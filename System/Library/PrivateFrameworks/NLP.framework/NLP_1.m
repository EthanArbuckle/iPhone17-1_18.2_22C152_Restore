void sub_1A43B438C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unordered_map<std::string,std::string>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unordered_map<std::string,std::string>>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

double std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unordered_map<std::string,std::string>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::unordered_map<std::string,std::string>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::unordered_map<std::string,std::string>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unordered_map<std::string,std::string>>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, long long **a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  v8 = (char *)operator new(0x50uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *(unsigned char *)(a4 + 16) = 0;
  *(void *)v8 = 0;
  *((void *)v8 + 1) = a2;
  v9 = (std::string *)(v8 + 16);
  v10 = *a3;
  if (*((char *)*a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)v10, *((void *)v10 + 1));
  }
  else
  {
    long long v11 = *v10;
    *((void *)v8 + 4) = *((void *)v10 + 2);
    *(_OWORD *)&v9->__r_.__value_.__l.__data_ = v11;
  }
  double result = 0.0;
  *(_OWORD *)(v8 + 56) = 0u;
  *(_OWORD *)(v8 + 40) = 0u;
  *((_DWORD *)v8 + 18) = 1065353216;
  *(unsigned char *)(a4 + 16) = 1;
  return result;
}

void sub_1A43B443C(_Unwind_Exception *a1)
{
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unordered_map<std::string,std::string>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unordered_map<std::string,std::string>>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unordered_map<std::string,std::string>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unordered_map<std::string,std::string>>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::unordered_map<std::string,std::unordered_map<std::string,std::string>>>,0>((uint64_t)v2 + 16);
    }
    operator delete(v2);
  }
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<std::string,std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<std::string,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1, unsigned __int8 *a2, uint64_t a3, long long **a4)
{
  v8 = (void *)(a1 + 24);
  unint64_t v9 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  unint64_t v10 = v9;
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    unint64_t v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v4 = v9;
      if (v9 >= v11) {
        unint64_t v4 = v9 % v11;
      }
    }
    else
    {
      unint64_t v4 = (v11 - 1) & v9;
    }
    v14 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v4);
    if (v14)
    {
      for (i = *v14; i; i = *(unsigned __int8 **)i)
      {
        unint64_t v16 = *((void *)i + 1);
        if (v16 == v10)
        {
          if (std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2)) {
            return i;
          }
        }
        else
        {
          if (v13 > 1)
          {
            if (v16 >= v11) {
              v16 %= v11;
            }
          }
          else
          {
            v16 &= v11 - 1;
          }
          if (v16 != v4) {
            break;
          }
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<std::string,std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<std::string,std::string>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1, v10, a4, (uint64_t)v26);
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v18 = *(float *)(a1 + 32);
  if (!v11 || (float)(v18 * (float)v11) < v17)
  {
    BOOL v19 = 1;
    if (v11 >= 3) {
      BOOL v19 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v11);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    std::__hash_table<std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<NLExtendedString>>>>::__rehash<true>(a1, v22);
    unint64_t v11 = *(void *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11) {
        unint64_t v4 = v10 % v11;
      }
      else {
        unint64_t v4 = v10;
      }
    }
    else
    {
      unint64_t v4 = (v11 - 1) & v10;
    }
  }
  v23 = *(void **)(*(void *)a1 + 8 * v4);
  if (v23)
  {
    *(void *)v26[0] = *v23;
    void *v23 = v26[0];
  }
  else
  {
    *(void *)v26[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v26[0];
    *(void *)(*(void *)a1 + 8 * v4) = a1 + 16;
    if (*(void *)v26[0])
    {
      unint64_t v24 = *(void *)(*(void *)v26[0] + 8);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v24 >= v11) {
          v24 %= v11;
        }
      }
      else
      {
        v24 &= v11 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v24) = v26[0];
    }
  }
  i = (unsigned __int8 *)v26[0];
  v26[0] = 0;
  ++*v8;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<std::string,std::string>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<std::string,std::string>>,void *>>>>::reset[abi:ne180100]((uint64_t)v26, 0);
  return i;
}

void sub_1A43B4730(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<std::string,std::string>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<std::string,std::string>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

double std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<std::string,std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<std::string,std::string>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, long long **a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  v8 = (char *)operator new(0x50uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *(unsigned char *)(a4 + 16) = 0;
  *(void *)v8 = 0;
  *((void *)v8 + 1) = a2;
  unint64_t v9 = (std::string *)(v8 + 16);
  unint64_t v10 = *a3;
  if (*((char *)*a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)v10, *((void *)v10 + 1));
  }
  else
  {
    long long v11 = *v10;
    *((void *)v8 + 4) = *((void *)v10 + 2);
    *(_OWORD *)&v9->__r_.__value_.__l.__data_ = v11;
  }
  double result = 0.0;
  *(_OWORD *)(v8 + 56) = 0u;
  *(_OWORD *)(v8 + 40) = 0u;
  *((_DWORD *)v8 + 18) = 1065353216;
  *(unsigned char *)(a4 + 16) = 1;
  return result;
}

void sub_1A43B47E0(_Unwind_Exception *a1)
{
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<std::string,std::string>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<std::string,std::string>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<std::string,std::string>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<std::string,std::string>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::unordered_map<std::string,std::string>>,0>((uint64_t)v2 + 16);
    }
    operator delete(v2);
  }
}

void std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unordered_map<std::string,std::string>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::unordered_map<std::string,std::string>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::unordered_map<std::string,std::string>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unordered_map<std::string,std::string>>>>>::__move_assign(uint64_t a1, uint64_t *a2)
{
  std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unordered_map<std::string,std::string>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::unordered_map<std::string,std::string>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::unordered_map<std::string,std::string>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unordered_map<std::string,std::string>>>>>::clear(a1);
  uint64_t v4 = *a2;
  *a2 = 0;
  v5 = *(void **)a1;
  *(void *)a1 = v4;
  if (v5) {
    operator delete(v5);
  }
  uint64_t v8 = a2[2];
  uint64_t v7 = a2 + 2;
  uint64_t v6 = v8;
  uint64_t v9 = *(v7 - 1);
  *(void *)(a1 + 16) = v8;
  *(void *)(a1 + 8) = v9;
  *(v7 - 1) = 0;
  uint64_t v10 = v7[1];
  *(void *)(a1 + 24) = v10;
  *(_DWORD *)(a1 + 32) = *((_DWORD *)v7 + 4);
  if (v10)
  {
    unint64_t v11 = *(void *)(v6 + 8);
    unint64_t v12 = *(void *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12) {
        v11 %= v12;
      }
    }
    else
    {
      v11 &= v12 - 1;
    }
    *(void *)(*(void *)a1 + 8 * v11) = a1 + 16;
    *uint64_t v7 = 0;
    v7[1] = 0;
  }
}

void std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unordered_map<std::string,std::string>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::unordered_map<std::string,std::string>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::unordered_map<std::string,std::string>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unordered_map<std::string,std::string>>>>>::clear(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unordered_map<std::string,std::string>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::unordered_map<std::string,std::string>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::unordered_map<std::string,std::string>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unordered_map<std::string,std::string>>>>>::__deallocate_node(a1, *(void **)(a1 + 16));
    *(void *)(a1 + 16) = 0;
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      for (uint64_t i = 0; i != v2; ++i)
        *(void *)(*(void *)a1 + 8 * i) = 0;
    }
    *(void *)(a1 + 24) = 0;
  }
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<std::string,std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<std::string,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(uint64_t a1, unsigned __int8 *a2, uint64_t a3, long long **a4)
{
  uint64_t v8 = (void *)(a1 + 24);
  unint64_t v9 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  unint64_t v10 = v9;
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    unint64_t v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v4 = v9;
      if (v9 >= v11) {
        unint64_t v4 = v9 % v11;
      }
    }
    else
    {
      unint64_t v4 = (v11 - 1) & v9;
    }
    v14 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v4);
    if (v14)
    {
      for (uint64_t i = *v14; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v16 = *((void *)i + 1);
        if (v16 == v10)
        {
          if (std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2)) {
            return i;
          }
        }
        else
        {
          if (v13 > 1)
          {
            if (v16 >= v11) {
              v16 %= v11;
            }
          }
          else
          {
            v16 &= v11 - 1;
          }
          if (v16 != v4) {
            break;
          }
        }
      }
    }
  }
  float v17 = (char *)operator new(0x50uLL);
  v29[0] = v17;
  v29[1] = a1 + 16;
  *(void *)float v17 = 0;
  *((void *)v17 + 1) = v10;
  float v18 = *a4;
  long long v19 = **a4;
  *((void *)v17 + 4) = *((void *)*a4 + 2);
  *((_OWORD *)v17 + 1) = v19;
  *((void *)v18 + 1) = 0;
  *((void *)v18 + 2) = 0;
  *(void *)float v18 = 0;
  *(_OWORD *)(v17 + 40) = 0u;
  *(_OWORD *)(v17 + 56) = 0u;
  *((_DWORD *)v17 + 18) = 1065353216;
  char v30 = 1;
  float v20 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v21 = *(float *)(a1 + 32);
  if (!v11 || (float)(v21 * (float)v11) < v20)
  {
    BOOL v22 = 1;
    if (v11 >= 3) {
      BOOL v22 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v23 = v22 | (2 * v11);
    unint64_t v24 = vcvtps_u32_f32(v20 / v21);
    if (v23 <= v24) {
      size_t v25 = v24;
    }
    else {
      size_t v25 = v23;
    }
    std::__hash_table<std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<NLExtendedString>>>>::__rehash<true>(a1, v25);
    unint64_t v11 = *(void *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11) {
        unint64_t v4 = v10 % v11;
      }
      else {
        unint64_t v4 = v10;
      }
    }
    else
    {
      unint64_t v4 = (v11 - 1) & v10;
    }
  }
  v26 = *(void **)(*(void *)a1 + 8 * v4);
  if (v26)
  {
    *(void *)v29[0] = *v26;
    void *v26 = v29[0];
  }
  else
  {
    *(void *)v29[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v29[0];
    *(void *)(*(void *)a1 + 8 * v4) = a1 + 16;
    if (*(void *)v29[0])
    {
      unint64_t v27 = *(void *)(*(void *)v29[0] + 8);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v27 >= v11) {
          v27 %= v11;
        }
      }
      else
      {
        v27 &= v11 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v27) = v29[0];
    }
  }
  uint64_t i = (unsigned __int8 *)v29[0];
  v29[0] = 0;
  ++*v8;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<std::string,std::string>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<std::string,std::string>>,void *>>>>::reset[abi:ne180100]((uint64_t)v29, 0);
  return i;
}

void sub_1A43B4BE8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<std::string,std::string>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<std::string,std::string>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,int> *,false>(uint64_t result, int *a2, uint64_t a3, uint64_t a4, char a5)
{
  unint64_t v10 = (int *)result;
LABEL_2:
  unint64_t v11 = v10;
LABEL_3:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    unint64_t v10 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = (char *)a2 - (char *)v11;
    unint64_t v15 = ((char *)a2 - (char *)v11) >> 3;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          int v23 = *(a2 - 2);
          int v24 = *v11;
          if (v23 < *v11 || v24 >= v23 && *(a2 - 1) < v11[1])
          {
            *unint64_t v11 = v23;
            *(a2 - 2) = v24;
            int v25 = v11[1];
            v11[1] = *(a2 - 1);
            *(a2 - 1) = v25;
          }
          break;
        case 3uLL:
          double result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,int> *>(v11, v11 + 2, a2 - 2);
          break;
        case 4uLL:
          double result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,int> *>(v11, v11 + 2, v11 + 4, a2 - 2);
          break;
        case 5uLL:
          double result = std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,int> *>(v11, v11 + 2, v11 + 4, v11 + 6, a2 - 2);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v14 <= 191) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != a2)
      {
        return (uint64_t)std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,int> *,std::pair<int,int> *>(v11, a2, a2, a3);
      }
      return result;
    }
    unint64_t v16 = v15 >> 1;
    float v17 = &v11[2 * (v15 >> 1)];
    if ((unint64_t)v14 >= 0x401)
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,int> *>(v11, &v11[2 * (v15 >> 1)], a2 - 2);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,int> *>(v11 + 2, v17 - 2, a2 - 4);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,int> *>(v11 + 4, &v11[2 * v16 + 2], a2 - 6);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,int> *>(v17 - 2, v17, &v11[2 * v16 + 2]);
      uint64_t v18 = *(void *)v11;
      *(void *)unint64_t v11 = *(void *)v17;
      *(void *)float v17 = v18;
      if (a5) {
        goto LABEL_16;
      }
    }
    else
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,int> *>(&v11[2 * (v15 >> 1)], v11, a2 - 2);
      if (a5) {
        goto LABEL_16;
      }
    }
    int v19 = *(v11 - 2);
    if (v19 >= *v11 && (*v11 < v19 || *(v11 - 1) >= v11[1]))
    {
      double result = (uint64_t)std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,std::pair<int,int> *,std::__less<void,void> &>(v11, a2);
      unint64_t v11 = (int *)result;
      goto LABEL_21;
    }
LABEL_16:
    float v20 = std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,std::pair<int,int> *,std::__less<void,void> &>(v11, a2);
    if ((v21 & 1) == 0) {
      goto LABEL_19;
    }
    BOOL v22 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,int> *>(v11, v20);
    unint64_t v11 = v20 + 2;
    double result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,int> *>(v20 + 2, a2);
    if (result)
    {
      a4 = -v13;
      a2 = v20;
      if (v22) {
        return result;
      }
      goto LABEL_2;
    }
    uint64_t v12 = v13 + 1;
    if (!v22)
    {
LABEL_19:
      double result = std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,int> *,false>(v10, v20, a3, -v13, a5 & 1);
      unint64_t v11 = v20 + 2;
LABEL_21:
      a5 = 0;
      a4 = -v13;
      goto LABEL_3;
    }
  }
  if (a5)
  {
    return (uint64_t)std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,int> *>(v11, a2);
  }
  else
  {
    return (uint64_t)std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,int> *>(v11, a2);
  }
}

_DWORD *std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,int> *>(_DWORD *result, _DWORD *a2)
{
  if (result == a2) {
    return result;
  }
  uint64_t v2 = result + 2;
  if (result + 2 == a2) {
    return result;
  }
  uint64_t v3 = 0;
  unint64_t v4 = result;
  do
  {
    char v5 = v4;
    unint64_t v4 = v2;
    int v6 = v5[2];
    int v7 = *v5;
    if (v6 >= *v5 && (v7 < v6 || v5[3] >= v5[1])) {
      goto LABEL_18;
    }
    int v9 = v5[2];
    int v8 = v5[3];
    int v10 = v5[1];
    v5[2] = v7;
    v4[1] = v10;
    unint64_t v11 = result;
    if (v5 == result) {
      goto LABEL_17;
    }
    uint64_t v12 = v3;
    while (1)
    {
      int v13 = *(_DWORD *)((char *)result + v12 - 8);
      if (v13 <= v9) {
        break;
      }
      int v14 = *(_DWORD *)((char *)result + v12 - 4);
LABEL_11:
      v5 -= 2;
      unint64_t v15 = (_DWORD *)((char *)result + v12);
      *unint64_t v15 = v13;
      v15[1] = v14;
      v12 -= 8;
      if (!v12)
      {
        unint64_t v11 = result;
        goto LABEL_17;
      }
    }
    if (v13 >= v9)
    {
      unint64_t v11 = (_DWORD *)((char *)result + v12);
      int v14 = *(_DWORD *)((char *)result + v12 - 4);
      if (v14 <= v8) {
        goto LABEL_17;
      }
      goto LABEL_11;
    }
    unint64_t v11 = v5;
LABEL_17:
    *unint64_t v11 = v9;
    v11[1] = v8;
LABEL_18:
    uint64_t v2 = v4 + 2;
    v3 += 8;
  }
  while (v4 + 2 != a2);
  return result;
}

int *std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,int> *>(int *result, int *a2)
{
  if (result != a2)
  {
    uint64_t v2 = result + 2;
    if (result + 2 != a2)
    {
      uint64_t v3 = result + 1;
      do
      {
        unint64_t v4 = result;
        double result = v2;
        int v5 = v4[2];
        int v6 = *v4;
        if (v5 < *v4 || v6 >= v5 && v4[3] < v4[1])
        {
          int v7 = *result;
          int v8 = result[1];
          for (uint64_t i = v3; ; i -= 2)
          {
            int v10 = *i;
            i[1] = v6;
            i[2] = v10;
            int v6 = *(i - 3);
            if (v6 <= v7 && (v6 < v7 || *(i - 2) <= v8)) {
              break;
            }
          }
          *(i - 1) = v7;
          int *i = v8;
        }
        uint64_t v2 = result + 2;
        v3 += 2;
      }
      while (result + 2 != a2);
    }
  }
  return result;
}

uint64_t std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,int> *>(int *a1, int *a2, int *a3)
{
  int v3 = *a2;
  int v4 = *a1;
  if (*a2 >= *a1 && (v4 < v3 || a2[1] >= a1[1]))
  {
    int v9 = *a3;
    if (*a3 >= v3 && (v3 < v9 || a3[1] >= a2[1])) {
      return 0;
    }
    *a2 = v9;
    *a3 = v3;
    unint64_t v11 = a2 + 1;
    int v10 = a2[1];
    a2[1] = a3[1];
    a3[1] = v10;
    int v12 = *a2;
    int v13 = *a1;
    if (*a2 >= *a1 && (v13 < v12 || *v11 >= a1[1])) {
      return 1;
    }
    *a1 = v12;
    int v6 = a1 + 1;
    *a2 = v13;
    uint64_t v8 = 2;
  }
  else
  {
    int v5 = *a3;
    if (*a3 < v3 || v3 >= v5 && a3[1] < a2[1])
    {
      *a1 = v5;
      int v6 = a1 + 1;
      *a3 = v4;
      int v7 = a3 + 1;
      uint64_t v8 = 1;
    }
    else
    {
      *a1 = v3;
      *a2 = v4;
      int v14 = a1[1];
      a1[1] = a2[1];
      a2[1] = v14;
      int v15 = *a3;
      int v16 = *a2;
      if (*a3 >= *a2 && (v16 < v15 || a3[1] >= v14)) {
        return 1;
      }
      *a2 = v15;
      *a3 = v16;
      int v7 = a3 + 1;
      uint64_t v8 = 2;
      int v6 = a2 + 1;
    }
    unint64_t v11 = v7;
  }
  int v17 = *v6;
  *int v6 = *v11;
  *unint64_t v11 = v17;
  return v8;
}

int *std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,std::pair<int,int> *,std::__less<void,void> &>(int *a1, int *a2)
{
  int v3 = *a1;
  int v2 = a1[1];
  int v4 = *(a2 - 2);
  if (v4 <= *a1 && (v4 < v3 || *(a2 - 1) <= v2))
  {
    for (uint64_t i = a1 + 2; i < a2 && *i <= v3 && (*i < v3 || i[1] <= v2); i += 2)
      ;
  }
  else
  {
    uint64_t i = a1;
    do
    {
      int v7 = i[2];
      i += 2;
      int v6 = v7;
    }
    while (v7 <= v3 && (v6 < v3 || i[1] <= v2));
  }
  if (i < a2)
  {
    for (a2 -= 2; v4 > v3 || v4 >= v3 && a2[1] > v2; a2 -= 2)
    {
      int v8 = *(a2 - 2);
      int v4 = v8;
    }
  }
  if (i < a2)
  {
    int v9 = *i;
    int v10 = *a2;
    do
    {
      int *i = v10;
      *a2 = v9;
      int v11 = i[1];
      i[1] = a2[1];
      a2[1] = v11;
      do
      {
        int v12 = i[2];
        i += 2;
        int v9 = v12;
      }
      while (v12 <= v3 && (v9 < v3 || i[1] <= v2));
      do
      {
        do
        {
          int v13 = *(a2 - 2);
          a2 -= 2;
          int v10 = v13;
          BOOL v14 = v13 < v3;
        }
        while (v13 > v3);
      }
      while (!v14 && a2[1] > v2);
    }
    while (i < a2);
  }
  if (i - 2 != a1)
  {
    *a1 = *(i - 2);
    a1[1] = *(i - 1);
  }
  *(i - 2) = v3;
  *(i - 1) = v2;
  return i;
}

_DWORD *std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,std::pair<int,int> *,std::__less<void,void> &>(int *a1, _DWORD *a2)
{
  uint64_t v2 = 0;
  int v3 = *a1;
  int v4 = a1[1];
  while (1)
  {
    int v5 = a1[v2 + 2];
    if (v5 >= v3 && (v5 > v3 || a1[v2 + 3] >= v4)) {
      break;
    }
    v2 += 2;
  }
  unint64_t v6 = (unint64_t)&a1[v2 + 2];
  if (v2 * 4)
  {
    do
    {
      int v8 = *(a2 - 2);
      a2 -= 2;
      int v7 = v8;
    }
    while (v8 >= v3 && (v7 > v3 || a2[1] >= v4));
  }
  else
  {
LABEL_19:
    if (v6 < (unint64_t)a2)
    {
      do
      {
        int v10 = *(a2 - 2);
        a2 -= 2;
        int v9 = v10;
        if (v10 < v3) {
          break;
        }
        if (v9 > v3) {
          goto LABEL_19;
        }
      }
      while (a2[1] >= v4 && v6 < (unint64_t)a2);
    }
  }
  if (v6 >= (unint64_t)a2)
  {
    int v13 = (_DWORD *)v6;
  }
  else
  {
    int v12 = *a2;
    int v13 = (_DWORD *)v6;
    BOOL v14 = a2;
    do
    {
      *int v13 = v12;
      *BOOL v14 = v5;
      int v15 = v13[1];
      v13[1] = v14[1];
      v14[1] = v15;
      do
      {
        do
        {
          int v16 = v13[2];
          v13 += 2;
          int v5 = v16;
          BOOL v17 = v16 <= v3;
        }
        while (v16 < v3);
      }
      while (v17 && v13[1] < v4);
      do
      {
        int v18 = *(v14 - 2);
        v14 -= 2;
        int v12 = v18;
      }
      while (v18 >= v3 && (v12 > v3 || v14[1] >= v4));
    }
    while (v13 < v14);
  }
  if (v13 - 2 != a1)
  {
    *a1 = *(v13 - 2);
    a1[1] = *(v13 - 1);
  }
  *(v13 - 2) = v3;
  *(v13 - 1) = v4;
  return v13 - 2;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,int> *>(int *a1, int *a2)
{
  uint64_t v4 = ((char *)a2 - (char *)a1) >> 3;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      int v6 = *(a2 - 2);
      int v7 = *a1;
      if (v6 < *a1 || v7 >= v6 && *(a2 - 1) < a1[1])
      {
        *a1 = v6;
        *(a2 - 2) = v7;
        int v8 = a1[1];
        a1[1] = *(a2 - 1);
        *(a2 - 1) = v8;
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,int> *>(a1, a1 + 2, a2 - 2);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,int> *>(a1, a1 + 2, a1 + 4, a2 - 2);
      return 1;
    case 5:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,int> *>(a1, a1 + 2, a1 + 4, a1 + 6, a2 - 2);
      return 1;
    default:
      int v9 = a1 + 4;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,int> *>(a1, a1 + 2, a1 + 4);
      int v10 = a1 + 6;
      if (a1 + 6 == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  do
  {
    int v13 = *v9;
    if (*v10 >= *v9 && (v13 < *v10 || v10[1] >= v9[1])) {
      goto LABEL_22;
    }
    int v14 = *v10;
    int v15 = v10[1];
    int *v10 = v13;
    v10[1] = v9[1];
    int v16 = a1;
    if (v9 == a1) {
      goto LABEL_21;
    }
    uint64_t v17 = v11;
    while (1)
    {
      int v18 = (char *)a1 + v17;
      int v19 = *(int *)((char *)a1 + v17 + 8);
      if (v19 > v14)
      {
        int v20 = *((_DWORD *)v18 + 3);
        goto LABEL_17;
      }
      if (v19 < v14)
      {
        int v16 = v9;
        goto LABEL_21;
      }
      int v20 = *(int *)((char *)a1 + v17 + 12);
      if (v20 <= v15) {
        break;
      }
LABEL_17:
      v9 -= 2;
      *((_DWORD *)v18 + 4) = v19;
      *(int *)((char *)a1 + v17 + 20) = v20;
      v17 -= 8;
      if (v17 == -16)
      {
        int v16 = a1;
        goto LABEL_21;
      }
    }
    int v16 = (int *)((char *)a1 + v17 + 16);
LABEL_21:
    *int v16 = v14;
    v16[1] = v15;
    if (++v12 == 8) {
      return v10 + 2 == a2;
    }
LABEL_22:
    int v9 = v10;
    v11 += 8;
    v10 += 2;
  }
  while (v10 != a2);
  return 1;
}

uint64_t std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,int> *>(int *a1, int *a2, int *a3, int *a4)
{
  uint64_t result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,int> *>(a1, a2, a3);
  int v9 = *a4;
  int v10 = *a3;
  if (*a4 < *a3 || v10 >= v9 && a4[1] < a3[1])
  {
    *a3 = v9;
    *a4 = v10;
    int v11 = a3[1];
    a3[1] = a4[1];
    a4[1] = v11;
    int v12 = *a3;
    int v13 = *a2;
    if (*a3 < *a2 || v13 >= v12 && a3[1] < a2[1])
    {
      *a2 = v12;
      *a3 = v13;
      int v14 = a2[1];
      a2[1] = a3[1];
      a3[1] = v14;
      int v15 = *a2;
      int v16 = *a1;
      if (*a2 < *a1 || v16 >= v15 && a2[1] < a1[1])
      {
        *a1 = v15;
        *a2 = v16;
        int v17 = a1[1];
        a1[1] = a2[1];
        a2[1] = v17;
      }
    }
  }
  return result;
}

uint64_t std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,int> *>(int *a1, int *a2, int *a3, int *a4, int *a5)
{
  uint64_t result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,int> *>(a1, a2, a3, a4);
  int v11 = *a5;
  int v12 = *a4;
  if (*a5 < *a4 || v12 >= v11 && a5[1] < a4[1])
  {
    *a4 = v11;
    *a5 = v12;
    int v13 = a4[1];
    a4[1] = a5[1];
    a5[1] = v13;
    int v14 = *a4;
    int v15 = *a3;
    if (*a4 < *a3 || v15 >= v14 && a4[1] < a3[1])
    {
      *a3 = v14;
      *a4 = v15;
      int v16 = a3[1];
      a3[1] = a4[1];
      a4[1] = v16;
      int v17 = *a3;
      int v18 = *a2;
      if (*a3 < *a2 || v18 >= v17 && a3[1] < a2[1])
      {
        *a2 = v17;
        *a3 = v18;
        int v19 = a2[1];
        a2[1] = a3[1];
        a3[1] = v19;
        int v20 = *a2;
        int v21 = *a1;
        if (*a2 < *a1 || v21 >= v20 && a2[1] < a1[1])
        {
          *a1 = v20;
          *a2 = v21;
          int v22 = a1[1];
          a1[1] = a2[1];
          a2[1] = v22;
        }
      }
    }
  }
  return result;
}

int *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,int> *,std::pair<int,int> *>(int *a1, int *a2, int *a3, uint64_t a4)
{
  if (a1 != a2)
  {
    uint64_t v8 = (char *)a2 - (char *)a1;
    uint64_t v9 = ((char *)a2 - (char *)a1) >> 3;
    if ((char *)a2 - (char *)a1 >= 9)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      int v12 = &a1[2 * v10];
      do
      {
        std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,int> *>((uint64_t)a1, a4, v9, v12);
        v12 -= 2;
        --v11;
      }
      while (v11);
    }
    int v13 = a2;
    if (a2 != a3)
    {
      int v14 = a2;
      do
      {
        int v15 = *v14;
        int v16 = *a1;
        if (*v14 < *a1 || v16 >= v15 && v14[1] < a1[1])
        {
          *int v14 = v16;
          *a1 = v15;
          int v17 = v14[1];
          v14[1] = a1[1];
          a1[1] = v17;
          std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,int> *>((uint64_t)a1, a4, v9, a1);
        }
        v14 += 2;
      }
      while (v14 != a3);
      int v13 = a3;
    }
    if (v8 >= 9)
    {
      uint64_t v18 = (unint64_t)v8 >> 3;
      int v19 = a2 - 2;
      do
      {
        int v21 = *a1;
        int v20 = a1[1];
        int v22 = std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,int> *>(a1, a4, v18);
        if (v19 == v22)
        {
          *int v22 = v21;
          v22[1] = v20;
        }
        else
        {
          *int v22 = *v19;
          v22[1] = v19[1];
          *int v19 = v21;
          v19[1] = v20;
          std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,int> *>((uint64_t)a1, (uint64_t)(v22 + 2), a4, ((char *)(v22 + 2) - (char *)a1) >> 3);
        }
        v19 -= 2;
      }
      while (v18-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,int> *>(uint64_t result, uint64_t a2, uint64_t a3, int *a4)
{
  if (a3 >= 2)
  {
    uint64_t v4 = (uint64_t)a4 - result;
    int64_t v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 3)
    {
      uint64_t v6 = v4 >> 2;
      uint64_t v7 = (v4 >> 2) + 1;
      uint64_t v8 = (int *)(result + 8 * v7);
      uint64_t v9 = v6 + 2;
      if (v9 < a3)
      {
        int v10 = v8[2];
        if (*v8 < v10 || v10 >= *v8 && *(_DWORD *)(result + 8 * v7 + 4) < v8[3])
        {
          v8 += 2;
          uint64_t v7 = v9;
        }
      }
      int v11 = *v8;
      if (*v8 >= *a4 && (*a4 < v11 || v8[1] >= a4[1]))
      {
        int v12 = *a4;
        int v13 = a4[1];
        *a4 = v11;
        a4[1] = v8[1];
        if (v5 >= v7)
        {
          while (1)
          {
            uint64_t v15 = 2 * v7;
            uint64_t v7 = (2 * v7) | 1;
            int v14 = (int *)(result + 8 * v7);
            uint64_t v16 = v15 + 2;
            if (v16 < a3)
            {
              int v17 = v14[2];
              if (*v14 < v17 || v17 >= *v14 && *(_DWORD *)(result + 8 * v7 + 4) < v14[3])
              {
                v14 += 2;
                uint64_t v7 = v16;
              }
            }
            int v18 = *v14;
            if (*v14 < v12 || v18 <= v12 && v14[1] < v13) {
              break;
            }
            int *v8 = v18;
            v8[1] = v14[1];
            uint64_t v8 = v14;
            if (v5 < v7) {
              goto LABEL_22;
            }
          }
        }
        int v14 = v8;
LABEL_22:
        *int v14 = v12;
        v14[1] = v13;
      }
    }
  }
  return result;
}

_DWORD *std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,int> *>(_DWORD *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = 0;
  uint64_t v4 = a3 - 2;
  if (a3 < 2) {
    uint64_t v4 = a3 - 1;
  }
  uint64_t v5 = v4 >> 1;
  do
  {
    uint64_t v6 = result;
    uint64_t v7 = v3 + 1;
    result += 2 * v3 + 2;
    uint64_t v8 = 2 * v3;
    uint64_t v3 = (2 * v3) | 1;
    uint64_t v9 = v8 + 2;
    if (v9 < a3)
    {
      int v10 = result[2];
      if (*result < v10 || v10 >= *result && v6[2 * v7 + 1] < result[3])
      {
        result += 2;
        uint64_t v3 = v9;
      }
    }
    *uint64_t v6 = *result;
    v6[1] = result[1];
  }
  while (v3 <= v5);
  return result;
}

uint64_t std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<int,int> *>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = a4 - 2;
  if (a4 >= 2)
  {
    unint64_t v5 = v4 >> 1;
    uint64_t v6 = (int *)(result + 8 * (v4 >> 1));
    int v7 = *v6;
    int v8 = *(_DWORD *)(a2 - 8);
    if (*v6 < v8 || v8 >= v7 && *(_DWORD *)(result + 8 * v5 + 4) < *(_DWORD *)(a2 - 4))
    {
      int v9 = *(_DWORD *)(a2 - 8);
      int v10 = *(_DWORD *)(a2 - 4);
      *(_DWORD *)(a2 - 8) = v7;
      *(_DWORD *)(a2 - 4) = v6[1];
      if (v4 >= 2)
      {
        while (1)
        {
          unint64_t v12 = v5 - 1;
          unint64_t v5 = (v5 - 1) >> 1;
          int v11 = (int *)(result + 8 * v5);
          int v13 = *v11;
          if (*v11 >= v9)
          {
            if (v13 > v9) {
              break;
            }
            int v14 = *(_DWORD *)(result + 8 * v5 + 4);
            if (v14 >= v10) {
              break;
            }
          }
          else
          {
            int v14 = v11[1];
          }
          *uint64_t v6 = v13;
          v6[1] = v14;
          uint64_t v6 = (int *)(result + 8 * v5);
          if (v12 <= 1) {
            goto LABEL_12;
          }
        }
      }
      int v11 = v6;
LABEL_12:
      *int v11 = v9;
      v11[1] = v10;
    }
  }
  return result;
}

void *std::vector<float>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<float>::__vallocate[abi:ne180100](a1, a2);
    unint64_t v4 = (char *)a1[1];
    bzero(v4, 4 * a2);
    a1[1] = &v4[4 * a2];
  }
  return a1;
}

void sub_1A43B5DF8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__hash_table<std::__hash_value_type<int,std::unordered_map<int,float>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_map<int,float>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_map<int,float>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_map<int,float>>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<int,std::unordered_map<int,float>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_map<int,float>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_map<int,float>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_map<int,float>>>>::__deallocate_node(a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<int,std::unordered_map<int,float>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_map<int,float>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_map<int,float>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_map<int,float>>>>::__deallocate_node(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    do
    {
      uint64_t v3 = (void *)*v2;
      std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::~__hash_table((uint64_t)(v2 + 3));
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  unint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

uint64_t *std::__hash_table<std::__hash_value_type<int,std::unordered_map<int,float>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_map<int,float>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_map<int,float>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_map<int,float>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int &&>,std::tuple<>>(uint64_t a1, int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
    int v10 = *(uint64_t ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      for (uint64_t i = *v10; i; uint64_t i = (uint64_t *)*i)
      {
        unint64_t v12 = i[1];
        if (v12 == v7)
        {
          if (*((_DWORD *)i + 4) == v7) {
            return i;
          }
        }
        else
        {
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= v8) {
              v12 %= v8;
            }
          }
          else
          {
            v12 &= v8 - 1;
          }
          if (v12 != v4) {
            break;
          }
        }
      }
    }
  }
  uint64_t v13 = a1 + 16;
  int v14 = (char *)operator new(0x40uLL);
  v24[0] = v14;
  v24[1] = a1 + 16;
  *(void *)int v14 = 0;
  *((void *)v14 + 1) = v7;
  *((_DWORD *)v14 + 4) = **a4;
  *(_OWORD *)(v14 + 40) = 0u;
  *(_OWORD *)(v14 + 24) = 0u;
  *((_DWORD *)v14 + 14) = 1065353216;
  char v25 = 1;
  float v15 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v16 = *(float *)(a1 + 32);
  if (!v8 || (float)(v16 * (float)v8) < v15)
  {
    BOOL v17 = 1;
    if (v8 >= 3) {
      BOOL v17 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v8);
    unint64_t v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19) {
      size_t v20 = v19;
    }
    else {
      size_t v20 = v18;
    }
    std::__hash_table<std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<NLExtendedString>>>>::__rehash<true>(a1, v20);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }
  int v21 = *(void **)(*(void *)a1 + 8 * v4);
  if (v21)
  {
    *(void *)v24[0] = *v21;
    *int v21 = v24[0];
  }
  else
  {
    *(void *)v24[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v24[0];
    *(void *)(*(void *)a1 + 8 * v4) = v13;
    if (*(void *)v24[0])
    {
      unint64_t v22 = *(void *)(*(void *)v24[0] + 8);
      if ((v8 & (v8 - 1)) != 0)
      {
        if (v22 >= v8) {
          v22 %= v8;
        }
      }
      else
      {
        v22 &= v8 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v22) = v24[0];
    }
  }
  uint64_t i = (uint64_t *)v24[0];
  v24[0] = 0;
  ++*(void *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<int,std::unordered_map<int,float>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<int,std::unordered_map<int,float>>,void *>>>>::reset[abi:ne180100]((uint64_t)v24, 0);
  return i;
}

void sub_1A43B6138(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<int,std::unordered_map<int,float>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<int,std::unordered_map<int,float>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<int,std::unordered_map<int,float>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<int,std::unordered_map<int,float>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::~__hash_table((uint64_t)v2 + 24);
    }
    operator delete(v2);
  }
}

void *std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(uint64_t a1, int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
    int v10 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      int v11 = *v10;
      if (*v10)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v12 == v7)
          {
            if (*((_DWORD *)v11 + 4) == v7) {
              return v11;
            }
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8) {
                v12 %= v8;
              }
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v4) {
              break;
            }
          }
          int v11 = (void *)*v11;
        }
        while (v11);
      }
    }
  }
  int v11 = operator new(0x18uLL);
  *int v11 = 0;
  v11[1] = v7;
  *((_DWORD *)v11 + 4) = **a4;
  *((_DWORD *)v11 + 5) = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v8 || (float)(v14 * (float)v8) < v13)
  {
    BOOL v15 = 1;
    if (v8 >= 3) {
      BOOL v15 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v8);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    std::__hash_table<std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<NLExtendedString>>>>::__rehash<true>(a1, v18);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }
  uint64_t v19 = *(void *)a1;
  size_t v20 = *(void **)(*(void *)a1 + 8 * v4);
  if (v20)
  {
    *int v11 = *v20;
LABEL_38:
    *size_t v20 = v11;
    goto LABEL_39;
  }
  *int v11 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v11;
  *(void *)(v19 + 8 * v4) = a1 + 16;
  if (*v11)
  {
    unint64_t v21 = *(void *)(*v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v21 >= v8) {
        v21 %= v8;
      }
    }
    else
    {
      v21 &= v8 - 1;
    }
    size_t v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v11;
}

void sub_1A43B63B4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<std::unique_ptr<NLMessageIntentCandidate>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    std::unique_ptr<NLMessageIntentCandidate>::reset[abi:ne180100]((uint64_t *)(i - 8), 0);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

CFStringRef containsNonNamePunctuation(const __CFString *result)
{
  if (result)
  {
    CFStringRef v1 = result;
    CFIndex Length = CFStringGetLength(result);
    CFCharacterSetRef Predefined = CFCharacterSetGetPredefined(kCFCharacterSetPunctuation);
    v5.location = 0;
    v5.length = 1;
    uint64_t result = (const __CFString *)1;
    if (!CFStringFindCharacterFromSet(v1, Predefined, v5, 0, 0))
    {
      CFCharacterSetRef v4 = CFCharacterSetGetPredefined(kCFCharacterSetLetter);
      v6.location = 0;
      v6.length = Length;
      if (CFStringFindCharacterFromSet(v1, v4, v6, 0, 0)) {
        return 0;
      }
    }
  }
  return result;
}

CFStringRef lookslikeProperName(CFStringRef theString, uint64_t a2, uint64_t a3, int a4)
{
  CFStringRef v4 = theString;
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  if (theString)
  {
    if (CFStringGetLength(theString) && (containsNonNamePunctuation(v4) & 1) == 0)
    {
      CFStringRef v8 = a4
         ? CFStringCreateWithFormat(0, 0, @"(kMDItemRecipients=\"%@*\"cwd || kMDItemRecipientEmailAddresses=\"%@\"cd || kMDItemAuthors=\"%@*\"cwd || kMDItemAuthorEmailAddresses=\"%@\"cd)", v4, v4, v4, v4): CFStringCreateWithFormat(0, 0, @"(kMDItemRecipients=\"%@*\"cwd || kMDItemRecipientEmailAddresses=\"%@@*\"cd || kMDItemAuthors=\"%@*\"cwd || kMDItemAuthorEmailAddresses=\"%@@*\"cd)", v4, v4, v4, v4);
      if (v8)
      {
        CFStringRef v9 = v8;
        uint64_t v39 = 0;
        v40 = &v39;
        uint64_t v41 = 0x2000000000;
        int v42 = 0;
        uint64_t v35 = 0;
        v36 = &v35;
        uint64_t v37 = 0x2000000000;
        char v38 = 0;
        if (getDynamicNamesQueue(void)::namesOnce != -1) {
          dispatch_once(&getDynamicNamesQueue(void)::namesOnce, &__block_literal_global_74);
        }
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 0x40000000;
        block[2] = __lookslikeProperName_block_invoke;
        block[3] = &unk_1E5B36398;
        block[4] = &v35;
        block[5] = &v39;
        block[6] = v4;
        dispatch_sync((dispatch_queue_t)getDynamicNamesQueue(void)::dynamicNamesQueue, block);
        int v10 = v36;
        int v11 = *((unsigned __int8 *)v36 + 24);
        if (*((unsigned char *)v36 + 24) && a4 && *((_DWORD *)v40 + 6) == 1) {
          *((unsigned char *)v36 + 24) = 1;
        }
        if (!v11 || (a4 & 1) != 0)
        {
          if (!v11)
          {
            CFStringRef v13 = (const __CFString *)CFPreferencesCopyValue(@"NLSearchNameCheckTimeout", @"com.apple.NLP", (CFStringRef)*MEMORY[0x1E4F1D3F0], (CFStringRef)*MEMORY[0x1E4F1D3C8]);
            CFStringRef v14 = v13;
            CFStringRef v33 = v13;
            double DoubleValue = 0.09;
            if (v13)
            {
              CFTypeID v16 = CFGetTypeID(v13);
              if (v16 == CFStringGetTypeID()) {
                double DoubleValue = CFStringGetDoubleValue(v14);
              }
            }
            if ((a3 & 0xFFFFFFFFFFFFFFFELL) != 2 || !CoreSpotlightLibraryCore(0)) {
              goto LABEL_47;
            }
            if (CFPreferencesGetAppBooleanValue(@"NLSearchEnableLogging", (CFStringRef)*MEMORY[0x1E4F1D3B8], 0))
            {
              unint64_t v17 = _nlpDefaultLog();
              if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG)) {
                lookslikeProperName_cold_1(v17);
              }
            }
            *(_OWORD *)values = xmmword_1E5B36B60;
            CFArrayRef v18 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)values, 2, MEMORY[0x1E4F1D510]);
            if (!v18) {
              goto LABEL_47;
            }
            CFArrayRef v19 = CFLocaleCopyPreferredLanguages();
            if (v19)
            {
              if (a2) {
                uint64_t v20 = MEMORY[0x1A625A3A0](a2);
              }
              else {
                uint64_t v20 = 0;
              }
              uint64_t v29 = 0;
              char v30 = &v29;
              uint64_t v31 = 0x2000000000;
              char v32 = 0;
              unint64_t v22 = dispatch_group_create();
              dispatch_group_enter(v22);
              v28[0] = MEMORY[0x1E4F143A8];
              v28[1] = 0x40000000;
              v28[2] = __lookslikeProperName_block_invoke_20;
              v28[3] = &unk_1E5B36B78;
              v28[4] = &v29;
              v28[5] = v22;
              uint64_t HasResultsForQuery = _CSSimpleQueryHasResultsForQuery((uint64_t)v9, (uint64_t)v18, v20, (uint64_t)v19, (uint64_t)v28);
              dispatch_time_t v24 = dispatch_time(0, (uint64_t)(DoubleValue * 1000000000.0));
              if (dispatch_group_wait(v22, v24)) {
                _CSSimpleQueryCancel(HasResultsForQuery);
              }
              dispatch_release(v22);
              int v25 = *((unsigned __int8 *)v30 + 24);
              CFRelease(v19);
              BOOL v21 = v25 != 0;
              _Block_object_dispose(&v29, 8);
            }
            else
            {
              BOOL v21 = 0;
            }
            CFRelease(v18);
            if (v21)
            {
              if (a4) {
                int v26 = 1;
              }
              else {
                int v26 = 2;
              }
              *((_DWORD *)v40 + 6) = v26;
              CFRetain(v4);
              if (getDynamicNamesQueue(void)::namesOnce != -1) {
                dispatch_once(&getDynamicNamesQueue(void)::namesOnce, &__block_literal_global_74);
              }
              v27[0] = MEMORY[0x1E4F143A8];
              v27[1] = 0x40000000;
              v27[2] = __lookslikeProperName_block_invoke_2;
              v27[3] = &unk_1E5B36BC0;
              v27[4] = &v39;
              v27[5] = v4;
              dispatch_async((dispatch_queue_t)getDynamicNamesQueue(void)::dynamicNamesQueue, v27);
              CFStringRef v4 = (CFStringRef)1;
            }
            else
            {
LABEL_47:
              CFStringRef v4 = 0;
            }
            CFRelease(v9);
            if (v14) {
              CFRelease(v14);
            }
            goto LABEL_22;
          }
        }
        else if (*((_DWORD *)v40 + 6) == 2)
        {
          *((unsigned char *)v10 + 24) = 1;
        }
        CFRelease(v9);
        CFStringRef v4 = (CFStringRef)(*((unsigned char *)v36 + 24) != 0);
LABEL_22:
        _Block_object_dispose(&v35, 8);
        _Block_object_dispose(&v39, 8);
        return v4;
      }
    }
    return 0;
  }
  return v4;
}

void sub_1A43B6978(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,const void *a29)
{
  nlp::CFScopedPtr<void const*>::reset(&a29, 0);
  _Block_object_dispose((const void *)(v29 - 208), 8);
  _Block_object_dispose((const void *)(v29 - 176), 8);
  _Unwind_Resume(a1);
}

BOOL __lookslikeProperName_block_invoke(uint64_t a1)
{
  if (getProperNames(void)::propernamesOnce != -1) {
    dispatch_once(&getProperNames(void)::propernamesOnce, &__block_literal_global_78);
  }
  BOOL result = searchBurstTrie((nlp *)getProperNames(void)::propernames, *(CFStringRef *)(a1 + 48), (_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

BOOL searchBurstTrie(nlp *a1, CFStringRef theString, _DWORD *a3)
{
  v12[1] = *MEMORY[0x1E4F143B8];
  CFIndex Length = CFStringGetLength(theString);
  CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  MEMORY[0x1F4188790]();
  CFStringRef v8 = (char *)v12 - v7;
  CFStringGetCString(theString, (char *)v12 - v7, v9, 0x8000100u);
  size_t v10 = strlen(v8);
  return nlp::BurstTrieContains(a1, v8, v10, a3, 0) != 0;
}

uint64_t _CSSimpleQueryHasResultsForQuery(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = 0;
  CFTypeID v16 = &v15;
  uint64_t v17 = 0x2000000000;
  size_t v10 = getCSSimpleQueryHasResultsForQuerySymbolLoc(void)::ptr;
  CFArrayRef v18 = getCSSimpleQueryHasResultsForQuerySymbolLoc(void)::ptr;
  if (!getCSSimpleQueryHasResultsForQuerySymbolLoc(void)::ptr)
  {
    int v11 = (void *)CoreSpotlightLibrary();
    v16[3] = (uint64_t)dlsym(v11, "CSSimpleQueryHasResultsForQuery");
    getCSSimpleQueryHasResultsForQuerySymbolLoc(void)::ptr = (_UNKNOWN *)v16[3];
    size_t v10 = (void *)v16[3];
  }
  _Block_object_dispose(&v15, 8);
  if (!v10)
  {
    _CSSimpleQueryHasResultsForQuery();
    CFStringRef v14 = v13;
    _Block_object_dispose(&v15, 8);
    _Unwind_Resume(v14);
  }
  return ((uint64_t (*)(uint64_t, uint64_t, void, uint64_t, uint64_t, void, uint64_t))v10)(a1, a2, 0, a3, a4, 0, a5);
}

void __lookslikeProperName_block_invoke_20(uint64_t a1, int a2, int a3)
{
  if (a2 && a3) {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
}

uint64_t _CSSimpleQueryCancel(uint64_t a1)
{
  uint64_t v7 = 0;
  CFStringRef v8 = &v7;
  uint64_t v9 = 0x2000000000;
  uint64_t v2 = (uint64_t (*)(uint64_t))getCSSimpleQueryCancelSymbolLoc(void)::ptr;
  size_t v10 = getCSSimpleQueryCancelSymbolLoc(void)::ptr;
  if (!getCSSimpleQueryCancelSymbolLoc(void)::ptr)
  {
    uint64_t v3 = (void *)CoreSpotlightLibrary();
    v8[3] = (uint64_t)dlsym(v3, "CSSimpleQueryCancel");
    getCSSimpleQueryCancelSymbolLoc(void)::ptr = (_UNKNOWN *)v8[3];
    uint64_t v2 = (uint64_t (*)(uint64_t))v8[3];
  }
  _Block_object_dispose(&v7, 8);
  if (!v2)
  {
    _CSSimpleQueryHasResultsForQuery();
    CFRange v6 = v5;
    _Block_object_dispose(&v7, 8);
    _Unwind_Resume(v6);
  }
  return v2(a1);
}

void __lookslikeProperName_block_invoke_2(uint64_t a1)
{
  v8[4] = *MEMORY[0x1E4F143B8];
  if (getProperNames(void)::propernamesOnce != -1) {
    dispatch_once(&getProperNames(void)::propernamesOnce, &__block_literal_global_78);
  }
  if (nlp::BurstTrieGetCount(getProperNames(void)::propernames) == 2000)
  {
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    if (Mutable)
    {
      CFArrayRef v3 = Mutable;
      if (getProperNames(void)::propernamesOnce != -1) {
        dispatch_once(&getProperNames(void)::propernamesOnce, &__block_literal_global_78);
      }
      CFStringRef v4 = (nlp *)getProperNames(void)::propernames;
      v8[0] = &unk_1EF7CDF08;
      v8[1] = _Block_copy(&__block_literal_global_5);
      v8[3] = v8;
      nlp::BurstTrieSearch(v4, "", 0, (uint64_t)v3, (uint64_t)v8, -1);
      std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL *)>::~__value_func[abi:ne180100](v8);
      CFIndex Count = CFArrayGetCount(v3);
      if (Count >= 1)
      {
        for (CFIndex i = 0; i != Count; ++i)
        {
          CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v3, i);
          if (getProperNames(void)::propernamesOnce != -1) {
            dispatch_once(&getProperNames(void)::propernamesOnce, &__block_literal_global_78);
          }
          removeFromBurstTrie((_DWORD *)getProperNames(void)::propernames, ValueAtIndex);
        }
      }
      CFRelease(v3);
    }
  }
  if (getProperNames(void)::propernamesOnce != -1) {
    dispatch_once(&getProperNames(void)::propernamesOnce, &__block_literal_global_78);
  }
  addToBurstTrie(getProperNames(void)::propernames, *(CFStringRef *)(a1 + 40));
  CFRelease(*(CFTypeRef *)(a1 + 40));
}

void sub_1A43B6FB4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL *)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void __lookslikeProperName_block_invoke_3(uint64_t a1, __CFArray *a2, _DWORD *a3)
{
  double Score = nlp::TrieCompletionGetScore(a3);
  if (*(float *)&Score <= 1.0)
  {
    CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    Completion = (const UInt8 *)nlp::TrieCompletionGetCompletion((uint64_t)a3);
    unsigned int Length = nlp::TrieCompletionGetLength((uint64_t)a3);
    CFStringRef v9 = CFStringCreateWithBytes(v6, Completion, Length, 0x8000100u, 0);
    if (v9)
    {
      CFStringRef v10 = v9;
      CFArrayAppendValue(a2, v9);
      CFRelease(v10);
    }
  }
}

uint64_t removeFromBurstTrie(_DWORD *a1, CFStringRef theString)
{
  v10[1] = *MEMORY[0x1E4F143B8];
  CFIndex Length = CFStringGetLength(theString);
  CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  MEMORY[0x1F4188790]();
  CFAllocatorRef v6 = (char *)v10 - v5;
  CFStringGetCString(theString, (char *)v10 - v5, v7, 0x8000100u);
  int v8 = strlen(v6);
  return nlp::BurstTrieRemove(a1, v6, v8);
}

BOOL addToBurstTrie(uint64_t a1, CFStringRef theString)
{
  v10[1] = *MEMORY[0x1E4F143B8];
  CFIndex Length = CFStringGetLength(theString);
  CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  MEMORY[0x1F4188790]();
  CFAllocatorRef v6 = (char *)v10 - v5;
  CFStringGetCString(theString, (char *)v10 - v5, v7, 0x8000100u);
  int v8 = strlen(v6);
  return nlp::BurstTrieAdd(a1, (uint64_t)v6, v8, 1);
}

void NL::EntityConverter::EntityConverter(void *a1, void *a2)
{
  uint64_t v2 = a2[1];
  *a1 = *a2;
  a1[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 0;
  operator new();
}

void sub_1A43B737C(_Unwind_Exception *a1)
{
  MEMORY[0x1A625B130](v5, 0x20C4093837F09);
  std::unique_ptr<NL::Transcriber>::reset[abi:ne180100](v4, 0);
  std::unique_ptr<NL::NumericConverter>::reset[abi:ne180100](v3, 0);
  uint64_t v7 = *v2;
  uint64_t *v2 = 0;
  if (v7) {
    std::default_delete<NL::DateConverter>::operator()[abi:ne180100]((uint64_t)v2, v7);
  }
  int v8 = *(std::__shared_weak_count **)(v1 + 8);
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  }
  _Unwind_Resume(a1);
}

CFIndex NL::EntityConverter::entityWithString@<X0>(CFIndex this@<X0>, CFStringRef theString@<X1>, CFRange a3@<0:X2, 8:X3>, void *a4@<X8>)
{
  *a4 = 0;
  if (theString && (*(_DWORD *)(*(void *)this + 40) - 7) <= 1)
  {
    if (*(void *)(*(void *)this + 8)) {
      return CFStringGetLength(theString);
    }
  }
  return this;
}

void sub_1A43B7460(_Unwind_Exception *a1)
{
  std::unique_ptr<NL::Entity>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

NL::Entity *NL::EntityConverter::enumerateEntitiesWithTypeAndValues(NL::Entity *result, CFStringRef theString, CFIndex a3, CFIndex a4, const __CFString *a5, const __CFString *a6, const __CFDictionary *a7, int a8, uint64_t a9)
{
  CFIndex v32 = a3;
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  if (theString)
  {
    if (a5)
    {
      if (a6)
      {
        CFStringRef v14 = result;
        CFIndex v31 = a4;
        uint64_t v15 = (NL::Entity *)(v32 + a4);
        BOOL result = (NL::Entity *)CFStringGetLength(theString);
        if ((uint64_t)v15 <= (uint64_t)result)
        {
          v36 = 0;
          if (a7) {
            CFIndex Count = CFDictionaryGetCount(a7);
          }
          else {
            CFIndex Count = 0;
          }
          v38.location = v32;
          v38.length = v31;
          CFStringRef v17 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E4F1CF80], theString, v38);
          CFStringRef v35 = v17;
          uint64_t HasSuffix = CFStringHasSuffix(a5, @"Text");
          if (HasSuffix) {
            int v19 = 7;
          }
          else {
            int v19 = 0;
          }
          if (a8) {
            int v19 = 3;
          }
          v27[1] = v19;
          if (!Count)
          {
            if (!CFStringHasSuffix(a6, @"Date") && !CFStringHasSuffix(a6, @"Time")) {
              operator new();
            }
            NL::DateConverter::datePeriodForRelativeDate(a6, &v33);
            if (v33) {
              operator new();
            }
            if (!v17) {
              goto LABEL_28;
            }
            goto LABEL_27;
          }
          v28 = v27;
          MEMORY[0x1F4188790](HasSuffix);
          uint64_t v29 = a9;
          CFStringRef v30 = v17;
          unint64_t v20 = (8 * Count + 15) & 0xFFFFFFFFFFFFFFF0;
          BOOL v21 = (const void **)((char *)v27 - v20);
          if ((unint64_t)(8 * Count) >= 0x200) {
            size_t v22 = 512;
          }
          else {
            size_t v22 = 8 * Count;
          }
          bzero((char *)v27 - v20, v22);
          MEMORY[0x1F4188790](v23);
          dispatch_time_t v24 = (char *)v27 - v20;
          size_t v25 = v22;
          CFStringRef v17 = v30;
          bzero((char *)v27 - v20, v25);
          CFDictionaryGetKeysAndValues(a7, v21, (const void **)((char *)v27 - v20));
          if (CFStringsAreEqual(a6, @"Contact") || CFStringFind(a6, @"Email", 0).location != -1) {
            operator new();
          }
          if (CFStringHasSuffix(a6, @"Status"))
          {
            if (Count >= 1)
            {
              do
              {
                if (CFStringHasSuffix(a5, (CFStringRef)*v21)) {
                  operator new();
                }
                v24 += 8;
                ++v21;
                --Count;
              }
              while (Count);
            }
            goto LABEL_20;
          }
          if (CFStringHasSuffix(a6, @"Value"))
          {
            NL::NumericConverter::numericValueForTypeWithValues(*((NL::ParserContext ***)v14 + 3), a6, a7, &v33);
            int v26 = v34;
            if (v33) {
              operator new();
            }
          }
          else
          {
            if (!CFStringHasSuffix(a6, @"Count"))
            {
              if (CFStringHasSuffix(a6, @"CalendarTime") || CFStringHasSuffix(a6, @"FormattedTime"))
              {
                NL::DateConverter::datePeriodForValues(a6, a7, &v33);
                if (v33) {
                  operator new();
                }
              }
              else
              {
                if (!CFStringHasSuffix(a6, @"Date") && !CFStringHasSuffix(a6, @"Time")) {
                  operator new();
                }
                NL::DateConverter::datePeriodForValues(a6, a7, &v33);
                if (v33) {
                  operator new();
                }
              }
              CFStringRef v33 = 0;
              std::unique_ptr<NL::DatePeriod>::reset[abi:ne180100](&v33, 0);
LABEL_20:
              if (!v17)
              {
LABEL_28:
                BOOL result = v36;
                v36 = 0;
                if (result)
                {
                  NL::Entity::~Entity(result);
                  return (NL::Entity *)MEMORY[0x1A625B130]();
                }
                return result;
              }
LABEL_27:
              CFRelease(v17);
              goto LABEL_28;
            }
            NL::NumericConverter::numericValueForTypeWithValues(*((NL::ParserContext ***)v14 + 3), a5, a7, &v33);
            int v26 = v34;
            if (v33) {
              operator new();
            }
          }
          if (v26) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v26);
          }
          goto LABEL_20;
        }
      }
    }
  }
  return result;
}

void sub_1A43B8360(_Unwind_Exception *a1)
{
  std::unique_ptr<NL::Entity>::reset[abi:ne180100]((NL::Entity **)(v1 + 216), 0);
  nlp::CFScopedPtr<__CFString const*>::reset((const void **)(v2 - 112), 0);
  std::unique_ptr<NL::Entity>::reset[abi:ne180100]((NL::Entity **)(v2 - 104), 0);
  _Unwind_Resume(a1);
}

void NL::Entity::setValues(NL::Entity *this, CFTypeRef cf)
{
  CFStringRef v4 = (const void *)*((void *)this + 15);
  if (v4)
  {
    CFRelease(v4);
    *((void *)this + 15) = 0;
  }
  if (cf) {
    *((void *)this + 15) = CFRetain(cf);
  }
}

NL::ParserContext **NL::EntityConverter::enumerateEntitiesWithString(NL::ParserContext **a1, const __CFString *a2, const __CFString *a3, CFIndex a4, CFIndex a5)
{
  if (a2 && a4 != -1)
  {
    CFStringRef v9 = a1;
    uint64_t v22 = 0;
    CFRange result = (CFRange)xmmword_1A43F6B80;
    CFCharacterSetRef Predefined = CFCharacterSetGetPredefined(kCFCharacterSetPunctuation);
    v23.location = a4;
    v23.length = a5;
    CFStringFindCharacterFromSet(a2, Predefined, v23, 0, &result);
    CFIndex Length = CFStringGetLength(a2);
    if (a3)
    {
      BOOL v12 = CFStringHasPrefix(a3, @"QuotedText") != 0;
      BOOL v13 = CFStringHasPrefix(a3, @"Keyword") != 0;
    }
    else
    {
      BOOL v12 = 0;
      BOOL v13 = 0;
    }
    if (result.location == -1)
    {
      BOOL v20 = 0;
    }
    else
    {
      BOOL v15 = result.location == a4 && result.length == a5;
      BOOL v20 = v15;
    }
    v24.location = a4;
    v24.length = a5;
    CFStringRef v16 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, v24);
    int v17 = !v20;
    if (a3) {
      int v17 = 0;
    }
    if ((v17 | (v12 || v13)) == 1)
    {
      uint64_t v18 = *((void *)*v9 + 1);
      uint64_t v19 = NL::ParserContext::index(*v9);
      if (lookslikeProperName(v16, v18, v19, a4 + a5 < Length)) {
        operator new();
      }
      if ((*((_DWORD *)*v9 + 10) - 7) <= 1 && v16 && *((void *)*v9 + 1)) {
        CFStringGetLength(v16);
      }
    }
    if (a3) {
      operator new();
    }
    if (v20) {
      operator new();
    }
    operator new();
  }
  return a1;
}

void sub_1A43B8DCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,char a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,void *a44,uint64_t a45,int a46,__int16 a47,char a48,char a49,void *a50,uint64_t a51,int a52,__int16 a53,char a54,char a55,char a56,void *a57,uint64_t a58,int a59,__int16 a60,char a61,char a62)
{
  if (*(char *)(v62 - 169) < 0) {
    operator delete(*(void **)(v62 - 192));
  }
  nlp::CFScopedPtr<__CFString const*>::reset((const void **)&a38, 0);
  nlp::CFScopedPtr<__CFString const*>::reset((const void **)(v62 - 120), 0);
  std::unique_ptr<NL::Entity>::reset[abi:ne180100]((NL::Entity **)(v62 - 96), 0);
  _Unwind_Resume(a1);
}

void NL::EntityConverter::merge(uint64_t a1, NL::Entity *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *((void *)a2 + 16);
  CFAllocatorRef v6 = (std::__shared_weak_count *)*((void *)a2 + 17);
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v5)
  {
    BOOL v9 = 1;
    if (!v6) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  uint64_t v8 = *(void *)(a4 + 128);
  uint64_t v7 = *(std::__shared_weak_count **)(a4 + 136);
  if (v7)
  {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    BOOL v9 = v8 == 0;
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
    if (!v6) {
      goto LABEL_9;
    }
LABEL_8:
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
    goto LABEL_9;
  }
  BOOL v9 = v8 == 0;
  if (v6) {
    goto LABEL_8;
  }
LABEL_9:
  if (!v9)
  {
    v10[0] = 0;
    v10[1] = v10;
    void v10[2] = 0x3802000000;
    v10[3] = __Block_byref_object_copy__11;
    v10[5] = 0;
    v10[6] = 0;
    v10[4] = __Block_byref_object_dispose__11;
    NL::Entity::entityTemplate(a2);
  }
}

void sub_1A43B9290(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, NL::Entity *a19, uint64_t a20,NL::Entity *a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,std::__shared_weak_count *a28)
{
  if (a28) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a28);
  }
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__11(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  return result;
}

void __Block_byref_object_dispose__11(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void NL::Entity::entityTemplate(NL::Entity *this)
{
}

void sub_1A43B9510(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v29 - 41) < 0) {
    operator delete(*(void **)(v29 - 64));
  }
  MEMORY[0x1A625B130](v28, 0x1072C4084E83484);
  _Unwind_Resume(a1);
}

void *std::shared_ptr<NL::DatePeriod>::operator=[abi:ne180100]<NL::DatePeriod,std::default_delete<NL::DatePeriod>,void>(void *a1, uint64_t *a2)
{
  std::shared_ptr<NL::DatePeriod>::shared_ptr[abi:ne180100]<NL::DatePeriod,std::default_delete<NL::DatePeriod>,void>((uint64_t *)&v6, a2);
  CFArrayRef v3 = (std::__shared_weak_count *)a1[1];
  long long v4 = v6;
  *(void *)&long long v6 = *a1;
  *((void *)&v6 + 1) = v3;
  *(_OWORD *)a1 = v4;
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  return a1;
}

void ___ZN2NL15EntityConverter5mergeERKNS_6EntityEjS3_jU13block_pointerFvNSt3__110unique_ptrIS1_NS4_14default_deleteIS1_EEEEE_block_invoke(int a1, NL::Entity *this)
{
}

void sub_1A43B9804(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  std::unique_ptr<NL::Entity>::reset[abi:ne180100]((NL::Entity **)va, 0);
  std::unique_ptr<NL::Entity>::reset[abi:ne180100]((NL::Entity **)(v10 - 56), 0);
  _Unwind_Resume(a1);
}

void ___ZN2NL15EntityConverter5mergeERKNS_6EntityEjS3_jU13block_pointerFvNSt3__110unique_ptrIS1_NS4_14default_deleteIS1_EEEEE_block_invoke_2(uint64_t a1)
{
}

void sub_1A43B99E8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  CFArrayRef v3 = va_arg(va1, NL::Entity *);
  uint64_t v5 = va_arg(va1, void);
  std::unique_ptr<NL::Entity>::reset[abi:ne180100]((NL::Entity **)va, 0);
  std::unique_ptr<NL::Entity>::reset[abi:ne180100]((NL::Entity **)va1, 0);
  _Unwind_Resume(a1);
}

dispatch_queue_t ___ZL20getDynamicNamesQueuev_block_invoke()
{
  dispatch_queue_t result = dispatch_queue_create("com.apple.NLP.DynamicNames", 0);
  getDynamicNamesQueue(void)::dynamicNamesQueue = (uint64_t)result;
  return result;
}

void ___ZL14getProperNamesv_block_invoke(nlp *a1)
{
  nlp::BurstTrieCreateMutable(a1);
  getProperNames(void)::propernames = v1;
}

uint64_t CoreSpotlightLibraryCore(char **a1)
{
  if (!CoreSpotlightLibraryCore(char **)::frameworkLibrary) {
    CoreSpotlightLibraryCore(char **)::frameworkLibrary = _sl_dlopen();
  }
  return CoreSpotlightLibraryCore(char **)::frameworkLibrary;
}

uint64_t ___ZL24CoreSpotlightLibraryCorePPc_block_invoke()
{
  uint64_t result = _sl_dlopen();
  CoreSpotlightLibraryCore(char **)::frameworkLibrary = result;
  return result;
}

void *___ZL43getCSSimpleQueryHasResultsForQuerySymbolLocv_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)CoreSpotlightLibrary();
  uint64_t result = dlsym(v2, "CSSimpleQueryHasResultsForQuery");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getCSSimpleQueryHasResultsForQuerySymbolLoc(void)::ptr = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t CoreSpotlightLibrary(void)
{
  CFArrayRef v3 = 0;
  uint64_t v0 = CoreSpotlightLibraryCore(&v3);
  uint64_t v1 = v3;
  if (!v0)
  {
    uint64_t v1 = (void *)abort_report_np();
    goto LABEL_5;
  }
  if (v3) {
LABEL_5:
  }
    free(v1);
  return v0;
}

void *___ZL31getCSSimpleQueryCancelSymbolLocv_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)CoreSpotlightLibrary();
  uint64_t result = dlsym(v2, "CSSimpleQueryCancel");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getCSSimpleQueryCancelSymbolLoc(void)::ptr = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

std::string *NL::Entity::Entity(std::string *this, long long *a2, long long *a3, std::string::size_type a4, std::string::size_type a5)
{
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v9 = *a2;
    this->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v9;
  }
  if (*((char *)a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this + 1, *(const std::string::value_type **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v10 = *a3;
    this[1].__r_.__value_.__r.__words[2] = *((void *)a3 + 2);
    *(_OWORD *)&this[1].__r_.__value_.__l.__data_ = v10;
  }
  std::string::basic_string[abi:ne180100]<0>(this[2].__r_.__value_.__r.__words, "");
  std::string::basic_string[abi:ne180100]<0>(this[3].__r_.__value_.__r.__words, "");
  this[4].__r_.__value_.__r.__words[0] = a4;
  this[4].__r_.__value_.__l.__size_ = a5;
  LODWORD(this[4].__r_.__value_.__r.__words[2]) = 0;
  *(_OWORD *)&this[5].__r_.__value_.__l.__data_ = 0u;
  *(_OWORD *)&this[5].__r_.__value_.__r.__words[2] = 0u;
  *(_OWORD *)&this[6].__r_.__value_.__r.__words[1] = 0u;
  *(_OWORD *)&this[7].__r_.__value_.__l.__data_ = 0u;
  return this;
}

void sub_1A43B9DA4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

std::string *NL::Entity::Entity(std::string *this, long long *a2, long long *a3, long long *a4, std::string::size_type a5, std::string::size_type a6)
{
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v11 = *a2;
    this->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v11;
  }
  if (*((char *)a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this + 1, *(const std::string::value_type **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v12 = *a3;
    this[1].__r_.__value_.__r.__words[2] = *((void *)a3 + 2);
    *(_OWORD *)&this[1].__r_.__value_.__l.__data_ = v12;
  }
  std::string::basic_string[abi:ne180100]<0>(this[2].__r_.__value_.__r.__words, "");
  BOOL v13 = this + 3;
  if (*((char *)a4 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v13, *(const std::string::value_type **)a4, *((void *)a4 + 1));
  }
  else
  {
    long long v14 = *a4;
    this[3].__r_.__value_.__r.__words[2] = *((void *)a4 + 2);
    *(_OWORD *)&v13->__r_.__value_.__l.__data_ = v14;
  }
  this[4].__r_.__value_.__r.__words[0] = a5;
  this[4].__r_.__value_.__l.__size_ = a6;
  LODWORD(this[4].__r_.__value_.__r.__words[2]) = 0;
  *(_OWORD *)&this[5].__r_.__value_.__l.__data_ = 0u;
  *(_OWORD *)&this[5].__r_.__value_.__r.__words[2] = 0u;
  *(_OWORD *)&this[6].__r_.__value_.__r.__words[1] = 0u;
  *(_OWORD *)&this[7].__r_.__value_.__l.__data_ = 0u;
  return this;
}

void sub_1A43B9EE4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 71) < 0) {
    operator delete(*v3);
  }
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void nlp::CFScopedPtr<void const*>::reset(const void **a1, const void *a2)
{
  long long v4 = *a1;
  if (v4) {
    CFRelease(v4);
  }
  *a1 = a2;
}

void std::__function::__func<void({block_pointer})(void *,nlp::_TrieCompletion *,BOOL *),std::allocator<void({block_pointer})(void *,nlp::_TrieCompletion *,BOOL *)>,void ()(void *,nlp::_TrieCompletion *,BOOL *)>::~__func()
{
}

uint64_t std::__function::__func<void({block_pointer})(void *,nlp::_TrieCompletion *,BOOL *),std::allocator<void({block_pointer})(void *,nlp::_TrieCompletion *,BOOL *)>,void ()(void *,nlp::_TrieCompletion *,BOOL *)>::__clone()
{
  return 0;
}

void *std::__function::__func<void({block_pointer})(void *,nlp::_TrieCompletion *,BOOL *),std::allocator<void({block_pointer})(void *,nlp::_TrieCompletion *,BOOL *)>,void ()(void *,nlp::_TrieCompletion *,BOOL *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF7CDF08;
  uint64_t result = *(void **)(a1 + 8);
  if (result) {
    uint64_t result = _Block_copy(result);
  }
  a2[1] = result;
  return result;
}

void std::__function::__func<void({block_pointer})(void *,nlp::_TrieCompletion *,BOOL *),std::allocator<void({block_pointer})(void *,nlp::_TrieCompletion *,BOOL *)>,void ()(void *,nlp::_TrieCompletion *,BOOL *)>::destroy(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  *(void *)(a1 + 8) = 0;
}

uint64_t std::__function::__func<void({block_pointer})(void *,nlp::_TrieCompletion *,BOOL *),std::allocator<void({block_pointer})(void *,nlp::_TrieCompletion *,BOOL *)>,void ()(void *,nlp::_TrieCompletion *,BOOL *)>::operator()(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 16))();
}

uint64_t std::__function::__func<void({block_pointer})(void *,nlp::_TrieCompletion *,BOOL *),std::allocator<void({block_pointer})(void *,nlp::_TrieCompletion *,BOOL *)>,void ()(void *,nlp::_TrieCompletion *,BOOL *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void({block_pointer})(void *,nlp::_TrieCompletion *,BOOL *),std::allocator<void({block_pointer})(void *,nlp::_TrieCompletion *,BOOL *)>,void ()(void *,nlp::_TrieCompletion *,BOOL *)>::target_type()
{
}

void *std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL *)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t *std::shared_ptr<NL::DatePeriod>::shared_ptr[abi:ne180100]<NL::DatePeriod,std::default_delete<NL::DatePeriod>,void>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *uint64_t result = *a2;
  if (v2) {
    operator new();
  }
  result[1] = 0;
  *a2 = 0;
  return result;
}

void std::__shared_ptr_pointer<NL::DatePeriod  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A625B130);
}

const void **std::__shared_ptr_pointer<NL::DatePeriod  *>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(const void ***)(a1 + 24);
  if (result)
  {
    NL::DatePeriod::~DatePeriod(result);
    JUMPOUT(0x1A625B130);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<NL::DatePeriod  *>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else {
    return 0;
  }
}

uint64_t NLAbstractIntentRecognizer::NLAbstractIntentRecognizer(uint64_t a1, long long *a2)
{
  *(void *)a1 = &unk_1EF7CD608;
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a1 + 8), *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v3 = *a2;
    *(void *)(a1 + 24) = *((void *)a2 + 2);
    *(_OWORD *)(a1 + 8) = v3;
  }
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  NLTokenizerWithDataDetector::NLTokenizerWithDataDetector((NLTokenizerWithDataDetector *)(a1 + 72));
  return a1;
}

void sub_1A43BA2D0(_Unwind_Exception *exception_object)
{
  long long v4 = v3;
  long long v6 = *v4;
  if (*v4)
  {
    *(void *)(v1 + 56) = v6;
    operator delete(v6);
  }
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void NLAbstractIntentRecognizer::~NLAbstractIntentRecognizer(NLAbstractIntentRecognizer *this)
{
  *(void *)this = &unk_1EF7CD608;
  if (*((void *)this + 4)) {
    MRLModelRelease();
  }
  uint64_t v2 = (void *)*((void *)this + 6);
  if (v2)
  {
    *((void *)this + 7) = v2;
    operator delete(v2);
  }
  if (*((char *)this + 31) < 0) {
    operator delete(*((void **)this + 1));
  }
}

NL::SpotlightUserContext *NL::SpotlightUserContext::SpotlightUserContext(NL::SpotlightUserContext *this)
{
  *(void *)this = getuid();
  *((void *)this + 1) = 0;
  CFMutableSetRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D548]);
  nlp::CFScopedPtr<__CFSet *>::reset((const void **)this + 1, Mutable);
  return this;
}

void sub_1A43BA3D8(_Unwind_Exception *a1)
{
  nlp::CFScopedPtr<__CFSet *>::reset(v1, 0);
  _Unwind_Resume(a1);
}

void nlp::CFScopedPtr<__CFSet *>::reset(const void **a1, const void *a2)
{
  long long v4 = *a1;
  if (v4) {
    CFRelease(v4);
  }
  *a1 = a2;
}

void NL::SpotlightUserContext::~SpotlightUserContext(const void **this)
{
}

uint64_t NL::SpotlightUserContext::copyUserNames(NL::SpotlightUserContext *this)
{
  return 0;
}

void NLUrduTransliterator::NLUrduTransliterator(NLUrduTransliterator *this, const __CFDictionary *a2)
{
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_DWORD *)this + 28) = 1065353216;
  *(_OWORD *)((char *)this + 12nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = xmmword_1A43F7930;
  *((_DWORD *)this + 34) = 2;
  *((void *)this + 18) = 0xC03E000000000000;
  *((void *)this + 19) = 0x3E800000005;
  *((_DWORD *)this + 4nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = 3;
  *((void *)this + 21) = 0x3FF3333333333333;
  *((void *)this + 22) = 0x1F40000000ALL;
  *(void *)this = &unk_1EF7CCBE8;
  std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((std::regex_traits<char> *)((char *)this + 184), "[\",,;.\"'?!:{}<>*\\-]",
    0);
}

void sub_1A43BA76C(_Unwind_Exception *a1)
{
  MEMORY[0x1A625B130](v8, 0xE1C40D30581F4);
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex(v7);
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex(v6);
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex(v5);
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex(v4);
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex(v3);
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex(v2);
  NLGenericTransliterator::~NLGenericTransliterator(v1);
  _Unwind_Resume(a1);
}

void NLUrduTransliterator::addDynamicMapping(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  char v41 = 0;
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  char v44 = 0;
  char v45 = 0;
  uint64_t v46 = 0;
  memset(v38, 0, 41);
  uint64_t v4 = a1 + 376;
  memset(&__p.__prefix_, 0, 17);
  memset(&__p.__suffix_, 0, 17);
  __p.__ready_ = 0;
  __p.__position_start_ = 0;
  memset(&__p, 0, 32);
  uint64_t v5 = *(unsigned __int8 *)(a2 + 23);
  uint64_t v6 = *(void *)(a2 + 8);
  if ((v5 & 0x80u) != 0)
  {
    a2 = *(void *)a2;
    uint64_t v5 = v6;
  }
  *(std::pair<const char *, const char *> *)((char *)&__p.__unmatched_.std::pair<const char *, const char *> + 1) = 0uLL;
  int v7 = std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>(v4, (char *)a2, (char *)(a2 + v5), &__p, 0);
  uint64_t v8 = *(unsigned __int8 *)(v2 + 23);
  if ((v8 & 0x80u) == 0) {
    uint64_t v9 = v2;
  }
  else {
    uint64_t v9 = *(void *)v2;
  }
  if ((v8 & 0x80u) != 0) {
    uint64_t v8 = *(void *)(v2 + 8);
  }
  std::match_results<std::__wrap_iter<char const*>>::__assign[abi:ne180100]<char const*,std::allocator<std::sub_match<char const*>>>(v38, v9, (std::sub_match<std::__wrap_iter<const char *>> *)(v9 + v8), (uint64_t *)&__p, 0);
  if (__p.__matches_.__begin_)
  {
    __p.__matches_.__end_ = __p.__matches_.__begin_;
    operator delete(__p.__matches_.__begin_);
  }
  if (v7)
  {
    char v10 = *(unsigned char *)(v2 + 23);
    if (v10 >= 0) {
      uint64_t v11 = *(unsigned __int8 *)(v2 + 23);
    }
    else {
      uint64_t v11 = *(void *)(v2 + 8);
    }
    if (v10 >= 0) {
      long long v12 = (char *)v2;
    }
    else {
      long long v12 = *(char **)v2;
    }
    BOOL v13 = &v12[v11];
    long long v14 = &v12[v11];
    if (v11 > 4)
    {
      uint64_t v15 = v11;
      CFStringRef v16 = v12;
      do
      {
        int v17 = (char *)memchr(v16, 112, v15 - 4);
        if (!v17) {
          break;
        }
        long long v14 = v17;
        if (*(_DWORD *)v17 == 1953067632 && v17[4] == 104) {
          goto LABEL_26;
        }
        CFStringRef v16 = v17 + 1;
        uint64_t v15 = v13 - (v14 + 1);
      }
      while (v15 > 4);
      long long v14 = &v12[v11];
    }
LABEL_26:
    if (v11 >= 4)
    {
      uint64_t v19 = v12;
      do
      {
        BOOL v20 = (char *)memchr(v19, 103, v11 - 3);
        if (!v20) {
          break;
        }
        if (*(_DWORD *)v20 == 1751741031) {
          goto LABEL_32;
        }
        uint64_t v19 = v20 + 1;
        uint64_t v11 = v13 - (unsigned char *)v19;
      }
      while (v13 - (unsigned char *)v19 > 3);
    }
    BOOL v20 = v13;
LABEL_32:
    BOOL v22 = v20 != v13 && v20 - v12 != -1;
    BOOL v23 = v14 - v12 == -1 || v14 == v13;
    if (!v23 || v22)
    {
      std::string::basic_string[abi:ne180100]<0>(v36, "");
      NLExtendedString::NLExtendedString((std::string *)&__p, (long long *)v36, 2, 2, 1.0);
      if (v37 < 0) {
        operator delete(v36[0]);
      }
    }
    else
    {
      std::string::basic_string[abi:ne180100]<0>(v36, "");
      NLExtendedString::NLExtendedString((std::string *)&__p, (long long *)v36, 2, 2, 0.005);
      if (v37 < 0) {
        operator delete(v36[0]);
      }
    }
    uint64_t v24 = *(void *)(a1 + 8);
    std::string::basic_string[abi:ne180100]<0>(v36, "i");
    (*(void (**)(uint64_t, void **, std::match_results<const char *> *))(*(void *)v24 + 16))(v24, v36, &__p);
    if (v37 < 0) {
      operator delete(v36[0]);
    }
    if (SHIBYTE(__p.__matches_.__end_cap_.__value_) < 0) {
      operator delete(__p.__matches_.__begin_);
    }
  }
  memset(&__p.__prefix_, 0, 17);
  memset(&__p.__suffix_, 0, 17);
  __p.__ready_ = 0;
  __p.__position_start_ = 0;
  memset(&__p, 0, 41);
  uint64_t v25 = *(unsigned __int8 *)(v2 + 23);
  if ((v25 & 0x80u) == 0) {
    int v26 = (char *)v2;
  }
  else {
    int v26 = *(char **)v2;
  }
  if ((v25 & 0x80u) != 0) {
    uint64_t v25 = *(void *)(v2 + 8);
  }
  char v27 = std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>(a1 + 312, v26, &v26[v25], &__p, 0);
  uint64_t v28 = *(unsigned __int8 *)(v2 + 23);
  if ((v28 & 0x80u) == 0) {
    uint64_t v29 = v2;
  }
  else {
    uint64_t v29 = *(void *)v2;
  }
  if ((v28 & 0x80u) != 0) {
    uint64_t v28 = *(void *)(v2 + 8);
  }
  std::match_results<std::__wrap_iter<char const*>>::__assign[abi:ne180100]<char const*,std::allocator<std::sub_match<char const*>>>(v38, v29, (std::sub_match<std::__wrap_iter<const char *>> *)(v29 + v28), (uint64_t *)&__p, 0);
  if (__p.__matches_.__begin_)
  {
    __p.__matches_.__end_ = __p.__matches_.__begin_;
    operator delete(__p.__matches_.__begin_);
  }
  if (v27) {
    goto LABEL_79;
  }
  memset(&__p.__prefix_, 0, 17);
  memset(&__p.__suffix_, 0, 17);
  __p.__ready_ = 0;
  __p.__position_start_ = 0;
  memset(&__p, 0, 41);
  uint64_t v30 = *(unsigned __int8 *)(v2 + 23);
  if ((v30 & 0x80u) == 0) {
    CFIndex v31 = (char *)v2;
  }
  else {
    CFIndex v31 = *(char **)v2;
  }
  if ((v30 & 0x80u) != 0) {
    uint64_t v30 = *(void *)(v2 + 8);
  }
  int v32 = std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>(a1 + 248, v31, &v31[v30], &__p, 0);
  uint64_t v33 = *(unsigned __int8 *)(v2 + 23);
  if ((v33 & 0x80u) == 0) {
    uint64_t v34 = v2;
  }
  else {
    uint64_t v34 = *(void *)v2;
  }
  if ((v33 & 0x80u) != 0) {
    uint64_t v33 = *(void *)(v2 + 8);
  }
  std::match_results<std::__wrap_iter<char const*>>::__assign[abi:ne180100]<char const*,std::allocator<std::sub_match<char const*>>>(v38, v34, (std::sub_match<std::__wrap_iter<const char *>> *)(v34 + v33), (uint64_t *)&__p, 0);
  if (__p.__matches_.__begin_)
  {
    __p.__matches_.__end_ = __p.__matches_.__begin_;
    operator delete(__p.__matches_.__begin_);
  }
  if (v32)
  {
LABEL_79:
    std::string::basic_string[abi:ne180100]<0>(v36, "");
    NLExtendedString::NLExtendedString((std::string *)&__p, (long long *)v36, 3, 2, 0.1);
    if (v37 < 0) {
      operator delete(v36[0]);
    }
    uint64_t v35 = *(void *)(a1 + 8);
    std::string::basic_string[abi:ne180100]<0>(v36, "a");
    (*(void (**)(uint64_t, void **, std::match_results<const char *> *))(*(void *)v35 + 16))(v35, v36, &__p);
    if (v37 < 0) {
      operator delete(v36[0]);
    }
    if (SHIBYTE(__p.__matches_.__end_cap_.__value_) < 0) {
      operator delete(__p.__matches_.__begin_);
    }
  }
  if (v38[0].__begin_)
  {
    v38[0].__end_ = v38[0].__begin_;
    operator delete(v38[0].__begin_);
  }
}

void sub_1A43BAD28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  if (a16) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

BOOL NLUrduTransliterator::addSpecialCandidates(uint64_t a1, unsigned __int16 *a2)
{
  int v2 = *((unsigned __int8 *)a2 + 23);
  if (*((char *)a2 + 23) < 0)
  {
    if (*((void *)a2 + 1) != 2)
    {
      BOOL v4 = 0;
      goto LABEL_13;
    }
    long long v3 = *(unsigned __int16 **)a2;
  }
  else
  {
    long long v3 = a2;
    if (v2 != 2)
    {
      BOOL v4 = 0;
LABEL_11:
      if (v2 != 2)
      {
LABEL_17:
        if (v2 != 2)
        {
LABEL_24:
          if (v2 != 2) {
            goto LABEL_31;
          }
          uint64_t v8 = a2;
          goto LABEL_29;
        }
        int v7 = a2;
        goto LABEL_22;
      }
      uint64_t v6 = a2;
      goto LABEL_15;
    }
  }
  int v5 = *v3;
  BOOL v4 = v5 == 25977;
  if (v5 == 25977) {
    operator new();
  }
  if ((v2 & 0x80) == 0) {
    goto LABEL_11;
  }
LABEL_13:
  if (*((void *)a2 + 1) != 2) {
    goto LABEL_20;
  }
  uint64_t v6 = *(_WORD **)a2;
LABEL_15:
  if (*v6 == 28535) {
    operator new();
  }
  if ((v2 & 0x80) == 0) {
    goto LABEL_17;
  }
LABEL_20:
  if (*((void *)a2 + 1) != 2) {
    goto LABEL_27;
  }
  int v7 = *(_WORD **)a2;
LABEL_22:
  if (*v7 == 28534) {
    operator new();
  }
  if ((v2 & 0x80) == 0) {
    goto LABEL_24;
  }
LABEL_27:
  if (*((void *)a2 + 1) != 2) {
    goto LABEL_34;
  }
  uint64_t v8 = *(_WORD **)a2;
LABEL_29:
  if (*v8 == 26987) {
    operator new();
  }
  if ((v2 & 0x80) == 0)
  {
LABEL_31:
    uint64_t v9 = a2;
    if (v2 != 1) {
      return v4;
    }
    goto LABEL_36;
  }
LABEL_34:
  if (*((void *)a2 + 1) != 1) {
    return v4;
  }
  uint64_t v9 = *(unsigned char **)a2;
LABEL_36:
  if (*v9 == 107) {
    operator new();
  }
  return v4;
}

void sub_1A43BB748(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL NLUrduTransliterator::isSpecialCharSeq(int a1, int a2, char *__s, int a4)
{
  if (a2 != 1) {
    return 0;
  }
  uint64_t v5 = a4;
  size_t v6 = a4 + 1;
  if (strlen(__s) <= v6 || __s[v5] != 97) {
    return 0;
  }
  int v7 = __s[v6];
  return v7 == 104 || v7 == 121;
}

void NLUrduTransliterator::~NLUrduTransliterator(std::locale *this)
{
  NLUrduTransliterator::~NLUrduTransliterator(this);

  JUMPOUT(0x1A625B130);
}

{
  std::locale *v2;
  std::__shared_weak_count *locale;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;
  uint64_t vars8;

  this->__locale_ = (std::locale::__imp *)&unk_1EF7CCBE8;
  int v2 = this + 63;
  locale = (std::__shared_weak_count *)this[69].__locale_;
  if (locale) {
    std::__shared_weak_count::__release_shared[abi:ne180100](locale);
  }
  std::locale::~locale(v2);
  BOOL v4 = (std::__shared_weak_count *)this[61].__locale_;
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  std::locale::~locale(this + 55);
  uint64_t v5 = (std::__shared_weak_count *)this[53].__locale_;
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  std::locale::~locale(this + 47);
  size_t v6 = (std::__shared_weak_count *)this[45].__locale_;
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
  std::locale::~locale(this + 39);
  int v7 = (std::__shared_weak_count *)this[37].__locale_;
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  std::locale::~locale(this + 31);
  uint64_t v8 = (std::__shared_weak_count *)this[29].__locale_;
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  }
  std::locale::~locale(this + 23);

  NLGenericTransliterator::~NLGenericTransliterator((NLGenericTransliterator *)this);
}

uint64_t _CFInit_TransliteratorWrapper(uint64_t result)
{
  *(void *)(result + 16) = &unk_1EF7CCF48;
  return result;
}

uint64_t createTransliteratorWrapper(uint64_t a1, uint64_t a2)
{
  CFAllocatorGetDefault();
  if (!g_CFTypeID_TransliteratorWrapper)
  {
    qword_1EC024008 = 0;
    unk_1EC024018 = 0u;
    unk_1EC024028 = 0u;
    g_CFTypeID_TransliteratorWrapper = _CFRuntimeRegisterClass();
  }
  uint64_t result = _CFRuntimeCreateInstance();
  *(void *)(result + 24) = a1;
  *(void *)(result + 32) = a2;
  return result;
}

CFDictionaryRef NLTransliteratorCreate(const __CFDictionary *a1)
{
  if ((_os_feature_enabled_impl() & 1) == 0)
  {
    if (a1)
    {
      CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a1, kNLTransliteratorTargetLocaleKey[0]);
      if (!Value)
      {
        uint64_t v11 = *(void (**)(void))(*(void *)NL::CFLogger::sharedInstance(0) + 16);
LABEL_29:
        v11();
        return 0;
      }
      CFStringRef v7 = Value;
      CFTypeID v8 = CFGetTypeID(Value);
      if (v8 == CFStringGetTypeID())
      {
        CFLocaleRef v9 = CFLocaleCreate(0, v7);
      }
      else
      {
        CFTypeID v14 = CFGetTypeID(v7);
        TypeID = (NL::CFLogger *)CFLocaleGetTypeID();
        if ((NL::CFLogger *)v14 != TypeID)
        {
LABEL_28:
          uint64_t v11 = *(void (**)(void))(*(void *)NL::CFLogger::sharedInstance(TypeID) + 16);
          goto LABEL_29;
        }
        CFLocaleRef v9 = (const __CFLocale *)CFRetain(v7);
      }
      CFLocaleRef v10 = v9;
    }
    else
    {
      CFLocaleRef v10 = 0;
    }
    CFStringRef v15 = (const __CFString *)CFLocaleGetValue(v10, (CFLocaleKey)*MEMORY[0x1E4F1D218]);
    if (CFStringCompare(v15, @"hi", 0))
    {
      if (CFStringCompare(v15, @"gu", 0))
      {
        if (CFStringCompare(v15, @"ur", 0))
        {
          if (CFStringCompare(v15, @"ar", 0)) {
            operator new();
          }
          operator new();
        }
        operator new();
      }
      operator new();
    }
    operator new();
  }
  if (a1)
  {
    TypeID = (NL::CFLogger *)CFDictionaryGetValue(a1, kNLTransliteratorTargetLocaleKey[0]);
    if (TypeID)
    {
      CFStringRef v3 = (const __CFString *)TypeID;
      CFTypeID v4 = CFGetTypeID(TypeID);
      if (v4 == CFStringGetTypeID())
      {
        uint64_t v5 = CFLocaleCreate(0, v3);
        goto LABEL_15;
      }
      CFTypeID v12 = CFGetTypeID(v3);
      TypeID = (NL::CFLogger *)CFLocaleGetTypeID();
      if ((NL::CFLogger *)v12 == TypeID)
      {
        uint64_t v5 = (void *)CFRetain(v3);
LABEL_15:
        BOOL v13 = v5;
        CFDictionaryGetValue(a1, (const void *)kNLTransliteratorBundleURLKey);
        if (v13) {
          operator new();
        }
        return 0;
      }
    }
    goto LABEL_28;
  }
  return a1;
}

#error "1A43BBFDC: call analysis failed (funcsize=46)"

void sub_1A43BBFF0()
{
}

CFIndex convertToVector@<X0>(CFIndex theArray@<X0>, void **a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  if (theArray)
  {
    CFArrayRef v2 = (const __CFArray *)theArray;
    CFIndex v4 = 0;
    uint64_t v5 = (uint64_t)(a2 + 2);
    while (1)
    {
      theArray = CFArrayGetCount(v2);
      if (theArray <= v4) {
        break;
      }
      CFStringRef ValueAtIndex = (NLTextSlot *)CFArrayGetValueAtIndex(v2, v4);
      uint64_t ResolvedDate = NLTextSlot::getResolvedDate(ValueAtIndex);
      uint64_t v8 = ResolvedDate;
      CFLocaleRef v10 = (uint64_t *)a2[1];
      unint64_t v9 = (unint64_t)a2[2];
      if ((unint64_t)v10 >= v9)
      {
        uint64_t v12 = ((char *)v10 - (unsigned char *)*a2) >> 3;
        if ((unint64_t)(v12 + 1) >> 61) {
          std::vector<NLExtendedString>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v13 = v9 - (void)*a2;
        uint64_t v14 = v13 >> 2;
        if (v13 >> 2 <= (unint64_t)(v12 + 1)) {
          uint64_t v14 = v12 + 1;
        }
        if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v15 = v14;
        }
        if (v15) {
          CFStringRef v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NLTransliterationCandidate *>>(v5, v15);
        }
        else {
          CFStringRef v16 = 0;
        }
        int v17 = (uint64_t *)&v16[8 * v12];
        *int v17 = v8;
        uint64_t v11 = v17 + 1;
        uint64_t v19 = (char *)*a2;
        uint64_t v18 = (char *)a2[1];
        if (v18 != *a2)
        {
          do
          {
            uint64_t v20 = *((void *)v18 - 1);
            v18 -= 8;
            *--int v17 = v20;
          }
          while (v18 != v19);
          uint64_t v18 = (char *)*a2;
        }
        *a2 = v17;
        a2[1] = v11;
        a2[2] = &v16[8 * v15];
        if (v18) {
          operator delete(v18);
        }
      }
      else
      {
        uint64_t *v10 = ResolvedDate;
        uint64_t v11 = v10 + 1;
      }
      a2[1] = v11;
      ++v4;
    }
  }
  return theArray;
}

void sub_1A43BC130(_Unwind_Exception *exception_object)
{
  CFStringRef v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

__CFArray *NLTransliteratorCopyCandidates(uint64_t a1, const __CFString *a2, const void *a3, uint64_t a4)
{
  CFMutableSetRef Mutable = 0;
  if ((_os_feature_enabled_impl() & 1) == 0)
  {
    if (a1 && a2)
    {
      convertToVector((CFIndex)a3, (void **)&__v.__first_);
      uint64_t v19 = *(void *)(a1 + 24);
      getUTF8StringFromCFString(a2, __p);
      (*(void (**)(void **__return_ptr, uint64_t, void **, std::__split_buffer<std::string> *, uint64_t))(*(void *)v19 + 16))(&v47, v19, __p, &__v, a4);
      CFMutableSetRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
      uint64_t v20 = (NLTransliterationCandidate **)v47;
      BOOL v21 = v48;
      if (v47 != v48)
      {
        do
        {
          CandidateWrapper = (const void *)createCandidateWrapper(*v20);
          CFArrayAppendValue(Mutable, CandidateWrapper);
          CFRelease(CandidateWrapper);
          ++v20;
        }
        while (v20 != v21);
        uint64_t v20 = (NLTransliterationCandidate **)v47;
      }
      if (v20)
      {
        v48 = v20;
        operator delete(v20);
      }
      if (SHIBYTE(v51) < 0) {
        operator delete(__p[0]);
      }
      first = __v.__first_;
      if (__v.__first_)
      {
        __v.__begin_ = __v.__first_;
LABEL_73:
        operator delete(first);
        return Mutable;
      }
    }
    return Mutable;
  }
  if (!a1 || !a2) {
    return Mutable;
  }
  getUTF8StringFromCFString(a2, &v47);
  unint64_t v9 = (NLTransliterationCandidate **)v49;
  unsigned __int8 v10 = v49;
  uint64_t v11 = (char *)v47;
  uint64_t v12 = v48;
  if ((v49 & 0x80u) == 0) {
    uint64_t v13 = (char *)&v47;
  }
  else {
    uint64_t v13 = (char *)v47;
  }
  if ((v49 & 0x80u) == 0) {
    uint64_t v14 = (NLTransliterationCandidate **)v49;
  }
  else {
    uint64_t v14 = v48;
  }
  if (v14)
  {
    unint64_t v15 = (char *)v14 + (void)v13;
    uint64_t v16 = MEMORY[0x1E4F14390];
    while (1)
    {
      unsigned int v17 = *v13;
      if (!((v17 & 0x80000000) != 0 ? __maskrune(v17, 0x100uLL) : *(_DWORD *)(v16 + 4 * v17 + 60) & 0x100)) {
        break;
      }
      ++v13;
      uint64_t v14 = (NLTransliterationCandidate **)((char *)v14 - 1);
      if (!v14)
      {
        uint64_t v13 = v15;
        break;
      }
    }
    unint64_t v9 = (NLTransliterationCandidate **)v49;
    uint64_t v11 = (char *)v47;
    uint64_t v12 = v48;
    unsigned __int8 v10 = v49;
  }
  if ((v10 & 0x80u) != 0) {
    unint64_t v9 = v12;
  }
  else {
    uint64_t v11 = (char *)&v47;
  }
  if (v13 == (char *)v9 + (void)v11)
  {
    if (a3) {
      CFRetain(a3);
    }
    applesauce::CF::ArrayRef::ArrayRef((applesauce::CF::ArrayRef *)&theArray, a3);
    memset(&v46, 0, sizeof(v46));
    CFArrayRef v24 = theArray;
    if (!theArray)
    {
LABEL_64:
      NLCompositeTransliterator::getTransliterationCandidates(*(void *)(a1 + 32), (uint64_t *)&v46, (uint64_t)&v47, a4, (std::string *)&__v);
      CFMutableSetRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
      char v41 = (NLTransliterationCandidate **)__v.__first_;
      std::__split_buffer<std::string>::pointer begin = __v.__begin_;
      if (__v.__first_ != __v.__begin_)
      {
        do
        {
          uint64_t v43 = (const void *)createCandidateWrapper(*v41);
          CFArrayAppendValue(Mutable, v43);
          if (v43) {
            CFRelease(v43);
          }
          ++v41;
        }
        while (v41 != (NLTransliterationCandidate **)begin);
        char v41 = (NLTransliterationCandidate **)__v.__first_;
      }
      if (v41)
      {
        __v.__begin_ = (std::__split_buffer<std::string>::pointer)v41;
        operator delete(v41);
      }
      __v.__first_ = (std::__split_buffer<std::string>::pointer)&v46;
      std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&__v);
      if ((v49 & 0x80) != 0) {
        goto LABEL_72;
      }
      return Mutable;
    }
    CFIndex Count = CFArrayGetCount(theArray);
    CFIndex v26 = Count;
    CFArrayRef v27 = theArray;
    if (theArray)
    {
      CFIndex v28 = CFArrayGetCount(theArray);
      if (!v26)
      {
LABEL_62:
        if (theArray) {
          CFRelease(theArray);
        }
        goto LABEL_64;
      }
    }
    else
    {
      CFIndex v28 = 0;
      if (!Count) {
        goto LABEL_62;
      }
    }
    unint64_t v29 = 0;
    do
    {
      if (v24 == v27 && v28 == v29) {
        break;
      }
      uint64_t v30 = (NLTextSlot *)applesauce::CF::details::at_to<void const*>(v24, v29);
      CFStringRef v31 = NLTransliterationCandidateCopyOutputString(v30);
      applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&cf, v31);
      applesauce::CF::convert_to<std::string,0>((const __CFString *)cf, (uint64_t)__p);
      std::vector<std::string>::pointer end = v46.__end_;
      if (v46.__end_ >= v46.__end_cap_.__value_)
      {
        unint64_t v34 = 0xAAAAAAAAAAAAAAABLL * (((char *)v46.__end_ - (char *)v46.__begin_) >> 3);
        unint64_t v35 = v34 + 1;
        if (v34 + 1 > 0xAAAAAAAAAAAAAAALL) {
          std::vector<NLExtendedString>::__throw_length_error[abi:ne180100]();
        }
        if (0x5555555555555556 * (((char *)v46.__end_cap_.__value_ - (char *)v46.__begin_) >> 3) > v35) {
          unint64_t v35 = 0x5555555555555556 * (((char *)v46.__end_cap_.__value_ - (char *)v46.__begin_) >> 3);
        }
        if (0xAAAAAAAAAAAAAAABLL * (((char *)v46.__end_cap_.__value_ - (char *)v46.__begin_) >> 3) >= 0x555555555555555) {
          unint64_t v36 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v36 = v35;
        }
        __v.__end_cap_.__value_ = (std::allocator<std::string> *)&v46.__end_cap_;
        if (v36) {
          char v37 = (std::string *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)&v46.__end_cap_, v36);
        }
        else {
          char v37 = 0;
        }
        CFRange v38 = v37 + v34;
        __v.__first_ = v37;
        __v.__begin_ = v38;
        __v.__end_cap_.__value_ = &v37[v36];
        long long v39 = *(_OWORD *)__p;
        v38->__r_.__value_.__r.__words[2] = v51;
        *(_OWORD *)&v38->__r_.__value_.__l.__data_ = v39;
        __p[1] = 0;
        std::string::size_type v51 = 0;
        __p[0] = 0;
        __v.__end_ = v38 + 1;
        std::vector<std::string>::__swap_out_circular_buffer(&v46, &__v);
        uint64_t v40 = v46.__end_;
        std::__split_buffer<std::string>::~__split_buffer(&__v);
        v46.__end_ = v40;
        if (SHIBYTE(v51) < 0) {
          operator delete(__p[0]);
        }
      }
      else
      {
        long long v33 = *(_OWORD *)__p;
        v46.__end_->__r_.__value_.__r.__words[2] = v51;
        *(_OWORD *)&end->__r_.__value_.__l.__data_ = v33;
        v46.__end_ = end + 1;
      }
      if (cf) {
        CFRelease(cf);
      }
      ++v29;
    }
    while (v26 != v29);
    goto LABEL_62;
  }
  CFMutableSetRef Mutable = 0;
  if ((v10 & 0x80) != 0)
  {
LABEL_72:
    first = v47;
    goto LABEL_73;
  }
  return Mutable;
}

void sub_1A43BC5C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CFTypeRef a9, char a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,CFTypeRef cf,char *__p,char *a27)
{
  if (__p)
  {
    a27 = __p;
    operator delete(__p);
  }
  std::match_results<const char *> __p = &a10;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  if (a18 < 0) {
    operator delete(a13);
  }
  _Unwind_Resume(a1);
}

void NLTransliterationCandidateCreate()
{
}

void sub_1A43BC788(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  MEMORY[0x1A625B130](v20, 0x1012C40B0087DDBLL);
  _Unwind_Resume(a1);
}

NLTextSlot *NLTransliterationCandidateCopyInputString(NLTextSlot *result)
{
  if (result)
  {
    uint64_t ResolvedDate = (NLAbstractOrthographyConvertor *)NLTextSlot::getResolvedDate(result);
    NLAbstractOrthographyConvertor::~NLAbstractOrthographyConvertor(ResolvedDate);
    return (NLTextSlot *)createCFStringFromString(v2);
  }
  return result;
}

CFStringRef NLTransliterationCandidateCopyOutputString(NLTextSlot *a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t ResolvedDate = (NLTransliterationCandidate *)NLTextSlot::getResolvedDate(a1);
  if (!ResolvedDate) {
    return 0;
  }
  uint64_t TransliteratedWord = NLTransliterationCandidate::getTransliteratedWord(ResolvedDate);

  return createCFStringFromString(TransliteratedWord);
}

NLTextSlot *NLTransliterationCandidateIsExtensionCandidate(NLTextSlot *result)
{
  if (result)
  {
    uint64_t ResolvedDate = (NLTransliterationCandidate *)NLTextSlot::getResolvedDate(result);
    return (NLTextSlot *)NLTransliterationCandidate::isExtensionCandidate(ResolvedDate);
  }
  return result;
}

double NLTransliterationCandidateScore(NLTextSlot *a1)
{
  if (!a1) {
    return 0.0;
  }
  uint64_t ResolvedDate = (NLTransliterationCandidate *)NLTextSlot::getResolvedDate(a1);

  return NLTransliterationCandidate::getLMScore(ResolvedDate);
}

void NLTransliteratorAcceptCandidate(uint64_t a1, CFIndex a2, NLTextSlot *a3)
{
  if (a1 && a3 && (_os_feature_enabled_impl() & 1) == 0)
  {
    uint64_t v6 = *(void *)(a1 + 24);
    convertToVector(a2, __p);
    uint64_t ResolvedDate = NLTextSlot::getResolvedDate(a3);
    (*(void (**)(uint64_t, void **, uint64_t))(*(void *)v6 + 32))(v6, __p, ResolvedDate);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }
}

void sub_1A43BC964(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NLTransliteratorFlushDynamicLanguageModel(uint64_t a1)
{
  uint64_t result = _os_feature_enabled_impl();
  if ((result & 1) == 0)
  {
    CFStringRef v3 = *(uint64_t (**)(void))(**(void **)(a1 + 24) + 40);
    return v3();
  }
  return result;
}

uint64_t NLTransliteratorResetDynamicLanguageModel(uint64_t a1)
{
  uint64_t result = _os_feature_enabled_impl();
  if ((result & 1) == 0)
  {
    CFStringRef v3 = *(uint64_t (**)(void))(**(void **)(a1 + 24) + 48);
    return v3();
  }
  return result;
}

uint64_t NLTransliterationCandidateIsInVocabulary(NLTextSlot *a1)
{
  if (!_os_feature_enabled_impl()) {
    return 0;
  }
  uint64_t ResolvedDate = (NLTransliterationCandidate *)NLTextSlot::getResolvedDate(a1);
  if (!ResolvedDate) {
    return 0;
  }

  return NLTransliterationCandidate::isInVocabulary(ResolvedDate);
}

uint64_t NLTransliteratorAssetsAvailable()
{
  uint64_t result = _os_feature_enabled_impl();
  if (result)
  {
    uint64_t v2 = 0;
    CFStringRef v3 = &v2;
    uint64_t v4 = 0x3812000000;
    uint64_t v5 = __Block_byref_object_copy__12;
    uint64_t v6 = __Block_byref_object_dispose__12;
    CFStringRef v7 = &unk_1A4417359;
    CFTypeRef cf = 0;
    LMEnumerateAssetDataItems();
    uint64_t v1 = v3[6];
    _Block_object_dispose(&v2, 8);
    if (cf) {
      CFRelease(cf);
    }
    return v1 != 0;
  }
  return result;
}

void sub_1A43BCBE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(a1);
}

uint64_t NLTransliterationCandidateCopyMetadata(NLTextSlot *a1)
{
  uint64_t ResolvedDate = (NLTransliterationCandidate *)NLTextSlot::getResolvedDate(a1);

  return NLTransliterationCandidate::copyMetadata(ResolvedDate);
}

void TransliteratorWrapper::~TransliteratorWrapper(TransliteratorWrapper *this)
{
  TransliteratorWrapper::~TransliteratorWrapper(this);

  JUMPOUT(0x1A625B130);
}

{
  uint64_t v2;
  NLCompositeTransliterator *v3;
  uint64_t vars8;

  *(void *)this = &unk_1EF7CCF48;
  uint64_t v2 = *((void *)this + 1);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  CFStringRef v3 = (NLCompositeTransliterator *)*((void *)this + 2);
  if (v3)
  {
    NLCompositeTransliterator::~NLCompositeTransliterator(v3);
    MEMORY[0x1A625B130]();
  }

  NLAbstractOrthographyConvertor::~NLAbstractOrthographyConvertor(this);
}

void *applesauce::CF::convert_to<std::string,0>@<X0>(const __CFString *a1@<X0>, uint64_t a2@<X8>)
{
  if (!a1 || (CFTypeID TypeID = CFStringGetTypeID(), TypeID != CFGetTypeID(a1)))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::convert_error(exception);
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }

  return applesauce::CF::details::CFString_get_value<true>(a1, a2);
}

void sub_1A43BCD9C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

applesauce::CF::StringRef *applesauce::CF::StringRef::StringRef(applesauce::CF::StringRef *this, CFTypeRef cf)
{
  *(void *)this = cf;
  if (cf)
  {
    CFTypeID v3 = CFGetTypeID(cf);
    if (v3 != CFStringGetTypeID())
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Could not construct");
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
  }
  return this;
}

void sub_1A43BCE38(_Unwind_Exception *a1)
{
  __cxa_free_exception(v2);
  if (*v1) {
    CFRelease(*v1);
  }
  _Unwind_Resume(a1);
}

const void *applesauce::CF::details::at_to<void const*>(const __CFArray *a1, unint64_t a2)
{
  if (!a1 || CFArrayGetCount(a1) <= a2 || (uint64_t result = CFArrayGetValueAtIndex(a1, a2)) == 0)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::not_found(exception);
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  return result;
}

void sub_1A43BCEE8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::runtime_error *applesauce::CF::not_found@<X0>(std::runtime_error *a1@<X8>)
{
  return std::runtime_error::runtime_error(a1, "Could not find item");
}

std::runtime_error *applesauce::CF::convert_error@<X0>(std::runtime_error *a1@<X8>)
{
  return std::runtime_error::runtime_error(a1, "Could not convert");
}

applesauce::CF::ArrayRef *applesauce::CF::ArrayRef::ArrayRef(applesauce::CF::ArrayRef *this, CFTypeRef cf)
{
  *(void *)this = cf;
  if (cf)
  {
    CFTypeID v3 = CFGetTypeID(cf);
    if (v3 != CFArrayGetTypeID())
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Could not construct");
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
  }
  return this;
}

void sub_1A43BCFA4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v2);
  if (*v1) {
    CFRelease(*v1);
  }
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__12(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = 0;
  *(void *)(result + 48) = v2;
  return result;
}

void __Block_byref_object_dispose__12(uint64_t a1)
{
}

void ___ZL23isSeq2SeqModelAvailablePK10__CFLocale_block_invoke(uint64_t a1, CFURLRef url, uint64_t a3, uint64_t a4, uint64_t a5, unsigned char *a6)
{
  CFStringRef PathComponent = CFURLCopyLastPathComponent(url);
  if (PathComponent)
  {
    CFStringRef v10 = PathComponent;
    if (CFStringsAreEqual(PathComponent, @"EMT_package"))
    {
      uint64_t v11 = *(void *)(*(void *)(a1 + 32) + 8);
      CFStringRef v12 = CFURLCopyPath(url);
      nlp::CFScopedPtr<__CFString const*>::reset((const void **)(v11 + 48), v12);
      *a6 = 1;
    }
    CFRelease(v10);
  }
}

void sub_1A43BD07C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  nlp::CFScopedPtr<__CFString const*>::reset((const void **)va, 0);
  _Unwind_Resume(a1);
}

uint64_t NLLatticePath::NLLatticePath(uint64_t a1, const std::string *a2, double a3)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  uint64_t v5 = (uint64_t *)(a1 + 24);
  *(_OWORD *)a1 = 0u;
  std::string::operator=((std::string *)a1, a2);
  NLExtendedString::NLExtendedString((NLExtendedString *)__p);
  std::vector<NLExtendedString>::push_back[abi:ne180100](v5, (long long *)__p);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  *(double *)(a1 + 48) = a3;
  return a1;
}

void sub_1A43BD110(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  std::vector<NLExtendedString>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  if (*(char *)(v14 + 23) < 0) {
    operator delete(*(void **)v14);
  }
  _Unwind_Resume(a1);
}

uint64_t NLLatticePath::appendPathString(std::string *this, const NLExtendedString *a2)
{
  std::string::size_type size = this[1].__r_.__value_.__l.__size_;
  CFTypeID v3 = (uint64_t *)&this[1];
  if (size == this[1].__r_.__value_.__r.__words[0]) {
    goto LABEL_19;
  }
  if (NLExtendedString::getJoinNext((NLExtendedString *)(size - 48)) == 1
    && NLExtendedString::getJoinPrev(a2) == 1)
  {
    goto LABEL_8;
  }
  std::string::size_type v6 = this[1].__r_.__value_.__l.__size_;
  if (v6 == this[1].__r_.__value_.__r.__words[0]) {
LABEL_19:
  }
    std::vector<NLExtendedString>::__throw_out_of_range[abi:ne180100]();
  if (NLExtendedString::getJoinNext((NLExtendedString *)(v6 - 48))
    || NLExtendedString::getJoinPrev(a2))
  {
    uint64_t v7 = 0;
    goto LABEL_15;
  }
LABEL_8:
  NLAbstractOrthographyConvertor::~NLAbstractOrthographyConvertor(a2);
  int v9 = *(char *)(v8 + 23);
  if (v9 >= 0) {
    CFStringRef v10 = (const std::string::value_type *)v8;
  }
  else {
    CFStringRef v10 = *(const std::string::value_type **)v8;
  }
  if (v9 >= 0) {
    std::string::size_type v11 = *(unsigned __int8 *)(v8 + 23);
  }
  else {
    std::string::size_type v11 = *(void *)(v8 + 8);
  }
  std::string::append(this, v10, v11);
  uint64_t v7 = 1;
LABEL_15:
  std::string::size_type v12 = this[1].__r_.__value_.__l.__size_;
  if (v12 >= this[1].__r_.__value_.__r.__words[2])
  {
    uint64_t v13 = std::vector<NLExtendedString>::__push_back_slow_path<NLExtendedString const&>(v3, (long long *)a2);
  }
  else
  {
    std::vector<NLExtendedString>::__construct_one_at_end[abi:ne180100]<NLExtendedString const&>((uint64_t)v3, (long long *)a2);
    uint64_t v13 = v12 + 48;
  }
  this[1].__r_.__value_.__l.__size_ = v13;
  return v7;
}

double NLLatticePath::addPathScore(NLLatticePath *this, double a2)
{
  double result = *((double *)this + 6) + a2;
  *((double *)this + 6) = result;
  return result;
}

std::string *NLLatticePath::getNodeVector@<X0>(long long **this@<X0>, std::string *a2@<X8>)
{
  a2->__r_.__value_.__r.__words[0] = 0;
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  return std::vector<NLExtendedString>::__init_with_size[abi:ne180100]<NLExtendedString*,NLExtendedString*>(a2, this[3], this[4], 0xAAAAAAAAAAAAAAABLL * (this[4] - this[3]));
}

void NLTokenizerWithDataDetector::NLTokenizerWithDataDetector(NLTokenizerWithDataDetector *this)
{
  CFErrorRef err = 0;
  uint64_t v2 = DDScannerCreateWithType();
  *(void *)this = v2;
  if (!v2 && err)
  {
    CFStringRef v3 = CFErrorCopyDescription(err);
    UTF8StringFromCFString = (NL::CFLogger *)getUTF8StringFromCFString(v3, __p);
    uint64_t v5 = NL::CFLogger::sharedInstance(UTF8StringFromCFString);
    if (v8 >= 0) {
      std::string::size_type v6 = __p;
    }
    else {
      std::string::size_type v6 = (void **)__p[0];
    }
    (*(void (**)(uint64_t, uint64_t, const char *, ...))(*(void *)v5 + 16))(v5, 3, "Could not create DDScanner : %s", (const char *)v6);
    if (v3) {
      CFRelease(v3);
    }
    CFRelease(err);
    if (v8 < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_1A43BD358(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

__CFArray *NLTokenizerWithDataDetector::copyTokenizeWithDataDetectors(NLTokenizerWithDataDetector *this, const __CFString *a2)
{
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableSetRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  if (*(void *)this
    && DDScannerScanString()
    && (CFArrayRef v6 = (const __CFArray *)DDScannerCopyResultsWithOptions()) != 0)
  {
    CFArrayRef v7 = v6;
    CFIndex Count = CFArrayGetCount(v6);
    if (Count >= 1)
    {
      CFIndex v9 = Count;
      CFIndex v10 = 0;
      CFIndex v11 = 0;
      CFTypeRef v28 = (CFTypeRef)*MEMORY[0x1E4F5EFE0];
      CFTypeRef v25 = (CFTypeRef)*MEMORY[0x1E4F5F0D0];
      CFTypeRef v26 = (CFTypeRef)*MEMORY[0x1E4F5EFE8];
      CFTypeRef v23 = (CFTypeRef)*MEMORY[0x1E4F5F0C8];
      CFTypeRef v24 = (CFTypeRef)*MEMORY[0x1E4F5EFD8];
      CFTypeRef cf2 = (CFTypeRef)*MEMORY[0x1E4F5F0E0];
      while (2)
      {
        CFArrayGetValueAtIndex(v7, v11);
        std::string::size_type v12 = @"URL";
        switch(DDResultGetCategory())
        {
          case 1u:
            goto LABEL_17;
          case 2u:
            std::string::size_type v12 = @"PHONE";
            goto LABEL_17;
          case 3u:
            std::string::size_type v12 = @"ADDRESS";
            goto LABEL_17;
          case 4u:
            Type = (const void *)DDResultGetType();
            std::string::size_type v12 = @"DATETIME";
            if (CFEqual(Type, v28)
              || CFEqual(Type, v26)
              || CFEqual(Type, v25)
              || CFEqual(Type, v24)
              || CFEqual(Type, v23))
            {
              goto LABEL_17;
            }
            goto LABEL_20;
          default:
            uint64_t v13 = (const void *)DDResultGetType();
            int v14 = CFEqual(v13, cf2);
            std::string::size_type v12 = @"CURRENCY";
            if ((DDResultHasType() & 1) == 0)
            {
              std::string::size_type v12 = @"DATETIME";
              if (!v14) {
                goto LABEL_20;
              }
            }
LABEL_17:
            uint64_t Range = DDResultGetRange();
            uint64_t v18 = v17;
            if (Range > v10)
            {
              v29.location = v10;
              v29.length = Range - v10;
              CFStringRef v19 = CFStringCreateWithSubstring(v4, a2, v29);
              CFArrayAppendValue(Mutable, v19);
              CFRelease(v19);
            }
            CFArrayAppendValue(Mutable, v12);
            CFIndex v10 = Range + v18;
LABEL_20:
            if (v9 == ++v11) {
              goto LABEL_24;
            }
            continue;
        }
      }
    }
    CFIndex v10 = 0;
LABEL_24:
    CFRelease(v7);
  }
  else
  {
    CFIndex v10 = 0;
  }
  CFIndex Length = CFStringGetLength(a2);
  if (Length > v10)
  {
    v30.location = v10;
    v30.length = Length - v10;
    CFStringRef v21 = CFStringCreateWithSubstring(v4, a2, v30);
    CFArrayAppendValue(Mutable, v21);
    CFRelease(v21);
  }
  return Mutable;
}

__CFArray *NLTokenizerWithDataDetector::copyCharacterTokens(NLTokenizerWithDataDetector *this, const __CFString *a2)
{
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableSetRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  CFIndex Length = CFStringGetLength(a2);
  if (Length >= 1)
  {
    CFIndex v6 = Length;
    for (CFIndex i = 0; i != v6; ++i)
    {
      v10.location = i;
      v10.length = 1;
      CFStringRef v8 = CFStringCreateWithSubstring(v3, a2, v10);
      CFArrayAppendValue(Mutable, v8);
      CFRelease(v8);
    }
  }
  return Mutable;
}

CFMutableArrayRef NLTokenizerWithDataDetector::copyTokens(NLTokenizerWithDataDetector *this, const __CFString *a2)
{
  uint64_t v2 = NLTokenizerWithDataDetector::copyTokenizeWithDataDetectors(this, a2);
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableSetRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  CFArrayAppendValue(Mutable, (const void *)*MEMORY[0x1E4F5C920]);
  uint64_t v5 = (const void *)NLTaggerCreate();
  if (Mutable) {
    CFRelease(Mutable);
  }
  CFIndex Count = CFArrayGetCount(v2);
  CFMutableArrayRef v7 = CFArrayCreateMutable(v3, 0, MEMORY[0x1E4F1D510]);
  if (Count >= 1)
  {
    for (CFIndex i = 0; i != Count; ++i)
    {
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v2, i);
      NLTaggerSetString();
      CFStringGetLength(ValueAtIndex);
      NLTaggerEnumerateTokens();
    }
  }
  if (v2) {
    CFRelease(v2);
  }
  if (v5) {
    CFRelease(v5);
  }
  return v7;
}

void ___ZN27NLTokenizerWithDataDetector10copyTokensEPK10__CFString_block_invoke(uint64_t a1, CFRange *a2)
{
  CFStringRef v3 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(CFStringRef *)(a1 + 32), *a2);
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 40), v3);
  if (v3)
  {
    CFRelease(v3);
  }
}

CFMutableArrayRef NLTokenizerWithDataDetector::copyTokenizedSentences(NLTokenizerWithDataDetector *this, const __CFString *a2)
{
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFAllocatorRef v4 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
  CFMutableSetRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  CFArrayAppendValue(Mutable, (const void *)*MEMORY[0x1E4F5C920]);
  CFIndex v6 = (const void *)NLTaggerCreate();
  NLTaggerSetString();
  CFStringGetLength(a2);
  CFMutableArrayRef v7 = CFArrayCreateMutable(v3, 0, v4);
  NLTaggerEnumerateTokens();
  if (v6) {
    CFRelease(v6);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v7;
}

void ___ZN27NLTokenizerWithDataDetector22copyTokenizedSentencesEPK10__CFString_block_invoke(uint64_t a1, CFRange *a2)
{
  CFStringRef v3 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(CFStringRef *)(a1 + 32), *a2);
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 40), v3);
  if (v3)
  {
    CFRelease(v3);
  }
}

void getVocabulary(uint64_t a1, uint64_t a2)
{
  Completion = (char *)nlp::TrieCompletionGetCompletion(a2);
  std::string::basic_string[abi:ne180100]<0>(__p, Completion);
  int Score = NLBranchGetScore(a2);
  NL::SearchRules::addVocabulary(a1, (uint64_t)__p, Score);
  if (v7 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1A43BDAE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void NL::SearchRules::addVocabulary(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3 = *(unsigned __int8 *)(a2 + 23);
  int v4 = (char)v3;
  if ((v3 & 0x80u) != 0) {
    uint64_t v3 = *(void *)(a2 + 8);
  }
  if (v3)
  {
    int TermID = a3;
    if (a3)
    {
      CFStringRef v8 = (uint64_t **)(a1 + 32);
      if (a1 + 40 != std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::find<std::string>(a1 + 32, (const void **)a2))return; {
LABEL_15:
      }
      if (*(char *)(a2 + 23) < 0) {
        std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
      }
      else {
        std::string __p = *(std::string *)a2;
      }
      LODWORD(v12) = TermID;
      std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::__emplace_unique_key_args<std::string,std::pair<std::string,unsigned int>>(v8, (const void **)&__p.__r_.__value_.__l.__data_, (uint64_t)&__p);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      CFRange v10 = (uint64_t **)(a1 + 8);
      LODWORD(__p.__r_.__value_.__l.__data_) = TermID;
      if (*(char *)(a2 + 23) < 0)
      {
        std::string::__init_copy_ctor_external((std::string *)&__p.__r_.__value_.__r.__words[1], *(const std::string::value_type **)a2, *(void *)(a2 + 8));
      }
      else
      {
        *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = *(_OWORD *)a2;
        uint64_t v12 = *(void *)(a2 + 16);
      }
      std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int,std::string>>(v10, (unsigned int *)&__p, (uint64_t)&__p);
      if (SHIBYTE(v12) < 0) {
        operator delete((void *)__p.__r_.__value_.__l.__size_);
      }
      return;
    }
    if (v4 < 0)
    {
      if (*(void *)(a2 + 8) != 4)
      {
LABEL_13:
        CFStringRef v8 = (uint64_t **)(a1 + 32);
        if (a1 + 40 != std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::find<std::string>(a1 + 32, (const void **)a2))return; {
        int TermID = NL::SearchRules::getTermID(a1, (const void **)a2);
        }
        goto LABEL_15;
      }
      CFIndex v9 = *(_DWORD **)a2;
    }
    else
    {
      CFIndex v9 = (_DWORD *)a2;
      if (v4 != 4) {
        goto LABEL_13;
      }
    }
    if (*v9 == 1701736270) {
      return;
    }
    goto LABEL_13;
  }
}

void sub_1A43BDC74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NL::SearchRules::createFromPath(NL::SearchRules *this, const __CFURL *a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (this)
  {
    CFURLGetFileSystemRepresentation(this, 1u, buffer, 1024);
    if (!stat((const char *)buffer, &v5))
    {
      int v3 = open((const char *)buffer, 0);
      if ((v3 & 0x80000000) == 0)
      {
        int v4 = mmap(0, v5.st_size, 1, 1, v3, 0);
        if (v4 != (_DWORD *)-1)
        {
          if (*v4 == 485346046 && v4[1] == 2) {
            operator new();
          }
          munmap(v4, v5.st_size);
        }
        close(v3);
      }
    }
  }
  return 0;
}

void sub_1A43BDFA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28)
{
}

uint64_t *NL::SearchRules::addRule(NL::SearchRules *this, unsigned int a2, unsigned int a3, unsigned int a4, uint64_t a5)
{
  CFRange v10 = (char *)this + 208;
  uint64_t v9 = *((void *)this + 26);
  if (!v9) {
    goto LABEL_12;
  }
  CFIndex v11 = (char *)this + 208;
  uint64_t v12 = (char *)*((void *)this + 26);
  do
  {
    unsigned int v13 = *((_DWORD *)v12 + 8);
    BOOL v14 = v13 >= a3;
    if (v13 >= a3) {
      unint64_t v15 = (char **)v12;
    }
    else {
      unint64_t v15 = (char **)(v12 + 8);
    }
    if (v14) {
      CFIndex v11 = v12;
    }
    uint64_t v12 = *v15;
  }
  while (*v15);
  if (v11 == v10 || *((_DWORD *)v11 + 8) > a3)
  {
LABEL_12:
    v50 = 0;
    uint64_t v51 = 0;
    unsigned __int8 v49 = &v50;
    LODWORD(v52) = a3;
    v54 = 0;
    uint64_t v55 = 0;
    v53 = &v54;
    std::__tree<std::__value_type<unsigned int,std::map<unsigned int,std::map<unsigned int,unsigned int>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::map<unsigned int,std::map<unsigned int,unsigned int>>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::map<unsigned int,std::map<unsigned int,unsigned int>>>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int,std::map<unsigned int,std::map<unsigned int,unsigned int>>>>((uint64_t)this + 200, (unsigned int *)&v52, (uint64_t)&v52);
    std::__tree<std::__value_type<unsigned int,std::map<unsigned int,unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::map<unsigned int,unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::map<unsigned int,unsigned int>>>>::destroy((uint64_t)&v53, v54);
    std::__tree<std::__value_type<unsigned int,std::map<unsigned int,unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::map<unsigned int,unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::map<unsigned int,unsigned int>>>>::destroy((uint64_t)&v49, v50);
    uint64_t v9 = *(void *)v10;
  }
  if (!v9) {
    goto LABEL_24;
  }
  uint64_t v16 = v10;
  uint64_t v17 = v9;
  do
  {
    unsigned int v18 = *(_DWORD *)(v17 + 32);
    BOOL v19 = v18 >= a3;
    if (v18 >= a3) {
      uint64_t v20 = (uint64_t *)v17;
    }
    else {
      uint64_t v20 = (uint64_t *)(v17 + 8);
    }
    if (v19) {
      uint64_t v16 = (char *)v17;
    }
    uint64_t v17 = *v20;
  }
  while (*v20);
  if (v16 == v10 || *((_DWORD *)v16 + 8) > a3) {
LABEL_24:
  }
    uint64_t v16 = v10;
  uint64_t v23 = *((void *)v16 + 6);
  CFStringRef v21 = v16 + 48;
  uint64_t v22 = v23;
  if (!v23) {
    goto LABEL_36;
  }
  CFTypeRef v24 = v21;
  do
  {
    unsigned int v25 = *(_DWORD *)(v22 + 32);
    BOOL v26 = v25 >= a2;
    if (v25 >= a2) {
      CFArrayRef v27 = (uint64_t *)v22;
    }
    else {
      CFArrayRef v27 = (uint64_t *)(v22 + 8);
    }
    if (v26) {
      CFTypeRef v24 = (char *)v22;
    }
    uint64_t v22 = *v27;
  }
  while (*v27);
  if (v24 == v21 || *((_DWORD *)v24 + 8) > a2) {
LABEL_36:
  }
    CFTypeRef v24 = v21;
  if (!v9) {
    goto LABEL_48;
  }
  CFTypeRef v28 = v10;
  uint64_t v29 = v9;
  do
  {
    unsigned int v30 = *(_DWORD *)(v29 + 32);
    BOOL v31 = v30 >= a3;
    if (v30 >= a3) {
      int v32 = (uint64_t *)v29;
    }
    else {
      int v32 = (uint64_t *)(v29 + 8);
    }
    if (v31) {
      CFTypeRef v28 = (char *)v29;
    }
    uint64_t v29 = *v32;
  }
  while (*v32);
  if (v28 == v10 || *((_DWORD *)v28 + 8) > a3) {
LABEL_48:
  }
    CFTypeRef v28 = v10;
  if (v24 == v28 + 48)
  {
    if (!v9) {
      goto LABEL_63;
    }
    long long v33 = v10;
    do
    {
      unsigned int v34 = *(_DWORD *)(v9 + 32);
      BOOL v35 = v34 >= a3;
      if (v34 >= a3) {
        unint64_t v36 = (uint64_t *)v9;
      }
      else {
        unint64_t v36 = (uint64_t *)(v9 + 8);
      }
      if (v35) {
        long long v33 = (char *)v9;
      }
      uint64_t v9 = *v36;
    }
    while (*v36);
    if (v33 == v10 || *((_DWORD *)v33 + 8) > a3) {
LABEL_63:
    }
      long long v33 = v10;
    v50 = 0;
    uint64_t v51 = 0;
    unsigned __int8 v49 = &v50;
    LODWORD(v52) = a2;
    v54 = 0;
    uint64_t v55 = 0;
    v53 = &v54;
    std::__tree<std::__value_type<unsigned int,std::map<unsigned int,std::map<unsigned int,unsigned int>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::map<unsigned int,std::map<unsigned int,unsigned int>>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::map<unsigned int,std::map<unsigned int,unsigned int>>>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int,std::map<unsigned int,std::map<unsigned int,unsigned int>>>>((uint64_t)(v33 + 40), (unsigned int *)&v52, (uint64_t)&v52);
    std::__tree<std::__value_type<__CFString const*,__CFString const*>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,__CFString const*>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,__CFString const*>>>::destroy((uint64_t)&v53, v54);
    std::__tree<std::__value_type<__CFString const*,__CFString const*>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,__CFString const*>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,__CFString const*>>>::destroy((uint64_t)&v49, v50);
    uint64_t v9 = *(void *)v10;
    if (!*(void *)v10) {
      goto LABEL_75;
    }
  }
  else if (!v9)
  {
LABEL_75:
    char v37 = v10;
    goto LABEL_76;
  }
  char v37 = v10;
  do
  {
    unsigned int v38 = *(_DWORD *)(v9 + 32);
    BOOL v39 = v38 >= a3;
    if (v38 >= a3) {
      uint64_t v40 = (uint64_t *)v9;
    }
    else {
      uint64_t v40 = (uint64_t *)(v9 + 8);
    }
    if (v39) {
      char v37 = (char *)v9;
    }
    uint64_t v9 = *v40;
  }
  while (*v40);
  if (v37 == v10 || *((_DWORD *)v37 + 8) > a3) {
    goto LABEL_75;
  }
LABEL_76:
  uint64_t v43 = *((void *)v37 + 6);
  char v41 = v37 + 48;
  uint64_t v42 = v43;
  if (!v43) {
    goto LABEL_87;
  }
  char v44 = v41;
  do
  {
    unsigned int v45 = *(_DWORD *)(v42 + 32);
    BOOL v46 = v45 >= a2;
    if (v45 >= a2) {
      v47 = (uint64_t *)v42;
    }
    else {
      v47 = (uint64_t *)(v42 + 8);
    }
    if (v46) {
      char v44 = (void *)v42;
    }
    uint64_t v42 = *v47;
  }
  while (*v47);
  if (v44 == v41 || *((_DWORD *)v44 + 8) > a2) {
LABEL_87:
  }
    char v44 = v41;
  unint64_t v52 = a4 | (unint64_t)(a5 << 32);
  return std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int,unsigned int>>((uint64_t **)v44 + 5, (unsigned int *)&v52, (uint64_t *)&v52);
}

void sub_1A43BE2B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  std::__tree<std::__value_type<__CFString const*,__CFString const*>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,__CFString const*>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,__CFString const*>>>::destroy(v15, a15);
  std::__tree<std::__value_type<__CFString const*,__CFString const*>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,__CFString const*>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,__CFString const*>>>::destroy((uint64_t)&a10, a11);
  _Unwind_Resume(a1);
}

void NL::SearchRules::setIsInferred(NL::SearchRules *this, unsigned int __c)
{
  uint64_t v2 = *((void *)this + 2);
  if (v2)
  {
    stat v5 = (_DWORD *)((char *)this + 16);
    do
    {
      unsigned int v6 = *(_DWORD *)(v2 + 32);
      BOOL v7 = v6 >= __c;
      if (v6 >= __c) {
        CFStringRef v8 = (uint64_t *)v2;
      }
      else {
        CFStringRef v8 = (uint64_t *)(v2 + 8);
      }
      if (v7) {
        stat v5 = (_DWORD *)v2;
      }
      uint64_t v2 = *v8;
    }
    while (*v8);
    if (v5 != (_DWORD *)((char *)this + 16) && v5[8] <= __c)
    {
      CFRange v10 = (__int32 *)*((void *)this + 14);
      uint64_t v9 = (void **)((char *)this + 104);
      CFIndex v11 = wmemchr(*((__int32 **)this + 13), __c, ((uint64_t)v10 - *((void *)this + 13)) >> 2);
      uint64_t v12 = v11 ? v11 : v10;
      unsigned int v13 = (__int32 *)*((void *)this + 14);
      if (v12 == v13)
      {
        unint64_t v14 = *((void *)this + 15);
        if ((unint64_t)v12 >= v14)
        {
          uint64_t v16 = (__int32 *)*v9;
          uint64_t v17 = ((char *)v13 - (unsigned char *)*v9) >> 2;
          unint64_t v18 = v17 + 1;
          if ((unint64_t)(v17 + 1) >> 62) {
            std::vector<NLExtendedString>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v19 = v14 - (void)v16;
          if (v19 >> 1 > v18) {
            unint64_t v18 = v19 >> 1;
          }
          if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v20 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v20 = v18;
          }
          if (v20)
          {
            CFStringRef v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<char32_t>>((uint64_t)this + 120, v20);
            uint64_t v16 = (__int32 *)*((void *)this + 13);
            uint64_t v12 = (__int32 *)*((void *)this + 14);
          }
          else
          {
            CFStringRef v21 = 0;
          }
          uint64_t v22 = &v21[4 * v17];
          uint64_t v23 = &v21[4 * v20];
          *(_DWORD *)uint64_t v22 = __c;
          uint64_t v15 = v22 + 4;
          while (v12 != v16)
          {
            int v24 = *--v12;
            *((_DWORD *)v22 - 1) = v24;
            v22 -= 4;
          }
          *((void *)this + 13) = v22;
          *((void *)this + 14) = v15;
          *((void *)this + 15) = v23;
          if (v16) {
            operator delete(v16);
          }
        }
        else
        {
          *uint64_t v12 = __c;
          uint64_t v15 = v12 + 1;
        }
        *((void *)this + 14) = v15;
      }
    }
  }
}

void NL::SearchRules::setIsCombinable(NL::SearchRules *this, unsigned int __c)
{
  uint64_t v2 = *((void *)this + 2);
  if (v2)
  {
    stat v5 = (_DWORD *)((char *)this + 16);
    do
    {
      unsigned int v6 = *(_DWORD *)(v2 + 32);
      BOOL v7 = v6 >= __c;
      if (v6 >= __c) {
        CFStringRef v8 = (uint64_t *)v2;
      }
      else {
        CFStringRef v8 = (uint64_t *)(v2 + 8);
      }
      if (v7) {
        stat v5 = (_DWORD *)v2;
      }
      uint64_t v2 = *v8;
    }
    while (*v8);
    if (v5 != (_DWORD *)((char *)this + 16) && v5[8] <= __c)
    {
      CFRange v10 = (__int32 *)*((void *)this + 17);
      uint64_t v9 = (void **)((char *)this + 128);
      CFIndex v11 = wmemchr(*((__int32 **)this + 16), __c, ((uint64_t)v10 - *((void *)this + 16)) >> 2);
      uint64_t v12 = v11 ? v11 : v10;
      unsigned int v13 = (__int32 *)*((void *)this + 17);
      if (v12 == v13)
      {
        unint64_t v14 = *((void *)this + 18);
        if ((unint64_t)v12 >= v14)
        {
          uint64_t v16 = (__int32 *)*v9;
          uint64_t v17 = ((char *)v13 - (unsigned char *)*v9) >> 2;
          unint64_t v18 = v17 + 1;
          if ((unint64_t)(v17 + 1) >> 62) {
            std::vector<NLExtendedString>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v19 = v14 - (void)v16;
          if (v19 >> 1 > v18) {
            unint64_t v18 = v19 >> 1;
          }
          if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v20 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v20 = v18;
          }
          if (v20)
          {
            CFStringRef v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<char32_t>>((uint64_t)this + 144, v20);
            uint64_t v16 = (__int32 *)*((void *)this + 16);
            uint64_t v12 = (__int32 *)*((void *)this + 17);
          }
          else
          {
            CFStringRef v21 = 0;
          }
          uint64_t v22 = &v21[4 * v17];
          uint64_t v23 = &v21[4 * v20];
          *(_DWORD *)uint64_t v22 = __c;
          uint64_t v15 = v22 + 4;
          while (v12 != v16)
          {
            int v24 = *--v12;
            *((_DWORD *)v22 - 1) = v24;
            v22 -= 4;
          }
          *((void *)this + 16) = v22;
          *((void *)this + 17) = v15;
          *((void *)this + 18) = v23;
          if (v16) {
            operator delete(v16);
          }
        }
        else
        {
          *uint64_t v12 = __c;
          uint64_t v15 = v12 + 1;
        }
        *((void *)this + 17) = v15;
      }
    }
  }
}

void NL::SearchRules::setIsFunction(NL::SearchRules *this, unsigned int __c)
{
  uint64_t v2 = *((void *)this + 2);
  if (v2)
  {
    stat v5 = (_DWORD *)((char *)this + 16);
    do
    {
      unsigned int v6 = *(_DWORD *)(v2 + 32);
      BOOL v7 = v6 >= __c;
      if (v6 >= __c) {
        CFStringRef v8 = (uint64_t *)v2;
      }
      else {
        CFStringRef v8 = (uint64_t *)(v2 + 8);
      }
      if (v7) {
        stat v5 = (_DWORD *)v2;
      }
      uint64_t v2 = *v8;
    }
    while (*v8);
    if (v5 != (_DWORD *)((char *)this + 16) && v5[8] <= __c)
    {
      CFRange v10 = (__int32 *)*((void *)this + 20);
      uint64_t v9 = (void **)((char *)this + 152);
      CFIndex v11 = wmemchr(*((__int32 **)this + 19), __c, ((uint64_t)v10 - *((void *)this + 19)) >> 2);
      uint64_t v12 = v11 ? v11 : v10;
      unsigned int v13 = (__int32 *)*((void *)this + 20);
      if (v12 == v13)
      {
        unint64_t v14 = *((void *)this + 21);
        if ((unint64_t)v12 >= v14)
        {
          uint64_t v16 = (__int32 *)*v9;
          uint64_t v17 = ((char *)v13 - (unsigned char *)*v9) >> 2;
          unint64_t v18 = v17 + 1;
          if ((unint64_t)(v17 + 1) >> 62) {
            std::vector<NLExtendedString>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v19 = v14 - (void)v16;
          if (v19 >> 1 > v18) {
            unint64_t v18 = v19 >> 1;
          }
          if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v20 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v20 = v18;
          }
          if (v20)
          {
            CFStringRef v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<char32_t>>((uint64_t)this + 168, v20);
            uint64_t v16 = (__int32 *)*((void *)this + 19);
            uint64_t v12 = (__int32 *)*((void *)this + 20);
          }
          else
          {
            CFStringRef v21 = 0;
          }
          uint64_t v22 = &v21[4 * v17];
          uint64_t v23 = &v21[4 * v20];
          *(_DWORD *)uint64_t v22 = __c;
          uint64_t v15 = v22 + 4;
          while (v12 != v16)
          {
            int v24 = *--v12;
            *((_DWORD *)v22 - 1) = v24;
            v22 -= 4;
          }
          *((void *)this + 19) = v22;
          *((void *)this + 2nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = v15;
          *((void *)this + 21) = v23;
          if (v16) {
            operator delete(v16);
          }
        }
        else
        {
          *uint64_t v12 = __c;
          uint64_t v15 = v12 + 1;
        }
        *((void *)this + 2nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = v15;
      }
    }
  }
}

void NL::SearchRules::setRequiresComplement(NL::SearchRules *this, unsigned int __c)
{
  uint64_t v2 = *((void *)this + 2);
  if (v2)
  {
    stat v5 = (_DWORD *)((char *)this + 16);
    do
    {
      unsigned int v6 = *(_DWORD *)(v2 + 32);
      BOOL v7 = v6 >= __c;
      if (v6 >= __c) {
        CFStringRef v8 = (uint64_t *)v2;
      }
      else {
        CFStringRef v8 = (uint64_t *)(v2 + 8);
      }
      if (v7) {
        stat v5 = (_DWORD *)v2;
      }
      uint64_t v2 = *v8;
    }
    while (*v8);
    if (v5 != (_DWORD *)((char *)this + 16) && v5[8] <= __c)
    {
      CFRange v10 = (__int32 *)*((void *)this + 23);
      uint64_t v9 = (void **)((char *)this + 176);
      CFIndex v11 = wmemchr(*((__int32 **)this + 22), __c, ((uint64_t)v10 - *((void *)this + 22)) >> 2);
      uint64_t v12 = v11 ? v11 : v10;
      unsigned int v13 = (__int32 *)*((void *)this + 23);
      if (v12 == v13)
      {
        unint64_t v14 = *((void *)this + 24);
        if ((unint64_t)v12 >= v14)
        {
          uint64_t v16 = (__int32 *)*v9;
          uint64_t v17 = ((char *)v13 - (unsigned char *)*v9) >> 2;
          unint64_t v18 = v17 + 1;
          if ((unint64_t)(v17 + 1) >> 62) {
            std::vector<NLExtendedString>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v19 = v14 - (void)v16;
          if (v19 >> 1 > v18) {
            unint64_t v18 = v19 >> 1;
          }
          if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v20 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v20 = v18;
          }
          if (v20)
          {
            CFStringRef v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<char32_t>>((uint64_t)this + 192, v20);
            uint64_t v16 = (__int32 *)*((void *)this + 22);
            uint64_t v12 = (__int32 *)*((void *)this + 23);
          }
          else
          {
            CFStringRef v21 = 0;
          }
          uint64_t v22 = &v21[4 * v17];
          uint64_t v23 = &v21[4 * v20];
          *(_DWORD *)uint64_t v22 = __c;
          uint64_t v15 = v22 + 4;
          while (v12 != v16)
          {
            int v24 = *--v12;
            *((_DWORD *)v22 - 1) = v24;
            v22 -= 4;
          }
          *((void *)this + 22) = v22;
          *((void *)this + 23) = v15;
          *((void *)this + 24) = v23;
          if (v16) {
            operator delete(v16);
          }
        }
        else
        {
          *uint64_t v12 = __c;
          uint64_t v15 = v12 + 1;
        }
        *((void *)this + 23) = v15;
      }
    }
  }
}

void NL::SearchRules::setEquivalence(NL::SearchRules *this, unsigned int __c, unsigned __int32 a3)
{
  BOOL v7 = (char *)this + 64;
  unsigned int v6 = (char *)*((void *)this + 8);
  CFStringRef v8 = (uint64_t **)((char *)this + 56);
  if (!v6)
  {
LABEL_21:
    unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)this + 11) - *((void *)this + 10)) >> 3);
    std::string __p = (void *)__c;
    unint64_t v105 = v19;
    std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int,unsigned long>>((uint64_t **)this + 7, (unsigned int *)&__p, (uint64_t)&__p);
    std::string __p = (void *)a3;
    unint64_t v105 = v19;
    std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int,unsigned long>>(v8, (unsigned int *)&__p, (uint64_t)&__p);
    std::string __p = 0;
    unint64_t v105 = 0;
    v106 = 0;
    CFStringRef v21 = std::__allocate_at_least[abi:ne180100]<std::allocator<char32_t>>((uint64_t)&v106, 1uLL);
    uint64_t v22 = (char *)__p;
    uint64_t v23 = (char *)v105;
    int v24 = (char *)&v21[v20];
    *CFStringRef v21 = __c;
    unsigned int v25 = (char *)(v21 + 1);
    BOOL v26 = (char *)v21;
    while (v23 != v22)
    {
      int v27 = *((_DWORD *)v23 - 1);
      v23 -= 4;
      *((_DWORD *)v26 - 1) = v27;
      v26 -= 4;
    }
    std::string __p = v26;
    unint64_t v105 = (unint64_t)(v21 + 1);
    v106 = (char *)&v21[v20];
    if (v22)
    {
      operator delete(v22);
      int v24 = v106;
    }
    unint64_t v105 = (unint64_t)(v21 + 1);
    if (v25 >= v24)
    {
      uint64_t v29 = (char *)__p;
      uint64_t v30 = (v25 - (unsigned char *)__p) >> 2;
      unint64_t v31 = v30 + 1;
      if ((unint64_t)(v30 + 1) >> 62) {
        std::vector<NLExtendedString>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v32 = v24 - (unsigned char *)__p;
      if (v32 >> 1 > v31) {
        unint64_t v31 = v32 >> 1;
      }
      if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v33 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v33 = v31;
      }
      if (v33)
      {
        unsigned int v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<char32_t>>((uint64_t)&v106, v33);
        uint64_t v29 = (char *)__p;
        unsigned int v25 = (char *)v105;
      }
      else
      {
        unsigned int v34 = 0;
      }
      v70 = (unsigned __int32 *)&v34[4 * v30];
      v71 = &v34[4 * v33];
      unsigned __int32 *v70 = a3;
      CFTypeRef v28 = v70 + 1;
      while (v25 != v29)
      {
        unsigned __int32 v72 = *((_DWORD *)v25 - 1);
        v25 -= 4;
        *--v70 = v72;
      }
      std::string __p = v70;
      unint64_t v105 = (unint64_t)v28;
      v106 = v71;
      if (v29) {
        operator delete(v29);
      }
    }
    else
    {
      v21[1] = a3;
      CFTypeRef v28 = v21 + 2;
    }
    unint64_t v105 = (unint64_t)v28;
    unint64_t v73 = *((void *)this + 11);
    if (v73 >= *((void *)this + 12))
    {
      uint64_t v74 = std::vector<std::vector<unsigned int>>::__push_back_slow_path<std::vector<unsigned int> const&>((uint64_t *)this + 10, (uint64_t)&__p);
    }
    else
    {
      std::vector<std::vector<unsigned int>>::__construct_one_at_end[abi:ne180100]<std::vector<unsigned int> const&>((uint64_t)this + 80, (uint64_t)&__p);
      uint64_t v74 = v73 + 24;
    }
    *((void *)this + 11) = v74;
    if (__p)
    {
      unint64_t v105 = (unint64_t)__p;
      operator delete(__p);
    }
    return;
  }
  uint64_t v9 = (char *)this + 64;
  CFRange v10 = (char *)*((void *)this + 8);
  do
  {
    unsigned int v11 = *((_DWORD *)v10 + 7);
    BOOL v12 = v11 >= __c;
    if (v11 >= __c) {
      unsigned int v13 = (char **)v10;
    }
    else {
      unsigned int v13 = (char **)(v10 + 8);
    }
    if (v12) {
      uint64_t v9 = v10;
    }
    CFRange v10 = *v13;
  }
  while (*v13);
  unint64_t v14 = (char *)this + 64;
  uint64_t v15 = (char *)*((void *)this + 8);
  if (v9 == v7 || (unint64_t v14 = (char *)this + 64, v15 = (char *)*((void *)this + 8), *((_DWORD *)v9 + 7) > __c))
  {
    do
    {
      unsigned __int32 v16 = *((_DWORD *)v15 + 7);
      BOOL v17 = v16 >= a3;
      if (v16 >= a3) {
        unint64_t v18 = (char **)v15;
      }
      else {
        unint64_t v18 = (char **)(v15 + 8);
      }
      if (v17) {
        unint64_t v14 = v15;
      }
      uint64_t v15 = *v18;
    }
    while (*v18);
    if (v14 == v7 || *((_DWORD *)v14 + 7) > a3) {
      goto LABEL_21;
    }
    v53 = (char *)this + 64;
    do
    {
      unsigned __int32 v54 = *((_DWORD *)v6 + 7);
      BOOL v55 = v54 >= a3;
      if (v54 >= a3) {
        v56 = (char **)v6;
      }
      else {
        v56 = (char **)(v6 + 8);
      }
      if (v55) {
        v53 = v6;
      }
      unsigned int v6 = *v56;
    }
    while (*v56);
    if (v53 == v7 || *((_DWORD *)v53 + 7) > a3) {
      v53 = (char *)this + 64;
    }
    uint64_t v39 = *((unsigned int *)v53 + 8);
    uint64_t v57 = *((void *)this + 10) + 24 * v39;
    v58 = *(__int32 **)(v57 + 8);
    v59 = wmemchr(*(__int32 **)v57, __c, ((uint64_t)v58 - *(void *)v57) >> 2);
    if (v59) {
      v60 = v59;
    }
    else {
      v60 = v58;
    }
    uint64_t v61 = *((void *)this + 10);
    uint64_t v62 = (__int32 **)(v61 + 24 * v39);
    v64 = v62 + 1;
    v63 = v62[1];
    if (v60 == v63)
    {
      uint64_t v65 = v61 + 24 * v39;
      unint64_t v68 = *(void *)(v65 + 16);
      v67 = (char **)(v65 + 16);
      unint64_t v66 = v68;
      if ((unint64_t)v60 >= v68)
      {
        v81 = *v62;
        uint64_t v82 = v63 - *v62;
        unint64_t v83 = v82 + 1;
        if ((unint64_t)(v82 + 1) >> 62) {
          std::vector<NLExtendedString>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v84 = v66 - (void)v81;
        if (v84 >> 1 > v83) {
          unint64_t v83 = v84 >> 1;
        }
        if ((unint64_t)v84 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v85 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v85 = v83;
        }
        if (v85)
        {
          v86 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<char32_t>>((uint64_t)v67, v85);
          v60 = *v64;
          v81 = *v62;
        }
        else
        {
          v86 = 0;
        }
        v96 = &v86[4 * v82];
        v97 = &v86[4 * v85];
        *(_DWORD *)v96 = __c;
        v69 = (__int32 *)(v96 + 4);
        while (v60 != v81)
        {
          int v98 = *--v60;
          *((_DWORD *)v96 - 1) = v98;
          v96 -= 4;
        }
        *uint64_t v62 = (__int32 *)v96;
        *v64 = v69;
        *v67 = v97;
        if (v81) {
          operator delete(v81);
        }
      }
      else
      {
        __int32 *v60 = __c;
        v69 = v60 + 1;
      }
      *v64 = v69;
    }
    uint64_t v99 = *(void *)v7;
    if (!*(void *)v7) {
      goto LABEL_134;
    }
    v100 = v7;
    do
    {
      unsigned int v101 = *(_DWORD *)(v99 + 28);
      BOOL v102 = v101 >= __c;
      if (v101 >= __c) {
        v103 = (uint64_t *)v99;
      }
      else {
        v103 = (uint64_t *)(v99 + 8);
      }
      if (v102) {
        v100 = (char *)v99;
      }
      uint64_t v99 = *v103;
    }
    while (*v103);
    if (v100 == v7 || *((_DWORD *)v100 + 7) > __c)
    {
LABEL_134:
      uint64_t v95 = __c;
      goto LABEL_135;
    }
  }
  else
  {
    BOOL v35 = (char *)this + 64;
    do
    {
      unsigned int v36 = *((_DWORD *)v6 + 7);
      BOOL v37 = v36 >= __c;
      if (v36 >= __c) {
        unsigned int v38 = (char **)v6;
      }
      else {
        unsigned int v38 = (char **)(v6 + 8);
      }
      if (v37) {
        BOOL v35 = v6;
      }
      unsigned int v6 = *v38;
    }
    while (*v38);
    if (v35 == v7 || *((_DWORD *)v35 + 7) > __c) {
      BOOL v35 = (char *)this + 64;
    }
    uint64_t v39 = *((unsigned int *)v35 + 8);
    uint64_t v40 = *((void *)this + 10) + 24 * v39;
    char v41 = *(unsigned __int32 **)(v40 + 8);
    uint64_t v42 = wmemchr(*(__int32 **)v40, a3, ((uint64_t)v41 - *(void *)v40) >> 2);
    if (v42) {
      uint64_t v43 = (unsigned __int32 *)v42;
    }
    else {
      uint64_t v43 = v41;
    }
    uint64_t v44 = *((void *)this + 10);
    unsigned int v45 = (unsigned __int32 **)(v44 + 24 * v39);
    v47 = v45 + 1;
    BOOL v46 = v45[1];
    if (v43 == v46)
    {
      uint64_t v48 = v44 + 24 * v39;
      unint64_t v51 = *(void *)(v48 + 16);
      v50 = (char **)(v48 + 16);
      unint64_t v49 = v51;
      if ((unint64_t)v43 >= v51)
      {
        v75 = *v45;
        uint64_t v76 = v46 - *v45;
        unint64_t v77 = v76 + 1;
        if ((unint64_t)(v76 + 1) >> 62) {
          std::vector<NLExtendedString>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v78 = v49 - (void)v75;
        if (v78 >> 1 > v77) {
          unint64_t v77 = v78 >> 1;
        }
        if ((unint64_t)v78 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v79 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v79 = v77;
        }
        if (v79)
        {
          v80 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<char32_t>>((uint64_t)v50, v79);
          uint64_t v43 = *v47;
          v75 = *v45;
        }
        else
        {
          v80 = 0;
        }
        v87 = (unsigned __int32 *)&v80[4 * v76];
        v88 = &v80[4 * v79];
        unsigned __int32 *v87 = a3;
        unint64_t v52 = v87 + 1;
        while (v43 != v75)
        {
          unsigned __int32 v89 = *--v43;
          *--v87 = v89;
        }
        *unsigned int v45 = v87;
        uint64_t *v47 = v52;
        void *v50 = v88;
        if (v75) {
          operator delete(v75);
        }
      }
      else
      {
        *uint64_t v43 = a3;
        unint64_t v52 = v43 + 1;
      }
      uint64_t *v47 = v52;
    }
    uint64_t v90 = *(void *)v7;
    if (!*(void *)v7) {
      goto LABEL_115;
    }
    v91 = v7;
    do
    {
      unsigned __int32 v92 = *(_DWORD *)(v90 + 28);
      BOOL v93 = v92 >= a3;
      if (v92 >= a3) {
        v94 = (uint64_t *)v90;
      }
      else {
        v94 = (uint64_t *)(v90 + 8);
      }
      if (v93) {
        v91 = (char *)v90;
      }
      uint64_t v90 = *v94;
    }
    while (*v94);
    if (v91 == v7 || *((_DWORD *)v91 + 7) > a3)
    {
LABEL_115:
      uint64_t v95 = a3;
LABEL_135:
      std::string __p = (void *)(v95 | (v39 << 32));
      std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int,unsigned int>>(v8, (unsigned int *)&__p, (uint64_t *)&__p);
    }
  }
}

void sub_1A43BED90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

NL::SearchRules *NL::SearchRules::SearchRules(NL::SearchRules *this)
{
  *(_WORD *)this = 0;
  *((unsigned char *)this + 2) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 1) = (char *)this + 16;
  *((void *)this + 3) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 4) = (char *)this + 40;
  *((void *)this + 8) = 0;
  *((void *)this + 7) = (char *)this + 64;
  *((void *)this + 6) = 0;
  *((void *)this + 9) = 0;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((void *)this + 27) = 0;
  *((void *)this + 26) = 0;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 1nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((void *)this + 24) = 0;
  *((void *)this + 25) = (char *)this + 208;
  NL::SearchRules::loadVocabulary((uint64_t **)this);
  return this;
}

void sub_1A43BEE80(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  uint64_t v10 = v6;
  std::__tree<std::__value_type<unsigned int,std::map<unsigned int,std::map<unsigned int,unsigned int>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::map<unsigned int,std::map<unsigned int,unsigned int>>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::map<unsigned int,std::map<unsigned int,unsigned int>>>>>::destroy(v10, *(void **)(v2 + 208));
  BOOL v12 = *(void **)(v2 + 176);
  if (v12)
  {
    *(void *)(v2 + 184) = v12;
    operator delete(v12);
  }
  NL::SearchRules::SearchRules(v9, v8, v7, (void *)v2);
  std::vector<std::vector<CFRange>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  std::__tree<std::__value_type<__CFString const*,__CFString const*>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,__CFString const*>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,__CFString const*>>>::destroy(v5, *(void **)(v2 + 64));
  std::__tree<std::string>::destroy(v4, *(char **)(v2 + 40));
  std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::destroy(v3, *(char **)(v2 + 16));
  _Unwind_Resume(a1);
}

void NL::SearchRules::loadVocabulary(uint64_t **this)
{
  uint64_t v2 = this + 4;
  std::string::basic_string[abi:ne180100]<0>(v3, "None");
  *(_OWORD *)std::string __p = *(_OWORD *)v3;
  *(void *)&__p[16] = v4;
  v3[1] = 0;
  uint64_t v4 = 0;
  v3[0] = 0;
  LODWORD(v6) = 0;
  std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::__emplace_unique_key_args<std::string,std::pair<std::string,unsigned int>>(v2, (const void **)__p, (uint64_t)__p);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  if (SHIBYTE(v4) < 0) {
    operator delete(v3[0]);
  }
  std::string::basic_string[abi:ne180100]<0>(v3, "None");
  *(_DWORD *)std::string __p = 0;
  *(_OWORD *)&__p[8] = *(_OWORD *)v3;
  uint64_t v6 = v4;
  v3[0] = 0;
  v3[1] = 0;
  uint64_t v4 = 0;
  std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int,std::string>>(this + 1, (unsigned int *)__p, (uint64_t)__p);
  if (SHIBYTE(v6) < 0) {
    operator delete(*(void **)&__p[8]);
  }
  if (SHIBYTE(v4) < 0) {
    operator delete(v3[0]);
  }
  std::string::basic_string[abi:ne180100]<0>(v3, "S");
  *(_OWORD *)std::string __p = *(_OWORD *)v3;
  *(void *)&__p[16] = v4;
  v3[1] = 0;
  uint64_t v4 = 0;
  v3[0] = 0;
  LODWORD(v6) = 1;
  std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::__emplace_unique_key_args<std::string,std::pair<std::string,unsigned int>>(v2, (const void **)__p, (uint64_t)__p);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  if (SHIBYTE(v4) < 0) {
    operator delete(v3[0]);
  }
  std::string::basic_string[abi:ne180100]<0>(v3, "S");
  *(_DWORD *)std::string __p = 1;
  *(_OWORD *)&__p[8] = *(_OWORD *)v3;
  uint64_t v6 = v4;
  v3[0] = 0;
  v3[1] = 0;
  uint64_t v4 = 0;
  std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int,std::string>>(this + 1, (unsigned int *)__p, (uint64_t)__p);
  if (SHIBYTE(v6) < 0) {
    operator delete(*(void **)&__p[8]);
  }
  if (SHIBYTE(v4) < 0) {
    operator delete(v3[0]);
  }
  std::string::basic_string[abi:ne180100]<0>(v3, "$");
  *(_OWORD *)std::string __p = *(_OWORD *)v3;
  *(void *)&__p[16] = v4;
  v3[1] = 0;
  uint64_t v4 = 0;
  v3[0] = 0;
  LODWORD(v6) = 2;
  std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::__emplace_unique_key_args<std::string,std::pair<std::string,unsigned int>>(v2, (const void **)__p, (uint64_t)__p);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  if (SHIBYTE(v4) < 0) {
    operator delete(v3[0]);
  }
  std::string::basic_string[abi:ne180100]<0>(v3, "$");
  *(_DWORD *)std::string __p = 2;
  *(_OWORD *)&__p[8] = *(_OWORD *)v3;
  uint64_t v6 = v4;
  v3[0] = 0;
  v3[1] = 0;
  uint64_t v4 = 0;
  std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int,std::string>>(this + 1, (unsigned int *)__p, (uint64_t)__p);
  if (SHIBYTE(v6) < 0) {
    operator delete(*(void **)&__p[8]);
  }
  if (SHIBYTE(v4) < 0) {
    operator delete(v3[0]);
  }
  *((_DWORD *)this + 1) = 3;
  std::string::basic_string[abi:ne180100]<0>(__p, "To");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 3);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "Of");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 4);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "From");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 5);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "For");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 6);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "About");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 7);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "With");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 8);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "By");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 9);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "In");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 10);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "As");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 11);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "Via");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 12);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "Honorific");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 13);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "After");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 14);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "Before");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 15);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "Since");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 16);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "Contact");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 17);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "EmailAddress");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 18);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "JabberOrEmail");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 19);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "AIMOrEmail");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 20);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "Date");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 21);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "TO");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 22);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "FROM");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 23);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "FROMTO");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 24);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "SENTO");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 25);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "SENTFROM");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 26);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "WITH");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 27);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "BY");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 28);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "AUTHORED");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 29);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "DATE");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 30);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "ANYDATE");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 31);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "FROMDATE");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 32);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "BEFOREDATE");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 33);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "AFTERDATE");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 34);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "SINCEDATE");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 35);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "STARTDATE");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 36);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "ENDDATE");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 37);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "ABOUT");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 38);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "TOPIC");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 39);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "TOPICMOD");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 40);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "THEME");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 41);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "TITLE");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 42);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "TITLED");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 43);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "TITLEMOD");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 44);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "FILETITLED");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 45);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "QUOTED");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 46);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "SENTMOD");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 47);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "RECEIVEMOD");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 48);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "IGNORED");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 49);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "IGNOREMOD");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 50);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "REPLIED");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 51);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "REPLYMOD");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 52);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "FLAGGED");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 53);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "FLAGMOD");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 54);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "CREATED");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 55);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "MODIFIED");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 56);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "DOWNLOADED");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 57);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "PRINTED");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 58);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "VIEWED");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 59);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "ADDED");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 60);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "AIRDROPPED");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 61);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "MESSAGED");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 62);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "MAILED");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 63);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "SHARED");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 64);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "CAPTURED");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 65);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "CONTAINS");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 66);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "TAGGED");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 67);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "TAGMOD");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 68);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "ATTACHED");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 69);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "ATTACHMOD");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 70);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "KIND");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 71);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "ALBUM");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 72);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "Sent");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 73);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "UserSent");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 74);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "Received");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 75);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "Tag");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 76);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "Text");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 77);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "NameText");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 78);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "QuotedText");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 79);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "Title");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 80);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "Titled");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 81);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "MessageKind");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 82);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "MailKind");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 83);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "ChatKind");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 84);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "WebsiteKind");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 85);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "EventKind");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 86);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "ImageKind");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 87);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "VideoKind");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 88);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "AudioKind");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 89);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "AlbumKind");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 90);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "ApplicationKind");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 91);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "PresentationKind");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 92);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "SpreadsheetKind");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 93);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "DocumentKind");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 94);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "FileKind");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 95);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "PdfKind");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 96);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "BookKind");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 97);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "NotesKind");
  NL::SearchRules::addVocabulary((uint64_t)this, (uint64_t)__p, 98);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
}

void sub_1A43C0368(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A43C0500(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *__p, int a18, __int16 a19, char a20,char a21,int a22,__int16 a23,char a24,char a25)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    JUMPOUT(0x1A43C04F4);
  }
  JUMPOUT(0x1A43C04F8);
}

BOOL NL::SearchRules::hasExpansions(NL::SearchRules *this, unsigned int a2)
{
  uint64_t v4 = (char *)*((void *)this + 26);
  uint64_t v2 = (char *)this + 208;
  uint64_t v3 = v4;
  if (!v4) {
    goto LABEL_12;
  }
  uint64_t v5 = v2;
  do
  {
    unsigned int v6 = *((_DWORD *)v3 + 8);
    BOOL v7 = v6 >= a2;
    if (v6 >= a2) {
      CFStringRef v8 = (char **)v3;
    }
    else {
      CFStringRef v8 = (char **)(v3 + 8);
    }
    if (v7) {
      uint64_t v5 = v3;
    }
    uint64_t v3 = *v8;
  }
  while (*v8);
  if (v5 == v2 || *((_DWORD *)v5 + 8) > a2) {
LABEL_12:
  }
    uint64_t v5 = v2;
  return v5 != v2;
}

BOOL NL::SearchRules::isEquivalent(NL::SearchRules *this, unsigned int a2, unsigned int a3)
{
  uint64_t v5 = (char *)*((void *)this + 8);
  uint64_t v3 = (char *)this + 64;
  uint64_t v4 = v5;
  if (!v5) {
    return 0;
  }
  unsigned int v6 = v3;
  BOOL v7 = v4;
  do
  {
    unsigned int v8 = *((_DWORD *)v7 + 7);
    BOOL v9 = v8 >= a2;
    if (v8 >= a2) {
      uint64_t v10 = (char **)v7;
    }
    else {
      uint64_t v10 = (char **)(v7 + 8);
    }
    if (v9) {
      unsigned int v6 = v7;
    }
    BOOL v7 = *v10;
  }
  while (*v10);
  if (v6 == v3 || *((_DWORD *)v6 + 7) > a2) {
    return 0;
  }
  unsigned int v11 = v3;
  BOOL v12 = v4;
  do
  {
    unsigned int v13 = *((_DWORD *)v12 + 7);
    BOOL v14 = v13 >= a3;
    if (v13 >= a3) {
      uint64_t v15 = (char **)v12;
    }
    else {
      uint64_t v15 = (char **)(v12 + 8);
    }
    if (v14) {
      unsigned int v11 = v12;
    }
    BOOL v12 = *v15;
  }
  while (*v15);
  if (v11 == v3 || *((_DWORD *)v11 + 7) > a3) {
    return 0;
  }
  unsigned __int32 v16 = v3;
  BOOL v17 = v4;
  do
  {
    unsigned int v18 = *((_DWORD *)v17 + 7);
    BOOL v19 = v18 >= a2;
    if (v18 >= a2) {
      uint64_t v20 = (char **)v17;
    }
    else {
      uint64_t v20 = (char **)(v17 + 8);
    }
    if (v19) {
      unsigned __int32 v16 = v17;
    }
    BOOL v17 = *v20;
  }
  while (*v20);
  if (v16 == v3 || *((_DWORD *)v16 + 7) > a2) {
    unsigned __int32 v16 = v3;
  }
  int v21 = *((_DWORD *)v16 + 8);
  uint64_t v22 = v3;
  do
  {
    unsigned int v23 = *((_DWORD *)v4 + 7);
    BOOL v24 = v23 >= a3;
    if (v23 >= a3) {
      unsigned int v25 = (char **)v4;
    }
    else {
      unsigned int v25 = (char **)(v4 + 8);
    }
    if (v24) {
      uint64_t v22 = v4;
    }
    uint64_t v4 = *v25;
  }
  while (*v25);
  if (v22 == v3 || *((_DWORD *)v22 + 7) > a3) {
    uint64_t v22 = v3;
  }
  return v21 == *((_DWORD *)v22 + 8);
}

char *NL::SearchRules::term(NL::SearchRules *this, unsigned int a2)
{
  uint64_t v4 = (char *)*((void *)this + 2);
  uint64_t v2 = (char *)this + 16;
  uint64_t v3 = v4;
  if (!v4) {
    goto LABEL_26;
  }
  uint64_t v5 = v2;
  unsigned int v6 = v3;
  do
  {
    unsigned int v7 = *((_DWORD *)v6 + 8);
    BOOL v8 = v7 >= a2;
    if (v7 >= a2) {
      BOOL v9 = (char **)v6;
    }
    else {
      BOOL v9 = (char **)(v6 + 8);
    }
    if (v8) {
      uint64_t v5 = v6;
    }
    unsigned int v6 = *v9;
  }
  while (*v9);
  if (v5 == v2 || *((_DWORD *)v5 + 8) > a2)
  {
    do
    {
      uint64_t v10 = v3;
      uint64_t v3 = *(char **)v3;
    }
    while (v3);
    if (v10 != v2 && !*((_DWORD *)v10 + 8)) {
      return v10 + 40;
    }
LABEL_26:
    uint64_t v10 = v2;
    return v10 + 40;
  }
  uint64_t v10 = v2;
  do
  {
    unsigned int v11 = *((_DWORD *)v3 + 8);
    BOOL v12 = v11 >= a2;
    if (v11 >= a2) {
      unsigned int v13 = (char **)v3;
    }
    else {
      unsigned int v13 = (char **)(v3 + 8);
    }
    if (v12) {
      uint64_t v10 = v3;
    }
    uint64_t v3 = *v13;
  }
  while (*v13);
  if (v10 == v2 || *((_DWORD *)v10 + 8) > a2) {
    goto LABEL_26;
  }
  return v10 + 40;
}

uint64_t NL::SearchRules::termID(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 *)(a2 + 23);
  if ((v2 & 0x80u) != 0) {
    uint64_t v2 = *(void *)(a2 + 8);
  }
  if (!v2) {
    return 0;
  }
  uint64_t v4 = a1 + 32;
  if (a1 + 40 != std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::find<std::string>(a1 + 32, (const void **)a2))return *(unsigned int *)(std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::find<std::string>(v4, (const void **)a2)+ 56); {
  std::string::basic_string[abi:ne180100]<0>(__p, "None");
  }
  uint64_t v5 = *(unsigned int *)(std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::find<std::string>(v4, (const void **)__p)+ 56);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  return v5;
}

void sub_1A43C07F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NL::SearchRules::score(NL::SearchRules *this, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v6 = (char *)*((void *)this + 26);
  uint64_t v4 = (char *)this + 208;
  uint64_t v5 = v6;
  if (!v6) {
    return 0;
  }
  unsigned int v7 = v4;
  char v8 = v5;
  do
  {
    unsigned int v9 = *((_DWORD *)v8 + 8);
    BOOL v10 = v9 >= a3;
    if (v9 >= a3) {
      unsigned int v11 = (char **)v8;
    }
    else {
      unsigned int v11 = (char **)(v8 + 8);
    }
    if (v10) {
      unsigned int v7 = v8;
    }
    char v8 = *v11;
  }
  while (*v11);
  if (v7 == v4 || *((_DWORD *)v7 + 8) > a3) {
    return 0;
  }
  BOOL v12 = v4;
  do
  {
    unsigned int v13 = *((_DWORD *)v5 + 8);
    BOOL v14 = v13 >= a3;
    if (v13 >= a3) {
      uint64_t v15 = (char **)v5;
    }
    else {
      uint64_t v15 = (char **)(v5 + 8);
    }
    if (v14) {
      BOOL v12 = v5;
    }
    uint64_t v5 = *v15;
  }
  while (*v15);
  if (v12 == v4 || *((_DWORD *)v12 + 8) > a3) {
    BOOL v12 = v4;
  }
  unsigned int v18 = (char *)*((void *)v12 + 6);
  unsigned __int32 v16 = v12 + 48;
  BOOL v17 = v18;
  if (!v18) {
    return 0;
  }
  BOOL v19 = v16;
  uint64_t v20 = v17;
  do
  {
    unsigned int v21 = *((_DWORD *)v20 + 8);
    BOOL v22 = v21 >= a2;
    if (v21 >= a2) {
      unsigned int v23 = (char **)v20;
    }
    else {
      unsigned int v23 = (char **)(v20 + 8);
    }
    if (v22) {
      BOOL v19 = v20;
    }
    uint64_t v20 = *v23;
  }
  while (*v23);
  if (v19 == v16 || *((_DWORD *)v19 + 8) > a2) {
    return 0;
  }
  BOOL v24 = v16;
  do
  {
    unsigned int v25 = *((_DWORD *)v17 + 8);
    BOOL v26 = v25 >= a2;
    if (v25 >= a2) {
      int v27 = (char **)v17;
    }
    else {
      int v27 = (char **)(v17 + 8);
    }
    if (v26) {
      BOOL v24 = v17;
    }
    BOOL v17 = *v27;
  }
  while (*v27);
  if (v24 == v16 || *((_DWORD *)v24 + 8) > a2) {
    BOOL v24 = v16;
  }
  uint64_t v30 = (char *)*((void *)v24 + 6);
  uint64_t v29 = v24 + 48;
  CFTypeRef v28 = v30;
  if (!v30) {
    return 0;
  }
  unint64_t v31 = v29;
  uint64_t v32 = v28;
  do
  {
    unsigned int v33 = *((_DWORD *)v32 + 7);
    BOOL v34 = v33 >= a4;
    if (v33 >= a4) {
      BOOL v35 = (uint64_t *)v32;
    }
    else {
      BOOL v35 = (uint64_t *)(v32 + 8);
    }
    if (v34) {
      unint64_t v31 = v32;
    }
    uint64_t v32 = (char *)*v35;
  }
  while (*v35);
  if (v31 == v29 || *((_DWORD *)v31 + 7) > a4) {
    return 0;
  }
  BOOL v37 = v29;
  do
  {
    unsigned int v38 = *((_DWORD *)v28 + 7);
    BOOL v39 = v38 >= a4;
    if (v38 >= a4) {
      uint64_t v40 = (uint64_t *)v28;
    }
    else {
      uint64_t v40 = (uint64_t *)(v28 + 8);
    }
    if (v39) {
      BOOL v37 = v28;
    }
    CFTypeRef v28 = (char *)*v40;
  }
  while (*v40);
  if (v37 == v29 || *((_DWORD *)v37 + 7) > a4) {
    BOOL v37 = v29;
  }
  return *((unsigned int *)v37 + 8);
}

uint64_t NL::SearchRules::termIDs(uint64_t result, uint64_t a2)
{
  char v8 = 0;
  uint64_t v2 = *(void **)(result + 8);
  uint64_t v3 = (void *)(result + 16);
  if (v2 != (void *)(result + 16))
  {
    do
    {
      double result = (*(uint64_t (**)(uint64_t, void, char *))(a2 + 16))(a2, *((unsigned int *)v2 + 8), &v8);
      if (v8) {
        break;
      }
      uint64_t v5 = (void *)v2[1];
      if (v5)
      {
        do
        {
          unsigned int v6 = v5;
          uint64_t v5 = (void *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          unsigned int v6 = (void *)v2[2];
          BOOL v7 = *v6 == (void)v2;
          uint64_t v2 = v6;
        }
        while (!v7);
      }
      uint64_t v2 = v6;
    }
    while (v6 != v3);
  }
  return result;
}

void NL::SearchRules::expansions(uint64_t a1, unsigned int a2, uint64_t a3)
{
  unsigned __int8 v38 = 0;
  uint64_t v5 = *(void *)(a1 + 208);
  uint64_t v3 = a1 + 208;
  uint64_t v4 = v5;
  if (v5)
  {
    uint64_t v7 = v3;
    uint64_t v8 = v4;
    do
    {
      unsigned int v9 = *(_DWORD *)(v8 + 32);
      BOOL v10 = v9 >= a2;
      if (v9 >= a2) {
        unsigned int v11 = (uint64_t *)v8;
      }
      else {
        unsigned int v11 = (uint64_t *)(v8 + 8);
      }
      if (v10) {
        uint64_t v7 = v8;
      }
      uint64_t v8 = *v11;
    }
    while (*v11);
    if (v7 != v3 && *(_DWORD *)(v7 + 32) <= a2)
    {
      uint64_t v12 = v3;
      do
      {
        unsigned int v13 = *(_DWORD *)(v4 + 32);
        BOOL v14 = v13 >= a2;
        if (v13 >= a2) {
          uint64_t v15 = (uint64_t *)v4;
        }
        else {
          uint64_t v15 = (uint64_t *)(v4 + 8);
        }
        if (v14) {
          uint64_t v12 = v4;
        }
        uint64_t v4 = *v15;
      }
      while (*v15);
      if (v12 == v3 || *(_DWORD *)(v12 + 32) > a2) {
        uint64_t v12 = v3;
      }
      unsigned __int32 v16 = *(void **)(v12 + 40);
      BOOL v17 = (void *)(v12 + 48);
      if (v16 != (void *)(v12 + 48))
      {
        do
        {
          std::string __p = 0;
          unsigned int v36 = 0;
          BOOL v37 = 0;
          unsigned int v18 = (void *)v16[5];
          if (v18 != v16 + 6)
          {
            BOOL v19 = 0;
            do
            {
              if (v19 >= v37)
              {
                uint64_t v20 = (char *)__p;
                uint64_t v21 = (v19 - (unsigned char *)__p) >> 2;
                unint64_t v22 = v21 + 1;
                if ((unint64_t)(v21 + 1) >> 62) {
                  std::vector<NLExtendedString>::__throw_length_error[abi:ne180100]();
                }
                uint64_t v23 = v37 - (unsigned char *)__p;
                if ((v37 - (unsigned char *)__p) >> 1 > v22) {
                  unint64_t v22 = v23 >> 1;
                }
                if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFFCLL) {
                  unint64_t v24 = 0x3FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v24 = v22;
                }
                if (v24)
                {
                  unsigned int v25 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<char32_t>>((uint64_t)&v37, v24);
                  uint64_t v20 = (char *)__p;
                  BOOL v19 = v36;
                }
                else
                {
                  unsigned int v25 = 0;
                }
                BOOL v26 = &v25[4 * v21];
                *(_DWORD *)BOOL v26 = *((_DWORD *)v18 + 7);
                int v27 = v26 + 4;
                while (v19 != v20)
                {
                  int v28 = *((_DWORD *)v19 - 1);
                  v19 -= 4;
                  *((_DWORD *)v26 - 1) = v28;
                  v26 -= 4;
                }
                std::string __p = v26;
                unsigned int v36 = v27;
                BOOL v37 = &v25[4 * v24];
                if (v20) {
                  operator delete(v20);
                }
                BOOL v19 = v27;
              }
              else
              {
                *(_DWORD *)BOOL v19 = *((_DWORD *)v18 + 7);
                v19 += 4;
              }
              unsigned int v36 = v19;
              uint64_t v29 = (void *)v18[1];
              if (v29)
              {
                do
                {
                  uint64_t v30 = v29;
                  uint64_t v29 = (void *)*v29;
                }
                while (v29);
              }
              else
              {
                do
                {
                  uint64_t v30 = (void *)v18[2];
                  BOOL v31 = *v30 == (void)v18;
                  unsigned int v18 = v30;
                }
                while (!v31);
              }
              unsigned int v18 = v30;
            }
            while (v30 != v16 + 6);
          }
          (*(void (**)(uint64_t, void, void **, unsigned __int8 *))(a3 + 16))(a3, *((unsigned int *)v16 + 8), &__p, &v38);
          int v32 = v38;
          if (__p)
          {
            unsigned int v36 = (char *)__p;
            operator delete(__p);
          }
          if (v32) {
            break;
          }
          unsigned int v33 = (void *)v16[1];
          if (v33)
          {
            do
            {
              BOOL v34 = v33;
              unsigned int v33 = (void *)*v33;
            }
            while (v33);
          }
          else
          {
            do
            {
              BOOL v34 = (void *)v16[2];
              BOOL v31 = *v34 == (void)v16;
              unsigned __int32 v16 = v34;
            }
            while (!v31);
          }
          unsigned __int32 v16 = v34;
        }
        while (v34 != v17);
      }
    }
  }
}

void sub_1A43C0C78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NL::SearchRules::getTermID(uint64_t a1, const void **a2)
{
  uint64_t v4 = (void *)(a1 + 32);
  uint64_t v5 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::find<std::string>(a1 + 32, a2);
  if (a1 + 40 != v5) {
    return *(unsigned int *)(std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::find<std::string>((uint64_t)v4, a2)+ 56);
  }
  uint64_t v7 = (void *)*v4;
  if (*v4 == v5)
  {
    uint64_t result = 1;
  }
  else
  {
    unsigned int v8 = 0;
    do
    {
      if (*((_DWORD *)v7 + 14) > v8) {
        unsigned int v8 = *((_DWORD *)v7 + 14);
      }
      unsigned int v9 = (void *)v7[1];
      if (v9)
      {
        do
        {
          BOOL v10 = v9;
          unsigned int v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          BOOL v10 = (void *)v7[2];
          BOOL v11 = *v10 == (void)v7;
          uint64_t v7 = v10;
        }
        while (!v11);
      }
      uint64_t v7 = v10;
    }
    while (v10 != (void *)v5);
    uint64_t result = v8 + 1;
  }
  *(_DWORD *)(a1 + 4) = result;
  return result;
}

void std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::destroy(uint64_t a1, char *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::destroy(a1, *(void *)a2);
    std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::destroy(a1, *((void *)a2 + 1));
    if (a2[63] < 0) {
      operator delete(*((void **)a2 + 5));
    }
    operator delete(a2);
  }
}

void std::__tree<std::__value_type<unsigned int,std::map<unsigned int,std::map<unsigned int,unsigned int>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::map<unsigned int,std::map<unsigned int,unsigned int>>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::map<unsigned int,std::map<unsigned int,unsigned int>>>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<unsigned int,std::map<unsigned int,std::map<unsigned int,unsigned int>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::map<unsigned int,std::map<unsigned int,unsigned int>>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::map<unsigned int,std::map<unsigned int,unsigned int>>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<unsigned int,std::map<unsigned int,std::map<unsigned int,unsigned int>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::map<unsigned int,std::map<unsigned int,unsigned int>>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::map<unsigned int,std::map<unsigned int,unsigned int>>>>>::destroy(a1, a2[1]);
    std::__tree<std::__value_type<unsigned int,std::map<unsigned int,unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::map<unsigned int,unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::map<unsigned int,unsigned int>>>>::destroy((uint64_t)(a2 + 5), (void *)a2[6]);
    operator delete(a2);
  }
}

void std::__function::__func<void (*)(void *,nlp::_TrieCompletion *,BOOL *),std::allocator<void (*)(void *,nlp::_TrieCompletion *,BOOL *)>,void ()(void *,nlp::_TrieCompletion *,BOOL *)>::~__func()
{
}

void *std::__function::__func<void (*)(void *,nlp::_TrieCompletion *,BOOL *),std::allocator<void (*)(void *,nlp::_TrieCompletion *,BOOL *)>,void ()(void *,nlp::_TrieCompletion *,BOOL *)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF7CDE58;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void (*)(void *,nlp::_TrieCompletion *,BOOL *),std::allocator<void (*)(void *,nlp::_TrieCompletion *,BOOL *)>,void ()(void *,nlp::_TrieCompletion *,BOOL *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF7CDE58;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<void (*)(void *,nlp::_TrieCompletion *,BOOL *),std::allocator<void (*)(void *,nlp::_TrieCompletion *,BOOL *)>,void ()(void *,nlp::_TrieCompletion *,BOOL *)>::operator()(uint64_t a1, void *a2, void *a3, void *a4)
{
  return (*(uint64_t (**)(void, void, void))(a1 + 8))(*a2, *a3, *a4);
}

uint64_t std::__function::__func<void (*)(void *,nlp::_TrieCompletion *,BOOL *),std::allocator<void (*)(void *,nlp::_TrieCompletion *,BOOL *)>,void ()(void *,nlp::_TrieCompletion *,BOOL *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void (*)(void *,nlp::_TrieCompletion *,BOOL *),std::allocator<void (*)(void *,nlp::_TrieCompletion *,BOOL *)>,void ()(void *,nlp::_TrieCompletion *,BOOL *)>::target_type()
{
}

void std::__tree<std::__value_type<unsigned int,std::map<unsigned int,unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::map<unsigned int,unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::map<unsigned int,unsigned int>>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<unsigned int,std::map<unsigned int,unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::map<unsigned int,unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::map<unsigned int,unsigned int>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<unsigned int,std::map<unsigned int,unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::map<unsigned int,unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::map<unsigned int,unsigned int>>>>::destroy(a1, a2[1]);
    std::__tree<std::__value_type<__CFString const*,__CFString const*>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,__CFString const*>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,__CFString const*>>>::destroy((uint64_t)(a2 + 5), (void *)a2[6]);
    operator delete(a2);
  }
}

uint64_t *std::__tree<std::__value_type<unsigned int,std::map<unsigned int,std::map<unsigned int,unsigned int>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::map<unsigned int,std::map<unsigned int,unsigned int>>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::map<unsigned int,std::map<unsigned int,unsigned int>>>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int,std::map<unsigned int,std::map<unsigned int,unsigned int>>>>(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v5 = (uint64_t **)(a1 + 8);
  uint64_t v4 = *(uint64_t **)(a1 + 8);
  if (v4)
  {
    unsigned int v6 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v4;
        unsigned int v8 = *((_DWORD *)v4 + 8);
        if (v6 >= v8) {
          break;
        }
        uint64_t v4 = *v7;
        uint64_t v5 = v7;
        if (!*v7) {
          goto LABEL_10;
        }
      }
      if (v8 >= v6) {
        break;
      }
      uint64_t v4 = v7[1];
      if (!v4)
      {
        uint64_t v5 = v7 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v7 = (uint64_t **)(a1 + 8);
LABEL_10:
    std::__tree<std::__value_type<unsigned int,std::map<unsigned int,std::map<unsigned int,unsigned int>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::map<unsigned int,std::map<unsigned int,unsigned int>>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::map<unsigned int,std::map<unsigned int,unsigned int>>>>>::__construct_node<std::pair<unsigned int,std::map<unsigned int,std::map<unsigned int,unsigned int>>>>(a1, a3, (uint64_t)&v10);
    std::__tree<std::string>::__insert_node_at((uint64_t **)a1, (uint64_t)v7, v5, v10);
    return v10;
  }
  return (uint64_t *)v7;
}

_DWORD *std::__tree<std::__value_type<unsigned int,std::map<unsigned int,std::map<unsigned int,unsigned int>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::map<unsigned int,std::map<unsigned int,unsigned int>>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::map<unsigned int,std::map<unsigned int,unsigned int>>>>>::__construct_node<std::pair<unsigned int,std::map<unsigned int,std::map<unsigned int,unsigned int>>>>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  uint64_t result = operator new(0x40uLL);
  *(void *)a3 = result;
  *(void *)(a3 + 8) = v5;
  result[8] = *(_DWORD *)a2;
  uint64_t v7 = (void *)(a2 + 16);
  uint64_t v8 = *(void *)(a2 + 16);
  *((void *)result + 5) = *(void *)(a2 + 8);
  *((void *)result + 6) = v8;
  unsigned int v9 = (char *)(result + 12);
  uint64_t v10 = *(void *)(a2 + 24);
  *((void *)result + 7) = v10;
  if (v10)
  {
    *(void *)(v8 + 16) = v9;
    *(void *)(a2 + 8) = v7;
    *uint64_t v7 = 0;
    *(void *)(a2 + 24) = 0;
  }
  else
  {
    *((void *)result + 5) = v9;
  }
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

uint64_t *std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int,unsigned int>>(uint64_t **a1, unsigned int *a2, uint64_t *a3)
{
  unsigned int v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    unsigned int v7 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v8 = (uint64_t **)v5;
        unsigned int v9 = *((_DWORD *)v5 + 7);
        if (v7 >= v9) {
          break;
        }
        uint64_t v5 = *v8;
        unsigned int v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      uint64_t v5 = v8[1];
      if (!v5)
      {
        unsigned int v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v8 = a1 + 1;
LABEL_10:
    uint64_t v10 = (uint64_t *)operator new(0x28uLL);
    *(uint64_t *)((char *)v10 + 28) = *a3;
    std::__tree<std::string>::__insert_node_at(a1, (uint64_t)v8, v6, v10);
    return v10;
  }
  return (uint64_t *)v8;
}

_OWORD *std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::__emplace_unique_key_args<std::string,std::pair<std::string,unsigned int>>(uint64_t **a1, const void **a2, uint64_t a3)
{
  uint64_t v5 = (void **)std::__tree<std::string>::__find_equal<std::string>((uint64_t)a1, &v9, a2);
  unsigned int v6 = *v5;
  if (!*v5)
  {
    unsigned int v7 = (uint64_t **)v5;
    unsigned int v6 = operator new(0x40uLL);
    v6[2] = *(_OWORD *)a3;
    *((void *)v6 + 6) = *(void *)(a3 + 16);
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *((_DWORD *)v6 + 14) = *(_DWORD *)(a3 + 24);
    std::__tree<std::string>::__insert_node_at(a1, v9, v7, (uint64_t *)v6);
  }
  return v6;
}

uint64_t **std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int,std::string>>(uint64_t **a1, unsigned int *a2, uint64_t a3)
{
  unsigned int v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    unsigned int v7 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v8 = (uint64_t **)v5;
        unsigned int v9 = *((_DWORD *)v5 + 8);
        if (v7 >= v9) {
          break;
        }
        uint64_t v5 = *v8;
        unsigned int v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      uint64_t v5 = v8[1];
      if (!v5)
      {
        unsigned int v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v8 = a1 + 1;
LABEL_10:
    uint64_t v10 = (char *)operator new(0x40uLL);
    *((_DWORD *)v10 + 8) = *(_DWORD *)a3;
    *(_OWORD *)(v10 + 4nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = *(_OWORD *)(a3 + 8);
    *((void *)v10 + 7) = *(void *)(a3 + 24);
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)(a3 + 24) = 0;
    std::__tree<std::string>::__insert_node_at(a1, (uint64_t)v8, v6, (uint64_t *)v10);
    return (uint64_t **)v10;
  }
  return v8;
}

uint64_t **std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int,unsigned long>>(uint64_t **a1, unsigned int *a2, uint64_t a3)
{
  unsigned int v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    unsigned int v7 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v8 = (uint64_t **)v5;
        unsigned int v9 = *((_DWORD *)v5 + 7);
        if (v7 >= v9) {
          break;
        }
        uint64_t v5 = *v8;
        unsigned int v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      uint64_t v5 = v8[1];
      if (!v5)
      {
        unsigned int v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v8 = a1 + 1;
LABEL_10:
    uint64_t v10 = (uint64_t *)operator new(0x28uLL);
    uint64_t v11 = *(void *)(a3 + 8);
    *((_DWORD *)v10 + 7) = *(_DWORD *)a3;
    *((_DWORD *)v10 + 8) = v11;
    std::__tree<std::string>::__insert_node_at(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }
  return v8;
}

void *std::vector<std::vector<unsigned int>>::__construct_one_at_end[abi:ne180100]<std::vector<unsigned int> const&>(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void **)(a1 + 8);
  *uint64_t v3 = 0;
  v3[1] = 0;
  v3[2] = 0;
  uint64_t result = std::vector<unsigned int>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>(v3, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
  *(void *)(a1 + 8) = v3 + 3;
  return result;
}

void sub_1A43C13D8(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::vector<unsigned int>>::__push_back_slow_path<std::vector<unsigned int> const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL) {
    std::vector<NLExtendedString>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x555555555555555) {
    unint64_t v9 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v9 = v5;
  }
  BOOL v17 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = &v10[24 * v4];
  v14[0] = v10;
  v14[1] = v11;
  uint64_t v15 = v11;
  unsigned __int32 v16 = &v10[24 * v9];
  *(void *)uint64_t v11 = 0;
  *((void *)v11 + 1) = 0;
  *((void *)v11 + 2) = 0;
  std::vector<unsigned int>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>(v11, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
  v15 += 24;
  std::vector<std::vector<unsigned int>>::__swap_out_circular_buffer(a1, v14);
  uint64_t v12 = a1[1];
  std::__split_buffer<std::vector<CFRange>>::~__split_buffer((uint64_t)v14);
  return v12;
}

void sub_1A43C14E4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::vector<CFRange>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void *std::vector<unsigned int>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unsigned int v6 = result;
    uint64_t result = std::vector<float>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1A43C1558(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<unsigned int>>,std::reverse_iterator<std::vector<unsigned int>*>,std::reverse_iterator<std::vector<unsigned int>*>,std::reverse_iterator<std::vector<unsigned int>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v14 = a6;
  *((void *)&v14 + 1) = a7;
  long long v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    uint64_t v9 = a6;
  }
  else
  {
    do
    {
      *(void *)(v7 - 24) = 0;
      *(void *)(v7 - 16) = 0;
      *(void *)(v7 - 8) = 0;
      long long v8 = *(_OWORD *)(a3 - 3);
      a3 -= 3;
      *(_OWORD *)(v7 - 24) = v8;
      *(void *)(v7 - 8) = a3[2];
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      uint64_t v7 = *((void *)&v14 + 1) - 24;
      *((void *)&v14 + 1) -= 24;
    }
    while (a3 != a5);
    uint64_t v9 = v14;
  }
  char v12 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<unsigned int>>,std::reverse_iterator<std::vector<unsigned int>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<unsigned int>>,std::reverse_iterator<std::vector<unsigned int>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<CFRange>>,std::reverse_iterator<std::vector<CFRange>*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void NLAbstractDictionaryLookup::NLAbstractDictionaryLookup(NLAbstractDictionaryLookup *this)
{
  *(void *)this = &unk_1EF7CD5E0;
  *((void *)this + 1) = 0;
}

void NLAbstractDictionaryLookup::~NLAbstractDictionaryLookup(NLAbstractDictionaryLookup *this)
{
  *(void *)this = &unk_1EF7CD5E0;
  uint64_t v1 = (NL::StringMap *)*((void *)this + 1);
  if (v1)
  {
    NL::StringMap::~StringMap(v1);
    MEMORY[0x1A625B130]();
  }
}

uint64_t NLAbstractDictionaryLookup::getDictMap(NLAbstractDictionaryLookup *this)
{
  return *((void *)this + 1);
}

void *NLAbstractDictionaryLookup::getWord@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "");
}

_DWORD *NLMessageIntentTypeWithMetadata::NLMessageIntentTypeWithMetadata(_DWORD *a1, int a2, uint64_t a3)
{
  *a1 = a2;
  std::unordered_map<std::string,std::string>::unordered_map((uint64_t)(a1 + 2), a3);
  return a1;
}

void NLEnglishHindiDictionaryLookup::NLEnglishHindiDictionaryLookup(NLEnglishHindiDictionaryLookup *this)
{
  NLAbstractDictionaryLookup::NLAbstractDictionaryLookup(this);
  *(void *)uint64_t v1 = &unk_1EF7CDBC0;
  NLEnglishHindiDictionaryLookup::loadDictMap(v1);
}

void sub_1A43C1768(_Unwind_Exception *a1)
{
  NLAbstractDictionaryLookup::~NLAbstractDictionaryLookup(v1);
  _Unwind_Resume(a1);
}

void NLEnglishHindiDictionaryLookup::loadDictMap(NLEnglishHindiDictionaryLookup *this)
{
  CFLocaleCreate(0, @"hi");
  uint64_t v5 = 0;
  unsigned int v6 = &v5;
  uint64_t v7 = 0x2000000000;
  uint64_t v8 = 0;
  __p[3] = (void *)MEMORY[0x1E4F143A8];
  __p[4] = (void *)0x40000000;
  __p[5] = ___ZN30NLEnglishHindiDictionaryLookup11loadDictMapEv_block_invoke;
  __p[6] = &unk_1E5B363E0;
  __p[7] = &v5;
  LMEnumerateAssetDataItems();
  CFStringRef v2 = (const __CFString *)v6[3];
  if (v2)
  {
    getUTF8StringFromCFString(v2, __p);
    CFRelease((CFTypeRef)v6[3]);
    NL::StringMap::createWithFile();
  }
  uint64_t v3 = NL::CFLogger::sharedInstance(0);
  (*(void (**)(uint64_t, uint64_t, const char *))(*(void *)v3 + 16))(v3, 3, "Could not locate English-Hindi dictionary resource");
  *((void *)this + 1) = 0;
  _Block_object_dispose(&v5, 8);
}

void sub_1A43C18E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  _Block_object_dispose((const void *)(v14 - 48), 8);
  _Unwind_Resume(a1);
}

void ___ZN30NLEnglishHindiDictionaryLookup11loadDictMapEv_block_invoke(uint64_t a1, CFURLRef url, uint64_t a3, uint64_t a4, uint64_t a5, unsigned char *a6)
{
  CFStringRef PathComponent = CFURLCopyLastPathComponent(url);
  if (PathComponent)
  {
    CFStringRef v10 = PathComponent;
    if (CFStringsAreEqual(PathComponent, @"english-hindi.dict"))
    {
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = CFURLCopyPath(url);
      *a6 = 1;
    }
    CFRelease(v10);
  }
}

double NLEnglishHindiDictionaryLookup::getWord@<D0>(uint64_t a1@<X0>, const void **a2@<X1>, void *a3@<X8>)
{
  unint64_t v4 = *(uint64_t **)(a1 + 8);
  if (v4)
  {
    NL::StringMap::get(v4, a2, &v31);
    if (!std::string::compare(&v31, ""))
    {
      double result = *(double *)&v31.__r_.__value_.__l.__data_;
      *(std::string *)a3 = v31;
    }
    else
    {
      int v27 = a3;
      chars = 0;
      uint64_t v5 = 0;
      uint64_t v29 = 0;
      uint64_t v30 = 0;
      std::string::size_type size = HIBYTE(v31.__r_.__value_.__r.__words[2]);
      if ((v31.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v7 = &v31;
      }
      else {
        uint64_t v7 = (std::string *)v31.__r_.__value_.__r.__words[0];
      }
      if ((v31.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type size = v31.__r_.__value_.__l.__size_;
      }
      uint64_t v8 = (std::string *)((char *)v7 + size);
      uint64_t v9 = *MEMORY[0x1E4FBA418];
      uint64_t v10 = *(void *)(MEMORY[0x1E4FBA418] + 24);
      do
      {
        unsigned int v11 = v7->__r_.__value_.__s.__data_[0];
        if (v11 > 0x71)
        {
          if (v11 == 114)
          {
            __int16 v12 = 44;
          }
          else
          {
            std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v34);
            std::ostream::operator<<();
            long long v13 = (NL::CFLogger *)std::stringbuf::str();
            uint64_t v14 = NL::CFLogger::sharedInstance(v13);
            p_p = (const char *)&__p;
            if (v33 < 0) {
              p_p = (const char *)__p;
            }
            (*(void (**)(uint64_t, uint64_t, const char *, ...))(*(void *)v14 + 16))(v14, 3, "Could not find decoding for character: %s\n", p_p);
            if (v33 < 0) {
              operator delete(__p);
            }
            v34[0] = v9;
            *(void *)((char *)v34 + *(void *)(v9 - 24)) = v10;
            v34[1] = MEMORY[0x1E4FBA470] + 16;
            if (v35 < 0) {
              operator delete((void *)v34[9]);
            }
            std::streambuf::~streambuf();
            std::ostream::~ostream();
            MEMORY[0x1A625B0A0](&v36);
            __int16 v12 = 32;
            uint64_t v5 = v29;
          }
        }
        else
        {
          __int16 v12 = v11 + 2304;
        }
        if (v5 >= v30)
        {
          unsigned __int32 v16 = chars;
          uint64_t v17 = (char *)v5 - (char *)chars;
          if ((char *)v5 - (char *)chars <= -3) {
            std::vector<NLExtendedString>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v18 = v17 >> 1;
          if ((char *)v30 - (char *)chars <= (unint64_t)((v17 >> 1) + 1)) {
            uint64_t v19 = v18 + 1;
          }
          else {
            uint64_t v19 = (char *)v30 - (char *)chars;
          }
          if ((unint64_t)((char *)v30 - (char *)chars) >= 0x7FFFFFFFFFFFFFFELL) {
            uint64_t v20 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v20 = v19;
          }
          if (v20)
          {
            uint64_t v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned short>>((uint64_t)&v30, v20);
            unsigned __int32 v16 = chars;
            uint64_t v5 = v29;
          }
          else
          {
            uint64_t v21 = 0;
          }
          unint64_t v22 = (__int16 *)&v21[2 * v18];
          *unint64_t v22 = v12;
          uint64_t v23 = v22 + 1;
          while (v5 != (__int16 *)v16)
          {
            __int16 v24 = *--v5;
            *--unint64_t v22 = v24;
          }
          chars = (UniChar *)v22;
          uint64_t v30 = (__int16 *)&v21[2 * v20];
          if (v16) {
            operator delete(v16);
          }
          uint64_t v5 = v23;
        }
        else
        {
          *v5++ = v12;
        }
        uint64_t v29 = v5;
        uint64_t v7 = (std::string *)((char *)v7 + 1);
      }
      while (v7 != v8);
      CFStringRef v25 = CFStringCreateWithCharacters(0, chars, ((char *)v5 - (char *)chars) >> 1);
      getUTF8StringFromCFString(v25, v27);
      CFRelease(v25);
      if (chars) {
        operator delete(chars);
      }
      if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v31.__r_.__value_.__l.__data_);
      }
    }
  }
  else
  {
    std::string::basic_string[abi:ne180100]<0>(a3, "");
  }
  return result;
}

void sub_1A43C1D30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void **a11, void *__p, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  if (*(char *)(v27 + 23) < 0) {
    operator delete(*a11);
  }
  if (__p) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void NLTextSlot::~NLTextSlot(NLTextSlot *this)
{
  uint64_t v1 = (const void *)*((void *)this + 3);
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t NLTextSlot::getRange(NLTextSlot *this)
{
  return *(void *)this;
}

uint64_t NLTextSlot::getSlotID(NLTextSlot *this)
{
  return *((unsigned int *)this + 4);
}

uint64_t NLTextSlot::getResolvedDate(NLTextSlot *this)
{
  return *((void *)this + 3);
}

uint64_t NLTextSlot::getAllDayEventFlag(NLTextSlot *this)
{
  return *((unsigned __int8 *)this + 32);
}

uint64_t NLTextStructuredEvent::NLTextStructuredEvent(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8, uint64_t a9)
{
  *(_OWORD *)(a1 + 56) = 0u;
  unsigned int v11 = (char *)(a1 + 56);
  __int16 v12 = (char *)(a1 + 80);
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 4nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = 0u;
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  *(void *)(a1 + 16) = a4;
  *(void *)(a1 + 24) = a5;
  *(void *)(a1 + 32) = a6;
  uint64_t v13 = *a7;
  uint64_t v14 = a7[1];
  if (v14)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
    uint64_t v15 = *(std::__shared_weak_count **)(a1 + 48);
    *(void *)(a1 + 4nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = v13;
    *(void *)(a1 + 48) = v14;
    if (v15) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v15);
    }
  }
  else
  {
    *(void *)(a1 + 48) = 0;
    *(void *)(a1 + 4nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = v13;
  }
  if (v11 != (char *)a8) {
    std::vector<NLTextSlot *>::__assign_with_size[abi:ne180100]<NLTextSlot **,NLTextSlot **>(v11, *(char **)a8, *(void *)(a8 + 8), (uint64_t)(*(void *)(a8 + 8) - *(void *)a8) >> 3);
  }
  if (v12 != (char *)a9) {
    std::vector<NLTextSlot *>::__assign_with_size[abi:ne180100]<NLTextSlot **,NLTextSlot **>(v12, *(char **)a9, *(void *)(a9 + 8), (uint64_t)(*(void *)(a9 + 8) - *(void *)a9) >> 3);
  }
  return a1;
}

void sub_1A43C1EDC(_Unwind_Exception *a1)
{
  unsigned int v6 = *v3;
  if (*v3)
  {
    *(void *)(v1 + 88) = v6;
    operator delete(v6);
  }
  NLTextStructuredEvent::NLTextStructuredEvent(v2, v4, v1);
  _Unwind_Resume(a1);
}

void NLTextStructuredEvent::~NLTextStructuredEvent(NLTextStructuredEvent *this)
{
  CFStringRef v2 = (NLTextSlot *)*((void *)this + 4);
  if (v2)
  {
    NLTextSlot::~NLTextSlot(v2);
    MEMORY[0x1A625B130]();
  }
  if (*((void *)this + 5))
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 6);
    *((void *)this + 5) = 0;
    *((void *)this + 6) = 0;
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    }
  }
  unint64_t v4 = (NLTextSlot **)*((void *)this + 7);
  uint64_t v5 = (NLTextSlot **)*((void *)this + 8);
  if (v5 == v4)
  {
    unint64_t v4 = (NLTextSlot **)*((void *)this + 8);
  }
  else
  {
    unint64_t v6 = 0;
    do
    {
      if (v4[v6])
      {
        NLTextSlot::~NLTextSlot(v4[v6]);
        MEMORY[0x1A625B130]();
        unint64_t v4 = (NLTextSlot **)*((void *)this + 7);
        uint64_t v5 = (NLTextSlot **)*((void *)this + 8);
      }
      ++v6;
    }
    while (v6 < v5 - v4);
  }
  uint64_t v7 = (void *)*((void *)this + 10);
  uint64_t v8 = (unsigned char *)*((void *)this + 11);
  if (v8 == (unsigned char *)v7)
  {
    uint64_t v7 = (void *)*((void *)this + 11);
  }
  else
  {
    unint64_t v9 = 0;
    do
    {
      uint64_t v10 = (NLTextSlot *)v7[v9];
      if (v10)
      {
        NLTextSlot::~NLTextSlot(v10);
        MEMORY[0x1A625B130]();
        uint64_t v7 = (void *)*((void *)this + 10);
        uint64_t v8 = (unsigned char *)*((void *)this + 11);
      }
      ++v9;
    }
    while (v9 < (v8 - (unsigned char *)v7) >> 3);
    unint64_t v4 = (NLTextSlot **)*((void *)this + 7);
  }
  *((void *)this + 8) = v4;
  *((void *)this + 11) = v7;
  if (v7)
  {
    operator delete(v7);
    unint64_t v4 = (NLTextSlot **)*((void *)this + 7);
  }
  if (v4)
  {
    *((void *)this + 8) = v4;
    operator delete(v4);
  }
  unsigned int v11 = (std::__shared_weak_count *)*((void *)this + 6);
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v11);
  }
}

uint64_t NLTextStructuredEvent::getActionPhraseRange(NLTextStructuredEvent *this)
{
  return *((void *)this + 2);
}

uint64_t NLTextStructuredEvent::getRecurrentEvent(NLTextStructuredEvent *this)
{
  return *((void *)this + 5);
}

void *NLTextStructuredEvent::getLocationRanges@<X0>(NLTextStructuredEvent *this@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return std::vector<NLTextSlot *>::__init_with_size[abi:ne180100]<NLTextSlot **,NLTextSlot **>(a2, *((const void **)this + 7), *((void *)this + 8), (uint64_t)(*((void *)this + 8) - *((void *)this + 7)) >> 3);
}

void *NLTextStructuredEvent::getPeopleRanges@<X0>(NLTextStructuredEvent *this@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return std::vector<NLTextSlot *>::__init_with_size[abi:ne180100]<NLTextSlot **,NLTextSlot **>(a2, *((const void **)this + 10), *((void *)this + 11), (uint64_t)(*((void *)this + 11) - *((void *)this + 10)) >> 3);
}

void NLTextSlotRecurrentEvent::NLTextSlotRecurrentEvent(NLTextSlotRecurrentEvent *this, CFTypeRef cf, CFTypeRef a3, CFTypeRef a4, CFRange a5, char a6)
{
  CFIndex length = a5.length;
  CFIndex location = a5.location;
  *((void *)this + 4) = 0;
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  if (cf) {
    *(void *)this = CFRetain(cf);
  }
  if (a3) {
    *((void *)this + 1) = CFRetain(a3);
  }
  if (a4) {
    *((void *)this + 4) = CFRetain(a4);
  }
  *((void *)this + 2) = location;
  *((void *)this + 3) = length;
  *((unsigned char *)this + 4nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = a6;
}

void NLTextSlotRecurrentEvent::~NLTextSlotRecurrentEvent(NLTextSlotRecurrentEvent *this)
{
  CFStringRef v2 = *(const void **)this;
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)*((void *)this + 1);
  if (v3) {
    CFRelease(v3);
  }
  unint64_t v4 = (const void *)*((void *)this + 4);
  if (v4) {
    CFRelease(v4);
  }
}

uint64_t NLTextSlotRecurrentEvent::getEventEndDate(NLTextSlotRecurrentEvent *this)
{
  return *((void *)this + 1);
}

uint64_t NLTextSlotRecurrentEvent::getAllDayEventFlag(NLTextSlotRecurrentEvent *this)
{
  return *((unsigned __int8 *)this + 40);
}

uint64_t NLTextSlotRecurrentEvent::setEventDateRange(uint64_t this, uint64_t a2, uint64_t a3)
{
  *(void *)(this + 16) = a2;
  *(void *)(this + 24) = a3;
  return this;
}

void NLTextSlotParser::NLTextSlotParser(NLTextSlotParser *this, const __CFLocale *a2, const __CFDictionary *a3)
{
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  *(void *)this = MEMORY[0x1A625A380](*MEMORY[0x1E4F1CF80], a2);
  *((void *)this + 1) = CFRetain(a3);
}

void NLTextSlotParser::~NLTextSlotParser(NLTextSlotParser *this)
{
  CFStringRef v2 = *(const void **)this;
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)*((void *)this + 1);
  if (v3) {
    CFRelease(v3);
  }
  unint64_t v4 = (NLTextSlotParserEventExtractor *)*((void *)this + 2);
  if (v4)
  {
    NLTextSlotParserEventExtractor::~NLTextSlotParserEventExtractor(v4);
    MEMORY[0x1A625B130]();
  }
  uint64_t v5 = (NLTextSlotParserDateTimeExtractor *)*((void *)this + 3);
  if (v5)
  {
    NLTextSlotParserDateTimeExtractor::~NLTextSlotParserDateTimeExtractor(v5);
    MEMORY[0x1A625B130]();
  }
  unint64_t v6 = (NLTextSlotParserNamedEntityExtractor *)*((void *)this + 4);
  if (v6)
  {
    NLTextSlotParserNamedEntityExtractor::~NLTextSlotParserNamedEntityExtractor(v6);
    MEMORY[0x1A625B130]();
  }
  uint64_t v7 = (NLTextSlotParserRecurrenceEventExtractor *)*((void *)this + 5);
  if (v7)
  {
    NLTextSlotParserRecurrenceEventExtractor::~NLTextSlotParserRecurrenceEventExtractor(v7);
    MEMORY[0x1A625B130]();
  }
}

uint64_t NLTextSlotParser::createStructuredEvent(NLTextSlotParser *this, const __CFString *a2, const __CFTimeZone *a3)
{
  if (a3 && a2 && *(void *)this)
  {
    memset(&cf[4], 0, 48);
    unint64_t v6 = (NLTextSlotParserEventExtractor *)*((void *)this + 2);
    if (!v6) {
      operator new();
    }
    NLTextSlotParserEventExtractor::getEventNameRange(v6, a2);
    NLTextSlotParserEventExtractor::getEventActionPhraseRange(*((NLTextSlotParserEventExtractor **)this + 2), a2);
    if (!*((void *)this + 3)) {
      operator new();
    }
    NLTextSlotParserDateTimeExtractor::getEventFixedDateTimeAndRange(a3, (uint64_t)cf);
    operator new();
  }
  return 0;
}

void sub_1A43C2770(_Unwind_Exception *a1)
{
  MEMORY[0x1A625B130](v1, 0x60C40FAD0F902);
  unint64_t v4 = *(void **)(v2 - 136);
  if (v4)
  {
    *(void *)(v2 - 128) = v4;
    operator delete(v4);
  }
  uint64_t v5 = *(void **)(v2 - 112);
  if (v5)
  {
    *(void *)(v2 - 104) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(a1);
}

uint64_t std::pair<std::vector<std::pair<NLTextSlotID,CFRange>>,std::vector<std::pair<NLTextSlotID,CFRange>>>::~pair(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v3;
    operator delete(v3);
  }
  return a1;
}

char *std::vector<NLTextSlot *>::__assign_with_size[abi:ne180100]<NLTextSlot **,NLTextSlot **>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  unint64_t v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 3)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *uint64_t v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 61) {
      std::vector<NLExtendedString>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 2;
    if (v8 >> 2 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    double result = std::vector<__CFString const*>::__vallocate[abi:ne180100](v7, v11);
    uint64_t v13 = (char *)v7[1];
    __int16 v12 = (void **)(v7 + 1);
    unint64_t v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      uint64_t v18 = v9;
      uint64_t v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  __int16 v12 = (void **)(result + 8);
  uint64_t v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 3;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  unsigned __int32 v16 = &__src[8 * v15];
  if (v14 != v9)
  {
    double result = (char *)memmove(*(void **)result, __src, v14 - v9);
    unint64_t v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    uint64_t v18 = v9;
    uint64_t v19 = v16;
LABEL_18:
    double result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *__int16 v12 = &v9[v17];
  return result;
}

void *std::vector<NLTextSlot *>::__init_with_size[abi:ne180100]<NLTextSlot **,NLTextSlot **>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = result;
    double result = std::vector<__CFString const*>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      double result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1A43C2A44(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void NLQamus::NLQamus(NLQamus *this)
{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *(_OWORD *)((char *)this + 4nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = 0u;
  *((_DWORD *)this + 8) = 1065353216;
  *(_OWORD *)((char *)this + 56) = 0u;
  *((_DWORD *)this + 18) = 1065353216;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_DWORD *)this + 28) = 1065353216;
  *(_OWORD *)((char *)this + 12nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *((_DWORD *)this + 38) = 1065353216;
  *((_OWORD *)this + 1nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((_DWORD *)this + 48) = 1065353216;
  *(_OWORD *)((char *)this + 20nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = 0u;
  *((_DWORD *)this + 58) = 1065353216;
  *(_OWORD *)((char *)this + 216) = 0u;
  NLConvertBW2UTF::NLConvertBW2UTF((NLQamus *)((char *)this + 240));
}

void sub_1A43C2B04(_Unwind_Exception *a1)
{
  std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::~__hash_table(v6);
  std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::~__hash_table(v5);
  std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::~__hash_table(v4);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(v3);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(v2);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void NLQamus::~NLQamus(NLQamus *this)
{
  uint64_t v2 = (char *)this + 240;
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)this + 280);
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)v2);
  std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::~__hash_table((uint64_t)this + 200);
  std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::~__hash_table((uint64_t)this + 160);
  std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::~__hash_table((uint64_t)this + 120);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)this + 80);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)this + 40);

  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)this);
}

uint64_t NLQamus::getBw2UTFConverter@<X0>(NLQamus *this@<X0>, uint64_t a2@<X8>)
{
  return std::unordered_map<std::string,std::string>::unordered_map(a2 + 40, (uint64_t)this + 280);
}

void sub_1A43C2BF4(_Unwind_Exception *a1)
{
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void NLQamus::loadTable(uint64_t a1@<X8>)
{
  v5[72] = *MEMORY[0x1E4F143B8];
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  std::ifstream::basic_ifstream(v5);
  std::string __p = 0;
  uint64_t v3 = 0;
  uint64_t v4 = 0;
  std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100](v1, "^\\s+", 0);
}

void sub_1A43C3054(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, std::locale a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,std::locale a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,std::locale a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *__p,uint64_t a41,int a42,__int16 a43,char a44,char a45,uint64_t a46)
{
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex(&a24);
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex(&a32);
  if (a45 < 0) {
    operator delete(__p);
  }
  std::ifstream::~ifstream(&a46);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(v46);
  _Unwind_Resume(a1);
}

uint64_t NLQamus::loadDict@<X0>(uint64_t a1@<X8>)
{
  v31[19] = *MEMORY[0x1E4F143B8];
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  std::ifstream::basic_ifstream(v29);
  uint64_t v1 = (std::locale::id *)MEMORY[0x1E4FBA258];
  v27[1] = 0;
  v27[0] = 0;
  uint64_t v28 = 0;
  memset(v25, 0, sizeof(v25));
  int v26 = 1065353216;
  while (1)
  {
    std::ios_base::getloc((const std::ios_base *)((char *)v29 + *(void *)(v29[0] - 24)));
    uint64_t v2 = std::locale::use_facet(&v9[0].__loc_, v1);
    unsigned __int8 v3 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v2->__vftable[2].~facet_0)(v2, 10);
    std::locale::~locale(&v9[0].__loc_);
    uint64_t v4 = std::getline[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v29, (uint64_t)v27, v3);
    if ((*((unsigned char *)v4 + *(void *)(*v4 - 24) + 32) & 5) != 0) {
      break;
    }
    std::string::basic_string[abi:ne180100]<0>(v9, ";");
    BOOL v5 = startswith((unsigned __int8 *)v27, (unsigned __int8 *)v9);
    BOOL v6 = v5;
    if (SHIBYTE(v9[0].__col_) < 0)
    {
      operator delete(v9[0].__loc_.__locale_);
      if (!v6)
      {
LABEL_7:
        uint64_t v23 = 0;
        __str = 0;
        uint64_t v24 = 0;
        splitWithChar((uint64_t)v27, 9u, (uint64_t)&__str);
        std::string::basic_string[abi:ne180100]<0>(&v21, "");
        std::string::basic_string[abi:ne180100]<0>(&v20, "");
        std::string::basic_string[abi:ne180100]<0>(&v19, "");
        std::string::basic_string[abi:ne180100]<0>(&v18, "");
        std::string::basic_string[abi:ne180100]<0>(&v17, "");
        std::string::basic_string[abi:ne180100]<0>(&v16, "");
        std::string::basic_string[abi:ne180100]<0>(&v15, "");
        std::string::basic_string[abi:ne180100]<0>(&__p, "");
        unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * ((v23 - (uint64_t)__str) >> 3);
        switch(v7)
        {
          case 5uLL:
            std::string::operator=(&v19, __str);
            std::string::operator=(&v18, __str + 1);
            std::string::operator=(&v17, __str + 2);
            std::string::operator=(&v16, __str + 3);
            std::string::operator=(&v15, __str + 4);
            trim((unint64_t)&v15, v9);
            if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v15.__r_.__value_.__l.__data_);
            }
            std::string v15 = (std::string)v9[0];
            break;
          case 6uLL:
            std::string::operator=(&v20, __str);
            std::string::operator=(&v19, __str + 1);
            std::string::operator=(&v18, __str + 2);
            std::string::operator=(&v17, __str + 3);
            std::string::operator=(&v16, __str + 4);
            trim((unint64_t)&__str[5], v9);
            if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v15.__r_.__value_.__l.__data_);
            }
            std::string v15 = (std::string)v9[0];
LABEL_16:
            if (!std::__hash_table<std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<NLExtendedString>>>>::find<std::string>(v25, (unsigned __int8 *)&v20))std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t)v25, (unsigned __int8 *)&v20, (uint64_t)&v20); {
            break;
            }
          case 8uLL:
            std::string::operator=(&v21, __str);
            std::string::operator=(&v20, __str + 1);
            std::string::operator=(&v19, __str + 2);
            std::string::operator=(&v18, __str + 3);
            std::string::operator=(&v17, __str + 4);
            std::string::operator=(&v16, __str + 5);
            std::string::operator=(&v15, __str + 6);
            trim((unint64_t)&__str[7], v9);
            if (SHIBYTE(__p.__col_) < 0) {
              operator delete(__p.__loc_.__locale_);
            }
            std::regex_traits<char> __p = v9[0];
            goto LABEL_16;
        }
        __int16 v12 = 0;
        uint64_t v11 = 0;
        uint64_t v13 = 0;
        __int16 v12 = (std::string *)std::vector<std::string>::__push_back_slow_path<std::string const&>(&v11, (long long *)&v19);
        if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
          std::string::__init_copy_ctor_external(&v10, v19.__r_.__value_.__l.__data_, v19.__r_.__value_.__l.__size_);
        }
        else {
          std::string v10 = v19;
        }
        std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100](v9, "^[>|<{]", 0);
      }
    }
    else if (!v5)
    {
      goto LABEL_7;
    }
  }
  if (!std::filebuf::close()) {
    std::ios_base::clear((std::ios_base *)((char *)v29 + *(void *)(v29[0] - 24)), *(_DWORD *)&v30[*(void *)(v29[0] - 24) + 16] | 4);
  }
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v25);
  if (SHIBYTE(v28) < 0) {
    operator delete(v27[0]);
  }
  v29[0] = *MEMORY[0x1E4FBA3F8];
  *(uint64_t *)((char *)v29 + *(void *)(v29[0] - 24)) = *(void *)(MEMORY[0x1E4FBA3F8] + 24);
  MEMORY[0x1A625AEE0](v30);
  std::istream::~istream();
  return MEMORY[0x1A625B0A0](v31);
}

void sub_1A43C3DA4(_Unwind_Exception *a1)
{
  std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void sub_1A43C40E0()
{
}

std::string *std::regex_replace[abi:ne180100]<std::back_insert_iterator<std::string>,std::__wrap_iter<char *>,std::regex_traits<char>,char>(std::string *a1, std::__wrap_iter<const char *> a2, std::__wrap_iter<const char *> a3, const std::regex_iterator<std::__wrap_iter<const char *>, char>::regex_type *a4, char *a5, unsigned __int32 __m)
{
  __int16 v6 = __m;
  CFIndex i = (std::string::value_type *)a2.__i_;
  std::regex_iterator<std::__wrap_iter<char const*>,char,std::regex_traits<char>>::regex_iterator(&v29, a2, a3, a4, (std::regex_constants::match_flag_type)__m);
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  char v23 = 0;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  char v26 = 0;
  char v27 = 0;
  uint64_t v28 = 0;
  *(_OWORD *)std::regex_traits<char> __p = 0u;
  memset(v20, 0, sizeof(v20));
  memset(v17, 0, sizeof(v17));
  int v18 = 0;
  if (std::regex_iterator<std::__wrap_iter<char *>,char,std::regex_traits<char>>::operator==((uint64_t)&v29, (uint64_t)v17))
  {
    if ((v6 & 0x200) == 0)
    {
      while (i != a3.__i_)
        std::string::push_back(a1, *i++);
    }
  }
  else
  {
    std::__wrap_iter<const char *>::iterator_type v11 = 0;
    __int16 v12 = 0;
    uint64_t v13 = (unsigned __int8 *)&a5[strlen(a5)];
    while (!std::regex_iterator<std::__wrap_iter<char *>,char,std::regex_traits<char>>::operator==((uint64_t)&v29, (uint64_t)v17))
    {
      if ((v6 & 0x200) == 0)
      {
        uint64_t v14 = (std::string::value_type *)v29.__match_.__prefix_.first.__i_;
        std::__wrap_iter<const char *>::iterator_type v15 = v29.__match_.__prefix_.second.__i_;
        while (v14 != v15)
          std::string::push_back(a1, *v14++);
      }
      a1 = std::match_results<std::__wrap_iter<char const*>>::format<std::back_insert_iterator<std::string>>((std::string::value_type ***)&v29.__match_, a1, (unsigned __int8 *)a5, v13, v6);
      __int16 v12 = (std::string::value_type *)v29.__match_.__suffix_.first.__i_;
      std::__wrap_iter<const char *>::iterator_type v11 = v29.__match_.__suffix_.second.__i_;
      if ((v6 & 0x400) != 0) {
        break;
      }
      std::regex_iterator<std::__wrap_iter<char const*>,char,std::regex_traits<char>>::operator++(&v29);
    }
    if ((v6 & 0x200) == 0)
    {
      while (v12 != v11)
        std::string::push_back(a1, *v12++);
    }
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v29.__match_.__matches_.__begin_)
  {
    v29.__match_.__matches_.__end_ = v29.__match_.__matches_.__begin_;
    operator delete(v29.__match_.__matches_.__begin_);
  }
  return a1;
}

void sub_1A43C4268(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32)
{
  if (__p) {
    operator delete(__p);
  }
  if (a31) {
    operator delete(a31);
  }
  _Unwind_Resume(exception_object);
}

void NLQamus::loadData(NLQamus *this)
{
  v16[0] = 0;
  v16[1] = v16;
  v16[2] = 0x4002000000;
  v16[3] = __Block_byref_object_copy__13;
  v16[4] = __Block_byref_object_dispose__13;
  std::string::basic_string[abi:ne180100]<0>(&v17, "");
  v14[0] = 0;
  v14[1] = v14;
  void v14[2] = 0x4002000000;
  v14[3] = __Block_byref_object_copy__13;
  v14[4] = __Block_byref_object_dispose__13;
  std::string::basic_string[abi:ne180100]<0>(&v15, "");
  v12[0] = 0;
  v12[1] = v12;
  void v12[2] = 0x4002000000;
  v12[3] = __Block_byref_object_copy__13;
  v12[4] = __Block_byref_object_dispose__13;
  std::string::basic_string[abi:ne180100]<0>(&v13, "");
  v10[0] = 0;
  v10[1] = v10;
  void v10[2] = 0x4002000000;
  v10[3] = __Block_byref_object_copy__13;
  v10[4] = __Block_byref_object_dispose__13;
  std::string::basic_string[abi:ne180100]<0>(&v11, "");
  v8[0] = 0;
  v8[1] = v8;
  v8[2] = 0x4002000000;
  v8[3] = __Block_byref_object_copy__13;
  v8[4] = __Block_byref_object_dispose__13;
  std::string::basic_string[abi:ne180100]<0>(&v9, "");
  v6[0] = 0;
  v6[1] = v6;
  v6[2] = 0x4002000000;
  v6[3] = __Block_byref_object_copy__13;
  v6[4] = __Block_byref_object_dispose__13;
  std::string::basic_string[abi:ne180100]<0>(&v7, "");
  v4[0] = 0;
  v4[1] = v4;
  v4[2] = 0x4002000000;
  v4[3] = __Block_byref_object_copy__13;
  v4[4] = __Block_byref_object_dispose__13;
  std::string::basic_string[abi:ne180100]<0>(&__p, "");
  CFLocaleRef v2 = CFLocaleCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], @"ar");
  v3[5] = MEMORY[0x1E4F143A8];
  v3[6] = 0x40000000;
  v3[7] = (uint64_t)___ZN7NLQamus8loadDataEv_block_invoke;
  v3[8] = (uint64_t)&unk_1E5B36408;
  v3[9] = (uint64_t)v16;
  v3[10] = (uint64_t)v14;
  v3[11] = (uint64_t)v12;
  v3[12] = (uint64_t)v10;
  v3[13] = (uint64_t)v8;
  v3[14] = (uint64_t)v6;
  v3[15] = (uint64_t)v4;
  NL::Resource::enumerateAssetResourcesWithContentType();
  CFRelease(v2);
  NLConvertBW2UTF::loadBw2utf((uint64_t)this + 240);
  NLQamus::loadDict((uint64_t)v3);
  std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::__move_assign((uint64_t)this + 120, v3);
  std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::~__hash_table((uint64_t)v3);
  NLQamus::loadDict((uint64_t)v3);
  std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::__move_assign((uint64_t)this + 160, v3);
  std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::~__hash_table((uint64_t)v3);
  NLQamus::loadDict((uint64_t)v3);
  std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::__move_assign((uint64_t)this + 200, v3);
  std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::~__hash_table((uint64_t)v3);
  NLQamus::loadTable((uint64_t)v3);
}

void sub_1A43C4714(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,int a43,__int16 a44,char a45,char a46,char a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,void *a52,uint64_t a53,int a54,__int16 a55,char a56,char a57,char a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,void *a63)
{
  _Block_object_dispose(&a25, 8);
  if (a35 < 0) {
    operator delete(__p);
  }
  _Block_object_dispose(&a36, 8);
  if (a46 < 0) {
    operator delete(a41);
  }
  _Block_object_dispose(&a47, 8);
  if (a57 < 0) {
    operator delete(a52);
  }
  _Block_object_dispose(&a58, 8);
  if (a68 < 0) {
    operator delete(a63);
  }
  _Block_object_dispose((const void *)(v68 - 240), 8);
  if (*(char *)(v68 - 177) < 0) {
    operator delete(*(void **)(v68 - 200));
  }
  _Block_object_dispose((const void *)(v68 - 176), 8);
  if (*(char *)(v68 - 113) < 0) {
    operator delete(*(void **)(v68 - 136));
  }
  _Block_object_dispose((const void *)(v68 - 112), 8);
  if (*(char *)(v68 - 49) < 0) {
    operator delete(*(void **)(v68 - 72));
  }
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__13(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(__n128 *)(a1 + 4nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = result;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 4nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = 0;
  return result;
}

void __Block_byref_object_dispose__13(uint64_t a1)
{
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
}

void ___ZN7NLQamus8loadDataEv_block_invoke(int a1, const __CFURL **this)
{
  if (this) {
    NL::Resource::exists(this);
  }
  exception = __cxa_allocate_exception(0x20uLL);
  std::string::basic_string[abi:ne180100]<0>(__p, "Couldn't create the resource for Arabic Morphological Analyzer");
  NL::ResourceCreationException::ResourceCreationException(exception, (long long *)__p);
}

void sub_1A43C4D30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void extractRooPartOfSpeechTag(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  if (*(char *)(a1 + 23) < 0)
  {
    if (*(void *)(a1 + 8)) {
      goto LABEL_3;
    }
  }
  else if (*(unsigned char *)(a1 + 23))
  {
LABEL_3:
    unsigned __int8 v3 = 0;
    uint64_t v4 = 0;
    uint64_t v5 = 0;
    splitWithChar(a1, 0x20u, (uint64_t)&v3);
    std::string::basic_string[abi:ne180100]<0>(a2, "");
    if (v4 != v3) {
      std::string::operator=(a2, v3);
    }
    __int16 v6 = &v3;
    std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v6);
    return;
  }

  std::string::basic_string[abi:ne180100]<0>(a2, "");
}

void sub_1A43C4E48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  if (*(char *)(v12 + 23) < 0) {
    operator delete(*(void **)v12);
  }
  a12 = (void **)&a9;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

void NLQamus::process_word_for_analysisType(uint64_t a1, uint64_t a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (*(char *)(a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(&v27, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string v27 = *(std::string *)a2;
  }
  std::string::basic_string[abi:ne180100]<0>(&v26, "");
  long long v23 = 0u;
  long long v24 = 0u;
  int v25 = 1065353216;
  long long v20 = 0u;
  long long v21 = 0u;
  int v22 = 1065353216;
  long long v17 = 0u;
  long long v18 = 0u;
  int v19 = 1065353216;
  long long v14 = 0u;
  long long v15 = 0u;
  int v16 = 1065353216;
  long long v11 = 0u;
  long long v12 = 0u;
  int v13 = 1065353216;
  if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&v10, v27.__r_.__value_.__l.__data_, v27.__r_.__value_.__l.__size_);
  }
  else {
    std::string v10 = v27;
  }
  std::operator+<char>();
  unsigned __int8 v3 = std::string::append(&v9, "\n");
  long long v4 = *(_OWORD *)&v3->__r_.__value_.__l.__data_;
  int64_t v8 = v3->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::regex_traits<char> __p = v4;
  v3->__r_.__value_.__l.__size_ = 0;
  v3->__r_.__value_.__r.__words[2] = 0;
  v3->__r_.__value_.__r.__words[0] = 0;
  if (v8 >= 0) {
    uint64_t v5 = __p;
  }
  else {
    uint64_t v5 = (void **)__p[0];
  }
  if (v8 >= 0) {
    std::string::size_type v6 = HIBYTE(v8);
  }
  else {
    std::string::size_type v6 = (std::string::size_type)__p[1];
  }
  std::string::append(&v26, (const std::string::value_type *)v5, v6);
  if (SHIBYTE(v8) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v9.__r_.__value_.__l.__data_);
  }
  NLQamus::get_lookup(a1, (uint64_t)&v27);
}

void sub_1A43C66AC(_Unwind_Exception *a1)
{
  if (SLOBYTE(STACK[0x26F]) < 0) {
    operator delete((void *)STACK[0x258]);
  }
  if (SLOBYTE(STACK[0x287]) < 0) {
    operator delete((void *)STACK[0x270]);
  }
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&STACK[0x290]);
  std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::~__hash_table((uint64_t)&STACK[0x2C0]);
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)&STACK[0x2F0]);
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)&STACK[0x320]);
  std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::~__hash_table((uint64_t)&STACK[0x350]);
  if (SLOBYTE(STACK[0x38F]) < 0) {
    operator delete((void *)STACK[0x378]);
  }
  if (SLOBYTE(STACK[0x3A7]) < 0) {
    operator delete((void *)STACK[0x390]);
  }
  _Unwind_Resume(a1);
}

void NLQamus::get_lookup(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(&v2, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string v2 = *(std::string *)a2;
  }
  NLConvertBW2UTF::utf2bw(&v2, &v3);
}

void sub_1A43C6D68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (*(char *)(v22 + 23) < 0) {
    operator delete(*(void **)v22);
  }
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex((std::locale *)&a9);
  if (*(char *)(v23 - 17) < 0) {
    operator delete(*(void **)(v23 - 40));
  }
  _Unwind_Resume(a1);
}

void NLQamus::get_variants(long long *a1@<X1>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  memset(v9, 0, sizeof(v9));
  int v10 = 1065353216;
  std::string::basic_string[abi:ne180100]<0>(&v8, "");
  unint64_t v4 = *(void *)(a2 + 8);
  if (v4 >= *(void *)(a2 + 16))
  {
    uint64_t v5 = std::vector<std::string>::__push_back_slow_path<std::string const&>((uint64_t *)a2, a1);
  }
  else
  {
    std::vector<std::string>::__construct_one_at_end[abi:ne180100]<std::string const&>(a2, a1);
    uint64_t v5 = v4 + 24;
  }
  *(void *)(a2 + 8) = v5;
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t)v9, (unsigned __int8 *)a1, (uint64_t)a1);
  memset(&v7, 0, sizeof(v7));
  std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>((std::string *)&v7, *(long long **)a2, *(long long **)(a2 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3));
  std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100](v6, "Y'$", 0);
}

void sub_1A43C7C78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, std::locale a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,std::locale a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,std::locale a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,std::locale a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,std::locale a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,std::locale a57)
{
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex(&a25);
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex(&a33);
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex(&a41);
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex(&a49);
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex(&a57);
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex((std::locale *)(v58 - 240));
  *(void *)(v58 - 24nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = v58 - 176;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)(v58 - 240));
  if (*(char *)(v58 - 129) < 0) {
    operator delete(*(void **)(v58 - 152));
  }
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(v58 - 128);
  *(void *)(v58 - 24nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = v57;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)(v58 - 240));
  _Unwind_Resume(a1);
}

void NLQamus::analyze(void *a1@<X0>, std::string *a2@<X1>, void *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  NLQamus::segmentword(a2, (std::string::size_type)&v105);
  uint64_t v3 = v105;
  unint64_t v51 = v106;
  if (v105 != v106)
  {
    unint64_t v52 = a1 + 20;
    BOOL v55 = a1 + 15;
    uint64_t v57 = a1 + 25;
    do
    {
      v53 = v3;
      if (*((char *)v3 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&v104, *(const std::string::value_type **)v3, *((void *)v3 + 1));
      }
      else
      {
        long long v4 = *v3;
        v104.__r_.__value_.__r.__words[2] = *((void *)v3 + 2);
        *(_OWORD *)&v104.__r_.__value_.__l.__data_ = v4;
      }
      unsigned int v101 = 0;
      uint64_t v102 = 0;
      uint64_t v103 = 0;
      splitWithChar((uint64_t)&v104, 9u, (uint64_t)&v101);
      if (SHIBYTE(v101->__r_.__value_.__r.__words[2]) < 0)
      {
        std::string::__init_copy_ctor_external(&v100, v101->__r_.__value_.__l.__data_, v101->__r_.__value_.__l.__size_);
      }
      else
      {
        long long v5 = *(_OWORD *)&v101->__r_.__value_.__l.__data_;
        v100.__r_.__value_.__r.__words[2] = v101->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v100.__r_.__value_.__l.__data_ = v5;
      }
      std::string::size_type v6 = (std::string *)std::string::basic_string[abi:ne180100]<0>(v98, "");
      if (0xAAAAAAAAAAAAAAABLL * ((v102 - (uint64_t)v101) >> 3) >= 2) {
        std::string::operator=(v6, v101 + 1);
      }
      std::vector<std::string> v7 = (std::string *)std::string::basic_string[abi:ne180100]<0>(v96, "");
      if (0xAAAAAAAAAAAAAAABLL * ((v102 - (uint64_t)v101) >> 3) >= 3) {
        std::string::operator=(v7, v101 + 2);
      }
      if (std::__hash_table<std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<NLExtendedString>>>>::find<std::string>(v52, (unsigned __int8 *)&v100)&& std::__hash_table<std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<NLExtendedString>>>>::find<std::string>(v55, (unsigned __int8 *)v98)&& std::__hash_table<std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<NLExtendedString>>>>::find<std::string>(v57, (unsigned __int8 *)v96))
      {
        v63.__r_.__value_.__r.__words[0] = (std::string::size_type)&v100;
        std::string v8 = std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v52, (unsigned __int8 *)&v100, (uint64_t)&std::piecewise_construct, (long long **)&v63);
        int v10 = (long long *)*((void *)v8 + 5);
        std::string v9 = (long long *)*((void *)v8 + 6);
        unsigned __int32 v54 = v9;
        while (v10 != v9)
        {
          v56 = v10;
          if (*((char *)v10 + 23) < 0)
          {
            std::string::__init_copy_ctor_external(&v95, *(const std::string::value_type **)v10, *((void *)v10 + 1));
          }
          else
          {
            long long v11 = *v10;
            v95.__r_.__value_.__r.__words[2] = *((void *)v10 + 2);
            *(_OWORD *)&v95.__r_.__value_.__l.__data_ = v11;
          }
          memset(v94, 0, sizeof(v94));
          splitWithChar((uint64_t)&v95, 9u, (uint64_t)v94);
          uint64_t v12 = v94[0];
          if (*(char *)(v94[0] + 23) < 0)
          {
            std::string::__init_copy_ctor_external(&v93, *(const std::string::value_type **)v94[0], *(void *)(v94[0] + 8));
            uint64_t v12 = v94[0];
          }
          else
          {
            long long v13 = *(_OWORD *)v94[0];
            v93.__r_.__value_.__r.__words[2] = *(void *)(v94[0] + 16);
            *(_OWORD *)&v93.__r_.__value_.__l.__data_ = v13;
          }
          if (*(char *)(v12 + 47) < 0)
          {
            std::string::__init_copy_ctor_external(&v92, *(const std::string::value_type **)(v12 + 24), *(void *)(v12 + 32));
            uint64_t v12 = v94[0];
          }
          else
          {
            std::string v92 = *(std::string *)(v12 + 24);
          }
          if (*(char *)(v12 + 71) < 0)
          {
            std::string::__init_copy_ctor_external(&v91, *(const std::string::value_type **)(v12 + 48), *(void *)(v12 + 56));
            uint64_t v12 = v94[0];
          }
          else
          {
            std::string v91 = *(std::string *)(v12 + 48);
          }
          if (*(char *)(v12 + 95) < 0)
          {
            std::string::__init_copy_ctor_external(&v90, *(const std::string::value_type **)(v12 + 72), *(void *)(v12 + 80));
            uint64_t v12 = v94[0];
          }
          else
          {
            std::string v90 = *(std::string *)(v12 + 72);
          }
          if (*(char *)(v12 + 119) < 0) {
            std::string::__init_copy_ctor_external(&v89, *(const std::string::value_type **)(v12 + 96), *(void *)(v12 + 104));
          }
          else {
            std::string v89 = *(std::string *)(v12 + 96);
          }
          v63.__r_.__value_.__r.__words[0] = (std::string::size_type)v98;
          long long v14 = std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v55, (unsigned __int8 *)v98, (uint64_t)&std::piecewise_construct, (long long **)&v63);
          int v16 = (long long *)*((void *)v14 + 5);
          long long v15 = (long long *)*((void *)v14 + 6);
          v59 = v15;
          while (v16 != v15)
          {
            if (*((char *)v16 + 23) < 0)
            {
              std::string::__init_copy_ctor_external(&v88, *(const std::string::value_type **)v16, *((void *)v16 + 1));
            }
            else
            {
              long long v17 = *v16;
              v88.__r_.__value_.__r.__words[2] = *((void *)v16 + 2);
              *(_OWORD *)&v88.__r_.__value_.__l.__data_ = v17;
            }
            memset(v87, 0, sizeof(v87));
            splitWithChar((uint64_t)&v88, 9u, (uint64_t)v87);
            uint64_t v18 = v87[0];
            if (*(char *)(v87[0] + 23) < 0)
            {
              std::string::__init_copy_ctor_external(&v86, *(const std::string::value_type **)v87[0], *(void *)(v87[0] + 8));
              uint64_t v18 = v87[0];
            }
            else
            {
              long long v19 = *(_OWORD *)v87[0];
              v86.__r_.__value_.__r.__words[2] = *(void *)(v87[0] + 16);
              *(_OWORD *)&v86.__r_.__value_.__l.__data_ = v19;
            }
            if (*(char *)(v18 + 47) < 0)
            {
              std::string::__init_copy_ctor_external(&v85, *(const std::string::value_type **)(v18 + 24), *(void *)(v18 + 32));
              uint64_t v18 = v87[0];
            }
            else
            {
              std::string v85 = *(std::string *)(v18 + 24);
            }
            if (*(char *)(v18 + 71) < 0)
            {
              std::string::__init_copy_ctor_external(&v84, *(const std::string::value_type **)(v18 + 48), *(void *)(v18 + 56));
              uint64_t v18 = v87[0];
            }
            else
            {
              std::string v84 = *(std::string *)(v18 + 48);
            }
            if (*(char *)(v18 + 95) < 0)
            {
              std::string::__init_copy_ctor_external(&v83, *(const std::string::value_type **)(v18 + 72), *(void *)(v18 + 80));
              uint64_t v18 = v87[0];
            }
            else
            {
              std::string v83 = *(std::string *)(v18 + 72);
            }
            if (*(char *)(v18 + 119) < 0)
            {
              std::string::__init_copy_ctor_external(&v82, *(const std::string::value_type **)(v18 + 96), *(void *)(v18 + 104));
              uint64_t v18 = v87[0];
            }
            else
            {
              std::string v82 = *(std::string *)(v18 + 96);
            }
            if (*(char *)(v18 + 143) < 0)
            {
              std::string::__init_copy_ctor_external(&v81, *(const std::string::value_type **)(v18 + 120), *(void *)(v18 + 128));
              uint64_t v18 = v87[0];
            }
            else
            {
              std::string v81 = *(std::string *)(v18 + 120);
            }
            if (*(char *)(v18 + 167) < 0)
            {
              std::string::__init_copy_ctor_external(&v80, *(const std::string::value_type **)(v18 + 144), *(void *)(v18 + 152));
              uint64_t v18 = v87[0];
            }
            else
            {
              std::string v80 = *(std::string *)(v18 + 144);
            }
            if (*(char *)(v18 + 191) < 0) {
              std::string::__init_copy_ctor_external(&v79, *(const std::string::value_type **)(v18 + 168), *(void *)(v18 + 176));
            }
            else {
              std::string v79 = *(std::string *)(v18 + 168);
            }
            if ((v91.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              size_t size = HIBYTE(v91.__r_.__value_.__r.__words[2]);
            }
            else {
              size_t size = v91.__r_.__value_.__l.__size_;
            }
            std::string::basic_string[abi:ne180100]((uint64_t)&v63, size + 1);
            if ((v63.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              long long v21 = &v63;
            }
            else {
              long long v21 = (std::string *)v63.__r_.__value_.__r.__words[0];
            }
            if (size)
            {
              if ((v91.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                uint64_t v22 = &v91;
              }
              else {
                uint64_t v22 = (std::string *)v91.__r_.__value_.__r.__words[0];
              }
              memmove(v21, v22, size);
            }
            *(_WORD *)((char *)&v21->__r_.__value_.__l.__data_ + size) = 32;
            if ((v84.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              uint64_t v23 = &v84;
            }
            else {
              uint64_t v23 = (std::string *)v84.__r_.__value_.__r.__words[0];
            }
            if ((v84.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              std::string::size_type v24 = HIBYTE(v84.__r_.__value_.__r.__words[2]);
            }
            else {
              std::string::size_type v24 = v84.__r_.__value_.__l.__size_;
            }
            int v25 = std::string::append(&v63, (const std::string::value_type *)v23, v24);
            long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
            __p.__r_.__value_.__r.__words[2] = v25->__r_.__value_.__r.__words[2];
            *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v26;
            v25->__r_.__value_.__l.__size_ = 0;
            v25->__r_.__value_.__r.__words[2] = 0;
            v25->__r_.__value_.__r.__words[0] = 0;
            trim((unint64_t)&__p, v77);
            v60 = v16;
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__p.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v63.__r_.__value_.__l.__data_);
            }
            if (std::__hash_table<std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<NLExtendedString>>>>::find<std::string>(a1, (unsigned __int8 *)v77))
            {
              v63.__r_.__value_.__r.__words[0] = (std::string::size_type)v96;
              std::string v27 = std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v57, (unsigned __int8 *)v96, (uint64_t)&std::piecewise_construct, (long long **)&v63);
              std::regex_iterator<std::__wrap_iter<const char *>, char> v29 = (long long *)*((void *)v27 + 5);
              uint64_t v28 = (long long *)*((void *)v27 + 6);
              uint64_t v61 = v28;
              while (v29 != v28)
              {
                if (*((char *)v29 + 23) < 0)
                {
                  std::string::__init_copy_ctor_external(&v76, *(const std::string::value_type **)v29, *((void *)v29 + 1));
                }
                else
                {
                  long long v30 = *v29;
                  v76.__r_.__value_.__r.__words[2] = *((void *)v29 + 2);
                  *(_OWORD *)&v76.__r_.__value_.__l.__data_ = v30;
                }
                memset(v75, 0, sizeof(v75));
                splitWithChar((uint64_t)&v76, 9u, (uint64_t)v75);
                uint64_t v31 = v75[0];
                if (*(char *)(v75[0] + 23) < 0)
                {
                  std::string::__init_copy_ctor_external(&v74, *(const std::string::value_type **)v75[0], *(void *)(v75[0] + 8));
                  uint64_t v31 = v75[0];
                }
                else
                {
                  long long v32 = *(_OWORD *)v75[0];
                  v74.__r_.__value_.__r.__words[2] = *(void *)(v75[0] + 16);
                  *(_OWORD *)&v74.__r_.__value_.__l.__data_ = v32;
                }
                if (*(char *)(v31 + 47) < 0)
                {
                  std::string::__init_copy_ctor_external(&v73, *(const std::string::value_type **)(v31 + 24), *(void *)(v31 + 32));
                  uint64_t v31 = v75[0];
                }
                else
                {
                  std::string v73 = *(std::string *)(v31 + 24);
                }
                if (*(char *)(v31 + 71) < 0)
                {
                  std::string::__init_copy_ctor_external(&v72, *(const std::string::value_type **)(v31 + 48), *(void *)(v31 + 56));
                  uint64_t v31 = v75[0];
                }
                else
                {
                  std::string v72 = *(std::string *)(v31 + 48);
                }
                if (*(char *)(v31 + 95) < 0)
                {
                  std::string::__init_copy_ctor_external(&v71, *(const std::string::value_type **)(v31 + 72), *(void *)(v31 + 80));
                  uint64_t v31 = v75[0];
                }
                else
                {
                  std::string v71 = *(std::string *)(v31 + 72);
                }
                if (*(char *)(v31 + 119) < 0) {
                  std::string::__init_copy_ctor_external(&v70, *(const std::string::value_type **)(v31 + 96), *(void *)(v31 + 104));
                }
                else {
                  std::string v70 = *(std::string *)(v31 + 96);
                }
                if ((v91.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                  size_t v33 = HIBYTE(v91.__r_.__value_.__r.__words[2]);
                }
                else {
                  size_t v33 = v91.__r_.__value_.__l.__size_;
                }
                std::string::basic_string[abi:ne180100]((uint64_t)&v63, v33 + 1);
                if ((v63.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                  BOOL v34 = &v63;
                }
                else {
                  BOOL v34 = (std::string *)v63.__r_.__value_.__r.__words[0];
                }
                if (v33)
                {
                  if ((v91.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                    char v35 = &v91;
                  }
                  else {
                    char v35 = (std::string *)v91.__r_.__value_.__r.__words[0];
                  }
                  memmove(v34, v35, v33);
                }
                *(_WORD *)((char *)&v34->__r_.__value_.__l.__data_ + v33) = 32;
                if ((v72.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                  uint64_t v36 = &v72;
                }
                else {
                  uint64_t v36 = (std::string *)v72.__r_.__value_.__r.__words[0];
                }
                if ((v72.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                  std::string::size_type v37 = HIBYTE(v72.__r_.__value_.__r.__words[2]);
                }
                else {
                  std::string::size_type v37 = v72.__r_.__value_.__l.__size_;
                }
                unsigned __int8 v38 = std::string::append(&v63, (const std::string::value_type *)v36, v37);
                long long v39 = *(_OWORD *)&v38->__r_.__value_.__l.__data_;
                __p.__r_.__value_.__r.__words[2] = v38->__r_.__value_.__r.__words[2];
                *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v39;
                v38->__r_.__value_.__l.__size_ = 0;
                v38->__r_.__value_.__r.__words[2] = 0;
                v38->__r_.__value_.__r.__words[0] = 0;
                trim((unint64_t)&__p, v68);
                if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(__p.__r_.__value_.__l.__data_);
                }
                if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v63.__r_.__value_.__l.__data_);
                }
                if (std::__hash_table<std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<NLExtendedString>>>>::find<std::string>(a1 + 5, (unsigned __int8 *)v68))
                {
                  if ((v84.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                    size_t v40 = HIBYTE(v84.__r_.__value_.__r.__words[2]);
                  }
                  else {
                    size_t v40 = v84.__r_.__value_.__l.__size_;
                  }
                  std::string::basic_string[abi:ne180100]((uint64_t)&v63, v40 + 1);
                  if ((v63.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                    char v41 = &v63;
                  }
                  else {
                    char v41 = (std::string *)v63.__r_.__value_.__r.__words[0];
                  }
                  if (v40)
                  {
                    if ((v84.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      uint64_t v42 = &v84;
                    }
                    else {
                      uint64_t v42 = (std::string *)v84.__r_.__value_.__r.__words[0];
                    }
                    memmove(v41, v42, v40);
                  }
                  *(_WORD *)((char *)&v41->__r_.__value_.__l.__data_ + v4nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = 32;
                  if ((v72.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                    uint64_t v43 = &v72;
                  }
                  else {
                    uint64_t v43 = (std::string *)v72.__r_.__value_.__r.__words[0];
                  }
                  if ((v72.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                    std::string::size_type v44 = HIBYTE(v72.__r_.__value_.__r.__words[2]);
                  }
                  else {
                    std::string::size_type v44 = v72.__r_.__value_.__l.__size_;
                  }
                  unsigned int v45 = std::string::append(&v63, (const std::string::value_type *)v43, v44);
                  long long v46 = *(_OWORD *)&v45->__r_.__value_.__l.__data_;
                  __p.__r_.__value_.__r.__words[2] = v45->__r_.__value_.__r.__words[2];
                  *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v46;
                  v45->__r_.__value_.__l.__size_ = 0;
                  v45->__r_.__value_.__r.__words[2] = 0;
                  v45->__r_.__value_.__r.__words[0] = 0;
                  trim((unint64_t)&__p, v66);
                  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(__p.__r_.__value_.__l.__data_);
                  }
                  if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(v63.__r_.__value_.__l.__data_);
                  }
                  if (std::__hash_table<std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<NLExtendedString>>>>::find<std::string>(a1 + 10, (unsigned __int8 *)v66))
                  {
                    std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((const void **)&v92.__r_.__value_.__l.__data_, (const void **)&v85.__r_.__value_.__l.__data_, (uint64_t)&__p);
                    if ((v73.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      v47 = &v73;
                    }
                    else {
                      v47 = (std::string *)v73.__r_.__value_.__r.__words[0];
                    }
                    if ((v73.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      std::string::size_type v48 = HIBYTE(v73.__r_.__value_.__r.__words[2]);
                    }
                    else {
                      std::string::size_type v48 = v73.__r_.__value_.__l.__size_;
                    }
                    unint64_t v49 = std::string::append(&__p, (const std::string::value_type *)v47, v48);
                    long long v50 = *(_OWORD *)&v49->__r_.__value_.__l.__data_;
                    std::string::size_type v65 = v49->__r_.__value_.__r.__words[2];
                    long long __s = v50;
                    v49->__r_.__value_.__l.__size_ = 0;
                    v49->__r_.__value_.__r.__words[2] = 0;
                    v49->__r_.__value_.__r.__words[0] = 0;
                    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(__p.__r_.__value_.__l.__data_);
                    }
                    std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((std::regex_traits<char> *)&v63, "A\\+a([pt])", 0);
                  }
                  if (v67 < 0) {
                    operator delete(v66[0]);
                  }
                }
                if (v69 < 0) {
                  operator delete(v68[0]);
                }
                if (SHIBYTE(v70.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v70.__r_.__value_.__l.__data_);
                }
                if (SHIBYTE(v71.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v71.__r_.__value_.__l.__data_);
                }
                if (SHIBYTE(v72.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v72.__r_.__value_.__l.__data_);
                }
                if (SHIBYTE(v73.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v73.__r_.__value_.__l.__data_);
                }
                if (SHIBYTE(v74.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v74.__r_.__value_.__l.__data_);
                }
                __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v75;
                std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
                if (SHIBYTE(v76.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v76.__r_.__value_.__l.__data_);
                }
                std::regex_iterator<std::__wrap_iter<const char *>, char> v29 = (long long *)((char *)v29 + 24);
                uint64_t v28 = v61;
              }
            }
            if (v78 < 0) {
              operator delete(v77[0]);
            }
            if (SHIBYTE(v79.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v79.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v80.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v81.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v81.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v82.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v82.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v83.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v83.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v84.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v84.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v85.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v85.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v86.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v86.__r_.__value_.__l.__data_);
            }
            __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v87;
            std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
            if (SHIBYTE(v88.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v88.__r_.__value_.__l.__data_);
            }
            int v16 = (long long *)((char *)v60 + 24);
            long long v15 = v59;
          }
          if (SHIBYTE(v89.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v89.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v90.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v90.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v91.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v92.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v92.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v93.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v93.__r_.__value_.__l.__data_);
          }
          __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v94;
          std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
          if (SHIBYTE(v95.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v95.__r_.__value_.__l.__data_);
          }
          int v10 = (long long *)((char *)v56 + 24);
          std::string v9 = v54;
        }
      }
      if (v97 < 0) {
        operator delete(v96[0]);
      }
      if (v99 < 0) {
        operator delete(v98[0]);
      }
      if (SHIBYTE(v100.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v100.__r_.__value_.__l.__data_);
      }
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v101;
      std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
      if (SHIBYTE(v104.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v104.__r_.__value_.__l.__data_);
      }
      uint64_t v3 = (long long *)((char *)v53 + 24);
    }
    while ((long long *)((char *)v53 + 24) != v51);
  }
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v105;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
}

void sub_1A43C9554(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,uint64_t a41,uint64_t a42,void *a43,uint64_t a44,uint64_t a45,uint64_t a46,void *a47,uint64_t a48,uint64_t a49,uint64_t a50,void *a51)
{
}

void sub_1A43C9BAC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,int a53,__int16 a54,char a55,char a56)
{
  if (a56 < 0) {
    JUMPOUT(0x1A43C98F0);
  }
  JUMPOUT(0x1A43C98F4);
}

void sub_1A43C9BC0()
{
}

void sub_1A43C9BC8()
{
}

void sub_1A43C9BDC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,int a53,__int16 a54,char a55,char a56)
{
  if (a56 < 0) {
    JUMPOUT(0x1A43C9960);
  }
  JUMPOUT(0x1A43C9964);
}

void sub_1A43C9BF0()
{
  if (SLOBYTE(STACK[0x477]) < 0) {
    JUMPOUT(0x1A43C9994);
  }
  JUMPOUT(0x1A43C9998);
}

void sub_1A43C9C24()
{
  if (SLOBYTE(STACK[0x477]) < 0) {
    JUMPOUT(0x1A43C99A4);
  }
  JUMPOUT(0x1A43C99A8);
}

void sub_1A43C9C34(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *__p,uint64_t a52,int a53,__int16 a54,char a55,char a56)
{
  if (a56 < 0) {
    operator delete(__p);
  }
  if (SLOBYTE(STACK[0x477]) < 0) {
    JUMPOUT(0x1A43C99A4);
  }
  JUMPOUT(0x1A43C99A8);
}

void sub_1A43C9C58()
{
}

void NLResult::~NLResult(void **this)
{
  if (*((char *)this + 151) < 0) {
    operator delete(this[16]);
  }
  if (*((char *)this + 119) < 0) {
    operator delete(this[12]);
  }
  if (*((char *)this + 95) < 0) {
    operator delete(this[9]);
  }
  if (*((char *)this + 71) < 0) {
    operator delete(this[6]);
  }
  if (*((char *)this + 47) < 0) {
    operator delete(this[3]);
  }
  if (*((char *)this + 23) < 0) {
    operator delete(*this);
  }
}

void NLQamus::segmentword(std::string *__str@<X1>, std::string::size_type size@<X8>)
{
  uint64_t v3 = (std::vector<std::string> *)size;
  int64_t v4 = 0;
  v43[2] = *MEMORY[0x1E4F143B8];
  *(void *)(size + 16) = 0;
  long long v5 = (std::allocator<std::string> *)(size + 16);
  LODWORD(size) = HIBYTE(__str->__r_.__value_.__r.__words[2]);
  if ((size & 0x80u) != 0) {
    size_t size = __str->__r_.__value_.__l.__size_;
  }
  v3->__begin_ = 0;
  v3->__end_ = 0;
  int64_t v34 = (int)size;
  int v35 = size;
  do
  {
    std::string::basic_string(&v41, __str, 0, v4, (std::allocator<char> *)&__v);
    if (v34 > v4)
    {
      std::string::size_type v6 = 0;
      uint64_t v7 = v35;
      do
      {
        std::string::basic_string(&v40, __str, v4, v7, (std::allocator<char> *)&__v);
        std::string::basic_string(&v39, __str, v4 + v7, v6, (std::allocator<char> *)&__v);
        if ((v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          size_t v8 = HIBYTE(v41.__r_.__value_.__r.__words[2]);
        }
        else {
          size_t v8 = v41.__r_.__value_.__l.__size_;
        }
        std::string::basic_string[abi:ne180100]((uint64_t)&v36, v8 + 1);
        if ((v36.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string v9 = &v36;
        }
        else {
          std::string v9 = (std::string *)v36.__r_.__value_.__r.__words[0];
        }
        if (v8)
        {
          if ((v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            int v10 = &v41;
          }
          else {
            int v10 = (std::string *)v41.__r_.__value_.__r.__words[0];
          }
          memmove(v9, v10, v8);
        }
        *(_WORD *)((char *)&v9->__r_.__value_.__l.__data_ + v8) = 9;
        if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          long long v11 = &v40;
        }
        else {
          long long v11 = (std::string *)v40.__r_.__value_.__r.__words[0];
        }
        if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v12 = HIBYTE(v40.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v12 = v40.__r_.__value_.__l.__size_;
        }
        long long v13 = std::string::append(&v36, (const std::string::value_type *)v11, v12);
        long long v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
        v37.__r_.__value_.__r.__words[2] = v13->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v37.__r_.__value_.__l.__data_ = v14;
        v13->__r_.__value_.__l.__size_ = 0;
        v13->__r_.__value_.__r.__words[2] = 0;
        v13->__r_.__value_.__r.__words[0] = 0;
        long long v15 = std::string::append(&v37, "\t");
        long long v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
        v38.__r_.__value_.__r.__words[2] = v15->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v38.__r_.__value_.__l.__data_ = v16;
        v15->__r_.__value_.__l.__size_ = 0;
        v15->__r_.__value_.__r.__words[2] = 0;
        v15->__r_.__value_.__r.__words[0] = 0;
        if ((v39.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          long long v17 = &v39;
        }
        else {
          long long v17 = (std::string *)v39.__r_.__value_.__r.__words[0];
        }
        if ((v39.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v18 = HIBYTE(v39.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v18 = v39.__r_.__value_.__l.__size_;
        }
        long long v19 = std::string::append(&v38, (const std::string::value_type *)v17, v18);
        std::string::size_type v20 = v19->__r_.__value_.__r.__words[0];
        v43[0] = v19->__r_.__value_.__l.__size_;
        *(void *)((char *)v43 + 7) = *(std::string::size_type *)((char *)&v19->__r_.__value_.__r.__words[1] + 7);
        char v21 = HIBYTE(v19->__r_.__value_.__r.__words[2]);
        v19->__r_.__value_.__l.__size_ = 0;
        v19->__r_.__value_.__r.__words[2] = 0;
        v19->__r_.__value_.__r.__words[0] = 0;
        std::vector<std::string>::pointer end = v3->__end_;
        value = v3->__end_cap_.__value_;
        if (end >= value)
        {
          unint64_t v26 = 0xAAAAAAAAAAAAAAABLL * (((char *)end - (char *)v3->__begin_) >> 3);
          unint64_t v27 = v26 + 1;
          if (v26 + 1 > 0xAAAAAAAAAAAAAAALL) {
            std::vector<NLExtendedString>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v28 = 0xAAAAAAAAAAAAAAABLL * (((char *)value - (char *)v3->__begin_) >> 3);
          if (2 * v28 > v27) {
            unint64_t v27 = 2 * v28;
          }
          if (v28 >= 0x555555555555555) {
            unint64_t v29 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v29 = v27;
          }
          __v.__end_cap_.__value_ = v5;
          if (v29) {
            long long v30 = (std::string *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)v5, v29);
          }
          else {
            long long v30 = 0;
          }
          uint64_t v31 = v30 + v26;
          __v.__first_ = v30;
          __v.__begin_ = v31;
          __v.__end_cap_.__value_ = &v30[v29];
          std::string::size_type v32 = v43[0];
          v31->__r_.__value_.__r.__words[0] = v20;
          v31->__r_.__value_.__l.__size_ = v32;
          *(std::string::size_type *)((char *)&v31->__r_.__value_.__r.__words[1] + 7) = *(void *)((char *)v43 + 7);
          *((unsigned char *)&v31->__r_.__value_.__s + 23) = v21;
          v43[0] = 0;
          *(void *)((char *)v43 + 7) = 0;
          __v.__end_ = v31 + 1;
          std::vector<std::string>::__swap_out_circular_buffer(v3, &__v);
          int v25 = v3->__end_;
          std::__split_buffer<std::string>::~__split_buffer(&__v);
        }
        else
        {
          std::string::size_type v24 = v43[0];
          end->__r_.__value_.__r.__words[0] = v20;
          end->__r_.__value_.__l.__size_ = v24;
          *(std::string::size_type *)((char *)&end->__r_.__value_.__r.__words[1] + 7) = *(void *)((char *)v43 + 7);
          *((unsigned char *)&end->__r_.__value_.__s + 23) = v21;
          int v25 = end + 1;
          v3->__end_ = end + 1;
        }
        v3->__end_ = v25;
        if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v38.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v37.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v36.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v39.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v40.__r_.__value_.__l.__data_);
        }
        if (v7 < 2) {
          break;
        }
        --v7;
      }
      while (v6++ < 6);
    }
    if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v41.__r_.__value_.__l.__data_);
    }
    ++v4;
    --v35;
  }
  while (v4 != 5);
}

void sub_1A43CA084(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,void *a43,uint64_t a44,int a45,__int16 a46,char a47,char a48)
{
}

void NLResult::NLResult(std::string *this, const NLResult *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *(_OWORD *)a2;
    this->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v4;
  }
  if (*((char *)a2 + 47) < 0)
  {
    std::string::__init_copy_ctor_external(this + 1, *((const std::string::value_type **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v5 = *(_OWORD *)((char *)a2 + 24);
    this[1].__r_.__value_.__r.__words[2] = *((void *)a2 + 5);
    *(_OWORD *)&this[1].__r_.__value_.__l.__data_ = v5;
  }
  if (*((char *)a2 + 71) < 0)
  {
    std::string::__init_copy_ctor_external(this + 2, *((const std::string::value_type **)a2 + 6), *((void *)a2 + 7));
  }
  else
  {
    long long v6 = *((_OWORD *)a2 + 3);
    this[2].__r_.__value_.__r.__words[2] = *((void *)a2 + 8);
    *(_OWORD *)&this[2].__r_.__value_.__l.__data_ = v6;
  }
  if (*((char *)a2 + 95) < 0)
  {
    std::string::__init_copy_ctor_external(this + 3, *((const std::string::value_type **)a2 + 9), *((void *)a2 + 10));
  }
  else
  {
    long long v7 = *(_OWORD *)((char *)a2 + 72);
    this[3].__r_.__value_.__r.__words[2] = *((void *)a2 + 11);
    *(_OWORD *)&this[3].__r_.__value_.__l.__data_ = v7;
  }
  if (*((char *)a2 + 119) < 0)
  {
    std::string::__init_copy_ctor_external(this + 4, *((const std::string::value_type **)a2 + 12), *((void *)a2 + 13));
  }
  else
  {
    long long v8 = *((_OWORD *)a2 + 6);
    this[4].__r_.__value_.__r.__words[2] = *((void *)a2 + 14);
    *(_OWORD *)&this[4].__r_.__value_.__l.__data_ = v8;
  }
  LODWORD(this[5].__r_.__value_.__l.__data_) = *((_DWORD *)a2 + 30);
  std::string v9 = (std::string *)((char *)this + 128);
  if (*((char *)a2 + 151) < 0)
  {
    std::string::__init_copy_ctor_external(v9, *((const std::string::value_type **)a2 + 16), *((void *)a2 + 17));
  }
  else
  {
    long long v10 = *((_OWORD *)a2 + 8);
    this[6].__r_.__value_.__r.__words[0] = *((void *)a2 + 18);
    *(_OWORD *)&v9->__r_.__value_.__l.__data_ = v10;
  }
}

void sub_1A43CA2A8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 119) < 0) {
    operator delete(*v5);
  }
  if (*(char *)(v1 + 95) < 0) {
    operator delete(*v4);
  }
  if (*(char *)(v1 + 71) < 0) {
    operator delete(*v3);
  }
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL std::regex_iterator<std::__wrap_iter<char *>,char,std::regex_traits<char>>::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = a1 + 32;
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = *(void *)(v6 + 8);
  uint64_t v9 = a2 + 32;
  uint64_t v7 = *(void *)(a2 + 32);
  uint64_t v8 = *(void *)(v9 + 8);
  BOOL v10 = v8 == v7 && v5 == v4;
  if (v5 != v4 && v8 != v7) {
    return *(void *)a1 == *(void *)a2
  }
        && *(void *)(a1 + 8) == *(void *)(a2 + 8)
        && *(void *)(a1 + 16) == *(void *)(a2 + 16)
        && *(_DWORD *)(a1 + 24) == *(_DWORD *)(a2 + 24)
        && std::sub_match<std::__wrap_iter<char *>>::compare[abi:ne180100](v4, v7) == 0;
  return v10;
}

uint64_t std::sub_match<std::__wrap_iter<char *>>::compare[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 16))
  {
    std::string::__init_with_size[abi:ne180100]<char const*,char const*>(&__p, *(char **)a1, *(char **)(a1 + 8), *(void *)(a1 + 8) - *(void *)a1);
  }
  else
  {
    std::string __p = 0;
    size_t v19 = 0;
    uint64_t v20 = 0;
  }
  if (*(unsigned char *)(a2 + 16))
  {
    std::string::__init_with_size[abi:ne180100]<char const*,char const*>(&v15, *(char **)a2, *(char **)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
    unsigned int v3 = HIBYTE(v17);
    uint64_t v5 = v15;
    size_t v4 = v16;
  }
  else
  {
    size_t v4 = 0;
    uint64_t v5 = 0;
    unsigned int v3 = 0;
    long long v15 = 0;
    size_t v16 = 0;
    uint64_t v17 = 0;
  }
  char v6 = HIBYTE(v20);
  if (v20 >= 0) {
    size_t v7 = HIBYTE(v20);
  }
  else {
    size_t v7 = v19;
  }
  if (v20 >= 0) {
    p_p = &__p;
  }
  else {
    p_p = __p;
  }
  if ((v3 & 0x80u) == 0) {
    size_t v9 = v3;
  }
  else {
    size_t v9 = v4;
  }
  if ((v3 & 0x80u) == 0) {
    BOOL v10 = (void **)&v15;
  }
  else {
    BOOL v10 = v5;
  }
  if (v9 >= v7) {
    size_t v11 = v7;
  }
  else {
    size_t v11 = v9;
  }
  unsigned int v12 = memcmp(p_p, v10, v11);
  if ((v3 & 0x80) != 0)
  {
    operator delete(v5);
    if ((v20 & 0x8000000000000000) == 0) {
      goto LABEL_24;
    }
  }
  else if ((v6 & 0x80) == 0)
  {
    goto LABEL_24;
  }
  operator delete(__p);
LABEL_24:
  unsigned int v13 = v9 < v7;
  if (v7 < v9) {
    unsigned int v13 = -1;
  }
  if (v12) {
    return v12;
  }
  else {
    return v13;
  }
}

void sub_1A43CA4D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::__move_assign(uint64_t a1, uint64_t *a2)
{
  std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::clear(a1);
  uint64_t v4 = *a2;
  *a2 = 0;
  uint64_t v5 = *(void **)a1;
  *(void *)a1 = v4;
  if (v5) {
    operator delete(v5);
  }
  uint64_t v8 = a2[2];
  size_t v7 = a2 + 2;
  uint64_t v6 = v8;
  uint64_t v9 = *(v7 - 1);
  *(void *)(a1 + 16) = v8;
  *(void *)(a1 + 8) = v9;
  *(v7 - 1) = 0;
  uint64_t v10 = v7[1];
  *(void *)(a1 + 24) = v10;
  *(_DWORD *)(a1 + 32) = *((_DWORD *)v7 + 4);
  if (v10)
  {
    unint64_t v11 = *(void *)(v6 + 8);
    unint64_t v12 = *(void *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12) {
        v11 %= v12;
      }
    }
    else
    {
      v11 &= v12 - 1;
    }
    *(void *)(*(void *)a1 + 8 * v11) = a1 + 16;
    *size_t v7 = 0;
    v7[1] = 0;
  }
}

void std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::clear(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::__deallocate_node(a1, *(void **)(a1 + 16));
    *(void *)(a1 + 16) = 0;
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      for (uint64_t i = 0; i != v2; ++i)
        *(void *)(*(void *)a1 + 8 * i) = 0;
    }
    *(void *)(a1 + 24) = 0;
  }
}

void std::vector<NLResult>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 152;
        std::allocator<NLResult>::destroy[abi:ne180100]((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::allocator<NLResult>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 151) < 0) {
    operator delete(*(void **)(a2 + 128));
  }
  if (*(char *)(a2 + 119) < 0) {
    operator delete(*(void **)(a2 + 96));
  }
  if (*(char *)(a2 + 95) < 0) {
    operator delete(*(void **)(a2 + 72));
  }
  if (*(char *)(a2 + 71) < 0) {
    operator delete(*(void **)(a2 + 48));
  }
  if (*(char *)(a2 + 47) < 0) {
    operator delete(*(void **)(a2 + 24));
  }
  if (*(char *)(a2 + 23) < 0)
  {
    unsigned int v3 = *(void **)a2;
    operator delete(v3);
  }
}

uint64_t std::vector<NLResult>::__push_back_slow_path<NLResult>(uint64_t *a1, long long *a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0x86BCA1AF286BCA1BLL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x1AF286BCA1AF286) {
    std::vector<NLExtendedString>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x86BCA1AF286BCA1BLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0xD79435E50D7943) {
    unint64_t v9 = 0x1AF286BCA1AF286;
  }
  else {
    unint64_t v9 = v5;
  }
  v20[4] = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NLResult>>(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  unint64_t v11 = &v10[152 * v4];
  v20[0] = v10;
  v20[1] = v11;
  v20[3] = &v10[152 * v9];
  long long v12 = *a2;
  *((void *)v11 + 2) = *((void *)a2 + 2);
  *(_OWORD *)unint64_t v11 = v12;
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *(void *)a2 = 0;
  long long v13 = *(long long *)((char *)a2 + 24);
  *((void *)v11 + 5) = *((void *)a2 + 5);
  *(_OWORD *)(v11 + 24) = v13;
  *((void *)a2 + 4) = 0;
  *((void *)a2 + 5) = 0;
  *((void *)a2 + 3) = 0;
  long long v14 = a2[3];
  *((void *)v11 + 8) = *((void *)a2 + 8);
  *((_OWORD *)v11 + 3) = v14;
  *((void *)a2 + 6) = 0;
  *((void *)a2 + 7) = 0;
  *((void *)a2 + 8) = 0;
  long long v15 = *(long long *)((char *)a2 + 72);
  *((void *)v11 + 11) = *((void *)a2 + 11);
  *(_OWORD *)(v11 + 72) = v15;
  *((void *)a2 + 9) = 0;
  *((void *)a2 + 1nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = 0;
  *((void *)a2 + 11) = 0;
  long long v16 = a2[6];
  *((void *)v11 + 14) = *((void *)a2 + 14);
  *((_OWORD *)v11 + 6) = v16;
  *((void *)a2 + 12) = 0;
  *((void *)a2 + 13) = 0;
  *((void *)a2 + 14) = 0;
  *((_DWORD *)v11 + 3nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = *((_DWORD *)a2 + 30);
  long long v17 = a2[8];
  *((void *)v11 + 18) = *((void *)a2 + 18);
  *((_OWORD *)v11 + 8) = v17;
  *((void *)a2 + 17) = 0;
  *((void *)a2 + 18) = 0;
  *((void *)a2 + 16) = 0;
  v20[2] = v11 + 152;
  std::vector<NLResult>::__swap_out_circular_buffer(a1, v20);
  uint64_t v18 = a1[1];
  std::__split_buffer<NLResult>::~__split_buffer(v20);
  return v18;
}

void sub_1A43CA8AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<NLResult>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<NLResult>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<NLResult>,std::reverse_iterator<NLResult*>,std::reverse_iterator<NLResult*>,std::reverse_iterator<NLResult*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<NLResult>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x1AF286BCA1AF287) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(152 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<NLResult>,std::reverse_iterator<NLResult*>,std::reverse_iterator<NLResult*>,std::reverse_iterator<NLResult*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  *(void *)&long long v22 = a6;
  *((void *)&v22 + 1) = a7;
  long long v21 = v22;
  v19[0] = a1;
  v19[1] = &v21;
  v19[2] = &v22;
  if (a3 == a5)
  {
    uint64_t v17 = a6;
  }
  else
  {
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = a7 + v7;
      uint64_t v9 = a3 + v7;
      long long v10 = *(_OWORD *)(a3 + v7 - 152);
      *(void *)(v8 - 136) = *(void *)(a3 + v7 - 136);
      *(_OWORD *)(v8 - 152) = v10;
      *(void *)(v9 - 144) = 0;
      *(void *)(v9 - 136) = 0;
      *(void *)(v9 - 152) = 0;
      long long v11 = *(_OWORD *)(a3 + v7 - 128);
      *(void *)(v8 - 112) = *(void *)(a3 + v7 - 112);
      *(_OWORD *)(v8 - 128) = v11;
      *(void *)(v9 - 12nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = 0;
      *(void *)(v9 - 112) = 0;
      *(void *)(v9 - 128) = 0;
      long long v12 = *(_OWORD *)(a3 + v7 - 104);
      *(void *)(v8 - 88) = *(void *)(a3 + v7 - 88);
      *(_OWORD *)(v8 - 104) = v12;
      *(void *)(v9 - 96) = 0;
      *(void *)(v9 - 88) = 0;
      long long v13 = *(_OWORD *)(a3 + v7 - 80);
      uint64_t v14 = *(void *)(a3 + v7 - 64);
      *(void *)(v9 - 104) = 0;
      *(void *)(v8 - 64) = v14;
      *(_OWORD *)(v8 - 8nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = v13;
      *(void *)(v9 - 8nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = 0;
      *(void *)(v9 - 72) = 0;
      *(void *)(v9 - 64) = 0;
      long long v15 = *(_OWORD *)(a3 + v7 - 56);
      *(void *)(v8 - 4nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = *(void *)(a3 + v7 - 40);
      *(_OWORD *)(v8 - 56) = v15;
      *(void *)(v9 - 56) = 0;
      *(void *)(v9 - 48) = 0;
      *(void *)(v9 - 4nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = 0;
      *(_DWORD *)(v8 - 32) = *(_DWORD *)(a3 + v7 - 32);
      long long v16 = *(_OWORD *)(a3 + v7 - 24);
      *(void *)(v8 - 8) = *(void *)(a3 + v7 - 8);
      *(_OWORD *)(v8 - 24) = v16;
      *(void *)(v9 - 16) = 0;
      *(void *)(v9 - 8) = 0;
      *(void *)(v9 - 24) = 0;
      v7 -= 152;
    }
    while (a3 + v7 != a5);
    *((void *)&v22 + 1) = a7 + v7;
    uint64_t v17 = v22;
  }
  char v20 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<NLResult>,std::reverse_iterator<NLResult*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v19);
  return v17;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<NLResult>,std::reverse_iterator<NLResult*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<NLResult>,std::reverse_iterator<NLResult*>>::operator()[abi:ne180100]((uint64_t *)a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<NLResult>,std::reverse_iterator<NLResult*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v1 = *(void *)(a1[2] + 8);
  uint64_t v2 = *(void *)(a1[1] + 8);
  if (v1 != v2)
  {
    uint64_t v3 = *a1;
    do
    {
      std::allocator<NLResult>::destroy[abi:ne180100](v3, v1);
      v1 += 152;
    }
    while (v1 != v2);
  }
}

void **std::__split_buffer<NLResult>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void std::__split_buffer<NLResult>::clear[abi:ne180100](void *a1)
{
  uint64_t v2 = a1[1];
  for (uint64_t i = a1[2]; i != v2; uint64_t i = a1[2])
  {
    uint64_t v4 = a1[4];
    a1[2] = i - 152;
    std::allocator<NLResult>::destroy[abi:ne180100](v4, i - 152);
  }
}

void NLMessageConversationTurn::NLMessageConversationTurn(std::string *this, long long *a2, long long *a3, std::string::size_type a4)
{
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v7 = *a2;
    this->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v7;
  }
  uint64_t v8 = this + 1;
  if (*((char *)a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v8, *(const std::string::value_type **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v9 = *a3;
    this[1].__r_.__value_.__r.__words[2] = *((void *)a3 + 2);
    *(_OWORD *)&v8->__r_.__value_.__l.__data_ = v9;
  }
  this[2].__r_.__value_.__r.__words[0] = a4;
}

void sub_1A43CAC44(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NLMessageConversationTurn::getTimestamp(NLMessageConversationTurn *this)
{
  return *((void *)this + 6);
}

CFStringTokenizerRef NL::Transcriber::updateLocale(const void **this, CFLocaleRef locale)
{
  uint64_t v4 = *this;
  if (v4) {
    CFRelease(v4);
  }
  v6.CFIndex location = 0;
  v6.CFIndex length = 0;
  CFStringTokenizerRef result = CFStringTokenizerCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &stru_1EF7CF078, v6, 0x10000uLL, locale);
  *this = result;
  return result;
}

const void **NL::Transcriber::Transcriber(const void **this, const __CFLocale *a2)
{
  *this = 0;
  NL::Transcriber::updateLocale(this, a2);
  return this;
}

void NL::Transcriber::~Transcriber(const void **this)
{
  uint64_t v2 = *this;
  if (v2) {
    CFRelease(v2);
  }
  *this = 0;
}

CFMutableStringRef NL::Transcriber::copyTranscription(CFStringTokenizerRef *this, const __CFString *a2)
{
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  uint64_t v5 = *this;
  v9.CFIndex length = CFStringGetLength(a2);
  v9.CFIndex location = 0;
  CFStringTokenizerSetString(v5, a2, v9);
  while (CFStringTokenizerAdvanceToNextToken(*this))
  {
    CFStringRef v6 = (const __CFString *)CFStringTokenizerCopyCurrentTokenAttribute(*this, 0x10000uLL);
    if (v6)
    {
      CFStringRef v7 = v6;
      CFStringAppend(Mutable, v6);
      CFStringAppend(Mutable, @" ");
      CFRelease(v7);
    }
  }
  CFStringTrimWhitespace(Mutable);
  if (CFStringsAreEqual(Mutable, a2))
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

void NLTextSlotParserNamedEntityExtractor::NLTextSlotParserNamedEntityExtractor(NLTextSlotParserNamedEntityExtractor *this, const __CFLocale *a2)
{
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  *(void *)this = MEMORY[0x1A625A380](*MEMORY[0x1E4F1CF80]);
  CFMutableStringRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  uint64_t v5 = CFLocaleCreate(v3, @"root");
  CFArrayAppendValue(Mutable, (const void *)*MEMORY[0x1E4F5C908]);
  AssetResource = (const __CFURL **)NL::Resource::createAssetResource(v5, (const __CFLocale *)@"Tagging", @"reminder-gazetteer.dat", v6);
  if (AssetResource) {
    NL::Resource::exists(AssetResource);
  }
  *((void *)this + 1) = NLTaggerCreate();
  if (v5) {
    CFRelease(v5);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
}

void sub_1A43CB128(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, const void *a12, const void *a13, const void *a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,const void *a22,const void *a23,const void *a24)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  nlp::CFScopedPtr<__CFString const*>::reset(&a22, 0);
  nlp::CFScopedPtr<__CFLocale const*>::reset(&a23, 0);
  nlp::CFScopedPtr<__CFArray *>::reset(&a24, 0);
  _Unwind_Resume(a1);
}

void NLTextSlotParserNamedEntityExtractor::~NLTextSlotParserNamedEntityExtractor(NLTextSlotParserNamedEntityExtractor *this)
{
  uint64_t v2 = (const void *)*((void *)this + 1);
  if (v2) {
    CFRelease(v2);
  }
  if (*(void *)this) {
    CFRelease(*(CFTypeRef *)this);
  }
}

void NLTextSlotParserNamedEntityExtractor::getLocationAndPeopleNameRanges(NLTextSlotParserNamedEntityExtractor *this@<X0>, const __CFString *a2@<X1>, uint64_t a3@<X8>)
{
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)a3 = 0u;
  if (*((void *)this + 1))
  {
    NLTaggerSetString();
    CFStringGetLength(a2);
    NLTaggerSetLocaleForRange();
    uint64_t v27 = 0;
    unint64_t v28 = (long long **)&v27;
    uint64_t v29 = 0x4002000000;
    long long v30 = __Block_byref_object_copy__14;
    uint64_t v31 = __Block_byref_object_dispose__14;
    std::string::size_type v32 = 0;
    size_t v33 = 0;
    uint64_t v34 = 0;
    uint64_t v19 = 0;
    char v20 = (long long **)&v19;
    uint64_t v21 = 0x4002000000;
    long long v22 = __Block_byref_object_copy__14;
    uint64_t v23 = __Block_byref_object_dispose__14;
    std::string __p = 0;
    int v25 = 0;
    uint64_t v26 = 0;
    CFStringGetLength(a2);
    uint64_t v12 = MEMORY[0x1E4F143A8];
    uint64_t v13 = 0x40000000;
    uint64_t v14 = ___ZN36NLTextSlotParserNamedEntityExtractor30getLocationAndPeopleNameRangesEPK10__CFString_block_invoke;
    long long v15 = &unk_1E5B36430;
    uint64_t v17 = &v27;
    uint64_t v18 = this;
    long long v16 = &v19;
    NLTaggerEnumerateTokens();
    std::pair<std::vector<std::pair<NLTextSlotID,CFRange>>,std::vector<std::pair<NLTextSlotID,CFRange>>>::pair[abi:ne180100]<std::vector<std::pair<NLTextSlotID,CFRange>>&,std::vector<std::pair<NLTextSlotID,CFRange>>&,0>((uint64_t)&v8, v28 + 5, v20 + 5);
    uint64_t v6 = v9;
    *(_OWORD *)a3 = v8;
    *(void *)(a3 + 16) = v6;
    uint64_t v7 = v11;
    *(_OWORD *)(a3 + 24) = v10;
    *(void *)(a3 + 4nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = v7;
    _Block_object_dispose(&v19, 8);
    if (__p)
    {
      int v25 = __p;
      operator delete(__p);
    }
    _Block_object_dispose(&v27, 8);
    if (v32)
    {
      size_t v33 = v32;
      operator delete(v32);
    }
  }
}

void sub_1A43CB400(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29)
{
  _Block_object_dispose(&a23, 8);
  if (__p)
  {
    a29 = (uint64_t)__p;
    operator delete(__p);
  }
  _Block_object_dispose((const void *)(v30 - 128), 8);
  std::string::size_type v32 = *(void **)(v30 - 88);
  if (v32)
  {
    *(void *)(v30 - 8nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = v32;
    operator delete(v32);
  }
  std::pair<std::vector<std::pair<NLTextSlotID,CFRange>>,std::vector<std::pair<NLTextSlotID,CFRange>>>::~pair(v29);
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__14(void *a1, uint64_t a2)
{
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(void *)(a2 + 56);
  *(void *)(a2 + 4nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  return result;
}

void __Block_byref_object_dispose__14(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(void *)(a1 + 48) = v2;
    operator delete(v2);
  }
}

void ___ZN36NLTextSlotParserNamedEntityExtractor30getLocationAndPeopleNameRangesEPK10__CFString_block_invoke(uint64_t a1, _OWORD *a2)
{
  uint64_t v74 = *MEMORY[0x1E4F143B8];
  CFStringRef v4 = (const __CFString *)NLTaggerCopyTagForCurrentToken();
  if (v4)
  {
    CFStringRef v5 = v4;
    if (CFStringCompare(v4, (CFStringRef)*MEMORY[0x1E4F5C738], 0))
    {
      if (CFStringCompare(v5, (CFStringRef)*MEMORY[0x1E4F5C740], 0))
      {
        if (CFStringCompare(v5, @"<LEAVE_CAR>", 0))
        {
          if (CFStringCompare(v5, @"<GOTO_CAR>", 0))
          {
            if (CFStringCompare(v5, @"<LEAVE_WORK>", 0))
            {
              if (CFStringCompare(v5, @"<GOTO_WORK>", 0))
              {
                if (CFStringCompare(v5, @"<LEAVE_HOME>", 0))
                {
                  if (CFStringCompare(v5, @"<GOTO_HOME>", 0))
                  {
                    if (CFStringCompare(v5, @"<LEAVE_SCHOOL>", 0))
                    {
                      if (CFStringCompare(v5, @"<GOTO_SCHOOL>", 0))
                      {
                        if (CFEqual(v5, @"<SERVICE>")
                          || CFEqual(v5, @"<GROCERY>")
                          || CFEqual(v5, @"<RESTAURANT>"))
                        {
                          uint64_t v6 = (void **)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
                          *(_DWORD *)std::string v73 = 4;
                          *(_OWORD *)&v73[8] = *a2;
                          std::vector<std::pair<NLTextSlotID,CFRange>>::push_back[abi:ne180100](v6, (long long *)v73);
                        }
                      }
                      else
                      {
                        std::string v72 = (void **)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
                        *(_DWORD *)std::string v73 = 11;
                        *(_OWORD *)&v73[8] = *a2;
                        std::vector<std::pair<NLTextSlotID,CFRange>>::push_back[abi:ne180100](v72, (long long *)v73);
                      }
                    }
                    else
                    {
                      char v69 = (void **)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
                      *(_DWORD *)std::string v73 = 12;
                      *(_OWORD *)&v73[8] = *a2;
                      std::vector<std::pair<NLTextSlotID,CFRange>>::push_back[abi:ne180100](v69, (long long *)v73);
                    }
                  }
                  else
                  {
                    unint64_t v66 = (void **)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
                    *(_DWORD *)std::string v73 = 5;
                    *(_OWORD *)&v73[8] = *a2;
                    std::vector<std::pair<NLTextSlotID,CFRange>>::push_back[abi:ne180100](v66, (long long *)v73);
                  }
                }
                else
                {
                  uint64_t v57 = (void **)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
                  *(_DWORD *)std::string v73 = 6;
                  *(_OWORD *)&v73[8] = *a2;
                  std::vector<std::pair<NLTextSlotID,CFRange>>::push_back[abi:ne180100](v57, (long long *)v73);
                }
                goto LABEL_107;
              }
              uint64_t v7 = *(void **)(*(void *)(a1 + 40) + 8);
              *(_OWORD *)&v73[4] = *a2;
              unint64_t v8 = v7[6];
              unint64_t v48 = v7[7];
              if (v8 < v48)
              {
                int v10 = 9;
                goto LABEL_68;
              }
              uint64_t v12 = (void **)(v7 + 5);
              uint64_t v58 = v7[5];
              unint64_t v59 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v8 - v58) >> 3);
              unint64_t v60 = v59 + 1;
              if (v59 + 1 <= 0xAAAAAAAAAAAAAAALL)
              {
                unint64_t v61 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v48 - v58) >> 3);
                if (2 * v61 > v60) {
                  unint64_t v60 = 2 * v61;
                }
                if (v61 >= 0x555555555555555) {
                  unint64_t v62 = 0xAAAAAAAAAAAAAAALL;
                }
                else {
                  unint64_t v62 = v60;
                }
                if (v62) {
                  std::string v63 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)(v7 + 7), v62);
                }
                else {
                  std::string v63 = 0;
                }
                size_t v33 = &v63[24 * v59];
                uint64_t v34 = &v63[24 * v62];
                *(_DWORD *)size_t v33 = 9;
                *(_OWORD *)(v33 + 4) = *(_OWORD *)v73;
                *((_DWORD *)v33 + 5) = *(_DWORD *)&v73[16];
                int v35 = v33 + 24;
                std::string v70 = (char *)v7[5];
                std::string v36 = (char *)v7[6];
                if (v36 == v70) {
                  goto LABEL_104;
                }
                do
                {
                  long long v71 = *(_OWORD *)(v36 - 24);
                  *((void *)v33 - 1) = *((void *)v36 - 1);
                  *(_OWORD *)(v33 - 24) = v71;
                  v33 -= 24;
                  v36 -= 24;
                }
                while (v36 != v70);
LABEL_103:
                std::string v36 = (char *)*v12;
LABEL_104:
                v7[5] = v33;
                v7[6] = v35;
                v7[7] = v34;
                if (v36) {
                  operator delete(v36);
                }
                goto LABEL_106;
              }
              goto LABEL_110;
            }
            uint64_t v7 = *(void **)(*(void *)(a1 + 40) + 8);
            *(_OWORD *)&v73[4] = *a2;
            unint64_t v8 = v7[6];
            unint64_t v39 = v7[7];
            if (v8 >= v39)
            {
              uint64_t v12 = (void **)(v7 + 5);
              uint64_t v49 = v7[5];
              unint64_t v50 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v8 - v49) >> 3);
              unint64_t v51 = v50 + 1;
              if (v50 + 1 <= 0xAAAAAAAAAAAAAAALL)
              {
                unint64_t v52 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v39 - v49) >> 3);
                if (2 * v52 > v51) {
                  unint64_t v51 = 2 * v52;
                }
                if (v52 >= 0x555555555555555) {
                  unint64_t v53 = 0xAAAAAAAAAAAAAAALL;
                }
                else {
                  unint64_t v53 = v51;
                }
                if (v53) {
                  unsigned __int32 v54 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)(v7 + 7), v53);
                }
                else {
                  unsigned __int32 v54 = 0;
                }
                size_t v33 = &v54[24 * v50];
                uint64_t v34 = &v54[24 * v53];
                *(_DWORD *)size_t v33 = 10;
                *(_OWORD *)(v33 + 4) = *(_OWORD *)v73;
                *((_DWORD *)v33 + 5) = *(_DWORD *)&v73[16];
                int v35 = v33 + 24;
                char v67 = (char *)v7[5];
                std::string v36 = (char *)v7[6];
                if (v36 == v67) {
                  goto LABEL_104;
                }
                do
                {
                  long long v68 = *(_OWORD *)(v36 - 24);
                  *((void *)v33 - 1) = *((void *)v36 - 1);
                  *(_OWORD *)(v33 - 24) = v68;
                  v33 -= 24;
                  v36 -= 24;
                }
                while (v36 != v67);
                goto LABEL_103;
              }
              goto LABEL_110;
            }
            int v10 = 10;
          }
          else
          {
            uint64_t v7 = *(void **)(*(void *)(a1 + 40) + 8);
            *(_OWORD *)&v73[4] = *a2;
            unint64_t v8 = v7[6];
            unint64_t v26 = v7[7];
            if (v8 >= v26)
            {
              uint64_t v12 = (void **)(v7 + 5);
              uint64_t v40 = v7[5];
              unint64_t v41 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v8 - v40) >> 3);
              unint64_t v42 = v41 + 1;
              if (v41 + 1 <= 0xAAAAAAAAAAAAAAALL)
              {
                unint64_t v43 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v26 - v40) >> 3);
                if (2 * v43 > v42) {
                  unint64_t v42 = 2 * v43;
                }
                if (v43 >= 0x555555555555555) {
                  unint64_t v44 = 0xAAAAAAAAAAAAAAALL;
                }
                else {
                  unint64_t v44 = v42;
                }
                if (v44) {
                  unsigned int v45 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)(v7 + 7), v44);
                }
                else {
                  unsigned int v45 = 0;
                }
                size_t v33 = &v45[24 * v41];
                uint64_t v34 = &v45[24 * v44];
                *(_DWORD *)size_t v33 = 7;
                *(_OWORD *)(v33 + 4) = *(_OWORD *)v73;
                *((_DWORD *)v33 + 5) = *(_DWORD *)&v73[16];
                int v35 = v33 + 24;
                v64 = (char *)v7[5];
                std::string v36 = (char *)v7[6];
                if (v36 == v64) {
                  goto LABEL_104;
                }
                do
                {
                  long long v65 = *(_OWORD *)(v36 - 24);
                  *((void *)v33 - 1) = *((void *)v36 - 1);
                  *(_OWORD *)(v33 - 24) = v65;
                  v33 -= 24;
                  v36 -= 24;
                }
                while (v36 != v64);
                goto LABEL_103;
              }
              goto LABEL_110;
            }
            int v10 = 7;
          }
        }
        else
        {
          uint64_t v7 = *(void **)(*(void *)(a1 + 40) + 8);
          *(_OWORD *)&v73[4] = *a2;
          unint64_t v8 = v7[6];
          unint64_t v19 = v7[7];
          if (v8 >= v19)
          {
            uint64_t v12 = (void **)(v7 + 5);
            uint64_t v27 = v7[5];
            unint64_t v28 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v8 - v27) >> 3);
            unint64_t v29 = v28 + 1;
            if (v28 + 1 <= 0xAAAAAAAAAAAAAAALL)
            {
              unint64_t v30 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v19 - v27) >> 3);
              if (2 * v30 > v29) {
                unint64_t v29 = 2 * v30;
              }
              if (v30 >= 0x555555555555555) {
                unint64_t v31 = 0xAAAAAAAAAAAAAAALL;
              }
              else {
                unint64_t v31 = v29;
              }
              if (v31) {
                std::string::size_type v32 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)(v7 + 7), v31);
              }
              else {
                std::string::size_type v32 = 0;
              }
              size_t v33 = &v32[24 * v28];
              uint64_t v34 = &v32[24 * v31];
              *(_DWORD *)size_t v33 = 8;
              *(_OWORD *)(v33 + 4) = *(_OWORD *)v73;
              *((_DWORD *)v33 + 5) = *(_DWORD *)&v73[16];
              int v35 = v33 + 24;
              BOOL v55 = (char *)v7[5];
              std::string v36 = (char *)v7[6];
              if (v36 == v55) {
                goto LABEL_104;
              }
              do
              {
                long long v56 = *(_OWORD *)(v36 - 24);
                *((void *)v33 - 1) = *((void *)v36 - 1);
                *(_OWORD *)(v33 - 24) = v56;
                v33 -= 24;
                v36 -= 24;
              }
              while (v36 != v55);
              goto LABEL_103;
            }
            goto LABEL_110;
          }
          int v10 = 8;
        }
      }
      else
      {
        uint64_t v7 = *(void **)(*(void *)(a1 + 40) + 8);
        *(_OWORD *)&v73[4] = *a2;
        unint64_t v8 = v7[6];
        unint64_t v11 = v7[7];
        if (v8 >= v11)
        {
          uint64_t v12 = (void **)(v7 + 5);
          uint64_t v20 = v7[5];
          unint64_t v21 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v8 - v20) >> 3);
          unint64_t v22 = v21 + 1;
          if (v21 + 1 <= 0xAAAAAAAAAAAAAAALL)
          {
            unint64_t v23 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - v20) >> 3);
            if (2 * v23 > v22) {
              unint64_t v22 = 2 * v23;
            }
            if (v23 >= 0x555555555555555) {
              unint64_t v24 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v24 = v22;
            }
            if (v24) {
              int v25 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)(v7 + 7), v24);
            }
            else {
              int v25 = 0;
            }
            size_t v33 = &v25[24 * v21];
            uint64_t v34 = &v25[24 * v24];
            *(_DWORD *)size_t v33 = 4;
            *(_OWORD *)(v33 + 4) = *(_OWORD *)v73;
            *((_DWORD *)v33 + 5) = *(_DWORD *)&v73[16];
            int v35 = v33 + 24;
            long long v46 = (char *)v7[5];
            std::string v36 = (char *)v7[6];
            if (v36 == v46) {
              goto LABEL_104;
            }
            do
            {
              long long v47 = *(_OWORD *)(v36 - 24);
              *((void *)v33 - 1) = *((void *)v36 - 1);
              *(_OWORD *)(v33 - 24) = v47;
              v33 -= 24;
              v36 -= 24;
            }
            while (v36 != v46);
            goto LABEL_103;
          }
          goto LABEL_110;
        }
        int v10 = 4;
      }
    }
    else
    {
      uint64_t v7 = *(void **)(*(void *)(a1 + 32) + 8);
      *(_OWORD *)&v73[4] = *a2;
      unint64_t v8 = v7[6];
      unint64_t v9 = v7[7];
      if (v8 >= v9)
      {
        uint64_t v12 = (void **)(v7 + 5);
        uint64_t v13 = v7[5];
        unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v8 - v13) >> 3);
        unint64_t v15 = v14 + 1;
        if (v14 + 1 <= 0xAAAAAAAAAAAAAAALL)
        {
          unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v9 - v13) >> 3);
          if (2 * v16 > v15) {
            unint64_t v15 = 2 * v16;
          }
          if (v16 >= 0x555555555555555) {
            unint64_t v17 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v17 = v15;
          }
          if (v17) {
            uint64_t v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)(v7 + 7), v17);
          }
          else {
            uint64_t v18 = 0;
          }
          size_t v33 = &v18[24 * v14];
          uint64_t v34 = &v18[24 * v17];
          *(_DWORD *)size_t v33 = 14;
          *(_OWORD *)(v33 + 4) = *(_OWORD *)v73;
          *((_DWORD *)v33 + 5) = *(_DWORD *)&v73[16];
          int v35 = v33 + 24;
          std::string v37 = (char *)v7[5];
          std::string v36 = (char *)v7[6];
          if (v36 == v37) {
            goto LABEL_104;
          }
          do
          {
            long long v38 = *(_OWORD *)(v36 - 24);
            *((void *)v33 - 1) = *((void *)v36 - 1);
            *(_OWORD *)(v33 - 24) = v38;
            v33 -= 24;
            v36 -= 24;
          }
          while (v36 != v37);
          goto LABEL_103;
        }
LABEL_110:
        std::vector<NLExtendedString>::__throw_length_error[abi:ne180100]();
      }
      int v10 = 14;
    }
LABEL_68:
    *(_DWORD *)unint64_t v8 = v10;
    *(_OWORD *)(v8 + 4) = *(_OWORD *)v73;
    *(_DWORD *)(v8 + 2nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = *(_DWORD *)&v73[16];
    int v35 = (char *)(v8 + 24);
LABEL_106:
    v7[6] = v35;
LABEL_107:
    CFRelease(v5);
  }
}

void std::vector<std::pair<NLTextSlotID,CFRange>>::push_back[abi:ne180100](void **a1, long long *a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  CFStringRef v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= (unint64_t)v6)
  {
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - (void)*a1) >> 3);
    unint64_t v11 = v10 + 1;
    if (v10 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<NLExtendedString>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((v5 - (unsigned char *)*a1) >> 3);
    if (2 * v12 > v11) {
      unint64_t v11 = 2 * v12;
    }
    if (v12 >= 0x555555555555555) {
      unint64_t v13 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v13 = v11;
    }
    if (v13) {
      unint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(v4, v13);
    }
    else {
      unint64_t v14 = 0;
    }
    unint64_t v15 = &v14[24 * v10];
    unint64_t v16 = &v14[24 * v13];
    long long v17 = *a2;
    *((void *)v15 + 2) = *((void *)a2 + 2);
    *(_OWORD *)unint64_t v15 = v17;
    unint64_t v9 = v15 + 24;
    unint64_t v19 = (char *)*a1;
    uint64_t v18 = (char *)a1[1];
    if (v18 != *a1)
    {
      do
      {
        long long v20 = *(_OWORD *)(v18 - 24);
        *((void *)v15 - 1) = *((void *)v18 - 1);
        *(_OWORD *)(v15 - 24) = v20;
        v15 -= 24;
        v18 -= 24;
      }
      while (v18 != v19);
      uint64_t v18 = (char *)*a1;
    }
    *a1 = v15;
    a1[1] = v9;
    a1[2] = v16;
    if (v18) {
      operator delete(v18);
    }
  }
  else
  {
    long long v8 = *a2;
    *(void *)(v7 + 16) = *((void *)a2 + 2);
    *(_OWORD *)unint64_t v7 = v8;
    unint64_t v9 = (char *)(v7 + 24);
  }
  a1[1] = v9;
}

uint64_t std::pair<std::vector<std::pair<NLTextSlotID,CFRange>>,std::vector<std::pair<NLTextSlotID,CFRange>>>::pair[abi:ne180100]<std::vector<std::pair<NLTextSlotID,CFRange>>&,std::vector<std::pair<NLTextSlotID,CFRange>>&,0>(uint64_t a1, long long **a2, long long **a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  std::vector<std::pair<NLTextSlotID,CFRange>>::__init_with_size[abi:ne180100]<std::pair<NLTextSlotID,CFRange>*,std::pair<NLTextSlotID,CFRange>*>((char *)a1, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * (((char *)a2[1] - (char *)*a2) >> 3));
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 4nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = 0;
  std::vector<std::pair<NLTextSlotID,CFRange>>::__init_with_size[abi:ne180100]<std::pair<NLTextSlotID,CFRange>*,std::pair<NLTextSlotID,CFRange>*>((char *)(a1 + 24), *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * (((char *)a3[1] - (char *)*a3) >> 3));
  return a1;
}

void sub_1A43CBE98(_Unwind_Exception *exception_object)
{
  CFAllocatorRef v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<std::pair<NLTextSlotID,CFRange>>::__init_with_size[abi:ne180100]<std::pair<NLTextSlotID,CFRange>*,std::pair<NLTextSlotID,CFRange>*>(char *result, long long *a2, long long *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<std::string>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = *((void *)v6 + 1);
    while (a2 != a3)
    {
      long long v8 = *a2;
      *(void *)(v7 + 16) = *((void *)a2 + 2);
      *(_OWORD *)uint64_t v7 = v8;
      v7 += 24;
      a2 = (long long *)((char *)a2 + 24);
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_1A43CBF18(_Unwind_Exception *exception_object)
{
  CFAllocatorRef v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *operator<<(void *a1, uint64_t a2)
{
  uint64_t v4 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"Latin string: ", 14);
  int v5 = *(char *)(a2 + 23);
  if (v5 >= 0) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = *(void *)a2;
  }
  if (v5 >= 0) {
    uint64_t v7 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v7 = *(void *)(a2 + 8);
  }
  long long v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, v6, v7);
  unint64_t v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)", Transliterated string: ", 25);
  int v10 = *(char *)(a2 + 47);
  if (v10 >= 0) {
    uint64_t v11 = a2 + 24;
  }
  else {
    uint64_t v11 = *(void *)(a2 + 24);
  }
  if (v10 >= 0) {
    uint64_t v12 = *(unsigned __int8 *)(a2 + 47);
  }
  else {
    uint64_t v12 = *(void *)(a2 + 32);
  }
  unint64_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, v11, v12);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)", LM score: ", 12);
  unint64_t v14 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)", Seq2Seq score: ", 17);
  unint64_t v15 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)", Total Score: ", 15);
  NLTransliterationCandidate::getTotalScore((NLTransliterationCandidate *)a2);
  unint64_t v16 = (void *)std::ostream::operator<<();
  long long v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)", Type: ", 8);
  switch(*(_DWORD *)(a2 + 72))
  {
    case 0:
      uint64_t v18 = "Lexicon";
      goto LABEL_22;
    case 1:
      uint64_t v18 = "OrthographicVariant";
      goto LABEL_22;
    case 2:
      uint64_t v18 = "NasalizedVariant";
      goto LABEL_22;
    case 3:
      uint64_t v18 = "EnglishLexicon";
      goto LABEL_22;
    case 4:
      uint64_t v18 = "Unknown";
      goto LABEL_22;
    case 5:
      uint64_t v18 = "Exception list";
      goto LABEL_22;
    case 6:
      uint64_t v18 = "Seq2Seq";
      goto LABEL_22;
    case 7:
      uint64_t v18 = "Emoji";
LABEL_22:
      std::string::basic_string[abi:ne180100]<0>(v36, v18);
      break;
    default:
      std::to_string(&v38, *(_DWORD *)(a2 + 72));
      std::string::size_type v32 = std::string::insert(&v38, 0, "Unknown type: ");
      long long v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
      int64_t v37 = v32->__r_.__value_.__r.__words[2];
      *(_OWORD *)std::string v36 = v33;
      v32->__r_.__value_.__l.__size_ = 0;
      v32->__r_.__value_.__r.__words[2] = 0;
      v32->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v38.__r_.__value_.__l.__data_);
      }
      break;
  }
  if (v37 >= 0) {
    unint64_t v19 = v36;
  }
  else {
    unint64_t v19 = (void **)v36[0];
  }
  if (v37 >= 0) {
    uint64_t v20 = HIBYTE(v37);
  }
  else {
    uint64_t v20 = (uint64_t)v36[1];
  }
  unint64_t v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)v19, v20);
  unint64_t v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)", Is in vocabulary: ", 20);
  if (*(unsigned char *)(a2 + 77)) {
    unint64_t v23 = "true";
  }
  else {
    unint64_t v23 = "false";
  }
  std::string::basic_string[abi:ne180100]<0>(&v38, v23);
  if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unint64_t v24 = &v38;
  }
  else {
    unint64_t v24 = (std::string *)v38.__r_.__value_.__r.__words[0];
  }
  if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v38.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v38.__r_.__value_.__l.__size_;
  }
  unint64_t v26 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, (uint64_t)v24, size);
  uint64_t v27 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)", Is extension candidate: ", 26);
  if (*(unsigned char *)(a2 + 76)) {
    unint64_t v28 = "true";
  }
  else {
    unint64_t v28 = "false";
  }
  std::string::basic_string[abi:ne180100]<0>(__p, v28);
  if ((v35 & 0x80u) == 0) {
    unint64_t v29 = __p;
  }
  else {
    unint64_t v29 = (void **)__p[0];
  }
  if ((v35 & 0x80u) == 0) {
    uint64_t v30 = v35;
  }
  else {
    uint64_t v30 = (uint64_t)__p[1];
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v27, (uint64_t)v29, v30);
  if ((char)v35 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v38.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v37) < 0) {
    operator delete(v36[0]);
  }
  return a1;
}

void sub_1A43CC214(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NLTransliterationCandidate::getTransliteratedWord(NLTransliterationCandidate *this)
{
  return (uint64_t)this + 24;
}

double NLTransliterationCandidate::getLMScore(NLTransliterationCandidate *this)
{
  return *((double *)this + 7);
}

double NLTransliterationCandidate::getSequenceScore(NLTransliterationCandidate *this)
{
  return *((double *)this + 8);
}

uint64_t NLTransliterationCandidate::getType(NLTransliterationCandidate *this)
{
  return *((unsigned int *)this + 18);
}

uint64_t NLTransliterationCandidate::isInVocabulary(NLTransliterationCandidate *this)
{
  return *((unsigned __int8 *)this + 77);
}

uint64_t NLTransliterationCandidate::isExtensionCandidate(NLTransliterationCandidate *this)
{
  return *((unsigned __int8 *)this + 76);
}

void NLTransliterationCandidate::NLTransliterationCandidate(std::string *this, long long *a2, long long *a3, int a4, std::string::value_type a5, double a6, double a7)
{
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v13 = *a2;
    this->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v13;
  }
  unint64_t v14 = this + 1;
  if (*((char *)a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v14, *(const std::string::value_type **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v15 = *a3;
    this[1].__r_.__value_.__r.__words[2] = *((void *)a3 + 2);
    *(_OWORD *)&v14->__r_.__value_.__l.__data_ = v15;
  }
  this[2].__r_.__value_.__r.__words[0] = 0;
  *(double *)&this[2].__r_.__value_.__l.__size_ = a6;
  *(double *)&this[2].__r_.__value_.__r.__words[2] = a7;
  LODWORD(this[3].__r_.__value_.__l.__data_) = a4;
  this[3].__r_.__value_.__s.__data_[4] = a5;
  this[3].__r_.__value_.__s.__data_[5] = 0;
}

void sub_1A43CC37C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void NLTransliterationCandidate::NLTransliterationCandidate(std::string *a1, long long *a2, long long *a3)
{
}

void NLTransliterationCandidate::NLTransliterationCandidate(std::string *a1, long long *a2, long long *a3, int a4, std::string::value_type a5, double a6)
{
}

uint64_t NLTransliterationCandidate::setCharLMScore(uint64_t this, double a2)
{
  *(double *)(this + 48) = a2;
  return this;
}

uint64_t NLTransliterationCandidate::setLMScore(uint64_t this, double a2)
{
  *(double *)(this + 56) = a2;
  return this;
}

uint64_t NLTransliterationCandidate::setType(uint64_t result, int a2)
{
  *(_DWORD *)(result + 72) = a2;
  return result;
}

uint64_t NLTransliterationCandidate::setIsExtensionCandidate(uint64_t this, char a2)
{
  *(unsigned char *)(this + 76) = a2;
  return this;
}

uint64_t NLTransliterationCandidate::setIsInVocabulary(uint64_t this, char a2)
{
  *(unsigned char *)(this + 77) = a2;
  return this;
}

uint64_t _CFInit_TransliterationCandidateWrapper(uint64_t result)
{
  *(void *)(result + 16) = &unk_1EF7CDC80;
  return result;
}

uint64_t createCandidateWrapper(NLTransliterationCandidate *a1)
{
  CFAllocatorGetDefault();
  if (!g_CFTypeID_TransliterationCandidateWrapper)
  {
    qword_1EC023FA8 = 0;
    unk_1EC023FB8 = 0u;
    unk_1EC023FC8 = 0u;
    g_CFTypeID_TransliterationCandidateWrapper = _CFRuntimeRegisterClass();
  }
  uint64_t result = _CFRuntimeCreateInstance();
  *(void *)(result + 24) = a1;
  return result;
}

void TransliterationCandidateWrapper::~TransliterationCandidateWrapper(TransliterationCandidateWrapper *this)
{
  TransliterationCandidateWrapper::~TransliterationCandidateWrapper(this);

  JUMPOUT(0x1A625B130);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1EF7CDC80;
  uint64_t v2 = *((void *)this + 1);
  if (v2)
  {
    if (*(char *)(v2 + 47) < 0) {
      operator delete(*(void **)(v2 + 24));
    }
    if (*(char *)(v2 + 23) < 0) {
      operator delete(*(void **)v2);
    }
    MEMORY[0x1A625B130](v2, 0x1012C40B0087DDBLL);
  }

  NLAbstractOrthographyConvertor::~NLAbstractOrthographyConvertor(this);
}

void NL::StringMap::StringMap()
{
}

void sub_1A43CC5A0(_Unwind_Exception *a1)
{
  MEMORY[0x1A625B130](v1, 0x70C40A8FA3B04);
  _Unwind_Resume(a1);
}

void NL::StringMap::createWithFile()
{
}

void sub_1A43CC60C(_Unwind_Exception *a1, int a2)
{
  uint64_t v4 = v2;
  MEMORY[0x1A625B130](v4, 0x80C40803F642BLL);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    JUMPOUT(0x1A43CC5FCLL);
  }
  _Unwind_Resume(a1);
}

void NL::StringMap::~StringMap(NL::StringMap *this)
{
  uint64_t v2 = *((void *)this + 1);
  if (v2)
  {
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(*((void *)this + 1), *(void **)(v2 + 8));
    MEMORY[0x1A625B130](v2, 0x1020C4062D53EE8);
  }
  if (*(void *)this)
  {
    StringMapFile::~StringMapFile(*(StringMapFile **)this);
    MEMORY[0x1A625B130]();
  }
}

void NL::StringMap::get(uint64_t *a1@<X0>, const void **a2@<X1>, std::string *a3@<X8>)
{
  uint64_t v4 = a1[1];
  if (v4) {
    StringMapBuilder::get(v4, a2, a3);
  }
  else {
    StringMapFile::get(*a1, a3);
  }
}

void StringMapBuilder::get(uint64_t a1@<X0>, const void **a2@<X1>, std::string *a3@<X8>)
{
  uint64_t v5 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::find<std::string>(a1, a2);
  if (a1 + 8 == v5)
  {
    std::string::basic_string[abi:ne180100]<0>(a3, "");
  }
  else if (*(char *)(v5 + 79) < 0)
  {
    uint64_t v7 = *(const std::string::value_type **)(v5 + 56);
    std::string::size_type v8 = *(void *)(v5 + 64);
    std::string::__init_copy_ctor_external(a3, v7, v8);
  }
  else
  {
    long long v6 = *(_OWORD *)(v5 + 56);
    a3->__r_.__value_.__r.__words[2] = *(void *)(v5 + 72);
    *(_OWORD *)&a3->__r_.__value_.__l.__data_ = v6;
  }
}

void *StringMapFile::get@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  if (CFBurstTrieFindUTF8String()) {
    uint64_t v4 = *(char **)(a1 + 8);
  }
  else {
    uint64_t v4 = "";
  }
  return std::string::basic_string[abi:ne180100]<0>(a2, v4);
}

uint64_t *StringMapFile::StringMapFile(uint64_t *a1, char *a2)
{
  *a1 = 0;
  CFAllocatorRef v3 = a1 + 2;
  if (a2[23] >= 0) {
    uint64_t v4 = a2;
  }
  else {
    uint64_t v4 = *(char **)a2;
  }
  NL::ReadOnlyFile<char>::open(v4, (uint64_t)"r", 1, v3);
  uint64_t v5 = *(_DWORD **)a1[2];
  if (*v5 != -149896238)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    std::string::basic_string[abi:ne180100]<0>(&v9, "string map file is invalid");
    NL::ResourceCreationException::ResourceCreationException(exception, &v9);
  }
  if (v5[1] != 1)
  {
    std::string::size_type v8 = __cxa_allocate_exception(0x20uLL);
    std::string::basic_string[abi:ne180100]<0>(&v9, "string map file version is not supported");
    NL::ResourceCreationException::ResourceCreationException(v8, &v9);
  }
  a1[1] = (uint64_t)v5 + v5[2] + 24;
  *a1 = CFBurstTrieCreateFromMapBytes();
  return a1;
}

void sub_1A43CC940(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((v17 & 1) == 0)
    {
LABEL_6:
      unint64_t v19 = *(std::__shared_weak_count **)(v15 + 24);
      if (v19) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v19);
      }
      _Unwind_Resume(a1);
    }
  }
  else if (!v17)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v16);
  goto LABEL_6;
}

void NL::ReadOnlyFile<char>::open(char *__s@<X0>, uint64_t a2@<X1>, char a3@<W2>, void *a4@<X8>)
{
  uint64_t v13 = 0;
  unint64_t v14 = &v13;
  uint64_t v15 = 0x4002000000;
  unint64_t v16 = __Block_byref_object_copy__15;
  int v17 = __Block_byref_object_dispose__15;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  std::string::basic_string[abi:ne180100]<0>(__p, __s);
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 0x40000000;
  std::regex_traits<char> v9[2] = ___ZN2NL12ReadOnlyFileIcE4openEPKcS3_b_block_invoke;
  v9[3] = &unk_1E5B36458;
  v9[5] = __s;
  v9[6] = a2;
  char v10 = a3;
  v9[4] = &v13;
  nlp::SingletonResourceManager<std::string,NL::ReadOnlyFile<char>>::getResource((uint64_t)__p, (uint64_t)v9, a4);
  if (v12 < 0) {
    operator delete(__p[0]);
  }
  if ((*((char *)v14 + 63) & 0x80000000) == 0)
  {
    if (!*((unsigned char *)v14 + 63)) {
      goto LABEL_5;
    }
LABEL_9:
    exception = __cxa_allocate_exception(0x20uLL);
    NL::ResourceCreationException::ResourceCreationException(exception, (long long *)(v14 + 5));
  }
  if (v14[6]) {
    goto LABEL_9;
  }
LABEL_5:
  _Block_object_dispose(&v13, 8);
  if (SHIBYTE(v20) < 0) {
    operator delete(v18);
  }
}

void sub_1A43CCB08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  std::string v36 = *(std::__shared_weak_count **)(v34 + 8);
  if (v36) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v36);
  }
  _Block_object_dispose(&a24, 8);
  if (a34 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__15(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(__n128 *)(a1 + 4nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = result;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 4nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = 0;
  return result;
}

void __Block_byref_object_dispose__15(uint64_t a1)
{
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
}

void nlp::SingletonResourceManager<std::string,NL::ReadOnlyFile<char>>::getResource(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v9 = 0;
  char v10 = &v9;
  uint64_t v11 = 0x3802000000;
  char v12 = __Block_byref_object_copy__4;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v13 = __Block_byref_object_dispose__5;
  Queue = nlp::SingletonResourceManager<std::string,NL::ReadOnlyFile<char>>::getQueue();
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 0x40000000;
  v8[2] = ___ZN3nlp24SingletonResourceManagerINSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEN2NL12ReadOnlyFileIcEEE11getResourceERKS7_U13block_pointerFPSA_vE_block_invoke;
  v8[3] = &unk_1E5B36D20;
  void v8[5] = &v9;
  v8[6] = a1;
  v8[4] = a2;
  dispatch_sync(Queue, v8);
  uint64_t v7 = v10[6];
  *a3 = v10[5];
  a3[1] = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  _Block_object_dispose(&v9, 8);
  if (v15) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v15);
  }
}

void ___ZN2NL12ReadOnlyFileIcE4openEPKcS3_b_block_invoke()
{
}

void sub_1A43CCCF4(_Unwind_Exception *a1, int a2)
{
  uint64_t v5 = v3;
  MEMORY[0x1A625B130](v5, 0x1012C403EBA5055);
  if (a2 == 1)
  {
    uint64_t v7 = __cxa_begin_catch(a1);
    uint64_t v8 = (*(uint64_t (**)(void *))(*(void *)v7 + 16))(v7);
    MEMORY[0x1A625AE00](*(void *)(*(void *)(v2 + 32) + 8) + 40, v8);
    __cxa_end_catch();
    JUMPOUT(0x1A43CCCE0);
  }
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__4(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 4nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = result;
  *(void *)(a2 + 4nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = 0;
  *(void *)(a2 + 48) = 0;
  return result;
}

uint64_t nlp::SingletonResourceManager<std::string,NL::ReadOnlyFile<char>>::getQueue()
{
  {
    nlp::SingletonResourceManager<std::string,NL::ReadOnlyFile<char>>::getQueue(void)::attributes = (uint64_t)dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
  }
  unint64_t v0 = 0x1E9646000uLL;
  {
    unint64_t v0 = 0x1E9646000;
    if (v2)
    {
      nlp::SingletonResourceManager<std::string,NL::ReadOnlyFile<char>>::getQueue(void)::queue = (uint64_t)dispatch_queue_create("com.apple.NLPUtils.SingletonResourceManager", (dispatch_queue_attr_t)nlp::SingletonResourceManager<std::string,NL::ReadOnlyFile<char>>::getQueue(void)::attributes);
      unint64_t v0 = 0x1E9646000;
    }
  }
  return *(void *)(v0 + 432);
}

void ___ZN3nlp24SingletonResourceManagerINSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEN2NL12ReadOnlyFileIcEEE11getResourceERKS7_U13block_pointerFPSA_vE_block_invoke(uint64_t a1)
{
  Cache = nlp::SingletonResourceManager<std::string,NL::ReadOnlyFile<char>>::getCache();
  uint64_t v3 = std::__hash_table<std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<NLExtendedString>>>>::find<std::string>(Cache, *(unsigned __int8 **)(a1 + 48));
  if (v3)
  {
    uint64_t v4 = v3;
    uint64_t v5 = (std::__shared_weak_count *)*((void *)v3 + 6);
    if (v5 && (uint64_t v5 = std::__shared_weak_count::lock(v5)) != 0) {
      uint64_t v6 = *((void *)v4 + 5);
    }
    else {
      uint64_t v6 = 0;
    }
    uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8);
    uint64_t v8 = *(std::__shared_weak_count **)(v7 + 48);
    *(void *)(v7 + 4nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = v6;
    *(void *)(v7 + 48) = v5;
    if (v8) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v8);
    }
  }
  uint64_t v9 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v11 = *(void *)(v9 + 40);
  uint64_t v10 = v9 + 40;
  if (!v11)
  {
    uint64_t v12 = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
    std::shared_ptr<NL::ReadOnlyFile<char>>::reset[abi:ne180100]<NL::ReadOnlyFile<char>,void>(v10, v12);
  }
}

void sub_1A43CCF6C(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
  _Unwind_Resume(exception_object);
}

long long *nlp::SingletonResourceManager<std::string,NL::ReadOnlyFile<char>>::getCache()
{
  {
    nlp::SingletonResourceManager<std::string,NL::ReadOnlyFile<char>>::getCache(void)::cache = 0u;
    *(_OWORD *)algn_1E96461D0 = 0u;
    dword_1E96461E0 = 1065353216;
  }
  return &nlp::SingletonResourceManager<std::string,NL::ReadOnlyFile<char>>::getCache(void)::cache;
}

void std::shared_ptr<NL::ReadOnlyFile<char>>::reset[abi:ne180100]<NL::ReadOnlyFile<char>,void>(uint64_t a1, uint64_t a2)
{
  std::shared_ptr<NL::ReadOnlyFile<char>>::shared_ptr[abi:ne180100]<NL::ReadOnlyFile<char>,void>(&v2, a2);
}

void std::shared_ptr<NL::ReadOnlyFile<char>>::shared_ptr[abi:ne180100]<NL::ReadOnlyFile<char>,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1A43CD0A4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<NL::ReadOnlyFile<char>>::reset[abi:ne180100]((uint64_t *)va, 0);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<NL::ReadOnlyFile<char> *,std::shared_ptr<NL::ReadOnlyFile<char>>::__shared_ptr_default_delete<NL::ReadOnlyFile<char>,NL::ReadOnlyFile<char>>,std::allocator<NL::ReadOnlyFile<char>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A625B130);
}

uint64_t std::__shared_ptr_pointer<NL::ReadOnlyFile<char> *,std::shared_ptr<NL::ReadOnlyFile<char>>::__shared_ptr_default_delete<NL::ReadOnlyFile<char>,NL::ReadOnlyFile<char>>,std::allocator<NL::ReadOnlyFile<char>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result)
  {
    NL::ReadOnlyFile<char>::~ReadOnlyFile(result);
    JUMPOUT(0x1A625B130);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<NL::ReadOnlyFile<char> *,std::shared_ptr<NL::ReadOnlyFile<char>>::__shared_ptr_default_delete<NL::ReadOnlyFile<char>,NL::ReadOnlyFile<char>>,std::allocator<NL::ReadOnlyFile<char>>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t NL::ReadOnlyFile<char>::~ReadOnlyFile(uint64_t a1)
{
  long long v2 = *(void **)a1;
  if (*(void *)a1)
  {
    if (*(unsigned char *)(a1 + 68))
    {
      munmap(*(void **)a1, *(void *)(a1 + 8));
    }
    else
    {
      if (*(_DWORD *)(a1 + 64) != 2) {
        goto LABEL_10;
      }
      uint64_t v3 = (const char *)(a1 + 16);
      if (*(char *)(a1 + 39) < 0) {
        uint64_t v3 = *(const char **)v3;
      }
      int v4 = open(v3, 2);
      int v5 = v4;
      long long v2 = *(void **)a1;
      if ((v4 & 0x80000000) == 0)
      {
        write(v4, *(const void **)a1, *(void *)(a1 + 8));
        close(v5);
        long long v2 = *(void **)a1;
      }
      if (v2) {
LABEL_10:
      }
        MEMORY[0x1A625B110](v2, 0x1000C8077774924);
    }
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

uint64_t std::unique_ptr<NL::ReadOnlyFile<char>>::reset[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    NL::ReadOnlyFile<char>::~ReadOnlyFile(result);
    JUMPOUT(0x1A625B130);
  }
  return result;
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::weak_ptr<NL::ReadOnlyFile<char>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::weak_ptr<NL::ReadOnlyFile<char>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::weak_ptr<NL::ReadOnlyFile<char>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::weak_ptr<NL::ReadOnlyFile<char>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1, unsigned __int8 *a2, uint64_t a3, long long **a4)
{
  uint64_t v8 = (void *)(a1 + 24);
  unint64_t v9 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  unint64_t v10 = v9;
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    unint64_t v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v4 = v9;
      if (v9 >= v11) {
        unint64_t v4 = v9 % v11;
      }
    }
    else
    {
      unint64_t v4 = (v11 - 1) & v9;
    }
    uint64_t v14 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v4);
    if (v14)
    {
      for (uint64_t i = *v14; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v16 = *((void *)i + 1);
        if (v16 == v10)
        {
          if (std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2)) {
            return i;
          }
        }
        else
        {
          if (v13 > 1)
          {
            if (v16 >= v11) {
              v16 %= v11;
            }
          }
          else
          {
            v16 &= v11 - 1;
          }
          if (v16 != v4) {
            break;
          }
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,std::weak_ptr<NL::ReadOnlyFile<char>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::weak_ptr<NL::ReadOnlyFile<char>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::weak_ptr<NL::ReadOnlyFile<char>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::weak_ptr<NL::ReadOnlyFile<char>>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1, v10, a4, (uint64_t)v26);
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v18 = *(float *)(a1 + 32);
  if (!v11 || (float)(v18 * (float)v11) < v17)
  {
    BOOL v19 = 1;
    if (v11 >= 3) {
      BOOL v19 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v11);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    std::__hash_table<std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<NLExtendedString>>>>::__rehash<true>(a1, v22);
    unint64_t v11 = *(void *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11) {
        unint64_t v4 = v10 % v11;
      }
      else {
        unint64_t v4 = v10;
      }
    }
    else
    {
      unint64_t v4 = (v11 - 1) & v10;
    }
  }
  unint64_t v23 = *(void **)(*(void *)a1 + 8 * v4);
  if (v23)
  {
    *(void *)v26[0] = *v23;
    void *v23 = v26[0];
  }
  else
  {
    *(void *)v26[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v26[0];
    *(void *)(*(void *)a1 + 8 * v4) = a1 + 16;
    if (*(void *)v26[0])
    {
      unint64_t v24 = *(void *)(*(void *)v26[0] + 8);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v24 >= v11) {
          v24 %= v11;
        }
      }
      else
      {
        v24 &= v11 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v24) = v26[0];
    }
  }
  uint64_t i = (unsigned __int8 *)v26[0];
  v26[0] = 0;
  ++*v8;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::weak_ptr<NL::ReadOnlyFile<char>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::weak_ptr<NL::ReadOnlyFile<char>>>,void *>>>>::reset[abi:ne180100]((uint64_t)v26, 0);
  return i;
}

void sub_1A43CD528(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::weak_ptr<NL::ReadOnlyFile<char>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::weak_ptr<NL::ReadOnlyFile<char>>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<std::string,std::weak_ptr<NL::ReadOnlyFile<char>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::weak_ptr<NL::ReadOnlyFile<char>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::weak_ptr<NL::ReadOnlyFile<char>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::weak_ptr<NL::ReadOnlyFile<char>>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1@<X0>, uint64_t a2@<X1>, long long **a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  uint64_t v8 = operator new(0x38uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *(unsigned char *)(a4 + 16) = 0;
  void *v8 = 0;
  v8[1] = a2;
  unint64_t v9 = (std::string *)(v8 + 2);
  unint64_t v10 = *a3;
  if (*((char *)*a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)v10, *((void *)v10 + 1));
  }
  else
  {
    long long v11 = *v10;
    v8[4] = *((void *)v10 + 2);
    *(_OWORD *)&v9->__r_.__value_.__l.__data_ = v11;
  }
  void v8[5] = 0;
  v8[6] = 0;
  *(unsigned char *)(a4 + 16) = 1;
}

void sub_1A43CD5C8(_Unwind_Exception *a1)
{
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::weak_ptr<NL::ReadOnlyFile<char>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::weak_ptr<NL::ReadOnlyFile<char>>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::weak_ptr<NL::ReadOnlyFile<char>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::weak_ptr<NL::ReadOnlyFile<char>>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  long long v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::weak_ptr<NL::ReadOnlyFile<char>>>,0>((uint64_t)v2 + 16);
    }
    operator delete(v2);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::weak_ptr<NL::ReadOnlyFile<char>>>,0>(uint64_t a1)
{
  long long v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v3 = *(void **)a1;
    operator delete(v3);
  }
}

uint64_t NL::ReadOnlyFile<char>::ReadOnlyFile(uint64_t a1, char *a2, char *a3, int a4)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  std::string::basic_string[abi:ne180100]<0>((void *)(a1 + 16), a2);
  std::string::basic_string[abi:ne180100]<0>((void *)(a1 + 40), a3);
  *(_DWORD *)(a1 + 64) = 0;
  *(unsigned char *)(a1 + 68) = a4;
  if (!strcmp(a3, "r"))
  {
    *(_DWORD *)(a1 + 64) = 0;
    int v8 = open(a2, 0);
  }
  else
  {
    if (strcmp(a3, "r+"))
    {
LABEL_15:
      exception = __cxa_allocate_exception(0x20uLL);
      NL::ReadOnlyFileCreationException::ReadOnlyFileCreationException(exception);
LABEL_16:
    }
    *(_DWORD *)(a1 + 64) = 514;
    int v8 = open(a2, 514, 384);
  }
  int v9 = v8;
  if (v8 < 0) {
    goto LABEL_15;
  }
  if (fstat(v8, &v16) < 0)
  {
    close(v9);
    exception = __cxa_allocate_exception(0x20uLL);
    NL::ReadOnlyFileCreationException::ReadOnlyFileCreationException(exception);
    goto LABEL_16;
  }
  st_std::string::size_type size = v16.st_size;
  *(void *)(a1 + 8) = v16.st_size;
  uint64_t v17 = 0;
  int v18 = st_size;
  fcntl(v9, 44, &v17);
  size_t v11 = *(void *)(a1 + 8);
  if (!a4) {
    operator new[]();
  }
  if (v11)
  {
    uint8x8_t v12 = mmap(0, v11, *(_DWORD *)(a1 + 64) & 2 | 1u, 1, v9, 0);
    if (v12 == (void *)-1)
    {
      close(v9);
      uint64_t v15 = __cxa_allocate_exception(0x20uLL);
      NL::ReadOnlyFileCreationException::ReadOnlyFileCreationException(v15);
    }
    *(void *)a1 = v12;
  }
  close(v9);
  return a1;
}

void sub_1A43CD8E8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v4);
  if (*(char *)(v2 + 63) < 0) {
    operator delete(*v3);
  }
  if (*(char *)(v2 + 39) < 0) {
    operator delete(*v1);
  }
  _Unwind_Resume(a1);
}

void *NL::ReadOnlyFileCreationException::ReadOnlyFileCreationException(void *a1)
{
  std::operator+<char>();
  NL::ResourceCreationException::ResourceCreationException(a1, &__p);
  if (v4 < 0) {
    operator delete((void *)__p);
  }
  *a1 = &unk_1EF7CDD80;
  return a1;
}

void sub_1A43CD9D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void NL::ReadOnlyFileCreationException::~ReadOnlyFileCreationException(std::exception *this)
{
  NL::ResourceCreationException::~ResourceCreationException(this);

  JUMPOUT(0x1A625B130);
}

void StringMapFile::~StringMapFile(StringMapFile *this)
{
  if (*(void *)this) {
    CFBurstTrieRelease();
  }
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
}

dispatch_queue_t ___Z23getParserResourcesQueuev_block_invoke()
{
  dispatch_queue_t result = dispatch_queue_create("com.apple.NLP.Resources", 0);
  getParserResourcesQueue(void)::resourcesQueue = (uint64_t)result;
  return result;
}

NL::ParserResources *NL::ParserResources::ParserResources(NL::ParserResources *this, const __CFDictionary *a2)
{
  *((_OWORD *)this + 1) = 0u;
  char v4 = (const void **)((char *)this + 16);
  *(_OWORD *)this = 0u;
  *((_DWORD *)this + 8) = 8;
  *((void *)this + 5) = 0;
  int v5 = (const void **)((char *)this + 40);
  *((_WORD *)this + 24) = 1;
  uint64_t v6 = (const void **)((char *)this + 8);
  *((void *)this + 8) = 0;
  *((void *)this + 9) = 0;
  *((void *)this + 7) = 0;
  NL::AssetResourceManager::AssetResourceManager((NL::ParserResources *)((char *)this + 80));
  if (!a2) {
    goto LABEL_26;
  }
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a2, kNLSearchParserLocaleKey);
  CFStringRef v8 = Value;
  if (Value)
  {
    CFTypeID v9 = CFGetTypeID(Value);
    if (v9 == CFStringGetTypeID())
    {
      unint64_t v10 = CFLocaleCreate(0, v8);
    }
    else
    {
      CFTypeID v11 = CFGetTypeID(v8);
      if (v11 != CFLocaleGetTypeID()) {
        goto LABEL_8;
      }
      unint64_t v10 = CFRetain(v8);
    }
    nlp::CFScopedPtr<__CFLocale const*>::reset(v6, v10);
  }
LABEL_8:
  uint8x8_t v12 = CFDictionaryGetValue(a2, kNLSearchParserDateKey);
  if (v12) {
    NL::ParserResources::setDate((const void **)this, v12);
  }
  CFStringRef v13 = (const __CFString *)CFDictionaryGetValue(a2, kNLSearchParserCustomResourceDirectoryKey);
  CFStringRef v14 = v13;
  if (!v13) {
    goto LABEL_18;
  }
  CFTypeID v15 = CFGetTypeID(v13);
  if (v15 == CFStringGetTypeID())
  {
    stat v16 = CFURLCreateWithFileSystemPath((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v14, kCFURLPOSIXPathStyle, 1u);
  }
  else
  {
    CFTypeID v17 = CFGetTypeID(v14);
    if (v17 != CFURLGetTypeID()) {
      goto LABEL_16;
    }
    stat v16 = CFRetain(v14);
  }
  nlp::CFScopedPtr<__CFURL const*>::reset(v5, v16);
LABEL_16:
  if (!*v5)
  {
    CFURLRef v18 = CFURLCreateWithString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &stru_1EF7CF078, 0);
    nlp::CFScopedPtr<__CFURL const*>::reset(v5, v18);
  }
LABEL_18:
  BOOL v19 = CFDictionaryGetValue(a2, @"username");
  if (v19)
  {
    CFTypeRef v20 = CFRetain(v19);
    nlp::CFScopedPtr<__CFString const*>::reset(v4, v20);
  }
  if (CFDictionaryContainsKey(a2, @"contextIdentifier"))
  {
    CFStringRef v21 = (const __CFString *)CFDictionaryGetValue(a2, @"contextIdentifier");
    NL::ParserResources::setContext(this, v21);
  }
  if (CFDictionaryContainsKey(a2, @"includeFutureDates"))
  {
    CFBooleanRef v22 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"includeFutureDates");
    if (v22)
    {
      if (CFBooleanGetValue(v22)) {
        *((unsigned char *)this + 49) = 1;
      }
    }
  }
LABEL_26:
  if (!*v6)
  {
    *((unsigned char *)this + 48) = 1;
    LocalCenter = CFNotificationCenterGetLocalCenter();
    CFNotificationCenterAddObserver(LocalCenter, this, (CFNotificationCallback)localeChangeCallback, (CFStringRef)*MEMORY[0x1E4F1D200], 0, CFNotificationSuspensionBehaviorDeliverImmediately);
    CFLocaleRef v24 = copyCurrentLocale();
    nlp::CFScopedPtr<__CFLocale const*>::reset(v6, v24);
  }
  if (getParserResourcesQueue(void)::resourcesOnceToken != -1) {
    dispatch_once(&getParserResourcesQueue(void)::resourcesOnceToken, &__block_literal_global_6);
  }
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZN2NL15ParserResourcesC2EPK14__CFDictionary_block_invoke;
  block[3] = &__block_descriptor_tmp_12;
  block[4] = this;
  dispatch_sync((dispatch_queue_t)getParserResourcesQueue(void)::resourcesQueue, block);
  return this;
}

void sub_1A43CDDCC(_Unwind_Exception *a1)
{
  NL::AssetResourceManager::~AssetResourceManager(v5);
  uint64_t v7 = *(std::__shared_weak_count **)(v1 + 72);
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  nlp::CFScopedPtr<__CFURL const*>::reset(v4, 0);
  nlp::CFScopedPtr<__CFDictionary const*>::reset((const void **)(v1 + 24), 0);
  nlp::CFScopedPtr<__CFString const*>::reset(v2, 0);
  nlp::CFScopedPtr<__CFLocale const*>::reset(v3, 0);
  nlp::CFScopedPtr<__CFDate const*>::reset((const void **)v1, 0);
  _Unwind_Resume(a1);
}

void NL::ParserResources::setDate(const void **this, CFTypeRef cf2)
{
  if (cf2)
  {
    CFTypeRef v3 = cf2;
    char v4 = *this;
    if (*this && CFEqual(v4, cf2)) {
      return;
    }
    nlp::CFScopedPtr<__CFDate const*>::reset(this, 0);
    CFTypeRef cf2 = CFRetain(v3);
  }

  nlp::CFScopedPtr<__CFDate const*>::reset(this, cf2);
}

CFComparisonResult NL::ParserResources::setContext(NL::ParserResources *this, CFStringRef theString1)
{
  CFComparisonResult result = CFStringCompare(theString1, @"com.apple.mail", 1uLL);
  if (result == kCFCompareEqualTo)
  {
    *((_DWORD *)this + 8) = 1;
    return result;
  }
  CFComparisonResult result = CFStringCompare(theString1, @"com.apple.Finder", 1uLL);
  if (result == kCFCompareEqualTo)
  {
    int v5 = 2;
    goto LABEL_15;
  }
  CFComparisonResult result = CFStringCompare(theString1, @"com.apple.Notes", 1uLL);
  if (result == kCFCompareEqualTo
    || (CFComparisonResult result = CFStringCompare(theString1, @"com.apple.mobilenotes", 1uLL)) == kCFCompareEqualTo)
  {
    int v5 = 3;
    goto LABEL_15;
  }
  CFComparisonResult result = CFStringCompare(theString1, @"com.apple.Photos", 1uLL);
  if (result == kCFCompareEqualTo)
  {
    int v5 = 4;
    goto LABEL_15;
  }
  CFComparisonResult result = CFStringCompare(theString1, @"com.apple.Reminders", 1uLL);
  if (result == kCFCompareEqualTo)
  {
    int v5 = 5;
    goto LABEL_15;
  }
  CFComparisonResult result = CFStringCompare(theString1, @"com.apple.Calendar", 1uLL);
  if (result == kCFCompareEqualTo
    || (CFComparisonResult result = CFStringCompare(theString1, @"com.apple.iCal", 1uLL)) == kCFCompareEqualTo)
  {
    int v5 = 6;
    goto LABEL_15;
  }
  CFComparisonResult result = CFStringCompare(theString1, @"com.apple.Spotlight", 1uLL);
  if (result == kCFCompareEqualTo)
  {
    int v5 = 7;
    goto LABEL_15;
  }
  CFComparisonResult result = CFStringCompare(theString1, @"com.apple.NLP", 1uLL);
  if (result)
  {
    int v5 = 8;
LABEL_15:
    *((_DWORD *)this + 8) = v5;
    return result;
  }
  *((_DWORD *)this + 8) = 0;
  return result;
}

void localeChangeCallback(__CFNotificationCenter *a1, NL::ParserResources *a2, const __CFString *a3, const void *a4, const __CFDictionary *a5)
{
  if (a2)
  {
    CFLocaleRef v6 = copyCurrentLocale();
    NL::ParserResources::updateLocale(a2, v6);
    if (v6) {
      CFRelease(v6);
    }
  }
}

void sub_1A43CE07C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  nlp::CFScopedPtr<__CFLocale const*>::reset((const void **)va, 0);
  _Unwind_Resume(a1);
}

void ___ZN2NL15ParserResourcesC2EPK14__CFDictionary_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(NL::ParserResources **)(a1 + 32);
  CFLocaleRef v2 = (const __CFLocale *)*((void *)v1 + 1);
  if (v2) {
    NL::ParserResources::updateLockedResources(v1, v2);
  }
}

void NL::ParserResources::updateLockedResources(NL::ParserResources *this, CFLocaleRef locale)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  char v4 = (std::__shared_weak_count *)*((void *)this + 9);
  *((void *)this + 8) = 0;
  *((void *)this + 9) = 0;
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  int v5 = (const void **)*((void *)this + 7);
  if (v5)
  {
    NLEntityDetectorRelease(v5);
    *((void *)this + 7) = 0;
  }
  CFLocaleRef v6 = (void *)*MEMORY[0x1E4F1D218];
  CFTypeRef Value = CFLocaleGetValue(locale, (CFLocaleKey)*MEMORY[0x1E4F1D218]);
  CFStringRef v8 = (const __CFString *)CFRetain(Value);
  CFStringRef v48 = v8;
  CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFLocaleRef v10 = CFLocaleCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v8);
  CFLocaleRef v47 = v10;
  if (!v10)
  {
    CFTypeID v17 = 0;
    CFURLRef v18 = 0;
    BOOL v19 = 0;
    CFStringRef LocaleIdentifierFromComponents = v8;
    goto LABEL_50;
  }
  if (!CFStringsAreEqual(v8, @"zh")) {
    goto LABEL_17;
  }
  CFTypeID v11 = (std::__shared_weak_count *)*MEMORY[0x1E4F1D220];
  uint8x8_t v12 = (__CFString *)CFLocaleGetValue(locale, (CFLocaleKey)*MEMORY[0x1E4F1D220]);
  if (!v12)
  {
    CFStringRef v13 = (const __CFString *)CFLocaleGetValue(locale, (CFLocaleKey)*MEMORY[0x1E4F1D1F0]);
    if (v13)
    {
      if (CFStringsAreEqual(v13, @"CN")) {
        uint8x8_t v12 = @"Hans";
      }
      else {
        uint8x8_t v12 = @"Hant";
      }
      goto LABEL_12;
    }
LABEL_17:
    stat v16 = v10;
    CFStringRef LocaleIdentifierFromComponents = v8;
    goto LABEL_18;
  }
LABEL_12:
  keys = v6;
  unint64_t v52 = v11;
  values[0] = (CFNumberRef)v8;
  values[1] = (CFNumberRef)v12;
  CFURLRef v14 = CFDictionaryCreate(v9, (const void **)&keys, (const void **)values, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFURLRef v46 = v14;
  CFStringRef LocaleIdentifierFromComponents = CFLocaleCreateLocaleIdentifierFromComponents(v9, v14);
  if (v8) {
    CFRelease(v8);
  }
  CFStringRef v48 = LocaleIdentifierFromComponents;
  stat v16 = CFLocaleCreate(v9, LocaleIdentifierFromComponents);
  CFRelease(v10);
  CFLocaleRef v47 = v16;
  if (v14) {
    CFRelease(v14);
  }
LABEL_18:
  if (*((void *)this + 5))
  {
    CFStringRef v20 = CFStringCreateWithFormat(v9, 0, @"%@/%@-search.plist", LocaleIdentifierFromComponents, LocaleIdentifierFromComponents);
    values[0] = (CFNumberRef)v20;
    NL::AssetResourceManager::createAssetResourceFromPathWithName(v16, *((CFURLRef *)this + 5), v20, &keys);
    CFStringRef v21 = (NL::AssetResource *)keys;
    CFTypeID v17 = v52;
    if (v20) {
      CFRelease(v20);
    }
    if (!v21) {
      goto LABEL_47;
    }
  }
  else
  {
    NL::AssetResourceManager::createAssetResourceOfType(&keys);
    CFStringRef v21 = (NL::AssetResource *)keys;
    CFTypeID v17 = v52;
    if (!keys) {
      goto LABEL_47;
    }
  }
  if (NL::AssetResource::exists((const __CFURL **)v21))
  {
    CFURLRef v22 = (const __CFURL *)NL::AssetResource::URL(v21);
    CFMutableDictionaryRef DictionaryWithContentsOfURL = createDictionaryWithContentsOfURL(v22, 0);
    CFDictionaryRef v24 = DictionaryWithContentsOfURL;
    keys = DictionaryWithContentsOfURL;
    if (!DictionaryWithContentsOfURL) {
      goto LABEL_84;
    }
    if (CFDictionaryContainsKey(DictionaryWithContentsOfURL, @"Contents")
      && (CFArrayRef v25 = (const __CFArray *)CFDictionaryGetValue(v24, @"Contents"), CFArrayGetCount(v25) == 2))
    {
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v25, 0);
      if (CFDictionaryContainsKey(ValueAtIndex, @"Version"))
      {
        CFNumberRef v27 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, @"Version");
        values[0] = CFNumberCreate(v9, kCFNumberIntType, &NLPARSER_MIN_CACHE_VERSION);
        BOOL v28 = CFNumberCompare(v27, values[0], 0) >= kCFCompareEqualTo;
        nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)values, 0);
      }
      else
      {
        BOOL v28 = 0;
      }
      CFDictionaryRef v30 = (const __CFDictionary *)CFArrayGetValueAtIndex(v25, 1);
      if (CFDictionaryContainsKey(v30, @"Version"))
      {
        CFNumberRef v31 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, @"Version");
        values[0] = CFNumberCreate(v9, kCFNumberIntType, &NLPARSER_MIN_CFG_VERSION);
        int v29 = CFNumberCompare(v31, values[0], 0) >= kCFCompareEqualTo && v28;
        nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)values, 0);
      }
      else
      {
        int v29 = 0;
      }
    }
    else
    {
      int v29 = 1;
    }
    if (CFDictionaryContainsKey(v24, @"CanonicalRegions"))
    {
      CFDictionaryRef v32 = (const __CFDictionary *)CFDictionaryGetValue(v24, @"CanonicalRegions");
      CFDictionaryRef Copy = CFDictionaryCreateCopy(v9, v32);
      nlp::CFScopedPtr<__CFDictionary const*>::reset((const void **)this + 3, Copy);
    }
    CFRelease(v24);
    if (v29)
    {
LABEL_84:
      if (*((void *)this + 5))
      {
        CFStringRef v34 = CFStringCreateWithFormat(v9, 0, @"%@/%@-search.cache", LocaleIdentifierFromComponents, LocaleIdentifierFromComponents);
        if (cf) {
          CFRelease(cf);
        }
        CFTypeRef cf = v34;
        NL::AssetResourceManager::createAssetResourceFromPathWithName(v16, *((CFURLRef *)this + 5), v34, &keys);
        unsigned __int8 v35 = (const __CFURL **)keys;
        CFURLRef v18 = v52;
        CFStringRef v36 = CFStringCreateWithFormat(v9, 0, @"%@/%@-search.cfg", LocaleIdentifierFromComponents, LocaleIdentifierFromComponents);
        if (cf) {
          CFRelease(cf);
        }
        CFTypeRef cf = v36;
        NL::AssetResourceManager::createAssetResourceFromPathWithName(v16, *((CFURLRef *)this + 5), v36, &keys);
      }
      else
      {
        NL::AssetResourceManager::createAssetResourceOfType(&keys);
        unsigned __int8 v35 = (const __CFURL **)keys;
        CFURLRef v18 = v52;
        NL::AssetResourceManager::createAssetResourceOfType(&keys);
      }
      int64_t v37 = (const __CFURL **)keys;
      BOOL v19 = v52;
      NL::AssetResourceManager::createAssetResourceFromBundle(0, @"root", @"cache", 0, &keys);
      if (keys)
      {
        uint64_t v38 = NL::AssetResource::URL((NL::AssetResource *)keys);
        unint64_t v39 = (const void **)NLEntityDetectorCreate(v38);
        *((void *)this + 7) = v39;
        if (!v39) {
          goto LABEL_69;
        }
      }
      else
      {
        unint64_t v39 = (const void **)*((void *)this + 7);
        if (!v39)
        {
LABEL_69:
          if (!v39 || !v37 || !NL::AssetResource::exists(v37)) {
            goto LABEL_80;
          }
          CFURLRef v46 = (const __CFURL *)NL::AssetResource::URL((NL::AssetResource *)v37);
          std::allocate_shared[abi:ne180100]<NL::SearchGrammar,std::allocator<NL::SearchGrammar>,__CFURL const*,void>(&v46, values);
          long long v43 = *(_OWORD *)values;
          values[0] = 0;
          values[1] = 0;
          unint64_t v44 = (std::__shared_weak_count *)*((void *)this + 9);
          *((_OWORD *)this + 4) = v43;
          if (v44)
          {
            std::__shared_weak_count::__release_shared[abi:ne180100](v44);
            if (values[1]) {
              std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)values[1]);
            }
          }
          if (NL::SearchGrammar::hasResources(*((NL::SearchGrammar **)this + 8))) {
            goto LABEL_80;
          }
          unsigned int v45 = (std::__shared_weak_count *)*((void *)this + 9);
          *((void *)this + 8) = 0;
          *((void *)this + 9) = 0;
          if (v45) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v45);
          }
          unint64_t v39 = (const void **)*((void *)this + 7);
LABEL_79:
          NLEntityDetectorRelease(v39);
          *((void *)this + 7) = 0;
LABEL_80:
          if (v52) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v52);
          }
          goto LABEL_48;
        }
      }
      if (v35)
      {
        BOOL v40 = NL::AssetResource::exists(v35);
        unint64_t v39 = (const void **)*((void *)this + 7);
        if (v40)
        {
          uint64_t v41 = NL::AssetResource::URL((NL::AssetResource *)v35);
          BOOL LanguageResources = NLEntityDetectorLoadLanguageResources((uint64_t)v39, v41);
          unint64_t v39 = (const void **)*((void *)this + 7);
          if (!LanguageResources) {
            goto LABEL_79;
          }
        }
      }
      goto LABEL_69;
    }
  }
LABEL_47:
  BOOL v19 = 0;
  CFURLRef v18 = 0;
LABEL_48:
  if (v16) {
    CFRelease(v16);
  }
LABEL_50:
  if (LocaleIdentifierFromComponents) {
    CFRelease(LocaleIdentifierFromComponents);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v17) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v17);
  }
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v18);
  }
  if (v19) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v19);
  }
}

void sub_1A43CE6E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va4, a5);
  va_start(va3, a5);
  va_start(va2, a5);
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v7 = va_arg(va1, const void *);
  va_copy(va2, va1);
  CFAllocatorRef v9 = va_arg(va2, const void *);
  va_copy(va3, va2);
  CFTypeID v11 = va_arg(va3, const void *);
  uint64_t v13 = va_arg(va3, void);
  va_copy(va4, va3);
  CFURLRef v14 = va_arg(va4, const void *);
  uint64_t v16 = va_arg(va4, void);
  uint64_t v17 = va_arg(va4, void);
  nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)va3, 0);
  nlp::CFScopedPtr<__CFDictionary const*>::reset((const void **)va4, 0);
  nlp::CFScopedPtr<__CFLocale const*>::reset((const void **)va, 0);
  nlp::CFScopedPtr<__CFString const*>::reset((const void **)va1, 0);
  nlp::CFScopedPtr<__CFString const*>::reset((const void **)va2, 0);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  _Unwind_Resume(a1);
}

void NL::ParserResources::~ParserResources(NL::ParserResources *this)
{
  CFLocaleRef v2 = (const void **)*((void *)this + 7);
  if (v2) {
    NLEntityDetectorRelease(v2);
  }
  NL::AssetResourceManager::~AssetResourceManager((NL::ParserResources *)((char *)this + 80));
  CFTypeRef v3 = (std::__shared_weak_count *)*((void *)this + 9);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  nlp::CFScopedPtr<__CFURL const*>::reset((const void **)this + 5, 0);
  nlp::CFScopedPtr<__CFDictionary const*>::reset((const void **)this + 3, 0);
  nlp::CFScopedPtr<__CFString const*>::reset((const void **)this + 2, 0);
  nlp::CFScopedPtr<__CFLocale const*>::reset((const void **)this + 1, 0);
  nlp::CFScopedPtr<__CFDate const*>::reset((const void **)this, 0);
}

uint64_t NL::ParserResources::copyEntityDetector(NL::ParserResources *this)
{
  uint64_t v5 = 0;
  CFLocaleRef v6 = &v5;
  uint64_t v7 = 0x2000000000;
  uint64_t v8 = 0;
  if (getParserResourcesQueue(void)::resourcesOnceToken != -1) {
    dispatch_once(&getParserResourcesQueue(void)::resourcesOnceToken, &__block_literal_global_6);
  }
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 0x40000000;
  v4[2] = ___ZN2NL15ParserResources18copyEntityDetectorEv_block_invoke;
  v4[3] = &unk_1E5B36DF8;
  v4[4] = &v5;
  void v4[5] = this;
  dispatch_sync((dispatch_queue_t)getParserResourcesQueue(void)::resourcesQueue, v4);
  uint64_t v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

void NL::ParserResources::getSearchGrammar(NL::ParserResources *this@<X0>, void *a2@<X8>)
{
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x3802000000;
  CFAllocatorRef v9 = __Block_byref_object_copy__16;
  uint64_t v11 = 0;
  uint8x8_t v12 = 0;
  CFLocaleRef v10 = __Block_byref_object_dispose__16;
  if (getParserResourcesQueue(void)::resourcesOnceToken != -1) {
    dispatch_once(&getParserResourcesQueue(void)::resourcesOnceToken, &__block_literal_global_6);
  }
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZN2NL15ParserResources16getSearchGrammarEv_block_invoke;
  block[3] = &unk_1E5B36E20;
  block[4] = &v6;
  void block[5] = this;
  dispatch_sync((dispatch_queue_t)getParserResourcesQueue(void)::resourcesQueue, block);
  uint64_t v4 = v7[6];
  *a2 = v7[5];
  a2[1] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  _Block_object_dispose(&v6, 8);
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v12);
  }
}

void NL::ParserResources::setLocale(NL::ParserResources *this, const __CFLocale *a2)
{
  *((unsigned char *)this + 48) = 0;
  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterRemoveObserver(LocalCenter, this, (CFNotificationName)*MEMORY[0x1E4F1D200], 0);
  if (getParserResourcesQueue(void)::resourcesOnceToken != -1) {
    dispatch_once(&getParserResourcesQueue(void)::resourcesOnceToken, &__block_literal_global_6);
  }
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 0x40000000;
  v5[2] = ___ZN2NL15ParserResources9setLocaleEPK10__CFLocale_block_invoke;
  v5[3] = &__block_descriptor_tmp_13_0;
  v5[4] = this;
  v5[5] = a2;
  dispatch_sync((dispatch_queue_t)getParserResourcesQueue(void)::resourcesQueue, v5);
}

void ___ZN2NL15ParserResources9setLocaleEPK10__CFLocale_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(const void ***)(a1 + 32);
  nlp::CFScopedPtr<__CFLocale const*>::reset(v2 + 1, 0);
  CFTypeRef v3 = *(const void **)(a1 + 40);
  if (v3)
  {
    CFTypeRef v4 = CFRetain(v3);
    nlp::CFScopedPtr<__CFLocale const*>::reset(v2 + 1, v4);
    CFLocaleRef v5 = (const __CFLocale *)v2[1];
    NL::ParserResources::updateLockedResources((NL::ParserResources *)v2, v5);
  }
}

void NL::ParserResources::updateLocale(NL::ParserResources *this, const __CFLocale *a2)
{
  if (a2)
  {
    CFLocaleRef v4 = (const __CFLocale *)NL::ParserResources::copyLocale(this);
    void block[6] = v4;
    if (v4)
    {
      if ((NL::AssetResourceManager::checkHasUpdatedAssetsAndReset((NL::ParserResources *)((char *)this + 80)) & 1) == 0)
      {
        CFStringRef v5 = (const __CFString *)*MEMORY[0x1E4F1D218];
        CFStringRef Value = (const __CFString *)CFLocaleGetValue(a2, (CFLocaleKey)*MEMORY[0x1E4F1D218]);
        CFStringRef v7 = (const __CFString *)CFLocaleGetValue(v4, v5);
        BOOL v8 = !Value || v7 == 0;
        if (v8 || CFStringHasPrefix(v7, Value)) {
          goto LABEL_13;
        }
      }
    }
    if (getParserResourcesQueue(void)::resourcesOnceToken != -1) {
      dispatch_once(&getParserResourcesQueue(void)::resourcesOnceToken, &__block_literal_global_6);
    }
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = ___ZN2NL15ParserResources12updateLocaleEPK10__CFLocale_block_invoke;
    block[3] = &__block_descriptor_tmp_14;
    block[4] = this;
    void block[5] = a2;
    dispatch_sync((dispatch_queue_t)getParserResourcesQueue(void)::resourcesQueue, block);
    if (v4) {
LABEL_13:
    }
      CFRelease(v4);
  }
}

void sub_1A43CED84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  nlp::CFScopedPtr<__CFLocale const*>::reset((const void **)va, 0);
  _Unwind_Resume(a1);
}

uint64_t NL::ParserResources::copyLocale(NL::ParserResources *this)
{
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000;
  uint64_t v8 = 0;
  if (getParserResourcesQueue(void)::resourcesOnceToken != -1) {
    dispatch_once(&getParserResourcesQueue(void)::resourcesOnceToken, &__block_literal_global_6);
  }
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 0x40000000;
  v4[2] = ___ZN2NL15ParserResources10copyLocaleEv_block_invoke;
  v4[3] = &unk_1E5B36DD0;
  v4[4] = &v5;
  void v4[5] = this;
  dispatch_sync((dispatch_queue_t)getParserResourcesQueue(void)::resourcesQueue, v4);
  uint64_t v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

void ___ZN2NL15ParserResources12updateLocaleEPK10__CFLocale_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(const void ***)(a1 + 32);
  nlp::CFScopedPtr<__CFLocale const*>::reset(v2 + 1, 0);
  CFTypeRef v3 = *(const void **)(a1 + 40);
  if (v3)
  {
    CFTypeRef v4 = CFRetain(v3);
    nlp::CFScopedPtr<__CFLocale const*>::reset(v2 + 1, v4);
    CFLocaleRef v5 = (const __CFLocale *)v2[1];
    NL::ParserResources::updateLockedResources((NL::ParserResources *)v2, v5);
  }
}

uint64_t ___ZN2NL15ParserResources10copyLocaleEv_block_invoke(uint64_t result)
{
  if (*(void *)(*(void *)(result + 40) + 8))
  {
    uint64_t v1 = result;
    CFComparisonResult result = MEMORY[0x1A625A380](*MEMORY[0x1E4F1CF80]);
    *(void *)(*(void *)(*(void *)(v1 + 32) + 8) + 24) = result;
  }
  return result;
}

uint64_t ___ZN2NL15ParserResources18copyEntityDetectorEv_block_invoke(uint64_t a1)
{
  uint64_t result = *(void *)(*(void *)(a1 + 40) + 56);
  if (result)
  {
    uint64_t result = NLEntityDetectorRetain(result);
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  }
  return result;
}

__n128 __Block_byref_object_copy__16(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 4nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = result;
  *(void *)(a2 + 4nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = 0;
  *(void *)(a2 + 48) = 0;
  return result;
}

void __Block_byref_object_dispose__16(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void ___ZN2NL15ParserResources16getSearchGrammarEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v4 = *(void *)(v1 + 64);
  uint64_t v3 = *(void *)(v1 + 72);
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  CFLocaleRef v5 = *(std::__shared_weak_count **)(v2 + 48);
  *(void *)(v2 + 4nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = v4;
  *(void *)(v2 + 48) = v3;
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
}

NL::AssetResource *NL::ParserResources::copyReferenceDatesPath(NL::ParserResources *this)
{
  CFLocaleRef v2 = CFLocaleCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], @"root");
  CFTypeRef cf = v2;
  if (!v2) {
    return 0;
  }
  CFURLRef v3 = (const __CFURL *)*((void *)this + 5);
  if (v3) {
    NL::AssetResourceManager::createAssetResourceFromPathWithName(v2, v3, @"root/dates.plist", v8);
  }
  else {
    NL::AssetResourceManager::createAssetResourceOfType(v8);
  }
  uint64_t v4 = (NL::AssetResource *)v8[0];
  CFLocaleRef v5 = (std::__shared_weak_count *)v8[1];
  if (v8[0])
  {
    if (NL::AssetResource::exists(v8[0]))
    {
      uint64_t v6 = (const void *)NL::AssetResource::URL(v4);
      uint64_t v4 = (NL::AssetResource *)CFRetain(v6);
    }
    else
    {
      uint64_t v4 = 0;
    }
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  return v4;
}

void sub_1A43CF0A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  nlp::CFScopedPtr<__CFLocale const*>::reset((const void **)va, 0);
  _Unwind_Resume(a1);
}

void NL::ParserResources::setCustomResourcePath(const void **this, const __CFURL *a2)
{
  uint64_t v4 = this + 5;
  nlp::CFScopedPtr<__CFURL const*>::reset(this + 5, 0);
  if (a2)
  {
    CFURLRef v5 = CFURLCopyAbsoluteURL(a2);
    nlp::CFScopedPtr<__CFURL const*>::reset(v4, v5);
  }
  if (getParserResourcesQueue(void)::resourcesOnceToken != -1) {
    dispatch_once(&getParserResourcesQueue(void)::resourcesOnceToken, &__block_literal_global_6);
  }
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZN2NL15ParserResources21setCustomResourcePathEPK7__CFURL_block_invoke;
  block[3] = &__block_descriptor_tmp_60;
  block[4] = this;
  dispatch_sync((dispatch_queue_t)getParserResourcesQueue(void)::resourcesQueue, block);
}

void ___ZN2NL15ParserResources21setCustomResourcePathEPK7__CFURL_block_invoke(uint64_t a1)
{
}

void NL::ParserResources::reset(NL::ParserResources *this)
{
  if (!*((void *)this + 8) || !*((void *)this + 7))
  {
    CFLocaleRef v2 = (const __CFLocale *)NL::ParserResources::copyLocale(this);
    NL::ParserResources::updateLocale(this, v2);
    if (v2) {
      CFRelease(v2);
    }
  }
}

void sub_1A43CF234(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  nlp::CFScopedPtr<__CFLocale const*>::reset((const void **)va, 0);
  _Unwind_Resume(a1);
}

void *std::allocate_shared[abi:ne180100]<NL::SearchGrammar,std::allocator<NL::SearchGrammar>,__CFURL const*,void>@<X0>(const __CFURL **a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x48uLL);
  __n128 result = std::__shared_ptr_emplace<NL::SearchGrammar>::__shared_ptr_emplace[abi:ne180100]<__CFURL const*,std::allocator<NL::SearchGrammar>,0>(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1A43CF294(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<NL::SearchGrammar>::__shared_ptr_emplace[abi:ne180100]<__CFURL const*,std::allocator<NL::SearchGrammar>,0>(void *a1, const __CFURL **a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1EF7CE6C8;
  NL::SearchGrammar::SearchGrammar((NL::SearchGrammar *)(a1 + 3), *a2);
  return a1;
}

void sub_1A43CF2F4(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<NL::SearchGrammar>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7CE6C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<NL::SearchGrammar>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7CE6C8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A625B130);
}

void std::__shared_ptr_emplace<NL::SearchGrammar>::__on_zero_shared(uint64_t a1)
{
}

void NLHindiTransliterator::NLHindiTransliterator(NLHindiTransliterator *this, const __CFDictionary *a2)
{
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_DWORD *)this + 28) = 1065353216;
  *(_OWORD *)((char *)this + 12nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = xmmword_1A43F7930;
  *((_DWORD *)this + 34) = 2;
  *((void *)this + 18) = 0xC03E000000000000;
  *((void *)this + 19) = 0x3E800000005;
  *((_DWORD *)this + 4nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = 3;
  *((void *)this + 21) = 0x3FF3333333333333;
  *((void *)this + 22) = 0x1F40000000ALL;
  *(void *)this = &unk_1EF7CCD98;
  std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((std::regex_traits<char> *)((char *)this + 184), "[\",,;.\"'?!:{}<>*\\-]",
    0);
}

void sub_1A43CF67C(_Unwind_Exception *a1)
{
  MEMORY[0x1A625B130](v8, 0x10E1C4025DEE3AFLL);
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex(v7);
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex(v6);
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex(v5);
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex(v4);
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex(v3);
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex(v2);
  NLGenericTransliterator::~NLGenericTransliterator(v1);
  _Unwind_Resume(a1);
}

uint64_t NLHindiTransliterator::shouldProcessForPhonetics(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  char v13 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  char v16 = 0;
  char v17 = 0;
  uint64_t v18 = 0;
  memset(v10, 0, 41);
  uint64_t v3 = a1 + 504;
  memset(&__p.__prefix_, 0, 17);
  memset(&__p.__suffix_, 0, 17);
  __p.__ready_ = 0;
  __p.__position_start_ = 0;
  memset(&__p, 0, 32);
  uint64_t v4 = *(unsigned __int8 *)(a2 + 23);
  uint64_t v5 = *(void *)(a2 + 8);
  if ((v4 & 0x80u) != 0)
  {
    a2 = *(void *)a2;
    uint64_t v4 = v5;
  }
  *(std::pair<const char *, const char *> *)((char *)&__p.__unmatched_.std::pair<const char *, const char *> + 1) = 0uLL;
  uint64_t v6 = std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>(v3, (char *)a2, (char *)(a2 + v4), &__p, 0);
  uint64_t v7 = *(unsigned __int8 *)(v2 + 23);
  if ((v7 & 0x80u) == 0) {
    uint64_t v8 = v2;
  }
  else {
    uint64_t v8 = *(void *)v2;
  }
  if ((v7 & 0x80u) != 0) {
    uint64_t v7 = *(void *)(v2 + 8);
  }
  std::match_results<std::__wrap_iter<char const*>>::__assign[abi:ne180100]<char const*,std::allocator<std::sub_match<char const*>>>(v10, v8, (std::sub_match<std::__wrap_iter<const char *>> *)(v8 + v7), (uint64_t *)&__p, 0);
  if (__p.__matches_.__begin_)
  {
    __p.__matches_.__end_ = __p.__matches_.__begin_;
    operator delete(__p.__matches_.__begin_);
  }
  if (v10[0].__begin_)
  {
    v10[0].__end_ = v10[0].__begin_;
    operator delete(v10[0].__begin_);
  }
  return v6;
}

void sub_1A43CF87C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24)
{
  if (__p) {
    operator delete(__p);
  }
  if (a9) {
    operator delete(a9);
  }
  _Unwind_Resume(exception_object);
}

void NLHindiTransliterator::addSpecialElements(void **a1, char *a2, int *a3, unsigned int *a4, unsigned int *a5, uint64_t *a6)
{
  std::string::basic_string[abi:ne180100]<0>(&__str, a2);
  std::string::basic_string(&v16, &__str, *a3, 2uLL, (std::allocator<char> *)&p_str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  (*(void (**)(std::string *__return_ptr))(*a1[1] + 32))(&__str);
  ((void (*)(void **, std::string *, void, void, char *, uint64_t *))(*a1)[18])(a1, &__str, *a4, *a5, a2, a6);
  uint64_t v12 = *a6;
  if (a6[1] != *a6)
  {
    uint64_t v13 = 0;
    unint64_t v14 = 0;
    do
    {
      NLExtendedString::setJoin(v12 + v13, 1);
      ++v14;
      uint64_t v12 = *a6;
      v13 += 48;
    }
    while (0xAAAAAAAAAAAAAAABLL * ((a6[1] - *a6) >> 4) > v14);
  }
  p_str = &__str;
  std::vector<NLExtendedString>::__destroy_vector::operator()[abi:ne180100]((void ***)&p_str);
  if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v16.__r_.__value_.__l.__data_);
  }
}

void sub_1A43CF9F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t *a22)
{
  a22 = &a10;
  std::vector<NLExtendedString>::__destroy_vector::operator()[abi:ne180100]((void ***)&a22);
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

double NLHindiTransliterator::getEnglishCandidateSequenceScore(uint64_t a1, uint64_t *a2)
{
  stringToUTF32Characters(a2, &v8);
  double v2 = 0.0;
  if (v8 != v9)
  {
    uint64_t v3 = v8;
    do
    {
      int v4 = *v3;
      double v5 = -0.75;
      if (*v3 != 2381)
      {
        double v5 = 1.0;
        if ((v4 - 2325) >= 0x25 && (v4 & 0xFFFFFFF8) != 0x958)
        {
          if ((v4 & 0xFFFFFFFE) != 0x960 && (v4 - 2309) >= 0x10) {
            double v5 = 0.3;
          }
          else {
            double v5 = 0.5;
          }
        }
      }
      double v2 = v2 + v5;
      ++v3;
    }
    while (v3 != v9);
  }
  if (v8)
  {
    CFAllocatorRef v9 = v8;
    operator delete(v8);
  }
  return v2;
}

void NLHindiTransliterator::preProcessForRomanSuffixes(uint64_t a1@<X0>, std::__wrap_iter<const char *> a2@<X1>, uint64_t a3@<X8>)
{
  std::string::size_type v5 = *((unsigned __int8 *)a2.__i_ + 23);
  if ((a2.__i_[23] & 0x80000000) == 0)
  {
    if (v5 < 4)
    {
      *(_OWORD *)a3 = *(_OWORD *)a2.__i_;
      std::string::size_type v6 = *((void *)a2.__i_ + 2);
LABEL_19:
      *(void *)(a3 + 16) = v6;
      return;
    }
    std::string::size_type v7 = *((void *)a2.__i_ + 1);
LABEL_9:
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    if ((v5 & 0x80u) != 0)
    {
      a2.__i_ = *(std::__wrap_iter<const char *>::iterator_type *)a2.__i_;
      std::string::size_type v5 = v7;
    }
    v9.__i_ = &a2.__i_[v5];
    std::regex_replace[abi:ne180100]<std::back_insert_iterator<std::string>,std::__wrap_iter<char const*>,std::regex_traits<char>,char>((std::string *)a3, a2, v9, (const std::regex_iterator<std::__wrap_iter<const char *>, char>::regex_type *)(a1 + 248), "$1$2", 0);
    memset(&v13, 0, sizeof(v13));
    uint64_t v10 = *(unsigned __int8 *)(a3 + 23);
    if ((v10 & 0x80u) == 0) {
      v11.__i_ = (std::__wrap_iter<const char *>::iterator_type)a3;
    }
    else {
      v11.__i_ = *(std::__wrap_iter<const char *>::iterator_type *)a3;
    }
    if ((v10 & 0x80u) != 0) {
      uint64_t v10 = *(void *)(a3 + 8);
    }
    v12.__i_ = &v11.__i_[v10];
    std::regex_replace[abi:ne180100]<std::back_insert_iterator<std::string>,std::__wrap_iter<char const*>,std::regex_traits<char>,char>(&v13, v11, v12, (const std::regex_iterator<std::__wrap_iter<const char *>, char>::regex_type *)(a1 + 312), "$1", 0);
    if (*(char *)(a3 + 23) < 0) {
      operator delete(*(void **)a3);
    }
    *(_OWORD *)a3 = *(_OWORD *)&v13.__r_.__value_.__l.__data_;
    std::string::size_type v6 = v13.__r_.__value_.__r.__words[2];
    goto LABEL_19;
  }
  std::string::size_type v7 = *((void *)a2.__i_ + 1);
  if (v7 >= 4) {
    goto LABEL_9;
  }
  uint64_t v8 = *(const std::string::value_type **)a2.__i_;

  std::string::__init_copy_ctor_external((std::string *)a3, v8, v7);
}

void sub_1A43CFC10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v15 + 23) < 0) {
    operator delete(*(void **)v15);
  }
  _Unwind_Resume(exception_object);
}

void NLHindiTransliterator::addDynamicMapping(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  char v45 = 0;
  uint64_t v46 = 0;
  uint64_t v47 = 0;
  char v48 = 0;
  char v49 = 0;
  uint64_t v50 = 0;
  memset(v42, 0, 41);
  uint64_t v4 = a1 + 376;
  memset(&v51.__prefix_, 0, 17);
  memset(&v51.__suffix_, 0, 17);
  v51.__ready_ = 0;
  v51.__position_start_ = 0;
  memset(&v51, 0, 32);
  uint64_t v5 = *(unsigned __int8 *)(a2 + 23);
  uint64_t v6 = *(void *)(a2 + 8);
  if ((v5 & 0x80u) != 0)
  {
    a2 = *(void *)a2;
    uint64_t v5 = v6;
  }
  *(std::pair<const char *, const char *> *)((char *)&v51.__unmatched_.std::pair<const char *, const char *> + 1) = 0uLL;
  int v7 = std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>(v4, (char *)a2, (char *)(a2 + v5), &v51, 0);
  uint64_t v8 = *(unsigned __int8 *)(v2 + 23);
  if ((v8 & 0x80u) == 0) {
    uint64_t v9 = v2;
  }
  else {
    uint64_t v9 = *(void *)v2;
  }
  if ((v8 & 0x80u) != 0) {
    uint64_t v8 = *(void *)(v2 + 8);
  }
  std::match_results<std::__wrap_iter<char const*>>::__assign[abi:ne180100]<char const*,std::allocator<std::sub_match<char const*>>>(v42, v9, (std::sub_match<std::__wrap_iter<const char *>> *)(v9 + v8), (uint64_t *)&v51, 0);
  if (v51.__matches_.__begin_)
  {
    v51.__matches_.__end_ = v51.__matches_.__begin_;
    operator delete(v51.__matches_.__begin_);
  }
  int v10 = *(unsigned __int8 *)(v2 + 23);
  if (v7)
  {
    if ((v10 & 0x80u) == 0) {
      uint64_t v11 = *(unsigned __int8 *)(v2 + 23);
    }
    else {
      uint64_t v11 = *(void *)(v2 + 8);
    }
    if ((v10 & 0x80u) == 0) {
      std::__wrap_iter<const char *> v12 = (char *)v2;
    }
    else {
      std::__wrap_iter<const char *> v12 = *(char **)v2;
    }
    std::string v13 = &v12[v11];
    unint64_t v14 = &v12[v11];
    if (v11 > 4)
    {
      uint64_t v15 = v11;
      std::string v16 = v12;
      do
      {
        char v17 = (char *)memchr(v16, 112, v15 - 4);
        if (!v17) {
          break;
        }
        unint64_t v14 = v17;
        if (*(_DWORD *)v17 == 1953067632 && v17[4] == 104) {
          goto LABEL_26;
        }
        std::string v16 = v17 + 1;
        uint64_t v15 = v13 - (v14 + 1);
      }
      while (v15 > 4);
      unint64_t v14 = &v12[v11];
    }
LABEL_26:
    if (v11 >= 4)
    {
      BOOL v19 = v12;
      do
      {
        CFStringRef v20 = (char *)memchr(v19, 103, v11 - 3);
        if (!v20) {
          break;
        }
        if (*(_DWORD *)v20 == 1751741031) {
          goto LABEL_32;
        }
        BOOL v19 = v20 + 1;
        uint64_t v11 = v13 - (unsigned char *)v19;
      }
      while (v13 - (unsigned char *)v19 > 3);
    }
    CFStringRef v20 = v13;
LABEL_32:
    BOOL v22 = v20 != v13 && v20 - v12 != -1;
    BOOL v23 = v14 - v12 == -1 || v14 == v13;
    if (!v23 || v22)
    {
      std::string::basic_string[abi:ne180100]<0>(__p, "");
      NLExtendedString::NLExtendedString((std::string *)&v51, (long long *)__p, 2, 2, 1.0);
      if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p[0].__r_.__value_.__l.__data_);
      }
    }
    else
    {
      std::string::basic_string[abi:ne180100]<0>(__p, "");
      NLExtendedString::NLExtendedString((std::string *)&v51, (long long *)__p, 2, 2, 0.005);
      if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p[0].__r_.__value_.__l.__data_);
      }
    }
    uint64_t v24 = *(void *)(a1 + 8);
    std::string::basic_string[abi:ne180100]<0>(__p, "i");
    (*(void (**)(uint64_t, std::string *, std::match_results<const char *> *))(*(void *)v24 + 16))(v24, __p, &v51);
    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p[0].__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v51.__matches_.__end_cap_.__value_) < 0) {
      operator delete(v51.__matches_.__begin_);
    }
    int v10 = *(unsigned __int8 *)(v2 + 23);
    uint64_t v25 = *(void *)(v2 + 8);
    if ((v10 & 0x80u) != 0)
    {
      unint64_t v26 = *(char **)v2;
    }
    else
    {
      uint64_t v25 = *(unsigned __int8 *)(v2 + 23);
      unint64_t v26 = (char *)v2;
    }
    if (v25 >= 2)
    {
      CFNumberRef v27 = &v26[v25];
      BOOL v28 = v26;
      do
      {
        int v29 = (char *)memchr(v28, 114, v25 - 1);
        if (!v29) {
          break;
        }
        if (*(_WORD *)v29 == 30066)
        {
          if (v29 != v27 && v29 - v26 != -1)
          {
            std::string::basic_string[abi:ne180100]<0>(__p, "");
            NLExtendedString::NLExtendedString((std::string *)&v51, (long long *)__p, 2, 2, 0.005);
            if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__p[0].__r_.__value_.__l.__data_);
            }
            uint64_t v30 = *(void *)(a1 + 8);
            std::string::basic_string[abi:ne180100]<0>(__p, "u");
            (*(void (**)(uint64_t, std::string *, std::match_results<const char *> *))(*(void *)v30 + 16))(v30, __p, &v51);
            if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__p[0].__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v51.__matches_.__end_cap_.__value_) < 0) {
              operator delete(v51.__matches_.__begin_);
            }
            int v10 = *(unsigned __int8 *)(v2 + 23);
          }
          break;
        }
        BOOL v28 = v29 + 1;
        uint64_t v25 = v27 - (unsigned char *)v28;
      }
      while (v27 - (unsigned char *)v28 >= 2);
    }
  }
  if ((v10 & 0x80) != 0)
  {
    if (*(void *)(v2 + 8) != 1) {
      goto LABEL_121;
    }
    CFNumberRef v31 = *(unsigned char **)v2;
  }
  else
  {
    CFNumberRef v31 = (unsigned char *)v2;
    if (v10 != 1) {
      goto LABEL_85;
    }
  }
  if (*v31 == 111)
  {
    std::string::basic_string[abi:ne180100]<0>(__p, "");
    NLExtendedString::NLExtendedString((std::string *)&v51, (long long *)__p, 1, 3, 1.0);
    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p[0].__r_.__value_.__l.__data_);
    }
    uint64_t v32 = *(void *)(a1 + 8);
    std::string::basic_string[abi:ne180100]<0>(__p, "o");
    (*(void (**)(uint64_t, std::string *, std::match_results<const char *> *))(*(void *)v32 + 16))(v32, __p, &v51);
    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p[0].__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v51.__matches_.__end_cap_.__value_) < 0) {
      operator delete(v51.__matches_.__begin_);
    }
    int v10 = *(unsigned __int8 *)(v2 + 23);
  }
  if ((v10 & 0x80) != 0)
  {
    if (*(void *)(v2 + 8) != 1) {
      goto LABEL_121;
    }
    long long v33 = *(unsigned char **)v2;
    goto LABEL_89;
  }
LABEL_85:
  if (v10 != 1) {
    goto LABEL_110;
  }
  int v10 = 1;
  long long v33 = (unsigned char *)v2;
LABEL_89:
  if (*v33 == 110)
  {
    std::string::basic_string[abi:ne180100]<0>(__p, "");
    NLExtendedString::NLExtendedString((std::string *)&v51, (long long *)__p, 1, 3, 0.00001);
    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p[0].__r_.__value_.__l.__data_);
    }
    uint64_t v34 = *(void *)(a1 + 8);
    std::string::basic_string[abi:ne180100]<0>(__p, "n");
    (*(void (**)(uint64_t, std::string *, std::match_results<const char *> *))(*(void *)v34 + 16))(v34, __p, &v51);
    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p[0].__r_.__value_.__l.__data_);
    }
    std::string::basic_string[abi:ne180100]<0>(&v40, "");
    NLExtendedString::NLExtendedString(__p, (long long *)&v40, 1, 3, 0.00001);
    if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v40.__r_.__value_.__l.__data_);
    }
    uint64_t v35 = *(void *)(a1 + 8);
    std::string::basic_string[abi:ne180100]<0>(&v40, "n");
    (*(void (**)(uint64_t, std::string *, std::string *))(*(void *)v35 + 16))(v35, &v40, __p);
    if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v40.__r_.__value_.__l.__data_);
    }
    std::string::basic_string[abi:ne180100]<0>(v38, "");
    NLExtendedString::NLExtendedString(&v40, (long long *)v38, 1, 3, 0.00001);
    if (v39 < 0) {
      operator delete(v38[0]);
    }
    uint64_t v36 = *(void *)(a1 + 8);
    std::string::basic_string[abi:ne180100]<0>(v38, "n");
    (*(void (**)(uint64_t, void **, std::string *))(*(void *)v36 + 16))(v36, v38, &v40);
    if (v39 < 0) {
      operator delete(v38[0]);
    }
    if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v40.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p[0].__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v51.__matches_.__end_cap_.__value_) < 0) {
      operator delete(v51.__matches_.__begin_);
    }
    int v10 = *(unsigned __int8 *)(v2 + 23);
  }
  if ((v10 & 0x80) == 0)
  {
LABEL_110:
    if (v10 != 1) {
      goto LABEL_121;
    }
    goto LABEL_114;
  }
  if (*(void *)(v2 + 8) != 1) {
    goto LABEL_121;
  }
  uint64_t v2 = *(void *)v2;
LABEL_114:
  if (*(unsigned char *)v2 == 114)
  {
    std::string::basic_string[abi:ne180100]<0>(__p, "");
    NLExtendedString::NLExtendedString((std::string *)&v51, (long long *)__p, 1, 3, 0.00001);
    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p[0].__r_.__value_.__l.__data_);
    }
    uint64_t v37 = *(void *)(a1 + 8);
    std::string::basic_string[abi:ne180100]<0>(__p, "r");
    (*(void (**)(uint64_t, std::string *, std::match_results<const char *> *))(*(void *)v37 + 16))(v37, __p, &v51);
    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p[0].__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v51.__matches_.__end_cap_.__value_) < 0) {
      operator delete(v51.__matches_.__begin_);
    }
  }
LABEL_121:
  if (v42[0].__begin_)
  {
    v42[0].__end_ = v42[0].__begin_;
    operator delete(v42[0].__begin_);
  }
}

void sub_1A43D0428(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35)
{
  if (a30 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v35 - 185) < 0) {
    operator delete(*(void **)(v35 - 208));
  }
  if (a34) {
    operator delete(a34);
  }
  _Unwind_Resume(exception_object);
}

void NLHindiTransliterator::postProcessForNewOrthography(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  std::string::basic_string[abi:ne180100]<0>(&v16, "");
  std::string::basic_string[abi:ne180100]<0>(__p, "");
  LODWORD(v4) = *(char *)(a1 + 23);
  if ((v4 & 0x80000000) == 0)
  {
    *(_OWORD *)a2 = *(_OWORD *)a1;
    *(void *)(a2 + 16) = *(void *)(a1 + 16);
LABEL_4:
    unint64_t v4 = v4;
    goto LABEL_5;
  }
  std::string::__init_copy_ctor_external((std::string *)a2, *(const std::string::value_type **)a1, *(void *)(a1 + 8));
  LODWORD(v4) = *(char *)(a1 + 23);
  if ((v4 & 0x80000000) == 0) {
    goto LABEL_4;
  }
  unint64_t v4 = *(void *)(a1 + 8);
LABEL_5:
  unint64_t v5 = v18;
  if ((v18 & 0x80u) != 0) {
    unint64_t v5 = v17;
  }
  if (v4 > v5) {
    replaceAll((std::string *)a2, (char *)&v16, (uint64_t)__p);
  }
  MEMORY[0x1A625AE00](&v16, "");
  MEMORY[0x1A625AE00](__p, "");
  int v6 = *(char *)(a1 + 23);
  int v7 = *(char *)(a2 + 23);
  if (v7 >= 0) {
    size_t v8 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    size_t v8 = *(void *)(a2 + 8);
  }
  if (v7 >= 0) {
    uint64_t v9 = (const void *)a2;
  }
  else {
    uint64_t v9 = *(const void **)a2;
  }
  if (v6 >= 0) {
    size_t v10 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    size_t v10 = *(void *)(a1 + 8);
  }
  if (v6 >= 0) {
    uint64_t v11 = (const std::string::value_type *)a1;
  }
  else {
    uint64_t v11 = *(const std::string::value_type **)a1;
  }
  if (v10 >= v8) {
    size_t v12 = v8;
  }
  else {
    size_t v12 = v10;
  }
  if (!memcmp(v9, v11, v12) && v10 == v8)
  {
    size_t v13 = v18;
    if ((v18 & 0x80u) != 0) {
      size_t v13 = v17;
    }
    if (v8 > v13) {
      replaceAll((std::string *)a2, (char *)&v16, (uint64_t)__p);
    }
  }
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  if ((char)v18 < 0) {
    operator delete(v16);
  }
}

void sub_1A43D06C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void NLHindiTransliterator::postProcessForExaggeration(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v10 = a1[1];
  std::string::basic_string(&__p, (const std::string *)a2, 0, 2uLL, (std::allocator<char> *)&v22);
  (*(void (**)(void *__return_ptr, uint64_t, std::string *))(*(void *)v10 + 32))(v21, v10, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  *a5 = 0;
  a5[1] = 0;
  a5[2] = 0;
  int v11 = *(unsigned __int8 *)(a2 + 23);
  if ((v11 & 0x80u) != 0) {
    int v11 = *(_DWORD *)(a2 + 8);
  }
  (*(void (**)(void *, void *, uint64_t, void, uint64_t, uint64_t *))(*a1 + 144))(a1, v21, a4, (v11 + a4), a3, a5);
  uint64_t v12 = *a5;
  if (a5[1] != *a5)
  {
    unint64_t v13 = 0;
    do
    {
      NLAbstractOrthographyConvertor::~NLAbstractOrthographyConvertor((NLAbstractOrthographyConvertor *)(v12 + 48 * v13));
      if (*((char *)v14 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)v14, *((void *)v14 + 1));
      }
      else
      {
        long long v15 = *v14;
        __p.__r_.__value_.__r.__words[2] = *((void *)v14 + 2);
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v15;
      }
      if (0xAAAAAAAAAAAAAAABLL * ((a5[1] - *a5) >> 4) <= v13) {
        goto LABEL_24;
      }
      double Weight = NLExtendedString::getWeight((NLExtendedString *)(*a5 + 48 * v13));
      unint64_t v17 = *(unsigned __int8 *)(a2 + 23);
      if ((v17 & 0x80u) != 0) {
        unint64_t v17 = *(void *)(a2 + 8);
      }
      if (v17 >= 3)
      {
        for (unint64_t i = 2; i < v19; ++i)
        {
          std::string::append(&__p, "");
          double Weight = Weight + Weight;
          unint64_t v19 = *(unsigned __int8 *)(a2 + 23);
          if ((v19 & 0x80u) != 0) {
            unint64_t v19 = *(void *)(a2 + 8);
          }
        }
      }
      if (0xAAAAAAAAAAAAAAABLL * ((a5[1] - *a5) >> 4) <= v13
        || (NLExtendedString::setString((std::string *)(*a5 + 48 * v13), &__p),
            0xAAAAAAAAAAAAAAABLL * ((a5[1] - *a5) >> 4) <= v13))
      {
LABEL_24:
        std::vector<NLExtendedString>::__throw_out_of_range[abi:ne180100]();
      }
      NLExtendedString::setWeight(*a5 + 48 * v13, Weight);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      ++v13;
      uint64_t v12 = *a5;
    }
    while (0xAAAAAAAAAAAAAAABLL * ((a5[1] - *a5) >> 4) > v13);
  }
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v21;
  std::vector<NLExtendedString>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
}

void sub_1A43D0970(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
  std::string __p = &a16;
  std::vector<NLExtendedString>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  _Unwind_Resume(a1);
}

void NLHindiTransliterator::postProcessForPhonetics(uint64_t a1@<X1>, uint64_t *a2@<X8>)
{
  std::string::basic_string[abi:ne180100]<0>(v49, "");
  std::string::basic_string[abi:ne180100]<0>(__p, "");
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  if (*(char *)(a1 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__str, *(const std::string::value_type **)a1, *(void *)(a1 + 8));
  }
  else {
    std::string __str = *(std::string *)a1;
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&v45, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
  }
  else {
    std::string v45 = __str;
  }
  replaceAll(&v45, (char *)v49, (uint64_t)__p);
  int v4 = SHIBYTE(v45.__r_.__value_.__r.__words[2]);
  long long v5 = *(_OWORD *)&v45.__r_.__value_.__l.__data_;
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __str.__r_.__value_.__l.__size_;
  }
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_str = &__str;
  }
  else {
    p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
  }
  if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v8 = HIBYTE(v45.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v8 = v45.__r_.__value_.__l.__size_;
  }
  if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v9 = &v45;
  }
  else {
    uint64_t v9 = (std::string *)v45.__r_.__value_.__r.__words[0];
  }
  if (v8 >= size) {
    size_t v10 = size;
  }
  else {
    size_t v10 = v8;
  }
  if (memcmp(p_str, v9, v10) || v8 != size)
  {
    unint64_t v12 = a2[1];
    if (v12 >= a2[2])
    {
      uint64_t v14 = std::vector<std::string>::__push_back_slow_path<std::string const&>(a2, (long long *)&v45);
    }
    else
    {
      if (v4 < 0)
      {
        std::string::__init_copy_ctor_external((std::string *)a2[1], (const std::string::value_type *)v5, *((std::string::size_type *)&v5 + 1));
      }
      else
      {
        long long v13 = *(_OWORD *)&v45.__r_.__value_.__l.__data_;
        *(void *)(v12 + 16) = *((void *)&v45.__r_.__value_.__l + 2);
        *(_OWORD *)unint64_t v12 = v13;
      }
      uint64_t v14 = v12 + 24;
      a2[1] = v12 + 24;
    }
    a2[1] = v14;
  }
  MEMORY[0x1A625AE00](v49, "");
  MEMORY[0x1A625AE00](__p, "");
  std::string::operator=(&__str, &v45);
  std::string::operator=(&v45, &__str);
  replaceAll(&v45, (char *)v49, (uint64_t)__p);
  int v15 = SHIBYTE(v45.__r_.__value_.__r.__words[2]);
  long long v16 = *(_OWORD *)&v45.__r_.__value_.__l.__data_;
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v17 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v17 = __str.__r_.__value_.__l.__size_;
  }
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unsigned __int8 v18 = &__str;
  }
  else {
    unsigned __int8 v18 = (std::string *)__str.__r_.__value_.__r.__words[0];
  }
  if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v19 = HIBYTE(v45.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v19 = v45.__r_.__value_.__l.__size_;
  }
  if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    CFStringRef v20 = &v45;
  }
  else {
    CFStringRef v20 = (std::string *)v45.__r_.__value_.__r.__words[0];
  }
  if (v19 >= v17) {
    size_t v21 = v17;
  }
  else {
    size_t v21 = v19;
  }
  if (memcmp(v18, v20, v21) || v19 != v17)
  {
    unint64_t v22 = a2[1];
    if (v22 >= a2[2])
    {
      uint64_t v24 = std::vector<std::string>::__push_back_slow_path<std::string const&>(a2, (long long *)&v45);
    }
    else
    {
      if (v15 < 0)
      {
        std::string::__init_copy_ctor_external((std::string *)a2[1], (const std::string::value_type *)v16, *((std::string::size_type *)&v16 + 1));
      }
      else
      {
        long long v23 = *(_OWORD *)&v45.__r_.__value_.__l.__data_;
        *(void *)(v22 + 16) = *((void *)&v45.__r_.__value_.__l + 2);
        *(_OWORD *)unint64_t v22 = v23;
      }
      uint64_t v24 = v22 + 24;
      a2[1] = v22 + 24;
    }
    a2[1] = v24;
  }
  MEMORY[0x1A625AE00](v49, "");
  MEMORY[0x1A625AE00](__p, "");
  std::string::operator=(&__str, &v45);
  std::string::operator=(&v45, &__str);
  replaceAll(&v45, (char *)v49, (uint64_t)__p);
  int v25 = SHIBYTE(v45.__r_.__value_.__r.__words[2]);
  long long v26 = *(_OWORD *)&v45.__r_.__value_.__l.__data_;
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v27 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v27 = __str.__r_.__value_.__l.__size_;
  }
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    BOOL v28 = &__str;
  }
  else {
    BOOL v28 = (std::string *)__str.__r_.__value_.__r.__words[0];
  }
  if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v29 = HIBYTE(v45.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v29 = v45.__r_.__value_.__l.__size_;
  }
  if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v30 = &v45;
  }
  else {
    uint64_t v30 = (std::string *)v45.__r_.__value_.__r.__words[0];
  }
  if (v29 >= v27) {
    size_t v31 = v27;
  }
  else {
    size_t v31 = v29;
  }
  if (memcmp(v28, v30, v31) || v29 != v27)
  {
    unint64_t v32 = a2[1];
    if (v32 >= a2[2])
    {
      uint64_t v34 = std::vector<std::string>::__push_back_slow_path<std::string const&>(a2, (long long *)&v45);
    }
    else
    {
      if (v25 < 0)
      {
        std::string::__init_copy_ctor_external((std::string *)a2[1], (const std::string::value_type *)v26, *((std::string::size_type *)&v26 + 1));
      }
      else
      {
        long long v33 = *(_OWORD *)&v45.__r_.__value_.__l.__data_;
        *(void *)(v32 + 16) = *((void *)&v45.__r_.__value_.__l + 2);
        *(_OWORD *)unint64_t v32 = v33;
      }
      uint64_t v34 = v32 + 24;
      a2[1] = v32 + 24;
    }
    a2[1] = v34;
  }
  MEMORY[0x1A625AE00](v49, "");
  MEMORY[0x1A625AE00](__p, "");
  std::string::operator=(&__str, &v45);
  std::string::operator=(&v45, &__str);
  replaceAll(&v45, (char *)v49, (uint64_t)__p);
  int v35 = SHIBYTE(v45.__r_.__value_.__r.__words[2]);
  long long v36 = *(_OWORD *)&v45.__r_.__value_.__l.__data_;
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v37 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v37 = __str.__r_.__value_.__l.__size_;
  }
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v38 = &__str;
  }
  else {
    uint64_t v38 = (std::string *)__str.__r_.__value_.__r.__words[0];
  }
  if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v39 = HIBYTE(v45.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v39 = v45.__r_.__value_.__l.__size_;
  }
  if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string v40 = &v45;
  }
  else {
    std::string v40 = (std::string *)v45.__r_.__value_.__r.__words[0];
  }
  if (v39 >= v37) {
    size_t v41 = v37;
  }
  else {
    size_t v41 = v39;
  }
  if (!memcmp(v38, v40, v41) && v39 == v37)
  {
    if ((v35 & 0x80) == 0) {
      goto LABEL_99;
    }
    goto LABEL_113;
  }
  unint64_t v42 = a2[1];
  if (v42 >= a2[2])
  {
    uint64_t v44 = std::vector<std::string>::__push_back_slow_path<std::string const&>(a2, (long long *)&v45);
  }
  else
  {
    if (v35 < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)a2[1], (const std::string::value_type *)v36, *((std::string::size_type *)&v36 + 1));
    }
    else
    {
      long long v43 = *(_OWORD *)&v45.__r_.__value_.__l.__data_;
      *(void *)(v42 + 16) = *((void *)&v45.__r_.__value_.__l + 2);
      *(_OWORD *)unint64_t v42 = v43;
    }
    uint64_t v44 = v42 + 24;
    a2[1] = v42 + 24;
  }
  a2[1] = v44;
  if ((*((unsigned char *)&v45.__r_.__value_.__s + 23) & 0x80) != 0) {
LABEL_113:
  }
    operator delete(v45.__r_.__value_.__l.__data_);
LABEL_99:
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  if (v48 < 0) {
    operator delete(__p[0]);
  }
  if (v50 < 0) {
    operator delete(v49[0]);
  }
}

void sub_1A43D0E40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  v34[1] = v35;
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  a16 = v34;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&a16);
  if (a28 < 0) {
    operator delete(a23);
  }
  if (a34 < 0) {
    operator delete(a29);
  }
  _Unwind_Resume(a1);
}

uint64_t NLHindiTransliterator::pruneLattice(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  int MaximumLayerSize = NLTransliteratorUtils::getMaximumLayerSize(a2);
  uint64_t v4 = *a3;
  uint64_t v5 = a3[1];
  if (v5 != *a3)
  {
    unint64_t v6 = 0;
    LODWORD(v7) = 1;
    while (1)
    {
      std::string::size_type v8 = (long long **)(v4 + 24 * v6);
      uint64_t v9 = *v8;
      if (v8[1] == *v8) {
        std::vector<NLExtendedString>::__throw_out_of_range[abi:ne180100]();
      }
      int v51 = v7;
      if (*((char *)v9 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&v53, *(const std::string::value_type **)v9, *((void *)v9 + 1));
        uint64_t v4 = *a3;
        uint64_t v5 = a3[1];
      }
      else
      {
        long long v10 = *v9;
        v53.__r_.__value_.__r.__words[2] = *((void *)v9 + 2);
        *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v10;
      }
      long long v11 = *(long long *)((char *)v9 + 24);
      char v55 = *((unsigned char *)v9 + 40);
      long long v54 = v11;
      if (0xAAAAAAAAAAAAAAABLL * ((v5 - v4) >> 3) <= v6) {
        goto LABEL_61;
      }
      unint64_t v12 = (uint64_t *)(v4 + 24 * v6);
      long long v13 = v12 + 1;
      unint64_t v14 = v12[1];
      uint64_t v15 = *v12;
      if (v14 != *v12) {
        break;
      }
LABEL_40:
      if (v15 == v14)
      {
        if (v14 >= *(void *)(v4 + 24 * v6 + 16))
        {
          uint64_t v34 = std::vector<NLExtendedString>::__push_back_slow_path<NLExtendedString const&>(v12, (long long *)&v53);
        }
        else
        {
          std::vector<NLExtendedString>::__construct_one_at_end[abi:ne180100]<NLExtendedString const&>((uint64_t)v12, (long long *)&v53);
          uint64_t v34 = v14 + 48;
        }
        *long long v13 = v34;
        uint64_t v4 = *a3;
        uint64_t v5 = a3[1];
      }
      if (0xAAAAAAAAAAAAAAABLL * ((v5 - v4) >> 3) <= v6) {
        goto LABEL_62;
      }
      uint64_t v35 = v4 + 24 * v6;
      long long v36 = *(uint64_t **)v35;
      uint64_t v37 = *(void *)(v35 + 8);
      uint64_t v38 = v37 - *(void *)v35;
      unint64_t v39 = 0xAAAAAAAAAAAAAAABLL * (v38 >> 4);
      if (v38 < 1)
      {
        std::string v40 = 0;
        uint64_t v42 = 0;
      }
      else
      {
        std::string v40 = (long long *)std::get_temporary_buffer[abi:ne180100]<NLExtendedString>(0xAAAAAAAAAAAAAAABLL * (v38 >> 4));
        uint64_t v42 = v41;
      }
      std::__stable_sort<std::_ClassicAlgPolicy,std::greater<NLExtendedString> &,std::__wrap_iter<NLExtendedString*>>(v36, v37, (uint64_t)&v52, v39, v40, v42);
      if (v40) {
        operator delete(v40);
      }
      if (0xAAAAAAAAAAAAAAABLL * ((a3[1] - *a3) >> 3) <= v6) {
        goto LABEL_62;
      }
      long long v43 = (uint64_t *)(*a3 + 24 * v6);
      int v44 = -1431655765 * ((unint64_t)(v43[1] - *v43) >> 4);
      if (MaximumLayerSize < v44) {
        int v44 = MaximumLayerSize;
      }
      std::vector<NLExtendedString>::resize(v43, v44);
      uint64_t v4 = *a3;
      uint64_t v5 = a3[1];
      unint64_t v45 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a3) >> 3);
      if (v45 <= v6) {
LABEL_62:
      }
        std::vector<NLExtendedString>::__throw_out_of_range[abi:ne180100]();
      uint64_t v46 = (uint64_t *)(v4 + 24 * v6);
      uint64_t v48 = *v46;
      uint64_t v47 = v46[1];
      if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v53.__r_.__value_.__l.__data_);
        uint64_t v4 = *a3;
        uint64_t v5 = a3[1];
        unint64_t v45 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a3) >> 3);
      }
      uint64_t v7 = -1431655765 * ((unint64_t)(v47 - v48) >> 4) * v51;
      if (v45 <= ++v6) {
        return v7;
      }
    }
    int v16 = 0;
    uint64_t v17 = 0;
    while (1)
    {
      NLAbstractOrthographyConvertor::~NLAbstractOrthographyConvertor((NLAbstractOrthographyConvertor *)(v15 + 48 * v17));
      if (*((char *)v18 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&v52, *(const std::string::value_type **)v18, *((void *)v18 + 1));
      }
      else
      {
        long long v19 = *v18;
        v52.__r_.__value_.__r.__words[2] = *((void *)v18 + 2);
        *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v19;
      }
      int64_t size = HIBYTE(v52.__r_.__value_.__r.__words[2]);
      char v21 = HIBYTE(v52.__r_.__value_.__r.__words[2]);
      if ((v52.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        unint64_t v22 = &v52;
      }
      else
      {
        int64_t size = v52.__r_.__value_.__l.__size_;
        unint64_t v22 = (std::string *)v52.__r_.__value_.__r.__words[0];
      }
      if (size >= 3)
      {
        long long v23 = (unsigned __int16 *)((char *)v22 + size);
        uint64_t v24 = v22;
        do
        {
          int v25 = (char *)memchr(v24, -32, size - 2);
          if (!v25) {
            break;
          }
          if (*(unsigned __int16 *)v25 == 42208 && v25[2] == 188)
          {
            if (v25 == (char *)v23 || v25 - (char *)v22 == -1) {
              break;
            }
            if (0xAAAAAAAAAAAAAAABLL * ((a3[1] - *a3) >> 3) <= v6) {
              std::vector<NLExtendedString>::__throw_out_of_range[abi:ne180100]();
            }
            std::string::size_type v27 = (void *)(*a3 + 24 * v6);
            uint64_t v28 = *v27 + 48 * v17;
            uint64_t v30 = (long long *)v27[1];
            std::string::size_type v29 = v27 + 1;
            std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<NLExtendedString *,NLExtendedString *,NLExtendedString *>((uint64_t)&v56, (long long *)(v28 + 48), v30, v28);
            uint64_t v32 = v31;
            for (uint64_t i = *v29; i != v32; i -= 48)
            {
              if (*(char *)(i - 25) < 0) {
                operator delete(*(void **)(i - 48));
              }
            }
            *std::string::size_type v29 = v32;
            --v16;
            if ((*((unsigned char *)&v52.__r_.__value_.__s + 23) & 0x80) == 0) {
              goto LABEL_35;
            }
            goto LABEL_34;
          }
          uint64_t v24 = (std::string *)(v25 + 1);
          int64_t size = (char *)v23 - (char *)v24;
        }
        while ((char *)v23 - (char *)v24 >= 3);
      }
      if (v21 < 0) {
LABEL_34:
      }
        operator delete(v52.__r_.__value_.__l.__data_);
LABEL_35:
      uint64_t v4 = *a3;
      uint64_t v5 = a3[1];
      if (0xAAAAAAAAAAAAAAABLL * ((v5 - *a3) >> 3) <= v6) {
        break;
      }
      ++v16;
      unint64_t v12 = (uint64_t *)(v4 + 24 * v6);
      long long v13 = v12 + 1;
      unint64_t v14 = v12[1];
      uint64_t v17 = v16;
      uint64_t v15 = *v12;
      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v14 - *v12) >> 4) <= v16) {
        goto LABEL_40;
      }
    }
LABEL_61:
    std::vector<NLExtendedString>::__throw_out_of_range[abi:ne180100]();
  }
  return 1;
}

void sub_1A43D12E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NLHindiTransliterator::addSpecialCandidates(uint64_t a1, uint64_t a2)
{
  int v2 = *(unsigned __int8 *)(a2 + 23);
  if ((*(char *)(a2 + 23) & 0x80000000) == 0)
  {
    if (v2 != 2)
    {
      uint64_t result = 0;
      goto LABEL_20;
    }
    uint64_t v3 = (_WORD *)a2;
    if (*(_WORD *)a2 == 26994)
    {
      uint64_t v4 = (_WORD *)a2;
      goto LABEL_17;
    }
LABEL_7:
    if (*v3 != 30066)
    {
      uint64_t result = 0;
      if ((v2 & 0x80) != 0) {
        goto LABEL_22;
      }
LABEL_20:
      unint64_t v6 = (_WORD *)a2;
      if (v2 != 2) {
        return result;
      }
      goto LABEL_24;
    }
LABEL_12:
    if ((v2 & 0x80) != 0)
    {
      if (*(void *)(a2 + 8) != 2) {
        goto LABEL_18;
      }
      uint64_t v4 = *(_WORD **)a2;
    }
    else
    {
      uint64_t v4 = (_WORD *)a2;
      if (v2 != 2) {
        goto LABEL_18;
      }
    }
LABEL_17:
    if (*v4 == 26994) {
      operator new();
    }
LABEL_18:
    operator new();
  }
  if (*(void *)(a2 + 8) == 2)
  {
    uint64_t v3 = *(_WORD **)a2;
    if (**(_WORD **)a2 == 26994) {
      goto LABEL_12;
    }
    goto LABEL_7;
  }
  uint64_t result = 0;
LABEL_22:
  if (*(void *)(a2 + 8) != 2) {
    return result;
  }
  unint64_t v6 = *(_WORD **)a2;
LABEL_24:
  if (*v6 == 28015) {
    operator new();
  }
  return result;
}

void sub_1A43D1D90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16)
{
  MEMORY[0x1A625B130](v16, 0x1012C40B0087DDBLL);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

BOOL NLHindiTransliterator::shouldHandleNasalizationException(uint64_t a1, uint64_t a2, uint64_t a3)
{
  char v5 = *(unsigned char *)(a2 + 23);
  if (v5 >= 0) {
    uint64_t v6 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v6 = *(void *)(a2 + 8);
  }
  if (v5 >= 0) {
    uint64_t v7 = a2;
  }
  else {
    uint64_t v7 = *(void *)a2;
  }
  std::string::size_type v8 = (char *)(v7 + v6);
  if (v6 <= 1)
  {
LABEL_48:
    if (v6 >= 1)
    {
LABEL_49:
      size_t v28 = v6;
      std::string::size_type v29 = (void *)v7;
      do
      {
        uint64_t v30 = (char *)memchr(v29, 110, v28);
        if (!v30) {
          break;
        }
        if (*v30 == 110)
        {
          if (v30 == v8 || &v30[-v7] == (char *)-1) {
            return 0;
          }
          if (v6 >= 3)
          {
            uint64_t v31 = v6;
            uint64_t v32 = (void *)v7;
            do
            {
              long long v33 = (char *)memchr(v32, 110, v31 - 2);
              if (!v33) {
                break;
              }
              if (*(_WORD *)v33 == 26734 && v33[2] == 101)
              {
                if (v33 != v8 && &v33[-v7] != (char *)-1) {
                  return 0;
                }
                break;
              }
              uint64_t v32 = v33 + 1;
              uint64_t v31 = v8 - (unsigned char *)v32;
            }
            while (v8 - (unsigned char *)v32 >= 3);
            uint64_t v37 = v6;
            uint64_t v38 = (void *)v7;
            do
            {
              unint64_t v39 = (char *)memchr(v38, 110, v37 - 2);
              if (!v39) {
                break;
              }
              if (*(_WORD *)v39 == 26734 && v39[2] == 111)
              {
                if (v39 != v8 && &v39[-v7] != (char *)-1) {
                  return 0;
                }
                break;
              }
              uint64_t v38 = v39 + 1;
              uint64_t v37 = v8 - (unsigned char *)v38;
            }
            while (v8 - (unsigned char *)v38 >= 3);
            uint64_t v41 = (void *)v7;
            do
            {
              uint64_t v42 = (char *)memchr(v41, 110, v6 - 2);
              if (!v42) {
                break;
              }
              if (*(_WORD *)v42 == 24942 && v42[2] == 104)
              {
                if (v42 != v8 && &v42[-v7] != (char *)-1) {
                  return 0;
                }
                break;
              }
              uint64_t v41 = v42 + 1;
              uint64_t v6 = v8 - (unsigned char *)v41;
            }
            while (v8 - (unsigned char *)v41 >= 3);
          }
          return std::string::find[abi:ne180100]((uint64_t *)a2, "ain", 0) == -1
              && std::string::find[abi:ne180100]((uint64_t *)a2, "nu", 0) == -1
              && (std::string::find[abi:ne180100]((uint64_t *)a3, "", 0) == -1
               || std::string::find[abi:ne180100]((uint64_t *)a3, "", 0) == -1
               || std::string::find[abi:ne180100]((uint64_t *)a3, "", 0) == -1
               || std::string::find[abi:ne180100]((uint64_t *)a3, "", 0) == -1);
        }
        std::string::size_type v29 = v30 + 1;
        size_t v28 = v8 - (unsigned char *)v29;
      }
      while (v8 - (unsigned char *)v29 >= 1);
    }
    return 0;
  }
  else
  {
    uint64_t v9 = v6;
    long long v10 = (void *)v7;
    while (1)
    {
      long long v11 = memchr(v10, 110, v9 - 1);
      if (!v11) {
        goto LABEL_44;
      }
      if (*v11 == 24942) {
        break;
      }
      long long v10 = (char *)v11 + 1;
      uint64_t v9 = v8 - (unsigned char *)v10;
      if (v8 - (unsigned char *)v10 < 2) {
        goto LABEL_44;
      }
    }
    if (v11 == (_WORD *)v8 || (_WORD *)((char *)v11 - v7) == (_WORD *)-1)
    {
LABEL_44:
      uint64_t v25 = v6;
      long long v26 = (void *)v7;
      while (1)
      {
        std::string::size_type v27 = memchr(v26, 110, v25 - 1);
        if (!v27) {
          goto LABEL_48;
        }
        if (*v27 == 24942)
        {
          if ((_WORD *)((char *)v27 - v7) != (_WORD *)-1 && v27 != (_WORD *)v8 || v6 < 1) {
            return 0;
          }
          goto LABEL_49;
        }
        long long v26 = (char *)v27 + 1;
        uint64_t v25 = v8 - (unsigned char *)v26;
        if (v8 - (unsigned char *)v26 <= 1) {
          goto LABEL_48;
        }
      }
    }
    char v12 = *(unsigned char *)(a3 + 23);
    if (v12 >= 0) {
      uint64_t v13 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      uint64_t v13 = *(void *)(a3 + 8);
    }
    if (v12 >= 0) {
      uint64_t v14 = a3;
    }
    else {
      uint64_t v14 = *(void *)a3;
    }
    if (v13 >= 3)
    {
      uint64_t v15 = (unsigned __int16 *)(v14 + v13);
      uint64_t v16 = v13;
      uint64_t v17 = (void *)v14;
      do
      {
        unsigned __int8 v18 = (unsigned __int16 *)memchr(v17, -32, v16 - 2);
        if (!v18) {
          break;
        }
        if (*v18 == 42208 && *((unsigned __int8 *)v18 + 2) == 168)
        {
          if (v18 != v15 && (unsigned __int16 *)((char *)v18 - v14) != (unsigned __int16 *)-1) {
            goto LABEL_44;
          }
          break;
        }
        uint64_t v17 = (char *)v18 + 1;
        uint64_t v16 = (char *)v15 - (unsigned char *)v17;
      }
      while ((char *)v15 - (unsigned char *)v17 >= 3);
      char v21 = (void *)v14;
      while (1)
      {
        unint64_t v22 = (unsigned __int16 *)memchr(v21, -32, v13 - 2);
        if (!v22) {
          break;
        }
        long long v23 = v22;
        if (*v22 == 42208 && *((unsigned __int8 *)v22 + 2) == 163)
        {
          BOOL result = 1;
          if (v23 == v15 || (unsigned __int16 *)((char *)v23 - v14) == (unsigned __int16 *)-1) {
            return result;
          }
          goto LABEL_44;
        }
        char v21 = (char *)v22 + 1;
        uint64_t v13 = (char *)v15 - (unsigned char *)v21;
        BOOL result = 1;
        if ((char *)v15 - (unsigned char *)v21 < 3) {
          return result;
        }
      }
    }
    return 1;
  }
}

void *NLHindiTransliterator::getHalantCharacter@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "");
}

void *NLHindiTransliterator::getFirstLetter@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "");
}

void *NLHindiTransliterator::getLastLetter@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "");
}

void *NLHindiTransliterator::getAnyConsonant@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "");
}

BOOL NLHindiTransliterator::isSpecialCharSeq(int a1, int a2, char *__s, int a4)
{
  if (a2 != 2) {
    return 0;
  }
  uint64_t v5 = a4;
  size_t v6 = a4 + 1;
  if (strlen(__s) <= v6 || __s[v5] != 114) {
    return 0;
  }
  int v7 = __s[v6];
  return v7 == 105 || v7 == 117;
}

uint64_t NLHindiTransliterator::shouldHandleExaggeration(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 *)(a2 + 23);
  if ((v2 & 0x80u) == 0) {
    uint64_t v3 = (char *)a2;
  }
  else {
    uint64_t v3 = *(char **)a2;
  }
  if ((v2 & 0x80u) != 0) {
    uint64_t v2 = *(void *)(a2 + 8);
  }
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  char v10 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  char v13 = 0;
  char v14 = 0;
  uint64_t v15 = 0;
  *(_OWORD *)std::string __p = 0u;
  memset(v7, 0, sizeof(v7));
  uint64_t v4 = std::regex_match[abi:ne180100]<std::__wrap_iter<char const*>,std::allocator<std::sub_match<std::__wrap_iter<char const*>>>,char,std::regex_traits<char>>(v3, &v3[v2], (uint64_t)__p, a1 + 440, 0);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  return v4;
}

void sub_1A43D23F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void NLHindiTransliterator::~NLHindiTransliterator(std::locale *this)
{
  NLHindiTransliterator::~NLHindiTransliterator(this);

  JUMPOUT(0x1A625B130);
}

{
  std::locale *v2;
  std::__shared_weak_count *locale;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;
  uint64_t vars8;

  this->__locale_ = (std::locale::__imp *)&unk_1EF7CCD98;
  uint64_t v2 = this + 63;
  locale = (std::__shared_weak_count *)this[69].__locale_;
  if (locale) {
    std::__shared_weak_count::__release_shared[abi:ne180100](locale);
  }
  std::locale::~locale(v2);
  uint64_t v4 = (std::__shared_weak_count *)this[61].__locale_;
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  std::locale::~locale(this + 55);
  uint64_t v5 = (std::__shared_weak_count *)this[53].__locale_;
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  std::locale::~locale(this + 47);
  size_t v6 = (std::__shared_weak_count *)this[45].__locale_;
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
  std::locale::~locale(this + 39);
  int v7 = (std::__shared_weak_count *)this[37].__locale_;
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  std::locale::~locale(this + 31);
  uint64_t v8 = (std::__shared_weak_count *)this[29].__locale_;
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  }
  std::locale::~locale(this + 23);

  NLGenericTransliterator::~NLGenericTransliterator((NLGenericTransliterator *)this);
}

uint64_t std::regex_match[abi:ne180100]<std::__wrap_iter<char const*>,std::allocator<std::sub_match<std::__wrap_iter<char const*>>>,char,std::regex_traits<char>>(char *__f, char *__l, uint64_t a3, uint64_t a4, int a5)
{
  __int16 v5 = a5;
  memset(&__p.__prefix_, 0, 17);
  memset(&__p.__suffix_, 0, 17);
  __p.__ready_ = 0;
  __p.__position_start_ = 0;
  memset(&__p, 0, 41);
  int v9 = std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>(a4, __f, __l, &__p, a5 | 0x1040u);
  std::match_results<std::__wrap_iter<char const*>>::__assign[abi:ne180100]<char const*,std::allocator<std::sub_match<char const*>>>((std::vector<std::ssub_match> *)a3, (uint64_t)__f, (std::sub_match<std::__wrap_iter<const char *>> *)__l, (uint64_t *)&__p, (v5 & 0x800) != 0);
  if (__p.__matches_.__begin_)
  {
    __p.__matches_.__end_ = __p.__matches_.__begin_;
    operator delete(__p.__matches_.__begin_);
  }
  if (!v9) {
    return 0;
  }
  if (!*(unsigned char *)(a3 + 88)) {
    return 1;
  }
  uint64_t result = 0;
  *(void *)(a3 + 8) = *(void *)a3;
  return result;
}

void sub_1A43D2600(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void NLArabicTransliterator::NLArabicTransliterator(NLArabicTransliterator *this, const __CFDictionary *a2)
{
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_DWORD *)this + 28) = 1065353216;
  *(_OWORD *)((char *)this + 12nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = xmmword_1A43F7930;
  *((_DWORD *)this + 34) = 2;
  *((void *)this + 18) = 0xC03E000000000000;
  *((void *)this + 19) = 0x3E800000005;
  *((_DWORD *)this + 4nlp::CFScopedPtr<__CFSet *>::reset(this + 1, 0) = 3;
  *((void *)this + 21) = 0x3FF3333333333333;
  *((void *)this + 22) = 0x1F40000000ALL;
  *(void *)this = &unk_1EF7CCF90;
  std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((std::regex_traits<char> *)((char *)this + 184), "[\",,;.\"'?!:{}<>*\\-]",
    0);
}

void sub_1A43D2968(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale *a10, std::locale *a11, std::locale *a12, std::locale *a13)
{
  MEMORY[0x1A625B130](v15, 0xE1C40D30581F4);
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex(v14);
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex(v20);
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex(v19);
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex(v18);
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex(v17);
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex(v16);
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex(a10);
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex(a11);
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex(a12);
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex(a13);
  NLGenericTransliterator::~NLGenericTransliterator(v13);
  _Unwind_Resume(a1);
}

void *NLArabicTransliterator::getTargetDigit@<X0>(unsigned int a1@<W1>, void *a2@<X8>)
{
  if (a1 > 9) {
    uint64_t v3 = "";
  }
  else {
    uint64_t v3 = off_1E5B36E40[a1];
  }
  return std::string::basic_string[abi:ne180100]<0>(a2, v3);
}

void NLArabicTransliterator::addDynamicMapping(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v37 = 0;
  uint64_t v38 = 0;
  char v39 = 0;
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  char v42 = 0;
  char v43 = 0;
  uint64_t v44 = 0;
  memset(v36, 0, 41);
  uint64_t v4 = a1 + 568;
  memset(&v45.__prefix_, 0, 17);
  memset(&v45.__suffix_, 0, 17);
  v45.__ready_ = 0;
  v45.__position_start_ = 0;
  memset(&v45, 0, 32);
  uint64_t v5 = *(unsigned __int8 *)(a2 + 23);
  uint64_t v6 = *(void *)(a2 + 8);
  if ((v5 & 0x80u) != 0)
  {
    a2 = *(void *)a2;
    uint64_t v5 = v6;
  }
  *(std::pair<const char *, const char *> *)((char *)&v45.__unmatched_.std::pair<const char *, const char *> + 1) = 0uLL;
  int v7 = std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>(v4, (char *)a2, (char *)(a2 + v5), &v45, 0);
  uint64_t v8 = *(unsigned __int8 *)(v2 + 23);
  if ((v8 & 0x80u) == 0) {
    uint64_t v9 = v2;
  }
  else {
    uint64_t v9 = *(void *)v2;
  }
  if ((v8 & 0x80u) != 0) {
    uint64_t v8 = *(void *)(v2 + 8);
  }
  std::match_results<std::__wrap_iter<char const*>>::__assign[abi:ne180100]<char const*,std::allocator<std::sub_match<char const*>>>(v36, v9, (std::sub_match<std::__wrap_iter<const char *>> *)(v9 + v8), (uint64_t *)&v45, 0);
  if (v45.__matches_.__begin_)
  {
    v45.__matches_.__end_ = v45.__matches_.__begin_;
    operator delete(v45.__matches_.__begin_);
  }
  if (v7)
  {
    std::string::basic_string[abi:ne180100]<0>(__p, "");
    NLExtendedString::NLExtendedString((std::string *)&v45, (long long *)__p, 2, 2, 0.1);
    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p[0].__r_.__value_.__l.__data_);
    }
    uint64_t v10 = *(void *)(a1 + 8);
    std::string::basic_string[abi:ne180100]<0>(__p, "n");
    (*(void (**)(uint64_t, std::string *, std::match_results<const char *> *))(*(void *)v10 + 16))(v10, __p, &v45);
    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p[0].__r_.__value_.__l.__data_);
    }
    std::string::basic_string[abi:ne180100]<0>(v33, "");
    NLExtendedString::NLExtendedString(__p, (long long *)v33, 3, 2, 0.1);
    if (v34 < 0) {
      operator delete(v33[0]);
    }
    uint64_t v11 = *(void *)(a1 + 8);
    std::string::basic_string[abi:ne180100]<0>(v33, "n");
    (*(void (**)(uint64_t, void **, std::string *))(*(void *)v11 + 16))(v11, v33, __p);
    if (v34 < 0) {
      operator delete(v33[0]);
    }
    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p[0].__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v45.__matches_.__end_cap_.__value_) < 0) {
      operator delete(v45.__matches_.__begin_);
    }
  }
  memset(&v45.__prefix_, 0, 17);
  memset(&v45.__suffix_, 0, 17);
  v45.__ready_ = 0;
  v45.__position_start_ = 0;
  memset(&v45, 0, 41);
  uint64_t v12 = *(unsigned __int8 *)(v2 + 23);
  if ((v12 & 0x80u) == 0) {
    char v13 = (char *)v2;
  }
  else {
    char v13 = *(char **)v2;
  }
  if ((v12 & 0x80u) != 0) {
    uint64_t v12 = *(void *)(v2 + 8);
  }
  int v14 = std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>(a1 + 632, v13, &v13[v12], &v45, 0);
  uint64_t v15 = *(unsigned __int8 *)(v2 + 23);
  if ((v15 & 0x80u) == 0) {
    uint64_t v16 = v2;
  }
  else {
    uint64_t v16 = *(void *)v2;
  }
  if ((v15 & 0x80u) != 0) {
    uint64_t v15 = *(void *)(v2 + 8);
  }
  std::match_results<std::__wrap_iter<char const*>>::__assign[abi:ne180100]<char const*,std::allocator<std::sub_match<char const*>>>(v36, v16, (std::sub_match<std::__wrap_iter<const char *>> *)(v16 + v15), (uint64_t *)&v45, 0);
  if (v45.__matches_.__begin_)
  {
    v45.__matches_.__end_ = v45.__matches_.__begin_;
    operator delete(v45.__matches_.__begin_);
  }
  if (v14)
  {
    std::string::basic_string[abi:ne180100]<0>(__p, "");
    NLExtendedString::NLExtendedString((std::string *)&v45, (long long *)__p, 2, 2, 0.1);
    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p[0].__r_.__value_.__l.__data_);
    }
    uint64_t v17 = *(void *)(a1 + 8);
    std::string::basic_string[abi:ne180100]<0>(__p, "h");
    (*(void (**)(uint64_t, std::string *, std::match_results<const char *> *))(*(void *)v17 + 16))(v17, __p, &v45);
    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p[0].__r_.__value_.__l.__data_);
    }
    std::string::basic_string[abi:ne180100]<0>(v33, "");
    NLExtendedString::NLExtendedString(__p, (long long *)v33, 3, 2, 0.1);
    if (v34 < 0) {
      operator delete(v33[0]);
    }
    uint64_t v18 = *(void *)(a1 + 8);
    std::string::basic_string[abi:ne180100]<0>(v33, "h");
    (*(void (**)(uint64_t, void **, std::string *))(*(void *)v18 + 16))(v18, v33, __p);
    if (v34 < 0) {
      operator delete(v33[0]);
    }
    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p[0].__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v45.__matches_.__end_cap_.__value_) < 0) {
      operator delete(v45.__matches_.__begin_);
    }
  }
  memset(&v45.__prefix_, 0, 17);
  memset(&v45.__suffix_, 0, 17);
  v45.__ready_ = 0;
  v45.__position_start_ = 0;
  memset(&v45, 0, 41);
  uint64_t v19 = *(unsigned __int8 *)(v2 + 23);
  if ((v19 & 0x80u) == 0) {
    CFStringRef v20 = (char *)v2;
  }
  else {
    CFStringRef v20 = *(char **)v2;
  }
  if ((v19 & 0x80u) != 0) {
    uint64_t v19 = *(void *)(v2 + 8);
  }
  int v21 = std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>(a1 + 696, v20, &v20[v19], &v45, 0);
  uint64_t v22 = *(unsigned __int8 *)(v2 + 23);
  if ((v22 & 0x80u) == 0) {
    uint64_t v23 = v2;
  }
  else {
    uint64_t v23 = *(void *)v2;
  }
  if ((v22 & 0x80u) != 0) {
    uint64_t v22 = *(void *)(v2 + 8);
  }
  std::match_results<std::__wrap_iter<char const*>>::__assign[abi:ne180100]<char const*,std::allocator<std::sub_match<char const*>>>(v36, v23, (std::sub_match<std::__wrap_iter<const char *>> *)(v23 + v22), (uint64_t *)&v45, 0);
  if (v45.__matches_.__begin_)
  {
    v45.__matches_.__end_ = v45.__matches_.__begin_;
    operator delete(v45.__matches_.__begin_);
  }
  if (v21)
  {
    std::string::basic_string[abi:ne180100]<0>(__p, "");
    NLExtendedString::NLExtendedString((std::string *)&v45, (long long *)__p, 2, 2, 0.1);
    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p[0].__r_.__value_.__l.__data_);
    }
    uint64_t v24 = *(void *)(a1 + 8);
    std::string::basic_string[abi:ne180100]<0>(__p, "w");
    (*(void (**)(uint64_t, std::string *, std::match_results<const char *> *))(*(void *)v24 + 16))(v24, __p, &v45);
    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p[0].__r_.__value_.__l.__data_);
    }
    std::string::basic_string[abi:ne180100]<0>(v33, "");
    NLExtendedString::NLExtendedString(__p, (long long *)v33, 3, 2, 0.1);
    if (v34 < 0) {
      operator delete(v33[0]);
    }
    uint64_t v25 = *(void *)(a1 + 8);
    std::string::basic_string[abi:ne180100]<0>(v33, "w");
    (*(void (**)(uint64_t, void **, std::string *))(*(void *)v25 + 16))(v25, v33, __p);
    if (v34 < 0) {
      operator delete(v33[0]);
    }
    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p[0].__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v45.__matches_.__end_cap_.__value_) < 0) {
      operator delete(v45.__matches_.__begin_);
    }
  }
  memset(&v45.__prefix_, 0, 17);
  memset(&v45.__suffix_, 0, 17);
  v45.__ready_ = 0;
  v45.__position_start_ = 0;
  memset(&v45, 0, 41);
  uint64_t v26 = *(unsigned __int8 *)(v2 + 23);
  if ((v26 & 0x80u) == 0) {
    std::string::size_type v27 = (char *)v2;
  }
  else {
    std::string::size_type v27 = *(char **)v2;
  }
  if ((v26 & 0x80u) != 0) {
    uint64_t v26 = *(void *)(v2 + 8);
  }
  int v28 = std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>(a1 + 760, v27, &v27[v26], &v45, 0);
  uint64_t v29 = *(unsigned __int8 *)(v2 + 23);
  if ((v29 & 0x80u) == 0) {
    uint64_t v30 = v2;
  }
  else {
    uint64_t v30 = *(void *)v2;
  }
  if ((v29 & 0x80u) != 0) {
    uint64_t v29 = *(void *)(v2 + 8);
  }
  std::match_results<std::__wrap_iter<char const*>>::__assign[abi:ne180100]<char const*,std::allocator<std::sub_match<char const*>>>(v36, v30, (std::sub_match<std::__wrap_iter<const char *>> *)(v30 + v29), (uint64_t *)&v45, 0);
  if (v45.__matches_.__begin_)
  {
    v45.__matches_.__end_ = v45.__matches_.__begin_;
    operator delete(v45.__matches_.__begin_);
  }
  if (v28)
  {
    std::string::basic_string[abi:ne180100]<0>(__p, "");
    NLExtendedString::NLExtendedString((std::string *)&v45, (long long *)__p, 3, 2, 0.1);
    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p[0].__r_.__value_.__l.__data_);
    }
    uint64_t v31 = *(void *)(a1 + 8);
    std::string::basic_string[abi:ne180100]<0>(__p, "l");
    (*(void (**)(uint64_t, std::string *, std::match_results<const char *> *))(*(void *)v31 + 16))(v31, __p, &v45);
    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p[0].__r_.__value_.__l.__data_);
    }
    std::string::basic_string[abi:ne180100]<0>(v33, "");
    NLExtendedString::NLExtendedString(__p, (long long *)v33, 3, 2, 0.1);
    if (v34 < 0) {
      operator delete(v33[0]);
    }
    uint64_t v32 = *(void *)(a1 + 8);
    std::string::basic_string[abi:ne180100]<0>(v33, "h");
    (*(void (**)(uint64_t, void **, std::string *))(*(void *)v32 + 16))(v32, v33, __p);
    if (v34 < 0) {
      operator delete(v33[0]);
    }
    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p[0].__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v45.__matches_.__end_cap_.__value_) < 0) {
      operator delete(v45.__matches_.__begin_);
    }
  }
  if (v36[0].__begin_)
  {
    v36[0].__end_ = v36[0].__begin_;
    operator delete(v36[0].__begin_);
  }
}

void sub_1A43D326C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (*(char *)(v26 - 153) < 0) {
    operator delete(*(void **)(v26 - 176));
  }
  if (a25) {
    operator delete(a25);
  }
  _Unwind_Resume(exception_object);
}

BOOL NLArabicTransliterator::isSpecialCharSeq(int a1, int a2, char *__s, int a4)
{
  if (a2 != 1) {
    return 0;
  }
  uint64_t v5 = a4;
  size_t v6 = a4 + 1;
  if (strlen(__s) <= v6) {
    return 0;
  }
  BOOL result = 0;
  switch(((__s[v5] - 97) >> 1) | ((__s[v5] - 97) << 7))
  {
    case 0:
      if ((__s[v6] - 104) >= 0x10u) {
        return 0;
      }
      return (0x8041u >> (__s[v6] - 104)) & 1;
    case 2:
      BOOL v8 = (__s[v6] & 0xFB) == 104;
      goto LABEL_12;
    case 4:
      if (__s[v6] != 110) {
        return 0;
      }
      goto LABEL_7;
    case 7:
      if (__s[v6] != 119) {
        return 0;
      }
LABEL_7:
      BOOL result = 1;
      break;
    case 10:
      BOOL v8 = __s[v6] == 110;
LABEL_12:
      BOOL result = v8;
      break;
    default:
      return result;
  }
  return result;
}

void NLArabicTransliterator::addSpecialElements(void **a1, char *a2, int *a3, unsigned int *a4, unsigned int *a5, uint64_t *a6)
{
  std::string::basic_string[abi:ne180100]<0>(&__str, a2);
  std::string::basic_string(&v16, &__str, *a3, 2uLL, (std::allocator<char> *)&p_str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  (*(void (**)(std::string *__return_ptr))(*a1[1] + 32))(&__str);
  ((void (*)(void **, std::string *, void, void, char *, uint64_t *))(*a1)[18])(a1, &__str, *a4, *a5, a2, a6);
  uint64_t v12 = *a6;
  if (a6[1] != *a6)
  {
    uint64_t v13 = 0;
    unint64_t v14 = 0;
    do
    {
      NLExtendedString::setJoin(v12 + v13, 1);
      ++v14;
      uint64_t v12 = *a6;
      v13 += 48;
    }
    while (0xAAAAAAAAAAAAAAABLL * ((a6[1] - *a6) >> 4) > v14);
  }
  p_str = &__str;
  std::vector<NLExtendedString>::__destroy_vector::operator()[abi:ne180100]((void ***)&p_str);
  if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v16.__r_.__value_.__l.__data_);
  }
}

void sub_1A43D35F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t *a22)
{
  a22 = &a10;
  std::vector<NLExtendedString>::__destroy_vector::operator()[abi:ne180100]((void ***)&a22);
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void NLArabicTransliterator::~NLArabicTransliterator(std::locale *this)
{
  NLArabicTransliterator::~NLArabicTransliterator(this);

  JUMPOUT(0x1A625B130);
}

{
  std::locale *v2;
  std::__shared_weak_count *locale;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;
  std::__shared_weak_count *v12;
  uint64_t vars8;

  this->__locale_ = (std::locale::__imp *)&unk_1EF7CCF90;
  uint64_t v2 = this + 95;
  locale = (std::__shared_weak_count *)this[101].__locale_;
  if (locale) {
    std::__shared_weak_count::__release_shared[abi:ne180100](locale);
  }
  std::locale::~locale(v2);
  uint64_t v4 = (std::__shared_weak_count *)this[93].__locale_;
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  std::locale::~locale(this + 87);
  uint64_t v5 = (std::__shared_weak_count *)this[85].__locale_;
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  std::locale::~locale(this + 79);
  size_t v6 = (std::__shared_weak_count *)this[77].__locale_;
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
  std::locale::~locale(this + 71);
  int v7 = (std::__shared_weak_count *)this[69].__locale_;
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  std::locale::~locale(this + 63);
  BOOL v8 = (std::__shared_weak_count *)this[61].__locale_;
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  }
  std::locale::~locale(this + 55);
  uint64_t v9 = (std::__shared_weak_count *)this[53].__locale_;
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v9);
  }
  std::locale::~locale(this + 47);
  uint64_t v10 = (std::__shared_weak_count *)this[45].__locale_;
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
  std::locale::~locale(this + 39);
  uint64_t v11 = (std::__shared_weak_count *)this[37].__locale_;
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v11);
  }
  std::locale::~locale(this + 31);
  uint64_t v12 = (std::__shared_weak_count *)this[29].__locale_;
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v12);
  }
  std::locale::~locale(this + 23);

  NLGenericTransliterator::~NLGenericTransliterator((NLGenericTransliterator *)this);
}

void NLUrduCharLanguageModeler::NLUrduCharLanguageModeler(NLUrduCharLanguageModeler *this, CFDictionaryRef theDict)
{
  *((void *)this + 1) = 0;
  uint64_t v2 = (uint64_t *)((char *)this + 8);
  *(void *)this = &unk_1EF7CD4B8;
  *((void *)this + 2) = 0;
  if (theDict) {
    MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(0, 0, theDict);
  }
  else {
    MutableCFDictionaryRef Copy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
  uint64_t v4 = MutableCopy;
  CFDictionarySetValue(MutableCopy, (const void *)*MEMORY[0x1E4F723C8], @"ur");
  BundleWithIdentifier = CFBundleGetBundleWithIdentifier(@"com.apple.NLP");
  if (v4)
  {
    if (BundleWithIdentifier)
    {
      BundleWithIdentifier = CFBundleCopyResourcesDirectoryURL(BundleWithIdentifier);
      size_t v6 = BundleWithIdentifier;
      if (BundleWithIdentifier)
      {
        CFDictionarySetValue(v4, (const void *)*MEMORY[0x1E4F72380], BundleWithIdentifier);
        uint64_t *v2 = LMLanguageModelCreate();
        CFRelease(v6);
      }
    }
  }
  if (!*v2)
  {
    uint64_t v7 = NL::CFLogger::sharedInstance(BundleWithIdentifier);
    (*(void (**)(uint64_t, uint64_t, const char *))(*(void *)v7 + 16))(v7, 3, "Could not locate Urdu character language model");
  }
  if (v4) {
    CFRelease(v4);
  }
}

void sub_1A43D38E8(_Unwind_Exception *a1)
{
  NLAbstractLanguageModeler::~NLAbstractLanguageModeler(v1);
  _Unwind_Resume(a1);
}

double NLUrduCharLanguageModeler::logProbability(uint64_t a1)
{
  if (!*(void *)(a1 + 8)) {
    return -INFINITY;
  }
  LMLanguageModelJointProbability();
  return result;
}

double NLUrduCharLanguageModeler::logProbability(uint64_t a1, uint64_t *a2)
{
  stringToUTF32Characters(a2, (int **)__p);
  if (*(void *)(a1 + 8))
  {
    LMLanguageModelJointProbability();
    double v4 = v3;
  }
  else
  {
    double v4 = -INFINITY;
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  return v4;
}

void sub_1A43D39A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void NLUrduCharLanguageModeler::~NLUrduCharLanguageModeler(NLUrduCharLanguageModeler *this)
{
  NLAbstractLanguageModeler::~NLAbstractLanguageModeler(this);

  JUMPOUT(0x1A625B130);
}

void NL::NumericConverter::~NumericConverter(NL::NumericConverter *this)
{
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 1);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void *NL::NumericConverter::locale@<X0>(NL::NumericConverter *this@<X0>, void *a2@<X8>)
{
  CFLocaleRef v3 = *(const __CFLocale **)(*(void *)this + 8);
  if (v3)
  {
    CFStringRef Value = (const __CFString *)CFLocaleGetValue(v3, (CFLocaleKey)*MEMORY[0x1E4F1D218]);
    return getUTF8StringFromCFString(Value, a2);
  }
  else
  {
    return std::string::basic_string[abi:ne180100]<0>(a2, "en");
  }
}

void NL::NumericConverter::numericValueForTypeWithValues(NL::ParserContext **this@<X0>, const __CFString *a2@<X1>, CFDictionaryRef theDict@<X2>, void *a4@<X8>)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (!a2 || !theDict)
  {
    *a4 = 0;
    a4[1] = 0;
    return;
  }
  CFTypeRef v19 = 0;
  if (CFDictionaryContainsKey(theDict, @"DIGITS"))
  {
    BOOL v8 = @"DIGITS";
  }
  else if (CFDictionaryContainsKey(theDict, @"NUMBERS"))
  {
    if (NL::ParserContext::languageIsCJ(*this))
    {
      CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, @"SPELLED");
      CFStringRef v10 = copyTranslatedRomanNumberFromChineseNumberString(Value);
      CFTypeRef v19 = v10;
      if (v10) {
        goto LABEL_8;
      }
      goto LABEL_6;
    }
    BOOL v8 = @"NUMBERS";
  }
  else
  {
    if (!CFDictionaryContainsKey(theDict, @"DECIMAL"))
    {
      CFStringRef v10 = 0;
      goto LABEL_8;
    }
    BOOL v8 = @"DECIMAL";
  }
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, v8);
  CFStringRef v10 = 0;
LABEL_6:
  if (Value)
  {
    CFStringRef v10 = (const __CFString *)CFRetain(Value);
    CFTypeRef v19 = v10;
  }
LABEL_8:
  MutableCFDictionaryRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, a2);
  CFTypeRef cf = MutableCopy;
  if (MutableCopy)
  {
    v23.CFIndex length = CFStringGetLength(a2);
    v23.CFIndex location = 0;
    CFStringFindAndReplace(MutableCopy, @"Value", @"Unit", v23, 0);
    if (!CFDictionaryContainsKey(theDict, MutableCopy)) {
      goto LABEL_19;
    }
    CFDictionaryRef v12 = (const __CFDictionary *)CFDictionaryGetValue(theDict, MutableCopy);
    CFDictionaryRef v13 = v12;
    if (!v12)
    {
      *a4 = 0;
      a4[1] = 0;
LABEL_30:
      if (cf) {
        CFRelease(cf);
      }
      goto LABEL_32;
    }
    if (CFDictionaryGetCount(v12) == 1)
    {
      keys[0] = 0;
      CFDictionaryGetKeysAndValues(v13, (const void **)keys, 0);
      CFStringRef v14 = (const __CFString *)keys[0];
    }
    else
    {
LABEL_19:
      CFStringRef v14 = 0;
    }
    uint64_t v15 = 0;
    while (!CFStringHasPrefix(a2, NL::NumericConverter::numericValueForTypeWithValues(__CFString const*,__CFDictionary const*)const::intTypes[v15]))
    {
      if (++v15 == 5)
      {
        getUTF8StringFromCFString(v14, keys);
        getUTF8StringFromCFString(v10, __p);
        NL::NumericConverter::numericDoubleForType((NL::NumericConverter *)this, (uint64_t)keys, a4);
        goto LABEL_25;
      }
    }
    getUTF8StringFromCFString(v14, keys);
    getUTF8StringFromCFString(v10, __p);
    NL::NumericConverter::numericIntForType((uint64_t)__p, a4);
LABEL_25:
    if (v17 < 0) {
      operator delete(__p[0]);
    }
    if (v21 < 0) {
      operator delete(keys[0]);
    }
    goto LABEL_30;
  }
  *a4 = 0;
  a4[1] = 0;
LABEL_32:
  if (v19) {
    CFRelease(v19);
  }
}

void sub_1A43D3D58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, const void *a16, const void *a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
}

void NL::NumericConverter::numericIntForType(uint64_t a1@<X2>, void *a2@<X8>)
{
  if (*(char *)(a1 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__str, *(const std::string::value_type **)a1, *(void *)(a1 + 8));
  }
  else {
    std::string __str = *(std::string *)a1;
  }
  std::string::size_type size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_str = &__str;
  }
  else {
    p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
  }
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = __str.__r_.__value_.__l.__size_;
  }
  uint64_t v5 = std::remove_if[abi:ne180100]<std::__wrap_iter<char *>,ValidNumChars>((unsigned __int8 *)p_str, (unsigned __int8 *)p_str + size, ", ");
  size_t v6 = (char *)&__str + HIBYTE(__str.__r_.__value_.__r.__words[2]);
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    uint64_t v7 = &__str;
  }
  else
  {
    size_t v6 = (char *)(__str.__r_.__value_.__r.__words[0] + __str.__r_.__value_.__l.__size_);
    uint64_t v7 = (std::string *)__str.__r_.__value_.__r.__words[0];
  }
  std::string::erase(&__str, v5 - (unsigned __int8 *)v7, v6 - (char *)v5);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::size_type v8 = __str.__r_.__value_.__l.__size_;
    if (__str.__r_.__value_.__l.__size_)
    {
      uint64_t v9 = (std::string *)__str.__r_.__value_.__r.__words[0];
      goto LABEL_17;
    }
  }
  else
  {
    std::string::size_type v8 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    if (*((unsigned char *)&__str.__r_.__value_.__s + 23))
    {
      uint64_t v9 = &__str;
LABEL_17:
      while ((v9->__r_.__value_.__s.__data_[0] & 0x80000000) == 0
           && (*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v9->__r_.__value_.__s.__data_[0] + 60) & 0x400) != 0)
      {
        uint64_t v9 = (std::string *)((char *)v9 + 1);
        if (!--v8)
        {
          int v10 = std::stoi(&__str, 0, 10);
          goto LABEL_22;
        }
      }
    }
  }
  int v10 = 0;
LABEL_22:
  uint64_t v11 = (std::__shared_weak_count *)operator new(0x28uLL);
  v11->__shared_owners_ = 0;
  v11->__shared_weak_owners_ = 0;
  v11->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7CE7E0;
  LODWORD(v11[1].__vftable) = v10;
  HIDWORD(v11[1].__vftable) = v10 / 10 + v10;
  LODWORD(v11[1].__shared_owners_) = v10 - v10 / 10;
  CFDictionaryRef v12 = v11 + 1;
  CFDictionaryRef v13 = v11;
  std::allocate_shared[abi:ne180100]<NL::NumericValue,std::allocator<NL::NumericValue>,std::shared_ptr<NL::NumericInterval<int>> &,void>((uint64_t *)&v12, a2);
  if (v13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v13);
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
}

void NL::NumericConverter::numericDoubleForType(NL::NumericConverter *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  *(void *)pErrorCode = 0;
  MEMORY[0x1F4188790](a1);
  uint64_t v9 = (UChar *)((char *)&v29 - v8);
  int v10 = *(char *)(v7 + 23);
  if (v10 >= 0) {
    uint64_t v11 = (const char *)v7;
  }
  else {
    uint64_t v11 = *(const char **)v7;
  }
  if (v10 >= 0) {
    int32_t v12 = *(unsigned __int8 *)(v7 + 23);
  }
  else {
    int32_t v12 = *(_DWORD *)(v7 + 8);
  }
  u_strFromUTF8(v9, v6, (int32_t *)pErrorCode, v11, v12, &pErrorCode[1]);
  v9[pErrorCode[0]] = 0;
  NL::NumericConverter::locale(a1, &v29);
  uint64_t v13 = unum_open();
  if (v31 < 0) {
    operator delete(v29);
  }
  if (pErrorCode[1] >= U_ILLEGAL_ARGUMENT_ERROR)
  {
    if (v13) {
      unum_close();
    }
    goto LABEL_13;
  }
  unum_parseDouble();
  double v15 = v14;
  unum_close();
  if (pErrorCode[1] >= U_ILLEGAL_ARGUMENT_ERROR)
  {
LABEL_13:
    *a3 = 0;
    a3[1] = 0;
    return;
  }
  char v16 = *(unsigned char *)(a2 + 23);
  if (v16 >= 0) {
    uint64_t v17 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v17 = *(void *)(a2 + 8);
  }
  if (v16 >= 0) {
    uint64_t v18 = a2;
  }
  else {
    uint64_t v18 = *(void *)a2;
  }
  if (v17 >= 4)
  {
    CFTypeRef v19 = (char *)(v18 + v17);
    uint64_t v20 = v17;
    char v21 = (void *)v18;
    do
    {
      uint64_t v22 = (char *)memchr(v21, 70, v20 - 3);
      if (!v22) {
        break;
      }
      if (*(_DWORD *)v22 == 1952802118)
      {
        if (v22 != v19 && &v22[-v18] != (char *)-1)
        {
          double v23 = 0.304800004;
          goto LABEL_45;
        }
        break;
      }
      char v21 = v22 + 1;
      uint64_t v20 = v19 - (unsigned char *)v21;
    }
    while (v19 - (unsigned char *)v21 >= 4);
    if (v17 >= 6)
    {
      uint64_t v24 = (void *)v18;
      do
      {
        uint64_t v25 = (char *)memchr(v24, 73, v17 - 5);
        if (!v25) {
          break;
        }
        if (*(_DWORD *)v25 == 1751346761 && *((_WORD *)v25 + 2) == 29541)
        {
          if (v25 != v19 && &v25[-v18] != (char *)-1)
          {
            double v23 = 0.0253999997;
            goto LABEL_45;
          }
          break;
        }
        uint64_t v24 = v25 + 1;
        uint64_t v17 = v19 - (unsigned char *)v24;
      }
      while (v19 - (unsigned char *)v24 >= 6);
    }
  }
  if (std::string::find[abi:ne180100]((uint64_t *)a2, "Meters", 0) == -1)
  {
    if (std::string::find[abi:ne180100]((uint64_t *)a2, "Centimeters", 0) != -1)
    {
      double v23 = 0.00999999978;
LABEL_45:
      double v15 = v15 * v23;
      goto LABEL_46;
    }
    if (std::string::find[abi:ne180100]((uint64_t *)a2, "Seconds", 0) == -1)
    {
      if (std::string::find[abi:ne180100]((uint64_t *)a2, "Minutes", 0) != -1)
      {
        *(double *)&uint64_t v28 = 60.0;
LABEL_51:
        double v23 = *(double *)&v28;
        goto LABEL_45;
      }
      if (std::string::find[abi:ne180100]((uint64_t *)a2, "Hours", 0) != -1)
      {
        double v23 = 3600.0;
        goto LABEL_45;
      }
      if (std::string::find[abi:ne180100]((uint64_t *)a2, "Bytes", 0) == -1)
      {
        if (std::string::find[abi:ne180100]((uint64_t *)a2, "Kilobytes", 0) == -1)
        {
          if (std::string::find[abi:ne180100]((uint64_t *)a2, "Megabytes", 0) == -1)
          {
            if (std::string::find[abi:ne180100]((uint64_t *)a2, "Gigabytes", 0) != -1) {
              double v15 = v15 * 1073741820.0;
            }
            goto LABEL_46;
          }
          *(double *)&uint64_t v28 = 1048576.0;
        }
        else
        {
          *(double *)&uint64_t v28 = 1024.0;
        }
        goto LABEL_51;
      }
    }
  }
LABEL_46:
  std::string::size_type v27 = (std::__shared_weak_count *)operator new(0x30uLL);
  v27->__shared_owners_ = 0;
  v27->__shared_weak_owners_ = 0;
  *(double *)&v27[1].__vftable = v15;
  v27->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7CE7A8;
  *(double *)&v27[1].__shared_owners_ = v15 + v15 / 10.0;
  *(double *)&v27[1].__shared_weak_owners_ = v15 - v15 / 10.0;
  uint64_t v29 = v27 + 1;
  uint64_t v30 = v27;
  std::allocate_shared[abi:ne180100]<NL::NumericValue,std::allocator<NL::NumericValue>,std::shared_ptr<NL::NumericInterval<double>> &,void>((uint64_t *)&v29, a3);
  if (v30) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v30);
  }
}

void sub_1A43D4434(_Unwind_Exception *exception_object)
{
  CFLocaleRef v3 = *(std::__shared_weak_count **)(v1 - 120);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  _Unwind_Resume(exception_object);
}

unsigned __int8 *std::remove_if[abi:ne180100]<std::__wrap_iter<char *>,ValidNumChars>(unsigned __int8 *result, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (result == a2) {
    return a2;
  }
  while (1)
  {
    CFLocaleRef v3 = a3;
    do
    {
      int v5 = *v3++;
      int v4 = v5;
    }
    while (v5 != *result && v4 != 0);
    if (v4) {
      break;
    }
    if (++result == a2)
    {
      double result = a2;
      break;
    }
  }
  if (result != a2)
  {
    for (uint64_t i = result + 1; i != a2; ++i)
    {
      int v8 = *i;
      uint64_t v9 = a3;
      do
      {
        int v11 = *v9++;
        int v10 = v11;
      }
      while (v11 != v8 && v10 != 0);
      if (!v10) {
        *result++ = v8;
      }
    }
  }
  return result;
}

void std::__shared_ptr_emplace<NL::NumericInterval<int>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7CE7E0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<NL::NumericInterval<int>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7CE7E0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A625B130);
}

void *std::allocate_shared[abi:ne180100]<NL::NumericValue,std::allocator<NL::NumericValue>,std::shared_ptr<NL::NumericInterval<int>> &,void>@<X0>(uint64_t *a1@<X1>, void *a2@<X8>)
{
  int v4 = operator new(0x38uLL);
  double result = std::__shared_ptr_emplace<NL::NumericValue>::__shared_ptr_emplace[abi:ne180100]<std::shared_ptr<NL::NumericInterval<int>> &,std::allocator<NL::NumericValue>,0>(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1A43D45A8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<NL::NumericValue>::__shared_ptr_emplace[abi:ne180100]<std::shared_ptr<NL::NumericInterval<int>> &,std::allocator<NL::NumericValue>,0>(void *a1, uint64_t *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1EF7CE5E8;
  uint64_t v4 = *a2;
  CFLocaleRef v3 = (std::__shared_weak_count *)a2[1];
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    a1[3] = v4;
    a1[4] = v3;
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    a1[5] = 0;
    a1[6] = 0;
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  else
  {
    a1[3] = v4;
    a1[4] = 0;
    a1[5] = 0;
    a1[6] = 0;
  }
  return a1;
}

void std::__shared_ptr_emplace<NL::NumericValue>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7CE5E8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<NL::NumericValue>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7CE5E8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A625B130);
}

void std::__shared_ptr_emplace<NL::NumericValue>::__on_zero_shared(uint64_t a1)
{
}

void NL::NumericValue::~NumericValue(NL::NumericValue *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  CFLocaleRef v3 = (std::__shared_weak_count *)*((void *)this + 1);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
}

void std::__shared_ptr_emplace<NL::NumericInterval<double>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7CE7A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<NL::NumericInterval<double>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7CE7A8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A625B130);
}

void *std::allocate_shared[abi:ne180100]<NL::NumericValue,std::allocator<NL::NumericValue>,std::shared_ptr<NL::NumericInterval<double>> &,void>@<X0>(uint64_t *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x38uLL);
  double result = std::__shared_ptr_emplace<NL::NumericValue>::__shared_ptr_emplace[abi:ne180100]<std::shared_ptr<NL::NumericInterval<double>> &,std::allocator<NL::NumericValue>,0>(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1A43D47B0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<NL::NumericValue>::__shared_ptr_emplace[abi:ne180100]<std::shared_ptr<NL::NumericInterval<double>> &,std::allocator<NL::NumericValue>,0>(void *a1, uint64_t *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1EF7CE5E8;
  std::allocator<NL::NumericValue>::construct[abi:ne180100]<NL::NumericValue,std::shared_ptr<NL::NumericInterval<double>> &>((uint64_t)&v4, a1 + 3, a2);
  return a1;
}

void sub_1A43D4820(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::allocator<NL::NumericValue>::construct[abi:ne180100]<NL::NumericValue,std::shared_ptr<NL::NumericInterval<double>> &>(uint64_t a1, void *a2, uint64_t *a3)
{
  uint64_t v4 = *a3;
  CFLocaleRef v3 = (std::__shared_weak_count *)a3[1];
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    *a2 = 0;
    a2[1] = 0;
    a2[2] = v4;
    a2[3] = v3;
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = v4;
    a2[3] = 0;
  }
}

void SearchParseCandidate::~SearchParseCandidate(const void **this)
{
}

void SearchParseCandidate::setDescription(const void **this, const __CFString *a2)
{
  CFLocaleRef v3 = this + 1;
  nlp::CFScopedPtr<__CFString const*>::reset(this + 1, 0);
  if (a2)
  {
    CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2);
    nlp::CFScopedPtr<__CFString const*>::reset(v3, Copy);
  }
}

void SearchParseCandidate::setRankingTerms(const void **this, const __CFDictionary *a2)
{
  CFLocaleRef v3 = this + 3;
  nlp::CFScopedPtr<__CFDictionary const*>::reset(this + 3, 0);
  if (a2)
  {
    CFDictionaryRef Copy = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2);
    nlp::CFScopedPtr<__CFDictionary const*>::reset(v3, Copy);
  }
}

void SearchParseCandidate::setRankingCategories(const void **this, const __CFDictionary *a2)
{
  CFLocaleRef v3 = this + 4;
  nlp::CFScopedPtr<__CFDictionary const*>::reset(this + 4, 0);
  if (a2)
  {
    CFDictionaryRef Copy = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2);
    nlp::CFScopedPtr<__CFDictionary const*>::reset(v3, Copy);
  }
}

void SearchParseCandidate::setResultModifier(const void **this, const __CFDictionary *a2)
{
  CFLocaleRef v3 = this + 5;
  nlp::CFScopedPtr<__CFDictionary const*>::reset(this + 5, 0);
  if (a2)
  {
    CFDictionaryRef Copy = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2);
    nlp::CFScopedPtr<__CFDictionary const*>::reset(v3, Copy);
  }
}

void SearchParseCandidate::setAttributedInput(const void **this, const __CFArray *a2)
{
  CFLocaleRef v3 = this + 2;
  nlp::CFScopedPtr<__CFArray const*>::reset(this + 2, 0);
  if (a2)
  {
    CFArrayRef Copy = CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2);
    nlp::CFScopedPtr<__CFArray const*>::reset(v3, Copy);
  }
}

void SearchParser::SearchParser(SearchParser *this, const __CFDictionary *a2)
{
  *((_OWORD *)this + 4) = 0u;
  *(_OWORD *)((char *)this + 108) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_DWORD *)this + 31) = 1;
  *((_WORD *)this + 64) = 1;
  SearchParser::init(this, a2);
}

void sub_1A43D4B4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  nlp::CFScopedPtr<__CFDictionary const*>::reset((const void **)(v10 + 112), 0);
  nlp::CFScopedPtr<__CFString const*>::reset((const void **)(v10 + 104), 0);
  double v14 = *(std::__shared_weak_count **)(v10 + 96);
  if (v14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v14);
  }
  SearchParser::SearchParser((void *)v10, v11, v12);
  a10 = (void **)v10;
  std::vector<std::shared_ptr<NL::ParseAttribute>>::__destroy_vector::operator()[abi:ne180100](&a10);
  _Unwind_Resume(a1);
}

void SearchParser::init(SearchParser *this, const __CFDictionary *a2)
{
}

void sub_1A43D4D9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  nlp::CFScopedPtr<__CFURL const*>::reset((const void **)va, 0);
  _Unwind_Resume(a1);
}

void SearchParser::~SearchParser(SearchParser *this)
{
  nlp::CFScopedPtr<__CFDictionary const*>::reset((const void **)this + 14, 0);
  nlp::CFScopedPtr<__CFString const*>::reset((const void **)this + 13, 0);
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 12);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  CFLocaleRef v3 = (std::__shared_weak_count *)*((void *)this + 10);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  std::unique_ptr<NL::ParseBuilder>::reset[abi:ne180100]((NL::ParseBuilder **)this + 8, 0);
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  std::unique_ptr<NL::ParserResources>::reset[abi:ne180100]((NL::ParserResources **)this + 5, 0);
  int v5 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  int32_t v6 = (void **)this;
  std::vector<std::shared_ptr<NL::ParseAttribute>>::__destroy_vector::operator()[abi:ne180100](&v6);
}

NL::ParserResources *std::unique_ptr<NL::ParserResources>::reset[abi:ne180100](NL::ParserResources **a1, NL::ParserResources *a2)
{
  double result = *a1;
  *a1 = a2;
  if (result)
  {
    NL::ParserResources::~ParserResources(result);
    JUMPOUT(0x1A625B130);
  }
  return result;
}

NL::ParseBuilder *std::unique_ptr<NL::ParseBuilder>::reset[abi:ne180100](NL::ParseBuilder **a1, NL::ParseBuilder *a2)
{
  double result = *a1;
  *a1 = a2;
  if (result)
  {
    NL::ParseBuilder::~ParseBuilder(result);
    JUMPOUT(0x1A625B130);
  }
  return result;
}

void SearchParser::setLocale(SearchParser *this, const __CFLocale *a2)
{
  NL::ParserResources::setLocale(*((NL::ParserResources **)this + 5), a2);
  NL::ParserContext::setCanonicalRegions(*((const void ***)this + 3), *(const __CFDictionary **)(*((void *)this + 5) + 24));
  CFLocaleRef v3 = NL::ParserResources::copyReferenceDatesPath(*((NL::ParserResources **)this + 5));
  if (v3)
  {
    uint64_t v4 = v3;
    NL::ParserContext::setReferenceDatesPath(*((const void ***)this + 3), v3);
    CFRelease(v4);
  }
}

void sub_1A43D4FB4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  nlp::CFScopedPtr<__CFURL const*>::reset((const void **)va, 0);
  _Unwind_Resume(a1);
}

BOOL SearchParser::hasResources(NL::ParserResources **this)
{
  NL::ParserResources::getSearchGrammar(this[5], &v3);
  uint64_t v1 = v3;
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  return v1 != 0;
}

void SearchParser::addInput(SearchParser *this, CFTypeRef cf)
{
  uint64_t v3 = *((void *)this + 13);
  if (v3) {
    CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@%@", v3, cf);
  }
  else {
    CFStringRef v4 = (const __CFString *)CFRetain(cf);
  }
  CFStringRef v5 = v4;
  SearchParser::setInput(this, v4);
  if (v5) {
    CFRelease(v5);
  }
}

void sub_1A43D5094(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  nlp::CFScopedPtr<__CFString const*>::reset((const void **)va, 0);
  _Unwind_Resume(a1);
}

void SearchParser::setInput(SearchParser *this, const __CFString *a2)
{
  SearchParser::reset(this);
  if (a2) {
    CFTypeRef v4 = CFRetain(a2);
  }
  else {
    CFTypeRef v4 = 0;
  }
  nlp::CFScopedPtr<__CFString const*>::reset((const void **)this + 13, v4);
  NL::QueryTokenizer::setString(*((const void ***)this + 6), a2);
  CFStringRef v5 = (NL::ParseBuilder *)*((void *)this + 8);

  NL::ParseBuilder::parse(v5);
}

void SearchParser::reset(SearchParser *this)
{
  std::vector<std::shared_ptr<NL::ParseAttributes>>::__clear[abi:ne180100]((uint64_t *)this);
  *((_WORD *)this + 64) = 1;
  *((void *)this + 15) = 0x100000000;
  nlp::CFScopedPtr<__CFDictionary const*>::reset((const void **)this + 14, 0);
  uint64_t v2 = (NL::ParserContext *)*((void *)this + 3);
  if (v2) {
    NL::ParserContext::reset(v2);
  }
  uint64_t v3 = (NL::QueryTokenizer *)*((void *)this + 6);
  if (v3) {
    NL::QueryTokenizer::reset(v3);
  }
  CFTypeRef v4 = (NL::ParseBuilder *)*((void *)this + 8);
  if (v4) {
    NL::ParseBuilder::reset(v4);
  }
  CFStringRef v5 = (NL::ParserResources *)*((void *)this + 5);
  if (v5) {
    NL::ParserResources::reset(v5);
  }
  nlp::CFScopedPtr<__CFString const*>::reset((const void **)this + 13, 0);
  CFLocaleRef v6 = (const __CFLocale *)NL::ParserResources::copyLocale(*((NL::ParserResources **)this + 5));
  CFLocaleRef v22 = v6;
  if (v6) {
    NL::ParserContext::setLocale(*((const void ***)this + 3), v6);
  }
  uint64_t v7 = (const void **)NL::ParserResources::copyEntityDetector(*((NL::ParserResources **)this + 5));
  NL::QueryTokenizer::setEntityDetector(*((void *)this + 6), (uint64_t)v7);
  if (v7) {
    NLEntityDetectorRelease(v7);
  }
  NL::ParserResources::getSearchGrammar(*((NL::ParserResources **)this + 5), &v20);
  uint64_t v8 = v20;
  if (v20)
  {
    uint64_t v9 = *((void *)this + 3);
    uint64_t v10 = (std::__shared_weak_count *)*((void *)this + 4);
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    int v11 = *(std::__shared_weak_count **)(v8 + 40);
    *(void *)(v8 + 32) = v9;
    *(void *)(v8 + 4nlp::CFScopedPtr<__CFString const*>::reset(this + 1, 0) = v10;
    if (v11) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v11);
    }
    if (v10) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v10);
    }
  }
  uint64_t v12 = *((void *)this + 8);
  uint64_t v13 = v20;
  double v14 = v21;
  if (v21)
  {
    atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  double v15 = *(std::__shared_weak_count **)(v12 + 56);
  *(void *)(v12 + 48) = v13;
  *(void *)(v12 + 56) = v14;
  if (v15) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v15);
  }
  if (v14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v14);
  }
  uint64_t v16 = *((void *)this + 6);
  uint64_t v17 = v20;
  uint64_t v18 = v21;
  if (v21)
  {
    atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  CFTypeRef v19 = *(std::__shared_weak_count **)(v16 + 24);
  *(void *)(v16 + 16) = v17;
  *(void *)(v16 + 24) = v18;
  if (v19) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v19);
  }
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v18);
  }
  if (v21) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v21);
  }
  if (v6) {
    CFRelease(v6);
  }
}

void sub_1A43D52BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  nlp::CFScopedPtr<__CFLocale const*>::reset((const void **)va, 0);
  _Unwind_Resume(a1);
}

void SearchParser::getFormatter(uint64_t *a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  if ((a2 - 1) <= 1)
  {
    uint64_t v5 = a1[11];
    if (!v5)
    {
      std::allocate_shared[abi:ne180100]<NL::SpotlightParseFormatter,std::allocator<NL::SpotlightParseFormatter>,std::shared_ptr<NL::ParserContext> &,std::shared_ptr<NL::QueryTokenizer> &,void>(a1 + 3, a1 + 6, &v11);
      long long v6 = v11;
      long long v11 = 0uLL;
      uint64_t v7 = (std::__shared_weak_count *)a1[12];
      *(_OWORD *)(a1 + 11) = v6;
      if (v7)
      {
        std::__shared_weak_count::__release_shared[abi:ne180100](v7);
        if (*((void *)&v11 + 1)) {
          std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v11 + 1));
        }
      }
      uint64_t v5 = a1[11];
    }
    uint64_t v8 = a1[12];
    if (!v8) {
      goto LABEL_16;
    }
LABEL_15:
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    goto LABEL_16;
  }
  uint64_t v5 = a1[9];
  if (!v5)
  {
    std::allocate_shared[abi:ne180100]<NL::ParseFormatter,std::allocator<NL::ParseFormatter>,std::shared_ptr<NL::ParserContext> &,std::shared_ptr<NL::QueryTokenizer> &,void>(a1 + 3, a1 + 6, &v11);
    long long v9 = v11;
    long long v11 = 0uLL;
    uint64_t v10 = (std::__shared_weak_count *)a1[10];
    *(_OWORD *)(a1 + 9) = v9;
    if (v10)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v10);
      if (*((void *)&v11 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v11 + 1));
      }
    }
    uint64_t v5 = a1[9];
  }
  uint64_t v8 = a1[10];
  if (v8) {
    goto LABEL_15;
  }
LABEL_16:
  *a3 = v5;
  a3[1] = v8;
}

void SearchParser::parse(uint64_t a1, int a2, uint64_t a3)
{
  if (*(_DWORD *)(a1 + 120) != a2 || *(_DWORD *)(a1 + 124) != a3 || *(unsigned char *)(a1 + 128))
  {
    long long v6 = (const void **)(a1 + 112);
    nlp::CFScopedPtr<__CFDictionary const*>::reset((const void **)(a1 + 112), 0);
    SearchParser::getFormatter((uint64_t *)a1, a2, &v16);
    uint64_t v7 = v16;
    if (!v16) {
      goto LABEL_16;
    }
    if (!SearchParser::hasResources((NL::ParserResources **)a1))
    {
      long long v11 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v7 + 24))(v7, a3);
      nlp::CFScopedPtr<__CFDictionary const*>::reset((const void **)(a1 + 112), v11);
      goto LABEL_16;
    }
    *(_DWORD *)(a1 + 12nlp::CFScopedPtr<__CFString const*>::reset(this + 1, 0) = a2;
    *(_WORD *)(a1 + 128) = 256;
    uint64_t v8 = *(uint64_t **)(a1 + 64);
    uint64_t v9 = *v8;
    uint64_t v10 = (std::__shared_weak_count *)v8[1];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      if (*(void *)(v9 + 16) != *(void *)(v9 + 8))
      {
        uint64_t v14 = v9;
        double v15 = v10;
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        goto LABEL_12;
      }
    }
    else if (*(void *)(v9 + 16) != *(void *)(v9 + 8))
    {
      uint64_t v14 = *v8;
      double v15 = 0;
LABEL_12:
      uint64_t v12 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t *, uint64_t))(*(void *)v7 + 16))(v7, &v14, a3);
      nlp::CFScopedPtr<__CFDictionary const*>::reset(v6, v12);
      if (v15) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v15);
      }
      if (!v10) {
        goto LABEL_16;
      }
      goto LABEL_15;
    }
    uint64_t v13 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v7 + 24))(v7, a3);
    nlp::CFScopedPtr<__CFDictionary const*>::reset(v6, v13);
    if (!v10)
    {
LABEL_16:
      if (v17) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v17);
      }
      return;
    }
LABEL_15:
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
    goto LABEL_16;
  }
}

void sub_1A43D5584(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v12);
  }
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(exception_object);
}

void SearchParser::enumerateDateRangeDisplaySuggestions(uint64_t a1, CFDictionaryRef theDict, uint64_t a3)
{
  if (!theDict) {
    return;
  }
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, @"startDateQuery");
  CFNumberRef v7 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"startDateModifier");
  CFStringRef v8 = (const __CFString *)CFDictionaryGetValue(theDict, @"endDateQuery");
  CFNumberRef v9 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"endDateModifier");
  if (!Value || !v8) {
    return;
  }
  CFNumberRef v10 = v9;
  char v25 = 0;
  int valuePtr = 0;
  if (v7) {
    CFNumberGetValue(v7, kCFNumberSInt32Type, &valuePtr);
  }
  int v23 = 0;
  if (v10) {
    CFNumberGetValue(v10, kCFNumberSInt32Type, &v23);
  }
  long long v11 = copyCurrentCalendar(*(void *)(*(void *)(a1 + 24) + 8));
  CFLocaleRef v22 = v11;
  NL::DateFormatter::DateFormatter(v17);
  uint64_t v12 = NL::DateFormatter::copyDisplayStringWithStartAndEndDateForRange((NL::DateFormatter *)v17, Value, valuePtr, v8, v23);
  if (v12) {
    (*(void (**)(uint64_t, __CFBundle *, char *))(a3 + 16))(a3, v12, &v25);
  }
  if (valuePtr) {
    BOOL v13 = valuePtr == 3;
  }
  else {
    BOOL v13 = 1;
  }
  BOOL v14 = v23 == 3 && v13;
  if (v23) {
    BOOL v15 = 0;
  }
  else {
    BOOL v15 = valuePtr == 3;
  }
  if (v14 || v15)
  {
    CFStringRef v16 = NL::DateFormatter::copyDisplayStringForDates((NL::DateFormatter *)v17, Value, v8);
    if (v12) {
      CFRelease(v12);
    }
    if (!v16) {
      goto LABEL_28;
    }
    (*(void (**)(uint64_t, CFStringRef, char *))(a3 + 16))(a3, v16, &v25);
  }
  else
  {
    CFStringRef v16 = (CFStringRef)v12;
    if (!v12) {
      goto LABEL_28;
    }
  }
  CFRelease(v16);
LABEL_28:
  if (cf) {
    CFRelease(cf);
  }
  CFTypeRef cf = 0;
  if (v20) {
    CFRelease(v20);
  }
  CFTypeRef v20 = 0;
  if (v19) {
    CFRelease(v19);
  }
  CFTypeRef v19 = 0;
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v18);
  }
  if (v11) {
    CFRelease(v11);
  }
}

void sub_1A43D57CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  CFTypeRef v4 = va_arg(va1, const void *);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  NL::DateFormatter::~DateFormatter((const void **)va);
  nlp::CFScopedPtr<__CFCalendar *>::reset((const void **)va1, 0);
  _Unwind_Resume(a1);
}

void NL::DateFormatter::~DateFormatter(const void **this)
{
  nlp::CFScopedPtr<__CFDateFormatter *>::reset(this + 4, 0);
  nlp::CFScopedPtr<__CFDateFormatter *>::reset(this + 3, 0);
  nlp::CFScopedPtr<__CFDateFormatter *>::reset(this + 2, 0);
  uint64_t v2 = (std::__shared_weak_count *)this[1];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
}

void SearchParser::enumerateDateDisplaySuggestions(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFTypeRef v4 = *(std::__shared_weak_count **)(a1 + 32);
  uint64_t v31 = *(void *)(a1 + 24);
  uint64_t v32 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  NL::DateConverter::DateConverter(&v33, &v31);
  if (v32) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v32);
  }
  NL::DateFormatter::DateFormatter(&v26);
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  CFTypeRef cf = 0;
  char v25 = 0;
  char v23 = 0;
  do
  {
    NL::DateConverter::datePeriodForRelativeDate(off_1E5B36EB8[v5], &keys);
    uint64_t v7 = (NL::DatePeriod *)keys;
    keys = 0;
    char v25 = v7;
    if (!v6)
    {
      uint64_t v6 = v7;
      if (!v7) {
        goto LABEL_16;
      }
LABEL_12:
      uint64_t v9 = NL::DateFormatter::copyDisplayForDate(&v26, v6, 0, 0);
      if (cf) {
        CFRelease(cf);
      }
      CFTypeRef cf = v9;
      if (v9) {
        (*(void (**)(uint64_t, __CFDateFormatter **, char *))(a3 + 16))(a3, v9, &v23);
      }
      goto LABEL_16;
    }
    NL::DatePeriod::~DatePeriod((const void **)v6);
    MEMORY[0x1A625B130]();
    uint64_t v8 = (const void **)keys;
    keys = 0;
    if (v8)
    {
      NL::DatePeriod::~DatePeriod(v8);
      MEMORY[0x1A625B130]();
    }
    uint64_t v6 = v25;
    if (v25) {
      goto LABEL_12;
    }
LABEL_16:
    ++v5;
  }
  while (v5 != 8);
  uint64_t v10 = 0;
  keys = @"DIGITS";
  CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v12 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  BOOL v13 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  do
  {
    uint64_t v14 = 1u;
    do
    {
      CFStringRef v15 = off_1E5B36EF8[v14];
      values = (void *)CFStringCreateWithFormat(v11, 0, @"%ld", v10);
      CFTypeRef v20 = CFDictionaryCreate(v11, (const void **)&keys, (const void **)&values, 1, v12, v13);
      NL::DateConverter::datePeriodForValues(v15, (const __CFDictionary *)v20, &v19);
      CFStringRef v16 = v19;
      CFTypeRef v19 = 0;
      char v25 = v16;
      if (v6)
      {
        NL::DatePeriod::~DatePeriod((const void **)v6);
        MEMORY[0x1A625B130]();
        uint64_t v17 = (const void **)v19;
        CFTypeRef v19 = 0;
        if (v17)
        {
          NL::DatePeriod::~DatePeriod(v17);
          MEMORY[0x1A625B130]();
        }
      }
      uint64_t v6 = v25;
      uint64_t v18 = NL::DateFormatter::copyDisplayForDate(&v26, v25, 0, 0);
      if (cf) {
        CFRelease(cf);
      }
      CFTypeRef cf = v18;
      (*(void (**)(uint64_t, __CFDateFormatter **, char *))(a3 + 16))(a3, v18, &v23);
      if (v20) {
        CFRelease(v20);
      }
      if (values) {
        CFRelease(values);
      }
      ++v14;
    }
    while (v14 != 4);
    ++v10;
  }
  while (v10 != 6);
  if (v18) {
    CFRelease(v18);
  }
  NL::DatePeriod::~DatePeriod((const void **)v6);
  MEMORY[0x1A625B130]();
  if (v30) {
    CFRelease(v30);
  }
  CFTypeRef v30 = 0;
  if (v29) {
    CFRelease(v29);
  }
  CFTypeRef v29 = 0;
  if (v28) {
    CFRelease(v28);
  }
  CFTypeRef v28 = 0;
  if (v27) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v27);
  }
  if (v34) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v34);
  }
}

void sub_1A43D5B90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, char a19, int a20,__int16 a21,char a22,char a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33)
{
  uint64_t v35 = *(std::__shared_weak_count **)(v33 - 88);
  if (v35) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v35);
  }
  _Unwind_Resume(exception_object);
}

void SearchParser::enumerateSuggestions(uint64_t a1, uint64_t a2, CFDictionaryRef theDict, uint64_t a4)
{
  if (*(void *)(*(void *)(a1 + 24) + 8))
  {
    if (theDict
      && CFDictionaryContainsKey(theDict, @"startDateQuery")
      && CFDictionaryContainsKey(theDict, @"endDateQuery"))
    {
      v8[0] = MEMORY[0x1E4F143A8];
      v8[1] = 0x40000000;
      v8[2] = ___ZN12SearchParser20enumerateSuggestionsEPK10__CFStringPK14__CFDictionaryU13block_pointerFvS2_PbE_block_invoke;
      v8[3] = &unk_1E5B364A0;
      v8[4] = a4;
      SearchParser::enumerateDateRangeDisplaySuggestions(a1, theDict, (uint64_t)v8);
    }
    else
    {
      v7[0] = MEMORY[0x1E4F143A8];
      v7[1] = 0x40000000;
      v7[2] = ___ZN12SearchParser20enumerateSuggestionsEPK10__CFStringPK14__CFDictionaryU13block_pointerFvS2_PbE_block_invoke_2;
      v7[3] = &unk_1E5B36F30;
      v7[4] = a4;
      SearchParser::enumerateDateDisplaySuggestions(a1, a2, (uint64_t)v7);
    }
  }
}

uint64_t ___ZN12SearchParser20enumerateSuggestionsEPK10__CFStringPK14__CFDictionaryU13block_pointerFvS2_PbE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t ___ZN12SearchParser20enumerateSuggestionsEPK10__CFStringPK14__CFDictionaryU13block_pointerFvS2_PbE_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

const void *SearchParser::currentParse(SearchParser *this)
{
  CFDictionaryRef v2 = (const __CFDictionary *)*((void *)this + 14);
  if (!v2 || !CFDictionaryContainsKey(v2, @"Parse")) {
    return 0;
  }
  CFDictionaryRef v3 = (const __CFDictionary *)*((void *)this + 14);

  return CFDictionaryGetValue(v3, @"Parse");
}

const __CFDictionary *SearchParser::currentConfidence(SearchParser *this)
{
  unsigned int valuePtr = 0;
  CFDictionaryRef result = (const __CFDictionary *)*((void *)this + 14);
  if (result)
  {
    CFDictionaryRef result = (const __CFDictionary *)CFDictionaryContainsKey(result, @"Confidence");
    if (result)
    {
      CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 14), @"Confidence");
      CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
      return (const __CFDictionary *)valuePtr;
    }
  }
  return result;
}

const void *SearchParser::rankingTerms(SearchParser *this)
{
  CFDictionaryRef v2 = (const __CFDictionary *)*((void *)this + 14);
  if (!v2 || !CFDictionaryContainsKey(v2, @"RankTerms")) {
    return 0;
  }
  CFDictionaryRef v3 = (const __CFDictionary *)*((void *)this + 14);

  return CFDictionaryGetValue(v3, @"RankTerms");
}

const void *SearchParser::rankCategories(SearchParser *this)
{
  CFDictionaryRef v2 = (const __CFDictionary *)*((void *)this + 14);
  if (!v2 || !CFDictionaryContainsKey(v2, @"RankCategories")) {
    return 0;
  }
  CFDictionaryRef v3 = (const __CFDictionary *)*((void *)this + 14);

  return CFDictionaryGetValue(v3, @"RankCategories");
}

const void *SearchParser::resultModifier(SearchParser *this)
{
  CFDictionaryRef v2 = (const __CFDictionary *)*((void *)this + 14);
  if (!v2 || !CFDictionaryContainsKey(v2, @"ResultModifier")) {
    return 0;
  }
  CFDictionaryRef v3 = (const __CFDictionary *)*((void *)this + 14);

  return CFDictionaryGetValue(v3, @"ResultModifier");
}

const void *SearchParser::attributedInput(SearchParser *this)
{
  CFDictionaryRef v2 = (const __CFDictionary *)*((void *)this + 14);
  if (!v2 || !CFDictionaryContainsKey(v2, @"AttributedInput")) {
    return 0;
  }
  CFDictionaryRef v3 = (const __CFDictionary *)*((void *)this + 14);

  return CFDictionaryGetValue(v3, @"AttributedInput");
}

uint64_t _CFInit_SearchParserWrapper(uint64_t result)
{
  *(void *)(result + 16) = &unk_1EF7CCB70;
  return result;
}

uint64_t createSearchParserWrapper(SearchParser *a1)
{
  CFAllocatorGetDefault();
  if (!g_CFTypeID_SearchParserWrapper)
  {
    qword_1EC024188 = 0;
    unk_1EC024198 = 0u;
    unk_1EC0241A8 = 0u;
    g_CFTypeID_SearchParserWrapper = _CFRuntimeRegisterClass();
  }
  uint64_t result = _CFRuntimeCreateInstance();
  *(void *)(result + 24) = a1;
  return result;
}

uint64_t _CFInit_SearchParseCandidateWrapper(uint64_t result)
{
  *(void *)(result + 16) = &unk_1EF7CD7F0;
  return result;
}

uint64_t createSearchParseCandidateWrapper(SearchParseCandidate *a1)
{
  CFAllocatorGetDefault();
  if (!g_CFTypeID_SearchParseCandidateWrapper)
  {
    qword_1EC024128 = 0;
    unk_1EC024138 = 0u;
    unk_1EC024148 = 0u;
    g_CFTypeID_SearchParseCandidateWrapper = _CFRuntimeRegisterClass();
  }
  uint64_t result = _CFRuntimeCreateInstance();
  *(void *)(result + 24) = a1;
  return result;
}

CFArrayRef NLSearchParserCopyAvailableLanguages()
{
  return CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&NLSearchParserCopyAvailableLanguages::languages, 10, MEMORY[0x1E4F1D510]);
}

void NLSearchParserCreate()
{
}

void sub_1A43D6168(_Unwind_Exception *a1)
{
  MEMORY[0x1A625B130](v1, 0x1060C407CA3BCE5);
  _Unwind_Resume(a1);
}

void NLSearchParserSetLocale(uint64_t a1, const __CFLocale *a2)
{
  if (a1 && a2)
  {
    CFDictionaryRef v2 = *(SearchParser **)(a1 + 24);
    if (v2) {
      SearchParser::setLocale(v2, a2);
    }
  }
}

CFComparisonResult NLSearchParserSetContext(CFComparisonResult result, const __CFString *a2)
{
  if (result && a2)
  {
    uint64_t v2 = *(void *)(result + 24);
    if (v2)
    {
      uint64_t result = NL::ParserResources::setContext(*(NL::ParserResources **)(v2 + 40), a2);
      *(_DWORD *)(*(void *)(v2 + 24) + 4nlp::CFScopedPtr<__CFString const*>::reset(this + 1, 0) = *(_DWORD *)(*(void *)(v2 + 40) + 32);
    }
  }
  return result;
}

uint64_t NLSearchParserSetIndex(uint64_t result, uint64_t a2)
{
  if (result && a2)
  {
    uint64_t v2 = *(void *)(result + 24);
    if (v2) {
      *(void *)(*(void *)(v2 + 24) + 56) = a2;
    }
  }
  return result;
}

uint64_t NLSearchParserSetFutureDates(uint64_t result, int a2)
{
  if (result)
  {
    uint64_t v2 = *(void *)(result + 24);
    if (v2) {
      *(unsigned char *)(*(void *)(v2 + 24) + 66) = a2 != 0;
    }
  }
  return result;
}

void NLSearchParserSetCustomResourceDirectory(uint64_t a1, const __CFURL *a2)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 24);
    if (v2) {
      NL::ParserResources::setCustomResourcePath(*(const void ***)(v2 + 40), a2);
    }
  }
}

void NLSearchParserSetString(uint64_t a1, const __CFString *a2)
{
  if (a1 && a2)
  {
    uint64_t v2 = *(SearchParser **)(a1 + 24);
    if (v2) {
      SearchParser::setInput(v2, a2);
    }
  }
}

void NLSearchParserSetDate(uint64_t a1, CFTypeRef cf2)
{
  if (a1)
  {
    if (cf2)
    {
      uint64_t v3 = *(void *)(a1 + 24);
      if (v3)
      {
        NL::ParserResources::setDate(*(const void ***)(v3 + 40), cf2);
        CFTypeRef v4 = *(const void ***)(v3 + 24);
        NL::ParserContext::setDate(v4, (const __CFDate *)cf2);
      }
    }
  }
}

void NLSearchParserAppendString(uint64_t a1, CFStringRef theString)
{
  if (a1)
  {
    if (theString)
    {
      if (CFStringGetLength(theString))
      {
        CFTypeRef v4 = *(SearchParser **)(a1 + 24);
        if (v4)
        {
          SearchParser::addInput(v4, theString);
        }
      }
    }
  }
}

uint64_t NLSearchParserGetTokenCount(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(void *)(a1 + 24)) != 0) {
    return *(void *)(*(void *)(v1 + 48) + 256);
  }
  else {
    return -1;
  }
}

void NLSearchParserCopyParse()
{
}

void NLSearchParserCopyParseWithOptions()
{
}

void NLSearchParserEnumerateSuggestions(uint64_t a1, uint64_t a2, const __CFDictionary *a3, uint64_t a4)
{
  if (a1)
  {
    uint64_t v4 = *(void *)(a1 + 24);
    if (v4)
    {
      v5[0] = MEMORY[0x1E4F143A8];
      v5[1] = 0x40000000;
      v5[2] = __NLSearchParserEnumerateSuggestions_block_invoke;
      v5[3] = &unk_1E5B36F58;
      v5[4] = a4;
      SearchParser::enumerateSuggestions(v4, a2, a3, (uint64_t)v5);
    }
  }
}

uint64_t __NLSearchParserEnumerateSuggestions_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

CFStringRef NLSearchParseCandidateCopyDescription(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(void *)(a1 + 24)) != 0 && (v2 = *(const __CFString **)(v1 + 8)) != 0) {
    return CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v2);
  }
  else {
    return &stru_1EF7CF078;
  }
}

__CFArray *NLSearchParseCandidateCopyRankingTerms(uint64_t a1)
{
  v10[1] = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  uint64_t v1 = *(void *)(a1 + 24);
  if (!v1) {
    return 0;
  }
  CFDictionaryRef v2 = *(const __CFDictionary **)(v1 + 24);
  if (!v2) {
    return 0;
  }
  uint64_t Count = CFDictionaryGetCount(*(CFDictionaryRef *)(v1 + 24));
  MEMORY[0x1F4188790](Count);
  uint64_t v5 = (const void **)((char *)v10 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0));
  if (v4 >= 0x200) {
    size_t v6 = 512;
  }
  else {
    size_t v6 = v4;
  }
  bzero((char *)v10 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0), v6);
  CFDictionaryGetKeysAndValues(v2, v5, 0);
  CFMutableStringRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Count, MEMORY[0x1E4F1D510]);
  if (Count >= 1)
  {
    for (CFIndex i = 0; i != Count; ++i)
      CFArrayInsertValueAtIndex(Mutable, i, v5[i]);
  }
  v11.CFIndex location = 0;
  v11.CFIndex length = Count;
  CFArraySortValues(Mutable, v11, (CFComparatorFunction)compareRankTerms, v2);
  return Mutable;
}

CFComparisonResult compareRankTerms(const void *key, const void *a2, CFDictionaryRef theDict)
{
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, key);
  CFNumberRef v6 = (const __CFNumber *)CFDictionaryGetValue(theDict, a2);

  return CFNumberCompare(Value, v6, 0);
}

CFDictionaryRef NLSearchParseCandidateCopyRankTerms(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(void *)(a1 + 24)) != 0 && (v2 = *(const __CFDictionary **)(v1 + 24)) != 0) {
    return CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v2);
  }
  else {
    return 0;
  }
}

CFArrayRef NLSearchParseCandidateCopyAttributedInput(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(void *)(a1 + 24)) != 0 && (v2 = *(const __CFArray **)(v1 + 16)) != 0) {
    return CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v2);
  }
  else {
    return 0;
  }
}

CFDictionaryRef NLSearchParseCandidateCopyRankCategories(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(void *)(a1 + 24)) != 0 && (v2 = *(const __CFDictionary **)(v1 + 32)) != 0) {
    return CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v2);
  }
  else {
    return 0;
  }
}

CFDictionaryRef NLSearchParseCandidateCopyResultModifier(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(void *)(a1 + 24)) != 0 && (v2 = *(const __CFDictionary **)(v1 + 40)) != 0) {
    return CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v2);
  }
  else {
    return 0;
  }
}

uint64_t NLSearchParseGetConfidence(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 24);
    if (v1) {
      return *(unsigned int *)(v1 + 48);
    }
    else {
      return 0;
    }
  }
  return result;
}

BOOL NLSearchParseLanguageIsSupported(BOOL result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 24);
    return v1 && *(unsigned __int8 *)(v1 + 52) != 0;
  }
  return result;
}

void SearchParserWrapper::~SearchParserWrapper(SearchParserWrapper *this)
{
  SearchParserWrapper::~SearchParserWrapper(this);

  JUMPOUT(0x1A625B130);
}

{
  SearchParser *v2;
  uint64_t vars8;

  *(void *)this = &unk_1EF7CCB70;
  CFDictionaryRef v2 = (SearchParser *)*((void *)this + 1);
  if (v2)
  {
    SearchParser::~SearchParser(v2);
    MEMORY[0x1A625B130]();
  }

  NLAbstractOrthographyConvertor::~NLAbstractOrthographyConvertor(this);
}

void SearchParseCandidateWrapper::~SearchParseCandidateWrapper(SearchParseCandidateWrapper *this)
{
  SearchParseCandidateWrapper::~SearchParseCandidateWrapper(this);

  JUMPOUT(0x1A625B130);
}

{
  const void **v2;
  uint64_t vars8;

  *(void *)this = &unk_1EF7CD7F0;
  CFDictionaryRef v2 = (const void **)*((void *)this + 1);
  if (v2)
  {
    SearchParseCandidate::~SearchParseCandidate(v2);
    MEMORY[0x1A625B130]();
  }

  NLAbstractOrthographyConvertor::~NLAbstractOrthographyConvertor(this);
}

void *_ZNSt3__115allocate_sharedB8ne180100IN2NL13ParserContextENS_9allocatorIS2_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_@<X0>(void *a1@<X8>)
{
  CFDictionaryRef v2 = operator new(0x90uLL);
  uint64_t result = _ZNSt3__120__shared_ptr_emplaceIN2NL13ParserContextENS_9allocatorIS2_EEEC2B8ne180100IJES4_Li0EEES4_DpOT_(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_1A43D6950(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *_ZNSt3__120__shared_ptr_emplaceIN2NL13ParserContextENS_9allocatorIS2_EEEC2B8ne180100IJES4_Li0EEES4_DpOT_(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1EF7CE690;
  NL::ParserContext::ParserContext((NL::ParserContext *)(a1 + 3));
  return a1;
}

void sub_1A43D69AC(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<NL::ParserContext>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7CE690;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<NL::ParserContext>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7CE690;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A625B130);
}

void std::__shared_ptr_emplace<NL::ParserContext>::__on_zero_shared(uint64_t a1)
{
  std::allocator<NL::ParserContext>::destroy[abi:ne180100]((uint64_t)&v1, a1 + 24);
}

void std::allocator<NL::ParserContext>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
  std::__tree<std::string>::destroy(a2 + 96, *(char **)(a2 + 104));
  std::__tree<std::__value_type<__CFString const*,__CFString const*>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,__CFString const*>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,__CFString const*>>>::destroy(a2 + 72, *(void **)(a2 + 80));
  nlp::CFScopedPtr<__CFDictionary const*>::reset((const void **)(a2 + 32), 0);
  nlp::CFScopedPtr<__CFDictionary const*>::reset((const void **)(a2 + 24), 0);
  nlp::CFScopedPtr<__CFString const*>::reset((const void **)(a2 + 16), 0);
  nlp::CFScopedPtr<__CFLocale const*>::reset((const void **)(a2 + 8), 0);

  nlp::CFScopedPtr<__CFDate const*>::reset((const void **)a2, 0);
}

void *std::allocate_shared[abi:ne180100]<NL::QueryTokenizer,std::allocator<NL::QueryTokenizer>,std::shared_ptr<NL::ParserContext> &,void>@<X0>(uint64_t *a1@<X1>, void *a2@<X8>)
{
  unint64_t v4 = operator new(0x120uLL);
  uint64_t result = std::__shared_ptr_emplace<NL::QueryTokenizer>::__shared_ptr_emplace[abi:ne180100]<std::shared_ptr<NL::ParserContext> &,std::allocator<NL::QueryTokenizer>,0>(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1A43D6B28(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<NL::QueryTokenizer>::__shared_ptr_emplace[abi:ne180100]<std::shared_ptr<NL::ParserContext> &,std::allocator<NL::QueryTokenizer>,0>(void *a1, uint64_t *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1EF7CE770;
  std::allocator<NL::QueryTokenizer>::construct[abi:ne180100]<NL::QueryTokenizer,std::shared_ptr<NL::ParserContext> &>((uint64_t)&v4, (uint64_t)(a1 + 3), a2);
  return a1;
}

void sub_1A43D6B98(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<NL::QueryTokenizer>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7CE770;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<NL::QueryTokenizer>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7CE770;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A625B130);
}

void std::__shared_ptr_emplace<NL::QueryTokenizer>::__on_zero_shared(uint64_t a1)
{
}

void std::allocator<NL::QueryTokenizer>::construct[abi:ne180100]<NL::QueryTokenizer,std::shared_ptr<NL::ParserContext> &>(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3 = (std::__shared_weak_count *)a3[1];
  uint64_t v4 = *a3;
  uint64_t v5 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  NL::QueryTokenizer::QueryTokenizer(a2, &v4);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
}

void sub_1A43D6C80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void *std::allocate_shared[abi:ne180100]<NL::SpotlightParseFormatter,std::allocator<NL::SpotlightParseFormatter>,std::shared_ptr<NL::ParserContext> &,std::shared_ptr<NL::QueryTokenizer> &,void>@<X0>(uint64_t *a1@<X1>, uint64_t *a2@<X2>, void *a3@<X8>)
{
  CFNumberRef v6 = operator new(0x150uLL);
  uint64_t result = std::__shared_ptr_emplace<NL::SpotlightParseFormatter>::__shared_ptr_emplace[abi:ne180100]<std::shared_ptr<NL::ParserContext> &,std::shared_ptr<NL::QueryTokenizer> &,std::allocator<NL::SpotlightParseFormatter>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_1A43D6CE8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<NL::SpotlightParseFormatter>::__shared_ptr_emplace[abi:ne180100]<std::shared_ptr<NL::ParserContext> &,std::shared_ptr<NL::QueryTokenizer> &,std::allocator<NL::SpotlightParseFormatter>,0>(void *a1, uint64_t *a2, uint64_t *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1EF7CE850;
  std::allocator<NL::SpotlightParseFormatter>::construct[abi:ne180100]<NL::SpotlightParseFormatter,std::shared_ptr<NL::ParserContext> &,std::shared_ptr<NL::QueryTokenizer> &>((uint64_t)&v5, (uint64_t)(a1 + 3), a2, a3);
  return a1;
}

void sub_1A43D6D5C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<NL::SpotlightParseFormatter>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7CE850;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<NL::SpotlightParseFormatter>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7CE850;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A625B130);
}

uint64_t std::__shared_ptr_emplace<NL::SpotlightParseFormatter>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::allocator<NL::SpotlightParseFormatter>::construct[abi:ne180100]<NL::SpotlightParseFormatter,std::shared_ptr<NL::ParserContext> &,std::shared_ptr<NL::QueryTokenizer> &>(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v4 = (std::__shared_weak_count *)a3[1];
  uint64_t v8 = *a3;
  uint64_t v9 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  char v5 = (std::__shared_weak_count *)a4[1];
  uint64_t v6 = *a4;
  uint64_t v7 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  NL::SpotlightParseFormatter::SpotlightParseFormatter(a2, &v8, &v6);
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v9);
  }
}

void sub_1A43D6E88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(exception_object);
}

void *std::allocate_shared[abi:ne180100]<NL::ParseFormatter,std::allocator<NL::ParseFormatter>,std::shared_ptr<NL::ParserContext> &,std::shared_ptr<NL::QueryTokenizer> &,void>@<X0>(uint64_t *a1@<X1>, uint64_t *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0xA8uLL);
  uint64_t result = std::__shared_ptr_emplace<NL::ParseFormatter>::__shared_ptr_emplace[abi:ne180100]<std::shared_ptr<NL::ParserContext> &,std::shared_ptr<NL::QueryTokenizer> &,std::allocator<NL::ParseFormatter>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_1A43D6EFC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<NL::ParseFormatter>::__shared_ptr_emplace[abi:ne180100]<std::shared_ptr<NL::ParserContext> &,std::shared_ptr<NL::QueryTokenizer> &,std::allocator<NL::ParseFormatter>,0>(void *a1, uint64_t *a2, uint64_t *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1EF7CE738;
  std::allocator<NL::ParseFormatter>::construct[abi:ne180100]<NL::ParseFormatter,std::shared_ptr<NL::ParserContext> &,std::shared_ptr<NL::QueryTokenizer> &>((uint64_t)&v5, (uint64_t)(a1 + 3), a2, a3);
  return a1;
}

void sub_1A43D6F70(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<NL::ParseFormatter>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7CE738;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<NL::ParseFormatter>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7CE738;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A625B130);
}

uint64_t std::__shared_ptr_emplace<NL::ParseFormatter>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::allocator<NL::ParseFormatter>::construct[abi:ne180100]<NL::ParseFormatter,std::shared_ptr<NL::ParserContext> &,std::shared_ptr<NL::QueryTokenizer> &>(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v4 = (std::__shared_weak_count *)a3[1];
  uint64_t v8 = *a3;
  uint64_t v9 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  char v5 = (std::__shared_weak_count *)a4[1];
  uint64_t v6 = *a4;
  uint64_t v7 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  NL::ParseFormatter::ParseFormatter(a2, &v8, &v6);
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v9);
  }
}

void sub_1A43D709C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(exception_object);
}

id dateComponentsForDate(void *a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  id v2 = objc_alloc_init(MEMORY[0x1E4F1C9D8]);
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  uint64_t v3 = objc_msgSend(a1, "allKeys", 0);
  uint64_t v4 = [v3 countByEnumeratingWithState:&v11 objects:v15 count:16];
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = *(void *)v12;
    do
    {
      for (uint64_t i = 0; i != v5; ++i)
      {
        if (*(void *)v12 != v6) {
          objc_enumerationMutation(v3);
        }
        uint64_t v8 = *(void **)(*((void *)&v11 + 1) + 8 * i);
        int v9 = objc_msgSend((id)objc_msgSend(a1, "objectForKey:", v8), "intValue");
        if ([v8 isEqualToString:@"d"])
        {
          [v2 setDay:v9];
        }
        else if ([v8 isEqualToString:@"E"])
        {
          [v2 setWeekday:v9];
        }
        else if ([v8 isEqualToString:@"F"])
        {
          [v2 setWeekdayOrdinal:v9];
        }
        else if ([v8 isEqualToString:@"M"])
        {
          [v2 setMonth:v9];
        }
        else if ([v8 isEqualToString:@"y"])
        {
          [v2 setYear:v9];
        }
        else if ([v8 isEqualToString:@"W"])
        {
          [v2 setWeekOfMonth:v9];
        }
        else if ([v8 isEqualToString:@"w"])
        {
          [v2 setWeekOfYear:v9];
        }
        else if ([v8 isEqualToString:@"Y"])
        {
          [v2 setYearForWeekOfYear:v9];
        }
        else if ([v8 isEqualToString:@"H"])
        {
          [v2 setHour:v9];
        }
        else if ([v8 isEqualToString:@"m"])
        {
          [v2 setMinute:v9];
        }
        else if ([v8 isEqualToString:@"s"])
        {
          [v2 setSecond:v9];
        }
      }
      uint64_t v5 = [v3 countByEnumeratingWithState:&v11 objects:v15 count:16];
    }
    while (v5);
  }
  return v2;
}

void sub_1A43D767C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1A43D77A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__17(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__17(uint64_t a1)
{
}

void sub_1A43D7908(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1A43D7DDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1A43D8260(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

const void **NL::DateFormatter::DateFormatter(const void **a1, const void **a2)
{
  uint64_t v3 = (atomic_ullong *)a2[1];
  *a1 = *a2;
  a1[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit(v3 + 1, 1uLL, memory_order_relaxed);
  }
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 0;
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDateFormatterRef ISO8601Formatter = CFDateFormatterCreateISO8601Formatter((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0x333uLL);
  nlp::CFScopedPtr<__CFDateFormatter *>::reset(a1 + 2, ISO8601Formatter);
  CFLocaleRef v6 = (const __CFLocale *)*((void *)*a1 + 1);
  if (v6)
  {
    CFDateFormatterRef v7 = CFDateFormatterCreate(v4, v6, kCFDateFormatterShortStyle, kCFDateFormatterShortStyle);
    nlp::CFScopedPtr<__CFDateFormatter *>::reset(a1 + 4, v7);
    CFDateFormatterRef v8 = CFDateFormatterCreate(v4, *((CFLocaleRef *)*a1 + 1), kCFDateFormatterNoStyle, kCFDateFormatterNoStyle);
    nlp::CFScopedPtr<__CFDateFormatter *>::reset(a1 + 3, v8);
  }
  return a1;
}

void sub_1A43D83EC(_Unwind_Exception *a1)
{
  nlp::CFScopedPtr<__CFDateFormatter *>::reset(v4, 0);
  nlp::CFScopedPtr<__CFDateFormatter *>::reset(v3, 0);
  nlp::CFScopedPtr<__CFDateFormatter *>::reset(v2, 0);
  CFLocaleRef v6 = *(std::__shared_weak_count **)(v1 + 8);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
  _Unwind_Resume(a1);
}

__CFBundle *NL::DateFormatter::copyDisplayStringForStartAndEndDateComponents(__CFDateFormatter **this, __CFCalendar *a2, const __CFLocale *a3, const __CFDate *a4, const NL::DateComponents *a5, const NL::DateComponents *a6)
{
  BundleWithIdentifier = 0;
  if (!a2) {
    return BundleWithIdentifier;
  }
  if (!a3) {
    return BundleWithIdentifier;
  }
  BundleWithIdentifier = CFBundleGetBundleWithIdentifier(@"com.apple.NLP");
  if (!BundleWithIdentifier) {
    return BundleWithIdentifier;
  }
  double v21 = 0.0;
  if (!NL::DateComponents::isEmpty(a5))
  {
    if (NL::DateComponents::isEmpty(a6))
    {
      NL::DateComponents::getFullFormat(a5, a2, a4, &v21, &__p);
      CFStringRef v13 = copyDisplayDateForDateComponents(this[3], a2, a3, a4, a5, (uint64_t)&__p);
      goto LABEL_8;
    }
    NL::DateComponents::getShortFormat(a5, a2, a4, &v21, &__p);
    CFStringRef v15 = copyDisplayDateForDateComponents(this[4], a2, a3, a4, a5, (uint64_t)&__p);
    CFStringRef v19 = v15;
    NL::DateComponents::getShortFormat(a6, a2, a4, &v21, &v18);
    CFStringRef v16 = copyDisplayDateForDateComponents(this[4], a2, a3, a4, a6, (uint64_t)&v18);
    CFStringRef v17 = CFBundleCopyLocalizedString(BundleWithIdentifier, @"FROM_DATE_TO_DATE", @"FROM_DATE_TO_DATE", @"Localizable");
    if (v17)
    {
      BundleWithIdentifier = (__CFBundle *)NLPCreateStringWithValidatedFormat(@"%1@%2@", v17, v15, v16, v17, v16);
      CFRelease(v17);
      if (!v16) {
        goto LABEL_17;
      }
    }
    else
    {
      BundleWithIdentifier = 0;
      if (!v16)
      {
LABEL_17:
        if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v18.__r_.__value_.__l.__data_);
        }
        if (v15) {
          CFRelease(v15);
        }
        goto LABEL_9;
      }
    }
    CFRelease(v16);
    goto LABEL_17;
  }
  NL::DateComponents::getFullFormat(a6, a2, a4, &v21, &__p);
  CFStringRef v13 = copyDisplayDateForDateComponents(this[3], a2, a3, a4, a6, (uint64_t)&__p);
LABEL_8:
  BundleWithIdentifier = (__CFBundle *)v13;
LABEL_9:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return BundleWithIdentifier;
}

void sub_1A43D863C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, const void *a11, const void *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, const void *a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  nlp::CFScopedPtr<__CFString const*>::reset(&a19, 0);
  if (a25 < 0) {
    operator delete(a20);
  }
  _Unwind_Resume(a1);
}

CFStringRef copyDisplayDateForDateComponents(__CFDateFormatter *a1, __CFCalendar *a2, const __CFLocale *a3, const __CFDate *a4, NL::DateComponents *this, uint64_t a6)
{
  CFStringRef StringWithDate = 0;
  if (!a1 || !a2 || !a3) {
    return StringWithDate;
  }
  if (NL::DateComponents::isEmpty(this)) {
    return 0;
  }
  CFAbsoluteTime AbsoluteTime = NL::DateComponents::getAbsoluteTime(this, a2, a4);
  CFStringRef CFStringFromString = createCFStringFromString(a6);
  CFStringRef DateFormatFromTemplate = CFDateFormatterCreateDateFormatFromTemplate(0, CFStringFromString, 0, a3);
  CFDateFormatterSetFormat(a1, DateFormatFromTemplate);
  CFAllocatorRef v16 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDateRef v17 = CFDateCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], AbsoluteTime);
  if (!v17)
  {
    CFStringRef StringWithDate = 0;
    if (!DateFormatFromTemplate) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  CFStringRef StringWithDate = CFDateFormatterCreateStringWithDate(v16, a1, v17);
  CFRelease(v17);
  if (DateFormatFromTemplate) {
LABEL_10:
  }
    CFRelease(DateFormatFromTemplate);
LABEL_11:
  if (CFStringFromString) {
    CFRelease(CFStringFromString);
  }
  return StringWithDate;
}

void sub_1A43D87F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, const void *);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, const void *);
  nlp::CFScopedPtr<__CFDate const*>::reset((const void **)va, 0);
  nlp::CFScopedPtr<__CFString const*>::reset((const void **)va1, 0);
  nlp::CFScopedPtr<__CFString const*>::reset((const void **)va2, 0);
  _Unwind_Resume(a1);
}

__CFBundle *NL::DateFormatter::copyDisplayStringForStartAndEndDateAndFreqComponents(NL::DateFormatter *this, __CFCalendar *a2, const __CFLocale *a3, const __CFDate *a4, const NL::DateComponents *a5, const NL::DateComponents *a6, const __CFString *a7)
{
  BundleWithIdentifier = 0;
  if (a2)
  {
    if (a3)
    {
      if (a7)
      {
        BundleWithIdentifier = CFBundleGetBundleWithIdentifier(@"com.apple.NLP");
        if (BundleWithIdentifier)
        {
          CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0, a7, @"::");
          CFArrayRef v33 = ArrayBySeparatingStrings;
          if (CFArrayGetCount(ArrayBySeparatingStrings) != 2)
          {
            BundleWithIdentifier = 0;
            if (!ArrayBySeparatingStrings) {
              return BundleWithIdentifier;
            }
            goto LABEL_20;
          }
          NL::DatePeriod::DatePeriod((NL::DatePeriod *)v28);
          NL::DatePeriod::setLocale(v28, a3);
          NL::DatePeriod::setCurrentDate(v28, a4);
          CFStringRef v16 = (const __CFString *)MEMORY[0x1A625A0E0](a2);
          NL::DatePeriod::setCalendarWithIdentifier(v28, v16);
          CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, 0);
          NL::DatePeriod::setDisplayKey(v28, ValueAtIndex);
          long long v18 = *((_OWORD *)a5 + 1);
          long long v29 = *(_OWORD *)a5;
          long long v30 = v18;
          long long v19 = *((_OWORD *)a5 + 3);
          long long v31 = *((_OWORD *)a5 + 2);
          long long v32 = v19;
          CFStringRef v20 = (const __CFString *)NL::DateFormatter::copyDisplayForDate(this, (const NL::DatePeriod *)v28, 0, 0);
          long long v21 = *((_OWORD *)a6 + 1);
          long long v29 = *(_OWORD *)a6;
          long long v30 = v21;
          long long v22 = *((_OWORD *)a6 + 3);
          long long v31 = *((_OWORD *)a6 + 2);
          long long v32 = v22;
          CFStringRef v23 = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, 1);
          NL::DatePeriod::setDisplayKey(v28, v23);
          uint64_t v24 = (const void *)NL::DateFormatter::copyDisplayForDate(this, (const NL::DatePeriod *)v28, 0, 0);
          CFStringRef v25 = CFBundleCopyLocalizedString(BundleWithIdentifier, @"EVERY_DATE_TO_DATE", @"EVERY_DATE_TO_DATE", @"Localizable");
          if (v25)
          {
            if (CFStringHasPrefix(v20, @"Every"))
            {
              BundleWithIdentifier = (__CFBundle *)NLPCreateStringWithValidatedFormat(@"%1@%2@", v25, v20, v24);
            }
            else
            {
              CFStringRef v26 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Every %@", v20);
              BundleWithIdentifier = (__CFBundle *)NLPCreateStringWithValidatedFormat(@"%1@%2@", v25, v26, v24, v26, v25, v24, v20);
              if (v26) {
                CFRelease(v26);
              }
            }
            CFRelease(v25);
          }
          else
          {
            BundleWithIdentifier = 0;
          }
          if (v24) {
            CFRelease(v24);
          }
          if (v20) {
            CFRelease(v20);
          }
          NL::DatePeriod::~DatePeriod(v28);
          if (ArrayBySeparatingStrings) {
LABEL_20:
          }
            CFRelease(ArrayBySeparatingStrings);
        }
      }
    }
  }
  return BundleWithIdentifier;
}

void sub_1A43D8AA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va4, a3);
  va_start(va3, a3);
  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v5 = va_arg(va1, const void *);
  va_copy(va2, va1);
  CFDateFormatterRef v7 = va_arg(va2, const void *);
  va_copy(va3, va2);
  int v9 = va_arg(va3, const void *);
  va_copy(va4, va3);
  long long v11 = va_arg(va4, const void *);
  nlp::CFScopedPtr<__CFString const*>::reset((const void **)va, 0);
  nlp::CFScopedPtr<__CFString const*>::reset((const void **)va1, 0);
  nlp::CFScopedPtr<__CFString const*>::reset((const void **)va2, 0);
  nlp::CFScopedPtr<__CFString const*>::reset((const void **)va3, 0);
  NL::DatePeriod::~DatePeriod((const void **)va4);
  nlp::CFScopedPtr<__CFArray const*>::reset((const void **)(v3 - 88), 0);
  _Unwind_Resume(a1);
}

__CFDateFormatter **NL::DateFormatter::copyDisplayForDate(__CFDateFormatter **this, const NL::DatePeriod *a2, unsigned int a3, int a4)
{
  if (*((void *)a2 + 1)) {
    BOOL v4 = *(void *)a2 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4) {
    return 0;
  }
  if (!*((void *)a2 + 2)) {
    return 0;
  }
  CFBundleRef BundleWithIdentifier = CFBundleGetBundleWithIdentifier(@"com.apple.NLP");
  if (!BundleWithIdentifier) {
    return 0;
  }
  uint64_t v10 = BundleWithIdentifier;
  CFStringRef v49 = 0;
  char v50 = 0;
  memset(v48, 0, sizeof(v48));
  memset(v47, 0, sizeof(v47));
  NL::DatePeriod::resolveDateComponents(a2, (NL::DateComponents *)v48, (NL::DateComponents *)v47, a3, a4);
  if (CFStringFind((CFStringRef)*(void *)a2, @"::", 0).location != -1)
  {
    long long v11 = (__CFCalendar *)*((void *)a2 + 1);
    CFLocaleRef v12 = (const __CFLocale *)*((void *)a2 + 2);
    CFDateRef v13 = (const __CFDate *)*((void *)a2 + 28);
    CFStringRef v14 = *(const __CFString **)a2;
    goto LABEL_9;
  }
  if (CFStringFind((CFStringRef)*(void *)a2, @":", 0).location != -1)
  {
    BOOL isEmpty = NL::DateComponents::isEmpty((NL::DateComponents *)v47);
    long long v11 = (__CFCalendar *)*((void *)a2 + 1);
    CFLocaleRef v12 = (const __CFLocale *)*((void *)a2 + 2);
    CFDateRef v13 = (const __CFDate *)*((void *)a2 + 28);
    CFStringRef v14 = *(const __CFString **)a2;
    if (isEmpty)
    {
      CFStringRef v15 = NL::DateFormatter::copyDisplayStringForEveryOrdinalISODateComponents((NL::DateFormatter *)this, v11, v12, v13, (const NL::DateComponents *)v48, *(const __CFString **)a2);
      goto LABEL_10;
    }
LABEL_9:
    CFStringRef v15 = NL::DateFormatter::copyDisplayStringForStartAndEndDateAndFreqComponents((NL::DateFormatter *)this, v11, v12, v13, (const NL::DateComponents *)v48, (const NL::DateComponents *)v47, v14);
LABEL_10:
    this = (__CFDateFormatter **)v15;
    goto LABEL_11;
  }
  if (CFStringHasPrefix(*(CFStringRef *)a2, @"VAL"))
  {
    CFAllocatorRef v18 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(CFStringRef *)a2, @"-");
    theArray[0] = ArrayBySeparatingStrings;
    if (ArrayBySeparatingStrings && CFArrayGetCount(ArrayBySeparatingStrings) == 2)
    {
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(theArray[0], 1);
      CFTypeRef v21 = CFRetain(ValueAtIndex);
      nlp::CFScopedPtr<__CFString const*>::reset((const void **)&v49, v21);
      CFStringRef v22 = (const __CFString *)CFArrayGetValueAtIndex(theArray[0], 0);
      v51.CFIndex length = CFStringGetLength(v22) - 4;
      v51.CFIndex location = 4;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)CFStringCreateWithSubstring(v18, v22, v51);
      IntCFNumberRef Value = CFStringGetIntValue((CFStringRef)__p.__r_.__value_.__l.__data_);
      nlp::CFScopedPtr<__CFString const*>::reset((const void **)&__p.__r_.__value_.__l.__data_, 0);
    }
    else
    {
      IntCFNumberRef Value = 0;
    }
    nlp::CFScopedPtr<__CFArray const*>::reset((const void **)theArray, 0);
  }
  else
  {
    if (CFStringsAreEqual(*(const __CFString **)a2, @"FORMATTED")
      || CFStringHasSuffix(*(CFStringRef *)a2, @"HOLIDAY"))
    {
      if (!NL::DateComponents::isEmpty((NL::DateComponents *)v48)
        && !NL::DateComponents::isEmpty((NL::DateComponents *)v47))
      {
        CFStringRef v15 = NL::DateFormatter::copyDisplayStringForStartAndEndDateComponents(this, *((__CFCalendar **)a2 + 1), *((const __CFLocale **)a2 + 2), *((const __CFDate **)a2 + 28), (const NL::DateComponents *)v48, (const NL::DateComponents *)v47);
        goto LABEL_10;
      }
      double v46 = 0.0;
      uint64_t v24 = (_OWORD *)((char *)a2 + 28);
      if (a4) {
        uint64_t v24 = v48;
      }
      long long v25 = v24[1];
      *(_OWORD *)CFArrayRef theArray = *v24;
      long long v43 = v25;
      long long v26 = v24[3];
      long long v44 = v24[2];
      long long v45 = v26;
      NL::DateComponents::getFullFormat((NL::DateComponents *)theArray, *((__CFCalendar **)a2 + 1), *((const __CFDate **)a2 + 28), &v46, &__p);
      CFStringRef v27 = copyDisplayDateForDateComponents(this[3], *((__CFCalendar **)a2 + 1), *((const __CFLocale **)a2 + 2), *((const __CFDate **)a2 + 28), (NL::DateComponents *)theArray, (uint64_t)&__p);
      nlp::CFScopedPtr<__CFString const*>::reset(&v50, v27);
      BOOL v28 = a3 >= 4 || v50 == 0;
      char v29 = !v28;
      if (!v28) {
        this = (__CFDateFormatter **)CFRetain(v50);
      }
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (v29) {
        goto LABEL_11;
      }
    }
    else if (CFStringHasPrefix(*(CFStringRef *)a2, @"EVERY") {
           && !NL::DateComponents::isEmpty((NL::DateComponents *)v48)
    }
           && NL::DateComponents::isEmpty((NL::DateComponents *)v47))
    {
      double v46 = 0.0;
      NL::DateComponents::getFullFormat((const NL::DatePeriod *)((char *)a2 + 28), *((__CFCalendar **)a2 + 1), *((const __CFDate **)a2 + 28), &v46, &__p);
      long long v31 = v48;
      if (!a4) {
        long long v31 = (_OWORD *)((char *)a2 + 28);
      }
      long long v32 = v31[1];
      *(_OWORD *)CFArrayRef theArray = *v31;
      long long v43 = v32;
      long long v33 = v31[3];
      long long v44 = v31[2];
      long long v45 = v33;
      CFStringRef v34 = copyDisplayDateForDateComponents(this[3], *((__CFCalendar **)a2 + 1), *((const __CFLocale **)a2 + 2), *((const __CFDate **)a2 + 28), (NL::DateComponents *)theArray, (uint64_t)&__p);
      nlp::CFScopedPtr<__CFString const*>::reset(&v50, v34);
      uint64_t v35 = v50;
      if (v50)
      {
        CFStringRef v40 = CFBundleCopyLocalizedString(v10, *(CFStringRef *)a2, *(CFStringRef *)a2, @"Localizable");
        this = (__CFDateFormatter **)NLPCreateStringWithValidatedFormat(@"%@", v40, v50);
        nlp::CFScopedPtr<__CFString const*>::reset((const void **)&v40, 0);
      }
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (v35) {
        goto LABEL_11;
      }
    }
    IntCFNumberRef Value = 0;
  }
  switch(a3)
  {
    case 4u:
      if (v49)
      {
        CFStringRef v30 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"BEFORE_%@", v49);
        break;
      }
      if (!v50) {
        goto LABEL_72;
      }
      CFStringRef v30 = @"BEFORE_DATE";
      break;
    case 5u:
      if (v49)
      {
        CFStringRef v30 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"AFTER_%@", v49);
        break;
      }
      if (!v50) {
        goto LABEL_70;
      }
      CFStringRef v30 = @"AFTER_DATE";
      break;
    case 6u:
      if (v49)
      {
        CFStringRef v30 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"SINCE_%@", v49);
      }
      else if (v50)
      {
        CFStringRef v30 = @"SINCE_DATE";
      }
      else
      {
LABEL_70:
        CFStringRef v30 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"AFTER_%@", *(void *)a2);
      }
      break;
    case 7u:
      if (v49)
      {
        CFStringRef v30 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"TO_%@", v49);
      }
      else if (v50)
      {
        CFStringRef v30 = @"TO_DATE";
      }
      else
      {
LABEL_72:
        CFStringRef v30 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"BEFORE_%@", *(void *)a2);
      }
      break;
    default:
      goto LABEL_74;
  }
  nlp::CFScopedPtr<__CFString const*>::reset((const void **)&v49, v30);
LABEL_74:
  CFStringRef v36 = v49;
  if (v49
    || (CFTypeRef v37 = CFRetain(*(CFTypeRef *)a2),
        nlp::CFScopedPtr<__CFString const*>::reset((const void **)&v49, v37),
        (CFStringRef v36 = v49) != 0))
  {
    CFArrayRef v38 = (const __CFArray *)CFBundleCopyLocalizedString(v10, v36, v36, @"Localizable");
    theArray[0] = v38;
    if (v38)
    {
      if (IntValue) {
        char v39 = (NL::DateFormatter *)NLPCreateStringWithValidatedFormat(@"%d", (CFStringRef)v38, IntValue);
      }
      else {
        char v39 = (NL::DateFormatter *)NLPCreateStringWithValidatedFormat(@"%@", (CFStringRef)v38, v50);
      }
      this = (__CFDateFormatter **)v39;
      nlp::CFScopedPtr<__CFString const*>::reset((const void **)theArray, 0);
    }
    else
    {
      nlp::CFScopedPtr<__CFString const*>::reset((const void **)theArray, 0);
      this = 0;
    }
LABEL_11:
    if (v49) {
      CFRelease(v49);
    }
    goto LABEL_13;
  }
  this = 0;
LABEL_13:
  if (v50) {
    CFRelease(v50);
  }
  return this;
}

void sub_1A43D91B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, const void *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18)
{
  nlp::CFScopedPtr<__CFString const*>::reset(&a11, 0);
  if (a17 < 0) {
    operator delete(__p);
  }
  nlp::CFScopedPtr<__CFString const*>::reset((const void **)(v18 - 80), 0);
  nlp::CFScopedPtr<__CFString const*>::reset((const void **)(v18 - 72), 0);
  _Unwind_Resume(a1);
}

__CFBundle *NL::DateFormatter::copyDisplayStringForEveryOrdinalISODateComponents(NL::DateFormatter *this, __CFCalendar *a2, const __CFLocale *a3, const __CFDate *a4, const NL::DateComponents *a5, const __CFString *a6)
{
  CFBundleRef BundleWithIdentifier = 0;
  if (a2)
  {
    if (a3)
    {
      if (a6)
      {
        CFBundleRef BundleWithIdentifier = CFBundleGetBundleWithIdentifier(@"com.apple.NLP");
        if (BundleWithIdentifier)
        {
          CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0, a6, @":");
          CFArrayRef v37 = ArrayBySeparatingStrings;
          if (CFArrayGetCount(ArrayBySeparatingStrings) == 3)
          {
            NL::DatePeriod::DatePeriod((NL::DatePeriod *)v32);
            NL::DatePeriod::setLocale(v32, a3);
            NL::DatePeriod::setCurrentDate(v32, a4);
            CFStringRef v14 = (const __CFString *)MEMORY[0x1A625A0E0](a2);
            NL::DatePeriod::setCalendarWithIdentifier(v32, v14);
            CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(ArrayBySeparatingStrings, 0);
            CFStringRef v16 = CFArrayGetValueAtIndex(ArrayBySeparatingStrings, 1);
            CFAllocatorRef v17 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
            CFStringRef v18 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@ %@", ValueAtIndex, v16);
            NL::DatePeriod::setDisplayKey(v32, v18);
            long long v19 = *((_OWORD *)a5 + 1);
            long long v33 = *(_OWORD *)a5;
            long long v34 = v19;
            long long v20 = *((_OWORD *)a5 + 3);
            long long v35 = *((_OWORD *)a5 + 2);
            long long v36 = v20;
            CFTypeRef v21 = (const void *)NL::DateFormatter::copyDisplayForDate(this, (const NL::DatePeriod *)v32, 0, 0);
            CFStringRef v22 = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, 2);
            NL::DatePeriod::setDisplayKey(v32, v22);
            CFStringRef v23 = (const void *)NL::DateFormatter::copyDisplayForDate(this, (const NL::DatePeriod *)v32, 0, 0);
            CFBundleRef BundleWithIdentifier = (__CFBundle *)CFStringCreateWithFormat(v17, 0, @"%@ %@", v21, v23);
            if (v23) {
              CFRelease(v23);
            }
            if (v21) {
LABEL_19:
            }
              CFRelease(v21);
LABEL_20:
            NL::DatePeriod::~DatePeriod(v32);
            if (!ArrayBySeparatingStrings) {
              return BundleWithIdentifier;
            }
            goto LABEL_23;
          }
          if (CFArrayGetCount(ArrayBySeparatingStrings) == 2)
          {
            NL::DatePeriod::DatePeriod((NL::DatePeriod *)v32);
            NL::DatePeriod::setLocale(v32, a3);
            NL::DatePeriod::setCurrentDate(v32, a4);
            CFStringRef v24 = (const __CFString *)MEMORY[0x1A625A0E0](a2);
            NL::DatePeriod::setCalendarWithIdentifier(v32, v24);
            CFStringRef v25 = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, 1);
            NL::DatePeriod::setDisplayKey(v32, v25);
            long long v26 = *((_OWORD *)a5 + 1);
            long long v33 = *(_OWORD *)a5;
            long long v34 = v26;
            long long v27 = *((_OWORD *)a5 + 3);
            long long v35 = *((_OWORD *)a5 + 2);
            long long v36 = v27;
            CFTypeRef v21 = (const void *)NL::DateFormatter::copyDisplayForDate(this, (const NL::DatePeriod *)v32, 0, 0);
            CFStringRef v28 = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, 0);
            NL::DatePeriod::setDisplayKey(v32, v28);
            char v29 = (const void *)NL::DateFormatter::copyDisplayForDate(this, (const NL::DatePeriod *)v32, 0, 0);
            CFStringRef v30 = CFBundleCopyLocalizedString(BundleWithIdentifier, @"EVERY_ORDINAL_FORMATTED_DATE", @"EVERY_ORDINAL_FORMATTED_DATE", @"Localizable");
            CFBundleRef BundleWithIdentifier = 0;
            if (v30)
            {
              if (v29 && v21) {
                CFBundleRef BundleWithIdentifier = (__CFBundle *)NLPCreateStringWithValidatedFormat(@"%1@%2@", v30, v29, v21);
              }
              CFRelease(v30);
            }
            if (v29) {
              CFRelease(v29);
            }
            if (v21) {
              goto LABEL_19;
            }
            goto LABEL_20;
          }
          CFBundleRef BundleWithIdentifier = 0;
          if (ArrayBySeparatingStrings) {
LABEL_23:
          }
            CFRelease(ArrayBySeparatingStrings);
        }
      }
    }
  }
  return BundleWithIdentifier;
}

void sub_1A43D9598(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va3, a4);
  va_start(va2, a4);
  va_start(va1, a4);
  va_start(va, a4);
  CFLocaleRef v6 = va_arg(va1, const void *);
  va_copy(va2, va1);
  CFDateFormatterRef v8 = va_arg(va2, const void *);
  va_copy(va3, va2);
  uint64_t v10 = va_arg(va3, const void *);
  nlp::CFScopedPtr<__CFString const*>::reset((const void **)va, 0);
  nlp::CFScopedPtr<__CFString const*>::reset((const void **)va1, 0);
  nlp::CFScopedPtr<__CFString const*>::reset((const void **)va2, 0);
  NL::DatePeriod::~DatePeriod((const void **)va3);
  nlp::CFScopedPtr<__CFArray const*>::reset((const void **)(v4 - 72), 0);
  _Unwind_Resume(a1);
}

CFStringRef NL::DateFormatter::copyISODisplayForDateComponents(NL::DateFormatter *this, __CFCalendar *a2, const NL::DateComponents *a3)
{
  if (NL::DateComponents::isEmpty(a3)) {
    return 0;
  }
  CFAbsoluteTime at = 0.0;
  NL::DateComponents::getShortFormat(a3, a2, **(const __CFDate ***)this, &at, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDateRef v7 = CFDateCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], at);
  if (!v7) {
    return 0;
  }
  CFDateRef v8 = v7;
  CFStringRef StringWithDate = CFDateFormatterCreateStringWithDate(v6, *((CFDateFormatterRef *)this + 2), v7);
  CFRelease(v8);
  return StringWithDate;
}

void sub_1A43D96FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  nlp::CFScopedPtr<__CFDate const*>::reset((const void **)va, 0);
  _Unwind_Resume(a1);
}

__CFBundle *NL::DateFormatter::copyDisplayStringWithStartAndEndDateForRange(NL::DateFormatter *this, const __CFString *a2, int a3, const __CFString *a4, int a5)
{
  CFArrayRef Copy = 0;
  if (!a2) {
    return Copy;
  }
  if (!a4) {
    return Copy;
  }
  CFBundleRef BundleWithIdentifier = CFBundleGetBundleWithIdentifier(@"com.apple.NLP");
  CFArrayRef Copy = BundleWithIdentifier;
  if (!BundleWithIdentifier) {
    return Copy;
  }
  CFStringRef v30 = 0;
  CFTypeRef cf = 0;
  if (a3 == 1)
  {
    CFStringRef v12 = (const __CFString *)CFRetain(a2);
    CFStringRef v30 = v12;
  }
  else if (a3 == 3)
  {
    if (!a5)
    {
      CFStringRef v18 = CFBundleCopyLocalizedString(BundleWithIdentifier, @"TO_DATE", @"TO_DATE", @"Localizable");
      if (v18)
      {
        CFStringRef v19 = NLPCreateStringWithValidatedFormat(@"%@", v18, a2);
        nlp::CFScopedPtr<__CFString const*>::reset(&cf, v19);
        CFRelease(v18);
      }
      goto LABEL_28;
    }
    CFStringRef v11 = CFBundleCopyLocalizedString(BundleWithIdentifier, @"FROM_DATE", @"FROM_DATE", @"Localizable");
    if (v11)
    {
      CFTypeRef cf = NLPCreateStringWithValidatedFormat(@"%@", v11, a2);
      CFRelease(v11);
    }
    CFStringRef v12 = 0;
  }
  else
  {
    CFTypeRef v13 = CFRetain(a2);
    CFStringRef v12 = 0;
    CFTypeRef cf = v13;
  }
  if (a5 == 1)
  {
    if (v12)
    {
      CFTypeRef v16 = CFRetain(a4);
      CFTypeRef v17 = cf;
      if (cf) {
        goto LABEL_24;
      }
      goto LABEL_25;
    }
    CFStringRef v20 = (const __CFString *)CFRetain(a4);
LABEL_32:
    CFStringRef v12 = v20;
    CFStringRef v30 = v20;
    goto LABEL_33;
  }
  if (a5 == 3)
  {
    if (v12)
    {
      CFStringRef v14 = CFBundleCopyLocalizedString(Copy, @"FROM_DATE", @"FROM_DATE", @"Localizable");
      if (v14)
      {
        CFStringRef v15 = NLPCreateStringWithValidatedFormat(@"%@", v14, a4);
        if (cf) {
          CFRelease(cf);
        }
        CFTypeRef cf = v15;
        CFRelease(v14);
      }
    }
    else
    {
      CFStringRef v21 = CFBundleCopyLocalizedString(Copy, @"TO_DATE", @"TO_DATE", @"Localizable");
      if (v21)
      {
        CFStringRef v12 = NLPCreateStringWithValidatedFormat(@"%@", v21, a4);
        CFStringRef v30 = v12;
        CFRelease(v21);
      }
      else
      {
        CFStringRef v12 = 0;
      }
    }
    goto LABEL_33;
  }
  if (!v12)
  {
LABEL_28:
    CFStringRef v20 = (const __CFString *)CFRetain(a4);
    goto LABEL_32;
  }
  CFTypeRef v16 = CFRetain(a4);
  CFTypeRef v17 = cf;
  if (cf) {
LABEL_24:
  }
    CFRelease(v17);
LABEL_25:
  CFTypeRef cf = v16;
LABEL_33:
  CFStringRef v22 = CFBundleCopyLocalizedString(Copy, @"DATE1_DATE2", @"DATE1_DATE2", @"Localizable");
  CFStringRef v29 = v22;
  if (v22)
  {
    CFAllocatorRef v23 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    MutableCFArrayRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v22);
    CFStringRef v25 = (__CFString *)MutableCopy;
    CFStringRef theString = MutableCopy;
    if (MutableCopy)
    {
      CFStringRef v26 = (const __CFString *)cf;
      v32.CFIndex length = CFStringGetLength(MutableCopy);
      v32.CFIndex location = 0;
      CFStringFindAndReplace(v25, @"%@1", v26, v32, 0);
      v33.CFIndex length = CFStringGetLength(v25);
      v33.CFIndex location = 0;
      CFStringFindAndReplace(v25, @"%@2", v12, v33, 0);
      CFArrayRef Copy = (__CFBundle *)CFStringCreateCopy(v23, theString);
      CFRelease(theString);
    }
    else
    {
      CFArrayRef Copy = 0;
    }
    if (v29) {
      CFRelease(v29);
    }
  }
  else
  {
    CFArrayRef Copy = 0;
  }
  if (v30) {
    CFRelease(v30);
  }
  if (cf) {
    CFRelease(cf);
  }
  return Copy;
}

void sub_1A43D9A98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va2, a4);
  va_start(va1, a4);
  va_start(va, a4);
  uint64_t v5 = va_arg(va1, const void *);
  va_copy(va2, va1);
  CFDateRef v7 = va_arg(va2, const void *);
  nlp::CFScopedPtr<__CFString const*>::reset((const void **)va, 0);
  nlp::CFScopedPtr<__CFString const*>::reset((const void **)va1, 0);
  nlp::CFScopedPtr<__CFString const*>::reset((const void **)va2, 0);
  _Unwind_Resume(a1);
}

CFStringRef NL::DateFormatter::copyDisplayStringForDates(NL::DateFormatter *this, const __CFString *a2, const __CFString *a3)
{
  CFStringRef Copy = 0;
  if (a2 && a3)
  {
    CFBundleRef BundleWithIdentifier = CFBundleGetBundleWithIdentifier(@"com.apple.NLP");
    if (BundleWithIdentifier
      && (CFStringRef v7 = CFBundleCopyLocalizedString(BundleWithIdentifier, @"DATE1_DATE2", @"DATE1_DATE2", @"Localizable")) != 0)
    {
      CFStringRef v8 = v7;
      CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      MutableCFStringRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v7);
      CFStringRef v11 = (__CFString *)MutableCopy;
      if (MutableCopy)
      {
        v13.CFIndex length = CFStringGetLength(MutableCopy);
        v13.CFIndex location = 0;
        CFStringFindAndReplace(v11, @"%@1", a2, v13, 0);
        v14.CFIndex length = CFStringGetLength(v11);
        v14.CFIndex location = 0;
        CFStringFindAndReplace(v11, @"%@2", a3, v14, 0);
        CFStringRef Copy = CFStringCreateCopy(v9, v11);
        CFRelease(v11);
      }
      else
      {
        CFStringRef Copy = 0;
      }
      CFRelease(v8);
    }
    else
    {
      return 0;
    }
  }
  return Copy;
}

void sub_1A43D9C68(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  nlp::CFScopedPtr<__CFString const*>::reset((const void **)va, 0);
  _Unwind_Resume(a1);
}

__CFDictionary *NL::DateFormatter::copyComponentsForDateComponents(NL::DateFormatter *this, const NL::DateComponents *a2)
{
  if (NL::DateComponents::isEmpty(a2)) {
    return 0;
  }
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (*(_DWORD *)a2)
  {
    CFNumberRef v5 = CFNumberCreate(v4, kCFNumberIntType, a2);
    CFDictionarySetValue(Mutable, @"d", v5);
    if (v5) {
      CFRelease(v5);
    }
  }
  if (*((_DWORD *)a2 + 9))
  {
    CFNumberRef v6 = CFNumberCreate(v4, kCFNumberIntType, (char *)a2 + 36);
    CFDictionarySetValue(Mutable, @"E", v6);
    if (v6) {
      CFRelease(v6);
    }
  }
  if (*((_DWORD *)a2 + 10))
  {
    CFNumberRef v7 = CFNumberCreate(v4, kCFNumberIntType, (char *)a2 + 40);
    CFDictionarySetValue(Mutable, @"F", v7);
    if (v7) {
      CFRelease(v7);
    }
  }
  if (*((_DWORD *)a2 + 1))
  {
    CFNumberRef v8 = CFNumberCreate(v4, kCFNumberIntType, (char *)a2 + 4);
    CFDictionarySetValue(Mutable, @"M", v8);
    if (v8) {
      CFRelease(v8);
    }
  }
  if (*((_DWORD *)a2 + 2))
  {
    CFNumberRef v9 = CFNumberCreate(v4, kCFNumberIntType, (char *)a2 + 8);
    CFDictionarySetValue(Mutable, @"y", v9);
    if (v9) {
      CFRelease(v9);
    }
  }
  if (*((_DWORD *)a2 + 11))
  {
    CFNumberRef v10 = CFNumberCreate(v4, kCFNumberIntType, (char *)a2 + 44);
    CFDictionarySetValue(Mutable, @"W", v10);
    if (v10) {
      CFRelease(v10);
    }
  }
  if (*((_DWORD *)a2 + 12))
  {
    CFNumberRef v11 = CFNumberCreate(v4, kCFNumberIntType, (char *)a2 + 48);
    CFDictionarySetValue(Mutable, @"w", v11);
    if (v11) {
      CFRelease(v11);
    }
  }
  if (*((_DWORD *)a2 + 13))
  {
    CFNumberRef v12 = CFNumberCreate(v4, kCFNumberIntType, (char *)a2 + 52);
    CFDictionarySetValue(Mutable, @"Y", v12);
    if (v12) {
      CFRelease(v12);
    }
  }
  if (*((_DWORD *)a2 + 6))
  {
    CFNumberRef v13 = CFNumberCreate(v4, kCFNumberIntType, (char *)a2 + 24);
    CFDictionarySetValue(Mutable, @"H", v13);
    if (v13) {
      CFRelease(v13);
    }
  }
  if (*((_DWORD *)a2 + 7))
  {
    CFNumberRef v14 = CFNumberCreate(v4, kCFNumberIntType, (char *)a2 + 28);
    CFDictionarySetValue(Mutable, @"m", v14);
    if (v14) {
      CFRelease(v14);
    }
  }
  int v16 = *((_DWORD *)a2 + 8);
  CFStringRef v15 = (char *)a2 + 32;
  if (v16)
  {
    CFNumberRef v17 = CFNumberCreate(v4, kCFNumberIntType, v15);
    CFDictionarySetValue(Mutable, @"s", v17);
    if (v17) {
      CFRelease(v17);
    }
  }
  return Mutable;
}

void sub_1A43D9FC0(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

CFArrayRef *NLBranchGetRoot(CFArrayRef *result)
{
  if (result)
  {
    uint64_t v1 = result;
    unsigned int valuePtr = 0;
    uint64_t result = (CFArrayRef *)CFArrayGetCount(*result);
    if (result)
    {
      uint64_t result = (CFArrayRef *)CFArrayGetValueAtIndex(*v1, 0);
      if (result)
      {
        CFNumberGetValue((CFNumberRef)result, kCFNumberSInt32Type, &valuePtr);
        return (CFArrayRef *)valuePtr;
      }
    }
  }
  return result;
}

CFArrayRef *NLBranchGetLeaf(CFArrayRef *result)
{
  if (result)
  {
    uint64_t v1 = result;
    unsigned int valuePtr = 0;
    CFIndex Count = CFArrayGetCount(*result);
    CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(*v1, Count - 1);
    CFNumberGetValue(ValueAtIndex, kCFNumberSInt32Type, &valuePtr);
    return (CFArrayRef *)valuePtr;
  }
  return result;
}

uint64_t NLBranchGetLocation(uint64_t a1)
{
  if (a1) {
    return *(__int16 *)(a1 + 18);
  }
  else {
    return -1;
  }
}

uint64_t NLBranchGetTokenSpan(uint64_t a1)
{
  if (a1) {
    return *(__int16 *)(a1 + 14);
  }
  else {
    return -1;
  }
}

uint64_t NLBranchGetScore(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 8);
  }
  return result;
}

_DWORD *branchRetain(const __CFAllocator *a1, _DWORD *a2)
{
  uint64_t result = a2;
  if (a2) {
    ++a2[6];
  }
  return result;
}

void branchRelease(const __CFAllocator *a1, CFTypeRef *a2)
{
  if (a2)
  {
    int v3 = *((_DWORD *)a2 + 6) - 1;
    *((_DWORD *)a2 + 6) = v3;
    if (!v3)
    {
      CFRelease(*a2);
      free(a2);
    }
  }
}

BOOL NLBranchIsEqual(CFArrayRef *a1, CFArrayRef *a2)
{
  if (!a1)
  {
    CFIndex Count = 0;
    if (a2) {
      goto LABEL_3;
    }
LABEL_5:
    CFIndex v5 = 0;
    goto LABEL_6;
  }
  CFIndex Count = CFArrayGetCount(*a1);
  if (!a2) {
    goto LABEL_5;
  }
LABEL_3:
  CFIndex v5 = CFArrayGetCount(*a2);
LABEL_6:
  if (Count != v5) {
    return 0;
  }
  unsigned int Root = NLBranchGetRoot(a1);
  if (Root != NLBranchGetRoot(a2)) {
    return 0;
  }
  unsigned int Leaf = NLBranchGetLeaf(a1);
  if (Leaf != NLBranchGetLeaf(a2)) {
    return 0;
  }
  if (a1)
  {
    int v8 = *((unsigned __int16 *)a1 + 6);
    if (a2)
    {
LABEL_11:
      int v9 = *((unsigned __int16 *)a2 + 6);
      return v8 == v9;
    }
  }
  else
  {
    int v8 = 0xFFFF;
    if (a2) {
      goto LABEL_11;
    }
  }
  int v9 = 0xFFFF;
  return v8 == v9;
}

void NLBranchRelease(const __CFAllocator *a1)
{
}

uint64_t NLBranchRetain(uint64_t result)
{
  if (result) {
    ++*(_DWORD *)(result + 24);
  }
  return result;
}

_DWORD *parseRetain(const __CFAllocator *a1, _DWORD *a2)
{
  uint64_t result = a2;
  if (a2) {
    ++a2[4];
  }
  return result;
}

void parseRelease(const __CFAllocator *a1, CFTypeRef *a2)
{
  if (a2)
  {
    int v3 = *((_DWORD *)a2 + 4) - 1;
    *((_DWORD *)a2 + 4) = v3;
    if (!v3)
    {
      CFRelease(*a2);
      free(a2);
    }
  }
}

void *NLParseCreate(CFIndex a1)
{
  id v2 = malloc_type_calloc(1uLL, 0x18uLL, 0x10200405AF6BDC9uLL);
  if (v2)
  {
    callBacks.retain = (CFArrayRetainCallBack)branchRetain;
    callBacks.release = (CFArrayReleaseCallBack)branchRelease;
    void *v2 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1, &callBacks);
    v2[1] = 0xFFFFFFFF00000000;
    *((_DWORD *)v2 + 4) = 1;
  }
  return v2;
}

void NLParseAddBranch(uint64_t a1, __int16 *value)
{
  if (a1 && value)
  {
    CFArrayAppendValue(*(CFMutableArrayRef *)a1, value);
    int v4 = *(__int16 *)(a1 + 12);
    int v5 = value[7];
    if (v4 < 0) {
      LOWORD(v4) = value[7];
    }
    *(_WORD *)(a1 + 12) = v4;
    int v6 = *(__int16 *)(a1 + 14) + (__int16)v4;
    int v7 = value[8] + v5;
    __int16 v8 = v7 - v4;
    if (v6 >= v7) {
      __int16 v8 = *(_WORD *)(a1 + 14);
    }
    *(_WORD *)(a1 + 14) = v8;
    *(_DWORD *)(a1 + 8) += *((_DWORD *)value + 2);
  }
}

uint64_t NLParseGetTokenCount(uint64_t result)
{
  if (result) {
    return *(__int16 *)(result + 14) - (uint64_t)*(__int16 *)(result + 12);
  }
  return result;
}

void NLParseEnumerateBranches(CFArrayRef *a1, uint64_t a2)
{
  if (a1)
  {
    if (a2)
    {
      char v9 = 0;
      uint64_t Count = CFArrayGetCount(*a1);
      int context = 0;
      v10.CFIndex location = 0;
      v10.CFIndex length = Count;
      CFArraySortValues(*a1, v10, (CFComparatorFunction)NLBranchCompare, &context);
      if (Count >= 1)
      {
        CFIndex v5 = 0;
        int v6 = 0;
        do
        {
          CFNumberRef ValueAtIndex = (CFArrayRef *)CFArrayGetValueAtIndex(*a1, v5);
          if (!v6 || !NLBranchIsEqual(v6, ValueAtIndex))
          {
            (*(void (**)(uint64_t, CFArrayRef *, char *))(a2 + 16))(a2, ValueAtIndex, &v9);
            int v6 = ValueAtIndex;
            if (v9) {
              break;
            }
          }
          ++v5;
        }
        while (Count != v5);
      }
    }
  }
}

uint64_t NLBranchCompare(__int16 *a1, __int16 *a2, void *a3)
{
  if (!a1)
  {
    uint64_t v4 = 0;
    uint64_t v3 = -1;
    if (a2) {
      goto LABEL_3;
    }
LABEL_5:
    uint64_t v6 = 0;
    uint64_t v5 = -1;
    goto LABEL_6;
  }
  uint64_t v3 = a1[7];
  uint64_t v4 = a1[8];
  if (!a2) {
    goto LABEL_5;
  }
LABEL_3:
  uint64_t v5 = a2[7];
  uint64_t v6 = a2[8];
LABEL_6:
  if (v3 == v5 && v4 == v6)
  {
    if (a1)
    {
      int v7 = (unsigned __int16)a1[6];
      if (a2)
      {
LABEL_10:
        int v8 = (unsigned __int16)a2[6];
        goto LABEL_22;
      }
    }
    else
    {
      int v7 = 0xFFFF;
      if (a2) {
        goto LABEL_10;
      }
    }
    int v8 = 0xFFFF;
LABEL_22:
    if (v7 == v8)
    {
      if (a1)
      {
        int v12 = *((_DWORD *)a1 + 2);
        if (a2)
        {
LABEL_25:
          int v13 = *((_DWORD *)a2 + 2);
          goto LABEL_31;
        }
      }
      else
      {
        int v12 = 0;
        if (a2) {
          goto LABEL_25;
        }
      }
      int v13 = 0;
LABEL_31:
      if (v12 == v13) {
        return 0;
      }
      if (a1)
      {
        unsigned int v16 = *((_DWORD *)a1 + 2);
        if (a2)
        {
LABEL_35:
          unsigned int v17 = *((_DWORD *)a2 + 2);
          goto LABEL_43;
        }
      }
      else
      {
        unsigned int v16 = 0;
        if (a2) {
          goto LABEL_35;
        }
      }
      unsigned int v17 = 0;
LABEL_43:
      if (v16 > v17) {
        return -1;
      }
      else {
        return 1;
      }
    }
    if (a1)
    {
      unsigned int v14 = *((_DWORD *)a1 + 2);
      if (a2)
      {
LABEL_28:
        unsigned int v15 = *((_DWORD *)a2 + 2);
        goto LABEL_38;
      }
    }
    else
    {
      unsigned int v14 = 0;
      if (a2) {
        goto LABEL_28;
      }
    }
    unsigned int v15 = 0;
LABEL_38:
    if (v14 < v15) {
      return -1;
    }
    else {
      return 1;
    }
  }
  if (v3 < v5) {
    uint64_t v9 = -1;
  }
  else {
    uint64_t v9 = 1;
  }
  if (v4 > v6) {
    uint64_t v10 = -1;
  }
  else {
    uint64_t v10 = 1;
  }
  if (v3 == v5) {
    return v10;
  }
  else {
    return v9;
  }
}

void *NLGraphStructureStackCreate(void)
{
  unint64_t v0 = malloc_type_calloc(1uLL, 0x78uLL, 0x10300403A992469uLL);
  uint64_t v1 = v0;
  if (v0)
  {
    *unint64_t v0 = 0x4000000000;
    v0[1] = malloc_type_calloc(0x40uLL, 0x1CuLL, 0x1000040028C9EA4uLL);
    std::regex_traits<char> v1[2] = 0;
    *((_DWORD *)v1 + 6) = 128;
    v1[4] = malloc_type_calloc(0x80uLL, 4uLL, 0x100004052888210uLL);
    *((_DWORD *)v1 + 1nlp::CFScopedPtr<__CFString const*>::reset(this + 1, 0) = 0x40000;
    v1[6] = malloc_type_calloc(4uLL, 4uLL, 0x100004052888210uLL);
    *((_DWORD *)v1 + 14) = 0x40000;
    v1[8] = malloc_type_calloc(4uLL, 4uLL, 0x100004052888210uLL);
    *((unsigned char *)v1 + 72) = 0;
    v1[13] = 0;
    v1[10] = 0;
    v1[11] = 0;
    *((_DWORD *)v1 + 28) = 1;
  }
  return v1;
}

uint64_t NLGraphStructureSetGrammar(uint64_t result, uint64_t *a2)
{
  if (result)
  {
    uint64_t v2 = result;
    uint64_t result = *a2;
    uint64_t v3 = a2[1];
    if (v3) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v4 = *(std::__shared_weak_count **)(v2 + 88);
    *(void *)(v2 + 8nlp::CFScopedPtr<__CFString const*>::reset(this + 1, 0) = result;
    *(void *)(v2 + 88) = v3;
    if (v4)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v4);
      uint64_t result = *(void *)(v2 + 80);
    }
    if (result)
    {
      if (!*(_DWORD *)(v2 + 16))
      {
        uint64_t v6 = 0;
        int v7 = &v6;
        uint64_t v8 = 0x2000000000;
        int v9 = 0;
        v5[0] = MEMORY[0x1E4F143A8];
        v5[1] = 0x40000000;
        v5[2] = ___Z26NLGraphStructureSetGrammarP22_NLGraphStructureStackNSt3__110shared_ptrIN2NL13SearchGrammarEEE_block_invoke;
        v5[3] = &unk_1E5B364C8;
        v5[4] = &v6;
        NL::SearchGrammar::termIDs(result, (uint64_t)v5);
        *(_DWORD *)(v2 + 2nlp::CFScopedPtr<__CFString const*>::reset(this + 1, 0) = *((_DWORD *)v7 + 6);
        _Block_object_dispose(&v6, 8);
      }
      return NLGraphStructureUpdate(v2);
    }
  }
  return result;
}

void sub_1A43DA8C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z26NLGraphStructureSetGrammarP22_NLGraphStructureStackNSt3__110shared_ptrIN2NL13SearchGrammarEEE_block_invoke(uint64_t result, unsigned int a2)
{
  uint64_t v2 = *(void *)(*(void *)(result + 32) + 8);
  if (*(_DWORD *)(v2 + 24) < a2) {
    *(_DWORD *)(v2 + 24) = a2;
  }
  return result;
}

uint64_t NLGraphStructureUpdate(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t result = NL::SearchGrammar::hasResources(*(NL::SearchGrammar **)(result + 80));
    if (result) {
      uint64_t result = NL::SearchGrammar::tokenDelayed(*(NL::SearchGrammar **)(v1 + 80));
    }
    *(_DWORD *)(v1 + 96) = result;
  }
  return result;
}

void NLGraphStructureStackAdd(uint64_t a1, int a2, int a3, __int16 a4)
{
  if (a1)
  {
    gssSetNode(a1, a3, a4, 0, 0, 1, 0);
    if (a2)
    {
      uint64_t v8 = gssSetNodeWithNode(a1, a2, v7, 1, 0, 0);
      if (NL::SearchGrammar::isInferred(*(NL::SearchGrammar **)(a1 + 80), a2)
        && (v8 & 0x80000000) == 0
        && *(_DWORD *)a1 > v8)
      {
        uint64_t v9 = *(void *)(a1 + 8);
        if (v9) {
          *(unsigned char *)(v9 + 28 * v8) |= 8u;
        }
      }
      if (*(_WORD *)(a1 + 56))
      {
        uint64_t v10 = *(unsigned __int8 *)(a1 + 72);
        if (v10 + 1 >= a3)
        {
          BOOL isCombinable = NL::SearchGrammar::isCombinable(*(NL::SearchGrammar **)(a1 + 80), a2);
          BOOL v11 = isCombinable;
          if (v10 < a3 && !isCombinable && *(_WORD *)(a1 + 56))
          {
            unint64_t v16 = 0;
            do
            {
              if (*(_DWORD *)(*(void *)(a1 + 64) + 4 * v16) >= *(_DWORD *)a1) {
                unsigned int v17 = -1;
              }
              else {
                unsigned int v17 = *(_DWORD *)(*(void *)(a1 + 64) + 4 * v16);
              }
              gssCombinableShift(a1, v17, v8);
              ++v16;
            }
            while (v16 < *(unsigned __int16 *)(a1 + 56));
          }
        }
        else
        {
          BOOL v11 = NL::SearchGrammar::isCombinable(*(NL::SearchGrammar **)(a1 + 80), a2);
          gssPopStack(a1);
        }
        if (v11) {
          goto LABEL_28;
        }
      }
      else if (NL::SearchGrammar::isCombinable(*(NL::SearchGrammar **)(a1 + 80), a2))
      {
LABEL_28:
        *(unsigned char *)(a1 + 72) = a3;
        uint64_t v20 = MEMORY[0x1E4F143A8];
        uint64_t v21 = 0x40000000;
        CFStringRef v18 = (void (*)(uint64_t, uint64_t))___ZL6gssAddP22_NLGraphStructureStackjll_block_invoke;
        CFStringRef v19 = &__block_descriptor_tmp_15_2;
LABEL_32:
        CFStringRef v22 = v18;
        CFAllocatorRef v23 = v19;
        uint64_t v24 = a1;
LABEL_34:
        gssShift(a1, v8, (uint64_t)&v20);
        return;
      }
      char v12 = 0;
      int v13 = *(unsigned __int16 *)(a1 + 56);
      if (a3 && *(_WORD *)(a1 + 40))
      {
        if (*(_WORD *)(a1 + 56))
        {
          uint64_t v14 = *(unsigned __int8 *)(a1 + 72);
          if (v14 != a3)
          {
            char v12 = 0;
            goto LABEL_30;
          }
        }
        gssCombine(a1, v8, 0);
        int v13 = *(unsigned __int16 *)(a1 + 56);
        char v12 = 1;
      }
      if (!v13) {
        goto LABEL_33;
      }
      uint64_t v14 = *(unsigned __int8 *)(a1 + 72);
LABEL_30:
      if (v14 < a3)
      {
        uint64_t v20 = MEMORY[0x1E4F143A8];
        uint64_t v21 = 0x40000000;
        CFStringRef v18 = (void (*)(uint64_t, uint64_t))___ZL6gssAddP22_NLGraphStructureStackjll_block_invoke_2;
        CFStringRef v19 = &__block_descriptor_tmp_16_1;
        goto LABEL_32;
      }
LABEL_33:
      uint64_t v20 = MEMORY[0x1E4F143A8];
      uint64_t v21 = 0x40000000;
      CFStringRef v22 = ___ZL6gssAddP22_NLGraphStructureStackjll_block_invoke_3;
      CFAllocatorRef v23 = &__block_descriptor_tmp_17_1;
      uint64_t v24 = a1;
      char v25 = v12;
      goto LABEL_34;
    }
  }
}

__CFArray *NLGraphStructureStackCopyParsesWithCallback(uint64_t a1, uint64_t a2, void (*a3)(uint64_t, CFArrayRef *, CFArrayRef *, uint64_t))
{
  if (!a1) {
    return 0;
  }
  gssPopStack(a1);
  CFIndex v6 = *(unsigned __int16 *)(a1 + 40);
  if (!*(_WORD *)(a1 + 40)) {
    return 0;
  }
  callBacks.retain = (CFArrayRetainCallBack)parseRetain;
  callBacks.release = (CFArrayReleaseCallBack)parseRelease;
  unsigned int v7 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v6, &callBacks);
  if (*(_WORD *)(a1 + 40))
  {
    for (unint64_t i = 0; i < *(unsigned __int16 *)(a1 + 40); ++i)
    {
      unsigned int v9 = *(_DWORD *)(*(void *)(a1 + 48) + 4 * i);
      if (v9 >= *(_DWORD *)a1)
      {
        BOOL v11 = NLParseCreate(0);
        int v10 = 0;
        __int16 v12 = -1;
        unsigned int v9 = -1;
      }
      else
      {
        if ((v9 & 0x80000000) != 0)
        {
          BOOL v11 = NLParseCreate(0);
          int v10 = 0;
        }
        else
        {
          int v10 = *(_DWORD *)(*(void *)(a1 + 8) + 28 * v9 + 8);
          BOOL v11 = NLParseCreate(0);
          if (*(_DWORD *)a1 > v9)
          {
            __int16 v12 = *(_WORD *)(*(void *)(a1 + 8) + 28 * v9 + 2);
            goto LABEL_12;
          }
        }
        __int16 v12 = -1;
      }
LABEL_12:
      int v13 = NLBranchCreate(v12, 0);
      NLBranchAddNode((uint64_t)v13, v10, 0);
      *(_OWORD *)&callBacks.version = xmmword_1A43F6B80;
      gssVisitState(a1, v9, (uint64_t)v11, (uint64_t)v13, &callBacks.version, 0, a2, a3);
      branchRelease(v14, (CFTypeRef *)v13);
      if (v11 && v11[2]) {
        CFArrayAppendValue(v7, v11);
      }
      parseRelease(v15, (CFTypeRef *)v11);
    }
  }
  if (!CFArrayGetCount(v7))
  {
    CFRelease(v7);
    return 0;
  }
  v18.CFIndex length = CFArrayGetCount(v7);
  v18.CFIndex location = 0;
  CFArraySortValues(v7, v18, (CFComparatorFunction)NLParseCompare, 0);
  return v7;
}

void NLGraphStructureStackReset(uint64_t a1)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 4))
    {
      uint64_t v2 = 0;
      unint64_t v3 = 0;
      do
      {
        uint64_t v4 = *(void *)(a1 + 8) + v2;
        *(void *)uint64_t v4 = 0;
        *(void *)(v4 + 8) = 0;
        *(_DWORD *)(v4 + 24) = 0;
        *(void *)(v4 + 16) = 0;
        ++v3;
        v2 += 28;
      }
      while (v3 < *(unsigned int *)(a1 + 4));
    }
    *(_DWORD *)a1 = 0;
    bzero(*(void **)(a1 + 32), *(unsigned int *)(a1 + 24));
    bzero(*(void **)(a1 + 48), *(unsigned __int16 *)(a1 + 42));
    bzero(*(void **)(a1 + 64), *(unsigned __int16 *)(a1 + 58));
    *(_DWORD *)(a1 + 16) = 0;
    *(_WORD *)(a1 + 56) = 0;
    *(_WORD *)(a1 + 4nlp::CFScopedPtr<__CFString const*>::reset(this + 1, 0) = 0;
  }
}

void NLGraphStructureStackRelease(uint64_t a1)
{
  if (a1)
  {
    int v2 = *(_DWORD *)(a1 + 112) - 1;
    *(_DWORD *)(a1 + 112) = v2;
    if (!v2)
    {
      NLGraphStructureStackReset(a1);
      unint64_t v3 = *(std::__shared_weak_count **)(a1 + 88);
      if (v3) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v3);
      }
      free(*(void **)(a1 + 8));
      free(*(void **)(a1 + 32));
      free(*(void **)(a1 + 64));
      free(*(void **)(a1 + 48));
      free((void *)a1);
    }
  }
}

uint64_t gssGetRHSAtIndex(uint64_t a1, unsigned int a2, int a3)
{
  if ((a2 & 0x80000000) != 0) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v3 = *(_DWORD *)a1;
  if (*(_DWORD *)a1 <= a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = *(void *)(a1 + 8);
  if (*(unsigned __int16 *)(v4 + 28 * a2 + 12) <= a3) {
    return 0xFFFFFFFFLL;
  }
  int v5 = *(_DWORD *)(v4 + 28 * a2 + 16) + a3;
  if (v5 >= *(_DWORD *)(a1 + 16)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = *(unsigned int *)(*(void *)(a1 + 32) + 4 * v5);
  if (result >= v3 || (result & 0x80000000) != 0) {
    return 0xFFFFFFFFLL;
  }
  return result;
}

double gssSetNode(uint64_t a1, __int16 a2, __int16 a3, int a4, int a5, int a6, int a7)
{
  if (a1)
  {
    unsigned int v14 = *(_DWORD *)(a1 + 4);
    if (*(_DWORD *)a1 + 1 >= v14)
    {
      unsigned int v15 = 2 * v14;
      *(_DWORD *)(a1 + 4) = v15;
      unint64_t v16 = malloc_type_realloc(*(void **)(a1 + 8), 28 * v15, 0x1000040028C9EA4uLL);
      if (v16) {
        *(void *)(a1 + 8) = v16;
      }
    }
  }
  int v17 = (*(_DWORD *)a1)++;
  int v18 = (unsigned __int16)v17;
  uint64_t v19 = *(void *)(a1 + 8) + 28 * (unsigned __int16)v17;
  if (a6) {
    char v20 = 5;
  }
  else {
    char v20 = 1;
  }
  if (a7) {
    v20 |= 2u;
  }
  *(unsigned char *)uint64_t v19 = v20;
  *(_DWORD *)(v19 + 24) = v18;
  *(_WORD *)(v19 + 2) = a2;
  *(_WORD *)(v19 + 4) = a3;
  double result = NAN;
  *(void *)(v19 + 16) = -1;
  *(_DWORD *)(v19 + 8) = a4;
  *(_DWORD *)(v19 + 12) = a5;
  return result;
}

uint64_t gssSetNodeWithNode(uint64_t a1, int a2, unsigned int a3, int a4, unsigned int a5, int *a6)
{
  if ((a3 & 0x80000000) != 0 || *(_DWORD *)a1 <= a3)
  {
    __int16 v11 = -1;
    __int16 v12 = -1;
  }
  else
  {
    uint64_t v10 = *(void *)(a1 + 8) + 28 * a3;
    __int16 v11 = *(_WORD *)(v10 + 2);
    __int16 v12 = *(_WORD *)(v10 + 4);
  }
  gssSetNode(a1, v11, v12, a2, (__int16)a5, 0, a4);
  uint64_t v13 = *(void *)(a1 + 8);
  unsigned int v15 = v14;
  *(_DWORD *)(v13 + 28 * v14 + 2nlp::CFScopedPtr<__CFString const*>::reset(this + 1, 0) = a3;
  if (a5)
  {
    gssRefsResize((void *)a1, a5);
    *(_DWORD *)(v13 + 28 * v15 + 16) = *(_DWORD *)(a1 + 16);
    uint64_t v16 = *(void *)(a1 + 32);
    uint64_t v17 = a5;
    do
    {
      int v18 = *a6++;
      uint64_t v19 = *(unsigned int *)(a1 + 16);
      *(_DWORD *)(a1 + 16) = v19 + 1;
      *(_DWORD *)(v16 + 4 * v19) = v18 + 100000;
      --v17;
    }
    while (v17);
  }
  return *(unsigned int *)(v13 + 28 * v15 + 24);
}

void gssPopStack(uint64_t a1)
{
  v11[0] = 0;
  v11[1] = v11;
  v11[2] = 0x2000000000;
  int v2 = *(unsigned __int16 *)(a1 + 40);
  BOOL v12 = *(_WORD *)(a1 + 40) != 0;
  unsigned int v3 = *(unsigned __int16 *)(a1 + 56);
  if (!v2)
  {
    if (!*(_WORD *)(a1 + 56)) {
      goto LABEL_25;
    }
    uint64_t v6 = 0;
    while (1)
    {
      unsigned int v7 = *(_DWORD *)(*(void *)(a1 + 64) + 4 * v6);
      if (v7 >= *(_DWORD *)a1) {
        break;
      }
      if ((v7 & 0x80000000) != 0 || *(_DWORD *)(*(void *)(a1 + 8) + 28 * v7 + 20)) {
        goto LABEL_22;
      }
LABEL_24:
      if (++v6 >= (unint64_t)v3) {
        goto LABEL_25;
      }
    }
    unsigned int v7 = -1;
LABEL_22:
    if (gssNodeHasRHS(a1, v7))
    {
      v10[0] = MEMORY[0x1E4F143A8];
      v10[1] = 0x40000000;
      void v10[2] = ___ZL11gssPopStackP22_NLGraphStructureStack_block_invoke;
      v10[3] = &unk_1E5B37148;
      v10[4] = v11;
      void v10[5] = a1;
      gssShift(a1, v7, (uint64_t)v10);
      unsigned int v3 = *(unsigned __int16 *)(a1 + 56);
    }
    goto LABEL_24;
  }
  if (*(_WORD *)(a1 + 56))
  {
    uint64_t v4 = 0;
    while (1)
    {
      uint64_t v5 = *(unsigned int *)(*(void *)(a1 + 64) + 4 * v4);
      if (v5 >= *(_DWORD *)a1) {
        break;
      }
      if ((v5 & 0x80000000) != 0 || *(_DWORD *)(*(void *)(a1 + 8) + 28 * v5 + 20)) {
        goto LABEL_9;
      }
LABEL_13:
      if (++v4 >= (unint64_t)v3) {
        goto LABEL_25;
      }
    }
    uint64_t v5 = 0xFFFFFFFFLL;
LABEL_9:
    if (gssNodeHasRHS(a1, v5))
    {
      char v9 = 0;
      gssCombine(a1, v5, &v9);
      if (!v9)
      {
        v8[0] = MEMORY[0x1E4F143A8];
        v8[1] = 0x40000000;
        v8[2] = ___ZL11gssPopStackP22_NLGraphStructureStack_block_invoke_2;
        v8[3] = &__block_descriptor_tmp_19;
        v8[4] = a1;
        gssShift(a1, v5, (uint64_t)v8);
      }
      unsigned int v3 = *(unsigned __int16 *)(a1 + 56);
    }
    goto LABEL_13;
  }
LABEL_25:
  *(_WORD *)(a1 + 56) = 0;
  _Block_object_dispose(v11, 8);
}

void sub_1A43DB354(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL gssCombinableShift(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v18 = 0;
  uint64_t v19 = &v18;
  uint64_t v20 = 0x2000000000;
  char v21 = 0;
  if (a1) {
    BOOL v6 = (int)a3 < 0;
  }
  else {
    BOOL v6 = 1;
  }
  char v7 = v6;
  unsigned int v8 = a3;
  do
  {
    if ((v7 & 1) != 0 || *(_DWORD *)a1 <= a3) {
      unsigned int v9 = 0;
    }
    else {
      unsigned int v9 = *(_DWORD *)(*(void *)(a1 + 8) + 28 * v8 + 8);
    }
    unsigned __int8 v23 = 0;
    __gssNodeReduce(a1, a2, a3, &v22, &v23);
    int v10 = v23;
    *((unsigned char *)v19 + 24) = v23;
    if (v10 || !NL::SearchGrammar::hasExpansions(*(NL::SearchGrammar **)(a1 + 80), v9))
    {
      int v11 = 0;
    }
    else
    {
      v16[0] = MEMORY[0x1E4F143A8];
      v16[1] = 0x40000000;
      v16[2] = ___ZL18gssCombinableShiftP22_NLGraphStructureStackii_block_invoke;
      v16[3] = &unk_1E5B37190;
      v16[4] = &v18;
      void v16[5] = a1;
      unsigned int v17 = a2;
      gssShift(a1, a3, (uint64_t)v16);
      int v11 = 1;
    }
    unsigned int v12 = NL::SearchGrammar::hasExpansions(*(NL::SearchGrammar **)(a1 + 80), v9);
    if (*((unsigned char *)v19 + 24)) {
      int v13 = 1;
    }
    else {
      int v13 = v11;
    }
  }
  while (v12 && !v13);
  BOOL v14 = *((unsigned __int8 *)v19 + 24) != 0;
  _Block_object_dispose(&v18, 8);
  return v14;
}

void sub_1A43DB4FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t gssCombine(uint64_t result, uint64_t a2, unsigned char *a3)
{
  if (*(_WORD *)(result + 40))
  {
    uint64_t v5 = result;
    unint64_t v6 = 0;
    do
    {
      unsigned int v7 = *(_DWORD *)(*(void *)(v5 + 48) + 4 * v6);
      char v9 = 0;
      double result = __gssNodeReduce(v5, v7, a2, &v8, &v9);
      if (a3)
      {
        if (v9) {
          *a3 = v9;
        }
      }
      ++v6;
    }
    while (v6 < *(unsigned __int16 *)(v5 + 40));
  }
  return result;
}

void gssShift(uint64_t a1, unsigned int a2, uint64_t a3)
{
  unsigned int v3 = 0;
  v7[0] = 0;
  v7[1] = v7;
  v7[2] = 0x2000000000;
  char v8 = 0;
  uint64_t v4 = *(void *)(a1 + 80);
  if (a1 && (a2 & 0x80000000) == 0)
  {
    if (*(_DWORD *)a1 <= a2) {
      unsigned int v3 = 0;
    }
    else {
      unsigned int v3 = *(_DWORD *)(*(void *)(a1 + 8) + 28 * a2 + 8);
    }
  }
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 0x40000000;
  v5[2] = ___ZL8gssShiftP22_NLGraphStructureStackiU13block_pointerFviPbE_block_invoke;
  v5[3] = &unk_1E5B371B8;
  void v5[5] = v7;
  void v5[6] = a1;
  unsigned int v6 = a2;
  v5[4] = a3;
  NL::SearchGrammar::expansions(v4, v3, (uint64_t)v5);
  _Block_object_dispose(v7, 8);
}

void sub_1A43DB674(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

_DWORD *___ZL6gssAddP22_NLGraphStructureStackjll_block_invoke(uint64_t a1, unsigned int a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if ((a2 & 0x80000000) == 0 && *(_DWORD *)v3 > a2)
  {
    uint64_t v4 = *(void *)(v3 + 8);
    if (v4)
    {
      *(unsigned char *)(v4 + 28 * a2) |= 0x10u;
      uint64_t v3 = *(void *)(a1 + 32);
    }
  }
  int v5 = *(unsigned __int16 *)(v3 + 56);
  unsigned int v6 = *(unsigned __int16 *)(v3 + 58);
  if (v5 + 1 >= v6)
  {
    *(_WORD *)(v3 + 58) = 2 * v6;
    double result = malloc_type_realloc(*(void **)(v3 + 64), 8 * (v6 & 0x7FFF), 0x100004052888210uLL);
    *(void *)(v3 + 64) = result;
    int v5 = *(unsigned __int16 *)(v3 + 56);
  }
  else
  {
    double result = *(_DWORD **)(v3 + 64);
  }
  *(_WORD *)(v3 + 56) = v5 + 1;
  result[v5] = a2;
  return result;
}

uint64_t ___ZL6gssAddP22_NLGraphStructureStackjll_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void *)(a1 + 32);
  if (*(_WORD *)(result + 56))
  {
    unint64_t v5 = 0;
    do
    {
      if (*(_DWORD *)(*(void *)(result + 64) + 4 * v5) >= *(_DWORD *)result) {
        unsigned int v6 = -1;
      }
      else {
        unsigned int v6 = *(_DWORD *)(*(void *)(result + 64) + 4 * v5);
      }
      gssCombinableShift(result, v6, a2);
      ++v5;
      uint64_t result = *(void *)(a1 + 32);
    }
    while (v5 < *(unsigned __int16 *)(result + 56));
  }
  return result;
}

void ___ZL6gssAddP22_NLGraphStructureStackjll_block_invoke_3(uint64_t a1, uint64_t a2)
{
}

void gssMerge(uint64_t a1, uint64_t a2, int a3)
{
  char v3 = a3;
  unsigned int v4 = a2;
  char v6 = 0;
  if (a3) {
    gssCombine(a1, a2, &v6);
  }
  gssExpand(a1, v4, &v6, 0, v3);
}

void *gssRefsResize(void *result, int a2)
{
  if (result)
  {
    int v2 = result;
    unsigned int v3 = *((_DWORD *)result + 6);
    if (a2 + *((_DWORD *)result + 4) + 1 >= v3)
    {
      unsigned int v4 = 2 * v3;
      *((_DWORD *)result + 6) = v4;
      uint64_t result = malloc_type_realloc(*((void **)result + 4), 4 * v4, 0x100004052888210uLL);
      v2[4] = result;
    }
  }
  return result;
}

uint64_t gssNodeHasRHS(uint64_t a1, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0) {
    return 0;
  }
  unsigned int v4 = *(_DWORD *)a1;
  if (*(_DWORD *)a1 <= a2) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 8);
  if (!v5 || (*(_DWORD *)(v5 + 28 * a2 + 20) & 0x80000000) != 0 && !*(_DWORD *)(v5 + 28 * a2 + 12)) {
    return 0;
  }
  int v6 = *(_DWORD *)(v5 + 28 * a2 + 12);
  if (!v6) {
    return 0;
  }
  int v7 = 0;
  while (1)
  {
    unsigned int RHSAtIndex = gssGetRHSAtIndex(a1, a2, v7);
    if ((RHSAtIndex & 0x80000000) == 0
      && (v4 <= RHSAtIndex
       || (*(_DWORD *)(v5 + 28 * RHSAtIndex + 20) & 0x80000000) == 0
       || *(_DWORD *)(v5 + 28 * RHSAtIndex + 12)))
    {
      break;
    }
    if (v6 == ++v7) {
      return 0;
    }
  }
  return 1;
}

void ___ZL11gssPopStackP22_NLGraphStructureStack_block_invoke(uint64_t a1, uint64_t a2)
{
}

void ___ZL11gssPopStackP22_NLGraphStructureStack_block_invoke_2(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  char v3 = 0;
  gssExpand(v2, a2, &v3, 0, 0);
}

uint64_t ___ZL18gssCombinableShiftP22_NLGraphStructureStackii_block_invoke(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  uint64_t result = gssCombinableShift(*(void *)(a1 + 40), *(unsigned int *)(a1 + 48), a2);
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    *a3 = 1;
  }
  return result;
}

uint64_t __gssNodeReduce(uint64_t result, unsigned int a2, uint64_t a3, __int16 *a4, unsigned char *a5)
{
  if (((a2 | a3) & 0x80000000) != 0) {
    return result;
  }
  unsigned int v8 = a2;
  uint64_t v9 = result;
  if (result) {
    BOOL v10 = (int)a3 < 0;
  }
  else {
    BOOL v10 = 1;
  }
  char v11 = v10;
  unsigned int v39 = a3;
  do
  {
    if ((v8 & 0x80000000) == 0 && *(_DWORD *)v9 > v8)
    {
      uint64_t v12 = *(void *)(v9 + 8) + 28 * v8;
      int v13 = *(unsigned __int16 *)(v12 + 12);
      if (*(_WORD *)(v12 + 12))
      {
        uint64_t v14 = 0;
        unsigned int v15 = v8;
        while (1)
        {
          uint64_t result = gssGetRHSAtIndex(v9, v8, v14);
          if ((result & 0x80000000) != 0
            && *(_DWORD *)v9 > v8
            && (uint64_t v16 = *(void *)(v9 + 8), *(unsigned __int16 *)(v16 + 28 * v8 + 12) > v14)
            && (uint64_t v17 = *(int *)(v16 + 28 * v8 + 16), (v14 + v17) < *(_DWORD *)(v9 + 16)))
          {
            unsigned int v18 = *(_DWORD *)(*(void *)(v9 + 32) + 4 * (v14 + v17));
            if (v18 <= *(_DWORD *)v9)
            {
              int v19 = *(_DWORD *)(v16 + 28 * v18 + 8);
              if (v11) {
                goto LABEL_26;
              }
            }
            else
            {
              int v19 = v18 - 100000;
              if (v18 == 100000) {
                int v19 = -1;
              }
              if (v11) {
                goto LABEL_26;
              }
            }
          }
          else
          {
            int v19 = -1;
            if (v11) {
              goto LABEL_26;
            }
          }
          if (*(_DWORD *)v9 > a3)
          {
            int v20 = *(_DWORD *)(*(void *)(v9 + 8) + 28 * v39 + 8);
            goto LABEL_27;
          }
LABEL_26:
          int v20 = 0;
LABEL_27:
          if (v19 == v20)
          {
            if ((result & 0x80000000) != 0)
            {
              unsigned int v33 = *(_DWORD *)v9;
              if (*(_DWORD *)v9 > v8 && v33 > a3)
              {
                uint64_t v34 = *(void *)(v9 + 8);
                if (*(unsigned __int16 *)(v34 + 28 * v8 + 12) > v14)
                {
                  uint64_t v35 = *(int *)(v34 + 28 * v8 + 16);
                  if ((v35 + v14) < *(_DWORD *)(v9 + 16))
                  {
                    unsigned int v36 = *(_DWORD *)(v34 + 28 * v39 + 24);
                    if (v36 < v33) {
                      *(_DWORD *)(*(void *)(v9 + 32) + 4 * (v35 + v14)) = v36;
                    }
                  }
                }
              }
              if ((a3 & 0x80000000) == 0 && *(_DWORD *)v9 > a3)
              {
                uint64_t v37 = *(void *)(v9 + 8) + 28 * v39;
                goto LABEL_58;
              }
              __int16 v38 = -1;
LABEL_59:
              *a4 = v38;
            }
            else
            {
              uint64_t result = gssNodesAreEqual(v9, result, a3);
              if ((result & 1) == 0)
              {
                uint64_t v21 = *(void *)(v9 + 8);
                uint64_t v22 = v21 + 28 * v15;
                int v24 = *(_DWORD *)(v22 + 12);
                int v23 = *(_DWORD *)(v22 + 16);
                char v25 = (int *)(v22 + 12);
                unsigned int v26 = *(_DWORD *)(v9 + 16);
                v25[1] = v26;
                if (v24)
                {
                  unsigned int v27 = 0;
                  uint64_t v28 = v23 + (int)v14;
                  do
                  {
                    uint64_t result = (uint64_t)gssRefsResize((void *)v9, 1);
                    uint64_t v29 = *(void *)(v9 + 32);
                    int v30 = *(_DWORD *)(v29 + 4 * v28);
                    uint64_t v31 = *(unsigned int *)(v9 + 16);
                    *(_DWORD *)(v9 + 16) = v31 + 1;
                    *(_DWORD *)(v29 + 4 * v31) = v30;
                    unsigned int v26 = *(_DWORD *)(v9 + 16) + 1;
                    *(_DWORD *)(v9 + 16) = v26;
                    ++v27;
                  }
                  while (v27 < *v25);
                  int v32 = *v25 + 1;
                }
                else
                {
                  uint64_t v29 = *(void *)(v9 + 32);
                  int v32 = 1;
                }
                *char v25 = v32;
                *(_DWORD *)(v9 + 16) = v26 + 1;
                *(_DWORD *)(v29 + 4 * v26) = a3;
                uint64_t v37 = v21 + 28 * v15;
LABEL_58:
                __int16 v38 = *(_WORD *)(v37 + 2);
                goto LABEL_59;
              }
            }
            *a5 = 1;
            return result;
          }
          if (result) {
            uint64_t result = __gssNodeReduce(v9, result, a3, a4, a5);
          }
          if (*a5) {
            return result;
          }
          if (v13 == ++v14) {
            goto LABEL_34;
          }
        }
      }
    }
    if (*a5) {
      return result;
    }
LABEL_34:
    if ((v8 & 0x80000000) == 0 && *(_DWORD *)v9 > v8)
    {
      unsigned int v8 = *(_DWORD *)(*(void *)(v9 + 8) + 28 * v8 + 20);
      if ((v8 & 0x80000000) == 0) {
        continue;
      }
    }
    unsigned int v8 = -1;
  }
  while (((v8 | a3) & 0x80000000) == 0);
  return result;
}

uint64_t gssNodesAreEqual(uint64_t a1, unsigned int a2, unsigned int a3)
{
  if ((a2 & 0x80000000) != 0 || *(_DWORD *)a1 <= a2)
  {
    uint64_t v6 = 0;
    if ((a3 & 0x80000000) != 0) {
      goto LABEL_8;
    }
  }
  else
  {
    uint64_t v6 = *(void *)(a1 + 8) + 28 * a2;
    if ((a3 & 0x80000000) != 0) {
      goto LABEL_8;
    }
  }
  if (*(_DWORD *)a1 > a3)
  {
    uint64_t v7 = *(void *)(a1 + 8) + 28 * a3;
    goto LABEL_9;
  }
LABEL_8:
  uint64_t v7 = 0;
LABEL_9:
  if (!(v6 | v7)) {
    return 1;
  }
  uint64_t result = 0;
  if (v6 && v7)
  {
    if (*(_DWORD *)(v6 + 8) != *(_DWORD *)(v7 + 8)) {
      return 0;
    }
    unsigned int v9 = *(_DWORD *)(v6 + 12);
    if (v9 != *(_DWORD *)(v7 + 12) || *(_DWORD *)(v6 + 20) != *(_DWORD *)(v7 + 20)) {
      return 0;
    }
    if ((a2 & 0x80000000) != 0
      || *(_DWORD *)a1 <= a2
      || (uint64_t v10 = *(unsigned int *)(*(void *)(a1 + 8) + 28 * a2 + 20), (v10 & 0x80000000) != 0))
    {
      uint64_t v10 = 0xFFFFFFFFLL;
    }
    if ((a3 & 0x80000000) != 0
      || *(_DWORD *)a1 <= a3
      || (uint64_t v11 = *(unsigned int *)(*(void *)(a1 + 8) + 28 * a3 + 20), (v11 & 0x80000000) != 0))
    {
      uint64_t v11 = 0xFFFFFFFFLL;
    }
    uint64_t result = gssNodesAreEqual(a1, v10, v11);
    if (result)
    {
      if (v9)
      {
        uint64_t RHSAtIndex = gssGetRHSAtIndex(a1, a2, 0);
        uint64_t v13 = gssGetRHSAtIndex(a1, a3, 0);
        int v14 = gssNodesAreEqual(a1, RHSAtIndex, v13);
        uint64_t result = 0;
        if (v14)
        {
          int v15 = 1;
          do
          {
            unsigned int v16 = v15;
            if (v9 == v15) {
              break;
            }
            uint64_t v17 = gssGetRHSAtIndex(a1, a2, v15);
            uint64_t v18 = gssGetRHSAtIndex(a1, a3, v16);
            char v19 = gssNodesAreEqual(a1, v17, v18);
            int v15 = v16 + 1;
          }
          while ((v19 & 1) != 0);
          return v16 >= v9;
        }
        return result;
      }
      return 1;
    }
  }
  return result;
}

uint64_t ___ZL8gssShiftP22_NLGraphStructureStackiU13block_pointerFviPbE_block_invoke(uint64_t a1, int a2, uint64_t a3, unsigned char *a4)
{
  unsigned int v6 = gssSetNodeWithNode(*(void *)(a1 + 48), a2, *(_DWORD *)(a1 + 56), 0, (unsigned __int16)((*(_DWORD *)(a3 + 8) - *(void *)a3) >> 2), *(int **)a3);
  __int32 v7 = 0;
  uint64_t v8 = *(void *)(a1 + 48);
  if ((v6 & 0x80000000) == 0 && v8)
  {
    if (*(_DWORD *)v8 <= v6) {
      __int32 v7 = 0;
    }
    else {
      __int32 v7 = *(_DWORD *)(*(void *)(v8 + 8) + 28 * v6 + 8);
    }
  }
  BOOL v9 = NL::SearchGrammar::requiresComplement(*(NL::SearchGrammar **)(v8 + 80), v7);
  uint64_t v10 = *(unsigned int **)(a1 + 48);
  if ((v6 & 0x80000000) == 0 && v9 && *v10 > v6)
  {
    uint64_t v11 = *((void *)v10 + 1);
    if (v11)
    {
      *(unsigned char *)(v11 + 28 * v6) |= 0x20u;
      uint64_t v10 = *(unsigned int **)(a1 + 48);
    }
  }
  unsigned int v12 = *(_DWORD *)(a1 + 56);
  if ((v12 & 0x80000000) == 0)
  {
    unsigned int v13 = *v10;
    if (*v10 > v12)
    {
      uint64_t v14 = *((void *)v10 + 1);
      if (v14)
      {
        if ((*(unsigned char *)(v14 + 28 * v12) & 8) != 0 && v13 > v6 && (v6 & 0x80000000) == 0) {
          *(unsigned char *)(v14 + 28 * v6) |= 8u;
        }
      }
    }
  }
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)) {
    *a4 = 1;
  }
  return result;
}

void gssExpand(uint64_t a1, unsigned int a2, unsigned char *a3, char a4, char a5)
{
  unsigned int v10 = 0;
  if (a1 && (a2 & 0x80000000) == 0)
  {
    if (*(_DWORD *)a1 <= a2)
    {
      unsigned int v10 = 0;
    }
    else
    {
      unsigned int v10 = *(_DWORD *)(*(void *)(a1 + 8) + 28 * a2 + 8);
      if ((a4 & 1) == 0 && v10 == 1)
      {
        gssAddState(a1, a2);
        return;
      }
    }
  }
  if (*a3
    && (NL::SearchGrammar::hasExpansions(*(NL::SearchGrammar **)(a1 + 80), v10) & 1) == 0
    && v10 != 1
    && !*a3)
  {
    gssAddState(a1, a2);
  }
  v11[0] = MEMORY[0x1E4F143A8];
  v11[1] = 0x40000000;
  v11[2] = ___ZL9gssExpandP22_NLGraphStructureStackiPbbb_block_invoke;
  void v11[3] = &__block_descriptor_tmp_23_0;
  char v12 = a5;
  v11[4] = a1;
  v11[5] = a3;
  char v13 = a4;
  gssShift(a1, a2, (uint64_t)v11);
}

_DWORD *gssAddState(uint64_t a1, int a2)
{
  int v4 = *(unsigned __int16 *)(a1 + 40);
  unsigned int v5 = *(unsigned __int16 *)(a1 + 42);
  if (v4 + 1 >= v5)
  {
    *(_WORD *)(a1 + 42) = 2 * v5;
    uint64_t result = malloc_type_realloc(*(void **)(a1 + 48), 8 * (v5 & 0x7FFF), 0x100004052888210uLL);
    *(void *)(a1 + 48) = result;
    int v4 = *(unsigned __int16 *)(a1 + 40);
  }
  else
  {
    uint64_t result = *(_DWORD **)(a1 + 48);
  }
  *(_WORD *)(a1 + 4nlp::CFScopedPtr<__CFString const*>::reset(this + 1, 0) = v4 + 1;
  result[v4] = a2;
  return result;
}

uint64_t ___ZL9gssExpandP22_NLGraphStructureStackiPbbb_block_invoke(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  if (*(unsigned char *)(result + 48)) {
    uint64_t result = gssCombine(*(void *)(result + 32), a2, *(unsigned char **)(result + 40));
  }
  if (!**(unsigned char **)(v3 + 40))
  {
    uint64_t v4 = *(void *)(v3 + 32);
    return gssExpand(v4, a2);
  }
  return result;
}

char *NLBranchCreate(__int16 a1, char a2)
{
  uint64_t v4 = (char *)malloc_type_calloc(1uLL, 0x20uLL, 0x102004086FE837DuLL);
  if (v4)
  {
    *(void *)uint64_t v4 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    int16x4_t v5 = (int16x4_t)-1;
    v5.i16[0] = a1;
    int16x4_t v6 = vzip1_s16(v5, v5);
    v6.i16[2] = a1;
    *(int16x4_t *)(v4 + 12) = v6;
    *((_DWORD *)v4 + 2) = 0;
    v4[20] = a2;
    *((_DWORD *)v4 + 6) = 1;
  }
  return v4;
}

void NLBranchAddNode(uint64_t a1, int a2, int a3)
{
  int valuePtr = a2;
  if (a1)
  {
    CFNumberRef v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &valuePtr);
    CFArrayAppendValue(*(CFMutableArrayRef *)a1, v5);
    CFRelease(v5);
    *(_DWORD *)(a1 + 8) += a3;
  }
}

void gssVisitState(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t *a5, unsigned int a6, uint64_t a7, void (*a8)(uint64_t, CFArrayRef *, CFArrayRef *, uint64_t))
{
  unsigned int v9 = a2;
  if ((a2 & 0x80000000) != 0 || *(_DWORD *)a1 <= a2)
  {
    __int16 v13 = -1;
    __int16 v14 = -1;
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 8);
    uint64_t v12 = v11 + 28 * a2;
    __int16 v13 = *(_WORD *)(v12 + 2);
    __int16 v14 = *(_WORD *)(v12 + 4);
    if (v11
      && (*(unsigned char *)(v11 + 28 * a2) & 0x20) != 0
      && (!gssNodeHasLHS(a1, a2) || !gssNodeHasRHS(a1, v9)))
    {
      return;
    }
  }
  if ((!a4 || !CFArrayGetCount(*(CFArrayRef *)a4) || CFArrayGetCount(*(CFArrayRef *)a4) <= 3) && (v9 & 0x80000000) == 0)
  {
    unsigned int v15 = *(_DWORD *)a1;
    if (*(_DWORD *)a1 <= v9) {
      goto LABEL_43;
    }
    uint64_t v16 = *(void *)(a1 + 8);
    if (!v16 || (*(unsigned char *)(v16 + 28 * v9) & 4) == 0)
    {
      uint64_t v17 = *(void *)(a1 + 8);
      uint64_t v18 = *(unsigned int *)(v17 + 28 * v9 + 20);
      if ((v18 & 0x80000000) == 0)
      {
        if (v15 <= v18)
        {
          int v20 = 0;
          __int16 v22 = -1;
          if (a6) {
            goto LABEL_38;
          }
          uint64_t v21 = -1;
LABEL_31:
          *a5 = v21;
          a5[1] = 1;
LABEL_32:
          if (v15 > v18 && (*(unsigned char *)(v17 + 28 * v18) & 0x20) != 0 && (a6 & 1) == 0)
          {
            if (gssNodeHasRHS(a1, v18))
            {
              uint64_t v29 = NLBranchCreate(v22, 1);
              int Score = gssNodeGetScore(a1, v18);
              NLBranchAddNode((uint64_t)v29, v20, Score);
              int v71 = 0;
              gssNodeGetMaxIndex(a1, v18, &v71);
              uint64_t v69 = v22;
              uint64_t v70 = v71 - v22 + 1;
              CFAllocatorRef v31 = (const __CFAllocator *)gssVisitState(a1, v18, a3, v29, &v69, 1, a7, a8);
              branchRelease(v31, (CFTypeRef *)v29);
            }
            LOBYTE(a6) = 0;
            goto LABEL_43;
          }
LABEL_38:
          int v32 = NLBranchCopy(a4);
          int v33 = gssNodeGetScore(a1, v18);
          NLBranchAddNode((uint64_t)v32, v20, v33);
          CFAllocatorRef v34 = (const __CFAllocator *)gssVisitState(a1, v18, a3, v32, a5, a6, a7, a8);
          branchRelease(v34, (CFTypeRef *)v32);
          if (*(_DWORD *)a1 <= v18
            || (uint64_t v35 = *(void *)(a1 + 8)) == 0
            || (*(unsigned char *)(v35 + 28 * v18) & 2) == 0)
          {
            unsigned int v36 = NLBranchCreate(v22, 0);
            int v37 = gssNodeGetScore(a1, v18);
            NLBranchAddNode((uint64_t)v36, v20, v37);
            CFAllocatorRef v38 = (const __CFAllocator *)gssVisitState(a1, v18, a3, v36, a5, a6, a7, a8);
            branchRelease(v38, (CFTypeRef *)v36);
          }
          goto LABEL_43;
        }
        uint64_t v19 = v17 + 28 * v18;
        if ((*(unsigned char *)v19 & 4) == 0)
        {
          int v20 = *(_DWORD *)(v19 + 8);
          uint64_t v21 = *(__int16 *)(v19 + 2);
          __int16 v22 = v21;
          if (a6) {
            goto LABEL_32;
          }
          goto LABEL_31;
        }
        gssVisitState(a1, v18, a3, a4, a5, a6, a7, a8);
      }
LABEL_43:
      if (*(_DWORD *)a1 <= v9) {
        return;
      }
      uint64_t v39 = *(void *)(a1 + 8) + 28 * v9;
      int v40 = *(unsigned __int16 *)(v39 + 12);
      if (!*(_WORD *)(v39 + 12)) {
        return;
      }
      int v41 = 0;
      unsigned int v63 = v9;
      uint64_t v62 = a4;
      int v61 = *(unsigned __int16 *)(v39 + 12);
      while (1)
      {
        uint64_t RHSAtIndex = gssGetRHSAtIndex(a1, v9, v41);
        if ((RHSAtIndex & 0x80000000) == 0)
        {
          uint64_t v43 = RHSAtIndex;
          unsigned int v44 = *(_DWORD *)a1;
          if (*(_DWORD *)a1 <= RHSAtIndex)
          {
            int v45 = 0;
          }
          else
          {
            int v45 = *(_DWORD *)(*(void *)(a1 + 8) + 28 * RHSAtIndex + 8);
            if (v45 == 2) {
              goto LABEL_62;
            }
          }
          if (v44 <= RHSAtIndex)
          {
            __int16 v47 = -1;
            goto LABEL_56;
          }
          uint64_t v46 = *(void *)(a1 + 8);
          if (!v46
            || (*(unsigned char *)(v46 + 28 * RHSAtIndex) & 0x20) == 0
            || gssNodeHasLHS(a1, RHSAtIndex) && gssNodeHasRHS(a1, v43))
          {
            __int16 v47 = *(_WORD *)(*(void *)(a1 + 8) + 28 * v43 + 2);
LABEL_56:
            if ((a6 & 1) == 0)
            {
              *a5 = v47;
              a5[1] = 1;
            }
            if (v44 > v43
              && (uint64_t v48 = *(void *)(a1 + 8)) != 0
              && !(((*(unsigned char *)(v48 + 28 * v43) & 0x20) == 0) | a6 & 1))
            {
              LOWORD(a6) = v47;
              __int16 v55 = v47;
              char v56 = NLBranchCreate(v47, 1);
              int v57 = v45;
              uint64_t v58 = (CFTypeRef *)v56;
              int v59 = gssNodeGetScore(a1, v43);
              NLBranchAddNode((uint64_t)v58, v57, v59);
              int v71 = 0;
              gssNodeGetMaxIndex(a1, v43, &v71);
              uint64_t v69 = (__int16)a6;
              uint64_t v70 = v71 - v55 + 1;
              CFAllocatorRef v60 = (const __CFAllocator *)gssVisitState(a1, v43, a3, v58, &v69, 1, a7, a8);
              branchRelease(v60, v58);
              LOBYTE(a6) = 0;
            }
            else
            {
              CFStringRef v49 = NLBranchCopy(a4);
              int v50 = gssNodeGetScore(a1, v43);
              NLBranchAddNode((uint64_t)v49, v45, v50);
              CFAllocatorRef v51 = (const __CFAllocator *)gssVisitState(a1, v43, a3, v49, a5, a6 & 1, a7, a8);
              branchRelease(v51, (CFTypeRef *)v49);
              std::string v52 = NLBranchCreate(v47, 0);
              int v53 = gssNodeGetScore(a1, v43);
              NLBranchAddNode((uint64_t)v52, v45, v53);
              int v40 = v61;
              a4 = v62;
              unsigned int v9 = v63;
              CFAllocatorRef v54 = (const __CFAllocator *)gssVisitState(a1, v43, a3, v52, a5, a6 & 1, a7, a8);
              branchRelease(v54, (CFTypeRef *)v52);
            }
          }
        }
LABEL_62:
        if (v40 == ++v41) {
          return;
        }
      }
    }
    unsigned int Root = NLBranchGetRoot((CFArrayRef *)a4);
    if (a4)
    {
      if (Root != 1 && CFArrayGetCount(*(CFArrayRef *)a4) >= 3 && CFArrayGetCount(*(CFArrayRef *)a4) <= 4)
      {
        *(_WORD *)(a4 + 12) = v13;
        uint64_t v24 = a5[1];
        *(_WORD *)(a4 + 14) = *a5;
        *(_WORD *)(a4 + 16) = v24;
        *(_WORD *)(a4 + 18) = v14;
        NLParseAddBranch(a3, (__int16 *)a4);
        if (a8)
        {
          uint64_t v25 = a4;
          unsigned int v26 = NLBranchGetRoot((CFArrayRef *)a4);
          unsigned int Leaf = NLBranchGetLeaf((CFArrayRef *)v25);
          uint64_t v28 = *(__int16 *)(v25 + 12);
          a8(a7, v26, Leaf, v28);
        }
      }
    }
  }
}

uint64_t NLParseCompare(_DWORD *a1, _DWORD *a2, void *a3)
{
  int v3 = *((unsigned __int16 *)a1 + 6);
  int v4 = *((unsigned __int16 *)a2 + 6);
  if (v3 == v4)
  {
    int v5 = *((unsigned __int16 *)a1 + 7);
    int v6 = *((unsigned __int16 *)a2 + 7);
    if (v5 == v6)
    {
      unsigned int v7 = a1[2];
      unsigned int v8 = a2[2];
      BOOL v9 = v7 == v8;
      BOOL v10 = v7 > v8;
      uint64_t v11 = -1;
      if (!v10) {
        uint64_t v11 = 1;
      }
      if (v9) {
        return 0;
      }
      else {
        return v11;
      }
    }
    else if ((__int16)v5 > (__int16)v6)
    {
      return -1;
    }
    else
    {
      return 1;
    }
  }
  else if ((__int16)v3 < (__int16)v4)
  {
    return -1;
  }
  else
  {
    return 1;
  }
}

BOOL gssNodeHasLHS(uint64_t a1, unsigned int a2)
{
  BOOL result = 0;
  if ((a2 & 0x80000000) == 0 && *(_DWORD *)a1 > a2)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      uint64_t v3 = v2 + 28 * a2;
      int v5 = *(_DWORD *)(v3 + 20);
      int v4 = (unsigned int *)(v3 + 20);
      if ((v5 & 0x80000000) == 0 || *(_DWORD *)(v2 + 28 * a2 + 12))
      {
        unsigned int v6 = *v4;
        if ((v6 & 0x80000000) != 0
          || *(_DWORD *)a1 <= v6
          || (*(_DWORD *)(v2 + 28 * v6 + 20) & 0x80000000) == 0
          || *(_DWORD *)(v2 + 28 * v6 + 12))
        {
          return 1;
        }
      }
    }
  }
  return result;
}

uint64_t gssNodeGetScore(uint64_t a1, unsigned int a2)
{
  if ((a2 & 0x80000000) == 0)
  {
    unsigned int v2 = a2;
    unsigned int v4 = *(_DWORD *)a1;
    if (*(_DWORD *)a1 > a2)
    {
      uint64_t v5 = 0;
      while (1)
      {
        uint64_t v6 = *(void *)(a1 + 8);
        if (!v6) {
          return v5;
        }
        unsigned int v7 = *(_DWORD *)(v6 + 28 * v2 + 20);
        if ((v7 & 0x80000000) != 0) {
          return v5;
        }
        if (v4 <= v7) {
          unsigned int v8 = 0;
        }
        else {
          unsigned int v8 = *(_DWORD *)(v6 + 28 * v7 + 8);
        }
        unsigned int v9 = *(_DWORD *)(v6 + 28 * v2 + 8);
        uint64_t v10 = v6 + 28 * v2;
        int v11 = *(unsigned __int16 *)(v10 + 12);
        if (*(_WORD *)(v10 + 12))
        {
          int v19 = v5;
          int v12 = 0;
          unsigned int Score = 0;
          int v14 = 0;
          do
          {
            uint64_t RHSAtIndex = gssGetRHSAtIndex(a1, v2, v12);
            if ((RHSAtIndex & 0x80000000) == 0)
            {
              uint64_t v16 = RHSAtIndex;
              if (*(_DWORD *)a1 <= RHSAtIndex) {
                unsigned int v17 = 0;
              }
              else {
                unsigned int v17 = *(_DWORD *)(*(void *)(a1 + 8) + 28 * RHSAtIndex + 8);
              }
              Score += NL::SearchGrammar::getScore(*(NL::SearchGrammar **)(a1 + 80), v9, v8, v17);
              v14 += gssNodeGetScore(a1, v16);
            }
            ++v12;
          }
          while (v11 != v12);
          LODWORD(v5) = v19;
          if (Score) {
            goto LABEL_21;
          }
        }
        else
        {
          int v14 = 0;
        }
        unsigned int Score = NL::SearchGrammar::getScore(*(NL::SearchGrammar **)(a1 + 80), v9, v8, 2u);
LABEL_21:
        uint64_t v5 = v14 + v5 + Score;
        unsigned int v4 = *(_DWORD *)a1;
        unsigned int v2 = v7;
        if (*(_DWORD *)a1 <= v7) {
          return v5;
        }
      }
    }
  }
  return 0;
}

uint64_t gssNodeGetMaxIndex(uint64_t result, unsigned int a2, int *a3)
{
  if ((a2 & 0x80000000) == 0)
  {
    uint64_t v4 = result;
    if (*(_DWORD *)result > a2)
    {
      uint64_t v5 = *(void *)(result + 8);
      if (v5)
      {
        int v8 = *(unsigned __int16 *)(v5 + 28 * a2 + 2);
        if (*a3 > v8) {
          int v8 = *a3;
        }
        *a3 = v8;
        if (*(_DWORD *)result <= a2 || (uint64_t v9 = *(unsigned int *)(v5 + 28 * a2 + 20), (v9 & 0x80000000) != 0)) {
          uint64_t v9 = 0xFFFFFFFFLL;
        }
        BOOL result = gssNodeGetMaxIndex(result, v9, a3);
        uint64_t v10 = v5 + 28 * a2;
        int v12 = *(_DWORD *)(v10 + 12);
        int v11 = (unsigned int *)(v10 + 12);
        if (v12)
        {
          unsigned int v13 = 0;
          do
          {
            uint64_t RHSAtIndex = gssGetRHSAtIndex(v4, a2, v13);
            BOOL result = gssNodeGetMaxIndex(v4, RHSAtIndex, a3);
            ++v13;
          }
          while (v13 < *v11);
        }
      }
    }
  }
  return result;
}

char *NLBranchCopy(uint64_t a1)
{
  unsigned int v2 = (char *)malloc_type_calloc(1uLL, 0x20uLL, 0x102004086FE837DuLL);
  if (v2)
  {
    CFMutableStringRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    *(void *)unsigned int v2 = Mutable;
    CFArrayRef v4 = *(const __CFArray **)a1;
    v6.CFIndex length = CFArrayGetCount(*(CFArrayRef *)a1);
    v6.CFIndex location = 0;
    CFArrayAppendArray(Mutable, v4, v6);
    *(void *)(v2 + 12) = *(void *)(a1 + 12);
    *((_DWORD *)v2 + 2) = *(_DWORD *)(a1 + 8);
    v2[20] = *(unsigned char *)(a1 + 20);
    *((_DWORD *)v2 + 6) = 1;
  }
  return v2;
}

void NLCompositeTransliterator::NLCompositeTransliterator(NLCompositeTransliterator *this, const __CFLocale *a2, const __CFURL *a3)
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  operator new();
}

void sub_1A43DD0C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  MEMORY[0x1A625B130](v6, 0xE1C409BBF8FE8);
  applesauce::CF::DictionaryRef::~DictionaryRef((const void **)va);
  nlp::CFScopedPtr<__EmojiLocaleDataWrapper const*>::reset((const void **)(v3 + 40), 0);
  uint64_t v8 = *(void *)(v3 + 32);
  *(void *)(v3 + 32) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  uint64_t v9 = *(void *)(v3 + 24);
  *(void *)(v3 + 24) = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  std::unique_ptr<NLCompositeTransliteratorLexicon>::reset[abi:ne180100](v5, 0);
  std::unique_ptr<NLCompositeTransliteratorException>::reset[abi:ne180100](v4, 0);
  std::unique_ptr<NLCompositeTransliteratorSeq2Seq>::reset[abi:ne180100]((NLCompositeTransliteratorSeq2Seq **)v3, 0);
  _Unwind_Resume(a1);
}

NLCompositeTransliteratorSeq2Seq *std::unique_ptr<NLCompositeTransliteratorSeq2Seq>::reset[abi:ne180100](NLCompositeTransliteratorSeq2Seq **a1, NLCompositeTransliteratorSeq2Seq *a2)
{
  BOOL result = *a1;
  *a1 = a2;
  if (result)
  {
    NLCompositeTransliteratorSeq2Seq::~NLCompositeTransliteratorSeq2Seq(result);
    JUMPOUT(0x1A625B130);
  }
  return result;
}

NL::StringMap **std::unique_ptr<NLCompositeTransliteratorException>::reset[abi:ne180100](NL::StringMap ***a1, NL::StringMap **a2)
{
  BOOL result = *a1;
  *a1 = a2;
  if (result)
  {
    NLCompositeTransliteratorException::~NLCompositeTransliteratorException(result);
    JUMPOUT(0x1A625B130);
  }
  return result;
}

const void **std::unique_ptr<NLCompositeTransliteratorLexicon>::reset[abi:ne180100](const void ***a1, const void **a2)
{
  BOOL result = *a1;
  *a1 = a2;
  if (result)
  {
    NLCompositeTransliteratorLexicon::~NLCompositeTransliteratorLexicon(result);
    JUMPOUT(0x1A625B130);
  }
  return result;
}

void applesauce::CF::DictionaryRef::~DictionaryRef(const void **this)
{
  uint64_t v1 = *this;
  if (v1) {
    CFRelease(v1);
  }
}

void NLCompositeTransliterator::~NLCompositeTransliterator(NLCompositeTransliterator *this)
{
  nlp::CFScopedPtr<__EmojiLocaleDataWrapper const*>::reset((const void **)this + 5, 0);
  uint64_t v2 = *((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  std::unique_ptr<NLCompositeTransliteratorLexicon>::reset[abi:ne180100]((const void ***)this + 2, 0);
  std::unique_ptr<NLCompositeTransliteratorException>::reset[abi:ne180100]((NL::StringMap ***)this + 1, 0);
  std::unique_ptr<NLCompositeTransliteratorSeq2Seq>::reset[abi:ne180100]((NLCompositeTransliteratorSeq2Seq **)this, 0);
}

BOOL NLCompositeTransliterator::isTransliteratedWordInLexiconForCandidate(NLCompositeTransliterator *this, NLTransliterationCandidate *a2)
{
  uint64_t TransliteratedWord = NLTransliterationCandidate::getTransliteratedWord(a2);
  if (*(char *)(TransliteratedWord + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)TransliteratedWord, *(void *)(TransliteratedWord + 8));
  }
  else
  {
    long long v4 = *(_OWORD *)TransliteratedWord;
    __p.__r_.__value_.__r.__words[2] = *(void *)(TransliteratedWord + 16);
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v4;
  }
  std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  if (!size)
  {
    BOOL isMemberOfTheNativeLexicon = 0;
    if ((*((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x80) == 0) {
      return isMemberOfTheNativeLexicon;
    }
    goto LABEL_8;
  }
  BOOL isMemberOfTheNativeLexicon = NLCompositeTransliteratorLexicon::isMemberOfTheNativeLexicon(*((void *)this + 2), (uint64_t)&__p);
  if ((*((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x80) != 0) {
LABEL_8:
  }
    operator delete(__p.__r_.__value_.__l.__data_);
  return isMemberOfTheNativeLexicon;
}

void sub_1A43DD4B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

unint64_t NLCompositeTransliterator::updateCandidatesWithEmojiCandidates(uint64_t a1, uint64_t a2)
{
  if (!*(void *)(a1 + 40) || *(void *)a2 == *(void *)(a2 + 8)) {
    return 0;
  }
  NLAbstractOrthographyConvertor::~NLAbstractOrthographyConvertor(**(NLAbstractOrthographyConvertor ***)a2);
  if (*((char *)v3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&v31, *(const std::string::value_type **)v3, *((void *)v3 + 1));
  }
  else
  {
    long long v4 = *v3;
    v31.__r_.__value_.__r.__words[2] = *((void *)v3 + 2);
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v4;
  }
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  unint64_t v30 = 0;
  for (unint64_t i = *(NLTransliterationCandidate ***)a2; i != *(NLTransliterationCandidate ***)(a2 + 8); ++i)
  {
    uint64_t TransliteratedWord = NLTransliterationCandidate::getTransliteratedWord(*i);
    CFStringRef CFStringFromString = createCFStringFromString(TransliteratedWord);
    CFTypeRef v27 = CFStringFromString;
    EmojiTokensForCFStringRef String = (const void *)CEMEmojiLocaleDataCreateEmojiTokensForString();
    CFTypeRef cf = EmojiTokensForString;
    if (EmojiTokensForString)
    {
      for (CFIndex j = 0; j < CFArrayGetCount((CFArrayRef)EmojiTokensForString); ++j)
      {
        CFArrayGetValueAtIndex((CFArrayRef)EmojiTokensForString, j);
        CFStringRef String = (const __CFString *)CEMEmojiTokenGetString();
        getUTF8StringFromCFString(String, __p);
        int v12 = v29;
        if ((unint64_t)v29 >= v30)
        {
          int v14 = (std::string *)std::vector<std::string>::__push_back_slow_path<std::string const&>((uint64_t *)&v28, (long long *)__p);
        }
        else
        {
          if (SHIBYTE(v25) < 0)
          {
            std::string::__init_copy_ctor_external(v29, (const std::string::value_type *)__p[0], (std::string::size_type)__p[1]);
          }
          else
          {
            long long v13 = *(_OWORD *)__p;
            v29->__r_.__value_.__r.__words[2] = v25;
            *(_OWORD *)&v12->__r_.__value_.__l.__data_ = v13;
          }
          int v14 = v12 + 1;
        }
        uint64_t v29 = v14;
        if (SHIBYTE(v25) < 0) {
          operator delete(__p[0]);
        }
      }
      if (v28 != v29)
      {
        __p[0] = 0;
        __p[1] = 0;
        std::string::size_type v25 = 0;
        uint64_t v15 = HIBYTE(v28->__r_.__value_.__r.__words[2]);
        if ((v15 & 0x80u) == 0) {
          std::string::size_type size = (unsigned __int8 *)HIBYTE(v28->__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type size = (unsigned __int8 *)v28->__r_.__value_.__l.__size_;
        }
        unsigned int v17 = (unsigned __int8 *)HIBYTE(v28->__r_.__value_.__r.__words[2]);
        int v18 = (char)v17;
        if ((char)v17 < 0) {
          unsigned int v17 = (unsigned __int8 *)v28->__r_.__value_.__l.__size_;
        }
        if (size == v17)
        {
          if (v18 >= 0) {
            int v19 = v28;
          }
          else {
            int v19 = (std::string *)v28->__r_.__value_.__r.__words[0];
          }
          if ((v15 & 0x80) != 0)
          {
            memcmp(v28->__r_.__value_.__l.__data_, v19, v28->__r_.__value_.__l.__size_);
          }
          else if (*((unsigned char *)&v28->__r_.__value_.__s + 23))
          {
            uint64_t v20 = 0;
            uint64_t v21 = v15 - 1;
            do
            {
              BOOL v22 = v28->__r_.__value_.__s.__data_[v20] != v19->__r_.__value_.__s.__data_[v20] || v21 == v20;
              ++v20;
            }
            while (!v22);
          }
        }
        operator new();
      }
      CFRelease(EmojiTokensForString);
    }
    if (CFStringFromString) {
      CFRelease(CFStringFromString);
    }
  }
  unint64_t v5 = 0xAAAAAAAAAAAAAAABLL * (((char *)v29 - (char *)v28) >> 3);
  __p[0] = &v28;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
  if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v31.__r_.__value_.__l.__data_);
  }
  return v5;
}

void sub_1A43DD88C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, __int16 *__p, __int16 *a10, int a11, __int16 a12, char a13, char a14, const void *a15, const void *a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (__p)
  {
    a10 = __p;
    operator delete(__p);
  }
  nlp::CFScopedPtr<__CFArray const*>::reset(&a15, 0);
  nlp::CFScopedPtr<__CFString const*>::reset(&a16, 0);
  std::string __p = &a17;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  if (a27 < 0) {
    operator delete(a22);
  }
  _Unwind_Resume(a1);
}

void NLCompositeTransliterator::trimCandidatesToSize(uint64_t a1, uint64_t *a2, unint64_t a3)
{
  uint64_t v6 = *a2;
  uint64_t v5 = a2[1];
  unint64_t v7 = (v5 - *a2) >> 3;
  if (v7 > a3)
  {
    unint64_t v8 = a3;
    do
    {
      uint64_t v9 = *(void *)(v6 + 8 * v8);
      if (v9)
      {
        if (*(char *)(v9 + 47) < 0) {
          operator delete(*(void **)(v9 + 24));
        }
        if (*(char *)(v9 + 23) < 0) {
          operator delete(*(void **)v9);
        }
        MEMORY[0x1A625B130](v9, 0x1012C40B0087DDBLL);
        uint64_t v6 = *a2;
        uint64_t v5 = a2[1];
      }
      ++v8;
    }
    while (v8 < (v5 - v6) >> 3);
    unint64_t v7 = (v5 - v6) >> 3;
  }
  if (v7 > a3)
  {
    std::vector<NLTransliterationCandidate *>::resize((uint64_t)a2, a3);
  }
}

void std::vector<NLTransliterationCandidate *>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 8 * a2;
    }
  }
  else
  {
    std::vector<NLTransliterationCandidate *>::__append((void **)a1, a2 - v2);
  }
}

uint64_t NLCompositeTransliterator::setIsInVocabularyforCandidates(uint64_t result, NLTransliterationCandidate ***a2)
{
  unint64_t v2 = *a2;
  uint64_t v3 = a2[1];
  if (*a2 != v3)
  {
    long long v4 = (NLCompositeTransliterator *)result;
    do
    {
      uint64_t v5 = *v2;
      int Type = NLTransliterationCandidate::getType(*v2);
      if (Type) {
        BOOL v7 = Type == 5;
      }
      else {
        BOOL v7 = 1;
      }
      if (v7 || (BOOL result = NLCompositeTransliterator::isTransliteratedWordInLexiconForCandidate(v4, v5), result)) {
        BOOL result = NLTransliterationCandidate::setIsInVocabulary((uint64_t)v5, 1);
      }
      ++v2;
    }
    while (v2 != v3);
  }
  return result;
}

void NLCompositeTransliterator::assignLanguageModelScoreToCandidates(uint64_t a1, NLTransliterationCandidate ***a2, uint64_t *a3)
{
  if (*(void *)(a1 + 24))
  {
    std::string __p = 0;
    uint64_t v24 = 0;
    uint64_t v5 = *a3;
    uint64_t v6 = a3[1];
    uint64_t v25 = 0;
    p_p = &__p;
    while (v5 != v6)
    {
      int v7 = *(char *)(v5 + 23);
      if (v7 >= 0) {
        unint64_t v8 = (const UInt8 *)v5;
      }
      else {
        unint64_t v8 = *(const UInt8 **)v5;
      }
      if (v7 >= 0) {
        CFIndex v9 = *(unsigned __int8 *)(v5 + 23);
      }
      else {
        CFIndex v9 = *(void *)(v5 + 8);
      }
      CFStringRef v10 = CFStringCreateWithBytes(0, v8, v9, 0x8000100u, 0);
      if (!v10)
      {
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Could not construct");
        __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
      }
      applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&cf, v10);
      (*(void (**)(void))(**(void **)(a1 + 24) + 56))(*(void *)(a1 + 24));
      TokenIDForCFStringRef String = LMLanguageModelGetTokenIDForString();
      if (cf) {
        CFRelease(cf);
      }
      LODWORD(cf) = TokenIDForString;
      std::back_insert_iterator<std::vector<unsigned int>>::operator=[abi:ne180100]((uint64_t *)&p_p, &cf);
      v5 += 24;
    }
    int v12 = *a2;
    long long v13 = a2[1];
    if (*a2 == v13)
    {
      int v18 = *a2;
    }
    else
    {
      do
      {
        int v14 = *v12;
        uint64_t v15 = *(void *)(a1 + 24);
        uint64_t TransliteratedWord = NLTransliterationCandidate::getTransliteratedWord(*v12);
        double v17 = (*(double (**)(uint64_t, uint64_t))(*(void *)v15 + 24))(v15, TransliteratedWord);
        NLTransliterationCandidate::setLMScore((uint64_t)v14, v17);
        ++v12;
      }
      while (v12 != v13);
      int v18 = *a2;
      int v12 = a2[1];
    }
    if ((char *)v12 - (char *)v18 < 1025)
    {
      int v19 = 0;
      uint64_t v21 = 0;
    }
    else
    {
      int v19 = (NLTransliterationCandidate **)std::get_temporary_buffer[abi:ne180100]<NLTransliterationCandidate *>(v12 - v18);
      uint64_t v21 = v20;
    }
    std::__stable_sort<std::_ClassicAlgPolicy,NLCompositeTransliterator::assignLanguageModelScoreToCandidates(std::vector<NLTransliterationCandidate *> &,std::vector<std::string> const&)::$_2 &,std::__wrap_iter<NLTransliterationCandidate **>>(v18, v12, v12 - v18, v19, v21);
    if (v19) {
      operator delete(v19);
    }
    if (__p)
    {
      uint64_t v24 = __p;
      operator delete(__p);
    }
  }
}

void sub_1A43DDCC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, CFTypeRef cf)
{
  if (v14) {
    operator delete(v14);
  }
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void NLCompositeTransliterator::getTransliterationCandidates(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, std::string *a5@<X8>)
{
  uint64_t v74 = *MEMORY[0x1E4F143B8];
  NLOSSignPostgetTransliterationCandidates::NLOSSignPostgetTransliterationCandidates((NLOSSignPostgetTransliterationCandidates *)&v67);
  a5->__r_.__value_.__r.__words[0] = 0;
  a5->__r_.__value_.__l.__size_ = 0;
  a5->__r_.__value_.__r.__words[2] = 0;
  if (*(char *)(a3 + 23) < 0) {
    std::string::__init_copy_ctor_external(&v66, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
  }
  else {
    std::string v66 = *(std::string *)a3;
  }
  char v10 = HIBYTE(v66.__r_.__value_.__r.__words[2]);
  if ((v66.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v11 = (std::string *)((char *)&v66 + HIBYTE(v66.__r_.__value_.__r.__words[2]));
  }
  else {
    int v11 = (std::string *)(v66.__r_.__value_.__r.__words[0] + v66.__r_.__value_.__l.__size_);
  }
  if ((v66.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v12 = &v66;
  }
  else {
    int v12 = (std::string *)v66.__r_.__value_.__r.__words[0];
  }
  if (v12 != v11)
  {
    do
    {
      v12->__r_.__value_.__s.__data_[0] = __tolower(v12->__r_.__value_.__s.__data_[0]);
      int v12 = (std::string *)((char *)v12 + 1);
    }
    while (v12 != v11);
    char v10 = HIBYTE(v66.__r_.__value_.__r.__words[2]);
  }
  if (v10 < 0)
  {
    std::string::__init_copy_ctor_external(&v69, v66.__r_.__value_.__l.__data_, v66.__r_.__value_.__l.__size_);
    if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v66.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    std::string v69 = v66;
  }
  std::string v66 = v69;
  NLCompositeTransliteratorSeq2Seq::seq2SeqCandidatesForInput(*(uint64_t **)a1, (uint64_t **)&v66, &v64);
  NLCompositeTransliteratorException::exceptionCandidatesForInput(*(uint64_t ***)(a1 + 8), a3, &v62);
  long long v13 = (char *)v62;
  uint64_t v14 = (uint64_t)v63;
  if (v62 == v63)
  {
    NLCompositeTransliteratorException::exceptionCandidatesForInput(*(uint64_t ***)(a1 + 8), (uint64_t)&v66, &v69);
    std::vector<NLTextSlot *>::__assign_with_size[abi:ne180100]<NLTextSlot **,NLTextSlot **>((char *)&v62, v69.__r_.__value_.__l.__data_, v69.__r_.__value_.__l.__size_, (uint64_t)(v69.__r_.__value_.__l.__size_ - v69.__r_.__value_.__r.__words[0]) >> 3);
    if (v69.__r_.__value_.__r.__words[0])
    {
      v69.__r_.__value_.__l.__size_ = v69.__r_.__value_.__r.__words[0];
      operator delete(v69.__r_.__value_.__l.__data_);
    }
    long long v13 = (char *)v62;
    uint64_t v14 = (uint64_t)v63;
  }
  if (v13 == (char *)v14)
  {
    NLCompositeTransliteratorLexicon::lexiconCandidatesForInput(*(uint64_t **)(a1 + 16), (uint64_t)&v66, &v69);
    if (v69.__r_.__value_.__l.__size_ == v69.__r_.__value_.__r.__words[0])
    {
      if (&v64 != (void **)a5) {
        std::vector<NLTextSlot *>::__assign_with_size[abi:ne180100]<NLTextSlot **,NLTextSlot **>((char *)a5, (char *)v64, (uint64_t)v65, ((char *)v65 - (unsigned char *)v64) >> 3);
      }
    }
    else
    {
      if (&v69 != a5) {
        std::vector<NLTextSlot *>::__assign_with_size[abi:ne180100]<NLTextSlot **,NLTextSlot **>((char *)a5, v69.__r_.__value_.__l.__data_, v69.__r_.__value_.__l.__size_, (uint64_t)(v69.__r_.__value_.__l.__size_ - v69.__r_.__value_.__r.__words[0]) >> 3);
      }
      unint64_t v30 = (NLTransliterationCandidate **)v64;
      std::string v31 = v65;
      if (v64 != v65)
      {
        do
        {
          if (candidateSurfaceFormPresentInVector(*v30, (NLTransliterationCandidate ***)a5))
          {
            int v32 = *v30;
            if (*v30)
            {
              if (*((char *)v32 + 47) < 0) {
                operator delete(*((void **)v32 + 3));
              }
              if (*((char *)v32 + 23) < 0) {
                operator delete(*(void **)v32);
              }
              MEMORY[0x1A625B130](v32, 0x1012C40B0087DDBLL);
            }
          }
          else
          {
            std::string::size_type size = (void *)a5->__r_.__value_.__l.__size_;
            unint64_t v33 = a5->__r_.__value_.__r.__words[2];
            if ((unint64_t)size >= v33)
            {
              uint64_t v36 = (uint64_t)((uint64_t)size - a5->__r_.__value_.__r.__words[0]) >> 3;
              if ((unint64_t)(v36 + 1) >> 61) {
                std::vector<NLExtendedString>::__throw_length_error[abi:ne180100]();
              }
              uint64_t v37 = v33 - a5->__r_.__value_.__r.__words[0];
              uint64_t v38 = v37 >> 2;
              if (v37 >> 2 <= (unint64_t)(v36 + 1)) {
                uint64_t v38 = v36 + 1;
              }
              if ((unint64_t)v37 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v39 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v39 = v38;
              }
              if (v39) {
                int v40 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NLTransliterationCandidate *>>((uint64_t)&a5->__r_.__value_.__r.__words[2], v39);
              }
              else {
                int v40 = 0;
              }
              int v41 = (NLTransliterationCandidate **)&v40[8 * v36];
              *int v41 = *v30;
              uint64_t v35 = v41 + 1;
              std::string::pointer v43 = (std::string::pointer)a5->__r_.__value_.__r.__words[0];
              std::string::pointer v42 = (std::string::pointer)a5->__r_.__value_.__l.__size_;
              if (v42 != a5->__r_.__value_.__l.__data_)
              {
                do
                {
                  unsigned int v44 = (NLTransliterationCandidate *)*((void *)v42 - 1);
                  v42 -= 8;
                  *--int v41 = v44;
                }
                while (v42 != v43);
                std::string::pointer v42 = (std::string::pointer)a5->__r_.__value_.__r.__words[0];
              }
              a5->__r_.__value_.__r.__words[0] = (std::string::size_type)v41;
              a5->__r_.__value_.__l.__size_ = (std::string::size_type)v35;
              a5->__r_.__value_.__r.__words[2] = (std::string::size_type)&v40[8 * v39];
              if (v42) {
                operator delete(v42);
              }
            }
            else
            {
              *std::string::size_type size = *v30;
              uint64_t v35 = size + 1;
            }
            a5->__r_.__value_.__l.__size_ = (std::string::size_type)v35;
          }
          ++v30;
        }
        while (v30 != v31);
      }
    }
    NLCompositeTransliterator::assignLanguageModelScoreToCandidates(a1, (NLTransliterationCandidate ***)a5, a2);
    if (v69.__r_.__value_.__r.__words[0])
    {
      v69.__r_.__value_.__l.__size_ = v69.__r_.__value_.__r.__words[0];
      operator delete(v69.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    if (&v62 != (void **)a5) {
      std::vector<NLTextSlot *>::__assign_with_size[abi:ne180100]<NLTextSlot **,NLTextSlot **>((char *)a5, v13, v14, (v14 - (uint64_t)v13) >> 3);
    }
    NLCompositeTransliterator::assignLanguageModelScoreToCandidates(a1, (NLTransliterationCandidate ***)&v64, a2);
    uint64_t v15 = (NLTransliterationCandidate **)v64;
    uint64_t v16 = v65;
    if (v64 != v65)
    {
      do
      {
        if (candidateSurfaceFormPresentInVector(*v15, (NLTransliterationCandidate ***)a5))
        {
          double v17 = *v15;
          if (*v15)
          {
            if (*((char *)v17 + 47) < 0) {
              operator delete(*((void **)v17 + 3));
            }
            if (*((char *)v17 + 23) < 0) {
              operator delete(*(void **)v17);
            }
            MEMORY[0x1A625B130](v17, 0x1012C40B0087DDBLL);
          }
        }
        else
        {
          int v19 = (void *)a5->__r_.__value_.__l.__size_;
          unint64_t v18 = a5->__r_.__value_.__r.__words[2];
          if ((unint64_t)v19 >= v18)
          {
            uint64_t v21 = (uint64_t)((uint64_t)v19 - a5->__r_.__value_.__r.__words[0]) >> 3;
            if ((unint64_t)(v21 + 1) >> 61) {
              std::vector<NLExtendedString>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v22 = v18 - a5->__r_.__value_.__r.__words[0];
            uint64_t v23 = v22 >> 2;
            if (v22 >> 2 <= (unint64_t)(v21 + 1)) {
              uint64_t v23 = v21 + 1;
            }
            if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v24 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v24 = v23;
            }
            if (v24) {
              uint64_t v25 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NLTransliterationCandidate *>>((uint64_t)&a5->__r_.__value_.__r.__words[2], v24);
            }
            else {
              uint64_t v25 = 0;
            }
            unsigned int v26 = (NLTransliterationCandidate **)&v25[8 * v21];
            CFArrayRef *v26 = *v15;
            uint64_t v20 = v26 + 1;
            std::string::pointer v28 = (std::string::pointer)a5->__r_.__value_.__r.__words[0];
            std::string::pointer v27 = (std::string::pointer)a5->__r_.__value_.__l.__size_;
            if (v27 != a5->__r_.__value_.__l.__data_)
            {
              do
              {
                uint64_t v29 = (NLTransliterationCandidate *)*((void *)v27 - 1);
                v27 -= 8;
                *--unsigned int v26 = v29;
              }
              while (v27 != v28);
              std::string::pointer v27 = (std::string::pointer)a5->__r_.__value_.__r.__words[0];
            }
            a5->__r_.__value_.__r.__words[0] = (std::string::size_type)v26;
            a5->__r_.__value_.__l.__size_ = (std::string::size_type)v20;
            a5->__r_.__value_.__r.__words[2] = (std::string::size_type)&v25[8 * v24];
            if (v27) {
              operator delete(v27);
            }
          }
          else
          {
            *int v19 = *v15;
            uint64_t v20 = v19 + 1;
          }
          a5->__r_.__value_.__l.__size_ = (std::string::size_type)v20;
        }
        ++v15;
      }
      while (v15 != v16);
    }
  }
  if (*(void *)(a1 + 32))
  {
    int v45 = (NLTransliterationCandidate **)a5->__r_.__value_.__r.__words[0];
    while (1)
    {
      while (1)
      {
        if (v45 == (NLTransliterationCandidate **)a5->__r_.__value_.__l.__size_) {
          goto LABEL_101;
        }
        uint64_t TransliteratedWord = NLTransliterationCandidate::getTransliteratedWord(*v45);
        CFStringRef CFStringFromString = createCFStringFromString(TransliteratedWord);
        v69.__r_.__value_.__r.__words[0] = (std::string::size_type)CFStringFromString;
        if (((*(uint64_t (**)(void, CFStringRef, void, void))(**(void **)(a1 + 32) + 16))(*(void *)(a1 + 32), CFStringFromString, 0, 0) & 1) == 0)break; {
        ++v45;
        }
        if (CFStringFromString) {
          goto LABEL_100;
        }
      }
      uint64_t v48 = *v45;
      if (*v45)
      {
        if (*((char *)v48 + 47) < 0) {
          operator delete(*((void **)v48 + 3));
        }
        if (*((char *)v48 + 23) < 0) {
          operator delete(*(void **)v48);
        }
        MEMORY[0x1A625B130](v48, 0x1012C40B0087DDBLL);
      }
      CFStringRef v49 = (NLTransliterationCandidate **)a5->__r_.__value_.__l.__size_;
      int64_t v50 = (char *)v49 - (char *)(v45 + 1);
      if (v49 != v45 + 1) {
        memmove(v45, v45 + 1, (char *)v49 - (char *)(v45 + 1));
      }
      a5->__r_.__value_.__l.__size_ = (std::string::size_type)v45 + v50;
      if (CFStringFromString) {
LABEL_100:
      }
        CFRelease(CFStringFromString);
    }
  }
LABEL_101:
  unint64_t updated = NLCompositeTransliterator::updateCandidatesWithEmojiCandidates(a1, (uint64_t)a5);
  if (updated + 5 >= updated + a4) {
    unint64_t v52 = updated + a4;
  }
  else {
    unint64_t v52 = updated + 5;
  }
  NLCompositeTransliterator::trimCandidatesToSize(updated, (uint64_t *)a5, v52);
  NLCompositeTransliterator::setIsInVocabularyforCandidates(a1, (NLTransliterationCandidate ***)a5);
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v69);
  int v53 = (uint64_t *)a5->__r_.__value_.__r.__words[0];
  CFAllocatorRef v54 = (uint64_t *)a5->__r_.__value_.__l.__size_;
  if ((uint64_t *)a5->__r_.__value_.__l.__data_ != v54)
  {
    __int16 v55 = (std::locale::id *)MEMORY[0x1E4FBA258];
    do
    {
      uint64_t v56 = *v53;
      int v57 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v69, (uint64_t)"<", 1);
      uint64_t v58 = operator<<(v57, v56);
      int v59 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v58, (uint64_t)">", 1);
      std::ios_base::getloc((const std::ios_base *)((char *)v59 + *(void *)(*v59 - 24)));
      CFAllocatorRef v60 = std::locale::use_facet(&v68, v55);
      ((void (*)(const std::locale::facet *, uint64_t))v60->__vftable[2].~facet_0)(v60, 10);
      std::locale::~locale(&v68);
      std::ostream::put();
      std::ostream::flush();
      ++v53;
    }
    while (v53 != v54);
  }
  int v61 = _nlpDefaultLog();
  if (os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG))
  {
    std::stringbuf::str();
    NLCompositeTransliterator::getTransliterationCandidates((char *)&v68, buf, v61);
  }
  v69.__r_.__value_.__r.__words[0] = *MEMORY[0x1E4FBA418];
  *(std::string::size_type *)((char *)v69.__r_.__value_.__r.__words + *(void *)(v69.__r_.__value_.__r.__words[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v69.__r_.__value_.__l.__size_ = MEMORY[0x1E4FBA470] + 16;
  if (v71 < 0) {
    operator delete(__p);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1A625B0A0](&v72);
  if (v62)
  {
    unsigned int v63 = v62;
    operator delete(v62);
  }
  if (v64)
  {
    long long v65 = (NLTransliterationCandidate **)v64;
    operator delete(v64);
  }
  if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v66.__r_.__value_.__l.__data_);
  }
  NLOSSignPostgetTransliterationCandidates::~NLOSSignPostgetTransliterationCandidates(&v67);
}

void sub_1A43DE510(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,os_signpost_id_t a22,std::locale a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27)
{
  if (__p)
  {
    a27 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a9) {
    operator delete(a9);
  }
  if (a12) {
    operator delete(a12);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  uint64_t v29 = *(void **)v27;
  if (*(void *)v27)
  {
    *(void *)(v27 + 8) = v29;
    operator delete(v29);
  }
  NLOSSignPostgetTransliterationCandidates::~NLOSSignPostgetTransliterationCandidates(&a22);
  _Unwind_Resume(a1);
}

uint64_t candidateSurfaceFormPresentInVector(NLTransliterationCandidate *a1, NLTransliterationCandidate ***a2)
{
  unint64_t v2 = *a2;
  uint64_t v3 = a2[1];
  if (*a2 == v3) {
    return 0;
  }
  while (1)
  {
    uint64_t TransliteratedWord = (unsigned __int8 *)NLTransliterationCandidate::getTransliteratedWord(*v2);
    uint64_t v6 = NLTransliterationCandidate::getTransliteratedWord(a1);
    uint64_t v7 = TransliteratedWord[23];
    if ((v7 & 0x80u) == 0) {
      uint64_t v8 = TransliteratedWord[23];
    }
    else {
      uint64_t v8 = *((void *)TransliteratedWord + 1);
    }
    uint64_t v9 = *(unsigned __int8 *)(v6 + 23);
    int v10 = (char)v9;
    if ((v9 & 0x80u) != 0) {
      uint64_t v9 = *(void *)(v6 + 8);
    }
    if (v8 != v9) {
      goto LABEL_17;
    }
    int v11 = v10 >= 0 ? (unsigned __int8 *)v6 : *(unsigned __int8 **)v6;
    if ((v7 & 0x80) != 0) {
      break;
    }
    if (!TransliteratedWord[23]) {
      return 1;
    }
    while (*TransliteratedWord == *v11)
    {
      ++TransliteratedWord;
      ++v11;
      if (!--v7) {
        return 1;
      }
    }
LABEL_17:
    if (++v2 == v3) {
      return 0;
    }
  }
  if (memcmp(*(const void **)TransliteratedWord, v11, *((void *)TransliteratedWord + 1))) {
    goto LABEL_17;
  }
  return 1;
}

applesauce::CF::DictionaryRef *applesauce::CF::DictionaryRef::DictionaryRef(applesauce::CF::DictionaryRef *this, CFTypeRef cf)
{
  *(void *)this = cf;
  if (cf)
  {
    CFTypeID v3 = CFGetTypeID(cf);
    if (v3 != CFDictionaryGetTypeID())
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Could not construct");
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
  }
  return this;
}

void sub_1A43DE774(_Unwind_Exception *a1)
{
  __cxa_free_exception(v2);
  if (*v1) {
    CFRelease(*v1);
  }
  _Unwind_Resume(a1);
}

void NLOSSignPostgetTransliterationCandidates::NLOSSignPostgetTransliterationCandidates(NLOSSignPostgetTransliterationCandidates *this)
{
  unint64_t v2 = _nlpSignpostLog();
  *(void *)this = os_signpost_id_make_with_pointer(v2, this);
  CFTypeID v3 = _nlpSignpostLog();
  os_signpost_id_t v4 = *(void *)this;
  if ((unint64_t)(*(void *)this - 1) <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v5 = v3;
    if (os_signpost_enabled(v3))
    {
      *(_WORD *)uint64_t v6 = 0;
      _os_signpost_emit_with_name_impl(&dword_1A431F000, v5, OS_SIGNPOST_INTERVAL_BEGIN, v4, "getTransliterationCandidates", (const char *)&unk_1A441379D, v6, 2u);
    }
  }
}

void NLOSSignPostgetTransliterationCandidates::~NLOSSignPostgetTransliterationCandidates(os_signpost_id_t *this)
{
  unint64_t v2 = _nlpSignpostLog();
  os_signpost_id_t v3 = *this;
  if (*this - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    os_signpost_id_t v4 = v2;
    if (os_signpost_enabled(v2))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_signpost_emit_with_name_impl(&dword_1A431F000, v4, OS_SIGNPOST_INTERVAL_END, v3, "getTransliterationCandidates", (const char *)&unk_1A441379D, v5, 2u);
    }
  }
}

void nlp::CFScopedPtr<__EmojiLocaleDataWrapper const*>::reset(const void **a1, const void *a2)
{
  os_signpost_id_t v4 = *a1;
  if (v4) {
    CFRelease(v4);
  }
  *a1 = a2;
}

char *std::vector<NLTransliterationCandidate *>::__insert_with_size[abi:ne180100]<std::__wrap_iter<NLTransliterationCandidate **>,std::__wrap_iter<NLTransliterationCandidate **>>(uint64_t a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  uint64_t v5 = (char *)__dst;
  if (a5 < 1) {
    return v5;
  }
  uint64_t v7 = __src;
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v9 = a1 + 16;
  uint64_t v10 = v11;
  unint64_t v12 = *(void *)(v9 - 8);
  if (a5 > (uint64_t)(v11 - v12) >> 3)
  {
    long long v13 = *(void **)a1;
    unint64_t v14 = a5 + ((uint64_t)(v12 - *(void *)a1) >> 3);
    if (v14 >> 61) {
      std::vector<NLExtendedString>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v15 = (__dst - (uint64_t)v13) >> 3;
    uint64_t v16 = v10 - (void)v13;
    if (v16 >> 2 > v14) {
      unint64_t v14 = v16 >> 2;
    }
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v14;
    }
    uint64_t v37 = v9;
    if (v17) {
      unint64_t v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NLTransliterationCandidate *>>(v9, v17);
    }
    else {
      unint64_t v18 = 0;
    }
    std::string::pointer v28 = &v18[8 * v15];
    std::string __p = v18;
    CFAllocatorRef v34 = v28;
    uint64_t v36 = &v18[8 * v17];
    uint64_t v29 = 8 * a5;
    unint64_t v30 = &v28[8 * a5];
    do
    {
      uint64_t v31 = *(void *)v7;
      v7 += 8;
      *(void *)std::string::pointer v28 = v31;
      v28 += 8;
      v29 -= 8;
    }
    while (v29);
    uint64_t v35 = v30;
    uint64_t v5 = std::vector<NLTransliterationCandidate *>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v5);
    if (v35 != v34) {
      v35 += (v34 - v35 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    if (__p) {
      operator delete(__p);
    }
    return v5;
  }
  uint64_t v19 = v12 - __dst;
  uint64_t v20 = (uint64_t)(v12 - __dst) >> 3;
  if (v20 >= a5)
  {
    uint64_t v21 = &__src[8 * a5];
    uint64_t v23 = *(char **)(v9 - 8);
LABEL_17:
    unint64_t v24 = &v5[8 * a5];
    uint64_t v25 = &v23[-8 * a5];
    unsigned int v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      unsigned int v26 = v23;
      do
      {
        uint64_t v27 = *(void *)v25;
        v25 += 8;
        *(void *)unsigned int v26 = v27;
        v26 += 8;
      }
      while ((unint64_t)v25 < v12);
    }
    *(void *)(a1 + 8) = v26;
    if (v23 != v24) {
      memmove(&v23[-8 * ((v23 - v24) >> 3)], v5, v23 - v24);
    }
    if (v21 != v7) {
      memmove(v5, v7, v21 - v7);
    }
    return v5;
  }
  uint64_t v21 = &__src[8 * v20];
  int64_t v22 = a4 - v21;
  if (a4 != v21) {
    memmove(*(void **)(v9 - 8), &__src[8 * v20], a4 - v21);
  }
  uint64_t v23 = (char *)(v12 + v22);
  *(void *)(a1 + 8) = v12 + v22;
  if (v19 >= 1) {
    goto LABEL_17;
  }
  return v5;
}

void sub_1A43DEAD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<NLTransliterationCandidate *>::__swap_out_circular_buffer(void **a1, uint64_t a2, char *__src)
{
  uint64_t v5 = *(char **)(a2 + 8);
  uint64_t v6 = (char *)*a1;
  uint64_t v7 = v5;
  if (*a1 != __src)
  {
    uint64_t v8 = __src;
    uint64_t v7 = *(char **)(a2 + 8);
    do
    {
      uint64_t v9 = *((void *)v8 - 1);
      v8 -= 8;
      *((void *)v7 - 1) = v9;
      v7 -= 8;
    }
    while (v8 != v6);
  }
  *(void *)(a2 + 8) = v7;
  uint64_t v10 = a1[1];
  uint64_t v11 = *(void *)(a2 + 16);
  int64_t v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    uint64_t v7 = *(char **)(a2 + 8);
  }
  *(void *)(a2 + 16) = v11 + v12;
  long long v13 = (char *)*a1;
  *a1 = v7;
  *(void *)(a2 + 8) = v13;
  unint64_t v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(void *)(a2 + 16) = v14;
  uint64_t v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(void *)(a2 + 24) = v15;
  *(void *)a2 = *(void *)(a2 + 8);
  return v5;
}

void std::vector<NLTransliterationCandidate *>::__append(void **a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = v7 - (unsigned char *)*a1;
    unint64_t v9 = a2 + (v8 >> 3);
    if (v9 >> 61) {
      std::vector<NLExtendedString>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 3;
    uint64_t v11 = v5 - (unsigned char *)*a1;
    if (v11 >> 2 > v9) {
      unint64_t v9 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v9;
    }
    if (v12) {
      long long v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NLTransliterationCandidate *>>(v4, v12);
    }
    else {
      long long v13 = 0;
    }
    unint64_t v14 = &v13[8 * v10];
    uint64_t v15 = &v13[8 * v12];
    bzero(v14, 8 * a2);
    uint64_t v16 = &v14[8 * a2];
    unint64_t v18 = (char *)*a1;
    unint64_t v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        uint64_t v19 = *((void *)v17 - 1);
        v17 -= 8;
        *((void *)v14 - 1) = v19;
        v14 -= 8;
      }
      while (v17 != v18);
      unint64_t v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
    {
      operator delete(v17);
    }
  }
}

uint64_t *std::back_insert_iterator<std::vector<unsigned int>>::operator=[abi:ne180100](uint64_t *a1, _DWORD *a2)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *(_DWORD **)(*a1 + 8);
  uint64_t v6 = (void *)(*a1 + 16);
  if ((unint64_t)v5 >= *v6)
  {
    uint64_t v8 = *(_DWORD **)v4;
    uint64_t v9 = ((uint64_t)v5 - *(void *)v4) >> 2;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 62) {
      std::vector<NLExtendedString>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = *v6 - (void)v8;
    if (v11 >> 1 > v10) {
      unint64_t v10 = v11 >> 1;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      long long v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<char32_t>>((uint64_t)v6, v12);
      uint64_t v8 = *(_DWORD **)v4;
      uint64_t v5 = *(_DWORD **)(v4 + 8);
    }
    else
    {
      long long v13 = 0;
    }
    unint64_t v14 = &v13[4 * v9];
    uint64_t v15 = &v13[4 * v12];
    *(_DWORD *)unint64_t v14 = *a2;
    uint64_t v7 = v14 + 4;
    while (v5 != v8)
    {
      int v16 = *--v5;
      *((_DWORD *)v14 - 1) = v16;
      v14 -= 4;
    }
    *(void *)uint64_t v4 = v14;
    *(void *)(v4 + 8) = v7;
    *(void *)(v4 + 16) = v15;
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    _DWORD *v5 = *a2;
    uint64_t v7 = v5 + 1;
  }
  *(void *)(v4 + 8) = v7;
  return a1;
}

void std::__stable_sort<std::_ClassicAlgPolicy,NLCompositeTransliterator::assignLanguageModelScoreToCandidates(std::vector<NLTransliterationCandidate *> &,std::vector<std::string> const&)::$_2 &,std::__wrap_iter<NLTransliterationCandidate **>>(NLTransliterationCandidate **a1, NLTransliterationCandidate **a2, unint64_t a3, NLTransliterationCandidate **a4, uint64_t a5)
{
  if (a3 >= 2)
  {
    uint64_t v6 = a1;
    if (a3 == 2)
    {
      uint64_t v7 = *a1;
      Totalunsigned int Score = NLTransliterationCandidate::getTotalScore(*(a2 - 1));
      if (TotalScore > NLTransliterationCandidate::getTotalScore(v7))
      {
        uint64_t v9 = *v6;
        *uint64_t v6 = *(a2 - 1);
        *(a2 - 1) = v9;
      }
    }
    else if ((uint64_t)a3 > 128)
    {
      int64_t v22 = a4;
      unint64_t v23 = a3 >> 1;
      unint64_t v24 = &a1[a3 >> 1];
      unint64_t v25 = a3 >> 1;
      if ((uint64_t)a3 <= a5)
      {
        std::__stable_sort_move<std::_ClassicAlgPolicy,NLCompositeTransliterator::assignLanguageModelScoreToCandidates(std::vector<NLTransliterationCandidate *> &,std::vector<std::string> const&)::$_2 &,std::__wrap_iter<NLTransliterationCandidate **>>(a1, v24, v25, a4);
        unsigned int v26 = &v22[v23];
        std::__stable_sort_move<std::_ClassicAlgPolicy,NLCompositeTransliterator::assignLanguageModelScoreToCandidates(std::vector<NLTransliterationCandidate *> &,std::vector<std::string> const&)::$_2 &,std::__wrap_iter<NLTransliterationCandidate **>>(&v6[a3 >> 1], a2, a3 - (a3 >> 1), v26);
        uint64_t v27 = &v22[a3];
        std::string::pointer v28 = v26;
        while (v28 != v27)
        {
          uint64_t v29 = v28;
          unint64_t v30 = *v22;
          double v31 = NLTransliterationCandidate::getTotalScore(*v28);
          double v32 = NLTransliterationCandidate::getTotalScore(v30);
          if (v31 > v32) {
            unint64_t v33 = v29;
          }
          else {
            unint64_t v33 = v22;
          }
          v22 += v31 <= v32;
          std::string::pointer v28 = &v29[v31 > v32];
          *v6++ = *v33;
          if (v22 == v26)
          {
            if (v28 != v27)
            {
              uint64_t v34 = 0;
              if (v31 > v32) {
                char v35 = 1;
              }
              else {
                char v35 = 2;
              }
              uint64_t v36 = &v29[v35 & 1];
              do
              {
                v6[v34] = v36[v34];
                ++v34;
              }
              while (&v36[v34] != v27);
            }
            return;
          }
        }
        if (v22 != v26)
        {
          uint64_t v37 = 0;
          do
          {
            v6[v37] = v22[v37];
            ++v37;
          }
          while (&v22[v37] != v26);
        }
      }
      else
      {
        std::__stable_sort<std::_ClassicAlgPolicy,NLCompositeTransliterator::assignLanguageModelScoreToCandidates(std::vector<NLTransliterationCandidate *> &,std::vector<std::string> const&)::$_2 &,std::__wrap_iter<NLTransliterationCandidate **>>(a1, v24, v25, a4, a5);
        std::__stable_sort<std::_ClassicAlgPolicy,NLCompositeTransliterator::assignLanguageModelScoreToCandidates(std::vector<NLTransliterationCandidate *> &,std::vector<std::string> const&)::$_2 &,std::__wrap_iter<NLTransliterationCandidate **>>(&v6[a3 >> 1], a2, a3 - (a3 >> 1), v22, a5);
        std::__inplace_merge<std::_ClassicAlgPolicy,NLCompositeTransliterator::assignLanguageModelScoreToCandidates(std::vector<NLTransliterationCandidate *> &,std::vector<std::string> const&)::$_2 &,std::__wrap_iter<NLTransliterationCandidate **>>(v6, &v6[a3 >> 1], a2, a3 >> 1, a3 - (a3 >> 1), v22, a5);
      }
    }
    else if (a1 != a2)
    {
      uint64_t v11 = a1 + 1;
      if (a1 + 1 != a2)
      {
        uint64_t v12 = 0;
        long long v13 = a1;
        do
        {
          unint64_t v14 = *v13;
          long long v13 = v11;
          double v15 = NLTransliterationCandidate::getTotalScore(*v11);
          if (v15 > NLTransliterationCandidate::getTotalScore(v14))
          {
            int v16 = *v13;
            uint64_t v17 = v12;
            while (1)
            {
              *(NLTransliterationCandidate **)((char *)v6 + v17 + 8) = *(NLTransliterationCandidate **)((char *)v6 + v17);
              if (!v17) {
                break;
              }
              unint64_t v18 = *(NLTransliterationCandidate **)((char *)v6 + v17 - 8);
              double v19 = NLTransliterationCandidate::getTotalScore(v16);
              v17 -= 8;
              if (v19 <= NLTransliterationCandidate::getTotalScore(v18))
              {
                uint64_t v20 = (NLTransliterationCandidate **)((char *)v6 + v17 + 8);
                goto LABEL_15;
              }
            }
            uint64_t v20 = v6;
LABEL_15:
            *uint64_t v20 = v16;
          }
          uint64_t v11 = v13 + 1;
          v12 += 8;
        }
        while (v13 + 1 != a2);
      }
    }
  }
}

void std::__stable_sort_move<std::_ClassicAlgPolicy,NLCompositeTransliterator::assignLanguageModelScoreToCandidates(std::vector<NLTransliterationCandidate *> &,std::vector<std::string> const&)::$_2 &,std::__wrap_iter<NLTransliterationCandidate **>>(NLTransliterationCandidate **a1, NLTransliterationCandidate **a2, unint64_t a3, NLTransliterationCandidate **a4)
{
  if (a3)
  {
    uint64_t v4 = a4;
    uint64_t v6 = a1;
    if (a3 == 1)
    {
LABEL_9:
      *uint64_t v4 = *v6;
      return;
    }
    if (a3 == 2)
    {
      uint64_t v8 = a2 - 1;
      uint64_t v9 = *a1;
      Totalunsigned int Score = NLTransliterationCandidate::getTotalScore(*(a2 - 1));
      double v11 = NLTransliterationCandidate::getTotalScore(v9);
      if (TotalScore <= v11) {
        uint64_t v12 = v6;
      }
      else {
        uint64_t v12 = v8;
      }
      *v4++ = *v12;
      if (TotalScore <= v11) {
        uint64_t v6 = v8;
      }
      goto LABEL_9;
    }
    if ((uint64_t)a3 > 8)
    {
      unint64_t v24 = &a1[a3 >> 1];
      std::__stable_sort<std::_ClassicAlgPolicy,NLCompositeTransliterator::assignLanguageModelScoreToCandidates(std::vector<NLTransliterationCandidate *> &,std::vector<std::string> const&)::$_2 &,std::__wrap_iter<NLTransliterationCandidate **>>(a1, v24, a3 >> 1, a4, a3 >> 1);
      std::__stable_sort<std::_ClassicAlgPolicy,NLCompositeTransliterator::assignLanguageModelScoreToCandidates(std::vector<NLTransliterationCandidate *> &,std::vector<std::string> const&)::$_2 &,std::__wrap_iter<NLTransliterationCandidate **>>(&v6[a3 >> 1], a2, a3 - (a3 >> 1), &v4[a3 >> 1], a3 - (a3 >> 1));
      unint64_t v25 = &v6[a3 >> 1];
      while (v25 != a2)
      {
        unsigned int v26 = v25;
        uint64_t v27 = *v6;
        double v28 = NLTransliterationCandidate::getTotalScore(*v25);
        double v29 = NLTransliterationCandidate::getTotalScore(v27);
        if (v28 <= v29) {
          unint64_t v30 = v6;
        }
        else {
          unint64_t v30 = v26;
        }
        unint64_t v25 = &v26[v28 > v29];
        v6 += v28 <= v29;
        *v4++ = *v30;
        if (v6 == v24)
        {
          if (v25 != a2)
          {
            uint64_t v31 = 0;
            double v32 = &v26[v28 > v29];
            do
            {
              v4[v31] = v32[v31];
              ++v31;
            }
            while (&v32[v31] != a2);
          }
          return;
        }
      }
      if (v6 != v24)
      {
        uint64_t v33 = 0;
        do
        {
          v4[v33] = v6[v33];
          ++v33;
        }
        while (&v6[v33] != v24);
      }
    }
    else if (a1 != a2)
    {
      long long v13 = a1 + 1;
      *a4 = *a1;
      if (a1 + 1 != a2)
      {
        uint64_t v14 = 0;
        double v15 = a4;
        do
        {
          int v16 = v15;
          uint64_t v17 = *v15++;
          double v18 = NLTransliterationCandidate::getTotalScore(*v13);
          double v19 = v15;
          if (v18 > NLTransliterationCandidate::getTotalScore(v17))
          {
            v16[1] = *v16;
            double v19 = v4;
            if (v16 != v4)
            {
              uint64_t v20 = v14;
              while (1)
              {
                double v19 = (NLTransliterationCandidate **)((char *)v4 + v20);
                uint64_t v21 = *(NLTransliterationCandidate **)((char *)v4 + v20 - 8);
                double v22 = NLTransliterationCandidate::getTotalScore(*v13);
                if (v22 <= NLTransliterationCandidate::getTotalScore(v21)) {
                  break;
                }
                *double v19 = *(v19 - 1);
                v20 -= 8;
                if (!v20)
                {
                  double v19 = v4;
                  break;
                }
              }
            }
          }
          unint64_t v23 = *v13++;
          *double v19 = v23;
          v14 += 8;
        }
        while (v13 != a2);
      }
    }
  }
}

void std::__inplace_merge<std::_ClassicAlgPolicy,NLCompositeTransliterator::assignLanguageModelScoreToCandidates(std::vector<NLTransliterationCandidate *> &,std::vector<std::string> const&)::$_2 &,std::__wrap_iter<NLTransliterationCandidate **>>(NLTransliterationCandidate **a1, NLTransliterationCandidate **a2, NLTransliterationCandidate **a3, uint64_t a4, uint64_t a5, NLTransliterationCandidate **a6, uint64_t a7)
{
  uint64_t v71 = a5;
  if (a5)
  {
    while (v71 > a7 && a4 > a7)
    {
      if (!a4) {
        return;
      }
      unint64_t v13 = 0;
      uint64_t v14 = -a4;
      while (1)
      {
        double v15 = a1[v13 / 8];
        Totalunsigned int Score = NLTransliterationCandidate::getTotalScore(*a2);
        if (TotalScore > NLTransliterationCandidate::getTotalScore(v15)) {
          break;
        }
        v13 += 8;
        if (__CFADD__(v14++, 1)) {
          return;
        }
      }
      uint64_t v18 = -v14;
      uint64_t v19 = v71;
      std::string v69 = a6;
      uint64_t v70 = a3;
      os_signpost_id_t v67 = (char *)&a1[v13 / 8];
      uint64_t v68 = a7;
      if (-v14 >= v71)
      {
        if (v14 == -1)
        {
          unsigned int v63 = a1[v13 / 8];
          a1[v13 / 8] = *a2;
          *a2 = v63;
          return;
        }
        if (v14 > 0) {
          uint64_t v18 = 1 - v14;
        }
        uint64_t v29 = v18 >> 1;
        unint64_t v30 = a3;
        unint64_t v23 = (char *)&a1[v18 >> 1] + v13;
        double v22 = a2;
        if (a2 != v30)
        {
          uint64_t v66 = v18 >> 1;
          unint64_t v31 = v70 - a2;
          double v22 = a2;
          do
          {
            double v32 = &v22[v31 >> 1];
            uint64_t v34 = *v32;
            uint64_t v33 = v32 + 1;
            char v35 = *(NLTransliterationCandidate **)v23;
            double v36 = NLTransliterationCandidate::getTotalScore(v34);
            double v37 = NLTransliterationCandidate::getTotalScore(v35);
            if (v36 <= v37) {
              v31 >>= 1;
            }
            else {
              v31 += ~(v31 >> 1);
            }
            if (v36 > v37) {
              double v22 = v33;
            }
          }
          while (v31);
          uint64_t v19 = v71;
          uint64_t v29 = v66;
        }
        uint64_t v21 = v22 - a2;
      }
      else
      {
        if (v71 >= 0) {
          uint64_t v20 = v71;
        }
        else {
          uint64_t v20 = v71 + 1;
        }
        uint64_t v21 = v20 >> 1;
        double v22 = &a2[v20 >> 1];
        unint64_t v23 = (char *)a2;
        if ((char *)a2 - (char *)a1 != v13)
        {
          uint64_t v65 = v20 >> 1;
          unint64_t v24 = (uint64_t)((char *)a2 - (char *)a1 - v13) >> 3;
          unint64_t v23 = (char *)&a1[v13 / 8];
          do
          {
            unint64_t v25 = (NLTransliterationCandidate **)&v23[8 * (v24 >> 1)];
            uint64_t v27 = *v25;
            unsigned int v26 = (char *)(v25 + 1);
            double v28 = NLTransliterationCandidate::getTotalScore(*v22);
            if (v28 > NLTransliterationCandidate::getTotalScore(v27))
            {
              v24 >>= 1;
            }
            else
            {
              unint64_t v23 = v26;
              v24 += ~(v24 >> 1);
            }
          }
          while (v24);
          uint64_t v19 = v71;
          uint64_t v21 = v65;
        }
        uint64_t v29 = (uint64_t)(v23 - (char *)a1 - v13) >> 3;
      }
      a4 = -(v29 + v14);
      uint64_t v38 = v19 - v21;
      unint64_t v39 = (char *)a2;
      uint64_t v40 = v19;
      uint64_t v41 = v29;
      uint64_t v42 = v21;
      std::string::pointer v43 = std::__rotate[abi:ne180100]<std::_ClassicAlgPolicy,std::__wrap_iter<NLTransliterationCandidate **>,std::__wrap_iter<NLTransliterationCandidate **>>(v23, v39, (char *)v22);
      uint64_t v44 = v41;
      int v45 = v43;
      if (v44 + v42 >= v40 - (v44 + v42) - v14)
      {
        __int16 v47 = v22;
        a6 = v69;
        uint64_t v48 = v44;
        uint64_t v49 = v42;
        a7 = v68;
        std::__inplace_merge<std::_ClassicAlgPolicy,NLCompositeTransliterator::assignLanguageModelScoreToCandidates(std::vector<NLTransliterationCandidate *> &,std::vector<std::string> const&)::$_2 &,std::__wrap_iter<NLTransliterationCandidate **>>(v43, v47, v70, a4, v38, v69, v68);
        a2 = (NLTransliterationCandidate **)v23;
        uint64_t v38 = v49;
        a4 = v48;
        a3 = (NLTransliterationCandidate **)v45;
        int v45 = v67;
      }
      else
      {
        uint64_t v46 = v42;
        a7 = v68;
        std::__inplace_merge<std::_ClassicAlgPolicy,NLCompositeTransliterator::assignLanguageModelScoreToCandidates(std::vector<NLTransliterationCandidate *> &,std::vector<std::string> const&)::$_2 &,std::__wrap_iter<NLTransliterationCandidate **>>(&a1[v13 / 8], v23, v43, v44, v46, v69, v68);
        a2 = v22;
        a6 = v69;
        a3 = v70;
      }
      uint64_t v71 = v38;
      a1 = (NLTransliterationCandidate **)v45;
      if (!v38) {
        return;
      }
    }
    if (a4 <= v71)
    {
      if (a1 != a2)
      {
        uint64_t v57 = 0;
        do
        {
          a6[v57] = a1[v57];
          ++v57;
        }
        while (&a1[v57] != a2);
        if (v57 * 8)
        {
          uint64_t v58 = a6;
          while (a2 != a3)
          {
            int v59 = *v58;
            double v60 = NLTransliterationCandidate::getTotalScore(*a2);
            double v61 = NLTransliterationCandidate::getTotalScore(v59);
            if (v60 <= v61) {
              uint64_t v62 = v58;
            }
            else {
              uint64_t v62 = a2;
            }
            a2 += v60 > v61;
            v58 += v60 <= v61;
            *a1++ = *v62;
            if (&a6[v57] == v58) {
              return;
            }
          }
          memmove(a1, v58, (char *)a6 - (char *)v58 + v57 * 8);
        }
      }
    }
    else if (a3 != a2)
    {
      uint64_t v50 = 0;
      do
      {
        a6[v50] = a2[v50];
        ++v50;
      }
      while (&a2[v50] != a3);
      if (v50 * 8)
      {
        CFAllocatorRef v51 = &a6[v50];
        unint64_t v52 = a3 - 1;
        while (a2 != a1)
        {
          int v53 = *(a2 - 1);
          double v54 = NLTransliterationCandidate::getTotalScore(*(v51 - 1));
          double v55 = NLTransliterationCandidate::getTotalScore(v53);
          if (v54 <= v55) {
            uint64_t v56 = v51;
          }
          else {
            uint64_t v56 = a2;
          }
          if (v54 <= v55) {
            --v51;
          }
          else {
            --a2;
          }
          *v52-- = *(v56 - 1);
          if (v51 == a6) {
            return;
          }
        }
        uint64_t v64 = 0;
        do
        {
          v52[v64] = v51[v64 - 1];
          --v64;
        }
        while (&v51[v64] != a6);
      }
    }
  }
}

uint64_t NL::ParseIntent::ParseIntent(uint64_t this)
{
  *(_DWORD *)(this + 8) = 0;
  *(void *)this = 0;
  *(void *)(this + 32) = 0;
  *(void *)(this + 4nlp::CFScopedPtr<__CFString const*>::reset(this + 1, 0) = 0;
  *(void *)(this + 24) = 0;
  *(void *)(this + 16) = this + 24;
  *(void *)(this + 48) = 0;
  *(void *)(this + 56) = 0;
  return this;
}

uint64_t NL::ParseIntent::confidence(NL::ParseIntent *this)
{
  float v1 = *(float *)this;
  if (*(float *)this >= 20.0) {
    return 3;
  }
  if (v1 >= 15.0) {
    return 2;
  }
  return v1 > 8.0;
}

void NL::ParseIntent::add(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (*a2)
  {
    uint64_t v5 = operator new(0x30uLL);
    v5[2] = 0;
    v5[3] = 0;
    void *v5 = &unk_1EF7CE818;
    v5[1] = 0;
    v5[4] = 0;
    void v5[5] = 0;
    *(void *)&long long v8 = v5 + 3;
    *((void *)&v8 + 1) = v5;
    uint64_t v6 = a2[1];
    *(void *)&long long v7 = v2;
    *((void *)&v7 + 1) = v6;
    if (v6) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
    }
    std::vector<std::shared_ptr<NL::ParseAttribute>>::push_back[abi:ne180100](v5 + 3, &v7);
    if (*((void *)&v7 + 1)) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v7 + 1));
    }
    std::vector<std::shared_ptr<NL::ParseAttributes>>::push_back[abi:ne180100]((uint64_t *)(a1 + 40), &v8);
    if (*((void *)&v8 + 1)) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v8 + 1));
    }
  }
}

void sub_1A43DF7D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(exception_object);
}

void **std::vector<std::shared_ptr<NL::ParseAttributes>>::push_back[abi:ne180100](uint64_t *a1, long long *a2)
{
  unint64_t v6 = a1[2];
  BOOL result = (void **)(a1 + 2);
  unint64_t v5 = v6;
  long long v7 = *(result - 1);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v10 = ((uint64_t)v7 - *a1) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      std::vector<NLExtendedString>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v12 = v5 - *a1;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    v18[4] = result;
    uint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<NL::ParseIntent>>>((uint64_t)result, v13);
    double v15 = &v14[16 * v10];
    v18[0] = v14;
    v18[1] = v15;
    v18[3] = &v14[16 * v16];
    long long v17 = *a2;
    *(_OWORD *)double v15 = *a2;
    if (*((void *)&v17 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v17 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    v18[2] = v15 + 16;
    std::vector<std::shared_ptr<NL::ParseAttributes>>::__swap_out_circular_buffer(a1, v18);
    uint64_t v9 = (void *)a1[1];
    BOOL result = std::__split_buffer<std::shared_ptr<NL::ParseIntent>>::~__split_buffer(v18);
  }
  else
  {
    *long long v7 = *(void *)a2;
    uint64_t v8 = *((void *)a2 + 1);
    v7[1] = v8;
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v9 = v7 + 2;
    a1[1] = (uint64_t)(v7 + 2);
  }
  a1[1] = (uint64_t)v9;
  return result;
}

void sub_1A43DF910(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::shared_ptr<NL::ParseIntent>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void NL::ParseIntent::append(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (*a2)
  {
    uint64_t v4 = *(void *)(a1 + 48);
    unint64_t v5 = (uint64_t *)(a1 + 40);
    if (v4 == *(void *)(a1 + 40))
    {
      uint64_t v9 = operator new(0x30uLL);
      std::regex_traits<char> v9[2] = 0;
      v9[3] = 0;
      void *v9 = &unk_1EF7CE818;
      v9[1] = 0;
      v9[4] = 0;
      v9[5] = 0;
      *(void *)&long long v12 = v9 + 3;
      *((void *)&v12 + 1) = v9;
      uint64_t v10 = a2[1];
      *(void *)&long long v11 = v2;
      *((void *)&v11 + 1) = v10;
      if (v10) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
      }
      std::vector<std::shared_ptr<NL::ParseAttribute>>::push_back[abi:ne180100](v9 + 3, &v11);
      if (*((void *)&v11 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v11 + 1));
      }
      std::vector<std::shared_ptr<NL::ParseAttributes>>::push_back[abi:ne180100](v5, &v12);
      uint64_t v8 = (std::__shared_weak_count *)*((void *)&v12 + 1);
      if (*((void *)&v12 + 1)) {
        goto LABEL_6;
      }
    }
    else
    {
      unint64_t v6 = *(uint64_t **)(v4 - 16);
      uint64_t v7 = a2[1];
      *(void *)&long long v13 = *a2;
      *((void *)&v13 + 1) = v7;
      if (v7) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
      }
      std::vector<std::shared_ptr<NL::ParseAttribute>>::push_back[abi:ne180100](v6, &v13);
      uint64_t v8 = (std::__shared_weak_count *)*((void *)&v13 + 1);
      if (*((void *)&v13 + 1)) {
LABEL_6:
      }
        std::__shared_weak_count::__release_shared[abi:ne180100](v8);
    }
  }
}

void sub_1A43DFA18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14)
{
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_emplace<NL::ParseAttributes>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7CE818;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<NL::ParseAttributes>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF7CE818;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A625B130);
}

void std::__shared_ptr_emplace<NL::ParseAttributes>::__on_zero_shared(uint64_t a1)
{
  float v1 = (void **)(a1 + 24);
  std::vector<std::shared_ptr<NL::ParseAttribute>>::__destroy_vector::operator()[abi:ne180100](&v1);
}

uint64_t std::vector<std::shared_ptr<NL::ParseAttributes>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::shared_ptr<NL::ParseAttributes>>,std::reverse_iterator<std::shared_ptr<NL::ParseAttributes>*>,std::reverse_iterator<std::shared_ptr<NL::ParseAttributes>*>,std::reverse_iterator<std::shared_ptr<NL::ParseAttributes>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::shared_ptr<NL::ParseAttributes>>,std::reverse_iterator<std::shared_ptr<NL::ParseAttributes>*>,std::reverse_iterator<std::shared_ptr<NL::ParseAttributes>*>,std::reverse_iterator<std::shared_ptr<NL::ParseAttributes>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  void v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = (_OWORD *)(a7 - 16);
    do
    {
      long long v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      _OWORD *v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *((void *)&v15 + 1) = v8;
      v7 -= 16;
      --v8;
    }
    while (a3 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<NL::ParseAttributes>>,std::reverse_iterator<std::shared_ptr<NL::ParseAttributes>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<NL::ParseAttributes>>,std::reverse_iterator<std::shared_ptr<NL::ParseAttributes>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<NL::ParseIntent>>,std::reverse_iterator<std::shared_ptr<NL::ParseIntent>*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void NL::SharedCFType::Wrapper::~Wrapper(const void **this)
{
  float v1 = *this;
  if (v1) {
    CFRelease(v1);
  }
}

void NL::SharedCFType::SharedCFType(NL::SharedCFType *this, const void *a2)
{
}

uint64_t NL::SharedCFType::get(NL::SharedCFType *this)
{
  return **(void **)this;
}

void std::shared_ptr<NL::SharedCFType::Wrapper>::shared_ptr[abi:ne180100]<NL::SharedCFType::Wrapper,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1A43DFD4C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<NL::SharedCFType::Wrapper>::reset[abi:ne180100]((const void ***)va, 0);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<NL::SharedCFType::Wrapper *,std::shared_ptr<NL::SharedCFType::Wrapper>::__shared_ptr_default_delete<NL::SharedCFType::Wrapper,NL::SharedCFType::Wrapper>,std::allocator<NL::SharedCFType::Wrapper>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1A625B130);
}

const void **std::__shared_ptr_pointer<NL::SharedCFType::Wrapper *,std::shared_ptr<NL::SharedCFType::Wrapper>::__shared_ptr_default_delete<NL::SharedCFType::Wrapper,NL::SharedCFType::Wrapper>,std::allocator<NL::SharedCFType::Wrapper>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(const void ***)(a1 + 24);
  if (result)
  {
    NL::SharedCFType::Wrapper::~Wrapper(result);
    JUMPOUT(0x1A625B130);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<NL::SharedCFType::Wrapper *,std::shared_ptr<NL::SharedCFType::Wrapper>::__shared_ptr_default_delete<NL::SharedCFType::Wrapper,NL::SharedCFType::Wrapper>,std::allocator<NL::SharedCFType::Wrapper>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

const void **std::unique_ptr<NL::SharedCFType::Wrapper>::reset[abi:ne180100](const void ***a1, const void **a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    NL::SharedCFType::Wrapper::~Wrapper(result);
    JUMPOUT(0x1A625B130);
  }
  return result;
}

void NLArabicWordLanguageModeler::NLArabicWordLanguageModeler(NLArabicWordLanguageModeler *this, const __CFDictionary *a2)
{
  NLAbstractLanguageModeler::NLAbstractLanguageModeler(this, @"ar");
  *uint64_t v4 = &unk_1EF7CD758;
  if (CFDictionaryGetValue(a2, @"useLanguageModel") == (const void *)*MEMORY[0x1E4F1CFD0]) {
    NLArabicWordLanguageModeler::loadLanguageModel(this, a2);
  }
}

void sub_1A43DFEFC(_Unwind_Exception *a1)
{
  NLAbstractLanguageModeler::~NLAbstractLanguageModeler(v1);
  _Unwind_Resume(a1);
}

void NLArabicWordLanguageModeler::loadLanguageModel(NLArabicWordLanguageModeler *this, CFDictionaryRef theDict)
{
  if (theDict) {
    MutableCFStringRef Copy = CFDictionaryCreateMutableCopy(0, 0, theDict);
  }
  else {
    MutableCFStringRef Copy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
  uint64_t v4 = MutableCopy;
  CFDictionarySetValue(MutableCopy, (const void *)*MEMORY[0x1E4F72358], (const void *)*MEMORY[0x1E4F1CFD0]);
  uint64_t valuePtr = 0x3FD0000000000000;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberDoubleType, &valuePtr);
  CFDictionarySetValue(v4, (const void *)*MEMORY[0x1E4F72390], v5);
  CFRelease(v5);
  uint64_t v9 = 1;
  CFNumberRef v6 = CFNumberCreate(0, kCFNumberLongType, &v9);
  CFDictionarySetValue(v4, (const void *)*MEMORY[0x1E4F72398], v6);
  CFDictionarySetValue(v4, (const void *)*MEMORY[0x1E4F723A8], v6);
  CFDictionarySetValue(v4, (const void *)*MEMORY[0x1E4F723A0], v6);
  CFRelease(v6);
  CFDictionarySetValue(v4, (const void *)*MEMORY[0x1E4F723C8], @"ar");
  *((void *)this + 1) = LMLanguageModelCreate();
  CFRelease(v4);
  if (!*((void *)this + 1))
  {
    uint64_t v8 = NL::CFLogger::sharedInstance(v7);
    (*(void (**)(uint64_t, uint64_t, const char *))(*(void *)v8 + 16))(v8, 3, "Could not locate Arabic language model");
  }
}

void NLArabicWordLanguageModeler::~NLArabicWordLanguageModeler(NLArabicWordLanguageModeler *this)
{
  NLAbstractLanguageModeler::~NLAbstractLanguageModeler(this);

  JUMPOUT(0x1A625B130);
}

NL::SearchGrammar *NL::SearchGrammar::SearchGrammar(NL::SearchGrammar *this, const __CFURL *a2)
{
  uint64_t v4 = std::string::basic_string[abi:ne180100]<0>(this, "None");
  v4[3] = 0;
  v4[4] = 0;
  CFNumberRef v5 = (NL::SearchRules **)(v4 + 3);
  void v4[5] = 0;
  uint64_t v7 = (NL::SearchRules *)NL::SearchRules::createFromPath(a2, v6);
  std::unique_ptr<NL::SearchRules>::reset[abi:ne180100](v5, v7);
  return this;
}

void sub_1A43E0140(_Unwind_Exception *a1)
{
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 40);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  NL::SearchGrammar::SearchGrammar(v2, v1);
  _Unwind_Resume(a1);
}

NL::SearchRules *std::unique_ptr<NL::SearchRules>::reset[abi:ne180100](NL::SearchRules **a1, NL::SearchRules *a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    NL::SearchRules::~SearchRules(result);
    JUMPOUT(0x1A625B130);
  }
  return result;
}

void NL::SearchGrammar::~SearchGrammar(NL::SearchGrammar *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  std::unique_ptr<NL::SearchRules>::reset[abi:ne180100]((NL::SearchRules **)this + 3, 0);
  if (*((char *)this + 23) < 0) {
    operator delete(*(void **)this);
  }
}

BOOL NL::SearchGrammar::hasResources(NL::SearchGrammar *this)
{
  return *((void *)this + 3) != 0;
}

NL::SearchRules *NL::SearchGrammar::hasExpansions(NL::SearchGrammar *this, unsigned int a2)
{
  uint64_t result = (NL::SearchRules *)*((void *)this + 3);
  if (result) {
    return (NL::SearchRules *)NL::SearchRules::hasExpansions(result, a2);
  }
  return result;
}

void NL::SearchGrammar::expansions(uint64_t a1, unsigned int a2, uint64_t a3)
{
  v5[0] = 0;
  v5[1] = v5;
  v5[2] = 0x2000000000;
  char v6 = 0;
  uint64_t v3 = *(void *)(a1 + 24);
  if (v3)
  {
    v4[0] = MEMORY[0x1E4F143A8];
    v4[1] = 0x40000000;
    v4[2] = ___ZNK2NL13SearchGrammar10expansionsEjU13block_pointerFvjRKNSt3__16vectorIjNS1_9allocatorIjEEEEPbE_block_invoke;
    v4[3] = &unk_1E5B364F0;
    v4[4] = a3;
    void v4[5] = v5;
    NL::SearchRules::expansions(v3, a2, (uint64_t)v4);
  }
  _Block_object_dispose(v5, 8);
}

void sub_1A43E02C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZNK2NL13SearchGrammar10expansionsEjU13block_pointerFvjRKNSt3__16vectorIjNS1_9allocatorIjEEEEPbE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)) {
    *a4 = 1;
  }
  return result;
}

uint64_t NL::SearchGrammar::termIDs(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result)
  {
    v3[0] = MEMORY[0x1E4F143A8];
    v3[1] = 0x40000000;
    v3[2] = ___ZNK2NL13SearchGrammar7termIDsEU13block_pointerFvjPbE_block_invoke;
    v3[3] = &unk_1E5B37200;
    v3[4] = a2;
    return NL::SearchRules::termIDs(result, (uint64_t)v3);
  }
  return result;
}

uint64_t ___ZNK2NL13SearchGrammar7termIDsEU13block_pointerFvjPbE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void NL::SearchGrammar::getValidTypeName(uint64_t a1@<X0>, uint64_t a2@<X1>, std::string *a3@<X8>)
{
  if (*(void *)(a1 + 24))
  {
    std::string::basic_string[abi:ne180100]<0>(__p, "AmbiguousCalendarDate");
    BOOL v6 = endswith((uint64_t *)a2, (uint64_t *)__p);
    BOOL v7 = v6;
    if (v17 < 0)
    {
      operator delete(__p[0]);
      if (v7) {
        goto LABEL_4;
      }
    }
    else if (v6)
    {
LABEL_4:
      uint64_t v8 = "AmbiguousCalendarDate";
LABEL_29:
      std::string::basic_string[abi:ne180100]<0>(a3, v8);
      return;
    }
    std::string::basic_string[abi:ne180100]<0>(__p, "Date");
    BOOL v9 = endswith((uint64_t *)a2, (uint64_t *)__p);
    BOOL v10 = v9;
    if (v17 < 0)
    {
      operator delete(__p[0]);
      if (v10) {
        goto LABEL_11;
      }
    }
    else if (v9)
    {
LABEL_11:
      uint64_t v8 = "CalendarDate";
      goto LABEL_29;
    }
    std::string::basic_string[abi:ne180100]<0>(__p, "AmbiguousCalendarTime");
    if (endswith((uint64_t *)a2, (uint64_t *)__p))
    {
      BOOL v11 = 1;
    }
    else
    {
      std::string::basic_string[abi:ne180100]<0>(v14, "RelativeNowTime");
      BOOL v11 = endswith((uint64_t *)a2, (uint64_t *)v14);
      if (v15 < 0) {
        operator delete(v14[0]);
      }
    }
    if (v17 < 0)
    {
      operator delete(__p[0]);
      if (v11) {
        goto LABEL_19;
      }
    }
    else if (v11)
    {
LABEL_19:
      uint64_t v8 = "AmbiguousCalendarTime";
      goto LABEL_29;
    }
    std::string::basic_string[abi:ne180100]<0>(__p, "CalendarTime");
    if (endswith((uint64_t *)a2, (uint64_t *)__p))
    {
      BOOL v12 = 1;
    }
    else
    {
      std::string::basic_string[abi:ne180100]<0>(v14, "FormattedTime");
      BOOL v12 = endswith((uint64_t *)a2, (uint64_t *)v14);
      if (v15 < 0) {
        operator delete(v14[0]);
      }
    }
    if (v17 < 0) {
      operator delete(__p[0]);
    }
    if (v12)
    {
      uint64_t v8 = "CalendarTime";
      goto LABEL_29;
    }
    std::string::basic_string[abi:ne180100]<0>(__p, "Status");
    BOOL v13 = endswith((uint64_t *)a2, (uint64_t *)__p);
    if (v17 < 0) {
      operator delete(__p[0]);
    }
    if (v13)
    {
      if (*(char *)(a2 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(a3, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
      }
      else
      {
        *(_OWORD *)&a3->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
        a3->__r_.__value_.__r.__words[2] = *(void *)(a2 + 16);
      }
      std::string::basic_string[abi:ne180100]<0>(__p, "Status");
      std::string::basic_string[abi:ne180100]<0>(v14, "");
      replaceAll(a3, (char *)__p, (uint64_t)v14);
      if (v15 < 0) {
        operator delete(v14[0]);
      }
      if (v17 < 0) {
        operator delete(__p[0]);
      }
    }
    else
    {
      if (!NL::SearchRules::termID(*(void *)(a1 + 24), a2))
      {
        uint64_t v8 = "";
        goto LABEL_29;
      }
      if (*(char *)(a2 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(a3, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
      }
      else
      {
        *(_OWORD *)&a3->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
        a3->__r_.__value_.__r.__words[2] = *(void *)(a2 + 16);
      }
    }
  }
  else
  {
    std::string::basic_string[abi:ne180100]<0>(a3, "");
  }
}

void sub_1A43E06A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (*(char *)(v20 + 23) < 0) {
    operator delete(*(void **)v20);
  }
  _Unwind_Resume(exception_object);
}

void NL::SearchGrammar::getValidRootName(uint64_t a1@<X1>, std::string *a2@<X8>)
{
  if (*(char *)(a1 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)a1, *(void *)(a1 + 8));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)a1;
    a2->__r_.__value_.__r.__words[2] = *(void *)(a1 + 16);
  }
  uint64_t v3 = HIBYTE(a2->__r_.__value_.__r.__words[2]);
  char v4 = v3;
  BOOL v6 = (char *)a2->__r_.__value_.__r.__words[0];
  uint64_t size = a2->__r_.__value_.__l.__size_;
  if ((v3 & 0x80u) == 0) {
    uint64_t v7 = HIBYTE(a2->__r_.__value_.__r.__words[2]);
  }
  else {
    uint64_t v7 = a2->__r_.__value_.__l.__size_;
  }
  if ((v3 & 0x80u) == 0) {
    uint64_t v8 = a2;
  }
  else {
    uint64_t v8 = (std::string *)a2->__r_.__value_.__r.__words[0];
  }
  if (v7 >= 4)
  {
    BOOL v9 = (char *)v8 + v7;
    BOOL v10 = v8;
    do
    {
      BOOL v11 = (char *)memchr(v10, 75, v7 - 3);
      if (!v11) {
        break;
      }
      if (*(_DWORD *)v11 == 1145981259)
      {
        if (v11 != v9 && v11 - (char *)v8 != -1)
        {
          MEMORY[0x1A625AE00](a2, "KIND");
          uint64_t v3 = HIBYTE(a2->__r_.__value_.__r.__words[2]);
          BOOL v6 = (char *)a2->__r_.__value_.__r.__words[0];
          uint64_t size = a2->__r_.__value_.__l.__size_;
          char v4 = HIBYTE(a2->__r_.__value_.__r.__words[2]);
        }
        break;
      }
      BOOL v10 = (std::string *)(v11 + 1);
      uint64_t v7 = v9 - (char *)v10;
    }
    while (v9 - (char *)v10 >= 4);
  }
  if (v4 >= 0) {
    uint64_t v12 = v3;
  }
  else {
    uint64_t v12 = size;
  }
  if (v4 >= 0) {
    BOOL v13 = a2;
  }
  else {
    BOOL v13 = (std::string *)v6;
  }
  if (v12 > 4)
  {
    long long v14 = (char *)v13 + v12;
    char v15 = v13;
    do
    {
      uint64_t v16 = (char *)memchr(v15, 81, v12 - 4);
      if (!v16) {
        break;
      }
      if (*(_DWORD *)v16 == 1414485329 && v16[4] == 69)
      {
        if (v16 != v14 && v16 - (char *)v13 != -1)
        {
          MEMORY[0x1A625AE00](a2, "QUOTED");
          uint64_t v3 = HIBYTE(a2->__r_.__value_.__r.__words[2]);
          BOOL v6 = (char *)a2->__r_.__value_.__r.__words[0];
          uint64_t size = a2->__r_.__value_.__l.__size_;
          char v4 = HIBYTE(a2->__r_.__value_.__r.__words[2]);
        }
        break;
      }
      char v15 = (std::string *)(v16 + 1);
      uint64_t v12 = v14 - (char *)v15;
    }
    while (v14 - (char *)v15 >= 5);
  }
  if (v4 >= 0) {
    uint64_t v18 = v3;
  }
  else {
    uint64_t v18 = size;
  }
  if (v4 >= 0) {
    uint64_t v19 = a2;
  }
  else {
    uint64_t v19 = (std::string *)v6;
  }
  if (v18 >= 12)
  {
    uint64_t v20 = (char *)v19 + v18;
    uint64_t v21 = v19;
    do
    {
      double v22 = (char *)memchr(v21, 70, v18 - 11);
      if (!v22) {
        break;
      }
      if (*(void *)v22 == 0x41545441454C4946 && *((_DWORD *)v22 + 2) == 1145391171)
      {
        if (v22 != v20 && v22 - (char *)v19 != -1) {
          MEMORY[0x1A625AE00](a2, "ATTACHMOD");
        }
        break;
      }
      uint64_t v21 = (std::string *)(v22 + 1);
      uint64_t v18 = v20 - (char *)v21;
    }
    while (v20 - (char *)v21 >= 12);
  }
  std::string::basic_string[abi:ne180100]<0>(v26, "1");
  std::string::basic_string[abi:ne180100]<0>(__p, "");
  replaceAll(a2, (char *)v26, (uint64_t)__p);
  if (v25 < 0) {
    operator delete(__p[0]);
  }
  if (v27 < 0) {
    operator delete(v26[0]);
  }
  std::string::basic_string[abi:ne180100]<0>(v26, "3");
  std::string::basic_string[abi:ne180100]<0>(__p, "");
  replaceAll(a2, (char *)v26, (uint64_t)__p);
  if (v25 < 0) {
    operator delete(__p[0]);
  }
  if (v27 < 0) {
    operator delete(v26[0]);
  }
}

void sub_1A43E0A04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (*(char *)(v20 + 23) < 0) {
    operator delete(*(void **)v20);
  }
  _Unwind_Resume(exception_object);
}

void NL::SearchGrammar::getValidLeafName(uint64_t a1@<X1>, std::string *a2@<X8>)
{
  if (*(char *)(a1 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)a1, *(void *)(a1 + 8));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)a1;
    a2->__r_.__value_.__r.__words[2] = *(void *)(a1 + 16);
  }
  std::string::basic_string[abi:ne180100]<0>(v6, "Text");
  if (endswith((uint64_t *)a2, (uint64_t *)v6))
  {
    std::string::basic_string[abi:ne180100]<0>(__p, "Quote");
    BOOL v3 = !startswith((unsigned __int8 *)a2, (unsigned __int8 *)__p);
    if (v5 < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    BOOL v3 = 0;
  }
  if (v7 < 0)
  {
    operator delete(v6[0]);
    if (!v3) {
      return;
    }
    goto LABEL_12;
  }
  if (v3) {
LABEL_12:
  }
    MEMORY[0x1A625AE00](a2, "Text");
}

void sub_1A43E0B38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (*(char *)(v20 + 23) < 0) {
    operator delete(*(void **)v20);
  }
  _Unwind_Resume(exception_object);
}

BOOL NL::SearchGrammar::isTypeValidForTopic(uint64_t a1, unsigned __int8 *a2)
{
  if ((char)a2[23] < 0)
  {
    uint64_t v4 = *((void *)a2 + 1);
    if (v4 == 3 && **(_WORD **)a2 == 24916 && *(unsigned char *)(*(void *)a2 + 2) == 103) {
      return 0;
    }
    if (v4 != 4) {
      goto LABEL_18;
    }
    BOOL v3 = *(unsigned __int8 **)a2;
  }
  else
  {
    if (a2[23] == 3)
    {
      if (*(_WORD *)a2 == 24916 && a2[2] == 103) {
        return 0;
      }
      goto LABEL_18;
    }
    BOOL v3 = a2;
    if (a2[23] != 4) {
      goto LABEL_18;
    }
  }
  if (*(_DWORD *)v3 == 1734437958) {
    return 0;
  }
LABEL_18:
  std::string::basic_string[abi:ne180100]<0>(__p, "Has");
  BOOL v7 = startswith(a2, (unsigned __int8 *)__p);
  BOOL v8 = v7;
  if (v14 < 0)
  {
    operator delete(__p[0]);
    if (v8) {
      return 0;
    }
  }
  else if (v7)
  {
    return 0;
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "As");
  BOOL v9 = startswith(a2, (unsigned __int8 *)__p);
  BOOL v10 = v9;
  if (v14 < 0)
  {
    operator delete(__p[0]);
    if (v10) {
      return 0;
    }
  }
  else if (v9)
  {
    return 0;
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "Contains");
  BOOL v12 = endswith((uint64_t *)a2, (uint64_t *)__p);
  if (v14 < 0) {
    operator delete(__p[0]);
  }
  return !v12;
}

void sub_1A43E0CF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL NL::SearchGrammar::isTypeSubsumed(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
  uint64_t v4 = *(unsigned __int8 *)(a2 + 23);
  size_t v5 = *(void *)(a2 + 8);
  if ((v4 & 0x80u) == 0) {
    uint64_t v6 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v6 = *(void *)(a2 + 8);
  }
  uint64_t v7 = a3[23];
  int v8 = (char)v7;
  if ((v7 & 0x80u) != 0) {
    uint64_t v7 = *((void *)a3 + 1);
  }
  if (v6 != v7) {
    return 1;
  }
  if (v8 >= 0) {
    BOOL v11 = a3;
  }
  else {
    BOOL v11 = *(unsigned __int8 **)a3;
  }
  if ((v4 & 0x80) != 0)
  {
    if (memcmp(*(const void **)a2, v11, v5)) {
      return 1;
    }
  }
  else if (v4)
  {
    for (unint64_t i = (unsigned __int8 *)a2; *i == *v11; ++i)
    {
      ++v11;
      if (!--v4) {
        return NL::SearchGrammar::getSymbolID(a1, a2) != 21;
      }
    }
    return 1;
  }
  return NL::SearchGrammar::getSymbolID(a1, a2) != 21;
}

uint64_t NL::SearchGrammar::getSymbolID(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3 || !NL::SearchRules::termID(v3, a2)) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 24);

  return NL::SearchRules::termID(v5, a2);
}

BOOL NL::SearchGrammar::isTypeMultivalued(uint64_t a1, void *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    uint64_t v5 = a2[1];
    if (v5 == 12)
    {
      uint64_t v6 = (void *)*a2;
      if (*(void *)*a2 == 0x7261646E656C6143 && *(_DWORD *)(*a2 + 8) == 1702125892) {
        return 1;
      }
      uint64_t v8 = *v6;
      int v9 = *((_DWORD *)v6 + 2);
      if (v8 == 0x7261646E656C6143 && v9 == 1701669204) {
        return 1;
      }
      uint64_t v5 = a2[1];
    }
    if (v5 == 21)
    {
      if (*(void *)*a2 == 0x756F756769626D41
        && *(void *)(*a2 + 8) == 0x61646E656C614373
        && *(void *)(*a2 + 13) == 0x656D69547261646ELL)
      {
        return 1;
      }
      if (a2[1] == 21)
      {
        a2 = (void *)*a2;
        return *a2 == 0x756F756769626D41
            && a2[1] == 0x61646E656C614373
            && *(void *)((char *)a2 + 13) == 0x657461447261646ELL;
      }
    }
    return 0;
  }
  int v2 = *((unsigned __int8 *)a2 + 23);
  if (v2 != 12)
  {
    if (v2 == 21)
    {
      if (*a2 != 0x756F756769626D41
        || a2[1] != 0x61646E656C614373
        || *(void *)((char *)a2 + 13) != 0x656D69547261646ELL)
      {
        return *a2 == 0x756F756769626D41
            && a2[1] == 0x61646E656C614373
            && *(void *)((char *)a2 + 13) == 0x657461447261646ELL;
      }
      return 1;
    }
    return 0;
  }
  if (*a2 == 0x7261646E656C6143 && *((_DWORD *)a2 + 2) == 1702125892) {
    return 1;
  }
  return *a2 == 0x7261646E656C6143 && *((_DWORD *)a2 + 2) == 1701669204;
}

BOOL NL::SearchGrammar::isInferred(NL::SearchGrammar *this, __int32 a2)
{
  uint64_t v2 = *((void *)this + 3);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = *(__int32 **)(v2 + 112);
  uint64_t v4 = wmemchr(*(__int32 **)(v2 + 104), a2, ((uint64_t)v3 - *(void *)(v2 + 104)) >> 2);
  if (v4) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = v3;
  }
  return v5 != *(__int32 **)(v2 + 112);
}

BOOL NL::SearchGrammar::isCombinable(NL::SearchGrammar *this, __int32 a2)
{
  uint64_t v2 = *((void *)this + 3);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = *(__int32 **)(v2 + 136);
  uint64_t v4 = wmemchr(*(__int32 **)(v2 + 128), a2, ((uint64_t)v3 - *(void *)(v2 + 128)) >> 2);
  if (v4) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = v3;
  }
  return v5 != *(__int32 **)(v2 + 136);
}

BOOL NL::SearchGrammar::isEquivalent(NL::SearchGrammar *this, unsigned int a2, unsigned int a3)
{
  if (a2 == a3) {
    return 1;
  }
  uint64_t v4 = (NL::SearchRules *)*((void *)this + 3);
  return v4 && NL::SearchRules::isEquivalent(v4, a2, a3);
}

BOOL NL::SearchGrammar::isFunction(NL::SearchGrammar *this, __int32 a2)
{
  uint64_t v2 = *((void *)this + 3);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = *(__int32 **)(v2 + 160);
  uint64_t v4 = wmemchr(*(__int32 **)(v2 + 152), a2, ((uint64_t)v3 - *(void *)(v2 + 152)) >> 2);
  if (v4) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = v3;
  }
  return v5 != *(__int32 **)(v2 + 160);
}

BOOL NL::SearchGrammar::requiresComplement(NL::SearchGrammar *this, __int32 a2)
{
  uint64_t v2 = *((void *)this + 3);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = *(__int32 **)(v2 + 184);
  uint64_t v4 = wmemchr(*(__int32 **)(v2 + 176), a2, ((uint64_t)v3 - *(void *)(v2 + 176)) >> 2);
  if (v4) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = v3;
  }
  return v5 != *(__int32 **)(v2 + 184);
}

BOOL NL::SearchGrammar::tokenOrderReversed(NL::SearchGrammar *this)
{
  uint64_t v1 = (unsigned __int8 *)*((void *)this + 3);
  return v1 && *v1 != 0;
}

BOOL NL::SearchGrammar::tokenDelayed(NL::SearchGrammar *this)
{
  uint64_t v1 = *((void *)this + 3);
  return v1 && *(unsigned char *)(v1 + 1) != 0;
}

uint64_t NL::SearchGrammar::updateParseContext(NL::SearchGrammar *this, unsigned int a2, unsigned int a3, __int16 a4)
{
  switch(a2)
  {
    case 0x16u:
    case 0x19u:
      NL::ParserContext::setActionSentTo(*((void *)this + 4));
      break;
    case 0x17u:
    case 0x1Au:
      NL::ParserContext::setActionSentFrom(*((void *)this + 4));
      break;
    case 0x18u:
      NL::ParserContext::setActionFromTo(*((void *)this + 4));
      break;
    case 0x1Bu:
      NL::ParserContext::setActionWith(*((void *)this + 4));
      break;
    case 0x1Du:
      NL::ParserContext::setActionAuthored(*((void *)this + 4));
      break;
    case 0x21u:
      NL::ParserContext::setAttributeBeforeDate(*((void *)this + 4));
      break;
    case 0x22u:
      NL::ParserContext::setAttributeAfterDate(*((void *)this + 4));
      break;
    case 0x2Fu:
      NL::ParserContext::setActionSent(*((void *)this + 4));
      break;
    case 0x30u:
      NL::ParserContext::setActionReceived(*((void *)this + 4));
      break;
    case 0x37u:
      NL::ParserContext::setActionCreated(*((void *)this + 4));
      break;
    case 0x38u:
      NL::ParserContext::setActionModified(*((void *)this + 4));
      break;
    case 0x39u:
      NL::ParserContext::setActionDownloaded(*((void *)this + 4));
      break;
    case 0x3Au:
      NL::ParserContext::setActionPrinted(*((void *)this + 4));
      break;
    case 0x3Bu:
      NL::ParserContext::setActionViewed(*((void *)this + 4));
      break;
    case 0x3Cu:
      NL::ParserContext::setActionAdded(*((void *)this + 4));
      break;
    case 0x3Du:
      NL::ParserContext::setActionAirdropped(*((void *)this + 4));
      break;
    case 0x3Eu:
      NL::ParserContext::setActionMessaged(*((void *)this + 4));
      break;
    case 0x3Fu:
      NL::ParserContext::setActionMailed(*((void *)this + 4));
      break;
    default:
      break;
  }
  uint64_t v8 = (NL::SearchRules *)*((void *)this + 3);
  int v9 = (char *)this;
  if (v8) {
    int v9 = NL::SearchRules::term(v8, a2);
  }
  if (v9[23] < 0)
  {
    BOOL v11 = v9;
    int v9 = *(char **)v9;
    uint64_t v10 = *((void *)v11 + 1);
  }
  else
  {
    uint64_t v10 = v9[23];
  }
  if (v10 >= 4)
  {
    BOOL v12 = &v9[v10];
    BOOL v13 = v9;
    do
    {
      char v14 = (char *)memchr(v13, 75, v10 - 3);
      if (!v14) {
        break;
      }
      if (*(_DWORD *)v14 == 1145981259)
      {
        if (v14 != v12 && v14 - v9 != -1) {
          NL::ParserContext::setAttributeKind(*((void *)this + 4));
        }
        break;
      }
      BOOL v13 = v14 + 1;
      uint64_t v10 = v12 - v13;
    }
    while (v12 - v13 >= 4);
  }
  char v15 = (NL::SearchRules *)*((void *)this + 3);
  uint64_t v16 = (char *)this;
  if (v15) {
    uint64_t v16 = NL::SearchRules::term(v15, a3);
  }
  if (v16[23] < 0)
  {
    uint64_t v18 = v16;
    uint64_t v16 = *(char **)v16;
    uint64_t v17 = *((void *)v18 + 1);
  }
  else
  {
    uint64_t v17 = v16[23];
  }
  if (v17 >= 4)
  {
    uint64_t v19 = &v16[v17];
    uint64_t v20 = v16;
    do
    {
      uint64_t v21 = (char *)memchr(v20, 68, v17 - 3);
      if (!v21) {
        break;
      }
      if (*(_DWORD *)v21 == 1702125892)
      {
        if (v21 != v19 && v21 - v16 != -1) {
          NL::ParserContext::setAttributeDate(*((void *)this + 4));
        }
        break;
      }
      uint64_t v20 = v21 + 1;
      uint64_t v17 = v19 - v20;
    }
    while (v19 - v20 >= 4);
  }
  double v22 = (NL::SearchRules *)*((void *)this + 3);
  unint64_t v23 = (char *)this;
  if (v22) {
    unint64_t v23 = NL::SearchRules::term(v22, a3);
  }
  if (v23[23] < 0)
  {
    char v25 = v23;
    unint64_t v23 = *(char **)v23;
    uint64_t v24 = *((void *)v25 + 1);
  }
  else
  {
    uint64_t v24 = v23[23];
  }
  if (v24 >= 4)
  {
    unsigned int v26 = &v23[v24];
    char v27 = v23;
    do
    {
      double v28 = (char *)memchr(v27, 85, v24 - 3);
      if (!v28) {
        break;
      }
      if (*(_DWORD *)v28 == 1919251285)
      {
        if (v28 != v26 && v28 - v23 != -1)
        {
          uint64_t v29 = (NL::SearchRules *)*((void *)this + 3);
          unint64_t v30 = (uint64_t *)this;
          if (v29) {
            unint64_t v30 = (uint64_t *)NL::SearchRules::term(v29, a3);
          }
          std::string::basic_string[abi:ne180100]<0>(__p, "Received");
          BOOL v31 = endswith(v30, (uint64_t *)__p);
          if (v172 < 0) {
            operator delete(__p[0]);
          }
          if (!v31) {
            NL::ParserContext::setActionUserAction(*((void *)this + 4));
          }
        }
        break;
      }
      char v27 = v28 + 1;
      uint64_t v24 = v26 - v27;
    }
    while (v26 - v27 >= 4);
  }
  double v32 = (NL::SearchRules *)*((void *)this + 3);
  uint64_t v33 = (char *)this;
  if (v32) {
    uint64_t v33 = NL::SearchRules::term(v32, a3);
  }
  if (v33[23] < 0)
  {
    char v35 = v33;
    uint64_t v33 = *(char **)v33;
    uint64_t v34 = *((void *)v35 + 1);
  }
  else
  {
    uint64_t v34 = v33[23];
  }
  if (v34 >= 8)
  {
    double v36 = &v33[v34];
    double v37 = v33;
    do
    {
      uint64_t v38 = (char *)memchr(v37, 85, v34 - 7);
      if (!v38) {
        break;
      }
      if (*(void *)v38 == 0x746E655372657355)
      {
        if (v38 != v36 && v38 - v33 != -1) {
          NL::ParserContext::setActionUserSent(*((void *)this + 4));
        }
        break;
      }
      double v37 = v38 + 1;
      uint64_t v34 = v36 - v37;
    }
    while (v36 - v37 >= 8);
  }
  unint64_t v39 = (NL::SearchRules *)*((void *)this + 3);
  uint64_t v40 = (char *)this;
  if (v39) {
    uint64_t v40 = NL::SearchRules::term(v39, a3);
  }
  if (v40[23] < 0)
  {
    uint64_t v42 = v40;
    uint64_t v40 = *(char **)v40;
    uint64_t v41 = *((void *)v42 + 1);
  }
  else
  {
    uint64_t v41 = v40[23];
  }
  if (v41 >= 12)
  {
    std::string::pointer v43 = &v40[v41];
    uint64_t v44 = v40;
    do
    {
      int v45 = (char *)memchr(v44, 85, v41 - 11);
      if (!v45) {
        break;
      }
      if (*(void *)v45 == 0x6563655272657355 && *((_DWORD *)v45 + 2) == 1684371049)
      {
        if (v45 != v43 && v45 - v40 != -1) {
          NL::ParserContext::setActionUserReceived(*((void *)this + 4));
        }
        break;
      }
      uint64_t v44 = v45 + 1;
      uint64_t v41 = v43 - v44;
    }
    while (v43 - v44 >= 12);
  }
  __int16 v47 = (NL::SearchRules *)*((void *)this + 3);
  uint64_t v48 = (char *)this;
  if (v47) {
    uint64_t v48 = NL::SearchRules::term(v47, a3);
  }
  if (v48[23] < 0)
  {
    uint64_t v50 = v48;
    uint64_t v48 = *(char **)v48;
    uint64_t v49 = *((void *)v50 + 1);
  }
  else
  {
    uint64_t v49 = v48[23];
  }
  if (v49 >= 10)
  {
    CFAllocatorRef v51 = &v48[v49];
    unint64_t v52 = v48;
    do
    {
      int v53 = (char *)memchr(v52, 85, v49 - 9);
      if (!v53) {
        break;
      }
      if (*(void *)v53 == 0x7261685372657355 && *((_WORD *)v53 + 4) == 25701)
      {
        if (v53 != v51 && v53 - v48 != -1)
        {
          NL::ParserContext::setActionUserAction(*((void *)this + 4));
          NL::ParserContext::setActionShared(*((void *)this + 4));
        }
        break;
      }
      unint64_t v52 = v53 + 1;
      uint64_t v49 = v51 - v52;
    }
    while (v51 - v52 >= 10);
  }
  double v55 = (char *)this;
  if (*((void *)this + 3)) {
    double v55 = NL::SearchRules::term(*((NL::SearchRules **)this + 3), a2);
  }
  int v56 = v55[23];
  if (v56 < 0)
  {
    if (*((void *)v55 + 1) != 11) {
      goto LABEL_128;
    }
    double v55 = *(char **)v55;
  }
  else if (v56 != 11)
  {
    goto LABEL_128;
  }
  if (*(void *)v55 == 0x4145524352455355 && *(void *)(v55 + 3) == 0x4445544145524352)
  {
    NL::ParserContext::setActionUserAction(*((void *)this + 4));
    NL::ParserContext::setActionCreated(*((void *)this + 4));
  }
LABEL_128:
  uint64_t v58 = (char *)this;
  if (*((void *)this + 3)) {
    uint64_t v58 = NL::SearchRules::term(*((NL::SearchRules **)this + 3), a2);
  }
  int v59 = v58[23];
  if (v59 < 0)
  {
    if (*((void *)v58 + 1) != 12) {
      goto LABEL_141;
    }
    uint64_t v58 = *(char **)v58;
  }
  else if (v59 != 12)
  {
    goto LABEL_141;
  }
  if (*(void *)v58 == 0x49444F4D52455355 && *((_DWORD *)v58 + 2) == 1145391430)
  {
    NL::ParserContext::setActionUserAction(*((void *)this + 4));
    NL::ParserContext::setActionModified(*((void *)this + 4));
  }
LABEL_141:
  double v61 = (char *)this;
  if (*((void *)this + 3)) {
    double v61 = NL::SearchRules::term(*((NL::SearchRules **)this + 3), a2);
  }
  int v62 = v61[23];
  if (v62 < 0)
  {
    if (*((void *)v61 + 1) != 11) {
      goto LABEL_154;
    }
    double v61 = *(char **)v61;
  }
  else if (v62 != 11)
  {
    goto LABEL_154;
  }
  if (*(void *)v61 == 0x4E49525052455355 && *(void *)(v61 + 3) == 0x4445544E49525052)
  {
    NL::ParserContext::setActionUserAction(*((void *)this + 4));
    NL::ParserContext::setActionPrinted(*((void *)this + 4));
  }
LABEL_154:
  uint64_t v64 = (NL::SearchRules *)*((void *)this + 3);
  uint64_t v65 = (char *)this;
  if (v64) {
    uint64_t v65 = NL::SearchRules::term(v64, a2);
  }
  if (v65[23] < 0)
  {
    os_signpost_id_t v67 = v65;
    uint64_t v65 = *(char **)v65;
    uint64_t v66 = *((void *)v67 + 1);
  }
  else
  {
    uint64_t v66 = v65[23];
  }
  if (v66 >= 10)
  {
    uint64_t v68 = &v65[v66];
    std::string v69 = v65;
    do
    {
      uint64_t v70 = (char *)memchr(v69, 85, v66 - 9);
      if (!v70) {
        break;
      }
      if (*(void *)v70 == 0x54534F5052455355 && *((_WORD *)v70 + 4) == 17477)
      {
        if (v70 != v68 && v70 - v65 != -1)
        {
          NL::ParserContext::setActionUserAction(*((void *)this + 4));
          NL::ParserContext::setTransportSharesheet(*((void *)this + 4));
          NL::ParserContext::setActionPosted(*((void *)this + 4));
        }
        break;
      }
      std::string v69 = v70 + 1;
      uint64_t v66 = v68 - v69;
    }
    while (v68 - v69 >= 10);
  }
  uint64_t v72 = (NL::SearchRules *)*((void *)this + 3);
  std::string v73 = (char *)this;
  if (v72) {
    std::string v73 = NL::SearchRules::term(v72, a2);
  }
  if (v73[23] < 0)
  {
    v75 = v73;
    std::string v73 = *(char **)v73;
    uint64_t v74 = *((void *)v75 + 1);
  }
  else
  {
    uint64_t v74 = v73[23];
  }
  if (v74 >= 12)
  {
    std::string v76 = &v73[v74];
    unint64_t v77 = v73;
    do
    {
      char v78 = (char *)memchr(v77, 85, v74 - 11);
      if (!v78) {
        break;
      }
      if (*(void *)v78 == 0x4543455252455355 && *((_DWORD *)v78 + 2) == 1145394761)
      {
        if (v78 != v76 && v78 - v73 != -1)
        {
          NL::ParserContext::setActionReceived(*((void *)this + 4));
          NL::ParserContext::setActionUserReceived(*((void *)this + 4));
        }
        break;
      }
      unint64_t v77 = v78 + 1;
      uint64_t v74 = v76 - v77;
    }
    while (v76 - v77 >= 12);
  }
  std::string v80 = (NL::SearchRules *)*((void *)this + 3);
  std::string v81 = (char *)this;
  if (v80) {
    std::string v81 = NL::SearchRules::term(v80, a2);
  }
  if (v81[23] < 0)
  {
    std::string v83 = v81;
    std::string v81 = *(char **)v81;
    uint64_t v82 = *((void *)v83 + 1);
  }
  else
  {
    uint64_t v82 = v81[23];
  }
  if (v82 >= 8)
  {
    std::string v84 = &v81[v82];
    std::string v85 = v81;
    do
    {
      std::string v86 = (char *)memchr(v85, 85, v82 - 7);
      if (!v86) {
        break;
      }
      if (*(void *)v86 == 0x544E455352455355)
      {
        if (v86 != v84 && v86 - v81 != -1)
        {
          NL::ParserContext::setActionUserAction(*((void *)this + 4));
          NL::ParserContext::setActionSent(*((void *)this + 4));
          NL::ParserContext::setActionUserSent(*((void *)this + 4));
        }
        break;
      }
      std::string v85 = v86 + 1;
      uint64_t v82 = v84 - v85;
    }
    while (v84 - v85 >= 8);
  }
  v87 = (char *)this;
  if (*((void *)this + 3)) {
    v87 = NL::SearchRules::term(*((NL::SearchRules **)this + 3), a2);
  }
  int v88 = v87[23];
  if (v88 < 0)
  {
    if (*((void *)v87 + 1) != 10) {
      goto LABEL_215;
    }
    v87 = *(char **)v87;
  }
  else if (v88 != 10)
  {
    goto LABEL_215;
  }
  if (*(void *)v87 == 0x4957444552414853 && *((_WORD *)v87 + 4) == 18516) {
    NL::ParserContext::setActionShared(*((void *)this + 4));
  }
LABEL_215:
  if (a3 - 17 <= 1) {
    NL::ParserContext::setParticipant(*((uint64_t ***)this + 4), a4);
  }
  std::string v90 = (NL::SearchRules *)*((void *)this + 3);
  std::string v91 = (unsigned __int8 *)this;
  if (v90) {
    std::string v91 = (unsigned __int8 *)NL::SearchRules::term(v90, a2);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "POSTED");
  BOOL v92 = startswith(v91, (unsigned __int8 *)__p);
  BOOL v93 = v92;
  if ((v172 & 0x80000000) == 0)
  {
    if (!v92) {
      goto LABEL_222;
    }
    goto LABEL_221;
  }
  operator delete(__p[0]);
  if (v93) {
LABEL_221:
  }
    NL::ParserContext::setActionPosted(*((void *)this + 4));
LABEL_222:
  v94 = (NL::SearchRules *)*((void *)this + 3);
  std::string v95 = (unsigned __int8 *)this;
  if (v94) {
    std::string v95 = (unsigned __int8 *)NL::SearchRules::term(v94, a2);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "SHARED");
  BOOL v96 = startswith(v95, (unsigned __int8 *)__p);
  BOOL v97 = v96;
  if ((v172 & 0x80000000) == 0)
  {
    if (!v96) {
      goto LABEL_227;
    }
    goto LABEL_226;
  }
  operator delete(__p[0]);
  if (v97) {
LABEL_226:
  }
    NL::ParserContext::setActionShared(*((void *)this + 4));
LABEL_227:
  int v98 = (NL::SearchRules *)*((void *)this + 3);
  char v99 = (unsigned __int8 *)this;
  if (v98) {
    char v99 = (unsigned __int8 *)NL::SearchRules::term(v98, a2);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "AIRDROPPED");
  if (startswith(v99, (unsigned __int8 *)__p))
  {
    std::string v100 = (NL::SearchRules *)*((void *)this + 3);
    unsigned int v101 = (char *)this;
    if (v100) {
      unsigned int v101 = NL::SearchRules::term(v100, a3);
    }
    if (v101[23] < 0)
    {
      uint64_t v103 = v101;
      unsigned int v101 = *(char **)v101;
      uint64_t v102 = *((void *)v103 + 1);
    }
    else
    {
      uint64_t v102 = v101[23];
    }
    std::string v104 = &v101[v102];
    if (v102 >= 7)
    {
      unint64_t v105 = v101;
      do
      {
        v106 = memchr(v105, 65, v102 - 6);
        if (!v106) {
          break;
        }
        if (*v106 == 1685219649 && *(_DWORD *)((char *)v106 + 3) == 1886351972) {
          goto LABEL_250;
        }
        unint64_t v105 = (char *)v106 + 1;
        uint64_t v102 = v104 - v105;
      }
      while (v104 - v105 > 6);
    }
    v106 = v104;
LABEL_250:
    BOOL v109 = v106 == (_DWORD *)v104 || (char *)v106 - v101 == -1;
    if ((v172 & 0x80000000) == 0)
    {
      if (v109) {
        goto LABEL_259;
      }
      goto LABEL_258;
    }
    operator delete(__p[0]);
    if (!v109) {
LABEL_258:
    }
      NL::ParserContext::setTransportAirdrop(*((void *)this + 4));
  }
  else if (v172 < 0)
  {
    operator delete(__p[0]);
  }
LABEL_259:
  v110 = (NL::SearchRules *)*((void *)this + 3);
  v111 = (unsigned __int8 *)this;
  if (v110) {
    v111 = (unsigned __int8 *)NL::SearchRules::term(v110, a2);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "MESSAGED");
  if (startswith(v111, (unsigned __int8 *)__p))
  {
    v112 = (NL::SearchRules *)*((void *)this + 3);
    v113 = (char *)this;
    if (v112) {
      v113 = NL::SearchRules::term(v112, a3);
    }
    if (v113[23] < 0)
    {
      v115 = v113;
      v113 = *(char **)v113;
      uint64_t v114 = *((void *)v115 + 1);
    }
    else
    {
      uint64_t v114 = v113[23];
    }
    v116 = &v113[v114];
    if (v114 >= 7)
    {
      v117 = v113;
      do
      {
        v118 = memchr(v117, 77, v114 - 6);
        if (!v118) {
          break;
        }
        if (*v118 == 1936942413 && *(_DWORD *)((char *)v118 + 3) == 1701273971) {
          goto LABEL_280;
        }
        v117 = (char *)v118 + 1;
        uint64_t v114 = v116 - v117;
      }
      while (v116 - v117 > 6);
    }
    v118 = v116;
LABEL_280:
    BOOL v121 = v118 == (_DWORD *)v116 || (char *)v118 - v113 == -1;
    if (v172 < 0)
    {
      operator delete(__p[0]);
      if (v121) {
        goto LABEL_289;
      }
      goto LABEL_288;
    }
    if (!v121) {
LABEL_288:
    }
      NL::ParserContext::setTransportMessages(*((void *)this + 4));
  }
  else if (v172 < 0)
  {
    operator delete(__p[0]);
  }
LABEL_289:
  if (a2 == 63)
  {
    v122 = (NL::SearchRules *)*((void *)this + 3);
    v123 = (char *)this;
    if (v122) {
      v123 = NL::SearchRules::term(v122, a3);
    }
    if (v123[23] < 0)
    {
      v125 = v123;
      v123 = *(char **)v123;
      uint64_t v124 = *((void *)v125 + 1);
    }
    else
    {
      uint64_t v124 = v123[23];
    }
    if (v124 >= 4)
    {
      v126 = &v123[v124];
      v127 = v123;
      do
      {
        v128 = (char *)memchr(v127, 77, v124 - 3);
        if (!v128) {
          break;
        }
        if (*(_DWORD *)v128 == 1818845517)
        {
          if (v128 != v126 && v128 - v123 != -1) {
            NL::ParserContext::setTransportMail(*((void *)this + 4));
          }
          break;
        }
        v127 = v128 + 1;
        uint64_t v124 = v126 - v127;
      }
      while (v126 - v127 >= 4);
    }
  }
  v129 = (NL::SearchRules *)*((void *)this + 3);
  v130 = (uint64_t *)this;
  if (v129) {
    v130 = (uint64_t *)NL::SearchRules::term(v129, a2);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "SENDER");
  BOOL v131 = endswith(v130, (uint64_t *)__p);
  BOOL v132 = v131;
  if ((v172 & 0x80000000) == 0)
  {
    if (!v131) {
      goto LABEL_311;
    }
    goto LABEL_310;
  }
  operator delete(__p[0]);
  if (v132)
  {
LABEL_310:
    NL::ParserContext::setActionMailed(*((void *)this + 4));
    NL::ParserContext::setAttributeMail(*((void *)this + 4));
    NL::ParserContext::setActionSentFrom(*((void *)this + 4));
  }
LABEL_311:
  switch(a3)
  {
    case 'R':
      goto LABEL_316;
    case 'S':
      NL::ParserContext::setAttributeMail(*((void *)this + 4));
      goto LABEL_316;
    case 'T':
      NL::ParserContext::setAttributeChat(*((void *)this + 4));
LABEL_316:
      NL::ParserContext::setAttributeMessage(*((void *)this + 4));
      goto LABEL_318;
    case 'U':
      NL::ParserContext::setAttributeWebsite(*((void *)this + 4));
      goto LABEL_318;
    case '[':
      uint64_t result = NL::ParserContext::setAttributeApplication(*((void *)this + 4));
      goto LABEL_402;
    default:
LABEL_318:
      v133 = (NL::SearchRules *)*((void *)this + 3);
      v134 = (char *)this;
      if (v133) {
        v134 = NL::SearchRules::term(v133, a3);
      }
      if (v134[23] < 0)
      {
        v136 = v134;
        v134 = *(char **)v134;
        uint64_t v135 = *((void *)v136 + 1);
      }
      else
      {
        uint64_t v135 = v134[23];
      }
      if (v135 < 5) {
        goto LABEL_336;
      }
      v137 = &v134[v135];
      v138 = v134;
      break;
  }
  do
  {
    v139 = (char *)memchr(v138, 65, v135 - 4);
    if (!v139) {
      break;
    }
    if (*(_DWORD *)v139 == 1768191297 && v139[4] == 111)
    {
      if (v139 != v137 && v139 - v134 != -1)
      {
        uint64_t result = NL::ParserContext::setAttributeAudio(*((void *)this + 4));
        goto LABEL_402;
      }
      break;
    }
    v138 = v139 + 1;
    uint64_t v135 = v137 - v138;
  }
  while (v137 - v138 >= 5);
LABEL_336:
  v142 = (NL::SearchRules *)*((void *)this + 3);
  v143 = (char *)this;
  if (v142) {
    v143 = NL::SearchRules::term(v142, a3);
  }
  if (v143[23] < 0)
  {
    v145 = v143;
    v143 = *(char **)v143;
    uint64_t v144 = *((void *)v145 + 1);
  }
  else
  {
    uint64_t v144 = v143[23];
  }
  if (v144 >= 5)
  {
    v146 = &v143[v144];
    v147 = v143;
    do
    {
      v148 = (char *)memchr(v147, 73, v144 - 4);
      if (!v148) {
        break;
      }
      if (*(_DWORD *)v148 == 1734438217 && v148[4] == 101)
      {
        if (v148 != v146 && v148 - v143 != -1)
        {
          uint64_t result = NL::ParserContext::setAttributeImage(*((void *)this + 4));
          goto LABEL_402;
        }
        break;
      }
      v147 = v148 + 1;
      uint64_t v144 = v146 - v147;
    }
    while (v146 - v147 >= 5);
  }
  v150 = (NL::SearchRules *)*((void *)this + 3);
  v151 = (char *)this;
  if (v150) {
    v151 = NL::SearchRules::term(v150, a3);
  }
  if (v151[23] < 0)
  {
    v153 = v151;
    v151 = *(char **)v151;
    uint64_t v152 = *((void *)v153 + 1);
  }
  else
  {
    uint64_t v152 = v151[23];
  }
  if (v152 >= 5)
  {
    v154 = &v151[v152];
    v155 = v151;
    do
    {
      v156 = (char *)memchr(v155, 86, v152 - 4);
      if (!v156) {
        break;
      }
      if (*(_DWORD *)v156 == 1701079382 && v156[4] == 111)
      {
        if (v156 != v154 && v156 - v151 != -1)
        {
          uint64_t result = NL::ParserContext::setAttributeVideo(*((void *)this + 4));
          goto LABEL_402;
        }
        break;
      }
      v155 = v156 + 1;
      uint64_t v152 = v154 - v155;
    }
    while (v154 - v155 >= 5);
  }
  v158 = (NL::SearchRules *)*((void *)this + 3);
  v159 = (char *)this;
  if (v158) {
    v159 = NL::SearchRules::term(v158, a3);
  }
  if (v159[23] < 0)
  {
    v161 = v159;
    v159 = *(char **)v159;
    uint64_t v160 = *((void *)v161 + 1);
  }
  else
  {
    uint64_t v160 = v159[23];
  }
  if (v160 >= 12)
  {
    v162 = &v159[v160];
    v163 = v159;
    do
    {
      v164 = (char *)memchr(v163, 80, v160 - 11);
      if (!v164) {
        break;
      }
      if (*(void *)v164 == 0x61746E6573657250 && *((_DWORD *)v164 + 2) == 1852795252)
      {
        if (v164 != v162 && v164 - v159 != -1)
        {
          uint64_t result = NL::ParserContext::setAttributePresentation(*((void *)this + 4));
          goto LABEL_402;
        }
        break;
      }
      v163 = v164 + 1;
      uint64_t v160 = v162 - v163;
    }
    while (v162 - v163 >= 12);
  }
  v166 = (uint64_t *)this;
  if (*((void *)this + 3)) {
    v166 = (uint64_t *)NL::SearchRules::term(*((NL::SearchRules **)this + 3), a3);
  }
  if (std::string::find[abi:ne180100](v166, "Spreadsheet", 0) == -1)
  {
    v167 = (uint64_t *)this;
    if (*((void *)this + 3)) {
      v167 = (uint64_t *)NL::SearchRules::term(*((NL::SearchRules **)this + 3), a3);
    }
    if (std::string::find[abi:ne180100](v167, "Pdf", 0) == -1)
    {
      v168 = (uint64_t *)this;
      if (*((void *)this + 3)) {
        v168 = (uint64_t *)NL::SearchRules::term(*((NL::SearchRules **)this + 3), a3);
      }
      if (std::string::find[abi:ne180100](v168, "Document", 0) != -1) {
        goto LABEL_401;
      }
      v169 = (uint64_t *)this;
      if (*((void *)this + 3)) {
        v169 = (uint64_t *)NL::SearchRules::term(*((NL::SearchRules **)this + 3), a3);
      }
      if (std::string::find[abi:ne180100](v169, "File", 0) != -1) {
        goto LABEL_401;
      }
      v170 = (uint64_t *)this;
      if (*((void *)this + 3)) {
        v170 = (uint64_t *)NL::SearchRules::term(*((NL::SearchRules **)this + 3), a3);
      }
      uint64_t result = std::string::find[abi:ne180100](v170, "TextFormat", 0);
      if (a3 - 97 < 2 || result != -1) {
LABEL_401:
      }
        uint64_t result = NL::ParserContext::setAttributeDocument(*((void *)this + 4));
    }
    else
    {
      uint64_t result = NL::ParserContext::setAttributePdf(*((void *)this + 4));
    }
  }
  else
  {
    uint64_t result = NL::ParserContext::setAttributeSpreadsheet(*((void *)this + 4));
  }
LABEL_402:
  if (a2 - 69 <= 1) {
    return NL::ParserContext::setAttributeAttachment(*((void *)this + 4));
  }
  return result;
}

void sub_1A43E22F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

char *NL::SearchGrammar::getSymbol(NL::SearchGrammar *this, unsigned int a2)
{
  uint64_t v3 = (NL::SearchRules *)*((void *)this + 3);
  if (v3) {
    return NL::SearchRules::term(v3, a2);
  }
  else {
    return (char *)this;
  }
}

NL::SearchRules *NL::SearchGrammar::getScore(NL::SearchGrammar *this, unsigned int a2, unsigned int a3, unsigned int a4)
{
  uint64_t result = (NL::SearchRules *)*((void *)this + 3);
  if (result) {
    return (NL::SearchRules *)NL::SearchRules::score(result, a2, a3, a4);
  }
  return result;
}

void NL::SearchRules::~SearchRules(NL::SearchRules *this)
{
  std::__tree<std::__value_type<unsigned int,std::map<unsigned int,std::map<unsigned int,unsigned int>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::map<unsigned int,std::map<unsigned int,unsigned int>>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::map<unsigned int,std::map<unsigned int,unsigned int>>>>>::destroy((uint64_t)this + 200, *((void **)this + 26));
  uint64_t v2 = (void *)*((void *)this + 22);
  if (v2)
  {
    *((void *)this + 23) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 19);
  if (v3)
  {
    *((void *)this + 2nlp::CFScopedPtr<__CFString const*>::reset(this + 1, 0) = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)*((void *)this + 16);
  if (v4)
  {
    *((void *)this + 17) = v4;
    operator delete(v4);
  }
  uint64_t v5 = (void *)*((void *)this + 13);
  if (v5)
  {
    *((void *)this + 14) = v5;
    operator delete(v5);
  }
  uint64_t v6 = (void **)((char *)this + 80);
  std::vector<std::vector<CFRange>>::__destroy_vector::operator()[abi:ne180100](&v6);
  std::__tree<std::__value_type<__CFString const*,__CFString const*>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,__CFString const*>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,__CFString const*>>>::destroy((uint64_t)this + 56, *((void **)this + 8));
  std::__tree<std::string>::destroy((uint64_t)this + 32, *((char **)this + 5));
  std::__tree<std::__value_type<unsigned int,std::string>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::string>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::string>>>::destroy((uint64_t)this + 8, *((char **)this + 2));
}

void *NLEntityDetectorCreate(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x1020040EDCEB4C7uLL);
  void *v2 = 0;
  v2[1] = 0;
  *((_DWORD *)v2 + 4) = 0;
  if (a1 && (v3 = DDScannerCreateWithCacheFile(), (void *v2 = v3) != 0))
  {
    DDScannerSetOptions();
    *((_DWORD *)v2 + 4) = 1;
  }
  else
  {
    destroyNLEntityDetector((const void **)v2);
    return 0;
  }
  return v2;
}

void destroyNLEntityDetector(const void **a1)
{
  if (a1)
  {
    uint64_t v2 = *a1;
    if (v2) {
      CFRelease(v2);
    }
    uint64_t v3 = a1[1];
    if (v3) {
      CFRelease(v3);
    }
    free(a1);
  }
}

BOOL NLEntityDetectorLoadLanguageResources(uint64_t a1, uint64_t a2)
{
  BOOL v2 = 0;
  if (a1 && a2)
  {
    uint64_t v4 = *(const void **)(a1 + 8);
    if (v4)
    {
      CFRelease(v4);
      *(void *)(a1 + 8) = 0;
    }
    uint64_t v5 = DDScannerCreateWithCacheFile();
    *(void *)(a1 + 8) = v5;
    BOOL v2 = v5 != 0;
    if (v5) {
      DDScannerSetOptions();
    }
  }
  return v2;
}

void NLEntityDetectorEnumerateEntities(void *a1, uint64_t a2, uint64_t a3)
{
  if (a2 && *a1 && a1[1])
  {
    uint64_t v40 = 0;
    uint64_t v41 = &v40;
    uint64_t v42 = 0x2000000000;
    CFMutableArrayRef Mutable = 0;
    CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    if (v41[3])
    {
      if (getDataDetectorsQueue_onceToken != -1) {
        dispatch_once(&getDataDetectorsQueue_onceToken, &__block_literal_global_8);
      }
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 0x40000000;
      block[2] = __NLEntityDetectorEnumerateEntities_block_invoke;
      block[3] = &unk_1E5B36518;
      void block[5] = a1;
      void block[6] = a2;
      block[4] = &v40;
      dispatch_sync((dispatch_queue_t)getDataDetectorsQueue_dataDetectorsQueue, block);
      v37[0] = 0;
      v37[1] = v37;
      v37[2] = 0x2000000000;
      char v38 = 0;
      CFArrayRef v7 = (const __CFArray *)v41[3];
      v32[0] = MEMORY[0x1E4F143A8];
      v32[1] = 0x40000000;
      uint64_t v33 = __NLEntityDetectorEnumerateEntities_block_invoke_2;
      uint64_t v34 = &unk_1E5B37228;
      uint64_t v35 = a3;
      double v36 = v37;
      if (v7)
      {
        CFIndex Count = CFArrayGetCount(v7);
        MutableCFStringRef Copy = CFArrayCreateMutableCopy(v6, Count, v7);
        if (MutableCopy)
        {
          uint64_t v10 = MutableCopy;
          v45.CFIndex length = CFArrayGetCount(MutableCopy);
          v45.CFIndex location = 0;
          CFArraySortValues(v10, v45, (CFComparatorFunction)EntityCompare, 0);
          BOOL v11 = (const CFSetCallBacks *)MEMORY[0x1E4F1D548];
          unint64_t v30 = CFSetCreateMutable(v6, 0, MEMORY[0x1E4F1D548]);
          theSet = CFSetCreateMutable(v6, 0, v11);
          v44[0] = 0;
          CFIndex v12 = CFArrayGetCount(v10);
          if (v12 >= 1)
          {
            CFIndex v13 = v12;
            CFIndex v14 = 0;
            uint64_t v15 = 0;
            uint64_t v16 = -1;
            do
            {
              CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(v10, v14);
              uint64_t Range = DDResultGetRange();
              uint64_t v20 = Range;
              uint64_t v21 = v19;
              if (v16 == -1
                || ((uint64_t v22 = v16 + v15, v23 = Range + v19, v16 >= Range) || v22 < v23)
                && (v16 < Range ? (BOOL v24 = Range < v22) : (BOOL v24 = 0),
                    !v24 ? (char v25 = 0) : (char v25 = 1),
                    v22 > v23 ? (BOOL v26 = v16 <= Range) : (BOOL v26 = 0),
                    !v26 && (v25 & 1) == 0))
              {
                int Type = (const void *)DDResultGetType();
                SubResults = (const void *)DDResultGetSubResults();
                if (v20 != v16 || v21 != v15)
                {
                  CFSetRemoveAllValues(theSet);
                  CFSetRemoveAllValues(v30);
LABEL_32:
                  MatchedCFStringRef String = (const __CFString *)DDResultGetMatchedString();
                  if (!CFStringHasSuffix(MatchedString, @" "))
                  {
                    v33((uint64_t)v32, (uint64_t)ValueAtIndex, v44);
                    if (v44[0]) {
                      break;
                    }
                    CFSetAddValue(theSet, Type);
                    if (SubResults) {
                      CFSetAddValue(v30, SubResults);
                    }
                    uint64_t v16 = v20;
                    uint64_t v15 = v21;
                  }
                  goto LABEL_37;
                }
                if (!CFSetContainsValue(theSet, Type) || !SubResults || !CFSetContainsValue(v30, SubResults)) {
                  goto LABEL_32;
                }
              }
LABEL_37:
              ++v14;
            }
            while (v13 != v14);
          }
          CFRelease(v10);
          CFRelease(theSet);
          CFRelease(v30);
        }
      }
      CFRelease((CFTypeRef)v41[3]);
      _Block_object_dispose(v37, 8);
    }
    _Block_object_dispose(&v40, 8);
  }
}

void __NLEntityDetectorEnumerateEntities_block_invoke(uint64_t a1)
{
  DDScannerScanString();
  DDScannerScanString();
  CFArrayRef v2 = (const __CFArray *)DDScannerCopyResultsWithOptions();
  if (v2)
  {
    CFArrayRef v3 = v2;
    uint64_t v4 = *(__CFArray **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
    v9.CFIndex length = CFArrayGetCount(v2);
    v9.CFIndex location = 0;
    CFArrayAppendArray(v4, v3, v9);
    CFRelease(v3);
  }
  CFArrayRef v5 = (const __CFArray *)DDScannerCopyResultsWithOptions();
  if (v5)
  {
    CFArrayRef v6 = v5;
    CFArrayRef v7 = *(__CFArray **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
    v10.CFIndex length = CFArrayGetCount(v5);
    v10.CFIndex location = 0;
    CFArrayAppendArray(v7, v6, v10);
    CFRelease(v6);
  }
}

void __NLEntityDetectorEnumerateEntities_block_invoke_2(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  DDResultGetType();
  DDResultGetRange();
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFArrayRef SubResults = (const __CFArray *)DDResultGetSubResults();
  if (SubResults)
  {
    CFArrayRef v5 = SubResults;
    CFIndex Count = CFArrayGetCount(SubResults);
    if (Count >= 1)
    {
      CFIndex v7 = Count;
      CFIndex v8 = 0;
      CFArrayRef v24 = v5;
      theDict = Mutable;
      CFIndex v23 = Count;
      do
      {
        CFArrayGetValueAtIndex(v5, v8);
        CFStringRef Type = (const __CFString *)DDResultGetType();
        CFNumberRef Value = (const void *)DDResultGetValue();
        CFDictionarySetValue(Mutable, Type, Value);
        if (CFStringHasPrefix(Type, @"NUMBERS"))
        {
          MatchedCFStringRef String = (const void *)DDResultGetMatchedString();
          CFDictionarySetValue(Mutable, @"SPELLED", MatchedString);
        }
        CFArrayRef v12 = (const __CFArray *)DDResultGetSubResults();
        if (v12)
        {
          CFArrayRef v13 = v12;
          CFIndex v14 = CFArrayGetCount(v12);
          if (v14)
          {
            uint64_t v15 = v14;
            uint64_t v16 = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            if (v15 >= 1)
            {
              for (CFIndex i = 0; i != v15; ++i)
              {
                CFArrayGetValueAtIndex(v13, i);
                CFStringRef v18 = (const __CFString *)DDResultGetType();
                uint64_t v19 = (const void *)DDResultGetValue();
                CFDictionarySetValue(v16, v18, v19);
                if (CFStringHasPrefix(v18, @"NUMBERS"))
                {
                  uint64_t v20 = (const void *)DDResultGetMatchedString();
                  CFDictionarySetValue(v16, @"SPELLED", v20);
                }
              }
            }
            CFMutableArrayRef Mutable = theDict;
            CFDictionarySetValue(theDict, Type, v16);
            CFRelease(v16);
            CFIndex v7 = v23;
            CFArrayRef v5 = v24;
          }
        }
        ++v8;
      }
      while (v8 != v7);
    }
  }
  if (Mutable)
  {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
    CFRelease(Mutable);
  }
  *a3 = *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
}

uint64_t NLEntityDetectorRetain(uint64_t result)
{
  if (result) {
    ++*(_DWORD *)(result + 16);
  }
  return result;
}

void NLEntityDetectorRelease(const void **a1)
{
  if (a1)
  {
    int v1 = *((_DWORD *)a1 + 4) - 1;
    *((_DWORD *)a1 + 4) = v1;
    if (!v1) {
      destroyNLEntityDetector(a1);
    }
  }
}

dispatch_queue_t __getDataDetectorsQueue_block_invoke()
{
  dispatch_queue_t result = dispatch_queue_create("com.apple.NLP.DataDetectors", 0);
  getDataDetectorsQueue_dataDetectorsQueue = (uint64_t)result;
  return result;
}

uint64_t EntityCompare()
{
  uint64_t Range = DDResultGetRange();
  uint64_t v2 = v1;
  uint64_t v3 = DDResultGetRange();
  if (Range == v3)
  {
    BOOL v5 = v2 <= v4;
    if (v2 != v4)
    {
LABEL_14:
      if (v5) {
        return 1;
      }
      else {
        return -1;
      }
    }
    CFArrayRef SubResults = (const __CFArray *)DDResultGetSubResults();
    uint64_t v7 = DDResultGetSubResults();
    if (SubResults)
    {
      CFArrayRef v8 = (const __CFArray *)v7;
      if (v7)
      {
        CFIndex Count = CFArrayGetCount(SubResults);
        if (Count == CFArrayGetCount(v8)) {
          return 0;
        }
        CFIndex v11 = CFArrayGetCount(SubResults);
        BOOL v5 = v11 <= CFArrayGetCount(v8);
        goto LABEL_14;
      }
    }
    if (SubResults) {
      return -1;
    }
    else {
      return 1;
    }
  }
  else if (Range < v3)
  {
    return -1;
  }
  else
  {
    return 1;
  }
}

CFStringRef createCFStringFromString(uint64_t a1)
{
  uint64_t v1 = (const UInt8 *)a1;
  if ((*(char *)(a1 + 23) & 0x80000000) == 0)
  {
    CFIndex v2 = *(unsigned __int8 *)(a1 + 23);
    if (!*(unsigned char *)(a1 + 23)) {
      return &stru_1EF7CF078;
    }
    return CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v1, v2, 0x8000100u, 0);
  }
  CFIndex v2 = *(void *)(a1 + 8);
  if (v2)
  {
    uint64_t v1 = *(const UInt8 **)a1;
    return CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v1, v2, 0x8000100u, 0);
  }
  return &stru_1EF7CF078;
}

void *getUTF8StringFromCFString@<X0>(const __CFString *a1@<X0>, void *a2@<X8>)
{
  if (a1)
  {
    CFIndex Length = CFStringGetLength(a1);
    CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
    operator new[]();
  }

  return std::string::basic_string[abi:ne180100]<0>(a2, "");
}

void sub_1A43E2F2C(_Unwind_Exception *a1)
{
  MEMORY[0x1A625B110](v1, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void getFileSystemRepresentationFromCFURL(const __CFURL *a1)
{
}

void sub_1A43E2FDC(_Unwind_Exception *a1)
{
  MEMORY[0x1A625B110](v1, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

const __CFURL *getPathForResource@<X0>(const __CFString *a1@<X0>, void *a2@<X8>)
{
  CFBundleRef BundleWithIdentifier = CFBundleGetBundleWithIdentifier(@"com.apple.NLP");
  CFURLRef result = CFBundleCopyResourceURL(BundleWithIdentifier, a1, 0, 0);
  a2[1] = 0;
  a2[2] = 0;
  *a2 = 0;
  if (result) {
    getFileSystemRepresentationFromCFURL(result);
  }
  return result;
}

void sub_1A43E3078(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t getParsecLogHandle()
{
  if (getParsecLogHandle::onceToken != -1) {
    dispatch_once(&getParsecLogHandle::onceToken, &__block_literal_global_9);
  }
  return getParsecLogHandle::logHandle;
}

os_log_t __getParsecLogHandle_block_invoke()
{
  os_log_t result = os_log_create("com.apple.NLP", "NLParsecDataManager");
  getParsecLogHandle::logHandle = (uint64_t)result;
  return result;
}

CFURLRef createCFURLFromPathRepresentation(const __CFString *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 == CFStringGetTypeID())
  {
    return CFURLCreateWithFileSystemPath(0, a1, kCFURLPOSIXPathStyle, 1u);
  }
  else
  {
    CFTypeID v4 = CFGetTypeID(a1);
    if (v4 == CFURLGetTypeID())
    {
      return CFURLCopyAbsoluteURL((CFURLRef)a1);
    }
    else
    {
      return 0;
    }
  }
}

CFMutableDictionaryRef createDictionaryWithContentsOfURL(CFURLRef fileURL, int a2)
{
  uint64_t v3 = CFReadStreamCreateWithFile(0, fileURL);
  if (v3)
  {
    CFTypeID v4 = v3;
    if (CFReadStreamOpen(v3))
    {
      if (a2) {
        CFOptionFlags v5 = 2;
      }
      else {
        CFOptionFlags v5 = 0;
      }
      CFPropertyListRef v6 = CFPropertyListCreateWithStream(0, v4, 0, v5, 0, 0);
      CFReadStreamClose(v4);
      CFRelease(v4);
      if (v6)
      {
        CFTypeID v7 = CFGetTypeID(v6);
        if (v7 != CFDictionaryGetTypeID())
        {
          CFRelease(v6);
          exception = __cxa_allocate_exception(0x20uLL);
          std::string::basic_string[abi:ne180100]<0>(&v12, "unexpected info dictionary format");
          NL::ResourceCreationException::ResourceCreationException(exception, &v12);
        }
        return (CFMutableDictionaryRef)v6;
      }
    }
    else
    {
      CFRelease(v4);
    }
  }
  CFRange v9 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  CFRange v10 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];

  return CFDictionaryCreateMutable(0, 0, v9, v10);
}

void sub_1A43E32E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0) {
LABEL_6:
    }
      _Unwind_Resume(a1);
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

BOOL CFStringsAreEqual(const __CFString *a1, const __CFString *a2)
{
  return CFEqual(a1, a2);
}

void splitWithChar(uint64_t a1, unsigned __int8 a2, uint64_t a3)
{
  std::string::basic_string[abi:ne180100]<0>(&v38, "");
  uint64_t v6 = *(unsigned __int8 *)(a1 + 23);
  if ((v6 & 0x80u) != 0) {
    uint64_t v6 = *(void *)(a1 + 8);
  }
  if (v6)
  {
    std::string::size_type v7 = 0;
    while (*(unsigned __int8 *)std::string::at((const std::string *)a1, v7) != a2)
    {
      CFArrayRef v8 = (std::string::value_type *)std::string::at((const std::string *)a1, v7);
      std::string::push_back(&v38, *v8);
LABEL_34:
      ++v7;
      std::string::size_type v24 = *(unsigned __int8 *)(a1 + 23);
      if ((v24 & 0x80u) != 0) {
        std::string::size_type v24 = *(void *)(a1 + 8);
      }
      if (v24 <= v7) {
        goto LABEL_37;
      }
    }
    if (v7)
    {
      if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
        std::string::__init_copy_ctor_external(&__p, v38.__r_.__value_.__l.__data_, v38.__r_.__value_.__l.__size_);
      }
      else {
        std::string __p = v38;
      }
      unint64_t v10 = *(void *)(a3 + 8);
      unint64_t v16 = *(void *)(a3 + 16);
      if (v10 < v16) {
        goto LABEL_21;
      }
      unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - *(void *)a3) >> 3);
      unint64_t v18 = v11 + 1;
      if (v11 + 1 > 0xAAAAAAAAAAAAAAALL) {
        std::vector<NLExtendedString>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v16 - *(void *)a3) >> 3);
      if (2 * v19 > v18) {
        unint64_t v18 = 2 * v19;
      }
      if (v19 >= 0x555555555555555) {
        unint64_t v14 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v14 = v18;
      }
      __v.__end_cap_.__value_ = (std::allocator<std::string> *)(a3 + 16);
      if (!v14)
      {
        uint64_t v15 = 0;
        goto LABEL_31;
      }
    }
    else
    {
      std::string::basic_string[abi:ne180100]<0>(&__p, "");
      unint64_t v10 = *(void *)(a3 + 8);
      unint64_t v9 = *(void *)(a3 + 16);
      if (v10 < v9)
      {
LABEL_21:
        long long v17 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
        *(void *)(v10 + 16) = *((void *)&__p.__r_.__value_.__l + 2);
        *(_OWORD *)unint64_t v10 = v17;
        *(void *)(a3 + 8) = v10 + 24;
LABEL_33:
        MEMORY[0x1A625AE00](&v38, "");
        goto LABEL_34;
      }
      unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - *(void *)a3) >> 3);
      unint64_t v12 = v11 + 1;
      if (v11 + 1 > 0xAAAAAAAAAAAAAAALL) {
        std::vector<NLExtendedString>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v9 - *(void *)a3) >> 3);
      if (2 * v13 > v12) {
        unint64_t v12 = 2 * v13;
      }
      if (v13 >= 0x555555555555555) {
        unint64_t v14 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v14 = v12;
      }
      __v.__end_cap_.__value_ = (std::allocator<std::string> *)(a3 + 16);
      if (!v14)
      {
        uint64_t v15 = 0;
LABEL_31:
        uint64_t v20 = v15 + v11;
        __v.__first_ = v15;
        __v.__begin_ = v20;
        __v.__end_cap_.__value_ = &v15[v14];
        long long v21 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
        v20->__r_.__value_.__r.__words[2] = __p.__r_.__value_.__r.__words[2];
        *(_OWORD *)&v20->__r_.__value_.__l.__data_ = v21;
        memset(&__p, 0, sizeof(__p));
        __v.__end_ = v20 + 1;
        std::vector<std::string>::__swap_out_circular_buffer((std::vector<std::string> *)a3, &__v);
        uint64_t v22 = *(void *)(a3 + 8);
        std::__split_buffer<std::string>::~__split_buffer(&__v);
        int v23 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
        *(void *)(a3 + 8) = v22;
        if (v23 < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        goto LABEL_33;
      }
    }
    uint64_t v15 = (std::string *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(a3 + 16, v14);
    goto LABEL_31;
  }
LABEL_37:
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&__p, v38.__r_.__value_.__l.__data_, v38.__r_.__value_.__l.__size_);
  }
  else {
    std::string __p = v38;
  }
  unint64_t v25 = *(void *)(a3 + 16);
  unint64_t v26 = *(void *)(a3 + 8);
  if (v26 >= v25)
  {
    unint64_t v28 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v26 - *(void *)a3) >> 3);
    unint64_t v29 = v28 + 1;
    if (v28 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<NLExtendedString>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v30 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v25 - *(void *)a3) >> 3);
    if (2 * v30 > v29) {
      unint64_t v29 = 2 * v30;
    }
    if (v30 >= 0x555555555555555) {
      unint64_t v31 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v31 = v29;
    }
    __v.__end_cap_.__value_ = (std::allocator<std::string> *)(a3 + 16);
    if (v31) {
      double v32 = (std::string *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(a3 + 16, v31);
    }
    else {
      double v32 = 0;
    }
    uint64_t v33 = v32 + v28;
    __v.__first_ = v32;
    __v.__begin_ = v33;
    __v.__end_cap_.__value_ = &v32[v31];
    long long v34 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
    v33->__r_.__value_.__r.__words[2] = __p.__r_.__value_.__r.__words[2];
    *(_OWORD *)&v33->__r_.__value_.__l.__data_ = v34;
    memset(&__p, 0, sizeof(__p));
    __v.__end_ = v33 + 1;
    std::vector<std::string>::__swap_out_circular_buffer((std::vector<std::string> *)a3, &__v);
    uint64_t v35 = *(void *)(a3 + 8);
    std::__split_buffer<std::string>::~__split_buffer(&__v);
    int v36 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
    *(void *)(a3 + 8) = v35;
    if (v36 < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    long long v27 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
    *(void *)(v26 + 16) = *((void *)&__p.__r_.__value_.__l + 2);
    *(_OWORD *)unint64_t v26 = v27;
    *(void *)(a3 + 8) = v26 + 24;
  }
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v38.__r_.__value_.__l.__data_);
  }
}

void sub_1A43E3748(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,std::__split_buffer<std::string> *a22)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

unint64_t trim@<X0>(unint64_t result@<X0>, void *a2@<X8>)
{
  unint64_t v2 = result;
  uint64_t v4 = *(unsigned __int8 *)(result + 23);
  char v5 = v4;
  uint64_t v6 = *(char **)result;
  uint64_t v7 = *(void *)(result + 8);
  if ((v4 & 0x80u) == 0) {
    CFArrayRef v8 = (char *)result;
  }
  else {
    CFArrayRef v8 = *(char **)result;
  }
  if ((v4 & 0x80u) == 0) {
    uint64_t v9 = *(unsigned __int8 *)(result + 23);
  }
  else {
    uint64_t v9 = *(void *)(result + 8);
  }
  uint64_t v10 = MEMORY[0x1E4F14390];
  if (v9)
  {
    unint64_t v11 = &v8[v9];
    do
    {
      unsigned int v12 = *v8;
      if ((v12 & 0x80000000) != 0)
      {
        os_log_t result = __maskrune(v12, 0x4000uLL);
        if (!result) {
          goto LABEL_15;
        }
      }
      else
      {
        os_log_t result = *(_DWORD *)(v10 + 4 * v12 + 60) & 0x4000;
        if (!result) {
          goto LABEL_15;
        }
      }
      ++v8;
      --v9;
    }
    while (v9);
    CFArrayRef v8 = v11;
LABEL_15:
    uint64_t v4 = *(unsigned __int8 *)(v2 + 23);
    uint64_t v6 = *(char **)v2;
    uint64_t v7 = *(void *)(v2 + 8);
    char v5 = *(unsigned char *)(v2 + 23);
  }
  unint64_t v13 = &v6[v7];
  unint64_t v14 = (char *)(v2 + v4);
  if (v5 >= 0) {
    uint64_t v15 = v14;
  }
  else {
    uint64_t v15 = v13;
  }
  if (v5 < 0) {
    unint64_t v2 = (unint64_t)v6;
  }
  while (v15 != (char *)v2)
  {
    unsigned int v17 = *--v15;
    unsigned int v16 = v17;
    if ((v17 & 0x80000000) != 0)
    {
      os_log_t result = __maskrune(v16, 0x4000uLL);
      if (!result)
      {
LABEL_26:
        unint64_t v2 = (unint64_t)(v15 + 1);
        break;
      }
    }
    else
    {
      os_log_t result = *(_DWORD *)(v10 + 4 * v16 + 60) & 0x4000;
      if (!result) {
        goto LABEL_26;
      }
    }
  }
  if ((unint64_t)v8 >= v2)
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
  }
  else
  {
    return (unint64_t)std::string::__init_with_size[abi:ne180100]<char const*,char const*>(a2, v8, (char *)v2, v2 - (void)v8);
  }
  return result;
}

void join(uint64_t *a1@<X0>, uint64_t a2@<X1>, std::string *a3@<X8>)
{
  uint64_t v4 = *a1;
  unint64_t v5 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  if (v5 == 1)
  {
    if (*(char *)(v4 + 23) < 0)
    {
      unsigned int v17 = *(const std::string::value_type **)v4;
      std::string::size_type v18 = *(void *)(v4 + 8);
      std::string::__init_copy_ctor_external(a3, v17, v18);
    }
    else
    {
      long long v6 = *(_OWORD *)v4;
      a3->__r_.__value_.__r.__words[2] = *(void *)(v4 + 16);
      *(_OWORD *)&a3->__r_.__value_.__l.__data_ = v6;
    }
  }
  else if (v5)
  {
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v19);
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v9 = a2;
    }
    else {
      uint64_t v9 = *(void *)a2;
    }
    std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::__wrap_iter<std::string *>,std::__wrap_iter<std::string *>,std::ostream_iterator<std::string,char,std::char_traits<char>>,0>(*a1, a1[1] - 24, (uint64_t)v19, v9, v22);
    uint64_t v10 = a1[1];
    uint64_t v13 = *(void *)(v10 - 24);
    uint64_t v11 = v10 - 24;
    uint64_t v12 = v13;
    int v14 = *(char *)(v11 + 23);
    if (v14 >= 0) {
      uint64_t v15 = v11;
    }
    else {
      uint64_t v15 = v12;
    }
    if (v14 >= 0) {
      uint64_t v16 = *(unsigned __int8 *)(v11 + 23);
    }
    else {
      uint64_t v16 = *(void *)(v11 + 8);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, v15, v16);
    std::stringbuf::str();
    v19[0] = *MEMORY[0x1E4FBA418];
    *(void *)((char *)v19 + *(void *)(v19[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
    v19[1] = MEMORY[0x1E4FBA470] + 16;
    if (v20 < 0) {
      operator delete((void *)v19[9]);
    }
    std::streambuf::~streambuf();
    std::ostream::~ostream();
    MEMORY[0x1A625B0A0](&v21);
  }
  else
  {
    std::string::basic_string[abi:ne180100]<0>(a3, "");
  }
}

void sub_1A43E3AF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

BOOL startswith(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v2 = (char)a2[23];
  BOOL v3 = v2 < 0;
  if (v2 >= 0) {
    uint64_t v4 = a2;
  }
  else {
    uint64_t v4 = *(unsigned __int8 **)a2;
  }
  if (v3) {
    uint64_t v5 = *((void *)a2 + 1);
  }
  else {
    uint64_t v5 = a2[23];
  }
  long long v6 = &v4[v5];
  if (v5)
  {
    if ((a1[23] & 0x80u) == 0) {
      uint64_t v7 = a1;
    }
    else {
      uint64_t v7 = *(unsigned __int8 **)a1;
    }
    while (*v4 == *v7)
    {
      ++v4;
      ++v7;
      if (!--v5)
      {
        uint64_t v4 = v6;
        return v4 == v6;
      }
    }
  }
  return v4 == v6;
}

BOOL endswith(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = *((unsigned __int8 *)a2 + 23);
  if ((v2 & 0x80u) == 0) {
    unint64_t v3 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    unint64_t v3 = a2[1];
  }
  unint64_t v4 = *((unsigned __int8 *)a1 + 23);
  int v5 = (char)v4;
  if ((v4 & 0x80u) != 0) {
    unint64_t v4 = a1[1];
  }
  if (v3 > v4) {
    return 0;
  }
  int v7 = (char)v2;
  CFArrayRef v8 = (uint64_t *)((char *)a2 + v2);
  if (v7 >= 0)
  {
    uint64_t v9 = a2;
  }
  else
  {
    CFArrayRef v8 = (uint64_t *)(*a2 + a2[1]);
    uint64_t v9 = (uint64_t *)*a2;
  }
  if (v5 >= 0) {
    uint64_t v10 = a1;
  }
  else {
    uint64_t v10 = (uint64_t *)*a1;
  }
  uint64_t v11 = (unsigned __int8 *)v10 + v4 - 1;
  do
  {
    BOOL result = v8 == v9;
    if (v8 == v9) {
      break;
    }
    int v13 = *((unsigned __int8 *)v8 - 1);
    CFArrayRef v8 = (uint64_t *)((char *)v8 - 1);
    int v12 = v13;
    int v14 = *v11--;
  }
  while (v12 == v14);
  return result;
}

std::string *replaceAll(std::string *this, char *a2, uint64_t a3)
{
  int v3 = a2[23];
  BOOL v25 = v3 < 0;
  std::string::size_type v4 = *((void *)a2 + 1);
  std::string::size_type v5 = a2[23];
  if (v3 >= 0) {
    int64_t v6 = a2[23];
  }
  else {
    int64_t v6 = *((void *)a2 + 1);
  }
  if (v6)
  {
    CFArrayRef v8 = this;
    std::string::size_type v9 = 0;
    std::string::size_type size = HIBYTE(this->__r_.__value_.__r.__words[2]);
    if ((size & 0x80u) == 0) {
      uint64_t v11 = this;
    }
    else {
      uint64_t v11 = (std::string *)this->__r_.__value_.__r.__words[0];
    }
    if ((size & 0x80u) != 0) {
      std::string::size_type size = this->__r_.__value_.__l.__size_;
    }
    if ((v5 & 0x80u) == 0) {
      int v12 = a2;
    }
    else {
      int v12 = *(char **)a2;
    }
    while (!v6)
    {
LABEL_23:
      if (v9 != -1)
      {
        if (v25) {
          std::string::size_type v18 = v4;
        }
        else {
          std::string::size_type v18 = v5;
        }
        int v19 = *(char *)(a3 + 23);
        if (v19 >= 0) {
          char v20 = (const std::string::value_type *)a3;
        }
        else {
          char v20 = *(const std::string::value_type **)a3;
        }
        if (v19 >= 0) {
          std::string::size_type v21 = *(unsigned __int8 *)(a3 + 23);
        }
        else {
          std::string::size_type v21 = *(void *)(a3 + 8);
        }
        this = std::string::replace(v8, v9, v18, v20, v21);
        uint64_t v22 = *(unsigned __int8 *)(a3 + 23);
        if ((v22 & 0x80u) != 0) {
          uint64_t v22 = *(void *)(a3 + 8);
        }
        v9 += v22;
        std::string::size_type size = HIBYTE(v8->__r_.__value_.__r.__words[2]);
        if ((size & 0x80u) == 0) {
          uint64_t v11 = v8;
        }
        else {
          uint64_t v11 = (std::string *)v8->__r_.__value_.__r.__words[0];
        }
        if ((size & 0x80u) != 0) {
          std::string::size_type size = v8->__r_.__value_.__l.__size_;
        }
        int v23 = a2[23];
        BOOL v25 = v23 < 0;
        std::string::size_type v4 = *((void *)a2 + 1);
        std::string::size_type v5 = a2[23];
        int v12 = v23 >= 0 ? a2 : *(char **)a2;
        int64_t v6 = v23 >= 0 ? a2[23] : *((void *)a2 + 1);
        if (size >= v9) {
          continue;
        }
      }
      return this;
    }
    this = (std::string *)((char *)v11 + v9);
    int v13 = (std::string *)((char *)v11 + size);
    int64_t v14 = size - v9;
    if (v14 >= v6)
    {
      int v15 = *v12;
      do
      {
        int64_t v16 = v14 - v6;
        if (v16 == -1) {
          break;
        }
        this = (std::string *)memchr(this, v15, v16 + 1);
        if (!this) {
          break;
        }
        unsigned int v17 = this;
        this = (std::string *)memcmp(this, v12, v6);
        if (!this)
        {
          if (v17 == v13) {
            return this;
          }
          std::string::size_type v9 = (char *)v17 - (char *)v11;
          goto LABEL_23;
        }
        this = (std::string *)((char *)&v17->__r_.__value_.__l.__data_ + 1);
        int64_t v14 = (char *)v13 - ((char *)&v17->__r_.__value_.__l.__data_ + 1);
      }
      while (v14 >= v6);
    }
  }
  return this;
}

void stringToUTF32Characters(uint64_t *a1@<X0>, int **a2@<X8>)
{
  if (*((char *)a1 + 23) >= 0) {
    int v3 = *((unsigned __int8 *)a1 + 23);
  }
  else {
    int v3 = *((_DWORD *)a1 + 2);
  }
  a2[1] = 0;
  a2[2] = 0;
  *a2 = 0;
  if (v3 >= 1)
  {
    std::string::size_type v5 = 0;
    LODWORD(v6) = 0;
    int v7 = a2 + 2;
    do
    {
      if (*((char *)a1 + 23) >= 0) {
        CFArrayRef v8 = a1;
      }
      else {
        CFArrayRef v8 = (uint64_t *)*a1;
      }
      uint64_t v9 = (int)v6;
      int v10 = *((char *)v8 + (int)v6);
      uint64_t v6 = (int)v6 + 1;
      int v11 = v10;
      if ((v10 & 0x80000000) == 0) {
        goto LABEL_10;
      }
      if (v6 == v3) {
        return;
      }
      if (v10 < 0xE0u)
      {
        if (v10 < 0xC2u) {
          continue;
        }
        int v15 = v10 & 0x1F;
      }
      else
      {
        if (v10 > 0xEFu)
        {
          if (v10 > 0xF4u) {
            continue;
          }
          unint64_t v25 = *((unsigned __int8 *)v8 + v6);
          if (((byte_1A43F8287[v25 >> 4] >> (v10 + 16)) & 1) == 0) {
            continue;
          }
          uint64_t v6 = v9 + 2;
          if (v9 + 2 == v3) {
            return;
          }
          unsigned int v14 = *((unsigned __int8 *)v8 + v6) ^ 0x80;
          if (v14 > 0x3F) {
            continue;
          }
          LODWORD(v13) = v25 & 0x3F | ((v11 - 240) << 6);
        }
        else
        {
          uint64_t v13 = v10 & 0xF;
          if (((a00000000000000[v13] >> (*((unsigned char *)v8 + v6) >> 5)) & 1) == 0) {
            continue;
          }
          unsigned int v14 = *((unsigned char *)v8 + v6) & 0x3F;
        }
        LODWORD(v6) = v6 + 1;
        if (v6 == v3) {
          return;
        }
        int v15 = v14 | (v13 << 6);
      }
      unsigned int v22 = *((unsigned __int8 *)v8 + (int)v6) ^ 0x80;
      if (v22 <= 0x3F)
      {
        int v11 = v22 | (v15 << 6);
        LODWORD(v6) = v6 + 1;
LABEL_10:
        if ((unint64_t)v5 >= *v7)
        {
          int64_t v16 = *a2;
          uint64_t v17 = v5 - *a2;
          unint64_t v18 = v17 + 1;
          if ((unint64_t)(v17 + 1) >> 62) {
            std::vector<NLExtendedString>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v19 = *v7 - (void)v16;
          if (v19 >> 1 > v18) {
            unint64_t v18 = v19 >> 1;
          }
          if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v20 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v20 = v18;
          }
          if (v20)
          {
            std::string::size_type v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<char32_t>>((uint64_t)(a2 + 2), v20);
            int64_t v16 = *a2;
            std::string::size_type v5 = a2[1];
          }
          else
          {
            std::string::size_type v21 = 0;
          }
          int v23 = (int *)&v21[4 * v17];
          int *v23 = v11;
          int v12 = v23 + 1;
          while (v5 != v16)
          {
            int v24 = *--v5;
            *--int v23 = v24;
          }
          *a2 = v23;
          a2[1] = v12;
          a2[2] = (int *)&v21[4 * v20];
          if (v16) {
            operator delete(v16);
          }
        }
        else
        {
          int *v5 = v11;
          int v12 = v5 + 1;
        }
        a2[1] = v12;
        std::string::size_type v5 = v12;
      }
    }
    while ((int)v6 < v3);
  }
}

void sub_1A43E3FB8(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

CFIndex enumerateCharactersInCFString(CFIndex theString, CFIndex theIndex, uint64_t a3, uint64_t a4)
{
  CFIndex v5 = theIndex;
  CFStringRef v6 = (const __CFString *)theString;
  char v9 = 0;
  CFIndex v7 = theIndex + a3;
  do
  {
    if (v5 >= v7) {
      break;
    }
    CFRange RangeOfComposedCharactersAtIndex = CFStringGetRangeOfComposedCharactersAtIndex(v6, v5);
    CFStringRef theString = RangeOfComposedCharactersAtIndex.location;
    if (RangeOfComposedCharactersAtIndex.location == -1) {
      break;
    }
    CFStringRef theString = (*(uint64_t (**)(uint64_t, CFIndex, CFIndex, char *))(a4 + 16))(a4, RangeOfComposedCharactersAtIndex.location, RangeOfComposedCharactersAtIndex.length, &v9);
    v5 += RangeOfComposedCharactersAtIndex.length;
  }
  while (!v9);
  return theString;
}

uint64_t newCharacterSetWithPattern(const __CFString *a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  HIDWORD(v5) = 0;
  CFIndex Length = CFStringGetLength(@"[[:Hani:][:Katakana:][:Hiragana:][:Katakana_Or_Hiragana:][\\u30FC]]");
  MEMORY[0x1F4188790](Length);
  int v3 = (UniChar *)((char *)&v5 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0));
  if (!CFStringGetCharactersPtr(@"[[:Hani:][:Katakana:][:Hiragana:][:Katakana_Or_Hiragana:][\\u30FC]]"))
  {
    v7.CFIndex location = 0;
    v7.CFIndex length = Length;
    CFStringGetCharacters(@"[[:Hani:][:Katakana:][:Hiragana:][:Katakana_Or_Hiragana:][\\u30FC]]", v7, v3);
  }
  uint64_t result = uset_openPattern();
  if (SHIDWORD(v5) >= 1)
  {
    if (result)
    {
      uset_close();
      return 0;
    }
  }
  return result;
}

uint64_t copyStringInsertingSpacesBetweenIdeographCharacters(CFIndex a1, CFIndex a2, uint64_t a3)
{
  if (__onceCSetToken != -1) {
    dispatch_once(&__onceCSetToken, &__block_literal_global_46);
  }
  uint64_t v15 = 0;
  int64_t v16 = &v15;
  uint64_t v17 = 0x2000000000;
  CFMutableStringRef Mutable = 0;
  CFMutableStringRef Mutable = CFStringCreateMutable(0, 0);
  v13[0] = 0;
  v13[1] = v13;
  v13[2] = 0x2000000000;
  int v14 = 0;
  v11[0] = 0;
  v11[1] = v11;
  v11[2] = 0x2000000000;
  char v12 = 0;
  v9[0] = 0;
  v9[1] = v9;
  std::regex_traits<char> v9[2] = 0x2000000000;
  char v10 = 0;
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 0x40000000;
  v8[2] = __copyStringInsertingSpacesBetweenIdeographCharacters_block_invoke_2;
  v8[3] = &unk_1E5B37290;
  void v8[7] = &v15;
  v8[8] = a1;
  v8[4] = v13;
  void v8[5] = v11;
  v8[6] = v9;
  enumerateCharactersInCFString(a1, a2, a3, (uint64_t)v8);
  uint64_t v6 = v16[3];
  _Block_object_dispose(v9, 8);
  _Block_object_dispose(v11, 8);
  _Block_object_dispose(v13, 8);
  _Block_object_dispose(&v15, 8);
  return v6;
}

void sub_1A43E42C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va1, a11);
  va_start(va, a11);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose((const void *)(v11 - 128), 8);
  _Block_object_dispose((const void *)(v11 - 96), 8);
  _Unwind_Resume(a1);
}

uint64_t __copyStringInsertingSpacesBetweenIdeographCharacters_block_invoke(const __CFString *a1)
{
  uint64_t result = newCharacterSetWithPattern(a1);
  __CSet = result;
  return result;
}

void __copyStringInsertingSpacesBetweenIdeographCharacters_block_invoke_2(uint64_t a1, CFRange a2)
{
  CFIndex length = a2.length;
  v10[1] = *MEMORY[0x1E4F143B8];
  std::string::size_type v4 = (UniChar *)((char *)v10 - ((2 * a2.length + 17) & 0xFFFFFFFFFFFFFFF0));
  CFStringGetCharacters(*(CFStringRef *)(a1 + 64), a2, v4);
  int isWhitespace = u_isWhitespace(*v4);
  int v6 = uset_containsAllCodePoints();
  int v7 = v6;
  if (*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    BOOL v8 = !*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) || v6 == 0;
    if (!v8 || (*(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) ? (BOOL v9 = isWhitespace == 0) : (BOOL v9 = 0), v9)) {
      CFStringAppend(*(CFMutableStringRef *)(*(void *)(*(void *)(a1 + 56) + 8) + 24), @" ");
    }
  }
  CFStringAppendCharacters(*(CFMutableStringRef *)(*(void *)(*(void *)(a1 + 56) + 8) + 24), v4, length);
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = isWhitespace == 0;
  *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = v7 != 0;
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

CFStringRef copyTranslatedRomanNumberFromChineseNumberString(const __CFString *a1)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  values[4] = xmmword_1E5B372F0;
  values[5] = *(_OWORD *)&off_1E5B37300;
  unint64_t v30 = @"9";
  values[0] = xmmword_1E5B372B0;
  values[1] = *(_OWORD *)&off_1E5B372C0;
  values[2] = xmmword_1E5B372D0;
  CFNumberRef values[3] = *(_OWORD *)&off_1E5B372E0;
  long long v26 = xmmword_1E5B37358;
  long long v27 = *(_OWORD *)&off_1E5B37368;
  unint64_t v28 = @"";
  *(_OWORD *)keys = xmmword_1E5B37318;
  long long v23 = *(_OWORD *)&off_1E5B37328;
  long long v24 = xmmword_1E5B37338;
  long long v25 = *(_OWORD *)&off_1E5B37348;
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDictionaryRef v3 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)keys, (const void **)values, 13, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  *(_OWORD *)prefix = xmmword_1E5B37380;
  std::string::size_type v21 = @"";
  CFArrayRef v4 = CFArrayCreate(v2, (const void **)prefix, 3, MEMORY[0x1E4F1D510]);
  CFIndex Length = CFStringGetLength(a1);
  if (Length < 1)
  {
    uint64_t v17 = 0;
  }
  else
  {
    CFIndex v6 = Length;
    int v7 = 0;
    int v8 = 0;
    int v9 = 0;
    for (CFIndex i = 0; i != v6; ++i)
    {
      v33.CFIndex location = i;
      v33.CFIndex length = 1;
      CFStringRef v11 = CFStringCreateWithSubstring(v2, a1, v33);
      value = 0;
      if (CFDictionaryGetValueIfPresent(v3, v11, (const void **)&value))
      {
        IntCFNumberRef Value = CFStringGetIntValue((CFStringRef)value);
        int v13 = 10 * v9;
        if (!v7) {
          int v13 = v9;
        }
        int v9 = IntValue + v13;
        ++v7;
      }
      else
      {
        v32.CFIndex length = CFArrayGetCount(v4);
        v32.CFIndex location = 0;
        if (CFArrayContainsValue(v4, v32, v11))
        {
          int HasPrefix = CFStringHasPrefix(v11, prefix[0]);
          if (v9)
          {
            if (HasPrefix)
            {
              int v15 = 10 * v9;
            }
            else
            {
              int v16 = CFStringHasPrefix(v11, prefix[1]);
              int v15 = 1000 * v9;
              if (v16) {
                int v15 = 100 * v9;
              }
            }
          }
          else if (HasPrefix)
          {
            int v15 = 10;
          }
          else if (CFStringHasPrefix(v11, prefix[1]))
          {
            int v15 = 100;
          }
          else
          {
            int v15 = 1000;
          }
          int v9 = 0;
          int v7 = 0;
          v8 += v15;
        }
      }
      CFRelease(v11);
    }
    uint64_t v17 = (v8 + v9);
  }
  CFRelease(v3);
  CFRelease(v4);
  return CFStringCreateWithFormat(v2, 0, @"%d", v17);
}

uint64_t intFromSpelledNumber(const __CFString *a1, uint64_t a2)
{
  IntCFNumberRef Value = 0xFFFFFFFFLL;
  if (a1 && a2)
  {
    CFStringRef v4 = (const __CFString *)MEMORY[0x1A625A3A0](a2);
    if ((CFStringHasPrefix(v4, @"zh") || CFStringHasPrefix(v4, @"ja"))
      && (CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80],
          (CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1, @" ")) != 0))
    {
      CFArrayRef v7 = ArrayBySeparatingStrings;
      CFStringRef v8 = CFStringCreateByCombiningStrings(v5, ArrayBySeparatingStrings, &stru_1EF7CF078);
      if (v8)
      {
        CFStringRef v9 = v8;
        CFStringRef v10 = copyTranslatedRomanNumberFromChineseNumberString(v8);
        if (v10)
        {
          CFStringRef v11 = v10;
          IntCFNumberRef Value = CFStringGetIntValue(v10);
          CFRelease(v11);
        }
        else
        {
          IntCFNumberRef Value = 0xFFFFFFFFLL;
        }
        CFRelease(v9);
      }
      else
      {
        IntCFNumberRef Value = 0xFFFFFFFFLL;
      }
      CFRelease(v7);
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return IntValue;
}

CFLocaleRef copyCurrentLocale()
{
  CFArrayRef v0 = CFLocaleCopyPreferredLanguages();
  if (v0)
  {
    CFArrayRef v1 = v0;
    if (CFArrayGetCount(v0)
      && (CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v1, 0),
          uint64_t v3 = *MEMORY[0x1E4F1CF80],
          (CFLocaleRef v4 = CFLocaleCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], ValueAtIndex)) != 0))
    {
      CFLocaleRef v5 = v4;
      if (CFLocaleGetValue(v4, (CFLocaleKey)*MEMORY[0x1E4F1D1F0])) {
        CFLocaleRef v6 = (CFLocaleRef)MEMORY[0x1A625A380](v3, v5);
      }
      else {
        CFLocaleRef v6 = CFLocaleCopyCurrent();
      }
      CFLocaleRef v7 = v6;
      CFRelease(v5);
    }
    else
    {
      CFLocaleRef v7 = CFLocaleCopyCurrent();
    }
    CFRelease(v1);
    return v7;
  }
  else
  {
    return CFLocaleCopyCurrent();
  }
}

__CFCalendar *copyCurrentCalendar(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  CFStringRef v1 = (const __CFString *)MEMORY[0x1A625A3A0]();
  CFAllocatorRef v2 = CFCalendarCreateWithIdentifier((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v1);
  if (v2 || (CFAllocatorRef v2 = CFCalendarCopyCurrent()) != 0)
  {
    CFTimeZoneRef v3 = CFTimeZoneCopySystem();
    if (v3)
    {
      CFTimeZoneRef v4 = v3;
      CFCalendarSetTimeZone(v2, v3);
      CFRelease(v4);
    }
    CFCalendarSetFirstWeekday(v2, 1);
  }
  return v2;
}

double getCurrentTime(uint64_t a1)
{
  if (a1) {
    JUMPOUT(0x1A625A220);
  }
  return CFAbsoluteTimeGetCurrent();
}

void *convertToCString(const __CFString *a1)
{
  if (!a1) {
    return 0;
  }
  CFIndex Length = CFStringGetLength(a1);
  CFIndex v3 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
  CFTimeZoneRef v4 = malloc_type_malloc(v3, 0xD5CEEA62uLL);
  if (!CFStringGetCString(a1, (char *)v4, v3, 0x8000100u))
  {
    free(v4);
    return 0;
  }
  return v4;
}

uint64_t createLexicon(const __CFString *a1)
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFStringRef v8 = Mutable;
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F72458], a1);
  CFLocaleRef v7 = 0;
  uint64_t v3 = LXLexiconCreate();
  if (!v3)
  {
    getUTF8StringFromCFString(a1, v6);
    __cxa_allocate_exception(0x20uLL);
    std::operator+<char>();
    NL::SharedCFType::SharedCFType((NL::SharedCFType *)&v5, v7);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v3;
}

void sub_1A43E4AE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  if (a16 < 0)
  {
    operator delete(__p);
    if ((v23 & 1) == 0)
    {
LABEL_8:
      if (a22 < 0) {
        operator delete(a17);
      }
      nlp::CFScopedPtr<__CFDictionary *>::reset((const void **)(v24 - 40), 0);
      _Unwind_Resume(a1);
    }
  }
  else if (!v23)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v22);
  goto LABEL_8;
}

void composeErrorMessageForLocale(CFLocaleRef locale@<X1>, const void **a2@<X0>, uint64_t a3@<X8>)
{
  CFStringRef Value = (const __CFString *)CFLocaleGetValue(locale, (CFLocaleKey)*MEMORY[0x1E4F1D218]);
  CFLocaleRef v6 = (char *)convertToCString(Value);
  std::string::basic_string[abi:ne180100]<0>(__p, v6);
  free(v6);
  std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(a2, (const void **)__p, a3);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1A43E4BF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

CFStringRef NLPCreateStringWithValidatedFormat(CFStringRef validFormatSpecifiers, CFStringRef format, ...)
{
  va_start(va, format);
  errorPtr[0] = 0;
  va_copy((va_list)&errorPtr[1], va);
  CFStringRef StringWithValidatedFormatAndArguments = CFStringCreateStringWithValidatedFormatAndArguments((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, validFormatSpecifiers, format, va, errorPtr);
  if (errorPtr[0])
  {
    CFStringRef v4 = CFErrorCopyDescription(errorPtr[0]);
    uint64_t v5 = _nlpDefaultLog();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      NLPCreateStringWithValidatedFormat((uint64_t)format, (uint64_t)v4, v5);
    }
    CFRelease(errorPtr[0]);
    if (v4) {
      CFRelease(v4);
    }
  }
  return StringWithValidatedFormatAndArguments;
}

void sub_1A43E4CCC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  nlp::CFScopedPtr<__CFString const*>::reset((const void **)va, 0);
  _Unwind_Resume(a1);
}

uint64_t NL::ResourceCreationException::ResourceCreationException(uint64_t a1, const void **a2, NL::SharedCFType *this)
{
  v22[2] = *MEMORY[0x1E4F143B8];
  *(void *)a1 = &unk_1EF7CDD58;
  *(void *)(a1 + 8) = 0;
  uint64_t v5 = (void **)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  CFLocaleRef v6 = (void *)NL::SharedCFType::get(this);
  CFTypeID v7 = CFGetTypeID(v6);
  if (v7 == CFErrorGetTypeID())
  {
    CFStringRef v8 = CFErrorCopyDescription((CFErrorRef)v6);
    if (*((char *)a2 + 23) >= 0) {
      size_t v9 = *((unsigned __int8 *)a2 + 23);
    }
    else {
      size_t v9 = (size_t)a2[1];
    }
    CFStringRef v10 = &v21;
    std::string::basic_string[abi:ne180100]((uint64_t)&v21, v9 + 2);
    if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      CFStringRef v10 = (std::string *)v21.__r_.__value_.__r.__words[0];
    }
    if (v9)
    {
      if (*((char *)a2 + 23) >= 0) {
        CFStringRef v11 = a2;
      }
      else {
        CFStringRef v11 = *a2;
      }
      memmove(v10, v11, v9);
    }
    strcpy((char *)v10 + v9, ": ");
    getUTF8StringFromCFString(v8, __p);
    if ((v20 & 0x80u) == 0) {
      char v12 = __p;
    }
    else {
      char v12 = (void **)__p[0];
    }
    if ((v20 & 0x80u) == 0) {
      std::string::size_type v13 = v20;
    }
    else {
      std::string::size_type v13 = (std::string::size_type)__p[1];
    }
    int v14 = std::string::append(&v21, (const std::string::value_type *)v12, v13);
    std::string::size_type v15 = v14->__r_.__value_.__r.__words[0];
    v22[0] = v14->__r_.__value_.__l.__size_;
    *(void *)((char *)v22 + 7) = *(std::string::size_type *)((char *)&v14->__r_.__value_.__r.__words[1] + 7);
    char v16 = HIBYTE(v14->__r_.__value_.__r.__words[2]);
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    if (*(char *)(a1 + 31) < 0) {
      operator delete(*v5);
    }
    uint64_t v17 = v22[0];
    *(void *)(a1 + 8) = v15;
    *(void *)(a1 + 16) = v17;
    *(void *)(a1 + 23) = *(void *)((char *)v22 + 7);
    *(unsigned char *)(a1 + 31) = v16;
    if ((char)v20 < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v21.__r_.__value_.__l.__data_);
    }
    CFRelease(v8);
  }
  return a1;
}

void sub_1A43E4EA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (*(char *)(v21 + 31) < 0) {
    operator delete(*v22);
  }
  std::exception::~exception((std::exception *)v21);
  _Unwind_Resume(a1);
}

void NLDevanagariOrthographyChecker::NLDevanagariOrthographyChecker(NLDevanagariOrthographyChecker *this)
{
  *(void *)this = &unk_1EF7CDB98;
  *((void *)this + 1) = @"";
  *((void *)this + 2) = @"";
  *((void *)this + 3) = @"";
  *((void *)this + 4) = @"";
  *((void *)this + 5) = @"";
  *((void *)this + 6) = @"";
  CFMutableStringRef Mutable = CFStringCreateMutable(0, 0);
  CFStringAppend(Mutable, *((CFStringRef *)this + 2));
  CFStringAppend(Mutable, *((CFStringRef *)this + 3));
  CFStringAppend(Mutable, *((CFStringRef *)this + 4));
  CFStringAppend(Mutable, *((CFStringRef *)this + 5));
  CFStringAppend(Mutable, *((CFStringRef *)this + 6));
  CFStringAppend(Mutable, @"");
  CFStringAppend(Mutable, @"");
  CFStringAppend(Mutable, @"");
  CFStringAppend(Mutable, @"");
  CFStringAppend(Mutable, @"");
  CFStringAppend(Mutable, @"");
  CFStringAppend(Mutable, @"");
  CFStringAppend(Mutable, @"");
  CFStringAppend(Mutable, @"");
  CFStringAppend(Mutable, @"");
  CFStringAppend(Mutable, @"");
  CFStringAppend(Mutable, @"");
  CFStringAppend(Mutable, @"");
  *((void *)this + 7) = CFCharacterSetCreateWithCharactersInString(0, Mutable);
  CFRelease(Mutable);
  CFMutableStringRef v3 = CFStringCreateMutable(0, 0);
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  CFStringAppend(v3, @"");
  *((void *)this + 8) = CFCharacterSetCreateWithCharactersInString(0, v3);
  CFRelease(v3);
  CFMutableStringRef v4 = CFStringCreateMutable(0, 0);
  CFStringAppend(v4, @"");
  CFStringAppend(v4, @"");
  CFStringAppend(v4, @"");
  CFStringAppend(v4, @"");
  CFStringAppend(v4, @"");
  *((void *)this + 9) = CFCharacterSetCreateWithCharactersInString(0, v4);
  CFRelease(v4);
  CFMutableStringRef v5 = CFStringCreateMutable(0, 0);
  CFStringAppend(v5, @"");
  CFStringAppend(v5, @"");
  CFStringAppend(v5, @"");
  CFStringAppend(v5, @"");
  CFStringAppend(v5, @"");
  *((void *)this + 1nlp::CFScopedPtr<__CFString const*>::reset(this + 1, 0) = CFCharacterSetCreateWithCharactersInString(0, v5);
  CFRelease(v5);
  CFMutableStringRef v6 = CFStringCreateMutable(0, 0);
  CFStringAppend(v6, @"");
  CFStringAppend(v6, @"");
  CFStringAppend(v6, @"");
  CFStringAppend(v6, @"");
  CFStringAppend(v6, @"");
  *((void *)this + 11) = CFCharacterSetCreateWithCharactersInString(0, v6);
  CFRelease(v6);
  CFMutableStringRef v7 = CFStringCreateMutable(0, 0);
  CFStringAppend(v7, @"");
  CFStringAppend(v7, @"");
  CFStringAppend(v7, @"");
  CFStringAppend(v7, @"");
  CFStringAppend(v7, @"");
  *((void *)this + 12) = CFCharacterSetCreateWithCharactersInString(0, v7);
  CFRelease(v7);
  CFMutableStringRef v8 = CFStringCreateMutable(0, 0);
  CFStringAppend(v8, @"");
  CFStringAppend(v8, @"");
  CFStringAppend(v8, @"");
  CFStringAppend(v8, @"");
  CFStringAppend(v8, @"");
  CFStringAppend(v8, @"");
  CFStringAppend(v8, @"");
  CFStringAppend(v8, @"");
  CFStringAppend(v8, @"");
  CFStringAppend(v8, @"");
  CFStringAppend(v8, @"");
  *((void *)this + 13) = CFCharacterSetCreateWithCharactersInString(0, v8);
  CFRelease(v8);
  CFMutableStringRef v9 = CFStringCreateMutable(0, 0);
  CFStringAppend(v9, @"");
  CFStringAppend(v9, @"");
  CFStringAppend(v9, @"");
  CFStringAppend(v9, @"");
  CFStringAppend(v9, @"");
  CFStringAppend(v9, @"");
  CFStringAppend(v9, @"");
  CFStringAppend(v9, @"");
  *((void *)this + 14) = CFCharacterSetCreateWithCharactersInString(0, v9);
  CFRelease(v9);
  CFMutableStringRef v10 = CFStringCreateMutable(0, 0);
  CFStringAppend(v10, @"");
  CFStringAppend(v10, @"");
  CFStringAppend(v10, @"");
  CFStringAppend(v10, @"");
  CFStringAppend(v10, @"");
  CFStringAppend(v10, @"");
  CFStringAppend(v10, @"");
  CFStringAppend(v10, @"");
  CFStringAppend(v10, @"");
  CFStringAppend(v10, @"");
  CFStringAppend(v10, @"");
  CFStringAppend(v10, @"");
  CFStringAppend(v10, @"");
  *((void *)this + 15) = CFCharacterSetCreateWithCharactersInString(0, v10);
  CFRelease(v10);
  CFMutableStringRef v11 = CFStringCreateMutable(0, 0);
  CFStringAppend(v11, @"");
  CFStringAppend(v11, @"");
  CFStringAppend(v11, @"");
  CFStringAppend(v11, @"");
  CFStringAppend(v11, @"");
  CFStringAppend(v11, @"");
  CFStringAppend(v11, @"");
  CFStringAppend(v11, @"");
  CFStringAppend(v11, @"");
  CFStringAppend(v11, @"");
  CFStringAppend(v11, @"");
  CFCharacterSetRef v12 = CFCharacterSetCreateWithCharactersInString(0, v11);
  CFRelease(v11);
  MutableCFStringRef Copy = CFCharacterSetCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *((CFCharacterSetRef *)this + 15));
  CFCharacterSetUnion(MutableCopy, *((CFCharacterSetRef *)this + 8));
  CFCharacterSetUnion(MutableCopy, *((CFCharacterSetRef *)this + 7));
  CFCharacterSetUnion(MutableCopy, v12);
  CFRelease(v12);
  *((void *)this + 16) = CFCharacterSetCreateInvertedSet(0, MutableCopy);
  CFRelease(MutableCopy);
}

void sub_1A43E5A38(_Unwind_Exception *a1)
{
  NLAbstractOrthographyConvertor::~NLAbstractOrthographyConvertor(v1);
  _Unwind_Resume(a1);
}

void NLDevanagariOrthographyChecker::~NLDevanagariOrthographyChecker(CFTypeRef *this)
{
  *this = &unk_1EF7CDB98;
  CFRelease(this[7]);
  CFRelease(this[8]);
  CFRelease(this[9]);
  CFRelease(this[10]);
  CFRelease(this[11]);
  CFRelease(this[12]);
  CFRelease(this[13]);
  CFRelease(this[14]);
  CFRelease(this[15]);
  CFRelease(this[16]);

  NLAbstractOrthographyConvertor::~NLAbstractOrthographyConvertor((NLAbstractOrthographyConvertor *)this);
}

{
  uint64_t vars8;

  NLDevanagariOrthographyChecker::~NLDevanagariOrthographyChecker(this);

  JUMPOUT(0x1A625B130);
}

BOOL NLDevanagariOrthographyChecker::isVowelSign(NLDevanagariOrthographyChecker *this, const __CFString *a2)
{
  CFMutableStringRef Mutable = CFStringCreateMutable(0, 0);
  CFStringAppend(Mutable, @"");
  CFStringAppend(Mutable, @"");
  CFStringAppend(Mutable, @"");
  CFStringAppend(Mutable, @"");
  CFStringAppend(Mutable, @"");
  CFStringAppend(Mutable, @"");
  CFStringAppend(Mutable, @"");
  CFStringAppend(Mutable, @"");
  CFStringAppend(Mutable, @"");
  CFStringAppend(Mutable, @"");
  CFStringAppend(Mutable, @"");
  CFStringAppend(Mutable, @"");
  CFStringAppend(Mutable, @"");
  CFStringAppend(Mutable, @"");
  CFCharacterSetRef v4 = CFCharacterSetCreateWithCharactersInString(0, Mutable);
  CFCharacterSetRef InvertedSet = CFCharacterSetCreateInvertedSet(0, v4);
  CFRelease(Mutable);
  CFRelease(v4);
  v8.CFIndex length = CFStringGetLength(a2);
  v8.CFIndex location = 0;
  BOOL v6 = CFStringFindCharacterFromSet(a2, InvertedSet, v8, 0, 0) == 0;
  CFRelease(InvertedSet);
  return v6;
}

BOOL NLDevanagariOrthographyChecker::canCandrabinduFollowVowelSign(NLDevanagariOrthographyChecker *this, CFStringRef theString1)
{
  return CFEqual(theString1, @"")
      || CFEqual(theString1, @"")
      || CFEqual(theString1, @"");
}

BOOL NLDevanagariOrthographyChecker::canNuktaFollowLetter(NLDevanagariOrthographyChecker *this, const __CFString *a2)
{
  CFCharacterSetRef v3 = CFCharacterSetCreateWithCharactersInString(0, @"");
  CFCharacterSetRef InvertedSet = CFCharacterSetCreateInvertedSet(0, v3);
  CFRelease(@"");
  CFRelease(v3);
  v7.CFIndex length = CFStringGetLength(a2);
  v7.CFIndex location = 0;
  BOOL v5 = CFStringFindCharacterFromSet(a2, InvertedSet, v7, 0, 0) == 0;
  CFRelease(InvertedSet);
  return v5;
}

BOOL NLDevanagariOrthographyChecker::canViramaFollowLetter(CFStringRef *this, CFStringRef theString1)
{
  if (CFEqual(theString1, this[2])) {
    return 1;
  }
  CFCharacterSetRef v4 = (const __CFCharacterSet *)this[8];
  UniChar CharacterAtIndex = CFStringGetCharacterAtIndex(theString1, 0);
  return CFCharacterSetIsCharacterMember(v4, CharacterAtIndex) != 0;
}

CFMutableStringRef NLDevanagariOrthographyChecker::stringByCorrectingIllegalVowelLetters(NLDevanagariOrthographyChecker *this, const __CFString *a2)
{
  v14[0] = 0;
  v14[1] = 0;
  CFCharacterSetRef v12 = @"";
  std::string::size_type v13 = (uint64_t *)v14;
  std::string::size_type v15 = &v12;
  std::__tree<std::__value_type<__CFString const*,__CFString const*>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,__CFString const*>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,__CFString const*>>>::__emplace_unique_key_args<__CFString const*,std::piecewise_construct_t const&,std::tuple<__CFString const*&&>,std::tuple<>>(&v13, (unint64_t *)&v12, (uint64_t)&std::piecewise_construct, (uint64_t **)&v15)[5] = @"";
  CFCharacterSetRef v12 = @"";
  std::string::size_type v15 = &v12;
  std::__tree<std::__value_type<__CFString const*,__CFString const*>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,__CFString const*>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,__CFString const*>>>::__emplace_unique_key_args<__CFString const*,std::piecewise_construct_t const&,std::tuple<__CFString const*&&>,std::tuple<>>(&v13, (unint64_t *)&v12, (uint64_t)&std::piecewise_construct, (uint64_t **)&v15)[5] = @"";
  CFCharacterSetRef v12 = @"";
  std::string::size_type v15 = &v12;
  std::__tree<std::__value_type<__CFString const*,__CFString const*>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,__CFString const*>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,__CFString const*>>>::__emplace_unique_key_args<__CFString const*,std::piecewise_construct_t const&,std::tuple<__CFString const*&&>,std::tuple<>>(&v13, (unint64_t *)&v12, (uint64_t)&std::piecewise_construct, (uint64_t **)&v15)[5] = @"";
  CFCharacterSetRef v12 = @"";
  std::string::size_type v15 = &v12;
  std::__tree<std::__value_type<__CFString const*,__CFString const*>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,__CFString const*>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,__CFString const*>>>::__emplace_unique_key_args<__CFString const*,std::piecewise_construct_t const&,std::tuple<__CFString const*&&>,std::tuple<>>(&v13, (unint64_t *)&v12, (uint64_t)&std::piecewise_construct, (uint64_t **)&v15)[5] = @"";
  CFCharacterSetRef v12 = @"";
  std::string::size_type v15 = &v12;
  std::__tree<std::__value_type<__CFString const*,__CFString const*>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,__CFString const*>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,__CFString const*>>>::__emplace_unique_key_args<__CFString const*,std::piecewise_construct_t const&,std::tuple<__CFString const*&&>,std::tuple<>>(&v13, (unint64_t *)&v12, (uint64_t)&std::piecewise_construct, (uint64_t **)&v15)[5] = @"";
  CFCharacterSetRef v12 = @"";
  std::string::size_type v15 = &v12;
  std::__tree<std::__value_type<__CFString const*,__CFString const*>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,__CFString const*>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,__CFString const*>>>::__emplace_unique_key_args<__CFString const*,std::piecewise_construct_t const&,std::tuple<__CFString const*&&>,std::tuple<>>(&v13, (unint64_t *)&v12, (uint64_t)&std::piecewise_construct, (uint64_t **)&v15)[5] = @"";
  CFCharacterSetRef v12 = @"";
  std::string::size_type v15 = &v12;
  std::__tree<std::__value_type<__CFString const*,__CFString const*>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,__CFString const*>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,__CFString const*>>>::__emplace_unique_key_args<__CFString const*,std::piecewise_construct_t const&,std::tuple<__CFString const*&&>,std::tuple<>>(&v13, (unint64_t *)&v12, (uint64_t)&std::piecewise_construct, (uint64_t **)&v15)[5] = @"";
  CFCharacterSetRef v12 = @"";
  std::string::size_type v15 = &v12;
  std::__tree<std::__value_type<__CFString const*,__CFString const*>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,__CFString const*>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,__CFString const*>>>::__emplace_unique_key_args<__CFString const*,std::piecewise_construct_t const&,std::tuple<__CFString const*&&>,std::tuple<>>(&v13, (unint64_t *)&v12, (uint64_t)&std::piecewise_construct, (uint64_t **)&v15)[5] = @"";
  CFCharacterSetRef v12 = @"";
  std::string::size_type v15 = &v12;
  std::__tree<std::__value_type<__CFString const*,__CFString const*>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,__CFString const*>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,__CFString const*>>>::__emplace_unique_key_args<__CFString const*,std::piecewise_construct_t const&,std::tuple<__CFString const*&&>,std::tuple<>>(&v13, (unint64_t *)&v12, (uint64_t)&std::piecewise_construct, (uint64_t **)&v15)[5] = @"";
  CFCharacterSetRef v12 = @"";
  std::string::size_type v15 = &v12;
  std::__tree<std::__value_type<__CFString const*,__CFString const*>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,__CFString const*>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,__CFString const*>>>::__emplace_unique_key_args<__CFString const*,std::piecewise_construct_t const&,std::tuple<__CFString const*&&>,std::tuple<>>(&v13, (unint64_t *)&v12, (uint64_t)&std::piecewise_construct, (uint64_t **)&v15)[5] = @"";
  CFCharacterSetRef v12 = @"";
  std::string::size_type v15 = &v12;
  std::__tree<std::__value_type<__CFString const*,__CFString const*>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,__CFString const*>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,__CFString const*>>>::__emplace_unique_key_args<__CFString const*,std::piecewise_construct_t const&,std::tuple<__CFString const*&&>,std::tuple<>>(&v13, (unint64_t *)&v12, (uint64_t)&std::piecewise_construct, (uint64_t **)&v15)[5] = @"";
  CFCharacterSetRef v12 = @"";
  std::string::size_type v15 = &v12;
  std::__tree<std::__value_type<__CFString const*,__CFString const*>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,__CFString const*>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,__CFString const*>>>::__emplace_unique_key_args<__CFString const*,std::piecewise_construct_t const&,std::tuple<__CFString const*&&>,std::tuple<>>(&v13, (unint64_t *)&v12, (uint64_t)&std::piecewise_construct, (uint64_t **)&v15)[5] = @"";
  CFIndex Length = CFStringGetLength(a2);
  MutableCFStringRef Copy = CFStringCreateMutableCopy(0, Length, a2);
  BOOL v5 = v13;
  if (v13 != (uint64_t *)v14)
  {
    do
    {
      CFStringRef v6 = (const __CFString *)v5[5];
      CFRange v7 = CFStringFind(MutableCopy, (CFStringRef)v5[4], 0);
      if (v7.length >= 1) {
        CFStringReplace(MutableCopy, v7, v6);
      }
      CFRange v8 = (uint64_t *)v5[1];
      if (v8)
      {
        do
        {
          CFMutableStringRef v9 = v8;
          CFRange v8 = (uint64_t *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          CFMutableStringRef v9 = (uint64_t *)v5[2];
          BOOL v10 = *v9 == (void)v5;
          BOOL v5 = v9;
        }
        while (!v10);
      }
      BOOL v5 = v9;
    }
    while (v9 != (uint64_t *)v14);
  }
  std::__tree<std::__value_type<__CFString const*,__CFString const*>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,__CFString const*>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,__CFString const*>>>::destroy((uint64_t)&v13, v14[0]);
  return MutableCopy;
}

void sub_1A43E61B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

BOOL NLDevanagariOrthographyChecker::checkSpelling(NLDevanagariOrthographyChecker *this, CFStringRef theString, __CFString **a3, const __CFString **a4)
{
  uint64_t v81 = *MEMORY[0x1E4F143B8];
  CFIndex Length = CFStringGetLength(theString);
  CFRange result = (CFRange)xmmword_1A43F6B90;
  v82.CFIndex location = 0;
  v82.CFIndex length = Length;
  if (CFStringFindCharacterFromSet(theString, *((CFCharacterSetRef *)this + 7), v82, 0, &result))
  {
    CFIndex v9 = 0;
    CFIndex location = 0x7FFFFFFFFFFFFFFFLL;
    do
    {
      if (!result.location) {
        goto LABEL_51;
      }
      if (location != 0x7FFFFFFFFFFFFFFFLL && result.location == v9 + location)
      {
        v83.CFIndex location = location;
        v83.CFIndex length = v9;
        CFStringRef v11 = CFStringCreateWithSubstring(0, theString, v83);
        CFStringRef v12 = CFStringCreateWithSubstring(0, theString, result);
        if ((CFStringCompare(v11, *((CFStringRef *)this + 2), 0)
           || CFEqual(v12, *((CFStringRef *)this + 2)))
          && (CFStringCompare(v12, *((CFStringRef *)this + 5), 0)
           || !NLDevanagariOrthographyChecker::isVowelSign(0, v11))
          && (CFStringCompare(v12, *((CFStringRef *)this + 6), 0)
           || !NLDevanagariOrthographyChecker::canCandrabinduFollowVowelSign(0, v11))
          && (CFStringCompare(v12, *((CFStringRef *)this + 4), 0)
           || !NLDevanagariOrthographyChecker::isVowelSign(0, v11)))
        {
          if (v11) {
            CFRelease(v11);
          }
          if (v12) {
            CFRelease(v12);
          }
LABEL_51:
          BOOL v24 = 0;
          CFStringRef v25 = @"illegal diacritic placement";
          goto LABEL_131;
        }
        if (v11) {
          CFRelease(v11);
        }
        if (v12) {
          CFRelease(v12);
        }
      }
      CFIndex location = result.location;
      CFIndex v9 = result.length;
      v84.CFIndex location = result.length + result.location;
      v84.CFIndex length = Length - (result.length + result.location);
    }
    while (CFStringFindCharacterFromSet(theString, *((CFCharacterSetRef *)this + 7), v84, 0, &result));
  }
  CFRange result = (CFRange)xmmword_1A43F6B90;
  CFStringRef v13 = (const __CFString *)*((void *)this + 2);
  CFStringRef v14 = theString;
  v15.CFIndex location = 0;
  v15.CFIndex length = Length;
  while (CFStringFindWithOptions(v14, v13, v15, 0, &result))
  {
    if (!result.location) {
      goto LABEL_46;
    }
    v85.CFIndex location = result.location - 1;
    v85.CFIndex length = 1;
    char v16 = (__CFString *)CFStringCreateWithSubstring(0, theString, v85);
    if (!NLDevanagariOrthographyChecker::canNuktaFollowLetter((NLDevanagariOrthographyChecker *)v16, v16))
    {
      if (v16) {
        CFRelease(v16);
      }
LABEL_46:
      BOOL v24 = 0;
      CFStringRef v25 = @"illegal nukta placement";
      goto LABEL_131;
    }
    if (v16) {
      CFRelease(v16);
    }
    v15.CFIndex location = result.length + result.location;
    v15.CFIndex length = Length - (result.length + result.location);
    CFStringRef v13 = (const __CFString *)*((void *)this + 2);
    CFStringRef v14 = theString;
  }
  CFRange result = (CFRange)xmmword_1A43F6B90;
  CFStringRef v17 = (const __CFString *)*((void *)this + 3);
  CFStringRef v18 = theString;
  v19.CFIndex location = 0;
  v19.CFIndex length = Length;
  while (CFStringFindWithOptions(v18, v17, v19, 0, &result))
  {
    if (!result.location) {
      goto LABEL_56;
    }
    v86.CFIndex location = result.location - 1;
    v86.CFIndex length = 1;
    CFStringRef v20 = CFStringCreateWithSubstring(0, theString, v86);
    if (result.location + 1 >= Length)
    {
      CFStringRef v21 = 0;
      if (!NLDevanagariOrthographyChecker::canViramaFollowLetter((CFStringRef *)this, v20))
      {
LABEL_52:
        if (v20) {
          CFRelease(v20);
        }
        if (v21) {
          CFRelease(v21);
        }
LABEL_56:
        BOOL v24 = 0;
        CFStringRef v25 = @"illegal virama placement";
        goto LABEL_131;
      }
LABEL_37:
      char v22 = 1;
      if (!v20) {
        goto LABEL_39;
      }
LABEL_38:
      CFRelease(v20);
      goto LABEL_39;
    }
    v87.CFIndex length = 1;
    v87.CFIndex location = result.location + 1;
    CFStringRef v21 = CFStringCreateWithSubstring(0, theString, v87);
    if (!NLDevanagariOrthographyChecker::canViramaFollowLetter((CFStringRef *)this, v20)) {
      goto LABEL_52;
    }
    if (!v21) {
      goto LABEL_37;
    }
    if (!NLBengaliOrthographyChecker::canViramaPrecedeLetter(this, v21)) {
      goto LABEL_52;
    }
    char v22 = 0;
    if (v20) {
      goto LABEL_38;
    }
LABEL_39:
    if ((v22 & 1) == 0) {
      CFRelease(v21);
    }
    v19.CFIndex location = result.length + result.location;
    v19.CFIndex length = Length - (result.length + result.location);
    CFStringRef v17 = (const __CFString *)*((void *)this + 3);
    CFStringRef v18 = theString;
  }
  if (a3) {
    CFArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  }
  else {
    CFArrayRef Mutable = 0;
  }
  CFIndex v26 = CFStringGetLength(theString);
  v88.CFIndex location = 0;
  v88.CFIndex length = v26;
  uint64_t v72 = (const __CFString **)a3;
  CFArrayRef theArray = Mutable;
  CFStringRef v25 = 0;
  if (!CFStringFindCharacterFromSet(theString, *((CFCharacterSetRef *)this + 9), v88, 0, &range))
  {
    if (!Mutable) {
      goto LABEL_110;
    }
    char v27 = 1;
LABEL_100:
    if (CFArrayGetCount(Mutable) >= 1)
    {
      char v70 = v27;
      CFStringRef v71 = v25;
      theStringa = CFStringCreateMutableCopy(0, 0, theString);
      CFIndex Count = CFArrayGetCount(Mutable);
      if (Count >= 1)
      {
        unint64_t v40 = Count + 1;
        do
        {
          CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(Mutable, v40 - 2);
          CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, @"range.location");
          CFNumberRef v43 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, @"range.length");
          CFRange result = (CFRange)xmmword_1A43F6B80;
          CFNumberGetValue(Value, kCFNumberCFIndexType, &result);
          CFNumberGetValue(v43, kCFNumberCFIndexType, &result.length);
          CFStringRef v44 = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, @"replacement");
          v45.CFIndex location = result.location;
          if (result.location != -1)
          {
            v45.CFIndex length = result.length;
            if (result.length >= 1)
            {
              if (v44) {
                CFStringReplace(theStringa, v45, v44);
              }
            }
          }
          --v40;
          CFArrayRef Mutable = theArray;
        }
        while (v40 > 1);
      }
      *a3 = theStringa;
      CFStringRef v25 = v71;
      char v27 = v70;
    }
    CFRelease(Mutable);
    if (v27) {
      goto LABEL_110;
    }
LABEL_130:
    BOOL v24 = 0;
    goto LABEL_131;
  }
  char v27 = 1;
  while (2)
  {
    if (range.location + 2 >= v26 || CFStringGetCharacterAtIndex(theString, range.location + 1) != 2381) {
      goto LABEL_93;
    }
    int CharacterAtIndex = CFStringGetCharacterAtIndex(theString, range.location);
    UniChar v29 = CFStringGetCharacterAtIndex(theString, range.location + 2);
    if (CFCharacterSetIsCharacterMember(*((CFCharacterSetRef *)this + 14), v29)) {
      BOOL v30 = 1;
    }
    else {
      BOOL v30 = range.location + 3 < v26 && CFStringGetCharacterAtIndex(theString, range.location + 3) == 2364;
    }
    if (CharacterAtIndex > 2338)
    {
      if (CharacterAtIndex != 2339)
      {
        if (CharacterAtIndex == 2344
          && (CFCharacterSetIsCharacterMember(*((CFCharacterSetRef *)this + 10), v29)
           || CFCharacterSetIsCharacterMember(*((CFCharacterSetRef *)this + 11), v29)
           || CFCharacterSetIsCharacterMember(*((CFCharacterSetRef *)this + 12), v29))
          && (range.location < 1 || CFStringGetCharacterAtIndex(theString, range.location) != 2381))
        {
          if (Mutable)
          {
            CFRange result = (CFRange)xmmword_1E5B37398;
            std::string v80 = @"replacement";
            CFIndex valuePtr = range.location;
            uint64_t v76 = 2;
            CFNumberRef v32 = CFNumberCreate(0, kCFNumberCFIndexType, &valuePtr);
            CFNumberRef v33 = CFNumberCreate(0, kCFNumberCFIndexType, &v76);
            values[0] = v32;
            values[1] = v33;
            values[2] = @"";
            CFStringRef v34 = v25;
            uint64_t v35 = a4;
            CFDictionaryRef v36 = CFDictionaryCreate(0, (const void **)&result, (const void **)values, 3, MEMORY[0x1E4F1D048], MEMORY[0x1E4F1D540]);
            CFRelease(v32);
            CFRelease(v33);
            CFArrayAppendValue(theArray, v36);
            CFDictionaryRef v37 = v36;
            a4 = v35;
            CFStringRef v25 = v34;
            CFArrayRef Mutable = theArray;
            CFRelease(v37);
          }
          goto LABEL_89;
        }
        goto LABEL_79;
      }
      if (v30) {
        goto LABEL_89;
      }
      CFCharacterSetRef v31 = (const __CFCharacterSet *)*((void *)this + 13);
LABEL_85:
      if (((CFCharacterSetIsCharacterMember(v31, v29) != 0) & v27) == 0) {
        goto LABEL_89;
      }
LABEL_86:
      char v27 = 1;
      goto LABEL_93;
    }
    if (CharacterAtIndex == 2329)
    {
      if (v30) {
        goto LABEL_89;
      }
      CFCharacterSetRef v31 = (const __CFCharacterSet *)*((void *)this + 10);
      goto LABEL_85;
    }
    if (CharacterAtIndex != 2334)
    {
LABEL_79:
      if ((v27 & 1) == 0) {
        goto LABEL_89;
      }
      goto LABEL_86;
    }
    if (!v30)
    {
      CFCharacterSetRef v31 = (const __CFCharacterSet *)*((void *)this + 11);
      goto LABEL_85;
    }
LABEL_89:
    if (!v25)
    {
      v89.CFIndex location = range.location;
      v89.CFIndex length = 3;
      CFStringRef v38 = CFStringCreateWithSubstring(0, theString, v89);
      CFStringRef v25 = CFStringCreateWithFormat(0, 0, @"invalid nasal combination '%@'", v38);
      CFRelease(v38);
    }
    if (!Mutable) {
      goto LABEL_130;
    }
    char v27 = 0;
LABEL_93:
    if (v26 > range.location + 1)
    {
      v90.CFIndex location = range.location + 1;
      v90.CFIndex length = v26 - (range.location + 1);
      if (CFStringFindCharacterFromSet(theString, *((CFCharacterSetRef *)this + 9), v90, 0, &range)) {
        continue;
      }
    }
    break;
  }
  if (Mutable) {
    goto LABEL_100;
  }
  if ((v27 & 1) == 0) {
    goto LABEL_130;
  }
LABEL_110:
  CFCharacterSetRef Copy = CFCharacterSetCreateCopy(0, *((CFCharacterSetRef *)this + 15));
  CFCharacterSetRef v47 = CFCharacterSetCreateCopy(0, *((CFCharacterSetRef *)this + 7));
  CFCharacterSetRef v48 = CFCharacterSetCreateWithCharactersInString(0, @"");
  CFIndex v49 = CFStringGetLength(theString);
  v91.CFIndex location = 0;
  v91.CFIndex length = v49;
  if (CFStringFindCharacterFromSet(theString, Copy, v91, 0, &result))
  {
    CFStringRef v50 = v25;
    CFAllocatorRef v51 = a4;
    while (1)
    {
      if (result.location + 1 < v49)
      {
        UniChar v52 = CFStringGetCharacterAtIndex(theString, result.location + 1);
        if (CFCharacterSetIsCharacterMember(v47, v52))
        {
          IsCharacterMember = (NLDevanagariOrthographyChecker *)CFCharacterSetIsCharacterMember(v48, v52);
          if (!IsCharacterMember) {
            break;
          }
        }
      }
      v92.CFIndex location = result.length + result.location;
      v92.CFIndex length = v49 - (result.length + result.location);
      if (!CFStringFindCharacterFromSet(theString, Copy, v92, 0, &result))
      {
        int v54 = 1;
        a4 = v51;
        CFStringRef v25 = v50;
        goto LABEL_121;
      }
    }
    int v54 = 0;
    if (v72) {
      *uint64_t v72 = NLDevanagariOrthographyChecker::stringByCorrectingIllegalVowelLetters(IsCharacterMember, theString);
    }
    a4 = v51;
    CFStringRef v25 = @"illegal diacritic after vowel letter";
  }
  else
  {
    int v54 = 1;
  }
LABEL_121:
  CFRelease(Copy);
  CFRelease(v47);
  CFRelease(v48);
  if (!v54) {
    goto LABEL_130;
  }
  double v55 = (__CFString *)v25;
  CFIndex v56 = CFStringGetLength(theString);
  MutableCFCharacterSetRef Copy = CFStringCreateMutableCopy(0, v56, theString);
  CFRange v58 = CFStringFind(MutableCopy, @"", 0);
  if (v58.length >= 1) {
    CFStringReplace(MutableCopy, v58, &stru_1EF7CF078);
  }
  CFComparisonResult v59 = CFStringCompare(MutableCopy, theString, 0);
  CFComparisonResult v60 = v59;
  if (v72 && v59) {
    *uint64_t v72 = MutableCopy;
  }
  if (!MutableCopy)
  {
    if (v59 == kCFCompareEqualTo) {
      goto LABEL_139;
    }
LABEL_129:
    BOOL v24 = 0;
    CFStringRef v25 = @"invalid: ZWNJ present";
    goto LABEL_131;
  }
  CFRelease(MutableCopy);
  if (v60) {
    goto LABEL_129;
  }
LABEL_139:
  CFStringRef v62 = (const __CFString *)*((void *)this + 1);
  v93.CFIndex length = CFStringGetLength(theString);
  v93.CFIndex location = 0;
  if (!CFStringFindWithOptions(theString, v62, v93, 0, &result))
  {
LABEL_146:
    CFStringRef v25 = v55;
    v95.CFIndex length = CFStringGetLength(theString);
    v95.CFIndex location = 0;
    int CharacterFromSet = CFStringFindCharacterFromSet(theString, *((CFCharacterSetRef *)this + 16), v95, 0, &result);
    BOOL v24 = CharacterFromSet == 0;
    if (CharacterFromSet)
    {
      CFStringRef v66 = CFStringCreateWithSubstring(0, theString, result);
      CFStringRef v25 = CFStringCreateWithFormat(0, 0, @"invalid letter '%@'", v66);
      CFRelease(v66);
    }
    goto LABEL_131;
  }
  if (!result.location)
  {
    if (!v72)
    {
      BOOL v24 = 0;
      CFStringRef v25 = @"invalid sequence with ZWJ";
      goto LABEL_131;
    }
    double v55 = @"invalid sequence with ZWJ";
LABEL_150:
    CFIndex v67 = CFStringGetLength(theString);
    CFMutableStringRef v68 = CFStringCreateMutableCopy(0, v67, theString);
    CFRange v69 = CFStringFind(v68, (CFStringRef)*((void *)this + 1), 0);
    if (v69.length >= 1) {
      CFStringReplace(v68, v69, &stru_1EF7CF078);
    }
    BOOL v24 = 0;
    *uint64_t v72 = v68;
    goto LABEL_153;
  }
  v94.CFIndex length = result.location - 1;
  v94.CFIndex location = 0;
  CFStringRef v63 = CFStringCreateWithSubstring(0, theString, v94);
  int HasSuffix = CFStringHasSuffix(v63, @"");
  if (!HasSuffix) {
    double v55 = @"invalid sequence with ZWJ";
  }
  CFRelease(v63);
  if (v72 && !HasSuffix) {
    goto LABEL_150;
  }
  if (HasSuffix) {
    goto LABEL_146;
  }
  BOOL v24 = 0;
LABEL_153:
  CFStringRef v25 = v55;
LABEL_131:
  if (!a4 || v24)
  {
    if (!a4 && v25) {
      CFRelease(v25);
    }
  }
  else
  {
    *a4 = v25;
  }
  return v24;
}

void *NLMessageConversation::NLMessageConversation(void *a1, void **a2, uint64_t a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  std::vector<std::shared_ptr<NLMessageConversationTurn>>::__init_with_size[abi:ne180100]<std::shared_ptr<NLMessageConversationTurn>*,std::shared_ptr<NLMessageConversationTurn>*>(a1, *a2, a2[1], ((char *)a2[1] - (char *)*a2) >> 4);
  std::unordered_map<std::string,std::string>::unordered_map((uint64_t)(a1 + 3), a3);
  return a1;
}

void sub_1A43E6D78(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::vector<std::shared_ptr<NL::ParseAttribute>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

void *NLMessageConversation::getConversationTurns@<X0>(NLMessageConversation *this@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return std::vector<std::shared_ptr<NLMessageConversationTurn>>::__init_with_size[abi:ne180100]<std::shared_ptr<NLMessageConversationTurn>*,std::shared_ptr<NLMessageConversationTurn>*>(a2, *(void **)this, *((void **)this + 1), (uint64_t)(*((void *)this + 1) - *(void *)this) >> 4);
}

void NLMessageConversation::updateMetadata(uint64_t a1, uint64_t a2)
{
  CFCharacterSetRef v3 = (void *)(a1 + 24);
  if (v3 != (void *)a2)
  {
    *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 32);
    std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *> *>>(v3, *(uint64_t **)(a2 + 16), 0);
  }
}

uint64_t NL::CFFinalize(uint64_t (***this)(void), const void *a2)
{
  return (*this[2])();
}

void NLMessageIntentRecognizer::NLMessageIntentRecognizer(NLMessageIntentRecognizer *this, CFDictionaryRef theDict)
{
  *((void *)this + 6) = 0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  *((_DWORD *)this + 14) = 1065353216;
  *((_OWORD *)this + 4) = 0u;
  CFCharacterSetRef v4 = (char *)this + 64;
  *((_OWORD *)this + 5) = 0u;
  *((_DWORD *)this + 24) = 1065353216;
  *(_OWORD *)((char *)this + 104) = 0u;
  BOOL v5 = (char *)this + 104;
  *(_OWORD *)((char *)this + 12nlp::CFScopedPtr<__CFString const*>::reset(this + 1, 0) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_DWORD *)this + 34) = 1065353216;
  *((_OWORD *)this + 1nlp::CFScopedPtr<__CFString const*>::reset(this + 1, 0) = 0u;
  *((_DWORD *)this + 44) = 1065353216;
  *(_OWORD *)((char *)this + 184) = 0u;
  CFStringRef v6 = (char *)this + 184;
  CFRange v7 = (char *)this + 208;
  *(_OWORD *)((char *)this + 20nlp::CFScopedPtr<__CFString const*>::reset(this + 1, 0) = 0u;
  *(_OWORD *)((char *)this + 216) = 0u;
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, kNLMessageIntentRecognizerLocaleKey);
  CFStringRef v9 = (const __CFString *)CFDictionaryGetValue(theDict, kNLMessageIntentRecognizerCustomModelPathKey);
  getUTF8StringFromCFString(Value, __p);
  if (*((char *)this + 231) < 0) {
    operator delete(*(void **)v7);
  }
  *(_OWORD *)CFRange v7 = *(_OWORD *)__p;
  *((void *)v7 + 2) = v12;
  if (v9)
  {
    getUTF8StringFromCFString(v9, __p);
    if (*((char *)this + 207) < 0) {
      operator delete(*(void **)v6);
    }
    *(_OWORD *)CFStringRef v6 = *(_OWORD *)__p;
    *((void *)v6 + 2) = v12;
  }
  else
  {
    MEMORY[0x1A625AE00](v6, "");
  }
  if (*((char *)this + 231) < 0) {
    std::string::__init_copy_ctor_external(&v10, *((const std::string::value_type **)this + 26), *((void *)this + 27));
  }
  else {
    std::string v10 = *(std::string *)v7;
  }
  NLMessageIntentDomainDetector::NLMessageIntentDomainDetector(__p, &v10);
  if (*((char *)this + 23) < 0) {
    operator delete(*(void **)this);
  }
  *(_OWORD *)this = *(_OWORD *)__p;
  *((void *)this + 2) = v12;
  HIBYTE(v12) = 0;
  LOBYTE(__p[0]) = 0;
  std::__hash_table<std::__hash_value_type<std::string,std::basic_regex<char,std::regex_traits<char>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::basic_regex<char,std::regex_traits<char>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::basic_regex<char,std::regex_traits<char>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::basic_regex<char,std::regex_traits<char>>>>>::__move_assign((uint64_t)this + 24, v13);
  std::__hash_table<std::__hash_value_type<std::string,std::basic_regex<char,std::regex_traits<char>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::basic_regex<char,std::regex_traits<char>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::basic_regex<char,std::regex_traits<char>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::basic_regex<char,std::regex_traits<char>>>>>::__move_assign((uint64_t)v4, v14);
  std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<std::string>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<std::string>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<std::string>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<std::string>>>>>::__move_assign((uint64_t)v5, v15);
  std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<std::string>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<std::string>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<std::string>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<std::string,std::vector<std::string>>>>>::~__hash_table((uint64_t)v15);
  std::__hash_table<std::__hash_value_type<std::string,std::basic_regex<char,std::regex_traits<char>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::basic_regex<char,std::regex_traits<char>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::basic_regex<char,std::regex_traits<char>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::basic_regex<char,std::regex_traits<char>>>>>::~__hash_table((uint64_t)v14);
  std::__hash_table<std::__hash_value_type<std::string,std::basic_regex<char,std::regex_traits<char>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::basic_regex<char,std::regex_traits<char>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::basic_regex<char,std::regex_traits<char>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::basic_regex<char,std::regex_traits<char>>>>>::~__hash_table((uint64_t)v13);
  if (SHIBYTE(v12) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
}

void sub_1A43E7014(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (*(char *)(v14 + 231) < 0) {
    operator delete(*v17);
  }
  if (*(char *)(v14 + 207) < 0) {
    operator delete(*v16);
  }
  std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>>>::~__hash_table(v15);
  NLMessageIntentDomainDetector::~NLMessageIntentDomainDetector((void **)v14);
  _Unwind_Resume(a1);
}

void NLMessageIntentDomainDetector::~NLMessageIntentDomainDetector(void **this)
{
  if (*((char *)this + 23) < 0) {
    operator delete(*this);
  }
}

void *NLMessageIntentRecognizer::getIntentTypeString@<X0>(int a1@<W1>, void *a2@<X8>)
{
  if ((a1 - 1) > 6) {
    CFAllocatorRef v2 = "none";
  }
  else {
    CFAllocatorRef v2 = off_1E5B373B0[a1 - 1];
  }
  return std::string::basic_string[abi:ne180100]<0>(a2, v2);
}

void NLMessageIntentRecognizer::getCandidateIntentTypes(std::string *a1@<X0>, NLMessageConversation **a2@<X1>, char **a3@<X8>)
{
  NLMessageConversation::getConversationTurns(*a2, &v30);
  if ((unint64_t)(v31 - v30) >= 0x11)
  {
    int v23 = (void **)descending_timestamp;
    unint64_t v6 = 126 - 2 * __clz((v31 - v30) >> 4);
    if (v31 == v30) {
      uint64_t v7 = 0;
    }
    else {
      uint64_t v7 = v6;
    }
    std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(std::shared_ptr<NLMessageConversationTurn> const&,std::shared_ptr<NLMessageConversationTurn> const&),std::shared_ptr<NLMessageConversationTurn>*,false>((uint64_t *)v30, (long long *)v31, (uint64_t (**)(uint64_t *, uint64_t *))&v23, v7, 1);
  }
  NLTransliterationCandidate::getTransliteratedWord(*a2);
  NLMessageIntentRecognizer::extractMessageAndContext((uint64_t)&v30, &v27);
  NLMessageIntentDomainDetector::getCandidateIntentTypes(a1, (uint64_t)&v27, (const void **)&__p, (uint64_t *)&v25);
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  CFRange v8 = v25;
  for (CFIndex i = v26; v8 != i; v8 += 12)
  {
    LODWORD(v23) = *v8;
    std::unordered_map<std::string,std::string>::unordered_map((uint64_t)v24, (uint64_t)(v8 + 2));
    MessageIntentCFStringRef Type = NLMessageIntentCandidate::getMessageIntentType((NLMessageIntentCandidate *)&v23);
    int v11 = MessageIntentType;
    CFStringRef v13 = a3[1];
    unint64_t v12 = (unint64_t)a3[2];
    if ((unint64_t)v13 >= v12)
    {
      uint64_t v15 = *a3;
      uint64_t v16 = (v13 - *a3) >> 2;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 62) {
        std::vector<NLExtendedString>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v18 = v12 - (void)v15;
      if (v18 >> 1 > v17) {
        unint64_t v17 = v18 >> 1;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v19 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        CFStringRef v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<char32_t>>((uint64_t)(a3 + 2), v19);
        uint64_t v15 = *a3;
        CFStringRef v13 = a3[1];
      }
      else
      {
        CFStringRef v20 = 0;
      }
      CFStringRef v21 = &v20[4 * v16];
      *(_DWORD *)CFStringRef v21 = v11;
      uint64_t v14 = v21 + 4;
      while (v13 != v15)
      {
        int v22 = *((_DWORD *)v13 - 1);
        v13 -= 4;
        *((_DWORD *)v21 - 1) = v22;
        v21 -= 4;
      }
      *a3 = v21;
      a3[1] = v14;
      a3[2] = &v20[4 * v19];
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      *(_DWORD *)CFStringRef v13 = MessageIntentType;
      uint64_t v14 = v13 + 4;
    }
    a3[1] = v14;
    std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)v24);
  }
  int v23 = (void **)&v25;
  std::vector<NLMessageIntentTypeWithMetadata>::__destroy_vector::operator()[abi:ne180100](&v23);
  if (v29 < 0) {
    operator delete(__p);
  }
  if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v27.__r_.__value_.__l.__data_);
  }
  v27.__r_.__value_.__r.__words[0] = (std::string::size_type)&v30;
  std::vector<std::shared_ptr<NL::ParseAttribute>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v27);
}

void sub_1A43E730C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void **a18)
{
  a18 = (void **)(v18 - 104);
  std::vector<std::shared_ptr<NL::ParseAttribute>>::__destroy_vector::operator()[abi:ne180100](&a18);
  _Unwind_Resume(a1);
}

BOOL descending_timestamp(NLMessageConversationTurn **a1, NLMessageConversationTurn **a2)
{
  uint64_t Timestamp = NLMessageConversationTurn::getTimestamp(*a1);
  return Timestamp > NLMessageConversationTurn::getTimestamp(*a2);
}

void NLMessageIntentRecognizer::extractMessageAndContext(uint64_t a1@<X1>, std::string *a2@<X8>)
{
  std::string::basic_string[abi:ne180100]<0>(&v11, "");
  std::string::basic_string[abi:ne180100]<0>(&__p, "");
  if (*(void *)a1 == *(void *)(a1 + 8))
  {
    MEMORY[0x1A625AE00](&v11, "");
    MEMORY[0x1A625AE00](&__p, "");
  }
  else
  {
    MEMORY[0x1A625AE00](&v11, "");
    NLResult::getLemmaID(**(NLResult ***)a1, &v9);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    std::string __p = v9;
    uint64_t v4 = *(void *)(a1 + 8) - *(void *)a1;
    uint64_t v5 = (v4 >> 4) + 1;
    for (unint64_t i = (v4 & 0xFFFFFFFFFFFFFFF0) - 16; --v5 > 1; i -= 16)
    {
      NLResult::getLemmaID(*(NLResult **)(*(void *)a1 + i), &v9);
      if ((v9.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v7 = &v9;
      }
      else {
        uint64_t v7 = (std::string *)v9.__r_.__value_.__r.__words[0];
      }
      if ((v9.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(v9.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = v9.__r_.__value_.__l.__size_;
      }
      std::string::append(&v11, (const std::string::value_type *)v7, size);
      if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v9.__r_.__value_.__l.__data_);
      }
      std::string::append(&v11, " ");
    }
  }
  std::pair<std::string,std::string>::pair[abi:ne180100]<std::string&,std::string&,0>(a2, (long long *)&__p, (long long *)&v11);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v11.__r_.__value_.__l.__data_);
  }
}

void sub_1A43E7534(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NLMessageIntentRecognizer::getCandidateForIntentType@<X0>(uint64_t a1@<X0>, NLTransliterationCandidate **a2@<X1>, int a3@<W2>, void *a4@<X8>)
{
  memset(v14, 0, sizeof(v14));
  int v15 = 1065353216;
  std::unordered_map<std::string,std::string>::unordered_map((uint64_t)v11, (uint64_t)v14);
  NLMessageIntentTypeWithMetadata::NLMessageIntentTypeWithMetadata(&v12, a3, (uint64_t)v11);
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)v11);
  int v9 = v12;
  std::unordered_map<std::string,std::string>::unordered_map((uint64_t)v10, (uint64_t)v13);
  NLMessageIntentRecognizer::getCandidateForIntentType(a1, a2, (NLMessageIntentCandidate *)&v9, a4);
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)v10);
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)v13);
  return std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)v14);
}

void sub_1A43E7660(_Unwind_Exception *a1)
{
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table(v2);
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table(v1);
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table(v3 - 112);
  _Unwind_Resume(a1);
}

void NLMessageIntentRecognizer::getCandidateForIntentType(uint64_t a1@<X0>, NLTransliterationCandidate **a2@<X1>, NLMessageIntentCandidate *a3@<X2>, void *a4@<X8>)
{
  NLTransliterationCandidate::getTransliteratedWord(*a2);
  NLMessageConversation::getConversationTurns(*a2, &v36);
  if ((unint64_t)(v37 - v36) >= 0x11)
  {
    *(void *)&long long v39 = descending_timestamp;
    unint64_t v8 = 126 - 2 * __clz((v37 - v36) >> 4);
    if (v37 == v36) {
      uint64_t v9 = 0;
    }
    else {
      uint64_t v9 = v8;
    }
    std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(std::shared_ptr<NLMessageConversationTurn> const&,std::shared_ptr<NLMessageConversationTurn> const&),std::shared_ptr<NLMessageConversationTurn>*,false>((uint64_t *)v36, (long long *)v37, (uint64_t (**)(uint64_t *, uint64_t *))&v39, v9, 1);
  }
  NLMessageIntentRecognizer::extractMessageAndContext((uint64_t)&v36, &v34);
  if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&v33, v35.__r_.__value_.__l.__data_, v35.__r_.__value_.__l.__size_);
  }
  else {
    std::string v33 = v35;
  }
  if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&v32, v34.__r_.__value_.__l.__data_, v34.__r_.__value_.__l.__size_);
  }
  else {
    std::string v32 = v34;
  }
  if ((v33.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    size_t size = HIBYTE(v33.__r_.__value_.__r.__words[2]);
  }
  else {
    size_t size = v33.__r_.__value_.__l.__size_;
  }
  std::string v11 = &v39;
  std::string::basic_string[abi:ne180100]((uint64_t)&v39, size + 1);
  if (SBYTE7(v40) < 0) {
    std::string v11 = (long long *)v39;
  }
  if (size)
  {
    if ((v33.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int v12 = &v33;
    }
    else {
      int v12 = (std::string *)v33.__r_.__value_.__r.__words[0];
    }
    memmove(v11, v12, size);
  }
  *(_WORD *)((char *)v11 + size) = 32;
  if ((v32.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    CFStringRef v13 = &v32;
  }
  else {
    CFStringRef v13 = (std::string *)v32.__r_.__value_.__r.__words[0];
  }
  if ((v32.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v14 = HIBYTE(v32.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v14 = v32.__r_.__value_.__l.__size_;
  }
  int v15 = std::string::append((std::string *)&v39, (const std::string::value_type *)v13, v14);
  uint64_t v16 = (void *)v15->__r_.__value_.__r.__words[0];
  int v17 = SHIBYTE(v15->__r_.__value_.__r.__words[2]);
  v15->__r_.__value_.__r.__words[0] = 0;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  if (SBYTE7(v40) < 0) {
    operator delete((void *)v39);
  }
  MessageIntentCFStringRef Type = NLMessageIntentCandidate::getMessageIntentType(a3);
  NLMessageIntentRecognizer::getIntentTypeString(MessageIntentType, v30);
  if (!std::__hash_table<std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<NLExtendedString>>>>::find<std::string>((void *)(a1 + 144), (unsigned __int8 *)v30))
  {
    long long v39 = 0u;
    long long v40 = 0u;
    LODWORD(v41) = 1065353216;
    __p[0] = v30;
    unint64_t v19 = std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1 + 144, (unsigned __int8 *)v30, (uint64_t)&std::piecewise_construct, (long long **)__p);
    std::__hash_table<std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>>::__move_assign((uint64_t)(v19 + 40), (uint64_t *)&v39);
    std::__hash_table<std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>>::~__hash_table((uint64_t)&v39);
  }
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  if (MessageIntentType == 1)
  {
    NLMessageIntentCandidate::getAttributes(a3, (uint64_t)&v39);
    getUTF8StringFromCFString(kNLMessageIntentAttributeKeywordsKey, __p);
    v28[0] = (long long *)__p;
    CFStringRef v20 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)&v39, (unsigned __int8 *)__p, (uint64_t)&std::piecewise_construct, v28);
    if ((char)v20[63] < 0) {
      std::string::__init_copy_ctor_external(&__str, *((const std::string::value_type **)v20 + 5), *((void *)v20 + 6));
    }
    else {
      std::string __str = *(std::string *)(v20 + 40);
    }
    if (v27 < 0) {
      operator delete(__p[0]);
    }
    std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)&v39);
    *(void *)&long long v39 = v30;
    CFStringRef v21 = std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1 + 144, (unsigned __int8 *)v30, (uint64_t)&std::piecewise_construct, (long long **)&v39);
    int v22 = std::__hash_table<std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<NLExtendedString>>>>::find<std::string>((void *)v21 + 5, (unsigned __int8 *)(a1 + 208));
    *(void *)&long long v39 = v30;
    std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1 + 144, (unsigned __int8 *)v30, (uint64_t)&std::piecewise_construct, (long long **)&v39);
    if (!v22)
    {
      if (*(char *)(a1 + 207) < 0)
      {
        if (*(void *)(a1 + 192)) {
LABEL_41:
        }
          operator new();
      }
      else if (*(unsigned char *)(a1 + 207))
      {
        goto LABEL_41;
      }
      operator new();
    }
    *(void *)&long long v39 = v30;
    int v23 = std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1 + 144, (unsigned __int8 *)v30, (uint64_t)&std::piecewise_construct, (long long **)&v39);
    *(void *)&long long v39 = a1 + 208;
    BOOL v24 = std::__hash_table<std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(v23 + 40), (unsigned __int8 *)(a1 + 208), (uint64_t)&std::piecewise_construct, (long long **)&v39);
    (*(void (**)(long long **__return_ptr))(**((void **)v24 + 5) + 16))(v28);
    if (v28[1] != v28[0])
    {
      NLMessageIntentCandidate::getAttributes(*(NLMessageIntentCandidate **)v28[0], (uint64_t)__p);
      getUTF8StringFromCFString(kNLMessageIntentAttributeKeywordsKey, &v39);
      CFStringRef v38 = &v39;
      CFStringRef v25 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (unsigned __int8 *)&v39, (uint64_t)&std::piecewise_construct, &v38);
      std::string::operator=((std::string *)(v25 + 40), &__str);
      if (SBYTE7(v40) < 0) {
        operator delete((void *)v39);
      }
      operator new();
    }
    *(void *)&long long v39 = v28;
    std::vector<std::unique_ptr<NLMessageIntentCandidate>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v39);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
  }
  if (v31 < 0)
  {
    operator delete(v30[0]);
    if ((v17 & 0x80000000) == 0) {
      goto LABEL_52;
    }
  }
  else if ((v17 & 0x80000000) == 0)
  {
    goto LABEL_52;
  }
  operator delete(v16);
LABEL_52:
  if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v32.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v33.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v35.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v34.__r_.__value_.__l.__data_);
  }
  v34.__r_.__value_.__r.__words[0] = (std::string::size_type)&v36;
  std::vector<std::shared_ptr<NL::ParseAttribute>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v34);
}

void sub_1A43E7DC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, int a11, int a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,void *a41,uint64_t a42,int a43,__int16 a44,char a45,char a46,uint64_t a47,void *a48,uint64_t a49,int a50,__int16 a51,char a52,char a53,uint64_t a54)
{
  MEMORY[0x1A625B130](v54, 0x10F3C400A978A76);
  if (a34 < 0) {
    operator delete(__p);
  }
  std::vector<std::unique_ptr<NLMessageIntentCandidate>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a18);
  if (a40 < 0) {
    operator delete(a35);
  }
  if (a12 < 0) {
    operator delete(a10);
  }
  if (a46 < 0) {
    operator delete(a41);
  }
  if (a53 < 0) {
    operator delete(a48);
  }
  std::pair<std::string,std::string>::~pair((uint64_t)&a54);
  a54 = v55 - 184;
  std::vector<std::shared_ptr<NL::ParseAttribute>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a54);
  _Unwind_Resume(a1);
}

void NLMessageIntentRecognizer::getCandidates(std::string *a1@<X0>, NLMessageConversation **a2@<X1>, uint64_t *a3@<X8>)
{
  NLMessageConversation::getConversationTurns(*a2, &v30);
  if ((unint64_t)(v31 - v30) >= 0x11)
  {
    int v22 = (void **)descending_timestamp;
    unint64_t v4 = 126 - 2 * __clz((v31 - v30) >> 4);
    if (v31 == v30) {
      uint64_t v5 = 0;
    }
    else {
      uint64_t v5 = v4;
    }
    std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(std::shared_ptr<NLMessageConversationTurn> const&,std::shared_ptr<NLMessageConversationTurn> const&),std::shared_ptr<NLMessageConversationTurn>*,false>((uint64_t *)v30, (long long *)v31, (uint64_t (**)(uint64_t *, uint64_t *))&v22, v5, 1);
  }
  NLTransliterationCandidate::getTransliteratedWord(*a2);
  NLMessageIntentRecognizer::extractMessageAndContext((uint64_t)&v30, &v28);
  if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&v27, v29.__r_.__value_.__l.__data_, v29.__r_.__value_.__l.__size_);
  }
  else {
    std::string v27 = v29;
  }
  if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&v26, v28.__r_.__value_.__l.__data_, v28.__r_.__value_.__l.__size_);
  }
  else {
    std::string v26 = v28;
  }
  NLMessageIntentDomainDetector::getCandidateIntentTypes(a1, (uint64_t)&v26, (const void **)&v27.__r_.__value_.__l.__data_, (uint64_t *)&v24);
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  unint64_t v6 = v24;
  CFStringRef v13 = v25;
  if (v24 == v25)
  {
    uint64_t v9 = 0;
    std::string v10 = 0;
  }
  else
  {
    do
    {
      LODWORD(v22) = *v6;
      std::unordered_map<std::string,std::string>::unordered_map((uint64_t)v23, (uint64_t)(v6 + 2));
      int v19 = (int)v22;
      std::unordered_map<std::string,std::string>::unordered_map((uint64_t)v20, (uint64_t)v23);
      NLMessageIntentRecognizer::getCandidateForIntentType((uint64_t)a1, a2, (NLMessageIntentCandidate *)&v19, v21);
      std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)v20);
      NLMessageIntentCandidate::getAttributes((NLMessageIntentCandidate *)&v22, (uint64_t)v33);
      getUTF8StringFromCFString(kNLMessageIntentAttributeKeywordsKey, __p);
      std::string v32 = __p;
      uint64_t v7 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)v33, (unsigned __int8 *)__p, (uint64_t)&std::piecewise_construct, (long long **)&v32);
      if ((char)v7[63] < 0) {
        std::string::__init_copy_ctor_external(&__str, *((const std::string::value_type **)v7 + 5), *((void *)v7 + 6));
      }
      else {
        std::string __str = *(std::string *)(v7 + 40);
      }
      if (v17 < 0) {
        operator delete(__p[0]);
      }
      std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)v33);
      if (v21[1] != v21[0])
      {
        NLMessageIntentCandidate::getAttributes(*(NLMessageIntentCandidate **)v21[0], (uint64_t)__p);
        getUTF8StringFromCFString(kNLMessageIntentAttributeKeywordsKey, v33);
        std::string v32 = (void **)v33;
        unint64_t v8 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (unsigned __int8 *)v33, (uint64_t)&std::piecewise_construct, (long long **)&v32);
        std::string::operator=((std::string *)(v8 + 40), &__str);
        if (v34 < 0) {
          operator delete(v33[0]);
        }
        operator new();
      }
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str.__r_.__value_.__l.__data_);
      }
      v33[0] = (void **)v21;
      std::vector<std::unique_ptr<NLMessageIntentCandidate>>::__destroy_vector::operator()[abi:ne180100](v33);
      std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)v23);
      v6 += 12;
    }
    while (v6 != v13);
    uint64_t v9 = *a3;
    std::string v10 = (uint64_t *)a3[1];
  }
  if ((unint64_t)v10 - v9 > 8)
  {
    v33[0] = (void **)greater_than_key;
    unint64_t v11 = 126 - 2 * __clz(((uint64_t)v10 - v9) >> 3);
    if (v10 == (uint64_t *)v9) {
      uint64_t v12 = 0;
    }
    else {
      uint64_t v12 = v11;
    }
    std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*,false>(v9, v10, (uint64_t (**)(uint64_t *, uint64_t *))v33, v12, 1);
  }
  int v22 = (void **)&v24;
  std::vector<NLMessageIntentTypeWithMetadata>::__destroy_vector::operator()[abi:ne180100](&v22);
  if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v26.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v27.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v29.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v28.__r_.__value_.__l.__data_);
  }
  v28.__r_.__value_.__r.__words[0] = (std::string::size_type)&v30;
  std::vector<std::shared_ptr<NL::ParseAttribute>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v28);
}

void sub_1A43E84E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,char a50,uint64_t a51,uint64_t a52,void *__p,uint64_t a54,int a55,__int16 a56,char a57,char a58)
{
  if (*(char *)(v58 - 217) < 0) {
    operator delete(*(void **)(v58 - 240));
  }
  std::pair<std::string,std::string>::~pair(v58 - 216);
  *(void *)(v58 - 216) = v58 - 168;
  std::vector<std::shared_ptr<NL::ParseAttribute>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v58 - 216));
  _Unwind_Resume(a1);
}

BOOL greater_than_key(NLMessageIntentCandidate **a1, NLMessageIntentCandidate **a2)
{
  double Score = NLMessageIntentCandidate::getScore(*a1);
  return Score > NLMessageIntentCandidate::getScore(*a2);
}

void std::__hash_table<std::__hash_value_type<std::string,std::basic_regex<char,std::regex_traits<char>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::basic_regex<char,std::regex_traits<char>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::basic_regex<char,std::regex_traits<char>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::basic_regex<char,std::regex_traits<char>>>>>::__move_assign(uint64_t a1, uint64_t *a2)
{
  std::__hash_table<std::__hash_value_type<std::string,std::basic_regex<char,std::regex_traits<char>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::basic_regex<char,std::regex_traits<char>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::basic_regex<char,std::regex_traits<char>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::basic_regex<char,std::regex_traits<char>>>>>::clear(a1);
  uint64_t v4 = *a2;
  *a2 = 0;
  uint64_t v5 = *(void **)a1;
  *(void *)a1 = v4;
  if (v5) {
    operator delete(v5);
  }
  uint64_t v8 = a2[2];
  uint64_t v7 = a2 + 2;
  uint64_t v6 = v8;
  uint64_t v9 = *(v7 - 1);
  *(void *)(a1 + 16) = v8;
  *(void *)(a1 + 8) = v9;
  *(v7 - 1) = 0;
  uint64_t v10 = v7[1];
  *(void *)(a1 + 24) = v10;
  *(_DWORD *)(a1 + 32) = *((_DWORD *)v7 + 4);
  if (v10)
  {
    unint64_t v11 = *(void *)(v6 + 8);
    unint64_t v12 = *(void *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12) {
        v11 %= v12;
      }
    }
    else
    {
      v11 &= v12 - 1;
    }
    *(void *)(*(void *)a1 + 8 * v11) = a1 + 16;
    *uint64_t v7 = 0;
    v7[1] = 0;
  }
}

void std::__hash_table<std::__hash_value_type<std::string,std::basic_regex<char,std::regex_traits<char>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::basic_regex<char,std::regex_traits<char>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::basic_regex<char,std::regex_traits<char>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::basic_regex<char,std::regex_traits<char>>>>>::clear(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    std::__hash_table<std::__hash_value_type<std::string,std::basic_regex<char,std::regex_traits<char>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::basic_regex<char,std::regex_traits<char>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::basic_regex<char,std::regex_traits<char>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::basic_regex<char,std::regex_traits<char>>>>>::__deallocate_node(a1, *(void **)(a1 + 16));
    *(void *)(a1 + 16) = 0;
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      for (uint64_t i = 0; i != v2; ++i)
        *(void *)(*(void *)a1 + 8 * i) = 0;
    }
    *(void *)(a1 + 24) = 0;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(std::shared_ptr<NLMessageConversationTurn> const&,std::shared_ptr<NLMessageConversationTurn> const&),std::shared_ptr<NLMessageConversationTurn>*,false>(uint64_t *a1, long long *a2, uint64_t (**a3)(uint64_t *, uint64_t *), uint64_t a4, char a5)
{
void std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::shared_ptr<NLMessageConversationTurn> const&,std::shared_ptr<NLMessageConversationTurn> const&),std::shared_ptr<NLMessageConversationTurn>*>(uint64_t a1, uint64_t a2, uint64_t (**a3)(long long *, uint64_t))
{
  if (a1 != a2)
  {
    char v5 = (long long *)(a1 + 16);
    if (a1 + 16 != a2)
    {
      uint64_t v7 = 0;
      uint64_t v8 = a1;
      do
      {
        uint64_t v9 = v8;
        uint64_t v8 = (uint64_t)v5;
        if ((*a3)(v5, v9))
        {
          long long v18 = *(_OWORD *)v8;
          *(void *)uint64_t v8 = 0;
          *(void *)(v8 + 8) = 0;
          uint64_t v10 = v7;
          while (1)
          {
            uint64_t v11 = a1 + v10;
            long long v12 = *(_OWORD *)(a1 + v10);
            *(void *)uint64_t v11 = 0;
            *(void *)(v11 + 8) = 0;
            uint64_t v13 = *(std::__shared_weak_count **)(a1 + v10 + 24);
            *(_OWORD *)(v11 + 16) = v12;
            if (v13) {
              std::__shared_weak_count::__release_shared[abi:ne180100](v13);
            }
            if (!v10) {
              break;
            }
            char v14 = (*a3)(&v18, a1 + v10 - 16);
            v10 -= 16;
            if ((v14 & 1) == 0)
            {
              uint64_t v15 = a1 + v10 + 16;
              goto LABEL_12;
            }
          }
          uint64_t v15 = a1;
LABEL_12:
          long long v16 = v18;
          long long v18 = 0uLL;
          char v17 = *(std::__shared_weak_count **)(v15 + 8);
          *(_OWORD *)uint64_t v15 = v16;
          if (v17) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v17);
          }
          if (*((void *)&v18 + 1)) {
            std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v18 + 1));
          }
        }
        char v5 = (long long *)(v8 + 16);
        v7 += 16;
      }
      while (v8 + 16 != a2);
    }
  }
}

void sub_1A43E8C74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::shared_ptr<NLMessageConversationTurn> const&,std::shared_ptr<NLMessageConversationTurn> const&),std::shared_ptr<NLMessageConversationTurn>*>(long long *a1, long long *a2, uint64_t (**a3)(long long *, long long *))
{
  if (a1 != a2)
  {
    uint64_t v4 = a1;
    char v5 = a1 + 1;
    if (a1 + 1 != a2)
    {
      uint64_t v7 = a1 - 1;
      do
      {
        uint64_t v8 = v4;
        uint64_t v4 = v5;
        if ((*a3)(v5, v8))
        {
          long long v15 = *v4;
          *(void *)uint64_t v4 = 0;
          *((void *)v4 + 1) = 0;
          uint64_t v9 = v7;
          do
          {
            long long v10 = v9[1];
            *((void *)v9 + 2) = 0;
            *((void *)v9 + 3) = 0;
            uint64_t v11 = (std::__shared_weak_count *)*((void *)v9 + 5);
            std::regex_traits<char> v9[2] = v10;
            if (v11) {
              std::__shared_weak_count::__release_shared[abi:ne180100](v11);
            }
            char v12 = (*a3)(&v15, v9--);
          }
          while ((v12 & 1) != 0);
          long long v13 = v15;
          long long v15 = 0uLL;
          char v14 = (std::__shared_weak_count *)*((void *)v9 + 5);
          std::regex_traits<char> v9[2] = v13;
          if (v14) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v14);
          }
          if (*((void *)&v15 + 1)) {
            std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v15 + 1));
          }
        }
        char v5 = v4 + 1;
        ++v7;
      }
      while (v4 + 1 != a2);
    }
  }
}

void sub_1A43E8D70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::shared_ptr<NLMessageConversationTurn> const&,std::shared_ptr<NLMessageConversationTurn> const&),std::shared_ptr<NLMessageConversationTurn>*>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t (**a4)(uint64_t *, uint64_t *))
{
  char v8 = (*a4)(a2, a1);
  uint64_t result = (*a4)(a3, a2);
  if (v8)
  {
    uint64_t v10 = *a1;
    if (result)
    {
      *a1 = *a3;
      *a3 = v10;
      uint64_t v11 = a3 + 1;
      uint64_t result = 1;
      char v12 = a1 + 1;
LABEL_9:
      long long v15 = v11;
      goto LABEL_10;
    }
    *a1 = *a2;
    *a2 = v10;
    uint64_t v17 = a1[1];
    a1[1] = a2[1];
    a2[1] = v17;
    if ((*a4)(a3, a2))
    {
      uint64_t v18 = *a2;
      *a2 = *a3;
      *a3 = v18;
      uint64_t v11 = a3 + 1;
      uint64_t result = 2;
      char v12 = a2 + 1;
      goto LABEL_9;
    }
  }
  else
  {
    if (!result) {
      return result;
    }
    uint64_t v13 = *a2;
    *a2 = *a3;
    *a3 = v13;
    long long v15 = a2 + 1;
    uint64_t v14 = a2[1];
    a2[1] = a3[1];
    a3[1] = v14;
    if ((*a4)(a2, a1))
    {
      uint64_t v16 = *a1;
      *a1 = *a2;
      char v12 = a1 + 1;
      *a2 = v16;
      uint64_t result = 2;
LABEL_10:
      uint64_t v19 = *v12;
      *char v12 = *v15;
      *long long v15 = v19;
      return result;
    }
  }
  return 1;
}

void *std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,std::shared_ptr<NLMessageConversationTurn> *,BOOL (*&)(std::shared_ptr<NLMessageConversationTurn> const&,std::shared_ptr<NLMessageConversationTurn> const&)>(long long *a1, void *a2, uint64_t (**a3)(long long *, void *))
{
  uint64_t v4 = a2;
  long long v17 = *a1;
  *(void *)a1 = 0;
  *((void *)a1 + 1) = 0;
  if ((*a3)(&v17, a2 - 2))
  {
    char v6 = a1;
    do
      v6 += 2;
    while (((*a3)(&v17, v6) & 1) == 0);
  }
  else
  {
    uint64_t v7 = a1 + 1;
    do
    {
      char v6 = v7;
      if (v7 >= v4) {
        break;
      }
      int v8 = (*a3)(&v17, v7);
      uint64_t v7 = v6 + 2;
    }
    while (!v8);
  }
  if (v6 < v4)
  {
    do
      v4 -= 2;
    while (((*a3)(&v17, v4) & 1) != 0);
  }
  while (v6 < v4)
  {
    uint64_t v9 = *v6;
    *char v6 = *v4;
    *uint64_t v4 = v9;
    uint64_t v10 = v6[1];
    v6[1] = v4[1];
    v4[1] = v10;
    do
      v6 += 2;
    while (!(*a3)(&v17, v6));
    do
      v4 -= 2;
    while (((*a3)(&v17, v4) & 1) != 0);
  }
  uint64_t v11 = (long long *)(v6 - 2);
  if (v6 - 2 != (void *)a1)
  {
    long long v12 = *v11;
    *(void *)uint64_t v11 = 0;
    *(v6 - 1) = 0;
    uint64_t v13 = (std::__shared_weak_count *)*((void *)a1 + 1);
    *a1 = v12;
    if (v13) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v13);
    }
  }
  long long v14 = v17;
  long long v17 = 0uLL;
  long long v15 = (std::__shared_weak_count *)*(v6 - 1);
  *((_OWORD *)v6 - 1) = v14;
  if (v15) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v15);
  }
  if (*((void *)&v17 + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v17 + 1));
  }
  return v6;
}

void sub_1A43E9034(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

long long *std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,std::shared_ptr<NLMessageConversationTurn> *,BOOL (*&)(std::shared_ptr<NLMessageConversationTurn> const&,std::shared_ptr<NLMessageConversationTurn> const&)>(long long *a1, long long *a2, uint64_t (**a3)(long long *, long long *))
{
  uint64_t v6 = 0;
  long long v19 = *a1;
  *(void *)a1 = 0;
  *((void *)a1 + 1) = 0;
  do
    char v7 = (*a3)(&a1[++v6], &v19);
  while ((v7 & 1) != 0);
  unint64_t v8 = (unint64_t)&a1[v6];
  if (v6 == 1)
  {
    do
    {
      if (v8 >= (unint64_t)a2) {
        break;
      }
      --a2;
    }
    while (((*a3)(a2, &v19) & 1) == 0);
  }
  else
  {
    do
      --a2;
    while (!(*a3)(a2, &v19));
  }
  uint64_t v9 = &a1[v6];
  if (v8 < (unint64_t)a2)
  {
    uint64_t v10 = a2;
    do
    {
      uint64_t v11 = *(void *)v9;
      *(void *)uint64_t v9 = *(void *)v10;
      *(void *)uint64_t v10 = v11;
      uint64_t v12 = *((void *)v9 + 1);
      *((void *)v9 + 1) = *((void *)v10 + 1);
      *((void *)v10 + 1) = v12;
      do
        ++v9;
      while (((*a3)(v9, &v19) & 1) != 0);
      do
        --v10;
      while (!(*a3)(v10, &v19));
    }
    while (v9 < v10);
  }
  uint64_t v13 = v9 - 1;
  if (v9 - 1 != a1)
  {
    long long v14 = *v13;
    *(void *)uint64_t v13 = 0;
    *((void *)v9 - 1) = 0;
    long long v15 = (std::__shared_weak_count *)*((void *)a1 + 1);
    *a1 = v14;
    if (v15) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v15);
    }
  }
  long long v16 = v19;
  long long v19 = 0uLL;
  long long v17 = (std::__shared_weak_count *)*((void *)v9 - 1);
  *(v9 - 1) = v16;
  if (v17) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v17);
  }
  if (*((void *)&v19 + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v19 + 1));
  }
  return v9 - 1;
}

void sub_1A43E91D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::shared_ptr<NLMessageConversationTurn> const&,std::shared_ptr<NLMessageConversationTurn> const&),std::shared_ptr<NLMessageConversationTurn>*>(uint64_t *a1, uint64_t *a2, uint64_t (**a3)(uint64_t *, uint64_t *))
{
  uint64_t v6 = ((char *)a2 - (char *)a1) >> 4;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if ((*a3)(a2 - 2, a1))
      {
        uint64_t v8 = *a1;
        *a1 = *(a2 - 2);
        *(a2 - 2) = v8;
        uint64_t v9 = a1[1];
        a1[1] = *(a2 - 1);
        *(a2 - 1) = v9;
      }
      return 1;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::shared_ptr<NLMessageConversationTurn> const&,std::shared_ptr<NLMessageConversationTurn> const&),std::shared_ptr<NLMessageConversationTurn>*>(a1, a1 + 2, a2 - 2, a3);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::shared_ptr<NLMessageConversationTurn> const&,std::shared_ptr<NLMessageConversationTurn> const&),std::shared_ptr<NLMessageConversationTurn>*>(a1, a1 + 2, a1 + 4, a2 - 2, a3);
      return 1;
    case 5:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::shared_ptr<NLMessageConversationTurn> const&,std::shared_ptr<NLMessageConversationTurn> const&),std::shared_ptr<NLMessageConversationTurn>*>(a1, a1 + 2, a1 + 4, a1 + 6, a2 - 2, a3);
      return 1;
    default:
      uint64_t v10 = a1 + 4;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::shared_ptr<NLMessageConversationTurn> const&,std::shared_ptr<NLMessageConversationTurn> const&),std::shared_ptr<NLMessageConversationTurn>*>(a1, a1 + 2, a1 + 4, a3);
      uint64_t v11 = a1 + 6;
      if (a1 + 6 == a2) {
        return 1;
      }
      uint64_t v12 = 0;
      int v13 = 0;
      break;
  }
  while (1)
  {
    if ((*a3)(v11, v10))
    {
      long long v22 = *(_OWORD *)v11;
      *uint64_t v11 = 0;
      v11[1] = 0;
      uint64_t v14 = v12;
      while (1)
      {
        long long v15 = (char *)a1 + v14;
        long long v16 = *(_OWORD *)((char *)a1 + v14 + 32);
        *((void *)v15 + 4) = 0;
        *((void *)v15 + 5) = 0;
        long long v17 = *(std::__shared_weak_count **)((char *)a1 + v14 + 56);
        *((_OWORD *)v15 + 3) = v16;
        if (v17) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v17);
        }
        if (v14 == -32) {
          break;
        }
        char v18 = (*a3)((uint64_t *)&v22, (uint64_t *)((char *)a1 + v14 + 16));
        v14 -= 16;
        if ((v18 & 1) == 0)
        {
          uint64_t v19 = (uint64_t)a1 + v14 + 48;
          goto LABEL_14;
        }
      }
      uint64_t v19 = (uint64_t)a1;
LABEL_14:
      long long v20 = v22;
      long long v22 = 0uLL;
      BOOL v21 = *(std::__shared_weak_count **)(v19 + 8);
      *(_OWORD *)uint64_t v19 = v20;
      if (v21) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v21);
      }
      if (*((void *)&v22 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v22 + 1));
      }
      if (++v13 == 8) {
        return v11 + 2 == a2;
      }
    }
    uint64_t v10 = v11;
    v12 += 16;
    v11 += 2;
    if (v11 == a2) {
      return 1;
    }
  }
}

void sub_1A43E93FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::shared_ptr<NLMessageConversationTurn> const&,std::shared_ptr<NLMessageConversationTurn> const&),std::shared_ptr<NLMessageConversationTurn>*>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t (**a5)(uint64_t *, uint64_t *))
{
  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::shared_ptr<NLMessageConversationTurn> const&,std::shared_ptr<NLMessageConversationTurn> const&),std::shared_ptr<NLMessageConversationTurn>*>(a1, a2, a3, a5);
  uint64_t result = (*a5)(a4, a3);
  if (result)
  {
    uint64_t v11 = *a3;
    *a3 = *a4;
    *a4 = v11;
    uint64_t v12 = a3[1];
    a3[1] = a4[1];
    a4[1] = v12;
    uint64_t result = (*a5)(a3, a2);
    if (result)
    {
      uint64_t v13 = *a2;
      *a2 = *a3;
      *a3 = v13;
      uint64_t v14 = a2[1];
      a2[1] = a3[1];
      a3[1] = v14;
      uint64_t result = (*a5)(a2, a1);
      if (result)
      {
        uint64_t v15 = *a1;
        *a1 = *a2;
        *a2 = v15;
        uint64_t v16 = a1[1];
        a1[1] = a2[1];
        a2[1] = v16;
      }
    }
  }
  return result;
}

uint64_t std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::shared_ptr<NLMessageConversationTurn> const&,std::shared_ptr<NLMessageConversationTurn> const&),std::shared_ptr<NLMessageConversationTurn>*>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t (**a6)(uint64_t *, uint64_t *))
{
  std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::shared_ptr<NLMessageConversationTurn> const&,std::shared_ptr<NLMessageConversationTurn> const&),std::shared_ptr<NLMessageConversationTurn>*>(a1, a2, a3, a4, a6);
  uint64_t result = (*a6)(a5, a4);
  if (result)
  {
    uint64_t v13 = *a4;
    *a4 = *a5;
    *a5 = v13;
    uint64_t v14 = a4[1];
    a4[1] = a5[1];
    a5[1] = v14;
    uint64_t result = (*a6)(a4, a3);
    if (result)
    {
      uint64_t v15 = *a3;
      *a3 = *a4;
      *a4 = v15;
      uint64_t v16 = a3[1];
      a3[1] = a4[1];
      a4[1] = v16;
      uint64_t result = (*a6)(a3, a2);
      if (result)
      {
        uint64_t v17 = *a2;
        *a2 = *a3;
        *a3 = v17;
        uint64_t v18 = a2[1];
        a2[1] = a3[1];
        a3[1] = v18;
        uint64_t result = (*a6)(a2, a1);
        if (result)
        {
          uint64_t v19 = *a1;
          *a1 = *a2;
          *a2 = v19;
          uint64_t v20 = a1[1];
          a1[1] = a2[1];
          a2[1] = v20;
        }
      }
    }
  }
  return result;
}

long long *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::shared_ptr<NLMessageConversationTurn> const&,std::shared_ptr<NLMessageConversationTurn> const&),std::shared_ptr<NLMessageConversationTurn>*,std::shared_ptr<NLMessageConversationTurn>*>(uint64_t a1, uint64_t a2, long long *a3, unsigned int (**a4)(long long *, uint64_t))
{
  if (a1 != a2)
  {
    uint64_t v6 = a2;
    uint64_t v8 = a2 - a1;
    uint64_t v9 = (a2 - a1) >> 4;
    if (a2 - a1 >= 17)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      uint64_t v12 = (long long *)(a1 + 16 * v10);
      do
      {
        std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::shared_ptr<NLMessageConversationTurn> const&,std::shared_ptr<NLMessageConversationTurn> const&),std::shared_ptr<NLMessageConversationTurn>*>(a1, a4, v9, v12--);
        --v11;
      }
      while (v11);
    }
    uint64_t v13 = v6;
    if ((long long *)v6 != a3)
    {
      uint64_t v14 = (long long *)v6;
      do
      {
        if ((*a4)(v14, a1))
        {
          uint64_t v15 = *(void *)v14;
          *(void *)uint64_t v14 = *(void *)a1;
          *(void *)a1 = v15;
          uint64_t v16 = *((void *)v14 + 1);
          *((void *)v14 + 1) = *(void *)(a1 + 8);
          *(void *)(a1 + 8) = v16;
          std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::shared_ptr<NLMessageConversationTurn> const&,std::shared_ptr<NLMessageConversationTurn> const&),std::shared_ptr<NLMessageConversationTurn>*>(a1, a4, v9, (long long *)a1);
        }
        ++v14;
      }
      while (v14 != a3);
      uint64_t v13 = (uint64_t)a3;
    }
    if (v8 >= 17)
    {
      unint64_t v17 = (unint64_t)v8 >> 4;
      do
      {
        std::__pop_heap[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*)(std::shared_ptr<NLMessageConversationTurn> const&,std::shared_ptr<NLMessageConversationTurn> const&),std::shared_ptr<NLMessageConversationTurn>*>((uint64_t *)a1, v6, (unsigned int (**)(uint64_t, uint64_t))a4, v17);
        v6 -= 16;
      }
      while (v17-- > 2);
    }
    return (long long *)v13;
  }
  return a3;
}

void std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::shared_ptr<NLMessageConversationTurn> const&,std::shared_ptr<NLMessageConversationTurn> const&),std::shared_ptr<NLMessageConversationTurn>*>(uint64_t a1, unsigned int (**a2)(long long *, uint64_t), uint64_t a3, long long *a4)
{
  unint64_t v4 = a3 - 2;
  if (a3 >= 2)
  {
    char v5 = a4;
    uint64_t v7 = v4 >> 1;
    if ((uint64_t)(v4 >> 1) >= ((uint64_t)a4 - a1) >> 4)
    {
      uint64_t v10 = ((uint64_t)a4 - a1) >> 3;
      uint64_t v11 = v10 + 1;
      uint64_t v12 = (long long *)(a1 + 16 * (v10 + 1));
      uint64_t v13 = v10 + 2;
      if (v10 + 2 < a3 && (*a2)(v12, (uint64_t)(v12 + 1)))
      {
        ++v12;
        uint64_t v11 = v13;
      }
      if ((((uint64_t (*)(long long *, long long *))*a2)(v12, v5) & 1) == 0)
      {
        long long v20 = *v5;
        *(void *)char v5 = 0;
        *((void *)v5 + 1) = 0;
        do
        {
          uint64_t v14 = v12;
          long long v15 = *v12;
          *(void *)uint64_t v12 = 0;
          *((void *)v12 + 1) = 0;
          uint64_t v16 = (std::__shared_weak_count *)*((void *)v5 + 1);
          long long *v5 = v15;
          if (v16) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v16);
          }
          if (v7 < v11) {
            break;
          }
          uint64_t v17 = (2 * v11) | 1;
          uint64_t v12 = (long long *)(a1 + 16 * v17);
          uint64_t v11 = 2 * v11 + 2;
          if (v11 >= a3)
          {
            uint64_t v11 = v17;
          }
          else if ((*a2)((long long *)(a1 + 16 * v17), (uint64_t)(v12 + 1)))
          {
            ++v12;
          }
          else
          {
            uint64_t v11 = v17;
          }
          char v5 = v14;
        }
        while (!(*a2)(v12, (uint64_t)&v20));
        long long v18 = v20;
        long long v20 = 0uLL;
        uint64_t v19 = (std::__shared_weak_count *)*((void *)v14 + 1);
        *uint64_t v14 = v18;
        if (v19) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v19);
        }
        if (*((void *)&v20 + 1)) {
          std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v20 + 1));
        }
      }
    }
  }
}

void sub_1A43E98C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void std::__pop_heap[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*)(std::shared_ptr<NLMessageConversationTurn> const&,std::shared_ptr<NLMessageConversationTurn> const&),std::shared_ptr<NLMessageConversationTurn>*>(uint64_t *a1, uint64_t a2, unsigned int (**a3)(uint64_t, uint64_t), uint64_t a4)
{
  if (a4 >= 2)
  {
    uint64_t v8 = *a1;
    uint64_t v7 = a1[1];
    *a1 = 0;
    a1[1] = 0;
    uint64_t v9 = std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::shared_ptr<NLMessageConversationTurn> const&,std::shared_ptr<NLMessageConversationTurn> const&),std::shared_ptr<NLMessageConversationTurn>*>((uint64_t)a1, a3, a4);
    uint64_t v10 = (void *)v9;
    if (v9 == a2 - 16)
    {
      long long v15 = *(std::__shared_weak_count **)(v9 + 8);
      void *v10 = v8;
      v10[1] = v7;
      if (v15)
      {
        std::__shared_weak_count::__release_shared[abi:ne180100](v15);
      }
    }
    else
    {
      long long v11 = *(_OWORD *)(a2 - 16);
      *(void *)(a2 - 16) = 0;
      *(void *)(a2 - 8) = 0;
      uint64_t v12 = *(std::__shared_weak_count **)(v9 + 8);
      *(_OWORD *)uint64_t v10 = v11;
      if (v12) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v12);
      }
      uint64_t v13 = (uint64_t)(v10 + 2);
      uint64_t v14 = *(std::__shared_weak_count **)(a2 - 8);
      *(void *)(a2 - 16) = v8;
      *(void *)(a2 - 8) = v7;
      if (v14) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v14);
      }
      std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::shared_ptr<NLMessageConversationTurn> const&,std::shared_ptr<NLMessageConversationTurn> const&),std::shared_ptr<NLMessageConversationTurn>*>((uint64_t)a1, v13, (uint64_t (**)(long long *, long long *))a3, (v13 - (uint64_t)a1) >> 4);
    }
  }
}

void sub_1A43E99D4(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::shared_ptr<NLMessageConversationTurn> const&,std::shared_ptr<NLMessageConversationTurn> const&),std::shared_ptr<NLMessageConversationTurn>*>(uint64_t a1, unsigned int (**a2)(uint64_t, uint64_t), uint64_t a3)
{
  uint64_t v6 = 0;
  uint64_t v7 = a3 - 2;
  if (a3 < 2) {
    uint64_t v7 = a3 - 1;
  }
  uint64_t v8 = v7 >> 1;
  do
  {
    uint64_t v9 = a1 + 16 * v6 + 16;
    uint64_t v10 = 2 * v6;
    uint64_t v6 = (2 * v6) | 1;
    uint64_t v11 = v10 + 2;
    if (v10 + 2 < a3 && (*a2)(v9, v9 + 16))
    {
      v9 += 16;
      uint64_t v6 = v11;
    }
    long long v12 = *(_OWORD *)v9;
    *(void *)uint64_t v9 = 0;
    *(void *)(v9 + 8) = 0;
    uint64_t v13 = *(std::__shared_weak_count **)(a1 + 8);
    *(_OWORD *)a1 = v12;
    if (v13) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v13);
    }
    a1 = v9;
  }
  while (v6 <= v8);
  return v9;
}

void std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::shared_ptr<NLMessageConversationTurn> const&,std::shared_ptr<NLMessageConversationTurn> const&),std::shared_ptr<NLMessageConversationTurn>*>(uint64_t a1, uint64_t a2, uint64_t (**a3)(long long *, long long *), uint64_t a4)
{
  unint64_t v4 = a4 - 2;
  if (a4 >= 2)
  {
    unint64_t v7 = v4 >> 1;
    uint64_t v8 = (long long *)(a1 + 16 * (v4 >> 1));
    uint64_t v9 = (long long *)(a2 - 16);
    if ((*a3)(v8, (long long *)(a2 - 16)))
    {
      long long v15 = *v9;
      *(void *)uint64_t v9 = 0;
      *((void *)v9 + 1) = 0;
      do
      {
        uint64_t v10 = v8;
        long long v11 = *v8;
        *(void *)uint64_t v8 = 0;
        *((void *)v8 + 1) = 0;
        long long v12 = (std::__shared_weak_count *)*((void *)v9 + 1);
        long long *v9 = v11;
        if (v12) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v12);
        }
        if (!v7) {
          break;
        }
        unint64_t v7 = (v7 - 1) >> 1;
        uint64_t v8 = (long long *)(a1 + 16 * v7);
        uint64_t v9 = v10;
      }
      while (((*a3)(v8, &v15) & 1) != 0);
      long long v13 = v15;
      long long v15 = 0uLL;
      uint64_t v14 = (std::__shared_weak_count *)*((void *)v10 + 1);
      long long *v10 = v13;
      if (v14)
      {
        std::__shared_weak_count::__release_shared[abi:ne180100](v14);
        if (*((void *)&v15 + 1)) {
          std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v15 + 1));
        }
      }
    }
  }
}

void sub_1A43E9B84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1, unsigned __int8 *a2, uint64_t a3, long long **a4)
{
  uint64_t v8 = (void *)(a1 + 24);
  unint64_t v9 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  unint64_t v10 = v9;
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    unint64_t v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v4 = v9;
      if (v9 >= v11) {
        unint64_t v4 = v9 % v11;
      }
    }
    else
    {
      unint64_t v4 = (v11 - 1) & v9;
    }
    uint64_t v14 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v4);
    if (v14)
    {
      for (uint64_t i = *v14; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v16 = *((void *)i + 1);
        if (v16 == v10)
        {
          if (std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2)) {
            return i;
          }
        }
        else
        {
          if (v13 > 1)
          {
            if (v16 >= v11) {
              v16 %= v11;
            }
          }
          else
          {
            v16 &= v11 - 1;
          }
          if (v16 != v4) {
            break;
          }
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1, v10, a4, (uint64_t)v26);
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v18 = *(float *)(a1 + 32);
  if (!v11 || (float)(v18 * (float)v11) < v17)
  {
    BOOL v19 = 1;
    if (v11 >= 3) {
      BOOL v19 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v11);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    std::__hash_table<std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<NLExtendedString>>>>::__rehash<true>(a1, v22);
    unint64_t v11 = *(void *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11) {
        unint64_t v4 = v10 % v11;
      }
      else {
        unint64_t v4 = v10;
      }
    }
    else
    {
      unint64_t v4 = (v11 - 1) & v10;
    }
  }
  uint64_t v23 = *(void **)(*(void *)a1 + 8 * v4);
  if (v23)
  {
    *(void *)v26[0] = *v23;
    void *v23 = v26[0];
  }
  else
  {
    *(void *)v26[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v26[0];
    *(void *)(*(void *)a1 + 8 * v4) = a1 + 16;
    if (*(void *)v26[0])
    {
      unint64_t v24 = *(void *)(*(void *)v26[0] + 8);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v24 >= v11) {
          v24 %= v11;
        }
      }
      else
      {
        v24 &= v11 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v24) = v26[0];
    }
  }
  uint64_t i = (unsigned __int8 *)v26[0];
  v26[0] = 0;
  ++*v8;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>,void *>>>>::reset[abi:ne180100]((uint64_t)v26, 0);
  return i;
}

void sub_1A43E9E20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

double std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, long long **a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  uint64_t v8 = (char *)operator new(0x50uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *(unsigned char *)(a4 + 16) = 0;
  *(void *)uint64_t v8 = 0;
  *((void *)v8 + 1) = a2;
  unint64_t v9 = (std::string *)(v8 + 16);
  unint64_t v10 = *a3;
  if (*((char *)*a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)v10, *((void *)v10 + 1));
  }
  else
  {
    long long v11 = *v10;
    *((void *)v8 + 4) = *((void *)v10 + 2);
    *(_OWORD *)&v9->__r_.__value_.__l.__data_ = v11;
  }
  double result = 0.0;
  *(_OWORD *)(v8 + 56) = 0u;
  *(_OWORD *)(v8 + 4nlp::CFScopedPtr<__CFString const*>::reset(this + 1, 0) = 0u;
  *((_DWORD *)v8 + 18) = 1065353216;
  *(unsigned char *)(a4 + 16) = 1;
  return result;
}

void sub_1A43E9ED0(_Unwind_Exception *a1)
{
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::unordered_map<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>,0>((uint64_t)v2 + 16);
    }
    operator delete(v2);
  }
}

void std::__hash_table<std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>>::__move_assign(uint64_t a1, uint64_t *a2)
{
  std::__hash_table<std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>>::clear(a1);
  uint64_t v4 = *a2;
  *a2 = 0;
  char v5 = *(void **)a1;
  *(void *)a1 = v4;
  if (v5) {
    operator delete(v5);
  }
  uint64_t v8 = a2[2];
  uint64_t v7 = a2 + 2;
  uint64_t v6 = v8;
  uint64_t v9 = *(v7 - 1);
  *(void *)(a1 + 16) = v8;
  *(void *)(a1 + 8) = v9;
  *(v7 - 1) = 0;
  uint64_t v10 = v7[1];
  *(void *)(a1 + 24) = v10;
  *(_DWORD *)(a1 + 32) = *((_DWORD *)v7 + 4);
  if (v10)
  {
    unint64_t v11 = *(void *)(v6 + 8);
    unint64_t v12 = *(void *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12) {
        v11 %= v12;
      }
    }
    else
    {
      v11 &= v12 - 1;
    }
    *(void *)(*(void *)a1 + 8 * v11) = a1 + 16;
    *uint64_t v7 = 0;
    v7[1] = 0;
  }
}

void std::__hash_table<std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>>::clear(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    std::__hash_table<std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>>::__deallocate_node(a1, *(void **)(a1 + 16));
    *(void *)(a1 + 16) = 0;
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      for (uint64_t i = 0; i != v2; ++i)
        *(void *)(*(void *)a1 + 8 * i) = 0;
    }
    *(void *)(a1 + 24) = 0;
  }
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1, unsigned __int8 *a2, uint64_t a3, long long **a4)
{
  uint64_t v8 = (void *)(a1 + 24);
  unint64_t v9 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  unint64_t v10 = v9;
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    unint64_t v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v4 = v9;
      if (v9 >= v11) {
        unint64_t v4 = v9 % v11;
      }
    }
    else
    {
      unint64_t v4 = (v11 - 1) & v9;
    }
    uint64_t v14 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v4);
    if (v14)
    {
      for (uint64_t i = *v14; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v16 = *((void *)i + 1);
        if (v16 == v10)
        {
          if (std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2)) {
            return i;
          }
        }
        else
        {
          if (v13 > 1)
          {
            if (v16 >= v11) {
              v16 %= v11;
            }
          }
          else
          {
            v16 &= v11 - 1;
          }
          if (v16 != v4) {
            break;
          }
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1, v10, a4, (uint64_t)v26);
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v18 = *(float *)(a1 + 32);
  if (!v11 || (float)(v18 * (float)v11) < v17)
  {
    BOOL v19 = 1;
    if (v11 >= 3) {
      BOOL v19 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v11);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    std::__hash_table<std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<NLExtendedString>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<NLExtendedString>>>>::__rehash<true>(a1, v22);
    unint64_t v11 = *(void *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11) {
        unint64_t v4 = v10 % v11;
      }
      else {
        unint64_t v4 = v10;
      }
    }
    else
    {
      unint64_t v4 = (v11 - 1) & v10;
    }
  }
  uint64_t v23 = *(void **)(*(void *)a1 + 8 * v4);
  if (v23)
  {
    *(void *)v26[0] = *v23;
    void *v23 = v26[0];
  }
  else
  {
    *(void *)v26[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v26[0];
    *(void *)(*(void *)a1 + 8 * v4) = a1 + 16;
    if (*(void *)v26[0])
    {
      unint64_t v24 = *(void *)(*(void *)v26[0] + 8);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v24 >= v11) {
          v24 %= v11;
        }
      }
      else
      {
        v24 &= v11 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v24) = v26[0];
    }
  }
  uint64_t i = (unsigned __int8 *)v26[0];
  v26[0] = 0;
  ++*v8;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>,void *>>>>::reset[abi:ne180100]((uint64_t)v26, 0);
  return i;
}

void sub_1A43EA2C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1@<X0>, uint64_t a2@<X1>, long long **a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  uint64_t v8 = operator new(0x30uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *(unsigned char *)(a4 + 16) = 0;
  void *v8 = 0;
  v8[1] = a2;
  unint64_t v9 = (std::string *)(v8 + 2);
  unint64_t v10 = *a3;
  if (*((char *)*a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)v10, *((void *)v10 + 1));
  }
  else
  {
    long long v11 = *v10;
    v8[4] = *((void *)v10 + 2);
    *(_OWORD *)&v9->__r_.__value_.__l.__data_ = v11;
  }
  void v8[5] = 0;
  *(unsigned char *)(a4 + 16) = 1;
}

void sub_1A43EA360(_Unwind_Exception *a1)
{
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unique_ptr<NLAbstractIntentRecognizer>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::unique_ptr<NLAbstractIntentRecognizer>>,0>((uint64_t)v2 + 16);
    }
    operator delete(v2);
  }
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*,false>(uint64_t result, uint64_t *a2, uint64_t (**a3)(uint64_t *, uint64_t *), uint64_t a4, char a5)
{
  unint64_t v10 = (uint64_t *)result;
LABEL_2:
  long long v11 = a2 - 1;
  uint8x8_t v12 = v10;
LABEL_3:
  uint64_t v13 = 1 - a4;
  while (1)
  {
    unint64_t v10 = v12;
    uint64_t v14 = v13;
    uint64_t v15 = (char *)a2 - (char *)v12;
    unint64_t v16 = a2 - v12;
    if (!(!v6 & v5))
    {
      switch(v16)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          double result = (*a3)(a2 - 1, v12);
          if (result)
          {
            uint64_t v23 = *v12;
            *uint8x8_t v12 = *v11;
            *long long v11 = v23;
          }
          break;
        case 3uLL:
          double result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*>(v12, v12 + 1, a2 - 1, a3);
          break;
        case 4uLL:
          double result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*>(v12, v12 + 1, v12 + 2, a2 - 1, a3);
          break;
        case 5uLL:
          double result = std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*>(v12, v12 + 1, v12 + 2, v12 + 3, a2 - 1, a3);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v15 <= 191) {
      break;
    }
    if (v14 == 1)
    {
      if (v12 != a2)
      {
        return (uint64_t)std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*,std::unique_ptr<NLMessageIntentCandidate>*>(v12, (uint64_t)a2, a2, a3);
      }
      return result;
    }
    unint64_t v17 = v16 >> 1;
    float v18 = &v12[v16 >> 1];
    if ((unint64_t)v15 >= 0x401)
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*>(v12, &v12[v16 >> 1], a2 - 1, a3);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*>(v12 + 1, v18 - 1, a2 - 2, a3);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*>(v12 + 2, &v12[v17 + 1], a2 - 3, a3);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*>(v18 - 1, v18, &v12[v17 + 1], a3);
      uint64_t v19 = *v12;
      *uint8x8_t v12 = *v18;
      *float v18 = v19;
      if (a5) {
        goto LABEL_14;
      }
    }
    else
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*>(&v12[v16 >> 1], v12, a2 - 1, a3);
      if (a5) {
        goto LABEL_14;
      }
    }
    if (((*a3)(v12 - 1, v12) & 1) == 0)
    {
      double result = (uint64_t)std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,std::unique_ptr<NLMessageIntentCandidate> *,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&)>(v12, a2, a3);
      uint8x8_t v12 = (uint64_t *)result;
      goto LABEL_19;
    }
LABEL_14:
    unint64_t v20 = std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,std::unique_ptr<NLMessageIntentCandidate> *,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&)>(v12, a2, a3);
    if ((v21 & 1) == 0) {
      goto LABEL_17;
    }
    BOOL v22 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*>(v12, v20, a3);
    uint8x8_t v12 = v20 + 1;
    double result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*>(v20 + 1, a2, a3);
    if (result)
    {
      a4 = -v14;
      a2 = v20;
      if (v22) {
        return result;
      }
      goto LABEL_2;
    }
    uint64_t v13 = v14 + 1;
    if (!v22)
    {
LABEL_17:
      double result = std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*,false>(v10, v20, a3, -v14, a5 & 1);
      uint8x8_t v12 = v20 + 1;
LABEL_19:
      a5 = 0;
      a4 = -v14;
      goto LABEL_3;
    }
  }
  if (a5)
  {
    return (uint64_t)std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*>(v12, a2, (uint64_t (**)(uint64_t *, uint64_t))a3);
  }
  else
  {
    return (uint64_t)std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*>(v12, a2, a3);
  }
}

uint64_t *std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*>(uint64_t *result, uint64_t *a2, uint64_t (**a3)(uint64_t *, uint64_t))
{
  if (result != a2)
  {
    unint64_t v4 = result;
    char v5 = result + 1;
    if (result + 1 != a2)
    {
      uint64_t v7 = 0;
      uint64_t v8 = result;
      do
      {
        unint64_t v9 = v8;
        uint64_t v8 = v5;
        double result = (uint64_t *)(*a3)(v5, (uint64_t)v9);
        if (result)
        {
          uint64_t v10 = *v8;
          uint64_t *v8 = 0;
          uint64_t v17 = v10;
          uint64_t v11 = v7;
          while (1)
          {
            uint64_t v12 = *(uint64_t *)((char *)v4 + v11);
            *(uint64_t *)((char *)v4 + v11) = 0;
            std::unique_ptr<NLMessageIntentCandidate>::reset[abi:ne180100]((uint64_t *)((char *)v4 + v11 + 8), v12);
            if (!v11) {
              break;
            }
            char v13 = (*a3)(&v17, (uint64_t)v4 + v11 - 8);
            v11 -= 8;
            if ((v13 & 1) == 0)
            {
              uint64_t v14 = (uint64_t *)((char *)v4 + v11 + 8);
              goto LABEL_10;
            }
          }
          uint64_t v14 = v4;
LABEL_10:
          uint64_t v15 = v17;
          uint64_t v17 = 0;
          double result = std::unique_ptr<NLMessageIntentCandidate>::reset[abi:ne180100](v14, v15);
          uint64_t v16 = v17;
          uint64_t v17 = 0;
          if (v16)
          {
            std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table(v16 + 8);
            double result = (uint64_t *)MEMORY[0x1A625B130](v16, 0x10A0C4042D94C91);
          }
        }
        char v5 = v8 + 1;
        v7 += 8;
      }
      while (v8 + 1 != a2);
    }
  }
  return result;
}

void sub_1A43EA8AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<NLMessageIntentCandidate>::reset[abi:ne180100]((uint64_t *)va, 0);
  _Unwind_Resume(a1);
}

uint64_t *std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*>(uint64_t *result, uint64_t *a2, uint64_t (**a3)(uint64_t *, uint64_t *))
{
  if (result != a2)
  {
    unint64_t v4 = result;
    for (uint64_t i = result + 1; v4 + 1 != a2; uint64_t i = v4 + 1)
    {
      uint64_t v7 = v4;
      unint64_t v4 = i;
      double result = (uint64_t *)(*a3)(i, v7);
      if (result)
      {
        uint64_t v8 = *v4;
        *unint64_t v4 = 0;
        uint64_t v14 = v8;
        unint64_t v9 = v4;
        do
        {
          uint64_t v10 = *(v9 - 1);
          *(v9 - 1) = 0;
          std::unique_ptr<NLMessageIntentCandidate>::reset[abi:ne180100](v9, v10);
          char v11 = (*a3)(&v14, v9 - 2);
          --v9;
        }
        while ((v11 & 1) != 0);
        uint64_t v12 = v14;
        uint64_t v14 = 0;
        double result = std::unique_ptr<NLMessageIntentCandidate>::reset[abi:ne180100](v9, v12);
        uint64_t v13 = v14;
        uint64_t v14 = 0;
        if (v13)
        {
          std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table(v13 + 8);
          double result = (uint64_t *)MEMORY[0x1A625B130](v13, 0x10A0C4042D94C91);
        }
      }
    }
  }
  return result;
}

void sub_1A43EA9A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<NLMessageIntentCandidate>::reset[abi:ne180100]((uint64_t *)va, 0);
  _Unwind_Resume(a1);
}

uint64_t std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t (**a4)(uint64_t *, uint64_t *))
{
  char v8 = (*a4)(a2, a1);
  uint64_t result = (*a4)(a3, a2);
  if ((v8 & 1) == 0)
  {
    if (!result) {
      return result;
    }
    uint64_t v11 = *a2;
    *a2 = *a3;
    *a3 = v11;
    if (!(*a4)(a2, a1)) {
      return 1;
    }
    uint64_t v12 = *a1;
    *a1 = *a2;
    *a2 = v12;
    return 2;
  }
  uint64_t v10 = *a1;
  if (!result)
  {
    *a1 = *a2;
    *a2 = v10;
    if (!(*a4)(a3, a2)) {
      return 1;
    }
    uint64_t v13 = *a2;
    *a2 = *a3;
    *a3 = v13;
    return 2;
  }
  *a1 = *a3;
  *a3 = v10;
  return 1;
}

uint64_t *std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,std::unique_ptr<NLMessageIntentCandidate> *,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&)>(uint64_t *a1, uint64_t *a2, uint64_t (**a3)(uint64_t *, uint64_t *))
{
  unint64_t v4 = a2;
  uint64_t v6 = *a1;
  *a1 = 0;
  uint64_t v16 = v6;
  if ((*a3)(&v16, a2 - 1))
  {
    uint64_t v7 = a1;
    do
      ++v7;
    while (((*a3)(&v16, v7) & 1) == 0);
  }
  else
  {
    char v8 = a1 + 1;
    do
    {
      uint64_t v7 = v8;
      if (v8 >= v4) {
        break;
      }
      int v9 = (*a3)(&v16, v8);
      char v8 = v7 + 1;
    }
    while (!v9);
  }
  if (v7 < v4)
  {
    do
      --v4;
    while (((*a3)(&v16, v4) & 1) != 0);
  }
  while (v7 < v4)
  {
    uint64_t v10 = *v7;
    *uint64_t v7 = *v4;
    *unint64_t v4 = v10;
    do
      ++v7;
    while (!(*a3)(&v16, v7));
    do
      --v4;
    while (((*a3)(&v16, v4) & 1) != 0);
  }
  uint64_t v11 = v7 - 1;
  if (v7 - 1 != a1)
  {
    uint64_t v12 = *v11;
    *uint64_t v11 = 0;
    std::unique_ptr<NLMessageIntentCandidate>::reset[abi:ne180100](a1, v12);
  }
  uint64_t v13 = v16;
  uint64_t v16 = 0;
  std::unique_ptr<NLMessageIntentCandidate>::reset[abi:ne180100](v7 - 1, v13);
  uint64_t v14 = v16;
  uint64_t v16 = 0;
  if (v14)
  {
    std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table(v14 + 8);
    MEMORY[0x1A625B130](v14, 0x10A0C4042D94C91);
  }
  return v7;
}

void sub_1A43EAC1C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<NLMessageIntentCandidate>::reset[abi:ne180100]((uint64_t *)va, 0);
  _Unwind_Resume(a1);
}

uint64_t *std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,std::unique_ptr<NLMessageIntentCandidate> *,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&)>(uint64_t *a1, uint64_t *a2, uint64_t (**a3)(uint64_t *, uint64_t *))
{
  uint64_t v6 = 0;
  uint64_t v7 = *a1;
  *a1 = 0;
  uint64_t v18 = v7;
  do
    char v8 = (*a3)(&a1[++v6], &v18);
  while ((v8 & 1) != 0);
  int v9 = &a1[v6];
  if (v6 == 1)
  {
    do
    {
      if (v9 >= a2) {
        break;
      }
      --a2;
    }
    while (((*a3)(a2, &v18) & 1) == 0);
  }
  else
  {
    do
      --a2;
    while (!(*a3)(a2, &v18));
  }
  if (v9 >= a2)
  {
    uint64_t v13 = v9 - 1;
  }
  else
  {
    uint64_t v10 = &a1[v6];
    uint64_t v11 = a2;
    do
    {
      uint64_t v12 = *v10;
      uint64_t *v10 = *v11;
      *uint64_t v11 = v12;
      do
        ++v10;
      while (((*a3)(v10, &v18) & 1) != 0);
      do
        --v11;
      while (!(*a3)(v11, &v18));
    }
    while (v10 < v11);
    uint64_t v13 = v10 - 1;
  }
  if (v13 != a1)
  {
    uint64_t v14 = *v13;
    *uint64_t v13 = 0;
    std::unique_ptr<NLMessageIntentCandidate>::reset[abi:ne180100](a1, v14);
  }
  uint64_t v15 = v18;
  uint64_t v18 = 0;
  std::unique_ptr<NLMessageIntentCandidate>::reset[abi:ne180100](v13, v15);
  uint64_t v16 = v18;
  uint64_t v18 = 0;
  if (v16)
  {
    std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table(v16 + 8);
    MEMORY[0x1A625B130](v16, 0x10A0C4042D94C91);
  }
  return v13;
}

void sub_1A43EADC0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<NLMessageIntentCandidate>::reset[abi:ne180100]((uint64_t *)va, 0);
  _Unwind_Resume(a1);
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*>(uint64_t *a1, uint64_t *a2, uint64_t (**a3)(uint64_t *, uint64_t *))
{
  uint64_t v6 = a2 - a1;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      char v8 = a2 - 1;
      if ((*a3)(a2 - 1, a1))
      {
        uint64_t v9 = *a1;
        *a1 = *v8;
        uint64_t *v8 = v9;
      }
      return 1;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*>(a1, a1 + 1, a2 - 1, a3);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*>(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, a3);
      return 1;
    default:
      uint64_t v10 = a1 + 2;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*>(a1, a1 + 1, a1 + 2, a3);
      uint64_t v11 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      uint64_t v12 = 0;
      int v13 = 0;
      break;
  }
  while (1)
  {
    if ((*a3)(v11, v10))
    {
      uint64_t v14 = *v11;
      *uint64_t v11 = 0;
      uint64_t v21 = v14;
      uint64_t v15 = v12;
      while (1)
      {
        uint64_t v16 = *(uint64_t *)((char *)a1 + v15 + 16);
        *(uint64_t *)((char *)a1 + v15 + 16) = 0;
        std::unique_ptr<NLMessageIntentCandidate>::reset[abi:ne180100]((uint64_t *)((char *)a1 + v15 + 24), v16);
        if (v15 == -16) {
          break;
        }
        char v17 = (*a3)(&v21, (uint64_t *)((char *)a1 + v15 + 8));
        v15 -= 8;
        if ((v17 & 1) == 0)
        {
          uint64_t v18 = (uint64_t *)((char *)a1 + v15 + 24);
          goto LABEL_12;
        }
      }
      uint64_t v18 = a1;
LABEL_12:
      uint64_t v19 = v21;
      uint64_t v21 = 0;
      std::unique_ptr<NLMessageIntentCandidate>::reset[abi:ne180100](v18, v19);
      uint64_t v20 = v21;
      uint64_t v21 = 0;
      if (v20)
      {
        std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table(v20 + 8);
        MEMORY[0x1A625B130](v20, 0x10A0C4042D94C91);
      }
      if (++v13 == 8) {
        return v11 + 1 == a2;
      }
    }
    uint64_t v10 = v11;
    v12 += 8;
    if (++v11 == a2) {
      return 1;
    }
  }
}

void sub_1A43EAFE8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<NLMessageIntentCandidate>::reset[abi:ne180100]((uint64_t *)va, 0);
  _Unwind_Resume(a1);
}

uint64_t std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t (**a5)(uint64_t *, uint64_t *))
{
  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*>(a1, a2, a3, a5);
  uint64_t result = (*a5)(a4, a3);
  if (result)
  {
    uint64_t v11 = *a3;
    *a3 = *a4;
    *a4 = v11;
    uint64_t result = (*a5)(a3, a2);
    if (result)
    {
      uint64_t v12 = *a2;
      *a2 = *a3;
      *a3 = v12;
      uint64_t result = (*a5)(a2, a1);
      if (result)
      {
        uint64_t v13 = *a1;
        *a1 = *a2;
        *a2 = v13;
      }
    }
  }
  return result;
}

uint64_t std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t (**a6)(uint64_t *, uint64_t *))
{
  std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*>(a1, a2, a3, a4, a6);
  uint64_t result = (*a6)(a5, a4);
  if (result)
  {
    uint64_t v13 = *a4;
    *a4 = *a5;
    *a5 = v13;
    uint64_t result = (*a6)(a4, a3);
    if (result)
    {
      uint64_t v14 = *a3;
      *a3 = *a4;
      *a4 = v14;
      uint64_t result = (*a6)(a3, a2);
      if (result)
      {
        uint64_t v15 = *a2;
        *a2 = *a3;
        *a3 = v15;
        uint64_t result = (*a6)(a2, a1);
        if (result)
        {
          uint64_t v16 = *a1;
          *a1 = *a2;
          *a2 = v16;
        }
      }
    }
  }
  return result;
}

uint64_t *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*,std::unique_ptr<NLMessageIntentCandidate>*>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t (**a4)(uint64_t *, uint64_t *))
{
  if (a1 != (uint64_t *)a2)
  {
    uint64_t v8 = (a2 - (uint64_t)a1) >> 3;
    if (a2 - (uint64_t)a1 >= 9)
    {
      unint64_t v9 = (unint64_t)(v8 - 2) >> 1;
      unint64_t v10 = v9 + 1;
      uint64_t v11 = &a1[v9];
      do
      {
        std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*>((uint64_t)a1, a4, v8, v11--);
        --v10;
      }
      while (v10);
    }
    uint64_t v12 = a2;
    if ((uint64_t *)a2 != a3)
    {
      uint64_t v13 = (uint64_t *)a2;
      do
      {
        if ((*a4)(v13, a1))
        {
          uint64_t v14 = *v13;
          *uint64_t v13 = *a1;
          *a1 = v14;
          std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*>((uint64_t)a1, a4, v8, a1);
        }
        ++v13;
      }
      while (v13 != a3);
      uint64_t v12 = (uint64_t)a3;
    }
    std::__sort_heap[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*>(a1, a2, (unsigned int (**)(uint64_t, uint64_t))a4);
    return (uint64_t *)v12;
  }
  return a3;
}

uint64_t std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*>(uint64_t result, uint64_t (**a2)(uint64_t *, uint64_t *), uint64_t a3, uint64_t *a4)
{
  unint64_t v4 = a3 - 2;
  if (a3 >= 2)
  {
    char v5 = a4;
    uint64_t v6 = result;
    uint64_t v7 = v4 >> 1;
    if ((uint64_t)(v4 >> 1) >= ((uint64_t)a4 - result) >> 3)
    {
      uint64_t v10 = ((uint64_t)a4 - result) >> 2;
      uint64_t v11 = v10 + 1;
      uint64_t v12 = (uint64_t *)(result + 8 * (v10 + 1));
      uint64_t v13 = v10 + 2;
      if (v10 + 2 < a3 && (*a2)(v12, v12 + 1))
      {
        ++v12;
        uint64_t v11 = v13;
      }
      uint64_t result = (*a2)(v12, v5);
      if ((result & 1) == 0)
      {
        uint64_t v14 = *v5;
        uint64_t *v5 = 0;
        uint64_t v20 = v14;
        do
        {
          uint64_t v15 = v12;
          uint64_t v16 = *v12;
          *uint64_t v12 = 0;
          std::unique_ptr<NLMessageIntentCandidate>::reset[abi:ne180100](v5, v16);
          if (v7 < v11) {
            break;
          }
          uint64_t v17 = (2 * v11) | 1;
          uint64_t v12 = (uint64_t *)(v6 + 8 * v17);
          uint64_t v11 = 2 * v11 + 2;
          if (v11 >= a3)
          {
            uint64_t v11 = v17;
          }
          else if ((*a2)((uint64_t *)(v6 + 8 * v17), v12 + 1))
          {
            ++v12;
          }
          else
          {
            uint64_t v11 = v17;
          }
          char v5 = v15;
        }
        while (!(*a2)(v12, &v20));
        uint64_t v18 = v20;
        uint64_t v20 = 0;
        uint64_t result = (uint64_t)std::unique_ptr<NLMessageIntentCandidate>::reset[abi:ne180100](v15, v18);
        uint64_t v19 = v20;
        uint64_t v20 = 0;
        if (v19)
        {
          std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table(v19 + 8);
          return MEMORY[0x1A625B130](v19, 0x10A0C4042D94C91);
        }
      }
    }
  }
  return result;
}

void sub_1A43EB41C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<NLMessageIntentCandidate>::reset[abi:ne180100]((uint64_t *)va, 0);
  _Unwind_Resume(a1);
}

uint64_t *std::__sort_heap[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*>(uint64_t *result, uint64_t a2, unsigned int (**a3)(uint64_t, uint64_t))
{
  if (a2 - (uint64_t)result >= 9)
  {
    unint64_t v4 = result;
    uint64_t v5 = (unint64_t)(a2 - (void)result) >> 3;
    uint64_t v6 = (uint64_t *)(a2 - 8);
    do
    {
      uint64_t v7 = *v4;
      *unint64_t v4 = 0;
      uint64_t v8 = std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*>(v4, a3, v5);
      unint64_t v9 = v8;
      if (v6 == v8)
      {
        uint64_t result = std::unique_ptr<NLMessageIntentCandidate>::reset[abi:ne180100](v8, v7);
      }
      else
      {
        uint64_t v10 = *v6;
        *uint64_t v6 = 0;
        std::unique_ptr<NLMessageIntentCandidate>::reset[abi:ne180100](v8, v10);
        std::unique_ptr<NLMessageIntentCandidate>::reset[abi:ne180100](v6, v7);
        uint64_t result = std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*>(v4, (uint64_t)(v9 + 1), (uint64_t (**)(uint64_t *, uint64_t))a3, v9 + 1 - v4);
      }
      --v6;
    }
    while (v5-- > 2);
  }
  return result;
}

void sub_1A43EB4FC(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__sort_heap[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*>(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*>(uint64_t *a1, unsigned int (**a2)(uint64_t, uint64_t), uint64_t a3)
{
  uint64_t v6 = 0;
  uint64_t v7 = a3 - 2;
  if (a3 < 2) {
    uint64_t v7 = a3 - 1;
  }
  uint64_t v8 = v7 >> 1;
  do
  {
    unint64_t v9 = &a1[v6 + 1];
    uint64_t v10 = (2 * v6) | 1;
    uint64_t v11 = 2 * v6 + 2;
    if (v11 < a3 && (*a2)((uint64_t)&a1[v6 + 1], (uint64_t)&a1[v6 + 2]))
    {
      ++v9;
      uint64_t v10 = v11;
    }
    uint64_t v12 = *v9;
    uint64_t *v9 = 0;
    std::unique_ptr<NLMessageIntentCandidate>::reset[abi:ne180100](a1, v12);
    a1 = v9;
    uint64_t v6 = v10;
  }
  while (v10 <= v8);
  return v9;
}

uint64_t *std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*>(uint64_t *result, uint64_t a2, uint64_t (**a3)(uint64_t *, uint64_t), uint64_t a4)
{
  unint64_t v4 = a4 - 2;
  if (a4 >= 2)
  {
    uint64_t v6 = result;
    unint64_t v7 = v4 >> 1;
    uint64_t v8 = &result[v4 >> 1];
    unint64_t v9 = (uint64_t *)(a2 - 8);
    uint64_t result = (uint64_t *)(*a3)(v8, a2 - 8);
    if (result)
    {
      uint64_t v10 = *v9;
      uint64_t *v9 = 0;
      uint64_t v15 = v10;
      do
      {
        uint64_t v11 = v8;
        uint64_t v12 = *v8;
        uint64_t *v8 = 0;
        std::unique_ptr<NLMessageIntentCandidate>::reset[abi:ne180100](v9, v12);
        if (!v7) {
          break;
        }
        unint64_t v7 = (v7 - 1) >> 1;
        uint64_t v8 = &v6[v7];
        unint64_t v9 = v11;
      }
      while (((*a3)(v8, (uint64_t)&v15) & 1) != 0);
      uint64_t v13 = v15;
      uint64_t v15 = 0;
      uint64_t result = std::unique_ptr<NLMessageIntentCandidate>::reset[abi:ne180100](v11, v13);
      uint64_t v14 = v15;
      uint64_t v15 = 0;
      if (v14)
      {
        std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table(v14 + 8);
        return (uint64_t *)MEMORY[0x1A625B130](v14, 0x10A0C4042D94C91);
      }
    }
  }
  return result;
}

void sub_1A43EB6B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<NLMessageIntentCandidate>::reset[abi:ne180100]((uint64_t *)va, 0);
  _Unwind_Resume(a1);
}

uint64_t NL::ParseFormatter::ParseFormatter(uint64_t a1, uint64_t *a2, void *a3)
{
  uint64_t v5 = *a2;
  uint64_t v4 = a2[1];
  *(void *)a1 = &unk_1EF7CDCF8;
  *(void *)(a1 + 8) = v5;
  *(void *)(a1 + 16) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = a3[1];
  *(void *)(a1 + 24) = *a3;
  *(void *)(a1 + 32) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 4nlp::CFScopedPtr<__CFString const*>::reset(this + 1, 0) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 84) = 0u;
  NL::DateFormatter::DateFormatter(a1 + 104);
  CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  nlp::CFScopedPtr<__CFArray *>::reset((const void **)(a1 + 56), Mutable);
  CFMutableArrayRef v9 = CFArrayCreateMutable(v7, 0, MEMORY[0x1E4F1D510]);
  nlp::CFScopedPtr<__CFArray *>::reset((const void **)(a1 + 64), v9);
  CFMutableDictionaryRef v10 = CFDictionaryCreateMutable(v7, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  nlp::CFScopedPtr<__CFDictionary *>::reset((const void **)(a1 + 72), v10);
  CFMutableDictionaryRef v11 = CFDictionaryCreateMutable(v7, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  nlp::CFScopedPtr<__CFDictionary *>::reset((const void **)(a1 + 80), v11);
  CFMutableDictionaryRef v12 = CFDictionaryCreateMutable(v7, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  nlp::CFScopedPtr<__CFDictionary *>::reset((const void **)(a1 + 88), v12);
  NL::ParseFormatter::reset((const void **)a1);
  return a1;
}

void sub_1A43EB864(_Unwind_Exception *a1)
{
  nlp::CFScopedPtr<__CFDictionary *>::reset(v7, 0);
  nlp::CFScopedPtr<__CFDictionary *>::reset(v6, 0);
  nlp::CFScopedPtr<__CFDictionary *>::reset(v5, 0);
  nlp::CFScopedPtr<__CFArray *>::reset(v4, 0);
  nlp::CFScopedPtr<__CFArray *>::reset(v3, 0);
  nlp::CFScopedPtr<__CFString const*>::reset(v2, 0);
  CFMutableArrayRef v9 = *(std::__shared_weak_count **)(v1 + 32);
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v9);
  }
  CFMutableDictionaryRef v10 = *(std::__shared_weak_count **)(v1 + 16);
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
  _Unwind_Resume(a1);
}

void NL::ParseFormatter::reset(const void **this)
{
  nlp::CFScopedPtr<__CFString const*>::reset(this + 5, &stru_1EF7CF078);
  *((_DWORD *)this + 12) = 0;
  uint64_t v2 = (__CFArray *)this[7];
  if (v2) {
    CFArrayRemoveAllValues(v2);
  }
  uint64_t v3 = (__CFArray *)this[8];
  if (v3) {
    CFArrayRemoveAllValues(v3);
  }
  uint64_t v4 = (__CFDictionary *)this[9];
  if (v4) {
    CFDictionaryRemoveAllValues(v4);
  }
  uint64_t v5 = (__CFDictionary *)this[10];
  if (v5) {
    CFDictionaryRemoveAllValues(v5);
  }
  uint64_t v6 = (__CFDictionary *)this[11];
  if (v6) {
    CFDictionaryRemoveAllValues(v6);
  }
  *((_DWORD *)this + 24) = *((_DWORD *)this[1] + 10);
}

void NL::ParseFormatter::~ParseFormatter(const void **this)
{
  *this = &unk_1EF7CDCF8;
  nlp::CFScopedPtr<__CFDateFormatter *>::reset(this + 17, 0);
  nlp::CFScopedPtr<__CFDateFormatter *>::reset(this + 16, 0);
  nlp::CFScopedPtr<__CFDateFormatter *>::reset(this + 15, 0);
  uint64_t v2 = (std::__shared_weak_count *)this[14];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  nlp::CFScopedPtr<__CFDictionary *>::reset(this + 11, 0);
  nlp::CFScopedPtr<__CFDictionary *>::reset(this + 10, 0);
  nlp::CFScopedPtr<__CFDictionary *>::reset(this + 9, 0);
  nlp::CFScopedPtr<__CFArray *>::reset(this + 8, 0);
  nlp::CFScopedPtr<__CFArray *>::reset(this + 7, 0);
  nlp::CFScopedPtr<__CFString const*>::reset(this + 5, 0);
  uint64_t v3 = (std::__shared_weak_count *)this[4];
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)this[2];
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
}

{
  uint64_t vars8;

  NL::ParseFormatter::~ParseFormatter(this);

  JUMPOUT(0x1A625B130);
}

__CFDictionary *NL::ParseFormatter::copyFormattedResult(NL::ParseFormatter *this, char a2)
{
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v6 = Mutable;
  if (!Mutable) {
    return v6;
  }
  CFDictionarySetValue(Mutable, @"String", *((const void **)this + 5));
  key = 0;
  CFArrayRef v7 = (const __CFArray *)*((void *)this + 7);
  if (v7 && CFArrayGetCount(v7))
  {
    CFArrayRef v8 = (const __CFArray *)*((void *)this + 7);
    if (v8 && CFArrayGetCount(*((CFArrayRef *)this + 7)))
    {
      if (CFArrayGetCount(v8) == 1)
      {
        CFMutableArrayRef v9 = (__CFString *)CFStringCreateByCombiningStrings(v4, v8, &stru_1EF7CF078);
      }
      else
      {
        CFMutableArrayRef v9 = CFStringCreateMutable(v4, 0);
        CFIndex Count = CFArrayGetCount(v8);
        if (Count >= 1)
        {
          for (CFIndex i = 0; i != Count; ++i)
          {
            if (CFStringGetLength(v9)) {
              CFStringAppend(v9, @" || ");
            }
            CFStringAppend(v9, @"(");
            CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v8, i);
            CFStringAppend(v9, ValueAtIndex);
            CFStringAppend(v9, @""));
          }
        }
      }
    }
    else
    {
      CFMutableArrayRef v9 = 0;
    }
    key = v9;
    if (v9) {
      goto LABEL_10;
    }
    goto LABEL_45;
  }
  NL::QueryTokenizer::description(*((NL::QueryTokenizer **)this + 3), &__p);
  CFStringRef CFStringFromString = (__CFString *)createCFStringFromString((uint64_t)&__p);
  CFMutableArrayRef v9 = CFStringFromString;
  key = CFStringFromString;
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (CFStringFromString) {
      goto LABEL_10;
    }
    goto LABEL_45;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  if (!v9)
  {
LABEL_45:
    CFMutableArrayRef v9 = &stru_1EF7CF078;
    key = &stru_1EF7CF078;
  }
LABEL_10:
  if (CFPreferencesGetAppBooleanValue(@"NLSearchEnableLogging", (CFStringRef)*MEMORY[0x1E4F1D3B8], 0))
  {
    CFMutableDictionaryRef v11 = _nlpDefaultLog();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG)) {
      NL::ParseFormatter::copyFormattedResult((uint64_t)v9, v11);
    }
  }
  CFDictionarySetValue(v6, @"Parse", v9);
  CFDictionaryRef v12 = (const __CFDictionary *)*((void *)this + 11);
  if (v12 && CFDictionaryGetCount(v12)) {
    CFDictionarySetValue(v6, @"ResultModifier", *((const void **)this + 11));
  }
  CFNumberRef v13 = CFNumberCreate(v4, kCFNumberSInt32Type, (char *)this + 48);
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v13;
  if (v13) {
    CFDictionarySetValue(v6, @"Confidence", v13);
  }
  if ((a2 & 4) != 0)
  {
    CFArrayRef v14 = (const __CFArray *)*((void *)this + 8);
    if (v14)
    {
      if (!CFArrayGetCount(v14))
      {
        CFAttributedStringRef v15 = CFAttributedStringCreate(v4, *((CFStringRef *)this + 5), 0);
        CFIndex valuePtr = (CFIndex)v15;
        if (v15)
        {
          CFArrayAppendValue(*((CFMutableArrayRef *)this + 8), v15);
          CFRelease(v15);
        }
      }
      CFArrayRef Copy = CFArrayCreateCopy(v4, *((CFArrayRef *)this + 8));
      CFIndex valuePtr = (CFIndex)Copy;
      if (Copy)
      {
        CFDictionarySetValue(v6, @"AttributedInput", Copy);
        CFRelease(Copy);
      }
    }
  }
  if ((a2 & 2) != 0)
  {
    CFDictionaryRef v17 = (const __CFDictionary *)*((void *)this + 9);
    if (v17)
    {
      if (*((int *)this + 12) >= 1)
      {
        uint64_t v18 = key;
        int v19 = CFDictionaryContainsKey(*((CFDictionaryRef *)this + 9), key);
        CFDictionaryRef v17 = (const __CFDictionary *)*((void *)this + 9);
        if (!v19)
        {
          CFIndex valuePtr = CFDictionaryGetCount(v17) + 200;
          CFNumberRef v20 = CFNumberCreate(v4, kCFNumberCFIndexType, &valuePtr);
          if (v20)
          {
            CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 9), v18, v20);
            CFRelease(v20);
          }
          CFDictionaryRef v17 = (const __CFDictionary *)*((void *)this + 9);
        }
      }
      CFDictionaryRef v21 = CFDictionaryCreateCopy(v4, v17);
      CFIndex valuePtr = (CFIndex)v21;
      if (v21)
      {
        CFDictionarySetValue(v6, @"RankTerms", v21);
        CFRelease(v21);
      }
    }
  }
  if ((a2 & 8) != 0)
  {
    CFDictionaryRef v22 = (const __CFDictionary *)*((void *)this + 10);
    if (v22)
    {
      CFDictionaryRef v23 = CFDictionaryCreateCopy(v4, v22);
      CFIndex valuePtr = (CFIndex)v23;
      if (v23)
      {
        CFDictionarySetValue(v6, @"RankCategories", v23);
        CFRelease(v23);
      }
    }
  }
  if (v13) {
    CFRelease(v13);
  }
  if (key) {
    CFRelease(key);
  }
  return v6;
}

void sub_1A43EBE64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, const void *a17)
{
}

BOOL NL::ParseFormatter::updateAttributedParseForAttributeWithEntity(uint64_t a1, __CFAttributedString *a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned __int8 *a6)
{
  BOOL v6 = 0;
  if (!a2 || *(_DWORD *)(a4 + 112) != 1) {
    return v6;
  }
  uint64_t v12 = *(void *)(a4 + 128);
  CFMutableDictionaryRef v11 = *(std::__shared_weak_count **)(a4 + 136);
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  BOOL v6 = v12 != 0;
  if (v12)
  {
    memset(v36, 0, sizeof(v36));
    memset(v35, 0, sizeof(v35));
    long long v13 = *(_OWORD *)(v12 + 172);
    v34[0] = *(_OWORD *)(v12 + 156);
    v34[1] = v13;
    long long v14 = *(_OWORD *)(v12 + 204);
    int v15 = *(_DWORD *)(a3 + 40);
    v34[2] = *(_OWORD *)(v12 + 188);
    v34[3] = v14;
    if ((v15 - 1) > 6) {
      int v16 = 0;
    }
    else {
      int v16 = dword_1A43F82E0[v15 - 1];
    }
    int v33 = v16;
    int valuePtr = *(_DWORD *)(v12 + 24);
    if (*(unsigned char *)(v12 + 240))
    {
      BOOL v17 = 1;
    }
    else
    {
      std::string::basic_string[abi:ne180100]<0>(__p, "Ambiguous");
      BOOL v17 = startswith(a6, (unsigned __int8 *)__p);
      if (v31 < 0) {
        operator delete(__p[0]);
      }
      int v15 = *(_DWORD *)(a3 + 40);
    }
    NL::DatePeriod::resolveDateComponents((NL::DatePeriod *)v12, (NL::DateComponents *)v36, (NL::DateComponents *)v35, v15, v17);
    if (*(unsigned char *)(a3 + 39))
    {
      int valuePtr = 42;
      CFNumberRef v18 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
      __p[0] = v18;
      if (v18)
      {
        CFAttributedStringSetAttribute(a2, *(CFRange *)(a3 + 16), @"kNLDateType", v18);
        CFRelease(v18);
      }
      goto LABEL_44;
    }
    int v19 = (NL::DateFormatter *)(a1 + 104);
    CFNumberRef v20 = NL::DateFormatter::copyDisplayForDate((__CFDateFormatter **)(a1 + 104), (const NL::DatePeriod *)v12, *(_DWORD *)(a3 + 40), v17);
    __p[0] = v20;
    if (v20) {
      CFAttributedStringSetAttribute(a2, *(CFRange *)(a3 + 16), @"kNLDisplayDate", v20);
    }
    CFTypeRef value = NL::DateFormatter::copyComponentsForDateComponents(v19, (const NL::DateComponents *)v36);
    CFDictionaryRef v21 = NL::DateFormatter::copyComponentsForDateComponents(v19, (const NL::DateComponents *)v34);
    if ((unint64_t)value | (unint64_t)v21)
    {
      CFDictionaryRef v22 = NL::DateFormatter::copyComponentsForDateComponents(v19, (const NL::DateComponents *)v35);
    }
    else
    {
      CFDictionaryRef v23 = NL::DateFormatter::copyComponentsForDateComponents(v19, (const NL::DateComponents *)v35);
      nlp::CFScopedPtr<__CFDictionary const*>::reset(&value, v23);
      CFDictionaryRef v22 = 0;
    }
    if (value)
    {
      CFRange v24 = *(CFRange *)(a3 + 16);
      if (v22 && !v21)
      {
        CFAttributedStringSetAttribute(a2, v24, @"kNLStartDateComponents", value);
LABEL_27:
        CFAttributedStringSetAttribute(a2, *(CFRange *)(a3 + 16), @"kNLEndDateComponents", v22);
        goto LABEL_28;
      }
      CFAttributedStringSetAttribute(a2, v24, @"kNLDateComponents", value);
      if (v22) {
        goto LABEL_27;
      }
    }
LABEL_28:
    if (v21) {
      CFAttributedStringSetAttribute(a2, *(CFRange *)(a3 + 16), @"kNLFrequencyDateComponents", v21);
    }
    CFAllocatorRef v25 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFNumberRef v26 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
    if (v26) {
      CFAttributedStringSetAttribute(a2, *(CFRange *)(a3 + 16), @"kNLDateType", v26);
    }
    CFNumberRef v27 = CFNumberCreate(v25, kCFNumberIntType, &v33);
    if (v27)
    {
      CFAttributedStringSetAttribute(a2, *(CFRange *)(a3 + 16), @"kNLDateModifier", v27);
      CFRelease(v27);
    }
    if (v26) {
      CFRelease(v26);
    }
    if (v21) {
      CFRelease(v21);
    }
    if (v22) {
      CFRelease(v22);
    }
    if (value) {
      CFRelease(value);
    }
    if (v20) {
      CFRelease(v20);
    }
  }
LABEL_44:
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v11);
  }
  return v6;
}

void sub_1A43EC2C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, const void *a11, const void *a12, const void *a13, const void *a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  nlp::CFScopedPtr<__CFNumber const*>::reset(&a10, 0);
  nlp::CFScopedPtr<__CFNumber const*>::reset(&a11, 0);
  nlp::CFScopedPtr<__CFDictionary const*>::reset(&a12, 0);
  nlp::CFScopedPtr<__CFDictionary const*>::reset(&a13, 0);
  nlp::CFScopedPtr<__CFDictionary const*>::reset(&a14, 0);
  nlp::CFScopedPtr<__CFString const*>::reset((const void **)&__p, 0);
  if (v20) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v20);
  }
  _Unwind_Resume(a1);
}

const __CFArray *NL::ParseFormatter::updateCurrentParsesForAttributeWithEntity(NL::ParseFormatter *this, __CFArray *a2, const NL::ParseAttribute *a3, const NL::Entity *a4)
{
  CFArrayRef v4 = a2;
  if (a2)
  {
    uint64_t v22 = 0;
    CFDictionaryRef v23 = &v22;
    uint64_t v24 = 0x2000000000;
    char v25 = 0;
    CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    CFArrayRef v21 = Mutable;
    CFIndex Count = CFArrayGetCount(v4);
    if (Count >= 1)
    {
      for (CFIndex i = 0; i != Count; ++i)
      {
        uint64_t v15 = 0;
        int v16 = &v15;
        uint64_t v17 = 0x3002000000;
        CFNumberRef v18 = __Block_byref_object_copy__18;
        int v19 = __Block_byref_object_dispose__18;
        CFAttributedStringRef ValueAtIndex = (const __CFAttributedString *)CFArrayGetValueAtIndex(v4, i);
        CFTypeRef cf = CFAttributedStringCreateMutableCopy(v6, 0, ValueAtIndex);
        v14[0] = MEMORY[0x1E4F143A8];
        v14[1] = 0x40000000;
        void v14[2] = ___ZN2NL14ParseFormatter41updateCurrentParsesForAttributeWithEntityEP9__CFArrayRKNS_14ParseAttributeERKNS_6EntityE_block_invoke;
        v14[3] = &unk_1E5B36560;
        v14[4] = &v22;
        uint64_t v14[5] = &v15;
        v14[6] = this;
        v14[7] = a3;
        v14[8] = a4;
        NL::ParseAttribute::enumerateParseNamesWithType((uint64_t)a3, (uint64_t)v14);
        v26.CFIndex length = CFArrayGetCount(Mutable);
        v26.CFIndex location = 0;
        if (!CFArrayContainsValue(Mutable, v26, (const void *)v16[5])) {
          CFArrayAppendValue(Mutable, (const void *)v16[5]);
        }
        _Block_object_dispose(&v15, 8);
        if (cf) {
          CFRelease(cf);
        }
      }
    }
    CFArrayRemoveAllValues(v4);
    v27.CFIndex length = CFArrayGetCount(Mutable);
    v27.CFIndex location = 0;
    CFArrayAppendArray(v4, Mutable, v27);
    CFArrayRef v4 = (const __CFArray *)(*((unsigned char *)v23 + 24) != 0);
    if (Mutable) {
      CFRelease(Mutable);
    }
    _Block_object_dispose(&v22, 8);
  }
  return v4;
}

void sub_1A43EC5C8(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__18(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a2 + 4nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)&__p, 0) = 0;
  *(void *)(result + 4nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)&__p, 0) = v2;
  return result;
}

BOOL ___ZN2NL14ParseFormatter41updateCurrentParsesForAttributeWithEntityEP9__CFArrayRKNS_14ParseAttributeERKNS_6EntityE_block_invoke(void *a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5)
{
  BOOL result = NL::ParseFormatter::updateAttributedParseForAttributeWithEntity(a1[6], *(__CFAttributedString **)(*(void *)(a1[5] + 8) + 40), a1[7], a1[8], a5, a3);
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = result;
  return result;
}

uint64_t NL::ParseFormatter::copyParseResult(uint64_t a1, uint64_t a2, uint64_t a3)
{
  NL::ParseFormatter::reset((const void **)a1);
  if (*(void *)(*(void *)a2 + 16) == *(void *)(*(void *)a2 + 8)
    || (CFStringRef v6 = *(const __CFString **)(*(void *)(a1 + 24) + 104)) == 0)
  {
    char v31 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 24);
    return v31(a1, a3);
  }
  else
  {
    CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v6);
    nlp::CFScopedPtr<__CFString const*>::reset((const void **)(a1 + 40), Copy);
    uint64_t v54 = 0;
    uint64_t v55 = &v54;
    uint64_t v56 = 0x3002000000;
    uint64_t v57 = __Block_byref_object_copy__48_0;
    uint64_t v58 = __Block_byref_object_dispose__49_0;
    CFMutableArrayRef v9 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
    CFMutableArrayRef Mutable = CFArrayCreateMutable(v7, 0, MEMORY[0x1E4F1D510]);
    uint64_t v48 = 0;
    CFIndex v49 = &v48;
    uint64_t v50 = 0x3002000000;
    CFAllocatorRef v51 = __Block_byref_object_copy__48_0;
    UniChar v52 = __Block_byref_object_dispose__49_0;
    CFMutableArrayRef v53 = CFArrayCreateMutable(v7, 0, v9);
    v46[0] = 0;
    v46[1] = v46;
    v46[2] = 0x3002000000;
    v46[3] = __Block_byref_object_copy__48_0;
    v46[4] = __Block_byref_object_dispose__49_0;
    CFTypeRef cf = CFArrayCreateMutable(v7, 0, MEMORY[0x1E4F1D510]);
    CFAttributedStringRef v45 = 0;
    uint64_t v41 = 0;
    uint64_t v42 = &v41;
    uint64_t v43 = 0x2000000000;
    char v44 = 0;
    uint64_t v10 = *(void *)(*(void *)a2 + 16) - *(void *)(*(void *)a2 + 8);
    if (v10 < 1)
    {
      CFAttributedStringRef v11 = 0;
    }
    else
    {
      CFAllocatorRef alloc = v7;
      CFAttributedStringRef v11 = 0;
      uint64_t v12 = 0;
      uint64_t v13 = (unint64_t)v10 >> 4;
      if (v13 <= 1) {
        uint64_t v13 = 1;
      }
      uint64_t v34 = v13;
      do
      {
        long long v14 = (uint64_t *)(*(void *)(*(void *)a2 + 8) + 16 * v12);
        uint64_t v38 = *v14;
        uint64_t v15 = (std::__shared_weak_count *)v14[1];
        if (v15) {
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v35 = v12;
        CFDictionaryRef v36 = v15;
        uint64_t v16 = *(void *)(v38 + 48) - *(void *)(v38 + 40);
        if (v16)
        {
          if (*((unsigned char *)v42 + 24))
          {
            int v17 = 2;
          }
          else
          {
            if (v16 >= 1)
            {
              uint64_t v18 = 0;
              uint64_t v19 = v16 >> 4;
              if (v19 <= 1) {
                uint64_t v19 = 1;
              }
              uint64_t v37 = v19;
              do
              {
                uint64_t v20 = *(void *)(v38 + 40) + 16 * v18;
                CFArrayRef v21 = *(uint64_t **)v20;
                uint64_t v22 = *(std::__shared_weak_count **)(v20 + 8);
                if (v22) {
                  atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                uint64_t v24 = *v21;
                uint64_t v23 = v21[1];
                while (v24 != v23)
                {
                  if (*(unsigned char *)(*(void *)v24 + 36))
                  {
                    if (CFArrayGetCount((CFArrayRef)v55[5]))
                    {
                      CFAttributedStringRef v25 = v11;
                    }
                    else
                    {
                      CFAttributedStringRef v25 = CFAttributedStringCreateMutable(alloc, 0);
                      if (v11) {
                        CFRelease(v11);
                      }
                      CFAttributedStringRef v45 = v25;
                      v61.CFIndex length = CFAttributedStringGetLength(v25);
                      v61.CFIndex location = 0;
                      CFAttributedStringReplaceString(v25, v61, *(CFStringRef *)(a1 + 40));
                      CFArrayAppendValue((CFMutableArrayRef)v55[5], v25);
                    }
                    CFRange v26 = *(void **)v24;
                    v40[0] = MEMORY[0x1E4F143A8];
                    v40[1] = 0x40000000;
                    v40[2] = ___ZN2NL14ParseFormatter15copyParseResultENSt3__110shared_ptrINS_12ParseIntentsEEEj_block_invoke;
                    v40[3] = &unk_1E5B373F0;
                    v40[4] = v46;
                    v40[5] = &v54;
                    v40[8] = a1;
                    v40[9] = v24;
                    v40[6] = &v41;
                    v40[7] = &v48;
                    NL::ParseAttribute::enumerateEntities(v26, (uint64_t)v40);
                    CFAttributedStringRef v11 = v25;
                  }
                  v24 += 16;
                }
                if (CFArrayGetCount((CFArrayRef)v49[5]))
                {
                  CFArrayRemoveAllValues((CFMutableArrayRef)v55[5]);
                  CFRange v27 = (__CFArray *)v55[5];
                  CFArrayRef v28 = (const __CFArray *)v49[5];
                  v62.CFIndex length = CFArrayGetCount(v28);
                  v62.CFIndex location = 0;
                  CFArrayAppendArray(v27, v28, v62);
                  CFArrayRemoveAllValues((CFMutableArrayRef)v49[5]);
                }
                if (v22) {
                  std::__shared_weak_count::__release_shared[abi:ne180100](v22);
                }
                ++v18;
              }
              while (v18 != v37);
            }
            if (CFArrayGetCount((CFArrayRef)v55[5]))
            {
              std::string v29 = *(__CFArray **)(a1 + 64);
              if (v29)
              {
                CFArrayRef v30 = (const __CFArray *)v55[5];
                v63.CFIndex length = CFArrayGetCount(v30);
                v63.CFIndex location = 0;
                CFArrayAppendArray(v29, v30, v63);
              }
            }
            int v17 = 0;
          }
        }
        else
        {
          int v17 = 4;
        }
        if (v36) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v36);
        }
        if ((v17 | 4) != 4) {
          break;
        }
        uint64_t v12 = v35 + 1;
      }
      while (v35 + 1 != v34);
    }
    int v33 = NL::ParseFormatter::copyFormattedResult((NL::ParseFormatter *)a1, a3);
    _Block_object_dispose(&v41, 8);
    if (v11) {
      CFRelease(v11);
    }
    _Block_object_dispose(v46, 8);
    if (cf) {
      CFRelease(cf);
    }
    _Block_object_dispose(&v48, 8);
    if (v53) {
      CFRelease(v53);
    }
    _Block_object_dispose(&v54, 8);
    if (Mutable) {
      CFRelease(Mutable);
    }
    return (uint64_t)v33;
  }
}

void sub_1A43ECBC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,const void *a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,const void *a39)
{
  _Block_object_dispose(&a29, 8);
  nlp::CFScopedPtr<__CFAttributedString *>::reset(&a33, 0);
  _Block_object_dispose(&a34, 8);
  nlp::CFScopedPtr<__CFArray *>::reset(&a39, 0);
  _Block_object_dispose((const void *)(v39 - 200), 8);
  nlp::CFScopedPtr<__CFArray *>::reset((const void **)(v39 - 160), 0);
  _Block_object_dispose((const void *)(v39 - 152), 8);
  nlp::CFScopedPtr<__CFArray *>::reset((const void **)(v39 - 112), 0);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__48_0(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a2 + 4nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)&__p, 0) = 0;
  *(void *)(result + 4nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)&__p, 0) = v2;
  return result;
}

void __Block_byref_object_dispose__49_0(uint64_t a1)
{
}

void ___ZN2NL14ParseFormatter15copyParseResultENSt3__110shared_ptrINS_12ParseIntentsEEEj_block_invoke(uint64_t a1, const NL::Entity *a2)
{
  CFArrayRef v4 = *(NL::ParseFormatter **)(a1 + 64);
  uint64_t v5 = *(__CFArray **)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  CFArrayRef v6 = *(const __CFArray **)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
  v11.CFIndex length = CFArrayGetCount(v6);
  v11.CFIndex location = 0;
  CFArrayAppendArray(v5, v6, v11);
  *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = NL::ParseFormatter::updateCurrentParsesForAttributeWithEntity(v4, *(__CFArray **)(*(void *)(*(void *)(a1 + 32) + 8)+ 40), **(const NL::ParseAttribute ***)(a1 + 72), a2);
  *((_DWORD *)v4 + 12) = 3;
  CFAllocatorRef v7 = *(__CFArray **)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
  CFArrayRef v8 = *(const __CFArray **)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  v12.CFIndex length = CFArrayGetCount(v8);
  v12.CFIndex location = 0;
  CFArrayAppendArray(v7, v8, v12);
  CFMutableArrayRef v9 = *(__CFArray **)(*(void *)(*(void *)(a1 + 32) + 8) + 40);

  CFArrayRemoveAllValues(v9);
}

__CFDictionary *NL::ParseFormatter::copyDefaultParseResult(const void **this, char a2)
{
  NL::ParseFormatter::reset(this);
  CFArrayRef v4 = (CFStringRef *)this[3];
  if (v4) {
    CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v4[13]);
  }
  else {
    CFStringRef Copy = &stru_1EF7CF078;
  }
  nlp::CFScopedPtr<__CFString const*>::reset(this + 5, Copy);

  return NL::ParseFormatter::copyFormattedResult((NL::ParseFormatter *)this, a2);
}

void nlp::CFScopedPtr<__CFAttributedString const*>::reset(const void **a1, const void *a2)
{
  CFArrayRef v4 = *a1;
  if (v4) {
    CFRelease(v4);
  }
  *a1 = a2;
}

void NLHindiCharLanguageModeler::NLHindiCharLanguageModeler(NLHindiCharLanguageModeler *this, CFDictionaryRef theDict)
{
  *((void *)this + 1) = 0;
  uint64_t v2 = (uint64_t *)((char *)this + 8);
  *(void *)this = &unk_1EF7CD630;
  *((void *)this + 2) = 0;
  if (theDict) {
    MutableCFStringRef Copy = CFDictionaryCreateMutableCopy(0, 0, theDict);
  }
  else {
    MutableCFStringRef Copy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
  CFArrayRef v4 = MutableCopy;
  CFDictionarySetValue(MutableCopy, (const void *)*MEMORY[0x1E4F723C8], @"hi");
  CFBundleRef BundleWithIdentifier = CFBundleGetBundleWithIdentifier(@"com.apple.NLP");
  if (v4)
  {
    if (BundleWithIdentifier)
    {
      CFBundleRef BundleWithIdentifier = CFBundleCopyResourcesDirectoryURL(BundleWithIdentifier);
      CFArrayRef v6 = BundleWithIdentifier;
      if (BundleWithIdentifier)
      {
        CFDictionarySetValue(v4, (const void *)*MEMORY[0x1E4F72380], BundleWithIdentifier);
        uint64_t *v2 = LMLanguageModelCreate();
        CFRelease(v6);
      }
    }
  }
  if (!*v2)
  {
    uint64_t v7 = NL::CFLogger::sharedInstance(BundleWithIdentifier);
    (*(void (**)(uint64_t, uint64_t, const char *))(*(void *)v7 + 16))(v7, 3, "Could not locate Hindi character language model");
  }
  if (v4) {
    CFRelease(v4);
  }
}

void sub_1A43ECF78(_Unwind_Exception *a1)
{
  NLAbstractLanguageModeler::~NLAbstractLanguageModeler(v1);
  _Unwind_Resume(a1);
}

double NLHindiCharLanguageModeler::logProbability(uint64_t a1)
{
  if (!*(void *)(a1 + 8)) {
    return -INFINITY;
  }
  LMLanguageModelJointProbability();
  return result;
}

double NLHindiCharLanguageModeler::logProbability(uint64_t a1, uint64_t *a2)
{
  stringToUTF32Characters(a2, (int **)__p);
  if (*(void *)(a1 + 8))
  {
    LMLanguageModelJointProbability();
    double v4 = v3;
  }
  else
  {
    double v4 = -INFINITY;
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  return v4;
}

void sub_1A43ED034(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void NLHindiCharLanguageModeler::~NLHindiCharLanguageModeler(NLHindiCharLanguageModeler *this)
{
  NLAbstractLanguageModeler::~NLAbstractLanguageModeler(this);

  JUMPOUT(0x1A625B130);
}

BOOL nlp::BurstTrieAdd(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (*(void *)(a1 + 2080) || (*(unsigned char *)(a1 + 2064) & 1) != 0) {
    return 0;
  }
  int v5 = 0;
  int v22 = 0;
  int v6 = a3 - 1;
  if ((a3 - 1) <= 0x3FE)
  {
    int v7 = a4;
    if (a4)
    {
      uint64_t v9 = 0;
      uint64_t v10 = (int *)a1;
      while (1)
      {
        uint64_t v11 = *(void *)&v10[2 * *(unsigned __int8 *)(a2 + v9) + 1];
        if ((v11 & 3) != 1) {
          break;
        }
        uint64_t v10 = (int *)(v11 & 0xFFFFFFFFFFFFFFFCLL);
        if (a3 == ++v9)
        {
          int v12 = *v10;
          int *v10 = a4;
          if (!v12) {
            goto LABEL_17;
          }
LABEL_18:
          int v5 = 1;
          return v5 != 0;
        }
      }
      if ((v11 & 3) != 2)
      {
        int v17 = (unsigned __int8 *)(a2 + v9);
        uint64_t v18 = (const void *)(a2 + v9 + 1);
        unsigned int v19 = v6 - v9;
        size_t v20 = (v6 - v9);
        unint64_t v21 = (unint64_t)malloc_type_calloc(1uLL, v20 + 15, 0x64AF1970uLL);
        memcpy((void *)(v21 + 14), v18, v20);
        *(unsigned char *)(v21 + 14 + v19) = 0;
        *(_WORD *)(v21 + 12) = v19;
        *(_DWORD *)(v21 + 8) = v7;
        *(void *)unint64_t v21 = 0;
        *(void *)&v10[2 * *v17 + 1] = v21 | 2;
        goto LABEL_17;
      }
      uint64_t v23 = (unsigned __int16 *)(v11 & 0xFFFFFFFFFFFFFFFCLL);
      unsigned int v14 = nlp::addListNode(a1, &v23, a2, a3, (int)v9 + 1, a4, &v22);
      unint64_t v15 = (unint64_t)v23;
      if (v14 >= *(_DWORD *)(a1 + 2088))
      {
        unint64_t v15 = (unint64_t)nlp::burstLevel(a1, v23, &v22);
        uint64_t v16 = 1;
      }
      else
      {
        uint64_t v16 = 2;
      }
      int v5 = v22;
      *(void *)&v10[2 * *(unsigned __int8 *)(a2 + v9) + 1] = v16 | v15;
      if (v5 == 2)
      {
LABEL_17:
        ++*(_DWORD *)(a1 + 2060);
        goto LABEL_18;
      }
    }
  }
  return v5 != 0;
}

uint64_t nlp::TrieCompletionGetCompletion(uint64_t a1)
{
  if (a1) {
    return a1 + 20;
  }
  else {
    return 0;
  }
}

uint64_t nlp::TrieCompletionGetLength(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 16);
  }
  return result;
}

BOOL nlp::BurstTrieAddWithScore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, float a7)
{
  v17[4] = *MEMORY[0x1E4F143B8];
  if (*(void *)(a1 + 2080) || (*(unsigned char *)(a1 + 2064) & 1) == 0) {
    return 0;
  }
  BOOL result = 0;
  int v16 = 0;
  if ((a3 - 1) <= 0x3FE && a4)
  {
    int v15 = 0;
    std::__function::__value_func<float ()(void *,float,float)>::__value_func[abi:ne180100]((uint64_t)v17, a6);
    nlp::addLevelRanked(a1, a1, a2, a3, 0, a4, (float *)&v15, &v16, a7, a5, (uint64_t)v17);
    std::__function::__value_func<float ()(void *,float,float)>::~__value_func[abi:ne180100](v17);
    int v14 = v16;
    if (v16 == 2) {
      ++*(_DWORD *)(a1 + 2060);
    }
    return v14 != 0;
  }
  return result;
}

void sub_1A43ED370(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::__function::__value_func<float ()(void *,float,float)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

double nlp::TrieCompletionGetScore(_DWORD *a1)
{
  if (!a1) {
    return 0.0;
  }
  LODWORD(result) = *a1;
  return result;
}

double nlp::BurstTrieCreateMutable(nlp *this)
{
  return nlp::BurstTrieCreateMutableWithOptions(64, 0);
}

double nlp::BurstTrieCreateMutableWithOptions(int a1, int a2)
{
  double v4 = (char *)malloc_type_calloc(1uLL, 0x838uLL, 0x105004014637929uLL);
  if (v4)
  {
    double result = 0.0;
    *(_OWORD *)(v4 + 206nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)&__p, 0) = 0u;
    *((_DWORD *)v4 + 519) = 1;
    *((void *)v4 + 26nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)&__p, 0) = 0;
    *(void *)(v4 + 2092) = 0x200000000;
    *((_DWORD *)v4 + 516) = a2;
    *((_DWORD *)v4 + 522) = a1;
  }
  return result;
}

char *nlp::burstTrieCreateWithBytes(char *this, const char *a2)
{
  if (this)
  {
    uint64_t v2 = this;
    if (*(_DWORD *)this == 12648430 || *(_DWORD *)this == -900339842)
    {
      int v4 = (int)a2;
      this = (char *)malloc_type_calloc(1uLL, 0x838uLL, 0x105004014637929uLL);
      *((void *)this + 26nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)&__p, 0) = v2;
      int v5 = v2[3];
      *(void *)(this + 2068) = v2[2];
      *((_DWORD *)this + 515) = v5;
      int v6 = v2[4];
      *((_DWORD *)this + 516) = v6;
      if (*v2 == -900339842) {
        *((_DWORD *)this + 516) = v6 | 1;
      }
      *((_DWORD *)this + 522) = v2[5];
      *((_DWORD *)this + 523) = v4;
      *((_DWORD *)this + 524) = 2;
      *((_DWORD *)this + 519) = 1;
    }
    else
    {
      return 0;
    }
  }
  return this;
}

void nlp::BurstTrieRelease(char *a1)
{
  if (a1)
  {
    int v2 = *((_DWORD *)a1 + 519) - 1;
    *((_DWORD *)a1 + 519) = v2;
    if (!v2)
    {
      double v3 = (void *)*((void *)a1 + 260);
      if (v3)
      {
        if (*((_DWORD *)a1 + 523)) {
          munmap(v3, *(void *)(a1 + 2068));
        }
      }
      else if (a1[2064])
      {
        nlp::finishLevel<nlp::_RankedTrieLevel *,nlp::_RankedListNode *>((uint64_t)a1);
      }
      else
      {
        nlp::finishLevel<nlp::_TrieLevel *,nlp::_ListNode *>((uint64_t)a1);
      }
      free(a1);
    }
  }
}

char *nlp::BurstTrieCreateWithBytes(nlp *this, const char *a2)
{
  return nlp::burstTrieCreateWithBytes((char *)this, 0);
}

uint64_t nlp::BurstTrieGetCount(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 2060);
  }
  return result;
}

void nlp::BurstTrieSearch(nlp *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  v18[4] = *MEMORY[0x1E4F143B8];
  if (a6 < 0)
  {
    unint64_t v15 = 0xFFFFFFFF00000003;
    int v16 = 0;
    uint64_t v17 = a4;
    std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v18, a5);
    nlp::searchWithContext(a1, a2, a3, 0, (uint64_t)&v15);
    std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL *)>::~__value_func[abi:ne180100](v18);
  }
  else
  {
    CursorWithBytes = (nlp *)nlp::BurstTrieCreateCursorWithBytes((uint64_t)a1, (unsigned __int8 *)a2, a3);
    if (CursorWithBytes)
    {
      int v12 = CursorWithBytes;
      uint64_t v13 = operator new(0x20uLL);
      *uint64_t v13 = &unk_1EF7CDF60;
      v13[1] = a2;
      *((_DWORD *)v13 + 4) = a3;
      void v13[3] = a5;
      v14[3] = v13;
      nlp::BurstTrieTraverseFromCursor(v12, 0, (uint64_t)v14, a6);
      std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::~__value_func[abi:ne180100](v14);
      free(v12);
    }
  }
}

void sub_1A43ED6BC(_Unwind_Exception *a1)
{
  std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL *)>::~__value_func[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t nlp::addLevelRanked(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, uint64_t a6, float *a7, int *a8, float a9, uint64_t a10, uint64_t a11)
{
  float v13 = a9;
  v32[4] = *MEMORY[0x1E4F143B8];
  if (a5 >= a4)
  {
    *a8 = 2;
    if (*(_DWORD *)(a2 + 8))
    {
      *a8 = 1;
      if (*(void *)(a11 + 24))
      {
        double result = std::function<float ()(void *,float,float)>::operator()(a11, a10, *(float *)(a2 + 4), a9);
        float v13 = v21;
      }
    }
    *(float *)(a2 + 4) = v13;
    *(_DWORD *)(a2 + 8) = a6;
    *a7 = v13;
  }
  else
  {
    uint64_t v19 = result;
    std::string v29 = (unsigned __int8 *)(a3 + a5);
    uint64_t v20 = *(void *)(a2 + 8 * *v29 + 12);
    if ((v20 & 3) == 2)
    {
      CFArrayRef v30 = (unsigned __int16 *)(v20 & 0xFFFFFFFFFFFFFFFCLL);
      std::__function::__value_func<float ()(void *,float,float)>::__value_func[abi:ne180100]((uint64_t)v31, a11);
      unsigned int v22 = nlp::addListNodeRanked(v19, (uint64_t **)&v30, a3, a4, a5 + 1, a6, a7, a8, v13, a10, (uint64_t)v31);
      double result = (uint64_t)std::__function::__value_func<float ()(void *,float,float)>::~__value_func[abi:ne180100](v31);
      unint64_t v23 = (unint64_t)v30;
      if (v22 >= *(_DWORD *)(v19 + 2088))
      {
        double result = (uint64_t)nlp::burstLevelRanked(v19, v30, a7, a8);
        unint64_t v23 = result;
        uint64_t v24 = 1;
      }
      else
      {
        uint64_t v24 = 2;
      }
      uint64_t v28 = v24 | v23;
      CFAttributedStringRef v25 = v29;
    }
    else
    {
      if ((v20 & 3) == 1)
      {
        std::__function::__value_func<float ()(void *,float,float)>::__value_func[abi:ne180100]((uint64_t)v32, a11);
        nlp::addLevelRanked(v19, v20 & 0xFFFFFFFFFFFFFFFCLL, a3, a4, a5 + 1, a6, a7, a8, v13, a10, v32);
        double result = (uint64_t)std::__function::__value_func<float ()(void *,float,float)>::~__value_func[abi:ne180100](v32);
        goto LABEL_15;
      }
      *a7 = a9;
      CFAttributedStringRef v25 = (unsigned __int8 *)(a3 + a5);
      size_t v26 = ~a5 + a4;
      unint64_t v27 = (unint64_t)malloc_type_calloc(1uLL, v26 + 23, 0x35949B46uLL);
      double result = (uint64_t)memcpy((void *)(v27 + 22), v29 + 1, v26);
      *(unsigned char *)(v27 + 22 + v26) = 0;
      *(_WORD *)(v27 + 2nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)&__p, 0) = v26;
      *(_DWORD *)(v27 + 16) = a6;
      *(float *)(v27 + 8) = v13;
      *(float *)(v27 + 12) = v13;
      *(void *)unint64_t v27 = 0;
      uint64_t v28 = v27 | 2;
      *a8 = 2;
    }
    *(void *)(a2 + 8 * *v25 + 12) = v28;
  }
LABEL_15:
  if (*a7 > *(float *)a2) {
    *(float *)a2 = *a7;
  }
  return result;
}

void sub_1A43ED94C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  std::__function::__value_func<float ()(void *,float,float)>::~__value_func[abi:ne180100](va);
  _Unwind_Resume(a1);
}

uint64_t nlp::BurstTrieRemove(_DWORD *a1, char *a2, int a3)
{
  uint64_t result = 0;
  uint64_t v119 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return result;
  }
  int v5 = a2;
  if (!a2 || !a3) {
    return result;
  }
  if ((a1[516] & 1) == 0)
  {
    int v7 = operator new(8uLL);
    uint64_t v8 = 0;
    *int v7 = a1;
    uint64_t v9 = (char *)(v7 + 1);
    unint64_t v105 = (char *)(v7 + 1);
    std::string __p = v7;
    uint64_t v103 = (char *)(v7 + 1);
    uint64_t v10 = a1;
    while (1)
    {
      uint64_t v11 = &v10[2 * v5[v8]];
      uint64_t v14 = *(void *)(v11 + 1);
      float v13 = (uint64_t *)(v11 + 1);
      uint64_t v12 = v14;
      uint64_t v15 = v14 & 3;
      if ((v14 & 3) == 0) {
        goto LABEL_62;
      }
      if (v15 == 2) {
        break;
      }
      uint64_t v10 = (_DWORD *)(v12 & 0xFFFFFFFFFFFFFFFCLL);
      if (v9 >= v105)
      {
        uint64_t v16 = (v9 - (char *)__p) >> 3;
        if ((unint64_t)(v16 + 1) >> 61) {
          std::vector<NLExtendedString>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v17 = (v105 - (char *)__p) >> 2;
        if (v17 <= v16 + 1) {
          unint64_t v17 = v16 + 1;
        }
        if ((unint64_t)(v105 - (char *)__p) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v18 = v17;
        }
        if (v18) {
          uint64_t v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NLTransliterationCandidate *>>((uint64_t)&v105, v18);
        }
        else {
          uint64_t v19 = 0;
        }
        uint64_t v20 = &v19[8 * v16];
        *(void *)uint64_t v20 = v10;
        uint64_t v9 = v20 + 8;
        float v21 = v103;
        if (v103 != (char *)__p)
        {
          do
          {
            uint64_t v22 = *((void *)v21 - 1);
            v21 -= 8;
            *((void *)v20 - 1) = v22;
            v20 -= 8;
          }
          while (v21 != (char *)__p);
          float v21 = (char *)__p;
        }
        std::string __p = (unint64_t *)v20;
        unint64_t v105 = &v19[8 * v18];
        if (v21) {
          operator delete(v21);
        }
      }
      else
      {
        *(void *)uint64_t v9 = v10;
        v9 += 8;
      }
      uint64_t v103 = v9;
      if (++v8 == a3)
      {
        if (!*v10) {
          goto LABEL_62;
        }
        _DWORD *v10 = 0;
LABEL_70:
        if ((unint64_t)(v103 - (char *)__p) < 0x10) {
          goto LABEL_131;
        }
        uint64_t v58 = (v103 - (char *)__p) >> 3;
        unsigned int v109 = 0;
        uint64_t v59 = v58 - 1;
        if (v58 == 1) {
          goto LABEL_131;
        }
        LOBYTE(v6nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)&__p, 0) = 0;
        unint64_t v61 = a1[522];
        while (1)
        {
          CFRange v62 = (nlp *)nlp::burstTrieCreateCursorWithTrieLevelRef<nlp::_TrieLevel *>((uint64_t)a1, __p[v59]);
          unsigned int v109 = 0;
          v116 = &unk_1EF7CE010;
          v117 = &v109;
          v118 = &v116;
          nlp::BurstTrieTraverseFromCursor(v62, 0, (uint64_t)&v116, -1);
          std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::~__value_func[abi:ne180100](&v116);
          if (v62) {
            free(v62);
          }
          if (v109 >= v61) {
            break;
          }
          uint64_t v60 = 1;
          if (!--v59) {
            goto LABEL_89;
          }
        }
        if ((v60 & 1) == 0) {
          goto LABEL_131;
        }
        uint64_t v60 = v59 + 1;
LABEL_89:
        uint64_t v106 = 0;
        uint64_t v107 = 0;
        uint64_t v108 = 0;
        std::vector<std::tuple<std::string,unsigned int,float>>::reserve(&v106, v61);
        unint64_t v68 = __p[v60];
        CFRange v69 = (nlp *)nlp::burstTrieCreateCursorWithTrieLevelRef<nlp::_TrieLevel *>((uint64_t)a1, v68);
        v113 = &unk_1EF7CDFB8;
        uint64_t v114 = &v106;
        v115 = &v113;
        nlp::BurstTrieTraverseFromCursor(v69, 0, (uint64_t)&v113, -1);
        std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::~__value_func[abi:ne180100](&v113);
        if (v61 <= (v107 - v106) >> 5) {
          __assert_rtn("reverseBurst", "BurstTrie.cpp", 965, "items.size() < sizeThreshold");
        }
        if (v69) {
          free(v69);
        }
        nlp::finishLevel<nlp::_TrieLevel *,nlp::_ListNode *>(v68);
        a1[515] -= (unint64_t)(v107 - v106) >> 5;
        *(void *)(__p[v59] + 8 * v5[v59] + 4) = 0;
        if ((a3 + 1) < (unint64_t)((v103 - (char *)__p) >> 3)) {
          __assert_rtn("reverseBurst", "BurstTrie.cpp", 974, "levels.size() <= keyLen + 1");
        }
        CFStringRef v71 = nlp::sharedBuffer(v70);
        uint64_t v72 = (uint64_t)v71;
        if (v60)
        {
          std::string v73 = v71;
          uint64_t v74 = v60;
          do
          {
            char v75 = *v5++;
            *v73++ = v75;
            --v74;
          }
          while (v74);
        }
        uint64_t v76 = v106;
        uint64_t v77 = v107;
        if (v106 != v107)
        {
          int v78 = a1[516];
          do
          {
            if (*(char *)(v76 + 23) < 0)
            {
              std::string v80 = *(const void **)v76;
              size_t v79 = *(void *)(v76 + 8);
            }
            else
            {
              size_t v79 = *(unsigned __int8 *)(v76 + 23);
              std::string v80 = (const void *)v76;
            }
            uint64_t v81 = *(unsigned int *)(v76 + 24);
            float v82 = *(float *)(v76 + 28);
            memcpy((void *)(v72 + v60), v80, v79);
            if (*(char *)(v76 + 23) < 0) {
              uint64_t v83 = *(void *)(v76 + 8);
            }
            else {
              LODWORD(v83) = *(unsigned __int8 *)(v76 + 23);
            }
            uint64_t v84 = (v83 + v60);
            if (v78)
            {
              uint64_t v112 = 0;
              nlp::BurstTrieAddWithScore((uint64_t)a1, v72, v84, v81, 0, (uint64_t)v111, v82);
              std::__function::__value_func<float ()(void *,float,float)>::~__value_func[abi:ne180100](v111);
            }
            else
            {
              nlp::BurstTrieAdd((uint64_t)a1, v72, v84, v81);
            }
            v76 += 32;
          }
          while (v76 != v77);
        }
        goto LABEL_130;
      }
    }
    uint64_t v39 = &v5[v8 + 1];
    int v40 = ~v8 + a3;
    uint64_t v41 = (uint64_t *)(v12 & 0xFFFFFFFFFFFFFFFCLL);
    size_t v42 = *(unsigned __int16 *)((v12 & 0xFFFFFFFFFFFFFFFCLL) + 12);
    if (v40 == v42 && !memcmp(v39, (char *)v41 + 14, v42))
    {
      uint64_t v54 = *v41;
      free(v41);
      uint64_t v55 = v54 | 2;
      if (!v54) {
        uint64_t v55 = 0;
      }
      *float v13 = v55;
    }
    else
    {
      uint64_t v43 = *v41;
      if (!*v41) {
        goto LABEL_62;
      }
      while (1)
      {
        char v44 = (uint64_t *)v43;
        size_t v45 = *(unsigned __int16 *)(v43 + 12);
        if (v40 == v45 && !memcmp(v39, (const void *)(v43 + 14), v45)) {
          break;
        }
        uint64_t v43 = *v44;
        uint64_t v41 = v44;
        if (!*v44) {
          goto LABEL_62;
        }
      }
      *uint64_t v41 = *v44;
      free(v44);
    }
    goto LABEL_70;
  }
  unint64_t v23 = (unint64_t *)operator new(8uLL);
  uint64_t v24 = 0;
  unint64_t *v23 = (unint64_t)a1;
  CFAttributedStringRef v25 = v23 + 1;
  unint64_t v105 = (char *)(v23 + 1);
  std::string __p = v23;
  std::string v104 = v23 + 1;
  unint64_t v26 = (unint64_t)a1;
  do
  {
    unint64_t v27 = v26 + 8 * v5[v24];
    uint64_t v30 = *(void *)(v27 + 12);
    std::string v29 = (uint64_t *)(v27 + 12);
    uint64_t v28 = v30;
    uint64_t v31 = v30 & 3;
    if ((v30 & 3) == 0) {
      goto LABEL_62;
    }
    if (v31 == 2)
    {
      uint64_t v46 = &v5[v24 + 1];
      int v47 = ~v24 + a3;
      uint64_t v48 = (uint64_t *)(v28 & 0xFFFFFFFFFFFFFFFCLL);
      size_t v49 = *(unsigned __int16 *)((v28 & 0xFFFFFFFFFFFFFFFCLL) + 20);
      if (v47 == v49 && !memcmp(v46, (char *)v48 + 22, v49))
      {
        uint64_t v56 = *v48;
        free(v48);
        uint64_t v57 = v56 | 2;
        if (!v56) {
          uint64_t v57 = 0;
        }
        *std::string v29 = v57;
        goto LABEL_79;
      }
      uint64_t v50 = *v48;
      if (*v48)
      {
        while (1)
        {
          CFAllocatorRef v51 = (uint64_t *)v50;
          size_t v52 = *(unsigned __int16 *)(v50 + 20);
          if (v47 == v52 && !memcmp(v46, (const void *)(v50 + 22), v52)) {
            break;
          }
          uint64_t v50 = *v51;
          uint64_t v48 = v51;
          if (!*v51) {
            goto LABEL_62;
          }
        }
        *uint64_t v48 = *v51;
        free(v51);
        goto LABEL_79;
      }
LABEL_62:
      int v53 = 0;
      goto LABEL_132;
    }
    unint64_t v26 = v28 & 0xFFFFFFFFFFFFFFFCLL;
    if (v25 >= (unint64_t *)v105)
    {
      uint64_t v32 = v25 - __p;
      if ((unint64_t)(v32 + 1) >> 61) {
        std::vector<NLExtendedString>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v33 = (v105 - (char *)__p) >> 2;
      if (v33 <= v32 + 1) {
        unint64_t v33 = v32 + 1;
      }
      if ((unint64_t)(v105 - (char *)__p) >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v34 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v34 = v33;
      }
      if (v34) {
        uint64_t v35 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NLTransliterationCandidate *>>((uint64_t)&v105, v34);
      }
      else {
        uint64_t v35 = 0;
      }
      CFDictionaryRef v36 = (unint64_t *)&v35[8 * v32];
      unint64_t *v36 = v26;
      CFAttributedStringRef v25 = v36 + 1;
      uint64_t v37 = v104;
      if (v104 != __p)
      {
        do
        {
          unint64_t v38 = *--v37;
          *--CFDictionaryRef v36 = v38;
        }
        while (v37 != __p);
        uint64_t v37 = __p;
      }
      std::string __p = v36;
      unint64_t v105 = &v35[8 * v34];
      if (v37) {
        operator delete(v37);
      }
    }
    else
    {
      *v25++ = v26;
    }
    std::string v104 = v25;
    ++v24;
  }
  while (v24 != a3);
  if (!*(_DWORD *)(v26 + 8)) {
    goto LABEL_62;
  }
  *(_DWORD *)(v26 + 8) = 0;
LABEL_79:
  if ((unint64_t)((char *)v104 - (char *)__p) >= 0x10)
  {
    uint64_t v63 = v104 - __p;
    unsigned int v109 = 0;
    uint64_t v64 = v63 - 1;
    if (v63 != 1)
    {
      LOBYTE(v65) = 0;
      unint64_t v66 = a1[522];
      while (1)
      {
        CFIndex v67 = (nlp *)nlp::burstTrieCreateCursorWithTrieLevelRef<nlp::_RankedTrieLevel *>((uint64_t)a1, __p[v64]);
        unsigned int v109 = 0;
        v116 = &unk_1EF7CE0C0;
        v117 = &v109;
        v118 = &v116;
        nlp::BurstTrieTraverseFromCursor(v67, 0, (uint64_t)&v116, -1);
        std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::~__value_func[abi:ne180100](&v116);
        if (v67) {
          free(v67);
        }
        if (v109 >= v66) {
          break;
        }
        uint64_t v65 = 1;
        if (!--v64) {
          goto LABEL_111;
        }
      }
      if ((v65 & 1) == 0) {
        goto LABEL_131;
      }
      uint64_t v65 = v64 + 1;
LABEL_111:
      uint64_t v106 = 0;
      uint64_t v107 = 0;
      uint64_t v108 = 0;
      std::vector<std::tuple<std::string,unsigned int,float>>::reserve(&v106, v66);
      uint64_t v85 = __p[v65];
      CFRange v86 = (nlp *)nlp::burstTrieCreateCursorWithTrieLevelRef<nlp::_RankedTrieLevel *>((uint64_t)a1, v85);
      v113 = &unk_1EF7CE068;
      uint64_t v114 = &v106;
      v115 = &v113;
      nlp::BurstTrieTraverseFromCursor(v86, 0, (uint64_t)&v113, -1);
      std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::~__value_func[abi:ne180100](&v113);
      if (v66 <= (v107 - v106) >> 5) {
        __assert_rtn("reverseBurst", "BurstTrie.cpp", 965, "items.size() < sizeThreshold");
      }
      if (v86) {
        free(v86);
      }
      nlp::finishLevel<nlp::_RankedTrieLevel *,nlp::_RankedListNode *>(v85);
      a1[515] -= (unint64_t)(v107 - v106) >> 5;
      *(void *)(__p[v64] + 8 * v5[v64] + 12) = 0;
      if ((a3 + 1) < (unint64_t)(v104 - __p)) {
        __assert_rtn("reverseBurst", "BurstTrie.cpp", 974, "levels.size() <= keyLen + 1");
      }
      CFRange v88 = nlp::sharedBuffer(v87);
      uint64_t v89 = (uint64_t)v88;
      if (v65)
      {
        CFRange v90 = v88;
        uint64_t v91 = v65;
        do
        {
          char v92 = *v5++;
          *v90++ = v92;
          --v91;
        }
        while (v91);
      }
      uint64_t v93 = v106;
      uint64_t v94 = v107;
      if (v106 != v107)
      {
        int v95 = a1[516];
        do
        {
          if (*(char *)(v93 + 23) < 0)
          {
            BOOL v97 = *(const void **)v93;
            size_t v96 = *(void *)(v93 + 8);
          }
          else
          {
            size_t v96 = *(unsigned __int8 *)(v93 + 23);
            BOOL v97 = (const void *)v93;
          }
          uint64_t v98 = *(unsigned int *)(v93 + 24);
          float v99 = *(float *)(v93 + 28);
          memcpy((void *)(v89 + v65), v97, v96);
          if (*(char *)(v93 + 23) < 0) {
            uint64_t v100 = *(void *)(v93 + 8);
          }
          else {
            LODWORD(v10nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)&__p, 0) = *(unsigned __int8 *)(v93 + 23);
          }
          uint64_t v101 = (v100 + v65);
          if (v95)
          {
            uint64_t v112 = 0;
            nlp::BurstTrieAddWithScore((uint64_t)a1, v89, v101, v98, 0, (uint64_t)v111, v99);
            std::__function::__value_func<float ()(void *,float,float)>::~__value_func[abi:ne180100](v111);
          }
          else
          {
            nlp::BurstTrieAdd((uint64_t)a1, v89, v101, v98);
          }
          v93 += 32;
        }
        while (v93 != v94);
      }
LABEL_130:
      v110 = (void **)&v106;
      std::vector<std::tuple<std::string,unsigned int,float>>::__destroy_vector::operator()[abi:ne180100](&v110);
    }
  }
LABEL_131:
  int v53 = 1;
LABEL_132:
  if (__p) {
    operator delete(__p);
  }
  if (!v53) {
    return 0;
  }
  --a1[515];
  return 1;
}

void sub_1A43EE2D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, char *a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25)
{
  a16 = &a12;
  std::vector<std::tuple<std::string,unsigned int,float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a16);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t nlp::BurstTrieContains(nlp *a1, const void *a2, uint64_t a3, _DWORD *a4, _DWORD *a5)
{
  v12[4] = *MEMORY[0x1E4F143B8];
  if (!a3) {
    return 0;
  }
  unint64_t v9 = 0xFFFFFFFF00000000;
  int v10 = 0;
  uint64_t v11 = 0;
  void v12[3] = 0;
  nlp::searchWithContext(a1, a2, a3, 1, (uint64_t)&v9);
  if ((v9 & 0x8000000000000000) != 0)
  {
    uint64_t v7 = 0;
  }
  else
  {
    if (a4) {
      *a4 = HIDWORD(v9);
    }
    if (a5) {
      *a5 = v10;
    }
    uint64_t v7 = 1;
  }
  std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL *)>::~__value_func[abi:ne180100](v12);
  return v7;
}

void sub_1A43EE444(_Unwind_Exception *a1)
{
  std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL *)>::~__value_func[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

nlp *nlp::searchWithContext(nlp *result, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v18[4] = *MEMORY[0x1E4F143B8];
  if (a3 <= 0x3FF)
  {
    uint64_t v9 = (uint64_t)result;
    int v10 = nlp::sharedBuffer(result);
    memcpy(v10, a2, a3);
    v10[a3] = 0;
    uint64_t v11 = *(void *)(v9 + 2080);
    int v12 = *(_DWORD *)(v9 + 2064);
    if (v11)
    {
      uint64_t v13 = (*(_DWORD *)(v11 + 4) & 0xFFFFFFFC) + v11;
      if (v12)
      {
        uint64_t v14 = v18;
        v18[0] = &unk_1EF7CDEB0;
        v18[1] = nlp::containsKey;
        v18[3] = v18;
        nlp::searchDiskLevelRanked(v9, v13, v10, a3, 0, a4, a5, (uint64_t)v18);
      }
      else
      {
        uint64_t v14 = v17;
        v17[0] = &unk_1EF7CDEB0;
        v17[1] = nlp::containsKey;
        void v17[3] = v17;
        nlp::searchDiskLevel(v9, v13, v10, a3, 0, a4, a5, (uint64_t)v17);
      }
    }
    else if (v12)
    {
      uint64_t v14 = v16;
      v16[0] = &unk_1EF7CDEB0;
      v16[1] = nlp::containsKey;
      v16[3] = v16;
      nlp::searchLevelRanked(v9, v10, a3, 0, a4, a5, (uint64_t)v16);
    }
    else
    {
      uint64_t v14 = v15;
      v15[0] = &unk_1EF7CDEB0;
      v15[1] = nlp::containsKey;
      v15[3] = v15;
      nlp::searchLevel((int *)v9, v10, a3, 0, a4, a5, (uint64_t)v15);
    }
    return (nlp *)std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::~__value_func[abi:ne180100](v14);
  }
  return result;
}

void sub_1A43EE670(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::~__value_func[abi:ne180100](va);
  _Unwind_Resume(a1);
}

void *nlp::BurstTrieCreateCursorWithBytes(uint64_t a1, unsigned __int8 *a2, unsigned int a3)
{
  int v6 = malloc_type_calloc(0x28uLL, 1uLL, 0xB69D8915uLL);
  if (!nlp::BurstTrieSetCursorWithBytes(a1, (uint64_t)v6, a2, a3) && v6)
  {
    free(v6);
    return 0;
  }
  return v6;
}

nlp *nlp::BurstTrieTraverseFromCursor(nlp *result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (result)
  {
    uint64_t v7 = result;
    uint64_t result = (nlp *)nlp::sharedBuffer(result);
    uint64_t v8 = (uint64_t)result;
    char v16 = 0;
    int v9 = *((_DWORD *)v7 + 7);
    if (v9)
    {
      if (v9 != 1) {
        return result;
      }
      long long v13 = *(_OWORD *)v7;
      uint64_t v14 = *((void *)v7 + 2);
      int v10 = (void *)*((void *)v7 + 4);
      std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v18, a3);
      nlp::traverseFromCompactMapCursor(v10, (uint64_t)&v13, v8, 0x1000u, 0, &v16, a2, (uint64_t)v18);
      uint64_t v11 = v18;
    }
    else
    {
      long long v13 = *(_OWORD *)v7;
      uint64_t v14 = *((void *)v7 + 2);
      int v15 = *((_DWORD *)v7 + 6);
      int v12 = (void *)*((void *)v7 + 4);
      std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v17, a3);
      nlp::traverseFromMapCursor(v12, (uint64_t)&v13, v8, 0, &v16, a4, a2, (uint64_t)v17);
      uint64_t v11 = v17;
    }
    return (nlp *)std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::~__value_func[abi:ne180100](v11);
  }
  return result;
}

void sub_1A43EE85C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::~__value_func[abi:ne180100](va);
  _Unwind_Resume(a1);
}

uint64_t std::function<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, uint64_t a6, float a7)
{
  uint64_t v13 = a3;
  uint64_t v14 = a2;
  int v12 = a4;
  int v11 = a5;
  float v10 = a7;
  uint64_t v9 = a6;
  uint64_t v7 = *(void *)(a1 + 24);
  if (!v7) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *, int *, int *, float *, uint64_t *))(*(void *)v7 + 48))(v7, &v14, &v13, &v12, &v11, &v10, &v9);
}

void *nlp::traverseFromCompactMapCursor(void *result, uint64_t a2, uint64_t a3, unsigned int a4, unsigned int a5, unsigned char *a6, uint64_t a7, uint64_t a8)
{
  v69[4] = *MEMORY[0x1E4F143B8];
  uint64_t v13 = (uint64_t)result;
  switch(*(void *)a2 & 3)
  {
    case 1:
      std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v68, a8);
      uint64_t v14 = v68;
      nlp::traverseFromCompactMapCursorMappedLevel(v13, (void *)a2, a3, a4, a5, a6, a7, (uint64_t)v68);
      return std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::~__value_func[abi:ne180100](v14);
    case 2:
      std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v66, a8);
      int v15 = *(_DWORD *)(v13 + 2064);
      char v16 = (_DWORD *)((*(void *)a2 & 0xFFFFFFFFFFFFFFFCLL) + *(void *)(v13 + 2080));
      if (v15)
      {
        unint64_t v17 = (void *)std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v69, (uint64_t)v66);
        unsigned int v27 = *v16 - 8;
        if (*v16 == 8) {
          goto LABEL_34;
        }
        unsigned int v28 = 0;
        do
        {
          std::string v29 = (char *)v16 + v28;
          uint64_t v30 = *((unsigned __int16 *)v29 + 8);
          uint64_t v31 = *(unsigned int *)(a2 + 12);
          if (v30 >= v31)
          {
            uint64_t v32 = v29 + 8;
            int v33 = v30 - v31;
            memcpy((void *)(a3 + a5), &v29[v31 + 18], v30 - (int)v31);
            *(unsigned char *)(a3 + v33 + a5) = 0;
            std::function<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::operator()((uint64_t)v69, a7, a3, *((unsigned __int16 *)v32 + 4), *((_DWORD *)v32 + 1), (uint64_t)a6, *(float *)v32);
            LODWORD(v3nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)&__p, 0) = *((unsigned __int16 *)v32 + 4);
          }
          v28 += v30 + 10;
        }
        while (v28 < v27);
      }
      else if ((v15 & 4) != 0)
      {
        unint64_t v17 = (void *)std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v69, (uint64_t)v66);
        unsigned int v34 = *v16 - 4;
        unsigned int v35 = *(_DWORD *)(a2 + 8);
        if (v35 >= v34) {
          goto LABEL_34;
        }
        do
        {
          CFDictionaryRef v36 = (char *)v16 + v35;
          uint64_t v37 = *((unsigned __int16 *)v36 + 4);
          uint64_t v38 = *(unsigned int *)(a2 + 12);
          if (v37 >= v38)
          {
            int v40 = v36 + 4;
            int v41 = v37 - v38;
            memcpy((void *)(a3 + a5 + v36[10]), &v36[v38 + 11], v37 - (int)v38);
            *(unsigned char *)(a3 + v41 + a5 + v40[6]) = 0;
            std::function<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::operator()((uint64_t)v69, a7, a3, *((unsigned __int16 *)v40 + 2), *(_DWORD *)v40, (uint64_t)a6, 0.0);
            int v39 = *((unsigned __int16 *)v40 + 2) + *(_DWORD *)(a2 + 8);
          }
          else
          {
            int v39 = v35 + v37;
          }
          unsigned int v35 = v39 + 7;
          *(_DWORD *)(a2 + 8) = v35;
        }
        while (v35 < v34);
      }
      else
      {
        unint64_t v17 = (void *)std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v69, (uint64_t)v66);
        unsigned int v18 = *v16 - 4;
        unsigned int v19 = *(_DWORD *)(a2 + 8);
        if (v19 >= v18) {
          goto LABEL_34;
        }
        do
        {
          uint64_t v20 = (char *)v16 + v19;
          uint64_t v21 = *((unsigned __int16 *)v20 + 4);
          uint64_t v22 = *(unsigned int *)(a2 + 12);
          if (v21 >= v22)
          {
            uint64_t v24 = v20 + 4;
            int v25 = v21 - v22;
            memcpy((void *)(a3 + a5), &v20[v22 + 10], v21 - (int)v22);
            *(unsigned char *)(a3 + v25 + a5) = 0;
            std::function<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::operator()((uint64_t)v69, a7, a3, *((unsigned __int16 *)v24 + 2), *(_DWORD *)v24, (uint64_t)a6, (float)*(unsigned int *)v24);
            int v23 = *((unsigned __int16 *)v24 + 2) + *(_DWORD *)(a2 + 8);
          }
          else
          {
            int v23 = v19 + v21;
          }
          unsigned int v19 = v23 + 6;
          *(_DWORD *)(a2 + 8) = v19;
        }
        while (v19 < v18);
      }
      unint64_t v17 = v69;
LABEL_34:
      std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::~__value_func[abi:ne180100](v17);
      uint64_t v14 = v66;
      return std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::~__value_func[abi:ne180100](v14);
    case 3:
      std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v67, a8);
      unint64_t v26 = (*(void *)a2 & 0xFFFFFFFFFFFFFFFCLL) + *(void *)(v13 + 2080);
      if ((*(unsigned char *)(v13 + 2064) & 1) == 0)
      {
        if (*(_DWORD *)(v26 + 32))
        {
          *(unsigned char *)(a3 + a5) = 0;
          std::function<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::operator()((uint64_t)v67, a7, a3, a5, *(_DWORD *)(v26 + 32), (uint64_t)a6, 0.0);
          if (a5 >= a4 || *a6) {
            goto LABEL_65;
          }
        }
        else if (a5 >= a4)
        {
          goto LABEL_65;
        }
        uint64_t v42 = a5;
        unint64_t v43 = 0;
        uint64_t v44 = a5 + 1;
        uint64_t v45 = a4 - 1;
        while (1)
        {
          *(unsigned char *)(a3 + v42) = v43;
          if (v43 >> 6 <= 1) {
            uint64_t v46 = 1;
          }
          else {
            uint64_t v46 = v43 >> 6;
          }
          uint64_t v47 = *(void *)(v26 + 8 * (v43 >> 6));
          if ((v47 & (1 << v43)) != 0)
          {
            if (v43 >= 0x40)
            {
              int v48 = 0;
              size_t v49 = (int8x8_t *)v26;
              do
              {
                int8x8_t v50 = *v49++;
                uint8x8_t v51 = (uint8x8_t)vcnt_s8(v50);
                v51.i16[0] = vaddlv_u8(v51);
                v48 += v51.i32[0];
                --v46;
              }
              while (v46);
            }
            else
            {
              int v48 = 0;
            }
            uint8x8_t v52 = (uint8x8_t)vcnt_s8((int8x8_t)(v47 & ((1 << v43) - 1)));
            v52.i16[0] = vaddlv_u8(v52);
            *(void *)a2 = *(unsigned int *)(v26 + 4 * (v48 + v52.i32[0]) + 36);
            *(void *)(a2 + 8) = 0;
            *(_DWORD *)(a2 + 16) = 0;
            std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v69, (uint64_t)v67);
            nlp::traverseFromCompactMapCursor(v13, a2, a3, v45, v44, a6, a7, v69);
            std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::~__value_func[abi:ne180100](v69);
            if (*a6 || v43 >= 0xFF) {
              goto LABEL_65;
            }
          }
          else if (v43 > 0xFE)
          {
            goto LABEL_65;
          }
          ++v43;
        }
      }
      if (*(_DWORD *)(v26 + 40))
      {
        *(unsigned char *)(a3 + a5) = 0;
        std::function<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::operator()((uint64_t)v67, a7, a3, a5, *(_DWORD *)(v26 + 40), (uint64_t)a6, *(float *)(v26 + 36));
        if (a5 >= a4 || *a6) {
          goto LABEL_65;
        }
      }
      else if (a5 >= a4)
      {
        goto LABEL_65;
      }
      uint64_t v53 = a5;
      unint64_t v54 = 0;
      uint64_t v55 = a5 + 1;
      uint64_t v56 = a4 - 1;
      break;
    default:
      if (*(void *)a2 != *(_DWORD *)(result[260] + 4)) {
        return result;
      }
      std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v65, a8);
      uint64_t v14 = v65;
      nlp::traverseFromCompactMapCursorMappedLevel(v13, (void *)a2, a3, a4, a5, a6, a7, (uint64_t)v65);
      return std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::~__value_func[abi:ne180100](v14);
  }
  while (1)
  {
    *(unsigned char *)(a3 + v53) = v54;
    uint64_t v57 = v54 >> 6 <= 1 ? 1 : v54 >> 6;
    uint64_t v58 = *(void *)(v26 + 8 * (v54 >> 6));
    if ((v58 & (1 << v54)) != 0) {
      break;
    }
    if (v54 > 0xFE) {
      goto LABEL_65;
    }
LABEL_64:
    ++v54;
  }
  if (v54 >= 0x40)
  {
    int v59 = 0;
    uint64_t v60 = (int8x8_t *)v26;
    do
    {
      int8x8_t v61 = *v60++;
      uint8x8_t v62 = (uint8x8_t)vcnt_s8(v61);
      v62.i16[0] = vaddlv_u8(v62);
      v59 += v62.i32[0];
      --v57;
    }
    while (v57);
  }
  else
  {
    int v59 = 0;
  }
  uint8x8_t v63 = (uint8x8_t)vcnt_s8((int8x8_t)(v58 & ((1 << v54) - 1)));
  v63.i16[0] = vaddlv_u8(v63);
  *(void *)a2 = *(unsigned int *)(v26 + 4 * (v59 + v63.i32[0]) + 44);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v69, (uint64_t)v67);
  nlp::traverseFromCompactMapCursor(v13, a2, a3, v56, v55, a6, a7, v69);
  std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::~__value_func[abi:ne180100](v69);
  if (!*a6 && v54 < 0xFF) {
    goto LABEL_64;
  }
LABEL_65:
  uint64_t v14 = v67;
  return std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::~__value_func[abi:ne180100](v14);
}

void sub_1A43EEEF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::~__value_func[abi:ne180100](va);
  _Unwind_Resume(a1);
}

uint64_t nlp::traverseFromCompactMapCursorMappedLevel(uint64_t result, void *a2, uint64_t a3, unsigned int a4, unsigned int a5, unsigned char *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = result;
  v23[4] = *MEMORY[0x1E4F143B8];
  unint64_t v12 = (*a2 & 0xFFFFFFFFFFFFFFFCLL) + *(void *)(result + 2080);
  if (*(unsigned char *)(result + 2064))
  {
    if (*(_DWORD *)(v12 + 1024))
    {
      *(unsigned char *)(a3 + a5) = 0;
      uint64_t result = std::function<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::operator()(a8, a7, a3, 0, *(_DWORD *)(v12 + 1024), (uint64_t)a6, *(float *)(v12 + 1032));
      if (a5 >= a4 || *a6) {
        return result;
      }
    }
    else if (a5 >= a4)
    {
      return result;
    }
    uint64_t v16 = 0;
    do
    {
      *(unsigned char *)(a3 + a5) = v16;
      *a2 = *(unsigned int *)(v12 + 4 * v16);
      if (v16) {
        uint64_t v17 = a5 + 1;
      }
      else {
        uint64_t v17 = a5;
      }
      a2[1] = 0;
      a2[2] = 0;
      std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v23, a8);
      nlp::traverseFromCompactMapCursor(v11, a2, a3, a4 - (v16 != 0), v17, a6, a7, v23);
      uint64_t result = (uint64_t)std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::~__value_func[abi:ne180100](v23);
      if (*a6) {
        break;
      }
      BOOL v15 = v16++ == 255;
    }
    while (!v15);
  }
  else
  {
    if (*(_DWORD *)(v12 + 1024))
    {
      *(unsigned char *)(a3 + a5) = 0;
      uint64_t result = std::function<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::operator()(a8, a7, a3, 0, *(_DWORD *)(v12 + 1024), (uint64_t)a6, 0.0);
      if (a5 >= a4 || *a6) {
        return result;
      }
    }
    else if (a5 >= a4)
    {
      return result;
    }
    uint64_t v13 = 0;
    do
    {
      *(unsigned char *)(a3 + a5) = v13;
      *a2 = *(unsigned int *)(v12 + 4 * v13);
      a2[1] = 0;
      *((_DWORD *)a2 + 4) = 0;
      if (v13) {
        uint64_t v14 = a5 + 1;
      }
      else {
        uint64_t v14 = a5;
      }
      std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v22, a8);
      nlp::traverseFromCompactMapCursor(v11, a2, a3, a4 - (v13 != 0), v14, a6, a7, v22);
      uint64_t result = (uint64_t)std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::~__value_func[abi:ne180100](v22);
      if (*a6) {
        break;
      }
      BOOL v15 = v13++ == 255;
    }
    while (!v15);
  }
  return result;
}

void sub_1A43EF1C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t nlp::BurstTrieSetCursorWithBytes(uint64_t a1, uint64_t a2, unsigned __int8 *a3, unsigned int a4)
{
  if (!a1 || !a2 || !nlp::burstTrieSetCursor(a1, a2)) {
    return 0;
  }

  return nlp::BurstTrieCursorAdvanceWithBytes(a2, a3, a4, v7, v8);
}

uint64_t nlp::burstTrieSetCursor(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  *(void *)(a2 + 32) = a1;
  int v2 = *(_DWORD **)(a1 + 2080);
  if (v2)
  {
    if (*v2 == -900339842 || *v2 == 12648430 && v2[7] == 2)
    {
      uint64_t result = 1;
      *(_DWORD *)(a2 + 28) = 1;
      uint64_t v4 = v2[1];
      *(void *)(a2 + 8) = 0;
      *(void *)(a2 + 16) = 0;
      *(void *)a2 = v4;
      return result;
    }
    return 0;
  }
  *(_DWORD *)(a2 + 28) = 0;
  *(void *)(a2 + 8) = a1 | 1;
  *(void *)(a2 + 16) = 0;
  return 1;
}

uint64_t nlp::BurstTrieCursorAdvanceWithBytes(uint64_t result, unsigned __int8 *a2, unsigned int a3, __n128 a4, __n128 a5)
{
  if (result)
  {
    uint64_t v5 = result;
    int v6 = *(_DWORD *)(result + 28);
    if (v6)
    {
      if (v6 == 1)
      {
        uint64_t v7 = *(void *)result;
        uint64_t v8 = *(void *)(result + 8);
        int v9 = *(_DWORD *)(result + 16);
        int v10 = *(_DWORD *)(result + 20);
        uint64_t result = nlp::advanceCompactMapCursor(*(void *)(result + 32), result, a2, a3, a4.n128_f64[0], a5);
        if (!result)
        {
          *(void *)uint64_t v5 = v7;
          *(void *)(v5 + 8) = v8;
          *(_DWORD *)(v5 + 16) = v9;
          *(_DWORD *)(v5 + 2nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)&__p, 0) = v10;
          return result;
        }
        return 1;
      }
      return 0;
    }
    else
    {
      uint64_t v12 = *(void *)result;
      uint64_t v11 = *(void *)(result + 8);
      uint64_t v13 = *(void *)(result + 16);
      int v14 = *(_DWORD *)(result + 24);
      uint64_t result = nlp::advanceMapCursor(*(void *)(result + 32), result, a2, a3, a4);
      if (result) {
        return 1;
      }
      *(void *)uint64_t v5 = v12;
      *(void *)(v5 + 8) = v11;
      *(void *)(v5 + 16) = v13;
      *(_DWORD *)(v5 + 24) = v14;
    }
  }
  return result;
}

BOOL nlp::advanceCompactMapCursor(uint64_t a1, uint64_t a2, unsigned __int8 *a3, unsigned int a4, double a5, __n128 a6)
{
  uint64_t v6 = *(void *)a2;
  size_t v7 = a4;
  switch(*(void *)a2 & 3)
  {
    case 1:
      goto LABEL_3;
    case 2:
      int v13 = *(_DWORD *)(a1 + 2064);
      int v14 = (int *)((v6 & 0xFFFFFFFFFFFFFFFCLL) + *(void *)(a1 + 2080));
      int v15 = *v14;
      if ((v13 & 1) == 0)
      {
        unsigned int v16 = v15 - 4;
        if (v15 == 4) {
          goto LABEL_21;
        }
        uint64_t v17 = *(unsigned int *)(a2 + 8);
        if ((v13 & 4) != 0)
        {
          if (a4)
          {
            if (v17 < v16)
            {
              unsigned int v45 = 0;
              while (1)
              {
                uint64_t v46 = (char *)v14 + v17;
                uint64_t v47 = v46 + 4;
                uint64_t v48 = v46[10];
                LODWORD(v49) = v48;
                if (v48 < a4)
                {
                  if (v48 <= *((unsigned __int16 *)v47 + 2)) {
                    uint64_t v49 = *((unsigned __int16 *)v47 + 2);
                  }
                  else {
                    uint64_t v49 = v48;
                  }
                  uint64_t v50 = v48;
                  while (v49 != v50)
                  {
                    if (v47[(v50 + *(_DWORD *)(a2 + 12)) + 7] != a3[v45 + v50])
                    {
                      LODWORD(v49) = v50;
                      break;
                    }
                    if (a4 == ++v50)
                    {
                      LODWORD(v49) = a4;
                      break;
                    }
                  }
                }
                v45 += v49;
                int v51 = *((unsigned __int16 *)v47 + 2);
                if (v45 == a4) {
                  break;
                }
                int v22 = 0;
                LODWORD(v17) = v17 + v51 + 7;
                *(_DWORD *)(a2 + 8) = v17;
                if (v17 >= v16) {
                  goto LABEL_89;
                }
              }
              unsigned int v63 = *(_DWORD *)(a2 + 12) + a4;
              *(_DWORD *)(a2 + 16) = 0;
              if (v51 + v48 == v63) {
                *(_DWORD *)(a2 + 16) = *(_DWORD *)v47;
              }
              goto LABEL_87;
            }
LABEL_21:
            int v22 = 0;
            goto LABEL_89;
          }
          uint8x8_t v62 = (char *)v14 + v17;
          if (*(unsigned __int16 *)((char *)v14 + v17 + 8) + *((unsigned __int8 *)v14 + v17 + 10))
          {
LABEL_78:
            *(_DWORD *)(a2 + 16) = 0;
            goto LABEL_88;
          }
        }
        else
        {
          if (a4)
          {
            if (v17 < v16)
            {
              uint64_t v18 = *(unsigned int *)(a2 + 12);
              while (1)
              {
                unsigned int v19 = (char *)v14 + v17;
                unsigned int v20 = *((unsigned __int16 *)v19 + 4);
                if (v20 >= v18)
                {
                  uint64_t v21 = v19 + 4;
                  if (!memcmp(&v19[v18 + 10], a3, v7)) {
                    break;
                  }
                }
                int v22 = 0;
                LODWORD(v17) = v17 + v20 + 6;
                *(_DWORD *)(a2 + 8) = v17;
                if (v17 >= v16) {
                  goto LABEL_89;
                }
              }
              *(_DWORD *)(a2 + 16) = 0;
              if (v20 - v18 == a4) {
                *(_DWORD *)(a2 + 16) = *v21;
              }
              unsigned int v63 = v18 + a4;
LABEL_87:
              *(_DWORD *)(a2 + 12) = v63;
              goto LABEL_88;
            }
            goto LABEL_21;
          }
          uint8x8_t v62 = (char *)v14 + v17;
          if (*(_WORD *)((char *)v14 + v17 + 8)) {
            goto LABEL_78;
          }
        }
        *(_DWORD *)(a2 + 16) = 0;
        *(_DWORD *)(a2 + 16) = *((_DWORD *)v62 + 1);
        goto LABEL_88;
      }
      if (v15 == 4) {
        goto LABEL_21;
      }
      unsigned int v35 = *(_DWORD *)(a2 + 8);
      a6.n128_u64[0] = *(void *)(a2 + 12);
      float v36 = *(float *)(a2 + 20);
      unsigned int v37 = v15 - 8;
      if (v15 == 8)
      {
        int v22 = 0;
LABEL_76:
        *(_DWORD *)(a2 + 8) = v35;
        *(void *)(a2 + 12) = a6.n128_u64[0];
        *(float *)(a2 + 2nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)&__p, 0) = v36;
        goto LABEL_89;
      }
      unsigned int v38 = 0;
      int v22 = 0;
      uint64_t v39 = a6.n128_u32[0];
      unsigned __int32 v40 = a6.n128_u32[0] + a4;
      while (2)
      {
        while (1)
        {
          int v41 = (char *)v14 + v38;
          unsigned __int32 v42 = *((unsigned __int16 *)v41 + 8);
          if (v40 <= v42) {
            break;
          }
          v38 += v42 + 10;
          if (v38 >= v37) {
            goto LABEL_76;
          }
        }
        __n128 v67 = a6;
        unsigned int v65 = v35;
        uint64_t v66 = v39;
        uint64_t v64 = v41 + 8;
        if (memcmp(&v41[v39 + 18], a3, v7))
        {
          unsigned int v35 = v65;
          a6 = v67;
          goto LABEL_39;
        }
        a6 = v67;
        if (v40 != v42)
        {
          HIDWORD(v43) = 0;
          BOOL v44 = v22 == 0;
          unsigned int v35 = v65;
          if (!v22)
          {
            unsigned int v35 = v38;
            float v36 = 0.0;
          }
          int v22 = 1;
          if (v44)
          {
            LODWORD(v43) = v67.n128_u32[0] + a4;
            a6.n128_f64[0] = v43;
          }
LABEL_39:
          v38 += v42 + 10;
          uint64_t v39 = v66;
          if (v38 >= v37) {
            goto LABEL_76;
          }
          continue;
        }
        break;
      }
      *(_DWORD *)(a2 + 16) = 0;
      *(_DWORD *)(a2 + 16) = v64[1];
      *(_DWORD *)(a2 + 2nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)&__p, 0) = *v64;
      *(_DWORD *)(a2 + 8) = v38;
      *(_DWORD *)(a2 + 12) = v40;
LABEL_88:
      int v22 = 1;
LABEL_89:
      BOOL v61 = v22 == 0;
      return !v61;
    case 3:
      int v23 = (int8x8_t *)((v6 & 0xFFFFFFFFFFFFFFFCLL) + *(void *)(a1 + 2080));
      if (*(unsigned char *)(a1 + 2064))
      {
        if (a4)
        {
          unsigned int v30 = *a3;
          LODWORD(v31) = v30 >> 6;
          int8x8_t v32 = v23[v30 >> 6];
          uint64_t v33 = 1 << v30;
          if (((1 << v30) & *(void *)&v32) != 0)
          {
            if (v30 >= 0x40)
            {
              int v34 = 0;
              if (v31 <= 1) {
                uint64_t v31 = 1;
              }
              else {
                uint64_t v31 = v31;
              }
              uint64_t v57 = v23;
              do
              {
                int8x8_t v58 = *v57++;
                uint8x8_t v59 = (uint8x8_t)vcnt_s8(v58);
                v59.i16[0] = vaddlv_u8(v59);
                v34 += v59.i32[0];
                --v31;
              }
              while (v31);
            }
            else
            {
              int v34 = 0;
            }
            uint8x8_t v60 = (uint8x8_t)vcnt_s8((int8x8_t)((v33 - 1) & *(void *)&v32));
            v60.i16[0] = vaddlv_u8(v60);
            uint64_t v56 = v23[5].u32[v34 + v60.i32[0] + 1];
            goto LABEL_73;
          }
LABEL_41:
          int v12 = 0;
          goto LABEL_74;
        }
        *(_DWORD *)(a2 + 16) = v23[5].i32[0];
        *(_DWORD *)(a2 + 2nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)&__p, 0) = v23[4].i32[1];
      }
      else
      {
        if (a4)
        {
          unsigned int v24 = *a3;
          LODWORD(v25) = v24 >> 6;
          int8x8_t v26 = v23[v24 >> 6];
          uint64_t v27 = 1 << v24;
          if (((1 << v24) & *(void *)&v26) != 0)
          {
            if (v24 >= 0x40)
            {
              int v28 = 0;
              if (v25 <= 1) {
                uint64_t v25 = 1;
              }
              else {
                uint64_t v25 = v25;
              }
              uint8x8_t v52 = v23;
              do
              {
                int8x8_t v53 = *v52++;
                uint8x8_t v54 = (uint8x8_t)vcnt_s8(v53);
                v54.i16[0] = vaddlv_u8(v54);
                v28 += v54.i32[0];
                --v25;
              }
              while (v25);
            }
            else
            {
              int v28 = 0;
            }
            uint8x8_t v55 = (uint8x8_t)vcnt_s8((int8x8_t)((v27 - 1) & *(void *)&v26));
            v55.i16[0] = vaddlv_u8(v55);
            uint64_t v56 = v23[4].u32[v28 + v55.i32[0] + 1];
LABEL_73:
            nlp::updateCompactMapCursorPointer(a1, a2, v56);
            int v12 = nlp::advanceCompactMapCursor(a1, a2, a3 + 1, a4 - 1);
            goto LABEL_74;
          }
          goto LABEL_41;
        }
        *(_DWORD *)(a2 + 16) = v23[4].i32[0];
      }
      int v12 = 1;
LABEL_74:
      BOOL v61 = v12 == 0;
      return !v61;
    default:
      if (v6 == *(_DWORD *)(*(void *)(a1 + 2080) + 4))
      {
LABEL_3:
        int v12 = nlp::advanceCompactMapCursorMappedLevel(a1, a2, a3, a4);
        goto LABEL_74;
      }
      return 0;
  }
}

uint64_t nlp::advanceMapCursor(uint64_t a1, uint64_t a2, unsigned __int8 *a3, unsigned int a4, __n128 a5)
{
  uint64_t v9 = *(void *)(a2 + 8);
  if ((v9 & 3) == 2)
  {
    int v12 = nlp::advanceMapCursorTrieList(a1, a2, a3, a4, a5);
    return v12 != 0;
  }
  if ((v9 & 3) != 1) {
    return 0;
  }
  int v10 = (_DWORD *)(v9 & 0xFFFFFFFFFFFFFFFCLL);
  if (*(unsigned char *)(a1 + 2064))
  {
    if (a4)
    {
      uint64_t v11 = (uint64_t *)&v10[2 * *a3 + 3];
      goto LABEL_10;
    }
    *(_DWORD *)(a2 + 2nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)&__p, 0) = v10[2];
    *(_DWORD *)(a2 + 24) = v10[1];
  }
  else
  {
    if (a4)
    {
      uint64_t v11 = (uint64_t *)&v10[2 * *a3 + 1];
LABEL_10:
      nlp::updateMapCursorPointer(a1, a2, *v11);
      int v12 = nlp::advanceMapCursor(a1, a2, a3 + 1, a4 - 1);
      return v12 != 0;
    }
    *(_DWORD *)(a2 + 2nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)&__p, 0) = *v10;
  }
  return 1;
}

void *nlp::sharedBuffer(nlp *this)
{
  {
    pthread_key_t v3 = 0;
    pthread_key_create(&v3, MEMORY[0x1E4F14838]);
    nlp::sharedBuffer(void)::key = v3;
  }
  uint64_t v1 = pthread_getspecific(nlp::sharedBuffer(void)::key);
  if (!v1)
  {
    uint64_t v1 = malloc_type_malloc(0x1000uLL, 0xEDA05693uLL);
    pthread_setspecific(nlp::sharedBuffer(void)::key, v1);
  }
  return v1;
}

void sub_1A43EFA38(_Unwind_Exception *a1)
{
}

void *nlp::traverseFromMapCursor(void *result, uint64_t a2, uint64_t a3, unsigned int a4, unsigned char *a5, int a6, uint64_t a7, uint64_t a8)
{
  v61[4] = *MEMORY[0x1E4F143B8];
  int v14 = *((_DWORD *)result + 516);
  uint64_t v15 = *(void *)(a2 + 8) & 3;
  if (v15 != 2)
  {
    if (v15 != 1) {
      return result;
    }
    uint64_t v16 = (uint64_t)result;
    if ((v14 & 1) == 0)
    {
      std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v59, a8);
      uint64_t v17 = (int *)(*(void *)(a2 + 8) & 0xFFFFFFFFFFFFFFFCLL);
      if (*v17)
      {
        std::function<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::operator()((uint64_t)v59, a7, a3, a4, *v17, (uint64_t)a5, *(float *)(a2 + 24));
        if (!a6 || *a5) {
          goto LABEL_48;
        }
      }
      else if (!a6)
      {
LABEL_48:
        uint64_t v47 = v59;
        return std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::~__value_func[abi:ne180100](v47);
      }
      uint64_t v48 = 0;
      uint64_t v49 = (a6 - 1);
      uint64_t v50 = v17 + 1;
      do
      {
        *(unsigned char *)(a3 + a4) = v48;
        nlp::updateMapCursorPointer(v16, a2, *(void *)&v50[2 * v48]);
        std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v61, (uint64_t)v59);
        nlp::traverseFromMapCursor(v16, a2, a3, a4 + 1, a5, v49, a7, v61);
        std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::~__value_func[abi:ne180100](v61);
        if (*a5) {
          break;
        }
        BOOL v51 = v48++ == 255;
      }
      while (!v51);
      goto LABEL_48;
    }
    std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v60, a8);
    unint64_t v31 = *(void *)(a2 + 8) & 0xFFFFFFFFFFFFFFFCLL;
    int v32 = *(_DWORD *)(v31 + 8);
    if (v32)
    {
      std::function<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::operator()((uint64_t)v60, a7, a3, a4, v32, (uint64_t)a5, *(float *)(a2 + 24));
      if (!a6 || *a5) {
        goto LABEL_54;
      }
    }
    else if (!a6)
    {
LABEL_54:
      uint64_t v47 = v60;
      return std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::~__value_func[abi:ne180100](v47);
    }
    uint64_t v52 = 0;
    uint64_t v53 = (a6 - 1);
    unint64_t v54 = v31 + 12;
    do
    {
      *(unsigned char *)(a3 + a4) = v52;
      nlp::updateMapCursorPointer(v16, a2, *(void *)(v54 + 8 * v52));
      std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v61, (uint64_t)v60);
      nlp::traverseFromMapCursor(v16, a2, a3, a4 + 1, a5, v53, a7, v61);
      std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::~__value_func[abi:ne180100](v61);
      if (*a5) {
        break;
      }
      BOOL v51 = v52++ == 255;
    }
    while (!v51);
    goto LABEL_54;
  }
  if (v14)
  {
    std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v58, a8);
    unint64_t v33 = *(void *)a2 & 0xFFFFFFFFFFFFFFFCLL;
    if (!v33) {
      goto LABEL_42;
    }
    uint64_t v56 = (unsigned __int8 *)(v33 + 22);
    unsigned int v34 = a4;
    uint64_t v35 = *(unsigned int *)(a2 + 16);
    unsigned int v36 = v34;
    unsigned int v37 = (void *)(a3 + v34);
    while (1)
    {
      uint64_t v38 = *(unsigned __int16 *)(v33 + 20);
      if (v38 >= v35)
      {
        size_t v39 = v38 - (int)v35;
        if (a6 < 0 || (int)v39 <= a6)
        {
          if (v35)
          {
            unsigned __int32 v40 = (unsigned __int8 *)(v33 + 22);
            int v41 = v56;
            uint64_t v42 = v35;
            while (1)
            {
              int v44 = *v40++;
              int v43 = v44;
              int v45 = *v41++;
              if (v43 != v45) {
                break;
              }
              if (!--v42) {
                goto LABEL_38;
              }
            }
          }
          else
          {
LABEL_38:
            unsigned int v46 = v39 + v36;
            memcpy(v37, (const void *)(v33 + v35 + 22), v39);
            *(unsigned char *)(a3 + v46) = 0;
            std::function<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::operator()((uint64_t)v58, a7, a3, v46, *(_DWORD *)(v33 + 16), (uint64_t)a5, *(float *)(v33 + 12));
          }
        }
      }
      unint64_t v33 = *(void *)v33;
      if (!v33) {
        goto LABEL_40;
      }
    }
  }
  std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v57, a8);
  unsigned int v55 = a4;
  unint64_t v18 = *(void *)(a2 + 8) & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v19 = *(unsigned int *)(a2 + 16);
  if (v19 > *(unsigned __int16 *)(v18 + 12)) {
    __assert_rtn("traverseFromMapCursorTrieList", "BurstTrie.cpp", 1957, "cursor.prfxlen <= head->restlen");
  }
  if (!v18) {
    goto LABEL_40;
  }
  unint64_t v20 = *(void *)(a2 + 8) & 0xFFFFFFFFFFFFFFFCLL;
  while (v20 == v18)
  {
    unsigned int v21 = *(unsigned __int16 *)(v18 + 12);
LABEL_20:
    int v28 = v21 - v19;
    if (a6 < 0 || v28 <= a6)
    {
      unsigned int v29 = v28 + v55;
      memcpy((void *)(a3 + v55), (const void *)(v20 + v19 + 14), v28);
      *(unsigned char *)(a3 + v29) = 0;
      uint64_t v30 = std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v61, (uint64_t)v57);
      std::function<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::operator()(v30, a7, a3, v29, *(_DWORD *)(v20 + 8), (uint64_t)a5, 0.0);
      std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::~__value_func[abi:ne180100](v61);
    }
    unint64_t v20 = *(void *)v20;
    if (!v20) {
      goto LABEL_40;
    }
  }
  unsigned int v21 = *(unsigned __int16 *)(v20 + 12);
  if (v21 <= (unsigned __int16)v19) {
    goto LABEL_40;
  }
  if (!v19) {
    goto LABEL_20;
  }
  int v22 = (unsigned __int8 *)(v20 + 14);
  int v23 = (unsigned __int8 *)(v18 + 14);
  uint64_t v24 = v19;
  while (1)
  {
    int v26 = *v22++;
    int v25 = v26;
    int v27 = *v23++;
    if (v25 != v27) {
      break;
    }
    if (!--v24) {
      goto LABEL_20;
    }
  }
LABEL_40:
  if ((v14 & 1) == 0)
  {
    uint64_t v47 = v57;
    return std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::~__value_func[abi:ne180100](v47);
  }
LABEL_42:
  uint64_t v47 = v58;
  return std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::~__value_func[abi:ne180100](v47);
}

void sub_1A43EFE78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void nlp::finishLevel<nlp::_RankedTrieLevel *,nlp::_RankedListNode *>(uint64_t a1)
{
  for (uint64_t i = 0; i != 256; ++i)
  {
    uint64_t v3 = a1 + 8 * i;
    uint64_t v6 = *(void *)(v3 + 12);
    uint64_t v5 = (void *)(v3 + 12);
    uint64_t v4 = v6;
    uint64_t v7 = v6 & 3;
    if (v7 == 2)
    {
      uint64_t v8 = (void *)(v4 & 0xFFFFFFFFFFFFFFFCLL);
      do
      {
        uint64_t v9 = (void *)*v8;
        free(v8);
        uint64_t v8 = v9;
      }
      while (v9);
    }
    else if (v7 == 1)
    {
      nlp::finishLevel<nlp::_RankedTrieLevel *,nlp::_RankedListNode *>(v4 & 0xFFFFFFFFFFFFFFFCLL);
      free((void *)(*v5 & 0xFFFFFFFFFFFFFFFCLL));
    }
  }
}

void nlp::finishLevel<nlp::_TrieLevel *,nlp::_ListNode *>(uint64_t a1)
{
  for (uint64_t i = 0; i != 256; ++i)
  {
    uint64_t v3 = a1 + 8 * i;
    uint64_t v6 = *(void *)(v3 + 4);
    uint64_t v5 = (void *)(v3 + 4);
    uint64_t v4 = v6;
    uint64_t v7 = v6 & 3;
    if (v7 == 2)
    {
      uint64_t v8 = (void *)(v4 & 0xFFFFFFFFFFFFFFFCLL);
      do
      {
        uint64_t v9 = (void *)*v8;
        free(v8);
        uint64_t v8 = v9;
      }
      while (v9);
    }
    else if (v7 == 1)
    {
      nlp::finishLevel<nlp::_TrieLevel *,nlp::_ListNode *>(v4 & 0xFFFFFFFFFFFFFFFCLL);
      free((void *)(*v5 & 0xFFFFFFFFFFFFFFFCLL));
    }
  }
}

uint64_t nlp::addListNode(uint64_t a1, void *a2, uint64_t a3, int a4, unsigned int a5, uint64_t a6, int *a7)
{
  int v12 = a2;
  uint64_t v13 = a1;
  int v14 = (uint64_t *)*a2;
  uint64_t v15 = malloc_type_calloc(8uLL, (*(_DWORD *)(a1 + 2088) + 1), 0xDF779D89uLL);
  uint64_t v16 = (const void *)(a3 + a5);
  if (v14)
  {
    unsigned int v36 = v12;
    uint64_t v37 = v13;
    uint64_t v38 = a7;
    uint64_t v17 = 0;
    char v18 = 1;
LABEL_3:
    uint64_t v19 = a6;
    uint64_t v20 = 0;
    uint64_t v21 = v17;
    int v22 = &v15[v17];
    do
    {
      size_t v23 = *((unsigned __int16 *)v14 + 6);
      if (v23 + a5 == a4 && !memcmp(v16, (char *)v14 + 14, v23))
      {
        char v18 = 0;
        a6 = v19;
        *((_DWORD *)v14 + 2) = v19;
        uint64_t v17 = v21 + v20 + 1;
        v15[v21 + v20] = v14;
        int v14 = (uint64_t *)*v14;
        if (v14) {
          goto LABEL_3;
        }
        uint64_t v24 = (v21 + v20 + 1);
        int v25 = 1;
        goto LABEL_15;
      }
      v22[v20] = v14;
      int v14 = (uint64_t *)*v14;
      ++v20;
    }
    while (v14);
    uint64_t v26 = v21 + v20;
    if (v18)
    {
      uint64_t v13 = v37;
      a7 = v38;
      LODWORD(a6) = v19;
      int v12 = v36;
      goto LABEL_13;
    }
    int v25 = 1;
    uint64_t v24 = v26;
LABEL_15:
    uint64_t v13 = v37;
    a7 = v38;
    int v12 = v36;
  }
  else
  {
    LODWORD(v26) = 0;
LABEL_13:
    size_t v27 = a4 - a5;
    int v28 = (char *)malloc_type_calloc(1uLL, v27 + 15, 0x64AF1970uLL);
    memcpy(v28 + 14, v16, v27);
    v28[v27 + 14] = 0;
    *((_WORD *)v28 + 6) = v27;
    *((_DWORD *)v28 + 2) = a6;
    uint64_t v24 = (v26 + 1);
    int v25 = 2;
    *(void *)int v28 = 0;
    v15[v26] = v28;
  }
  qsort(v15, (int)v24, 8uLL, (int (__cdecl *)(const void *, const void *))nlp::nodeStringCompare);
  unsigned int v29 = (void *)*v15;
  uint64_t v30 = (void *)*v15;
  if ((int)v24 >= 2)
  {
    unint64_t v31 = v15 + 1;
    uint64_t v32 = v24 - 1;
    unint64_t v33 = (void *)*v15;
    do
    {
      unsigned int v34 = (void *)*v31++;
      uint64_t v30 = v34;
      *unint64_t v33 = v34;
      unint64_t v33 = v34;
      --v32;
    }
    while (v32);
  }
  *uint64_t v30 = 0;
  *int v12 = v29;
  free(v15);
  *a7 = v25;
  if (v24 > *(_DWORD *)(v13 + 2088)) {
    nlp::addListNode();
  }
  return v24;
}

_DWORD *nlp::burstLevel(uint64_t a1, unsigned __int16 *a2, int *a3)
{
  uint64_t v6 = malloc_type_calloc(1uLL, 0x804uLL, 0x10000406A7154B6uLL);
  if (a2)
  {
    do
    {
      int v7 = a2[6];
      uint64_t v8 = *((unsigned int *)a2 + 2);
      if (a2[6])
      {
        uint64_t v9 = *(void *)&v6[2 * *((unsigned __int8 *)a2 + 14) + 1];
        if (v9)
        {
          unint64_t v19 = v9 & 0xFFFFFFFFFFFFFFFCLL;
          unsigned int v10 = nlp::addListNode(a1, &v19, (uint64_t)(a2 + 7), v7, 1u, v8, a3);
          uint64_t v11 = v19;
          if (v10 >= *(_DWORD *)(a1 + 2088))
          {
            uint64_t v11 = nlp::burstLevel(a1, v19, a3);
            uint64_t v12 = 1;
          }
          else
          {
            uint64_t v12 = 2;
          }
          uint64_t v15 = v12 | v11;
          uint64_t v16 = *((unsigned __int8 *)a2 + 14);
        }
        else
        {
          size_t v13 = (v7 - 1);
          unint64_t v14 = (unint64_t)malloc_type_calloc(1uLL, v13 + 15, 0x64AF1970uLL);
          memcpy((void *)(v14 + 14), (char *)a2 + 15, v13);
          *(unsigned char *)(v14 + 14 + v13) = 0;
          *(_WORD *)(v14 + 12) = v13;
          *(_DWORD *)(v14 + 8) = v8;
          *(void *)unint64_t v14 = 0;
          uint64_t v15 = v14 | 2;
          uint64_t v16 = *((unsigned __int8 *)a2 + 14);
        }
        *(void *)&v6[2 * v16 + 1] = v15;
      }
      else
      {
        *uint64_t v6 = v8;
      }
      uint64_t v17 = *(unsigned __int16 **)a2;
      free(a2);
      a2 = v17;
    }
    while (v17);
  }
  return v6;
}

uint64_t nlp::nodeStringCompare(nlp *this, void *a2, const void *a3)
{
  uint64_t v3 = *(void *)this;
  uint64_t v4 = *a2;
  uint64_t v5 = (const void *)(*(void *)this + 14);
  uint64_t v6 = (const void *)(*a2 + 14);
  unsigned int v7 = *(unsigned __int16 *)(v3 + 12);
  unsigned int v8 = *(unsigned __int16 *)(v4 + 12);
  unsigned int v9 = v7 - v8;
  if ((int)v7 >= (int)v8) {
    size_t v10 = v8;
  }
  else {
    size_t v10 = v7;
  }
  LODWORD(result) = memcmp(v5, v6, v10);
  if (result) {
    return result;
  }
  else {
    return v9;
  }
}

uint64_t nlp::addListNodeRanked(uint64_t a1, uint64_t **a2, uint64_t a3, int a4, unsigned int a5, int a6, float *a7, int *a8, float a9, uint64_t a10, uint64_t a11)
{
  uint64_t v17 = *a2;
  char v18 = (uint64_t *)malloc_type_calloc(8uLL, (*(_DWORD *)(a1 + 2088) + 1), 0xCCEAD6FFuLL);
  unint64_t v19 = (const void *)(a3 + a5);
  if (v17)
  {
    uint64_t v20 = 0;
    int v21 = 0;
    float v22 = 0.0;
    do
    {
      uint64_t v23 = v20;
      size_t v24 = *((unsigned __int16 *)v17 + 10);
      if (v24 + a5 == a4 && !memcmp(v19, (char *)v17 + 22, v24))
      {
        *((_DWORD *)v17 + 4) = a6;
        float v25 = *((float *)v17 + 3);
        if (*(void *)(a11 + 24)) {
          std::function<float ()(void *,float,float)>::operator()(a11, a10, v25, a9);
        }
        else {
          float v26 = v25 + a9;
        }
        *((float *)v17 + 3) = v26;
        int v21 = 1;
      }
      if (*((float *)v17 + 2) > v22) {
        float v22 = *((float *)v17 + 2);
      }
      ++v20;
      v18[v23] = (uint64_t)v17;
      uint64_t v17 = (uint64_t *)*v17;
    }
    while (v17);
    if (v21)
    {
      int v27 = 1;
      uint64_t v28 = v23 + 1;
      uint64_t v29 = a1;
      goto LABEL_18;
    }
  }
  else
  {
    LODWORD(v2nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)&__p, 0) = 0;
    float v22 = 0.0;
  }
  uint64_t v29 = a1;
  if (v22 < a9) {
    float v22 = a9;
  }
  size_t v30 = a4 - a5;
  unint64_t v31 = (char *)malloc_type_calloc(1uLL, v30 + 23, 0x35949B46uLL);
  memcpy(v31 + 22, v19, v30);
  v31[v30 + 22] = 0;
  *((_WORD *)v31 + 1nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)&__p, 0) = v30;
  *((_DWORD *)v31 + 4) = a6;
  *((float *)v31 + 2) = v22;
  *((float *)v31 + 3) = a9;
  uint64_t v28 = (v20 + 1);
  int v27 = 2;
  *(void *)unint64_t v31 = 0;
  v18[v20] = (uint64_t)v31;
LABEL_18:
  qsort(v18, (int)v28, 8uLL, (int (__cdecl *)(const void *, const void *))nlp::nodeScoreCompare);
  uint64_t v32 = (void *)*v18;
  *a7 = v22;
  unint64_t v33 = v32;
  if ((int)v28 >= 2)
  {
    uint64_t v34 = (v28 - 1);
    uint64_t v35 = v18 + 1;
    unsigned int v36 = v32;
    do
    {
      uint64_t v37 = *v35++;
      unint64_t v33 = (void *)v37;
      void *v36 = v37;
      *(float *)(v37 + 8) = *a7;
      unsigned int v36 = (void *)v37;
      --v34;
    }
    while (v34);
  }
  *unint64_t v33 = 0;
  *a2 = v32;
  free(v18);
  *a8 = v27;
  if (v28 > *(_DWORD *)(v29 + 2088)) {
    nlp::addListNodeRanked();
  }
  return v28;
}

float *nlp::burstLevelRanked(uint64_t a1, unsigned __int16 *a2, float *a3, int *a4)
{
  void v25[4] = *MEMORY[0x1E4F143B8];
  unsigned int v8 = (float *)malloc_type_calloc(1uLL, 0x80CuLL, 0x10000408B9410F9uLL);
  *a3 = 0.0;
  if (a2)
  {
    do
    {
      float v22 = 0.0;
      int v9 = a2[10];
      int v10 = *((_DWORD *)a2 + 4);
      float v11 = *((float *)a2 + 3);
      v24[3] = 0;
      if (v9)
      {
        uint64_t v12 = *(void *)&v8[2 * *((unsigned __int8 *)a2 + 22) + 3];
        if (v12)
        {
          uint64_t v23 = (uint64_t *)(v12 & 0xFFFFFFFFFFFFFFFCLL);
          v25[3] = 0;
          unsigned int v13 = nlp::addListNodeRanked(a1, &v23, (uint64_t)(a2 + 11), v9, 1u, v10, &v22, a4, v11, 0, (uint64_t)v25);
          std::__function::__value_func<float ()(void *,float,float)>::~__value_func[abi:ne180100](v25);
          uint64_t v14 = (uint64_t)v23;
          if (v13 >= *(_DWORD *)(a1 + 2088))
          {
            uint64_t v14 = nlp::burstLevelRanked(a1, v23, &v22, a4);
            uint64_t v15 = 1;
          }
          else
          {
            uint64_t v15 = 2;
          }
          *(void *)&v8[2 * *((unsigned __int8 *)a2 + 22) + 3] = v15 | v14;
          float v11 = v22;
        }
        else
        {
          size_t v16 = (v9 - 1);
          unint64_t v17 = (unint64_t)malloc_type_calloc(1uLL, v16 + 23, 0x35949B46uLL);
          memcpy((void *)(v17 + 22), (char *)a2 + 23, v16);
          *(unsigned char *)(v17 + 22 + v16) = 0;
          *(_WORD *)(v17 + 2nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)&__p, 0) = v16;
          *(_DWORD *)(v17 + 16) = v10;
          *(float *)(v17 + 8) = v11;
          *(float *)(v17 + 12) = v11;
          *(void *)unint64_t v17 = 0;
          *(void *)&v8[2 * *((unsigned __int8 *)a2 + 22) + 3] = v17 | 2;
        }
      }
      else
      {
        v8[1] = v11;
        *((_DWORD *)v8 + 2) = v10;
      }
      std::__function::__value_func<float ()(void *,float,float)>::~__value_func[abi:ne180100](v24);
      float v18 = *a3;
      if (v11 > *a3) {
        float v18 = v11;
      }
      *a3 = v18;
      unint64_t v19 = *(unsigned __int16 **)a2;
      free(a2);
      a2 = v19;
    }
    while (v19);
    float v20 = *a3;
  }
  else
  {
    float v20 = 0.0;
  }
  float *v8 = v20;
  return v8;
}

void sub_1A43F07DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  std::__function::__value_func<float ()(void *,float,float)>::~__value_func[abi:ne180100]((uint64_t *)va1);
  std::__function::__value_func<float ()(void *,float,float)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t std::function<float ()(void *,float,float)>::operator()(uint64_t a1, uint64_t a2, float a3, float a4)
{
  uint64_t v8 = a2;
  float v6 = a4;
  float v7 = a3;
  uint64_t v4 = *(void *)(a1 + 24);
  if (!v4) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *, float *, float *))(*(void *)v4 + 48))(v4, &v8, &v7, &v6);
}

uint64_t nlp::nodeScoreCompare(nlp *this, const void *a2, const void *a3)
{
  float v3 = *(float *)(*(void *)this + 12);
  float v4 = *(float *)(*(void *)a2 + 12);
  if (v3 == v4)
  {
    unsigned int v5 = *(_DWORD *)(*(void *)this + 16);
    unsigned int v6 = *(_DWORD *)(*(void *)a2 + 16);
    BOOL v7 = v5 == v6;
    if (v5 > v6) {
      unsigned int v8 = -1;
    }
    else {
      unsigned int v8 = 1;
    }
    if (v7) {
      return 0;
    }
    else {
      return v8;
    }
  }
  else if ((float)(v3 - v4) <= 0.0)
  {
    return 1;
  }
  else
  {
    return 0xFFFFFFFFLL;
  }
}

void std::__throw_bad_function_call[abi:ne180100]()
{
  exception = __cxa_allocate_exception(8uLL);
}

void std::bad_function_call::~bad_function_call(std::bad_function_call *this)
{
  std::exception::~exception(this);

  JUMPOUT(0x1A625B130);
}

BOOL nlp::searchDiskLevelRanked(uint64_t a1, uint64_t a2, unsigned char *a3, uint64_t a4, unsigned int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  char v38 = 0;
  if (a5 < a4)
  {
    int v15 = *(_DWORD *)(a2 + 4 * a3[a5]);
    uint64_t v16 = v15 & 3;
    switch(v16)
    {
      case 3:
        uint64_t v34 = *(void *)(a1 + 2080);
        std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v43, a8);
        float v18 = v43;
        uint64_t v19 = nlp::searchCompactDiskLevelRanked(a1, (int8x8_t *)((v15 & 0xFFFFFFFC) + v34), a3, a4, a5 + 1, a6, a7, (uint64_t)v43);
        goto LABEL_29;
      case 2:
        uint64_t v35 = *(void *)(a1 + 2080);
        std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v42, a8);
        float v18 = v42;
        uint64_t v19 = nlp::searchDiskPageRanked((unsigned int *)((v15 & 0xFFFFFFFC) + v35), a3, a4, a5 + 1, a6, a7, (uint64_t)v42);
        goto LABEL_29;
      case 1:
        uint64_t v17 = *(void *)(a1 + 2080);
        std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v44, a8);
        float v18 = v44;
        uint64_t v19 = nlp::searchDiskLevelRanked(a1, (v15 & 0xFFFFFFFC) + v17, a3, a4, a5 + 1, a6, a7, v44);
LABEL_29:
        BOOL v25 = v19;
        std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::~__value_func[abi:ne180100](v18);
        return v25;
    }
    return 0;
  }
  int v20 = *(_DWORD *)(a2 + 1024);
  if (!v20)
  {
    if (a6) {
      return 0;
    }
    goto LABEL_15;
  }
  int v21 = *(_DWORD *)(a2 + 1032);
  char v22 = a6;
  uint64_t v23 = malloc_type_malloc(a4 + 21, 0x64E2CA22uLL);
  v23[4] = a4;
  *((unsigned char *)v23 + a4 + 2nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)&__p, 0) = 0;
  memcpy(v23 + 5, a3, a4);
  v23[2] = v20;
  _DWORD *v23 = v21;
  v23[3] = 1;
  std::function<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::operator()(a8, a7, (uint64_t)v23, 1, (uint64_t)&v38);
  BOOL v24 = v23[3]-- == 1;
  if (v24) {
    free(v23);
  }
  BOOL v25 = v38 != 0;
  if (!v38 && (v22 & 1) == 0)
  {
LABEL_15:
    uint64_t v26 = 0;
    uint64_t v27 = (a4 + 1);
    while (1)
    {
      int v28 = *(_DWORD *)(a2 + 4 * v26);
      a3[a5] = v26;
      uint64_t v29 = v28 & 3;
      switch(v29)
      {
        case 3:
          uint64_t v32 = *(void *)(a1 + 2080);
          std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v40, a8);
          char v38 = nlp::searchCompactDiskLevelRanked(a1, (int8x8_t *)((v28 & 0xFFFFFFFC) + v32), a3, v27, a5 + 1, 0, a7, (uint64_t)v40);
          unint64_t v31 = v40;
          break;
        case 2:
          uint64_t v33 = *(void *)(a1 + 2080);
          std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v39, a8);
          char v38 = nlp::searchDiskPageRanked((unsigned int *)((v28 & 0xFFFFFFFC) + v33), a3, v27, a5 + 1, 0, a7, (uint64_t)v39);
          unint64_t v31 = v39;
          break;
        case 1:
          uint64_t v30 = *(void *)(a1 + 2080);
          std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v41, a8);
          char v38 = nlp::searchDiskLevelRanked(a1, (v28 & 0xFFFFFFFC) + v30, a3, v27, a5 + 1, 0, a7, v41);
          unint64_t v31 = v41;
          break;
        default:
          goto LABEL_23;
      }
      std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::~__value_func[abi:ne180100](v31);
LABEL_23:
      BOOL v25 = v38 != 0;
      if (!v38)
      {
        BOOL v24 = v26++ == 255;
        if (!v24) {
          continue;
        }
      }
      return v25;
    }
  }
  return v25;
}

void sub_1A43F0C88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::~__value_func[abi:ne180100](va);
  _Unwind_Resume(a1);
}

uint64_t nlp::containsKey(uint64_t result, _DWORD *a2, int a3, unsigned char *a4)
{
  if (result)
  {
    if (*(_DWORD *)result == 1)
    {
LABEL_5:
      *(_DWORD *)(result + 4) = a2[2];
      *(_DWORD *)(result + 8) = *a2;
LABEL_8:
      *a4 = 1;
      return result;
    }
    if (!*(_DWORD *)result)
    {
      if (!a3) {
        return result;
      }
      goto LABEL_5;
    }
    char v5 = 0;
    if (*(void *)(result + 48))
    {
      uint64_t result = std::function<void ()(void *,nlp::_TrieCompletion *,BOOL *)>::operator()(result + 24, *(void *)(result + 16), (uint64_t)a2, (uint64_t)&v5);
      if (v5) {
        goto LABEL_8;
      }
    }
  }
  return result;
}

BOOL nlp::searchDiskLevel(uint64_t a1, uint64_t a2, char *a3, uint64_t a4, unsigned int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  char v37 = 0;
  if (a5 < a4)
  {
    int v15 = *(_DWORD *)(a2 + 4 * a3[a5]);
    uint64_t v16 = v15 & 3;
    switch(v16)
    {
      case 3:
        uint64_t v33 = *(void *)(a1 + 2080);
        std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v42, a8);
        float v18 = v42;
        uint64_t v19 = nlp::searchCompactDiskLevel(a1, (int8x8_t *)((v15 & 0xFFFFFFFC) + v33), a3, a4, a5 + 1, a6, a7, (uint64_t)v42);
        goto LABEL_29;
      case 2:
        uint64_t v34 = *(void *)(a1 + 2080);
        std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v41, a8);
        float v18 = v41;
        uint64_t v19 = nlp::searchDiskPage(a1, (unsigned int *)((v15 & 0xFFFFFFFC) + v34), a3, a4, a5 + 1, a6, a7, (uint64_t)v41);
        goto LABEL_29;
      case 1:
        uint64_t v17 = *(void *)(a1 + 2080);
        std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v43, a8);
        float v18 = v43;
        uint64_t v19 = nlp::searchDiskLevel(a1, (v15 & 0xFFFFFFFC) + v17, a3, a4, a5 + 1, a6, a7, v43);
LABEL_29:
        BOOL v24 = v19;
        std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::~__value_func[abi:ne180100](v18);
        return v24;
    }
    return 0;
  }
  int v20 = *(_DWORD *)(a2 + 1024);
  if (!v20)
  {
    if (a6) {
      return 0;
    }
    goto LABEL_15;
  }
  char v21 = a6;
  char v22 = malloc_type_malloc(a4 + 21, 0x64E2CA22uLL);
  void v22[4] = a4;
  *((unsigned char *)v22 + a4 + 2nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)&__p, 0) = 0;
  memcpy(v22 + 5, a3, a4);
  v22[2] = v20;
  *char v22 = 0;
  void v22[3] = 1;
  std::function<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::operator()(a8, a7, (uint64_t)v22, 1, (uint64_t)&v37);
  BOOL v23 = v22[3]-- == 1;
  if (v23) {
    free(v22);
  }
  BOOL v24 = v37 != 0;
  if (!v37 && (v21 & 1) == 0)
  {
LABEL_15:
    uint64_t v25 = 0;
    uint64_t v26 = (a4 + 1);
    while (1)
    {
      int v27 = *(_DWORD *)(a2 + 4 * v25);
      a3[a5] = v25;
      uint64_t v28 = v27 & 3;
      switch(v28)
      {
        case 3:
          uint64_t v31 = *(void *)(a1 + 2080);
          std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v39, a8);
          char v37 = nlp::searchCompactDiskLevel(a1, (int8x8_t *)((v27 & 0xFFFFFFFC) + v31), a3, v26, a5 + 1, 0, a7, (uint64_t)v39);
          uint64_t v30 = v39;
          break;
        case 2:
          uint64_t v32 = *(void *)(a1 + 2080);
          std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v38, a8);
          char v37 = nlp::searchDiskPage(a1, (unsigned int *)((v27 & 0xFFFFFFFC) + v32), a3, v26, a5 + 1, 0, a7, (uint64_t)v38);
          uint64_t v30 = v38;
          break;
        case 1:
          uint64_t v29 = *(void *)(a1 + 2080);
          std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v40, a8);
          char v37 = nlp::searchDiskLevel(a1, (v27 & 0xFFFFFFFC) + v29, a3, v26, a5 + 1, 0, a7, v40);
          uint64_t v30 = v40;
          break;
        default:
          goto LABEL_23;
      }
      std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::~__value_func[abi:ne180100](v30);
LABEL_23:
      BOOL v24 = v37 != 0;
      if (!v37)
      {
        BOOL v23 = v25++ == 255;
        if (!v23) {
          continue;
        }
      }
      return v24;
    }
  }
  return v24;
}

void sub_1A43F10C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::~__value_func[abi:ne180100](va);
  _Unwind_Resume(a1);
}

BOOL nlp::searchLevelRanked(uint64_t a1, unsigned char *a2, uint64_t a3, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  char v33 = 0;
  if (a4 < a3)
  {
    uint64_t v14 = *(void *)(a1 + 8 * a2[a4] + 12);
    if ((v14 & 3) == 2)
    {
      std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v36, a7);
      int v15 = v36;
      uint64_t v16 = nlp::searchListRanked(v14 & 0xFFFFFFFFFFFFFFFCLL, a2, a3, a4 + 1, a5, a6, (uint64_t)v36);
      goto LABEL_25;
    }
    if ((v14 & 3) == 1)
    {
      std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v37, a7);
      int v15 = v37;
      uint64_t v16 = nlp::searchLevelRanked(v14 & 0xFFFFFFFFFFFFFFFCLL, a2, a3, a4 + 1, a5, a6, v37);
LABEL_25:
      BOOL v21 = v16;
      std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::~__value_func[abi:ne180100](v15);
      return v21;
    }
    return 0;
  }
  int v17 = *(_DWORD *)(a1 + 8);
  if (!v17)
  {
    if (a5) {
      return 0;
    }
    goto LABEL_14;
  }
  int v18 = *(_DWORD *)(a1 + 4);
  uint64_t v19 = malloc_type_malloc(a4 + 21, 0x64E2CA22uLL);
  v19[4] = a4;
  *((unsigned char *)v19 + a4 + 2nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)&__p, 0) = 0;
  memcpy(v19 + 5, a2, a4);
  v19[2] = v17;
  *uint64_t v19 = v18;
  void v19[3] = 1;
  std::function<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::operator()(a7, a6, (uint64_t)v19, 1, (uint64_t)&v33);
  BOOL v20 = v19[3]-- == 1;
  if (v20) {
    free(v19);
  }
  BOOL v21 = v33 != 0;
  if (!v33 && (a5 & 1) == 0)
  {
LABEL_14:
    uint64_t v22 = 0;
    uint64_t v23 = (a3 + 1);
    uint64_t v24 = a4 + 1;
    uint64_t v25 = a1 + 12;
    uint64_t v26 = a4;
    while (1)
    {
      uint64_t v27 = *(void *)(v25 + 8 * v22);
      a2[v26] = v22;
      if ((v27 & 3) == 2)
      {
        std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v34, a7);
        unint64_t v31 = v27 & 0xFFFFFFFFFFFFFFFCLL;
        uint64_t v29 = v34;
        char v30 = nlp::searchListRanked(v31, a2, v23, v24, 0, a6, (uint64_t)v34);
      }
      else
      {
        if ((v27 & 3) != 1) {
          goto LABEL_20;
        }
        std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v35, a7);
        unint64_t v28 = v27 & 0xFFFFFFFFFFFFFFFCLL;
        uint64_t v29 = v35;
        char v30 = nlp::searchLevelRanked(v28, a2, v23, v24, 0, a6, v35);
      }
      char v33 = v30;
      std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::~__value_func[abi:ne180100](v29);
LABEL_20:
      BOOL v21 = v33 != 0;
      if (!v33)
      {
        BOOL v20 = v22++ == 255;
        if (!v20) {
          continue;
        }
      }
      return v21;
    }
  }
  return v21;
}

void sub_1A43F13B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::~__value_func[abi:ne180100](va);
  _Unwind_Resume(a1);
}

BOOL nlp::searchLevel(int *a1, unsigned char *a2, uint64_t a3, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  char v32 = 0;
  if (a4 < a3)
  {
    uint64_t v14 = *(void *)&a1[2 * a2[a4] + 1];
    if ((v14 & 3) == 2)
    {
      std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v35, a7);
      int v15 = v35;
      uint64_t v16 = nlp::searchList(v14 & 0xFFFFFFFFFFFFFFFCLL, a2, a3, a4 + 1, a5, a6, (uint64_t)v35);
      goto LABEL_25;
    }
    if ((v14 & 3) == 1)
    {
      std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v36, a7);
      int v15 = v36;
      uint64_t v16 = nlp::searchLevel(v14 & 0xFFFFFFFFFFFFFFFCLL, a2, a3, a4 + 1, a5, a6, v36);
LABEL_25:
      BOOL v20 = v16;
      std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::~__value_func[abi:ne180100](v15);
      return v20;
    }
    return 0;
  }
  int v17 = *a1;
  if (!*a1)
  {
    if (a5) {
      return 0;
    }
    goto LABEL_14;
  }
  int v18 = malloc_type_malloc(a4 + 21, 0x64E2CA22uLL);
  v18[4] = a4;
  *((unsigned char *)v18 + a4 + 2nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)&__p, 0) = 0;
  memcpy(v18 + 5, a2, a4);
  v18[2] = v17;
  *int v18 = 0;
  v18[3] = 1;
  std::function<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::operator()(a7, a6, (uint64_t)v18, 1, (uint64_t)&v32);
  BOOL v19 = v18[3]-- == 1;
  if (v19) {
    free(v18);
  }
  BOOL v20 = v32 != 0;
  if (!v32 && (a5 & 1) == 0)
  {
LABEL_14:
    uint64_t v21 = 0;
    uint64_t v22 = (a3 + 1);
    uint64_t v23 = a4 + 1;
    uint64_t v24 = a1 + 1;
    uint64_t v25 = a4;
    while (1)
    {
      uint64_t v26 = *(void *)&v24[2 * v21];
      a2[v25] = v21;
      if ((v26 & 3) == 2)
      {
        std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v33, a7);
        unint64_t v30 = v26 & 0xFFFFFFFFFFFFFFFCLL;
        unint64_t v28 = v33;
        char v29 = nlp::searchList(v30, a2, v22, v23, 0, a6, (uint64_t)v33);
      }
      else
      {
        if ((v26 & 3) != 1) {
          goto LABEL_20;
        }
        std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v34, a7);
        unint64_t v27 = v26 & 0xFFFFFFFFFFFFFFFCLL;
        unint64_t v28 = v34;
        char v29 = nlp::searchLevel(v27, a2, v22, v23, 0, a6, v34);
      }
      char v32 = v29;
      std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::~__value_func[abi:ne180100](v28);
LABEL_20:
      BOOL v20 = v32 != 0;
      if (!v32)
      {
        BOOL v19 = v21++ == 255;
        if (!v19) {
          continue;
        }
      }
      return v20;
    }
  }
  return v20;
}

void sub_1A43F1688(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::~__value_func[abi:ne180100](va);
  _Unwind_Resume(a1);
}

BOOL nlp::searchCompactDiskLevelRanked(uint64_t a1, int8x8_t *a2, unsigned char *a3, uint64_t a4, unsigned int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  char v55 = 0;
  if (a5 < a4)
  {
    unint64_t v14 = a3[a5];
    uint64_t v15 = v14 >> 6;
    int8x8_t v16 = a2[v14 >> 6];
    uint64_t v17 = 1 << v14;
    if (((1 << v14) & *(void *)&v16) != 0)
    {
      if (v14 >= 0x40)
      {
        int v18 = 0;
        if (v15 <= 1) {
          uint64_t v15 = 1;
        }
        else {
          uint64_t v15 = v15;
        }
        size_t v39 = a2;
        do
        {
          int8x8_t v40 = *v39++;
          uint8x8_t v41 = (uint8x8_t)vcnt_s8(v40);
          v41.i16[0] = vaddlv_u8(v41);
          v18 += v41.i32[0];
          --v15;
        }
        while (v15);
      }
      else
      {
        int v18 = 0;
      }
      uint8x8_t v42 = (uint8x8_t)vcnt_s8((int8x8_t)((v17 - 1) & *(void *)&v16));
      v42.i16[0] = vaddlv_u8(v42);
      __int32 v43 = a2[5].i32[v18 + v42.i32[0] + 1];
      int v44 = v43 & 3;
      switch(v44)
      {
        case 1:
          uint64_t v49 = *(void *)(a1 + 2080);
          std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v61, a8);
          uint64_t v50 = (v43 & 0xFFFFFFFC) + v49;
          uint64_t v47 = v61;
          uint64_t v48 = nlp::searchDiskLevelRanked(a1, v50, a3, a4, a5 + 1, a6, a7, v61);
          goto LABEL_44;
        case 2:
          uint64_t v51 = *(void *)(a1 + 2080);
          std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v59, a8);
          uint64_t v47 = v59;
          uint64_t v48 = nlp::searchDiskPageRanked((unsigned int *)((v43 & 0xFFFFFFFC) + v51), a3, a4, a5 + 1, a6, a7, (uint64_t)v59);
          goto LABEL_44;
        case 3:
          uint64_t v45 = *(void *)(a1 + 2080);
          std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v60, a8);
          uint64_t v46 = (v43 & 0xFFFFFFFC) + v45;
          uint64_t v47 = v60;
          uint64_t v48 = nlp::searchCompactDiskLevelRanked(a1, v46, a3, a4, a5 + 1, a6, a7, v60);
LABEL_44:
          BOOL v23 = v48;
          std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::~__value_func[abi:ne180100](v47);
          return v23;
      }
    }
    return 0;
  }
  __int32 v19 = a2[5].i32[0];
  if (!v19)
  {
    if (a6) {
      return 0;
    }
    goto LABEL_13;
  }
  __int32 v20 = a2[4].i32[1];
  uint64_t v21 = malloc_type_malloc(a4 + 21, 0x64E2CA22uLL);
  v21[4] = a4;
  *((unsigned char *)v21 + a4 + 2nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)&__p, 0) = 0;
  memcpy(v21 + 5, a3, a4);
  v21[2] = v19;
  *uint64_t v21 = v20;
  void v21[3] = 1;
  std::function<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::operator()(a8, a7, (uint64_t)v21, 1, (uint64_t)&v55);
  if (v21[3]-- == 1) {
    free(v21);
  }
  BOOL v23 = v55 != 0;
  if (!v55 && (a6 & 1) == 0)
  {
LABEL_13:
    unint64_t v24 = 0;
    uint64_t v25 = (a4 + 1);
    while (1)
    {
      if (v24 >> 6 <= 1) {
        uint64_t v26 = 1;
      }
      else {
        uint64_t v26 = v24 >> 6;
      }
      int8x8_t v27 = a2[v24 >> 6];
      if ((*(void *)&v27 & (1 << v24)) == 0) {
        goto LABEL_29;
      }
      if (v24 >= 0x40)
      {
        int v28 = 0;
        char v29 = a2;
        do
        {
          int8x8_t v30 = *v29++;
          uint8x8_t v31 = (uint8x8_t)vcnt_s8(v30);
          v31.i16[0] = vaddlv_u8(v31);
          v28 += v31.i32[0];
          --v26;
        }
        while (v26);
      }
      else
      {
        int v28 = 0;
      }
      uint8x8_t v32 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)&v27 & ((1 << v24) - 1)));
      v32.i16[0] = vaddlv_u8(v32);
      __int32 v33 = a2[5].i32[v28 + v32.i32[0] + 1];
      a3[a5] = v24;
      int v34 = v33 & 3;
      switch(v34)
      {
        case 1:
          uint64_t v37 = *(void *)(a1 + 2080);
          std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v58, a8);
          char v55 = nlp::searchDiskLevelRanked(a1, v37 + (v33 & 0xFFFFFFFC), a3, v25, a5 + 1, 0, a7, v58);
          unsigned int v36 = v58;
          break;
        case 2:
          uint64_t v38 = *(void *)(a1 + 2080);
          std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v56, a8);
          char v55 = nlp::searchDiskPageRanked((unsigned int *)(v38 + (v33 & 0xFFFFFFFC)), a3, v25, a5 + 1, 0, a7, (uint64_t)v56);
          unsigned int v36 = v56;
          break;
        case 3:
          uint64_t v35 = *(void *)(a1 + 2080);
          std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v57, a8);
          char v55 = nlp::searchCompactDiskLevelRanked(a1, v35 + (v33 & 0xFFFFFFFC), a3, v25, a5 + 1, 0, a7, v57);
          unsigned int v36 = v57;
          break;
        default:
          goto LABEL_29;
      }
      std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::~__value_func[abi:ne180100](v36);
LABEL_29:
      BOOL v23 = v55 != 0;
      if (!v55 && ++v24 != 256) {
        continue;
      }
      return v23;
    }
  }
  return v23;
}

void sub_1A43F1AFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::~__value_func[abi:ne180100](va);
  _Unwind_Resume(a1);
}

uint64_t nlp::searchDiskPageRanked(unsigned int *a1, unsigned char *a2, unsigned int a3, int a4, char a5, uint64_t a6, uint64_t a7)
{
  char v37 = 0;
  unsigned int v7 = *a1;
  if (!*a1) {
    return 0;
  }
  int v8 = a4;
  int v9 = a3;
  unsigned int v11 = 0;
  uint64_t v12 = &a2[a4];
  int v13 = a3 - a4;
  size_t __n = (int)(a3 - a4);
  char v29 = v12;
  __dst = &a2[a3];
  size_t v28 = a3;
  while (1)
  {
    unint64_t v14 = (char *)a1 + v11;
    uint64_t v15 = *((unsigned __int16 *)v14 + 8);
    if (v13 > (int)v15) {
      goto LABEL_14;
    }
    int8x8_t v16 = v14 + 8;
    uint64_t v17 = v14 + 18;
    if (memcmp(v14 + 18, v12, __n)) {
      goto LABEL_14;
    }
    char v18 = a5;
    if (v13 == v15) {
      char v18 = 0;
    }
    if (v18) {
      goto LABEL_14;
    }
    size_t v19 = (v15 + v8);
    size_t v20 = (v19 - v9);
    size_t v21 = v28;
    if ((int)v20 >= 1)
    {
      memcpy(__dst, &v17[v15 - (int)v20], v20);
      size_t v21 = v19;
      int v9 = v19;
    }
    a2[v21] = 0;
    int v22 = *((_DWORD *)v16 + 1);
    int v23 = *(_DWORD *)v16;
    unint64_t v24 = malloc_type_malloc(v21 + 21, 0x64E2CA22uLL);
    void v24[4] = v9;
    *((unsigned char *)v24 + v21 + 2nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)&__p, 0) = 0;
    memcpy(v24 + 5, a2, v21);
    *unint64_t v24 = v23;
    void v24[2] = v22;
    v24[3] = 1;
    std::function<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::operator()(a7, a6, (uint64_t)v24, v13 == v15, (uint64_t)&v37);
    int v25 = v24[3] - 1;
    v24[3] = v25;
    if (!v25) {
      free(v24);
    }
    int v9 = a3;
    int v8 = a4;
    uint64_t v12 = v29;
    if (v37) {
      return 1;
    }
    LODWORD(v15) = *((unsigned __int16 *)v16 + 4);
LABEL_14:
    v11 += v15 + 10;
    if (v11 >= v7) {
      return 0;
    }
  }
}

uint64_t std::function<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5)
{
  uint64_t v10 = a2;
  uint64_t v9 = a3;
  char v8 = a4;
  uint64_t v7 = a5;
  uint64_t v5 = *(void *)(a1 + 24);
  if (!v5) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *, char *, uint64_t *))(*(void *)v5 + 48))(v5, &v10, &v9, &v8, &v7);
}

uint64_t std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t std::function<void ()(void *,nlp::_TrieCompletion *,BOOL *)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = a2;
  uint64_t v6 = a4;
  uint64_t v7 = a3;
  uint64_t v4 = *(void *)(a1 + 24);
  if (!v4) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *))(*(void *)v4 + 48))(v4, &v8, &v7, &v6);
}

void std::__function::__func<void (*)(void *,nlp::_TrieCompletion *,BOOL,BOOL *),std::allocator<void (*)(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>,void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::~__func()
{
}

void *std::__function::__func<void (*)(void *,nlp::_TrieCompletion *,BOOL,BOOL *),std::allocator<void (*)(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>,void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF7CDEB0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void (*)(void *,nlp::_TrieCompletion *,BOOL,BOOL *),std::allocator<void (*)(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>,void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF7CDEB0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<void (*)(void *,nlp::_TrieCompletion *,BOOL,BOOL *),std::allocator<void (*)(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>,void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::operator()(uint64_t a1, void *a2, void *a3, unsigned __int8 *a4, void *a5)
{
  return (*(uint64_t (**)(void, void, void, void))(a1 + 8))(*a2, *a3, *a4, *a5);
}

uint64_t std::__function::__func<void (*)(void *,nlp::_TrieCompletion *,BOOL,BOOL *),std::allocator<void (*)(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>,void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void (*)(void *,nlp::_TrieCompletion *,BOOL,BOOL *),std::allocator<void (*)(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>,void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::target_type()
{
}

void *std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

BOOL nlp::searchCompactDiskLevel(uint64_t a1, int8x8_t *a2, char *a3, uint64_t a4, unsigned int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  char v55 = 0;
  if (a5 < a4)
  {
    unint64_t v14 = a3[a5];
    uint64_t v15 = v14 >> 6;
    int8x8_t v16 = a2[v14 >> 6];
    uint64_t v17 = 1 << v14;
    if (((1 << v14) & *(void *)&v16) != 0)
    {
      if (v14 >= 0x40)
      {
        int v18 = 0;
        if (v15 <= 1) {
          uint64_t v15 = 1;
        }
        else {
          uint64_t v15 = v15;
        }
        uint64_t v38 = a2;
        do
        {
          int8x8_t v39 = *v38++;
          uint8x8_t v40 = (uint8x8_t)vcnt_s8(v39);
          v40.i16[0] = vaddlv_u8(v40);
          v18 += v40.i32[0];
          --v15;
        }
        while (v15);
      }
      else
      {
        int v18 = 0;
      }
      uint8x8_t v41 = (uint8x8_t)vcnt_s8((int8x8_t)((v17 - 1) & *(void *)&v16));
      v41.i16[0] = vaddlv_u8(v41);
      __int32 v42 = a2[4].i32[v18 + v41.i32[0] + 1];
      int v43 = v42 & 3;
      switch(v43)
      {
        case 1:
          uint64_t v48 = *(void *)(a1 + 2080);
          std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v61, a8);
          uint64_t v49 = (v42 & 0xFFFFFFFC) + v48;
          uint64_t v46 = v61;
          uint64_t v47 = nlp::searchDiskLevel(a1, v49, a3, a4, a5 + 1, a6, a7, v61);
          goto LABEL_44;
        case 2:
          uint64_t v50 = *(void *)(a1 + 2080);
          std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v59, a8);
          uint64_t v51 = (unsigned int *)((v42 & 0xFFFFFFFC) + v50);
          uint64_t v46 = v59;
          uint64_t v47 = nlp::searchDiskPage(a1, v51, a3, a4, a5 + 1, a6, a7, (uint64_t)v59);
          goto LABEL_44;
        case 3:
          uint64_t v44 = *(void *)(a1 + 2080);
          std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v60, a8);
          uint64_t v45 = (v42 & 0xFFFFFFFC) + v44;
          uint64_t v46 = v60;
          uint64_t v47 = nlp::searchCompactDiskLevel(a1, v45, a3, a4, a5 + 1, a6, a7, v60);
LABEL_44:
          BOOL v22 = v47;
          std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::~__value_func[abi:ne180100](v46);
          return v22;
      }
    }
    return 0;
  }
  __int32 v19 = a2[4].i32[0];
  if (!v19)
  {
    if (a6) {
      return 0;
    }
    goto LABEL_13;
  }
  size_t v20 = malloc_type_malloc(a4 + 21, 0x64E2CA22uLL);
  v20[4] = a4;
  *((unsigned char *)v20 + a4 + 2nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)&__p, 0) = 0;
  memcpy(v20 + 5, a3, a4);
  v20[2] = v19;
  *size_t v20 = 0;
  v20[3] = 1;
  std::function<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::operator()(a8, a7, (uint64_t)v20, 1, (uint64_t)&v55);
  if (v20[3]-- == 1) {
    free(v20);
  }
  BOOL v22 = v55 != 0;
  if (!v55 && (a6 & 1) == 0)
  {
LABEL_13:
    unint64_t v23 = 0;
    uint64_t v24 = (a4 + 1);
    while (1)
    {
      if (v23 >> 6 <= 1) {
        uint64_t v25 = 1;
      }
      else {
        uint64_t v25 = v23 >> 6;
      }
      int8x8_t v26 = a2[v23 >> 6];
      if ((*(void *)&v26 & (1 << v23)) == 0) {
        goto LABEL_29;
      }
      if (v23 >= 0x40)
      {
        int v27 = 0;
        size_t v28 = a2;
        do
        {
          int8x8_t v29 = *v28++;
          uint8x8_t v30 = (uint8x8_t)vcnt_s8(v29);
          v30.i16[0] = vaddlv_u8(v30);
          v27 += v30.i32[0];
          --v25;
        }
        while (v25);
      }
      else
      {
        int v27 = 0;
      }
      uint8x8_t v31 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)&v26 & ((1 << v23) - 1)));
      v31.i16[0] = vaddlv_u8(v31);
      __int32 v32 = a2[4].i32[v27 + v31.i32[0] + 1];
      a3[a5] = v23;
      int v33 = v32 & 3;
      switch(v33)
      {
        case 1:
          uint64_t v36 = *(void *)(a1 + 2080);
          std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v58, a8);
          char v55 = nlp::searchDiskLevel(a1, v36 + (v32 & 0xFFFFFFFC), a3, v24, a5 + 1, 0, a7, v58);
          uint64_t v35 = v58;
          break;
        case 2:
          uint64_t v37 = *(void *)(a1 + 2080);
          std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v56, a8);
          char v55 = nlp::searchDiskPage(a1, (unsigned int *)(v37 + (v32 & 0xFFFFFFFC)), a3, v24, a5 + 1, 0, a7, (uint64_t)v56);
          uint64_t v35 = v56;
          break;
        case 3:
          uint64_t v34 = *(void *)(a1 + 2080);
          std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::__value_func[abi:ne180100]((uint64_t)v57, a8);
          char v55 = nlp::searchCompactDiskLevel(a1, v34 + (v32 & 0xFFFFFFFC), a3, v24, a5 + 1, 0, a7, v57);
          uint64_t v35 = v57;
          break;
        default:
          goto LABEL_29;
      }
      std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::~__value_func[abi:ne180100](v35);
LABEL_29:
      BOOL v22 = v55 != 0;
      if (!v55 && ++v23 != 256) {
        continue;
      }
      return v22;
    }
  }
  return v22;
}

void sub_1A43F2410(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::~__value_func[abi:ne180100](va);
  _Unwind_Resume(a1);
}

uint64_t nlp::searchDiskPage(uint64_t a1, unsigned int *a2, char *a3, unsigned int a4, int a5, char a6, uint64_t a7, uint64_t a8)
{
  int v8 = a5;
  unsigned int v9 = a4;
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  char v64 = 0;
  int v11 = a4 - a5;
  unsigned int v12 = *a2;
  if ((*(unsigned char *)(a1 + 2064) & 4) != 0)
  {
    memset(__s1, 0, sizeof(__s1));
    if (v12)
    {
      size_t v28 = 0;
      unsigned int v29 = 0;
      int v52 = a5 - a4;
      __s2a = &a3[a5];
      uint64_t v51 = &a3[a4];
      do
      {
        uint8x8_t v30 = (char *)a2 + v29;
        uint64_t v31 = v30[10];
        if (v28)
        {
          uint64_t v32 = v28[6];
          if (v31 > v32) {
            memcpy((char *)__s1 + v32, v28 + 7, v31 - v32);
          }
        }
        size_t v28 = v30 + 4;
        unsigned int v33 = *((unsigned __int16 *)v30 + 4);
        int v34 = v33 + v31;
        if ((int)(v33 + v31) >= v11)
        {
          if (v9 == v8 || ((int)v31 >= v11 ? (int v35 = v11) : (int v35 = v31), !memcmp(__s1, __s2a, v35)))
          {
            unsigned int v36 = v11 - v31;
            if (v11 - (int)v31 < 0
              || ((int)v33 >= (int)v36 ? (size_t v37 = v36) : (size_t v37 = v33), !memcmp(v28 + 7, &__s2a[v31], v37)))
            {
              char v38 = a6;
              if (v11 == v34) {
                char v38 = 0;
              }
              if ((v38 & 1) == 0)
              {
                unsigned int v39 = v9;
                unsigned int v40 = v31 + v8;
                size_t v41 = v31 + v8 - v39;
                if ((int)v41 < 1)
                {
                  unsigned int v40 = v39;
                }
                else
                {
                  memcpy(v51, (char *)__s1 + v31 - (int)v41, v41);
                  unsigned int v33 = *((unsigned __int16 *)v28 + 2);
                  LODWORD(v31) = v28[6];
                }
                int v42 = v52 + v33 + v31;
                if (v42 < 1)
                {
                  uint64_t v44 = a3;
                }
                else
                {
                  int v43 = v42 - (v41 & ~((int)v41 >> 31));
                  uint64_t v44 = a3;
                  memcpy(&a3[v40], &v28[v33 - v43 + 7], v43);
                  v40 += v43;
                }
                char v54 = v11 == v34;
                v44[v40] = 0;
                int v45 = *(_DWORD *)v28;
                uint64_t v46 = malloc_type_malloc(v40 + 21, 0x64E2CA22uLL);
                v46[4] = v40;
                *((unsigned char *)v46 + v40 + 2nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)&__p, 0) = 0;
                memcpy(v46 + 5, v44, v40);
                *uint64_t v46 = 0;
                v46[2] = v45;
                v46[3] = 1;
                std::function<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::operator()(a8, a7, (uint64_t)v46, v54, (uint64_t)&v64);
                int v47 = v46[3] - 1;
                v46[3] = v47;
                if (!v47) {
                  free(v46);
                }
                unsigned int v9 = a4;
                if (v64) {
                  return 1;
                }
                unsigned int v33 = *((unsigned __int16 *)v28 + 2);
                int v8 = a5;
              }
            }
          }
        }
        v29 += v33 + 7;
      }
      while (v29 < v12);
    }
  }
  else if (v12)
  {
    unsigned int v13 = 0;
    unint64_t v14 = &a3[a5];
    size_t v15 = v11;
    __dst = &a3[a4];
    size_t v50 = a4;
    uint64_t v53 = v14;
    do
    {
      int8x8_t v16 = (char *)a2 + v13;
      uint64_t v17 = *((unsigned __int16 *)v16 + 4);
      if (v11 <= (int)v17)
      {
        int v18 = v16 + 4;
        __int32 v19 = v16 + 10;
        if (!memcmp(v16 + 10, v14, v15))
        {
          char v20 = a6;
          if (v11 == v17) {
            char v20 = 0;
          }
          if ((v20 & 1) == 0)
          {
            size_t v21 = (v17 + v8);
            int v22 = a4;
            size_t v23 = v21 - a4;
            size_t v24 = v50;
            if ((int)v23 >= 1)
            {
              memcpy(__dst, &v19[v17 - (int)v23], v23);
              size_t v24 = v21;
              int v22 = v21;
            }
            a3[v24] = 0;
            int v25 = *(_DWORD *)v18;
            int8x8_t v26 = malloc_type_malloc(v24 + 21, 0x64E2CA22uLL);
            v26[4] = v22;
            *((unsigned char *)v26 + v24 + 2nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)&__p, 0) = 0;
            memcpy(v26 + 5, a3, v24);
            _DWORD *v26 = 0;
            v26[2] = v25;
            void v26[3] = 1;
            std::function<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::operator()(a8, a7, (uint64_t)v26, v11 == v17, (uint64_t)&v64);
            int v27 = v26[3] - 1;
            void v26[3] = v27;
            if (!v27) {
              free(v26);
            }
            int v8 = a5;
            size_t v15 = v11;
            unint64_t v14 = v53;
            if (v64) {
              return 1;
            }
            LODWORD(v17) = *((unsigned __int16 *)v18 + 2);
          }
        }
      }
      v13 += v17 + 6;
    }
    while (v13 < v12);
  }
  return 0;
}

uint64_t nlp::searchListRanked(uint64_t result, unsigned char *a2, unsigned int a3, int a4, char a5, uint64_t a6, uint64_t a7)
{
  char v30 = 0;
  if (result)
  {
    int v7 = a4;
    uint64_t v10 = result;
    int v11 = &a2[a4];
    size_t v12 = (int)(a3 - a4);
    size_t v26 = a3;
    char v13 = a5;
    __dst = &a2[a3];
    while (1)
    {
      uint64_t v14 = *(unsigned __int16 *)(v10 + 20);
      if ((int)v12 <= (int)v14 && !memcmp((const void *)(v10 + 22), v11, v12))
      {
        char v15 = v12 == v14 ? 0 : v13;
        if ((v15 & 1) == 0)
        {
          size_t v16 = (v14 + v7);
          size_t v17 = v16 - a3;
          size_t v18 = v26;
          int v19 = a3;
          if ((int)v17 >= 1)
          {
            memcpy(__dst, (const void *)(v10 + 22 + v14 - (int)v17), v17);
            size_t v18 = v16;
            int v19 = v16;
          }
          a2[v18] = 0;
          int v20 = *(_DWORD *)(v10 + 16);
          int v21 = *(_DWORD *)(v10 + 12);
          int v22 = malloc_type_malloc(v18 + 21, 0x64E2CA22uLL);
          void v22[4] = v19;
          *((unsigned char *)v22 + v18 + 2nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)&__p, 0) = 0;
          memcpy(v22 + 5, a2, v18);
          *int v22 = v21;
          v22[2] = v20;
          void v22[3] = 1;
          std::function<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::operator()(a7, a6, (uint64_t)v22, v12 == v14, (uint64_t)&v30);
          int v23 = v22[3] - 1;
          void v22[3] = v23;
          if (!v23) {
            free(v22);
          }
          int v7 = a4;
          char v13 = a5;
          if (v30) {
            break;
          }
        }
      }
      uint64_t v10 = *(void *)v10;
      if (!v10) {
        return 0;
      }
    }
    return 1;
  }
  return result;
}

uint64_t nlp::searchList(uint64_t result, unsigned char *a2, unsigned int a3, int a4, char a5, uint64_t a6, uint64_t a7)
{
  char v29 = 0;
  if (result)
  {
    int v7 = a4;
    uint64_t v10 = result;
    int v11 = &a2[a4];
    size_t v12 = (int)(a3 - a4);
    size_t v25 = a3;
    char v13 = a5;
    __dst = &a2[a3];
    while (1)
    {
      uint64_t v14 = *(unsigned __int16 *)(v10 + 12);
      if ((int)v12 <= (int)v14 && !memcmp((const void *)(v10 + 14), v11, v12))
      {
        char v15 = v12 == v14 ? 0 : v13;
        if ((v15 & 1) == 0)
        {
          size_t v16 = (v14 + v7);
          size_t v17 = v16 - a3;
          size_t v18 = v25;
          int v19 = a3;
          if ((int)v17 >= 1)
          {
            memcpy(__dst, (const void *)(v10 + 14 + v14 - (int)v17), v17);
            size_t v18 = v16;
            int v19 = v16;
          }
          a2[v18] = 0;
          int v20 = *(_DWORD *)(v10 + 8);
          int v21 = malloc_type_malloc(v18 + 21, 0x64E2CA22uLL);
          v21[4] = v19;
          *((unsigned char *)v21 + v18 + 2nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)&__p, 0) = 0;
          memcpy(v21 + 5, a2, v18);
          *int v21 = 0;
          v21[2] = v20;
          void v21[3] = 1;
          std::function<void ()(void *,nlp::_TrieCompletion *,BOOL,BOOL *)>::operator()(a7, a6, (uint64_t)v21, v12 == v14, (uint64_t)&v29);
          int v22 = v21[3] - 1;
          void v21[3] = v22;
          if (!v22) {
            free(v21);
          }
          int v7 = a4;
          char v13 = a5;
          if (v29) {
            break;
          }
        }
      }
      uint64_t v10 = *(void *)v10;
      if (!v10) {
        return 0;
      }
    }
    return 1;
  }
  return result;
}

uint64_t nlp::advanceCompactMapCursorMappedLevel(uint64_t a1, uint64_t a2, unsigned __int8 *a3, int a4)
{
  unint64_t v8 = (*(void *)a2 & 0xFFFFFFFFFFFFFFFCLL) + *(void *)(a1 + 2080);
  if (*(unsigned char *)(a1 + 2064))
  {
    if (!a4)
    {
      *(_DWORD *)(a2 + 16) = *(_DWORD *)(v8 + 1024);
      *(_DWORD *)(a2 + 2nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)&__p, 0) = *(_DWORD *)(v8 + 1032);
      return 1;
    }
  }
  else if (!a4)
  {
    *(_DWORD *)(a2 + 16) = *(_DWORD *)(v8 + 1024);
    return 1;
  }
  nlp::updateCompactMapCursorPointer(a1, a2, *(unsigned int *)(v8 + 4 * *a3));

  return nlp::advanceCompactMapCursor(a1, a2, a3 + 1, (a4 - 1));
}

uint64_t nlp::updateCompactMapCursorPointer(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)a2 != a3)
  {
    switch(a3 & 3)
    {
      case 1:
        unint64_t v3 = (a3 & 0xFFFFFFFFFFFFFFFCLL) + *(void *)(result + 2080);
        if ((*(unsigned char *)(result + 2064) & 1) == 0)
        {
          int v4 = *(_DWORD *)(v3 + 1024);
          goto LABEL_13;
        }
        *(_DWORD *)(a2 + 16) = *(_DWORD *)(v3 + 1024);
        int v8 = *(_DWORD *)(v3 + 1032);
        goto LABEL_16;
      case 2:
        int v5 = *(_DWORD *)(result + 2064);
        if ((v5 & 4) != 0)
        {
          int v4 = *(_DWORD *)((a3 & 0xFFFFFFFFFFFFFFFCLL) + *(void *)(result + 2080));
          goto LABEL_13;
        }
        uint64_t v6 = (int *)((a3 & 0xFFFFFFFFFFFFFFFCLL) + *(void *)(result + 2080));
        if ((v5 & 1) == 0)
        {
          int v4 = *v6;
          goto LABEL_13;
        }
        *(_DWORD *)(a2 + 16) = v6[1];
        int v8 = *v6;
        goto LABEL_16;
      case 3:
        int v7 = (_DWORD *)((a3 & 0xFFFFFFFFFFFFFFFCLL) + *(void *)(result + 2080));
        if (*(unsigned char *)(result + 2064))
        {
          *(_DWORD *)(a2 + 16) = v7[10];
          int v8 = v7[9];
LABEL_16:
          *(_DWORD *)(a2 + 2nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)&__p, 0) = v8;
        }
        else
        {
          int v4 = v7[8];
LABEL_13:
          *(_DWORD *)(a2 + 16) = v4;
        }
LABEL_17:
        *(void *)a2 = a3;
        *(void *)(a2 + 8) = 0;
        break;
      default:
        *(_DWORD *)(a2 + 16) = 0;
        goto LABEL_17;
    }
  }
  return result;
}

uint64_t nlp::advanceMapCursorTrieList(uint64_t a1, uint64_t a2, unsigned __int8 *a3, unsigned int a4, __n128 a5)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *(void *)(a2 + 8);
  if ((*(unsigned char *)(a1 + 2064) & 1) == 0)
  {
    unint64_t v9 = v8 & 0xFFFFFFFFFFFFFFFCLL;
    uint64_t v10 = *(unsigned int *)(a2 + 16);
    if (v10 > *(unsigned __int16 *)((v8 & 0xFFFFFFFFFFFFFFFCLL) + 12)) {
      nlp::advanceMapCursorTrieList();
    }
    if (!v9) {
      return 0;
    }
    unint64_t v11 = v8 & 0xFFFFFFFFFFFFFFFCLL;
    while (1)
    {
      unsigned int v12 = *(unsigned __int16 *)((v8 & 0xFFFFFFFFFFFFFFFCLL) + 12);
      if (v11 != v9)
      {
        unsigned int v12 = *(unsigned __int16 *)(v11 + 12);
        if (v10 >= v12) {
          goto LABEL_19;
        }
        if (v10)
        {
          char v13 = (unsigned __int8 *)(v11 + 14);
          uint64_t v14 = *(unsigned int *)(a2 + 16);
          char v15 = (unsigned __int8 *)(v9 + 14);
          do
          {
            int v17 = *v13++;
            int v16 = v17;
            int v18 = *v15++;
            if (v16 != v18) {
              goto LABEL_19;
            }
          }
          while (--v14);
        }
      }
      LODWORD(v19) = 0;
      int v20 = *(_DWORD *)(a2 + 16);
      if (v10 < v12 && a4)
      {
        unint64_t v19 = 0;
        do
        {
          if (*(unsigned __int8 *)(v11 + v10 + 14 + v19) != a3[v19]) {
            break;
          }
          if (++v19 + v10 >= v12) {
            break;
          }
        }
        while (v19 < a4);
        int v20 = v10 + v19;
      }
      if (v19 == a4)
      {
        *(void *)(a2 + 8) = v11 | 2;
        if (v20 == v12)
        {
          *(_DWORD *)(a2 + 16) = v12;
          *(_DWORD *)(a2 + 2nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)&__p, 0) = *(_DWORD *)(v11 + 8);
        }
        else
        {
          *(void *)(a2 + 16) = v10 + a4;
        }
        return 1;
      }
LABEL_19:
      unint64_t v11 = *(void *)v11;
      if (!v11) {
        return 0;
      }
    }
  }
  v35[1] = v35;
  v35[0] = *(void *)a2;
  a5.n128_u64[0] = *(void *)(a2 + 16);
  float v22 = *(float *)(a2 + 24);
  __n128 v38 = a5;
  MEMORY[0x1F4188790]();
  size_t v24 = (char *)v35 - v23;
  size_t v26 = *(unsigned int *)(a2 + 16);
  memcpy((char *)v35 - v23, (const void *)(v25 + 22), v26);
  unint64_t v27 = *(void *)a2 & 0xFFFFFFFFFFFFFFFCLL;
  if (v27)
  {
    int v37 = 0;
    unsigned int v28 = v26 + a4;
    size_t v36 = a4;
    do
    {
      unsigned int v29 = *(unsigned __int16 *)(v27 + 20);
      if (v28 <= v29 && !memcmp((const void *)(v27 + 22), v24, v26) && !memcmp((const void *)(v27 + 22 + v26), a3, v36))
      {
        if (v28 == v29)
        {
          *(void *)(a2 + 8) = v27 | 2;
          int v34 = *(_DWORD *)(v27 + 16);
          *(_DWORD *)(a2 + 24) = *(_DWORD *)(v27 + 12);
          *(_DWORD *)(a2 + 16) = v28;
          *(_DWORD *)(a2 + 2nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)&__p, 0) = v34;
          return 1;
        }
        __n128 v30 = v38;
        HIDWORD(v31) = 0;
        int v32 = v37;
        if (!v37)
        {
          uint64_t v8 = v27 | 2;
          float v22 = 0.0;
        }
        int v37 = 1;
        if (!v32)
        {
          LODWORD(v31) = v38.n128_u32[0] + a4;
          v30.n128_f64[0] = v31;
        }
        __n128 v38 = v30;
      }
      unint64_t v27 = *(void *)v27;
    }
    while (v27);
  }
  else
  {
    int v37 = 0;
  }
  *(void *)a2 = v35[0];
  *(void *)(a2 + 8) = v8;
  *(void *)(a2 + 16) = v38.n128_u64[0];
  *(float *)(a2 + 24) = v22;
  return v37;
}

uint64_t nlp::updateMapCursorPointer(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a2 + 8) != a3)
  {
    uint64_t v3 = a3 & 3;
    if ((a3 & 3) != 0)
    {
      if (v3 == 2)
      {
        unint64_t v6 = a3 & 0xFFFFFFFFFFFFFFFCLL;
        if ((*(unsigned char *)(result + 2064) & 1) == 0)
        {
          if (*(_WORD *)(v6 + 12)) {
            int v5 = 0;
          }
          else {
            int v5 = *(_DWORD *)(v6 + 8);
          }
          goto LABEL_14;
        }
        *(_DWORD *)(a2 + 2nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)&__p, 0) = *(_DWORD *)(v6 + 16);
        *(_DWORD *)(a2 + 24) = *(_DWORD *)(v6 + 12);
        *(void *)a2 = a3;
      }
      else if (v3 == 1)
      {
        int v4 = (int *)(a3 & 0xFFFFFFFFFFFFFFFCLL);
        if ((*(unsigned char *)(result + 2064) & 1) == 0)
        {
          int v5 = *v4;
LABEL_14:
          *(_DWORD *)(a2 + 2nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)&__p, 0) = v5;
          goto LABEL_15;
        }
        *(_DWORD *)(a2 + 2nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)&__p, 0) = v4[2];
        *(_DWORD *)(a2 + 24) = v4[1];
      }
    }
    else
    {
      *(void *)(a2 + 2nlp::CFScopedPtr<__CFNumber const*>::reset((const void **)&__p, 0) = 0;
    }
LABEL_15:
    *(void *)(a2 + 8) = a3;
    *(_DWORD *)(a2 + 16) = 0;
  }
  return result;
}

void *std::__function::__value_func<float ()(void *,float,float)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__value_func<float ()(void *,float,float)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *nlp::burstTrieCreateCursorWithTrieLevelRef<nlp::_RankedTrieLevel *>(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 0;
  if (a1 && a2)
  {
    if (*(void *)(a1 + 2080)) {
      nlp::burstTrieCreateCursorWithTrieLevelRef<nlp::_RankedTrieLevel *>();
    }
    uint64_t v2 = malloc_type_calloc(0x28uLL, 1uLL, 0xD2939DE6uLL);
    if (nlp::burstTrieSetCursor(a1, (uint64_t)v2))
    {
      v2[1] = a2 | 1;
      *((_DWORD *)v2 + 5) = *(_DWORD *)(a2 + 8);
      *((_DWORD *)v2 + 6) = *(_DWORD *)(a2 + 4);
    }
    else if (v2)
    {
      free(v2);
      return 0;
    }
  }
  return v2;
}

uint64_t std::vector<std::tuple<std::string,unsigned int,float>>::reserve(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  if (a2 > (v4 - *a1) >> 5)
  {
    if (a2 >> 59) {
      std::vector<NLExtendedString>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v5 = a1[1] - *a1;
    v7[4] = result;
    v7[0] = std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<std::string,unsigned int,float>>>(result, a2);
    v7[1] = v7[0] + v5;
    v7[2] = v7[0] + v5;
    void v7[3] = v7[0] + 32 * v6;
    std::vector<std::tuple<std::string,unsigned int,float>>::__swap_out_circular_buffer(a1, v7);
    return std::__split_buffer<std::tuple<std::string,unsigned int,float>>::~__split_buffer((uint64_t)v7);
  }
  return result;
}

void sub_1A43F32CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::tuple<std::string,unsigned int,float>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::__function::__func<void nlp::reverseBurst<nlp::_RankedTrieLevel *,nlp::_RankedListNode *>(nlp::_BurstTrie *,std::vector<nlp::_RankedTrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#1},std::allocator<void nlp::reverseBurst<nlp::_RankedTrieLevel *,nlp::_RankedListNode *>(nlp::_BurstTrie *,std::vector<nlp::_RankedTrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#1}>,void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::~__func()
{
}

void *std::__function::__func<void nlp::reverseBurst<nlp::_RankedTrieLevel *,nlp::_RankedListNode *>(nlp::_BurstTrie *,std::vector<nlp::_RankedTrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#1},std::allocator<void nlp::reverseBurst<nlp::_RankedTrieLevel *,nlp::_RankedListNode *>(nlp::_BurstTrie *,std::vector<nlp::_RankedTrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#1}>,void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF7CE0C0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void nlp::reverseBurst<nlp::_RankedTrieLevel *,nlp::_RankedListNode *>(nlp::_BurstTrie *,std::vector<nlp::_RankedTrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#1},std::allocator<void nlp::reverseBurst<nlp::_RankedTrieLevel *,nlp::_RankedListNode *>(nlp::_BurstTrie *,std::vector<nlp::_RankedTrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#1}>,void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF7CE0C0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<void nlp::reverseBurst<nlp::_RankedTrieLevel *,nlp::_RankedListNode *>(nlp::_BurstTrie *,std::vector<nlp::_RankedTrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#1},std::allocator<void nlp::reverseBurst<nlp::_RankedTrieLevel *,nlp::_RankedListNode *>(nlp::_BurstTrie *,std::vector<nlp::_RankedTrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#1}>,void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::operator()(uint64_t result)
{
  return result;
}

uint64_t std::__function::__func<void nlp::reverseBurst<nlp::_RankedTrieLevel *,nlp::_RankedListNode *>(nlp::_BurstTrie *,std::vector<nlp::_RankedTrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#1},std::allocator<void nlp::reverseBurst<nlp::_RankedTrieLevel *,nlp::_RankedListNode *>(nlp::_BurstTrie *,std::vector<nlp::_RankedTrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#1}>,void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void nlp::reverseBurst<nlp::_RankedTrieLevel *,nlp::_RankedListNode *>(nlp::_BurstTrie *,std::vector<nlp::_RankedTrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#1},std::allocator<void nlp::reverseBurst<nlp::_RankedTrieLevel *,nlp::_RankedListNode *>(nlp::_BurstTrie *,std::vector<nlp::_RankedTrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#1}>,void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::target_type()
{
}

uint64_t std::vector<std::tuple<std::string,unsigned int,float>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::tuple<std::string,unsigned int,float>>,std::reverse_iterator<std::tuple<std::string,unsigned int,float>*>,std::reverse_iterator<std::tuple<std::string,unsigned int,float>*>,std::reverse_iterator<std::tuple<std::string,unsigned int,float>*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<std::string,unsigned int,float>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 59) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(32 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::tuple<std::string,unsigned int,float>>,std::reverse_iterator<std::tuple<std::string,unsigned int,float>*>,std::reverse_iterator<std::tuple<std::string,unsigned int,float>*>,std::reverse_iterator<std::tuple<std::string,unsigned int,float>*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  void v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = a7;
    do
    {
      long long v9 = *(_OWORD *)(a3 - 32);
      *(void *)(v8 - 16) = *(void *)(a3 - 16);
      *(_OWORD *)(v8 - 32) = v9;
      *(void *)(a3 - 24) = 0;
      *(void *)(a3 - 16) = 0;
      *(void *)(a3 - 32) = 0;
      *(void *)(v8 - ++**(_DWORD **)(result + 8) = *(void *)(a3 - 8);
      v8 -= 32;
      v7 -= 32;
      a3 -= 32;
    }
    while (a3 != a5);
    *((void *)&v15 + 1) = v8;
    uint64_t v10 = v15;
  }
  char v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::tuple<std::string,unsigned int,float>>,std::reverse_iterator<std::tuple<std::string,unsigned int,float>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::tuple<std::string,unsigned int,float>>,std::reverse_iterator<std::tuple<std::string,unsigned int,float>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::tuple<std::string,unsigned int,float>>,std::reverse_iterator<std::tuple<std::string,unsigned int,float>*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::tuple<std::string,unsigned int,float>>,std::reverse_iterator<std::tuple<std::string,unsigned int,float>*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    v1 += 32;
  }
}

uint64_t std::__split_buffer<std::tuple<std::string,unsigned int,float>>::~__split_buffer(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__split_buffer<std::tuple<std::string,unsigned int,float>>::__destruct_at_end[abi:ne180100](uint64_t a1, void **a2)
{
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      uint64_t v5 = v2 - 4;
      *(void *)(a1 + 16) = v2 - 4;
      if (*((char *)v2 - 9) < 0)
      {
        operator delete(*v5);
        uint64_t v5 = *(void ***)(a1 + 16);
      }
      uint64_t v2 = v5;
    }
    while (v5 != a2);
  }
}

void std::__function::__func<void nlp::reverseBurst<nlp::_RankedTrieLevel *,nlp::_RankedListNode *>(nlp::_BurstTrie *,std::vector<nlp::_RankedTrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#2},std::allocator<void nlp::reverseBurst<nlp::_RankedTrieLevel *,nlp::_RankedListNode *>(nlp::_BurstTrie *,std::vector<nlp::_RankedTrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#2}>,void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::~__func()
{
}

void *std::__function::__func<void nlp::reverseBurst<nlp::_RankedTrieLevel *,nlp::_RankedListNode *>(nlp::_BurstTrie *,std::vector<nlp::_RankedTrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#2},std::allocator<void nlp::reverseBurst<nlp::_RankedTrieLevel *,nlp::_RankedListNode *>(nlp::_BurstTrie *,std::vector<nlp::_RankedTrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#2}>,void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF7CE068;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void nlp::reverseBurst<nlp::_RankedTrieLevel *,nlp::_RankedListNode *>(nlp::_BurstTrie *,std::vector<nlp::_RankedTrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#2},std::allocator<void nlp::reverseBurst<nlp::_RankedTrieLevel *,nlp::_RankedListNode *>(nlp::_BurstTrie *,std::vector<nlp::_RankedTrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#2}>,void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF7CE068;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void nlp::reverseBurst<nlp::_RankedTrieLevel *,nlp::_RankedListNode *>(nlp::_BurstTrie *,std::vector<nlp::_RankedTrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#2},std::allocator<void nlp::reverseBurst<nlp::_RankedTrieLevel *,nlp::_RankedListNode *>(nlp::_BurstTrie *,std::vector<nlp::_RankedTrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#2}>,void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::operator()(uint64_t a1, uint64_t a2, void **a3, unsigned int *a4, int *a5, int *a6)
{
  int v6 = *a5;
  int v7 = *a6;
  uint64_t v8 = *(uint64_t **)(a1 + 8);
  std::string::basic_string[abi:ne180100](__p, *a3, *a4);
  unint64_t v9 = v8[1];
  unint64_t v10 = v8[2];
  if (v9 >= v10)
  {
    uint64_t v12 = (uint64_t)(v9 - *v8) >> 5;
    unint64_t v13 = v12 + 1;
    if ((unint64_t)(v12 + 1) >> 59) {
      std::vector<NLExtendedString>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v14 = v10 - *v8;
    if (v14 >> 4 > v13) {
      unint64_t v13 = v14 >> 4;
    }
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v15 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v15 = v13;
    }
    v23[4] = v8 + 2;
    if (v15) {
      int v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<std::string,unsigned int,float>>>((uint64_t)(v8 + 2), v15);
    }
    else {
      int v16 = 0;
    }
    int v17 = &v16[32 * v12];
    v23[0] = v16;
    v23[1] = v17;
    v23[3] = &v16[32 * v15];
    long long v18 = *(_OWORD *)__p;
    *((void *)v17 + 2) = v22;
    *(_OWORD *)int v17 = v18;
    __p[1] = 0;
    uint64_t v22 = 0;
    __p[0] = 0;
    *((_DWORD *)v17 + 6) = v6;
    *((_DWORD *)v17 + 7) = v7;
    v23[2] = v17 + 32;
    std::vector<std::tuple<std::string,unsigned int,float>>::__swap_out_circular_buffer(v8, v23);
    uint64_t v19 = v8[1];
    std::__split_buffer<std::tuple<std::string,unsigned int,float>>::~__split_buffer((uint64_t)v23);
    int v20 = SHIBYTE(v22);
    v8[1] = v19;
    if (v20 < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    long long v11 = *(_OWORD *)__p;
    *(void *)(v9 + 16) = v22;
    *(_OWORD *)unint64_t v9 = v11;
    *(_DWORD *)(v9 + 24) = v6;
    *(_DWORD *)(v9 + 2++**(_DWORD **)(result + 8) = v7;
    v8[1] = v9 + 32;
  }
}

void sub_1A43F380C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void nlp::reverseBurst<nlp::_RankedTrieLevel *,nlp::_RankedListNode *>(nlp::_BurstTrie *,std::vector<nlp::_RankedTrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#2},std::allocator<void nlp::reverseBurst<nlp::_RankedTrieLevel *,nlp::_RankedListNode *>(nlp::_BurstTrie *,std::vector<nlp::_RankedTrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#2}>,void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void nlp::reverseBurst<nlp::_RankedTrieLevel *,nlp::_RankedListNode *>(nlp::_BurstTrie *,std::vector<nlp::_RankedTrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#2},std::allocator<void nlp::reverseBurst<nlp::_RankedTrieLevel *,nlp::_RankedListNode *>(nlp::_BurstTrie *,std::vector<nlp::_RankedTrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#2}>,void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::target_type()
{
}

void std::vector<std::tuple<std::string,unsigned int,float>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<std::tuple<std::string,unsigned int,float>>::__clear[abi:ne180100]((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<std::tuple<std::string,unsigned int,float>>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 32)
  {
    if (*(char *)(i - 9) < 0) {
      operator delete(*(void **)(i - 32));
    }
  }
  a1[1] = v2;
}

void *nlp::burstTrieCreateCursorWithTrieLevelRef<nlp::_TrieLevel *>(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = 0;
  if (a1 && a2)
  {
    if (*(void *)(a1 + 2080)) {
      nlp::burstTrieCreateCursorWithTrieLevelRef<nlp::_RankedTrieLevel *>();
    }
    uint64_t v2 = malloc_type_calloc(0x28uLL, 1uLL, 0xD2939DE6uLL);
    if (nlp::burstTrieSetCursor(a1, (uint64_t)v2))
    {
      v2[1] = a2 | 1;
      *((_DWORD *)v2 + 5) = *(_DWORD *)a2;
    }
    else if (v2)
    {
      free(v2);
      return 0;
    }
  }
  return v2;
}

void std::__function::__func<void nlp::reverseBurst<nlp::_TrieLevel *,nlp::_ListNode *>(nlp::_BurstTrie *,std::vector<nlp::_TrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#1},std::allocator<void nlp::reverseBurst<nlp::_TrieLevel *,nlp::_ListNode *>(nlp::_BurstTrie *,std::vector<nlp::_TrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#1}>,void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::~__func()
{
}

void *std::__function::__func<void nlp::reverseBurst<nlp::_TrieLevel *,nlp::_ListNode *>(nlp::_BurstTrie *,std::vector<nlp::_TrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#1},std::allocator<void nlp::reverseBurst<nlp::_TrieLevel *,nlp::_ListNode *>(nlp::_BurstTrie *,std::vector<nlp::_TrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#1}>,void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF7CE010;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void nlp::reverseBurst<nlp::_TrieLevel *,nlp::_ListNode *>(nlp::_BurstTrie *,std::vector<nlp::_TrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#1},std::allocator<void nlp::reverseBurst<nlp::_TrieLevel *,nlp::_ListNode *>(nlp::_BurstTrie *,std::vector<nlp::_TrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#1}>,void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF7CE010;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<void nlp::reverseBurst<nlp::_TrieLevel *,nlp::_ListNode *>(nlp::_BurstTrie *,std::vector<nlp::_TrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#1},std::allocator<void nlp::reverseBurst<nlp::_TrieLevel *,nlp::_ListNode *>(nlp::_BurstTrie *,std::vector<nlp::_TrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#1}>,void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::operator()(uint64_t result)
{
  return result;
}

uint64_t std::__function::__func<void nlp::reverseBurst<nlp::_TrieLevel *,nlp::_ListNode *>(nlp::_BurstTrie *,std::vector<nlp::_TrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#1},std::allocator<void nlp::reverseBurst<nlp::_TrieLevel *,nlp::_ListNode *>(nlp::_BurstTrie *,std::vector<nlp::_TrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#1}>,void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void nlp::reverseBurst<nlp::_TrieLevel *,nlp::_ListNode *>(nlp::_BurstTrie *,std::vector<nlp::_TrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#1},std::allocator<void nlp::reverseBurst<nlp::_TrieLevel *,nlp::_ListNode *>(nlp::_BurstTrie *,std::vector<nlp::_TrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#1}>,void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::target_type()
{
}

void std::__function::__func<void nlp::reverseBurst<nlp::_TrieLevel *,nlp::_ListNode *>(nlp::_BurstTrie *,std::vector<nlp::_TrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#2},std::allocator<void nlp::reverseBurst<nlp::_TrieLevel *,nlp::_ListNode *>(nlp::_BurstTrie *,std::vector<nlp::_TrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#2}>,void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::~__func()
{
}

void *std::__function::__func<void nlp::reverseBurst<nlp::_TrieLevel *,nlp::_ListNode *>(nlp::_BurstTrie *,std::vector<nlp::_TrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#2},std::allocator<void nlp::reverseBurst<nlp::_TrieLevel *,nlp::_ListNode *>(nlp::_BurstTrie *,std::vector<nlp::_TrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#2}>,void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF7CDFB8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void nlp::reverseBurst<nlp::_TrieLevel *,nlp::_ListNode *>(nlp::_BurstTrie *,std::vector<nlp::_TrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#2},std::allocator<void nlp::reverseBurst<nlp::_TrieLevel *,nlp::_ListNode *>(nlp::_BurstTrie *,std::vector<nlp::_TrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#2}>,void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF7CDFB8;
  a2[1] = v2;
  return result;
}

void std::__function::__func<void nlp::reverseBurst<nlp::_TrieLevel *,nlp::_ListNode *>(nlp::_BurstTrie *,std::vector<nlp::_TrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#2},std::allocator<void nlp::reverseBurst<nlp::_TrieLevel *,nlp::_ListNode *>(nlp::_BurstTrie *,std::vector<nlp::_TrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#2}>,void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::operator()(uint64_t a1, uint64_t a2, void **a3, unsigned int *a4, int *a5, int *a6)
{
  int v6 = *a5;
  int v7 = *a6;
  uint64_t v8 = *(uint64_t **)(a1 + 8);
  std::string::basic_string[abi:ne180100](__p, *a3, *a4);
  unint64_t v9 = v8[1];
  unint64_t v10 = v8[2];
  if (v9 >= v10)
  {
    uint64_t v12 = (uint64_t)(v9 - *v8) >> 5;
    unint64_t v13 = v12 + 1;
    if ((unint64_t)(v12 + 1) >> 59) {
      std::vector<NLExtendedString>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v14 = v10 - *v8;
    if (v14 >> 4 > v13) {
      unint64_t v13 = v14 >> 4;
    }
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v15 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v15 = v13;
    }
    v23[4] = v8 + 2;
    if (v15) {
      int v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<std::string,unsigned int,float>>>((uint64_t)(v8 + 2), v15);
    }
    else {
      int v16 = 0;
    }
    int v17 = &v16[32 * v12];
    v23[0] = v16;
    v23[1] = v17;
    v23[3] = &v16[32 * v15];
    long long v18 = *(_OWORD *)__p;
    *((void *)v17 + 2) = v22;
    *(_OWORD *)int v17 = v18;
    __p[1] = 0;
    uint64_t v22 = 0;
    __p[0] = 0;
    *((_DWORD *)v17 + 6) = v6;
    *((_DWORD *)v17 + 7) = v7;
    v23[2] = v17 + 32;
    std::vector<std::tuple<std::string,unsigned int,float>>::__swap_out_circular_buffer(v8, v23);
    uint64_t v19 = v8[1];
    std::__split_buffer<std::tuple<std::string,unsigned int,float>>::~__split_buffer((uint64_t)v23);
    int v20 = SHIBYTE(v22);
    v8[1] = v19;
    if (v20 < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    long long v11 = *(_OWORD *)__p;
    *(void *)(v9 + 16) = v22;
    *(_OWORD *)unint64_t v9 = v11;
    *(_DWORD *)(v9 + 24) = v6;
    *(_DWORD *)(v9 + 2++**(_DWORD **)(result + 8) = v7;
    v8[1] = v9 + 32;
  }
}

void sub_1A43F3C78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void nlp::reverseBurst<nlp::_TrieLevel *,nlp::_ListNode *>(nlp::_BurstTrie *,std::vector<nlp::_TrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#2},std::allocator<void nlp::reverseBurst<nlp::_TrieLevel *,nlp::_ListNode *>(nlp::_BurstTrie *,std::vector<nlp::_TrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#2}>,void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void nlp::reverseBurst<nlp::_TrieLevel *,nlp::_ListNode *>(nlp::_BurstTrie *,std::vector<nlp::_TrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#2},std::allocator<void nlp::reverseBurst<nlp::_TrieLevel *,nlp::_ListNode *>(nlp::_BurstTrie *,std::vector<nlp::_TrieLevel *> const&,unsigned char const*,unsigned int)::{lambda(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)#2}>,void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::target_type()
{
}

uint64_t std::__function::__value_func<void ()(void *,nlp::_TrieCompletion *,BOOL *)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void std::__function::__func<nlp::BurstTrieSearch(nlp::_BurstTrie const*,unsigned char const*,unsigned int,void *,std::function<void ()(void *,nlp::_TrieCompletion *,BOOL *)>,int)::$_0,std::allocator<nlp::BurstTrieSearch(nlp::_BurstTrie const*,unsigned char const*,unsigned int,void *,std::function<void ()(void *,nlp::_TrieCompletion *,BOOL *)>,int)::$_0>,void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::~__func()
{
}

__n128 std::__function::__func<nlp::BurstTrieSearch(nlp::_BurstTrie const*,unsigned char const*,unsigned int,void *,std::function<void ()(void *,nlp::_TrieCompletion *,BOOL *)>,int)::$_0,std::allocator<nlp::BurstTrieSearch(nlp::_BurstTrie const*,unsigned char const*,unsigned int,void *,std::function<void ()(void *,nlp::_TrieCompletion *,BOOL *)>,int)::$_0>,void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1EF7CDF60;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + ++**(_DWORD **)(result + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<nlp::BurstTrieSearch(nlp::_BurstTrie const*,unsigned char const*,unsigned int,void *,std::function<void ()(void *,nlp::_TrieCompletion *,BOOL *)>,int)::$_0,std::allocator<nlp::BurstTrieSearch(nlp::_BurstTrie const*,unsigned char const*,unsigned int,void *,std::function<void ()(void *,nlp::_TrieCompletion *,BOOL *)>,int)::$_0>,void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF7CDF60;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + ++**(_DWORD **)(result + 8) = result;
  return result;
}

void std::__function::__func<nlp::BurstTrieSearch(nlp::_BurstTrie const*,unsigned char const*,unsigned int,void *,std::function<void ()(void *,nlp::_TrieCompletion *,BOOL *)>,int)::$_0,std::allocator<nlp::BurstTrieSearch(nlp::_BurstTrie const*,unsigned char const*,unsigned int,void *,std::function<void ()(void *,nlp::_TrieCompletion *,BOOL *)>,int)::$_0>,void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::operator()()
{
}

uint64_t std::__function::__func<nlp::BurstTrieSearch(nlp::_BurstTrie const*,unsigned char const*,unsigned int,void *,std::function<void ()(void *,nlp::_TrieCompletion *,BOOL *)>,int)::$_0,std::allocator<nlp::BurstTrieSearch(nlp::_BurstTrie const*,unsigned char const*,unsigned int,void *,std::function<void ()(void *,nlp::_TrieCompletion *,BOOL *)>,int)::$_0>,void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<nlp::BurstTrieSearch(nlp::_BurstTrie const*,unsigned char const*,unsigned int,void *,std::function<void ()(void *,nlp::_TrieCompletion *,BOOL *)>,int)::$_0,std::allocator<nlp::BurstTrieSearch(nlp::_BurstTrie const*,unsigned char const*,unsigned int,void *,std::function<void ()(void *,nlp::_TrieCompletion *,BOOL *)>,int)::$_0>,void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::target_type()
{
}

void *std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__value_func<void ()(void *,unsigned char const*,unsigned int,unsigned int,float,BOOL *)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

const __CFString *nlp::getUTF8StringFromCFString@<X0>(const __CFString *this@<X0>, void *a2@<X8>)
{
  if (this)
  {
    CFStringRef v4 = this;
    CStringPtr = (char *)CFStringGetCStringPtr(this, 0x8000100u);
    if (!CStringPtr)
    {
      CFIndex Length = CFStringGetLength(v4);
      CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
      operator new[]();
    }
    return (const __CFString *)std::string::basic_string[abi:ne180100]<0>(a2, CStringPtr);
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
  }
  return this;
}

void sub_1A43F41B8(_Unwind_Exception *a1)
{
  MEMORY[0x1A625B110](v1, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  uint64_t v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    std::string::size_type v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17) {
      std::string::size_type v6 = __sz | 7;
    }
    std::string::size_type v7 = v6 + 1;
    uint64_t v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    uint64_t v5 = v8;
  }
  else
  {
    *((unsigned char *)&this->__r_.__value_.__s + 23) = __sz;
  }

  memmove(v5, __s, __sz + 1);
}

void ___ZNK26NLTransliterationCandidate13getTotalScoreEv_block_invoke_cold_1(uint64_t a1, uint64_t a2, os_log_t log)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  int v3 = 138412802;
  uint64_t v4 = a1;
  __int16 v5 = 2112;
  uint64_t v6 = a2;
  __int16 v7 = 2048;
  uint64_t v8 = NLTransliterationCandidate::getTotalScore(void)const::lmDistributionModulatingFactor;
  _os_log_error_impl(&dword_1A431F000, log, OS_LOG_TYPE_ERROR, "Failed to create dictionary with contents of url %@:%@, using default value: %f", (uint8_t *)&v3, 0x20u);
}

void ___ZNK26NLTransliterationCandidate13getTotalScoreEv_block_invoke_cold_2()
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  OUTLINED_FUNCTION_0();
  _os_log_error_impl(&dword_1A431F000, v0, OS_LOG_TYPE_ERROR, "LM distribution modulating factor is not in range [0, 1]: %@, using default value: %f", v1, 0x16u);
}

void ___ZNK26NLTransliterationCandidate13getTotalScoreEv_block_invoke_cold_3()
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  OUTLINED_FUNCTION_0();
  _os_log_error_impl(&dword_1A431F000, v0, OS_LOG_TYPE_ERROR, "LM distribution modulating factor is not of number type: %@, using default value: %f", v1, 0x16u);
}

void NLHindiWordLanguageModeler::loadLanguageModel()
{
  OUTLINED_FUNCTION_0_0(*MEMORY[0x1E4F143B8]);
  int v2 = 136315138;
  uint64_t v3 = v0;
  _os_log_error_impl(&dword_1A431F000, v1, OS_LOG_TYPE_ERROR, "Failed to create language model for locale: %s", (uint8_t *)&v2, 0xCu);
}

{
  uint64_t v0;
  os_log_t v1;
  int v2;
  uint64_t v3;

  OUTLINED_FUNCTION_0_0(*MEMORY[0x1E4F143B8]);
  int v2 = 136315138;
  uint64_t v3 = v0;
  _os_log_debug_impl(&dword_1A431F000, v1, OS_LOG_TYPE_DEBUG, "Successfully created language model for locale: %s", (uint8_t *)&v2, 0xCu);
}

{
  uint64_t v0;
  os_log_t v1;
  int v2;
  uint64_t v3;

  OUTLINED_FUNCTION_0_0(*MEMORY[0x1E4F143B8]);
  int v2 = 136315138;
  uint64_t v3 = v0;
  _os_log_debug_impl(&dword_1A431F000, v1, OS_LOG_TYPE_DEBUG, "Creating language model for locale: %s", (uint8_t *)&v2, 0xCu);
}

void NL::ParseBuilder::merge(char a1, std::__shared_weak_count **a2, void *a3, std::__shared_weak_count *a4)
{
  if ((a1 & 1) == 0) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a4);
  }
  _Block_object_dispose(a2, 8);
  uint64_t v6 = a2[6];
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
  _Block_object_dispose(a3, 8);
  __int16 v7 = (std::__shared_weak_count *)a3[6];
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
}

void loadPlistFromFile(os_log_t log)
{
  *(_WORD *)os_log_t v1 = 0;
  _os_log_fault_impl(&dword_1A431F000, log, OS_LOG_TYPE_FAULT, "can not load the property list from disk!", v1, 2u);
}

{
  uint8_t v1[16];

  *(_WORD *)os_log_t v1 = 0;
  _os_log_fault_impl(&dword_1A431F000, log, OS_LOG_TYPE_FAULT, "Can not fetch the language and keywords from the given plist!", v1, 2u);
}

uint64_t std::shared_ptr<std::__empty_state<char>>::shared_ptr[abi:ne180100]<std::__empty_state<char>,void>(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 8))();
}

void loadAlternteKeywordsPlistFromFile(os_log_t log)
{
  *(_WORD *)os_log_t v1 = 0;
  _os_log_fault_impl(&dword_1A431F000, log, OS_LOG_TYPE_FAULT, "Could not extract the alternative keywords for each language in the given plist", v1, 2u);
}

{
  uint8_t v1[16];

  *(_WORD *)os_log_t v1 = 0;
  _os_log_fault_impl(&dword_1A431F000, log, OS_LOG_TYPE_FAULT, "Could not load the mappings from resource bundle", v1, 2u);
}

void lookslikeProperName_cold_1(os_log_t log)
{
  *(_WORD *)os_log_t v1 = 0;
  _os_log_debug_impl(&dword_1A431F000, log, OS_LOG_TYPE_DEBUG, "Checking for names in CoreSpotlight index", v1, 2u);
}

void _CSSimpleQueryHasResultsForQuery()
{
  dlerror();
  uint64_t v0 = (void **)abort_report_np();
  NL::SearchRules::SearchRules(v0, v1, v2, v3);
}

void NL::SearchRules::SearchRules(void **a1, void **a2, void **a3, void *a4)
{
  __int16 v7 = *a1;
  if (v7)
  {
    a4[20] = v7;
    operator delete(v7);
  }
  uint64_t v8 = *a2;
  if (*a2)
  {
    a4[17] = v8;
    operator delete(v8);
  }
  uint64_t v9 = *a3;
  if (*a3)
  {
    a4[14] = v9;
    operator delete(v9);
  }
}

void NLTextStructuredEvent::NLTextStructuredEvent(void **a1, std::__shared_weak_count **a2, uint64_t a3)
{
  uint64_t v4 = *a1;
  if (v4)
  {
    *(void *)(a3 + 64) = v4;
    operator delete(v4);
  }
  __int16 v5 = *a2;
  if (*a2)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
}

void SearchParser::SearchParser(void *a1, NL::ParseBuilder **a2, NL::ParserResources **a3)
{
  uint64_t v6 = (std::__shared_weak_count *)a1[10];
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
  std::unique_ptr<NL::ParseBuilder>::reset[abi:ne180100](a2, 0);
  __int16 v7 = (std::__shared_weak_count *)a1[7];
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  std::unique_ptr<NL::ParserResources>::reset[abi:ne180100](a3, 0);
  uint64_t v8 = (std::__shared_weak_count *)a1[4];
  if (v8)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  }
}

uint64_t SearchParser::init(std::__shared_weak_count **a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  return MEMORY[0x1A625B130](a2, 0x20C4074B9A93DLL);
}

void NLCompositeTransliterator::getTransliterationCandidates(char *a1, uint8_t *buf, os_log_t log)
{
  if (a1[23] >= 0) {
    uint64_t v4 = a1;
  }
  else {
    uint64_t v4 = *(char **)a1;
  }
  *(_DWORD *)buf = 136315394;
  *(void *)(buf + 4) = "Candidates";
  *((_WORD *)buf + 6) = 2080;
  *(void *)(buf + 14) = v4;
  _os_log_debug_impl(&dword_1A431F000, log, OS_LOG_TYPE_DEBUG, "%s:\n %s", buf, 0x16u);
  if (a1[23] < 0) {
    operator delete(*(void **)a1);
  }
}

void NL::SearchGrammar::SearchGrammar(NL::SearchRules **a1, uint64_t a2)
{
  std::unique_ptr<NL::SearchRules>::reset[abi:ne180100](a1, 0);
  if (*(char *)(a2 + 23) < 0)
  {
    uint64_t v3 = *(void **)a2;
    operator delete(v3);
  }
}

void NLPCreateStringWithValidatedFormat(uint64_t a1, uint64_t a2, os_log_t log)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  int v3 = 138412546;
  uint64_t v4 = a1;
  __int16 v5 = 2112;
  uint64_t v6 = a2;
  _os_log_error_impl(&dword_1A431F000, log, OS_LOG_TYPE_ERROR, "Failed to create string with format %@:%@", (uint8_t *)&v3, 0x16u);
}

void std::__sort_heap[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::unique_ptr<NLMessageIntentCandidate> const&,std::unique_ptr<NLMessageIntentCandidate> const&),std::unique_ptr<NLMessageIntentCandidate>*>(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table(a1 + 8);

  JUMPOUT(0x1A625B130);
}

void NL::ParseFormatter::copyFormattedResult(uint64_t a1, NSObject *a2)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  int v2 = 138412290;
  uint64_t v3 = a1;
  _os_log_debug_impl(&dword_1A431F000, a2, OS_LOG_TYPE_DEBUG, "query: %@", (uint8_t *)&v2, 0xCu);
}

void nlp::addListNode()
{
  __assert_rtn("addListNode", "BurstTrie.cpp", 578, "listcount <= trie->reserved[ContainerSize]");
}

void nlp::addListNodeRanked()
{
  __assert_rtn("addListNodeRanked", "BurstTrie.cpp", 717, "listcount <= trie->reserved[ContainerSize]");
}

void nlp::advanceMapCursorTrieList()
{
  __assert_rtn("advanceMapCursorTrieList", "BurstTrie.cpp", 1855, "cursor->prfxlen <= head->restlen");
}

void nlp::burstTrieCreateCursorWithTrieLevelRef<nlp::_RankedTrieLevel *>()
{
  __assert_rtn("burstTrieCreateCursorWithTrieLevelRef", "BurstTrie.cpp", 2634, "nullptr == trie->mapbase");
}

uint64_t CEMEmojiLocaleDataCreateEmojiTokensForString()
{
  return MEMORY[0x1F4113BD8]();
}

uint64_t CEMEmojiTokenGetString()
{
  return MEMORY[0x1F4113C58]();
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  MEMORY[0x1F40D70A8]();
  return result;
}

CFAllocatorRef CFAllocatorGetDefault(void)
{
  return (CFAllocatorRef)MEMORY[0x1F40D7110]();
}

void CFArrayAppendArray(CFMutableArrayRef theArray, CFArrayRef otherArray, CFRange otherRange)
{
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
}

Boolean CFArrayContainsValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x1F40D7160](theArray, range.location, range.length, value);
}

CFArrayRef CFArrayCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks)
{
  return (CFArrayRef)MEMORY[0x1F40D7170](allocator, values, numValues, callBacks);
}

CFArrayRef CFArrayCreateCopy(CFAllocatorRef allocator, CFArrayRef theArray)
{
  return (CFArrayRef)MEMORY[0x1F40D7178](allocator, theArray);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x1F40D7190](allocator, capacity, callBacks);
}

CFMutableArrayRef CFArrayCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFArrayRef theArray)
{
  return (CFMutableArrayRef)MEMORY[0x1F40D7198](allocator, capacity, theArray);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x1F40D71B8](theArray);
}

CFTypeID CFArrayGetTypeID(void)
{
  return MEMORY[0x1F40D71D8]();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x1F40D71F0](theArray, idx);
}

void CFArrayInsertValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
}

void CFArrayRemoveAllValues(CFMutableArrayRef theArray)
{
}

void CFArraySortValues(CFMutableArrayRef theArray, CFRange range, CFComparatorFunction comparator, void *context)
{
}

CFAttributedStringRef CFAttributedStringCreate(CFAllocatorRef alloc, CFStringRef str, CFDictionaryRef attributes)
{
  return (CFAttributedStringRef)MEMORY[0x1F40D7240](alloc, str, attributes);
}

CFMutableAttributedStringRef CFAttributedStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  return (CFMutableAttributedStringRef)MEMORY[0x1F40D7250](alloc, maxLength);
}

CFMutableAttributedStringRef CFAttributedStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFAttributedStringRef aStr)
{
  return (CFMutableAttributedStringRef)MEMORY[0x1F40D7258](alloc, maxLength, aStr);
}

CFIndex CFAttributedStringGetLength(CFAttributedStringRef aStr)
{
  return MEMORY[0x1F40D7298](aStr);
}

void CFAttributedStringReplaceString(CFMutableAttributedStringRef aStr, CFRange range, CFStringRef replacement)
{
}

void CFAttributedStringSetAttribute(CFMutableAttributedStringRef aStr, CFRange range, CFStringRef attrName, CFTypeRef value)
{
}

void CFAttributedStringSetAttributes(CFMutableAttributedStringRef aStr, CFRange range, CFDictionaryRef replacement, Boolean clearOtherAttributes)
{
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x1F40D7430](BOOLean);
}

CFStringRef CFBundleCopyLocalizedString(CFBundleRef bundle, CFStringRef key, CFStringRef value, CFStringRef tableName)
{
  return (CFStringRef)MEMORY[0x1F40D74A8](bundle, key, value, tableName);
}

CFURLRef CFBundleCopyResourceURL(CFBundleRef bundle, CFStringRef resourceName, CFStringRef resourceType, CFStringRef subDirName)
{
  return (CFURLRef)MEMORY[0x1F40D74D0](bundle, resourceName, resourceType, subDirName);
}

CFURLRef CFBundleCopyResourcesDirectoryURL(CFBundleRef bundle)
{
  return (CFURLRef)MEMORY[0x1F40D7500](bundle);
}

CFBundleRef CFBundleGetBundleWithIdentifier(CFStringRef bundleID)
{
  return (CFBundleRef)MEMORY[0x1F40D7538](bundleID);
}

uint64_t CFBurstTrieCreateFromMapBytes()
{
  return MEMORY[0x1F40D7640]();
}

uint64_t CFBurstTrieFindUTF8String()
{
  return MEMORY[0x1F40D7648]();
}

uint64_t CFBurstTrieRelease()
{
  return MEMORY[0x1F40D7658]();
}

Boolean CFCalendarAddComponents(CFCalendarRef calendar, CFAbsoluteTime *at, CFOptionFlags options, const char *componentDesc, ...)
{
  return MEMORY[0x1F40D7670](calendar, at, options, componentDesc);
}

Boolean CFCalendarComposeAbsoluteTime(CFCalendarRef calendar, CFAbsoluteTime *at, const char *componentDesc, ...)
{
  return MEMORY[0x1F40D7678](calendar, at, componentDesc);
}

CFCalendarRef CFCalendarCopyCurrent(void)
{
  return (CFCalendarRef)MEMORY[0x1F40D7680]();
}

CFCalendarRef CFCalendarCreateWithIdentifier(CFAllocatorRef allocator, CFCalendarIdentifier identifier)
{
  return (CFCalendarRef)MEMORY[0x1F40D7690](allocator, identifier);
}

Boolean CFCalendarDecomposeAbsoluteTime(CFCalendarRef calendar, CFAbsoluteTime at, const char *componentDesc, ...)
{
  va_start(va, componentDesc);
  uint64_t v3 = va_arg(va, void);
  return MEMORY[0x1F40D7698](calendar, v3, at);
}

CFCalendarIdentifier CFCalendarGetIdentifier(CFCalendarRef calendar)
{
  return (CFCalendarIdentifier)MEMORY[0x1F40D76A8](calendar);
}

CFRange CFCalendarGetMaximumRangeOfUnit(CFCalendarRef calendar, CFCalendarUnit unit)
{
  CFIndex v2 = MEMORY[0x1F40D76B0](calendar, unit);
  result.CFIndex length = v3;
  result.CFIndex location = v2;
  return result;
}

CFRange CFCalendarGetRangeOfUnit(CFCalendarRef calendar, CFCalendarUnit smallerUnit, CFCalendarUnit biggerUnit, CFAbsoluteTime at)
{
  CFIndex v4 = MEMORY[0x1F40D76C0](calendar, smallerUnit, biggerUnit, at);
  result.CFIndex length = v5;
  result.CFIndex location = v4;
  return result;
}

void CFCalendarSetFirstWeekday(CFCalendarRef calendar, CFIndex wkdy)
{
}

void CFCalendarSetTimeZone(CFCalendarRef calendar, CFTimeZoneRef tz)
{
}

void CFCharacterSetAddCharactersInRange(CFMutableCharacterSetRef theSet, CFRange theRange)
{
}

CFCharacterSetRef CFCharacterSetCreateCopy(CFAllocatorRef alloc, CFCharacterSetRef theSet)
{
  return (CFCharacterSetRef)MEMORY[0x1F40D7708](alloc, theSet);
}

CFCharacterSetRef CFCharacterSetCreateInvertedSet(CFAllocatorRef alloc, CFCharacterSetRef theSet)
{
  return (CFCharacterSetRef)MEMORY[0x1F40D7710](alloc, theSet);
}

CFMutableCharacterSetRef CFCharacterSetCreateMutable(CFAllocatorRef alloc)
{
  return (CFMutableCharacterSetRef)MEMORY[0x1F40D7718](alloc);
}

CFMutableCharacterSetRef CFCharacterSetCreateMutableCopy(CFAllocatorRef alloc, CFCharacterSetRef theSet)
{
  return (CFMutableCharacterSetRef)MEMORY[0x1F40D7720](alloc, theSet);
}

CFCharacterSetRef CFCharacterSetCreateWithCharactersInString(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFCharacterSetRef)MEMORY[0x1F40D7738](alloc, theString);
}

CFCharacterSetRef CFCharacterSetGetPredefined(CFCharacterSetPredefinedSet theSetIdentifier)
{
  return (CFCharacterSetRef)MEMORY[0x1F40D7740](theSetIdentifier);
}

Boolean CFCharacterSetIsCharacterMember(CFCharacterSetRef theSet, UniChar theChar)
{
  return MEMORY[0x1F40D7770](theSet, theChar);
}

void CFCharacterSetUnion(CFMutableCharacterSetRef theSet, CFCharacterSetRef theOtherSet)
{
}

CFDateRef CFDateCreate(CFAllocatorRef allocator, CFAbsoluteTime at)
{
  return (CFDateRef)MEMORY[0x1F40D7898](allocator, at);
}

CFDateFormatterRef CFDateFormatterCreate(CFAllocatorRef allocator, CFLocaleRef locale, CFDateFormatterStyle dateStyle, CFDateFormatterStyle timeStyle)
{
  return (CFDateFormatterRef)MEMORY[0x1F40D78B0](allocator, locale, dateStyle, timeStyle);
}

CFStringRef CFDateFormatterCreateDateFormatFromTemplate(CFAllocatorRef allocator, CFStringRef tmplate, CFOptionFlags options, CFLocaleRef locale)
{
  return (CFStringRef)MEMORY[0x1F40D78B8](allocator, tmplate, options, locale);
}

CFDateFormatterRef CFDateFormatterCreateISO8601Formatter(CFAllocatorRef allocator, CFISO8601DateFormatOptions formatOptions)
{
  return (CFDateFormatterRef)MEMORY[0x1F40D78D0](allocator, formatOptions);
}

CFStringRef CFDateFormatterCreateStringWithDate(CFAllocatorRef allocator, CFDateFormatterRef formatter, CFDateRef date)
{
  return (CFStringRef)MEMORY[0x1F40D78E0](allocator, formatter, date);
}

void CFDateFormatterSetFormat(CFDateFormatterRef formatter, CFStringRef formatString)
{
}

CFAbsoluteTime CFDateGetAbsoluteTime(CFDateRef theDate)
{
  MEMORY[0x1F40D7928](theDate);
  return result;
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return MEMORY[0x1F40D7968](theDict, key);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x1F40D7978](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFDictionaryRef CFDictionaryCreateCopy(CFAllocatorRef allocator, CFDictionaryRef theDict)
{
  return (CFDictionaryRef)MEMORY[0x1F40D7990](allocator, theDict);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x1F40D7998](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  return (CFMutableDictionaryRef)MEMORY[0x1F40D79A8](allocator, capacity, theDict);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x1F40D79C0](theDict);
}

void CFDictionaryGetKeysAndValues(CFDictionaryRef theDict, const void **keys, const void **values)
{
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x1F40D7A00]();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x1F40D7A10](theDict, key);
}

Boolean CFDictionaryGetValueIfPresent(CFDictionaryRef theDict, const void *key, const void **value)
{
  return MEMORY[0x1F40D7A18](theDict, key, value);
}

void CFDictionaryRemoveAllValues(CFMutableDictionaryRef theDict)
{
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x1F40D7A68](cf1, cf2);
}

CFStringRef CFErrorCopyDescription(CFErrorRef err)
{
  return (CFStringRef)MEMORY[0x1F40D7A80](err);
}

CFTypeID CFErrorGetTypeID(void)
{
  return MEMORY[0x1F40D7AC0]();
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x1F40D7B80](cf);
}

CFLocaleRef CFLocaleCopyCurrent(void)
{
  return (CFLocaleRef)MEMORY[0x1F40D7BB8]();
}

CFArrayRef CFLocaleCopyPreferredLanguages(void)
{
  return (CFArrayRef)MEMORY[0x1F40D7BD8]();
}

CFLocaleRef CFLocaleCreate(CFAllocatorRef allocator, CFLocaleIdentifier localeIdentifier)
{
  return (CFLocaleRef)MEMORY[0x1F40D7BE0](allocator, localeIdentifier);
}

CFLocaleIdentifier CFLocaleCreateCanonicalLocaleIdentifierFromString(CFAllocatorRef allocator, CFStringRef localeIdentifier)
{
  return (CFLocaleIdentifier)MEMORY[0x1F40D7BF8](allocator, localeIdentifier);
}

CFLocaleRef CFLocaleCreateCopy(CFAllocatorRef allocator, CFLocaleRef locale)
{
  return (CFLocaleRef)MEMORY[0x1F40D7C08](allocator, locale);
}

CFLocaleIdentifier CFLocaleCreateLocaleIdentifierFromComponents(CFAllocatorRef allocator, CFDictionaryRef dictionary)
{
  return (CFLocaleIdentifier)MEMORY[0x1F40D7C10](allocator, dictionary);
}

CFLocaleIdentifier CFLocaleGetIdentifier(CFLocaleRef locale)
{
  return (CFLocaleIdentifier)MEMORY[0x1F40D7C20](locale);
}

CFTypeID CFLocaleGetTypeID(void)
{
  return MEMORY[0x1F40D7C40]();
}

CFTypeRef CFLocaleGetValue(CFLocaleRef locale, CFLocaleKey key)
{
  return (CFTypeRef)MEMORY[0x1F40D7C48](locale, key);
}

uint64_t CFLog()
{
  return MEMORY[0x1F40D7C50]();
}

CFTypeRef CFMakeCollectable(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x1F40D7CA0](cf);
}

void CFNotificationCenterAddObserver(CFNotificationCenterRef center, const void *observer, CFNotificationCallback callBack, CFStringRef name, const void *object, CFNotificationSuspensionBehavior suspensionBehavior)
{
}

CFNotificationCenterRef CFNotificationCenterGetLocalCenter(void)
{
  return (CFNotificationCenterRef)MEMORY[0x1F40D7D20]();
}

void CFNotificationCenterRemoveObserver(CFNotificationCenterRef center, const void *observer, CFNotificationName name, const void *object)
{
}

CFComparisonResult CFNumberCompare(CFNumberRef number, CFNumberRef otherNumber, void *context)
{
  return MEMORY[0x1F40D7D78](number, otherNumber, context);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x1F40D7D80](allocator, theType, valuePtr);
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x1F40D7E20](number, theType, valuePtr);
}

CFPropertyListRef CFPreferencesCopyValue(CFStringRef key, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return (CFPropertyListRef)MEMORY[0x1F40D7ED0](key, applicationID, userName, hostName);
}

Boolean CFPreferencesGetAppBooleanValue(CFStringRef key, CFStringRef applicationID, Boolean *keyExistsAndHasValidFormat)
{
  return MEMORY[0x1F40D7EE0](key, applicationID, keyExistsAndHasValidFormat);
}

CFIndex CFPreferencesGetAppIntegerValue(CFStringRef key, CFStringRef applicationID, Boolean *keyExistsAndHasValidFormat)
{
  return MEMORY[0x1F40D7EE8](key, applicationID, keyExistsAndHasValidFormat);
}

CFPropertyListRef CFPropertyListCreateFromXMLData(CFAllocatorRef allocator, CFDataRef xmlData, CFOptionFlags mutabilityOption, CFStringRef *errorString)
{
  return (CFPropertyListRef)MEMORY[0x1F40D7F40](allocator, xmlData, mutabilityOption, errorString);
}

CFPropertyListRef CFPropertyListCreateWithData(CFAllocatorRef allocator, CFDataRef data, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return (CFPropertyListRef)MEMORY[0x1F40D7F50](allocator, data, options, format, error);
}

CFPropertyListRef CFPropertyListCreateWithStream(CFAllocatorRef allocator, CFReadStreamRef stream, CFIndex streamLength, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return (CFPropertyListRef)MEMORY[0x1F40D7F58](allocator, stream, streamLength, options, format, error);
}

Boolean CFPropertyListIsValid(CFPropertyListRef plist, CFPropertyListFormat format)
{
  return MEMORY[0x1F40D7F68](plist, format);
}

void CFReadStreamClose(CFReadStreamRef stream)
{
}

CFReadStreamRef CFReadStreamCreateWithFile(CFAllocatorRef alloc, CFURLRef fileURL)
{
  return (CFReadStreamRef)MEMORY[0x1F40D7FC0](alloc, fileURL);
}

Boolean CFReadStreamOpen(CFReadStreamRef stream)
{
  return MEMORY[0x1F40D7FF8](stream);
}

void CFRelease(CFTypeRef cf)
{
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x1F40D8048](cf);
}

void CFSetAddValue(CFMutableSetRef theSet, const void *value)
{
}

Boolean CFSetContainsValue(CFSetRef theSet, const void *value)
{
  return MEMORY[0x1F40D81F8](theSet, value);
}

CFMutableSetRef CFSetCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFSetCallBacks *callBacks)
{
  return (CFMutableSetRef)MEMORY[0x1F40D8210](allocator, capacity, callBacks);
}

CFIndex CFSetGetCount(CFSetRef theSet)
{
  return MEMORY[0x1F40D8220](theSet);
}

void CFSetGetValues(CFSetRef theSet, const void **values)
{
}

void CFSetRemoveAllValues(CFMutableSetRef theSet)
{
}

void CFShow(CFTypeRef obj)
{
}

void CFStringAppend(CFMutableStringRef theString, CFStringRef appendedString)
{
}

void CFStringAppendCharacters(CFMutableStringRef theString, const UniChar *chars, CFIndex numChars)
{
}

void CFStringAppendFormat(CFMutableStringRef theString, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1F40D8388](theString1, theString2, compareOptions);
}

CFArrayRef CFStringCreateArrayBySeparatingStrings(CFAllocatorRef alloc, CFStringRef theString, CFStringRef separatorString)
{
  return (CFArrayRef)MEMORY[0x1F40D83D0](alloc, theString, separatorString);
}

CFArrayRef CFStringCreateArrayWithFindResults(CFAllocatorRef alloc, CFStringRef theString, CFStringRef stringToFind, CFRange rangeToSearch, CFStringCompareFlags compareOptions)
{
  return (CFArrayRef)MEMORY[0x1F40D83D8](alloc, theString, stringToFind, rangeToSearch.location, rangeToSearch.length, compareOptions);
}

CFStringRef CFStringCreateByCombiningStrings(CFAllocatorRef alloc, CFArrayRef theArray, CFStringRef separatorString)
{
  return (CFStringRef)MEMORY[0x1F40D83E0](alloc, theArray, separatorString);
}

CFStringRef CFStringCreateCopy(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFStringRef)MEMORY[0x1F40D83F0](alloc, theString);
}

CFMutableStringRef CFStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  return (CFMutableStringRef)MEMORY[0x1F40D8408](alloc, maxLength);
}

CFMutableStringRef CFStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFStringRef theString)
{
  return (CFMutableStringRef)MEMORY[0x1F40D8410](alloc, maxLength, theString);
}

CFStringRef CFStringCreateStringWithValidatedFormatAndArguments(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef validFormatSpecifiers, CFStringRef format, va_list arguments, CFErrorRef *errorPtr)
{
  return (CFStringRef)MEMORY[0x1F40D8428](alloc, formatOptions, validFormatSpecifiers, format, arguments, errorPtr);
}

CFStringRef CFStringCreateWithBytes(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation)
{
  return (CFStringRef)MEMORY[0x1F40D8438](alloc, bytes, numBytes, *(void *)&encoding, isExternalRepresentation);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1F40D8448](alloc, cStr, *(void *)&encoding);
}

CFStringRef CFStringCreateWithCharacters(CFAllocatorRef alloc, const UniChar *chars, CFIndex numChars)
{
  return (CFStringRef)MEMORY[0x1F40D8460](alloc, chars, numChars);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return (CFStringRef)MEMORY[0x1F40D8490](alloc, formatOptions, format);
}

CFStringRef CFStringCreateWithSubstring(CFAllocatorRef alloc, CFStringRef str, CFRange range)
{
  return (CFStringRef)MEMORY[0x1F40D84A8](alloc, str, range.location, range.length);
}

void CFStringDelete(CFMutableStringRef theString, CFRange range)
{
}

CFRange CFStringFind(CFStringRef theString, CFStringRef stringToFind, CFStringCompareFlags compareOptions)
{
  CFIndex v3 = MEMORY[0x1F40D84C8](theString, stringToFind, compareOptions);
  result.CFIndex length = v4;
  result.CFIndex location = v3;
  return result;
}

CFIndex CFStringFindAndReplace(CFMutableStringRef theString, CFStringRef stringToFind, CFStringRef replacementString, CFRange rangeToSearch, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1F40D84D0](theString, stringToFind, replacementString, rangeToSearch.location, rangeToSearch.length, compareOptions);
}

Boolean CFStringFindCharacterFromSet(CFStringRef theString, CFCharacterSetRef theSet, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result)
{
  return MEMORY[0x1F40D84D8](theString, theSet, rangeToSearch.location, rangeToSearch.length, searchOptions, result);
}

Boolean CFStringFindWithOptions(CFStringRef theString, CFStringRef stringToFind, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result)
{
  return MEMORY[0x1F40D84E0](theString, stringToFind, rangeToSearch.location, rangeToSearch.length, searchOptions, result);
}

CFIndex CFStringGetBytes(CFStringRef theString, CFRange range, CFStringEncoding encoding, UInt8 lossByte, Boolean isExternalRepresentation, UInt8 *buffer, CFIndex maxBufLen, CFIndex *usedBufLen)
{
  return MEMORY[0x1F40D8500](theString, range.location, range.length, *(void *)&encoding, lossByte, isExternalRepresentation, buffer, maxBufLen);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x1F40D8510](theString, buffer, bufferSize, *(void *)&encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x1F40D8520](theString, *(void *)&encoding);
}

UniChar CFStringGetCharacterAtIndex(CFStringRef theString, CFIndex idx)
{
  return MEMORY[0x1F40D8528](theString, idx);
}

void CFStringGetCharacters(CFStringRef theString, CFRange range, UniChar *buffer)
{
}

const UniChar *__cdecl CFStringGetCharactersPtr(CFStringRef theString)
{
  return (const UniChar *)MEMORY[0x1F40D8540](theString);
}

double CFStringGetDoubleValue(CFStringRef str)
{
  MEMORY[0x1F40D8548](str);
  return result;
}

SInt32 CFStringGetIntValue(CFStringRef str)
{
  return MEMORY[0x1F40D8568](str);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x1F40D8578](theString);
}

CFIndex CFStringGetMaximumSizeForEncoding(CFIndex length, CFStringEncoding encoding)
{
  return MEMORY[0x1F40D8590](length, *(void *)&encoding);
}

CFRange CFStringGetRangeOfComposedCharactersAtIndex(CFStringRef theString, CFIndex theIndex)
{
  CFIndex v2 = MEMORY[0x1F40D85D8](theString, theIndex);
  result.CFIndex length = v3;
  result.CFIndex location = v2;
  return result;
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x1F40D85F0]();
}

Boolean CFStringHasPrefix(CFStringRef theString, CFStringRef prefix)
{
  return MEMORY[0x1F40D8600](theString, prefix);
}

Boolean CFStringHasSuffix(CFStringRef theString, CFStringRef suffix)
{
  return MEMORY[0x1F40D8608](theString, suffix);
}

void CFStringLowercase(CFMutableStringRef theString, CFLocaleRef locale)
{
}

void CFStringNormalize(CFMutableStringRef theString, CFStringNormalizationForm theForm)
{
}

void CFStringReplace(CFMutableStringRef theString, CFRange range, CFStringRef replacement)
{
}

CFStringTokenizerTokenType CFStringTokenizerAdvanceToNextToken(CFStringTokenizerRef tokenizer)
{
  return MEMORY[0x1F40D8680](tokenizer);
}

CFTypeRef CFStringTokenizerCopyCurrentTokenAttribute(CFStringTokenizerRef tokenizer, CFOptionFlags attribute)
{
  return (CFTypeRef)MEMORY[0x1F40D8690](tokenizer, attribute);
}

CFStringTokenizerRef CFStringTokenizerCreate(CFAllocatorRef alloc, CFStringRef string, CFRange range, CFOptionFlags options, CFLocaleRef locale)
{
  return (CFStringTokenizerRef)MEMORY[0x1F40D8698](alloc, string, range.location, range.length, options, locale);
}

void CFStringTokenizerSetString(CFStringTokenizerRef tokenizer, CFStringRef string, CFRange range)
{
}

Boolean CFStringTransform(CFMutableStringRef string, CFRange *range, CFStringRef transform, Boolean reverse)
{
  return MEMORY[0x1F40D86C0](string, range, transform, reverse);
}

void CFStringTrimWhitespace(CFMutableStringRef theString)
{
}

void CFStringUppercase(CFMutableStringRef theString, CFLocaleRef locale)
{
}

CFTimeZoneRef CFTimeZoneCopySystem(void)
{
  return (CFTimeZoneRef)MEMORY[0x1F40D86F8]();
}

CFURLRef CFURLCopyAbsoluteURL(CFURLRef relativeURL)
{
  return (CFURLRef)MEMORY[0x1F40D8740](relativeURL);
}

CFStringRef CFURLCopyLastPathComponent(CFURLRef url)
{
  return (CFStringRef)MEMORY[0x1F40D8770](url);
}

CFStringRef CFURLCopyPath(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1F40D8790](anURL);
}

CFURLRef CFURLCreateCopyAppendingPathComponent(CFAllocatorRef allocator, CFURLRef url, CFStringRef pathComponent, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1F40D87F8](allocator, url, pathComponent, isDirectory);
}

Boolean CFURLCreateDataAndPropertiesFromResource(CFAllocatorRef alloc, CFURLRef url, CFDataRef *resourceData, CFDictionaryRef *properties, CFArrayRef desiredProperties, SInt32 *errorCode)
{
  return MEMORY[0x1F40D8828](alloc, url, resourceData, properties, desiredProperties, errorCode);
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1F40D88A0](allocator, filePath, pathStyle, isDirectory);
}

CFURLRef CFURLCreateWithString(CFAllocatorRef allocator, CFStringRef URLString, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x1F40D88C0](allocator, URLString, baseURL);
}

Boolean CFURLGetFileSystemRepresentation(CFURLRef url, Boolean resolveAgainstBase, UInt8 *buffer, CFIndex maxBufLen)
{
  return MEMORY[0x1F40D8908](url, resolveAgainstBase, buffer, maxBufLen);
}

CFTypeID CFURLGetTypeID(void)
{
  return MEMORY[0x1F40D8928]();
}

Boolean CFURLResourceIsReachable(CFURLRef url, CFErrorRef *error)
{
  return MEMORY[0x1F40D8948](url, error);
}

uint64_t DDResultCopyExtractedDateFromReferenceDateWithLocale()
{
  return MEMORY[0x1F4117190]();
}

uint64_t DDResultGetCategory()
{
  return MEMORY[0x1F4117208]();
}

uint64_t DDResultGetMatchedString()
{
  return MEMORY[0x1F4117218]();
}

uint64_t DDResultGetRange()
{
  return MEMORY[0x1F4117248]();
}

uint64_t DDResultGetSubResults()
{
  return MEMORY[0x1F4117268]();
}

uint64_t DDResultGetType()
{
  return MEMORY[0x1F4117278]();
}

uint64_t DDResultGetValue()
{
  return MEMORY[0x1F4117280]();
}

uint64_t DDResultHasType()
{
  return MEMORY[0x1F4117290]();
}

uint64_t DDScannerCopyResultsWithOptions()
{
  return MEMORY[0x1F4117318]();
}

uint64_t DDScannerCreateWithCacheFile()
{
  return MEMORY[0x1F4117328]();
}

uint64_t DDScannerCreateWithLocale()
{
  return MEMORY[0x1F4117330]();
}

uint64_t DDScannerCreateWithType()
{
  return MEMORY[0x1F4117338]();
}

uint64_t DDScannerScanString()
{
  return MEMORY[0x1F4117350]();
}

uint64_t DDScannerSetOptions()
{
  return MEMORY[0x1F4117370]();
}

uint64_t LDEnumerateAssetDataItems()
{
  return MEMORY[0x1F412A878]();
}

uint64_t LMEnumerateAssetDataItems()
{
  return MEMORY[0x1F412A100]();
}

uint64_t LMLanguageModelAddTokenForString()
{
  return MEMORY[0x1F412A130]();
}

uint64_t LMLanguageModelConditionalProbability()
{
  return MEMORY[0x1F412A148]();
}

uint64_t LMLanguageModelCreate()
{
  return MEMORY[0x1F412A158]();
}

uint64_t LMLanguageModelCreatePredictionEnumerator()
{
  return MEMORY[0x1F412A160]();
}

uint64_t LMLanguageModelCreateStringForTokenID()
{
  return MEMORY[0x1F412A170]();
}

uint64_t LMLanguageModelGetTokenIDForString()
{
  return MEMORY[0x1F412A1A0]();
}

uint64_t LMLanguageModelIncrementUsageCount()
{
  return MEMORY[0x1F412A1B8]();
}

uint64_t LMLanguageModelJointProbability()
{
  return MEMORY[0x1F412A1C0]();
}

uint64_t LMLanguageModelRelease()
{
  return MEMORY[0x1F412A1E0]();
}

uint64_t LMPredictionEnumeratorAdvance()
{
  return MEMORY[0x1F412A2B0]();
}

uint64_t LMPredictionEnumeratorGetPrediction()
{
  return MEMORY[0x1F412A2B8]();
}

uint64_t LMPredictionEnumeratorRelease()
{
  return MEMORY[0x1F412A2C0]();
}

uint64_t LXCursorCreateByAdvancing()
{
  return MEMORY[0x1F412A618]();
}

uint64_t LXCursorEnumerateEntries()
{
  return MEMORY[0x1F412A630]();
}

uint64_t LXCursorHasEntries()
{
  return MEMORY[0x1F412A650]();
}

uint64_t LXEntryCopyString()
{
  return MEMORY[0x1F412A6A8]();
}

uint64_t LXEntryGetProbability()
{
  return MEMORY[0x1F412A6F0]();
}

uint64_t LXEntryGetTokenID()
{
  return MEMORY[0x1F412A700]();
}

uint64_t LXLexiconCopyEntryForTokenID()
{
  return MEMORY[0x1F412A750]();
}

uint64_t LXLexiconCreate()
{
  return MEMORY[0x1F412A768]();
}

uint64_t LXLexiconCreateRootCursor()
{
  return MEMORY[0x1F412A778]();
}

uint64_t LXLexiconEnumerateEntriesForString()
{
  return MEMORY[0x1F412A788]();
}

uint64_t LXLexiconGetFirstTokenIDForString()
{
  return MEMORY[0x1F412A798]();
}

uint64_t MRLModelCreate()
{
  return MEMORY[0x1F4130368]();
}

uint64_t MRLModelGetIOMappings()
{
  return MEMORY[0x1F4130378]();
}

uint64_t MRLModelGetOutputSize()
{
  return MEMORY[0x1F4130380]();
}

uint64_t MRLModelRecognize()
{
  return MEMORY[0x1F4130390]();
}

uint64_t MRLModelRelease()
{
  return MEMORY[0x1F4130398]();
}

uint64_t MRLModelReset()
{
  return MEMORY[0x1F41303A0]();
}

uint64_t MRLModelStateCreate()
{
  return MEMORY[0x1F41303B0]();
}

uint64_t MRLModelStateRelease()
{
  return MEMORY[0x1F41303B8]();
}

uint64_t NLTaggerCopyTagForCurrentToken()
{
  return MEMORY[0x1F4114100]();
}

uint64_t NLTaggerCreate()
{
  return MEMORY[0x1F4114108]();
}

uint64_t NLTaggerEnumerateTokens()
{
  return MEMORY[0x1F4114110]();
}

uint64_t NLTaggerSetLocaleForRange()
{
  return MEMORY[0x1F4114128]();
}

uint64_t NLTaggerSetString()
{
  return MEMORY[0x1F4114130]();
}

uint64_t PBDataWriterWriteStringField()
{
  return MEMORY[0x1F4147220]();
}

uint64_t PBReaderReadString()
{
  return MEMORY[0x1F4147280]();
}

uint64_t PBReaderSkipValueWithTag()
{
  return MEMORY[0x1F41472A8]();
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return (void *)MEMORY[0x1F40C9A70](aBlock);
}

void _Block_object_assign(void *a1, const void *a2, const int a3)
{
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

void _Block_release(const void *aBlock)
{
}

uint64_t _CFRuntimeCreateInstance()
{
  return MEMORY[0x1F40D90D0]();
}

uint64_t _CFRuntimeRegisterClass()
{
  return MEMORY[0x1F40D90E8]();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

std::string::const_reference std::string::at(const std::string *this, std::string::size_type __n)
{
  return (std::string::const_reference)MEMORY[0x1F417E368](this, __n);
}

int std::string::compare(const std::string *this, const std::string::value_type *__s)
{
  return MEMORY[0x1F417E390](this, __s);
}

uint64_t std::stringbuf::str()
{
  return MEMORY[0x1F417E3A8]();
}

std::string *__cdecl std::locale::name(std::string *__return_ptr retstr, const std::locale *this)
{
  return (std::string *)MEMORY[0x1F417E400](retstr, this);
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x1F417E408](this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return (std::locale)MEMORY[0x1F417E418](this);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x1F417E448](this, a2);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const char *a2)
{
  return (std::runtime_error *)MEMORY[0x1F417E4B8](this, a2);
}

{
  return (std::runtime_error *)MEMORY[0x1F417E4D0](this, a2);
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x1F417E530](this);
}

std::regex_error *__cdecl std::regex_error::regex_error(std::regex_error *this, std::regex_constants::error_type __ecode)
{
  return (std::regex_error *)MEMORY[0x1F417E550](this, *(void *)&__ecode);
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x1F417E588](__n);
}

std::string *__cdecl std::string::erase(std::string *this, std::string::size_type __pos, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x1F417E5A0](this, __pos, __n);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s)
{
  return (std::string *)MEMORY[0x1F417E5B8](this, __s);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x1F417E5C0](this, __s, __n);
}

std::string *__cdecl std::string::assign(std::string *this, const std::string::value_type *__s)
{
  return (std::string *)MEMORY[0x1F417E5D8](this, __s);
}

std::string *__cdecl std::string::insert(std::string *this, std::string::size_type __pos, const std::string::value_type *__s)
{
  return (std::string *)MEMORY[0x1F417E600](this, __pos, __s);
}

std::string *__cdecl std::string::insert(std::string *this, std::string::size_type __pos, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x1F417E608](this, __pos, __s, __n);
}

void std::string::resize(std::string *this, std::string::size_type __n, std::string::value_type __c)
{
}

std::string *__cdecl std::string::replace(std::string *this, std::string::size_type __pos, std::string::size_type __n1, const std::string::value_type *__s)
{
  return (std::string *)MEMORY[0x1F417E620](this, __pos, __n1, __s);
}

std::string *__cdecl std::string::replace(std::string *this, std::string::size_type __pos, std::string::size_type __n1, const std::string::value_type *__s, std::string::size_type __n2)
{
  return (std::string *)MEMORY[0x1F417E628](this, __pos, __n1, __s, __n2);
}

void std::string::__grow_by(std::string *this, std::string::size_type __old_cap, std::string::size_type __delta_cap, std::string::size_type __old_sz, std::string::size_type __n_copy, std::string::size_type __n_del, std::string::size_type __n_add)
{
}

void std::string::push_back(std::string *this, std::string::value_type __c)
{
}

std::string *__cdecl std::string::basic_string(std::string *this, const std::string *__str, std::string::size_type __pos, std::string::size_type __n, std::allocator<char> *__a)
{
  return (std::string *)MEMORY[0x1F417E660](this, __str, __pos, __n, __a);
}

std::string *__cdecl std::string::operator=(std::string *this, const std::string *__str)
{
  return (std::string *)MEMORY[0x1F417E670](this, __str);
}

std::string *__cdecl std::string::operator=(std::string *this, std::string::value_type __c)
{
  return (std::string *)MEMORY[0x1F417E678](this, __c);
}

uint64_t std::filebuf::open()
{
  return MEMORY[0x1F417E728]();
}

uint64_t std::filebuf::close()
{
  return MEMORY[0x1F417E730]();
}

uint64_t std::filebuf::basic_filebuf()
{
  return MEMORY[0x1F417E740]();
}

uint64_t std::filebuf::~filebuf()
{
  return MEMORY[0x1F417E748]();
}

uint64_t std::istream::sentry::sentry()
{
  return MEMORY[0x1F417E7A0]();
}

uint64_t std::istream::~istream()
{
  return MEMORY[0x1F417E7C0]();
}

uint64_t std::istream::operator>>()
{
  return MEMORY[0x1F417E7D8]();
}

uint64_t std::ostream::put()
{
  return MEMORY[0x1F417E830]();
}

uint64_t std::ostream::flush()
{
  return MEMORY[0x1F417E838]();
}

uint64_t std::ostream::sentry::sentry()
{
  return MEMORY[0x1F417E848]();
}

uint64_t std::ostream::sentry::~sentry()
{
  return MEMORY[0x1F417E850]();
}

uint64_t std::ostream::~ostream()
{
  return MEMORY[0x1F417E860]();
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x1F417E880]();
}

{
  return MEMORY[0x1F417E8C0]();
}

uint64_t std::iostream::~basic_iostream()
{
  return MEMORY[0x1F417E940]();
}

std::regex_traits<char>::char_class_type std::__get_classname(const char *__s, BOOL __icase)
{
  return MEMORY[0x1F417E960](__s, __icase);
}

uint64_t std::streambuf::basic_streambuf()
{
  return MEMORY[0x1F417E978]();
}

uint64_t std::streambuf::~streambuf()
{
  return MEMORY[0x1F417E980]();
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
}

std::__shared_weak_count *__cdecl std::__shared_weak_count::lock(std::__shared_weak_count *this)
{
  return (std::__shared_weak_count *)MEMORY[0x1F417EA90](this);
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
}

std::string *__cdecl std::__get_collation_name(std::string *__return_ptr retstr, const char *__s)
{
  return (std::string *)MEMORY[0x1F417EAA8](retstr, __s);
}

int std::stoi(const std::string *__str, size_t *__idx, int __base)
{
  return MEMORY[0x1F417EBE0](__str, __idx, *(void *)&__base);
}

std::locale *__cdecl std::locale::locale(std::locale *this, const std::locale *a2)
{
  return (std::locale *)MEMORY[0x1F417ECE0](this, a2);
}

std::locale *__cdecl std::locale::locale(std::locale *this)
{
  return (std::locale *)MEMORY[0x1F417ECE8](this);
}

void std::locale::~locale(std::locale *this)
{
}

const std::locale *__cdecl std::locale::operator=(std::locale *this, const std::locale *a2)
{
  return (const std::locale *)MEMORY[0x1F417ECF8](this, a2);
}

void std::codecvt<char32_t,char,__mbstate_t>::~codecvt(std::codecvt<char32_t, char, mbstate_t> *this)
{
}

void std::ios_base::__set_badbit_and_consider_rethrow(std::ios_base *this)
{
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
}

uint64_t std::ios::~ios()
{
  return MEMORY[0x1F417EE40]();
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, double __val)
{
  return (std::string *)MEMORY[0x1F417EE58](retstr, __val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, int __val)
{
  return (std::string *)MEMORY[0x1F417EE70](retstr, *(void *)&__val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, uint64_t __val)
{
  return (std::string *)MEMORY[0x1F417EE80](retstr, __val);
}

uint64_t std::operator+<char>()
{
  return MEMORY[0x1F417EEA0]();
}

void std::exception::~exception(std::exception *this)
{
}

void std::terminate(void)
{
}

void operator delete[]()
{
  while (1)
    ;
}

void operator delete(void *__p)
{
  while (1)
    ;
}

void operator delete()
{
  while (1)
    ;
}

void operator new[]()
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz)
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz, const std::nothrow_t *a2)
{
  while (1)
    ;
}

void operator new()
{
  while (1)
    ;
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x1F417EF30](thrown_size);
}

int __cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle)
{
  return MEMORY[0x1F40C9B60](lpfunc, obj, lpdso_handle);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x1F417EF48](a1);
}

void __cxa_end_catch(void)
{
}

void __cxa_free_exception(void *a1)
{
}

void __cxa_guard_abort(__guard *a1)
{
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x1F417EF80](a1);
}

void __cxa_guard_release(__guard *a1)
{
}

void __cxa_rethrow(void)
{
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
}

int __maskrune(__darwin_ct_rune_t a1, unint64_t a2)
{
  return MEMORY[0x1F40C9C18](*(void *)&a1, a2);
}

__darwin_ct_rune_t __tolower(__darwin_ct_rune_t a1)
{
  return MEMORY[0x1F40C9CF8](*(void *)&a1);
}

__darwin_ct_rune_t __toupper(__darwin_ct_rune_t a1)
{
  return MEMORY[0x1F40C9D00](*(void *)&a1);
}

uint64_t _os_feature_enabled_impl()
{
  return MEMORY[0x1F40C9FB0]();
}

void _os_log_debug_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_signpost_emit_with_name_impl(void *dso, os_log_t log, os_signpost_type_t type, os_signpost_id_t spid, const char *name, const char *format, uint8_t *buf, uint32_t size)
{
}

uint64_t _sl_dlopen()
{
  return MEMORY[0x1F415B160]();
}

uint64_t abort_report_np()
{
  return MEMORY[0x1F40CA1E8]();
}

int atoi(const char *a1)
{
  return MEMORY[0x1F40CA4A8](a1);
}

void bzero(void *a1, size_t a2)
{
}

int close(int a1)
{
  return MEMORY[0x1F40CB3F8](*(void *)&a1);
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_group_t dispatch_group_create(void)
{
  return (dispatch_group_t)MEMORY[0x1F40CBA88]();
}

void dispatch_group_enter(dispatch_group_t group)
{
}

void dispatch_group_leave(dispatch_group_t group)
{
}

intptr_t dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)
{
  return MEMORY[0x1F40CBAC0](group, timeout);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return (dispatch_queue_attr_t)MEMORY[0x1F40CBBB8](attr, *(void *)&qos_class, *(void *)&relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x1F40CBBC0](label, attr);
}

void dispatch_release(dispatch_object_t object)
{
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return (dispatch_semaphore_t)MEMORY[0x1F40CBC30](value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return MEMORY[0x1F40CBC40](dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return MEMORY[0x1F40CBC50](dsema, timeout);
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x1F40CBD30](when, delta);
}

char *dlerror(void)
{
  return (char *)MEMORY[0x1F40CBDB0]();
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return (void *)MEMORY[0x1F40CBDC8](__handle, __symbol);
}

long double exp2(long double __x)
{
  MEMORY[0x1F40CBFE8](__x);
  return result;
}

int fcntl(int a1, int a2, ...)
{
  return MEMORY[0x1F40CC058](*(void *)&a1, *(void *)&a2);
}

long double fmod(long double __x, long double __y)
{
  MEMORY[0x1F40CC1A0](__x, __y);
  return result;
}

void free(void *a1)
{
}

int fstat(int a1, stat *a2)
{
  return MEMORY[0x1F40CC2B8](*(void *)&a1, a2);
}

uid_t getuid(void)
{
  return MEMORY[0x1F40CC570]();
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCB90](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCB98](size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCBA8](ptr, size, type_id);
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x1F40CCCD8](__s, *(void *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x1F40CCCE8](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1F40CCCF0](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x1F40CCD10](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x1F40CCD20](__b, *(void *)&__c, __len);
}

void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
{
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  return (void *)MEMORY[0x1F40CCE40](a1, a2, *(void *)&a3, *(void *)&a4, *(void *)&a5, a6);
}

int munmap(void *a1, size_t a2)
{
  return MEMORY[0x1F40CCE88](a1, a2);
}

uint32_t notify_cancel(int token)
{
  return MEMORY[0x1F40CD028](*(void *)&token);
}

uint32_t notify_register_dispatch(const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
{
  return MEMORY[0x1F40CD060](name, out_token, queue, handler);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x1F4181638](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x1F4181648]();
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x1F4181660](a1);
}

{
  MEMORY[0x1F4181668](context);
}

{
  return (void *)MEMORY[0x1F4181670]();
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x1F4181688]();
}

void objc_enumerationMutation(id obj)
{
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x1F41817A8](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x1F41817B0]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x1F41817B8]();
}

void objc_release(id a1)
{
}

void objc_setProperty_nonatomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x1F40CD0E0](a1, *(void *)&a2);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x1F40CD360](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x1F40CD3B8](oslog, type);
}

BOOL os_signpost_enabled(os_log_t log)
{
  return MEMORY[0x1F40CD550](log);
}

os_signpost_id_t os_signpost_id_make_with_pointer(os_log_t log, const void *ptr)
{
  return MEMORY[0x1F40CD560](log, ptr);
}

void *__cdecl pthread_getspecific(pthread_key_t a1)
{
  return (void *)MEMORY[0x1F40CDA20](a1);
}

int pthread_key_create(pthread_key_t *a1, void (__cdecl *a2)(void *))
{
  return MEMORY[0x1F40CDA40](a1, a2);
}

int pthread_setspecific(pthread_key_t a1, const void *a2)
{
  return MEMORY[0x1F40CDB70](a1, a2);
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
}

ssize_t read(int a1, void *a2, size_t a3)
{
  return MEMORY[0x1F40CDC50](*(void *)&a1, a2, a3);
}

int stat(const char *a1, stat *a2)
{
  return MEMORY[0x1F40CE110](a1, a2);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x1F40CE158](__s1, __s2);
}

char *__cdecl strcpy(char *__dst, const char *__src)
{
  return (char *)MEMORY[0x1F40CE168](__dst, __src);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1F40CE1C8](__s);
}

UBool u_isWhitespace(UChar32 c)
{
  return MEMORY[0x1F417F7A8](*(void *)&c);
}

UChar *__cdecl u_strFromUTF8(UChar *dest, int32_t destCapacity, int32_t *pDestLength, const char *src, int32_t srcLength, UErrorCode *pErrorCode)
{
  return (UChar *)MEMORY[0x1F417F838](dest, *(void *)&destCapacity, pDestLength, src, *(void *)&srcLength, pErrorCode);
}

uint64_t unum_close()
{
  return MEMORY[0x1F4180290]();
}

uint64_t unum_open()
{
  return MEMORY[0x1F41802F0]();
}

uint64_t unum_parseDouble()
{
  return MEMORY[0x1F4180308]();
}

uint64_t uset_close()
{
  return MEMORY[0x1F41806D0]();
}

uint64_t uset_containsAllCodePoints()
{
  return MEMORY[0x1F41806E8]();
}

uint64_t uset_openPattern()
{
  return MEMORY[0x1F4180720]();
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  return MEMORY[0x1F40CE790](__str, __size, __format, a4);
}

__int32 *__cdecl wmemchr(__int32 *__s, __int32 __c, size_t __n)
{
  return (__int32 *)MEMORY[0x1F40CE8B0](__s, *(void *)&__c, __n);
}

ssize_t write(int __fd, const void *__buf, size_t __nbyte)
{
  return MEMORY[0x1F40CE928](*(void *)&__fd, __buf, __nbyte);
}