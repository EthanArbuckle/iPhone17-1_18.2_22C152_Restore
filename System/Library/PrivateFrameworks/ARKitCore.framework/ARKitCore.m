void __ARDeviceSupported_block_invoke()
{
  id v0;
  uint64_t vars8;

  v0 = (id)MGCopyAnswer();
  ARDeviceSupported_supported = [v0 BOOLValue];
}

void __ARDeviceHasGPSCapability_block_invoke()
{
  id v0 = (id)MGCopyAnswer();
  s_deviceHasGPSCapability = [v0 BOOLValue];
}

dispatch_queue_t ARCreateFixedPriorityDispatchQueueWithQOS(const char *a1)
{
  inactive = dispatch_workloop_create_inactive(a1);
  dispatch_workloop_set_qos_class_floor();
  dispatch_activate(inactive);
  v3 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  dispatch_queue_t v4 = dispatch_queue_create_with_target_V2(a1, v3, inactive);

  return v4;
}

void sub_1B88A4B20(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  v6 = va_arg(va1, void (*)(uint64_t *));
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  v6((uint64_t *)va);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t ARCreateCV3DLoggingHandle(uint64_t a1, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t Handle = CV3DLoggingCreateHandle();
  if (a1 < 0)
  {
    uint64_t v7 = _ARLogGeneral_13();
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_INFO)) {
      goto LABEL_11;
    }
    LOWORD(v20) = 0;
    uint64_t v8 = "AppleCV3D API logging disabled";
    v9 = v7;
    os_log_type_t v10 = OS_LOG_TYPE_INFO;
    uint32_t v11 = 2;
  }
  else
  {
    int v5 = CV3DLoggingEnable();
    v6 = _ARLogGeneral_13();
    uint64_t v7 = v6;
    if (v5)
    {
      if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
        goto LABEL_11;
      }
      int v20 = 67109120;
      int v21 = v5;
      uint64_t v8 = "Error enabling AppleCV3D API logging: %i";
      v9 = v7;
      os_log_type_t v10 = OS_LOG_TYPE_ERROR;
    }
    else
    {
      if (!os_log_type_enabled(v6, OS_LOG_TYPE_INFO)) {
        goto LABEL_11;
      }
      int v20 = 67109120;
      int v21 = a1;
      uint64_t v8 = "AppleCV3D API logging level enabled: %i";
      v9 = v7;
      os_log_type_t v10 = OS_LOG_TYPE_INFO;
    }
    uint32_t v11 = 8;
  }
  _os_log_impl(&dword_1B88A2000, v9, v10, v8, (uint8_t *)&v20, v11);
LABEL_11:

  if (a2 < 0)
  {
    v14 = _ARLogGeneral_13();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
    {
      LOWORD(v20) = 0;
      v15 = "AppleCV3D internal logging disabled";
      v16 = v14;
      os_log_type_t v17 = OS_LOG_TYPE_INFO;
      uint32_t v18 = 2;
LABEL_20:
      _os_log_impl(&dword_1B88A2000, v16, v17, v15, (uint8_t *)&v20, v18);
    }
  }
  else
  {
    int v12 = CV3DLoggingEnableInternal();
    v13 = _ARLogGeneral_13();
    v14 = v13;
    if (v12)
    {
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        int v20 = 67109120;
        int v21 = v12;
        v15 = "Error enabling AppleCV3D internal logging: %i";
        v16 = v14;
        os_log_type_t v17 = OS_LOG_TYPE_ERROR;
LABEL_19:
        uint32_t v18 = 8;
        goto LABEL_20;
      }
    }
    else if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      int v20 = 67109120;
      int v21 = a2;
      v15 = "AppleCV3D internal logging level enabled: %i";
      v16 = v14;
      os_log_type_t v17 = OS_LOG_TYPE_INFO;
      goto LABEL_19;
    }
  }

  return Handle;
}

id _ARLogGeneral()
{
  if (_ARLogGeneral_onceToken != -1) {
    dispatch_once(&_ARLogGeneral_onceToken, &__block_literal_global_1);
  }
  id v0 = (void *)_ARLogGeneral_logObj;
  return v0;
}

id _ARLogGeneral_0()
{
  if (_ARLogGeneral_onceToken_0 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_0, &__block_literal_global_4);
  }
  id v0 = (void *)_ARLogGeneral_logObj_0;
  return v0;
}

id _ARLogGeneral_1()
{
  if (_ARLogGeneral_onceToken_2 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_2, &__block_literal_global_7);
  }
  id v0 = (void *)_ARLogGeneral_logObj_2;
  return v0;
}

id _ARLogGeneral_2()
{
  if (_ARLogGeneral_onceToken_3 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_3, &__block_literal_global_104);
  }
  id v0 = (void *)_ARLogGeneral_logObj_3;
  return v0;
}

id _ARLogGeneral_3()
{
  if (_ARLogGeneral_onceToken_4 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_4, &__block_literal_global_10);
  }
  id v0 = (void *)_ARLogGeneral_logObj_4;
  return v0;
}

id _ARLogGeneral_4()
{
  if (_ARLogGeneral_onceToken_5 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_5, &__block_literal_global_308);
  }
  id v0 = (void *)_ARLogGeneral_logObj_5;
  return v0;
}

id _ARLogGeneral_5()
{
  if (_ARLogGeneral_onceToken_6 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_6, &__block_literal_global_217);
  }
  id v0 = (void *)_ARLogGeneral_logObj_6;
  return v0;
}

id _ARLogGeneral_6()
{
  if (_ARLogGeneral_onceToken_7 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_7, &__block_literal_global_26);
  }
  id v0 = (void *)_ARLogGeneral_logObj_7;
  return v0;
}

id _ARLogGeneral_7()
{
  if (_ARLogGeneral_onceToken_9 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_9, &__block_literal_global_28);
  }
  id v0 = (void *)_ARLogGeneral_logObj_9;
  return v0;
}

id _ARLogGeneral_8()
{
  if (_ARLogGeneral_onceToken_10 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_10, &__block_literal_global_34);
  }
  id v0 = (void *)_ARLogGeneral_logObj_10;
  return v0;
}

id _ARLogGeneral_9()
{
  if (_ARLogGeneral_onceToken_11 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_11, &__block_literal_global_479);
  }
  id v0 = (void *)_ARLogGeneral_logObj_11;
  return v0;
}

id _ARLogGeneral_10()
{
  if (_ARLogGeneral_onceToken_12 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_12, &__block_literal_global_220);
  }
  id v0 = (void *)_ARLogGeneral_logObj_12;
  return v0;
}

id _ARLogGeneral_11()
{
  if (_ARLogGeneral_onceToken_13 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_13, &__block_literal_global_281);
  }
  id v0 = (void *)_ARLogGeneral_logObj_13;
  return v0;
}

id _ARLogGeneral_12()
{
  if (_ARLogGeneral_onceToken_14 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_14, &__block_literal_global_37);
  }
  id v0 = (void *)_ARLogGeneral_logObj_14;
  return v0;
}

id _ARLogGeneral_13()
{
  if (_ARLogGeneral_onceToken_15 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_15, &__block_literal_global_366);
  }
  id v0 = (void *)_ARLogGeneral_logObj_15;
  return v0;
}

id _ARLogGeneral_14()
{
  if (_ARLogGeneral_onceToken_16 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_16, &__block_literal_global_371);
  }
  id v0 = (void *)_ARLogGeneral_logObj_16;
  return v0;
}

id _ARLogGeneral_15()
{
  if (_ARLogGeneral_onceToken_17 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_17, &__block_literal_global_41);
  }
  id v0 = (void *)_ARLogGeneral_logObj_17;
  return v0;
}

id _ARLogGeneral_16()
{
  if (_ARLogGeneral_onceToken_18 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_18, &__block_literal_global_92);
  }
  id v0 = (void *)_ARLogGeneral_logObj_18;
  return v0;
}

id _ARLogGeneral_17()
{
  if (_ARLogGeneral_onceToken_20 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_20, &__block_literal_global_47);
  }
  id v0 = (void *)_ARLogGeneral_logObj_20;
  return v0;
}

id _ARLogGeneral_18()
{
  if (_ARLogGeneral_onceToken_21 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_21, &__block_literal_global_48);
  }
  id v0 = (void *)_ARLogGeneral_logObj_21;
  return v0;
}

id _ARLogGeneral_19()
{
  if (_ARLogGeneral_onceToken_22 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_22, &__block_literal_global_123);
  }
  id v0 = (void *)_ARLogGeneral_logObj_22;
  return v0;
}

id _ARLogGeneral_20()
{
  if (_ARLogGeneral_onceToken_24 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_24, &__block_literal_global_58);
  }
  id v0 = (void *)_ARLogGeneral_logObj_24;
  return v0;
}

id _ARLogGeneral_21()
{
  if (_ARLogGeneral_onceToken_25 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_25, &__block_literal_global_59);
  }
  id v0 = (void *)_ARLogGeneral_logObj_25;
  return v0;
}

id _ARLogGeneral_22()
{
  if (_ARLogGeneral_onceToken_26 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_26, &__block_literal_global_164);
  }
  id v0 = (void *)_ARLogGeneral_logObj_26;
  return v0;
}

id _ARLogGeneral_23()
{
  if (_ARLogGeneral_onceToken_28 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_28, &__block_literal_global_64);
  }
  id v0 = (void *)_ARLogGeneral_logObj_28;
  return v0;
}

id _ARLogGeneral_24()
{
  if (_ARLogGeneral_onceToken_29 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_29, &__block_literal_global_288_0);
  }
  id v0 = (void *)_ARLogGeneral_logObj_29;
  return v0;
}

id _ARLogGeneral_25()
{
  if (_ARLogGeneral_onceToken_30 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_30, &__block_literal_global_68);
  }
  id v0 = (void *)_ARLogGeneral_logObj_30;
  return v0;
}

id _ARLogGeneral_26()
{
  if (_ARLogGeneral_onceToken_31 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_31, &__block_literal_global_873);
  }
  id v0 = (void *)_ARLogGeneral_logObj_31;
  return v0;
}

id _ARLogGeneral_27()
{
  if (_ARLogGeneral_onceToken_32 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_32, &__block_literal_global_214_0);
  }
  id v0 = (void *)_ARLogGeneral_logObj_32;
  return v0;
}

id _ARLogGeneral_28()
{
  if (_ARLogGeneral_onceToken_33 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_33, &__block_literal_global_282);
  }
  id v0 = (void *)_ARLogGeneral_logObj_33;
  return v0;
}

id _ARLogGeneral_29()
{
  if (_ARLogGeneral_onceToken_34 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_34, &__block_literal_global_74);
  }
  id v0 = (void *)_ARLogGeneral_logObj_34;
  return v0;
}

id _ARLogGeneral_30()
{
  if (_ARLogGeneral_onceToken_35 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_35, &__block_literal_global_209);
  }
  id v0 = (void *)_ARLogGeneral_logObj_35;
  return v0;
}

id _ARLogGeneral_31()
{
  if (_ARLogGeneral_onceToken_36 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_36, &__block_literal_global_82);
  }
  id v0 = (void *)_ARLogGeneral_logObj_36;
  return v0;
}

id _ARLogGeneral_32()
{
  if (_ARLogGeneral_onceToken_38 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_38, &__block_literal_global_247_0);
  }
  id v0 = (void *)_ARLogGeneral_logObj_38;
  return v0;
}

id _ARLogGeneral_33()
{
  if (_ARLogGeneral_onceToken_39 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_39, &__block_literal_global_88);
  }
  id v0 = (void *)_ARLogGeneral_logObj_39;
  return v0;
}

id _ARLogGeneral_34()
{
  if (_ARLogGeneral_onceToken_41 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_41, &__block_literal_global_53_0);
  }
  id v0 = (void *)_ARLogGeneral_logObj_41;
  return v0;
}

id _ARLogGeneral_35()
{
  if (_ARLogGeneral_onceToken_42 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_42, &__block_literal_global_9_0);
  }
  id v0 = (void *)_ARLogGeneral_logObj_42;
  return v0;
}

id _ARLogGeneral_36()
{
  if (_ARLogGeneral_onceToken_43 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_43, &__block_literal_global_455);
  }
  id v0 = (void *)_ARLogGeneral_logObj_43;
  return v0;
}

id _ARLogGeneral_37()
{
  if (_ARLogGeneral_onceToken_44[0] != -1) {
    dispatch_once(_ARLogGeneral_onceToken_44, &__block_literal_global_106);
  }
  id v0 = (void *)_ARLogGeneral_logObj_44;
  return v0;
}

id _ARLogGeneral_38()
{
  if (_ARLogGeneral_onceToken_45 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_45, &__block_literal_global_191);
  }
  id v0 = (void *)_ARLogGeneral_logObj_45;
  return v0;
}

id _ARLogGeneral_39()
{
  if (_ARLogGeneral_onceToken_46 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_46, &__block_literal_global_228_0);
  }
  id v0 = (void *)_ARLogGeneral_logObj_46;
  return v0;
}

id _ARLogGeneral_40()
{
  if (_ARLogGeneral_onceToken_47 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_47, &__block_literal_global_19);
  }
  id v0 = (void *)_ARLogGeneral_logObj_47;
  return v0;
}

id _ARLogGeneral_41()
{
  if (_ARLogGeneral_onceToken_48 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_48, &__block_literal_global_113);
  }
  id v0 = (void *)_ARLogGeneral_logObj_48;
  return v0;
}

id _ARLogGeneral_42()
{
  if (_ARLogGeneral_onceToken_49 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_49, &__block_literal_global_58);
  }
  id v0 = (void *)_ARLogGeneral_logObj_49;
  return v0;
}

void sub_1B88A63B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
  objc_destroyWeak(v21);
  objc_destroyWeak(v20);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t ARDeviceSupported()
{
  if (ARDeviceSupported_onceToken != -1) {
    dispatch_once(&ARDeviceSupported_onceToken, &__block_literal_global_27);
  }
  return ARDeviceSupported_supported;
}

uint64_t ARDeviceHasGPSCapability()
{
  if (ARDeviceHasGPSCapability_onceToken != -1) {
    dispatch_once(&ARDeviceHasGPSCapability_onceToken, &__block_literal_global_237);
  }
  return s_deviceHasGPSCapability;
}

id _ARLogSession()
{
  if (_ARLogSession_onceToken != -1) {
    dispatch_once(&_ARLogSession_onceToken, &__block_literal_global_630);
  }
  id v0 = (void *)_ARLogSession_logObj;
  return v0;
}

id _ARLogSession_0()
{
  if (_ARLogSession_onceToken_1 != -1) {
    dispatch_once(&_ARLogSession_onceToken_1, &__block_literal_global_869);
  }
  id v0 = (void *)_ARLogSession_logObj_1;
  return v0;
}

uint64_t ARAppleNeuralEngine()
{
  if (ARAppleNeuralEngine_onceToken[0] != -1) {
    dispatch_once(ARAppleNeuralEngine_onceToken, &__block_literal_global_88_0);
  }
  return s_deviceSupportsANE;
}

uint64_t __ARAppleNeuralEngine_block_invoke()
{
  uint64_t result = MGGetBoolAnswer();
  s_deviceSupportsANE = result;
  return result;
}

uint64_t ARPowerUsageForThermalState(uint64_t a1)
{
  if (a1 == 3) {
    return 2;
  }
  else {
    return a1 == 2;
  }
}

uint64_t ARPowerUsageForPowerPressureLevel(int a1)
{
  uint64_t v1 = a1 == 20;
  if (a1 == 30) {
    uint64_t v1 = 2;
  }
  if (a1 == 40) {
    return 2;
  }
  else {
    return v1;
  }
}

id ARKitCoreBuildVersionString()
{
  id v0 = [MEMORY[0x1E4F28B50] bundleForClass:objc_opt_class()];
  uint64_t v1 = [v0 infoDictionary];
  v2 = [v1 objectForKeyedSubscript:@"CFBundleVersion"];

  return v2;
}

dispatch_queue_t ARCreateFixedPriorityDispatchQueue(const char *a1)
{
  return ARCreateFixedPriorityDispatchQueueWithQOS(a1);
}

void sub_1B88A8F18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

void sub_1B88A9590(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, os_activity_scope_state_s state)
{
}

ARRaycastResult *raycastResultFromNewAPI(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  *(double *)v4.i64 = ARVisionToRenderingCoordinateTransform();
  float32x4_t v33 = v4;
  float32x4_t v35 = v5;
  float32x4_t v29 = v7;
  float32x4_t v31 = v6;
  CV3DRaycastResultTransformationToWorld();
  unint64_t v8 = 0;
  float32x4_t v45 = v9;
  float32x4_t v46 = v10;
  float32x4_t v47 = v11;
  float32x4_t v48 = v12;
  do
  {
    *(float32x4_t *)((char *)&v49 + v8) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v33, COERCE_FLOAT(*(_OWORD *)((char *)&v45 + v8))), v35, *(float32x2_t *)&v45.f32[v8 / 4], 1), v31, *(float32x4_t *)((char *)&v45 + v8), 2), v29, *(float32x4_t *)((char *)&v45 + v8), 3);
    v8 += 16;
  }
  while (v8 != 64);
  float32x4_t v34 = v49;
  float32x4_t v36 = v50;
  float32x4_t v30 = v52;
  float32x4_t v32 = v51;
  *(double *)v13.i64 = ARRenderingToVisionCoordinateTransform();
  unint64_t v14 = 0;
  float32x4_t v45 = v13;
  float32x4_t v46 = v15;
  float32x4_t v47 = v16;
  float32x4_t v48 = v17;
  do
  {
    *(float32x4_t *)((char *)&v49 + v14) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v34, COERCE_FLOAT(*(_OWORD *)((char *)&v45 + v14))), v36, *(float32x2_t *)&v45.f32[v14 / 4], 1), v32, *(float32x4_t *)((char *)&v45 + v14), 2), v30, *(float32x4_t *)((char *)&v45 + v14), 3);
    v14 += 16;
  }
  while (v14 != 64);
  unint64_t v18 = 0;
  float32x4_t v45 = v49;
  float32x4_t v46 = v50;
  float32x4_t v47 = v51;
  float32x4_t v48 = v52;
  do
  {
    *(float32x4_t *)((char *)&v49 + v18) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a1, COERCE_FLOAT(*(_OWORD *)((char *)&v45 + v18))), a2, *(float32x2_t *)&v45.f32[v18 / 4], 1), a3, *(float32x4_t *)((char *)&v45 + v18), 2), a4, *(float32x4_t *)((char *)&v45 + v18), 3);
    v18 += 16;
  }
  while (v18 != 64);
  double v42 = *(double *)v51.i64;
  double v44 = *(double *)v52.i64;
  double v38 = *(double *)v49.i64;
  double v40 = *(double *)v50.i64;
  int v19 = CV3DRaycastResultOriginatedFrom();
  BOOL v20 = CV3DRaycastResultExtentChecked() == *MEMORY[0x1E4F4D388];
  if (v19 == *MEMORY[0x1E4F4D3A0]) {
    uint64_t v21 = v20;
  }
  else {
    uint64_t v21 = 2;
  }
  int ResultOrientation = CV3DRaycastGetResultOrientation();
  uint64_t v23 = 1;
  if (ResultOrientation != *MEMORY[0x1E4F4D398]) {
    uint64_t v23 = 2;
  }
  if (ResultOrientation == *MEMORY[0x1E4F4D390]) {
    uint64_t v24 = 0;
  }
  else {
    uint64_t v24 = v23;
  }
  v25 = -[ARRaycastResult initWithWorldTransform:target:targetAlignment:]([ARRaycastResult alloc], "initWithWorldTransform:target:targetAlignment:", v21, v24, v38, v40, v42, v44);
  v26 = (const void *)CV3DRaycastResultPlaneIdentifier();
  if (v26)
  {
    v27 = objc_msgSend(MEMORY[0x1E4F29128], "ar_UUIDWithCFUUIDRef:", v26);
    [(ARRaycastResult *)v25 setAnchorIdentifier:v27];
    CFRelease(v26);
  }
  return v25;
}

void sub_1B88A9E74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id raycastResultsFromNewAPI(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, uint64_t a5, void *a6)
{
  v17[1] = *MEMORY[0x1E4F143B8];
  id v6 = a6;
  float32x4_t v7 = objc_opt_new();
  for (unint64_t i = 0; i < CV3DRayCastResultsLength(); ++i)
  {
    CV3DRayCastResultAtIndex();
    float32x4_t v9 = raycastResultFromNewAPI(a1, a2, a3, a4);
    [v7 addObject:v9];
  }
  if ([v6 target] == 2)
  {
    float32x4_t v10 = [v7 firstObject];
    [v10 setTarget:2];
    v17[0] = v10;
    id v11 = [MEMORY[0x1E4F1C978] arrayWithObjects:v17 count:1];
  }
  else
  {
    id v11 = v7;
  }

  return v11;
}

void sub_1B88A9FD8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id ARRaycastResultsDictionaryFrom(const CV3DRaycastResultMap *a1, simd_float4x4 a2)
{
  uint64_t v15 = CV3DRayCastResultMapLength();
  if (v15)
  {
    uint64_t v3 = objc_opt_new();
    CFArrayRef theArray = (const __CFArray *)MEMORY[0x1BA9C3C70](a1);
    for (CFIndex i = 0; i != v15; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(theArray, i);
      id v6 = a1;
      CV3DRayCastResultListFromId();
      float32x4_t v7 = objc_msgSend(MEMORY[0x1E4F29128], "ar_UUIDWithCFUUIDRef:", ValueAtIndex);
      uint64_t v8 = CV3DRayCastResultsLength();
      if (v8)
      {
        for (uint64_t j = 0; j != v8; ++j)
        {
          CV3DRayCastResultAtIndex();
          float32x4_t v10 = raycastResultFromNewAPI((float32x4_t)a2.columns[0], (float32x4_t)a2.columns[1], (float32x4_t)a2.columns[2], (float32x4_t)a2.columns[3]);
          id v11 = [v3 objectForKeyedSubscript:v7];

          if (!v11)
          {
            float32x4_t v12 = objc_opt_new();
            [v3 setObject:v12 forKeyedSubscript:v7];
          }
          float32x4_t v13 = objc_msgSend(v3, "objectForKeyedSubscript:", v7, v15);
          [v13 addObject:v10];
        }
      }

      a1 = v6;
    }
    CFRelease(theArray);
  }
  else
  {
    uint64_t v3 = 0;
  }
  return v3;
}

void sub_1B88AA1BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

ARRaycastResult *ARRaycastResultFrom(CV3DHitTestResult *a1, simd_float4x4 a2)
{
  *(double *)v3.i64 = ARVisionToRenderingCoordinateTransform();
  float32x4_t v29 = v3;
  float32x4_t v31 = v4;
  float32x4_t v25 = v6;
  float32x4_t v27 = v5;
  *(double *)v7.i64 = ARMatrix4x4MakeColumnMajorTransformFromArray((float64x2_t *)a1->var1);
  unint64_t v8 = 0;
  float32x4_t v34 = v7;
  float32x4_t v35 = v9;
  float32x4_t v36 = v10;
  float32x4_t v37 = v11;
  do
  {
    *(float32x4_t *)((char *)&v38 + v8) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v29, COERCE_FLOAT(*(_OWORD *)((char *)&v34 + v8))), v31, *(float32x2_t *)&v34.f32[v8 / 4], 1), v27, *(float32x4_t *)((char *)&v34 + v8), 2), v25, *(float32x4_t *)((char *)&v34 + v8), 3);
    v8 += 16;
  }
  while (v8 != 64);
  float32x4_t v30 = v38;
  float32x4_t v32 = v39;
  float32x4_t v26 = v41;
  float32x4_t v28 = v40;
  *(double *)v12.i64 = ARRenderingToVisionCoordinateTransform();
  unint64_t v13 = 0;
  float32x4_t v34 = v12;
  float32x4_t v35 = v14;
  float32x4_t v36 = v15;
  float32x4_t v37 = v16;
  do
  {
    *(float32x4_t *)((char *)&v38 + v13) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v30, COERCE_FLOAT(*(_OWORD *)((char *)&v34 + v13))), v32, *(float32x2_t *)&v34.f32[v13 / 4], 1), v28, *(float32x4_t *)((char *)&v34 + v13), 2), v26, *(float32x4_t *)((char *)&v34 + v13), 3);
    v13 += 16;
  }
  while (v13 != 64);
  unint64_t v17 = 0;
  float32x4_t v34 = v38;
  float32x4_t v35 = v39;
  float32x4_t v36 = v40;
  float32x4_t v37 = v41;
  do
  {
    *(float32x4_t *)((char *)&v38 + v17) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)a2.columns[0], COERCE_FLOAT(*(_OWORD *)((char *)&v34 + v17))), (float32x4_t)a2.columns[1], *(float32x2_t *)&v34.f32[v17 / 4], 1), (float32x4_t)a2.columns[2], *(float32x4_t *)((char *)&v34 + v17), 2), (float32x4_t)a2.columns[3], *(float32x4_t *)((char *)&v34 + v17), 3);
    v17 += 16;
  }
  while (v17 != 64);
  if (a1->var2 == 1 && (int v18 = a1->var3 - 1, v18 <= 3)) {
    uint64_t v19 = qword_1B8A2AFF0[v18];
  }
  else {
    uint64_t v19 = 2;
  }
  int var4 = a1->var4;
  if (var4 == 4) {
    uint64_t v21 = 2;
  }
  else {
    uint64_t v21 = var4 == 2;
  }
  uint64_t v22 = -[ARRaycastResult initWithWorldTransform:target:targetAlignment:]([ARRaycastResult alloc], "initWithWorldTransform:target:targetAlignment:", v19, v21, *(double *)v38.i64, *(double *)v39.i64, *(double *)v40.i64, *(double *)v41.i64);
  if (a1->var5)
  {
    uint64_t v23 = objc_msgSend(MEMORY[0x1E4F29128], "ar_UUIDWithCFUUIDRef:");
    [(ARRaycastResult *)v22 setAnchorIdentifier:v23];
  }
  return v22;
}

void sub_1B88AA3F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id raycastResultsFrom(CV3DHitTestResults *a1, ARRaycastQuery *a2, simd_float4x4 a3)
{
  v13[1] = *MEMORY[0x1E4F143B8];
  float32x4_t v4 = a2;
  float32x4_t v5 = objc_opt_new();
  if (a1->var1)
  {
    uint64_t v6 = 0;
    unint64_t v7 = 0;
    do
    {
      unint64_t v8 = ARRaycastResultFrom(&a1->var0[v6], a3);
      [v5 addObject:v8];

      ++v7;
      ++v6;
    }
    while (v7 < a1->var1);
  }
  if ([(ARRaycastQuery *)v4 target] == ARRaycastTargetEstimatedPlane)
  {
    float32x4_t v9 = [v5 firstObject];
    [v9 setTarget:2];
    v13[0] = v9;
    id v10 = [MEMORY[0x1E4F1C978] arrayWithObjects:v13 count:1];
  }
  else
  {
    id v10 = v5;
  }

  return v10;
}

void sub_1B88AA554(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t intentFrom(uint64_t a1)
{
  uint64_t v2 = CV3DRaycastIntentCreate();
  if (*(_DWORD *)(a1 + 72)) {
    CV3DRaycastIntentEnableTracking();
  }
  int v3 = *(_DWORD *)(a1 + 76);
  if (v3 == 1 || v3 == 3) {
    CV3DRaycastIntentSetConsideredGeometry();
  }
  CV3DRaycastIntentSetConsideredOrientations();
  CV3DRaycastIntentSetExtentCheckForTrackedPlanes();
  return v2;
}

uint64_t *RaycastSession::RaycastSession(uint64_t *a1, uint64_t a2, void *a3, int a4)
{
  id v7 = a3;
  CV3DRaycastSessionConfigurationCreate();
  if (a4) {
    CV3DRaycastSessionConfigurationEnableDeterministicMode();
  }
  uint64_t v17 = 0;
  *a1 = CV3DRaycastSessionCreateWithConfig();
  CV3DRaycastSessionConfigurationRelease();
  if (v17)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    uint64_t v14 = v17;
    void *exception = &unk_1F12098A0;
    exception[1] = v14;
  }
  v16[0] = MEMORY[0x1E4F143A8];
  v16[1] = 3221225472;
  v16[2] = ___ZN14RaycastSessionC2EP15CV3DSLAMSessionU13block_pointerFvPK20CV3DRaycastResultMapEb_block_invoke;
  v16[3] = &__block_descriptor_40_e28_v80__0____CFUUID__8____4__16l;
  v16[4] = a2;
  unint64_t v8 = (void *)MEMORY[0x1BA9C63E0](v16);
  v15[0] = MEMORY[0x1E4F143A8];
  v15[1] = 3221225472;
  v15[2] = ___ZN14RaycastSessionC2EP15CV3DSLAMSessionU13block_pointerFvPK20CV3DRaycastResultMapEb_block_invoke_5;
  v15[3] = &__block_descriptor_40_e19_v16__0____CFUUID__8l;
  v15[4] = a2;
  float32x4_t v9 = (void *)MEMORY[0x1BA9C63E0](v15);
  CV3DRaycastSessionSetAnchoringFunctors();
  if (v17 || (CV3DRaycastSessionRegisterOnTrackableUpdateCallback(), v17))
  {
    float32x4_t v11 = __cxa_allocate_exception(0x10uLL);
    uint64_t v12 = v17;
    *float32x4_t v11 = &unk_1F12098A0;
    v11[1] = v12;
  }

  return a1;
}

void sub_1B88AA898(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZN14RaycastSessionC2EP15CV3DSLAMSessionU13block_pointerFvPK20CV3DRaycastResultMapEb_block_invoke()
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  if ((CV3DSLAMSessionAddAnchor() & 1) == 0)
  {
    id v0 = _ARLogGeneral();
    if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v2 = 0;
      _os_log_impl(&dword_1B88A2000, v0, OS_LOG_TYPE_ERROR, "Error adding anchor: %@", buf, 0xCu);
    }
  }
}

id _ARLogGeneral(void)
{
  if (_ARLogGeneral(void)::onceToken != -1) {
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global);
  }
  id v0 = (void *)_ARLogGeneral(void)::logObj;
  return v0;
}

{
  void *v0;
  uint64_t vars8;

  if (_ARLogGeneral(void)::onceToken != -1) {
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_0);
  }
  id v0 = (void *)_ARLogGeneral(void)::logObj;
  return v0;
}

{
  void *v0;
  uint64_t vars8;

  if (_ARLogGeneral(void)::onceToken != -1) {
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_84);
  }
  id v0 = (void *)_ARLogGeneral(void)::logObj;
  return v0;
}

{
  void *v0;
  uint64_t vars8;

  if (_ARLogGeneral(void)::onceToken != -1) {
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_38);
  }
  id v0 = (void *)_ARLogGeneral(void)::logObj;
  return v0;
}

{
  void *v0;
  uint64_t vars8;

  if (_ARLogGeneral(void)::onceToken != -1) {
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_67);
  }
  id v0 = (void *)_ARLogGeneral(void)::logObj;
  return v0;
}

{
  void *v0;
  uint64_t vars8;

  if (_ARLogGeneral(void)::onceToken != -1) {
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_129);
  }
  id v0 = (void *)_ARLogGeneral(void)::logObj;
  return v0;
}

{
  void *v0;
  uint64_t vars8;

  if (_ARLogGeneral(void)::onceToken != -1) {
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_572);
  }
  id v0 = (void *)_ARLogGeneral(void)::logObj;
  return v0;
}

{
  void *v0;
  uint64_t vars8;

  if (_ARLogGeneral(void)::onceToken != -1) {
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_49);
  }
  id v0 = (void *)_ARLogGeneral(void)::logObj;
  return v0;
}

{
  void *v0;
  uint64_t vars8;

  if (_ARLogGeneral(void)::onceToken != -1) {
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_643);
  }
  id v0 = (void *)_ARLogGeneral(void)::logObj;
  return v0;
}

{
  void *v0;
  uint64_t vars8;

  if (_ARLogGeneral(void)::onceToken != -1) {
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_60);
  }
  id v0 = (void *)_ARLogGeneral(void)::logObj;
  return v0;
}

{
  void *v0;
  uint64_t vars8;

  if (_ARLogGeneral(void)::onceToken != -1) {
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_56);
  }
  id v0 = (void *)_ARLogGeneral(void)::logObj;
  return v0;
}

{
  void *v0;
  uint64_t vars8;

  if (_ARLogGeneral(void)::onceToken != -1) {
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_49);
  }
  id v0 = (void *)_ARLogGeneral(void)::logObj;
  return v0;
}

{
  void *v0;
  uint64_t vars8;

  if (_ARLogGeneral(void)::onceToken != -1) {
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_244);
  }
  id v0 = (void *)_ARLogGeneral(void)::logObj;
  return v0;
}

{
  void *v0;
  uint64_t vars8;

  if (_ARLogGeneral(void)::onceToken != -1) {
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_87);
  }
  id v0 = (void *)_ARLogGeneral(void)::logObj;
  return v0;
}

{
  void *v0;
  uint64_t vars8;

  if (_ARLogGeneral(void)::onceToken != -1) {
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_126_1);
  }
  id v0 = (void *)_ARLogGeneral(void)::logObj;
  return v0;
}

{
  void *v0;
  uint64_t vars8;

  if (_ARLogGeneral(void)::onceToken != -1) {
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_49_0);
  }
  id v0 = (void *)_ARLogGeneral(void)::logObj;
  return v0;
}

{
  void *v0;
  uint64_t vars8;

  if (_ARLogGeneral(void)::onceToken != -1) {
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_97);
  }
  id v0 = (void *)_ARLogGeneral(void)::logObj;
  return v0;
}

{
  void *v0;
  uint64_t vars8;

  if (_ARLogGeneral(void)::onceToken != -1) {
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_174_0);
  }
  id v0 = (void *)_ARLogGeneral(void)::logObj;
  return v0;
}

{
  void *v0;
  uint64_t vars8;

  if (_ARLogGeneral(void)::onceToken != -1) {
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_59_0);
  }
  id v0 = (void *)_ARLogGeneral(void)::logObj;
  return v0;
}

{
  void *v0;
  uint64_t vars8;

  if (_ARLogGeneral(void)::onceToken != -1) {
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_251_0);
  }
  id v0 = (void *)_ARLogGeneral(void)::logObj;
  return v0;
}

{
  void *v0;
  uint64_t vars8;

  if (_ARLogGeneral(void)::onceToken != -1) {
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_9_1);
  }
  id v0 = (void *)_ARLogGeneral(void)::logObj;
  return v0;
}

void ___ZN14RaycastSessionC2EP15CV3DSLAMSessionU13block_pointerFvPK20CV3DRaycastResultMapEb_block_invoke_5()
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  if ((CV3DSLAMSessionRemoveAnchor() & 1) == 0)
  {
    id v0 = _ARLogGeneral();
    if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v2 = 0;
      _os_log_impl(&dword_1B88A2000, v0, OS_LOG_TYPE_ERROR, "Error removing anchor: %@", buf, 0xCu);
    }
  }
}

uint64_t RaycastSession::PushDenseFrame(RaycastSession *this, __CVBuffer *a2, __CVBuffer *a3, simd_float3x3 a4, simd_float4x4 a5)
{
  return CV3DRaycastDenseFrameRelease();
}

uint64_t RaycastSession::InvalidateDenseFrame(RaycastSession *this)
{
  return MEMORY[0x1F4109C40](*(void *)this, 0);
}

id RaycastSession::PerformHitTest(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, uint64_t a5, uint64_t a6, void *a7)
{
  id v8 = a7;
  intentFrom(a6);
  float32x4_t v9 = (void *)MEMORY[0x1E4F1CBF0];
  uint64_t v10 = CV3DRaycastSessionAttemptWithIntent();
  CV3DRaycastIntentRelease();
  if (v10 && CV3DRayCastResultsLength())
  {
    float32x4_t v9 = raycastResultsFromNewAPI(a1, a2, a3, a4, v10, v8);
  }
  CV3DRaycastResultListRelease();

  return v9;
}

void sub_1B88AAC78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t RaycastSession::StopRaycast(RaycastSession *this, const __CFUUID *a2)
{
  return MEMORY[0x1F4109C70](*(void *)this, a2, 0);
}

uint64_t RaycastSession::PushChunks(RaycastSession *this, const CV3DReconMeshList *a2, simd_float4x4 a3)
{
  return MEMORY[0x1F4109C48](*(void *)this, a2, 0, (__n128)a3.columns[0], (__n128)a3.columns[1], (__n128)a3.columns[2], (__n128)a3.columns[3]);
}

void CFErrorRefException::~CFErrorRefException(std::exception *this)
{
  CFErrorRefException::~CFErrorRefException(this);
  JUMPOUT(0x1BA9C56C0);
}

{
  std::exception_vtbl *v2;
  uint64_t vars8;

  this->__vftable = (std::exception_vtbl *)&unk_1F12098A0;
  uint64_t v2 = this[1].__vftable;
  if (v2) {
    CFRelease(v2);
  }
  std::exception::~exception(this);
}

void __clang_call_terminate(void *a1)
{
}

void ___ZL13_ARLogGeneralv_block_invoke()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "General");
  uint64_t v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObuint64_t j = (uint64_t)v0;
}

uint64_t ARCreatePlaneDetectionExtentTypeForPlaneDetectionType(__int16 a1)
{
  uint64_t v2 = CV3DPlaneDetectionExtentTypesCreate();
  if (!v2)
  {
    uint64_t v3 = _ARLogGeneral();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)float32x4_t v5 = 0;
      _os_log_impl(&dword_1B88A2000, v3, OS_LOG_TYPE_ERROR, "Could not instantiate desired extent for plane detection", v5, 2u);
    }
  }
  if ((a1 & 0x200) != 0)
  {
    CV3DPlaneDetectionExtentTypesSetAll();
  }
  else
  {
    CV3DPlaneDetectionExtentTypesSetAxisAlignedBox();
    CV3DPlaneDetectionExtentTypesSetOrientedBox();
    CV3DPlaneDetectionExtentTypesSetConvexHull();
  }
  return v2;
}

uint64_t ARPlaneDetectionOrientationForPlaneDetectionType(char a1)
{
  uint64_t v1 = (unsigned __int8 *)MEMORY[0x1E4F94870];
  if ((~a1 & 3) != 0)
  {
    if ((a1 & 0x80) == 0) {
      uint64_t v1 = (unsigned __int8 *)MEMORY[0x1E4F94868];
    }
    uint64_t v2 = (unsigned __int8 *)MEMORY[0x1E4F94880];
    if ((a1 & 2) == 0) {
      uint64_t v2 = (unsigned __int8 *)MEMORY[0x1E4F94878];
    }
    if ((a1 & 0x81) == 0) {
      uint64_t v1 = v2;
    }
  }
  return *v1;
}

uint64_t ExtractConfig(const PlaneDetectionConfiguration *a1)
{
  uint64_t v2 = CV3DPlaneDetectionConfigurationCreate();
  minVergenceAngleDegreesUserDefaultValue = a1->minVergenceAngleDegreesUserDefaultValue;
  if (minVergenceAngleDegreesUserDefaultValue) {
    [(NSNumber *)minVergenceAngleDegreesUserDefaultValue doubleValue];
  }
  else {
    [(ARWorldTrackingOptions *)a1->options minVergenceAngle];
  }
  CV3DPlaneDetectionConfigurationSetMinVergenceAngle();
  [(ARWorldTrackingOptions *)a1->options planeDetection];
  CV3DPlaneDetectionConfigurationSetDesiredOrientations();
  ARCreatePlaneDetectionExtentTypeForPlaneDetectionType([(ARWorldTrackingOptions *)a1->options planeDetection]);
  CV3DPlaneDetectionConfigurationSetDesiredExtent();
  CV3DPlaneDetectionExtentTypesRelease();
  if ([(ARWorldTrackingOptions *)a1->options planeEstimationShouldUseJasperData])
  {
    detectionPolicyString = a1->detectionPolicyString;
    if (detectionPolicyString) {
      [(NSString *)detectionPolicyString isEqualToString:@"jasper"];
    }
    CV3DPlaneDetectionConfigurationSetDetectionPolicy();
  }
  else
  {
    CV3DPlaneDetectionConfigurationSetDetectionPolicy();
    CV3DPlaneDetectionConfigurationEnableMLSegmentDetector();
  }
  if (a1->var0) {
    CV3DPlaneDetectionConfigurationEnableDeterministicMode();
  }
  if ([(ARWorldTrackingOptions *)a1->options lowQosSchedulingEnabled]) {
    CV3DPlaneDetectionConfigurationEnableLowQosScheduling();
  }
  return v2;
}

uint64_t ExtractParams(const PlaneDetectionConfiguration *a1)
{
  uint64_t v2 = CV3DPlaneDetectionParametersCreate();
  detectionCountUserDefaultValue = a1->detectionCountUserDefaultValue;
  if (detectionCountUserDefaultValue)
  {
    [(NSNumber *)detectionCountUserDefaultValue intValue];
    CV3DPlaneDetectionParametersSetMinDetections();
  }
  if ([(ARWorldTrackingOptions *)a1->options planeBundleAdjustmentEnabled]) {
    CV3DPlaneDetectionParametersSetMinDetections();
  }
  if (+[ARKitUserDefaults BOOLForKey:@"com.apple.arkit.planeEstimation.enableInverseDepthDetector"])
  {
    CV3DPlaneDetectionParametersSetInverseDepthDetector();
    CV3DPlaneDetectionParametersSetMinimumCellSize();
    CV3DPlaneDetectionParametersSetPlaneFitThreshold();
    CV3DPlaneDetectionParametersSetMinDepthConfidence();
    CV3DPlaneDetectionParametersSetMinNormalDotProduct();
    CV3DPlaneDetectionParametersSetMinClusterSize();
  }
  return v2;
}

void *PlaneDetectionSession::PlaneDetectionSession(void *a1, uint64_t a2, const PlaneDetectionConfiguration *a3, void *a4, void *a5)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  id v9 = a4;
  id v10 = a5;
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0;
  a1[1] = ExtractParams(a3);
  *a1 = ExtractConfig(a3);
  CFErrorRef err = 0;
  uint64_t v11 = CV3DPlaneDetectionSessionCreateWithConfig();
  a1[2] = v11;
  if (v11)
  {
    v21[0] = MEMORY[0x1E4F143A8];
    v21[1] = 3221225472;
    v21[2] = ___ZN21PlaneDetectionSessionC2EP15CV3DSLAMSessionRK27PlaneDetectionConfigurationU13block_pointerFvPK27CV3DPlaneDetectionPlaneListEU13block_pointerFvPK37CV3DPlaneDetectionSingleShotPlaneListE_block_invoke;
    v21[3] = &__block_descriptor_40_e28_v80__0____CFUUID__8____4__16l;
    v21[4] = a2;
    uint64_t v12 = (void *)MEMORY[0x1BA9C63E0](v21);
    v20[0] = MEMORY[0x1E4F143A8];
    v20[1] = 3221225472;
    v20[2] = ___ZN21PlaneDetectionSessionC2EP15CV3DSLAMSessionRK27PlaneDetectionConfigurationU13block_pointerFvPK27CV3DPlaneDetectionPlaneListEU13block_pointerFvPK37CV3DPlaneDetectionSingleShotPlaneListE_block_invoke_2;
    v20[3] = &__block_descriptor_40_e19_v16__0____CFUUID__8l;
    v20[4] = a2;
    unint64_t v13 = (void *)MEMORY[0x1BA9C63E0](v20);
    if ((CV3DPlaneDetectionSessionSetAnchoringFunctors() & 1) == 0)
    {
      uint64_t v14 = _ARLogGeneral();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v15 = CFErrorCopyDescription(err);
        *(_DWORD *)buf = 138412290;
        CFStringRef v24 = v15;
        _os_log_impl(&dword_1B88A2000, v14, OS_LOG_TYPE_ERROR, "Error setting anchoring functors: %@", buf, 0xCu);
      }

      CFRelease(err);
    }
    if ((CV3DPlaneDetectionSessionRegisterUpdateCallback() & 1) == 0)
    {
      float32x4_t v16 = _ARLogGeneral();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v17 = CFErrorCopyDescription(err);
        *(_DWORD *)buf = 138412290;
        CFStringRef v24 = v17;
        _os_log_impl(&dword_1B88A2000, v16, OS_LOG_TYPE_ERROR, "Error registering update callback: %@", buf, 0xCu);
      }

      CFRelease(err);
    }
    if (v10) {
      CV3DPlaneDetectionSessionSetSingleShotPlanesCallback();
    }
  }
  else
  {
    int v18 = _ARLogGeneral();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      CFStringRef v24 = CFErrorCopyDescription(err);
      _os_log_impl(&dword_1B88A2000, v18, OS_LOG_TYPE_ERROR, "Error initializing surface detection: %@", buf, 0xCu);
    }

    CFRelease(err);
  }

  return a1;
}

void sub_1B88AB464(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN21PlaneDetectionSessionC2EP15CV3DSLAMSessionRK27PlaneDetectionConfigurationU13block_pointerFvPK27CV3DPlaneDetectionPlaneListEU13block_pointerFvPK37CV3DPlaneDetectionSingleShotPlaneListE_block_invoke()
{
  return CV3DSLAMSessionAddAnchor();
}

uint64_t ___ZN21PlaneDetectionSessionC2EP15CV3DSLAMSessionRK27PlaneDetectionConfigurationU13block_pointerFvPK27CV3DPlaneDetectionPlaneListEU13block_pointerFvPK37CV3DPlaneDetectionSingleShotPlaneListE_block_invoke_2()
{
  return CV3DSLAMSessionRemoveAnchor();
}

void PlaneDetectionSession::~PlaneDetectionSession(PlaneDetectionSession *this)
{
}

void PlaneDetectionSession::PushSlamState(PlaneDetectionSession *this, const CV3DSLAMStateContext *a2)
{
}

void sub_1B88AB670(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t PlaneDetectionSession::PushSemanticsAndNormals(PlaneDetectionSession *this, ARSegmentationData *a2, simd_float4x4 a3, simd_float3x3 a4, double a5)
{
  float32x4_t v5 = a2;
  [(ARSegmentationData *)v5 timestamp];
  [(ARSegmentationData *)v5 segmentationBuffer];
  [(ARSegmentationData *)v5 confidenceBuffer];
  [(ARSegmentationData *)v5 normalsBuffer];
  CV3DPlaneDetectionSemanticFrameCreate();
  CV3DPlaneDetectionPushSemanticFrame();
  CV3DPlaneDetectionSemanticFrameRelease();

  return 1;
}

void sub_1B88AB7F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t PlaneDetectionSession::PushDepthWithSemantics(PlaneDetectionSession *this, ARMLDepthData *a2, ARSegmentationData *a3, simd_float4x4 a4, simd_float3x3 a5, double a6)
{
  id v7 = a2;
  id v8 = a3;
  [(ARSegmentationData *)v8 timestamp];
  [(ARMLDepthData *)v7 singleFrameDepthBuffer];
  [(ARMLDepthData *)v7 confidenceBuffer];
  [(ARMLDepthData *)v7 normalsBuffer];
  [(ARSegmentationData *)v8 maskedSemanticsSampledForDepth];
  [(ARSegmentationData *)v8 confidenceSampledForDepth];
  CV3DPlaneDetectionDepthAndSemanticFrameCreate();
  CV3DPlaneDetectionPushDepthAndSemanticFrame();
  CV3DPlaneDetectionDepthAndSemanticFrameRelease();

  return 1;
}

void sub_1B88AB9C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t PlaneDetectionSession::PushJasperPointCloud(uint64_t a1, void *a2)
{
  id v2 = a2;
  CV3DPlaneDetectionDepthCameraFrameCreateFromAD();
  CV3DPlaneDetectionPushSparseDepthFrame();
  CV3DPlaneDetectionDepthCameraFrameRelease();

  return 1;
}

void sub_1B88ABB4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id PlaneDetectionSession::SerializePlanes(PlaneDetectionSession *this)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = objc_opt_new();
  if (CV3DPlaneDetectionSerialize())
  {
    id v2 = v1;
  }
  else
  {
    uint64_t v3 = _ARLogGeneral();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      CFStringRef v6 = CFErrorCopyDescription(0);
      _os_log_impl(&dword_1B88A2000, v3, OS_LOG_TYPE_ERROR, "Failed to serialize surface data: %@", buf, 0xCu);
    }

    CFRelease(0);
    id v2 = 0;
  }

  return v2;
}

void sub_1B88ABC7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void PlaneDetectionSession::LoadPlanes(PlaneDetectionSession *this, const __CFData *a2)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  if ((CV3DPlaneDetectionLoadMap() & 1) == 0)
  {
    id v2 = _ARLogGeneral();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      CFStringRef v4 = CFErrorCopyDescription(0);
      _os_log_impl(&dword_1B88A2000, v2, OS_LOG_TYPE_ERROR, "Failed to load surface data: %@", buf, 0xCu);
    }

    CFRelease(0);
  }
}

void sub_1B88ABD64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void PlaneDetectionSession::ErasePlanes(uint64_t a1, void *a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  id v2 = a2;
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0);
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  id v4 = v2;
  uint64_t v5 = [v4 countByEnumeratingWithState:&v11 objects:v15 count:16];
  if (v5)
  {
    uint64_t v6 = *(void *)v12;
    do
    {
      uint64_t v7 = 0;
      do
      {
        if (*(void *)v12 != v6) {
          objc_enumerationMutation(v4);
        }
        id v8 = *(void **)(*((void *)&v11 + 1) + 8 * v7);
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          id v9 = objc_msgSend(v8, "identifier", (void)v11);
          id v10 = (const void *)objc_msgSend(v9, "ar_createCFUUIDRef");

          CFArrayAppendValue(Mutable, v10);
          CFRelease(v10);
        }
        ++v7;
      }
      while (v5 != v7);
      uint64_t v5 = [v4 countByEnumeratingWithState:&v11 objects:v15 count:16];
    }
    while (v5);
  }

  CV3DPlaneDetectionErasePlaneDetections();
  CFRelease(Mutable);
}

void sub_1B88ABF00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t PlaneDetectionSession::UpdateConfiguration(PlaneDetectionSession *this, const PlaneDetectionConfiguration *a2)
{
  CV3DPlaneDetectionConfigurationRelease();
  uint64_t Config = ExtractConfig(a2);
  *(void *)this = Config;
  uint64_t v5 = *((void *)this + 2);
  return MEMORY[0x1F4147CF8](v5, Config, 0);
}

uint64_t PlaneDetectionSession::DidParametersOrConfigurationChanged(PlaneDetectionSession *this, const PlaneDetectionConfiguration *a2)
{
  ExtractParams(a2);
  ExtractConfig(a2);
  unsigned int v3 = CV3DPlaneDetectionParametersEqualParameters() ^ 1;
  int v4 = CV3DPlaneDetectionConfigurationEqualConfigurations();
  CV3DPlaneDetectionConfigurationRelease();
  CV3DPlaneDetectionParametersRelease();
  if (v4) {
    int v5 = 0;
  }
  else {
    int v5 = 256;
  }
  return v5 | v3;
}

void ___ZL13_ARLogGeneralv_block_invoke_0()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "General");
  uint64_t v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObuint64_t j = (uint64_t)v0;
}

void sub_1B88AE138(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

double simd_quaternion(simd_float3x3 a1)
{
  float v1 = a1.columns[2].f32[2] + (float)(a1.columns[0].f32[0] + a1.columns[1].f32[1]);
  if (v1 >= 0.0)
  {
    float v8 = sqrtf(v1 + 1.0);
    float32x2_t v9 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT(v8 + v8));
    float32x2_t v10 = vmul_f32(v9, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT(v8 + v8), v9));
    float32x2_t v20 = vmul_n_f32(vsub_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a1.columns[1], (int8x16_t)a1.columns[1], 8uLL), *(int32x2_t *)a1.columns[2].f32), (float32x2_t)vext_s8(*(int8x8_t *)a1.columns[2].f32, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)a1.columns[0], (int8x16_t)a1.columns[0], 8uLL), 4uLL)), vmul_f32(v10, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT(v8 + v8), v10)).f32[0]);
  }
  else if (a1.columns[0].f32[0] < a1.columns[1].f32[1] || a1.columns[0].f32[0] < a1.columns[2].f32[2])
  {
    float v3 = 1.0 - a1.columns[0].f32[0];
    if (a1.columns[1].f32[1] >= a1.columns[2].f32[2])
    {
      float v21 = sqrtf(a1.columns[1].f32[1] + (float)(v3 - a1.columns[2].f32[2]));
      *(float *)&unsigned int v22 = v21 + v21;
      float32x2_t v23 = vrecpe_f32((float32x2_t)v22);
      float32x2_t v24 = vmul_f32(v23, vrecps_f32((float32x2_t)v22, v23));
      v25.i32[0] = vmul_f32(v24, vrecps_f32((float32x2_t)v22, v24)).u32[0];
      v24.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_lane_s32(*(int32x2_t *)a1.columns[0].f32, 1), *(float32x2_t *)a1.columns[1].f32).u32[0];
      v24.i32[1] = v22;
      v25.i32[1] = 0.25;
      float32x2_t v20 = vmul_f32(v24, v25);
    }
    else
    {
      float32x2_t v4 = (float32x2_t)__PAIR64__(a1.columns[0].u32[1], COERCE_UNSIGNED_INT(sqrtf(a1.columns[2].f32[2] + (float)(v3 - a1.columns[1].f32[1]))));
      *(float32x2_t *)a1.columns[2].f32 = vadd_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a1.columns[0], (int8x16_t)a1.columns[0], 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a1.columns[1], (int8x16_t)a1.columns[1], 8uLL)), *(float32x2_t *)a1.columns[2].f32);
      *(int32x2_t *)a1.columns[1].f32 = vdup_lane_s32(*(int32x2_t *)a1.columns[1].f32, 0);
      a1.columns[1].i32[0] = 2.0;
      a1.columns[1].i32[0] = vmul_f32(v4, *(float32x2_t *)a1.columns[1].f32).u32[0];
      float32x2_t v5 = vrecpe_f32((float32x2_t)a1.columns[1].u32[0]);
      float32x2_t v6 = vmul_f32(v5, vrecps_f32((float32x2_t)a1.columns[1].u32[0], v5));
      float32x2_t v20 = vmul_n_f32(*(float32x2_t *)a1.columns[2].f32, vmul_f32(v6, vrecps_f32((float32x2_t)a1.columns[1].u32[0], v6)).f32[0]);
      __asm { FMOV            V2.2S, #0.25 }
    }
  }
  else
  {
    float32x2_t v11 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)a1.columns[1].f32, 0);
    float32x2_t v12 = vadd_f32(*(float32x2_t *)a1.columns[0].f32, v11);
    v11.i32[0] = 2.0;
    v11.i32[0] = vmul_f32((float32x2_t)__PAIR64__(a1.columns[0].u32[1], COERCE_UNSIGNED_INT(sqrtf(a1.columns[0].f32[0]+ (float)((float)(1.0 - a1.columns[1].f32[1]) - a1.columns[2].f32[2])))), v11).u32[0];
    v11.i32[1] = v12.i32[1];
    float32x2_t v13 = vrecpe_f32((float32x2_t)v11.u32[0]);
    float32x2_t v14 = vmul_f32(v13, vrecps_f32((float32x2_t)v11.u32[0], v13));
    unsigned __int32 v15 = vmul_f32(v14, vrecps_f32((float32x2_t)v11.u32[0], v14)).u32[0];
    __asm { FMOV            V5.2S, #0.25 }
    _D5.i32[1] = v15;
    float32x2_t v20 = vmul_f32(v11, _D5);
  }
  return *(double *)&v20;
}

void sub_1B88B0AAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88B0BA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B88B0D90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,id a26)
{
  _Unwind_Resume(a1);
}

void sub_1B88B1260(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18)
{
  _Unwind_Resume(a1);
}

uint64_t cv3d::recon::mesh_util::TriMesh<float,unsigned int>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    std::vector<cva::Matrix<float,3u,1u,false>>::__assign_with_size[abi:ne180100]<cva::Matrix<float,3u,1u,false>*,cva::Matrix<float,3u,1u,false>*>((void *)a1, *(_DWORD **)a2, *(_DWORD **)(a2 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2));
    std::vector<cva::Matrix<float,3u,1u,false>>::__assign_with_size[abi:ne180100]<cva::Matrix<float,3u,1u,false>*,cva::Matrix<float,3u,1u,false>*>((void *)(a1 + 24), *(_DWORD **)(a2 + 24), *(_DWORD **)(a2 + 32), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 32) - *(void *)(a2 + 24)) >> 2));
    std::vector<cva::Matrix<float,3u,1u,false>>::__assign_with_size[abi:ne180100]<cva::Matrix<float,3u,1u,false>*,cva::Matrix<float,3u,1u,false>*>((void *)(a1 + 48), *(_DWORD **)(a2 + 48), *(_DWORD **)(a2 + 56), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 56) - *(void *)(a2 + 48)) >> 2));
    std::vector<cva::Matrix<float,3u,1u,false>>::__assign_with_size[abi:ne180100]<cva::Matrix<float,3u,1u,false>*,cva::Matrix<float,3u,1u,false>*>((void *)(a1 + 72), *(_DWORD **)(a2 + 72), *(_DWORD **)(a2 + 80), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 80) - *(void *)(a2 + 72)) >> 2));
    std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__assign_with_size[abi:ne180100]<cva::Matrix<unsigned int,2u,1u,false>*,cva::Matrix<unsigned int,2u,1u,false>*>((uint64_t **)(a1 + 96), *(uint64_t **)(a2 + 96), *(uint64_t **)(a2 + 104), (uint64_t)(*(void *)(a2 + 104) - *(void *)(a2 + 96)) >> 3);
    std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__assign_with_size[abi:ne180100]<cva::Matrix<unsigned int,2u,1u,false>*,cva::Matrix<unsigned int,2u,1u,false>*>((uint64_t **)(a1 + 120), *(uint64_t **)(a2 + 120), *(uint64_t **)(a2 + 128), (uint64_t)(*(void *)(a2 + 128) - *(void *)(a2 + 120)) >> 3);
    std::vector<cva::Matrix<float,3u,1u,false>>::__assign_with_size[abi:ne180100]<cva::Matrix<float,3u,1u,false>*,cva::Matrix<float,3u,1u,false>*>((void *)(a1 + 144), *(_DWORD **)(a2 + 144), *(_DWORD **)(a2 + 152), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 152) - *(void *)(a2 + 144)) >> 2));
  }
  return a1;
}

_DWORD *std::vector<cva::Matrix<float,3u,1u,false>>::__assign_with_size[abi:ne180100]<cva::Matrix<float,3u,1u,false>*,cva::Matrix<float,3u,1u,false>*>(void *a1, _DWORD *a2, _DWORD *a3, unint64_t a4)
{
  float32x2_t v6 = a2;
  uint64_t v8 = a1[2];
  uint64_t result = (_DWORD *)*a1;
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - (uint64_t)result) >> 2) < a4)
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      uint64_t v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 > 0x1555555555555555) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 2);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= a4) {
      uint64_t v11 = a4;
    }
    if (v10 >= 0xAAAAAAAAAAAAAAALL) {
      unint64_t v12 = 0x1555555555555555;
    }
    else {
      unint64_t v12 = v11;
    }
    std::vector<cva::Matrix<float,3u,1u,false>>::__vallocate[abi:ne180100](a1, v12);
    float32x2_t v14 = (_DWORD *)a1[1];
    float32x2_t v13 = (_DWORD **)(a1 + 1);
    uint64_t result = v14;
    unsigned __int32 v15 = (char *)v14;
    if (v6 != a3)
    {
      unsigned __int32 v15 = (char *)result;
      do
      {
        uint64_t v16 = *(void *)v6;
        *((_DWORD *)v15 + 2) = v6[2];
        *(void *)unsigned __int32 v15 = v16;
        v15 += 12;
        v6 += 3;
      }
      while (v6 != a3);
    }
LABEL_30:
    int64_t v26 = v15 - (char *)result;
    goto LABEL_31;
  }
  int v18 = (_DWORD *)a1[1];
  float32x2_t v13 = (_DWORD **)(a1 + 1);
  CFStringRef v17 = v18;
  unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * (v18 - result);
  if (v19 >= a4)
  {
    unsigned __int32 v15 = (char *)result;
    if (a2 != a3)
    {
      float32x4_t v27 = result;
      do
      {
        if (v6 != v27)
        {
          uint64_t v28 = *(void *)v6;
          v27[2] = v6[2];
          *(void *)float32x4_t v27 = v28;
        }
        v6 += 3;
        v27 += 3;
        v15 += 12;
      }
      while (v6 != a3);
    }
    goto LABEL_30;
  }
  float32x2_t v20 = &a2[3 * v19];
  if (v17 != result)
  {
    uint64_t v21 = 12 * v19;
    do
    {
      if (v6 != result)
      {
        uint64_t v22 = *(void *)v6;
        result[2] = v6[2];
        *(void *)uint64_t result = v22;
      }
      v6 += 3;
      result += 3;
      v21 -= 12;
    }
    while (v21);
    uint64_t result = *v13;
  }
  float32x2_t v23 = (char *)result;
  if (v20 != a3)
  {
    float32x2_t v23 = (char *)result;
    float32x2_t v24 = result;
    do
    {
      uint64_t v25 = *(void *)v20;
      v24[2] = v20[2];
      *(void *)float32x2_t v24 = v25;
      v24 += 3;
      v20 += 3;
      v23 += 12;
    }
    while (v20 != a3);
  }
  int64_t v26 = v23 - (char *)result;
LABEL_31:
  void *v13 = (_DWORD *)((char *)result + v26);
  return result;
}

char *std::vector<cva::Matrix<float,3u,1u,false>>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x1555555555555556) {
    std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<float,3u,1u,false>>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[12 * v4];
  return result;
}

void std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]()
{
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<float,3u,1u,false>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x1555555555555556) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(12 * a2);
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_1E6184908, MEMORY[0x1E4FBA1C8]);
}

void sub_1B88B18E0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  uint64_t result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D0] + 16);
  return result;
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  float v1 = std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(v1, MEMORY[0x1E4FBA350], MEMORY[0x1E4FBA1F8]);
}

uint64_t *std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__assign_with_size[abi:ne180100]<cva::Matrix<unsigned int,2u,1u,false>*,cva::Matrix<unsigned int,2u,1u,false>*>(uint64_t **a1, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  float32x2_t v6 = a2;
  uint64_t v8 = (uint64_t)a1[2];
  uint64_t result = *a1;
  if (a4 > (v8 - (uint64_t)result) >> 3)
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      uint64_t v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 >> 61) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 2;
    if (v8 >> 2 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__vallocate[abi:ne180100](a1, v11);
    float32x2_t v13 = a1[1];
    unint64_t v12 = a1 + 1;
    uint64_t result = v13;
    float32x2_t v14 = (char *)v13;
    if (v6 != a3)
    {
      float32x2_t v14 = (char *)result;
      do
      {
        uint64_t v15 = *v6++;
        *(void *)float32x2_t v14 = v15;
        v14 += 8;
      }
      while (v6 != a3);
    }
LABEL_30:
    int64_t v24 = v14 - (char *)result;
    goto LABEL_31;
  }
  CFStringRef v17 = a1[1];
  unint64_t v12 = a1 + 1;
  uint64_t v16 = v17;
  unint64_t v18 = v17 - result;
  if (v18 >= a4)
  {
    float32x2_t v14 = (char *)result;
    if (a2 != a3)
    {
      uint64_t v25 = result;
      do
      {
        if (v6 != v25) {
          uint64_t *v25 = *v6;
        }
        ++v6;
        ++v25;
        v14 += 8;
      }
      while (v6 != a3);
    }
    goto LABEL_30;
  }
  unint64_t v19 = &a2[v18];
  if (v16 != result)
  {
    uint64_t v20 = 8 * v18;
    do
    {
      if (v6 != result) {
        *uint64_t result = *v6;
      }
      ++v6;
      ++result;
      v20 -= 8;
    }
    while (v20);
    uint64_t result = *v12;
  }
  uint64_t v21 = (char *)result;
  if (v19 != a3)
  {
    uint64_t v21 = (char *)result;
    uint64_t v22 = result;
    do
    {
      uint64_t v23 = *v19++;
      *v22++ = v23;
      v21 += 8;
    }
    while (v19 != a3);
  }
  int64_t v24 = v21 - (char *)result;
LABEL_31:
  *unint64_t v12 = (uint64_t *)((char *)result + v24);
  return result;
}

char *std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >> 61) {
    std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(8 * a2);
}

uint64_t cv3d::recon::mesh_util::TriMesh<float,unsigned int>::TriMesh(uint64_t a1, uint64_t **a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  std::vector<cva::Matrix<float,3u,1u,false>>::__init_with_size[abi:ne180100]<cva::Matrix<float,3u,1u,false>*,cva::Matrix<float,3u,1u,false>*>((char *)a1, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * (((char *)a2[1] - (char *)*a2) >> 2));
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  std::vector<cva::Matrix<float,3u,1u,false>>::__init_with_size[abi:ne180100]<cva::Matrix<float,3u,1u,false>*,cva::Matrix<float,3u,1u,false>*>((char *)(a1 + 24), a2[3], a2[4], 0xAAAAAAAAAAAAAAABLL * (((char *)a2[4] - (char *)a2[3]) >> 2));
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  std::vector<cva::Matrix<float,3u,1u,false>>::__init_with_size[abi:ne180100]<cva::Matrix<float,3u,1u,false>*,cva::Matrix<float,3u,1u,false>*>((char *)(a1 + 48), a2[6], a2[7], 0xAAAAAAAAAAAAAAABLL * (((char *)a2[7] - (char *)a2[6]) >> 2));
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  std::vector<cva::Matrix<unsigned int,3u,1u,false>>::__init_with_size[abi:ne180100]<cva::Matrix<unsigned int,3u,1u,false>*,cva::Matrix<unsigned int,3u,1u,false>*>((char *)(a1 + 72), a2[9], a2[10], 0xAAAAAAAAAAAAAAABLL * (((char *)a2[10] - (char *)a2[9]) >> 2));
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__init_with_size[abi:ne180100]<cva::Matrix<unsigned int,2u,1u,false>*,cva::Matrix<unsigned int,2u,1u,false>*>((char *)(a1 + 96), a2[12], a2[13], a2[13] - a2[12]);
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = 0;
  std::vector<cva::Matrix<float,2u,1u,false>>::__init_with_size[abi:ne180100]<cva::Matrix<float,2u,1u,false>*,cva::Matrix<float,2u,1u,false>*>((char *)(a1 + 120), a2[15], a2[16], a2[16] - a2[15]);
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = 0;
  std::vector<cva::Matrix<unsigned int,3u,1u,false>>::__init_with_size[abi:ne180100]<cva::Matrix<unsigned int,3u,1u,false>*,cva::Matrix<unsigned int,3u,1u,false>*>((char *)(a1 + 144), a2[18], a2[19], 0xAAAAAAAAAAAAAAABLL * (((char *)a2[19] - (char *)a2[18]) >> 2));
  return a1;
}

void sub_1B88B1C90(_Unwind_Exception *exception_object)
{
  uint64_t v8 = *v6;
  if (*v6)
  {
    *(void *)(v1 + 128) = v8;
    operator delete(v8);
  }
  float32x2_t v9 = *v5;
  if (*v5)
  {
    *(void *)(v1 + 104) = v9;
    operator delete(v9);
  }
  uint64_t v10 = *v4;
  if (*v4)
  {
    *(void *)(v1 + 80) = v10;
    operator delete(v10);
  }
  unint64_t v11 = *v3;
  if (*v3)
  {
    *(void *)(v1 + 56) = v11;
    operator delete(v11);
  }
  unint64_t v12 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 32) = v12;
    operator delete(v12);
  }
  float32x2_t v13 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v13;
    operator delete(v13);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<cva::Matrix<float,3u,1u,false>>::__init_with_size[abi:ne180100]<cva::Matrix<float,3u,1u,false>*,cva::Matrix<float,3u,1u,false>*>(char *result, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  if (a4)
  {
    float32x2_t v6 = result;
    uint64_t result = std::vector<cva::Matrix<float,3u,1u,false>>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = *((void *)v6 + 1);
    while (a2 != a3)
    {
      uint64_t v8 = *a2;
      *(_DWORD *)(v7 + 8) = *((_DWORD *)a2 + 2);
      *(void *)uint64_t v7 = v8;
      v7 += 12;
      a2 = (uint64_t *)((char *)a2 + 12);
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_1B88B1D88(_Unwind_Exception *exception_object)
{
  float v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<cva::Matrix<unsigned int,3u,1u,false>>::__init_with_size[abi:ne180100]<cva::Matrix<unsigned int,3u,1u,false>*,cva::Matrix<unsigned int,3u,1u,false>*>(char *result, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  if (a4)
  {
    float32x2_t v6 = result;
    uint64_t result = std::vector<cva::Matrix<float,3u,1u,false>>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = *((void *)v6 + 1);
    while (a2 != a3)
    {
      uint64_t v8 = *a2;
      *(_DWORD *)(v7 + 8) = *((_DWORD *)a2 + 2);
      *(void *)uint64_t v7 = v8;
      v7 += 12;
      a2 = (uint64_t *)((char *)a2 + 12);
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_1B88B1E08(_Unwind_Exception *exception_object)
{
  float v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__init_with_size[abi:ne180100]<cva::Matrix<unsigned int,2u,1u,false>*,cva::Matrix<unsigned int,2u,1u,false>*>(char *result, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  if (a4)
  {
    float32x2_t v6 = result;
    uint64_t result = std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = (void *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      uint64_t v8 = *a2++;
      *v7++ = v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_1B88B1E7C(_Unwind_Exception *exception_object)
{
  float v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<cva::Matrix<float,2u,1u,false>>::__init_with_size[abi:ne180100]<cva::Matrix<float,2u,1u,false>*,cva::Matrix<float,2u,1u,false>*>(char *result, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  if (a4)
  {
    float32x2_t v6 = result;
    uint64_t result = std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = (void *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      uint64_t v8 = *a2++;
      *v7++ = v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_1B88B1EF0(_Unwind_Exception *exception_object)
{
  float v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t cv3d::recon::mesh_util::TriMesh<float,unsigned int>::~TriMesh(uint64_t a1)
{
  id v2 = *(void **)(a1 + 144);
  if (v2)
  {
    *(void *)(a1 + 152) = v2;
    operator delete(v2);
  }
  float v3 = *(void **)(a1 + 120);
  if (v3)
  {
    *(void *)(a1 + 128) = v3;
    operator delete(v3);
  }
  uint64_t v4 = *(void **)(a1 + 96);
  if (v4)
  {
    *(void *)(a1 + 104) = v4;
    operator delete(v4);
  }
  float32x2_t v5 = *(void **)(a1 + 72);
  if (v5)
  {
    *(void *)(a1 + 80) = v5;
    operator delete(v5);
  }
  float32x2_t v6 = *(void **)(a1 + 48);
  if (v6)
  {
    *(void *)(a1 + 56) = v6;
    operator delete(v6);
  }
  uint64_t v7 = *(void **)(a1 + 24);
  if (v7)
  {
    *(void *)(a1 + 32) = v7;
    operator delete(v7);
  }
  uint64_t v8 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v8;
    operator delete(v8);
  }
  return a1;
}

void *std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(void *result, const void *a2, uint64_t a3, size_t __sz)
{
  if (__sz)
  {
    float32x2_t v6 = result;
    uint64_t result = std::vector<unsigned char>::__vallocate[abi:ne180100](result, __sz);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1B88B2000(_Unwind_Exception *exception_object)
{
  float v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<unsigned char>::__vallocate[abi:ne180100](void *a1, size_t __sz)
{
  if ((__sz & 0x8000000000000000) != 0) {
    std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)operator new(__sz);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[__sz];
  return result;
}

void *std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char *,unsigned char *>(void *result, char *__src, char *a3, unint64_t a4)
{
  uint64_t v7 = result;
  unint64_t v8 = result[2];
  float32x2_t v9 = (char *)*result;
  if (v8 - *result < a4)
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      unint64_t v8 = 0;
      *uint64_t v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if ((a4 & 0x8000000000000000) != 0) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = 2 * v8;
    if (2 * v8 <= a4) {
      uint64_t v10 = a4;
    }
    if (v8 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v11 = v10;
    }
    uint64_t result = std::vector<unsigned char>::__vallocate[abi:ne180100](v7, v11);
    float32x2_t v9 = (char *)v7[1];
    goto LABEL_17;
  }
  unint64_t v12 = (unsigned char *)result[1];
  size_t v13 = v12 - v9;
  if (v12 - v9 >= a4)
  {
LABEL_17:
    size_t v16 = a3 - __src;
    if (v16) {
      uint64_t result = memmove(v9, __src, v16);
    }
    uint64_t v15 = &v9[v16];
    goto LABEL_20;
  }
  float32x2_t v14 = &__src[v13];
  if (v12 != v9)
  {
    uint64_t result = memmove((void *)*result, __src, v13);
    float32x2_t v9 = (char *)v7[1];
  }
  if (a3 != v14) {
    uint64_t result = memmove(v9, v14, a3 - v14);
  }
  uint64_t v15 = &v9[a3 - v14];
LABEL_20:
  v7[1] = v15;
  return result;
}

void sub_1B88B3700(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88B38B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88B3A94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88B3DA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88B3FC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL13_ARLogGeneralv_block_invoke_1()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "General");
  uint64_t v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObuint64_t j = (uint64_t)v0;
}

BOOL ___ZL18ARSkipCrashOnCrashv_block_invoke()
{
  BOOL result = +[ARKitUserDefaults BOOLForKey:@"com.apple.arkit.skipCrashOnARCrash"];
  ARSkipCrashOnCrash(void)::skipCrashOnCrash = result;
  return result;
}

id _ARLogSensor()
{
  if (_ARLogSensor_onceToken != -1) {
    dispatch_once(&_ARLogSensor_onceToken, &__block_literal_global_133);
  }
  os_log_t v0 = (void *)_ARLogSensor_logObj;
  return v0;
}

void sub_1B88B5A84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9, int a10, __int16 a11, __int16 a12, uint64_t a13, __int16 a14, long long a15)
{
  if (a2 == 1)
  {
    id v17 = objc_begin_catch(exception_object);
    unint64_t v18 = _ARLogSensor();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      unint64_t v19 = (objc_class *)objc_opt_class();
      NSStringFromClass(v19);
      id v20 = (id)objc_claimAutoreleasedReturnValue();
      id v21 = [v16 logPrefix];
      uint64_t v22 = [v15 timeOfFlightProjectorMode];
      uint64_t v23 = [v17 reason];
      LODWORD(a9) = 138544642;
      *(void *)((char *)&a9 + 4) = v20;
      WORD6(a9) = 2048;
      *(void *)((char *)&a9 + 14) = v16;
      a12 = 2112;
      a13 = (uint64_t)v21;
      a14 = 2112;
      WORD1(a15) = 2048;
      *(void *)((char *)&a15 + 4) = v22;
      WORD6(a15) = 2112;
      *(void *)((char *)&a15 + 14) = v23;
      _os_log_impl(&dword_1B88A2000, v18, OS_LOG_TYPE_ERROR, "%{public}@ <%p>: %@ Unable to set projector mode to %@. Current projector mode of the device: %ld. Exception: %@", (uint8_t *)&a9, 0x3Eu);
    }
    objc_end_catch();
    JUMPOUT(0x1B88B5A40);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ARAVTimeOfFlightProjectorModeFromARTimeOfFlightProjectMode(void *a1)
{
  id v1 = a1;
  if ([v1 isEqualToString:@"ARTimeOfFlightProjectorModeNormal"])
  {
    uint64_t v2 = 1;
  }
  else if ([v1 isEqualToString:@"ARTimeOfFlightProjectorModeShortRange"])
  {
    uint64_t v2 = 2;
  }
  else if ([v1 isEqualToString:@"ARTimeOfFlightProjectorModeNormalShortHybrid"])
  {
    uint64_t v2 = 3;
  }
  else if ([v1 isEqualToString:@"ARTimeOfFlightProjectorModeHighQualityMacro"])
  {
    uint64_t v2 = 6;
  }
  else
  {
    uint64_t v2 = 0;
  }

  return v2;
}

void sub_1B88B661C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88B6828(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88B6D1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL13_ARLogGeneralv_block_invoke_2()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "General");
  id v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObuint64_t j = (uint64_t)v0;
}

BOOL ___ZL18ARSkipCrashOnCrashv_block_invoke_0()
{
  BOOL result = +[ARKitUserDefaults BOOLForKey:@"com.apple.arkit.skipCrashOnARCrash"];
  ARSkipCrashOnCrash(void)::skipCrashOnCrash = result;
  return result;
}

void sub_1B88B76A8(void *a1)
{
  objc_begin_catch(a1);

  objc_exception_rethrow();
}

void sub_1B88B76B8(_Unwind_Exception *a1)
{
  objc_end_catch();

  _Unwind_Resume(a1);
}

void sub_1B88B7770(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88B7838(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88B92E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88B95B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
  std::deque<std::pair<int,int>>::~deque[abi:ne180100](&a27);
  _Unwind_Resume(a1);
}

void std::deque<std::pair<int,int>>::push_back(void *a1, void *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = ((v4 - v5) << 6) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    std::deque<std::pair<int,int>>::__add_back_capacity(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }
  *(void *)(*(void *)(v5 + ((v7 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v7 & 0x1FF)) = *a2;
  ++a1[5];
}

void sub_1B88B981C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1B88B992C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88B99AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88B9A50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B88B9B98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88B9C74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88B9D80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *_ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE16__init_with_sizeB8ne180100IPS1_S6_EEvT_T0_m(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    BOOL result = _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE11__vallocateB8ne180100Em(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      BOOL result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1B88B9E1C(_Unwind_Exception *exception_object)
{
  float v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *_ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE11__vallocateB8ne180100Em(void *a1, unint64_t a2)
{
  if (a2 >> 60) {
    std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
  }
  BOOL result = (char *)_ZNSt3__119__allocate_at_leastB8ne180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

void *_ZNSt3__119__allocate_at_leastB8ne180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(16 * a2);
}

char *_ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE18__assign_with_sizeB8ne180100IPS1_S6_EEvT_T0_l(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  float32x2_t v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 4)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *uint64_t v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 60) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 3;
    if (v8 >> 3 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v11 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    BOOL result = _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE11__vallocateB8ne180100Em(v7, v11);
    size_t v13 = (char *)v7[1];
    unint64_t v12 = (void **)(v7 + 1);
    float32x2_t v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      unint64_t v18 = v9;
      unint64_t v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  unint64_t v12 = (void **)(result + 8);
  float32x2_t v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 4;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  size_t v16 = &__src[16 * v15];
  if (v14 != v9)
  {
    BOOL result = (char *)memmove(*(void **)result, __src, v14 - v9);
    float32x2_t v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    unint64_t v18 = v9;
    unint64_t v19 = v16;
LABEL_18:
    BOOL result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *unint64_t v12 = &v9[v17];
  return result;
}

uint64_t std::deque<std::pair<int,int>>::~deque[abi:ne180100](void *a1)
{
  uint64_t v2 = (void **)a1[1];
  float v3 = (void **)a1[2];
  a1[5] = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      float v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 256;
  }
  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 512;
  }
  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    uint64_t v7 = *v2++;
    operator delete(v7);
  }
  return std::__split_buffer<std::pair<int,int> *,std::allocator<std::pair<int,int> *>>::~__split_buffer((uint64_t)a1);
}

uint64_t std::__split_buffer<std::pair<int,int> *,std::allocator<std::pair<int,int> *>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3) {
    *(void *)(a1 + 16) = v2 + ((v3 - v2 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  unint64_t v4 = *(void **)a1;
  if (*(void *)a1) {
    operator delete(v4);
  }
  return a1;
}

void std::deque<std::pair<int,int>>::__add_back_capacity(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    uint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    float32x2_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)uint64_t v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      float32x4_t v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>(v5, v33);
      float32x4_t v35 = &v34[8 * (v33 >> 2)];
      float32x4_t v37 = &v34[8 * v36];
      float32x4_t v38 = (uint64_t *)a1[1];
      uint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        uint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        float32x4_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)float32x4_t v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    unint64_t v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      float32x2_t v9 = (char *)a1[1];
    }
    uint64_t v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0x1000uLL);
      std::__split_buffer<std::pair<int,int> *,std::allocator<std::pair<int,int> *>>::push_back(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0x1000uLL);
    std::__split_buffer<std::pair<int,int> *,std::allocator<std::pair<int,int> *>>::push_front((uint64_t)a1, &v54);
    double v44 = (void *)a1[1];
    uint64_t v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    float32x2_t v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      float32x4_t v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>((uint64_t)(a1 + 3), v46);
      float32x4_t v35 = &v34[8 * (v46 >> 2)];
      float32x4_t v37 = &v34[8 * v47];
      float32x4_t v48 = (uint64_t *)a1[1];
      uint64_t v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        uint64_t v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        float32x4_t v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)float32x4_t v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        uint64_t v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  v56 = a1 + 3;
  *(void *)&long long v54 = std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  v53 = operator new(0x1000uLL);
  std::__split_buffer<std::pair<int,int> *,std::allocator<std::pair<int,int> *> &>::push_back(&v54, &v53);
  float32x4_t v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    std::__split_buffer<std::pair<int,int> *,std::allocator<std::pair<int,int> *> &>::push_front((uint64_t)&v54, v27);
  }
  float32x4_t v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_1B88BA384(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void std::__split_buffer<std::pair<int,int> *,std::allocator<std::pair<int,int> *>>::push_back(void *a1, void *a2)
{
  uint64_t v5 = (char *)a1[3];
  uint64_t v4 = (uint64_t)(a1 + 3);
  uint64_t v6 = *(char **)(v4 - 8);
  if (v6 == v5)
  {
    uint64_t v7 = (char *)a1[1];
    uint64_t v8 = (uint64_t)&v7[-*a1];
    if ((unint64_t)v7 <= *a1)
    {
      if (v6 == (char *)*a1) {
        unint64_t v18 = 1;
      }
      else {
        unint64_t v18 = (uint64_t)&v6[-*a1] >> 2;
      }
      unint64_t v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>(v4, v18);
      uint64_t v21 = &v19[8 * (v18 >> 2)];
      unint64_t v22 = (uint64_t *)a1[1];
      uint64_t v6 = v21;
      uint64_t v23 = a1[2] - (void)v22;
      if (v23)
      {
        uint64_t v6 = &v21[v23 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v24 = 8 * (v23 >> 3);
        unint64_t v25 = &v19[8 * (v18 >> 2)];
        do
        {
          uint64_t v26 = *v22++;
          *(void *)unint64_t v25 = v26;
          v25 += 8;
          v24 -= 8;
        }
        while (v24);
      }
      float32x4_t v27 = (char *)*a1;
      *a1 = v19;
      a1[1] = v21;
      a1[2] = v6;
      a1[3] = &v19[8 * v20];
      if (v27)
      {
        operator delete(v27);
        uint64_t v6 = (char *)a1[2];
      }
    }
    else
    {
      uint64_t v9 = v8 >> 3;
      BOOL v10 = v8 >> 3 < -1;
      uint64_t v11 = (v8 >> 3) + 2;
      if (v10) {
        uint64_t v12 = v11;
      }
      else {
        uint64_t v12 = v9 + 1;
      }
      uint64_t v13 = -(v12 >> 1);
      uint64_t v14 = v12 >> 1;
      uint64_t v15 = &v7[-8 * v14];
      int64_t v16 = v6 - v7;
      if (v6 != v7)
      {
        memmove(&v7[-8 * v14], v7, v6 - v7);
        uint64_t v6 = (char *)a1[1];
      }
      uint64_t v17 = &v6[8 * v13];
      uint64_t v6 = &v15[v16];
      a1[1] = v17;
      a1[2] = &v15[v16];
    }
  }
  *(void *)uint64_t v6 = *a2;
  a1[2] += 8;
}

void std::__split_buffer<std::pair<int,int> *,std::allocator<std::pair<int,int> *>>::push_front(uint64_t a1, void *a2)
{
  uint64_t v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    uint64_t v6 = a1 + 24;
    uint64_t v7 = *(unsigned char **)(a1 + 24);
    uint64_t v8 = *(unsigned char **)(a1 + 16);
    if (v8 >= v7)
    {
      if (v7 == v4) {
        unint64_t v12 = 1;
      }
      else {
        unint64_t v12 = (v7 - v4) >> 2;
      }
      uint64_t v13 = 2 * v12;
      uint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>(v6, v12);
      uint64_t v5 = &v14[(v13 + 6) & 0xFFFFFFFFFFFFFFF8];
      int64_t v16 = *(uint64_t **)(a1 + 8);
      uint64_t v17 = v5;
      uint64_t v18 = *(void *)(a1 + 16) - (void)v16;
      if (v18)
      {
        uint64_t v17 = &v5[v18 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v19 = 8 * (v18 >> 3);
        uint64_t v20 = v5;
        do
        {
          uint64_t v21 = *v16++;
          *(void *)uint64_t v20 = v21;
          v20 += 8;
          v19 -= 8;
        }
        while (v19);
      }
      unint64_t v22 = *(char **)a1;
      *(void *)a1 = v14;
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = v17;
      *(void *)(a1 + 24) = &v14[8 * v15];
      if (v22)
      {
        operator delete(v22);
        uint64_t v5 = *(char **)(a1 + 8);
      }
    }
    else
    {
      uint64_t v9 = (v7 - v8) >> 3;
      if (v9 >= -1) {
        uint64_t v10 = v9 + 1;
      }
      else {
        uint64_t v10 = v9 + 2;
      }
      uint64_t v11 = v10 >> 1;
      uint64_t v5 = &v4[8 * (v10 >> 1)];
      if (v8 != v4)
      {
        memmove(&v4[8 * (v10 >> 1)], v4, v8 - v4);
        uint64_t v4 = *(char **)(a1 + 16);
      }
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = &v4[8 * v11];
    }
  }
  else
  {
    uint64_t v5 = *(char **)(a1 + 8);
  }
  *((void *)v5 - 1) = *a2;
  *(void *)(a1 + 8) -= 8;
}

void std::__split_buffer<std::pair<int,int> *,std::allocator<std::pair<int,int> *> &>::push_back(void *a1, void *a2)
{
  uint64_t v4 = (char *)a1[2];
  if (v4 == (char *)a1[3])
  {
    uint64_t v5 = (char *)a1[1];
    uint64_t v6 = (uint64_t)&v5[-*a1];
    if ((unint64_t)v5 <= *a1)
    {
      if (v4 == (char *)*a1) {
        unint64_t v16 = 1;
      }
      else {
        unint64_t v16 = (uint64_t)&v4[-*a1] >> 2;
      }
      uint64_t v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>(a1[4], v16);
      uint64_t v19 = &v17[8 * (v16 >> 2)];
      uint64_t v20 = (uint64_t *)a1[1];
      uint64_t v4 = v19;
      uint64_t v21 = a1[2] - (void)v20;
      if (v21)
      {
        uint64_t v4 = &v19[v21 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v22 = 8 * (v21 >> 3);
        uint64_t v23 = &v17[8 * (v16 >> 2)];
        do
        {
          uint64_t v24 = *v20++;
          *(void *)uint64_t v23 = v24;
          v23 += 8;
          v22 -= 8;
        }
        while (v22);
      }
      unint64_t v25 = (char *)*a1;
      *a1 = v17;
      a1[1] = v19;
      a1[2] = v4;
      a1[3] = &v17[8 * v18];
      if (v25)
      {
        operator delete(v25);
        uint64_t v4 = (char *)a1[2];
      }
    }
    else
    {
      uint64_t v7 = v6 >> 3;
      BOOL v8 = v6 >> 3 < -1;
      uint64_t v9 = (v6 >> 3) + 2;
      if (v8) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = v7 + 1;
      }
      uint64_t v11 = -(v10 >> 1);
      uint64_t v12 = v10 >> 1;
      uint64_t v13 = &v5[-8 * v12];
      int64_t v14 = v4 - v5;
      if (v4 != v5)
      {
        memmove(&v5[-8 * v12], v5, v4 - v5);
        uint64_t v4 = (char *)a1[1];
      }
      uint64_t v15 = &v4[8 * v11];
      uint64_t v4 = &v13[v14];
      a1[1] = v15;
      a1[2] = &v13[v14];
    }
  }
  *(void *)uint64_t v4 = *a2;
  a1[2] += 8;
}

void std::__split_buffer<std::pair<int,int> *,std::allocator<std::pair<int,int> *> &>::push_front(uint64_t a1, void *a2)
{
  uint64_t v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    uint64_t v6 = *(unsigned char **)(a1 + 16);
    uint64_t v7 = *(unsigned char **)(a1 + 24);
    if (v6 >= v7)
    {
      if (v7 == v4) {
        unint64_t v11 = 1;
      }
      else {
        unint64_t v11 = (v7 - v4) >> 2;
      }
      uint64_t v12 = 2 * v11;
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>(*(void *)(a1 + 32), v11);
      uint64_t v5 = &v13[(v12 + 6) & 0xFFFFFFFFFFFFFFF8];
      uint64_t v15 = *(uint64_t **)(a1 + 8);
      unint64_t v16 = v5;
      uint64_t v17 = *(void *)(a1 + 16) - (void)v15;
      if (v17)
      {
        unint64_t v16 = &v5[v17 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v18 = 8 * (v17 >> 3);
        uint64_t v19 = v5;
        do
        {
          uint64_t v20 = *v15++;
          *(void *)uint64_t v19 = v20;
          v19 += 8;
          v18 -= 8;
        }
        while (v18);
      }
      uint64_t v21 = *(char **)a1;
      *(void *)a1 = v13;
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = v16;
      *(void *)(a1 + 24) = &v13[8 * v14];
      if (v21)
      {
        operator delete(v21);
        uint64_t v5 = *(char **)(a1 + 8);
      }
    }
    else
    {
      uint64_t v8 = (v7 - v6) >> 3;
      if (v8 >= -1) {
        uint64_t v9 = v8 + 1;
      }
      else {
        uint64_t v9 = v8 + 2;
      }
      uint64_t v10 = v9 >> 1;
      uint64_t v5 = &v4[8 * (v9 >> 1)];
      if (v6 != v4)
      {
        memmove(&v4[8 * (v9 >> 1)], v4, v6 - v4);
        uint64_t v4 = *(char **)(a1 + 16);
      }
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = &v4[8 * v10];
    }
  }
  else
  {
    uint64_t v5 = *(char **)(a1 + 8);
  }
  *((void *)v5 - 1) = *a2;
  *(void *)(a1 + 8) -= 8;
}

void *_ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEEC2Em(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE11__vallocateB8ne180100Em(a1, a2);
    uint64_t v4 = (char *)a1[1];
    bzero(v4, 16 * a2);
    a1[1] = &v4[16 * a2];
  }
  return a1;
}

void sub_1B88BA898(_Unwind_Exception *exception_object)
{
  BOOL v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *_ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE16__init_with_sizeB8ne180100IPKS1_S7_EEvT_T0_m(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    BOOL result = _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE11__vallocateB8ne180100Em(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      BOOL result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1B88BA914(_Unwind_Exception *exception_object)
{
  BOOL v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B88BAB70(_Unwind_Exception *a1)
{
  objc_destroyWeak(v2);
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v3 - 72));
  _Unwind_Resume(a1);
}

uint64_t ARCorrectCVPixelBufferOrientation(__CVBuffer *a1, unsigned int a2, __CVBuffer **a3)
{
  if (a1)
  {
    if (CVPixelBufferGetPixelFormatType(a1) == 1278226488)
    {
      if (a2 == 1)
      {
        CVPixelBufferRetain(a1);
        uint64_t result = 0;
        *a3 = a1;
        return result;
      }
      CVPixelBufferRef v24 = 0;
      CVPixelBufferRef pixelBufferOut = 0;
      switch(a2)
      {
        case 2u:
          size_t Width = CVPixelBufferGetWidth(a1);
          size_t Height = CVPixelBufferGetHeight(a1);
          uint8_t v11 = 0;
          break;
        case 3u:
        case 4u:
          size_t Width = CVPixelBufferGetWidth(a1);
          size_t Height = CVPixelBufferGetHeight(a1);
          uint8_t v11 = 2;
          break;
        case 5u:
        case 8u:
          size_t Height = CVPixelBufferGetWidth(a1);
          size_t Width = CVPixelBufferGetHeight(a1);
          uint8_t v11 = 3;
          break;
        case 6u:
        case 7u:
          size_t Height = CVPixelBufferGetWidth(a1);
          size_t Width = CVPixelBufferGetHeight(a1);
          uint8_t v11 = 1;
          break;
        default:
          uint8_t v11 = 0;
          size_t Height = 0;
          size_t Width = 0;
          break;
      }
      CFDictionaryRef Attributes = (const __CFDictionary *)_getAttributes();
      CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      if (CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Width, Height, 0x4C303038u, Attributes, &pixelBufferOut))
      {
        uint64_t v14 = _ARLogGeneral();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf.data) = 0;
          uint64_t v15 = "Could not create pixelbuffer";
          p_vImage_Buffer buf = &buf;
LABEL_29:
          _os_log_impl(&dword_1B88A2000, v14, OS_LOG_TYPE_ERROR, v15, (uint8_t *)p_buf, 2u);
        }
LABEL_30:

        CVPixelBufferRelease(pixelBufferOut);
        CVPixelBufferRelease(v24);
        return 4294960636;
      }
      CVPixelBufferLockBaseAddress(a1, 0);
      CVPixelBufferLockBaseAddress(pixelBufferOut, 0);
      buf.data = CVPixelBufferGetBaseAddress(a1);
      buf.height = CVPixelBufferGetHeight(a1);
      buf.width = CVPixelBufferGetWidth(a1);
      buf.rowBytes = CVPixelBufferGetBytesPerRow(a1);
      dest.data = CVPixelBufferGetBaseAddress(pixelBufferOut);
      dest.height = CVPixelBufferGetHeight(pixelBufferOut);
      dest.width = CVPixelBufferGetWidth(pixelBufferOut);
      dest.rowBytes = CVPixelBufferGetBytesPerRow(pixelBufferOut);
      vImage_Error v17 = vImageRotate90_Planar8(&buf, &dest, v11, 0, 0);
      CVPixelBufferUnlockBaseAddress(a1, 0);
      CVPixelBufferUnlockBaseAddress(pixelBufferOut, 0);
      if (v17)
      {
        uint64_t v14 = _ARLogGeneral();
        if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
          goto LABEL_30;
        }
        LOWORD(v21.data) = 0;
        uint64_t v15 = "Could not rotate pixelbuffer";
LABEL_28:
        p_vImage_Buffer buf = &v21;
        goto LABEL_29;
      }
      if (a2 <= 7 && ((1 << a2) & 0xB4) != 0)
      {
        if (CVPixelBufferCreate(v13, Width, Height, 0x4C303038u, Attributes, &v24))
        {
          uint64_t v14 = _ARLogGeneral();
          if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
            goto LABEL_30;
          }
          LOWORD(v21.data) = 0;
          uint64_t v15 = "Could not create pixelbuffer";
          goto LABEL_28;
        }
        CVPixelBufferLockBaseAddress(pixelBufferOut, 0);
        CVPixelBufferLockBaseAddress(v24, 0);
        v21.data = CVPixelBufferGetBaseAddress(v24);
        v21.height = CVPixelBufferGetHeight(v24);
        v21.width = CVPixelBufferGetWidth(v24);
        v21.rowBytes = CVPixelBufferGetBytesPerRow(v24);
        vImage_Error v18 = vImageHorizontalReflect_Planar8(&dest, &v21, 0);
        CVPixelBufferUnlockBaseAddress(pixelBufferOut, 0);
        CVPixelBufferUnlockBaseAddress(v24, 0);
        if (v18)
        {
          uint64_t v14 = _ARLogGeneral();
          if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
            goto LABEL_30;
          }
          __int16 v20 = 0;
          uint64_t v15 = "Could not mirror pixelbuffer";
          p_vImage_Buffer buf = (vImage_Buffer *)&v20;
          goto LABEL_29;
        }
        uint64_t v19 = pixelBufferOut;
        *a3 = v24;
        CVPixelBufferRelease(v19);
      }
      else
      {
        *a3 = pixelBufferOut;
      }
      return 0;
    }
    size_t v8 = _ARLogGeneral();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.data) = 0;
      _os_log_impl(&dword_1B88A2000, v8, OS_LOG_TYPE_ERROR, "Input pixel buffer must have format kCVPixelFormatType_OneComponent8", (uint8_t *)&buf, 2u);
    }

    return 4294960616;
  }
  else
  {
    uint64_t v7 = _ARLogGeneral();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.data) = 0;
      _os_log_impl(&dword_1B88A2000, v7, OS_LOG_TYPE_ERROR, "Input pixel buffer cannot be NULL", (uint8_t *)&buf, 2u);
    }

    return 4294960635;
  }
}

id _getAttributes(void)
{
  v4[2] = *MEMORY[0x1E4F143B8];
  uint64_t v0 = *MEMORY[0x1E4F24D20];
  v3[0] = *MEMORY[0x1E4F24D28];
  v3[1] = v0;
  v4[0] = MEMORY[0x1E4F1CC38];
  v4[1] = MEMORY[0x1E4F1CC08];
  uint64_t v1 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v4 forKeys:v3 count:2];
  return v1;
}

uint64_t ARCreateDownScaledGrayscaleImageAndMask(void *a1, size_t a2, void *a3, CVPixelBufferRef *a4, CVPixelBufferRef *a5)
{
  id v8 = a1;
  id v9 = a3;
  id v10 = objc_alloc_init(MEMORY[0x1E4F1E018]);
  CVPixelBufferRef pixelBufferOut = 0;
  CVPixelBufferRef v44 = 0;
  CVPixelBufferRef texture = 0;
  [v8 extent];
  double v12 = v11;
  [v8 extent];
  double v14 = v13;
  objc_msgSend(NSString, "stringWithFormat:", @"arkit/%s; %@; 1/1",
    "ARCreateDownScaledGrayscaleImageAndMask",
  uint64_t v15 = v9);
  CFDictionaryRef Attributes = (const __CFDictionary *)_getAttributes();
  CFAllocatorRef v17 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (!CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (unint64_t)v12, (unint64_t)v14, 0x4C303038u, Attributes, &pixelBufferOut))
  {
    [v10 render:v8 toCVPixelBuffer:pixelBufferOut];
    if (pixelBufferOut)
    {
      buf.data = 0;
      if (!ARScalePixelBufferMaxDimensionToNewDimension(pixelBufferOut, a2, (__CVBuffer **)&buf))
      {
        CVPixelBufferRelease(pixelBufferOut);
        CVPixelBufferRef pixelBufferOut = (CVPixelBufferRef)buf.data;
        if (a5) {
          goto LABEL_14;
        }
        goto LABEL_18;
      }
      id v36 = v9;
      id v23 = v10;
      CVPixelBufferRef v24 = v15;
      unint64_t v25 = a5;
      uint64_t v26 = a4;
      float32x4_t v27 = _ARLogGeneral();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v40.data) = 0;
        _os_log_impl(&dword_1B88A2000, v27, OS_LOG_TYPE_ERROR, "Error: Could not downscale pixelbuffer", (uint8_t *)&v40, 2u);
      }

      a4 = v26;
      a5 = v25;
      uint64_t v15 = v24;
      id v10 = v23;
      id v9 = v36;
    }
    if (a5)
    {
LABEL_14:
      if (CVPixelBufferCreate(v17, (unint64_t)v12, (unint64_t)v14, 0x20u, Attributes, &v44))
      {
        vImage_Error v18 = _ARLogGeneral();
        if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
          goto LABEL_6;
        }
        LOWORD(buf.data) = 0;
        uint64_t v19 = "Could not create pixelbuffer";
        goto LABEL_4;
      }
      [v10 render:v8 toCVPixelBuffer:v44];
      if (CVPixelBufferCreate(v17, (unint64_t)v12, (unint64_t)v14, 0x4C303038u, Attributes, &texture))
      {
        vImage_Error v18 = _ARLogGeneral();
        if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
          goto LABEL_6;
        }
        LOWORD(buf.data) = 0;
        uint64_t v19 = "Could not create pixelbuffer";
        goto LABEL_4;
      }
      CVPixelBufferLockBaseAddress(v44, 0);
      CVPixelBufferLockBaseAddress(texture, 0);
      memset(&buf, 0, sizeof(buf));
      buf.data = CVPixelBufferGetBaseAddress(v44);
      buf.height = CVPixelBufferGetHeight(v44);
      buf.width = CVPixelBufferGetWidth(v44);
      buf.rowBytes = CVPixelBufferGetBytesPerRow(v44);
      memset(&v40, 0, sizeof(v40));
      v40.data = CVPixelBufferGetBaseAddress(texture);
      v40.height = CVPixelBufferGetHeight(texture);
      v40.width = CVPixelBufferGetWidth(texture);
      v40.rowBytes = CVPixelBufferGetBytesPerRow(texture);
      vImage_Error v30 = vImageExtractChannel_ARGB8888(&buf, &v40, 0, 0);
      CVPixelBufferUnlockBaseAddress(v44, 0);
      CVPixelBufferUnlockBaseAddress(texture, 0);
      if (v30)
      {
        vImage_Error v18 = _ARLogGeneral();
        if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
          goto LABEL_6;
        }
        LOWORD(v39[0]) = 0;
        uint64_t v19 = "Could not extract alpha channel from image";
        p_vImage_Buffer buf = (uint8_t *)v39;
        goto LABEL_5;
      }
      CVPixelBufferRelease(v44);
      if (texture)
      {
        v39[0] = 0;
        if (ARScalePixelBufferMaxDimensionToNewDimension(texture, a2, v39))
        {
          long long v31 = _ARLogGeneral();
          if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)float32x4_t v38 = 0;
            _os_log_impl(&dword_1B88A2000, v31, OS_LOG_TYPE_ERROR, "Error: Could not downscale alpha mask", v38, 2u);
          }

          CVPixelBufferRef v32 = texture;
        }
        else
        {
          CVPixelBufferRelease(texture);
          CVPixelBufferRef v32 = v39[0];
          CVPixelBufferRef texture = v39[0];
        }
      }
      else
      {
        CVPixelBufferRef v32 = 0;
      }
      *a5 = v32;
      *a4 = pixelBufferOut;
      IOSurface = CVPixelBufferGetIOSurface(*a5);
      CFStringRef v34 = (const __CFString *)*MEMORY[0x1E4F2F128];
      IOSurfaceSetValue(IOSurface, (CFStringRef)*MEMORY[0x1E4F2F128], v15);
      float32x4_t v35 = CVPixelBufferGetIOSurface(*a4);
      IOSurfaceSetValue(v35, v34, v15);
LABEL_19:
      uint64_t v21 = 0;
      goto LABEL_7;
    }
LABEL_18:
    uint64_t v28 = pixelBufferOut;
    *a4 = pixelBufferOut;
    float32x4_t v29 = CVPixelBufferGetIOSurface(v28);
    IOSurfaceSetValue(v29, (CFStringRef)*MEMORY[0x1E4F2F128], v15);
    goto LABEL_19;
  }
  vImage_Error v18 = _ARLogGeneral();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.data) = 0;
    uint64_t v19 = "Could not create pixelbuffer";
LABEL_4:
    p_vImage_Buffer buf = (uint8_t *)&buf;
LABEL_5:
    _os_log_impl(&dword_1B88A2000, v18, OS_LOG_TYPE_ERROR, v19, p_buf, 2u);
  }
LABEL_6:

  CVPixelBufferRelease(v44);
  CVPixelBufferRelease(pixelBufferOut);
  CVPixelBufferRelease(texture);
  uint64_t v21 = 4294960636;
LABEL_7:

  return v21;
}

void sub_1B88BBB14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ARScalePixelBufferMaxDimensionToNewDimension(__CVBuffer *a1, size_t a2, __CVBuffer **a3)
{
  if (CVPixelBufferGetPixelFormatType(a1) == 1278226488)
  {
    size_t Width = CVPixelBufferGetWidth(a1);
    size_t Height = CVPixelBufferGetHeight(a1);
    if (Width <= Height) {
      size_t v8 = Height;
    }
    else {
      size_t v8 = Width;
    }
    if (v8 <= a2)
    {
      size_t v10 = Height;
      a2 = Width;
    }
    else
    {
      float v9 = (float)a2;
      if (Width <= Height)
      {
        size_t v10 = a2;
        a2 = (unint64_t)(float)((float)(v9 / (float)Height) * (float)Width);
      }
      else
      {
        size_t v10 = (unint64_t)(float)((float)(v9 / (float)Width) * (float)Height);
      }
    }
    if (a2 == Width && v10 == Height)
    {
      *a3 = a1;
      CVPixelBufferRetain(a1);
      return 0;
    }
    else
    {
      CFDictionaryRef Attributes = (const __CFDictionary *)_getAttributes();
      CVPixelBufferRef pixelBufferOut = 0;
      if (CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, v10, 0x4C303038u, Attributes, &pixelBufferOut))
      {
        double v14 = _ARLogGeneral();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf.data) = 0;
          _os_log_impl(&dword_1B88A2000, v14, OS_LOG_TYPE_ERROR, "Could not create pixelbuffer", (uint8_t *)&buf, 2u);
        }

        return 4294960634;
      }
      else
      {
        CVPixelBufferLockBaseAddress(a1, 0);
        CVPixelBufferLockBaseAddress(pixelBufferOut, 0);
        buf.data = CVPixelBufferGetBaseAddress(a1);
        buf.height = CVPixelBufferGetHeight(a1);
        buf.width = CVPixelBufferGetWidth(a1);
        buf.rowBytes = CVPixelBufferGetBytesPerRow(a1);
        dest.data = CVPixelBufferGetBaseAddress(pixelBufferOut);
        dest.height = CVPixelBufferGetHeight(pixelBufferOut);
        dest.width = CVPixelBufferGetWidth(pixelBufferOut);
        dest.rowBytes = CVPixelBufferGetBytesPerRow(pixelBufferOut);
        if (vImageScale_Planar8(&buf, &dest, 0, 0x20u))
        {
          uint64_t v15 = _ARLogGeneral();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)unint64_t v16 = 0;
            _os_log_impl(&dword_1B88A2000, v15, OS_LOG_TYPE_ERROR, "Could not scale pixelbuffer", v16, 2u);
          }

          CVPixelBufferUnlockBaseAddress(a1, 0);
          CVPixelBufferUnlockBaseAddress(pixelBufferOut, 0);
          CVPixelBufferRelease(pixelBufferOut);
          return 4294960636;
        }
        else
        {
          CVPixelBufferUnlockBaseAddress(a1, 0);
          CVPixelBufferUnlockBaseAddress(pixelBufferOut, 0);
          uint64_t result = 0;
          *a3 = pixelBufferOut;
        }
      }
    }
  }
  else
  {
    double v11 = _ARLogGeneral();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.data) = 0;
      _os_log_impl(&dword_1B88A2000, v11, OS_LOG_TYPE_ERROR, "Pixelbuffer must have format kCVPixelFormatType_OneComponent8", (uint8_t *)&buf, 2u);
    }

    return 4294960616;
  }
  return result;
}

CVPixelBufferRef ARPixelBufferWithCIImage(void *a1)
{
  v12[1] = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  unint64_t v2 = [MEMORY[0x1E4F1E018] context];
  CVPixelBufferRef v10 = 0;
  [v1 extent];
  double v4 = v3;
  [v1 extent];
  double v6 = v5;
  uint64_t v11 = *MEMORY[0x1E4F24D20];
  v12[0] = MEMORY[0x1E4F1CC08];
  CFDictionaryRef v7 = (const __CFDictionary *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v12 forKeys:&v11 count:1];
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (unint64_t)v4, (unint64_t)v6, 0x34323066u, v7, &v10);
  [v2 render:v1 toCVPixelBuffer:v10];
  CVPixelBufferRef v8 = v10;

  return v8;
}

void sub_1B88BBF40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ARCreatePixelBufferWithPaddingToFillMinimumDimension(__CVBuffer *a1, size_t a2, Pixel_8 a3, __CVBuffer **a4)
{
  if (CVPixelBufferGetPixelFormatType(a1) == 1278226488)
  {
    size_t Width = CVPixelBufferGetWidth(a1);
    size_t Height = CVPixelBufferGetHeight(a1);
    if (Width >= a2 && Height >= a2)
    {
      *a4 = a1;
      CVPixelBufferRetain(a1);
      return 0;
    }
    if (Width <= a2) {
      size_t Width = a2;
    }
    if (Height > a2) {
      a2 = Height;
    }
    CVPixelBufferRef pixelBufferOut = 0;
    CFDictionaryRef Attributes = (const __CFDictionary *)_getAttributes();
    if (CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Width, a2, 0x4C303038u, Attributes, &pixelBufferOut))
    {
      double v13 = _ARLogGeneral();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf.data) = 0;
        double v14 = "Error: Could not create mask";
        p_vImage_Buffer buf = (uint8_t *)&buf;
LABEL_22:
        _os_log_impl(&dword_1B88A2000, v13, OS_LOG_TYPE_ERROR, v14, p_buf, 2u);
      }
LABEL_23:

      CVPixelBufferUnlockBaseAddress(pixelBufferOut, 0);
      CVPixelBufferUnlockBaseAddress(a1, 0);
      CVPixelBufferRelease(pixelBufferOut);
      return 4294960636;
    }
    CVPixelBufferLockBaseAddress(pixelBufferOut, 0);
    CVPixelBufferLockBaseAddress(a1, 0);
    buf.data = CVPixelBufferGetBaseAddress(pixelBufferOut);
    buf.height = CVPixelBufferGetHeight(pixelBufferOut);
    buf.width = CVPixelBufferGetWidth(pixelBufferOut);
    buf.rowBytes = CVPixelBufferGetBytesPerRow(pixelBufferOut);
    src.data = CVPixelBufferGetBaseAddress(a1);
    src.height = CVPixelBufferGetHeight(a1);
    src.width = CVPixelBufferGetWidth(a1);
    src.rowBytes = CVPixelBufferGetBytesPerRow(a1);
    dest.data = buf.data;
    dest.height = src.height;
    dest.width = src.width;
    dest.rowBytes = buf.rowBytes;
    if (vImageOverwriteChannelsWithScalar_Planar8(a3, &buf, 0))
    {
      double v13 = _ARLogGeneral();
      if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        goto LABEL_23;
      }
      __int16 v16 = 0;
      double v14 = "Error: Could not fill buffer";
    }
    else
    {
      if (!vImageCopyBuffer(&src, &dest, 1uLL, 0))
      {
        CVPixelBufferUnlockBaseAddress(pixelBufferOut, 0);
        CVPixelBufferUnlockBaseAddress(a1, 0);
        uint64_t result = 0;
        *a4 = pixelBufferOut;
        return result;
      }
      double v13 = _ARLogGeneral();
      if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        goto LABEL_23;
      }
      __int16 v16 = 0;
      double v14 = "Error: Could not copy buffer";
    }
    p_vImage_Buffer buf = (uint8_t *)&v16;
    goto LABEL_22;
  }
  uint64_t v11 = _ARLogGeneral();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.data) = 0;
    _os_log_impl(&dword_1B88A2000, v11, OS_LOG_TYPE_ERROR, "Pixelbuffer must have format kCVPixelFormatType_OneComponent8", (uint8_t *)&buf, 2u);
  }

  return 4294960616;
}

uint64_t ARCreateSynchronizationMarker(size_t width, size_t height, CVPixelBufferRef *a3)
{
  CVPixelBufferRef pixelBufferOut = 0;
  if (CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], width, height, 0x4C303038u, 0, &pixelBufferOut)) {
    return 4294960636;
  }
  CVPixelBufferLockBaseAddress(pixelBufferOut, 0);
  dest.data = CVPixelBufferGetBaseAddress(pixelBufferOut);
  dest.height = CVPixelBufferGetHeight(pixelBufferOut);
  dest.width = CVPixelBufferGetWidth(pixelBufferOut);
  dest.rowBytes = CVPixelBufferGetBytesPerRow(pixelBufferOut);
  if (vImageOverwriteChannelsWithScalar_Planar8(0, &dest, 0x200u)
    || ((vImagePixelCount v4 = dest.height >> 1, ((dest.height >> 1) & 0x80000000) == 0) ? (v5 = dest.height >> 1) : (v5 = v4 + 1),
        v22.data = (char *)dest.data + (v4 - (v5 >> 1)) * dest.rowBytes - (v5 >> 1) + (dest.width >> 1),
        v22.height = (int)((uint64_t)dest.height >> 1),
        v22.width = v22.height,
        v22.rowBytes = dest.rowBytes,
        vImageOverwriteChannelsWithScalar_Planar8(0xFFu, &v22, 0x200u)))
  {
    CVPixelBufferUnlockBaseAddress(pixelBufferOut, 0);
    CVPixelBufferRelease(pixelBufferOut);
    return 4294960636;
  }
  vImagePixelCount v8 = v22.height;
  vImagePixelCount v7 = v22.width;
  if (SLODWORD(v22.width) >= 0) {
    int v9 = v22.width;
  }
  else {
    int v9 = LODWORD(v22.width) + 1;
  }
  if (SLODWORD(v22.height) >= 0) {
    int v10 = v22.height;
  }
  else {
    int v10 = LODWORD(v22.height) + 1;
  }
  if ((v4 & 0x80000000) == 0) {
    int v11 = v4;
  }
  else {
    int v11 = v4 + 3;
  }
  if (v22.height)
  {
    vImagePixelCount v12 = 0;
    data = v22.data;
    int v14 = v9 >> 1;
    unsigned int v15 = v14 * v14;
    unsigned int v16 = (v11 >> 2) * (v11 >> 2);
    int v17 = -v14;
    int v18 = -(v10 >> 1);
    do
    {
      if (v7)
      {
        vImagePixelCount v19 = 0;
        size_t v20 = (size_t)data + v22.rowBytes * v12;
        do
        {
          unsigned int v21 = (v18 + v12) * (v18 + v12) + (v17 + v19) * (v17 + v19);
          if (v21 < v15) {
            *(unsigned char *)(v20 + v19) = 85;
          }
          if (v21 < v16) {
            *(unsigned char *)(v20 + v19) = -86;
          }
          ++v19;
          vImagePixelCount v7 = v22.width;
        }
        while (v22.width > v19);
        vImagePixelCount v8 = v22.height;
      }
      ++v12;
    }
    while (v8 > v12);
  }
  CVPixelBufferUnlockBaseAddress(pixelBufferOut, 0);
  uint64_t result = 0;
  *a3 = pixelBufferOut;
  return result;
}

size_t ARWrapCVPixelBufferVImage@<X0>(__CVBuffer *a1@<X0>, void **a2@<X8>)
{
  *a2 = CVPixelBufferGetBaseAddress(a1);
  a2[1] = (void *)CVPixelBufferGetHeight(a1);
  a2[2] = (void *)CVPixelBufferGetWidth(a1);
  size_t result = CVPixelBufferGetBytesPerRow(a1);
  a2[3] = (void *)result;
  return result;
}

size_t ARWrapCVPixelBufferPlaneVImage@<X0>(__CVBuffer *a1@<X0>, size_t a2@<X1>, void **a3@<X8>)
{
  *a3 = CVPixelBufferGetBaseAddressOfPlane(a1, a2);
  a3[1] = (void *)CVPixelBufferGetHeightOfPlane(a1, a2);
  a3[2] = (void *)CVPixelBufferGetWidthOfPlane(a1, a2);
  size_t result = CVPixelBufferGetBytesPerRowOfPlane(a1, a2);
  a3[3] = (void *)result;
  return result;
}

CVPixelBufferRef ARCreateCVPixelBufferFromPoolWithZeroCopyOption(CVPixelBufferPoolRef *a1, int a2, void *a3, void *a4, int a5, double a6, double a7)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  id v13 = a3;
  id v14 = a4;
  CVPixelBufferRef pixelBufferOut = 0;
  CVReturn v15 = ARRecreatePixelBufferPoolOnConfigurationChangesWithZeroCopyOption(a1, a2, a5, a6, a7);
  if (v15)
  {
    unsigned int v16 = _ARLogTechnique();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      int v17 = (objc_class *)objc_opt_class();
      int v18 = NSStringFromClass(v17);
      *(_DWORD *)vImage_Buffer buf = 138413058;
      uint64_t v28 = v18;
      __int16 v29 = 2048;
      id v30 = v13;
      __int16 v31 = 2112;
      id v32 = v14;
      __int16 v33 = 1024;
      CVReturn v34 = v15;
      _os_log_impl(&dword_1B88A2000, v16, OS_LOG_TYPE_ERROR, "%@(%p): Unable to configure pixelbuffer pool for %@: %i", buf, 0x26u);
    }
    CVPixelBufferRef v19 = 0;
  }
  else
  {
    CVReturn v20 = CVPixelBufferPoolCreatePixelBuffer((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *a1, &pixelBufferOut);
    if (v20)
    {
      unsigned int v21 = _ARLogTechnique();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        vImage_Buffer v22 = (objc_class *)objc_opt_class();
        id v23 = NSStringFromClass(v22);
        *(_DWORD *)vImage_Buffer buf = 138413058;
        uint64_t v28 = v23;
        __int16 v29 = 2048;
        id v30 = v13;
        __int16 v31 = 2112;
        id v32 = v14;
        __int16 v33 = 1024;
        CVReturn v34 = v20;
        _os_log_impl(&dword_1B88A2000, v21, OS_LOG_TYPE_ERROR, "%@(%p): Unable to create pixel buffer for %@: %i", buf, 0x26u);
      }
    }
    objc_msgSend(NSString, "stringWithFormat:", @"arkit/%s; %@; X/X",
      "ARCreateCVPixelBufferFromPoolWithZeroCopyOption",
    unsigned int v16 = v14);
    IOSurface = CVPixelBufferGetIOSurface(pixelBufferOut);
    IOSurfaceSetValue(IOSurface, (CFStringRef)*MEMORY[0x1E4F2F128], v16);
    CVPixelBufferRef v19 = pixelBufferOut;
  }

  return v19;
}

void sub_1B88BC70C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ARRecreatePixelBufferPoolOnConfigurationChangesWithZeroCopyOption(CVPixelBufferPoolRef *a1, int a2, int a3, double a4, double a5)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  int v10 = *a1;
  if (v10)
  {
    int v11 = CVPixelBufferPoolGetPixelBufferAttributes(v10);
    vImagePixelCount v12 = [v11 objectForKeyedSubscript:*MEMORY[0x1E4F24E10]];
    uint64_t v13 = [v12 integerValue];

    id v14 = [v11 objectForKeyedSubscript:*MEMORY[0x1E4F24D08]];
    uint64_t v15 = [v14 integerValue];

    unsigned int v16 = [v11 objectForKeyedSubscript:*MEMORY[0x1E4F24D70]];
    uint64_t v17 = [v16 integerValue];

    if (v13 == (int)a4 && v15 == (int)a5)
    {

      if (v17 == a2) {
        return 0;
      }
    }
    else
    {
    }
  }
  else
  {
    uint64_t v13 = 0;
    uint64_t v15 = 0;
    uint64_t v17 = 0;
  }
  CVPixelBufferRef v19 = _ARLogGeneral();
  if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
  {
    CVPixelBufferPoolRef v20 = *a1;
    int v23 = 134219520;
    CVPixelBufferPoolRef v24 = v20;
    __int16 v25 = 2048;
    uint64_t v26 = v13;
    __int16 v27 = 2048;
    uint64_t v28 = v15;
    __int16 v29 = 2048;
    uint64_t v30 = v17;
    __int16 v31 = 1024;
    int v32 = (int)a4;
    __int16 v33 = 1024;
    int v34 = (int)a5;
    __int16 v35 = 1024;
    int v36 = a2;
    _os_log_impl(&dword_1B88A2000, v19, OS_LOG_TYPE_INFO, "ARSystemTools: Recreating pixel buffer pool (%p) due to configuration changes: %li,%li/%li => %i,%i/%i", (uint8_t *)&v23, 0x3Cu);
  }

  if (*a1)
  {
    CVPixelBufferPoolRelease(*a1);
    *a1 = 0;
  }
  kdebug_trace();
  uint64_t NewWithZeroCopyOption = ar_pixelBufferPoolCreateNewWithZeroCopyOption((int)a4, (int)a5, a2, a1, a3);
  kdebug_trace();
  if (NewWithZeroCopyOption)
  {
    unsigned int v21 = _ARLogGeneral();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v23) = 0;
      _os_log_impl(&dword_1B88A2000, v21, OS_LOG_TYPE_ERROR, "ARSystemTools: Could not create pixel buffer pool.", (uint8_t *)&v23, 2u);
    }
  }
  return NewWithZeroCopyOption;
}

void sub_1B88BC9E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id _ARLogTechnique(void)
{
  if (_ARLogTechnique(void)::onceToken != -1) {
    dispatch_once(&_ARLogTechnique(void)::onceToken, &__block_literal_global_71);
  }
  uint64_t v0 = (void *)_ARLogTechnique(void)::logObj;
  return v0;
}

{
  void *v0;
  uint64_t vars8;

  if (_ARLogTechnique(void)::onceToken != -1) {
    dispatch_once(&_ARLogTechnique(void)::onceToken, &__block_literal_global_125);
  }
  uint64_t v0 = (void *)_ARLogTechnique(void)::logObj;
  return v0;
}

{
  void *v0;
  uint64_t vars8;

  if (_ARLogTechnique(void)::onceToken != -1) {
    dispatch_once(&_ARLogTechnique(void)::onceToken, &__block_literal_global_33);
  }
  uint64_t v0 = (void *)_ARLogTechnique(void)::logObj;
  return v0;
}

{
  void *v0;
  uint64_t vars8;

  if (_ARLogTechnique(void)::onceToken != -1) {
    dispatch_once(&_ARLogTechnique(void)::onceToken, &__block_literal_global_568);
  }
  uint64_t v0 = (void *)_ARLogTechnique(void)::logObj;
  return v0;
}

{
  void *v0;
  uint64_t vars8;

  if (_ARLogTechnique(void)::onceToken != -1) {
    dispatch_once(&_ARLogTechnique(void)::onceToken, &__block_literal_global_51);
  }
  uint64_t v0 = (void *)_ARLogTechnique(void)::logObj;
  return v0;
}

{
  void *v0;
  uint64_t vars8;

  if (_ARLogTechnique(void)::onceToken != -1) {
    dispatch_once(&_ARLogTechnique(void)::onceToken, &__block_literal_global_137);
  }
  uint64_t v0 = (void *)_ARLogTechnique(void)::logObj;
  return v0;
}

{
  void *v0;
  uint64_t vars8;

  if (_ARLogTechnique(void)::onceToken != -1) {
    dispatch_once(&_ARLogTechnique(void)::onceToken, &__block_literal_global_79);
  }
  uint64_t v0 = (void *)_ARLogTechnique(void)::logObj;
  return v0;
}

{
  void *v0;
  uint64_t vars8;

  if (_ARLogTechnique(void)::onceToken != -1) {
    dispatch_once(&_ARLogTechnique(void)::onceToken, &__block_literal_global_122_0);
  }
  uint64_t v0 = (void *)_ARLogTechnique(void)::logObj;
  return v0;
}

{
  void *v0;
  uint64_t vars8;

  if (_ARLogTechnique(void)::onceToken != -1) {
    dispatch_once(&_ARLogTechnique(void)::onceToken, &__block_literal_global_90);
  }
  uint64_t v0 = (void *)_ARLogTechnique(void)::logObj;
  return v0;
}

{
  void *v0;
  uint64_t vars8;

  if (_ARLogTechnique(void)::onceToken != -1) {
    dispatch_once(&_ARLogTechnique(void)::onceToken, &__block_literal_global_63);
  }
  uint64_t v0 = (void *)_ARLogTechnique(void)::logObj;
  return v0;
}

{
  void *v0;
  uint64_t vars8;

  if (_ARLogTechnique(void)::onceToken != -1) {
    dispatch_once(&_ARLogTechnique(void)::onceToken, &__block_literal_global_109);
  }
  uint64_t v0 = (void *)_ARLogTechnique(void)::logObj;
  return v0;
}

{
  void *v0;
  uint64_t vars8;

  if (_ARLogTechnique(void)::onceToken != -1) {
    dispatch_once(&_ARLogTechnique(void)::onceToken, &__block_literal_global_293);
  }
  uint64_t v0 = (void *)_ARLogTechnique(void)::logObj;
  return v0;
}

CVPixelBufferRef ARCreateCVPixelBufferFromPool(CVPixelBufferPoolRef *a1, int a2, void *a3, void *a4, double a5, double a6)
{
  return ARCreateCVPixelBufferFromPoolWithZeroCopyOption(a1, a2, a3, a4, 0, a5, a6);
}

double ARPixelBufferGetSensorCropRect(__CVBuffer *a1)
{
  long long v3 = *MEMORY[0x1E4F1DB28];
  if (a1)
  {
    id v1 = ARPixelBufferGetMetadata(a1);
    FigCFDictionaryGetCGRectIfPresent();
  }
  return *(double *)&v3;
}

void sub_1B88BCADC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id ARPixelBufferGetMetadata(__CVBuffer *a1)
{
  CFDictionaryRef v1 = CVBufferCopyAttachments(a1, kCVAttachmentMode_ShouldPropagate);
  unint64_t v2 = [(__CFDictionary *)v1 valueForKey:*MEMORY[0x1E4F51480]];

  return v2;
}

void sub_1B88BCB44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ARPixelBufferConvertYCbCrToARGB(__CVBuffer *a1, CVPixelBufferRef *a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    OSType PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
    int Width = CVPixelBufferGetWidth(a1);
    int Height = CVPixelBufferGetHeight(a1);
    OSType v7 = CVPixelBufferGetPixelFormatType(*a2);
    int v8 = CVPixelBufferGetWidth(*a2);
    int v9 = CVPixelBufferGetHeight(*a2);
    if (v7 == 32)
    {
      if (v9 == Height && v8 == Width)
      {
        CVPixelBufferLockBaseAddress(*a2, 0);
        CVPixelBufferLockBaseAddress(a1, 0);
        vImagePixelCount v12 = (const vImage_YpCbCrToARGBMatrix *)*MEMORY[0x1E4F167D8];
        *(_DWORD *)permuteMap = 50462976;
        if ((PixelFormatType | 0x10) == 0x34323076)
        {
          v10.i32[0] = 875704422;
          v11.i32[0] = PixelFormatType;
          int8x8_t v13 = vbsl_s8((int8x8_t)vdup_lane_s32(vceq_s32(v11, v10), 0), (int8x8_t)0x1000000FFLL, (int8x8_t)0x10000000EBLL);
          pixelRange.Yp_bias = 16 * (PixelFormatType != 875704422);
          pixelRange.CbCr_bias = 128;
          pixelRange.YpRangeMax = v13.i32[0];
          if (PixelFormatType == 875704422) {
            int32_t v14 = 255;
          }
          else {
            int32_t v14 = 240;
          }
          pixelRange.CbCrRangeMax = v14;
          *(int8x8_t *)&pixelRange.YpMax = v13;
          pixelRange.CbCrMax = v14;
          pixelRange.CbCrMin = 16 * (PixelFormatType != 875704422);
          if (vImageConvert_YpCbCrToARGB_GenerateConversion(v12, &pixelRange, &outInfo, kvImage420Yp8_CbCr8, kvImageARGB8888, 0))
          {
            uint64_t v15 = _ARLogGeneral();
            if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
            {
              LOWORD(buf.data) = 0;
              _os_log_impl(&dword_1B88A2000, v15, OS_LOG_TYPE_ERROR, "Could not generate the conversion format", (uint8_t *)&buf, 2u);
            }
          }
          memset(&buf, 0, sizeof(buf));
          __ARPixelBufferConvertYCbCrToARGB_block_invoke(a1, 0, (uint64_t)&buf);
          memset(&srcCbCr, 0, sizeof(srcCbCr));
          __ARPixelBufferConvertYCbCrToARGB_block_invoke(a1, 1uLL, (uint64_t)&srcCbCr);
          memset(&dest, 0, sizeof(dest));
          __ARPixelBufferConvertYCbCrToARGB_block_invoke(*a2, 0, (uint64_t)&dest);
          if (!vImageConvert_420Yp8_CbCr8ToARGB8888(&buf, &srcCbCr, &dest, &outInfo, permuteMap, 0xFFu, 0))
          {
            uint64_t v18 = 0;
            goto LABEL_32;
          }
          unsigned int v16 = _ARLogGeneral();
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)unsigned int v21 = 0;
            _os_log_impl(&dword_1B88A2000, v16, OS_LOG_TYPE_ERROR, "Could not convert color formats", v21, 2u);
          }
        }
        else
        {
          CVPixelBufferPoolRef v20 = _ARLogGeneral();
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)outInfo.opaque = 0;
            _os_log_impl(&dword_1B88A2000, v20, OS_LOG_TYPE_ERROR, "Pixel format not supported", outInfo.opaque, 2u);
          }
        }
        uint64_t v18 = 4294960636;
LABEL_32:
        CVPixelBufferUnlockBaseAddress(*a2, 0);
        CVPixelBufferUnlockBaseAddress(a1, 0);
        return v18;
      }
      uint64_t v17 = _ARLogGeneral();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)outInfo.opaque = 0;
        _os_log_impl(&dword_1B88A2000, v17, OS_LOG_TYPE_ERROR, "Output pixel buffer must have same dimensions as input pixel buffer", outInfo.opaque, 2u);
      }
    }
    else
    {
      uint64_t v17 = _ARLogGeneral();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)outInfo.opaque = 0;
        _os_log_impl(&dword_1B88A2000, v17, OS_LOG_TYPE_ERROR, "Output pixel buffer must have format kCVPixelFormatType_32ARGB", outInfo.opaque, 2u);
      }
    }
  }
  else
  {
    uint64_t v17 = _ARLogGeneral();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)outInfo.opaque = 0;
      _os_log_impl(&dword_1B88A2000, v17, OS_LOG_TYPE_ERROR, "Input buffer cannot be null", outInfo.opaque, 2u);
    }
  }

  return 4294960635;
}

size_t __ARPixelBufferConvertYCbCrToARGB_block_invoke@<X0>(CVPixelBufferRef pixelBuffer@<X1>, size_t planeIndex@<X2>, uint64_t a3@<X8>)
{
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(void *)a3 = CVPixelBufferGetBaseAddressOfPlane(pixelBuffer, planeIndex);
  *(void *)(a3 + 8) = CVPixelBufferGetHeightOfPlane(pixelBuffer, planeIndex);
  *(void *)(a3 + 16) = CVPixelBufferGetWidthOfPlane(pixelBuffer, planeIndex);
  size_t result = CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, planeIndex);
  *(void *)(a3 + 24) = result;
  return result;
}

CVPixelBufferRef ARCreatePixelBufferWithConversion(__CVBuffer *a1, OSType a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v17 = 0;
  uint64_t v18 = &v17;
  uint64_t v19 = 0x2020000000;
  VTPixelTransferSessionRef v20 = 0;
  v13[0] = MEMORY[0x1E4F143A8];
  v13[1] = 3221225472;
  int32_t v14 = __ARCreatePixelBufferWithConversion_block_invoke;
  uint64_t v15 = &unk_1E6185330;
  unsigned int v16 = &v17;
  OSStatus v4 = VTPixelTransferSessionCreate(0, &v20);
  if (v4)
  {
    int v5 = _ARLogGeneral();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)vImage_Buffer buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v4;
      _os_log_impl(&dword_1B88A2000, v5, OS_LOG_TYPE_ERROR, "Could not create pixel transfer session. Error code: %d", buf, 8u);
    }
LABEL_4:

    goto LABEL_13;
  }
  *(void *)vImage_Buffer buf = 0;
  size_t Width = CVPixelBufferGetWidth(a1);
  size_t Height = CVPixelBufferGetHeight(a1);
  CVReturn v8 = CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Width, Height, a2, 0, (CVPixelBufferRef *)buf);
  if (v8)
  {
    int v5 = _ARLogGeneral();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)unsigned int v21 = 67109120;
      CVReturn v22 = v8;
      _os_log_impl(&dword_1B88A2000, v5, OS_LOG_TYPE_ERROR, "Could not create RGB24 pixel buffer. Error code: %d", v21, 8u);
    }
    goto LABEL_4;
  }
  OSStatus v9 = VTPixelTransferSessionTransferImage((VTPixelTransferSessionRef)v18[3], a1, *(CVPixelBufferRef *)buf);
  if (!v9)
  {
    CVPixelBufferRef v11 = *(CVPixelBufferRef *)buf;
    goto LABEL_14;
  }
  int32x2_t v10 = _ARLogGeneral();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)unsigned int v21 = 67109120;
    CVReturn v22 = v9;
    _os_log_impl(&dword_1B88A2000, v10, OS_LOG_TYPE_ERROR, "Could not transfer pixel buffer. Error code: %d", v21, 8u);
  }

  CVPixelBufferRelease(*(CVPixelBufferRef *)buf);
LABEL_13:
  CVPixelBufferRef v11 = 0;
LABEL_14:
  v14((uint64_t)v13);
  _Block_object_dispose(&v17, 8);
  return v11;
}

void sub_1B88BD1F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  double v6 = va_arg(va1, void (*)(uint64_t *));
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  v6((uint64_t *)va);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void __ARCreatePixelBufferWithConversion_block_invoke(uint64_t a1)
{
  CFDictionaryRef v1 = *(const void **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t ARPixelBufferConvertRGBAHalfTo128RGBAFloat(__CVBuffer *a1, CVPixelBufferRef *a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    int8x8_t v13 = _ARLogGeneral();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      LOWORD(src.data) = 0;
      _os_log_impl(&dword_1B88A2000, v13, OS_LOG_TYPE_ERROR, "Input buffer cannot be null", (uint8_t *)&src, 2u);
    }
    goto LABEL_21;
  }
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  int Width = CVPixelBufferGetWidth(a1);
  int Height = CVPixelBufferGetHeight(a1);
  OSType v7 = CVPixelBufferGetPixelFormatType(*a2);
  int v8 = CVPixelBufferGetWidth(*a2);
  int v9 = CVPixelBufferGetHeight(*a2);
  if (PixelFormatType != 1380411457)
  {
    int8x8_t v13 = _ARLogGeneral();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      LOWORD(src.data) = 0;
      _os_log_impl(&dword_1B88A2000, v13, OS_LOG_TYPE_ERROR, "Input pixel buffer must have format kCVPixelFormatType_64RGBAHalf", (uint8_t *)&src, 2u);
    }
    goto LABEL_21;
  }
  if (v7 != 1380410945)
  {
    int8x8_t v13 = _ARLogGeneral();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      LOWORD(src.data) = 0;
      _os_log_impl(&dword_1B88A2000, v13, OS_LOG_TYPE_ERROR, "Output pixel buffer must have format kCVPixelFormatType_128RGBAFloat", (uint8_t *)&src, 2u);
    }
    goto LABEL_21;
  }
  if (v9 != Height || v8 != Width)
  {
    int8x8_t v13 = _ARLogGeneral();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      LOWORD(src.data) = 0;
      _os_log_impl(&dword_1B88A2000, v13, OS_LOG_TYPE_ERROR, "Output pixel buffer must have same dimensions as input pixel buffer", (uint8_t *)&src, 2u);
    }
LABEL_21:

    return 4294960635;
  }
  CVPixelBufferLockBaseAddress(*a2, 0);
  CVPixelBufferLockBaseAddress(a1, 0);
  v17[0] = MEMORY[0x1E4F143A8];
  v17[1] = 3221225472;
  uint64_t v18 = __ARPixelBufferConvertRGBAHalfTo128RGBAFloat_block_invoke;
  uint64_t v19 = &__block_descriptor_48_e5_v8__0l;
  VTPixelTransferSessionRef v20 = a2;
  unsigned int v21 = a1;
  memset(&src, 0, sizeof(src));
  ARWrapCVPixelBufferVImage(a1, &src.data);
  memset(&v15, 0, sizeof(v15));
  ARWrapCVPixelBufferVImage(*a2, &v15.data);
  src.width *= 4;
  v15.width *= 4;
  vImage_Error v10 = vImageConvert_Planar16FtoPlanarF(&src, &v15, 0);
  if (v10)
  {
    CVPixelBufferRef v11 = _ARLogGeneral();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)vImage_Buffer buf = 134217984;
      vImage_Error v23 = v10;
      _os_log_impl(&dword_1B88A2000, v11, OS_LOG_TYPE_ERROR, "vImageConvert_Planar16FtoPlanarF error: %zd", buf, 0xCu);
    }

    uint64_t v12 = 4294960636;
  }
  else
  {
    uint64_t v12 = 0;
  }
  v18((uint64_t)v17);
  return v12;
}

void sub_1B88BD584(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, void (*a19)(char *))
{
}

uint64_t __ARPixelBufferConvertRGBAHalfTo128RGBAFloat_block_invoke(uint64_t a1)
{
  CVPixelBufferUnlockBaseAddress(**(CVPixelBufferRef **)(a1 + 32), 0);
  unint64_t v2 = *(__CVBuffer **)(a1 + 40);
  return CVPixelBufferUnlockBaseAddress(v2, 0);
}

uint64_t ARPixelBufferConvertTwoComponent16HalfToRGBAHalf(__CVBuffer *a1, CVPixelBufferRef *a2)
{
  if (!a1)
  {
    unsigned int v21 = _ARLogGeneral();
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    *(_WORD *)vImage_Buffer buf = 0;
    CVReturn v22 = "Input buffer cannot be null";
LABEL_20:
    _os_log_impl(&dword_1B88A2000, v21, OS_LOG_TYPE_ERROR, v22, buf, 2u);
    goto LABEL_21;
  }
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  unsigned int Width = CVPixelBufferGetWidth(a1);
  int Height = CVPixelBufferGetHeight(a1);
  OSType v7 = CVPixelBufferGetPixelFormatType(*a2);
  int v8 = CVPixelBufferGetWidth(*a2);
  int v9 = CVPixelBufferGetHeight(*a2);
  if (PixelFormatType != 843264104)
  {
    unsigned int v21 = _ARLogGeneral();
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    *(_WORD *)vImage_Buffer buf = 0;
    CVReturn v22 = "Input pixel buffer must have format kCVPixelFormatType_TwoComponent16Half";
    goto LABEL_20;
  }
  if (v7 != 1380411457)
  {
    unsigned int v21 = _ARLogGeneral();
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    *(_WORD *)vImage_Buffer buf = 0;
    CVReturn v22 = "Output pixel buffer must have format kCVPixelFormatType_64RGBAHalf";
    goto LABEL_20;
  }
  if (v9 != Height || v8 != Width)
  {
    unsigned int v21 = _ARLogGeneral();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)vImage_Buffer buf = 0;
      CVReturn v22 = "Output pixel buffer must have same dimensions as input pixel buffer";
      goto LABEL_20;
    }
LABEL_21:

    return 4294960635;
  }
  CVPixelBufferLockBaseAddress(a1, 0);
  CVPixelBufferLockBaseAddress(*a2, 0);
  v23[0] = MEMORY[0x1E4F143A8];
  v23[1] = 3221225472;
  uint64_t v24 = __ARPixelBufferConvertTwoComponent16HalfToRGBAHalf_block_invoke;
  __int16 v25 = &__block_descriptor_48_e5_v8__0l;
  uint64_t v26 = a1;
  __int16 v27 = a2;
  BaseAddress = (char *)CVPixelBufferGetBaseAddress(a1);
  size_t BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
  size_t v12 = CVPixelBufferGetBytesPerRow(*a2);
  int8x8_t v13 = (char *)CVPixelBufferGetBaseAddress(*a2);
  size_t DataSize = CVPixelBufferGetDataSize(*a2);
  bzero(v13, DataSize);
  if (Height)
  {
    uint64_t v15 = 0;
    do
    {
      unsigned int v16 = v13;
      uint64_t v17 = (int *)BaseAddress;
      uint64_t v18 = Width;
      if (Width)
      {
        do
        {
          int v19 = *v17++;
          _DWORD *v16 = v19;
          v16 += 2;
          --v18;
        }
        while (v18);
      }
      ++v15;
      BaseAddress += BytesPerRow;
      v13 += v12;
    }
    while (v15 != Height);
  }
  v24((uint64_t)v23);
  return 0;
}

void sub_1B88BD890(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void (*a11)(uint64_t *))
{
}

uint64_t __ARPixelBufferConvertTwoComponent16HalfToRGBAHalf_block_invoke(uint64_t a1)
{
  CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a1 + 32), 0);
  unint64_t v2 = **(__CVBuffer ***)(a1 + 40);
  return CVPixelBufferUnlockBaseAddress(v2, 0);
}

uint64_t ARPixelBufferConvertBGRAToARGB(__CVBuffer *a1, CVPixelBufferRef *a2)
{
  if (!a1)
  {
    CVReturn v22 = _ARLogGeneral();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    __int16 v28 = 0;
    vImage_Error v23 = "Input buffer cannot be null";
    uint64_t v24 = (uint8_t *)&v28;
LABEL_20:
    _os_log_impl(&dword_1B88A2000, v22, OS_LOG_TYPE_ERROR, v23, v24, 2u);
    goto LABEL_21;
  }
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  unsigned int Width = CVPixelBufferGetWidth(a1);
  int Height = CVPixelBufferGetHeight(a1);
  OSType v7 = CVPixelBufferGetPixelFormatType(*a2);
  int v8 = CVPixelBufferGetWidth(*a2);
  int v9 = CVPixelBufferGetHeight(*a2);
  if (PixelFormatType != 1111970369)
  {
    CVReturn v22 = _ARLogGeneral();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    __int16 v27 = 0;
    vImage_Error v23 = "Input pixel buffer must have format kCVPixelFormatType_32BGRA";
    uint64_t v24 = (uint8_t *)&v27;
    goto LABEL_20;
  }
  if (v7 != 32)
  {
    CVReturn v22 = _ARLogGeneral();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    __int16 v26 = 0;
    vImage_Error v23 = "Output pixel buffer must have format kCVPixelFormatType_32ARGB";
    uint64_t v24 = (uint8_t *)&v26;
    goto LABEL_20;
  }
  if (v9 != Height || v8 != Width)
  {
    CVReturn v22 = _ARLogGeneral();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      __int16 v25 = 0;
      vImage_Error v23 = "Output pixel buffer must have same dimensions as input pixel buffer";
      uint64_t v24 = (uint8_t *)&v25;
      goto LABEL_20;
    }
LABEL_21:

    return 4294960635;
  }
  CVPixelBufferLockBaseAddress(*a2, 0);
  CVPixelBufferLockBaseAddress(a1, 0);
  size_t BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
  size_t v11 = CVPixelBufferGetBytesPerRow(*a2);
  BaseAddress = (char *)CVPixelBufferGetBaseAddress(a1);
  int8x8_t v13 = (char *)CVPixelBufferGetBaseAddress(*a2);
  if (Height)
  {
    uint64_t v15 = 0;
    do
    {
      unsigned int v16 = v13;
      uint64_t v17 = (__int32 *)BaseAddress;
      uint64_t v18 = Width;
      if (Width)
      {
        do
        {
          __int32 v19 = *v17++;
          v14.i32[0] = v19;
          int16x8_t v20 = (int16x8_t)vmovl_u8(v14);
          *(int16x4_t *)v20.i8 = vrev64_s16(*(int16x4_t *)v20.i8);
          uint8x8_t v14 = (uint8x8_t)vmovn_s16(v20);
          *v16++ = v14.i32[0];
          --v18;
        }
        while (v18);
      }
      ++v15;
      BaseAddress += BytesPerRow;
      v13 += v11;
    }
    while (v15 != Height);
  }
  CVPixelBufferUnlockBaseAddress(*a2, 0);
  CVPixelBufferUnlockBaseAddress(a1, 0);
  return 0;
}

uint64_t AROSTypeFromMTLPixelFormat(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (a1 == 10) {
    return 1278226488;
  }
  for (uint64_t i = 0; ; i += 24)
  {
    uint64_t v4 = i + 24;
    if (i == 216) {
      break;
    }
    uint64_t v5 = *(void *)&FormatList[i + 32];
    if (v5 == a1) {
      return *(unsigned int *)&FormatList[v4];
    }
  }
  uint64_t v1 = 0;
  double v6 = _ARLogGeneral();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    int v8 = 134217984;
    uint64_t v9 = a1;
    _os_log_impl(&dword_1B88A2000, v6, OS_LOG_TYPE_ERROR, "MTLPixelFormat not supported %lu", (uint8_t *)&v8, 0xCu);
  }

  return v1;
}

uint64_t ARMTLPixelFormatFromOSType(unsigned int a1)
{
  uint64_t v2 = 0;
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  int v3 = 1278226488;
  do
  {
    if (v3 == a1) {
      return *(void *)&FormatList[v2 + 8];
    }
    int v3 = *(_DWORD *)&FormatList[v2 + 24];
    v2 += 24;
  }
  while (v2 != 240);
  uint64_t v4 = _ARLogGeneral();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    uint64_t v5 = AROSTypeToString(a1);
    int v7 = 138543362;
    int v8 = v5;
    _os_log_impl(&dword_1B88A2000, v4, OS_LOG_TYPE_ERROR, "OSType not supported %{public}@", (uint8_t *)&v7, 0xCu);
  }
  return 0;
}

void sub_1B88BDD44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id AROSTypeToString(unsigned int a1)
{
  *(void *)&v12[31] = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v1 = &v11;
    for (int i = 24; i != -8; i -= 8)
    {
      unsigned int v3 = a1 >> i;
      unsigned int v4 = (a1 >> i);
      if (v4 - 127 > 0xFFFFFFA0)
      {
        int v8 = v1 + 1;
      }
      else
      {
        unsigned int v3 = (a1 >> i) & 0xF;
        if (v4 >= 0xA0) {
          char v5 = 55;
        }
        else {
          char v5 = 48;
        }
        v1[1] = v5 + ((a1 >> i) >> 4);
        if (v3 >= 0xA) {
          char v6 = 55;
        }
        else {
          char v6 = 48;
        }
        char v7 = v6 + v3;
        int v8 = v1 + 3;
        v1[2] = v7;
        LOBYTE(v3) = 36;
      }
      *uint64_t v1 = v3;
      uint64_t v1 = v8;
    }
  }
  else
  {
    int v8 = v12;
    char v11 = 48;
  }
  *int v8 = 0;
  uint64_t v9 = [NSString stringWithUTF8String:&v11];
  return v9;
}

uint64_t ARBytesPerElement(unsigned int a1)
{
  uint64_t v2 = 0;
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  int v3 = 1278226488;
  do
  {
    if (v3 == a1) {
      return *(int *)&FormatList[v2 + 16];
    }
    int v3 = *(_DWORD *)&FormatList[v2 + 24];
    v2 += 24;
  }
  while (v2 != 240);
  unsigned int v4 = _ARLogGeneral();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    char v5 = AROSTypeToString(a1);
    int v7 = 138543362;
    int v8 = v5;
    _os_log_impl(&dword_1B88A2000, v4, OS_LOG_TYPE_ERROR, "OSType not supported %{public}@", (uint8_t *)&v7, 0xCu);
  }
  return 0;
}

void sub_1B88BDF48(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

__CFDictionary *ar_createAttributeDictionaryNewWithZeroCopyOption(unsigned int a1, unsigned int a2, int a3, int a4)
{
  unint64_t v19 = __PAIR64__(a1, a2);
  LODWORD(v18) = 16;
  HIDWORD(v18) = a3;
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    CFNumberRef v7 = CFNumberCreate(v5, kCFNumberIntType, (char *)&v18 + 4);
    if (!v7) {
      goto LABEL_9;
    }
    CFNumberRef v8 = v7;
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F24D70], v7);
    CFRelease(v8);
    CFMutableDictionaryRef v9 = CFDictionaryCreateMutable(v5, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (!v9) {
      goto LABEL_9;
    }
    CFMutableDictionaryRef v10 = v9;
    CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E4F24D20], v9);
    CFRelease(v10);
    CFNumberRef v11 = CFNumberCreate(v5, kCFNumberIntType, (char *)&v19 + 4);
    if (!v11) {
      goto LABEL_9;
    }
    CFNumberRef v12 = v11;
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F24E10], v11);
    CFRelease(v12);
    CFNumberRef v13 = CFNumberCreate(v5, kCFNumberIntType, &v19);
    if (!v13) {
      goto LABEL_9;
    }
    CFNumberRef v14 = v13;
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F24D08], v13);
    CFRelease(v14);
    CFNumberRef v15 = CFNumberCreate(v5, kCFNumberIntType, &v18);
    if (v15)
    {
      CFNumberRef v16 = v15;
      CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F24D78], v15);
      CFRelease(v16);
      if (a4) {
        CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F24C98], (const void *)objc_msgSend(NSNumber, "numberWithInt:", 64, v18, v19));
      }
    }
    else
    {
LABEL_9:
      CFRelease(Mutable);
      return 0;
    }
  }
  return Mutable;
}

__CFDictionary *ar_createAttributeDictionaryNew(unsigned int a1, unsigned int a2, int a3)
{
  return ar_createAttributeDictionaryNewWithZeroCopyOption(a1, a2, a3, 0);
}

uint64_t ar_pixelBufferPoolCreateNewWithZeroCopyOption(unsigned int a1, unsigned int a2, int a3, __CVPixelBufferPool **a4, int a5)
{
  AttributeDictionaryuint64_t NewWithZeroCopyOption = ar_createAttributeDictionaryNewWithZeroCopyOption(a1, a2, a3, a5);
  if (AttributeDictionaryNewWithZeroCopyOption)
  {
    CFNumberRef v7 = AttributeDictionaryNewWithZeroCopyOption;
    uint64_t v8 = CVPixelBufferPoolCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, AttributeDictionaryNewWithZeroCopyOption, a4);
    CFRelease(v7);
    if (!v8) {
      return v8;
    }
  }
  else
  {
    uint64_t v8 = 4294960636;
  }
  *a4 = 0;
  return v8;
}

uint64_t ar_pixelBufferPoolCreateNew(unsigned int a1, unsigned int a2, int a3, __CVPixelBufferPool **a4)
{
  return ar_pixelBufferPoolCreateNewWithZeroCopyOption(a1, a2, a3, a4, 0);
}

uint64_t ARRecreatePixelBufferPoolOnConfigurationChanges(CVPixelBufferPoolRef *a1, int a2, double a3, double a4)
{
  return ARRecreatePixelBufferPoolOnConfigurationChangesWithZeroCopyOption(a1, a2, 0, a3, a4);
}

id ARPixelBufferToDictionaryRepresentation(__CVBuffer *a1)
{
  v14[5] = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    size_t Width = CVPixelBufferGetWidth(a1);
    size_t Height = CVPixelBufferGetHeight(a1);
    uint64_t PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
    size_t BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
    CVPixelBufferLockBaseAddress(a1, 0);
    char v6 = [MEMORY[0x1E4F1C9B8] dataWithBytes:CVPixelBufferGetBaseAddress(a1) length:BytesPerRow * Height];
    CVPixelBufferUnlockBaseAddress(a1, 0);
    v14[0] = v6;
    v13[0] = @"ARPixelBufferData";
    v13[1] = @"ARPixelBufferWidth";
    CFNumberRef v7 = [NSNumber numberWithUnsignedLong:Width];
    v14[1] = v7;
    void v13[2] = @"ARPixelBufferHeight";
    uint64_t v8 = [NSNumber numberWithUnsignedLong:Height];
    v14[2] = v8;
    v13[3] = @"ARPixelBufferBytesPerRow";
    CFMutableDictionaryRef v9 = [NSNumber numberWithUnsignedLong:BytesPerRow];
    v14[3] = v9;
    v13[4] = @"ARPixelBufferFormat";
    CFMutableDictionaryRef v10 = [NSNumber numberWithUnsignedInt:PixelFormatType];
    v14[4] = v10;
    CFNumberRef v11 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v14 forKeys:v13 count:5];
  }
  else
  {
    CFNumberRef v11 = 0;
  }
  return v11;
}

void sub_1B88BE380(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ARPixelBufferFromDictionaryRepresentation(void *a1, CVPixelBufferRef *a2)
{
  id v3 = a1;
  unsigned int v4 = v3;
  uint64_t v5 = 4294960635;
  if (v3 && a2)
  {
    char v6 = [v3 objectForKeyedSubscript:@"ARPixelBufferWidth"];
    size_t v7 = [v6 unsignedIntegerValue];

    uint64_t v8 = [v4 objectForKeyedSubscript:@"ARPixelBufferHeight"];
    size_t v9 = [v8 unsignedIntegerValue];

    CFMutableDictionaryRef v10 = [v4 objectForKeyedSubscript:@"ARPixelBufferFormat"];
    OSType v11 = [v10 unsignedIntValue];

    CFNumberRef v12 = [v4 objectForKeyedSubscript:@"ARPixelBufferBytesPerRow"];
    size_t v13 = [v12 unsignedIntegerValue];

    CFNumberRef v14 = [v4 objectForKeyedSubscript:@"ARPixelBufferData"];
    CFNumberRef v15 = v14;
    if (v7 && v9 && v11 && v13 && v14) {
      uint64_t v5 = CVPixelBufferCreateWithBytes(0, v7, v9, v11, (void *)[v14 bytes], v13, 0, 0, 0, a2);
    }
  }
  return v5;
}

void sub_1B88BE52C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ARUnWrapOneComponent16BufferDepth32BitsBuffer(__CVBuffer *a1, __CVBuffer *a2)
{
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  OSType v5 = CVPixelBufferGetPixelFormatType(a2);
  if (PixelFormatType != 1278226742 || v5 != 1717855600)
  {
    CFNumberRef v16 = _ARLogGeneral();
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
      goto LABEL_17;
    }
    __int16 v25 = 0;
    uint64_t v17 = "Source buffer must have pixel format kCVPixelFormatType_OneComponent16 and destination buffer kCVPixelFormatTy"
          "pe_DepthFloat32.";
    uint64_t v18 = (uint8_t *)&v25;
LABEL_16:
    _os_log_impl(&dword_1B88A2000, v16, OS_LOG_TYPE_ERROR, v17, v18, 2u);
    goto LABEL_17;
  }
  size_t BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
  size_t Height = CVPixelBufferGetHeight(a1);
  size_t Width = CVPixelBufferGetWidth(a1);
  size_t v9 = CVPixelBufferGetBytesPerRow(a2);
  size_t v10 = CVPixelBufferGetHeight(a2);
  size_t v11 = CVPixelBufferGetWidth(a2);
  if (Height != v10)
  {
    CFNumberRef v16 = _ARLogGeneral();
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
      goto LABEL_17;
    }
    __int16 v24 = 0;
    uint64_t v17 = "Source buffer and destination buffer must have the same height";
    uint64_t v18 = (uint8_t *)&v24;
    goto LABEL_16;
  }
  size_t v12 = v11;
  if (Width != 2 * v11)
  {
    CFNumberRef v16 = _ARLogGeneral();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      __int16 v23 = 0;
      uint64_t v17 = "Source buffer must have double the width of the source buffer";
      uint64_t v18 = (uint8_t *)&v23;
      goto LABEL_16;
    }
LABEL_17:

    return 0;
  }
  CVPixelBufferLockBaseAddress(a1, 0);
  CVPixelBufferLockBaseAddress(a2, 0);
  BaseAddress = (char *)CVPixelBufferGetBaseAddress(a1);
  CFNumberRef v14 = (char *)CVPixelBufferGetBaseAddress(a2);
  if (BytesPerRow == v9)
  {
    if (Height)
    {
      uint64_t v15 = 0;
      do
      {
        memcpy(&v14[v15], &BaseAddress[v15], BytesPerRow);
        v15 += BytesPerRow;
        --Height;
      }
      while (Height);
    }
  }
  else if (Height)
  {
    for (uint64_t i = 0; i != Height; ++i)
    {
      if (v12)
      {
        uint64_t v21 = 0;
        size_t v22 = v12;
        do
        {
          *(_WORD *)&v14[v21] = *(_WORD *)&BaseAddress[i * BytesPerRow + (v21 & 0xFFFFFFFC)];
          v21 += 4;
          --v22;
        }
        while (v22);
      }
      v14 += v9;
    }
  }
  CVPixelBufferUnlockBaseAddress(a1, 0);
  CVPixelBufferUnlockBaseAddress(a2, 0);
  return 1;
}

uint64_t ARWrapDepth32BitsBufferOneComponent16Buffer(__CVBuffer *a1, __CVBuffer *a2)
{
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  OSType v5 = CVPixelBufferGetPixelFormatType(a2);
  if (PixelFormatType != 1717855600 || v5 != 1278226742)
  {
    CFNumberRef v16 = _ARLogGeneral();
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
      goto LABEL_17;
    }
    __int16 v25 = 0;
    uint64_t v17 = "Source buffer must have pixel format kCVPixelFormatType_DepthFloat32 and destination buffer kCVPixelFormatType_OneComponent16";
    uint64_t v18 = (uint8_t *)&v25;
LABEL_16:
    _os_log_impl(&dword_1B88A2000, v16, OS_LOG_TYPE_ERROR, v17, v18, 2u);
    goto LABEL_17;
  }
  size_t BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
  size_t Height = CVPixelBufferGetHeight(a1);
  size_t Width = CVPixelBufferGetWidth(a1);
  size_t v9 = CVPixelBufferGetBytesPerRow(a2);
  size_t v10 = CVPixelBufferGetHeight(a2);
  size_t v11 = CVPixelBufferGetWidth(a2);
  if (Height != v10)
  {
    CFNumberRef v16 = _ARLogGeneral();
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
      goto LABEL_17;
    }
    __int16 v24 = 0;
    uint64_t v17 = "Source buffer and destination buffer must have the same height";
    uint64_t v18 = (uint8_t *)&v24;
    goto LABEL_16;
  }
  if (v11 != 2 * Width)
  {
    CFNumberRef v16 = _ARLogGeneral();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      __int16 v23 = 0;
      uint64_t v17 = "Destination buffer must have double the width of the source buffer";
      uint64_t v18 = (uint8_t *)&v23;
      goto LABEL_16;
    }
LABEL_17:

    return 0;
  }
  CVPixelBufferLockBaseAddress(a1, 0);
  CVPixelBufferLockBaseAddress(a2, 0);
  BaseAddress = (char *)CVPixelBufferGetBaseAddress(a1);
  size_t v13 = (char *)CVPixelBufferGetBaseAddress(a2);
  CFNumberRef v14 = v13;
  if (v9 == BytesPerRow)
  {
    if (Height)
    {
      uint64_t v15 = 0;
      do
      {
        memcpy(&v14[v15], &BaseAddress[v15], BytesPerRow);
        v15 += BytesPerRow;
        --Height;
      }
      while (Height);
    }
  }
  else if (Height)
  {
    for (uint64_t i = 0; i != Height; ++i)
    {
      if (Width)
      {
        uint64_t v21 = 0;
        size_t v22 = Width;
        do
        {
          *(_DWORD *)&v13[i * v9 + (v21 & 0xFFFFFFFC)] = *(_DWORD *)&BaseAddress[v21];
          v21 += 4;
          --v22;
        }
        while (v22);
      }
      BaseAddress += BytesPerRow;
    }
  }
  CVPixelBufferUnlockBaseAddress(a2, 0);
  CVPixelBufferUnlockBaseAddress(a1, 0);
  return 1;
}

uint64_t ARWrapDepth32BitsBufferOneComponent8BufferWithScale(__CVBuffer *a1, __CVBuffer *a2, float a3)
{
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  OSType v7 = CVPixelBufferGetPixelFormatType(a2);
  if (PixelFormatType != 1717855600 || v7 != 1278226488)
  {
    size_t v22 = _ARLogGeneral();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      goto LABEL_18;
    }
    __int16 v27 = 0;
    __int16 v23 = "Source buffer must have pixel format kCVPixelFormatType_DepthFloat32 and destination buffer kCVPixelFormatType_OneComponent8";
    __int16 v24 = (uint8_t *)&v27;
LABEL_17:
    _os_log_impl(&dword_1B88A2000, v22, OS_LOG_TYPE_ERROR, v23, v24, 2u);
    goto LABEL_18;
  }
  size_t BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
  size_t Height = CVPixelBufferGetHeight(a1);
  size_t Width = CVPixelBufferGetWidth(a1);
  size_t v11 = CVPixelBufferGetBytesPerRow(a2);
  size_t v12 = CVPixelBufferGetHeight(a2);
  size_t v13 = CVPixelBufferGetWidth(a2);
  if (Height != v12)
  {
    size_t v22 = _ARLogGeneral();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      goto LABEL_18;
    }
    __int16 v26 = 0;
    __int16 v23 = "Source buffer and destination buffer must have the same height";
    __int16 v24 = (uint8_t *)&v26;
    goto LABEL_17;
  }
  if (Width != v13)
  {
    size_t v22 = _ARLogGeneral();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      __int16 v25 = 0;
      __int16 v23 = "Destination buffer must have the same width as the source buffer";
      __int16 v24 = (uint8_t *)&v25;
      goto LABEL_17;
    }
LABEL_18:

    return 0;
  }
  CVPixelBufferLockBaseAddress(a1, 0);
  CVPixelBufferLockBaseAddress(a2, 0);
  BaseAddress = (float *)CVPixelBufferGetBaseAddress(a1);
  uint64_t v15 = CVPixelBufferGetBaseAddress(a2);
  if (Height)
  {
    for (uint64_t i = 0; i != Height; ++i)
    {
      size_t v17 = Width;
      uint64_t v18 = v15;
      for (uint64_t j = BaseAddress; v17; --v17)
      {
        float v20 = *j++;
        *v18++ = (int)(float)(v20 * a3);
      }
      BaseAddress = (float *)((char *)BaseAddress + BytesPerRow);
      v15 += v11;
    }
  }
  CVPixelBufferUnlockBaseAddress(a2, 0);
  CVPixelBufferUnlockBaseAddress(a1, 0);
  return 1;
}

uint64_t ARWrapDepth32BitsBufferOneComponent16BufferWithScale(__CVBuffer *a1, __CVBuffer *a2, float a3)
{
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  OSType v7 = CVPixelBufferGetPixelFormatType(a2);
  if (PixelFormatType != 1717855600 || v7 != 1278226742 && v7 != 1647392359)
  {
    size_t v22 = _ARLogGeneral();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
LABEL_15:

      return 0;
    }
    *(_WORD *)vImage_Buffer buf = 0;
    __int16 v23 = "Source buffer must have pixel format kCVPixelFormatType_DepthFloat32 and destination buffer kCVPixelFormatType_OneComponent16";
    __int16 v24 = buf;
LABEL_14:
    _os_log_impl(&dword_1B88A2000, v22, OS_LOG_TYPE_ERROR, v23, v24, 2u);
    goto LABEL_15;
  }
  size_t BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
  size_t Height = CVPixelBufferGetHeight(a1);
  size_t Width = CVPixelBufferGetWidth(a1);
  size_t v11 = CVPixelBufferGetBytesPerRow(a2);
  size_t v12 = CVPixelBufferGetHeight(a2);
  size_t v13 = CVPixelBufferGetWidth(a2);
  if (Height != v12)
  {
    size_t v22 = _ARLogGeneral();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      goto LABEL_15;
    }
    __int16 v26 = 0;
    __int16 v23 = "Source buffer and destination buffer must have the same height";
    __int16 v24 = (uint8_t *)&v26;
    goto LABEL_14;
  }
  if (Width != v13)
  {
    size_t v22 = _ARLogGeneral();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      goto LABEL_15;
    }
    __int16 v25 = 0;
    __int16 v23 = "Destination buffer must have the same width as the source buffer";
    __int16 v24 = (uint8_t *)&v25;
    goto LABEL_14;
  }
  CVPixelBufferLockBaseAddress(a1, 0);
  CVPixelBufferLockBaseAddress(a2, 0);
  BaseAddress = (float *)CVPixelBufferGetBaseAddress(a1);
  uint64_t v15 = (char *)CVPixelBufferGetBaseAddress(a2);
  if (Height)
  {
    for (uint64_t i = 0; i != Height; ++i)
    {
      size_t v17 = Width;
      uint64_t v18 = BaseAddress;
      for (uint64_t j = v15; v17; --v17)
      {
        float v20 = *v18++;
        *j++ = (int)(float)(v20 * a3);
      }
      v15 += v11;
      BaseAddress = (float *)((char *)BaseAddress + BytesPerRow);
    }
  }
  CVPixelBufferUnlockBaseAddress(a2, 0);
  CVPixelBufferUnlockBaseAddress(a1, 0);
  return 1;
}

uint64_t ARWrapDepth32BitsBuffer_FixedPointUnsigned13_3_OneComponent16Buffer(__CVBuffer *a1, __CVBuffer *a2)
{
  return ARWrapDepth32BitsBufferOneComponent16BufferWithScale(a1, a2, 8000.0);
}

uint64_t ARConvertDepthFloatingPointBufferToFixedPointUnsigned13_3Buffer(__CVBuffer *a1, __CVBuffer *a2)
{
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  OSType v5 = CVPixelBufferGetPixelFormatType(a2);
  if (PixelFormatType != 1751410032 && PixelFormatType != 1717855600 || v5 != 825437747)
  {
    unint64_t v19 = _ARLogGeneral();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      __int16 v36 = 0;
      float v20 = "Source buffer must have either kCVPixelFormatType_DepthFloat16 or kCVPixelFormatType_DepthFloat32 pixel form"
            "at, destination buffer should have kCVPixelFormatType_FixedPointUnsigned13_3 pixel format";
      uint64_t v21 = (uint8_t *)&v36;
LABEL_15:
      _os_log_impl(&dword_1B88A2000, v19, OS_LOG_TYPE_ERROR, v20, v21, 2u);
    }
LABEL_16:

    return 0;
  }
  size_t BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
  size_t Height = CVPixelBufferGetHeight(a1);
  size_t Width = CVPixelBufferGetWidth(a1);
  size_t v9 = CVPixelBufferGetBytesPerRow(a2);
  size_t v10 = CVPixelBufferGetHeight(a2);
  size_t v11 = CVPixelBufferGetWidth(a2);
  if (PixelFormatType != 1717855600)
  {
    if (Height != v10)
    {
      unint64_t v19 = _ARLogGeneral();
      if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        goto LABEL_16;
      }
      __int16 v40 = 0;
      float v20 = "Source buffer and destination buffer must have the same height";
      uint64_t v21 = (uint8_t *)&v40;
      goto LABEL_15;
    }
    if (Width == v11)
    {
      CVPixelBufferLockBaseAddress(a1, 0);
      CVPixelBufferLockBaseAddress(a2, 0);
      BaseAddress = (char *)CVPixelBufferGetBaseAddress(a1);
      __int16 v24 = (char *)CVPixelBufferGetBaseAddress(a2);
      if (Height)
      {
        for (uint64_t i = 0; i != Height; ++i)
        {
          __int16 v26 = (__int16 *)BaseAddress;
          __int16 v27 = v24;
          for (size_t j = Width; j; --j)
          {
            __int16 v29 = *v26++;
            _H0 = v29;
            __asm { FCVT            S0, H0 }
            *v27++ = (int)(float)(_S0 * 8000.0);
          }
          v24 += v9;
          BaseAddress += BytesPerRow;
        }
      }
      goto LABEL_24;
    }
    unint64_t v19 = _ARLogGeneral();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      __int16 v39 = 0;
      float v20 = "Destination buffer must have the same width as the source buffer";
      uint64_t v21 = (uint8_t *)&v39;
      goto LABEL_15;
    }
    goto LABEL_16;
  }
  if (Height != v10)
  {
    unint64_t v19 = _ARLogGeneral();
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      goto LABEL_16;
    }
    __int16 v38 = 0;
    float v20 = "Source buffer and destination buffer must have the same height";
    uint64_t v21 = (uint8_t *)&v38;
    goto LABEL_15;
  }
  if (Width != v11)
  {
    unint64_t v19 = _ARLogGeneral();
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      goto LABEL_16;
    }
    __int16 v37 = 0;
    float v20 = "Destination buffer must have the same width as the source buffer";
    uint64_t v21 = (uint8_t *)&v37;
    goto LABEL_15;
  }
  CVPixelBufferLockBaseAddress(a1, 0);
  CVPixelBufferLockBaseAddress(a2, 0);
  size_t v12 = (float *)CVPixelBufferGetBaseAddress(a1);
  size_t v13 = (char *)CVPixelBufferGetBaseAddress(a2);
  if (Height)
  {
    for (uint64_t k = 0; k != Height; ++k)
    {
      uint64_t v15 = v12;
      CFNumberRef v16 = v13;
      for (size_t m = Width; m; --m)
      {
        float v18 = *v15++;
        *v16++ = (int)(float)(v18 * 8000.0);
      }
      v13 += v9;
      size_t v12 = (float *)((char *)v12 + BytesPerRow);
    }
  }
LABEL_24:
  CVPixelBufferUnlockBaseAddress(a2, 0);
  CVPixelBufferUnlockBaseAddress(a1, 0);
  return 1;
}

uint64_t ARUnWrapFixedPointUnsigned13_3_OneComponent16Buffer_Depth32BitsBuffer(__CVBuffer *a1, __CVBuffer *a2)
{
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  OSType v5 = CVPixelBufferGetPixelFormatType(a2);
  if (PixelFormatType != 825437747 && PixelFormatType != 1647392359 && PixelFormatType != 1278226742
    || v5 != 1717855600)
  {
    uint64_t v21 = _ARLogGeneral();
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      goto LABEL_20;
    }
    __int16 v26 = 0;
    size_t v22 = "Source buffer must have pixel format kCVPixelFormatType_OneComponent16, kCVPixelFormatType_FixedPointUnsigned1"
          "3_3, or kCVPixelFormatType_16Gray and destination buffer kCVPixelFormatType_DepthFloat32.";
    __int16 v23 = (uint8_t *)&v26;
LABEL_19:
    _os_log_impl(&dword_1B88A2000, v21, OS_LOG_TYPE_ERROR, v22, v23, 2u);
    goto LABEL_20;
  }
  size_t BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
  size_t Height = CVPixelBufferGetHeight(a1);
  size_t Width = CVPixelBufferGetWidth(a1);
  size_t v9 = CVPixelBufferGetBytesPerRow(a2);
  size_t v10 = CVPixelBufferGetHeight(a2);
  size_t v11 = CVPixelBufferGetWidth(a2);
  if (Height != v10)
  {
    uint64_t v21 = _ARLogGeneral();
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      goto LABEL_20;
    }
    __int16 v25 = 0;
    size_t v22 = "Source buffer and destination buffer must have the same height";
    __int16 v23 = (uint8_t *)&v25;
    goto LABEL_19;
  }
  if (Width != v11)
  {
    uint64_t v21 = _ARLogGeneral();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      __int16 v24 = 0;
      size_t v22 = "Source buffer must have the same width of the source buffer";
      __int16 v23 = (uint8_t *)&v24;
      goto LABEL_19;
    }
LABEL_20:

    return 0;
  }
  CVPixelBufferLockBaseAddress(a1, 0);
  CVPixelBufferLockBaseAddress(a2, 0);
  BaseAddress = (unsigned __int16 *)CVPixelBufferGetBaseAddress(a1);
  size_t v13 = (float *)CVPixelBufferGetBaseAddress(a2);
  if (Height)
  {
    for (uint64_t i = 0; i != Height; ++i)
    {
      size_t v15 = Width;
      CFNumberRef v16 = BaseAddress;
      for (size_t j = v13; v15; --v15)
      {
        unsigned int v18 = *v16++;
        float v19 = (double)v18 * 0.000125;
        *j++ = v19;
      }
      size_t v13 = (float *)((char *)v13 + v9);
      BaseAddress = (unsigned __int16 *)((char *)BaseAddress + BytesPerRow);
    }
  }
  CVPixelBufferUnlockBaseAddress(a1, 0);
  CVPixelBufferUnlockBaseAddress(a2, 0);
  return 1;
}

uint64_t ARConvertFixedPointUnsigned13_3ToDepthFloat32Buffer(__CVBuffer *a1, __CVBuffer *a2)
{
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  OSType v5 = CVPixelBufferGetPixelFormatType(a2);
  if (PixelFormatType != 825437747 || v5 != 1717855600)
  {
    uint64_t v21 = _ARLogGeneral();
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      goto LABEL_18;
    }
    __int16 v26 = 0;
    size_t v22 = "Source buffer must have pixel format kCVPixelFormatType_FixedPointUnsigned13_3 and destination buffer kCVPixel"
          "FormatType_DepthFloat32.";
    __int16 v23 = (uint8_t *)&v26;
LABEL_17:
    _os_log_impl(&dword_1B88A2000, v21, OS_LOG_TYPE_ERROR, v22, v23, 2u);
    goto LABEL_18;
  }
  size_t BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
  size_t Height = CVPixelBufferGetHeight(a1);
  size_t Width = CVPixelBufferGetWidth(a1);
  size_t v9 = CVPixelBufferGetBytesPerRow(a2);
  size_t v10 = CVPixelBufferGetHeight(a2);
  size_t v11 = CVPixelBufferGetWidth(a2);
  if (Height != v10)
  {
    uint64_t v21 = _ARLogGeneral();
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      goto LABEL_18;
    }
    __int16 v25 = 0;
    size_t v22 = "Source buffer and destination buffer must have the same height";
    __int16 v23 = (uint8_t *)&v25;
    goto LABEL_17;
  }
  if (Width != v11)
  {
    uint64_t v21 = _ARLogGeneral();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      __int16 v24 = 0;
      size_t v22 = "Source buffer must have the same width of the source buffer";
      __int16 v23 = (uint8_t *)&v24;
      goto LABEL_17;
    }
LABEL_18:

    return 0;
  }
  CVPixelBufferLockBaseAddress(a1, 0);
  CVPixelBufferLockBaseAddress(a2, 0);
  BaseAddress = (unsigned __int16 *)CVPixelBufferGetBaseAddress(a1);
  size_t v13 = (float *)CVPixelBufferGetBaseAddress(a2);
  if (Height)
  {
    for (uint64_t i = 0; i != Height; ++i)
    {
      size_t v15 = Width;
      CFNumberRef v16 = BaseAddress;
      for (size_t j = v13; v15; --v15)
      {
        unsigned int v18 = *v16++;
        float v19 = (double)v18 * 0.000125;
        *j++ = v19;
      }
      size_t v13 = (float *)((char *)v13 + v9);
      BaseAddress = (unsigned __int16 *)((char *)BaseAddress + BytesPerRow);
    }
  }
  CVPixelBufferUnlockBaseAddress(a1, 0);
  CVPixelBufferUnlockBaseAddress(a2, 0);
  return 1;
}

uint64_t ARDepth32BitsBufferToBGRAWithScaling(__CVBuffer *a1, __CVBuffer *a2, float a3)
{
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  OSType v7 = CVPixelBufferGetPixelFormatType(a2);
  if (PixelFormatType != 1717855600 || v7 != 1111970369)
  {
    __int16 v29 = _ARLogGeneral();
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
      goto LABEL_31;
    }
    __int16 v34 = 0;
    uint64_t v30 = "Source buffer must have pixel format kCVPixelFormatType_DepthFloat32 and destination buffer kCVPixelFormatType_32BGRA.";
    __int16 v31 = (uint8_t *)&v34;
LABEL_30:
    _os_log_impl(&dword_1B88A2000, v29, OS_LOG_TYPE_ERROR, v30, v31, 2u);
    goto LABEL_31;
  }
  size_t BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
  size_t Height = CVPixelBufferGetHeight(a1);
  size_t Width = CVPixelBufferGetWidth(a1);
  size_t v11 = CVPixelBufferGetBytesPerRow(a2);
  size_t v12 = CVPixelBufferGetHeight(a2);
  size_t v13 = CVPixelBufferGetWidth(a2);
  if (Height != v12)
  {
    __int16 v29 = _ARLogGeneral();
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
      goto LABEL_31;
    }
    __int16 v33 = 0;
    uint64_t v30 = "Source buffer and destination buffer must have the same height";
    __int16 v31 = (uint8_t *)&v33;
    goto LABEL_30;
  }
  if (Width != v13)
  {
    __int16 v29 = _ARLogGeneral();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      __int16 v32 = 0;
      uint64_t v30 = "Source buffer must have the same width of the source buffer";
      __int16 v31 = (uint8_t *)&v32;
      goto LABEL_30;
    }
LABEL_31:

    return 0;
  }
  CVPixelBufferLockBaseAddress(a1, 0);
  CVPixelBufferLockBaseAddress(a2, 0);
  BaseAddress = (float *)CVPixelBufferGetBaseAddress(a1);
  size_t v15 = (char *)CVPixelBufferGetBaseAddress(a2);
  if (Height)
  {
    uint64_t v16 = 0;
    size_t v17 = v15 + 1;
    do
    {
      unsigned int v18 = v17;
      size_t v19 = Width;
      for (uint64_t i = BaseAddress; v19; --v19)
      {
        double v21 = (float)((float)(*i * a3) * 0.25);
        float v22 = (fabs(v21 + -0.25) * -4.0 + 1.5) * 255.0;
        int v23 = (int)v22;
        if (v22 > 255.0) {
          LOBYTE(v23) = -1;
        }
        if (v22 < 0.0) {
          LOBYTE(v23) = 0;
        }
        *(v18 - 1) = v23;
        float v24 = (fabs(v21 + -0.5) * -4.0 + 1.5) * 255.0;
        int v25 = (int)v24;
        if (v24 > 255.0) {
          LOBYTE(v25) = -1;
        }
        if (v24 < 0.0) {
          LOBYTE(v25) = 0;
        }
        *unsigned int v18 = v25;
        float v26 = (fabs(v21 + -0.75) * -4.0 + 1.5) * 255.0;
        if (v26 >= 0.0)
        {
          if (v26 <= 255.0) {
            int v27 = (int)v26;
          }
          else {
            LOBYTE(v27) = -1;
          }
        }
        else
        {
          LOBYTE(v27) = 0;
        }
        v18[1] = v27;
        v18[2] = -1;
        ++i;
        v18 += 4;
      }
      ++v16;
      BaseAddress = (float *)((char *)BaseAddress + BytesPerRow);
      v17 += v11;
    }
    while (v16 != Height);
  }
  CVPixelBufferUnlockBaseAddress(a1, 0);
  CVPixelBufferUnlockBaseAddress(a2, 0);
  return 1;
}

void ARDepth32ImageAverageDepth(__CVBuffer *a1)
{
  if (CVPixelBufferGetPixelFormatType(a1) == 1717855600)
  {
    size_t BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
    size_t Width = CVPixelBufferGetWidth(a1);
    size_t Height = CVPixelBufferGetHeight(a1);
    CVPixelBufferLockBaseAddress(a1, 1uLL);
    BaseAddress = (float *)CVPixelBufferGetBaseAddress(a1);
    if (Height)
    {
      uint64_t v6 = 0;
      int v7 = 0;
      float v8 = 0.0;
      do
      {
        if (Width)
        {
          size_t v9 = Width;
          size_t v10 = BaseAddress;
          do
          {
            float v11 = *v10++;
            float v8 = v8 + v11;
            --v9;
          }
          while (v9);
          v7 += Width;
        }
        ++v6;
        BaseAddress = (float *)((char *)BaseAddress + BytesPerRow);
      }
      while (v6 != Height);
    }
    CVPixelBufferUnlockBaseAddress(a1, 1uLL);
  }
  else
  {
    size_t v12 = _ARLogGeneral();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)size_t v13 = 0;
      _os_log_impl(&dword_1B88A2000, v12, OS_LOG_TYPE_ERROR, "Source buffer must have pixel format kCVPixelFormatType_DepthFloat32.", v13, 2u);
    }
  }
}

void ARDepth16ImageAverageDepth(__CVBuffer *a1)
{
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  if (PixelFormatType == 1278226536 || PixelFormatType == 1751410032 || PixelFormatType == 1751411059)
  {
    size_t BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
    size_t Width = CVPixelBufferGetWidth(a1);
    size_t Height = CVPixelBufferGetHeight(a1);
    CVPixelBufferLockBaseAddress(a1, 1uLL);
    BaseAddress = (char *)CVPixelBufferGetBaseAddress(a1);
    if (Height)
    {
      uint64_t v7 = 0;
      int v8 = 0;
      float v9 = 0.0;
      do
      {
        if (Width)
        {
          size_t v10 = Width;
          float v11 = BaseAddress;
          do
          {
            v11 += 2;
            __asm
            {
              FCMP            H1, #0
              FCVT            S1, H1
            }
            if (_ZF) {
              _S1 = 1.0 / _S1;
            }
            float v9 = v9 + _S1;
            --v10;
          }
          while (v10);
          v8 += Width;
        }
        ++v7;
        BaseAddress += BytesPerRow;
      }
      while (v7 != Height);
    }
    CVPixelBufferUnlockBaseAddress(a1, 1uLL);
  }
  else
  {
    unsigned int v18 = _ARLogGeneral();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)size_t v19 = 0;
      _os_log_impl(&dword_1B88A2000, v18, OS_LOG_TYPE_ERROR, "Source buffer must have pixel format kCVPixelFormatType_OneComponent16Half, kCVPixelFormatType_DepthFloat16 or kCVPixelFormatType_DisparityFloat16.", v19, 2u);
    }
  }
}

uint64_t ARDepth32BitsBufferToBGRA(__CVBuffer *a1, __CVBuffer *a2)
{
  return ARDepth32BitsBufferToBGRAWithScaling(a1, a2, 1.0);
}

id ARDepthRepresentationDictionaryClassList()
{
  if (ARDepthRepresentationDictionaryClassList::onceToken != -1) {
    dispatch_once(&ARDepthRepresentationDictionaryClassList::onceToken, &__block_literal_global_59);
  }
  uint64_t v0 = (void *)ARDepthRepresentationDictionaryClassList::depthMetadataClasses;
  return v0;
}

void __ARDepthRepresentationDictionaryClassList_block_invoke()
{
  uint64_t v0 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v1 = objc_opt_class();
  uint64_t v2 = objc_opt_class();
  uint64_t v3 = objc_opt_class();
  uint64_t v4 = objc_opt_class();
  uint64_t v5 = objc_msgSend(v0, "setWithObjects:", v1, v2, v3, v4, objc_opt_class(), 0);
  uint64_t v6 = (void *)ARDepthRepresentationDictionaryClassList::depthMetadataClasses;
  ARDepthRepresentationDictionaryClassList::depthMetadataClasses = v5;
}

id ARDepthRepresentationDictionary(void *a1)
{
  id v1 = a1;
  if (v1)
  {
    uint64_t v2 = objc_opt_new();
    uint64_t v3 = objc_msgSend(NSNumber, "numberWithShort:", objc_msgSend(v1, "depthDataVersionMajor"));
    [v2 setObject:v3 forKey:*MEMORY[0x1E4F526A8]];

    uint64_t v4 = objc_msgSend(NSNumber, "numberWithInteger:", objc_msgSend(v1, "depthDataQuality"));
    [v2 setObject:v4 forKey:*MEMORY[0x1E4F526A0]];

    uint64_t v5 = objc_msgSend(NSNumber, "numberWithBool:", objc_msgSend(v1, "isDepthDataFiltered"));
    [v2 setObject:v5 forKey:*MEMORY[0x1E4F52668]];

    uint64_t v6 = objc_msgSend(NSNumber, "numberWithInteger:", objc_msgSend(v1, "depthDataAccuracy"));
    [v2 setObject:v6 forKey:*MEMORY[0x1E4F52658]];

    uint64_t v7 = NSNumber;
    [v1 depthBlurEffectSimulatedAperture];
    int v8 = objc_msgSend(v7, "numberWithFloat:");
    [v2 setObject:v8 forKey:*MEMORY[0x1E4F52590]];

    float v9 = [v1 depthBlurEffectRenderingParameters];

    if (v9)
    {
      size_t v10 = [v1 depthBlurEffectRenderingParameters];
      [v2 setObject:v10 forKey:*MEMORY[0x1E4F52588]];
    }
    float v11 = [v1 cameraCalibrationData];
    size_t v12 = [v11 cameraCalibrationDataDictionary];
    [v2 addEntriesFromDictionary:v12];
  }
  else
  {
    uint64_t v2 = 0;
  }

  return v2;
}

void sub_1B88BFE94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

CVPixelBufferRef ARCreatePixelBufferFromCGImage(CGImage *a1)
{
  void v23[2] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *MEMORY[0x1E4F24CA0];
  v22[0] = *MEMORY[0x1E4F24CA8];
  v22[1] = v2;
  v23[0] = MEMORY[0x1E4F1CC38];
  v23[1] = MEMORY[0x1E4F1CC38];
  CFDictionaryRef v3 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v23 forKeys:v22 count:2];
  CVPixelBufferRef pixelBufferOut = 0;
  size_t Width = CGImageGetWidth(a1);
  size_t Height = CGImageGetHeight(a1);
  if (CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Width, Height, 0x20u, v3, &pixelBufferOut)) {
    BOOL v6 = 1;
  }
  else {
    BOOL v6 = pixelBufferOut == 0;
  }
  if (v6)
  {
    uint64_t v7 = _ARLogGeneral();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)vImage_Buffer buf = 0;
      _os_log_impl(&dword_1B88A2000, v7, OS_LOG_TYPE_ERROR, "Operation failed: Could not create a pixel buffer", buf, 2u);
    }

    CVPixelBufferRef v17 = 0;
  }
  else
  {
    CVPixelBufferLockBaseAddress(pixelBufferOut, 0);
    BaseAddress = CVPixelBufferGetBaseAddress(pixelBufferOut);
    size_t BitsPerComponent = CGImageGetBitsPerComponent(a1);
    size_t BytesPerRow = CVPixelBufferGetBytesPerRow(pixelBufferOut);
    DeviceRGB = CGColorSpaceCreateDeviceRGB();
    size_t v12 = CGImageGetWidth(a1);
    size_t v13 = CGImageGetHeight(a1);
    CFNumberRef v14 = CGBitmapContextCreate(BaseAddress, v12, v13, BitsPerComponent, BytesPerRow, DeviceRGB, 6u);
    CGAffineTransformMakeRotation(&v19, 0.0);
    CGContextConcatCTM(v14, &v19);
    size_t v15 = CGImageGetWidth(a1);
    size_t v16 = CGImageGetHeight(a1);
    v24.size.width = (double)v15;
    v24.size.height = (double)v16;
    v24.origin.x = 0.0;
    v24.origin.y = 0.0;
    CGContextDrawImage(v14, v24, a1);
    CGColorSpaceRelease(DeviceRGB);
    CGContextRelease(v14);
    CVPixelBufferUnlockBaseAddress(pixelBufferOut, 0);
    CVPixelBufferRef v17 = pixelBufferOut;
  }

  return v17;
}

void sub_1B88C0110(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ARReadDepthBufferFromFile(void *a1, CVPixelBufferRef *a2, float a3)
{
  id v5 = a1;
  BOOL v6 = (const char *)[v5 UTF8String];
  CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v8 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v6, 0x8000100u);
  CFURLRef v9 = CFURLCreateWithFileSystemPath(v7, v8, kCFURLPOSIXPathStyle, 0);
  CFRelease(v8);
  size_t v10 = CGImageSourceCreateWithURL(v9, 0);
  CFRelease(v9);
  if (!v10)
  {
    size_t v15 = _ARLogGeneral();
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    __int16 v39 = 0;
    size_t v16 = "CGImageSourceCreateWithURL() failed!";
    CVPixelBufferRef v17 = (uint8_t *)&v39;
LABEL_20:
    _os_log_impl(&dword_1B88A2000, v15, OS_LOG_TYPE_ERROR, v16, v17, 2u);
    goto LABEL_21;
  }
  ImageAtIndex = CGImageSourceCreateImageAtIndex(v10, 0, 0);
  CFRelease(v10);
  if (!ImageAtIndex)
  {
    size_t v15 = _ARLogGeneral();
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    __int16 v38 = 0;
    size_t v16 = "CGImageSourceCreateImageAtIndex() failed!";
    CVPixelBufferRef v17 = (uint8_t *)&v38;
    goto LABEL_20;
  }
  ColorSpace = CGImageGetColorSpace(ImageAtIndex);
  CGColorSpaceModel Model = CGColorSpaceGetModel(ColorSpace);
  if (Model | CGImageGetAlphaInfo(ImageAtIndex))
  {
    CFNumberRef v14 = _ARLogGeneral();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)vImage_Buffer buf = 0;
      _os_log_impl(&dword_1B88A2000, v14, OS_LOG_TYPE_ERROR, "unexpected image format!", buf, 2u);
    }

    CGImageRelease(ImageAtIndex);
    goto LABEL_22;
  }
  unint64_t Width = CGImageGetWidth(ImageAtIndex);
  size_t Height = CGImageGetHeight(ImageAtIndex);
  size_t BitsPerPixel = CGImageGetBitsPerPixel(ImageAtIndex);
  size_t BytesPerRow = CGImageGetBytesPerRow(ImageAtIndex);
  if (BitsPerPixel != 16)
  {
    CGImageRelease(ImageAtIndex);
    size_t v15 = _ARLogGeneral();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      __int16 v36 = 0;
      size_t v16 = "expected 16bit format!";
      CVPixelBufferRef v17 = (uint8_t *)&v36;
      goto LABEL_20;
    }
    goto LABEL_21;
  }
  size_t v22 = BytesPerRow;
  DataProvider = CGImageGetDataProvider(ImageAtIndex);
  CFDataRef v24 = CGDataProviderCopyData(DataProvider);
  CFDataRef v25 = v24;
  if (!v24)
  {
    CGImageRelease(ImageAtIndex);
    size_t v15 = _ARLogGeneral();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__int16 v35 = 0;
      size_t v16 = "CGDataProviderCopyData() failed!";
      CVPixelBufferRef v17 = v35;
      goto LABEL_20;
    }
    goto LABEL_21;
  }
  BytePtr = CFDataGetBytePtr(v24);
  if (CVPixelBufferCreate(v7, Width, Height, 0x66646570u, 0, a2))
  {
    CFRelease(v25);
    CGImageRelease(ImageAtIndex);
    size_t v15 = _ARLogGeneral();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      __int16 v34 = 0;
      size_t v16 = "CVPixelBufferCreate() failed!";
      CVPixelBufferRef v17 = (uint8_t *)&v34;
      goto LABEL_20;
    }
LABEL_21:

LABEL_22:
    uint64_t v27 = 0;
    goto LABEL_23;
  }
  CVPixelBufferLockBaseAddress(*a2, 0);
  BaseAddress = (float *)CVPixelBufferGetBaseAddress(*a2);
  size_t v30 = CVPixelBufferGetBytesPerRow(*a2);
  if (Height)
  {
    LODWORD(v32) = 0;
    do
    {
      if (Width)
      {
        uint64_t v33 = 0;
        do
        {
          LOWORD(v31) = *(_WORD *)&BytePtr[2 * v33];
          float v31 = (float)LODWORD(v31) * a3;
          BaseAddress[v33++] = v31;
        }
        while (Width > v33);
      }
      BytePtr += v22;
      BaseAddress = (float *)((char *)BaseAddress + v30);
      size_t v32 = (v32 + 1);
    }
    while (Height > v32);
  }
  CVPixelBufferUnlockBaseAddress(*a2, 0);
  CFRelease(v25);
  CGImageRelease(ImageAtIndex);
  uint64_t v27 = 1;
LABEL_23:

  return v27;
}

void sub_1B88C04D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ARPixelBufferCopy(__CVBuffer *a1, __CVBuffer *a2)
{
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  size_t Width = CVPixelBufferGetWidth(a1);
  size_t v5 = CVPixelBufferGetWidth(a2);
  size_t Height = CVPixelBufferGetHeight(a1);
  size_t v7 = CVPixelBufferGetHeight(a2);
  if (Width != v5 || Height != v7)
  {
    size_t v10 = _ARLogGeneral();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)vImage_Buffer buf = 0;
      _os_log_impl(&dword_1B88A2000, v10, OS_LOG_TYPE_ERROR, "ARPixelBufferCopy: Source and destination buffers must have matching dimensions", buf, 2u);
    }
    goto LABEL_9;
  }
  CVReturn v8 = CVPixelBufferLockBaseAddress(a1, 0);
  if (!v8)
  {
    v47[0] = MEMORY[0x1E4F143A8];
    v47[1] = 3221225472;
    float32x4_t v48 = __ARPixelBufferCopy_block_invoke;
    uint64_t v49 = &__block_descriptor_40_e5_v8__0l;
    uint64_t v50 = a1;
    CVReturn v13 = CVPixelBufferLockBaseAddress(a2, 0);
    if (v13)
    {
      CFNumberRef v14 = _ARLogGeneral();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)vImage_Buffer buf = 67109120;
        LODWORD(v52) = v13;
        _os_log_impl(&dword_1B88A2000, v14, OS_LOG_TYPE_ERROR, "ARPixelBufferCopy: Error locking destination buffer: %d", buf, 8u);
      }

      uint64_t v11 = 0;
      goto LABEL_58;
    }
    v43[0] = MEMORY[0x1E4F143A8];
    v43[1] = 3221225472;
    CVPixelBufferRef v44 = __ARPixelBufferCopy_block_invoke_64;
    uint64_t v45 = &__block_descriptor_40_e5_v8__0l;
    unint64_t v46 = a2;
    if (CVPixelBufferIsPlanar(a1))
    {
      if (CVPixelBufferIsPlanar(a2))
      {
        size_t PlaneCount = CVPixelBufferGetPlaneCount(a1);
        if (PlaneCount == CVPixelBufferGetPlaneCount(a2))
        {
          if (PlaneCount)
          {
            size_t v16 = 0;
            while (1)
            {
              size_t WidthOfPlane = CVPixelBufferGetWidthOfPlane(a1, v16);
              size_t HeightOfPlane = CVPixelBufferGetHeightOfPlane(a1, v16);
              size_t v19 = CVPixelBufferGetWidthOfPlane(a2, v16);
              size_t v20 = CVPixelBufferGetHeightOfPlane(a2, v16);
              if (WidthOfPlane != v19 || HeightOfPlane != v20) {
                break;
              }
              size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(a1, v16);
              if (BytesPerRowOfPlane * HeightOfPlane != CVPixelBufferGetBytesPerRowOfPlane(a2, v16) * HeightOfPlane)
              {
                __int16 v36 = _ARLogGeneral();
                if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)vImage_Buffer buf = 134217984;
                  size_t v52 = v16;
                  _os_log_impl(&dword_1B88A2000, v36, OS_LOG_TYPE_ERROR, "ARPixelBufferCopy: Source and destination buffers match resolution and number of planes but plane %lu within each pixel buffer has a different number of bytes per row", buf, 0xCu);
                }
LABEL_49:

                goto LABEL_56;
              }
              if (BytesPerRowOfPlane % WidthOfPlane)
              {
                BaseAddressOfPlane = CVPixelBufferGetBaseAddressOfPlane(a2, v16);
                int v23 = CVPixelBufferGetBaseAddressOfPlane(a1, v16);
                memcpy(BaseAddressOfPlane, v23, BytesPerRowOfPlane * HeightOfPlane);
              }
              else
              {
                memset(&src, 0, sizeof(src));
                ARWrapCVPixelBufferPlaneVImage(a1, v16, &src.data);
                memset(&dest, 0, sizeof(dest));
                ARWrapCVPixelBufferPlaneVImage(a2, v16, &dest.data);
                vImage_Error v24 = vImageCopyBuffer(&src, &dest, BytesPerRowOfPlane / WidthOfPlane, 0x10u);
                if (v24)
                {
                  float v31 = _ARLogGeneral();
                  if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
                  {
                    OSType PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
                    AROSTypeToString(PixelFormatType);
                    id v38 = (id)objc_claimAutoreleasedReturnValue();
                    OSType v39 = CVPixelBufferGetPixelFormatType(a2);
                    __int16 v40 = AROSTypeToString(v39);
                    *(_DWORD *)vImage_Buffer buf = 134219778;
                    size_t v52 = v24;
                    __int16 v53 = 2048;
                    size_t v54 = v16;
                    __int16 v55 = 2114;
                    size_t v56 = (size_t)v38;
                    __int16 v57 = 2048;
                    size_t v58 = WidthOfPlane;
                    __int16 v59 = 2048;
                    size_t v60 = HeightOfPlane;
                    __int16 v61 = 2114;
                    size_t v62 = (size_t)v40;
                    __int16 v63 = 2048;
                    size_t v64 = WidthOfPlane;
                    __int16 v65 = 2048;
                    size_t v66 = HeightOfPlane;
                    _os_log_impl(&dword_1B88A2000, v31, OS_LOG_TYPE_ERROR, "ARPixelBufferCopy: vImageCopyBuffer error (%zu) for plane %zu copying pixel buffer (format:%{public}@, plane size:%zux%zu) to pixel buffer (format:%{public}@, plane size:%zux%zu)", buf, 0x52u);
                  }
                  goto LABEL_55;
                }
              }
              if (PlaneCount == ++v16) {
                goto LABEL_43;
              }
            }
            __int16 v36 = _ARLogGeneral();
            if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)vImage_Buffer buf = 134217984;
              size_t v52 = v16;
              _os_log_impl(&dword_1B88A2000, v36, OS_LOG_TYPE_ERROR, "ARPixelBufferCopy: Source and destination buffers match resolution and number of planes but plane %lu within each pixel buffer are different resolutions", buf, 0xCu);
            }
            goto LABEL_49;
          }
          goto LABEL_43;
        }
        CFDataRef v25 = _ARLogGeneral();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)vImage_Buffer buf = 0;
          _os_log_impl(&dword_1B88A2000, v25, OS_LOG_TYPE_ERROR, "ARPixelBufferCopy: Source and destination buffers must have the same number of planes", buf, 2u);
        }
      }
      else
      {
        CFDataRef v25 = _ARLogGeneral();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)vImage_Buffer buf = 0;
          _os_log_impl(&dword_1B88A2000, v25, OS_LOG_TYPE_ERROR, "ARPixelBufferCopy: Cannot have planar mismatch between source (planar) and destination (non-planar)", buf, 2u);
        }
      }
    }
    else if (CVPixelBufferIsPlanar(a2))
    {
      CFDataRef v25 = _ARLogGeneral();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)vImage_Buffer buf = 0;
        _os_log_impl(&dword_1B88A2000, v25, OS_LOG_TYPE_ERROR, "ARPixelBufferCopy: Cannot have planar mismatch between source (non-planar) and destination (planar)", buf, 2u);
      }
    }
    else
    {
      IOSurface = CVPixelBufferGetIOSurface(a1);
      size_t BytesPerElement = IOSurfaceGetBytesPerElement(IOSurface);
      __int16 v28 = CVPixelBufferGetIOSurface(a2);
      size_t v29 = IOSurfaceGetBytesPerElement(v28);
      if (BytesPerElement == v29)
      {
        memset(&src, 0, sizeof(src));
        ARWrapCVPixelBufferVImage(a1, &src.data);
        memset(&dest, 0, sizeof(dest));
        ARWrapCVPixelBufferVImage(a2, &dest.data);
        vImage_Error v30 = vImageCopyBuffer(&src, &dest, BytesPerElement, 0x10u);
        if (!v30)
        {
LABEL_43:
          CVBufferPropagateAttachments(a1, a2);
          uint64_t v11 = 1;
LABEL_57:
          v44((uint64_t)v43);
LABEL_58:
          v48((uint64_t)v47);
          return v11;
        }
        float v31 = _ARLogGeneral();
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
        {
          OSType v32 = CVPixelBufferGetPixelFormatType(a1);
          AROSTypeToString(v32);
          id v33 = (id)objc_claimAutoreleasedReturnValue();
          OSType v34 = CVPixelBufferGetPixelFormatType(a2);
          __int16 v35 = AROSTypeToString(v34);
          *(_DWORD *)vImage_Buffer buf = 134219522;
          size_t v52 = v30;
          __int16 v53 = 2114;
          size_t v54 = (size_t)v33;
          __int16 v55 = 2048;
          size_t v56 = Width;
          __int16 v57 = 2048;
          size_t v58 = Height;
          __int16 v59 = 2114;
          size_t v60 = (size_t)v35;
          __int16 v61 = 2048;
          size_t v62 = Width;
          __int16 v63 = 2048;
          size_t v64 = Height;
          _os_log_impl(&dword_1B88A2000, v31, OS_LOG_TYPE_ERROR, "ARPixelBufferCopy: vImageCopyBuffer error (%zu) copying pixel buffer (format:%{public}@, size:%zux%zu) to pixel buffer (format:%{public}@, size:%zux%zu)", buf, 0x48u);
        }
LABEL_55:

LABEL_56:
        uint64_t v11 = 0;
        goto LABEL_57;
      }
      CFDataRef v25 = _ARLogGeneral();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)vImage_Buffer buf = 134218240;
        size_t v52 = BytesPerElement;
        __int16 v53 = 2048;
        size_t v54 = v29;
        _os_log_impl(&dword_1B88A2000, v25, OS_LOG_TYPE_ERROR, "ARPixelBufferCopy: Cannot have byte-per-element mismatch between source and destination. src: %zu - dst: %zu", buf, 0x16u);
      }
    }

    goto LABEL_56;
  }
  CVReturn v9 = v8;
  size_t v10 = _ARLogGeneral();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)vImage_Buffer buf = 67109120;
    LODWORD(v52) = v9;
    _os_log_impl(&dword_1B88A2000, v10, OS_LOG_TYPE_ERROR, "ARPixelBufferCopy: Error locking source buffer: %d", buf, 8u);
  }
LABEL_9:

  return 0;
}

void sub_1B88C0CF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,void (*a21)(char *),uint64_t a22,uint64_t a23,char a24,uint64_t a25,void (*a26)(char *))
{
  a21(&a19);
  a26(&a24);
  _Unwind_Resume(a1);
}

void __ARPixelBufferCopy_block_invoke(uint64_t a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  CVReturn v1 = CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a1 + 32), 0);
  if (v1)
  {
    CVReturn v2 = v1;
    CFDictionaryRef v3 = _ARLogGeneral();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v4[0] = 67109120;
      v4[1] = v2;
      _os_log_impl(&dword_1B88A2000, v3, OS_LOG_TYPE_ERROR, "ARPixelBufferCopy: Error unlocking source buffer: %d", (uint8_t *)v4, 8u);
    }
  }
}

void __ARPixelBufferCopy_block_invoke_64(uint64_t a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  CVReturn v1 = CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a1 + 32), 0);
  if (v1)
  {
    CVReturn v2 = v1;
    CFDictionaryRef v3 = _ARLogGeneral();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v4[0] = 67109120;
      v4[1] = v2;
      _os_log_impl(&dword_1B88A2000, v3, OS_LOG_TYPE_ERROR, "ARPixelBufferCopy: Error unlocking destination buffer: %d", (uint8_t *)v4, 8u);
    }
  }
}

double ARGetCroppedRegionCenterCrop(double a1, double a2, double a3)
{
  return (a1 - a3) * 0.5 + 0.0;
}

uint64_t ARCGImagePropertyOrientationFromUIDeviceOrientation(uint64_t a1)
{
  if ((unint64_t)(a1 - 1) > 3) {
    return 1;
  }
  else {
    return dword_1B8A2B260[a1 - 1];
  }
}

uint64_t _ARConvertBufferPixelsToBufferPixels(__CVBuffer *a1, __CVBuffer *a2, void *a3)
{
  uint64_t v5 = a3;
  size_t BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
  size_t Height = CVPixelBufferGetHeight(a1);
  size_t Width = CVPixelBufferGetWidth(a1);
  size_t v18 = CVPixelBufferGetBytesPerRow(a2);
  size_t v7 = CVPixelBufferGetHeight(a2);
  size_t v8 = CVPixelBufferGetWidth(a2);
  BOOL v9 = Height == v7 && Width == v8;
  uint64_t v10 = v9;
  if (v9)
  {
    CVPixelBufferLockBaseAddress(a1, 0);
    CVPixelBufferLockBaseAddress(a2, 0);
    BaseAddress = (char *)CVPixelBufferGetBaseAddress(a1);
    size_t v15 = a2;
    size_t v16 = (char *)CVPixelBufferGetBaseAddress(a2);
    if (Height)
    {
      for (uint64_t i = 0; i != Height; ++i)
      {
        uint64_t v12 = 0;
        size_t v13 = Width;
        do
        {
          v5[2](v5, &BaseAddress[i * BytesPerRow + v12 * (BytesPerRow / Width)], BytesPerRow / Width, &v16[i * v18 + v12 * (v18 / Width)], v18 / Width);
          ++v12;
          --v13;
        }
        while (v13);
      }
    }
    CVPixelBufferUnlockBaseAddress(a1, 0);
    uint64_t v10 = v10;
    CVPixelBufferUnlockBaseAddress(v15, 0);
  }

  return v10;
}

void sub_1B88C10FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ARCreatePixelBufferFromSourceWithPixelConverter(__CVBuffer *a1, OSType a2, CVPixelBufferRef *a3, void *a4)
{
  id v7 = a4;
  size_t Width = CVPixelBufferGetWidth(a1);
  size_t Height = CVPixelBufferGetHeight(a1);
  if (CVPixelBufferGetWidth(*a3) == Width && CVPixelBufferGetHeight(*a3) == Height)
  {
    IOSurfaceRef IOSurface = CVPixelBufferGetIOSurface(*a3);
    CVPixelBufferRef pixelBufferOut = 0;
    if (IOSurface)
    {
      uint64_t v11 = *a3;
      CVPixelBufferRef pixelBufferOut = *a3;
      LOBYTE(v12) = 1;
      goto LABEL_9;
    }
  }
  else
  {
    CVPixelBufferRef pixelBufferOut = 0;
  }
  if (*a3)
  {
LABEL_13:
    uint64_t v12 = 4294960636;
    goto LABEL_14;
  }
  uint64_t v12 = CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Width, Height, a2, 0, &pixelBufferOut);
  if (v12) {
    goto LABEL_14;
  }
  uint64_t v11 = pixelBufferOut;
LABEL_9:
  if ((_ARConvertBufferPixelsToBufferPixels(a1, v11, v7) & 1) == 0)
  {
    CVPixelBufferRelease(pixelBufferOut);
    goto LABEL_13;
  }
  if (v12)
  {
    uint64_t v12 = 0;
  }
  else
  {
    uint64_t v12 = 0;
    *a3 = pixelBufferOut;
  }
LABEL_14:

  return v12;
}

void sub_1B88C124C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

CVPixelBufferRef ARCreateColorizedOneComponentTo24RGBPixelBuffer(__CVBuffer *a1, void *a2)
{
  v48[1] = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  OSType v5 = PixelFormatType;
  if (!v3 && PixelFormatType == 1278226488)
  {
    BOOL v6 = 0;
    id v7 = _ARLogGeneral();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)vImage_Buffer buf = 0;
      _os_log_impl(&dword_1B88A2000, v7, OS_LOG_TYPE_ERROR, "Missing color table for kCVPixelFormatType_OneComponent8 input", buf, 2u);
    }
LABEL_5:

    CVPixelBufferRef v8 = 0;
    goto LABEL_37;
  }
  if (PixelFormatType - 1278226488 > 0x30
    || ((1 << (PixelFormatType - 56)) & 0x1400000000001) == 0)
  {
    BOOL v6 = v3;
    id v7 = _ARLogGeneral();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)vImage_Buffer buf = 0;
      _os_log_impl(&dword_1B88A2000, v7, OS_LOG_TYPE_ERROR, "Failed to create the colorized buffer: Unexpected format.", buf, 2u);
    }
    goto LABEL_5;
  }
  size_t Width = CVPixelBufferGetWidth(a1);
  size_t Height = CVPixelBufferGetHeight(a1);
  *(void *)vImage_Buffer buf = 0;
  uint64_t v47 = *MEMORY[0x1E4F24D20];
  v48[0] = MEMORY[0x1E4F1CC08];
  CFDictionaryRef v37 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v48 forKeys:&v47 count:1];
  if (CVPixelBufferCreate(0, Width, Height, 0x18u, v37, (CVPixelBufferRef *)buf))
  {
    BOOL v6 = v3;
    uint64_t v11 = _ARLogGeneral();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v45 = 0;
      _os_log_impl(&dword_1B88A2000, v11, OS_LOG_TYPE_ERROR, "Could not create pixelbuffer", v45, 2u);
    }

    CVPixelBufferRef v8 = 0;
    goto LABEL_36;
  }
  CVPixelBufferLockBaseAddress(a1, 0);
  CVPixelBufferLockBaseAddress(*(CVPixelBufferRef *)buf, 0);
  v39[0] = MEMORY[0x1E4F143A8];
  v39[1] = 3221225472;
  __int16 v40 = __ARCreateColorizedOneComponentTo24RGBPixelBuffer_block_invoke;
  float32x4_t v41 = &__block_descriptor_48_e5_v8__0l;
  uint64_t v42 = a1;
  CVPixelBufferRef v43 = *(CVPixelBufferRef *)buf;
  BaseAddress = (char *)CVPixelBufferGetBaseAddress(a1);
  size_t v13 = (char *)CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)buf);
  size_t BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
  BOOL v6 = v3;
  size_t v34 = CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)buf);
  if (!Height)
  {
LABEL_26:
    CVPixelBufferRef v8 = *(CVPixelBufferRef *)buf;
    goto LABEL_35;
  }
  uint64_t v14 = 0;
  id v38 = v13 + 2;
  BOOL v36 = 1;
  size_t v33 = Height;
  while (!Width)
  {
LABEL_25:
    BOOL v36 = v33 > ++v14;
    BaseAddress += BytesPerRow;
    v38 += v34;
    if (v14 == v33) {
      goto LABEL_26;
    }
  }
  uint64_t v15 = 0;
  size_t v16 = v38;
  while (1)
  {
    if (v5 == 1278226536)
    {
      _H0 = *(_WORD *)&BaseAddress[2 * v15];
      __asm { FCVT            S0, H0 }
LABEL_23:
      int v30 = (int)fminf(_S0 * 255.0, 255.0);
      *(v16 - 2) = v30;
      *(v16 - 1) = v30;
      unsigned char *v16 = v30;
      goto LABEL_24;
    }
    if (v5 == 1278226534)
    {
      _S0 = *(float *)&BaseAddress[4 * v15];
      goto LABEL_23;
    }
    if (v5 == 1278226488) {
      break;
    }
LABEL_24:
    ++v15;
    v16 += 3;
    if (Width == v15) {
      goto LABEL_25;
    }
  }
  unint64_t v17 = BaseAddress[v15];
  if ([v6 count] > v17)
  {
    size_t v18 = [v6 objectAtIndexedSubscript:v17];
    [v18 red];
    *(v16 - 2) = (int)(v19 * 255.0);

    size_t v20 = [v6 objectAtIndexedSubscript:v17];
    [v20 green];
    *(v16 - 1) = (int)(v21 * 255.0);

    size_t v22 = [v6 objectAtIndexedSubscript:v17];
    [v22 blue];
    unsigned char *v16 = (int)(v23 * 255.0);

    goto LABEL_24;
  }
  float v31 = _ARLogGeneral();
  if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)uint64_t v45 = 67109120;
    int v46 = v17;
    _os_log_impl(&dword_1B88A2000, v31, OS_LOG_TYPE_ERROR, "Failed to create the colorized buffer: Color is not defined for label=%d", v45, 8u);
  }

  if (v36) {
    CVPixelBufferRef v8 = 0;
  }
  else {
    CVPixelBufferRef v8 = *(CVPixelBufferRef *)buf;
  }
LABEL_35:
  v40((uint64_t)v39);
LABEL_36:

LABEL_37:
  return v8;
}

void sub_1B88C172C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

uint64_t __ARCreateColorizedOneComponentTo24RGBPixelBuffer_block_invoke(uint64_t a1)
{
  CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a1 + 32), 0);
  CVReturn v2 = *(__CVBuffer **)(a1 + 40);
  return CVPixelBufferUnlockBaseAddress(v2, 0);
}

uint64_t ARCreateConcatenatedCVPixelBuffer(__CVBuffer *a1, __CVBuffer *a2, uint64_t a3)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  size_t Width = CVPixelBufferGetWidth(a1);
  size_t v7 = CVPixelBufferGetWidth(a2);
  size_t Height = CVPixelBufferGetHeight(a1);
  size_t v9 = CVPixelBufferGetHeight(a2);
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  OSType v11 = CVPixelBufferGetPixelFormatType(a2);
  if (Height != v9)
  {
    uint64_t v12 = _ARLogGeneral();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)CVPixelBufferRef pixelBufferOut = 134218240;
      *(void *)&pixelBufferOut[4] = Height;
      __int16 v42 = 2048;
      size_t v43 = v9;
      uint64_t v14 = "Failed to concatenate buffers: Height does not match (%zu <-> %zu)";
      uint64_t v15 = v12;
      uint32_t v16 = 22;
LABEL_16:
      _os_log_impl(&dword_1B88A2000, v15, OS_LOG_TYPE_ERROR, v14, pixelBufferOut, v16);
      goto LABEL_17;
    }
    goto LABEL_17;
  }
  if (PixelFormatType != v11)
  {
    uint64_t v12 = _ARLogGeneral();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)CVPixelBufferRef pixelBufferOut = 0;
      uint64_t v14 = "Failed to concatenate buffers: format does not match";
LABEL_15:
      uint64_t v15 = v12;
      uint32_t v16 = 2;
      goto LABEL_16;
    }
LABEL_17:
    uint64_t v17 = 0;
    goto LABEL_18;
  }
  if (!CVPixelBufferGetIOSurface(a1) || !CVPixelBufferGetIOSurface(a2))
  {
    uint64_t v12 = _ARLogGeneral();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)CVPixelBufferRef pixelBufferOut = 0;
      uint64_t v14 = "Failed to concatenate buffers: Buffers need to be IOSurface back";
      goto LABEL_15;
    }
    goto LABEL_17;
  }
  size_t __n = v7;
  uint64_t v39 = *MEMORY[0x1E4F24D20];
  uint64_t v40 = MEMORY[0x1E4F1CC08];
  uint64_t v12 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v40 forKeys:&v39 count:1];
  *(void *)CVPixelBufferRef pixelBufferOut = 0;
  if (CVPixelBufferCreate(0, Width + a3 + __n, Height, PixelFormatType, (CFDictionaryRef)v12, (CVPixelBufferRef *)pixelBufferOut))
  {
    size_t v13 = _ARLogGeneral();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)vImage_Buffer buf = 0;
      _os_log_impl(&dword_1B88A2000, v13, OS_LOG_TYPE_ERROR, "Could not create pixelbuffer", buf, 2u);
    }

    goto LABEL_17;
  }
  CVPixelBufferLockBaseAddress(*(CVPixelBufferRef *)pixelBufferOut, 0);
  CVPixelBufferLockBaseAddress(a1, 0);
  CVPixelBufferLockBaseAddress(a2, 0);
  size_t BytesPerRow = CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)pixelBufferOut);
  size_t v34 = CVPixelBufferGetBytesPerRow(a1);
  size_t v33 = BytesPerRow;
  size_t v32 = CVPixelBufferGetBytesPerRow(a2);
  BaseAddress = (char *)CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)pixelBufferOut);
  double v21 = (char *)CVPixelBufferGetBaseAddress(a1);
  size_t v22 = (char *)CVPixelBufferGetBaseAddress(a2);
  IOSurfaceRef IOSurface = CVPixelBufferGetIOSurface(a1);
  size_t BytesPerElement = IOSurfaceGetBytesPerElement(IOSurface);
  CFDataRef v25 = CVPixelBufferGetIOSurface(a2);
  size_t v26 = IOSurfaceGetBytesPerElement(v25);
  size_t v27 = v34;
  size_t v28 = v32;
  if (Height)
  {
    size_t v35 = v26 * __n;
    size_t __na = BytesPerElement * Width;
    size_t v29 = a3 + BytesPerElement * Width;
    do
    {
      size_t v30 = v27;
      size_t v31 = v28;
      memcpy(BaseAddress, v21, __na);
      memcpy(&BaseAddress[v29], v22, v35);
      size_t v28 = v31;
      size_t v27 = v30;
      BaseAddress += v33;
      v21 += v30;
      v22 += v31;
      --Height;
    }
    while (Height);
  }
  CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)pixelBufferOut, 0);
  CVPixelBufferUnlockBaseAddress(a1, 0);
  CVPixelBufferUnlockBaseAddress(a2, 0);
  uint64_t v17 = *(void *)pixelBufferOut;
LABEL_18:

  return v17;
}

void sub_1B88C1BA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

id ARIOSurfaceToPNGData(IOSurfaceRef surface)
{
  CVPixelBufferRef pixelBufferOut = 0;
  if (CVPixelBufferCreateWithIOSurface(0, surface, 0, &pixelBufferOut))
  {
    CVReturn v1 = _ARLogGeneral();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_log_impl(&dword_1B88A2000, v1, OS_LOG_TYPE_ERROR, "Could not create pixelbuffer", v4, 2u);
    }

    CVReturn v2 = 0;
  }
  else
  {
    CVReturn v2 = ARPixelBufferToPNGData((uint64_t)pixelBufferOut);
    CVPixelBufferRelease(pixelBufferOut);
  }
  return v2;
}

void sub_1B88C1C98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id ARPixelBufferToPNGData(uint64_t a1)
{
  v16[1] = *MEMORY[0x1E4F143B8];
  CVReturn v2 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC18]);
  id v3 = (void *)MEMORY[0x1E4F1E050];
  uint64_t v15 = *MEMORY[0x1E4F1E390];
  v16[0] = v2;
  uint64_t v4 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v16 forKeys:&v15 count:1];
  OSType v5 = [v3 imageWithCVPixelBuffer:a1 options:v4];

  if (v5)
  {
    BOOL v6 = (void *)MEMORY[0x1E4F1E018];
    uint64_t v13 = *MEMORY[0x1E4F1E240];
    uint64_t v14 = v2;
    size_t v7 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v14 forKeys:&v13 count:1];
    CVPixelBufferRef v8 = [v6 contextWithOptions:v7];

    uint64_t v9 = [v8 workingColorSpace];
    uint64_t v10 = [v8 PNGRepresentationOfImage:v5 format:*MEMORY[0x1E4F1E280] colorSpace:v9 options:MEMORY[0x1E4F1CC08]];
    CGColorSpaceRelease(v2);
  }
  else
  {
    CVPixelBufferRef v8 = _ARLogGeneral();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v12 = 0;
      _os_log_impl(&dword_1B88A2000, v8, OS_LOG_TYPE_ERROR, "Failed to create CIImage", v12, 2u);
    }
    uint64_t v10 = 0;
  }

  return v10;
}

void sub_1B88C1E64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

CVPixelBufferRef ARCreateEmptyBufferWithSameFormatFromSource(__CVBuffer *a1)
{
  CVReturn v1 = a1;
  v9[1] = *MEMORY[0x1E4F143B8];
  CVPixelBufferRef pixelBufferOut = 0;
  size_t Width = CVPixelBufferGetWidth(a1);
  size_t Height = CVPixelBufferGetHeight(v1);
  LODWORD(v1) = CVPixelBufferGetPixelFormatType(v1);
  uint64_t v8 = *MEMORY[0x1E4F24D20];
  v9[0] = MEMORY[0x1E4F1CC08];
  CVPixelBufferCreate(0, Width, Height, (OSType)v1, (CFDictionaryRef)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v9 forKeys:&v8 count:1], &pixelBufferOut);
  CVPixelBufferRef result = pixelBufferOut;
  if (!pixelBufferOut)
  {
    OSType v5 = _ARLogGeneral();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)BOOL v6 = 0;
      _os_log_impl(&dword_1B88A2000, v5, OS_LOG_TYPE_ERROR, "Failed to create an empty pixelbuffer", v6, 2u);
    }

    return pixelBufferOut;
  }
  return result;
}

void ___ZL13_ARLogGeneralv_block_invoke_3()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "General");
  CVReturn v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObsize_t j = (uint64_t)v0;
}

void ___ZL15_ARLogTechniquev_block_invoke()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "Technique");
  CVReturn v1 = (void *)_ARLogTechnique(void)::logObj;
  _ARLogTechnique(void)::logObsize_t j = (uint64_t)v0;
}

double ARUltrawideToWideExtrinsics()
{
  ARCameraToJasperExtrinsics((void *)*MEMORY[0x1E4F15828]);
  ARMatrix4x4FromMatrix4x3();
  long long v7 = v1;
  long long v8 = v0;
  long long v9 = v3;
  long long v10 = v2;
  ARCameraToJasperExtrinsics((void *)*MEMORY[0x1E4F15830]);
  ARMatrix4x4FromMatrix4x3();
  simd_float4x4 v14 = __invert_f4(v13);
  uint64_t v5 = 0;
  v11[0] = v8;
  v11[1] = v7;
  v11[2] = v10;
  v11[3] = v9;
  do
  {
    v11[v5 + 4] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v14.columns[0], COERCE_FLOAT(v11[v5])), (float32x4_t)v14.columns[1], *(float32x2_t *)&v11[v5], 1), (float32x4_t)v14.columns[2], (float32x4_t)v11[v5], 2), (float32x4_t)v14.columns[3], (float32x4_t)v11[v5], 3);
    ++v5;
  }
  while (v5 != 4);
  *(void *)&double result = ARMatrix4x3FromMatrix4x4(v4).n128_u64[0];
  return result;
}

__n128 ARCameraToJasperExtrinsics(void *a1)
{
  id v1 = a1;
  if ([v1 isEqualToString:*MEMORY[0x1E4F15830]])
  {
    long long v2 = &unk_1F125BC30;
  }
  else
  {
    if (![v1 isEqualToString:*MEMORY[0x1E4F15828]])
    {
      __n128 v4 = (__n128)xmmword_1B8A2B0C0;
      goto LABEL_7;
    }
    long long v2 = &unk_1F125BC48;
  }
  __n128 v4 = ARMatrix4x3FromRowMajorFlatArray(v2);
LABEL_7:

  return v4;
}

void sub_1B88C21BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double ARST2UltrawideToWideExtrinsics()
{
  return *(double *)&_PromotedConst;
}

__n128 ARST2CameraToJasperExtrinsics(void *a1)
{
  id v1 = a1;
  if ([v1 isEqualToString:*MEMORY[0x1E4F15830]])
  {
    long long v2 = &unk_1F125BC60;
  }
  else
  {
    if (![v1 isEqualToString:*MEMORY[0x1E4F15828]])
    {
      __n128 v4 = (__n128)xmmword_1B8A2B0C0;
      goto LABEL_7;
    }
    long long v2 = &unk_1F125BC48;
  }
  __n128 v4 = ARMatrix4x3FromRowMajorFlatArray(v2);
LABEL_7:

  return v4;
}

void sub_1B88C229C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id ARJasperWideCameraCalibration()
{
  if (ARJasperWideCameraCalibration::onceToken != -1) {
    dispatch_once(&ARJasperWideCameraCalibration::onceToken, &__block_literal_global_9);
  }
  long long v0 = (void *)ARJasperWideCameraCalibration::cameraCalibration;
  return v0;
}

void __ARJasperWideCameraCalibration_block_invoke()
{
  unint64_t v0 = ARCameraToJasperExtrinsics((void *)*MEMORY[0x1E4F15830]).n128_u64[0];
  double v16 = v1;
  double v17 = *(double *)&v0;
  double v14 = v3;
  double v15 = v2;
  __n128 v4 = (void *)MEMORY[0x1E4F1C9B8];
  uint64_t v5 = ARKitCoreBundle();
  BOOL v6 = objc_msgSend(v5, "ar_pathForPrivateResource:ofType:", @"Wide_distortion_lookup_table", @"hardcoded");
  size_t v18 = [v4 dataWithContentsOfFile:v6];

  long long v7 = (void *)MEMORY[0x1E4F1C9B8];
  long long v8 = ARKitCoreBundle();
  long long v9 = objc_msgSend(v8, "ar_pathForPrivateResource:ofType:", @"Wide_inverse_distortion_lookup_table", @"hardcoded");
  long long v10 = [v7 dataWithContentsOfFile:v9];

  if (v18 && v10)
  {
    OSType v11 = objc_msgSend(objc_alloc(MEMORY[0x1E4F4D820]), "initWithDistortionCenter:lensDistortionLookupTable:inverseLensDistortionLookupTable:", v18, v10, 959.341819, 718.244185);
    uint64_t v12 = objc_msgSend(objc_alloc(MEMORY[0x1E4F4D800]), "initWithIntrinsics:cameraToPlatformTransform:pixelSize:forReferenceDimensions:withDistortionModel:", v11, *(double *)&_PromotedConst_88, unk_1B8A2B2F0, 0.0, v17, v16, v15, v14, 0.00197999994, 0x409E000000000000, 0x4096800000000000);
    simd_float4x4 v13 = (void *)ARJasperWideCameraCalibration::cameraCalibration;
    ARJasperWideCameraCalibration::cameraCalibration = v12;
  }
}

void sub_1B88C2494(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id ARST2JasperWideCameraCalibration()
{
  if (ARST2JasperWideCameraCalibration::onceToken != -1) {
    dispatch_once(&ARST2JasperWideCameraCalibration::onceToken, &__block_literal_global_11);
  }
  unint64_t v0 = (void *)ARST2JasperWideCameraCalibration::cameraCalibration;
  return v0;
}

void __ARST2JasperWideCameraCalibration_block_invoke()
{
  unint64_t v0 = ARST2CameraToJasperExtrinsics((void *)*MEMORY[0x1E4F15830]).n128_u64[0];
  double v16 = v1;
  double v17 = *(double *)&v0;
  double v14 = v3;
  double v15 = v2;
  __n128 v4 = (void *)MEMORY[0x1E4F1C9B8];
  uint64_t v5 = ARKitCoreBundle();
  BOOL v6 = objc_msgSend(v5, "ar_pathForPrivateResource:ofType:", @"Wide_distortion_lookup_table", @"hardcoded");
  size_t v18 = [v4 dataWithContentsOfFile:v6];

  long long v7 = (void *)MEMORY[0x1E4F1C9B8];
  long long v8 = ARKitCoreBundle();
  long long v9 = objc_msgSend(v8, "ar_pathForPrivateResource:ofType:", @"Wide_inverse_distortion_lookup_table", @"hardcoded");
  long long v10 = [v7 dataWithContentsOfFile:v9];

  if (v18 && v10)
  {
    OSType v11 = objc_msgSend(objc_alloc(MEMORY[0x1E4F4D820]), "initWithDistortionCenter:lensDistortionLookupTable:inverseLensDistortionLookupTable:", v18, v10, 959.341819, 718.244185);
    uint64_t v12 = objc_msgSend(objc_alloc(MEMORY[0x1E4F4D800]), "initWithIntrinsics:cameraToPlatformTransform:pixelSize:forReferenceDimensions:withDistortionModel:", v11, *(double *)&_PromotedConst_88, unk_1B8A2B2F0, 0.0, v17, v16, v15, v14, 0.00197999994, 0x409E000000000000, 0x4096800000000000);
    simd_float4x4 v13 = (void *)ARST2JasperWideCameraCalibration::cameraCalibration;
    ARST2JasperWideCameraCalibration::cameraCalibration = v12;
  }
}

void sub_1B88C26D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88C2880(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88C28E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88C2984(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B88C2A94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88C2B48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B88C3030(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_1B88C31B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B88C3308(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88C3444(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88C3564(_Unwind_Exception *a1)
{
  __n128 v4 = v3;

  _Unwind_Resume(a1);
}

void std::vector<ARTexturedPlane>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  double v2 = (uint64_t *)*a1;
  if (*v2)
  {
    std::vector<ARTexturedPlane>::__base_destruct_at_end[abi:ne180100]((uint64_t)v2, *v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<ARTexturedPlane>::__base_destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(void *)(a1 + 8); i != a2; i -= 224)
  {

    std::__tree<std::array<unsigned char,16ul>>::destroy(i - 32, *(void **)(i - 24));
  }
  *(void *)(a1 + 8) = a2;
}

void std::__tree<std::array<unsigned char,16ul>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::array<unsigned char,16ul>>::destroy(a1, *a2);
    std::__tree<std::array<unsigned char,16ul>>::destroy(a1, a2[1]);
    operator delete(a2);
  }
}

void std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::destroy(a1, a2[1]);

    std::__tree<std::array<unsigned char,16ul>>::destroy((uint64_t)(a2 + 30), (void *)a2[31]);
    operator delete(a2);
  }
}

uint64_t ARCaptureLensFromMakerNotesDictionary(void *a1)
{
  if (!a1)
  {
    double v2 = _ARLogGeneral_3();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)vImage_Buffer buf = 0;
      _os_log_impl(&dword_1B88A2000, v2, OS_LOG_TYPE_ERROR, "Could not retrieve MakerNotes dictionary from metadata.", buf, 2u);
    }
    goto LABEL_12;
  }
  double v1 = [a1 valueForKey:*MEMORY[0x1E4F51050]];
  double v2 = v1;
  if (!v1) {
    goto LABEL_9;
  }
  int v3 = [v1 integerValue];
  if (v3 == 4)
  {
    uint64_t v4 = 2;
    goto LABEL_13;
  }
  if (v3 == 3)
  {
    uint64_t v4 = 3;
    goto LABEL_13;
  }
  if (v3 != 2)
  {
LABEL_9:
    uint64_t v5 = _ARLogGeneral_3();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long v7 = 0;
      _os_log_impl(&dword_1B88A2000, v5, OS_LOG_TYPE_ERROR, "Could not retrieve lens information from MakerNotes dictionary.", v7, 2u);
    }

LABEL_12:
    uint64_t v4 = 0;
    goto LABEL_13;
  }
  uint64_t v4 = 1;
LABEL_13:

  return v4;
}

void sub_1B88C4274(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, void (*a18)(char *))
{
}

uint64_t ARKitDaemonLibraryCore()
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = 0;
  int v3 = &v2;
  uint64_t v4 = 0x2020000000;
  uint64_t v0 = ARKitDaemonLibraryCore_frameworkLibrary;
  uint64_t v5 = ARKitDaemonLibraryCore_frameworkLibrary;
  if (!ARKitDaemonLibraryCore_frameworkLibrary)
  {
    long long v6 = xmmword_1E6185430;
    long long v7 = *(_OWORD *)&off_1E6185440;
    v3[3] = _sl_dlopen();
    ARKitDaemonLibraryCore_frameworkLibrary = v3[3];
    uint64_t v0 = v3[3];
  }
  _Block_object_dispose(&v2, 8);
  return v0;
}

void sub_1B88C6384(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __ARKitDaemonLibraryCore_block_invoke(uint64_t a1)
{
  uint64_t result = _sl_dlopen();
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  ARKitDaemonLibraryCore_frameworkLibrary = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t ARKitDaemonLibrary()
{
  uint64_t v0 = ARKitDaemonLibraryCore();
  if (!v0)
  {
    uint64_t v2 = (void *)abort_report_np();
    free(v2);
  }
  return v0;
}

id getARDaemonClass()
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2050000000;
  uint64_t v0 = (void *)getARDaemonClass_softClass;
  uint64_t v7 = getARDaemonClass_softClass;
  if (!getARDaemonClass_softClass)
  {
    v3[0] = MEMORY[0x1E4F143A8];
    v3[1] = 3221225472;
    void v3[2] = __getARDaemonClass_block_invoke;
    v3[3] = &unk_1E6185480;
    v3[4] = &v4;
    __getARDaemonClass_block_invoke((uint64_t)v3);
    uint64_t v0 = (void *)v5[3];
  }
  id v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_1B88C6554(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

Class __getARDaemonClass_block_invoke(uint64_t a1)
{
  ARKitDaemonLibrary();
  Class result = objc_getClass("ARDaemon");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    __getARDaemonClass_block_invoke_cold_1();
  }
  getARDaemonClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

id getARDaemonReplayBlockDelegateClass()
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2050000000;
  uint64_t v0 = (void *)getARDaemonReplayBlockDelegateClass_softClass;
  uint64_t v7 = getARDaemonReplayBlockDelegateClass_softClass;
  if (!getARDaemonReplayBlockDelegateClass_softClass)
  {
    v3[0] = MEMORY[0x1E4F143A8];
    v3[1] = 3221225472;
    void v3[2] = __getARDaemonReplayBlockDelegateClass_block_invoke;
    v3[3] = &unk_1E6185480;
    v3[4] = &v4;
    __getARDaemonReplayBlockDelegateClass_block_invoke((uint64_t)v3);
    uint64_t v0 = (void *)v5[3];
  }
  id v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_1B88C6690(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

Class __getARDaemonReplayBlockDelegateClass_block_invoke(uint64_t a1)
{
  ARKitDaemonLibrary();
  Class result = objc_getClass("ARDaemonReplayBlockDelegate");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    __getARDaemonReplayBlockDelegateClass_block_invoke_cold_1();
  }
  getARDaemonReplayBlockDelegateClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

id ARDaemonLocalAnonymousListenerDaemon()
{
  id WeakRetained = objc_loadWeakRetained(&sLocalAnonymousListenerDaemon);
  return WeakRetained;
}

id AROverrideARDaemonLocalAnonymousListenerDaemon(id obj)
{
  return objc_storeWeak(&sLocalAnonymousListenerDaemon, obj);
}

id AROSVersionString()
{
  if (AROSVersionString_onceToken != -1) {
    dispatch_once(&AROSVersionString_onceToken, &__block_literal_global_11);
  }
  uint64_t v0 = (void *)AROSVersionString_buildVersion;
  return v0;
}

void __AROSVersionString_block_invoke()
{
  uint64_t v0 = MGCopyAnswer();
  id v1 = (void *)AROSVersionString_buildVersion;
  AROSVersionString_buildVersion = v0;
}

uint64_t ARInternalOSBuild()
{
  if (ARInternalOSBuild_onceToken != -1) {
    dispatch_once(&ARInternalOSBuild_onceToken, &__block_literal_global_13);
  }
  return ARInternalOSBuild_internalVersion;
}

uint64_t __ARInternalOSBuild_block_invoke()
{
  uint64_t result = os_variant_has_internal_content();
  ARInternalOSBuild_internalVersion = result;
  return result;
}

id ARDeviceString()
{
  if (ARDeviceString_onceToken != -1) {
    dispatch_once(&ARDeviceString_onceToken, &__block_literal_global_16);
  }
  uint64_t v0 = (void *)ARDeviceString_deviceString;
  return v0;
}

void __ARDeviceString_block_invoke()
{
  uint64_t v0 = MGCopyAnswer();
  id v1 = (void *)ARDeviceString_deviceString;
  ARDeviceString_deviceString = v0;
}

id ARVersionStringForIdentifier(void *a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (ARVersionStringForIdentifier_onceToken != -1) {
    dispatch_once(&ARVersionStringForIdentifier_onceToken, &__block_literal_global_21);
  }
  uint64_t v2 = [(id)ARVersionStringForIdentifier_versionDictionary objectForKeyedSubscript:v1];
  if (!v2)
  {
    int v3 = [MEMORY[0x1E4F28B50] bundleWithIdentifier:v1];
    uint64_t v4 = v3;
    if (v3)
    {
      uint64_t v5 = [v3 infoDictionary];
      uint64_t v2 = [v5 objectForKeyedSubscript:@"CFBundleVersion"];

      if (v2) {
        [(id)ARVersionStringForIdentifier_versionDictionary setObject:v2 forKeyedSubscript:v1];
      }
    }
    else
    {
      uint64_t v6 = _ARLogGeneral_4();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        int v8 = 138412290;
        id v9 = v1;
        _os_log_impl(&dword_1B88A2000, v6, OS_LOG_TYPE_ERROR, "Couldn't find bundle for name %@", (uint8_t *)&v8, 0xCu);
      }

      uint64_t v2 = 0;
    }
  }
  return v2;
}

void __ARVersionStringForIdentifier_block_invoke()
{
  uint64_t v0 = objc_opt_new();
  id v1 = (void *)ARVersionStringForIdentifier_versionDictionary;
  ARVersionStringForIdentifier_versionDictionary = v0;
}

uint64_t ARDeviceIsiPad()
{
  if (ARDeviceIsiPad_onceToken != -1) {
    dispatch_once(&ARDeviceIsiPad_onceToken, &__block_literal_global_32);
  }
  return s_deviceIsiPad;
}

void __ARDeviceIsiPad_block_invoke()
{
  id v0 = (id)MGCopyAnswer();
  s_deviceIsiPad = [v0 integerValue] == 3;
}

uint64_t AROverrideARDeviceIsiPad(uint64_t result)
{
  s_deviceIsiPad = result;
  return result;
}

uint64_t ARDeviceHasBackCamera()
{
  if (ARDeviceHasBackCamera_onceToken != -1) {
    dispatch_once(&ARDeviceHasBackCamera_onceToken, &__block_literal_global_37);
  }
  return ARDeviceHasBackCamera_s_deviceHasBackCamera;
}

uint64_t __ARDeviceHasBackCamera_block_invoke()
{
  uint64_t result = MGGetBoolAnswer();
  ARDeviceHasBackCamera_s_deviceHasBackCamera = result;
  return result;
}

uint64_t ARDeviceHasFrontCamera()
{
  if (ARDeviceHasFrontCamera_onceToken != -1) {
    dispatch_once(&ARDeviceHasFrontCamera_onceToken, &__block_literal_global_42_0);
  }
  return ARDeviceHasFrontCamera_s_deviceHasFrontCamera;
}

uint64_t __ARDeviceHasFrontCamera_block_invoke()
{
  uint64_t result = MGGetBoolAnswer();
  ARDeviceHasFrontCamera_s_deviceHasFrontCamera = result;
  return result;
}

uint64_t ARDeviceHasHomeButton()
{
  if (ARDeviceHasHomeButton_onceToken != -1) {
    dispatch_once(&ARDeviceHasHomeButton_onceToken, &__block_literal_global_47);
  }
  return s_deviceHasHomeButton;
}

uint64_t __ARDeviceHasHomeButton_block_invoke()
{
  uint64_t result = MGGetSInt32Answer();
  s_deviceHasHomeButton = result != 2;
  return result;
}

uint64_t AROverrideARDeviceHasHomeButton(uint64_t result)
{
  s_deviceHasHomeButton = result;
  return result;
}

uint64_t ARDeviceHasIsland()
{
  if (ARDeviceHasIsland_onceToken != -1) {
    dispatch_once(&ARDeviceHasIsland_onceToken, &__block_literal_global_52);
  }
  return s_deviceHasIsland;
}

uint64_t __ARDeviceHasIsland_block_invoke()
{
  uint64_t result = MGGetBoolAnswer();
  s_deviceHasIsland = result;
  return result;
}

uint64_t AROverrideARDeviceHasIsland(uint64_t result)
{
  s_deviceHasIsland = result;
  return result;
}

id ARDeviceName()
{
  if (ARDeviceName_onceToken != -1) {
    dispatch_once(&ARDeviceName_onceToken, &__block_literal_global_57);
  }
  id v0 = (void *)ARDeviceName_deviceName;
  return v0;
}

void __ARDeviceName_block_invoke()
{
  uint64_t v0 = MGCopyAnswer();
  id v1 = (void *)ARDeviceName_deviceName;
  ARDeviceName_deviceName = v0;
}

id ARMarketingDeviceName()
{
  if (ARMarketingDeviceName_onceToken != -1) {
    dispatch_once(&ARMarketingDeviceName_onceToken, &__block_literal_global_62);
  }
  uint64_t v0 = (void *)ARMarketingDeviceName_localizedDeviceName;
  return v0;
}

void __ARMarketingDeviceName_block_invoke()
{
  uint64_t v0 = MGCopyAnswer();
  id v1 = (void *)ARMarketingDeviceName_localizedDeviceName;
  ARMarketingDeviceName_localizedDeviceName = v0;
}

id ARDeviceClass()
{
  if (ARDeviceClass_onceToken != -1) {
    dispatch_once(&ARDeviceClass_onceToken, &__block_literal_global_67_0);
  }
  uint64_t v0 = (void *)ARDeviceClass_deviceClass;
  return v0;
}

void __ARDeviceClass_block_invoke()
{
  uint64_t v0 = MGCopyAnswer();
  id v1 = (void *)ARDeviceClass_deviceClass;
  ARDeviceClass_deviceClass = v0;
}

uint64_t ARPearlCameraSupported()
{
  if (ARPearlCameraSupported_onceToken != -1) {
    dispatch_once(&ARPearlCameraSupported_onceToken, &__block_literal_global_72);
  }
  return ARPearlCameraSupported_supported;
}

uint64_t __ARPearlCameraSupported_block_invoke()
{
  uint64_t result = MGGetBoolAnswer();
  ARPearlCameraSupported_supported = result;
  return result;
}

__n128 ARDisplayCenterTransformForCaptureDevicePosition(uint64_t a1)
{
  if (ARDisplayCenterTransformForCaptureDevicePosition_onceToken[0] != -1) {
    dispatch_once(ARDisplayCenterTransformForCaptureDevicePosition_onceToken, &__block_literal_global_77);
  }
  if (a1 == 2) {
    uint64_t v2 = &ARDisplayCenterTransformForCaptureDevicePosition_frontCameraFromDisplayCenter_0;
  }
  else {
    uint64_t v2 = &ARDisplayCenterTransformForCaptureDevicePosition_rearCameraFromDisplayCenter;
  }
  return (__n128)*v2;
}

void __ARDisplayCenterTransformForCaptureDevicePosition_block_invoke()
{
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  uint64_t v0 = (void *)MGCopyAnswer();
  if ((unint64_t)[v0 count] < 3)
  {
    uint64_t v7 = _ARLogGeneral_4();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      int v8 = ARDeviceString();
      *(_DWORD *)vImage_Buffer buf = 138412290;
      double v56 = *(double *)&v8;
      _os_log_impl(&dword_1B88A2000, v7, OS_LOG_TYPE_DEBUG, "No front camera offset value found for device: %@", buf, 0xCu);
    }
  }
  else
  {
    id v1 = [v0 objectAtIndexedSubscript:0];
    [v1 floatValue];
    float v54 = v2 / 1000.0;
    int v3 = [v0 objectAtIndexedSubscript:1];
    [v3 floatValue];
    float v53 = v4 / -1000.0;
    uint64_t v5 = [v0 objectAtIndexedSubscript:2];
    [v5 floatValue];
    float v52 = v6 / -1000.0;

    uint64_t v7 = _ARLogGeneral_4();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)vImage_Buffer buf = 134218496;
      double v56 = v54;
      __int16 v57 = 2048;
      double v58 = v53;
      __int16 v59 = 2048;
      double v60 = v52;
      _os_log_impl(&dword_1B88A2000, v7, OS_LOG_TYPE_DEBUG, "Using front camera offset values (%f, %f, %f).", buf, 0x20u);
    }
  }

  id v9 = (void *)MGCopyAnswer();
  if ((unint64_t)[v9 count] < 2)
  {
    uint64_t v10 = _ARLogGeneral_4();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      size_t v27 = ARDeviceString();
      *(_DWORD *)vImage_Buffer buf = 138412290;
      double v56 = *(double *)&v27;
      _os_log_impl(&dword_1B88A2000, v10, OS_LOG_TYPE_DEBUG, "No front camera rotation value found in MobileGetStalt for device: %@", buf, 0xCu);
    }
  }
  else
  {
    uint64_t v10 = [v9 objectAtIndexedSubscript:0];
    [v10 floatValue];
    float v12 = v11 * 3.14159265 / 180.0;
    _Q0 = vmulq_n_f32((float32x4_t)xmmword_1B8A2B0D0, __sincosf_stret(v12 * -0.5).__sinval);
    _S2 = _Q0.i32[1];
    _S4 = _Q0.i32[2];
    __asm
    {
      FMLS            S3, S4, V0.S[2]
      FMLA            S5, S2, V0.S[1]
      FMLS            S5, S0, V0.S[0]
      FMLA            S16, S4, V0.S[1]
      FMLA            S1, S4, V0.S[2]
      FMLS            S1, S0, V0.S[0]
      FMLS            S1, S2, V0.S[1]
    }
  }

  ARMatrix4x4FromRotationAndTranslation();
  ARDisplayCenterTransformForCaptureDevicePosition_frontCameraFromDisplayCenter_0 = v28;
  ARDisplayCenterTransformForCaptureDevicePosition_frontCameraFromDisplayCenter_1 = v29;
  ARDisplayCenterTransformForCaptureDevicePosition_frontCameraFromDisplayCenter_2 = v30;
  ARDisplayCenterTransformForCaptureDevicePosition_frontCameraFromDisplayCenter_3 = v31;
  long long v32 = *(_OWORD *)(MEMORY[0x1E4F149A0] + 16);
  ARDisplayCenterTransformForCaptureDevicePosition_rearCameraFromDisplayCenter = *MEMORY[0x1E4F149A0];
  xmmword_1E9EED300 = v32;
  long long v33 = *(_OWORD *)(MEMORY[0x1E4F149A0] + 48);
  xmmword_1E9EED310 = *(_OWORD *)(MEMORY[0x1E4F149A0] + 32);
  xmmword_1E9EED320 = v33;
  size_t v34 = (void *)MGCopyAnswer();
  if ((unint64_t)[v34 count] < 3)
  {
    uint64_t v47 = _ARLogGeneral_4();
    if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
    {
      float32x4_t v48 = ARDeviceString();
      *(_DWORD *)vImage_Buffer buf = 138412290;
      double v56 = *(double *)&v48;
      _os_log_impl(&dword_1B88A2000, v47, OS_LOG_TYPE_ERROR, "No rear camera offset value found for device: %@", buf, 0xCu);
    }
  }
  else
  {
    size_t v35 = [v34 objectAtIndexedSubscript:0];
    [v35 floatValue];
    float v51 = v36 / 1000.0;
    CFDictionaryRef v37 = [v34 objectAtIndexedSubscript:1];
    [v37 floatValue];
    float v49 = v38 / -1000.0;
    uint64_t v39 = [v34 objectAtIndexedSubscript:2];
    [v39 floatValue];
    float v50 = v40 / 1000.0;

    float32x4_t v41 = _ARLogGeneral_4();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)vImage_Buffer buf = 134218496;
      double v56 = v51;
      __int16 v57 = 2048;
      double v58 = v49;
      __int16 v59 = 2048;
      double v60 = v50;
      _os_log_impl(&dword_1B88A2000, v41, OS_LOG_TYPE_DEBUG, "Using rear camera offset values (%f, %f, %f).", buf, 0x20u);
    }

    __int16 v42 = _ARLogGeneral_4();
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)vImage_Buffer buf = 134218496;
      double v56 = v51;
      __int16 v57 = 2048;
      double v58 = v49;
      __int16 v59 = 2048;
      double v60 = v50;
      _os_log_impl(&dword_1B88A2000, v42, OS_LOG_TYPE_DEBUG, "Using rear camera offset values (%f, %f, %f).", buf, 0x20u);
    }

    ARMatrix4x4FromRotationAndTranslation();
    ARDisplayCenterTransformForCaptureDevicePosition_rearCameraFromDisplayCenter = v43;
    xmmword_1E9EED300 = v44;
    xmmword_1E9EED310 = v45;
    xmmword_1E9EED320 = v46;
  }
}

double ARFrontWideCameraTransformFromBackWideAngleCameraTransform(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  if (ARDisplayCenterTransformForCaptureDevicePosition_onceToken[0] != -1) {
    dispatch_once(ARDisplayCenterTransformForCaptureDevicePosition_onceToken, &__block_literal_global_77);
  }
  float32x4_t v13 = (float32x4_t)xmmword_1E9EED300;
  float32x4_t v15 = (float32x4_t)ARDisplayCenterTransformForCaptureDevicePosition_rearCameraFromDisplayCenter;
  float32x4_t v9 = (float32x4_t)xmmword_1E9EED310;
  float32x4_t v11 = (float32x4_t)xmmword_1E9EED320;
  v27.columns[2] = (simd_float4)ARDisplayCenterTransformForCaptureDevicePosition_frontCameraFromDisplayCenter_2;
  v27.columns[1] = (simd_float4)ARDisplayCenterTransformForCaptureDevicePosition_frontCameraFromDisplayCenter_1;
  v27.columns[0] = (simd_float4)ARDisplayCenterTransformForCaptureDevicePosition_frontCameraFromDisplayCenter_0;
  v27.columns[3] = (simd_float4)ARDisplayCenterTransformForCaptureDevicePosition_frontCameraFromDisplayCenter_3;
  simd_float4x4 v28 = __invert_f4(v27);
  uint64_t v4 = 0;
  simd_float4x4 v25 = v28;
  memset(&v26, 0, sizeof(v26));
  do
  {
    v26.columns[v4] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v15, COERCE_FLOAT(*(_OWORD *)&v25.columns[v4])), v13, *(float32x2_t *)v25.columns[v4].f32, 1), v9, (float32x4_t)v25.columns[v4], 2), v11, (float32x4_t)v25.columns[v4], 3);
    ++v4;
  }
  while (v4 != 4);
  uint64_t v5 = 0;
  simd_float4x4 v25 = v26;
  memset(&v26, 0, sizeof(v26));
  do
  {
    v26.columns[v5] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a1, COERCE_FLOAT(*(_OWORD *)&v25.columns[v5])), a2, *(float32x2_t *)v25.columns[v5].f32, 1), a3, (float32x4_t)v25.columns[v5], 2), a4, (float32x4_t)v25.columns[v5], 3);
    ++v5;
  }
  while (v5 != 4);
  float32x4_t v22 = (float32x4_t)v26.columns[1];
  float32x4_t v24 = (float32x4_t)v26.columns[0];
  float32x4_t v18 = (float32x4_t)v26.columns[3];
  float32x4_t v20 = (float32x4_t)v26.columns[2];
  simd_float4x4 v29 = *(simd_float4x4 *)*(void *)&MEMORY[0x1E4F149A0];
  simd_float4 v14 = v29.columns[1];
  simd_float4 v16 = *(simd_float4 *)MEMORY[0x1E4F149A0];
  v29.columns[2].i32[2] = -1.0;
  simd_float4 v10 = v29.columns[2];
  simd_float4 v12 = v29.columns[3];
  simd_float4x4 v30 = __invert_f4(*MEMORY[0x1E4F149A0]);
  uint64_t v6 = 0;
  v25.columns[0] = v16;
  v25.columns[1] = v14;
  v25.columns[2] = v10;
  v25.columns[3] = v12;
  memset(&v26, 0, sizeof(v26));
  do
  {
    v26.columns[v6] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v24, COERCE_FLOAT(*(_OWORD *)&v25.columns[v6])), v22, *(float32x2_t *)v25.columns[v6].f32, 1), v20, (float32x4_t)v25.columns[v6], 2), v18, (float32x4_t)v25.columns[v6], 3);
    ++v6;
  }
  while (v6 != 4);
  uint64_t v7 = 0;
  simd_float4x4 v25 = v26;
  memset(&v26, 0, sizeof(v26));
  do
  {
    v26.columns[v7] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v30.columns[0], COERCE_FLOAT(*(_OWORD *)&v25.columns[v7])), (float32x4_t)v30.columns[1], *(float32x2_t *)v25.columns[v7].f32, 1), (float32x4_t)v30.columns[2], (float32x4_t)v25.columns[v7], 2), (float32x4_t)v30.columns[3], (float32x4_t)v25.columns[v7], 3);
    ++v7;
  }
  while (v7 != 4);
  return *(double *)v26.columns[0].i64;
}

double ARFrontWideCameraTransformFromBackWideAngleCameraTransformWithZFlip(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  if (ARDisplayCenterTransformForCaptureDevicePosition_onceToken[0] != -1) {
    dispatch_once(ARDisplayCenterTransformForCaptureDevicePosition_onceToken, &__block_literal_global_77);
  }
  float32x4_t v17 = (float32x4_t)xmmword_1E9EED300;
  float32x4_t v18 = (float32x4_t)ARDisplayCenterTransformForCaptureDevicePosition_rearCameraFromDisplayCenter;
  float32x4_t v15 = (float32x4_t)xmmword_1E9EED310;
  float32x4_t v16 = (float32x4_t)xmmword_1E9EED320;
  v25.columns[2] = (simd_float4)ARDisplayCenterTransformForCaptureDevicePosition_frontCameraFromDisplayCenter_2;
  v25.columns[1] = (simd_float4)ARDisplayCenterTransformForCaptureDevicePosition_frontCameraFromDisplayCenter_1;
  v25.columns[0] = (simd_float4)ARDisplayCenterTransformForCaptureDevicePosition_frontCameraFromDisplayCenter_0;
  v25.columns[3] = (simd_float4)ARDisplayCenterTransformForCaptureDevicePosition_frontCameraFromDisplayCenter_3;
  simd_float4x4 v26 = __invert_f4(v25);
  uint64_t v4 = 0;
  simd_float4x4 v23 = v26;
  memset(&v24, 0, sizeof(v24));
  do
  {
    v24.columns[v4] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v18, COERCE_FLOAT(*(_OWORD *)&v23.columns[v4])), v17, *(float32x2_t *)v23.columns[v4].f32, 1), v15, (float32x4_t)v23.columns[v4], 2), v16, (float32x4_t)v23.columns[v4], 3);
    ++v4;
  }
  while (v4 != 4);
  uint64_t v5 = 0;
  simd_float4x4 v23 = v24;
  memset(&v24, 0, sizeof(v24));
  do
  {
    v24.columns[v5] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a1, COERCE_FLOAT(*(_OWORD *)&v23.columns[v5])), a2, *(float32x2_t *)v23.columns[v5].f32, 1), a3, (float32x4_t)v23.columns[v5], 2), a4, (float32x4_t)v23.columns[v5], 3);
    ++v5;
  }
  while (v5 != 4);
  uint64_t v6 = 0;
  float32x4_t v7 = (float32x4_t)v24.columns[0];
  float32x4_t v8 = (float32x4_t)v24.columns[1];
  float32x4_t v9 = (float32x4_t)v24.columns[2];
  float32x4_t v10 = (float32x4_t)v24.columns[3];
  simd_float4 v11 = *(simd_float4 *)(MEMORY[0x1E4F149A0] + 32);
  simd_float4 v12 = *(simd_float4 *)(MEMORY[0x1E4F149A0] + 48);
  v11.i32[2] = -1.0;
  simd_float4 v13 = *(simd_float4 *)(MEMORY[0x1E4F149A0] + 16);
  v23.columns[0] = (simd_float4)*MEMORY[0x1E4F149A0];
  v23.columns[1] = v13;
  v23.columns[2] = v11;
  v23.columns[3] = v12;
  memset(&v24, 0, sizeof(v24));
  do
  {
    v24.columns[v6] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v7, COERCE_FLOAT(*(_OWORD *)&v23.columns[v6])), v8, *(float32x2_t *)v23.columns[v6].f32, 1), v9, (float32x4_t)v23.columns[v6], 2), v10, (float32x4_t)v23.columns[v6], 3);
    ++v6;
  }
  while (v6 != 4);
  return *(double *)v24.columns[0].i64;
}

uint64_t ARDeviceHasANE()
{
  if (ARAppleNeuralEngine_onceToken[0] != -1) {
    dispatch_once(ARAppleNeuralEngine_onceToken, &__block_literal_global_88_0);
  }
  return s_deviceSupportsANE;
}

uint64_t AROverrideARAppleNeuralEngine(uint64_t result)
{
  s_deviceSupportsANE = result;
  return result;
}

id ARDeviceANEVersion()
{
  if ([MEMORY[0x1E4F4E040] hasANE])
  {
    uint64_t v0 = [MEMORY[0x1E4F4E040] aneSubType];
  }
  else
  {
    uint64_t v0 = 0;
  }
  return v0;
}

uint64_t ARIsANEVersionEqualOrPriorToH12()
{
  if (ARIsANEVersionEqualOrPriorToH12_onceToken[0] != -1) {
    dispatch_once(ARIsANEVersionEqualOrPriorToH12_onceToken, &__block_literal_global_94);
  }
  return ARIsANEVersionEqualOrPriorToH12_s_isANEVersionEqualOrPriorToH12;
}

void __ARIsANEVersionEqualOrPriorToH12_block_invoke()
{
  ARDeviceANEVersion();
  id v5 = (id)objc_claimAutoreleasedReturnValue();
  uint64_t v0 = [v5 lowercaseString];
  if ([v0 isEqualToString:@"m9"])
  {
    char v1 = 1;
  }
  else
  {
    float v2 = [v5 lowercaseString];
    if ([v2 isEqualToString:@"h10"])
    {
      char v1 = 1;
    }
    else
    {
      int v3 = [v5 lowercaseString];
      if ([v3 isEqualToString:@"h11"])
      {
        char v1 = 1;
      }
      else
      {
        uint64_t v4 = [v5 lowercaseString];
        char v1 = [v4 isEqualToString:@"h12"];
      }
    }
  }
  ARIsANEVersionEqualOrPriorToH12_s_isANEVersionEqualOrPriorToH12 = v1;
}

uint64_t ARIsANEE5RTAvailable()
{
  return 1;
}

id ARMLModelPath(void *a1, int a2)
{
  id v3 = a1;
  if ((a2 & 1) == 0) {
    goto LABEL_5;
  }
  uint64_t v4 = [MEMORY[0x1E4F4E040] aneSubType];
  if (![MEMORY[0x1E4F4E040] hasANE]
    || ([v4 isEqualToString:@"m9"] & 1) != 0)
  {

LABEL_5:
    id v5 = v3;
    goto LABEL_6;
  }
  float32x4_t v9 = [v4 uppercaseString];
  float32x4_t v10 = [@"_" stringByAppendingString:v9];
  id v5 = [v3 stringByAppendingString:v10];

LABEL_6:
  uint64_t v6 = ARKitCoreBundle();
  float32x4_t v7 = [MEMORY[0x1E4F4E040] aneSubType];
  if (a2)
  {
    if ([MEMORY[0x1E4F4E040] hasANE]
      && ([v7 isEqualToString:@"m9"] & 1) == 0)
    {
      id v11 = [NSString alloc];
      simd_float4 v12 = [v7 uppercaseString];
      float32x4_t v8 = (__CFString *)[v11 initWithFormat:@"MLModels/%@", v12];
    }
    else
    {
      float32x4_t v8 = @"MLModels/Debug";
    }
  }
  else
  {
    float32x4_t v8 = @"MLModels/NonPrecompiled";
  }

  simd_float4 v13 = [v6 pathForResource:v5 ofType:@"mlmodelc" inDirectory:v8];
  simd_float4 v14 = [v13 stringByAppendingPathComponent:@"model.espresso.net"];

  return v14;
}

id ARKitCoreBundle()
{
  if (ARKitCoreBundle_onceToken != -1) {
    dispatch_once(&ARKitCoreBundle_onceToken, &__block_literal_global_288);
  }
  uint64_t v0 = (void *)ARKitCoreBundle_arkitCoreBundle;
  return v0;
}

uint64_t ARIsAirPlaneModeEnabled()
{
  return MGGetBoolAnswer();
}

uint64_t ARDeviceSupportsJasper()
{
  if (ARDeviceSupportsJasper_onceToken != -1) {
    dispatch_once(&ARDeviceSupportsJasper_onceToken, &__block_literal_global_117);
  }
  return s_deviceSupportsJasper;
}

BOOL __ARDeviceSupportsJasper_block_invoke()
{
  BOOL result = +[ARKitUserDefaults BOOLForKey:@"com.apple.arkit.jasper.enabled"];
  s_deviceSupportsJasper = result;
  return result;
}

uint64_t AROverrideARDeviceSupportsJasper(uint64_t result)
{
  s_deviceSupportsJasper = result;
  return result;
}

uint64_t ARShouldSupport1440pAndAutofocus()
{
  if (ARShouldSupport1440pAndAutofocus_onceToken != -1) {
    dispatch_once(&ARShouldSupport1440pAndAutofocus_onceToken, &__block_literal_global_120);
  }
  return ARShouldSupport1440pAndAutofocus_cachedReturn;
}

void __ARShouldSupport1440pAndAutofocus_block_invoke()
{
  if (dyld_program_sdk_at_least())
  {
    BOOL v0 = 1;
  }
  else
  {
    if (ARDeviceSupportsJasper_onceToken != -1) {
      dispatch_once(&ARDeviceSupportsJasper_onceToken, &__block_literal_global_117);
    }
    BOOL v0 = s_deviceSupportsJasper != 0;
  }
  ARShouldSupport1440pAndAutofocus_cachedReturn = v0;
}

uint64_t ARLinkedOnOrAfterPeace()
{
  if (ARLinkedOnOrAfterPeace_onceToken != -1) {
    dispatch_once(&ARLinkedOnOrAfterPeace_onceToken, &__block_literal_global_122);
  }
  return ARLinkedOnOrAfterPeace_cachedReturn;
}

uint64_t __ARLinkedOnOrAfterPeace_block_invoke()
{
  uint64_t result = dyld_program_sdk_at_least();
  ARLinkedOnOrAfterPeace_cachedReturn = result;
  return result;
}

uint64_t ARLinkedOnOrAfterPeaceE()
{
  if (ARLinkedOnOrAfterPeaceE_onceToken != -1) {
    dispatch_once(&ARLinkedOnOrAfterPeaceE_onceToken, &__block_literal_global_124);
  }
  return ARLinkedOnOrAfterPeaceE_cachedReturn;
}

uint64_t __ARLinkedOnOrAfterPeaceE_block_invoke()
{
  uint64_t result = dyld_program_sdk_at_least();
  ARLinkedOnOrAfterPeaceE_cachedReturn = result;
  return result;
}

uint64_t ARLinkedOnOrAfterYukon()
{
  if (ARLinkedOnOrAfterYukon_onceToken != -1) {
    dispatch_once(&ARLinkedOnOrAfterYukon_onceToken, &__block_literal_global_126);
  }
  return ARLinkedOnOrAfterYukon_cachedReturn;
}

uint64_t __ARLinkedOnOrAfterYukon_block_invoke()
{
  uint64_t result = dyld_program_sdk_at_least();
  ARLinkedOnOrAfterYukon_cachedReturn = result;
  return result;
}

uint64_t ARLinkedOnOrAfterAzul()
{
  if (ARLinkedOnOrAfterAzul_onceToken != -1) {
    dispatch_once(&ARLinkedOnOrAfterAzul_onceToken, &__block_literal_global_128);
  }
  BOOL v0 = (void *)ARLinkedOnOrAfterAzul_forceAssumeLinkedOnOrAfterAzul;
  if (!ARLinkedOnOrAfterAzul_forceAssumeLinkedOnOrAfterAzul) {
    return ARLinkedOnOrAfterAzul_cachedReturn;
  }
  return [v0 BOOLValue];
}

void __ARLinkedOnOrAfterAzul_block_invoke()
{
  ARLinkedOnOrAfterAzul_cachedReturn = dyld_program_sdk_at_least();
  uint64_t v0 = +[ARKitUserDefaults objectForKey:@"com.apple.arkit.forceLinkedOnOrAfterAzul"];
  char v1 = (void *)ARLinkedOnOrAfterAzul_forceAssumeLinkedOnOrAfterAzul;
  ARLinkedOnOrAfterAzul_forceAssumeLinkedOnOrAfterAzul = v0;
}

uint64_t ARLinkedOnOrAfterAzulC()
{
  if (ARLinkedOnOrAfterAzulC_onceToken[0] != -1) {
    dispatch_once(ARLinkedOnOrAfterAzulC_onceToken, &__block_literal_global_130);
  }
  return ARLinkedOnOrAfterAzulC_cachedReturn;
}

uint64_t __ARLinkedOnOrAfterAzulC_block_invoke()
{
  uint64_t result = dyld_program_sdk_at_least();
  ARLinkedOnOrAfterAzulC_cachedReturn = result;
  return result;
}

uint64_t ARLinkedOnOrAfterAzulE()
{
  if (ARLinkedOnOrAfterAzulE_onceToken != -1) {
    dispatch_once(&ARLinkedOnOrAfterAzulE_onceToken, &__block_literal_global_132);
  }
  return ARLinkedOnOrAfterAzulE_cachedReturn;
}

uint64_t __ARLinkedOnOrAfterAzulE_block_invoke()
{
  uint64_t result = dyld_program_sdk_at_least();
  ARLinkedOnOrAfterAzulE_cachedReturn = result;
  return result;
}

uint64_t ARLinkedOnOrAfterSydney()
{
  if (ARLinkedOnOrAfterSydney_onceToken != -1) {
    dispatch_once(&ARLinkedOnOrAfterSydney_onceToken, &__block_literal_global_134);
  }
  return ARLinkedOnOrAfterSydney_cachedReturn;
}

uint64_t __ARLinkedOnOrAfterSydney_block_invoke()
{
  uint64_t result = dyld_program_sdk_at_least();
  ARLinkedOnOrAfterSydney_cachedReturn = result;
  return result;
}

uint64_t ARLinkedOnOrAfterCrystal()
{
  if (ARLinkedOnOrAfterCrystal_onceToken != -1) {
    dispatch_once(&ARLinkedOnOrAfterCrystal_onceToken, &__block_literal_global_136);
  }
  return ARLinkedOnOrAfterCrystal_cachedReturn;
}

uint64_t __ARLinkedOnOrAfterCrystal_block_invoke()
{
  uint64_t result = dyld_program_sdk_at_least();
  ARLinkedOnOrAfterCrystal_cachedReturn = result;
  return result;
}

uint64_t ARLinkedOnOrAfterConstellation()
{
  if (ARLinkedOnOrAfterConstellation_onceToken != -1) {
    dispatch_once(&ARLinkedOnOrAfterConstellation_onceToken, &__block_literal_global_138);
  }
  return ARLinkedOnOrAfterConstellation_cachedReturn;
}

uint64_t __ARLinkedOnOrAfterConstellation_block_invoke()
{
  uint64_t result = dyld_program_sdk_at_least();
  ARLinkedOnOrAfterConstellation_cachedReturn = result;
  return result;
}

double ARDispatchAfterLeewayForTimeInterval(double a1)
{
  double v1 = fmax(a1 * 0.1, 0.001);
  BOOL v2 = a1 > 0.0;
  double result = 0.0;
  if (v2) {
    return v1;
  }
  return result;
}

double ARConvertTicksToSeconds(unint64_t a1)
{
  if (ARConvertTicksToSeconds_onceToken != -1) {
    dispatch_once(&ARConvertTicksToSeconds_onceToken, &__block_literal_global_140);
  }
  return *(double *)&ARConvertTicksToSeconds_ticksToSecond * (double)a1;
}

double __ARConvertTicksToSeconds_block_invoke()
{
  mach_timebase_info info = 0;
  if (!mach_timebase_info(&info))
  {
    LODWORD(result) = info.numer;
    LODWORD(v1) = info.denom;
    double result = (double)*(unint64_t *)&result / (double)v1 / 1000000000.0;
    ARConvertTicksToSeconds_ticksToSecond = *(void *)&result;
  }
  return result;
}

unint64_t ARConvertSecondsToTicks(double a1)
{
  if (ARConvertSecondsToTicks_onceToken != -1) {
    dispatch_once(&ARConvertSecondsToTicks_onceToken, &__block_literal_global_142);
  }
  return (unint64_t)(*(double *)&ARConvertSecondsToTicks_secondsToTick * a1);
}

double __ARConvertSecondsToTicks_block_invoke()
{
  mach_timebase_info info = 0;
  if (!mach_timebase_info(&info))
  {
    LODWORD(v1) = info.numer;
    LODWORD(result) = info.denom;
    double result = (double)*(unint64_t *)&result / (double)v1 * 1000000000.0;
    ARConvertSecondsToTicks_secondsToTicuint64_t k = *(void *)&result;
  }
  return result;
}

uint64_t ARConvertMCTToMAT(uint64_t a1)
{
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  if (!mach_get_times()) {
    return a1 - v5 + v6;
  }
  BOOL v2 = _ARLogGeneral_4();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl(&dword_1B88A2000, v2, OS_LOG_TYPE_ERROR, "mach_get_times is failing for ARConvertMCTToMAT", v4, 2u);
  }

  return a1;
}

uint64_t ARConvertMATToMCT(uint64_t a1)
{
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  if (!mach_get_times()) {
    return v5 + a1 - v6;
  }
  BOOL v2 = _ARLogGeneral_4();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl(&dword_1B88A2000, v2, OS_LOG_TYPE_ERROR, "mach_get_times is failing for ARConvertMATToMCT", v4, 2u);
  }

  return a1;
}

dispatch_queue_t ARCreateFixedPriorityDispatchQueueWithPropagatedQOS(const char *a1, dispatch_qos_class_t a2, int a3)
{
  inactive = dispatch_workloop_create_inactive(a1);
  dispatch_workloop_set_qos_class_floor();
  dispatch_activate(inactive);
  float32x4_t v7 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  float32x4_t v8 = dispatch_queue_attr_make_with_qos_class(v7, a2, a3);

  dispatch_queue_t v9 = dispatch_queue_create_with_target_V2(a1, v8, inactive);
  return v9;
}

dispatch_queue_t ARCreateNonFixedPriorityDispatchQueue(const char *a1)
{
  inactive = dispatch_workloop_create_inactive(a1);
  dispatch_workloop_set_qos_class_floor();
  dispatch_activate(inactive);
  id v3 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  dispatch_queue_t v4 = dispatch_queue_create_with_target_V2(a1, v3, inactive);

  return v4;
}

dispatch_queue_t ARCreateNonFixedPriorityConcurrentDispatchQueue(const char *a1)
{
  inactive = dispatch_workloop_create_inactive(a1);
  dispatch_workloop_set_qos_class_floor();
  dispatch_activate(inactive);
  id v3 = dispatch_queue_attr_make_with_autorelease_frequency(MEMORY[0x1E4F14430], DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  dispatch_queue_t v4 = dispatch_queue_create_with_target_V2(a1, v3, inactive);

  return v4;
}

BOOL ARDispatchQueueIsCurrentDispatchQueue(NSObject *a1)
{
  label = dispatch_queue_get_label(a1);
  BOOL v2 = dispatch_queue_get_label(0);
  return ARStringIsEqualToString(label, v2);
}

BOOL ARStringIsEqualToString(const char *a1, const char *a2)
{
  size_t v4 = strlen(a1);
  return strlen(a2) == v4 && strncmp(a1, a2, v4) == 0;
}

BOOL ARDispatchQueueIsEqualToDispatchQueue(NSObject *a1, NSObject *a2)
{
  label = dispatch_queue_get_label(a1);
  size_t v4 = dispatch_queue_get_label(a2);
  return ARStringIsEqualToString(label, v4);
}

uint64_t ARGetMemoryFootprint(void *a1, void *a2)
{
  int v29 = 0;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v14 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  *(_OWORD *)task_info_out = 0u;
  long long v7 = 0u;
  mach_msg_type_number_t task_info_outCnt = 93;
  uint64_t result = task_info(*MEMORY[0x1E4F14960], 0x16u, task_info_out, &task_info_outCnt);
  if (!result)
  {
    *a1 = v15;
    *a2 = *((void *)&v16 + 1);
  }
  return result;
}

uint64_t ARRGBFaceTrackingEnabled()
{
  if (ARRGBFaceTrackingEnabled_onceToken[0] != -1) {
    dispatch_once(ARRGBFaceTrackingEnabled_onceToken, &__block_literal_global_144);
  }
  return ARRGBFaceTrackingEnabled_faceTrackingEnabled;
}

void __ARRGBFaceTrackingEnabled_block_invoke()
{
  if (+[ARKitUserDefaults BOOLForKey:@"com.apple.arkit.faceTracking.rgbOnly.enabled"])
  {
    if (ARAppleNeuralEngine_onceToken[0] != -1) {
      dispatch_once(ARAppleNeuralEngine_onceToken, &__block_literal_global_88_0);
    }
    BOOL v0 = s_deviceSupportsANE != 0;
  }
  else
  {
    BOOL v0 = 0;
  }
  ARRGBFaceTrackingEnabled_faceTrackingEnabled = v0;
}

id ARFaceTrackingDevice()
{
  if (ARFaceTrackingDevice_onceToken[0] != -1) {
    dispatch_once(ARFaceTrackingDevice_onceToken, &__block_literal_global_146);
  }
  BOOL v0 = (void *)ARFaceTrackingDevice_deviceType;
  return v0;
}

void __ARFaceTrackingDevice_block_invoke()
{
  if (ARRGBFaceTrackingEnabled_onceToken[0] != -1) {
    dispatch_once(ARRGBFaceTrackingEnabled_onceToken, &__block_literal_global_144);
  }
  if (!ARRGBFaceTrackingEnabled_faceTrackingEnabled) {
    goto LABEL_7;
  }
  if (ARPearlCameraSupported_onceToken != -1) {
    dispatch_once(&ARPearlCameraSupported_onceToken, &__block_literal_global_72);
  }
  if (!ARPearlCameraSupported_supported) {
    BOOL v0 = (void **)MEMORY[0x1E4F15830];
  }
  else {
LABEL_7:
  }
    BOOL v0 = (void **)MEMORY[0x1E4F15820];
  unint64_t v1 = *v0;
  objc_storeStrong((id *)&ARFaceTrackingDevice_deviceType, v1);
}

BOOL ARHasH10()
{
  BOOL v0 = (void *)MGCopyAnswer();
  BOOL v1 = [v0 integerValue] == 32789;

  return v1;
}

uint64_t ARDeviceRequiresFrameTrendControllerWorkaround()
{
  if (!dyld_program_sdk_at_least()) {
    return 1;
  }
  BOOL v0 = (void *)MGCopyAnswer();
  if (v0) {
    uint64_t v1 = [&unk_1F125BC78 containsObject:v0];
  }
  else {
    uint64_t v1 = 1;
  }

  return v1;
}

uint64_t ARDeviceSupportsMulticamMode()
{
  uint64_t result = [MEMORY[0x1E4F16470] isMultiCamSupported];
  if (result)
  {
    if (ARLinkedOnOrAfterYukon_onceToken != -1) {
      dispatch_once(&ARLinkedOnOrAfterYukon_onceToken, &__block_literal_global_126);
    }
    return ARLinkedOnOrAfterYukon_cachedReturn != 0;
  }
  return result;
}

uint64_t ARDeviceSupportsMulticamSessionWithVideoFormats(void *a1)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (ARDeviceSupportsMulticamMode())
  {
    long long v31 = objc_msgSend(v1, "ar_map:", &__block_literal_global_160);
    BOOL v2 = objc_msgSend(MEMORY[0x1E4F1CAD0], "setWithArray:");
    id v3 = (void *)MEMORY[0x1E4F16448];
    simd_float4x4 v30 = v2;
    size_t v4 = [v2 allObjects];
    uint64_t v5 = [v3 discoverySessionWithDeviceTypes:v4 mediaType:*MEMORY[0x1E4F15C18] position:0];

    int v29 = v5;
    [v5 supportedMultiCamDeviceSets];
    long long v49 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v52 = 0u;
    obuint64_t j = (id)objc_claimAutoreleasedReturnValue();
    uint64_t v6 = [obj countByEnumeratingWithState:&v49 objects:v55 count:16];
    if (v6)
    {
      uint64_t v7 = v6;
      uint64_t v8 = *(void *)v50;
      id v38 = v1;
      uint64_t v32 = *(void *)v50;
      while (2)
      {
        uint64_t v9 = 0;
        uint64_t v33 = v7;
        do
        {
          if (*(void *)v50 != v8) {
            objc_enumerationMutation(obj);
          }
          long long v10 = *(void **)(*((void *)&v49 + 1) + 8 * v9);
          unint64_t v11 = [v10 count];
          if (v11 >= [v1 count])
          {
            uint64_t v35 = v9;
            CFDictionaryRef v37 = objc_opt_new();
            long long v45 = 0u;
            long long v46 = 0u;
            long long v47 = 0u;
            long long v48 = 0u;
            id v36 = v10;
            uint64_t v40 = [v36 countByEnumeratingWithState:&v45 objects:v54 count:16];
            if (v40)
            {
              uint64_t v39 = *(void *)v46;
              do
              {
                for (uint64_t i = 0; i != v40; ++i)
                {
                  if (*(void *)v46 != v39) {
                    objc_enumerationMutation(v36);
                  }
                  long long v13 = *(void **)(*((void *)&v45 + 1) + 8 * i);
                  long long v41 = 0u;
                  long long v42 = 0u;
                  long long v43 = 0u;
                  long long v44 = 0u;
                  id v14 = v1;
                  uint64_t v15 = [v14 countByEnumeratingWithState:&v41 objects:v53 count:16];
                  if (v15)
                  {
                    uint64_t v16 = v15;
                    uint64_t v17 = *(void *)v42;
                    while (2)
                    {
                      for (uint64_t j = 0; j != v16; ++j)
                      {
                        if (*(void *)v42 != v17) {
                          objc_enumerationMutation(v14);
                        }
                        long long v19 = *(void **)(*((void *)&v41 + 1) + 8 * j);
                        uint64_t v20 = [v13 position];
                        if (v20 == [v19 captureDevicePosition])
                        {
                          long long v21 = [v13 deviceType];
                          long long v22 = [v19 captureDeviceType];
                          int v23 = [v21 isEqualToString:v22];

                          if (v23)
                          {
                            [v37 addObject:v19];
                            goto LABEL_24;
                          }
                        }
                      }
                      uint64_t v16 = [v14 countByEnumeratingWithState:&v41 objects:v53 count:16];
                      if (v16) {
                        continue;
                      }
                      break;
                    }
                  }
LABEL_24:

                  id v1 = v38;
                }
                uint64_t v40 = [v36 countByEnumeratingWithState:&v45 objects:v54 count:16];
              }
              while (v40);
            }

            uint64_t v24 = [v37 count];
            uint64_t v25 = [v1 count];

            BOOL v26 = v24 == v25;
            uint64_t v8 = v32;
            uint64_t v7 = v33;
            uint64_t v9 = v35;
            if (v26)
            {
              uint64_t v27 = 1;
              goto LABEL_32;
            }
          }
          ++v9;
        }
        while (v9 != v7);
        uint64_t v7 = [obj countByEnumeratingWithState:&v49 objects:v55 count:16];
        if (v7) {
          continue;
        }
        break;
      }
    }
    uint64_t v27 = 0;
LABEL_32:
  }
  else
  {
    uint64_t v27 = 0;
  }

  return v27;
}

uint64_t __ARDeviceSupportsMulticamSessionWithVideoFormats_block_invoke(uint64_t a1, void *a2)
{
  return [a2 captureDeviceType];
}

uint64_t ARDeviceSupportsMulticamWithTripleRGBStreaming()
{
  if (ARDeviceSupportsMulticamWithTripleRGBStreaming_onceToken != -1) {
    dispatch_once(&ARDeviceSupportsMulticamWithTripleRGBStreaming_onceToken, &__block_literal_global_165);
  }
  return ARDeviceSupportsMulticamWithTripleRGBStreaming_supportsMulticamWithTripleRGBStreaming;
}

void __ARDeviceSupportsMulticamWithTripleRGBStreaming_block_invoke()
{
  v9[3] = *MEMORY[0x1E4F143B8];
  BOOL v0 = [ARVideoFormat alloc];
  uint64_t v1 = *MEMORY[0x1E4F15830];
  double v2 = *MEMORY[0x1E4F1DB30];
  double v3 = *(double *)(MEMORY[0x1E4F1DB30] + 8);
  size_t v4 = -[ARVideoFormat initWithImageResolution:captureDevicePosition:captureDeviceType:](v0, "initWithImageResolution:captureDevicePosition:captureDeviceType:", 1, *MEMORY[0x1E4F15830], *MEMORY[0x1E4F1DB30], v3);
  v9[0] = v4;
  uint64_t v5 = [ARVideoFormat alloc];
  uint64_t v6 = -[ARVideoFormat initWithImageResolution:captureDevicePosition:captureDeviceType:](v5, "initWithImageResolution:captureDevicePosition:captureDeviceType:", 1, *MEMORY[0x1E4F15828], v2, v3, v4);
  v9[1] = v6;
  uint64_t v7 = -[ARVideoFormat initWithImageResolution:captureDevicePosition:captureDeviceType:]([ARVideoFormat alloc], "initWithImageResolution:captureDevicePosition:captureDeviceType:", 2, v1, v2, v3);
  void v9[2] = v7;
  uint64_t v8 = [MEMORY[0x1E4F1C978] arrayWithObjects:v9 count:3];

  ARDeviceSupportsMulticamWithTripleRGBStreaming_supportsMulticamWithTripleRGBStreaming = ARDeviceSupportsMulticamSessionWithVideoFormats(v8);
}

uint64_t ARDeviceSupportsUltraWideCamera()
{
  if (ARDeviceSupportsUltraWideCamera_onceToken != -1) {
    dispatch_once(&ARDeviceSupportsUltraWideCamera_onceToken, &__block_literal_global_169);
  }
  return ARDeviceSupportsUltraWideCamera_ultraWideAvailable;
}

void __ARDeviceSupportsUltraWideCamera_block_invoke()
{
  id v1 = (id)MGCopyAnswer();
  int v0 = [v1 BOOLValue];
  if (v0) {
    LOBYTE(v0) = +[ARKitUserDefaults BOOLForKey:@"com.apple.arkit.imagesensor.back.ultrawide.enabled"];
  }
  ARDeviceSupportsUltraWideCamera_ultraWideAvailable = v0;
}

uint64_t ARUserDefaultsMulticamModeEnabled()
{
  if (ARUserDefaultsMulticamModeEnabled_onceToken != -1) {
    dispatch_once(&ARUserDefaultsMulticamModeEnabled_onceToken, &__block_literal_global_174);
  }
  return s_multicamModeEnabled;
}

BOOL __ARUserDefaultsMulticamModeEnabled_block_invoke()
{
  BOOL result = +[ARKitUserDefaults BOOLForKey:@"com.apple.arkit.multicam_mode.enabled"];
  s_multicamModeEnabled = result;
  return result;
}

uint64_t AROverrideARUserDefaultsMulticamModeEnabled(uint64_t result)
{
  s_multicamModeEnabled = result;
  return result;
}

double ARReflectedLightMeterCalibrationConstantForDevice(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = MGGetProductType();
  if (a1 != 1) {
    goto LABEL_12;
  }
  if (v4 <= 2032616840)
  {
    if (v4 != 910181310) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  if (v4 == 3743999268)
  {
LABEL_8:
    if ((id)*MEMORY[0x1E4F15830] == v3)
    {
      double v5 = 45.3950005;
      goto LABEL_13;
    }
LABEL_9:
    if (v4 != 1371389549) {
      goto LABEL_12;
    }
    goto LABEL_10;
  }
  if (v4 != 2722529672)
  {
    if (v4 != 2032616841) {
      goto LABEL_12;
    }
    goto LABEL_8;
  }
LABEL_10:
  if ((id)*MEMORY[0x1E4F15828] == v3)
  {
    double v5 = 210.628006;
    goto LABEL_13;
  }
  if ((id)*MEMORY[0x1E4F15830] == v3)
  {
    double v5 = 58.7200012;
    goto LABEL_13;
  }
LABEL_12:
  double v5 = 0.0;
LABEL_13:

  return v5;
}

BOOL ARDeviceSupportsSceneLuminanceEstimation(uint64_t a1, void *a2)
{
  return ARReflectedLightMeterCalibrationConstantForDevice(a1, a2) != 0.0;
}

long double AREstimatedSceneLuminanceForCamera(uint64_t a1, void *a2, double a3, double a4, long double a5)
{
  double v8 = ARReflectedLightMeterCalibrationConstantForDevice(a1, a2);
  return exp2(a5) * v8 / (a3 * a4);
}

__CFString *ARCreateOBJStringForMeshAnchors(void *a1, void *a2, float a3)
{
  v17[1] = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  uint64_t v6 = (void *)[objc_alloc(MEMORY[0x1E4F1CAA8]) initToMemory];
  uint64_t v7 = v6;
  if (v6)
  {
    [v6 open];
    ARWriteOBJForMeshAnchorsToStream(v5, v7, a2, a3);
    if (!*a2)
    {
      [v7 close];
      double v8 = [v7 propertyForKey:*MEMORY[0x1E4F1C4C0]];
      uint64_t v9 = (__CFString *)[[NSString alloc] initWithData:v8 encoding:4];

      goto LABEL_9;
    }
  }
  else
  {
    long long v10 = _ARLogGeneral_4();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v15 = 0;
      _os_log_impl(&dword_1B88A2000, v10, OS_LOG_TYPE_ERROR, "Creating the OBJ failed.", v15, 2u);
    }

    if (a2)
    {
      unint64_t v11 = (void *)MEMORY[0x1E4F28C58];
      uint64_t v12 = *MEMORY[0x1E4F281F8];
      uint64_t v16 = *MEMORY[0x1E4F28568];
      v17[0] = @"Failed to create an in-memory output stream.";
      long long v13 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v17 forKeys:&v16 count:1];
      *a2 = [v11 errorWithDomain:v12 code:-1 userInfo:v13];
    }
  }
  uint64_t v9 = &stru_1F120C8F0;
LABEL_9:

  return v9;
}

void ARWriteOBJForMeshAnchorsToStream(void *a1, void *a2, void *a3, float a4)
{
  uint64_t v185 = *MEMORY[0x1E4F143B8];
  id v7 = a1;
  id v8 = a2;
  uint64_t v9 = _ARLogGeneral_4();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)vImage_Buffer buf = 134217984;
    *(void *)v183 = [v7 count];
    _os_log_impl(&dword_1B88A2000, v9, OS_LOG_TYPE_INFO, "Writing an OBJ file for %lu mesh anchors to a stream.", buf, 0xCu);
  }

  long long v10 = [MEMORY[0x1E4F28E78] string];
  long long v171 = 0u;
  long long v172 = 0u;
  long long v173 = 0u;
  long long v174 = 0u;
  id v11 = v7;
  uint64_t v155 = [v11 countByEnumeratingWithState:&v171 objects:v184 count:16];
  if (!v155)
  {

    goto LABEL_60;
  }
  v151 = v10;
  v153 = v8;
  v154 = a3;
  LODWORD(v12) = 0;
  LODWORD(v13) = 0;
  v159 = v11;
  uint64_t v160 = *(void *)v172;
LABEL_5:
  uint64_t v14 = 0;
  while (1)
  {
    unsigned int v164 = v12;
    if (*(void *)v172 != v160) {
      objc_enumerationMutation(v11);
    }
    uint64_t v15 = [*(id *)(*((void *)&v171 + 1) + 8 * v14) geometry];
    uint64_t v16 = [v15 vertices];
    uint64_t v17 = [v16 count];

    long long v18 = [v15 normals];
    uint64_t v19 = [v18 count];

    uint64_t v20 = [v15 vertices];
    uint64_t v21 = [v20 count];
    long long v22 = [v15 normals];
    uint64_t v23 = [v22 count];

    if (v21 != v23) {
      break;
    }
    uint64_t v24 = [v15 faces];
    id v25 = [v24 buffer];
    uint64_t v26 = [v25 contents];

    uint64_t v27 = [v15 faces];
    uint64_t v28 = [v27 count];

    if (v28 >= 1)
    {
      uint64_t v29 = 0;
      while (1)
      {
        uint64_t v30 = *(unsigned int *)(v26 + 4 * v29);
        long long v31 = [v15 vertices];
        uint64_t v32 = [v31 count];

        if (v32 <= v30) {
          break;
        }
        ++v29;
        uint64_t v33 = [v15 faces];
        uint64_t v34 = 3 * [v33 count];

        if (v34 <= v29) {
          goto LABEL_13;
        }
      }
      v123 = _ARLogGeneral_4();
      id v11 = v159;
      if (os_log_type_enabled(v123, OS_LOG_TYPE_ERROR))
      {
        int v124 = *(_DWORD *)(v26 + 4 * v29);
        v125 = [v15 vertices];
        uint64_t v126 = [v125 count];
        *(_DWORD *)vImage_Buffer buf = 67109376;
        *(_DWORD *)v183 = v124;
        *(_WORD *)&v183[4] = 2048;
        *(void *)&v183[6] = v126;
        _os_log_impl(&dword_1B88A2000, v123, OS_LOG_TYPE_ERROR, "Face index %d is out of range [0, %ld].", buf, 0x12u);
      }
      id v8 = v153;
      v127 = v154;
      long long v10 = v151;
      if (v154)
      {
        v128 = (void *)MEMORY[0x1E4F28C58];
        uint64_t v129 = *MEMORY[0x1E4F281F8];
        uint64_t v178 = *MEMORY[0x1E4F28568];
        v179 = @"A face index is out of range.";
        v130 = (void *)MEMORY[0x1E4F1C9E8];
        v131 = &v179;
        v132 = &v178;
        goto LABEL_57;
      }
      goto LABEL_58;
    }
LABEL_13:
    uint64_t v13 = v17 + v13;
    uint64_t v12 = v19 + v164;

    ++v14;
    id v11 = v159;
    if (v14 == v155)
    {
      uint64_t v155 = [v159 countByEnumeratingWithState:&v171 objects:v184 count:16];
      if (!v155)
      {

        id v8 = v153;
        a3 = v154;
        long long v10 = v151;
        if (v13)
        {
          [v151 appendString:@"#\n"];
          v149 = NSString;
          v161 = [MEMORY[0x1E4F28B50] mainBundle];
          v156 = [v161 infoDictionary];
          uint64_t v165 = v12;
          v147 = [v156 objectForKeyedSubscript:@"CFBundleVersion"];
          uint64_t v35 = ARKitBundle();
          id v36 = [v35 infoDictionary];
          CFDictionaryRef v37 = [v36 objectForKeyedSubscript:@"CFBundleVersion"];
          id v38 = [MEMORY[0x1E4F28B50] bundleWithIdentifier:@"com.apple.AppleCV3D"];
          uint64_t v39 = [v38 infoDictionary];
          uint64_t v40 = [v39 objectForKeyedSubscript:@"CFBundleVersion"];
          long long v41 = [v149 stringWithFormat:@"# ARKit mesh exported from ARExamples %@, ARKit %@, AppleCV3D %@\n", v147, v37, v40];
          [v151 appendString:v41];

          [v151 appendString:@"#\n"];
          long long v42 = objc_msgSend(NSString, "stringWithFormat:", @"# Vertex count: %d\n", v13);
          [v151 appendString:v42];

          long long v43 = objc_msgSend(NSString, "stringWithFormat:", @"# Face count: %d\n", v165);
          [v151 appendString:v43];

          [v151 appendString:@"#\n"];
          [v151 appendString:@"# Real world scale is 1 unit = 1 m\n"];
          [v151 appendString:@"# Each vertex is followed by four RGBA color values in range [0.0 - 1.0] (not in spec)\n"];
          long long v169 = 0u;
          long long v170 = 0u;
          long long v167 = 0u;
          long long v168 = 0u;
          obuint64_t j = v159;
          uint64_t v145 = [obj countByEnumeratingWithState:&v167 objects:v175 count:16];
          if (!v145)
          {
            id v8 = v153;
LABEL_71:

            long long v10 = v151;
            [v151 appendString:@"\n"];
            [v151 appendString:@"# EOF\n"];
            ARAppendStringToStream(v151, v8, v154);
LABEL_72:
            id v11 = v159;
            goto LABEL_64;
          }
          int v44 = 1;
          uint64_t v144 = *(void *)v168;
          double v45 = a4;
          while (2)
          {
            uint64_t v46 = 0;
            long long v47 = v151;
LABEL_19:
            int v150 = v44;
            if (*(void *)v168 != v144) {
              objc_enumerationMutation(obj);
            }
            long long v48 = *(void **)(*((void *)&v167 + 1) + 8 * v46);
            long long v49 = [v48 geometry];
            [v47 appendString:@"\n"];
            long long v50 = NSString;
            v152 = v48;
            long long v51 = [v48 identifier];
            long long v52 = [v51 UUIDString];
            float v53 = [v50 stringWithFormat:@"o mesh_anchor_%@\n", v52];
            [v47 appendString:v53];

            [v47 appendString:@"\n"];
            float v54 = [v49 colors];
            uint64_t v55 = [v54 count];

            uint64_t v56 = [v49 classification];
            __int16 v57 = (float *)[v56 count];

            double v58 = [v49 faces];
            id v59 = [v58 buffer];
            uint64_t v60 = [v59 contents];

            uint64_t v146 = v60;
            uint64_t v148 = v46;
            if (v55)
            {
              uint64_t v61 = v57;
              size_t v62 = [v49 colors];
              id v63 = [v62 buffer];
              __int16 v57 = (float *)[v63 contents];

              goto LABEL_23;
            }
            uint64_t v61 = v57;
            if (v57)
            {
              size_t v66 = [v49 vertices];
              __int16 v57 = (float *)malloc_type_malloc(12 * [v66 count], 0x100004052888210uLL);

              uint64_t v67 = [v49 classification];
              id v68 = [v67 buffer];
              uint64_t v69 = [v68 contents];

              v70 = 0;
              uint64_t v71 = v60;
              do
              {
                for (uint64_t i = 0; i != 12; i += 4)
                {
                  int v73 = *(_DWORD *)(v71 + i);
                  __n128 v74 = ARCV3DColorComponentsForARKitSemantics(*((unsigned __int8 *)v70 + v69));
                  v75 = &v57[3 * v73];
                  *(void *)v75 = v74.n128_u64[0];
                  v75[2] = v74.n128_f32[2];
                }
                v70 = (float *)((char *)v70 + 1);
                v71 += 12;
              }
              while (v70 != v61);
              char v65 = 1;
            }
            else
            {
LABEL_23:
              if (v61) {
                BOOL v64 = v55 == 0;
              }
              else {
                BOOL v64 = 0;
              }
              char v65 = v64;
            }
            v76 = [v49 vertices];
            id v77 = [v76 buffer];
            uint64_t v78 = [v77 contents];

            v79 = [v49 vertices];
            uint64_t v80 = [v79 count];

            if (v80 >= 1)
            {
              uint64_t v81 = 0;
              v82 = v57 + 2;
              v83 = (float *)(v78 + 8);
              do
              {
                float v157 = *(v83 - 2);
                float v162 = *(v83 - 1);
                float v166 = *v83;
                [v152 transform];
                if (v57)
                {
                  uint64_t v88 = *((void *)v82 - 1);
                  float v89 = *v82;
                }
                else
                {
                  uint64_t v88 = 0x3F0000003F000000;
                  float v89 = 0.5;
                }
                float32x4_t v90 = vaddq_f32(v87, vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v84, v157), v85, v162), v86, v166));
                v91 = objc_msgSend(NSString, "stringWithFormat:", @"v %.06f %.06f %.06f %.03f %.03f %.03f %.03f\n", v90.f32[0], v90.f32[1], v90.f32[2], *(float *)&v88, *((float *)&v88 + 1), v89, *(void *)&v45);
                [v47 appendString:v91];

                ++v81;
                v92 = [v49 vertices];
                uint64_t v93 = [v92 count];

                v82 += 3;
                v83 += 3;
              }
              while (v93 > v81);
            }
            if (v65) {
              free(v57);
            }
            [v47 appendString:@"\n"];
            v94 = [v49 normals];
            id v95 = [v94 buffer];
            uint64_t v96 = [v95 contents];

            v97 = [v49 normals];
            uint64_t v98 = [v97 count];

            if (v98 >= 1)
            {
              uint64_t v99 = 0;
              v100 = (float *)(v96 + 8);
              do
              {
                float v158 = *(v100 - 2);
                float v163 = *(v100 - 1);
                float v101 = *v100;
                v100 += 3;
                [v152 transform];
                float32x4_t v106 = vmlaq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v102, v158), v103, v163), v104, v101), (float32x4_t)0, v105);
                v107 = objc_msgSend(NSString, "stringWithFormat:", @"vn %f %f %f\n", v106.f32[0], v106.f32[1], v106.f32[2]);
                [v47 appendString:v107];

                ++v99;
                v108 = [v49 normals];
                uint64_t v109 = [v108 count];
              }
              while (v109 > v99);
            }
            [v47 appendString:@"\n"];
            v110 = [v49 faces];
            uint64_t v111 = [v110 count];

            if (v111 >= 1)
            {
              uint64_t v112 = 0;
              v113 = (int *)(v146 + 8);
              do
              {
                uint64_t v114 = (*(v113 - 2) + v150);
                uint64_t v115 = (*(v113 - 1) + v150);
                int v116 = *v113;
                v113 += 3;
                v117 = objc_msgSend(NSString, "stringWithFormat:", @"f %d//%d %d//%d %d//%d\n", v114, v114, v115, v115, (v116 + v150), (v116 + v150));
                [v47 appendString:v117];

                ++v112;
                v118 = [v49 faces];
                uint64_t v119 = [v118 count];
              }
              while (v119 > v112);
            }
            v120 = [v49 vertices];
            int v121 = [v120 count];

            id v8 = v153;
            ARAppendStringToStream(v47, v153, v154);
            if (*v154)
            {

              long long v10 = v47;
              goto LABEL_72;
            }
            int v44 = v150 + v121;
            uint64_t v122 = [MEMORY[0x1E4F28E78] string];

            uint64_t v46 = v148 + 1;
            long long v47 = (void *)v122;
            if (v148 + 1 == v145)
            {
              v151 = (void *)v122;
              uint64_t v145 = [obj countByEnumeratingWithState:&v167 objects:v175 count:16];
              if (v145) {
                continue;
              }
              goto LABEL_71;
            }
            goto LABEL_19;
          }
        }
LABEL_60:
        v134 = _ARLogGeneral_4();
        if (os_log_type_enabled(v134, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)vImage_Buffer buf = 0;
          _os_log_impl(&dword_1B88A2000, v134, OS_LOG_TYPE_ERROR, "No mesh to save.", buf, 2u);
        }

        if (a3)
        {
          v135 = (void *)MEMORY[0x1E4F28C58];
          uint64_t v136 = *MEMORY[0x1E4F281F8];
          uint64_t v176 = *MEMORY[0x1E4F28568];
          v177 = @"There is no mesh to save.";
          v137 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v177 forKeys:&v176 count:1];
          *a3 = [v135 errorWithDomain:v136 code:-1 userInfo:v137];
        }
        goto LABEL_64;
      }
      goto LABEL_5;
    }
  }
  v138 = _ARLogGeneral_4();
  if (os_log_type_enabled(v138, OS_LOG_TYPE_ERROR))
  {
    v139 = [v15 vertices];
    uint64_t v140 = [v139 count];
    v141 = [v15 normals];
    uint64_t v142 = [v141 count];
    *(_DWORD *)vImage_Buffer buf = 134218240;
    *(void *)v183 = v140;
    *(_WORD *)&v183[8] = 2048;
    *(void *)&v183[10] = v142;
    _os_log_impl(&dword_1B88A2000, v138, OS_LOG_TYPE_ERROR, "Vertex count %ld does not match normal count %ld.", buf, 0x16u);
  }
  id v8 = v153;
  v127 = v154;
  long long v10 = v151;
  if (v154)
  {
    v128 = (void *)MEMORY[0x1E4F28C58];
    uint64_t v129 = *MEMORY[0x1E4F281F8];
    uint64_t v180 = *MEMORY[0x1E4F28568];
    v181 = @"An anchor geometrie's vertex count does not match normal count.";
    v130 = (void *)MEMORY[0x1E4F1C9E8];
    v131 = &v181;
    v132 = &v180;
LABEL_57:
    v133 = [v130 dictionaryWithObjects:v131 forKeys:v132 count:1];
    void *v127 = [v128 errorWithDomain:v129 code:-1 userInfo:v133];
  }
LABEL_58:

LABEL_64:
}

void ARAppendStringToStream(void *a1, void *a2, void *a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  uint64_t v6 = [a1 dataUsingEncoding:4];
  uint64_t v7 = [v6 length];
  id v8 = v6;
  if (objc_msgSend(v5, "write:maxLength:", objc_msgSend(v8, "bytes"), v7) != v7)
  {
    uint64_t v9 = [v5 streamError];

    if (v9)
    {
      long long v10 = _ARLogGeneral_4();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        id v11 = [v5 streamError];
        *(_DWORD *)vImage_Buffer buf = 138412290;
        long long v18 = v11;
        _os_log_impl(&dword_1B88A2000, v10, OS_LOG_TYPE_ERROR, "Writing a string to the output stream failed with error: %@", buf, 0xCu);
      }
      if (a3)
      {
        *a3 = [v5 streamError];
      }
    }
    else if (a3)
    {
      uint64_t v12 = (void *)MEMORY[0x1E4F28C58];
      uint64_t v13 = *MEMORY[0x1E4F281F8];
      uint64_t v15 = *MEMORY[0x1E4F28568];
      uint64_t v16 = @"Writing a string to an output stream failed with an unknown error.";
      uint64_t v14 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v16 forKeys:&v15 count:1];
      *a3 = [v12 errorWithDomain:v13 code:-1 userInfo:v14];
    }
  }
}

id ARKitBundle()
{
  if (ARKitBundle_onceToken != -1) {
    dispatch_once(&ARKitBundle_onceToken, &__block_literal_global_272);
  }
  int v0 = (void *)ARKitBundle_arkitBundle;
  return v0;
}

double ARFixedIntrinsicsForBackUltraWideCamera640x480()
{
  uint64_t v0 = MGGetProductType();
  double result = *(double *)&_PromotedConst_325;
  if (v0 <= 2722529671)
  {
    if (v0 != 1371389549 && v0 != 2080700391) {
      return result;
    }
    return *(double *)"KFyC";
  }
  if (v0 == 2722529672) {
    return *(double *)"KFyC";
  }
  if (v0 == 3863625342 || v0 == 3599094683) {
    return *(double *)&_PromotedConst_324;
  }
  return result;
}

double ARRadialDistortionForUltraWideCamera()
{
  uint64_t v0 = MGGetProductType();
  if (v0 <= 2722529671)
  {
    if (v0 != 1371389549)
    {
      double result = -0.00199588993;
      if (v0 != 2080700391) {
        return result;
      }
    }
    return -0.000000502777423;
  }
  if (v0 == 2722529672) {
    return -0.000000502777423;
  }
  double result = -0.00199588993;
  if (v0 == 3863625342 || v0 == 3599094683) {
    return -0.00382197322;
  }
  return result;
}

double ARWideToUltrawideExtrinsicsForOldRecordings()
{
  if (ARWideToUltrawideExtrinsicsForOldRecordings_onceToken != -1) {
    dispatch_once(&ARWideToUltrawideExtrinsicsForOldRecordings_onceToken, &__block_literal_global_235);
  }
  return *(double *)&ARWideToUltrawideExtrinsicsForOldRecordings_wideToUltrawideExtrinsics_0;
}

void __ARWideToUltrawideExtrinsicsForOldRecordings_block_invoke()
{
  uint64_t v0 = MGGetProductType();
  v1.columns[0] = (simd_float4)*MEMORY[0x1E4F149A0];
  v1.columns[1] = *(simd_float4 *)(MEMORY[0x1E4F149A0] + 16);
  v1.columns[2] = *(simd_float4 *)(MEMORY[0x1E4F149A0] + 32);
  float32x4_t v2 = *(float32x4_t *)(MEMORY[0x1E4F149A0] + 48);
  if (v0 <= 2103978417)
  {
    if (v0 == 1293446025)
    {
LABEL_13:
      float32x4_t v3 = (float32x4_t)xmmword_1B8A2B430;
      float32x4_t v2 = (float32x4_t)xmmword_1B8A2B440;
      goto LABEL_15;
    }
    if (v0 == 1371389549)
    {
LABEL_14:
      float32x4_t v3 = (float32x4_t)xmmword_1B8A2B3B0;
      float32x4_t v2 = (float32x4_t)xmmword_1B8A2B3C0;
      goto LABEL_15;
    }
    float32x4_t v3 = *(float32x4_t *)(MEMORY[0x1E4F149A0] + 48);
    if (v0 == 2080700391)
    {
      float32x4_t v3 = (float32x4_t)xmmword_1B8A2B3F0;
      float32x4_t v2 = (float32x4_t)xmmword_1B8A2B400;
LABEL_15:
      v1.columns[2] = (simd_float4)xmmword_1B8A2B0E0;
      v1.columns[1] = (simd_float4)xmmword_1B8A2B3D0;
      v1.columns[0] = (simd_float4)xmmword_1B8A2B3E0;
    }
  }
  else
  {
    if (v0 <= 3599094682)
    {
      if (v0 != 2103978418)
      {
        float32x4_t v3 = *(float32x4_t *)(MEMORY[0x1E4F149A0] + 48);
        if (v0 != 2722529672) {
          goto LABEL_16;
        }
        goto LABEL_14;
      }
      goto LABEL_13;
    }
    if (v0 == 3599094683 || (float32x4_t v3 = *(float32x4_t *)(MEMORY[0x1E4F149A0] + 48), v0 == 3863625342))
    {
      float32x4_t v3 = (float32x4_t)xmmword_1B8A2B410;
      float32x4_t v2 = (float32x4_t)xmmword_1B8A2B420;
      goto LABEL_15;
    }
  }
LABEL_16:
  simd_float4 v15 = v1.columns[0];
  simd_float4 v16 = v1.columns[1];
  float32x4_t v4 = (float32x4_t)vdupq_n_s32(0x447A0000u);
  v1.columns[3] = (simd_float4)vmulq_f32(v2, v4);
  v1.columns[3].i32[3] = v2.i32[3];
  float32x4_t v5 = vmulq_f32(v3, v4);
  v5.i32[3] = v3.i32[3];
  simd_float4 v17 = v1.columns[2];
  float32x4_t v18 = v5;
  simd_float4x4 v21 = __invert_f4(v1);
  uint64_t v7 = 0;
  v19[0] = v15;
  v19[1] = v16;
  v19[2] = v17;
  v19[3] = v18;
  memset(v20, 0, sizeof(v20));
  do
  {
    v20[v7] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v21.columns[0], COERCE_FLOAT(v19[v7])), (float32x4_t)v21.columns[1], *(float32x2_t *)&v19[v7], 1), (float32x4_t)v21.columns[2], (float32x4_t)v19[v7], 2), (float32x4_t)v21.columns[3], (float32x4_t)v19[v7], 3);
    ++v7;
  }
  while (v7 != 4);
  __n128 v8 = ARMatrix4x3FromMatrix4x4(v6);
  DWORD2(ARWideToUltrawideExtrinsicsForOldRecordings_wideToUltrawideExtrinsics_0) = v8.n128_u32[2];
  *(void *)&ARWideToUltrawideExtrinsicsForOldRecordings_wideToUltrawideExtrinsics_0 = v8.n128_u64[0];
  DWORD2(ARWideToUltrawideExtrinsicsForOldRecordings_wideToUltrawideExtrinsics_1) = v9;
  *(void *)&ARWideToUltrawideExtrinsicsForOldRecordings_wideToUltrawideExtrinsics_1 = v10;
  DWORD2(ARWideToUltrawideExtrinsicsForOldRecordings_wideToUltrawideExtrinsics_2) = v11;
  *(void *)&ARWideToUltrawideExtrinsicsForOldRecordings_wideToUltrawideExtrinsics_2 = v12;
  DWORD2(ARWideToUltrawideExtrinsicsForOldRecordings_wideToUltrawideExtrinsics_3) = v13;
  *(void *)&ARWideToUltrawideExtrinsicsForOldRecordings_wideToUltrawideExtrinsics_3 = v14;
}

uint64_t AROverrideARDeviceHasGPSCapability(uint64_t result)
{
  s_deviceHasGPSCapability = result;
  return result;
}

const __SCNetworkReachability *ARDeviceHasInternetConnectivity()
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  sockaddr address = (sockaddr)xmmword_1B8A2B450;
  double result = SCNetworkReachabilityCreateWithAddress((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &address);
  if (result)
  {
    simd_float4x4 v1 = result;
    SCNetworkReachabilityFlags flags = 0;
    SCNetworkReachabilityGetFlags(result, &flags);
    CFRelease(v1);
    return (const __SCNetworkReachability *)((flags >> 1) & 1);
  }
  return result;
}

uint64_t ARGetProcessNameForPID(uint64_t a1)
{
  return objc_msgSend(NSString, "stringWithFormat:", @"pid=%d <Unknown>", a1);
}

BOOL ARIsProcessRunning()
{
  uint64_t v0 = (void *)MEMORY[0x1F4188790]();
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  id v1 = v0;
  bzero(buffer, 0x2000uLL);
  int v2 = proc_listallpids(buffer, 0x2000);
  if (v2 < 1)
  {
    BOOL v5 = 0;
  }
  else
  {
    uint64_t v3 = 0;
    unint64_t v4 = v2;
    BOOL v5 = 1;
    do
    {
      bzero(__s1, 0x400uLL);
      proc_name(buffer[v3], __s1, 0x400u);
      id v6 = v1;
      if (!strncmp(__s1, (const char *)[v6 UTF8String], objc_msgSend(v6, "length"))) {
        break;
      }
      BOOL v5 = ++v3 < v4;
    }
    while (v4 != v3);
  }

  return v5;
}

double ARGetSystemBootTime()
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (ARGetSystemBootTime_onceToken != -1) {
    dispatch_once(&ARGetSystemBootTime_onceToken, &__block_literal_global_245);
  }
  if (!ARGetSystemBootTime_bootTimeMIBSize) {
    return 0.0;
  }
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  size_t v5 = 16;
  int v0 = sysctl(ARGetSystemBootTime_bootTimeMIB, ARGetSystemBootTime_bootTimeMIBSize, &v6, &v5, 0, 0);
  if (v0)
  {
    int v1 = v0;
    int v2 = _ARLogGeneral_4();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      uint64_t v3 = strerror(v1);
      *(_DWORD *)vImage_Buffer buf = 136380675;
      int v9 = v3;
      _os_log_impl(&dword_1B88A2000, v2, OS_LOG_TYPE_ERROR, "Failed to lookup kern.boottime with error: %{private}s", buf, 0xCu);
    }

    return 0.0;
  }
  return (double)(int)v7 / 1000000.0 + (double)v6;
}

void __ARGetSystemBootTime_block_invoke()
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  __memset_chk();
  int v0 = sysctlnametomib("kern.boottime", ARGetSystemBootTime_bootTimeMIB, (size_t *)&ARGetSystemBootTime_bootTimeMIBSize);
  if (v0)
  {
    int v1 = v0;
    int v2 = _ARLogGeneral_4();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      int v3 = 136380675;
      unint64_t v4 = strerror(v1);
      _os_log_impl(&dword_1B88A2000, v2, OS_LOG_TYPE_ERROR, "Failed to get kern.boottime MIB with error: %{private}s", (uint8_t *)&v3, 0xCu);
    }

    ARGetSystemBootTime_bootTimeMIBSize = 0;
  }
}

double ARGetSystemUpTime()
{
  return (double)clock_gettime_nsec_np(_CLOCK_UPTIME_RAW) / 1000000000.0;
}

double ARGetSystemUpTimeIncludingSleep()
{
  return (double)clock_gettime_nsec_np(_CLOCK_MONOTONIC_RAW) / 1000000000.0;
}

double ARGetSystemUpTimeIncludingSleepAndDriftCorrection()
{
  return (double)clock_gettime_nsec_np(_CLOCK_MONOTONIC) / 1000000000.0;
}

NSObject *ARCreateDispatchSourceForSignalWithHandler(int a1, NSObject *a2, void *a3)
{
  id v5 = a3;
  uint64_t v6 = dispatch_source_create(MEMORY[0x1E4F14480], a1, 0, a2);
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3221225472;
  void v9[2] = __ARCreateDispatchSourceForSignalWithHandler_block_invoke;
  v9[3] = &unk_1E61854C8;
  id v10 = v5;
  int v11 = a1;
  id v7 = v5;
  dispatch_source_set_event_handler(v6, v9);

  return v6;
}

uint64_t __ARCreateDispatchSourceForSignalWithHandler_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(unsigned int *)(a1 + 40));
}

__CFString *ARAVCaptureDevicePositionToString(unint64_t a1)
{
  if (a1 > 2) {
    return 0;
  }
  else {
    return off_1E6185510[a1];
  }
}

__CFString *NSStringFromAVCaptureDevicePosition(unint64_t a1)
{
  if (a1 > 2) {
    return 0;
  }
  else {
    return off_1E6185510[a1];
  }
}

uint64_t ARIsSupportedAVCaptureDeviceTypeForRearCameraBackdrop(void *a1)
{
  id v1 = a1;
  if (([v1 isEqualToString:*MEMORY[0x1E4F15830]] & 1) != 0
    || ([v1 isEqualToString:*MEMORY[0x1E4F157F0]] & 1) != 0)
  {
    uint64_t v2 = 1;
  }
  else
  {
    uint64_t v2 = [v1 isEqualToString:*MEMORY[0x1E4F15818]];
  }

  return v2;
}

id ARCreateTransactionForService(void *a1)
{
  id v1 = NSString;
  id v2 = a1;
  int v3 = [(id)objc_opt_class() serviceName];
  unint64_t v4 = [v2 clientBundleIdentifier];

  id v5 = [v1 stringWithFormat:@"%@:%@", v3, v4];

  id v6 = v5;
  [v6 UTF8String];
  id v7 = (void *)os_transaction_create();

  return v7;
}

uint64_t ARGetImageContainingClass()
{
  return MEMORY[0x1F40CBE68]();
}

id ARGetSubclassesForClassAndImage(objc_class *a1, const void *a2)
{
  return AREnumerateClasses(a2, 0, a1);
}

id AREnumerateClasses(const void *a1, void *a2, objc_class *a3)
{
  id v5 = a2;
  id v6 = objc_opt_new();
  id v7 = v6;
  if (a1)
  {
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = __AREnumerateClasses_block_invoke;
    block[3] = &unk_1E61854F0;
    id v16 = v6;
    objc_enumerateClasses(a1, 0, v5, a3, block);
  }
  else
  {
    uint32_t v8 = _dyld_image_count();
    if (v8)
    {
      uint32_t v9 = v8;
      for (uint32_t i = 0; i != v9; ++i)
      {
        image_header = _dyld_get_image_header(i);
        v13[0] = MEMORY[0x1E4F143A8];
        v13[1] = 3221225472;
        void v13[2] = __AREnumerateClasses_block_invoke_2;
        v13[3] = &unk_1E61854F0;
        id v14 = v7;
        objc_enumerateClasses(image_header, 0, v5, a3, v13);
      }
    }
  }

  return v7;
}

id ARGetSubclassesForClass(objc_class *a1)
{
  return AREnumerateClasses(0, 0, a1);
}

id ARGetClassesImplementingProtocol(void *a1)
{
  return AREnumerateClasses(0, a1, 0);
}

id ARLibraryDirectory()
{
  if (ARLibraryDirectory_onceToken != -1) {
    dispatch_once(&ARLibraryDirectory_onceToken, &__block_literal_global_260);
  }
  int v0 = (void *)ARLibraryDirectory_arkitLibraryDirectory;
  return v0;
}

void __ARLibraryDirectory_block_invoke()
{
  int v0 = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, 1uLL, 1);
  id v4 = [v0 lastObject];

  id v1 = [v4 stringByAppendingPathComponent:@"ARKit"];
  uint64_t v2 = [v1 stringByAppendingString:@"/"];
  int v3 = (void *)ARLibraryDirectory_arkitLibraryDirectory;
  ARLibraryDirectory_arkitLibraryDirectory = v2;
}

id ARCacheDirectory()
{
  if (ARCacheDirectory_onceToken != -1) {
    dispatch_once(&ARCacheDirectory_onceToken, &__block_literal_global_268);
  }
  int v0 = (void *)ARCacheDirectory_arkitCacheDirectory;
  return v0;
}

void __ARCacheDirectory_block_invoke()
{
  int v0 = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, 1uLL, 1);
  id v6 = [v0 lastObject];

  id v1 = [MEMORY[0x1E4F28B50] mainBundle];
  uint64_t v2 = [v1 bundleIdentifier];
  int v3 = [v6 stringByAppendingPathComponent:v2];
  uint64_t v4 = [v3 stringByAppendingString:@"/"];
  id v5 = (void *)ARCacheDirectory_arkitCacheDirectory;
  ARCacheDirectory_arkitCacheDirectory = v4;
}

id ARCreateTemporaryDirectory(uint64_t a1)
{
  uint64_t v2 = NSTemporaryDirectory();
  int v3 = objc_opt_new();
  uint64_t v4 = [v3 UUIDString];
  id v5 = [v2 stringByAppendingPathComponent:v4];

  id v6 = [MEMORY[0x1E4F28CB8] defaultManager];
  LODWORD(v3) = [v6 createDirectoryAtPath:v5 withIntermediateDirectories:0 attributes:0 error:a1];

  id v7 = 0;
  if (v3) {
    id v7 = v5;
  }

  return v7;
}

id ARSandboxDirectories()
{
  v6[2] = *MEMORY[0x1E4F143B8];
  int v0 = NSTemporaryDirectory();
  id v1 = [v0 stringByStandardizingPath];
  v6[0] = v1;
  uint64_t v2 = ARLibraryDirectory();
  int v3 = [v2 stringByStandardizingPath];
  v6[1] = v3;
  uint64_t v4 = [MEMORY[0x1E4F1C978] arrayWithObjects:v6 count:2];

  return v4;
}

uint64_t ARSandboxContains(void *a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  id v1 = [a1 stringByStandardizingPath];
  uint64_t v2 = [MEMORY[0x1E4F28CB8] defaultManager];
  uint64_t v3 = [v2 fileExistsAtPath:v1 isDirectory:0];

  if (v3)
  {
    long long v10 = 0u;
    long long v11 = 0u;
    long long v8 = 0u;
    long long v9 = 0u;
    uint64_t v4 = ARSandboxDirectories();
    uint64_t v3 = [v4 countByEnumeratingWithState:&v8 objects:v12 count:16];
    if (v3)
    {
      uint64_t v5 = *(void *)v9;
      while (2)
      {
        for (uint64_t i = 0; i != v3; ++i)
        {
          if (*(void *)v9 != v5) {
            objc_enumerationMutation(v4);
          }
          if (objc_msgSend(v1, "hasPrefix:", *(void *)(*((void *)&v8 + 1) + 8 * i), (void)v8))
          {
            uint64_t v3 = 1;
            goto LABEL_12;
          }
        }
        uint64_t v3 = [v4 countByEnumeratingWithState:&v8 objects:v12 count:16];
        if (v3) {
          continue;
        }
        break;
      }
    }
LABEL_12:
  }
  return v3;
}

id ARCreateFixedPriorityPthreadQueue(uint64_t a1, int a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  memset(&v6, 0, sizeof(v6));
  pthread_attr_init(&v6);
  sched_param v5 = 0;
  pthread_attr_getschedparam(&v6, &v5);
  v5.sched_priority = a2;
  pthread_attr_setschedpolicy(&v6, 2);
  pthread_attr_setschedparam(&v6, &v5);
  pthread_attr_setinheritsched(&v6, 2);
  uint64_t v3 = (void *)dispatch_pthread_root_queue_create();
  pthread_attr_destroy(&v6);
  return v3;
}

void __ARKitBundle_block_invoke()
{
  uint64_t v0 = [MEMORY[0x1E4F28B50] bundleWithIdentifier:@"com.apple.ARKit"];
  id v1 = (void *)ARKitBundle_arkitBundle;
  ARKitBundle_arkitBundle = v0;

  if (!ARKitBundle_arkitBundle)
  {
    uint64_t v2 = (void *)MEMORY[0x1E4F28B50];
    _ARSystemLibraryPath();
    id v6 = (id)objc_claimAutoreleasedReturnValue();
    uint64_t v3 = [v6 stringByAppendingPathComponent:@"Frameworks/ARKit.framework"];
    uint64_t v4 = [v2 bundleWithPath:v3];
    sched_param v5 = (void *)ARKitBundle_arkitBundle;
    ARKitBundle_arkitBundle = v4;
  }
}

id _ARSystemLibraryPath()
{
  uint64_t v0 = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, 8uLL, 1);
  if ([v0 count])
  {
    id v1 = [v0 objectAtIndex:0];
  }
  else
  {
    id v1 = 0;
  }

  return v1;
}

id ARKitUIBundle()
{
  if (ARKitUIBundle_onceToken != -1) {
    dispatch_once(&ARKitUIBundle_onceToken, &__block_literal_global_280);
  }
  uint64_t v0 = (void *)ARKitUIBundle_arkitUIBundle;
  return v0;
}

void __ARKitUIBundle_block_invoke()
{
  uint64_t v0 = [MEMORY[0x1E4F28B50] bundleWithIdentifier:@"com.apple.ARKitUI"];
  id v1 = (void *)ARKitUIBundle_arkitUIBundle;
  ARKitUIBundle_arkitUIBundle = v0;

  if (!ARKitUIBundle_arkitUIBundle)
  {
    uint64_t v2 = (void *)MEMORY[0x1E4F28B50];
    _ARSystemLibraryPath();
    id v6 = (id)objc_claimAutoreleasedReturnValue();
    uint64_t v3 = [v6 stringByAppendingPathComponent:@"PrivateFrameworks/ARKitUI.framework"];
    uint64_t v4 = [v2 bundleWithPath:v3];
    sched_param v5 = (void *)ARKitUIBundle_arkitUIBundle;
    ARKitUIBundle_arkitUIBundle = v4;
  }
}

void __ARKitCoreBundle_block_invoke()
{
  uint64_t v0 = [MEMORY[0x1E4F28B50] bundleWithIdentifier:@"com.apple.ARKitCore"];
  id v1 = (void *)ARKitCoreBundle_arkitCoreBundle;
  ARKitCoreBundle_arkitCoreBundle = v0;

  if (!ARKitCoreBundle_arkitCoreBundle)
  {
    uint64_t v2 = (void *)MEMORY[0x1E4F28B50];
    _ARSystemLibraryPath();
    id v6 = (id)objc_claimAutoreleasedReturnValue();
    uint64_t v3 = [v6 stringByAppendingPathComponent:@"PrivateFrameworks/ARKitCore.framework"];
    uint64_t v4 = [v2 bundleWithPath:v3];
    sched_param v5 = (void *)ARKitCoreBundle_arkitCoreBundle;
    ARKitCoreBundle_arkitCoreBundle = v4;
  }
}

uint64_t ARLoadExternalBundleByName()
{
  return 0;
}

BOOL ARSubclassOverridesSelector(objc_class *a1, objc_class *a2, SEL name)
{
  if (a1 == a2) {
    return 0;
  }
  IMP MethodImplementation = class_getMethodImplementation(a1, name);
  IMP v6 = class_getMethodImplementation(a2, name);
  if (MethodImplementation) {
    BOOL v7 = v6 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  return !v7 && MethodImplementation != v6;
}

BOOL ARSubclassOverridesClassSelector(void *a1, void *a2, uint64_t a3)
{
  if (a1 == a2) {
    return 0;
  }
  uint64_t v5 = objc_msgSend(a1, "methodForSelector:");
  uint64_t v6 = [a2 methodForSelector:a3];
  if (v5) {
    BOOL v7 = v6 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  return !v7 && v5 != v6;
}

id ARApprovedDecoderClasses()
{
  if (ARApprovedDecoderClasses_onceToken != -1) {
    dispatch_once(&ARApprovedDecoderClasses_onceToken, &__block_literal_global_296);
  }
  uint64_t v0 = (void *)ARApprovedDecoderClasses_set;
  return v0;
}

void __ARApprovedDecoderClasses_block_invoke()
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v0 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v4 = objc_opt_class();
  uint64_t v5 = objc_opt_class();
  uint64_t v6 = objc_opt_class();
  uint64_t v7 = objc_opt_class();
  uint64_t v8 = objc_opt_class();
  uint64_t v9 = objc_opt_class();
  uint64_t v10 = objc_opt_class();
  uint64_t v11 = objc_opt_class();
  uint64_t v12 = objc_opt_class();
  id v1 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v4 count:9];
  uint64_t v2 = objc_msgSend(v0, "setWithArray:", v1, v4, v5, v6, v7, v8, v9, v10, v11);
  uint64_t v3 = (void *)ARApprovedDecoderClasses_set;
  ARApprovedDecoderClasses_set = v2;
}

id ARCrashReporterKey()
{
  if (ARCrashReporterKey_onceToken != -1) {
    dispatch_once(&ARCrashReporterKey_onceToken, &__block_literal_global_303);
  }
  uint64_t v0 = (void *)ARCrashReporterKey_crashReporterKey;
  return v0;
}

void __ARCrashReporterKey_block_invoke()
{
  if (ARInternalOSBuild_onceToken != -1) {
    dispatch_once(&ARInternalOSBuild_onceToken, &__block_literal_global_13);
  }
  if (ARInternalOSBuild_internalVersion)
  {
    uint64_t v0 = MGCopyAnswer();
    id v1 = (void *)ARCrashReporterKey_crashReporterKey;
    ARCrashReporterKey_crashReporterKey = v0;
  }
}

uint64_t __AREnumerateClasses_block_invoke(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) addObject:a2];
}

uint64_t __AREnumerateClasses_block_invoke_2(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) addObject:a2];
}

id _ARLogTechnique()
{
  if (_ARLogTechnique_onceToken != -1) {
    dispatch_once(&_ARLogTechnique_onceToken, &__block_literal_global_290);
  }
  uint64_t v0 = (void *)_ARLogTechnique_logObj;
  return v0;
}

void sub_1B88CF2A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88CF4CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88CF6EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88CFB3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28)
{
  uint64_t v32 = *(void **)(v30 - 128);
  if (v32)
  {
    *(void *)(v30 - 120) = v32;
    operator delete(v32);
  }

  _Unwind_Resume(a1);
}

void sub_1B88CFC98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88CFF18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88D0294(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88D0450(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B88D05DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88D07F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88D095C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88D0A80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88D0C94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88D1224(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1B88D13C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88D18D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88D1B14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL15_ARLogTechniquev_block_invoke_0()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "Technique");
  id v1 = (void *)_ARLogTechnique(void)::logObj;
  _ARLogTechnique(void)::logObuint64_t j = (uint64_t)v0;
}

void ___ZL13_ARLogGeneralv_block_invoke_4()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "General");
  id v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObuint64_t j = (uint64_t)v0;
}

void std::allocate_shared[abi:ne180100]<arkit::KeyMapBuffer<void const*,std::vector<unsigned char>>,std::allocator<arkit::KeyMapBuffer<void const*,std::vector<unsigned char>>>,int,void>()
{
  os_log_t v0 = operator new(0x78uLL);
  std::__shared_ptr_emplace<arkit::KeyMapBuffer<void const*,std::vector<unsigned char>>>::__shared_ptr_emplace[abi:ne180100]<int,std::allocator<arkit::KeyMapBuffer<void const*,std::vector<unsigned char>>>,0>(v0);
}

void sub_1B88D1D68(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<arkit::KeyMapBuffer<void const*,std::vector<unsigned char>>>::__shared_ptr_emplace[abi:ne180100]<int,std::allocator<arkit::KeyMapBuffer<void const*,std::vector<unsigned char>>>,0>(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F1209998;
  arkit::KeyMapBuffer<void const*,std::vector<unsigned char>>::KeyMapBuffer();
}

void sub_1B88D1DC8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<arkit::KeyMapBuffer<void const*,std::vector<unsigned char>>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1209998;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<arkit::KeyMapBuffer<void const*,std::vector<unsigned char>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1209998;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BA9C56C0);
}

uint64_t std::__shared_ptr_emplace<arkit::KeyMapBuffer<void const*,std::vector<unsigned char>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = a1 + 24;
  std::deque<std::pair<int,int>>::~deque[abi:ne180100]((void *)(a1 + 64));
  return std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::~__hash_table(v1);
}

uint64_t std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::__deallocate_node(a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::__deallocate_node(int a1, void *__p)
{
  if (__p)
  {
    uint64_t v2 = __p;
    do
    {
      uint64_t v3 = (void *)*v2;
      uint64_t v4 = (void *)v2[3];
      if (v4)
      {
        v2[4] = v4;
        operator delete(v4);
      }
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

void std::__shared_weak_count::__release_shared[abi:ne180100](std::__shared_weak_count *a1)
{
  if (!atomic_fetch_add(&a1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a1->__on_zero_shared)(a1);
    std::__shared_weak_count::__release_weak(a1);
  }
}

id _ARLogTechnique_0()
{
  if (_ARLogTechnique_onceToken_0 != -1) {
    dispatch_once(&_ARLogTechnique_onceToken_0, &__block_literal_global_183);
  }
  os_log_t v0 = (void *)_ARLogTechnique_logObj_0;
  return v0;
}

void sub_1B88D324C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void (*)(uint64_t *));
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v11 = va_arg(va2, void);
  uint64_t v13 = va_arg(va2, void);
  uint64_t v14 = va_arg(va2, void);
  uint64_t v15 = va_arg(va2, void);
  va_copy(va3, va2);
  uint64_t v16 = va_arg(va3, void);
  uint64_t v18 = va_arg(va3, void);
  uint64_t v19 = va_arg(va3, void);
  uint64_t v20 = va_arg(va3, void);
  v6((uint64_t *)va);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose(va2, 8);
  _Block_object_dispose(va3, 8);
  _Unwind_Resume(a1);
}

void sub_1B88D5478(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,id location,os_activity_scope_state_s state)
{
  objc_destroyWeak(v28);
  objc_destroyWeak(v27);
  objc_destroyWeak(&location);
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_1B88D5694(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, os_activity_scope_state_s state)
{
}

void sub_1B88D5904(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_1B88D5CC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
}

void sub_1B88D5DDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id location)
{
}

void sub_1B88D5E98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B88D6180(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
}

void sub_1B88D63F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id location)
{
}

void sub_1B88D6790(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
}

void sub_1B88D68C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
}

void sub_1B88D6AEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
}

void sub_1B88D6D5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location, os_activity_scope_state_s state)
{
  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_1B88D7414(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88D7504(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88D781C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88D85B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

__n64 simd_matrix3x3(float32x4_t a1)
{
  _Q2 = a1;
  _S3 = a1.i32[1];
  _S4 = a1.i32[2];
  __asm { FMLS            S0, S4, V2.S[2] }
  _S6 = _Q2.i32[3];
  __asm { FMLA            S0, S6, V2.S[3] }
  float v9 = vmlas_n_f32(vmuls_lane_f32(a1.f32[2], _Q2, 3), a1.f32[1], _Q2.f32[0]);
  __asm
  {
    FMLA            S5, S3, V2.S[1]
    FMLA            S5, S6, V2.S[3]
    FMLS            S5, S2, V2.S[0]
    FMLA            S18, S4, V2.S[1]
    FMLA            S6, S4, V2.S[2]
    FMLS            S6, S2, V2.S[0]
    FMLS            S6, S3, V2.S[1]
  }
  result.n64_f32[1] = v9 + v9;
  return result;
}

void _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE6resizeEm(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 4;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 16 * a2;
    }
  }
  else
  {
    _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE8__appendEm((void **)a1, a2 - v2);
  }
}

void sub_1B88D8AE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88D8FF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88D9180(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B88D95EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88D9860(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88D9E00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,void *a23,void *a24)
{
  _Unwind_Resume(a1);
}

void sub_1B88D9F60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B88DA048(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id ARFilterFaceTrackingPayload(void *a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (v1)
  {
    if (ARFilterFaceTrackingPayload::onceToken != -1) {
      dispatch_once(&ARFilterFaceTrackingPayload::onceToken, &__block_literal_global_254);
    }
    id v15 = (id)objc_opt_new();
    long long v18 = 0u;
    long long v19 = 0u;
    long long v16 = 0u;
    long long v17 = 0u;
    unint64_t v2 = [v1 allKeys];
    uint64_t v3 = [v2 countByEnumeratingWithState:&v16 objects:v20 count:16];
    if (v3)
    {
      uint64_t v4 = *(void *)v17;
      do
      {
        for (uint64_t i = 0; i != v3; ++i)
        {
          if (*(void *)v17 != v4) {
            objc_enumerationMutation(v2);
          }
          uint64_t v6 = *(void *)(*((void *)&v16 + 1) + 8 * i);
          uint64_t v7 = (void *)MEMORY[0x1BA9C6160]();
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            if ([(id)ARFilterFaceTrackingPayload::approvedListNoFurtherFiltering containsObject:v6])goto LABEL_17; {
            if (![(id)ARFilterFaceTrackingPayload::approvedList containsObject:v6])
            }
              goto LABEL_19;
            uint64_t v8 = [v1 objectForKeyedSubscript:v6];
            objc_opt_class();
            char isKindOfClass = objc_opt_isKindOfClass();

            if (isKindOfClass)
            {
              uint64_t v10 = [v1 objectForKeyedSubscript:v6];
              uint64_t v11 = ARFilterFaceTrackingPayload(v10);
              [v15 setObject:v11 forKeyedSubscript:v6];
              goto LABEL_16;
            }
            uint64_t v12 = [v1 objectForKeyedSubscript:v6];
            objc_opt_class();
            char v13 = objc_opt_isKindOfClass();

            if ((v13 & 1) == 0)
            {
LABEL_17:
              uint64_t v10 = [v1 objectForKeyedSubscript:v6];
              [v15 setObject:v10 forKeyedSubscript:v6];
            }
            else
            {
              uint64_t v10 = [v1 objectForKeyedSubscript:v6];
              uint64_t v11 = _ARFilterFaceTrackingPayloadArray(v10);
              [v15 setObject:v11 forKeyedSubscript:v6];
LABEL_16:
            }
          }
LABEL_19:
        }
        uint64_t v3 = [v2 countByEnumeratingWithState:&v16 objects:v20 count:16];
      }
      while (v3);
    }
  }
  else
  {
    id v15 = 0;
  }

  return v15;
}

void sub_1B88DA36C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void __ARFilterFaceTrackingPayload_block_invoke()
{
  id v0 = objc_alloc(MEMORY[0x1E4F1CAD0]);
  uint64_t v1 = objc_msgSend(v0, "initWithObjects:", *MEMORY[0x1E4F4D7C8], *MEMORY[0x1E4F4D7A0], *MEMORY[0x1E4F4D7B8], *MEMORY[0x1E4F4D690], *MEMORY[0x1E4F4D698], *MEMORY[0x1E4F4D798], *MEMORY[0x1E4F4D7A8], *MEMORY[0x1E4F4D7D0], *MEMORY[0x1E4F4D750], *MEMORY[0x1E4F4D768], *MEMORY[0x1E4F4D748], *MEMORY[0x1E4F4D768], *MEMORY[0x1E4F4D758], *MEMORY[0x1E4F4D760], *MEMORY[0x1E4F4D6A8], *MEMORY[0x1E4F4D6B0], *MEMORY[0x1E4F4D6B8],
         *MEMORY[0x1E4F4D6C0],
         *MEMORY[0x1E4F4D6A0],
         *MEMORY[0x1E4F4D6C8],
         *MEMORY[0x1E4F4D740],
         *MEMORY[0x1E4F4D7C0],
         0);
  unint64_t v2 = (void *)ARFilterFaceTrackingPayload::approvedList;
  ARFilterFaceTrackingPayload::approvedList = v1;

  id v3 = objc_alloc(MEMORY[0x1E4F1CAD0]);
  uint64_t v4 = objc_msgSend(v3, "initWithObjects:", *MEMORY[0x1E4F4D730], *MEMORY[0x1E4F4D6F8], *MEMORY[0x1E4F4D6E8], 0);
  uint64_t v5 = (void *)ARFilterFaceTrackingPayload::approvedListNoFurtherFiltering;
  ARFilterFaceTrackingPayload::approvedListNoFurtherFiltering = v4;
}

id _ARFilterFaceTrackingPayloadArray(NSArray *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  unint64_t v2 = objc_opt_new();
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  id v3 = v1;
  uint64_t v4 = [(NSArray *)v3 countByEnumeratingWithState:&v12 objects:v16 count:16];
  uint64_t v5 = v4;
  if (v4)
  {
    uint64_t v6 = *(void *)v13;
    do
    {
      uint64_t v7 = 0;
      do
      {
        if (*(void *)v13 != v6) {
          objc_enumerationMutation(v3);
        }
        uint64_t v8 = *(NSArray **)(*((void *)&v12 + 1) + 8 * v7);
        float v9 = (void *)MEMORY[0x1BA9C6160](v4);
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          uint64_t v10 = ARFilterFaceTrackingPayload(v8);
          [v2 addObject:v10];
LABEL_10:

          goto LABEL_12;
        }
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          uint64_t v10 = _ARFilterFaceTrackingPayloadArray(v8);
          [v2 addObject:v10];
          goto LABEL_10;
        }
        objc_msgSend(v2, "addObject:", v8, (void)v12);
LABEL_12:
        ++v7;
      }
      while (v5 != v7);
      uint64_t v4 = [(NSArray *)v3 countByEnumeratingWithState:&v12 objects:v16 count:16];
      uint64_t v5 = v4;
    }
    while (v4);
  }

  return v2;
}

void sub_1B88DA794(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL13_ARLogGeneralv_block_invoke_5()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "General");
  uint64_t v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObuint64_t j = (uint64_t)v0;
}

char *std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  float v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 2)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *uint64_t v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 62) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 1;
    if (v8 >> 1 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v11 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    __n64 result = std::vector<float>::__vallocate[abi:ne180100](v7, v11);
    long long v13 = (char *)v7[1];
    long long v12 = (void **)(v7 + 1);
    float v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      long long v18 = v9;
      long long v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  long long v12 = (void **)(result + 8);
  long long v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 2;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  long long v16 = &__src[4 * v15];
  if (v14 != v9)
  {
    __n64 result = (char *)memmove(*(void **)result, __src, v14 - v9);
    float v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    long long v18 = v9;
    long long v19 = v16;
LABEL_18:
    __n64 result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *long long v12 = &v9[v17];
  return result;
}

char *std::vector<float>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >> 62) {
    std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
  }
  __n64 result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[4 * v4];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(4 * a2);
}

void _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE8__appendEm(void **a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 4)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 16 * a2);
      v7 += 16 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = v7 - (unsigned char *)*a1;
    unint64_t v9 = a2 + (v8 >> 4);
    if (v9 >> 60) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 4;
    uint64_t v11 = v5 - (unsigned char *)*a1;
    if (v11 >> 3 > v9) {
      unint64_t v9 = v11 >> 3;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v12 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v9;
    }
    if (v12) {
      long long v13 = (char *)_ZNSt3__119__allocate_at_leastB8ne180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m(v4, v12);
    }
    else {
      long long v13 = 0;
    }
    long long v14 = &v13[16 * v10];
    unint64_t v15 = &v13[16 * v12];
    bzero(v14, 16 * a2);
    long long v16 = &v14[16 * a2];
    long long v18 = (char *)*a1;
    size_t v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        long long v19 = *((_OWORD *)v17 - 1);
        v17 -= 16;
        *((_OWORD *)v14 - 1) = v19;
        v14 -= 16;
      }
      while (v17 != v18);
      size_t v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
    {
      operator delete(v17);
    }
  }
}

void *std::vector<float>::__init_with_size[abi:ne180100]<float const*,float const*>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n64 result = std::vector<float>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      __n64 result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1B88DAB1C(_Unwind_Exception *exception_object)
{
  id v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *_ZNSt3__16vectorIDv2_fNS_9allocatorIS1_EEEC2Em(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_1B88DAB94(_Unwind_Exception *exception_object)
{
  id v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *_ZNSt3__16vectorIDv2_fNS_9allocatorIS1_EEE16__init_with_sizeB8ne180100IPKS1_S7_EEvT_T0_m(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n64 result = std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      __n64 result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1B88DAC10(_Unwind_Exception *exception_object)
{
  id v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B88DADA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  uint64_t v11 = v10;

  a9.super_class = (Class)ARFaceTrackingImageSensor;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

id _ARLogSensor(void)
{
  if (_ARLogSensor(void)::onceToken != -1) {
    dispatch_once(&_ARLogSensor(void)::onceToken, &__block_literal_global_143);
  }
  os_log_t v0 = (void *)_ARLogSensor(void)::logObj;
  return v0;
}

void sub_1B88DAF5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88DB170(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88DB258(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88DBA48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

void sub_1B88DBC38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88DBD3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88DBFB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88DC1F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88DCCEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

void sub_1B88DCFFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88DD5EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17)
{
  _Unwind_Resume(a1);
}

void sub_1B88DD774(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88DDD34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1B88DDEE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void ___ZL12_ARLogSensorv_block_invoke()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "Sensor");
  uint64_t v1 = (void *)_ARLogSensor(void)::logObj;
  _ARLogSensor(void)::logObuint64_t j = (uint64_t)v0;
}

uint64_t rawGyroscopeCallback(uint64_t a1, void *a2)
{
  kdebug_trace();
  [a2 gyroscopeOutput:a1];
  return kdebug_trace();
}

uint64_t rawAccelerometerCallback(uint64_t a1, void *a2)
{
  kdebug_trace();
  [a2 accelerometerOutput:a1];
  return kdebug_trace();
}

uint64_t rawMagnetometerCallback(uint64_t a1, void *a2)
{
  kdebug_trace();
  [a2 magnetometerOutput:a1];
  return kdebug_trace();
}

id _ARLogSensor_0()
{
  if (_ARLogSensor_onceToken_0 != -1) {
    dispatch_once(&_ARLogSensor_onceToken_0, &__block_literal_global_19);
  }
  os_log_t v0 = (void *)_ARLogSensor_logObj_0;
  return v0;
}

id ARDictionaryFromAnchors(void *a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  unint64_t v2 = objc_msgSend(MEMORY[0x1E4F1CA60], "dictionaryWithCapacity:", objc_msgSend(v1, "count"));
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  id v3 = v1;
  uint64_t v4 = [v3 countByEnumeratingWithState:&v11 objects:v15 count:16];
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = *(void *)v12;
    do
    {
      for (uint64_t i = 0; i != v5; ++i)
      {
        if (*(void *)v12 != v6) {
          objc_enumerationMutation(v3);
        }
        size_t v8 = *(void **)(*((void *)&v11 + 1) + 8 * i);
        unint64_t v9 = objc_msgSend(v8, "identifier", (void)v11);
        [v2 setObject:v8 forKey:v9];
      }
      uint64_t v5 = [v3 countByEnumeratingWithState:&v11 objects:v15 count:16];
    }
    while (v5);
  }

  return v2;
}

id ARAnchorsForPoseGraphUpdates(void *a1)
{
  id v1 = (void *)MEMORY[0x1E4F28F60];
  id v2 = a1;
  id v3 = [v1 predicateWithBlock:&__block_literal_global_20];
  uint64_t v4 = [v2 filteredArrayUsingPredicate:v3];

  return v4;
}

uint64_t __ARAnchorsForPoseGraphUpdates_block_invoke(uint64_t a1, void *a2)
{
  id v2 = a2;
  if (objc_opt_respondsToSelector() & 1) != 0 || (objc_opt_class(), (objc_opt_isKindOfClass()))
  {
    char v3 = 0;
  }
  else
  {
    objc_opt_class();
    char v3 = objc_opt_isKindOfClass() ^ 1;
  }

  return v3 & 1;
}

id ARAnchorsForPublicDelegate(void *a1)
{
  id v1 = (void *)MEMORY[0x1E4F28F60];
  id v2 = a1;
  char v3 = [v1 predicateWithBlock:&__block_literal_global_55];
  uint64_t v4 = [v2 filteredArrayUsingPredicate:v3];

  return v4;
}

uint64_t __ARAnchorsForPublicDelegate_block_invoke(uint64_t a1, void *a2)
{
  return [a2 isHiddenFromPublicDelegate] ^ 1;
}

__IOHIDServiceClient *copyHIDServicePlugin(__IOHIDEventSystemClient *a1, int a2, int a3, const char *a4)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  int v35 = a3;
  int valuePtr = a2;
  if (!a1) {
    return 0;
  }
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFNumberRef v7 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v8 = CFNumberCreate(v6, kCFNumberSInt32Type, &v35);
  *(_OWORD *)keys = xmmword_1E6185C60;
  values[0] = v7;
  values[1] = v8;
  CFDictionaryRef v9 = CFDictionaryCreate(v6, (const void **)keys, (const void **)values, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  IOHIDEventSystemClientSetMatching();
  CFArrayRef v10 = IOHIDEventSystemClientCopyServices(a1);
  CFArrayRef v11 = v10;
  if (!v10 || CFArrayGetCount(v10) < 1 || (CFIndex Count = CFArrayGetCount(v11), Count < 1))
  {
    ValueAtIndex = 0;
    goto LABEL_27;
  }
  CFIndex v13 = Count;
  CFNumberRef v32 = v8;
  CFNumberRef v33 = v7;
  CFIndex v14 = 0;
  while (1)
  {
    ValueAtIndex = (__IOHIDServiceClient *)CFArrayGetValueAtIndex(v11, v14);
    uint64_t v16 = (void *)IOHIDServiceClientCopyProperty(ValueAtIndex, @"PrimaryUsage");
    if (!v16) {
      goto LABEL_21;
    }
    size_t v17 = v16;
    int v18 = [v16 intValue];
    int v19 = v35;
    CFRelease(v17);
    if (v18 != v19) {
      goto LABEL_21;
    }
    if (!a4 || !*a4) {
      break;
    }
    CFStringRef v20 = (const __CFString *)IOHIDServiceClientCopyProperty(ValueAtIndex, @"LocationID");
    if (v20)
    {
      CFStringRef v21 = v20;
      CFTypeID v22 = CFGetTypeID(v20);
      if (v22 == CFStringGetTypeID())
      {
        CStringPtr = CFStringGetCStringPtr(v21, 0x8000100u);
        size_t v24 = strlen(a4);
        if (v24 != strlen(CStringPtr)) {
          goto LABEL_20;
        }
        id v25 = a4;
        uint64_t v26 = (char *)CStringPtr;
        size_t v27 = v24;
      }
      else
      {
        CFTypeID v28 = CFGetTypeID(v21);
        if (v28 != CFNumberGetTypeID()
          || (uint64_t v34 = 0, !CFNumberGetValue((CFNumberRef)v21, kCFNumberLongType, &v34))
          || (snprintf(__str, 0x20uLL, "%lu", v34), size_t v29 = strlen(a4), v29 != strlen(__str)))
        {
LABEL_20:
          CFRelease(v21);
          goto LABEL_21;
        }
        uint64_t v26 = __str;
        id v25 = a4;
        size_t v27 = v29;
      }
      int v30 = strncmp(v25, v26, v27);
      CFRelease(v21);
      if (!v30) {
        break;
      }
    }
LABEL_21:
    if (v13 == ++v14)
    {
      ValueAtIndex = 0;
      goto LABEL_26;
    }
  }
  CFRetain(ValueAtIndex);
LABEL_26:
  CFNumberRef v8 = v32;
  CFNumberRef v7 = v33;
LABEL_27:
  CFRelease(v9);
  CFRelease(v7);
  CFRelease(v8);
  if (v11) {
    CFRelease(v11);
  }
  return ValueAtIndex;
}

void rawIOHIDEventCallback(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  id v5 = a1;
  mach_timebase_info info = 0;
  mach_timebase_info(&info);
  LODWORD(v7) = info.denom;
  LODWORD(v6) = info.numer;
  double v8 = (double)v6 / (double)v7 * 0.000000001 * (double)(unint64_t)IOHIDEventGetTimeStamp();
  if (IOHIDEventGetType() == 13)
  {
    kdebug_trace();
    [v5 accelerometerDidOutputEvent:a4 timestamp:v8];
LABEL_5:
    kdebug_trace();
    goto LABEL_6;
  }
  if (IOHIDEventGetType() == 20)
  {
    kdebug_trace();
    [v5 gyroscopeDidOutputEvent:a4 timestamp:v8];
    goto LABEL_5;
  }
LABEL_6:
}

void sub_1B88E139C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88E14EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88E1674(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88E1754(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88E1870(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88E1BFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23)
{
  if (__p) {
    operator delete(__p);
  }
  if (a19) {
    operator delete(a19);
  }
  if (a22) {
    operator delete(a22);
  }
  id v25 = *(void **)(v23 - 112);
  if (v25)
  {
    *(void *)(v23 - 104) = v25;
    operator delete(v25);
  }

  _Unwind_Resume(a1);
}

void _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE7reserveEm(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 4)
  {
    if (a2 >> 60) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    unint64_t v6 = (char *)_ZNSt3__119__allocate_at_leastB8ne180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m(v3, a2);
    unint64_t v7 = &v6[v5];
    CFDictionaryRef v9 = &v6[16 * v8];
    CFArrayRef v11 = (char *)*a1;
    CFArrayRef v10 = (char *)a1[1];
    long long v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        long long v13 = *((_OWORD *)v10 - 1);
        v10 -= 16;
        *((_OWORD *)v12 - 1) = v13;
        v12 -= 16;
      }
      while (v10 != v11);
      CFArrayRef v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

void std::vector<unsigned long long>::reserve(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 3)
  {
    if (a2 >> 61) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    unint64_t v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>(v3, a2);
    unint64_t v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    CFDictionaryRef v9 = &v6[8 * v8];
    CFArrayRef v10 = (char *)*a1;
    CFArrayRef v11 = (char *)a1[1];
    long long v12 = v7;
    if (v11 != *a1)
    {
      long long v12 = v7;
      do
      {
        uint64_t v13 = *((void *)v11 - 1);
        v11 -= 8;
        *((void *)v12 - 1) = v13;
        v12 -= 8;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

void sub_1B88E2228(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28)
{
  if (__p) {
    operator delete(__p);
  }
  if (a19) {
    operator delete(a19);
  }
  if (a23) {
    operator delete(a23);
  }
  if (a27) {
    operator delete(a27);
  }
  int v30 = *(void **)(v28 - 160);
  if (v30)
  {
    *(void *)(v28 - 152) = v30;
    operator delete(v30);
  }
  long long v31 = *(void **)(v28 - 128);
  if (v31)
  {
    *(void *)(v28 - 120) = v31;
    operator delete(v31);
  }

  _Unwind_Resume(a1);
}

void std::vector<float>::reserve(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 2)
  {
    if (a2 >> 62) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    unint64_t v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v3, a2);
    unint64_t v7 = &v6[v5 & 0xFFFFFFFFFFFFFFFCLL];
    CFDictionaryRef v9 = &v6[4 * v8];
    CFArrayRef v10 = (char *)*a1;
    CFArrayRef v11 = (char *)a1[1];
    long long v12 = v7;
    if (v11 != *a1)
    {
      long long v12 = v7;
      do
      {
        int v13 = *((_DWORD *)v11 - 1);
        v11 -= 4;
        *((_DWORD *)v12 - 1) = v13;
        v12 -= 4;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

void std::vector<unsigned long long>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 8 * a2;
    }
  }
  else
  {
    std::vector<unsigned long long>::__append((char **)a1, a2 - v2);
  }
}

void std::vector<float>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 2;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 4 * a2;
    }
  }
  else
  {
    std::vector<float>::__append((char **)a1, a2 - v2);
  }
}

void sub_1B88E2488(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  if (__p) {
    operator delete(__p);
  }
  if (a13) {
    operator delete(a13);
  }
  uint64_t v16 = *(void **)(v14 - 48);
  if (v16)
  {
    *(void *)(v14 - 40) = v16;
    operator delete(v16);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B88E267C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88E2C50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24)
{
  if (__p) {
    operator delete(__p);
  }
  if (a19) {
    operator delete(a19);
  }
  if (a23) {
    operator delete(a23);
  }
  uint64_t v26 = *(void **)(v24 - 112);
  if (v26)
  {
    *(void *)(v24 - 104) = v26;
    operator delete(v26);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B88E2FA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22)
{
  if (__p) {
    operator delete(__p);
  }
  if (a13) {
    operator delete(a13);
  }
  if (a17) {
    operator delete(a17);
  }
  if (a21) {
    operator delete(a21);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B88E3574(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,char a46,void *a47)
{
  if (__p) {
    operator delete(__p);
  }
  if (a29) {
    operator delete(a29);
  }
  if (a33) {
    operator delete(a33);
  }
  std::__tree<std::array<unsigned char,16ul>>::destroy((uint64_t)&a46, a47);

  _Unwind_Resume(a1);
}

void sub_1B88E36CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, char a12)
{
  if (__p) {
    operator delete(__p);
  }
  +[ARPointCloud emptyPointCloud]((uint64_t)&a12);
  _Unwind_Resume(a1);
}

void sub_1B88E3934(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88E3B80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26)
{
  if (__p) {
    operator delete(__p);
  }
  if (a22) {
    operator delete(a22);
  }
  if (a25) {
    operator delete(a25);
  }
  uint64_t v28 = *(void **)(v26 - 96);
  if (v28)
  {
    *(void *)(v26 - 88) = v28;
    operator delete(v28);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B88E3C7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88E3E54(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B88E3F24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B88E40E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::vector<unsigned long long>::__append(char **a1, unint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  int64_t v5 = v6;
  unint64_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = *a1;
    uint64_t v9 = v7 - *a1;
    unint64_t v10 = a2 + (v9 >> 3);
    if (v10 >> 61) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = v9 >> 3;
    uint64_t v12 = v5 - v8;
    if (v12 >> 2 > v10) {
      unint64_t v10 = v12 >> 2;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v10;
    }
    if (v13)
    {
      uint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>(v4, v13);
      uint64_t v8 = *a1;
      unint64_t v7 = a1[1];
    }
    else
    {
      uint64_t v14 = 0;
    }
    unint64_t v15 = &v14[8 * v11];
    uint64_t v16 = &v14[8 * v13];
    bzero(v15, 8 * a2);
    size_t v17 = &v15[8 * a2];
    while (v7 != v8)
    {
      uint64_t v18 = *((void *)v7 - 1);
      v7 -= 8;
      *((void *)v15 - 1) = v18;
      v15 -= 8;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

void std::vector<float>::__append(char **a1, unint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  int64_t v5 = v6;
  unint64_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 2)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 4 * a2);
      v7 += 4 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = *a1;
    uint64_t v9 = v7 - *a1;
    unint64_t v10 = a2 + (v9 >> 2);
    if (v10 >> 62) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = v9 >> 2;
    uint64_t v12 = v5 - v8;
    if (v12 >> 1 > v10) {
      unint64_t v10 = v12 >> 1;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v13 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v10;
    }
    if (v13)
    {
      uint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v4, v13);
      uint64_t v8 = *a1;
      unint64_t v7 = a1[1];
    }
    else
    {
      uint64_t v14 = 0;
    }
    unint64_t v15 = &v14[4 * v11];
    uint64_t v16 = &v14[4 * v13];
    bzero(v15, 4 * a2);
    size_t v17 = &v15[4 * a2];
    while (v7 != v8)
    {
      int v18 = *((_DWORD *)v7 - 1);
      v7 -= 4;
      *((_DWORD *)v15 - 1) = v18;
      v15 -= 4;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

__n128 _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE13__move_assignERS4_NS_17integral_constantIbLb1EEE(uint64_t a1, __n128 *a2)
{
  uint64_t v4 = *(void **)a1;
  if (v4)
  {
    *(void *)(a1 + 8) = v4;
    operator delete(v4);
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
  }
  __n128 result = *a2;
  *(__n128 *)a1 = *a2;
  *(void *)(a1 + 16) = a2[1].n128_u64[0];
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  return result;
}

void *std::vector<unsigned long long>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_1B88E447C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t **_ZNSt3__16__treeINS_12__value_typeIyDv4_fEENS_19__map_value_compareIyS3_NS_4lessIyEELb1EEENS_9allocatorIS3_EEE25__emplace_unique_key_argsIyJNS_4pairIyS2_EEEEENSC_INS_15__tree_iteratorIS3_PNS_11__tree_nodeIS3_PvEElEEbEERKT_DpOT0_(uint64_t **a1, unint64_t *a2, uint64_t a3)
{
  unint64_t v6 = a1 + 1;
  int64_t v5 = a1[1];
  if (v5)
  {
    unint64_t v7 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v8 = (uint64_t **)v5;
        unint64_t v9 = v5[4];
        if (v7 >= v9) {
          break;
        }
        int64_t v5 = *v8;
        unint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      int64_t v5 = v8[1];
      if (!v5)
      {
        unint64_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v8 = a1 + 1;
LABEL_10:
    unint64_t v10 = operator new(0x40uLL);
    v10[4] = *(void *)a3;
    *((_OWORD *)v10 + 3) = *(_OWORD *)(a3 + 16);
    _ZNSt3__16__treeINS_12__value_typeIyDv4_fEENS_19__map_value_compareIyS3_NS_4lessIyEELb1EEENS_9allocatorIS3_EEE16__insert_node_atEPNS_15__tree_end_nodeIPNS_16__tree_node_baseIPvEEEERSF_SF_(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }
  return v8;
}

uint64_t *_ZNSt3__16__treeINS_12__value_typeIyDv4_fEENS_19__map_value_compareIyS3_NS_4lessIyEELb1EEENS_9allocatorIS3_EEE16__insert_node_atEPNS_15__tree_end_nodeIPNS_16__tree_node_baseIPvEEEERSF_SF_(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  int64_t v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  __n128 result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t *std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  *((unsigned char *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      unint64_t v2 = (uint64_t *)a2[2];
      if (*((unsigned char *)v2 + 24)) {
        return result;
      }
      uint64_t v3 = (uint64_t *)v2[2];
      uint64_t v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        uint64_t v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), int64_t v5 = (unsigned char *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            unint64_t v9 = (uint64_t **)a2[2];
          }
          else
          {
            unint64_t v9 = (uint64_t **)v2[1];
            unint64_t v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              uint64_t v3 = (uint64_t *)v2[2];
            }
            void v9[2] = v3;
            *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = v9;
            char *v9 = v2;
            v2[2] = (uint64_t)v9;
            uint64_t v3 = v9[2];
            unint64_t v2 = (uint64_t *)*v3;
          }
          *((unsigned char *)v9 + 24) = 1;
          *((unsigned char *)v3 + 24) = 0;
          uint64_t v13 = v2[1];
          uint64_t *v3 = v13;
          if (v13) {
            *(void *)(v13 + 16) = v3;
          }
          v2[2] = v3[2];
          *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), int64_t v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          uint64_t v11 = a2[1];
          uint64_t *v2 = v11;
          if (v11)
          {
            *(void *)(v11 + 16) = v2;
            uint64_t v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          uint64_t v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((unsigned char *)a2 + 24) = 1;
        *((unsigned char *)v3 + 24) = 0;
        unint64_t v2 = (uint64_t *)v3[1];
        uint64_t v12 = *v2;
        v3[1] = *v2;
        if (v12) {
          *(void *)(v12 + 16) = v3;
        }
        v2[2] = v3[2];
        *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
        uint64_t *v2 = (uint64_t)v3;
LABEL_27:
        void v3[2] = (uint64_t)v2;
        return result;
      }
      *((unsigned char *)v2 + 24) = 1;
      a2 = v3;
      *((unsigned char *)v3 + 24) = v3 == result;
      *int64_t v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

void *std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    int v6 = result;
    __n128 result = std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      __n128 result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1B88E47AC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    int v6 = result;
    __n128 result = std::vector<float>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      __n128 result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1B88E4828(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double ARRotateCovariance(double a1, double a2, __n128 a3, int32x4_t a4, int32x4_t a5, int32x4_t a6)
{
  uint64_t v6 = 0;
  int32x4_t v7 = vzip1q_s32(a4, a6);
  int32x4_t v8 = vzip1q_s32(v7, a5);
  int32x4_t v9 = vzip1q_s32(vzip2q_s32(a4, a6), vdupq_laneq_s32(a5, 2));
  int32x4_t v10 = vzip2q_s32(v7, vdupq_lane_s32(*(int32x2_t *)a5.i8, 1));
  __n128 v17 = a3;
  float32x4_t v18 = 0u;
  float32x4_t v19 = 0u;
  float32x4_t v20 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v18 + v6 * 16) = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)a4, COERCE_FLOAT(v16[v6])), (float32x4_t)a5, *(float32x2_t *)&v16[v6], 1), (float32x4_t)a6, (float32x4_t)v16[v6], 2);
    ++v6;
  }
  while (v6 != 3);
  uint64_t v11 = 0;
  v8.i32[3] = 0;
  v10.i32[3] = 0;
  v9.i32[3] = 0;
  float32x4_t v12 = v18;
  float32x4_t v13 = v19;
  float32x4_t v14 = v20;
  v16[0] = v8;
  v16[1] = v10;
  __n128 v17 = (__n128)v9;
  float32x4_t v18 = 0u;
  float32x4_t v19 = 0u;
  float32x4_t v20 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v18 + v11 * 16) = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v12, COERCE_FLOAT(v16[v11])), v13, *(float32x2_t *)&v16[v11], 1), v14, (float32x4_t)v16[v11], 2);
    ++v11;
  }
  while (v11 != 3);
  return *(double *)v18.i64;
}

float tanFromCos(float a1)
{
  return sqrtf(1.0 - (float)(a1 * a1)) / a1;
}

float computeVarianceInCamZ(__n128 a1, float a2)
{
  float v2 = a1.n128_f32[2] / (float)(sqrtf(1.0 - (float)(a2 * a2)) / a2);
  return (float)(v2 * *(float *)&k_viofeature_normalized_disparity_error)
       * (float)(v2 * *(float *)&k_viofeature_normalized_disparity_error);
}

__n64 ARPointVarianceVIOFeature()
{
  result.n64_u32[0] = k_viofeature_variance_xy;
  result.n64_u32[1] = k_viofeature_variance_xy;
  return result;
}

double ARPointCovarianceVIOFeature(__n128 a1, int32x4_t a2, int32x4_t a3, int32x4_t a4, float a5)
{
  float v8 = sqrtf(1.0 - (float)(a5 * a5));
  *(float *)&unsigned int v9 = (float)((float)(a1.n128_f32[2] / (float)(v8 / a5)) * *(float *)&k_viofeature_normalized_disparity_error)
                * (float)((float)(a1.n128_f32[2] / (float)(v8 / a5)) * *(float *)&k_viofeature_normalized_disparity_error);
  v10.n128_u64[0] = 0;
  LODWORD(v11) = 0;
  HIDWORD(v11) = k_viofeature_variance_xy;
  v10.n128_u64[1] = v9;
  return ARRotateCovariance(COERCE_DOUBLE((unint64_t)k_viofeature_variance_xy), v11, v10, a2, a3, a4);
}

__n64 ARPointVarianceJasper()
{
  result.n64_u32[0] = k_jasper_variance_uv;
  result.n64_u32[1] = k_jasper_variance_uv;
  return result;
}

double ARPointCovarianceJasper(__n128 a1, int32x4_t a2, int32x4_t a3, int32x4_t a4)
{
  a1.n128_f32[0] = *(float *)&k_jasper_max_z - a1.n128_f32[2];
  if ((float)(*(float *)&k_jasper_max_z - a1.n128_f32[2]) < 0.0) {
    a1.n128_f32[0] = 0.0;
  }
  v7.n128_u64[0] = 0;
  LODWORD(v8) = 0;
  HIDWORD(v8) = k_jasper_variance_uv;
  v7.n128_u64[1] = COERCE_UNSIGNED_INT(*(float *)&k_jasper_variance_z * (float)(1.0
                                                                              - (float)(a1.n128_f32[0]
                                                                                      / *(float *)&k_jasper_max_z)));
  return ARRotateCovariance(COERCE_DOUBLE((unint64_t)k_jasper_variance_uv), v8, v7, a2, a3, a4);
}

void *ar_rt_frame_time_estimator_init(uint64_t a1, int a2)
{
  ar_rt_ring_buffer_init(a1, a2);
  __n64 result = malloc_type_calloc(a2, 8uLL, 0x100004000313F17uLL);
  *(void *)(a1 + 16) = result;
  return result;
}

void ar_rt_frame_time_estimator_reset(uint64_t a1)
{
  ar_rt_ring_buffer_reset(a1);
  float v2 = *(void **)(a1 + 16);
  free(v2);
}

uint64_t ar_rt_frame_time_estimator_add_frame_time(uint64_t a1, double a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t result = ar_rt_ring_buffer_add_element((int *)a1);
  *(double *)(v3 + 8 * (int)result) = a2;
  return result;
}

BOOL ar_rt_frame_time_estimator_estimate_frame_time(uint64_t a1, double *a2)
{
  BOOL v4 = ar_rt_ring_buffer_filled((_DWORD *)a1);
  if (v4)
  {
    int v5 = ar_rt_ring_buffer_increment_index((_DWORD *)a1, *(_DWORD *)(a1 + 4));
    if (v5 == *(_DWORD *)(a1 + 4))
    {
      double v6 = NAN;
    }
    else
    {
      int v7 = v5;
      unint64_t v8 = 0;
      double v9 = 0.0;
      do
      {
        int v10 = ar_rt_ring_buffer_increment_index((_DWORD *)a1, v7);
        double v9 = v9 + *(double *)(*(void *)(a1 + 16) + 8 * v10) - *(double *)(*(void *)(a1 + 16) + 8 * v7);
        ++v8;
        int v7 = v10;
      }
      while (v10 != *(_DWORD *)(a1 + 4));
      double v6 = v9 / (double)v8;
    }
    *a2 = v6;
  }
  return v4;
}

id _ARLogTechnique_1()
{
  if (_ARLogTechnique_onceToken_1 != -1) {
    dispatch_once(&_ARLogTechnique_onceToken_1, &__block_literal_global_23);
  }
  os_log_t v0 = (void *)_ARLogTechnique_logObj_1;
  return v0;
}

id reportingQueue()
{
  if (reportingQueue_onceToken != -1) {
    dispatch_once(&reportingQueue_onceToken, &__block_literal_global_622);
  }
  os_log_t v0 = (void *)reportingQueue_s_reportingQueue;
  return v0;
}

id hitTestReportingMap()
{
  if (hitTestReportingMap_onceToken != -1) {
    dispatch_once(&hitTestReportingMap_onceToken, &__block_literal_global_624);
  }
  os_log_t v0 = (void *)hitTestReportingMap_s_hitTestReporting;
  return v0;
}

id bundleID()
{
  if (bundleID_onceToken != -1) {
    dispatch_once(&bundleID_onceToken, &__block_literal_global_627);
  }
  os_log_t v0 = (void *)bundleID_bundleID;
  return v0;
}

void __reportingQueue_block_invoke()
{
  float v2 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  dispatch_queue_t v0 = dispatch_queue_create(0, v2);
  uint64_t v1 = (void *)reportingQueue_s_reportingQueue;
  reportingQueue_s_reportingQueue = (uint64_t)v0;
}

void __hitTestReportingMap_block_invoke()
{
  uint64_t v0 = objc_opt_new();
  uint64_t v1 = (void *)hitTestReportingMap_s_hitTestReporting;
  hitTestReportingMap_s_hitTestReporting = v0;
}

void __bundleID_block_invoke()
{
  uint64_t v0 = [MEMORY[0x1E4F28B50] mainBundle];
  uint64_t v1 = [v0 bundleIdentifier];
  float v2 = (void *)bundleID_bundleID;
  bundleID_bundleID = v1;

  if (!bundleID_bundleID)
  {
    id v5 = [MEMORY[0x1E4F28F80] processInfo];
    uint64_t v3 = [v5 processName];
    BOOL v4 = (void *)bundleID_bundleID;
    bundleID_bundleID = v3;
  }
}

void sub_1B88EE4B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ARLLAToECEF@<X0>(_OWORD *a1@<X8>)
{
  uint64_t result = cnnavigation::LLAToECEF();
  long long v3 = 0uLL;
  long long v4 = 0uLL;
  if (!result)
  {
    *(void *)&long long v4 = 0;
    long long v3 = 0uLL;
  }
  *a1 = v3;
  a1[1] = v4;
  return result;
}

int8x16_t ARECEFToLLA@<Q0>(int8x16_t *a1@<X8>)
{
  __int32 v2 = cnnavigation::ECEFToLLA();
  v3.i32[0] = 0;
  v4.i32[0] = v2;
  int8x16_t v5 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32(v4, v3), 0);
  float64x2_t v6 = (float64x2_t)vdupq_n_s64(0x404CA5DC1A63C1F8uLL);
  int8x16_t v7 = vandq_s8((int8x16_t)vmulq_f64((float64x2_t)0, v6), v5);
  v6.f64[0] = 0.0;
  int8x16_t result = vbslq_s8(v5, (int8x16_t)v6, (int8x16_t)0);
  *a1 = v7;
  a1[1] = result;
  return result;
}

uint64_t ARECEFToENU@<X0>(_OWORD *a1@<X8>)
{
  uint64_t result = cnnavigation::ECEFToENU();
  long long v3 = 0uLL;
  long long v4 = 0uLL;
  if (!result)
  {
    long long v3 = v5;
    *(void *)&long long v4 = v6;
  }
  *a1 = v3;
  a1[1] = v4;
  return result;
}

uint64_t ARENUToECEF@<X0>(_OWORD *a1@<X8>)
{
  uint64_t result = cnnavigation::ENUToECEF();
  long long v3 = 0uLL;
  long long v4 = 0uLL;
  if (!result)
  {
    long long v3 = v5;
    *(void *)&long long v4 = v6;
  }
  *a1 = v3;
  a1[1] = v4;
  return result;
}

void ARENUToECEFTransform(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  float64x2_t v3 = *(float64x2_t *)a1;
  long long v4 = (_OWORD *)MEMORY[0x1E4F14990];
  long long v5 = *(_OWORD *)(MEMORY[0x1E4F14990] + 80);
  a2[4] = *(_OWORD *)(MEMORY[0x1E4F14990] + 64);
  a2[5] = v5;
  long long v6 = v4[7];
  a2[6] = v4[6];
  a2[7] = v6;
  long long v7 = v4[1];
  *a2 = *v4;
  a2[1] = v7;
  long long v8 = v4[3];
  a2[2] = v4[2];
  a2[3] = v8;
  double v9 = *(void **)(a1 + 16);
  float64x2_t v16 = vmulq_f64(v3, (float64x2_t)vdupq_n_s64(0x3F91DF46A2529D39uLL));
  float64x2_t v22 = v16;
  uint64_t v23 = v9;
  memset(v18, 0, sizeof(v18));
  int v10 = cnnavigation::LLAToECEF();
  long long v11 = 0uLL;
  uint64_t v17 = 0;
  if (!v10)
  {
    long long v11 = *(_OWORD *)v18;
    uint64_t v17 = *(void *)&v18[16];
  }
  long long v15 = v11;
  long long v29 = xmmword_1B8A2B610;
  uint64_t v30 = 0x3FF0000000000000;
  *(float64x2_t *)&v27[104] = v16;
  uint64_t v28 = v9;
  LOBYTE(v22.f64[1]) = 0;
  uint64_t v25 = 0x300000003;
  uint64_t v23 = &unk_1F12098F8;
  long long v24 = xmmword_1B8A2B600;
  uint64_t v26 = v27;
  *(void *)&v22.f64[0] = MEMORY[0x1E4F5C970] + 16;
  if (!cnnavigation::ENUToECEF())
  {
    uint64_t v19 = 0x300000003;
    *(void *)float32x4_t v18 = &unk_1F12098F8;
    *(_OWORD *)&v18[8] = xmmword_1B8A2B600;
    float32x4_t v20 = &v21;
    for (uint64_t i = 0; i != 3; ++i)
    {
      for (unsigned int j = 0; j != 3; ++j)
        *((void *)&a2[2 * i] + j) = *(void *)cnmatrix::CNMatrixBase<double>::operator()((uint64_t)v18, j, i);
    }
  }
  *(void *)&long long v14 = v17;
  *((void *)&v14 + 1) = 1.0;
  a2[6] = v15;
  a2[7] = v14;
  cnnavigation::ENUToECEFJacobian::~ENUToECEFJacobian((cnnavigation::ENUToECEFJacobian *)&v22);
}

void sub_1B88EEA5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
}

void *cnmatrix::CNMatrix<3u,3u,double>::~CNMatrix(void *result)
{
  *uint64_t result = &unk_1F12098C8;
  return result;
}

void ARAnchorToECEFTransform(_OWORD *a1@<X0>, _OWORD *a2@<X8>)
{
  long long v2 = a1[1];
  v3[0] = *a1;
  v3[1] = v2;
  ARENUToECEFTransform((uint64_t)v3, a2);
}

uint64_t find_index(const __int16 *a1, __int16 a2, __int16 a3, unint64_t a4, unint64_t a5, unint64_t *a6)
{
  while (1)
  {
    unint64_t v6 = (a5 + a4) >> 1;
    int v7 = (unsigned __int16)a1[3 * v6];
    if (v7 == (unsigned __int16)a2) {
      break;
    }
    if ((__int16)v7 <= a2) {
      goto LABEL_6;
    }
LABEL_7:
    a5 = v6;
    if (v6 <= a4) {
      return 0;
    }
  }
  int v8 = (unsigned __int16)a1[3 * ((a5 + a4) >> 1) + 1];
  if (v8 != (unsigned __int16)a3)
  {
    if ((__int16)v8 > a3) {
      goto LABEL_7;
    }
LABEL_6:
    a4 = v6 + 1;
    unint64_t v6 = a5;
    goto LABEL_7;
  }
  *a6 = v6;
  return 1;
}

double ARGetFallbackUndulationValue(double a1, double a2)
{
  unint64_t v2 = 0;
  int v3 = (unsigned __int16)(int)((a1 + 90.0) * 10.0);
  int v4 = (unsigned __int16)(int)((a2 + 180.0) * 10.0);
  uint64_t v5 = 2173;
  while (1)
  {
    unint64_t v6 = (v5 + v2) >> 1;
    int v7 = undulation_constants[3 * v6];
    if (v7 == v3) {
      break;
    }
    if ((__int16)v7 <= (__int16)v3) {
      goto LABEL_7;
    }
LABEL_8:
    uint64_t v5 = v6;
    if (v6 <= v2) {
      return NAN;
    }
  }
  int v8 = (char *)&undulation_constants[3 * ((v5 + v2) >> 1)];
  int v9 = *((unsigned __int16 *)v8 + 1);
  if (v9 != v4)
  {
    if ((__int16)v9 > (__int16)v4) {
      goto LABEL_8;
    }
LABEL_7:
    unint64_t v2 = v6 + 1;
    unint64_t v6 = v5;
    goto LABEL_8;
  }
  return (double)*((__int16 *)v8 + 2) * 0.01;
}

double ARMSLToWGS84Altitude(double a1, double a2)
{
  return a1 + a2;
}

double ARWGS84ToMSLAltitude(double a1, double a2)
{
  return a1 - a2;
}

double ARLInfinityDistance(double a1, double a2, double a3, double a4)
{
  int v8 = (void *)[objc_alloc(MEMORY[0x1E4F1E5F0]) initWithLatitude:a1 longitude:a2];
  int v9 = (void *)[objc_alloc(MEMORY[0x1E4F1E5F0]) initWithLatitude:a3 longitude:a4];
  int v10 = (void *)[objc_alloc(MEMORY[0x1E4F1E5F0]) initWithLatitude:a1 longitude:a4];
  long long v11 = (void *)[objc_alloc(MEMORY[0x1E4F1E5F0]) initWithLatitude:a3 longitude:a2];
  [v8 distanceFromLocation:v10];
  double v13 = v12;
  [v9 distanceFromLocation:v10];
  double v15 = v14;
  [v8 distanceFromLocation:v11];
  double v17 = v16;
  [v9 distanceFromLocation:v11];
  if (v13 >= v15) {
    double v19 = v13;
  }
  else {
    double v19 = v15;
  }
  if (v17 >= v18) {
    double v18 = v17;
  }
  if (v19 >= v18) {
    double v20 = v19;
  }
  else {
    double v20 = v18;
  }

  return v20;
}

void sub_1B88EED30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double ARLInfinityAngularDistance(double a1, double a2, double a3, double a4)
{
  double v4 = vabdd_f64(a4, a2);
  if (v4 > 180.0) {
    double v4 = 360.0 - v4;
  }
  double result = vabdd_f64(a3, a1);
  if (v4 >= result) {
    return v4;
  }
  return result;
}

__n128 cnmatrix::CNMatrixBase<double>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    unsigned int v2 = *(_DWORD *)(a2 + 8);
    if (*(_DWORD *)(a1 + 24) < v2) {
      cnmatrix::CNMatrixBase<double>::operator=();
    }
    unsigned int v3 = *(_DWORD *)(a2 + 12);
    if (*(_DWORD *)(a1 + 28) < v3) {
      cnmatrix::CNMatrixBase<double>::operator=();
    }
    *(_DWORD *)(a1 + 8) = v2;
    *(_DWORD *)(a1 + 12) = v3;
    uint64_t v4 = v3 * v2;
    *(_DWORD *)(a1 + 16) = v4;
    *(_DWORD *)(a1 + 20) = v2;
    int v5 = *(_DWORD *)(a2 + 16);
    if (v5 > 3)
    {
      int v10 = *(_OWORD **)(a1 + 32);
      long long v11 = *(long long **)(a2 + 32);
      double v12 = (__n128 *)((char *)v10 + 8 * (v5 - 2));
      double v13 = (__n128 *)((char *)v11 + 8 * (v5 - 2));
      uint64_t v14 = (v5 - 1) >> 1;
      do
      {
        long long v15 = *v11++;
        *v10++ = v15;
        --v14;
      }
      while (v14);
      __n128 result = *v13;
      *double v12 = *v13;
    }
    else if ((int)v4 >= 1)
    {
      unint64_t v6 = *(unint64_t **)(a2 + 32);
      int v7 = *(unint64_t **)(a1 + 32);
      do
      {
        unint64_t v8 = *v6++;
        result.n128_u64[0] = v8;
        *v7++ = v8;
        --v4;
      }
      while (v4);
    }
  }
  return result;
}

void cnmatrix::CNMatrix<3u,3u,double>::~CNMatrix(void *a1)
{
  *a1 = &unk_1F12098C8;
  JUMPOUT(0x1BA9C56C0);
}

uint64_t cnmatrix::CNMatrix<3u,3u,double>::AllocateAndBindMemoryBacking(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void cnmatrix::CNMatrix<3u,3u,double>::TransposeDataFootprint(uint64_t a1)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  cnmatrix::CNMatrix<3u,3u,double>::TransposeDataFootprint(a1, v1);
}

void cnmatrix::CNMatrix<3u,3u,double>::TransposeDataFootprint(uint64_t a1, char *a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (v2 >= 2)
  {
    unsigned int v4 = *(_DWORD *)(a1 + 12);
    if (v4 >= 2)
    {
      if (!a2) {
        cnmatrix::CNMatrix<3u,3u,double>::TransposeDataFootprint();
      }
      int v6 = v4 + v2 - *(_DWORD *)(a1 + 20);
      if (v6 <= 0) {
        cnmatrix::CNMatrix<3u,3u,double>::TransposeDataFootprint();
      }
      bzero(a2, *(unsigned int *)(a1 + 16));
      int v7 = *(_DWORD *)(a1 + 16);
      if (v7 >= 3)
      {
        uint64_t v8 = (v7 - 1);
        uint64_t v9 = *(void *)(a1 + 32);
        uint64_t v10 = 1;
        do
        {
          long long v11 = &a2[v10];
          if (!a2[v10])
          {
            uint64_t v12 = *(void *)(v9 + 8 * v10);
            int v13 = v10;
            do
            {
              int v13 = v13 * v6 % (int)v8;
              uint64_t v14 = *(void *)(v9 + 8 * v13);
              *(void *)(v9 + 8 * v13) = v12;
              *long long v11 = 1;
              long long v11 = &a2[v13];
              uint64_t v12 = v14;
            }
            while (!*v11);
          }
          ++v10;
        }
        while (v10 != v8);
      }
    }
  }
}

uint64_t cnmatrix::CNMatrixBase<double>::operator()(uint64_t a1, int a2, int a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (!v3) {
    cnmatrix::CNMatrixBase<double>::operator()();
  }
  unsigned int v4 = a2 + *(_DWORD *)(a1 + 20) * a3;
  if ((v4 & 0x80000000) != 0) {
    cnmatrix::CNMatrixBase<double>::operator()();
  }
  if ((signed int)v4 >= *(_DWORD *)(a1 + 16)) {
    cnmatrix::CNMatrixBase<double>::operator()();
  }
  return v3 + 8 * v4;
}

id _ARLogSensor_1()
{
  if (_ARLogSensor_onceToken_3 != -1) {
    dispatch_once(&_ARLogSensor_onceToken_3, &__block_literal_global_241);
  }
  uint64_t v0 = (void *)_ARLogSensor_logObj_3;
  return v0;
}

void sub_1B88EFA58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  os_unfair_lock_unlock(v7);
  _Unwind_Resume(a1);
}

void sub_1B88F0B28(_Unwind_Exception *exception_object)
{
}

void sub_1B88F16E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B88F1948(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B88F1DA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, os_unfair_lock_t lock)
{
}

void *ARC3DShapeTriangulationListCreate@<X0>(void *a1@<X8>)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0x400000000;
  a1[1] = malloc_type_malloc(0x20uLL, 0x2004093837F09uLL);
  __n128 result = malloc_type_malloc(0x20uLL, 0x2004093837F09uLL);
  a1[2] = result;
  return result;
}

void ARC3DShapeTriangulationListDestroy(uint64_t a1)
{
  free(*(void **)(a1 + 8));
  unsigned int v2 = *(void **)(a1 + 16);
  free(v2);
}

void **ARC3DShapeTriangulationListInsert(void **result, uint64_t a2, uint64_t a3)
{
  int v5 = result;
  unsigned int v6 = *(_DWORD *)result;
  if (*(_DWORD *)result == *((_DWORD *)result + 1))
  {
    unsigned int v7 = 2 * v6;
    *((_DWORD *)result + 1) = v7;
    result[1] = malloc_type_realloc(result[1], 8 * v7, 0x2004093837F09uLL);
    __n128 result = (void **)malloc_type_realloc(v5[2], 8 * *((unsigned int *)v5 + 1), 0x2004093837F09uLL);
    v5[2] = result;
    unsigned int v6 = *(_DWORD *)v5;
  }
  *((void *)v5[1] + v6) = a2;
  *((void *)v5[2] + v6) = a3;
  *(_DWORD *)int v5 = v6 + 1;
  return result;
}

uint64_t ARC3DShapeTriangulationStackCreate()
{
  return 0x1000000000;
}

void ARC3DShapeTriangulationStackDestroy(int a1, void *a2)
{
}

void *ARC3DShapeTriangulationStackPush(int *a1, uint64_t a2)
{
  int v4 = *a1;
  int v5 = a1[1];
  if (v5 == *a1)
  {
    a1[1] = 2 * v5;
    __n128 result = malloc_type_realloc(*((void **)a1 + 1), 8 * (2 * v5), 0x2004093837F09uLL);
    *((void *)a1 + 1) = result;
    int v4 = *a1;
  }
  else
  {
    __n128 result = (void *)*((void *)a1 + 1);
  }
  *a1 = v4 + 1;
  result[v4] = a2;
  return result;
}

uint64_t ARC3DShapeTriangulationStackPop(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  unsigned int v2 = *(_DWORD *)a1 - 1;
  *(_DWORD *)a1 = v2;
  return *(void *)(v1 + 8 * v2);
}

void *ARC3DNeighborSharingVertex(void *result, uint64_t a2)
{
  if (*result == a2)
  {
    unsigned int v2 = result + 3;
    return (void *)*v2;
  }
  if (result[1] == a2)
  {
    unsigned int v2 = result + 4;
    return (void *)*v2;
  }
  if (result[2] == a2)
  {
    unsigned int v2 = result + 5;
    return (void *)*v2;
  }
  return result;
}

uint64_t ARC3DNeighborSharingVertices(void *a1, uint64_t a2, uint64_t a3)
{
  if (*a1 == a2 || *a1 == a3)
  {
    uint64_t v4 = a1[1];
    BOOL v5 = v4 == a2 || v4 == a3;
    unsigned int v6 = a1 + 3;
    if (!v5) {
      unsigned int v6 = a1 + 5;
    }
  }
  else
  {
    unsigned int v6 = a1 + 4;
  }
  return *v6;
}

uint64_t ARC3DShapeTriangulationTriangleCrossesSegment(double **a1, double a2, double a3, double a4, double a5)
{
  int v10 = ARC3DSegmentIntersectsSegment(a2, a3, a4, a5, **a1, (*a1)[1], *a1[1], a1[1][1]);
  int v11 = ARC3DSegmentIntersectsSegment(a2, a3, a4, a5, *a1[1], a1[1][1], *a1[2], a1[2][1]);
  return v10 | v11 | ARC3DSegmentIntersectsSegment(a2, a3, a4, a5, *a1[2], a1[2][1], **a1, (*a1)[1]);
}

uint64_t ARC3DShapeTriangulationCheckConsistency(uint64_t result)
{
  uint64_t v1 = *(unsigned int *)(result + 32);
  if (v1)
  {
    uint64_t v2 = 0;
    uint64_t v3 = *(void *)(result + 16);
    do
    {
      uint64_t v4 = 0;
      uint64_t v5 = v3 + 56 * v2;
      do
      {
        uint64_t v6 = v4 + 1;
        if (v4 == 2) {
          uint64_t v7 = 0;
        }
        else {
          uint64_t v7 = (v4 + 1);
        }
        uint64_t v8 = *(void *)(v3 + 56 * v2 + 8 * v4 + 24);
        if (v8 == v5) {
          ARC3DShapeTriangulationCheckConsistency_cold_1();
        }
        if (v8 == 1) {
          ARC3DShapeTriangulationCheckConsistency_cold_2();
        }
        uint64_t v9 = 0;
        __n128 result = 0;
        int v10 = 0;
        uint64_t v11 = *(void *)(v5 + 8 * v7);
        uint64_t v12 = v3;
        uint64_t v13 = 0xFFFFFFFFLL;
        do
        {
          for (uint64_t i = 0; i != 3; ++i)
          {
            if (i == 2) {
              uint64_t v15 = 0;
            }
            else {
              uint64_t v15 = i + 1;
            }
            if (*(void *)(v5 + 8 * v4) == *(void *)(v3 + 56 * v9 + 8 * v15) && v11 == *(void *)(v12 + 8 * i))
            {
              uint64_t v13 = i;
              ++v10;
              __n128 result = v3 + 56 * v9;
            }
          }
          ++v9;
          v12 += 56;
        }
        while (v9 != v1);
        if (result != v8) {
          ARC3DShapeTriangulationCheckConsistency_cold_8();
        }
        if (v8)
        {
          if (v10 != 1) {
            ARC3DShapeTriangulationCheckConsistency_cold_7();
          }
          if (*(void *)(v8 + 8 * v13 + 24) != v5) {
            ARC3DShapeTriangulationCheckConsistency_cold_6();
          }
          if (*(unsigned __int8 *)(v8 + v13 + 48) != *(unsigned __int8 *)(v3 + 56 * v2 + v4 + 48)) {
            ARC3DShapeTriangulationCheckConsistency_cold_5();
          }
        }
        else
        {
          if (v10) {
            ARC3DShapeTriangulationCheckConsistency_cold_4();
          }
          if (*(unsigned char *)(v3 + 56 * v2 + v4 + 48)) {
            ARC3DShapeTriangulationCheckConsistency_cold_3();
          }
        }
        ++v4;
      }
      while (v6 != 3);
      ++v2;
    }
    while (v2 != v1);
  }
  return result;
}

double ARC3DShapeTriangulationTriangleArea(double a1, double a2, double a3, double a4, double a5, double a6)
{
  return fabs(a3 * a6 + a1 * a4 + a5 * a2 - a1 * a6 - a5 * a4 - a3 * a2) * 0.5;
}

uint64_t ARC3DShapeTriangulationGetNewTriangle(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  unsigned int v2 = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 32) = v2 + 1;
  uint64_t result = v1 + 56 * v2;
  *(unsigned char *)(result + 51) = 0;
  return result;
}

uint64_t ARC3DShapeTriangulationTriangleContainingVertex(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 32);
  unsigned int v3 = v2 - 1;
  if (v2 - 1 < 0) {
    return 2;
  }
  uint64_t v4 = *(void *)(a2 + 16);
  for (uint64_t i = (void *)(v4 + 56 * v3); ; i -= 7)
  {
    if (v4)
    {
      uint64_t v6 = v4 + 56 * v3;
      if (*i == a1 || i[1] == a1) {
        return v6;
      }
      if (i[2] == a1) {
        break;
      }
    }
    --v3;
    if (--v2 <= 0) {
      return 2;
    }
  }
  return (uint64_t)i;
}

uint64_t ARC3DShapeTriangulationTriangleContainingPoint(float64x2_t *a1, unint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)(a3 + 32);
  int v4 = *(_DWORD *)(a3 + 32);
  while (v4)
  {
    uint64_t v5 = 0;
    char v6 = 0;
    --v4;
    float64x2_t v7 = *a1;
    do
    {
      if (v5 == 2) {
        uint64_t v8 = 0;
      }
      else {
        uint64_t v8 = v5 + 1;
      }
      int8x16_t v9 = (int8x16_t)vsubq_f64(*(float64x2_t *)*(void *)(a2 + 8 * v5), v7);
      float64x2_t v10 = vmulq_f64(vsubq_f64(*(float64x2_t *)*(void *)(a2 + 8 * v8), v7), (float64x2_t)vextq_s8(v9, v9, 8uLL));
      if (vmovn_s64(vcgtq_f64(v10, (float64x2_t)vdupq_laneq_s64((int64x2_t)v10, 1))).u8[0])
      {
        a2 = *(void *)(a2 + 8 * v5 + 24);
        if (a2 < 3) {
          return 2;
        }
        char v6 = 1;
      }
      ++v5;
    }
    while (v5 != 3);
    if ((v6 & 1) == 0) {
      return a2;
    }
  }
  if (!v3) {
    return 2;
  }
  uint64_t v11 = *(double ***)(a3 + 16);
  a2 = 2;
  while (1)
  {
    uint64_t v15 = v11[1];
    double v16 = v11[2];
    double v17 = **v11;
    double v18 = (*v11)[1];
    double v19 = v15[1];
    double v20 = v16[1];
    double v12 = a1->f64[0];
    double v13 = a1->f64[1];
    float64_t v14 = -a1->f64[0];
    if (vabdd_f64(fabs(*v15 * v20 + v17 * v19 + *v16 * v18 - v17 * v20 - *v16 * v19 - *v15 * v18) * 0.5- fabs(v18 * *v16 + v12 * v20 + v17 * v13 + v14 * v18 - v17 * v20 - *v16 * v13) * 0.5- fabs(*v15 * v20 + v12 * v19 + *v16 * v13 + v14 * v20 - *v16 * v19 - *v15 * v13) * 0.5, fabs(v17 * v19 + v12 * v18 + *v15 * v13 + v14 * v19 - *v15 * v18 - v17 * v13) * 0.5) < 0.001)break; {
    v11 += 7;
    }
    if (!--v3) {
      return a2;
    }
  }
  return (uint64_t)v11;
}

uint64_t ARC3DEdgeCrossingSegment(uint64_t a1, double *a2, double *a3, double ***a4)
{
  uint64_t v8 = *(double **)a1;
  if (*(double **)a1 == a3 || (int8x16_t v9 = *(double **)(a1 + 8), v9 == a3) || *(double **)(a1 + 16) == a3)
  {
    double v12 = *(double ***)(a1 + 24);
    if (v12 && (*v12 == a2 || v12[1] == a2 || v12[2] == a2) && (*v12 == a3 || v12[1] == a3 || v12[2] == a3)) {
      goto LABEL_41;
    }
    double v12 = *(double ***)(a1 + 32);
    if (v12 && (*v12 == a2 || v12[1] == a2 || v12[2] == a2) && (*v12 == a3 || v12[1] == a3 || v12[2] == a3)) {
      goto LABEL_41;
    }
    double v12 = *(double ***)(a1 + 40);
    if (v12 && (*v12 == a2 || v12[1] == a2 || v12[2] == a2) && (*v12 == a3 || v12[1] == a3 || v12[2] == a3)) {
      goto LABEL_41;
    }
  }
  else
  {
    BOOL v10 = v8 == a2 || v9 == a2;
    if (!v10 && ARC3DSegmentIntersectsSegment(*a2, a2[1], *a3, a3[1], *v8, v8[1], *v9, v9[1]))
    {
      uint64_t v11 = (double ***)(a1 + 24);
LABEL_40:
      double v12 = *v11;
LABEL_41:
      *a4 = v12;
      return 1;
    }
    double v13 = *(double **)(a1 + 8);
    if (v13 != a2)
    {
      float64_t v14 = *(double **)(a1 + 16);
      if (v14 != a2)
      {
        if (ARC3DSegmentIntersectsSegment(*a2, a2[1], *a3, a3[1], *v13, v13[1], *v14, v14[1]))
        {
          uint64_t v11 = (double ***)(a1 + 32);
          goto LABEL_40;
        }
      }
    }
    uint64_t v15 = *(double **)(a1 + 16);
    if (v15 != a2 && *(double **)a1 != a2)
    {
      uint64_t result = ARC3DSegmentIntersectsSegment(*a2, a2[1], *a3, a3[1], *v15, v15[1], **(double **)a1, *(double *)(*(void *)a1 + 8));
      if (!result) {
        return result;
      }
      uint64_t v11 = (double ***)(a1 + 40);
      goto LABEL_40;
    }
  }
  return 0;
}

uint64_t ARC3DLinkFromTriangleToTriangle(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = 0;
  uint64_t v4 = a1 + 24;
  uint64_t result = 3;
  while (*(void *)(v4 + v3) != a2)
  {
    v3 += 8;
    if (v3 == 24) {
      return result;
    }
  }
  return a1 + v3 + 24;
}

uint64_t ARC3DLinkIndexFromTriangleToTriangle(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0;
  uint64_t v4 = a1 + 24;
  while (*(void *)(v4 + 8 * result) != a2)
  {
    if (++result == 3) {
      ARC3DLinkIndexFromTriangleToTriangle_cold_1();
    }
  }
  return result;
}

uint64_t ARC3DLinkIndicesFromTriangleToTriangle(uint64_t result, uint64_t a2, _DWORD *a3, _DWORD *a4, int *a5)
{
  uint64_t v5 = 0;
  while (*(void *)(result + 24 + 8 * v5) != a2)
  {
    if (++v5 == 3)
    {
      *a5 = -1;
      *a4 = -1;
      *a3 = -1;
      return result;
    }
  }
  *a3 = v5;
  if (v5 > 1) {
    int v6 = -2;
  }
  else {
    int v6 = 1;
  }
  *a4 = v6 + v5;
  if (v5) {
    int v7 = v5 - 1;
  }
  else {
    int v7 = 2;
  }
  *a5 = v7;
  return result;
}

uint64_t ARC3DLinkFromTriangleWithEdge(void *a1, uint64_t a2, uint64_t a3)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = a1[1];
  if (*a1 == a2 && v3 == a3) {
    return 0;
  }
  uint64_t v5 = a1[2];
  if (v5 == a2 && *a1 == a3) {
    unsigned int v7 = 2;
  }
  else {
    unsigned int v7 = -1;
  }
  if (v3 == a2 && v5 == a3) {
    return 1;
  }
  else {
    return v7;
  }
}

BOOL ARC3DCircumcircleContainsPoint_BROKEN(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  double v8 = a1 - a5;
  double v9 = a2 - a6;
  double v10 = a3 - a5;
  double v11 = a4 - a6;
  double v12 = a1 - a7;
  double v13 = a2 - a8;
  double v14 = a3 - a7;
  double v15 = a4 - a8;
  double v16 = v9 * v11 + v8 * v10;
  double v17 = v15 * v13 + v14 * v12;
  if (v16 >= 0.0 && v17 >= 0.0) {
    return 0;
  }
  if (v16 >= 0.0 || v17 >= 0.0) {
    return v16 * (v14 * v13 - v12 * v15) + (v8 * v11 - v10 * v9) * v17 < 0.0;
  }
  return 1;
}

BOOL ARC3DCircumcircleContainsPoint(double *a1, double *a2, double *a3, double *a4)
{
  double v4 = a1[1];
  double v5 = a2[1];
  double v6 = a3[1];
  double v7 = v4 * v4 + *a1 * *a1;
  double v8 = v5 * v5 + *a2 * *a2;
  double v9 = v6 * v6 + *a3 * *a3;
  double v10 = v5 - v6;
  double v11 = *a2 * (v6 - v4) + *a1 * (v5 - v6);
  double v12 = v4 - v5;
  double v13 = v11 + *a3 * v12 + v11 + *a3 * v12;
  double v14 = (v8 * (v6 - v4) + v7 * v10 + v9 * v12) / v13;
  double v15 = *a2 - *a3;
  double v16 = *a1 - *a2;
  double v17 = -(v8 * (*a3 - *a1) + v7 * v15 + v9 * v16) / v13;
  double v18 = sqrt(((v4 - v6) * (v4 - v6) + (*a1 - *a3) * (*a1 - *a3)) * ((v12 * v12 + v16 * v16) * (v10 * v10 + v15 * v15)));
  double v19 = fabs(v13);
  return (v17 - a4[1]) * (v17 - a4[1]) + (v14 - *a4) * (v14 - *a4) < v18 / v19 * (v18 / v19);
}

BOOL ARC3DPointFallsOnTriangleEdge(void *a1, double *a2)
{
  uint64_t v3 = (double *)a1[1];
  double v4 = *a2;
  double v5 = a2[1];
  double v6 = *v3;
  double v7 = v3[1];
  double v8 = *(double *)*a1 - *a2;
  double v9 = *(double *)(*a1 + 8) - v5;
  double v10 = v9 * v9 + v8 * v8;
  if (v10 <= 0.0)
  {
    double v11 = -v10;
    long double v12 = hypot(v8, v9);
    if (v12 * v12 == v11) {
      return 1;
    }
  }
  double v13 = (double *)a1[2];
  double v14 = *v13;
  double v15 = v13[1];
  double v16 = v6 - v4;
  double v17 = v7 - v5;
  double v18 = v17 * v17 + v16 * v16;
  if (v18 <= 0.0)
  {
    double v19 = -v18;
    long double v20 = hypot(v16, v17);
    if (v20 * v20 == v19) {
      return 1;
    }
  }
  double v22 = v14 - v4;
  double v23 = v15 - v5;
  double v24 = v23 * v23 + v22 * v22;
  if (v24 > 0.0) {
    return 0;
  }
  double v25 = -v24;
  long double v26 = hypot(v22, v23);
  return v26 * v26 == v25;
}

uint64_t ARC3DPointFallsOnTriangleEdgeAndLinks(uint64_t a1, double *a2, _DWORD *a3, _DWORD *a4)
{
  double v4 = *(double **)(a1 + 8);
  double v5 = **(double **)a1;
  double v6 = *(double *)(*(void *)a1 + 8);
  double v7 = v4[1];
  double v8 = *a2;
  double v9 = a2[1];
  if ((*v4 - v5) * (v9 - v6) - (v7 - v6) * (*a2 - v5) == 0.0)
  {
    uint64_t v10 = 0;
    *a3 = 0;
    while (*(void *)(*(void *)(a1 + 24) + 24 + 8 * v10) != a1)
    {
      if (++v10 == 3) {
        ARC3DLinkIndexFromTriangleToTriangle_cold_1();
      }
    }
  }
  else
  {
    double v11 = *(double **)(a1 + 16);
    double v12 = v11[1];
    if ((*v11 - *v4) * (v9 - v7) - (v12 - v7) * (v8 - *v4) == 0.0)
    {
      uint64_t v10 = 0;
      *a3 = 1;
      while (*(void *)(*(void *)(a1 + 32) + 24 + 8 * v10) != a1)
      {
        if (++v10 == 3) {
          ARC3DLinkIndexFromTriangleToTriangle_cold_1();
        }
      }
    }
    else
    {
      if ((v5 - *v11) * (v9 - v12) - (v6 - v12) * (v8 - *v11) != 0.0) {
        return 0;
      }
      uint64_t v10 = 0;
      *a3 = 2;
      while (*(void *)(*(void *)(a1 + 40) + 24 + 8 * v10) != a1)
      {
        if (++v10 == 3) {
          ARC3DLinkIndexFromTriangleToTriangle_cold_1();
        }
      }
    }
  }
  *a4 = v10;
  return 1;
}

uint64_t ARC3DVertexNotSharedByTriangles(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    ARC3DVertexNotSharedByTriangles_cold_1();
  }
  if (!a2) {
    ARC3DVertexNotSharedByTriangles_cold_2();
  }
  int v2 = (void *)(a1 + 24);
  int v3 = 1;
  while (*v2 != a2)
  {
    --v3;
    ++v2;
    if (v3 == -2) {
      return 0;
    }
  }
  if (v3 == 1) {
    unsigned int v5 = 2;
  }
  else {
    unsigned int v5 = -v3;
  }
  return *(void *)(a1 + 8 * v5);
}

uint64_t ARC3DShapeConnectedComponentTriangulatePseudopolygon(int *a1, double *a2, double *a3, unsigned int *a4, int a5)
{
  unsigned int v5 = *a1;
  uint64_t v6 = (*a1 - 1);
  if (*a1 <= 1) {
    ARC3DShapeConnectedComponentTriangulatePseudopolygon_cold_1();
  }
  uint64_t v10 = (double **)*((void *)a1 + 1);
  double v11 = *v10;
  if (v6 <= 1)
  {
    int v12 = 0;
    double v16 = (unint64_t **)(a1 + 4);
    double v17 = (unint64_t *)*((void *)a1 + 2);
    unint64_t v18 = *v17;
    unsigned int v19 = *a4;
  }
  else
  {
    unsigned int v119 = *a1;
    v120 = a4;
    int v121 = a5;
    int v12 = 0;
    uint64_t v13 = 1;
    double v14 = *v10;
    do
    {
      double v15 = v10[v13];
      if (ARC3DCircumcircleContainsPoint(a2, a3, v14, v15))
      {
        int v12 = v13;
        double v14 = v15;
      }
      ++v13;
    }
    while (v6 != v13);
    double v16 = (unint64_t **)(a1 + 4);
    double v17 = (unint64_t *)*((void *)a1 + 2);
    unint64_t v18 = *v17;
    a4 = v120;
    unsigned int v19 = *v120;
    if (v12 >= 1)
    {
      uint64_t v20 = 1;
      a5 = v121;
      while (1)
      {
        unint64_t v21 = *(void *)(*((void *)v120 + 1) + 8 * --v19);
        if (v121)
        {
          double v22 = v10[v20];
          *(void *)unint64_t v21 = v22;
          unint64_t v23 = 1;
        }
        else
        {
          *(void *)unint64_t v21 = v11;
          double v22 = v11;
          double v11 = *(double **)(*((void *)a1 + 1) + v20 * 8);
          unint64_t v23 = v18;
          unint64_t v18 = 1;
        }
        *(void *)(v21 + 8) = v11;
        *(void *)(v21 + 16) = a2;
        double v24 = (double **)(*v16)[v20];
        *(void *)(v21 + 24) = v24;
        *(void *)(v21 + 32) = v18;
        *(void *)(v21 + 40) = v23;
        if (v121)
        {
          if (v18)
          {
            double v25 = *(double **)v18;
            long double v26 = *(double **)(v18 + 8);
            if (*(double **)v18 == a2 && v26 == v11)
            {
              unsigned int v27 = 0;
            }
            else
            {
              uint64_t v30 = *(double **)(v18 + 16);
              if (v26 == a2 && v30 == v11)
              {
                unsigned int v27 = 1;
              }
              else if (v30 == a2 && v25 == v11)
              {
                unsigned int v27 = 2;
              }
              else
              {
                unsigned int v27 = -1;
              }
            }
          }
          else
          {
            unsigned int v27 = -1;
          }
          if (!v24) {
            goto LABEL_204;
          }
          CFNumberRef v33 = v24[1];
          if (*v24 == v11 && v33 == v22)
          {
            unsigned int v39 = 0;
          }
          else
          {
            int v35 = v24[2];
            BOOL v36 = v35 == v11 && *v24 == v22;
            int v37 = v36 ? 2 : -1;
            BOOL v38 = v33 == v11 && v35 == v22;
            unsigned int v39 = v38 ? 1 : v37;
          }
          if (v27 == -1 || v39 == -1) {
            goto LABEL_204;
          }
          v24[v39 + 3] = (double *)v21;
          *(void *)(*(void *)(v21 + 32) + 8 * v27 + 24) = v21;
          uint64_t v40 = *(void *)(v21 + 24);
          *(unsigned char *)(v21 + 49) = *(unsigned char *)(*(void *)(v21 + 32) + v27 + 48);
          *(unsigned char *)(v21 + 48) = *(unsigned char *)(v40 + v39 + 48);
          *(unsigned char *)(v21 + 50) = 0;
        }
        else
        {
          if (v23)
          {
            uint64_t v28 = *(double **)(v23 + 8);
            if (*(double **)v23 == v22 && v28 == a2)
            {
              unsigned int v29 = 0;
            }
            else
            {
              uint64_t v31 = *(double **)(v23 + 16);
              if (v28 == v22 && v31 == a2)
              {
                unsigned int v29 = 1;
              }
              else if (v31 == v22 && *(void *)v23 == (void)a2)
              {
                unsigned int v29 = 2;
              }
              else
              {
                unsigned int v29 = -1;
              }
            }
          }
          else
          {
            unsigned int v29 = -1;
          }
          if (!v24
            || ((long long v42 = v24[1], *v24 == v11) ? (v43 = v42 == v22) : (v43 = 0),
                v43
              ? (unsigned int v48 = 0)
              : ((int v44 = v24[2], v44 == v11) ? (v45 = *v24 == v22) : (v45 = 0),
                 !v45 ? (int v46 = -1) : (int v46 = 2),
                 v42 == v11 ? (BOOL v47 = v44 == v22) : (BOOL v47 = 0),
                 !v47 ? (unsigned int v48 = v46) : (unsigned int v48 = 1)),
                v29 == -1 || v48 == -1))
          {
LABEL_204:
            *a4 = v19;
            return 2;
          }
          if (v23 >= 2)
          {
            *(void *)(v23 + 8 * v29 + 24) = v21;
            *(unsigned char *)(v21 + 50) = *(unsigned char *)(*(void *)(v21 + 40) + v29 + 48);
            double v24 = *(double ***)(v21 + 24);
          }
          if ((unint64_t)v24 >= 2)
          {
            v24[v48 + 3] = (double *)v21;
            *(unsigned char *)(v21 + 48) = *(unsigned char *)(*(void *)(v21 + 24) + v48 + 48);
          }
          *(unsigned char *)(v21 + 49) = 0;
        }
        uint64_t v10 = (double **)*((void *)a1 + 1);
        double v11 = v10[v20++];
        unint64_t v18 = v21;
        if (v12 + 1 == v20)
        {
          unsigned int *v120 = v19;
          double v17 = *v16;
          double v11 = v14;
          unint64_t v18 = v21;
          goto LABEL_91;
        }
      }
    }
    double v11 = v14;
    a5 = v121;
LABEL_91:
    unsigned int v5 = v119;
  }
  uint64_t v49 = v17[v6];
  if ((int)(v5 - 3) >= v12)
  {
    long long v51 = &v10[v5 - 2];
    uint64_t v52 = (int)(v5 - 3);
    while (1)
    {
      float v53 = *v51;
      unint64_t v50 = *(void *)(*((void *)a4 + 1) + 8 * --v19);
      *(void *)unint64_t v50 = a3;
      if (a5)
      {
        *(void *)(v50 + 8) = v53;
        float v54 = v53;
        float v53 = *(double **)(*((void *)a1 + 1) + 8 * v52);
        unint64_t v55 = 1;
      }
      else
      {
        float v54 = *(double **)(*((void *)a1 + 1) + 8 * v52);
        *(void *)(v50 + 8) = v54;
        unint64_t v55 = v49;
        uint64_t v49 = 1;
      }
      *(void *)(v50 + 16) = v53;
      *(void *)(v50 + 24) = v49;
      uint64_t v56 = (double **)(*v16)[v52 + 1];
      *(void *)(v50 + 32) = v56;
      *(void *)(v50 + 40) = v55;
      if (a5)
      {
        if (v49)
        {
          double v58 = *(double **)v49;
          __int16 v57 = *(double **)(v49 + 8);
          if (*(double **)v49 == v54 && v57 == a3)
          {
            unsigned int v64 = 0;
            if (!v56) {
              goto LABEL_204;
            }
          }
          else
          {
            uint64_t v60 = *(double **)(v49 + 16);
            if (v60 == v54 && v58 == a3) {
              int v62 = 2;
            }
            else {
              int v62 = -1;
            }
            if (v57 == v54 && v60 == a3) {
              unsigned int v64 = 1;
            }
            else {
              unsigned int v64 = v62;
            }
            if (!v56) {
              goto LABEL_204;
            }
          }
        }
        else
        {
          unsigned int v64 = -1;
          if (!v56) {
            goto LABEL_204;
          }
        }
        uint64_t v67 = v56[1];
        if (*v56 == v53 && v67 == v54)
        {
          unsigned int v73 = 0;
        }
        else
        {
          uint64_t v69 = v56[2];
          if (v69 == v53 && *v56 == v54) {
            int v71 = 2;
          }
          else {
            int v71 = -1;
          }
          if (v67 == v53 && v69 == v54) {
            unsigned int v73 = 1;
          }
          else {
            unsigned int v73 = v71;
          }
        }
        if (v64 == -1 || v73 == -1) {
          goto LABEL_204;
        }
        v56[v73 + 3] = (double *)v50;
        *(void *)(*(void *)(v50 + 24) + 8 * v64 + 24) = v50;
        uint64_t v74 = *(void *)(v50 + 32);
        *(unsigned char *)(v50 + 48) = *(unsigned char *)(*(void *)(v50 + 24) + v64 + 48);
        *(_WORD *)(v50 + 49) = *(unsigned __int8 *)(v74 + v73 + 48);
      }
      else
      {
        if (v55)
        {
          char v65 = *(double **)(v55 + 8);
          if (*(double **)v55 == a3 && v65 == v53)
          {
            unsigned int v66 = 0;
          }
          else
          {
            v75 = *(double **)(v55 + 16);
            if (v65 == a3 && v75 == v53)
            {
              unsigned int v66 = 1;
            }
            else if (v75 == a3 && *(void *)v55 == (void)v53)
            {
              unsigned int v66 = 2;
            }
            else
            {
              unsigned int v66 = -1;
            }
          }
        }
        else
        {
          unsigned int v66 = -1;
        }
        if (!v56) {
          goto LABEL_204;
        }
        id v77 = v56[1];
        if (*v56 == v53 && v77 == v54)
        {
          unsigned int v83 = 0;
        }
        else
        {
          v79 = v56[2];
          BOOL v80 = v79 == v53 && *v56 == v54;
          int v81 = v80 ? 2 : -1;
          BOOL v82 = v77 == v53 && v79 == v54;
          unsigned int v83 = v82 ? 1 : v81;
        }
        if (v66 == -1 || v83 == -1) {
          goto LABEL_204;
        }
        if (v55 < 2)
        {
          char v84 = 0;
        }
        else
        {
          *(void *)(v55 + 8 * v66 + 24) = v50;
          uint64_t v56 = *(double ***)(v50 + 32);
          char v84 = *(unsigned char *)(*(void *)(v50 + 40) + v66 + 48);
        }
        *(unsigned char *)(v50 + 50) = v84;
        if ((unint64_t)v56 < 2)
        {
          char v85 = 0;
        }
        else
        {
          v56[v83 + 3] = (double *)v50;
          char v85 = *(unsigned char *)(*(void *)(v50 + 32) + v83 + 48);
        }
        *(unsigned char *)(v50 + 49) = v85;
        *(unsigned char *)(v50 + 48) = 0;
      }
      long long v51 = (double **)(*((void *)a1 + 1) + 8 * v52);
      uint64_t v49 = v50;
      if (v52-- <= v12) {
        goto LABEL_184;
      }
    }
  }
  unint64_t v50 = v17[v6];
LABEL_184:
  uint64_t v87 = *((void *)a4 + 1);
  unsigned int v88 = v19 - 1;
  *a4 = v88;
  uint64_t v89 = *(void *)(v87 + 8 * v88);
  *(void *)uint64_t v89 = a2;
  if (a5)
  {
    *(void *)(v89 + 8) = a3;
    *(void *)(v89 + 16) = v11;
    if (v18)
    {
      float32x4_t v90 = *(double **)(v18 + 8);
      if (*(double **)v18 != a2 || v90 != v11)
      {
        v92 = *(double **)(v18 + 16);
        if (v92 == a2 && *(void *)v18 == (void)v11) {
          int v94 = 2;
        }
        else {
          int v94 = -1;
        }
        if (v90 == a2 && v92 == v11) {
          unsigned int v96 = 1;
        }
        else {
          unsigned int v96 = v94;
        }
        if (!v50) {
          return 2;
        }
LABEL_231:
        float32x4_t v105 = *(double **)(v50 + 8);
        if (*(double **)v50 == v11 && v105 == a3)
        {
          unsigned int v110 = 0;
        }
        else
        {
          v107 = *(double **)(v50 + 16);
          if (v105 == v11 && v107 == a3)
          {
            unsigned int v110 = 1;
          }
          else if (v107 == v11 && *(void *)v50 == (void)a3)
          {
            unsigned int v110 = 2;
          }
          else
          {
            unsigned int v110 = -1;
          }
        }
        uint64_t result = 2;
        if (v96 != -1 && v110 != -1)
        {
          *(void *)(v89 + 24) = 1;
          *(void *)(v89 + 32) = v50;
          *(void *)(v89 + 40) = v18;
          if (v18 < 2)
          {
            char v117 = 0;
          }
          else
          {
            *(void *)(v18 + 8 * v96 + 24) = v89;
            char v117 = *(unsigned char *)(v18 + v96 + 48);
          }
          *(unsigned char *)(v89 + 50) = v117;
          if (v50 < 2)
          {
            char v118 = 0;
          }
          else
          {
            *(void *)(v50 + 8 * v110 + 24) = v89;
            char v118 = *(unsigned char *)(v50 + v110 + 48);
          }
          *(unsigned char *)(v89 + 49) = v118;
          *(unsigned char *)(v89 + 48) = 1;
          return v89;
        }
        return result;
      }
      unsigned int v96 = 0;
      if (v50) {
        goto LABEL_231;
      }
    }
    else
    {
      unsigned int v96 = -1;
      if (v50) {
        goto LABEL_231;
      }
    }
    return 2;
  }
  *(void *)(v89 + 8) = v11;
  *(void *)(v89 + 16) = a3;
  if (v18)
  {
    uint64_t v98 = *(double **)(v18 + 8);
    if (*(double **)v18 == v11 && v98 == a2)
    {
      unsigned int v104 = 0;
      if (!v50) {
        return 2;
      }
    }
    else
    {
      v100 = *(double **)(v18 + 16);
      if (v100 == v11 && *(void *)v18 == (void)a2) {
        int v102 = 2;
      }
      else {
        int v102 = -1;
      }
      if (v98 == v11 && v100 == a2) {
        unsigned int v104 = 1;
      }
      else {
        unsigned int v104 = v102;
      }
      if (!v50) {
        return 2;
      }
    }
  }
  else
  {
    unsigned int v104 = -1;
    if (!v50) {
      return 2;
    }
  }
  uint64_t v111 = *(double **)(v50 + 8);
  if (*(double **)v50 == a3 && v111 == v11)
  {
    unsigned int v116 = 0;
  }
  else
  {
    v113 = *(double **)(v50 + 16);
    if (v111 == a3 && v113 == v11)
    {
      unsigned int v116 = 1;
    }
    else if (v113 == a3 && *(void *)v50 == (void)v11)
    {
      unsigned int v116 = 2;
    }
    else
    {
      unsigned int v116 = -1;
    }
  }
  uint64_t result = 2;
  if (v18 && v104 != -1 && v116 != -1)
  {
    *(void *)(v18 + 8 * v104 + 24) = v89;
    *(void *)(v50 + 8 * v116 + 24) = v89;
    *(void *)(v89 + 24) = v18;
    *(void *)(v89 + 32) = v50;
    *(void *)(v89 + 40) = 1;
    *(unsigned char *)(v89 + 48) = *(unsigned char *)(v18 + v104 + 48);
    *(unsigned char *)(v89 + 49) = *(unsigned char *)(v50 + v116 + 48);
    *(unsigned char *)(v89 + 50) = 1;
    return v89;
  }
  return result;
}

void ARC3DShapeTriangulationAddEdge(uint64_t a1, double *a2, double *a3)
{
  int v3 = a3;
  uint64_t v4 = a1;
  if (*a2 > *a3 || *a2 == *a3 && a2[1] < a3[1])
  {
    unsigned int v5 = a2;
  }
  else
  {
    unsigned int v5 = a3;
    int v3 = a2;
  }
  uint64_t v6 = ARC3DShapeTriangulationTriangleContainingVertex((uint64_t)v3, a1);
  if (v6 == 2)
  {
    int v16 = 6;
    goto LABEL_44;
  }
  uint64_t v7 = v6;
  int v8 = *(_DWORD *)(v4 + 32);
  v70 = 0;
  if ((ARC3DEdgeCrossingSegment(v6, v3, v5, &v70) & 1) == 0)
  {
    while (1)
    {
      if (!--v8)
      {
        int v16 = 2;
        goto LABEL_44;
      }
      if (*(double **)v7 == v3) {
        break;
      }
      if (*(double **)(v7 + 8) == v3)
      {
        double v9 = (uint64_t *)(v7 + 32);
        goto LABEL_15;
      }
      if (*(double **)(v7 + 16) == v3)
      {
        double v9 = (uint64_t *)(v7 + 40);
LABEL_15:
        uint64_t v7 = *v9;
      }
      if (ARC3DEdgeCrossingSegment(v7, v3, v5, &v70)) {
        goto LABEL_17;
      }
    }
    double v9 = (uint64_t *)(v7 + 24);
    goto LABEL_15;
  }
LABEL_17:
  if (!v7 || *(double **)v7 != v5 && *(double **)(v7 + 8) != v5 && *(double **)(v7 + 16) != v5)
  {
    uint64_t v68 = 0x1000000000;
    ptr = malloc_type_malloc(0x80uLL, 0x2004093837F09uLL);
    uint64_t v65 = 0x400000000;
    unsigned int v66 = malloc_type_malloc(0x20uLL, 0x2004093837F09uLL);
    uint64_t v67 = malloc_type_malloc(0x20uLL, 0x2004093837F09uLL);
    uint64_t v62 = 0x400000000;
    id v63 = malloc_type_malloc(0x20uLL, 0x2004093837F09uLL);
    uint64_t v10 = malloc_type_malloc(0x20uLL, 0x2004093837F09uLL);
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    unsigned int v64 = v10;
    do
    {
      double v14 = *(double **)(v7 + v11);
      if (v14 != v3)
      {
        if ((*v5 - *v3) * (v14[1] - v3[1]) - (v5[1] - v3[1]) * (*v14 - *v3) <= 0.0) {
          uint64_t v12 = *(void *)(v7 + v11);
        }
        else {
          uint64_t v13 = *(void *)(v7 + v11);
        }
      }
      v11 += 8;
    }
    while (v11 != 24);
    if (*(void *)v7 == v12)
    {
      unsigned int v19 = (uint64_t *)(v7 + 32);
    }
    else if (*(void *)(v7 + 8) == v12)
    {
      unsigned int v19 = (uint64_t *)(v7 + 40);
    }
    else
    {
      if (*(void *)(v7 + 16) != v12)
      {
        uint64_t v15 = 0;
        goto LABEL_49;
      }
      unsigned int v19 = (uint64_t *)(v7 + 24);
    }
    uint64_t v15 = *v19;
LABEL_49:
    ARC3DShapeTriangulationListInsert((void **)&v65, v13, v15);
    if (*(void *)v7 == v13)
    {
      unint64_t v21 = (uint64_t *)(v7 + 32);
    }
    else if (*(void *)(v7 + 8) == v13)
    {
      unint64_t v21 = (uint64_t *)(v7 + 40);
    }
    else
    {
      if (*(void *)(v7 + 16) != v13)
      {
        uint64_t v20 = 0;
LABEL_57:
        ARC3DShapeTriangulationListInsert((void **)&v62, v12, v20);
        uint64_t v22 = 0;
        unsigned int v61 = v68;
        if ((double *)v13 != v5 && (double *)v12 != v5)
        {
          uint64_t v56 = 0;
          uint64_t v57 = 0;
          uint64_t v55 = v4;
          unsigned int v58 = HIDWORD(v68);
          unint64_t v23 = ptr;
          int v24 = *(_DWORD *)(v4 + 32) - 1;
          double v25 = v3;
          while (1)
          {
            if (!v24)
            {
              int v45 = 3;
              goto LABEL_112;
            }
            long double v26 = *(double **)(v7 + 8);
            if (*(double **)v7 == v25)
            {
              uint64_t v28 = *(double **)(v7 + 16);
              unsigned int v27 = (uint64_t **)(v7 + 32);
            }
            else if (v26 == v25)
            {
              unsigned int v27 = (uint64_t **)(v7 + 40);
              uint64_t v28 = *(double **)v7;
              long double v26 = *(double **)(v7 + 16);
            }
            else
            {
              if (*(double **)(v7 + 16) != v25) {
                goto LABEL_108;
              }
              unsigned int v27 = (uint64_t **)(v7 + 24);
              uint64_t v28 = *(double **)(v7 + 8);
              long double v26 = *(double **)v7;
            }
            unsigned int v29 = *v27;
            if (*v27) {
              BOOL v30 = v26 == 0;
            }
            else {
              BOOL v30 = 1;
            }
            if (v30)
            {
LABEL_108:
              int v45 = 4;
              goto LABEL_112;
            }
            int v60 = v24;
            uint64_t v31 = v23;
            CFNumberRef v32 = (double *)ARC3DVertexNotSharedByTriangles((uint64_t)v29, v7);
            if (!v32)
            {
              int v45 = 1;
LABEL_112:
              uint64_t v4 = v55;
LABEL_129:
              *(_DWORD *)(v4 + 40) = v45;
              goto LABEL_130;
            }
            CFNumberRef v33 = v32;
            double v34 = (*v5 - *v3) * (v32[1] - v3[1]) - (v5[1] - v3[1]) * (*v32 - *v3);
            uint64_t v35 = *v29;
            id v59 = v28;
            if (v34 <= 0.0)
            {
              if (v35 == v13)
              {
                unsigned int v39 = v29 + 4;
              }
              else if (v29[1] == v13)
              {
                unsigned int v39 = v29 + 5;
              }
              else
              {
                if (v29[2] != v13)
                {
                  uint64_t v37 = 0;
LABEL_90:
                  ARC3DShapeTriangulationListInsert((void **)&v62, (uint64_t)v32, v37);
                  uint64_t v40 = (double *)v13;
                  uint64_t v56 = v12;
                  goto LABEL_91;
                }
                unsigned int v39 = v29 + 3;
              }
              uint64_t v37 = *v39;
              goto LABEL_90;
            }
            if (v35 == v12) {
              break;
            }
            if (v29[1] == v12)
            {
              BOOL v38 = v29 + 5;
              goto LABEL_86;
            }
            if (v29[2] == v12)
            {
              BOOL v38 = v29 + 3;
              goto LABEL_86;
            }
            uint64_t v36 = 0;
LABEL_87:
            ARC3DShapeTriangulationListInsert((void **)&v65, (uint64_t)v32, v36);
            uint64_t v40 = v33;
            uint64_t v57 = v13;
            CFNumberRef v33 = (double *)v12;
LABEL_91:
            unint64_t v23 = v31;
            if (v61 == v58)
            {
              v58 *= 2;
              unint64_t v23 = malloc_type_realloc(v31, 8 * v58, 0x2004093837F09uLL);
              ptr = v23;
            }
            unsigned int v41 = v61 + 1;
            *((void *)v23 + v61) = v7;
            double v25 = v59;
            if (v34 > 0.0 == (*v5 - *v3) * (v26[1] - v3[1]) - (v5[1] - v3[1]) * (*v26 - *v3) > 0.0) {
              double v25 = v26;
            }
            if (v40 != v5)
            {
              int v24 = v60 - 1;
              uint64_t v12 = (uint64_t)v33;
              uint64_t v13 = (uint64_t)v40;
              uint64_t v7 = (uint64_t)v29;
              ++v61;
              if (v33 != v5) {
                continue;
              }
            }
            uint64_t v22 = v57;
            HIDWORD(v68) = v58;
            uint64_t v4 = v55;
            uint64_t v42 = v56;
            goto LABEL_99;
          }
          BOOL v38 = v29 + 4;
LABEL_86:
          uint64_t v36 = *v38;
          goto LABEL_87;
        }
        unsigned int v41 = v68;
        unsigned int v29 = (uint64_t *)v7;
        uint64_t v40 = (double *)v13;
        uint64_t v42 = 0;
LABEL_99:
        uint64_t v43 = *v29;
        if (v40 != v5)
        {
          if (v43 == v42)
          {
            int v46 = v29 + 4;
          }
          else if (v29[1] == v42)
          {
            int v46 = v29 + 5;
          }
          else
          {
            if (v29[2] != v42)
            {
              uint64_t v44 = 0;
LABEL_117:
              unsigned int v48 = &v65;
              goto LABEL_122;
            }
            int v46 = v29 + 3;
          }
          uint64_t v44 = *v46;
          goto LABEL_117;
        }
        if (v43 == v22)
        {
          BOOL v47 = v29 + 4;
        }
        else if (v29[1] == v22)
        {
          BOOL v47 = v29 + 5;
        }
        else
        {
          if (v29[2] != v22)
          {
            uint64_t v44 = 0;
LABEL_121:
            unsigned int v48 = &v62;
LABEL_122:
            ARC3DShapeTriangulationListInsert((void **)v48, (uint64_t)v5, v44);
            if (HIDWORD(v68) == v41)
            {
              HIDWORD(v68) = 2 * v41;
              uint64_t v49 = malloc_type_realloc(ptr, 16 * v41, 0x2004093837F09uLL);
              ptr = v49;
            }
            else
            {
              uint64_t v49 = ptr;
            }
            LODWORD(v68) = v41 + 1;
            *((void *)v49 + v41) = v29;
            int v45 = 1;
            uint64_t v50 = ARC3DShapeConnectedComponentTriangulatePseudopolygon((int *)&v65, v3, v5, (unsigned int *)&v68, 1);
            if (v50 == 2) {
              goto LABEL_129;
            }
            uint64_t v51 = v50;
            uint64_t v52 = ARC3DShapeConnectedComponentTriangulatePseudopolygon((int *)&v62, v3, v5, (unsigned int *)&v68, 0);
            if (v52 == 2) {
              goto LABEL_129;
            }
            *(void *)(v51 + 24) = v52;
            *(void *)(v52 + 40) = v51;
            if (v68) {
              ARC3DShapeTriangulationAddEdge_cold_1();
            }
LABEL_130:
            free(ptr);
            float v53 = v67;
            free(v66);
            free(v53);
            float v54 = v64;
            free(v63);
            free(v54);
            return;
          }
          BOOL v47 = v29 + 3;
        }
        uint64_t v44 = *v47;
        goto LABEL_121;
      }
      unint64_t v21 = (uint64_t *)(v7 + 24);
    }
    uint64_t v20 = *v21;
    goto LABEL_57;
  }
  uint64_t v17 = 0;
  while (*(double ***)(v7 + 8 * v17 + 24) != v70)
  {
    if (++v17 == 3)
    {
      LODWORD(v17) = -1;
      break;
    }
  }
  uint64_t v18 = 0;
  while (v70[v18 + 3] != (double *)v7)
  {
    if (++v18 == 3) {
      goto LABEL_43;
    }
  }
  if (v17 != -1)
  {
    *((unsigned char *)v70 + v18 + 48) = 1;
    *(unsigned char *)(v7 + v17 + 48) = 1;
    return;
  }
LABEL_43:
  int v16 = 5;
LABEL_44:
  *(_DWORD *)(v4 + 40) = v16;
}

int *ARC3DShapeTriangulationResolveSwaps(int *result, double *a2)
{
  unsigned int v2 = *result;
  if (*result)
  {
    uint64_t v4 = result;
    unsigned int v5 = 1000;
    while (2)
    {
      if (v5 >= 2)
      {
        if (v2 > v4[8])
        {
          int v14 = 9;
        }
        else
        {
          uint64_t v6 = *((void *)v4 + 1);
          unsigned int v7 = v2 - 1;
          *uint64_t v4 = v7;
          uint64_t v8 = *(void *)(v6 + 8 * v7);
          uint64_t v9 = *(void *)(v8 + 32);
          if (v9)
          {
            uint64_t v10 = 0;
            --v5;
            uint64_t v11 = 24;
            while (*(void *)(v9 + v11) != v8)
            {
              ++v10;
              v11 += 8;
              if (v10 == 3) {
                goto LABEL_38;
              }
            }
            if (v10 > 1) {
              int v12 = -2;
            }
            else {
              int v12 = 1;
            }
            if (v10) {
              uint64_t v13 = (v10 - 1);
            }
            else {
              uint64_t v13 = 2;
            }
            int v14 = 5;
            if (~v12 != v10 && v13 != -1)
            {
              if (!*(unsigned char *)(v8 + 49))
              {
                unsigned int v15 = v12 + v10;
                int v16 = *(double **)(v9 + v11 - 24);
                uint64_t v17 = *(double **)(v9 + 8 * v13);
                uint64_t result = (int *)ARC3DCircumcircleContainsPoint(v16, *(double **)(v9 + 8 * (v12 + v10)), v17, a2);
                if (result)
                {
                  uint64_t v18 = v15;
                  uint64_t v19 = *(void *)(v9 + 24 + 8 * v15);
                  uint64_t v20 = *(void *)(v9 + 24 + 8 * v13);
                  uint64_t v21 = *(void *)(v8 + 40);
                  char v22 = *(unsigned char *)(v9 + 48 + v13);
                  char v23 = *(unsigned char *)(v8 + 50);
                  *(_WORD *)(v8 + 49) = *(unsigned __int8 *)(v9 + 48 + v18);
                  *(unsigned char *)(v9 + 48) = 0;
                  *(unsigned char *)(v9 + 49) = v22;
                  *(unsigned char *)(v9 + 50) = v23;
                  *(void *)(v8 + 16) = v17;
                  *(void *)(v8 + 32) = v19;
                  *(void *)(v8 + 40) = v9;
                  *(void *)uint64_t v9 = a2;
                  *(void *)(v9 + 8) = v17;
                  *(void *)(v9 + 16) = v16;
                  *(void *)(v9 + 24) = v8;
                  *(void *)(v9 + 32) = v20;
                  *(void *)(v9 + 40) = v21;
                  if (v19)
                  {
                    uint64_t v24 = 0;
                    while (*(void *)(v19 + 24 + v24) != v9)
                    {
                      v24 += 8;
                      if (v24 == 24) {
                        goto LABEL_38;
                      }
                    }
                    double v25 = (uint64_t *)(v19 + v24 + 24);
                    if (v25 == (uint64_t *)3) {
                      goto LABEL_38;
                    }
                    uint64_t *v25 = v8;
                    uint64_t result = (int *)ARC3DShapeTriangulationStackPush(v4, v8);
                  }
                  if (v20) {
                    uint64_t result = (int *)ARC3DShapeTriangulationStackPush(v4, v9);
                  }
                  if (v21)
                  {
                    uint64_t v26 = 0;
                    while (*(void *)(v21 + 24 + v26) != v8)
                    {
                      v26 += 8;
                      if (v26 == 24) {
                        goto LABEL_38;
                      }
                    }
                    unsigned int v27 = (uint64_t *)(v21 + v26 + 24);
                    if (v27 != (uint64_t *)3)
                    {
                      uint64_t *v27 = v9;
                      goto LABEL_36;
                    }
LABEL_38:
                    int v14 = 5;
                    goto LABEL_39;
                  }
                }
              }
LABEL_36:
              unsigned int v2 = *v4;
              if (*v4) {
                continue;
              }
              return result;
            }
          }
          else
          {
            int v14 = 10;
          }
        }
LABEL_39:
        v4[10] = v14;
      }
      break;
    }
  }
  return result;
}

int *ARC3DShapeTriangulationTriangleSplitInside(int *result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = result;
  uint64_t v6 = *(void *)(a2 + 32);
  uint64_t v5 = *(void *)(a2 + 40);
  uint64_t v7 = *(void *)a2;
  uint64_t v8 = *(void *)(a2 + 8);
  uint64_t v10 = *(void *)(a2 + 16);
  uint64_t v9 = *(void *)(a2 + 24);
  *(void *)a2 = a3;
  *(void *)(a2 + 8) = v7;
  *(void *)(a2 + 16) = v8;
  uint64_t v11 = *((void *)result + 2);
  unsigned int v12 = result[8];
  uint64_t v13 = v11 + 56 * v12;
  *(unsigned char *)(v13 + 51) = 0;
  result[8] = v12 + 2;
  uint64_t v14 = v11 + 56 * (v12 + 1);
  *(unsigned char *)(v14 + 51) = 0;
  *(void *)(a2 + 24) = v13;
  *(void *)(a2 + 32) = v9;
  *(void *)(a2 + 40) = v14;
  *(void *)uint64_t v13 = a3;
  *(void *)(v13 + 8) = v10;
  *(void *)(v13 + 16) = v7;
  *(void *)(v13 + 24) = v14;
  *(void *)(v13 + 32) = v5;
  *(void *)(v13 + 40) = a2;
  *(void *)uint64_t v14 = a3;
  *(void *)(v14 + 8) = v8;
  *(void *)(v14 + 16) = v10;
  *(void *)(v14 + 24) = a2;
  *(void *)(v14 + 32) = v6;
  *(void *)(v14 + 40) = v13;
  *(unsigned char *)(v13 + 48) = 0;
  *(unsigned char *)(v13 + 49) = *(unsigned char *)(a2 + 50);
  *(unsigned char *)(v13 + 50) = 0;
  *(unsigned char *)(v14 + 48) = 0;
  *(unsigned char *)(v14 + 49) = *(unsigned char *)(a2 + 49);
  *(unsigned char *)(v14 + 50) = 0;
  *(unsigned char *)(a2 + 49) = *(unsigned char *)(a2 + 48);
  *(unsigned char *)(a2 + 48) = 0;
  *(unsigned char *)(a2 + 50) = 0;
  if (v9) {
    uint64_t result = (int *)ARC3DShapeTriangulationStackPush(result, a2);
  }
  if (v6)
  {
    uint64_t v15 = 0;
    while (*(void *)(v6 + 24 + v15) != a2)
    {
      v15 += 8;
      if (v15 == 24) {
        goto LABEL_19;
      }
    }
    int v16 = (uint64_t *)(v6 + v15 + 24);
    if (v16 == (uint64_t *)3)
    {
LABEL_19:
      v4[10] = 5;
      return result;
    }
    uint64_t *v16 = v14;
    uint64_t result = (int *)ARC3DShapeTriangulationStackPush(v4, v14);
  }
  if (!v5) {
    return result;
  }
  uint64_t v17 = 0;
  while (*(void *)(v5 + 24 + v17) != a2)
  {
    v17 += 8;
    if (v17 == 24) {
      goto LABEL_19;
    }
  }
  uint64_t v18 = (uint64_t *)(v5 + v17 + 24);
  if (v18 == (uint64_t *)3) {
    goto LABEL_19;
  }
  *uint64_t v18 = v13;
  return (int *)ARC3DShapeTriangulationStackPush(v4, v13);
}

void *ARC3DShapeTriangulationTriangleSplitOnEdge(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, unsigned int a5)
{
  uint64_t v7 = *(void *)(a2 + 24 + 8 * a4);
  unsigned int v8 = (a5 + 1) % 3;
  uint64_t v9 = *(void *)(v7 + 24 + 8 * v8);
  unsigned int v10 = (a5 + 2) % 3;
  uint64_t v11 = *(void *)(v7 + 24 + 8 * v10);
  unsigned int v12 = (a4 + 1) % 3;
  uint64_t v13 = *(void *)(a2 + 24 + 8 * v12);
  unsigned int v14 = (a4 + 2) % 3;
  uint64_t v15 = *(void *)(a2 + 24 + 8 * v14);
  unsigned __int8 v16 = *(unsigned char *)(v7 + 48 + v8);
  LOBYTE(v8) = *(unsigned char *)(v7 + 48 + v10);
  LOBYTE(v12) = *(unsigned char *)(a2 + 48 + v12);
  char v17 = *(unsigned char *)(a2 + 48 + v14);
  char v18 = *(unsigned char *)(v7 + 48 + a5);
  uint64_t v19 = *(void *)(a2 + 8 * a4);
  uint64_t v20 = *(void *)(v7 + 8 * a5);
  uint64_t v21 = *(void *)(a2 + 8 * v14);
  uint64_t v22 = *(void *)(v7 + 8 * v10);
  uint64_t result = *(void **)(a1 + 16);
  unsigned int v24 = *(_DWORD *)(a1 + 32);
  uint64_t v25 = (uint64_t)&result[7 * v24];
  *(unsigned char *)(v25 + 51) = 0;
  *(_DWORD *)(a1 + 32) = v24 + 2;
  uint64_t v26 = (uint64_t)&result[7 * v24 + 7];
  *(unsigned char *)(v26 + 51) = 0;
  *(void *)a2 = a3;
  *(void *)(a2 + 8) = v20;
  *(void *)(a2 + 16) = v21;
  *(void *)(a2 + 24) = v7;
  *(void *)(a2 + 32) = v13;
  *(void *)(a2 + 40) = v25;
  *(unsigned char *)(a2 + 48) = v18;
  *(_WORD *)(a2 + 49) = v12;
  *(void *)uint64_t v7 = a3;
  *(void *)(v7 + 8) = v22;
  *(void *)(v7 + 16) = v20;
  *(void *)(v7 + 24) = v26;
  *(void *)(v7 + 32) = v11;
  *(void *)(v7 + 40) = a2;
  *(unsigned char *)(v7 + 48) = 0;
  *(unsigned char *)(v7 + 49) = v8;
  *(unsigned char *)(v7 + 50) = v18;
  *(void *)uint64_t v25 = a3;
  *(void *)(v25 + 8) = v21;
  *(void *)(v25 + 16) = v19;
  *(void *)(v25 + 24) = a2;
  *(void *)(v25 + 32) = v15;
  *(void *)(v25 + 40) = v26;
  *(unsigned char *)(v25 + 48) = 0;
  *(unsigned char *)(v25 + 49) = v17;
  *(unsigned char *)(v25 + 50) = v18;
  *(void *)uint64_t v26 = a3;
  *(void *)(v26 + 8) = v19;
  *(void *)(v26 + 16) = v22;
  *(void *)(v26 + 24) = v25;
  *(void *)(v26 + 32) = v9;
  *(void *)(v26 + 40) = v7;
  *(unsigned char *)(v26 + 48) = v18;
  *(_WORD *)(v26 + 49) = v16;
  if (v11) {
    uint64_t result = ARC3DShapeTriangulationStackPush((int *)a1, v7);
  }
  if (v13) {
    uint64_t result = ARC3DShapeTriangulationStackPush((int *)a1, a2);
  }
  if (v15)
  {
    uint64_t v27 = 0;
    while (*(void *)(v15 + 24 + v27) != a2)
    {
      v27 += 8;
      if (v27 == 24) {
        goto LABEL_21;
      }
    }
    uint64_t v28 = (uint64_t *)(v15 + v27 + 24);
    if (v28 == (uint64_t *)3)
    {
LABEL_21:
      *(_DWORD *)(a1 + 40) = 5;
      return result;
    }
    *uint64_t v28 = v25;
    uint64_t result = ARC3DShapeTriangulationStackPush((int *)a1, v25);
  }
  if (!v9) {
    return result;
  }
  uint64_t v29 = 0;
  while (*(void *)(v9 + 24 + v29) != v7)
  {
    v29 += 8;
    if (v29 == 24) {
      goto LABEL_21;
    }
  }
  BOOL v30 = (uint64_t *)(v9 + v29 + 24);
  if (v30 == (uint64_t *)3) {
    goto LABEL_21;
  }
  *BOOL v30 = v26;
  return ARC3DShapeTriangulationStackPush((int *)a1, v26);
}

int *ARC3DShapeTriangulationAddPoint(uint64_t a1, float64x2_t *a2)
{
  uint64_t result = (int *)ARC3DShapeTriangulationTriangleContainingPoint(a2, *(void *)(a1 + 16) + 56 * (*(_DWORD *)(a1 + 32) - 1), a1);
  if (result == (int *)2)
  {
    *(_DWORD *)(a1 + 40) = 8;
  }
  else
  {
    uint64_t v5 = (uint64_t)result;
    uint64_t v6 = 0;
    if (ARC3DPointFallsOnTriangleEdgeAndLinks((uint64_t)result, a2->f64, (_DWORD *)&v6 + 1, &v6)) {
      ARC3DShapeTriangulationTriangleSplitOnEdge(a1, v5, (uint64_t)a2, HIDWORD(v6), v6);
    }
    else {
      ARC3DShapeTriangulationTriangleSplitInside((int *)a1, v5, (uint64_t)a2);
    }
    return ARC3DShapeTriangulationResolveSwaps((int *)a1, a2->f64);
  }
  return result;
}

__n128 ARC3DShapeTriangulationInit(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *(void *)(a1 + 16);
  unsigned int v6 = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 32) = v6 + 1;
  uint64_t v7 = v5 + 56 * v6;
  *(unsigned char *)(v7 + 51) = 0;
  *(void *)(a1 + 24) = v7;
  double v8 = *(double *)(*(void *)a2 + 16);
  double v9 = *(double *)(*(void *)a2 + 24);
  double v10 = *(double *)(*(void *)a2 + 32);
  double v11 = *(double *)(*(void *)a2 + 40);
  double v12 = v9 - v8;
  double v13 = v11 - v10;
  if (vabdd_f64(v9, v8) < 0.00001 || vabdd_f64(v11, v10) < 0.00001) {
    *(_DWORD *)(a1 + 40) = 7;
  }
  double v14 = v10 + v13 * -100.0;
  uint64_t v15 = v5 + 56 * v6;
  *(void *)(v15 + 24) = 0;
  *(void *)(v15 + 32) = 0;
  *(_DWORD *)(v15 + 47) = 0;
  *(void *)(v15 + 40) = 0;
  *(double *)a3 = v8 + v12 * -100.0;
  *(double *)(a3 + 8) = v14;
  *(_OWORD *)(a3 + 48) = *(_OWORD *)a3;
  *(double *)a4 = v8 + v12 * 100.0;
  *(double *)(a4 + 8) = v14;
  *(_OWORD *)(a4 + 48) = *(_OWORD *)a4;
  *(double *)a5 = v8 + v12 * 0.0;
  *(double *)(a5 + 8) = v10 + v13 * 100.0;
  __n128 result = *(__n128 *)a5;
  *(_OWORD *)(a5 + 48) = *(_OWORD *)a5;
  *(void *)uint64_t v7 = a3;
  *(void *)(v7 + 8) = a4;
  *(void *)(v7 + 16) = a5;
  return result;
}

uint64_t ARC3DShapeTriangulationTriangleMark(uint64_t a1, int a2, BOOL *a3)
{
  *(unsigned char *)(a1 + 51) = 1;
  *(unsigned char *)(a1 + 52) = a2;
  uint64_t v6 = *(void *)(a1 + 24);
  if (v6 && !*(unsigned char *)(v6 + 51)) {
    ARC3DShapeTriangulationTriangleMark();
  }
  uint64_t v7 = *(void *)(a1 + 32);
  if (v7 && !*(unsigned char *)(v7 + 51)) {
    ARC3DShapeTriangulationTriangleMark();
  }
  uint64_t result = *(void *)(a1 + 40);
  if (result)
  {
    if (!*(unsigned char *)(result + 51)) {
      uint64_t result = ARC3DShapeTriangulationTriangleMark();
    }
  }
  if (*(void *)(a1 + 24))
  {
    if (*(void *)(a1 + 32))
    {
      if (*(void *)(a1 + 40)) {
        return result;
      }
      double v9 = (unsigned __int8 *)(a1 + 50);
    }
    else
    {
      double v9 = (unsigned __int8 *)(a1 + 49);
    }
  }
  else
  {
    double v9 = (unsigned __int8 *)(a1 + 48);
  }
  *a3 = *v9 != a2;
  return result;
}

void *ARC3DShapeTriangulationClean(uint64_t a1)
{
  BOOL v10 = 0;
  ARC3DShapeTriangulationTriangleMark(*(void *)(a1 + 16), 1, &v10);
  LODWORD(v2) = *(_DWORD *)(a1 + 32);
  if (!v2) {
    goto LABEL_12;
  }
  unsigned int v3 = 0;
  int v4 = v10;
  do
  {
    if (*(unsigned __int8 *)(*(void *)(a1 + 16) + 56 * v3 + 52) == v4)
    {
      LODWORD(v2) = v2 - 1;
      *(_DWORD *)(a1 + 32) = v2;
      if (v3 < v2)
      {
        unint64_t v5 = v3;
        uint64_t v6 = 56 * v3;
        do
        {
          uint64_t v7 = *(void *)(a1 + 16) + v6;
          ++v5;
          long long v8 = *(_OWORD *)(v7 + 72);
          *(_OWORD *)uint64_t v7 = *(_OWORD *)(v7 + 56);
          *(_OWORD *)(v7 + 16) = v8;
          *(_OWORD *)(v7 + 32) = *(_OWORD *)(v7 + 88);
          *(void *)(v7 + 48) = *(void *)(v7 + 104);
          unint64_t v2 = *(unsigned int *)(a1 + 32);
          v6 += 56;
        }
        while (v5 < v2);
      }
    }
    else
    {
      ++v3;
    }
  }
  while (v3 < v2);
  if (v2)
  {
    uint64_t result = malloc_type_realloc(*(void **)(a1 + 16), 56 * v2, 0x1020040F7381AC9uLL);
  }
  else
  {
LABEL_12:
    free(*(void **)(a1 + 16));
    uint64_t result = 0;
  }
  *(void *)(a1 + 16) = result;
  return result;
}

void *ARC3DShapeConnectedComponentTriangulate(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v6 = *(unsigned int *)(a1 + 8);
  if (v6)
  {
    int v7 = 0;
    long long v8 = (int *)(*(void *)a1 + 8);
    do
    {
      int v9 = *v8;
      v8 += 14;
      v7 += v9;
      --v6;
    }
    while (v6);
    unsigned int v10 = 2 * v7 + 2;
  }
  else
  {
    unsigned int v10 = 2;
  }
  uint64_t v35 = 0;
  uint64_t v32 = 0x1000000000;
  CFNumberRef v33 = malloc_type_malloc(0x80uLL, 0x2004093837F09uLL);
  double v34 = malloc_type_malloc(56 * v10, 0x1020040F7381AC9uLL);
  int v36 = 0;
  unsigned int v37 = v10;
  uint64_t v38 = 0;
  memset(v31, 0, sizeof(v31));
  memset(v30, 0, sizeof(v30));
  long long v11 = *(_OWORD *)(a1 + 16);
  v28[0] = *(_OWORD *)a1;
  v28[1] = v11;
  memset(v29, 0, sizeof(v29));
  ARC3DShapeTriangulationInit((uint64_t)&v32, (uint64_t)v28, (uint64_t)v31, (uint64_t)v30, (uint64_t)v29);
  int v12 = v38;
  if (v38)
  {
LABEL_20:
    free(v33);
    *a2 = 0;
    *a3 = v12;
    free(v34);
    return 0;
  }
  else
  {
    uint64_t v26 = a3;
    unsigned int v13 = *(_DWORD *)(a1 + 8);
    float64x2_t v27 = (float64x2_t)vdupq_n_s64(0x3EE4F8B588E368F1uLL);
    while ((--v13 & 0x80000000) == 0)
    {
      uint64_t v14 = *(void *)a1 + 56 * v13;
      uint64_t v15 = *(float64x2_t **)v14;
      uint64_t v16 = *(unsigned int *)(v14 + 8);
      ARC3DShapeTriangulationAddPoint((uint64_t)&v32, *(float64x2_t **)v14);
      int v12 = v38;
      if (v38) {
        goto LABEL_19;
      }
      if (v16 >= 2)
      {
        uint64_t v17 = 1;
        while (1)
        {
          char v18 = &v15[5 * v17];
          float64x2_t v20 = *v18;
          f64 = v18[-5].f64;
          float64x2_t v21 = v20;
          uint64_t v22 = v17;
          char v23 = v15;
          while (1)
          {
            int32x2_t v24 = vmovn_s64(vcgeq_f64(v27, vabdq_f64(v21, *v23)));
            if (v24.i32[0] & v24.i32[1]) {
              break;
            }
            v23 += 5;
            if (!--v22)
            {
              ARC3DShapeTriangulationAddPoint((uint64_t)&v32, &v15[5 * v17]);
              int v12 = v38;
              if (v38) {
                goto LABEL_19;
              }
              break;
            }
          }
          ARC3DShapeTriangulationAddEdge((uint64_t)&v32, f64, v15[5 * v17].f64);
          int v12 = v38;
          if (v38) {
            break;
          }
          if (++v17 == v16) {
            goto LABEL_18;
          }
        }
LABEL_19:
        a3 = v26;
        goto LABEL_20;
      }
LABEL_18:
      ARC3DShapeTriangulationAddEdge((uint64_t)&v32, v15[5 * (v16 - 1)].f64, v15->f64);
      int v12 = v38;
      if (v38) {
        goto LABEL_19;
      }
    }
    ARC3DShapeTriangulationClean((uint64_t)&v32);
    free(v33);
    *a2 = v36;
    _DWORD *v26 = 0;
    return v34;
  }
}

void sub_1B88F769C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,id location)
{
}

float ARVoxelSizeForSceneReconstructionOptions(void *a1)
{
  float v1 = 0.05;
  switch([a1 voxelSize])
  {
    case 0:
      unint64_t v2 = +[ARKitUserDefaults numberForKey:@"com.apple.arkit.sceneReconstruction.voxelSize"];
      [v2 doubleValue];
      float v1 = v3;

      break;
    case 2:
      float v1 = 0.03;
      break;
    case 3:
      float v1 = 0.01;
      break;
    case 4:
      float v1 = 0.0;
      break;
    default:
      return v1;
  }
  return v1;
}

uint64_t ARBucketsOrderOfMagnitudeForSceneReconstructionOptions(void *a1)
{
  unint64_t v1 = [a1 bucketsCount];
  unsigned int v2 = 0x11100D11u >> (8 * v1);
  if (v1 >= 4) {
    LOBYTE(v2) = 13;
  }
  return v2;
}

unint64_t SemanticFromARMeshClassification(unsigned int a1)
{
  unint64_t v1 = 0x6070F1303010200uLL >> (8 * a1);
  if (a1 >= 8) {
    LOBYTE(v1) = 0;
  }
  return v1 & 0x1F;
}

uint64_t ARMeshClassificationFromSemantic(int a1)
{
  int v1 = a1 - 1;
  uint64_t result = 2;
  switch(v1)
  {
    case 0:
      return result;
    case 1:
      uint64_t result = 1;
      break;
    case 2:
      uint64_t result = 3;
      break;
    case 5:
      uint64_t result = 7;
      break;
    case 6:
    case 7:
      uint64_t result = 6;
      break;
    case 14:
    case 17:
      uint64_t result = 5;
      break;
    case 15:
    case 18:
      uint64_t result = 4;
      break;
    default:
      uint64_t result = 0;
      break;
  }
  return result;
}

id ARMeshAnchorFromMesh(void *a1, uint64_t a2, void *a3, void *a4, uint64_t a5, char a6, float32x4_t a7, float32x4_t a8, float32x4_t a9, float32x4_t a10, double a11)
{
  return ARMeshAnchorFromMeshNoCopy(a1, a2, a3, a4, a5, 0, 1, 1, a7, a8, a9, a10, a11, a6, 0);
}

id ARMeshAnchorFromMeshNoCopy(void *a1, uint64_t a2, void *a3, void *a4, uint64_t a5, int a6, int a7, int a8, float32x4_t a9, float32x4_t a10, float32x4_t a11, float32x4_t a12, double a13, char a14, char a15)
{
  id v23 = a1;
  id v24 = a3;
  id v26 = a4;
  unint64_t v27 = a9.i64[0];
  unint64_t v28 = a10.i64[0];
  unint64_t v29 = a11.i64[0];
  unint64_t v30 = a12.i64[0];
  if (a15)
  {
    CV3DReconMeshGetLocalToWorldTransform();
    uint64_t v25 = 0;
    uint64_t v31 = 0;
    v54[0] = v32;
    v54[1] = v33;
    v54[2] = v34;
    v54[3] = v35;
    long long v55 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v58 = 0u;
    do
    {
      *(long long *)((char *)&v55 + v31 * 16) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a9, COERCE_FLOAT(v54[v31])), a10, *(float32x2_t *)&v54[v31], 1), a11, (float32x4_t)v54[v31], 2), a12, (float32x4_t)v54[v31], 3);
      ++v31;
    }
    while (v31 != 4);
    unint64_t v27 = v55;
    unint64_t v28 = v56;
    unint64_t v29 = v57;
    unint64_t v30 = v58;
  }
  double v46 = *(double *)&v30;
  double v47 = *(double *)&v29;
  double v48 = *(double *)&v28;
  double v49 = *(double *)&v27;
  int v36 = ARMeshGeometryFromMeshNoCopy(v23, a2, v25, a5, a6, a8);
  if (!v36)
  {
    uint64_t v44 = 0;
    goto LABEL_14;
  }
  unsigned int v37 = [ARMeshAnchor alloc];
  uint64_t v38 = v37;
  if (!v26)
  {
    if (a7)
    {
      uint64_t v43 = -[ARMeshAnchor initWithGeometry:atTimestamp:identifier:referenceOriginTransform:](v37, "initWithGeometry:atTimestamp:identifier:referenceOriginTransform:", v36, v24, a13, *(double *)a9.i64, *(double *)a10.i64, *(double *)a11.i64, *(double *)a12.i64);
      goto LABEL_13;
    }
LABEL_12:
    uint64_t v43 = -[ARMeshAnchor initWithGeometry:atTimestamp:identifier:transform:](v37, "initWithGeometry:atTimestamp:identifier:transform:", v36, v24, a13, v49, v48, v47, v46);
    goto LABEL_13;
  }
  if (!a7) {
    goto LABEL_12;
  }
  [v26 visionTransform];
  uint64_t v43 = -[ARMeshAnchor initWithGeometry:atTimestamp:identifier:visionTransform:referenceOriginTransform:](v38, "initWithGeometry:atTimestamp:identifier:visionTransform:referenceOriginTransform:", v36, v24, a13, v39, v40, v41, v42, *(_OWORD *)&a9, *(_OWORD *)&a10, *(_OWORD *)&a11, *(_OWORD *)&a12);
LABEL_13:
  uint64_t v44 = (void *)v43;
LABEL_14:

  return v44;
}

ARMeshGeometry *ARMeshGeometryFromMeshNoCopy(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  id v9 = a1;
  VerticesCFIndex Count = CV3DReconMeshGetVerticesCount();
  if (!VerticesCount) {
    goto LABEL_10;
  }
  uint64_t v11 = VerticesCount;
  if (a5)
  {
    int v12 = CV3DReconMeshGetVerticesAsMTLBufferForDevice();
    goto LABEL_6;
  }
  uint64_t VerticesRawPtr = CV3DReconMeshGetVerticesRawPtr();
  if (!VerticesRawPtr)
  {
    __ARMeshGeometryFromMeshNoCopy_block_invoke(0, @"Error getting vertices raw pointer", 0);
LABEL_10:
    uint64_t v17 = 0;
    goto LABEL_19;
  }
  int v12 = (void *)[v9 newBufferWithBytes:VerticesRawPtr length:12 * v11 options:0];
LABEL_6:
  uint64_t v14 = [[ARGeometrySource alloc] initWithBuffer:v12 count:v11 format:30 componentsPerVector:3 offset:0 stride:12];
  uint64_t v15 = 0;
  if (a6)
  {
    if (a5)
    {
      uint64_t v16 = CV3DReconMeshGetVertexNormalsAsMTLBufferForDevice();
    }
    else
    {
      uint64_t VertexNormalsRawPtr = CV3DReconMeshGetVertexNormalsRawPtr();
      if (!VertexNormalsRawPtr)
      {
        __ARMeshGeometryFromMeshNoCopy_block_invoke(0, @"Error getting normals raw pointer", 0);
        uint64_t v15 = 0;
        goto LABEL_17;
      }
      uint64_t v16 = (void *)[v9 newBufferWithBytes:VertexNormalsRawPtr length:12 * v11 options:0];
    }
    uint64_t v15 = [[ARGeometrySource alloc] initWithBuffer:v16 count:v11 format:30 componentsPerVector:3 offset:0 stride:12];
  }
  FacesCFIndex Count = CV3DReconMeshGetFacesCount();
  if (FacesCount)
  {
    uint64_t v20 = CV3DReconMeshGetFacesAsMTLBufferForDevice();
    uint64_t v31 = (void *)v20;
    uint64_t v22 = [[ARGeometryElement alloc] initWithBuffer:v20 count:FacesCount bytesPerIndex:4 primitiveType:1];
    long long v32 = [[ARMeshGeometry alloc] initWithVertices:v14 normals:v15 faces:v22];
    if ((~a4 & 0x11) == 0 || (a4 & 0x80) != 0)
    {
      unint64_t v30 = CV3DReconMeshGetVertexColorsAsMTLBufferForDevice();
      id v23 = [[ARGeometrySource alloc] initWithBuffer:v30 count:v11 format:30 componentsPerVector:3 offset:0 stride:12];
      [(ARMeshGeometry *)v32 setColors:v23];
    }
    if ((~(_BYTE)a4 & 3) == 0)
    {
      if (a5)
      {
        CV3DReconMeshGetFaceSemanticLabelsAsMTLBufferForDevice();
        id v24 = (id)objc_claimAutoreleasedReturnValue();
      }
      else
      {
        uint64_t FaceSemanticLabelsRawPtr = CV3DReconMeshGetFaceSemanticLabelsRawPtr();
        if (!FaceSemanticLabelsRawPtr)
        {
          unint64_t v29 = v22;
          __ARMeshGeometryFromMeshNoCopy_block_invoke(0, @"Error getting semantic labels raw pointer", 0);
          uint64_t v17 = 0;
          goto LABEL_34;
        }
        id v24 = (id) [v9 newBufferWithBytes:FaceSemanticLabelsRawPtr length:FacesCount options:0];
        id v26 = (unsigned char *)[v24 contents];
        uint64_t v27 = FacesCount;
        do
        {
          unsigned char *v26 = ARMeshClassificationFromSemantic(*v26);
          ++v26;
          --v27;
        }
        while (v27);
      }
      unint64_t v28 = [[ARGeometrySource alloc] initWithBuffer:v24 count:FacesCount format:45 componentsPerVector:1 offset:0 stride:1];
      [(ARMeshGeometry *)v32 setClassification:v28];
    }
    unint64_t v29 = v22;
    uint64_t v17 = v32;
LABEL_34:

    goto LABEL_18;
  }
LABEL_17:
  uint64_t v17 = 0;
LABEL_18:

LABEL_19:
  return v17;
}

void __ARMeshGeometryFromMeshNoCopy_block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  id v4 = a2;
  if (a3)
  {
    unint64_t v5 = _ARLogGeneral_8();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = [a3 localizedFailureReason];
      int v7 = 138412546;
      id v8 = v4;
      __int16 v9 = 2112;
      unsigned int v10 = v6;
      _os_log_impl(&dword_1B88A2000, v5, OS_LOG_TYPE_ERROR, "%@: %@", (uint8_t *)&v7, 0x16u);
    }
  }
}

__CFString *NSStringFromAREnvironmentTexturing(unint64_t a1)
{
  if (a1 > 2) {
    return @"Unknown";
  }
  else {
    return off_1E61863F0[a1];
  }
}

__CFString *NSStringFromARPlaneDetection(char a1)
{
  int v1 = @"Vertical";
  if ((a1 & 2) == 0) {
    int v1 = @"None";
  }
  if (a1) {
    int v1 = @"Horizontal";
  }
  if ((~a1 & 3) != 0) {
    return v1;
  }
  else {
    return @"Horizontal|Vertical";
  }
}

__CFString *NSStringFromARWorldAlignment(unint64_t a1)
{
  if (a1 > 2) {
    return @"Unknown";
  }
  else {
    return off_1E6186408[a1];
  }
}

id NSStringFromARFrameSemantics(uint64_t a1)
{
  unsigned int v2 = objc_opt_new();
  double v3 = v2;
  if (!a1)
  {
    unint64_t v5 = @"None";
LABEL_15:
    [v3 addObject:v5];
    goto LABEL_16;
  }
  if ((~a1 & 3) != 0)
  {
    if ((a1 & 1) == 0)
    {
      if ((a1 & 4) != 0) {
        goto LABEL_12;
      }
LABEL_7:
      if ((a1 & 8) != 0) {
        goto LABEL_13;
      }
      goto LABEL_8;
    }
    id v4 = @"Person Segmentation";
  }
  else
  {
    id v4 = @"Person Segmentation with Depth";
  }
  [v2 addObject:v4];
  if ((a1 & 4) == 0) {
    goto LABEL_7;
  }
LABEL_12:
  [v3 addObject:@"Body Detection"];
  if ((a1 & 8) != 0)
  {
LABEL_13:
    [v3 addObject:@"Scene Depth"];
    if ((a1 & 0x10) == 0) {
      goto LABEL_16;
    }
    goto LABEL_14;
  }
LABEL_8:
  if ((a1 & 0x10) != 0)
  {
LABEL_14:
    unint64_t v5 = @"Smoothed Scene Depth";
    goto LABEL_15;
  }
LABEL_16:
  if (![v3 count]) {
    [v3 addObject:@"Unknown"];
  }
  uint64_t v6 = [v3 componentsJoinedByString:@"|"];

  return v6;
}

__CFString *NSStringFromARSceneReconstruction(uint64_t a1)
{
  unsigned int v2 = objc_opt_new();
  double v3 = v2;
  if (a1)
  {
    if (a1) {
      [v2 addObject:@"Mesh"];
    }
    if ((~a1 & 3) == 0) {
      [v3 addObject:@"with classification"];
    }
    if ((~a1 & 0x11) == 0) {
      [v3 addObject:@"with color"];
    }
    if ((a1 & 8) != 0) {
      [v3 addObject:@"Keyframe"];
    }
    if ((~a1 & 0x18) == 0) {
      [v3 addObject:@"with color"];
    }
    if ((a1 & 0x80) != 0) {
      [v3 addObject:@"ObjectCapture"];
    }
    if ([v3 count])
    {
      id v4 = NSString;
      unint64_t v5 = [v3 componentsJoinedByString:@" "];
      uint64_t v6 = [v4 stringWithFormat:@"(%@)", v5];
    }
    else
    {
      uint64_t v6 = @"Unknown";
    }
  }
  else
  {
    uint64_t v6 = @"None";
  }

  return v6;
}

void sub_1B88F8DD4(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, long long buf, int a12, __int16 a13, __int16 a14, void *a15)
{
  if (a2 == 1)
  {
    id v15 = objc_begin_catch(a1);
    uint64_t v16 = _ARLogGeneral_9();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      uint64_t v17 = (objc_class *)objc_opt_class();
      NSStringFromClass(v17);
      id v18 = (id)objc_claimAutoreleasedReturnValue();
      uint64_t v19 = [v15 reason];
      LODWORD(buf) = 138543874;
      *(void *)((char *)&buf + 4) = v18;
      WORD6(buf) = 2048;
      a14 = 2112;
      a15 = v19;
      _os_log_impl(&dword_1B88A2000, v16, OS_LOG_TYPE_ERROR, "%{public}@ <%p>: Unable to decode jasper framerate values: %@", (uint8_t *)&buf, 0x20u);
    }
    objc_end_catch();
    JUMPOUT(0x1B88F8CD8);
  }
  _Unwind_Resume(a1);
}

void sub_1B88F9484(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id location)
{
}

void ARAddScalingTechniquesToTechniques(void *a1, uint64_t a2, uint64_t a3, double a4, double a5, double a6, double a7)
{
  v23[1] = *MEMORY[0x1E4F143B8];
  id v13 = a1;
  uint64_t v14 = -[ARMLImageDownScalingTechnique initWithSize:requiredTimeInterval:]([ARMLImageDownScalingTechnique alloc], "initWithSize:requiredTimeInterval:", a4, a5, a6);
  [(ARMLImageDownScalingTechnique *)v14 setSaveIntermediateScaleResultData:a2];
  [(ARMLImageDownScalingTechnique *)v14 setCenterCropImage:a3];
  id v15 = -[ARMLImageDownScalingTechnique initWithSize:requiredTimeInterval:]([ARMLImageDownScalingTechnique alloc], "initWithSize:requiredTimeInterval:", a4, a5, a7);
  [(ARMLImageDownScalingTechnique *)v15 setSaveIntermediateScaleResultData:a2];
  [(ARMLImageDownScalingTechnique *)v15 setCenterCropImage:a3];
  [(ARMLImageDownScalingTechnique *)v15 setShouldOperateOnHighResolutionImages:1];
  uint64_t v16 = [ARParentTechnique alloc];
  v23[0] = v14;
  uint64_t v17 = [MEMORY[0x1E4F1C978] arrayWithObjects:v23 count:1];
  id v18 = [(ARParentTechnique *)v16 initWithParallelTechniques:v17];

  uint64_t v19 = [ARParentTechnique alloc];
  uint64_t v22 = v15;
  uint64_t v20 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v22 count:1];
  float64x2_t v21 = [(ARParentTechnique *)v19 initWithParallelTechniques:v20];

  [v13 addObject:v18];
  [v13 addObject:v21];
}

void ARAddNonJasperSemanticsToParent(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  v31[1] = *MEMORY[0x1E4F143B8];
  id v27 = a1;
  uint64_t v6 = (void *)MEMORY[0x1E4F1CA80];
  id v26 = a2;
  uint64_t v7 = objc_opt_class();
  uint64_t v8 = objc_opt_class();
  uint64_t v9 = objc_opt_class();
  unint64_t v28 = objc_msgSend(v6, "setWithObjects:", v7, v8, v9, objc_opt_class(), 0);
  unsigned int v10 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v11 = -[ARMLImageDownScalingTechnique initWithSize:requiredTimeInterval:]([ARMLImageDownScalingTechnique alloc], "initWithSize:requiredTimeInterval:", 256.0, 192.0, 0.002);
  [(ARMLImageDownScalingTechnique *)v11 setResizeUltraWideImage:ARDeviceSupportsUltraWideCamera()];
  [(ARMLImageDownScalingTechnique *)v11 setWideRotationStrategy:&__block_literal_global_30];
  [(ARMLImageDownScalingTechnique *)v11 setUltrawideRotationStrategy:&__block_literal_global_30];
  int v12 = [ARParentTechnique alloc];
  v31[0] = v11;
  id v13 = [MEMORY[0x1E4F1C978] arrayWithObjects:v31 count:1];
  uint64_t v14 = [(ARParentTechnique *)v12 initWithParallelTechniques:v13];

  [v10 addObject:v14];
  if (ARDeviceSupportsUltraWideCamera())
  {
    id v15 = -[ARImageDistortionCorrectionTechnique initWithImageSize:]([ARImageDistortionCorrectionTechnique alloc], "initWithImageSize:", 256.0, 192.0);
    [v10 addObject:v15];
  }
  uint64_t v16 = [ARParentTechnique alloc];
  id v17 = [[ARSISemanticSegmentationTechnique alloc] initLegacyAlgorithmUsingSynchronizedUltrawideWhenAvailable:a4];
  id v30 = v17;
  id v18 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v30 count:1];
  uint64_t v19 = [(ARParentTechnique *)v16 initWithParallelTechniques:v18];

  [v10 addObject:v19];
  uint64_t v20 = [[ARSplitTechniqueSynchronizerTechnique alloc] initWithSynchronizedResultDataClasses:v28];
  float64x2_t v21 = [[ARParentTechnique alloc] initWithTechniques:v10 delegate:v20];
  unint64_t v29 = v21;
  uint64_t v22 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v29 count:1];
  [v27 setSplitTechniques:v22];

  if (ARDeviceSupportsUltraWideCamera() && a4) {
    id v23 = [[ARSyncedUltraWideForwardingStrategy alloc] initWithMaxFrameRate:a3];
  }
  else {
    id v23 = [[ARFrameRateLimitingStrategy alloc] initWithFrameRate:10];
  }
  id v24 = v23;
  [v27 setSplitTechniqueFowardingStrategy:v23];

  [v26 insertObject:v20 atIndex:0];
}

void __ARAddNonJasperSemanticsToParent_block_invoke(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v4 = 180;
  if (((a2 - 2) & 0xFFFFFFFFFFFFFFFDLL) != 0) {
    uint64_t v4 = 0;
  }
  *a4 = v4;
  *a3 = v4;
}

void ARAddJasperTechniquesToParent(void *a1, void *a2, int a3, unsigned int a4, uint64_t a5)
{
  v59[1] = *MEMORY[0x1E4F143B8];
  id v6 = a1;
  id v7 = a2;
  uint64_t v8 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v9 = +[ARParentTechnique parentTechniqueOfClass:objc_opt_class() inArray:v7];
  if (v9)
  {
    unsigned int v10 = (void *)MEMORY[0x1E4F1CA80];
    uint64_t v11 = objc_opt_class();
    int v12 = objc_msgSend(v10, "setWithObjects:", v11, objc_opt_class(), 0);
  }
  else
  {
    int v12 = 0;
  }
  if (a3)
  {
    id v53 = v6;
    id v13 = (void *)MEMORY[0x1E4F1CA80];
    uint64_t v14 = objc_opt_class();
    uint64_t v15 = objc_opt_class();
    uint64_t v16 = objc_opt_class();
    uint64_t v17 = objc_opt_class();
    uint64_t v18 = objc_msgSend(v13, "setWithObjects:", v14, v15, v16, v17, objc_opt_class(), 0);

    [v8 removeAllObjects];
    if (v9)
    {
      uint64_t v19 = +[ARTechnique techniqueOfClass:objc_opt_class() inArray:v7];
    }
    else
    {
      uint64_t v19 = -[ARMLImageDownScalingTechnique initWithSize:requiredTimeInterval:]([ARMLImageDownScalingTechnique alloc], "initWithSize:requiredTimeInterval:", 256.0, 192.0, 0.002);
      uint64_t v20 = [ARParentTechnique alloc];
      v59[0] = v19;
      float64x2_t v21 = [MEMORY[0x1E4F1C978] arrayWithObjects:v59 count:1];
      uint64_t v22 = [(ARParentTechnique *)v20 initWithParallelTechniques:v21];

      [v8 addObject:v22];
      id v23 = [[ARDepthTechnique alloc] initWithPrioritization:1 temporalSmoothing:a4];
      id v24 = [ARParentTechnique alloc];
      long long v58 = v23;
      uint64_t v25 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v58 count:1];
      id v26 = [(ARParentTechnique *)v24 initWithParallelTechniques:v25];

      [v8 addObject:v26];
    }
    id v6 = v53;
    if (ARDeviceSupportsUltraWideCamera())
    {
      id v27 = -[ARImageDistortionCorrectionTechnique initWithImageSize:]([ARImageDistortionCorrectionTechnique alloc], "initWithImageSize:", 256.0, 192.0);
      [v8 addObject:v27];
      [(ARMLImageDownScalingTechnique *)v19 setResizeUltraWideImage:1];
      [(ARMLImageDownScalingTechnique *)v19 setUltrawideRotationStrategy:&__block_literal_global_471];
    }
    unint64_t v28 = [ARParentTechnique alloc];
    unint64_t v29 = objc_opt_new();
    long long v57 = v29;
    id v30 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v57 count:1];
    uint64_t v31 = [(ARParentTechnique *)v28 initWithParallelTechniques:v30];

    [v8 addObject:v31];
    long long v32 = objc_opt_new();
    [v8 addObject:v32];

    int v12 = (void *)v18;
  }
  if (v12)
  {
    if (v9) {
      long long v33 = v9;
    }
    else {
      long long v33 = v6;
    }
    id v34 = v33;
    if ([v8 count]) {
      long long v35 = [[ARParentTechnique alloc] initWithTechniques:v8];
    }
    else {
      long long v35 = (ARParentTechnique *)objc_opt_new();
    }
    int v36 = v35;
    id v37 = v6;
    uint64_t v38 = [v34 splitTechniques];
    double v39 = [v38 arrayByAddingObject:v36];
    [v34 setSplitTechniques:v39];

    if (ARDeviceSupportsUltraWideCamera()) {
      double v40 = [[ARSyncedUltraWideForwardingStrategy alloc] initWithMaxFrameRate:a5];
    }
    else {
      double v40 = [[ARFrameRateLimitingStrategy alloc] initWithFrameRate:10];
    }
    double v41 = v40;
    [v34 setSplitTechniqueFowardingStrategy:v40];

    double v42 = [[ARSplitTechniqueSynchronizerTechnique alloc] initWithSynchronizedResultDataClasses:v12];
    [(ARTechnique *)v36 setDelegate:v42];
    [v7 insertObject:v42 atIndex:0];

    id v6 = v37;
  }
  if (a3)
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      id v43 = v9;
      int v44 = ARDeviceSupportsUltraWideCamera();
      int v45 = [v43 splitTechniqueFowardingStrategy];
      double v46 = v45;
      if (v44)
      {
        if (!v45)
        {
          double v47 = [[ARSyncedUltraWideForwardingStrategy alloc] initWithMaxFrameRate:a5];
LABEL_30:
          double v48 = v47;

          [v43 setDepthTechniqueProcessingStrategy:v48];
          double v49 = [v43 splitTechniqueFowardingStrategy];
          uint64_t v50 = v49;
          if (v49) {
            uint64_t v51 = v49;
          }
          else {
            uint64_t v51 = [[ARSyncedUltraWideForwardingStrategy alloc] initWithMaxFrameRate:a5];
          }
          uint64_t v52 = v51;

          [v43 setDepthTechniqueProcessingStrategy:v52];
          goto LABEL_34;
        }
      }
      else if (!v45)
      {
        double v47 = [[ARFrameRateLimitingStrategy alloc] initWithFrameRate:10];
        goto LABEL_30;
      }
      double v47 = v45;
      goto LABEL_30;
    }
  }
LABEL_34:
}

void __ARAddJasperTechniquesToParent_block_invoke(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v4 = a2 - 1;
  if ((unint64_t)(a2 - 1) > 3)
  {
    uint64_t v5 = 0;
    uint64_t v6 = 0;
  }
  else
  {
    uint64_t v5 = qword_1B8A2E9F8[v4];
    uint64_t v6 = qword_1B8A2EA18[v4];
  }
  *a4 = v5;
  *a3 = v6;
}

id _ARLogSensor_2()
{
  if (_ARLogSensor_onceToken_5 != -1) {
    dispatch_once(&_ARLogSensor_onceToken_5, &__block_literal_global_224);
  }
  uint64_t v0 = (void *)_ARLogSensor_logObj_5;
  return v0;
}

id _ARLogTechnique_2()
{
  if (_ARLogTechnique_onceToken_4 != -1) {
    dispatch_once(&_ARLogTechnique_onceToken_4, &__block_literal_global_273);
  }
  uint64_t v0 = (void *)_ARLogTechnique_logObj_4;
  return v0;
}

void sub_1B8901358(_Unwind_Exception *a1)
{
  objc_destroyWeak((id *)(v1 - 72));
  _Unwind_Resume(a1);
}

void arkit::computeBoundingBoxes(uint64_t a1, void *a2, char **a3, uint64_t *a4, uint64x2_t *a5)
{
  uint64_t v80 = *MEMORY[0x1E4F143B8];
  id v9 = a2;
  unint64_t v11 = *(void *)(a1 + 8);
  unint64_t v10 = *(void *)(a1 + 16);
  id v67 = v9;
  int v12 = [v9 detectedObjects];
  std::vector<arkit::IntRect>::reserve((void **)a3, [v12 count]);

  long long v77 = 0u;
  long long v78 = 0u;
  long long v75 = 0u;
  long long v76 = 0u;
  id v13 = [v67 detectedObjects];
  unsigned int v66 = a4;
  uint64_t v14 = [v13 countByEnumeratingWithState:&v75 objects:v79 count:16];
  if (v14)
  {
    double v15 = (double)v10;
    uint64_t v16 = *(void *)v76;
    double v17 = (double)v11;
    do
    {
      for (uint64_t i = 0; i != v14; ++i)
      {
        if (*(void *)v76 != v16) {
          objc_enumerationMutation(v13);
        }
        [*(id *)(*((void *)&v75 + 1) + 8 * i) boundingBox];
        v21.i64[0] = vcvtpd_u64_f64(v19 * v15);
        v21.i64[1] = vcvtpd_u64_f64(v20 * v17);
        unint64_t v24 = vcvtpd_u64_f64((v20 + v23) * v17);
        v25.i64[0] = vcvtpd_u64_f64((v19 + v22) * v15);
        v25.i64[1] = v24;
        id v27 = (int8x16_t *)a3[1];
        unint64_t v26 = (unint64_t)a3[2];
        if ((unint64_t)v27 >= v26)
        {
          uint64_t v29 = ((char *)v27 - *a3) >> 5;
          unint64_t v30 = v29 + 1;
          if ((unint64_t)(v29 + 1) >> 59) {
            std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
          }
          int8x16_t v68 = v25;
          int8x16_t v69 = v21;
          uint64_t v31 = v26 - (void)*a3;
          if (v31 >> 4 > v30) {
            unint64_t v30 = v31 >> 4;
          }
          if ((unint64_t)v31 >= 0x7FFFFFFFFFFFFFE0) {
            unint64_t v32 = 0x7FFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v32 = v30;
          }
          long long v33 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<arkit::IntRect>>((uint64_t)(a3 + 2), v32);
          long long v35 = (int8x16_t *)&v33[32 * v29];
          int8x16_t v25 = v68;
          int8x16_t v21 = v69;
          *long long v35 = v69;
          v35[1] = v68;
          id v37 = *a3;
          int v36 = a3[1];
          uint64_t v38 = v35;
          if (v36 != *a3)
          {
            do
            {
              int8x16_t v39 = *((int8x16_t *)v36 - 1);
              v38[-2] = *((int8x16_t *)v36 - 2);
              v38[-1] = v39;
              v38 -= 2;
              v36 -= 32;
            }
            while (v36 != v37);
            int v36 = *a3;
          }
          unint64_t v28 = v35 + 2;
          *a3 = (char *)v38;
          a3[1] = v35[2].i8;
          a3[2] = &v33[32 * v34];
          if (v36)
          {
            operator delete(v36);
            int8x16_t v25 = v68;
            int8x16_t v21 = v69;
          }
        }
        else
        {
          int8x16_t *v27 = v21;
          v27[1] = v25;
          unint64_t v28 = v27 + 2;
        }
        a3[1] = (char *)v28;
        int8x16_t v40 = vbslq_s8((int8x16_t)vcgtq_u64(a5[1], (uint64x2_t)v25), (int8x16_t)a5[1], v25);
        *(int8x16_t *)a5 = vbslq_s8((int8x16_t)vcgtq_u64(*a5, (uint64x2_t)v21), v21, *(int8x16_t *)a5);
        a5[1] = (uint64x2_t)v40;
      }
      uint64_t v14 = [v13 countByEnumeratingWithState:&v75 objects:v79 count:16];
    }
    while (v14);
  }

  std::vector<arkit::BoundingBoxGroup>::reserve(v66, (unint64_t)((a3[1] - *a3) >> 5) >> 1);
  __p = 0;
  int v71 = 0;
  uint64_t v72 = 0;
  v41.i64[0] = -1;
  v41.i64[1] = -1;
  int8x16_t v73 = v41;
  int8x16_t v74 = 0uLL;
  std::vector<arkit::BoundingBoxGroup::Element>::reserve(&__p, (a3[1] - *a3) >> 5);
  double v42 = (uint64x2_t *)*a3;
  id v43 = a3[1];
  if (*a3 != v43)
  {
    do
    {
      uint64_t v45 = *v66;
      uint64_t v44 = v66[1];
      if (*v66 != v44)
      {
        while (1)
        {
          double v46 = *(uint64x2_t **)v45;
          double v47 = *(uint64x2_t **)(v45 + 8);
          if (*(uint64x2_t **)v45 != v47) {
            break;
          }
LABEL_26:
          v45 += 64;
          if (v45 == v44) {
            goto LABEL_30;
          }
        }
        while (1)
        {
          int64x2_t v48 = (int64x2_t)vorrq_s8(vandq_s8((int8x16_t)vcgeq_u64(*v42, v46[1]), (int8x16_t)vcgtq_u64(*v42, *v46)), vandq_s8((int8x16_t)vcgeq_u64(*v46, v42[1]), (int8x16_t)vcgtq_u64(*v46, *v42)));
          if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v48, 1), (int8x16_t)v48).u64[0] & 0x8000000000000000) == 0) {
            break;
          }
          v46 += 7;
          if (v46 == v47) {
            goto LABEL_26;
          }
        }
      }
      if (v45 == v44)
      {
LABEL_30:
        if (&v42[2] == (uint64x2_t *)v43) {
          goto LABEL_50;
        }
        uint64_t v51 = v42 + 2;
        while (1)
        {
          uint64x2_t v52 = v51[1];
          int64x2_t v53 = (int64x2_t)vorrq_s8(vandq_s8((int8x16_t)vcgeq_u64(*v42, v52), (int8x16_t)vcgtq_u64(*v42, *v51)), vandq_s8((int8x16_t)vcgeq_u64(*v51, v42[1]), (int8x16_t)vcgtq_u64(*v51, *v42)));
          if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v53, 1), (int8x16_t)v53).u64[0] & 0x8000000000000000) == 0) {
            break;
          }
          float v54 = (uint64x2_t *)__p;
          if (__p != v71)
          {
            do
            {
              int64x2_t v55 = (int64x2_t)vorrq_s8(vandq_s8((int8x16_t)vcgeq_u64(*v51, v54[1]), (int8x16_t)vcgtq_u64(*v51, *v54)), vandq_s8((int8x16_t)vcgeq_u64(*v54, v52), (int8x16_t)vcgtq_u64(*v54, *v51)));
              if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v55, 1), (int8x16_t)v55).u64[0] & 0x8000000000000000) == 0) {
                goto LABEL_38;
              }
              v54 += 7;
            }
            while (v54 != v71);
          }
          v51 += 2;
          if (v51 == (uint64x2_t *)v43) {
            goto LABEL_50;
          }
        }
LABEL_38:
        std::vector<arkit::BoundingBoxGroup::Element>::emplace_back<arkit::IntRect const&>(&__p, v51);
        int8x16_t v73 = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v73, *v51), *(int8x16_t *)v51, v73);
        int8x16_t v74 = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v74, v51[1]), v74, (int8x16_t)v51[1]);
        if (v51 == (uint64x2_t *)v43)
        {
LABEL_50:
          uint64_t v50 = v43;
        }
        else
        {
          long long v56 = v51 + 2;
          if (&v51[2] == (uint64x2_t *)v43)
          {
            uint64_t v50 = (char *)v51;
          }
          else
          {
            uint64_t v50 = (char *)v51;
            do
            {
              uint64x2_t v57 = v51[2];
              uint64x2_t v58 = v51[3];
              id v59 = v56;
              int64x2_t v60 = (int64x2_t)vorrq_s8(vandq_s8((int8x16_t)vcgeq_u64(v57, v42[1]), (int8x16_t)vcgtq_u64(v57, *v42)), vandq_s8((int8x16_t)vcgeq_u64(*v42, v58), (int8x16_t)vcgtq_u64(*v42, v57)));
              if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v60, 1), (int8x16_t)v60).u64[0] & 0x8000000000000000) != 0)
              {
                for (unsigned int j = (uint64x2_t *)__p; j != v71; j += 7)
                {
                  int64x2_t v63 = (int64x2_t)vorrq_s8(vandq_s8((int8x16_t)vcgeq_u64(v57, j[1]), (int8x16_t)vcgtq_u64(v57, *j)), vandq_s8((int8x16_t)vcgeq_u64(*j, v58), (int8x16_t)vcgtq_u64(*j, v57)));
                  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v63, 1), (int8x16_t)v63).u64[0] & 0x8000000000000000) == 0) {
                    goto LABEL_42;
                  }
                }
                uint64x2_t v64 = v59[1];
                *(uint64x2_t *)uint64_t v50 = *v59;
                *((uint64x2_t *)v50 + 1) = v64;
                v50 += 32;
              }
              else
              {
LABEL_42:
                std::vector<arkit::BoundingBoxGroup::Element>::emplace_back<arkit::IntRect const&>(&__p, v59);
                int8x16_t v61 = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v74, v51[3]), v74, (int8x16_t)v51[3]);
                int8x16_t v73 = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v73, *v59), *(int8x16_t *)v59, v73);
                int8x16_t v74 = v61;
              }
              long long v56 = v59 + 2;
              uint64_t v51 = v59;
            }
            while (&v59[2] != (uint64x2_t *)v43);
          }
        }
        if (v71 == __p)
        {
          v42 += 2;
        }
        else
        {
          std::vector<arkit::BoundingBoxGroup::Element>::emplace_back<arkit::IntRect const&>(&__p, v42);
          int8x16_t v73 = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v73, *v42), *(int8x16_t *)v42, v73);
          int8x16_t v74 = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v74, v42[1]), v74, (int8x16_t)v42[1]);
          uint64_t v50 = std::__rotate[abi:ne180100]<std::_ClassicAlgPolicy,std::__wrap_iter<arkit::IntRect *>,std::__wrap_iter<arkit::IntRect *>>(v42->i8, v42[2].i8, v50);
          std::vector<arkit::BoundingBoxGroup>::push_back[abi:ne180100](v66, (uint64_t)&__p);
          int v71 = __p;
          v65.i64[0] = -1;
          v65.i64[1] = -1;
          int8x16_t v73 = v65;
          int8x16_t v74 = 0uLL;
        }
      }
      else
      {
        std::vector<arkit::BoundingBoxGroup::Element>::emplace_back<arkit::IntRect const&>((void **)v45, v42);
        int8x16_t v49 = *(int8x16_t *)(v45 + 48);
        *(int8x16_t *)(v45 + 32) = vbslq_s8((int8x16_t)vcgtq_u64(*(uint64x2_t *)(v45 + 32), *v42), *(int8x16_t *)v42, *(int8x16_t *)(v45 + 32));
        *(int8x16_t *)(v45 + 48) = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v49, v42[1]), v49, (int8x16_t)v42[1]);
        uint64_t v50 = std::__rotate[abi:ne180100]<std::_ClassicAlgPolicy,std::__wrap_iter<arkit::IntRect *>,std::__wrap_iter<arkit::IntRect *>>(v42->i8, v42[2].i8, v43);
      }
      id v43 = v50;
    }
    while (v42 != (uint64x2_t *)v50);
    if (v42 != (uint64x2_t *)a3[1]) {
      a3[1] = (char *)v42;
    }
  }
  if (__p)
  {
    int v71 = __p;
    operator delete(__p);
  }
}

void sub_1B89052A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void std::vector<arkit::IntRect>::reserve(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 5)
  {
    if (a2 >> 59) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    uint64_t v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<arkit::IntRect>>(v3, a2);
    id v7 = &v6[v5 & 0xFFFFFFFFFFFFFFE0];
    id v9 = &v6[32 * v8];
    unint64_t v11 = (char *)*a1;
    unint64_t v10 = (char *)a1[1];
    int v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        long long v13 = *((_OWORD *)v10 - 1);
        *((_OWORD *)v12 - 2) = *((_OWORD *)v10 - 2);
        *((_OWORD *)v12 - 1) = v13;
        v12 -= 32;
        v10 -= 32;
      }
      while (v10 != v11);
      unint64_t v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

uint64_t std::vector<arkit::BoundingBoxGroup>::reserve(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  if (a2 > (v4 - *a1) >> 6)
  {
    if (a2 >> 58) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v5 = a1[1] - *a1;
    v7[4] = result;
    v7[0] = std::__allocate_at_least[abi:ne180100]<std::allocator<arkit::BoundingBoxGroup>>(result, a2);
    v7[1] = v7[0] + v5;
    v7[2] = v7[0] + v5;
    v7[3] = v7[0] + (v6 << 6);
    std::vector<arkit::BoundingBoxGroup>::__swap_out_circular_buffer(a1, v7);
    return std::__split_buffer<arkit::BoundingBoxGroup>::~__split_buffer((uint64_t)v7);
  }
  return result;
}

void sub_1B8905448(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<arkit::BoundingBoxGroup>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::vector<arkit::BoundingBoxGroup::Element>::reserve(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (0x6DB6DB6DB6DB6DB7 * ((v4 - (unsigned char *)*a1) >> 4) < a2)
  {
    if (a2 >= 0x24924924924924ALL) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v5 = ((unsigned char *)a1[1] - (unsigned char *)*a1) / 112;
    uint64_t v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<arkit::BoundingBoxGroup::Element>>(v3, a2);
    id v7 = &v6[112 * v5];
    id v9 = &v6[112 * v8];
    unint64_t v11 = (char *)*a1;
    unint64_t v10 = (char *)a1[1];
    int v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        long long v13 = *((_OWORD *)v10 - 7);
        long long v14 = *((_OWORD *)v10 - 5);
        *((_OWORD *)v12 - 6) = *((_OWORD *)v10 - 6);
        *((_OWORD *)v12 - 5) = v14;
        *((_OWORD *)v12 - 7) = v13;
        long long v15 = *((_OWORD *)v10 - 4);
        long long v16 = *((_OWORD *)v10 - 3);
        long long v17 = *((_OWORD *)v10 - 1);
        *((_OWORD *)v12 - 2) = *((_OWORD *)v10 - 2);
        *((_OWORD *)v12 - 1) = v17;
        *((_OWORD *)v12 - 4) = v15;
        *((_OWORD *)v12 - 3) = v16;
        v12 -= 112;
        v10 -= 112;
      }
      while (v10 != v11);
      unint64_t v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

uint64_t std::vector<arkit::BoundingBoxGroup>::push_back[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(result - 8);
  if (v7 >= v6)
  {
    uint64_t v10 = (uint64_t)(v7 - *a1) >> 6;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 58) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v12 = v5 - *a1;
    if (v12 >> 5 > v11) {
      unint64_t v11 = v12 >> 5;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFC0) {
      unint64_t v13 = 0x3FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    v17[4] = result;
    if (v13) {
      long long v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<arkit::BoundingBoxGroup>>(result, v13);
    }
    else {
      long long v14 = 0;
    }
    long long v15 = &v14[64 * v10];
    v17[0] = v14;
    v17[1] = v15;
    v17[3] = &v14[64 * v13];
    *(void *)long long v15 = 0;
    *((void *)v15 + 1) = 0;
    *((void *)v15 + 2) = 0;
    *(_OWORD *)long long v15 = *(_OWORD *)a2;
    *((void *)v15 + 2) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    long long v16 = *(_OWORD *)(a2 + 48);
    *((_OWORD *)v15 + 2) = *(_OWORD *)(a2 + 32);
    *((_OWORD *)v15 + 3) = v16;
    void v17[2] = v15 + 64;
    std::vector<arkit::BoundingBoxGroup>::__swap_out_circular_buffer(a1, v17);
    uint64_t v9 = a1[1];
    uint64_t result = std::__split_buffer<arkit::BoundingBoxGroup>::~__split_buffer((uint64_t)v17);
  }
  else
  {
    *(void *)unint64_t v7 = 0;
    *(void *)(v7 + 8) = 0;
    *(void *)(v7 + 16) = 0;
    *(_OWORD *)unint64_t v7 = *(_OWORD *)a2;
    *(void *)(v7 + 16) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    long long v8 = *(_OWORD *)(a2 + 48);
    *(_OWORD *)(v7 + 32) = *(_OWORD *)(a2 + 32);
    *(_OWORD *)(v7 + 48) = v8;
    uint64_t v9 = v7 + 64;
    a1[1] = v7 + 64;
  }
  a1[1] = v9;
  return result;
}

void sub_1B8905694(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<arkit::BoundingBoxGroup>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B8905810(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B890588C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)ARPersonOcclusionTechnique;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1B8906310(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1B89073F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,void *__p,uint64_t a33)
{
  *(void *)(v34 - 176) = &a29;
  std::vector<arkit::BoundingBoxGroup>::__destroy_vector::operator()[abi:ne180100]((void ***)(v34 - 176));
  if (__p)
  {
    a33 = (uint64_t)__p;
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

float *arkit::RobustExpFilter<float>::filter(uint64_t a1, float *a2, size_t a3)
{
  uint64_t result = *(float **)a1;
  unint64_t v6 = *(float **)(a1 + 8);
  unint64_t v8 = v6 - result;
  if (v8 == a3 >> 2)
  {
    if (v6 == result)
    {
      return v6;
    }
    else
    {
      uint64_t v9 = 0;
      uint64_t v10 = *(void *)(a1 + 24);
      do
      {
        float v11 = result[v9];
        float v12 = (float)((float)(v11 + (float)(*(float *)(a1 + 72) * *(float *)(v10 + 4 * v9))) * 0.7)
            + (float)(a2[v9] * 0.3);
        result[v9] = v12;
        *(float *)(v10 + 4 * v9) = (float)((float)(1.0 - *(float *)(a1 + 88)) * *(float *)(v10 + 4 * v9))
                                 + (float)(*(float *)(a1 + 88) * (float)(v12 - v11));
        ++v9;
      }
      while (v8 > v9);
    }
  }
  else
  {
    unint64_t v14 = a3 >> 2;
    std::vector<float>::resize(a1, a3 >> 2);
    memcpy(*(void **)a1, a2, a3);
    int v15 = 0;
    std::vector<float>::resize(a1 + 24, v14, &v15);
    return *(float **)a1;
  }
  return result;
}

void *arkit::fillInstanceDepthBufferOutsideAllDetections(void *result, unsigned __int8 **a2, void *a3, uint64_t *a4)
{
  unint64_t v4 = a4[1];
  if (v4)
  {
    unint64_t v5 = 0;
    unint64_t v6 = *a2;
    unint64_t v7 = (_DWORD *)*result;
    uint64_t v8 = result[3];
    uint64_t v9 = (_DWORD *)*a3;
    uint64_t v10 = a3[3];
    float v12 = a2[2];
    float v11 = a2[3];
    do
    {
      if (v12)
      {
        unint64_t v13 = v6;
        unint64_t v14 = v7;
        int v15 = v9;
        long long v16 = v12;
        do
        {
          if (*v13++) {
            _DWORD *v15 = *v14;
          }
          ++v15;
          ++v14;
          --v16;
        }
        while (v16);
        unint64_t v4 = a4[1];
      }
      ++v5;
      uint64_t v9 = (_DWORD *)((char *)v9 + v10);
      unint64_t v7 = (_DWORD *)((char *)v7 + v8);
      unint64_t v6 = &v11[(void)v6];
    }
    while (v4 > v5);
  }
  unint64_t v18 = a4[3];
  if (v4 < v18)
  {
    uint64_t v19 = result[3];
    uint64_t v20 = a3[3];
    double v22 = a2[2];
    int8x16_t v21 = a2[3];
    double v23 = (_DWORD *)(*a3 + v4 * v20);
    unint64_t v24 = (_DWORD *)(*result + v4 * v19);
    int8x16_t v25 = &(*a2)[v4 * (void)v21];
    do
    {
      uint64_t v26 = *a4;
      if (*a4)
      {
        id v27 = v25;
        unint64_t v28 = v24;
        uint64_t v29 = v23;
        do
        {
          if (*v27++) {
            *uint64_t v29 = *v28;
          }
          ++v29;
          ++v28;
          --v26;
        }
        while (v26);
      }
      unint64_t v31 = a4[2];
      if (v31 >= (unint64_t)v22)
      {
        unint64_t v18 = a4[3];
      }
      else
      {
        do
        {
          if (v25[v31]) {
            v23[v31] = v24[v31];
          }
          ++v31;
        }
        while (v22 != (unsigned __int8 *)v31);
        unint64_t v18 = a4[3];
      }
      ++v4;
      double v23 = (_DWORD *)((char *)v23 + v20);
      unint64_t v24 = (_DWORD *)((char *)v24 + v19);
      int8x16_t v25 = &v21[(void)v25];
    }
    while (v4 < v18);
  }
  unint64_t v32 = a2[1];
  if (v18 < (unint64_t)v32)
  {
    uint64_t v33 = result[3];
    uint64_t v34 = a3[3];
    int v36 = a2[2];
    long long v35 = a2[3];
    id v37 = (_DWORD *)(*a3 + v18 * v34);
    uint64_t v38 = (void *)(*result + v18 * v33);
    int8x16_t v39 = &(*a2)[v18 * (void)v35];
    do
    {
      if (v36)
      {
        int8x16_t v40 = v39;
        uint64_t result = v38;
        int8x16_t v41 = v37;
        double v42 = v36;
        do
        {
          if (*v40++) {
            *int8x16_t v41 = *(_DWORD *)result;
          }
          ++v41;
          uint64_t result = (void *)((char *)result + 4);
          --v42;
        }
        while (v42);
      }
      ++v18;
      id v37 = (_DWORD *)((char *)v37 + v34);
      uint64_t v38 = (void *)((char *)v38 + v33);
      int8x16_t v39 = &v35[(void)v39];
    }
    while ((unsigned __int8 *)v18 != v32);
  }
  return result;
}

void sub_1B8907A1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8907B3C(_Unwind_Exception *a1)
{
  unint64_t v6 = v4;

  _Unwind_Resume(a1);
}

char *std::vector<arkit::BoundingBoxGroup::Element>::emplace_back<arkit::IntRect const&>(void **a1, _OWORD *a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= (unint64_t)v6)
  {
    uint64_t v10 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v7 - (void)*a1) >> 4);
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) > 0x249249249249249) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v12 = 0x6DB6DB6DB6DB6DB7 * ((v5 - (unsigned char *)*a1) >> 4);
    if (2 * v12 > v11) {
      unint64_t v11 = 2 * v12;
    }
    if (v12 >= 0x124924924924924) {
      unint64_t v13 = 0x249249249249249;
    }
    else {
      unint64_t v13 = v11;
    }
    unint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<arkit::BoundingBoxGroup::Element>>(v4, v13);
    long long v15 = a2[1];
    long long v16 = &v14[112 * v10];
    *(_OWORD *)long long v16 = *a2;
    *((_OWORD *)v16 + 1) = v15;
    unint64_t v18 = &v14[112 * v17];
    *((_DWORD *)v16 + 8) = 0;
    *((void *)v16 + 5) = 0;
    *((_DWORD *)v16 + 12) = 0;
    *((void *)v16 + 7) = 0;
    *((_DWORD *)v16 + 16) = 2139095039;
    *((_DWORD *)v16 + 18) = 0;
    *((void *)v16 + 10) = 0;
    *((_DWORD *)v16 + 22) = 0;
    *((void *)v16 + 12) = 0;
    *((_DWORD *)v16 + 26) = 2139095039;
    uint64_t v9 = v16 + 112;
    uint64_t v20 = (char *)*a1;
    uint64_t v19 = (char *)a1[1];
    if (v19 != *a1)
    {
      do
      {
        long long v21 = *((_OWORD *)v19 - 7);
        long long v22 = *((_OWORD *)v19 - 5);
        *((_OWORD *)v16 - 6) = *((_OWORD *)v19 - 6);
        *((_OWORD *)v16 - 5) = v22;
        *((_OWORD *)v16 - 7) = v21;
        long long v23 = *((_OWORD *)v19 - 4);
        long long v24 = *((_OWORD *)v19 - 3);
        long long v25 = *((_OWORD *)v19 - 1);
        *((_OWORD *)v16 - 2) = *((_OWORD *)v19 - 2);
        *((_OWORD *)v16 - 1) = v25;
        *((_OWORD *)v16 - 4) = v23;
        *((_OWORD *)v16 - 3) = v24;
        v16 -= 112;
        v19 -= 112;
      }
      while (v19 != v20);
      uint64_t v19 = (char *)*a1;
    }
    *a1 = v16;
    a1[1] = v9;
    a1[2] = v18;
    if (v19) {
      operator delete(v19);
    }
  }
  else
  {
    long long v8 = a2[1];
    *(_OWORD *)unint64_t v7 = *a2;
    *(_OWORD *)(v7 + 16) = v8;
    *(_DWORD *)(v7 + 32) = 0;
    *(void *)(v7 + 40) = 0;
    *(_DWORD *)(v7 + 48) = 0;
    *(void *)(v7 + 56) = 0;
    *(_DWORD *)(v7 + 64) = 2139095039;
    *(_DWORD *)(v7 + 72) = 0;
    *(void *)(v7 + 80) = 0;
    *(_DWORD *)(v7 + 88) = 0;
    *(_DWORD *)(v7 + 104) = 2139095039;
    uint64_t v9 = (char *)(v7 + 112);
    *(void *)(v7 + 96) = 0;
  }
  a1[1] = v9;
  return v9 - 112;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<arkit::BoundingBoxGroup::Element>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x24924924924924ALL) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(112 * a2);
}

void ___ZL15_ARLogTechniquev_block_invoke_1()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "Technique");
  uint64_t v1 = (void *)_ARLogTechnique(void)::logObj;
  _ARLogTechnique(void)::logObunsigned int j = (uint64_t)v0;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<arkit::IntRect>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 59) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(32 * a2);
}

uint64_t std::vector<arkit::BoundingBoxGroup>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<arkit::BoundingBoxGroup>,std::reverse_iterator<arkit::BoundingBoxGroup*>,std::reverse_iterator<arkit::BoundingBoxGroup*>,std::reverse_iterator<arkit::BoundingBoxGroup*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<arkit::BoundingBoxGroup>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 58) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(a2 << 6);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<arkit::BoundingBoxGroup>,std::reverse_iterator<arkit::BoundingBoxGroup*>,std::reverse_iterator<arkit::BoundingBoxGroup*>,std::reverse_iterator<arkit::BoundingBoxGroup*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  void v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    do
    {
      *(void *)(v7 - 64) = 0;
      *(void *)(v7 - 56) = 0;
      *(void *)(v7 - 48) = 0;
      long long v8 = *(_OWORD *)(a3 - 64);
      a3 -= 64;
      *(_OWORD *)(v7 - 64) = v8;
      *(void *)(v7 - 48) = *(void *)(a3 + 16);
      *(void *)a3 = 0;
      *(void *)(a3 + 8) = 0;
      *(void *)(a3 + 16) = 0;
      long long v9 = *(_OWORD *)(a3 + 48);
      *(_OWORD *)(v7 - 32) = *(_OWORD *)(a3 + 32);
      *(_OWORD *)(v7 - 16) = v9;
      uint64_t v7 = *((void *)&v15 + 1) - 64;
      *((void *)&v15 + 1) -= 64;
    }
    while (a3 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<arkit::BoundingBoxGroup>,std::reverse_iterator<arkit::BoundingBoxGroup*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<arkit::BoundingBoxGroup>,std::reverse_iterator<arkit::BoundingBoxGroup*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<arkit::BoundingBoxGroup>,std::reverse_iterator<arkit::BoundingBoxGroup*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<arkit::BoundingBoxGroup>,std::reverse_iterator<arkit::BoundingBoxGroup*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    uint64_t v3 = *(void **)v1;
    if (*(void *)v1)
    {
      *(void *)(v1 + 8) = v3;
      operator delete(v3);
    }
    v1 += 64;
  }
}

uint64_t std::__split_buffer<arkit::BoundingBoxGroup>::~__split_buffer(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__split_buffer<arkit::BoundingBoxGroup>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != a2)
  {
    uint64_t v5 = *(void **)(v2 - 64);
    *(void *)(a1 + 16) = v2 - 64;
    if (v5)
    {
      *(void *)(v2 - 56) = v5;
      operator delete(v5);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 64;
    }
  }
}

char *std::__rotate[abi:ne180100]<std::_ClassicAlgPolicy,std::__wrap_iter<arkit::IntRect *>,std::__wrap_iter<arkit::IntRect *>>(char *__src, char *a2, char *a3)
{
  uint64_t v4 = a3;
  if (__src != a2)
  {
    if (a2 == a3)
    {
      return __src;
    }
    else if (__src + 32 == a2)
    {
      long long v9 = *(_OWORD *)__src;
      long long v11 = *((_OWORD *)__src + 1);
      int64_t v6 = a3 - a2;
      memmove(__src, a2, a3 - a2);
      uint64_t v4 = &__src[v6];
      *(_OWORD *)uint64_t v4 = v9;
      *((_OWORD *)v4 + 1) = v11;
    }
    else if (a2 + 32 == a3)
    {
      uint64_t v4 = __src + 32;
      long long v10 = *((_OWORD *)a3 - 2);
      long long v12 = *((_OWORD *)a3 - 1);
      size_t v7 = a3 - 32 - __src;
      if (a3 - 32 != __src) {
        memmove(__src + 32, __src, v7);
      }
      *(_OWORD *)__vImage_Buffer src = v10;
      *((_OWORD *)__src + 1) = v12;
    }
    else
    {
      return std::__rotate_gcd[abi:ne180100]<std::_ClassicAlgPolicy,std::__wrap_iter<arkit::IntRect *>>(__src, a2, a3);
    }
  }
  return v4;
}

char *std::__rotate_gcd[abi:ne180100]<std::_ClassicAlgPolicy,std::__wrap_iter<arkit::IntRect *>>(char *a1, char *a2, char *a3)
{
  uint64_t v3 = (a2 - a1) >> 5;
  if (v3 == (a3 - a2) >> 5)
  {
    if (a1 != a2 && a2 != a3)
    {
      uint64_t v4 = a1 + 32;
      uint64_t v5 = a2 + 32;
      do
      {
        long long v7 = *((_OWORD *)v4 - 2);
        long long v6 = *((_OWORD *)v4 - 1);
        long long v8 = *((_OWORD *)v5 - 1);
        *((_OWORD *)v4 - 2) = *((_OWORD *)v5 - 2);
        *((_OWORD *)v4 - 1) = v8;
        *((_OWORD *)v5 - 2) = v7;
        *((_OWORD *)v5 - 1) = v6;
        if (v4 == a2) {
          break;
        }
        v4 += 32;
        BOOL v9 = v5 == a3;
        v5 += 32;
      }
      while (!v9);
    }
  }
  else
  {
    uint64_t v10 = (a3 - a2) >> 5;
    uint64_t v11 = (a2 - a1) >> 5;
    do
    {
      uint64_t v12 = v11;
      uint64_t v11 = v10;
      uint64_t v10 = v12 % v10;
    }
    while (v10);
    if (v11)
    {
      char v13 = &a1[32 * v11];
      do
      {
        long long v14 = *((_OWORD *)v13 - 2);
        long long v15 = *((_OWORD *)v13 - 1);
        v13 -= 32;
        long long v26 = v15;
        long long v16 = &v13[32 * v3];
        uint64_t v17 = v13;
        do
        {
          unint64_t v18 = v16;
          long long v19 = *((_OWORD *)v16 + 1);
          *(_OWORD *)uint64_t v17 = *(_OWORD *)v16;
          *((_OWORD *)v17 + 1) = v19;
          uint64_t v20 = a3 - v16;
          v16 += 32 * v3;
          BOOL v21 = __OFSUB__(v3, v20 >> 5);
          uint64_t v23 = v3 - (v20 >> 5);
          char v22 = (v23 < 0) ^ v21;
          long long v24 = &a1[32 * v23];
          if (!v22) {
            long long v16 = v24;
          }
          uint64_t v17 = v18;
        }
        while (v16 != v13);
        *(_OWORD *)unint64_t v18 = v14;
        *((_OWORD *)v18 + 1) = v26;
      }
      while (v13 != a1);
    }
    return &a1[32 * ((a3 - a2) >> 5)];
  }
  return a2;
}

void *std::allocate_shared[abi:ne180100]<arkit::RobustExpFilter<float>,std::allocator<arkit::RobustExpFilter<float>>,double,double,double,double,double,double,double,double,void>@<X0>(double *a1@<X1>, double *a2@<X2>, double *a3@<X3>, double *a4@<X4>, double *a5@<X5>, uint64_t a6@<X6>, double *a7@<X7>, void *a8@<X8>, double *a9)
{
  uint64_t v17 = operator new(0x78uLL);
  uint64_t result = std::__shared_ptr_emplace<arkit::RobustExpFilter<float>>::__shared_ptr_emplace[abi:ne180100]<double,double,double,double,double,double,double,double,std::allocator<arkit::RobustExpFilter<float>>,0>(v17, a1, a2, a3, a4, a5, a6, a7, a9);
  *a8 = v17 + 3;
  a8[1] = v17;
  return result;
}

void sub_1B89082E4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<arkit::RobustExpFilter<float>>::__shared_ptr_emplace[abi:ne180100]<double,double,double,double,double,double,double,double,std::allocator<arkit::RobustExpFilter<float>>,0>(void *a1, double *a2, double *a3, double *a4, double *a5, double *a6, uint64_t a7, double *a8, double *a9)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F12099D0;
  std::allocator<arkit::RobustExpFilter<float>>::construct[abi:ne180100]<arkit::RobustExpFilter<float>,double,double,double,double,double,double,double,double>((uint64_t)&v11, (uint64_t)(a1 + 3), a2, a3, a4, a5, a6, a7, a8, a9);
  return a1;
}

void sub_1B8908374(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<arkit::RobustExpFilter<float>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F12099D0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<arkit::RobustExpFilter<float>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F12099D0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BA9C56C0);
}

void std::__shared_ptr_emplace<arkit::RobustExpFilter<float>>::__on_zero_shared(uint64_t a1)
{
  std::allocator<arkit::RobustExpFilter<float>>::destroy[abi:ne180100]((uint64_t)&v1, a1 + 24);
}

float std::allocator<arkit::RobustExpFilter<float>>::construct[abi:ne180100]<arkit::RobustExpFilter<float>,double,double,double,double,double,double,double,double>(uint64_t a1, uint64_t a2, double *a3, double *a4, double *a5, double *a6, double *a7, uint64_t a8, double *a9, double *a10)
{
  float v10 = *a3;
  float v11 = *a4;
  float v12 = *a5;
  float v13 = *a6;
  float v14 = *a7;
  float v15 = *a9;
  float v16 = *a10;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  *(float *)(a2 + 48) = v10;
  *(float *)(a2 + 52) = v11;
  *(float *)(a2 + 56) = v12;
  *(float *)(a2 + 60) = v13;
  *(float *)(a2 + 64) = v14;
  *(float *)(a2 + 68) = v15;
  *(float *)(a2 + 72) = v15;
  *(float *)(a2 + 76) = v16;
  float v17 = v12 - v11;
  float v18 = 1.0 / (float)(v12 - v11);
  BOOL v19 = v17 < 0.000001;
  float v20 = 1000000.0;
  if (v19) {
    float v18 = 1000000.0;
  }
  float v21 = v14 - v13;
  if (v21 >= 0.000001) {
    float v20 = 1.0 / v21;
  }
  *(float *)(a2 + 80) = v18;
  *(float *)(a2 + 84) = v20;
  float result = 1.0 / (float)(v15 + 1.0);
  *(float *)(a2 + 88) = result;
  return result;
}

void std::allocator<arkit::RobustExpFilter<float>>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void **)(a2 + 24);
  if (v3)
  {
    *(void *)(a2 + 32) = v3;
    operator delete(v3);
  }
  uint64_t v4 = *(void **)a2;
  if (*(void *)a2)
  {
    *(void *)(a2 + 8) = v4;
    operator delete(v4);
  }
}

void std::vector<float>::resize(uint64_t a1, unint64_t a2, _DWORD *a3)
{
  unint64_t v3 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 2;
  if (a2 <= v3)
  {
    if (a2 < v3) {
      *(void *)(a1 + 8) = *(void *)a1 + 4 * a2;
    }
  }
  else
  {
    std::vector<float>::__append((void **)a1, a2 - v3, a3);
  }
}

void std::vector<float>::__append(void **a1, unint64_t a2, _DWORD *a3)
{
  long long v8 = a1[2];
  uint64_t v6 = (uint64_t)(a1 + 2);
  long long v7 = v8;
  BOOL v9 = *(_DWORD **)(v6 - 8);
  if (a2 <= (v8 - (unsigned char *)v9) >> 2)
  {
    if (a2)
    {
      uint64_t v16 = 4 * a2;
      float v17 = &v9[a2];
      do
      {
        *v9++ = *a3;
        v16 -= 4;
      }
      while (v16);
      BOOL v9 = v17;
    }
    a1[1] = v9;
  }
  else
  {
    uint64_t v10 = (char *)v9 - (unsigned char *)*a1;
    unint64_t v11 = a2 + (v10 >> 2);
    if (v11 >> 62) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v12 = v10 >> 2;
    uint64_t v13 = v7 - (unsigned char *)*a1;
    if (v13 >> 1 > v11) {
      unint64_t v11 = v13 >> 1;
    }
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v14 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v11;
    }
    if (v14) {
      float v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v6, v14);
    }
    else {
      float v15 = 0;
    }
    float v18 = &v15[4 * v12];
    BOOL v19 = &v18[4 * a2];
    uint64_t v20 = 4 * a2;
    float v21 = v18;
    do
    {
      *(_DWORD *)float v21 = *a3;
      v21 += 4;
      v20 -= 4;
    }
    while (v20);
    char v22 = &v15[4 * v14];
    uint64_t v23 = (char *)*a1;
    for (uint64_t i = (char *)a1[1]; i != v23; i -= 4)
    {
      int v25 = *((_DWORD *)i - 1);
      *((_DWORD *)v18 - 1) = v25;
      v18 -= 4;
    }
    *a1 = v18;
    a1[1] = v19;
    a1[2] = v22;
    if (v23)
    {
      operator delete(v23);
    }
  }
}

void std::vector<arkit::BoundingBoxGroup>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<arkit::BoundingBoxGroup>::__clear[abi:ne180100]((uint64_t *)v2);
    unint64_t v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<arkit::BoundingBoxGroup>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  if (v2 != *a1)
  {
    uint64_t v4 = a1[1];
    do
    {
      uint64_t v6 = *(void **)(v4 - 64);
      v4 -= 64;
      uint64_t v5 = v6;
      if (v6)
      {
        *(void *)(v2 - 56) = v5;
        operator delete(v5);
      }
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  a1[1] = v3;
}

void sub_1B8908C1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, id a9)
{
  objc_destroyWeak(v9);
  objc_destroyWeak(&a9);
  _Unwind_Resume(a1);
}

void sub_1B89095C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy_(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{
}

void sub_1B8909900(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B8909FD0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1B890A068(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1B890A1DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 64), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__0(uint64_t a1)
{
}

void sub_1B890AAD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  _Block_object_dispose(&a27, 8);
  _Block_object_dispose(&a31, 8);
  _Block_object_dispose((const void *)(v31 - 176), 8);
  _Block_object_dispose((const void *)(v31 - 128), 8);
  _Unwind_Resume(a1);
}

void sub_1B890D780(_Unwind_Exception *a1)
{
  std::__tree<std::array<unsigned char,16ul>>::destroy(v3 - 216, *(void **)(v3 - 208));

  _Unwind_Resume(a1);
}

void sub_1B890D894(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<unsigned long long>::__emplace_unique_key_args<unsigned long long,unsigned long long>(uint64_t **a1, unint64_t *a2, uint64_t *a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    unint64_t v7 = *a2;
    while (1)
    {
      while (1)
      {
        long long v8 = (uint64_t **)v5;
        unint64_t v9 = v5[4];
        if (v7 >= v9) {
          break;
        }
        uint64_t v5 = *v8;
        uint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      uint64_t v5 = v8[1];
      if (!v5)
      {
        uint64_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    long long v8 = a1 + 1;
LABEL_10:
    uint64_t v10 = (uint64_t *)operator new(0x28uLL);
    v10[4] = *a3;
    _ZNSt3__16__treeINS_12__value_typeIyDv4_fEENS_19__map_value_compareIyS3_NS_4lessIyEELb1EEENS_9allocatorIS3_EEE16__insert_node_atEPNS_15__tree_end_nodeIPNS_16__tree_node_baseIPvEEEERSF_SF_(a1, (uint64_t)v8, v6, v10);
    return v10;
  }
  return (uint64_t *)v8;
}

uint64_t *std::set<unsigned long long>::set[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  std::set<unsigned long long>::insert[abi:ne180100]<std::__tree_const_iterator<unsigned long long,std::__tree_node<unsigned long long,void *> *,long>>(a1, *(void **)a2, (void *)(a2 + 8));
  return a1;
}

void sub_1B890D9FC(_Unwind_Exception *a1)
{
  std::__tree<std::array<unsigned char,16ul>>::destroy(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *std::set<unsigned long long>::insert[abi:ne180100]<std::__tree_const_iterator<unsigned long long,std::__tree_node<unsigned long long,void *> *,long>>(uint64_t *result, void *a2, void *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    uint64_t v5 = (uint64_t **)result;
    uint64_t v6 = result + 1;
    do
    {
      float result = std::__tree<unsigned long long>::__emplace_hint_unique_key_args<unsigned long long,unsigned long long const&>(v5, v6, v4 + 4, v4 + 4);
      unint64_t v7 = (void *)v4[1];
      if (v7)
      {
        do
        {
          long long v8 = v7;
          unint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          long long v8 = (void *)v4[2];
          BOOL v9 = *v8 == (void)v4;
          uint64_t v4 = v8;
        }
        while (!v9);
      }
      uint64_t v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *std::__tree<unsigned long long>::__emplace_hint_unique_key_args<unsigned long long,unsigned long long const&>(uint64_t **a1, void *a2, unint64_t *a3, uint64_t *a4)
{
  uint64_t v6 = (uint64_t **)std::__tree<unsigned long long>::__find_equal<unsigned long long>(a1, a2, &v11, &v10, a3);
  unint64_t v7 = *v6;
  if (!*v6)
  {
    long long v8 = v6;
    unint64_t v7 = (uint64_t *)operator new(0x28uLL);
    v7[4] = *a4;
    _ZNSt3__16__treeINS_12__value_typeIyDv4_fEENS_19__map_value_compareIyS3_NS_4lessIyEELb1EEENS_9allocatorIS3_EEE16__insert_node_atEPNS_15__tree_end_nodeIPNS_16__tree_node_baseIPvEEEERSF_SF_(a1, v11, v8, v7);
  }
  return v7;
}

void *std::__tree<unsigned long long>::__find_equal<unsigned long long>(void *a1, void *a2, void *a3, void *a4, unint64_t *a5)
{
  uint64_t v5 = a1 + 1;
  if (a1 + 1 == a2 || (v6 = *a5, unint64_t v7 = a2[4], *a5 < v7))
  {
    uint64_t v8 = *a2;
    if ((void *)*a1 == a2)
    {
      uint64_t v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      BOOL v9 = (void *)*a2;
      do
      {
        uint64_t v10 = v9;
        BOOL v9 = (void *)v9[1];
      }
      while (v9);
    }
    else
    {
      uint64_t v13 = a2;
      do
      {
        uint64_t v10 = (void *)v13[2];
        BOOL v14 = *v10 == (void)v13;
        uint64_t v13 = v10;
      }
      while (v14);
    }
    unint64_t v15 = *a5;
    if (v10[4] < *a5) {
      goto LABEL_17;
    }
    uint64_t v16 = (void *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          float v17 = v16;
          unint64_t v18 = v16[4];
          if (v15 >= v18) {
            break;
          }
          uint64_t v16 = (void *)*v17;
          uint64_t v5 = v17;
          if (!*v17) {
            goto LABEL_29;
          }
        }
        if (v18 >= v15) {
          break;
        }
        uint64_t v5 = v17 + 1;
        uint64_t v16 = (void *)v17[1];
      }
      while (v16);
    }
    else
    {
      float v17 = a1 + 1;
    }
LABEL_29:
    *a3 = v17;
    return v5;
  }
  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = a2;
    return a4;
  }
  uint64_t v11 = a2[1];
  if (v11)
  {
    uint64_t v12 = (void *)a2[1];
    do
    {
      a4 = v12;
      uint64_t v12 = (void *)*v12;
    }
    while (v12);
  }
  else
  {
    BOOL v19 = a2;
    do
    {
      a4 = (void *)v19[2];
      BOOL v14 = *a4 == (void)v19;
      BOOL v19 = a4;
    }
    while (!v14);
  }
  if (a4 != v5 && v6 >= a4[4])
  {
    uint64_t v20 = (void *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          float v21 = v20;
          unint64_t v22 = v20[4];
          if (v6 >= v22) {
            break;
          }
          uint64_t v20 = (void *)*v21;
          uint64_t v5 = v21;
          if (!*v21) {
            goto LABEL_48;
          }
        }
        if (v22 >= v6) {
          break;
        }
        uint64_t v5 = v21 + 1;
        uint64_t v20 = (void *)v21[1];
      }
      while (v20);
    }
    else
    {
      float v21 = a1 + 1;
    }
LABEL_48:
    *a3 = v21;
    return v5;
  }
  if (v11)
  {
    *a3 = a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return a4;
}

void sub_1B890F7C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B890F95C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1B890F9F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B891051C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

void sub_1B89106E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8910B1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  uint64_t v10 = v9;

  a9.super_class = (Class)ARWorldTrackingTechnique;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1B8910C58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8910F24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8910FD8(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1B8911044(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8911220(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B891156C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89118A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8911A78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8911D48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1B8912DF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8913318(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B891389C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, uint64_t a17, void *a18)
{
  _Unwind_Resume(a1);
}

void sub_1B8913B10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id a18)
{
  uint64_t v20 = v19;

  _Unwind_Resume(a1);
}

void sub_1B8913DB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, uint64_t a20,void *a21,void *a22)
{
  _Unwind_Resume(a1);
}

void sub_1B891456C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, void (*a19)(char *), uint64_t a20,uint64_t a21,char a22,uint64_t a23,void (*a24)(char *),uint64_t a25,uint64_t a26,char a27,uint64_t a28,void (*a29)(char *))
{
}

void sub_1B89152BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,void *a22,void *a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,void *a30)
{
  _Unwind_Resume(a1);
}

void sub_1B891567C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8915808(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id a16)
{
  if (a2 == 1)
  {
    [v17 _handleCV3DError:*((void *)__cxa_begin_catch(a1) + 1) withDescription:@"Raycasting error" failTechnique:0];
    __cxa_end_catch();
    JUMPOUT(0x1B89157D4);
  }

  _Unwind_Resume(a1);
}

void sub_1B8915A08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B891612C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,void (*a26)(char *),uint64_t a27,uint64_t a28,char a29,uint64_t a30,void (*a31)(char *))
{
  a26(&a24);
  a31(&a29);

  _Unwind_Resume(a1);
}

void sub_1B89163E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8916604(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8916734(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B8916B44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33)
{
  _Unwind_Resume(a1);
}

void sub_1B8916EBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_1B8916FBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8917040(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8917AA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32)
{
  _Unwind_Resume(a1);
}

double simd_matrix4x4(float32x4_t a1)
{
  _S3 = a1.i32[1];
  _S5 = a1.i32[2];
  __asm { FMLS            S1, S5, V0.S[2] }
  _S7 = a1.i32[3];
  __asm { FMLA            S1, S7, V0.S[3] }
  float v10 = vmlas_n_f32(vmuls_lane_f32(a1.f32[2], a1, 3), a1.f32[1], a1.f32[0]);
  LODWORD(v11) = _S1;
  *((float *)&v11 + 1) = v10 + v10;
  __asm
  {
    FMLA            S6, S3, V0.S[1]
    FMLA            S6, S7, V0.S[3]
    FMLS            S6, S0, V0.S[0]
    FMLA            S18, S5, V0.S[1]
    FMLA            S17, S0, V0.S[2]
    FMLA            S16, S5, V0.S[1]
    FMLA            S7, S5, V0.S[2]
    FMLS            S7, S0, V0.S[0]
    FMLS            S7, S3, V0.S[1]
  }
  return v11;
}

void sub_1B8918030(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8918138(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B89181A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89182E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89184C4(_Unwind_Exception *a1)
{
  unint64_t v6 = v4;

  _Unwind_Resume(a1);
}

void sub_1B8918604(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_1B89186BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1B8918860(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89189D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B8918A80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B8918B6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8919E20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, id *location, id *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,id a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,id a50,uint64_t a51,uint64_t a52,char a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,char a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  objc_destroyWeak(location);
  objc_destroyWeak(a10);
  objc_destroyWeak(&a50);
  ((void (*)(char *))a55)(&a53);
  ((void (*)(char *))a62)(&a60);
  ((void (*)(char *))a68)(&a66);

  _Unwind_Resume(a1);
}

void sub_1B891A250(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B891A2B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B891A320(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B891A3E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B891A52C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B891A6A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B891A838(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B891A9C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B891AA7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B891AB7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B891AC3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B891ACD0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B891AE10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B891AF08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1B891B1A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B891B2B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B891B554(_Unwind_Exception *a1)
{
  objc_destroyWeak(v2);
  os_unfair_lock_unlock(v1);
  objc_destroyWeak((id *)(v3 - 80));
  _Unwind_Resume(a1);
}

void sub_1B891B5FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B891B660(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B891B6C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B891B7BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B891BAD4(_Unwind_Exception *a1)
{
  uint64_t v4 = v2;

  _Unwind_Resume(a1);
}

void sub_1B891C340(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33)
{
  _Unwind_Resume(a1);
}

void sub_1B891C448(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B891C698(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double ARCascadeTransform(double *a1, double *a2, simd_float4x3 a3, const double *a4, const double *a5)
{
  *a1 = a4[3] * a3.columns[1].f32[0] + *a4 * a3.columns[0].f32[0] + a4[6] * a3.columns[2].f32[0];
  a1[1] = a4[4] * a3.columns[1].f32[0] + a4[1] * a3.columns[0].f32[0] + a4[7] * a3.columns[2].f32[0];
  a1[2] = a4[5] * a3.columns[1].f32[0] + a4[2] * a3.columns[0].f32[0] + a4[8] * a3.columns[2].f32[0];
  a1[3] = a4[3] * a3.columns[1].f32[1] + *a4 * a3.columns[0].f32[1] + a4[6] * a3.columns[2].f32[1];
  a1[4] = a4[4] * a3.columns[1].f32[1] + a4[1] * a3.columns[0].f32[1] + a4[7] * a3.columns[2].f32[1];
  a1[5] = a4[5] * a3.columns[1].f32[1] + a4[2] * a3.columns[0].f32[1] + a4[8] * a3.columns[2].f32[1];
  a1[6] = a4[3] * a3.columns[1].f32[2] + *a4 * a3.columns[0].f32[2] + a4[6] * a3.columns[2].f32[2];
  a1[7] = a4[4] * a3.columns[1].f32[2] + a4[1] * a3.columns[0].f32[2] + a4[7] * a3.columns[2].f32[2];
  a1[8] = a4[5] * a3.columns[1].f32[2] + a4[2] * a3.columns[0].f32[2] + a4[8] * a3.columns[2].f32[2];
  *a2 = a3.columns[3].f32[0] / 1000.0
      + *a5 * a3.columns[0].f32[0]
      + a5[2] * a3.columns[2].f32[0]
      + a5[1] * a3.columns[1].f32[0];
  a2[1] = a3.columns[3].f32[1] / 1000.0
        + *a5 * a3.columns[0].f32[1]
        + a5[2] * a3.columns[2].f32[1]
        + a5[1] * a3.columns[1].f32[1];
  double result = a3.columns[3].f32[2] / 1000.0
         + *a5 * a3.columns[0].f32[2]
         + a5[2] * a3.columns[2].f32[2]
         + a5[1] * a3.columns[1].f32[2];
  a2[2] = result;
  return result;
}

void sub_1B891CE1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, void (*a20)(char *),uint64_t a21,uint64_t a22,char a23,uint64_t a24,void (*a25)(char *))
{
  a20(&a18);
  a25(&a23);

  _Unwind_Resume(a1);
}

void sub_1B891D380(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B891EA34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,void *a22)
{
  _Unwind_Resume(a1);
}

void sub_1B891F488(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B891F5DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void ___ZL15_ARLogTechniquev_block_invoke_2()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "Technique");
  uint64_t v1 = (void *)_ARLogTechnique(void)::logObj;
  _ARLogTechnique(void)::logObunsigned int j = (uint64_t)v0;
}

void ___ZL13_ARLogGeneralv_block_invoke_6()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "General");
  uint64_t v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObunsigned int j = (uint64_t)v0;
}

uint64_t initAudioServicesPlaySystemSound(uint64_t a1)
{
  if (AudioToolboxLibrary(void)::sOnce != -1) {
    dispatch_once(&AudioToolboxLibrary(void)::sOnce, &__block_literal_global_576);
  }
  uint64_t v2 = (uint64_t (*))dlsym((void *)AudioToolboxLibrary(void)::sLib, "AudioServicesPlaySystemSound");
  softLinkAudioServicesPlaySystemSound = v2;
  return v2(a1);
}

void *___ZL19AudioToolboxLibraryv_block_invoke()
{
  double result = dlopen("/System/Library/Frameworks/AudioToolbox.framework/AudioToolbox", 2);
  AudioToolboxLibrary(void)::sLib = (uint64_t)result;
  return result;
}

void *std::allocate_shared[abi:ne180100]<RaycastSession,std::allocator<RaycastSession>,CV3DSLAMSession *&,void({block_pointer} {__strong}&)(CV3DRaycastResultMap const*),BOOL,void>@<X0>(void *a1@<X1>, void *a2@<X2>, unsigned __int8 *a3@<X3>, void *a4@<X8>)
{
  uint64_t v8 = operator new(0x20uLL);
  double result = std::__shared_ptr_emplace<RaycastSession>::__shared_ptr_emplace[abi:ne180100]<CV3DSLAMSession *&,void({block_pointer} {__strong}&)(CV3DRaycastResultMap const*),BOOL,std::allocator<RaycastSession>,0>(v8, a1, a2, a3);
  *a4 = v8 + 3;
  a4[1] = v8;
  return result;
}

void sub_1B891FD04(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<RaycastSession>::__shared_ptr_emplace[abi:ne180100]<CV3DSLAMSession *&,void({block_pointer} {__strong}&)(CV3DRaycastResultMap const*),BOOL,std::allocator<RaycastSession>,0>(void *a1, void *a2, void *a3, unsigned __int8 *a4)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F1209928;
  RaycastSession::RaycastSession(a1 + 3, *a2, *a3, *a4);
  return a1;
}

void sub_1B891FD6C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<RaycastSession>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1209928;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<RaycastSession>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1209928;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BA9C56C0);
}

uint64_t std::__shared_ptr_emplace<RaycastSession>::__on_zero_shared()
{
  return CV3DRaycastSessionRelease();
}

void *std::allocate_shared[abi:ne180100]<PlaneDetectionSession,std::allocator<PlaneDetectionSession>,CV3DSLAMSession *&,PlaneDetectionConfiguration const&,void({block_pointer} {__strong}&)(CV3DPlaneDetectionPlaneList const*),void({block_pointer} {__strong}&)(CV3DPlaneDetectionSingleShotPlaneList const*),void>@<X0>(void *a1@<X1>, uint64_t a2@<X2>, void *a3@<X3>, void *a4@<X4>, void *a5@<X8>)
{
  float v10 = operator new(0x30uLL);
  double result = std::__shared_ptr_emplace<PlaneDetectionSession>::__shared_ptr_emplace[abi:ne180100]<CV3DSLAMSession *&,PlaneDetectionConfiguration const&,void({block_pointer} {__strong}&)(CV3DPlaneDetectionPlaneList const*),void({block_pointer} {__strong}&)(CV3DPlaneDetectionSingleShotPlaneList const*),std::allocator<PlaneDetectionSession>,0>(v10, a1, a2, a3, a4);
  *a5 = v10 + 3;
  a5[1] = v10;
  return result;
}

void sub_1B891FE80(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<PlaneDetectionSession>::__shared_ptr_emplace[abi:ne180100]<CV3DSLAMSession *&,PlaneDetectionConfiguration const&,void({block_pointer} {__strong}&)(CV3DPlaneDetectionPlaneList const*),void({block_pointer} {__strong}&)(CV3DPlaneDetectionSingleShotPlaneList const*),std::allocator<PlaneDetectionSession>,0>(void *a1, void *a2, uint64_t a3, void *a4, void *a5)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F1209960;
  PlaneDetectionSession::PlaneDetectionSession(a1 + 3, *a2, a3, *a4, *a5);
  return a1;
}

void sub_1B891FEE8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PlaneDetectionSession>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1209960;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PlaneDetectionSession>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1209960;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BA9C56C0);
}

void std::__shared_ptr_emplace<PlaneDetectionSession>::__on_zero_shared(uint64_t a1)
{
}

void *std::allocate_shared[abi:ne180100]<PlaneDetectionSession,std::allocator<PlaneDetectionSession>,CV3DSLAMSession *&,PlaneDetectionConfiguration const&,void({block_pointer} {__strong}&)(CV3DPlaneDetectionPlaneList const*),void>@<X0>(void *a1@<X1>, uint64_t a2@<X2>, void *a3@<X3>, void *a4@<X8>)
{
  uint64_t v8 = operator new(0x30uLL);
  double result = std::__shared_ptr_emplace<PlaneDetectionSession>::__shared_ptr_emplace[abi:ne180100]<CV3DSLAMSession *&,PlaneDetectionConfiguration const&,void({block_pointer} {__strong}&)(CV3DPlaneDetectionPlaneList const*),std::allocator<PlaneDetectionSession>,0>(v8, a1, a2, a3);
  *a4 = v8 + 3;
  a4[1] = v8;
  return result;
}

void sub_1B891FFDC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<PlaneDetectionSession>::__shared_ptr_emplace[abi:ne180100]<CV3DSLAMSession *&,PlaneDetectionConfiguration const&,void({block_pointer} {__strong}&)(CV3DPlaneDetectionPlaneList const*),std::allocator<PlaneDetectionSession>,0>(void *a1, void *a2, uint64_t a3, void *a4)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F1209960;
  PlaneDetectionSession::PlaneDetectionSession(a1 + 3, *a2, a3, *a4, 0);
  return a1;
}

void sub_1B8920044(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<long,double>,std::__map_value_compare<long,std::__value_type<long,double>,std::less<long>,true>,std::allocator<std::__value_type<long,double>>>::__emplace_unique_key_args<long,std::piecewise_construct_t const&,std::tuple<long &&>,std::tuple<>>(uint64_t **a1, uint64_t *a2, uint64_t a3, uint64_t **a4)
{
  unint64_t v7 = a1 + 1;
  unint64_t v6 = a1[1];
  if (v6)
  {
    uint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        BOOL v9 = (uint64_t **)v6;
        uint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        unint64_t v6 = *v9;
        unint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      unint64_t v6 = v9[1];
      if (!v6)
      {
        unint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    BOOL v9 = a1 + 1;
LABEL_10:
    double v11 = (uint64_t *)operator new(0x30uLL);
    v11[4] = **a4;
    _OWORD v11[5] = 0;
    _ZNSt3__16__treeINS_12__value_typeIyDv4_fEENS_19__map_value_compareIyS3_NS_4lessIyEELb1EEENS_9allocatorIS3_EEE16__insert_node_atEPNS_15__tree_end_nodeIPNS_16__tree_node_baseIPvEEEERSF_SF_(a1, (uint64_t)v9, v7, v11);
    return v11;
  }
  return (uint64_t *)v9;
}

void sub_1B89202D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

float arkit::ExponentialSmoother<float>::step(uint64_t a1, float *a2, float a3, float a4, float a5)
{
  if (a5 <= 0.0 || a5 > 1.0) {
    arkit::ExponentialSmoother<float>::step();
  }
  if (a3 <= 0.0) {
    arkit::ExponentialSmoother<float>::step();
  }
  if (a4 <= 0.0) {
    arkit::ExponentialSmoother<float>::step();
  }
  float v8 = *a2;
  if (*(unsigned char *)(a1 + 4))
  {
    float v9 = a4 / log(1.0 - a5);
    float v10 = expf(a3 / v9);
    float v8 = (float)((float)(1.0 - (float)(1.0 - v10)) * *(float *)a1) + (float)((float)(1.0 - v10) * v8);
  }
  *(float *)a1 = v8;
  *(unsigned char *)(a1 + 4) = 1;
  return v8;
}

void sub_1B8920560(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double ar_rt_ring_buffer_init(uint64_t a1, int a2)
{
  if (a2 < 0) {
    ar_rt_ring_buffer_init_cold_1();
  }
  *(_DWORD *)a1 = a2;
  *(void *)&double result = 0xFFFFFFFFLL;
  *(void *)(a1 + 4) = 0xFFFFFFFFLL;
  return result;
}

uint64_t ar_rt_ring_buffer_reset(uint64_t result)
{
  if (!result) {
    ar_rt_ring_buffer_reset_cold_1();
  }
  *(void *)double result = 0;
  *(_DWORD *)(result + 8) = 0;
  return result;
}

BOOL ar_rt_ring_buffer_empty(uint64_t a1)
{
  if (!a1) {
    ar_rt_ring_buffer_empty_cold_1();
  }
  return *(_DWORD *)(a1 + 8) < 1;
}

uint64_t ar_rt_ring_buffer_increment_index(_DWORD *a1, int a2)
{
  if (!a1) {
    ar_rt_ring_buffer_increment_index_cold_1();
  }
  return (*a1 & (((a2 + 1) % *a1) >> 31)) + (a2 + 1) % *a1;
}

uint64_t ar_rt_ring_buffer_decrement_index(_DWORD *a1, int a2)
{
  if (!a1) {
    ar_rt_ring_buffer_decrement_index_cold_1();
  }
  return (*a1 & (((a2 - 1) % *a1) >> 31)) + (a2 - 1) % *a1;
}

uint64_t ar_rt_ring_buffer_add_element(int *a1)
{
  if (!a1) {
    ar_rt_ring_buffer_add_element_cold_1();
  }
  int v1 = a1[2];
  int v2 = *a1;
  if (v1 < *a1) {
    a1[2] = v1 + 1;
  }
  uint64_t v3 = (v2 & (((a1[1] + 1) % v2) >> 31)) + (a1[1] + 1) % v2;
  a1[1] = v3;
  return v3;
}

BOOL ar_rt_ring_buffer_filled(_DWORD *a1)
{
  if (!a1) {
    ar_rt_ring_buffer_filled_cold_1();
  }
  return a1[2] == *a1;
}

void MakeMatrix3x4f(float a1@<S0>, float a2@<S1>, float a3@<S2>, float a4@<S3>, float a5@<S4>, float a6@<S5>, float a7@<S6>, float a8@<S7>, float *a9@<X8>, float a10, float a11, float a12, float a13)
{
  *a9 = a1;
  a9[1] = a5;
  a9[2] = a10;
  a9[3] = a2;
  a9[4] = a6;
  a9[5] = a11;
  a9[6] = a3;
  a9[7] = a7;
  a9[8] = a12;
  a9[9] = a4;
  a9[10] = a8;
  a9[11] = a13;
}

int32x2_t round@<D0>(float32x2_t *a1@<X0>, int32x2_t *a2@<X8>)
{
  int32x2_t result = vcvt_s32_f32(vrnda_f32(*a1));
  *a2 = result;
  return result;
}

{
  unsigned int v2;
  int32x2_t result;

  int v2 = llroundf(a1[1].f32[0]);
  int32x2_t result = vcvt_s32_f32(vrnda_f32(*a1));
  *a2 = result;
  a2[1].i32[0] = v2;
  return result;
}

double convert@<D0>(double *a1@<X0>, void *a2@<X8>)
{
  double result = *a1;
  *a2 = *(void *)a1;
  return result;
}

float convert@<S0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  float result = *(float *)(a1 + 8);
  *(void *)a2 = *(void *)a1;
  *(float *)(a2 + 8) = result;
  return result;
}

double convert@<D0>(const simd_float3x3 *a1@<X0>, uint64_t a2@<X8>)
{
  long long v2 = *(long long *)((char *)a1->columns + 4);
  __int32 v3 = a1->columns[1].i32[2];
  __int32 v4 = a1->columns[2].i32[2];
  *((void *)&v2 + 1) = a1->columns[1].i64[0];
  *(_DWORD *)a2 = a1->columns[0].i32[0];
  *(_OWORD *)(a2 + 4) = v2;
  *(_DWORD *)(a2 + 20) = v3;
  double result = *(double *)a1->columns[2].i64;
  *(double *)(a2 + 24) = result;
  *(_DWORD *)(a2 + 32) = v4;
  return result;
}

__n128 convert@<Q0>(const simd_float4x4 *a1@<X0>, uint64_t a2@<X8>)
{
  simd_float4 v2 = a1->columns[1];
  *(simd_float4 *)a2 = a1->columns[0];
  *(simd_float4 *)(a2 + 16) = v2;
  __n128 result = (__n128)a1->columns[2];
  simd_float4 v4 = a1->columns[3];
  *(__n128 *)(a2 + 32) = result;
  *(simd_float4 *)(a2 + 48) = v4;
  return result;
}

double convert(uint64_t a1)
{
  return *(double *)a1;
}

double homogenize@<D0>(double *a1@<X0>, uint64_t a2@<X8>)
{
  double result = *a1;
  *(double *)a2 = *a1;
  *(_DWORD *)(a2 + 8) = 1065353216;
  return result;
}

float homogenize@<S0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  float result = *(float *)(a1 + 8);
  *(void *)a2 = *(void *)a1;
  *(float *)(a2 + 8) = result;
  *(_DWORD *)(a2 + 12) = 1065353216;
  return result;
}

double homogenize(uint64_t a1)
{
  __asm { FMOV            V0.4S, #1.0 }
  return *(double *)a1;
}

__n128 homogenize(uint64_t a1)
{
  return *(__n128 *)a1;
}

float32x2_t dehomogenize@<D0>(float32x2_t *a1@<X0>, float32x2_t *a2@<X8>)
{
  simd_float4 v2 = (const float *)&a1[1];
  float32x2_t v3 = vld1_dup_f32(v2);
  float32x2_t result = vdiv_f32(*a1, v3);
  *a2 = result;
  return result;
}

float32x2_t dehomogenize@<D0>(float32x2_t *a1@<X0>, float32x2_t *a2@<X8>, double a3@<D0>)
{
  LODWORD(a3) = a1[1].i32[1];
  float32_t v3 = a1[1].f32[0] / *(float *)&a3;
  float32x2_t result = vdiv_f32(*a1, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a3, 0));
  *a2 = result;
  a2[1].f32[0] = v3;
  return result;
}

float32x2_t dehomogenize(uint64_t a1)
{
  return vdiv_f32(*(float32x2_t *)a1, (float32x2_t)vdup_lane_s32(*(int32x2_t *)(a1 + 8), 0));
}

float32x2_t dehomogenize(float32x2_t *a1, double a2, int32x2_t a3)
{
  a3.i32[0] = a1[1].i32[1];
  return vdiv_f32(*a1, (float32x2_t)vdup_lane_s32(a3, 0));
}

id ARStreamIdentifierForDeviceTypeAndPosition(void *a1, uint64_t a2)
{
  id v3 = a1;
  if ([v3 isEqualToString:*MEMORY[0x1E4F15810]])
  {
    id v4 = (id)*MEMORY[0x1E4F51408];
  }
  else
  {
    id v4 = [NSString stringWithFormat:@"%@.%ld", v3, a2];
  }
  uint64_t v5 = v4;

  return v5;
}

id AVCaptureDeviceTypeFromST2StreamIdentifier(void *a1)
{
  id v1 = a1;
  id v2 = (id)*MEMORY[0x1E4F15830];
  if ([v1 isEqualToString:*MEMORY[0x1E4F51410]])
  {
    id v3 = (id)*MEMORY[0x1E4F15828];

    id v2 = v3;
  }
  if (([v1 isEqualToString:@"JasperCamera"] & 1) != 0
    || [v1 isEqualToString:*MEMORY[0x1E4F51408]])
  {
    id v4 = (id)*MEMORY[0x1E4F15810];

    id v2 = v4;
  }

  return v2;
}

id AVCaptureDeviceTypeFromStreamIdentifier(void *a1)
{
  id v1 = a1;
  id v2 = [v1 componentsSeparatedByString:@"."];
  id v3 = [v2 firstObject];

  if ([v3 containsString:@"AVCaptureDeviceType"])
  {
    if ([v3 isEqualToString:@"AVCaptureDeviceTypeBuiltInSuperWideAngleCamera"])
    {
      id v4 = (id)*MEMORY[0x1E4F15828];

      id v3 = v4;
    }
    id v5 = v3;
    id v3 = v5;
  }
  else
  {
    AVCaptureDeviceTypeFromST2StreamIdentifier(v1);
    id v5 = (id)objc_claimAutoreleasedReturnValue();
  }

  return v5;
}

uint64_t AVCaptureDevicePositionFromST2StreamIdentifier(void *a1)
{
  id v1 = a1;
  if (([v1 isEqualToString:*MEMORY[0x1E4F51400]] & 1) != 0
    || ([v1 isEqualToString:*MEMORY[0x1E4F51410]] & 1) != 0
    || ([v1 isEqualToString:@"JasperCamera"] & 1) != 0)
  {
    uint64_t v2 = 1;
  }
  else
  {
    uint64_t v2 = [v1 isEqualToString:*MEMORY[0x1E4F51408]];
  }

  return v2;
}

uint64_t AVCaptureDevicePositionFromStreamIdentifier(void *a1)
{
  id v1 = a1;
  if ([v1 containsString:@"AVCaptureDeviceType"])
  {
    uint64_t v2 = [v1 componentsSeparatedByString:@"."];

    if ((unint64_t)[v2 count] < 2)
    {
      uint64_t v4 = 0;
    }
    else
    {
      id v3 = [v2 objectAtIndexedSubscript:1];
      uint64_t v4 = [v3 integerValue];
    }
    id v1 = v2;
  }
  else
  {
    uint64_t v4 = AVCaptureDevicePositionFromST2StreamIdentifier(v1);
  }

  return v4;
}

uint64_t ARDeviceOrientationForCameraPositionAndVideoTransform(uint64_t a1, _OWORD *a2)
{
  long long v4 = a2[1];
  *(_OWORD *)&t1.a = *a2;
  *(_OWORD *)&t1.c = v4;
  *(_OWORD *)&t1.tx = a2[2];
  CGAffineTransform v9 = *(CGAffineTransform *)ARVideoTransformPortrait;
  if (CGAffineTransformEqualToTransform(&t1, &v9)) {
    return 1;
  }
  long long v6 = a2[1];
  *(_OWORD *)&t1.a = *a2;
  *(_OWORD *)&t1.c = v6;
  *(_OWORD *)&t1.tx = a2[2];
  CGAffineTransform v9 = *(CGAffineTransform *)ARVideoTransformPortraitUpsideDown;
  if (CGAffineTransformEqualToTransform(&t1, &v9)) {
    return 2;
  }
  long long v7 = a2[1];
  *(_OWORD *)&t1.a = *a2;
  *(_OWORD *)&t1.c = v7;
  *(_OWORD *)&t1.tx = a2[2];
  CGAffineTransform v9 = *(CGAffineTransform *)ARVideoTransformLandscapeLeft;
  if (CGAffineTransformEqualToTransform(&t1, &v9))
  {
    if (a1 == 2) {
      return 4;
    }
    else {
      return 3;
    }
  }
  else
  {
    long long v8 = a2[1];
    *(_OWORD *)&t1.a = *a2;
    *(_OWORD *)&t1.c = v8;
    *(_OWORD *)&t1.tx = a2[2];
    CGAffineTransform v9 = *(CGAffineTransform *)ARVideoTransformLandscapeRight;
    if (CGAffineTransformEqualToTransform(&t1, &v9))
    {
      if (a1 == 2) {
        return 3;
      }
      else {
        return 4;
      }
    }
    else if (a1 == 2)
    {
      return 1;
    }
    else
    {
      return 3;
    }
  }
}

__n128 ARVideoTransformForDeviceOrientation@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  switch(a1)
  {
    case 1:
      uint64_t v2 = &ARVideoTransformPortrait;
      break;
    case 2:
      uint64_t v2 = &ARVideoTransformPortraitUpsideDown;
      break;
    case 4:
      uint64_t v2 = &ARVideoTransformLandscapeRight;
      break;
    default:
      uint64_t v2 = &ARVideoTransformLandscapeLeft;
      break;
  }
  long long v3 = v2[1];
  *(_OWORD *)a2 = *v2;
  *(_OWORD *)(a2 + 16) = v3;
  __n128 result = (__n128)v2[2];
  *(__n128 *)(a2 + 32) = result;
  return result;
}

id ARMetadataIdentifierForARRecordableResultsClass(objc_class *a1)
{
  id v1 = NSString;
  uint64_t v2 = NSStringFromClass(a1);
  long long v3 = [v1 stringWithFormat:@"%@%@", @"mdta/com.apple.arkit.result.", v2];

  return v3;
}

id ARMetadataIdentifierForARSensorDataClass(uint64_t a1, uint64_t a2)
{
  if (objc_opt_class() == a1)
  {
    id v5 = (id *)MEMORY[0x1E4F4D650];
    long long v6 = (id *)MEMORY[0x1E4F4D678];
    goto LABEL_12;
  }
  if (objc_opt_class() == a1)
  {
    id v5 = (id *)MEMORY[0x1E4F4D5F0];
    long long v6 = (id *)MEMORY[0x1E4F4D668];
LABEL_12:
    if (!a2) {
      id v5 = v6;
    }
    goto LABEL_14;
  }
  if (objc_opt_class() == a1)
  {
    id v5 = (id *)MEMORY[0x1E4F4D658];
  }
  else
  {
    if (objc_opt_class() != a1)
    {
      if (objc_opt_class() != a1)
      {
        id v4 = 0;
        goto LABEL_15;
      }
      id v5 = (id *)MEMORY[0x1E4F4D628];
      long long v6 = (id *)MEMORY[0x1E4F4D670];
      goto LABEL_12;
    }
    id v5 = (id *)MEMORY[0x1E4F4D630];
  }
LABEL_14:
  id v4 = *v5;
LABEL_15:
  return v4;
}

uint64_t aggregationSizeForPointCloud(void *a1)
{
  id v1 = [a1 pointCloud];
  int v2 = [v1 length];

  if (v2 == 168) {
    return 2;
  }
  else {
    return 4;
  }
}

void sub_1B892137C(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B8921A24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, os_unfair_lock_t lock)
{
}

void sub_1B8921D00(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B8921DB8(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B8921FE0(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

__CFString *NSStringFromCV3DVIOReturn(unsigned int a1)
{
  if (a1 > 0x21) {
    return &stru_1F120C8F0;
  }
  else {
    return off_1E61868A0[a1];
  }
}

__CFString *NSStringFromCV3DSLAMConfigReturn(unsigned int a1)
{
  if (a1 < 5) {
    return off_1E61869B0[a1];
  }
  int v2 = _ARLogGeneral_13();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)long long v3 = 0;
    _os_log_impl(&dword_1B88A2000, v2, OS_LOG_TYPE_DEBUG, "Unknown CV3DSLAMConfigReturn value passed.", v3, 2u);
  }

  return &stru_1F120C8F0;
}

__CFString *NSStringFromCV3DSLAMReturn(int a1)
{
  if (*MEMORY[0x1E4F4D490] == a1) {
    return @"NoError";
  }
  if (*MEMORY[0x1E4F4D470] == a1) {
    return @"Error";
  }
  if (*MEMORY[0x1E4F4D478] == a1) {
    return @"InsufficientMemory";
  }
  if (*MEMORY[0x1E4F4D480] == a1) {
    return @"InvalidContext";
  }
  if (*MEMORY[0x1E4F4D488] == a1) {
    return @"InvalidParameter";
  }
  if (*MEMORY[0x1E4F4D468] == a1) {
    return @"CMMapNotAvailable";
  }
  int v2 = _ARLogGeneral_13();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)long long v3 = 0;
    _os_log_impl(&dword_1B88A2000, v2, OS_LOG_TYPE_DEBUG, "Unknown CV3DSLAMReturn value passed.", v3, 2u);
  }

  return &stru_1F120C8F0;
}

__CFString *NSStringFromCV3DPosePredictionReturn(unsigned int a1)
{
  if (a1 > 6) {
    return &stru_1F120C8F0;
  }
  else {
    return off_1E61869D8[a1];
  }
}

__CFString *NSStringFromCV3DSLAMAnchorAddedResult(int a1)
{
  if (*MEMORY[0x1E4F4D3C8] == a1) {
    return @"NoError";
  }
  if (*MEMORY[0x1E4F4D3C0] == a1) {
    return @"NoActiveAnchorGroup";
  }
  if (*MEMORY[0x1E4F4D3B8] == a1) {
    return @"InactiveAnchorGroup";
  }
  if (*MEMORY[0x1E4F4D3D0] == a1) {
    return @"TooManyAnchors";
  }
  if (*MEMORY[0x1E4F4D3A8] == a1) {
    return @"DuplicateAnchor";
  }
  if (*MEMORY[0x1E4F4D3B0] == a1) {
    return @"Error";
  }
  return @"Unknown";
}

__CFString *NSStringFromSLAMCMDataType(int a1)
{
  if (*MEMORY[0x1E4F4D3F8] == a1) {
    return @"PoseAnchor";
  }
  if (*MEMORY[0x1E4F4D3D8] == a1) {
    return @"KeyframeInfo";
  }
  if (*MEMORY[0x1E4F4D3F0] == a1) {
    return @"ObjectsAnchor";
  }
  if (*MEMORY[0x1E4F4D408] == a1) {
    return @"RelocalizationResult";
  }
  if (*MEMORY[0x1E4F4D400] == a1) {
    return @"RegistrationData";
  }
  if (*MEMORY[0x1E4F4D3E8] == a1) {
    return @"ObjectAnchorRemoval";
  }
  if (*MEMORY[0x1E4F4D410] == a1) {
    return @"VIOStateAndUTCTimestamp";
  }
  if (*MEMORY[0x1E4F4D3E0] == a1) {
    return @"MapRegistrationStats";
  }
  return @"Unknown";
}

__CFString *NSStringFromCV3DSLAMCalibrationReturn(unsigned int a1)
{
  if (a1 > 6) {
    return &stru_1F120C8F0;
  }
  else {
    return off_1E6186A10[a1];
  }
}

__CFString *NSStringFromCV3DSLAMJasperPointCloudReturn(unsigned int a1)
{
  if (a1 > 2) {
    return @"Unknown";
  }
  else {
    return off_1E6186A48[a1];
  }
}

__CFString *NSStringFromCV3DVIOTrackingState(unsigned int a1)
{
  if (a1 > 4) {
    return &stru_1F120C8F0;
  }
  else {
    return off_1E6186A60[a1];
  }
}

__CFString *NSStringFromCV3DSLAMMode(int a1)
{
  if (*MEMORY[0x1E4F4D460] == a1) {
    id v1 = @"Visual";
  }
  else {
    id v1 = @"Unknown";
  }
  if (*MEMORY[0x1E4F4D458] == a1) {
    return @"Regular";
  }
  else {
    return v1;
  }
}

id ARGetAnchorIdentifierFromAnchorRef()
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  uint64_t v0 = CV3DSLAMAnchorCopyAnchorID();
  if (v0)
  {
    id v1 = (const void *)v0;
    int v2 = objc_msgSend(MEMORY[0x1E4F29128], "ar_UUIDWithCFUUIDRef:", v0);
    CFRelease(v1);
  }
  else
  {
    long long v3 = _ARLogGeneral_13();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)vImage_Buffer buf = 138543362;
      uint64_t v6 = 0;
      _os_log_impl(&dword_1B88A2000, v3, OS_LOG_TYPE_ERROR, "Failed to retrieve anchor identifier %{public}@", buf, 0xCu);
    }
    int v2 = 0;
  }
  return v2;
}

__CFString *NSStringFromCV3DVisualSLAMState(int a1)
{
  if (*MEMORY[0x1E4F4D568] == a1) {
    return @"VisionOnly";
  }
  if (*MEMORY[0x1E4F4D570] == a1) {
    return @"VisionOnlyAndInertialInitialization";
  }
  if (*MEMORY[0x1E4F4D578] == a1) {
    return @"VisualInertial";
  }
  return @"Unknown";
}

uint64_t NSErrorFromCV3DVIOTrackingState()
{
  return 0;
}

uint64_t CV3DSLAMCameraVideoModeForResolutionAndDeviceType(void *a1, double a2, double a3)
{
  id v5 = NSString;
  id v6 = a1;
  uint64_t v7 = objc_msgSend(v5, "stringWithFormat:", @"%.0fx%.0f", *(void *)&a2, *(void *)&a3);
  id v8 = (id)*MEMORY[0x1E4F15828];

  if (v8 == v6)
  {
    uint64_t v9 = [v7 stringByAppendingString:@"xSW"];

    uint64_t v7 = (void *)v9;
  }
  id v10 = v7;
  [v10 UTF8String];
  uint64_t v11 = CV3DSLAMCameraVideoModeFromString();

  return v11;
}

id ARVisionDataParametersForWorldTrackingOptions(void *a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v13 = 0;
  unsigned int v2 = [v1 createSLAMCalibration:&v13];
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3221225472;
  id v10 = __ARVisionDataParametersForWorldTrackingOptions_block_invoke;
  uint64_t v11 = &__block_descriptor_40_e5_v8__0l;
  uint64_t v12 = v13;
  if (v2)
  {
    long long v3 = _ARLogGeneral_13();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      if (v2 > 6) {
        id v4 = &stru_1F120C8F0;
      }
      else {
        id v4 = off_1E6186A88[v2 - 1];
      }
      *(_DWORD *)vImage_Buffer buf = 138543618;
      id v15 = v1;
      __int16 v16 = 2114;
      float v17 = v4;
      _os_log_impl(&dword_1B88A2000, v3, OS_LOG_TYPE_ERROR, "Error building slam calibration, unable to fetch vision data output parameters for %{public}@: %{public}@", buf, 0x16u);
    }

    AVCaptureuint64_t Config = 0;
  }
  else
  {
    uint64_t v8 = 0;
    objc_msgSend(v1, "createSLAMConfig:calibration:", &v8);
    AVCaptureuint64_t Config = (void *)CV3DSLAMConfigCreateAVCaptureConfig();
    CV3DSLAMConfigRelease();
    if (!AVCaptureConfig)
    {
      id v6 = _ARLogGeneral_13();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)vImage_Buffer buf = 138543618;
        id v15 = v1;
        __int16 v16 = 2112;
        float v17 = 0;
        _os_log_impl(&dword_1B88A2000, v6, OS_LOG_TYPE_ERROR, "Error reading vision data output parameters for %{public}@: %@", buf, 0x16u);
      }
    }
  }
  ((void (*)(void *))v10)(v9);

  return AVCaptureConfig;
}

void sub_1B89228BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, void (*a13)(char *))
{
}

uint64_t __ARVisionDataParametersForWorldTrackingOptions_block_invoke()
{
  return CV3DSLAMCalibrationRelease();
}

uint64_t ARParseAndAddCameraCalibrationParameters(void *a1)
{
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  unsigned int v2 = [v1 objectForKeyedSubscript:ARWorldTrackingBackWideCalibrationParametersKeyImageWidth];
  int v3 = [v2 intValue];

  id v4 = [v1 objectForKeyedSubscript:ARWorldTrackingBackWideCalibrationParametersKeyImageHeight];
  int v5 = [v4 intValue];

  if (v3) {
    BOOL v6 = v5 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6)
  {
    uint64_t v7 = _ARLogGeneral_13();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf[0]) = 136446722;
      *(void *)((char *)buf + 4) = "CV3DSLAMCalibrationReturn ARParseAndAddCameraCalibrationParameters(NSDictionary *__"
                                     "strong _Nonnull, CV3DSLAMMutableCalibrationRef _Nonnull, CV3DSLAMCameraMode, const "
                                     "uint32_t, const uint32_t)";
      WORD2(buf[1]) = 1024;
      *(_DWORD *)((char *)&buf[1] + 6) = v3;
      WORD1(buf[2]) = 1024;
      HIDWORD(buf[2]) = v5;
      _os_log_impl(&dword_1B88A2000, v7, OS_LOG_TYPE_ERROR, "%{public}s: wrong width (%d) or height(%d)", (uint8_t *)buf, 0x18u);
    }
    uint64_t v8 = 1;
  }
  else
  {
    uint64_t v9 = [v1 objectForKeyedSubscript:ARWorldTrackingBackWideCalibrationParametersKeyLensType];
    uint64_t v7 = v9;
    if (v9)
    {
      id v10 = [v1 objectForKeyedSubscript:ARWorldTrackingBackWideCalibrationParametersKeyCameraMatrix];
      uint64_t v11 = [v10 componentsSeparatedByString:@","];
      if ((unint64_t)[v11 count] > 8)
      {
        uint64_t v13 = [v11 objectAtIndex:0];
        [v13 floatValue];

        BOOL v14 = [v11 objectAtIndex:4];
        [v14 floatValue];

        id v15 = [v11 objectAtIndex:2];
        [v15 floatValue];

        __int16 v16 = [v11 objectAtIndex:5];
        [v16 floatValue];

        uint64_t v12 = [v1 objectForKeyedSubscript:ARWorldTrackingBackWideCalibrationParametersKeyRadialDistortion];
        float v17 = [v12 componentsSeparatedByString:@","];
        if ((unint64_t)[v17 count] > 2)
        {
          uint64_t v50 = v12;
          uint64_t v19 = 0;
          memset(v60, 0, sizeof(v60));
          do
          {
            uint64_t v20 = [v17 objectAtIndex:v19];
            [v20 doubleValue];
            *((void *)v60 + v19) = v21;

            ++v19;
          }
          while (v19 != 4);
          unint64_t v22 = [v1 objectForKeyedSubscript:ARWorldTrackingBackWideCalibrationParametersKeyTangentialDistortion];
          uint64_t v23 = [v22 componentsSeparatedByString:@","];
          if ((unint64_t)[v23 count] >= 2)
          {
            int v25 = [v23 objectAtIndex:0];
            [v25 doubleValue];
            v59[3] = v26;
            int8x16_t v49 = v23;
            id v27 = [v23 objectAtIndex:1];
            [v27 doubleValue];
            v59[4] = v28;

            int64x2_t v48 = [v1 objectForKeyedSubscript:ARWorldTrackingBackWideCalibrationParametersKeyCameraToImuPosition];
            uint64_t v29 = [v48 componentsSeparatedByString:@","];
            if ((unint64_t)[v29 count] > 2)
            {
              uint64_t v45 = v11;
              double v46 = v22;
              double v47 = v10;
              uint64_t v31 = 0;
              memset(v59, 0, 24);
              do
              {
                unint64_t v32 = [v29 objectAtIndex:v31];
                [v32 doubleValue];
                v59[v31] = v33;

                ++v31;
              }
              while (v31 != 3);
              uint64_t v34 = [v1 objectForKeyedSubscript:ARWorldTrackingBackWideCalibrationParametersKeyCameraToImuRotation];
              long long v35 = [v34 componentsSeparatedByString:@","];
              if ((unint64_t)[v35 count] >= 9)
              {
                uint64_t v44 = v34;
                uint64_t v36 = 0;
                uint64_t v58 = 0;
                long long v56 = 0u;
                long long v57 = 0u;
                memset(buf, 0, sizeof(buf));
                do
                {
                  id v37 = [v35 objectAtIndex:v36];
                  [v37 doubleValue];
                  buf[v36] = v38;

                  ++v36;
                }
                while (v36 != 9);
                int8x16_t v39 = [v1 objectForKeyedSubscript:ARWorldTrackingBackWideCalibrationParametersKeyTimestampCorrectionForCamera];
                [v39 doubleValue];

                int8x16_t v40 = [v1 objectForKeyedSubscript:ARWorldTrackingBackWideCalibrationParametersKeyCameraReadoutTime];
                [v40 doubleValue];

                ARGetCV3DCameraLensDistortionModelFromLensType(v7);
                uint64_t v8 = CV3DSLAMCalibrationAddCameraParameters2();
                unint64_t v22 = v46;
                uint64_t v23 = v49;
                if (v8)
                {
                  int8x16_t v41 = _ARLogGeneral_13();
                  if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
                  {
                    if (v8 > 6) {
                      double v42 = &stru_1F120C8F0;
                    }
                    else {
                      double v42 = off_1E6186A88[(int)v8 - 1];
                    }
                    *(_DWORD *)uint64_t v51 = 136315394;
                    uint64x2_t v52 = "CV3DSLAMCalibrationReturn ARParseAndAddCameraCalibrationParameters(NSDictionary *__strong _Non"
                          "null, CV3DSLAMMutableCalibrationRef _Nonnull, CV3DSLAMCameraMode, const uint32_t, const uint32_t)";
                    __int16 v53 = 2112;
                    float v54 = v42;
                    _os_log_impl(&dword_1B88A2000, v41, OS_LOG_TYPE_ERROR, "%s: CV3DSLAMCalibrationAddCameraParameters failed (result=%@)", v51, 0x16u);
                  }
                }
                uint64_t v34 = v44;
              }
              else
              {
                uint64_t v8 = 1;
                unint64_t v22 = v46;
                uint64_t v23 = v49;
              }

              id v10 = v47;
              uint64_t v11 = v45;
            }
            else
            {
              unint64_t v30 = _ARLogGeneral_13();
              if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
              {
                LODWORD(buf[0]) = 136315394;
                *(void *)((char *)buf + 4) = "CV3DSLAMCalibrationReturn ARParseAndAddCameraCalibrationParameters(NSDict"
                                               "ionary *__strong _Nonnull, CV3DSLAMMutableCalibrationRef _Nonnull, CV3DSL"
                                               "AMCameraMode, const uint32_t, const uint32_t)";
                WORD2(buf[1]) = 1024;
                *(_DWORD *)((char *)&buf[1] + 6) = [v29 count];
                _os_log_impl(&dword_1B88A2000, v30, OS_LOG_TYPE_ERROR, "%s: wrong cameraToImuPositionArray (cameraToImuPositionArray=%d)", (uint8_t *)buf, 0x12u);
              }

              uint64_t v8 = 1;
              uint64_t v23 = v49;
            }
          }
          else
          {
            long long v24 = _ARLogGeneral_13();
            if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
            {
              LODWORD(buf[0]) = 136315394;
              *(void *)((char *)buf + 4) = "CV3DSLAMCalibrationReturn ARParseAndAddCameraCalibrationParameters(NSDictio"
                                             "nary *__strong _Nonnull, CV3DSLAMMutableCalibrationRef _Nonnull, CV3DSLAMCa"
                                             "meraMode, const uint32_t, const uint32_t)";
              WORD2(buf[1]) = 1024;
              *(_DWORD *)((char *)&buf[1] + 6) = [v23 count];
              _os_log_impl(&dword_1B88A2000, v24, OS_LOG_TYPE_ERROR, "%s: wrong tangentialDistortionArray (tangentialDistortionArray.count=%d)", (uint8_t *)buf, 0x12u);
            }

            uint64_t v8 = 1;
          }
          uint64_t v12 = v50;
        }
        else
        {
          uint64_t v18 = _ARLogGeneral_13();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          {
            LODWORD(buf[0]) = 136315394;
            *(void *)((char *)buf + 4) = "CV3DSLAMCalibrationReturn ARParseAndAddCameraCalibrationParameters(NSDictiona"
                                           "ry *__strong _Nonnull, CV3DSLAMMutableCalibrationRef _Nonnull, CV3DSLAMCamera"
                                           "Mode, const uint32_t, const uint32_t)";
            WORD2(buf[1]) = 1024;
            *(_DWORD *)((char *)&buf[1] + 6) = [v17 count];
            _os_log_impl(&dword_1B88A2000, v18, OS_LOG_TYPE_ERROR, "%s: wrong radialDistortionArray array (radialDistortionArray.count=%d)", (uint8_t *)buf, 0x12u);
          }

          uint64_t v8 = 1;
        }
      }
      else
      {
        uint64_t v12 = _ARLogGeneral_13();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          LODWORD(buf[0]) = 136446466;
          *(void *)((char *)buf + 4) = "CV3DSLAMCalibrationReturn ARParseAndAddCameraCalibrationParameters(NSDictionary"
                                         " *__strong _Nonnull, CV3DSLAMMutableCalibrationRef _Nonnull, CV3DSLAMCameraMode"
                                         ", const uint32_t, const uint32_t)";
          WORD2(buf[1]) = 1024;
          *(_DWORD *)((char *)&buf[1] + 6) = [v11 count];
          _os_log_impl(&dword_1B88A2000, v12, OS_LOG_TYPE_ERROR, "%{public}s: wrong Intrinsics array (intrinsicsArray.count=%d)", (uint8_t *)buf, 0x12u);
        }
        uint64_t v8 = 1;
      }
    }
    else
    {
      id v10 = _ARLogGeneral_13();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf[0]) = 136446466;
        *(void *)((char *)buf + 4) = "CV3DSLAMCalibrationReturn ARParseAndAddCameraCalibrationParameters(NSDictionary *"
                                       "__strong _Nonnull, CV3DSLAMMutableCalibrationRef _Nonnull, CV3DSLAMCameraMode, co"
                                       "nst uint32_t, const uint32_t)";
        WORD2(buf[1]) = 2114;
        *(void *)((char *)&buf[1] + 6) = 0;
        _os_log_impl(&dword_1B88A2000, v10, OS_LOG_TYPE_ERROR, "%{public}s: wrong lens type(%{public}@)", (uint8_t *)buf, 0x16u);
      }
      uint64_t v8 = 1;
    }
  }
  return v8;
}

uint64_t ARGetCV3DCameraLensDistortionModelFromLensType(void *a1)
{
  id v1 = a1;
  if (([v1 isEqualToString:@"Perspective"] & 1) == 0)
  {
    if ([v1 isEqualToString:@"Fisheye"])
    {
      uint64_t v2 = 1;
      goto LABEL_9;
    }
    if ([v1 isEqualToString:@"FlyoverPerspective"])
    {
      uint64_t v2 = 2;
      goto LABEL_9;
    }
    if ([v1 isEqualToString:@"NoDistortion"])
    {
      uint64_t v2 = 3;
      goto LABEL_9;
    }
    id v4 = _ARLogGeneral_13();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int v5 = 0;
      _os_log_impl(&dword_1B88A2000, v4, OS_LOG_TYPE_ERROR, "LensType not configured in calibration directory, defaulting to Perspective", v5, 2u);
    }
  }
  uint64_t v2 = 0;
LABEL_9:

  return v2;
}

id AppleCV3DValuesFromExternalCalibrationDictionary(void *a1)
{
  v52[9] = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = [MEMORY[0x1E4F1CA60] dictionary];
  int v3 = [v1 objectForKeyedSubscript:@"CameraDescription"];
  id v4 = v3;
  if (!v3) {
    goto LABEL_34;
  }
  int v5 = [v3 objectForKeyedSubscript:@"CameraIntrinsics"];
  BOOL v6 = v5;
  if (v5)
  {
    uint64_t v7 = [v5 objectForKeyedSubscript:@"DistortionCoefficients"];
    uint64_t v8 = v7;
    if (v7)
    {
      uint64_t v9 = [v7 componentsJoinedByString:@","];
      [v2 setObject:v9 forKeyedSubscript:ARWorldTrackingBackWideCalibrationParametersKeyRadialDistortion];
    }
    uint64_t v10 = [v6 objectForKeyedSubscript:@"LensType"];
    if (v10) {
      [v2 setObject:v10 forKeyedSubscript:ARWorldTrackingBackWideCalibrationParametersKeyLensType];
    }
    uint64_t v11 = [v6 objectForKeyedSubscript:@"Resolution"];
    uint64_t v12 = v11;
    if (v11)
    {
      uint64_t v13 = [v11 objectForKeyedSubscript:@"Height"];
      if (v13) {
        [v2 setObject:v13 forKeyedSubscript:ARWorldTrackingBackWideCalibrationParametersKeyImageHeight];
      }
      BOOL v14 = [v12 objectForKeyedSubscript:@"Width"];
      if (v14) {
        [v2 setObject:v14 forKeyedSubscript:ARWorldTrackingBackWideCalibrationParametersKeyImageWidth];
      }
    }
    int64x2_t v48 = v12;
    id v51 = v1;
    id v15 = [v6 objectForKeyedSubscript:@"EffectiveFocusLength"];
    __int16 v16 = v15;
    if (v15)
    {
      float v17 = [v15 objectForKeyedSubscript:@"X"];
      uint64_t v18 = [v16 objectForKeyedSubscript:@"Y"];
    }
    else
    {
      uint64_t v18 = 0;
      float v17 = 0;
    }
    int8x16_t v49 = (void *)v10;
    uint64_t v50 = v8;
    uint64_t v19 = [v6 objectForKeyedSubscript:@"PrincipalPoint"];
    uint64_t v20 = v19;
    double v47 = v16;
    if (v19)
    {
      uint64_t v21 = [v19 objectForKeyedSubscript:@"X"];
      unint64_t v22 = [v20 objectForKeyedSubscript:@"Y"];
      if (!v17) {
        goto LABEL_24;
      }
    }
    else
    {
      unint64_t v22 = 0;
      uint64_t v21 = 0;
      if (!v17)
      {
LABEL_24:
        uint64_t v26 = [v6 objectForKeyedSubscript:@"TangentialDistortionCoefficients"];
        id v27 = v26;
        if (v26)
        {
          [v26 componentsJoinedByString:@","];
          uint64_t v29 = v28 = v17;
          [v2 setObject:v29 forKeyedSubscript:ARWorldTrackingBackWideCalibrationParametersKeyTangentialDistortion];

          float v17 = v28;
        }
        [v2 setObject:&unk_1F125C3B0 forKeyedSubscript:ARWorldTrackingBackWideCalibrationParametersKeyCameraReadoutTime];

        id v1 = v51;
        goto LABEL_27;
      }
    }
    if (v18 && v21 && v22)
    {
      v52[0] = v17;
      v52[1] = &unk_1F125C390;
      v52[2] = v21;
      v52[3] = &unk_1F125C390;
      v52[4] = v18;
      v52[5] = v22;
      v52[6] = &unk_1F125C390;
      v52[7] = &unk_1F125C390;
      v52[8] = &unk_1F125C3A0;
      uint64_t v23 = [MEMORY[0x1E4F1C978] arrayWithObjects:v52 count:9];
      [v23 componentsJoinedByString:@","];
      v25 = long long v24 = v17;
      [v2 setObject:v25 forKeyedSubscript:ARWorldTrackingBackWideCalibrationParametersKeyCameraMatrix];

      float v17 = v24;
    }
    goto LABEL_24;
  }
LABEL_27:
  unint64_t v30 = [v4 objectForKeyedSubscript:@"RotationIMUToCamera"];
  uint64_t v31 = v30;
  if (v30)
  {
    unint64_t v32 = [v30 componentsJoinedByString:@","];
    [v2 setObject:v32 forKeyedSubscript:ARWorldTrackingBackWideCalibrationParametersKeyCameraToImuRotation];
  }
  uint64_t v33 = [v4 objectForKeyedSubscript:@"TranslationCameraToIMU"];
  uint64_t v34 = v33;
  if (v33)
  {
    long long v35 = [v33 componentsJoinedByString:@","];
    [v2 setObject:v35 forKeyedSubscript:ARWorldTrackingBackWideCalibrationParametersKeyCameraToImuPosition];
  }
  uint64_t v36 = [v4 objectForKeyedSubscript:@"TimestampCorrectionForCamera"];
  if (v36) {
    [v2 setObject:v36 forKeyedSubscript:ARWorldTrackingBackWideCalibrationParametersKeyTimestampCorrectionForCamera];
  }

LABEL_34:
  id v37 = [v1 objectForKeyedSubscript:@"IMUDescription"];
  if (v37)
  {
    uint64_t v38 = [v4 objectForKeyedSubscript:@"AccelerometerTimestampCorrection"];
    if (v38) {
      [v2 setObject:v38 forKeyedSubscript:@"AccelerometerTimestampCorrection"];
    }
    int8x16_t v39 = [v37 objectForKeyedSubscript:@"Gravity"];
    int8x16_t v40 = v39;
    if (v39)
    {
      int8x16_t v41 = [v39 componentsJoinedByString:@","];
      [v2 setObject:v41 forKeyedSubscript:@"Gravity"];
    }
    double v42 = [v37 objectForKeyedSubscript:@"NoiseCharacteristics"];
    id v43 = v42;
    if (v42)
    {
      uint64_t v44 = [v42 componentsJoinedByString:@","];
      [v2 setObject:v44 forKeyedSubscript:@"ImuNoiseCharacteristics"];
    }
  }
  uint64_t v45 = (void *)[v2 copy];

  return v45;
}

uint64_t ARParseAndAddImuCalibrationParameters(void *a1)
{
  v24[3] = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = [v1 valueForKey:@"Gravity"];
  int v3 = [v2 componentsSeparatedByString:@","];
  if ((unint64_t)[v3 count] > 2)
  {
    uint64_t v6 = 0;
    memset(v24, 0, 24);
    do
    {
      uint64_t v7 = [v3 objectAtIndex:v6];
      [v7 doubleValue];
      v24[v6] = v8;

      ++v6;
    }
    while (v6 != 3);
    uint64_t v9 = [v1 valueForKey:@"ImuNoiseCharacteristics"];
    uint64_t v10 = [v9 componentsSeparatedByString:@","];
    if ((unint64_t)[v10 count] >= 4)
    {
      uint64_t v12 = 0;
      memset(buf, 0, sizeof(buf));
      do
      {
        uint64_t v13 = [v10 objectAtIndex:v12];
        [v13 doubleValue];
        buf[v12] = v14;

        ++v12;
      }
      while (v12 != 4);
      id v15 = [v1 valueForKey:@"AccelerometerTimestampCorrection"];
      [v15 doubleValue];

      uint64_t v5 = CV3DSLAMCalibrationAddIMUParameters();
      if (v5)
      {
        __int16 v16 = _ARLogGeneral_13();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          if (v5 > 6) {
            float v17 = &stru_1F120C8F0;
          }
          else {
            float v17 = off_1E6186A88[(int)v5 - 1];
          }
          int v19 = 136315394;
          uint64_t v20 = "CV3DSLAMCalibrationReturn ARParseAndAddImuCalibrationParameters(NSDictionary *__strong _Nonnull, CV3DSLA"
                "MMutableCalibrationRef _Nonnull)";
          __int16 v21 = 2112;
          unint64_t v22 = v17;
          _os_log_impl(&dword_1B88A2000, v16, OS_LOG_TYPE_ERROR, "%s: CV3DSLAMCalibrationAddIMUParameters failed (result=%@)", (uint8_t *)&v19, 0x16u);
        }
      }
    }
    else
    {
      uint64_t v11 = _ARLogGeneral_13();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf[0]) = 136446466;
        *(void *)((char *)buf + 4) = "CV3DSLAMCalibrationReturn ARParseAndAddImuCalibrationParameters(NSDictionary *__s"
                                       "trong _Nonnull, CV3DSLAMMutableCalibrationRef _Nonnull)";
        WORD2(buf[1]) = 1024;
        *(_DWORD *)((char *)&buf[1] + 6) = [v10 count];
        _os_log_impl(&dword_1B88A2000, v11, OS_LOG_TYPE_ERROR, "%{public}s: wrong imuNoiseCharacteristicsArray (imuNoiseCharacteristicsArray.count=%d)", (uint8_t *)buf, 0x12u);
      }

      uint64_t v5 = 1;
    }
  }
  else
  {
    id v4 = _ARLogGeneral_13();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf[0]) = 136446466;
      *(void *)((char *)buf + 4) = "CV3DSLAMCalibrationReturn ARParseAndAddImuCalibrationParameters(NSDictionary *__str"
                                     "ong _Nonnull, CV3DSLAMMutableCalibrationRef _Nonnull)";
      WORD2(buf[1]) = 1024;
      *(_DWORD *)((char *)&buf[1] + 6) = [v3 count];
      _os_log_impl(&dword_1B88A2000, v4, OS_LOG_TYPE_ERROR, "%{public}s: wrong gravityArray (gravityArray.count=%d)", (uint8_t *)buf, 0x12u);
    }

    uint64_t v5 = 1;
  }

  return v5;
}

uint64_t ARGetLensTypeFromCalibrationDictionary(void *a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  id v1 = [a1 objectForKey:*MEMORY[0x1E4F4D530]];
  uint64_t v2 = [v1 objectForKey:*MEMORY[0x1E4F4D540]];
  int v3 = [v2 valueForKey:*MEMORY[0x1E4F4D548]];
  if ([v3 isEqualToString:@"Perspective"])
  {
    uint64_t v4 = 1;
  }
  else if ([v3 isEqualToString:@"Fisheye"])
  {
    uint64_t v4 = 2;
  }
  else if ([v3 isEqualToString:@"FlyoverPerspective"])
  {
    uint64_t v4 = 3;
  }
  else if ([v3 isEqualToString:@"NoDistortion"])
  {
    uint64_t v4 = 4;
  }
  else
  {
    uint64_t v5 = _ARLogGeneral_13();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      int v7 = 136446210;
      uint64_t v8 = "ARLensType ARGetLensTypeFromCalibrationDictionary(NSDictionary *__strong _Nonnull)";
      _os_log_impl(&dword_1B88A2000, v5, OS_LOG_TYPE_ERROR, "%{public}s: ARLensType not configured in calibration directory", (uint8_t *)&v7, 0xCu);
    }

    uint64_t v4 = 0;
  }

  return v4;
}

float ARGetIntrinsicsFromCalibrationDictionary(void *a1)
{
  id v1 = [a1 objectForKey:*MEMORY[0x1E4F4D530]];
  CFDictionaryRef v2 = [v1 objectForKey:*MEMORY[0x1E4F4D540]];
  point.float x = 0.0;
  point.y = 0.0;
  v13.float x = 0.0;
  v13.y = 0.0;
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v2, (const void *)*MEMORY[0x1E4F4D538]);
  CGPointMakeWithDictionaryRepresentation(Value, &point);
  CFDictionaryRef v4 = (const __CFDictionary *)CFDictionaryGetValue(v2, (const void *)*MEMORY[0x1E4F4D550]);
  CGPointMakeWithDictionaryRepresentation(v4, &v13);
  float x = point.x;
  float v12 = x;

  __asm { FMOV            V2.4S, #1.0 }
  return v12;
}

void ARGetRadialDistortionFromCalibrationDictionary(void *a1@<X0>, _OWORD *a2@<X8>)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  int v3 = [a1 objectForKey:*MEMORY[0x1E4F4D530]];
  CFDictionaryRef v4 = [v3 objectForKey:*MEMORY[0x1E4F4D540]];
  uint64_t v5 = [v4 objectForKey:*MEMORY[0x1E4F4D558]];
  if ((unint64_t)[v5 count] < 3)
  {
    id v15 = _ARLogGeneral_13();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)vImage_Buffer buf = 67109120;
      int v21 = [v5 count];
      _os_log_impl(&dword_1B88A2000, v15, OS_LOG_TYPE_ERROR, "ARGetRadialDistortionFromCalibrationDictionary: wrong radialDistortion coeffs (coefficients.count = %d)", buf, 8u);
    }

    long long v13 = 0uLL;
    long long v14 = 0uLL;
  }
  else
  {
    uint64_t v6 = [v5 objectAtIndexedSubscript:0];
    [v6 doubleValue];
    uint64_t v18 = v7;

    uint64_t v8 = [v5 objectAtIndexedSubscript:1];
    [v8 doubleValue];
    uint64_t v16 = v9;

    uint64_t v10 = [v5 objectAtIndexedSubscript:2];
    [v10 doubleValue];
    *(void *)&long long v11 = v18;
    *((void *)&v11 + 1) = v16;
    long long v19 = v11;
    long long v17 = v12;

    long long v14 = v17;
    long long v13 = v19;
  }
  *a2 = v13;
  a2[1] = v14;
}

__n128 ARGetTangentialDistortionFromCalibrationDictionary(void *a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  id v1 = [a1 objectForKey:*MEMORY[0x1E4F4D530]];
  CFDictionaryRef v2 = [v1 objectForKey:*MEMORY[0x1E4F4D540]];
  int v3 = [v2 objectForKey:*MEMORY[0x1E4F4D560]];
  if ((unint64_t)[v3 count] < 2)
  {
    uint64_t v9 = _ARLogGeneral_13();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)vImage_Buffer buf = 67109120;
      int v14 = [v3 count];
      _os_log_impl(&dword_1B88A2000, v9, OS_LOG_TYPE_ERROR, "ARGetTangentialDistortionFromCalibrationDictionary: wrong tangentialDistortion coeffs (coefficients.count = %d)", buf, 8u);
    }

    long long v12 = 0u;
  }
  else
  {
    CFDictionaryRef v4 = [v3 objectAtIndexedSubscript:0];
    [v4 doubleValue];
    uint64_t v11 = v5;

    uint64_t v6 = [v3 objectAtIndexedSubscript:1];
    [v6 doubleValue];
    *(void *)&long long v7 = v11;
    *((void *)&v7 + 1) = v8;
    long long v12 = v7;
  }
  return (__n128)v12;
}

uint64_t ARSurfaceOrientationForPlaneDetectionType(char a1)
{
  uint64_t v1 = 3;
  if ((~a1 & 3) != 0)
  {
    if (a1 < 0) {
      LODWORD(v1) = 3;
    }
    else {
      LODWORD(v1) = 1;
    }
    if ((a1 & 0x81) != 0) {
      return v1;
    }
    else {
      return a1 & 2;
    }
  }
  return v1;
}

uint64_t ARSurfaceExtentTypeForPlaneDetectionType(__int16 a1)
{
  if ((a1 & 0x200) != 0) {
    return 15;
  }
  else {
    return 7;
  }
}

uint64_t ARPlaneClassificationForSceneUnderstandingLabel(int a1)
{
  if ((a1 - 1) > 9) {
    return 0;
  }
  else {
    return qword_1B8A2F300[a1 - 1];
  }
}

__CFString *NSStringFromSceneUnderstandingLabel(unsigned int a1)
{
  if (a1 > 0xC) {
    return @"Empty";
  }
  else {
    return off_1E6186AB8[a1];
  }
}

void ARInitializeHitTestIntent(uint64_t a1, void *a2, int a3, simd_float4 a4, simd_float4 a5, simd_float4 a6, simd_float4 a7)
{
}

void ARInitializeHitTestIntentWithExtentCheck(uint64_t a1, void *a2, int a3, int a4, simd_float4 a5, simd_float4 a6, simd_float4 a7, simd_float4 a8)
{
  v30.columns[2] = a7;
  v30.columns[3] = a8;
  v30.columns[0] = a5;
  v30.columns[1] = a6;
  id v31 = a2;
  [v31 direction];
  float32x4_t v27 = v11;
  simd_float4x4 v35 = __invert_f4(v30);
  v30.columns[1] = v35.columns[0];
  v30.columns[2] = v35.columns[1];
  v30.columns[3] = v35.columns[2];
  float32x4_t v28 = vmlaq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v35.columns[0], v27.f32[0]), (float32x4_t)v35.columns[1], *(float32x2_t *)v27.f32, 1), (float32x4_t)v35.columns[2], v27, 2), (float32x4_t)0, (float32x4_t)v35.columns[3]);
  v30.columns[0] = v35.columns[3];
  *(double *)v12.i64 = ARRenderingToVisionCoordinateTransform();
  float32x4_t v29 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v12, v28.f32[0]), v13, *(float32x2_t *)v28.f32, 1), v14, v28, 2), v15, v28, 3);
  [v31 origin];
  v30.columns[3] = (simd_float4)vaddq_f32((float32x4_t)v30.columns[0], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v30.columns[1], v16.f32[0]), (float32x4_t)v30.columns[2], *(float32x2_t *)v16.f32, 1), (float32x4_t)v30.columns[3], v16, 2));
  *(double *)v17.i64 = ARRenderingToVisionCoordinateTransform();
  uint64_t v18 = 0;
  float32x4_t v22 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v17, v30.columns[3].f32[0]), v19, *(float32x2_t *)v30.columns[3].f32, 1), v20, (float32x4_t)v30.columns[3], 2), v21, (float32x4_t)v30.columns[3], 3);
  do
  {
    float32x4_t v32 = v22;
    uint64_t v23 = (double *)(a1 + 8 * v18);
    *uint64_t v23 = *(float *)((unint64_t)&v32 & 0xFFFFFFFFFFFFFFF3 | (4 * (v18 & 3)));
    float32x4_t v33 = v29;
    void v23[3] = *(float *)((unint64_t)&v33 & 0xFFFFFFFFFFFFFFF3 | (4 * (v18++ & 3)));
  }
  while (v18 != 3);
  *(_OWORD *)(a1 + 48) = xmmword_1B8A2ECE0;
  *(CFAbsoluteTime *)(a1 + 88) = CFAbsoluteTimeGetCurrent();
  *(_DWORD *)(a1 + 72) = a3;
  *(_DWORD *)(a1 + 76) = 0;
  *(_DWORD *)(a1 + 84) = 0;
  uint64_t v24 = [v31 target];
  if (v24)
  {
    if (v24 == 1)
    {
      int v25 = 1;
      a4 = 1;
    }
    else
    {
      if (v24 != 2) {
        goto LABEL_10;
      }
      int v25 = 3;
    }
  }
  else
  {
    int v25 = 1;
  }
  *(_DWORD *)(a1 + 76) = v25;
  *(_DWORD *)(a1 + 84) = a4;
LABEL_10:
  unint64_t v26 = [v31 targetAlignment];
  if (v26 <= 2) {
    *(_DWORD *)(a1 + 80) = dword_1B8A2F350[v26];
  }
  *(void *)(a1 + 64) = CFUUIDCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
}

void ARReleaseHitTestIntent(uint64_t a1)
{
  if (a1)
  {
    uint64_t v1 = *(const void **)(a1 + 64);
    if (v1) {
      CFRelease(v1);
    }
  }
}

id ARAnchorsFromCV3DAnchorsArray(void *a1, void *a2, double a3)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  id v30 = a2;
  uint64_t v6 = [v5 count];
  id v31 = [MEMORY[0x1E4F1CA80] setWithCapacity:v6];
  if (v6)
  {
    uint64_t v7 = 0;
    unint64_t v8 = 0x1E4F29000uLL;
    do
    {
      [v5 objectAtIndex:v7];
      uint64_t v9 = CV3DSLAMAnchorCopyAnchorID();
      if (v9)
      {
        uint64_t v10 = (const void *)v9;
        float32x4_t v11 = objc_msgSend(*(id *)(v8 + 296), "ar_UUIDWithCFUUIDRef:", v9);
        CFRelease(v10);
        float32x4_t v12 = (void *)CV3DSLAMAnchorCopySessionID();
        float32x4_t v13 = v12;
        if (v12)
        {
          float32x4_t v14 = objc_msgSend(*(id *)(v8 + 296), "ar_UUIDWithIntegerValue:", objc_msgSend(v12, "integerValue"));
        }
        else
        {
          float32x4_t v16 = _ARLogGeneral_13();
          if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)vImage_Buffer buf = 138412290;
            *(void *)&uint8_t buf[4] = 0;
            _os_log_impl(&dword_1B88A2000, v16, OS_LOG_TYPE_INFO, "Unable to parse SLAM anchor session identifier: %@", buf, 0xCu);

            unint64_t v8 = 0x1E4F29000;
          }

          float32x4_t v14 = 0;
        }
        if (CV3DSLAMAnchorCopyPose())
        {
          v44.columns[2] = 0u;
          v44.columns[3] = 0u;
          v44.columns[0] = 0u;
          v44.columns[1] = 0u;
          simd_float4x4 v36 = __invert_f4(v44);
          *(double *)v17.i64 = ARVisionToRenderingCoordinateTransform();
          uint64_t v21 = 0;
          simd_float4x4 v37 = v36;
          *(_OWORD *)vImage_Buffer buf = 0u;
          float32x4_t v39 = 0u;
          float32x4_t v40 = 0u;
          float32x4_t v41 = 0u;
          do
          {
            *(float32x4_t *)&buf[v21 * 16] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v17, COERCE_FLOAT(*(_OWORD *)&v37.columns[v21])), v18, *(float32x2_t *)v37.columns[v21].f32, 1), v19, (float32x4_t)v37.columns[v21], 2), v20, (float32x4_t)v37.columns[v21], 3);
            ++v21;
          }
          while (v21 != 4);
          float32x4_t v34 = v39;
          float32x4_t v35 = *(float32x4_t *)buf;
          float32x4_t v32 = v41;
          float32x4_t v33 = v40;
          *(double *)v22.i64 = ARRenderingToVisionCoordinateTransform();
          uint64_t v23 = 0;
          v37.columns[0] = v22;
          v37.columns[1] = v24;
          v37.columns[2] = v25;
          v37.columns[3] = v26;
          *(_OWORD *)vImage_Buffer buf = 0u;
          float32x4_t v39 = 0u;
          float32x4_t v40 = 0u;
          float32x4_t v41 = 0u;
          do
          {
            *(float32x4_t *)&buf[v23 * 16] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v35, COERCE_FLOAT(*(_OWORD *)&v37.columns[v23])), v34, *(float32x2_t *)v37.columns[v23].f32, 1), v33, (float32x4_t)v37.columns[v23], 2), v32, (float32x4_t)v37.columns[v23], 3);
            ++v23;
          }
          while (v23 != 4);
          float32x4_t v27 = -[ARAnchor initWithIdentifier:transform:]([ARAnchor alloc], "initWithIdentifier:transform:", v11, *(double *)buf, *(double *)v39.i64, *(double *)v40.i64, *(double *)v41.i64);
          [(ARAnchor *)v27 setSessionIdentifier:v14];
          [(ARAnchor *)v27 setLastUpdateTimestamp:a3];
          [v31 addObject:v27];
        }
        else
        {
          float32x4_t v28 = _ARLogGeneral_13();
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)vImage_Buffer buf = 138412290;
            *(void *)&uint8_t buf[4] = 0;
            _os_log_impl(&dword_1B88A2000, v28, OS_LOG_TYPE_ERROR, "Unable to parse SLAM anchor transform: %@", buf, 0xCu);

            unint64_t v8 = 0x1E4F29000;
          }
        }
      }
      else
      {
        float32x4_t v15 = _ARLogGeneral_13();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)vImage_Buffer buf = 138412290;
          *(void *)&uint8_t buf[4] = 0;
          _os_log_impl(&dword_1B88A2000, v15, OS_LOG_TYPE_ERROR, "Unable to parse SLAM anchor identifier: %@", buf, 0xCu);
        }
      }
      ++v7;
    }
    while (v7 != v6);
  }

  return v31;
}

uint64_t ARRequestIDsFromSLAMAnchorUpdate()
{
  return MEMORY[0x1E4F1CBF0];
}

id ARGetAnchorIdentifierFromCMData(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  char v7 = 0;
  long long v6 = 0uLL;
  id v5 = 0;
  if (MEMORY[0x1BA9C47C0](a1, &v7, &v6, &v5))
  {
    *(_OWORD *)vImage_Buffer buf = v6;
    uint64_t v1 = (void *)[objc_alloc(MEMORY[0x1E4F29128]) initWithUUIDBytes:buf];
  }
  else
  {
    CFDictionaryRef v2 = _ARLogGeneral_13();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      int v3 = v5;
      *(_DWORD *)vImage_Buffer buf = 138412290;
      *(void *)&uint8_t buf[4] = v5;
      _os_log_impl(&dword_1B88A2000, v2, OS_LOG_TYPE_ERROR, "Unable to parse anchor metadata: %@", buf, 0xCu);
    }
    uint64_t v1 = 0;
  }
  return v1;
}

__n128 ARCV3DColorComponentsForRawSemantics(unint64_t a1)
{
  if (ARDeviceSupportsJasper())
  {
    if (_CV3DColorMappingForRawSemantics_onceToken != -1) {
      dispatch_once(&_CV3DColorMappingForRawSemantics_onceToken, &__block_literal_global_373);
    }
    result.n128_u64[0] = 0;
    if (a1 <= 0x64)
    {
      int v3 = &_CV3DColorMappingForRawSemantics_cv3DColors;
      return (__n128)v3[a1];
    }
  }
  else
  {
    if (_CV3DColorComponentsFor12ClassModelIndex_onceToken != -1) {
      dispatch_once(&_CV3DColorComponentsFor12ClassModelIndex_onceToken, &__block_literal_global_375);
    }
    result.n128_u64[0] = 0;
    if (a1 <= 0xB)
    {
      int v3 = &_CV3DColorComponentsFor12ClassModelIndex_cv3DColors;
      return (__n128)v3[a1];
    }
  }
  return result;
}

uint64_t _CV3DRawSemanticsValueForARKitSemantics(uint64_t a1)
{
  if ((unint64_t)(a1 - 1) > 6) {
    return 0;
  }
  else {
    return qword_1B8A2F360[a1 - 1];
  }
}

long long *ARCV3DColorComponentsForARKitSemanticsLUT8Elements()
{
  if (ARCV3DColorComponentsForARKitSemanticsLUT8Elements_onceToken != -1) {
    dispatch_once(&ARCV3DColorComponentsForARKitSemanticsLUT8Elements_onceToken, &__block_literal_global_38);
  }
  return &ARCV3DColorComponentsForARKitSemanticsLUT8Elements_cv3DColors;
}

double __ARCV3DColorComponentsForARKitSemanticsLUT8Elements_block_invoke()
{
  if (_CV3DColorMappingForRawSemantics_onceToken != -1) {
    dispatch_once(&_CV3DColorMappingForRawSemantics_onceToken, &__block_literal_global_373);
  }
  double result = *(double *)&_CV3DColorMappingForRawSemantics_cv3DColors;
  ARCV3DColorComponentsForARKitSemanticsLUT8Elements_cv3DColors = _CV3DColorMappingForRawSemantics_cv3DColors;
  *(_OWORD *)algn_1E9EED610 = xmmword_1E9EED6C0;
  xmmword_1E9EED620 = xmmword_1E9EED6B0;
  unk_1E9EED630 = xmmword_1E9EED6D0;
  xmmword_1E9EED640 = xmmword_1E9EED7D0;
  unk_1E9EED650 = xmmword_1E9EED790;
  xmmword_1E9EED660 = xmmword_1E9EED710;
  unk_1E9EED670 = xmmword_1E9EED700;
  return result;
}

__n128 ARCV3DColorComponentsForARKitSemantics(unint64_t a1)
{
  if (ARCV3DColorComponentsForARKitSemanticsLUT8Elements_onceToken != -1) {
    dispatch_once(&ARCV3DColorComponentsForARKitSemanticsLUT8Elements_onceToken, &__block_literal_global_38);
  }
  result.n128_u64[0] = 0;
  if (a1 <= 7) {
    return (__n128)ARCV3DColorComponentsForARKitSemanticsLUT8Elements_cv3DColors[a1];
  }
  return result;
}

BOOL __ARSkipCrashOnCrash_block_invoke()
{
  BOOL result = +[ARKitUserDefaults BOOLForKey:@"com.apple.arkit.skipCrashOnARCrash"];
  ARSkipCrashOnCrash_skipCrashOnCrash = result;
  return result;
}

void sub_1B8924FDC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8925098(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B892510C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8925480(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8925544(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B892560C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89257D0(_Unwind_Exception *a1)
{
  CFDictionaryRef v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1B8925968(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8925B20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8925BD8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8925CC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id _ARLogSensor_3()
{
  if (_ARLogSensor_onceToken_6 != -1) {
    dispatch_once(&_ARLogSensor_onceToken_6, &__block_literal_global_235_0);
  }
  uint64_t v0 = (void *)_ARLogSensor_logObj_6;
  return v0;
}

id _ARLogSensor_4()
{
  if (_ARLogSensor_onceToken_7 != -1) {
    dispatch_once(&_ARLogSensor_onceToken_7, &__block_literal_global_375_0);
  }
  uint64_t v0 = (void *)_ARLogSensor_logObj_7;
  return v0;
}

id _ARLogTechnique_3()
{
  if (_ARLogTechnique_onceToken_5 != -1) {
    dispatch_once(&_ARLogTechnique_onceToken_5, &__block_literal_global_557);
  }
  uint64_t v0 = (void *)_ARLogTechnique_logObj_5;
  return v0;
}

double HeadingFromRot(uint64_t a1)
{
  double v1 = *(double *)(a1 + 64);
  double v2 = *(double *)(a1 + 72);
  if (v2 * v2 + v1 * v1 < 0.01) {
    return NAN;
  }
  double result = atan2(-v1, -v2) * 0.318309886 * 180.0;
  if (fabs(result) < 0.001) {
    double result = 0.0;
  }
  if (result < 0.0) {
    double result = result + 360.0;
  }
  if (result >= 360.0) {
    HeadingFromRot();
  }
  return result;
}

__n128 MatrixFromTransform4Dof@<Q0>(__n128 *a1@<X0>, uint64_t a2@<X8>)
{
  __double2 v5 = __sincos_stret(a1[1].n128_f64[1] * 3.14159265 / 180.0);
  *(double *)&long long v4 = v5.__cosval;
  __asm { FMOV            V2.2D, #1.0 }
  *(void *)&_Q2 = a1[1].n128_u64[0];
  *(double *)&long long v11 = -v5.__sinval;
  *((void *)&v11 + 1) = *(void *)&v5.__cosval;
  *((void *)&v4 + 1) = *(void *)&v5.__sinval;
  __n128 result = *a1;
  *(_OWORD *)a2 = v4;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = v11;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = xmmword_1B8A2F430;
  *(__n128 *)(a2 + 96) = result;
  *(_OWORD *)(a2 + 112) = _Q2;
  return result;
}

void Transform4DofFromMatrix(const simd_double4x4 *a1@<X0>, uint64_t a2@<X8>)
{
  double v4 = atan2(a1->columns[0].f64[0], a1->columns[1].f64[0]) * 0.318309886 * 180.0 + -90.0;
  if (v4 < 0.0) {
    double v4 = v4 + 360.0;
  }
  *(_OWORD *)a2 = *(_OWORD *)a1->columns[3].f64;
  *(double *)(a2 + 16) = a1->columns[3].f64[2];
  *(double *)(a2 + 24) = v4;
  *(unsigned char *)(a2 + 32) = 0;
}

float64x2_t *ConvertIMU@<X0>(float64x2_t *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = 0;
  float64x2_t v4 = *result;
  float64x2_t v3 = result[1];
  float64x2_t v6 = result[2];
  float64x2_t v5 = result[3];
  float64x2_t v8 = result[4];
  float64x2_t v7 = result[5];
  float64x2_t v10 = result[6];
  float64x2_t v9 = result[7];
  v14[2] = xmmword_1B8A2F450;
  memset(&v14[3], 0, 32);
  v14[5] = xmmword_1B8A2F450;
  void v14[6] = 0u;
  v14[7] = xmmword_1B8A2F460;
  do
  {
    float64x2_t v12 = (float64x2_t)v14[v2];
    float64x2_t v11 = (float64x2_t)v14[v2 + 1];
    float32x4_t v13 = (float64x2_t *)(a2 + v2 * 16);
    float64x2_t *v13 = vmlaq_laneq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(v4, v12.f64[0]), v6, v12, 1), v8, v11.f64[0]), v10, v11, 1);
    v13[1] = vmlaq_laneq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(v3, v12.f64[0]), v5, v12, 1), v7, v11.f64[0]), v9, v11, 1);
    v2 += 2;
  }
  while (v2 != 8);
  return result;
}

id ARTechniqueProcessDataClassApprovedList()
{
  if (ARTechniqueProcessDataClassApprovedList_onceToken != -1) {
    dispatch_once(&ARTechniqueProcessDataClassApprovedList_onceToken, &__block_literal_global_43);
  }
  uint64_t v0 = (void *)ARTechniqueProcessDataClassApprovedList_techniqueProcessDataClassApprovedList;
  return v0;
}

void __ARTechniqueProcessDataClassApprovedList_block_invoke()
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v0 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v4 = objc_opt_class();
  uint64_t v5 = objc_opt_class();
  uint64_t v6 = objc_opt_class();
  uint64_t v7 = objc_opt_class();
  uint64_t v8 = objc_opt_class();
  uint64_t v9 = objc_opt_class();
  uint64_t v10 = objc_opt_class();
  uint64_t v11 = objc_opt_class();
  uint64_t v12 = objc_opt_class();
  uint64_t v13 = objc_opt_class();
  uint64_t v14 = objc_opt_class();
  uint64_t v15 = objc_opt_class();
  uint64_t v16 = objc_opt_class();
  uint64_t v17 = objc_opt_class();
  uint64_t v18 = objc_opt_class();
  uint64_t v19 = objc_opt_class();
  uint64_t v20 = objc_opt_class();
  uint64_t v21 = objc_opt_class();
  uint64_t v22 = objc_opt_class();
  uint64_t v23 = objc_opt_class();
  uint64_t v24 = objc_opt_class();
  uint64_t v25 = objc_opt_class();
  uint64_t v26 = objc_opt_class();
  double v1 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v4 count:23];
  objc_msgSend(v0, "setWithArray:", v1, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,
    v20,
    v21,
    v22,
    v23,
    v24,
  uint64_t v2 = v25);
  float64x2_t v3 = (void *)ARTechniqueProcessDataClassApprovedList_techniqueProcessDataClassApprovedList;
  ARTechniqueProcessDataClassApprovedList_techniqueProcessDataClassApprovedList = v2;
}

id ARTechniqueResultDataClassApprovedList()
{
  if (ARTechniqueResultDataClassApprovedList_onceToken != -1) {
    dispatch_once(&ARTechniqueResultDataClassApprovedList_onceToken, &__block_literal_global_28);
  }
  uint64_t v0 = (void *)ARTechniqueResultDataClassApprovedList_techniqueResultDataClassApprovedList;
  return v0;
}

void __ARTechniqueResultDataClassApprovedList_block_invoke()
{
  float32x4_t v41 = (void *)MEMORY[0x1E4F1CA48];
  uint64_t v40 = objc_opt_class();
  uint64_t v39 = objc_opt_class();
  uint64_t v38 = objc_opt_class();
  uint64_t v37 = objc_opt_class();
  uint64_t v36 = objc_opt_class();
  uint64_t v35 = objc_opt_class();
  uint64_t v34 = objc_opt_class();
  uint64_t v33 = objc_opt_class();
  uint64_t v32 = objc_opt_class();
  uint64_t v31 = objc_opt_class();
  uint64_t v30 = objc_opt_class();
  uint64_t v29 = objc_opt_class();
  uint64_t v28 = objc_opt_class();
  uint64_t v27 = objc_opt_class();
  uint64_t v26 = objc_opt_class();
  uint64_t v25 = objc_opt_class();
  uint64_t v24 = objc_opt_class();
  uint64_t v23 = objc_opt_class();
  uint64_t v22 = objc_opt_class();
  uint64_t v21 = objc_opt_class();
  uint64_t v20 = objc_opt_class();
  uint64_t v19 = objc_opt_class();
  uint64_t v18 = objc_opt_class();
  uint64_t v17 = objc_opt_class();
  uint64_t v16 = objc_opt_class();
  uint64_t v15 = objc_opt_class();
  uint64_t v14 = objc_opt_class();
  uint64_t v13 = objc_opt_class();
  uint64_t v12 = objc_opt_class();
  uint64_t v0 = objc_opt_class();
  uint64_t v1 = objc_opt_class();
  uint64_t v2 = objc_opt_class();
  uint64_t v3 = objc_opt_class();
  uint64_t v4 = objc_opt_class();
  uint64_t v5 = objc_opt_class();
  uint64_t v6 = objc_opt_class();
  uint64_t v7 = objc_opt_class();
  uint64_t v8 = objc_opt_class();
  uint64_t v9 = objc_opt_class();
  objc_msgSend(v41, "arrayWithObjects:", v40, v39, v38, v37, v36, v35, v34, v33, v32, v31, v30, v29, v28, v27, v26, v25, v24,
    v23,
    v22,
    v21,
    v20,
    v19,
    v18,
    v17,
    v16,
    v15,
    v14,
    v13,
    v12,
    v0,
    v1,
    v2,
    v3,
    v4,
    v5,
    v6,
    v7,
    v8,
    v9,
    objc_opt_class(),
  uint64_t v42 = 0);
  uint64_t v10 = [MEMORY[0x1E4F1CAD0] setWithArray:v42];
  uint64_t v11 = (void *)ARTechniqueResultDataClassApprovedList_techniqueResultDataClassApprovedList;
  ARTechniqueResultDataClassApprovedList_techniqueResultDataClassApprovedList = v10;
}

id ARRemoteTechniqueClientInterfaceWithProtocol(uint64_t a1)
{
  uint64_t v1 = [MEMORY[0x1E4F29280] interfaceWithProtocol:a1];
  uint64_t v2 = ARTechniqueResultDataClassApprovedList();
  [v1 setClasses:v2 forSelector:sel_techniqueDidOutputResultData_timestamp_context_ argumentIndex:0 ofReply:0];

  uint64_t v3 = ARTechniqueResultDataClassApprovedList();
  [v1 setClasses:v3 forSelector:sel_techniqueDidOutputResultData_timestamp_context_ argumentIndex:2 ofReply:0];

  return v1;
}

id ARRemoteTechniqueServiceInterfaceWithProtocol(uint64_t a1)
{
  uint64_t v1 = [MEMORY[0x1E4F29280] interfaceWithProtocol:a1];
  uint64_t v2 = ARTechniqueProcessDataClassApprovedList();
  [v1 setClasses:v2 forSelector:sel_processData_reply_ argumentIndex:0 ofReply:0];

  uint64_t v3 = ARTechniqueProcessDataClassApprovedList();
  [v1 setClasses:v3 forSelector:sel_processData_reply_ argumentIndex:0 ofReply:1];

  uint64_t v4 = ARTechniqueResultDataClassApprovedList();
  [v1 setClasses:v4 forSelector:sel_requestResultDataAtTimestamp_context_ argumentIndex:1 ofReply:0];

  return v1;
}

id _ARLogTechnique_4()
{
  if (_ARLogTechnique_onceToken_6 != -1) {
    dispatch_once(&_ARLogTechnique_onceToken_6, &__block_literal_global_199);
  }
  uint64_t v0 = (void *)_ARLogTechnique_logObj_6;
  return v0;
}

void sub_1B8932EE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B893300C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B89330E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B8933368(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__1(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__1(uint64_t a1)
{
}

void sub_1B8933510(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B89335F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B8933714(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id _ARLogTechnique_5()
{
  if (_ARLogTechnique_onceToken_7 != -1) {
    dispatch_once(&_ARLogTechnique_onceToken_7, &__block_literal_global_45);
  }
  uint64_t v0 = (void *)_ARLogTechnique_logObj_7;
  return v0;
}

void sub_1B8935B3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, void (*a17)(char *))
{
}

BOOL __ARSkipCrashOnCrash_block_invoke_0()
{
  BOOL result = +[ARKitUserDefaults BOOLForKey:@"com.apple.arkit.skipCrashOnARCrash"];
  ARSkipCrashOnCrash_skipCrashOnCrash_0 = result;
  return result;
}

float arkit::gaussian(arkit *this, float a2, float a3)
{
  float v3 = a3 * 6.28318531;
  return expf((float)-(float)(a2 * a2) / (float)(a3 + a3)) * (float)(1.0 / sqrtf(v3));
}

float arkit::invgaussian(arkit *this, float a2, float a3)
{
  float v4 = a3 * 6.28318531;
  return sqrtf(-(float)(logf(sqrtf(v4) * a2) * (float)(a3 + a3)));
}

void arkit::gaussianKernel(arkit *this@<X0>, float a2@<S0>, float **a3@<X8>)
{
  if ((int)this <= 0) {
    arkit::gaussianKernel();
  }
  int v3 = (int)this;
  if ((this & 0x80000001) != 1) {
    arkit::gaussianKernel();
  }
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  if (a2 == 0.0)
  {
    uint64_t v5 = (float *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(a3 + 2), 1uLL);
    uint64_t v6 = *a3;
    uint64_t v7 = a3[1];
    uint64_t v9 = &v5[v8];
    *uint64_t v5 = 1.0;
    uint64_t v10 = v5 + 1;
    while (v7 != v6)
    {
      int v11 = *((_DWORD *)v7-- - 1);
      *((_DWORD *)v5-- - 1) = v11;
    }
    *a3 = v5;
    a3[1] = v10;
    a3[2] = v9;
    if (v6) {
      operator delete(v6);
    }
    a3[1] = v10;
  }
  else
  {
    uint64_t v12 = 0;
    int v13 = 0;
    unsigned int v14 = (this - 1) >> 1;
    float v15 = a2 * 6.28318531;
    float v16 = 1.0 / sqrtf(v15);
    float v17 = a2 + a2;
    uint64_t v18 = a3 + 2;
    float v19 = 0.0;
    do
    {
      float v20 = v16 * expf((float)-(float)((float)(int)(v13 - v14) * (float)(int)(v13 - v14)) / v17);
      if ((unint64_t)v12 >= *v18)
      {
        uint64_t v21 = *a3;
        uint64_t v22 = v12 - *a3;
        unint64_t v23 = v22 + 1;
        if ((unint64_t)(v22 + 1) >> 62) {
          std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v24 = *v18 - (void)v21;
        if (v24 >> 1 > v23) {
          unint64_t v23 = v24 >> 1;
        }
        if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v25 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v25 = v23;
        }
        if (v25)
        {
          uint64_t v26 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(a3 + 2), v25);
          uint64_t v21 = *a3;
          uint64_t v12 = a3[1];
        }
        else
        {
          uint64_t v26 = 0;
        }
        uint64_t v27 = (float *)&v26[4 * v22];
        float *v27 = v20;
        uint64_t v28 = v27 + 1;
        while (v12 != v21)
        {
          int v29 = *((_DWORD *)v12-- - 1);
          *((_DWORD *)v27-- - 1) = v29;
        }
        *a3 = v27;
        a3[1] = v28;
        a3[2] = (float *)&v26[4 * v25];
        if (v21) {
          operator delete(v21);
        }
        uint64_t v12 = v28;
      }
      else
      {
        *v12++ = v20;
      }
      a3[1] = v12;
      float v19 = v19 + *(v12 - 1);
      ++v13;
    }
    while (v13 != v3);
    for (uint64_t i = *a3; i != v12; ++i)
      *uint64_t i = *i / v19;
  }
}

void sub_1B893611C(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void arkit::unflatten(uint64_t *a1@<X0>, uint64_t *a2@<X8>, double a3@<D0>)
{
  int v3 = a2;
  uint64_t v25 = LODWORD(a3);
  if (LODWORD(a3) * HIDWORD(a3) != (a1[1] - *a1) >> 2) {
    arkit::unflatten();
  }
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  if (HIDWORD(a3))
  {
    uint64_t v4 = 0;
    uint64_t v23 = HIDWORD(a3);
    do
    {
      __p = 0;
      uint64_t v27 = 0;
      uint64_t v28 = 0;
      std::vector<std::vector<float>>::push_back[abi:ne180100](v3, (uint64_t)&__p);
      if (__p)
      {
        uint64_t v27 = __p;
        operator delete(__p);
      }
      if (v25)
      {
        for (uint64_t i = 0; i != v25; ++i)
        {
          uint64_t v6 = v3;
          uint64_t v7 = *v3 + 24 * v4;
          uint64_t v8 = (v25 * v4 + i);
          uint64_t v9 = *a1;
          int v11 = (_DWORD **)(v7 + 8);
          uint64_t v10 = *(_DWORD **)(v7 + 8);
          int v13 = (void *)(v7 + 16);
          unint64_t v12 = *(void *)(v7 + 16);
          if ((unint64_t)v10 >= v12)
          {
            float v15 = *(_DWORD **)v7;
            uint64_t v16 = ((uint64_t)v10 - *(void *)v7) >> 2;
            unint64_t v17 = v16 + 1;
            if ((unint64_t)(v16 + 1) >> 62) {
              std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v18 = v12 - (void)v15;
            if (v18 >> 1 > v17) {
              unint64_t v17 = v18 >> 1;
            }
            if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v19 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v19 = v17;
            }
            if (v19)
            {
              float v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)v13, v19);
              uint64_t v10 = *v11;
              float v15 = *(_DWORD **)v7;
            }
            else
            {
              float v20 = 0;
            }
            uint64_t v21 = &v20[4 * v16];
            *(_DWORD *)uint64_t v21 = *(_DWORD *)(v9 + 4 * v8);
            unsigned int v14 = v21 + 4;
            int v3 = v6;
            while (v10 != v15)
            {
              int v22 = *--v10;
              *((_DWORD *)v21 - 1) = v22;
              v21 -= 4;
            }
            *(void *)uint64_t v7 = v21;
            *int v11 = v14;
            void *v13 = &v20[4 * v19];
            if (v15) {
              operator delete(v15);
            }
          }
          else
          {
            *uint64_t v10 = *(_DWORD *)(v9 + 4 * v8);
            unsigned int v14 = v10 + 1;
          }
          *int v11 = v14;
        }
      }
      ++v4;
    }
    while (v4 != v23);
  }
}

void sub_1B8936308(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  unsigned int v14 = v13;
  if (__p)
  {
    a13 = (uint64_t)__p;
    operator delete(__p);
  }
  __p = v14;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::vector<float>>::push_back[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  uint64_t v7 = *(void **)(result - 8);
  if ((unint64_t)v7 >= v6)
  {
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v7 - *a1) >> 3);
    unint64_t v10 = v9 + 1;
    if (v9 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 3);
    if (2 * v11 > v10) {
      unint64_t v10 = 2 * v11;
    }
    if (v11 >= 0x555555555555555) {
      unint64_t v12 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v12 = v10;
    }
    v16[4] = result;
    int v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<float>>>(result, v12);
    unsigned int v14 = &v13[24 * v9];
    v16[0] = v13;
    v16[1] = v14;
    v16[3] = &v13[24 * v15];
    *((void *)v14 + 1) = 0;
    *((void *)v14 + 2) = 0;
    *(void *)unsigned int v14 = 0;
    *(_OWORD *)unsigned int v14 = *(_OWORD *)a2;
    *((void *)v14 + 2) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    _OWORD v16[2] = v14 + 24;
    std::vector<std::vector<float>>::__swap_out_circular_buffer(a1, v16);
    uint64_t v8 = (void *)a1[1];
    uint64_t result = std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)v16);
  }
  else
  {
    *uint64_t v7 = 0;
    v7[1] = 0;
    v7[2] = 0;
    *(_OWORD *)uint64_t v7 = *(_OWORD *)a2;
    v7[2] = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    uint64_t v8 = v7 + 3;
    a1[1] = (uint64_t)(v7 + 3);
  }
  a1[1] = (uint64_t)v8;
  return result;
}

void sub_1B893646C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void arkit::unflatten(void *a1@<X0>, uint64_t *a2@<X8>, __n128 a3@<Q0>)
{
  uint64_t v3 = a3.n128_u32[0];
  uint64_t v32 = a3.n128_u32[1];
  if (a3.n128_u32[0] * a3.n128_u32[1] * a3.n128_u32[2] != (uint64_t)(a1[1] - *a1) >> 2) {
    arkit::unflatten();
  }
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  if (a3.n128_u32[2])
  {
    uint64_t v4 = a1;
    uint64_t v5 = 0;
    uint64_t v30 = a3.n128_u32[2];
    do
    {
      __p = 0;
      uint64_t v37 = 0;
      uint64_t v38 = 0;
      std::vector<std::vector<std::vector<float>>>::push_back[abi:ne180100](a2, (uint64_t)&__p);
      p_p = &__p;
      std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&p_p);
      if (v32)
      {
        uint64_t v6 = 0;
        int v31 = v32 * v5;
        do
        {
          uint64_t v34 = v6;
          uint64_t v7 = (uint64_t *)(*a2 + 24 * v5);
          __p = 0;
          uint64_t v37 = 0;
          uint64_t v38 = 0;
          std::vector<std::vector<float>>::push_back[abi:ne180100](v7, (uint64_t)&__p);
          if (__p)
          {
            uint64_t v37 = __p;
            operator delete(__p);
          }
          uint64_t v8 = v34;
          if (v3)
          {
            uint64_t v9 = 0;
            int v10 = (v31 + v34) * v3;
            int v33 = v10;
            do
            {
              uint64_t v11 = *(void *)(*a2 + 24 * v5) + 24 * v8;
              uint64_t v12 = (v10 + v9);
              uint64_t v13 = *v4;
              uint64_t v15 = (_DWORD **)(v11 + 8);
              unsigned int v14 = *(_DWORD **)(v11 + 8);
              unint64_t v17 = (void *)(v11 + 16);
              unint64_t v16 = *(void *)(v11 + 16);
              if ((unint64_t)v14 >= v16)
              {
                uint64_t v19 = v5;
                uint64_t v20 = v3;
                uint64_t v21 = v4;
                int v22 = *(_DWORD **)v11;
                uint64_t v23 = ((uint64_t)v14 - *(void *)v11) >> 2;
                unint64_t v24 = v23 + 1;
                if ((unint64_t)(v23 + 1) >> 62) {
                  std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
                }
                uint64_t v25 = v16 - (void)v22;
                if (v25 >> 1 > v24) {
                  unint64_t v24 = v25 >> 1;
                }
                if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFFCLL) {
                  unint64_t v26 = 0x3FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v26 = v24;
                }
                if (v26)
                {
                  uint64_t v27 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)v17, v26);
                  unsigned int v14 = *v15;
                  int v22 = *(_DWORD **)v11;
                }
                else
                {
                  uint64_t v27 = 0;
                }
                uint64_t v28 = &v27[4 * v23];
                *(_DWORD *)uint64_t v28 = *(_DWORD *)(v13 + 4 * v12);
                uint64_t v18 = v28 + 4;
                uint64_t v4 = v21;
                while (v14 != v22)
                {
                  int v29 = *--v14;
                  *((_DWORD *)v28 - 1) = v29;
                  v28 -= 4;
                }
                *(void *)uint64_t v11 = v28;
                _DWORD *v15 = v18;
                *unint64_t v17 = &v27[4 * v26];
                uint64_t v3 = v20;
                if (v22) {
                  operator delete(v22);
                }
                uint64_t v5 = v19;
                uint64_t v8 = v34;
                int v10 = v33;
              }
              else
              {
                _DWORD *v14 = *(_DWORD *)(v13 + 4 * v12);
                uint64_t v18 = v14 + 1;
              }
              _DWORD *v15 = v18;
              ++v9;
            }
            while (v9 != v3);
          }
          uint64_t v6 = v8 + 1;
        }
        while (v6 != v32);
      }
      ++v5;
    }
    while (v5 != v30);
  }
}

void sub_1B89366D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *__p, uint64_t a16, uint64_t a17, void **p_p)
{
  p_p = &__p;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&p_p);
  __p = a14;
  std::vector<std::vector<std::vector<float>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  _Unwind_Resume(a1);
}

void **std::vector<std::vector<std::vector<float>>>::push_back[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (void **)(a1 + 2);
  unint64_t v5 = v6;
  uint64_t v7 = *(result - 1);
  if ((unint64_t)v7 >= v6)
  {
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v7 - *a1) >> 3);
    unint64_t v10 = v9 + 1;
    if (v9 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 3);
    if (2 * v11 > v10) {
      unint64_t v10 = 2 * v11;
    }
    if (v11 >= 0x555555555555555) {
      unint64_t v12 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v12 = v10;
    }
    v16[4] = result;
    uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<float>>>((uint64_t)result, v12);
    unsigned int v14 = &v13[24 * v9];
    v16[0] = v13;
    v16[1] = v14;
    v16[3] = &v13[24 * v15];
    *((void *)v14 + 1) = 0;
    *((void *)v14 + 2) = 0;
    *(void *)unsigned int v14 = 0;
    *(_OWORD *)unsigned int v14 = *(_OWORD *)a2;
    *((void *)v14 + 2) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    _OWORD v16[2] = v14 + 24;
    std::vector<std::vector<std::vector<float>>>::__swap_out_circular_buffer(a1, v16);
    uint64_t v8 = (void *)a1[1];
    uint64_t result = std::__split_buffer<std::vector<std::vector<float>>>::~__split_buffer(v16);
  }
  else
  {
    *uint64_t v7 = 0;
    v7[1] = 0;
    v7[2] = 0;
    *(_OWORD *)uint64_t v7 = *(_OWORD *)a2;
    v7[2] = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    uint64_t v8 = v7 + 3;
    a1[1] = (uint64_t)(v7 + 3);
  }
  a1[1] = (uint64_t)v8;
  return result;
}

void sub_1B893684C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::vector<std::vector<float>>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void arkit::sum(float ***a1@<X0>, unsigned int a2@<W1>, char **a3@<X8>)
{
  if (a2 >= 2) {
    arkit::sum();
  }
  if (a2 == 1)
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    unint64_t v17 = *a1;
    uint64_t v18 = a1[1];
    if (*a1 != v18)
    {
      uint64_t v19 = 0;
      uint64_t v20 = a3 + 2;
      do
      {
        if ((unint64_t)v19 >= *v20)
        {
          uint64_t v21 = (float *)*a3;
          uint64_t v22 = ((char *)v19 - *a3) >> 2;
          unint64_t v23 = v22 + 1;
          if ((unint64_t)(v22 + 1) >> 62) {
            std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v24 = *v20 - (void)v21;
          if (v24 >> 1 > v23) {
            unint64_t v23 = v24 >> 1;
          }
          if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v25 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v25 = v23;
          }
          if (v25)
          {
            unint64_t v26 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(a3 + 2), v25);
            uint64_t v21 = (float *)*a3;
            uint64_t v19 = (float *)a3[1];
          }
          else
          {
            unint64_t v26 = 0;
          }
          uint64_t v27 = &v26[4 * v22];
          *(_DWORD *)uint64_t v27 = 0;
          uint64_t v28 = (float *)(v27 + 4);
          while (v19 != v21)
          {
            int v29 = *((_DWORD *)v19-- - 1);
            *((_DWORD *)v27 - 1) = v29;
            v27 -= 4;
          }
          *a3 = v27;
          a3[1] = (char *)v28;
          a3[2] = &v26[4 * v25];
          if (v21) {
            operator delete(v21);
          }
          uint64_t v19 = v28;
        }
        else
        {
          *v19++ = 0.0;
        }
        a3[1] = (char *)v19;
        uint64_t v30 = *v17;
        int v31 = v17[1];
        if (*v17 != v31)
        {
          float v32 = *(v19 - 1);
          do
          {
            float v33 = *v30++;
            float v32 = v33 + v32;
            *(v19 - 1) = v32;
          }
          while (v30 != v31);
        }
        v17 += 3;
      }
      while (v17 != v18);
    }
  }
  else
  {
    unint64_t v5 = (*a1)[1] - **a1;
    int v34 = 0;
    std::vector<float>::vector(a3, v5, &v34);
    unint64_t v6 = (char *)*a1;
    uint64_t v7 = (char *)(*a1)[1] - (char *)**a1;
    if (v7)
    {
      uint64_t v8 = 0;
      unint64_t v9 = v7 >> 2;
      unint64_t v10 = (char *)a1[1];
      unint64_t v11 = (v10 - v6) / 24;
      unint64_t v12 = (float *)*a3;
      if (v11 <= 1) {
        unint64_t v11 = 1;
      }
      if (v9 <= 1) {
        unint64_t v9 = 1;
      }
      do
      {
        if (v10 != v6)
        {
          float v13 = v12[v8];
          unint64_t v14 = v11;
          uint64_t v15 = v6;
          do
          {
            uint64_t v16 = *(void *)v15;
            v15 += 24;
            float v13 = *(float *)(v16 + 4 * v8) + v13;
            v12[v8] = v13;
            --v14;
          }
          while (v14);
        }
        ++v8;
      }
      while (v8 != v9);
    }
  }
}

void sub_1B8936A6C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void arkit::normalizeL1(float **a1@<X0>, float **a2@<X8>)
{
  uint64_t v3 = *a1;
  uint64_t v4 = a1[1];
  if (*a1 == v4)
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
  }
  else
  {
    float v5 = 0.0;
    unint64_t v6 = *a1;
    do
    {
      float v7 = *v6++;
      float v5 = v5 + v7;
    }
    while (v6 != v4);
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    if (v3 != v4)
    {
      uint64_t v8 = 0;
      unint64_t v9 = a2 + 2;
      do
      {
        float v10 = *v3 / v5;
        if ((unint64_t)v8 >= *v9)
        {
          unint64_t v12 = *a2;
          uint64_t v13 = v8 - *a2;
          unint64_t v14 = v13 + 1;
          if ((unint64_t)(v13 + 1) >> 62) {
            std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v15 = *v9 - (void)v12;
          if (v15 >> 1 > v14) {
            unint64_t v14 = v15 >> 1;
          }
          if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v16 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v16 = v14;
          }
          if (v16)
          {
            unint64_t v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(a2 + 2), v16);
            unint64_t v12 = *a2;
            uint64_t v8 = a2[1];
          }
          else
          {
            unint64_t v17 = 0;
          }
          uint64_t v18 = (float *)&v17[4 * v13];
          *uint64_t v18 = v10;
          unint64_t v11 = v18 + 1;
          while (v8 != v12)
          {
            int v19 = *((_DWORD *)v8-- - 1);
            *((_DWORD *)v18-- - 1) = v19;
          }
          *a2 = v18;
          a2[1] = v11;
          a2[2] = (float *)&v17[4 * v16];
          if (v12) {
            operator delete(v12);
          }
        }
        else
        {
          *uint64_t v8 = v10;
          unint64_t v11 = v8 + 1;
        }
        a2[1] = v11;
        ++v3;
        uint64_t v8 = v11;
      }
      while (v3 != v4);
    }
  }
}

void sub_1B8936BDC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void arkit::mixtureKernel(arkit *this@<X2>, uint64_t *a2@<X0>, void *a3@<X1>, float **a4@<X8>)
{
  float v33 = 0;
  int v34 = 0;
  unint64_t v35 = 0;
  if (a2[1] != *a2)
  {
    unint64_t v8 = 0;
    unint64_t v9 = 0;
    do
    {
      arkit::gaussianKernel(this, *(float *)(*a3 + 4 * v8), (float **)&__p);
      float v10 = __p;
      unint64_t v11 = v32;
      if (__p != v32)
      {
        uint64_t v12 = *a2;
        uint64_t v13 = (float *)__p;
        do
        {
          float *v13 = *v13 * sqrtf(*(float *)(v12 + 4 * v8));
          ++v13;
        }
        while (v13 != v11);
      }
      unint64_t v14 = ((char *)v11 - v10) >> 2;
      if (v14 > v9) {
        unint64_t v9 = v14;
      }
      uint64_t v15 = v34;
      if ((unint64_t)v34 >= v35)
      {
        uint64_t v16 = std::vector<std::vector<float>>::__push_back_slow_path<std::vector<float> const&>((uint64_t *)&v33, (uint64_t)&__p);
      }
      else
      {
        *int v34 = 0;
        v15[1] = 0;
        v15[2] = 0;
        std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v15, __p, (uint64_t)v32, ((char *)v32 - (unsigned char *)__p) >> 2);
        uint64_t v16 = (uint64_t)(v15 + 3);
      }
      int v34 = (float **)v16;
      if (__p)
      {
        float v32 = (float *)__p;
        operator delete(__p);
      }
      ++v8;
    }
    while (v8 < (a2[1] - *a2) >> 2);
    unint64_t v17 = v33;
    for (uint64_t i = v34; v17 != i; v17 += 3)
    {
      int v19 = (char *)*v17;
      if (v9 > v17[1] - *v17)
      {
        do
        {
          LODWORD(__p) = 0;
          std::vector<float>::insert((uint64_t)v17, v19, (float *)&__p);
          uint64_t v21 = v17[1];
          uint64_t v20 = v17[2];
          if (v21 >= v20)
          {
            unint64_t v23 = *v17;
            uint64_t v24 = v21 - *v17;
            unint64_t v25 = v24 + 1;
            if ((unint64_t)(v24 + 1) >> 62) {
              std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v26 = (char *)v20 - (char *)v23;
            if (v26 >> 1 > v25) {
              unint64_t v25 = v26 >> 1;
            }
            if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v27 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v27 = v25;
            }
            if (v27)
            {
              uint64_t v28 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(v17 + 2), v27);
              unint64_t v23 = *v17;
              uint64_t v21 = v17[1];
            }
            else
            {
              uint64_t v28 = 0;
            }
            int v29 = (float *)&v28[4 * v24];
            *int v29 = 0.0;
            uint64_t v22 = v29 + 1;
            while (v21 != v23)
            {
              int v30 = *((_DWORD *)v21-- - 1);
              *((_DWORD *)v29-- - 1) = v30;
            }
            *unint64_t v17 = v29;
            v17[1] = v22;
            void v17[2] = (float *)&v28[4 * v27];
            if (v23) {
              operator delete(v23);
            }
          }
          else
          {
            *uint64_t v21 = 0.0;
            uint64_t v22 = v21 + 1;
          }
          v17[1] = v22;
          int v19 = (char *)*v17;
        }
        while (v9 > v22 - *v17);
      }
    }
  }
  arkit::sum(&v33, 0, (char **)&__p);
  arkit::normalizeL1((float **)&__p, a4);
  if (__p)
  {
    float v32 = (float *)__p;
    operator delete(__p);
  }
  __p = &v33;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
}

void sub_1B8936E54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char *__p, char *a10, uint64_t a11, char a12, uint64_t a13)
{
  if (__p)
  {
    a10 = __p;
    operator delete(__p);
  }
  __p = &a12;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  _Unwind_Resume(a1);
}

char *std::vector<float>::insert(uint64_t a1, char *__src, float *a3)
{
  uint64_t v4 = __src;
  unint64_t v6 = *(char **)(a1 + 8);
  unint64_t v9 = *(void *)(a1 + 16);
  uint64_t v7 = a1 + 16;
  unint64_t v8 = v9;
  if ((unint64_t)v6 >= v9)
  {
    unint64_t v14 = *(unsigned char **)a1;
    unint64_t v15 = ((uint64_t)&v6[-*(void *)a1] >> 2) + 1;
    if (v15 >> 62) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v16 = (__src - v14) >> 2;
    uint64_t v17 = v8 - (void)v14;
    if (v17 >> 1 > v15) {
      unint64_t v15 = v17 >> 1;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v18 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v15;
    }
    uint64_t v25 = v7;
    if (v18) {
      int v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v7, v18);
    }
    else {
      int v19 = 0;
    }
    __p = v19;
    uint64_t v22 = &v19[4 * v16];
    unint64_t v23 = v22;
    uint64_t v24 = &v19[4 * v18];
    std::__split_buffer<float>::push_back(&__p, a3);
    uint64_t v4 = std::vector<float>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v4);
    if (v23 != v22) {
      v23 += (v22 - v23 + 3) & 0xFFFFFFFFFFFFFFFCLL;
    }
    if (__p) {
      operator delete(__p);
    }
  }
  else if (__src == v6)
  {
    *(float *)__vImage_Buffer src = *a3;
    *(void *)(a1 + 8) = __src + 4;
  }
  else
  {
    float v10 = __src + 4;
    unint64_t v11 = v6 - 4;
    uint64_t v12 = v6;
    while (v11 < v6)
    {
      int v13 = *(_DWORD *)v11;
      v11 += 4;
      *(_DWORD *)uint64_t v12 = v13;
      v12 += 4;
    }
    *(void *)(a1 + 8) = v12;
    if (v6 != v10) {
      memmove(&v6[-4 * ((v6 - v10) >> 2)], __src, v6 - v10);
    }
    *(float *)uint64_t v4 = *a3;
  }
  return v4;
}

void sub_1B8937014(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void arkit::mixtureKernels(uint64_t *a1@<X0>, void *a2@<X1>, arkit *a3@<X2>, uint64_t *a4@<X8>)
{
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  uint64_t v5 = *a1;
  if (a1[1] != *a1)
  {
    uint64_t v9 = 0;
    unint64_t v10 = 0;
    do
    {
      uint64_t v16 = 0;
      uint64_t v17 = 0;
      uint64_t v18 = 0;
      std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v16, *(const void **)(v5 + v9), *(void *)(v5 + v9 + 8), (uint64_t)(*(void *)(v5 + v9 + 8) - *(void *)(v5 + v9)) >> 2);
      uint64_t v11 = *a2 + v9;
      unint64_t v14 = 0;
      uint64_t v15 = 0;
      int v13 = 0;
      std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v13, *(const void **)v11, *(void *)(v11 + 8), (uint64_t)(*(void *)(v11 + 8) - *(void *)v11) >> 2);
      arkit::mixtureKernel(a3, (uint64_t *)&v16, &v13, (float **)__p);
      std::vector<std::vector<float>>::push_back[abi:ne180100](a4, (uint64_t)__p);
      if (__p[0])
      {
        __p[1] = __p[0];
        operator delete(__p[0]);
      }
      if (v13)
      {
        unint64_t v14 = v13;
        operator delete(v13);
      }
      if (v16)
      {
        uint64_t v17 = v16;
        operator delete(v16);
      }
      ++v10;
      uint64_t v5 = *a1;
      v9 += 24;
    }
    while (0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3) > v10);
  }
}

void sub_1B8937170(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }
  if (a13) {
    operator delete(a13);
  }
  if (a16)
  {
    a17 = (uint64_t)a16;
    operator delete(a16);
  }
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a16);
  _Unwind_Resume(a1);
}

void arkit::unflattenParams(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, char *a5, uint64_t *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = (v8 - *(void *)a1) >> 2;
  unint64_t v10 = (a2[1] - *a2) >> 2;
  if (v10 % v9) {
    arkit::unflattenParams();
  }
  unint64_t v14 = v10 / v9;
  uint64_t v15 = *(void *)(a3 + 8);
  uint64_t v16 = *(const void **)a3;
  unint64_t v17 = (v15 - *(void *)a3) >> 2;
  if (v17 / v9 % v14) {
    arkit::unflattenParams();
  }
  if (v17 / v14 % v9) {
    arkit::unflattenParams();
  }
  if (v17 != (uint64_t)(*(void *)(a4 + 8) - *(void *)a4) >> 2) {
    arkit::unflattenParams();
  }
  unsigned int v21 = v17 / v9 / v14;
  if (a5 != (char *)a1)
  {
    std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a5, *(char **)a1, v8, v9);
    uint64_t v16 = *(const void **)a3;
    uint64_t v15 = *(void *)(a3 + 8);
    unint64_t v17 = (v15 - *(void *)a3) >> 2;
  }
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  __p = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&__p, v16, v15, v17);
  v22.n128_u64[0] = __PAIR64__(v14, v21);
  v22.n128_u32[2] = v9;
  __n128 v23 = v22;
  arkit::unflatten(&__p, (uint64_t *)&v30, v22);
  std::vector<std::vector<std::vector<float>>>::__vdeallocate((void ***)a7);
  *(_OWORD *)a7 = v30;
  *(void *)(a7 + 16) = v31;
  uint64_t v31 = 0;
  long long v30 = 0uLL;
  float v32 = (void **)&v30;
  std::vector<std::vector<std::vector<float>>>::__destroy_vector::operator()[abi:ne180100](&v32);
  if (__p)
  {
    uint64_t v28 = __p;
    operator delete(__p);
  }
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  uint64_t v24 = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v24, *(const void **)a4, *(void *)(a4 + 8), (uint64_t)(*(void *)(a4 + 8) - *(void *)a4) >> 2);
  arkit::unflatten(&v24, (uint64_t *)&v30, v23);
  std::vector<std::vector<std::vector<float>>>::__vdeallocate((void ***)a8);
  *(_OWORD *)a8 = v30;
  *(void *)(a8 + 16) = v31;
  uint64_t v31 = 0;
  long long v30 = 0uLL;
  float v32 = (void **)&v30;
  std::vector<std::vector<std::vector<float>>>::__destroy_vector::operator()[abi:ne180100](&v32);
  if (v24)
  {
    uint64_t v25 = v24;
    operator delete(v24);
  }
  arkit::unflatten(a2, (uint64_t *)&v30, COERCE_DOUBLE(__PAIR64__(v9, v14)));
  std::vector<std::vector<float>>::__vdeallocate(a6);
  *(_OWORD *)a6 = v30;
  a6[2] = v31;
  uint64_t v31 = 0;
  long long v30 = 0uLL;
  float v32 = (void **)&v30;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v32);
}

void sub_1B89373F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void arkit::loadParams(int a1, char *a2, uint64_t *a3, uint64_t a4, uint64_t a5, char *a6)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  switch(a1)
  {
    case 0:
      *(_OWORD *)__dst = xmmword_1B8A2F478;
      *(_OWORD *)&__dst[16] = unk_1B8A2F488;
      *(_OWORD *)&__dst[32] = xmmword_1B8A2F498;
      *(_OWORD *)&__dst[48] = unk_1B8A2F4A8;
      *(_DWORD *)&__dst[64] = 1107321277;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x11uLL);
      *(_OWORD *)&__dst[144] = unk_1B8A2F54C;
      *(_OWORD *)&__dst[160] = xmmword_1B8A2F55C;
      *(_OWORD *)&__dst[176] = unk_1B8A2F56C;
      *(_OWORD *)&__dst[188] = unk_1B8A2F578;
      *(_OWORD *)&__dst[80] = unk_1B8A2F50C;
      *(_OWORD *)&__dst[96] = xmmword_1B8A2F51C;
      *(_OWORD *)&__dst[112] = unk_1B8A2F52C;
      *(_OWORD *)&__dst[128] = xmmword_1B8A2F53C;
      *(_OWORD *)&__dst[16] = unk_1B8A2F4CC;
      *(_OWORD *)&__dst[32] = xmmword_1B8A2F4DC;
      *(_OWORD *)&__dst[48] = unk_1B8A2F4EC;
      *(_OWORD *)&__dst[64] = xmmword_1B8A2F4FC;
      *(_OWORD *)__dst = xmmword_1B8A2F4BC;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x33uLL);
      memcpy(__dst, &unk_1B8A2F588, 0x3FCuLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xFFuLL);
      memcpy(__dst, &unk_1B8A2F984, 0x3FCuLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xFFuLL);
      *(_OWORD *)__dst = xmmword_1B8A2FD80;
      *(_OWORD *)&__dst[16] = unk_1B8A2FD90;
      *(_OWORD *)&__dst[32] = xmmword_1B8A2FDA0;
      *(_OWORD *)&__dst[48] = unk_1B8A2FDB0;
      *(_DWORD *)&__dst[64] = 1059106455;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x11uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 1:
      *(_OWORD *)__dst = xmmword_1B8A2FDC4;
      *(_OWORD *)&__dst[16] = unk_1B8A2FDD4;
      *(_OWORD *)&__dst[32] = xmmword_1B8A2FDE4;
      *(_OWORD *)&__dst[48] = unk_1B8A2FDF4;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x10uLL);
      *(_OWORD *)&__dst[144] = unk_1B8A2FE94;
      *(_OWORD *)&__dst[160] = xmmword_1B8A2FEA4;
      *(_OWORD *)&__dst[176] = unk_1B8A2FEB4;
      *(_OWORD *)&__dst[80] = unk_1B8A2FE54;
      *(_OWORD *)&__dst[96] = xmmword_1B8A2FE64;
      *(_OWORD *)&__dst[112] = unk_1B8A2FE74;
      *(_OWORD *)&__dst[128] = xmmword_1B8A2FE84;
      *(_OWORD *)__dst = xmmword_1B8A2FE04;
      *(_OWORD *)&__dst[16] = unk_1B8A2FE14;
      *(_OWORD *)&__dst[32] = xmmword_1B8A2FE24;
      *(_OWORD *)&__dst[48] = unk_1B8A2FE34;
      *(_OWORD *)&__dst[64] = xmmword_1B8A2FE44;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x30uLL);
      memcpy(__dst, &unk_1B8A2FEC4, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xF0uLL);
      memcpy(__dst, &unk_1B8A30284, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xF0uLL);
      *(_OWORD *)__dst = xmmword_1B8A30644;
      *(_OWORD *)&__dst[16] = unk_1B8A30654;
      *(_OWORD *)&__dst[32] = xmmword_1B8A30664;
      *(_OWORD *)&__dst[48] = unk_1B8A30674;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x10uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 2:
      *(_OWORD *)__dst = xmmword_1B8A3DFA0;
      *(_OWORD *)&__dst[16] = unk_1B8A3DFB0;
      *(_OWORD *)&__dst[32] = xmmword_1B8A3DFC0;
      *(_OWORD *)&__dst[48] = unk_1B8A3DFD0;
      *(_DWORD *)&__dst[64] = 1106318384;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x11uLL);
      *(_OWORD *)&__dst[144] = unk_1B8A3E074;
      *(_OWORD *)&__dst[160] = xmmword_1B8A3E084;
      *(_OWORD *)&__dst[176] = unk_1B8A3E094;
      *(_OWORD *)&__dst[188] = unk_1B8A3E0A0;
      *(_OWORD *)&__dst[80] = unk_1B8A3E034;
      *(_OWORD *)&__dst[96] = xmmword_1B8A3E044;
      *(_OWORD *)&__dst[112] = unk_1B8A3E054;
      *(_OWORD *)&__dst[128] = xmmword_1B8A3E064;
      *(_OWORD *)&__dst[16] = unk_1B8A3DFF4;
      *(_OWORD *)&__dst[32] = xmmword_1B8A3E004;
      *(_OWORD *)&__dst[48] = unk_1B8A3E014;
      *(_OWORD *)&__dst[64] = xmmword_1B8A3E024;
      *(_OWORD *)__dst = xmmword_1B8A3DFE4;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x33uLL);
      memcpy(__dst, &unk_1B8A3E0B0, 0x3FCuLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xFFuLL);
      memcpy(__dst, &unk_1B8A3E4AC, 0x3FCuLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xFFuLL);
      *(_OWORD *)__dst = xmmword_1B8A3E8A8;
      *(_OWORD *)&__dst[16] = unk_1B8A3E8B8;
      *(_OWORD *)&__dst[32] = xmmword_1B8A3E8C8;
      *(_OWORD *)&__dst[48] = unk_1B8A3E8D8;
      *(_DWORD *)&__dst[64] = 1058765256;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x11uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 3:
      *(_OWORD *)__dst = xmmword_1B8A3E8EC;
      *(_OWORD *)&__dst[16] = unk_1B8A3E8FC;
      *(_OWORD *)&__dst[32] = xmmword_1B8A3E90C;
      *(_OWORD *)&__dst[48] = unk_1B8A3E91C;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x10uLL);
      *(_OWORD *)&__dst[144] = unk_1B8A3E9BC;
      *(_OWORD *)&__dst[160] = xmmword_1B8A3E9CC;
      *(_OWORD *)&__dst[176] = unk_1B8A3E9DC;
      *(_OWORD *)&__dst[80] = unk_1B8A3E97C;
      *(_OWORD *)&__dst[96] = xmmword_1B8A3E98C;
      *(_OWORD *)&__dst[112] = unk_1B8A3E99C;
      *(_OWORD *)&__dst[128] = xmmword_1B8A3E9AC;
      *(_OWORD *)__dst = xmmword_1B8A3E92C;
      *(_OWORD *)&__dst[16] = unk_1B8A3E93C;
      *(_OWORD *)&__dst[32] = xmmword_1B8A3E94C;
      *(_OWORD *)&__dst[48] = unk_1B8A3E95C;
      *(_OWORD *)&__dst[64] = xmmword_1B8A3E96C;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x30uLL);
      memcpy(__dst, &unk_1B8A3E9EC, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xF0uLL);
      memcpy(__dst, &unk_1B8A3EDAC, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xF0uLL);
      *(_OWORD *)__dst = xmmword_1B8A3F16C;
      *(_OWORD *)&__dst[16] = unk_1B8A3F17C;
      *(_OWORD *)&__dst[32] = xmmword_1B8A3F18C;
      *(_OWORD *)&__dst[48] = unk_1B8A3F19C;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x10uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 4:
      *(_OWORD *)&__dst[16] = unk_1B8A35A40;
      *(_OWORD *)&__dst[32] = xmmword_1B8A35A50;
      *(_OWORD *)&__dst[48] = unk_1B8A35A60;
      *(void *)&__dst[64] = 0x42048AD641D8840ALL;
      *(_OWORD *)__dst = xmmword_1B8A35A30;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x12uLL);
      *(_OWORD *)&__dst[176] = unk_1B8A35B28;
      *(_OWORD *)&__dst[192] = xmmword_1B8A35B38;
      *(_OWORD *)&__dst[112] = unk_1B8A35AE8;
      *(_OWORD *)&__dst[128] = xmmword_1B8A35AF8;
      *(_OWORD *)&__dst[144] = unk_1B8A35B08;
      *(_OWORD *)&__dst[160] = xmmword_1B8A35B18;
      *(_OWORD *)&__dst[48] = unk_1B8A35AA8;
      *(_OWORD *)&__dst[64] = xmmword_1B8A35AB8;
      *(_OWORD *)&__dst[80] = unk_1B8A35AC8;
      *(_OWORD *)&__dst[96] = xmmword_1B8A35AD8;
      *(_OWORD *)__dst = xmmword_1B8A35A78;
      *(void *)&__dst[208] = 0x382BF76A391C3CE2;
      *(_OWORD *)&__dst[16] = unk_1B8A35A88;
      *(_OWORD *)&__dst[32] = xmmword_1B8A35A98;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x36uLL);
      memcpy(__dst, &unk_1B8A35B50, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0x10EuLL);
      memcpy(__dst, &unk_1B8A35F88, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0x10EuLL);
      *(_OWORD *)&__dst[16] = unk_1B8A363D0;
      *(_OWORD *)&__dst[32] = xmmword_1B8A363E0;
      *(_OWORD *)&__dst[48] = unk_1B8A363F0;
      *(void *)&__dst[64] = 0x3F27AA8B3F22E968;
      *(_OWORD *)__dst = xmmword_1B8A363C0;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x12uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 5:
      *(_OWORD *)&__dst[16] = unk_1B8A35068;
      *(_OWORD *)&__dst[32] = xmmword_1B8A35078;
      *(_OWORD *)&__dst[48] = unk_1B8A35088;
      *(void *)&__dst[64] = 0x41EEE0B641DD5DB7;
      *(_OWORD *)__dst = xmmword_1B8A35058;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x12uLL);
      *(_OWORD *)&__dst[176] = unk_1B8A35150;
      *(_OWORD *)&__dst[192] = xmmword_1B8A35160;
      *(_OWORD *)&__dst[112] = unk_1B8A35110;
      *(_OWORD *)&__dst[128] = xmmword_1B8A35120;
      *(_OWORD *)&__dst[144] = unk_1B8A35130;
      *(_OWORD *)&__dst[160] = xmmword_1B8A35140;
      *(_OWORD *)&__dst[48] = unk_1B8A350D0;
      *(_OWORD *)&__dst[64] = xmmword_1B8A350E0;
      *(_OWORD *)&__dst[80] = unk_1B8A350F0;
      *(_OWORD *)&__dst[96] = xmmword_1B8A35100;
      *(_OWORD *)__dst = xmmword_1B8A350A0;
      *(void *)&__dst[208] = 0x39A7C5AC3A20B1BCLL;
      *(_OWORD *)&__dst[16] = unk_1B8A350B0;
      *(_OWORD *)&__dst[32] = xmmword_1B8A350C0;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x36uLL);
      memcpy(__dst, &unk_1B8A35178, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0x10EuLL);
      memcpy(__dst, &unk_1B8A355B0, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0x10EuLL);
      *(_OWORD *)&__dst[16] = unk_1B8A359F8;
      *(_OWORD *)&__dst[32] = xmmword_1B8A35A08;
      *(_OWORD *)&__dst[48] = unk_1B8A35A18;
      *(void *)&__dst[64] = 0x3F2754B03F234DCFLL;
      *(_OWORD *)__dst = xmmword_1B8A359E8;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x12uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 6:
      *(_OWORD *)&__dst[48] = unk_1B8A36E10;
      *(_OWORD *)&__dst[64] = xmmword_1B8A36E20;
      *(void *)&__dst[80] = 0x4203DBAA41E1A20FLL;
      *(_OWORD *)__dst = xmmword_1B8A36DE0;
      *(_OWORD *)&__dst[16] = unk_1B8A36DF0;
      *(_OWORD *)&__dst[32] = xmmword_1B8A36E00;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x16uLL);
      memcpy(__dst, &unk_1B8A36E38, 0x108uLL);
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x42uLL);
      memcpy(__dst, &unk_1B8A36F40, sizeof(__dst));
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0x14AuLL);
      memcpy(__dst, &unk_1B8A37468, sizeof(__dst));
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0x14AuLL);
      *(_OWORD *)&__dst[48] = unk_1B8A379C0;
      *(_OWORD *)&__dst[64] = xmmword_1B8A379D0;
      *(void *)&__dst[80] = 0x3F2B11E83F2A2D73;
      *(_OWORD *)__dst = xmmword_1B8A37990;
      *(_OWORD *)&__dst[16] = unk_1B8A379A0;
      *(_OWORD *)&__dst[32] = xmmword_1B8A379B0;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x16uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 7:
      *(_OWORD *)&__dst[16] = unk_1B8A36418;
      *(_OWORD *)&__dst[32] = xmmword_1B8A36428;
      *(_OWORD *)&__dst[48] = unk_1B8A36438;
      *(void *)&__dst[64] = 0x41FDBD4641CDA493;
      *(_OWORD *)__dst = xmmword_1B8A36408;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x12uLL);
      *(_OWORD *)&__dst[176] = unk_1B8A36500;
      *(_OWORD *)&__dst[192] = xmmword_1B8A36510;
      *(_OWORD *)&__dst[112] = unk_1B8A364C0;
      *(_OWORD *)&__dst[128] = xmmword_1B8A364D0;
      *(_OWORD *)&__dst[144] = unk_1B8A364E0;
      *(_OWORD *)&__dst[160] = xmmword_1B8A364F0;
      *(_OWORD *)&__dst[48] = unk_1B8A36480;
      *(_OWORD *)&__dst[64] = xmmword_1B8A36490;
      *(_OWORD *)&__dst[80] = unk_1B8A364A0;
      *(_OWORD *)&__dst[96] = xmmword_1B8A364B0;
      *(_OWORD *)__dst = xmmword_1B8A36450;
      *(void *)&__dst[208] = 0x36EAE18B38F776C5;
      *(_OWORD *)&__dst[16] = unk_1B8A36460;
      *(_OWORD *)&__dst[32] = xmmword_1B8A36470;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x36uLL);
      memcpy(__dst, &unk_1B8A36528, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0x10EuLL);
      memcpy(__dst, &unk_1B8A36960, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0x10EuLL);
      *(_OWORD *)&__dst[16] = unk_1B8A36DA8;
      *(_OWORD *)&__dst[32] = xmmword_1B8A36DB8;
      *(_OWORD *)&__dst[48] = unk_1B8A36DC8;
      *(void *)&__dst[64] = 0x3F2A95EA3F25CDC4;
      *(_OWORD *)__dst = xmmword_1B8A36D98;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x12uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 8:
      *(_OWORD *)__dst = xmmword_1B8A38334;
      *(_OWORD *)&__dst[16] = unk_1B8A38344;
      *(_OWORD *)&__dst[32] = xmmword_1B8A38354;
      *(_OWORD *)&__dst[48] = unk_1B8A38364;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x10uLL);
      *(_OWORD *)&__dst[144] = unk_1B8A38404;
      *(_OWORD *)&__dst[160] = xmmword_1B8A38414;
      *(_OWORD *)&__dst[176] = unk_1B8A38424;
      *(_OWORD *)&__dst[80] = unk_1B8A383C4;
      *(_OWORD *)&__dst[96] = xmmword_1B8A383D4;
      *(_OWORD *)&__dst[112] = unk_1B8A383E4;
      *(_OWORD *)&__dst[128] = xmmword_1B8A383F4;
      *(_OWORD *)__dst = xmmword_1B8A38374;
      *(_OWORD *)&__dst[16] = unk_1B8A38384;
      *(_OWORD *)&__dst[32] = xmmword_1B8A38394;
      *(_OWORD *)&__dst[48] = unk_1B8A383A4;
      *(_OWORD *)&__dst[64] = xmmword_1B8A383B4;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x30uLL);
      memcpy(__dst, &unk_1B8A38434, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xF0uLL);
      memcpy(__dst, &unk_1B8A387F4, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xF0uLL);
      *(_OWORD *)__dst = xmmword_1B8A38BB4;
      *(_OWORD *)&__dst[16] = unk_1B8A38BC4;
      *(_OWORD *)&__dst[32] = xmmword_1B8A38BD4;
      *(_OWORD *)&__dst[48] = unk_1B8A38BE4;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x10uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 9:
      *(_OWORD *)__dst = xmmword_1B8A379E8;
      *(_OWORD *)&__dst[16] = unk_1B8A379F8;
      *(_OWORD *)&__dst[32] = xmmword_1B8A37A08;
      *(_OWORD *)&__dst[48] = unk_1B8A37A18;
      *(_DWORD *)&__dst[64] = 1106231152;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x11uLL);
      *(_OWORD *)&__dst[144] = unk_1B8A37ABC;
      *(_OWORD *)&__dst[160] = xmmword_1B8A37ACC;
      *(_OWORD *)&__dst[176] = unk_1B8A37ADC;
      *(_OWORD *)&__dst[188] = unk_1B8A37AE8;
      *(_OWORD *)&__dst[80] = unk_1B8A37A7C;
      *(_OWORD *)&__dst[96] = xmmword_1B8A37A8C;
      *(_OWORD *)&__dst[112] = unk_1B8A37A9C;
      *(_OWORD *)&__dst[128] = xmmword_1B8A37AAC;
      *(_OWORD *)&__dst[16] = unk_1B8A37A3C;
      *(_OWORD *)&__dst[32] = xmmword_1B8A37A4C;
      *(_OWORD *)&__dst[48] = unk_1B8A37A5C;
      *(_OWORD *)&__dst[64] = xmmword_1B8A37A6C;
      *(_OWORD *)__dst = xmmword_1B8A37A2C;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x33uLL);
      memcpy(__dst, &unk_1B8A37AF8, 0x3FCuLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xFFuLL);
      memcpy(__dst, &unk_1B8A37EF4, 0x3FCuLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xFFuLL);
      *(_OWORD *)__dst = xmmword_1B8A382F0;
      *(_OWORD *)&__dst[16] = unk_1B8A38300;
      *(_OWORD *)&__dst[32] = xmmword_1B8A38310;
      *(_OWORD *)&__dst[48] = unk_1B8A38320;
      *(_DWORD *)&__dst[64] = 1052182263;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x11uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 10:
      *(_OWORD *)__dst = xmmword_1B8A38BF4;
      *(_OWORD *)&__dst[16] = unk_1B8A38C04;
      *(_OWORD *)&__dst[32] = xmmword_1B8A38C14;
      *(_OWORD *)&__dst[48] = unk_1B8A38C24;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x10uLL);
      *(_OWORD *)&__dst[144] = unk_1B8A38CC4;
      *(_OWORD *)&__dst[160] = xmmword_1B8A38CD4;
      *(_OWORD *)&__dst[176] = unk_1B8A38CE4;
      *(_OWORD *)&__dst[80] = unk_1B8A38C84;
      *(_OWORD *)&__dst[96] = xmmword_1B8A38C94;
      *(_OWORD *)&__dst[112] = unk_1B8A38CA4;
      *(_OWORD *)&__dst[128] = xmmword_1B8A38CB4;
      *(_OWORD *)__dst = xmmword_1B8A38C34;
      *(_OWORD *)&__dst[16] = unk_1B8A38C44;
      *(_OWORD *)&__dst[32] = xmmword_1B8A38C54;
      *(_OWORD *)&__dst[48] = unk_1B8A38C64;
      *(_OWORD *)&__dst[64] = xmmword_1B8A38C74;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x30uLL);
      memcpy(__dst, &unk_1B8A38CF4, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xF0uLL);
      memcpy(__dst, &unk_1B8A390B4, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xF0uLL);
      *(_OWORD *)__dst = xmmword_1B8A39474;
      *(_OWORD *)&__dst[16] = unk_1B8A39484;
      *(_OWORD *)&__dst[32] = xmmword_1B8A39494;
      *(_OWORD *)&__dst[48] = unk_1B8A394A4;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x10uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 11:
      *(_OWORD *)&__dst[16] = unk_1B8A39F28;
      *(_OWORD *)&__dst[32] = xmmword_1B8A39F38;
      *(_OWORD *)&__dst[48] = unk_1B8A39F48;
      *(void *)&__dst[64] = 0x41F0537541E02DC3;
      *(_OWORD *)__dst = xmmword_1B8A39F18;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x12uLL);
      *(_OWORD *)&__dst[176] = unk_1B8A3A010;
      *(_OWORD *)&__dst[192] = xmmword_1B8A3A020;
      *(_OWORD *)&__dst[112] = unk_1B8A39FD0;
      *(_OWORD *)&__dst[128] = xmmword_1B8A39FE0;
      *(_OWORD *)&__dst[144] = unk_1B8A39FF0;
      *(_OWORD *)&__dst[160] = xmmword_1B8A3A000;
      *(_OWORD *)&__dst[48] = unk_1B8A39F90;
      *(_OWORD *)&__dst[64] = xmmword_1B8A39FA0;
      *(_OWORD *)&__dst[80] = unk_1B8A39FB0;
      *(_OWORD *)&__dst[96] = xmmword_1B8A39FC0;
      *(_OWORD *)__dst = xmmword_1B8A39F60;
      *(void *)&__dst[208] = 0x389B3073388637BDLL;
      *(_OWORD *)&__dst[16] = unk_1B8A39F70;
      *(_OWORD *)&__dst[32] = xmmword_1B8A39F80;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x36uLL);
      memcpy(__dst, &unk_1B8A3A038, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0x10EuLL);
      memcpy(__dst, &unk_1B8A3A470, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0x10EuLL);
      *(_OWORD *)&__dst[16] = unk_1B8A3A8B8;
      *(_OWORD *)&__dst[32] = xmmword_1B8A3A8C8;
      *(_OWORD *)&__dst[48] = unk_1B8A3A8D8;
      *(void *)&__dst[64] = 0x3F2731C23F211740;
      *(_OWORD *)__dst = xmmword_1B8A3A8A8;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x12uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 12:
      *(_OWORD *)&__dst[16] = unk_1B8A394C4;
      *(_OWORD *)&__dst[32] = xmmword_1B8A394D4;
      *(_OWORD *)&__dst[48] = unk_1B8A394E4;
      *(_OWORD *)&__dst[60] = unk_1B8A394F0;
      *(_OWORD *)__dst = xmmword_1B8A394B4;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x13uLL);
      *(_OWORD *)&__dst[176] = unk_1B8A395B0;
      *(_OWORD *)&__dst[192] = xmmword_1B8A395C0;
      *(_OWORD *)&__dst[208] = unk_1B8A395D0;
      *(_OWORD *)&__dst[112] = unk_1B8A39570;
      *(_OWORD *)&__dst[128] = xmmword_1B8A39580;
      *(_OWORD *)&__dst[144] = unk_1B8A39590;
      *(_OWORD *)&__dst[160] = xmmword_1B8A395A0;
      *(_OWORD *)&__dst[48] = unk_1B8A39530;
      *(_OWORD *)&__dst[64] = xmmword_1B8A39540;
      *(_OWORD *)&__dst[80] = unk_1B8A39550;
      *(_OWORD *)&__dst[96] = xmmword_1B8A39560;
      *(_OWORD *)__dst = xmmword_1B8A39500;
      *(_OWORD *)&__dst[16] = unk_1B8A39510;
      *(_OWORD *)&__dst[32] = xmmword_1B8A39520;
      *(_DWORD *)&__dst[224] = 981548204;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x39uLL);
      memcpy(__dst, &unk_1B8A395E4, 0x474uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0x11DuLL);
      memcpy(__dst, &unk_1B8A39A58, 0x474uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0x11DuLL);
      *(_OWORD *)&__dst[16] = unk_1B8A39EDC;
      *(_OWORD *)&__dst[32] = xmmword_1B8A39EEC;
      *(_OWORD *)&__dst[48] = unk_1B8A39EFC;
      *(_OWORD *)&__dst[60] = unk_1B8A39F08;
      *(_OWORD *)__dst = xmmword_1B8A39ECC;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x13uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 13:
      *(_OWORD *)__dst = xmmword_1B8A3B2C8;
      *(_OWORD *)&__dst[16] = unk_1B8A3B2D8;
      *(_OWORD *)&__dst[32] = xmmword_1B8A3B2E8;
      *(_OWORD *)&__dst[48] = unk_1B8A3B2F8;
      *(_DWORD *)&__dst[64] = 1106552048;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x11uLL);
      *(_OWORD *)&__dst[144] = unk_1B8A3B39C;
      *(_OWORD *)&__dst[160] = xmmword_1B8A3B3AC;
      *(_OWORD *)&__dst[176] = unk_1B8A3B3BC;
      *(_OWORD *)&__dst[188] = unk_1B8A3B3C8;
      *(_OWORD *)&__dst[80] = unk_1B8A3B35C;
      *(_OWORD *)&__dst[96] = xmmword_1B8A3B36C;
      *(_OWORD *)&__dst[112] = unk_1B8A3B37C;
      *(_OWORD *)&__dst[128] = xmmword_1B8A3B38C;
      *(_OWORD *)&__dst[16] = unk_1B8A3B31C;
      *(_OWORD *)&__dst[32] = xmmword_1B8A3B32C;
      *(_OWORD *)&__dst[48] = unk_1B8A3B33C;
      *(_OWORD *)&__dst[64] = xmmword_1B8A3B34C;
      *(_OWORD *)__dst = xmmword_1B8A3B30C;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x33uLL);
      memcpy(__dst, &unk_1B8A3B3D8, 0x3FCuLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xFFuLL);
      memcpy(__dst, &unk_1B8A3B7D4, 0x3FCuLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xFFuLL);
      *(_OWORD *)__dst = xmmword_1B8A3BBD0;
      *(_OWORD *)&__dst[16] = unk_1B8A3BBE0;
      *(_OWORD *)&__dst[32] = xmmword_1B8A3BBF0;
      *(_OWORD *)&__dst[48] = unk_1B8A3BC00;
      *(_DWORD *)&__dst[64] = 1059864650;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x11uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 14:
      *(_OWORD *)&__dst[16] = unk_1B8A3A900;
      *(_OWORD *)&__dst[32] = xmmword_1B8A3A910;
      *(_OWORD *)&__dst[48] = unk_1B8A3A920;
      *(void *)&__dst[64] = 0x41F0C6B541DD6B4DLL;
      *(_OWORD *)__dst = xmmword_1B8A3A8F0;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x12uLL);
      *(_OWORD *)&__dst[176] = unk_1B8A3A9E8;
      *(_OWORD *)&__dst[192] = xmmword_1B8A3A9F8;
      *(_OWORD *)&__dst[112] = unk_1B8A3A9A8;
      *(_OWORD *)&__dst[128] = xmmword_1B8A3A9B8;
      *(_OWORD *)&__dst[144] = unk_1B8A3A9C8;
      *(_OWORD *)&__dst[160] = xmmword_1B8A3A9D8;
      *(_OWORD *)&__dst[48] = unk_1B8A3A968;
      *(_OWORD *)&__dst[64] = xmmword_1B8A3A978;
      *(_OWORD *)&__dst[80] = unk_1B8A3A988;
      *(_OWORD *)&__dst[96] = xmmword_1B8A3A998;
      *(_OWORD *)__dst = xmmword_1B8A3A938;
      *(void *)&__dst[208] = 0x360637BD3827C5ACLL;
      *(_OWORD *)&__dst[16] = unk_1B8A3A948;
      *(_OWORD *)&__dst[32] = xmmword_1B8A3A958;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x36uLL);
      memcpy(__dst, &unk_1B8A3AA10, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0x10EuLL);
      memcpy(__dst, &unk_1B8A3AE48, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0x10EuLL);
      *(_OWORD *)&__dst[16] = unk_1B8A3B290;
      *(_OWORD *)&__dst[32] = xmmword_1B8A3B2A0;
      *(_OWORD *)&__dst[48] = unk_1B8A3B2B0;
      *(void *)&__dst[64] = 0x3F2799703F26BD3CLL;
      *(_OWORD *)__dst = xmmword_1B8A3B280;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x12uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 15:
      *(_OWORD *)&__dst[16] = unk_1B8A3F9F0;
      *(_OWORD *)&__dst[32] = xmmword_1B8A3FA00;
      *(_OWORD *)&__dst[48] = unk_1B8A3FA10;
      *(_OWORD *)&__dst[60] = unk_1B8A3FA1C;
      *(_OWORD *)__dst = xmmword_1B8A3F9E0;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x13uLL);
      *(_OWORD *)&__dst[176] = unk_1B8A3FADC;
      *(_OWORD *)&__dst[192] = xmmword_1B8A3FAEC;
      *(_OWORD *)&__dst[208] = unk_1B8A3FAFC;
      *(_OWORD *)&__dst[112] = unk_1B8A3FA9C;
      *(_OWORD *)&__dst[128] = xmmword_1B8A3FAAC;
      *(_OWORD *)&__dst[144] = unk_1B8A3FABC;
      *(_OWORD *)&__dst[160] = xmmword_1B8A3FACC;
      *(_OWORD *)&__dst[48] = unk_1B8A3FA5C;
      *(_OWORD *)&__dst[64] = xmmword_1B8A3FA6C;
      *(_OWORD *)&__dst[80] = unk_1B8A3FA7C;
      *(_OWORD *)&__dst[96] = xmmword_1B8A3FA8C;
      *(_OWORD *)__dst = xmmword_1B8A3FA2C;
      *(_OWORD *)&__dst[16] = unk_1B8A3FA3C;
      *(_OWORD *)&__dst[32] = xmmword_1B8A3FA4C;
      *(_DWORD *)&__dst[224] = 966265636;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x39uLL);
      memcpy(__dst, &unk_1B8A3FB10, 0x474uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0x11DuLL);
      memcpy(__dst, &unk_1B8A3FF84, 0x474uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0x11DuLL);
      *(_OWORD *)&__dst[16] = unk_1B8A40408;
      *(_OWORD *)&__dst[32] = xmmword_1B8A40418;
      *(_OWORD *)&__dst[48] = unk_1B8A40428;
      *(_OWORD *)&__dst[60] = unk_1B8A40434;
      *(_OWORD *)__dst = xmmword_1B8A403F8;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x13uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 16:
      *(_OWORD *)&__dst[16] = unk_1B8A40454;
      *(_OWORD *)&__dst[32] = xmmword_1B8A40464;
      *(_OWORD *)&__dst[48] = unk_1B8A40474;
      *(_OWORD *)&__dst[60] = unk_1B8A40480;
      *(_OWORD *)__dst = xmmword_1B8A40444;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x13uLL);
      *(_OWORD *)&__dst[176] = unk_1B8A40540;
      *(_OWORD *)&__dst[192] = xmmword_1B8A40550;
      *(_OWORD *)&__dst[208] = unk_1B8A40560;
      *(_OWORD *)&__dst[112] = unk_1B8A40500;
      *(_OWORD *)&__dst[128] = xmmword_1B8A40510;
      *(_OWORD *)&__dst[144] = unk_1B8A40520;
      *(_OWORD *)&__dst[160] = xmmword_1B8A40530;
      *(_OWORD *)&__dst[48] = unk_1B8A404C0;
      *(_OWORD *)&__dst[64] = xmmword_1B8A404D0;
      *(_OWORD *)&__dst[80] = unk_1B8A404E0;
      *(_OWORD *)&__dst[96] = xmmword_1B8A404F0;
      *(_OWORD *)__dst = xmmword_1B8A40490;
      *(_OWORD *)&__dst[16] = unk_1B8A404A0;
      *(_OWORD *)&__dst[32] = xmmword_1B8A404B0;
      *(_DWORD *)&__dst[224] = 964336659;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x39uLL);
      memcpy(__dst, &unk_1B8A40574, 0x474uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0x11DuLL);
      memcpy(__dst, &unk_1B8A409E8, 0x474uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0x11DuLL);
      *(_OWORD *)&__dst[16] = unk_1B8A40E6C;
      *(_OWORD *)&__dst[32] = xmmword_1B8A40E7C;
      *(_OWORD *)&__dst[48] = unk_1B8A40E8C;
      *(_OWORD *)&__dst[60] = unk_1B8A40E98;
      *(_OWORD *)__dst = xmmword_1B8A40E5C;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x13uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 17:
      *(_OWORD *)__dst = xmmword_1B8A3BC14;
      *(_OWORD *)&__dst[16] = unk_1B8A3BC24;
      *(_OWORD *)&__dst[32] = xmmword_1B8A3BC34;
      *(_OWORD *)&__dst[48] = unk_1B8A3BC44;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x10uLL);
      *(_OWORD *)&__dst[144] = unk_1B8A3BCE4;
      *(_OWORD *)&__dst[160] = xmmword_1B8A3BCF4;
      *(_OWORD *)&__dst[176] = unk_1B8A3BD04;
      *(_OWORD *)&__dst[80] = unk_1B8A3BCA4;
      *(_OWORD *)&__dst[96] = xmmword_1B8A3BCB4;
      *(_OWORD *)&__dst[112] = unk_1B8A3BCC4;
      *(_OWORD *)&__dst[128] = xmmword_1B8A3BCD4;
      *(_OWORD *)__dst = xmmword_1B8A3BC54;
      *(_OWORD *)&__dst[16] = unk_1B8A3BC64;
      *(_OWORD *)&__dst[32] = xmmword_1B8A3BC74;
      *(_OWORD *)&__dst[48] = unk_1B8A3BC84;
      *(_OWORD *)&__dst[64] = xmmword_1B8A3BC94;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x30uLL);
      memcpy(__dst, &unk_1B8A3BD14, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xF0uLL);
      memcpy(__dst, &unk_1B8A3C0D4, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xF0uLL);
      *(_OWORD *)__dst = xmmword_1B8A3C494;
      *(_OWORD *)&__dst[16] = unk_1B8A3C4A4;
      *(_OWORD *)&__dst[32] = xmmword_1B8A3C4B4;
      *(_OWORD *)&__dst[48] = unk_1B8A3C4C4;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x10uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 18:
      *(_OWORD *)__dst = xmmword_1B8A3C4D4;
      *(_OWORD *)&__dst[16] = unk_1B8A3C4E4;
      *(_OWORD *)&__dst[32] = xmmword_1B8A3C4F4;
      *(_OWORD *)&__dst[48] = unk_1B8A3C504;
      *(_DWORD *)&__dst[64] = 1107695405;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x11uLL);
      *(_OWORD *)&__dst[144] = unk_1B8A3C5A8;
      *(_OWORD *)&__dst[160] = xmmword_1B8A3C5B8;
      *(_OWORD *)&__dst[176] = unk_1B8A3C5C8;
      *(_OWORD *)&__dst[188] = unk_1B8A3C5D4;
      *(_OWORD *)&__dst[80] = unk_1B8A3C568;
      *(_OWORD *)&__dst[96] = xmmword_1B8A3C578;
      *(_OWORD *)&__dst[112] = unk_1B8A3C588;
      *(_OWORD *)&__dst[128] = xmmword_1B8A3C598;
      *(_OWORD *)&__dst[16] = unk_1B8A3C528;
      *(_OWORD *)&__dst[32] = xmmword_1B8A3C538;
      *(_OWORD *)&__dst[48] = unk_1B8A3C548;
      *(_OWORD *)&__dst[64] = xmmword_1B8A3C558;
      *(_OWORD *)__dst = xmmword_1B8A3C518;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x33uLL);
      memcpy(__dst, &unk_1B8A3C5E4, 0x3FCuLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xFFuLL);
      memcpy(__dst, &unk_1B8A3C9E0, 0x3FCuLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xFFuLL);
      *(_OWORD *)__dst = xmmword_1B8A3CDDC;
      *(_OWORD *)&__dst[16] = unk_1B8A3CDEC;
      *(_OWORD *)&__dst[32] = xmmword_1B8A3CDFC;
      *(_OWORD *)&__dst[48] = unk_1B8A3CE0C;
      *(_DWORD *)&__dst[64] = 1050791868;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x11uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 19:
      *(_OWORD *)__dst = xmmword_1B8A3BC14;
      *(_OWORD *)&__dst[16] = unk_1B8A3BC24;
      *(_OWORD *)&__dst[32] = xmmword_1B8A3BC34;
      *(_OWORD *)&__dst[48] = unk_1B8A3BC44;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x10uLL);
      *(_OWORD *)&__dst[144] = unk_1B8A3BCE4;
      *(_OWORD *)&__dst[160] = xmmword_1B8A3BCF4;
      *(_OWORD *)&__dst[176] = unk_1B8A3BD04;
      *(_OWORD *)&__dst[80] = unk_1B8A3BCA4;
      *(_OWORD *)&__dst[96] = xmmword_1B8A3BCB4;
      *(_OWORD *)&__dst[112] = unk_1B8A3BCC4;
      *(_OWORD *)&__dst[128] = xmmword_1B8A3BCD4;
      *(_OWORD *)__dst = xmmword_1B8A3BC54;
      *(_OWORD *)&__dst[16] = unk_1B8A3BC64;
      *(_OWORD *)&__dst[32] = xmmword_1B8A3BC74;
      *(_OWORD *)&__dst[48] = unk_1B8A3BC84;
      *(_OWORD *)&__dst[64] = xmmword_1B8A3BC94;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x30uLL);
      memcpy(__dst, &unk_1B8A3BD14, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xF0uLL);
      memcpy(__dst, &unk_1B8A3C0D4, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xF0uLL);
      *(_OWORD *)__dst = xmmword_1B8A3C494;
      *(_OWORD *)&__dst[16] = unk_1B8A3C4A4;
      *(_OWORD *)&__dst[32] = xmmword_1B8A3C4B4;
      *(_OWORD *)&__dst[48] = unk_1B8A3C4C4;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x10uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 20:
    case 24:
      uint64_t v11 = operator new(0x40uLL);
      *(void *)&__dst[8] = v11 + 4;
      *(void *)&__dst[16] = v11 + 4;
      *uint64_t v11 = xmmword_1B8A3D6E0;
      v11[1] = unk_1B8A3D6F0;
      v11[2] = xmmword_1B8A3D700;
      v11[3] = unk_1B8A3D710;
      *(void *)__dst = v11;
      uint64_t v12 = operator new(0xC0uLL);
      uint64_t v36 = (char *)(v12 + 12);
      uint8_t v12[8] = xmmword_1B8A3D7A0;
      v12[9] = unk_1B8A3D7B0;
      v12[10] = xmmword_1B8A3D7C0;
      v12[11] = unk_1B8A3D7D0;
      v12[4] = xmmword_1B8A3D760;
      v12[5] = unk_1B8A3D770;
      v12[6] = xmmword_1B8A3D780;
      v12[7] = unk_1B8A3D790;
      *uint64_t v12 = xmmword_1B8A3D720;
      v12[1] = unk_1B8A3D730;
      void v12[2] = xmmword_1B8A3D740;
      void v12[3] = unk_1B8A3D750;
      int v34 = v12;
      unint64_t v35 = v12 + 12;
      int v13 = (char *)operator new(0x3C0uLL);
      uint64_t v31 = v13;
      float v33 = v13 + 960;
      memcpy(v13, &unk_1B8A3D7E0, 0x3C0uLL);
      float v32 = v13 + 960;
      unint64_t v14 = (char *)operator new(0x3C0uLL);
      uint64_t v28 = v14;
      long long v30 = v14 + 960;
      memcpy(v14, &unk_1B8A3DBA0, 0x3C0uLL);
      uint64_t v29 = v14 + 960;
      uint64_t v15 = operator new(0x40uLL);
      _OWORD *v15 = xmmword_1B8A3DF60;
      v15[1] = unk_1B8A3DF70;
      v15[2] = xmmword_1B8A3DF80;
      v15[3] = unk_1B8A3DF90;
      std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)v15, (uint64_t)(v15 + 4), 0x10uLL);
      arkit::unflattenParams((uint64_t)__dst, (uint64_t *)&v34, (uint64_t)&v31, (uint64_t)&v28, a2, a3, a4, a5);
      goto LABEL_11;
    case 21:
    case 25:
      uint64_t v16 = operator new(0x40uLL);
      *(void *)&__dst[8] = v16 + 4;
      *(void *)&__dst[16] = v16 + 4;
      _OWORD *v16 = xmmword_1B8A3CE20;
      v16[1] = unk_1B8A3CE30;
      _OWORD v16[2] = xmmword_1B8A3CE40;
      v16[3] = unk_1B8A3CE50;
      *(void *)__dst = v16;
      uint64_t v12 = operator new(0xC0uLL);
      uint64_t v36 = (char *)(v12 + 12);
      uint8_t v12[8] = xmmword_1B8A3CEE0;
      v12[9] = unk_1B8A3CEF0;
      v12[10] = xmmword_1B8A3CF00;
      v12[11] = unk_1B8A3CF10;
      v12[4] = xmmword_1B8A3CEA0;
      v12[5] = unk_1B8A3CEB0;
      v12[6] = xmmword_1B8A3CEC0;
      v12[7] = unk_1B8A3CED0;
      *uint64_t v12 = xmmword_1B8A3CE60;
      v12[1] = unk_1B8A3CE70;
      void v12[2] = xmmword_1B8A3CE80;
      void v12[3] = unk_1B8A3CE90;
      int v34 = v12;
      unint64_t v35 = v12 + 12;
      int v13 = (char *)operator new(0x3C0uLL);
      uint64_t v31 = v13;
      float v33 = v13 + 960;
      memcpy(v13, &unk_1B8A3CF20, 0x3C0uLL);
      float v32 = v13 + 960;
      unint64_t v14 = (char *)operator new(0x3C0uLL);
      uint64_t v28 = v14;
      long long v30 = v14 + 960;
      memcpy(v14, &unk_1B8A3D2E0, 0x3C0uLL);
      uint64_t v29 = v14 + 960;
      uint64_t v15 = operator new(0x40uLL);
      _OWORD *v15 = xmmword_1B8A3D6A0;
      v15[1] = unk_1B8A3D6B0;
      v15[2] = xmmword_1B8A3D6C0;
      v15[3] = unk_1B8A3D6D0;
      std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)v15, (uint64_t)(v15 + 4), 0x10uLL);
      arkit::unflattenParams((uint64_t)__dst, (uint64_t *)&v34, (uint64_t)&v31, (uint64_t)&v28, a2, a3, a4, a5);
      goto LABEL_11;
    case 22:
    case 26:
      uint64_t v18 = operator new(0x38uLL);
      *(void *)&__dst[8] = (char *)v18 + 56;
      *(void *)&__dst[16] = (char *)v18 + 56;
      *uint64_t v18 = xmmword_1B8A4EBF4;
      v18[1] = unk_1B8A4EC04;
      v18[2] = xmmword_1B8A4EC14;
      *((void *)v18 + 6) = 0x41FF189341DFACC5;
      *(void *)__dst = v18;
      uint64_t v12 = operator new(0xA8uLL);
      uint64_t v36 = (char *)v12 + 168;
      uint8_t v12[8] = xmmword_1B8A4ECAC;
      v12[9] = unk_1B8A4ECBC;
      *((void *)v12 + 20) = 0x39BBB1F238BAA583;
      v12[4] = xmmword_1B8A4EC6C;
      v12[5] = unk_1B8A4EC7C;
      v12[6] = xmmword_1B8A4EC8C;
      v12[7] = unk_1B8A4EC9C;
      *uint64_t v12 = xmmword_1B8A4EC2C;
      v12[1] = unk_1B8A4EC3C;
      void v12[2] = xmmword_1B8A4EC4C;
      void v12[3] = unk_1B8A4EC5C;
      int v34 = v12;
      unint64_t v35 = (char *)v12 + 168;
      int v13 = (char *)operator new(0x348uLL);
      uint64_t v31 = v13;
      float v33 = v13 + 840;
      memcpy(v13, &unk_1B8A4ECD4, 0x348uLL);
      float v32 = v13 + 840;
      unint64_t v14 = (char *)operator new(0x348uLL);
      uint64_t v28 = v14;
      long long v30 = v14 + 840;
      memcpy(v14, &unk_1B8A4F01C, 0x348uLL);
      uint64_t v29 = v14 + 840;
      uint64_t v15 = operator new(0x38uLL);
      _OWORD *v15 = xmmword_1B8A4F364;
      v15[1] = unk_1B8A4F374;
      v15[2] = xmmword_1B8A4F384;
      *((void *)v15 + 6) = 0x3EBE4B883EB90DBFLL;
      std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)v15, (uint64_t)v15 + 56, 0xEuLL);
      arkit::unflattenParams((uint64_t)__dst, (uint64_t *)&v34, (uint64_t)&v31, (uint64_t)&v28, a2, a3, a4, a5);
      goto LABEL_11;
    case 23:
    case 27:
      uint64_t v20 = operator new(0x3CuLL);
      *(void *)&__dst[8] = (char *)v20 + 60;
      *(void *)&__dst[16] = (char *)v20 + 60;
      *uint64_t v20 = xmmword_1B8A4F39C;
      v20[1] = unk_1B8A4F3AC;
      v20[2] = xmmword_1B8A4F3BC;
      *(_OWORD *)((char *)v20 + 44) = *(long long *)((char *)&xmmword_1B8A4F3BC + 12);
      *(void *)__dst = v20;
      uint64_t v12 = operator new(0xB4uLL);
      uint64_t v36 = (char *)v12 + 180;
      *((_DWORD *)v12 + 44) = 984649170;
      uint8_t v12[8] = xmmword_1B8A4F458;
      v12[9] = unk_1B8A4F468;
      v12[10] = xmmword_1B8A4F478;
      v12[4] = xmmword_1B8A4F418;
      v12[5] = unk_1B8A4F428;
      v12[6] = xmmword_1B8A4F438;
      v12[7] = unk_1B8A4F448;
      *uint64_t v12 = xmmword_1B8A4F3D8;
      v12[1] = unk_1B8A4F3E8;
      void v12[2] = xmmword_1B8A4F3F8;
      void v12[3] = unk_1B8A4F408;
      int v34 = v12;
      unint64_t v35 = (char *)v12 + 180;
      int v13 = (char *)operator new(0x384uLL);
      uint64_t v31 = v13;
      float v33 = v13 + 900;
      memcpy(v13, &unk_1B8A4F48C, 0x384uLL);
      float v32 = v13 + 900;
      unint64_t v14 = (char *)operator new(0x384uLL);
      uint64_t v28 = v14;
      long long v30 = v14 + 900;
      memcpy(v14, &unk_1B8A4F810, 0x384uLL);
      uint64_t v29 = v14 + 900;
      uint64_t v15 = operator new(0x3CuLL);
      _OWORD *v15 = xmmword_1B8A4FB94;
      v15[1] = unk_1B8A4FBA4;
      v15[2] = xmmword_1B8A4FBB4;
      *(_OWORD *)((char *)v15 + 44) = *(long long *)((char *)&xmmword_1B8A4FBB4 + 12);
      std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)v15, (uint64_t)v15 + 60, 0xFuLL);
      arkit::unflattenParams((uint64_t)__dst, (uint64_t *)&v34, (uint64_t)&v31, (uint64_t)&v28, a2, a3, a4, a5);
      goto LABEL_11;
    case 28:
      *(_OWORD *)__dst = xmmword_1B8A4FBD0;
      *(_OWORD *)&__dst[16] = unk_1B8A4FBE0;
      *(_OWORD *)&__dst[32] = xmmword_1B8A4FBF0;
      *(_OWORD *)&__dst[48] = unk_1B8A4FC00;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x10uLL);
      *(_OWORD *)&__dst[144] = unk_1B8A4FCA0;
      *(_OWORD *)&__dst[160] = xmmword_1B8A4FCB0;
      *(_OWORD *)&__dst[176] = unk_1B8A4FCC0;
      *(_OWORD *)&__dst[80] = unk_1B8A4FC60;
      *(_OWORD *)&__dst[96] = xmmword_1B8A4FC70;
      *(_OWORD *)&__dst[112] = unk_1B8A4FC80;
      *(_OWORD *)&__dst[128] = xmmword_1B8A4FC90;
      *(_OWORD *)__dst = xmmword_1B8A4FC10;
      *(_OWORD *)&__dst[16] = unk_1B8A4FC20;
      *(_OWORD *)&__dst[32] = xmmword_1B8A4FC30;
      *(_OWORD *)&__dst[48] = unk_1B8A4FC40;
      *(_OWORD *)&__dst[64] = xmmword_1B8A4FC50;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x30uLL);
      memcpy(__dst, &unk_1B8A4FCD0, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xF0uLL);
      memcpy(__dst, &unk_1B8A50090, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xF0uLL);
      *(_OWORD *)__dst = xmmword_1B8A50450;
      *(_OWORD *)&__dst[16] = unk_1B8A50460;
      *(_OWORD *)&__dst[32] = xmmword_1B8A50470;
      *(_OWORD *)&__dst[48] = unk_1B8A50480;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x10uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 29:
      *(_OWORD *)__dst = xmmword_1B8A33500;
      *(_OWORD *)&__dst[16] = unk_1B8A33510;
      *(_OWORD *)&__dst[32] = xmmword_1B8A33520;
      *(_OWORD *)&__dst[48] = unk_1B8A33530;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x10uLL);
      *(_OWORD *)&__dst[144] = unk_1B8A335D0;
      *(_OWORD *)&__dst[160] = xmmword_1B8A335E0;
      *(_OWORD *)&__dst[176] = unk_1B8A335F0;
      *(_OWORD *)&__dst[80] = unk_1B8A33590;
      *(_OWORD *)&__dst[96] = xmmword_1B8A335A0;
      *(_OWORD *)&__dst[112] = unk_1B8A335B0;
      *(_OWORD *)&__dst[128] = xmmword_1B8A335C0;
      *(_OWORD *)__dst = xmmword_1B8A33540;
      *(_OWORD *)&__dst[16] = unk_1B8A33550;
      *(_OWORD *)&__dst[32] = xmmword_1B8A33560;
      *(_OWORD *)&__dst[48] = unk_1B8A33570;
      *(_OWORD *)&__dst[64] = xmmword_1B8A33580;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x30uLL);
      memcpy(__dst, &unk_1B8A33600, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xF0uLL);
      memcpy(__dst, &unk_1B8A339C0, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xF0uLL);
      *(_OWORD *)__dst = xmmword_1B8A33D80;
      *(_OWORD *)&__dst[16] = unk_1B8A33D90;
      *(_OWORD *)&__dst[32] = xmmword_1B8A33DA0;
      *(_OWORD *)&__dst[48] = unk_1B8A33DB0;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x10uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 30:
      *(_OWORD *)__dst = xmmword_1B8A32C40;
      *(_OWORD *)&__dst[16] = unk_1B8A32C50;
      *(_OWORD *)&__dst[32] = xmmword_1B8A32C60;
      *(_OWORD *)&__dst[48] = unk_1B8A32C70;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x10uLL);
      *(_OWORD *)&__dst[144] = unk_1B8A32D10;
      *(_OWORD *)&__dst[160] = xmmword_1B8A32D20;
      *(_OWORD *)&__dst[176] = unk_1B8A32D30;
      *(_OWORD *)&__dst[80] = unk_1B8A32CD0;
      *(_OWORD *)&__dst[96] = xmmword_1B8A32CE0;
      *(_OWORD *)&__dst[112] = unk_1B8A32CF0;
      *(_OWORD *)&__dst[128] = xmmword_1B8A32D00;
      *(_OWORD *)__dst = xmmword_1B8A32C80;
      *(_OWORD *)&__dst[16] = unk_1B8A32C90;
      *(_OWORD *)&__dst[32] = xmmword_1B8A32CA0;
      *(_OWORD *)&__dst[48] = unk_1B8A32CB0;
      *(_OWORD *)&__dst[64] = xmmword_1B8A32CC0;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x30uLL);
      memcpy(__dst, &unk_1B8A32D40, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xF0uLL);
      memcpy(__dst, &unk_1B8A33100, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xF0uLL);
      *(_OWORD *)__dst = xmmword_1B8A334C0;
      *(_OWORD *)&__dst[16] = unk_1B8A334D0;
      *(_OWORD *)&__dst[32] = xmmword_1B8A334E0;
      *(_OWORD *)&__dst[48] = unk_1B8A334F0;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x10uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 31:
      *(_OWORD *)__dst = xmmword_1B8A34798;
      *(_OWORD *)&__dst[16] = unk_1B8A347A8;
      *(_OWORD *)&__dst[32] = xmmword_1B8A347B8;
      *(_OWORD *)&__dst[48] = unk_1B8A347C8;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x10uLL);
      *(_OWORD *)&__dst[144] = unk_1B8A34868;
      *(_OWORD *)&__dst[160] = xmmword_1B8A34878;
      *(_OWORD *)&__dst[176] = unk_1B8A34888;
      *(_OWORD *)&__dst[80] = unk_1B8A34828;
      *(_OWORD *)&__dst[96] = xmmword_1B8A34838;
      *(_OWORD *)&__dst[112] = unk_1B8A34848;
      *(_OWORD *)&__dst[128] = xmmword_1B8A34858;
      *(_OWORD *)__dst = xmmword_1B8A347D8;
      *(_OWORD *)&__dst[16] = unk_1B8A347E8;
      *(_OWORD *)&__dst[32] = xmmword_1B8A347F8;
      *(_OWORD *)&__dst[48] = unk_1B8A34808;
      *(_OWORD *)&__dst[64] = xmmword_1B8A34818;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x30uLL);
      memcpy(__dst, &unk_1B8A34898, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xF0uLL);
      memcpy(__dst, &unk_1B8A34C58, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xF0uLL);
      *(_OWORD *)__dst = xmmword_1B8A35018;
      *(_OWORD *)&__dst[16] = unk_1B8A35028;
      *(_OWORD *)&__dst[32] = xmmword_1B8A35038;
      *(_OWORD *)&__dst[48] = unk_1B8A35048;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x10uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 32:
      *(_OWORD *)&__dst[16] = unk_1B8A33DD0;
      *(_OWORD *)&__dst[32] = xmmword_1B8A33DE0;
      *(_OWORD *)&__dst[48] = unk_1B8A33DF0;
      *(void *)&__dst[64] = 0x41F0831241EF45A2;
      *(_OWORD *)__dst = xmmword_1B8A33DC0;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x12uLL);
      *(_OWORD *)&__dst[176] = unk_1B8A33EB8;
      *(_OWORD *)&__dst[192] = xmmword_1B8A33EC8;
      *(_OWORD *)&__dst[112] = unk_1B8A33E78;
      *(_OWORD *)&__dst[128] = xmmword_1B8A33E88;
      *(_OWORD *)&__dst[144] = unk_1B8A33E98;
      *(_OWORD *)&__dst[160] = xmmword_1B8A33EA8;
      *(_OWORD *)&__dst[48] = unk_1B8A33E38;
      *(_OWORD *)&__dst[64] = xmmword_1B8A33E48;
      *(_OWORD *)&__dst[80] = unk_1B8A33E58;
      *(_OWORD *)&__dst[96] = xmmword_1B8A33E68;
      *(_OWORD *)__dst = xmmword_1B8A33E08;
      *(void *)&__dst[208] = 0x3A288AF93705D7F6;
      *(_OWORD *)&__dst[16] = unk_1B8A33E18;
      *(_OWORD *)&__dst[32] = xmmword_1B8A33E28;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x36uLL);
      memcpy(__dst, &unk_1B8A33EE0, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0x10EuLL);
      memcpy(__dst, &unk_1B8A34318, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0x10EuLL);
      *(_OWORD *)&__dst[16] = unk_1B8A34760;
      *(_OWORD *)&__dst[32] = xmmword_1B8A34770;
      *(_OWORD *)&__dst[48] = unk_1B8A34780;
      *(void *)&__dst[64] = 0x3F2C26573F297785;
      *(_OWORD *)__dst = xmmword_1B8A34750;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x12uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 33:
      *(_OWORD *)&__dst[16] = unk_1B8A30FE0;
      *(_OWORD *)&__dst[32] = xmmword_1B8A30FF0;
      *(_OWORD *)&__dst[48] = unk_1B8A31000;
      *(void *)&__dst[64] = 0x420B90CD41F6113ELL;
      *(_OWORD *)__dst = xmmword_1B8A30FD0;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x12uLL);
      *(_OWORD *)&__dst[176] = unk_1B8A310C8;
      *(_OWORD *)&__dst[192] = xmmword_1B8A310D8;
      *(_OWORD *)&__dst[112] = unk_1B8A31088;
      *(_OWORD *)&__dst[128] = xmmword_1B8A31098;
      *(_OWORD *)&__dst[144] = unk_1B8A310A8;
      *(_OWORD *)&__dst[160] = xmmword_1B8A310B8;
      *(_OWORD *)&__dst[48] = unk_1B8A31048;
      *(_OWORD *)&__dst[64] = xmmword_1B8A31058;
      *(_OWORD *)&__dst[80] = unk_1B8A31068;
      *(_OWORD *)&__dst[96] = xmmword_1B8A31078;
      *(_OWORD *)__dst = xmmword_1B8A31018;
      *(void *)&__dst[208] = 0x3928D21C394C78EALL;
      *(_OWORD *)&__dst[16] = unk_1B8A31028;
      *(_OWORD *)&__dst[32] = xmmword_1B8A31038;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x36uLL);
      memcpy(__dst, &unk_1B8A310F0, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0x10EuLL);
      memcpy(__dst, &unk_1B8A31528, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0x10EuLL);
      *(_OWORD *)&__dst[16] = unk_1B8A31970;
      *(_OWORD *)&__dst[32] = xmmword_1B8A31980;
      *(_OWORD *)&__dst[48] = unk_1B8A31990;
      *(void *)&__dst[64] = 0x3F2879D53F2547F1;
      *(_OWORD *)__dst = xmmword_1B8A31960;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x12uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 34:
      *(_OWORD *)__dst = xmmword_1B8A30684;
      *(_OWORD *)&__dst[16] = unk_1B8A30694;
      *(_OWORD *)&__dst[32] = xmmword_1B8A306A4;
      *(_OWORD *)&__dst[48] = unk_1B8A306B4;
      *(_DWORD *)&__dst[64] = 1107628358;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x11uLL);
      *(_OWORD *)&__dst[144] = unk_1B8A30758;
      *(_OWORD *)&__dst[160] = xmmword_1B8A30768;
      *(_OWORD *)&__dst[176] = unk_1B8A30778;
      *(_OWORD *)&__dst[188] = unk_1B8A30784;
      *(_OWORD *)&__dst[80] = unk_1B8A30718;
      *(_OWORD *)&__dst[96] = xmmword_1B8A30728;
      *(_OWORD *)&__dst[112] = unk_1B8A30738;
      *(_OWORD *)&__dst[128] = xmmword_1B8A30748;
      *(_OWORD *)&__dst[16] = unk_1B8A306D8;
      *(_OWORD *)&__dst[32] = xmmword_1B8A306E8;
      *(_OWORD *)&__dst[48] = unk_1B8A306F8;
      *(_OWORD *)&__dst[64] = xmmword_1B8A30708;
      *(_OWORD *)__dst = xmmword_1B8A306C8;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x33uLL);
      memcpy(__dst, &unk_1B8A30794, 0x3FCuLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xFFuLL);
      memcpy(__dst, &unk_1B8A30B90, 0x3FCuLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xFFuLL);
      *(_OWORD *)__dst = xmmword_1B8A30F8C;
      *(_OWORD *)&__dst[16] = unk_1B8A30F9C;
      *(_OWORD *)&__dst[32] = xmmword_1B8A30FAC;
      *(_OWORD *)&__dst[48] = unk_1B8A30FBC;
      *(_DWORD *)&__dst[64] = 1059764423;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x11uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 35:
      *(_OWORD *)__dst = xmmword_1B8A32380;
      *(_OWORD *)&__dst[16] = unk_1B8A32390;
      *(_OWORD *)&__dst[32] = xmmword_1B8A323A0;
      *(_OWORD *)&__dst[48] = unk_1B8A323B0;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x10uLL);
      *(_OWORD *)&__dst[144] = unk_1B8A32450;
      *(_OWORD *)&__dst[160] = xmmword_1B8A32460;
      *(_OWORD *)&__dst[176] = unk_1B8A32470;
      *(_OWORD *)&__dst[80] = unk_1B8A32410;
      *(_OWORD *)&__dst[96] = xmmword_1B8A32420;
      *(_OWORD *)&__dst[112] = unk_1B8A32430;
      *(_OWORD *)&__dst[128] = xmmword_1B8A32440;
      *(_OWORD *)__dst = xmmword_1B8A323C0;
      *(_OWORD *)&__dst[16] = unk_1B8A323D0;
      *(_OWORD *)&__dst[32] = xmmword_1B8A323E0;
      *(_OWORD *)&__dst[48] = unk_1B8A323F0;
      *(_OWORD *)&__dst[64] = xmmword_1B8A32400;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x30uLL);
      memcpy(__dst, &unk_1B8A32480, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xF0uLL);
      memcpy(__dst, &unk_1B8A32840, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xF0uLL);
      *(_OWORD *)__dst = xmmword_1B8A32C00;
      *(_OWORD *)&__dst[16] = unk_1B8A32C10;
      *(_OWORD *)&__dst[32] = xmmword_1B8A32C20;
      *(_OWORD *)&__dst[48] = unk_1B8A32C30;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x10uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 36:
      *(_OWORD *)&__dst[16] = unk_1B8A319B8;
      *(_OWORD *)&__dst[32] = xmmword_1B8A319C8;
      *(_OWORD *)&__dst[48] = unk_1B8A319D8;
      *(void *)&__dst[64] = 0x41FDA7F941E7D63FLL;
      *(_OWORD *)__dst = xmmword_1B8A319A8;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x12uLL);
      *(_OWORD *)&__dst[176] = unk_1B8A31AA0;
      *(_OWORD *)&__dst[192] = xmmword_1B8A31AB0;
      *(_OWORD *)&__dst[112] = unk_1B8A31A60;
      *(_OWORD *)&__dst[128] = xmmword_1B8A31A70;
      *(_OWORD *)&__dst[144] = unk_1B8A31A80;
      *(_OWORD *)&__dst[160] = xmmword_1B8A31A90;
      *(_OWORD *)&__dst[48] = unk_1B8A31A20;
      *(_OWORD *)&__dst[64] = xmmword_1B8A31A30;
      *(_OWORD *)&__dst[80] = unk_1B8A31A40;
      *(_OWORD *)&__dst[96] = xmmword_1B8A31A50;
      *(_OWORD *)__dst = xmmword_1B8A319F0;
      *(void *)&__dst[208] = 0x380A697B358637BDLL;
      *(_OWORD *)&__dst[16] = unk_1B8A31A00;
      *(_OWORD *)&__dst[32] = xmmword_1B8A31A10;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x36uLL);
      memcpy(__dst, &unk_1B8A31AC8, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0x10EuLL);
      memcpy(__dst, &unk_1B8A31F00, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0x10EuLL);
      *(_OWORD *)&__dst[16] = unk_1B8A32348;
      *(_OWORD *)&__dst[32] = xmmword_1B8A32358;
      *(_OWORD *)&__dst[48] = unk_1B8A32368;
      *(void *)&__dst[64] = 0x3F2936D63F26466BLL;
      *(_OWORD *)__dst = xmmword_1B8A32338;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x12uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 37:
      *(_OWORD *)__dst = xmmword_1B8A3F1AC;
      *(_OWORD *)&__dst[16] = unk_1B8A3F1BC;
      *(_OWORD *)&__dst[32] = xmmword_1B8A3F1CC;
      *(_OWORD *)&__dst[44] = *(long long *)((char *)&xmmword_1B8A3F1CC + 12);
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0xFuLL);
      *(_OWORD *)&__dst[112] = unk_1B8A3F258;
      *(_OWORD *)&__dst[128] = xmmword_1B8A3F268;
      *(_OWORD *)&__dst[144] = unk_1B8A3F278;
      *(_OWORD *)&__dst[160] = xmmword_1B8A3F288;
      *(_OWORD *)&__dst[48] = unk_1B8A3F218;
      *(_OWORD *)&__dst[64] = xmmword_1B8A3F228;
      *(_OWORD *)&__dst[80] = unk_1B8A3F238;
      *(_OWORD *)&__dst[96] = xmmword_1B8A3F248;
      *(_OWORD *)__dst = xmmword_1B8A3F1E8;
      *(_OWORD *)&__dst[16] = unk_1B8A3F1F8;
      *(_OWORD *)&__dst[32] = xmmword_1B8A3F208;
      *(_DWORD *)&__dst[176] = 974499625;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x2DuLL);
      memcpy(__dst, &unk_1B8A3F29C, 0x384uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xE1uLL);
      memcpy(__dst, &unk_1B8A3F620, 0x384uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xE1uLL);
      *(_OWORD *)__dst = xmmword_1B8A3F9A4;
      *(_OWORD *)&__dst[16] = unk_1B8A3F9B4;
      *(_OWORD *)&__dst[32] = xmmword_1B8A3F9C4;
      *(_OWORD *)&__dst[44] = *(long long *)((char *)&xmmword_1B8A3F9C4 + 12);
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0xFuLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 38:
      *(_OWORD *)&__dst[16] = unk_1B8A40EB8;
      *(_OWORD *)&__dst[32] = xmmword_1B8A40EC8;
      *(_OWORD *)&__dst[48] = unk_1B8A40ED8;
      *(void *)&__dst[64] = 0x420394AC41EFBA84;
      *(_OWORD *)__dst = xmmword_1B8A40EA8;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x12uLL);
      *(_OWORD *)&__dst[176] = unk_1B8A40FA0;
      *(_OWORD *)&__dst[192] = xmmword_1B8A40FB0;
      *(_OWORD *)&__dst[112] = unk_1B8A40F60;
      *(_OWORD *)&__dst[128] = xmmword_1B8A40F70;
      *(_OWORD *)&__dst[144] = unk_1B8A40F80;
      *(_OWORD *)&__dst[160] = xmmword_1B8A40F90;
      *(_OWORD *)&__dst[48] = unk_1B8A40F20;
      *(_OWORD *)&__dst[64] = xmmword_1B8A40F30;
      *(_OWORD *)&__dst[80] = unk_1B8A40F40;
      *(_OWORD *)&__dst[96] = xmmword_1B8A40F50;
      *(_OWORD *)__dst = xmmword_1B8A40EF0;
      *(void *)&__dst[208] = 0x3955E8D5390A697BLL;
      *(_OWORD *)&__dst[16] = unk_1B8A40F00;
      *(_OWORD *)&__dst[32] = xmmword_1B8A40F10;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x36uLL);
      memcpy(__dst, &unk_1B8A40FC8, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0x10EuLL);
      memcpy(__dst, &unk_1B8A41400, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0x10EuLL);
      *(_OWORD *)&__dst[16] = unk_1B8A41848;
      *(_OWORD *)&__dst[32] = xmmword_1B8A41858;
      *(_OWORD *)&__dst[48] = unk_1B8A41868;
      *(void *)&__dst[64] = 0x3F210E343F19E27ALL;
      *(_OWORD *)__dst = xmmword_1B8A41838;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x12uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 39:
      *(_OWORD *)&__dst[16] = unk_1B8A41890;
      *(_OWORD *)&__dst[32] = xmmword_1B8A418A0;
      *(_OWORD *)&__dst[48] = unk_1B8A418B0;
      *(_OWORD *)&__dst[60] = unk_1B8A418BC;
      *(_OWORD *)__dst = xmmword_1B8A41880;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x13uLL);
      *(_OWORD *)&__dst[176] = unk_1B8A4197C;
      *(_OWORD *)&__dst[192] = xmmword_1B8A4198C;
      *(_OWORD *)&__dst[208] = unk_1B8A4199C;
      *(_OWORD *)&__dst[112] = unk_1B8A4193C;
      *(_OWORD *)&__dst[128] = xmmword_1B8A4194C;
      *(_OWORD *)&__dst[144] = unk_1B8A4195C;
      *(_OWORD *)&__dst[160] = xmmword_1B8A4196C;
      *(_OWORD *)&__dst[48] = unk_1B8A418FC;
      *(_OWORD *)&__dst[64] = xmmword_1B8A4190C;
      *(_OWORD *)&__dst[80] = unk_1B8A4191C;
      *(_OWORD *)&__dst[96] = xmmword_1B8A4192C;
      *(_OWORD *)__dst = xmmword_1B8A418CC;
      *(_OWORD *)&__dst[16] = unk_1B8A418DC;
      *(_OWORD *)&__dst[32] = xmmword_1B8A418EC;
      *(_DWORD *)&__dst[224] = 929751435;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x39uLL);
      memcpy(__dst, &unk_1B8A419B0, 0x474uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0x11DuLL);
      memcpy(__dst, &unk_1B8A41E24, 0x474uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0x11DuLL);
      *(_OWORD *)&__dst[16] = unk_1B8A422A8;
      *(_OWORD *)&__dst[32] = xmmword_1B8A422B8;
      *(_OWORD *)&__dst[48] = unk_1B8A422C8;
      *(_OWORD *)&__dst[60] = unk_1B8A422D4;
      *(_OWORD *)__dst = xmmword_1B8A42298;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x13uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 40:
      *(_OWORD *)__dst = xmmword_1B8A422E4;
      *(_OWORD *)&__dst[16] = unk_1B8A422F4;
      *(_OWORD *)&__dst[32] = xmmword_1B8A42304;
      *(_OWORD *)&__dst[44] = *(long long *)((char *)&xmmword_1B8A42304 + 12);
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0xFuLL);
      *(_OWORD *)&__dst[112] = unk_1B8A42390;
      *(_OWORD *)&__dst[128] = xmmword_1B8A423A0;
      *(_OWORD *)&__dst[144] = unk_1B8A423B0;
      *(_OWORD *)&__dst[160] = xmmword_1B8A423C0;
      *(_OWORD *)&__dst[48] = unk_1B8A42350;
      *(_OWORD *)&__dst[64] = xmmword_1B8A42360;
      *(_OWORD *)&__dst[80] = unk_1B8A42370;
      *(_OWORD *)&__dst[96] = xmmword_1B8A42380;
      *(_OWORD *)__dst = xmmword_1B8A42320;
      *(_OWORD *)&__dst[16] = unk_1B8A42330;
      *(_OWORD *)&__dst[32] = xmmword_1B8A42340;
      *(_DWORD *)&__dst[176] = 0;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x2DuLL);
      memcpy(__dst, &unk_1B8A423D4, 0x384uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xE1uLL);
      memcpy(__dst, &unk_1B8A42758, 0x384uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xE1uLL);
      *(_OWORD *)__dst = xmmword_1B8A42ADC;
      *(_OWORD *)&__dst[16] = unk_1B8A42AEC;
      *(_OWORD *)&__dst[32] = xmmword_1B8A42AFC;
      *(_OWORD *)&__dst[44] = *(long long *)((char *)&xmmword_1B8A42AFC + 12);
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0xFuLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 41:
      *(_OWORD *)&__dst[16] = unk_1B8A42B28;
      *(_OWORD *)&__dst[32] = xmmword_1B8A42B38;
      *(_OWORD *)&__dst[48] = unk_1B8A42B48;
      *(void *)&__dst[64] = 0x42004EF741F0AF74;
      *(_OWORD *)__dst = xmmword_1B8A42B18;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x12uLL);
      *(_OWORD *)&__dst[176] = unk_1B8A42C10;
      *(_OWORD *)&__dst[192] = xmmword_1B8A42C20;
      *(_OWORD *)&__dst[112] = unk_1B8A42BD0;
      *(_OWORD *)&__dst[128] = xmmword_1B8A42BE0;
      *(_OWORD *)&__dst[144] = unk_1B8A42BF0;
      *(_OWORD *)&__dst[160] = xmmword_1B8A42C00;
      *(_OWORD *)&__dst[48] = unk_1B8A42B90;
      *(_OWORD *)&__dst[64] = xmmword_1B8A42BA0;
      *(_OWORD *)&__dst[80] = unk_1B8A42BB0;
      *(_OWORD *)&__dst[96] = xmmword_1B8A42BC0;
      *(_OWORD *)__dst = xmmword_1B8A42B60;
      *(void *)&__dst[208] = 0x37E27E0F3855E8D5;
      *(_OWORD *)&__dst[16] = unk_1B8A42B70;
      *(_OWORD *)&__dst[32] = xmmword_1B8A42B80;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x36uLL);
      memcpy(__dst, &unk_1B8A42C38, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0x10EuLL);
      memcpy(__dst, &unk_1B8A43070, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0x10EuLL);
      *(_OWORD *)&__dst[16] = unk_1B8A434B8;
      *(_OWORD *)&__dst[32] = xmmword_1B8A434C8;
      *(_OWORD *)&__dst[48] = unk_1B8A434D8;
      *(void *)&__dst[64] = 0x3F2DAFE23F2C5B3ALL;
      *(_OWORD *)__dst = xmmword_1B8A434A8;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x12uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 42:
      *(_OWORD *)&__dst[16] = unk_1B8A43500;
      *(_OWORD *)&__dst[32] = xmmword_1B8A43510;
      *(_OWORD *)&__dst[48] = unk_1B8A43520;
      *(void *)&__dst[64] = 0x4200033741E8DB70;
      *(_OWORD *)__dst = xmmword_1B8A434F0;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x12uLL);
      *(_OWORD *)&__dst[176] = unk_1B8A435E8;
      *(_OWORD *)&__dst[192] = xmmword_1B8A435F8;
      *(_OWORD *)&__dst[112] = unk_1B8A435A8;
      *(_OWORD *)&__dst[128] = xmmword_1B8A435B8;
      *(_OWORD *)&__dst[144] = unk_1B8A435C8;
      *(_OWORD *)&__dst[160] = xmmword_1B8A435D8;
      *(_OWORD *)&__dst[48] = unk_1B8A43568;
      *(_OWORD *)&__dst[64] = xmmword_1B8A43578;
      *(_OWORD *)&__dst[80] = unk_1B8A43588;
      *(_OWORD *)&__dst[96] = xmmword_1B8A43598;
      *(_OWORD *)__dst = xmmword_1B8A43538;
      *(void *)&__dst[208] = 0x38BAA583390205FFLL;
      *(_OWORD *)&__dst[16] = unk_1B8A43548;
      *(_OWORD *)&__dst[32] = xmmword_1B8A43558;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x36uLL);
      memcpy(__dst, &unk_1B8A43610, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0x10EuLL);
      memcpy(__dst, &unk_1B8A43A48, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0x10EuLL);
      *(_OWORD *)&__dst[16] = unk_1B8A43E90;
      *(_OWORD *)&__dst[32] = xmmword_1B8A43EA0;
      *(_OWORD *)&__dst[48] = unk_1B8A43EB0;
      *(void *)&__dst[64] = 0x3F31BB283F2DFA01;
      *(_OWORD *)__dst = xmmword_1B8A43E80;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x12uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 43:
      *(_OWORD *)__dst = xmmword_1B8A460B0;
      *(_OWORD *)&__dst[16] = unk_1B8A460C0;
      *(_OWORD *)&__dst[32] = xmmword_1B8A460D0;
      *(_OWORD *)&__dst[48] = unk_1B8A460E0;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x10uLL);
      *(_OWORD *)&__dst[144] = unk_1B8A46180;
      *(_OWORD *)&__dst[160] = xmmword_1B8A46190;
      *(_OWORD *)&__dst[176] = unk_1B8A461A0;
      *(_OWORD *)&__dst[80] = unk_1B8A46140;
      *(_OWORD *)&__dst[96] = xmmword_1B8A46150;
      *(_OWORD *)&__dst[112] = unk_1B8A46160;
      *(_OWORD *)&__dst[128] = xmmword_1B8A46170;
      *(_OWORD *)__dst = xmmword_1B8A460F0;
      *(_OWORD *)&__dst[16] = unk_1B8A46100;
      *(_OWORD *)&__dst[32] = xmmword_1B8A46110;
      *(_OWORD *)&__dst[48] = unk_1B8A46120;
      *(_OWORD *)&__dst[64] = xmmword_1B8A46130;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x30uLL);
      memcpy(__dst, &unk_1B8A461B0, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xF0uLL);
      memcpy(__dst, &unk_1B8A46570, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xF0uLL);
      *(_OWORD *)__dst = xmmword_1B8A46930;
      *(_OWORD *)&__dst[16] = unk_1B8A46940;
      *(_OWORD *)&__dst[32] = xmmword_1B8A46950;
      *(_OWORD *)&__dst[48] = unk_1B8A46960;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x10uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 44:
      *(_OWORD *)__dst = xmmword_1B8A46970;
      *(_OWORD *)&__dst[16] = unk_1B8A46980;
      *(_OWORD *)&__dst[32] = xmmword_1B8A46990;
      *(_OWORD *)&__dst[48] = unk_1B8A469A0;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x10uLL);
      *(_OWORD *)&__dst[144] = unk_1B8A46A40;
      *(_OWORD *)&__dst[160] = xmmword_1B8A46A50;
      *(_OWORD *)&__dst[176] = unk_1B8A46A60;
      *(_OWORD *)&__dst[80] = unk_1B8A46A00;
      *(_OWORD *)&__dst[96] = xmmword_1B8A46A10;
      *(_OWORD *)&__dst[112] = unk_1B8A46A20;
      *(_OWORD *)&__dst[128] = xmmword_1B8A46A30;
      *(_OWORD *)__dst = xmmword_1B8A469B0;
      *(_OWORD *)&__dst[16] = unk_1B8A469C0;
      *(_OWORD *)&__dst[32] = xmmword_1B8A469D0;
      *(_OWORD *)&__dst[48] = unk_1B8A469E0;
      *(_OWORD *)&__dst[64] = xmmword_1B8A469F0;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x30uLL);
      memcpy(__dst, &unk_1B8A46A70, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xF0uLL);
      memcpy(__dst, &unk_1B8A46E30, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xF0uLL);
      *(_OWORD *)__dst = xmmword_1B8A471F0;
      *(_OWORD *)&__dst[16] = unk_1B8A47200;
      *(_OWORD *)&__dst[32] = xmmword_1B8A47210;
      *(_OWORD *)&__dst[48] = unk_1B8A47220;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x10uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 45:
      *(_OWORD *)__dst = xmmword_1B8A47230;
      *(_OWORD *)&__dst[16] = unk_1B8A47240;
      *(_OWORD *)&__dst[32] = xmmword_1B8A47250;
      *(_OWORD *)&__dst[44] = *(long long *)((char *)&xmmword_1B8A47250 + 12);
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0xFuLL);
      *(_OWORD *)&__dst[112] = unk_1B8A472DC;
      *(_OWORD *)&__dst[128] = xmmword_1B8A472EC;
      *(_OWORD *)&__dst[144] = unk_1B8A472FC;
      *(_OWORD *)&__dst[160] = xmmword_1B8A4730C;
      *(_OWORD *)&__dst[48] = unk_1B8A4729C;
      *(_OWORD *)&__dst[64] = xmmword_1B8A472AC;
      *(_OWORD *)&__dst[80] = unk_1B8A472BC;
      *(_OWORD *)&__dst[96] = xmmword_1B8A472CC;
      *(_OWORD *)__dst = xmmword_1B8A4726C;
      *(_OWORD *)&__dst[16] = unk_1B8A4727C;
      *(_OWORD *)&__dst[32] = xmmword_1B8A4728C;
      *(_DWORD *)&__dst[176] = 1001742066;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x2DuLL);
      memcpy(__dst, &unk_1B8A47320, 0x384uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xE1uLL);
      memcpy(__dst, &unk_1B8A476A4, 0x384uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xE1uLL);
      *(_OWORD *)__dst = xmmword_1B8A47A28;
      *(_OWORD *)&__dst[16] = unk_1B8A47A38;
      *(_OWORD *)&__dst[32] = xmmword_1B8A47A48;
      *(_OWORD *)&__dst[44] = *(long long *)((char *)&xmmword_1B8A47A48 + 12);
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0xFuLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 46:
      *(_OWORD *)__dst = xmmword_1B8A47A64;
      *(_OWORD *)&__dst[16] = unk_1B8A47A74;
      *(_OWORD *)&__dst[32] = xmmword_1B8A47A84;
      *(_OWORD *)&__dst[48] = unk_1B8A47A94;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x10uLL);
      *(_OWORD *)&__dst[144] = unk_1B8A47B34;
      *(_OWORD *)&__dst[160] = xmmword_1B8A47B44;
      *(_OWORD *)&__dst[176] = unk_1B8A47B54;
      *(_OWORD *)&__dst[80] = unk_1B8A47AF4;
      *(_OWORD *)&__dst[96] = xmmword_1B8A47B04;
      *(_OWORD *)&__dst[112] = unk_1B8A47B14;
      *(_OWORD *)&__dst[128] = xmmword_1B8A47B24;
      *(_OWORD *)__dst = xmmword_1B8A47AA4;
      *(_OWORD *)&__dst[16] = unk_1B8A47AB4;
      *(_OWORD *)&__dst[32] = xmmword_1B8A47AC4;
      *(_OWORD *)&__dst[48] = unk_1B8A47AD4;
      *(_OWORD *)&__dst[64] = xmmword_1B8A47AE4;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x30uLL);
      memcpy(__dst, &unk_1B8A47B64, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xF0uLL);
      memcpy(__dst, &unk_1B8A47F24, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xF0uLL);
      *(_OWORD *)__dst = xmmword_1B8A482E4;
      *(_OWORD *)&__dst[16] = unk_1B8A482F4;
      *(_OWORD *)&__dst[32] = xmmword_1B8A48304;
      *(_OWORD *)&__dst[48] = unk_1B8A48314;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x10uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 47:
      *(_OWORD *)__dst = xmmword_1B8A48324;
      *(_OWORD *)&__dst[16] = unk_1B8A48334;
      *(_OWORD *)&__dst[32] = xmmword_1B8A48344;
      *(_OWORD *)&__dst[48] = unk_1B8A48354;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x10uLL);
      *(_OWORD *)&__dst[144] = unk_1B8A483F4;
      *(_OWORD *)&__dst[160] = xmmword_1B8A48404;
      *(_OWORD *)&__dst[176] = unk_1B8A48414;
      *(_OWORD *)&__dst[80] = unk_1B8A483B4;
      *(_OWORD *)&__dst[96] = xmmword_1B8A483C4;
      *(_OWORD *)&__dst[112] = unk_1B8A483D4;
      *(_OWORD *)&__dst[128] = xmmword_1B8A483E4;
      *(_OWORD *)__dst = xmmword_1B8A48364;
      *(_OWORD *)&__dst[16] = unk_1B8A48374;
      *(_OWORD *)&__dst[32] = xmmword_1B8A48384;
      *(_OWORD *)&__dst[48] = unk_1B8A48394;
      *(_OWORD *)&__dst[64] = xmmword_1B8A483A4;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x30uLL);
      memcpy(__dst, &unk_1B8A48424, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xF0uLL);
      memcpy(__dst, &unk_1B8A487E4, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xF0uLL);
      *(_OWORD *)__dst = xmmword_1B8A48BA4;
      *(_OWORD *)&__dst[16] = unk_1B8A48BB4;
      *(_OWORD *)&__dst[32] = xmmword_1B8A48BC4;
      *(_OWORD *)&__dst[48] = unk_1B8A48BD4;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x10uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 48:
      *(_OWORD *)__dst = xmmword_1B8A49E4C;
      *(_OWORD *)&__dst[16] = unk_1B8A49E5C;
      *(_OWORD *)&__dst[32] = xmmword_1B8A49E6C;
      *(void *)&__dst[48] = 0x4204750141F0E75ELL;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0xEuLL);
      *(_OWORD *)&__dst[112] = unk_1B8A49EF4;
      *(_OWORD *)&__dst[128] = xmmword_1B8A49F04;
      *(_OWORD *)&__dst[144] = unk_1B8A49F14;
      *(_OWORD *)&__dst[48] = unk_1B8A49EB4;
      *(_OWORD *)&__dst[64] = xmmword_1B8A49EC4;
      *(_OWORD *)&__dst[80] = unk_1B8A49ED4;
      *(_OWORD *)&__dst[96] = xmmword_1B8A49EE4;
      *(_OWORD *)__dst = xmmword_1B8A49E84;
      *(void *)&__dst[160] = 0x3C2A10E03AC7C0F4;
      *(_OWORD *)&__dst[16] = unk_1B8A49E94;
      *(_OWORD *)&__dst[32] = xmmword_1B8A49EA4;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x2AuLL);
      memcpy(__dst, &unk_1B8A49F2C, 0x348uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xD2uLL);
      memcpy(__dst, &unk_1B8A4A274, 0x348uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xD2uLL);
      *(_OWORD *)__dst = xmmword_1B8A4A5BC;
      *(_OWORD *)&__dst[16] = unk_1B8A4A5CC;
      *(_OWORD *)&__dst[32] = xmmword_1B8A4A5DC;
      *(void *)&__dst[48] = 0x3E7AD7D83E6BD33DLL;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0xEuLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 49:
      *(_OWORD *)__dst = xmmword_1B8A4A5F4;
      *(_OWORD *)&__dst[16] = unk_1B8A4A604;
      *(_OWORD *)&__dst[32] = xmmword_1B8A4A614;
      *(_OWORD *)&__dst[44] = *(long long *)((char *)&xmmword_1B8A4A614 + 12);
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0xFuLL);
      *(_OWORD *)&__dst[112] = unk_1B8A48C54;
      *(_OWORD *)&__dst[128] = xmmword_1B8A48C64;
      *(_OWORD *)&__dst[144] = unk_1B8A48C74;
      *(_OWORD *)&__dst[160] = xmmword_1B8A48C84;
      *(_OWORD *)&__dst[48] = unk_1B8A48C14;
      *(_OWORD *)&__dst[64] = xmmword_1B8A48C24;
      *(_OWORD *)&__dst[80] = unk_1B8A48C34;
      *(_OWORD *)&__dst[96] = xmmword_1B8A48C44;
      *(_OWORD *)__dst = xmmword_1B8A48BE4;
      *(_OWORD *)&__dst[16] = unk_1B8A48BF4;
      *(_OWORD *)&__dst[32] = xmmword_1B8A48C04;
      *(_DWORD *)&__dst[176] = 986478826;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x2DuLL);
      memcpy(__dst, &unk_1B8A4A6E4, 0x384uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xE1uLL);
      memcpy(__dst, &unk_1B8A4AA68, 0x384uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xE1uLL);
      *(_OWORD *)__dst = xmmword_1B8A4ADEC;
      *(_OWORD *)&__dst[16] = unk_1B8A4ADFC;
      *(_OWORD *)&__dst[32] = xmmword_1B8A4AE0C;
      *(_OWORD *)&__dst[44] = *(long long *)((char *)&xmmword_1B8A4AE0C + 12);
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0xFuLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 50:
      *(_OWORD *)__dst = xmmword_1B8A48C98;
      *(_OWORD *)&__dst[16] = unk_1B8A48CA8;
      *(_OWORD *)&__dst[32] = xmmword_1B8A48CB8;
      *(_OWORD *)&__dst[44] = *(long long *)((char *)&xmmword_1B8A48CB8 + 12);
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0xFuLL);
      *(_OWORD *)&__dst[112] = unk_1B8A48D44;
      *(_OWORD *)&__dst[128] = xmmword_1B8A48D54;
      *(_OWORD *)&__dst[144] = unk_1B8A48D64;
      *(_OWORD *)&__dst[160] = xmmword_1B8A48D74;
      *(_OWORD *)&__dst[48] = unk_1B8A48D04;
      *(_OWORD *)&__dst[64] = xmmword_1B8A48D14;
      *(_OWORD *)&__dst[80] = unk_1B8A48D24;
      *(_OWORD *)&__dst[96] = xmmword_1B8A48D34;
      *(_OWORD *)__dst = xmmword_1B8A48CD4;
      *(_OWORD *)&__dst[16] = unk_1B8A48CE4;
      *(_OWORD *)&__dst[32] = xmmword_1B8A48CF4;
      *(_DWORD *)&__dst[176] = 910775196;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x2DuLL);
      memcpy(__dst, &unk_1B8A48D88, 0x384uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xE1uLL);
      memcpy(__dst, &unk_1B8A4910C, 0x384uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xE1uLL);
      *(_OWORD *)__dst = xmmword_1B8A49490;
      *(_OWORD *)&__dst[16] = unk_1B8A494A0;
      *(_OWORD *)&__dst[32] = xmmword_1B8A494B0;
      *(_OWORD *)&__dst[44] = *(long long *)((char *)&xmmword_1B8A494B0 + 12);
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0xFuLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 51:
      *(_OWORD *)__dst = xmmword_1B8A4958C;
      *(_OWORD *)&__dst[16] = unk_1B8A4959C;
      *(_OWORD *)&__dst[32] = xmmword_1B8A495AC;
      *(_OWORD *)&__dst[48] = unk_1B8A495BC;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x10uLL);
      *(_OWORD *)&__dst[144] = unk_1B8A4955C;
      *(_OWORD *)&__dst[160] = xmmword_1B8A4956C;
      *(_OWORD *)&__dst[176] = unk_1B8A4957C;
      *(_OWORD *)&__dst[80] = unk_1B8A4951C;
      *(_OWORD *)&__dst[96] = xmmword_1B8A4952C;
      *(_OWORD *)&__dst[112] = unk_1B8A4953C;
      *(_OWORD *)&__dst[128] = xmmword_1B8A4954C;
      *(_OWORD *)__dst = xmmword_1B8A494CC;
      *(_OWORD *)&__dst[16] = unk_1B8A494DC;
      *(_OWORD *)&__dst[32] = xmmword_1B8A494EC;
      *(_OWORD *)&__dst[48] = unk_1B8A494FC;
      *(_OWORD *)&__dst[64] = xmmword_1B8A4950C;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x30uLL);
      memcpy(__dst, &unk_1B8A4968C, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xF0uLL);
      memcpy(__dst, &unk_1B8A49A4C, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xF0uLL);
      *(_OWORD *)__dst = xmmword_1B8A49E0C;
      *(_OWORD *)&__dst[16] = unk_1B8A49E1C;
      *(_OWORD *)&__dst[32] = xmmword_1B8A49E2C;
      *(_OWORD *)&__dst[48] = unk_1B8A49E3C;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x10uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 52:
      *(_OWORD *)__dst = xmmword_1B8A4958C;
      *(_OWORD *)&__dst[16] = unk_1B8A4959C;
      *(_OWORD *)&__dst[32] = xmmword_1B8A495AC;
      *(_OWORD *)&__dst[48] = unk_1B8A495BC;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x10uLL);
      *(_OWORD *)&__dst[144] = unk_1B8A4965C;
      *(_OWORD *)&__dst[160] = xmmword_1B8A4966C;
      *(_OWORD *)&__dst[176] = unk_1B8A4967C;
      *(_OWORD *)&__dst[80] = unk_1B8A4961C;
      *(_OWORD *)&__dst[96] = xmmword_1B8A4962C;
      *(_OWORD *)&__dst[112] = unk_1B8A4963C;
      *(_OWORD *)&__dst[128] = xmmword_1B8A4964C;
      *(_OWORD *)__dst = xmmword_1B8A495CC;
      *(_OWORD *)&__dst[16] = unk_1B8A495DC;
      *(_OWORD *)&__dst[32] = xmmword_1B8A495EC;
      *(_OWORD *)&__dst[48] = unk_1B8A495FC;
      *(_OWORD *)&__dst[64] = xmmword_1B8A4960C;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x30uLL);
      memcpy(__dst, &unk_1B8A4968C, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xF0uLL);
      memcpy(__dst, &unk_1B8A49A4C, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xF0uLL);
      *(_OWORD *)__dst = xmmword_1B8A49E0C;
      *(_OWORD *)&__dst[16] = unk_1B8A49E1C;
      *(_OWORD *)&__dst[32] = xmmword_1B8A49E2C;
      *(_OWORD *)&__dst[48] = unk_1B8A49E3C;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x10uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 53:
    case 62:
      __n128 v23 = operator new(0x38uLL);
      *(void *)&__dst[8] = (char *)v23 + 56;
      *(void *)&__dst[16] = (char *)v23 + 56;
      *__n128 v23 = xmmword_1B8A49E4C;
      v23[1] = unk_1B8A49E5C;
      void v23[2] = xmmword_1B8A49E6C;
      *((void *)v23 + 6) = 0x4204750141F0E75ELL;
      *(void *)__dst = v23;
      uint64_t v12 = operator new(0xA8uLL);
      uint64_t v36 = (char *)v12 + 168;
      uint8_t v12[8] = xmmword_1B8A49F04;
      v12[9] = unk_1B8A49F14;
      *((void *)v12 + 20) = 0x3C2A10E03AC7C0F4;
      v12[4] = xmmword_1B8A49EC4;
      v12[5] = unk_1B8A49ED4;
      v12[6] = xmmword_1B8A49EE4;
      v12[7] = unk_1B8A49EF4;
      *uint64_t v12 = xmmword_1B8A49E84;
      v12[1] = unk_1B8A49E94;
      void v12[2] = xmmword_1B8A49EA4;
      void v12[3] = unk_1B8A49EB4;
      int v34 = v12;
      unint64_t v35 = (char *)v12 + 168;
      int v13 = (char *)operator new(0x348uLL);
      uint64_t v31 = v13;
      float v33 = v13 + 840;
      memcpy(v13, &unk_1B8A49F2C, 0x348uLL);
      float v32 = v13 + 840;
      unint64_t v14 = (char *)operator new(0x348uLL);
      uint64_t v28 = v14;
      long long v30 = v14 + 840;
      memcpy(v14, &unk_1B8A4A274, 0x348uLL);
      uint64_t v29 = v14 + 840;
      uint64_t v15 = operator new(0x38uLL);
      _OWORD *v15 = xmmword_1B8A4A5BC;
      v15[1] = unk_1B8A4A5CC;
      v15[2] = xmmword_1B8A4A5DC;
      *((void *)v15 + 6) = 0x3E7AD7D83E6BD33DLL;
      std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)v15, (uint64_t)v15 + 56, 0xEuLL);
      arkit::unflattenParams((uint64_t)__dst, (uint64_t *)&v34, (uint64_t)&v31, (uint64_t)&v28, a2, a3, a4, a5);
      goto LABEL_11;
    case 54:
    case 63:
      __n128 v22 = operator new(0x3CuLL);
      *(void *)&__dst[8] = (char *)v22 + 60;
      *(void *)&__dst[16] = (char *)v22 + 60;
      *__n128 v22 = xmmword_1B8A4A5F4;
      v22[1] = unk_1B8A4A604;
      void v22[2] = xmmword_1B8A4A614;
      *(_OWORD *)((char *)v22 + 44) = *(long long *)((char *)&xmmword_1B8A4A614 + 12);
      *(void *)__dst = v22;
      uint64_t v12 = operator new(0xB4uLL);
      uint64_t v36 = (char *)v12 + 180;
      *((_DWORD *)v12 + 44) = 991517359;
      uint8_t v12[8] = xmmword_1B8A4A6B0;
      v12[9] = unk_1B8A4A6C0;
      v12[10] = xmmword_1B8A4A6D0;
      v12[4] = xmmword_1B8A4A670;
      v12[5] = unk_1B8A4A680;
      v12[6] = xmmword_1B8A4A690;
      v12[7] = unk_1B8A4A6A0;
      *uint64_t v12 = xmmword_1B8A4A630;
      v12[1] = unk_1B8A4A640;
      void v12[2] = xmmword_1B8A4A650;
      void v12[3] = unk_1B8A4A660;
      int v34 = v12;
      unint64_t v35 = (char *)v12 + 180;
      int v13 = (char *)operator new(0x384uLL);
      uint64_t v31 = v13;
      float v33 = v13 + 900;
      memcpy(v13, &unk_1B8A4A6E4, 0x384uLL);
      float v32 = v13 + 900;
      unint64_t v14 = (char *)operator new(0x384uLL);
      uint64_t v28 = v14;
      long long v30 = v14 + 900;
      memcpy(v14, &unk_1B8A4AA68, 0x384uLL);
      uint64_t v29 = v14 + 900;
      uint64_t v15 = operator new(0x3CuLL);
      _OWORD *v15 = xmmword_1B8A4ADEC;
      v15[1] = unk_1B8A4ADFC;
      v15[2] = xmmword_1B8A4AE0C;
      *(_OWORD *)((char *)v15 + 44) = *(long long *)((char *)&xmmword_1B8A4AE0C + 12);
      std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)v15, (uint64_t)v15 + 60, 0xFuLL);
      arkit::unflattenParams((uint64_t)__dst, (uint64_t *)&v34, (uint64_t)&v31, (uint64_t)&v28, a2, a3, a4, a5);
      goto LABEL_11;
    case 55:
    case 64:
      unint64_t v17 = operator new(0x38uLL);
      *(void *)&__dst[8] = (char *)v17 + 56;
      *(void *)&__dst[16] = (char *)v17 + 56;
      *unint64_t v17 = xmmword_1B8A4AE28;
      v17[1] = unk_1B8A4AE38;
      void v17[2] = xmmword_1B8A4AE48;
      *((void *)v17 + 6) = 0x41FF12A441E0E33ALL;
      *(void *)__dst = v17;
      uint64_t v12 = operator new(0xA8uLL);
      uint64_t v36 = (char *)v12 + 168;
      uint8_t v12[8] = xmmword_1B8A4AEE0;
      v12[9] = unk_1B8A4AEF0;
      *((void *)v12 + 20) = 0x36C9539C38C9539CLL;
      v12[4] = xmmword_1B8A4AEA0;
      v12[5] = unk_1B8A4AEB0;
      v12[6] = xmmword_1B8A4AEC0;
      v12[7] = unk_1B8A4AED0;
      *uint64_t v12 = xmmword_1B8A4AE60;
      v12[1] = unk_1B8A4AE70;
      void v12[2] = xmmword_1B8A4AE80;
      void v12[3] = unk_1B8A4AE90;
      int v34 = v12;
      unint64_t v35 = (char *)v12 + 168;
      int v13 = (char *)operator new(0x348uLL);
      uint64_t v31 = v13;
      float v33 = v13 + 840;
      memcpy(v13, &unk_1B8A4AF08, 0x348uLL);
      float v32 = v13 + 840;
      unint64_t v14 = (char *)operator new(0x348uLL);
      uint64_t v28 = v14;
      long long v30 = v14 + 840;
      memcpy(v14, &unk_1B8A4B250, 0x348uLL);
      uint64_t v29 = v14 + 840;
      uint64_t v15 = operator new(0x38uLL);
      _OWORD *v15 = xmmword_1B8A4B598;
      v15[1] = unk_1B8A4B5A8;
      v15[2] = xmmword_1B8A4B5B8;
      *((void *)v15 + 6) = 0x3E92DA983E8708ABLL;
      std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)v15, (uint64_t)v15 + 56, 0xEuLL);
      arkit::unflattenParams((uint64_t)__dst, (uint64_t *)&v34, (uint64_t)&v31, (uint64_t)&v28, a2, a3, a4, a5);
      goto LABEL_11;
    case 56:
    case 65:
      int v19 = operator new(0x44uLL);
      *(void *)&__dst[8] = v19 + 17;
      *(void *)&__dst[16] = v19 + 17;
      uint8_t v19[16] = 1107541042;
      *(_OWORD *)int v19 = xmmword_1B8A4B5D0;
      *((_OWORD *)v19 + 1) = unk_1B8A4B5E0;
      *((_OWORD *)v19 + 2) = xmmword_1B8A4B5F0;
      *((_OWORD *)v19 + 3) = unk_1B8A4B600;
      *(void *)__dst = v19;
      uint64_t v12 = operator new(0xCCuLL);
      uint64_t v36 = (char *)v12 + 204;
      v12[10] = xmmword_1B8A4B6B4;
      v12[11] = unk_1B8A4B6C4;
      *(_OWORD *)((char *)v12 + 188) = unk_1B8A4B6D0;
      v12[6] = xmmword_1B8A4B674;
      v12[7] = unk_1B8A4B684;
      uint8_t v12[8] = xmmword_1B8A4B694;
      v12[9] = unk_1B8A4B6A4;
      void v12[2] = xmmword_1B8A4B634;
      void v12[3] = unk_1B8A4B644;
      v12[4] = xmmword_1B8A4B654;
      v12[5] = unk_1B8A4B664;
      *uint64_t v12 = xmmword_1B8A4B614;
      v12[1] = unk_1B8A4B624;
      int v34 = v12;
      unint64_t v35 = (char *)v12 + 204;
      int v13 = (char *)operator new(0x3FCuLL);
      uint64_t v31 = v13;
      float v33 = v13 + 1020;
      memcpy(v13, &unk_1B8A4B6E0, 0x3FCuLL);
      float v32 = v13 + 1020;
      unint64_t v14 = (char *)operator new(0x3FCuLL);
      uint64_t v28 = v14;
      long long v30 = v14 + 1020;
      memcpy(v14, &unk_1B8A4BADC, 0x3FCuLL);
      uint64_t v29 = v14 + 1020;
      uint64_t v15 = operator new(0x44uLL);
      *((_DWORD *)v15 + 16) = 1051758571;
      _OWORD *v15 = xmmword_1B8A4BED8;
      v15[1] = unk_1B8A4BEE8;
      v15[2] = xmmword_1B8A4BEF8;
      v15[3] = unk_1B8A4BF08;
      std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)v15, (uint64_t)v15 + 68, 0x11uLL);
      arkit::unflattenParams((uint64_t)__dst, (uint64_t *)&v34, (uint64_t)&v31, (uint64_t)&v28, a2, a3, a4, a5);
      goto LABEL_11;
    case 57:
    case 66:
      unsigned int v21 = operator new(0x3CuLL);
      *(void *)&__dst[8] = (char *)v21 + 60;
      *(void *)&__dst[16] = (char *)v21 + 60;
      *unsigned int v21 = xmmword_1B8A4BF1C;
      v21[1] = unk_1B8A4BF2C;
      v21[2] = xmmword_1B8A4BF3C;
      *(_OWORD *)((char *)v21 + 44) = *(long long *)((char *)&xmmword_1B8A4BF3C + 12);
      *(void *)__dst = v21;
      uint64_t v12 = operator new(0xB4uLL);
      uint64_t v36 = (char *)v12 + 180;
      *((_DWORD *)v12 + 44) = 1008605961;
      uint8_t v12[8] = xmmword_1B8A4BFD8;
      v12[9] = unk_1B8A4BFE8;
      v12[10] = xmmword_1B8A4BFF8;
      v12[4] = xmmword_1B8A4BF98;
      v12[5] = unk_1B8A4BFA8;
      v12[6] = xmmword_1B8A4BFB8;
      v12[7] = unk_1B8A4BFC8;
      *uint64_t v12 = xmmword_1B8A4BF58;
      v12[1] = unk_1B8A4BF68;
      void v12[2] = xmmword_1B8A4BF78;
      void v12[3] = unk_1B8A4BF88;
      int v34 = v12;
      unint64_t v35 = (char *)v12 + 180;
      int v13 = (char *)operator new(0x384uLL);
      uint64_t v31 = v13;
      float v33 = v13 + 900;
      memcpy(v13, &unk_1B8A4C00C, 0x384uLL);
      float v32 = v13 + 900;
      unint64_t v14 = (char *)operator new(0x384uLL);
      uint64_t v28 = v14;
      long long v30 = v14 + 900;
      memcpy(v14, &unk_1B8A4C390, 0x384uLL);
      uint64_t v29 = v14 + 900;
      uint64_t v15 = operator new(0x3CuLL);
      _OWORD *v15 = xmmword_1B8A4C714;
      v15[1] = unk_1B8A4C724;
      v15[2] = xmmword_1B8A4C734;
      *(_OWORD *)((char *)v15 + 44) = *(long long *)((char *)&xmmword_1B8A4C734 + 12);
      std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)v15, (uint64_t)v15 + 60, 0xFuLL);
      arkit::unflattenParams((uint64_t)__dst, (uint64_t *)&v34, (uint64_t)&v31, (uint64_t)&v28, a2, a3, a4, a5);
LABEL_11:
      operator delete(v15);
      operator delete(v14);
      operator delete(v13);
      operator delete(v12);
      uint64_t v24 = *(void **)__dst;
      if (!*(void *)__dst) {
        return;
      }
      *(void *)&__dst[8] = *(void *)__dst;
      goto LABEL_199;
    case 58:
      *(_OWORD *)__dst = xmmword_1B8A44788;
      *(_OWORD *)&__dst[16] = unk_1B8A44798;
      *(_OWORD *)&__dst[32] = xmmword_1B8A447A8;
      *(_OWORD *)&__dst[44] = *(long long *)((char *)&xmmword_1B8A447A8 + 12);
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0xFuLL);
      *(_OWORD *)&__dst[112] = unk_1B8A44834;
      *(_OWORD *)&__dst[128] = xmmword_1B8A44844;
      *(_OWORD *)&__dst[144] = unk_1B8A44854;
      *(_OWORD *)&__dst[160] = xmmword_1B8A44864;
      *(_OWORD *)&__dst[48] = unk_1B8A447F4;
      *(_OWORD *)&__dst[64] = xmmword_1B8A44804;
      *(_OWORD *)&__dst[80] = unk_1B8A44814;
      *(_OWORD *)&__dst[96] = xmmword_1B8A44824;
      *(_OWORD *)__dst = xmmword_1B8A447C4;
      *(_OWORD *)&__dst[16] = unk_1B8A447D4;
      *(_OWORD *)&__dst[32] = xmmword_1B8A447E4;
      *(_DWORD *)&__dst[176] = 949557140;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x2DuLL);
      memcpy(__dst, &unk_1B8A44878, 0x384uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xE1uLL);
      memcpy(__dst, &unk_1B8A44BFC, 0x384uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xE1uLL);
      *(_OWORD *)__dst = xmmword_1B8A44F80;
      *(_OWORD *)&__dst[16] = unk_1B8A44F90;
      *(_OWORD *)&__dst[32] = xmmword_1B8A44FA0;
      *(_OWORD *)&__dst[44] = *(long long *)((char *)&xmmword_1B8A44FA0 + 12);
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0xFuLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 59:
      *(_OWORD *)__dst = xmmword_1B8A43EC8;
      *(_OWORD *)&__dst[16] = unk_1B8A43ED8;
      *(_OWORD *)&__dst[32] = xmmword_1B8A43EE8;
      *(_OWORD *)&__dst[48] = unk_1B8A43EF8;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x10uLL);
      *(_OWORD *)&__dst[144] = unk_1B8A43F98;
      *(_OWORD *)&__dst[160] = xmmword_1B8A43FA8;
      *(_OWORD *)&__dst[176] = unk_1B8A43FB8;
      *(_OWORD *)&__dst[80] = unk_1B8A43F58;
      *(_OWORD *)&__dst[96] = xmmword_1B8A43F68;
      *(_OWORD *)&__dst[112] = unk_1B8A43F78;
      *(_OWORD *)&__dst[128] = xmmword_1B8A43F88;
      *(_OWORD *)__dst = xmmword_1B8A43F08;
      *(_OWORD *)&__dst[16] = unk_1B8A43F18;
      *(_OWORD *)&__dst[32] = xmmword_1B8A43F28;
      *(_OWORD *)&__dst[48] = unk_1B8A43F38;
      *(_OWORD *)&__dst[64] = xmmword_1B8A43F48;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x30uLL);
      memcpy(__dst, &unk_1B8A43FC8, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xF0uLL);
      memcpy(__dst, &unk_1B8A44388, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xF0uLL);
      *(_OWORD *)__dst = xmmword_1B8A44748;
      *(_OWORD *)&__dst[16] = unk_1B8A44758;
      *(_OWORD *)&__dst[32] = xmmword_1B8A44768;
      *(_OWORD *)&__dst[48] = unk_1B8A44778;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x10uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 60:
      *(_OWORD *)__dst = xmmword_1B8A44FBC;
      *(_OWORD *)&__dst[16] = unk_1B8A44FCC;
      *(_OWORD *)&__dst[32] = xmmword_1B8A44FDC;
      *(_OWORD *)&__dst[48] = unk_1B8A44FEC;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x10uLL);
      *(_OWORD *)&__dst[144] = unk_1B8A4508C;
      *(_OWORD *)&__dst[160] = xmmword_1B8A4509C;
      *(_OWORD *)&__dst[176] = unk_1B8A450AC;
      *(_OWORD *)&__dst[80] = unk_1B8A4504C;
      *(_OWORD *)&__dst[96] = xmmword_1B8A4505C;
      *(_OWORD *)&__dst[112] = unk_1B8A4506C;
      *(_OWORD *)&__dst[128] = xmmword_1B8A4507C;
      *(_OWORD *)__dst = xmmword_1B8A44FFC;
      *(_OWORD *)&__dst[16] = unk_1B8A4500C;
      *(_OWORD *)&__dst[32] = xmmword_1B8A4501C;
      *(_OWORD *)&__dst[48] = unk_1B8A4502C;
      *(_OWORD *)&__dst[64] = xmmword_1B8A4503C;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x30uLL);
      memcpy(__dst, &unk_1B8A450BC, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xF0uLL);
      memcpy(__dst, &unk_1B8A4547C, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xF0uLL);
      *(_OWORD *)__dst = xmmword_1B8A4583C;
      *(_OWORD *)&__dst[16] = unk_1B8A4584C;
      *(_OWORD *)&__dst[32] = xmmword_1B8A4585C;
      *(_OWORD *)&__dst[48] = unk_1B8A4586C;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x10uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 61:
      *(_OWORD *)__dst = xmmword_1B8A4587C;
      *(_OWORD *)&__dst[16] = unk_1B8A4588C;
      *(_OWORD *)&__dst[32] = xmmword_1B8A4589C;
      *(_OWORD *)&__dst[44] = *(long long *)((char *)&xmmword_1B8A4589C + 12);
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0xFuLL);
      *(_OWORD *)&__dst[112] = unk_1B8A45928;
      *(_OWORD *)&__dst[128] = xmmword_1B8A45938;
      *(_OWORD *)&__dst[144] = unk_1B8A45948;
      *(_OWORD *)&__dst[160] = xmmword_1B8A45958;
      *(_OWORD *)&__dst[48] = unk_1B8A458E8;
      *(_OWORD *)&__dst[64] = xmmword_1B8A458F8;
      *(_OWORD *)&__dst[80] = unk_1B8A45908;
      *(_OWORD *)&__dst[96] = xmmword_1B8A45918;
      *(_OWORD *)__dst = xmmword_1B8A458B8;
      *(_OWORD *)&__dst[16] = unk_1B8A458C8;
      *(_OWORD *)&__dst[32] = xmmword_1B8A458D8;
      *(_DWORD *)&__dst[176] = 944604505;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x2DuLL);
      memcpy(__dst, &unk_1B8A4596C, 0x384uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xE1uLL);
      memcpy(__dst, &unk_1B8A45CF0, 0x384uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xE1uLL);
      *(_OWORD *)__dst = xmmword_1B8A46074;
      *(_OWORD *)&__dst[16] = unk_1B8A46084;
      *(_OWORD *)&__dst[32] = xmmword_1B8A46094;
      *(_OWORD *)&__dst[44] = *(long long *)((char *)&xmmword_1B8A46094 + 12);
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0xFuLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 67:
      *(_OWORD *)__dst = xmmword_1B8A4C750;
      *(_OWORD *)&__dst[16] = unk_1B8A4C760;
      *(_OWORD *)&__dst[32] = xmmword_1B8A4C770;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0xCuLL);
      *(_OWORD *)&__dst[80] = unk_1B8A4C7D0;
      *(_OWORD *)&__dst[96] = xmmword_1B8A4C7E0;
      *(_OWORD *)&__dst[112] = unk_1B8A4C7F0;
      *(_OWORD *)&__dst[128] = xmmword_1B8A4C800;
      *(_OWORD *)&__dst[16] = unk_1B8A4C790;
      *(_OWORD *)&__dst[32] = xmmword_1B8A4C7A0;
      *(_OWORD *)&__dst[48] = unk_1B8A4C7B0;
      *(_OWORD *)&__dst[64] = xmmword_1B8A4C7C0;
      *(_OWORD *)__dst = xmmword_1B8A4C780;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x24uLL);
      memcpy(__dst, &unk_1B8A4C810, 0x2D0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xB4uLL);
      memcpy(__dst, &unk_1B8A4CAE0, 0x2D0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xB4uLL);
      *(_OWORD *)__dst = xmmword_1B8A4CDB0;
      *(_OWORD *)&__dst[16] = unk_1B8A4CDC0;
      *(_OWORD *)&__dst[32] = xmmword_1B8A4CDD0;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0xCuLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 68:
      *(_OWORD *)__dst = xmmword_1B8A4CDE0;
      *(_OWORD *)&__dst[16] = unk_1B8A4CDF0;
      *(_OWORD *)&__dst[32] = xmmword_1B8A4CE00;
      *(_DWORD *)&__dst[48] = 1106905750;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0xDuLL);
      *(_OWORD *)&__dst[112] = unk_1B8A4CE84;
      *(_OWORD *)&__dst[128] = xmmword_1B8A4CE94;
      *(_OWORD *)&__dst[140] = *(long long *)((char *)&xmmword_1B8A4CE94 + 12);
      *(_OWORD *)&__dst[48] = unk_1B8A4CE44;
      *(_OWORD *)&__dst[64] = xmmword_1B8A4CE54;
      *(_OWORD *)&__dst[80] = unk_1B8A4CE64;
      *(_OWORD *)&__dst[96] = xmmword_1B8A4CE74;
      *(_OWORD *)__dst = xmmword_1B8A4CE14;
      *(_OWORD *)&__dst[16] = unk_1B8A4CE24;
      *(_OWORD *)&__dst[32] = xmmword_1B8A4CE34;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x27uLL);
      memcpy(__dst, &unk_1B8A4CEB0, 0x30CuLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xC3uLL);
      memcpy(__dst, &unk_1B8A4D1BC, 0x30CuLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xC3uLL);
      *(_OWORD *)__dst = xmmword_1B8A4D4C8;
      *(_OWORD *)&__dst[16] = unk_1B8A4D4D8;
      *(_OWORD *)&__dst[32] = xmmword_1B8A4D4E8;
      *(_DWORD *)&__dst[48] = 1049737453;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0xDuLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 69:
      *(_OWORD *)__dst = xmmword_1B8A4D4FC;
      *(_OWORD *)&__dst[16] = unk_1B8A4D50C;
      *(_OWORD *)&__dst[32] = xmmword_1B8A4D51C;
      *(_OWORD *)&__dst[44] = *(long long *)((char *)&xmmword_1B8A4D51C + 12);
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0xFuLL);
      *(_OWORD *)&__dst[112] = unk_1B8A4D5A8;
      *(_OWORD *)&__dst[128] = xmmword_1B8A4D5B8;
      *(_OWORD *)&__dst[144] = unk_1B8A4D5C8;
      *(_OWORD *)&__dst[160] = xmmword_1B8A4D5D8;
      *(_OWORD *)&__dst[48] = unk_1B8A4D568;
      *(_OWORD *)&__dst[64] = xmmword_1B8A4D578;
      *(_OWORD *)&__dst[80] = unk_1B8A4D588;
      *(_OWORD *)&__dst[96] = xmmword_1B8A4D598;
      *(_OWORD *)__dst = xmmword_1B8A4D538;
      *(_OWORD *)&__dst[16] = unk_1B8A4D548;
      *(_OWORD *)&__dst[32] = xmmword_1B8A4D558;
      *(_DWORD *)&__dst[176] = 936490775;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x2DuLL);
      memcpy(__dst, &unk_1B8A4D5EC, 0x384uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xE1uLL);
      memcpy(__dst, &unk_1B8A4D970, 0x384uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xE1uLL);
      *(_OWORD *)__dst = xmmword_1B8A4DCF4;
      *(_OWORD *)&__dst[16] = unk_1B8A4DD04;
      *(_OWORD *)&__dst[32] = xmmword_1B8A4DD14;
      *(_OWORD *)&__dst[44] = *(long long *)((char *)&xmmword_1B8A4DD14 + 12);
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0xFuLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 70:
      *(_OWORD *)__dst = xmmword_1B8A4DD30;
      *(_OWORD *)&__dst[16] = unk_1B8A4DD40;
      *(_OWORD *)&__dst[32] = xmmword_1B8A4DD50;
      *(_DWORD *)&__dst[48] = 1103650039;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0xDuLL);
      *(_OWORD *)&__dst[112] = unk_1B8A4DDD4;
      *(_OWORD *)&__dst[128] = xmmword_1B8A4DDE4;
      *(_OWORD *)&__dst[140] = *(long long *)((char *)&xmmword_1B8A4DDE4 + 12);
      *(_OWORD *)&__dst[48] = unk_1B8A4DD94;
      *(_OWORD *)&__dst[64] = xmmword_1B8A4DDA4;
      *(_OWORD *)&__dst[80] = unk_1B8A4DDB4;
      *(_OWORD *)&__dst[96] = xmmword_1B8A4DDC4;
      *(_OWORD *)__dst = xmmword_1B8A4DD64;
      *(_OWORD *)&__dst[16] = unk_1B8A4DD74;
      *(_OWORD *)&__dst[32] = xmmword_1B8A4DD84;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x27uLL);
      memcpy(__dst, &unk_1B8A4DE00, 0x30CuLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xC3uLL);
      memcpy(__dst, &unk_1B8A4E10C, 0x30CuLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xC3uLL);
      *(_OWORD *)__dst = xmmword_1B8A4E418;
      *(_OWORD *)&__dst[16] = unk_1B8A4E428;
      *(_OWORD *)&__dst[32] = xmmword_1B8A4E438;
      *(_DWORD *)&__dst[48] = 1051218311;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0xDuLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 71:
      *(_OWORD *)__dst = xmmword_1B8A4E44C;
      *(_OWORD *)&__dst[16] = unk_1B8A4E45C;
      *(_OWORD *)&__dst[32] = xmmword_1B8A4E46C;
      *(void *)&__dst[48] = 0x41C16A6841B9EA9BLL;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0xEuLL);
      *(_OWORD *)&__dst[112] = unk_1B8A4E4F4;
      *(_OWORD *)&__dst[128] = xmmword_1B8A4E504;
      *(_OWORD *)&__dst[144] = unk_1B8A4E514;
      *(_OWORD *)&__dst[48] = unk_1B8A4E4B4;
      *(_OWORD *)&__dst[64] = xmmword_1B8A4E4C4;
      *(_OWORD *)&__dst[80] = unk_1B8A4E4D4;
      *(_OWORD *)&__dst[96] = xmmword_1B8A4E4E4;
      *(_OWORD *)__dst = xmmword_1B8A4E484;
      *(_OWORD *)&__dst[16] = unk_1B8A4E494;
      *(_OWORD *)&__dst[32] = xmmword_1B8A4E4A4;
      *(void *)&__dst[160] = 0;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x2AuLL);
      memcpy(__dst, &unk_1B8A4E52C, 0x348uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xD2uLL);
      memcpy(__dst, &unk_1B8A4E874, 0x348uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xD2uLL);
      *(_OWORD *)__dst = xmmword_1B8A4EBBC;
      *(_OWORD *)&__dst[16] = unk_1B8A4EBCC;
      *(_OWORD *)&__dst[32] = xmmword_1B8A4EBDC;
      *(void *)&__dst[48] = 0x3EADDA8C3EA2B9D4;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0xEuLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 72:
      *(_OWORD *)__dst = xmmword_1B8A50490;
      *(_OWORD *)&__dst[16] = unk_1B8A504A0;
      *(_OWORD *)&__dst[32] = xmmword_1B8A504B0;
      *(_DWORD *)&__dst[48] = 1108299798;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0xDuLL);
      *(_OWORD *)&__dst[112] = unk_1B8A50534;
      *(_OWORD *)&__dst[128] = xmmword_1B8A50544;
      *(_OWORD *)&__dst[140] = *(long long *)((char *)&xmmword_1B8A50544 + 12);
      *(_OWORD *)&__dst[48] = unk_1B8A504F4;
      *(_OWORD *)&__dst[64] = xmmword_1B8A50504;
      *(_OWORD *)&__dst[80] = unk_1B8A50514;
      *(_OWORD *)&__dst[96] = xmmword_1B8A50524;
      *(_OWORD *)__dst = xmmword_1B8A504C4;
      *(_OWORD *)&__dst[16] = unk_1B8A504D4;
      *(_OWORD *)&__dst[32] = xmmword_1B8A504E4;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x27uLL);
      memcpy(__dst, &unk_1B8A50560, 0x30CuLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xC3uLL);
      memcpy(__dst, &unk_1B8A5086C, 0x30CuLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xC3uLL);
      *(_OWORD *)__dst = xmmword_1B8A50B78;
      *(_OWORD *)&__dst[16] = unk_1B8A50B88;
      *(_OWORD *)&__dst[32] = xmmword_1B8A50B98;
      *(_DWORD *)&__dst[48] = 1050384047;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0xDuLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 73:
      *(_OWORD *)__dst = xmmword_1B8A50BAC;
      *(_OWORD *)&__dst[16] = unk_1B8A50BBC;
      *(_OWORD *)&__dst[32] = xmmword_1B8A50BCC;
      *(void *)&__dst[48] = 0x4204202B41F0C020;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0xEuLL);
      *(_OWORD *)&__dst[112] = unk_1B8A50C54;
      *(_OWORD *)&__dst[128] = xmmword_1B8A50C64;
      *(_OWORD *)&__dst[144] = unk_1B8A50C74;
      *(_OWORD *)&__dst[48] = unk_1B8A50C14;
      *(_OWORD *)&__dst[64] = xmmword_1B8A50C24;
      *(_OWORD *)&__dst[80] = unk_1B8A50C34;
      *(_OWORD *)&__dst[96] = xmmword_1B8A50C44;
      *(_OWORD *)__dst = xmmword_1B8A50BE4;
      *(void *)&__dst[160] = 0x3716FEB5360637BDLL;
      *(_OWORD *)&__dst[16] = unk_1B8A50BF4;
      *(_OWORD *)&__dst[32] = xmmword_1B8A50C04;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x2AuLL);
      memcpy(__dst, &unk_1B8A50C8C, 0x348uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xD2uLL);
      memcpy(__dst, &unk_1B8A50FD4, 0x348uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xD2uLL);
      *(_OWORD *)__dst = xmmword_1B8A5131C;
      *(_OWORD *)&__dst[16] = unk_1B8A5132C;
      *(_OWORD *)&__dst[32] = xmmword_1B8A5133C;
      *(void *)&__dst[48] = 0x3E87D71B3E77E308;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0xEuLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 74:
      *(_OWORD *)__dst = xmmword_1B8A51354;
      *(_OWORD *)&__dst[16] = unk_1B8A51364;
      *(_OWORD *)&__dst[32] = xmmword_1B8A51374;
      *(_OWORD *)&__dst[44] = *(long long *)((char *)&xmmword_1B8A51374 + 12);
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0xFuLL);
      *(_OWORD *)&__dst[112] = unk_1B8A51400;
      *(_OWORD *)&__dst[128] = xmmword_1B8A51410;
      *(_OWORD *)&__dst[144] = unk_1B8A51420;
      *(_OWORD *)&__dst[160] = xmmword_1B8A51430;
      *(_OWORD *)&__dst[48] = unk_1B8A513C0;
      *(_OWORD *)&__dst[64] = xmmword_1B8A513D0;
      *(_OWORD *)&__dst[80] = unk_1B8A513E0;
      *(_OWORD *)&__dst[96] = xmmword_1B8A513F0;
      *(_OWORD *)__dst = xmmword_1B8A51390;
      *(_OWORD *)&__dst[16] = unk_1B8A513A0;
      *(_OWORD *)&__dst[32] = xmmword_1B8A513B0;
      *(_DWORD *)&__dst[176] = 964994326;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x2DuLL);
      memcpy(__dst, &unk_1B8A51444, 0x384uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xE1uLL);
      memcpy(__dst, &unk_1B8A517C8, 0x384uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xE1uLL);
      *(_OWORD *)__dst = xmmword_1B8A51B4C;
      *(_OWORD *)&__dst[16] = unk_1B8A51B5C;
      *(_OWORD *)&__dst[32] = xmmword_1B8A51B6C;
      *(_OWORD *)&__dst[44] = *(long long *)((char *)&xmmword_1B8A51B6C + 12);
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0xFuLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 75:
      *(_OWORD *)__dst = xmmword_1B8A51B88;
      *(_OWORD *)&__dst[16] = unk_1B8A51B98;
      *(_OWORD *)&__dst[32] = xmmword_1B8A51BA8;
      *(_OWORD *)&__dst[48] = unk_1B8A51BB8;
      *(_DWORD *)&__dst[64] = 1107585920;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x11uLL);
      *(_OWORD *)&__dst[144] = unk_1B8A51C5C;
      *(_OWORD *)&__dst[160] = xmmword_1B8A51C6C;
      *(_OWORD *)&__dst[176] = unk_1B8A51C7C;
      *(_OWORD *)&__dst[188] = unk_1B8A51C88;
      *(_OWORD *)&__dst[80] = unk_1B8A51C1C;
      *(_OWORD *)&__dst[96] = xmmword_1B8A51C2C;
      *(_OWORD *)&__dst[112] = unk_1B8A51C3C;
      *(_OWORD *)&__dst[128] = xmmword_1B8A51C4C;
      *(_OWORD *)&__dst[16] = unk_1B8A51BDC;
      *(_OWORD *)&__dst[32] = xmmword_1B8A51BEC;
      *(_OWORD *)&__dst[48] = unk_1B8A51BFC;
      *(_OWORD *)&__dst[64] = xmmword_1B8A51C0C;
      *(_OWORD *)__dst = xmmword_1B8A51BCC;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x33uLL);
      memcpy(__dst, &unk_1B8A51C98, 0x3FCuLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xFFuLL);
      memcpy(__dst, &unk_1B8A52094, 0x3FCuLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xFFuLL);
      *(_OWORD *)__dst = xmmword_1B8A52490;
      *(_OWORD *)&__dst[16] = unk_1B8A524A0;
      *(_OWORD *)&__dst[32] = xmmword_1B8A524B0;
      *(_OWORD *)&__dst[48] = unk_1B8A524C0;
      *(_DWORD *)&__dst[64] = 1052594043;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x11uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
      goto LABEL_189;
    case 76:
      *(_OWORD *)__dst = xmmword_1B8A524D4;
      *(_OWORD *)&__dst[16] = unk_1B8A524E4;
      *(_OWORD *)&__dst[32] = xmmword_1B8A524F4;
      *(_OWORD *)&__dst[48] = unk_1B8A52504;
      *(_DWORD *)&__dst[64] = 1107151090;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x11uLL);
      *(_OWORD *)&__dst[144] = unk_1B8A525A8;
      *(_OWORD *)&__dst[160] = xmmword_1B8A525B8;
      *(_OWORD *)&__dst[176] = unk_1B8A525C8;
      *(_OWORD *)&__dst[188] = unk_1B8A525D4;
      *(_OWORD *)&__dst[80] = unk_1B8A52568;
      *(_OWORD *)&__dst[96] = xmmword_1B8A52578;
      *(_OWORD *)&__dst[112] = unk_1B8A52588;
      *(_OWORD *)&__dst[128] = xmmword_1B8A52598;
      *(_OWORD *)&__dst[16] = unk_1B8A52528;
      *(_OWORD *)&__dst[32] = xmmword_1B8A52538;
      *(_OWORD *)&__dst[48] = unk_1B8A52548;
      *(_OWORD *)&__dst[64] = xmmword_1B8A52558;
      *(_OWORD *)__dst = xmmword_1B8A52518;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x33uLL);
      memcpy(__dst, &unk_1B8A525E4, 0x3FCuLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xFFuLL);
      memcpy(__dst, &unk_1B8A529E0, 0x3FCuLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xFFuLL);
      *(_OWORD *)__dst = xmmword_1B8A52DDC;
      *(_OWORD *)&__dst[16] = unk_1B8A52DEC;
      *(_OWORD *)&__dst[32] = xmmword_1B8A52DFC;
      *(_OWORD *)&__dst[48] = unk_1B8A52E0C;
      *(_DWORD *)&__dst[64] = 1052644911;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x11uLL);
      if (&__p != (void **)a6) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
      }
LABEL_189:
      arkit::unflattenParams((uint64_t)&v34, (uint64_t *)&v31, (uint64_t)&v28, (uint64_t)v27, a2, a3, a4, a5);
      if (__p)
      {
        uint64_t v26 = __p;
        operator delete(__p);
      }
      if (v27[0])
      {
        v27[1] = v27[0];
        operator delete(v27[0]);
      }
      if (v28)
      {
        uint64_t v29 = v28;
        operator delete(v28);
      }
      if (v31)
      {
        float v32 = v31;
        operator delete(v31);
      }
      uint64_t v24 = v34;
      if (!v34) {
        return;
      }
      unint64_t v35 = v34;
LABEL_199:
      operator delete(v24);
      return;
    default:
      arkit::loadParams();
  }
}

void sub_1B893CB2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26)
{
  if (__p) {
    operator delete(__p);
  }
  if (a16) {
    operator delete(a16);
  }
  if (a19) {
    operator delete(a19);
  }
  if (a22) {
    operator delete(a22);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<float>::vector[abi:ne180100](void *a1, const void *a2, unint64_t a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a3)
  {
    std::vector<float>::__vallocate[abi:ne180100](a1, a3);
    unint64_t v6 = (char *)a1[1];
    memmove(v6, a2, 4 * a3);
    a1[1] = &v6[4 * a3];
  }
  return a1;
}

void sub_1B893DCF8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

float **arkit::sampleSignalToNoise(float **result, _DWORD *a2, _DWORD *a3, float *a4, float *a5, float a6)
{
  unint64_t v6 = *result;
  uint64_t v7 = result[1];
  if (*result == v7)
  {
    int v10 = 0;
    int v8 = 0;
    float v12 = INFINITY;
    float v11 = -INFINITY;
  }
  else
  {
    int v8 = 0;
    int v9 = 0;
    int v10 = 0;
    float v11 = -INFINITY;
    float v12 = INFINITY;
    do
    {
      float v13 = *v6++;
      float v14 = v13 - a6;
      BOOL v15 = (float)(v13 - a6) <= 0.0;
      if ((float)(v13 - a6) >= 0.0 && (float)(v13 - a6) < v12)
      {
        float v12 = v14;
        int v8 = v9;
      }
      if (v15 && v14 > v11)
      {
        int v10 = v9;
        float v11 = v14;
      }
      ++v9;
    }
    while (v6 != v7);
  }
  if (v11 == -INFINITY) {
    int v10 = v8;
  }
  BOOL v16 = v12 == INFINITY;
  if (v12 == INFINITY) {
    int v8 = v10;
  }
  BOOL v17 = v11 == -INFINITY;
  float v18 = -v11;
  float v19 = v12 - v11;
  float v20 = v18 / v19;
  float v21 = v12 / v19;
  if (v17) {
    BOOL v16 = 1;
  }
  if (v16) {
    float v20 = 0.5;
  }
  *a4 = v20;
  if (v16) {
    float v22 = 0.5;
  }
  else {
    float v22 = v21;
  }
  *a5 = v22;
  *a3 = v10;
  *a2 = v8;
  return result;
}

void arkit::gaussianMixtureKernels(int a1@<W0>, arkit *a2@<X1>, uint64_t a3@<X8>, float a4@<S0>)
{
  int8x16_t v68 = 0;
  int8x16_t v69 = 0;
  uint64_t v70 = 0;
  memset(v67, 0, sizeof(v67));
  memset(v66, 0, sizeof(v66));
  memset(v65, 0, sizeof(v65));
  uint64_t v62 = 0;
  int64x2_t v63 = 0;
  uint64_t v64 = 0;
  arkit::loadParams(a1, (char *)&v68, v67, (uint64_t)v66, (uint64_t)v65, (char *)&v62);
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  arkit::sampleSignalToNoise(&v68, (_DWORD *)&v61 + 1, &v61, (float *)&v60 + 1, (float *)&v60, a4);
  uint64_t v7 = SHIDWORD(v61);
  arkit::mixtureKernels((uint64_t *)&v66[0][3 * SHIDWORD(v61)], &v65[0][3 * SHIDWORD(v61)], a2, v59);
  uint64_t v8 = (int)v61;
  arkit::mixtureKernels((uint64_t *)&v66[0][3 * (int)v61], &v65[0][3 * (int)v61], a2, (uint64_t *)v58);
  long long v56 = 0;
  uint64_t v57 = 0;
  int64x2_t v55 = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v55, *(const void **)(v67[0] + 24 * (int)v7), *(void *)(v67[0] + 24 * (int)v7 + 8), (uint64_t)(*(void *)(v67[0] + 24 * (int)v7 + 8) - *(void *)(v67[0] + 24 * (int)v7)) >> 2);
  uint64_t v41 = v7;
  uint64_t v42 = a3;
  uint64_t v40 = v8;
  __int16 v53 = 0;
  uint64_t v54 = 0;
  uint64x2_t v52 = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v52, *(const void **)(v67[0] + 24 * (int)v8), *(void *)(v67[0] + 24 * (int)v8 + 8), (uint64_t)(*(void *)(v67[0] + 24 * (int)v8 + 8) - *(void *)(v67[0] + 24 * (int)v8)) >> 2);
  uint64_t v9 = 0;
  uint64_t v49 = 0;
  uint64_t v50 = 0;
  uint64_t v51 = 0;
  double v46 = 0;
  double v47 = 0;
  int64x2_t v48 = 0;
  do
  {
    __p = 0;
    simd_float4x4 v44 = 0;
    uint64_t v45 = 0;
    std::vector<std::vector<float>>::push_back[abi:ne180100](&v49, (uint64_t)&__p);
    if (__p)
    {
      simd_float4x4 v44 = __p;
      operator delete(__p);
    }
    if (a2)
    {
      uint64_t v10 = 0;
      do
      {
        uint64_t v11 = v49 + 24 * v9;
        float v12 = (float)(*(float *)&v60 * *((float *)v58[0][3 * v9] + v10))
            + (float)(*((float *)&v60 + 1) * *(float *)(*(void *)(v59[0] + 24 * v9) + 4 * v10));
        float v14 = (float **)(v11 + 8);
        float v13 = *(float **)(v11 + 8);
        BOOL v16 = (void *)(v11 + 16);
        unint64_t v15 = *(void *)(v11 + 16);
        if ((unint64_t)v13 >= v15)
        {
          float v18 = *(float **)v11;
          uint64_t v19 = ((uint64_t)v13 - *(void *)v11) >> 2;
          unint64_t v20 = v19 + 1;
          if ((unint64_t)(v19 + 1) >> 62) {
            std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v21 = v15 - (void)v18;
          if (v21 >> 1 > v20) {
            unint64_t v20 = v21 >> 1;
          }
          if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v22 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v22 = v20;
          }
          if (v22)
          {
            __n128 v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)v16, v22);
            float v13 = *v14;
            float v18 = *(float **)v11;
          }
          else
          {
            __n128 v23 = 0;
          }
          uint64_t v24 = (float *)&v23[4 * v19];
          *uint64_t v24 = v12;
          BOOL v17 = v24 + 1;
          while (v13 != v18)
          {
            int v25 = *((_DWORD *)v13-- - 1);
            *((_DWORD *)v24-- - 1) = v25;
          }
          *(void *)uint64_t v11 = v24;
          char *v14 = v17;
          void *v16 = &v23[4 * v22];
          if (v18) {
            operator delete(v18);
          }
        }
        else
        {
          float *v13 = v12;
          BOOL v17 = v13 + 1;
        }
        char *v14 = v17;
        ++v10;
      }
      while (v10 != a2);
    }
    float v26 = (float)(*(float *)&v60 * *((float *)v52 + v9)) + (float)(*((float *)&v60 + 1) * *((float *)v55 + v9));
    unint64_t v27 = v47;
    if (v47 >= v48)
    {
      uint64_t v29 = (float *)v46;
      uint64_t v30 = ((char *)v47 - (unsigned char *)v46) >> 2;
      unint64_t v31 = v30 + 1;
      if ((unint64_t)(v30 + 1) >> 62) {
        std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v32 = (char *)v48 - (unsigned char *)v46;
      if (((char *)v48 - (unsigned char *)v46) >> 1 > v31) {
        unint64_t v31 = v32 >> 1;
      }
      if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v33 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v33 = v31;
      }
      if (v33)
      {
        int v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v48, v33);
        uint64_t v29 = (float *)v46;
        unint64_t v27 = v47;
      }
      else
      {
        int v34 = 0;
      }
      unint64_t v35 = (float *)&v34[4 * v30];
      *unint64_t v35 = v26;
      uint64_t v28 = (uint64_t)(v35 + 1);
      while (v27 != v29)
      {
        int v36 = *((_DWORD *)v27-- - 1);
        *((_DWORD *)v35-- - 1) = v36;
      }
      double v46 = v35;
      double v47 = (float *)v28;
      int64x2_t v48 = (float *)&v34[4 * v33];
      if (v29) {
        operator delete(v29);
      }
    }
    else
    {
      *double v47 = v26;
      uint64_t v28 = (uint64_t)(v27 + 1);
    }
    double v47 = (float *)v28;
    ++v9;
  }
  while (v9 != 3);
  uint64_t v37 = v60;
  float v38 = *((float *)v62 + v41);
  float v39 = *((float *)v62 + v40);
  *(void *)(v42 + 8) = 0;
  *(void *)(v42 + 16) = 0;
  *(void *)uint64_t v42 = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((void *)v42, v46, v28, (v28 - (uint64_t)v46) >> 2);
  *(void *)(v42 + 24) = 0;
  *(void *)(v42 + 32) = 0;
  *(void *)(v42 + 40) = 0;
  std::vector<std::vector<float>>::__init_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>((void *)(v42 + 24), v49, v50, 0xAAAAAAAAAAAAAAABLL * ((v50 - v49) >> 3));
  *(float *)(v42 + 48) = (float)(*(float *)&v37 * v39) + (float)(*((float *)&v37 + 1) * v38);
  if (v46)
  {
    double v47 = (float *)v46;
    operator delete(v46);
  }
  double v46 = &v49;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v46);
  if (v52)
  {
    __int16 v53 = v52;
    operator delete(v52);
  }
  if (v55)
  {
    long long v56 = v55;
    operator delete(v55);
  }
  int64x2_t v55 = v58;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v55);
  v58[0] = (void **)v59;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](v58);
  if (v62)
  {
    int64x2_t v63 = v62;
    operator delete(v62);
  }
  uint64_t v62 = v65;
  std::vector<std::vector<std::vector<float>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v62);
  v65[0] = (void **)v66;
  std::vector<std::vector<std::vector<float>>>::__destroy_vector::operator()[abi:ne180100](v65);
  v66[0] = (void **)v67;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](v66);
  if (v68)
  {
    int8x16_t v69 = v68;
    operator delete(v68);
  }
}

void sub_1B893E29C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char *__p, char *a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,char **a26,char **a27,uint64_t a28,char *a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38)
{
  uint64_t v41 = *v38;
  if (*v38)
  {
    *(void *)(a12 + 8) = v41;
    operator delete(v41);
  }
  if (__p)
  {
    a18 = __p;
    operator delete(__p);
  }
  __p = &a20;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  if (a23)
  {
    a24 = (uint64_t)a23;
    operator delete(a23);
  }
  if (a26)
  {
    a27 = a26;
    operator delete(a26);
  }
  a26 = &a29;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a26);
  a29 = &a32;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a29);
  if (a37)
  {
    a38 = (uint64_t)a37;
    operator delete(a37);
  }
  a37 = (void *)(v39 - 216);
  std::vector<std::vector<std::vector<float>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a37);
  *(void *)(v39 - 216) = v39 - 192;
  std::vector<std::vector<std::vector<float>>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v39 - 216));
  *(void *)(v39 - 192) = v39 - 168;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v39 - 192));
  uint64_t v42 = *(void **)(v39 - 144);
  if (v42)
  {
    *(void *)(v39 - 136) = v42;
    operator delete(v42);
  }
  _Unwind_Resume(a1);
}

void std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<std::vector<float>>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  if (v2 != *a1)
  {
    uint64_t v4 = a1[1];
    do
    {
      unint64_t v6 = *(void **)(v4 - 24);
      v4 -= 24;
      uint64_t v5 = v6;
      if (v6)
      {
        *(void *)(v2 - 16) = v5;
        operator delete(v5);
      }
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  a1[1] = v3;
}

uint64_t std::vector<std::vector<float>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<float>>,std::reverse_iterator<std::vector<float>*>,std::reverse_iterator<std::vector<float>*>,std::reverse_iterator<std::vector<float>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<float>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(24 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<float>>,std::reverse_iterator<std::vector<float>*>,std::reverse_iterator<std::vector<float>*>,std::reverse_iterator<std::vector<float>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v14 = a6;
  *((void *)&v14 + 1) = a7;
  long long v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    uint64_t v9 = a6;
  }
  else
  {
    do
    {
      *(void *)(v7 - 24) = 0;
      *(void *)(v7 - 16) = 0;
      *(void *)(v7 - 8) = 0;
      long long v8 = *(_OWORD *)(a3 - 3);
      a3 -= 3;
      *(_OWORD *)(v7 - 24) = v8;
      *(void *)(v7 - 8) = a3[2];
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      uint64_t v7 = *((void *)&v14 + 1) - 24;
      *((void *)&v14 + 1) -= 24;
    }
    while (a3 != a5);
    uint64_t v9 = v14;
  }
  char v12 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::reverse_iterator<std::vector<float>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::reverse_iterator<std::vector<float>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::reverse_iterator<std::vector<float>*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::reverse_iterator<std::vector<float>*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    uint64_t v3 = *(void **)v1;
    if (*(void *)v1)
    {
      *(void *)(v1 + 8) = v3;
      operator delete(v3);
    }
    v1 += 24;
  }
}

uint64_t std::__split_buffer<std::vector<float>>::~__split_buffer(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__split_buffer<std::vector<float>>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != a2)
  {
    uint64_t v5 = *(void **)(v2 - 24);
    *(void *)(a1 + 16) = v2 - 24;
    if (v5)
    {
      *(void *)(v2 - 16) = v5;
      operator delete(v5);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 24;
    }
  }
}

void std::vector<std::vector<std::vector<float>>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    uint64_t v4 = (void **)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        uint64_t v6 = v4;
        std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v6);
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::vector<std::vector<std::vector<float>>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<std::vector<float>>>,std::reverse_iterator<std::vector<std::vector<float>>*>,std::reverse_iterator<std::vector<std::vector<float>>*>,std::reverse_iterator<std::vector<std::vector<float>>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<std::vector<float>>>,std::reverse_iterator<std::vector<std::vector<float>>*>,std::reverse_iterator<std::vector<std::vector<float>>*>,std::reverse_iterator<std::vector<std::vector<float>>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v14 = a6;
  *((void *)&v14 + 1) = a7;
  long long v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    uint64_t v9 = a6;
  }
  else
  {
    do
    {
      *(void *)(v7 - 24) = 0;
      *(void *)(v7 - 16) = 0;
      *(void *)(v7 - 8) = 0;
      long long v8 = *(_OWORD *)(a3 - 3);
      a3 -= 3;
      *(_OWORD *)(v7 - 24) = v8;
      *(void *)(v7 - 8) = a3[2];
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      uint64_t v7 = *((void *)&v14 + 1) - 24;
      *((void *)&v14 + 1) -= 24;
    }
    while (a3 != a5);
    uint64_t v9 = v14;
  }
  char v12 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::vector<float>>>,std::reverse_iterator<std::vector<std::vector<float>>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::vector<float>>>,std::reverse_iterator<std::vector<std::vector<float>>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::vector<float>>>,std::reverse_iterator<std::vector<std::vector<float>>*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::vector<float>>>,std::reverse_iterator<std::vector<std::vector<float>>*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void ***)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void ***)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    uint64_t v3 = v1;
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v3);
    v1 += 3;
  }
}

void **std::__split_buffer<std::vector<std::vector<float>>>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void std::__split_buffer<std::vector<std::vector<float>>>::clear[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = (void **)(i - 24);
    *(void *)(a1 + 16) = v4;
    uint64_t v5 = v4;
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v5);
  }
}

void *std::vector<float>::vector(void *a1, unint64_t a2, _DWORD *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<float>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v6 = (_DWORD *)a1[1];
    uint64_t v7 = &v6[a2];
    uint64_t v8 = 4 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 4;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_1B893E9E4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<std::vector<float>>::__push_back_slow_path<std::vector<float> const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL) {
    std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x555555555555555) {
    unint64_t v9 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v9 = v5;
  }
  BOOL v17 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<float>>>(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = &v10[24 * v4];
  v14[0] = v10;
  v14[1] = v11;
  unint64_t v15 = v11;
  BOOL v16 = &v10[24 * v9];
  *(void *)uint64_t v11 = 0;
  *((void *)v11 + 1) = 0;
  *((void *)v11 + 2) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v11, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
  v15 += 24;
  std::vector<std::vector<float>>::__swap_out_circular_buffer(a1, v14);
  uint64_t v12 = a1[1];
  std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)v14);
  return v12;
}

void sub_1B893EB04(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

float std::__split_buffer<float>::push_back(void *a1, float *a2)
{
  unint64_t v4 = (char *)a1[2];
  if (v4 == (char *)a1[3])
  {
    unint64_t v5 = (char *)a1[1];
    uint64_t v6 = (uint64_t)&v5[-*a1];
    if ((unint64_t)v5 <= *a1)
    {
      if (v4 == (char *)*a1) {
        unint64_t v16 = 1;
      }
      else {
        unint64_t v16 = (uint64_t)&v4[-*a1] >> 1;
      }
      BOOL v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(a1[4], v16);
      uint64_t v19 = &v17[v16 & 0xFFFFFFFFFFFFFFFCLL];
      unint64_t v20 = (int *)a1[1];
      unint64_t v4 = v19;
      uint64_t v21 = a1[2] - (void)v20;
      if (v21)
      {
        unint64_t v4 = &v19[v21 & 0xFFFFFFFFFFFFFFFCLL];
        uint64_t v22 = 4 * (v21 >> 2);
        __n128 v23 = &v17[v16 & 0xFFFFFFFFFFFFFFFCLL];
        do
        {
          int v24 = *v20++;
          *(_DWORD *)__n128 v23 = v24;
          v23 += 4;
          v22 -= 4;
        }
        while (v22);
      }
      int v25 = (char *)*a1;
      *a1 = v17;
      a1[1] = v19;
      a1[2] = v4;
      a1[3] = &v17[4 * v18];
      if (v25)
      {
        operator delete(v25);
        unint64_t v4 = (char *)a1[2];
      }
    }
    else
    {
      uint64_t v7 = v6 >> 2;
      BOOL v8 = v6 >> 2 < -1;
      uint64_t v9 = (v6 >> 2) + 2;
      if (v8) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = v7 + 1;
      }
      uint64_t v11 = -(v10 >> 1);
      uint64_t v12 = v10 >> 1;
      long long v13 = &v5[-4 * v12];
      int64_t v14 = v4 - v5;
      if (v4 != v5)
      {
        memmove(&v5[-4 * v12], v5, v4 - v5);
        unint64_t v4 = (char *)a1[1];
      }
      unint64_t v15 = &v4[4 * v11];
      unint64_t v4 = &v13[v14];
      a1[1] = v15;
    }
  }
  float result = *a2;
  *(float *)unint64_t v4 = *a2;
  a1[2] = v4 + 4;
  return result;
}

char *std::vector<float>::__swap_out_circular_buffer(void **a1, uint64_t a2, char *__src)
{
  unint64_t v5 = *(char **)(a2 + 8);
  uint64_t v6 = (char *)*a1;
  uint64_t v7 = v5;
  if (*a1 != __src)
  {
    BOOL v8 = __src;
    uint64_t v7 = *(char **)(a2 + 8);
    do
    {
      int v9 = *((_DWORD *)v8 - 1);
      v8 -= 4;
      *((_DWORD *)v7 - 1) = v9;
      v7 -= 4;
    }
    while (v8 != v6);
  }
  *(void *)(a2 + 8) = v7;
  uint64_t v10 = a1[1];
  uint64_t v11 = *(void *)(a2 + 16);
  int64_t v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    uint64_t v7 = *(char **)(a2 + 8);
  }
  *(void *)(a2 + 16) = v11 + v12;
  long long v13 = (char *)*a1;
  *a1 = v7;
  *(void *)(a2 + 8) = v13;
  int64_t v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(void *)(a2 + 16) = v14;
  unint64_t v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(void *)(a2 + 24) = v15;
  *(void *)a2 = *(void *)(a2 + 8);
  return v5;
}

void std::vector<std::vector<std::vector<float>>>::__vdeallocate(void ***a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = a1[1];
    unint64_t v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        v3 -= 3;
        unint64_t v5 = v3;
        std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v5);
      }
      while (v3 != v1);
      unint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void std::vector<std::vector<float>>::__vdeallocate(uint64_t *a1)
{
  if (*a1)
  {
    std::vector<std::vector<float>>::__clear[abi:ne180100](a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void *std::vector<std::vector<float>>::__init_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    std::vector<std::vector<float>>::__vallocate[abi:ne180100](result, a4);
    float result = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<float>>,std::vector<float>*,std::vector<float>*,std::vector<float>*>((uint64_t)(v6 + 2), a2, a3, (void *)v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_1B893EE08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

char *std::vector<std::vector<float>>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
  }
  float result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<float>>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

void *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<float>>,std::vector<float>*,std::vector<float>*,std::vector<float>*>(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v4 = a4;
  uint64_t v10 = a4;
  uint64_t v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  char v9 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      *uint64_t v4 = 0;
      v4[1] = 0;
      _DWORD v4[2] = 0;
      std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v4, *(const void **)v6, *(void *)(v6 + 8), (uint64_t)(*(void *)(v6 + 8) - *(void *)v6) >> 2);
      uint64_t v4 = v11 + 3;
      v11 += 3;
      v6 += 24;
    }
    while (v6 != a3);
  }
  char v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::vector<float>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v8);
  return v4;
}

void sub_1B893EF1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::vector<float>*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::vector<float>*>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::vector<float>*>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 16);
  uint64_t v2 = **(void **)(a1 + 8);
  if (v1 != v2)
  {
    uint64_t v3 = **(void **)(a1 + 16);
    do
    {
      unint64_t v5 = *(void **)(v3 - 24);
      v3 -= 24;
      uint64_t v4 = v5;
      if (v5)
      {
        *(void *)(v1 - 16) = v4;
        operator delete(v4);
      }
      uint64_t v1 = v3;
    }
    while (v3 != v2);
  }
}

BOOL operator==(float32x2_t *a1, float32x2_t *a2)
{
  float32x2_t v2 = vsub_f32(*a1, *a2);
  if (fabsf(sqrtf(vaddv_f32(vmul_f32(v2, v2)))) >= 0.00000011921) {
    return 0;
  }
  float32x2_t v3 = vsub_f32(a1[1], a2[1]);
  return fabsf(sqrtf(vaddv_f32(vmul_f32(v3, v3)))) < 0.00000011921;
}

void sub_1B893F61C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B893F6B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B893F748(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B893F84C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  if (__p) {
    operator delete(__p);
  }
  if (a13) {
    operator delete(a13);
  }

  _Unwind_Resume(a1);
}

void *std::vector<ARPatch>::__init_with_size[abi:ne180100]<ARPatch*,ARPatch*>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    float result = _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE11__vallocateB8ne180100Em(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      float result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1B893F918(_Unwind_Exception *exception_object)
{
  float32x2_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

float arkit::btr::EstimateScaleReprojectionLinear(uint64_t a1)
{
  uint64_t v1 = *(const RegistrationData **)a1;
  unint64_t v2 = 0xEFBEFBEFBEFBEFBFLL * ((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3);
  float result = -1.0;
  if (v2 >= 2)
  {
    v16[0] = 10;
    v16[1] = 0x3CA3D70A3A83126FLL;
    _OWORD v16[2] = 5;
    uint64_t v18 = 0x3FF9999A3D4CCCCDLL;
    char v19 = 1;
    long long v17 = xmmword_1B8A52E30;
    uint64_t v7 = 0;
    long long v8 = xmmword_1B8A52E44;
    long long v9 = *(_OWORD *)algn_1B8A52E54;
    long long v10 = xmmword_1B8A52E64;
    long long v11 = unk_1B8A52E74;
    long long v12 = xmmword_1B8A52E44;
    long long v13 = *(_OWORD *)algn_1B8A52E54;
    long long v14 = xmmword_1B8A52E64;
    long long v15 = unk_1B8A52E74;
    unint64_t v5 = v2 - 1;
    uint64_t v6 = 504;
    do
    {
      v6 += 504;
      --v5;
    }
    while (v5);
    return *(float *)&v7 / *((float *)&v7 + 1);
  }
  return result;
}

__n128 arkit::btr::anonymous namespace'::LinearScaleEstimatorOnline::Reset(arkit::btr::_anonymous_namespace_::LinearScaleEstimatorOnline *this, const RegistrationData *a2)
{
  *(void *)this = 0;
  p_cam_from_vio = &a2->cam_from_vio;
  long long v24 = xmmword_1B8A52E44;
  long long v25 = *(_OWORD *)algn_1B8A52E54;
  long long v26 = xmmword_1B8A52E64;
  long long v27 = unk_1B8A52E74;
  *(void *)&v33[0] = &a2->cam_from_vio;
  *((void *)&v33[0] + 1) = 4;
  v30[0] = (uint64_t *)v33;
  unint64_t v31 = &v24;
  uint64_t v32 = 4;
  cva::MatrixRef<float,3u,3u,false>::operator=<cva::MatrixTransposeExpr<cva::MatrixRef<float const,3u,3u,false>>>((uint64_t)&v31, v30);
  v29[0] = &v24;
  v29[1] = 4;
  v30[0] = v29;
  v28[0] = &p_cam_from_vio->m_data[12];
  v28[1] = 0xC00000004;
  unint64_t v31 = (long long *)v30;
  uint64_t v32 = (uint64_t)v28;
  if (p_cam_from_vio == (SE3GroupStorage<float, cva::Matrix<float, 4, 4>> *)&v24)
  {
    DWORD2(v33[0]) = 0;
    *(void *)&v33[0] = 0;
    cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::MatrixUnaryExpr<cva::MatrixRef<float,3u,3u,false>,cva::detail::NegOp>,cva::MatrixRef<float const,3u,1u,false>>((uint64_t)v33, (uint64_t)&v31);
    *(void *)&long long v27 = *(void *)&v33[0];
    DWORD2(v27) = DWORD2(v33[0]);
  }
  else
  {
    uint64_t v6 = 0;
    int v34 = 0;
    memset(v33, 0, sizeof(v33));
    uint64_t v7 = (float *)&v24;
    unint64_t v8 = 0x100000000;
    do
    {
      *(float *)((char *)v33 + v6) = -*v7;
      unint64_t v9 = HIDWORD(v8);
      BOOL v10 = (int)v8 < 2;
      if ((int)v8 < 2) {
        unint64_t v9 = 0;
      }
      long long v11 = &v7[v9];
      uint64_t v12 = (v8 + 1);
      unint64_t v13 = v8 & 0xFFFFFFFF00000000;
      uint64_t v7 = v11 + 1;
      if (!v10) {
        uint64_t v12 = 0;
      }
      unint64_t v8 = v12 | v13;
      v6 += 4;
    }
    while (v6 != 36);
    uint64_t v14 = 0;
    long long v15 = v33;
    do
    {
      uint64_t v16 = 0;
      float v17 = 0.0;
      uint64_t v18 = &p_cam_from_vio->m_data[12];
      do
      {
        float v19 = *v18++;
        float v17 = v17 + (float)(*(float *)((char *)v15 + v16) * v19);
        v16 += 12;
      }
      while (v16 != 36);
      *((float *)&v28[-2] + v14++) = v17;
      long long v15 = (_OWORD *)((char *)v15 + 4);
    }
    while (v14 != 3);
  }
  long long v20 = v25;
  *(_OWORD *)((char *)this + 8) = v24;
  *(_OWORD *)((char *)this + 24) = v20;
  result.n128_u64[0] = v26;
  long long v21 = v27;
  *(_OWORD *)((char *)this + 40) = v26;
  *(_OWORD *)((char *)this + 56) = v21;
  if ((SE3GroupStorage<float, cva::Matrix<float, 4, 4>> *)((char *)this + 72) != &a2->cam_from_obj)
  {
    __n128 result = *(__n128 *)a2->cam_from_obj.m_data;
    long long v22 = *(_OWORD *)&a2->cam_from_obj.m_data[4];
    long long v23 = *(_OWORD *)&a2->cam_from_obj.m_data[12];
    *(_OWORD *)((char *)this + 104) = *(_OWORD *)&a2->cam_from_obj.m_data[8];
    *(_OWORD *)((char *)this + 120) = v23;
    *(__n128 *)((char *)this + 72) = result;
    *(_OWORD *)((char *)this + 88) = v22;
  }
  return result;
}

unint64_t arkit::btr::anonymous namespace'::LinearScaleEstimatorOnline::Add(float *a1, uint64_t a2, uint64_t a3, float a4)
{
  uint64_t v6 = 0;
  uint64_t v7 = a2 + 356;
  uint64_t v8 = a2 + 128;
  uint64_t v9 = a2 + 404;
  memset(&v77, 0, 128);
  do
  {
    uint64_t v10 = a2 + 12 * v6;
    uint64_t v11 = v6 + 1;
    *(void *)&v71[0] = *(void *)(v10 + 128);
    DWORD2(v71[0]) = *(_DWORD *)(v10 + 136);
    v74[0].i64[0] = v7;
    v74[0].i64[1] = 4;
    *(void *)&v73[0] = v74;
    *((void *)&v73[0] + 1) = v71;
    *(void *)((char *)v76 + 4) = 0;
    HIDWORD(v76[0]) = 0;
    cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::MatrixRef<float const,3u,3u,false>,cva::Matrix<float,3u,1u,false>>((uint64_t)v76 + 4, (float **)v73);
    uint64_t v12 = 0;
    DWORD2(v72[0]) = 0;
    *(void *)&v72[0] = 0;
    do
    {
      *(float *)((char *)v72 + v12) = *(float *)((char *)v76 + v12 + 4) + *(float *)(v9 + v12);
      v12 += 4;
    }
    while (v12 != 12);
    unint64_t v13 = (const float *)v72 + 2;
    float32x2_t v14 = vld1_dup_f32(v13);
    *(&v77 + v6++) = vdiv_f32(*(float32x2_t *)&v72[0], v14);
  }
  while (v11 != 16);
  uint64_t v15 = 0;
  memset(v76, 0, sizeof(v76));
  do
  {
    uint64_t v16 = v8 + 12 * v15;
    *(void *)&v70[0] = *(void *)v16;
    DWORD2(v70[0]) = *(_DWORD *)(v16 + 8);
    *(void *)&v72[0] = a1 + 18;
    *((void *)&v72[0] + 1) = 4;
    float v17 = (char *)v76 + 12 * v15++;
    v74[0].i64[0] = (uint64_t)v72;
    v74[0].i64[1] = (uint64_t)v70;
    *(void *)((char *)v73 + 4) = 0;
    HIDWORD(v73[0]) = 0;
    cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::MatrixRef<float const,3u,3u,false>,cva::Matrix<float,3u,1u,false>>((uint64_t)v73 + 4, (float **)v74);
    uint64_t v18 = 0;
    DWORD2(v71[0]) = 0;
    *(void *)&v71[0] = 0;
    do
    {
      *(float *)((char *)v71 + v18 * 4) = *(float *)((char *)v73 + v18 * 4 + 4) + a1[v18 + 30];
      ++v18;
    }
    while (v18 != 3);
    *(void *)float v17 = *(void *)&v71[0];
    *((_DWORD *)v17 + 2) = DWORD2(v71[0]);
  }
  while (v15 != 16);
  *(void *)&v73[0] = a2 + 420;
  *((void *)&v73[0] + 1) = a1 + 2;
  memset(v74, 0, sizeof(v74));
  long long v75 = 0u;
  cva::assign<false,false,cva::Matrix<float,4u,4u,false>,cva::Matrix<float,4u,4u,false>,cva::Matrix<float,4u,4u,false>>(v74, (float32x4_t **)v73);
  *(void *)&v71[0] = v74;
  *((void *)&v71[0] + 1) = 4;
  *(void *)&v72[0] = v71;
  *((void *)&v72[0] + 1) = v76;
  memset(v73, 0, sizeof(v73));
  float v19 = v73;
  cva::assign<false,false,cva::Matrix<float,3u,16u,false>,cva::MatrixRef<float,3u,3u,false>,cva::Matrix<float,3u,16u,false>>((uint64_t *)v73, (uint64_t **)v72);
  uint64_t v20 = 0;
  *(void *)&v71[0] = v75;
  DWORD2(v71[0]) = DWORD2(v75);
  float v21 = 0.0;
  do
  {
    uint64_t v22 = 0;
    DWORD2(v72[0]) = 0;
    *(void *)&v72[0] = 0;
    do
    {
      *(float *)((char *)v72 + v22) = (float)(*(float *)((char *)v19 + v22) * a4) + *(float *)((char *)v71 + v22);
      v22 += 4;
    }
    while (v22 != 12);
    long long v23 = (const float *)v72 + 2;
    float32x2_t v24 = vld1_dup_f32(v23);
    float32x2_t v25 = vsub_f32(vdiv_f32(*(float32x2_t *)&v72[0], v24), *(&v77 + v20));
    float v21 = v21 + sqrtf(vaddv_f32(vmul_f32(v25, v25)));
    float v19 = (_OWORD *)((char *)v19 + 12);
    ++v20;
  }
  while (v20 != 16);
  float v26 = v21 * 0.0625;
  if ((float)(v21 * 0.0625) >= *(float *)(a3 + 36))
  {
    uint64_t v28 = 0;
    uint64_t v29 = (float *)v73 + 2;
    memset(v72, 0, sizeof(v72));
    uint64_t v30 = (float *)&v77;
    unint64_t v31 = (float *)v73 + 2;
    do
    {
      float v32 = *v30;
      v30 += 2;
      *(float *)((char *)v72 + v28) = (float)(*v31 * v32) - *(v31 - 2);
      v31 += 3;
      v28 += 4;
    }
    while (v28 != 64);
    uint64_t v33 = 0;
    int v34 = (float *)&v77 + 1;
    memset(v71, 0, sizeof(v71));
    unint64_t v35 = (float *)&v77 + 1;
    do
    {
      float v36 = *v35;
      v35 += 2;
      *(float *)((char *)v71 + v33) = (float)(*v29 * v36) - *(v29 - 1);
      v29 += 3;
      v33 += 4;
    }
    while (v33 != 64);
    uint64_t v37 = 0;
    float v38 = *((float *)&v75 + 2);
    float v39 = *(float *)&v75;
    memset(v70, 0, sizeof(v70));
    uint64_t v40 = (float *)&v77;
    do
    {
      float v41 = *v40;
      v40 += 2;
      *(float *)((char *)v70 + v37) = v39 - (float)(v41 * v38);
      v37 += 4;
    }
    while (v37 != 64);
    uint64_t v42 = 0;
    float v43 = *((float *)&v75 + 1);
    memset(v69, 0, sizeof(v69));
    do
    {
      float v44 = *v34;
      v34 += 2;
      *(float *)((char *)v69 + v42) = v43 - (float)(v44 * v38);
      v42 += 4;
    }
    while (v42 != 64);
    uint64_t v64 = v70;
    int8x16_t v65 = v72;
    unsigned int v66 = &v64;
    uint64_t v61 = v69;
    uint64_t v62 = v71;
    int64x2_t v63 = &v61;
    v67.i32[1] = 0;
    cva::assign<false,false,cva::Matrix<float,1u,1u,false>,cva::Matrix<float,1u,16u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,1u,16u,false>>>((float *)&v67 + 1, (uint64_t)&v65);
    float v68 = 0.0;
    cva::assign<false,false,cva::Matrix<float,1u,1u,false>,cva::Matrix<float,1u,16u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,1u,16u,false>>>(&v68, (uint64_t)&v62);
    float v45 = v67.f32[1];
    float v46 = v68;
    uint64_t v64 = v72;
    int8x16_t v65 = v72;
    unsigned int v66 = &v64;
    uint64_t v61 = v71;
    uint64_t v62 = v71;
    int64x2_t v63 = &v61;
    v67.i32[1] = 0;
    cva::assign<false,false,cva::Matrix<float,1u,1u,false>,cva::Matrix<float,1u,16u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,1u,16u,false>>>((float *)&v67 + 1, (uint64_t)&v65);
    float v68 = 0.0;
    cva::assign<false,false,cva::Matrix<float,1u,1u,false>,cva::Matrix<float,1u,16u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,1u,16u,false>>>(&v68, (uint64_t)&v62);
    uint64_t v47 = 0;
    int8x16_t v65 = (_OWORD *)v75;
    LODWORD(v66) = DWORD2(v75);
    float v48 = v67.f32[1] + v68;
    float v49 = (float)(v45 + v46) / (float)(v67.f32[1] + v68);
    float v50 = 0.0;
    uint64_t v51 = v73;
    do
    {
      uint64_t v52 = 0;
      float v68 = 0.0;
      float32x2_t v67 = 0;
      do
      {
        v67.f32[v52] = (float)(v49 * *(float *)((char *)v51 + v52 * 4)) + *(float *)((char *)&v65 + v52 * 4);
        ++v52;
      }
      while (v52 != 3);
      __int16 v53 = &v68;
      float32x2_t v54 = vld1_dup_f32(v53);
      float32x2_t v55 = vsub_f32(vdiv_f32(v67, v54), *(&v77 + v47));
      float v50 = v50 + sqrtf(vaddv_f32(vmul_f32(v55, v55)));
      uint64_t v51 = (_OWORD *)((char *)v51 + 12);
      ++v47;
    }
    while (v47 != 16);
    float v56 = v50 * 0.0625;
    if (v56 <= (float)(v26 * 1.001))
    {
      float v57 = v48 + a1[1];
      *a1 = (float)(v45 + v46) + *a1;
      a1[1] = v57;
      uint64_t v27 = 13;
      float v56 = v49;
    }
    else
    {
      uint64_t v27 = 8;
    }
    float v26 = v56;
  }
  else
  {
    uint64_t v27 = 12;
  }
  return v27 | ((unint64_t)LODWORD(v26) << 32);
}

void arkit::btr::ComputeReprojectionErrorS(uint64_t **a1, float a2)
{
  if (a2 >= 0.0 && (unint64_t)((char *)a1[1] - (char *)*a1) >= 0x10)
  {
    float32x2_t v3 = a1;
    uint64_t v5 = **a1;
    long long v6 = *(_OWORD *)(v5 + 372);
    v65[0] = *(_OWORD *)(v5 + 356);
    v65[1] = v6;
    long long v7 = *(_OWORD *)(v5 + 404);
    v65[2] = *(_OWORD *)(v5 + 388);
    v65[3] = v7;
    for (uint64_t i = 48; i != 60; i += 4)
      *(float *)((char *)v65 + i) = *(float *)((char *)v65 + i) * a2;
    uint64_t v9 = (float32x4_t *)(v5 + 420);
    long long v57 = xmmword_1B8A52E44;
    long long v58 = *(_OWORD *)algn_1B8A52E54;
    long long v59 = xmmword_1B8A52E64;
    long long v60 = unk_1B8A52E74;
    v61.i64[0] = v5 + 420;
    v61.i64[1] = 4;
    uint64_t v70 = (long long **)&v61;
    *(void *)&v72[0] = &v57;
    *((void *)&v72[0] + 1) = 4;
    cva::MatrixRef<float,3u,3u,false>::operator=<cva::MatrixTransposeExpr<cva::MatrixRef<float const,3u,3u,false>>>((uint64_t)v72, (uint64_t **)&v70);
    float v68 = &v57;
    uint64_t v69 = 4;
    uint64_t v70 = &v68;
    unsigned int v66 = v9 + 3;
    uint64_t v67 = 0xC00000004;
    *(void *)&v72[0] = &v70;
    *((void *)&v72[0] + 1) = &v66;
    if (v9 == (float32x4_t *)&v57)
    {
      v61.i32[2] = 0;
      v61.i64[0] = 0;
      cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::MatrixUnaryExpr<cva::MatrixRef<float,3u,3u,false>,cva::detail::NegOp>,cva::MatrixRef<float const,3u,1u,false>>((uint64_t)&v61, (uint64_t)v72);
      *(void *)&long long v60 = v61.i64[0];
      DWORD2(v60) = v61.i32[2];
    }
    else
    {
      uint64_t v10 = 0;
      LODWORD(v63) = 0;
      float32x4_t v61 = 0u;
      long long v62 = 0u;
      uint64_t v11 = (float *)&v57;
      unint64_t v12 = 0x100000000;
      do
      {
        v61.f32[v10] = -*v11;
        unint64_t v13 = HIDWORD(v12);
        BOOL v14 = (int)v12 < 2;
        if ((int)v12 < 2) {
          unint64_t v13 = 0;
        }
        uint64_t v15 = &v11[v13];
        uint64_t v16 = (v12 + 1);
        unint64_t v17 = v12 & 0xFFFFFFFF00000000;
        uint64_t v11 = v15 + 1;
        if (!v14) {
          uint64_t v16 = 0;
        }
        unint64_t v12 = v16 | v17;
        ++v10;
      }
      while (v10 != 9);
      uint64_t v18 = 0;
      float v19 = &v61;
      do
      {
        uint64_t v20 = 0;
        float v21 = 0.0;
        f32 = v9[3].f32;
        do
        {
          float v23 = *f32++;
          float v21 = v21 + (float)(v19->f32[v20] * v23);
          v20 += 3;
        }
        while (v20 != 9);
        *((float *)&v60 + v18++) = v21;
        float v19 = (float32x4_t *)((char *)v19 + 4);
      }
      while (v18 != 3);
    }
    *(void *)&v72[0] = &v57;
    *((void *)&v72[0] + 1) = v65;
    float32x4_t v61 = 0u;
    long long v62 = 0u;
    long long v63 = 0u;
    long long v64 = 0u;
    cva::assign<false,false,cva::Matrix<float,4u,4u,false>,cva::Matrix<float,4u,4u,false>,cva::Matrix<float,4u,4u,false>>(&v61, (float32x4_t **)v72);
    uint64_t v24 = (char *)v3[1] - (char *)*v3;
    if ((unint64_t)v24 >= 9)
    {
      unint64_t v25 = v24 >> 3;
      if (v25 <= 2) {
        unint64_t v25 = 2;
      }
      unint64_t v49 = v25;
      float v26 = 0.0;
      uint64_t v52 = 1;
      float v50 = v3;
      do
      {
        uint64_t v27 = 0;
        uint64_t v28 = 128;
        do
        {
          uint64_t v29 = (*v3)[v52];
          uint64_t v30 = 3 * v27;
          LODWORD(v69) = 0;
          float v68 = 0;
          if ((long long **)(v29 + 128) == &v68)
          {
            uint64_t v32 = v29 + 128 + 12 * v27;
            uint64_t v33 = *(long long **)v32;
            LODWORD(v69) = *(_DWORD *)(v32 + 8);
            float v68 = v33;
          }
          else
          {
            for (uint64_t j = 0; j != 12; j += 4)
              *(_DWORD *)((char *)&v68 + j) = *(_DWORD *)(v29 + v28 + j);
          }
          uint64_t v51 = v27 + 1;
          uint64_t v70 = (long long **)(v29 + 356);
          uint64_t v71 = 4;
          *(void *)&v72[0] = &v70;
          *((void *)&v72[0] + 1) = &v68;
          uint64_t v34 = v29 + 404;
          *(void *)((char *)&v57 + 4) = 0;
          HIDWORD(v57) = 0;
          cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::MatrixRef<float const,3u,3u,false>,cva::Matrix<float,3u,1u,false>>((uint64_t)&v57 + 4, (float **)v72);
          uint64_t v35 = 0;
          LODWORD(v67) = 0;
          unsigned int v66 = 0;
          do
          {
            *(float *)((char *)&v66 + v35) = *(float *)((char *)&v57 + v35 + 4) + *(float *)(v34 + v35);
            v35 += 4;
          }
          while (v35 != 12);
          float v36 = (const float *)&v67;
          float32x2_t v37 = vld1_dup_f32(v36);
          float32x2_t v38 = (float32x2_t)v66;
          *(void *)&v72[0] = (*v50)[v52] + 420;
          *((void *)&v72[0] + 1) = &v61;
          long long v57 = 0u;
          long long v58 = 0u;
          long long v59 = 0u;
          long long v60 = 0u;
          cva::assign<false,false,cva::Matrix<float,4u,4u,false>,cva::Matrix<float,4u,4u,false>,cva::Matrix<float,4u,4u,false>>((float32x4_t *)&v57, (float32x4_t **)v72);
          uint64_t v39 = (*v50)[v52];
          uint64_t v53 = 0;
          int v54 = 0;
          if ((uint64_t *)(v39 + 4 * v30 - 4 * v30 + 128) == &v53)
          {
            uint64_t v42 = 0;
            DWORD2(v72[0]) = 0;
            *(void *)&v72[0] = 0;
            uint64_t v43 = v39 + v28;
            do
            {
              *(float *)((char *)v72 + v42) = *(float *)(v43 + v42) * a2;
              v42 += 4;
            }
            while (v42 != 12);
            uint64_t v53 = *(void *)&v72[0];
            int v54 = DWORD2(v72[0]);
            float32x2_t v3 = v50;
          }
          else
          {
            uint64_t v40 = 0;
            uint64_t v41 = v39 + v28;
            float32x2_t v3 = v50;
            do
            {
              *(float *)((char *)&v53 + v40) = *(float *)(v41 + v40) * a2;
              v40 += 4;
            }
            while (v40 != 12);
          }
          float32x2_t v44 = vdiv_f32(v38, v37);
          float v68 = &v57;
          uint64_t v69 = 4;
          uint64_t v70 = &v68;
          uint64_t v71 = (uint64_t)&v53;
          *(void *)((char *)v72 + 4) = 0;
          HIDWORD(v72[0]) = 0;
          cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::MatrixRef<float const,3u,3u,false>,cva::Matrix<float,3u,1u,false>>((uint64_t)v72 + 4, (float **)&v70);
          uint64_t v45 = 0;
          int v56 = 0;
          float32x2_t v55 = 0;
          do
          {
            v55.f32[v45] = *(float *)((char *)v72 + v45 * 4 + 4) + *(float *)((char *)&v60 + v45 * 4);
            ++v45;
          }
          while (v45 != 3);
          float v46 = (const float *)&v56;
          float32x2_t v47 = vld1_dup_f32(v46);
          float32x2_t v48 = vsub_f32(vdiv_f32(v55, v47), v44);
          float v26 = v26 + sqrtf(vaddv_f32(vmul_f32(v48, v48)));
          v28 += 12;
          uint64_t v27 = v51;
        }
        while (v51 != 16);
        ++v52;
      }
      while (v52 != v49);
    }
  }
}

uint64_t arkit::btr::ScaleCorrection::ScaleCorrection(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  long long v4 = a2[1];
  long long v5 = a2[2];
  *(void *)(a1 + 48) = *((void *)a2 + 6);
  *(_OWORD *)(a1 + 16) = v4;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)a1 = v3;
  _ZNSt3__115allocate_sharedB8ne180100IN5arkit3btr15ScaleCorrection4ImplENS_9allocatorIS4_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_((void *)(a1 + 56));
  return a1;
}

{
  long long v3;
  long long v4;
  long long v5;

  long long v3 = *a2;
  long long v4 = a2[1];
  long long v5 = a2[2];
  *(void *)(a1 + 48) = *((void *)a2 + 6);
  *(_OWORD *)(a1 + 16) = v4;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)a1 = v3;
  _ZNSt3__115allocate_sharedB8ne180100IN5arkit3btr15ScaleCorrection4ImplENS_9allocatorIS4_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_((void *)(a1 + 56));
  return a1;
}

float arkit::btr::ScaleCorrection::EstimateScale(uint64_t a1, uint64_t a2, float *a3)
{
  long long v3 = a3;
  uint64_t v6 = *(void *)(a1 + 56);
  if (!*(unsigned char *)(a1 + 48) || !*(unsigned char *)(v6 + 5))
  {
    long long v7 = (long long *)(a2 + 420);
    if (*(unsigned char *)(v6 + 8))
    {
      *(unsigned char *)(v6 + 8) = 0;
      long long v98 = xmmword_1B8A52E44;
      long long v99 = *(_OWORD *)algn_1B8A52E54;
      long long v100 = xmmword_1B8A52E64;
      v101[0] = unk_1B8A52E74;
      *(void *)&long long v92 = a2 + 420;
      *((void *)&v92 + 1) = 4;
      v108 = &v92;
      v102.i64[0] = (uint64_t)&v98;
      v102.i64[1] = 4;
      cva::MatrixRef<float,3u,3u,false>::operator=<cva::MatrixTransposeExpr<cva::MatrixRef<float const,3u,3u,false>>>((uint64_t)&v102, (uint64_t **)&v108);
      v107[0] = (uint64_t *)&v98;
      v107[1] = (uint64_t *)4;
      v108 = (long long *)v107;
      float32x4_t v105 = (long long *)(a2 + 468);
      uint64_t v106 = 0xC00000004;
      v102.i64[0] = (uint64_t)&v108;
      v102.i64[1] = (uint64_t)&v105;
      if (v7 == &v98)
      {
        DWORD2(v92) = 0;
        *(void *)&long long v92 = 0;
        cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::MatrixUnaryExpr<cva::MatrixRef<float,3u,3u,false>,cva::detail::NegOp>,cva::MatrixRef<float const,3u,1u,false>>((uint64_t)&v92, (uint64_t)&v102);
        *(void *)&v101[0] = v92;
        DWORD2(v101[0]) = DWORD2(v92);
      }
      else
      {
        uint64_t v8 = 0;
        LODWORD(v94) = 0;
        long long v92 = 0u;
        long long v93 = 0u;
        uint64_t v9 = (float *)&v98;
        unint64_t v10 = 0x100000000;
        do
        {
          *(float *)((char *)&v92 + v8) = -*v9;
          unint64_t v11 = HIDWORD(v10);
          BOOL v12 = (int)v10 < 2;
          if ((int)v10 < 2) {
            unint64_t v11 = 0;
          }
          unint64_t v13 = &v9[v11];
          uint64_t v14 = (v10 + 1);
          unint64_t v15 = v10 & 0xFFFFFFFF00000000;
          uint64_t v9 = v13 + 1;
          if (!v12) {
            uint64_t v14 = 0;
          }
          unint64_t v10 = v14 | v15;
          v8 += 4;
        }
        while (v8 != 36);
        uint64_t v16 = 0;
        unint64_t v17 = &v92;
        do
        {
          uint64_t v18 = 0;
          float v19 = 0.0;
          uint64_t v20 = (float *)(a2 + 468);
          do
          {
            float v21 = *v20++;
            float v19 = v19 + (float)(*(float *)((char *)v17 + v18) * v21);
            v18 += 12;
          }
          while (v18 != 36);
          *((float *)v101 + v16++) = v19;
          unint64_t v17 = (long long *)((char *)v17 + 4);
        }
        while (v16 != 3);
      }
      long long v36 = v99;
      *(_OWORD *)(v6 + 408) = v98;
      *(_OWORD *)(v6 + 424) = v36;
      long long v37 = v101[0];
      *(_OWORD *)(v6 + 440) = v100;
      *(_OWORD *)(v6 + 456) = v37;
      unint64_t v38 = 1;
      goto LABEL_34;
    }
    *(void *)&long long v98 = a2 + 420;
    *((void *)&v98 + 1) = v6 + 408;
    memset(&v102, 0, 48);
    long long v103 = 0u;
    cva::assign<false,false,cva::Matrix<float,4u,4u,false>,cva::Matrix<float,4u,4u,false>,cva::Matrix<float,4u,4u,false>>(&v102, (float32x4_t **)&v98);
    long long v98 = xmmword_1B8A52E44;
    long long v99 = *(_OWORD *)algn_1B8A52E54;
    long long v100 = xmmword_1B8A52E64;
    v101[0] = unk_1B8A52E74;
    *(void *)&long long v92 = a2 + 420;
    *((void *)&v92 + 1) = 4;
    v107[0] = (uint64_t *)&v92;
    v108 = &v98;
    uint64_t v109 = 4;
    cva::MatrixRef<float,3u,3u,false>::operator=<cva::MatrixTransposeExpr<cva::MatrixRef<float const,3u,3u,false>>>((uint64_t)&v108, v107);
    float32x4_t v105 = &v98;
    uint64_t v106 = 4;
    v107[0] = (uint64_t *)&v105;
    v104[0] = a2 + 468;
    v104[1] = 0xC00000004;
    v108 = (long long *)v107;
    uint64_t v109 = (uint64_t)v104;
    if (v7 == &v98)
    {
      DWORD2(v92) = 0;
      *(void *)&long long v92 = 0;
      cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::MatrixUnaryExpr<cva::MatrixRef<float,3u,3u,false>,cva::detail::NegOp>,cva::MatrixRef<float const,3u,1u,false>>((uint64_t)&v92, (uint64_t)&v108);
      long long v3 = a3;
      *(void *)&v101[0] = v92;
      DWORD2(v101[0]) = DWORD2(v92);
    }
    else
    {
      uint64_t v22 = 0;
      LODWORD(v94) = 0;
      float v23 = (float *)&v98;
      unint64_t v24 = 0x100000000;
      long long v92 = 0u;
      long long v93 = 0u;
      do
      {
        *(float *)((char *)&v92 + v22) = -*v23;
        unint64_t v25 = HIDWORD(v24);
        BOOL v26 = (int)v24 < 2;
        if ((int)v24 < 2) {
          unint64_t v25 = 0;
        }
        uint64_t v27 = &v23[v25];
        uint64_t v28 = (v24 + 1);
        unint64_t v29 = v24 & 0xFFFFFFFF00000000;
        float v23 = v27 + 1;
        if (!v26) {
          uint64_t v28 = 0;
        }
        unint64_t v24 = v28 | v29;
        v22 += 4;
      }
      while (v22 != 36);
      uint64_t v30 = 0;
      unint64_t v31 = &v92;
      long long v3 = a3;
      do
      {
        uint64_t v32 = 0;
        float v33 = 0.0;
        uint64_t v34 = (float *)(a2 + 468);
        do
        {
          float v35 = *v34++;
          float v33 = v33 + (float)(*(float *)((char *)v31 + v32) * v35);
          v32 += 12;
        }
        while (v32 != 36);
        *((float *)v101 + v30++) = v33;
        unint64_t v31 = (long long *)((char *)v31 + 4);
      }
      while (v30 != 3);
    }
    long long v39 = v99;
    *(_OWORD *)(v6 + 408) = v98;
    *(_OWORD *)(v6 + 424) = v39;
    long long v40 = v101[0];
    *(_OWORD *)(v6 + 440) = v100;
    *(_OWORD *)(v6 + 456) = v40;
    float v41 = sqrtf((float)((float)(*(float *)&v103 * *(float *)&v103) + (float)(*((float *)&v103 + 1) * *((float *)&v103 + 1)))+ (float)(*((float *)&v103 + 2) * *((float *)&v103 + 2)));
    if (v41 < *(float *)(a1 + 8))
    {
      unint64_t v38 = ((unint64_t)LODWORD(v41) << 32) | 1;
      goto LABEL_34;
    }
    if (v41 <= *(float *)(a1 + 12))
    {
      uint64_t v43 = 0;
      long long v44 = *(_OWORD *)(a2 + 272);
      v101[5] = *(_OWORD *)(a2 + 256);
      v101[6] = v44;
      long long v45 = *(_OWORD *)(a2 + 304);
      v101[7] = *(_OWORD *)(a2 + 288);
      v101[8] = v45;
      long long v46 = *(_OWORD *)(a2 + 208);
      v101[1] = *(_OWORD *)(a2 + 192);
      v101[2] = v46;
      long long v47 = *(_OWORD *)(a2 + 240);
      v101[3] = *(_OWORD *)(a2 + 224);
      v101[4] = v47;
      long long v48 = *(_OWORD *)(a2 + 144);
      long long v98 = *(_OWORD *)(a2 + 128);
      long long v99 = v48;
      long long v49 = *(_OWORD *)(a2 + 176);
      long long v100 = *(_OWORD *)(a2 + 160);
      v51.i32[1] = DWORD1(v100);
      v101[0] = v49;
      uint64_t v50 = *(void *)(v6 + 16) + 1;
      *(void *)(v6 + 16) = v50;
      *(float *)v51.i32 = (float)(unint64_t)v50;
      float32x4_t v52 = (float32x4_t)vdupq_lane_s32(v51, 0);
      do
      {
        *(float32x4_t *)(v6 + 24 + v43) = vaddq_f32(*(float32x4_t *)(v6 + 24 + v43), vdivq_f32(vsubq_f32(*(float32x4_t *)((char *)&v98 + v43), *(float32x4_t *)(v6 + 24 + v43)), v52));
        v43 += 16;
      }
      while (v43 != 192);
      uint64_t v53 = 0;
      int v54 = (float *)(v6 + 216);
      do
      {
        float32x4_t v55 = vsubq_f32(*(float32x4_t *)((char *)&v98 + v53), *(float32x4_t *)(v6 + v53 + 24));
        *(float32x4_t *)(v6 + v53 + 216) = vaddq_f32(*(float32x4_t *)(v6 + v53 + 216), vmulq_f32(v55, v55));
        v53 += 16;
      }
      while (v53 != 192);
      uint64_t v56 = 0;
      unint64_t v57 = 0;
      int v97 = 0;
      long long v95 = 0u;
      long long v96 = 0u;
      long long v93 = 0u;
      long long v94 = 0u;
      long long v92 = 0u;
      do
      {
        *(float *)((char *)&v92 + v56) = *v54 / *(float *)v51.i32;
        unint64_t v58 = HIDWORD(v57);
        BOOL v59 = (int)v57 < 2;
        if ((int)v57 < 2) {
          unint64_t v58 = 0;
        }
        long long v60 = &v54[v58];
        uint64_t v61 = (v57 + 1);
        unint64_t v62 = v57 & 0xFFFFFFFF00000000;
        int v54 = v60 + 1;
        if (!v59) {
          uint64_t v61 = 0;
        }
        unint64_t v57 = v61 | v62;
        v56 += 4;
      }
      while (v56 != 84);
      float v63 = *(float *)&v92;
      for (uint64_t i = 12; i != 84; i += 12)
        float v63 = v63 + *(float *)((char *)&v92 + i);
      uint64_t v65 = 1;
      float v66 = sqrtf(v63);
      do
      {
        uint64_t v67 = (float *)&v92 + v65;
        float v68 = *v67;
        for (uint64_t j = 3; j != 21; j += 3)
          float v68 = v68 + v67[j];
        float v70 = sqrtf(v68);
        if (v66 < v70) {
          float v66 = v70;
        }
        uint64_t v65 = (v65 + 1);
      }
      while (v65 != 3);
      uint64_t v71 = 13;
      if (v66 > *(float *)(a1 + 32))
      {
        uint64_t v71 = 5;
        float v41 = v66;
      }
      *(void *)long long v3 = v71 | ((unint64_t)LODWORD(v41) << 32);
      if (v71 != 5) {
        goto LABEL_64;
      }
    }
    else
    {
      *(void *)long long v3 = ((unint64_t)LODWORD(v41) << 32) | 2;
    }
    _ZNSt3__115allocate_sharedB8ne180100IN5arkit3btr15ScaleCorrection4ImplENS_9allocatorIS4_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v98);
    long long v72 = v98;
    long long v98 = 0uLL;
    int8x16_t v73 = *(std::__shared_weak_count **)(a1 + 64);
    *(_OWORD *)(a1 + 56) = v72;
    if (v73)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v73);
      if (*((void *)&v98 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v98 + 1));
      }
    }
    *(float *)&uint64_t v71 = *v3;
LABEL_64:
    if (v71 != 13) {
      goto LABEL_35;
    }
    uint64_t v74 = *(void *)(a1 + 56);
    if (*(unsigned char *)(v74 + 4))
    {
      float v75 = v3[1];
      *(void *)long long v3 = v76;
      uint64_t v6 = *(void *)(a1 + 56);
      if (v76 != 13) {
        return *(float *)v6;
      }
      float v77 = *(float *)(v6 + 472) / *(float *)(v6 + 476);
      float v78 = v75 + *(float *)(v6 + 628);
      *(float *)(v6 + 628) = v78;
      unint64_t v79 = *(void *)(v6 + 608) + 1;
      *(void *)(v6 + 608) = v79;
      if (v79 >= *(void *)a1)
      {
        if (v78 >= *(float *)(a1 + 28))
        {
          if (*(float *)(a1 + 40) > v77 || *(float *)(a1 + 44) < v77)
          {
            *(void *)long long v3 = ((unint64_t)LODWORD(v77) << 32) | 0xB;
            v3[1] = *((float *)&v76 + 1);
            _ZNSt3__115allocate_sharedB8ne180100IN5arkit3btr15ScaleCorrection4ImplENS_9allocatorIS4_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v98);
            long long v82 = v98;
            long long v98 = 0uLL;
            unsigned int v83 = *(std::__shared_weak_count **)(a1 + 64);
            *(_OWORD *)(a1 + 56) = v82;
            if (v83)
            {
              std::__shared_weak_count::__release_shared[abi:ne180100](v83);
              if (*((void *)&v98 + 1)) {
                std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v98 + 1));
              }
            }
            goto LABEL_35;
          }
          float v84 = vabds_f32(v77, *(float *)(v6 + 624)) / fminf(v77, *(float *)(v6 + 624));
          *(float *)(v6 + 624) = v77;
          if (v84 >= *(float *)(a1 + 24))
          {
            *(void *)(v6 + 616) = 0;
          }
          else
          {
            uint64_t v85 = *(void *)(v6 + 616);
            BOOL v88 = __CFADD__(v85, 1);
            unint64_t v86 = v85 + 1;
            *(void *)(v6 + 616) = v86;
            if (!v88)
            {
              unint64_t v87 = *(void *)(a1 + 16);
              BOOL v88 = v86 >= v87;
              if (v86 >= v87) {
                uint64_t v89 = 0;
              }
              else {
                uint64_t v89 = 9;
              }
              *(void *)long long v3 = v89 | ((unint64_t)LODWORD(v77) << 32);
              v3[1] = *((float *)&v76 + 1);
              if (v88)
              {
                uint64_t v90 = *(void *)(a1 + 56);
                *(float *)uint64_t v90 = v77;
                *(unsigned char *)(v90 + 5) = 1;
              }
              goto LABEL_35;
            }
          }
          uint64_t v80 = 10;
        }
        else
        {
          uint64_t v80 = 3;
          float v77 = v78;
        }
      }
      else
      {
        uint64_t v80 = 7;
      }
      *(void *)long long v3 = v80 | ((unint64_t)LODWORD(v77) << 32);
      v3[1] = *((float *)&v76 + 1);
LABEL_35:
      uint64_t v6 = *(void *)(a1 + 56);
      return *(float *)v6;
    }
    *(unsigned char *)(v74 + 4) = 1;
    unint64_t v38 = 7;
LABEL_34:
    *(void *)long long v3 = v38;
    goto LABEL_35;
  }
  *(void *)a3 = 6;
  return *(float *)v6;
}

uint64_t arkit::btr::ScaleCorrection::GetDbgData(arkit::btr::ScaleCorrection *this)
{
  return *((void *)this + 7) + 632;
}

double cva::assign<false,false,cva::Matrix<float,3u,16u,false>,cva::MatrixRef<float,3u,3u,false>,cva::Matrix<float,3u,16u,false>>(uint64_t *a1, uint64_t **a2)
{
  uint64_t v3 = **a2;
  if ((uint64_t *)(v3 - 4 * *((unsigned int *)*a2 + 3)) == a1 || (long long v4 = a2[1], v4 == a1))
  {
    long long v29 = 0u;
    long long v30 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    cva::assign<false,false,cva::Matrix<float,3u,16u,false>,cva::MatrixRef<float,3u,3u,false>,cva::Matrix<float,3u,16u,false>>(&v19);
    long long v13 = v28;
    *((_OWORD *)a1 + 8) = v27;
    *((_OWORD *)a1 + 9) = v13;
    long long v14 = v30;
    *((_OWORD *)a1 + 10) = v29;
    *((_OWORD *)a1 + 11) = v14;
    long long v15 = v24;
    *((_OWORD *)a1 + 4) = v23;
    *((_OWORD *)a1 + 5) = v15;
    long long v16 = v26;
    *((_OWORD *)a1 + 6) = v25;
    *((_OWORD *)a1 + 7) = v16;
    long long v17 = v20;
    *(_OWORD *)a1 = v19;
    *((_OWORD *)a1 + 1) = v17;
    double result = *(double *)&v21;
    long long v18 = v22;
    *((_OWORD *)a1 + 2) = v21;
    *((_OWORD *)a1 + 3) = v18;
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t v6 = *((unsigned int *)*a2 + 2);
    do
    {
      uint64_t v7 = 0;
      uint64_t v8 = v3;
      do
      {
        if (v6)
        {
          uint64_t v9 = 0;
          double result = 0.0;
          unint64_t v11 = (float *)v4 + 3 * v5;
          do
          {
            float v12 = *v11++;
            *(float *)&double result = *(float *)&result + (float)(*(float *)(v8 + v9) * v12);
            v9 += 4 * v6;
          }
          while (4 * (3 * v6) != v9);
        }
        else
        {
          double result = 0.0;
        }
        *((_DWORD *)a1 + 3 * v5 + v7++) = LODWORD(result);
        v8 += 4;
      }
      while (v7 != 3);
      ++v5;
    }
    while (v5 != 16);
  }
  return result;
}

float *cva::assign<false,false,cva::Matrix<float,1u,1u,false>,cva::Matrix<float,1u,16u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,1u,16u,false>>>(float *result, uint64_t a2)
{
  unint64_t v2 = result;
  if (*(float **)a2 == result)
  {
    int v6 = 0;
    double result = (float *)cva::assign<false,false,cva::Matrix<float,1u,1u,false>,cva::Matrix<float,1u,16u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,1u,16u,false>>>(&v6);
    *(_DWORD *)unint64_t v2 = v6;
  }
  else
  {
    uint64_t v3 = 0;
    float v4 = 0.0;
    do
    {
      float32x4_t v5 = vmulq_f32(*(float32x4_t *)(*(void *)a2 + v3), *(float32x4_t *)(**(void **)(a2 + 8) + v3));
      float v4 = (float)((float)((float)(v4 + v5.f32[0]) + v5.f32[1]) + v5.f32[2]) + v5.f32[3];
      v3 += 16;
    }
    while (v3 != 64);
    *double result = v4;
  }
  return result;
}

uint64_t cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::MatrixRef<float const,3u,3u,false>,cva::Matrix<float,3u,1u,false>>(uint64_t result, float **a2)
{
  uint64_t v2 = result;
  uint64_t v3 = *(void *)*a2;
  if (v3 - 4 * *((unsigned int *)*a2 + 3) == result || (float v4 = a2[1], v4 == (float *)result))
  {
    int v12 = 0;
    uint64_t v11 = 0;
    double result = cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::MatrixRef<float const,3u,3u,false>,cva::Matrix<float,3u,1u,false>>(&v11);
    *(void *)uint64_t v2 = v11;
    *(_DWORD *)(v2 + 8) = v12;
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t v6 = *((unsigned int *)*a2 + 2);
    do
    {
      if (v6)
      {
        uint64_t v7 = 0;
        float v8 = 0.0;
        uint64_t v9 = v4;
        do
        {
          float v10 = *v9++;
          float v8 = v8 + (float)(*(float *)(v3 + v7) * v10);
          v7 += 4 * v6;
        }
        while (4 * (3 * v6) != v7);
      }
      else
      {
        float v8 = 0.0;
      }
      *(float *)(result + 4 * v5++) = v8;
      v3 += 4;
    }
    while (v5 != 3);
  }
  return result;
}

uint64_t cva::MatrixRef<float,3u,3u,false>::operator=<cva::MatrixTransposeExpr<cva::MatrixRef<float const,3u,3u,false>>>(uint64_t result, uint64_t **a2)
{
  uint64_t v2 = *(_DWORD **)result;
  uint64_t v3 = *a2;
  uint64_t v4 = **a2;
  if (v4 - 4 * *((unsigned int *)*a2 + 3) == *(void *)result - 4 * *(unsigned int *)(result + 12))
  {
    uint64_t v14 = 0;
    unint64_t v15 = 0;
    int v27 = 0;
    memset(v26, 0, sizeof(v26));
    do
    {
      if (v15 > 2 || HIDWORD(v15) >= 3) {
        cva::MatrixRef<float,3u,3u,false>::operator=<cva::MatrixTransposeExpr<cva::MatrixRef<float const,3u,3u,false>>>();
      }
      *(_DWORD *)((char *)v26 + v14) = *(_DWORD *)(v4 + 4 * (HIDWORD(v15) + *((_DWORD *)v3 + 2) * v15));
      if (v15 >= 2) {
        unint64_t v15 = (v15 & 0xFFFFFFFF00000000) + 0x100000000;
      }
      else {
        unint64_t v15 = (v15 + 1) | v15 & 0xFFFFFFFF00000000;
      }
      v14 += 4;
    }
    while (v14 != 36);
    int v16 = *(_DWORD *)(result + 8);
    if (v16)
    {
      long long v17 = &v2[3 * v16];
      unint64_t v18 = (unint64_t)(v16 - 3) << 32;
      long long v19 = (int *)v26;
      do
      {
        int v20 = *v19++;
        _DWORD *v2 = v20;
        unint64_t v21 = HIDWORD(v18);
        BOOL v22 = (int)v18 < 2;
        if ((int)v18 < 2) {
          unint64_t v21 = 0;
        }
        long long v23 = &v2[v21];
        uint64_t v24 = (v18 + 1);
        unint64_t v25 = v18 & 0xFFFFFFFF00000000;
        if (!v22) {
          uint64_t v24 = 0;
        }
        unint64_t v18 = v24 | v25;
        uint64_t v2 = v23 + 1;
      }
      while (v2 != v17);
    }
  }
  else
  {
    int v5 = *(_DWORD *)(result + 8);
    if (v5)
    {
      unint64_t v6 = 0;
      uint64_t v7 = &v2[3 * v5];
      unint64_t v8 = (unint64_t)(v5 - 3) << 32;
      do
      {
        if (v6 > 2 || HIDWORD(v6) >= 3) {
          cva::MatrixRef<float,3u,3u,false>::operator=<cva::MatrixTransposeExpr<cva::MatrixRef<float const,3u,3u,false>>>();
        }
        _DWORD *v2 = *(_DWORD *)(v4 + 4 * (HIDWORD(v6) + *((_DWORD *)v3 + 2) * v6));
        if (v6 >= 2) {
          unint64_t v6 = (v6 & 0xFFFFFFFF00000000) + 0x100000000;
        }
        else {
          unint64_t v6 = (v6 + 1) | v6 & 0xFFFFFFFF00000000;
        }
        unint64_t v9 = HIDWORD(v8);
        BOOL v10 = (int)v8 < 2;
        if ((int)v8 < 2) {
          unint64_t v9 = 0;
        }
        uint64_t v11 = &v2[v9];
        uint64_t v12 = (v8 + 1);
        unint64_t v13 = v8 & 0xFFFFFFFF00000000;
        if (!v10) {
          uint64_t v12 = 0;
        }
        unint64_t v8 = v12 | v13;
        uint64_t v2 = v11 + 1;
      }
      while (v2 != v7);
    }
  }
  return result;
}

uint64_t cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::MatrixUnaryExpr<cva::MatrixRef<float,3u,3u,false>,cva::detail::NegOp>,cva::MatrixRef<float const,3u,1u,false>>(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  uint64_t v3 = *(void *)(a2 + 8);
  uint64_t v4 = *(float **)v3;
  if (*(void *)v3 - 4 * *(unsigned int *)(v3 + 12) == result)
  {
    DWORD2(v21[0]) = 0;
    *(void *)&v21[0] = 0;
    double result = cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::MatrixUnaryExpr<cva::MatrixRef<float,3u,3u,false>,cva::detail::NegOp>,cva::MatrixRef<float const,3u,1u,false>>(v21);
    *(void *)uint64_t v2 = *(void *)&v21[0];
    *(_DWORD *)(v2 + 8) = DWORD2(v21[0]);
  }
  else
  {
    uint64_t v5 = 0;
    unint64_t v6 = *(float ****)a2;
    memset(v21, 0, sizeof(v21));
    int v22 = 0;
    uint64_t v7 = *v6;
    unint64_t v8 = **v6;
    unint64_t v9 = (unint64_t)(*((_DWORD *)v7 + 2) - 3) << 32;
    do
    {
      *(float *)((char *)v21 + v5) = -*v8;
      unint64_t v10 = HIDWORD(v9);
      BOOL v11 = (int)v9 < 2;
      if ((int)v9 < 2) {
        unint64_t v10 = 0;
      }
      uint64_t v12 = &v8[v10];
      uint64_t v13 = (v9 + 1);
      unint64_t v14 = v9 & 0xFFFFFFFF00000000;
      unint64_t v8 = v12 + 1;
      if (!v11) {
        uint64_t v13 = 0;
      }
      unint64_t v9 = v13 | v14;
      v5 += 4;
    }
    while (v5 != 36);
    uint64_t v15 = 0;
    int v16 = v21;
    do
    {
      uint64_t v17 = 0;
      float v18 = 0.0;
      long long v19 = v4;
      do
      {
        float v20 = *v19++;
        float v18 = v18 + (float)(*(float *)((char *)v16 + v17) * v20);
        v17 += 12;
      }
      while (v17 != 36);
      *(float *)(result + 4 * v15++) = v18;
      int v16 = (_OWORD *)((char *)v16 + 4);
    }
    while (v15 != 3);
  }
  return result;
}

double cva::assign<false,false,cva::Matrix<float,4u,4u,false>,cva::Matrix<float,4u,4u,false>,cva::Matrix<float,4u,4u,false>>(float32x4_t *a1, float32x4_t **a2)
{
  uint64_t v3 = *a2;
  if (*a2 == a1 || (uint64_t v4 = a2[1], v4 == a1))
  {
    float32x4_t v15 = 0u;
    float32x4_t v16 = 0u;
    float32x4_t v13 = 0u;
    float32x4_t v14 = 0u;
    cva::assign<false,false,cva::Matrix<float,4u,4u,false>,cva::Matrix<float,4u,4u,false>,cva::Matrix<float,4u,4u,false>>(&v13);
    float32x4_t v10 = v14;
    *a1 = v13;
    a1[1] = v10;
    v7.i64[0] = v15.i64[0];
    float32x4_t v11 = v16;
    a1[2] = v15;
    a1[3] = v11;
  }
  else
  {
    for (uint64_t i = 0; i != 4; ++i)
    {
      uint64_t v6 = 0;
      float32x4_t v7 = 0uLL;
      unint64_t v8 = v3;
      do
      {
        float32x4_t v9 = *v8++;
        float32x4_t v7 = vmlaq_n_f32(v7, v9, v4->f32[v6++]);
      }
      while (v6 != 4);
      a1[i] = v7;
      ++v4;
    }
  }
  return *(double *)v7.i64;
}

double _ZNSt3__115allocate_sharedB8ne180100IN5arkit3btr15ScaleCorrection4ImplENS_9allocatorIS4_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_@<D0>(void *a1@<X8>)
{
  uint64_t v2 = (char *)operator new(0x2A8uLL);
  double result = 0.0;
  *(_OWORD *)(v2 + 8) = 0u;
  *(void *)uint64_t v2 = &unk_1F1209A08;
  *(_OWORD *)(v2 + 24) = 0u;
  *((_DWORD *)v2 + 6) = 1065353216;
  v2[32] = 1;
  *(_OWORD *)(v2 + 40) = 0u;
  *(_OWORD *)(v2 + 56) = 0u;
  *(_OWORD *)(v2 + 72) = 0u;
  *(_OWORD *)(v2 + 88) = 0u;
  *(_OWORD *)(v2 + 104) = 0u;
  *(_OWORD *)(v2 + 120) = 0u;
  *(_OWORD *)(v2 + 136) = 0u;
  *(_OWORD *)(v2 + 152) = 0u;
  *(_OWORD *)(v2 + 168) = 0u;
  *(_OWORD *)(v2 + 184) = 0u;
  *(_OWORD *)(v2 + 200) = 0u;
  *(_OWORD *)(v2 + 216) = 0u;
  *(_OWORD *)(v2 + 232) = 0u;
  *(_OWORD *)(v2 + 248) = 0u;
  *((void *)v2 + 53) = 0;
  *(_OWORD *)(v2 + 264) = 0u;
  *(_OWORD *)(v2 + 280) = 0u;
  *(_OWORD *)(v2 + 296) = 0u;
  *(_OWORD *)(v2 + 312) = 0u;
  *(_OWORD *)(v2 + 328) = 0u;
  *(_OWORD *)(v2 + 344) = 0u;
  *(_OWORD *)(v2 + 360) = 0u;
  *(_OWORD *)(v2 + 376) = 0u;
  *(_OWORD *)(v2 + 392) = 0u;
  *(_OWORD *)(v2 + 408) = 0u;
  *((_OWORD *)v2 + 27) = xmmword_1B8A52E44;
  *((_OWORD *)v2 + 28) = *(_OWORD *)algn_1B8A52E54;
  *((_OWORD *)v2 + 29) = xmmword_1B8A52E64;
  *((_OWORD *)v2 + 30) = unk_1B8A52E74;
  *((void *)v2 + 62) = 0;
  *(_OWORD *)(v2 + 504) = xmmword_1B8A52E44;
  *(_OWORD *)(v2 + 520) = *(_OWORD *)algn_1B8A52E54;
  *(_OWORD *)(v2 + 536) = xmmword_1B8A52E64;
  *(_OWORD *)(v2 + 552) = unk_1B8A52E74;
  *(_OWORD *)(v2 + 568) = xmmword_1B8A52E44;
  *(_OWORD *)(v2 + 584) = *(_OWORD *)algn_1B8A52E54;
  *(_OWORD *)(v2 + 600) = xmmword_1B8A52E64;
  *(_OWORD *)(v2 + 616) = unk_1B8A52E74;
  *(_OWORD *)(v2 + 632) = 0u;
  *((_DWORD *)v2 + 162) = 1065353216;
  *((_DWORD *)v2 + 169) = 0;
  *(void *)(v2 + 668) = 0;
  *(_OWORD *)(v2 + 652) = 0u;
  *a1 = v2 + 24;
  a1[1] = v2;
  return result;
}

void std::__shared_ptr_emplace<arkit::btr::ScaleCorrection::Impl>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1209A08;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<arkit::btr::ScaleCorrection::Impl>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1209A08;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BA9C56C0);
}

void std::__shared_ptr_emplace<arkit::btr::ScaleCorrection::Impl>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 656);
  if (v2)
  {
    *(void *)(a1 + 664) = v2;
    operator delete(v2);
  }
}

void sub_1B894158C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8941714(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8941808(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8941888(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8941914(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89419F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8941A94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8941B38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B8941C98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8941D34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B8941E24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double ARConsensusAndAverageFilterImpl::Update(ARConsensusAndAverageFilterImpl *this, const simd_double4x4 *a2, const simd_double4x4 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, long long a9, long long a10, long long a11, long long a12, uint64_t a13, __n128 a14, uint64_t a15, uint64_t a16, char a17, long long __src, long long a19, long long a20,long long a21,long long a22,long long a23,long long a24,long long a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,simd_double4x4 a48)
{
  uint64_t v52 = *((void *)this + 34);
  uint64_t v51 = *((void *)this + 35);
  if (0x8E38E38E38E38E39 * ((v51 - v52) >> 5) == *((_DWORD *)this + 76))
  {
    uint64_t v53 = v51 - (v52 + 288);
    if (v51 != v52 + 288) {
      memmove(*((void **)this + 34), (const void *)(v52 + 288), v51 - (v52 + 288));
    }
    *((void *)this + 35) = v52 + v53;
  }
  int v54 = (char **)((char *)this + 272);
  *(_OWORD *)&STACK[0x5C0] = 0u;
  *(_OWORD *)&STACK[0x5D0] = 0u;
  *(_OWORD *)&STACK[0x5A0] = 0u;
  *(_OWORD *)&STACK[0x5B0] = 0u;
  *(_OWORD *)&STACK[0x580] = 0u;
  *(_OWORD *)&STACK[0x590] = 0u;
  *(_OWORD *)&STACK[0x560] = 0u;
  *(_OWORD *)&STACK[0x570] = 0u;
  long long v55 = *(_OWORD *)&a2->columns[2].f64[2];
  a22 = *(_OWORD *)a2->columns[2].f64;
  a23 = v55;
  long long v56 = *(_OWORD *)&a2->columns[3].f64[2];
  a24 = *(_OWORD *)a2->columns[3].f64;
  a25 = v56;
  long long v57 = *(_OWORD *)&a2->columns[0].f64[2];
  __vImage_Buffer src = *(_OWORD *)a2->columns[0].f64;
  a19 = v57;
  long long v58 = *(_OWORD *)&a2->columns[1].f64[2];
  a20 = *(_OWORD *)a2->columns[1].f64;
  a21 = v58;
  __invert_d4();
  *(_OWORD *)&STACK[0x540] = 0u;
  *(_OWORD *)&STACK[0x550] = 0u;
  memset(&a48, 0, 96);
  ConvertIMU((float64x2_t *)&STACK[0x560], (uint64_t)&a48);
  ARConsensusAndAverageFilterImpl::ConvertToENU((float64x2_t *)this, &a48, a3, (uint64_t)&__src);
  unint64_t v60 = *((void *)this + 35);
  unint64_t v59 = *((void *)this + 36);
  if (v60 >= v59)
  {
    unint64_t v62 = 0x8E38E38E38E38E39 * ((uint64_t)(v60 - (void)*v54) >> 5);
    if (v62 + 1 > 0xE38E38E38E38E3) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v63 = 0x8E38E38E38E38E39 * ((uint64_t)(v59 - (void)*v54) >> 5);
    uint64_t v64 = 2 * v63;
    if (2 * v63 <= v62 + 1) {
      uint64_t v64 = v62 + 1;
    }
    if (v63 >= 0x71C71C71C71C71) {
      unint64_t v65 = 0xE38E38E38E38E3;
    }
    else {
      unint64_t v65 = v64;
    }
    if (v65) {
      float v66 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<AlignedPose>>((uint64_t)this + 288, v65);
    }
    else {
      float v66 = 0;
    }
    uint64_t v67 = &v66[288 * v62];
    float v68 = &v66[288 * v65];
    memcpy(v67, &__src, 0x120uLL);
    uint64_t v61 = v67 + 288;
    float v70 = (char *)*((void *)this + 34);
    uint64_t v69 = (char *)*((void *)this + 35);
    if (v69 != v70)
    {
      do
      {
        v69 -= 288;
        v67 -= 288;
        memcpy(v67, v69, 0x120uLL);
      }
      while (v69 != v70);
      uint64_t v69 = *v54;
    }
    *((void *)this + 34) = v67;
    *((void *)this + 35) = v61;
    *((void *)this + 36) = v68;
    if (v69) {
      operator delete(v69);
    }
  }
  else
  {
    memcpy(*((void **)this + 35), &__src, 0x120uLL);
    uint64_t v61 = (char *)(v60 + 288);
  }
  *((void *)this + 35) = v61;
  ARConsensusAndAverageFilterImpl::GetAlignmentAtFrameConsensusAndAverage((uint64_t)this, (uint64_t *)this + 34, 954437177 * ((unint64_t)&v61[-*((void *)this + 34)] >> 5) - 1, (uint64_t)this + 296, (uint64_t)&a14);
  if (a17)
  {
    MatrixFromTransform4Dof(&a14, (uint64_t)v74);
    *((_OWORD *)this + 4) = a9;
    *((_OWORD *)this + 5) = a10;
    *((_OWORD *)this + 6) = a11;
    *((_OWORD *)this + 7) = a12;
    long long v72 = v74[1];
    *(_OWORD *)this = v74[0];
    *((_OWORD *)this + 1) = v72;
    double result = *(double *)&v75;
    long long v73 = vars0;
    *((_OWORD *)this + 2) = v75;
    *((_OWORD *)this + 3) = v73;
    *((unsigned char *)this + 128) = 1;
  }
  return result;
}

void ARConsensusAndAverageFilterImpl::ConvertToENU(float64x2_t *this@<X0>, const simd_double4x4 *a2@<X1>, const simd_double4x4 *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = 0;
  *(void *)(a4 + 128) = 0x7FF8000000000000;
  *(unsigned char *)(a4 + 136) = 0;
  int64x2_t v8 = vdupq_n_s64(0x7FF8000000000000uLL);
  do
  {
    float32x4_t v9 = (int64x2_t *)(a4 + v7);
    int64x2_t *v9 = v8;
    v9[1] = v8;
    v7 += 32;
  }
  while (v7 != 128);
  float32x4_t v10 = (_OWORD *)(a4 + 144);
  *(void *)(a4 + 272) = 0x7FF8000000000000;
  *(unsigned char *)(a4 + 280) = 0;
  uint64_t v11 = 144;
  int64x2_t v12 = vdupq_n_s64(0x7FF8000000000000uLL);
  do
  {
    float32x4_t v13 = (int64x2_t *)(a4 + v11);
    int64x2_t *v13 = v12;
    v13[1] = v12;
    v11 += 32;
  }
  while (v11 != 272);
  long long v14 = *(_OWORD *)&a2->columns[2].f64[2];
  *(_OWORD *)(a4 + 64) = *(_OWORD *)a2->columns[2].f64;
  *(_OWORD *)(a4 + 80) = v14;
  long long v15 = *(_OWORD *)&a2->columns[3].f64[2];
  *(_OWORD *)(a4 + 96) = *(_OWORD *)a2->columns[3].f64;
  *(_OWORD *)(a4 + 112) = v15;
  long long v16 = *(_OWORD *)&a2->columns[0].f64[2];
  *(_OWORD *)a4 = *(_OWORD *)a2->columns[0].f64;
  *(_OWORD *)(a4 + 16) = v16;
  long long v17 = *(_OWORD *)&a2->columns[1].f64[2];
  *(_OWORD *)(a4 + 32) = *(_OWORD *)a2->columns[1].f64;
  *(_OWORD *)(a4 + 48) = v17;
  *(void *)(a4 + 128) = 0;
  *(unsigned char *)(a4 + 136) = 1;
  *(double *)(a4 + 128) = HeadingFromRot(a4);
  uint64_t v18 = 0;
  long long v19 = *(_OWORD *)&a3->columns[3].f64[2];
  *(_OWORD *)(a4 + 240) = *(_OWORD *)a3->columns[3].f64;
  *(_OWORD *)(a4 + 256) = v19;
  long long v20 = *(_OWORD *)&a3->columns[2].f64[2];
  *(_OWORD *)(a4 + 208) = *(_OWORD *)a3->columns[2].f64;
  *(_OWORD *)(a4 + 224) = v20;
  long long v21 = *(_OWORD *)&a3->columns[1].f64[2];
  *(_OWORD *)(a4 + 176) = *(_OWORD *)a3->columns[1].f64;
  *(_OWORD *)(a4 + 192) = v21;
  long long v22 = *(_OWORD *)&a3->columns[0].f64[2];
  *float32x4_t v10 = *(_OWORD *)a3->columns[0].f64;
  *(_OWORD *)(a4 + 160) = v22;
  *(void *)(a4 + 272) = 0;
  float64x2_t v23 = vnegq_f64(*(float64x2_t *)(a4 + 224));
  float64x2_t v24 = vnegq_f64(*(float64x2_t *)(a4 + 208));
  float64x2_t v25 = vnegq_f64(*(float64x2_t *)(a4 + 192));
  float64x2_t v26 = vnegq_f64(*(float64x2_t *)(a4 + 176));
  float64x2_t v27 = vnegq_f64(*(float64x2_t *)(a4 + 160));
  float64x2_t v28 = vnegq_f64(*(float64x2_t *)(a4 + 144));
  long long v30 = *(_OWORD *)(a4 + 240);
  long long v29 = *(_OWORD *)(a4 + 256);
  long long v53 = 0u;
  long long v54 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  float64x2_t v32 = this[9];
  float64x2_t v31 = this[10];
  float64x2_t v34 = this[11];
  float64x2_t v33 = this[12];
  float64x2_t v36 = this[13];
  float64x2_t v35 = this[14];
  float64x2_t v38 = this[15];
  float64x2_t v37 = this[16];
  v46[0] = v24;
  v46[1] = v23;
  v46[2] = v26;
  v46[3] = v25;
  v46[4] = v28;
  v46[5] = v27;
  v46[6] = v30;
  v46[7] = v29;
  do
  {
    float64x2_t v40 = (float64x2_t)v46[v18];
    float64x2_t v39 = (float64x2_t)v46[v18 + 1];
    float v41 = (float64x2_t *)((char *)&v47 + v18 * 16);
    *float v41 = vmlaq_laneq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(v32, v40.f64[0]), v34, v40, 1), v36, v39.f64[0]), v38, v39, 1);
    v41[1] = vmlaq_laneq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(v31, v40.f64[0]), v33, v40, 1), v35, v39.f64[0]), v37, v39, 1);
    v18 += 2;
  }
  while (v18 != 8);
  long long v42 = v52;
  *(_OWORD *)(a4 + 208) = v51;
  *(_OWORD *)(a4 + 224) = v42;
  long long v43 = v54;
  *(_OWORD *)(a4 + 240) = v53;
  *(_OWORD *)(a4 + 256) = v43;
  long long v44 = v48;
  *float32x4_t v10 = v47;
  *(_OWORD *)(a4 + 160) = v44;
  long long v45 = v50;
  *(_OWORD *)(a4 + 176) = v49;
  *(_OWORD *)(a4 + 192) = v45;
  *(unsigned char *)(a4 + 280) = 1;
  *(double *)(a4 + 272) = HeadingFromRot(a4 + 144);
}

void ARConsensusAndAverageFilterImpl::GetAlignmentAtFrameConsensusAndAverage(uint64_t a1@<X0>, uint64_t *a2@<X1>, unsigned int a3@<W2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  int v9 = *(_DWORD *)(a4 + 8);
  ARConsensusAndAverageFilterImpl::GetAlignmentAtFrameConsensus(a1, a2, a3, a4, (uint64_t)&v41);
  if (!(_BYTE)v43)
  {
    long long v24 = v42;
    *(_OWORD *)a5 = v41;
    *(_OWORD *)(a5 + 16) = v24;
    *(void *)(a5 + 32) = v43;
    return;
  }
  float64x2_t v38 = 0;
  float64x2_t v39 = 0;
  uint64_t v40 = 0;
  ARConsensusAndAverageFilterImpl::GetInliers(a1, a2, a3, (uint64_t)&v41, v9, (uint64_t)&v38);
  float32x4_t v10 = v39;
  if (v39 == v38)
  {
    long long v25 = v42;
    *(_OWORD *)a5 = v41;
    *(_OWORD *)(a5 + 16) = v25;
    *(void *)(a5 + 32) = v43;
    if (v10)
    {
LABEL_19:
      float64x2_t v39 = v10;
      operator delete(v10);
    }
  }
  else
  {
    ARConsensusAndAverageFilterImpl::RetrieveInliers(a2, &v38, &v36);
    uint64_t v11 = (double *)v36;
    int64x2_t v12 = v37;
    double v13 = 0.0;
    double v14 = 0.0;
    double v15 = 0.0;
    if (v36 != (char *)v37)
    {
      long long v16 = (double *)v36;
      do
      {
        double v17 = v16[16] - v16[34];
        double v18 = v17 + ceil(v17 / -360.0) * 360.0;
        if (v18 > 180.0) {
          double v18 = v18 + -360.0;
        }
        __double2 v19 = __sincos_stret(v18 * 3.14159265 / 180.0);
        double v13 = v13 + v19.__sinval;
        double v14 = v14 + v19.__cosval;
        double v15 = v15 + 1.0;
        v16 += 36;
      }
      while (v16 != v12);
    }
    double v21 = atan2(v13 / v15, v14 / v15) * 0.318309886 * 180.0;
    float64x2_t v22 = 0uLL;
    uint64_t v35 = 1;
    long long v32 = 0u;
    uint64_t v33 = 0;
    double v34 = v21;
    double v23 = 0.0;
    if (v11 == v12)
    {
      *(void *)&long long v20 = 0;
    }
    else
    {
      *(void *)&long long v20 = 0;
      do
      {
        float64x2_t v26 = v22;
        long long v27 = v20;
        memcpy(__dst, v11, sizeof(__dst));
        ARConsensusAndAverageFilterImpl::ApplyTransform((uint64_t)__dst, (uint64_t)&v32, (uint64_t)v28);
        float64x2_t v22 = vaddq_f64(v26, vsubq_f64(__dst[15], v29));
        double v23 = v23 + __dst[16].f64[0] - v30;
        *((void *)&v20 + 1) = *((void *)&v27 + 1);
        *(double *)&long long v20 = *(double *)&v27 + 1.0;
        v11 += 36;
      }
      while (v11 != v12);
      uint64_t v11 = (double *)v36;
    }
    *(float64x2_t *)a5 = vdivq_f64(v22, (float64x2_t)vdupq_lane_s64(v20, 0));
    *(double *)(a5 + 16) = v23 / *(double *)&v20;
    *(double *)(a5 + 24) = v21;
    *(unsigned char *)(a5 + 32) = 1;
    if (v11)
    {
      float64x2_t v37 = v11;
      operator delete(v11);
    }
    float32x4_t v10 = v38;
    if (v38) {
      goto LABEL_19;
    }
  }
}

void sub_1B89425E0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)(v1 - 192);
  if (v3)
  {
    *(void *)(v1 - 184) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<AlignedPose>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xE38E38E38E38E4) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(288 * a2);
}

void ARConsensusAndAverageFilterImpl::GetAlignmentAtFrameConsensus(uint64_t a1@<X0>, uint64_t *a2@<X1>, unsigned int a3@<W2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  int v7 = *(_DWORD *)(a4 + 8);
  double v8 = *(double *)a4;
  LOBYTE(v29) = 0;
  float64x2_t v27 = 0u;
  long long v28 = 0u;
  if ((a3 & 0x80000000) != 0)
  {
    double v14 = 0.0;
  }
  else
  {
    int v11 = 0;
    uint64_t v12 = a3;
    uint64_t v13 = 288 * a3 + 280;
    double v14 = 0.0;
    do
    {
      double v15 = (double *)(*a2 + v13);
      if (*((unsigned char *)v15 - 144)) {
        BOOL v16 = *(unsigned char *)v15 == 0;
      }
      else {
        BOOL v16 = 1;
      }
      if (!v16)
      {
        double v17 = *(v15 - 19) - *(v15 - 1);
        *((double *)&v25 + 1) = v17 + ceil(v17 / -360.0) * 360.0;
        __double2 v19 = __sincos_stret(*((double *)&v25 + 1) * 3.14159265 / 180.0);
        v18.f64[0] = v19.__cosval;
        v20.f64[0] = -v19.__sinval;
        v20.f64[1] = v19.__cosval;
        v18.f64[1] = v19.__sinval;
        float64x2_t v24 = vsubq_f64(*(float64x2_t *)(v15 - 5), vmlaq_n_f64(vmulq_laneq_f64(v20, *(float64x2_t *)(v15 - 23), 1), v18, *(v15 - 23)));
        *(double *)&long long v25 = *(v15 - 3) - *(v15 - 21);
        char v26 = 1;
        double Inliers = ARConsensusAndAverageFilterImpl::GetInliers(a1, a2, a3, (uint64_t)&v24, v7, 0);
        if (Inliers > v14)
        {
          float64x2_t v27 = v24;
          long long v28 = v25;
          LOBYTE(v29) = v26;
          double v14 = Inliers;
        }
        ++v11;
      }
      if (v11 > v7) {
        break;
      }
      v13 -= 288;
    }
    while (v12-- > 0);
  }
  *(double *)(a1 + 312) = v14;
  if (v14 >= v8)
  {
    long long v23 = v28;
    *(float64x2_t *)a5 = v27;
    *(_OWORD *)(a5 + 16) = v23;
    *(void *)(a5 + 32) = v29;
  }
  else
  {
    *(unsigned char *)(a5 + 32) = 0;
    *(_OWORD *)a5 = 0u;
    *(_OWORD *)(a5 + 16) = 0u;
  }
}

double ARConsensusAndAverageFilterImpl::GetInliers(uint64_t a1, uint64_t *a2, unsigned int a3, uint64_t a4, int a5, uint64_t a6)
{
  if (0x8E38E38E38E38E39 * ((a2[1] - *a2) >> 5) <= a3) {
    ARConsensusAndAverageFilterImpl::GetInliers();
  }
  if ((a3 & 0x80000000) == 0)
  {
    int v10 = 0;
    uint64_t v11 = a3;
    uint64_t v12 = a6 + 16;
    double v13 = 0.0;
    while (1)
    {
      uint64_t v14 = *a2;
      uint64_t v15 = *a2 + 288 * v11;
      if (*(unsigned char *)(v15 + 136)) {
        BOOL v16 = *(unsigned char *)(v15 + 280) == 0;
      }
      else {
        BOOL v16 = 1;
      }
      if (!v16)
      {
        ARConsensusAndAverageFilterImpl::ApplyTransform(v15, a4, (uint64_t)&v34);
        double v17 = (double *)(v14 + 288 * v11);
        float v18 = (v17[31] - v36) * (v17[31] - v36) + (v17[30] - v35) * (v17[30] - v35);
        float v19 = sqrtf(v18);
        double v20 = v17[34] - v37 + ceil((v17[34] - v37) / -360.0) * 360.0;
        if (v20 > 180.0) {
          double v20 = v20 + -360.0;
        }
        BOOL v21 = fabs(v20) <= 10.0 && v19 <= 10.0;
        if (v21)
        {
          if (a6)
          {
            long long v23 = *(_DWORD **)(a6 + 8);
            unint64_t v22 = *(void *)(a6 + 16);
            if ((unint64_t)v23 >= v22)
            {
              long long v25 = *(_DWORD **)a6;
              uint64_t v26 = ((uint64_t)v23 - *(void *)a6) >> 2;
              unint64_t v27 = v26 + 1;
              if ((unint64_t)(v26 + 1) >> 62) {
                std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
              }
              uint64_t v28 = v22 - (void)v25;
              if (v28 >> 1 > v27) {
                unint64_t v27 = v28 >> 1;
              }
              if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v29 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v29 = v27;
              }
              if (v29)
              {
                double v30 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v12, v29);
                long long v25 = *(_DWORD **)a6;
                long long v23 = *(_DWORD **)(a6 + 8);
              }
              else
              {
                double v30 = 0;
              }
              float64x2_t v31 = &v30[4 * v26];
              *(_DWORD *)float64x2_t v31 = v11;
              float64x2_t v24 = v31 + 4;
              while (v23 != v25)
              {
                int v32 = *--v23;
                *((_DWORD *)v31 - 1) = v32;
                v31 -= 4;
              }
              *(void *)a6 = v31;
              *(void *)(a6 + 8) = v24;
              *(void *)(a6 + 16) = &v30[4 * v29];
              if (v25) {
                operator delete(v25);
              }
            }
            else
            {
              *long long v23 = v11;
              float64x2_t v24 = v23 + 1;
            }
            *(void *)(a6 + 8) = v24;
          }
          double v13 = v13 + 1.0;
          if (v10 >= a5) {
            return v13;
          }
        }
        ++v10;
      }
      BOOL v21 = v11-- <= 0;
      if (v21) {
        return v13;
      }
    }
  }
  return 0.0;
}

__n128 ARConsensusAndAverageFilterImpl::RetrieveInliers@<Q0>(void *a1@<X1>, unsigned int **a2@<X2>, void *a3@<X8>)
{
  uint64_t v5 = std::vector<std::pair<Pos4Dof,Pos4Dof>>::vector(a3, a2[1] - *a2);
  int v7 = *a2;
  double v8 = a2[1];
  if (*a2 != v8)
  {
    unsigned int v9 = 0;
    uint64_t v10 = *v5;
    do
    {
      unsigned int v11 = *v7++;
      uint64_t v12 = (_OWORD *)(*a1 + 288 * v11);
      uint64_t v13 = v10 + 288 * v9;
      long long v14 = v12[4];
      long long v16 = v12[1];
      long long v15 = v12[2];
      *(_OWORD *)(v13 + 48) = v12[3];
      *(_OWORD *)(v13 + 64) = v14;
      *(_OWORD *)(v13 + 16) = v16;
      *(_OWORD *)(v13 + 32) = v15;
      long long v18 = v12[6];
      long long v17 = v12[7];
      long long v19 = v12[5];
      *(_OWORD *)(v13 + 121) = *(_OWORD *)((char *)v12 + 121);
      *(_OWORD *)(v13 + 96) = v18;
      *(_OWORD *)(v13 + 112) = v17;
      *(_OWORD *)(v13 + 80) = v19;
      *(_OWORD *)uint64_t v13 = *v12;
      uint64_t v20 = *a1 + 288 * v11;
      *(_OWORD *)(v13 + 144) = *(_OWORD *)(v20 + 144);
      long long v21 = *(_OWORD *)(v20 + 160);
      long long v22 = *(_OWORD *)(v20 + 176);
      long long v23 = *(_OWORD *)(v20 + 208);
      *(_OWORD *)(v13 + 192) = *(_OWORD *)(v20 + 192);
      *(_OWORD *)(v13 + 208) = v23;
      *(_OWORD *)(v13 + 160) = v21;
      *(_OWORD *)(v13 + 176) = v22;
      __n128 result = *(__n128 *)(v20 + 224);
      long long v24 = *(_OWORD *)(v20 + 240);
      long long v25 = *(_OWORD *)(v20 + 256);
      *(_OWORD *)(v13 + 265) = *(_OWORD *)(v20 + 265);
      *(_OWORD *)(v13 + 240) = v24;
      *(_OWORD *)(v13 + 256) = v25;
      *(__n128 *)(v13 + 224) = result;
      ++v9;
    }
    while (v7 != v8);
  }
  return result;
}

void ARConsensusAndAverageFilterImpl::ApplyTransform(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v6 = 0;
  *(void *)(a3 + 128) = 0x7FF8000000000000;
  *(unsigned char *)(a3 + 136) = 0;
  int64x2_t v7 = vdupq_n_s64(0x7FF8000000000000uLL);
  do
  {
    double v8 = (int64x2_t *)(a3 + v6);
    *double v8 = v7;
    v8[1] = v7;
    v6 += 32;
  }
  while (v6 != 128);
  if (*(unsigned char *)(a2 + 32))
  {
    double v9 = *(double *)(a2 + 24);
    float64x2_t v30 = *(float64x2_t *)(MEMORY[0x1E4F14990] + 80);
    float64x2_t v31 = *(float64x2_t *)(MEMORY[0x1E4F14990] + 16);
    float64x2_t v28 = *(float64x2_t *)(MEMORY[0x1E4F14990] + 64);
    float64x2_t v29 = *(float64x2_t *)(MEMORY[0x1E4F14990] + 48);
    long long v27 = *(_OWORD *)(MEMORY[0x1E4F14990] + 112);
    __double2 v10 = __sincos_stret(v9 * 3.14159265 / 180.0);
    v13.f64[0] = v10.__cosval;
    v15.f64[1] = *((float64_t *)&v27 + 1);
    uint64_t v11 = 0;
    v12.f64[0] = -v10.__sinval;
    v12.f64[1] = v10.__cosval;
    v13.f64[1] = v10.__sinval;
    float64x2_t v14 = *(float64x2_t *)a2;
    v15.f64[0] = *(float64_t *)(a2 + 16);
    long long v16 = *(_OWORD *)(a1 + 80);
    v32[4] = *(_OWORD *)(a1 + 64);
    v32[5] = v16;
    long long v17 = *(_OWORD *)(a1 + 112);
    v32[6] = *(_OWORD *)(a1 + 96);
    v32[7] = v17;
    long long v18 = *(_OWORD *)(a1 + 16);
    v32[0] = *(_OWORD *)a1;
    v32[1] = v18;
    long long v19 = *(_OWORD *)(a1 + 48);
    v32[2] = *(_OWORD *)(a1 + 32);
    v32[3] = v19;
    do
    {
      float64x2_t v21 = (float64x2_t)v32[v11];
      float64x2_t v20 = (float64x2_t)v32[v11 + 1];
      long long v22 = (float64x2_t *)&v33[v11];
      *long long v22 = vmlaq_laneq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(v13, v21.f64[0]), v12, v21, 1), v28, v20.f64[0]), v14, v20, 1);
      v22[1] = vmlaq_laneq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(v31, v21.f64[0]), v29, v21, 1), v30, v20.f64[0]), v15, v20, 1);
      v11 += 2;
    }
    while (v11 != 8);
    long long v23 = v33[5];
    *(_OWORD *)(a3 + 64) = v33[4];
    *(_OWORD *)(a3 + 80) = v23;
    long long v24 = v33[7];
    *(_OWORD *)(a3 + 96) = v33[6];
    *(_OWORD *)(a3 + 112) = v24;
    long long v25 = v33[1];
    *(_OWORD *)a3 = v33[0];
    *(_OWORD *)(a3 + 16) = v25;
    long long v26 = v33[3];
    *(_OWORD *)(a3 + 32) = v33[2];
    *(_OWORD *)(a3 + 48) = v26;
    *(double *)(a3 + 128) = *(double *)(a1 + 128) - v9;
    *(unsigned char *)(a3 + 136) = 1;
  }
}

void *std::vector<std::pair<Pos4Dof,Pos4Dof>>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::pair<Pos4Dof,Pos4Dof>>::__vallocate[abi:ne180100](a1, a2);
    std::vector<std::pair<Pos4Dof,Pos4Dof>>::__construct_at_end((uint64_t)a1, a2);
  }
  return a1;
}

void sub_1B8942D0C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<std::pair<Pos4Dof,Pos4Dof>>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >= 0xE38E38E38E38E4) {
    std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
  }
  __n128 result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<AlignedPose>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[288 * v4];
  return result;
}

uint64_t std::vector<std::pair<Pos4Dof,Pos4Dof>>::__construct_at_end(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 8);
  if (a2)
  {
    uint64_t v3 = v2 + 288 * a2;
    int64x2_t v4 = vdupq_n_s64(0x7FF8000000000000uLL);
    do
    {
      uint64_t v5 = 0;
      *(void *)(v2 + 128) = 0x7FF8000000000000;
      *(unsigned char *)(v2 + 136) = 0;
      do
      {
        uint64_t v6 = (int64x2_t *)(v2 + v5);
        int64x2_t *v6 = v4;
        v6[1] = v4;
        v5 += 32;
      }
      while (v5 != 128);
      *(void *)(v2 + 272) = 0x7FF8000000000000;
      *(unsigned char *)(v2 + 280) = 0;
      for (uint64_t i = 144; i != 272; i += 32)
      {
        double v8 = (int64x2_t *)(v2 + i);
        *double v8 = v4;
        v8[1] = v4;
      }
      v2 += 288;
    }
    while (v2 != v3);
    uint64_t v2 = v3;
  }
  *(void *)(result + 8) = v2;
  return result;
}

void sub_1B8944214(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::vector<unsigned char>::resize(unint64_t *a1, unint64_t a2)
{
  unint64_t v2 = a1[1] - *a1;
  BOOL v3 = a2 >= v2;
  size_t v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<unsigned char>::__append(a1, v4);
  }
  else if (!v3)
  {
    a1[1] = *a1 + a2;
  }
}

void _ZNSt3__16vectorIDv4_hNS_9allocatorIS1_EEE6resizeEm(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 2;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 4 * a2;
    }
  }
  else
  {
    _ZNSt3__16vectorIDv4_hNS_9allocatorIS1_EEE8__appendEm((void **)a1, a2 - v2);
  }
}

void _ZNSt3__16vectorIDv4_tNS_9allocatorIS1_EEE6resizeEm(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 8 * a2;
    }
  }
  else
  {
    _ZNSt3__16vectorIDv4_tNS_9allocatorIS1_EEE8__appendEm((void **)a1, a2 - v2);
  }
}

void sub_1B8944484(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B894459C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8944BD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, void *a15, void *a16, void *a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void ___ZL13_ARLogGeneralv_block_invoke_7()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "General");
  uint64_t v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObuint64_t j = (uint64_t)v0;
}

void std::vector<unsigned char>::__append(unint64_t *a1, size_t a2)
{
  uint64_t v5 = (char *)a1[1];
  size_t v4 = (char *)a1[2];
  if (v4 - v5 >= a2)
  {
    if (a2)
    {
      bzero((void *)a1[1], a2);
      v5 += a2;
    }
    a1[1] = (unint64_t)v5;
  }
  else
  {
    unint64_t v6 = *a1;
    int64x2_t v7 = &v5[-*a1];
    unint64_t v8 = (unint64_t)&v7[a2];
    if ((uint64_t)&v7[a2] < 0) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v9 = (unint64_t)&v4[-v6];
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v10 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v10 = v8;
    }
    if (v10) {
      unint64_t v11 = (unint64_t)operator new(v10);
    }
    else {
      unint64_t v11 = 0;
    }
    float64x2_t v12 = &v7[v11];
    float64x2_t v13 = (char *)(v11 + v10);
    bzero(v12, a2);
    if (v5 == (char *)v6)
    {
      unint64_t v11 = (unint64_t)v12;
    }
    else
    {
      float64x2_t v14 = &v5[~v6];
      do
      {
        char v15 = *--v5;
        (v14--)[v11] = v15;
      }
      while (v5 != (char *)v6);
      uint64_t v5 = (char *)*a1;
    }
    *a1 = v11;
    a1[1] = (unint64_t)&v12[a2];
    a1[2] = (unint64_t)v13;
    if (v5)
    {
      operator delete(v5);
    }
  }
}

void _ZNSt3__16vectorIDv4_hNS_9allocatorIS1_EEE8__appendEm(void **a1, unint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  int64x2_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 2)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 4 * a2);
      v7 += 4 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = v7 - (unsigned char *)*a1;
    unint64_t v9 = a2 + (v8 >> 2);
    if (v9 >> 62) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 2;
    uint64_t v11 = v5 - (unsigned char *)*a1;
    if (v11 >> 1 > v9) {
      unint64_t v9 = v11 >> 1;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v9;
    }
    if (v12) {
      float64x2_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v4, v12);
    }
    else {
      float64x2_t v13 = 0;
    }
    float64x2_t v14 = &v13[4 * v10];
    char v15 = &v13[4 * v12];
    bzero(v14, 4 * a2);
    long long v16 = &v14[4 * a2];
    long long v18 = (char *)*a1;
    long long v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        int v19 = *((_DWORD *)v17 - 1);
        v17 -= 4;
        *((_DWORD *)v14 - 1) = v19;
        v14 -= 4;
      }
      while (v17 != v18);
      long long v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
    {
      operator delete(v17);
    }
  }
}

void _ZNSt3__16vectorIDv4_tNS_9allocatorIS1_EEE8__appendEm(void **a1, unint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  int64x2_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = v7 - (unsigned char *)*a1;
    unint64_t v9 = a2 + (v8 >> 3);
    if (v9 >> 61) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 3;
    uint64_t v11 = v5 - (unsigned char *)*a1;
    if (v11 >> 2 > v9) {
      unint64_t v9 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v9;
    }
    if (v12) {
      float64x2_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>(v4, v12);
    }
    else {
      float64x2_t v13 = 0;
    }
    float64x2_t v14 = &v13[8 * v10];
    char v15 = &v13[8 * v12];
    bzero(v14, 8 * a2);
    long long v16 = &v14[8 * a2];
    long long v18 = (char *)*a1;
    long long v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        uint64_t v19 = *((void *)v17 - 1);
        v17 -= 8;
        *((void *)v14 - 1) = v19;
        v14 -= 8;
      }
      while (v17 != v18);
      long long v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
    {
      operator delete(v17);
    }
  }
}

char *_ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE18__insert_with_sizeB8ne180100INS_11__wrap_iterIPS1_EES8_EES8_NS6_IPKS1_EET_T0_l(uint64_t a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  uint64_t v5 = (char *)__dst;
  if (a5 < 1) {
    return v5;
  }
  int64x2_t v7 = __src;
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v9 = a1 + 16;
  uint64_t v10 = v11;
  unint64_t v12 = *(void *)(v9 - 8);
  if (a5 > (uint64_t)(v11 - v12) >> 4)
  {
    float64x2_t v13 = *(void **)a1;
    unint64_t v14 = a5 + ((uint64_t)(v12 - *(void *)a1) >> 4);
    if (v14 >> 60) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v15 = (__dst - (uint64_t)v13) >> 4;
    uint64_t v16 = v10 - (void)v13;
    if (v16 >> 3 > v14) {
      unint64_t v14 = v16 >> 3;
    }
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v17 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v14;
    }
    uint64_t v37 = v9;
    if (v17) {
      long long v18 = (char *)_ZNSt3__119__allocate_at_leastB8ne180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m(v9, v17);
    }
    else {
      long long v18 = 0;
    }
    float64x2_t v28 = &v18[16 * v15];
    __p = v18;
    uint64_t v34 = v28;
    double v36 = &v18[16 * v17];
    uint64_t v29 = 16 * a5;
    float64x2_t v30 = &v28[16 * a5];
    do
    {
      long long v31 = *(_OWORD *)v7;
      v7 += 16;
      *(_OWORD *)float64x2_t v28 = v31;
      v28 += 16;
      v29 -= 16;
    }
    while (v29);
    double v35 = v30;
    uint64_t v5 = _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE26__swap_out_circular_bufferERNS_14__split_bufferIS1_RS3_EEPS1_((void **)a1, (uint64_t)&__p, v5);
    if (v35 != v34) {
      v35 += (v34 - v35 + 15) & 0xFFFFFFFFFFFFFFF0;
    }
    if (__p) {
      operator delete(__p);
    }
    return v5;
  }
  uint64_t v19 = v12 - __dst;
  uint64_t v20 = (uint64_t)(v12 - __dst) >> 4;
  if (v20 >= a5)
  {
    float64x2_t v21 = &__src[16 * a5];
    long long v23 = *(char **)(v9 - 8);
LABEL_17:
    long long v24 = &v5[16 * a5];
    long long v25 = &v23[-16 * a5];
    long long v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      long long v26 = v23;
      do
      {
        long long v27 = *(_OWORD *)v25;
        v25 += 16;
        *(_OWORD *)long long v26 = v27;
        v26 += 16;
      }
      while ((unint64_t)v25 < v12);
    }
    *(void *)(a1 + 8) = v26;
    if (v23 != v24) {
      memmove(&v23[-16 * ((v23 - v24) >> 4)], v5, v23 - v24);
    }
    if (v21 != v7) {
      memmove(v5, v7, v21 - v7);
    }
    return v5;
  }
  float64x2_t v21 = &__src[16 * v20];
  int64_t v22 = a4 - v21;
  if (a4 != v21) {
    memmove(*(void **)(v9 - 8), &__src[16 * v20], a4 - v21);
  }
  long long v23 = (char *)(v12 + v22);
  *(void *)(a1 + 8) = v12 + v22;
  if (v19 >= 1) {
    goto LABEL_17;
  }
  return v5;
}

void sub_1B8945470(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

char *_ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE26__swap_out_circular_bufferERNS_14__split_bufferIS1_RS3_EEPS1_(void **a1, uint64_t a2, char *__src)
{
  uint64_t v5 = *(char **)(a2 + 8);
  unint64_t v6 = (char *)*a1;
  int64x2_t v7 = v5;
  if (*a1 != __src)
  {
    uint64_t v8 = __src;
    int64x2_t v7 = *(char **)(a2 + 8);
    do
    {
      long long v9 = *((_OWORD *)v8 - 1);
      v8 -= 16;
      *((_OWORD *)v7 - 1) = v9;
      v7 -= 16;
    }
    while (v8 != v6);
  }
  *(void *)(a2 + 8) = v7;
  uint64_t v10 = a1[1];
  uint64_t v11 = *(void *)(a2 + 16);
  int64_t v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    int64x2_t v7 = *(char **)(a2 + 8);
  }
  *(void *)(a2 + 16) = v11 + v12;
  float64x2_t v13 = (char *)*a1;
  *a1 = v7;
  *(void *)(a2 + 8) = v13;
  unint64_t v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(void *)(a2 + 16) = v14;
  uint64_t v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(void *)(a2 + 24) = v15;
  *(void *)a2 = *(void *)(a2 + 8);
  return v5;
}

char *std::vector<unsigned char>::__insert_with_size[abi:ne180100]<std::__wrap_iter<unsigned char *>,std::__wrap_iter<unsigned char *>>(uint64_t a1, char *__dst, char *__src, char *a4, uint64_t a5)
{
  uint64_t v5 = __dst;
  if (a5 < 1) {
    return v5;
  }
  uint64_t v6 = a5;
  int64x2_t v7 = __src;
  uint64_t v10 = *(char **)(a1 + 8);
  uint64_t v9 = *(void *)(a1 + 16);
  if (v9 - (uint64_t)v10 < a5)
  {
    uint64_t v11 = *(char **)a1;
    uint64_t v12 = (uint64_t)&v10[a5 - *(void *)a1];
    if (v12 < 0) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    float64x2_t v13 = (char *)(__dst - v11);
    unint64_t v14 = v9 - (void)v11;
    if (2 * v14 > v12) {
      uint64_t v12 = 2 * v14;
    }
    if (v14 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v15 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v15 = v12;
    }
    if (v15) {
      uint64_t v16 = operator new(v15);
    }
    else {
      uint64_t v16 = 0;
    }
    long long v26 = &v13[(void)v16];
    long long v27 = &v13[(void)v16 + v6];
    float64x2_t v28 = v26;
    do
    {
      char v29 = *v7++;
      *v28++ = v29;
      --v6;
    }
    while (v6);
    float64x2_t v30 = *(char **)a1;
    if (*(char **)a1 == v5)
    {
      int v32 = v26;
    }
    else
    {
      long long v31 = v5;
      int v32 = v26;
      do
      {
        char v33 = *--v31;
        *--int v32 = v33;
      }
      while (v31 != v30);
      uint64_t v10 = *(char **)(a1 + 8);
    }
    uint64_t v34 = (char *)v16 + v15;
    if (v10 != v5) {
      memmove(v27, v5, v10 - v5);
    }
    double v35 = *(char **)a1;
    *(void *)a1 = v32;
    *(void *)(a1 + 8) = &v27[v10 - v5];
    *(void *)(a1 + 16) = v34;
    if (v35) {
      operator delete(v35);
    }
    return v26;
  }
  uint64_t v17 = v10 - __dst;
  if (v10 - __dst >= a5)
  {
    long long v18 = &__src[a5];
    uint64_t v20 = *(char **)(a1 + 8);
LABEL_17:
    float64x2_t v21 = &v5[v6];
    int64_t v22 = &v20[-v6];
    long long v23 = v20;
    if (&v20[-v6] < v10)
    {
      int64_t v24 = &v10[v6] - v20;
      long long v23 = v20;
      do
      {
        char v25 = *v22++;
        *v23++ = v25;
        --v24;
      }
      while (v24);
    }
    *(void *)(a1 + 8) = v23;
    if (v20 != v21) {
      memmove(&v5[v6], v5, v20 - v21);
    }
    if (v18 != v7) {
      memmove(v5, v7, v18 - v7);
    }
    return v5;
  }
  long long v18 = &__src[v17];
  int64_t v19 = a4 - &__src[v17];
  if (a4 != &__src[v17]) {
    memmove(*(void **)(a1 + 8), &__src[v17], a4 - &__src[v17]);
  }
  uint64_t v20 = &v10[v19];
  *(void *)(a1 + 8) = &v10[v19];
  if (v17 >= 1) {
    goto LABEL_17;
  }
  return v5;
}

char *_ZNSt3__16vectorIDv4_hNS_9allocatorIS1_EEE18__insert_with_sizeB8ne180100INS_11__wrap_iterIPS1_EES8_EES8_NS6_IPKS1_EET_T0_l(uint64_t a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  uint64_t v5 = (char *)__dst;
  if (a5 < 1) {
    return v5;
  }
  int64x2_t v7 = __src;
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v9 = a1 + 16;
  uint64_t v10 = v11;
  unint64_t v12 = *(void *)(v9 - 8);
  if (a5 > (uint64_t)(v11 - v12) >> 2)
  {
    float64x2_t v13 = *(void **)a1;
    unint64_t v14 = a5 + ((uint64_t)(v12 - *(void *)a1) >> 2);
    if (v14 >> 62) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v15 = (__dst - (uint64_t)v13) >> 2;
    uint64_t v16 = v10 - (void)v13;
    if (v16 >> 1 > v14) {
      unint64_t v14 = v16 >> 1;
    }
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v17 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v14;
    }
    uint64_t v37 = v9;
    if (v17) {
      long long v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v9, v17);
    }
    else {
      long long v18 = 0;
    }
    float64x2_t v28 = &v18[4 * v15];
    __p = v18;
    uint64_t v34 = v28;
    double v36 = &v18[4 * v17];
    uint64_t v29 = 4 * a5;
    float64x2_t v30 = &v28[4 * a5];
    do
    {
      int v31 = *(_DWORD *)v7;
      v7 += 4;
      *(_DWORD *)float64x2_t v28 = v31;
      v28 += 4;
      v29 -= 4;
    }
    while (v29);
    double v35 = v30;
    uint64_t v5 = _ZNSt3__16vectorIDv4_hNS_9allocatorIS1_EEE26__swap_out_circular_bufferERNS_14__split_bufferIS1_RS3_EEPS1_((void **)a1, (uint64_t)&__p, v5);
    if (v35 != v34) {
      v35 += (v34 - v35 + 3) & 0xFFFFFFFFFFFFFFFCLL;
    }
    if (__p) {
      operator delete(__p);
    }
    return v5;
  }
  uint64_t v19 = v12 - __dst;
  uint64_t v20 = (uint64_t)(v12 - __dst) >> 2;
  if (v20 >= a5)
  {
    float64x2_t v21 = &__src[4 * a5];
    long long v23 = *(char **)(v9 - 8);
LABEL_17:
    int64_t v24 = &v5[4 * a5];
    char v25 = &v23[-4 * a5];
    long long v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      long long v26 = v23;
      do
      {
        int v27 = *(_DWORD *)v25;
        v25 += 4;
        *(_DWORD *)long long v26 = v27;
        v26 += 4;
      }
      while ((unint64_t)v25 < v12);
    }
    *(void *)(a1 + 8) = v26;
    if (v23 != v24) {
      memmove(&v23[-4 * ((v23 - v24) >> 2)], v5, v23 - v24);
    }
    if (v21 != v7) {
      memmove(v5, v7, v21 - v7);
    }
    return v5;
  }
  float64x2_t v21 = &__src[4 * v20];
  int64_t v22 = a4 - v21;
  if (a4 != v21) {
    memmove(*(void **)(v9 - 8), &__src[4 * v20], a4 - v21);
  }
  long long v23 = (char *)(v12 + v22);
  *(void *)(a1 + 8) = v12 + v22;
  if (v19 >= 1) {
    goto LABEL_17;
  }
  return v5;
}

void sub_1B8945928(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

char *_ZNSt3__16vectorIDv4_hNS_9allocatorIS1_EEE26__swap_out_circular_bufferERNS_14__split_bufferIS1_RS3_EEPS1_(void **a1, uint64_t a2, char *__src)
{
  uint64_t v5 = *(char **)(a2 + 8);
  uint64_t v6 = (char *)*a1;
  int64x2_t v7 = v5;
  if (*a1 != __src)
  {
    uint64_t v8 = __src;
    int64x2_t v7 = *(char **)(a2 + 8);
    do
    {
      int v9 = *((_DWORD *)v8 - 1);
      v8 -= 4;
      *((_DWORD *)v7 - 1) = v9;
      v7 -= 4;
    }
    while (v8 != v6);
  }
  *(void *)(a2 + 8) = v7;
  uint64_t v10 = a1[1];
  uint64_t v11 = *(void *)(a2 + 16);
  int64_t v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    int64x2_t v7 = *(char **)(a2 + 8);
  }
  *(void *)(a2 + 16) = v11 + v12;
  float64x2_t v13 = (char *)*a1;
  *a1 = v7;
  *(void *)(a2 + 8) = v13;
  unint64_t v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(void *)(a2 + 16) = v14;
  uint64_t v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(void *)(a2 + 24) = v15;
  *(void *)a2 = *(void *)(a2 + 8);
  return v5;
}

char *_ZNSt3__16vectorIDv4_tNS_9allocatorIS1_EEE18__insert_with_sizeB8ne180100INS_11__wrap_iterIPS1_EES8_EES8_NS6_IPKS1_EET_T0_l(uint64_t a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  uint64_t v5 = (char *)__dst;
  if (a5 < 1) {
    return v5;
  }
  int64x2_t v7 = __src;
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v9 = a1 + 16;
  uint64_t v10 = v11;
  unint64_t v12 = *(void *)(v9 - 8);
  if (a5 > (uint64_t)(v11 - v12) >> 3)
  {
    float64x2_t v13 = *(void **)a1;
    unint64_t v14 = a5 + ((uint64_t)(v12 - *(void *)a1) >> 3);
    if (v14 >> 61) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v15 = (__dst - (uint64_t)v13) >> 3;
    uint64_t v16 = v10 - (void)v13;
    if (v16 >> 2 > v14) {
      unint64_t v14 = v16 >> 2;
    }
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v14;
    }
    uint64_t v37 = v9;
    if (v17) {
      long long v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>(v9, v17);
    }
    else {
      long long v18 = 0;
    }
    float64x2_t v28 = &v18[8 * v15];
    __p = v18;
    uint64_t v34 = v28;
    double v36 = &v18[8 * v17];
    uint64_t v29 = 8 * a5;
    float64x2_t v30 = &v28[8 * a5];
    do
    {
      uint64_t v31 = *(void *)v7;
      v7 += 8;
      *(void *)float64x2_t v28 = v31;
      v28 += 8;
      v29 -= 8;
    }
    while (v29);
    double v35 = v30;
    uint64_t v5 = _ZNSt3__16vectorIDv4_tNS_9allocatorIS1_EEE26__swap_out_circular_bufferERNS_14__split_bufferIS1_RS3_EEPS1_((void **)a1, (uint64_t)&__p, v5);
    if (v35 != v34) {
      v35 += (v34 - v35 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    if (__p) {
      operator delete(__p);
    }
    return v5;
  }
  uint64_t v19 = v12 - __dst;
  uint64_t v20 = (uint64_t)(v12 - __dst) >> 3;
  if (v20 >= a5)
  {
    float64x2_t v21 = &__src[8 * a5];
    long long v23 = *(char **)(v9 - 8);
LABEL_17:
    int64_t v24 = &v5[8 * a5];
    char v25 = &v23[-8 * a5];
    long long v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      long long v26 = v23;
      do
      {
        uint64_t v27 = *(void *)v25;
        v25 += 8;
        *(void *)long long v26 = v27;
        v26 += 8;
      }
      while ((unint64_t)v25 < v12);
    }
    *(void *)(a1 + 8) = v26;
    if (v23 != v24) {
      memmove(&v23[-8 * ((v23 - v24) >> 3)], v5, v23 - v24);
    }
    if (v21 != v7) {
      memmove(v5, v7, v21 - v7);
    }
    return v5;
  }
  float64x2_t v21 = &__src[8 * v20];
  int64_t v22 = a4 - v21;
  if (a4 != v21) {
    memmove(*(void **)(v9 - 8), &__src[8 * v20], a4 - v21);
  }
  long long v23 = (char *)(v12 + v22);
  *(void *)(a1 + 8) = v12 + v22;
  if (v19 >= 1) {
    goto LABEL_17;
  }
  return v5;
}

void sub_1B8945C00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

char *_ZNSt3__16vectorIDv4_tNS_9allocatorIS1_EEE26__swap_out_circular_bufferERNS_14__split_bufferIS1_RS3_EEPS1_(void **a1, uint64_t a2, char *__src)
{
  uint64_t v5 = *(char **)(a2 + 8);
  uint64_t v6 = (char *)*a1;
  int64x2_t v7 = v5;
  if (*a1 != __src)
  {
    uint64_t v8 = __src;
    int64x2_t v7 = *(char **)(a2 + 8);
    do
    {
      uint64_t v9 = *((void *)v8 - 1);
      v8 -= 8;
      *((void *)v7 - 1) = v9;
      v7 -= 8;
    }
    while (v8 != v6);
  }
  *(void *)(a2 + 8) = v7;
  uint64_t v10 = a1[1];
  uint64_t v11 = *(void *)(a2 + 16);
  int64_t v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    int64x2_t v7 = *(char **)(a2 + 8);
  }
  *(void *)(a2 + 16) = v11 + v12;
  float64x2_t v13 = (char *)*a1;
  *a1 = v7;
  *(void *)(a2 + 8) = v13;
  unint64_t v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(void *)(a2 + 16) = v14;
  uint64_t v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(void *)(a2 + 24) = v15;
  *(void *)a2 = *(void *)(a2 + 8);
  return v5;
}

id ARQATraceableDefaultEntryForResultData(void *a1)
{
  id v1 = a1;
  unint64_t v2 = objc_opt_new();
  BOOL v3 = (objc_class *)objc_opt_class();
  uint64_t v4 = NSStringFromClass(v3);
  [v2 setObject:v4 forKeyedSubscript:@"type"];

  uint64_t v5 = NSNumber;
  [v1 timestamp];
  uint64_t v6 = objc_msgSend(v5, "numberWithDouble:");
  [v2 setObject:v6 forKeyedSubscript:@"timestamp"];

  return v2;
}

void sub_1B8945DB8(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;

  _Unwind_Resume(a1);
}

id ARQATraceableDefaultFormatForResultData()
{
  os_log_t v0 = objc_opt_new();
  [v0 setObject:@"Name of this data type" forKeyedSubscript:@"type"];
  [v0 setObject:@"Timestamp in seconds" forKeyedSubscript:@"timestamp"];
  return v0;
}

void sub_1B8945E54(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8945F20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id ARFloat(float a1)
{
  BOOL v3 = [NSNumber numberWithFloat:v1];
  return v3;
}

void sub_1B8946070(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B894619C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8946454(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_1B89466D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89467E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8946894(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89469F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8947210(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89473DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B89474DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B8947710(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89478C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8947D28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_1B8947E5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B8947F78(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1B8948078(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89481E0(_Unwind_Exception *a1)
{
  uint64_t v5 = v3;

  _Unwind_Resume(a1);
}

void sub_1B8948454(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

void sub_1B894907C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  _Unwind_Resume(a1);
}

void sub_1B8949570(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8949864(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, uint64_t a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1B8949994(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B894B65C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20,void *a21,void *a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,void *a27)
{
  _Unwind_Resume(a1);
}

void sub_1B894BD80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B894BE2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B894BFD8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B894C824(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B894CA10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1B894CC84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B894CD58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B894CEBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B894D210(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B894D364(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;

  _Unwind_Resume(a1);
}

void ___ZL13_ARLogGeneralv_block_invoke_8()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "General");
  uint64_t v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObuint64_t j = (uint64_t)v0;
}

__CFString *ARTrackingStateToString(unint64_t a1)
{
  if (a1 > 2) {
    return @"Undefined";
  }
  else {
    return off_1E6186E90[a1];
  }
}

__CFString *ARTrackingStateReasonToString(unint64_t a1)
{
  if (a1 > 4) {
    return @"Undefined";
  }
  else {
    return off_1E6186EA8[a1];
  }
}

void sub_1B894E5BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B894E6C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  unint64_t v17 = *(void **)(v15 - 48);
  if (v17)
  {
    *(void *)(v15 - 40) = v17;
    operator delete(v17);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B894E74C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  uint64_t v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)ARUndistortionMapping;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1B894E994(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1B894EA1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  uint64_t v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)ARImageDistortionCorrectionTechnique;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1B894F7C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37)
{
  _Unwind_Resume(a1);
}

void sub_1B894FBB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B894FE54(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B894FF7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8950120(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8950434(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B895058C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *std::vector<float>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<float>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v4 = (char *)a1[1];
    bzero(v4, 4 * a2);
    a1[1] = &v4[4 * a2];
  }
  return a1;
}

void sub_1B89506B0(_Unwind_Exception *exception_object)
{
  BOOL v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void ___ZL15_ARLogTechniquev_block_invoke_3()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "Technique");
  uint64_t v1 = (void *)_ARLogTechnique(void)::logObj;
  _ARLogTechnique(void)::logObuint64_t j = (uint64_t)v0;
}

id _ARLogTechnique_6()
{
  if (_ARLogTechnique_onceToken_8 != -1) {
    dispatch_once(&_ARLogTechnique_onceToken_8, &__block_literal_global_52);
  }
  os_log_t v0 = (void *)_ARLogTechnique_logObj_8;
  return v0;
}

double ARMatrixFromCVAMatrix(uint64_t a1)
{
  return *(double *)a1;
}

__n128 ARMatrixFromCVAMatrix(uint64_t a1)
{
  return *(__n128 *)a1;
}

void ARCVAMatrixFromMatrix(simd_float4x4 a1@<0:Q0, 16:Q1, 32:Q2, 48:Q3>, simd_float4x4 *a2@<X8>)
{
  *a2 = a1;
}

__n128 ARCVAMatrixFromMatrix@<Q0>(simd_float3x3 a1@<0:Q0, 16:Q1, 32:Q2>, uint64_t a2@<X8>)
{
  a1.columns[0].i32[3] = a1.columns[1].i32[0];
  *(simd_float3 *)a2 = a1.columns[0];
  *(int8x16_t *)(a2 + 16) = vextq_s8(vextq_s8((int8x16_t)a1.columns[1], (int8x16_t)a1.columns[1], 0xCuLL), (int8x16_t)a1.columns[2], 8uLL);
  *(_DWORD *)(a2 + 32) = a1.columns[2].i32[2];
  return (__n128)a1.columns[0];
}

void sub_1B8952438(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8952554(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)ARFaceTrackingManager;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1B8952B10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, uint64_t a12, void *a13, uint64_t a14, void *a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,id a42)
{
  _Block_object_dispose(&a37, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__2(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__2(uint64_t a1)
{
}

void sub_1B8952F5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8953410(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _Unwind_Exception *exception_object, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1B89536EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_1B89539E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, void *a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_1B8953B30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL13_ARLogGeneralv_block_invoke_9()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "General");
  uint64_t v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObuint64_t j = (uint64_t)v0;
}

void ___ZL15_ARLogTechniquev_block_invoke_4()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "Technique");
  uint64_t v1 = (void *)_ARLogTechnique(void)::logObj;
  _ARLogTechnique(void)::logObuint64_t j = (uint64_t)v0;
}

ARPlaneAnchor *ARCreatePlaneAnchorFromCV3DPlane(const CV3DPlaneDetectionPlane *a1, NSUUID *a2, simd_float4x4 a3, simd_float4x4 a4, char a5, int a6, __int16 a7)
{
  float32x4_t v65 = (float32x4_t)a4.columns[2];
  float32x4_t v68 = (float32x4_t)a4.columns[3];
  float32x4_t v71 = (float32x4_t)a4.columns[1];
  float32x4_t v74 = (float32x4_t)a4.columns[0];
  CV3DPlaneDetectionPlaneTransformationToWorld();
  uint64_t v12 = 0;
  v77.columns[0] = v13;
  v77.columns[1] = v14;
  v77.columns[2] = v15;
  v77.columns[3] = v16;
  do
  {
    v78.columns[v12] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v74, COERCE_FLOAT(*(_OWORD *)&v77.columns[v12])), v71, *(float32x2_t *)v77.columns[v12].f32, 1), v65, (float32x4_t)v77.columns[v12], 2), v68, (float32x4_t)v77.columns[v12], 3);
    ++v12;
  }
  while (v12 != 4);
  float32x4_t v69 = (float32x4_t)v78.columns[1];
  float32x4_t v72 = (float32x4_t)v78.columns[0];
  float32x4_t v64 = (float32x4_t)v78.columns[3];
  float32x4_t v66 = (float32x4_t)v78.columns[2];
  int v17 = CV3DPlaneDetectionPlaneExtentOrientedBoundingBox();
  int Orientation = CV3DPlaneDetectionPlaneGetOrientation();
  int v19 = *MEMORY[0x1E4F94888];
  float v20 = 0.0;
  if (Orientation == v19 && v17 != 0)
  {
    v78.columns[0] = v77.columns[0];
    v78.columns[1] = v77.columns[1];
    {
      pivotForOrientedBox(simd_float4x2)::k_cos45 = 1060439283;
    }
    uint64_t v22 = 0;
    float v23 = *(float *)&pivotForOrientedBox(simd_float4x2)::k_cos45;
    do
    {
      uint64_t v24 = v22 + 1;
      float32x2_t v25 = vsub_f32(*(float32x2_t *)&v78.columns[0].f32[2 * v22], *(float32x2_t *)&v78.columns[0].f32[2 * ((v22 + 1) & 3)]);
      int32x2_t v26 = (int32x2_t)vmul_f32(v25, v25);
      *(float *)v26.i32 = sqrtf(vmlas_n_f32(*(float *)&v26.i32[1], v25.f32[0], v25.f32[0]));
      float32x2_t v27 = vdiv_f32(v25, (float32x2_t)vdup_lane_s32(v26, 0));
      if (v27.f32[0] >= v23)
      {
        float v76 = v27.f32[1];
        float v28 = acosf(fminf(fmaxf(v27.f32[0], -1.0), 1.0));
        if (v76 >= 0.0) {
          float v20 = v28;
        }
        else {
          float v20 = -v28;
        }
      }
      uint64_t v22 = v24;
    }
    while (v24 != 4);
  }
  if (a6)
  {
    __float2 v29 = __sincosf_stret(v20 * 0.5);
    float32x4_t v30 = vmulq_n_f32((float32x4_t)xmmword_1B8A2B270, v29.__sinval);
    v30.i32[3] = LODWORD(v29.__cosval);
    *(double *)v31.i64 = simd_matrix4x4(v30);
    uint64_t v32 = 0;
    v77.columns[0] = v31;
    v77.columns[1] = v33;
    v77.columns[2] = v34;
    v77.columns[3] = v35;
    do
    {
      v78.columns[v32] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v72, COERCE_FLOAT(*(_OWORD *)&v77.columns[v32])), v69, *(float32x2_t *)v77.columns[v32].f32, 1), v66, (float32x4_t)v77.columns[v32], 2), v64, (float32x4_t)v77.columns[v32], 3);
      ++v32;
    }
    while (v32 != 4);
    float32x4_t v69 = (float32x4_t)v78.columns[1];
    float32x4_t v72 = (float32x4_t)v78.columns[0];
    float32x4_t v64 = (float32x4_t)v78.columns[3];
    float32x4_t v66 = (float32x4_t)v78.columns[2];
  }
  simd_float4x4 v80 = __invert_f4(*(simd_float4x4 *)_PromotedConst_2);
  uint64_t v36 = 0;
  simd_float4x4 v77 = v80;
  do
  {
    v78.columns[v36] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v72, COERCE_FLOAT(*(_OWORD *)&v77.columns[v36])), v69, *(float32x2_t *)v77.columns[v36].f32, 1), v66, (float32x4_t)v77.columns[v36], 2), v64, (float32x4_t)v77.columns[v36], 3);
    ++v36;
  }
  while (v36 != 4);
  uint64_t v37 = 0;
  __n128 v61 = (__n128)v78.columns[1];
  __n128 v62 = (__n128)v78.columns[0];
  simd_float4x4 v77 = v78;
  __n128 v60 = (__n128)v78.columns[2];
  do
  {
    v78.columns[v37] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)a3.columns[0], COERCE_FLOAT(*(_OWORD *)&v77.columns[v37])), (float32x4_t)a3.columns[1], *(float32x2_t *)v77.columns[v37].f32, 1), (float32x4_t)a3.columns[2], (float32x4_t)v77.columns[v37], 2), (float32x4_t)a3.columns[3], (float32x4_t)v77.columns[v37], 3);
    ++v37;
  }
  while (v37 != 4);
  float32x4_t v73 = (float32x4_t)v78.columns[1];
  float32x4_t v75 = (float32x4_t)v78.columns[0];
  float32x4_t v67 = (float32x4_t)v78.columns[3];
  float32x4_t v70 = (float32x4_t)v78.columns[2];
  int v38 = CV3DPlaneDetectionPlaneGetOrientation();
  BOOL v39 = v38 != v19;
  if (v38 != v19 || (a7 & 0x100) != 0) {
    goto LABEL_24;
  }
  simd_float4x4 v81 = __invert_f4(a3);
  double v50 = AREulerAnglesFromMatrix((__n128)v81.columns[0], (__n128)v81.columns[1], (__n128)v81.columns[2]);
  double v51 = *((float *)&v50 + 1);
  if (v51 > 2.35619449) {
    goto LABEL_31;
  }
  if (v51 <= 0.785398163)
  {
    if (v51 < -2.35619449)
    {
LABEL_31:
      uint64_t v40 = 180;
      goto LABEL_34;
    }
    if (v51 >= -0.785398163)
    {
LABEL_24:
      uint64_t v40 = 0;
      goto LABEL_25;
    }
    uint64_t v40 = -90;
  }
  else
  {
    uint64_t v40 = 90;
  }
LABEL_34:
  float v52 = (double)v40 * 3.14159265 / 180.0;
  __float2 v53 = __sincosf_stret(v52 * 0.5);
  float32x4_t v54 = vmulq_n_f32((float32x4_t)xmmword_1B8A2B0D0, v53.__sinval);
  v54.i32[3] = LODWORD(v53.__cosval);
  *(double *)v55.i64 = simd_matrix4x4(v54);
  uint64_t v56 = 0;
  v77.columns[0] = v55;
  v77.columns[1] = v57;
  v77.columns[2] = v58;
  v77.columns[3] = v59;
  do
  {
    v78.columns[v56] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v75, COERCE_FLOAT(*(_OWORD *)&v77.columns[v56])), v73, *(float32x2_t *)v77.columns[v56].f32, 1), v70, (float32x4_t)v77.columns[v56], 2), v67, (float32x4_t)v77.columns[v56], 3);
    ++v56;
  }
  while (v56 != 4);
  v73.i64[0] = v78.columns[1].i64[0];
  v75.i64[0] = v78.columns[0].i64[0];
  v67.i64[0] = v78.columns[3].i64[0];
  v70.i64[0] = v78.columns[2].i64[0];
LABEL_25:
  long long v41 = -[ARPlaneAnchor initWithIdentifier:transform:alignment:]([ARPlaneAnchor alloc], "initWithIdentifier:transform:alignment:", a2, v39, *(double *)v75.i64, *(double *)v73.i64, *(double *)v70.i64, *(double *)v67.i64);
  [(ARPlaneAnchor *)v41 setWorldAlignmentRotation:v40];
  CV3DPlaneDetectionPlaneUncertaintyAlongNormal();
  *(float *)&double v42 = v42;
  [(ARPlaneAnchor *)v41 setUncertaintyAlongNormal:v42];
  _updateExtentsForPlaneAnchor(v41, a1, v20, a6, (a7 & 0x200) != 0);
  uint64_t v43 = objc_opt_new();
  unsigned int v44 = semanticsLabelForPlane((uint64_t)a1, v43);
  setSemanticsFromCV3D(v44, v43, a5, v41);
  if ([(ARPlaneAnchor *)v41 alignment] == ARPlaneAnchorAlignmentHorizontal)
  {
    double v46 = AREulerAnglesFromMatrix(v62, v61, v60);
    *(float *)&double v46 = *((float *)&v46 + 1) * 0.318309886 * 180.0;
    double v45 = *(float *)&v46;
  }
  [(NSUUID *)a2 ar_integerValue];
  long long v47 = [(ARPlaneAnchor *)v41 planeExtent];
  [v47 width];
  long long v48 = [(ARPlaneAnchor *)v41 planeExtent];
  [v48 height];
  kdebug_trace();

  return v41;
}

void sub_1B895562C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void _updateExtentsForPlaneAnchor(ARPlaneAnchor *a1, const CV3DPlaneDetectionPlane *a2, float a3, int a4, int a5)
{
  v205 = a1;
  uint64_t v7 = [(ARPlaneAnchor *)v205 worldAlignmentRotation];
  if (CV3DPlaneDetectionPlaneExtentOrientedBoundingBox()
    && CV3DPlaneDetectionPlaneGetOrientation() == *MEMORY[0x1E4F94888])
  {
    CV3DPlaneDetectionPlaneExtentOrientedBoundingBox();
    __float2 v8 = __sincosf_stret(a3 * -0.5);
    float32x4_t v9 = vmulq_n_f32((float32x4_t)xmmword_1B8A2B270, v8.__sinval);
    v9.i32[3] = LODWORD(v8.__cosval);
    *(double *)v10.i64 = simd_matrix4x4(v9);
    uint64_t v14 = 0;
    float32x2_t v15 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
    float32x2_t v16 = (float32x2_t)0x80000000800000;
    do
    {
      float32x2_t v17 = vadd_f32(v13, (float32x2_t)*(_OWORD *)&vmlaq_f32(vmlaq_lane_f32(vmulq_n_f32(v10, COERCE_FLOAT(v220[v14])), v11, (float32x2_t)v220[v14], 1), (float32x4_t)0, v12));
      float32x2_t v15 = vminnm_f32(v15, v17);
      float32x2_t v16 = vmaxnm_f32(v16, v17);
      ++v14;
    }
    while (v14 != 4);
    *(float32x2_t *)v11.f32 = vsub_f32(v16, v15);
    v11.i32[2] = v11.i32[1];
    float32x4_t v18 = 0uLL;
    int8x16_t v204 = vextq_s8((int8x16_t)vzip1q_s32((int32x4_t)v11, (int32x4_t)0), (int8x16_t)v11, 8uLL);
    if (v7)
    {
      float32x4_t v215 = v11;
      float v19 = (double)-v7 * 3.14159265 / 180.0;
      __float2 v20 = __sincosf_stret(v19 * 0.5);
      float32x4_t v21 = vmulq_n_f32((float32x4_t)xmmword_1B8A2B0D0, v20.__sinval);
      v21.i32[3] = LODWORD(v20.__cosval);
      *(double *)v22.i64 = simd_matrix4x4(v21);
      uint64_t v26 = 0;
      long long v222 = xmmword_1B8A2B0E0;
      long long v223 = xmmword_1B8A2B3D0;
      long long v224 = xmmword_1B8A2B0D0;
      long long v225 = xmmword_1B8A2B050;
      do
      {
        *(long long *)((char *)&v226 + v26) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v22, COERCE_FLOAT(*(long long *)((char *)&v222 + v26))), v23, *(float32x2_t *)((char *)&v222 + v26), 1), v24, *(float32x4_t *)((char *)&v222 + v26), 2), v25, *(float32x4_t *)((char *)&v222 + v26), 3);
        v26 += 16;
      }
      while (v26 != 64);
      float32x4_t v28 = (float32x4_t)v226;
      float32x4_t v27 = v227;
      float32x4_t v30 = v228;
      float32x4_t v29 = v229;
      if (v7 == 90 || v7 == -90)
      {
        int8x16_t v31 = (int8x16_t)v215;
        v31.i32[1] = 0;
        int8x16_t v204 = v31;
      }
      float32x4_t v18 = 0uLL;
    }
    else
    {
      float32x4_t v29 = (float32x4_t)xmmword_1B8A2B050;
      float32x4_t v30 = (float32x4_t)xmmword_1B8A2B0D0;
      float32x4_t v27 = (float32x4_t)xmmword_1B8A2B3D0;
      float32x4_t v28 = (float32x4_t)xmmword_1B8A2B0E0;
    }
    float32x2_t v38 = vadd_f32(v15, v16);
    float32x4_t v37 = vaddq_f32(v29, vmlaq_f32(vmlaq_n_f32(vmulq_n_f32(v28, 0.5 * v38.f32[0]), v27, vmuls_lane_f32(0.5, v38, 1)), v18, v30));
  }
  else
  {
    CV3DPlaneDetectionPlaneExtentAlignedBoundingBox();
    uint64_t v32 = CV3DPlaneDetectionAlignedBoundingBoxMin();
    simd_float4 v33 = (float *)CV3DPlaneDetectionAlignedBoundingBoxMax();
    float v34 = v33[1];
    v35.i32[0] = *(_DWORD *)(v32 + 4);
    float v36 = (float)(v34 + *(float *)v35.i32) * 0.5;
    v35.i64[0] = v35.u32[0];
    v35.i32[3] = 0;
    *(float *)v35.i32 = v34 - *(float *)v35.i32;
    *(float *)&v35.i32[2] = *v33 - *(float *)v32;
    int8x16_t v204 = v35;
    float32x4_t v37 = vaddq_f32(vaddq_f32(vmlaq_n_f32(vmulq_n_f32((float32x4_t)xmmword_1B8A2B0E0, (float)(*v33 + *(float *)v32) * 0.5), (float32x4_t)xmmword_1B8A2B3D0, v36), (float32x4_t)0), (float32x4_t)xmmword_1B8A2B050);
  }
  float32x4_t v203 = vdivq_f32(v37, (float32x4_t)vdupq_laneq_s32((int32x4_t)v37, 3));
  if (a4)
  {
    [(ARPlaneAnchor *)v205 setCenter:*(double *)v203.i64];
    BOOL v39 = [(ARPlaneAnchor *)v205 planeExtent];
    [v39 setRotationOnYAxis:0.0];
  }
  else
  {
    __float2 v40 = __sincosf_stret(a3 * 0.5);
    float32x4_t v41 = vmulq_n_f32((float32x4_t)xmmword_1B8A2B0D0, v40.__sinval);
    v41.i32[3] = LODWORD(v40.__cosval);
    *(double *)v42.i64 = simd_matrix4x4(v41);
    float32x4_t v46 = vaddq_f32(v45, vmlaq_laneq_f32(vmlaq_f32(vmulq_n_f32(v42, v203.f32[0]), (float32x4_t)0, v43), v44, v203, 2));
    [(ARPlaneAnchor *)v205 setCenter:COERCE_DOUBLE((unint64_t)vdivq_f32(v46, (float32x4_t)vdupq_laneq_s32((int32x4_t)v46, 3)).u32[0])];
    BOOL v39 = [(ARPlaneAnchor *)v205 planeExtent];
    *(float *)&double v47 = a3;
    [v39 setRotationOnYAxis:v47];
  }

  [(ARPlaneAnchor *)v205 setExtent:*(double *)v204.i64];
  long long v48 = [(ARPlaneAnchor *)v205 planeExtent];
  [v48 setWidth:*(double *)v204.i64];

  long long v49 = [(ARPlaneAnchor *)v205 planeExtent];
  objc_msgSend(v49, "setHeight:", COERCE_DOUBLE(__PAIR64__(v204.u32[1], v204.u32[2])));

  if (!a4) {
    a3 = 0.0;
  }
  double v50 = [(ARAnchor *)v205 identifier];
  objc_msgSend(v50, "ar_integerValue");
  kdebug_trace();

  uint64_t v51 = [(ARPlaneAnchor *)v205 worldAlignmentRotation];
  __float2 v52 = __sincosf_stret(a3 * -0.5);
  float32x4_t v53 = vmulq_n_f32((float32x4_t)xmmword_1B8A2B270, v52.__sinval);
  v53.i32[3] = LODWORD(v52.__cosval);
  *(double *)&long long v54 = simd_matrix4x4(v53);
  uint64_t v55 = 0;
  long long v194 = v56;
  long long v196 = v54;
  long long v222 = v54;
  long long v223 = v56;
  long long v198 = v58;
  long long v200 = v57;
  long long v224 = v57;
  long long v225 = v58;
  do
  {
    *(long long *)((char *)&v226 + v55) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B8A2B0E0, COERCE_FLOAT(*(long long *)((char *)&v222 + v55))), (float32x4_t)xmmword_1B8A2B3D0, *(float32x2_t *)((char *)&v222 + v55), 1), (float32x4_t)xmmword_1B8A2B0D0, *(float32x4_t *)((char *)&v222 + v55), 2), (float32x4_t)xmmword_1B8A2B050, *(float32x4_t *)((char *)&v222 + v55), 3);
    v55 += 16;
  }
  while (v55 != 64);
  float32x4_t v213 = v229;
  float32x4_t v216 = v228;
  float32x4_t v209 = v227;
  float32x4_t v211 = (float32x4_t)v226;
  if (v51)
  {
    float v59 = (double)-v51 * 3.14159265 / 180.0;
    __float2 v60 = __sincosf_stret(v59 * 0.5);
    float32x4_t v61 = vmulq_n_f32((float32x4_t)xmmword_1B8A2B0D0, v60.__sinval);
    v61.i32[3] = LODWORD(v60.__cosval);
    *(double *)v62.i64 = simd_matrix4x4(v61);
    uint64_t v66 = 0;
    long long v222 = (__int128)v211;
    long long v223 = (__int128)v209;
    long long v224 = (__int128)v216;
    long long v225 = (__int128)v213;
    do
    {
      *(long long *)((char *)&v226 + v66) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v62, COERCE_FLOAT(*(long long *)((char *)&v222 + v66))), v63, *(float32x2_t *)((char *)&v222 + v66), 1), v64, *(float32x4_t *)((char *)&v222 + v66), 2), v65, *(float32x4_t *)((char *)&v222 + v66), 3);
      v66 += 16;
    }
    while (v66 != 64);
    float32x4_t v209 = v227;
    float32x4_t v211 = (float32x4_t)v226;
    float32x4_t v213 = v229;
    float32x4_t v216 = v228;
  }
  long long v226 = 0uLL;
  v227.i64[0] = 0;
  long long v222 = 0uLL;
  *(void *)&long long v223 = 0;
  if (CV3DPlaneDetectionPlaneExtentPolygons())
  {
    if (CV3DPlaneDetectionPlaneCreateTriangulatedPolygons())
    {
      v220[0] = 0;
      VerticesCFIndex Count = CV3DReconMeshGetVerticesCount();
      uint64_t VerticesRawPtr = CV3DReconMeshGetVerticesRawPtr();
      if (VerticesCount - 1 <= 0xFFFE)
      {
        uint64_t v69 = VerticesRawPtr;
        if (VerticesRawPtr)
        {
          _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE7reserveEm((void **)&v226, VerticesCount);
          uint64_t v70 = 0;
          float32x4_t v71 = (float32x4_t *)*((void *)&v226 + 1);
          do
          {
            float32x4_t v72 = vaddq_f32(v213, vmlaq_f32(vmlaq_n_f32(vmulq_n_f32(v211, *(float *)(v69 + 12 * v70)), v209, *(float *)(v69 + 12 * v70 + 4)), (float32x4_t)0, v216));
            float32x4_t v73 = vdivq_f32(v72, (float32x4_t)vdupq_laneq_s32((int32x4_t)v72, 3));
            if ((unint64_t)v71 >= v227.i64[0])
            {
              float32x4_t v206 = v73;
              uint64_t v74 = (uint64_t)((uint64_t)v71 - v226) >> 4;
              if ((unint64_t)(v74 + 1) >> 60) {
                std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
              }
              unint64_t v75 = (uint64_t)(v227.i64[0] - v226) >> 3;
              if (v75 <= v74 + 1) {
                unint64_t v75 = v74 + 1;
              }
              if (v227.i64[0] - (uint64_t)v226 >= 0x7FFFFFFFFFFFFFF0uLL) {
                unint64_t v76 = 0xFFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v76 = v75;
              }
              if (v76) {
                simd_float4x4 v77 = (char *)_ZNSt3__119__allocate_at_leastB8ne180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m((uint64_t)&v227, v76);
              }
              else {
                simd_float4x4 v77 = 0;
              }
              simd_float4x4 v78 = (float32x4_t *)&v77[16 * v74];
              *simd_float4x4 v78 = v206;
              float32x4_t v71 = v78 + 1;
              unint64_t v79 = (float32x4_t *)*((void *)&v226 + 1);
              simd_float4x4 v80 = (char *)v226;
              if (*((void *)&v226 + 1) != (void)v226)
              {
                do
                {
                  float32x4_t v81 = v79[-1];
                  --v79;
                  v78[-1] = v81;
                  --v78;
                }
                while (v79 != (float32x4_t *)v80);
                unint64_t v79 = (float32x4_t *)v226;
              }
              *(void *)&long long v226 = v78;
              *((void *)&v226 + 1) = v71;
              v227.i64[0] = (uint64_t)&v77[16 * v76];
              if (v79) {
                operator delete(v79);
              }
            }
            else
            {
              *v71++ = v73;
            }
            *((void *)&v226 + 1) = v71;
            ++v70;
          }
          while (v70 != VerticesCount);
        }
      }
      FacesCFIndex Count = CV3DReconMeshGetFacesCount();
      uint64_t FacesRawPtr = CV3DReconMeshGetFacesRawPtr();
      if (*((void *)&v226 + 1) - (void)v226 >= 0x21uLL)
      {
        if (FacesCount)
        {
          uint64_t v84 = FacesRawPtr;
          if (FacesRawPtr)
          {
            std::vector<short>::reserve((void **)&v222, 3 * FacesCount);
            uint64_t v85 = 0;
            unint64_t v86 = (_WORD *)*((void *)&v222 + 1);
            do
            {
              unint64_t v87 = (int *)(v84 + 12 * v85);
              int v88 = *v87;
              uint64_t v89 = (char *)v223;
              if ((unint64_t)v86 >= (unint64_t)v223)
              {
                v91 = (_WORD *)v222;
                uint64_t v92 = (uint64_t)v86 - v222;
                if ((uint64_t)((uint64_t)v86 - v222) < -2) {
                  goto LABEL_206;
                }
                uint64_t v93 = v92 >> 1;
                if ((void)v223 - (void)v222 <= (unint64_t)((v92 >> 1) + 1)) {
                  uint64_t v94 = v93 + 1;
                }
                else {
                  uint64_t v94 = v223 - v222;
                }
                if ((void)v223 - (void)v222 >= 0x7FFFFFFFFFFFFFFEuLL) {
                  uint64_t v95 = 0x7FFFFFFFFFFFFFFFLL;
                }
                else {
                  uint64_t v95 = v94;
                }
                if (v95)
                {
                  long long v96 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<short>>((uint64_t)&v223, v95);
                  unint64_t v86 = (_WORD *)*((void *)&v222 + 1);
                  v91 = (_WORD *)v222;
                }
                else
                {
                  long long v96 = 0;
                }
                int v97 = &v96[2 * v93];
                *(_WORD *)int v97 = v88;
                uint64_t v90 = v97 + 2;
                while (v86 != v91)
                {
                  __int16 v98 = *--v86;
                  *((_WORD *)v97 - 1) = v98;
                  v97 -= 2;
                }
                uint64_t v89 = &v96[2 * v95];
                *(void *)&long long v222 = v97;
                *((void *)&v222 + 1) = v90;
                *(void *)&long long v223 = v89;
                if (v91)
                {
                  operator delete(v91);
                  uint64_t v89 = (char *)v223;
                }
              }
              else
              {
                *unint64_t v86 = v88;
                uint64_t v90 = (char *)(v86 + 1);
              }
              *((void *)&v222 + 1) = v90;
              int v99 = v87[1];
              if (v90 >= v89)
              {
                float v101 = (char *)v222;
                uint64_t v102 = (uint64_t)&v90[-v222];
                if ((uint64_t)&v90[-v222] < -2) {
                  goto LABEL_206;
                }
                uint64_t v103 = v102 >> 1;
                unint64_t v104 = (unint64_t)&v89[-v222];
                if (v104 <= (v102 >> 1) + 1) {
                  unint64_t v105 = v103 + 1;
                }
                else {
                  unint64_t v105 = v104;
                }
                if (v104 >= 0x7FFFFFFFFFFFFFFELL) {
                  uint64_t v106 = 0x7FFFFFFFFFFFFFFFLL;
                }
                else {
                  uint64_t v106 = v105;
                }
                if (v106)
                {
                  v107 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<short>>((uint64_t)&v223, v106);
                  uint64_t v90 = (char *)*((void *)&v222 + 1);
                  float v101 = (char *)v222;
                }
                else
                {
                  v107 = 0;
                }
                v108 = &v107[2 * v103];
                *(_WORD *)v108 = v99;
                long long v100 = v108 + 2;
                while (v90 != v101)
                {
                  __int16 v109 = *((_WORD *)v90 - 1);
                  v90 -= 2;
                  *((_WORD *)v108 - 1) = v109;
                  v108 -= 2;
                }
                uint64_t v89 = &v107[2 * v106];
                *(void *)&long long v222 = v108;
                *((void *)&v222 + 1) = v100;
                *(void *)&long long v223 = v89;
                if (v101)
                {
                  operator delete(v101);
                  uint64_t v89 = (char *)v223;
                }
              }
              else
              {
                *(_WORD *)uint64_t v90 = v99;
                long long v100 = v90 + 2;
              }
              *((void *)&v222 + 1) = v100;
              int v110 = v87[2];
              if (v100 >= v89)
              {
                uint64_t v111 = (char *)v222;
                uint64_t v112 = (uint64_t)&v100[-v222];
                if ((uint64_t)&v100[-v222] <= -3) {
LABEL_206:
                }
                  std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
                uint64_t v113 = v112 >> 1;
                unint64_t v114 = (unint64_t)&v89[-v222];
                if (v114 <= (v112 >> 1) + 1) {
                  unint64_t v115 = v113 + 1;
                }
                else {
                  unint64_t v115 = v114;
                }
                if (v114 >= 0x7FFFFFFFFFFFFFFELL) {
                  uint64_t v116 = 0x7FFFFFFFFFFFFFFFLL;
                }
                else {
                  uint64_t v116 = v115;
                }
                if (v116)
                {
                  char v117 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<short>>((uint64_t)&v223, v116);
                  long long v100 = (char *)*((void *)&v222 + 1);
                  uint64_t v111 = (char *)v222;
                }
                else
                {
                  char v117 = 0;
                }
                char v118 = &v117[2 * v113];
                *(_WORD *)char v118 = v110;
                unint64_t v86 = v118 + 2;
                while (v100 != v111)
                {
                  __int16 v119 = *((_WORD *)v100 - 1);
                  v100 -= 2;
                  *((_WORD *)v118 - 1) = v119;
                  v118 -= 2;
                }
                *(void *)&long long v222 = v118;
                *((void *)&v222 + 1) = v86;
                *(void *)&long long v223 = &v117[2 * v116];
                if (v111) {
                  operator delete(v111);
                }
              }
              else
              {
                *(_WORD *)long long v100 = v110;
                unint64_t v86 = v100 + 2;
              }
              *((void *)&v222 + 1) = v86;
              ++v85;
            }
            while (v85 != FacesCount);
          }
        }
      }
      CV3DReconMeshRelease();
    }
    else
    {
      uint64_t v134 = CV3DPlaneDetectionPolygonListLength();
      if (v134)
      {
        uint64_t v135 = 0;
        unint64_t v136 = 0;
        do
        {
          CV3DPlaneDetectionPolygonAtIndex();
          v136 += CV3DPlaneDetectionPolygonPointsNum();
          ++v135;
        }
        while (v134 != v135);
      }
      else
      {
        unint64_t v136 = 0;
      }
      _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE7reserveEm((void **)&v226, v136);
      if (v134)
      {
        for (uint64_t i = 0; i != v134; ++i)
        {
          CV3DPlaneDetectionPolygonAtIndex();
          uint64_t v138 = CV3DPlaneDetectionPolygonPointsNum();
          uint64_t v139 = CV3DPlaneDetectionPolygonPointsRawPtr();
          if (v138)
          {
            uint64_t v140 = v139;
            uint64_t v141 = 0;
            uint64_t v142 = (float32x4_t *)*((void *)&v226 + 1);
            do
            {
              float32x4_t v143 = vaddq_f32(v213, vmlaq_f32(vmlaq_n_f32(vmulq_n_f32(v211, *(float *)(v140 + 8 * v141)), v209, *(float *)(v140 + 8 * v141 + 4)), (float32x4_t)0, v216));
              float32x4_t v144 = vdivq_f32(v143, (float32x4_t)vdupq_laneq_s32((int32x4_t)v143, 3));
              if ((unint64_t)v142 >= v227.i64[0])
              {
                float32x4_t v208 = v144;
                uint64_t v145 = (uint64_t)((uint64_t)v142 - v226) >> 4;
                if ((unint64_t)(v145 + 1) >> 60) {
                  std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
                }
                unint64_t v146 = (uint64_t)(v227.i64[0] - v226) >> 3;
                if (v146 <= v145 + 1) {
                  unint64_t v146 = v145 + 1;
                }
                if (v227.i64[0] - (uint64_t)v226 >= 0x7FFFFFFFFFFFFFF0uLL) {
                  unint64_t v147 = 0xFFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v147 = v146;
                }
                if (v147) {
                  uint64_t v148 = (char *)_ZNSt3__119__allocate_at_leastB8ne180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m((uint64_t)&v227, v147);
                }
                else {
                  uint64_t v148 = 0;
                }
                v149 = (float32x4_t *)&v148[16 * v145];
                float32x4_t *v149 = v208;
                uint64_t v142 = v149 + 1;
                int v150 = (float32x4_t *)*((void *)&v226 + 1);
                v151 = (char *)v226;
                if (*((void *)&v226 + 1) != (void)v226)
                {
                  do
                  {
                    float32x4_t v152 = v150[-1];
                    --v150;
                    v149[-1] = v152;
                    --v149;
                  }
                  while (v150 != (float32x4_t *)v151);
                  int v150 = (float32x4_t *)v226;
                }
                *(void *)&long long v226 = v149;
                *((void *)&v226 + 1) = v142;
                v227.i64[0] = (uint64_t)&v148[16 * v147];
                if (v150) {
                  operator delete(v150);
                }
              }
              else
              {
                *v142++ = v144;
              }
              *((void *)&v226 + 1) = v142;
              ++v141;
            }
            while (v141 != v138);
          }
        }
      }
    }
  }
  else
  {
    if (!CV3DPlaneDetectionPlaneConvexHull2D())
    {
LABEL_154:
      v154 = 0;
      goto LABEL_161;
    }
    uint64_t v120 = CV3DPlaneDetectionConvexHullPointsRawPtr();
    unint64_t v121 = CV3DPlaneDetectionConvexHullPointsNum();
    _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE7reserveEm((void **)&v226, v121);
    if (v121)
    {
      uint64_t v122 = 0;
      v123 = (float32x4_t *)*((void *)&v226 + 1);
      do
      {
        float32x4_t v124 = vaddq_f32(v213, vmlaq_f32(vmlaq_n_f32(vmulq_n_f32(v211, *(float *)(v120 + 8 * v122)), v209, *(float *)(v120 + 8 * v122 + 4)), (float32x4_t)0, v216));
        float32x4_t v125 = vdivq_f32(v124, (float32x4_t)vdupq_laneq_s32((int32x4_t)v124, 3));
        if ((unint64_t)v123 >= v227.i64[0])
        {
          float32x4_t v207 = v125;
          uint64_t v126 = (uint64_t)((uint64_t)v123 - v226) >> 4;
          if ((unint64_t)(v126 + 1) >> 60) {
            std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v127 = (uint64_t)(v227.i64[0] - v226) >> 3;
          if (v127 <= v126 + 1) {
            unint64_t v127 = v126 + 1;
          }
          if (v227.i64[0] - (uint64_t)v226 >= 0x7FFFFFFFFFFFFFF0uLL) {
            unint64_t v128 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v128 = v127;
          }
          if (v128) {
            uint64_t v129 = (char *)_ZNSt3__119__allocate_at_leastB8ne180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m((uint64_t)&v227, v128);
          }
          else {
            uint64_t v129 = 0;
          }
          v130 = (float32x4_t *)&v129[16 * v126];
          float32x4_t *v130 = v207;
          v123 = v130 + 1;
          v131 = (float32x4_t *)*((void *)&v226 + 1);
          v132 = (char *)v226;
          if (*((void *)&v226 + 1) != (void)v226)
          {
            do
            {
              float32x4_t v133 = v131[-1];
              --v131;
              v130[-1] = v133;
              --v130;
            }
            while (v131 != (float32x4_t *)v132);
            v131 = (float32x4_t *)v226;
          }
          *(void *)&long long v226 = v130;
          *((void *)&v226 + 1) = v123;
          v227.i64[0] = (uint64_t)&v129[16 * v128];
          if (v131) {
            operator delete(v131);
          }
        }
        else
        {
          *v123++ = v125;
        }
        *((void *)&v226 + 1) = v123;
        ++v122;
      }
      while (v122 != v121);
    }
  }
  uint64_t v153 = *((void *)&v226 + 1) - v226;
  if (*((void *)&v226 + 1) - (void)v226 < 0x30uLL) {
    goto LABEL_154;
  }
  if ((void)v222 == *((void *)&v222 + 1))
  {
    v154 = [[ARPlaneGeometry alloc] initWithBoundaryVertices:&v226 center:*(double *)v203.i64 extent:*(double *)v204.i64];
  }
  else
  {
    uint64_t v155 = [ARPlaneGeometry alloc];
    *(_OWORD *)v220 = v226;
    uint64_t v221 = v227.i64[0];
    v227.i64[0] = 0;
    long long v226 = 0uLL;
    *(_OWORD *)__p = v222;
    uint64_t v219 = v223;
    long long v222 = 0uLL;
    *(void *)&long long v223 = 0;
    v154 = [(ARPlaneGeometry *)v155 initWithVertices:v220 triangleIndices:__p boundaryVertexCount:v153 >> 4 center:*(double *)v203.i64 extent:*(double *)v204.i64];
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    if (v220[0])
    {
      v220[1] = v220[0];
      operator delete(v220[0]);
    }
  }
LABEL_161:
  if ((void)v222)
  {
    *((void *)&v222 + 1) = v222;
    operator delete((void *)v222);
  }
  if ((void)v226)
  {
    *((void *)&v226 + 1) = v226;
    operator delete((void *)v226);
  }
  -[ARPlaneAnchor setGeometry:](v205, "setGeometry:", v154, v194, v196, v198, v200);
  v156 = [(ARAnchor *)v205 identifier];
  objc_msgSend(v156, "ar_integerValue");
  [(ARPlaneGeometry *)v154 vertexCount];
  [(ARPlaneGeometry *)v154 triangleCount];
  kdebug_trace();

  if (a5)
  {
    uint64_t v157 = [(ARPlaneAnchor *)v205 worldAlignmentRotation];
    unint64_t v158 = CV3DPlaneDetectionExtentGridLength();
    if (v158)
    {
      uint64_t v159 = 0;
      long long v222 = v197;
      long long v223 = v195;
      long long v224 = v201;
      long long v225 = v199;
      do
      {
        *(long long *)((char *)&v226 + v159) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B8A2B0E0, COERCE_FLOAT(*(long long *)((char *)&v222 + v159))), (float32x4_t)xmmword_1B8A2B3D0, *(float32x2_t *)((char *)&v222 + v159), 1), (float32x4_t)xmmword_1B8A2B0D0, *(float32x4_t *)((char *)&v222 + v159), 2), (float32x4_t)xmmword_1B8A2B050, *(float32x4_t *)((char *)&v222 + v159), 3);
        v159 += 16;
      }
      while (v159 != 64);
      float32x4_t v214 = v229;
      float32x4_t v217 = v228;
      float32x4_t v210 = v227;
      float32x4_t v212 = (float32x4_t)v226;
      if (v157)
      {
        float v160 = (double)-v157 * 3.14159265 / 180.0;
        __float2 v161 = __sincosf_stret(v160 * 0.5);
        float32x4_t v162 = vmulq_n_f32((float32x4_t)xmmword_1B8A2B0D0, v161.__sinval);
        v162.i32[3] = LODWORD(v161.__cosval);
        *(double *)v163.i64 = simd_matrix4x4(v162);
        uint64_t v167 = 0;
        long long v222 = (__int128)v212;
        long long v223 = (__int128)v210;
        long long v224 = (__int128)v217;
        long long v225 = (__int128)v214;
        do
        {
          *(long long *)((char *)&v226 + v167) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v163, COERCE_FLOAT(*(long long *)((char *)&v222 + v167))), v164, *(float32x2_t *)((char *)&v222 + v167), 1), v165, *(float32x4_t *)((char *)&v222 + v167), 2), v166, *(float32x4_t *)((char *)&v222 + v167), 3);
          v167 += 16;
        }
        while (v167 != 64);
        float32x4_t v210 = v227;
        float32x4_t v212 = (float32x4_t)v226;
        float32x4_t v214 = v229;
        float32x4_t v217 = v228;
      }
      long long v226 = 0uLL;
      v227.i64[0] = 0;
      std::vector<ARPatch>::reserve((void **)&v226, v158);
      uint64_t v168 = 0;
      float v169 = -a3;
      if (v158 <= 1) {
        uint64_t v170 = 1;
      }
      else {
        uint64_t v170 = v158;
      }
      do
      {
        CV3DPlaneDetectionExtentGridAtIndex();
        long long v171 = (float32x2_t *)CV3DPlaneDetectionAlignedBoundingBoxMin();
        long long v172 = (float32x2_t *)CV3DPlaneDetectionAlignedBoundingBoxMax();
        float32x2_t v173 = vadd_f32(*v171, *v172);
        float32x4_t v174 = vaddq_f32(v214, vmlaq_f32(vmlaq_n_f32(vmulq_n_f32(v212, 0.5 * v173.f32[0]), v210, vmuls_lane_f32(0.5, v173, 1)), (float32x4_t)0, v217));
        int8x16_t v175 = (int8x16_t)vdivq_f32(v174, (float32x4_t)vdupq_laneq_s32((int32x4_t)v174, 3));
        double v176 = COERCE_DOUBLE(vsub_f32(*v172, *v171));
        double v177 = COERCE_DOUBLE(vrev64_s32(*(int32x2_t *)&v176));
        if (v157 == -90) {
          double v177 = v176;
        }
        if (v157 == 90) {
          double v178 = v176;
        }
        else {
          double v178 = v177;
        }
        int32x2_t v179 = vzip1_s32(*(int32x2_t *)v175.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v175, v175, 8uLL));
        uint64_t v180 = *((void *)&v226 + 1);
        if (*((void *)&v226 + 1) >= v227.i64[0])
        {
          uint64_t v182 = (uint64_t)(*((void *)&v226 + 1) - v226) >> 4;
          unint64_t v183 = v182 + 1;
          if ((unint64_t)(v182 + 1) >> 60) {
            std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v184 = v227.i64[0] - v226;
          if ((uint64_t)(v227.i64[0] - v226) >> 3 > v183) {
            unint64_t v183 = v184 >> 3;
          }
          if ((unint64_t)v184 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v185 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v185 = v183;
          }
          if (v185) {
            v186 = (char *)_ZNSt3__119__allocate_at_leastB8ne180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m((uint64_t)&v227, v185);
          }
          else {
            v186 = 0;
          }
          v187 = (double *)&v186[16 * v182];
          double *v187 = *(double *)&v179;
          v187[1] = v178;
          v188 = (char *)*((void *)&v226 + 1);
          v189 = (char *)v226;
          v190 = v187;
          if (*((void *)&v226 + 1) != (void)v226)
          {
            do
            {
              *((_OWORD *)v190 - 1) = *((_OWORD *)v188 - 1);
              v190 -= 2;
              v188 -= 16;
            }
            while (v188 != v189);
            v188 = (char *)v226;
          }
          v181 = (char *)(v187 + 2);
          *(void *)&long long v226 = v190;
          *((void *)&v226 + 1) = v187 + 2;
          v227.i64[0] = (uint64_t)&v186[16 * v185];
          if (v188) {
            operator delete(v188);
          }
        }
        else
        {
          **((void **)&v226 + 1) = v179;
          *(double *)(v180 + 8) = v178;
          v181 = (char *)(v180 + 16);
        }
        *((void *)&v226 + 1) = v181;
        ++v168;
      }
      while (v168 != v170);
      v191 = [ARPatchGrid alloc];
      HIDWORD(v192) = DWORD1(v226);
      long long v222 = v226;
      *(void *)&long long v223 = v227.i64[0];
      v227.i64[0] = 0;
      long long v226 = 0uLL;
      *(float *)&double v192 = v169;
      v193 = [(ARPatchGrid *)v191 initWithPatchesVector:&v222 pivotAngle:v192];
      if ((void)v222)
      {
        *((void *)&v222 + 1) = v222;
        operator delete((void *)v222);
      }
      if ((void)v226)
      {
        *((void *)&v226 + 1) = v226;
        operator delete((void *)v226);
      }
    }
    else
    {
      v193 = 0;
    }
    [(ARPlaneAnchor *)v205 setGridExtent:v193];
  }
}

void sub_1B8956694(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,void *__p,uint64_t a44,uint64_t a45,uint64_t a46,void *a47,uint64_t a48)
{
  double v50 = *(void **)(v48 - 256);
  if (v50)
  {
    *(void *)(v48 - 248) = v50;
    operator delete(v50);
  }
  uint64_t v51 = *(void **)(v48 - 192);
  if (v51)
  {
    *(void *)(v48 - 184) = v51;
    operator delete(v51);
  }

  _Unwind_Resume(a1);
}

uint64_t semanticsLabelForPlane(uint64_t a1, void *a2)
{
  id v2 = a2;
  if (CV3DPlaneDetectionGetSemanticLabel())
  {
    if (v2)
    {
      uint64_t NumSemanticLabels = CV3DPlaneDetectionGetNumSemanticLabels();
      if (NumSemanticLabels)
      {
        for (uint64_t i = 0; i != NumSemanticLabels; ++i)
        {
          CV3DPlaneDetectionGetSemanticProbability();
          uint64_t v5 = [NSNumber numberWithDouble:0.0];
          [v2 addObject:v5];
        }
      }
    }
  }

  return 0;
}

void sub_1B895689C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void setSemanticsFromCV3D(unsigned int a1, void *a2, char a3, void *a4)
{
  id v21 = a2;
  id v7 = a4;
  __float2 v8 = v21;
  id v9 = v7;
  if ((a3 & 1) == 0)
  {
    uint64_t v10 = [v21 count];
    __float2 v8 = v21;
    if (!v10)
    {
      uint64_t v20 = 1;
      goto LABEL_15;
    }
  }
  if (![v8 count])
  {
    uint64_t v20 = 0;
LABEL_15:
    [v9 setClassificationStatus:v20];
    [v9 setClassification:0];
    [v9 setPossibleClassifications:MEMORY[0x1E4F1CC08]];
    goto LABEL_16;
  }
  float32x4_t v11 = objc_opt_new();
  for (unint64_t i = 0; [v21 count] > i; ++i)
  {
    float32x2_t v13 = [v21 objectAtIndex:i];
    [v13 doubleValue];
    double v15 = v14;

    if (v15 > 2.22044605e-16)
    {
      uint64_t v16 = ARPlaneClassificationForSceneUnderstandingLabel(i);
      float32x2_t v17 = [NSNumber numberWithDouble:v15];
      float32x4_t v18 = [NSNumber numberWithInteger:v16];
      [v11 setObject:v17 forKeyedSubscript:v18];
    }
  }
  if (a1)
  {
    [v9 setClassification:ARPlaneClassificationForSceneUnderstandingLabel(a1)];
    [v9 setClassificationStatus:3];
    float v19 = NSStringFromSceneUnderstandingLabel(a1);
    [v9 setClassificationLabel:v19];
  }
  else
  {
    [v9 setClassification:0];
    [v9 setClassificationStatus:2];
  }
  [v9 setPossibleClassifications:v11];

LABEL_16:
}

void sub_1B8956AAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

ARPlaneAnchor *ARUpdatePlaneAnchorFromCV3DPlane(ARPlaneAnchor *a1, const CV3DPlaneDetectionPlane *a2, simd_float4x4 a3, simd_float4x4 a4, char a5, int a6, __int16 a7)
{
  float32x4_t v65 = (float32x4_t)a4.columns[2];
  float32x4_t v68 = (float32x4_t)a4.columns[3];
  float32x4_t v71 = (float32x4_t)a4.columns[1];
  float32x4_t v74 = (float32x4_t)a4.columns[0];
  CV3DPlaneDetectionPlaneTransformationToWorld();
  uint64_t v12 = 0;
  v78.columns[0] = v13;
  v78.columns[1] = v14;
  v78.columns[2] = v15;
  v78.columns[3] = v16;
  do
  {
    v79.columns[v12] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v74, COERCE_FLOAT(*(_OWORD *)&v78.columns[v12])), v71, *(float32x2_t *)v78.columns[v12].f32, 1), v65, (float32x4_t)v78.columns[v12], 2), v68, (float32x4_t)v78.columns[v12], 3);
    ++v12;
  }
  while (v12 != 4);
  float32x4_t v69 = (float32x4_t)v79.columns[1];
  float32x4_t v72 = (float32x4_t)v79.columns[0];
  float32x4_t v64 = (float32x4_t)v79.columns[3];
  float32x4_t v66 = (float32x4_t)v79.columns[2];
  int v17 = CV3DPlaneDetectionPlaneExtentOrientedBoundingBox();
  float v18 = 0.0;
  if (CV3DPlaneDetectionPlaneGetOrientation() == *MEMORY[0x1E4F94888] && v17 != 0)
  {
    v79.columns[0] = v78.columns[0];
    v79.columns[1] = v78.columns[1];
    {
      pivotForOrientedBox(simd_float4x2)::k_cos45 = 1060439283;
    }
    uint64_t v20 = 0;
    float v21 = *(float *)&pivotForOrientedBox(simd_float4x2)::k_cos45;
    do
    {
      uint64_t v22 = v20 + 1;
      float32x2_t v23 = vsub_f32(*(float32x2_t *)&v79.columns[0].f32[2 * v20], *(float32x2_t *)&v79.columns[0].f32[2 * ((v20 + 1) & 3)]);
      int32x2_t v24 = (int32x2_t)vmul_f32(v23, v23);
      *(float *)v24.i32 = sqrtf(vmlas_n_f32(*(float *)&v24.i32[1], v23.f32[0], v23.f32[0]));
      float32x2_t v25 = vdiv_f32(v23, (float32x2_t)vdup_lane_s32(v24, 0));
      if (v25.f32[0] >= v21)
      {
        float v76 = v25.f32[1];
        float v26 = acosf(fminf(fmaxf(v25.f32[0], -1.0), 1.0));
        if (v76 >= 0.0) {
          float v18 = v26;
        }
        else {
          float v18 = -v26;
        }
      }
      uint64_t v20 = v22;
    }
    while (v22 != 4);
  }
  if (a6)
  {
    __float2 v27 = __sincosf_stret(v18 * 0.5);
    float32x4_t v28 = vmulq_n_f32((float32x4_t)xmmword_1B8A2B270, v27.__sinval);
    v28.i32[3] = LODWORD(v27.__cosval);
    *(double *)v29.i64 = simd_matrix4x4(v28);
    uint64_t v30 = 0;
    v78.columns[0] = v29;
    v78.columns[1] = v31;
    v78.columns[2] = v32;
    v78.columns[3] = v33;
    do
    {
      v79.columns[v30] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v72, COERCE_FLOAT(*(_OWORD *)&v78.columns[v30])), v69, *(float32x2_t *)v78.columns[v30].f32, 1), v66, (float32x4_t)v78.columns[v30], 2), v64, (float32x4_t)v78.columns[v30], 3);
      ++v30;
    }
    while (v30 != 4);
    float32x4_t v69 = (float32x4_t)v79.columns[1];
    float32x4_t v72 = (float32x4_t)v79.columns[0];
    float32x4_t v64 = (float32x4_t)v79.columns[3];
    float32x4_t v66 = (float32x4_t)v79.columns[2];
  }
  simd_float4x4 v81 = __invert_f4(*(simd_float4x4 *)_PromotedConst_2);
  uint64_t v34 = 0;
  simd_float4x4 v78 = v81;
  do
  {
    v79.columns[v34] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v72, COERCE_FLOAT(*(_OWORD *)&v78.columns[v34])), v69, *(float32x2_t *)v78.columns[v34].f32, 1), v66, (float32x4_t)v78.columns[v34], 2), v64, (float32x4_t)v78.columns[v34], 3);
    ++v34;
  }
  while (v34 != 4);
  uint64_t v35 = 0;
  __n128 v61 = (__n128)v79.columns[1];
  __n128 v62 = (__n128)v79.columns[0];
  simd_float4x4 v78 = v79;
  __n128 v60 = (__n128)v79.columns[2];
  do
  {
    v79.columns[v35] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)a3.columns[0], COERCE_FLOAT(*(_OWORD *)&v78.columns[v35])), (float32x4_t)a3.columns[1], *(float32x2_t *)v78.columns[v35].f32, 1), (float32x4_t)a3.columns[2], (float32x4_t)v78.columns[v35], 2), (float32x4_t)a3.columns[3], (float32x4_t)v78.columns[v35], 3);
    ++v35;
  }
  while (v35 != 4);
  float32x4_t v73 = (float32x4_t)v79.columns[1];
  float32x4_t v75 = (float32x4_t)v79.columns[0];
  float32x4_t v67 = (float32x4_t)v79.columns[3];
  float32x4_t v70 = (float32x4_t)v79.columns[2];
  float v36 = (ARPlaneAnchor *)[(ARPlaneAnchor *)a1 copy];
  -[ARAnchor setTransform:](v36, "setTransform:", *(double *)v75.i64, *(double *)v73.i64, *(double *)v70.i64, *(double *)v67.i64);
  CV3DPlaneDetectionPlaneUncertaintyAlongNormal();
  *(float *)&double v37 = v37;
  [(ARPlaneAnchor *)v36 setUncertaintyAlongNormal:v37];
  if ([(ARPlaneAnchor *)v36 worldAlignmentRotation])
  {
    float v38 = (double)[(ARPlaneAnchor *)v36 worldAlignmentRotation]* 3.14159265/ 180.0;
    __float2 v39 = __sincosf_stret(v38 * 0.5);
    float32x4_t v40 = vmulq_n_f32((float32x4_t)xmmword_1B8A2B0D0, v39.__sinval);
    v40.i32[3] = LODWORD(v39.__cosval);
    *(double *)v41.i64 = simd_matrix4x4(v40);
    uint64_t v42 = 0;
    v78.columns[0] = v41;
    v78.columns[1] = v43;
    v78.columns[2] = v44;
    v78.columns[3] = v45;
    do
    {
      v79.columns[v42] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v75, COERCE_FLOAT(*(_OWORD *)&v78.columns[v42])), v73, *(float32x2_t *)v78.columns[v42].f32, 1), v70, (float32x4_t)v78.columns[v42], 2), v67, (float32x4_t)v78.columns[v42], 3);
      ++v42;
    }
    while (v42 != 4);
    -[ARAnchor setTransform:](v36, "setTransform:", *(double *)v79.columns[0].i64, *(double *)v79.columns[1].i64, *(double *)v79.columns[2].i64, *(double *)v79.columns[3].i64);
  }
  _updateExtentsForPlaneAnchor(v36, a2, v18, a6, (a7 & 0x200) != 0);
  float32x4_t v46 = objc_opt_new();
  unsigned int v47 = semanticsLabelForPlane((uint64_t)a2, v46);
  setSemanticsFromCV3D(v47, v46, a5, v36);
  if ([(ARPlaneAnchor *)v36 alignment] == ARPlaneAnchorAlignmentHorizontal)
  {
    double v49 = AREulerAnglesFromMatrix(v62, v61, v60);
    float v77 = *((float *)&v49 + 1);
    [(ARAnchor *)a1 referenceTransform];
    AREulerAnglesFromMatrix(v50, v51, v52);
    float v53 = v77 * 0.318309886 * 180.0;
    float v55 = v53 + v54 * -0.318309886 * 180.0;
    double v48 = v55;
  }
  long long v56 = [(ARAnchor *)v36 identifier];
  objc_msgSend(v56, "ar_integerValue");
  long long v57 = [(ARPlaneAnchor *)v36 planeExtent];
  [v57 width];
  long long v58 = [(ARPlaneAnchor *)v36 planeExtent];
  [v58 height];
  kdebug_trace();

  return v36;
}

void sub_1B8957054(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8957220(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B895779C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30)
{
  _Unwind_Resume(a1);
}

void sub_1B8957AE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8957EE4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::vector<short>::reserve(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 1)
  {
    if ((a2 & 0x8000000000000000) != 0) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    uint64_t v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<short>>(v3, a2);
    id v7 = &v6[v5 & 0xFFFFFFFFFFFFFFFELL];
    id v9 = &v6[2 * v8];
    uint64_t v10 = (char *)*a1;
    float32x4_t v11 = (char *)a1[1];
    uint64_t v12 = v7;
    if (v11 != *a1)
    {
      uint64_t v12 = v7;
      do
      {
        __int16 v13 = *((_WORD *)v11 - 1);
        v11 -= 2;
        *((_WORD *)v12 - 1) = v13;
        v12 -= 2;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<short>>(uint64_t a1, uint64_t a2)
{
  if (a2 < 0) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(2 * a2);
}

void std::vector<ARPatch>::reserve(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 4)
  {
    if (a2 >> 60) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    uint64_t v6 = (char *)_ZNSt3__119__allocate_at_leastB8ne180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m(v3, a2);
    id v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF0];
    id v9 = &v6[16 * v8];
    float32x4_t v11 = (char *)*a1;
    uint64_t v10 = (char *)a1[1];
    uint64_t v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        *((_OWORD *)v12 - 1) = *((_OWORD *)v10 - 1);
        v12 -= 16;
        v10 -= 16;
      }
      while (v10 != v11);
      uint64_t v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

void ___ZL13_ARLogGeneralv_block_invoke_10()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "General");
  uint64_t v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObuint64_t j = (uint64_t)v0;
}

void sub_1B8958B0C(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1B89590B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

void sub_1B8959B50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, void *a15, void *a16, uint64_t a17, uint64_t a18, void *a19)
{
  _Unwind_Resume(a1);
}

void ___ZL13_ARLogGeneralv_block_invoke_11()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "General");
  uint64_t v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObuint64_t j = (uint64_t)v0;
}

id ARSensorDataTypesToString(uint64_t a1)
{
  id v2 = objc_opt_new();
  uint64_t v3 = v2;
  if (!a1)
  {
    uint64_t v4 = @"None";
LABEL_20:
    [v3 addObject:v4];
    goto LABEL_21;
  }
  if (a1)
  {
    [v2 addObject:@"ColorImage"];
    if ((a1 & 2) == 0)
    {
LABEL_4:
      if ((a1 & 4) == 0) {
        goto LABEL_5;
      }
      goto LABEL_14;
    }
  }
  else if ((a1 & 2) == 0)
  {
    goto LABEL_4;
  }
  [v3 addObject:@"Accelerometer"];
  if ((a1 & 4) == 0)
  {
LABEL_5:
    if ((a1 & 8) == 0) {
      goto LABEL_6;
    }
    goto LABEL_15;
  }
LABEL_14:
  [v3 addObject:@"Gyroscope"];
  if ((a1 & 8) == 0)
  {
LABEL_6:
    if ((a1 & 0x10) == 0) {
      goto LABEL_7;
    }
    goto LABEL_16;
  }
LABEL_15:
  [v3 addObject:@"DeviceOrientation"];
  if ((a1 & 0x10) == 0)
  {
LABEL_7:
    if ((a1 & 0x20) == 0) {
      goto LABEL_8;
    }
    goto LABEL_17;
  }
LABEL_16:
  [v3 addObject:@"FaceMetaData"];
  if ((a1 & 0x20) == 0)
  {
LABEL_8:
    if ((a1 & 0x40) == 0) {
      goto LABEL_9;
    }
LABEL_18:
    [v3 addObject:@"Location"];
    if ((a1 & 0x400) == 0) {
      goto LABEL_21;
    }
    goto LABEL_19;
  }
LABEL_17:
  [v3 addObject:@"Depth"];
  if ((a1 & 0x40) != 0) {
    goto LABEL_18;
  }
LABEL_9:
  if ((a1 & 0x400) != 0)
  {
LABEL_19:
    uint64_t v4 = @"Magnetometer";
    goto LABEL_20;
  }
LABEL_21:
  int64_t v5 = [v3 componentsJoinedByString:@" | "];

  return v5;
}

uint64_t ARC3DSegmentIntersectsSegment(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  if ((a3 - a1) * (a6 - a2) - (a4 - a2) * (a5 - a1) <= 0.0 != (a3 - a1) * (a8 - a2) - (a4 - a2) * (a7 - a1) > 0.0) {
    return 0;
  }
  else {
    return ((a7 - a5) * (a2 - a6) - (a8 - a6) * (a1 - a5) > 0.0) ^ ((a7 - a5) * (a4 - a6)
  }
                                                                                - (a8 - a6) * (a3 - a5) > 0.0);
}

double ARC3DComputeLinesIntersection(double *a1, double *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  double v10 = a3 - a5;
  double v11 = (a3 - a5) * (a8 - a10) - (a4 - a6) * (a7 - a9);
  if (v11 == 0.0) {
    ARC3DComputeLinesIntersection_cold_1();
  }
  double v12 = -(a4 - a6);
  double v13 = a3 * a6 - a4 * a5;
  double v14 = a7 * a10 - a8 * a9;
  *a1 = (v13 * (a7 - a9) - v10 * v14) / v11;
  double result = (v14 * v12 + v13 * (a8 - a10)) / v11;
  *a2 = result;
  return result;
}

double ARC3DComputeLinesIntersectionForPoints(double *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  double v9 = a2 - a4;
  double v10 = (a2 - a4) * (a7 - a9) - (a3 - a5) * (a6 - a8);
  if (v10 == 0.0) {
    ARC3DComputeLinesIntersectionForPoints_cold_1();
  }
  double v11 = -(a3 - a5);
  double v12 = a2 * a5 - a3 * a4;
  double v13 = a6 * a9 - a7 * a8;
  double v14 = (v12 * (a6 - a8) - v9 * v13) / v10;
  double result = (v13 * v11 + v12 * (a7 - a9)) / v10;
  *a1 = v14;
  a1[1] = result;
  return result;
}

void sub_1B895C964(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

__CFString *NSStringFromARWorldMappingStatus(unint64_t a1)
{
  if (a1 > 3) {
    return &stru_1F120C8F0;
  }
  else {
    return off_1E6186FB0[a1];
  }
}

void sub_1B895DDB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B895F418(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B895F664(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

id _ARLogTechnique_7()
{
  if (_ARLogTechnique_onceToken_10 != -1) {
    dispatch_once(&_ARLogTechnique_onceToken_10, &__block_literal_global_60);
  }
  os_log_t v0 = (void *)_ARLogTechnique_logObj_10;
  return v0;
}

void sub_1B8960984(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, void (*a14)(char *), uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
}

void sub_1B8960D88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, void (*a12)(char *))
{
}

BOOL __ARSkipCrashOnCrash_block_invoke_1()
{
  BOOL result = +[ARKitUserDefaults BOOLForKey:@"com.apple.arkit.skipCrashOnARCrash"];
  ARSkipCrashOnCrash_skipCrashOnCrash_1 = result;
  return result;
}

id ARCopyFromSharedTextureHandle(void *a1, char a2)
{
  id v3 = a1;
  uint64_t v4 = [v3 device];
  int64_t v5 = (void *)[v4 newCommandQueue];
  uint64_t v6 = (void *)[v4 newSharedTextureWithHandle:v3];

  id v7 = objc_msgSend(MEMORY[0x1E4F35330], "textureCubeDescriptorWithPixelFormat:size:mipmapped:", objc_msgSend(v6, "pixelFormat"), objc_msgSend(v6, "width"), (unint64_t)objc_msgSend(v6, "mipmapLevelCount") > 1);
  if (a2) {
    uint64_t v8 = [v4 newSharedTextureWithDescriptor:v7];
  }
  else {
    uint64_t v8 = [v4 newTextureWithDescriptor:v7];
  }
  double v9 = (void *)v8;
  double v10 = [v5 commandBuffer];
  [v10 setLabel:@"com.apple.arkit.lightestimation.copytexturebuffer"];
  double v11 = [v10 blitCommandEncoder];
  [v11 setLabel:@"com.apple.arkit.lightestimation.copytexture"];
  [v11 copyFromTexture:v6 toTexture:v9];
  [v11 endEncoding];
  [v10 commit];
  [v10 waitUntilCompleted];

  return v9;
}

id ARCopyMipmapsFromSharedTextureHandle(void *a1, id a2)
{
  id v2 = a2;
  if (a2)
  {
    id v3 = a1;
    uint64_t v4 = [v3 device];
    int64_t v5 = (void *)[v4 newCommandQueue];
    uint64_t v6 = (void *)[v4 newSharedTextureWithHandle:v3];

    unint64_t v7 = [v6 mipmapLevelCount];
    if (v7 >= (unint64_t)v2) {
      id v8 = v2;
    }
    else {
      id v8 = (id)v7;
    }
    double v9 = objc_msgSend(MEMORY[0x1E4F35330], "textureCubeDescriptorWithPixelFormat:size:mipmapped:", objc_msgSend(v6, "pixelFormat"), (unint64_t)exp2((double)((unint64_t)v8 - 1)), (unint64_t)objc_msgSend(v6, "mipmapLevelCount") > 1);
    id v2 = (id)[v4 newSharedTextureWithDescriptor:v9];
    double v10 = [v5 commandBuffer];
    [v10 setLabel:@"com.apple.arkit.lightestimation.lowrescopytexturebuffer"];
    double v11 = [v10 blitCommandEncoder];
    [v11 setLabel:@"com.apple.arkit.lightestimation.lowrescopytexture"];
    objc_msgSend(v11, "copyFromTexture:sourceSlice:sourceLevel:toTexture:destinationSlice:destinationLevel:sliceCount:levelCount:", v6, 0, objc_msgSend(v6, "mipmapLevelCount") - (void)v8, v2, 0, 0, 6, v8);
    [v11 endEncoding];
    [v10 commit];
    [v10 waitUntilCompleted];
  }
  return v2;
}

float ARAverageCubemapIntensity(void *a1)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if ((unint64_t)[v1 mipmapLevelCount] >= 2) {
    uint64_t v2 = [v1 mipmapLevelCount] - 2;
  }
  else {
    uint64_t v2 = 0;
  }
  uint64_t v3 = 0;
  float v4 = 0.0;
  int64x2_t v24 = vdupq_n_s64(2uLL);
  do
  {
    memset(v25, 0, sizeof(v25));
    int64x2_t v26 = v24;
    char v5 = 1;
    uint64_t v27 = 1;
    objc_msgSend(v1, "getBytes:bytesPerRow:bytesPerImage:fromRegion:mipmapLevel:slice:", v28, 16, 32, v25, v2, v3, *(_OWORD *)&v24);
    uint64_t v6 = 0;
    do
    {
      uint64_t v7 = 0;
      char v8 = v5;
      char v9 = 1;
      do
      {
        char v10 = v9;
        uint64_t v11 = v6 | v7;
        _H0 = v28[v11];
        _H1 = *(_WORD *)((char *)v28 + ((2 * v11) | 2));
        _H2 = *(_WORD *)((char *)v28 + ((2 * v11) | 4));
        __asm
        {
          FCVT            S0, H0
          FCVT            S1, H1
        }
        float v21 = (float)(_S1 * 0.715) + (float)(_S0 * 0.213);
        __asm { FCVT            S1, H2 }
        float v4 = v4 + (float)(v21 + (float)(_S1 * 0.072));
        uint64_t v7 = 4;
        char v9 = 0;
      }
      while ((v10 & 1) != 0);
      char v5 = 0;
      uint64_t v6 = 8;
    }
    while ((v8 & 1) != 0);
    ++v3;
  }
  while (v3 != 6);

  return v4 / 24.0;
}

id ARErrorWithCodeAndUserInfo(uint64_t a1, void *a2)
{
  id v3 = a2;
  float v4 = [MEMORY[0x1E4F1CA60] dictionary];
  char v5 = v4;
  if (a1 > 299)
  {
    if (a1 <= 499)
    {
      switch(a1)
      {
        case 300:
          uint64_t v6 = ARKitCoreBundle();
          uint64_t v7 = v6;
          char v8 = @"Invalid reference image.";
          goto LABEL_50;
        case 301:
          float v19 = ARKitCoreBundle();
          uint64_t v20 = [v19 localizedStringForKey:@"Invalid reference object." value:&stru_1F120C8F0 table:@"Localizable_iOS"];
          [v5 setObject:v20 forKeyedSubscript:*MEMORY[0x1E4F28568]];

          uint64_t v11 = ARKitCoreBundle();
          uint64_t v7 = v11;
          double v12 = @"The reference object data is not in a format supported by this version of ARReferenceObject.";
          break;
        case 302:
          float v21 = ARKitCoreBundle();
          uint64_t v22 = [v21 localizedStringForKey:@"Invalid world map." value:&stru_1F120C8F0 table:@"Localizable_iOS"];
          [v5 setObject:v22 forKeyedSubscript:*MEMORY[0x1E4F28568]];

          uint64_t v11 = ARKitCoreBundle();
          uint64_t v7 = v11;
          double v12 = @"The world map data is not in a format supported by this version of ARWorldMap.";
          break;
        case 303:
          uint64_t v6 = ARKitCoreBundle();
          uint64_t v7 = v6;
          char v8 = @"Invalid configuration.";
          goto LABEL_50;
        case 304:
          float32x2_t v23 = ARKitCoreBundle();
          int64x2_t v24 = [v23 localizedStringForKey:@"Invalid collaboration data." value:&stru_1F120C8F0 table:@"Localizable_iOS"];
          [v5 setObject:v24 forKeyedSubscript:*MEMORY[0x1E4F28568]];

          uint64_t v11 = ARKitCoreBundle();
          uint64_t v7 = v11;
          double v12 = @"The encoded data is not in a format supported by this version of ARCollaborationData.";
          break;
        default:
          if (a1 == 400)
          {
            uint64_t v6 = ARKitCoreBundle();
            uint64_t v7 = v6;
            char v8 = @"Insufficient features.";
            goto LABEL_50;
          }
          if (a1 != 401) {
            goto LABEL_52;
          }
          int v17 = ARKitCoreBundle();
          float v18 = [v17 localizedStringForKey:@"Object merge failed." value:&stru_1F120C8F0 table:@"Localizable_iOS"];
          [v5 setObject:v18 forKeyedSubscript:*MEMORY[0x1E4F28568]];

          uint64_t v11 = ARKitCoreBundle();
          uint64_t v7 = v11;
          double v12 = @"Not enough matching features were found for the reference objects to be merged.";
          break;
      }
LABEL_31:
      uint64_t v27 = [v11 localizedStringForKey:v12 value:&stru_1F120C8F0 table:@"Localizable_iOS"];
      float32x4_t v28 = (void *)MEMORY[0x1E4F28588];
LABEL_51:
      [v5 setObject:v27 forKeyedSubscript:*v28];

LABEL_52:
      if (!v3) {
        goto LABEL_54;
      }
      goto LABEL_53;
    }
    if (a1 > 999)
    {
      switch(a1)
      {
        case 1000:
          [v4 setObject:@"Unauthorized to write to the photo library." forKeyedSubscript:*MEMORY[0x1E4F28568]];
          [v5 setObject:@"A permission is missing to access the photo library." forKeyedSubscript:*MEMORY[0x1E4F28588]];
          uint64_t v13 = *MEMORY[0x1E4F285A0];
          double v14 = @"Make sure that the application has the required privacy settings.";
          goto LABEL_58;
        case 1001:
          [v4 setObject:@"Failed saving the recording." forKeyedSubscript:*MEMORY[0x1E4F28568]];
          uint64_t v13 = *MEMORY[0x1E4F28588];
          double v14 = @"Failed saving the recording for an unknown reason.";
          goto LABEL_58;
        case 1002:
        case 1003:
          goto LABEL_52;
        case 1004:
          [v4 setObject:@"Failed to load espresso model." forKeyedSubscript:*MEMORY[0x1E4F28568]];
          if (v3)
          {
            uint64_t v51 = *MEMORY[0x1E4F28328];
            __n128 v52 = [v3 objectForKey:*MEMORY[0x1E4F28328]];

            if (v52)
            {
              float v53 = NSString;
              float v54 = [v3 objectForKey:v51];
              float v55 = [v53 stringWithFormat:@"File path '%@' is invalid or does not exist", v54];
              [v5 setObject:v55 forKeyedSubscript:*MEMORY[0x1E4F28588]];

              goto LABEL_53;
            }
          }
          uint64_t v13 = *MEMORY[0x1E4F28588];
          double v14 = @"File path is invalid or does not exist";
          break;
        case 1005:
          uint64_t v6 = ARKitCoreBundle();
          uint64_t v7 = v6;
          char v8 = @"Unsupported sensor data.";
          goto LABEL_50;
        default:
          if (a1 != 1028) {
            goto LABEL_52;
          }
          uint64_t v6 = ARKitCoreBundle();
          uint64_t v7 = v6;
          char v8 = @"Unsupported feature.";
          goto LABEL_50;
      }
      goto LABEL_58;
    }
    if (a1 == 500)
    {
      long long v56 = ARKitCoreBundle();
      long long v57 = [v56 localizedStringForKey:@"File IO failed." value:&stru_1F120C8F0 table:@"Localizable_iOS"];
      [v5 setObject:v57 forKeyedSubscript:*MEMORY[0x1E4F28568]];

      long long v58 = NSString;
      float v59 = ARKitCoreBundle();
      __n128 v60 = [v59 localizedStringForKey:@"Unable to read from or write to URL: %@." value:&stru_1F120C8F0 table:@"Localizable_iOS"];
      __n128 v61 = [v3 objectForKeyedSubscript:*MEMORY[0x1E4F289D0]];
      __n128 v62 = objc_msgSend(v58, "stringWithFormat:", v60, v61);
      [v5 setObject:v62 forKeyedSubscript:*MEMORY[0x1E4F28588]];

      if (!v3) {
        goto LABEL_54;
      }
      goto LABEL_53;
    }
    if (a1 != 501) {
      goto LABEL_52;
    }
    uint64_t v6 = ARKitCoreBundle();
    uint64_t v7 = v6;
    char v8 = @"Request failed.";
    goto LABEL_50;
  }
  if (a1 > 149)
  {
    if (a1 <= 200)
    {
      if (a1 != 150)
      {
        if (a1 != 200) {
          goto LABEL_52;
        }
        simd_float4 v15 = ARKitCoreBundle();
        simd_float4 v16 = [v15 localizedStringForKey:@"World tracking failed." value:&stru_1F120C8F0 table:@"Localizable_iOS"];
        [v5 setObject:v16 forKeyedSubscript:*MEMORY[0x1E4F28568]];

        uint64_t v11 = ARKitCoreBundle();
        uint64_t v7 = v11;
        double v12 = @"World tracking cannot determine the device’s position.";
        goto LABEL_31;
      }
      [v4 setObject:@"Unsupported capture session configuration." forKeyedSubscript:*MEMORY[0x1E4F28568]];
      [v5 setObject:@"Input device and/or format of the provided capture session are not supported for the given configuration." forKeyedSubscript:*MEMORY[0x1E4F28588]];
      uint64_t v13 = *MEMORY[0x1E4F285A0];
      double v14 = @"Make sure that the correct device and format are being used for capture.";
LABEL_58:
      [v5 setObject:v14 forKeyedSubscript:v13];
      if (!v3) {
        goto LABEL_54;
      }
LABEL_53:
      [v5 addEntriesFromDictionary:v3];
      goto LABEL_54;
    }
    if (a1 == 201)
    {
      uint64_t v6 = ARKitCoreBundle();
      uint64_t v7 = v6;
      char v8 = @"Geo tracking is not available at this location.";
    }
    else
    {
      if (a1 != 202) {
        goto LABEL_52;
      }
      uint64_t v6 = ARKitCoreBundle();
      uint64_t v7 = v6;
      char v8 = @"Geo tracking failed because of a runtime error.";
    }
LABEL_50:
    uint64_t v27 = [v6 localizedStringForKey:v8 value:&stru_1F120C8F0 table:@"Localizable_iOS"];
    float32x4_t v28 = (void *)MEMORY[0x1E4F28568];
    goto LABEL_51;
  }
  switch(a1)
  {
    case 'd':
      char v9 = ARKitCoreBundle();
      char v10 = [v9 localizedStringForKey:@"Unsupported configuration." value:&stru_1F120C8F0 table:@"Localizable_iOS"];
      [v5 setObject:v10 forKeyedSubscript:*MEMORY[0x1E4F28568]];

      uint64_t v11 = ARKitCoreBundle();
      uint64_t v7 = v11;
      double v12 = @"The provided configuration is not supported on this device.";
      goto LABEL_31;
    case 'e':
      float32x2_t v25 = ARKitCoreBundle();
      int64x2_t v26 = [v25 localizedStringForKey:@"Required sensor unavailable." value:&stru_1F120C8F0 table:@"Localizable_iOS"];
      [v5 setObject:v26 forKeyedSubscript:*MEMORY[0x1E4F28568]];

      uint64_t v11 = ARKitCoreBundle();
      uint64_t v7 = v11;
      double v12 = @"A required sensor is not available on this device.";
      goto LABEL_31;
    case 'f':
      uint64_t v29 = ARKitCoreBundle();
      uint64_t v30 = [v29 localizedStringForKey:@"Required sensor failed." value:&stru_1F120C8F0 table:@"Localizable_iOS"];
      [v5 setObject:v30 forKeyedSubscript:*MEMORY[0x1E4F28568]];

      simd_float4 v31 = ARKitCoreBundle();
      simd_float4 v32 = [v31 localizedStringForKey:@"A sensor failed to deliver the required input." value:&stru_1F120C8F0 table:@"Localizable_iOS"];
      [v5 setObject:v32 forKeyedSubscript:*MEMORY[0x1E4F28588]];

      simd_float4 v33 = ARKitCoreBundle();
      uint64_t v34 = v33;
      uint64_t v35 = @"Make sure that the application has the required privacy settings.";
      break;
    case 'g':
      float v36 = ARKitCoreBundle();
      double v37 = [v36 localizedStringForKey:@"Camera access not authorized." value:&stru_1F120C8F0 table:@"Localizable_iOS"];
      [v5 setObject:v37 forKeyedSubscript:*MEMORY[0x1E4F28568]];

      float v38 = ARKitCoreBundle();
      __float2 v39 = [v38 localizedStringForKey:@"The app does not have permission to use the camera." value:&stru_1F120C8F0 table:@"Localizable_iOS"];
      [v5 setObject:v39 forKeyedSubscript:*MEMORY[0x1E4F28588]];

      simd_float4 v33 = ARKitCoreBundle();
      uint64_t v34 = v33;
      uint64_t v35 = @"Make sure that the application has the required camera privacy settings.";
      break;
    case 'h':
      float32x4_t v40 = ARKitCoreBundle();
      simd_float4 v41 = [v40 localizedStringForKey:@"Microphone access not authorized." value:&stru_1F120C8F0 table:@"Localizable_iOS"];
      [v5 setObject:v41 forKeyedSubscript:*MEMORY[0x1E4F28568]];

      uint64_t v42 = ARKitCoreBundle();
      simd_float4 v43 = [v42 localizedStringForKey:@"The app does not have permission to use the microphone." value:&stru_1F120C8F0 table:@"Localizable_iOS"];
      [v5 setObject:v43 forKeyedSubscript:*MEMORY[0x1E4F28588]];

      simd_float4 v33 = ARKitCoreBundle();
      uint64_t v34 = v33;
      uint64_t v35 = @"Make sure that the application has the required microphone privacy settings.";
      break;
    case 'i':
      simd_float4 v44 = ARKitCoreBundle();
      simd_float4 v45 = [v44 localizedStringForKey:@"Location access not authorized." value:&stru_1F120C8F0 table:@"Localizable_iOS"];
      [v5 setObject:v45 forKeyedSubscript:*MEMORY[0x1E4F28568]];

      float32x4_t v46 = ARKitCoreBundle();
      unsigned int v47 = [v46 localizedStringForKey:@"The app does not have permission to use the location of the device." value:&stru_1F120C8F0 table:@"Localizable_iOS"];
      [v5 setObject:v47 forKeyedSubscript:*MEMORY[0x1E4F28588]];

      simd_float4 v33 = ARKitCoreBundle();
      uint64_t v34 = v33;
      uint64_t v35 = @"Location access and precise accuracy must be enabled in the app's privacy settings.";
      break;
    case 'j':
      double v49 = ARKitCoreBundle();
      __n128 v50 = [v49 localizedStringForKey:@"Another high-resolution frame is currently being captured." value:&stru_1F120C8F0 table:@"Localizable_iOS"];
      [v5 setObject:v50 forKeyedSubscript:*MEMORY[0x1E4F28568]];

      uint64_t v7 = ARKitCoreBundle();
      uint64_t v27 = [v7 localizedStringForKey:@"Please wait for the completion handler call." value:&stru_1F120C8F0 table:@"Localizable_iOS"];
      float32x4_t v28 = (void *)MEMORY[0x1E4F285A0];
      goto LABEL_51;
    case 'k':
      uint64_t v6 = ARKitCoreBundle();
      uint64_t v7 = v6;
      char v8 = @"Capturing a high resolution frame failed.";
      goto LABEL_50;
    default:
      goto LABEL_52;
  }
  double v48 = [v33 localizedStringForKey:v35 value:&stru_1F120C8F0 table:@"Localizable_iOS"];
  [v5 setObject:v48 forKeyedSubscript:*MEMORY[0x1E4F285A0]];

  if (v3) {
    goto LABEL_53;
  }
LABEL_54:
  float32x4_t v63 = [MEMORY[0x1E4F28C58] errorWithDomain:@"com.apple.arkit.error" code:a1 userInfo:v5];

  return v63;
}

__CFString *NSStringFromARPlaneClassification(uint64_t a1)
{
  if ((unint64_t)(a1 - 1) > 6) {
    return @"None";
  }
  else {
    return off_1E6187040[a1 - 1];
  }
}

__CFString *NSStringFromARPlaneClassificationStatus(uint64_t a1)
{
  if ((unint64_t)(a1 - 1) > 2) {
    return @"Unavailable";
  }
  else {
    return off_1E6187028[a1 - 1];
  }
}

__CFString *NSStringFromARPlaneAlignment(uint64_t a1)
{
  id v1 = @"vertical";
  if (a1 != 1) {
    id v1 = 0;
  }
  if (a1) {
    return v1;
  }
  else {
    return @"horizontal";
  }
}

id ARCreateOBJStringForPlaneAnchors(void *a1, void *a2, float a3)
{
  uint64_t v80 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  uint64_t v6 = [MEMORY[0x1E4F28E78] string];
  long long v72 = 0u;
  long long v73 = 0u;
  long long v74 = 0u;
  long long v75 = 0u;
  id v7 = v5;
  uint64_t v8 = [v7 countByEnumeratingWithState:&v72 objects:v79 count:16];
  if (v8)
  {
    uint64_t v9 = v8;
    int v10 = 0;
    LODWORD(v11) = 0;
    uint64_t v12 = *(void *)v73;
    do
    {
      for (uint64_t i = 0; i != v9; ++i)
      {
        if (*(void *)v73 != v12) {
          objc_enumerationMutation(v7);
        }
        double v14 = *(void **)(*((void *)&v72 + 1) + 8 * i);
        simd_float4 v15 = [v14 geometry];
        uint64_t v11 = [v15 vertexCount] + v11;

        simd_float4 v16 = [v14 geometry];
        v10 += [v16 triangleCount];
      }
      uint64_t v9 = [v7 countByEnumeratingWithState:&v72 objects:v79 count:16];
    }
    while (v9);

    if (v11) {
      BOOL v17 = v10 == 0;
    }
    else {
      BOOL v17 = 1;
    }
    if (!v17)
    {
      [v6 appendString:@"#\n"];
      float v18 = NSString;
      float v19 = [MEMORY[0x1E4F28B50] mainBundle];
      uint64_t v20 = [v19 bundleIdentifier];
      float v21 = ARVersionStringForIdentifier(v20);
      uint64_t v22 = ARVersionStringForIdentifier(@"com.apple.ARKit");
      ARVersionStringForIdentifier(@"com.apple.AppleCV3D");
      float32x2_t v23 = v61 = v7;
      int64x2_t v24 = [v18 stringWithFormat:@"# ARKit plane geometry mesh exported from ARExamples %@, ARKit %@, AppleCV3D %@\n", v21, v22, v23];
      [v6 appendString:v24];

      [v6 appendString:@"#\n"];
      float32x2_t v25 = objc_msgSend(NSString, "stringWithFormat:", @"# Vertex count: %d\n", v11);
      [v6 appendString:v25];

      int64x2_t v26 = objc_msgSend(NSString, "stringWithFormat:", @"# Face count: %d\n", (2 * v10));
      [v6 appendString:v26];

      [v6 appendString:@"#\n"];
      [v6 appendString:@"# Real world scale is 1 unit = 1 m\n"];
      [v6 appendString:@"# Each vertex is followed by four RGBA color values in range [0.0 - 1.0] (not in spec)\n"];
      long long v69 = 0u;
      long long v70 = 0u;
      long long v67 = 0u;
      long long v68 = 0u;
      obuint64_t j = v61;
      uint64_t v64 = [obj countByEnumeratingWithState:&v67 objects:v76 count:16];
      if (v64)
      {
        int v27 = 1;
        uint64_t v63 = *(void *)v68;
        double v28 = a3;
        do
        {
          uint64_t v29 = 0;
          do
          {
            if (*(void *)v68 != v63) {
              objc_enumerationMutation(obj);
            }
            uint64_t v65 = v29;
            uint64_t v30 = *(void **)(*((void *)&v67 + 1) + 8 * v29);
            [v6 appendString:@"\n"];
            simd_float4 v31 = NSString;
            simd_float4 v32 = [v30 identifier];
            simd_float4 v33 = [v32 UUIDString];
            uint64_t v34 = [v31 stringWithFormat:@"o plane_anchor_%@\n", v33];
            [v6 appendString:v34];

            [v6 appendString:@"\n"];
            uint64_t v35 = [v30 geometry];
            float v36 = (float32x4_t *)[v35 vertices];
            uint64_t v37 = [v35 vertexCount];
            __n128 v38 = ARCV3DColorComponentsForARKitSemantics([v30 classification]);
            int v66 = v37;
            if (v37)
            {
              double v39 = v38.n128_f32[0];
              double v40 = v38.n128_f32[1];
              double v41 = v38.n128_f32[2];
              uint64_t v42 = v37;
              do
              {
                float32x4_t v43 = *v36++;
                [v30 transform];
                float32x4_t v48 = vaddq_f32(v47, vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v44, v43.f32[0]), v45, *(float32x2_t *)v43.f32, 1), v46, v43, 2));
                double v49 = objc_msgSend(NSString, "stringWithFormat:", @"v %.03f %.03f %.03f %.03f %.03f %.03f %.03f\n", v48.f32[0], v48.f32[1], v48.f32[2], *(void *)&v39, *(void *)&v40, *(void *)&v41, *(void *)&v28);
                [v6 appendString:v49];

                --v42;
              }
              while (v42);
            }
            objc_msgSend(v6, "appendString:", @"\n", v38.n128_f64[0]);
            uint64_t v50 = [v35 triangleIndices];
            uint64_t v51 = [v35 triangleCount];
            if (v51)
            {
              uint64_t v52 = v51;
              float v53 = (__int16 *)(v50 + 4);
              do
              {
                float v54 = objc_msgSend(NSString, "stringWithFormat:", @"f %d %d %d\n", (v27 + *(v53 - 2)), (v27 + *(v53 - 1)), (v27 + *v53));
                [v6 appendString:v54];

                float v55 = objc_msgSend(NSString, "stringWithFormat:", @"f %d %d %d\n", (v27 + *v53), (v27 + *(v53 - 1)), (v27 + *(v53 - 2)));
                [v6 appendString:v55];

                v53 += 3;
                --v52;
              }
              while (v52);
            }
            v27 += v66;

            uint64_t v29 = v65 + 1;
          }
          while (v65 + 1 != v64);
          uint64_t v64 = [obj countByEnumeratingWithState:&v67 objects:v76 count:16];
        }
        while (v64);
      }

      [v6 appendString:@"\n"];
      [v6 appendString:@"# EOF\n"];
      id v7 = v61;
      goto LABEL_33;
    }
  }
  else
  {
  }
  if (_ARLogGeneral_onceToken_27 != -1) {
    dispatch_once(&_ARLogGeneral_onceToken_27, &__block_literal_global_61);
  }
  long long v56 = _ARLogGeneral_logObj_27;
  if (os_log_type_enabled((os_log_t)_ARLogGeneral_logObj_27, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)vImage_Buffer buf = 0;
    _os_log_impl(&dword_1B88A2000, v56, OS_LOG_TYPE_ERROR, "No mesh to save.", buf, 2u);
  }
  if (a2)
  {
    long long v57 = (void *)MEMORY[0x1E4F28C58];
    uint64_t v58 = *MEMORY[0x1E4F281F8];
    uint64_t v77 = *MEMORY[0x1E4F28568];
    simd_float4x4 v78 = @"There is no plane geometry mesh to save.";
    float v59 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v78 forKeys:&v77 count:1];
    *a2 = [v57 errorWithDomain:v58 code:-1 userInfo:v59];
  }
LABEL_33:

  return v6;
}

void sub_1B8964500(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object, void *a11)
{
  _Unwind_Resume(a1);
}

void sub_1B8964D40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B896549C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8965628(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL13_ARLogGeneralv_block_invoke_12()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "General");
  id v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObuint64_t j = (uint64_t)v0;
}

double cva::assign<false,false,cva::Matrix<float,4u,1u,false>,cva::MatrixMultExpr<cva::Matrix<float,4u,4u,false>,cva::Matrix<float,4u,4u,false>>,cva::Matrix<float,4u,1u,false>>(float32x4_t *a1, uint64_t a2)
{
  if (*(float32x4_t **)(a2 + 8) == a1)
  {
    v11[0] = 0uLL;
    cva::assign<false,false,cva::Matrix<float,4u,1u,false>,cva::MatrixMultExpr<cva::Matrix<float,4u,4u,false>,cva::Matrix<float,4u,4u,false>>,cva::Matrix<float,4u,1u,false>>(v11, a2);
    v8.i64[0] = v11[0].i64[0];
    *a1 = v11[0];
  }
  else
  {
    float v4 = *(float32x4_t ***)a2;
    memset(v11, 0, sizeof(v11));
    cva::assign<false,false,cva::Matrix<float,4u,4u,false>,cva::Matrix<float,4u,4u,false>,cva::Matrix<float,4u,4u,false>>(v11, v4);
    float32x4_t v5 = 0uLL;
    uint64_t v6 = 0;
    id v7 = *(float **)(a2 + 8);
    do
    {
      float32x4_t v8 = v11[v6];
      float v9 = *v7++;
      float32x4_t v5 = vmlaq_n_f32(v5, v8, v9);
      ++v6;
    }
    while (v6 != 4);
    *a1 = v5;
  }
  return *(double *)v8.i64;
}

uint64_t cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,3u,false>,cva::Matrix<float,3u,1u,false>>(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = result;
  uint64_t v3 = *a2;
  if (*a2 == result || (float v4 = (float *)a2[1], v4 == (float *)result))
  {
    int v11 = 0;
    uint64_t v10 = 0;
    BOOL result = cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,3u,false>,cva::Matrix<float,3u,1u,false>>(&v10);
    *(void *)uint64_t v2 = v10;
    *(_DWORD *)(v2 + 8) = v11;
  }
  else
  {
    for (uint64_t i = 0; i != 3; ++i)
    {
      uint64_t v6 = 0;
      float v7 = 0.0;
      float32x4_t v8 = v4;
      do
      {
        float v9 = *v8++;
        float v7 = v7 + (float)(*(float *)(v3 + v6) * v9);
        v6 += 12;
      }
      while (v6 != 36);
      *(float *)(result + 4 * i) = v7;
      v3 += 4;
    }
  }
  return result;
}

void cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::MatrixMultExpr<cva::Matrix<float,3u,4u,false>,cva::Matrix<float,4u,4u,false>>,cva::Matrix<float,4u,1u,false>>(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + 8) == a1)
  {
    DWORD2(v12[0]) = 0;
    *(void *)&v12[0] = 0;
    cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::MatrixMultExpr<cva::Matrix<float,3u,4u,false>,cva::Matrix<float,4u,4u,false>>,cva::Matrix<float,4u,1u,false>>(v12, a2);
    *(void *)a1 = *(void *)&v12[0];
    *(_DWORD *)(a1 + 8) = DWORD2(v12[0]);
  }
  else
  {
    float v4 = *(void **)a2;
    memset(v12, 0, sizeof(v12));
    float32x4_t v5 = v12;
    cva::assign<false,false,cva::Matrix<float,3u,4u,false>,cva::Matrix<float,3u,4u,false>,cva::Matrix<float,4u,4u,false>>(v12, v4);
    uint64_t v6 = 0;
    float v7 = *(float **)(a2 + 8);
    do
    {
      uint64_t v8 = 0;
      float v9 = 0.0;
      uint64_t v10 = v7;
      do
      {
        float v11 = *v10++;
        float v9 = v9 + (float)(*(float *)((char *)v5 + v8) * v11);
        v8 += 12;
      }
      while (v8 != 48);
      *(float *)(a1 + 4 * v6++) = v9;
      float32x4_t v5 = (_OWORD *)((char *)v5 + 4);
    }
    while (v6 != 3);
  }
}

double cva::assign<false,false,cva::Matrix<float,3u,4u,false>,cva::Matrix<float,3u,4u,false>,cva::Matrix<float,4u,4u,false>>(_OWORD *a1, void *a2)
{
  uint64_t v3 = (_OWORD *)*a2;
  if ((_OWORD *)*a2 == a1 || (float v4 = (_OWORD *)a2[1], v4 == a1))
  {
    long long v14 = 0u;
    long long v15 = 0u;
    long long v13 = 0u;
    cva::assign<false,false,cva::Matrix<float,3u,4u,false>,cva::Matrix<float,3u,4u,false>,cva::Matrix<float,4u,4u,false>>(&v13);
    long long v12 = v14;
    *a1 = v13;
    a1[1] = v12;
    double result = *(double *)&v15;
    a1[2] = v15;
  }
  else
  {
    for (uint64_t i = 0; i != 4; ++i)
    {
      uint64_t v6 = 0;
      float v7 = v3;
      do
      {
        uint64_t v8 = 0;
        double result = 0.0;
        uint64_t v10 = (float *)&v4[i];
        do
        {
          float v11 = *v10++;
          *(float *)&double result = *(float *)&result + (float)(*(float *)((char *)v7 + v8) * v11);
          v8 += 12;
        }
        while (v8 != 48);
        *((_DWORD *)a1 + 3 * i + v6++) = LODWORD(result);
        float v7 = (_OWORD *)((char *)v7 + 4);
      }
      while (v6 != 3);
    }
  }
  return result;
}

void sub_1B8965C08(_Unwind_Exception *a1)
{
  float32x4_t v5 = v4;

  _Unwind_Resume(a1);
}

void sub_1B8966014(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  _Unwind_Resume(a1);
}

void sub_1B89668A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20,void *__p,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1B8966C24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id visitChildren(int a1, int a2, void *a3, void *a4, uint64_t a5, uint64_t a6, __n128 a7)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  id v40 = a3;
  id v33 = a4;
  long long v12 = objc_opt_new();
  int v38 = a1;
  long long v13 = [&stru_1F120C8F0 stringByPaddingToLength:a1 withString:@"\t" startingAtIndex:0];
  uint64_t v35 = objc_opt_new();
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  obuint64_t j = v33;
  uint64_t v14 = [obj countByEnumeratingWithState:&v45 objects:v50 count:16];
  if (v14)
  {
    uint64_t v15 = 0;
    uint64_t v16 = *(void *)v46;
    do
    {
      for (uint64_t i = 0; i != v14; ++i)
      {
        if (*(void *)v46 != v16) {
          objc_enumerationMutation(obj);
        }
        if ([*(id *)(*((void *)&v45 + 1) + 8 * i) intValue] == a2)
        {
          float v18 = [NSNumber numberWithInt:v15 + i];
          [v35 addObject:v18];
        }
      }
      uint64_t v14 = [obj countByEnumeratingWithState:&v45 objects:v50 count:16];
      uint64_t v15 = (v15 + i);
    }
    while (v14);
  }

  if (![v35 count])
  {
    uint64_t v28 = [&stru_1F120C8F0 stringByPaddingToLength:v38 - 1 withString:@"\t" startingAtIndex:0];

    uint64_t v29 = [NSString stringWithFormat:@"\t%@End Site\n", v28];
    [v12 appendString:v29];

    uint64_t v30 = [NSString stringWithFormat:@"\t%@{\n", v28];
    [v12 appendString:v30];

    simd_float4 v31 = [NSString stringWithFormat:@"\t%@\tOFFSET 0.0 0.0 0.0\n", v28];
    [v12 appendString:v31];

    id v34 = [NSString stringWithFormat:@"\t%@}\n", v28];
    objc_msgSend(v12, "appendString:");
    long long v13 = (void *)v28;
    goto LABEL_25;
  }
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  id v34 = v35;
  uint64_t v19 = [v34 countByEnumeratingWithState:&v41 objects:v49 count:16];
  if (!v19) {
    goto LABEL_25;
  }
  uint64_t v36 = *(void *)v42;
  do
  {
    for (uint64_t j = 0; j != v19; ++j)
    {
      if (*(void *)v42 != v36) {
        objc_enumerationMutation(v34);
      }
      float v21 = *(void **)(*((void *)&v41 + 1) + 8 * j);
      uint64_t v22 = NSString;
      float32x2_t v23 = objc_msgSend(v40, "objectAtIndexedSubscript:", (int)objc_msgSend(v21, "intValue"));
      int64x2_t v24 = [v22 stringWithFormat:@"%@JOINT %@\n", v13, v23];
      [v12 appendString:v24];

      float32x2_t v25 = [NSString stringWithFormat:@"%@{\n", v13];
      [v12 appendString:v25];

      [v12 appendFormat:@"\t%@OFFSET %f %f %f\n", v13, (float)(*(float *)(a5 + ((uint64_t)(int)objc_msgSend(v21, "intValue") << 6) + 48) * a7.n128_f32[0]), vmuls_lane_f32(a7.n128_f32[1], *(float32x2_t *)(a5 + ((uint64_t)(int)objc_msgSend(v21, "intValue") << 6) + 48), 1), (float)(a7.n128_f32[2] * *(float *)(a5 + 8 + ((uint64_t)(int)objc_msgSend(v21, "intValue") << 6) + 48))];
      if (a6)
      {
        if (a6 != 1) {
          goto LABEL_21;
        }
        int64x2_t v26 = [NSString stringWithFormat:@"\t%@CHANNELS 3 Xposition Yposition Zposition\n", v13];
        [v12 appendString:v26];
      }
      else
      {
        int64x2_t v26 = [NSString stringWithFormat:@"\t%@CHANNELS 3 Xrotation Yrotation Zrotation\n", v13];
        [v12 appendString:v26];
      }

LABEL_21:
      int v27 = visitChildren((v38 + 1), [v21 intValue], v40, obj, a5, a6, a7);
      [v12 appendString:v27];
      [v12 appendFormat:@"%@}\n", v13];
    }
    uint64_t v19 = [v34 countByEnumeratingWithState:&v41 objects:v49 count:16];
  }
  while (v19);
LABEL_25:

  return v12;
}

void sub_1B896720C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26)
{
  _Unwind_Resume(a1);
}

void sub_1B89675D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8967918(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL13_ARLogGeneralv_block_invoke_13()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "General");
  id v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObuint64_t j = (uint64_t)v0;
}

void sub_1B8969A5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va1, a10);
  va_start(va, a10);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void (*)(uint64_t *));
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  v14((uint64_t *)va);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

__CFString *NSStringFromARAltitudeSource(unint64_t a1)
{
  if (a1 > 3) {
    return @"???";
  }
  else {
    return off_1E61870E8[a1];
  }
}

id _ARLogTechnique_8()
{
  if (_ARLogTechnique_onceToken_12 != -1) {
    dispatch_once(&_ARLogTechnique_onceToken_12, &__block_literal_global_66);
  }
  os_log_t v0 = (void *)_ARLogTechnique_logObj_12;
  return v0;
}

id _ARLogSensor_5()
{
  if (_ARLogSensor_onceToken_9 != -1) {
    dispatch_once(&_ARLogSensor_onceToken_9, &__block_literal_global_228);
  }
  os_log_t v0 = (void *)_ARLogSensor_logObj_9;
  return v0;
}

void sub_1B896DA0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B896DB78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B896E4C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ARTexturedPlane::~ARTexturedPlane(ARTexturedPlane *this)
{
  std::__tree<std::array<unsigned char,16ul>>::destroy((uint64_t)&this[3].var4, (void *)this[3].var4.__tree_.__pair1_.__value_.__left_);
}

uint64_t std::set<std::array<unsigned char,16ul>>::set[abi:ne180100](uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)a1 = a1 + 8;
  std::set<std::array<unsigned char,16ul>>::insert[abi:ne180100]<std::__tree_const_iterator<std::array<unsigned char,16ul>,std::__tree_node<std::array<unsigned char,16ul>,void *> *,long>>((char *)a1, *(void **)a2, (void *)(a2 + 8));
  return a1;
}

void sub_1B896E650(_Unwind_Exception *a1)
{
  std::__tree<std::array<unsigned char,16ul>>::destroy(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

char *std::set<std::array<unsigned char,16ul>>::insert[abi:ne180100]<std::__tree_const_iterator<std::array<unsigned char,16ul>,std::__tree_node<std::array<unsigned char,16ul>,void *> *,long>>(char *result, void *a2, void *a3)
{
  if (a2 != a3)
  {
    float v4 = a2;
    float32x4_t v5 = (uint64_t **)result;
    uint64_t v6 = result + 8;
    do
    {
      double result = std::__tree<std::array<unsigned char,16ul>>::__emplace_hint_unique_key_args<std::array<unsigned char,16ul>,std::array<unsigned char,16ul> const&>(v5, v6, (uint64_t)v4 + 25, (void *)((char *)v4 + 25));
      float v7 = (void *)v4[1];
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          float v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v8 = (void *)v4[2];
          BOOL v9 = *v8 == (void)v4;
          float v4 = v8;
        }
        while (!v9);
      }
      float v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

char *std::__tree<std::array<unsigned char,16ul>>::__emplace_hint_unique_key_args<std::array<unsigned char,16ul>,std::array<unsigned char,16ul> const&>(uint64_t **a1, void *a2, uint64_t a3, _OWORD *a4)
{
  uint64_t v6 = (void **)std::__tree<std::array<unsigned char,16ul>>::__find_equal<std::array<unsigned char,16ul>>(a1, a2, &v11, &v10, a3);
  float v7 = (char *)*v6;
  if (!*v6)
  {
    uint64_t v8 = (uint64_t **)v6;
    float v7 = (char *)operator new(0x30uLL);
    *(_OWORD *)(v7 + 25) = *a4;
    _ZNSt3__16__treeINS_12__value_typeIyDv4_fEENS_19__map_value_compareIyS3_NS_4lessIyEELb1EEENS_9allocatorIS3_EEE16__insert_node_atEPNS_15__tree_end_nodeIPNS_16__tree_node_baseIPvEEEERSF_SF_(a1, v11, v8, (uint64_t *)v7);
  }
  return v7;
}

void *std::__tree<std::array<unsigned char,16ul>>::__find_equal<std::array<unsigned char,16ul>>(void *a1, void *a2, void *a3, void *a4, uint64_t a5)
{
  if (a1 + 1 != a2)
  {
    uint64_t v5 = 0;
    while (1)
    {
      unsigned int v6 = *(unsigned __int8 *)(a5 + v5);
      unsigned int v7 = *((unsigned __int8 *)a2 + v5 + 25);
      if (v6 < v7) {
        break;
      }
      BOOL v8 = v7 < v6 || v5++ == 15;
      if (v8)
      {
        uint64_t v9 = 0;
        while (1)
        {
          unsigned int v10 = *((unsigned __int8 *)a2 + v9 + 25);
          unsigned int v11 = *(unsigned __int8 *)(a5 + v9);
          if (v10 < v11) {
            break;
          }
          if (v11 < v10 || v9++ == 15)
          {
            *a3 = a2;
            *a4 = a2;
            return a4;
          }
        }
        uint64_t v22 = a2[1];
        if (v22)
        {
          float32x2_t v23 = (void *)a2[1];
          do
          {
            a4 = v23;
            float32x2_t v23 = (void *)*v23;
          }
          while (v23);
        }
        else
        {
          int64x2_t v24 = a2;
          do
          {
            a4 = (void *)v24[2];
            BOOL v8 = *a4 == (void)v24;
            int64x2_t v24 = a4;
          }
          while (!v8);
        }
        if (a4 != a1 + 1)
        {
          uint64_t v25 = 0;
          while (1)
          {
            unsigned int v26 = *(unsigned __int8 *)(a5 + v25);
            unsigned int v27 = *((unsigned __int8 *)a4 + v25 + 25);
            if (v26 < v27) {
              break;
            }
            if (v27 < v26 || v25++ == 15) {
              return std::__tree<std::array<unsigned char,16ul>>::__find_equal<std::array<unsigned char,16ul>>((uint64_t)a1, a3, a5);
            }
          }
        }
        if (v22)
        {
          *a3 = a4;
        }
        else
        {
          *a3 = a2;
          return a2 + 1;
        }
        return a4;
      }
    }
  }
  uint64_t v13 = *a2;
  if ((void *)*a1 == a2)
  {
    uint64_t v15 = a2;
  }
  else
  {
    if (v13)
    {
      uint64_t v14 = (void *)*a2;
      do
      {
        uint64_t v15 = v14;
        uint64_t v14 = (void *)v14[1];
      }
      while (v14);
    }
    else
    {
      uint64_t v16 = a2;
      do
      {
        uint64_t v15 = (void *)v16[2];
        BOOL v8 = *v15 == (void)v16;
        uint64_t v16 = v15;
      }
      while (v8);
    }
    uint64_t v17 = 0;
    while (1)
    {
      unsigned int v18 = *((unsigned __int8 *)v15 + v17 + 25);
      unsigned int v19 = *(unsigned __int8 *)(a5 + v17);
      if (v18 < v19) {
        break;
      }
      if (v19 < v18 || v17++ == 15) {
        return std::__tree<std::array<unsigned char,16ul>>::__find_equal<std::array<unsigned char,16ul>>((uint64_t)a1, a3, a5);
      }
    }
  }
  if (v13)
  {
    *a3 = v15;
    return v15 + 1;
  }
  else
  {
    *a3 = a2;
    return a2;
  }
}

void *std::__tree<std::array<unsigned char,16ul>>::__find_equal<std::array<unsigned char,16ul>>(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = *(void **)(a1 + 8);
  double result = (void *)(a1 + 8);
  float v4 = v5;
  if (v5)
  {
LABEL_2:
    while (2)
    {
      uint64_t v6 = 0;
      unsigned int v7 = v4;
      do
      {
        unsigned int v8 = *(unsigned __int8 *)(a3 + v6);
        unsigned int v9 = *((unsigned __int8 *)v7 + v6 + 25);
        if (v8 < v9)
        {
          float v4 = (void *)*v7;
          double result = v7;
          if (*v7) {
            goto LABEL_2;
          }
          goto LABEL_22;
        }
      }
      while (v9 >= v8 && v6++ != 15);
      uint64_t v11 = 0;
      while (1)
      {
        unsigned int v12 = *((unsigned __int8 *)v7 + v11 + 25);
        unsigned int v13 = *(unsigned __int8 *)(a3 + v11);
        if (v12 < v13) {
          break;
        }
        if (v13 < v12 || v11++ == 15) {
          goto LABEL_22;
        }
      }
      double result = v7 + 1;
      float v4 = (void *)v7[1];
      if (v4) {
        continue;
      }
      break;
    }
  }
  else
  {
    unsigned int v7 = result;
  }
LABEL_22:
  *a2 = v7;
  return result;
}

void sub_1B896F2DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, os_activity_scope_state_s state)
{
}

id ARSessionRunOptionsToString(char a1)
{
  uint64_t v2 = objc_opt_new();
  uint64_t v3 = v2;
  if (a1)
  {
    unsigned int v8 = @"ResetTracking";
  }
  else
  {
    if ((a1 & 2) == 0)
    {
      if ((a1 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_12;
    }
    unsigned int v8 = @"RemoveExistingAnchors";
  }
  [v2 addObject:v8];
  if ((a1 & 4) == 0)
  {
LABEL_4:
    if ((a1 & 8) == 0) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
LABEL_12:
  [v3 addObject:@"StopTrackedRaycasts"];
  if ((a1 & 8) != 0) {
LABEL_5:
  }
    [v3 addObject:@"ResetSceneReconstruction"];
LABEL_6:
  float v4 = NSString;
  uint64_t v5 = [v3 componentsJoinedByString:@" | "];
  uint64_t v6 = [v4 stringWithFormat:@"(%@)", v5];

  return v6;
}

void sub_1B89717C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,os_activity_scope_state_s state)
{
}

void sub_1B897195C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
}

void sub_1B8971AC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
}

void sub_1B8977ED0(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B897D734(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__3(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__3(uint64_t a1)
{
}

void sub_1B897DF68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,os_activity_scope_state_s state)
{
}

void sub_1B897E5D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, os_activity_scope_state_s state)
{
}

void sub_1B897E9E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,os_activity_scope_state_s state)
{
}

void sub_1B897F308(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
}

void sub_1B897FD6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
}

void sub_1B89802E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
}

void sub_1B8980994(_Unwind_Exception *a1)
{
  objc_destroyWeak((id *)(v1 - 128));
  _Unwind_Resume(a1);
}

void sub_1B8980F00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,os_activity_scope_state_s state)
{
  objc_destroyWeak((id *)(v25 - 144));
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_1B89812A8(_Unwind_Exception *a1)
{
  objc_destroyWeak((id *)(v1 - 128));
  _Unwind_Resume(a1);
}

void sub_1B89815DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,os_activity_scope_state_s state)
{
}

void sub_1B89818FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
}

void sub_1B8981BF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
}

void sub_1B8982134(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id location, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43)
{
  objc_destroyWeak(&location);
  objc_destroyWeak(a10);
  _Block_object_dispose(&a43, 8);
  objc_destroyWeak((id *)(v43 - 256));
  _Unwind_Resume(a1);
}

void sub_1B8982654(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
}

void sub_1B8982A28(_Unwind_Exception *a1)
{
  objc_destroyWeak((id *)(v1 - 144));
  _Unwind_Resume(a1);
}

void sub_1B8982D44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
}

__CFString *NSStringFromCFUUIDRef(CFUUIDRef uuid)
{
  uint64_t v1 = (__CFString *)CFUUIDCreateString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], uuid);
  return v1;
}

id _ARLogSensor_6()
{
  if (_ARLogSensor_onceToken_11 != -1) {
    dispatch_once(&_ARLogSensor_onceToken_11, &__block_literal_global_218);
  }
  os_log_t v0 = (void *)_ARLogSensor_logObj_11;
  return v0;
}

void sub_1B8988484(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
}

void sub_1B8989410(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B8989A08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

id _ARLogTechnique_9()
{
  if (_ARLogTechnique_onceToken_13 != -1) {
    dispatch_once(&_ARLogTechnique_onceToken_13, &__block_literal_global_73);
  }
  os_log_t v0 = (void *)_ARLogTechnique_logObj_13;
  return v0;
}

void sub_1B898B8F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44,uint64_t a45,void (*a46)(char *))
{
}

uint64_t _archive_open_callback(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return 0;
  }
  archive_set_error();
  return 4294967266;
}

uint64_t _archive_write_callback(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  return a4;
}

uint64_t _archive_close_callback()
{
  return 0;
}

id ARLocationSensorDidOutputSensorDataClassApprovedList()
{
  if (ARLocationSensorDidOutputSensorDataClassApprovedList_onceToken != -1) {
    dispatch_once(&ARLocationSensorDidOutputSensorDataClassApprovedList_onceToken, &__block_literal_global_75);
  }
  os_log_t v0 = (void *)ARLocationSensorDidOutputSensorDataClassApprovedList_locationSensorDidOutputSensorDataClassApprovedList;
  return v0;
}

void __ARLocationSensorDidOutputSensorDataClassApprovedList_block_invoke()
{
  _DWORD v4[2] = *MEMORY[0x1E4F143B8];
  os_log_t v0 = (void *)MEMORY[0x1E4F1CAD0];
  v4[0] = objc_opt_class();
  v4[1] = objc_opt_class();
  uint64_t v1 = [MEMORY[0x1E4F1C978] arrayWithObjects:v4 count:2];
  uint64_t v2 = [v0 setWithArray:v1];
  uint64_t v3 = (void *)ARLocationSensorDidOutputSensorDataClassApprovedList_locationSensorDidOutputSensorDataClassApprovedList;
  ARLocationSensorDidOutputSensorDataClassApprovedList_locationSensorDidOutputSensorDataClassApprovedList = v2;
}

id ARLocationSensorUpdateEstimationFromVIOPoseClassApprovedList()
{
  if (ARLocationSensorUpdateEstimationFromVIOPoseClassApprovedList_onceToken != -1) {
    dispatch_once(&ARLocationSensorUpdateEstimationFromVIOPoseClassApprovedList_onceToken, &__block_literal_global_5_0);
  }
  os_log_t v0 = (void *)ARLocationSensorUpdateEstimationFromVIOPoseClassApprovedList_locationSensorUpdateEstimationFromVIOPoseClassApprovedList;
  return v0;
}

void __ARLocationSensorUpdateEstimationFromVIOPoseClassApprovedList_block_invoke()
{
  _DWORD v4[2] = *MEMORY[0x1E4F143B8];
  os_log_t v0 = (void *)MEMORY[0x1E4F1CAD0];
  v4[0] = objc_opt_class();
  v4[1] = objc_opt_class();
  uint64_t v1 = [MEMORY[0x1E4F1C978] arrayWithObjects:v4 count:2];
  uint64_t v2 = [v0 setWithArray:v1];
  uint64_t v3 = (void *)ARLocationSensorUpdateEstimationFromVIOPoseClassApprovedList_locationSensorUpdateEstimationFromVIOPoseClassApprovedList;
  ARLocationSensorUpdateEstimationFromVIOPoseClassApprovedList_locationSensorUpdateEstimationFromVIOPoseClassApprovedList = v2;
}

id ARRemoteLocationSensorClientInterface()
{
  os_log_t v0 = ARRemoteSensorClientInterfaceWithProtocol((uint64_t)&unk_1F1285920);
  uint64_t v1 = ARLocationSensorDidOutputSensorDataClassApprovedList();
  [v0 setClasses:v1 forSelector:sel_sensorDidOutputSensorData_ argumentIndex:0 ofReply:0];

  return v0;
}

id ARRemoteLocationSensorServiceInterface()
{
  os_log_t v0 = ARRemoteSensorServiceInterfaceWithProtocol((uint64_t)&unk_1F1285980);
  uint64_t v1 = ARLocationSensorUpdateEstimationFromVIOPoseClassApprovedList();
  [v0 setClasses:v1 forSelector:sel_updateEstimationFromVIOPose_imageData_ argumentIndex:1 ofReply:0];

  return v0;
}

id _ARLogSensor_7()
{
  if (_ARLogSensor_onceToken_12 != -1) {
    dispatch_once(&_ARLogSensor_onceToken_12, &__block_literal_global_114_0);
  }
  os_log_t v0 = (void *)_ARLogSensor_logObj_12;
  return v0;
}

void sub_1B8992F80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__4(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__4(uint64_t a1)
{
}

void sub_1B8993738(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8993790(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89937E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id _ARLogSession(void)
{
  if (_ARLogSession(void)::onceToken != -1) {
    dispatch_once(&_ARLogSession(void)::onceToken, &__block_literal_global_76);
  }
  os_log_t v0 = (void *)_ARLogSession(void)::logObj;
  return v0;
}

void sub_1B8993BA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t anonymous namespace'::_CV3DODTCreateWithOptionsConfigAndModel(_anonymous_namespace_ *this, CV3DODTContext **a2, const __CFDictionary *a3, CV3DMLModel *a4)
{
  CV3DODTConfigCreate();
  uint64_t v4 = CV3DODTCreateWithOptionsConfigAndModel();
  CV3DODTConfigRelease();
  return v4;
}

void sub_1B8993E74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8993FE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8994374(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8994494(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B899450C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8994580(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89945F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8994A10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8994EBC(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1B8995080(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89952D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89955C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89957BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  a9.super_class = (Class)ARODTHandleManager;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1B8995A18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8995AB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8995CC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8995D4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8995EB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL13_ARLogSessionv_block_invoke()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "Session");
  uint64_t v1 = (void *)_ARLogSession(void)::logObj;
  _ARLogSession(void)::logObuint64_t j = (uint64_t)v0;
}

void ___ZL15_ARLogTechniquev_block_invoke_5()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "Technique");
  uint64_t v1 = (void *)_ARLogTechnique(void)::logObj;
  _ARLogTechnique(void)::logObuint64_t j = (uint64_t)v0;
}

__CFString *ARMLDepthDataSourceDescription(uint64_t a1)
{
  uint64_t v1 = @"Unknown";
  if (a1 == 1) {
    uint64_t v1 = @"Estimated Depth";
  }
  if (a1 == 2) {
    return @"Apple Depth";
  }
  else {
    return v1;
  }
}

void sub_1B8996514(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89966CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8996B74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

void sub_1B8996CB0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8996F34(_Unwind_Exception *a1)
{
  uint64_t v4 = *(std::__shared_weak_count **)(v2 - 88);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }

  _Unwind_Resume(a1);
}

void sub_1B8997270(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26)
{
  MEMORY[0x1BA9C56C0](v26, 0x1020C405A8B1BAELL);
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void std::vector<arkit::Landmark>::reserve(char **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 2) < a2)
  {
    if (a2 >= 0x1555555555555556) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v5 = a1[1] - *a1;
    uint64_t v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<float,3u,1u,false>>>(v3, a2);
    unsigned int v7 = &v6[v5];
    unsigned int v9 = &v6[12 * v8];
    uint64_t v11 = *a1;
    unsigned int v10 = a1[1];
    unsigned int v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        uint64_t v13 = *(void *)(v10 - 12);
        v10 -= 12;
        *(void *)(v12 - 12) = v13;
        v12 -= 12;
        uint8_t v12[8] = v10[8];
      }
      while (v10 != v11);
      unsigned int v10 = *a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

void std::shared_ptr<arkit::FaceTrackingData>::shared_ptr[abi:ne180100]<arkit::FaceTrackingData,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1B8997530(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  a10 = 0;
  if (v10) {
    std::default_delete<arkit::FaceTrackingData>::operator()[abi:ne180100]((uint64_t)&a10, v10);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<arkit::FaceTrackingData *,std::shared_ptr<arkit::FaceTrackingData>::__shared_ptr_default_delete<arkit::FaceTrackingData,arkit::FaceTrackingData>,std::allocator<arkit::FaceTrackingData>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BA9C56C0);
}

void std::__shared_ptr_pointer<arkit::FaceTrackingData *,std::shared_ptr<arkit::FaceTrackingData>::__shared_ptr_default_delete<arkit::FaceTrackingData,arkit::FaceTrackingData>,std::allocator<arkit::FaceTrackingData>>::__on_zero_shared(uint64_t a1)
{
}

uint64_t std::__shared_ptr_pointer<arkit::FaceTrackingData *,std::shared_ptr<arkit::FaceTrackingData>::__shared_ptr_default_delete<arkit::FaceTrackingData,arkit::FaceTrackingData>,std::allocator<arkit::FaceTrackingData>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void std::default_delete<arkit::FaceTrackingData>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(void **)(a2 + 40);
    if (v2)
    {
      *(void *)(a2 + 48) = v2;
      operator delete(v2);
    }
    JUMPOUT(0x1BA9C56C0);
  }
}

BOOL std::type_info::operator==[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a2 + 8);
  if (v2 == v3) {
    return 1;
  }
  if ((v3 & v2) < 0 != __OFSUB__(v2, v3)) {
    return strcmp((const char *)(v2 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL)) == 0;
  }
  return 0;
}

void sub_1B899A334(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B899A4A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  a9.super_class = (Class)ARPlaneEstimationTechnique;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1B899A5D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B899A6D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B899A7BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B899A954(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B899AB38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B899AC30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B899AD74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B899B224(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  ((void (*)(char *))a44)(&a42);
  if (__p)
  {
    a69 = (uint64_t)__p;
    operator delete(__p);
  }
  long long v73 = *(void **)(v71 - 208);
  if (v73)
  {
    *(void *)(v71 - 200) = v73;
    operator delete(v73);
  }

  _Unwind_Resume(a1);
}

void std::vector<double>::reserve(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 3)
  {
    if (a2 >> 61) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    uint64_t v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>(v3, a2);
    unsigned int v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    unsigned int v9 = &v6[8 * v8];
    uint64_t v10 = (char *)*a1;
    uint64_t v11 = (char *)a1[1];
    unsigned int v12 = v7;
    if (v11 != *a1)
    {
      unsigned int v12 = v7;
      do
      {
        uint64_t v13 = *((void *)v11 - 1);
        v11 -= 8;
        *((void *)v12 - 1) = v13;
        v12 -= 8;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

void ___ZL15_ARLogTechniquev_block_invoke_6()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "Technique");
  uint64_t v1 = (void *)_ARLogTechnique(void)::logObj;
  _ARLogTechnique(void)::logObuint64_t j = (uint64_t)v0;
}

void *std::vector<CV3DSurfaceDetectionPoint3D>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::vector<float>>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v4 = (char *)a1[1];
    size_t v5 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v4, v5);
    a1[1] = &v4[v5];
  }
  return a1;
}

void sub_1B899B4D4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *std::back_insert_iterator<std::vector<double>>::operator=[abi:ne180100](uint64_t *a1, void *a2)
{
  uint64_t v4 = *a1;
  size_t v5 = *(void **)(*a1 + 8);
  uint64_t v6 = (void *)(*a1 + 16);
  if ((unint64_t)v5 >= *v6)
  {
    uint64_t v8 = *(void **)v4;
    uint64_t v9 = ((uint64_t)v5 - *(void *)v4) >> 3;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = *v6 - (void)v8;
    if (v11 >> 2 > v10) {
      unint64_t v10 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>((uint64_t)v6, v12);
      uint64_t v8 = *(void **)v4;
      size_t v5 = *(void **)(v4 + 8);
    }
    else
    {
      uint64_t v13 = 0;
    }
    uint64_t v14 = &v13[8 * v9];
    uint64_t v15 = &v13[8 * v12];
    *(void *)uint64_t v14 = *a2;
    unsigned int v7 = v14 + 8;
    while (v5 != v8)
    {
      uint64_t v16 = *--v5;
      *((void *)v14 - 1) = v16;
      v14 -= 8;
    }
    *(void *)uint64_t v4 = v14;
    *(void *)(v4 + 8) = v7;
    *(void *)(v4 + 16) = v15;
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    *size_t v5 = *a2;
    unsigned int v7 = v5 + 1;
  }
  *(void *)(v4 + 8) = v7;
  return a1;
}

void sub_1B899B6C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B899B9E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B899BD24(_Unwind_Exception *a1)
{
  uint64_t v8 = *(void **)(v6 - 216);
  if (v8)
  {
    *(void *)(v6 - 208) = v8;
    operator delete(v8);
  }
  uint64_t v9 = *(void **)(v6 - 192);
  if (v9)
  {
    *(void *)(v6 - 184) = v9;
    operator delete(v9);
  }

  _Unwind_Resume(a1);
}

void std::vector<CV3DHitTestPoint3D>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 2);
  BOOL v3 = a2 >= v2;
  unint64_t v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<CV3DHitTestPoint3D>::__append((char **)a1, v4);
  }
  else if (!v3)
  {
    *(void *)(a1 + 8) = *(void *)a1 + 12 * a2;
  }
}

void std::vector<CV3DHitTestCovariance3D>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = 0x8E38E38E38E38E39 * ((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 2);
  BOOL v3 = a2 >= v2;
  unint64_t v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<CV3DHitTestCovariance3D>::__append((void **)a1, v4);
  }
  else if (!v3)
  {
    *(void *)(a1 + 8) = *(void *)a1 + 36 * a2;
  }
}

void *std::vector<CV3DHitTestPoint3D>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<cva::Matrix<float,3u,1u,false>>::__vallocate[abi:ne180100](a1, a2);
    unint64_t v4 = (char *)a1[1];
    size_t v5 = 12 * ((12 * a2 - 12) / 0xC) + 12;
    bzero(v4, v5);
    a1[1] = &v4[v5];
  }
  return a1;
}

void sub_1B899BED0(_Unwind_Exception *exception_object)
{
  BOOL v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<CV3DHitTestCovariance3D>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<CV3DHitTestCovariance3D>::__vallocate[abi:ne180100](a1, a2);
    unint64_t v4 = (char *)a1[1];
    size_t v5 = 36 * ((36 * a2 - 36) / 0x24) + 36;
    bzero(v4, v5);
    a1[1] = &v4[v5];
  }
  return a1;
}

void sub_1B899BF74(_Unwind_Exception *exception_object)
{
  BOOL v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<CV3DHitTestCovariance3D>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x71C71C71C71C71DLL) {
    std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
  }
  double result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CV3DHitTestCovariance3D>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[36 * v4];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<CV3DHitTestCovariance3D>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x71C71C71C71C71DLL) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(36 * a2);
}

void std::vector<CV3DHitTestPoint3D>::__append(char **a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  size_t v5 = v6;
  unsigned int v7 = *(char **)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 2) >= a2)
  {
    if (a2)
    {
      size_t v13 = 12 * ((12 * a2 - 12) / 0xC) + 12;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 2);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0x1555555555555555) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 2);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0xAAAAAAAAAAAAAAALL) {
      unint64_t v11 = 0x1555555555555555;
    }
    else {
      unint64_t v11 = v9;
    }
    if (v11) {
      unint64_t v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<float,3u,1u,false>>>(v4, v11);
    }
    else {
      unint64_t v12 = 0;
    }
    uint64_t v14 = &v12[12 * v8];
    uint64_t v15 = &v12[12 * v11];
    size_t v16 = 12 * ((12 * a2 - 12) / 0xC) + 12;
    bzero(v14, v16);
    uint64_t v17 = &v14[v16];
    unsigned int v19 = *a1;
    unsigned int v18 = a1[1];
    if (v18 != *a1)
    {
      do
      {
        uint64_t v20 = *(void *)(v18 - 12);
        v18 -= 12;
        int v21 = *((_DWORD *)v18 + 2);
        *(void *)(v14 - 12) = v20;
        v14 -= 12;
        *((_DWORD *)v14 + 2) = v21;
      }
      while (v18 != v19);
      unsigned int v18 = *a1;
    }
    *a1 = v14;
    a1[1] = v17;
    a1[2] = v15;
    if (v18)
    {
      operator delete(v18);
    }
  }
}

void std::vector<CV3DHitTestCovariance3D>::__append(void **a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  size_t v5 = v6;
  unsigned int v7 = *(char **)(v4 - 8);
  if (0x8E38E38E38E38E39 * ((v6 - v7) >> 2) >= a2)
  {
    if (a2)
    {
      size_t v13 = 36 * ((36 * a2 - 36) / 0x24) + 36;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    unint64_t v8 = 0x8E38E38E38E38E39 * ((v7 - (unsigned char *)*a1) >> 2);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0x71C71C71C71C71CLL) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0x8E38E38E38E38E39 * ((v5 - (unsigned char *)*a1) >> 2);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x38E38E38E38E38ELL) {
      unint64_t v11 = 0x71C71C71C71C71CLL;
    }
    else {
      unint64_t v11 = v9;
    }
    if (v11) {
      unint64_t v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CV3DHitTestCovariance3D>>(v4, v11);
    }
    else {
      unint64_t v12 = 0;
    }
    uint64_t v14 = &v12[36 * v8];
    uint64_t v15 = &v12[36 * v11];
    size_t v16 = 36 * ((36 * a2 - 36) / 0x24) + 36;
    bzero(v14, v16);
    uint64_t v17 = &v14[v16];
    unsigned int v19 = (char *)*a1;
    unsigned int v18 = (char *)a1[1];
    if (v18 != *a1)
    {
      do
      {
        long long v20 = *(_OWORD *)(v18 - 36);
        long long v21 = *(_OWORD *)(v18 - 20);
        *((_DWORD *)v14 - 1) = *((_DWORD *)v18 - 1);
        *(_OWORD *)(v14 - 20) = v21;
        *(_OWORD *)(v14 - 36) = v20;
        v14 -= 36;
        v18 -= 36;
      }
      while (v18 != v19);
      unsigned int v18 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v17;
    a1[2] = v15;
    if (v18)
    {
      operator delete(v18);
    }
  }
}

void sub_1B899C42C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B899C864(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_1B899CCFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B899CEA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL13_ARLogGeneralv_block_invoke_14()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "General");
  uint64_t v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObuint64_t j = (uint64_t)v0;
}

void ___ZL15_ARLogTechniquev_block_invoke_7()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "Technique");
  uint64_t v1 = (void *)_ARLogTechnique(void)::logObj;
  _ARLogTechnique(void)::logObuint64_t j = (uint64_t)v0;
}

uint64_t ARRemoteSensorClientInterfaceWithProtocol(uint64_t a1)
{
  return [MEMORY[0x1E4F29280] interfaceWithProtocol:a1];
}

uint64_t ARRemoteSensorServiceInterfaceWithProtocol(uint64_t a1)
{
  return [MEMORY[0x1E4F29280] interfaceWithProtocol:a1];
}

id _ARLogSensor_8()
{
  if (_ARLogSensor_onceToken_13 != -1) {
    dispatch_once(&_ARLogSensor_onceToken_13, &__block_literal_global_81);
  }
  os_log_t v0 = (void *)_ARLogSensor_logObj_13;
  return v0;
}

void sub_1B899D61C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 64), 8);
  _Unwind_Resume(a1);
}

id _ARLogTechnique_10()
{
  if (_ARLogTechnique_onceToken_16 != -1) {
    dispatch_once(&_ARLogTechnique_onceToken_16, &__block_literal_global_79_0);
  }
  os_log_t v0 = (void *)_ARLogTechnique_logObj_16;
  return v0;
}

void sub_1B89A11E4(_Unwind_Exception *a1)
{
}

void AppClipCodeUpdateCallbackHandler(void *a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  uint64_t v84 = *MEMORY[0x1E4F143B8];
  kdebug_trace();
  unint64_t v11 = a1;
  if (!a8)
  {
    *(double *)&long long v74 = 0.0;
    uint64_t NumberOfTrackingData = AppC3DTrackingResultGetNumberOfTrackingData();
    kdebug_trace();
    *(void *)vImage_Buffer buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&uint8_t buf[16] = 0x2020000000;
    uint64_t v83 = 0;
    uint64_t v14 = (void *)[objc_alloc(MEMORY[0x1E4F1CA60]) initWithCapacity:NumberOfTrackingData];
    if (!NumberOfTrackingData)
    {
LABEL_61:
      uint64_t v51 = objc_opt_new();
      [v51 setTrackedAppClipCodes:v14];
      long long v75 = v51;
      uint64_t v52 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v75 count:1];
      [v11 pushResultData:v52 forTimestamp:a2];

      [v14 count];
      kdebug_trace();

      _Block_object_dispose(buf, 8);
      goto LABEL_62;
    }
    double v15 = 0.0;
    while (1)
    {
      *(double *)&long long v74 = 0.0;
      AppC3DTrackingResultCopyTransform();
      double log = v17;
      double theData = v16;
      obuint64_t j = v19;
      double v60 = v18;
      double v20 = *(double *)&v74;
      if (*(double *)&v74 == 0.0)
      {
        uint64_t Id = AppC3DTrackingResultGetId();
        double v20 = *(double *)&v74;
        if (*(double *)&v74 == 0.0)
        {
          double v20 = [NSNumber numberWithUnsignedLong:Id];
          int64x2_t v24 = [v14 objectForKey:*(void *)&v20];

          if (v24)
          {
            uint64_t v25 = _ARLogTechnique_10();
            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)float v76 = 138412546;
              double v77 = v20;
              __int16 v78 = 2048;
              double v79 = a2;
              _os_log_impl(&dword_1B88A2000, v25, OS_LOG_TYPE_ERROR, "ARAppClipCodeTechnique: Duplicate instance ID %@ detected at time %F", v76, 0x16u);
            }
            goto LABEL_35;
          }
          AppC3DTrackingResultGetConfidence();
          uint64_t v25 = v74;
          if (*(double *)&v74 != 0.0)
          {
            unsigned int v27 = _ARLogTechnique_10();
            if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)float v76 = 134218498;
              double v77 = a2;
              __int16 v78 = 2048;
              double v79 = v15;
              __int16 v80 = 2112;
              simd_float4x4 v81 = v25;
              _os_log_impl(&dword_1B88A2000, v27, OS_LOG_TYPE_ERROR, "ARAppClipCodeTechnique: Could not retrieve confidence at time %F index:%lu Error: %@", v76, 0x20u);
            }
            goto LABEL_34;
          }
          int v28 = v26;
          if (+[ARAppClipCodeTechnique shouldRunCameraOrScannerPerformanceTestingMode])
          {
            uint64_t v29 = 1;
            goto LABEL_31;
          }
          uint64_t IsScaleReliable = AppC3DTrackingResultIsScaleReliable();
          uint64_t v25 = v74;
          if (*(double *)&v74 != 0.0)
          {
            unsigned int v27 = _ARLogTechnique_10();
            if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)float v76 = 134218498;
              double v77 = a2;
              __int16 v78 = 2048;
              double v79 = v15;
              __int16 v80 = 2112;
              simd_float4x4 v81 = v25;
              _os_log_impl(&dword_1B88A2000, v27, OS_LOG_TYPE_ERROR, "ARAppClipCodeTechnique: Could not determine scale reliability at time %F index:%lu Error: %@", v76, 0x20u);
            }
LABEL_34:

            uint64_t v33 = [v25 code];
            *(void *)(*(void *)&buf[8] + 24) = v33;
LABEL_35:

            goto LABEL_15;
          }
          uint64_t v29 = IsScaleReliable;
LABEL_31:
          AppC3DTrackingResultGetSize();
          uint64_t v25 = v74;
          if (*(double *)&v74 != 0.0)
          {
            unsigned int v27 = _ARLogTechnique_10();
            if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)float v76 = 134218498;
              double v77 = a2;
              __int16 v78 = 2048;
              double v79 = v15;
              __int16 v80 = 2112;
              simd_float4x4 v81 = v25;
              _os_log_impl(&dword_1B88A2000, v27, OS_LOG_TYPE_ERROR, "ARAppClipCodeTechnique: Could not retrieve size at time %F index:%lu Error: %@", v76, 0x20u);
            }
            goto LABEL_34;
          }
          double v34 = v31;
          double v35 = v32;
          uint64_t v25 = objc_opt_new();
          -[NSObject setCodeToWorldVisionTransform:](v25, "setCodeToWorldVisionTransform:", theData, log, v60, obj);
          -[NSObject setSize:](v25, "setSize:", v34, v35);
          LODWORD(v36) = v28;
          [v25 setConfidence:v36];
          [v25 setIsScaleReliable:v29];
          [v25 setUrlDecodingStateInternal:0];
          [v14 setObject:v25 forKey:*(void *)&v20];
          theDataa = (void *)AppC3DTrackingResultCreateData();
          uint64_t v37 = v74;
          if (*(double *)&v74 == 0.0 && theDataa)
          {
            if (CFDataGetLength((CFDataRef)theDataa))
            {
              AppC3DTrackingResultGetMetadata();
              loga = v74;
              if (*(double *)&v74 != 0.0)
              {
                int v38 = _ARLogTechnique_10();
                if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)float v76 = 134218498;
                  double v77 = a2;
                  __int16 v78 = 2048;
                  double v79 = v15;
                  __int16 v80 = 2112;
                  simd_float4x4 v81 = loga;
                  _os_log_impl(&dword_1B88A2000, v38, OS_LOG_TYPE_ERROR, "ARAppClipCodeTechnique: Could not access result metadata at time %F index:%lu Error: %@", v76, 0x20u);
                }
                goto LABEL_42;
              }
              unsigned int DataVersion = AppC3DTrackingResultGetDataVersion();
              loga = v74;
              if (*(double *)&v74 == 0.0)
              {
                uint64_t v42 = DataVersion;
                [v25 setUrlEncodingVersion:DataVersion];
                uint64_t v55 = v42;
                loga = [NSNumber numberWithLong:v42];
                id obja = v11[13];
                objc_sync_enter(obja);
                uint64_t v43 = [v11[13] objectForKeyedSubscript:theDataa];
                __n128 v61 = [v43 objectForKeyedSubscript:loga];

                objc_sync_exit(obja);
                if (v61)
                {
                  long long v44 = [v61 url];
                  [v25 setUrl:v44];

                  -[NSObject setUrlDecodingStateInternal:](v25, "setUrlDecodingStateInternal:", [v61 urlDecodingStateInternal]);
                }
                else
                {
                  id v53 = v11[13];
                  objc_sync_enter(v53);
                  long long v45 = [v11[13] objectForKeyedSubscript:theDataa];
                  BOOL v46 = v45 == 0;

                  if (v46)
                  {
                    long long v47 = objc_opt_new();
                    [v11[13] setObject:v47 forKeyedSubscript:theDataa];
                  }
                  objb = objc_opt_new();
                  [objb setUrlDecodingStateInternal:2];
                  long long v48 = [v11[13] objectForKeyedSubscript:theDataa];
                  [v48 setObject:objb forKeyedSubscript:loga];

                  objc_sync_exit(v53);
                  id objc = v11[14];
                  int v49 = [v11 ignoreURLLimitation];
                  v67[0] = MEMORY[0x1E4F143A8];
                  unsigned int v54 = v49 ^ 1;
                  v67[1] = 3221225472;
                  v67[2] = __AppClipCodeUpdateCallbackHandler_block_invoke;
                  uint64_t v67[3] = &unk_1E6187740;
                  double v72 = a2;
                  double v73 = v15;
                  uint64_t v71 = buf;
                  long long v68 = v11;
                  id v50 = theDataa;
                  id v69 = v50;
                  long long v70 = loga;
                  [objc decodeURLWithEncodedData:v50 codingVersion:v55 requiresAuthorization:v54 completionHandler:v67];
                }
              }
              else
              {
                int v38 = _ARLogTechnique_10();
                if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)float v76 = 134218498;
                  double v77 = a2;
                  __int16 v78 = 2048;
                  double v79 = v15;
                  __int16 v80 = 2112;
                  simd_float4x4 v81 = loga;
                  _os_log_impl(&dword_1B88A2000, v38, OS_LOG_TYPE_ERROR, "ARAppClipCodeTechnique: Could not get URL coding version from result metadata at time %F index:%lu Error: %@", v76, 0x20u);
                }
LABEL_42:

                uint64_t v39 = [loga code];
                *(void *)(*(void *)&buf[8] + 24) = v39;
                [v25 setUrlDecodingStateInternal:1];
              }

              goto LABEL_35;
            }
            uint64_t v37 = v74;
          }
          if (v37)
          {
            logb = _ARLogTechnique_10();
            if (os_log_type_enabled(logb, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)float v76 = 134218498;
              double v77 = a2;
              __int16 v78 = 2048;
              double v79 = v15;
              __int16 v80 = 2112;
              simd_float4x4 v81 = v37;
              _os_log_impl(&dword_1B88A2000, logb, OS_LOG_TYPE_INFO, "ARAppClipCodeTechnique: Could not create decoded data at time %F index:%lu Error: %@", v76, 0x20u);
            }

            uint64_t v40 = [v37 code];
            *(void *)(*(void *)&buf[8] + 24) = v40;
          }
          if (theDataa) {
            CFRelease(theDataa);
          }
          goto LABEL_35;
        }
        long long v21 = _ARLogTechnique_10();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)float v76 = 134218498;
          double v77 = a2;
          __int16 v78 = 2048;
          double v79 = v15;
          __int16 v80 = 2112;
          simd_float4x4 v81 = *(NSObject **)&v20;
          _os_log_impl(&dword_1B88A2000, v21, OS_LOG_TYPE_ERROR, "ARAppClipCodeTechnique: Could not get id at time %F index:%lu Error: %@", v76, 0x20u);
        }
      }
      else
      {
        long long v21 = _ARLogTechnique_10();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)float v76 = 134218498;
          double v77 = a2;
          __int16 v78 = 2048;
          double v79 = v15;
          __int16 v80 = 2112;
          simd_float4x4 v81 = *(NSObject **)&v20;
          _os_log_impl(&dword_1B88A2000, v21, OS_LOG_TYPE_ERROR, "ARAppClipCodeTechnique: Could not copy tranform at time %F index:%lu Error: %@", v76, 0x20u);
        }
      }

      uint64_t v23 = [*(id *)&v20 code];
      *(void *)(*(void *)&buf[8] + 24) = v23;
LABEL_15:

      if (NumberOfTrackingData == ++*(void *)&v15) {
        goto LABEL_61;
      }
    }
  }
  unint64_t v12 = _ARLogTechnique_10();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)vImage_Buffer buf = 134218242;
    *(double *)&uint8_t buf[4] = a2;
    *(_WORD *)&buf[12] = 2112;
    *(void *)&buf[14] = a8;
    _os_log_impl(&dword_1B88A2000, v12, OS_LOG_TYPE_ERROR, "ARAppClipCodeTechnique: Error during app clip code tracking at time %F, Error: %@", buf, 0x16u);
  }

  [v11 pushResultData:MEMORY[0x1E4F1CBF0] forTimestamp:a2];
  [a8 code];
  kdebug_trace();

LABEL_62:
}

void sub_1B89A1DC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  objc_sync_exit(obj);
  _Block_object_dispose((const void *)(v17 - 192), 8);
  _Unwind_Resume(a1);
}

void __AppClipCodeUpdateCallbackHandler_block_invoke(void *a1, void *a2, void *a3)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    unsigned int v7 = _ARLogTechnique_10();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      uint64_t v8 = a1[8];
      uint64_t v9 = a1[9];
      int v25 = 134218498;
      uint64_t v26 = v8;
      __int16 v27 = 2048;
      uint64_t v28 = v9;
      __int16 v29 = 2112;
      id v30 = v6;
      _os_log_impl(&dword_1B88A2000, v7, OS_LOG_TYPE_ERROR, "ARAppClipCodeTechnique: Could not decode URL at time %F index:%lu Error: %@", (uint8_t *)&v25, 0x20u);
    }

    *(void *)(*(void *)(a1[7] + 8) + 24) = [v6 code];
    if ([v6 code])
    {
      if ([v6 code] == 1)
      {
        uint64_t v10 = 3;
      }
      else if ([v6 code] == 2)
      {
        uint64_t v10 = 4;
      }
      else if ([v6 code] == 3)
      {
        uint64_t v10 = 5;
      }
      else if ([v6 code] == 4)
      {
        uint64_t v10 = 6;
      }
      else
      {
        uint64_t v10 = 7;
      }
    }
    else
    {
      uint64_t v10 = 7;
    }
    id v22 = *(id *)(a1[4] + 104);
    objc_sync_enter(v22);
    uint64_t v23 = [*(id *)(a1[4] + 104) objectForKeyedSubscript:a1[5]];
    int64x2_t v24 = [v23 objectForKeyedSubscript:a1[6]];
    [v24 setUrlDecodingStateInternal:v10];

    objc_sync_exit(v22);
  }
  else if (v5)
  {
    id v11 = *(id *)(a1[4] + 104);
    objc_sync_enter(v11);
    unint64_t v12 = [*(id *)(a1[4] + 104) objectForKeyedSubscript:a1[5]];
    size_t v13 = [v12 objectForKeyedSubscript:a1[6]];
    [v13 setUrl:v5];

    uint64_t v14 = [*(id *)(a1[4] + 104) objectForKeyedSubscript:a1[5]];
    double v15 = [v14 objectForKeyedSubscript:a1[6]];
    [v15 setUrlDecodingStateInternal:8];

    objc_sync_exit(v11);
  }
  else
  {
    double v16 = _ARLogTechnique_10();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      uint64_t v17 = a1[8];
      uint64_t v18 = a1[9];
      int v25 = 134218240;
      uint64_t v26 = v17;
      __int16 v27 = 2048;
      uint64_t v28 = v18;
      _os_log_impl(&dword_1B88A2000, v16, OS_LOG_TYPE_ERROR, "ARAppClipCodeTechnique: Decoded URL at time %F index:%lu is nil.", (uint8_t *)&v25, 0x16u);
    }

    id v19 = *(id *)(a1[4] + 104);
    objc_sync_enter(v19);
    double v20 = [*(id *)(a1[4] + 104) objectForKeyedSubscript:a1[5]];
    long long v21 = [v20 objectForKeyedSubscript:a1[6]];
    [v21 setUrlDecodingStateInternal:7];

    objc_sync_exit(v19);
  }
}

void sub_1B89A2198(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

Class initBCSAppClipCodeURLDecoder()
{
  if (BarcodeSupportLibrary_sOnce != -1) {
    dispatch_once(&BarcodeSupportLibrary_sOnce, &__block_literal_global_76);
  }
  Class result = objc_getClass("BCSAppClipCodeURLDecoder");
  classBCSAppClipCodeURLDecoder = (uint64_t)result;
  getBCSAppClipCodeURLDecoderClass = (uint64_t (*)())BCSAppClipCodeURLDecoderFunction;
  return result;
}

id BCSAppClipCodeURLDecoderFunction()
{
  return (id)classBCSAppClipCodeURLDecoder;
}

void *__BarcodeSupportLibrary_block_invoke()
{
  Class result = dlopen("/System/Library/PrivateFrameworks/BarcodeSupport.framework/BarcodeSupport", 2);
  BarcodeSupportLibrary_sLib = (uint64_t)result;
  return result;
}

void sub_1B89A3898(_Unwind_Exception *a1)
{
  objc_destroyWeak(v2);
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v3 - 72));
  _Unwind_Resume(a1);
}

id _ARLogTechnique_11()
{
  if (_ARLogTechnique_onceToken_17 != -1) {
    dispatch_once(&_ARLogTechnique_onceToken_17, &__block_literal_global_84);
  }
  os_log_t v0 = (void *)_ARLogTechnique_logObj_17;
  return v0;
}

void sub_1B89A506C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40)
{
  _Unwind_Resume(a1);
}

id textureForSizeWithPixelFormatAndMetalDevice(int a1, void *a2, double a3, double a4)
{
  unsigned int v7 = (void *)MEMORY[0x1E4F35330];
  id v8 = a2;
  uint64_t v9 = [v7 texture2DDescriptorWithPixelFormat:getMTLPixelFormat(a1) width:(unint64_t)a3 height:(unint64_t)a4 mipmapped:0];
  [v9 setUsage:19];
  uint64_t v10 = (void *)[v8 newTextureWithDescriptor:v9];

  return v10;
}

__IOSurface *bindPixelBufferToMTL2DTextureWithMetalDevice(__CVBuffer *a1, void *a2)
{
  id v3 = a2;
  IOSurfaceRef IOSurface = CVPixelBufferGetIOSurface(a1);
  if (IOSurface)
  {
    OSType PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
    uint64_t MTLPixelFormat = getMTLPixelFormat(PixelFormatType);
    size_t WidthOfPlane = IOSurfaceGetWidthOfPlane(IOSurface, 0);
    id v8 = objc_msgSend(MEMORY[0x1E4F35330], "texture2DDescriptorWithPixelFormat:width:height:mipmapped:", MTLPixelFormat, WidthOfPlane, IOSurfaceGetHeightOfPlane(IOSurface, 0), 0);
    uint64_t v9 = v8;
    if (v8)
    {
      [v8 setUsage:23];
      IOSurfaceRef IOSurface = (__IOSurface *)[v3 newTextureWithDescriptor:v9 iosurface:IOSurface plane:0];
    }
    else
    {
      IOSurfaceRef IOSurface = 0;
    }
  }
  return IOSurface;
}

void sub_1B89A8188(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,char a58,uint64_t a59,void (*a60)(char *))
{
}

double matrixForImageRotation(uint64_t a1)
{
  float v1 = 0.0;
  if ((unint64_t)(a1 - 1) <= 2) {
    float v1 = flt_1B8A53648[a1 - 1];
  }
  __float2 v2 = __sincosf_stret(v1);
  *(float *)&double v3 = v2.__cosval;
  *((float *)&v3 + 1) = -v2.__sinval;
  return v3;
}

uint64_t getMTLPixelFormat(int a1)
{
  if (a1 > 1380401728)
  {
    if (a1 == 1380411457) {
      return 115;
    }
    if (a1 == 1380401729) {
      return 70;
    }
  }
  else
  {
    if (a1 == 843264104) {
      return 65;
    }
    if (a1 == 1111970369) {
      return 80;
    }
  }
  uint64_t v6 = v1;
  uint64_t v7 = v2;
  uint64_t v4 = _ARLogGeneral_32();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)id v5 = 0;
    _os_log_impl(&dword_1B88A2000, v4, OS_LOG_TYPE_ERROR, "error unsupported pixelformat", v5, 2u);
  }

  return 0;
}

void sub_1B89A8DD4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89A8FD0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89A92F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1B89A9590(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89A97A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89A9860(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89A98BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89A990C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89A9B7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89A9BCC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89A9C1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89A9C6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89A9D48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B89A9F24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89AA04C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89AA13C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ARFaceLandmarkDataFromLabeledFacePosition(void *a1, __int16 *a2, __int16 *a3, __int16 *a4, float *a5, float *a6, float *a7)
{
  id v13 = a1;
  float v14 = 1.0;
  if ([v13 isEqualToString:@"RightEyeOuterCorner"])
  {
    uint64_t v15 = 1;
    float v16 = 0.0;
    __int16 v17 = 1102;
    __int16 v18 = 1181;
    __int16 v19 = 1101;
LABEL_3:
    float v20 = 0.0;
    goto LABEL_20;
  }
  float v20 = 0.31;
  float v16 = 0.19242;
  if ([v13 isEqualToString:@"RightEyeInnerCorner"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 1088;
    __int16 v18 = 1089;
    __int16 v19 = 1193;
LABEL_6:
    float v14 = 0.49758;
    goto LABEL_20;
  }
  int v21 = 1058051330;
  if ([v13 isEqualToString:@"RightEyeLowerOuter"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 1106;
    float v14 = 0.0;
    __int16 v18 = 1107;
    __int16 v19 = 1199;
LABEL_9:
    float v16 = 0.43523;
LABEL_10:
    float v20 = *(float *)&v21;
    goto LABEL_20;
  }
  if ([v13 isEqualToString:@"RightEyeLowerInner"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 1085;
    __int16 v18 = 1198;
    __int16 v19 = 1108;
    float v14 = 0.20381;
    float v16 = 0.0;
LABEL_13:
    float v20 = 0.79619;
    goto LABEL_20;
  }
  char v22 = [v13 isEqualToString:@"RightEyeUpperOuter"];
  int v23 = 1059847335;
  int v24 = 1051199154;
  if (v22)
  {
    uint64_t v15 = 1;
    __int16 v17 = 1096;
    __int16 v18 = 1187;
    __int16 v19 = 1095;
LABEL_18:
    float v14 = *(float *)&v24;
    float v16 = 0.0;
LABEL_19:
    float v20 = *(float *)&v23;
    goto LABEL_20;
  }
  char v25 = [v13 isEqualToString:@"RightEyeUpperInner"];
  int v23 = 1058721800;
  int v24 = 1053450224;
  if (v25)
  {
    uint64_t v15 = 1;
    __int16 v17 = 1094;
    __int16 v18 = 1189;
    __int16 v19 = 1093;
    goto LABEL_18;
  }
  char v27 = [v13 isEqualToString:@"RightEyePupil"];
  int v23 = 1053609165;
  if (v27)
  {
    uint64_t v15 = 1;
    __int16 v17 = 1108;
    __int16 v18 = 1095;
    __int16 v19 = 1093;
    float v14 = 0.3;
    float v16 = 0.3;
    goto LABEL_19;
  }
  if ([v13 isEqualToString:@"LeftEyeOuterCorner"])
  {
    uint64_t v15 = 1;
    float v16 = 0.0;
    __int16 v17 = 1068;
    __int16 v18 = 1180;
    __int16 v19 = 1069;
    goto LABEL_3;
  }
  if ([v13 isEqualToString:@"LeftEyeInnerCorner"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 1082;
    __int16 v18 = 1081;
    __int16 v19 = 1168;
    goto LABEL_6;
  }
  if ([v13 isEqualToString:@"LeftEyeLowerOuter"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 1064;
    float v14 = 0.0;
    __int16 v18 = 1063;
    __int16 v19 = 1162;
    goto LABEL_9;
  }
  float v16 = 0.0;
  if ([v13 isEqualToString:@"LeftEyeLowerInner"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 1061;
    __int16 v18 = 1163;
    __int16 v19 = 1062;
    float v14 = 0.20381;
    goto LABEL_13;
  }
  if ([v13 isEqualToString:@"LeftEyeUpperOuter"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 1074;
    __int16 v18 = 1174;
    __int16 v19 = 1075;
    float v14 = 0.32818;
    float v20 = 0.67182;
    goto LABEL_20;
  }
  if ([v13 isEqualToString:@"LeftEyeUpperInner"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 1076;
    __int16 v18 = 1172;
    __int16 v19 = 1077;
    float v14 = 0.39526;
    float v20 = 0.60474;
    goto LABEL_20;
  }
  if ([v13 isEqualToString:@"LeftEyePupil"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 1062;
    __int16 v18 = 1077;
    __int16 v19 = 1075;
    float v16 = 0.3;
    float v20 = 0.4;
    float v14 = 0.3;
    goto LABEL_20;
  }
  float v20 = 0.48977;
  float v16 = 0.18919;
  float v14 = 0.32105;
  if ([v13 isEqualToString:@"RightBrowOuter"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 334;
    __int16 v18 = 327;
    __int16 v19 = 335;
    goto LABEL_20;
  }
  int v21 = 1053597916;
  int v28 = 1046921939;
  if ([v13 isEqualToString:@"RightBrowMiddle"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 209;
    __int16 v18 = 329;
    __int16 v19 = 328;
LABEL_41:
    float v14 = 0.37498;
LABEL_42:
    float v16 = *(float *)&v28;
    goto LABEL_10;
  }
  int v32 = 1030661949;
  int v29 = 1053234397;
  if ([v13 isEqualToString:@"RightBrowInner"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 329;
    __int16 v18 = 349;
    __int16 v19 = 348;
LABEL_45:
    float v14 = 0.5529;
LABEL_46:
    float v16 = *(float *)&v29;
    float v20 = *(float *)&v32;
    goto LABEL_20;
  }
  if ([v13 isEqualToString:@"LeftBrowOuter"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 767;
    __int16 v18 = 762;
    __int16 v19 = 768;
    goto LABEL_20;
  }
  if ([v13 isEqualToString:@"LeftBrowMiddle"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 657;
    __int16 v18 = 764;
    __int16 v19 = 763;
    goto LABEL_41;
  }
  if ([v13 isEqualToString:@"LeftBrowInner"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 764;
    __int16 v18 = 782;
    __int16 v19 = 781;
    goto LABEL_45;
  }
  float v20 = 0.56212;
  float v16 = 0.095512;
  float v14 = 0.34236;
  if ([v13 isEqualToString:@"MouthRightCorner"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 396;
    __int16 v18 = 190;
    __int16 v19 = 188;
    goto LABEL_20;
  }
  int v21 = 1053235527;
  int v28 = 1052383319;
  int v30 = 1048419522;
  if ([v13 isEqualToString:@"MouthRightUp1"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 108;
    __int16 v18 = 107;
    __int16 v19 = 100;
LABEL_57:
    float v14 = *(float *)&v30;
    goto LABEL_42;
  }
  int v32 = 1027608717;
  int v29 = 1047327851;
  if ([v13 isEqualToString:@"MouthRightUp2"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 108;
    __int16 v18 = 98;
    __int16 v19 = 96;
LABEL_60:
    float v14 = 0.72171;
    goto LABEL_46;
  }
  if ([v13 isEqualToString:@"MouthRightPhiltrum"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 90;
    __int16 v18 = 92;
    __int16 v19 = 94;
LABEL_63:
    float v14 = 0.47181;
    float v16 = 0.2723;
    float v20 = 0.25589;
    goto LABEL_20;
  }
  if ([v13 isEqualToString:@"MouthCenterPhiltrum"])
  {
    __int16 v19 = 1;
    __int16 v17 = 541;
    __int16 v18 = 21;
    float v16 = 0.7408;
    float v14 = 0.2592;
    float v20 = 0.0;
    uint64_t v15 = 1;
    goto LABEL_20;
  }
  if ([v13 isEqualToString:@"MouthLeftPhiltrum"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 539;
    __int16 v18 = 541;
    __int16 v19 = 543;
    goto LABEL_63;
  }
  if ([v13 isEqualToString:@"MouthLeftUp2"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 557;
    __int16 v18 = 547;
    __int16 v19 = 545;
    goto LABEL_60;
  }
  if ([v13 isEqualToString:@"MouthLeftUp1"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 557;
    __int16 v18 = 556;
    __int16 v19 = 549;
    goto LABEL_57;
  }
  if ([v13 isEqualToString:@"MouthLeftCorner"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 826;
    __int16 v18 = 639;
    __int16 v19 = 637;
    goto LABEL_20;
  }
  float v20 = 0.094037;
  float v16 = 0.13663;
  float v14 = 0.76933;
  if ([v13 isEqualToString:@"MouthLeftDown1"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 714;
    __int16 v18 = 713;
    __int16 v19 = 571;
    goto LABEL_20;
  }
  int v21 = 1056986958;
  int v28 = 1034297112;
  int v30 = 1054198174;
  if ([v13 isEqualToString:@"MouthLeftDown2"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 706;
    __int16 v18 = 723;
    __int16 v19 = 722;
    goto LABEL_57;
  }
  if ([v13 isEqualToString:@"MouthCenterLower"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 263;
    __int16 v18 = 27;
    __int16 v19 = 28;
    float v16 = 0.093781;
    float v14 = 0.90622;
    goto LABEL_3;
  }
  if ([v13 isEqualToString:@"MouthRightDown2"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 271;
    __int16 v18 = 288;
    __int16 v19 = 287;
    goto LABEL_57;
  }
  if ([v13 isEqualToString:@"MouthRightDown1"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 279;
    __int16 v18 = 278;
    __int16 v19 = 122;
    goto LABEL_20;
  }
  if ([v13 isEqualToString:@"MouthInnerUp"])
  {
    uint64_t v15 = 1;
    float v16 = 1.0;
    float v14 = 0.0;
    __int16 v17 = 542;
    __int16 v18 = 24;
    __int16 v19 = 23;
    goto LABEL_3;
  }
  float v20 = 0.0;
  if ([v13 isEqualToString:@"MouthInnerDown"])
  {
    uint64_t v15 = 1;
    float v14 = 1.0;
    __int16 v17 = 699;
    __int16 v18 = 26;
    __int16 v19 = 25;
LABEL_88:
    float v16 = 0.0;
    goto LABEL_20;
  }
  int v21 = 1030023345;
  float v16 = 0.7827;
  float v14 = 0.16141;
  if ([v13 isEqualToString:@"MouthInnerUpRight"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 105;
    __int16 v18 = 254;
    __int16 v19 = 253;
    goto LABEL_10;
  }
  if ([v13 isEqualToString:@"MouthInnerUpLeft"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 554;
    __int16 v18 = 689;
    __int16 v19 = 688;
    goto LABEL_10;
  }
  int v21 = 1050784710;
  float v16 = 0.66943;
  float v14 = 0.014741;
  if ([v13 isEqualToString:@"MouthInnerDownRight"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 275;
    __int16 v18 = 290;
    __int16 v19 = 289;
    goto LABEL_10;
  }
  if ([v13 isEqualToString:@"MouthInnerDownLeft"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 710;
    __int16 v18 = 725;
    __int16 v19 = 724;
    goto LABEL_10;
  }
  if ([v13 isEqualToString:@"NoseRidgeRoot"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 36;
    __int16 v18 = 360;
    __int16 v19 = 15;
    float v20 = 0.33965;
    float v14 = 0.66035;
    goto LABEL_88;
  }
  if ([v13 isEqualToString:@"NoseRidge1"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 606;
    __int16 v18 = 12;
    __int16 v19 = 13;
    float v16 = 0.38536;
    float v14 = 0.61464;
    goto LABEL_20;
  }
  if ([v13 isEqualToString:@"NoseRidge2"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 156;
    __int16 v18 = 10;
    __int16 v19 = 9;
    float v16 = 0.93626;
    float v14 = 0.063743;
    goto LABEL_20;
  }
  if ([v13 isEqualToString:@"NoseRidgeTip"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 129;
    __int16 v18 = 8;
    __int16 v19 = 7;
    float v16 = 0.68;
    float v14 = 0.32;
    goto LABEL_20;
  }
  int v21 = 1062999407;
  float v16 = 0.088421;
  float v14 = 0.051877;
  if ([v13 isEqualToString:@"NoseBaseLeft"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 743;
    __int16 v18 = 866;
    __int16 v19 = 867;
    goto LABEL_10;
  }
  if ([v13 isEqualToString:@"NoseBaseCenterLeft"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 526;
    __int16 v18 = 869;
    __int16 v19 = 742;
LABEL_113:
    float v14 = 0.65537;
    float v16 = 0.16678;
    float v20 = 0.17784;
    goto LABEL_20;
  }
  if ([v13 isEqualToString:@"NoseBaseCenter"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 759;
    __int16 v18 = 3;
    __int16 v19 = 4;
    float v16 = 0.27602;
    float v14 = 0.72398;
    goto LABEL_20;
  }
  if ([v13 isEqualToString:@"NoseBaseCenterRight"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 77;
    __int16 v18 = 441;
    __int16 v19 = 307;
    goto LABEL_113;
  }
  if ([v13 isEqualToString:@"NoseBaseRight"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 308;
    __int16 v18 = 438;
    __int16 v19 = 439;
    goto LABEL_10;
  }
  float v20 = 0.80801;
  float v16 = 0.12549;
  float v14 = 0.0665;
  if ([v13 isEqualToString:@"NoseAlaLeft1"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 588;
    __int16 v18 = 738;
    __int16 v19 = 739;
  }
  else if ([v13 isEqualToString:@"NoseAlaRight1"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 139;
    __int16 v18 = 303;
    __int16 v19 = 304;
  }
  else if ([v13 isEqualToString:@"NoseAlaLeft2"])
  {
    uint64_t v15 = 1;
    __int16 v17 = 530;
    __int16 v18 = 805;
    __int16 v19 = 531;
    float v20 = 0.051558;
    float v16 = 0.21135;
    float v14 = 0.73709;
  }
  else
  {
    uint64_t v31 = [v13 isEqualToString:@"NoseAlaRight2"];
    uint64_t v15 = v31;
    if (v31) {
      __int16 v19 = 82;
    }
    else {
      __int16 v19 = -1;
    }
    if (v31) {
      __int16 v18 = 374;
    }
    else {
      __int16 v18 = -1;
    }
    if (v31) {
      __int16 v17 = 81;
    }
    else {
      __int16 v17 = -1;
    }
    if (v31) {
      float v14 = 0.73709;
    }
    else {
      float v14 = -1.0;
    }
    if (v31) {
      float v16 = 0.21135;
    }
    else {
      float v16 = -1.0;
    }
    if (v31) {
      float v20 = 0.051558;
    }
    else {
      float v20 = -1.0;
    }
  }
LABEL_20:
  *a2 = v19;
  *a3 = v18;
  *a4 = v17;
  *a5 = v14;
  *a6 = v16;
  *a7 = v20;

  return v15;
}

void sub_1B89AAD60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL13_ARLogGeneralv_block_invoke_15()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "General");
  uint64_t v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObuint64_t j = (uint64_t)v0;
}

void *std::vector<short>::vector(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<short>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v4 = (char *)a1[1];
    bzero(v4, 2 * a2);
    a1[1] = &v4[2 * a2];
  }
  return a1;
}

void sub_1B89AB024(_Unwind_Exception *exception_object)
{
  double v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(&STACK[0x400], 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<short>::__vallocate[abi:ne180100](void *a1, uint64_t a2)
{
  if (a2 < 0) {
    std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
  }
  Class result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<short>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[2 * v4];
  return result;
}

uint64_t createUUID(void)
{
  v2[2] = *MEMORY[0x1E4F143B8];
  os_log_t v0 = objc_opt_new();
  [v0 getUUIDBytes:v2];

  return v2[0];
}

void sub_1B89AB0F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t toUUID(const __CFUUID *a1)
{
  _OWORD v3[2] = *MEMORY[0x1E4F143B8];
  uint64_t v1 = objc_msgSend(MEMORY[0x1E4F29128], "ar_UUIDWithCFUUIDRef:", a1);
  [v1 getUUIDBytes:v3];

  return v3[0];
}

void sub_1B89AB180(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id ARCreateTexture(uint64_t a1)
{
  uint64_t v1 = [MEMORY[0x1E4F35330] texture2DDescriptorWithPixelFormat:81 width:a1 height:a1 mipmapped:0];
  [v1 setUsage:5];
  uint64_t v2 = +[ARSharedGPUDevice sharedInstance];
  double v3 = [v2 device];

  uint64_t v4 = (void *)[v3 newTextureWithDescriptor:v1];
  [v4 setLabel:@"com.apple.arkit.planetexture"];

  return v4;
}

void sub_1B89AB244(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;

  _Unwind_Resume(a1);
}

void convert(uint64_t a1@<X8>)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  *(double *)v3.i64 = ARVisionToRenderingCoordinateTransform();
  float32x4_t v40 = v3;
  float32x4_t v41 = v4;
  float32x4_t v42 = v5;
  float32x4_t v43 = v6;
  CV3DPlaneDetectionPlaneTransformationToWorld();
  uint64_t v7 = 0;
  long long v48 = v8;
  long long v49 = v9;
  long long v50 = v10;
  long long v51 = v11;
  do
  {
    *(float32x4_t *)((char *)&v44 + v7) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v40, COERCE_FLOAT(*(long long *)((char *)&v48 + v7))), v41, *(float32x2_t *)((char *)&v48 + v7), 1), v42, *(float32x4_t *)((char *)&v48 + v7), 2), v43, *(float32x4_t *)((char *)&v48 + v7), 3);
    v7 += 16;
  }
  while (v7 != 64);
  float32x4_t v36 = v44;
  float32x4_t v38 = v45;
  float32x4_t v32 = v47;
  float32x4_t v34 = v46;
  *(double *)&long long v12 = ARRenderingToVisionCoordinateTransform();
  uint64_t v13 = 0;
  long long v48 = v12;
  long long v49 = v14;
  long long v50 = v15;
  long long v51 = v16;
  do
  {
    *(float32x4_t *)((char *)&v44 + v13) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v36, COERCE_FLOAT(*(long long *)((char *)&v48 + v13))), v38, *(float32x2_t *)((char *)&v48 + v13), 1), v34, *(float32x4_t *)((char *)&v48 + v13), 2), v32, *(float32x4_t *)((char *)&v48 + v13), 3);
    v13 += 16;
  }
  while (v13 != 64);
  float32x4_t v37 = v45;
  float32x4_t v39 = v44;
  float32x4_t v33 = v47;
  float32x4_t v35 = v46;
  CV3DPlaneDetectionPlaneExtentAlignedBoundingBox();
  __int16 v17 = (float *)CV3DPlaneDetectionAlignedBoundingBoxMin();
  __int16 v18 = (float *)CV3DPlaneDetectionAlignedBoundingBoxMax();
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 192) = a1 + 200;
  *(void *)(a1 + 20_Block_object_dispose(&STACK[0x400], 8) = 0;
  *(void *)(a1 + 216) = 0;
  CFUUIDRef v19 = (const __CFUUID *)CV3DPlaneDetectionPlaneCopyUUID();
  *(void *)a1 = toUUID(v19);
  *(void *)(a1 + _Block_object_dispose(&STACK[0x400], 8) = v20;
  CFRelease(v19);
  *(void *)(a1 + 16) = CV3DPlaneDetectionPlaneAge();
  float32x4_t v21 = vaddq_f32(v43, vmlaq_f32(vmlaq_n_f32(vmulq_n_f32(v40, *v18), v41, v18[1]), (float32x4_t)0, v42));
  float32x4_t v22 = vaddq_f32(v43, vmlaq_f32(vmlaq_n_f32(vmulq_n_f32(v40, *v17), v41, v17[1]), (float32x4_t)0, v42));
  *(float32x4_t *)(a1 + 96) = vmaxnmq_f32(v21, v22);
  *(float32x4_t *)(a1 + 112) = vminnmq_f32(v21, v22);
  *(float32x4_t *)(a1 + 32) = v39;
  *(float32x4_t *)(a1 + 4_Block_object_dispose(&STACK[0x400], 8) = v37;
  *(float32x4_t *)(a1 + 64) = v35;
  *(float32x4_t *)(a1 + 80) = v33;
  if (CV3DPlaneDetectionPlaneExtentOrientedBoundingBox())
  {
    float32x4_t v23 = vaddq_f32(v43, vmlaq_f32(vmlaq_lane_f32(vmulq_n_f32(v40, v44.f32[2]), v41, *(float32x2_t *)&v44.u32[2], 1), (float32x4_t)0, v42));
    float32x4_t v24 = vaddq_f32(v43, vmlaq_f32(vmlaq_lane_f32(vmulq_n_f32(v40, v45.f32[0]), v41, *(float32x2_t *)v45.f32, 1), (float32x4_t)0, v42));
    float32x4_t v25 = vmlaq_f32(vmlaq_lane_f32(vmulq_n_f32(v40, v45.f32[2]), v41, *(float32x2_t *)&v45.u32[2], 1), (float32x4_t)0, v42);
    *(float32x4_t *)(a1 + 12_Block_object_dispose(&STACK[0x400], 8) = vaddq_f32(v43, vmlaq_f32(vmlaq_lane_f32(vmulq_n_f32(v40, v44.f32[0]), v41, *(float32x2_t *)v44.f32, 1), (float32x4_t)0, v42));
    *(float32x4_t *)(a1 + 144) = v23;
    *(float32x4_t *)(a1 + 160) = v24;
    *(float32x4_t *)(a1 + 176) = vaddq_f32(v43, v25);
  }
  CFArrayRef v26 = (const __CFArray *)CV3DPlaneDetectionPlaneMergedIds();
  CFArrayRef v27 = v26;
  if (v26)
  {
    CFIndex Count = CFArrayGetCount(v26);
    if (Count)
    {
      for (CFIndex i = 0; i != Count; ++i)
      {
        ValueAtIndefloat x = (const __CFUUID *)CFArrayGetValueAtIndex(v27, i);
        *(void *)&long long v48 = toUUID(ValueAtIndex);
        *((void *)&v48 + 1) = v31;
        std::__tree<std::array<unsigned char,16ul>>::__emplace_unique_key_args<std::array<unsigned char,16ul>,std::array<unsigned char,16ul>>((uint64_t **)(a1 + 192), (uint64_t)&v48, &v48);
      }
    }
    CFRelease(v27);
  }
}

void sub_1B89AB538(_Unwind_Exception *a1)
{
  ARTexturedPlane::~ARTexturedPlane(v1);
  _Unwind_Resume(a1);
}

void convert(const CV3DPlaneDetectionPlaneList *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + _Block_object_dispose(&STACK[0x400], 8) = 0;
  *(void *)a2 = a2 + 8;
  if (a1)
  {
    uint64_t v3 = CV3DPlaneDetectionPlaneListLength();
    if (v3)
    {
      for (uint64_t i = 0; i != v3; ++i)
      {
        if (CV3DPlaneDetectionPlaneAtIndex())
        {
          CFUUIDRef v5 = (const __CFUUID *)CV3DPlaneDetectionPlaneCopyUUID();
          convert((uint64_t)v23);
          v22[0] = toUUID(v5);
          v22[1] = v6;
          float32x4_t v21 = (long long *)v22;
          uint64_t v7 = std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__emplace_unique_key_args<std::array<unsigned char,16ul>,std::piecewise_construct_t const&,std::tuple<std::array<unsigned char,16ul>&&>,std::tuple<>>((uint64_t **)a2, (uint64_t)v22, (uint64_t)&std::piecewise_construct, &v21);
          long long v9 = v23[10];
          long long v8 = v23[11];
          long long v10 = v23[9];
          long long v11 = v23[7];
          v7[11] = v23[8];
          v7[12] = v10;
          v7[13] = v9;
          v7[14] = v8;
          long long v12 = v23[5];
          v7[7] = v23[4];
          v7[8] = v12;
          v7[9] = v23[6];
          v7[10] = v11;
          long long v13 = v23[1];
          long long v15 = v23[2];
          long long v14 = v23[3];
          v7[3] = v23[0];
          v7[4] = v13;
          void v7[5] = v15;
          v7[6] = v14;
          long long v16 = (char *)v7 + 248;
          std::__tree<std::array<unsigned char,16ul>>::destroy((uint64_t)(v7 + 15), *((void **)v7 + 31));
          __int16 v17 = v25;
          *((void *)v7 + 30) = v24;
          *((void *)v7 + 31) = v17;
          uint64_t v18 = v26;
          *((void *)v7 + 32) = v26;
          if (v18)
          {
            void v17[2] = v16;
            float32x4_t v24 = &v25;
            float32x4_t v25 = 0;
            uint64_t v26 = 0;
          }
          else
          {
            *((void *)v7 + 30) = v16;
          }
          id v19 = v27;
          id v27 = 0;
          uint64_t v20 = (void *)*((void *)v7 + 33);
          *((void *)v7 + 33) = v19;

          std::__tree<std::array<unsigned char,16ul>>::destroy((uint64_t)&v24, v25);
          CFRelease(v5);
        }
      }
    }
  }
}

void sub_1B89AB72C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ARTexturedPlane *a7)
{
  std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::destroy(v7, *(void **)(v7 + 8));
  _Unwind_Resume(a1);
}

id convertToMesh(const ARTexturedPlane *a1)
{
  id v1 = -[ARMeshPrimitive initAsPlaneWithTransform:min:max:texture:]([ARMeshPrimitive alloc], "initAsPlaneWithTransform:min:max:texture:", a1[3].var5, *(double *)&a1->var4.__tree_.__pair1_.__value_.__left_, *(double *)&a1->var5, *(double *)&a1[1].var0.var0[8], *(double *)&a1[1].var4.__tree_.__begin_node_, *(double *)a1[2].var0.var0, *(double *)&a1[1].var4.__tree_.__pair3_.__value_);
  return v1;
}

id convertToMeshes(const ARTexturedPlane **a1)
{
  uint64_t v2 = objc_opt_new();
  uint64_t v3 = *a1;
  float32x4_t v4 = a1[1];
  while (v3 != v4)
  {
    CFUUIDRef v5 = convertToMesh(v3);
    [v2 addObject:v5];

    v3 += 4;
  }
  return v2;
}

void sub_1B89AB838(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double randomPlanePointInWorldCoordinates(const ARTexturedPlane *a1)
{
  float v2 = *(float *)a1[2].var0.var0;
  float v3 = *(float *)&a1[1].var4.__tree_.__pair3_.__value_;
  float v4 = v2 + (float)((float)((float)rand() * 4.6566e-10) * (float)(v3 - v2));
  *(void *)&double result = vaddq_f32(*(float32x4_t *)&a1[1].var4.__tree_.__begin_node_, vmlaq_n_f32(vmlaq_f32(vmulq_n_f32(*(float32x4_t *)&a1->var4.__tree_.__pair1_.__value_.__left_, v4), (float32x4_t)0, *(float32x4_t *)&a1->var5), *(float32x4_t *)((char *)&a1[1].var0 + 8), *(float *)&a1[2].var0.var0[8]+ (float)((float)((float)rand() * 4.6566e-10)* (float)(*(float *)&a1[1].var5 - *(float *)&a1[2].var0.var0[8])))).u64[0];
  return result;
}

__n128 convert@<Q0>(const ARTexturedPlane *a1@<X0>, _OWORD *a2@<X8>)
{
  int v2 = 0;
  p_var1 = &a1[2].var1;
  p_pair1 = &a1[2].var4.__tree_.__pair1_;
  uint64_t v5 = -3;
  do
  {
    long long v6 = *(_OWORD *)&p_pair1->__value_.__left_;
    p_pair1 += 2;
    if (*(float *)&v6 > *(float *)&p_var1[2 * v2]) {
      int v2 = v5 + 4;
    }
  }
  while (!__CFADD__(v5++, 1));
  uint64_t v8 = 0;
  int v9 = (v2 + 2) & 3;
  if (v2 + 2 <= 0) {
    int v9 = -(-(v2 + 2) & 3);
  }
  int v10 = (v2 + 3) & 3;
  if (v2 + 3 <= 0) {
    int v10 = -(-(v2 + 3) & 3);
  }
  float32x4_t v11 = *(float32x4_t *)&p_var1[2 * v10];
  float32x4_t v12 = vsubq_f32(*(float32x4_t *)&p_var1[2 * v2], v11);
  float32x4_t v13 = vmulq_f32(v12, v12);
  float32x4_t v14 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2);
  float32x4_t v16 = vaddq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 1));
  LODWORD(v15) = vaddq_f32(v14, v16).u32[0];
  v16.f32[0] = sqrtf(v15);
  *(float32x2_t *)v14.f32 = vrsqrte_f32((float32x2_t)LODWORD(v15));
  *(float32x2_t *)v14.f32 = vmul_f32(*(float32x2_t *)v14.f32, vrsqrts_f32((float32x2_t)LODWORD(v15), vmul_f32(*(float32x2_t *)v14.f32, *(float32x2_t *)v14.f32)));
  float32x4_t v17 = vmulq_n_f32(v12, vmul_f32(*(float32x2_t *)v14.f32, vrsqrts_f32((float32x2_t)LODWORD(v15), vmul_f32(*(float32x2_t *)v14.f32, *(float32x2_t *)v14.f32))).f32[0]);
  float32x4_t v18 = vsubq_f32(*(float32x4_t *)&p_var1[2 * v9], v11);
  float32x4_t v19 = vmulq_f32(v18, v18);
  LODWORD(v20) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v19, 2), vaddq_f32(v19, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v19.f32, 1))).u32[0];
  float v21 = sqrtf(v20);
  *(float32x2_t *)v14.f32 = vrsqrte_f32((float32x2_t)LODWORD(v20));
  *(float32x2_t *)v14.f32 = vmul_f32(*(float32x2_t *)v14.f32, vrsqrts_f32((float32x2_t)LODWORD(v20), vmul_f32(*(float32x2_t *)v14.f32, *(float32x2_t *)v14.f32)));
  float32x4_t v22 = vmulq_n_f32(v18, vmul_f32(*(float32x2_t *)v14.f32, vrsqrts_f32((float32x2_t)LODWORD(v20), vmul_f32(*(float32x2_t *)v14.f32, *(float32x2_t *)v14.f32))).f32[0]);
  float32x4_t v23 = vaddq_f32(vaddq_f32(*(float32x4_t *)&a1[2].var1, *(float32x4_t *)&a1[2].var4.__tree_.__pair1_.__value_.__left_), *(float32x4_t *)&a1[2].var5);
  if (v16.f32[0] >= v21) {
    float v24 = v21;
  }
  else {
    float v24 = v16.f32[0];
  }
  float32x4_t v25 = *(float32x4_t *)(MEMORY[0x1E4F149A0] + 32);
  float32x4_t v26 = *(float32x4_t *)(MEMORY[0x1E4F149A0] + 48);
  float32x4_t v27 = v26;
  v27.f32[1] = v24 * 0.5;
  float32x4_t v28 = *(float32x4_t *)MEMORY[0x1E4F149A0];
  float32x4_t v29 = *(float32x4_t *)(MEMORY[0x1E4F149A0] + 16);
  v17.i32[3] = HIDWORD(*MEMORY[0x1E4F149A0]);
  v22.i32[3] = v25.i32[3];
  __asm { FMOV            V4.4S, #0.25 }
  float32x4_t v34 = vmulq_f32(vaddq_f32(v23, *(float32x4_t *)((char *)&a1[3].var0 + 8)), _Q4);
  float32x4_t v35 = *(float32x4_t *)&a1->var4.__tree_.__pair1_.__value_.__left_;
  float32x4_t v36 = *(float32x4_t *)&a1->var5;
  float32x4_t v37 = *(float32x4_t *)((char *)&a1[1].var0 + 8);
  float32x4_t v38 = *(float32x4_t *)&a1[1].var4.__tree_.__begin_node_;
  long long v45 = *MEMORY[0x1E4F149A0];
  float32x4_t v46 = v29;
  float32x4_t v47 = v25;
  float32x4_t v48 = v27;
  do
  {
    *(long long *)((char *)&v49 + v_Block_object_dispose(&STACK[0x400], 8) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v17, COERCE_FLOAT(*(long long *)((char *)&v45 + v8))), v29, *(float32x2_t *)((char *)&v45 + v8), 1), v22, *(float32x4_t *)((char *)&v45 + v8), 2), v26, *(float32x4_t *)((char *)&v45 + v8), 3);
    v8 += 16;
  }
  while (v8 != 64);
  uint64_t v39 = 0;
  v34.i32[3] = v26.i32[3];
  long long v45 = v49;
  float32x4_t v46 = v50;
  float32x4_t v47 = v51;
  float32x4_t v48 = v52;
  do
  {
    *(long long *)((char *)&v49 + v39) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v28, COERCE_FLOAT(*(long long *)((char *)&v45 + v39))), v29, *(float32x2_t *)((char *)&v45 + v39), 1), v25, *(float32x4_t *)((char *)&v45 + v39), 2), v34, *(float32x4_t *)((char *)&v45 + v39), 3);
    v39 += 16;
  }
  while (v39 != 64);
  uint64_t v40 = 0;
  long long v45 = v49;
  float32x4_t v46 = v50;
  float32x4_t v47 = v51;
  float32x4_t v48 = v52;
  do
  {
    *(long long *)((char *)&v49 + v40) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v35, COERCE_FLOAT(*(long long *)((char *)&v45 + v40))), v36, *(float32x2_t *)((char *)&v45 + v40), 1), v37, *(float32x4_t *)((char *)&v45 + v40), 2), v38, *(float32x4_t *)((char *)&v45 + v40), 3);
    v40 += 16;
  }
  while (v40 != 64);
  float32x4_t v41 = v50;
  float32x4_t v42 = v51;
  float32x4_t v43 = v52;
  *a2 = v49;
  a2[1] = v41;
  a2[2] = v42;
  a2[3] = v43;
  v16.f32[1] = v24;
  v16.f32[2] = v21;
  a2[4] = v16;
  result.n128_u64[0] = v16.i64[0];
  result.n128_u32[2] = v16.u32[2];
  return result;
}

char *std::__tree<std::array<unsigned char,16ul>>::__emplace_unique_key_args<std::array<unsigned char,16ul>,std::array<unsigned char,16ul>>(uint64_t **a1, uint64_t a2, _OWORD *a3)
{
  uint64_t v5 = (void **)std::__tree<std::array<unsigned char,16ul>>::__find_equal<std::array<unsigned char,16ul>>((uint64_t)a1, &v9, a2);
  long long v6 = (char *)*v5;
  if (!*v5)
  {
    uint64_t v7 = (uint64_t **)v5;
    long long v6 = (char *)operator new(0x30uLL);
    *(_OWORD *)(v6 + 25) = *a3;
    _ZNSt3__16__treeINS_12__value_typeIyDv4_fEENS_19__map_value_compareIyS3_NS_4lessIyEELb1EEENS_9allocatorIS3_EEE16__insert_node_atEPNS_15__tree_end_nodeIPNS_16__tree_node_baseIPvEEEERSF_SF_(a1, v9, v7, (uint64_t *)v6);
  }
  return v6;
}

_OWORD *std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__emplace_unique_key_args<std::array<unsigned char,16ul>,std::piecewise_construct_t const&,std::tuple<std::array<unsigned char,16ul>&&>,std::tuple<>>(uint64_t **a1, uint64_t a2, uint64_t a3, long long **a4)
{
  long long v6 = (void **)std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__find_equal<std::array<unsigned char,16ul>>((uint64_t)a1, &v11, a2);
  uint64_t v7 = *v6;
  if (!*v6)
  {
    uint64_t v8 = (uint64_t **)v6;
    uint64_t v7 = operator new(0x110uLL);
    long long v9 = **a4;
    v7[15] = 0u;
    uint8_t v7[16] = 0u;
    v7[13] = 0u;
    v7[14] = 0u;
    v7[11] = 0u;
    v7[12] = 0u;
    v7[9] = 0u;
    v7[10] = 0u;
    v7[7] = 0u;
    v7[8] = 0u;
    void v7[5] = 0u;
    v7[6] = 0u;
    v7[3] = 0u;
    v7[4] = 0u;
    v7[2] = v9;
    *((void *)v7 + 30) = (char *)v7 + 248;
    _ZNSt3__16__treeINS_12__value_typeIyDv4_fEENS_19__map_value_compareIyS3_NS_4lessIyEELb1EEENS_9allocatorIS3_EEE16__insert_node_atEPNS_15__tree_end_nodeIPNS_16__tree_node_baseIPvEEEERSF_SF_(a1, v11, v8, (uint64_t *)v7);
  }
  return v7;
}

void *std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__find_equal<std::array<unsigned char,16ul>>(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = *(void **)(a1 + 8);
  __n128 result = (void *)(a1 + 8);
  float v4 = v5;
  if (v5)
  {
LABEL_2:
    while (2)
    {
      uint64_t v6 = 0;
      uint64_t v7 = v4;
      do
      {
        unsigned int v8 = *(unsigned __int8 *)(a3 + v6);
        unsigned int v9 = *((unsigned __int8 *)v7 + v6 + 32);
        if (v8 < v9)
        {
          float v4 = (void *)*v7;
          __n128 result = v7;
          if (*v7) {
            goto LABEL_2;
          }
          goto LABEL_22;
        }
      }
      while (v9 >= v8 && v6++ != 15);
      uint64_t v11 = 0;
      while (1)
      {
        unsigned int v12 = *((unsigned __int8 *)v7 + v11 + 32);
        unsigned int v13 = *(unsigned __int8 *)(a3 + v11);
        if (v12 < v13) {
          break;
        }
        if (v13 < v12 || v11++ == 15) {
          goto LABEL_22;
        }
      }
      __n128 result = v7 + 1;
      float v4 = (void *)v7[1];
      if (v4) {
        continue;
      }
      break;
    }
  }
  else
  {
    uint64_t v7 = result;
  }
LABEL_22:
  *a2 = v7;
  return result;
}

__CFString *NSStringFromARGeoTrackingState(unint64_t a1)
{
  if (a1 > 3) {
    return @"Unknown";
  }
  else {
    return *(&off_1E6187980 + a1);
  }
}

__CFString *NSStringFromARGeoTrackingAccuracy(unint64_t a1)
{
  if (a1 > 3) {
    return @"Unknown";
  }
  else {
    return *(&off_1E61879A0 + a1);
  }
}

__CFString *NSStringFromARGeoTrackingStateReason(unint64_t a1)
{
  if (a1 > 8) {
    return @"Unknown";
  }
  else {
    return *(&off_1E61879C0 + a1);
  }
}

__CFString *NSStringFromARGeoTrackingInternalFailureReason(uint64_t a1)
{
  if (a1 > 63)
  {
    if (a1 <= 511)
    {
      switch(a1)
      {
        case 64:
          return @"Invalid VIO Pose";
        case 128:
          return @"Phone Angle";
        case 256:
          return @"VL Bad Image";
      }
    }
    else if (a1 > 2047)
    {
      if (a1 == 2048) {
        return @"VL Unrecognized Error";
      }
      if (a1 == 4096) {
        return @"Waiting For Availability Check";
      }
    }
    else
    {
      if (a1 == 512) {
        return @"VL Unavailable At Location";
      }
      if (a1 == 1024) {
        return @"Waiting For Location";
      }
    }
    return @"Unknown";
  }
  __n128 result = @"None";
  switch(a1)
  {
    case 0:
      return result;
    case 1:
      return @"VL Unsupported";
    case 2:
      return @"VL Map Data Not Loaded";
    case 3:
    case 5:
    case 6:
    case 7:
      return @"Unknown";
    case 4:
      return @"VL Map Data Pending";
    case 8:
      return @"VL Pose Estimation Failed";
    default:
      if (a1 == 16)
      {
        __n128 result = @"VL Rejected Pose";
      }
      else
      {
        if (a1 != 32) {
          return @"Unknown";
        }
        __n128 result = @"VL Bad Input";
      }
      break;
  }
  return result;
}

void sub_1B89AC50C(_Unwind_Exception *a1)
{
  unsigned int v9 = v6;

  _Unwind_Resume(a1);
}

void sub_1B89AC664(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)ARDepthEstimationTechnique;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1B89AC8A4(_Unwind_Exception *a1)
{
  uint64_t v6 = v3;

  _Unwind_Resume(a1);
}

void sub_1B89AC904()
{
}

void sub_1B89ACCD0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL15_ARLogTechniquev_block_invoke_8()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "Technique");
  id v1 = (void *)_ARLogTechnique(void)::logObj;
  _ARLogTechnique(void)::logObuint64_t j = (uint64_t)v0;
}

id ARReplaySensorClassForMovieURL(void *a1, void *a2)
{
  v32[1] = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  float v4 = v3;
  if (!v3 || ([v3 isFileURL] & 1) == 0)
  {
    if (!a2)
    {
      unsigned int v9 = 0;
      goto LABEL_15;
    }
    int v10 = NSString;
    uint64_t v11 = ARKitCoreBundle();
    unsigned int v12 = [v11 localizedStringForKey:@"Replay URL is missing or not a fileURL: %@" value:&stru_1F120C8F0 table:@"Localizable_iOS"];
    uint64_t v7 = objc_msgSend(v10, "stringWithFormat:", v12, v4);

    unsigned int v13 = (void *)MEMORY[0x1E4F28C58];
    uint64_t v31 = *MEMORY[0x1E4F28568];
    v32[0] = v7;
    unsigned int v8 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v32 forKeys:&v31 count:1];
    [v13 errorWithDomain:@"com.apple.arkit.error" code:102 userInfo:v8];
    unsigned int v9 = 0;
    *a2 = (id)objc_claimAutoreleasedReturnValue();
    goto LABEL_9;
  }
  id v26 = 0;
  int v5 = [v4 getResourceValue:&v26 forKey:*MEMORY[0x1E4F1C668] error:a2];
  id v6 = v26;
  uint64_t v7 = v6;
  if (!v5) {
    goto LABEL_13;
  }
  if (([v6 BOOLValue] & 1) == 0)
  {
    if (a2)
    {
      float32x4_t v14 = NSString;
      float v15 = ARKitCoreBundle();
      float32x4_t v16 = [v15 localizedStringForKey:@"Replay URL is not readable: %@" value:&stru_1F120C8F0 table:@"Localizable_iOS"];
      unsigned int v8 = objc_msgSend(v14, "stringWithFormat:", v16, v4);

      float32x4_t v17 = (void *)MEMORY[0x1E4F28C58];
      uint64_t v29 = *MEMORY[0x1E4F28568];
      int v30 = v8;
      float32x4_t v18 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v30 forKeys:&v29 count:1];
      *a2 = [v17 errorWithDomain:@"com.apple.arkit.error" code:102 userInfo:v18];

LABEL_20:
      unsigned int v9 = 0;
      goto LABEL_9;
    }
LABEL_13:
    unsigned int v9 = 0;
    goto LABEL_14;
  }
  unsigned int v8 = [MEMORY[0x1E4F166C8] assetWithURL:v4];
  if (!v8)
  {
    if (a2)
    {
      float v20 = NSString;
      float v21 = ARKitCoreBundle();
      float32x4_t v22 = [v21 localizedStringForKey:@"Replay URL is not valid AVURLAsset: %@" value:&stru_1F120C8F0 table:@"Localizable_iOS"];
      float32x4_t v23 = objc_msgSend(v20, "stringWithFormat:", v22, v4);

      float v24 = (void *)MEMORY[0x1E4F28C58];
      uint64_t v27 = *MEMORY[0x1E4F28568];
      float32x4_t v28 = v23;
      float32x4_t v25 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v28 forKeys:&v27 count:1];
      *a2 = [v24 errorWithDomain:@"com.apple.arkit.error" code:102 userInfo:v25];
    }
    goto LABEL_20;
  }
  unsigned int v9 = objc_opt_class();
LABEL_9:

LABEL_14:
LABEL_15:

  return v9;
}

uint64_t replayModeByApplyingUserDefaultOverrides(uint64_t a1)
{
  if (+[ARKitUserDefaults BOOLForKey:@"com.apple.arkit.replaySensor.deterministicMode"])
  {
    if (+[ARKitUserDefaults BOOLForKey:@"com.apple.arkit.replaySensor.deterministicMode.useMovieFPS"])
    {
      return 2;
    }
    else
    {
      return 1;
    }
  }
  else if (+[ARKitUserDefaults BOOLForKey:@"com.apple.arkit.session.replay.filepath.manual"])
  {
    return 3;
  }
  else
  {
    return a1;
  }
}

__CFString *NSStringFromARReplayMode(uint64_t a1)
{
  if ((unint64_t)(a1 - 1) > 2) {
    return @"Realtime";
  }
  else {
    return *(&off_1E6187A08 + a1 - 1);
  }
}

uint64_t ARRigInputJoints()
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  {
    v1[6] = xmmword_1E6187A80;
    v1[7] = *(_OWORD *)off_1E6187A90;
    int v2 = "righthand";
    v1[2] = xmmword_1E6187A40;
    v1[3] = *(_OWORD *)&off_1E6187A50;
    v1[4] = xmmword_1E6187A60;
    v1[5] = *(_OWORD *)&off_1E6187A70;
    v1[0] = xmmword_1E6187A20;
    v1[1] = *(_OWORD *)&off_1E6187A30;
    std::vector<char const*>::vector[abi:ne180100](ARRigInputJoints::dataVector, v1, 0x11uLL);
    __cxa_atexit((void (*)(void *))std::vector<char const*>::~vector[abi:ne180100], ARRigInputJoints::dataVector, &dword_1B88A2000);
  }
  return ARRigInputJoints::dataVector[0];
}

void sub_1B89AD3C0(_Unwind_Exception *a1)
{
}

void *std::vector<char const*>::vector[abi:ne180100](void *a1, const void *a2, unint64_t a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a3)
  {
    std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__vallocate[abi:ne180100](a1, a3);
    id v6 = (char *)a1[1];
    memmove(v6, a2, 8 * a3);
    a1[1] = &v6[8 * a3];
  }
  return a1;
}

void sub_1B89AD440(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(&STACK[0x400], 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<char const*>::~vector[abi:ne180100](uint64_t a1)
{
  int v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + _Block_object_dispose(&STACK[0x400], 8) = v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t ARRigOutputJoints()
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  {
    memcpy(v1, off_1E6187AA8, sizeof(v1));
    std::vector<char const*>::vector[abi:ne180100](ARRigOutputJoints::dataVector, v1, 0x5BuLL);
    __cxa_atexit((void (*)(void *))std::vector<char const*>::~vector[abi:ne180100], ARRigOutputJoints::dataVector, &dword_1B88A2000);
  }
  return ARRigOutputJoints::dataVector[0];
}

void sub_1B89AD564(_Unwind_Exception *a1)
{
}

uint64_t ARNeutralBodySkeleton3DModelTransforms(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  MEMORY[0x1F4188790](a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  {
    v9[0] = xmmword_1B8A2B0C0;
    v9[1] = xmmword_1B8A2B0D0;
    void v9[2] = xmmword_1B8A2B270;
    v9[3] = xmmword_1B8A53790;
    void v9[4] = xmmword_1B8A537A0;
    v9[5] = xmmword_1B8A537B0;
    v9[6] = xmmword_1B8A537C0;
    v9[7] = xmmword_1B8A537D0;
    v9[8] = xmmword_1B8A537E0;
    v9[9] = xmmword_1B8A537F0;
    v9[10] = xmmword_1B8A53800;
    v9[11] = xmmword_1B8A53810;
    v9[12] = xmmword_1B8A53820;
    v9[13] = xmmword_1B8A53830;
    v9[14] = xmmword_1B8A53840;
    v9[15] = xmmword_1B8A53850;
    v9[16] = xmmword_1B8A53860;
    v9[17] = xmmword_1B8A53870;
    v9[18] = xmmword_1B8A53880;
    v9[19] = xmmword_1B8A53890;
    v9[20] = xmmword_1B8A538A0;
    v9[21] = xmmword_1B8A538B0;
    v9[22] = xmmword_1B8A53880;
    v9[23] = xmmword_1B8A538C0;
    v9[24] = xmmword_1B8A538A0;
    v9[25] = xmmword_1B8A538D0;
    v9[26] = xmmword_1B8A53880;
    v9[27] = xmmword_1B8A538E0;
    v9[28] = xmmword_1B8A538F0;
    v9[29] = xmmword_1B8A53900;
    v9[30] = xmmword_1B8A537A0;
    v9[31] = xmmword_1B8A53910;
    v9[32] = xmmword_1B8A53920;
    v9[33] = xmmword_1B8A53930;
    v9[34] = xmmword_1B8A537A0;
    v9[35] = xmmword_1B8A53940;
    v9[36] = xmmword_1B8A53950;
    v9[37] = xmmword_1B8A53960;
    v9[38] = xmmword_1B8A53970;
    v9[39] = xmmword_1B8A53980;
    v9[40] = xmmword_1B8A53990;
    v9[41] = xmmword_1B8A539A0;
    v9[42] = xmmword_1B8A539B0;
    v9[43] = xmmword_1B8A539C0;
    v9[44] = xmmword_1B8A53990;
    v9[45] = xmmword_1B8A539D0;
    v9[46] = xmmword_1B8A539E0;
    v9[47] = xmmword_1B8A539F0;
    v9[48] = xmmword_1B8A53A00;
    v9[49] = xmmword_1B8A53A10;
    v9[50] = xmmword_1B8A53A20;
    v9[51] = xmmword_1B8A53A30;
    v9[52] = xmmword_1B8A53A00;
    v9[53] = xmmword_1B8A53A10;
    v9[54] = xmmword_1B8A53A20;
    v9[55] = xmmword_1B8A53A40;
    v9[56] = xmmword_1B8A53A00;
    v9[57] = xmmword_1B8A53A10;
    v9[58] = xmmword_1B8A53A20;
    v9[59] = xmmword_1B8A53A50;
    v9[60] = xmmword_1B8A53A00;
    v9[61] = xmmword_1B8A53A10;
    v9[62] = xmmword_1B8A53A20;
    v9[63] = xmmword_1B8A53A60;
    v9[64] = xmmword_1B8A53A70;
    v9[65] = xmmword_1B8A53A80;
    v9[66] = xmmword_1B8A53A90;
    v9[67] = xmmword_1B8A53AA0;
    v9[68] = xmmword_1B8A53AB0;
    v9[69] = xmmword_1B8A53AC0;
    v9[70] = xmmword_1B8A53AD0;
    v9[71] = xmmword_1B8A53AE0;
    v9[72] = xmmword_1B8A53AB0;
    v9[73] = xmmword_1B8A53AC0;
    v9[74] = xmmword_1B8A53AD0;
    v9[75] = xmmword_1B8A53AF0;
    v9[76] = xmmword_1B8A53B00;
    v9[77] = xmmword_1B8A53B10;
    v9[78] = xmmword_1B8A53B20;
    v9[79] = xmmword_1B8A53B30;
    v9[80] = xmmword_1B8A53B40;
    v9[81] = xmmword_1B8A53B50;
    v9[82] = xmmword_1B8A53B60;
    v9[83] = xmmword_1B8A53B70;
    v9[84] = xmmword_1B8A53B80;
    v9[85] = xmmword_1B8A53B90;
    v9[86] = xmmword_1B8A53BA0;
    v9[87] = xmmword_1B8A53BB0;
    v9[88] = xmmword_1B8A53B80;
    v9[89] = xmmword_1B8A53BC0;
    v9[90] = xmmword_1B8A53BD0;
    v9[91] = xmmword_1B8A53BE0;
    v9[92] = xmmword_1B8A53BF0;
    v9[93] = xmmword_1B8A53C00;
    v9[94] = xmmword_1B8A53C10;
    v9[95] = xmmword_1B8A53C20;
    v9[96] = xmmword_1B8A53BF0;
    v9[97] = xmmword_1B8A53C00;
    v9[98] = xmmword_1B8A53C10;
    v9[99] = xmmword_1B8A53C30;
    v9[100] = xmmword_1B8A53BF0;
    v9[101] = xmmword_1B8A53C00;
    v9[102] = xmmword_1B8A53C10;
    v9[103] = xmmword_1B8A53C40;
    v9[104] = xmmword_1B8A53BF0;
    v9[105] = xmmword_1B8A53C00;
    v9[106] = xmmword_1B8A53C10;
    v9[107] = xmmword_1B8A53C50;
    v9[108] = xmmword_1B8A53BF0;
    v9[109] = xmmword_1B8A53C00;
    v9[110] = xmmword_1B8A53C10;
    v9[111] = xmmword_1B8A53C60;
    v9[112] = xmmword_1B8A53C70;
    v9[113] = xmmword_1B8A53C80;
    v9[114] = xmmword_1B8A53C90;
    v9[115] = xmmword_1B8A53CA0;
    v9[116] = xmmword_1B8A53C70;
    v9[117] = xmmword_1B8A53C80;
    v9[118] = xmmword_1B8A53C90;
    v9[119] = xmmword_1B8A53CB0;
    v9[120] = xmmword_1B8A53C70;
    v9[121] = xmmword_1B8A53C80;
    v9[122] = xmmword_1B8A53C90;
    v9[123] = xmmword_1B8A53CC0;
    v9[124] = xmmword_1B8A53C70;
    v9[125] = xmmword_1B8A53C80;
    v9[126] = xmmword_1B8A53C90;
    v9[127] = xmmword_1B8A53CD0;
    v9[128] = xmmword_1B8A53C70;
    v9[129] = xmmword_1B8A53C80;
    v9[130] = xmmword_1B8A53C90;
    v9[131] = xmmword_1B8A53CE0;
    v9[132] = xmmword_1B8A53CF0;
    v9[133] = xmmword_1B8A53D00;
    v9[134] = xmmword_1B8A53D10;
    v9[135] = xmmword_1B8A53D20;
    v9[136] = xmmword_1B8A53CF0;
    v9[137] = xmmword_1B8A53D00;
    v9[138] = xmmword_1B8A53D10;
    v9[139] = xmmword_1B8A53D30;
    v9[140] = xmmword_1B8A53CF0;
    v9[141] = xmmword_1B8A53D00;
    v9[142] = xmmword_1B8A53D10;
    v9[143] = xmmword_1B8A53D40;
    v9[144] = xmmword_1B8A53CF0;
    v9[145] = xmmword_1B8A53D00;
    v9[146] = xmmword_1B8A53D10;
    v9[147] = xmmword_1B8A53D50;
    v9[148] = xmmword_1B8A53CF0;
    v9[149] = xmmword_1B8A53D00;
    v9[150] = xmmword_1B8A53D10;
    v9[151] = xmmword_1B8A53D60;
    v9[152] = xmmword_1B8A53D70;
    v9[153] = xmmword_1B8A53D80;
    v9[154] = xmmword_1B8A53D90;
    v9[155] = xmmword_1B8A53DA0;
    v9[156] = xmmword_1B8A53D70;
    v9[157] = xmmword_1B8A53D80;
    v9[158] = xmmword_1B8A53D90;
    v9[159] = xmmword_1B8A53DB0;
    v9[160] = xmmword_1B8A53D70;
    v9[161] = xmmword_1B8A53D80;
    v9[162] = xmmword_1B8A53D90;
    v9[163] = xmmword_1B8A53DC0;
    v9[164] = xmmword_1B8A53D70;
    v9[165] = xmmword_1B8A53D80;
    v9[166] = xmmword_1B8A53D90;
    v9[167] = xmmword_1B8A53DD0;
    v9[168] = xmmword_1B8A53D70;
    v9[169] = xmmword_1B8A53D80;
    v9[170] = xmmword_1B8A53D90;
    v9[171] = xmmword_1B8A53DE0;
    v9[172] = xmmword_1B8A53DF0;
    v9[173] = xmmword_1B8A53E00;
    v9[174] = xmmword_1B8A53E10;
    v9[175] = xmmword_1B8A53E20;
    v9[176] = xmmword_1B8A53DF0;
    v9[177] = xmmword_1B8A53E00;
    v9[178] = xmmword_1B8A53E10;
    v9[179] = xmmword_1B8A53E30;
    v9[180] = xmmword_1B8A53DF0;
    v9[181] = xmmword_1B8A53E00;
    v9[182] = xmmword_1B8A53E10;
    v9[183] = xmmword_1B8A53E40;
    v9[184] = xmmword_1B8A53DF0;
    v9[185] = xmmword_1B8A53E00;
    v9[186] = xmmword_1B8A53E10;
    v9[187] = xmmword_1B8A53E50;
    v9[188] = xmmword_1B8A53E60;
    v9[189] = xmmword_1B8A53E70;
    v9[190] = xmmword_1B8A53AD0;
    v9[191] = xmmword_1B8A53E80;
    v9[192] = xmmword_1B8A53E90;
    v9[193] = xmmword_1B8A53EA0;
    v9[194] = xmmword_1B8A53EB0;
    v9[195] = xmmword_1B8A53EC0;
    v9[196] = xmmword_1B8A53E90;
    v9[197] = xmmword_1B8A53EA0;
    v9[198] = xmmword_1B8A53EB0;
    v9[199] = xmmword_1B8A53ED0;
    v9[200] = xmmword_1B8A53E90;
    v9[201] = xmmword_1B8A53EA0;
    v9[202] = xmmword_1B8A53EB0;
    v9[203] = xmmword_1B8A53EE0;
    v9[204] = xmmword_1B8A53EF0;
    v9[205] = xmmword_1B8A53F00;
    v9[206] = xmmword_1B8A53F10;
    v9[207] = xmmword_1B8A53F20;
    v9[208] = xmmword_1B8A53EF0;
    v9[209] = xmmword_1B8A53F00;
    v9[210] = xmmword_1B8A53F10;
    v9[211] = xmmword_1B8A53F30;
    v9[212] = xmmword_1B8A53EF0;
    v9[213] = xmmword_1B8A53F00;
    v9[214] = xmmword_1B8A53F10;
    v9[215] = xmmword_1B8A53F40;
    v9[216] = xmmword_1B8A53F50;
    v9[217] = xmmword_1B8A53F60;
    v9[218] = xmmword_1B8A53F10;
    v9[219] = xmmword_1B8A53F70;
    v9[220] = xmmword_1B8A53F50;
    v9[221] = xmmword_1B8A53F60;
    v9[222] = xmmword_1B8A53F10;
    v9[223] = xmmword_1B8A53F70;
    v9[224] = xmmword_1B8A53F50;
    v9[225] = xmmword_1B8A53F60;
    v9[226] = xmmword_1B8A53F10;
    v9[227] = xmmword_1B8A53F70;
    v9[228] = xmmword_1B8A53F50;
    v9[229] = xmmword_1B8A53F60;
    v9[230] = xmmword_1B8A53F10;
    v9[231] = xmmword_1B8A53F70;
    v9[232] = xmmword_1B8A53F80;
    v9[233] = xmmword_1B8A53F90;
    v9[234] = xmmword_1B8A53F10;
    v9[235] = xmmword_1B8A53FA0;
    v9[236] = xmmword_1B8A53F50;
    v9[237] = xmmword_1B8A53F60;
    v9[238] = xmmword_1B8A53F10;
    v9[239] = xmmword_1B8A53FB0;
    v9[240] = xmmword_1B8A53F50;
    v9[241] = xmmword_1B8A53F60;
    v9[242] = xmmword_1B8A53F10;
    v9[243] = xmmword_1B8A53FB0;
    v9[244] = xmmword_1B8A53F50;
    v9[245] = xmmword_1B8A53F60;
    v9[246] = xmmword_1B8A53F10;
    v9[247] = xmmword_1B8A53FB0;
    v9[248] = xmmword_1B8A53F50;
    v9[249] = xmmword_1B8A53F60;
    v9[250] = xmmword_1B8A53F10;
    v9[251] = xmmword_1B8A53FB0;
    v9[252] = xmmword_1B8A53FC0;
    v9[253] = xmmword_1B8A53FD0;
    v9[254] = xmmword_1B8A53FE0;
    v9[255] = xmmword_1B8A53FF0;
    v9[256] = xmmword_1B8A54000;
    v9[257] = xmmword_1B8A54010;
    v9[258] = xmmword_1B8A54020;
    v9[259] = xmmword_1B8A54030;
    v9[260] = xmmword_1B8A54040;
    v9[261] = xmmword_1B8A54050;
    v9[262] = xmmword_1B8A54060;
    v9[263] = xmmword_1B8A54070;
    v9[264] = xmmword_1B8A54040;
    v9[265] = xmmword_1B8A54080;
    v9[266] = xmmword_1B8A54050;
    v9[267] = xmmword_1B8A54090;
    v9[268] = xmmword_1B8A540A0;
    v9[269] = xmmword_1B8A540B0;
    v9[270] = xmmword_1B8A540C0;
    v9[271] = xmmword_1B8A540D0;
    v9[272] = xmmword_1B8A540A0;
    v9[273] = xmmword_1B8A540B0;
    v9[274] = xmmword_1B8A540C0;
    v9[275] = xmmword_1B8A540E0;
    v9[276] = xmmword_1B8A540A0;
    v9[277] = xmmword_1B8A540B0;
    v9[278] = xmmword_1B8A540C0;
    v9[279] = xmmword_1B8A540F0;
    v9[280] = xmmword_1B8A540A0;
    v9[281] = xmmword_1B8A540B0;
    v9[282] = xmmword_1B8A540C0;
    v9[283] = xmmword_1B8A54100;
    v9[284] = xmmword_1B8A540A0;
    v9[285] = xmmword_1B8A540B0;
    v9[286] = xmmword_1B8A540C0;
    v9[287] = xmmword_1B8A54110;
    v9[288] = xmmword_1B8A54120;
    v9[289] = xmmword_1B8A54130;
    v9[290] = xmmword_1B8A54140;
    v9[291] = xmmword_1B8A54150;
    v9[292] = xmmword_1B8A54120;
    v9[293] = xmmword_1B8A54130;
    v9[294] = xmmword_1B8A54140;
    v9[295] = xmmword_1B8A54160;
    v9[296] = xmmword_1B8A54120;
    v9[297] = xmmword_1B8A54130;
    v9[298] = xmmword_1B8A54140;
    v9[299] = xmmword_1B8A54170;
    v9[300] = xmmword_1B8A54120;
    v9[301] = xmmword_1B8A54130;
    v9[302] = xmmword_1B8A54140;
    v9[303] = xmmword_1B8A54180;
    v9[304] = xmmword_1B8A54120;
    v9[305] = xmmword_1B8A54130;
    v9[306] = xmmword_1B8A54140;
    v9[307] = xmmword_1B8A54190;
    v9[308] = xmmword_1B8A541A0;
    v9[309] = xmmword_1B8A541B0;
    v9[310] = xmmword_1B8A541C0;
    v9[311] = xmmword_1B8A541D0;
    v9[312] = xmmword_1B8A541A0;
    v9[313] = xmmword_1B8A541B0;
    v9[314] = xmmword_1B8A541C0;
    v9[315] = xmmword_1B8A541E0;
    v9[316] = xmmword_1B8A541A0;
    v9[317] = xmmword_1B8A541B0;
    v9[318] = xmmword_1B8A541C0;
    v9[319] = xmmword_1B8A541F0;
    v9[320] = xmmword_1B8A541A0;
    v9[321] = xmmword_1B8A541B0;
    v9[322] = xmmword_1B8A541C0;
    v9[323] = xmmword_1B8A54200;
    v9[324] = xmmword_1B8A541A0;
    v9[325] = xmmword_1B8A541B0;
    v9[326] = xmmword_1B8A541C0;
    v9[327] = xmmword_1B8A54210;
    v9[328] = xmmword_1B8A54220;
    v9[329] = xmmword_1B8A54230;
    v9[330] = xmmword_1B8A54240;
    v9[331] = xmmword_1B8A54250;
    v9[332] = xmmword_1B8A54220;
    v9[333] = xmmword_1B8A54230;
    v9[334] = xmmword_1B8A54240;
    v9[335] = xmmword_1B8A54260;
    v9[336] = xmmword_1B8A54220;
    v9[337] = xmmword_1B8A54230;
    v9[338] = xmmword_1B8A54240;
    v9[339] = xmmword_1B8A54270;
    v9[340] = xmmword_1B8A54220;
    v9[341] = xmmword_1B8A54230;
    v9[342] = xmmword_1B8A54240;
    v9[343] = xmmword_1B8A54280;
    v9[344] = xmmword_1B8A54220;
    v9[345] = xmmword_1B8A54230;
    v9[346] = xmmword_1B8A54240;
    v9[347] = xmmword_1B8A54290;
    v9[348] = xmmword_1B8A542A0;
    v9[349] = xmmword_1B8A542B0;
    v9[350] = xmmword_1B8A542C0;
    v9[351] = xmmword_1B8A542D0;
    v9[352] = xmmword_1B8A542A0;
    v9[353] = xmmword_1B8A542B0;
    v9[354] = xmmword_1B8A542C0;
    v9[355] = xmmword_1B8A542E0;
    v9[356] = xmmword_1B8A542A0;
    v9[357] = xmmword_1B8A542B0;
    v9[358] = xmmword_1B8A542C0;
    v9[359] = xmmword_1B8A542F0;
    v9[360] = xmmword_1B8A542A0;
    v9[361] = xmmword_1B8A542B0;
    v9[362] = xmmword_1B8A542C0;
    v9[363] = xmmword_1B8A54300;
    std::vector<simd_float4x4>::vector[abi:ne180100](ARNeutralBodySkeleton3DModelTransforms::dataVector, v9, 0x5BuLL);
    __cxa_atexit((void (*)(void *))std::vector<simd_float4x4>::~vector[abi:ne180100], ARNeutralBodySkeleton3DModelTransforms::dataVector, &dword_1B88A2000);
  }
  uint64_t result = ARNeutralBodySkeleton3DModelTransforms::dataVector[0];
  if (unk_1E9EEE038 - ARNeutralBodySkeleton3DModelTransforms::dataVector[0] != 5824) {
    ARNeutralBodySkeleton3DModelTransforms_cold_1();
  }
  return result;
}

void sub_1B89AE17C(_Unwind_Exception *a1)
{
}

void *std::vector<simd_float4x4>::vector[abi:ne180100](void *a1, const void *a2, unint64_t a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a3)
  {
    std::vector<simd_float4x4>::__vallocate[abi:ne180100](a1, a3);
    id v6 = (char *)a1[1];
    memmove(v6, a2, a3 << 6);
    a1[1] = &v6[64 * a3];
  }
  return a1;
}

void sub_1B89AE200(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(&STACK[0x400], 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<simd_float4x4>::~vector[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + _Block_object_dispose(&STACK[0x400], 8) = v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t ARNeutralBodySkeleton3DLocalTransforms(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  MEMORY[0x1F4188790](a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v923 = *MEMORY[0x1E4F143B8];
  {
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v14 = ARMakeSRT(_Q0);
    unsigned __int32 v469 = v14.n128_u32[2];
    unint64_t v468 = v14.n128_u64[0];
    long long v470 = v15;
    int v472 = v16;
    uint64_t v471 = v17;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v19 = ARMakeSRT(_Q0);
    unsigned __int32 v474 = v19.n128_u32[2];
    unint64_t v473 = v19.n128_u64[0];
    long long v475 = v20;
    int v477 = v21;
    uint64_t v476 = v22;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v24 = ARMakeSRT(_Q0);
    unsigned __int32 v479 = v24.n128_u32[2];
    unint64_t v478 = v24.n128_u64[0];
    long long v480 = v25;
    int v482 = v26;
    uint64_t v481 = v27;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v29 = ARMakeSRT(_Q0);
    unsigned __int32 v484 = v29.n128_u32[2];
    unint64_t v483 = v29.n128_u64[0];
    long long v485 = v30;
    int v487 = v31;
    uint64_t v486 = v32;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v34 = ARMakeSRT(_Q0);
    unsigned __int32 v489 = v34.n128_u32[2];
    unint64_t v488 = v34.n128_u64[0];
    long long v490 = v35;
    int v492 = v36;
    uint64_t v491 = v37;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v39 = ARMakeSRT(_Q0);
    unsigned __int32 v494 = v39.n128_u32[2];
    unint64_t v493 = v39.n128_u64[0];
    long long v495 = v40;
    int v497 = v41;
    uint64_t v496 = v42;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v44 = ARMakeSRT(_Q0);
    unsigned __int32 v499 = v44.n128_u32[2];
    unint64_t v498 = v44.n128_u64[0];
    long long v500 = v45;
    int v502 = v46;
    uint64_t v501 = v47;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v49 = ARMakeSRT(_Q0);
    unsigned __int32 v504 = v49.n128_u32[2];
    unint64_t v503 = v49.n128_u64[0];
    long long v505 = v50;
    int v507 = v51;
    uint64_t v506 = v52;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v54 = ARMakeSRT(_Q0);
    unsigned __int32 v509 = v54.n128_u32[2];
    unint64_t v508 = v54.n128_u64[0];
    long long v510 = v55;
    int v512 = v56;
    uint64_t v511 = v57;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v59 = ARMakeSRT(_Q0);
    unsigned __int32 v514 = v59.n128_u32[2];
    unint64_t v513 = v59.n128_u64[0];
    long long v515 = v60;
    int v517 = v61;
    uint64_t v516 = v62;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v64 = ARMakeSRT(_Q0);
    unsigned __int32 v519 = v64.n128_u32[2];
    unint64_t v518 = v64.n128_u64[0];
    long long v520 = v65;
    int v522 = v66;
    uint64_t v521 = v67;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v69 = ARMakeSRT(_Q0);
    unsigned __int32 v524 = v69.n128_u32[2];
    unint64_t v523 = v69.n128_u64[0];
    long long v525 = v70;
    int v527 = v71;
    uint64_t v526 = v72;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v74 = ARMakeSRT(_Q0);
    unsigned __int32 v529 = v74.n128_u32[2];
    unint64_t v528 = v74.n128_u64[0];
    long long v530 = v75;
    int v532 = v76;
    uint64_t v531 = v77;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v79 = ARMakeSRT(_Q0);
    unsigned __int32 v534 = v79.n128_u32[2];
    unint64_t v533 = v79.n128_u64[0];
    long long v535 = v80;
    int v537 = v81;
    uint64_t v536 = v82;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v84 = ARMakeSRT(_Q0);
    unsigned __int32 v539 = v84.n128_u32[2];
    unint64_t v538 = v84.n128_u64[0];
    long long v540 = v85;
    int v542 = v86;
    uint64_t v541 = v87;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v89 = ARMakeSRT(_Q0);
    unsigned __int32 v544 = v89.n128_u32[2];
    unint64_t v543 = v89.n128_u64[0];
    long long v545 = v90;
    int v547 = v91;
    uint64_t v546 = v92;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v94 = ARMakeSRT(_Q0);
    unsigned __int32 v549 = v94.n128_u32[2];
    unint64_t v548 = v94.n128_u64[0];
    long long v550 = v95;
    int v552 = v96;
    uint64_t v551 = v97;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v99 = ARMakeSRT(_Q0);
    unsigned __int32 v554 = v99.n128_u32[2];
    unint64_t v553 = v99.n128_u64[0];
    long long v555 = v100;
    int v557 = v101;
    uint64_t v556 = v102;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v104 = ARMakeSRT(_Q0);
    unsigned __int32 v559 = v104.n128_u32[2];
    unint64_t v558 = v104.n128_u64[0];
    long long v560 = v105;
    int v562 = v106;
    uint64_t v561 = v107;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v109 = ARMakeSRT(_Q0);
    unsigned __int32 v564 = v109.n128_u32[2];
    unint64_t v563 = v109.n128_u64[0];
    long long v565 = v110;
    int v567 = v111;
    uint64_t v566 = v112;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v114 = ARMakeSRT(_Q0);
    unsigned __int32 v569 = v114.n128_u32[2];
    unint64_t v568 = v114.n128_u64[0];
    long long v570 = v115;
    int v572 = v116;
    uint64_t v571 = v117;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v119 = ARMakeSRT(_Q0);
    unsigned __int32 v574 = v119.n128_u32[2];
    unint64_t v573 = v119.n128_u64[0];
    long long v575 = v120;
    int v577 = v121;
    uint64_t v576 = v122;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v124 = ARMakeSRT(_Q0);
    unsigned __int32 v579 = v124.n128_u32[2];
    unint64_t v578 = v124.n128_u64[0];
    long long v580 = v125;
    int v582 = v126;
    uint64_t v581 = v127;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v129 = ARMakeSRT(_Q0);
    unsigned __int32 v584 = v129.n128_u32[2];
    unint64_t v583 = v129.n128_u64[0];
    long long v585 = v130;
    int v587 = v131;
    uint64_t v586 = v132;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v134 = ARMakeSRT(_Q0);
    unsigned __int32 v589 = v134.n128_u32[2];
    unint64_t v588 = v134.n128_u64[0];
    long long v590 = v135;
    int v592 = v136;
    uint64_t v591 = v137;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v139 = ARMakeSRT(_Q0);
    unsigned __int32 v594 = v139.n128_u32[2];
    unint64_t v593 = v139.n128_u64[0];
    long long v595 = v140;
    int v597 = v141;
    uint64_t v596 = v142;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v144 = ARMakeSRT(_Q0);
    unsigned __int32 v599 = v144.n128_u32[2];
    unint64_t v598 = v144.n128_u64[0];
    long long v600 = v145;
    int v602 = v146;
    uint64_t v601 = v147;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v149 = ARMakeSRT(_Q0);
    unsigned __int32 v604 = v149.n128_u32[2];
    unint64_t v603 = v149.n128_u64[0];
    long long v605 = v150;
    int v607 = v151;
    uint64_t v606 = v152;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v154 = ARMakeSRT(_Q0);
    unsigned __int32 v609 = v154.n128_u32[2];
    unint64_t v608 = v154.n128_u64[0];
    long long v610 = v155;
    int v612 = v156;
    uint64_t v611 = v157;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v159 = ARMakeSRT(_Q0);
    unsigned __int32 v614 = v159.n128_u32[2];
    unint64_t v613 = v159.n128_u64[0];
    long long v615 = v160;
    int v617 = v161;
    uint64_t v616 = v162;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v164 = ARMakeSRT(_Q0);
    unsigned __int32 v619 = v164.n128_u32[2];
    unint64_t v618 = v164.n128_u64[0];
    long long v620 = v165;
    int v622 = v166;
    uint64_t v621 = v167;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v169 = ARMakeSRT(_Q0);
    unsigned __int32 v624 = v169.n128_u32[2];
    unint64_t v623 = v169.n128_u64[0];
    long long v625 = v170;
    int v627 = v171;
    uint64_t v626 = v172;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v174 = ARMakeSRT(_Q0);
    unsigned __int32 v629 = v174.n128_u32[2];
    unint64_t v628 = v174.n128_u64[0];
    long long v630 = v175;
    int v632 = v176;
    uint64_t v631 = v177;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v179 = ARMakeSRT(_Q0);
    unsigned __int32 v634 = v179.n128_u32[2];
    unint64_t v633 = v179.n128_u64[0];
    long long v635 = v180;
    int v637 = v181;
    uint64_t v636 = v182;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v184 = ARMakeSRT(_Q0);
    unsigned __int32 v639 = v184.n128_u32[2];
    unint64_t v638 = v184.n128_u64[0];
    long long v640 = v185;
    int v642 = v186;
    uint64_t v641 = v187;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v189 = ARMakeSRT(_Q0);
    unsigned __int32 v644 = v189.n128_u32[2];
    unint64_t v643 = v189.n128_u64[0];
    long long v645 = v190;
    int v647 = v191;
    uint64_t v646 = v192;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v194 = ARMakeSRT(_Q0);
    unsigned __int32 v649 = v194.n128_u32[2];
    unint64_t v648 = v194.n128_u64[0];
    long long v650 = v195;
    int v652 = v196;
    uint64_t v651 = v197;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v199 = ARMakeSRT(_Q0);
    unsigned __int32 v654 = v199.n128_u32[2];
    unint64_t v653 = v199.n128_u64[0];
    long long v655 = v200;
    int v657 = v201;
    uint64_t v656 = v202;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v204 = ARMakeSRT(_Q0);
    unsigned __int32 v659 = v204.n128_u32[2];
    unint64_t v658 = v204.n128_u64[0];
    long long v660 = v205;
    int v662 = v206;
    uint64_t v661 = v207;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v209 = ARMakeSRT(_Q0);
    unsigned __int32 v664 = v209.n128_u32[2];
    unint64_t v663 = v209.n128_u64[0];
    long long v665 = v210;
    int v667 = v211;
    uint64_t v666 = v212;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v214 = ARMakeSRT(_Q0);
    unsigned __int32 v669 = v214.n128_u32[2];
    unint64_t v668 = v214.n128_u64[0];
    long long v670 = v215;
    int v672 = v216;
    uint64_t v671 = v217;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v219 = ARMakeSRT(_Q0);
    unsigned __int32 v674 = v219.n128_u32[2];
    unint64_t v673 = v219.n128_u64[0];
    long long v675 = v220;
    int v677 = v221;
    uint64_t v676 = v222;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v224 = ARMakeSRT(_Q0);
    unsigned __int32 v679 = v224.n128_u32[2];
    unint64_t v678 = v224.n128_u64[0];
    long long v680 = v225;
    int v682 = v226;
    uint64_t v681 = v227;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v229 = ARMakeSRT(_Q0);
    unsigned __int32 v684 = v229.n128_u32[2];
    unint64_t v683 = v229.n128_u64[0];
    long long v685 = v230;
    int v687 = v231;
    uint64_t v686 = v232;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v234 = ARMakeSRT(_Q0);
    unsigned __int32 v689 = v234.n128_u32[2];
    unint64_t v688 = v234.n128_u64[0];
    long long v690 = v235;
    int v692 = v236;
    uint64_t v691 = v237;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v239 = ARMakeSRT(_Q0);
    unsigned __int32 v694 = v239.n128_u32[2];
    unint64_t v693 = v239.n128_u64[0];
    long long v695 = v240;
    int v697 = v241;
    uint64_t v696 = v242;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v244 = ARMakeSRT(_Q0);
    unsigned __int32 v699 = v244.n128_u32[2];
    unint64_t v698 = v244.n128_u64[0];
    long long v700 = v245;
    int v702 = v246;
    uint64_t v701 = v247;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v249 = ARMakeSRT(_Q0);
    unsigned __int32 v704 = v249.n128_u32[2];
    unint64_t v703 = v249.n128_u64[0];
    long long v705 = v250;
    int v707 = v251;
    uint64_t v706 = v252;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v254 = ARMakeSRT(_Q0);
    unsigned __int32 v709 = v254.n128_u32[2];
    unint64_t v708 = v254.n128_u64[0];
    long long v710 = v255;
    int v712 = v256;
    uint64_t v711 = v257;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v259 = ARMakeSRT(_Q0);
    unsigned __int32 v714 = v259.n128_u32[2];
    unint64_t v713 = v259.n128_u64[0];
    long long v715 = v260;
    int v717 = v261;
    uint64_t v716 = v262;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v264 = ARMakeSRT(_Q0);
    unsigned __int32 v719 = v264.n128_u32[2];
    unint64_t v718 = v264.n128_u64[0];
    long long v720 = v265;
    int v722 = v266;
    uint64_t v721 = v267;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v269 = ARMakeSRT(_Q0);
    unsigned __int32 v724 = v269.n128_u32[2];
    unint64_t v723 = v269.n128_u64[0];
    long long v725 = v270;
    int v727 = v271;
    uint64_t v726 = v272;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v274 = ARMakeSRT(_Q0);
    unsigned __int32 v729 = v274.n128_u32[2];
    unint64_t v728 = v274.n128_u64[0];
    long long v730 = v275;
    int v732 = v276;
    uint64_t v731 = v277;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v279 = ARMakeSRT(_Q0);
    unsigned __int32 v734 = v279.n128_u32[2];
    unint64_t v733 = v279.n128_u64[0];
    long long v735 = v280;
    int v737 = v281;
    uint64_t v736 = v282;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v284 = ARMakeSRT(_Q0);
    unsigned __int32 v739 = v284.n128_u32[2];
    unint64_t v738 = v284.n128_u64[0];
    long long v740 = v285;
    int v742 = v286;
    uint64_t v741 = v287;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v289 = ARMakeSRT(_Q0);
    unsigned __int32 v744 = v289.n128_u32[2];
    unint64_t v743 = v289.n128_u64[0];
    long long v745 = v290;
    int v747 = v291;
    uint64_t v746 = v292;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v294 = ARMakeSRT(_Q0);
    unsigned __int32 v749 = v294.n128_u32[2];
    unint64_t v748 = v294.n128_u64[0];
    long long v750 = v295;
    int v752 = v296;
    uint64_t v751 = v297;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v299 = ARMakeSRT(_Q0);
    unsigned __int32 v754 = v299.n128_u32[2];
    unint64_t v753 = v299.n128_u64[0];
    long long v755 = v300;
    int v757 = v301;
    uint64_t v756 = v302;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v304 = ARMakeSRT(_Q0);
    unsigned __int32 v759 = v304.n128_u32[2];
    unint64_t v758 = v304.n128_u64[0];
    long long v760 = v305;
    int v762 = v306;
    uint64_t v761 = v307;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v309 = ARMakeSRT(_Q0);
    unsigned __int32 v764 = v309.n128_u32[2];
    unint64_t v763 = v309.n128_u64[0];
    long long v765 = v310;
    int v767 = v311;
    uint64_t v766 = v312;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v314 = ARMakeSRT(_Q0);
    unsigned __int32 v769 = v314.n128_u32[2];
    unint64_t v768 = v314.n128_u64[0];
    long long v770 = v315;
    int v772 = v316;
    uint64_t v771 = v317;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v319 = ARMakeSRT(_Q0);
    unsigned __int32 v774 = v319.n128_u32[2];
    unint64_t v773 = v319.n128_u64[0];
    long long v775 = v320;
    int v777 = v321;
    uint64_t v776 = v322;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v324 = ARMakeSRT(_Q0);
    unsigned __int32 v779 = v324.n128_u32[2];
    unint64_t v778 = v324.n128_u64[0];
    long long v780 = v325;
    int v782 = v326;
    uint64_t v781 = v327;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v329 = ARMakeSRT(_Q0);
    unsigned __int32 v784 = v329.n128_u32[2];
    unint64_t v783 = v329.n128_u64[0];
    long long v785 = v330;
    int v787 = v331;
    uint64_t v786 = v332;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v334 = ARMakeSRT(_Q0);
    unsigned __int32 v789 = v334.n128_u32[2];
    unint64_t v788 = v334.n128_u64[0];
    long long v790 = v335;
    int v792 = v336;
    uint64_t v791 = v337;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v339 = ARMakeSRT(_Q0);
    unsigned __int32 v794 = v339.n128_u32[2];
    unint64_t v793 = v339.n128_u64[0];
    long long v795 = v340;
    int v797 = v341;
    uint64_t v796 = v342;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v344 = ARMakeSRT(_Q0);
    unsigned __int32 v799 = v344.n128_u32[2];
    unint64_t v798 = v344.n128_u64[0];
    long long v800 = v345;
    int v802 = v346;
    uint64_t v801 = v347;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v349 = ARMakeSRT(_Q0);
    unsigned __int32 v804 = v349.n128_u32[2];
    unint64_t v803 = v349.n128_u64[0];
    long long v805 = v350;
    int v807 = v351;
    uint64_t v806 = v352;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v354 = ARMakeSRT(_Q0);
    unsigned __int32 v809 = v354.n128_u32[2];
    unint64_t v808 = v354.n128_u64[0];
    long long v810 = v355;
    int v812 = v356;
    uint64_t v811 = v357;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v359 = ARMakeSRT(_Q0);
    unsigned __int32 v814 = v359.n128_u32[2];
    unint64_t v813 = v359.n128_u64[0];
    long long v815 = v360;
    int v817 = v361;
    uint64_t v816 = v362;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v364 = ARMakeSRT(_Q0);
    unsigned __int32 v819 = v364.n128_u32[2];
    unint64_t v818 = v364.n128_u64[0];
    long long v820 = v365;
    int v822 = v366;
    uint64_t v821 = v367;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v369 = ARMakeSRT(_Q0);
    unsigned __int32 v824 = v369.n128_u32[2];
    unint64_t v823 = v369.n128_u64[0];
    long long v825 = v370;
    int v827 = v371;
    uint64_t v826 = v372;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v374 = ARMakeSRT(_Q0);
    unsigned __int32 v829 = v374.n128_u32[2];
    unint64_t v828 = v374.n128_u64[0];
    long long v830 = v375;
    int v832 = v376;
    uint64_t v831 = v377;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v379 = ARMakeSRT(_Q0);
    unsigned __int32 v834 = v379.n128_u32[2];
    unint64_t v833 = v379.n128_u64[0];
    long long v835 = v380;
    int v837 = v381;
    uint64_t v836 = v382;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v384 = ARMakeSRT(_Q0);
    unsigned __int32 v839 = v384.n128_u32[2];
    unint64_t v838 = v384.n128_u64[0];
    long long v840 = v385;
    int v842 = v386;
    uint64_t v841 = v387;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v389 = ARMakeSRT(_Q0);
    unsigned __int32 v844 = v389.n128_u32[2];
    unint64_t v843 = v389.n128_u64[0];
    long long v845 = v390;
    int v847 = v391;
    uint64_t v846 = v392;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v394 = ARMakeSRT(_Q0);
    unsigned __int32 v849 = v394.n128_u32[2];
    unint64_t v848 = v394.n128_u64[0];
    long long v850 = v395;
    int v852 = v396;
    uint64_t v851 = v397;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v399 = ARMakeSRT(_Q0);
    unsigned __int32 v854 = v399.n128_u32[2];
    unint64_t v853 = v399.n128_u64[0];
    long long v855 = v400;
    int v857 = v401;
    uint64_t v856 = v402;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v404 = ARMakeSRT(_Q0);
    unsigned __int32 v859 = v404.n128_u32[2];
    unint64_t v858 = v404.n128_u64[0];
    long long v860 = v405;
    int v862 = v406;
    uint64_t v861 = v407;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v409 = ARMakeSRT(_Q0);
    unsigned __int32 v864 = v409.n128_u32[2];
    unint64_t v863 = v409.n128_u64[0];
    long long v865 = v410;
    int v867 = v411;
    uint64_t v866 = v412;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v414 = ARMakeSRT(_Q0);
    unsigned __int32 v869 = v414.n128_u32[2];
    unint64_t v868 = v414.n128_u64[0];
    long long v870 = v415;
    int v872 = v416;
    uint64_t v871 = v417;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v419 = ARMakeSRT(_Q0);
    unsigned __int32 v874 = v419.n128_u32[2];
    unint64_t v873 = v419.n128_u64[0];
    long long v875 = v420;
    int v877 = v421;
    uint64_t v876 = v422;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v424 = ARMakeSRT(_Q0);
    unsigned __int32 v879 = v424.n128_u32[2];
    unint64_t v878 = v424.n128_u64[0];
    long long v880 = v425;
    int v882 = v426;
    uint64_t v881 = v427;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v429 = ARMakeSRT(_Q0);
    unsigned __int32 v884 = v429.n128_u32[2];
    unint64_t v883 = v429.n128_u64[0];
    long long v885 = v430;
    int v887 = v431;
    uint64_t v886 = v432;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v434 = ARMakeSRT(_Q0);
    unsigned __int32 v889 = v434.n128_u32[2];
    unint64_t v888 = v434.n128_u64[0];
    long long v890 = v435;
    int v892 = v436;
    uint64_t v891 = v437;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v439 = ARMakeSRT(_Q0);
    unsigned __int32 v894 = v439.n128_u32[2];
    unint64_t v893 = v439.n128_u64[0];
    long long v895 = v440;
    int v897 = v441;
    uint64_t v896 = v442;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v444 = ARMakeSRT(_Q0);
    unsigned __int32 v899 = v444.n128_u32[2];
    unint64_t v898 = v444.n128_u64[0];
    long long v900 = v445;
    int v902 = v446;
    uint64_t v901 = v447;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v449 = ARMakeSRT(_Q0);
    unsigned __int32 v904 = v449.n128_u32[2];
    unint64_t v903 = v449.n128_u64[0];
    long long v905 = v450;
    int v907 = v451;
    uint64_t v906 = v452;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v454 = ARMakeSRT(_Q0);
    unsigned __int32 v909 = v454.n128_u32[2];
    unint64_t v908 = v454.n128_u64[0];
    long long v910 = v455;
    int v912 = v456;
    uint64_t v911 = v457;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v459 = ARMakeSRT(_Q0);
    unsigned __int32 v914 = v459.n128_u32[2];
    unint64_t v913 = v459.n128_u64[0];
    long long v915 = v460;
    int v917 = v461;
    uint64_t v916 = v462;
    __asm { FMOV            V0.4S, #1.0 }
    __n128 v464 = ARMakeSRT(_Q0);
    unsigned __int32 v919 = v464.n128_u32[2];
    unint64_t v918 = v464.n128_u64[0];
    long long v920 = v465;
    int v922 = v466;
    uint64_t v921 = v467;
    std::vector<ARSRT>::vector[abi:ne180100](ARNeutralBodySkeleton3DLocalTransforms::dataVector, &v468, 0x5BuLL);
    __cxa_atexit((void (*)(void *))std::vector<ARSRT>::~vector[abi:ne180100], ARNeutralBodySkeleton3DLocalTransforms::dataVector, &dword_1B88A2000);
  }
  uint64_t result = ARNeutralBodySkeleton3DLocalTransforms::dataVector[0];
  if (unk_1E9EEE058 - ARNeutralBodySkeleton3DLocalTransforms::dataVector[0] != 4368) {
    ARNeutralBodySkeleton3DLocalTransforms_cold_1();
  }
  return result;
}

void sub_1B89AF524(_Unwind_Exception *a1)
{
}

void *std::vector<ARSRT>::vector[abi:ne180100](void *a1, const void *a2, unint64_t a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a3)
  {
    std::vector<ARSRT>::__vallocate[abi:ne180100](a1, a3);
    uint64_t v6 = 3 * a3;
    size_t v7 = 48 * a3;
    unsigned int v8 = (char *)a1[1];
    memmove(v8, a2, v7);
    a1[1] = &v8[16 * v6];
  }
  return a1;
}

void sub_1B89AF5AC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(&STACK[0x400], 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<ARSRT>::~vector[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + _Block_object_dispose(&STACK[0x400], 8) = v2;
    operator delete(v2);
  }
  return a1;
}

char *std::vector<simd_float4x4>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >> 58) {
    std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<arkit::BoundingBoxGroup>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[64 * v4];
  return result;
}

char *std::vector<ARSRT>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x555555555555556) {
    std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<ARSRT>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[48 * v4];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<ARSRT>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x555555555555556) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(48 * a2);
}

void ARSurfaceUseCountIsZeroCallback(void *a1, uint64_t a2)
{
  id v3 = [a1 object];
  [v3 updateBufferPopulationRegistryWithReleasedSurfaceID:a2];
}

uint64_t ARBufferPopulationMonitorSignpostTypeForCaptureDevice(void *a1)
{
  id v1 = a1;
  if ((id)*MEMORY[0x1E4F15830] == v1)
  {
    uint64_t v2 = 1;
  }
  else if ((id)*MEMORY[0x1E4F15820] == v1)
  {
    uint64_t v2 = 4;
  }
  else if ((id)*MEMORY[0x1E4F15828] == v1)
  {
    uint64_t v2 = 2;
  }
  else
  {
    uint64_t v2 = 4 * (*MEMORY[0x1E4F15810] == (void)v1);
  }

  return v2;
}

uint64_t __Block_byref_object_copy__5(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__5(uint64_t a1)
{
}

void sub_1B89B017C(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B89B01EC(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B89B0258(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B89B0858(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89B08DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89B0978(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89B0B20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  _Unwind_Resume(a1);
}

void sub_1B89B0CC0(_Unwind_Exception *a1)
{
  int v5 = v4;

  _Unwind_Resume(a1);
}

void sub_1B89B0F20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_1B89B13F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20,void *a21,void *a22)
{
  _Unwind_Resume(a1);
}

void sub_1B89B1578(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  uint64_t v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)ARSpatialMappingResultData;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void ___ZL13_ARLogGeneralv_block_invoke_16()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "General");
  id v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObuint64_t j = (uint64_t)v0;
}

void *std::vector<unsigned char>::vector(void *a1, size_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<unsigned char>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v4 = (char *)a1[1];
    int v5 = &v4[a2];
    bzero(v4, a2);
    a1[1] = v5;
  }
  return a1;
}

void sub_1B89B16F8(_Unwind_Exception *exception_object)
{
  id v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(&STACK[0x400], 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

__n128 ARMinimumCornerForVertexSource(void *a1)
{
  id v1 = a1;
  uint64_t v2 = [v1 count];
  if (v2)
  {
    uint64_t v3 = v2;
    id v4 = [v1 buffer];
    uint64_t v5 = [v4 contents];

    *(void *)&long long v6 = *(void *)v5;
    float v8 = *(float *)(v5 + 8);
    size_t v7 = (float *)(v5 + 8);
    float v9 = v8;
    do
    {
      *(int8x8_t *)&long long v6 = vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)(v7 - 2), *(float32x2_t *)&v6), *(int8x8_t *)&v6, *(int8x8_t *)(v7 - 2));
      float v10 = *v7;
      v7 += 3;
      float v11 = v10;
      if (v9 >= v10) {
        float v9 = v11;
      }
      --v3;
    }
    while (v3);
    *((float *)&v6 + 2) = v9;
    long long v13 = v6;
  }
  else
  {
    long long v13 = 0u;
  }

  return (__n128)v13;
}

void ARConvertVisionSourceToWorldSource(void *a1, int a2, simd_float4 a3, simd_float4 a4, simd_float4 a5, simd_float4 a6)
{
  v21.columns[2] = a5;
  v21.columns[3] = a6;
  v21.columns[0] = a3;
  v21.columns[1] = a4;
  id v26 = a1;
  id v7 = [v26 buffer];
  uint64_t v8 = [v7 contents];

  simd_float4x4 v33 = __invert_f4(v21);
  v21.columns[2] = v33.columns[1];
  v21.columns[3] = v33.columns[0];
  v21.columns[0] = v33.columns[3];
  v21.columns[1] = v33.columns[2];
  *(double *)v9.i64 = ARVisionToRenderingCoordinateTransform();
  uint64_t v13 = 0;
  v27[0] = v21.columns[3];
  v27[1] = v21.columns[2];
  v27[2] = v21.columns[1];
  v27[3] = v21.columns[0];
  float32x4_t v28 = 0u;
  float32x4_t v29 = 0u;
  float32x4_t v30 = 0u;
  float32x4_t v31 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v28 + v13 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v9, COERCE_FLOAT(v27[v13])), v10, *(float32x2_t *)&v27[v13], 1), v11, (float32x4_t)v27[v13], 2), v12, (float32x4_t)v27[v13], 3);
    ++v13;
  }
  while (v13 != 4);
  float32x4_t v24 = v29;
  float32x4_t v25 = v28;
  float32x4_t v22 = v31;
  float32x4_t v23 = v30;
  uint64_t v14 = [v26 count];
  if (v14)
  {
    v15.i32[0] = 1.0;
    if (a2) {
      *(float *)v15.i32 = 0.0;
    }
    float32x4_t v16 = (float32x4_t)vdupq_lane_s32(v15, 0);
    uint64_t v17 = (float *)(v8 + 8);
    uint64_t v18 = 1;
    do
    {
      float32x4_t v19 = vmlaq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v25, *(v17 - 2)), v24, *(v17 - 1)), v23, *v17), v16, v22);
      if ((a2 & 1) == 0) {
        float32x4_t v19 = vdivq_f32(v19, (float32x4_t)vdupq_laneq_s32((int32x4_t)v19, 3));
      }
      *uint64_t v17 = v19.f32[2];
      *((void *)v17 - 1) = v19.i64[0];
      unint64_t v20 = v18 + 2;
      v18 += 3;
      v17 += 3;
    }
    while (v20 < 3 * v14);
  }
}

void sub_1B89B3A1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13)
{
  _Unwind_Resume(a1);
}

void std::vector<unsigned char>::reserve(unint64_t *a1, size_t __sz)
{
  unint64_t v2 = *a1;
  if (a1[2] - *a1 < __sz)
  {
    if ((__sz & 0x8000000000000000) != 0) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v5 = (char *)a1[1];
    long long v6 = operator new(__sz);
    id v7 = &v5[(void)v6 - v2];
    uint64_t v8 = v7;
    if (v5 != (char *)v2)
    {
      float32x4_t v9 = &v5[~v2];
      do
      {
        char v10 = *--v5;
        (v9--)[(void)v6] = v10;
      }
      while (v5 != (char *)v2);
      uint64_t v8 = v6;
    }
    *a1 = (unint64_t)v8;
    a1[1] = (unint64_t)v7;
    a1[2] = (unint64_t)&v6[__sz];
    if (v2)
    {
      operator delete((void *)v2);
    }
  }
}

void sub_1B89B3D3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)ARCubemapCompletion;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1B89B40B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89B459C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89B4C90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_1B89B4E68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1B89B5118(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL15_ARLogTechniquev_block_invoke_9()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "Technique");
  id v1 = (void *)_ARLogTechnique(void)::logObj;
  _ARLogTechnique(void)::logObuint64_t j = (uint64_t)v0;
}

void ___ZL13_ARLogGeneralv_block_invoke_17()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "General");
  id v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObuint64_t j = (uint64_t)v0;
}

void sub_1B89B543C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89B5694(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89B5720(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)ARSIPersonDetectionTechnique;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1B89B5944(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89B5BDC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL15_ARLogTechniquev_block_invoke_10()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "Technique");
  id v1 = (void *)_ARLogTechnique(void)::logObj;
  _ARLogTechnique(void)::logObuint64_t j = (uint64_t)v0;
}

void ___ZL13_ARLogGeneralv_block_invoke_18()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "General");
  id v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObuint64_t j = (uint64_t)v0;
}

BOOL ___ZL18ARSkipCrashOnCrashv_block_invoke_1()
{
  BOOL result = +[ARKitUserDefaults BOOLForKey:@"com.apple.arkit.skipCrashOnARCrash"];
  ARSkipCrashOnCrash(void)::skipCrashOnCrash = result;
  return result;
}

id _ARLogTechnique_12()
{
  if (_ARLogTechnique_onceToken_18 != -1) {
    dispatch_once(&_ARLogTechnique_onceToken_18, &__block_literal_global_91);
  }
  os_log_t v0 = (void *)_ARLogTechnique_logObj_18;
  return v0;
}

uint64_t ARViewToCameraImageTransform@<X0>(uint64_t result@<X0>, int a2@<W1>, uint64_t a3@<X8>, double a4@<D0>, double a5@<D1>, double a6@<D2>, double a7@<D3>)
{
  double v7 = a5 / a4;
  double v8 = a4 / a5;
  if ((unint64_t)(result - 3) <= 1) {
    double v7 = v8;
  }
  double v9 = *(double *)(MEMORY[0x1E4F1DAD8] + 8);
  double v10 = a6 / a7;
  if (v7 >= v10)
  {
    double v13 = *MEMORY[0x1E4F1DAD8];
    double v11 = 1.0;
    if (v7 <= v10)
    {
      double v12 = 1.0;
    }
    else
    {
      double v12 = v10 / v7;
      double v9 = (1.0 - v12) * 0.5;
    }
  }
  else
  {
    double v11 = v7 / v10;
    double v12 = 1.0;
    double v13 = (1.0 - v11) * 0.5;
  }
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)a3 = 0u;
  if (!a2)
  {
    if (result == 2)
    {
      double v13 = v13 + v11;
      *(double *)(a3 + _Block_object_dispose(&STACK[0x400], 8) = v12;
      *(double *)(a3 + 16) = -v11;
      goto LABEL_25;
    }
    if (result == 4)
    {
      double v13 = v13 + v11;
      *(double *)a3 = -v11;
      double v9 = v9 + v12;
      *(void *)(a3 + _Block_object_dispose(&STACK[0x400], 8) = 0;
      *(void *)(a3 + 16) = 0;
      *(double *)(a3 + 24) = -v12;
      goto LABEL_25;
    }
    if (result != 3)
    {
      double v9 = v9 + v12;
      *(double *)(a3 + _Block_object_dispose(&STACK[0x400], 8) = -v12;
      goto LABEL_24;
    }
    *(double *)a3 = v11;
LABEL_19:
    *(void *)(a3 + _Block_object_dispose(&STACK[0x400], 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(double *)(a3 + 24) = v12;
    goto LABEL_25;
  }
  if (result == 2)
  {
    double v13 = v13 + v11;
    double v9 = v9 + v12;
    *(double *)(a3 + _Block_object_dispose(&STACK[0x400], 8) = -v12;
    *(double *)(a3 + 16) = -v11;
    goto LABEL_25;
  }
  if (result == 4)
  {
    *(double *)a3 = -v11;
    double v13 = v13 + v11;
    goto LABEL_19;
  }
  if (result != 3)
  {
    *(double *)(a3 + _Block_object_dispose(&STACK[0x400], 8) = v12;
LABEL_24:
    *(double *)(a3 + 16) = v11;
    goto LABEL_25;
  }
  *(double *)a3 = v11;
  double v9 = v9 + v12;
  *(void *)(a3 + _Block_object_dispose(&STACK[0x400], 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(double *)(a3 + 24) = -v12;
LABEL_25:
  *(double *)(a3 + 32) = v13;
  *(double *)(a3 + 40) = v9;
  return result;
}

CGAffineTransform *ARCameraImageToViewTransform@<X0>(uint64_t a1@<X0>, int a2@<W1>, CGAffineTransform *a3@<X8>, double a4@<D0>, double a5@<D1>, double a6@<D2>, double a7@<D3>)
{
  ARViewToCameraImageTransform(a1, a2, (uint64_t)&v9, a6, a7, a4, a5);
  return CGAffineTransformInvert(a3, &v9);
}

uint64_t ARCameraToDisplayRotation(unint64_t a1)
{
  if (a1 > 4) {
    return 90;
  }
  else {
    return qword_1B8A565A8[a1];
  }
}

__CFString *NSStringFromUIInterfaceOrientation(unint64_t a1)
{
  if (a1 > 4) {
    return &stru_1F120C8F0;
  }
  else {
    return off_1E6187DD0[a1];
  }
}

id ARFrameworkVersions()
{
  if (ARFrameworkVersions_onceToken != -1) {
    dispatch_once(&ARFrameworkVersions_onceToken, &__block_literal_global_92);
  }
  os_log_t v0 = (void *)ARFrameworkVersions_frameworksVersionsDict;
  return v0;
}

void __ARFrameworkVersions_block_invoke()
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  os_log_t v0 = [MEMORY[0x1E4F1CA60] dictionary];
  long long v25 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  uint64_t v1 = [&unk_1F125BFC0 countByEnumeratingWithState:&v25 objects:v30 count:16];
  if (v1)
  {
    uint64_t v2 = v1;
    uint64_t v3 = *(void *)v26;
    do
    {
      uint64_t v4 = 0;
      do
      {
        if (*(void *)v26 != v3) {
          objc_enumerationMutation(&unk_1F125BFC0);
        }
        uint64_t v5 = *(void **)(*((void *)&v25 + 1) + 8 * v4);
        long long v6 = [MEMORY[0x1E4F28B50] bundleWithPath:v5];
        uint64_t v7 = [v5 lastPathComponent];
        double v8 = (void *)v7;
        if (v6) {
          goto LABEL_8;
        }
        CGAffineTransform v9 = (void *)MEMORY[0x1E4F28B50];
        double v10 = NSString;
        v29[0] = @"/AppleInternal/Library/Frameworks";
        v29[1] = v7;
        double v11 = [MEMORY[0x1E4F1C978] arrayWithObjects:v29 count:2];
        double v12 = [v10 pathWithComponents:v11];
        long long v6 = [v9 bundleWithPath:v12];

        if (v6)
        {
LABEL_8:
          double v13 = [v6 infoDictionary];
          uint64_t v14 = [v13 objectForKeyedSubscript:@"CFBundleName"];
          int32x2_t v15 = v14;
          if (v14)
          {
            id v16 = v14;
          }
          else
          {
            id v16 = [v8 stringByDeletingPathExtension];
          }
          uint64_t v17 = v16;

          uint64_t v18 = [v6 infoDictionary];
          uint64_t v19 = [v18 objectForKeyedSubscript:@"CFBundleVersion"];
          unint64_t v20 = (void *)v19;
          simd_float4x4 v21 = @"Unknown Version";
          if (v19) {
            simd_float4x4 v21 = (__CFString *)v19;
          }
          float32x4_t v22 = v21;
        }
        else
        {
          uint64_t v17 = [v8 stringByDeletingPathExtension];
          long long v6 = v8;
          float32x4_t v22 = @"Unknown Version";
        }

        [v0 setObject:v22 forKeyedSubscript:v17];
        ++v4;
      }
      while (v2 != v4);
      uint64_t v23 = [&unk_1F125BFC0 countByEnumeratingWithState:&v25 objects:v30 count:16];
      uint64_t v2 = v23;
    }
    while (v23);
  }
  float32x4_t v24 = (void *)ARFrameworkVersions_frameworksVersionsDict;
  ARFrameworkVersions_frameworksVersionsDict = (uint64_t)v0;
}

uint64_t ARObjectTrackingInternalErrorCodeIsTransientError(unint64_t a1)
{
  return (a1 > 9) | (0xA1u >> a1) & 1;
}

uint64_t ARObjectTrackingInternalErrorCodeShouldStopProvider(unint64_t a1)
{
  return (a1 > 7) | (0x56u >> a1) & 1;
}

id NSErrorFromARObjectTrackingInternalErrorCode(uint64_t a1)
{
  return NSErrorFromARObjectTrackingInternalErrorCodeAndUserInfo(a1, 0);
}

id NSErrorFromARObjectTrackingInternalErrorCodeAndUserInfo(uint64_t a1, void *a2)
{
  uint64_t v3 = (void *)MEMORY[0x1E4F28C58];
  uint64_t v4 = (void *)[a2 copy];
  uint64_t v5 = [v3 errorWithDomain:@"com.apple.arkit.error" code:a1 userInfo:v4];

  return v5;
}

id NSErrorFromARObjectTrackingODTError(void *a1)
{
  if (a1)
  {
    uint64_t v1 = (void *)MEMORY[0x1E4F28C58];
    uint64_t v2 = [a1 userInfo];
    uint64_t v3 = (void *)[v2 copy];
    uint64_t v4 = [v1 errorWithDomain:@"com.apple.arkit.error" code:4 userInfo:v3];
  }
  else
  {
    uint64_t v4 = 0;
  }
  return v4;
}

void sub_1B89B8AF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89B8D08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89B8D68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B89B9138(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89B9AE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,void *__p,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *a51,uint64_t a52)
{
  if (__p) {
    operator delete(__p);
  }
  if (a51) {
    operator delete(a51);
  }

  _Unwind_Resume(a1);
}

void _ZNSt3__16vectorIDv2_fNS_9allocatorIS1_EEE7reserveEm(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 3)
  {
    if (a2 >> 61) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    long long v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>(v3, a2);
    uint64_t v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    CGAffineTransform v9 = &v6[8 * v8];
    double v11 = (char *)*a1;
    double v10 = (char *)a1[1];
    double v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        uint64_t v13 = *((void *)v10 - 1);
        v10 -= 8;
        *((void *)v12 - 1) = v13;
        v12 -= 8;
      }
      while (v10 != v11);
      double v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

void ___ZL13_ARLogGeneralv_block_invoke_19()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "General");
  uint64_t v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObuint64_t j = (uint64_t)v0;
}

std::vector<unsigned int> *__cdecl std::vector<unsigned int>::vector(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __n)
{
  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  if (__n)
  {
    std::vector<float>::__vallocate[abi:ne180100](this, __n);
    std::vector<unsigned int>::pointer end = this->__end_;
    bzero(end, 4 * __n);
    this->__end_ = &end[__n];
  }
  return this;
}

void sub_1B89B9E48(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(&STACK[0x400], 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B89BB23C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89BBB24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *__p,uint64_t a41,uint64_t a42,void *a43,uint64_t a44)
{
  if (__p) {
    operator delete(__p);
  }
  if (a43) {
    operator delete(a43);
  }
  int v46 = *(void **)(v44 - 240);
  if (v46)
  {
    *(void *)(v44 - 232) = v46;
    operator delete(v46);
  }

  _Unwind_Resume(a1);
}

void std::vector<__ARC3DShapeVertex>::reserve(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (0xCCCCCCCCCCCCCCCDLL * ((v4 - (unsigned char *)*a1) >> 4) < a2)
  {
    if (a2 >= 0x333333333333334) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v5 = ((unsigned char *)a1[1] - (unsigned char *)*a1) / 80;
    long long v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<__ARC3DShapeVertex>>(v3, a2);
    uint64_t v7 = &v6[80 * v5];
    CGAffineTransform v9 = &v6[80 * v8];
    double v11 = (char *)*a1;
    double v10 = (char *)a1[1];
    double v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        *((_OWORD *)v12 - 5) = *((_OWORD *)v10 - 5);
        long long v13 = *((_OWORD *)v10 - 4);
        long long v14 = *((_OWORD *)v10 - 3);
        long long v15 = *((_OWORD *)v10 - 1);
        *((_OWORD *)v12 - 2) = *((_OWORD *)v10 - 2);
        *((_OWORD *)v12 - 1) = v15;
        *((_OWORD *)v12 - 4) = v13;
        *((_OWORD *)v12 - 3) = v14;
        v12 -= 80;
        v10 -= 80;
      }
      while (v10 != v11);
      double v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

void sub_1B89BBE40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B89BC170(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26)
{
  uint64_t v32 = v30;

  _Unwind_Resume(a1);
}

void ___ZL15_ARLogTechniquev_block_invoke_11()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "Technique");
  uint64_t v1 = (void *)_ARLogTechnique(void)::logObj;
  _ARLogTechnique(void)::logObuint64_t j = (uint64_t)v0;
}

void ___ZL13_ARLogGeneralv_block_invoke_20()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "General");
  uint64_t v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObuint64_t j = (uint64_t)v0;
}

char *std::vector<short>::__assign_with_size[abi:ne180100]<short const*,short const*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  unint64_t v8 = *((void *)result + 2);
  CGAffineTransform v9 = *(char **)result;
  if (a4 > (uint64_t)(v8 - *(void *)result) >> 1)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      unint64_t v8 = 0;
      *uint64_t v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if ((a4 & 0x8000000000000000) != 0) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    if (v8 <= a4) {
      unint64_t v10 = a4;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v8 >= 0x7FFFFFFFFFFFFFFELL) {
      uint64_t v11 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v11 = v10;
    }
    BOOL result = std::vector<short>::__vallocate[abi:ne180100](v7, v11);
    long long v13 = (char *)v7[1];
    double v12 = (void **)(v7 + 1);
    CGAffineTransform v9 = v13;
LABEL_17:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      uint64_t v18 = v9;
      uint64_t v19 = __src;
      goto LABEL_19;
    }
    goto LABEL_20;
  }
  double v12 = (void **)(result + 8);
  long long v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 1;
  if (v15 >= a4) {
    goto LABEL_17;
  }
  id v16 = &__src[2 * v15];
  if (v14 != v9)
  {
    BOOL result = (char *)memmove(*(void **)result, __src, v14 - v9);
    CGAffineTransform v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    uint64_t v18 = v9;
    uint64_t v19 = v16;
LABEL_19:
    BOOL result = (char *)memmove(v18, v19, v17);
  }
LABEL_20:
  *double v12 = &v9[v17];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<__ARC3DShapeVertex>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x333333333333334) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(80 * a2);
}

void *std::vector<short>::__init_with_size[abi:ne180100]<short const*,short const*>(void *result, const void *a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    long long v6 = result;
    BOOL result = std::vector<short>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      BOOL result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1B89BC4FC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(&STACK[0x400], 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B89BCA10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89BCB70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
  std::__tree<std::array<unsigned char,16ul>>::destroy((uint64_t)&a10, a11);
  std::__tree<std::__value_type<std::array<unsigned char,16ul>,std::set<std::array<unsigned char,16ul>>>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,std::set<std::array<unsigned char,16ul>>>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,std::set<std::array<unsigned char,16ul>>>>>::destroy(v11, *(void **)(v11 + 8));
  _Unwind_Resume(a1);
}

void *intersect<std::array<unsigned char,16ul>>@<X0>(void *result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)(a3 + 16) = 0;
  *(void *)(a3 + _Block_object_dispose(&STACK[0x400], 8) = 0;
  *(void *)a3 = a3 + 8;
  uint64_t v4 = result + 1;
  uint64_t v5 = (void *)*result;
  if ((void *)*result != result + 1)
  {
    uint64_t v7 = (void *)(a2 + 8);
    do
    {
      BOOL result = std::__tree<std::array<unsigned char,16ul>>::find<std::array<unsigned char,16ul>>(a2, (uint64_t)v5 + 25);
      if (v7 != result) {
        BOOL result = std::__tree<std::array<unsigned char,16ul>>::__emplace_unique_key_args<std::array<unsigned char,16ul>,std::array<unsigned char,16ul>>((uint64_t **)a3, (uint64_t)v5 + 25, (void *)((char *)v5 + 25));
      }
      size_t v8 = (void *)v5[1];
      if (v8)
      {
        do
        {
          CGAffineTransform v9 = v8;
          size_t v8 = (void *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          CGAffineTransform v9 = (void *)v5[2];
          BOOL v10 = *v9 == (void)v5;
          uint64_t v5 = v9;
        }
        while (!v10);
      }
      uint64_t v5 = v9;
    }
    while (v9 != v4);
  }
  return result;
}

void sub_1B89BCC60(_Unwind_Exception *a1)
{
  std::__tree<std::array<unsigned char,16ul>>::destroy(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

char *keys<std::array<unsigned char,16ul>,ARTexturedPlane>@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + _Block_object_dispose(&STACK[0x400], 8) = 0;
  *(void *)a2 = a2 + 8;
  uint64_t v3 = result + 8;
  uint64_t v4 = *(char **)result;
  if (*(char **)result != result + 8)
  {
    do
    {
      BOOL result = std::__tree<std::array<unsigned char,16ul>>::__emplace_unique_key_args<std::array<unsigned char,16ul>,std::array<unsigned char,16ul>>((uint64_t **)a2, (uint64_t)(v4 + 32), (_OWORD *)v4 + 2);
      uint64_t v5 = (char *)*((void *)v4 + 1);
      if (v5)
      {
        do
        {
          long long v6 = v5;
          uint64_t v5 = *(char **)v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          long long v6 = (char *)*((void *)v4 + 2);
          BOOL v7 = *(void *)v6 == (void)v4;
          uint64_t v4 = v6;
        }
        while (!v7);
      }
      uint64_t v4 = v6;
    }
    while (v6 != v3);
  }
  return result;
}

void sub_1B89BCD08(_Unwind_Exception *a1)
{
  std::__tree<std::array<unsigned char,16ul>>::destroy(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_1B89BD640(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,void *a25,uint64_t a26,char a27,void *a28,uint64_t a29,char a30,void *a31,uint64_t a32,char a33,void *a34,uint64_t a35,char a36,void *a37)
{
}

char *notInLeftButRight<std::array<unsigned char,16ul>>@<X0>(char *result@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)(a3 + 16) = 0;
  *(void *)(a3 + _Block_object_dispose(&STACK[0x400], 8) = 0;
  *(void *)a3 = a3 + 8;
  uint64_t v4 = a2 + 1;
  uint64_t v5 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    uint64_t v6 = (uint64_t)result;
    BOOL v7 = result + 8;
    do
    {
      BOOL result = (char *)std::__tree<std::array<unsigned char,16ul>>::find<std::array<unsigned char,16ul>>(v6, (uint64_t)v5 + 25);
      if (v7 == result) {
        BOOL result = std::__tree<std::array<unsigned char,16ul>>::__emplace_unique_key_args<std::array<unsigned char,16ul>,std::array<unsigned char,16ul>>((uint64_t **)a3, (uint64_t)v5 + 25, (void *)((char *)v5 + 25));
      }
      size_t v8 = (void *)v5[1];
      if (v8)
      {
        do
        {
          CGAffineTransform v9 = v8;
          size_t v8 = (void *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          CGAffineTransform v9 = (void *)v5[2];
          BOOL v10 = *v9 == (void)v5;
          uint64_t v5 = v9;
        }
        while (!v10);
      }
      uint64_t v5 = v9;
    }
    while (v9 != v4);
  }
  return result;
}

void sub_1B89BD7F4(_Unwind_Exception *a1)
{
  std::__tree<std::array<unsigned char,16ul>>::destroy(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t std::map<std::array<unsigned char,16ul>,ARTexturedPlane>::at(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__find_equal<std::array<unsigned char,16ul>>(a1, &v4, a2);
  if (!v2) {
    std::__throw_out_of_range[abi:ne180100]("map::at:  key not found");
  }
  return v2 + 48;
}

void sub_1B89BDF30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,char a46,void *a47,uint64_t a48,char a49,void *a50)
{
}

char *ARPlaneUpdateQueue::insert(void *a1, uint64_t a2, uint64_t a3, id *a4)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v21 = a2;
  *((void *)&v21 + 1) = a3;
  uint64_t v6 = (uint64_t **)(a1 + 6);
  BOOL result = (char *)std::__tree<std::array<unsigned char,16ul>>::find<std::array<unsigned char,16ul>>((uint64_t)(a1 + 6), (uint64_t)&v21);
  if (a1 + 7 == (void *)result)
  {
    long long v8 = *((_OWORD *)a4 + 8);
    long long v9 = *((_OWORD *)a4 + 10);
    long long v10 = *((_OWORD *)a4 + 11);
    v18[10] = *((_OWORD *)a4 + 9);
    v18[11] = v9;
    v18[12] = v10;
    long long v11 = *((_OWORD *)a4 + 4);
    long long v12 = *((_OWORD *)a4 + 6);
    long long v13 = *((_OWORD *)a4 + 7);
    v18[6] = *((_OWORD *)a4 + 5);
    v18[7] = v12;
    v18[8] = v13;
    v18[9] = v8;
    long long v14 = *(_OWORD *)a4;
    long long v15 = *((_OWORD *)a4 + 1);
    v18[0] = v21;
    v18[1] = v14;
    long long v16 = *((_OWORD *)a4 + 2);
    long long v17 = *((_OWORD *)a4 + 3);
    v18[2] = v15;
    v18[3] = v16;
    v18[4] = v17;
    v18[5] = v11;
    std::set<std::array<unsigned char,16ul>>::set[abi:ne180100]((uint64_t)v19, (uint64_t)(a4 + 24));
    id v20 = a4[27];
    std::deque<std::pair<std::array<unsigned char,16ul>,ARTexturedPlane>>::push_back(a1, (uint64_t)v18);

    std::__tree<std::array<unsigned char,16ul>>::destroy((uint64_t)v19, v19[1]);
    return std::__tree<std::array<unsigned char,16ul>>::__emplace_unique_key_args<std::array<unsigned char,16ul>,std::array<unsigned char,16ul>>(v6, (uint64_t)&v21, &v21);
  }
  return result;
}

void sub_1B89BE11C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::pair<std::array<unsigned char,16ul>,ARTexturedPlane>::~pair(uint64_t a1)
{
  std::__tree<std::array<unsigned char,16ul>>::destroy(a1 + 208, *(void **)(a1 + 216));
  return a1;
}

void sub_1B89BE250(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::vector<ARTexturedPlane>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

void sub_1B89BE344(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t **std::__tree<std::array<unsigned char,16ul>>::__assign_multi<std::__tree_const_iterator<std::array<unsigned char,16ul>,std::__tree_node<std::array<unsigned char,16ul>,void *> *,long>>(uint64_t **result, void *a2, void *a3)
{
  uint64_t v5 = result;
  if (result[2])
  {
    uint64_t v6 = *result;
    BOOL v7 = result[1];
    *BOOL result = (uint64_t *)(result + 1);
    v7[2] = 0;
    result[1] = 0;
    result[2] = 0;
    if (v6[1]) {
      long long v8 = (uint64_t *)v6[1];
    }
    else {
      long long v8 = v6;
    }
    long long v14 = result;
    long long v15 = v8;
    long long v16 = v8;
    if (v8)
    {
      long long v15 = std::__tree<std::array<unsigned char,16ul>>::_DetachedTreeCache::__detach_next((uint64_t)v8);
      if (a2 != a3)
      {
        long long v9 = a2;
        do
        {
          *(_OWORD *)((char *)v8 + 25) = *(_OWORD *)((char *)v9 + 25);
          std::__tree<std::array<unsigned char,16ul>>::__node_insert_multi(v5, v8);
          long long v8 = v15;
          long long v16 = v15;
          if (v15) {
            long long v15 = std::__tree<std::array<unsigned char,16ul>>::_DetachedTreeCache::__detach_next((uint64_t)v15);
          }
          long long v10 = (void *)v9[1];
          if (v10)
          {
            do
            {
              a2 = v10;
              long long v10 = (void *)*v10;
            }
            while (v10);
          }
          else
          {
            do
            {
              a2 = (void *)v9[2];
              BOOL v11 = *a2 == (void)v9;
              long long v9 = a2;
            }
            while (!v11);
          }
          if (!v8) {
            break;
          }
          long long v9 = a2;
        }
        while (a2 != a3);
      }
    }
    BOOL result = (uint64_t **)std::__tree<std::array<unsigned char,16ul>>::_DetachedTreeCache::~_DetachedTreeCache[abi:ne180100]((uint64_t)&v14);
  }
  if (a2 != a3)
  {
    do
    {
      BOOL result = (uint64_t **)std::__tree<std::array<unsigned char,16ul>>::__emplace_multi<std::array<unsigned char,16ul> const&>(v5, (void *)((char *)a2 + 25));
      long long v12 = (void *)a2[1];
      if (v12)
      {
        do
        {
          long long v13 = v12;
          long long v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          long long v13 = (void *)a2[2];
          BOOL v11 = *v13 == (void)a2;
          a2 = v13;
        }
        while (!v11);
      }
      a2 = v13;
    }
    while (v13 != a3);
  }
  return result;
}

void sub_1B89BE54C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__tree<std::array<unsigned char,16ul>>::_DetachedTreeCache::~_DetachedTreeCache[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::array<unsigned char,16ul>>::__node_insert_multi(uint64_t **a1, uint64_t *a2)
{
  uint64_t v3 = a1 + 1;
  uint64_t v4 = a1[1];
  if (v4)
  {
LABEL_2:
    while (2)
    {
      uint64_t v3 = (uint64_t **)v4;
      uint64_t v5 = 25;
      while (1)
      {
        unsigned int v6 = *((unsigned __int8 *)a2 + v5);
        unsigned int v7 = *((unsigned __int8 *)v3 + v5);
        if (v6 < v7) {
          break;
        }
        if (v7 >= v6 && v5++ != 40) {
          continue;
        }
        uint64_t v4 = v3[1];
        if (v4) {
          goto LABEL_2;
        }
        long long v9 = v3 + 1;
        goto LABEL_12;
      }
      uint64_t v4 = *v3;
      long long v9 = v3;
      if (*v3) {
        continue;
      }
      break;
    }
  }
  else
  {
    long long v9 = a1 + 1;
  }
LABEL_12:
  _ZNSt3__16__treeINS_12__value_typeIyDv4_fEENS_19__map_value_compareIyS3_NS_4lessIyEELb1EEENS_9allocatorIS3_EEE16__insert_node_atEPNS_15__tree_end_nodeIPNS_16__tree_node_baseIPvEEEERSF_SF_(a1, (uint64_t)v3, v9, a2);
  return a2;
}

void *std::__tree<std::array<unsigned char,16ul>>::_DetachedTreeCache::__detach_next(uint64_t a1)
{
  BOOL result = *(void **)(a1 + 16);
  if (result)
  {
    uint64_t v3 = (void *)*result;
    if (*result == a1)
    {
      *BOOL result = 0;
      while (1)
      {
        uint64_t v4 = (void *)result[1];
        if (!v4) {
          break;
        }
        do
        {
          BOOL result = v4;
          uint64_t v4 = (void *)*v4;
        }
        while (v4);
      }
    }
    else
    {
      for (result[1] = 0; v3; uint64_t v3 = (void *)result[1])
      {
        do
        {
          BOOL result = v3;
          uint64_t v3 = (void *)*v3;
        }
        while (v3);
      }
    }
  }
  return result;
}

uint64_t std::__tree<std::array<unsigned char,16ul>>::_DetachedTreeCache::~_DetachedTreeCache[abi:ne180100](uint64_t a1)
{
  std::__tree<std::array<unsigned char,16ul>>::destroy(*(void *)a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = (void *)v2[2];
    if (v3)
    {
      do
      {
        uint64_t v2 = v3;
        uint64_t v3 = (void *)v3[2];
      }
      while (v3);
      *(void *)(a1 + _Block_object_dispose(&STACK[0x400], 8) = v2;
    }
    std::__tree<std::array<unsigned char,16ul>>::destroy(*(void *)a1, v2);
  }
  return a1;
}

char *std::__tree<std::array<unsigned char,16ul>>::__emplace_multi<std::array<unsigned char,16ul> const&>(uint64_t **a1, _OWORD *a2)
{
  uint64_t v4 = (char *)operator new(0x30uLL);
  uint64_t v5 = v4;
  *(_OWORD *)(v4 + 25) = *a2;
  unsigned int v6 = a1 + 1;
  unsigned int v7 = a1[1];
  if (v7)
  {
LABEL_2:
    while (2)
    {
      unsigned int v6 = (uint64_t **)v7;
      uint64_t v8 = 25;
      while (1)
      {
        unsigned int v9 = v4[v8];
        unsigned int v10 = *((unsigned __int8 *)v6 + v8);
        if (v9 < v10) {
          break;
        }
        if (v10 >= v9 && v8++ != 40) {
          continue;
        }
        unsigned int v7 = v6[1];
        if (v7) {
          goto LABEL_2;
        }
        long long v12 = v6 + 1;
        goto LABEL_12;
      }
      unsigned int v7 = *v6;
      long long v12 = v6;
      if (*v6) {
        continue;
      }
      break;
    }
  }
  else
  {
    long long v12 = a1 + 1;
  }
LABEL_12:
  _ZNSt3__16__treeINS_12__value_typeIyDv4_fEENS_19__map_value_compareIyS3_NS_4lessIyEELb1EEENS_9allocatorIS3_EEE16__insert_node_atEPNS_15__tree_end_nodeIPNS_16__tree_node_baseIPvEEEERSF_SF_(a1, (uint64_t)v6, v12, (uint64_t *)v4);
  return v5;
}

uint64_t *std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__emplace_unique_key_args<std::array<unsigned char,16ul>,std::pair<std::array<unsigned char,16ul> const,ARTexturedPlane> const&>(uint64_t **a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = (uint64_t **)std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__find_equal<std::array<unsigned char,16ul>>((uint64_t)a1, &v8, a2);
  BOOL result = *v5;
  if (!*v5)
  {
    std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__construct_node<std::pair<std::array<unsigned char,16ul> const,ARTexturedPlane> const&>((uint64_t)a1, a3, (uint64_t)&v7);
    _ZNSt3__16__treeINS_12__value_typeIyDv4_fEENS_19__map_value_compareIyS3_NS_4lessIyEELb1EEENS_9allocatorIS3_EEE16__insert_node_atEPNS_15__tree_end_nodeIPNS_16__tree_node_baseIPvEEEERSF_SF_(a1, v8, v5, v7);
    return v7;
  }
  return result;
}

id std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__construct_node<std::pair<std::array<unsigned char,16ul> const,ARTexturedPlane> const&>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  unsigned int v6 = operator new(0x110uLL);
  *(void *)(a3 + _Block_object_dispose(&STACK[0x400], 8) = v5;
  *(void *)a3 = v6;
  *(unsigned char *)(a3 + 16) = 0;
  long long v7 = *(_OWORD *)(a2 + 176);
  v6[12] = *(_OWORD *)(a2 + 160);
  v6[13] = v7;
  v6[14] = *(_OWORD *)(a2 + 192);
  long long v8 = *(_OWORD *)(a2 + 112);
  v6[8] = *(_OWORD *)(a2 + 96);
  v6[9] = v8;
  long long v9 = *(_OWORD *)(a2 + 144);
  v6[10] = *(_OWORD *)(a2 + 128);
  v6[11] = v9;
  long long v10 = *(_OWORD *)(a2 + 16);
  v6[2] = *(_OWORD *)a2;
  void v6[3] = v10;
  long long v11 = *(_OWORD *)(a2 + 48);
  v6[4] = *(_OWORD *)(a2 + 32);
  v6[5] = v11;
  long long v12 = *(_OWORD *)(a2 + 80);
  v6[6] = *(_OWORD *)(a2 + 64);
  v6[7] = v12;
  std::set<std::array<unsigned char,16ul>>::set[abi:ne180100]((uint64_t)(v6 + 15), a2 + 208);
  id result = *(id *)(a2 + 232);
  *((void *)v6 + 33) = result;
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_1B89BE87C(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

void std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,void *>>>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 8))
  {

    std::__tree<std::array<unsigned char,16ul>>::destroy(a2 + 240, *(void **)(a2 + 248));
  }
  else if (!a2)
  {
    return;
  }
  operator delete((void *)a2);
}

void *std::__tree<std::array<unsigned char,16ul>>::find<std::array<unsigned char,16ul>>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void **)(a1 + 8);
  id result = (void *)(a1 + 8);
  uint64_t v3 = v4;
  if (v4)
  {
    uint64_t v5 = result;
    do
    {
      uint64_t v6 = 0;
      while (1)
      {
        unsigned int v7 = *((unsigned __int8 *)v3 + v6 + 25);
        unsigned int v8 = *(unsigned __int8 *)(a2 + v6);
        if (v7 < v8) {
          break;
        }
        if (v8 < v7 || v6++ == 15)
        {
          uint64_t v5 = v3;
          break;
        }
      }
      if (v7 < v8) {
        ++v3;
      }
      uint64_t v3 = (void *)*v3;
    }
    while (v3);
    if (v5 != result)
    {
      uint64_t v10 = 0;
      while (1)
      {
        unsigned int v11 = *(unsigned __int8 *)(a2 + v10);
        unsigned int v12 = *((unsigned __int8 *)v5 + v10 + 25);
        if (v11 < v12) {
          break;
        }
        if (v12 < v11 || v10++ == 15) {
          return v5;
        }
      }
    }
  }
  return result;
}

void std::deque<std::pair<std::array<unsigned char,16ul>,ARTexturedPlane>>::push_back(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 2 * (v4 - v5) + ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    std::deque<std::pair<std::array<unsigned char,16ul>,ARTexturedPlane>>::__add_back_capacity(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }
  uint64_t v8 = *(void *)(v5 + 8 * (v7 / 0x11));
  unint64_t v9 = v7 % 0x11;
  uint64_t v10 = v8 + 240 * v9;
  *(_OWORD *)uint64_t v10 = *(_OWORD *)a2;
  long long v11 = *(_OWORD *)(a2 + 128);
  long long v13 = *(_OWORD *)(a2 + 80);
  long long v12 = *(_OWORD *)(a2 + 96);
  *(_OWORD *)(v10 + 112) = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(v10 + 12_Block_object_dispose(&STACK[0x400], 8) = v11;
  *(_OWORD *)(v10 + 80) = v13;
  *(_OWORD *)(v10 + 96) = v12;
  long long v14 = *(_OWORD *)(a2 + 192);
  long long v16 = *(_OWORD *)(a2 + 144);
  long long v15 = *(_OWORD *)(a2 + 160);
  *(_OWORD *)(v10 + 176) = *(_OWORD *)(a2 + 176);
  *(_OWORD *)(v10 + 192) = v14;
  *(_OWORD *)(v10 + 144) = v16;
  *(_OWORD *)(v10 + 160) = v15;
  long long v17 = *(_OWORD *)(a2 + 16);
  long long v18 = *(_OWORD *)(a2 + 32);
  long long v19 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(v10 + 4_Block_object_dispose(&STACK[0x400], 8) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v10 + 64) = v19;
  *(_OWORD *)(v10 + 16) = v17;
  *(_OWORD *)(v10 + 32) = v18;
  *(void *)(v10 + 20_Block_object_dispose(&STACK[0x400], 8) = *(void *)(a2 + 208);
  id v20 = (void *)(v10 + 208);
  long long v21 = (void *)(a2 + 216);
  uint64_t v22 = *(void *)(a2 + 216);
  *(void *)(v10 + 216) = v22;
  uint64_t v23 = v10 + 216;
  uint64_t v24 = *(void *)(a2 + 224);
  *(void *)(v23 + _Block_object_dispose(&STACK[0x400], 8) = v24;
  if (v24)
  {
    *(void *)(v22 + 16) = v23;
    *(void *)(a2 + 20_Block_object_dispose(&STACK[0x400], 8) = v21;
    *long long v21 = 0;
    *(void *)(a2 + 224) = 0;
  }
  else
  {
    *id v20 = v23;
  }
  uint64_t v25 = v8 + 240 * v9;
  uint64_t v26 = *(void *)(a2 + 232);
  *(void *)(a2 + 232) = 0;
  *(void *)(v25 + 232) = v26;
  ++a1[5];
}

void std::deque<std::pair<std::array<unsigned char,16ul>,ARTexturedPlane>>::__add_back_capacity(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x11;
  unint64_t v4 = v2 - 17;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    uint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    unint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)uint64_t v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      __n128 v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>(v5, v33);
      long long v35 = &v34[8 * (v33 >> 2)];
      uint64_t v37 = &v34[8 * v36];
      float32x4_t v38 = (uint64_t *)a1[1];
      uint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        uint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        int v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)int v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    long long v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      unint64_t v9 = (char *)a1[1];
    }
    uint64_t v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0xFF0uLL);
      std::__split_buffer<std::pair<int,int> *,std::allocator<std::pair<int,int> *>>::push_back(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0xFF0uLL);
    std::__split_buffer<std::pair<int,int> *,std::allocator<std::pair<int,int> *>>::push_front((uint64_t)a1, &v54);
    uint64_t v44 = (void *)a1[1];
    uint64_t v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    unint64_t v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      __n128 v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>((uint64_t)(a1 + 3), v46);
      long long v35 = &v34[8 * (v46 >> 2)];
      uint64_t v37 = &v34[8 * v47];
      float32x4_t v48 = (uint64_t *)a1[1];
      uint64_t v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        uint64_t v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        int v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)int v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      float32x4_t v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        uint64_t v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  int v56 = a1 + 3;
  *(void *)&long long v54 = std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  id v53 = operator new(0xFF0uLL);
  std::__split_buffer<std::pair<int,int> *,std::allocator<std::pair<int,int> *> &>::push_back(&v54, &v53);
  long long v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    std::__split_buffer<std::pair<int,int> *,std::allocator<std::pair<int,int> *> &>::push_front((uint64_t)&v54, v27);
  }
  float32x4_t v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_1B89BED70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t std::__tree<std::array<unsigned char,16ul>>::__erase_unique<std::array<unsigned char,16ul>>(uint64_t **a1, uint64_t a2)
{
  BOOL v3 = std::__tree<std::array<unsigned char,16ul>>::find<std::array<unsigned char,16ul>>((uint64_t)a1, a2);
  if (a1 + 1 == (uint64_t **)v3) {
    return 0;
  }
  unint64_t v4 = v3;
  std::__tree<std::array<unsigned char,16ul>>::__remove_node_pointer(a1, v3);
  operator delete(v4);
  return 1;
}

uint64_t *std::__tree<std::array<unsigned char,16ul>>::__remove_node_pointer(uint64_t **a1, uint64_t *a2)
{
  unint64_t v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      BOOL v3 = v2;
      unint64_t v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    unint64_t v4 = a2;
    do
    {
      BOOL v3 = (uint64_t *)v4[2];
      BOOL v5 = *v3 == (void)v4;
      unint64_t v4 = v3;
    }
    while (!v5);
  }
  if (*a1 == a2) {
    *a1 = v3;
  }
  uint64_t v6 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v6, a2);
  return v3;
}

uint64_t *std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  BOOL v3 = a2;
  if (*a2)
  {
    unint64_t v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      BOOL v3 = a2;
      goto LABEL_7;
    }
    do
    {
      BOOL v3 = v4;
      unint64_t v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  uint64_t v2 = v3[1];
  if (v2)
  {
LABEL_7:
    int v5 = 0;
    *(void *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  int v5 = 1;
LABEL_8:
  uint64_t v6 = (uint64_t **)v3[2];
  unint64_t v7 = *v6;
  if (*v6 == v3)
  {
    uint64_t *v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      unint64_t v7 = 0;
      id result = (uint64_t *)v2;
    }
    else
    {
      unint64_t v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (uint64_t *)v2;
  }
  int v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    uint64_t v9 = a2[2];
    _OWORD v3[2] = v9;
    *(void *)(v9 + 8 * (*(void *)a2[2] != (void)a2)) = v3;
    uint64_t v11 = *a2;
    uint64_t v10 = a2[1];
    *(void *)(v11 + 16) = v3;
    uint64_t *v3 = v11;
    v3[1] = v10;
    if (v10) {
      *(void *)(v10 + 16) = v3;
    }
    *((unsigned char *)v3 + 24) = *((unsigned char *)a2 + 24);
    if (result == a2) {
      id result = v3;
    }
  }
  if (!v8 || !result) {
    return result;
  }
  if (!v5)
  {
    *(unsigned char *)(v2 + 24) = 1;
    return result;
  }
  while (1)
  {
    uint64_t v12 = v7[2];
    if (*(uint64_t **)v12 == v7) {
      break;
    }
    if (!*((unsigned char *)v7 + 24))
    {
      *((unsigned char *)v7 + 24) = 1;
      *(unsigned char *)(v12 + 24) = 0;
      uint64_t v13 = *(uint64_t **)(v12 + 8);
      uint64_t v14 = *v13;
      *(void *)(v12 + _Block_object_dispose(&STACK[0x400], 8) = *v13;
      if (v14) {
        *(void *)(v14 + 16) = v12;
      }
      void v13[2] = *(void *)(v12 + 16);
      *(void *)(*(void *)(v12 + 16) + 8 * (**(void **)(v12 + 16) != v12)) = v13;
      uint64_t *v13 = v12;
      *(void *)(v12 + 16) = v13;
      if (result == (uint64_t *)*v7) {
        id result = v7;
      }
      unint64_t v7 = *(uint64_t **)(*v7 + 8);
    }
    uint64_t v15 = (void *)*v7;
    if (*v7 && !*((unsigned char *)v15 + 24))
    {
      uint64_t v16 = (uint64_t *)v7[1];
      if (!v16) {
        goto LABEL_56;
      }
LABEL_55:
      if (*((unsigned char *)v16 + 24))
      {
LABEL_56:
        *((unsigned char *)v15 + 24) = 1;
        *((unsigned char *)v7 + 24) = 0;
        uint64_t v22 = v15[1];
        *unint64_t v7 = v22;
        if (v22) {
          *(void *)(v22 + 16) = v7;
        }
        v15[2] = v7[2];
        *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v15;
        v15[1] = v7;
        v7[2] = (uint64_t)v15;
        uint64_t v16 = v7;
      }
      else
      {
        uint64_t v15 = v7;
      }
      uint64_t v23 = v15[2];
      *((unsigned char *)v15 + 24) = *(unsigned char *)(v23 + 24);
      *(unsigned char *)(v23 + 24) = 1;
      *((unsigned char *)v16 + 24) = 1;
      uint64_t v24 = *(uint64_t **)(v23 + 8);
      uint64_t v25 = *v24;
      *(void *)(v23 + _Block_object_dispose(&STACK[0x400], 8) = *v24;
      if (v25) {
        *(void *)(v25 + 16) = v23;
      }
      v24[2] = *(void *)(v23 + 16);
      *(void *)(*(void *)(v23 + 16) + 8 * (**(void **)(v23 + 16) != v23)) = v24;
      *uint64_t v24 = v23;
      goto LABEL_72;
    }
    uint64_t v16 = (uint64_t *)v7[1];
    if (v16 && !*((unsigned char *)v16 + 24)) {
      goto LABEL_55;
    }
    *((unsigned char *)v7 + 24) = 0;
    uint64_t v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      uint64_t v17 = result;
LABEL_53:
      *((unsigned char *)v17 + 24) = 1;
      return result;
    }
    if (!*((unsigned char *)v17 + 24)) {
      goto LABEL_53;
    }
LABEL_49:
    unint64_t v7 = *(uint64_t **)(v17[2] + 8 * (*(void *)v17[2] == (void)v17));
  }
  if (!*((unsigned char *)v7 + 24))
  {
    *((unsigned char *)v7 + 24) = 1;
    *(unsigned char *)(v12 + 24) = 0;
    uint64_t v18 = v7[1];
    *(void *)uint64_t v12 = v18;
    if (v18) {
      *(void *)(v18 + 16) = v12;
    }
    v7[2] = *(void *)(v12 + 16);
    *(void *)(*(void *)(v12 + 16) + 8 * (**(void **)(v12 + 16) != v12)) = v7;
    v7[1] = v12;
    *(void *)(v12 + 16) = v7;
    if (result == (uint64_t *)v12) {
      id result = v7;
    }
    unint64_t v7 = *(uint64_t **)v12;
  }
  long long v19 = (void *)*v7;
  if (*v7 && !*((unsigned char *)v19 + 24)) {
    goto LABEL_68;
  }
  int64_t v20 = (uint64_t *)v7[1];
  if (!v20 || *((unsigned char *)v20 + 24))
  {
    *((unsigned char *)v7 + 24) = 0;
    uint64_t v17 = (uint64_t *)v7[2];
    if (*((unsigned char *)v17 + 24)) {
      BOOL v21 = v17 == result;
    }
    else {
      BOOL v21 = 1;
    }
    if (v21) {
      goto LABEL_53;
    }
    goto LABEL_49;
  }
  if (v19 && !*((unsigned char *)v19 + 24))
  {
LABEL_68:
    int64_t v20 = v7;
  }
  else
  {
    *((unsigned char *)v20 + 24) = 1;
    *((unsigned char *)v7 + 24) = 0;
    uint64_t v26 = *v20;
    v7[1] = *v20;
    if (v26) {
      *(void *)(v26 + 16) = v7;
    }
    v20[2] = v7[2];
    *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v20;
    *int64_t v20 = (uint64_t)v7;
    v7[2] = (uint64_t)v20;
    long long v19 = v7;
  }
  uint64_t v23 = v20[2];
  *((unsigned char *)v20 + 24) = *(unsigned char *)(v23 + 24);
  *(unsigned char *)(v23 + 24) = 1;
  *((unsigned char *)v19 + 24) = 1;
  uint64_t v24 = *(uint64_t **)v23;
  uint64_t v27 = *(void *)(*(void *)v23 + 8);
  *(void *)uint64_t v23 = v27;
  if (v27) {
    *(void *)(v27 + 16) = v23;
  }
  v24[2] = *(void *)(v23 + 16);
  *(void *)(*(void *)(v23 + 16) + 8 * (**(void **)(v23 + 16) != v23)) = v24;
  v24[1] = v23;
LABEL_72:
  *(void *)(v23 + 16) = v24;
  return result;
}

uint64_t std::deque<std::pair<std::array<unsigned char,16ul>,ARTexturedPlane>>::pop_front(int64x2_t *a1)
{
  unint64_t v2 = *(void *)(a1->i64[1] + 8 * (a1[2].i64[0] / 0x11uLL)) + 240 * (a1[2].i64[0] % 0x11uLL);

  std::__tree<std::array<unsigned char,16ul>>::destroy(v2 + 208, *(void **)(v2 + 216));
  a1[2] = vaddq_s64(a1[2], (int64x2_t)xmmword_1B8A56670);
  return std::deque<std::pair<std::array<unsigned char,16ul>,ARTexturedPlane>>::__maybe_remove_front_spare[abi:ne180100]((uint64_t)a1, 1);
}

uint64_t std::deque<std::pair<std::array<unsigned char,16ul>,ARTexturedPlane>>::__maybe_remove_front_spare[abi:ne180100](uint64_t a1, int a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 < 0x11) {
    a2 = 1;
  }
  if (v2 < 0x22) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8;
    *(void *)(a1 + 32) -= 17;
  }
  return v4 ^ 1u;
}

uint64_t std::deque<std::pair<std::array<unsigned char,16ul>,ARTexturedPlane>>::~deque[abi:ne180100](void *a1)
{
  unint64_t v2 = (void **)a1[1];
  BOOL v3 = (void **)a1[2];
  if (v3 == v2)
  {
    int v4 = a1 + 5;
    BOOL v3 = (void **)a1[1];
  }
  else
  {
    int v4 = a1 + 5;
    unint64_t v5 = a1[4];
    uint64_t v6 = &v2[v5 / 0x11];
    unint64_t v7 = (unint64_t)*v6 + 240 * (v5 % 0x11);
    unint64_t v8 = (unint64_t)v2[(a1[5] + v5) / 0x11] + 240 * ((a1[5] + v5) % 0x11);
    if (v7 != v8)
    {
      do
      {

        std::__tree<std::array<unsigned char,16ul>>::destroy(v7 + 208, *(void **)(v7 + 216));
        v7 += 240;
        if (v7 - (void)*v6 == 4080)
        {
          unint64_t v9 = (unint64_t)v6[1];
          ++v6;
          unint64_t v7 = v9;
        }
      }
      while (v7 != v8);
      unint64_t v2 = (void **)a1[1];
      BOOL v3 = (void **)a1[2];
    }
  }
  *int v4 = 0;
  unint64_t v10 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      BOOL v3 = (void **)a1[2];
      unint64_t v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v10 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v11 = v10 >> 3;
  if (v11 == 1)
  {
    uint64_t v12 = 8;
  }
  else
  {
    if (v11 != 2) {
      goto LABEL_16;
    }
    uint64_t v12 = 17;
  }
  a1[4] = v12;
LABEL_16:
  while (v2 != v3)
  {
    uint64_t v13 = *v2++;
    operator delete(v13);
  }
  return std::__split_buffer<std::pair<int,int> *,std::allocator<std::pair<int,int> *>>::~__split_buffer((uint64_t)a1);
}

void std::__tree<std::__value_type<std::array<unsigned char,16ul>,std::set<std::array<unsigned char,16ul>>>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,std::set<std::array<unsigned char,16ul>>>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,std::set<std::array<unsigned char,16ul>>>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::array<unsigned char,16ul>,std::set<std::array<unsigned char,16ul>>>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,std::set<std::array<unsigned char,16ul>>>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,std::set<std::array<unsigned char,16ul>>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<std::array<unsigned char,16ul>,std::set<std::array<unsigned char,16ul>>>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,std::set<std::array<unsigned char,16ul>>>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,std::set<std::array<unsigned char,16ul>>>>>::destroy(a1, a2[1]);
    std::__tree<std::array<unsigned char,16ul>>::destroy((uint64_t)(a2 + 6), (void *)a2[7]);
    operator delete(a2);
  }
}

_OWORD *std::__tree<std::__value_type<std::array<unsigned char,16ul>,std::set<std::array<unsigned char,16ul>>>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,std::set<std::array<unsigned char,16ul>>>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,std::set<std::array<unsigned char,16ul>>>>>::__emplace_unique_key_args<std::array<unsigned char,16ul>,std::piecewise_construct_t const&,std::tuple<std::array<unsigned char,16ul> const&>,std::tuple<>>(uint64_t **a1, uint64_t a2, uint64_t a3, _OWORD **a4)
{
  uint64_t v6 = (void **)std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__find_equal<std::array<unsigned char,16ul>>((uint64_t)a1, &v10, a2);
  unint64_t v7 = *v6;
  if (!*v6)
  {
    unint64_t v8 = (uint64_t **)v6;
    unint64_t v7 = operator new(0x48uLL);
    v7[2] = **a4;
    *((void *)v7 + _Block_object_dispose(&STACK[0x400], 8) = 0;
    *((void *)v7 + 7) = 0;
    *((void *)v7 + 6) = (char *)v7 + 56;
    _ZNSt3__16__treeINS_12__value_typeIyDv4_fEENS_19__map_value_compareIyS3_NS_4lessIyEELb1EEENS_9allocatorIS3_EEE16__insert_node_atEPNS_15__tree_end_nodeIPNS_16__tree_node_baseIPvEEEERSF_SF_(a1, v10, v8, (uint64_t *)v7);
  }
  return v7;
}

void std::__throw_out_of_range[abi:ne180100](const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::out_of_range::out_of_range[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_1E6184910, MEMORY[0x1E4FBA1D0]);
}

void sub_1B89BF59C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::out_of_range::out_of_range[abi:ne180100](std::logic_error *a1, const char *a2)
{
  id result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D8] + 16);
  return result;
}

void *std::__tree<std::__value_type<std::array<unsigned char,16ul>,std::set<std::array<unsigned char,16ul>>>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,std::set<std::array<unsigned char,16ul>>>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,std::set<std::array<unsigned char,16ul>>>>>::find<std::array<unsigned char,16ul>>(uint64_t a1, uint64_t a2)
{
  int v4 = *(void **)(a1 + 8);
  id result = (void *)(a1 + 8);
  BOOL v3 = v4;
  if (v4)
  {
    unint64_t v5 = result;
    do
    {
      uint64_t v6 = 0;
      while (1)
      {
        unsigned int v7 = *((unsigned __int8 *)v3 + v6 + 32);
        unsigned int v8 = *(unsigned __int8 *)(a2 + v6);
        if (v7 < v8) {
          break;
        }
        if (v8 < v7 || v6++ == 15)
        {
          unint64_t v5 = v3;
          break;
        }
      }
      if (v7 < v8) {
        ++v3;
      }
      BOOL v3 = (void *)*v3;
    }
    while (v3);
    if (v5 != result)
    {
      uint64_t v10 = 0;
      while (1)
      {
        unsigned int v11 = *(unsigned __int8 *)(a2 + v10);
        unsigned int v12 = *((unsigned __int8 *)v5 + v10 + 32);
        if (v11 < v12) {
          break;
        }
        if (v12 < v11 || v10++ == 15) {
          return v5;
        }
      }
    }
  }
  return result;
}

uint64_t *std::map<std::array<unsigned char,16ul>,ARTexturedPlane>::map[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  std::map<std::array<unsigned char,16ul>,ARTexturedPlane>::insert[abi:ne180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__tree_node<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,void *> *,long>>>(a1, *(void **)a2, (void *)(a2 + 8));
  return a1;
}

void sub_1B89BF6A8(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::destroy(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *std::map<std::array<unsigned char,16ul>,ARTexturedPlane>::insert[abi:ne180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__tree_node<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,void *> *,long>>>(uint64_t *result, void *a2, void *a3)
{
  if (a2 != a3)
  {
    int v4 = a2;
    unint64_t v5 = (uint64_t **)result;
    uint64_t v6 = result + 1;
    do
    {
      id result = std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__emplace_hint_unique_key_args<std::array<unsigned char,16ul>,std::pair<std::array<unsigned char,16ul> const,ARTexturedPlane> const&>(v5, v6, (uint64_t)(v4 + 4), (uint64_t)(v4 + 4));
      unsigned int v7 = (void *)v4[1];
      if (v7)
      {
        do
        {
          unsigned int v8 = v7;
          unsigned int v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          unsigned int v8 = (void *)v4[2];
          BOOL v9 = *v8 == (void)v4;
          int v4 = v8;
        }
        while (!v9);
      }
      int v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__emplace_hint_unique_key_args<std::array<unsigned char,16ul>,std::pair<std::array<unsigned char,16ul> const,ARTexturedPlane> const&>(uint64_t **a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = (uint64_t **)std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__find_equal<std::array<unsigned char,16ul>>(a1, a2, &v10, &v9, a3);
  id result = *v6;
  if (!*v6)
  {
    std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__construct_node<std::pair<std::array<unsigned char,16ul> const,ARTexturedPlane> const&>((uint64_t)a1, a4, (uint64_t)&v8);
    _ZNSt3__16__treeINS_12__value_typeIyDv4_fEENS_19__map_value_compareIyS3_NS_4lessIyEELb1EEENS_9allocatorIS3_EEE16__insert_node_atEPNS_15__tree_end_nodeIPNS_16__tree_node_baseIPvEEEERSF_SF_(a1, v10, v6, v8);
    return v8;
  }
  return result;
}

void *std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__find_equal<std::array<unsigned char,16ul>>(void *a1, void *a2, void *a3, void *a4, uint64_t a5)
{
  if (a1 + 1 != a2)
  {
    uint64_t v5 = 0;
    while (1)
    {
      unsigned int v6 = *(unsigned __int8 *)(a5 + v5);
      unsigned int v7 = *((unsigned __int8 *)a2 + v5 + 32);
      if (v6 < v7) {
        break;
      }
      BOOL v8 = v7 < v6 || v5++ == 15;
      if (v8)
      {
        uint64_t v9 = 0;
        while (1)
        {
          unsigned int v10 = *((unsigned __int8 *)a2 + v9 + 32);
          unsigned int v11 = *(unsigned __int8 *)(a5 + v9);
          if (v10 < v11) {
            break;
          }
          if (v11 < v10 || v9++ == 15)
          {
            *a3 = a2;
            *a4 = a2;
            return a4;
          }
        }
        uint64_t v22 = a2[1];
        if (v22)
        {
          uint64_t v23 = (void *)a2[1];
          do
          {
            a4 = v23;
            uint64_t v23 = (void *)*v23;
          }
          while (v23);
        }
        else
        {
          uint64_t v24 = a2;
          do
          {
            a4 = (void *)v24[2];
            BOOL v8 = *a4 == (void)v24;
            uint64_t v24 = a4;
          }
          while (!v8);
        }
        if (a4 != a1 + 1)
        {
          uint64_t v25 = 0;
          while (1)
          {
            unsigned int v26 = *(unsigned __int8 *)(a5 + v25);
            unsigned int v27 = *((unsigned __int8 *)a4 + v25 + 32);
            if (v26 < v27) {
              break;
            }
            if (v27 < v26 || v25++ == 15) {
              return std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__find_equal<std::array<unsigned char,16ul>>((uint64_t)a1, a3, a5);
            }
          }
        }
        if (v22)
        {
          *a3 = a4;
        }
        else
        {
          *a3 = a2;
          return a2 + 1;
        }
        return a4;
      }
    }
  }
  uint64_t v13 = *a2;
  if ((void *)*a1 == a2)
  {
    uint64_t v15 = a2;
  }
  else
  {
    if (v13)
    {
      uint64_t v14 = (void *)*a2;
      do
      {
        uint64_t v15 = v14;
        uint64_t v14 = (void *)v14[1];
      }
      while (v14);
    }
    else
    {
      uint64_t v16 = a2;
      do
      {
        uint64_t v15 = (void *)v16[2];
        BOOL v8 = *v15 == (void)v16;
        uint64_t v16 = v15;
      }
      while (v8);
    }
    uint64_t v17 = 0;
    while (1)
    {
      unsigned int v18 = *((unsigned __int8 *)v15 + v17 + 32);
      unsigned int v19 = *(unsigned __int8 *)(a5 + v17);
      if (v18 < v19) {
        break;
      }
      if (v19 < v18 || v17++ == 15) {
        return std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__find_equal<std::array<unsigned char,16ul>>((uint64_t)a1, a3, a5);
      }
    }
  }
  if (v13)
  {
    *a3 = v15;
    return v15 + 1;
  }
  else
  {
    *a3 = a2;
    return a2;
  }
}

uint64_t **std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__assign_multi<std::__tree_const_iterator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__tree_node<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,void *> *,long>>(uint64_t **result, void *a2, void *a3)
{
  uint64_t v5 = result;
  if (result[2])
  {
    unsigned int v6 = *result;
    unsigned int v7 = result[1];
    *id result = (uint64_t *)(result + 1);
    v7[2] = 0;
    result[1] = 0;
    result[2] = 0;
    if (v6[1]) {
      BOOL v8 = (uint64_t *)v6[1];
    }
    else {
      BOOL v8 = v6;
    }
    uint64_t v14 = result;
    uint64_t v15 = v8;
    uint64_t v16 = v8;
    if (v8)
    {
      uint64_t v15 = std::__tree<std::array<unsigned char,16ul>>::_DetachedTreeCache::__detach_next((uint64_t)v8);
      if (a2 != a3)
      {
        uint64_t v9 = a2;
        do
        {
          v17[0] = v8 + 4;
          v17[1] = v8 + 6;
          std::pair<std::array<unsigned char,16ul> &,ARTexturedPlane &>::operator=[abi:ne180100]<std::array<unsigned char,16ul> const,ARTexturedPlane,(void *)0>((uint64_t)v17, (uint64_t)(v9 + 4));
          std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__node_insert_multi(v5, v16);
          uint64_t v16 = v15;
          if (v15) {
            uint64_t v15 = std::__tree<std::array<unsigned char,16ul>>::_DetachedTreeCache::__detach_next((uint64_t)v15);
          }
          unsigned int v10 = (void *)v9[1];
          if (v10)
          {
            do
            {
              a2 = v10;
              unsigned int v10 = (void *)*v10;
            }
            while (v10);
          }
          else
          {
            do
            {
              a2 = (void *)v9[2];
              BOOL v11 = *a2 == (void)v9;
              uint64_t v9 = a2;
            }
            while (!v11);
          }
          BOOL v8 = v16;
          if (v16) {
            BOOL v11 = a2 == a3;
          }
          else {
            BOOL v11 = 1;
          }
          uint64_t v9 = a2;
        }
        while (!v11);
      }
    }
    id result = (uint64_t **)std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::_DetachedTreeCache::~_DetachedTreeCache[abi:ne180100]((uint64_t)&v14);
  }
  if (a2 != a3)
  {
    do
    {
      id result = (uint64_t **)std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__emplace_multi<std::pair<std::array<unsigned char,16ul> const,ARTexturedPlane> const&>((uint64_t)v5, (uint64_t)(a2 + 4));
      unsigned int v12 = (void *)a2[1];
      if (v12)
      {
        do
        {
          uint64_t v13 = v12;
          unsigned int v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          uint64_t v13 = (void *)a2[2];
          BOOL v11 = *v13 == (void)a2;
          a2 = v13;
        }
        while (!v11);
      }
      a2 = v13;
    }
    while (v13 != a3);
  }
  return result;
}

void sub_1B89BFAB4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::_DetachedTreeCache::~_DetachedTreeCache[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__node_insert_multi(uint64_t **a1, uint64_t *a2)
{
  BOOL v3 = a1 + 1;
  int v4 = a1[1];
  if (v4)
  {
LABEL_2:
    while (2)
    {
      BOOL v3 = (uint64_t **)v4;
      uint64_t v5 = 32;
      while (1)
      {
        unsigned int v6 = *((unsigned __int8 *)a2 + v5);
        unsigned int v7 = *((unsigned __int8 *)v3 + v5);
        if (v6 < v7) {
          break;
        }
        if (v7 >= v6 && v5++ != 47) {
          continue;
        }
        int v4 = v3[1];
        if (v4) {
          goto LABEL_2;
        }
        uint64_t v9 = v3 + 1;
        goto LABEL_12;
      }
      int v4 = *v3;
      uint64_t v9 = v3;
      if (*v3) {
        continue;
      }
      break;
    }
  }
  else
  {
    uint64_t v9 = a1 + 1;
  }
LABEL_12:
  _ZNSt3__16__treeINS_12__value_typeIyDv4_fEENS_19__map_value_compareIyS3_NS_4lessIyEELb1EEENS_9allocatorIS3_EEE16__insert_node_atEPNS_15__tree_end_nodeIPNS_16__tree_node_baseIPvEEEERSF_SF_(a1, (uint64_t)v3, v9, a2);
  return a2;
}

uint64_t std::pair<std::array<unsigned char,16ul> &,ARTexturedPlane &>::operator=[abi:ne180100]<std::array<unsigned char,16ul> const,ARTexturedPlane,(void *)0>(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)*(void *)a1 = *(_OWORD *)a2;
  uint64_t v4 = *(void *)(a1 + 8);
  long long v5 = *(_OWORD *)(a2 + 16);
  long long v6 = *(_OWORD *)(a2 + 32);
  long long v7 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(v4 + 32) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v4 + 4_Block_object_dispose(&STACK[0x400], 8) = v7;
  *(_OWORD *)uint64_t v4 = v5;
  *(_OWORD *)(v4 + 16) = v6;
  long long v8 = *(_OWORD *)(a2 + 80);
  long long v9 = *(_OWORD *)(a2 + 96);
  long long v10 = *(_OWORD *)(a2 + 128);
  *(_OWORD *)(v4 + 96) = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(v4 + 112) = v10;
  *(_OWORD *)(v4 + 64) = v8;
  *(_OWORD *)(v4 + 80) = v9;
  long long v11 = *(_OWORD *)(a2 + 144);
  long long v12 = *(_OWORD *)(a2 + 160);
  long long v13 = *(_OWORD *)(a2 + 192);
  *(_OWORD *)(v4 + 160) = *(_OWORD *)(a2 + 176);
  *(_OWORD *)(v4 + 176) = v13;
  *(_OWORD *)(v4 + 12_Block_object_dispose(&STACK[0x400], 8) = v11;
  *(_OWORD *)(v4 + 144) = v12;
  if (v4 != a2 + 16) {
    std::__tree<std::array<unsigned char,16ul>>::__assign_multi<std::__tree_const_iterator<std::array<unsigned char,16ul>,std::__tree_node<std::array<unsigned char,16ul>,void *> *,long>>((uint64_t **)(v4 + 192), *(void **)(a2 + 208), (void *)(a2 + 216));
  }
  objc_storeStrong((id *)(v4 + 216), *(id *)(a2 + 232));
  return a1;
}

uint64_t std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::_DetachedTreeCache::~_DetachedTreeCache[abi:ne180100](uint64_t a1)
{
  std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::destroy(*(void *)a1, *(void **)(a1 + 16));
  unint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    BOOL v3 = (void *)v2[2];
    if (v3)
    {
      do
      {
        unint64_t v2 = v3;
        BOOL v3 = (void *)v3[2];
      }
      while (v3);
      *(void *)(a1 + _Block_object_dispose(&STACK[0x400], 8) = v2;
    }
    std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::destroy(*(void *)a1, v2);
  }
  return a1;
}

uint64_t *std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__emplace_multi<std::pair<std::array<unsigned char,16ul> const,ARTexturedPlane> const&>(uint64_t a1, uint64_t a2)
{
  std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__construct_node<std::pair<std::array<unsigned char,16ul> const,ARTexturedPlane> const&>(a1, a2, (uint64_t)&v11);
  BOOL v3 = (uint64_t **)(a1 + 8);
  uint64_t v4 = *(uint64_t **)(a1 + 8);
  if (v4)
  {
LABEL_2:
    while (2)
    {
      BOOL v3 = (uint64_t **)v4;
      uint64_t v5 = 32;
      while (1)
      {
        unsigned int v6 = *((unsigned __int8 *)v11 + v5);
        unsigned int v7 = *((unsigned __int8 *)v3 + v5);
        if (v6 < v7) {
          break;
        }
        if (v7 >= v6 && v5++ != 47) {
          continue;
        }
        uint64_t v4 = v3[1];
        if (v4) {
          goto LABEL_2;
        }
        long long v9 = v3 + 1;
        goto LABEL_12;
      }
      uint64_t v4 = *v3;
      long long v9 = v3;
      if (*v3) {
        continue;
      }
      break;
    }
  }
  else
  {
    long long v9 = (uint64_t **)(a1 + 8);
  }
LABEL_12:
  _ZNSt3__16__treeINS_12__value_typeIyDv4_fEENS_19__map_value_compareIyS3_NS_4lessIyEELb1EEENS_9allocatorIS3_EEE16__insert_node_atEPNS_15__tree_end_nodeIPNS_16__tree_node_baseIPvEEEERSF_SF_((uint64_t **)a1, (uint64_t)v3, v9, v11);
  return v11;
}

id std::vector<ARTexturedPlane>::__construct_one_at_end[abi:ne180100]<ARTexturedPlane const&>(uint64_t a1, id *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  long long v5 = *(_OWORD *)a2;
  long long v6 = *((_OWORD *)a2 + 1);
  long long v7 = *((_OWORD *)a2 + 3);
  *(_OWORD *)(v4 + 32) = *((_OWORD *)a2 + 2);
  *(_OWORD *)(v4 + 4_Block_object_dispose(&STACK[0x400], 8) = v7;
  *(_OWORD *)uint64_t v4 = v5;
  *(_OWORD *)(v4 + 16) = v6;
  long long v8 = *((_OWORD *)a2 + 4);
  long long v9 = *((_OWORD *)a2 + 5);
  long long v10 = *((_OWORD *)a2 + 7);
  *(_OWORD *)(v4 + 96) = *((_OWORD *)a2 + 6);
  *(_OWORD *)(v4 + 112) = v10;
  *(_OWORD *)(v4 + 64) = v8;
  *(_OWORD *)(v4 + 80) = v9;
  long long v11 = *((_OWORD *)a2 + 8);
  long long v12 = *((_OWORD *)a2 + 9);
  long long v13 = *((_OWORD *)a2 + 11);
  *(_OWORD *)(v4 + 160) = *((_OWORD *)a2 + 10);
  *(_OWORD *)(v4 + 176) = v13;
  *(_OWORD *)(v4 + 12_Block_object_dispose(&STACK[0x400], 8) = v11;
  *(_OWORD *)(v4 + 144) = v12;
  std::set<std::array<unsigned char,16ul>>::set[abi:ne180100](v4 + 192, (uint64_t)(a2 + 24));
  id result = a2[27];
  *(void *)(v4 + 216) = result;
  *(void *)(a1 + _Block_object_dispose(&STACK[0x400], 8) = v4 + 224;
  return result;
}

void sub_1B89BFD6C(_Unwind_Exception *a1)
{
  *(void *)(v1 + _Block_object_dispose(&STACK[0x400], 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::vector<ARTexturedPlane>::__push_back_slow_path<ARTexturedPlane const&>(uint64_t *a1, id *a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = 0x6DB6DB6DB6DB6DB7 * ((a1[1] - *a1) >> 5);
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) > 0x124924924924924) {
    std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x6DB6DB6DB6DB6DB7 * ((a1[2] - v3) >> 5);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x92492492492492) {
    unint64_t v9 = 0x124924924924924;
  }
  else {
    unint64_t v9 = v5;
  }
  unsigned int v26 = a1 + 2;
  if (v9) {
    long long v10 = std::__allocate_at_least[abi:ne180100]<std::allocator<ARTexturedPlane>>(v7, v9);
  }
  else {
    long long v10 = 0;
  }
  long long v11 = &v10[28 * v4];
  v23[0] = v10;
  v23[1] = v11;
  uint64_t v24 = v11;
  uint64_t v25 = (char *)&v10[28 * v9];
  long long v12 = *(_OWORD *)a2;
  long long v13 = *((_OWORD *)a2 + 1);
  long long v14 = *((_OWORD *)a2 + 3);
  v11[2] = *((_OWORD *)a2 + 2);
  void v11[3] = v14;
  long long v15 = *((_OWORD *)a2 + 7);
  long long v17 = *((_OWORD *)a2 + 4);
  long long v16 = *((_OWORD *)a2 + 5);
  v11[6] = *((_OWORD *)a2 + 6);
  v11[7] = v15;
  float32x4_t v11[4] = v17;
  _OWORD v11[5] = v16;
  long long v18 = *((_OWORD *)a2 + 11);
  long long v20 = *((_OWORD *)a2 + 8);
  long long v19 = *((_OWORD *)a2 + 9);
  v11[10] = *((_OWORD *)a2 + 10);
  v11[11] = v18;
  v11[8] = v20;
  v11[9] = v19;
  *long long v11 = v12;
  v11[1] = v13;
  std::set<std::array<unsigned char,16ul>>::set[abi:ne180100]((uint64_t)(v11 + 12), (uint64_t)(a2 + 24));
  v10[28 * v4 + 27] = a2[27];
  v24 += 14;
  std::vector<ARTexturedPlane>::__swap_out_circular_buffer(a1, v23);
  uint64_t v21 = a1[1];
  std::__split_buffer<ARTexturedPlane>::~__split_buffer((uint64_t)v23);
  return v21;
}

void sub_1B89BFEC8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<ARTexturedPlane>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<ARTexturedPlane>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<ARTexturedPlane>,std::reverse_iterator<ARTexturedPlane*>,std::reverse_iterator<ARTexturedPlane*>,std::reverse_iterator<ARTexturedPlane*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<ARTexturedPlane>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x124924924924925) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(224 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<ARTexturedPlane>,std::reverse_iterator<ARTexturedPlane*>,std::reverse_iterator<ARTexturedPlane*>,std::reverse_iterator<ARTexturedPlane*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v27 = a6;
  *((void *)&v27 + 1) = a7;
  long long v26 = v27;
  v24[0] = a1;
  v24[1] = &v26;
  v24[2] = &v27;
  if (a3 == a5)
  {
    uint64_t v22 = a6;
  }
  else
  {
    do
    {
      long long v8 = *(_OWORD *)(a3 - 224);
      long long v9 = *(_OWORD *)(a3 - 208);
      long long v10 = *(_OWORD *)(a3 - 176);
      *(_OWORD *)(v7 - 192) = *(_OWORD *)(a3 - 192);
      *(_OWORD *)(v7 - 176) = v10;
      *(_OWORD *)(v7 - 224) = v8;
      *(_OWORD *)(v7 - 20_Block_object_dispose(&STACK[0x400], 8) = v9;
      long long v11 = *(_OWORD *)(a3 - 160);
      long long v12 = *(_OWORD *)(a3 - 144);
      long long v13 = *(_OWORD *)(a3 - 112);
      *(_OWORD *)(v7 - 12_Block_object_dispose(&STACK[0x400], 8) = *(_OWORD *)(a3 - 128);
      *(_OWORD *)(v7 - 112) = v13;
      *(_OWORD *)(v7 - 160) = v11;
      *(_OWORD *)(v7 - 144) = v12;
      long long v14 = *(_OWORD *)(a3 - 96);
      long long v15 = *(_OWORD *)(a3 - 80);
      long long v16 = *(_OWORD *)(a3 - 48);
      *(_OWORD *)(v7 - 64) = *(_OWORD *)(a3 - 64);
      *(_OWORD *)(v7 - 4_Block_object_dispose(&STACK[0x400], 8) = v16;
      *(_OWORD *)(v7 - 96) = v14;
      *(_OWORD *)(v7 - 80) = v15;
      *(void *)(v7 - 32) = *(void *)(a3 - 32);
      long long v17 = (void *)(a3 - 24);
      uint64_t v18 = *(void *)(a3 - 24);
      *(void *)(v7 - 24) = v18;
      uint64_t v19 = v7 - 24;
      uint64_t v20 = *(void *)(a3 - 16);
      *(void *)(v7 - 16) = v20;
      if (v20)
      {
        *(void *)(v18 + 16) = v19;
        *(void *)(a3 - 32) = v17;
        *long long v17 = 0;
        *(void *)(a3 - 16) = 0;
      }
      else
      {
        *(void *)(v7 - 32) = v19;
      }
      uint64_t v21 = *(void *)(a3 - 8);
      *(void *)(a3 - _Block_object_dispose(&STACK[0x400], 8) = 0;
      *(void *)(v7 - _Block_object_dispose(&STACK[0x400], 8) = v21;
      uint64_t v7 = *((void *)&v27 + 1) - 224;
      *((void *)&v27 + 1) -= 224;
      a3 -= 224;
    }
    while (a3 != a5);
    uint64_t v22 = v27;
  }
  char v25 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<ARTexturedPlane>,std::reverse_iterator<ARTexturedPlane*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v24);
  return v22;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<ARTexturedPlane>,std::reverse_iterator<ARTexturedPlane*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<ARTexturedPlane>,std::reverse_iterator<ARTexturedPlane*>>::operator()[abi:ne180100]((uint64_t *)a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<ARTexturedPlane>,std::reverse_iterator<ARTexturedPlane*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = (uint64_t *)a1[2];
  uint64_t v3 = *v1;
  uint64_t v2 = v1[1];
  uint64_t v14 = v3;
  uint64_t v15 = v2;
  uint64_t v16 = v3;
  uint64_t v17 = v2;
  uint64_t v4 = *a1;
  uint64_t v5 = (uint64_t *)a1[1];
  uint64_t v7 = *v5;
  uint64_t v6 = v5[1];
  uint64_t v9 = v7;
  uint64_t v10 = v6;
  uint64_t v11 = v7;
  uint64_t v12 = v6;
  std::__allocator_destroy[abi:ne180100]<std::allocator<ARTexturedPlane>,std::reverse_iterator<std::reverse_iterator<ARTexturedPlane*>>,std::reverse_iterator<std::reverse_iterator<ARTexturedPlane*>>>(v4, (uint64_t)v13, (uint64_t)v8);
}

void std::__allocator_destroy[abi:ne180100]<std::allocator<ARTexturedPlane>,std::reverse_iterator<std::reverse_iterator<ARTexturedPlane*>>,std::reverse_iterator<std::reverse_iterator<ARTexturedPlane*>>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  for (uint64_t i = *(void *)(a2 + 32); i != *(void *)(a3 + 32); *(void *)(a2 + 32) = i)
  {

    std::__tree<std::array<unsigned char,16ul>>::destroy(i + 192, *(void **)(i + 200));
    uint64_t i = *(void *)(a2 + 32) + 224;
  }
}

uint64_t std::__split_buffer<ARTexturedPlane>::~__split_buffer(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__split_buffer<ARTexturedPlane>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(void *)(a1 + 16); i != a2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 224;

    std::__tree<std::array<unsigned char,16ul>>::destroy(i - 32, *(void **)(i - 24));
  }
}

void sub_1B89C0858(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1B89C0C04(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89C0C74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89C0CC8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t GetRelativeMotionAndYaw(const simd_double4x4 *a1, const simd_double4x4 *a2, double *a3, double *a4)
{
  Transform4DofFromMatrix(a1, (uint64_t)&v16);
  double v7 = v18;
  Transform4DofFromMatrix(a2, (uint64_t)&v13);
  double v8 = v15;
  *a4 = 0.0;
  uint64_t result = 1;
  double v10 = v8 - v7 + ceil((v8 - v7) / -360.0) * 360.0;
  if (v10 > 180.0) {
    double v10 = v10 + -360.0;
  }
  *a4 = v10;
  v11.f64[1] = v16.f64[1];
  float64x2_t v12 = vsubq_f64(v13, v16);
  v11.f64[0] = v14 - v17;
  *a3 = sqrt(vmulq_f64(v11, v11).f64[0] + vaddvq_f64(vmulq_f64(v12, v12)));
  return result;
}

float angleDiff(float a1, float a2)
{
  for (float result = a2 - a1; result < -180.0; float result = result + 360.0)
    ;
  for (; result >= 180.0; float result = result + -360.0)
    ;
  return result;
}

uint64_t SanityCheck(uint64_t a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  Transform4DofFromMatrix((const simd_double4x4 *)a1, (uint64_t)v24);
  Transform4DofFromMatrix((const simd_double4x4 *)a2, (uint64_t)v22);
  Transform4DofFromMatrix((const simd_double4x4 *)a3, (uint64_t)v20);
  float v8 = v23;
  float v9 = v21;
  for (float i = v9 - v8; i < -180.0; float i = i + 360.0)
    ;
  for (; i >= 180.0; float i = i + -360.0)
    ;
  float v11 = v25;
  for (float j = v9 - v11; j < -180.0; float j = j + 360.0)
    ;
  for (k = fabsf(i); j >= 180.0; float j = j + -360.0)
    ;
  if (fabsf(j) + 0.001 < k) {
    return 0;
  }
  float64x2_t v16 = a4[6];
  float64x2_t v15 = a4[7];
  float64x2_t v17 = vmlaq_laneq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(*(float64x2_t *)a3, v16.f64[0]), *(float64x2_t *)(a3 + 32), v16, 1), *(float64x2_t *)(a3 + 64), v15.f64[0]), *(float64x2_t *)(a3 + 96), v15, 1);
  *(void *)&double v18 = *(_OWORD *)&vmlaq_laneq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(*(float64x2_t *)(a3 + 16), v16.f64[0]), *(float64x2_t *)(a3 + 48), v16, 1), *(float64x2_t *)(a3 + 80), v15.f64[0]), *(float64x2_t *)(a3 + 112), v15, 1);
  int32x2_t v19 = vmovn_s64(vcgeq_f64(vaddq_f64(vabdq_f64(v17, vmlaq_laneq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(*(float64x2_t *)a1, v16.f64[0]), *(float64x2_t *)(a1 + 32), v16, 1), *(float64x2_t *)(a1 + 64), v15.f64[0]), *(float64x2_t *)(a1 + 96), v15, 1)), (float64x2_t)vdupq_n_s64(0x3F50624DD2F1A9FCuLL)), vabdq_f64(v17, vmlaq_laneq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(*(float64x2_t *)a2, v16.f64[0]), *(float64x2_t *)(a2 + 32), v16, 1), *(float64x2_t *)(a2 + 64),
                  v15.f64[0]),
                *(float64x2_t *)(a2 + 96),
                v15,
                1))));
  return (v19.i8[0] & (vabdd_f64(v18, vmlaq_laneq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(*(float64x2_t *)(a2 + 16), v16.f64[0]), *(float64x2_t *)(a2 + 48), v16, 1), *(float64x2_t *)(a2 + 80), v15.f64[0]), *(float64x2_t *)(a2 + 112), v15, 1).f64[0]) <= vabdd_f64(v18, vmlaq_laneq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(*(float64x2_t *)(a1 + 16), v16.f64[0]), *(float64x2_t *)(a1 + 48),
                                                                  v16,
                                                                  1),
                                                                *(float64x2_t *)(a1 + 80),
                                                                v15.f64[0]),
                                                              *(float64x2_t *)(a1 + 112),
                                                              v15,
                                                              1).f64[0])
                                                        + 0.001)) & v19.i8[4];
}

void sub_1B89C2048(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL13_ARLogGeneralv_block_invoke_21()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "General");
  uint64_t v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObfloat j = (uint64_t)v0;
}

void sub_1B89C2378(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89C24F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89C25E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B89C3770(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,void *a50,uint64_t a51,uint64_t a52,uint64_t a53,void *a54,uint64_t a55,uint64_t a56,uint64_t a57,void *a58)
{
  _Unwind_Resume(a1);
}

void sub_1B89C426C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20)
{
  _Unwind_Resume(a1);
}

void sub_1B89C45FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89C4994(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89C4D04(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89C4EFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89C4F60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89C50B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B89C5490(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, void *a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void ___ZL13_ARLogGeneralv_block_invoke_22()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "General");
  uint64_t v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObfloat j = (uint64_t)v0;
}

void std::vector<ARTexturedPlane>::__vdeallocate(uint64_t *a1)
{
  if (*a1)
  {
    std::vector<ARTexturedPlane>::__base_destruct_at_end[abi:ne180100]((uint64_t)a1, *a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

double ARMatrix4x4MakeRowMajorTransform(double *a1)
{
  *(float *)&unsigned int v1 = *a1;
  *(float *)&unsigned int v2 = a1[3];
  return COERCE_DOUBLE(__PAIR64__(v2, v1));
}

float32x2_t ARMatrix4x4MakeColumnMajorTransform(float64x2_t *a1)
{
  return vcvt_f32_f64(*a1);
}

double ARMatrix4x4RowMajorRotationAndTranslation(float64x2_t *a1, float64x2_t *a2, int8x16_t a3, int8x16_t a4, __n128 a5, __n128 a6)
{
  a1->f64[0] = *(float *)a3.i32;
  a1->f64[1] = *(float *)a4.i32;
  float32x2_t v6 = (float32x2_t)vzip2_s32(*(int32x2_t *)a4.i8, (int32x2_t)a5.n128_u64[0]);
  a5.n128_u32[1] = a3.u32[1];
  a1[1] = vcvtq_f64_f32((float32x2_t)a5.n128_u64[0]);
  a1[2] = vcvtq_f64_f32(v6);
  a1[3] = vcvtq_f64_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL)));
  a1[4].f64[0] = a5.n128_f32[2];
  *a2 = vcvtq_f64_f32((float32x2_t)a6.n128_u64[0]);
  double result = a6.n128_f32[2];
  a2[1].f64[0] = a6.n128_f32[2];
  return result;
}

double ARMatrix3x3RowMajorArray(float64x2_t *a1, int8x16_t a2, int8x16_t a3, __n128 a4)
{
  float32x2_t v4 = (float32x2_t)vzip2_s32(*(int32x2_t *)a3.i8, (int32x2_t)a4.n128_u64[0]);
  a4.n128_u32[1] = a2.u32[1];
  a1->f64[0] = *(float *)a2.i32;
  a1->f64[1] = *(float *)a3.i32;
  a1[1] = vcvtq_f64_f32((float32x2_t)a4.n128_u64[0]);
  a1[2] = vcvtq_f64_f32(v4);
  a1[3] = vcvtq_f64_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(a2, a2, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL)));
  double result = a4.n128_f32[2];
  a1[4].f64[0] = a4.n128_f32[2];
  return result;
}

double ARRowMajor3x3MatrixArrayToColumnMajor3x3MatrixArray(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = *(void *)a1;
  *(void *)(a2 + _Block_object_dispose(&STACK[0x400], 8) = *(void *)(a1 + 24);
  *(void *)(a2 + 16) = *(void *)(a1 + 48);
  *(void *)(a2 + 24) = *(void *)(a1 + 8);
  *(void *)(a2 + 32) = *(void *)(a1 + 32);
  *(void *)(a2 + 40) = *(void *)(a1 + 56);
  *(void *)(a2 + 4_Block_object_dispose(&STACK[0x400], 8) = *(void *)(a1 + 16);
  *(void *)(a2 + 56) = *(void *)(a1 + 40);
  double result = *(double *)(a1 + 64);
  *(double *)(a2 + 64) = result;
  return result;
}

float32x2_t ARMatrix3x3MakeRowMajorTransform(float64_t *a1)
{
  v1.f64[0] = *a1;
  v1.f64[1] = a1[3];
  return vcvt_f32_f64(v1);
}

float32x2_t ARMatrix3x3MakeColumnMajorTransform(float64x2_t *a1)
{
  return vcvt_f32_f64(*a1);
}

__n128 ARMatrix4x4MakeColumnMajorTransformFromArrayF(uint64_t a1)
{
  return *(__n128 *)a1;
}

double ARMatrix4x4MakeColumnMajorTransformFromArray(float64x2_t *a1)
{
  *(void *)&double result = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*a1), a1[1]).u64[0];
  return result;
}

uint64_t ARMatrix3x3IsZero(float32x4_t a1, float32x4_t a2, float32x4_t a3)
{
  v3.i64[0] = 0x3400000034000000;
  v3.i64[1] = 0x3400000034000000;
  uint32x4_t v4 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v3, vabsq_f32(a1)), (int8x16_t)vcgeq_f32(v3, vabsq_f32(a2))), (int8x16_t)vcgeq_f32(v3, vabsq_f32(a3)));
  v4.i32[3] = v4.i32[2];
  return vminvq_u32(v4) >> 31;
}

uint64_t ARMatrix4x3IsZero(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  v4.i64[0] = 0x3400000034000000;
  v4.i64[1] = 0x3400000034000000;
  uint32x4_t v5 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v4, vabsq_f32(a1)), (int8x16_t)vcgeq_f32(v4, vabsq_f32(a2))), vandq_s8((int8x16_t)vcgeq_f32(v4, vabsq_f32(a3)), (int8x16_t)vcgeq_f32(v4, vabsq_f32(a4))));
  v5.i32[3] = v5.i32[2];
  return vminvq_u32(v5) >> 31;
}

uint64_t ARMatrix4x4IsZero(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  v4.i64[0] = 0x3400000034000000;
  v4.i64[1] = 0x3400000034000000;
  return vminvq_u32((uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v4, vabsq_f32(a1)), (int8x16_t)vcgeq_f32(v4, vabsq_f32(a2))), vandq_s8((int8x16_t)vcgeq_f32(v4, vabsq_f32(a3)), (int8x16_t)vcgeq_f32(v4, vabsq_f32(a4))))) >> 31;
}

uint64_t ARMatrix3x3IsNAN(float32x4_t a1, float32x4_t a2, float32x4_t a3)
{
  uint32x4_t v3 = (uint32x4_t)vmvnq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a1), (int8x16_t)vcgezq_f32(a1)));
  v3.i32[3] = v3.i32[2];
  if ((vminvq_u32(v3) & 0x80000000) == 0) {
    return 0;
  }
  uint32x4_t v4 = (uint32x4_t)vmvnq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a2), (int8x16_t)vcgezq_f32(a2)));
  v4.i32[3] = v4.i32[2];
  if ((vminvq_u32(v4) & 0x80000000) == 0) {
    return 0;
  }
  uint32x4_t v6 = (uint32x4_t)vmvnq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a3), (int8x16_t)vcgezq_f32(a3)));
  v6.i32[3] = v6.i32[2];
  return vminvq_u32(v6) >> 31;
}

uint64_t ARMatrix4x3IsNAN(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  uint32x4_t v4 = (uint32x4_t)vmvnq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a1), (int8x16_t)vcgezq_f32(a1)));
  v4.i32[3] = v4.i32[2];
  if ((vminvq_u32(v4) & 0x80000000) == 0) {
    return 0;
  }
  uint32x4_t v5 = (uint32x4_t)vmvnq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a2), (int8x16_t)vcgezq_f32(a2)));
  v5.i32[3] = v5.i32[2];
  if ((vminvq_u32(v5) & 0x80000000) == 0) {
    return 0;
  }
  uint32x4_t v6 = (uint32x4_t)vmvnq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a3), (int8x16_t)vcgezq_f32(a3)));
  v6.i32[3] = v6.i32[2];
  if ((vminvq_u32(v6) & 0x80000000) == 0) {
    return 0;
  }
  uint32x4_t v8 = (uint32x4_t)vmvnq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a4), (int8x16_t)vcgezq_f32(a4)));
  v8.i32[3] = v8.i32[2];
  return vminvq_u32(v8) >> 31;
}

uint64_t ARMatrix4x4IsNAN(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  if ((vminvq_u32((uint32x4_t)vmvnq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a1), (int8x16_t)vcgezq_f32(a1)))) & 0x80000000) != 0
    && (vminvq_u32((uint32x4_t)vmvnq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a2), (int8x16_t)vcgezq_f32(a2)))) & 0x80000000) != 0
    && (vminvq_u32((uint32x4_t)vmvnq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a3), (int8x16_t)vcgezq_f32(a3)))) & 0x80000000) != 0)
  {
    return vminvq_u32((uint32x4_t)vmvnq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a4), (int8x16_t)vcgezq_f32(a4)))) >> 31;
  }
  else
  {
    return 0;
  }
}

double ARMatrix4x4ColumnMajorRotationAndTranslation(uint64_t a1, float64x2_t *a2, __n128 a3, __n128 a4, __n128 a5, __n128 a6)
{
  *(float64x2_t *)a1 = vcvtq_f64_f32((float32x2_t)a3.n128_u64[0]);
  *(double *)(a1 + 16) = a3.n128_f32[2];
  *(float64x2_t *)(a1 + 24) = vcvtq_f64_f32((float32x2_t)a4.n128_u64[0]);
  *(double *)(a1 + 40) = a4.n128_f32[2];
  *(float64x2_t *)(a1 + 4_Block_object_dispose(&STACK[0x400], 8) = vcvtq_f64_f32((float32x2_t)a5.n128_u64[0]);
  *(double *)(a1 + 64) = a5.n128_f32[2];
  *a2 = vcvtq_f64_f32((float32x2_t)a6.n128_u64[0]);
  double result = a6.n128_f32[2];
  a2[1].f64[0] = a6.n128_f32[2];
  return result;
}

float64x2_t ARMatrix4x4ColumnMajorCopyValues(float64x2_t *a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5)
{
  *a1 = vcvtq_f64_f32(*(float32x2_t *)a2.f32);
  a1[1] = vcvt_hight_f64_f32(a2);
  a1[2] = vcvtq_f64_f32(*(float32x2_t *)a3.f32);
  a1[3] = vcvt_hight_f64_f32(a3);
  a1[4] = vcvtq_f64_f32(*(float32x2_t *)a4.f32);
  a1[5] = vcvt_hight_f64_f32(a4);
  float64x2_t result = vcvtq_f64_f32(*(float32x2_t *)a5.f32);
  a1[6] = result;
  a1[7] = vcvt_hight_f64_f32(a5);
  return result;
}

double ARMatrix4x4RowMajorCopyValues4x3(uint64_t a1, int8x16_t a2, int8x16_t a3, int8x16_t a4, __n128 a5)
{
  *(double *)a1 = *(float *)a2.i32;
  *(double *)(a1 + _Block_object_dispose(&STACK[0x400], 8) = *(float *)a3.i32;
  *(double *)(a1 + 16) = *(float *)a4.i32;
  float32x2_t v5 = (float32x2_t)vext_s8((int8x8_t)a5.n128_u64[0], (int8x8_t)*(_OWORD *)&vextq_s8(a2, a2, 8uLL), 4uLL);
  a5.n128_u32[1] = a2.u32[1];
  *(float64x2_t *)(a1 + 24) = vcvtq_f64_f32((float32x2_t)a5.n128_u64[0]);
  *(float64x2_t *)(a1 + 40) = vcvtq_f64_f32((float32x2_t)vzip2_s32(*(int32x2_t *)a3.i8, *(int32x2_t *)a4.i8));
  *(float64x2_t *)(a1 + 56) = vcvtq_f64_f32(v5);
  *(float64x2_t *)(a1 + 72) = vcvtq_f64_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL)));
  double result = a5.n128_f32[2];
  *(double *)(a1 + 8_Block_object_dispose(&STACK[0x400], 8) = a5.n128_f32[2];
  return result;
}

uint64_t ARMatrix3x3CopyValues(uint64_t result, __n128 a2, __n128 a3, __n128 a4)
{
  *(_DWORD *)(result + _Block_object_dispose(&STACK[0x400], 8) = a2.n128_u32[2];
  *(_DWORD *)(result + 20) = a3.n128_u32[2];
  *(void *)double result = a2.n128_u64[0];
  *(void *)(result + 12) = a3.n128_u64[0];
  *(_DWORD *)(result + 32) = a4.n128_u32[2];
  *(void *)(result + 24) = a4.n128_u64[0];
  return result;
}

__n128 *ARMatrix4x4CopyValues(__n128 *result, __n128 a2, __n128 a3, __n128 a4, __n128 a5)
{
  *double result = a2;
  result[1] = a3;
  result[2] = a4;
  result[3] = a5;
  return result;
}

double ARMatrix4x4FromCMRotationMatrix(double *a1)
{
  *(float *)&unsigned int v1 = *a1;
  *(float *)&unsigned int v2 = a1[3];
  return COERCE_DOUBLE(__PAIR64__(v2, v1));
}

double ARMatrix4x3Inverse(simd_float4x4 a1)
{
  a1.columns[0].i32[3] = 0;
  a1.columns[1].i32[3] = 0;
  a1.columns[2].i32[3] = 0;
  a1.columns[3].i32[3] = 1.0;
  *(void *)&double result = (unint64_t)__invert_f4(a1);
  return result;
}

float ARAdjustIntrinsicsForViewportSize(float result, double a2, double a3, double a4, double a5, double a6, double a7)
{
  if (a4 != a6 || a5 != a7)
  {
    double v8 = result;
    BOOL v9 = a6 / a7 < a4 / a5;
    double v10 = a6 / a4;
    if (v9) {
      double v10 = a7 / a5;
    }
    return v10 * v8;
  }
  return result;
}

float ARMatrixMakeFrustum(float a1, double a2, double a3, float64_t a4, float64_t a5)
{
  ARLinkedOnOrAfterPeace();
  _Q2.f64[0] = a4;
  _Q2.f64[1] = a5;
  float v6 = vcvt_f32_f64(_Q2).f32[0];
  __asm { FMOV            V2.2S, #1.0 }
  return (float)(a1 + a1) / v6;
}

double ARMatrixPerspectiveFlipZ(double a1, double a2, __n128 a3, __n128 a4)
{
  uint64_t v4 = 0;
  v6[2] = a3;
  void v6[3] = a4;
  memset(v7, 0, sizeof(v7));
  do
  {
    v7[v4] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B8A2B0C0, COERCE_FLOAT(v6[v4])), (float32x4_t)xmmword_1B8A2B0D0, *(float32x2_t *)&v6[v4], 1), (float32x4_t)xmmword_1B8A2B0E0, (float32x4_t)v6[v4], 2), (float32x4_t)xmmword_1B8A566F0, (float32x4_t)v6[v4], 3);
    ++v4;
  }
  while (v4 != 4);
  return *(double *)v7;
}

double ARMatrixMakePerspective(int a1, int8x16_t a2, float32x4_t a3, float a4, float a5, float a6, float32_t a7, double a8, float32x4_t a9)
{
  a9.i32[0] = 2139095040;
  if (a7 == 0.0) {
    a7 = INFINITY;
  }
  if (a6 == INFINITY) {
    a6 = 0.000001;
  }
  if (a6 < 0.000001) {
    a6 = 0.000001;
  }
  if (a7 < 0.000001) {
    a7 = 0.000001;
  }
  if ((float)(a3.f32[0] - *(float *)a2.i32) >= 0.000001) {
    float v9 = a3.f32[0];
  }
  else {
    float v9 = *(float *)a2.i32 + 0.000001;
  }
  if ((float)(a5 - a4) < 0.000001) {
    a5 = a4 + 0.000001;
  }
  if ((float)(a7 - a6) >= 0.000001) {
    a3.f32[0] = a7;
  }
  else {
    a3.f32[0] = a6 + 0.000001;
  }
  float v10 = a6 * *(float *)a2.i32;
  float v11 = v9 * a6;
  float v12 = a5 * a6;
  float v13 = a6 * a4;
  *(float *)a2.i32 = v11 - (float)(a6 * *(float *)a2.i32);
  __asm { FMOV            V6.4S, #1.0 }
  _Q6.i32[0] = a2.i32[0];
  *(float *)&a2.i32[1] = v12 - (float)(a6 * a4);
  *(float *)&a2.i32[2] = a3.f32[0] - a6;
  _Q6.i32[1] = a2.i32[1];
  float32x4_t v19 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_f32(a3, a9), 0), _Q6, a2);
  v19.i32[3] = 0;
  float32x4_t v20 = vrecpeq_f32(v19);
  float32x4_t v21 = vmulq_f32(v20, vrecpsq_f32(v19, v20));
  float32x4_t v22 = vmulq_f32(v21, vrecpsq_f32(v19, v21));
  float v23 = (float)(a6 + a6) * v22.f32[0];
  float v24 = vmuls_lane_f32(a6 + a6, *(float32x2_t *)v22.f32, 1);
  float v25 = (float)(v10 + v11) * v22.f32[0];
  float v26 = vmuls_lane_f32(v13 + v12, *(float32x2_t *)v22.f32, 1);
  if (a3.f32[0] == INFINITY)
  {
    LODWORD(v27) = 0;
    v22.i32[1] = 0;
    v22.f32[0] = (float)(a6 + a6) * v22.f32[0];
    *((float *)&v27 + 1) = v24;
    __asm { FMOV            V2.4S, #-1.0 }
    _Q2.n128_u64[0] = __PAIR64__(LODWORD(v26), LODWORD(v25));
    float v29 = -a6;
  }
  else
  {
    float v30 = vmuls_lane_f32(-a3.f32[0], v22, 2);
    float v29 = a6 * v30;
    LODWORD(v27) = 0;
    v22.i64[0] = LODWORD(v23);
    *((float *)&v27 + 1) = v24;
    __asm { FMOV            V2.4S, #-1.0 }
    _Q2.n128_u64[0] = __PAIR64__(LODWORD(v26), LODWORD(v25));
    _Q2.n128_f32[2] = v30;
  }
  v31.n128_u64[0] = 0;
  v31.n128_u64[1] = LODWORD(v29);
  if (a1) {
    *(double *)v22.i64 = ARMatrixPerspectiveFlipZ(*(double *)v22.i64, v27, _Q2, v31);
  }
  return *(double *)v22.i64;
}

float ARIntrinsicsFromTangent(float a1, double a2)
{
  double v2 = a1;
  float v3 = 1.0 / a1;
  if (v2 < 0.000001) {
    float v3 = 0.000001;
  }
  float v4 = a2 * 0.5;
  __asm
  {
    FMOV            V2.2D, #0.5
    FMOV            V4.2D, #-0.5
    FMOV            V2.4S, #1.0
  }
  return v3 * v4;
}

float ARIntrinsicsFromTangents(int8x16_t a1, float64x2_t a2, float64_t a3, float a4)
{
  int32x2_t v4 = (int32x2_t)vextq_s8(a1, a1, 8uLL).u64[0];
  float32x2_t v5 = (float32x2_t)vzip1_s32(*(int32x2_t *)a1.i8, v4);
  a2.f64[1] = a3;
  __asm { FMOV            V2.4S, #1.0 }
  return (float)((float)-vcvt_f32_f64(vsubq_f64(vdivq_f64(vmulq_f64(a2, vcvtq_f64_f32(v5)), vcvtq_f64_f32(vsub_f32(v5, (float32x2_t)vzip2_s32(*(int32x2_t *)a1.i8, v4)))), (float64x2_t)vdupq_lane_s64(COERCE__INT64(a4), 0))).f32[0]- a4)/ *(float *)a1.i32;
}

float ARIntrinsicsFromDeviceFormat(void *a1)
{
  id v1 = a1;
  int32_t width = CMVideoFormatDescriptionGetDimensions((CMVideoFormatDescriptionRef)[v1 formatDescription]).width;
  [v1 videoFieldOfView];
  float v3 = v2;

  long double v4 = tan(v3 * 3.14159265 / 180.0 * 0.5);
  __asm { FMOV            V2.4S, #1.0 }
  return (double)width / (v4 + v4);
}

float32x2_t ARCameraFieldOfViewFromIntrinsics(float a1, double a2, double a3, double a4, double a5)
{
  float v9 = *((float *)&a2 + 1);
  long double v10 = atan(a4 / (float)(a1 + a1));
  long double v6 = atan(a5 / (float)(v9 + v9));
  v7.f64[0] = v10;
  v7.f64[1] = v6;
  return vcvt_f32_f64(vaddq_f64(v7, v7));
}

double AREulerAnglesFromMatrix(__n128 a1, __n128 a2, __n128 a3)
{
  if (a3.n128_f32[1] >= 1.0)
  {
    atan2f(-a1.n128_f32[2], -a2.n128_f32[2]);
    LODWORD(v3) = -1077342245;
LABEL_6:
    HIDWORD(v3) = 0;
    return v3;
  }
  if (a3.n128_f32[1] <= -1.0)
  {
    atan2f(a1.n128_f32[2], a2.n128_f32[2]);
    LODWORD(v3) = 1070141403;
    goto LABEL_6;
  }
  __n128 v6 = a3;
  float v7 = a2.n128_f32[1];
  float v5 = a1.n128_f32[1];
  float v8 = asinf(-a3.n128_f32[1]);
  v6.n128_u32[0] = atan2f(v6.n128_f32[0], v6.n128_f32[2]);
  atan2f(v5, v7);
  return COERCE_DOUBLE(__PAIR64__(v6.n128_u32[0], LODWORD(v8)));
}

__n64 ARInnerScaleFromMatrix(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2 = vmulq_f32(a1, a1);
  result.n64_f32[0] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v2, 2), vaddq_f32(v2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v2.f32, 1))).f32[0]);
  float32x4_t v3 = vmulq_f32(a2, a2);
  result.n64_u32[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v3, 2), vaddq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1))).f32[0]);
  return result;
}

double ARNormalizedTransform(float32x4_t a1)
{
  int32x4_t v1 = (int32x4_t)vmulq_f32(a1, a1);
  v1.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v1, 2), vadd_f32(*(float32x2_t *)v1.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v1.i8, 1))).u32[0];
  float32x2_t v2 = vrsqrte_f32((float32x2_t)v1.u32[0]);
  float32x2_t v3 = vmul_f32(v2, vrsqrts_f32((float32x2_t)v1.u32[0], vmul_f32(v2, v2)));
  *(void *)&double result = vmulq_n_f32(a1, vmul_f32(v3, vrsqrts_f32((float32x2_t)v1.u32[0], vmul_f32(v3, v3))).f32[0]).u64[0];
  return result;
}

double ARMatrixMakeLookAt(double a1, float32x4_t a2)
{
  int32x4_t v2 = (int32x4_t)vnegq_f32(a2);
  float32x4_t v3 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v2, v2), (int8x16_t)v2, 0xCuLL), (float32x4_t)xmmword_1B8A56700), (float32x4_t)xmmword_1B8A56710, a2);
  float32x4_t v4 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v3, (int32x4_t)v3), (int8x16_t)v3, 0xCuLL);
  int32x4_t v5 = (int32x4_t)vmulq_f32(v3, v3);
  v5.i32[0] = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v5.i8, 1), vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v5, 2), *(float32x2_t *)v5.i8)).u32[0];
  float32x2_t v6 = vrsqrte_f32((float32x2_t)v5.u32[0]);
  float32x2_t v7 = vmul_f32(v6, vrsqrts_f32((float32x2_t)v5.u32[0], vmul_f32(v6, v6)));
  *(void *)&double result = vmulq_n_f32(v4, vmul_f32(v7, vrsqrts_f32((float32x2_t)v5.u32[0], vmul_f32(v7, v7))).f32[0]).u64[0];
  return result;
}

uint64_t AREqualTransforms(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5, float32x4_t a6, float32x4_t a7, float32x4_t a8)
{
  float32x4_t v8 = vabdq_f32(a1, a5);
  float32x4_t v9 = (float32x4_t)vdupq_n_s32(0x38FA0000u);
  return vminvq_u32((uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v9, v8), (int8x16_t)vcgeq_f32(v9, vabdq_f32(a2, a6))), vandq_s8((int8x16_t)vcgeq_f32(v9, vabdq_f32(a3, a7)), (int8x16_t)vcgeq_f32(v9, vabdq_f32(a4, a8))))) >> 31;
}

double ARVisionToRenderingCoordinateTransform()
{
  return *(double *)&_PromotedConst_5;
}

double ARRenderingToVisionCoordinateTransform()
{
  v1.columns[0] = (simd_float4)_PromotedConst_56;
  v1.columns[1] = (simd_float4)unk_1B8A567A0;
  v1.columns[2] = (simd_float4)xmmword_1B8A567B0;
  v1.columns[3] = *(simd_float4 *)(MEMORY[0x1E4F149A0] + 48);
  *(void *)&double result = (unint64_t)__invert_f4(v1);
  return result;
}

double ARVisionCameraToRenderingCoordinateTransform()
{
  return simd_matrix4x4((float32x4_t)_PromotedConst_57);
}

double ARRenderingToVisionCameraCoordinateTransform()
{
  return simd_matrix4x4((float32x4_t)_PromotedConst_57);
}

double ARRFUToRUBCoordinateTransform()
{
  return *(double *)&_PromotedConst_58;
}

double ARLFUToRUBCoordinateTransform()
{
  return *(double *)&_PromotedConst_59;
}

double ARIMUtoCameraCoordinateTransform()
{
  return *(double *)&_PromotedConst_60;
}

double ARFrontFacingCameraFlip()
{
  return *(double *)&_PromotedConst_61;
}

double ARMatrix4x4MirrorX(double a1, __n128 a2, __n128 a3, __n128 a4)
{
  uint64_t v4 = 0;
  float32x4_t v5 = *(float32x4_t *)(MEMORY[0x1E4F149A0] + 16);
  float32x4_t v6 = *(float32x4_t *)(MEMORY[0x1E4F149A0] + 32);
  float32x4_t v7 = *(float32x4_t *)(MEMORY[0x1E4F149A0] + 48);
  __n128 v15 = a2;
  __n128 v16 = a3;
  __n128 v17 = a4;
  float32x4_t v18 = 0u;
  float32x4_t v19 = 0u;
  float32x4_t v20 = 0u;
  float32x4_t v21 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v18 + v4) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B8A2B3D0, COERCE_FLOAT(*(long long *)((char *)&v14 + v4))), v5, *(float32x2_t *)((char *)&v14 + v4), 1), v6, *(float32x4_t *)((char *)&v14 + v4), 2), v7, *(float32x4_t *)((char *)&v14 + v4), 3);
    v4 += 16;
  }
  while (v4 != 64);
  uint64_t v8 = 0;
  float32x4_t v9 = v18;
  float32x4_t v10 = v19;
  float32x4_t v11 = v20;
  float32x4_t v12 = v21;
  long long v14 = xmmword_1B8A2B3D0;
  __n128 v15 = (__n128)v5;
  __n128 v16 = (__n128)v6;
  __n128 v17 = (__n128)v7;
  float32x4_t v18 = 0u;
  float32x4_t v19 = 0u;
  float32x4_t v20 = 0u;
  float32x4_t v21 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v18 + v_Block_object_dispose(&STACK[0x400], 8) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v9, COERCE_FLOAT(*(long long *)((char *)&v14 + v8))), v10, *(float32x2_t *)((char *)&v14 + v8), 1), v11, *(float32x4_t *)((char *)&v14 + v8), 2), v12, *(float32x4_t *)((char *)&v14 + v8), 3);
    v8 += 16;
  }
  while (v8 != 64);
  return *(double *)v18.i64;
}

double ARCameraToWorldTransformFromCMRotationMatrix(double *a1, uint64_t a2, int a3)
{
  float32x4_t v3 = *(float32x4_t *)(MEMORY[0x1E4F149A0] + 16);
  float32_t v4 = a1[4];
  v7.i32[3] = HIDWORD(*MEMORY[0x1E4F149A0]);
  v7.f32[0] = v4;
  float v5 = a1[5];
  v7.f32[1] = -v5;
  float32_t v6 = a1[3];
  v7.f32[2] = v6;
  float v8 = a1[1];
  v12.n128_u32[3] = v3.u32[3];
  v12.n128_f32[0] = -v8;
  __n128 v16 = *(__n128 *)(MEMORY[0x1E4F149A0] + 32);
  __n128 v9 = *(__n128 *)(MEMORY[0x1E4F149A0] + 48);
  float v10 = a1[2];
  v12.n128_f32[1] = v10;
  float v11 = *a1;
  v12.n128_f32[2] = -v11;
  float v13 = a1[7];
  v16.n128_f32[0] = -v13;
  float v14 = a1[8];
  v16.n128_f32[1] = v14;
  float v15 = a1[6];
  v16.n128_f32[2] = -v15;
  if (a2 == 2)
  {
    unint64_t v17 = 0;
    if (a3) {
      unsigned int v18 = -1;
    }
    else {
      unsigned int v18 = 0;
    }
    float32x4_t v19 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_n_s32(v18), *MEMORY[0x1E4F149A0], (int8x16_t)xmmword_1B8A2B3D0);
    float32x4_t v26 = v7;
    __n128 v27 = v12;
    long long v28 = (__int128)v16;
    __n128 v29 = v9;
    float32x4_t v30 = 0u;
    float32x4_t v31 = 0u;
    float32x4_t v32 = 0u;
    float32x4_t v33 = 0u;
    do
    {
      *(float32x4_t *)((char *)&v30 + v17) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v19, COERCE_FLOAT(*(_OWORD *)((char *)&v26 + v17))), v3, *(float32x2_t *)&v26.f32[v17 / 4], 1), (float32x4_t)xmmword_1B8A2B0E0, *(float32x4_t *)((char *)&v26 + v17), 2), (float32x4_t)v9, *(float32x4_t *)((char *)&v26 + v17), 3);
      v17 += 16;
    }
    while (v17 != 64);
    unint64_t v20 = 0;
    float32x4_t v21 = v30;
    float32x4_t v22 = v31;
    float32x4_t v23 = v32;
    float32x4_t v24 = v33;
    float32x4_t v26 = v19;
    __n128 v27 = (__n128)v3;
    long long v28 = xmmword_1B8A2B0E0;
    __n128 v29 = v9;
    float32x4_t v30 = 0u;
    float32x4_t v31 = 0u;
    float32x4_t v32 = 0u;
    float32x4_t v33 = 0u;
    do
    {
      *(float32x4_t *)((char *)&v30 + v20) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v21, COERCE_FLOAT(*(_OWORD *)((char *)&v26 + v20))), v22, *(float32x2_t *)&v26.f32[v20 / 4], 1), v23, *(float32x4_t *)((char *)&v26 + v20), 2), v24, *(float32x4_t *)((char *)&v26 + v20), 3);
      v20 += 16;
    }
    while (v20 != 64);
    v7.i64[0] = v30.i64[0];
  }
  else if (a3)
  {
    *(double *)v7.i64 = ARMatrix4x4MirrorX(*(double *)v7.i64, v12, v16, v9);
  }
  return *(double *)v7.i64;
}

double ARWorldToCameraTransformFromCMRotationMatrix(double *a1, uint64_t a2, int a3)
{
  float32x4_t v3 = *(float32x4_t *)(MEMORY[0x1E4F149A0] + 16);
  float32_t v4 = a1[4];
  v7.i32[3] = HIDWORD(*MEMORY[0x1E4F149A0]);
  v7.f32[0] = v4;
  float v5 = a1[1];
  v7.f32[1] = -v5;
  float v6 = a1[7];
  v7.f32[2] = -v6;
  float v8 = a1[5];
  v11.n128_f32[0] = -v8;
  float v9 = a1[2];
  v11.n128_f32[1] = v9;
  *(float *)&unsigned int v10 = a1[8];
  v11.n128_u64[1] = __PAIR64__(v3.u32[3], v10);
  __n128 v16 = *(__n128 *)(MEMORY[0x1E4F149A0] + 32);
  __n128 v12 = *(__n128 *)(MEMORY[0x1E4F149A0] + 48);
  float v13 = a1[3];
  v16.n128_f32[0] = v13;
  float v14 = *a1;
  v16.n128_f32[1] = -v14;
  float v15 = a1[6];
  v16.n128_f32[2] = -v15;
  if (a2 == 2)
  {
    unint64_t v17 = 0;
    if (a3) {
      unsigned int v18 = -1;
    }
    else {
      unsigned int v18 = 0;
    }
    float32x4_t v19 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_n_s32(v18), *MEMORY[0x1E4F149A0], (int8x16_t)xmmword_1B8A2B3D0);
    float32x4_t v26 = v7;
    __n128 v27 = v11;
    long long v28 = (__int128)v16;
    __n128 v29 = v12;
    float32x4_t v30 = 0u;
    float32x4_t v31 = 0u;
    float32x4_t v32 = 0u;
    float32x4_t v33 = 0u;
    do
    {
      *(float32x4_t *)((char *)&v30 + v17) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v19, COERCE_FLOAT(*(_OWORD *)((char *)&v26 + v17))), v3, *(float32x2_t *)&v26.f32[v17 / 4], 1), (float32x4_t)xmmword_1B8A2B0E0, *(float32x4_t *)((char *)&v26 + v17), 2), (float32x4_t)v12, *(float32x4_t *)((char *)&v26 + v17), 3);
      v17 += 16;
    }
    while (v17 != 64);
    unint64_t v20 = 0;
    float32x4_t v21 = v30;
    float32x4_t v22 = v31;
    float32x4_t v23 = v32;
    float32x4_t v24 = v33;
    float32x4_t v26 = v19;
    __n128 v27 = (__n128)v3;
    long long v28 = xmmword_1B8A2B0E0;
    __n128 v29 = v12;
    float32x4_t v30 = 0u;
    float32x4_t v31 = 0u;
    float32x4_t v32 = 0u;
    float32x4_t v33 = 0u;
    do
    {
      *(float32x4_t *)((char *)&v30 + v20) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v21, COERCE_FLOAT(*(_OWORD *)((char *)&v26 + v20))), v22, *(float32x2_t *)&v26.f32[v20 / 4], 1), v23, *(float32x4_t *)((char *)&v26 + v20), 2), v24, *(float32x4_t *)((char *)&v26 + v20), 3);
      v20 += 16;
    }
    while (v20 != 64);
    v7.i64[0] = v30.i64[0];
  }
  else if (a3)
  {
    *(double *)v7.i64 = ARMatrix4x4MirrorX(*(double *)v7.i64, v11, v16, v12);
  }
  return *(double *)v7.i64;
}

__n128 ARMatrix3x3FromArray(void *a1)
{
  id v1 = a1;
  int32x4_t v2 = [v1 objectAtIndexedSubscript:0];
  __n128 v8 = ARVector3FromArray(v2);
  float32x4_t v3 = [v1 objectAtIndexedSubscript:1];
  __n128 v7 = ARVector3FromArray(v3);
  float32_t v4 = [v1 objectAtIndexedSubscript:2];

  unsigned __int32 v6 = ARVector3FromArray(v4).n128_u32[0];
  result.n128_u64[0] = vzip1q_s32((int32x4_t)v8, (int32x4_t)v7).u64[0];
  result.n128_u32[2] = v6;
  return result;
}

__n128 ARVector3FromArray(void *a1)
{
  id v1 = a1;
  int32x4_t v2 = [v1 objectAtIndexedSubscript:0];
  [v2 floatValue];
  unsigned __int32 v11 = v3;
  float32_t v4 = [v1 objectAtIndexedSubscript:1];
  [v4 floatValue];
  unsigned __int32 v10 = v5;
  unsigned __int32 v6 = [v1 objectAtIndexedSubscript:2];

  [v6 floatValue];
  unsigned __int32 v9 = v7;

  result.n128_u32[0] = v11;
  result.n128_u32[1] = v10;
  result.n128_u32[2] = v9;
  return result;
}

__n128 ARMatrix3x3FromRowMajorFlatArray(void *a1)
{
  id v1 = a1;
  int32x4_t v2 = objc_msgSend(v1, "subarrayWithRange:", 0, 3);
  __n128 v8 = ARVector3FromArray(v2);
  unsigned __int32 v3 = objc_msgSend(v1, "subarrayWithRange:", 3, 3);
  __n128 v7 = ARVector3FromArray(v3);
  float32_t v4 = objc_msgSend(v1, "subarrayWithRange:", 6, 3);

  unsigned __int32 v6 = ARVector3FromArray(v4).n128_u32[0];
  result.n128_u64[0] = vzip1q_s32((int32x4_t)v8, (int32x4_t)v7).u64[0];
  result.n128_u32[2] = v6;
  return result;
}

__n128 ARMatrix3x3FromColumnMajorFlatArray(void *a1)
{
  id v1 = a1;
  int32x4_t v2 = objc_msgSend(v1, "subarrayWithRange:", 0, 3);
  __n128 v6 = ARVector3FromArray(v2);
  unsigned __int32 v3 = objc_msgSend(v1, "subarrayWithRange:", 3, 3);
  ARVector3FromArray(v3);
  float32_t v4 = objc_msgSend(v1, "subarrayWithRange:", 6, 3);

  ARVector3FromArray(v4);
  return v6;
}

__n128 ARMatrix4x3FromRowMajorFlatArray(void *a1)
{
  id v1 = a1;
  int32x4_t v2 = objc_msgSend(v1, "subarrayWithRange:", 0, 4);
  __n128 v8 = ARVector4FromArray(v2);
  unsigned __int32 v3 = objc_msgSend(v1, "subarrayWithRange:", 4, 4);
  __n128 v7 = ARVector4FromArray(v3);
  float32_t v4 = objc_msgSend(v1, "subarrayWithRange:", 8, 4);

  unsigned __int32 v6 = ARVector4FromArray(v4).n128_u32[0];
  result.n128_u64[0] = vzip1q_s32((int32x4_t)v8, (int32x4_t)v7).u64[0];
  result.n128_u32[2] = v6;
  return result;
}

__n128 ARVector4FromArray(void *a1)
{
  id v1 = a1;
  int32x4_t v2 = [v1 objectAtIndexedSubscript:0];
  [v2 floatValue];
  unsigned int v14 = v3;
  float32_t v4 = [v1 objectAtIndexedSubscript:1];
  [v4 floatValue];
  unsigned int v13 = v5;
  unsigned __int32 v6 = [v1 objectAtIndexedSubscript:2];
  [v6 floatValue];
  unsigned int v12 = v7;
  __n128 v8 = [v1 objectAtIndexedSubscript:3];

  [v8 floatValue];
  *(void *)&long long v9 = __PAIR64__(v13, v14);
  *((void *)&v9 + 1) = __PAIR64__(v10, v12);
  long long v15 = v9;

  return (__n128)v15;
}

id ARMatrix3x3ToColumnMajorFlatArray(__n128 a1, __n128 a2, __n128 a3)
{
  v20[9] = *MEMORY[0x1E4F143B8];
  unsigned int v3 = objc_msgSend(NSNumber, "numberWithFloat:");
  v20[0] = v3;
  HIDWORD(v4) = a1.n128_u32[1];
  LODWORD(v4) = a1.n128_u32[1];
  unsigned int v5 = [NSNumber numberWithFloat:v4];
  v20[1] = v5;
  unsigned __int32 v6 = objc_msgSend(NSNumber, "numberWithFloat:", COERCE_DOUBLE(__PAIR64__(a1.n128_u32[1], a1.n128_u32[2])));
  v20[2] = v6;
  unsigned int v7 = [NSNumber numberWithFloat:a2.n128_f64[0]];
  v20[3] = v7;
  HIDWORD(v_Block_object_dispose(&STACK[0x400], 8) = a2.n128_u32[1];
  LODWORD(v_Block_object_dispose(&STACK[0x400], 8) = a2.n128_u32[1];
  long long v9 = [NSNumber numberWithFloat:v8];
  _OWORD v20[4] = v9;
  unsigned int v10 = objc_msgSend(NSNumber, "numberWithFloat:", COERCE_DOUBLE(__PAIR64__(a2.n128_u32[1], a2.n128_u32[2])));
  void v20[5] = v10;
  unsigned __int32 v11 = [NSNumber numberWithFloat:a3.n128_f64[0]];
  v20[6] = v11;
  HIDWORD(v12) = a3.n128_u32[1];
  LODWORD(v12) = a3.n128_u32[1];
  unsigned int v13 = [NSNumber numberWithFloat:v12];
  v20[7] = v13;
  unsigned int v14 = objc_msgSend(NSNumber, "numberWithFloat:", COERCE_DOUBLE(__PAIR64__(a3.n128_u32[1], a3.n128_u32[2])));
  v20[8] = v14;
  long long v15 = [MEMORY[0x1E4F1C978] arrayWithObjects:v20 count:9];

  return v15;
}

id ARMatrix4x4ToColumnMajorFlatArray(__n128 a1, __n128 a2, __n128 a3, __n128 a4)
{
  v29[16] = *MEMORY[0x1E4F143B8];
  float32x4_t v24 = objc_msgSend(NSNumber, "numberWithFloat:");
  v29[0] = v24;
  HIDWORD(v4) = a1.n128_u32[1];
  LODWORD(v4) = a1.n128_u32[1];
  float32x4_t v23 = [NSNumber numberWithFloat:v4];
  v29[1] = v23;
  float32x4_t v22 = objc_msgSend(NSNumber, "numberWithFloat:", COERCE_DOUBLE(__PAIR64__(a1.n128_u32[1], a1.n128_u32[2])));
  void v29[2] = v22;
  a1.n128_u64[0] = objc_msgSend(NSNumber, "numberWithFloat:", COERCE_DOUBLE(__PAIR64__(a1.n128_u32[1], a1.n128_u32[3])));
  v29[3] = a1.n128_u64[0];
  float32x4_t v21 = [NSNumber numberWithFloat:a2.n128_f64[0]];
  v29[4] = v21;
  HIDWORD(v5) = a2.n128_u32[1];
  LODWORD(v5) = a2.n128_u32[1];
  unint64_t v20 = [NSNumber numberWithFloat:v5];
  _OWORD v29[5] = v20;
  float32x4_t v19 = objc_msgSend(NSNumber, "numberWithFloat:", COERCE_DOUBLE(__PAIR64__(a2.n128_u32[1], a2.n128_u32[2])));
  v29[6] = v19;
  unsigned __int32 v6 = objc_msgSend(NSNumber, "numberWithFloat:", COERCE_DOUBLE(__PAIR64__(a2.n128_u32[1], a2.n128_u32[3])));
  v29[7] = v6;
  unsigned int v7 = [NSNumber numberWithFloat:a3.n128_f64[0]];
  v29[8] = v7;
  HIDWORD(v_Block_object_dispose(&STACK[0x400], 8) = a3.n128_u32[1];
  LODWORD(v_Block_object_dispose(&STACK[0x400], 8) = a3.n128_u32[1];
  long long v9 = [NSNumber numberWithFloat:v8];
  v29[9] = v9;
  unsigned int v10 = objc_msgSend(NSNumber, "numberWithFloat:", COERCE_DOUBLE(__PAIR64__(a3.n128_u32[1], a3.n128_u32[2])));
  v29[10] = v10;
  unsigned __int32 v11 = objc_msgSend(NSNumber, "numberWithFloat:", COERCE_DOUBLE(__PAIR64__(a3.n128_u32[1], a3.n128_u32[3])));
  v29[11] = v11;
  double v12 = [NSNumber numberWithFloat:a4.n128_f64[0]];
  v29[12] = v12;
  HIDWORD(v13) = a4.n128_u32[1];
  LODWORD(v13) = a4.n128_u32[1];
  unsigned int v14 = [NSNumber numberWithFloat:v13];
  v29[13] = v14;
  long long v15 = objc_msgSend(NSNumber, "numberWithFloat:", COERCE_DOUBLE(__PAIR64__(a4.n128_u32[1], a4.n128_u32[2])));
  v29[14] = v15;
  __n128 v16 = objc_msgSend(NSNumber, "numberWithFloat:", COERCE_DOUBLE(__PAIR64__(a4.n128_u32[1], a4.n128_u32[3])));
  v29[15] = v16;
  unint64_t v17 = [MEMORY[0x1E4F1C978] arrayWithObjects:v29 count:16];

  return v17;
}

float64x2_t ARMatrix4x4ToColumnMajorFlatCArray(float64x2_t *a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5)
{
  *a1 = vcvtq_f64_f32(*(float32x2_t *)a2.f32);
  a1[1] = vcvt_hight_f64_f32(a2);
  a1[2] = vcvtq_f64_f32(*(float32x2_t *)a3.f32);
  a1[3] = vcvt_hight_f64_f32(a3);
  a1[4] = vcvtq_f64_f32(*(float32x2_t *)a4.f32);
  a1[5] = vcvt_hight_f64_f32(a4);
  float64x2_t result = vcvtq_f64_f32(*(float32x2_t *)a5.f32);
  a1[6] = result;
  a1[7] = vcvt_hight_f64_f32(a5);
  return result;
}

float ARMatrix4x4ToColumnMajor3x4FlatCArray(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a2 = *(_DWORD *)a1;
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a2 + _Block_object_dispose(&STACK[0x400], 8) = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a2 + 12) = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(a1 + 20);
  *(_DWORD *)(a2 + 20) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(a2 + 2_Block_object_dispose(&STACK[0x400], 8) = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(a2 + 36) = *(_DWORD *)(a1 + 48);
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a1 + 52);
  float result = *(float *)(a1 + 56);
  *(float *)(a2 + 44) = result;
  return result;
}

__n128 ARMatrix4x4FromRowMajorFlatArray(void *a1)
{
  id v1 = a1;
  int32x4_t v2 = objc_msgSend(v1, "subarrayWithRange:", 0, 4);
  __n128 v9 = ARVector4FromArray(v2);
  unsigned int v3 = objc_msgSend(v1, "subarrayWithRange:", 4, 4);
  __n128 v8 = ARVector4FromArray(v3);
  double v4 = objc_msgSend(v1, "subarrayWithRange:", 8, 4);
  __n128 v7 = ARVector4FromArray(v4);
  double v5 = objc_msgSend(v1, "subarrayWithRange:", 12, 4);

  int32x4_t v10 = vzip1q_s32(vzip1q_s32((int32x4_t)v9, (int32x4_t)v7), vzip1q_s32((int32x4_t)v8, (int32x4_t)ARVector4FromArray(v5)));
  return (__n128)v10;
}

__n128 ARMatrix4x4FromColumnMajorFlatArray(void *a1)
{
  id v1 = a1;
  int32x4_t v2 = objc_msgSend(v1, "subarrayWithRange:", 0, 4);
  __n128 v7 = ARVector4FromArray(v2);
  unsigned int v3 = objc_msgSend(v1, "subarrayWithRange:", 4, 4);
  ARVector4FromArray(v3);
  double v4 = objc_msgSend(v1, "subarrayWithRange:", 8, 4);
  ARVector4FromArray(v4);
  double v5 = objc_msgSend(v1, "subarrayWithRange:", 12, 4);

  ARVector4FromArray(v5);
  return v7;
}

__n128 ARVector3dFromArray@<Q0>(void *a1@<X0>, __n128 *a2@<X8>)
{
  id v3 = a1;
  double v4 = [v3 objectAtIndexedSubscript:0];
  [v4 doubleValue];
  unint64_t v13 = v5;
  unsigned __int32 v6 = [v3 objectAtIndexedSubscript:1];
  [v6 doubleValue];
  unint64_t v12 = v7;
  __n128 v8 = [v3 objectAtIndexedSubscript:2];

  [v8 doubleValue];
  __n128 v11 = v9;
  v9.n128_u64[0] = v13;
  v9.n128_u64[1] = v12;
  __n128 v14 = v9;

  __n128 result = v14;
  *a2 = v14;
  a2[1] = v11;
  return result;
}

double ARVector3FromCArray(uint64_t a1)
{
  return *(double *)a1;
}

void ARVector4dFromArray(void *a1@<X0>, _OWORD *a2@<X8>)
{
  id v3 = a1;
  id v16 = [v3 objectAtIndexedSubscript:0];
  [v16 doubleValue];
  uint64_t v15 = v4;
  unint64_t v5 = [v3 objectAtIndexedSubscript:1];
  [v5 doubleValue];
  uint64_t v14 = v6;
  unint64_t v7 = [v3 objectAtIndexedSubscript:2];
  [v7 doubleValue];
  uint64_t v13 = v8;
  __n128 v9 = [v3 objectAtIndexedSubscript:3];

  [v9 doubleValue];
  *(void *)&long long v10 = v13;
  *((void *)&v10 + 1) = v11;
  *(void *)&long long v12 = v15;
  *((void *)&v12 + 1) = v14;
  *a2 = v12;
  a2[1] = v10;
}

id ARVector3ToArray(__n128 a1)
{
  void v8[3] = *MEMORY[0x1E4F143B8];
  id v1 = objc_msgSend(NSNumber, "numberWithFloat:");
  v8[0] = v1;
  HIDWORD(v2) = a1.n128_u32[1];
  LODWORD(v2) = a1.n128_u32[1];
  id v3 = [NSNumber numberWithFloat:v2];
  v8[1] = v3;
  uint64_t v4 = objc_msgSend(NSNumber, "numberWithFloat:", COERCE_DOUBLE(__PAIR64__(a1.n128_u32[1], a1.n128_u32[2])));
  v8[2] = v4;
  unint64_t v5 = [MEMORY[0x1E4F1C978] arrayWithObjects:v8 count:3];

  return v5;
}

id ARVector3dToArray(double *a1)
{
  void v8[3] = *MEMORY[0x1E4F143B8];
  long long v7 = *(_OWORD *)a1;
  double v1 = a1[2];
  double v2 = [NSNumber numberWithDouble:*(void *)a1];
  v8[0] = v2;
  id v3 = [NSNumber numberWithDouble:*((double *)&v7 + 1)];
  v8[1] = v3;
  uint64_t v4 = [NSNumber numberWithDouble:v1];
  v8[2] = v4;
  unint64_t v5 = [MEMORY[0x1E4F1C978] arrayWithObjects:v8 count:3];

  return v5;
}

id ARVector4ToArray(__n128 a1)
{
  void v9[4] = *MEMORY[0x1E4F143B8];
  double v1 = objc_msgSend(NSNumber, "numberWithFloat:");
  v9[0] = v1;
  HIDWORD(v2) = a1.n128_u32[1];
  LODWORD(v2) = a1.n128_u32[1];
  id v3 = [NSNumber numberWithFloat:v2];
  v9[1] = v3;
  uint64_t v4 = objc_msgSend(NSNumber, "numberWithFloat:", COERCE_DOUBLE(__PAIR64__(a1.n128_u32[1], a1.n128_u32[2])));
  void v9[2] = v4;
  unint64_t v5 = objc_msgSend(NSNumber, "numberWithFloat:", COERCE_DOUBLE(__PAIR64__(a1.n128_u32[1], a1.n128_u32[3])));
  v9[3] = v5;
  uint64_t v6 = [MEMORY[0x1E4F1C978] arrayWithObjects:v9 count:4];

  return v6;
}

id ARVector4dToArray(long long *a1)
{
  void v9[4] = *MEMORY[0x1E4F143B8];
  long long v7 = *a1;
  *(_OWORD *)uint64_t v8 = a1[1];
  double v1 = [NSNumber numberWithDouble:*(void *)a1];
  v9[0] = v1;
  double v2 = [NSNumber numberWithDouble:*((double *)&v7 + 1)];
  v9[1] = v2;
  id v3 = [NSNumber numberWithDouble:v8[0]];
  void v9[2] = v3;
  uint64_t v4 = [NSNumber numberWithDouble:v8[1]];
  v9[3] = v4;
  unint64_t v5 = [MEMORY[0x1E4F1C978] arrayWithObjects:v9 count:4];

  return v5;
}

double ARVector2FromNSData(void *a1)
{
  double v2 = 0.0;
  [a1 getBytes:&v2 length:8];
  return v2;
}

double ARVector3FromNSData(void *a1)
{
  int v3 = 0;
  double v2 = 0.0;
  [a1 getBytes:&v2 length:16];
  return v2;
}

double ARVector3dFromNSData@<D0>(void *a1@<X0>, _OWORD *a2@<X8>)
{
  *(void *)&long long v6 = 0;
  long long v5 = 0uLL;
  [a1 getBytes:&v5 length:32];
  double result = *(double *)&v5;
  long long v4 = v6;
  *a2 = v5;
  a2[1] = v4;
  return result;
}

double ARMatrix3x3FromNSData(void *a1)
{
  memset(v2, 0, sizeof(v2));
  [a1 getBytes:v2 length:48];
  return *(double *)v2;
}

double ARMatrix4x3FromNSData(void *a1)
{
  memset(v2, 0, sizeof(v2));
  [a1 getBytes:v2 length:64];
  return *(double *)v2;
}

double ARMatrix4x4FromNSData(void *a1)
{
  memset(v2, 0, sizeof(v2));
  [a1 getBytes:v2 length:64];
  return *(double *)v2;
}

__n128 ARMatrix4x4FromDictionary(void *a1)
{
  id v1 = a1;
  double v2 = [v1 objectForKeyedSubscript:@"translation"];
  objc_opt_class();
  __n128 v18 = 0u;
  if (objc_opt_isKindOfClass()) {
    __n128 v18 = ARVector3FromArray(v2);
  }
  int v3 = objc_msgSend(v1, "objectForKeyedSubscript:", @"rotation", *(_OWORD *)&v18);
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();
  float32x4_t v19 = *(float32x4_t *)MEMORY[0x1E4F14998];
  if (isKindOfClass)
  {
    __n128 v5 = ARVector4FromArray(v3);
    if (fabsf(v5.n128_f32[3]) > 0.00000011921)
    {
      float32x4_t v6 = vmulq_f32((float32x4_t)v5, (float32x4_t)v5);
      if (sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v6, 2), vaddq_f32(v6, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1))).f32[0]) > 0.00000011921)
      {
        float32x4_t v20 = (float32x4_t)v5;
        __float2 v7 = __sincosf_stret(v5.n128_f32[3] * 0.5);
        float32x4_t v8 = vmulq_n_f32(v20, v7.__sinval);
        v8.i32[3] = LODWORD(v7.__cosval);
        *(double *)v9.i64 = simd_matrix4x4(v8);
        float32x4_t v19 = v9;
      }
    }
  }
  long long v10 = [v1 objectForKeyedSubscript:@"scale"];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    __n128 v11 = ARVector3FromArray(v10);
    float32x4_t v12 = vmulq_f32((float32x4_t)v11, (float32x4_t)v11);
    if (sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), vaddq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1))).f32[0]) > 0.00000011921)float32x4_t v19 = vmulq_n_f32(v19, v11.n128_f32[0]); {

    }
    long long v10 = 0;
  }
  uint64_t v13 = [v1 objectForKeyedSubscript:@"perspective"];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    unsigned __int32 v14 = ARVector4FromArray(v13).n128_u32[0];
    float32x4_t v15 = v19;
    v15.i32[3] = v14;
    float32x4_t v21 = v15;
  }
  else
  {
    float32x4_t v16 = v19;
    v16.i32[3] = 0;
    float32x4_t v21 = v16;
  }

  return (__n128)v21;
}

void sub_1B89C81E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9, long long a10, long long a11, long long a12, __int16 buf)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    uint64_t v13 = _ARLogGeneral_34();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      vImage_Buffer buf = 0;
      _os_log_impl(&dword_1B88A2000, v13, OS_LOG_TYPE_ERROR, "Error reading matrix from dictionary", (uint8_t *)&buf, 2u);
    }

    objc_end_catch();
    JUMPOUT(0x1B89C81BCLL);
  }
  _Unwind_Resume(a1);
}

id ARMatrix4x4Dictionary(int a1, int a2, float32x4_t a3, float32x4_t a4, float32x4_t a5, __n128 a6)
{
  v101[3] = *MEMORY[0x1E4F143B8];
  float32x4_t v8 = objc_opt_new();
  float32x4_t v9 = vmulq_f32(a3, a3);
  *(float *)v10.i32 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v9, 2), vaddq_f32(v9, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v9.f32, 1))).f32[0]);
  float32x4_t v11 = vmulq_f32(a4, a4);
  *(float *)v12.i32 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), vaddq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1))).f32[0]);
  float32x4_t v18 = a5;
  float32x4_t v13 = vmulq_f32(v18, v18);
  *(float *)v14.i32 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2), vaddq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 1))).f32[0]);
  double v91 = *(double *)&v10;
  double v92 = *(double *)&v12;
  int32x4_t v15 = (int32x4_t)vdivq_f32(a3, (float32x4_t)vdupq_lane_s32(v10, 0));
  float32x4_t v16 = vdivq_f32(a4, (float32x4_t)vdupq_lane_s32(v12, 0));
  double v93 = *(double *)&v14;
  float32x4_t v17 = vdivq_f32(a5, (float32x4_t)vdupq_lane_s32(v14, 0));
  v18.f32[0] = v17.f32[2] + (float)(*(float *)v15.i32 + v16.f32[1]);
  if (v18.f32[0] >= 0.0)
  {
    float v26 = sqrtf(v18.f32[0] + 1.0);
    float v27 = v26 + v26;
    float32x2_t v28 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT(v26 + v26));
    float32x2_t v29 = vmul_f32(v28, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT(v26 + v26), v28));
    LODWORD(v30) = vmul_f32(v29, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT(v26 + v26), v29)).u32[0];
    float32x4_t v18 = (float32x4_t)vzip2q_s32((int32x4_t)v16, vuzp1q_s32((int32x4_t)v16, (int32x4_t)v17));
    *(float32x2_t *)v18.f32 = vmul_n_f32(vsub_f32(*(float32x2_t *)v18.f32, (float32x2_t)*(_OWORD *)&vtrn2q_s32((int32x4_t)v17, vzip2q_s32((int32x4_t)v17, v15))), v30);
    float v40 = vmuls_n_f32(vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.i8, 1), v16).f32[0], v30);
    float v41 = v27 * 0.25;
  }
  else if (*(float *)v15.i32 < v16.f32[1] || *(float *)v15.i32 < v17.f32[2])
  {
    float v20 = 1.0 - *(float *)v15.i32;
    if (v16.f32[1] >= v17.f32[2])
    {
      float v42 = sqrtf(v16.f32[1] + (float)(v20 - v17.f32[2]));
      *(float *)&unsigned int v43 = v42 + v42;
      float32x2_t v44 = vrecpe_f32((float32x2_t)v43);
      float32x2_t v45 = vmul_f32(v44, vrecps_f32((float32x2_t)v43, v44));
      v46.i32[0] = vmul_f32(v45, vrecps_f32((float32x2_t)v43, v45)).u32[0];
      float32x4_t v18 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.i8, 1);
      v18.i32[0] = vadd_f32(*(float32x2_t *)v18.f32, *(float32x2_t *)v16.f32).u32[0];
      v18.i32[1] = v43;
      float v40 = vmuls_lane_f32(v46.f32[0], (float32x2_t)*(_OWORD *)&vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 2), v17), 1);
      float v41 = vmuls_n_f32(vsubq_f32(v17, (float32x4_t)vdupq_laneq_s32(v15, 2)).f32[0], v46.f32[0]);
      v46.i32[1] = 0.25;
      *(float32x2_t *)v18.f32 = vmul_f32(*(float32x2_t *)v18.f32, v46);
    }
    else
    {
      float v21 = sqrtf(v17.f32[2] + (float)(v20 - v16.f32[1]));
      *(float *)&unsigned int v22 = v21 + v21;
      float32x2_t v23 = vrecpe_f32((float32x2_t)v22);
      float32x2_t v24 = vmul_f32(v23, vrecps_f32((float32x2_t)v22, v23));
      LODWORD(v25) = vmul_f32(v24, vrecps_f32((float32x2_t)v22, v24)).u32[0];
      float32x4_t v18 = (float32x4_t)vzip2q_s32(v15, (int32x4_t)v16);
      *(float32x2_t *)v18.f32 = vmul_n_f32(vadd_f32(*(float32x2_t *)v18.f32, *(float32x2_t *)v17.f32), v25);
      float v40 = *(float *)&v22 * 0.25;
      float v41 = vmuls_n_f32(vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.i8, 1), v16).f32[0], v25);
    }
  }
  else
  {
    float32x2_t v31 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)v16.f32, 0);
    float32x2_t v32 = vadd_f32(*(float32x2_t *)v15.i8, v31);
    v31.i32[0] = 2.0;
    v31.i32[0] = vmul_f32((float32x2_t)__PAIR64__(v15.u32[1], COERCE_UNSIGNED_INT(sqrtf(*(float *)v15.i32 + (float)((float)(1.0 - v16.f32[1])- v17.f32[2])))), v31).u32[0];
    v31.i32[1] = v32.i32[1];
    float32x2_t v33 = vrecpe_f32((float32x2_t)v31.u32[0]);
    float32x2_t v34 = vmul_f32(v33, vrecps_f32((float32x2_t)v31.u32[0], v33));
    LODWORD(v35) = vmul_f32(v34, vrecps_f32((float32x2_t)v31.u32[0], v34)).u32[0];
    __asm { FMOV            V5.2S, #0.25 }
    _D5.f32[1] = v35;
    *(float32x2_t *)v18.f32 = vmul_f32(v31, _D5);
    float v40 = vmuls_n_f32(vaddq_f32((float32x4_t)vdupq_laneq_s32(v15, 2), v17).f32[0], v35);
    float v41 = vmuls_lane_f32(v35, (float32x2_t)*(_OWORD *)&vsubq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 2), v17), 1);
  }
  v18.f32[2] = v40;
  float32x4_t v47 = vmulq_f32(v18, v18);
  float32x4_t v88 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v47, 2), vaddq_f32(v47, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v47.f32, 1)));
  float32x4_t v89 = v18;
  float v48 = atan2f(sqrtf(v88.f32[0]), v41);
  float v49 = v48 + v48;
  uint64_t v50 = [NSNumber numberWithFloat:a6.n128_f64[0]];
  v101[0] = v50;
  HIDWORD(v51) = a6.n128_u32[1];
  LODWORD(v51) = a6.n128_u32[1];
  uint64_t v52 = [NSNumber numberWithFloat:v51];
  v101[1] = v52;
  id v53 = objc_msgSend(NSNumber, "numberWithFloat:", COERCE_DOUBLE(__PAIR64__(a6.n128_u32[1], a6.n128_u32[2])));
  v101[2] = v53;
  long long v54 = [MEMORY[0x1E4F1C978] arrayWithObjects:v101 count:3];
  [v8 setObject:v54 forKeyedSubscript:@"translation"];

  if (fabsf(v49) <= 0.00000011921)
  {
    [v8 setObject:&unk_1F125C008 forKeyedSubscript:@"rotation"];
    if (!a1) {
      goto LABEL_25;
    }
    goto LABEL_17;
  }
  float32x2_t v55 = vrsqrte_f32((float32x2_t)v88.u32[0]);
  float32x2_t v56 = vmul_f32(v55, vrsqrts_f32((float32x2_t)v88.u32[0], vmul_f32(v55, v55)));
  float32x4_t v57 = vmulq_n_f32(v89, vmul_f32(v56, vrsqrts_f32((float32x2_t)v88.u32[0], vmul_f32(v56, v56))).f32[0]);
  float32x4_t v58 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v57, 2);
  float32x4_t v59 = vaddq_f32(v58, vaddq_f32(v57, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v57.f32, 1)));
  v58.i64[0] = 0;
  float32x4_t v60 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(v58, v59), 0), (int8x16_t)vnegq_f32(v57), (int8x16_t)v57);
  if (v59.f32[0] < 0.0) {
    float v49 = -v49;
  }
  int32x4_t v61 = (int32x4_t)vmulq_f32(v60, v60);
  v61.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v61, 2), vadd_f32(*(float32x2_t *)v61.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v61.i8, 1))).u32[0];
  float32x2_t v62 = vrsqrte_f32((float32x2_t)v61.u32[0]);
  float32x2_t v63 = vmul_f32(v62, vrsqrts_f32((float32x2_t)v61.u32[0], vmul_f32(v62, v62)));
  float32x4_t v90 = vmulq_n_f32(v60, vmul_f32(v63, vrsqrts_f32((float32x2_t)v61.u32[0], vmul_f32(v63, v63))).f32[0]);
  __n128 v64 = [NSNumber numberWithFloat:*(_OWORD *)&v88];
  v100[0] = v64;
  HIDWORD(v65) = v90.i32[1];
  LODWORD(v65) = v90.i32[1];
  int v66 = [NSNumber numberWithFloat:v65];
  v100[1] = v66;
  uint64_t v67 = objc_msgSend(NSNumber, "numberWithFloat:", COERCE_DOUBLE(__PAIR64__(v90.u32[1], v90.u32[2])));
  v100[2] = v67;
  *(float *)&double v68 = v49;
  __n128 v69 = [NSNumber numberWithFloat:v68];
  v100[3] = v69;
  long long v70 = [MEMORY[0x1E4F1C978] arrayWithObjects:v100 count:4];
  [v8 setObject:v70 forKeyedSubscript:@"rotation"];

  if (a1)
  {
LABEL_17:
    float v71 = fabsf(*(float *)&v92 + -1.0);
    BOOL v72 = fabsf(*(float *)&v91 + -1.0) <= 0.000011921 && v71 <= 0.000011921;
    float v73 = fabsf(*(float *)&v93 + -1.0);
    if (!v72 || v73 > 0.000011921)
    {
      long long v75 = [NSNumber numberWithFloat:v91];
      v99[0] = v75;
      int v76 = [NSNumber numberWithFloat:v92];
      v99[1] = v76;
      uint64_t v77 = [NSNumber numberWithFloat:v93];
      v99[2] = v77;
      __int16 v78 = [MEMORY[0x1E4F1C978] arrayWithObjects:v99 count:3];
      [v8 setObject:v78 forKeyedSubscript:@"scale"];
    }
  }
LABEL_25:
  if (a2
    && (fabsf(a3.f32[3]) > 0.00000011921
     || fabsf(a4.f32[3]) > 0.00000011921
     || fabsf(a5.f32[3]) > 0.00000011921
     || fabsf(a6.n128_f32[3] + -1.0) > 0.00000011921))
  {
    __n128 v79 = [NSNumber numberWithFloat:v88.i64[0]];
    v98[0] = v79;
    LODWORD(v80) = a4.i32[3];
    int v81 = [NSNumber numberWithFloat:v80];
    v98[1] = v81;
    LODWORD(v82) = a5.i32[3];
    uint64_t v83 = [NSNumber numberWithFloat:v82];
    v98[2] = v83;
    LODWORD(v84) = a6.n128_u32[3];
    long long v85 = [NSNumber numberWithFloat:v84];
    v98[3] = v85;
    int v86 = [MEMORY[0x1E4F1C978] arrayWithObjects:v98 count:4];
    [v8 setObject:v86 forKeyedSubscript:@"perspective"];
  }
  return v8;
}

float32x2_t ARVector3ScalarMultiplication(float32x2_t a1, float a2)
{
  return vmul_n_f32(a1, a2);
}

double ARMatrix4x4DoubleToFloat(float64x2_t *a1)
{
  *(void *)&double result = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*a1), a1[1]).u64[0];
  return result;
}

float64x2_t ARMatrix4x4FloatToDouble@<Q0>(float64x2_t *a1@<X8>, float32x4_t a2@<Q0>, float32x4_t a3@<Q1>, float32x4_t a4@<Q2>, float32x4_t a5@<Q3>)
{
  *a1 = vcvtq_f64_f32(*(float32x2_t *)a2.f32);
  a1[1] = vcvt_hight_f64_f32(a2);
  a1[2] = vcvtq_f64_f32(*(float32x2_t *)a3.f32);
  a1[3] = vcvt_hight_f64_f32(a3);
  a1[4] = vcvtq_f64_f32(*(float32x2_t *)a4.f32);
  a1[5] = vcvt_hight_f64_f32(a4);
  float64x2_t result = vcvt_hight_f64_f32(a5);
  a1[6] = vcvtq_f64_f32(*(float32x2_t *)a5.f32);
  a1[7] = result;
  return result;
}

void ARYawDifference(__n128 a1, __n128 a2, double a3, double a4, __n128 a5, __n128 a6)
{
  char v6 = 0;
  int v7 = 0;
  float v8 = 0.0;
  while (1)
  {
    __n128 v25 = a1;
    float v9 = *(float *)((unint64_t)&v25 & 0xFFFFFFFFFFFFFFF3 | (4 * (v7 & 3)));
    __n128 v24 = a2;
    float v10 = sqrtf((float)(*(float *)((unint64_t)&v24 & 0xFFFFFFFFFFFFFFF3 | (4 * (v7 & 3)))* *(float *)((unint64_t)&v24 & 0xFFFFFFFFFFFFFFF3 | (4 * (v7 & 3))))+ (float)(v9 * v9));
    __n128 v23 = a5;
    float v11 = *(float *)((unint64_t)&v23 & 0xFFFFFFFFFFFFFFF3 | (4 * (v7 & 3)));
    __n128 v22 = a6;
    if (vabds_f32(v10, sqrtf((float)(*(float *)((unint64_t)&v22 & 0xFFFFFFFFFFFFFFF3 | (4 * (v7 & 3)))* *(float *)((unint64_t)&v22 & 0xFFFFFFFFFFFFFFF3 | (4 * (v7 & 3))))+ (float)(v11 * v11))) > 0.025)break; {
    if (v10 > v8)
    }
    {
      float v8 = v10;
      char v6 = v7;
    }
    if (++v7 == 3)
    {
      __n128 v21 = a2;
      int32x2_t v12 = (float *)((unint64_t)&v18 & 0xFFFFFFFFFFFFFFF3 | (4 * (v6 & 3)));
      float32x4_t v13 = (float *)((unint64_t)&v19 & 0xFFFFFFFFFFFFFFF3 | (4 * (v6 & 3)));
      float v14 = *(float *)((unint64_t)&v21 & 0xFFFFFFFFFFFFFFF3 | (4 * (v6 & 3)));
      __n128 v20 = a1;
      atan2f(v14, *(float *)((unint64_t)&v20 & 0xFFFFFFFFFFFFFFF3 | (4 * (v6 & 3))));
      __n128 v19 = a6;
      float v15 = *v13;
      __n128 v18 = a5;
      atan2f(v15, *v12);
      return;
    }
  }
}

id ARMatrix4x4Description(int a1, __n128 a2, __n128 a3, __n128 a4, __n128 a5)
{
  *(double *)v6.i64 = AREulerAnglesFromMatrix(a2, a3, a4);
  float32x4_t v7 = vdivq_f32(vmulq_f32(v6, (float32x4_t)vdupq_n_s32(0x43340000u)), (float32x4_t)vdupq_n_s32(0x40490FDBu));
  float v8 = objc_msgSend(MEMORY[0x1E4F28E78], "stringWithFormat:", @"<translation=(%f %f %f) rotation=(%0.2f° %0.2f° %0.2f°)", a5.n128_f32[0], a5.n128_f32[1], a5.n128_f32[2], v7.f32[0], v7.f32[1], v7.f32[2]);
  float v9 = v8;
  if (a1) {
    [v8 appendFormat:@" matrix=\n(%f, %f, %f, %f)\n(%f, %f, %f, %f)\n(%f, %f, %f, %f)\n(%f, %f, %f, %f)\n", a2.n128_f32[0], a3.n128_f32[0], a4.n128_f32[0], a5.n128_f32[0], a2.n128_f32[1], a3.n128_f32[1], a4.n128_f32[1], a5.n128_f32[1], a2.n128_f32[2], a3.n128_f32[2], a4.n128_f32[2], a5.n128_f32[2], a2.n128_f32[3], a3.n128_f32[3], a4.n128_f32[3], a5.n128_f32[3]];
  }
  [v9 appendString:@">"];
  return v9;
}

uint64_t ARMatrix3x3Description(__n128 a1, __n128 a2, __n128 a3)
{
  return [NSString stringWithFormat:@"<matrix=\n(%f, %f, %f)\n(%f, %f, %f)\n(%f, %f, %f)\n>", a1.n128_f32[0], a2.n128_f32[0], a3.n128_f32[0], a1.n128_f32[1], a2.n128_f32[1], a3.n128_f32[1], a1.n128_f32[2], a2.n128_f32[2], a3.n128_f32[2]];
}

uint64_t ARMatrix4x3Description(__n128 a1, __n128 a2, __n128 a3, __n128 a4)
{
  return [NSString stringWithFormat:@"<matrix=\n(%f, %f, %f, %f)\n(%f, %f, %f, %f)\n(%f, %f, %f, %f)\n>", a1.n128_f32[0], a2.n128_f32[0], a3.n128_f32[0], a4.n128_f32[0], a1.n128_f32[1], a2.n128_f32[1], a3.n128_f32[1], a4.n128_f32[1], a1.n128_f32[2], a2.n128_f32[2], a3.n128_f32[2], a4.n128_f32[2]];
}

uint64_t ARVector3Description(__n128 a1)
{
  return objc_msgSend(NSString, "stringWithFormat:", @"(%f %f %f)", a1.n128_f32[0], a1.n128_f32[1], a1.n128_f32[2]);
}

uint64_t ARVector4Description(__n128 a1)
{
  return objc_msgSend(NSString, "stringWithFormat:", @"(%f %f %f %f)", a1.n128_f32[0], a1.n128_f32[1], a1.n128_f32[2], a1.n128_f32[3]);
}

uint64_t ARVector3MatlabDescription(uint64_t a1, __n128 a2)
{
  return [NSString stringWithFormat:@"%@ = [%f,%f,%f]\n", a1, a2.n128_f32[0], a2.n128_f32[1], a2.n128_f32[2]];
}

uint64_t ARVector4MatlabDescription(uint64_t a1, __n128 a2)
{
  return [NSString stringWithFormat:@"%@ = [%f,%f,%f,%f]\n", a1, a2.n128_f32[0], a2.n128_f32[1], a2.n128_f32[2], a2.n128_f32[3]];
}

uint64_t ARMatrix3x3MatlabDescription(uint64_t a1, __n128 a2, __n128 a3, __n128 a4)
{
  return objc_msgSend(NSString, "stringWithFormat:", @"%@ = [%f,%f,%f;\n%f,%f,%f;\n%f,%f,%f]\n",
           a1,
           a2.n128_f32[0],
           a3.n128_f32[0],
           a4.n128_f32[0],
           a2.n128_f32[1],
           a3.n128_f32[1],
           a4.n128_f32[1],
           a2.n128_f32[2],
           a3.n128_f32[2],
           a4.n128_f32[2]);
}

uint64_t ARMatrix4x4MatlabDescription(uint64_t a1, __n128 a2, __n128 a3, __n128 a4, __n128 a5)
{
  return objc_msgSend(NSString, "stringWithFormat:", @"%@ = [%f,%f,%f,%f;\n%f,%f,%f,%f;\n%f,%f,%f,%f;\n%f,%f,%f,%f]\n",
           a1,
           a2.n128_f32[0],
           a3.n128_f32[0],
           a4.n128_f32[0],
           a5.n128_f32[0],
           a2.n128_f32[1],
           a3.n128_f32[1],
           a4.n128_f32[1],
           a5.n128_f32[1],
           a2.n128_f32[2],
           a3.n128_f32[2],
           a4.n128_f32[2],
           a5.n128_f32[2],
           a2.n128_f32[3],
           a3.n128_f32[3],
           a4.n128_f32[3],
           a5.n128_f32[3]);
}

void ARCGRectRotate(uint64_t a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5)
{
  memset(&v15, 0, sizeof(v15));
  long long v11 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
  *(_OWORD *)&v14.a = *MEMORY[0x1E4F1DAB8];
  long long v10 = *(_OWORD *)&v14.a;
  *(_OWORD *)&v14.c = v11;
  *(_OWORD *)&v14.tfloat x = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 32);
  long long v9 = *(_OWORD *)&v14.tx;
  CGAffineTransformRotate(&v15, &v14, (float)a1 * 3.14159265 / 180.0);
  *(_OWORD *)&v13.a = v10;
  *(_OWORD *)&v13.c = v11;
  *(_OWORD *)&v13.tfloat x = v9;
  memset(&v14, 0, sizeof(v14));
  CGAffineTransformTranslate(&v14, &v13, -0.5, -0.5);
  CGAffineTransform v12 = v14;
  memset(&v13, 0, sizeof(v13));
  CGAffineTransformInvert(&v13, &v12);
  CGAffineTransform v12 = v14;
  v16.origin.float x = a2;
  v16.origin.y = a3;
  v16.size.int32_t width = a4;
  v16.size.height = a5;
  CGRect v17 = CGRectApplyAffineTransform(v16, &v12);
  CGAffineTransform v12 = v15;
  CGRect v18 = CGRectApplyAffineTransform(v17, &v12);
  CGAffineTransform v12 = v13;
  CGRectApplyAffineTransform(v18, &v12);
}

double ARWorldTransformFromVisionTransform(simd_float4x4 a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5)
{
  simd_float4x4 v7 = __invert_f4(a1);
  simd_float4 v5 = v7.columns[3];
  uint64_t v6 = 0;
  v19.columns[0] = v7.columns[0];
  v7.columns[3] = *(simd_float4 *)(MEMORY[0x1E4F149A0] + 48);
  v19.columns[1] = v7.columns[1];
  v19.columns[2] = v7.columns[2];
  v19.columns[3] = v5;
  memset(&v20, 0, sizeof(v20));
  do
  {
    v20.columns[v6] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B8A2B0E0, COERCE_FLOAT(*(_OWORD *)&v19.columns[v6])), (float32x4_t)xmmword_1B8A2B3D0, *(float32x2_t *)v19.columns[v6].f32, 1), (float32x4_t)xmmword_1B8A2B0D0, (float32x4_t)v19.columns[v6], 2), (float32x4_t)v7.columns[3], (float32x4_t)v19.columns[v6], 3);
    ++v6;
  }
  while (v6 != 4);
  float32x4_t v13 = (float32x4_t)v20.columns[1];
  float32x4_t v14 = (float32x4_t)v20.columns[0];
  float32x4_t v11 = (float32x4_t)v20.columns[3];
  float32x4_t v12 = (float32x4_t)v20.columns[2];
  v7.columns[0] = (simd_float4)_PromotedConst_56;
  v7.columns[1] = (simd_float4)unk_1B8A567A0;
  v7.columns[2] = (simd_float4)xmmword_1B8A567B0;
  simd_float4x4 v21 = __invert_f4(v7);
  uint64_t v8 = 0;
  simd_float4x4 v19 = v21;
  memset(&v20, 0, sizeof(v20));
  do
  {
    v20.columns[v8] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v14, COERCE_FLOAT(*(_OWORD *)&v19.columns[v8])), v13, *(float32x2_t *)v19.columns[v8].f32, 1), v12, (float32x4_t)v19.columns[v8], 2), v11, (float32x4_t)v19.columns[v8], 3);
    ++v8;
  }
  while (v8 != 4);
  uint64_t v9 = 0;
  simd_float4x4 v19 = v20;
  memset(&v20, 0, sizeof(v20));
  do
  {
    v20.columns[v9] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a2, COERCE_FLOAT(*(_OWORD *)&v19.columns[v9])), a3, *(float32x2_t *)v19.columns[v9].f32, 1), a4, (float32x4_t)v19.columns[v9], 2), a5, (float32x4_t)v19.columns[v9], 3);
    ++v9;
  }
  while (v9 != 4);
  return *(double *)v20.columns[0].i64;
}

double ARTransformFromVisionTransform(simd_float4x4 a1)
{
  simd_float4 v1 = a1.columns[3];
  uint64_t v2 = 0;
  v9.columns[0] = a1.columns[0];
  a1.columns[3] = *(simd_float4 *)(MEMORY[0x1E4F149A0] + 48);
  v9.columns[1] = a1.columns[1];
  v9.columns[2] = a1.columns[2];
  v9.columns[3] = v1;
  float32x4_t v10 = 0u;
  float32x4_t v11 = 0u;
  float32x4_t v12 = 0u;
  float32x4_t v13 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v10 + v2 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B8A2B0E0, COERCE_FLOAT(*(_OWORD *)&v9.columns[v2])), (float32x4_t)xmmword_1B8A2B3D0, *(float32x2_t *)v9.columns[v2].f32, 1), (float32x4_t)xmmword_1B8A2B0D0, (float32x4_t)v9.columns[v2], 2), (float32x4_t)a1.columns[3], (float32x4_t)v9.columns[v2], 3);
    ++v2;
  }
  while (v2 != 4);
  float32x4_t v7 = v11;
  float32x4_t v8 = v10;
  float32x4_t v5 = v13;
  float32x4_t v6 = v12;
  a1.columns[0] = (simd_float4)_PromotedConst_56;
  a1.columns[1] = (simd_float4)unk_1B8A567A0;
  a1.columns[2] = (simd_float4)xmmword_1B8A567B0;
  simd_float4x4 v14 = __invert_f4(a1);
  uint64_t v3 = 0;
  simd_float4x4 v9 = v14;
  float32x4_t v10 = 0u;
  float32x4_t v11 = 0u;
  float32x4_t v12 = 0u;
  float32x4_t v13 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v10 + v3 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v8, COERCE_FLOAT(*(_OWORD *)&v9.columns[v3])), v7, *(float32x2_t *)v9.columns[v3].f32, 1), v6, (float32x4_t)v9.columns[v3], 2), v5, (float32x4_t)v9.columns[v3], 3);
    ++v3;
  }
  while (v3 != 4);
  return *(double *)v10.i64;
}

double ARVisionTransformFromARTransform(__n128 a1, __n128 a2, __n128 a3, __n128 a4)
{
  v24.columns[3] = *(simd_float4 *)(MEMORY[0x1E4F149A0] + 48);
  v24.columns[0] = (simd_float4)_PromotedConst_56;
  v24.columns[1] = (simd_float4)unk_1B8A567A0;
  v24.columns[2] = (simd_float4)xmmword_1B8A567B0;
  simd_float4 v15 = v24.columns[3];
  simd_float4x4 v25 = __invert_f4(v24);
  uint64_t v4 = 0;
  long long v16 = (__int128)a1;
  long long v17 = (__int128)a2;
  long long v18 = (__int128)a3;
  __n128 v19 = a4;
  float32x4_t v20 = 0u;
  float32x4_t v21 = 0u;
  float32x4_t v22 = 0u;
  float32x4_t v23 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v20 + v4) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v25.columns[0], COERCE_FLOAT(*(long long *)((char *)&v16 + v4))), (float32x4_t)v25.columns[1], *(float32x2_t *)((char *)&v16 + v4), 1), (float32x4_t)v25.columns[2], *(float32x4_t *)((char *)&v16 + v4), 2), (float32x4_t)v25.columns[3], *(float32x4_t *)((char *)&v16 + v4), 3);
    v4 += 16;
  }
  while (v4 != 64);
  uint64_t v5 = 0;
  float32x4_t v6 = v20;
  float32x4_t v7 = v21;
  float32x4_t v8 = v22;
  float32x4_t v9 = v23;
  long long v16 = xmmword_1B8A2B0E0;
  long long v17 = xmmword_1B8A2B3D0;
  long long v18 = xmmword_1B8A2B0D0;
  __n128 v19 = (__n128)v15;
  float32x4_t v20 = 0u;
  float32x4_t v21 = 0u;
  float32x4_t v22 = 0u;
  float32x4_t v23 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v20 + v5) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v6, COERCE_FLOAT(*(long long *)((char *)&v16 + v5))), v7, *(float32x2_t *)((char *)&v16 + v5), 1), v8, *(float32x4_t *)((char *)&v16 + v5), 2), v9, *(float32x4_t *)((char *)&v16 + v5), 3);
    v5 += 16;
  }
  while (v5 != 64);
  return *(double *)v20.i64;
}

double ARVisionTransformFromWorldTransform(__n128 a1, __n128 a2, __n128 a3, __n128 a4, simd_float4 a5, simd_float4 a6, simd_float4 a7, simd_float4 a8)
{
  v32.columns[0] = a5;
  v32.columns[1] = a6;
  v32.columns[2] = a7;
  v32.columns[3] = a8;
  simd_float4x4 v33 = __invert_f4(v32);
  unint64_t v8 = 0;
  long long v26 = (__int128)a1;
  long long v27 = (__int128)a2;
  long long v28 = (__int128)a3;
  __n128 v29 = a4;
  memset(&v30, 0, sizeof(v30));
  do
  {
    v30.columns[v8 / 0x10] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v33.columns[0], COERCE_FLOAT(*(long long *)((char *)&v26 + v8))), (float32x4_t)v33.columns[1], *(float32x2_t *)((char *)&v26 + v8), 1), (float32x4_t)v33.columns[2], *(float32x4_t *)((char *)&v26 + v8), 2), (float32x4_t)v33.columns[3], *(float32x4_t *)((char *)&v26 + v8), 3);
    v8 += 16;
  }
  while (v8 != 64);
  simd_float4 v21 = v30.columns[1];
  simd_float4 v23 = v30.columns[0];
  simd_float4 v17 = v30.columns[3];
  simd_float4 v19 = v30.columns[2];
  v34.columns[3] = *(simd_float4 *)(MEMORY[0x1E4F149A0] + 48);
  v34.columns[0] = (simd_float4)_PromotedConst_56;
  v34.columns[1] = (simd_float4)unk_1B8A567A0;
  v34.columns[2] = (simd_float4)xmmword_1B8A567B0;
  simd_float4 v25 = v34.columns[3];
  simd_float4x4 v35 = __invert_f4(v34);
  unint64_t v9 = 0;
  long long v26 = (__int128)v23;
  long long v27 = (__int128)v21;
  long long v28 = (__int128)v19;
  __n128 v29 = (__n128)v17;
  memset(&v30, 0, sizeof(v30));
  do
  {
    v30.columns[v9 / 0x10] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v35.columns[0], COERCE_FLOAT(*(long long *)((char *)&v26 + v9))), (float32x4_t)v35.columns[1], *(float32x2_t *)((char *)&v26 + v9), 1), (float32x4_t)v35.columns[2], *(float32x4_t *)((char *)&v26 + v9), 2), (float32x4_t)v35.columns[3], *(float32x4_t *)((char *)&v26 + v9), 3);
    v9 += 16;
  }
  while (v9 != 64);
  unint64_t v10 = 0;
  float32x4_t v11 = (float32x4_t)v30.columns[0];
  float32x4_t v12 = (float32x4_t)v30.columns[1];
  float32x4_t v13 = (float32x4_t)v30.columns[2];
  float32x4_t v14 = (float32x4_t)v30.columns[3];
  long long v26 = xmmword_1B8A2B0E0;
  long long v27 = xmmword_1B8A2B3D0;
  long long v28 = xmmword_1B8A2B0D0;
  __n128 v29 = (__n128)v25;
  memset(&v30, 0, sizeof(v30));
  do
  {
    v30.columns[v10 / 0x10] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v11, COERCE_FLOAT(*(long long *)((char *)&v26 + v10))), v12, *(float32x2_t *)((char *)&v26 + v10), 1), v13, *(float32x4_t *)((char *)&v26 + v10), 2), v14, *(float32x4_t *)((char *)&v26 + v10), 3);
    v10 += 16;
  }
  while (v10 != 64);
  simd_float4x4 v15 = v30;
  *(void *)&double result = (unint64_t)__invert_f4(v15);
  return result;
}

double ARVisionCameraTransformFromWorldTransform(__n128 a1, __n128 a2, __n128 a3, __n128 a4, simd_float4 a5, simd_float4 a6, simd_float4 a7, simd_float4 a8)
{
  v36.columns[0] = a5;
  v36.columns[1] = a6;
  v36.columns[2] = a7;
  v36.columns[3] = a8;
  simd_float4x4 v37 = __invert_f4(v36);
  unint64_t v8 = 0;
  __n128 v28 = a1;
  __n128 v29 = a2;
  __n128 v30 = a3;
  __n128 v31 = a4;
  float32x4_t v32 = 0u;
  float32x4_t v33 = 0u;
  float32x4_t v34 = 0u;
  float32x4_t v35 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v32 + v_Block_object_dispose(&STACK[0x400], 8) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v37.columns[0], COERCE_FLOAT(*(_OWORD *)((char *)&v28 + v8))), (float32x4_t)v37.columns[1], (float32x2_t)v28.n128_u64[v8 / 8], 1), (float32x4_t)v37.columns[2], *(float32x4_t *)((char *)&v28 + v8), 2), (float32x4_t)v37.columns[3], *(float32x4_t *)((char *)&v28 + v8), 3);
    v8 += 16;
  }
  while (v8 != 64);
  __n128 v23 = (__n128)v33;
  __n128 v26 = (__n128)v32;
  __n128 v17 = (__n128)v35;
  __n128 v20 = (__n128)v34;
  v38.columns[0] = (simd_float4)_PromotedConst_56;
  v38.columns[1] = (simd_float4)unk_1B8A567A0;
  v38.columns[2] = (simd_float4)xmmword_1B8A567B0;
  v38.columns[3] = *(simd_float4 *)(MEMORY[0x1E4F149A0] + 48);
  simd_float4x4 v39 = __invert_f4(v38);
  unint64_t v9 = 0;
  __n128 v28 = v26;
  __n128 v29 = v23;
  __n128 v30 = v20;
  __n128 v31 = v17;
  float32x4_t v32 = 0u;
  float32x4_t v33 = 0u;
  float32x4_t v34 = 0u;
  float32x4_t v35 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v32 + v9) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v39.columns[0], COERCE_FLOAT(*(_OWORD *)((char *)&v28 + v9))), (float32x4_t)v39.columns[1], (float32x2_t)v28.n128_u64[v9 / 8], 1), (float32x4_t)v39.columns[2], *(float32x4_t *)((char *)&v28 + v9), 2), (float32x4_t)v39.columns[3], *(float32x4_t *)((char *)&v28 + v9), 3);
    v9 += 16;
  }
  while (v9 != 64);
  float32x4_t v24 = v33;
  float32x4_t v27 = v32;
  float32x4_t v18 = v35;
  float32x4_t v21 = v34;
  v10.n128_f64[0] = simd_matrix4x4((float32x4_t)_PromotedConst_57);
  unint64_t v11 = 0;
  __n128 v28 = v10;
  __n128 v29 = v12;
  __n128 v30 = v13;
  __n128 v31 = v14;
  float32x4_t v32 = 0u;
  float32x4_t v33 = 0u;
  float32x4_t v34 = 0u;
  float32x4_t v35 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v32 + v11) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v27, COERCE_FLOAT(*(_OWORD *)((char *)&v28 + v11))), v24, (float32x2_t)v28.n128_u64[v11 / 8], 1), v21, *(float32x4_t *)((char *)&v28 + v11), 2), v18, *(float32x4_t *)((char *)&v28 + v11), 3);
    v11 += 16;
  }
  while (v11 != 64);
  return *(double *)v32.i64;
}

double ARWorldVectorFromVisionVector(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5)
{
  uint64_t v5 = 0;
  long long v6 = *(_OWORD *)(MEMORY[0x1E4F149A0] + 48);
  void v9[2] = xmmword_1B8A2B0D0;
  v9[3] = v6;
  float32x4_t v10 = 0u;
  float32x4_t v11 = 0u;
  float32x4_t v12 = 0u;
  float32x4_t v13 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v10 + v5 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a2, COERCE_FLOAT(v9[v5])), a3, *(float32x2_t *)&v9[v5], 1), a4, (float32x4_t)v9[v5], 2), a5, (float32x4_t)v9[v5], 3);
    ++v5;
  }
  while (v5 != 4);
  float32x4_t v7 = vaddq_f32(v13, vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v10, a1.f32[0]), v11, *(float32x2_t *)a1.f32, 1), v12, a1, 2));
  *(void *)&double result = vdivq_f32(v7, (float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 3)).u64[0];
  return result;
}

double ARVisionVectorFromARVector(int32x4_t a1)
{
  *(void *)&double result = vnegq_f32((float32x4_t)vzip2q_s32(a1, vuzp1q_s32(a1, a1))).u64[0];
  return result;
}

float ARCameraDirectionFromCMAttitude(void *a1)
{
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    [v1 rotationMatrix];
    double v3 = v9;
    [v2 rotationMatrix];
    double v4 = v8;
  }
  else
  {
    double v4 = 0.0;
    double v3 = 0.0;
  }
  if (v4 * v4 + v3 * v3 >= 0.01)
  {
    float v6 = atan2(v3, v4) * 0.318309886 * 180.0 + 90.0;
    if (v6 < 0.0) {
      float v6 = v6 + 360.0;
    }
    if (v6 >= 360.0) {
      float v5 = v6 + -360.0;
    }
    else {
      float v5 = v6;
    }
  }
  else
  {
    float v5 = NAN;
  }

  return v5;
}

double ARMatrix4x4FromRowMajorFlatBuffer(double *a1)
{
  *(float *)&unsigned int v1 = *a1;
  *(float *)&unsigned int v2 = a1[4];
  double result = COERCE_DOUBLE(__PAIR64__(v2, v1));
  __asm { FMOV            V3.4S, #1.0 }
  return result;
}

double ARMatrix4x4CopyToRowMajorFlatBuffer(uint64_t a1, int8x16_t a2, int8x16_t a3, int8x16_t a4, __n128 a5)
{
  float32x2_t v5 = (float32x2_t)vext_s8((int8x8_t)a5.n128_u64[0], (int8x8_t)*(_OWORD *)&vextq_s8(a2, a2, 8uLL), 4uLL);
  a5.n128_u32[1] = a2.u32[1];
  *(double *)a1 = *(float *)a2.i32;
  *(double *)(a1 + _Block_object_dispose(&STACK[0x400], 8) = *(float *)a3.i32;
  *(double *)(a1 + 16) = *(float *)a4.i32;
  *(float64x2_t *)(a1 + 24) = vcvtq_f64_f32((float32x2_t)a5.n128_u64[0]);
  *(float64x2_t *)(a1 + 40) = vcvtq_f64_f32((float32x2_t)vzip2_s32(*(int32x2_t *)a3.i8, *(int32x2_t *)a4.i8));
  *(float64x2_t *)(a1 + 56) = vcvtq_f64_f32(v5);
  double result = a5.n128_f32[2];
  *(float64x2_t *)(a1 + 72) = vcvtq_f64_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL)));
  *(double *)(a1 + 8_Block_object_dispose(&STACK[0x400], 8) = a5.n128_f32[2];
  return result;
}

uint64_t ARMatrix4x4ContainsNANValues()
{
  for (uint64_t i = 0; i != 4; ++i)
  {
    for (uint64_t j = 0; j != 64; j += 16)
      ;
  }
  return 0;
}

BOOL ARMatrix4x4ContainsScale(int32x4_t a1, int32x4_t a2, int32x4_t a3, __n128 a4)
{
  if (fabsf(a4.n128_f32[3] + -1.0) > 0.0000011921) {
    return 1;
  }
  uint64_t v5 = 0;
  int32x4_t v6 = a1;
  v6.i32[3] = 0;
  int32x4_t v7 = a2;
  v7.i32[3] = 0;
  int32x4_t v8 = a3;
  v8.i32[3] = 0;
  int32x4_t v9 = vdupq_lane_s32(*(int32x2_t *)a2.i8, 1);
  float32x4_t v10 = (float32x4_t)vzip1q_s32(a1, a2);
  v10.i32[2] = a3.i32[0];
  float32x4_t v11 = (float32x4_t)vzip2q_s32(a1, a2);
  v11.i32[2] = a3.i32[2];
  float32x4_t v12 = (float32x4_t)vzip2q_s32(vzip1q_s32(a1, a3), v9);
  v15[0] = v6;
  v15[1] = v7;
  v15[2] = v8;
  float32x4_t v16 = 0u;
  float32x4_t v17 = 0u;
  float32x4_t v18 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v16 + v5 * 16) = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v10, COERCE_FLOAT(v15[v5])), v12, *(float32x2_t *)&v15[v5], 1), v11, (float32x4_t)v15[v5], 2);
    ++v5;
  }
  while (v5 != 3);
  float32x4_t v13 = (float32x4_t)vdupq_n_s32(0x35A00000u);
  uint32x4_t v14 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v13, vabdq_f32(v17, *(float32x4_t *)(MEMORY[0x1E4F14998] + 16))), (int8x16_t)vcgeq_f32(v13, vabdq_f32(v16, *MEMORY[0x1E4F14998]))), (int8x16_t)vcgeq_f32(v13, vabdq_f32(v18, *(float32x4_t *)(MEMORY[0x1E4F14998] + 32))));
  v14.i32[3] = v14.i32[2];
  return (vminvq_u32(v14) & 0x80000000) == 0;
}

void ARInterpolateBetweenTransforms(simd_float3x3 a1, double a2, simd_float3 a3, simd_float3 a4, simd_float3 a5, double a6, float a7)
{
  v45.columns[1] = a4;
  v45.columns[2] = a5;
  v45.columns[0] = a3;
  *(double *)v14.i64 = simd_quaternion(a1);
  float32x4_t v50 = v14;
  *(double *)v15.i64 = simd_quaternion(v45);
  float32x4_t v16 = vmulq_f32(v50, v15);
  float32x4_t v17 = (float32x4_t)vextq_s8((int8x16_t)v16, (int8x16_t)v16, 8uLL);
  *(float32x2_t *)v16.f32 = vadd_f32(*(float32x2_t *)v16.f32, *(float32x2_t *)v17.f32);
  v16.f32[0] = vaddv_f32(*(float32x2_t *)v16.f32);
  v17.i64[0] = 0;
  float32x4_t v18 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vcgeq_f32(v16, v17)), 0), (int8x16_t)vnegq_f32(v15), (int8x16_t)v15);
  float v19 = 1.0;
  float v20 = 1.0 - a7;
  float32x4_t v21 = vsubq_f32(v50, v18);
  int8x16_t v22 = (int8x16_t)vmulq_f32(v21, v21);
  float32x4_t v49 = v18;
  float32x4_t v23 = vaddq_f32(v50, v18);
  int8x16_t v24 = (int8x16_t)vmulq_f32(v23, v23);
  float v25 = atan2f(sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v22.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v22, v22, 8uLL)))), sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v24.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL)))));
  float v26 = v25 + v25;
  BOOL v27 = (float)(v25 + v25) == 0.0;
  float v28 = 1.0;
  if (!v27) {
    float v28 = sinf(v26) / v26;
  }
  float v29 = v28;
  float32x2_t v30 = vrecpe_f32((float32x2_t)LODWORD(v28));
  float32x2_t v31 = vmul_f32(v30, vrecps_f32((float32x2_t)LODWORD(v29), v30));
  LODWORD(v32) = vmul_f32(v31, vrecps_f32((float32x2_t)LODWORD(v29), v31)).u32[0];
  if ((float)(v20 * v26) != 0.0)
  {
    float v47 = v32;
    v31.f32[0] = sinf(v20 * v26);
    float v32 = v47;
    float v19 = v31.f32[0] / (float)(v20 * v26);
  }
  v31.f32[0] = v20 * (float)(v32 * v19);
  float32x4_t v33 = (float32x4_t)vdupq_lane_s32((int32x2_t)v31, 0);
  float v34 = a7;
  float v35 = v26 * a7;
  float v36 = 1.0;
  if (v35 != 0.0)
  {
    float32x4_t v46 = v33;
    float v48 = v32;
    float v37 = sinf(v35);
    float32x4_t v33 = v46;
    float v32 = v48;
    float v34 = a7;
    float v36 = v37 / v35;
  }
  float32x4_t v38 = vmlaq_f32(vmulq_n_f32(v49, (float)(v32 * v36) * v34), v50, v33);
  int8x16_t v39 = (int8x16_t)vmulq_f32(v38, v38);
  float32x2_t v40 = vadd_f32(*(float32x2_t *)v39.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v39, v39, 8uLL));
  if (vaddv_f32(v40) == 0.0)
  {
    float32x4_t v41 = (float32x4_t)xmmword_1B8A2B050;
  }
  else
  {
    unsigned __int32 v42 = vadd_f32(v40, (float32x2_t)vdup_lane_s32((int32x2_t)v40, 1)).u32[0];
    float32x2_t v43 = vrsqrte_f32((float32x2_t)v42);
    float32x2_t v44 = vmul_f32(v43, vrsqrts_f32((float32x2_t)v42, vmul_f32(v43, v43)));
    float32x4_t v41 = vmulq_n_f32(v38, vmul_f32(v44, vrsqrts_f32((float32x2_t)v42, vmul_f32(v44, v44))).f32[0]);
  }
  simd_matrix4x4(v41);
}

uint64_t ARMinMax(_DWORD *a1, unsigned int a2, _DWORD *a3)
{
  if (a1) {
    BOOL v4 = (int)a2 <= 0;
  }
  else {
    BOOL v4 = 1;
  }
  uint64_t result = !v4;
  if (result == 1)
  {
    LODWORD(v6) = *a1;
    *a3 = *a1;
    HIDWORD(v6) = *a1;
    *(void *)a3 = v6;
    if (a2 >= 2)
    {
      int32x4_t v7 = (float *)(a1 + 1);
      uint64_t v8 = a2 - 1;
      while (1)
      {
        float v9 = *v7;
        if (*v7 > *((float *)&v6 + 1)) {
          break;
        }
        if (v9 < *(float *)&v6)
        {
          uint64_t v10 = 0;
          goto LABEL_14;
        }
LABEL_15:
        ++v7;
        if (!--v8) {
          return result;
        }
      }
      uint64_t v10 = 1;
LABEL_14:
      uint64_t v11 = v6;
      *(float *)((unint64_t)&v11 | (4 * v10)) = v9;
      uint64_t v6 = v11;
      *(void *)a3 = v11;
      goto LABEL_15;
    }
  }
  return result;
}

uint64_t ARInterpolateSorted(float *a1, uint64_t a2, int a3, float *a4, float a5)
{
  uint64_t v5 = 0;
  if (a1)
  {
    if (a2)
    {
      uint64_t v6 = (a3 - 1);
      if (a3 >= 1)
      {
        float v7 = *a1;
        if (*a1 > a5 || a1[v6] < a5) {
          return 0;
        }
        if (a3 >= 2)
        {
          uint64_t v9 = 0;
          int v10 = 0;
          char v11 = 0;
          while (1)
          {
            float v12 = v7;
            float v7 = a1[v9 + 1];
            if (v12 > v7) {
              return 0;
            }
            if (v11) {
              int v13 = v10;
            }
            else {
              int v13 = v9;
            }
            uint64_t v14 = v9 + 1;
            v11 |= v7 >= a5;
            if (v7 >= a5) {
              int v10 = v13;
            }
            ++v9;
            if (v6 == v14)
            {
              float v7 = a1[v10];
              goto LABEL_19;
            }
          }
        }
        int v10 = 0;
LABEL_19:
        *a4 = *(float *)(a2 + 4 * v10)
            + (float)((float)((float)(a5 - v7) * (float)(*(float *)(a2 + 4 * v10 + 4) - *(float *)(a2 + 4 * v10)))
                    / (float)(a1[v10 + 1] - v7));
        return 1;
      }
    }
  }
  return v5;
}

uint64_t kVTRotationFromARRotationAngle(uint64_t a1)
{
  uint64_t result = 0;
  if (a1 > 89)
  {
    if (a1 == 90)
    {
      uint64_t v3 = MEMORY[0x1E4F45360];
    }
    else
    {
      if (a1 != 180) {
        return result;
      }
      uint64_t v3 = MEMORY[0x1E4F45350];
    }
  }
  else if (a1 == -90)
  {
    uint64_t v3 = MEMORY[0x1E4F45358];
  }
  else
  {
    if (a1) {
      return result;
    }
    uint64_t v3 = MEMORY[0x1E4F45348];
  }
  return *(void *)v3;
}

void sub_1B89CA1A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89CA204(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89CA668(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89CB114(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t anonymous namespace'::FillRegistrationDataFrom(uint64_t result, uint64_t a2, uint64_t a3, float *a4, uint64_t a5, uint64_t a6, uint64_t a7, double a8)
{
  if (a3 != 16 || a5 != 17 || *a4 != 0.0 || a4[1] != 0.0 || a4[2] != 0.0)
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = "Please sync with arkit team if this happen!";
    __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
  }
  for (uint64_t i = 0; i != 128; i += 8)
  {
    uint64_t v9 = (_DWORD *)(result + i);
    _DWORD *v9 = *(void *)(a2 + i);
    v9[1] = *(_DWORD *)(a2 + i + 4);
  }
  unint64_t v10 = 0;
  char v11 = (_DWORD *)(result + 136);
  do
  {
    if (v10 < 7) {
      int v12 = v10;
    }
    else {
      int v12 = v10 + 1;
    }
    unint64_t v13 = v10 + 1;
    uint64_t v14 = &a4[4 * v12];
    *(v11 - 2) = *(_DWORD *)v14;
    *(v11 - 1) = *((_DWORD *)v14 + 1);
    *char v11 = *((_DWORD *)v14 + 2);
    v11 += 3;
    unint64_t v10 = v13;
  }
  while (v13 != 16);
  uint64_t v15 = 0;
  uint64_t v16 = result + 320;
  do
  {
    uint64_t v17 = 0;
    uint64_t v18 = a6;
    do
    {
      *(_DWORD *)(v16 + v17) = *(_DWORD *)(v18 + 4 * (v15 & 3));
      v18 += 16;
      v17 += 12;
    }
    while (v17 != 36);
    ++v15;
    v16 += 4;
  }
  while (v15 != 3);
  uint64_t v19 = 0;
  long long v25 = xmmword_1B8A56900;
  long long v26 = unk_1B8A56910;
  long long v27 = xmmword_1B8A56920;
  long long v28 = unk_1B8A56930;
  float v20 = &v25;
  do
  {
    for (uint64_t j = 0; j != 4; ++j)
      LODWORD(v20[j]) = *(_DWORD *)(a7 + j * 16 + 4 * (v19 & 3));
    ++v19;
    float v20 = (long long *)((char *)v20 + 4);
  }
  while (v19 != 3);
  long long v22 = v26;
  *(_OWORD *)(result + 356) = v25;
  *(_OWORD *)(result + 372) = v22;
  long long v23 = v28;
  *(_OWORD *)(result + 38_Block_object_dispose(&STACK[0x400], 8) = v27;
  *(_OWORD *)(result + 404) = v23;
  *(double *)(result + 48_Block_object_dispose(&STACK[0x400], 8) = a8;
  return result;
}

void sub_1B89CB5B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89CB744(_Unwind_Exception *a1)
{
  uint64_t v6 = v3;

  _Unwind_Resume(a1);
}

void sub_1B89CB82C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89CBD24(_Unwind_Exception *a1)
{
  std::ostream::~ostream();
  MEMORY[0x1BA9C5670](v1);
  _Unwind_Resume(a1);
}

void ___ZL13_ARLogGeneralv_block_invoke_23()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "General");
  uint64_t v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObuint64_t j = (uint64_t)v0;
}

void ___ZL15_ARLogTechniquev_block_invoke_12()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "Technique");
  uint64_t v1 = (void *)_ARLogTechnique(void)::logObj;
  _ARLogTechnique(void)::logObuint64_t j = (uint64_t)v0;
}

void *_ZNSt3__115allocate_sharedB8ne180100IN5arkit3btr15ScaleCorrectionENS_9allocatorIS3_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_@<X0>(void *a1@<X8>)
{
  unsigned int v2 = operator new(0x60uLL);
  uint64_t result = _ZNSt3__120__shared_ptr_emplaceIN5arkit3btr15ScaleCorrectionENS_9allocatorIS3_EEEC2B8ne180100IJES5_Li0EEES5_DpOT_(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_1B89CBE14(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *_ZNSt3__120__shared_ptr_emplaceIN5arkit3btr15ScaleCorrectionENS_9allocatorIS3_EEEC2B8ne180100IJES5_Li0EEES5_DpOT_(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F1209A40;
  *(void *)&long long v3 = 10;
  *((void *)&v3 + 1) = 0x3CA3D70A3A83126FLL;
  uint64_t v4 = 5;
  long long v5 = xmmword_1B8A568F0;
  uint64_t v6 = 0x3FF9999A3D4CCCCDLL;
  char v7 = 1;
  arkit::btr::ScaleCorrection::ScaleCorrection((uint64_t)(a1 + 3), &v3);
  return a1;
}

void sub_1B89CBEB8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<arkit::btr::ScaleCorrection>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1209A40;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<arkit::btr::ScaleCorrection>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1209A40;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BA9C56C0);
}

void std::__shared_ptr_emplace<arkit::btr::ScaleCorrection>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 88);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

float32x2_t dehomogenize3d(int32x4_t a1)
{
  return vdiv_f32(*(float32x2_t *)a1.i8, (float32x2_t)vdup_laneq_s32(a1, 2));
}

double dehomogenize4d(float32x4_t a1)
{
  *(void *)&double result = vdivq_f32(a1, (float32x4_t)vdupq_laneq_s32((int32x4_t)a1, 3)).u64[0];
  return result;
}

uint64_t ARIsBoxInViewFrustum(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5, double a6, double a7, double a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, float32x4_t a17, float32x4_t a18, float32x4_t a19, float32x4_t a20,float32x4_t a21,float32x4_t a22,float32x4_t a23,float a24,float a25)
{
  if (fabsf(a5.f32[0]) != INFINITY
    || (v22.i32[1] = a5.i32[1],
        v22.i32[0] = vextq_s8((int8x16_t)a5, (int8x16_t)a5, 8uLL).u32[0],
        int8x8_t v23 = vmvn_s8((int8x8_t)vceq_f32(vabs_f32(v22), (float32x2_t)vdup_n_s32(0x7F800000u))),
        (v23.i8[4] & 1) != 0)
    || (v23.i8[0] & 1) != 0)
  {
    float32x4_t v41 = vnegq_f32(a5);
    float32x4_t v40 = vaddq_f32(a5, a5);
    int v25 = 100;
    while (1)
    {
      int v26 = rand();
      *(float32x2_t *)v27.f32 = vcvt_f32_s32((int32x2_t)__PAIR64__(rand(), v26));
      float32x4_t v46 = v27;
      int v28 = rand();
      float32x4_t v29 = v46;
      v29.f32[2] = (float)v28;
      v30.i64[0] = 0x3000000030000000;
      v30.i64[1] = 0x3000000030000000;
      float32x4_t v31 = vmlaq_f32(v41, v40, vmulq_f32(v29, v30));
      v30.i64[0] = 0x3F0000003F000000;
      v30.i64[1] = 0x3F0000003F000000;
      float32x4_t v32 = vmulq_f32(v31, v30);
      float32x4_t v33 = vaddq_f32(a4, vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a1, v32.f32[0]), a2, *(float32x2_t *)v32.f32, 1), a3, v32, 2));
      float32x4_t v34 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a17, v33.f32[0]), a18, *(float32x2_t *)v33.f32, 1), a19, v33, 2), a20, v33, 3);
      float32x4_t v35 = vdivq_f32(v34, (float32x4_t)vdupq_laneq_s32((int32x4_t)v34, 3));
      if (v35.f32[2] < 0.0)
      {
        int32x4_t v36 = (int32x4_t)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a21, v35.f32[0]), a22, *(float32x2_t *)v35.f32, 1), a23, v35, 2);
        float32x2_t v37 = vdiv_f32(*(float32x2_t *)v36.i8, (float32x2_t)vdup_laneq_s32(v36, 2));
        if (v37.f32[0] >= 0.0 && v37.f32[0] < a24 && v37.f32[1] >= 0.0 && v37.f32[1] < a25) {
          break;
        }
      }
      if (!--v25) {
        return 0;
      }
    }
  }
  return 1;
}

double ARRandomBoxPointInWorldCoordinates(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5)
{
  int v5 = rand();
  *(float32x2_t *)v6.f32 = vcvt_f32_s32((int32x2_t)__PAIR64__(rand(), v5));
  float32x4_t v13 = v6;
  int v7 = rand();
  float32x4_t v8 = v13;
  v8.f32[2] = (float)v7;
  v9.i64[0] = 0x3000000030000000;
  v9.i64[1] = 0x3000000030000000;
  float32x4_t v10 = vmlaq_f32(vnegq_f32(a5), vaddq_f32(a5, a5), vmulq_f32(v8, v9));
  v9.i64[0] = 0x3F0000003F000000;
  v9.i64[1] = 0x3F0000003F000000;
  float32x4_t v11 = vmulq_f32(v10, v9);
  *(void *)&double result = vaddq_f32(a4, vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a1, v11.f32[0]), a2, *(float32x2_t *)v11.f32, 1), a3, v11, 2)).u64[0];
  return result;
}

void ARLogErrorNoClassLongMessage(void *a1, void *a2)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (ARLogErrorNoClassLongMessage_onceToken != -1) {
    dispatch_once(&ARLogErrorNoClassLongMessage_onceToken, &__block_literal_global_100);
  }
  float v20 = v3;
  int v5 = [v3 componentsSeparatedByCharactersInSet:ARLogErrorNoClassLongMessage_newLineCharacterSet];
  uint64_t v19 = v4;
  if (v4)
  {
    float32x4_t v6 = [NSString stringWithFormat:@"%@ ", v4, v4];
  }
  else
  {
    float32x4_t v6 = &stru_1F120C8F0;
  }
  uint64_t v7 = [(__CFString *)v6 length];
  if ((unint64_t)[v5 count] >= 2)
  {
    float32x4_t v8 = _ARLogGeneral_35();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)vImage_Buffer buf = 138543362;
      float32x4_t v29 = v6;
      _os_log_impl(&dword_1B88A2000, v8, OS_LOG_TYPE_ERROR, "%{public}@START", buf, 0xCu);
    }
  }
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  obuint64_t j = v5;
  uint64_t v23 = [obj countByEnumeratingWithState:&v24 objects:v32 count:16];
  if (v23)
  {
    unint64_t v9 = 1000 - v7;
    uint64_t v22 = *(void *)v25;
    do
    {
      for (uint64_t i = 0; i != v23; ++i)
      {
        if (*(void *)v25 != v22) {
          objc_enumerationMutation(obj);
        }
        float32x4_t v11 = *(void **)(*((void *)&v24 + 1) + 8 * i);
        if (v9 >= [v11 length])
        {
          uint64_t v12 = 0;
        }
        else
        {
          uint64_t v12 = 0;
          LODWORD(v13) = v9;
          do
          {
            uint64_t v14 = _ARLogGeneral_35();
            if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
            {
              uint64_t v15 = objc_msgSend(v11, "substringWithRange:", v12, v9);
              *(_DWORD *)vImage_Buffer buf = 138543618;
              float32x4_t v29 = v6;
              __int16 v30 = 2114;
              float32x4_t v31 = v15;
              _os_log_impl(&dword_1B88A2000, v14, OS_LOG_TYPE_ERROR, "%{public}@%{public}@", buf, 0x16u);
            }
            uint64_t v12 = (int)v13;
            unint64_t v13 = v9 + (int)v13;
          }
          while (v13 < [v11 length]);
        }
        uint64_t v16 = _ARLogGeneral_35();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          uint64_t v17 = [v11 substringFromIndex:v12];
          *(_DWORD *)vImage_Buffer buf = 138543618;
          float32x4_t v29 = v6;
          __int16 v30 = 2114;
          float32x4_t v31 = v17;
          _os_log_impl(&dword_1B88A2000, v16, OS_LOG_TYPE_ERROR, "%{public}@%{public}@", buf, 0x16u);
        }
      }
      uint64_t v23 = [obj countByEnumeratingWithState:&v24 objects:v32 count:16];
    }
    while (v23);
  }

  if ((unint64_t)[obj count] >= 2)
  {
    uint64_t v18 = _ARLogGeneral_35();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)vImage_Buffer buf = 138543362;
      float32x4_t v29 = v6;
      _os_log_impl(&dword_1B88A2000, v18, OS_LOG_TYPE_ERROR, "%{public}@END", buf, 0xCu);
    }
  }
}

void __ARLogErrorNoClassLongMessage_block_invoke()
{
  uint64_t v0 = [MEMORY[0x1E4F28B88] newlineCharacterSet];
  uint64_t v1 = (void *)ARLogErrorNoClassLongMessage_newLineCharacterSet;
  ARLogErrorNoClassLongMessage_newLineCharacterSet = v0;
}

void ARLogDebugNoClassLongMessage(void *a1, void *a2)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (ARLogDebugNoClassLongMessage_onceToken != -1) {
    dispatch_once(&ARLogDebugNoClassLongMessage_onceToken, &__block_literal_global_7_0);
  }
  float v20 = v3;
  int v5 = [v3 componentsSeparatedByCharactersInSet:ARLogDebugNoClassLongMessage_newLineCharacterSet];
  uint64_t v19 = v4;
  if (v4)
  {
    float32x4_t v6 = [NSString stringWithFormat:@"%@ ", v4, v4];
  }
  else
  {
    float32x4_t v6 = &stru_1F120C8F0;
  }
  uint64_t v7 = [(__CFString *)v6 length];
  if ((unint64_t)[v5 count] >= 2)
  {
    float32x4_t v8 = _ARLogGeneral_35();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)vImage_Buffer buf = 138543362;
      float32x4_t v29 = v6;
      _os_log_impl(&dword_1B88A2000, v8, OS_LOG_TYPE_DEBUG, "%{public}@START", buf, 0xCu);
    }
  }
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  obuint64_t j = v5;
  uint64_t v23 = [obj countByEnumeratingWithState:&v24 objects:v32 count:16];
  if (v23)
  {
    unint64_t v9 = 1000 - v7;
    uint64_t v22 = *(void *)v25;
    do
    {
      for (uint64_t i = 0; i != v23; ++i)
      {
        if (*(void *)v25 != v22) {
          objc_enumerationMutation(obj);
        }
        float32x4_t v11 = *(void **)(*((void *)&v24 + 1) + 8 * i);
        if (v9 >= [v11 length])
        {
          uint64_t v12 = 0;
        }
        else
        {
          uint64_t v12 = 0;
          LODWORD(v13) = v9;
          do
          {
            uint64_t v14 = _ARLogGeneral_35();
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v15 = objc_msgSend(v11, "substringWithRange:", v12, v9);
              *(_DWORD *)vImage_Buffer buf = 138543618;
              float32x4_t v29 = v6;
              __int16 v30 = 2114;
              float32x4_t v31 = v15;
              _os_log_impl(&dword_1B88A2000, v14, OS_LOG_TYPE_DEBUG, "%{public}@%{public}@", buf, 0x16u);
            }
            uint64_t v12 = (int)v13;
            unint64_t v13 = v9 + (int)v13;
          }
          while (v13 < [v11 length]);
        }
        uint64_t v16 = _ARLogGeneral_35();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v17 = [v11 substringFromIndex:v12];
          *(_DWORD *)vImage_Buffer buf = 138543618;
          float32x4_t v29 = v6;
          __int16 v30 = 2114;
          float32x4_t v31 = v17;
          _os_log_impl(&dword_1B88A2000, v16, OS_LOG_TYPE_DEBUG, "%{public}@%{public}@", buf, 0x16u);
        }
      }
      uint64_t v23 = [obj countByEnumeratingWithState:&v24 objects:v32 count:16];
    }
    while (v23);
  }

  if ((unint64_t)[obj count] >= 2)
  {
    uint64_t v18 = _ARLogGeneral_35();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)vImage_Buffer buf = 138543362;
      float32x4_t v29 = v6;
      _os_log_impl(&dword_1B88A2000, v18, OS_LOG_TYPE_DEBUG, "%{public}@END", buf, 0xCu);
    }
  }
}

void __ARLogDebugNoClassLongMessage_block_invoke()
{
  uint64_t v0 = [MEMORY[0x1E4F28B88] newlineCharacterSet];
  uint64_t v1 = (void *)ARLogDebugNoClassLongMessage_newLineCharacterSet;
  ARLogDebugNoClassLongMessage_newLineCharacterSet = v0;
}

id ARSphericalHarmonicsDataWithCoefficients(uint64_t a1, float32x4_t a2, float32x4_t a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (a2.f32[0] <= 0.0)
  {
    float32x4_t v6 = (float32x4_t)xmmword_1B8A2B0C0;
  }
  else
  {
    a3.i32[0] = 1170939904;
    int8x16_t v3 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vcgeq_f32(a3, a2)), 0);
    float32x4_t v4 = vaddq_f32((float32x4_t)vbslq_s8(v3, (int8x16_t)xmmword_1B8A569B0, (int8x16_t)xmmword_1B8A569A0), vdivq_f32((float32x4_t)vbslq_s8(v3, (int8x16_t)xmmword_1B8A569D0, (int8x16_t)xmmword_1B8A569C0), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.f32, 0), (float32x4_t)vbslq_s8(v3, (int8x16_t)xmmword_1B8A569F0, (int8x16_t)xmmword_1B8A569E0))));
    v4.i32[3] = 0;
    float32x4_t v5 = vmaxnmq_f32(v4, (float32x4_t)0);
    v5.i32[3] = 0;
    float32x4_t v6 = vminnmq_f32(v5, (float32x4_t)xmmword_1B8A56A00);
  }
  uint64_t v7 = 0;
  memset(v12, 0, 108);
  do
  {
    float v8 = *(float *)(a1 + v7);
    unint64_t v9 = (float *)((char *)v12 + v7);
    float *v9 = v6.f32[0] * v8;
    v9[9] = v6.f32[1] * v8;
    v9[18] = v6.f32[2] * v8;
    v7 += 4;
  }
  while (v7 != 36);
  float32x4_t v10 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v12 length:108];
  return v10;
}

double ARCCT2RGB(float32x4_t a1, float32x4_t a2)
{
  if (a1.f32[0] <= 0.0)
  {
    *(void *)&double result = 1065353216;
  }
  else
  {
    a2.i32[0] = 1170939904;
    int8x16_t v2 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vcgeq_f32(a2, a1)), 0);
    float32x4_t v3 = vaddq_f32((float32x4_t)vbslq_s8(v2, (int8x16_t)xmmword_1B8A569B0, (int8x16_t)xmmword_1B8A569A0), vdivq_f32((float32x4_t)vbslq_s8(v2, (int8x16_t)xmmword_1B8A569D0, (int8x16_t)xmmword_1B8A569C0), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a1.f32, 0), (float32x4_t)vbslq_s8(v2, (int8x16_t)xmmword_1B8A569F0, (int8x16_t)xmmword_1B8A569E0))));
    v3.i32[3] = 0;
    float32x4_t v4 = vmaxnmq_f32(v3, (float32x4_t)0);
    v4.i32[3] = 0;
    *(void *)&double result = vminnmq_f32(v4, (float32x4_t)xmmword_1B8A56A00).u64[0];
  }
  return result;
}

float32_t ARPrimaryLightFromSphericalHarmonics@<S0>(uint64_t a1@<X0>, float32x4_t *a2@<X8>, float a3@<S0>, float32x4_t a4@<Q1>)
{
  a4.i32[0] = *(_DWORD *)(a1 + 12);
  a4.i32[1] = *(_DWORD *)(a1 + 4);
  float32x4_t v4 = vnegq_f32(a4);
  v4.i32[2] = *(_DWORD *)(a1 + 8);
  float32x4_t v5 = vmulq_f32(v4, v4);
  LODWORD(v6) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1))).u32[0];
  if (sqrtf(v6) >= 0.00001)
  {
    uint64_t v8 = 0;
    float v9 = v6;
    float32x2_t v10 = vrsqrte_f32((float32x2_t)LODWORD(v6));
    float32x2_t v11 = vmul_f32(v10, vrsqrts_f32((float32x2_t)LODWORD(v9), vmul_f32(v10, v10)));
    _Q1 = vmulq_n_f32(v4, vmul_f32(v11, vrsqrts_f32((float32x2_t)LODWORD(v9), vmul_f32(v11, v11))).f32[0]);
    int v25 = 1049652922;
    float32x4_t v13 = (float32x4_t)vextq_s8((int8x16_t)_Q1, (int8x16_t)_Q1, 4uLL);
    v13.i32[2] = _Q1.i32[0];
    *a2 = _Q1;
    _Q6.i64[0] = 0x3EFA2A1BBEFA2A1BLL;
    _Q6.i32[2] = -1090901477;
    _Q6.i32[3] = vmuls_lane_f32(1.0925, *(float32x2_t *)_Q1.f32, 1);
    float32x4_t v26 = vmulq_f32(v13, _Q6);
    _S5 = vmuls_lane_f32(3.0, _Q1, 2);
    __asm { FMLA            S6, S5, V1.S[2] }
    float v27 = vmuls_lane_f32(vmuls_lane_f32(-1.0925, *(float32x2_t *)_Q1.f32, 1), _Q1, 2);
    float v28 = _Q6.f32[0] * 0.31539;
    float v29 = vmuls_lane_f32(-1.0925 * _Q1.f32[0], _Q1, 2);
    float v30 = vmlas_n_f32(vmuls_lane_f32(-_Q1.f32[1], *(float32x2_t *)_Q1.f32, 1), _Q1.f32[0], _Q1.f32[0]) * 0.54627;
    float v20 = 0.0;
    do
    {
      float v20 = v20 + (float)(*(float *)(a1 + v8) * *(float *)((char *)&v25 + v8));
      v8 += 4;
    }
    while (v8 != 36);
    double v21 = (float)(v20 * 867.0) / 992.743279;
    if (v21 < 0.0) {
      double v21 = 0.0;
    }
    float v22 = v21;
    float v23 = (float)((float)(*(float *)a1 + (float)((float)((float)(v22 * -8.0) * 1.7725) / 17.0)) * 1.7725) * 0.5;
    if (v23 < 0.0) {
      float v23 = 0.0;
    }
    float32_t v24 = v23 * a3;
    float32_t result = v22 * a3;
    a2[1].f32[0] = result;
    a2[1].f32[1] = v24;
  }
  else
  {
    *a2 = (float32x4_t)xmmword_1B8A2B270;
    float32_t result = *(float *)a1 * a3;
    a2[1].f32[1] = result;
    a2[1].i32[0] = 0;
  }
  return result;
}

float ARSphericalHarmonicsWithDirection@<S0>(uint64_t a1@<X8>, int8x16_t _Q0@<Q0>)
{
  *(_DWORD *)a1 = 1049652922;
  float32x4_t v2 = (float32x4_t)vextq_s8(_Q0, _Q0, 4uLL);
  v2.i32[2] = _Q0.i32[0];
  _Q5.i64[0] = 0x3EFA2A1BBEFA2A1BLL;
  _Q5.i32[2] = -1090901477;
  _Q5.i32[3] = vmuls_lane_f32(1.0925, *(float32x2_t *)_Q0.i8, 1);
  *(float32x4_t *)(a1 + 4) = vmulq_f32(v2, _Q5);
  _S4 = vmuls_lane_f32(3.0, (float32x4_t)_Q0, 2);
  __asm { FMLA            S5, S4, V0.S[2] }
  *(float *)(a1 + 20) = vmuls_lane_f32(vmuls_lane_f32(-1.0925, *(float32x2_t *)_Q0.i8, 1), (float32x4_t)_Q0, 2);
  *(float *)(a1 + 24) = _Q5.f32[0] * 0.31539;
  float v9 = vmuls_lane_f32(-1.0925 * *(float *)_Q0.i32, (float32x4_t)_Q0, 2);
  float result = vmlas_n_f32(vmuls_lane_f32(-*(float *)&_Q0.i32[1], *(float32x2_t *)_Q0.i8, 1), *(float *)_Q0.i32, *(float *)_Q0.i32)* 0.54627;
  *(float *)(a1 + 2_Block_object_dispose(&STACK[0x400], 8) = v9;
  *(float *)(a1 + 32) = result;
  return result;
}

float ARSphericalHarmonicsDotProduct(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 0;
  float result = 0.0;
  do
  {
    float result = result + (float)(*(float *)(a1 + v2) * *(float *)(a2 + v2));
    v2 += 4;
  }
  while (v2 != 36);
  return result;
}

double ARSphericalHarmonicsByFlippingZAxis@<D0>(long long *a1@<X0>, uint64_t a2@<X8>)
{
  int v10 = 0;
  long long v8 = 0u;
  long long v9 = 0u;
  if (&v8 != a1)
  {
    long long v3 = a1[1];
    long long v8 = *a1;
    long long v9 = v3;
    int v10 = *((_DWORD *)a1 + 8);
  }
  arkit::shct::flipAxesShCoeff((uint64_t)&v8, 0, 0, 1, (uint64_t)v6);
  double result = *(double *)v6;
  long long v5 = v6[1];
  *(_OWORD *)a2 = v6[0];
  *(_OWORD *)(a2 + 16) = v5;
  *(_DWORD *)(a2 + 32) = v7;
  return result;
}

double ARSphericalHarmonicsByApplyingRotation@<D0>(long long *a1@<X0>, uint64_t a2@<X8>, simd_float3x3 a3@<0:Q0, 16:Q1, 32:Q2>)
{
  int v12 = 0;
  long long v10 = 0u;
  long long v11 = 0u;
  if (&v10 != a1)
  {
    long long v4 = a1[1];
    long long v10 = *a1;
    long long v11 = v4;
    int v12 = *((_DWORD *)a1 + 8);
  }
  ARCVAMatrixFromMatrix(a3, (uint64_t)v9);
  arkit::shct::rotateShCoeff((uint64_t)&v10, v9, (uint64_t)v7);
  double result = *(double *)v7;
  long long v6 = v7[1];
  *(_OWORD *)a2 = v7[0];
  *(_OWORD *)(a2 + 16) = v6;
  *(_DWORD *)(a2 + 32) = v8;
  return result;
}

id ARSphericalHarmonicsDataWithAmbientLight(float a1, float32x4_t a2, double a3, float32x4_t a4)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v17 = 0;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  if (a2.f32[0] <= 0.0)
  {
    float32x4_t v7 = (float32x4_t)xmmword_1B8A2B0C0;
  }
  else
  {
    a4.i32[0] = 1170939904;
    int8x16_t v4 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vcgeq_f32(a4, a2)), 0);
    float32x4_t v5 = vaddq_f32((float32x4_t)vbslq_s8(v4, (int8x16_t)xmmword_1B8A569B0, (int8x16_t)xmmword_1B8A569A0), vdivq_f32((float32x4_t)vbslq_s8(v4, (int8x16_t)xmmword_1B8A569D0, (int8x16_t)xmmword_1B8A569C0), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.f32, 0), (float32x4_t)vbslq_s8(v4, (int8x16_t)xmmword_1B8A569F0, (int8x16_t)xmmword_1B8A569E0))));
    v5.i32[3] = 0;
    float32x4_t v6 = vmaxnmq_f32(v5, (float32x4_t)0);
    v6.i32[3] = 0;
    float32x4_t v7 = vminnmq_f32(v6, (float32x4_t)xmmword_1B8A56A00);
  }
  float v10 = a1 * v7.f32[0];
  LODWORD(v13) = vmuls_lane_f32(a1, *(float32x2_t *)v7.f32, 1);
  DWORD1(v15) = vmuls_lane_f32(a1, v7, 2);
  int v8 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&v10 length:108];
  return v8;
}

id _ARLogSensor_9()
{
  if (_ARLogSensor_onceToken_14 != -1) {
    dispatch_once(&_ARLogSensor_onceToken_14, &__block_literal_global_520);
  }
  uint64_t v0 = (void *)_ARLogSensor_logObj_14;
  return v0;
}

void sub_1B89D1C20(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12, long long buf, int a14, __int16 a15, __int16 a16, id a17, long long a18)
{
  if (a2 == 1)
  {
    id v21 = objc_begin_catch(a1);
    float v22 = _ARLogSensor_9();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      float v23 = (objc_class *)objc_opt_class();
      NSStringFromClass(v23);
      id v20 = (id)objc_claimAutoreleasedReturnValue();
      id v24 = [v18 logPrefix];
      int v25 = [v21 reason];
      LODWORD(buf) = 138544130;
      *(void *)((char *)&buf + 4) = v20;
      WORD6(buf) = 2048;
      *(void *)((char *)&buf + 14) = v18;
      a16 = 2112;
      a17 = v24;
      LOWORD(a1_Block_object_dispose(&STACK[0x400], 8) = 2112;
      *(void *)((char *)&a18 + 2) = v25;
      _os_log_impl(&dword_1B88A2000, v22, OS_LOG_TYPE_ERROR, "%{public}@ <%p>: %@ Unable to set capture device active format: %@", (uint8_t *)&buf, 0x2Au);
    }
    float32x4_t v26 = [v21 reason];
    if (v26)
    {
      a11 = *MEMORY[0x1E4F28588];
      id v20 = [v21 reason];
      a12 = v20;
      float v27 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&a12 forKeys:&a11 count:1];
    }
    else
    {
      float v27 = (void *)MEMORY[0x1E4F1CC08];
    }
    ARErrorWithCodeAndUserInfo(102, v27);
    objc_claimAutoreleasedReturnValue();

    if (v26)
    {
    }
    objc_end_catch();
    JUMPOUT(0x1B89D1BBCLL);
  }
  _Unwind_Resume(a1);
}

void sub_1B89D213C(_Unwind_Exception *exception_object, int a2)
{
  if (a2 == 1)
  {
    id v5 = objc_begin_catch(exception_object);
    float32x4_t v6 = _ARLogSensor_9();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      float32x4_t v7 = (objc_class *)objc_opt_class();
      NSStringFromClass(v7);
      id v8 = (id)objc_claimAutoreleasedReturnValue();
      id v9 = [v2 logPrefix];
      float v10 = [v5 reason];
      *(_DWORD *)(v3 - 144) = 138544386;
      uint64_t v11 = v3 - 144;
      *(void *)(v11 + 4) = v8;
      *(_WORD *)(v3 - 132) = 2048;
      *(void *)(v11 + 14) = v2;
      *(_WORD *)(v3 - 122) = 2112;
      *(void *)(v3 - 120) = v9;
      *(_WORD *)(v3 - 112) = 2048;
      *(void *)(v11 + 34) = v4;
      *(_WORD *)(v3 - 102) = 2112;
      *(void *)(v11 + 44) = v10;
      _os_log_impl(&dword_1B88A2000, v6, OS_LOG_TYPE_ERROR, "%{public}@ <%p>: %@ Unable to set image sensor depth rate to %f: %@", (uint8_t *)(v3 - 144), 0x34u);
    }
    objc_end_catch();
    JUMPOUT(0x1B89D20FCLL);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B89D2AEC(_Unwind_Exception *a1)
{
}

void sub_1B89D3018(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, long long location, int a16, __int16 a17, __int16 a18, id a19, __n128 a20,__n128 a21,uint64_t a22,long long a23)
{
  objc_destroyWeak(v25);
  objc_destroyWeak((id *)&location);
  if (a2 == 1)
  {
    id v31 = objc_begin_catch(a1);
    float32x4_t v32 = _ARLogSensor_9();
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      uint64_t v33 = (objc_class *)objc_opt_class();
      NSStringFromClass(v33);
      id v34 = (id)objc_claimAutoreleasedReturnValue();
      id v35 = [v24 logPrefix];
      [v23 maxWhiteBalanceGain];
      float v37 = v36;
      float32x4_t v38 = [v31 reason];
      LODWORD(location) = 138545154;
      *(void *)((char *)&location + 4) = v34;
      WORD6(location) = 2048;
      *(void *)((char *)&location + 14) = v24;
      a18 = 2112;
      a19 = v35;
      a20.n128_u16[0] = 2048;
      *(double *)((char *)a20.n128_f64 + 2) = v26;
      a20.n128_u16[5] = 2048;
      *(double *)((char *)&a20.n128_f64[1] + 4) = v27;
      a21.n128_u16[2] = 2048;
      *(double *)((char *)a21.n128_f64 + 6) = v28;
      a21.n128_u16[7] = 2048;
      *(double *)&a22 = v37;
      LOWORD(a23) = 2112;
      *(void *)((char *)&a23 + 2) = v38;
      _os_log_impl(&dword_1B88A2000, v32, OS_LOG_TYPE_ERROR, "%{public}@ <%p>: %@ Unable to set custom white balance gains %.2f, %.2f, %.2f, valid range is [1.0-%.1f] : %@", (uint8_t *)&location, 0x52u);
    }
    objc_end_catch();
    JUMPOUT(0x1B89D2F18);
  }
  _Unwind_Resume(a1);
}

void sub_1B89D3840(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location, id a18, long long buf, int a20,__int16 a21,__int16 a22,id a23,long long a24)
{
  objc_destroyWeak(v26);
  objc_destroyWeak(v25);
  objc_destroyWeak(&location);
  objc_destroyWeak(&a18);
  if (a2 == 1)
  {
    id v29 = objc_begin_catch(a1);
    float v30 = _ARLogSensor_9();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      id v31 = (objc_class *)objc_opt_class();
      NSStringFromClass(v31);
      id v32 = (id)objc_claimAutoreleasedReturnValue();
      id v33 = [v24 logPrefix];
      id v34 = [v29 reason];
      LODWORD(buf) = 138544130;
      *(void *)((char *)&buf + 4) = v32;
      WORD6(buf) = 2048;
      *(void *)((char *)&buf + 14) = v24;
      a22 = 2112;
      a23 = v33;
      LOWORD(a24) = 2112;
      *(void *)((char *)&a24 + 2) = v34;
      _os_log_impl(&dword_1B88A2000, v30, OS_LOG_TYPE_ERROR, "%{public}@ <%p>: %@ Unable to set fixed lens position: %@", (uint8_t *)&buf, 0x2Au);
    }
    objc_end_catch();
    JUMPOUT(0x1B89D37FCLL);
  }
  _Unwind_Resume(a1);
}

void sub_1B89D4E8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,int buf,int a30,int a31,__int16 a32,int a33,__int16 a34,__int16 a35,uint64_t a36,__int16 a37)
{
  if (a2 == 1)
  {
    id v40 = objc_begin_catch(exception_object);
    float32x4_t v41 = _ARLogSensor_9();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
    {
      unsigned __int32 v42 = (objc_class *)objc_opt_class();
      NSStringFromClass(v42);
      id v38 = (id)objc_claimAutoreleasedReturnValue();
      id v43 = [v37 logPrefix];
      float32x2_t v44 = [v40 reason];
      vImage_Buffer buf = 138544130;
      *(void *)(v39 + 4) = v38;
      a32 = 2048;
      *(void *)(v39 + 14) = v37;
      a35 = 2112;
      a36 = (uint64_t)v43;
      a37 = 2112;
      *(void *)(v39 + 34) = v44;
      _os_log_impl(&dword_1B88A2000, v41, OS_LOG_TYPE_ERROR, "%{public}@ <%p>: %@ Unable to setup vision data parameters: %@", (uint8_t *)&buf, 0x2Au);
    }
    simd_float3x3 v45 = [v40 reason];
    if (v45)
    {
      a27 = *MEMORY[0x1E4F28588];
      id v38 = [v40 reason];
      a28 = (uint64_t)v38;
      float32x4_t v46 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&a28 forKeys:&a27 count:1];
    }
    else
    {
      float32x4_t v46 = (void *)MEMORY[0x1E4F1CC08];
    }
    ARErrorWithCodeAndUserInfo(102, v46);
    objc_claimAutoreleasedReturnValue();
    if (v45)
    {
    }
    objc_end_catch();
    JUMPOUT(0x1B89D44CCLL);
  }
  _Unwind_Resume(exception_object);
}

__CFString *NSStringFromMagneticFieldCalibrationAccuracy(int a1)
{
  if ((a1 + 1) > 3) {
    return &stru_1F120C8F0;
  }
  else {
    return off_1E6187F88[a1 + 1];
  }
}

id NSStringFromAttitudeReferenceFrame(char a1)
{
  uint64_t v2 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v3 = v2;
  if (a1)
  {
    [v2 addObject:@"XArbitraryZVertical"];
    if ((a1 & 2) == 0)
    {
LABEL_3:
      if ((a1 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_11;
    }
  }
  else if ((a1 & 2) == 0)
  {
    goto LABEL_3;
  }
  [v3 addObject:@"XArbitraryCorrectedZVertical"];
  if ((a1 & 4) == 0)
  {
LABEL_4:
    if ((a1 & 8) == 0) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
LABEL_11:
  [v3 addObject:@"XMagneticNorthZVertical"];
  if ((a1 & 8) != 0) {
LABEL_5:
  }
    [v3 addObject:@"XTrueNorthZVertical"];
LABEL_6:
  uint64_t v4 = [v3 componentsJoinedByString:@" | "];

  return v4;
}

id _ARLogSensor_10()
{
  if (_ARLogSensor_onceToken_15 != -1) {
    dispatch_once(&_ARLogSensor_onceToken_15, &__block_literal_global_102);
  }
  uint64_t v0 = (void *)_ARLogSensor_logObj_15;
  return v0;
}

void sub_1B89D787C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B89D79E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

id _ARLogSensor_11()
{
  if (_ARLogSensor_onceToken_16 != -1) {
    dispatch_once(&_ARLogSensor_onceToken_16, &__block_literal_global_451);
  }
  uint64_t v0 = (void *)_ARLogSensor_logObj_16;
  return v0;
}

void sub_1B89E0980(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1B89E0A98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89E0B0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89E1568(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20,void *a21,void *a22,void *a23,void *a24,void *a25,void *a26,void *a27,void *a28,void *a29,void *a30,void *a31,void *a32,void *a33,void *a34,void *a35,void *a36,void *a37,void *a38,void *a39,void *a40,void *a41,void *a42,void *a43,void *a44,void *a45,void *a46,void *a47,void *a48,void *a49,void *a50,void *a51,void *a52)
{
  _Unwind_Resume(a1);
}

void sub_1B89E19B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1B89E1A54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B89E1B74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89E1C5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89E1E58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89E1F24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL26ARFaceAnchorInitializeMapsv_block_invoke()
{
  if (+[ARFaceTrackingInternalTechnique isSupported])
  {
    uint64_t v12 = 0;
    CVAFaceTrackingCopySemantics();
    uint64_t v0 = objc_opt_new();
    uint64_t v1 = objc_opt_new();
    uint64_t v2 = [0 objectForKeyedSubscript:*MEMORY[0x1E4F4D6D8]];
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 3221225472;
    void v9[2] = ___ZL26ARFaceAnchorInitializeMapsv_block_invoke_2;
    v9[3] = &unk_1E6188330;
    id v3 = v0;
    id v10 = v3;
    id v4 = v1;
    id v11 = v4;
    [v2 enumerateObjectsUsingBlock:v9];
    id v5 = (void *)_blendShapeLocationToIndexMap;
    _blendShapeLocationToIndexMap = (uint64_t)v3;
    id v6 = v3;

    float32x4_t v7 = (void *)_indexToBlendShapeLocationMap;
    _indexToBlendShapeLocationMap = (uint64_t)v4;
    id v8 = v4;
  }
}

void sub_1B89E2164(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

void ___ZL26ARFaceAnchorInitializeMapsv_block_invoke_2(uint64_t a1, void *a2, uint64_t a3)
{
  id v8 = a2;
  id v5 = [NSNumber numberWithUnsignedInteger:a3];
  [*(id *)(a1 + 32) setObject:v5 forKeyedSubscript:v8];

  id v6 = *(void **)(a1 + 40);
  float32x4_t v7 = [NSNumber numberWithUnsignedInteger:a3];
  [v6 setObject:v8 forKeyedSubscript:v7];
}

void sub_1B89E2250(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void ___ZL13_ARLogGeneralv_block_invoke_24()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "General");
  uint64_t v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObuint64_t j = (uint64_t)v0;
}

uint64_t arkit::Random::seedFromCurrentTime(arkit::Random *this)
{
  uint64_t v1 = [MEMORY[0x1E4F28F80] processInfo];
  [v1 systemUptime];
  uint64_t v3 = ((int)(uint64_t)(v2 * 1000000000.0) / 1000000);

  return v3;
}

void sub_1B89E4AA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

int *arkit::Random::globalSeed(arkit::Random *this)
{
  {
    if (v2)
    {
      arkit::Random::globalSeed(void)::s_seed = arkit::Random::seedFromCurrentTime(v2);
    }
  }
  return &arkit::Random::globalSeed(void)::s_seed;
}

void sub_1B89E4B18(_Unwind_Exception *a1)
{
}

void arkit::runSolver(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int v5 = *(unsigned __int8 *)(a2 + 8);
  unint64_t v6 = *(int *)(a2 + 12);
  unint64_t v7 = (a1[1] - *a1) >> 5;
  unint64_t v27 = v7;
  unint64_t v28 = v6;
  id v24 = 0;
  int v25 = 0;
  uint64_t v26 = 0;
  if (v5 && v7 > v6)
  {
    kdebug_trace();
    id v21 = 0;
    float v22 = 0;
    uint64_t v23 = 0;
    LODWORD(v_Block_object_dispose(&STACK[0x400], 8) = -1;
    for (int i = 1; i != 33; ++i)
    {
      arkit::Random::sampleNumbers<unsigned long>((arkit::Random *)&v27, &v28, v20);
      arkit::FaceLightOptimizer::compute(a1, v20, (uint64_t)v17);
      std::vector<unsigned long>::__assign_with_size[abi:ne180100]<unsigned long *,unsigned long *>((char *)&v21, (char *)__p, (uint64_t)v19, (v19 - (unsigned char *)__p) >> 3);
      unint64_t v10 = (v22 - v21) >> 3;
      BOOL v11 = 1;
      if ((int)v8 < (int)v10)
      {
        std::vector<unsigned long>::__assign_with_size[abi:ne180100]<unsigned long *,unsigned long *>((char *)&v24, v21, (uint64_t)v22, v10);
        unint64_t v8 = (unint64_t)(v22 - v21) >> 3;
        if ((float)((float)v27 * 0.9) < (float)(int)v8) {
          BOOL v11 = 0;
        }
      }
      if (__p)
      {
        uint64_t v19 = __p;
        operator delete(__p);
      }
      if (v20[0])
      {
        v20[1] = v20[0];
        operator delete(v20[0]);
      }
      if (!v11) {
        break;
      }
    }
    kdebug_trace();
    uint64_t v12 = v21;
    if (v21)
    {
      float v22 = v21;
LABEL_23:
      operator delete(v12);
    }
  }
  else
  {
    std::vector<unsigned long long>::resize((uint64_t)&v24, v7);
    long long v13 = v24;
    long long v14 = v25;
    if (v24 != v25)
    {
      uint64_t v15 = 0;
      do
        *v13++ = v15++;
      while (v13 != v14);
    }
    arkit::FaceLightOptimizer::compute(a1, &v24, (uint64_t)v17);
    long long v16 = __p;
    if ((unint64_t)(v19 - (unsigned char *)__p) >= 0x41)
    {
      std::vector<unsigned long>::__assign_with_size[abi:ne180100]<unsigned long *,unsigned long *>((char *)&v24, (char *)__p, (uint64_t)v19, (v19 - (unsigned char *)__p) >> 3);
      long long v16 = __p;
    }
    if (v16)
    {
      uint64_t v19 = v16;
      uint64_t v12 = v16;
      goto LABEL_23;
    }
  }
  arkit::FaceLightOptimizer::compute(a1, &v24, a3);
  if (v24)
  {
    int v25 = v24;
    operator delete(v24);
  }
}

void sub_1B89E4D70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25)
{
  if (__p) {
    operator delete(__p);
  }
  if (a24) {
    operator delete(a24);
  }
  _Unwind_Resume(exception_object);
}

arkit::Random *arkit::Random::sampleNumbers<unsigned long>@<X0>(arkit::Random *result@<X0>, unint64_t *a2@<X1>, void *a3@<X8>)
{
  unint64_t v5 = *a2;
  unint64_t v6 = *(void *)result;
  if (v5 > *(void *)result || v6 == 0)
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
  }
  else
  {
    unint64_t v8 = (uint64_t *)result;
    if (v5 <= v6 >> 1)
    {
      double result = (arkit::Random *)std::vector<unsigned long>::vector(a3, v5);
      if (*a2)
      {
        unint64_t v9 = 0;
        while (1)
        {
          uint64_t v10 = *v8;
          BOOL v11 = arkit::Random::globalSeed(result);
          double result = (arkit::Random *)rand_r((unsigned int *)v11);
          double v12 = (double)(int)result / 2147483650.0 * (double)(unint64_t)(v10 - 1);
          if (v12 >= 0.0) {
            double v13 = 0.5;
          }
          else {
            double v13 = -0.5;
          }
          unint64_t v14 = (unint64_t)(v12 + v13);
          uint64_t v15 = (void *)a3[1];
          long long v16 = (void *)*a3;
          if ((void *)*a3 != v15)
          {
            while (*v16 != v14)
            {
              if (++v16 == v15)
              {
                long long v16 = (void *)a3[1];
                break;
              }
            }
          }
          if (v16 == v15)
          {
            *(void *)(*a3 + 8 * v9++) = v14;
            if (v9 >= *a2) {
              break;
            }
          }
        }
      }
    }
    else
    {
      return arkit::Random::fisherYatesSample<unsigned long>(result, a2, a3);
    }
  }
  return result;
}

void sub_1B89E4F44(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(&STACK[0x400], 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

arkit::Random *arkit::Random::fisherYatesSample<unsigned long>@<X0>(arkit::Random *result@<X0>, unint64_t *a2@<X1>, void *a3@<X8>)
{
  unint64_t v5 = *a2;
  unint64_t v6 = *(void *)result;
  if (v5 > *(void *)result || v6 == 0)
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
  }
  else
  {
    unint64_t v8 = (uint64_t *)result;
    double result = (arkit::Random *)std::vector<unsigned long>::vector(a3, v6);
    uint64_t v10 = (void *)*a3;
    unint64_t v9 = (void *)a3[1];
    if ((void *)*a3 != v9)
    {
      uint64_t v11 = 0;
      double v12 = (void *)*a3;
      do
        *v12++ = v11++;
      while (v12 != v9);
    }
    unint64_t v13 = *a2;
    if (*a2)
    {
      unint64_t v14 = 0;
      uint64_t v15 = -1;
      do
      {
        uint64_t v16 = *v8;
        uint64_t v17 = arkit::Random::globalSeed(result);
        double result = (arkit::Random *)rand_r((unsigned int *)v17);
        double v18 = (double)(int)result / 2147483650.0 * (double)(unint64_t)(v15 + v16);
        if (v18 >= 0.0) {
          double v19 = 0.5;
        }
        else {
          double v19 = -0.5;
        }
        unint64_t v20 = (unint64_t)(v18 + v19);
        if (v20)
        {
          id v21 = (void *)*a3;
          unint64_t v22 = v14 + v20;
          uint64_t v23 = *(void *)(*a3 + 8 * v14);
          *(void *)(*a3 + 8 * v14) = *(void *)(*a3 + 8 * v22);
          v21[v22] = v23;
        }
        ++v14;
        unint64_t v13 = *a2;
        --v15;
      }
      while (v14 < *a2);
      uint64_t v10 = (void *)*a3;
      unint64_t v9 = (void *)a3[1];
    }
    id v24 = &v10[v13];
    if (v24 != v9) {
      a3[1] = v24;
    }
  }
  return result;
}

void sub_1B89E5090(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(&STACK[0x400], 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<unsigned long>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__vallocate[abi:ne180100](a1, a2);
    id v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_1B89E5108(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(&STACK[0x400], 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<unsigned long>::__assign_with_size[abi:ne180100]<unsigned long *,unsigned long *>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  unint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  unint64_t v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 3)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *unint64_t v7 = 0;
      v7[1] = 0;
      _OWORD v7[2] = 0;
    }
    if (a4 >> 61) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 2;
    if (v8 >> 2 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    double result = std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__vallocate[abi:ne180100](v7, v11);
    unint64_t v13 = (char *)v7[1];
    double v12 = (void **)(v7 + 1);
    unint64_t v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      double v18 = v9;
      double v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  double v12 = (void **)(result + 8);
  unint64_t v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 3;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  uint64_t v16 = &__src[8 * v15];
  if (v14 != v9)
  {
    double result = (char *)memmove(*(void **)result, __src, v14 - v9);
    unint64_t v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    double v18 = v9;
    double v19 = v16;
LABEL_18:
    double result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *double v12 = &v9[v17];
  return result;
}

void sub_1B89E6980(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89E6BB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B89E6C20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B89E6E60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

void sub_1B89E6F40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89E6FA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89E70B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89E7240(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B89E76B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89E7878(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL15_ARLogTechniquev_block_invoke_13()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "Technique");
  uint64_t v1 = (void *)_ARLogTechnique(void)::logObj;
  _ARLogTechnique(void)::logObuint64_t j = (uint64_t)v0;
}

void ___ZL13_ARLogGeneralv_block_invoke_25()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "General");
  uint64_t v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObuint64_t j = (uint64_t)v0;
}

float arkit::mapColorTemperature(arkit *this, float a2)
{
  return fmin(fmax(a2 * 6.86031362 + -6982.00584 + a2 * a2 * -0.00121228514 + pow(a2, 3.0) * 0.0000000714547913, 2000.0), 7000.0);
}

void *arkit::RTFSPContainer::loadRtfsp@<X0>(void *result@<X0>, void *a2@<X8>)
{
  if ((*((unsigned char *)result + *(void *)(*result - 24) + 32) & 1) == 0) {
    operator new();
  }
  *a2 = 0;
  return result;
}

void sub_1B89E8240(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::locale a18)
{
  std::istringstream::~istringstream((uint64_t)&a18);
  if (*(char *)(v19 - 89) < 0) {
    operator delete(*v18);
  }
  _Unwind_Resume(a1);
}

void arkit::RTFSPContainer::~RTFSPContainer(arkit::RTFSPContainer *this)
{
  uint64_t v3 = (void **)((char *)this + 72);
  std::vector<cva::Matrix<float,1u,0u,false>>::__destroy_vector::operator()[abi:ne180100](&v3);
  double v2 = (void *)*((void *)this + 6);
  if (v2)
  {
    *((void *)this + 7) = v2;
    operator delete(v2);
  }
  if (*((char *)this + 47) < 0) {
    operator delete(*((void **)this + 3));
  }
  if (*((char *)this + 23) < 0) {
    operator delete(*(void **)this);
  }
}

void std::vector<int>::resize(std::vector<int> *this, std::vector<int>::size_type __sz)
{
  std::vector<int>::size_type v2 = this->__end_ - this->__begin_;
  if (__sz <= v2)
  {
    if (__sz < v2) {
      this->__end_ = &this->__begin_[__sz];
    }
  }
  else
  {
    std::vector<int>::__append(this, __sz - v2);
  }
}

void std::vector<cva::Matrix<float,1u,0u,false>>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<cva::Matrix<float,1u,0u,false>>::__append(a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *a1 + 24 * a2;
    while (v3 != v7)
    {
      uint64_t v8 = *(void **)(v3 - 24);
      v3 -= 24;
      free(v8);
    }
    a1[1] = v7;
  }
}

void arkit::RTFSPContainer::loadRtfsp(void *a1@<X8>, uint64_t a2@<X0>)
{
  if (*(unsigned char *)(a2 + 24)) {
    arkit::RTFSPContainer::loadRtfsp(a1);
  }
  else {
    arkit::RTFSPContainer::loadRtfspDefault(a1);
  }
}

uint64_t arkit::RTFSPContainer::loadRtfsp@<X0>(void *a1@<X8>)
{
  v5[19] = *MEMORY[0x1E4F143B8];
  std::ifstream::basic_ifstream(v3);
  if (v4[15]) {
    arkit::RTFSPContainer::loadRtfsp(v3, a1);
  }
  else {
    *a1 = 0;
  }
  v3[0] = *MEMORY[0x1E4FBA3F8];
  *(uint64_t *)((char *)v3 + *(void *)(v3[0] - 24)) = *(void *)(MEMORY[0x1E4FBA3F8] + 24);
  MEMORY[0x1BA9C54E0](v4);
  std::istream::~istream();
  return MEMORY[0x1BA9C5670](v5);
}

void sub_1B89E8508(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::ifstream::~ifstream((uint64_t *)va);
  _Unwind_Resume(a1);
}

void arkit::RTFSPContainer::loadRtfspDefault(void *a1@<X8>)
{
  std::string::basic_string[abi:ne180100]<0>(&v6, aDefaultTrained);
  std::istringstream::basic_istringstream[abi:ne180100](v3, &v6, 8);
  arkit::RTFSPContainer::loadRtfsp(v3, a1);
  v3[0] = *MEMORY[0x1E4FBA410];
  *(uint64_t *)((char *)v3 + *(void *)(v3[0] - 24)) = *(void *)(MEMORY[0x1E4FBA410] + 24);
  uint64_t v3[2] = MEMORY[0x1E4FBA470] + 16;
  if (v4 < 0) {
    operator delete((void *)v3[10]);
  }
  std::streambuf::~streambuf();
  std::istream::~istream();
  MEMORY[0x1BA9C5670](&v5);
  if (SHIBYTE(v6.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v6.__r_.__value_.__l.__data_);
  }
}

void sub_1B89E8670(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::istringstream::~istringstream((uint64_t)va);
  if (*(char *)(v2 - 33) < 0) {
    operator delete(*(void **)(v2 - 56));
  }
  _Unwind_Resume(a1);
}

uint64_t *std::ifstream::basic_ifstream(uint64_t *a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA460] + 64;
  a1[53] = MEMORY[0x1E4FBA460] + 64;
  uint64_t v3 = a1 + 2;
  uint64_t v4 = *(void *)(MEMORY[0x1E4FBA3F8] + 16);
  uint64_t v5 = *(void *)(MEMORY[0x1E4FBA3F8] + 8);
  *a1 = v5;
  *(uint64_t *)((char *)a1 + *(void *)(v5 - 24)) = v4;
  a1[1] = 0;
  std::string v6 = (std::ios_base *)((char *)a1 + *(void *)(*a1 - 24));
  std::ios_base::init(v6, a1 + 2);
  uint64_t v7 = MEMORY[0x1E4FBA460] + 24;
  v6[1].__vftable = 0;
  v6[1].__fmtflags_ = -1;
  *a1 = v7;
  a1[53] = v2;
  MEMORY[0x1BA9C54D0](v3);
  if (!std::filebuf::open()) {
    std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 4);
  }
  return a1;
}

void sub_1B89E8834(_Unwind_Exception *a1)
{
  std::istream::~istream();
  MEMORY[0x1BA9C5670](v1);
  _Unwind_Resume(a1);
}

void *std::ifstream::~ifstream(void *a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA3F8];
  uint64_t v3 = *MEMORY[0x1E4FBA3F8];
  *a1 = *MEMORY[0x1E4FBA3F8];
  *(void *)((char *)a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  MEMORY[0x1BA9C54E0](a1 + 2);
  std::istream::~istream();
  MEMORY[0x1BA9C5670](a1 + 53);
  return a1;
}

void *arkit::RTFSPContainer::rtfspDefault@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, aDefaultTrained);
}

uint64_t *std::istringstream::basic_istringstream[abi:ne180100](uint64_t *a1, const std::string *a2, int a3)
{
  uint64_t v6 = MEMORY[0x1E4FBA490] + 64;
  a1[15] = MEMORY[0x1E4FBA490] + 64;
  uint64_t v7 = (uint64_t)(a1 + 2);
  uint64_t v8 = *(void *)(MEMORY[0x1E4FBA410] + 16);
  uint64_t v9 = *(void *)(MEMORY[0x1E4FBA410] + 8);
  *a1 = v9;
  *(uint64_t *)((char *)a1 + *(void *)(v9 - 24)) = v8;
  a1[1] = 0;
  uint64_t v10 = (std::ios_base *)((char *)a1 + *(void *)(*a1 - 24));
  std::ios_base::init(v10, a1 + 2);
  uint64_t v11 = MEMORY[0x1E4FBA490] + 24;
  v10[1].__vftable = 0;
  v10[1].__fmtflags_ = -1;
  *a1 = v11;
  a1[15] = v6;
  std::stringbuf::basic_stringbuf[abi:ne180100](v7, a2, a3 | 8);
  return a1;
}

void sub_1B89E8AA4(_Unwind_Exception *a1)
{
  std::istream::~istream();
  MEMORY[0x1BA9C5670](v1);
  _Unwind_Resume(a1);
}

uint64_t std::istringstream::~istringstream(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA410];
  uint64_t v3 = *MEMORY[0x1E4FBA410];
  *(void *)a1 = *MEMORY[0x1E4FBA410];
  *(void *)(a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 16) = MEMORY[0x1E4FBA470] + 16;
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  std::streambuf::~streambuf();
  std::istream::~istream();
  MEMORY[0x1BA9C5670](a1 + 120);
  return a1;
}

void std::vector<cva::Matrix<float,1u,0u,false>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v6 = (void *)*((void *)v4 - 3);
        v4 -= 24;
        free(v6);
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *std::string::basic_string[abi:ne180100]<0>(void *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((unsigned char *)a1 + 23) = v4;
    uint64_t v6 = a1;
    if (!v4) {
      goto LABEL_9;
    }
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((unsigned char *)v6 + v5) = 0;
  return a1;
}

void std::string::__throw_length_error[abi:ne180100]()
{
}

void *std::getline[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(void *a1, uint64_t a2, unsigned __int8 a3)
{
  MEMORY[0x1BA9C5510](&v11, a1, 1);
  if (!v11) {
    return a1;
  }
  if (*(char *)(a2 + 23) < 0)
  {
    **(unsigned char **)a2 = 0;
    *(void *)(a2 + _Block_object_dispose(&STACK[0x400], 8) = 0;
  }
  else
  {
    *(unsigned char *)a2 = 0;
    *(unsigned char *)(a2 + 23) = 0;
  }
  uint64_t v6 = 0;
  while (1)
  {
    uint64_t v7 = *(void **)((char *)a1 + *(void *)(*a1 - 24) + 40);
    uint64_t v8 = (unsigned char *)v7[3];
    if (v8 != (unsigned char *)v7[4])
    {
      v7[3] = v8 + 1;
      LOBYTE(v7) = *v8;
      goto LABEL_9;
    }
    LODWORD(v7) = (*(uint64_t (**)(void *))(*v7 + 80))(v7);
    if (v7 == -1) {
      break;
    }
LABEL_9:
    if (v7 == a3)
    {
      int v9 = 0;
      goto LABEL_17;
    }
    std::string::push_back((std::string *)a2, (std::string::value_type)v7);
    --v6;
    if (*(char *)(a2 + 23) < 0 && *(void *)(a2 + 8) == 0x7FFFFFFFFFFFFFF7)
    {
      int v9 = 4;
      goto LABEL_17;
    }
  }
  if (v6) {
    int v9 = 2;
  }
  else {
    int v9 = 6;
  }
LABEL_17:
  std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | v9);
  return a1;
}

void sub_1B89E8E7C(void *a1)
{
  __cxa_begin_catch(a1);
  uint64_t v2 = *v1;
  *(_DWORD *)((char *)v1 + *(void *)(*v1 - 24) + 32) |= 1u;
  if ((*((unsigned char *)v1 + *(void *)(v2 - 24) + 36) & 1) == 0)
  {
    __cxa_end_catch();
    JUMPOUT(0x1B89E8E3CLL);
  }
  __cxa_rethrow();
}

void sub_1B89E8EF8(_Unwind_Exception *a1)
{
}

void std::vector<int>::__append(std::vector<int> *this, std::vector<int>::size_type __n)
{
  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  size_t v5 = value;
  std::vector<unsigned int>::pointer end = p_end_cap[-1].__value_;
  if (__n <= value - end)
  {
    if (__n)
    {
      bzero(p_end_cap[-1].__value_, 4 * __n);
      end += __n;
    }
    this->__end_ = end;
  }
  else
  {
    std::vector<int>::pointer begin = this->__begin_;
    uint64_t v9 = (char *)end - (char *)this->__begin_;
    unint64_t v10 = __n + (v9 >> 2);
    if (v10 >> 62) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = v9 >> 2;
    uint64_t v12 = (char *)v5 - (char *)begin;
    if (v12 >> 1 > v10) {
      unint64_t v10 = v12 >> 1;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v13 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v10;
    }
    if (v13)
    {
      unint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)p_end_cap, v13);
      std::vector<int>::pointer begin = this->__begin_;
      std::vector<unsigned int>::pointer end = this->__end_;
    }
    else
    {
      unint64_t v14 = 0;
    }
    unint64_t v15 = &v14[4 * v11];
    uint64_t v16 = (int *)&v14[4 * v13];
    bzero(v15, 4 * __n);
    size_t v17 = (int *)&v15[4 * __n];
    while (end != begin)
    {
      int v18 = *--end;
      *((_DWORD *)v15 - 1) = v18;
      v15 -= 4;
    }
    this->__begin_ = (std::vector<int>::pointer)v15;
    this->__end_ = v17;
    this->__end_cap_.__value_ = v16;
    if (begin)
    {
      operator delete(begin);
    }
  }
}

uint64_t *std::operator>>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(uint64_t *a1, uint64_t a2)
{
  MEMORY[0x1BA9C5510](&v20, a1, 0);
  if (!v20) {
    return a1;
  }
  if (*(char *)(a2 + 23) < 0)
  {
    **(unsigned char **)a2 = 0;
    *(void *)(a2 + _Block_object_dispose(&STACK[0x400], 8) = 0;
  }
  else
  {
    *(unsigned char *)a2 = 0;
    *(unsigned char *)(a2 + 23) = 0;
  }
  uint64_t v4 = *(void *)(*a1 - 24);
  uint64_t v5 = *(uint64_t *)((char *)a1 + v4 + 24);
  if (v5 <= 1) {
    uint64_t v6 = 1;
  }
  else {
    uint64_t v6 = *(uint64_t *)((char *)a1 + v4 + 24);
  }
  std::ios_base::getloc((const std::ios_base *)((char *)a1 + v4));
  uint64_t v7 = std::locale::use_facet(&v19, MEMORY[0x1E4FBA258]);
  std::locale::~locale(&v19);
  uint64_t v8 = 0;
  uint64_t v9 = a1 + 5;
  if (v5 >= 1) {
    uint64_t v10 = v6;
  }
  else {
    uint64_t v10 = 0x7FFFFFFFFFFFFFF7;
  }
  while (1)
  {
    uint64_t v11 = *(void **)((char *)v9 + *(void *)(*a1 - 24));
    uint64_t v12 = (unsigned char *)v11[3];
    if (v12 == (unsigned char *)v11[4]) {
      break;
    }
    LOBYTE(v13) = *v12;
LABEL_14:
    if ((v13 & 0x80) == 0 && (*((_DWORD *)&v7[1].~facet + v13) & 0x4000) != 0)
    {
      int v16 = 0;
      goto LABEL_23;
    }
    std::string::push_back((std::string *)a2, v13);
    unint64_t v14 = *(void **)((char *)v9 + *(void *)(*a1 - 24));
    uint64_t v15 = v14[3];
    if (v15 == v14[4]) {
      (*(void (**)(void *))(*v14 + 80))(v14);
    }
    else {
      v14[3] = v15 + 1;
    }
    if (v10 == ++v8)
    {
      int v16 = 0;
      uint64_t v8 = 1;
      goto LABEL_23;
    }
  }
  int v13 = (*(uint64_t (**)(void *))(*v11 + 72))(v11);
  if (v13 != -1) {
    goto LABEL_14;
  }
  int v16 = 2;
LABEL_23:
  uint64_t v17 = *a1;
  *(uint64_t *)((char *)a1 + *(void *)(*a1 - 24) + 24) = 0;
  if (!v8) {
    v16 |= 4u;
  }
  std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(v17 - 24)), *(_DWORD *)((char *)a1 + *(void *)(v17 - 24) + 32) | v16);
  return a1;
}

void sub_1B89E9248(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::locale a9)
{
  std::locale::~locale(&a9);
  __cxa_begin_catch(a1);
  uint64_t v11 = *v9;
  *(_DWORD *)((char *)v9 + *(void *)(*v9 - 24) + 32) |= 1u;
  if ((*((unsigned char *)v9 + *(void *)(v11 - 24) + 36) & 1) == 0)
  {
    __cxa_end_catch();
    JUMPOUT(0x1B89E9204);
  }
  __cxa_rethrow();
}

void sub_1B89E92E4(_Unwind_Exception *a1)
{
}

uint64_t std::vector<cva::Matrix<float,1u,0u,false>>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(void *)(result - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      uint64_t v13 = v7 + 24 * a2;
      uint64_t v14 = 24 * a2;
      do
      {
        *(void *)uint64_t v7 = 0;
        *(void *)(v7 + _Block_object_dispose(&STACK[0x400], 8) = 0;
        *(_DWORD *)(v7 + 16) = 0;
        v7 += 24;
        v14 -= 24;
      }
      while (v14);
      uint64_t v7 = v13;
    }
    a1[1] = v7;
  }
  else
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 3);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x555555555555555) {
      unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v9;
    }
    v18[4] = result;
    if (v11) {
      uint64_t v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<float>>>(result, v11);
    }
    else {
      uint64_t v12 = 0;
    }
    uint64_t v15 = &v12[24 * v8];
    v18[0] = v12;
    v18[1] = v15;
    v18[3] = &v12[24 * v11];
    int v16 = &v15[24 * a2];
    uint64_t v17 = 24 * a2;
    do
    {
      *(void *)uint64_t v15 = 0;
      *((void *)v15 + 1) = 0;
      *((_DWORD *)v15 + 4) = 0;
      v15 += 24;
      v17 -= 24;
    }
    while (v17);
    v18[2] = v16;
    std::vector<cva::Matrix<float,1u,0u,false>>::__swap_out_circular_buffer(a1, v18);
    return std::__split_buffer<cva::Matrix<float,1u,0u,false>>::~__split_buffer((uint64_t)v18);
  }
  return result;
}

void sub_1B89E9438(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<cva::Matrix<float,1u,0u,false>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *std::vector<cva::Matrix<float,1u,0u,false>>::__swap_out_circular_buffer(uint64_t *result, void *a2)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  uint64_t v4 = a2[1];
  if (v2 != *result)
  {
    uint64_t v5 = 0;
    do
    {
      uint64_t v6 = v4 + v5;
      uint64_t v7 = v2 + v5;
      *(void *)(v6 - 24) = 0;
      *(void *)(v6 - 16) = 0;
      uint64_t v8 = *(void *)(v2 + v5 - 16);
      *(void *)(v6 - 24) = *(void *)(v2 + v5 - 24);
      *(void *)(v6 - 16) = v8;
      *(void *)(v7 - 24) = 0;
      *(void *)(v7 - 16) = 0;
      *(_DWORD *)(v6 - _Block_object_dispose(&STACK[0x400], 8) = *(_DWORD *)(v2 + v5 - 8);
      *(_DWORD *)(v7 - _Block_object_dispose(&STACK[0x400], 8) = 0;
      v5 -= 24;
    }
    while (v2 + v5 != v3);
    v4 += v5;
  }
  a2[1] = v4;
  uint64_t v9 = *result;
  *uint64_t result = v4;
  a2[1] = v9;
  uint64_t v10 = result[1];
  result[1] = a2[2];
  a2[2] = v10;
  uint64_t v11 = result[2];
  result[2] = a2[3];
  a2[3] = v11;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<cva::Matrix<float,1u,0u,false>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = *(void **)(i - 24);
    *(void *)(a1 + 16) = i - 24;
    free(v4);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void cva::MatrixData<float,0ul,0ul,false>::reserve(uint64_t a1, unint64_t a2)
{
  if (a2)
  {
    if (*(void *)(a1 + 8) < a2)
    {
      free(*(void **)a1);
      *(void *)a1 = 0;
      cva::MatrixData<float,0ul,0ul,false>::allocate((void **)a1, a2);
    }
  }
  else
  {
    free(*(void **)a1);
    *(void *)a1 = 0;
    *(void *)(a1 + _Block_object_dispose(&STACK[0x400], 8) = 0;
  }
}

uint64_t cva::MatrixData<float,0ul,0ul,false>::allocate(void **a1, uint64_t a2)
{
  if (*a1) {
    cva::MatrixData<float,0ul,0ul,false>::allocate();
  }
  size_t v3 = (4 * a2 + 31) & 0xFFFFFFFFFFFFFFE0;
  a1[1] = (void *)(v3 >> 2);
  memptr = 0;
  uint64_t result = malloc_type_posix_memalign(&memptr, 0x20uLL, v3, 0x49090899uLL);
  uint64_t v5 = memptr;
  *a1 = memptr;
  if (!v5) {
    cva::MatrixData<float,0ul,0ul,false>::allocate();
  }
  return result;
}

uint64_t std::stringbuf::basic_stringbuf[abi:ne180100](uint64_t a1, const std::string *a2, int a3)
{
  uint64_t v6 = std::streambuf::basic_streambuf();
  *(void *)uint64_t v6 = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)(v6 + 64) = 0u;
  *(_OWORD *)(v6 + 80) = 0u;
  *(_DWORD *)(v6 + 96) = a3;
  std::string::operator=((std::string *)(v6 + 64), a2);
  std::stringbuf::__init_buf_ptrs[abi:ne180100](a1);
  return a1;
}

void sub_1B89E9680(_Unwind_Exception *a1)
{
  if (*(char *)(v1 + 87) < 0) {
    operator delete(*v2);
  }
  std::streambuf::~streambuf();
  _Unwind_Resume(a1);
}

void std::stringbuf::__init_buf_ptrs[abi:ne180100](uint64_t a1)
{
  *(void *)(a1 + 8_Block_object_dispose(&STACK[0x400], 8) = 0;
  uint64_t v2 = (std::string *)(a1 + 64);
  char v3 = *(unsigned char *)(a1 + 87);
  if (v3 < 0)
  {
    uint64_t v4 = *(std::string **)(a1 + 64);
    unint64_t v5 = *(void *)(a1 + 72);
  }
  else
  {
    uint64_t v4 = v2;
    unint64_t v5 = *(unsigned __int8 *)(a1 + 87);
  }
  int v6 = *(_DWORD *)(a1 + 96);
  if ((v6 & 8) != 0)
  {
    *(void *)(a1 + 8_Block_object_dispose(&STACK[0x400], 8) = (char *)v4 + v5;
    *(void *)(a1 + 16) = v4;
    *(void *)(a1 + 24) = v4;
    *(void *)(a1 + 32) = (char *)v4 + v5;
  }
  if ((v6 & 0x10) != 0)
  {
    *(void *)(a1 + 8_Block_object_dispose(&STACK[0x400], 8) = (char *)v4 + v5;
    std::string::size_type v7 = v3 < 0 ? (*(void *)(a1 + 80) & 0x7FFFFFFFFFFFFFFFLL) - 1 : 22;
    std::string::resize(v2, v7, 0);
    uint64_t v8 = *(char *)(a1 + 87) < 0 ? *(void *)(a1 + 72) : *(unsigned __int8 *)(a1 + 87);
    *(void *)(a1 + 40) = v4;
    *(void *)(a1 + 4_Block_object_dispose(&STACK[0x400], 8) = v4;
    *(void *)(a1 + 56) = (char *)v4 + v8;
    if ((*(unsigned char *)(a1 + 96) & 3) != 0)
    {
      if (v5 >> 31)
      {
        uint64_t v9 = ((v5 - 0x80000000) * (unsigned __int128)0x200000005uLL) >> 64;
        unint64_t v10 = 0x7FFFFFFF * ((v9 + ((v5 - 0x80000000 - v9) >> 1)) >> 30);
        uint64_t v4 = (std::string *)((char *)v4 + v10 + 0x7FFFFFFF);
        unint64_t v5 = v5 - v10 - 0x7FFFFFFF;
        *(void *)(a1 + 4_Block_object_dispose(&STACK[0x400], 8) = v4;
      }
      if (v5) {
        *(void *)(a1 + 4_Block_object_dispose(&STACK[0x400], 8) = (char *)v4 + v5;
      }
    }
  }
}

void GetConfidenceFromUncertainty(float a1)
{
  float v1 = 1.0 - expf(a1 * 0.5);
  if (v1 < 0.0 || v1 > 1.0) {
    GetConfidenceFromUncertainty();
  }
}

void sub_1B89E9894(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89E994C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void **std::vector<std::shared_ptr<CV3DSLAMStateContext const>>::push_back[abi:ne180100](uint64_t *a1, long long *a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (void **)(a1 + 2);
  unint64_t v5 = v6;
  std::string::size_type v7 = *(result - 1);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v10 = ((uint64_t)v7 - *a1) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v12 = v5 - *a1;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    v18[4] = result;
    uint64_t v14 = (char *)_ZNSt3__119__allocate_at_leastB8ne180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m((uint64_t)result, v13);
    uint64_t v15 = &v14[16 * v10];
    v18[0] = v14;
    v18[1] = v15;
    v18[3] = &v14[16 * v16];
    long long v17 = *a2;
    *(_OWORD *)uint64_t v15 = *a2;
    if (*((void *)&v17 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v17 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    v18[2] = v15 + 16;
    std::vector<std::shared_ptr<CV3DSLAMStateContext const>>::__swap_out_circular_buffer(a1, v18);
    uint64_t v9 = (void *)a1[1];
    uint64_t result = std::__split_buffer<std::shared_ptr<CV3DSLAMStateContext const>>::~__split_buffer(v18);
  }
  else
  {
    *std::string::size_type v7 = *(void *)a2;
    uint64_t v8 = *((void *)a2 + 1);
    v7[1] = v8;
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v9 = v7 + 2;
    a1[1] = (uint64_t)(v7 + 2);
  }
  a1[1] = (uint64_t)v9;
  return result;
}

void sub_1B89E9A90(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::shared_ptr<CV3DSLAMStateContext const>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void sub_1B89E9BC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89EA898(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, id *a13, id *location, void *a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,void (*a30)(char *),uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38,uint64_t a39,uint64_t a40)
{
  a30(&a28);
  objc_destroyWeak(location);

  objc_destroyWeak(a13);
  objc_destroyWeak((id *)(v41 - 256));
  (*(void (**)(uint64_t))(v41 - 232))(v41 - 248);
  (*(void (**)(uint64_t))(v41 - 192))(v41 - 208);
  _Unwind_Resume(a1);
}

void ARSetNSErrorByWrappingCFErrorWithFailureReasonMessage(void *a1, void *a2, void *a3)
{
  id v7 = a3;
  if (a1)
  {
    unint64_t v5 = objc_opt_new();
    unint64_t v6 = v5;
    if (a2)
    {
      [v5 setObject:a2 forKeyedSubscript:*MEMORY[0x1E4F28A50]];
    }
    if (v7) {
      [v6 setObject:v7 forKeyedSubscript:*MEMORY[0x1E4F28588]];
    }
    *a1 = (id)[objc_alloc(MEMORY[0x1E4F28C58]) initWithDomain:@"com.apple.arkit.ARSceneReconstructionHandler" code:1 userInfo:v6];
  }
}

void sub_1B89EAB14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B89EABC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89EAC38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89EAD1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B89EAD98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B89EAE94(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_1B89EAF04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B89EAF8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89EB0D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89EB3C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89EB554(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89EB81C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89EBD0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89EC63C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,void *a23,void *a24,void *a25,char a26,uint64_t a27,void (*a28)(char *))
{
  a28(&a26);
  (*(void (**)(uint64_t))(v29 - 184))(v29 - 200);

  _Unwind_Resume(a1);
}

void sub_1B89ECAD4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89ECD60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, void (*a12)(char *))
{
  a12(&a10);

  _Unwind_Resume(a1);
}

void sub_1B89ECE28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B89ECF84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89ED024(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89ED290(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id a20)
{
  _Block_object_dispose(&a15, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__6(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__6(uint64_t a1)
{
}

void sub_1B89ED4A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, uint64_t a7, ...)
{
  va_start(va, a7);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B89ED5D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, objc_super a10)
{
  a10.super_class = (Class)ARSceneReconstructionHandler;
  [(_Unwind_Exception *)&a10 dealloc];
  _Unwind_Resume(a1);
}

void ___ZL15_ARLogTechniquev_block_invoke_14()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "Technique");
  float v1 = (void *)_ARLogTechnique(void)::logObj;
  _ARLogTechnique(void)::logObuint64_t j = (uint64_t)v0;
}

void ___ZL13_ARLogGeneralv_block_invoke_26()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "General");
  float v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObuint64_t j = (uint64_t)v0;
}

uint64_t std::vector<std::shared_ptr<CV3DSLAMStateContext const>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::shared_ptr<CV3DSLAMStateContext const>>,std::reverse_iterator<std::shared_ptr<CV3DSLAMStateContext const>*>,std::reverse_iterator<std::shared_ptr<CV3DSLAMStateContext const>*>,std::reverse_iterator<std::shared_ptr<CV3DSLAMStateContext const>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::shared_ptr<CV3DSLAMStateContext const>>,std::reverse_iterator<std::shared_ptr<CV3DSLAMStateContext const>*>,std::reverse_iterator<std::shared_ptr<CV3DSLAMStateContext const>*>,std::reverse_iterator<std::shared_ptr<CV3DSLAMStateContext const>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  void v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = (_OWORD *)(a7 - 16);
    do
    {
      long long v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      *uint64_t v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *((void *)&v15 + 1) = v8;
      v7 -= 16;
      --v8;
    }
    while (a3 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<CV3DSLAMStateContext const>>,std::reverse_iterator<std::shared_ptr<CV3DSLAMStateContext const>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<CV3DSLAMStateContext const>>,std::reverse_iterator<std::shared_ptr<CV3DSLAMStateContext const>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<CV3DSLAMStateContext const>>,std::reverse_iterator<std::shared_ptr<CV3DSLAMStateContext const>*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<CV3DSLAMStateContext const>>,std::reverse_iterator<std::shared_ptr<CV3DSLAMStateContext const>*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    char v3 = *(std::__shared_weak_count **)(v1 + 8);
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    }
    v1 += 16;
  }
}

void **std::__split_buffer<std::shared_ptr<CV3DSLAMStateContext const>>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void std::__split_buffer<std::shared_ptr<CV3DSLAMStateContext const>>::clear[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v1 = *(void *)(a1 + 16);
  while (v1 != v2)
  {
    *(void *)(a1 + 16) = v1 - 16;
    uint64_t v4 = *(std::__shared_weak_count **)(v1 - 8);
    if (v4)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v4);
      uint64_t v1 = *(void *)(a1 + 16);
    }
    else
    {
      v1 -= 16;
    }
  }
}

void std::vector<std::shared_ptr<CV3DSLAMStateContext const>>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 16)
  {
    uint64_t v4 = *(std::__shared_weak_count **)(i - 8);
    if (v4) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v4);
    }
  }
  a1[1] = v2;
}

void std::vector<std::shared_ptr<CV3DSLAMStateContext const>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<std::shared_ptr<CV3DSLAMStateContext const>>::__clear[abi:ne180100]((uint64_t *)v2);
    char v3 = **a1;
    operator delete(v3);
  }
}

void sub_1B89EEC78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, void (*a12)(char *))
{
}

void __ARMinVergenceAngleCosineDefault_block_invoke()
{
  +[ARKitUserDefaults doubleForKey:@"com.apple.arkit.worldtracking.minVergenceAngle"];
  ARMinVergenceAngleCosineDefault_sMinVergenceAngleCosine = cos(v0 * 3.14159265 / 180.0);
}

void arkit::FaceLightOptimizer::compute(uint64_t *a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *a1;
  uint64_t v5 = a1[1];
  if ((v5 - *a1) >> 5 >= (unint64_t)((uint64_t)(a2[1] - *a2) >> 3)) {
    uint64_t v7 = (uint64_t)(a2[1] - *a2) >> 3;
  }
  else {
    uint64_t v7 = (v5 - *a1) >> 5;
  }
  if (v5 == v6) {
    int v8 = 0;
  }
  else {
    int v8 = *(_DWORD *)(v6 + 24);
  }
  v31[0] = 0;
  v31[1] = 0;
  cva::MatrixData<float,0ul,0ul,false>::allocate(v31, v7);
  unsigned int v32 = v7;
  v28[0] = 0;
  v28[1] = 0;
  long long v9 = (cva::Logger *)cva::MatrixData<float,0ul,0ul,false>::allocate(v28, (v8 * v7));
  unsigned int v29 = v7;
  int v30 = v8;
  int v27 = v8;
  if ((int)v7 >= 1)
  {
    unint64_t v10 = 0;
    id v24 = "matrixmixin.h";
    int v25 = "(row < mixed().rows()) || cva::detail::assertMessage(\"Index out of bounds.\")";
    uint64_t v23 = "row";
    while (1)
    {
      if (v10 >= v32) {
        __assert_rtn("assert_in_bounds", "matrixmixin.h", 2283, "(i < mixed().elements()) || cva::detail::assertMessage(\"Index out of bounds!\")");
      }
      uint64_t v11 = *(void *)(*a2 + 8 * v10);
      uint64_t v12 = *a1;
      *((_DWORD *)v31[0] + v10) = *(_DWORD *)(*a1 + 32 * v11);
      unsigned int v13 = v29;
      if (v10 >= v29) {
        break;
      }
      int v14 = v30;
      long long v15 = (char *)v28[0];
      uint64_t v16 = v12 + 32 * v11;
      uint64_t v17 = v16 + 8;
      if (v30 != *(_DWORD *)(v16 + 24))
      {
        cva::Logger::instance(v9);
        long long v9 = (cva::Logger *)cva::Logger::logInCategory();
        if (v14 != *(_DWORD *)(v17 + 16))
        {
          int v22 = 163;
          uint64_t v23 = "assert_equal_size";
          id v24 = "matrixfun.h";
          int v25 = "(lhs.rows() == rhs.rows() && lhs.columns() == rhs.columns()) || cva::detail::assertMessage(\"Matrix size"
                "s are not compatible!\")";
LABEL_28:
          __assert_rtn(v23, v24, v22, v25);
        }
      }
      if (v14) {
        int v18 = &v15[4 * v10];
      }
      else {
        int v18 = 0;
      }
      uint64_t v19 = (uint64_t)&v15[4 * v10 + 4 * v14 * v13];
      if (!v14) {
        uint64_t v19 = 0;
      }
      if (v18 != (char *)v19)
      {
        char v20 = *(int **)v17;
        do
        {
          int v21 = *v20++;
          *(_DWORD *)int v18 = v21;
          v18 += 4 * (int)v13;
        }
        while (v18 != (char *)v19);
      }
      if (++v10 == v7) {
        goto LABEL_22;
      }
    }
    int v22 = 1063;
    goto LABEL_28;
  }
LABEL_22:
  if (v27 <= (int)v7) {
    arkit::FaceLightOptimizer::solveQuadratic((uint64_t)v31, (uint64_t)v28, 1);
  }
  *(_DWORD *)(a3 + 32) = 0;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(void *)(a3 + 4_Block_object_dispose(&STACK[0x400], 8) = 0;
  *(void *)(a3 + 56) = 0;
  *(void *)(a3 + 40) = 0;
  *(_DWORD *)(a3 + 64) = 0;
  free(v28[0]);
  free(v31[0]);
}

void sub_1B89EF1B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,void *a32)
{
  free(a20);
  free(a29);
  free(a32);
  free(*(void **)(v32 - 152));
  free(*(void **)(v32 - 128));
  _Unwind_Resume(a1);
}

void arkit::FaceLightOptimizer::solveQuadratic(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v74 = *MEMORY[0x1E4F143B8];
  kdebug_trace();
  int v6 = *(_DWORD *)(a1 + 16);
  if (v6 != *(_DWORD *)(a2 + 16)) {
    arkit::FaceLightOptimizer::solveQuadratic();
  }
  signed int v7 = *(_DWORD *)(a2 + 20);
  unsigned int v8 = v6 + 14;
  uint64_t v9 = (v7 * (v6 + 14));
  v64[0] = 0;
  v64[1] = 0;
  unint64_t v10 = (char *)cva::MatrixData<float,0ul,0ul,false>::allocate(v64, v9);
  unsigned int v65 = v8;
  unsigned int v66 = v7;
  unsigned int v11 = *(_DWORD *)(a2 + 16);
  BOOL v26 = v8 >= v11;
  unsigned int v12 = v8 - v11;
  if (!v26)
  {
    unsigned __int32 v42 = "((row + nRows <= mixed().rows()) && (col + nCols <= mixed().columns())) || cva::detail::assertMessage(\"Index "
          "out of bounds!\")";
    int v43 = 2252;
    float32x2_t v44 = "matrixmixin.h";
    unint64_t v10 = "assert_in_bounds";
    goto LABEL_67;
  }
  unsigned int v13 = v64[0];
  if (v7 != *(_DWORD *)(a2 + 20))
  {
    cva::Logger::instance((cva::Logger *)v10);
    cva::Logger::logInCategory();
    unsigned __int32 v42 = "(lhs.rows() == rhs.rows() && lhs.columns() == rhs.columns()) || cva::detail::assertMessage(\"Matrix sizes are "
          "not compatible!\")";
    int v43 = 163;
    float32x2_t v44 = "matrixfun.h";
    unint64_t v10 = "assert_equal_size";
    if (v11 != *(_DWORD *)(a2 + 16) || v7 != *(_DWORD *)(a2 + 20)) {
LABEL_67:
    }
      __assert_rtn(v10, v44, v43, v42);
  }
  int v14 = &v65;
  if (v11 * v7) {
    long long v15 = v13;
  }
  else {
    long long v15 = 0;
  }
  if (v11 * v7) {
    uint64_t v16 = &v13[v9];
  }
  else {
    uint64_t v16 = 0;
  }
  unsigned int v17 = v7;
  if (v15 != v16)
  {
    int v18 = 0;
    uint64_t v19 = *(int **)a2;
    do
    {
      int v20 = *v19++;
      _DWORD *v15 = v20;
      if (v18 + 1 >= (int)v11) {
        unsigned int v21 = v12;
      }
      else {
        unsigned int v21 = 0;
      }
      v15 += v21 + 1;
      if (v18 + 1 < (int)v11) {
        ++v18;
      }
      else {
        int v18 = 0;
      }
    }
    while (v15 != v16);
    unsigned int v17 = *(_DWORD *)(a2 + 20);
  }
  uint64_t v22 = 0;
  for (uint64_t i = 0; i != 14; ++i)
  {
    if (v17)
    {
      unint64_t v24 = 0;
      do
      {
        unint64_t v10 = (char *)arkit::kFLEDarkCoefficients((arkit *)v10);
        unsigned int v25 = *(_DWORD *)(a2 + 16) + i;
        BOOL v26 = v65 <= v25 || v24 >= v66;
        if (v26) {
          __assert_rtn("assert_in_bounds", "matrixmixin.h", 2269, "((row < mixed().rows()) && (col < mixed().columns())) || cva::detail::assertMessage(\"Index out of bounds!\")");
        }
        *((_DWORD *)v64[0] + v25 + v65 * v24) = *(_DWORD *)&v10[4 * v24 + v22];
        ++v24;
        unsigned int v17 = *(_DWORD *)(a2 + 20);
      }
      while (v17 > v24);
    }
    v22 += 4 * v7;
  }
  uint64_t v27 = (*(_DWORD *)(a1 + 16) + 14);
  v62[0] = 0;
  v62[1] = 0;
  cva::MatrixData<float,0ul,0ul,false>::allocate(v62, v27);
  int v63 = v27;
  uint64_t v28 = *(unsigned int *)(a1 + 16);
  if (v28 > v27) {
    __assert_rtn("assert_in_bounds", "matrixmixin.h", 2252, "((row + nRows <= mixed().rows()) && (col + nCols <= mixed().columns())) || cva::detail::assertMessage(\"Index out of bounds!\")");
  }
  unsigned int v29 = v62[0];
  if (v28)
  {
    int v30 = *(int **)a1;
    uint64_t v31 = 4 * v28;
    do
    {
      int v32 = *v30++;
      *v29++ = v32;
      v31 -= 4;
    }
    while (v31);
    unsigned int v29 = v62[0];
  }
  unint64_t v33 = 0;
  unsigned int v34 = v27 - v28;
  if (v27 < v28) {
    unsigned int v34 = 0;
  }
  uint64_t v35 = 4 * v34;
  float v36 = &v29[v28];
  do
  {
    if (v35 == v33) {
      __assert_rtn("assert_in_bounds", "matrixmixin.h", 2283, "(i < mixed().elements()) || cva::detail::assertMessage(\"Index out of bounds!\")");
    }
    v36[v33 / 4] = 0;
    v33 += 4;
  }
  while (v33 != 56);
  float32x4_t v59 = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  float32x2_t v56 = v64;
  if (v66)
  {
    if (!v64[0])
    {
      uint64_t v67 = 0;
      uint64_t v68 = 0;
      cva::MatrixData<float,0ul,0ul,false>::allocate(&v67, v66 * v66);
      LODWORD(v69) = *((_DWORD *)v56 + 5);
      HIDWORD(v69) = v66;
      float v71 = &v56;
      BOOL v72 = v64;
      if (*((_DWORD *)v56 + 4) != v65) {
        __assert_rtn("MatrixMultExpr", "matrixmultexpr.h", 100, "((lhs.ref().columns() == rhs.ref().rows())) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
      }
      int v73 = 1065353216;
      cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>((uint64_t)&v67, (uint64_t)v70);
      float v37 = v59;
      uint64_t v38 = v60;
      float32x4_t v59 = v67;
      uint64_t v60 = v68;
      uint64_t v67 = v37;
      uint64_t v68 = v38;
      uint64_t v61 = v69;
      uint64_t v69 = 0;
      free(v37);
LABEL_49:
      float32x2_t v56 = 0;
      uint64_t v57 = 0;
      unsigned int v58 = 0;
      v55[0] = v62;
      if (v63 != v65) {
        goto LABEL_54;
      }
      if (v66)
      {
        if (!v62[0] || !v64[0])
        {
          uint64_t v67 = 0;
          uint64_t v68 = 0;
          cva::MatrixData<float,0ul,0ul,false>::allocate(&v67, v66);
          LODWORD(v69) = v66;
          float v71 = (void **)v55;
          BOOL v72 = v64;
          if (*(_DWORD *)(v55[0] + 16) != v65) {
            __assert_rtn("MatrixMultExpr", "matrixmultexpr.h", 100, "((lhs.ref().columns() == rhs.ref().rows())) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
          }
          int v73 = 1065353216;
          cva::assign<false,false,cva::Matrix<float,1u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,1u,false> const>,cva::Matrix<float,0u,0u,false>>((uint64_t)&v67, (uint64_t)v70);
          id v40 = v56;
          uint64_t v41 = v57;
          float32x2_t v56 = v67;
          uint64_t v57 = v68;
          uint64_t v67 = v40;
          uint64_t v68 = v41;
          unsigned int v58 = v69;
          LODWORD(v69) = 0;
          free(v40);
LABEL_59:
          v55[0] = 0;
          v55[1] = 0;
          int v53 = 0;
          uint64_t v54 = 0;
          v52[0] = 0;
          v52[1] = 0;
          int v50 = 0;
          uint64_t v51 = 0;
          v49[0] = 0;
          v49[1] = 0;
          int v47 = 0;
          uint64_t v48 = 0;
          int v45 = 0;
          uint64_t v46 = 0;
          if (v7)
          {
            LODWORD(v55[0]) = v7;
            HIDWORD(v55[0]) = v7;
            operator new[]();
          }
          if (a3)
          {
            v49[0] = 0x6400000000;
            operator new[]();
          }
          thirdparty::quadprogpp::solve_quadprog(v55, (uint64_t)&v53, v52, &v50, v49, &v47, (uint64_t)&v45);
        }
        unsigned int v58 = v66;
        cva::MatrixData<float,0ul,0ul,false>::reserve((uint64_t)&v56, v66);
        int v39 = *(_DWORD *)(v55[0] + 16);
        float v71 = (void **)v55;
        BOOL v72 = v64;
        if (v39 != v65) {
LABEL_54:
        }
          __assert_rtn("MatrixMultExpr", "matrixmultexpr.h", 100, "((lhs.ref().columns() == rhs.ref().rows())) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
      }
      else
      {
        float v71 = (void **)v55;
        BOOL v72 = v64;
      }
      int v73 = 1065353216;
      cva::assign<false,false,cva::Matrix<float,1u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,1u,false> const>,cva::Matrix<float,0u,0u,false>>((uint64_t)&v56, (uint64_t)v70);
      goto LABEL_59;
    }
    LODWORD(v61) = v66;
    HIDWORD(v61) = v66;
    cva::MatrixData<float,0ul,0ul,false>::reserve((uint64_t)&v59, v66 * v66);
    int v14 = (unsigned int *)((char *)v56 + 16);
  }
  float v71 = &v56;
  BOOL v72 = v64;
  if (*v14 != v65) {
    __assert_rtn("MatrixMultExpr", "matrixmultexpr.h", 100, "((lhs.ref().columns() == rhs.ref().rows())) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
  }
  int v73 = 1065353216;
  cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>((uint64_t)&v59, (uint64_t)v70);
  goto LABEL_49;
}

void sub_1B89EFF4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,void *a30)
{
  free(v30[9]);
  free(*v30);
  free(v30[3]);
  free(v30[6]);
  _Unwind_Resume(a1);
}

void arkit::FaceLightOptimizer::inlierSet(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t **a4@<X8>, float a5@<S0>)
{
  if (a5 < 0.0) {
    arkit::FaceLightOptimizer::inlierSet();
  }
  uint64_t v7 = *(unsigned int *)(a2 + 16);
  arkit::FaceLightOptimizer::penaltyFunction(a1, a2, a3, (uint64_t)&v20);
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  if ((int)v7 >= 1)
  {
    unsigned int v8 = 0;
    unint64_t v9 = 0;
    unint64_t v10 = a4 + 2;
    do
    {
      if (v9 >= v21) {
        __assert_rtn("assert_in_bounds", "matrixmixin.h", 2283, "(i < mixed().elements()) || cva::detail::assertMessage(\"Index out of bounds!\")");
      }
      if (*((float *)v20 + v9) < a5)
      {
        if ((unint64_t)v8 >= *v10)
        {
          unsigned int v12 = *a4;
          uint64_t v13 = v8 - *a4;
          unint64_t v14 = v13 + 1;
          if ((unint64_t)(v13 + 1) >> 61) {
            std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v15 = *v10 - (void)v12;
          if (v15 >> 2 > v14) {
            unint64_t v14 = v15 >> 2;
          }
          if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v16 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v16 = v14;
          }
          if (v16)
          {
            unsigned int v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>((uint64_t)(a4 + 2), v16);
            unsigned int v12 = *a4;
            unsigned int v8 = a4[1];
          }
          else
          {
            unsigned int v17 = 0;
          }
          int v18 = (unint64_t *)&v17[8 * v13];
          *int v18 = v9;
          unsigned int v11 = v18 + 1;
          while (v8 != v12)
          {
            unint64_t v19 = *--v8;
            *--int v18 = v19;
          }
          *a4 = v18;
          a4[1] = v11;
          a4[2] = (unint64_t *)&v17[8 * v16];
          if (v12) {
            operator delete(v12);
          }
        }
        else
        {
          *unsigned int v8 = v9;
          unsigned int v11 = v8 + 1;
        }
        a4[1] = v11;
        unsigned int v8 = v11;
      }
      ++v9;
    }
    while (v9 != v7);
  }
  free(v20);
}

void sub_1B89F0214(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10)
{
  unsigned int v12 = *(void **)v10;
  if (*(void *)v10)
  {
    *(void *)(v10 + _Block_object_dispose(&STACK[0x400], 8) = v12;
    operator delete(v12);
  }
  free(a10);
  _Unwind_Resume(a1);
}

float arkit::FaceLightOptimizer::computeConfidence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  arkit::FaceLightOptimizer::penaltyFunction(a1, a2, a3, (uint64_t)&v9);
  float v3 = 0.0;
  if (v10)
  {
    uint64_t v4 = v10;
    uint64_t v5 = (float *)v9;
    do
    {
      float v6 = *v5++;
      float v3 = v3 + (float)(v6 * v6);
      --v4;
    }
    while (v4);
  }
  float v7 = 1.0 / (float)((float)(v3 / (float)v10) + 1.0);
  free(v9);
  return v7;
}

void arkit::FaceLightOptimizer::solveLinear(uint64_t a1@<X0>, _DWORD *a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 16) != a2[4]) {
    arkit::FaceLightOptimizer::solveLinear();
  }
  unsigned int v25 = 869711765;
  uint64_t v8 = a2[5];
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  cva::MatrixData<float,0ul,0ul,false>::allocate(&v22, v8);
  unsigned int v24 = v8;
  cva::SVD<cva::Matrix<float,0u,0u,false>,true>::SVD<cva::Matrix<float,0u,0u,false>>((uint64_t)v15, a2, 3, 0);
  cva::SVD<cva::Matrix<float,0u,0u,false>,true>::inverse(v15, &v25, (uint64_t)v19);
  if (v21 != *(_DWORD *)(a1 + 16)) {
    goto LABEL_18;
  }
  if (v20 == v24)
  {
    int v30 = v19;
    uint64_t v31 = a1;
LABEL_8:
    int v32 = 1065353216;
    cva::assign<false,false,cva::Matrix<float,0u,1u,false>,cva::Matrix<float,0u,0u,false>,cva::Matrix<float,0u,1u,false>>((uint64_t)&v22, (uint64_t)&v29);
    goto LABEL_11;
  }
  if (v19[0] != v22 && *(void **)a1 != v22)
  {
    unsigned int v24 = v20;
    cva::MatrixData<float,0ul,0ul,false>::reserve((uint64_t)&v22, v20);
    int v9 = *(_DWORD *)(a1 + 16);
    int v30 = v19;
    uint64_t v31 = a1;
    if (v21 == v9) {
      goto LABEL_8;
    }
LABEL_18:
    __assert_rtn("MatrixMultExpr", "matrixmultexpr.h", 100, "((lhs.ref().columns() == rhs.ref().rows())) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
  }
  BOOL v26 = 0;
  uint64_t v27 = 0;
  cva::MatrixData<float,0ul,0ul,false>::allocate(&v26, v20);
  unsigned int v28 = v20;
  int v30 = v19;
  uint64_t v31 = a1;
  if (v21 != *(_DWORD *)(a1 + 16)) {
    __assert_rtn("MatrixMultExpr", "matrixmultexpr.h", 100, "((lhs.ref().columns() == rhs.ref().rows())) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
  }
  int v32 = 1065353216;
  cva::assign<false,false,cva::Matrix<float,0u,1u,false>,cva::Matrix<float,0u,0u,false>,cva::Matrix<float,0u,1u,false>>((uint64_t)&v26, (uint64_t)&v29);
  unsigned int v10 = v22;
  uint64_t v11 = v23;
  uint64_t v22 = v26;
  uint64_t v23 = v27;
  BOOL v26 = v10;
  uint64_t v27 = v11;
  unsigned int v24 = v28;
  unsigned int v28 = 0;
  free(v10);
LABEL_11:
  free(v19[0]);
  free(v18);
  free(*((void **)&v16 + 1));
  free(v15[0]);
  float v12 = 0.0;
  if (a3)
  {
    *(_OWORD *)uint64_t v15 = 0u;
    long long v16 = 0u;
    int v17 = 0;
    if (v24 != 9) {
      __assert_rtn("MatrixData", "matrixdata.h", 96, "(size == sz) || cva::detail::assertMessage(\"Matrix data size mismatch.\")");
    }
    uint64_t v13 = 0;
    unint64_t v14 = (char *)v22;
    do
    {
      *(_DWORD *)((char *)v15 + v13) = *(_DWORD *)&v14[v13];
      v13 += 4;
    }
    while (v13 != 36);
    float v12 = arkit::FaceLightOptimizer::computeConfidence((uint64_t)v15, a1, (uint64_t)a2);
  }
  float v29 = v12;
  std::pair<cva::Matrix<float,9u,1u,false>,float>::pair[abi:ne180100]<cva::Matrix<float,0u,1u,false> &,float const&,0>(a4, (uint64_t *)&v22, &v29);
  free(v22);
}

void sub_1B89F0558(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,void *a23)
{
  free(*(void **)(v23 - 112));
  free(a20);
  cva::SVD<cva::Matrix<float,0u,0u,false>,true>::~SVD((void **)&a9);
  free(a23);
  _Unwind_Resume(a1);
}

void cva::SVD<cva::Matrix<float,0u,0u,false>,true>::inverse(_DWORD *a1@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  unint64_t v14 = a1 + 6;
  uint64_t v6 = cva::SVD<cva::Matrix<float,0u,0u,false>,true>::S(a1);
  v12[0] = v6;
  v12[1] = v7;
  uint64_t v8 = *a2;
  v13[0] = v12;
  v13[1] = v8;
  if (a1[10] != HIDWORD(v6)) {
    cva::SVD<cva::Matrix<float,0u,0u,false>,true>::inverse();
  }
  v15[0] = &v14;
  v15[1] = v13;
  uint64_t v11 = a1;
  if (a1[5] != v6) {
    cva::SVD<cva::Matrix<float,0u,0u,false>,true>::inverse();
  }
  uint64_t v9 = (a1[4] * a1[11]);
  *(void *)a3 = 0;
  *(void *)(a3 + _Block_object_dispose(&STACK[0x400], 8) = 0;
  cva::MatrixData<float,0ul,0ul,false>::allocate((void **)a3, v9);
  int v10 = a1[4];
  *(_DWORD *)(a3 + 16) = v14[5];
  *(_DWORD *)(a3 + 20) = v10;
  int v17 = v15;
  int v18 = &v11;
  if (*(_DWORD *)v13[0] != a1[5]) {
    __assert_rtn("MatrixMultExpr", "matrixmultexpr.h", 100, "((lhs.ref().columns() == rhs.ref().rows())) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
  }
  int v19 = 1065353216;
  cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixMultExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>>(a3, (uint64_t)v16);
}

void sub_1B89F06EC(_Unwind_Exception *a1)
{
  free(*v1);
  _Unwind_Resume(a1);
}

void **cva::SVD<cva::Matrix<float,0u,0u,false>,true>::~SVD(void **a1)
{
  return a1;
}

void arkit::FaceLightOptimizer::penaltyFunction(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  unint64_t v6 = *(unsigned int *)(a2 + 16);
  if (v6 != *(_DWORD *)(a3 + 16)) {
    arkit::FaceLightOptimizer::penaltyFunction();
  }
  *(void *)a4 = 0;
  *(void *)(a4 + _Block_object_dispose(&STACK[0x400], 8) = 0;
  *(_DWORD *)(a4 + 16) = v6;
  cva::MatrixData<float,0ul,0ul,false>::reserve(a4, v6);
  if (*(_DWORD *)(a3 + 20) != 9) {
    __assert_rtn("MatrixMultExpr", "matrixmultexpr.h", 100, "((lhs.ref().columns() == rhs.ref().rows())) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
  }
  uint64_t v9 = *(unsigned int *)(a3 + 16);
  v34[0] = 0;
  v34[1] = 0;
  cva::MatrixData<float,0ul,0ul,false>::allocate(v34, v9);
  int v10 = *(_DWORD *)(a3 + 20);
  unsigned int v35 = *(_DWORD *)(a3 + 16);
  uint64_t v37 = a3;
  uint64_t v38 = a1;
  if (v10 != 9) {
    __assert_rtn("MatrixMultExpr", "matrixmultexpr.h", 100, "((lhs.ref().columns() == rhs.ref().rows())) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
  }
  int v39 = 1065353216;
  cva::assign<false,false,cva::Matrix<float,0u,1u,false>,cva::Matrix<float,0u,0u,false>,cva::Matrix<float,9u,1u,false>>((uint64_t)v34, (uint64_t)&v36);
  unsigned int v12 = v35;
  if (v35 != *(_DWORD *)(a2 + 16))
  {
    cva::Logger::instance(v11);
    cva::Logger::logInCategory();
    unsigned int v12 = v35;
    if (v35 != *(_DWORD *)(a2 + 16)) {
      __assert_rtn("assert_equal_size", "matrixfun.h", 163, "(lhs.rows() == rhs.rows() && lhs.columns() == rhs.columns()) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
    }
  }
  if (v12 == *(_DWORD *)(a4 + 16)) {
    goto LABEL_7;
  }
  if (v34[0] != *(void **)a4 && *(void *)a2 != *(void *)a4)
  {
    *(_DWORD *)(a4 + 16) = v12;
    cva::MatrixData<float,0ul,0ul,false>::reserve(a4, v12);
    unsigned int v12 = v35;
    if (*(_DWORD *)(a4 + 16) != v35)
    {
      cva::Logger::instance(v21);
      cva::Logger::logInCategory();
      unsigned int v12 = *(_DWORD *)(a4 + 16);
      if (v12 != v35) {
        __assert_rtn("assert_equal_size", "matrixfun.h", 163, "(lhs.rows() == rhs.rows() && lhs.columns() == rhs.columns()) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
      }
    }
LABEL_7:
    if (v12)
    {
      uint64_t v13 = *(float **)a4;
      uint64_t v14 = v12;
      uint64_t v15 = *(float **)a2;
      long long v16 = (float *)v34[0];
      uint64_t v17 = 4 * v14;
      do
      {
        float v18 = *v16++;
        float v19 = v18;
        float v20 = *v15++;
        *v13++ = (float)(v19 - v20) / (float)(v20 + 0.01);
        v17 -= 4;
      }
      while (v17);
    }
    goto LABEL_20;
  }
  float v36 = 0;
  uint64_t v37 = 0;
  cva::MatrixData<float,0ul,0ul,false>::allocate((void **)&v36, v12);
  unsigned int v22 = v35;
  uint64_t v23 = v36;
  if (v35)
  {
    unsigned int v24 = *(float **)a2;
    unsigned int v25 = (float *)v34[0];
    uint64_t v26 = 4 * v35;
    uint64_t v27 = v36;
    do
    {
      float v28 = *v25++;
      float v29 = v28;
      float v30 = *v24++;
      *v27++ = (float)(v29 - v30) / (float)(v30 + 0.01);
      v26 -= 4;
    }
    while (v26);
  }
  uint64_t v31 = *(float **)a4;
  uint64_t v32 = *(void *)(a4 + 8);
  uint64_t v33 = v37;
  *(void *)a4 = v23;
  *(void *)(a4 + _Block_object_dispose(&STACK[0x400], 8) = v33;
  float v36 = v31;
  uint64_t v37 = v32;
  *(_DWORD *)(a4 + 16) = v22;
  LODWORD(v3_Block_object_dispose(&STACK[0x400], 8) = 0;
  free(v31);
LABEL_20:
  free(v34[0]);
}

void sub_1B89F0A40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  free(a13);
  free(*v13);
  _Unwind_Resume(a1);
}

float std::pair<cva::Matrix<float,9u,1u,false>,float>::pair[abi:ne180100]<cva::Matrix<float,0u,1u,false> &,float const&,0>(uint64_t a1, uint64_t *a2, float *a3)
{
  int v3 = *((_DWORD *)a2 + 4);
  *(_DWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  if (v3 != 9) {
    std::pair<cva::Matrix<float,9u,1u,false>,float>::pair[abi:ne180100]<cva::Matrix<float,0u,1u,false> &,float const&,0>();
  }
  if (*((_DWORD *)a2 + 4) != 9) {
    std::pair<cva::Matrix<float,9u,1u,false>,float>::pair[abi:ne180100]<cva::Matrix<float,0u,1u,false> &,float const&,0>();
  }
  uint64_t v4 = 0;
  uint64_t v5 = *a2;
  do
  {
    *(_DWORD *)(a1 + v4) = *(_DWORD *)(v5 + v4);
    v4 += 4;
  }
  while (v4 != 36);
  float result = *a3;
  *(float *)(a1 + 36) = *a3;
  return result;
}

void cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v5 = **(void **)(a2 + 8);
  if (*(void *)v5 == *(void *)a1 || *(void *)v4 == *(void *)a1)
  {
    uint64_t v8 = (*(_DWORD *)(v4 + 20) * *(_DWORD *)(v5 + 20));
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    cva::MatrixData<float,0ul,0ul,false>::allocate(&v14, v8);
    int v9 = *(_DWORD *)(*(void *)(a2 + 16) + 20);
    LODWORD(v16) = *(_DWORD *)(**(void **)(a2 + 8) + 20);
    HIDWORD(v16) = v9;
    cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>(&v14, a2);
    int v10 = *(void **)a1;
    uint64_t v11 = *(void *)(a1 + 8);
    uint64_t v12 = v15;
    *(void *)a1 = v14;
    *(void *)(a1 + _Block_object_dispose(&STACK[0x400], 8) = v12;
    uint64_t v14 = v10;
    uint64_t v15 = v11;
    *(void *)(a1 + 16) = v16;
    uint64_t v16 = 0;
    free(v10);
  }
  else
  {
    int v6 = *(_DWORD *)(a1 + 16);
    if (v6 != *(_DWORD *)(v5 + 20) || (int v7 = *(_DWORD *)(a1 + 20), v7 != *(_DWORD *)(v4 + 20)))
    {
      cva::Logger::instance((cva::Logger *)a1);
      cva::Logger::logInCategory();
      int v6 = *(_DWORD *)(a1 + 16);
      uint64_t v5 = **(void **)(a2 + 8);
      if (v6 != *(_DWORD *)(v5 + 20)
        || (uint64_t v4 = *(void *)(a2 + 16), v7 = *(_DWORD *)(v4 + 20), *(_DWORD *)(a1 + 20) != v7))
      {
        cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>();
      }
    }
    if (*(_DWORD *)(v5 + 16) * v6 && v7 * *(_DWORD *)(v4 + 16)) {
      cva::VecLib<float>::gemm();
    }
    if (v6 * v7)
    {
      uint64_t v13 = *(void **)a1;
      bzero(v13, 4 * (v6 * v7));
    }
  }
}

void sub_1B89F0C8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
}

void cva::assign<false,false,cva::Matrix<float,1u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,1u,false> const>,cva::Matrix<float,0u,0u,false>>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v5 = **(void **)(a2 + 8);
  if (*(void *)v5 == *(void *)a1 || *(void *)v4 == *(void *)a1)
  {
    uint64_t v7 = *(unsigned int *)(v4 + 20);
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    cva::MatrixData<float,0ul,0ul,false>::allocate(&v12, v7);
    int v14 = *(_DWORD *)(*(void *)(a2 + 16) + 20);
    cva::assign<false,false,cva::Matrix<float,1u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,1u,false> const>,cva::Matrix<float,0u,0u,false>>(&v12, a2);
    uint64_t v8 = *(void **)a1;
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v10 = v13;
    *(void *)a1 = v12;
    *(void *)(a1 + _Block_object_dispose(&STACK[0x400], 8) = v10;
    uint64_t v12 = v8;
    uint64_t v13 = v9;
    *(_DWORD *)(a1 + 16) = v14;
    int v14 = 0;
    free(v8);
  }
  else
  {
    unsigned int v6 = *(_DWORD *)(a1 + 16);
    if (v6 != *(_DWORD *)(v4 + 20))
    {
      cva::Logger::instance((cva::Logger *)a1);
      cva::Logger::logInCategory();
      unsigned int v6 = *(_DWORD *)(a1 + 16);
      uint64_t v4 = *(void *)(a2 + 16);
      if (v6 != *(_DWORD *)(v4 + 20)) {
        cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>();
      }
      uint64_t v5 = **(void **)(a2 + 8);
    }
    if (*(_DWORD *)(v5 + 16) && v6 * *(_DWORD *)(v4 + 16)) {
      cva::VecLib<float>::gemm();
    }
    if (v6)
    {
      uint64_t v11 = *(void **)a1;
      bzero(v11, 4 * v6);
    }
  }
}

void sub_1B89F0E1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
}

uint64_t thirdparty::quadprogpp::Matrix<double>::~Matrix(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    if (!*v2 || (MEMORY[0x1BA9C56A0](*v2, 0x1000C8000313F17), *(void *)(a1 + 8))) {
      MEMORY[0x1BA9C56A0]();
    }
  }
  return a1;
}

uint64_t cva::SVD<cva::Matrix<float,0u,0u,false>,true>::SVD<cva::Matrix<float,0u,0u,false>>(uint64_t a1, _DWORD *a2, char a3, int a4)
{
  *(_DWORD *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 4_Block_object_dispose(&STACK[0x400], 8) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 72) = 0;
  *(unsigned char *)(a1 + 80) = 0;
  cva::SVD<cva::Matrix<float,0u,0u,false>,true>::decompose<cva::Matrix<float,0u,0u,false> const&>(a1, a2, a3, a4);
  return a1;
}

void sub_1B89F0ED8(_Unwind_Exception *a1)
{
  free(v1[6]);
  free(v1[3]);
  free(*v1);
  _Unwind_Resume(a1);
}

void cva::SVD<cva::Matrix<float,0u,0u,false>,true>::decompose<cva::Matrix<float,0u,0u,false> const&>(uint64_t a1, _DWORD *a2, char a3, int a4)
{
  int v5 = a2[4];
  int v6 = a2[5];
  *(_DWORD *)(a1 + 72) = v5;
  *(_DWORD *)(a1 + 76) = v6;
  if (!(v5 | v6))
  {
    *(unsigned char *)(a1 + 80) = 1;
LABEL_8:
    uint64_t v7 = *(void **)(a1 + 48);
    *(_DWORD *)(a1 + 64) = 0;
    *(void *)(a1 + 4_Block_object_dispose(&STACK[0x400], 8) = 0;
    *(void *)(a1 + 56) = 0;
    free(v7);
    uint64_t v8 = *(void **)a1;
    *(void *)(a1 + _Block_object_dispose(&STACK[0x400], 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    free(v8);
    uint64_t v9 = *(void **)(a1 + 24);
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 40) = 0;
    *(void *)(a1 + 24) = 0;
    free(v9);
    return;
  }
  if (a4 && fabsf((float)(v5 - v6)) >= (float)((float)(v6 + v5) * 0.1)) {
    cva::SVD<cva::Matrix<float,0u,0u,false>,true>::decomposeRectangular<cva::Matrix<float,0u,0u,false>>(a1, a2, a3);
  }
  else {
    cva::SVD<cva::Matrix<float,0u,0u,false>,true>::decomposeDirect<cva::Matrix<float,0u,0u,false>>(a1, (uint64_t)a2, a3);
  }
  if (!*(unsigned char *)(a1 + 80)) {
    goto LABEL_8;
  }
}

void cva::SVD<cva::Matrix<float,0u,0u,false>,true>::decomposeDirect<cva::Matrix<float,0u,0u,false>>(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v6 = (*(_DWORD *)(a2 + 20) * *(_DWORD *)(a2 + 16));
  __dst[0] = 0;
  __dst[1] = 0;
  cva::MatrixData<float,0ul,0ul,false>::allocate(__dst, v6);
  if (v6) {
    memcpy(__dst[0], *(const void **)a2, 4 * v6);
  }
  __dst[2] = *(void **)(a2 + 16);
  cva::SVD<cva::Matrix<float,0u,0u,false>,true>::decomposeDirect<0u,0u>(a1, (uint64_t)__dst, a3);
  free(__dst[0]);
}

void sub_1B89F104C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10)
{
}

void cva::SVD<cva::Matrix<float,0u,0u,false>,true>::decomposeRectangular<cva::Matrix<float,0u,0u,false>>(uint64_t a1, _DWORD *a2, int a3)
{
  char v3 = a3;
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  if (a2[5] >= a2[4])
  {
    uint64_t v41 = a2;
    float32x2_t v44 = (void **)a2;
    int v45 = &v41;
    cva::SVD<cva::Matrix<float,0u,0u,false>,true>::decomposeDirect<cva::MatrixMultExpr<cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>>>(a1, &v44, a3 != 0);
    if (!*(unsigned char *)(a1 + 80)) {
      return;
    }
    uint64_t v12 = *(unsigned int *)(a1 + 64);
    if (v12)
    {
      uint64_t v13 = *(float **)(a1 + 48);
      uint64_t v14 = 4 * v12;
      do
      {
        float *v13 = sqrtf(*v13);
        ++v13;
        v14 -= 4;
      }
      while (v14);
    }
    if ((v3 & 2) == 0) {
      return;
    }
    uint64_t v34 = cva::SVD<cva::Matrix<float,0u,0u,false>,true>::S((_DWORD *)a1);
    unsigned int v35 = v15;
    float v36 = &v34;
    uint64_t v37 = 925353388;
    uint64_t v38 = a1;
    if (*(_DWORD *)(a1 + 20) != v34) {
      cva::SVD<cva::Matrix<float,0u,0u,false>,true>::inverse();
    }
    int v39 = &v36;
    uint64_t v40 = (uint64_t **)&v38;
    if (*(_DWORD *)(a1 + 16) != a2[4]) {
      cva::SVD<cva::Matrix<float,0u,0u,false>,true>::inverse();
    }
    uint64_t v16 = (uint64_t *)(a1 + 24);
    int v17 = HIDWORD(v34);
    if (__PAIR64__(a2[5], HIDWORD(v34)) == *(void *)(a1 + 40))
    {
      int v45 = (void **)&v39;
      uint64_t v46 = (uint64_t ***)a2;
LABEL_30:
      int v47 = 1065353216;
      cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixMultExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>>>,cva::Matrix<float,0u,0u,false>>(a1 + 24, (uint64_t)&v44);
      return;
    }
    uint64_t v21 = *v16;
    if (*v15 == *v16)
    {
      int v22 = a2[5];
    }
    else
    {
      int v22 = a2[5];
      if (*(void *)a1 != v21 && *(void *)a2 != v21)
      {
        *(_DWORD *)(a1 + 40) = HIDWORD(v34);
        *(_DWORD *)(a1 + 44) = v22;
        cva::MatrixData<float,0ul,0ul,false>::reserve(a1 + 24, (v22 * v17));
        int v23 = a2[4];
        int v24 = *((_DWORD *)*v40 + 4);
        int v45 = (void **)&v39;
        uint64_t v46 = (uint64_t ***)a2;
        if (v24 != v23) {
          cva::SVD<cva::Matrix<float,0u,0u,false>,true>::inverse();
        }
        goto LABEL_30;
      }
    }
    uint64_t v41 = 0;
    uint64_t v42 = 0;
    cva::MatrixData<float,0ul,0ul,false>::allocate(&v41, (v22 * HIDWORD(v34)));
    int v31 = a2[4];
    int v30 = a2[5];
    LODWORD(v43) = *((_DWORD *)*v39 + 1);
    HIDWORD(v43) = v30;
    int v45 = (void **)&v39;
    uint64_t v46 = (uint64_t ***)a2;
    if (*((_DWORD *)*v40 + 4) != v31) {
      __assert_rtn("MatrixMultExpr", "matrixmultexpr.h", 100, "((lhs.ref().columns() == rhs.ref().rows())) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
    }
    int v47 = 1065353216;
    cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixMultExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>>>,cva::Matrix<float,0u,0u,false>>((uint64_t)&v41, (uint64_t)&v44);
    uint64_t v27 = *(void **)(a1 + 24);
    uint64_t v32 = *(void *)(a1 + 32);
    uint64_t v33 = v42;
    *(void *)(a1 + 24) = v41;
    *(void *)(a1 + 32) = v33;
    uint64_t v41 = v27;
    uint64_t v42 = v32;
    *(void *)(a1 + 40) = v43;
LABEL_36:
    uint64_t v43 = 0;
    free(v27);
    return;
  }
  uint64_t v41 = a2;
  float32x2_t v44 = &v41;
  int v45 = (void **)a2;
  cva::SVD<cva::Matrix<float,0u,0u,false>,true>::decomposeDirect<cva::MatrixMultExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>>(a1, (uint64_t **)&v44, 2 * (a3 != 0));
  if (*(unsigned char *)(a1 + 80))
  {
    uint64_t v6 = *(unsigned int *)(a1 + 64);
    if (v6)
    {
      uint64_t v7 = *(float **)(a1 + 48);
      uint64_t v8 = 4 * v6;
      do
      {
        *uint64_t v7 = sqrtf(*v7);
        ++v7;
        v8 -= 4;
      }
      while (v8);
    }
    if (v3)
    {
      uint64_t v38 = a1 + 24;
      uint64_t v9 = cva::SVD<cva::Matrix<float,0u,0u,false>,true>::S((_DWORD *)a1);
      uint64_t v34 = v9;
      unsigned int v35 = v10;
      float v36 = &v34;
      uint64_t v37 = 925353388;
      if (*(_DWORD *)(a1 + 40) != HIDWORD(v9)) {
        cva::SVD<cva::Matrix<float,0u,0u,false>,true>::inverse();
      }
      int v39 = (uint64_t **)&v38;
      uint64_t v40 = &v36;
      if (a2[5] != *(_DWORD *)(a1 + 44)) {
        cva::SVD<cva::Matrix<float,0u,0u,false>,true>::inverse();
      }
      int v11 = a2[4];
      if (v11 == *(_DWORD *)(a1 + 16) && *(_DWORD *)(a1 + 20) == v9)
      {
        int v45 = (void **)a2;
        uint64_t v46 = &v39;
LABEL_25:
        int v47 = 1065353216;
        cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::Matrix<float,0u,0u,false>,cva::MatrixMultExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>>,cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>>>(a1, (uint64_t)&v44);
        return;
      }
      float v18 = *(void **)a1;
      if (*(void *)a2 != *(void *)a1 && *(void **)(a1 + 24) != v18 && (void *)*v10 != v18)
      {
        *(_DWORD *)(a1 + 16) = v11;
        *(_DWORD *)(a1 + 20) = v9;
        cva::MatrixData<float,0ul,0ul,false>::reserve(a1, (v11 * v9));
        int v19 = a2[5];
        int v20 = *((_DWORD *)*v39 + 5);
        int v45 = (void **)a2;
        uint64_t v46 = &v39;
        if (v19 != v20) {
          cva::SVD<cva::Matrix<float,0u,0u,false>,true>::inverse();
        }
        goto LABEL_25;
      }
      uint64_t v41 = 0;
      uint64_t v42 = 0;
      cva::MatrixData<float,0ul,0ul,false>::allocate(&v41, (v11 * v9));
      int v25 = *(_DWORD *)*v40;
      int v26 = a2[5];
      LODWORD(v43) = a2[4];
      HIDWORD(v43) = v25;
      int v45 = (void **)a2;
      uint64_t v46 = &v39;
      if (v26 != *((_DWORD *)*v39 + 5)) {
        __assert_rtn("MatrixMultExpr", "matrixmultexpr.h", 100, "((lhs.ref().columns() == rhs.ref().rows())) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
      }
      int v47 = 1065353216;
      cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::Matrix<float,0u,0u,false>,cva::MatrixMultExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>>,cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>>>((uint64_t)&v41, (uint64_t)&v44);
      uint64_t v27 = *(void **)a1;
      uint64_t v28 = *(void *)(a1 + 8);
      uint64_t v29 = v42;
      *(void *)a1 = v41;
      *(void *)(a1 + _Block_object_dispose(&STACK[0x400], 8) = v29;
      uint64_t v41 = v27;
      uint64_t v42 = v28;
      *(void *)(a1 + 16) = v43;
      goto LABEL_36;
    }
  }
}

void sub_1B89F14A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
}

void cva::SVD<cva::Matrix<float,0u,0u,false>,true>::decomposeDirect<0u,0u>(uint64_t a1, uint64_t a2, char a3)
{
  unsigned int v6 = *(_DWORD *)(a2 + 16);
  unsigned int v5 = *(_DWORD *)(a2 + 20);
  if ((int)v5 >= (int)v6) {
    unint64_t v7 = v6;
  }
  else {
    unint64_t v7 = v5;
  }
  *(_DWORD *)(a1 + 64) = v7;
  cva::MatrixData<float,0ul,0ul,false>::reserve(a1 + 48, v7);
  if (a3)
  {
    *(_DWORD *)(a1 + 16) = v6;
    *(_DWORD *)(a1 + 20) = v7;
    cva::MatrixData<float,0ul,0ul,false>::reserve(a1, v7 * v6);
  }
  else
  {
    uint64_t v8 = *(void **)a1;
    *(void *)(a1 + _Block_object_dispose(&STACK[0x400], 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    free(v8);
  }
  uint64_t v9 = (void **)(a1 + 24);
  if ((a3 & 2) != 0)
  {
    *(_DWORD *)(a1 + 40) = v7;
    *(_DWORD *)(a1 + 44) = v5;
    cva::MatrixData<float,0ul,0ul,false>::reserve(a1 + 24, v7 * v5);
  }
  else
  {
    uint64_t v10 = *v9;
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 40) = 0;
    void *v9 = 0;
    free(v10);
  }
  int v15 = 0;
  int v14 = 0;
  cva::vecLib::gesvd<float>();
  v12[0] = 0;
  v12[1] = 0;
  cva::MatrixData<float,0ul,0ul,false>::allocate(v12, 0.0);
  unsigned int v13 = 0.0;
  int v11 = (cva::Logger *)cva::vecLib::gesvd<float>();
  if (v14 < 0) {
    __assert_rtn("decomposeDirect", "matrixsvd.h", 439, "(info >= 0) || cva::detail::assertMessage(\"gesvd() compute SVD failed!\")");
  }
  if (v14)
  {
    cva::Logger::instance(v11);
    cva::Logger::logInCategory();
  }
  free(v12[0]);
  *(unsigned char *)(a1 + 80) = v14 == 0;
}

void sub_1B89F1728(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
}

void cva::SVD<cva::Matrix<float,0u,0u,false>,true>::decomposeDirect<cva::MatrixMultExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>>(uint64_t a1, uint64_t **a2, char a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  unsigned int v6 = a2 + 1;
  uint64_t v7 = (*((_DWORD *)a2[1] + 5) * *(_DWORD *)(**a2 + 20));
  v12[0] = 0;
  v12[1] = 0;
  cva::MatrixData<float,0ul,0ul,false>::allocate(v12, v7);
  uint64_t v8 = *a2;
  uint64_t v9 = **a2;
  uint64_t v10 = *v6;
  int v11 = *((_DWORD *)*v6 + 5);
  int v13 = *(_DWORD *)(v9 + 20);
  int v14 = v11;
  uint64_t v16 = v8;
  int v17 = v10;
  if (*(_DWORD *)(v9 + 16) != v10[4]) {
    __assert_rtn("MatrixMultExpr", "matrixmultexpr.h", 100, "((lhs.ref().columns() == rhs.ref().rows())) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
  }
  int v18 = 1065353216;
  cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>((uint64_t)v12, (uint64_t)v15);
  cva::SVD<cva::Matrix<float,0u,0u,false>,true>::decomposeDirect<0u,0u>(a1, (uint64_t)v12, a3);
  free(v12[0]);
}

void sub_1B89F1844(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9)
{
}

uint64_t cva::SVD<cva::Matrix<float,0u,0u,false>,true>::S(_DWORD *a1)
{
  unsigned int v2 = a1[18];
  LODWORD(v1) = a1[19];
  if (v1 >= v2) {
    uint64_t v1 = v2;
  }
  else {
    uint64_t v1 = v1;
  }
  if (v1 > a1[16]) {
    cva::SVD<cva::Matrix<float,0u,0u,false>,true>::S();
  }
  return v1 | (v1 << 32);
}

void cva::SVD<cva::Matrix<float,0u,0u,false>,true>::decomposeDirect<cva::MatrixMultExpr<cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>>>(uint64_t a1, void **a2, char a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  unsigned int v6 = a2 + 1;
  uint64_t v7 = (*(_DWORD *)(*a2[1] + 16) * *((_DWORD *)*a2 + 4));
  v12[0] = 0;
  v12[1] = 0;
  cva::MatrixData<float,0ul,0ul,false>::allocate(v12, v7);
  uint64_t v8 = *a2;
  uint64_t v9 = *v6;
  uint64_t v10 = **v6;
  int v11 = *(_DWORD *)(v10 + 16);
  int v13 = *((_DWORD *)*a2 + 4);
  int v14 = v11;
  uint64_t v16 = v8;
  int v17 = v9;
  if (v8[5] != *(_DWORD *)(v10 + 20)) {
    __assert_rtn("MatrixMultExpr", "matrixmultexpr.h", 100, "((lhs.ref().columns() == rhs.ref().rows())) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
  }
  int v18 = 1065353216;
  cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>>((uint64_t)v12, (uint64_t)v15);
  cva::SVD<cva::Matrix<float,0u,0u,false>,true>::decomposeDirect<0u,0u>(a1, (uint64_t)v12, a3);
  free(v12[0]);
}

void sub_1B89F19A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9)
{
}

void cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::Matrix<float,0u,0u,false>,cva::MatrixMultExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>>,cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>>>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  if (*(void *)v4 == *(void *)a1)
  {
    uint64_t v12 = (***(_DWORD ***)(*(void *)(a2 + 16) + 8) * *(_DWORD *)(v4 + 16));
    int v17 = 0;
    uint64_t v18 = 0;
    cva::MatrixData<float,0ul,0ul,false>::allocate(&v17, v12);
    int v13 = ***(_DWORD ***)(*(void *)(a2 + 16) + 8);
    LODWORD(v19) = *(_DWORD *)(*(void *)(a2 + 8) + 16);
    HIDWORD(v19) = v13;
    cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::Matrix<float,0u,0u,false>,cva::MatrixMultExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>>,cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>>>(&v17, a2);
    int v14 = *(void **)a1;
    uint64_t v15 = *(void *)(a1 + 8);
    uint64_t v16 = v18;
    *(void *)a1 = v17;
    *(void *)(a1 + _Block_object_dispose(&STACK[0x400], 8) = v16;
    int v17 = v14;
    uint64_t v18 = v15;
    *(void *)(a1 + 16) = v19;
    uint64_t v19 = 0;
    free(v14);
  }
  else
  {
    int v5 = *(_DWORD *)(a1 + 16);
    if (v5 != *(_DWORD *)(v4 + 16)
      || (v6 = *(_DWORD *)(a1 + 20), uint64_t v7 = *(uint64_t ***)(a2 + 16), v6 != *(_DWORD *)*v7[1]))
    {
      cva::Logger::instance((cva::Logger *)a1);
      cva::Logger::logInCategory();
      int v5 = *(_DWORD *)(a1 + 16);
      uint64_t v4 = *(void *)(a2 + 8);
      if (v5 != *(_DWORD *)(v4 + 16)
        || (uint64_t v7 = *(uint64_t ***)(a2 + 16), v6 = *(_DWORD *)*v7[1], *(_DWORD *)(a1 + 20) != v6))
      {
        cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>();
      }
    }
    if (*(_DWORD *)(v4 + 20) * v5)
    {
      uint64_t v8 = (v6 * *(_DWORD *)(**v7 + 20));
      if (v8)
      {
        int v17 = 0;
        uint64_t v18 = 0;
        cva::MatrixData<float,0ul,0ul,false>::allocate(&v17, v8);
        int v9 = *(_DWORD *)*v7[1];
        LODWORD(v19) = *(_DWORD *)(**v7 + 20);
        HIDWORD(v19) = v9;
        cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>>,cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>>((cva::Logger *)&v17, v7);
        cva::VecLib<float>::gemm();
      }
    }
    unsigned int v10 = v5 * v6;
    if (v10)
    {
      int v11 = *(void **)a1;
      bzero(v11, 4 * v10);
    }
  }
}

void sub_1B89F1BEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
}

void cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>>,cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>>(cva::Logger *a1, uint64_t **a2)
{
  int v4 = *((_DWORD *)a1 + 4);
  int v5 = *a2;
  uint64_t v6 = **a2;
  if (v4 != *(_DWORD *)(v6 + 20) || (unsigned int v7 = *((_DWORD *)a1 + 5), v8 = (unsigned int **)a2[1], v9 = *v8, v7 != **v8))
  {
    cva::Logger::instance(a1);
    cva::Logger::logInCategory();
    int v4 = *((_DWORD *)a1 + 4);
    int v5 = *a2;
    uint64_t v6 = **a2;
    if (v4 != *(_DWORD *)(v6 + 20) || (v8 = (unsigned int **)a2[1], v9 = *v8, unsigned int v7 = **v8, *((_DWORD *)a1 + 5) != v7)) {
      cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>();
    }
  }
  uint64_t v34 = v8;
  if (v7 >= v9[1]) {
    unsigned int v7 = v9[1];
  }
  if (v7 > *(_DWORD *)(v6 + 16)) {
    cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>>,cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>>();
  }
  v30[0] = v4;
  v30[1] = v7;
  int v31 = v5;
  uint64_t v32 = 0;
  int v25 = &v34;
  int v27 = v4;
  unsigned int v28 = v7;
  uint64_t v29 = &v25;
  v33[0] = v30;
  v33[1] = &v26;
  uint64_t v10 = *(void *)a1;
  v21[0] = v4;
  v21[1] = v7;
  uint64_t v22 = v10;
  int v23 = v4;
  int v24 = 0;
  cva::MatrixRef<float,0u,0u,false>::operator=<cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>,cva::detail::MulOp>>((uint64_t)v21, v33);
  unsigned int v11 = *(_DWORD *)(*v5 + 16);
  unsigned int v12 = *((_DWORD *)a1 + 5);
  BOOL v13 = v12 >= v11;
  unsigned int v14 = v12 - v11;
  if (v14 != 0 && v13)
  {
    int v15 = *((_DWORD *)a1 + 4);
    uint64_t v16 = *(void *)a1 + 4 * v15 * v11;
    unsigned int v17 = v15 * v14;
    BOOL v18 = v17 == 0;
    if (v17) {
      uint64_t v19 = (unsigned char *)v16;
    }
    else {
      uint64_t v19 = 0;
    }
    int v20 = (unsigned char *)(v16 + 4 * v17);
    if (v18) {
      int v20 = 0;
    }
    if (v19 != v20) {
      bzero(v19, ((v20 - v19 - 4) & 0xFFFFFFFFFFFFFFFCLL) + 4);
    }
  }
}

uint64_t cva::MatrixRef<float,0u,0u,false>::operator=<cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>,cva::detail::MulOp>>(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 8) - 4 * *(unsigned int *)(a1 + 20);
  if (***(void ***)(*a2 + 8) == v4 || **(void **)(****(void ****)(a2[1] + 16) + 8) == v4)
  {
    int v5 = *(_DWORD *)a1;
    int v6 = *(_DWORD *)(a1 + 4);
    v21[0] = 0;
    v21[1] = 0;
    cva::MatrixData<float,0ul,0ul,false>::allocate(v21, (v6 * v5));
    int v22 = v5;
    int v23 = v6;
    cva::detail::assignNoAlias<cva::Matrix<float,0u,0u,false>,cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>,cva::detail::MulOp>>((cva::Logger *)v21, a2);
    int v8 = *(_DWORD *)a1;
    if (*(_DWORD *)a1 != v22 || (int v9 = *(_DWORD *)(a1 + 4), v9 != v23))
    {
      cva::Logger::instance(v7);
      cva::Logger::logInCategory();
      int v8 = *(_DWORD *)a1;
      if (*(_DWORD *)a1 != v22 || (int v9 = *(_DWORD *)(a1 + 4), v9 != v23)) {
        __assert_rtn("assert_equal_size", "matrixfun.h", 163, "(lhs.rows() == rhs.rows() && lhs.columns() == rhs.columns()) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
      }
    }
    int v10 = *(_DWORD *)(a1 + 16);
    BOOL v11 = v8 * v9 == 0;
    if (v8 * v9) {
      unsigned int v12 = *(_DWORD **)(a1 + 8);
    }
    else {
      unsigned int v12 = 0;
    }
    uint64_t v13 = *(void *)(a1 + 8) + 4 * (v10 * v9);
    if (v11) {
      uint64_t v13 = 0;
    }
    unsigned int v14 = v21[0];
    if (v12 != (_DWORD *)v13)
    {
      int v15 = 0;
      unsigned int v16 = v10 - v8;
      unsigned int v17 = (int *)v21[0];
      do
      {
        int v18 = *v17++;
        *unsigned int v12 = v18;
        if (v15 + 1 >= v8) {
          unsigned int v19 = v16;
        }
        else {
          unsigned int v19 = 0;
        }
        v12 += v19 + 1;
        if (v15 + 1 < v8) {
          ++v15;
        }
        else {
          int v15 = 0;
        }
      }
      while (v12 != (_DWORD *)v13);
    }
    free(v14);
  }
  else
  {
    cva::detail::assignNoAlias<cva::MatrixRef<float,0u,0u,false>,cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>,cva::detail::MulOp>>(a1, a2);
  }
  return a1;
}

void sub_1B89F1F44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
}

void cva::detail::assignNoAlias<cva::Matrix<float,0u,0u,false>,cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>,cva::detail::MulOp>>(cva::Logger *a1, void *a2)
{
  unsigned int v4 = *((_DWORD *)a1 + 4);
  int v5 = (_DWORD *)*a2;
  if (v4 != *(_DWORD *)*a2 || (int v6 = *((_DWORD *)a1 + 5), v6 != v5[1]))
  {
    cva::Logger::instance(a1);
    cva::Logger::logInCategory();
    unsigned int v4 = *((_DWORD *)a1 + 4);
    int v5 = (_DWORD *)*a2;
    if (v4 != *(_DWORD *)*a2 || (int v6 = *((_DWORD *)a1 + 5), v6 != v5[1])) {
      cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>();
    }
  }
  uint64_t v7 = v6 * v4;
  if (v7)
  {
    unint64_t v8 = 0;
    unint64_t v9 = 0;
    uint64_t v10 = a2[1];
    BOOL v11 = *(float **)a1;
    uint64_t v12 = 4 * v7;
    do
    {
      if (v4 <= v9 || v5[1] <= HIDWORD(v9)) {
        cva::detail::assignNoAlias<cva::Matrix<float,0u,0u,false>,cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>,cva::detail::MulOp>>();
      }
      unsigned int v13 = v5[5] + HIDWORD(v9);
      uint64_t v14 = **((void **)v5 + 1);
      unsigned int v15 = *(_DWORD *)(v14 + 16);
      if (v15 <= v13 || (unsigned int v16 = v5[4] + v9, v16 >= *(_DWORD *)(v14 + 20))) {
        cva::MatrixRef<float,3u,3u,false>::operator=<cva::MatrixTransposeExpr<cva::MatrixRef<float const,3u,3u,false>>>();
      }
      float v17 = *(float *)(*(void *)v14 + 4 * (v13 + v15 * v16));
      *v11++ = v17
             * cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>::operator()(v10, v8, HIDWORD(v8));
      uint64_t v18 = (v9 + 1);
      unsigned int v4 = *v5;
      if (*v5 <= (int)v18) {
        unint64_t v9 = (v9 & 0xFFFFFFFF00000000) + 0x100000000;
      }
      else {
        unint64_t v9 = v9 & 0xFFFFFFFF00000000 | v18;
      }
      uint64_t v19 = (v8 + 1);
      if (*(_DWORD *)(v10 + 4) <= (int)v19) {
        unint64_t v8 = (v8 & 0xFFFFFFFF00000000) + 0x100000000;
      }
      else {
        unint64_t v8 = v8 & 0xFFFFFFFF00000000 | v19;
      }
      v12 -= 4;
    }
    while (v12);
  }
}

void cva::detail::assignNoAlias<cva::MatrixRef<float,0u,0u,false>,cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>,cva::detail::MulOp>>(uint64_t a1, void *a2)
{
  signed int v4 = *(_DWORD *)a1;
  int v5 = (_DWORD *)*a2;
  if (*(_DWORD *)a1 != *(_DWORD *)*a2 || (int v6 = *(_DWORD *)(a1 + 4), v6 != v5[1]))
  {
    cva::Logger::instance((cva::Logger *)a1);
    cva::Logger::logInCategory();
    signed int v4 = *(_DWORD *)a1;
    int v5 = (_DWORD *)*a2;
    if (*(_DWORD *)a1 != *(_DWORD *)*a2 || (int v6 = *(_DWORD *)(a1 + 4), v6 != v5[1])) {
      cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>();
    }
  }
  int v7 = v6 * v4;
  int v8 = *(_DWORD *)(a1 + 16);
  if (v6 * v4) {
    unint64_t v9 = *(float **)(a1 + 8);
  }
  else {
    unint64_t v9 = 0;
  }
  uint64_t v10 = *(void *)(a1 + 8) + 4 * (v8 * v6);
  if (v7) {
    BOOL v11 = (float *)v10;
  }
  else {
    BOOL v11 = 0;
  }
  if (v9 != v11)
  {
    unint64_t v12 = 0;
    unint64_t v13 = 0;
    int v14 = 0;
    uint64_t v15 = a2[1];
    unsigned int v16 = v8 - v4;
    unsigned int v17 = v4;
    do
    {
      if (v17 <= v13 || v5[1] <= HIDWORD(v13)) {
        cva::detail::assignNoAlias<cva::Matrix<float,0u,0u,false>,cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>,cva::detail::MulOp>>();
      }
      unsigned int v18 = v5[5] + HIDWORD(v13);
      uint64_t v19 = **((void **)v5 + 1);
      unsigned int v20 = *(_DWORD *)(v19 + 16);
      if (v20 <= v18 || (unsigned int v21 = v5[4] + v13, v21 >= *(_DWORD *)(v19 + 20))) {
        cva::MatrixRef<float,3u,3u,false>::operator=<cva::MatrixTransposeExpr<cva::MatrixRef<float const,3u,3u,false>>>();
      }
      float v22 = *(float *)(*(void *)v19 + 4 * (v18 + v20 * v21));
      float *v9 = v22
          * cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>::operator()(v15, v12, HIDWORD(v12));
      uint64_t v23 = (v13 + 1);
      unsigned int v17 = *v5;
      if (*v5 <= (int)v23) {
        unint64_t v13 = (v13 & 0xFFFFFFFF00000000) + 0x100000000;
      }
      else {
        unint64_t v13 = v13 & 0xFFFFFFFF00000000 | v23;
      }
      uint64_t v24 = (v12 + 1);
      if (*(_DWORD *)(v15 + 4) <= (int)v24) {
        unint64_t v12 = (v12 & 0xFFFFFFFF00000000) + 0x100000000;
      }
      else {
        unint64_t v12 = v12 & 0xFFFFFFFF00000000 | v24;
      }
      if (v14 + 1 >= v4) {
        unsigned int v25 = v16;
      }
      else {
        unsigned int v25 = 0;
      }
      v9 += v25 + 1;
      if (v14 + 1 < v4) {
        ++v14;
      }
      else {
        int v14 = 0;
      }
    }
    while (v9 != v11);
  }
}

float cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>::operator()(uint64_t a1, unsigned int a2, unsigned int a3)
{
  if (*(_DWORD *)(a1 + 4) <= a2 || *(_DWORD *)(a1 + 8) <= a3) {
    cva::MatrixRef<float,3u,3u,false>::operator=<cva::MatrixTransposeExpr<cva::MatrixRef<float const,3u,3u,false>>>();
  }
  char v3 = ***(float ****)(a1 + 16);
  unsigned int v4 = *(_DWORD *)(*(void *)v3 + 4);
  if (**(_DWORD **)v3 < v4) {
    unsigned int v4 = **(_DWORD **)v3;
  }
  unsigned int v5 = a3 % v4;
  uint64_t v6 = *(void *)(*(void *)v3 + 8);
  if (*(_DWORD *)(v6 + 16) <= v5) {
    cva::MatrixRef<float,3u,3u,false>::operator=<cva::MatrixTransposeExpr<cva::MatrixRef<float const,3u,3u,false>>>();
  }
  float v7 = *(float *)(*(void *)v6 + 4 * v5);
  float v8 = fabsf(v7);
  float result = 1.0 / v7;
  if (v8 < v3[2]) {
    return 0.0;
  }
  return result;
}

void cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t v5 = **(void **)(a2 + 16);
  if (*(void *)v4 == *(void *)a1 || *(void *)v5 == *(void *)a1)
  {
    uint64_t v8 = (*(_DWORD *)(v5 + 16) * *(_DWORD *)(v4 + 16));
    int v14 = 0;
    uint64_t v15 = 0;
    cva::MatrixData<float,0ul,0ul,false>::allocate(&v14, v8);
    int v9 = *(_DWORD *)(**(void **)(a2 + 16) + 16);
    LODWORD(v16) = *(_DWORD *)(*(void *)(a2 + 8) + 16);
    HIDWORD(v16) = v9;
    cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>>(&v14, a2);
    uint64_t v10 = *(void **)a1;
    uint64_t v11 = *(void *)(a1 + 8);
    uint64_t v12 = v15;
    *(void *)a1 = v14;
    *(void *)(a1 + _Block_object_dispose(&STACK[0x400], 8) = v12;
    int v14 = v10;
    uint64_t v15 = v11;
    *(void *)(a1 + 16) = v16;
    uint64_t v16 = 0;
    free(v10);
  }
  else
  {
    int v6 = *(_DWORD *)(a1 + 16);
    if (v6 != *(_DWORD *)(v4 + 16) || (int v7 = *(_DWORD *)(a1 + 20), v7 != *(_DWORD *)(v5 + 16)))
    {
      cva::Logger::instance((cva::Logger *)a1);
      cva::Logger::logInCategory();
      int v6 = *(_DWORD *)(a1 + 16);
      uint64_t v4 = *(void *)(a2 + 8);
      if (v6 != *(_DWORD *)(v4 + 16)
        || (uint64_t v5 = **(void **)(a2 + 16), v7 = *(_DWORD *)(v5 + 16), *(_DWORD *)(a1 + 20) != v7))
      {
        cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>();
      }
    }
    if (*(_DWORD *)(v4 + 20) * v6 && v7 * *(_DWORD *)(v5 + 20)) {
      cva::VecLib<float>::gemm();
    }
    if (v6 * v7)
    {
      unint64_t v13 = *(void **)a1;
      bzero(v13, 4 * (v6 * v7));
    }
  }
}

void sub_1B89F2518(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
}

void cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixMultExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>>>,cva::Matrix<float,0u,0u,false>>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 16);
  if (*(void *)v4 == *(void *)a1)
  {
    uint64_t v12 = (*(_DWORD *)(v4 + 20) * *(_DWORD *)(***(void ***)(a2 + 8) + 4));
    unsigned int v17 = 0;
    uint64_t v18 = 0;
    cva::MatrixData<float,0ul,0ul,false>::allocate(&v17, v12);
    int v13 = *(_DWORD *)(*(void *)(a2 + 16) + 20);
    LODWORD(v19) = *(_DWORD *)(***(void ***)(a2 + 8) + 4);
    HIDWORD(v19) = v13;
    cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixMultExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>>>,cva::Matrix<float,0u,0u,false>>(&v17, a2);
    int v14 = *(void **)a1;
    uint64_t v15 = *(void *)(a1 + 8);
    uint64_t v16 = v18;
    *(void *)a1 = v17;
    *(void *)(a1 + _Block_object_dispose(&STACK[0x400], 8) = v16;
    unsigned int v17 = v14;
    uint64_t v18 = v15;
    *(void *)(a1 + 16) = v19;
    uint64_t v19 = 0;
    free(v14);
  }
  else
  {
    int v5 = *(_DWORD *)(a1 + 16);
    int v6 = *(void ***)(a2 + 8);
    if (v5 != *(_DWORD *)(**v6 + 4) || (int v7 = *(_DWORD *)(a1 + 20), v7 != *(_DWORD *)(v4 + 20)))
    {
      cva::Logger::instance((cva::Logger *)a1);
      cva::Logger::logInCategory();
      int v5 = *(_DWORD *)(a1 + 16);
      int v6 = *(void ***)(a2 + 8);
      if (v5 != *(_DWORD *)(**v6 + 4)
        || (uint64_t v4 = *(void *)(a2 + 16), v7 = *(_DWORD *)(v4 + 20), *(_DWORD *)(a1 + 20) != v7))
      {
        cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>();
      }
    }
    uint64_t v8 = (*(_DWORD *)(*v6[1] + 16) * v5);
    if (v8 && v7 * *(_DWORD *)(v4 + 16))
    {
      unsigned int v17 = 0;
      uint64_t v18 = 0;
      cva::MatrixData<float,0ul,0ul,false>::allocate(&v17, v8);
      int v9 = *(_DWORD *)(*v6[1] + 16);
      LODWORD(v19) = *(_DWORD *)(**v6 + 4);
      HIDWORD(v19) = v9;
      cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>>>((cva::Logger *)&v17, (uint64_t)v6);
      cva::VecLib<float>::gemm();
    }
    unsigned int v10 = v5 * v7;
    if (v10)
    {
      uint64_t v11 = *(void **)a1;
      bzero(v11, 4 * v10);
    }
  }
}

void sub_1B89F2758(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
}

uint64_t cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>>>(cva::Logger *a1, uint64_t a2)
{
  unsigned int v4 = *((_DWORD *)a1 + 4);
  int v5 = *(unsigned int ***)a2;
  int v6 = **(unsigned int ***)a2;
  if (v4 != v6[1] || (int v7 = *((_DWORD *)a1 + 5), v8 = *(uint64_t **)(a2 + 8), v9 = *v8, v7 != *(_DWORD *)(*v8 + 16)))
  {
    cva::Logger::instance(a1);
    cva::Logger::logInCategory();
    unsigned int v4 = *((_DWORD *)a1 + 4);
    int v5 = *(unsigned int ***)a2;
    int v6 = **(unsigned int ***)a2;
    if (v4 != v6[1] || (v8 = *(uint64_t **)(a2 + 8), v9 = *v8, int v7 = *(_DWORD *)(*v8 + 16), *((_DWORD *)a1 + 5) != v7)) {
      cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>();
    }
  }
  unsigned int v35 = v5;
  unsigned int v10 = *v6;
  if (*v6 >= v4) {
    unsigned int v10 = v4;
  }
  if (v10 > *(_DWORD *)(v9 + 20)) {
    cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>>,cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>>();
  }
  v31[0] = v10;
  v31[1] = v7;
  uint64_t v32 = v8;
  uint64_t v33 = 0;
  unsigned int v28 = v10;
  int v29 = v7;
  int v30 = &v35;
  v34[0] = v31;
  v34[1] = &v27;
  uint64_t v11 = *(void *)a1;
  v23[0] = v10;
  v23[1] = v7;
  uint64_t v24 = v11;
  unsigned int v25 = v4;
  int v26 = 0;
  uint64_t result = cva::MatrixRef<float,0u,0u,false>::operator=<cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const>,1u,0u>,cva::detail::MulOp>>((uint64_t)v23, v34);
  uint64_t v13 = *(unsigned int *)(*v8 + 20);
  unsigned int v14 = *((_DWORD *)a1 + 4);
  if (v14 > v13)
  {
    int v15 = v14 - v13;
    int v16 = *((_DWORD *)a1 + 5);
    int v17 = v16 * (v14 - v13);
    BOOL v18 = v17 == 0;
    if (v17) {
      uint64_t v19 = (_DWORD *)(*(void *)a1 + 4 * v13);
    }
    else {
      uint64_t v19 = 0;
    }
    uint64_t v20 = *(void *)a1 + 4 * v13 + 4 * v16 * v14;
    if (v18) {
      uint64_t v20 = 0;
    }
    if (v19 != (_DWORD *)v20)
    {
      int v21 = 0;
      do
      {
        *uint64_t v19 = 0;
        if (v21 + 1 >= v15) {
          unsigned int v22 = v13;
        }
        else {
          unsigned int v22 = 0;
        }
        v19 += v22 + 1;
        if (v21 + 1 < v15) {
          ++v21;
        }
        else {
          int v21 = 0;
        }
      }
      while (v19 != (_DWORD *)v20);
    }
  }
  return result;
}

uint64_t cva::MatrixRef<float,0u,0u,false>::operator=<cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const>,1u,0u>,cva::detail::MulOp>>(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 8) - 4 * *(unsigned int *)(a1 + 20);
  if (***(void ***)(*a2 + 8) == v4 || **(void **)(***(void ***)(a2[1] + 16) + 8) == v4)
  {
    int v5 = *(_DWORD *)a1;
    int v6 = *(_DWORD *)(a1 + 4);
    v21[0] = 0;
    v21[1] = 0;
    cva::MatrixData<float,0ul,0ul,false>::allocate(v21, (v6 * v5));
    int v22 = v5;
    int v23 = v6;
    cva::detail::assignNoAlias<cva::Matrix<float,0u,0u,false>,cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const>,1u,0u>,cva::detail::MulOp>>((cva::Logger *)v21, a2);
    int v8 = *(_DWORD *)a1;
    if (*(_DWORD *)a1 != v22 || (int v9 = *(_DWORD *)(a1 + 4), v9 != v23))
    {
      cva::Logger::instance(v7);
      cva::Logger::logInCategory();
      int v8 = *(_DWORD *)a1;
      if (*(_DWORD *)a1 != v22 || (int v9 = *(_DWORD *)(a1 + 4), v9 != v23)) {
        __assert_rtn("assert_equal_size", "matrixfun.h", 163, "(lhs.rows() == rhs.rows() && lhs.columns() == rhs.columns()) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
      }
    }
    int v10 = *(_DWORD *)(a1 + 16);
    BOOL v11 = v8 * v9 == 0;
    if (v8 * v9) {
      uint64_t v12 = *(_DWORD **)(a1 + 8);
    }
    else {
      uint64_t v12 = 0;
    }
    uint64_t v13 = *(void *)(a1 + 8) + 4 * (v10 * v9);
    if (v11) {
      uint64_t v13 = 0;
    }
    unsigned int v14 = v21[0];
    if (v12 != (_DWORD *)v13)
    {
      int v15 = 0;
      unsigned int v16 = v10 - v8;
      int v17 = (int *)v21[0];
      do
      {
        int v18 = *v17++;
        *uint64_t v12 = v18;
        if (v15 + 1 >= v8) {
          unsigned int v19 = v16;
        }
        else {
          unsigned int v19 = 0;
        }
        v12 += v19 + 1;
        if (v15 + 1 < v8) {
          ++v15;
        }
        else {
          int v15 = 0;
        }
      }
      while (v12 != (_DWORD *)v13);
    }
    free(v14);
  }
  else
  {
    cva::detail::assignNoAlias<cva::MatrixRef<float,0u,0u,false>,cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const>,1u,0u>,cva::detail::MulOp>>(a1, a2);
  }
  return a1;
}

void sub_1B89F2ABC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
}

void cva::detail::assignNoAlias<cva::Matrix<float,0u,0u,false>,cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const>,1u,0u>,cva::detail::MulOp>>(cva::Logger *a1, void *a2)
{
  unsigned int v4 = *((_DWORD *)a1 + 4);
  int v5 = (_DWORD *)*a2;
  if (v4 != *(_DWORD *)*a2 || (int v6 = *((_DWORD *)a1 + 5), v6 != v5[1]))
  {
    cva::Logger::instance(a1);
    cva::Logger::logInCategory();
    unsigned int v4 = *((_DWORD *)a1 + 4);
    int v5 = (_DWORD *)*a2;
    if (v4 != *(_DWORD *)*a2 || (int v6 = *((_DWORD *)a1 + 5), v6 != v5[1])) {
      cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>();
    }
  }
  uint64_t v7 = v6 * v4;
  if (v7)
  {
    unint64_t v8 = 0;
    unint64_t v9 = 0;
    uint64_t v10 = a2[1];
    BOOL v11 = *(float **)a1;
    uint64_t v12 = 4 * v7;
    do
    {
      if (v4 <= v9 || v5[1] <= HIDWORD(v9)) {
        cva::detail::assignNoAlias<cva::Matrix<float,0u,0u,false>,cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>,cva::detail::MulOp>>();
      }
      unsigned int v13 = v5[5] + HIDWORD(v9);
      uint64_t v14 = **((void **)v5 + 1);
      unsigned int v15 = *(_DWORD *)(v14 + 16);
      if (v15 <= v13 || (unsigned int v16 = v5[4] + v9, v16 >= *(_DWORD *)(v14 + 20))) {
        cva::MatrixRef<float,3u,3u,false>::operator=<cva::MatrixTransposeExpr<cva::MatrixRef<float const,3u,3u,false>>>();
      }
      float v17 = *(float *)(*(void *)v14 + 4 * (v13 + v15 * v16));
      *v11++ = v17
             * cva::MatrixRepeatExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const>,1u,0u>::operator()(v10, v8, HIDWORD(v8));
      uint64_t v18 = (v9 + 1);
      unsigned int v4 = *v5;
      if (*v5 <= (int)v18) {
        unint64_t v9 = (v9 & 0xFFFFFFFF00000000) + 0x100000000;
      }
      else {
        unint64_t v9 = v9 & 0xFFFFFFFF00000000 | v18;
      }
      uint64_t v19 = (v8 + 1);
      if (*(_DWORD *)(v10 + 4) <= (int)v19) {
        unint64_t v8 = (v8 & 0xFFFFFFFF00000000) + 0x100000000;
      }
      else {
        unint64_t v8 = v8 & 0xFFFFFFFF00000000 | v19;
      }
      v12 -= 4;
    }
    while (v12);
  }
}

void cva::detail::assignNoAlias<cva::MatrixRef<float,0u,0u,false>,cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const>,1u,0u>,cva::detail::MulOp>>(uint64_t a1, void *a2)
{
  signed int v4 = *(_DWORD *)a1;
  int v5 = (_DWORD *)*a2;
  if (*(_DWORD *)a1 != *(_DWORD *)*a2 || (int v6 = *(_DWORD *)(a1 + 4), v6 != v5[1]))
  {
    cva::Logger::instance((cva::Logger *)a1);
    cva::Logger::logInCategory();
    signed int v4 = *(_DWORD *)a1;
    int v5 = (_DWORD *)*a2;
    if (*(_DWORD *)a1 != *(_DWORD *)*a2 || (int v6 = *(_DWORD *)(a1 + 4), v6 != v5[1])) {
      cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>();
    }
  }
  int v7 = v6 * v4;
  int v8 = *(_DWORD *)(a1 + 16);
  if (v6 * v4) {
    unint64_t v9 = *(float **)(a1 + 8);
  }
  else {
    unint64_t v9 = 0;
  }
  uint64_t v10 = *(void *)(a1 + 8) + 4 * (v8 * v6);
  if (v7) {
    BOOL v11 = (float *)v10;
  }
  else {
    BOOL v11 = 0;
  }
  if (v9 != v11)
  {
    unint64_t v12 = 0;
    unint64_t v13 = 0;
    int v14 = 0;
    uint64_t v15 = a2[1];
    unsigned int v16 = v8 - v4;
    unsigned int v17 = v4;
    do
    {
      if (v17 <= v13 || v5[1] <= HIDWORD(v13)) {
        cva::detail::assignNoAlias<cva::Matrix<float,0u,0u,false>,cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>,cva::detail::MulOp>>();
      }
      unsigned int v18 = v5[5] + HIDWORD(v13);
      uint64_t v19 = **((void **)v5 + 1);
      unsigned int v20 = *(_DWORD *)(v19 + 16);
      if (v20 <= v18 || (unsigned int v21 = v5[4] + v13, v21 >= *(_DWORD *)(v19 + 20))) {
        cva::MatrixRef<float,3u,3u,false>::operator=<cva::MatrixTransposeExpr<cva::MatrixRef<float const,3u,3u,false>>>();
      }
      float v22 = *(float *)(*(void *)v19 + 4 * (v18 + v20 * v21));
      float *v9 = v22
          * cva::MatrixRepeatExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const>,1u,0u>::operator()(v15, v12, HIDWORD(v12));
      uint64_t v23 = (v13 + 1);
      unsigned int v17 = *v5;
      if (*v5 <= (int)v23) {
        unint64_t v13 = (v13 & 0xFFFFFFFF00000000) + 0x100000000;
      }
      else {
        unint64_t v13 = v13 & 0xFFFFFFFF00000000 | v23;
      }
      uint64_t v24 = (v12 + 1);
      if (*(_DWORD *)(v15 + 4) <= (int)v24) {
        unint64_t v12 = (v12 & 0xFFFFFFFF00000000) + 0x100000000;
      }
      else {
        unint64_t v12 = v12 & 0xFFFFFFFF00000000 | v24;
      }
      if (v14 + 1 >= v4) {
        unsigned int v25 = v16;
      }
      else {
        unsigned int v25 = 0;
      }
      v9 += v25 + 1;
      if (v14 + 1 < v4) {
        ++v14;
      }
      else {
        int v14 = 0;
      }
    }
    while (v9 != v11);
  }
}

float cva::MatrixRepeatExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const>,1u,0u>::operator()(uint64_t a1, unsigned int a2, unsigned int a3)
{
  if (*(_DWORD *)(a1 + 4) <= a2 || *(_DWORD *)(a1 + 8) <= a3) {
    cva::MatrixRef<float,3u,3u,false>::operator=<cva::MatrixTransposeExpr<cva::MatrixRef<float const,3u,3u,false>>>();
  }
  char v3 = **(float ***)(a1 + 16);
  unsigned int v4 = *(_DWORD *)(*(void *)v3 + 4);
  if (**(_DWORD **)v3 < v4) {
    unsigned int v4 = **(_DWORD **)v3;
  }
  unsigned int v5 = a2 % v4;
  uint64_t v6 = *(void *)(*(void *)v3 + 8);
  if (*(_DWORD *)(v6 + 16) <= v5) {
    cva::MatrixRef<float,3u,3u,false>::operator=<cva::MatrixTransposeExpr<cva::MatrixRef<float const,3u,3u,false>>>();
  }
  float v7 = *(float *)(*(void *)v6 + 4 * v5);
  float v8 = fabsf(v7);
  float result = 1.0 / v7;
  if (v8 < v3[2]) {
    return 0.0;
  }
  return result;
}

void cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixMultExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = **(void **)(a2 + 16);
  if (*(void *)v4 == *(void *)a1)
  {
    uint64_t v12 = (*(_DWORD *)(v4 + 16) * *(_DWORD *)(***(void ***)(a2 + 8) + 20));
    unsigned int v17 = 0;
    uint64_t v18 = 0;
    cva::MatrixData<float,0ul,0ul,false>::allocate(&v17, v12);
    int v13 = *(_DWORD *)(**(void **)(a2 + 16) + 16);
    LODWORD(v19) = *(_DWORD *)(***(void ***)(a2 + 8) + 20);
    HIDWORD(v19) = v13;
    cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixMultExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>>(&v17, a2);
    int v14 = *(void **)a1;
    uint64_t v15 = *(void *)(a1 + 8);
    uint64_t v16 = v18;
    *(void *)a1 = v17;
    *(void *)(a1 + _Block_object_dispose(&STACK[0x400], 8) = v16;
    unsigned int v17 = v14;
    uint64_t v18 = v15;
    *(void *)(a1 + 16) = v19;
    uint64_t v19 = 0;
    free(v14);
  }
  else
  {
    int v5 = *(_DWORD *)(a1 + 16);
    uint64_t v6 = *(uint64_t ***)(a2 + 8);
    if (v5 != *(_DWORD *)(**v6 + 20) || (int v7 = *(_DWORD *)(a1 + 20), v7 != *(_DWORD *)(v4 + 16)))
    {
      cva::Logger::instance((cva::Logger *)a1);
      cva::Logger::logInCategory();
      int v5 = *(_DWORD *)(a1 + 16);
      uint64_t v6 = *(uint64_t ***)(a2 + 8);
      if (v5 != *(_DWORD *)(**v6 + 20)
        || (uint64_t v4 = **(void **)(a2 + 16), v7 = *(_DWORD *)(v4 + 16), *(_DWORD *)(a1 + 20) != v7))
      {
        cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>();
      }
    }
    uint64_t v8 = (*(_DWORD *)*v6[1] * v5);
    if (v8 && v7 * *(_DWORD *)(v4 + 20))
    {
      unsigned int v17 = 0;
      uint64_t v18 = 0;
      cva::MatrixData<float,0ul,0ul,false>::allocate(&v17, v8);
      int v9 = *(_DWORD *)*v6[1];
      LODWORD(v19) = *(_DWORD *)(**v6 + 20);
      HIDWORD(v19) = v9;
      cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>>((cva::Logger *)&v17, v6);
      cva::VecLib<float>::gemm();
    }
    unsigned int v10 = v5 * v7;
    if (v10)
    {
      BOOL v11 = *(void **)a1;
      bzero(v11, 4 * v10);
    }
  }
}

void sub_1B89F311C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
}

void cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>>(cva::Logger *a1, uint64_t **a2)
{
  int v4 = *((_DWORD *)a1 + 4);
  int v5 = *a2;
  uint64_t v6 = **a2;
  if (v4 != *(_DWORD *)(v6 + 20) || (unsigned int v7 = *((_DWORD *)a1 + 5), v8 = (unsigned int **)a2[1], v9 = *v8, v7 != **v8))
  {
    cva::Logger::instance(a1);
    cva::Logger::logInCategory();
    int v4 = *((_DWORD *)a1 + 4);
    int v5 = *a2;
    uint64_t v6 = **a2;
    if (v4 != *(_DWORD *)(v6 + 20) || (v8 = (unsigned int **)a2[1], v9 = *v8, unsigned int v7 = **v8, *((_DWORD *)a1 + 5) != v7)) {
      cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>();
    }
  }
  uint64_t v34 = v8;
  if (v7 >= v9[1]) {
    unsigned int v7 = v9[1];
  }
  if (v7 > *(_DWORD *)(v6 + 16)) {
    cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>>,cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>>();
  }
  v30[0] = v4;
  v30[1] = v7;
  int v31 = v5;
  uint64_t v32 = 0;
  unsigned int v25 = &v34;
  int v27 = v4;
  unsigned int v28 = v7;
  int v29 = &v25;
  v33[0] = v30;
  v33[1] = &v26;
  uint64_t v10 = *(void *)a1;
  v21[0] = v4;
  v21[1] = v7;
  uint64_t v22 = v10;
  int v23 = v4;
  int v24 = 0;
  cva::MatrixRef<float,0u,0u,false>::operator=<cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>,cva::detail::MulOp>>((uint64_t)v21, v33);
  unsigned int v11 = *(_DWORD *)(*v5 + 16);
  unsigned int v12 = *((_DWORD *)a1 + 5);
  BOOL v13 = v12 >= v11;
  unsigned int v14 = v12 - v11;
  if (v14 != 0 && v13)
  {
    int v15 = *((_DWORD *)a1 + 4);
    uint64_t v16 = *(void *)a1 + 4 * v15 * v11;
    unsigned int v17 = v15 * v14;
    BOOL v18 = v17 == 0;
    if (v17) {
      uint64_t v19 = (unsigned char *)v16;
    }
    else {
      uint64_t v19 = 0;
    }
    unsigned int v20 = (unsigned char *)(v16 + 4 * v17);
    if (v18) {
      unsigned int v20 = 0;
    }
    if (v19 != v20) {
      bzero(v19, ((v20 - v19 - 4) & 0xFFFFFFFFFFFFFFFCLL) + 4);
    }
  }
}

uint64_t cva::MatrixRef<float,0u,0u,false>::operator=<cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>,cva::detail::MulOp>>(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 8) - 4 * *(unsigned int *)(a1 + 20);
  if (***(void ***)(*a2 + 8) == v4 || **(void **)(****(void ****)(a2[1] + 16) + 8) == v4)
  {
    int v5 = *(_DWORD *)a1;
    int v6 = *(_DWORD *)(a1 + 4);
    v21[0] = 0;
    v21[1] = 0;
    cva::MatrixData<float,0ul,0ul,false>::allocate(v21, (v6 * v5));
    int v22 = v5;
    int v23 = v6;
    cva::detail::assignNoAlias<cva::Matrix<float,0u,0u,false>,cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>,cva::detail::MulOp>>((cva::Logger *)v21, a2);
    int v8 = *(_DWORD *)a1;
    if (*(_DWORD *)a1 != v22 || (int v9 = *(_DWORD *)(a1 + 4), v9 != v23))
    {
      cva::Logger::instance(v7);
      cva::Logger::logInCategory();
      int v8 = *(_DWORD *)a1;
      if (*(_DWORD *)a1 != v22 || (int v9 = *(_DWORD *)(a1 + 4), v9 != v23)) {
        __assert_rtn("assert_equal_size", "matrixfun.h", 163, "(lhs.rows() == rhs.rows() && lhs.columns() == rhs.columns()) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
      }
    }
    int v10 = *(_DWORD *)(a1 + 16);
    BOOL v11 = v8 * v9 == 0;
    if (v8 * v9) {
      unsigned int v12 = *(_DWORD **)(a1 + 8);
    }
    else {
      unsigned int v12 = 0;
    }
    uint64_t v13 = *(void *)(a1 + 8) + 4 * (v10 * v9);
    if (v11) {
      uint64_t v13 = 0;
    }
    unsigned int v14 = v21[0];
    if (v12 != (_DWORD *)v13)
    {
      int v15 = 0;
      unsigned int v16 = v10 - v8;
      unsigned int v17 = (int *)v21[0];
      do
      {
        int v18 = *v17++;
        *unsigned int v12 = v18;
        if (v15 + 1 >= v8) {
          unsigned int v19 = v16;
        }
        else {
          unsigned int v19 = 0;
        }
        v12 += v19 + 1;
        if (v15 + 1 < v8) {
          ++v15;
        }
        else {
          int v15 = 0;
        }
      }
      while (v12 != (_DWORD *)v13);
    }
    free(v14);
  }
  else
  {
    cva::detail::assignNoAlias<cva::MatrixRef<float,0u,0u,false>,cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>,cva::detail::MulOp>>(a1, a2);
  }
  return a1;
}

void sub_1B89F3474(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
}

void cva::assign<false,false,cva::Matrix<float,0u,1u,false>,cva::Matrix<float,0u,0u,false>,cva::Matrix<float,0u,1u,false>>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  if (*(void *)v4 == *(void *)a1 || **(void **)(a2 + 16) == *(void *)a1)
  {
    uint64_t v6 = *(unsigned int *)(v4 + 16);
    unsigned int v12 = 0;
    uint64_t v13 = 0;
    cva::MatrixData<float,0ul,0ul,false>::allocate(&v12, v6);
    int v14 = *(_DWORD *)(*(void *)(a2 + 8) + 16);
    cva::assign<false,false,cva::Matrix<float,0u,1u,false>,cva::Matrix<float,0u,0u,false>,cva::Matrix<float,0u,1u,false>>(&v12, a2);
    unsigned int v7 = *(void **)a1;
    uint64_t v8 = *(void *)(a1 + 8);
    uint64_t v9 = v13;
    *(void *)a1 = v12;
    *(void *)(a1 + _Block_object_dispose(&STACK[0x400], 8) = v9;
    unsigned int v12 = v7;
    uint64_t v13 = v8;
    *(_DWORD *)(a1 + 16) = v14;
    int v14 = 0;
    free(v7);
  }
  else
  {
    unsigned int v5 = *(_DWORD *)(a1 + 16);
    if (v5 != *(_DWORD *)(v4 + 16))
    {
      cva::Logger::instance((cva::Logger *)a1);
      cva::Logger::logInCategory();
      unsigned int v5 = *(_DWORD *)(a1 + 16);
      uint64_t v4 = *(void *)(a2 + 8);
      if (v5 != *(_DWORD *)(v4 + 16)) {
        cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>();
      }
    }
    if (*(_DWORD *)(v4 + 20) * v5 && *(_DWORD *)(*(void *)(a2 + 16) + 16)) {
      cva::VecLib<float>::gemv();
    }
    if (v5)
    {
      int v10 = *(void **)a1;
      size_t v11 = 4 * v5;
      bzero(v10, v11);
    }
  }
}

void sub_1B89F35F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
}

void cva::assign<false,false,cva::Matrix<float,0u,1u,false>,cva::Matrix<float,0u,0u,false>,cva::Matrix<float,9u,1u,false>>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  if (*(void *)v4 == *(void *)a1 || *(void *)(a2 + 16) == *(void *)a1)
  {
    uint64_t v6 = *(unsigned int *)(v4 + 16);
    unsigned int v12 = 0;
    uint64_t v13 = 0;
    cva::MatrixData<float,0ul,0ul,false>::allocate(&v12, v6);
    int v14 = *(_DWORD *)(*(void *)(a2 + 8) + 16);
    cva::assign<false,false,cva::Matrix<float,0u,1u,false>,cva::Matrix<float,0u,0u,false>,cva::Matrix<float,9u,1u,false>>(&v12, a2);
    unsigned int v7 = *(void **)a1;
    uint64_t v8 = *(void *)(a1 + 8);
    uint64_t v9 = v13;
    *(void *)a1 = v12;
    *(void *)(a1 + _Block_object_dispose(&STACK[0x400], 8) = v9;
    unsigned int v12 = v7;
    uint64_t v13 = v8;
    *(_DWORD *)(a1 + 16) = v14;
    int v14 = 0;
    free(v7);
  }
  else
  {
    unsigned int v5 = *(_DWORD *)(a1 + 16);
    if (v5 != *(_DWORD *)(v4 + 16))
    {
      cva::Logger::instance((cva::Logger *)a1);
      cva::Logger::logInCategory();
      unsigned int v5 = *(_DWORD *)(a1 + 16);
      uint64_t v4 = *(void *)(a2 + 8);
      if (v5 != *(_DWORD *)(v4 + 16)) {
        cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>();
      }
    }
    if (*(_DWORD *)(v4 + 20) * v5) {
      cva::VecLib<float>::gemv();
    }
    if (v5)
    {
      int v10 = *(void **)a1;
      size_t v11 = 4 * v5;
      bzero(v10, v11);
    }
  }
}

void sub_1B89F3764(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
}

id _ARLogTechnique_13()
{
  if (_ARLogTechnique_onceToken_19 != -1) {
    dispatch_once(&_ARLogTechnique_onceToken_19, &__block_literal_global_111);
  }
  double v0 = (void *)_ARLogTechnique_logObj_19;
  return v0;
}

uint64_t arkit::FaceTrackingData::FaceTrackingData(uint64_t a1, long long *a2, uint64_t *a3)
{
  long long v4 = *a2;
  long long v5 = a2[1];
  *(_DWORD *)(a1 + 32) = *((_DWORD *)a2 + 8);
  *(_OWORD *)a1 = v4;
  *(_OWORD *)(a1 + 16) = v5;
  *(void *)(a1 + 4_Block_object_dispose(&STACK[0x400], 8) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 40) = 0;
  std::vector<arkit::Landmark>::__init_with_size[abi:ne180100]<arkit::Landmark*,arkit::Landmark*>((char *)(a1 + 40), *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * ((a3[1] - *a3) >> 2));
  return a1;
}

{
  long long v4;
  long long v5;

  long long v4 = *a2;
  long long v5 = a2[1];
  *(_DWORD *)(a1 + 32) = *((_DWORD *)a2 + 8);
  *(_OWORD *)a1 = v4;
  *(_OWORD *)(a1 + 16) = v5;
  *(void *)(a1 + 4_Block_object_dispose(&STACK[0x400], 8) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 40) = 0;
  std::vector<arkit::Landmark>::__init_with_size[abi:ne180100]<arkit::Landmark*,arkit::Landmark*>((char *)(a1 + 40), *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * ((a3[1] - *a3) >> 2));
  return a1;
}

void arkit::FaceTrackingData::filteredLandmarks(uint64_t a1@<X0>, int **a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)a3 = 0;
  *(void *)(a3 + _Block_object_dispose(&STACK[0x400], 8) = 0;
  *(void *)(a3 + 16) = 0;
  std::vector<arkit::Landmark>::reserve((char **)a3, a2[1] - *a2);
  uint64_t v6 = *a2;
  unsigned int v7 = a2[1];
  if (*a2 != v7)
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 48) - *(void *)(a1 + 40)) >> 2) - 1;
    do
    {
      unint64_t v9 = *v6;
      if (v8 >= v9)
      {
        uint64_t v10 = *(void *)(a1 + 40);
        size_t v11 = (void *)(v10 + 12 * (int)v9);
        unint64_t v12 = *(void *)(a3 + 8);
        unint64_t v13 = *(void *)(a3 + 16);
        if (v12 >= v13)
        {
          unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v12 - *(void *)a3) >> 2);
          unint64_t v16 = v15 + 1;
          if (v15 + 1 > 0x1555555555555555) {
            std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - *(void *)a3) >> 2);
          if (2 * v17 > v16) {
            unint64_t v16 = 2 * v17;
          }
          if (v17 >= 0xAAAAAAAAAAAAAAALL) {
            unint64_t v18 = 0x1555555555555555;
          }
          else {
            unint64_t v18 = v16;
          }
          unsigned int v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<float,3u,1u,false>>>(a3 + 16, v18);
          unsigned int v21 = &v19[12 * v15];
          *(void *)unsigned int v21 = *v11;
          v21[8] = *(unsigned char *)(v10 + 12 * (int)v9 + 8);
          int v23 = *(char **)a3;
          int v22 = *(char **)(a3 + 8);
          int v24 = v21;
          if (v22 != *(char **)a3)
          {
            do
            {
              uint64_t v25 = *(void *)(v22 - 12);
              v22 -= 12;
              *(void *)(v24 - 12) = v25;
              v24 -= 12;
              v24[8] = v22[8];
            }
            while (v22 != v23);
            int v22 = *(char **)a3;
          }
          int v14 = v21 + 12;
          *(void *)a3 = v24;
          *(void *)(a3 + _Block_object_dispose(&STACK[0x400], 8) = v21 + 12;
          *(void *)(a3 + 16) = &v19[12 * v20];
          if (v22) {
            operator delete(v22);
          }
        }
        else
        {
          *(void *)unint64_t v12 = *v11;
          *(unsigned char *)(v12 + _Block_object_dispose(&STACK[0x400], 8) = *(unsigned char *)(v10 + 12 * (int)v9 + 8);
          int v14 = (char *)(v12 + 12);
        }
        *(void *)(a3 + _Block_object_dispose(&STACK[0x400], 8) = v14;
      }
      ++v6;
    }
    while (v6 != v7);
  }
}

void sub_1B89F429C(_Unwind_Exception *exception_object)
{
  char v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(&STACK[0x400], 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unint64_t arkit::FaceTrackingData::nLandmarks(arkit::FaceTrackingData *this)
{
  return 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)this + 6) - *((void *)this + 5)) >> 2);
}

char *std::vector<arkit::Landmark>::__init_with_size[abi:ne180100]<arkit::Landmark*,arkit::Landmark*>(char *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    float result = std::vector<cva::Matrix<float,3u,1u,false>>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = *((void *)v6 + 1);
    while (a2 != a3)
    {
      *(void *)uint64_t v7 = *(void *)a2;
      *(unsigned char *)(v7 + _Block_object_dispose(&STACK[0x400], 8) = *(unsigned char *)(a2 + 8);
      v7 += 12;
      a2 += 12;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_1B89F4344(_Unwind_Exception *exception_object)
{
  char v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(&STACK[0x400], 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

BOOL ARFileDescriptorIsTTY(FILE *a1)
{
  if (ARFileDescriptorIsTTY_onceToken != -1) {
    dispatch_once(&ARFileDescriptorIsTTY_onceToken, &__block_literal_global_115);
  }
  int v2 = fileno(a1);
  if (isatty(v2)) {
    BOOL v3 = ARFileDescriptorIsTTY_isSSHTTY == 0;
  }
  else {
    BOOL v3 = 1;
  }
  return !v3;
}

void __ARFileDescriptorIsTTY_block_invoke()
{
  id v2 = [MEMORY[0x1E4F28F80] processInfo];
  double v0 = [v2 environment];
  uint64_t v1 = [v0 objectForKey:@"SSH_TTY"];
  ARFileDescriptorIsTTY_isSSHTTY = v1 != 0;
}

void _printFormat(FILE *a1, void *a2, uint64_t a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  long long v5 = (objc_class *)NSString;
  id v6 = a2;
  uint64_t v7 = (void *)[[v5 alloc] initWithFormat:v6 arguments:a3];

  id v8 = v7;
  fprintf(a1, "%s\n", (const char *)[v8 UTF8String]);
  unint64_t v9 = _ARLogGeneral_42();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)vImage_Buffer buf = 138543362;
    id v11 = v8;
    _os_log_impl(&dword_1B88A2000, v9, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
  }
}

void _printMessageWithColor(FILE *a1, void *a2, void *a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = a3;
  if (ARFileDescriptorIsTTY(a1))
  {
    fputs((const char *)[v5 UTF8String], a1);
    fputs((const char *)[v6 UTF8String], a1);
    uint64_t v7 = (const char *)[@"\x1B[0m" UTF8String];
  }
  else
  {
    uint64_t v7 = "";
    fputs("", a1);
    fputs((const char *)[v6 UTF8String], a1);
  }
  fprintf(a1, "%s\n", v7);
  id v8 = _ARLogGeneral_42();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)vImage_Buffer buf = 138543362;
    id v10 = v6;
    _os_log_impl(&dword_1B88A2000, v8, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
  }
}

void printMessage(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void _printMessage(void *a1, uint64_t a2)
{
}

double printVector3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  printMessage(@"%s: (%f, %f, %f)", a2, a3, a4, a5, a6, a7, a8, a1);
  return result;
}

void printError(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void _printError(void *a1, uint64_t a2)
{
  BOOL v3 = (objc_class *)NSString;
  id v4 = a1;
  id v5 = [v3 alloc];
  id v6 = [NSString stringWithFormat:@"%@", v4];

  id v8 = (id)[v5 initWithFormat:v6 arguments:a2];
  uint64_t v7 = [NSString stringWithFormat:@"❌  ERROR: %@\n", v8];
  _printMessageWithColor((FILE *)*MEMORY[0x1E4F143C8], @"\x1B[1;35m", v7);
}

void printInfo(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void _printInfo(void *a1, uint64_t a2)
{
  BOOL v3 = (objc_class *)NSString;
  id v4 = a1;
  id v5 = [v3 alloc];
  id v6 = [NSString stringWithFormat:@"%@", v4];

  id v8 = (id)[v5 initWithFormat:v6 arguments:a2];
  uint64_t v7 = [NSString stringWithFormat:@"ℹ️  INFO: %@\n", v8];
  _printMessageWithColor((FILE *)*MEMORY[0x1E4F143D8], @"\x1B[1;35m", v7);
}

void printWarning(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void _printWarning(void *a1, uint64_t a2)
{
  BOOL v3 = (objc_class *)NSString;
  id v4 = a1;
  id v5 = [v3 alloc];
  id v6 = [NSString stringWithFormat:@"%@", v4];

  id v8 = (id)[v5 initWithFormat:v6 arguments:a2];
  uint64_t v7 = [NSString stringWithFormat:@"⚠️  WARNING: %@\n", v8];
  _printMessageWithColor((FILE *)*MEMORY[0x1E4F143D8], @"\x1B[1;35m", v7);
}

void printColoredMessage(void *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void _printColoredMessage(void *a1, void *a2, uint64_t a3)
{
  id v5 = (objc_class *)NSString;
  id v6 = a2;
  id v7 = a1;
  id v8 = [v5 alloc];
  unint64_t v9 = [NSString stringWithFormat:@"%@", v6];

  id v10 = (id)[v8 initWithFormat:v9 arguments:a3];
  _printMessageWithColor((FILE *)*MEMORY[0x1E4F143D8], v7, v10);
}

void ARPrintUsageStrings(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  printColoredMessage(@"\x1B[1m", @"Usage:", a3, a4, a5, a6, a7, a8, vars0);
  printMessage(@" arkitctl <COMMAND> [help]\n", v9, v10, v11, v12, v13, v14, v15, a9);
}

uint64_t ARPrintToiTerm(void *a1)
{
  id v1 = a1;
  printf("\x1B]1337;File=[size=%lld;inline=1;preserveAspectRatio=1]:", [v1 length]);
  id v2 = [v1 base64EncodedStringWithOptions:0];

  id v3 = v2;
  puts((const char *)[v3 UTF8String]);

  return puts("\a");
}

uint64_t ARPrintEscapeEnableAlternativeBuffer()
{
  printf("%s", "\x1B[?1049h");
  double v0 = (FILE *)*MEMORY[0x1E4F143D8];
  return fflush(v0);
}

uint64_t ARPrintEscapeDisableAlternativeBuffer()
{
  printf("%s", "\x1B[?1049l");
  double v0 = (FILE *)*MEMORY[0x1E4F143D8];
  return fflush(v0);
}

uint64_t ARPrintEscapeEraseScreen()
{
  printf("%s", "\x1B[2J");
  double v0 = (FILE *)*MEMORY[0x1E4F143D8];
  return fflush(v0);
}

uint64_t ARPrintEscapeMoveToLocation(int a1, int a2)
{
  printf("\x1B[%d;%dH", a1, a2);
  id v2 = (FILE *)*MEMORY[0x1E4F143D8];
  return fflush(v2);
}

char *arkit::wrap@<X0>(arkit *this@<X0>, void *a2@<X8>)
{
  if (CVPixelBufferGetPixelFormatType(this) != 875704422) {
    arkit::wrap();
  }
  a2[1] = 0;
  a2[2] = 0;
  a2[3] = 0;
  a2[6] = 0;
  a2[7] = 0;
  a2[5] = 0;
  a2[10] = 0;
  a2[11] = 0;
  a2[9] = 0;
  unsigned int WidthOfPlane = CVPixelBufferGetWidthOfPlane(this, 0);
  unsigned int HeightOfPlane = CVPixelBufferGetHeightOfPlane(this, 0);
  size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(this, 0);
  BaseAddressOfPlane = CVPixelBufferGetBaseAddressOfPlane(this, 0);
  *a2 = 0;
  a2[1] = WidthOfPlane | ((unint64_t)HeightOfPlane << 32);
  a2[2] = (BytesPerRowOfPlane << 32) | 1;
  a2[3] = BaseAddressOfPlane;
  unsigned int v9 = CVPixelBufferGetWidthOfPlane(this, 1uLL);
  unint64_t v10 = v9 | ((unint64_t)CVPixelBufferGetHeightOfPlane(this, 1uLL) << 32);
  size_t v11 = (CVPixelBufferGetBytesPerRowOfPlane(this, 1uLL) << 32) | 2;
  uint64_t v12 = CVPixelBufferGetBaseAddressOfPlane(this, 1uLL);
  a2[4] = 0;
  a2[5] = v10;
  a2[6] = v11;
  a2[7] = v12;
  LODWORD(v10) = CVPixelBufferGetWidthOfPlane(this, 1uLL);
  unint64_t v13 = v10 | ((unint64_t)CVPixelBufferGetHeightOfPlane(this, 1uLL) << 32);
  size_t v14 = (CVPixelBufferGetBytesPerRowOfPlane(this, 1uLL) << 32) | 2;
  double result = (char *)CVPixelBufferGetBaseAddressOfPlane(this, 1uLL);
  a2[8] = 0;
  a2[9] = v13;
  a2[10] = v14;
  a2[11] = result + 1;
  return result;
}

double arkit::KeyMapBuffer<void const*,std::vector<unsigned char>>::KeyMapBuffer(uint64_t a1, uint64_t a2)
{
  double result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(void *)(a1 + 8_Block_object_dispose(&STACK[0x400], 8) = a2;
  return result;
}

{
  double result;

  double result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(void *)(a1 + 8_Block_object_dispose(&STACK[0x400], 8) = a2;
  return result;
}

uint64_t *arkit::KeyMapBuffer<void const*,std::vector<unsigned char>>::insert(void *a1, std::locale::__imp *a2, char **a3)
{
  id v6 = a1 + 5;
  std::deque<void const*>::push_front((uint64_t)(a1 + 5), a2);
  if (std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::find<void const*>(a1, a2))
  {
    id v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"Key already in buffer", 21);
    std::ios_base::getloc((const std::ios_base *)((char *)v7 + *(void *)(*v7 - 24)));
    id v8 = std::locale::use_facet(&v12, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 10);
    std::locale::~locale(&v12);
    std::ostream::put();
    std::ostream::flush();
  }
  v12.__locale_ = a2;
  double result = std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::__emplace_unique_key_args<void const*,std::piecewise_construct_t const&,std::tuple<void const* const&>,std::tuple<>>((uint64_t)a1, a2, (uint64_t)&std::piecewise_construct, &v12)+ 3;
  if (result != (uint64_t *)a3) {
    double result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char *,unsigned char *>(result, *a3, a3[1], a3[1] - *a3);
  }
  unint64_t v10 = a1[10];
  if (v10 > a1[11])
  {
    unint64_t v11 = v10 - 1;
    v12.__locale_ = *(std::locale::__imp **)(*(void *)(a1[6] + (((a1[9] + v11) >> 6) & 0x3FFFFFFFFFFFFF8))
                                           + 8 * ((a1[9] + v11) & 0x1FF));
    a1[10] = v11;
    std::deque<void const*>::__maybe_remove_back_spare[abi:ne180100](v6, 1);
    return std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::__erase_unique<void const*>(a1, &v12);
  }
  return result;
}

void sub_1B89F6F28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
}

void std::deque<void const*>::push_front(uint64_t a1, void *a2)
{
  unint64_t v4 = *(void *)(a1 + 32);
  if (!v4)
  {
    std::deque<void const*>::__add_front_capacity((void **)a1);
    unint64_t v4 = *(void *)(a1 + 32);
  }
  uint64_t v5 = *(void *)(a1 + 8);
  id v6 = (void *)(v5 + 8 * (v4 >> 9));
  if (*(void *)(a1 + 16) == v5) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = *v6 + 8 * (v4 & 0x1FF);
  }
  if (v7 == *v6) {
    uint64_t v7 = *(v6 - 1) + 4096;
  }
  *(void *)(v7 - _Block_object_dispose(&STACK[0x400], 8) = *a2;
  uint64_t v8 = *(void *)(a1 + 40) + 1;
  *(void *)(a1 + 32) = v4 - 1;
  *(void *)(a1 + 40) = v8;
}

BOOL arkit::KeyMapBuffer<void const*,std::vector<unsigned char>>::find(void *a1, void *a2, void *a3)
{
  unint64_t v4 = std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::find<void const*>(a1, a2);
  uint64_t v5 = v4;
  if (a3 && v4 && v4 + 3 != a3) {
    std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char *,unsigned char *>(a3, (char *)v4[3], (char *)v4[4], v4[4] - v4[3]);
  }
  return v5 != 0;
}

void *arkit::wrapRawData@<X0>(arkit *this@<X0>, size_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = (void *)*std::vector<unsigned char>::vector(a3, a2);
  return memcpy(v5, this, a2);
}

double ARImageContextFromImageData(void *a1)
{
  [a1 timestamp];
  return result;
}

void std::deque<void const*>::__add_front_capacity(void **a1)
{
  id v2 = a1[1];
  id v3 = a1[2];
  unint64_t v4 = v3 - v2;
  if (v3 == v2) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = ((v3 - v2) << 6) - 1;
  }
  id v6 = (char *)a1[4];
  if (v5 - (unint64_t)&v6[(void)a1[5]] < 0x200)
  {
    uint64_t v7 = (uint64_t)(a1 + 3);
    uint64_t v8 = a1[3];
    unsigned int v9 = *a1;
    uint64_t v10 = v8 - (unsigned char *)*a1;
    if (v4 >= v10)
    {
      if (v8 == v9) {
        unint64_t v11 = 1;
      }
      else {
        unint64_t v11 = v10 >> 2;
      }
      uint64_t v46 = a1 + 3;
      __p = std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>(v7, v11);
      uint64_t v43 = (char *)__p;
      float32x2_t v44 = (char *)__p;
      int v45 = (char *)__p + 8 * v12;
      uint64_t v41 = operator new(0x1000uLL);
      std::__split_buffer<std::pair<int,int> *,std::allocator<std::pair<int,int> *> &>::push_back(&__p, &v41);
      unint64_t v13 = (char *)a1[1];
      size_t v14 = v44;
      if (v13 == a1[2])
      {
        uint64_t v33 = (char *)a1[1];
      }
      else
      {
        do
        {
          if (v14 == v45)
          {
            int64_t v15 = v43 - (unsigned char *)__p;
            if (v43 <= __p)
            {
              if (v14 == __p) {
                unint64_t v23 = 1;
              }
              else {
                unint64_t v23 = (v14 - (unsigned char *)__p) >> 2;
              }
              int v24 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>((uint64_t)v46, v23);
              char v26 = v43;
              size_t v14 = &v24[8 * (v23 >> 2)];
              uint64_t v27 = v44 - v43;
              if (v44 != v43)
              {
                size_t v14 = &v24[8 * (v23 >> 2) + (v27 & 0xFFFFFFFFFFFFFFF8)];
                uint64_t v28 = 8 * (v27 >> 3);
                int v29 = &v24[8 * (v23 >> 2)];
                do
                {
                  uint64_t v30 = *(void *)v26;
                  v26 += 8;
                  *(void *)int v29 = v30;
                  v29 += 8;
                  v28 -= 8;
                }
                while (v28);
              }
              int v31 = __p;
              __p = v24;
              uint64_t v43 = &v24[8 * (v23 >> 2)];
              float32x2_t v44 = v14;
              int v45 = &v24[8 * v25];
              if (v31)
              {
                operator delete(v31);
                size_t v14 = v44;
              }
            }
            else
            {
              uint64_t v16 = v15 >> 3;
              BOOL v17 = v15 >> 3 < -1;
              uint64_t v18 = (v15 >> 3) + 2;
              if (v17) {
                uint64_t v19 = v18;
              }
              else {
                uint64_t v19 = v16 + 1;
              }
              uint64_t v20 = &v43[-8 * (v19 >> 1)];
              int64_t v21 = v14 - v43;
              if (v14 != v43)
              {
                memmove(&v43[-8 * (v19 >> 1)], v43, v14 - v43);
                size_t v14 = v43;
              }
              int v22 = &v14[-8 * (v19 >> 1)];
              size_t v14 = &v20[v21];
              uint64_t v43 = v22;
              float32x2_t v44 = &v20[v21];
            }
          }
          uint64_t v32 = *(void *)v13;
          v13 += 8;
          *(void *)size_t v14 = v32;
          size_t v14 = v44 + 8;
          v44 += 8;
        }
        while (v13 != a1[2]);
        uint64_t v33 = (char *)a1[1];
      }
      float v36 = *a1;
      uint64_t v37 = v43;
      *a1 = __p;
      a1[1] = v37;
      __p = v36;
      uint64_t v43 = v33;
      uint64_t v38 = (char *)a1[3];
      int v39 = v45;
      a1[2] = v14;
      a1[3] = v39;
      float32x2_t v44 = v13;
      int v45 = v38;
      if (v14 - v37 == 8) {
        uint64_t v40 = 256;
      }
      else {
        uint64_t v40 = (uint64_t)a1[4] + 512;
      }
      a1[4] = (void *)v40;
      if (v13 != v33) {
        float32x2_t v44 = &v13[(v33 - v13 + 7) & 0xFFFFFFFFFFFFFFF8];
      }
      if (v36) {
        operator delete(v36);
      }
    }
    else
    {
      if (v2 == v9)
      {
        __p = operator new(0x1000uLL);
        std::__split_buffer<std::pair<int,int> *,std::allocator<std::pair<int,int> *>>::push_back(a1, &__p);
        uint64_t v34 = a1[2];
        __p = (void *)*(v34 - 1);
        a1[2] = v34 - 1;
      }
      else
      {
        __p = operator new(0x1000uLL);
      }
      std::__split_buffer<std::pair<int,int> *,std::allocator<std::pair<int,int> *>>::push_front((uint64_t)a1, &__p);
      if ((unsigned char *)a1[2] - (unsigned char *)a1[1] == 8) {
        uint64_t v35 = 256;
      }
      else {
        uint64_t v35 = (uint64_t)a1[4] + 512;
      }
      a1[4] = (void *)v35;
    }
  }
  else
  {
    a1[4] = v6 + 512;
    __p = (void *)*((void *)v3 - 1);
    a1[2] = v3 - 8;
    std::__split_buffer<std::pair<int,int> *,std::allocator<std::pair<int,int> *>>::push_front((uint64_t)a1, &__p);
  }
}

void sub_1B89F733C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  operator delete(v12);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void *std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(void *a1, uint64_t a2, uint64_t a3)
{
  MEMORY[0x1BA9C5580](v13, a1);
  if (v13[0])
  {
    uint64_t v6 = (uint64_t)a1 + *(void *)(*a1 - 24);
    uint64_t v7 = *(void *)(v6 + 40);
    int v8 = *(_DWORD *)(v6 + 8);
    int v9 = *(_DWORD *)(v6 + 144);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
      uint64_t v10 = std::locale::use_facet(&v14, MEMORY[0x1E4FBA258]);
      int v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&v14);
      *(_DWORD *)(v6 + 144) = v9;
    }
    if ((v8 & 0xB0) == 0x20) {
      uint64_t v11 = a2 + a3;
    }
    else {
      uint64_t v11 = a2;
    }
    if (!std::__pad_and_output[abi:ne180100]<char,std::char_traits<char>>(v7, a2, v11, a2 + a3, v6, (char)v9)) {
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
    }
  }
  MEMORY[0x1BA9C5590](v13);
  return a1;
}

void sub_1B89F74C4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, std::locale a12)
{
  MEMORY[0x1BA9C5590](&a10);
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((std::ios_base *)((char *)v12 + *(void *)(*v12 - 24)));
  __cxa_end_catch();
  JUMPOUT(0x1B89F74A4);
}

void sub_1B89F7518(_Unwind_Exception *a1)
{
}

uint64_t std::__pad_and_output[abi:ne180100]<char,std::char_traits<char>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int __c)
{
  uint64_t v6 = a1;
  if (a1)
  {
    uint64_t v11 = *(void *)(a5 + 24);
    if (v11 <= a4 - a2) {
      int64_t v12 = 0;
    }
    else {
      int64_t v12 = v11 - (a4 - a2);
    }
    if (a3 - a2 >= 1 && (*(uint64_t (**)(uint64_t))(*(void *)a1 + 96))(a1) != a3 - a2) {
      return 0;
    }
    if (v12 >= 1)
    {
      std::string::basic_string[abi:ne180100](__p, v12, __c);
      unint64_t v13 = v18 >= 0 ? __p : (void **)__p[0];
      uint64_t v14 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v6 + 96))(v6, v13, v12);
      if (v18 < 0) {
        operator delete(__p[0]);
      }
      if (v14 != v12) {
        return 0;
      }
    }
    uint64_t v15 = a4 - a3;
    if (v15 < 1 || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 96))(v6, a3, v15) == v15) {
      *(void *)(a5 + 24) = 0;
    }
    else {
      return 0;
    }
  }
  return v6;
}

void sub_1B89F7698(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *std::string::basic_string[abi:ne180100](void *__b, size_t __len, int __c)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (__len >= 0x17)
  {
    size_t v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v7 = __len | 7;
    }
    size_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    __b[1] = __len;
    __b[2] = v8 | 0x8000000000000000;
    *__b = v6;
  }
  else
  {
    *((unsigned char *)__b + 23) = __len;
    uint64_t v6 = __b;
    if (!__len) {
      goto LABEL_9;
    }
  }
  memset(v6, __c, __len);
LABEL_9:
  *((unsigned char *)v6 + __len) = 0;
  return __b;
}

void *std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::__emplace_unique_key_args<void const*,std::piecewise_construct_t const&,std::tuple<void const* const&>,std::tuple<>>(uint64_t a1, void *a2, uint64_t a3, void **a4)
{
  unint64_t v7 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  unint64_t v8 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v7 >> 47) ^ v7);
  unint64_t v9 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v4 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
      if (v9 >= v10) {
        unint64_t v4 = v9 % v10;
      }
    }
    else
    {
      unint64_t v4 = v9 & (v10 - 1);
    }
    int64_t v12 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v12)
    {
      for (uint64_t i = *v12; i; uint64_t i = (void *)*i)
      {
        unint64_t v14 = i[1];
        if (v14 == v9)
        {
          if (i[2] == *a2) {
            return i;
          }
        }
        else
        {
          if (v11.u32[0] > 1uLL)
          {
            if (v14 >= v10) {
              v14 %= v10;
            }
          }
          else
          {
            v14 &= v10 - 1;
          }
          if (v14 != v4) {
            break;
          }
        }
      }
    }
  }
  uint64_t v15 = (void *)(a1 + 16);
  uint64_t i = operator new(0x30uLL);
  *uint64_t i = 0;
  i[1] = v9;
  i[2] = **a4;
  i[3] = 0;
  i[4] = 0;
  i[5] = 0;
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    BOOL v18 = 1;
    if (v10 >= 3) {
      BOOL v18 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v10);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = v19;
    }
    std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::__rehash<true>(a1, v21);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v4 = v9 % v10;
      }
      else {
        unint64_t v4 = v9;
      }
    }
    else
    {
      unint64_t v4 = (v10 - 1) & v9;
    }
  }
  uint64_t v22 = *(void *)a1;
  unint64_t v23 = *(void **)(*(void *)a1 + 8 * v4);
  if (v23)
  {
    *uint64_t i = *v23;
LABEL_38:
    *unint64_t v23 = i;
    goto LABEL_39;
  }
  *uint64_t i = *v15;
  void *v15 = i;
  *(void *)(v22 + 8 * v4) = v15;
  if (*i)
  {
    unint64_t v24 = *(void *)(*i + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v24 >= v10) {
        v24 %= v10;
      }
    }
    else
    {
      v24 &= v10 - 1;
    }
    unint64_t v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_1B89F79CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<void const*,std::vector<unsigned char>>,void *>>>::operator()[abi:ne180100](v11, v10);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::__rehash<true>(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2;
  }
  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }
  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(void *)&v4) {
    goto LABEL_16;
  }
  if (prime < *(void *)&v4)
  {
    unint64_t v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      unint64_t v5 = std::__next_prime(v5);
    }
    else
    {
      uint64_t v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2) {
        unint64_t v5 = v7;
      }
    }
    if (prime <= v5) {
      size_t prime = v5;
    }
    if (prime < *(void *)&v4)
    {
LABEL_16:
      std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::__do_rehash<true>(a1, prime);
    }
  }
}

void std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::__do_rehash<true>(uint64_t a1, unint64_t a2)
{
  if (a2)
  {
    if (a2 >> 61) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    int8x8_t v4 = operator new(8 * a2);
    unint64_t v5 = *(void **)a1;
    *(void *)a1 = v4;
    if (v5) {
      operator delete(v5);
    }
    uint64_t v6 = 0;
    *(void *)(a1 + _Block_object_dispose(&STACK[0x400], 8) = a2;
    do
      *(void *)(*(void *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    uint64_t v7 = *(void **)(a1 + 16);
    if (v7)
    {
      unint64_t v8 = v7[1];
      uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2) {
          v8 %= a2;
        }
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v_Block_object_dispose(&STACK[0x400], 8) = a1 + 16;
      uint64_t v11 = (void *)*v7;
      if (*v7)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= a2) {
              v12 %= a2;
            }
          }
          else
          {
            v12 &= a2 - 1;
          }
          if (v12 != v8)
          {
            if (!*(void *)(*(void *)a1 + 8 * v12))
            {
              *(void *)(*(void *)a1 + 8 * v12) = v7;
              goto LABEL_24;
            }
            *uint64_t v7 = *v11;
            *uint64_t v11 = **(void **)(*(void *)a1 + 8 * v12);
            **(void **)(*(void *)a1 + 8 * v12) = v11;
            uint64_t v11 = v7;
          }
          unint64_t v12 = v8;
LABEL_24:
          uint64_t v7 = v11;
          uint64_t v11 = (void *)*v11;
          unint64_t v8 = v12;
        }
        while (v11);
      }
    }
  }
  else
  {
    unint64_t v10 = *(void **)a1;
    *(void *)a1 = 0;
    if (v10) {
      operator delete(v10);
    }
    *(void *)(a1 + _Block_object_dispose(&STACK[0x400], 8) = 0;
  }
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<void const*,std::vector<unsigned char>>,void *>>>::operator()[abi:ne180100](uint64_t a1, void *__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    id v3 = (void *)__p[3];
    if (v3)
    {
      __p[4] = v3;
      operator delete(v3);
    }
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

uint64_t std::deque<void const*>::__maybe_remove_back_spare[abi:ne180100](void *a1, int a2)
{
  uint64_t v3 = a1[1];
  uint64_t v2 = a1[2];
  if (v2 == v3) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = ((v2 - v3) << 6) - 1;
  }
  unint64_t v5 = v4 - (a1[5] + a1[4]);
  if (v5 < 0x200) {
    a2 = 1;
  }
  if (v5 < 0x400) {
    int v7 = a2;
  }
  else {
    int v7 = 0;
  }
  if ((v7 & 1) == 0)
  {
    operator delete(*(void **)(v2 - 8));
    a1[2] -= 8;
  }
  return v7 ^ 1u;
}

uint64_t *std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::__erase_unique<void const*>(void *a1, void *a2)
{
  double result = std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::find<void const*>(a1, a2);
  if (result)
  {
    std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::erase(a1, result);
    return (uint64_t *)1;
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::find<void const*>(void *a1, void *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  unint64_t v4 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v3 >> 47) ^ v3);
  unint64_t v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = v5;
    if (v5 >= *(void *)&v2) {
      unint64_t v7 = v5 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v7 = v5 & (*(void *)&v2 - 1);
  }
  unint64_t v8 = *(void **)(*a1 + 8 * v7);
  if (!v8) {
    return 0;
  }
  double result = (void *)*v8;
  if (*v8)
  {
    do
    {
      unint64_t v10 = result[1];
      if (v10 == v5)
      {
        if (result[2] == *a2) {
          return result;
        }
      }
      else
      {
        if (v6.u32[0] > 1uLL)
        {
          if (v10 >= *(void *)&v2) {
            v10 %= *(void *)&v2;
          }
        }
        else
        {
          v10 &= *(void *)&v2 - 1;
        }
        if (v10 != v7) {
          return 0;
        }
      }
      double result = (void *)*result;
    }
    while (result);
  }
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::erase(void *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::remove(a1, a2, (uint64_t)&__p);
  unint64_t v3 = __p;
  __p = 0;
  if (v3) {
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<void const*,std::vector<unsigned char>>,void *>>>::operator()[abi:ne180100]((uint64_t)&v6, v3);
  }
  return v2;
}

void *std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::remove@<X0>(void *result@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  int8x8_t v3 = (int8x8_t)result[1];
  unint64_t v4 = a2[1];
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(void *)&v3) {
      v4 %= *(void *)&v3;
    }
  }
  else
  {
    v4 &= *(void *)&v3 - 1;
  }
  uint64_t v6 = *(void **)(*result + 8 * v4);
  do
  {
    unint64_t v7 = v6;
    uint64_t v6 = (void *)*v6;
  }
  while (v6 != a2);
  if (v7 == result + 2) {
    goto LABEL_18;
  }
  unint64_t v8 = v7[1];
  if (v5.u32[0] > 1uLL)
  {
    if (v8 >= *(void *)&v3) {
      v8 %= *(void *)&v3;
    }
  }
  else
  {
    v8 &= *(void *)&v3 - 1;
  }
  if (v8 != v4)
  {
LABEL_18:
    if (!*a2) {
      goto LABEL_19;
    }
    unint64_t v9 = *(void *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v9 >= *(void *)&v3) {
        v9 %= *(void *)&v3;
      }
    }
    else
    {
      v9 &= *(void *)&v3 - 1;
    }
    if (v9 != v4) {
LABEL_19:
    }
      *(void *)(*result + 8 * v4) = 0;
  }
  uint64_t v10 = *a2;
  if (*a2)
  {
    unint64_t v11 = *(void *)(v10 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v11 >= *(void *)&v3) {
        v11 %= *(void *)&v3;
      }
    }
    else
    {
      v11 &= *(void *)&v3 - 1;
    }
    if (v11 != v4)
    {
      *(void *)(*result + 8 * v11) = v7;
      uint64_t v10 = *a2;
    }
  }
  *unint64_t v7 = v10;
  *a2 = 0;
  --result[3];
  *(void *)a3 = a2;
  *(void *)(a3 + _Block_object_dispose(&STACK[0x400], 8) = result + 2;
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

id NSStringFromARCollaborationData(void *a1)
{
  id v1 = (void *)MEMORY[0x1E4F28E78];
  id v2 = a1;
  int8x8_t v3 = (objc_class *)objc_opt_class();
  unint64_t v4 = NSStringFromClass(v3);
  uint8x8_t v5 = [v1 stringWithFormat:@"<%@: %p", v4, v2];

  uint64_t v6 = [v2 priority];
  unint64_t v7 = @"optional";
  if (!v6) {
    unint64_t v7 = @"critical";
  }
  [v5 appendFormat:@" priority=%@", v7];
  objc_msgSend(v5, "appendFormat:", @" version=%ti", objc_msgSend(v2, "version"));
  [v2 timestamp];
  objc_msgSend(v5, "appendFormat:", @" timestamp=%f", v8);
  unint64_t v9 = [v2 vioData];
  objc_msgSend(v5, "appendFormat:", @" vioData=%tu", objc_msgSend(v9, "length"));

  uint64_t v10 = NSStringFromSLAMCMDataType([v2 vioDataType]);
  [v5 appendFormat:@" vioDataType=%@", v10];

  objc_msgSend(v5, "appendFormat:", @" vioSessionID=%llX", objc_msgSend(v2, "vioSessionID"));
  unint64_t v11 = [v2 anchors];

  objc_msgSend(v5, "appendFormat:", @" anchors=%tu", objc_msgSend(v11, "count"));
  [v5 appendString:@">"];
  return v5;
}

void sub_1B89F884C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, void (*a12)(char *))
{
}

uint64_t __bufferContainsSegmentedPeople_block_invoke(uint64_t a1)
{
  return CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a1 + 32), 1uLL);
}

uint64_t arkit::ChromaFilter::ycbcr2xyz@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v4[0] = xmmword_1B8A56C14;
  v4[1] = unk_1B8A56C24;
  _DWORD v4[2] = xmmword_1B8A56C34;
  v3[0] = (uint64_t)v4;
  v3[1] = a1;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + _Block_object_dispose(&STACK[0x400], 8) = 0;
  return cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,4u,false>,cva::Matrix<float,4u,1u,false>>(a2, v3);
}

BOOL arkit::ChromaFilter::xyz2uvl(float32x2_t *a1, float32x2_t *a2, double a3, double a4)
{
  _D0 = *a1;
  _S1 = 15.0;
  __asm { FMLA            S2, S1, V0.S[1] }
  *(float *)&a4 = _S2 + (float)(a1[1].f32[0] * 3.0);
  if (*(float *)&a4 > 0.0)
  {
    *a2 = vdiv_f32(vmul_f32(_D0, (float32x2_t)0x40C0000040800000), (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a4, 0));
    a2[1].i32[0] = _D0.i32[1];
  }
  return *(float *)&a4 > 0.0;
}

uint64_t arkit::ChromaFilter::uvl2ind(uint64_t a1)
{
  uint64_t result = 0;
  if (*(float *)a1 >= 0.15 && *(float *)a1 <= 0.65)
  {
    uint64_t result = 0;
    v3.i32[0] = *(_DWORD *)(a1 + 4);
    if (v3.f32[0] >= 0.15 && v3.f32[0] <= 0.65)
    {
      float v4 = *(float *)(a1 + 8);
      if (v4 >= 0.0 && v4 <= 1.0)
      {
        v3.i32[1] = *(_DWORD *)a1;
        float32x2_t v6 = vadd_f32(v3, (float32x2_t)vdup_n_s32(0xBE19999A));
        double v7 = fmin((float)(ceilf(v4 * 50.0) + 1.0), 50.0);
        __asm { FMOV            V2.2S, #1.0 }
        int32x2_t v13 = vmul_s32((int32x2_t)vcvt_u32_f32(vadd_f32(vrndp_f32(vmul_f32(v6, (float32x2_t)vdup_n_s32(0x42C80000u))), _D2)), (int32x2_t)0x466F45D012740A5);
        return veor_s8((int8x8_t)v13, (int8x8_t)vdup_lane_s32(v13, 1)).u32[0] ^ (83492791 * v7);
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t arkit::ChromaFilter::filter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = MEMORY[0x1F4188790](a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v10 = v9;
  unint64_t v11 = (unsigned int *)v8;
  int32x2_t v13 = v12;
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  memcpy(__dst, &unk_1B8A56C44, sizeof(__dst));
  std::unordered_set<unsigned int>::unordered_set((uint64_t)v46, (unsigned int *)__dst, 1372);
  unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((v10[1] - *v10) >> 2);
  LOBYTE(__dst[0]) = 0;
  std::vector<BOOL>::vector(v13, v14, (unsigned __int8 *)__dst);
  uint64_t v44 = 0;
  uint64_t v45 = 0;
  uint64_t v16 = *v10;
  uint64_t v15 = v10[1];
  if (v15 != *v10)
  {
    uint64_t v17 = 0;
    unint64_t v18 = 0;
    int v19 = 0;
    int v20 = 0;
    _S8 = 15.0;
    while (1)
    {
      float v22 = *(float *)(v16 + v17);
      if (v22 < (float)v11[2])
      {
        float v23 = *(float *)(v16 + v17 + 4);
        if (v23 >= 0.0 && v22 >= 0.0 && v23 < (float)v11[3]) {
          break;
        }
      }
LABEL_18:
      ++v18;
      v17 += 12;
      if (0xAAAAAAAAAAAAAAABLL * ((v15 - v16) >> 2) <= v18) {
        goto LABEL_21;
      }
    }
    arkit::ImageViewYUV::at((arkit::ImageViewYUV *)v11, v22, v23, v43);
    LOBYTE(v25) = v43[0];
    LOBYTE(v26) = v43[1];
    LOBYTE(v27) = v43[2];
    *(float *)&uint64_t v44 = (float)v25 / 255.0;
    *((float *)&v44 + 1) = (float)v26 / 255.0;
    *(float *)&uint64_t v45 = (float)v27 / 255.0;
    HIDWORD(v45) = 1065353216;
    __dst[0] = xmmword_1B8A56C14;
    __dst[1] = unk_1B8A56C24;
    __dst[2] = xmmword_1B8A56C34;
    v47[0] = (uint64_t)__dst;
    v47[1] = (uint64_t)&v44;
    float32x2_t v41 = 0;
    float v42 = 0.0;
    cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,4u,false>,cva::Matrix<float,4u,1u,false>>((uint64_t)&v41, v47);
    _V0.S[1] = v41.i32[1];
    __asm { FMLA            S2, S8, V0.S[1] }
    *(float *)v34.i32 = _S2 + (float)(v42 * 3.0);
    if (*(float *)v34.i32 <= 0.0)
    {
      float v36 = (uint64_t *)(*v13 + 8 * (v18 >> 6));
      uint64_t v37 = 1 << v18;
    }
    else
    {
      *(float32x2_t *)&__dst[0] = vdiv_f32(vmul_f32(v41, (float32x2_t)0x40C0000040800000), (float32x2_t)vdup_lane_s32(v34, 0));
      DWORD2(__dst[0]) = v41.i32[1];
      LODWORD(v47[0]) = arkit::ChromaFilter::uvl2ind((uint64_t)__dst);
      uint64_t v35 = std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::find<unsigned int>(v46, (unsigned int *)v47);
      float v36 = (uint64_t *)(*v13 + 8 * (v18 >> 6));
      uint64_t v37 = 1 << v18;
      if (v35)
      {
        uint64_t v38 = *v36 | v37;
LABEL_15:
        *float v36 = v38;
        if ((v38 & v37) != 0) {
          ++v20;
        }
        ++v19;
        uint64_t v16 = *v10;
        uint64_t v15 = v10[1];
        goto LABEL_18;
      }
    }
    uint64_t v38 = *v36 & ~v37;
    goto LABEL_15;
  }
  int v20 = 0;
  int v19 = 0;
LABEL_21:
  if (v19 > 2 * v20)
  {
    unint64_t v39 = v13[1];
    if (v39)
    {
      *(void *)&__dst[0] = *v13;
      DWORD2(__dst[0]) = 0;
      std::__fill_n[abi:ne180100]<true,std::vector<BOOL>>(__dst, v39);
    }
  }
  return std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::~__hash_table((uint64_t)v46);
}

void sub_1B89FA96C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  if (*v6) {
    operator delete(*v6);
  }
  std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::~__hash_table((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t arkit::ImageViewYUV::at@<X0>(arkit::ImageViewYUV *this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  if (*((_DWORD *)this + 2) <= a2 || *((_DWORD *)this + 3) <= a3) {
    arkit::ImageViewYUV::at();
  }
  uint64_t v4 = 0;
  uint64_t v5 = *((void *)this + 1);
  unint64_t v34 = a2 | (unint64_t)(a3 << 32);
  uint64_t v35 = v5;
  do
  {
    unsigned int v6 = *(_DWORD *)((char *)&v34 + v4);
    unsigned int v7 = *(_DWORD *)((char *)&v35 + v4);
    BOOL v8 = v6 >= v7 || v4 == 4;
    v4 += 4;
  }
  while (!v8);
  if (v6 >= v7) {
    arkit::ImageViewYUV::at();
  }
  if (*((_DWORD *)this + 10) <= a2 >> 1 || (uint64_t v9 = a3 >> 1, *((_DWORD *)this + 11) <= v9)) {
    arkit::ImageViewYUV::at();
  }
  uint64_t v10 = 0;
  uint64_t v11 = *((void *)this + 3);
  uint64_t v12 = *(void *)this;
  int v13 = *((_DWORD *)this + 4);
  int v14 = *((_DWORD *)this + 5);
  uint64_t v15 = a2 >> 1;
  uint64_t v16 = *((void *)this + 5);
  unint64_t v34 = v15 | (v9 << 32);
  uint64_t v35 = v16;
  do
  {
    unsigned int v17 = *(_DWORD *)((char *)&v34 + v10);
    unsigned int v18 = *(_DWORD *)((char *)&v35 + v10);
    BOOL v19 = v17 >= v18 || v10 == 4;
    v10 += 4;
  }
  while (!v19);
  if (v17 >= v18) {
    arkit::ImageViewYUV::at();
  }
  if (*((_DWORD *)this + 18) <= v15 || *((_DWORD *)this + 19) <= v9) {
    arkit::ImageViewYUV::at();
  }
  uint64_t v20 = 0;
  uint64_t v21 = *((void *)this + 7);
  uint64_t v22 = *((void *)this + 4);
  int v23 = *((_DWORD *)this + 12);
  int v24 = *((_DWORD *)this + 13);
  unint64_t v34 = v15 | (v9 << 32);
  uint64_t v35 = *((void *)this + 9);
  do
  {
    unsigned int v25 = *(_DWORD *)((char *)&v34 + v20);
    unsigned int v26 = *(_DWORD *)((char *)&v35 + v20);
    BOOL v27 = v25 >= v26 || v20 == 4;
    v20 += 4;
  }
  while (!v27);
  if (v25 >= v26) {
    arkit::ImageViewYUV::at();
  }
  uint64_t v28 = v22 + (v23 * v15 + v24 * v9);
  uint64_t v29 = v12 + v13 * a2 + v14 * a3;
  uint64_t v30 = *((void *)this + 11);
  uint64_t v31 = *((void *)this + 8);
  int v33 = *((_DWORD *)this + 20);
  uint64_t result = *((unsigned int *)this + 21);
  *a4 = *(unsigned char *)(v11 + v29);
  a4[1] = *(unsigned char *)(v21 + v28);
  a4[2] = *(unsigned char *)(v30 + v31 + (v33 * v15 + result * v9));
  return result;
}

uint64_t *std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::find<unsigned int>(void *a1, unsigned int *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = *a2;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = *a2;
    if (*(void *)&v2 <= v3) {
      unint64_t v5 = v3 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v5 = (v2.i32[0] - 1) & v3;
  }
  unsigned int v6 = *(uint64_t ***)(*a1 + 8 * v5);
  if (!v6) {
    return 0;
  }
  for (uint64_t result = *v6; result; uint64_t result = (uint64_t *)*result)
  {
    unint64_t v8 = result[1];
    if (v8 == v3)
    {
      if (*((_DWORD *)result + 4) == v3) {
        return result;
      }
    }
    else
    {
      if (v4.u32[0] > 1uLL)
      {
        if (v8 >= *(void *)&v2) {
          v8 %= *(void *)&v2;
        }
      }
      else
      {
        v8 &= *(void *)&v2 - 1;
      }
      if (v8 != v5) {
        return 0;
      }
    }
  }
  return result;
}

uint64_t cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,4u,false>,cva::Matrix<float,4u,1u,false>>(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = result;
  uint64_t v3 = *a2;
  if (*a2 == result || (uint8x8_t v4 = (float *)a2[1], v4 == (float *)result))
  {
    int v11 = 0;
    uint64_t v10 = 0;
    uint64_t result = cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,4u,false>,cva::Matrix<float,4u,1u,false>>(&v10);
    *(void *)uint64_t v2 = v10;
    *(_DWORD *)(v2 + _Block_object_dispose(&STACK[0x400], 8) = v11;
  }
  else
  {
    for (uint64_t i = 0; i != 3; ++i)
    {
      uint64_t v6 = 0;
      float v7 = 0.0;
      unint64_t v8 = v4;
      do
      {
        float v9 = *v8++;
        float v7 = v7 + (float)(*(float *)(v3 + v6) * v9);
        v6 += 12;
      }
      while (v6 != 48);
      *(float *)(result + 4 * i) = v7;
      v3 += 4;
    }
  }
  return result;
}

uint64_t std::unordered_set<unsigned int>::unordered_set(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (a3)
  {
    uint64_t v5 = 4 * a3;
    do
    {
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>(a1, a2, a2);
      ++a2;
      v5 -= 4;
    }
    while (v5);
  }
  return a1;
}

void sub_1B89FACF8(_Unwind_Exception *a1)
{
  std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>(uint64_t a1, unsigned int *a2, _DWORD *a3)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = *a2;
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
    float v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == v6)
          {
            if (*((_DWORD *)v10 + 4) == v6) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  uint64_t v10 = operator new(0x18uLL);
  *uint64_t v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::__rehash<true>(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v18 = *(void *)a1;
  BOOL v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    *uint64_t v10 = *v19;
LABEL_38:
    *BOOL v19 = v10;
    goto LABEL_39;
  }
  *uint64_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }
    else
    {
      v20 &= v7 - 1;
    }
    BOOL v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1B89FAF18(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      unint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint8x8_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void *std::vector<BOOL>::vector(void *a1, unint64_t a2, unsigned __int8 *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<BOOL>::__vallocate[abi:ne180100](a1, a2);
    int v6 = *a3;
    unint64_t v7 = a1[1];
    unint64_t v8 = v7 + a2;
    a1[1] = v7 + a2;
    if (v7)
    {
      unint64_t v9 = v8 - 1;
      if (((v8 - 1) ^ (v7 - 1)) < 0x40)
      {
LABEL_10:
        uint64_t v13 = *a1 + 8 * (v7 >> 6);
        int v14 = v7 & 0x3F;
        if (v6) {
          std::__fill_n[abi:ne180100]<true,std::vector<BOOL>>(&v13, a2);
        }
        else {
          std::__fill_n[abi:ne180100]<false,std::vector<BOOL>>((uint64_t)&v13, a2);
        }
        return a1;
      }
    }
    else
    {
      unint64_t v9 = v8 - 1;
    }
    unint64_t v10 = v9 >> 6;
    if (v8 >= 0x41) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = 0;
    }
    *(void *)(*a1 + 8 * v11) = 0;
    goto LABEL_10;
  }
  return a1;
}

void *std::vector<BOOL>::__vallocate[abi:ne180100](void *a1, uint64_t a2)
{
  if (a2 < 0) {
    std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>((uint64_t)(a1 + 2), ((unint64_t)(a2 - 1) >> 6) + 1);
  *a1 = result;
  a1[1] = 0;
  a1[2] = v4;
  return result;
}

void *std::__fill_n[abi:ne180100]<true,std::vector<BOOL>>(void *result, unint64_t a2)
{
  unint64_t v2 = a2;
  unint64_t v3 = result;
  int v4 = *((_DWORD *)result + 2);
  uint64_t v5 = (void *)*result;
  if (v4)
  {
    if ((64 - v4) >= a2) {
      unint64_t v6 = a2;
    }
    else {
      unint64_t v6 = (64 - v4);
    }
    *v5++ |= (0xFFFFFFFFFFFFFFFFLL >> (64 - v4 - v6)) & (-1 << v4);
    unint64_t v2 = a2 - v6;
    *uint64_t result = v5;
  }
  unint64_t v7 = v2 >> 6;
  if (v2 >= 0x40) {
    uint64_t result = memset(v5, 255, 8 * v7);
  }
  if ((v2 & 0x3F) != 0)
  {
    unint64_t v8 = &v5[v7];
    void *v3 = v8;
    *v8 |= 0xFFFFFFFFFFFFFFFFLL >> -(v2 & 0x3F);
  }
  return result;
}

void std::__fill_n[abi:ne180100]<false,std::vector<BOOL>>(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = a2;
  int v4 = *(_DWORD *)(a1 + 8);
  uint64_t v5 = *(void **)a1;
  if (v4)
  {
    if ((64 - v4) >= a2) {
      unint64_t v6 = a2;
    }
    else {
      unint64_t v6 = (64 - v4);
    }
    *v5++ &= ~((0xFFFFFFFFFFFFFFFFLL >> (64 - v4 - v6)) & (-1 << v4));
    unint64_t v2 = a2 - v6;
    *(void *)a1 = v5;
  }
  unint64_t v7 = v2 >> 6;
  if (v2 >= 0x40) {
    bzero(v5, 8 * v7);
  }
  if ((v2 & 0x3F) != 0)
  {
    unint64_t v8 = &v5[v7];
    *(void *)a1 = v8;
    *v8 &= ~(0xFFFFFFFFFFFFFFFFLL >> -(v2 & 0x3F));
  }
}

void arkit::FacialLightEstimation::FacialLightEstimation(arkit::FacialLightEstimation *this)
{
  *(_OWORD *)((char *)this + 24) = 0u;
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((_DWORD *)this + 4) = 0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((void *)this + 11) = 0;
  operator new();
}

void sub_1B89FB97C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  free(*(void **)(v15 + 72));
  uint64_t v18 = *(void **)(v15 + 48);
  if (v18)
  {
    *(void *)(v15 + 56) = v18;
    operator delete(v18);
  }
  BOOL v19 = *v16;
  if (*v16)
  {
    *(void *)(v15 + 32) = v19;
    operator delete(v19);
  }
  free(*(void **)v15);
  _Unwind_Resume(a1);
}

void arkit::FacialLightEstimation::estimateLight(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  arkit::PrecomputedFaceData::getValidSampleIDs(*(arkit::PrecomputedFaceData **)(a1 + 96), __p);
  unint64_t v9 = *(void **)(a1 + 48);
  if (v9)
  {
    *(void *)(a1 + 56) = v9;
    operator delete(v9);
    *(void *)(a1 + 4_Block_object_dispose(&STACK[0x400], 8) = 0;
    *(void *)(a1 + 56) = 0;
    *(void *)(a1 + 64) = 0;
  }
  *(_OWORD *)(a1 + 4_Block_object_dispose(&STACK[0x400], 8) = *(_OWORD *)__p;
  *(void *)(a1 + 64) = *(void *)&__p[16];
  uint64_t v88 = a3;
  arkit::FaceTrackingData::filteredLandmarks(a3, (int **)(a1 + 48), (uint64_t)&v115);
  uint64_t v112 = 0;
  uint64_t v113 = 0;
  __n128 v114 = 0;
  unint64_t v10 = v115;
  unint64_t v11 = v116;
  if (v115 != v116)
  {
    float v12 = 0;
    do
    {
      int v13 = v10[8];
      if (v12 >= v114)
      {
        uint64_t v15 = v112;
        uint64_t v16 = (v12 - v112) >> 2;
        unint64_t v17 = v16 + 1;
        if ((unint64_t)(v16 + 1) >> 62) {
          std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v18 = v114 - v112;
        if ((v114 - v112) >> 1 > v17) {
          unint64_t v17 = v18 >> 1;
        }
        if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v19 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v19 = v17;
        }
        if (v19)
        {
          unint64_t v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v114, v19);
          uint64_t v15 = v112;
          float v12 = v113;
        }
        else
        {
          unint64_t v20 = 0;
        }
        uint64_t v21 = &v20[4 * v16];
        *(_DWORD *)uint64_t v21 = v13;
        int v14 = v21 + 4;
        while (v12 != v15)
        {
          int v22 = *((_DWORD *)v12 - 1);
          v12 -= 4;
          *((_DWORD *)v21 - 1) = v22;
          v21 -= 4;
        }
        uint64_t v112 = v21;
        uint64_t v113 = v14;
        __n128 v114 = &v20[4 * v19];
        if (v15) {
          operator delete(v15);
        }
      }
      else
      {
        *(_DWORD *)float v12 = v13;
        int v14 = v12 + 4;
      }
      uint64_t v113 = v14;
      v10 += 12;
      float v12 = v14;
    }
    while (v10 != v11);
  }
  if (*(unsigned char *)(a2 + 9))
  {
    kdebug_trace();
    arkit::ChromaFilter::filter(a4, (uint64_t)&v115, v23, v24, v25, v26, v27, v28);
    kdebug_trace();
    uint64_t v29 = v112;
    uint64_t v30 = *(char **)__p;
    if (v113 == v112)
    {
      if (!*(void *)__p) {
        goto LABEL_33;
      }
    }
    else
    {
      unint64_t v31 = 0;
      unint64_t v32 = (v113 - v112) >> 2;
      if (v32 <= 1) {
        unint64_t v32 = 1;
      }
      do
      {
        BOOL v33 = ((*(void *)&v30[(v31 >> 3) & 0x1FFFFFFFFFFFFFF8] >> v31) & 1) != 0 && *(_DWORD *)&v29[4 * v31] == 1;
        *(_DWORD *)&v29[4 * v31++] = v33;
      }
      while (v32 != v31);
    }
    operator delete(v30);
  }
LABEL_33:
  __n128 v109 = 0;
  long long v110 = 0;
  uint64_t v111 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(&v109, *(const void **)(a1 + 48), *(void *)(a1 + 56), (uint64_t)(*(void *)(a1 + 56) - *(void *)(a1 + 48)) >> 2);
  unint64_t v34 = v112;
  uint64_t v35 = v113;
  if (v112 != v113)
  {
    float v36 = v109;
    do
    {
      if (*(_DWORD *)v34)
      {
        ++v36;
      }
      else
      {
        int64_t v37 = (char *)v110 - (char *)(v36 + 1);
        if (v110 != v36 + 1) {
          memmove(v36, v36 + 1, (char *)v110 - (char *)(v36 + 1));
        }
        long long v110 = (int *)((char *)v36 + v37);
      }
      v34 += 4;
    }
    while (v34 != v35);
  }
  arkit::FaceTrackingData::filteredLandmarks(v88, &v109, (uint64_t)&v107);
  if (0xAAAAAAAAAAAAAAABLL * ((v108 - v107) >> 2) != v110 - v109) {
    __assert_rtn("estimateLight", "FacialLightEstimation.cpp", 67, "sampleIndices.size() == samplePositions.size()");
  }
  if (v108 == v107) {
    goto LABEL_48;
  }
  arkit::FacialLightEstimation::populateValidImageSamples(a1, a4, (uint64_t *)&v109, &v107, &v112);
  unint64_t v38 = *(unsigned int *)(a1 + 16);
  if (v38)
  {
    unint64_t v39 = *(float **)a1;
    uint64_t v40 = *(unsigned int *)(a1 + 16);
    do
    {
      *unint64_t v39 = powf(*v39, 2.2);
      ++v39;
      --v40;
    }
    while (v40);
  }
  if (v38 == *(_DWORD *)(a1 + 88) && v38 >= *(_DWORD *)(a1 + 92))
  {
    int64x2_t v105 = 0uLL;
    v106[0] = 0;
    std::vector<std::pair<float,cva::Matrix<float,1u,0u,false>>>::reserve(v105.i64, v38);
    unint64_t v41 = *(unsigned int *)(a1 + 88);
    if (v41)
    {
      unint64_t v42 = 0;
      do
      {
        if (v42 >= *(unsigned int *)(a1 + 16)) {
          __assert_rtn("assert_in_bounds", "matrixmixin.h", 2283, "(i < mixed().elements()) || cva::detail::assertMessage(\"Index out of bounds!\")");
        }
        if (v42 >= v41) {
          __assert_rtn("row", "matrixmixin.h", 1063, "(row < mixed().rows()) || cva::detail::assertMessage(\"Index out of bounds.\")");
        }
        int v43 = *(_DWORD *)(a1 + 92);
        uint64_t v44 = *(void *)(a1 + 72) + 4 * v42;
        LODWORD(v94) = *(_DWORD *)(*(void *)a1 + 4 * v42);
        DWORD2(v94) = v43;
        *(void *)&long long v95 = v44;
        *((void *)&v95 + 1) = __PAIR64__(v42, v41);
        std::pair<float,cva::Matrix<float,1u,0u,false>>::pair[abi:ne180100]<float,cva::MatrixRef<float,1u,0u,false>,0>((uint64_t)v97, (uint64_t)&v94);
        uint64_t v45 = v105.i64[1];
        if (v105.i64[1] >= v106[0])
        {
          uint64_t v48 = (v105.i64[1] - v105.i64[0]) >> 5;
          unint64_t v49 = v48 + 1;
          if ((unint64_t)(v48 + 1) >> 59) {
            std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v50 = v106[0] - v105.i64[0];
          if ((v106[0] - v105.i64[0]) >> 4 > v49) {
            unint64_t v49 = v50 >> 4;
          }
          if ((unint64_t)v50 >= 0x7FFFFFFFFFFFFFE0) {
            unint64_t v51 = 0x7FFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v51 = v49;
          }
          int v101 = v106;
          uint64_t v52 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<arkit::IntRect>>((uint64_t)v106, v51);
          int v53 = &v52[32 * v48];
          *(void *)__p = v52;
          *(void *)&__p[8] = v53;
          *(void *)&__p[24] = &v52[32 * v54];
          *(_DWORD *)int v53 = v97[0];
          *((void *)v53 + 1) = 0;
          *((void *)v53 + 2) = 0;
          *((void **)v53 + 1) = v97[1];
          v97[1] = 0;
          *((void *)v53 + 2) = v98;
          *(void *)&long long v98 = 0;
          *((_DWORD *)v53 + 6) = DWORD2(v98);
          DWORD2(v9_Block_object_dispose(&STACK[0x400], 8) = 0;
          int v47 = v53 + 32;
          *(void *)&__p[16] = v53 + 32;
          int64x2_t v55 = v105;
          uint64_t v56 = *(void *)&__p[8];
          if (v105.i64[1] == v105.i64[0])
          {
            int64x2_t v60 = vdupq_n_s64(v105.u64[1]);
          }
          else
          {
            uint64_t v57 = 0;
            do
            {
              uint64_t v58 = v56 + v57;
              uint64_t v59 = v55.i64[1] + v57;
              *(_DWORD *)(v58 - 32) = *(_DWORD *)(v55.i64[1] + v57 - 32);
              *(void *)(v58 - 24) = 0;
              *(void *)(v58 - 16) = 0;
              *(void *)(v58 - 24) = *(void *)(v55.i64[1] + v57 - 24);
              *(void *)(v59 - 24) = 0;
              *(void *)(v58 - 16) = *(void *)(v55.i64[1] + v57 - 16);
              *(void *)(v59 - 16) = 0;
              *(_DWORD *)(v58 - _Block_object_dispose(&STACK[0x400], 8) = *(_DWORD *)(v55.i64[1] + v57 - 8);
              *(_DWORD *)(v59 - _Block_object_dispose(&STACK[0x400], 8) = 0;
              v57 -= 32;
            }
            while (v55.i64[1] + v57 != v55.i64[0]);
            int64x2_t v60 = v105;
            int v47 = *(char **)&__p[16];
            v56 += v57;
          }
          v105.i64[0] = v56;
          v105.i64[1] = (uint64_t)v47;
          *(int64x2_t *)&__p[8] = v60;
          uint64_t v61 = v106[0];
          v106[0] = *(void *)&__p[24];
          *(void *)&__p[24] = v61;
          *(void *)__p = v60.i64[0];
          std::__split_buffer<std::pair<float,cva::Matrix<float,1u,0u,false>>>::~__split_buffer((uint64_t)__p);
          uint64_t v46 = v97[1];
        }
        else
        {
          uint64_t v46 = 0;
          *(_DWORD *)v105.i64[1] = v97[0];
          *(void *)(v45 + _Block_object_dispose(&STACK[0x400], 8) = 0;
          *(void *)(v45 + 16) = 0;
          *(void **)(v45 + _Block_object_dispose(&STACK[0x400], 8) = v97[1];
          *(void *)(v45 + 16) = v98;
          *(_DWORD *)(v45 + 24) = DWORD2(v98);
          v97[1] = 0;
          *(void *)&long long v98 = 0;
          DWORD2(v9_Block_object_dispose(&STACK[0x400], 8) = 0;
          int v47 = (char *)(v45 + 32);
        }
        ++v42;
        v105.i64[1] = (uint64_t)v47;
        free(v46);
        unint64_t v41 = *(unsigned int *)(a1 + 88);
      }
      while (v42 < v41);
    }
    arkit::runSolver(v105.i64, a2, (uint64_t)__p);
    *(_OWORD *)uint64_t v97 = *(_OWORD *)__p;
    long long v98 = *(_OWORD *)&__p[16];
    int v99 = (int)v101;
    int v63 = (void **)(a1 + 152);
    float32x2_t v62 = *(char **)(a1 + 152);
    *(void *)(a1 + 160) = v62;
    __n128 v64 = v102;
    unsigned int v65 = v103;
    if (v102 != v103)
    {
      unsigned int v66 = (void *)(a1 + 168);
      do
      {
        uint64_t v67 = v109[*v64];
        if ((unint64_t)v62 >= *v66)
        {
          uint64_t v69 = (char *)*v63;
          uint64_t v70 = (v62 - (unsigned char *)*v63) >> 3;
          unint64_t v71 = v70 + 1;
          if ((unint64_t)(v70 + 1) >> 61) {
            std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v72 = *v66 - (void)v69;
          if (v72 >> 2 > v71) {
            unint64_t v71 = v72 >> 2;
          }
          if ((unint64_t)v72 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v73 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v73 = v71;
          }
          if (v73)
          {
            uint64_t v74 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>(a1 + 168, v73);
            uint64_t v69 = *(char **)(a1 + 152);
            float32x2_t v62 = *(char **)(a1 + 160);
          }
          else
          {
            uint64_t v74 = 0;
          }
          long long v75 = &v74[8 * v70];
          *(void *)long long v75 = v67;
          uint64_t v68 = v75 + 8;
          while (v62 != v69)
          {
            uint64_t v76 = *((void *)v62 - 1);
            v62 -= 8;
            *((void *)v75 - 1) = v76;
            v75 -= 8;
          }
          *(void *)(a1 + 152) = v75;
          *(void *)(a1 + 160) = v68;
          *(void *)(a1 + 16_Block_object_dispose(&STACK[0x400], 8) = &v74[8 * v73];
          if (v69) {
            operator delete(v69);
          }
        }
        else
        {
          *(void *)float32x2_t v62 = v67;
          uint64_t v68 = v62 + 8;
        }
        *(void *)(a1 + 160) = v68;
        ++v64;
        float32x2_t v62 = v68;
      }
      while (v64 != v65);
    }
    for (uint64_t i = 0; i != 36; i += 4)
      ;
    long long v78 = *(_OWORD *)(v88 + 16);
    long long v94 = *(_OWORD *)v88;
    long long v95 = v78;
    float v96 = *(float *)(v88 + 32);
    arkit::shct::rotateShCoeff((uint64_t)v97, (float *)&v94, (uint64_t)v93);
    float v79 = *((float *)&v94 + 2);
    float v80 = *((float *)&v95 + 1);
    float v81 = v96;
    float v89 = atan2f(*((float *)&v95 + 1), v96);
    v82.f32[0] = atan2f(-v79, sqrtf((float)(v81 * v81) + (float)(v80 * v80)));
    v82.f32[1] = v89;
    float64x2_t v83 = vsubq_f64((float64x2_t)xmmword_1B8A581C0, vabsq_f64(vdivq_f64(vcvtq_f64_f32(vmul_f32(v82, (float32x2_t)vdup_n_s32(0x43340000u))), (float64x2_t)vdupq_n_s64(0x400921FB54442D18uLL))));
    if (v83.f64[0] >= v83.f64[1]) {
      v83.f64[0] = v83.f64[1];
    }
    double v84 = *(float *)a2;
    float v85 = v83.f64[0];
    *(float *)&unsigned int v86 = 1.0 / (float)(expf(v85 * -0.8) + 1.0) * v84;
    arkit::ExponentialSmoother<cva::Matrix<float,9u,1u,false>>::step(a1 + 112, v93, (uint64_t)v91, v86);
    long long v87 = v91[1];
    *(_OWORD *)a5 = v91[0];
    *(_OWORD *)(a5 + 16) = v87;
    *(_DWORD *)(a5 + 32) = v92;
    *(_DWORD *)(a5 + 36) = v104;
    if (v102)
    {
      uint64_t v103 = v102;
      operator delete(v102);
    }
    *(void *)__p = &v105;
    std::vector<std::pair<float,cva::Matrix<float,1u,0u,false>>>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
  }
  else
  {
LABEL_48:
    *(void *)(a5 + 32) = 0;
    *(_OWORD *)a5 = 0u;
    *(_OWORD *)(a5 + 16) = 0u;
  }
  if (v107)
  {
    v108 = v107;
    operator delete(v107);
  }
  if (v109)
  {
    long long v110 = v109;
    operator delete(v109);
  }
  if (v112)
  {
    uint64_t v113 = v112;
    operator delete(v112);
  }
  if (v115)
  {
    int v116 = v115;
    operator delete(v115);
  }
}

void sub_1B89FC278(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,void *__p,uint64_t a39)
{
  if (__p)
  {
    a39 = (uint64_t)__p;
    operator delete(__p);
  }
  a27 = v39 - 256;
  std::vector<std::pair<float,cva::Matrix<float,1u,0u,false>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a27);
  unint64_t v41 = *(void **)(v39 - 224);
  if (v41)
  {
    *(void *)(v39 - 216) = v41;
    operator delete(v41);
  }
  unint64_t v42 = *(void **)(v39 - 200);
  if (v42)
  {
    *(void *)(v39 - 192) = v42;
    operator delete(v42);
  }
  int v43 = *(void **)(v39 - 176);
  if (v43)
  {
    *(void *)(v39 - 16_Block_object_dispose(&STACK[0x400], 8) = v43;
    operator delete(v43);
  }
  uint64_t v44 = *(void **)(v39 - 152);
  if (v44)
  {
    *(void *)(v39 - 144) = v44;
    operator delete(v44);
  }
  _Unwind_Resume(a1);
}

void arkit::FacialLightEstimation::populateValidImageSamples(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4, void *a5)
{
  unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a4[1] - *a4) >> 2);
  *(_DWORD *)(a1 + 16) = v10;
  cva::MatrixData<float,0ul,0ul,false>::reserve(a1, v10);
  *(void *)(a1 + 32) = *(void *)(a1 + 24);
  unint64_t v11 = a4;
  std::vector<int>::reserve((std::vector<int> *)(a1 + 24), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a4[1] - *a4) >> 2));
  uint64_t v12 = (a4[1] - *a4) >> 2;
  *(_DWORD *)(a1 + 8_Block_object_dispose(&STACK[0x400], 8) = -1431655765 * v12;
  *(_DWORD *)(a1 + 92) = 9;
  int v53 = (void **)(a1 + 24);
  cva::MatrixData<float,0ul,0ul,false>::reserve(a1 + 72, (3 * v12));
  uint64_t v14 = *a3;
  uint64_t v13 = a3[1];
  uint64_t v54 = a3;
  if (v13 != *a3)
  {
    unint64_t v15 = 0;
    unsigned int v56 = 0;
    LODWORD(v16) = 0;
    uint64_t v52 = "(row < mixed().rows()) || cva::detail::assertMessage(\"Index out of bounds.\")";
    uint64_t v50 = "row";
    unint64_t v51 = "matrixmixin.h";
    uint64_t v55 = a2;
    while (1)
    {
      unint64_t v17 = (uint64_t)(a5[1] - *a5) >> 2;
      if (v17 > (int)v16)
      {
        unint64_t v16 = (int)v16;
        do
        {
          if (*(_DWORD *)(*a5 + 4 * v16)) {
            break;
          }
          ++v16;
        }
        while (v17 > v16);
      }
      uint64_t v18 = (float *)(*v11 + 12 * v15);
      float v19 = *v18;
      if (*v18 >= 0.0 && v19 < (float)*(unsigned int *)(a2 + 8))
      {
        float v20 = v18[1];
        if (v20 >= 0.0)
        {
          float v21 = (float)*(unsigned int *)(a2 + 12);
          if (v20 < v21)
          {
            uint64_t v23 = *(char **)(a1 + 32);
            unint64_t v22 = *(void *)(a1 + 40);
            if ((unint64_t)v23 >= v22)
            {
              uint64_t v25 = (char *)*v53;
              uint64_t v26 = (v23 - (unsigned char *)*v53) >> 2;
              unint64_t v27 = v26 + 1;
              if ((unint64_t)(v26 + 1) >> 62) {
                std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
              }
              uint64_t v28 = v22 - (void)v25;
              if (v28 >> 1 > v27) {
                unint64_t v27 = v28 >> 1;
              }
              if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v29 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v29 = v27;
              }
              if (v29)
              {
                uint64_t v30 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(a1 + 40, v29);
                uint64_t v25 = *(char **)(a1 + 24);
                uint64_t v23 = *(char **)(a1 + 32);
              }
              else
              {
                uint64_t v30 = 0;
              }
              unint64_t v31 = &v30[4 * v26];
              *(_DWORD *)unint64_t v31 = *(_DWORD *)(v14 + 4 * v15);
              uint64_t v24 = v31 + 4;
              if (v23 == v25)
              {
                a2 = v55;
              }
              else
              {
                a2 = v55;
                do
                {
                  int v32 = *((_DWORD *)v23 - 1);
                  v23 -= 4;
                  *((_DWORD *)v31 - 1) = v32;
                  v31 -= 4;
                }
                while (v23 != v25);
              }
              *(void *)(a1 + 24) = v31;
              *(void *)(a1 + 32) = v24;
              *(void *)(a1 + 40) = &v30[4 * v29];
              if (v25) {
                operator delete(v25);
              }
            }
            else
            {
              *(_DWORD *)uint64_t v23 = *(_DWORD *)(v14 + 4 * v15);
              uint64_t v24 = v23 + 4;
            }
            uint64_t v33 = 0;
            *(void *)(a1 + 32) = v24;
            uint64_t v34 = v19;
            uint64_t v35 = v20;
            v59[0] = v34 | (v35 << 32);
            v57[0] = *(void **)(a2 + 8);
            do
            {
              unsigned int v36 = *(_DWORD *)((char *)v59 + v33);
              unsigned int v37 = *(_DWORD *)((char *)v57 + v33);
              BOOL v38 = v36 >= v37 || v33 == 4;
              v33 += 4;
            }
            while (!v38);
            if (v36 >= v37) {
              arkit::ImageViewYUV::at();
            }
            if (v15 >= *(unsigned int *)(a1 + 16)) {
              arkit::FacialLightEstimation::populateValidImageSamples();
            }
            uint64_t v39 = v11;
            LOBYTE(v21) = *(unsigned char *)(*(void *)(a2 + 24)
                                   + *(void *)a2
                                   + (*(_DWORD *)(a2 + 16) * v34 + *(_DWORD *)(a2 + 20) * v35));
            *(float *)(*(void *)a1 + 4 * v15) = (float)LODWORD(v21) * 0.0039216;
            RTF = (cva::Logger *)arkit::PrecomputedFaceData::getRTF(*(arkit::PrecomputedFaceData **)(a1 + 96), v16, (uint64_t)v57);
            uint64_t v41 = *(int *)(a1 + 88);
            if (v41 <= v56)
            {
              int v49 = 1063;
              goto LABEL_58;
            }
            int v42 = *(_DWORD *)(a1 + 92);
            uint64_t v43 = *(void *)(a1 + 72);
            if (v42 != v58)
            {
              cva::Logger::instance(RTF);
              cva::Logger::logInCategory();
              if (v42 != v58)
              {
                int v49 = 163;
                uint64_t v50 = "assert_equal_size";
                unint64_t v51 = "matrixfun.h";
                uint64_t v52 = "(lhs.rows() == rhs.rows() && lhs.columns() == rhs.columns()) || cva::detail::assertMessage(\"Matri"
                      "x sizes are not compatible!\")";
LABEL_58:
                __assert_rtn(v50, v51, v49, v52);
              }
            }
            if (v42) {
              uint64_t v44 = (_DWORD *)(v43 + 4 * v56);
            }
            else {
              uint64_t v44 = 0;
            }
            uint64_t v45 = v43 + 4 * v56 + 4 * (v42 * v41);
            if (!v42) {
              uint64_t v45 = 0;
            }
            uint64_t v46 = v57[0];
            if (v44 != (_DWORD *)v45)
            {
              int v47 = (int *)v57[0];
              do
              {
                int v48 = *v47++;
                *uint64_t v44 = v48;
                v44 += v41;
              }
              while (v44 != (_DWORD *)v45);
            }
            ++v56;
            free(v46);
            LODWORD(v16) = v16 + 1;
            a2 = v55;
            uint64_t v14 = *v54;
            uint64_t v13 = v54[1];
            unint64_t v11 = v39;
          }
        }
      }
      if (++v15 >= (v13 - v14) >> 2) {
        goto LABEL_52;
      }
    }
  }
  unsigned int v56 = 0;
LABEL_52:
  cva::Matrix<float,0u,0u,false>::conservativeResize((uint64_t *)(a1 + 72), v56, 9u);
  cva::Matrix<float,0u,1u,false>::conservativeResize(a1, v56, 1);
}

void sub_1B89FC79C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22)
{
}

uint64_t std::vector<std::pair<float,cva::Matrix<float,1u,0u,false>>>::reserve(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  if (a2 > (v4 - *a1) >> 5)
  {
    if (a2 >> 59) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v5 = a1[1] - *a1;
    _OWORD v7[4] = result;
    v7[0] = std::__allocate_at_least[abi:ne180100]<std::allocator<arkit::IntRect>>(result, a2);
    v7[1] = v7[0] + v5;
    _OWORD v7[2] = v7[0] + v5;
    v7[3] = v7[0] + 32 * v6;
    std::vector<std::pair<float,cva::Matrix<float,1u,0u,false>>>::__swap_out_circular_buffer(a1, v7);
    return std::__split_buffer<std::pair<float,cva::Matrix<float,1u,0u,false>>>::~__split_buffer((uint64_t)v7);
  }
  return result;
}

void sub_1B89FC834(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::pair<float,cva::Matrix<float,1u,0u,false>>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

__n128 arkit::ExponentialSmoother<cva::Matrix<float,9u,1u,false>>::step@<Q0>(uint64_t a1@<X0>, long long *a2@<X1>, uint64_t a3@<X8>, unsigned int a4@<S0>)
{
  if (*(unsigned char *)(a1 + 36))
  {
    v11[0] = a2;
    v11[1] = a4;
    v10[0] = a1;
    v10[1] = COERCE_UNSIGNED_INT(1.0 - *(float *)&a4);
    v12[0] = (float *)v11;
    v12[1] = (float *)v10;
    std::optional<cva::Matrix<float,9u,1u,false>>::operator=[abi:ne180100]<cva::MatrixBinaryExpr<cva::MatrixScalarExpr<cva::Matrix<float,9u,1u,false>,cva::detail::MulOp>,cva::MatrixScalarExpr<cva::Matrix<float,9u,1u,false>,cva::detail::MulOp>,cva::detail::AddOp>,void>(a1, v12);
    if (!*(unsigned char *)(a1 + 36)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
  }
  else
  {
    long long v6 = *a2;
    long long v7 = a2[1];
    *(_DWORD *)(a1 + 32) = *((_DWORD *)a2 + 8);
    *(_OWORD *)a1 = v6;
    *(_OWORD *)(a1 + 16) = v7;
    *(unsigned char *)(a1 + 36) = 1;
  }
  __n128 result = *(__n128 *)a1;
  long long v9 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)a3 = *(_OWORD *)a1;
  *(_OWORD *)(a3 + 16) = v9;
  *(_DWORD *)(a3 + 32) = *(_DWORD *)(a1 + 32);
  return result;
}

void std::vector<int>::reserve(std::vector<int> *this, std::vector<int>::size_type __n)
{
  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  if (__n > value - this->__begin_)
  {
    if (__n >> 62) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    int64_t v5 = (char *)this->__end_ - (char *)this->__begin_;
    long long v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)p_end_cap, __n);
    long long v7 = (int *)&v6[v5 & 0xFFFFFFFFFFFFFFFCLL];
    long long v9 = (int *)&v6[4 * v8];
    std::vector<int>::pointer begin = this->__begin_;
    std::vector<unsigned int>::pointer end = this->__end_;
    uint64_t v12 = v7;
    if (end != this->__begin_)
    {
      uint64_t v12 = v7;
      do
      {
        int v13 = *--end;
        *--uint64_t v12 = v13;
      }
      while (end != begin);
    }
    this->__begin_ = v12;
    this->__end_ = v7;
    this->__end_cap_.__value_ = v9;
    if (begin)
    {
      operator delete(begin);
    }
  }
}

void cva::Matrix<float,0u,0u,false>::conservativeResize(uint64_t *a1, unsigned int a2, unsigned int a3)
{
  unint64_t v6 = a3 * a2;
  if (a1[1] >= v6)
  {
    if (a3 >= 2)
    {
      unsigned int v14 = *((_DWORD *)a1 + 4);
      if (v14 != a2)
      {
        unsigned int v15 = *((_DWORD *)a1 + 5);
        if (v15 > 1)
        {
          if (v15 >= a3) {
            uint64_t v16 = a3;
          }
          else {
            uint64_t v16 = v15;
          }
          if (v14 <= a2)
          {
            int v19 = v16 - 1;
            unsigned int v20 = a2 * (v16 - 1);
            do
            {
              memmove((void *)(*a1 + 4 * v20), (const void *)(*a1 + 4 * (*((_DWORD *)a1 + 4) * v19)), 4 * *((unsigned int *)a1 + 4));
              v20 -= a2;
              --v19;
            }
            while (v19);
          }
          else
          {
            uint64_t v17 = 1;
            unsigned int v18 = a2;
            do
            {
              memmove((void *)(*a1 + 4 * v18), (const void *)(*a1 + 4 * (*((_DWORD *)a1 + 4) * v17++)), 4 * a2);
              v18 += a2;
            }
            while (v16 != v17);
          }
        }
      }
    }
    *((_DWORD *)a1 + 4) = a2;
    *((_DWORD *)a1 + 5) = a3;
  }
  else
  {
    unint64_t v29 = 0;
    uint64_t v30 = 0;
    cva::MatrixData<float,0ul,0ul,false>::allocate(&v29, v6);
    unint64_t v31 = __PAIR64__(a3, a2);
    unsigned int v7 = *((_DWORD *)a1 + 4);
    unsigned int v8 = *((_DWORD *)a1 + 5);
    if (v7 >= a2) {
      unsigned int v9 = a2;
    }
    else {
      unsigned int v9 = *((_DWORD *)a1 + 4);
    }
    if (v8 >= a3) {
      unsigned int v8 = a3;
    }
    uint64_t v10 = *a1;
    v25[0] = v9;
    v25[1] = v8;
    uint64_t v26 = v10;
    unsigned int v27 = v7;
    int v28 = 0;
    v21[0] = v9;
    v21[1] = v8;
    unint64_t v22 = v29;
    unsigned int v23 = a2;
    int v24 = 0;
    cva::MatrixRef<float,0u,0u,false>::operator=<cva::MatrixRef<float,0u,0u,false>>((cva::Logger *)v21, (uint64_t)v25);
    unint64_t v11 = (void *)*a1;
    uint64_t v12 = a1[1];
    uint64_t v13 = v30;
    *a1 = (uint64_t)v29;
    a1[1] = v13;
    unint64_t v29 = v11;
    uint64_t v30 = v12;
    a1[2] = v31;
    unint64_t v31 = 0;
    free(v11);
  }
}

void sub_1B89FCAF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
}

uint64_t std::pair<float,cva::Matrix<float,1u,0u,false>>::pair[abi:ne180100]<float,cva::MatrixRef<float,1u,0u,false>,0>(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  uint64_t v4 = *(unsigned int *)(a2 + 8);
  *(void *)(a1 + _Block_object_dispose(&STACK[0x400], 8) = 0;
  int64_t v5 = (_DWORD **)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  unint64_t v6 = (cva::Logger *)cva::MatrixData<float,0ul,0ul,false>::allocate((void **)(a1 + 8), v4);
  uint64_t v7 = *(unsigned int *)(a2 + 8);
  *(_DWORD *)(a1 + 24) = v7;
  unsigned int v8 = *v5;
  if ((_DWORD *)(*(void *)(a2 + 16) - 4 * *(unsigned int *)(a2 + 28)) == *v5)
  {
    unint64_t v22 = 0;
    uint64_t v23 = 0;
    uint64_t v12 = (cva::Logger *)cva::MatrixData<float,0ul,0ul,false>::allocate(&v22, v7);
    unsigned int v24 = v7;
    if (v7 != *(_DWORD *)(a2 + 8))
    {
      cva::Logger::instance(v12);
      cva::Logger::logInCategory();
      uint64_t v7 = v24;
      if (v24 != *(_DWORD *)(a2 + 8)) {
        __assert_rtn("assert_equal_size", "matrixfun.h", 163, "(lhs.rows() == rhs.rows() && lhs.columns() == rhs.columns()) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
      }
    }
    uint64_t v13 = v22;
    if (v7)
    {
      unsigned int v14 = *(_DWORD **)(a2 + 16);
      uint64_t v15 = 4 * v7;
      uint64_t v16 = 4 * *(int *)(a2 + 24);
      uint64_t v17 = v22;
      do
      {
        *v17++ = *v14;
        unsigned int v14 = (_DWORD *)((char *)v14 + v16);
        v15 -= 4;
      }
      while (v15);
    }
    unsigned int v18 = *(void **)(a1 + 8);
    uint64_t v19 = *(void *)(a1 + 16);
    uint64_t v20 = v23;
    *(void *)(a1 + _Block_object_dispose(&STACK[0x400], 8) = v13;
    *(void *)(a1 + 16) = v20;
    unint64_t v22 = v18;
    uint64_t v23 = v19;
    *(_DWORD *)(a1 + 24) = v7;
    unsigned int v24 = 0;
    free(v18);
  }
  else
  {
    if (v7 != *(_DWORD *)(a2 + 8))
    {
      cva::Logger::instance(v6);
      cva::Logger::logInCategory();
      LODWORD(v7) = *(_DWORD *)(a1 + 24);
      if (v7 != *(_DWORD *)(a2 + 8)) {
        __assert_rtn("assert_equal_size", "matrixfun.h", 163, "(lhs.rows() == rhs.rows() && lhs.columns() == rhs.columns()) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
      }
      unsigned int v8 = *v5;
    }
    if (v7)
    {
      unsigned int v9 = *(_DWORD **)(a2 + 16);
      uint64_t v10 = 4 * v7;
      uint64_t v11 = 4 * *(int *)(a2 + 24);
      do
      {
        *v8++ = *v9;
        unsigned int v9 = (_DWORD *)((char *)v9 + v11);
        v10 -= 4;
      }
      while (v10);
    }
  }
  return a1;
}

void sub_1B89FCCFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  free(a14);
  free(*v14);
  _Unwind_Resume(a1);
}

void std::shared_ptr<arkit::PrecomputedFaceData>::shared_ptr[abi:ne180100]<arkit::PrecomputedFaceData,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1B89FCD94(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<arkit::PrecomputedFaceData>::reset[abi:ne180100]((arkit::PrecomputedFaceData **)va, 0);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<arkit::PrecomputedFaceData *,std::shared_ptr<arkit::PrecomputedFaceData>::__shared_ptr_default_delete<arkit::PrecomputedFaceData,arkit::PrecomputedFaceData>,std::allocator<arkit::PrecomputedFaceData>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BA9C56C0);
}

arkit::PrecomputedFaceData *std::__shared_ptr_pointer<arkit::PrecomputedFaceData *,std::shared_ptr<arkit::PrecomputedFaceData>::__shared_ptr_default_delete<arkit::PrecomputedFaceData,arkit::PrecomputedFaceData>,std::allocator<arkit::PrecomputedFaceData>>::__on_zero_shared(uint64_t a1)
{
  __n128 result = *(arkit::PrecomputedFaceData **)(a1 + 24);
  if (result)
  {
    arkit::PrecomputedFaceData::~PrecomputedFaceData(result);
    JUMPOUT(0x1BA9C56C0);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<arkit::PrecomputedFaceData *,std::shared_ptr<arkit::PrecomputedFaceData>::__shared_ptr_default_delete<arkit::PrecomputedFaceData,arkit::PrecomputedFaceData>,std::allocator<arkit::PrecomputedFaceData>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

arkit::PrecomputedFaceData *std::unique_ptr<arkit::PrecomputedFaceData>::reset[abi:ne180100](arkit::PrecomputedFaceData **a1, arkit::PrecomputedFaceData *a2)
{
  __n128 result = *a1;
  *a1 = a2;
  if (result)
  {
    arkit::PrecomputedFaceData::~PrecomputedFaceData(result);
    JUMPOUT(0x1BA9C56C0);
  }
  return result;
}

void *std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = result;
    __n128 result = std::vector<float>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      __n128 result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1B89FCF24(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(&STACK[0x400], 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<std::pair<float,cva::Matrix<float,1u,0u,false>>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = (void **)**a1;
  if (v2)
  {
    uint64_t v4 = (void **)v1[1];
    int64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        unint64_t v6 = v4 - 4;
        free(*(v4 - 3));
        uint64_t v4 = v6;
      }
      while (v6 != v2);
      int64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t *std::vector<std::pair<float,cva::Matrix<float,1u,0u,false>>>::__swap_out_circular_buffer(uint64_t *result, void *a2)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  uint64_t v4 = a2[1];
  if (v2 != *result)
  {
    uint64_t v5 = 0;
    do
    {
      uint64_t v6 = v4 + v5;
      uint64_t v7 = v2 + v5;
      *(_DWORD *)(v6 - 32) = *(_DWORD *)(v2 + v5 - 32);
      *(void *)(v6 - 24) = 0;
      *(void *)(v6 - 16) = 0;
      uint64_t v8 = *(void *)(v2 + v5 - 16);
      *(void *)(v6 - 24) = *(void *)(v2 + v5 - 24);
      *(void *)(v6 - 16) = v8;
      *(void *)(v7 - 24) = 0;
      *(void *)(v7 - 16) = 0;
      *(_DWORD *)(v6 - _Block_object_dispose(&STACK[0x400], 8) = *(_DWORD *)(v2 + v5 - 8);
      *(_DWORD *)(v7 - _Block_object_dispose(&STACK[0x400], 8) = 0;
      v5 -= 32;
    }
    while (v2 + v5 != v3);
    v4 += v5;
  }
  a2[1] = v4;
  uint64_t v9 = *result;
  *__n128 result = v4;
  a2[1] = v9;
  uint64_t v10 = result[1];
  result[1] = a2[2];
  a2[2] = v10;
  uint64_t v11 = result[2];
  result[2] = a2[3];
  a2[3] = v11;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<std::pair<float,cva::Matrix<float,1u,0u,false>>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 32;
    free(*(void **)(i - 24));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::optional<cva::Matrix<float,9u,1u,false>>::operator=[abi:ne180100]<cva::MatrixBinaryExpr<cva::MatrixScalarExpr<cva::Matrix<float,9u,1u,false>,cva::detail::MulOp>,cva::MatrixScalarExpr<cva::Matrix<float,9u,1u,false>,cva::detail::MulOp>,cva::detail::AddOp>,void>(uint64_t result, float **a2)
{
  if (*(unsigned char *)(result + 36))
  {
    uint64_t v2 = 0;
    uint64_t v3 = *a2;
    uint64_t v4 = a2[1];
    uint64_t v5 = *(void *)*a2;
    uint64_t v6 = *(void *)v4;
    do
    {
      *(float *)(result + v2) = (float)(*(float *)(v5 + v2) * v3[2]) + (float)(*(float *)(v6 + v2) * v4[2]);
      v2 += 4;
    }
    while (v2 != 36);
  }
  else
  {
    uint64_t v7 = 0;
    *(_DWORD *)(result + 32) = 0;
    *(_OWORD *)__n128 result = 0u;
    *(_OWORD *)(result + 16) = 0u;
    uint64_t v8 = *a2;
    uint64_t v9 = a2[1];
    uint64_t v10 = *(void *)*a2;
    uint64_t v11 = *(void *)v9;
    do
    {
      *(float *)(result + v7) = (float)(*(float *)(v10 + v7) * v8[2]) + (float)(*(float *)(v11 + v7) * v9[2]);
      v7 += 4;
    }
    while (v7 != 36);
    *(unsigned char *)(result + 36) = 1;
  }
  return result;
}

void std::__throw_bad_optional_access[abi:ne180100]()
{
  exception = __cxa_allocate_exception(8uLL);
  void *exception = MEMORY[0x1E4FBA4F8] + 16;
  __cxa_throw(exception, MEMORY[0x1E4FBA348], MEMORY[0x1E4FBA1F0]);
}

cva::Logger *cva::MatrixRef<float,0u,0u,false>::operator=<cva::MatrixRef<float,0u,0u,false>>(cva::Logger *a1, uint64_t a2)
{
  if (*(void *)(a2 + 8) - 4 * *(unsigned int *)(a2 + 20) != *((void *)a1 + 1) - 4 * *((unsigned int *)a1 + 5))
  {
    cva::detail::assignNoAlias<cva::MatrixRef<float,0u,0u,false>,cva::MatrixRef<float,0u,0u,false>>(a1, a2);
    return a1;
  }
  int v4 = *(_DWORD *)a1;
  int v5 = *((_DWORD *)a1 + 1);
  uint64_t v6 = (v5 * *(_DWORD *)a1);
  v25[0] = 0;
  v25[1] = 0;
  uint64_t v7 = (cva::Logger *)cva::MatrixData<float,0ul,0ul,false>::allocate((void **)v25, v6);
  int v26 = v4;
  int v27 = v5;
  if (v4 != *(_DWORD *)a2 || v5 != *(_DWORD *)(a2 + 4))
  {
    cva::Logger::instance(v7);
    cva::Logger::logInCategory();
    int v4 = v26;
    if (v26 != *(_DWORD *)a2) {
      goto LABEL_38;
    }
    int v5 = v27;
    if (v27 != *(_DWORD *)(a2 + 4)) {
      goto LABEL_38;
    }
    uint64_t v6 = (v26 * v27);
  }
  uint64_t v8 = v25[0];
  if (v6)
  {
    int v9 = 0;
    int v10 = *(_DWORD *)(a2 + 16) - v4;
    uint64_t v11 = *(_DWORD **)(a2 + 8);
    uint64_t v12 = 4 * v6;
    uint64_t v13 = v25[0];
    do
    {
      *(_DWORD *)uint64_t v13 = *v11;
      uint64_t v13 = (cva::Logger *)((char *)v13 + 4);
      if (v9 + 1 >= v4) {
        int v14 = v10;
      }
      else {
        int v14 = 0;
      }
      uint64_t v15 = &v11[v14];
      if (v9 + 1 < v4) {
        ++v9;
      }
      else {
        int v9 = 0;
      }
      uint64_t v11 = v15 + 1;
      v12 -= 4;
    }
    while (v12);
  }
  if (*(_DWORD *)a1 == v4 && *((_DWORD *)a1 + 1) == v5) {
    goto LABEL_22;
  }
  cva::Logger::instance(v8);
  cva::Logger::logInCategory();
  int v4 = *(_DWORD *)a1;
  if (*(_DWORD *)a1 != v26 || (int v5 = *((_DWORD *)a1 + 1), v5 != v27)) {
LABEL_38:
  }
    __assert_rtn("assert_equal_size", "matrixfun.h", 163, "(lhs.rows() == rhs.rows() && lhs.columns() == rhs.columns()) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
  uint64_t v8 = v25[0];
  LODWORD(v6) = v4 * v5;
LABEL_22:
  int v16 = *((_DWORD *)a1 + 4);
  if (v6) {
    uint64_t v17 = (_DWORD *)*((void *)a1 + 1);
  }
  else {
    uint64_t v17 = 0;
  }
  uint64_t v18 = *((void *)a1 + 1) + 4 * (v16 * v5);
  if (!v6) {
    uint64_t v18 = 0;
  }
  if (v17 != (_DWORD *)v18)
  {
    int v19 = 0;
    unsigned int v20 = v16 - v4;
    float v21 = v8;
    do
    {
      int v22 = *(_DWORD *)v21;
      float v21 = (cva::Logger *)((char *)v21 + 4);
      *uint64_t v17 = v22;
      if (v19 + 1 >= v4) {
        unsigned int v23 = v20;
      }
      else {
        unsigned int v23 = 0;
      }
      v17 += v23 + 1;
      if (v19 + 1 < v4) {
        ++v19;
      }
      else {
        int v19 = 0;
      }
    }
    while (v17 != (_DWORD *)v18);
  }
  free(v8);
  return a1;
}

void sub_1B89FD3BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
}

cva::Logger *cva::detail::assignNoAlias<cva::MatrixRef<float,0u,0u,false>,cva::MatrixRef<float,0u,0u,false>>(cva::Logger *result, uint64_t a2)
{
  uint64_t v3 = result;
  int v4 = *(_DWORD *)result;
  if (*(_DWORD *)result != *(_DWORD *)a2 || (int v5 = *((_DWORD *)result + 1), v5 != *(_DWORD *)(a2 + 4)))
  {
    cva::Logger::instance(result);
    __n128 result = (cva::Logger *)cva::Logger::logInCategory();
    int v4 = *(_DWORD *)v3;
    if (*(_DWORD *)v3 != *(_DWORD *)a2 || (int v5 = *((_DWORD *)v3 + 1), v5 != *(_DWORD *)(a2 + 4))) {
      cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>();
    }
  }
  int v6 = v5 * v4;
  int v7 = *((_DWORD *)v3 + 4);
  if (v5 * v4) {
    uint64_t v8 = (_DWORD *)*((void *)v3 + 1);
  }
  else {
    uint64_t v8 = 0;
  }
  uint64_t v9 = *((void *)v3 + 1) + 4 * (v7 * v5);
  if (!v6) {
    uint64_t v9 = 0;
  }
  if (v8 != (_DWORD *)v9)
  {
    int v10 = 0;
    int v11 = 0;
    unsigned int v12 = *(_DWORD *)(a2 + 16) - v4;
    unsigned int v13 = v7 - v4;
    if (v6) {
      int v14 = *(_DWORD **)(a2 + 8);
    }
    else {
      int v14 = 0;
    }
    do
    {
      *uint64_t v8 = *v14;
      if (v10 + 1 >= v4) {
        unsigned int v15 = v12;
      }
      else {
        unsigned int v15 = 0;
      }
      v14 += v15 + 1;
      if (v10 + 1 < v4) {
        ++v10;
      }
      else {
        int v10 = 0;
      }
      if (v11 + 1 >= v4) {
        unsigned int v16 = v13;
      }
      else {
        unsigned int v16 = 0;
      }
      v8 += v16 + 1;
      if (v11 + 1 < v4) {
        ++v11;
      }
      else {
        int v11 = 0;
      }
    }
    while (v8 != (_DWORD *)v9);
  }
  return result;
}

void cva::Matrix<float,0u,1u,false>::conservativeResize(uint64_t a1, unsigned int a2, int a3)
{
  if (a3 != 1) {
    cva::Matrix<float,0u,1u,false>::conservativeResize();
  }
  if (*(void *)(a1 + 8) >= (unint64_t)a2)
  {
    *(_DWORD *)(a1 + 16) = a2;
  }
  else
  {
    int v19 = 0;
    uint64_t v20 = 0;
    cva::MatrixData<float,0ul,0ul,false>::allocate(&v19, a2);
    unsigned int v21 = a2;
    unsigned int v5 = *(_DWORD *)(a1 + 16);
    if (v5 >= a2) {
      unsigned int v6 = a2;
    }
    else {
      unsigned int v6 = *(_DWORD *)(a1 + 16);
    }
    int v7 = *(void **)a1;
    int v14 = 0;
    unsigned int v15 = v6;
    unsigned int v16 = v7;
    unsigned int v17 = v5;
    int v18 = 0;
    unsigned int v11 = v6;
    unsigned int v12 = v19;
    unsigned int v13 = a2;
    cva::MatrixRef<float,0u,1u,false>::operator=<cva::MatrixRef<float,0u,1u,false>>(&v11, (uint64_t)&v15);
    uint64_t v8 = *(void **)a1;
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v10 = v20;
    *(void *)a1 = v19;
    *(void *)(a1 + _Block_object_dispose(&STACK[0x400], 8) = v10;
    int v19 = v8;
    uint64_t v20 = v9;
    *(_DWORD *)(a1 + 16) = v21;
    unsigned int v21 = 0;
    free(v8);
  }
}

void sub_1B89FD5B0(_Unwind_Exception *a1)
{
  free(*(void **)(v1 - 40));
  _Unwind_Resume(a1);
}

unsigned int *cva::MatrixRef<float,0u,1u,false>::operator=<cva::MatrixRef<float,0u,1u,false>>(unsigned int *a1, uint64_t a2)
{
  int v4 = (_DWORD *)*((void *)a1 + 1);
  if ((_DWORD *)(*(void *)(a2 + 8) - 4 * *(unsigned int *)(a2 + 20)) != &v4[-a1[5]])
  {
    unsigned int v5 = *a1;
    if (*a1 != *(_DWORD *)a2)
    {
      cva::Logger::instance((cva::Logger *)a1);
      cva::Logger::logInCategory();
      unsigned int v5 = *a1;
      if (*a1 != *(_DWORD *)a2) {
        cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>();
      }
      int v4 = (_DWORD *)*((void *)a1 + 1);
    }
    if (v5)
    {
      uint64_t v6 = v5;
      int v7 = *(int **)(a2 + 8);
      uint64_t v8 = 4 * v6;
      do
      {
        int v9 = *v7++;
        *v4++ = v9;
        v8 -= 4;
      }
      while (v8);
    }
    return a1;
  }
  uint64_t v10 = *a1;
  v22[0] = 0;
  v22[1] = 0;
  unsigned int v11 = (cva::Logger *)cva::MatrixData<float,0ul,0ul,false>::allocate((void **)v22, v10);
  unsigned int v23 = v10;
  if (v10 != *(_DWORD *)a2)
  {
    cva::Logger::instance(v11);
    cva::Logger::logInCategory();
    uint64_t v10 = v23;
    if (v23 != *(_DWORD *)a2) {
      goto LABEL_22;
    }
  }
  unsigned int v12 = v22[0];
  if (v10)
  {
    unsigned int v13 = *(int **)(a2 + 8);
    uint64_t v14 = 4 * v10;
    unsigned int v15 = v22[0];
    do
    {
      int v16 = *v13++;
      *(_DWORD *)unsigned int v15 = v16;
      unsigned int v15 = (cva::Logger *)((char *)v15 + 4);
      v14 -= 4;
    }
    while (v14);
  }
  if (*a1 == v10) {
    goto LABEL_17;
  }
  cva::Logger::instance(v12);
  cva::Logger::logInCategory();
  uint64_t v10 = *a1;
  if (v10 != v23) {
LABEL_22:
  }
    __assert_rtn("assert_equal_size", "matrixfun.h", 163, "(lhs.rows() == rhs.rows() && lhs.columns() == rhs.columns()) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
  unsigned int v12 = v22[0];
LABEL_17:
  if (v10)
  {
    unsigned int v17 = (_DWORD *)*((void *)a1 + 1);
    uint64_t v18 = 4 * v10;
    int v19 = v12;
    do
    {
      int v20 = *(_DWORD *)v19;
      int v19 = (cva::Logger *)((char *)v19 + 4);
      *v17++ = v20;
      v18 -= 4;
    }
    while (v18);
  }
  free(v12);
  return a1;
}

void sub_1B89FD7C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
}

ARSkeletonJointName ARSkeletonJointNameForRecognizedPointKey(VNRecognizedPointKey recognizedPointKey)
{
  uint64_t v1 = recognizedPointKey;
  uint64_t v2 = +[ARSkeletonDefinition defaultBody2DSkeletonDefinition];
  uint64_t v3 = [v2 jointNames];
  int v4 = [v3 containsObject:v1];

  if (v4) {
    unsigned int v5 = v1;
  }
  else {
    unsigned int v5 = 0;
  }

  return v5;
}

void sub_1B89FE6D0(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B89FE79C(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B89FE820(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B89FE918(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void *arkit::kFLEInequalityCoefficients(arkit *this)
{
  return &arkit::kFLEInequalityCoefficients(void)::kVals;
}

void *arkit::kFLEDarkCoefficients(arkit *this)
{
  return &arkit::kFLEDarkCoefficients(void)::kVals;
}

void sub_1B89FF1C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89FF2E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89FF438(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89FF560(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B89FF650(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)ARMLImageProcessingTechnique;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1B89FF934(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8A00218(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8A004CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::vector<espresso_buffer_t>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = 0xCF3CF3CF3CF3CF3DLL * ((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3);
  BOOL v3 = a2 >= v2;
  unint64_t v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<espresso_buffer_t>::__append((void **)a1, v4);
  }
  else if (!v3)
  {
    *(void *)(a1 + _Block_object_dispose(&STACK[0x400], 8) = *(void *)a1 + 168 * a2;
  }
}

void std::vector<__CVPixelBufferPool *>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + _Block_object_dispose(&STACK[0x400], 8) = *(void *)a1 + 8 * a2;
    }
  }
  else
  {
    std::vector<__CVPixelBufferPool *>::__append((void **)a1, a2 - v2);
  }
}

void sub_1B8A0069C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8A007CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8A00928(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8A00A90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8A00B40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8A01098(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8A013E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8A01530(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8A01794(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8A01C68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8A01E98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B8A01FB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B8A020D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8A0223C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8A0235C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8A02558(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8A02650(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8A02EA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *__p, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1B8A0306C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL13_ARLogGeneralv_block_invoke_27()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "General");
  uint64_t v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObuint64_t j = (uint64_t)v0;
}

void ___ZL15_ARLogTechniquev_block_invoke_15()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "Technique");
  uint64_t v1 = (void *)_ARLogTechnique(void)::logObj;
  _ARLogTechnique(void)::logObuint64_t j = (uint64_t)v0;
}

void std::vector<espresso_buffer_t>::__append(void **a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unsigned int v5 = v6;
  int v7 = *(char **)(v4 - 8);
  if (0xCF3CF3CF3CF3CF3DLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      size_t v13 = 168 * ((168 * a2 - 168) / 0xA8) + 168;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    unint64_t v8 = 0xCF3CF3CF3CF3CF3DLL * ((v7 - (unsigned char *)*a1) >> 3);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0x186186186186186) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0xCF3CF3CF3CF3CF3DLL * ((v5 - (unsigned char *)*a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0xC30C30C30C30C3) {
      unint64_t v11 = 0x186186186186186;
    }
    else {
      unint64_t v11 = v9;
    }
    if (v11) {
      unsigned int v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<espresso_buffer_t>>(v4, v11);
    }
    else {
      unsigned int v12 = 0;
    }
    uint64_t v14 = &v12[168 * v8];
    unsigned int v15 = &v12[168 * v11];
    size_t v16 = 168 * ((168 * a2 - 168) / 0xA8) + 168;
    bzero(v14, v16);
    unsigned int v17 = &v14[v16];
    int v19 = (char *)*a1;
    uint64_t v18 = (char *)a1[1];
    if (v18 != *a1)
    {
      do
      {
        long long v20 = *(_OWORD *)(v18 - 168);
        long long v21 = *(_OWORD *)(v18 - 152);
        *(_OWORD *)(v14 - 136) = *(_OWORD *)(v18 - 136);
        *(_OWORD *)(v14 - 152) = v21;
        *(_OWORD *)(v14 - 16_Block_object_dispose(&STACK[0x400], 8) = v20;
        long long v22 = *(_OWORD *)(v18 - 120);
        long long v23 = *(_OWORD *)(v18 - 104);
        long long v24 = *(_OWORD *)(v18 - 88);
        *(_OWORD *)(v14 - 72) = *(_OWORD *)(v18 - 72);
        *(_OWORD *)(v14 - 8_Block_object_dispose(&STACK[0x400], 8) = v24;
        *(_OWORD *)(v14 - 104) = v23;
        *(_OWORD *)(v14 - 120) = v22;
        long long v25 = *(_OWORD *)(v18 - 56);
        long long v26 = *(_OWORD *)(v18 - 40);
        long long v27 = *(_OWORD *)(v18 - 24);
        *((void *)v14 - 1) = *((void *)v18 - 1);
        *(_OWORD *)(v14 - 24) = v27;
        *(_OWORD *)(v14 - 40) = v26;
        *(_OWORD *)(v14 - 56) = v25;
        v14 -= 168;
        v18 -= 168;
      }
      while (v18 != v19);
      uint64_t v18 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v17;
    a1[2] = v15;
    if (v18)
    {
      operator delete(v18);
    }
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<espresso_buffer_t>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x186186186186187) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(168 * a2);
}

void std::vector<__CVPixelBufferPool *>::__append(void **a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unsigned int v5 = v6;
  int v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = v7 - (unsigned char *)*a1;
    unint64_t v9 = a2 + (v8 >> 3);
    if (v9 >> 61) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 3;
    uint64_t v11 = v5 - (unsigned char *)*a1;
    if (v11 >> 2 > v9) {
      unint64_t v9 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v9;
    }
    if (v12) {
      size_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>(v4, v12);
    }
    else {
      size_t v13 = 0;
    }
    uint64_t v14 = &v13[8 * v10];
    unsigned int v15 = &v13[8 * v12];
    bzero(v14, 8 * a2);
    size_t v16 = &v14[8 * a2];
    uint64_t v18 = (char *)*a1;
    unsigned int v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        uint64_t v19 = *((void *)v17 - 1);
        v17 -= 8;
        *((void *)v14 - 1) = v19;
        v14 -= 8;
      }
      while (v17 != v18);
      unsigned int v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
    {
      operator delete(v17);
    }
  }
}

double arkit::shct::rotateShCoeff@<D0>(uint64_t a1@<X0>, float *a2@<X1>, uint64_t a3@<X8>)
{
  float v6 = acosf(a2[8]);
  if (fabsf(v6) >= 0.001)
  {
    float v9 = a2[6];
    float v10 = a2[7];
    float v7 = atan2f(a2[5], -a2[2]);
    float v8 = atan2f(v10, v9);
  }
  else
  {
    float v7 = atan2f(a2[1], *a2);
    float v8 = 0.0;
  }
  float v11 = -*(float *)(a3 + 4);
  float v12 = -*(float *)(a3 + 20);
  float v14 = *(float *)(a3 + 24);
  int v13 = *(_DWORD *)(a3 + 28);
  float v15 = *(float *)(a3 + 32);
  float v16 = -*(float *)(a3 + 16);
  *(_DWORD *)(a3 + 4) = *(_DWORD *)(a3 + 8);
  *(float *)(a3 + _Block_object_dispose(&STACK[0x400], 8) = v11;
  *(_DWORD *)(a3 + 16) = v13;
  *(float *)(a3 + 20) = v12;
  *(float *)(a3 + 24) = (float)(v14 + (float)(v15 * 1.7321)) * -0.5;
  *(float *)(a3 + 2_Block_object_dispose(&STACK[0x400], 8) = v16;
  *(float *)(a3 + 32) = (float)(v15 + (float)(v14 * -1.7321)) * 0.5;
  long long v17 = v26;
  *(_OWORD *)a3 = v25;
  *(_OWORD *)(a3 + 16) = v17;
  *(_DWORD *)(a3 + 32) = v27;
  LODWORD(v17) = *(_DWORD *)(a3 + 4);
  float v18 = *(float *)(a3 + 24);
  float v19 = -*(float *)(a3 + 28);
  float v20 = *(float *)(a3 + 32);
  int v21 = *(_DWORD *)(a3 + 16);
  float v22 = -*(float *)(a3 + 20);
  *(float *)(a3 + 4) = -*(float *)(a3 + 8);
  *(_DWORD *)(a3 + _Block_object_dispose(&STACK[0x400], 8) = v17;
  *(float *)(a3 + 16) = v19;
  *(float *)(a3 + 20) = v22;
  *(float *)(a3 + 24) = (float)(v18 + (float)(v20 * 1.7321)) * -0.5;
  *(_DWORD *)(a3 + 2_Block_object_dispose(&STACK[0x400], 8) = v21;
  *(float *)(a3 + 32) = (float)(v20 + (float)(v18 * -1.7321)) * 0.5;
  double result = *(double *)&v25;
  long long v24 = v26;
  *(_OWORD *)a3 = v25;
  *(_OWORD *)(a3 + 16) = v24;
  *(_DWORD *)(a3 + 32) = v27;
  return result;
}

float arkit::anonymous namespace'::rotateSHCoeffsAroundZ@<S0>(uint64_t a1@<X0>, uint64_t a2@<X8>, float a3@<S0>)
{
  __float2 v6 = __sincosf_stret(a3);
  __float2 v7 = __sincosf_stret(a3 + a3);
  float v8 = *(float *)(a1 + 4);
  int v10 = *(_DWORD *)(a1 + 8);
  float v9 = *(float *)(a1 + 12);
  *(_DWORD *)a2 = *(_DWORD *)a1;
  *(float *)(a2 + 4) = (float)(v6.__sinval * v9) + (float)(v6.__cosval * v8);
  *(_DWORD *)(a2 + _Block_object_dispose(&STACK[0x400], 8) = v10;
  *(float *)(a2 + 12) = (float)(v6.__cosval * v9) - (float)(v6.__sinval * v8);
  float v12 = *(float *)(a1 + 28);
  float v11 = *(float *)(a1 + 32);
  float v13 = *(float *)(a1 + 16);
  float v14 = *(float *)(a1 + 20);
  int v15 = *(_DWORD *)(a1 + 24);
  *(float *)(a2 + 16) = (float)(v7.__sinval * v11) + (float)(v7.__cosval * v13);
  *(float *)(a2 + 20) = (float)(v6.__sinval * v12) + (float)(v6.__cosval * v14);
  *(_DWORD *)(a2 + 24) = v15;
  *(float *)(a2 + 2_Block_object_dispose(&STACK[0x400], 8) = (float)(v6.__cosval * v12) - (float)(v6.__sinval * v14);
  float result = (float)(v7.__cosval * v11) - (float)(v7.__sinval * v13);
  *(float *)(a2 + 32) = result;
  return result;
}

uint64_t arkit::shct::flipAxesShCoeff@<X0>(uint64_t result@<X0>, int a2@<W1>, int a3@<W2>, int a4@<W3>, uint64_t a5@<X8>)
{
  float v5 = *(float *)(result + 4);
  if (a3) {
    float v5 = -v5;
  }
  *(_DWORD *)a5 = *(_DWORD *)result;
  *(float *)(a5 + 4) = v5;
  float v7 = *(float *)(result + 8);
  float v6 = *(float *)(result + 12);
  if (a4) {
    float v7 = -v7;
  }
  *(_DWORD *)(a5 + 12) = 0;
  *(float *)(a5 + _Block_object_dispose(&STACK[0x400], 8) = v7;
  if (a2)
  {
    *(float *)(a5 + 12) = -v6;
    if ((a3 & 1) == 0)
    {
LABEL_7:
      float v8 = -*(float *)(result + 16);
      goto LABEL_10;
    }
  }
  else
  {
    *(float *)(a5 + 12) = v6;
    if (a3) {
      goto LABEL_7;
    }
  }
  float v8 = *(float *)(result + 16);
LABEL_10:
  float v9 = *(float *)(result + 20);
  int v10 = *(_DWORD *)(result + 24);
  if (a3 != a4) {
    float v9 = -v9;
  }
  *(float *)(a5 + 16) = v8;
  *(float *)(a5 + 20) = v9;
  float v11 = *(float *)(result + 28);
  int v12 = *(_DWORD *)(result + 32);
  if (a2 != a4) {
    float v11 = -v11;
  }
  *(_DWORD *)(a5 + 24) = v10;
  *(float *)(a5 + 2_Block_object_dispose(&STACK[0x400], 8) = v11;
  *(_DWORD *)(a5 + 32) = v12;
  return result;
}

id ARRemoteGeoTrackingTechniqueClientInterface()
{
  return ARRemoteTechniqueClientInterfaceWithProtocol((uint64_t)&unk_1F12859E0);
}

id ARRemoteGeoTrackingTechniqueServiceInterface()
{
  return ARRemoteTechniqueServiceInterfaceWithProtocol((uint64_t)&unk_1F1285A40);
}

void sub_1B8A054CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 128), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__7(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__7(uint64_t a1)
{
}

void sub_1B8A05690(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B8A057C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B8A058F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B8A05A28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B8A05B54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

float homographySquareTo@<S0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(_DWORD *)(a2 + 32) = 0;
  uint64_t v4 = a1 + 12;
  uint64_t v5 = a1 + 24;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  uint64_t v6 = a1 + 36;
  uint64_t v15 = a1;
  uint64_t v16 = a1 + 12;
  uint64_t v13 = a1 + 24;
  uint64_t v14 = a1 + 36;
  long long v17 = &v15;
  float v18 = &v13;
  uint64_t v11 = a2;
  uint64_t v12 = 3;
  if (a1 == a2 || v4 == a2 || v5 == a2 || v6 == a2)
  {
    int v20 = 0;
    uint64_t v19 = 0;
    cva::detail::assignNoAlias<cva::Matrix<float,3u,1u,false>,cva::MatrixCrossProdExpr<cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,1u,false>>,cva::MatrixCrossProdExpr<cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,1u,false>>>((uint64_t)&v19, (uint64_t)&v17);
    for (uint64_t i = 0; i != 12; i += 4)
      *(_DWORD *)(a2 + i) = *(_DWORD *)((char *)&v19 + i);
  }
  else
  {
    cva::detail::assignNoAlias<cva::MatrixRef<float,3u,1u,false>,cva::MatrixCrossProdExpr<cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,1u,false>>,cva::MatrixCrossProdExpr<cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,1u,false>>>(&v11, (uint64_t)&v17);
  }
  uint64_t v15 = a1;
  uint64_t v16 = v6;
  uint64_t v13 = v4;
  uint64_t v14 = v5;
  long long v17 = &v15;
  float v18 = &v13;
  uint64_t v11 = a2 + 12;
  uint64_t v12 = 0x300000003;
  if (a1 == a2 || v6 == a2 || v4 == a2 || v5 == a2)
  {
    int v20 = 0;
    uint64_t v19 = 0;
    cva::detail::assignNoAlias<cva::Matrix<float,3u,1u,false>,cva::MatrixCrossProdExpr<cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,1u,false>>,cva::MatrixCrossProdExpr<cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,1u,false>>>((uint64_t)&v19, (uint64_t)&v17);
    for (uint64_t j = 0; j != 12; j += 4)
      *(_DWORD *)(a2 + 12 + j) = *(_DWORD *)((char *)&v19 + j);
  }
  else
  {
    cva::detail::assignNoAlias<cva::MatrixRef<float,3u,1u,false>,cva::MatrixCrossProdExpr<cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,1u,false>>,cva::MatrixCrossProdExpr<cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,1u,false>>>(&v11, (uint64_t)&v17);
  }
  uint64_t v15 = a1;
  uint64_t v16 = v5;
  uint64_t v13 = v4;
  uint64_t v14 = v6;
  long long v17 = &v15;
  float v18 = &v13;
  uint64_t v11 = a2 + 24;
  uint64_t v12 = 0x600000003;
  if (a1 != a2 && v5 != a2 && v4 != a2 && v6 != a2) {
    return cva::detail::assignNoAlias<cva::MatrixRef<float,3u,1u,false>,cva::MatrixCrossProdExpr<cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,1u,false>>,cva::MatrixCrossProdExpr<cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,1u,false>>>(&v11, (uint64_t)&v17);
  }
  int v20 = 0;
  uint64_t v19 = 0;
  cva::detail::assignNoAlias<cva::Matrix<float,3u,1u,false>,cva::MatrixCrossProdExpr<cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,1u,false>>,cva::MatrixCrossProdExpr<cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,1u,false>>>((uint64_t)&v19, (uint64_t)&v17);
  for (uint64_t k = 0; k != 12; k += 4)
  {
    float result = *(float *)((char *)&v19 + k);
    *(float *)(a2 + 24 + k) = result;
  }
  return result;
}

BOOL hartleyNormalize(float *a1, _OWORD *a2, float32x2_t *a3, double a4, double a5, double a6)
{
  float v6 = a1[2];
  float32_t v8 = a1[1] / v6;
  v9.f32[0] = *a1 / v6;
  float32_t v7 = v9.f32[0];
  v9.f32[1] = v8;
  uint64_t v10 = (uint64_t)(a1 + 3);
  float v11 = a1[5];
  *(float *)&unsigned int v12 = a1[3] / v11;
  *(float *)&unsigned int v13 = a1[4] / v11;
  uint64_t v14 = (uint64_t)(a1 + 6);
  float v15 = a1[8];
  v16.f32[0] = a1[6] / v15;
  v16.f32[1] = a1[7] / v15;
  uint64_t v17 = (uint64_t)(a1 + 9);
  float v18 = a1[11];
  v19.f32[0] = a1[9] / v18;
  v19.f32[1] = a1[10] / v18;
  __asm { FMOV            V5.2S, #0.25 }
  float32x2_t v25 = vmul_f32(vadd_f32(vadd_f32(vadd_f32(v9, (float32x2_t)__PAIR64__(v13, v12)), v16), v19), _D5);
  *(float *)&a6 = (float)((float)((float)(sqrtf((float)((float)(v7 - v25.f32[0]) * (float)(v7 - v25.f32[0]))+ (float)((float)(v8 - v25.f32[1]) * (float)(v8 - v25.f32[1])))+ sqrtf((float)((float)(*(float *)&v12 - v25.f32[0])* (float)(*(float *)&v12 - v25.f32[0]))+ (float)((float)(*(float *)&v13 - v25.f32[1])* (float)(*(float *)&v13 - v25.f32[1]))))+ sqrtf((float)((float)(v16.f32[0] - v25.f32[0]) * (float)(v16.f32[0] - v25.f32[0]))+ (float)((float)(v16.f32[1] - v25.f32[1]) * (float)(v16.f32[1] - v25.f32[1]))))+ sqrtf((float)((float)(v19.f32[0] - v25.f32[0]) * (float)(v19.f32[0] - v25.f32[0]))+ (float)((float)(v19.f32[1] - v25.f32[1]) * (float)(v19.f32[1] - v25.f32[1]))))/ 1.4142;
  if (*(float *)&a6 >= 0.00000011921)
  {
    a3->f32[0] = 1.0 / *(float *)&a6;
    a3[1] = 0;
    a3->i32[1] = 0;
    a3[2].f32[0] = 1.0 / *(float *)&a6;
    a3[2].i32[1] = 0;
    a3[3] = vdiv_f32(vneg_f32(v25), (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a6, 0));
    a3[4].i32[0] = 1065353216;
    v34[0] = (uint64_t)a3;
    v34[1] = (uint64_t)a1;
    *(void *)uint64_t v35 = 0;
    *(_DWORD *)&v35[8] = 0;
    int v30 = LODWORD(a6);
    cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,3u,false>,cva::Matrix<float,3u,1u,false>>((uint64_t)v35, v34);
    v33[0] = (uint64_t)a3;
    v33[1] = v10;
    *(void *)&v35[12] = 0;
    *(_DWORD *)&v35[20] = 0;
    cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,3u,false>,cva::Matrix<float,3u,1u,false>>((uint64_t)&v35[12], v33);
    v32[0] = (uint64_t)a3;
    v32[1] = v14;
    *(void *)&v35[24] = 0;
    LODWORD(v36) = 0;
    cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,3u,false>,cva::Matrix<float,3u,1u,false>>((uint64_t)&v35[24], v32);
    v31[0] = (uint64_t)a3;
    v31[1] = v17;
    *(void *)((char *)&v36 + 4) = 0;
    HIDWORD(v36) = 0;
    cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,3u,false>,cva::Matrix<float,3u,1u,false>>((uint64_t)&v36 + 4, v31);
    LODWORD(a6) = v30;
    long long v28 = *(_OWORD *)&v35[16];
    *a2 = *(_OWORD *)v35;
    a2[1] = v28;
    a2[2] = v36;
  }
  return *(float *)&a6 >= 0.00000011921;
}

BOOL computeHomography(float *a1, float *a2, uint64_t a3, double a4, double a5, double a6)
{
  int v34 = 0;
  memset(v33, 0, sizeof(v33));
  __int32 v32 = 0;
  memset(v31, 0, sizeof(v31));
  memset(v30, 0, sizeof(v30));
  memset(v29, 0, sizeof(v29));
  BOOL v8 = hartleyNormalize(a1, v30, (float32x2_t *)v33, 0.0, a5, a6);
  BOOL result = 0;
  if (v8)
  {
    BOOL result = hartleyNormalize(a2, v29, (float32x2_t *)v31, v9, v10, v11);
    if (result)
    {
      homographySquareTo((uint64_t)v30, (uint64_t)&v28);
      homographySquareTo((uint64_t)v29, (uint64_t)v21);
      if (fabsf((float)(v28.columns[0].f32[2]* (float)((float)(*(float *)&v28.columns[1].i32[3] * *(float *)&v28.columns[0].i32[3])- (float)(v28.columns[1].f32[0] * v28.columns[1].f32[2])))+ (float)((float)(v28.columns[0].f32[0]* (float)((float)(v28.columns[2].f32[0] * v28.columns[1].f32[0])- (float)(v28.columns[1].f32[1] * *(float *)&v28.columns[1].i32[3])))- (float)(v28.columns[0].f32[1]* (float)((float)(v28.columns[2].f32[0] * *(float *)&v28.columns[0].i32[3])- (float)(v28.columns[1].f32[1] * v28.columns[1].f32[2]))))) >= 1.1755e-38&& fabsf((float)(v21[2] * (float)((float)(v26 * v22) - (float)(v23 * v25)))+ (float)((float)(v21[0] * (float)((float)(v27 * v23) - (float)(v24 * v26)))- (float)(v21[1] * (float)((float)(v27 * v22) - (float)(v24 * v25))))) >= 1.1755e-38)
      {
        v13.columns[2].i64[0] = *((void *)&v31[1] + 1);
        v13.columns[2].i32[2] = v32;
        v13.columns[0] = (simd_float3)v31[0];
        v13.columns[1] = *(simd_float3 *)((char *)v31 + 12);
        simd_float3x3 v35 = __invert_f3(v13);
        v35.columns[0].i32[3] = v35.columns[1].i32[0];
        v16[0] = v35.columns[0];
        v16[1] = vextq_s8(vextq_s8((int8x16_t)v35.columns[1], (int8x16_t)v35.columns[1], 0xCuLL), (int8x16_t)v35.columns[2], 8uLL);
        __int32 v17 = v35.columns[2].i32[2];
        v18[0] = v16;
        v18[1] = v21;
        v35.columns[2].i64[0] = v28.columns[1].i64[1];
        v35.columns[2].i32[2] = v28.columns[2].i32[0];
        v35.columns[0] = v28.columns[0];
        v35.columns[1] = *(simd_float3 *)((char *)v28.columns + 12);
        simd_float3x3 v36 = __invert_f3(v35);
        v36.columns[0].i32[3] = v36.columns[1].i32[0];
        v14[0] = v36.columns[0];
        v14[1] = vextq_s8(vextq_s8((int8x16_t)v36.columns[1], (int8x16_t)v36.columns[1], 0xCuLL), (int8x16_t)v36.columns[2], 8uLL);
        __int32 v15 = v36.columns[2].i32[2];
        v19[0] = v18;
        v19[1] = v14;
        v20[0] = (uint64_t)v19;
        v20[1] = (uint64_t)v33;
        cva::assign<false,false,cva::Matrix<float,3u,3u,false>,cva::MatrixMultExpr<cva::MatrixMultExpr<cva::Matrix<float,3u,3u,false>,cva::Matrix<float,3u,3u,false>>,cva::Matrix<float,3u,3u,false>>,cva::Matrix<float,3u,3u,false>>(a3, v20);
        return 1;
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

float cva::detail::assignNoAlias<cva::Matrix<float,3u,1u,false>,cva::MatrixCrossProdExpr<cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,1u,false>>,cva::MatrixCrossProdExpr<cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,1u,false>>>(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 0;
  BOOL v3 = *(void ***)a2;
  uint64_t v18 = 0;
  int v19 = 0;
  uint64_t v4 = v3[1];
  int v5 = *((_DWORD *)*v3 + 2);
  *(void *)&long long v6 = **v3;
  int v25 = DWORD1(v6);
  uint64_t v7 = *(void *)((char *)v4 + 4);
  int v26 = v5;
  unint64_t v27 = __PAIR64__(HIDWORD(v7), v6);
  LODWORD(v2_Block_object_dispose(&STACK[0x400], 8) = *(_DWORD *)v4;
  HIDWORD(v2_Block_object_dispose(&STACK[0x400], 8) = v7;
  int v21 = v5;
  *((void *)&v6 + 1) = v7;
  long long v22 = v6;
  int v23 = v28;
  do
  {
    *(float *)((char *)&v18 + v2) = (float)(*(float *)&v24[v2 + 4] * *(float *)((char *)&v27 + v2 + 4))
                                  - (float)(*(float *)&v20[v2 + 4] * *(float *)((char *)&v22 + v2 + 8));
    v2 += 4;
  }
  while (v2 != 12);
  uint64_t v8 = 0;
  double v9 = *(void ***)(a2 + 8);
  memset(v17, 0, 12);
  double v10 = v9[1];
  int v11 = *((_DWORD *)*v9 + 2);
  *(void *)&long long v12 = **v9;
  int v25 = DWORD1(v12);
  uint64_t v13 = *(void *)((char *)v10 + 4);
  int v26 = v11;
  unint64_t v27 = __PAIR64__(HIDWORD(v13), v12);
  LODWORD(v2_Block_object_dispose(&STACK[0x400], 8) = *(_DWORD *)v10;
  HIDWORD(v2_Block_object_dispose(&STACK[0x400], 8) = v13;
  int v21 = v11;
  *((void *)&v12 + 1) = v13;
  long long v22 = v12;
  int v23 = v28;
  do
  {
    *(float *)((char *)v17 + v_Block_object_dispose(&STACK[0x400], 8) = (float)(*(float *)&v24[v8 + 4] * *(float *)((char *)&v27 + v8 + 4))
                                 - (float)(*(float *)&v20[v8 + 4] * *(float *)((char *)&v22 + v8 + 8));
    v8 += 4;
  }
  while (v8 != 12);
  uint64_t v14 = 0;
  *(void *)&long long v15 = v18;
  int v25 = HIDWORD(v18);
  int v26 = v19;
  unint64_t v27 = __PAIR64__(v17[1], v18);
  uint64_t v28 = v17[0];
  int v21 = v19;
  *((void *)&v15 + 1) = *(void *)((char *)v17 + 4);
  long long v22 = v15;
  int v23 = v17[0];
  do
  {
    float result = (float)(*(float *)&v24[v14 + 4] * *(float *)((char *)&v27 + v14 + 4))
           - (float)(*(float *)&v20[v14 + 4] * *(float *)((char *)&v22 + v14 + 8));
    *(float *)(a1 + v14) = result;
    v14 += 4;
  }
  while (v14 != 12);
  return result;
}

float cva::detail::assignNoAlias<cva::MatrixRef<float,3u,1u,false>,cva::MatrixCrossProdExpr<cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,1u,false>>,cva::MatrixCrossProdExpr<cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,1u,false>>>(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = 0;
  BOOL v3 = *(void ***)a2;
  uint64_t v19 = 0;
  int v20 = 0;
  uint64_t v4 = v3[1];
  int v5 = *((_DWORD *)*v3 + 2);
  *(void *)&long long v6 = **v3;
  int v26 = DWORD1(v6);
  uint64_t v7 = *(void *)((char *)v4 + 4);
  int v27 = v5;
  unint64_t v28 = __PAIR64__(HIDWORD(v7), v6);
  LODWORD(v29) = *(_DWORD *)v4;
  HIDWORD(v29) = v7;
  int v22 = v5;
  *((void *)&v6 + 1) = v7;
  long long v23 = v6;
  int v24 = v29;
  do
  {
    *(float *)((char *)&v19 + v2) = (float)(*(float *)&v25[v2 + 4] * *(float *)((char *)&v28 + v2 + 4))
                                  - (float)(*(float *)&v21[v2 + 4] * *(float *)((char *)&v23 + v2 + 8));
    v2 += 4;
  }
  while (v2 != 12);
  uint64_t v8 = 0;
  double v9 = *(void ***)(a2 + 8);
  memset(v18, 0, 12);
  double v10 = v9[1];
  int v11 = *((_DWORD *)*v9 + 2);
  *(void *)&long long v12 = **v9;
  int v26 = DWORD1(v12);
  uint64_t v13 = *(void *)((char *)v10 + 4);
  int v27 = v11;
  unint64_t v28 = __PAIR64__(HIDWORD(v13), v12);
  LODWORD(v29) = *(_DWORD *)v10;
  HIDWORD(v29) = v13;
  int v22 = v11;
  *((void *)&v12 + 1) = v13;
  long long v23 = v12;
  int v24 = v29;
  do
  {
    *(float *)((char *)v18 + v_Block_object_dispose(&STACK[0x400], 8) = (float)(*(float *)&v25[v8 + 4] * *(float *)((char *)&v28 + v8 + 4))
                                 - (float)(*(float *)&v21[v8 + 4] * *(float *)((char *)&v23 + v8 + 8));
    v8 += 4;
  }
  while (v8 != 12);
  uint64_t v14 = 0;
  *(void *)&long long v15 = v19;
  int v26 = HIDWORD(v19);
  int v27 = v20;
  unint64_t v28 = __PAIR64__(v18[1], v19);
  uint64_t v29 = v18[0];
  int v22 = v20;
  *((void *)&v15 + 1) = *(void *)((char *)v18 + 4);
  long long v23 = v15;
  int v24 = v18[0];
  uint64_t v16 = *a1;
  do
  {
    float result = (float)(*(float *)&v25[v14 + 4] * *(float *)((char *)&v28 + v14 + 4))
           - (float)(*(float *)&v21[v14 + 4] * *(float *)((char *)&v23 + v14 + 8));
    *(float *)(v16 + v14) = result;
    v14 += 4;
  }
  while (v14 != 12);
  return result;
}

double cva::assign<false,false,cva::Matrix<float,3u,3u,false>,cva::MatrixMultExpr<cva::MatrixMultExpr<cva::Matrix<float,3u,3u,false>,cva::Matrix<float,3u,3u,false>>,cva::Matrix<float,3u,3u,false>>,cva::Matrix<float,3u,3u,false>>(uint64_t a1, uint64_t *a2)
{
  if (a2[1] == a1)
  {
    int v16 = 0;
    long long v14 = 0u;
    long long v15 = 0u;
    cva::assign<false,false,cva::Matrix<float,3u,3u,false>,cva::MatrixMultExpr<cva::MatrixMultExpr<cva::Matrix<float,3u,3u,false>,cva::Matrix<float,3u,3u,false>>,cva::Matrix<float,3u,3u,false>>,cva::Matrix<float,3u,3u,false>>(&v14, a2);
    double result = *(double *)&v14;
    long long v13 = v15;
    *(_OWORD *)a1 = v14;
    *(_OWORD *)(a1 + 16) = v13;
    *(_DWORD *)(a1 + 32) = v16;
  }
  else
  {
    uint64_t v4 = *a2;
    long long v14 = 0u;
    long long v15 = 0u;
    int v16 = 0;
    cva::assign<false,false,cva::Matrix<float,3u,3u,false>,cva::MatrixMultExpr<cva::Matrix<float,3u,3u,false>,cva::Matrix<float,3u,3u,false>>,cva::Matrix<float,3u,3u,false>>((uint64_t)&v14, v4);
    uint64_t v5 = 0;
    uint64_t v6 = a2[1];
    do
    {
      uint64_t v7 = 0;
      uint64_t v8 = &v14;
      do
      {
        uint64_t v9 = 0;
        double result = 0.0;
        int v11 = (float *)(v6 + 12 * v5);
        do
        {
          float v12 = *v11++;
          *(float *)&double result = *(float *)&result + (float)(*(float *)((char *)v8 + v9) * v12);
          v9 += 12;
        }
        while (v9 != 36);
        *(_DWORD *)(a1 + 12 * v5 + 4 * v7++) = LODWORD(result);
        uint64_t v8 = (long long *)((char *)v8 + 4);
      }
      while (v7 != 3);
      ++v5;
    }
    while (v5 != 3);
  }
  return result;
}

double cva::assign<false,false,cva::Matrix<float,3u,3u,false>,cva::MatrixMultExpr<cva::Matrix<float,3u,3u,false>,cva::Matrix<float,3u,3u,false>>,cva::Matrix<float,3u,3u,false>>(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + 8) == a1)
  {
    int v16 = 0;
    long long v14 = 0u;
    long long v15 = 0u;
    cva::assign<false,false,cva::Matrix<float,3u,3u,false>,cva::MatrixMultExpr<cva::Matrix<float,3u,3u,false>,cva::Matrix<float,3u,3u,false>>,cva::Matrix<float,3u,3u,false>>(&v14, a2);
    double result = *(double *)&v14;
    long long v13 = v15;
    *(_OWORD *)a1 = v14;
    *(_OWORD *)(a1 + 16) = v13;
    *(_DWORD *)(a1 + 32) = v16;
  }
  else
  {
    uint64_t v4 = *(uint64_t **)a2;
    long long v14 = 0u;
    long long v15 = 0u;
    int v16 = 0;
    cva::assign<false,false,cva::Matrix<float,3u,3u,false>,cva::Matrix<float,3u,3u,false>,cva::Matrix<float,3u,3u,false>>((uint64_t)&v14, v4);
    uint64_t v5 = 0;
    uint64_t v6 = *(void *)(a2 + 8);
    do
    {
      uint64_t v7 = 0;
      uint64_t v8 = &v14;
      do
      {
        uint64_t v9 = 0;
        double result = 0.0;
        int v11 = (float *)(v6 + 12 * v5);
        do
        {
          float v12 = *v11++;
          *(float *)&double result = *(float *)&result + (float)(*(float *)((char *)v8 + v9) * v12);
          v9 += 12;
        }
        while (v9 != 36);
        *(_DWORD *)(a1 + 12 * v5 + 4 * v7++) = LODWORD(result);
        uint64_t v8 = (long long *)((char *)v8 + 4);
      }
      while (v7 != 3);
      ++v5;
    }
    while (v5 != 3);
  }
  return result;
}

double cva::assign<false,false,cva::Matrix<float,3u,3u,false>,cva::Matrix<float,3u,3u,false>,cva::Matrix<float,3u,3u,false>>(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  if (*a2 == a1 || (uint64_t v4 = a2[1], v4 == a1))
  {
    int v15 = 0;
    long long v13 = 0u;
    long long v14 = 0u;
    cva::assign<false,false,cva::Matrix<float,3u,3u,false>,cva::Matrix<float,3u,3u,false>,cva::Matrix<float,3u,3u,false>>(&v13);
    double result = *(double *)&v13;
    long long v12 = v14;
    *(_OWORD *)a1 = v13;
    *(_OWORD *)(a1 + 16) = v12;
    *(_DWORD *)(a1 + 32) = v15;
  }
  else
  {
    for (uint64_t i = 0; i != 3; ++i)
    {
      uint64_t v6 = 0;
      uint64_t v7 = v3;
      do
      {
        uint64_t v8 = 0;
        double result = 0.0;
        double v10 = (float *)(v4 + 12 * i);
        do
        {
          float v11 = *v10++;
          *(float *)&double result = *(float *)&result + (float)(*(float *)(v7 + v8) * v11);
          v8 += 12;
        }
        while (v8 != 36);
        *(_DWORD *)(a1 + 12 * i + 4 * v6++) = LODWORD(result);
        v7 += 4;
      }
      while (v6 != 3);
    }
  }
  return result;
}

float ARMapExposureOffset(float a1)
{
  float v1 = exp2(a1);
  return pow(v1, 1.20000005);
}

float ARMapLightIntensity(float a1)
{
  long double v1 = pow(a1, 0.8333333);
  return log2(v1);
}

id ARCreateInstanceOfType(objc_class *a1)
{
  id Instance = class_createInstance(a1, 0);
  return Instance;
}

id ARGetPropertiesForType(objc_class *a1)
{
  outCFIndex Count = 0;
  long double v1 = class_copyPropertyList(a1, &outCount);
  id v2 = objc_alloc(MEMORY[0x1E4F1CA48]);
  uint64_t v3 = (void *)[v2 initWithCapacity:outCount];
  if (outCount)
  {
    for (unint64_t i = 0; i < outCount; ++i)
    {
      uint64_t v5 = [NSString stringWithUTF8String:property_getName(v1[i])];
      [v3 addObject:v5];
    }
  }
  free(v1);
  return v3;
}

id ARGetTypeOfProperty(objc_class *a1, id a2)
{
  Property = class_getProperty(a1, (const char *)[a2 UTF8String]);
  if (Property)
  {
    uint64_t v3 = property_copyAttributeValue(Property, "T");
    uint64_t v4 = [NSString stringWithUTF8String:v3];
    free(v3);
    if ([v4 hasPrefix:@"@"])
    {
      uint64_t v5 = [MEMORY[0x1E4F28FD8] regularExpressionWithPattern:@"@\"(.*)\"" options:0 error:0];
      uint64_t v6 = objc_msgSend(v5, "matchesInString:options:range:", v4, 0, 0, objc_msgSend(v4, "length"));
      uint64_t v7 = [v6 firstObject];
      if ([v7 numberOfRanges])
      {
        uint64_t v8 = [v7 rangeAtIndex:1];
        objc_msgSend(v4, "substringWithRange:", v8, v9);
        double v10 = (NSString *)objc_claimAutoreleasedReturnValue();
        float v11 = NSClassFromString(v10);
      }
      else
      {
        float v11 = 0;
      }
    }
    else
    {
      float v11 = 0;
    }
  }
  else
  {
    float v11 = 0;
  }
  return v11;
}

id ARGetValueOfProperty(void *a1, void *a2)
{
  id v3 = a1;
  uint64_t v4 = a2;
  SEL v5 = NSSelectorFromString(v4);
  if ((objc_opt_respondsToSelector() & 1) != 0 && (uint64_t v6 = (objc_class *)objc_opt_class(), ARGetTypeOfProperty(v6, v4)))
  {
    uint64_t v7 = ((void (*)(id, SEL))[v3 methodForSelector:v5])(v3, v5);
  }
  else
  {
    uint64_t v7 = 0;
  }

  return v7;
}

void ARSetValueOfIvar(void *a1, void *a2, void *a3)
{
  id v5 = a3;
  id v6 = a2;
  obuint64_t j = a1;
  uint64_t v7 = (objc_class *)objc_opt_class();
  id v8 = v6;
  uint64_t v9 = (const char *)[v8 UTF8String];

  InstanceVariable = class_getInstanceVariable(v7, v9);
  object_setIvar(obj, InstanceVariable, v5);
}

BOOL ARTypeIsSubclassOfType(objc_class *a1, objc_class *a2)
{
  Superclass = class_getSuperclass(a1);
  for (BOOL i = Superclass != 0; Superclass != a2 && Superclass; BOOL i = Superclass != 0)
    Superclass = class_getSuperclass(Superclass);
  return i;
}

void *arkit::PrecomputedFaceData::PrecomputedFaceData(void *a1, long long *a2)
{
  std::__optional_copy_base<std::string const,false>::__optional_copy_base[abi:ne180100](&__p, a2);
  arkit::RTFSPContainer::loadRtfsp(a1, (uint64_t)&__p);
  if (v5 && SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return a1;
}

void sub_1B8A06C00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a15)
  {
    if (a14 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(exception_object);
}

void arkit::PrecomputedFaceData::~PrecomputedFaceData(arkit::PrecomputedFaceData *this)
{
  uint64_t v1 = *(void *)this;
  *(void *)this = 0;
  if (v1) {
    std::default_delete<arkit::RTFSPContainer const>::operator()[abi:ne180100]((uint64_t)this, v1);
  }
}

{
  uint64_t v1;

  uint64_t v1 = *(void *)this;
  *(void *)this = 0;
  if (v1) {
    std::default_delete<arkit::RTFSPContainer const>::operator()[abi:ne180100]((uint64_t)this, v1);
  }
}

uint64_t arkit::PrecomputedFaceData::nSamples(arkit::PrecomputedFaceData *this)
{
  return (uint64_t)(*(void *)(*(void *)this + 56) - *(void *)(*(void *)this + 48)) >> 2;
}

uint64_t arkit::PrecomputedFaceData::getRTF@<X0>(arkit::PrecomputedFaceData *this@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v4 = *(void *)(*(void *)this + 72) + 24 * a2;
  uint64_t v5 = *(unsigned int *)(v4 + 16);
  *(void *)a3 = 0;
  *(void *)(a3 + _Block_object_dispose(&STACK[0x400], 8) = 0;
  uint64_t result = cva::MatrixData<float,0ul,0ul,false>::allocate((void **)a3, v5);
  if (v5) {
    uint64_t result = (uint64_t)memcpy(*(void **)a3, *(const void **)v4, 4 * v5);
  }
  *(_DWORD *)(a3 + 16) = *(_DWORD *)(v4 + 16);
  return result;
}

void arkit::PrecomputedFaceData::getRTF(arkit::PrecomputedFaceData *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)a3 = 0;
  *(void *)(a3 + _Block_object_dispose(&STACK[0x400], 8) = 0;
  unint64_t v6 = (unint64_t)(a2[1] - *a2) >> 2;
  int v7 = *(_DWORD *)(*(void *)a1 + 96);
  *(_DWORD *)(a3 + 16) = v6;
  *(_DWORD *)(a3 + 20) = v7;
  cva::MatrixData<float,0ul,0ul,false>::reserve(a3, (v7 * v6));
  uint64_t v8 = *a2;
  if (a2[1] != *a2)
  {
    unint64_t v9 = 0;
    int v21 = "matrixmixin.h";
    int v22 = "(row < mixed().rows()) || cva::detail::assertMessage(\"Index out of bounds.\")";
    int v20 = "row";
    while (1)
    {
      RTF = (cva::Logger *)arkit::PrecomputedFaceData::getRTF(a1, *(_DWORD *)(v8 + 4 * v9), (uint64_t)&v23);
      unint64_t v11 = *(unsigned int *)(a3 + 16);
      if (v9 >= v11) {
        break;
      }
      int v12 = *(_DWORD *)(a3 + 20);
      uint64_t v13 = *(void *)a3;
      if (v12 != v24)
      {
        cva::Logger::instance(RTF);
        cva::Logger::logInCategory();
        if (v12 != v24)
        {
          int v19 = 163;
          int v20 = "assert_equal_size";
          int v21 = "matrixfun.h";
          int v22 = "(lhs.rows() == rhs.rows() && lhs.columns() == rhs.columns()) || cva::detail::assertMessage(\"Matrix size"
                "s are not compatible!\")";
LABEL_18:
          __assert_rtn(v20, v21, v19, v22);
        }
      }
      if (v12) {
        long long v14 = (_DWORD *)(v13 + 4 * v9);
      }
      else {
        long long v14 = 0;
      }
      uint64_t v15 = v13 + 4 * v9 + 4 * (v12 * v11);
      if (!v12) {
        uint64_t v15 = 0;
      }
      int v16 = v23;
      if (v14 != (_DWORD *)v15)
      {
        __int32 v17 = (int *)v23;
        do
        {
          int v18 = *v17++;
          _DWORD *v14 = v18;
          v14 += (int)v11;
        }
        while (v14 != (_DWORD *)v15);
      }
      ++v9;
      free(v16);
      uint64_t v8 = *a2;
      if (v9 >= (a2[1] - *a2) >> 2) {
        return;
      }
    }
    int v19 = 1063;
    goto LABEL_18;
  }
}

void sub_1B8A06EC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  free(*v16);
  _Unwind_Resume(a1);
}

uint64_t arkit::PrecomputedFaceData::nCoefficients(arkit::PrecomputedFaceData *this)
{
  return *(int *)(*(void *)this + 96);
}

uint64_t arkit::PrecomputedFaceData::getValidSampleIDs(arkit::PrecomputedFaceData *this, int a2)
{
  uint64_t v2 = *(void *)this;
  uint64_t v3 = *(void *)(v2 + 48);
  if (a2 >= (unint64_t)((*(void *)(v2 + 56) - v3) >> 2)) {
    std::vector<int>::__throw_out_of_range[abi:ne180100]();
  }
  return *(int *)(v3 + 4 * a2);
}

void *arkit::PrecomputedFaceData::getValidSampleIDs@<X0>(arkit::PrecomputedFaceData *this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)this;
  a2[1] = 0;
  a2[2] = 0;
  *a2 = 0;
  return std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(a2, *(const void **)(v2 + 48), *(void *)(v2 + 56), (uint64_t)(*(void *)(v2 + 56) - *(void *)(v2 + 48)) >> 2);
}

std::string *std::__optional_copy_base<std::string const,false>::__optional_copy_base[abi:ne180100](std::string *a1, long long *a2)
{
  a1->__r_.__value_.__s.__data_[0] = 0;
  a1[1].__r_.__value_.__s.__data_[0] = 0;
  std::__optional_storage_base<std::string const,false>::__construct_from[abi:ne180100]<std::__optional_copy_base<std::string const,false> const&>(a1, a2);
  return a1;
}

void sub_1B8A06F80(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 24)) {
    std::__optional_copy_base<std::string const,false>::__optional_copy_base[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__optional_storage_base<std::string const,false>::__construct_from[abi:ne180100]<std::__optional_copy_base<std::string const,false> const&>(std::string *this, long long *a2)
{
  if (*((unsigned char *)a2 + 24))
  {
    if (*((char *)a2 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((void *)a2 + 1));
    }
    else
    {
      long long v3 = *a2;
      this->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
      *(_OWORD *)&this->__r_.__value_.__l.__data_ = v3;
    }
    this[1].__r_.__value_.__s.__data_[0] = 1;
  }
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  uint64_t v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    std::string::size_type v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17) {
      std::string::size_type v6 = __sz | 7;
    }
    std::string::size_type v7 = v6 + 1;
    uint64_t v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    uint64_t v5 = v8;
  }
  else
  {
    *((unsigned char *)&this->__r_.__value_.__s + 23) = __sz;
  }
  memmove(v5, __s, __sz + 1);
}

void std::default_delete<arkit::RTFSPContainer const>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v4 = (void **)(a2 + 72);
    std::vector<cva::Matrix<float,1u,0u,false>>::__destroy_vector::operator()[abi:ne180100](&v4);
    long long v3 = *(void **)(a2 + 48);
    if (v3)
    {
      *(void *)(a2 + 56) = v3;
      operator delete(v3);
    }
    if (*(char *)(a2 + 47) < 0) {
      operator delete(*(void **)(a2 + 24));
    }
    if (*(char *)(a2 + 23) < 0) {
      operator delete(*(void **)a2);
    }
    MEMORY[0x1BA9C56C0](a2, 0x1032C40D1F799DBLL);
  }
}

void std::vector<int>::__throw_out_of_range[abi:ne180100]()
{
}

void thirdparty::quadprogpp::solve_quadprog(_DWORD *a1, uint64_t a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, uint64_t a7)
{
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v34);
  int v11 = a1[1];
  if (v11 && *a1)
  {
    if (*a1 == v11)
    {
      if (*a3 == v11)
      {
        if (*a4 == a3[1])
        {
          if (*a5 == v11)
          {
            if (*a6 == a5[1])
            {
              if (*(_DWORD *)a7 != v11)
              {
                uint64_t v12 = *(void *)(a7 + 8);
                if (v12) {
                  MEMORY[0x1BA9C56A0](v12, 0x1000C8000313F17);
                }
                operator new[]();
              }
              thirdparty::quadprogpp::Matrix<double>::Matrix();
            }
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v34, (uint64_t)"The vector ci0 is incompatible (incorrect dimension ", 52);
            unint64_t v28 = (void *)std::ostream::operator<<();
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v28, (uint64_t)", expecting ", 12);
            uint64_t v29 = (void *)std::ostream::operator<<();
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v29, (uint64_t)")", 1);
            exception = __cxa_allocate_exception(0x10uLL);
            std::stringbuf::str();
            MEMORY[0x1BA9C5420](exception, v33);
            __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
          }
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v34, (uint64_t)"The matrix CI is incompatible (incorrect number of rows ", 56);
          int v25 = (void *)std::ostream::operator<<();
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v25, (uint64_t)" , expecting ", 13);
          int v26 = (void *)std::ostream::operator<<();
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)")", 1);
          int v27 = __cxa_allocate_exception(0x10uLL);
          std::stringbuf::str();
          MEMORY[0x1BA9C5420](v27, v33);
          __cxa_throw(v27, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
        }
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v34, (uint64_t)"The vector ce0 is incompatible (incorrect dimension ", 52);
        int v22 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, (uint64_t)", expecting ", 12);
        long long v23 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)")", 1);
        int v24 = __cxa_allocate_exception(0x10uLL);
        std::stringbuf::str();
        MEMORY[0x1BA9C5420](v24, v33);
        __cxa_throw(v24, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
      }
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v34, (uint64_t)"The matrix CE is incompatible (incorrect number of rows ", 56);
      int v19 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)" , expecting ", 13);
      int v20 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, (uint64_t)")", 1);
      int v21 = __cxa_allocate_exception(0x10uLL);
      std::stringbuf::str();
      MEMORY[0x1BA9C5420](v21, v33);
      __cxa_throw(v21, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v34, (uint64_t)"The matrix G is not a squared matrix (", 38);
    int v16 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)" x ", 3);
    __int32 v17 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)")", 1);
    int v18 = __cxa_allocate_exception(0x10uLL);
    std::stringbuf::str();
    MEMORY[0x1BA9C5420](v18, v33);
    __cxa_throw(v18, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v34, (uint64_t)"The matrix G has 0 dimension (", 30);
  uint64_t v13 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)" x ", 3);
  long long v14 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)")", 1);
  uint64_t v15 = __cxa_allocate_exception(0x10uLL);
  std::stringbuf::str();
  MEMORY[0x1BA9C5420](v15, v33);
  __cxa_throw(v15, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
}

void sub_1B8A0B000(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39,char a40)
{
  if (a39 < 0)
  {
    operator delete(__p);
    if ((v41 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a40);
      _Unwind_Resume(a1);
    }
  }
  else if (!v41)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v40);
  goto LABEL_6;
}

uint64_t std::ostringstream::basic_ostringstream[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA498] + 64;
  *(void *)(a1 + 112) = MEMORY[0x1E4FBA498] + 64;
  uint64_t v3 = *(void *)(MEMORY[0x1E4FBA418] + 16);
  uint64_t v4 = *(void *)(MEMORY[0x1E4FBA418] + 8);
  *(void *)a1 = v4;
  *(void *)(a1 + *(void *)(v4 - 24)) = v3;
  uint64_t v5 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24));
  std::ios_base::init(v5, (void *)(a1 + 8));
  uint64_t v6 = MEMORY[0x1E4FBA498] + 24;
  v5[1].__vftable = 0;
  v5[1].__fmtflags_ = -1;
  *(void *)a1 = v6;
  *(void *)(a1 + 112) = v2;
  std::streambuf::basic_streambuf();
  *(void *)(a1 + _Block_object_dispose(&STACK[0x400], 8) = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 8_Block_object_dispose(&STACK[0x400], 8) = 0u;
  *(_DWORD *)(a1 + 104) = 16;
  return a1;
}

void sub_1B8A0B394(_Unwind_Exception *a1)
{
  std::ostream::~ostream();
  MEMORY[0x1BA9C5670](v1);
  _Unwind_Resume(a1);
}

unsigned int *thirdparty::quadprogpp::cholesky_decomposition(unsigned int *result)
{
  unint64_t v1 = *result;
  if ((int)v1 >= 1)
  {
    uint64_t v2 = result;
    uint64_t v3 = 0;
    uint64_t v4 = *((void *)result + 1);
    uint64_t v5 = (unsigned int **)(v4 + 8);
    uint64_t v6 = 1;
    uint64_t v7 = 8;
    do
    {
      uint64_t v8 = *(void *)(v4 + 8 * v3);
      uint64_t v9 = v3;
      do
      {
        double v10 = *(double *)(v8 + 8 * v9);
        if (v3)
        {
          uint64_t v11 = v6;
          do
          {
            uint64_t result = (unsigned int *)(v11 - 2);
            double v10 = v10
                - *(double *)(v8 + 8 * result)
                * *(double *)(*(void *)(v4 + 8 * v9) + 8 * result);
            --v11;
          }
          while (v11 > 1);
        }
        if (v3 == v9)
        {
          if (v10 <= 0.0)
          {
            std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v19);
            thirdparty::quadprogpp::print_matrix("A", v2, 0xFFFFFFFF, -1);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)"Error in cholesky decomposition, sum: ", 38);
            std::ostream::operator<<();
            exception = __cxa_allocate_exception(0x10uLL);
            std::stringbuf::str();
            MEMORY[0x1BA9C5420](exception, &v18);
            __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
          }
          *(double *)(v8 + 8 * v3) = sqrt(v10);
        }
        else
        {
          *(double *)(*(void *)(v4 + 8 * v9) + 8 * v3) = v10 / *(double *)(v8 + 8 * v3);
        }
        ++v9;
      }
      while ((int)v1 > (int)v9);
      uint64_t v12 = v3 + 1;
      if (v3 + 1 < v1)
      {
        uint64_t v13 = (void *)(v8 + v7);
        unint64_t v14 = v1;
        uint64_t v15 = v5;
        do
        {
          int v16 = *v15++;
          uint64_t result = v16;
          *v13++ = *(void *)&v16[2 * v3];
          --v14;
        }
        while (v6 != v14);
      }
      ++v6;
      ++v5;
      v7 += 8;
      ++v3;
    }
    while (v12 != v1);
  }
  return result;
}

void sub_1B8A0B558(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

void thirdparty::quadprogpp::cholesky_solve()
{
}

BOOL thirdparty::quadprogpp::add_constraint(uint64_t a1, uint64_t a2, int *a3, _DWORD *a4, double *a5)
{
  int v5 = *a3;
  uint64_t v6 = *a4;
  uint64_t v7 = (int)*a4 + 1;
  if (*a3 > (int)v7)
  {
    uint64_t v8 = *((void *)a3 + 1);
    uint64_t v9 = *(uint64_t **)(a2 + 8);
    uint64_t v10 = *a3;
    do
    {
      uint64_t v11 = v10 - 2;
      double v12 = *(double *)(v8 + 8 * (v10-- - 2));
      double v13 = *(double *)(v8 + 8 * v10);
      double v14 = fabs(v12);
      double v15 = fabs(v13);
      if (v14 <= v15)
      {
        if (v15 <= v14) {
          double v16 = v14 * 1.41421356;
        }
        else {
          double v16 = v15 * sqrt(v14 / v15 * (v14 / v15) + 1.0);
        }
      }
      else
      {
        double v16 = v14 * sqrt(v15 / v14 * (v15 / v14) + 1.0);
      }
      if (fabs(v16) >= 2.22044605e-16)
      {
        *(void *)(v8 + 8 * v10) = 0;
        double v17 = v13 / v16;
        double v18 = v12 / v16;
        if (v18 < 0.0)
        {
          double v16 = -v16;
          double v18 = -v18;
          double v17 = -v17;
        }
        *(double *)(v8 + 8 * v11) = v16;
        if (v5 >= 1)
        {
          uint64_t v19 = v5;
          int v20 = v9;
          do
          {
            uint64_t v21 = *v20++;
            double v22 = *(double *)(v21 + 8 * v11);
            double v23 = *(double *)(v21 + 8 * v10);
            double v24 = v17 * v23 + v22 * v18;
            *(double *)(v21 + 8 * v11) = v24;
            *(double *)(v21 + 8 * v10) = -(v23 - v17 / (v18 + 1.0) * (v22 + v24));
            --v19;
          }
          while (v19);
        }
      }
    }
    while (v10 > v7);
  }
  *a4 = v7;
  uint64_t v25 = *((void *)a3 + 1);
  if ((v6 & 0x80000000) == 0)
  {
    int v26 = *(uint64_t **)(a1 + 8);
    uint64_t v7 = v7;
    int v27 = (uint64_t *)*((void *)a3 + 1);
    do
    {
      uint64_t v28 = *v27++;
      uint64_t v29 = v28;
      uint64_t v30 = *v26++;
      *(void *)(v30 + 8 * v6) = v29;
      --v7;
    }
    while (v7);
  }
  double v31 = fabs(*(double *)(v25 + 8 * v6));
  double v32 = *a5;
  double v33 = *a5 * 2.22044605e-16;
  if (v31 > v33)
  {
    if (v32 < v31) {
      double v32 = v31;
    }
    *a5 = v32;
  }
  return v31 > v33;
}

uint64_t thirdparty::quadprogpp::delete_constraint(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int *a7, int a8)
{
  LODWORD(v_Block_object_dispose(&STACK[0x400], 8) = *a7;
  if (*a7 <= a6)
  {
LABEL_4:
    a6 = -1;
  }
  else
  {
    while (*(_DWORD *)(*(void *)(a3 + 8) + 4 * a6) != a8)
    {
      if (v8 == ++a6) {
        goto LABEL_4;
      }
    }
  }
  unsigned int v9 = v8 - 1;
  uint64_t v10 = *(void *)(a3 + 8);
  uint64_t v11 = *(void *)(a4 + 8);
  if (a6 < (int)v8 - 1)
  {
    double v12 = *(uint64_t **)(result + 8);
    uint64_t v13 = a6;
    do
    {
      uint64_t v14 = v13++;
      *(_DWORD *)(v10 + 4 * v14) = *(_DWORD *)(v10 + 4 * v13);
      *(void *)(v11 + 8 * v14) = *(void *)(v11 + 8 * v13);
      if (a5 >= 1)
      {
        uint64_t v15 = a5;
        double v16 = v12;
        do
        {
          uint64_t v17 = *v16++;
          *(void *)(v17 + 8 * v14) = *(void *)(v17 + 8 * v13);
          --v15;
        }
        while (v15);
      }
      uint64_t v8 = *a7;
      unsigned int v9 = v8 - 1;
    }
    while (v13 < v8 - 1);
  }
  *(_DWORD *)(v10 + 4 * v9) = *(_DWORD *)(v10 + 4 * v8);
  uint64_t v18 = *a7;
  *(void *)(v11 + 8 * (v18 - 1)) = *(void *)(v11 + 8 * v18);
  *(_DWORD *)(v10 + 4 * v1_Block_object_dispose(&STACK[0x400], 8) = 0;
  uint64_t v19 = *a7;
  *(void *)(v11 + 8 * v19) = 0;
  if ((int)v19 <= 0)
  {
    LODWORD(v21) = v19 - 1;
  }
  else
  {
    int v20 = *(uint64_t **)(result + 8);
    uint64_t v21 = (v19 - 1);
    do
    {
      uint64_t v22 = *v20++;
      *(void *)(v22 + 8 * v21) = 0;
      --v19;
    }
    while (v19);
  }
  *a7 = v21;
  if (v21 && a6 < (int)v21)
  {
    uint64_t v23 = *(void *)(result + 8);
    double v24 = *(uint64_t **)(a2 + 8);
    uint64_t v25 = a6;
    do
    {
      uint64_t v26 = v25++;
      uint64_t v27 = *(void *)(v23 + 8 * v26);
      double v28 = *(double *)(v27 + 8 * v26);
      uint64_t v29 = *(void *)(v23 + 8 * v25);
      double v30 = *(double *)(v29 + 8 * v26);
      double v31 = fabs(v28);
      double v32 = fabs(v30);
      if (v31 <= v32)
      {
        if (v32 <= v31) {
          double v33 = v31 * 1.41421356;
        }
        else {
          double v33 = v32 * sqrt(v31 / v32 * (v31 / v32) + 1.0);
        }
      }
      else
      {
        double v33 = v31 * sqrt(v32 / v31 * (v32 / v31) + 1.0);
      }
      if (fabs(v33) >= 2.22044605e-16)
      {
        double v34 = v28 / v33;
        double v35 = v30 / v33;
        *(void *)(v29 + 8 * v26) = 0;
        if (v34 < 0.0)
        {
          double v33 = -v33;
          double v34 = -v34;
          double v35 = -v35;
        }
        *(double *)(v27 + 8 * v26) = v33;
        double v36 = v35 / (v34 + 1.0);
        for (uint64_t i = v25; i < (int)v21; ++i)
        {
          double v38 = *(double *)(v27 + 8 * i);
          double v39 = *(double *)(v29 + 8 * i);
          double v40 = v35 * v39 + v38 * v34;
          *(double *)(v27 + 8 * i) = v40;
          *(double *)(v29 + 8 * i) = -(v39 - v36 * (v38 + v40));
        }
        uint64_t v41 = a5;
        int v42 = v24;
        if (a5 >= 1)
        {
          do
          {
            uint64_t v43 = *v42++;
            double v44 = *(double *)(v43 + 8 * v26);
            double v45 = *(double *)(v43 + 8 * v25);
            double v46 = v35 * v45 + v44 * v34;
            *(double *)(v43 + 8 * v26) = v46;
            *(double *)(v43 + 8 * v25) = -(v45 - v36 * (v44 + v46));
            --v41;
          }
          while (v41);
        }
      }
    }
    while (v25 != (int)v21);
  }
  return result;
}

uint64_t std::ostringstream::~ostringstream(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA418];
  uint64_t v3 = *MEMORY[0x1E4FBA418];
  *(void *)a1 = *MEMORY[0x1E4FBA418];
  *(void *)(a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + _Block_object_dispose(&STACK[0x400], 8) = MEMORY[0x1E4FBA470] + 16;
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1BA9C5670](a1 + 112);
  return a1;
}

uint64_t thirdparty::quadprogpp::print_matrix(const char *a1, unsigned int *a2, unsigned int a3, int a4)
{
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v27);
  memset(&__str, 0, sizeof(__str));
  if (a3 == -1) {
    uint64_t v8 = *a2;
  }
  else {
    uint64_t v8 = a3;
  }
  if (a4 == -1) {
    int v9 = a2[1];
  }
  else {
    int v9 = a4;
  }
  size_t v10 = strlen(a1);
  uint64_t v11 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v27, (uint64_t)a1, v10);
  double v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)": ", 2);
  std::ios_base::getloc((const std::ios_base *)((char *)v12 + *(void *)(*v12 - 24)));
  uint64_t v13 = std::locale::use_facet((const std::locale *)&v25, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v13->__vftable[2].~facet_0)(v13, 10);
  std::locale::~locale((std::locale *)&v25);
  std::ostream::put();
  std::ostream::flush();
  if ((int)v8 >= 1)
  {
    uint64_t v14 = 0;
    uint64_t v15 = (std::locale::id *)MEMORY[0x1E4FBA258];
    do
    {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v27, (uint64_t)" ", 1);
      if (v9 >= 1)
      {
        uint64_t v16 = 0;
        do
        {
          uint64_t v17 = (void *)std::ostream::operator<<();
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)", ", 2);
          v16 += 8;
        }
        while (8 * v9 != v16);
      }
      std::ios_base::getloc((const std::ios_base *)((char *)v27 + *(void *)(v27[0] - 24)));
      uint64_t v18 = std::locale::use_facet((const std::locale *)&v25, v15);
      ((void (*)(const std::locale::facet *, uint64_t))v18->__vftable[2].~facet_0)(v18, 10);
      std::locale::~locale((std::locale *)&v25);
      std::ostream::put();
      std::ostream::flush();
      ++v14;
    }
    while (v14 != v8);
  }
  std::stringbuf::str();
  std::string __str = v25;
  std::string::size_type size = HIBYTE(v25.__r_.__value_.__r.__words[2]);
  if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = v25.__r_.__value_.__l.__size_;
  }
  std::string::basic_string(&v25, &__str, 0, size - 3, (std::allocator<char> *)v30);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  std::string __str = v25;
  if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_str = &__str;
  }
  else {
    p_str = (std::string *)v25.__r_.__value_.__r.__words[0];
  }
  if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v21 = HIBYTE(v25.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v21 = v25.__r_.__value_.__l.__size_;
  }
  uint64_t v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)p_str, v21);
  std::ios_base::getloc((const std::ios_base *)((char *)v22 + *(void *)(*v22 - 24)));
  uint64_t v23 = std::locale::use_facet((const std::locale *)&v25, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v23->__vftable[2].~facet_0)(v23, 10);
  std::locale::~locale((std::locale *)&v25);
  std::ostream::put();
  std::ostream::flush();
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  v27[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v27 + *(void *)(v27[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v27[1] = MEMORY[0x1E4FBA470] + 16;
  if (v28 < 0) {
    operator delete((void *)v27[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1BA9C5670](&v29);
}

void sub_1B8A0BFDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::ostringstream::~ostringstream((uint64_t)&a19);
  _Unwind_Resume(a1);
}

void thirdparty::quadprogpp::Matrix<double>::Matrix()
{
}

uint64_t ARSavePixelBufferPNG(__CVBuffer *a1, void *a2)
{
  id v3 = a2;
  signed int PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  size_t WidthOfPlane = CVPixelBufferGetWidthOfPlane(a1, 0);
  size_t HeightOfPlane = CVPixelBufferGetHeightOfPlane(a1, 0);
  CVPixelBufferRef pixelBufferOut = 0;
  CVPixelBufferLockBaseAddress(a1, 1uLL);
  if (PixelFormatType > 1111970368)
  {
    switch(PixelFormatType)
    {
      case 1111970369:
        goto LABEL_17;
      case 1278226488:
        cva::imageViewFromPixelBuffer<unsigned char>();
      case 1380401729:
        cva::imageViewFromPixelBuffer<cva::Matrix<unsigned char,4u,1u,false>>();
    }
  }
  else
  {
    if (PixelFormatType == 32) {
      goto LABEL_17;
    }
    if (PixelFormatType == 875704422 || PixelFormatType == 875704438)
    {
      uint64_t v7 = CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], WidthOfPlane, HeightOfPlane, 0x20u, 0, &pixelBufferOut);
      if (v7)
      {
        uint64_t v8 = _ARLogGeneral();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)vImage_Buffer buf = 0;
          _os_log_impl(&dword_1B88A2000, v8, OS_LOG_TYPE_ERROR, "Could not create image buffer of type kCVPixelFormatType_32ARGB", buf, 2u);
        }
        goto LABEL_20;
      }
      ARPixelBufferConvertYCbCrToARGB(a1, &pixelBufferOut);
LABEL_17:
      if (pixelBufferOut) {
        cva::imageViewFromPixelBuffer<cva::Matrix<unsigned char,4u,1u,false>>();
      }
      cva::imageViewFromPixelBuffer<cva::Matrix<unsigned char,4u,1u,false>>();
    }
  }
  uint64_t v8 = _ARLogGeneral();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)vImage_Buffer buf = 0;
    _os_log_impl(&dword_1B88A2000, v8, OS_LOG_TYPE_ERROR, "Supported formats are:  - kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange - kCVPixelFormatType_420YpCbCr8BiPlanarFullRange - kCVPixelFormatType_OneComponent8 - kCVPixelFormatType_32RGBA - kCVPixelFormatType_32ARGB - kCVPixelFormatType_32BGRA", buf, 2u);
  }
  uint64_t v7 = 4294960616;
LABEL_20:

  return v7;
}

void sub_1B8A0C458(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22)
{
  _Unwind_Resume(a1);
}

uint64_t ARSaveFloatingPixelBufferAsPng16(void *a1, __CVBuffer *a2, float a3)
{
  id v5 = a1;
  if (!a2)
  {
    uint64_t v14 = _ARLogGeneral();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)vImage_Buffer buf = 0;
      uint64_t v15 = "Input buffer cannot be null";
LABEL_23:
      _os_log_impl(&dword_1B88A2000, v14, OS_LOG_TYPE_ERROR, v15, buf, 2u);
    }
LABEL_24:

    uint64_t v20 = 0;
    goto LABEL_25;
  }
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(a2);
  if (PixelFormatType != 1278226534 && PixelFormatType != 1717855600 && PixelFormatType != 1717856627)
  {
    uint64_t v14 = _ARLogGeneral();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)vImage_Buffer buf = 0;
      uint64_t v15 = "Supported formats are kCVPixelFormatType_OneComponent32Float, kCVPixelFormatType_DepthFloat32 or kCVPixelFor"
            "matType_DisparityFloat32";
      goto LABEL_23;
    }
    goto LABEL_24;
  }
  CVPixelBufferLockBaseAddress(a2, 1uLL);
  size_t Width = CVPixelBufferGetWidth(a2);
  unsigned int Height = CVPixelBufferGetHeight(a2);
  size_t BytesPerRow = CVPixelBufferGetBytesPerRow(a2);
  BaseAddress = (float *)CVPixelBufferGetBaseAddress(a2);
  unint64_t v11 = Width | ((unint64_t)Height << 32);
  *(void *)vImage_Buffer buf = 0;
  unint64_t v30 = v11;
  unint64_t v31 = ((Width << 33) + 0xF00000000) & 0xFFFFFFF000000000 | 2;
  unint64_t v34 = v11;
  unint64_t v33 = v31;
  double v12 = cva::Array<cva::Matrix<unsigned char,4u,1u,false>,2u,16u>::allocate((uint64_t)&v34, (uint64_t)&v33);
  double v32 = v12;
  v27[0] = 0;
  v27[1] = v11;
  v27[3] = 0;
  char v28 = 0;
  v27[2] = (BytesPerRow << 32) | 4;
  if (BaseAddress)
  {
    char v28 = BaseAddress;
    uint64_t v13 = (float *)((char *)BaseAddress + BytesPerRow * Height);
  }
  else
  {
    uint64_t v13 = 0;
  }
  uint64_t v22 = 0;
  unint64_t v23 = v11;
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  unint64_t v24 = ((Width << 33) + 0xF00000000) & 0xFFFFFFF000000000 | 2;
  if (v12) {
    uint64_t v26 = v12;
  }
  if (BaseAddress != v13)
  {
    do
    {
      float v16 = *BaseAddress * a3;
      BOOL v17 = v16 > 65535.0 || v16 < 0.0;
      int v18 = (int)v16;
      if (v17) {
        LOWORD(v1_Block_object_dispose(&STACK[0x400], 8) = 0;
      }
      _WORD *v26 = v18;
      cva::ArrayIterator<float,2u>::increment((uint64_t)v27);
      cva::ArrayIterator<float,2u>::increment((uint64_t)&v22);
      BaseAddress = v28;
    }
    while (v28 != v13);
  }
  CVPixelBufferUnlockBaseAddress(a2, 1uLL);
  id v19 = v5;
  objc_msgSend(v19, "UTF8String", v22, v23, v24, v25);
  uint64_t v20 = cva::imwrite<unsigned short>();
  if (v32) {
    free(v32);
  }
LABEL_25:

  return v20;
}

void sub_1B8A0C74C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22)
{
  _Unwind_Resume(a1);
}

uint64_t ARSavePixelBufferPGM(__CVBuffer *a1, void *a2)
{
  v23[19] = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  if (PixelFormatType == 875704422 || PixelFormatType == 875704438 || PixelFormatType == 1278226488)
  {
    CVPixelBufferLockBaseAddress(a1, 0);
    CVPixelBufferGetWidthOfPlane(a1, 0);
    size_t HeightOfPlane = CVPixelBufferGetHeightOfPlane(a1, 0);
    size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(a1, 0);
    BaseAddressOfPlane = (char *)CVPixelBufferGetBaseAddressOfPlane(a1, 0);
    [v3 UTF8String];
    std::ofstream::basic_ofstream((uint64_t *)buf);
    uint64_t v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(buf, (uint64_t)"P5", 2);
    std::ios_base::getloc((const std::ios_base *)((char *)v8 + *(void *)(*v8 - 24)));
    int v9 = std::locale::use_facet(&v20, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v9->__vftable[2].~facet_0)(v9, 10);
    std::locale::~locale(&v20);
    std::ostream::put();
    std::ostream::flush();
    size_t v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(buf, (uint64_t)"# ARKit image dump", 18);
    std::ios_base::getloc((const std::ios_base *)((char *)v10 + *(void *)(*v10 - 24)));
    unint64_t v11 = std::locale::use_facet(&v20, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 10);
    std::locale::~locale(&v20);
    std::ostream::put();
    std::ostream::flush();
    double v12 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)" ", 1);
    uint64_t v13 = (void *)std::ostream::operator<<();
    std::ios_base::getloc((const std::ios_base *)((char *)v13 + *(void *)(*v13 - 24)));
    uint64_t v14 = std::locale::use_facet(&v20, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v14->__vftable[2].~facet_0)(v14, 10);
    std::locale::~locale(&v20);
    std::ostream::put();
    std::ostream::flush();
    uint64_t v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(buf, (uint64_t)"255", 3);
    std::ios_base::getloc((const std::ios_base *)((char *)v15 + *(void *)(*v15 - 24)));
    float v16 = std::locale::use_facet(&v20, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v16->__vftable[2].~facet_0)(v16, 10);
    std::locale::~locale(&v20);
    std::ostream::put();
    std::ostream::flush();
    for (; HeightOfPlane; --HeightOfPlane)
    {
      std::ostream::write();
      BaseAddressOfPlane += BytesPerRowOfPlane;
    }
    if (!std::filebuf::close()) {
      std::ios_base::clear((std::ios_base *)&buf[*(void *)(*(void *)buf - 24)], *(_DWORD *)&v22[*(void *)(*(void *)buf - 24) + 24] | 4);
    }
    CVPixelBufferUnlockBaseAddress(a1, 0);
    *(void *)vImage_Buffer buf = *MEMORY[0x1E4FBA400];
    *(void *)&buf[*(void *)(*(void *)buf - 24)] = *(void *)(MEMORY[0x1E4FBA400] + 24);
    MEMORY[0x1BA9C54E0](v22);
    std::ostream::~ostream();
    MEMORY[0x1BA9C5670](v23);
    uint64_t v17 = 0;
  }
  else
  {
    int v18 = _ARLogGeneral();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)vImage_Buffer buf = 0;
      _os_log_impl(&dword_1B88A2000, v18, OS_LOG_TYPE_ERROR, "Supported formats are kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange, kCVPixelFormatType_420YpCbCr8BiPlanarFullRange or kCVPixelFormatType_OneComponent8", buf, 2u);
    }

    uint64_t v17 = 4294960616;
  }

  return v17;
}

void sub_1B8A0CC60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, char a11)
{
  _Unwind_Resume(a1);
}

uint64_t *std::ofstream::basic_ofstream(uint64_t *a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA468] + 64;
  a1[52] = MEMORY[0x1E4FBA468] + 64;
  id v3 = a1 + 1;
  uint64_t v4 = *(void *)(MEMORY[0x1E4FBA400] + 16);
  uint64_t v5 = *(void *)(MEMORY[0x1E4FBA400] + 8);
  *a1 = v5;
  *(uint64_t *)((char *)a1 + *(void *)(v5 - 24)) = v4;
  uint64_t v6 = (std::ios_base *)((char *)a1 + *(void *)(*a1 - 24));
  std::ios_base::init(v6, a1 + 1);
  uint64_t v7 = MEMORY[0x1E4FBA468] + 24;
  v6[1].__vftable = 0;
  v6[1].__fmtflags_ = -1;
  *a1 = v7;
  a1[52] = v2;
  MEMORY[0x1BA9C54D0](v3);
  if (!std::filebuf::open()) {
    std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 4);
  }
  return a1;
}

void sub_1B8A0CE44(_Unwind_Exception *a1)
{
  std::ostream::~ostream();
  MEMORY[0x1BA9C5670](v1);
  _Unwind_Resume(a1);
}

void *std::ofstream::~ofstream(void *a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA400];
  uint64_t v3 = *MEMORY[0x1E4FBA400];
  *a1 = *MEMORY[0x1E4FBA400];
  *(void *)((char *)a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  MEMORY[0x1BA9C54E0](a1 + 1);
  std::ostream::~ostream();
  MEMORY[0x1BA9C5670](a1 + 52);
  return a1;
}

uint64_t ARSavePixelBufferPPM(__CVBuffer *a1, void *a2)
{
  v42[19] = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  signed int PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  if (PixelFormatType <= 875704437)
  {
    if (PixelFormatType == 32) {
      goto LABEL_8;
    }
    int v5 = 875704422;
  }
  else
  {
    if (PixelFormatType == 875704438 || PixelFormatType == 1111970369)
    {
LABEL_8:
      CVPixelBufferRef pixelBuffer = 0;
      if ((PixelFormatType & 0xFFFFFFEF) == 0x34323066)
      {
        size_t WidthOfPlane = CVPixelBufferGetWidthOfPlane(a1, 0);
        size_t HeightOfPlane = CVPixelBufferGetHeightOfPlane(a1, 0);
        uint64_t v8 = CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], WidthOfPlane, HeightOfPlane, 0x20u, 0, &pixelBuffer);
        if (v8)
        {
          int v9 = _ARLogGeneral();
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)vImage_Buffer buf = 0;
            _os_log_impl(&dword_1B88A2000, v9, OS_LOG_TYPE_ERROR, "Could not create image buffer of type kCVPixelFormatType_32ARGB", buf, 2u);
          }
LABEL_12:

          goto LABEL_46;
        }
        uint64_t v8 = ARPixelBufferConvertYCbCrToARGB(a1, &pixelBuffer);
        if (v8)
        {
          int v9 = _ARLogGeneral();
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)vImage_Buffer buf = 0;
            _os_log_impl(&dword_1B88A2000, v9, OS_LOG_TYPE_ERROR, "Could not convert pixel formats", buf, 2u);
          }
          goto LABEL_12;
        }
      }
      else
      {
        CVPixelBufferRef pixelBuffer = a1;
        CVPixelBufferRetain(a1);
      }
      CVPixelBufferLockBaseAddress(pixelBuffer, 0);
      OSType v10 = CVPixelBufferGetPixelFormatType(pixelBuffer);
      size_t v11 = CVPixelBufferGetWidthOfPlane(pixelBuffer, 0);
      size_t v12 = CVPixelBufferGetHeightOfPlane(pixelBuffer, 0);
      size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, 0);
      BaseAddressOfPlane = (char *)CVPixelBufferGetBaseAddressOfPlane(pixelBuffer, 0);
      [v3 UTF8String];
      std::ofstream::basic_ofstream((uint64_t *)buf);
      uint64_t v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(buf, (uint64_t)"P6", 2);
      std::ios_base::getloc((const std::ios_base *)((char *)v15 + *(void *)(*v15 - 24)));
      float v16 = std::locale::use_facet(&v39, MEMORY[0x1E4FBA258]);
      ((void (*)(const std::locale::facet *, uint64_t))v16->__vftable[2].~facet_0)(v16, 10);
      std::locale::~locale(&v39);
      std::ostream::put();
      std::ostream::flush();
      uint64_t v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(buf, (uint64_t)"# ARKit image dump", 18);
      std::ios_base::getloc((const std::ios_base *)((char *)v17 + *(void *)(*v17 - 24)));
      int v18 = std::locale::use_facet(&v39, MEMORY[0x1E4FBA258]);
      ((void (*)(const std::locale::facet *, uint64_t))v18->__vftable[2].~facet_0)(v18, 10);
      std::locale::~locale(&v39);
      std::ostream::put();
      std::ostream::flush();
      id v19 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)" ", 1);
      std::locale v20 = (void *)std::ostream::operator<<();
      std::ios_base::getloc((const std::ios_base *)((char *)v20 + *(void *)(*v20 - 24)));
      std::string::size_type v21 = std::locale::use_facet(&v39, MEMORY[0x1E4FBA258]);
      ((void (*)(const std::locale::facet *, uint64_t))v21->__vftable[2].~facet_0)(v21, 10);
      std::locale::~locale(&v39);
      std::ostream::put();
      std::ostream::flush();
      uint64_t v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(buf, (uint64_t)"255", 3);
      std::ios_base::getloc((const std::ios_base *)((char *)v22 + *(void *)(*v22 - 24)));
      unint64_t v23 = std::locale::use_facet(&v39, MEMORY[0x1E4FBA258]);
      ((void (*)(const std::locale::facet *, uint64_t))v23->__vftable[2].~facet_0)(v23, 10);
      std::locale::~locale(&v39);
      std::ostream::put();
      std::ostream::flush();
      switch(v10)
      {
        case 0x20u:
          if (v12)
          {
            uint64_t v29 = 0;
            unint64_t v30 = BaseAddressOfPlane + 3;
            do
            {
              size_t v31 = v11;
              for (uint64_t i = v30; v31; --v31)
              {
                ARSavePixelBufferPPM::color = *(i - 2);
                byte_1E9EEE2E1 = *(i - 1);
                byte_1E9EEE2E2 = *i;
                std::ostream::write();
                i += 4;
              }
              ++v29;
              v30 += BytesPerRowOfPlane;
            }
            while (v29 != v12);
          }
          break;
        case 0x42475241u:
          if (v12)
          {
            uint64_t v33 = 0;
            unint64_t v34 = BaseAddressOfPlane + 2;
            do
            {
              size_t v35 = v11;
              for (uint64_t j = v34; v35; --v35)
              {
                ARSavePixelBufferPPM::color = *j;
                byte_1E9EEE2E4 = *(j - 1);
                byte_1E9EEE2E5 = *(j - 2);
                std::ostream::write();
                j += 4;
              }
              ++v33;
              v34 += BytesPerRowOfPlane;
            }
            while (v33 != v12);
          }
          break;
        case 0x4C303038u:
          if (v12)
          {
            for (uint64_t k = 0; k != v12; ++k)
            {
              size_t v25 = v11;
              for (size_t m = BaseAddressOfPlane; v25; --v25)
              {
                ARSavePixelBufferPPM::color = *m;
                byte_1E9EEE2E7 = *m;
                char v27 = *m++;
                byte_1E9EEE2E8 = v27;
                std::ostream::write();
              }
              BaseAddressOfPlane += BytesPerRowOfPlane;
            }
          }
          break;
        default:
          uint64_t v8 = 4294960616;
          goto LABEL_43;
      }
      uint64_t v8 = 0;
LABEL_43:
      if (!std::filebuf::close()) {
        std::ios_base::clear((std::ios_base *)&buf[*(void *)(*(void *)buf - 24)], *(_DWORD *)&v41[*(void *)(*(void *)buf - 24) + 24] | 4);
      }
      CVPixelBufferUnlockBaseAddress(pixelBuffer, 0);
      CVPixelBufferRelease(pixelBuffer);
      *(void *)vImage_Buffer buf = *MEMORY[0x1E4FBA400];
      *(void *)&buf[*(void *)(*(void *)buf - 24)] = *(void *)(MEMORY[0x1E4FBA400] + 24);
      MEMORY[0x1BA9C54E0](v41);
      std::ostream::~ostream();
      MEMORY[0x1BA9C5670](v42);
      goto LABEL_46;
    }
    int v5 = 1278226488;
  }
  if (PixelFormatType == v5) {
    goto LABEL_8;
  }
  char v28 = _ARLogGeneral();
  if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)vImage_Buffer buf = 0;
    _os_log_impl(&dword_1B88A2000, v28, OS_LOG_TYPE_ERROR, "Supported formats are kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange, kCVPixelFormatType_420YpCbCr8BiPlanarFullRange, kCVPixelFormatType_OneComponent8 or kCVPixelFormatType_32ARGB", buf, 2u);
  }

  uint64_t v8 = 4294960616;
LABEL_46:

  return v8;
}

void sub_1B8A0D6A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, char a11)
{
  _Unwind_Resume(a1);
}

uint64_t ARSavePixelBufferEXR(__CVBuffer *a1, void *a2)
{
  keys[1] = *(void **)MEMORY[0x1E4F143B8];
  id v3 = a2;
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  OSType v5 = PixelFormatType;
  if (PixelFormatType == 843264104 || PixelFormatType == 1380411457)
  {
    size_t WidthOfPlane = CVPixelBufferGetWidthOfPlane(a1, 0);
    size_t HeightOfPlane = CVPixelBufferGetHeightOfPlane(a1, 0);
    CVPixelBufferRef pixelBufferOut = 0;
    if (v5 != 1380411457)
    {
      if (v5 == 843264104)
      {
        uint64_t v8 = CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], WidthOfPlane, HeightOfPlane, 0x52476841u, 0, &pixelBufferOut);
        if (v8)
        {
          int v9 = _ARLogGeneral();
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          {
            LODWORD(keys[0]) = 67109120;
            HIDWORD(keys[0]) = v8;
            OSType v10 = "CVPixelBufferCreate failed to create pixel buffer of type kCVPixelFormatType_128RGBAFloat with error %i";
LABEL_19:
            _os_log_impl(&dword_1B88A2000, v9, OS_LOG_TYPE_ERROR, v10, (uint8_t *)keys, 8u);
            goto LABEL_23;
          }
          goto LABEL_23;
        }
        uint64_t v8 = ARPixelBufferConvertTwoComponent16HalfToRGBAHalf(a1, &pixelBufferOut);
        if (!v8)
        {
LABEL_12:
          CVPixelBufferLockBaseAddress(pixelBufferOut, 0);
          BaseAddressOfPlane = CVPixelBufferGetBaseAddressOfPlane(pixelBufferOut, 0);
          size_t DataSize = CVPixelBufferGetDataSize(pixelBufferOut);
          uint64_t v14 = CGDataProviderCreateWithData(0, BaseAddressOfPlane, DataSize, 0);
          DeviceRGB = CGColorSpaceCreateDeviceRGB();
          size_t BytesPerRow = CVPixelBufferGetBytesPerRow(pixelBufferOut);
          uint64_t v17 = CGImageCreate(WidthOfPlane, HeightOfPlane, 0x10uLL, 0x40uLL, BytesPerRow, DeviceRGB, 0x1103u, v14, 0, 0, kCGRenderingIntentDefault);
          int v9 = [MEMORY[0x1E4F1CB10] fileURLWithPath:v3 isDirectory:0];
          CFAllocatorRef v18 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          CFStringRef v19 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], "com.ilm.openexr-image", 0x8000100u);
          std::locale v20 = CGImageDestinationCreateWithURL((CFURLRef)v9, v19, 1uLL, 0);
          keys[0] = *(void **)MEMORY[0x1E4F2F418];
          values = (void *)*MEMORY[0x1E4F1CFD0];
          CFDictionaryRef v21 = CFDictionaryCreate(v18, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          CGImageDestinationAddImage(v20, v17, v21);
          BOOL v22 = CGImageDestinationFinalize(v20);
          if (v20) {
            CFRelease(v20);
          }
          CFRelease(v21);
          CFRelease(v19);
          CGImageRelease(v17);
          CGColorSpaceRelease(DeviceRGB);
          CGDataProviderRelease(v14);
          CVPixelBufferUnlockBaseAddress(pixelBufferOut, 0);
          CVPixelBufferRelease(pixelBufferOut);
          if (v22)
          {
            uint64_t v8 = 0;
          }
          else
          {
            unint64_t v23 = _ARLogGeneral();
            if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)vImage_Buffer buf = 0;
              _os_log_impl(&dword_1B88A2000, v23, OS_LOG_TYPE_ERROR, "Could not save image to file", buf, 2u);
            }

            uint64_t v8 = 4294960636;
          }
          goto LABEL_23;
        }
      }
      else
      {
        uint64_t v8 = 4294960636;
      }
      int v9 = _ARLogGeneral();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        LODWORD(keys[0]) = 67109120;
        HIDWORD(keys[0]) = v8;
        OSType v10 = "Could not convert pixel formats with error: %i";
        goto LABEL_19;
      }
LABEL_23:

      goto LABEL_24;
    }
    CVPixelBufferRef pixelBufferOut = a1;
    CVPixelBufferRetain(a1);
    goto LABEL_12;
  }
  size_t v11 = _ARLogGeneral();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    LOWORD(pixelBufferOut) = 0;
    _os_log_impl(&dword_1B88A2000, v11, OS_LOG_TYPE_ERROR, "Supported pixel formats are kCVPixelFormatType_64RGBAHalf, kCVPixelFormatType_TwoComponent16Half", (uint8_t *)&pixelBufferOut, 2u);
  }

  uint64_t v8 = 4294960616;
LABEL_24:

  return v8;
}

void sub_1B8A0DB20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ARResizeBufferWithNearestNeighbors(__CVBuffer *a1, __CVBuffer *a2, size_t a3)
{
  size_t Height = CVPixelBufferGetHeight(a1);
  size_t Width = CVPixelBufferGetWidth(a1);
  size_t v8 = CVPixelBufferGetHeight(a2);
  size_t v9 = CVPixelBufferGetWidth(a2);
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  if (PixelFormatType != CVPixelBufferGetPixelFormatType(a2)) {
    return 4294960616;
  }
  uint64_t result = 4294960615;
  if (Height && Width && v8 && v9)
  {
    float v12 = (float)Height / (float)v8;
    float v13 = (float)Width / (float)v9;
    CVPixelBufferLockBaseAddress(a1, 0);
    CVPixelBufferLockBaseAddress(a2, 0);
    BaseAddress = (char *)CVPixelBufferGetBaseAddress(a1);
    CVPixelBufferRef pixelBuffer = a1;
    size_t BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
    uint64_t v15 = (char *)CVPixelBufferGetBaseAddress(a2);
    unint64_t v23 = a2;
    size_t v16 = CVPixelBufferGetBytesPerRow(a2);
    for (unint64_t i = 0; i != v18; ++i)
    {
      size_t v18 = v8;
      unint64_t v19 = 0;
      std::locale v20 = &BaseAddress[BytesPerRow * vcvtms_u32_f32(v12 * (float)i)];
      CFDictionaryRef v21 = v15;
      do
      {
        memcpy(v21, &v20[vcvtas_u32_f32(v13 * (float)v19++) * a3], a3);
        v21 += a3;
      }
      while (v9 != v19);
      v15 += v16;
      size_t v8 = v18;
    }
    CVPixelBufferUnlockBaseAddress(pixelBuffer, 0);
    CVPixelBufferUnlockBaseAddress(v23, 0);
    return 0;
  }
  return result;
}

BOOL ARDrawNormalizedCGRectIntoYUVPixelBuffer(__CVBuffer *a1, int a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6)
{
  OSType v12 = CVPixelBufferGetPixelFormatType(a1) & 0xFFFFFFEF;
  if (v12 == 875704422)
  {
    v54.origin.double x = 0.0;
    v54.origin.double y = 0.0;
    v54.size.double width = 1.0;
    v54.size.double height = 1.0;
    v52.origin.double x = a3;
    v52.origin.double y = a4;
    v52.size.double width = a5;
    v52.size.double height = a6;
    CGRect v53 = CGRectIntersection(v52, v54);
    double x = v53.origin.x;
    double y = v53.origin.y;
    double width = v53.size.width;
    double height = v53.size.height;
    CVPixelBufferLockBaseAddress(a1, 0);
    long long v50 = 0u;
    long long v51 = 0u;
    ARWrapCVPixelBufferPlaneVImage(a1, 0, (void **)&v50);
    long long v48 = 0u;
    long long v49 = 0u;
    ARWrapCVPixelBufferPlaneVImage(a1, 1uLL, (void **)&v48);
    unint64_t v16 = (unint64_t)(x * (double)(unint64_t)v51);
    double v17 = (double)*((unint64_t *)&v50 + 1);
    unint64_t v18 = (unint64_t)(y * (double)*((unint64_t *)&v50 + 1));
    vImagePixelCount v19 = (unint64_t)(width * (double)(unint64_t)v51);
    unint64_t v20 = v49;
    unint64_t v21 = *((void *)&v48 + 1);
    double v22 = (double)a2;
    double v23 = (double)BYTE1(a2);
    double v24 = (double)BYTE2(a2);
    double v25 = v23 * 0.504 + v22 * 0.257 + v24 * 0.098 + 16.0;
    int v26 = (int)v25;
    unint64_t v27 = v19 + v16;
    if (v19 + v16 <= (uint64_t)v51 - 1)
    {
      uint64_t v28 = v49;
      if (v18 + 5 <= *((void *)&v50 + 1) - 1)
      {
        dest.data = (void *)(v50 + *((void *)&v51 + 1) * v18 + v16);
        dest.double height = 5;
        dest.double width = (unint64_t)(width * (double)(unint64_t)v51);
        dest.rowBytes = *((void *)&v51 + 1);
        vImageOverwriteChannelsWithScalar_Planar8((int)v25, &dest, 0x10u);
        uint64_t v28 = v49;
      }
    }
    else
    {
      uint64_t v28 = v49;
    }
    double v29 = (double)v20;
    unint64_t v30 = (unint64_t)(x * (double)v20);
    double v31 = (double)v21;
    unint64_t v32 = (unint64_t)(y * (double)v21);
    vImagePixelCount v33 = (unint64_t)(width * v29);
    int v44 = (int)(v23 * -0.291 + v22 * -0.148 + v24 * 0.439 + 128.0);
    int v43 = (int)(v23 * -0.368 + v22 * 0.439 + v24 * -0.071 + 128.0);
    unint64_t v34 = v33 + v30;
    if (v33 + v30 <= v28 - 1 && v32 + 5 <= *((void *)&v48 + 1) - 1)
    {
      v46.data = (void *)(v48 + *((void *)&v49 + 1) * v32 + 2 * v30);
      v46.double height = 5;
      v46.double width = (unint64_t)(width * v29);
      v46.rowBytes = *((void *)&v49 + 1);
      vImageOverwriteChannelsWithScalar_Planar16U(v44 | ((_WORD)v43 << 8), &v46, 0x10u);
      unint64_t v32 = (unint64_t)(y * (double)v21);
    }
    unint64_t v42 = v18;
    unint64_t v35 = v18 + (unint64_t)(height * v17);
    if (v27 <= (uint64_t)v51 - 1)
    {
      float v36 = (float)v35 + -5.0;
      if ((unint64_t)v36 + 5 <= *((void *)&v50 + 1) - 1)
      {
        dest.data = (void *)(v50 + *((void *)&v51 + 1) * (unint64_t)v36 + v16);
        dest.double height = 5;
        dest.double width = v19;
        dest.rowBytes = *((void *)&v51 + 1);
        vImageOverwriteChannelsWithScalar_Planar8(v26, &dest, 0x10u);
        unint64_t v32 = (unint64_t)(y * (double)v21);
      }
    }
    unint64_t v37 = v32 + (unint64_t)(height * v31);
    if (v34 <= (uint64_t)v49 - 1)
    {
      float v38 = (float)v37 + -5.0;
      if ((unint64_t)v38 + 5 <= *((void *)&v48 + 1) - 1)
      {
        v46.data = (void *)(v48 + *((void *)&v49 + 1) * (unint64_t)v38 + 2 * v30);
        v46.double height = 5;
        v46.double width = v33;
        v46.rowBytes = *((void *)&v49 + 1);
        vImageOverwriteChannelsWithScalar_Planar16U(v44 | ((_WORD)v43 << 8), &v46, 0x10u);
        unint64_t v32 = (unint64_t)(y * (double)v21);
      }
    }
    if (v16 + 5 <= (uint64_t)v51 - 1 && v35 <= *((void *)&v50 + 1) - 1)
    {
      dest.data = (void *)(v50 + *((void *)&v51 + 1) * v42 + v16);
      dest.double height = (unint64_t)(height * v17);
      dest.double width = 5;
      dest.rowBytes = *((void *)&v51 + 1);
      vImageOverwriteChannelsWithScalar_Planar8(v26, &dest, 0x10u);
      unint64_t v32 = (unint64_t)(y * (double)v21);
    }
    if (v30 + 5 <= (uint64_t)v49 - 1 && v37 <= *((void *)&v48 + 1) - 1)
    {
      v46.data = (void *)(v48 + *((void *)&v49 + 1) * v32 + 2 * v30);
      v46.double height = (unint64_t)(height * v31);
      v46.double width = 5;
      v46.rowBytes = *((void *)&v49 + 1);
      vImageOverwriteChannelsWithScalar_Planar16U(v44 | ((_WORD)v43 << 8), &v46, 0x10u);
      unint64_t v32 = (unint64_t)(y * (double)v21);
    }
    float v39 = (float)v27 + -5.0;
    if ((unint64_t)v39 + 5 <= (uint64_t)v51 - 1 && v35 <= *((void *)&v50 + 1) - 1)
    {
      dest.data = (void *)(v50 + *((void *)&v51 + 1) * v42 + (unint64_t)v39);
      dest.double height = (unint64_t)(height * v17);
      dest.double width = 5;
      dest.rowBytes = *((void *)&v51 + 1);
      vImageOverwriteChannelsWithScalar_Planar8(v26, &dest, 0x10u);
      unint64_t v32 = (unint64_t)(y * (double)v21);
    }
    unint64_t v40 = (unint64_t)(float)((float)v34 + -5.0);
    if (v40 + 5 <= (uint64_t)v49 - 1 && v37 <= *((void *)&v48 + 1) - 1)
    {
      v46.data = (void *)(v48 + *((void *)&v49 + 1) * v32 + 2 * v40);
      v46.double height = (unint64_t)(height * v31);
      v46.double width = 5;
      v46.rowBytes = *((void *)&v49 + 1);
      vImageOverwriteChannelsWithScalar_Planar16U(v44 | ((_WORD)v43 << 8), &v46, 0x10u);
    }
    CVPixelBufferUnlockBaseAddress(a1, 0);
  }
  return v12 == 875704422;
}

void ___ZL13_ARLogGeneralv_block_invoke_28()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "General");
  uint64_t v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObuint64_t j = (uint64_t)v0;
}

void *cva::Array<cva::Matrix<unsigned char,4u,1u,false>,2u,16u>::allocate(uint64_t a1, uint64_t a2)
{
  unint64_t size = *(unsigned int *)(a1 + 4) * (unint64_t)*(unsigned int *)(a2 + 4);
  if (!size) {
    return 0;
  }
  uint64_t result = malloc_type_malloc(size, 0xA153FF5uLL);
  if (!result) {
    cva::Array<cva::Matrix<unsigned char,4u,1u,false>,2u,16u>::allocate();
  }
  return result;
}

uint64_t cva::ArrayIterator<float,2u>::increment(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  if (!v1) {
    cva::ArrayIterator<float,2u>::increment();
  }
  uint64_t v2 = *(unsigned int *)(result + 16);
  uint64_t v3 = v1 + v2;
  int v4 = *(_DWORD *)(result + 24) + 1;
  *(_DWORD *)(result + 24) = v4;
  if (v4 == *(_DWORD *)(result + 8))
  {
    uint64_t v3 = v3 - (v2 * v4) + *(unsigned int *)(result + 20);
    int v5 = *(_DWORD *)(result + 28) + 1;
    *(_DWORD *)(result + 24) = 0;
    *(_DWORD *)(result + 2_Block_object_dispose(&STACK[0x400], 8) = v5;
  }
  *(void *)(result + 32) = v3;
  return result;
}

uint64_t **thirdparty::quadprogpp::seq@<X0>(uint64_t **this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  *(void *)(a3 + 16) = 0;
  *(void *)(a3 + _Block_object_dispose(&STACK[0x400], 8) = 0;
  *(void *)a3 = a3 + 8;
  for (unsigned int i = this; i <= a2; ++i)
    this = std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int const&>((uint64_t **)a3, &i, &i);
  return this;
}

void sub_1B8A0E3E4(_Unwind_Exception *a1)
{
  std::__tree<std::array<unsigned char,16ul>>::destroy(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t **thirdparty::quadprogpp::singleton@<X0>(thirdparty::quadprogpp *this@<X0>, uint64_t a2@<X8>)
{
  unsigned int v3 = this;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + _Block_object_dispose(&STACK[0x400], 8) = 0;
  *(void *)a2 = a2 + 8;
  return std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int const&>((uint64_t **)a2, &v3, &v3);
}

void sub_1B8A0E444(_Unwind_Exception *a1)
{
  std::__tree<std::array<unsigned char,16ul>>::destroy(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t **std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int const&>(uint64_t **a1, unsigned int *a2, _DWORD *a3)
{
  uint64_t v6 = a1 + 1;
  int v5 = a1[1];
  if (v5)
  {
    unsigned int v7 = *a2;
    while (1)
    {
      while (1)
      {
        size_t v8 = (uint64_t **)v5;
        unsigned int v9 = *((_DWORD *)v5 + 7);
        if (v7 >= v9) {
          break;
        }
        int v5 = *v8;
        uint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      int v5 = v8[1];
      if (!v5)
      {
        uint64_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    size_t v8 = a1 + 1;
LABEL_10:
    OSType v10 = (uint64_t *)operator new(0x20uLL);
    *((_DWORD *)v10 + 7) = *a3;
    _ZNSt3__16__treeINS_12__value_typeIyDv4_fEENS_19__map_value_compareIyS3_NS_4lessIyEELb1EEENS_9allocatorIS3_EEE16__insert_node_atEPNS_15__tree_end_nodeIPNS_16__tree_node_baseIPvEEEERSF_SF_(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }
  return v8;
}

void sub_1B8A0E8F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8A0F710(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15, void *a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,void *a21,void *a22,void *a23,void *a24,void *a25,void *a26,void *a27)
{
  unint64_t v30 = (void *)STACK[0x268];
  if (STACK[0x268])
  {
    STACK[0x270] = (unint64_t)v30;
    operator delete(v30);
  }

  _Unwind_Resume(a1);
}

void ARNoiseModel::~ARNoiseModel(ARNoiseModel *this)
{
  unsigned int v3 = (void **)((char *)this + 24);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v3);
  uint64_t v2 = *(void **)this;
  if (*(void *)this)
  {
    *((void *)this + 1) = v2;
    operator delete(v2);
  }
}

void ___ZL13_ARLogGeneralv_block_invoke_29()
{
  os_log_t v0 = os_log_create("com.apple.ARKit", "General");
  uint64_t v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObuint64_t j = (uint64_t)v0;
}

float std::normal_distribution<float>::operator()<std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>>(uint64_t a1, std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> *this, float *a3)
{
  if (*(unsigned char *)(a1 + 12))
  {
    *(unsigned char *)(a1 + 12) = 0;
    float v5 = *(float *)(a1 + 8);
  }
  else
  {
    do
    {
      do
      {
        float v7 = (float)((float)((float)std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(this)
                           * 2.3283e-10)
                   * 2.0)
           + -1.0;
        float v8 = (float)((float)((float)std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(this)
                           * 2.3283e-10)
                   * 2.0)
           + -1.0;
        float v9 = (float)(v8 * v8) + (float)(v7 * v7);
      }
      while (v9 > 1.0);
    }
    while (v9 == 0.0);
    float v10 = sqrtf((float)(logf((float)(v8 * v8) + (float)(v7 * v7)) * -2.0) / v9);
    *(float *)(a1 + _Block_object_dispose(&STACK[0x400], 8) = v8 * v10;
    *(unsigned char *)(a1 + 12) = 1;
    float v5 = v7 * v10;
  }
  return *a3 + (float)(v5 * a3[1]);
}

std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> *this)
{
  size_t i = this->__i_;
  size_t v2 = (i + 1) % 0x270;
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v3 = this->__x_[(i + 397) % 0x270] ^ ((this->__x_[v2] & 0x7FFFFFFE | this->__x_[i] & 0x80000000) >> 1) ^ ((int)(this->__x_[v2] << 31) >> 31) & 0x9908B0DF;
  this->__x_[i] = v3;
  this->__i_ = v2;
  LODWORD(i) = ((v3 ^ (v3 >> 11)) << 7) & 0x9D2C5680 ^ v3 ^ (v3 >> 11);
  return (i << 15) & 0xEFC60000 ^ i ^ (((i << 15) & 0xEFC60000 ^ i) >> 18);
}

void sub_1B8A10FE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

uint64_t __Block_byref_object_copy__8(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__8(uint64_t a1)
{
}

void sub_1B8A119F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void std::vector<simd_float4x4>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 6;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + _Block_object_dispose(&STACK[0x400], 8) = *(void *)a1 + (a2 << 6);
    }
  }
  else
  {
    std::vector<simd_float4x4>::__append((void **)a1, a2 - v2);
  }
}

void sub_1B8A11C54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  float v13 = v11;

  _Unwind_Resume(a1);
}

void sub_1B8A11EE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8A120E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8A121FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8A12260(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8A122C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8A12868(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32)
{
  _Unwind_Resume(a1);
}

void sub_1B8A129C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1B8A12AC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *std::vector<simd_float4x4>::__init_with_size[abi:ne180100]<simd_float4x4 const*,simd_float4x4 const*>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = std::vector<simd_float4x4>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1B8A12B90(_Unwind_Exception *exception_object)
{
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(&STACK[0x400], 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<ARSRT>::__init_with_size[abi:ne180100]<ARSRT const*,ARSRT const*>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = std::vector<ARSRT>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1B8A12C0C(_Unwind_Exception *exception_object)
{
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(&STACK[0x400], 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<simd_float4x4>::__append(void **a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  float v5 = v6;
  uint64_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 6)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), a2 << 6);
      v7 += 64 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = v7 - (unsigned char *)*a1;
    unint64_t v9 = a2 + (v8 >> 6);
    if (v9 >> 58) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 6;
    uint64_t v11 = v5 - (unsigned char *)*a1;
    if (v11 >> 5 > v9) {
      unint64_t v9 = v11 >> 5;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFC0) {
      unint64_t v12 = 0x3FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v9;
    }
    if (v12) {
      float v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<arkit::BoundingBoxGroup>>(v4, v12);
    }
    else {
      float v13 = 0;
    }
    uint64_t v14 = &v13[64 * v10];
    uint64_t v15 = &v13[64 * v12];
    bzero(v14, a2 << 6);
    unint64_t v16 = &v14[64 * a2];
    unint64_t v18 = (char *)*a1;
    double v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        long long v19 = *((_OWORD *)v17 - 4);
        long long v20 = *((_OWORD *)v17 - 3);
        long long v21 = *((_OWORD *)v17 - 1);
        *((_OWORD *)v14 - 2) = *((_OWORD *)v17 - 2);
        *((_OWORD *)v14 - 1) = v21;
        *((_OWORD *)v14 - 4) = v19;
        *((_OWORD *)v14 - 3) = v20;
        v14 -= 64;
        v17 -= 64;
      }
      while (v17 != v18);
      double v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
    {
      operator delete(v17);
    }
  }
}

char *std::vector<simd_float4x4>::__assign_with_size[abi:ne180100]<simd_float4x4*,simd_float4x4*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  unint64_t v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 6)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *uint64_t v7 = 0;
      v7[1] = 0;
      _OWORD v7[2] = 0;
    }
    if (a4 >> 58) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 5;
    if (v8 >> 5 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFC0) {
      unint64_t v11 = 0x3FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    uint64_t result = std::vector<simd_float4x4>::__vallocate[abi:ne180100](v7, v11);
    float v13 = (char *)v7[1];
    unint64_t v12 = (void **)(v7 + 1);
    unint64_t v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      unint64_t v18 = v9;
      long long v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  unint64_t v12 = (void **)(result + 8);
  uint64_t v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 6;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  unint64_t v16 = &__src[64 * v15];
  if (v14 != v9)
  {
    uint64_t result = (char *)memmove(*(void **)result, __src, v14 - v9);
    unint64_t v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    unint64_t v18 = v9;
    long long v19 = v16;
LABEL_18:
    uint64_t result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *unint64_t v12 = &v9[v17];
  return result;
}

char *std::vector<ARSRT>::__assign_with_size[abi:ne180100]<ARSRT*,ARSRT*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  unint64_t v9 = *(char **)result;
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - *(void *)result) >> 4) < a4)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *uint64_t v7 = 0;
      v7[1] = 0;
      _OWORD v7[2] = 0;
    }
    if (a4 > 0x555555555555555) {
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 4);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= a4) {
      uint64_t v11 = a4;
    }
    if (v10 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v12 = 0x555555555555555;
    }
    else {
      unint64_t v12 = v11;
    }
    uint64_t result = std::vector<ARSRT>::__vallocate[abi:ne180100](v7, v12);
    uint64_t v14 = (char *)v7[1];
    float v13 = (void **)(v7 + 1);
    unint64_t v9 = v14;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      unint64_t v18 = v9;
      long long v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  float v13 = (void **)(result + 8);
  unint64_t v15 = (unsigned char *)*((void *)result + 1);
  if (0xAAAAAAAAAAAAAAABLL * ((v15 - v9) >> 4) >= a4) {
    goto LABEL_16;
  }
  unint64_t v16 = &__src[16 * ((v15 - v9) >> 4)];
  if (v15 != v9)
  {
    uint64_t result = (char *)memmove(*(void **)result, __src, v15 - v9);
    unint64_t v9 = (char *)*v13;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    unint64_t v18 = v9;
    long long v19 = v16;
LABEL_18:
    uint64_t result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  char *v13 = &v9[v17];
  return result;
}

void ARCoreAnalyticsEventCreateAndReport(void *a1, void *a2)
{
  id v4 = a1;
  id v3 = a2;
  if (ARShouldNotReportToCoreAnalytics_onceToken != -1) {
    dispatch_once(&ARShouldNotReportToCoreAnalytics_onceToken, &__block_literal_global_126);
  }
  if (!ARShouldNotReportToCoreAnalytics_shouldNotReportToCoreAnalytics) {
    AnalyticsSendEvent();
  }
}

BOOL __ARShouldNotReportToCoreAnalytics_block_invoke()
{
  BOOL result = +[ARKitUserDefaults BOOLForKey:@"com.apple.arkit.daemonMetrics.disableReporting"];
  ARShouldNotReportToCoreAnalytics_shouldNotReportToCoreAnalytics = result;
  return result;
}

void ARLabHistogramCreate(void *a1@<X8>)
{
}

float AREarthMoversDistance(uint64_t a1, uint64_t a2, double a3, __n128 a4)
{
  uint64_t v6 = 0;
  double v84 = 0;
  float v85 = 0;
  unsigned int v86 = 0;
  float v81 = 0;
  float32x2_t v82 = 0;
  float64x2_t v83 = 0;
  std::string __p = 0;
  float v79 = 0;
  float v80 = 0;
  long long v75 = 0;
  uint64_t v76 = 0;
  uint64_t v77 = 0;
  do
  {
    for (uint64_t i = 0; i != 8; ++i)
    {
      for (uint64_t j = 0; j != 4; ++j)
      {
        float v9 = *(float *)(a1 + (j << 8) + 32 * i + 4 * v6 + 4);
        float v10 = *(float *)(a2 + (j << 8) + 32 * i + 4 * v6 + 4);
        if (v9 > 0.0 || v10 > 0.0)
        {
          double v11 = v9;
          unint64_t v12 = v85;
          if (v85 >= v86)
          {
            uint64_t v14 = v84;
            uint64_t v15 = v85 - v84;
            unint64_t v16 = v15 + 1;
            if ((unint64_t)(v15 + 1) >> 61) {
              std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v17 = (char *)v86 - (char *)v84;
            if (((char *)v86 - (char *)v84) >> 2 > v16) {
              unint64_t v16 = v17 >> 2;
            }
            if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v18 = v16;
            }
            if (v18)
            {
              long long v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>((uint64_t)&v86, v18);
              uint64_t v14 = v84;
              unint64_t v12 = v85;
            }
            else
            {
              long long v19 = 0;
            }
            long long v20 = (double *)&v19[8 * v15];
            *long long v20 = v11;
            float v13 = v20 + 1;
            while (v12 != v14)
            {
              uint64_t v21 = *((void *)v12-- - 1);
              *((void *)v20-- - 1) = v21;
            }
            double v84 = v20;
            float v85 = v13;
            unsigned int v86 = (double *)&v19[8 * v18];
            if (v14) {
              operator delete(v14);
            }
          }
          else
          {
            *float v85 = v11;
            float v13 = v12 + 1;
          }
          a4.n128_f32[0] = (float)(int)j + (float)(int)j;
          a4.n128_f32[1] = (float)(int)i;
          float v85 = v13;
          a4.n128_f32[2] = (float)(int)v6;
          double v22 = v82;
          __n128 v71 = a4;
          if (v82 >= v83)
          {
            uint64_t v24 = v82 - v81;
            if ((unint64_t)(v24 + 1) >> 60) {
              std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v25 = ((char *)v83 - (char *)v81) >> 3;
            if (v25 <= v24 + 1) {
              unint64_t v25 = v24 + 1;
            }
            if ((unint64_t)((char *)v83 - (char *)v81) >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v26 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v26 = v25;
            }
            if (v26) {
              unint64_t v27 = (char *)_ZNSt3__119__allocate_at_leastB8ne180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m((uint64_t)&v83, v26);
            }
            else {
              unint64_t v27 = 0;
            }
            uint64_t v28 = (__n128 *)&v27[16 * v24];
            *uint64_t v28 = v71;
            double v23 = v28 + 1;
            unint64_t v30 = v81;
            double v29 = v82;
            if (v82 != v81)
            {
              do
              {
                __n128 v31 = v29[-1];
                --v29;
                v28[-1] = v31;
                --v28;
              }
              while (v29 != v30);
              double v29 = v81;
            }
            float v81 = v28;
            float32x2_t v82 = v23;
            float64x2_t v83 = (__n128 *)&v27[16 * v26];
            if (v29) {
              operator delete(v29);
            }
          }
          else
          {
            __n128 *v82 = a4;
            double v23 = v22 + 1;
          }
          float32x2_t v82 = v23;
          double v32 = v10;
          vImagePixelCount v33 = v79;
          if (v79 >= v80)
          {
            unint64_t v35 = (double *)__p;
            uint64_t v36 = ((char *)v79 - (unsigned char *)__p) >> 3;
            unint64_t v37 = v36 + 1;
            if ((unint64_t)(v36 + 1) >> 61) {
              std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v38 = (char *)v80 - (unsigned char *)__p;
            if (((char *)v80 - (unsigned char *)__p) >> 2 > v37) {
              unint64_t v37 = v38 >> 2;
            }
            if ((unint64_t)v38 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v39 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v39 = v37;
            }
            if (v39)
            {
              unint64_t v40 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>((uint64_t)&v80, v39);
              unint64_t v35 = (double *)__p;
              vImagePixelCount v33 = v79;
            }
            else
            {
              unint64_t v40 = 0;
            }
            uint64_t v41 = (double *)&v40[8 * v36];
            *uint64_t v41 = v32;
            unint64_t v34 = v41 + 1;
            while (v33 != v35)
            {
              uint64_t v42 = *((void *)v33-- - 1);
              *((void *)v41-- - 1) = v42;
            }
            std::string __p = v41;
            float v79 = v34;
            float v80 = (double *)&v40[8 * v39];
            if (v35) {
              operator delete(v35);
            }
          }
          else
          {
            double *v79 = v32;
            unint64_t v34 = v33 + 1;
          }
          float v79 = v34;
          int v43 = v76;
          if (v76 >= v77)
          {
            uint64_t v45 = ((char *)v76 - (unsigned char *)v75) >> 4;
            if ((unint64_t)(v45 + 1) >> 60) {
              std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v46 = ((char *)v77 - (unsigned char *)v75) >> 3;
            if (v46 <= v45 + 1) {
              unint64_t v46 = v45 + 1;
            }
            if ((unint64_t)((char *)v77 - (unsigned char *)v75) >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v47 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v47 = v46;
            }
            if (v47) {
              long long v48 = (char *)_ZNSt3__119__allocate_at_leastB8ne180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m((uint64_t)&v77, v47);
            }
            else {
              long long v48 = 0;
            }
            long long v49 = (__n128 *)&v48[16 * v45];
            *long long v49 = v71;
            int v44 = v49 + 1;
            long long v51 = (__n128 *)v75;
            long long v50 = v76;
            if (v76 != v75)
            {
              do
              {
                __n128 v52 = v50[-1];
                --v50;
                v49[-1] = v52;
                --v49;
              }
              while (v50 != v51);
              long long v50 = (__n128 *)v75;
            }
            long long v75 = v49;
            uint64_t v76 = v44;
            uint64_t v77 = (__n128 *)&v48[16 * v47];
            if (v50) {
              operator delete(v50);
            }
          }
          else
          {
            __n128 *v76 = v71;
            int v44 = v43 + 1;
          }
          uint64_t v76 = v44;
        }
      }
    }
    ++v6;
  }
  while (v6 != 8);
  CGRect v54 = v84;
  CGRect v53 = v85;
  uint64_t v72 = 0;
  std::vector<double>::vector(v73, ((char *)v79 - (unsigned char *)__p) >> 3, &v72);
  std::vector<std::vector<double>>::vector(v74, v53 - v54, (uint64_t)v73);
  if (v73[0])
  {
    v73[1] = v73[0];
    operator delete(v73[0]);
  }
  if (v85 == v84) {
    goto LABEL_87;
  }
  uint64_t v55 = 0;
  unint64_t v56 = v85 - v84;
  int v58 = (double *)__p;
  uint64_t v57 = v79;
  unint64_t v59 = ((char *)v79 - (unsigned char *)__p) >> 3;
  int64x2_t v60 = (float32x4_t *)v81;
  uint64_t v61 = (float32x4_t *)v75;
  float32x2_t v62 = v74[0];
  if (v59 <= 1) {
    unint64_t v59 = 1;
  }
  if (v56 <= 1) {
    unint64_t v56 = 1;
  }
  do
  {
    if (v57 != v58)
    {
      int v63 = v62[3 * v55];
      __n128 v64 = v61;
      unint64_t v65 = v59;
      do
      {
        float32x4_t v66 = *v64++;
        float32x4_t v67 = vsubq_f32(v60[v55], v66);
        float32x4_t v68 = vmulq_f32(v67, v67);
        *v63++ = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v68, 2), vaddq_f32(v68, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v68.f32, 1))).f32[0]);
        --v65;
      }
      while (v65);
    }
    ++v55;
  }
  while (v55 != v56);
  if (v79 == __p) {
LABEL_87:
  }
    float v69 = INFINITY;
  else {
    float v69 = emd_hat_gd_metric<double,(FLOW_TYPE_T)0>::operator()(-1.0, (uint64_t)v73, (uint64_t)&v84, (uint64_t)&__p, v74);
  }
  v73[0] = v74;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)v73);
  if (v75)
  {
    uint64_t v76 = (__n128 *)v75;
    operator delete(v75);
  }
  if (__p)
  {
    float v79 = (double *)__p;
    operator delete(__p);
  }
  if (v81)
  {
    float32x2_t v82 = v81;
    operator delete(v81);
  }
  if (v84)
  {
    float v85 = v84;
    operator delete(v84);
  }
  return v69;
}

void sub_1B8A135C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,uint64_t a28,void *a29,uint64_t a30)
{
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a20);
  if (__p)
  {
    a27 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a29)
  {
    a30 = (uint64_t)a29;
    operator delete(a29);
  }
  double v32 = *(void **)(v30 - 152);
  if (v32)
  {
    *(void *)(v30 - 144) = v32;
    operator delete(v32);
  }
  vImagePixelCount v33 = *(void **)(v30 - 128);
  if (v33)
  {
    *(void *)(v30 - 120) = v33;
    operator delete(v33);
  }
  _Unwind_Resume(a1);
}

double emd_hat_gd_metric<double,(FLOW_TYPE_T)0>::operator()(double a1, uint64_t a2, uint64_t a3, uint64_t a4, double ***a5)
{
  double v23 = 0;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  std::vector<double>::__init_with_size[abi:ne180100]<double *,double *>(&v23, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 3);
  std::string __p = 0;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  std::vector<double>::__init_with_size[abi:ne180100]<double *,double *>(&__p, *(const void **)a4, *(void *)(a4 + 8), (uint64_t)(*(void *)(a4 + 8) - *(void *)a4) >> 3);
  float v9 = (char *)v23;
  if (v24 != v23)
  {
    uint64_t v10 = 0;
    unint64_t v11 = (v24 - (unsigned char *)v23) >> 3;
    unint64_t v12 = (double *)__p;
    if (v11 <= 1) {
      unint64_t v11 = 1;
    }
    float v13 = (double *)v23;
    do
    {
      double v14 = *v13;
      double v15 = *v12;
      if (*v13 >= *v12)
      {
        double *v13 = v14 - v15;
        unint64_t v16 = v12;
      }
      else
      {
        unint64_t v16 = (double *)&v9[8 * v10];
        *unint64_t v12 = v15 - v14;
      }
      double *v16 = 0.0;
      ++v10;
      ++v12;
      ++v13;
      --v11;
    }
    while (v11);
  }
  double v17 = emd_hat_impl<double,(FLOW_TYPE_T)0>::operator()(a1, (uint64_t)&v19, (uint64_t *)a3, (uint64_t *)a4, (uint64_t *)&v23, (uint64_t *)&__p, a5);
  if (__p)
  {
    uint64_t v21 = __p;
    operator delete(__p);
  }
  if (v23)
  {
    uint64_t v24 = v23;
    operator delete(v23);
  }
  return v17;
}

void sub_1B8A13794(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, void *a14, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  if (a14) {
    operator delete(a14);
  }
  _Unwind_Resume(exception_object);
}

float ARCubemapSimilarity(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = (void *)MEMORY[0x1F4188790](a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v10 = v9;
  id v11 = v8;
  id v12 = v10;
  float v13 = v12;
  float v14 = INFINITY;
  if (v11 && v12)
  {
    double v15 = objc_opt_new();
    unint64_t v16 = v15;
    memset(__src, 0, 512);
    if (v15)
    {
      [v15 colorHistogramForCubemap:v11];
      memset(v22, 0, 512);
      [v16 colorHistogramForCubemap:v13];
    }
    else
    {
      bzero(__src, 0x404uLL);
      bzero(v22, 0x404uLL);
    }
    memcpy(__dst, __src, sizeof(__dst));
    memcpy(v20, v22, sizeof(v20));
    float v14 = AREarthMoversDistance((uint64_t)__dst, (uint64_t)v20, v17, v18);
  }
  return v14;
}

void sub_1B8A139A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *std::vector<double>::vector(void *a1, unint64_t a2, void *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v6 = (void *)a1[1];
    uint64_t v7 = &v6[a2];
    uint64_t v8 = 8 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 8;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_1B8A13A30(_Unwind_Exception *exception_object)
{
  id v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(&STACK[0x400], 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<std::vector<double>>::vector(void *a1, unint64_t a2, uint64_t a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::vector<float>>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v6 = (void *)a1[1];
    uint64_t v7 = 3 * a2;
    uint64_t v8 = &v6[3 * a2];
    uint64_t v9 = 8 * v7;
    do
    {
      void *v6 = 0;
      v6[1] = 0;
      _OWORD v6[2] = 0;
      std::vector<double>::__init_with_size[abi:ne180100]<double *,double *>(v6, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 3);
      v6 += 3;
      v9 -= 24;
    }
    while (v9);
    a1[1] = v8;
  }
  return a1;
}

void sub_1B8A13AE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

void *std::vector<double>::__init_with_size[abi:ne180100]<double *,double *>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    BOOL result = std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      BOOL result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1B8A13B68(_Unwind_Exception *exception_object)
{
  id v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(&STACK[0x400], 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double emd_hat_impl<double,(FLOW_TYPE_T)0>::operator()(double a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, double ***a7)
{
  uint64_t v13 = a5[1] - *a5;
  std::vector<long long>::vector(v52, (int)(v13 >> 3));
  std::vector<long long>::vector(v51, (int)(v13 >> 3));
  std::vector<long long>::vector(v50, (int)(v13 >> 3));
  std::vector<long long>::vector(v49, (int)(v13 >> 3));
  std::vector<long long>::vector(__p, (int)(v13 >> 3));
  std::vector<std::vector<long long>>::vector(v48, (int)(v13 >> 3), (uint64_t)__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  std::vector<long long>::vector(v46, (int)(v13 >> 3));
  std::vector<std::vector<long long>>::vector(__p, (int)(v13 >> 3), (uint64_t)v46);
  if (v46[0])
  {
    v46[1] = v46[0];
    operator delete(v46[0]);
  }
  float v14 = *a7;
  double v15 = ***a7;
  if ((int)((unint64_t)v13 >> 3) <= 0)
  {
    double v25 = 0.0;
    double v26 = INFINITY;
    double v18 = 0.0;
    double v19 = 0.0;
    double v36 = 1000000.0 / v15;
  }
  else
  {
    uint64_t v16 = 0;
    uint64_t v17 = ((unint64_t)v13 >> 3);
    double v18 = 0.0;
    double v19 = 0.0;
    do
    {
      double v18 = v18 + *(double *)(*a3 + 8 * v16);
      double v19 = v19 + *(double *)(*a4 + 8 * v16);
      long long v20 = v14[3 * v16];
      uint64_t v21 = ((unint64_t)v13 >> 3);
      do
      {
        double v22 = *v20++;
        double v23 = v22;
        if (v22 > v15) {
          double v15 = v23;
        }
        --v21;
      }
      while (v21);
      ++v16;
    }
    while (v16 != v17);
    uint64_t v24 = 0;
    if (v18 >= v19) {
      double v25 = v18;
    }
    else {
      double v25 = v19;
    }
    double v26 = 1000000.0 / v25;
    uint64_t v27 = *a3;
    uint64_t v28 = v52[0];
    uint64_t v29 = *a4;
    uint64_t v30 = v51[0];
    uint64_t v31 = *a5;
    double v32 = v50[0];
    uint64_t v33 = *a6;
    unint64_t v34 = v49[0];
    uint64_t v35 = v48[0];
    double v36 = 1000000.0 / v15;
    do
    {
      v28[v24] = vcvtmd_s64_f64(*(double *)(v27 + 8 * v24) * v26 + 0.5);
      v30[v24] = vcvtmd_s64_f64(*(double *)(v29 + 8 * v24) * v26 + 0.5);
      v32[v24] = vcvtmd_s64_f64(*(double *)(v31 + 8 * v24) * v26 + 0.5);
      v34[v24] = vcvtmd_s64_f64(*(double *)(v33 + 8 * v24) * v26 + 0.5);
      unint64_t v37 = v14[3 * v24];
      uint64_t v38 = *(void **)(v35 + 24 * v24);
      uint64_t v39 = ((unint64_t)v13 >> 3);
      do
      {
        double v40 = *v37++;
        *v38++ = vcvtmd_s64_f64(v40 * v36 + 0.5);
        --v39;
      }
      while (v39);
      ++v24;
    }
    while (v24 != v17);
  }
  uint64_t v41 = emd_hat_impl_integral_types<long long,(FLOW_TYPE_T)0>::operator()((uint64_t)&v53, (uint64_t)v52, (uint64_t)v51, (uint64_t)v50, (uint64_t)v49, v48, 0);
  v46[0] = __p;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)v46);
  __p[0] = v48;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
  if (v49[0])
  {
    v49[1] = v49[0];
    operator delete(v49[0]);
  }
  if (v50[0])
  {
    v50[1] = v50[0];
    operator delete(v50[0]);
  }
  if (v51[0])
  {
    v51[1] = v51[0];
    operator delete(v51[0]);
  }
  if (v52[0])
  {
    v52[1] = v52[0];
    operator delete(v52[0]);
  }
  if (v19 >= v18) {
    double v42 = v18;
  }
  else {
    double v42 = v19;
  }
  double v43 = v25 - v42;
  if (a1 == -1.0) {
    double v44 = v15;
  }
  else {
    double v44 = a1;
  }
  return (double)v41 / v26 / v36 + v43 * v44;
}

void sub_1B8A13E88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, char *a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28)
{
  a12 = &a15;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  if (__p)
  {
    a19 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a21)
  {
    a22 = (uint64_t)a21;
    operator delete(a21);
  }
  if (a24)
  {
    a25 = (uint64_t)a24;
    operator delete(a24);
  }
  if (a27)
  {
    a28 = (uint64_t)a27;
    operator delete(a27);
  }
  _Unwind_Resume(a1);
}

void *std::vector<long long>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__vallocate[abi:ne180100](a1, a2);
    id v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_1B8A13FA4(_Unwind_Exception *exception_object)
{
  id v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(&STACK[0x400], 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<std::vector<long long>>::vector(void *a1, unint64_t a2, uint64_t a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::vector<float>>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v6 = (void *)a1[1];
    uint64_t v7 = 3 * a2;
    size_t v8 = &v6[3 * a2];
    uint64_t v9 = 8 * v7;
    do
    {
      void *v6 = 0;
      v6[1] = 0;
      _OWORD v6[2] = 0;
      std::vector<long long>::__init_with_size[abi:ne180100]<long long *,long long *>(v6, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 3);
      v6 += 3;
      v9 -= 24;
    }
    while (v9);
    a1[1] = v8;
  }
  return a1;
}

void sub_1B8A1405C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

void *std::vector<long long>::__init_with_size[abi:ne180100]<long long *,long long *>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    BOOL result = std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      BOOL result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1B8A140DC(_Unwind_Exception *exception_object)
{
  id v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(&STACK[0x400], 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t emd_hat_impl_integral_types<long long,(FLOW_TYPE_T)0>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t a7)
{
  unint64_t v7 = *(void *)(a4 + 8) - *(void *)a4;
  uint64_t v8 = (int)((uint64_t)v7 >> 3);
  if (v8 != (uint64_t)(*(void *)(a5 + 8) - *(void *)a5) >> 3) {
    emd_hat_impl_integral_types<long long,(FLOW_TYPE_T)0>::operator()();
  }
  __n128 v184 = 0;
  long long v185 = 0;
  uint64_t v186 = 0;
  int v181 = 0;
  uint64_t v182 = 0;
  uint64_t v183 = 0;
  memset(v180, 0, sizeof(v180));
  std::vector<std::vector<long long>>::__init_with_size[abi:ne180100]<std::vector<long long>*,std::vector<long long>*>(v180, *a6, a6[1], 0xAAAAAAAAAAAAAAABLL * ((a6[1] - *a6) >> 3));
  unint64_t v12 = v7 >> 3;
  uint64_t v13 = (v7 >> 3);
  if ((int)(v7 >> 3) < 1)
  {
    uint64_t v18 = 0;
    uint64_t v14 = 0;
  }
  else
  {
    uint64_t v14 = 0;
    double v15 = *(uint64_t **)a4;
    uint64_t v16 = v13;
    do
    {
      uint64_t v17 = *v15++;
      v14 += v17;
      --v16;
    }
    while (v16);
    uint64_t v18 = 0;
    double v19 = *(uint64_t **)a5;
    uint64_t v20 = v13;
    do
    {
      uint64_t v21 = *v19++;
      v18 += v21;
      --v20;
    }
    while (v20);
    if (v18 > v14)
    {
      if (&v184 != (uint64_t **)a5) {
        std::vector<unsigned long>::__assign_with_size[abi:ne180100]<unsigned long *,unsigned long *>((char *)&v184, *(char **)a5, *(void *)(a5 + 8), (uint64_t)(*(void *)(a5 + 8) - *(void *)a5) >> 3);
      }
      if (&v181 != (uint64_t **)a4) {
        std::vector<unsigned long>::__assign_with_size[abi:ne180100]<unsigned long *,unsigned long *>((char *)&v181, *(char **)a4, *(void *)(a4 + 8), (uint64_t)(*(void *)(a4 + 8) - *(void *)a4) >> 3);
      }
      uint64_t v22 = 0;
      uint64_t v23 = *a6;
      uint64_t v24 = v180[0];
      uint64_t v25 = v18 - v14;
      do
      {
        double v26 = *(void **)(v24 + 24 * v22);
        uint64_t v27 = v13;
        uint64_t v28 = (uint64_t *)v23;
        do
        {
          uint64_t v29 = *v28;
          v28 += 3;
          *v26++ = *(void *)(v29 + 8 * v22);
          --v27;
        }
        while (v27);
        ++v22;
      }
      while (v22 != v13);
      goto LABEL_23;
    }
  }
  if (&v184 != (uint64_t **)a4) {
    std::vector<unsigned long>::__assign_with_size[abi:ne180100]<unsigned long *,unsigned long *>((char *)&v184, *(char **)a4, *(void *)(a4 + 8), (uint64_t)(*(void *)(a4 + 8) - *(void *)a4) >> 3);
  }
  if (&v181 != (uint64_t **)a5) {
    std::vector<unsigned long>::__assign_with_size[abi:ne180100]<unsigned long *,unsigned long *>((char *)&v181, *(char **)a5, *(void *)(a5 + 8), (uint64_t)(*(void *)(a5 + 8) - *(void *)a5) >> 3);
  }
  uint64_t v25 = v14 - v18;
LABEL_23:
  int v30 = 2 * v12;
  std::vector<long long>::vector(&v178, 2 * (int)v12 + 2);
  int v31 = (2 * v12) | 1;
  double v32 = v178;
  if ((int)v12 >= 1)
  {
    uint64_t v33 = v184;
    uint64_t v34 = v13;
    uint64_t v35 = v178;
    do
    {
      uint64_t v36 = *v33++;
      *v35++ = v36;
      --v34;
    }
    while (v34);
  }
  if (v30 <= (int)v12)
  {
    uint64_t v38 = v30;
  }
  else
  {
    unint64_t v37 = v181;
    uint64_t v38 = v30;
    uint64_t v39 = &v32[v8];
    uint64_t v40 = v30 - v8;
    do
    {
      uint64_t v41 = *v37++;
      *v39++ = v41;
      --v40;
    }
    while (v40);
  }
  uint64_t v157 = v38;
  v32[v38] = -v25;
  v32[v31] = 0;
  if ((int)v12 < 1)
  {
    uint64_t v43 = 0;
  }
  else
  {
    uint64_t v42 = 0;
    uint64_t v43 = 0;
    do
    {
      double v44 = *(uint64_t **)(v180[0] + 24 * v42);
      uint64_t v45 = v13;
      do
      {
        uint64_t v47 = *v44++;
        uint64_t v46 = v47;
        if (v47 < 0) {
          __assert_rtn("operator()", "emd_hat_impl.hpp", 154, "C[i][j]>=0");
        }
        if (v46 > v43) {
          uint64_t v43 = v46;
        }
        --v45;
      }
      while (v45);
      ++v42;
    }
    while (v42 != v13);
  }
  v177[0] = 0;
  v177[1] = 0;
  int v155 = 2 * v12;
  v175[1] = 0;
  int v176 = (uint64_t *)v177;
  __n128 v174 = (uint64_t *)v175;
  v175[0] = 0;
  std::vector<std::list<edge<long long>>>::vector(&v172, (v179 - (unsigned char *)v32) >> 3);
  uint64_t v153 = v25;
  if ((int)v12 > 0)
  {
    int v159 = v12;
    int v152 = v30 | 1;
    uint64_t v48 = 0;
    long long v49 = v178;
    do
    {
      if (v49[v48])
      {
        uint64_t v50 = 0;
        long long v51 = (void *)(v180[0] + 24 * v48);
        __n128 v52 = (uint64_t *)&v172[24 * v48];
        do
        {
          if (v49[v8 + v50])
          {
            uint64_t v53 = *(void *)(*v51 + 8 * v50);
            if (v53 != v43)
            {
              CGRect v54 = operator new(0x20uLL);
              _OWORD v54[4] = v8 + v50;
              *((void *)v54 + 3) = v53;
              *((void *)v54 + 1) = v52;
              uint64_t v55 = *v52;
              *(void *)CGRect v54 = *v52;
              *(void *)(v55 + _Block_object_dispose(&STACK[0x400], 8) = v54;
              *__n128 v52 = (uint64_t)v54;
              ++v52[2];
            }
          }
          ++v50;
        }
        while (v13 != v50);
      }
      ++v48;
    }
    while (v48 != v13);
    int v56 = 0;
    LODWORD(v162) = 0;
    int v31 = v152;
    LODWORD(v12) = v159;
    do
    {
      if (v178[v56])
      {
        uint64_t v57 = 0;
        uint64_t v58 = v8;
        do
        {
          if (v178[v58] && *(void *)(*(void *)(v180[0] + 24 * (int)v162) + v57) != v43)
          {
            std::__tree<int>::__emplace_unique_key_args<int,int const&>(&v176, (int *)&v162, &v162);
            LODWORD(v170.__begin_) = v58;
            std::__tree<int>::__emplace_unique_key_args<int,int const&>(&v174, (int *)&v170, &v170);
          }
          ++v58;
          v57 += 8;
        }
        while (8 * v13 != v57);
        int v56 = (int)v162;
        LODWORD(v12) = v159;
      }
      LODWORD(v162) = ++v56;
    }
    while (v56 < (int)v12);
  }
  if (v155 > (int)v12)
  {
    unint64_t v59 = &v178[v8];
    uint64_t v60 = v157 - v8;
    do
    {
      *unint64_t v59 = -*v59;
      ++v59;
      --v60;
    }
    while (v60);
  }
  if ((int)v12 >= 1)
  {
    uint64_t v61 = v172;
    do
    {
      float32x2_t v62 = operator new(0x20uLL);
      v62[4] = v155;
      *((void *)v62 + 3) = 0;
      *((void *)v62 + 1) = v61;
      uint64_t v63 = *(void *)v61;
      *(void *)float32x2_t v62 = *(void *)v61;
      *(void *)(v63 + _Block_object_dispose(&STACK[0x400], 8) = v62;
      *(void *)uint64_t v61 = v62;
      ++*((void *)v61 + 2);
      v61 += 24;
      --v13;
    }
    while (v13);
    int v64 = 0;
    unint64_t v65 = (uint64_t *)&v172[24 * (int)v157];
    do
    {
      float32x4_t v66 = operator new(0x20uLL);
      v66[4] = v12 + v64;
      *((void *)v66 + 3) = v43;
      *((void *)v66 + 1) = v65;
      uint64_t v67 = *v65;
      *(void *)float32x4_t v66 = *v65;
      *(void *)(v67 + _Block_object_dispose(&STACK[0x400], 8) = v66;
      *unint64_t v65 = (uint64_t)v66;
      ++v65[2];
      ++v64;
    }
    while (v12 != v64);
  }
  if ((v12 & 0x80000000) == 0)
  {
    uint64_t v68 = 0;
    float v69 = v172;
    uint64_t v70 = v43 + 1;
    __n128 v71 = (uint64_t *)&v172[24 * v31];
    if (v31 <= 1) {
      uint64_t v72 = 1;
    }
    else {
      uint64_t v72 = v31;
    }
    do
    {
      unint64_t v73 = operator new(0x20uLL);
      v73[4] = v31;
      *((void *)v73 + 3) = v70;
      *((void *)v73 + 1) = v69;
      uint64_t v74 = *(void *)v69;
      *(void *)unint64_t v73 = *(void *)v69;
      *(void *)(v74 + _Block_object_dispose(&STACK[0x400], 8) = v73;
      *(void *)float v69 = v73;
      ++*((void *)v69 + 2);
      long long v75 = operator new(0x20uLL);
      v75[4] = v68;
      *((void *)v75 + 3) = v70;
      *((void *)v75 + 1) = v71;
      uint64_t v76 = *v71;
      *(void *)long long v75 = *v71;
      *(void *)(v76 + _Block_object_dispose(&STACK[0x400], 8) = v75;
      *__n128 v71 = (uint64_t)v75;
      ++v71[2];
      ++v68;
      v69 += 24;
    }
    while (v72 != v68);
  }
  __double x = -1;
  std::vector<int>::vector(&v170, (v179 - (unsigned char *)v178) >> 3, &__x);
  memset(&v169, 0, sizeof(v169));
  std::vector<int>::reserve(&v169, (v179 - (unsigned char *)v178) >> 3);
  if ((int)v12 < 1)
  {
    uint64_t v79 = 0;
    int v78 = 0;
  }
  else
  {
    uint64_t v77 = 0;
    int v78 = 0;
    uint64_t v79 = 0;
    if (v155 <= 1) {
      uint64_t v80 = 1;
    }
    else {
      uint64_t v80 = v155;
    }
    do
    {
      uint64_t v81 = v178[v77];
      if (v81)
      {
        float32x2_t v82 = v177[0];
        if (v177[0])
        {
          float64x2_t v83 = v177;
          do
          {
            double v84 = v82;
            float v85 = v83;
            uint64_t v86 = *((int *)v82 + 7);
            long long v87 = v82 + 1;
            if (v77 <= v86)
            {
              long long v87 = v84;
              float64x2_t v83 = (void **)v84;
            }
            float32x2_t v82 = (void *)*v87;
          }
          while (v82);
          if (v83 != v177)
          {
            if (v77 > v86) {
              double v84 = v85;
            }
            if (v77 >= *((int *)v84 + 7)) {
              goto LABEL_98;
            }
          }
        }
        uint64_t v88 = v175[0];
        if (!v175[0]) {
          goto LABEL_95;
        }
        float v89 = v175;
        do
        {
          float32x4_t v90 = v88;
          double v91 = v89;
          uint64_t v92 = *((int *)v88 + 7);
          double v93 = v88 + 1;
          if (v77 <= v92)
          {
            double v93 = v90;
            float v89 = (void **)v90;
          }
          uint64_t v88 = (void *)*v93;
        }
        while (v88);
        if (v89 == v175) {
          goto LABEL_95;
        }
        if (v77 > v92) {
          float32x4_t v90 = v91;
        }
        if (v77 >= *((int *)v90 + 7))
        {
LABEL_98:
          v170.__begin_[v77] = v78;
          std::vector<int>::pointer end = v169.__end_;
          if (v169.__end_ >= v169.__end_cap_.__value_)
          {
            std::vector<int>::pointer begin = v169.__begin_;
            int64_t v98 = v169.__end_ - v169.__begin_;
            unint64_t v99 = v98 + 1;
            if ((unint64_t)(v98 + 1) >> 62) {
              std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
            }
            int64_t v100 = (char *)v169.__end_cap_.__value_ - (char *)v169.__begin_;
            if (((char *)v169.__end_cap_.__value_ - (char *)v169.__begin_) >> 1 > v99) {
              unint64_t v99 = v100 >> 1;
            }
            if ((unint64_t)v100 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v101 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v101 = v99;
            }
            if (v101)
            {
              uint64_t v102 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v169.__end_cap_, v101);
              std::vector<int>::pointer begin = v169.__begin_;
              std::vector<int>::pointer end = v169.__end_;
            }
            else
            {
              uint64_t v102 = 0;
            }
            uint64_t v103 = (int *)&v102[4 * v98];
            *uint64_t v103 = v77;
            float v96 = v103 + 1;
            while (end != begin)
            {
              int v104 = *--end;
              *--uint64_t v103 = v104;
            }
            v169.__begin_ = v103;
            v169.__end_ = v96;
            v169.__end_cap_.__value_ = (int *)&v102[4 * v101];
            if (begin) {
              operator delete(begin);
            }
          }
          else
          {
            *v169.__end_ = v77;
            float v96 = end + 1;
          }
          v169.__end_ = v96;
          ++v78;
        }
        else
        {
LABEL_95:
          uint64_t v94 = v81 * v43;
          if (v77 < v8) {
            uint64_t v94 = 0;
          }
          v79 -= v94;
          v178[v157] += v81;
        }
      }
      ++v77;
    }
    while (v77 != v80);
  }
  v170.__begin_[v157] = v78;
  std::vector<int>::pointer v106 = v169.__end_;
  value = v169.__end_cap_.__value_;
  if (v169.__end_ >= v169.__end_cap_.__value_)
  {
    std::vector<int>::pointer v108 = v169.__begin_;
    int64_t v109 = v169.__end_ - v169.__begin_;
    unint64_t v110 = v109 + 1;
    if ((unint64_t)(v109 + 1) >> 62) {
      goto LABEL_195;
    }
    int64_t v111 = (char *)v169.__end_cap_.__value_ - (char *)v169.__begin_;
    if (((char *)v169.__end_cap_.__value_ - (char *)v169.__begin_) >> 1 > v110) {
      unint64_t v110 = v111 >> 1;
    }
    if ((unint64_t)v111 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v112 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v112 = v110;
    }
    if (v112)
    {
      uint64_t v113 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v169.__end_cap_, v112);
      std::vector<int>::pointer v108 = v169.__begin_;
      std::vector<int>::pointer v106 = v169.__end_;
    }
    else
    {
      uint64_t v113 = 0;
    }
    __n128 v114 = (int *)&v113[4 * v109];
    value = (int *)&v113[4 * v112];
    *__n128 v114 = v155;
    uint64_t v107 = v114 + 1;
    while (v106 != v108)
    {
      int v115 = *--v106;
      *--__n128 v114 = v115;
    }
    v169.__begin_ = v114;
    v169.__end_ = v107;
    v169.__end_cap_.__value_ = value;
    if (v108)
    {
      operator delete(v108);
      value = v169.__end_cap_.__value_;
    }
  }
  else
  {
    *v169.__end_ = v155;
    uint64_t v107 = v106 + 1;
  }
  v169.__end_ = v107;
  v170.__begin_[v31] = v78 + 1;
  if (v107 < value)
  {
    int *v107 = v31;
    int v116 = v107 + 1;
    goto LABEL_151;
  }
  std::vector<int>::pointer v117 = v169.__begin_;
  uint64_t v118 = v107 - v169.__begin_;
  unint64_t v119 = v118 + 1;
  if ((unint64_t)(v118 + 1) >> 62) {
LABEL_195:
  }
    std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
  uint64_t v120 = (char *)value - (char *)v169.__begin_;
  if (v120 >> 1 > v119) {
    unint64_t v119 = v120 >> 1;
  }
  if ((unint64_t)v120 >= 0x7FFFFFFFFFFFFFFCLL) {
    unint64_t v121 = 0x3FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v121 = v119;
  }
  if (v121)
  {
    uint64_t v122 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v169.__end_cap_, v121);
    std::vector<int>::pointer v117 = v169.__begin_;
    uint64_t v107 = v169.__end_;
  }
  else
  {
    uint64_t v122 = 0;
  }
  v123 = (int *)&v122[4 * v118];
  __n128 v124 = (int *)&v122[4 * v121];
  int *v123 = v31;
  int v116 = v123 + 1;
  while (v107 != v117)
  {
    int v125 = *--v107;
    *--v123 = v125;
  }
  v169.__begin_ = v123;
  v169.__end_ = v116;
  v169.__end_cap_.__value_ = v124;
  if (v117) {
    operator delete(v117);
  }
LABEL_151:
  v169.__end_ = v116;
  std::vector<long long>::vector(&v167, v78 + 2);
  int v126 = v178;
  uint64_t v127 = v167;
  if (v179 != (unsigned char *)v178)
  {
    int v128 = 0;
    unint64_t v129 = (v179 - (unsigned char *)v178) >> 3;
    std::vector<int>::pointer v130 = v170.__begin_;
    if (v129 <= 1) {
      unint64_t v129 = 1;
    }
    do
    {
      int v131 = *v130++;
      if (v131 != -1) {
        v127[v128++] = *v126;
      }
      ++v126;
      --v129;
    }
    while (v129);
    uint64_t v127 = v167;
  }
  uint64_t v156 = v79;
  std::vector<std::list<edge<long long>>>::vector(v166, (v168 - (unsigned char *)v127) >> 3);
  unint64_t v158 = v172;
  if (v173 != v172)
  {
    uint64_t v132 = 0;
    unint64_t v133 = (v173 - v172) / 24;
    std::vector<int>::pointer v134 = v170.__begin_;
    if (v133 <= 1) {
      unint64_t v133 = 1;
    }
    unint64_t v160 = v133;
    do
    {
      if (v134[v132] != -1)
      {
        long long v135 = &v158[24 * v132];
        uint64_t v136 = *((void *)v135 + 1);
        if ((char *)v136 != v135)
        {
          uint64_t v137 = v166[0];
          do
          {
            int v138 = v134[*(int *)(v136 + 16)];
            if (v138 != -1)
            {
              int v139 = v134[v132];
              uint64_t v140 = *(void *)(v136 + 24);
              int v141 = operator new(0x20uLL);
              uint64_t v142 = (uint64_t *)(v137 + 24 * v139);
              v141[4] = v138;
              *((void *)v141 + 3) = v140;
              *((void *)v141 + 1) = v142;
              uint64_t v143 = *v142;
              *(void *)int v141 = *v142;
              *(void *)(v143 + _Block_object_dispose(&STACK[0x400], 8) = v141;
              *uint64_t v142 = (uint64_t)v141;
              ++v142[2];
            }
            uint64_t v136 = *(void *)(v136 + 8);
          }
          while ((char *)v136 != v135);
        }
      }
      ++v132;
    }
    while (v132 != v160);
  }
  __n128 v144 = (uint64_t *)v167;
  unint64_t v145 = (v168 - (unsigned char *)v167) >> 3;
  if (v168 != v167)
  {
    uint64_t v146 = 0;
    uint64_t v147 = v145 <= 1 ? 1 : (v168 - (unsigned char *)v167) >> 3;
    do
    {
      uint64_t v148 = *v144++;
      v146 += v148;
      --v147;
    }
    while (v147);
    if (v146) {
      __assert_rtn("operator()", "emd_hat_impl.hpp", 277, "DEBUG_sum_bb==0");
    }
  }
  std::string __p = 0;
  __n128 v164 = 0;
  uint64_t v165 = 0;
  std::vector<std::list<edge0<long long>>>::vector(v161, v145);
  uint64_t v149 = min_cost_flow<long long>::operator()((unsigned int *)&v162, (uint64_t *)&v167, v166, v161);
  uint64_t v187 = (void **)v161;
  std::vector<std::list<edge<long long>>>::__destroy_vector::operator()[abi:ne180100](&v187);
  if (__p)
  {
    __n128 v164 = __p;
    operator delete(__p);
  }
  uint64_t v162 = (char **)v166;
  std::vector<std::list<edge<long long>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v162);
  if (v167)
  {
    uint64_t v168 = v167;
    operator delete(v167);
  }
  if (v169.__begin_)
  {
    v169.__end_ = v169.__begin_;
    operator delete(v169.__begin_);
  }
  if (v170.__begin_)
  {
    v170.__end_ = v170.__begin_;
    operator delete(v170.__begin_);
  }
  uint64_t v162 = &v172;
  std::vector<std::list<edge<long long>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v162);
  std::__tree<std::array<unsigned char,16ul>>::destroy((uint64_t)&v174, v175[0]);
  std::__tree<std::array<unsigned char,16ul>>::destroy((uint64_t)&v176, v177[0]);
  if (v178)
  {
    __n128 v179 = v178;
    operator delete(v178);
  }
  uint64_t v162 = (char **)v180;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v162);
  if (v181)
  {
    uint64_t v182 = v181;
    operator delete(v181);
  }
  if (v184)
  {
    long long v185 = v184;
    operator delete(v184);
  }
  uint64_t v150 = a7;
  if (a7 == -1) {
    uint64_t v150 = v43;
  }
  return v156 + v150 * v153 + v149;
}

void sub_1B8A14CC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char *a21,void *__p,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38)
{
  *(void *)(v39 - 96) = v38;
  std::vector<std::list<edge<long long>>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v39 - 96));
  if (__p)
  {
    a23 = (uint64_t)__p;
    operator delete(__p);
  }
  a21 = &a25;
  std::vector<std::list<edge<long long>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a21);
  if (a28)
  {
    a29 = (uint64_t)a28;
    operator delete(a28);
  }
  if (a31)
  {
    a32 = (uint64_t)a31;
    operator delete(a31);
  }
  if (a34)
  {
    a35 = (uint64_t)a34;
    operator delete(a34);
  }
  a21 = &a38;
  std::vector<std::list<edge<long long>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a21);
  std::__tree<std::array<unsigned char,16ul>>::destroy(v39 - 240, *(void **)(v39 - 232));
  std::__tree<std::array<unsigned char,16ul>>::destroy(v39 - 216, *(void **)(v39 - 208));
  uint64_t v41 = *(void **)(v39 - 192);
  if (v41)
  {
    *(void *)(v39 - 184) = v41;
    operator delete(v41);
  }
  a21 = (char *)(v39 - 168);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a21);
  uint64_t v42 = *(void **)(v39 - 144);
  if (v42)
  {
    *(void *)(v39 - 136) = v42;
    operator delete(v42);
  }
  uint64_t v43 = *(void **)(v39 - 120);
  if (v43)
  {
    *(void *)(v39 - 112) = v43;
    operator delete(v43);
  }
  _Unwind_Resume(a1);
}

uint64_t min_cost_flow<long long>::operator()(unsigned int *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v4 = a2[1] - *a2;
  if (v4 >> 3 != 0xAAAAAAAAAAAAAAABLL * ((a3[1] - *a3) >> 3)) {
    min_cost_flow<long long>::operator()();
  }
  if (0xAAAAAAAAAAAAAAABLL * ((a4[1] - *a4) >> 3) != v4 >> 3) {
    min_cost_flow<long long>::operator()();
  }
  *a1 = (unint64_t)v4 >> 3;
  std::vector<int>::resize((std::vector<int> *)(a1 + 2), (int)(v4 >> 3));
  uint64_t v70 = (int *)a1;
  uint64_t v6 = *a1;
  if ((int)v6 >= 1)
  {
    uint64_t v7 = 0;
    uint64_t v8 = *a3;
    uint64_t v9 = *a4;
    do
    {
      uint64_t v10 = v8 + 24 * v7;
      uint64_t v11 = *(void *)(v10 + 8);
      if (v11 != v10)
      {
        unint64_t v12 = (uint64_t *)(v9 + 24 * v7);
        do
        {
          int v13 = *(_DWORD *)(v11 + 16);
          uint64_t v14 = *(void *)(v11 + 24);
          double v15 = operator new(0x28uLL);
          v15[4] = v13;
          *((void *)v15 + 3) = v14;
          *((void *)v15 + 4) = 0;
          *((void *)v15 + 1) = v12;
          uint64_t v16 = *v12;
          *(void *)double v15 = *v12;
          *(void *)(v16 + _Block_object_dispose(&STACK[0x400], 8) = v15;
          *unint64_t v12 = (uint64_t)v15;
          ++v12[2];
          uint64_t v17 = (uint64_t *)(v9 + 24 * *(int *)(v11 + 16));
          uint64_t v18 = -*(void *)(v11 + 24);
          double v19 = operator new(0x28uLL);
          _OWORD v19[4] = v7;
          *((void *)v19 + 3) = v18;
          *((void *)v19 + 4) = 0;
          *((void *)v19 + 1) = v17;
          uint64_t v20 = *v17;
          *(void *)double v19 = *v17;
          *(void *)(v20 + _Block_object_dispose(&STACK[0x400], 8) = v19;
          *uint64_t v17 = (uint64_t)v19;
          ++v17[2];
          uint64_t v11 = *(void *)(v11 + 8);
        }
        while (v11 != v10);
      }
      ++v7;
    }
    while (v7 != v6);
  }
  std::vector<std::list<edge1<long long>>>::vector(v75, (int)v6);
  uint64_t v21 = *v70;
  if ((int)v21 >= 1)
  {
    uint64_t v22 = 0;
    uint64_t v23 = *a3;
    uint64_t v24 = v75[0];
    do
    {
      uint64_t v25 = v23 + 24 * v22;
      uint64_t v26 = *(void *)(v25 + 8);
      if (v26 != v25)
      {
        uint64_t v27 = (uint64_t *)(v24 + 24 * v22);
        do
        {
          int v28 = *(_DWORD *)(v26 + 16);
          uint64_t v29 = *(void *)(v26 + 24);
          int v30 = operator new(0x20uLL);
          v30[4] = v28;
          *((void *)v30 + 3) = v29;
          *((void *)v30 + 1) = v27;
          uint64_t v31 = *v27;
          *(void *)int v30 = *v27;
          *(void *)(v31 + _Block_object_dispose(&STACK[0x400], 8) = v30;
          uint64_t *v27 = (uint64_t)v30;
          ++v27[2];
          uint64_t v26 = *(void *)(v26 + 8);
        }
        while (v26 != v25);
      }
      ++v22;
    }
    while (v22 != v21);
  }
  std::vector<std::list<edge2<long long>>>::vector(v74, (int)v21);
  uint64_t v32 = *v70;
  if ((int)v32 >= 1)
  {
    uint64_t v33 = 0;
    uint64_t v34 = *a3;
    uint64_t v35 = v74[0];
    do
    {
      uint64_t v36 = v34 + 24 * v33;
      for (uint64_t i = *(void *)(v36 + 8); i != v36; uint64_t i = *(void *)(i + 8))
      {
        int v38 = *(_DWORD *)(i + 16);
        uint64_t v39 = *(void *)(i + 24);
        uint64_t v40 = operator new(0x28uLL);
        uint64_t v41 = &v35[3 * v38];
        v40[4] = v33;
        *((void *)v40 + 3) = -v39;
        *((void *)v40 + 4) = 0;
        *((void *)v40 + 1) = v41;
        uint64_t v42 = *v41;
        *(void *)uint64_t v40 = *v41;
        v42[1] = v40;
        *uint64_t v41 = v40;
        v41[2] = (char *)v41[2] + 1;
      }
      ++v33;
    }
    while (v33 != v32);
  }
  std::vector<long long>::vector(__p, (int)v32);
  std::vector<int>::vector(&v72, *v70);
  uint64_t v43 = *v70;
  if ((int)v43 < 1)
  {
LABEL_49:
    uint64_t v62 = 0;
  }
  else
  {
    while (1)
    {
      uint64_t v44 = 0;
      int v45 = 0;
      uint64_t v46 = 0;
      do
      {
        if (*(void *)(*a2 + 8 * v44) > 0 && v46 < *(void *)(*a2 + 8 * v44))
        {
          uint64_t v46 = *(void *)(*a2 + 8 * v44);
          int v45 = v44;
        }
        ++v44;
      }
      while (v43 != v44);
      if (!v46) {
        break;
      }
      int v71 = 0;
      min_cost_flow<long long>::compute_shortest_path(v70, (uint64_t *)__p, &v72, v45, v75, (uint64_t *)v74, a2, &v71);
      int v47 = v71;
      std::vector<int>::pointer begin = v72.__begin_;
      long long v49 = v74[0];
      int v50 = v71;
      do
      {
        int v51 = v72.__begin_[v50];
        if (v51 == v50) {
          __assert_rtn("operator()", "min_cost_flow.hpp", 167, "from!=to");
        }
        __n128 v52 = &v74[0][3 * v51];
        while (1)
        {
          __n128 v52 = (void **)v52[1];
          if (v52 == &v74[0][3 * v51]) {
            break;
          }
          if (*((_DWORD *)v52 + 4) == v50)
          {
            if ((uint64_t)v52[4] < v46) {
              uint64_t v46 = (uint64_t)v52[4];
            }
            break;
          }
        }
        int v50 = v72.__begin_[v50];
      }
      while (v51 != v45);
      uint64_t v53 = *a4;
      uint64_t v54 = *a2;
      do
      {
        int v55 = begin[v47];
        if (v55 == v47) {
          __assert_rtn("operator()", "min_cost_flow.hpp", 187, "from!=to");
        }
        uint64_t v56 = v47;
        int v47 = begin[v47];
        uint64_t v57 = v53 + 24 * v55 + 8;
        do
        {
          uint64_t v58 = *(void *)v57;
          int v59 = *(_DWORD *)(*(void *)v57 + 16);
          uint64_t v57 = *(void *)v57 + 8;
        }
        while (v59 != v56);
        *(void *)(v58 + 32) += v46;
        uint64_t v60 = &v49[3 * (int)v56];
        while (1)
        {
          uint64_t v60 = (void **)v60[1];
          if (v60 == &v49[3 * (int)v56]) {
            break;
          }
          if (*((_DWORD *)v60 + 4) == v55)
          {
            v60[4] = (char *)v60[4] + v46;
            break;
          }
        }
        uint64_t v61 = &v49[3 * v55];
        while (1)
        {
          uint64_t v61 = (void **)v61[1];
          if (v61 == &v49[3 * v55]) {
            break;
          }
          if (*((_DWORD *)v61 + 4) == v56)
          {
            v61[4] = (char *)v61[4] - v46;
            break;
          }
        }
        *(void *)(v54 + 8 * v56) += v46;
        *(void *)(v54 + 8 * v55) -= v46;
      }
      while (v55 != v45);
      uint64_t v43 = *v70;
      if ((int)v43 <= 0) {
        goto LABEL_49;
      }
    }
    uint64_t v63 = 0;
    uint64_t v62 = 0;
    do
    {
      uint64_t v64 = *a4 + 24 * v63;
      for (uint64_t j = *(void **)(v64 + 8); j != (void *)v64; uint64_t j = (void *)j[1])
        v62 += j[4] * j[3];
      ++v63;
    }
    while (v63 != v43);
  }
  if (v72.__begin_)
  {
    v72.__end_ = v72.__begin_;
    operator delete(v72.__begin_);
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  __p[0] = v74;
  std::vector<std::list<edge<long long>>>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
  v74[0] = (void **)v75;
  std::vector<std::list<edge<long long>>>::__destroy_vector::operator()[abi:ne180100](v74);
  return v62;
}

void sub_1B8A15334(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t *__p, uint64_t *a19, uint64_t a20,uint64_t a21)
{
  if (__p)
  {
    a19 = __p;
    operator delete(__p);
  }
  std::string __p = &a21;
  std::vector<std::list<edge<long long>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  a21 = v21 - 104;
  std::vector<std::list<edge<long long>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a21);
  _Unwind_Resume(a1);
}

void *std::vector<std::vector<long long>>::__init_with_size[abi:ne180100]<std::vector<long long>*,std::vector<long long>*>(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    std::vector<std::vector<float>>::__vallocate[abi:ne180100](result, a4);
    BOOL result = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<long long>>,std::vector<long long>*,std::vector<long long>*,std::vector<long long>*>((uint64_t)(v6 + 2), a2, a3, (void *)v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_1B8A15410(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + _Block_object_dispose(&STACK[0x400], 8) = v10;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

void *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<long long>>,std::vector<long long>*,std::vector<long long>*,std::vector<long long>*>(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v4 = a4;
  uint64_t v10 = a4;
  uint64_t v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  char v9 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      *uint64_t v4 = 0;
      v4[1] = 0;
      _DWORD v4[2] = 0;
      std::vector<long long>::__init_with_size[abi:ne180100]<long long *,long long *>(v4, *(const void **)v6, *(void *)(v6 + 8), (uint64_t)(*(void *)(v6 + 8) - *(void *)v6) >> 3);
      uint64_t v4 = v11 + 3;
      v11 += 3;
      v6 += 24;
    }
    while (v6 != a3);
  }
  char v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<long long>>,std::vector<long long>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v8);
  return v4;
}

void sub_1B8A154D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<long long>>,std::vector<long long>*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::vector<float>*>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void *std::vector<std::list<edge<long long>>>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::vector<float>>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v4 = (void *)a1[1];
    float v5 = &v4[3 * a2];
    do
    {
      *uint64_t v4 = v4;
      v4[1] = v4;
      _DWORD v4[2] = 0;
      v4 += 3;
    }
    while (v4 != v5);
    a1[1] = v5;
  }
  return a1;
}

void sub_1B8A1558C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

void std::vector<std::list<edge<long long>>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = v1[1];
    float v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        std::__list_imp<edge<long long>>::clear(v4);
      }
      while (v4 != v2);
      float v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *std::__list_imp<edge<long long>>::clear(void *result)
{
  if (result[2])
  {
    uint64_t v1 = result;
    BOOL result = (void *)result[1];
    uint64_t v2 = *v1;
    uint64_t v3 = *result;
    *(void *)(v3 + _Block_object_dispose(&STACK[0x400], 8) = *(void *)(*v1 + 8);
    **(void **)(v2 + _Block_object_dispose(&STACK[0x400], 8) = v3;
    v1[2] = 0;
    if (result != v1)
    {
      do
      {
        uint64_t v4 = (void *)result[1];
        operator delete(result);
        BOOL result = v4;
      }
      while (v4 != v1);
    }
  }
  return result;
}

uint64_t **std::__tree<int>::__emplace_unique_key_args<int,int const&>(uint64_t **a1, int *a2, _DWORD *a3)
{
  uint64_t v6 = a1 + 1;
  float v5 = a1[1];
  if (v5)
  {
    int v7 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v8 = (uint64_t **)v5;
        int v9 = *((_DWORD *)v5 + 7);
        if (v7 >= v9) {
          break;
        }
        float v5 = *v8;
        uint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      float v5 = v8[1];
      if (!v5)
      {
        uint64_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v8 = a1 + 1;
LABEL_10:
    uint64_t v10 = (uint64_t *)operator new(0x20uLL);
    *((_DWORD *)v10 + 7) = *a3;
    _ZNSt3__16__treeINS_12__value_typeIyDv4_fEENS_19__map_value_compareIyS3_NS_4lessIyEELb1EEENS_9allocatorIS3_EEE16__insert_node_atEPNS_15__tree_end_nodeIPNS_16__tree_node_baseIPvEEEERSF_SF_(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }
  return v8;
}

std::vector<int> *__cdecl std::vector<int>::vector(std::vector<int> *this, std::vector<int>::size_type __n, const std::vector<int>::value_type *__x)
{
  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  if (__n)
  {
    std::vector<float>::__vallocate[abi:ne180100](this, __n);
    std::vector<int>::pointer end = this->__end_;
    int v7 = &end[__n];
    std::vector<int>::size_type v8 = 4 * __n;
    do
    {
      *end++ = *__x;
      v8 -= 4;
    }
    while (v8);
    this->__end_ = v7;
  }
  return this;
}

void sub_1B8A157AC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(&STACK[0x400], 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<std::list<edge0<long long>>>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::vector<float>>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v4 = (void *)a1[1];
    float v5 = &v4[3 * a2];
    do
    {
      *uint64_t v4 = v4;
      v4[1] = v4;
      _DWORD v4[2] = 0;
      v4 += 3;
    }
    while (v4 != v5);
    a1[1] = v5;
  }
  return a1;
}

void sub_1B8A15838(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

void min_cost_flow<long long>::compute_shortest_path(int *a1, uint64_t *a2, void *a3, int a4, uint64_t *a5, uint64_t *a6, void *a7, int *a8)
{
  std::vector<edge3<long long>>::vector(&__p, *a1);
  int v13 = __p;
  *(_DWORD *)std::string __p = a4;
  double v15 = a1 + 2;
  uint64_t v14 = *((void *)a1 + 1);
  *(_DWORD *)(v14 + 4 * a4) = 0;
  v13[1] = 0;
  if (a4 < 1)
  {
    uint64_t v19 = 1;
  }
  else
  {
    uint64_t v16 = 0;
    uint64_t v17 = v13 + 3;
    do
    {
      *((_DWORD *)v17 - 2) = v16;
      uint64_t v18 = v16 + 1;
      *(_DWORD *)(v14 + 4 * v16) = v16 + 1;
      *uint64_t v17 = 0x7FFFFFFFFFFFFFFFLL;
      v17 += 2;
      uint64_t v16 = v18;
    }
    while (a4 != v18);
    uint64_t v19 = v18 + 1;
  }
  LODWORD(v20) = a4 + 1;
  int64_t v21 = *a1;
  if (a4 + 1 < (int)v21)
  {
    int64_t v20 = (int)v20;
    uint64_t v22 = &v13[2 * v19 + 1];
    do
    {
      *((_DWORD *)v22 - 2) = v20;
      *(_DWORD *)(v14 + 4 * v20) = v19;
      *uint64_t v22 = 0x7FFFFFFFFFFFFFFFLL;
      v22 += 2;
      ++v20;
      int64_t v21 = *a1;
      LODWORD(v19) = v19 + 1;
    }
    while (v20 < v21);
  }
  __double x = 0;
  std::vector<int>::vector(&v61, v21, &__x);
  uint64_t v23 = __p;
  while (1)
  {
    int v24 = *(_DWORD *)v23;
    *(void *)(*a2 + 8 * v24) = v23[1];
    v61.__begin_[v24] = 1;
    if ((*(void *)(*a7 + 8 * v24) & 0x8000000000000000) != 0) {
      break;
    }
    min_cost_flow<long long>::heap_remove_first((uint64_t)a1, (uint64_t *)&__p, (uint64_t *)a1 + 1);
    uint64_t v25 = *a5;
    uint64_t v26 = *a5 + 24 * v24;
    uint64_t v27 = *(void *)(v26 + 8);
    while (v27 != v26)
    {
      uint64_t v28 = *(void *)(v27 + 24);
      if (v28 < 0) {
        __assert_rtn("compute_shortest_path", "min_cost_flow.hpp", 318, "it->_reduced_cost>=0");
      }
      uint64_t v29 = *(int *)(v27 + 16);
      unint64_t v30 = *(int *)(*v15 + 4 * v29);
      if (v30 < (v63 - (unsigned char *)__p) >> 4)
      {
        uint64_t v31 = *(void *)(*a2 + 8 * v24) + v28;
        if (v31 < *((void *)__p + 2 * v30 + 1))
        {
          min_cost_flow<long long>::heap_decrease_key((uint64_t)a1, (uint64_t *)&__p, (uint64_t *)a1 + 1, *(_DWORD *)(v27 + 16), v31);
          *(_DWORD *)(*a3 + 4 * v29) = v24;
          uint64_t v25 = *a5;
        }
      }
      uint64_t v27 = *(void *)(v27 + 8);
      uint64_t v26 = v25 + 24 * v24;
    }
    uint64_t v32 = *a6;
    uint64_t v33 = *a6 + 24 * v24;
    uint64_t v34 = *(void *)(v33 + 8);
    while (v34 != v33)
    {
      if (*(uint64_t *)(v34 + 32) >= 1)
      {
        uint64_t v35 = *(void *)(v34 + 24);
        if (v35 < 0) {
          __assert_rtn("compute_shortest_path", "min_cost_flow.hpp", 329, "it->_reduced_cost>=0");
        }
        uint64_t v36 = *(int *)(v34 + 16);
        unint64_t v37 = *(int *)(*v15 + 4 * v36);
        if (v37 < (v63 - (unsigned char *)__p) >> 4)
        {
          uint64_t v38 = *(void *)(*a2 + 8 * v24) + v35;
          if (v38 < *((void *)__p + 2 * v37 + 1))
          {
            min_cost_flow<long long>::heap_decrease_key((uint64_t)a1, (uint64_t *)&__p, (uint64_t *)a1 + 1, *(_DWORD *)(v34 + 16), v38);
            *(_DWORD *)(*a3 + 4 * v36) = v24;
            uint64_t v32 = *a6;
          }
        }
      }
      uint64_t v34 = *(void *)(v34 + 8);
      uint64_t v33 = v32 + 24 * v24;
    }
    uint64_t v23 = __p;
    if (__p == v63) {
      goto LABEL_29;
    }
  }
  *a8 = v24;
LABEL_29:
  uint64_t v39 = *a1;
  std::vector<int>::pointer begin = v61.__begin_;
  if ((int)v39 >= 1)
  {
    uint64_t v41 = 0;
    uint64_t v42 = *a5;
    do
    {
      uint64_t v43 = v42 + 24 * v41;
      uint64_t v44 = *(void *)(v43 + 8);
      if (v44 != v43)
      {
        int v45 = begin[v41];
        uint64_t v46 = *a2;
        uint64_t v47 = *a8;
        do
        {
          if (v45) {
            *(void *)(v44 + 24) += *(void *)(v46 + 8 * v41) - *(void *)(v46 + 8 * v47);
          }
          uint64_t v48 = *(int *)(v44 + 16);
          if (begin[v48]) {
            *(void *)(v44 + 24) += *(void *)(v46 + 8 * v47) - *(void *)(v46 + 8 * v48);
          }
          uint64_t v44 = *(void *)(v44 + 8);
        }
        while (v44 != v43);
      }
      ++v41;
    }
    while (v41 != v39);
    uint64_t v49 = 0;
    uint64_t v50 = *a6;
    do
    {
      uint64_t v51 = v50 + 24 * v49;
      uint64_t v52 = *(void *)(v51 + 8);
      if (v52 != v51)
      {
        int v53 = begin[v49];
        uint64_t v54 = *a2;
        uint64_t v55 = *a8;
        do
        {
          if (v53) {
            *(void *)(v52 + 24) += *(void *)(v54 + 8 * v49) - *(void *)(v54 + 8 * v55);
          }
          uint64_t v56 = *(int *)(v52 + 16);
          if (begin[v56]) {
            *(void *)(v52 + 24) += *(void *)(v54 + 8 * v55) - *(void *)(v54 + 8 * v56);
          }
          uint64_t v52 = *(void *)(v52 + 8);
        }
        while (v52 != v51);
      }
      ++v49;
    }
    while (v49 != v39);
  }
  if (begin)
  {
    v61.__end_ = begin;
    operator delete(begin);
    uint64_t v23 = __p;
  }
  if (v23)
  {
    uint64_t v63 = v23;
    operator delete(v23);
  }
}

void sub_1B8A15C54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<std::list<edge1<long long>>>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::vector<float>>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v4 = (void *)a1[1];
    float v5 = &v4[3 * a2];
    do
    {
      *uint64_t v4 = v4;
      v4[1] = v4;
      _DWORD v4[2] = 0;
      v4 += 3;
    }
    while (v4 != v5);
    a1[1] = v5;
  }
  return a1;
}

void sub_1B8A15D08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

void *std::vector<std::list<edge2<long long>>>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::vector<float>>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v4 = (void *)a1[1];
    float v5 = &v4[3 * a2];
    do
    {
      *uint64_t v4 = v4;
      v4[1] = v4;
      _DWORD v4[2] = 0;
      v4 += 3;
    }
    while (v4 != v5);
    a1[1] = v5;
  }
  return a1;
}

void sub_1B8A15D8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

std::vector<int> *__cdecl std::vector<int>::vector(std::vector<int> *this, std::vector<int>::size_type __n)
{
  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  if (__n)
  {
    std::vector<float>::__vallocate[abi:ne180100](this, __n);
    std::vector<int>::pointer end = this->__end_;
    bzero(end, 4 * __n);
    this->__end_ = &end[__n];
  }
  return this;
}

void sub_1B8A15DFC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(&STACK[0x400], 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

__n128 min_cost_flow<long long>::heap_remove_first(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  int v3 = ((unint64_t)(a2[1] - *a2) >> 4) - 1;
  long long v4 = *(_OWORD *)*a2;
  *(_OWORD *)*a2 = *(_OWORD *)(*a2 + 16 * v3);
  *(_OWORD *)(*a2 + 16 * v3) = v4;
  float v5 = (_OWORD *)*a2;
  uint64_t v6 = *a3;
  *(_DWORD *)(*a3 + 4 * *(int *)(*a2 + 16 * v3)) = v3;
  *(_DWORD *)(v6 + 4 * *(int *)v5) = 0;
  a2[1] -= 16;
  min_cost_flow<long long>::heapify(a1, a2, a3, 0);
  return result;
}

__n128 min_cost_flow<long long>::heap_decrease_key(uint64_t a1, uint64_t *a2, uint64_t *a3, int a4, uint64_t a5)
{
  uint64_t v5 = *(int *)(*a3 + 4 * a4);
  uint64_t v6 = *a2;
  *(void *)(*a2 + 16 * v5 + _Block_object_dispose(&STACK[0x400], 8) = a5;
  if ((int)v5 >= 1)
  {
    do
    {
      unsigned int v7 = v5 - 1;
      uint64_t v8 = (v5 - 1) >> 1;
      if (*(void *)(v6 + 16 * v8 + 8) <= *(void *)(v6 + 16 * v5 + 8)) {
        break;
      }
      __n128 result = *(__n128 *)(v6 + 16 * v5);
      *(_OWORD *)(v6 + 16 * v5) = *(_OWORD *)(v6 + 16 * v8);
      *(__n128 *)(*a2 + 16 * v_Block_object_dispose(&STACK[0x400], 8) = result;
      uint64_t v6 = *a2;
      uint64_t v10 = *a3;
      *(_DWORD *)(*a3 + 4 * *(int *)(*a2 + 16 * v8)) = v8;
      *(_DWORD *)(v10 + 4 * *(int *)(v6 + 16 * v5)) = v5;
      LODWORD(v5) = v7 >> 1;
    }
    while (v7 > 1);
  }
  return result;
}

void *std::vector<edge3<long long>>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE11__vallocateB8ne180100Em(a1, a2);
    uint64_t v4 = a1[1];
    uint64_t v5 = v4 + 16 * a2;
    do
    {
      *(_DWORD *)uint64_t v4 = 0;
      *(void *)(v4 + _Block_object_dispose(&STACK[0x400], 8) = 0;
      v4 += 16;
    }
    while (v4 != v5);
    a1[1] = v5;
  }
  return a1;
}

void sub_1B8A15F5C(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(&STACK[0x400], 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void min_cost_flow<long long>::heapify(uint64_t a1, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4 = *a2;
  while (1)
  {
    unint64_t v5 = (2 * (int)a4) | 1;
    unint64_t v6 = (a2[1] - v4) >> 4;
    if (v6 <= v5 || *(void *)(v4 + 16 * v5 + 8) >= *(void *)(v4 + 16 * (int)a4 + 8)) {
      unint64_t v5 = a4;
    }
    unsigned int v7 = 2 * a4 + 2;
    if (v6 > (int)v7)
    {
      if (*(void *)(v4 + 16 * (int)v7 + 8) >= *(void *)(v4 + 16 * (int)v5 + 8)) {
        unint64_t v5 = v5;
      }
      else {
        unint64_t v5 = v7;
      }
    }
    if (v5 == a4) {
      break;
    }
    long long v8 = *(_OWORD *)(v4 + 16 * (int)a4);
    *(_OWORD *)(v4 + 16 * (int)a4) = *(_OWORD *)(v4 + 16 * (int)v5);
    *(_OWORD *)(*a2 + 16 * (int)v5) = v8;
    uint64_t v4 = *a2;
    uint64_t v9 = *a3;
    *(_DWORD *)(*a3 + 4 * *(int *)(*a2 + 16 * (int)v5)) = v5;
    *(_DWORD *)(v9 + 4 * *(int *)(v4 + 16 * (int)a4)) = a4;
    a4 = v5;
  }
}

BOOL ARCheckConfidenceJasper(float a1)
{
  return a1 > 0.8;
}

void __getARDaemonClass_block_invoke_cold_1()
{
  uint64_t v0 = abort_report_np();
  __getARDaemonReplayBlockDelegateClass_block_invoke_cold_1(v0);
}

void __getARDaemonReplayBlockDelegateClass_block_invoke_cold_1()
{
  uint64_t v0 = abort_report_np();
  -[ARImageBasedTechnique getDeviceOrientationFromImageData:](v0);
}

void cnmatrix::CNMatrixBase<double>::operator=()
{
  __assert_rtn("operator=", "cnmatrixbase.h", 619, "this->max_num_rows_ >= A.num_rows_");
}

{
  __assert_rtn("operator=", "cnmatrixbase.h", 620, "this->max_num_cols_ >= A.num_cols_");
}

void cnmatrix::CNMatrix<3u,3u,double>::TransposeDataFootprint()
{
  __assert_rtn("TransposeDataFootprint", "cnmatrix.h", 122, "scratch != nullptr");
}

{
  __assert_rtn("TransposeDataFootprint", "cnmatrix.h", 128, "lead_dim > 0");
}

void cnmatrix::CNMatrixBase<double>::operator()()
{
  __assert_rtn("operator()", "cnmatrixbase.h", 782, "data_ != __null");
}

{
  __assert_rtn("operator()", "cnmatrixbase.h", 783, "idx >= 0");
}

{
  __assert_rtn("operator()", "cnmatrixbase.h", 784, "idx < num_elements_");
}

void ARC3DShapeTriangulationCheckConsistency_cold_1()
{
  __assert_rtn("ARC3DShapeTriangulationCheckConsistency", "ARC3DShapeTriangulation.m", 194, "neighborB != t");
}

void ARC3DShapeTriangulationCheckConsistency_cold_2()
{
  __assert_rtn("ARC3DShapeTriangulationCheckConsistency", "ARC3DShapeTriangulation.m", 195, "neighborB != UNDEFINED_NEIGHBOR");
}

void ARC3DShapeTriangulationCheckConsistency_cold_3()
{
  __assert_rtn("ARC3DShapeTriangulationCheckConsistency", "ARC3DShapeTriangulation.m", 215, "t->constrain[j] == false");
}

void ARC3DShapeTriangulationCheckConsistency_cold_4()
{
  __assert_rtn("ARC3DShapeTriangulationCheckConsistency", "ARC3DShapeTriangulation.m", 214, "neighborCount == 0");
}

void ARC3DShapeTriangulationCheckConsistency_cold_5()
{
  __assert_rtn("ARC3DShapeTriangulationCheckConsistency", "ARC3DShapeTriangulation.m", 219, "neighborA->constrain[link] == t->constrain[j]");
}

void ARC3DShapeTriangulationCheckConsistency_cold_6()
{
  __assert_rtn("ARC3DShapeTriangulationCheckConsistency", "ARC3DShapeTriangulation.m", 218, "neighborA->neighbors[link] == t");
}

void ARC3DShapeTriangulationCheckConsistency_cold_7()
{
  __assert_rtn("ARC3DShapeTriangulationCheckConsistency", "ARC3DShapeTriangulation.m", 217, "neighborCount == 1");
}

void ARC3DShapeTriangulationCheckConsistency_cold_8()
{
  __assert_rtn("ARC3DShapeTriangulationCheckConsistency", "ARC3DShapeTriangulation.m", 211, "neighborA == neighborB");
}

void ARC3DLinkIndexFromTriangleToTriangle_cold_1()
{
}

void ARC3DVertexNotSharedByTriangles_cold_1()
{
}

void ARC3DVertexNotSharedByTriangles_cold_2()
{
}

void ARC3DShapeConnectedComponentTriangulatePseudopolygon_cold_1()
{
}

void ARC3DShapeTriangulationAddEdge_cold_1()
{
  __assert_rtn("ARC3DShapeTriangulationAddEdge", "ARC3DShapeTriangulation.m", 898, "recycledTriangles.count == 0");
}

void arkit::ExponentialSmoother<float>::step()
{
  __assert_rtn("step", "ExponentialSmoother.h", 66, "0.f < targetAlpha && targetAlpha <= 1.f");
}

{
  __assert_rtn("step", "ExponentialSmoother.h", 68, "0.f < samplingInterval");
}

{
  __assert_rtn("step", "ExponentialSmoother.h", 69, "0.f < targetSamplingInterval");
}

void ar_rt_ring_buffer_init_cold_1()
{
  uint64_t v0 = __realtime_assert_rtn();
  ar_rt_ring_buffer_reset_cold_1(v0);
}

void ar_rt_ring_buffer_reset_cold_1()
{
  uint64_t v0 = __realtime_assert_rtn();
  ar_rt_ring_buffer_empty_cold_1(v0);
}

void ar_rt_ring_buffer_empty_cold_1()
{
}

void ar_rt_ring_buffer_increment_index_cold_1()
{
  uint64_t v0 = __realtime_assert_rtn();
  ar_rt_ring_buffer_decrement_index_cold_1(v0);
}

void ar_rt_ring_buffer_decrement_index_cold_1()
{
}

void ar_rt_ring_buffer_add_element_cold_1()
{
  uint64_t v0 = __realtime_assert_rtn();
  ar_rt_ring_buffer_filled_cold_1(v0);
}

void ar_rt_ring_buffer_filled_cold_1()
{
  uint64_t v0 = __realtime_assert_rtn();
  ARAnchorsFromCV3DAnchorsArray_cold_1(v0);
}

void ARAnchorsFromCV3DAnchorsArray_cold_1(__n128 *a1, __n128 *a2, __n128 *a3, __n128 *a4)
{
  uint64_t v4 = NSString;
  unint64_t v5 = ARMatrix4x4Description(1, *a1, *a2, *a3, *a4);
  unint64_t v6 = [v4 stringWithFormat:@"SLAM returned invalid anchor pose %@", v5];
  id v7 = [v4 stringWithFormat:@"ARCrash: %@", v6];
  qword_1E9EECB28 = (uint64_t)strdup((const char *)[v7 UTF8String]);

  abort();
}

void HeadingFromRot()
{
}

void arkit::gaussianKernel()
{
}

{
  __assert_rtn("gaussianKernel", "ARNoiseKernels.cpp", 25, "kernelSize % 2 == 1");
}

void arkit::unflatten()
{
  __assert_rtn("unflatten", "ARNoiseKernels.cpp", 48, "c*n == src.size()");
}

{
  __assert_rtn("unflatten", "ARNoiseKernels.cpp", 67, "k*c*n == src.size()");
}

void arkit::sum()
{
  __assert_rtn("sum", "ARNoiseKernels.cpp", 83, "dim == 0 || dim == 1");
}

void arkit::unflattenParams()
{
  __assert_rtn("unflattenParams", "ARNoiseKernels.cpp", 185, "wk_flat.size() == vk_flat.size()");
}

{
  __assert_rtn("unflattenParams", "ARNoiseKernels.cpp", 184, "wk_flat.size()/c % n == 0");
}

{
  __assert_rtn("unflattenParams", "ARNoiseKernels.cpp", 183, "wk_flat.size()/n % c == 0");
}

{
  __assert_rtn("unflattenParams", "ARNoiseKernels.cpp", 182, "vp_flat.size() % n == 0");
}

void arkit::loadParams()
{
}

void cva::MatrixRef<float,3u,3u,false>::operator=<cva::MatrixTransposeExpr<cva::MatrixRef<float const,3u,3u,false>>>()
{
}

void ARConsensusAndAverageFilterImpl::GetInliers()
{
}

void ARC3DComputeLinesIntersection_cold_1()
{
  __assert_rtn("ARC3DComputeLinesIntersection", "ARC3DShapeUtils.m", 35, "denom != 0");
}

void ARC3DComputeLinesIntersectionForPoints_cold_1()
{
  __assert_rtn("ARC3DComputeLinesIntersectionForPoints", "ARC3DShapeUtils.m", 46, "denom != 0");
}

void ARNeutralBodySkeleton3DModelTransforms_cold_1()
{
  __assert_rtn("ARNeutralBodySkeleton3DModelTransforms", "ARRigDependencyData.mm", 821, "dataVector.size() == OUTPUT_JOINT_COUNT");
}

void ARNeutralBodySkeleton3DLocalTransforms_cold_1()
{
  __assert_rtn("ARNeutralBodySkeleton3DLocalTransforms", "ARRigDependencyData.mm", 1285, "dataVector.size() == OUTPUT_JOINT_COUNT");
}

void cva::MatrixData<float,0ul,0ul,false>::allocate()
{
}

{
  __assert_rtn("allocate", "matrixdata.h", 479, "(!m_data) || cva::detail::assertMessage(\"No matrix data must be allocated.\")");
}

void GetConfidenceFromUncertainty()
{
  __assert_rtn("GetConfidenceFromUncertainty", "ARSceneReconstructionHandler.mm", 39, "(confidence >= 0.f) && (confidence <= 1.f)");
}

void arkit::FaceLightOptimizer::solveQuadratic()
{
  __assert_rtn("solveQuadratic", "FaceLightOptimizer.cpp", 68, "luminances.rows() == rtf.rows()");
}

void arkit::FaceLightOptimizer::inlierSet()
{
  __assert_rtn("inlierSet", "FaceLightOptimizer.cpp", 214, "thresh >= 0");
}

void arkit::FaceLightOptimizer::solveLinear()
{
  __assert_rtn("solveLinear", "FaceLightOptimizer.cpp", 179, "luminances.rows() == rtf.rows()");
}

void cva::SVD<cva::Matrix<float,0u,0u,false>,true>::inverse()
{
  __assert_rtn("MatrixMultExpr", "matrixmultexpr.h", 100, "((lhs.ref().columns() == rhs.ref().rows())) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
}

void arkit::FaceLightOptimizer::penaltyFunction()
{
  __assert_rtn("penaltyFunction", "FaceLightOptimizer.cpp", 200, "luminances.rows() == rtf.rows()");
}

void std::pair<cva::Matrix<float,9u,1u,false>,float>::pair[abi:ne180100]<cva::Matrix<float,0u,1u,false> &,float const&,0>()
{
  __assert_rtn("MatrixSize", "matrixsize.h", 36, "(ROWS == rows && COLS == cols) || cva::detail::assertMessage(\"Row and column values and templates need to be the same.\")");
}

{
  __assert_rtn("MatrixData", "matrixdata.h", 96, "(size == sz) || cva::detail::assertMessage(\"Matrix data size mismatch.\")");
}

void cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>()
{
  __assert_rtn("assert_equal_size", "matrixfun.h", 163, "(lhs.rows() == rhs.rows() && lhs.columns() == rhs.columns()) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
}

void cva::SVD<cva::Matrix<float,0u,0u,false>,true>::decomposeDirect<0u,0u>()
{
  __assert_rtn("decomposeDirect", "matrixsvd.h", 433, "(info == 0) || cva::detail::assertMessage(\"gesvd() query workspace size failed!\")");
}

void cva::SVD<cva::Matrix<float,0u,0u,false>,true>::S()
{
  __assert_rtn("VectorAsDiagonalExpr", "vectorasdiagexpr.h", 211, "(std::min(rows, cols) <= vector.elements()) || cva::detail::assertMessage(\"The matrix can't be in both dimensions larger than its diagonal.\")");
}

void cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>>,cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>>()
{
  __assert_rtn("assert_in_bounds", "matrixmixin.h", 2252, "((row + nRows <= mixed().rows()) && (col + nCols <= mixed().columns())) || cva::detail::assertMessage(\"Index out of bounds!\")");
}

void cva::detail::assignNoAlias<cva::Matrix<float,0u,0u,false>,cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>,cva::detail::MulOp>>()
{
}

void arkit::wrap()
{
  __assert_rtn("wrap", "ImageHelpers.cpp", 15, "format == kCVPixelFormatType_420YpCbCr8BiPlanarFullRange");
}

void arkit::ImageViewYUV::at()
{
}

{
  __assert_rtn("operator()", "arrayview.h", 321, "((x < size(0)) && (y < size(1))) || cva::detail::assertMessage(\"Index out of bounds!\")");
}

void arkit::FacialLightEstimation::populateValidImageSamples()
{
}

void cva::Matrix<float,0u,1u,false>::conservativeResize()
{
}

void std::__optional_copy_base<std::string const,false>::__optional_copy_base[abi:ne180100](uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
}

void cva::Array<cva::Matrix<unsigned char,4u,1u,false>,2u,16u>::allocate()
{
  __assert_rtn("allocate", "array.h", 257, "(nullptr != ptr) || cva::detail::assertMessage(\"Out of memory!\")");
}

void cva::ArrayIterator<float,2u>::increment()
{
  __assert_rtn("increment", "arrayiterator.h", 103, "(m_ptr != nullptr) || cva::detail::assertMessage(\"Cannot increment empty iterator\")");
}

void emd_hat_impl_integral_types<long long,(FLOW_TYPE_T)0>::operator()()
{
  __assert_rtn("operator()", "emd_hat_impl.hpp", 100, "Qc.size()==N");
}

void min_cost_flow<long long>::operator()()
{
  __assert_rtn("operator()", "min_cost_flow.hpp", 89, "x.size()==c.size()");
}

{
  __assert_rtn("operator()", "min_cost_flow.hpp", 88, "e.size()==c.size()");
}

uint64_t AVCaptureSessionSetAuthorizedToUseCameraInMultipleForegroundAppLayout()
{
  return MEMORY[0x1F40D0E90]();
}

uint64_t AnalyticsSendEvent()
{
  return MEMORY[0x1F41138A0]();
}

uint64_t AnalyticsSendEventLazy()
{
  return MEMORY[0x1F41138B8]();
}

uint64_t AppC3DConfigCreate()
{
  return MEMORY[0x1F4108838]();
}

uint64_t AppC3DConfigRelease()
{
  return MEMORY[0x1F4108840]();
}

uint64_t AppC3DConfigSetMaxNumberCodesToTrack()
{
  return MEMORY[0x1F4108850]();
}

uint64_t AppC3DConfigSetTrackingConfig()
{
  return MEMORY[0x1F4108858]();
}

uint64_t AppC3DConfigSetTrackingMode()
{
  return MEMORY[0x1F4108860]();
}

uint64_t AppC3DCreate()
{
  return MEMORY[0x1F4108868]();
}

uint64_t AppC3DProcess()
{
  return MEMORY[0x1F4108878]();
}

uint64_t AppC3DProcessCameraFrameData()
{
  return MEMORY[0x1F4108880]();
}

uint64_t AppC3DRelease()
{
  return MEMORY[0x1F4108888]();
}

uint64_t AppC3DSetPerformanceMode()
{
  return MEMORY[0x1F4108890]();
}

uint64_t AppC3DSetUpdateCallback()
{
  return MEMORY[0x1F4108898]();
}

uint64_t AppC3DTrackingResultCopyTransform()
{
  return MEMORY[0x1F41088A0]();
}

uint64_t AppC3DTrackingResultCreateData()
{
  return MEMORY[0x1F41088B0]();
}

uint64_t AppC3DTrackingResultGetConfidence()
{
  return MEMORY[0x1F41088B8]();
}

uint64_t AppC3DTrackingResultGetDataVersion()
{
  return MEMORY[0x1F41088C0]();
}

uint64_t AppC3DTrackingResultGetId()
{
  return MEMORY[0x1F41088C8]();
}

uint64_t AppC3DTrackingResultGetMetadata()
{
  return MEMORY[0x1F41088D0]();
}

uint64_t AppC3DTrackingResultGetNumberOfTrackingData()
{
  return MEMORY[0x1F41088D8]();
}

uint64_t AppC3DTrackingResultGetSize()
{
  return MEMORY[0x1F41088E0]();
}

uint64_t AppC3DTrackingResultIsScaleReliable()
{
  return MEMORY[0x1F41088E8]();
}

CFTimeInterval CACurrentMediaTime(void)
{
  MEMORY[0x1F40F4A90]();
  return result;
}

unsigned __int8 *__cdecl CC_SHA1(const void *data, CC_LONG len, unsigned __int8 *md)
{
  return (unsigned __int8 *)MEMORY[0x1F40C9730](data, *(void *)&len, md);
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  MEMORY[0x1F40D70A8]();
  return result;
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x1F40D7190](allocator, capacity, callBacks);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x1F40D71B8](theArray);
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x1F40D71F0](theArray, idx);
}

void CFArrayRemoveValueAtIndex(CFMutableArrayRef theArray, CFIndex idx)
{
}

CFStringRef CFCopyDescription(CFTypeRef cf)
{
  return (CFStringRef)MEMORY[0x1F40D77A8](cf);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x1F40D7830](theData);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x1F40D7850](theData);
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x1F40D7978](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x1F40D7998](allocator, capacity, keyCallBacks, valueCallBacks);
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x1F40D7A10](theDict, key);
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

CFStringRef CFErrorCopyDescription(CFErrorRef err)
{
  return (CFStringRef)MEMORY[0x1F40D7A80](err);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x1F40D7B80](cf);
}

CFNotificationCenterRef CFNotificationCenterGetDarwinNotifyCenter(void)
{
  return (CFNotificationCenterRef)MEMORY[0x1F40D7D08]();
}

void CFNotificationCenterPostNotification(CFNotificationCenterRef center, CFNotificationName name, const void *object, CFDictionaryRef userInfo, Boolean deliverImmediately)
{
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x1F40D7D80](allocator, theType, valuePtr);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x1F40D7E10]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x1F40D7E20](number, theType, valuePtr);
}

void CFRelease(CFTypeRef cf)
{
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x1F40D8048](cf);
}

void CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFRunLoopMode mode)
{
}

void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
}

CFRunLoopRef CFRunLoopGetCurrent(void)
{
  return (CFRunLoopRef)MEMORY[0x1F40D80B0]();
}

CFRunLoopObserverRef CFRunLoopObserverCreateWithHandler(CFAllocatorRef allocator, CFOptionFlags activities, Boolean repeats, CFIndex order, void *block)
{
  return (CFRunLoopObserverRef)MEMORY[0x1F40D80E0](allocator, activities, repeats, order, block);
}

void CFRunLoopPerformBlock(CFRunLoopRef rl, CFTypeRef mode, void *block)
{
}

void CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFRunLoopMode mode)
{
}

void CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
}

void CFRunLoopRun(void)
{
}

CFRunLoopSourceRef CFRunLoopSourceCreate(CFAllocatorRef allocator, CFIndex order, CFRunLoopSourceContext *context)
{
  return (CFRunLoopSourceRef)MEMORY[0x1F40D8140](allocator, order, context);
}

void CFRunLoopStop(CFRunLoopRef rl)
{
}

void CFRunLoopWakeUp(CFRunLoopRef rl)
{
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1F40D8448](alloc, cStr, *(void *)&encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x1F40D8520](theString, *(void *)&encoding);
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x1F40D85F0]();
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1F40D88A0](allocator, filePath, pathStyle, isDirectory);
}

CFUUIDRef CFUUIDCreate(CFAllocatorRef alloc)
{
  return (CFUUIDRef)MEMORY[0x1F40D8988](alloc);
}

CFUUIDRef CFUUIDCreateFromUUIDBytes(CFAllocatorRef alloc, CFUUIDBytes bytes)
{
  return (CFUUIDRef)MEMORY[0x1F40D89A0](alloc, *(void *)&bytes.byte0, *(void *)&bytes.byte8);
}

CFStringRef CFUUIDCreateString(CFAllocatorRef alloc, CFUUIDRef uuid)
{
  return (CFStringRef)MEMORY[0x1F40D89B0](alloc, uuid);
}

CFUUIDBytes CFUUIDGetUUIDBytes(CFUUIDRef uuid)
{
  uint64_t v1 = MEMORY[0x1F40D89E8](uuid);
  result.byte8 = v2;
  result.byte9 = BYTE1(v2);
  result.byte10 = BYTE2(v2);
  result.byte11 = BYTE3(v2);
  result.byte12 = BYTE4(v2);
  result.byte13 = BYTE5(v2);
  result.byte14 = BYTE6(v2);
  result.byte15 = HIBYTE(v2);
  result.byte0 = v1;
  result.byte1 = BYTE1(v1);
  result.byte2 = BYTE2(v1);
  result.byte3 = BYTE3(v1);
  result.byte4 = BYTE4(v1);
  result.byte5 = BYTE5(v1);
  result.byte6 = BYTE6(v1);
  result.byte7 = HIBYTE(v1);
  return result;
}

BOOL CGAffineTransformEqualToTransform(CGAffineTransform *t1, CGAffineTransform *t2)
{
  return MEMORY[0x1F40D97A0](t1, t2);
}

CGAffineTransform *__cdecl CGAffineTransformInvert(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t)
{
  return (CGAffineTransform *)MEMORY[0x1F40D97A8](retstr, t);
}

CGAffineTransform *__cdecl CGAffineTransformMakeRotation(CGAffineTransform *__return_ptr retstr, CGFloat angle)
{
  return (CGAffineTransform *)MEMORY[0x1F40D97C8](retstr, angle);
}

CGAffineTransform *__cdecl CGAffineTransformRotate(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t, CGFloat angle)
{
  return (CGAffineTransform *)MEMORY[0x1F40D97E8](retstr, t, angle);
}

CGAffineTransform *__cdecl CGAffineTransformTranslate(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t, CGFloat tx, CGFloat ty)
{
  return (CGAffineTransform *)MEMORY[0x1F40D97F8](retstr, t, tx, ty);
}

CGContextRef CGBitmapContextCreate(void *data, size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow, CGColorSpaceRef space, uint32_t bitmapInfo)
{
  return (CGContextRef)MEMORY[0x1F40D9808](data, width, height, bitsPerComponent, bytesPerRow, space, *(void *)&bitmapInfo);
}

CGColorSpaceRef CGColorSpaceCreateDeviceRGB(void)
{
  return (CGColorSpaceRef)MEMORY[0x1F40D9AF8]();
}

CGColorSpaceRef CGColorSpaceCreateWithName(CFStringRef name)
{
  return (CGColorSpaceRef)MEMORY[0x1F40D9B60](name);
}

CGColorSpaceModel CGColorSpaceGetModel(CGColorSpaceRef space)
{
  return MEMORY[0x1F40D9BE0](space);
}

void CGColorSpaceRelease(CGColorSpaceRef space)
{
}

void CGContextConcatCTM(CGContextRef c, CGAffineTransform *transform)
{
}

void CGContextDrawImage(CGContextRef c, CGRect rect, CGImageRef image)
{
}

void CGContextRelease(CGContextRef c)
{
}

CFDataRef CGDataProviderCopyData(CGDataProviderRef provider)
{
  return (CFDataRef)MEMORY[0x1F40DA2E8](provider);
}

CGDataProviderRef CGDataProviderCreateWithData(void *info, const void *data, size_t size, CGDataProviderReleaseDataCallback releaseData)
{
  return (CGDataProviderRef)MEMORY[0x1F40DA310](info, data, size, releaseData);
}

void CGDataProviderRelease(CGDataProviderRef provider)
{
}

CGImageRef CGImageCreate(size_t width, size_t height, size_t bitsPerComponent, size_t bitsPerPixel, size_t bytesPerRow, CGColorSpaceRef space, CGBitmapInfo bitmapInfo, CGDataProviderRef provider, const CGFloat *decode, BOOL shouldInterpolate, CGColorRenderingIntent intent)
{
  return (CGImageRef)MEMORY[0x1F40DA868](width, height, bitsPerComponent, bitsPerPixel, bytesPerRow, space, *(void *)&bitmapInfo, provider);
}

void CGImageDestinationAddImage(CGImageDestinationRef idst, CGImageRef image, CFDictionaryRef properties)
{
}

CGImageDestinationRef CGImageDestinationCreateWithURL(CFURLRef url, CFStringRef type, size_t count, CFDictionaryRef options)
{
  return (CGImageDestinationRef)MEMORY[0x1F40E9758](url, type, count, options);
}

BOOL CGImageDestinationFinalize(CGImageDestinationRef idst)
{
  return MEMORY[0x1F40E9760](idst);
}

CGImageAlphaInfo CGImageGetAlphaInfo(CGImageRef image)
{
  return MEMORY[0x1F40DA8D0](image);
}

size_t CGImageGetBitsPerComponent(CGImageRef image)
{
  return MEMORY[0x1F40DA8E0](image);
}

size_t CGImageGetBitsPerPixel(CGImageRef image)
{
  return MEMORY[0x1F40DA8E8](image);
}

size_t CGImageGetBytesPerRow(CGImageRef image)
{
  return MEMORY[0x1F40DA8F0](image);
}

CGColorSpaceRef CGImageGetColorSpace(CGImageRef image)
{
  return (CGColorSpaceRef)MEMORY[0x1F40DA908](image);
}

CGDataProviderRef CGImageGetDataProvider(CGImageRef image)
{
  return (CGDataProviderRef)MEMORY[0x1F40DA920](image);
}

size_t CGImageGetHeight(CGImageRef image)
{
  return MEMORY[0x1F40DA948](image);
}

size_t CGImageGetWidth(CGImageRef image)
{
  return MEMORY[0x1F40DA9B8](image);
}

void CGImageRelease(CGImageRef image)
{
}

CGImageRef CGImageSourceCreateImageAtIndex(CGImageSourceRef isrc, size_t index, CFDictionaryRef options)
{
  return (CGImageRef)MEMORY[0x1F40E9968](isrc, index, options);
}

CGImageSourceRef CGImageSourceCreateWithURL(CFURLRef url, CFDictionaryRef options)
{
  return (CGImageSourceRef)MEMORY[0x1F40E99C8](url, options);
}

BOOL CGPointMakeWithDictionaryRepresentation(CFDictionaryRef dict, CGPoint *point)
{
  return MEMORY[0x1F40DB210](dict, point);
}

CGRect CGRectApplyAffineTransform(CGRect rect, CGAffineTransform *t)
{
  MEMORY[0x1F40DB220](t, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  result.size.double height = v5;
  result.size.double width = v4;
  result.origin.double y = v3;
  result.origin.double x = v2;
  return result;
}

BOOL CGRectContainsPoint(CGRect rect, CGPoint point)
{
  return MEMORY[0x1F40DB228]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height, (__n128)point, *(__n128 *)&point.y);
}

CFDictionaryRef CGRectCreateDictionaryRepresentation(CGRect a1)
{
  return (CFDictionaryRef)MEMORY[0x1F40DB238]((__n128)a1.origin, *(__n128 *)&a1.origin.y, (__n128)a1.size, *(__n128 *)&a1.size.height);
}

BOOL CGRectEqualToRect(CGRect rect1, CGRect rect2)
{
  return MEMORY[0x1F40DB248]((__n128)rect1.origin, *(__n128 *)&rect1.origin.y, (__n128)rect1.size, *(__n128 *)&rect1.size.height, (__n128)rect2.origin, *(__n128 *)&rect2.origin.y, (__n128)rect2.size, *(__n128 *)&rect2.size.height);
}

CGRect CGRectIntersection(CGRect r1, CGRect r2)
{
  MEMORY[0x1F40DB2C8]((__n128)r1.origin, *(__n128 *)&r1.origin.y, (__n128)r1.size, *(__n128 *)&r1.size.height, (__n128)r2.origin, *(__n128 *)&r2.origin.y, (__n128)r2.size, *(__n128 *)&r2.size.height);
  result.size.double height = v5;
  result.size.double width = v4;
  result.origin.double y = v3;
  result.origin.double x = v2;
  return result;
}

BOOL CGRectIsEmpty(CGRect rect)
{
  return MEMORY[0x1F40DB2D8]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

BOOL CGRectMakeWithDictionaryRepresentation(CFDictionaryRef dict, CGRect *rect)
{
  return MEMORY[0x1F40DB2F0](dict, rect);
}

CGRect CGRectStandardize(CGRect rect)
{
  MEMORY[0x1F40DB300]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  result.size.double height = v4;
  result.size.double width = v3;
  result.origin.double y = v2;
  result.origin.double x = v1;
  return result;
}

CGRect CGRectUnion(CGRect r1, CGRect r2)
{
  MEMORY[0x1F40DB310]((__n128)r1.origin, *(__n128 *)&r1.origin.y, (__n128)r1.size, *(__n128 *)&r1.size.height, (__n128)r2.origin, *(__n128 *)&r2.origin.y, (__n128)r2.size, *(__n128 *)&r2.size.height);
  result.size.double height = v5;
  result.size.double width = v4;
  result.origin.double y = v3;
  result.origin.double x = v2;
  return result;
}

CLLocationCoordinate2D CLLocationCoordinate2DMake(CLLocationDegrees latitude, CLLocationDegrees longitude)
{
  MEMORY[0x1F40DB5A0](latitude, longitude);
  result.longitude = v3;
  result.latitude = v2;
  return result;
}

OSStatus CMAudioFormatDescriptionCreate(CFAllocatorRef allocator, const AudioStreamBasicDescription *asbd, size_t layoutSize, const AudioChannelLayout *layout, size_t magicCookieSize, const void *magicCookie, CFDictionaryRef extensions, CMAudioFormatDescriptionRef *formatDescriptionOut)
{
  return MEMORY[0x1F40DB880](allocator, asbd, layoutSize, layout, magicCookieSize, magicCookie, extensions, formatDescriptionOut);
}

CMTime *__cdecl CMClockGetTime(CMTime *__return_ptr retstr, CMClockRef clock)
{
  return (CMTime *)MEMORY[0x1F40DBB38](retstr, clock);
}

FourCharCode CMFormatDescriptionGetMediaSubType(CMFormatDescriptionRef desc)
{
  return MEMORY[0x1F40DBBC8](desc);
}

CFTypeRef CMGetAttachment(CMAttachmentBearerRef target, CFStringRef key, CMAttachmentMode *attachmentModeOut)
{
  return (CFTypeRef)MEMORY[0x1F40DBBF0](target, key, attachmentModeOut);
}

uint64_t CMPointCloudFormatDescriptionGetNumberOfPoints()
{
  return MEMORY[0x1F40DBCF0]();
}

CVImageBufferRef CMSampleBufferGetImageBuffer(CMSampleBufferRef sbuf)
{
  return (CVImageBufferRef)MEMORY[0x1F40DBDC8](sbuf);
}

CMTime *__cdecl CMSampleBufferGetPresentationTimeStamp(CMTime *__return_ptr retstr, CMSampleBufferRef sbuf)
{
  return (CMTime *)MEMORY[0x1F40DBDF8](retstr, sbuf);
}

int32_t CMTimeCompare(CMTime *time1, CMTime *time2)
{
  return MEMORY[0x1F40DC0C8](time1, time2);
}

CFDictionaryRef CMTimeCopyAsDictionary(CMTime *time, CFAllocatorRef allocator)
{
  return (CFDictionaryRef)MEMORY[0x1F40DC0E0](time, allocator);
}

Float64 CMTimeGetSeconds(CMTime *time)
{
  MEMORY[0x1F40DC100](time);
  return result;
}

CMTime *__cdecl CMTimeMake(CMTime *__return_ptr retstr, int64_t value, int32_t timescale)
{
  return (CMTime *)MEMORY[0x1F40DC108](retstr, value, *(void *)&timescale);
}

CMTime *__cdecl CMTimeMakeFromDictionary(CMTime *__return_ptr retstr, CFDictionaryRef dictionaryRepresentation)
{
  return (CMTime *)MEMORY[0x1F40DC110](retstr, dictionaryRepresentation);
}

CMTime *__cdecl CMTimeMakeWithSeconds(CMTime *__return_ptr retstr, Float64 seconds, int32_t preferredTimescale)
{
  return (CMTime *)MEMORY[0x1F40DC120](retstr, *(void *)&preferredTimescale, seconds);
}

CMTime *__cdecl CMTimeSubtract(CMTime *__return_ptr retstr, CMTime *lhs, CMTime *rhs)
{
  return (CMTime *)MEMORY[0x1F40DC1F0](retstr, lhs, rhs);
}

CMVideoDimensions CMVideoFormatDescriptionGetDimensions(CMVideoFormatDescriptionRef videoDesc)
{
  return (CMVideoDimensions)MEMORY[0x1F40DC338](videoDesc);
}

uint64_t CV3DGetVersionInfo()
{
  return MEMORY[0x1F4109A98]();
}

uint64_t CV3DHitTestingDefaultParameters()
{
  return MEMORY[0x1F4109AA0]();
}

uint64_t CV3DLoggingCreateHandle()
{
  return MEMORY[0x1F4109AB0]();
}

uint64_t CV3DLoggingEnable()
{
  return MEMORY[0x1F4109AB8]();
}

uint64_t CV3DLoggingEnableInternal()
{
  return MEMORY[0x1F4109AC0]();
}

uint64_t CV3DLoggingReleaseHandle()
{
  return MEMORY[0x1F4109AC8]();
}

uint64_t CV3DMLModelCreate()
{
  return MEMORY[0x1F4109AD0]();
}

uint64_t CV3DMLModelRelease()
{
  return MEMORY[0x1F4109AD8]();
}

uint64_t CV3DModelsCreateObjectRegionProposalModelData()
{
  return MEMORY[0x1F410A0F8]();
}

uint64_t CV3DNormalEstimationCreate()
{
  return MEMORY[0x1F4109AE0]();
}

uint64_t CV3DNormalEstimationSessionCompute()
{
  return MEMORY[0x1F4109AE8]();
}

uint64_t CV3DNormalEstimationSessionRelease()
{
  return MEMORY[0x1F4109AF0]();
}

uint64_t CV3DODTAdd3dObject()
{
  return MEMORY[0x1F4109AF8]();
}

uint64_t CV3DODTAddPlanarObject()
{
  return MEMORY[0x1F4109B00]();
}

uint64_t CV3DODTConfigCreate()
{
  return MEMORY[0x1F4109B08]();
}

uint64_t CV3DODTConfigRelease()
{
  return MEMORY[0x1F4109B10]();
}

uint64_t CV3DODTCreateWithOptionsConfigAndModel()
{
  return MEMORY[0x1F4109B18]();
}

uint64_t CV3DODTDetectWithMetadata()
{
  return MEMORY[0x1F4109B20]();
}

uint64_t CV3DODTGetMaxSupportedNumberImagesToTrack()
{
  return MEMORY[0x1F4109B28]();
}

uint64_t CV3DODTImagePredict()
{
  return MEMORY[0x1F4109B30]();
}

uint64_t CV3DODTImagePredictInWorld()
{
  return MEMORY[0x1F4109B38]();
}

uint64_t CV3DODTObjectInfoRelease()
{
  return MEMORY[0x1F4109B40]();
}

uint64_t CV3DODTRelease()
{
  return MEMORY[0x1F4109B48]();
}

uint64_t CV3DODTSetMaximumTrackingTime()
{
  return MEMORY[0x1F4109B50]();
}

uint64_t CV3DODTSetPerformanceMode()
{
  return MEMORY[0x1F4109B58]();
}

uint64_t CV3DODTTrack()
{
  return MEMORY[0x1F4109B60]();
}

uint64_t CV3DODTTrackAndEstimateScale()
{
  return MEMORY[0x1F4109B68]();
}

uint64_t CV3DODTVerifyReferenceImage()
{
  return MEMORY[0x1F4109B70]();
}

uint64_t CV3DODTWaitForAllObjectsAddToFinish()
{
  return MEMORY[0x1F4109B78]();
}

uint64_t CV3DPerformHitTestPointCloud()
{
  return MEMORY[0x1F4109B80]();
}

uint64_t CV3DPlaneDetectionAlignedBoundingBoxMax()
{
  return MEMORY[0x1F4147AB8]();
}

uint64_t CV3DPlaneDetectionAlignedBoundingBoxMin()
{
  return MEMORY[0x1F4147AC0]();
}

uint64_t CV3DPlaneDetectionConfigurationCreate()
{
  return MEMORY[0x1F4147AC8]();
}

uint64_t CV3DPlaneDetectionConfigurationEnableDeterministicMode()
{
  return MEMORY[0x1F4147AD0]();
}

uint64_t CV3DPlaneDetectionConfigurationEnableLowQosScheduling()
{
  return MEMORY[0x1F4147AD8]();
}

uint64_t CV3DPlaneDetectionConfigurationEnableMLSegmentDetector()
{
  return MEMORY[0x1F4147AE0]();
}

uint64_t CV3DPlaneDetectionConfigurationEqualConfigurations()
{
  return MEMORY[0x1F4147AE8]();
}

uint64_t CV3DPlaneDetectionConfigurationRelease()
{
  return MEMORY[0x1F4147AF0]();
}

uint64_t CV3DPlaneDetectionConfigurationSetDesiredExtent()
{
  return MEMORY[0x1F4147AF8]();
}

uint64_t CV3DPlaneDetectionConfigurationSetDesiredOrientations()
{
  return MEMORY[0x1F4147B00]();
}

uint64_t CV3DPlaneDetectionConfigurationSetDetectionPolicy()
{
  return MEMORY[0x1F4147B08]();
}

uint64_t CV3DPlaneDetectionConfigurationSetMinVergenceAngle()
{
  return MEMORY[0x1F4147B10]();
}

uint64_t CV3DPlaneDetectionConvexHullPointsNum()
{
  return MEMORY[0x1F4147B18]();
}

uint64_t CV3DPlaneDetectionConvexHullPointsRawPtr()
{
  return MEMORY[0x1F4147B20]();
}

uint64_t CV3DPlaneDetectionDepthAndSemanticFrameCreate()
{
  return MEMORY[0x1F4147B28]();
}

uint64_t CV3DPlaneDetectionDepthAndSemanticFrameRelease()
{
  return MEMORY[0x1F4147B30]();
}

uint64_t CV3DPlaneDetectionDepthCameraFrameCreateFromAD()
{
  return MEMORY[0x1F4147B38]();
}

uint64_t CV3DPlaneDetectionDepthCameraFrameRelease()
{
  return MEMORY[0x1F4147B40]();
}

uint64_t CV3DPlaneDetectionErasePlaneDetections()
{
  return MEMORY[0x1F4147B48]();
}

uint64_t CV3DPlaneDetectionExtentGridAtIndex()
{
  return MEMORY[0x1F4147B50]();
}

uint64_t CV3DPlaneDetectionExtentGridLength()
{
  return MEMORY[0x1F4147B58]();
}

uint64_t CV3DPlaneDetectionExtentTypesCreate()
{
  return MEMORY[0x1F4147B60]();
}

uint64_t CV3DPlaneDetectionExtentTypesRelease()
{
  return MEMORY[0x1F4147B68]();
}

uint64_t CV3DPlaneDetectionExtentTypesSetAll()
{
  return MEMORY[0x1F4147B70]();
}

uint64_t CV3DPlaneDetectionExtentTypesSetAxisAlignedBox()
{
  return MEMORY[0x1F4147B78]();
}

uint64_t CV3DPlaneDetectionExtentTypesSetConvexHull()
{
  return MEMORY[0x1F4147B80]();
}

uint64_t CV3DPlaneDetectionExtentTypesSetOrientedBox()
{
  return MEMORY[0x1F4147B88]();
}

uint64_t CV3DPlaneDetectionGetNumSemanticLabels()
{
  return MEMORY[0x1F4147B90]();
}

uint64_t CV3DPlaneDetectionGetSemanticLabel()
{
  return MEMORY[0x1F4147B98]();
}

uint64_t CV3DPlaneDetectionGetSemanticProbability()
{
  return MEMORY[0x1F4147BA0]();
}

uint64_t CV3DPlaneDetectionLoadMap()
{
  return MEMORY[0x1F4147BA8]();
}

uint64_t CV3DPlaneDetectionParametersCreate()
{
  return MEMORY[0x1F4147BB0]();
}

uint64_t CV3DPlaneDetectionParametersEqualParameters()
{
  return MEMORY[0x1F4147BB8]();
}

uint64_t CV3DPlaneDetectionParametersRelease()
{
  return MEMORY[0x1F4147BC0]();
}

uint64_t CV3DPlaneDetectionParametersSetInverseDepthDetector()
{
  return MEMORY[0x1F4147BC8]();
}

uint64_t CV3DPlaneDetectionParametersSetMinClusterSize()
{
  return MEMORY[0x1F4147BD0]();
}

uint64_t CV3DPlaneDetectionParametersSetMinDepthConfidence()
{
  return MEMORY[0x1F4147BD8]();
}

uint64_t CV3DPlaneDetectionParametersSetMinDetections()
{
  return MEMORY[0x1F4147BE0]();
}

uint64_t CV3DPlaneDetectionParametersSetMinNormalDotProduct()
{
  return MEMORY[0x1F4147BE8]();
}

uint64_t CV3DPlaneDetectionParametersSetMinimumCellSize()
{
  return MEMORY[0x1F4147BF0]();
}

uint64_t CV3DPlaneDetectionParametersSetPlaneFitThreshold()
{
  return MEMORY[0x1F4147BF8]();
}

uint64_t CV3DPlaneDetectionPlaneAge()
{
  return MEMORY[0x1F4147C00]();
}

uint64_t CV3DPlaneDetectionPlaneAtIndex()
{
  return MEMORY[0x1F4147C08]();
}

uint64_t CV3DPlaneDetectionPlaneConvexHull2D()
{
  return MEMORY[0x1F4147C10]();
}

uint64_t CV3DPlaneDetectionPlaneCopyUUID()
{
  return MEMORY[0x1F4147C18]();
}

uint64_t CV3DPlaneDetectionPlaneCreateTriangulatedPolygons()
{
  return MEMORY[0x1F4147C20]();
}

uint64_t CV3DPlaneDetectionPlaneExtentAlignedBoundingBox()
{
  return MEMORY[0x1F4147C28]();
}

uint64_t CV3DPlaneDetectionPlaneExtentOrientedBoundingBox()
{
  return MEMORY[0x1F4147C30]();
}

uint64_t CV3DPlaneDetectionPlaneExtentPolygons()
{
  return MEMORY[0x1F4147C38]();
}

uint64_t CV3DPlaneDetectionPlaneGetOrientation()
{
  return MEMORY[0x1F4147C40]();
}

uint64_t CV3DPlaneDetectionPlaneListLength()
{
  return MEMORY[0x1F4147C48]();
}

uint64_t CV3DPlaneDetectionPlaneListRelease()
{
  return MEMORY[0x1F4147C50]();
}

uint64_t CV3DPlaneDetectionPlaneListRetain()
{
  return MEMORY[0x1F4147C58]();
}

uint64_t CV3DPlaneDetectionPlaneMergedIds()
{
  return MEMORY[0x1F4147C60]();
}

uint64_t CV3DPlaneDetectionPlaneTransformationToWorld()
{
  return MEMORY[0x1F4147C68]();
}

uint64_t CV3DPlaneDetectionPlaneUncertaintyAlongNormal()
{
  return MEMORY[0x1F4147C70]();
}

uint64_t CV3DPlaneDetectionPolygonAtIndex()
{
  return MEMORY[0x1F4147C78]();
}

uint64_t CV3DPlaneDetectionPolygonListLength()
{
  return MEMORY[0x1F4147C80]();
}

uint64_t CV3DPlaneDetectionPolygonPointsNum()
{
  return MEMORY[0x1F4147C88]();
}

uint64_t CV3DPlaneDetectionPolygonPointsRawPtr()
{
  return MEMORY[0x1F4147C90]();
}

uint64_t CV3DPlaneDetectionPushDepthAndSemanticFrame()
{
  return MEMORY[0x1F4147C98]();
}

uint64_t CV3DPlaneDetectionPushSemanticFrame()
{
  return MEMORY[0x1F4147CA0]();
}

uint64_t CV3DPlaneDetectionPushSlamMetadata()
{
  return MEMORY[0x1F4147CA8]();
}

uint64_t CV3DPlaneDetectionPushSparseDepthFrame()
{
  return MEMORY[0x1F4147CB0]();
}

uint64_t CV3DPlaneDetectionSemanticFrameCreate()
{
  return MEMORY[0x1F4147CB8]();
}

uint64_t CV3DPlaneDetectionSemanticFrameRelease()
{
  return MEMORY[0x1F4147CC0]();
}

uint64_t CV3DPlaneDetectionSerialize()
{
  return MEMORY[0x1F4147CC8]();
}

uint64_t CV3DPlaneDetectionSessionCreateWithConfig()
{
  return MEMORY[0x1F4147CD0]();
}

uint64_t CV3DPlaneDetectionSessionRegisterUpdateCallback()
{
  return MEMORY[0x1F4147CD8]();
}

uint64_t CV3DPlaneDetectionSessionRelease()
{
  return MEMORY[0x1F4147CE0]();
}

uint64_t CV3DPlaneDetectionSessionSetAnchoringFunctors()
{
  return MEMORY[0x1F4147CE8]();
}

uint64_t CV3DPlaneDetectionSessionSetSingleShotPlanesCallback()
{
  return MEMORY[0x1F4147CF0]();
}

uint64_t CV3DPlaneDetectionSingleShotPlaneListRelease()
{
  return MEMORY[0x1F4147D00]();
}

uint64_t CV3DPlaneDetectionSingleShotPlaneListRetain()
{
  return MEMORY[0x1F4147D08]();
}

uint64_t CV3DPlaneDetectionSlamMetadataCreateFromSlamState()
{
  return MEMORY[0x1F4109B88]();
}

uint64_t CV3DPlaneDetectionSlamMetadataRelease()
{
  return MEMORY[0x1F4147D10]();
}

uint64_t CV3DPosePredictionConfigCreate()
{
  return MEMORY[0x1F4109B90]();
}

uint64_t CV3DPosePredictionCreate()
{
  return MEMORY[0x1F4109BA0]();
}

uint64_t CV3DPosePredictionGetPose()
{
  return MEMORY[0x1F4109BA8]();
}

uint64_t CV3DPosePredictionPushAccel()
{
  return MEMORY[0x1F4109BB0]();
}

uint64_t CV3DPosePredictionPushGyro()
{
  return MEMORY[0x1F4109BB8]();
}

uint64_t CV3DPosePredictionPushSLAMMetadata()
{
  return MEMORY[0x1F4109BC0]();
}

uint64_t CV3DPosePredictionRelease()
{
  return MEMORY[0x1F4109BC8]();
}

uint64_t CV3DRayCastResultAtIndex()
{
  return MEMORY[0x1F4109BD0]();
}

uint64_t CV3DRayCastResultListFromId()
{
  return MEMORY[0x1F4109BD8]();
}

uint64_t CV3DRayCastResultMapIds()
{
  return MEMORY[0x1F4109BE0]();
}

uint64_t CV3DRayCastResultMapLength()
{
  return MEMORY[0x1F4109BE8]();
}

uint64_t CV3DRayCastResultsLength()
{
  return MEMORY[0x1F4109BF0]();
}

uint64_t CV3DRaycastDenseFrameCreate()
{
  return MEMORY[0x1F4109BF8]();
}

uint64_t CV3DRaycastDenseFrameRelease()
{
  return MEMORY[0x1F4109C00]();
}

uint64_t CV3DRaycastGetResultOrientation()
{
  return MEMORY[0x1F4109C08]();
}

uint64_t CV3DRaycastIntentCreate()
{
  return MEMORY[0x1F4109C10]();
}

uint64_t CV3DRaycastIntentEnableTracking()
{
  return MEMORY[0x1F4109C18]();
}

uint64_t CV3DRaycastIntentRelease()
{
  return MEMORY[0x1F4109C20]();
}

uint64_t CV3DRaycastIntentSetConsideredGeometry()
{
  return MEMORY[0x1F4109C28]();
}

uint64_t CV3DRaycastIntentSetConsideredOrientations()
{
  return MEMORY[0x1F4109C30]();
}

uint64_t CV3DRaycastIntentSetExtentCheckForTrackedPlanes()
{
  return MEMORY[0x1F4109C38]();
}

uint64_t CV3DRaycastPushDenseFrame()
{
  return MEMORY[0x1F4109C50]();
}

uint64_t CV3DRaycastPushJasperPointCloud()
{
  return MEMORY[0x1F4109C58]();
}

uint64_t CV3DRaycastPushPlanes()
{
  return MEMORY[0x1F4109C60]();
}

uint64_t CV3DRaycastPushSlamState()
{
  return MEMORY[0x1F4109C68]();
}

uint64_t CV3DRaycastResultExtentChecked()
{
  return MEMORY[0x1F4109C78]();
}

uint64_t CV3DRaycastResultListRelease()
{
  return MEMORY[0x1F4109C80]();
}

uint64_t CV3DRaycastResultOriginatedFrom()
{
  return MEMORY[0x1F4109C88]();
}

uint64_t CV3DRaycastResultPlaneIdentifier()
{
  return MEMORY[0x1F4109C90]();
}

uint64_t CV3DRaycastResultTransformationToWorld()
{
  return MEMORY[0x1F4109C98]();
}

uint64_t CV3DRaycastSessionAttemptWithIntent()
{
  return MEMORY[0x1F4109CA0]();
}

uint64_t CV3DRaycastSessionConfigurationCreate()
{
  return MEMORY[0x1F4109CA8]();
}

uint64_t CV3DRaycastSessionConfigurationEnableDeterministicMode()
{
  return MEMORY[0x1F4109CB0]();
}

uint64_t CV3DRaycastSessionConfigurationRelease()
{
  return MEMORY[0x1F4109CB8]();
}

uint64_t CV3DRaycastSessionCreateWithConfig()
{
  return MEMORY[0x1F4109CC0]();
}

uint64_t CV3DRaycastSessionRegisterOnTrackableUpdateCallback()
{
  return MEMORY[0x1F4109CC8]();
}

uint64_t CV3DRaycastSessionRelease()
{
  return MEMORY[0x1F4109CD0]();
}

uint64_t CV3DRaycastSessionSetAnchoringFunctors()
{
  return MEMORY[0x1F4109CD8]();
}

uint64_t CV3DRaycastTriggerUpdateFromTrackableIntentsAsync()
{
  return MEMORY[0x1F4109CE0]();
}

uint64_t CV3DReconFrameBundleAddSlamMetadata()
{
  return MEMORY[0x1F4147D18]();
}

uint64_t CV3DReconFrameBundleCreate()
{
  return MEMORY[0x1F4147D20]();
}

uint64_t CV3DReconFrameBundleSetColorImage()
{
  return MEMORY[0x1F4147D30]();
}

uint64_t CV3DReconFrameBundleSetDepthConfidenceImage()
{
  return MEMORY[0x1F4147D38]();
}

uint64_t CV3DReconFrameBundleSetDepthImage()
{
  return MEMORY[0x1F4147D40]();
}

uint64_t CV3DReconFrameBundleSetNormalsImage()
{
  return MEMORY[0x1F4147D48]();
}

uint64_t CV3DReconFrameBundleSetSemanticsImage()
{
  return MEMORY[0x1F4147D50]();
}

uint64_t CV3DReconKeyframeCreatePointCloud()
{
  return MEMORY[0x1F4147D58]();
}

uint64_t CV3DReconKeyframeGetCreationTime()
{
  return MEMORY[0x1F4147D60]();
}

uint64_t CV3DReconKeyframeListCopyKeyframeAtIndex()
{
  return MEMORY[0x1F4147D68]();
}

uint64_t CV3DReconKeyframeListGetCount()
{
  return MEMORY[0x1F4147D70]();
}

uint64_t CV3DReconKeyframeListGetKeyframeToWorldTransformAtIndex()
{
  return MEMORY[0x1F4147D78]();
}

uint64_t CV3DReconKeyframeListGetKeyframeUUIDAtIndex()
{
  return MEMORY[0x1F4147D80]();
}

uint64_t CV3DReconKeyframeListRelease()
{
  return MEMORY[0x1F4147D88]();
}

uint64_t CV3DReconKeyframeListRetain()
{
  return MEMORY[0x1F4147D90]();
}

uint64_t CV3DReconLoggingHandleCreate()
{
  return MEMORY[0x1F4147DA0]();
}

uint64_t CV3DReconLoggingHandleEnable()
{
  return MEMORY[0x1F4147DA8]();
}

uint64_t CV3DReconLoggingHandleEnableInternal()
{
  return MEMORY[0x1F4147DB0]();
}

uint64_t CV3DReconLoggingHandleRelease()
{
  return MEMORY[0x1F4147DB8]();
}

uint64_t CV3DReconMeshGetFaceSemanticLabelsAsMTLBufferForDevice()
{
  return MEMORY[0x1F4147DC0]();
}

uint64_t CV3DReconMeshGetFaceSemanticLabelsRawPtr()
{
  return MEMORY[0x1F4147DC8]();
}

uint64_t CV3DReconMeshGetFacesAsMTLBufferForDevice()
{
  return MEMORY[0x1F4147DD0]();
}

uint64_t CV3DReconMeshGetFacesCount()
{
  return MEMORY[0x1F4147DD8]();
}

uint64_t CV3DReconMeshGetFacesRawPtr()
{
  return MEMORY[0x1F4147DE0]();
}

uint64_t CV3DReconMeshGetLocalToWorldTransform()
{
  return MEMORY[0x1F4147DE8]();
}

uint64_t CV3DReconMeshGetVertexColorsAsMTLBufferForDevice()
{
  return MEMORY[0x1F4147DF0]();
}

uint64_t CV3DReconMeshGetVertexNormalsAsMTLBufferForDevice()
{
  return MEMORY[0x1F4147DF8]();
}

uint64_t CV3DReconMeshGetVertexNormalsRawPtr()
{
  return MEMORY[0x1F4147E00]();
}

uint64_t CV3DReconMeshGetVerticesAsMTLBufferForDevice()
{
  return MEMORY[0x1F4147E08]();
}

uint64_t CV3DReconMeshGetVerticesCount()
{
  return MEMORY[0x1F4147E10]();
}

uint64_t CV3DReconMeshGetVerticesRawPtr()
{
  return MEMORY[0x1F4147E18]();
}

uint64_t CV3DReconMeshListCopyMeshAtIndex()
{
  return MEMORY[0x1F4147E20]();
}

uint64_t CV3DReconMeshListGetCount()
{
  return MEMORY[0x1F4147E28]();
}

uint64_t CV3DReconMeshListGetMeshUUIDAtIndex()
{
  return MEMORY[0x1F4147E30]();
}

uint64_t CV3DReconMeshListRelease()
{
  return MEMORY[0x1F4147E38]();
}

uint64_t CV3DReconMeshListRetain()
{
  return MEMORY[0x1F4147E40]();
}

uint64_t CV3DReconMeshRelease()
{
  return MEMORY[0x1F4147E48]();
}

uint64_t CV3DReconMeshingConfigurationAddMeshIntegrationAttribute()
{
  return MEMORY[0x1F4147E50]();
}

uint64_t CV3DReconMeshingConfigurationAddPrivateMeshIntegrationAttribute()
{
  return MEMORY[0x1F4147E58]();
}

uint64_t CV3DReconMeshingConfigurationCreateWithPrivatePreset()
{
  return MEMORY[0x1F4147E60]();
}

uint64_t CV3DReconMeshingConfigurationEnableOccupancyMapping()
{
  return MEMORY[0x1F4147E68]();
}

uint64_t CV3DReconMeshingConfigurationHasOccupancyMapping()
{
  return MEMORY[0x1F4147E70]();
}

uint64_t CV3DReconMeshingConfigurationRemoveMeshIntegrationAttribute()
{
  return MEMORY[0x1F4147E80]();
}

uint64_t CV3DReconMeshingConfigurationSetBucketsOrderOfMagnitude()
{
  return MEMORY[0x1F4147E88]();
}

uint64_t CV3DReconMeshingConfigurationSetMinMeshingPeriod()
{
  return MEMORY[0x1F4147E90]();
}

uint64_t CV3DReconMeshingConfigurationSetVoxelSize()
{
  return MEMORY[0x1F4147E98]();
}

uint64_t CV3DReconOccupancyQueryRequestCreateFromPoints()
{
  return MEMORY[0x1F4147EA0]();
}

uint64_t CV3DReconOccupancyQueryResultGetRawPtr()
{
  return MEMORY[0x1F4147EB0]();
}

uint64_t CV3DReconOccupancyQueryResultGetWidth()
{
  return MEMORY[0x1F4147EB8]();
}

uint64_t CV3DReconOccupancyQueryResultRelease()
{
  return MEMORY[0x1F4147EC0]();
}

uint64_t CV3DReconPointCloudGetColorRawPtr()
{
  return MEMORY[0x1F4147EC8]();
}

uint64_t CV3DReconPointCloudGetNormalsRawPtr()
{
  return MEMORY[0x1F4147ED0]();
}

uint64_t CV3DReconPointCloudGetPointsCount()
{
  return MEMORY[0x1F4147ED8]();
}

uint64_t CV3DReconPointCloudGetPointsRawPtr()
{
  return MEMORY[0x1F4147EE0]();
}

uint64_t CV3DReconPointCloudGetSemanticHistogramLabelsRawPtr()
{
  return MEMORY[0x1F4147EE8]();
}

uint64_t CV3DReconPointCloudGetSemanticHistogramVotesRawPtr()
{
  return MEMORY[0x1F4147EF0]();
}

uint64_t CV3DReconSessionAddOnKeyframeListUpdateCallback()
{
  return MEMORY[0x1F4147F00]();
}

uint64_t CV3DReconSessionAddOnMeshListUpdateCallback()
{
  return MEMORY[0x1F4147F08]();
}

uint64_t CV3DReconSessionConfigurationAddMappingAttribute()
{
  return MEMORY[0x1F4147F10]();
}

uint64_t CV3DReconSessionConfigurationAddPrivateMappingAttribute()
{
  return MEMORY[0x1F4147F18]();
}

uint64_t CV3DReconSessionConfigurationCreateWithPrivatePreset()
{
  return MEMORY[0x1F4147F20]();
}

uint64_t CV3DReconSessionConfigurationEnableConsumeVIOMetadata()
{
  return MEMORY[0x1F4147F28]();
}

uint64_t CV3DReconSessionConfigurationEnableDeterministicBehavior()
{
  return MEMORY[0x1F4147F30]();
}

uint64_t CV3DReconSessionConfigurationEnableLowQosScheduling()
{
  return MEMORY[0x1F4147F38]();
}

uint64_t CV3DReconSessionConfigurationEnableSynchronousScheduling()
{
  return MEMORY[0x1F4147F40]();
}

uint64_t CV3DReconSessionConfigurationSetMeshingConfiguration()
{
  return MEMORY[0x1F4147F50]();
}

uint64_t CV3DReconSessionConfigurationSetMinDepthConfidence()
{
  return MEMORY[0x1F4147F58]();
}

uint64_t CV3DReconSessionConfigurationSetSlamAdapter()
{
  return MEMORY[0x1F4147F60]();
}

uint64_t CV3DReconSessionCreateWithConfiguration()
{
  return MEMORY[0x1F4147F68]();
}

uint64_t CV3DReconSessionDisable()
{
  return MEMORY[0x1F4147F70]();
}

uint64_t CV3DReconSessionEnableMeshPlaneHarmony()
{
  return MEMORY[0x1F4147F80]();
}

uint64_t CV3DReconSessionEnablePerFrameMeshColor()
{
  return MEMORY[0x1F4147F88]();
}

uint64_t CV3DReconSessionEnablePerFrameMeshSemantics()
{
  return MEMORY[0x1F4147F90]();
}

uint64_t CV3DReconSessionHasKeyframingCapability()
{
  return MEMORY[0x1F4147F98]();
}

uint64_t CV3DReconSessionHasMeshingCapability()
{
  return MEMORY[0x1F4147FA0]();
}

uint64_t CV3DReconSessionProcessFrameBundle()
{
  return MEMORY[0x1F4147FA8]();
}

uint64_t CV3DReconSessionProcessPlaneList()
{
  return MEMORY[0x1F4147FB0]();
}

uint64_t CV3DReconSessionQueryOccupancyAsync()
{
  return MEMORY[0x1F4147FB8]();
}

uint64_t CV3DReconSessionRelease()
{
  return MEMORY[0x1F4147FC0]();
}

uint64_t CV3DReconSessionReset()
{
  return MEMORY[0x1F4147FC8]();
}

uint64_t CV3DReconSessionRetain()
{
  return MEMORY[0x1F4147FD0]();
}

uint64_t CV3DReconSessionWait()
{
  return MEMORY[0x1F4147FD8]();
}

uint64_t CV3DReconSlamAdapterCreate()
{
  return MEMORY[0x1F4147FE0]();
}

uint64_t CV3DReconSlamAdapterSetAnchoringCallbacks()
{
  return MEMORY[0x1F4147FF0]();
}

uint64_t CV3DReconSlamMetadataCreateFromSlamState()
{
  return MEMORY[0x1F4109CE8]();
}

uint64_t CV3DReleaseHitTestResults()
{
  return MEMORY[0x1F4109CF0]();
}

uint64_t CV3DSLAMAnchorCopyAnchorID()
{
  return MEMORY[0x1F4109CF8]();
}

uint64_t CV3DSLAMAnchorCopyPose()
{
  return MEMORY[0x1F4109D00]();
}

uint64_t CV3DSLAMAnchorCopySessionID()
{
  return MEMORY[0x1F4109D08]();
}

uint64_t CV3DSLAMCalibrationAddCameraParameters2()
{
  return MEMORY[0x1F4109D10]();
}

uint64_t CV3DSLAMCalibrationAddIMUParameters()
{
  return MEMORY[0x1F4109D18]();
}

uint64_t CV3DSLAMCalibrationCreate()
{
  return MEMORY[0x1F4109D20]();
}

uint64_t CV3DSLAMCalibrationDetectRuntimeHardware()
{
  return MEMORY[0x1F4109D28]();
}

uint64_t CV3DSLAMCalibrationForceToUsePerFrameCameraIntrinsics()
{
  return MEMORY[0x1F4109D30]();
}

uint64_t CV3DSLAMCalibrationRelease()
{
  return MEMORY[0x1F4109D38]();
}

uint64_t CV3DSLAMCameraFrameAddHWFPWithIntrinsics()
{
  return MEMORY[0x1F4109D40]();
}

uint64_t CV3DSLAMCameraFrameCreate()
{
  return MEMORY[0x1F4109D48]();
}

uint64_t CV3DSLAMCameraModelTypeFromString()
{
  return MEMORY[0x1F4109D58]();
}

uint64_t CV3DSLAMCameraVideoModeFromString()
{
  return MEMORY[0x1F4109D60]();
}

uint64_t CV3DSLAMConfigAnchorStrategy()
{
  return MEMORY[0x1F4109D68]();
}

uint64_t CV3DSLAMConfigAsString()
{
  return MEMORY[0x1F4109D70]();
}

uint64_t CV3DSLAMConfigCalcFeaturePointDetectionResolution()
{
  return MEMORY[0x1F4109D78]();
}

uint64_t CV3DSLAMConfigCalcLineDetectionResolution()
{
  return MEMORY[0x1F4109D80]();
}

uint64_t CV3DSLAMConfigCreate2()
{
  return MEMORY[0x1F4109D88]();
}

uint64_t CV3DSLAMConfigCreateAVCaptureConfig()
{
  return MEMORY[0x1F4109D90]();
}

uint64_t CV3DSLAMConfigDisableCameraSwitchingAndUsePrimaryCamera()
{
  return MEMORY[0x1F4109D98]();
}

uint64_t CV3DSLAMConfigDisableLineTracking()
{
  return MEMORY[0x1F4109DA0]();
}

uint64_t CV3DSLAMConfigDisableMLRelocalization()
{
  return MEMORY[0x1F4109DA8]();
}

uint64_t CV3DSLAMConfigDisablePlaneTracking()
{
  return MEMORY[0x1F4109DB0]();
}

uint64_t CV3DSLAMConfigEnableCollaborativeMapping()
{
  return MEMORY[0x1F4109DB8]();
}

uint64_t CV3DSLAMConfigEnableLacc()
{
  return MEMORY[0x1F4109DC0]();
}

uint64_t CV3DSLAMConfigEnableLineTracking()
{
  return MEMORY[0x1F4109DC8]();
}

uint64_t CV3DSLAMConfigEnableLineTrackingAlways()
{
  return MEMORY[0x1F4109DD0]();
}

uint64_t CV3DSLAMConfigEnableMLRelocalization()
{
  return MEMORY[0x1F4109DD8]();
}

uint64_t CV3DSLAMConfigEnablePlaneTracking()
{
  return MEMORY[0x1F4109DE0]();
}

uint64_t CV3DSLAMConfigEnableTransformToExternalSubmap()
{
  return MEMORY[0x1F4109DE8]();
}

uint64_t CV3DSLAMConfigGetLaccSupported()
{
  return MEMORY[0x1F4109DF0]();
}

uint64_t CV3DSLAMConfigIsMLRelocalizationSupported()
{
  return MEMORY[0x1F4109DF8]();
}

uint64_t CV3DSLAMConfigOutputCollaborativeMappingStatistics()
{
  return MEMORY[0x1F4109E00]();
}

uint64_t CV3DSLAMConfigOverrideSessionID()
{
  return MEMORY[0x1F4109E08]();
}

uint64_t CV3DSLAMConfigPresetFromString()
{
  return MEMORY[0x1F4109E10]();
}

uint64_t CV3DSLAMConfigRelease()
{
  return MEMORY[0x1F4109E18]();
}

uint64_t CV3DSLAMConfigSetMapFromCFData()
{
  return MEMORY[0x1F4109E20]();
}

uint64_t CV3DSLAMConfigSetMappingDirectory()
{
  return MEMORY[0x1F4109E28]();
}

uint64_t CV3DSLAMConfigSetRelocalizationEnabled()
{
  return MEMORY[0x1F4109E30]();
}

uint64_t CV3DSLAMConfigUseDeterministicMode()
{
  return MEMORY[0x1F4109E38]();
}

uint64_t CV3DSLAMConfigUseHWFeaturePoints()
{
  return MEMORY[0x1F4109E40]();
}

uint64_t CV3DSLAMConfigUseSWProxyFeaturePoints()
{
  return MEMORY[0x1F4109E48]();
}

uint64_t CV3DSLAMIsFatalError()
{
  return MEMORY[0x1F4109E50]();
}

uint64_t CV3DSLAMJasperPointCloudCreateFromADPointCloud()
{
  return MEMORY[0x1F4109E58]();
}

uint64_t CV3DSLAMJasperPointCloudRelease()
{
  return MEMORY[0x1F4109E60]();
}

uint64_t CV3DSLAMJasperPointCloudSetProjectorMode()
{
  return MEMORY[0x1F4109E68]();
}

uint64_t CV3DSLAMSessionAddAnchor()
{
  return MEMORY[0x1F4109E70]();
}

uint64_t CV3DSLAMSessionClearMap()
{
  return MEMORY[0x1F4109E78]();
}

uint64_t CV3DSLAMSessionCopyJasperCameraCalibration()
{
  return MEMORY[0x1F4109E80]();
}

uint64_t CV3DSLAMSessionCreate()
{
  return MEMORY[0x1F4109E88]();
}

uint64_t CV3DSLAMSessionCreateCMPoseAnchorData()
{
  return MEMORY[0x1F4109E90]();
}

uint64_t CV3DSLAMSessionDeregisterNewStateBlock()
{
  return MEMORY[0x1F4109E98]();
}

uint64_t CV3DSLAMSessionGetCMOjbectAnchorMetadata()
{
  return MEMORY[0x1F4109EA0]();
}

uint64_t CV3DSLAMSessionGetCMPoseAnchorTransformation()
{
  return MEMORY[0x1F4109EA8]();
}

uint64_t CV3DSLAMSessionGetSessionID()
{
  return MEMORY[0x1F4109EB0]();
}

uint64_t CV3DSLAMSessionPushAccel()
{
  return MEMORY[0x1F4109EB8]();
}

uint64_t CV3DSLAMSessionPushCMData()
{
  return MEMORY[0x1F4109EC0]();
}

uint64_t CV3DSLAMSessionPushCamera()
{
  return MEMORY[0x1F4109EC8]();
}

uint64_t CV3DSLAMSessionPushGyro()
{
  return MEMORY[0x1F4109ED0]();
}

uint64_t CV3DSLAMSessionPushJasperPointCloud()
{
  return MEMORY[0x1F4109ED8]();
}

uint64_t CV3DSLAMSessionRegisterNewStateBlock()
{
  return MEMORY[0x1F4109EE0]();
}

uint64_t CV3DSLAMSessionRelease()
{
  return MEMORY[0x1F4109EE8]();
}

uint64_t CV3DSLAMSessionRemoveAnchor()
{
  return MEMORY[0x1F4109EF0]();
}

uint64_t CV3DSLAMSessionRetain()
{
  return MEMORY[0x1F4109EF8]();
}

uint64_t CV3DSLAMSessionSerializeMap()
{
  return MEMORY[0x1F4109F00]();
}

uint64_t CV3DSLAMSessionSetCMDataBlock()
{
  return MEMORY[0x1F4109F08]();
}

uint64_t CV3DSLAMSessionSetOutputMapPoints()
{
  return MEMORY[0x1F4109F18]();
}

uint64_t CV3DSLAMSessionWait()
{
  return MEMORY[0x1F4109F20]();
}

uint64_t CV3DSLAMSetErrorBlock()
{
  return MEMORY[0x1F4109F28]();
}

uint64_t CV3DSLAMSetNewStateBlock()
{
  return MEMORY[0x1F4109F30]();
}

uint64_t CV3DSLAMStateConvertPoseToCameraFrame()
{
  return MEMORY[0x1F4109F38]();
}

uint64_t CV3DSLAMStateCopyCameraFrameRates()
{
  return MEMORY[0x1F4109F40]();
}

uint64_t CV3DSLAMStateCopyCurrentTrackingCameraIds()
{
  return MEMORY[0x1F4109F48]();
}

uint64_t CV3DSLAMStateCopyNewAnchors()
{
  return MEMORY[0x1F4109F50]();
}

uint64_t CV3DSLAMStateCopyRemovedAnchors()
{
  return MEMORY[0x1F4109F58]();
}

uint64_t CV3DSLAMStateCopyUpdatedAnchors()
{
  return MEMORY[0x1F4109F60]();
}

uint64_t CV3DSLAMStateCreateFromData()
{
  return MEMORY[0x1F4109F68]();
}

uint64_t CV3DSLAMStateGetCameraSwitchingStatistics()
{
  return MEMORY[0x1F4109F70]();
}

uint64_t CV3DSLAMStateGetCameraTrackRatiosPerCamera()
{
  return MEMORY[0x1F4109F78]();
}

uint64_t CV3DSLAMStateGetCollaborativeMapStatistics()
{
  return MEMORY[0x1F4109F80]();
}

uint64_t CV3DSLAMStateGetExternalAnchorNames()
{
  return MEMORY[0x1F4109F88]();
}

uint64_t CV3DSLAMStateGetLineCloud()
{
  return MEMORY[0x1F4109F90]();
}

uint64_t CV3DSLAMStateGetMapKeyFrameQuality()
{
  return MEMORY[0x1F4109F98]();
}

uint64_t CV3DSLAMStateGetMapMergeStats()
{
  return MEMORY[0x1F4109FA0]();
}

uint64_t CV3DSLAMStateGetMapSize()
{
  return MEMORY[0x1F4109FA8]();
}

uint64_t CV3DSLAMStateGetNumberOfVOToVIOStateTransitions()
{
  return MEMORY[0x1F4109FB0]();
}

uint64_t CV3DSLAMStateGetOldestStateCovarianceMatrices()
{
  return MEMORY[0x1F4109FB8]();
}

uint64_t CV3DSLAMStateGetPointCloud()
{
  return MEMORY[0x1F4109FC0]();
}

uint64_t CV3DSLAMStateGetPoseInCameraFrame()
{
  return MEMORY[0x1F4109FC8]();
}

uint64_t CV3DSLAMStateGetRelocalizationTimestamp()
{
  return MEMORY[0x1F4109FD0]();
}

uint64_t CV3DSLAMStateGetSLAMMode()
{
  return MEMORY[0x1F4109FD8]();
}

uint64_t CV3DSLAMStateGetStatus()
{
  return MEMORY[0x1F4109FE0]();
}

uint64_t CV3DSLAMStateGetTimestamp()
{
  return MEMORY[0x1F4109FE8]();
}

uint64_t CV3DSLAMStateGetVisualSLAMState()
{
  return MEMORY[0x1F4109FF0]();
}

uint64_t CV3DSLAMStateIsGlobalRelocalization()
{
  return MEMORY[0x1F4109FF8]();
}

uint64_t CV3DSLAMStateIsInitFinished()
{
  return MEMORY[0x1F410A000]();
}

uint64_t CV3DSLAMStateIsPoseLocked()
{
  return MEMORY[0x1F410A008]();
}

uint64_t CV3DSLAMStateNumReinit()
{
  return MEMORY[0x1F410A010]();
}

uint64_t CV3DSLAMStateRelease()
{
  return MEMORY[0x1F410A018]();
}

uint64_t CV3DSLAMStateRelocalizationEvent()
{
  return MEMORY[0x1F410A020]();
}

uint64_t CV3DSLAMStateRelocalizationSucceeded()
{
  return MEMORY[0x1F410A028]();
}

uint64_t CV3DSLAMStateRetain()
{
  return MEMORY[0x1F410A030]();
}

uint64_t CV3DSLAMStateSerializeToData()
{
  return MEMORY[0x1F410A038]();
}

uint64_t CV3DSLAMStateShouldUseVisualSLAM()
{
  return MEMORY[0x1F410A040]();
}

uint64_t CV3DSLAMStateSnapshotCreate()
{
  return MEMORY[0x1F410A048]();
}

uint64_t CV3DSLAMStateSnapshotCreateSLAMState()
{
  return MEMORY[0x1F410A050]();
}

uint64_t CV3DSLAMStateSnapshotGetPose()
{
  return MEMORY[0x1F410A058]();
}

uint64_t CV3DSLAMStateWasTrackingMap()
{
  return MEMORY[0x1F410A068]();
}

uint64_t CV3DSurfaceDetectionCreateWithArgs()
{
  return MEMORY[0x1F410A070]();
}

uint64_t CV3DSurfaceDetectionDefaultParameters()
{
  return MEMORY[0x1F410A078]();
}

uint64_t CV3DSurfaceDetectionRelease()
{
  return MEMORY[0x1F410A080]();
}

uint64_t CV3DSurfaceDetectionSingleShotSurfaces()
{
  return MEMORY[0x1F410A090]();
}

uint64_t CV3DUpdateHitTestResultPose()
{
  return MEMORY[0x1F410A098]();
}

uint64_t CV3DVIOAddCameraCalibrationToDictionaryV2()
{
  return MEMORY[0x1F410A0A0]();
}

uint64_t CV3DVIOAlignAndMergeMaps()
{
  return MEMORY[0x1F410A0A8]();
}

uint64_t CV3DVIOCreateKeyframesFromMap()
{
  return MEMORY[0x1F410A0B0]();
}

uint64_t CV3DVIOCreatePointsFromMap()
{
  return MEMORY[0x1F410A0B8]();
}

uint64_t CV3DVIOExtractObjectMap()
{
  return MEMORY[0x1F410A0C0]();
}

uint64_t CV3DVIOGetMapBounds()
{
  return MEMORY[0x1F410A0C8]();
}

uint64_t CV3DVIOIsVideoModeSupported()
{
  return MEMORY[0x1F410A0D0]();
}

uint64_t CV3PosePredictionInitialize()
{
  return MEMORY[0x1F410A0D8]();
}

uint64_t CVAFaceTrackingCopySemantics()
{
  return MEMORY[0x1F410A100]();
}

uint64_t CVAFaceTrackingCreate()
{
  return MEMORY[0x1F410A108]();
}

uint64_t CVAFaceTrackingGetErrorDescription()
{
  return MEMORY[0x1F410A110]();
}

uint64_t CVAFaceTrackingMaximumNumberOfTrackedFaces()
{
  return MEMORY[0x1F410A118]();
}

uint64_t CVAFaceTrackingProcess()
{
  return MEMORY[0x1F410A120]();
}

CFTypeRef CVBufferCopyAttachment(CVBufferRef buffer, CFStringRef key, CVAttachmentMode *attachmentMode)
{
  return (CFTypeRef)MEMORY[0x1F40DFB48](buffer, key, attachmentMode);
}

CFDictionaryRef CVBufferCopyAttachments(CVBufferRef buffer, CVAttachmentMode attachmentMode)
{
  return (CFDictionaryRef)MEMORY[0x1F40DFB50](buffer, *(void *)&attachmentMode);
}

void CVBufferPropagateAttachments(CVBufferRef sourceBuffer, CVBufferRef destinationBuffer)
{
}

void CVBufferRelease(CVBufferRef buffer)
{
}

CVBufferRef CVBufferRetain(CVBufferRef buffer)
{
  return (CVBufferRef)MEMORY[0x1F40DFB90](buffer);
}

void CVBufferSetAttachment(CVBufferRef buffer, CFStringRef key, CFTypeRef value, CVAttachmentMode attachmentMode)
{
}

uint64_t CVDataBufferGetIOSurface()
{
  return MEMORY[0x1F40DFBD8]();
}

CVReturn CVPixelBufferCreate(CFAllocatorRef allocator, size_t width, size_t height, OSType pixelFormatType, CFDictionaryRef pixelBufferAttributes, CVPixelBufferRef *pixelBufferOut)
{
  return MEMORY[0x1F40DFCE0](allocator, width, height, *(void *)&pixelFormatType, pixelBufferAttributes, pixelBufferOut);
}

CVReturn CVPixelBufferCreateWithBytes(CFAllocatorRef allocator, size_t width, size_t height, OSType pixelFormatType, void *baseAddress, size_t bytesPerRow, CVPixelBufferReleaseBytesCallback releaseCallback, void *releaseRefCon, CFDictionaryRef pixelBufferAttributes, CVPixelBufferRef *pixelBufferOut)
{
  return MEMORY[0x1F40DFD00](allocator, width, height, *(void *)&pixelFormatType, baseAddress, bytesPerRow, releaseCallback, releaseRefCon);
}

CVReturn CVPixelBufferCreateWithIOSurface(CFAllocatorRef allocator, IOSurfaceRef surface, CFDictionaryRef pixelBufferAttributes, CVPixelBufferRef *pixelBufferOut)
{
  return MEMORY[0x1F40DFD08](allocator, surface, pixelBufferAttributes, pixelBufferOut);
}

void *__cdecl CVPixelBufferGetBaseAddress(CVPixelBufferRef pixelBuffer)
{
  return (void *)MEMORY[0x1F40DFD28](pixelBuffer);
}

void *__cdecl CVPixelBufferGetBaseAddressOfPlane(CVPixelBufferRef pixelBuffer, size_t planeIndex)
{
  return (void *)MEMORY[0x1F40DFD30](pixelBuffer, planeIndex);
}

size_t CVPixelBufferGetBytesPerRow(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x1F40DFD40](pixelBuffer);
}

size_t CVPixelBufferGetBytesPerRowOfPlane(CVPixelBufferRef pixelBuffer, size_t planeIndex)
{
  return MEMORY[0x1F40DFD48](pixelBuffer, planeIndex);
}

size_t CVPixelBufferGetDataSize(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x1F40DFD50](pixelBuffer);
}

size_t CVPixelBufferGetHeight(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x1F40DFD68](pixelBuffer);
}

size_t CVPixelBufferGetHeightOfPlane(CVPixelBufferRef pixelBuffer, size_t planeIndex)
{
  return MEMORY[0x1F40DFD70](pixelBuffer, planeIndex);
}

IOSurfaceRef CVPixelBufferGetIOSurface(CVPixelBufferRef pixelBuffer)
{
  return (IOSurfaceRef)MEMORY[0x1F40DFD78](pixelBuffer);
}

OSType CVPixelBufferGetPixelFormatType(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x1F40DFD80](pixelBuffer);
}

size_t CVPixelBufferGetPlaneCount(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x1F40DFD88](pixelBuffer);
}

size_t CVPixelBufferGetWidth(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x1F40DFD98](pixelBuffer);
}

size_t CVPixelBufferGetWidthOfPlane(CVPixelBufferRef pixelBuffer, size_t planeIndex)
{
  return MEMORY[0x1F40DFDA0](pixelBuffer, planeIndex);
}

Boolean CVPixelBufferIsPlanar(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x1F40DFDB0](pixelBuffer);
}

CVReturn CVPixelBufferLockBaseAddress(CVPixelBufferRef pixelBuffer, CVPixelBufferLockFlags lockFlags)
{
  return MEMORY[0x1F40DFDB8](pixelBuffer, lockFlags);
}

CVReturn CVPixelBufferPoolCreate(CFAllocatorRef allocator, CFDictionaryRef poolAttributes, CFDictionaryRef pixelBufferAttributes, CVPixelBufferPoolRef *poolOut)
{
  return MEMORY[0x1F40DFDC0](allocator, poolAttributes, pixelBufferAttributes, poolOut);
}

CVReturn CVPixelBufferPoolCreatePixelBuffer(CFAllocatorRef allocator, CVPixelBufferPoolRef pixelBufferPool, CVPixelBufferRef *pixelBufferOut)
{
  return MEMORY[0x1F40DFDC8](allocator, pixelBufferPool, pixelBufferOut);
}

CFDictionaryRef CVPixelBufferPoolGetPixelBufferAttributes(CVPixelBufferPoolRef pool)
{
  return (CFDictionaryRef)MEMORY[0x1F40DFDF0](pool);
}

void CVPixelBufferPoolRelease(CVPixelBufferPoolRef pixelBufferPool)
{
}

void CVPixelBufferRelease(CVPixelBufferRef texture)
{
}

CVPixelBufferRef CVPixelBufferRetain(CVPixelBufferRef texture)
{
  return (CVPixelBufferRef)MEMORY[0x1F40DFE40](texture);
}

CVReturn CVPixelBufferUnlockBaseAddress(CVPixelBufferRef pixelBuffer, CVPixelBufferLockFlags unlockFlags)
{
  return MEMORY[0x1F40DFE48](pixelBuffer, unlockFlags);
}

uint64_t CoreIKCreateAltruisticSolverInstance()
{
  return MEMORY[0x1F4113E40]();
}

uint64_t CoreIKDestroySolver()
{
  return MEMORY[0x1F4113E48]();
}

uint64_t CoreIKSolverGetTargetBufferSize()
{
  return MEMORY[0x1F4113E50]();
}

uint64_t CoreIKSolverGetTargetName()
{
  return MEMORY[0x1F4113E58]();
}

uint64_t CoreIKSolverGetTargetParentName()
{
  return MEMORY[0x1F4113E60]();
}

uint64_t CreateABPK3DLiftingAlgorithm()
{
  return MEMORY[0x1F41081A0]();
}

uint64_t FigCFDictionaryGetCGRectIfPresent()
{
  return MEMORY[0x1F40DC9A8]();
}

uint64_t IOHIDEventGetFloatValue()
{
  return MEMORY[0x1F40E89F8]();
}

uint64_t IOHIDEventGetTimeStamp()
{
  return MEMORY[0x1F40E8A28]();
}

uint64_t IOHIDEventGetType()
{
  return MEMORY[0x1F40E8A38]();
}

CFArrayRef IOHIDEventSystemClientCopyServices(IOHIDEventSystemClientRef client)
{
  return (CFArrayRef)MEMORY[0x1F40E8AB8](client);
}

uint64_t IOHIDEventSystemClientCreateWithType()
{
  return MEMORY[0x1F40E8AC8]();
}

uint64_t IOHIDEventSystemClientRegisterEventCallback()
{
  return MEMORY[0x1F40E8AF0]();
}

uint64_t IOHIDEventSystemClientScheduleWithDispatchQueue()
{
  return MEMORY[0x1F40E8B18]();
}

uint64_t IOHIDEventSystemClientSetMatching()
{
  return MEMORY[0x1F40E8B38]();
}

uint64_t IOHIDEventSystemClientUnregisterEventCallback()
{
  return MEMORY[0x1F40E8B68]();
}

uint64_t IOHIDEventSystemClientUnscheduleFromDispatchQueue()
{
  return MEMORY[0x1F40E8B88]();
}

CFTypeRef IOHIDServiceClientCopyProperty(IOHIDServiceClientRef service, CFStringRef key)
{
  return (CFTypeRef)MEMORY[0x1F40E8D20](service, key);
}

Boolean IOHIDServiceClientSetProperty(IOHIDServiceClientRef service, CFStringRef key, CFTypeRef property)
{
  return MEMORY[0x1F40E8D60](service, key, property);
}

size_t IOSurfaceGetAllocSize(IOSurfaceRef buffer)
{
  return MEMORY[0x1F40E9350](buffer);
}

void *__cdecl IOSurfaceGetBaseAddress(IOSurfaceRef buffer)
{
  return (void *)MEMORY[0x1F40E9358](buffer);
}

size_t IOSurfaceGetBytesPerElement(IOSurfaceRef buffer)
{
  return MEMORY[0x1F40E9398](buffer);
}

size_t IOSurfaceGetBytesPerRow(IOSurfaceRef buffer)
{
  return MEMORY[0x1F40E93A8](buffer);
}

size_t IOSurfaceGetHeight(IOSurfaceRef buffer)
{
  return MEMORY[0x1F40E9440](buffer);
}

size_t IOSurfaceGetHeightOfPlane(IOSurfaceRef buffer, size_t planeIndex)
{
  return MEMORY[0x1F40E9450](buffer, planeIndex);
}

IOSurfaceID IOSurfaceGetID(IOSurfaceRef buffer)
{
  return MEMORY[0x1F40E9460](buffer);
}

OSType IOSurfaceGetPixelFormat(IOSurfaceRef buffer)
{
  return MEMORY[0x1F40E9480](buffer);
}

int32_t IOSurfaceGetUseCount(IOSurfaceRef buffer)
{
  return MEMORY[0x1F40E94E8](buffer);
}

size_t IOSurfaceGetWidth(IOSurfaceRef buffer)
{
  return MEMORY[0x1F40E94F8](buffer);
}

size_t IOSurfaceGetWidthOfPlane(IOSurfaceRef buffer, size_t planeIndex)
{
  return MEMORY[0x1F40E9508](buffer, planeIndex);
}

kern_return_t IOSurfaceLock(IOSurfaceRef buffer, IOSurfaceLockOptions options, uint32_t *seed)
{
  return MEMORY[0x1F40E9540](buffer, *(void *)&options, seed);
}

IOSurfaceRef IOSurfaceLookup(IOSurfaceID csid)
{
  return (IOSurfaceRef)MEMORY[0x1F40E9550](*(void *)&csid);
}

uint64_t IOSurfaceNotifierCreate()
{
  return MEMORY[0x1F40E9570]();
}

uint64_t IOSurfaceNotifierSetDispatchQueue()
{
  return MEMORY[0x1F40E9578]();
}

void IOSurfaceSetValue(IOSurfaceRef buffer, CFStringRef key, CFTypeRef value)
{
}

kern_return_t IOSurfaceUnlock(IOSurfaceRef buffer, IOSurfaceLockOptions options, uint32_t *seed)
{
  return MEMORY[0x1F40E9630](buffer, *(void *)&options, seed);
}

uint64_t MGCopyAnswer()
{
  return MEMORY[0x1F417CDE0]();
}

uint64_t MGGetBoolAnswer()
{
  return MEMORY[0x1F417CE00]();
}

uint64_t MGGetProductType()
{
  return MEMORY[0x1F417CE18]();
}

uint64_t MGGetSInt32Answer()
{
  return MEMORY[0x1F417CE28]();
}

uint64_t MGIsDeviceOneOfType()
{
  return MEMORY[0x1F417CE48]();
}

id MTLCreateSystemDefaultDevice(void)
{
  return (id)MEMORY[0x1F40EDE00]();
}

Class NSClassFromString(NSString *aClassName)
{
  return (Class)MEMORY[0x1F40E7010](aClassName);
}

uint64_t NSLocalizedFileSizeDescription()
{
  return MEMORY[0x1F40E7168]();
}

uint64_t NSPopAutoreleasePool()
{
  return MEMORY[0x1F40E71E0]();
}

uint64_t NSPushAutoreleasePool()
{
  return MEMORY[0x1F40E71F0]();
}

NSArray *__cdecl NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory directory, NSSearchPathDomainMask domainMask, BOOL expandTilde)
{
  return (NSArray *)MEMORY[0x1F40E7248](directory, domainMask, expandTilde);
}

SEL NSSelectorFromString(NSString *aSelectorName)
{
  return (SEL)MEMORY[0x1F40E7258](aSelectorName);
}

NSString *__cdecl NSStringFromClass(Class aClass)
{
  return (NSString *)MEMORY[0x1F40E7280](aClass);
}

NSString *__cdecl NSStringFromSelector(SEL aSelector)
{
  return (NSString *)MEMORY[0x1F40E72B0](aSelector);
}

NSString *NSTemporaryDirectory(void)
{
  return (NSString *)MEMORY[0x1F40E72C8]();
}

int32_t NSVersionOfRunTimeLibrary(const char *libraryName)
{
  return MEMORY[0x1F40C99B8](libraryName);
}

SCNetworkReachabilityRef SCNetworkReachabilityCreateWithAddress(CFAllocatorRef allocator, const sockaddr *address)
{
  return (SCNetworkReachabilityRef)MEMORY[0x1F4101EE8](allocator, address);
}

Boolean SCNetworkReachabilityGetFlags(SCNetworkReachabilityRef target, SCNetworkReachabilityFlags *flags)
{
  return MEMORY[0x1F4101F08](target, flags);
}

uint64_t SetDefaultCameraCalibrationData()
{
  return MEMORY[0x1F410A0E0]();
}

uint64_t SetDefaultImuCalibrationData()
{
  return MEMORY[0x1F410A0E8]();
}

uint64_t SetDefaultJasperCalibrationData()
{
  return MEMORY[0x1F410A0F0]();
}

OSStatus VTPixelRotationSessionCreate(CFAllocatorRef allocator, VTPixelRotationSessionRef *pixelRotationSessionOut)
{
  return MEMORY[0x1F4103490](allocator, pixelRotationSessionOut);
}

void VTPixelRotationSessionInvalidate(VTPixelRotationSessionRef session)
{
}

OSStatus VTPixelRotationSessionRotateImage(VTPixelRotationSessionRef session, CVPixelBufferRef sourceBuffer, CVPixelBufferRef destinationBuffer)
{
  return MEMORY[0x1F41034A8](session, sourceBuffer, destinationBuffer);
}

OSStatus VTPixelTransferSessionCreate(CFAllocatorRef allocator, VTPixelTransferSessionRef *pixelTransferSessionOut)
{
  return MEMORY[0x1F41034D0](allocator, pixelTransferSessionOut);
}

void VTPixelTransferSessionInvalidate(VTPixelTransferSessionRef session)
{
}

OSStatus VTPixelTransferSessionTransferImage(VTPixelTransferSessionRef session, CVPixelBufferRef sourceBuffer, CVPixelBufferRef destinationBuffer)
{
  return MEMORY[0x1F41034F0](session, sourceBuffer, destinationBuffer);
}

OSStatus VTSessionSetProperties(VTSessionRef session, CFDictionaryRef propertyDictionary)
{
  return MEMORY[0x1F4103530](session, propertyDictionary);
}

OSStatus VTSessionSetProperty(VTSessionRef session, CFStringRef propertyKey, CFTypeRef propertyValue)
{
  return MEMORY[0x1F4103538](session, propertyKey, propertyValue);
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

uint64_t _CFRunLoopSetPerCalloutAutoreleasepoolEnabled()
{
  return MEMORY[0x1F40D90C0]();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

void cnnavigation::ENUToECEFJacobian::~ENUToECEFJacobian(cnnavigation::ENUToECEFJacobian *this)
{
}

uint64_t cnnavigation::ECEFToENU()
{
  return MEMORY[0x1F41141D8]();
}

uint64_t cnnavigation::ECEFToLLA()
{
  return MEMORY[0x1F41141E0]();
}

uint64_t cnnavigation::ENUToECEF()
{
  return MEMORY[0x1F41141E8]();
}

{
  return MEMORY[0x1F41141F0]();
}

uint64_t cnnavigation::LLAToECEF()
{
  return MEMORY[0x1F41141F8]();
}

void cva::imageViewFromPixelBuffer<cva::Matrix<unsigned char,4u,1u,false>>()
{
  while (1)
    ;
}

void cva::imageViewFromPixelBuffer<unsigned char>()
{
  while (1)
    ;
}

uint64_t cva::Logger::logInCategory()
{
  return MEMORY[0x1F41139E8]();
}

uint64_t cva::Logger::instance(cva::Logger *this)
{
  return MEMORY[0x1F41139F0](this);
}

void cva::VecLib<float>::gemm()
{
  while (1)
    ;
}

void cva::VecLib<float>::gemv()
{
  while (1)
    ;
}

uint64_t cva::vecLib::gesvd<float>()
{
  return MEMORY[0x1F4113A00]();
}

uint64_t cva::imwrite<cva::Matrix<unsigned char,4u,1u,false>>()
{
  return MEMORY[0x1F4113A18]();
}

uint64_t cva::imwrite<unsigned char>()
{
  return MEMORY[0x1F4113A20]();
}

uint64_t cva::imwrite<unsigned short>()
{
  return MEMORY[0x1F4113A28]();
}

void arkit::KeyMapBuffer<void const*,std::vector<unsigned char>>::find()
{
  while (1)
    ;
}

void arkit::KeyMapBuffer<void const*,std::vector<unsigned char>>::insert()
{
  while (1)
    ;
}

void arkit::KeyMapBuffer<void const*,std::vector<unsigned char>>::KeyMapBuffer()
{
  while (1)
    ;
}

uint64_t std::stringbuf::str()
{
  return MEMORY[0x1F417E3A8]();
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x1F417E408](this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return (std::locale)MEMORY[0x1F417E418](this);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const std::string *a2)
{
  return (std::logic_error *)MEMORY[0x1F417E440](this, a2);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x1F417E448](this, a2);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const char *a2)
{
  return (std::runtime_error *)MEMORY[0x1F417E4B8](this, a2);
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x1F417E530](this);
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x1F417E588](__n);
}

void std::string::resize(std::string *this, std::string::size_type __n, std::string::value_type __c)
{
}

void std::string::push_back(std::string *this, std::string::value_type __c)
{
}

std::string *__cdecl std::string::basic_string(std::string *this, const std::string *__str, std::string::size_type __pos, std::string::size_type __n, std::allocator<char> *__a)
{
  return (std::string *)MEMORY[0x1F417E660](this, __str, __pos, __n, __a);
}

std::string *__cdecl std::string::operator=(std::string *this, const std::string *__str)
{
  return (std::string *)MEMORY[0x1F417E670](this, __str);
}

uint64_t std::filebuf::open()
{
  return MEMORY[0x1F417E728]();
}

uint64_t std::filebuf::close()
{
  return MEMORY[0x1F417E730]();
}

uint64_t std::filebuf::basic_filebuf()
{
  return MEMORY[0x1F417E740]();
}

uint64_t std::filebuf::~filebuf()
{
  return MEMORY[0x1F417E748]();
}

uint64_t std::istream::peek()
{
  return MEMORY[0x1F417E760]();
}

uint64_t std::istream::ignore()
{
  return MEMORY[0x1F417E798]();
}

uint64_t std::istream::sentry::sentry()
{
  return MEMORY[0x1F417E7A0]();
}

uint64_t std::istream::~istream()
{
  return MEMORY[0x1F417E7C0]();
}

uint64_t std::istream::operator>>()
{
  return MEMORY[0x1F417E7D8]();
}

{
  return MEMORY[0x1F417E7E0]();
}

uint64_t std::ostream::put()
{
  return MEMORY[0x1F417E830]();
}

uint64_t std::ostream::flush()
{
  return MEMORY[0x1F417E838]();
}

uint64_t std::ostream::write()
{
  return MEMORY[0x1F417E840]();
}

uint64_t std::ostream::sentry::sentry()
{
  return MEMORY[0x1F417E848]();
}

uint64_t std::ostream::sentry::~sentry()
{
  return MEMORY[0x1F417E850]();
}

uint64_t std::ostream::~ostream()
{
  return MEMORY[0x1F417E860]();
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x1F417E880]();
}

{
  return MEMORY[0x1F417E898]();
}

{
  return MEMORY[0x1F417E8A0]();
}

{
  return MEMORY[0x1F417E8B0]();
}

uint64_t std::streambuf::basic_streambuf()
{
  return MEMORY[0x1F417E978]();
}

uint64_t std::streambuf::~streambuf()
{
  return MEMORY[0x1F417E980]();
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
}

void std::locale::~locale(std::locale *this)
{
}

void std::ios_base::__set_badbit_and_consider_rethrow(std::ios_base *this)
{
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
}

uint64_t std::ios::~ios()
{
  return MEMORY[0x1F417EE40]();
}

void std::exception::~exception(std::exception *this)
{
}

void std::terminate(void)
{
}

void operator delete[]()
{
  while (1)
    ;
}

void operator delete(void *__p)
{
  while (1)
    ;
}

void operator delete()
{
  while (1)
    ;
}

void operator new[]()
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz)
{
  while (1)
    ;
}

void operator new()
{
  while (1)
    ;
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x1F417EF30](thrown_size);
}

int __cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle)
{
  return MEMORY[0x1F40C9B60](lpfunc, obj, lpdso_handle);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x1F417EF48](a1);
}

void __cxa_end_catch(void)
{
}

void __cxa_free_exception(void *a1)
{
}

void __cxa_guard_abort(__guard *a1)
{
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x1F417EF80](a1);
}

void __cxa_guard_release(__guard *a1)
{
}

void __cxa_rethrow(void)
{
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
}

double __exp10(double a1)
{
  MEMORY[0x1F40C9B90](a1);
  return result;
}

float __exp10f(float a1)
{
  MEMORY[0x1F40C9B98](a1);
  return result;
}

uint64_t __invert_d4()
{
  return MEMORY[0x1F40C9BE8]();
}

simd_float3x3 __invert_f3(simd_float3x3 a1)
{
  MEMORY[0x1F40C9BF8]((__n128)a1.columns[0], (__n128)a1.columns[1], (__n128)a1.columns[2]);
  result.columns[2].i64[1] = v6;
  result.columns[2].i64[0] = v5;
  result.columns[1].i64[1] = v4;
  result.columns[1].i64[0] = v3;
  result.columns[0].i64[1] = v2;
  result.columns[0].i64[0] = v1;
  return result;
}

simd_float4x4 __invert_f4(simd_float4x4 a1)
{
  MEMORY[0x1F40C9C00]((__n128)a1.columns[0], (__n128)a1.columns[1], (__n128)a1.columns[2], (__n128)a1.columns[3]);
  result.columns[3].i64[1] = v8;
  result.columns[3].i64[0] = v7;
  result.columns[2].i64[1] = v6;
  result.columns[2].i64[0] = v5;
  result.columns[1].i64[1] = v4;
  result.columns[1].i64[0] = v3;
  result.columns[0].i64[1] = v2;
  result.columns[0].i64[0] = v1;
  return result;
}

uint64_t __memcpy_chk()
{
  return MEMORY[0x1F40C9C28]();
}

uint64_t __memset_chk()
{
  return MEMORY[0x1F40C9C38]();
}

uint64_t __realtime_assert_rtn()
{
  return MEMORY[0x1F4181E88]();
}

__double2 __sincos_stret(double a1)
{
  MEMORY[0x1F40C9C80](a1);
  result.__cosval = v2;
  result.__sinval = v1;
  return result;
}

__float2 __sincosf_stret(float a1)
{
  MEMORY[0x1F40C9C88](a1);
  result.__cosval = v2;
  result.__sinval = v1;
  return result;
}

const mach_header *__cdecl _dyld_get_image_header(uint32_t image_index)
{
  return (const mach_header *)MEMORY[0x1F40C9E08](*(void *)&image_index);
}

uint32_t _dyld_image_count(void)
{
  return MEMORY[0x1F40C9E60]();
}

os_activity_t _os_activity_create(void *dso, const char *description, os_activity_t activity, os_activity_flag_t flags)
{
  return (os_activity_t)MEMORY[0x1F40C9F70](dso, description, activity, *(void *)&flags);
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

uint64_t _os_log_send_and_compose_impl()
{
  return MEMORY[0x1F40C9FF8]();
}

uint64_t _sl_dlopen()
{
  return MEMORY[0x1F415B160]();
}

void abort(void)
{
}

uint64_t abort_report_np()
{
  return MEMORY[0x1F40CA1E8]();
}

long double acos(long double __x)
{
  MEMORY[0x1F40CA330](__x);
  return result;
}

float acosf(float a1)
{
  MEMORY[0x1F40CA340](a1);
  return result;
}

uint32_t arc4random_uniform(uint32_t __upper_bound)
{
  return MEMORY[0x1F40CA3C0](*(void *)&__upper_bound);
}

uint64_t archive_entry_filetype()
{
  return MEMORY[0x1F417DFE8]();
}

uint64_t archive_entry_free()
{
  return MEMORY[0x1F417DFF0]();
}

uint64_t archive_entry_new()
{
  return MEMORY[0x1F417DFF8]();
}

uint64_t archive_entry_pathname()
{
  return MEMORY[0x1F417E000]();
}

uint64_t archive_entry_set_atime()
{
  return MEMORY[0x1F417E018]();
}

uint64_t archive_entry_set_birthtime()
{
  return MEMORY[0x1F417E020]();
}

uint64_t archive_entry_set_ctime()
{
  return MEMORY[0x1F417E028]();
}

uint64_t archive_entry_set_filetype()
{
  return MEMORY[0x1F417E030]();
}

uint64_t archive_entry_set_mtime()
{
  return MEMORY[0x1F417E038]();
}

uint64_t archive_entry_set_pathname()
{
  return MEMORY[0x1F417E040]();
}

uint64_t archive_entry_set_perm()
{
  return MEMORY[0x1F417E048]();
}

uint64_t archive_entry_set_size()
{
  return MEMORY[0x1F417E050]();
}

uint64_t archive_error_string()
{
  return MEMORY[0x1F417E080]();
}

uint64_t archive_read_data()
{
  return MEMORY[0x1F417E0A0]();
}

uint64_t archive_read_free()
{
  return MEMORY[0x1F417E110]();
}

uint64_t archive_read_new()
{
  return MEMORY[0x1F417E118]();
}

uint64_t archive_read_next_header()
{
  return MEMORY[0x1F417E120]();
}

uint64_t archive_read_open_filename()
{
  return MEMORY[0x1F417E140]();
}

uint64_t archive_read_open_memory()
{
  return MEMORY[0x1F417E148]();
}

uint64_t archive_read_support_filter_compress()
{
  return MEMORY[0x1F417E168]();
}

uint64_t archive_read_support_format_zip()
{
  return MEMORY[0x1F417E1A0]();
}

uint64_t archive_set_error()
{
  return MEMORY[0x1F417E1B0]();
}

uint64_t archive_write_data()
{
  return MEMORY[0x1F417E1D8]();
}

uint64_t archive_write_free()
{
  return MEMORY[0x1F417E208]();
}

uint64_t archive_write_header()
{
  return MEMORY[0x1F417E210]();
}

uint64_t archive_write_new()
{
  return MEMORY[0x1F417E218]();
}

uint64_t archive_write_open()
{
  return MEMORY[0x1F417E220]();
}

uint64_t archive_write_open_filename()
{
  return MEMORY[0x1F417E230]();
}

uint64_t archive_write_set_format_zip()
{
  return MEMORY[0x1F417E260]();
}

float asinf(float a1)
{
  MEMORY[0x1F40CA3D8](a1);
  return result;
}

long double atan(long double __x)
{
  MEMORY[0x1F40CA450](__x);
  return result;
}

long double atan2(long double __y, long double __x)
{
  MEMORY[0x1F40CA460](__y, __x);
  return result;
}

float atan2f(float a1, float a2)
{
  MEMORY[0x1F40CA468](a1, a2);
  return result;
}

void bzero(void *a1, size_t a2)
{
}

objc_property_t *__cdecl class_copyPropertyList(Class cls, unsigned int *outCount)
{
  return (objc_property_t *)MEMORY[0x1F4181500](cls, outCount);
}

id class_createInstance(Class cls, size_t extraBytes)
{
  return (id)MEMORY[0x1F4181510](cls, extraBytes);
}

Ivar class_getInstanceVariable(Class cls, const char *name)
{
  return (Ivar)MEMORY[0x1F4181538](cls, name);
}

IMP class_getMethodImplementation(Class cls, SEL name)
{
  return (IMP)MEMORY[0x1F4181540](cls, name);
}

objc_property_t class_getProperty(Class cls, const char *name)
{
  return (objc_property_t)MEMORY[0x1F4181550](cls, name);
}

Class class_getSuperclass(Class cls)
{
  return (Class)MEMORY[0x1F4181558](cls);
}

__uint64_t clock_gettime_nsec_np(clockid_t __clock_id)
{
  return MEMORY[0x1F40CB3D8](*(void *)&__clock_id);
}

long double cos(long double __x)
{
  MEMORY[0x1F40CB8A8](__x);
  return result;
}

float cosf(float a1)
{
  MEMORY[0x1F40CB8B0](a1);
  return result;
}

void dispatch_activate(dispatch_object_t object)
{
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_assert_queue_V2(dispatch_queue_t queue)
{
}

void dispatch_assert_queue_not_V2(dispatch_queue_t queue)
{
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

void *__cdecl dispatch_get_specific(const void *key)
{
  return (void *)MEMORY[0x1F40CBA68](key);
}

dispatch_group_t dispatch_group_create(void)
{
  return (dispatch_group_t)MEMORY[0x1F40CBA88]();
}

void dispatch_group_enter(dispatch_group_t group)
{
}

void dispatch_group_leave(dispatch_group_t group)
{
}

intptr_t dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)
{
  return MEMORY[0x1F40CBAC0](group, timeout);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

uint64_t dispatch_pthread_root_queue_create()
{
  return MEMORY[0x1F40CBB98]();
}

dispatch_queue_attr_t dispatch_queue_attr_make_initially_inactive(dispatch_queue_attr_t attr)
{
  return (dispatch_queue_attr_t)MEMORY[0x1F40CBBA0](attr);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency(dispatch_queue_attr_t attr, dispatch_autorelease_frequency_t frequency)
{
  return (dispatch_queue_attr_t)MEMORY[0x1F40CBBA8](attr, frequency);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return (dispatch_queue_attr_t)MEMORY[0x1F40CBBB8](attr, *(void *)&qos_class, *(void *)&relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x1F40CBBC0](label, attr);
}

dispatch_queue_t dispatch_queue_create_with_target_V2(const char *label, dispatch_queue_attr_t attr, dispatch_queue_t target)
{
  return (dispatch_queue_t)MEMORY[0x1F40CBBD0](label, attr, target);
}

const char *__cdecl dispatch_queue_get_label(dispatch_queue_t queue)
{
  return (const char *)MEMORY[0x1F40CBBD8](queue);
}

void dispatch_queue_set_specific(dispatch_queue_t queue, const void *key, void *context, dispatch_function_t destructor)
{
}

void dispatch_resume(dispatch_object_t object)
{
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return (dispatch_semaphore_t)MEMORY[0x1F40CBC30](value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return MEMORY[0x1F40CBC40](dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return MEMORY[0x1F40CBC50](dsema, timeout);
}

void dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t queue)
{
}

void dispatch_source_cancel(dispatch_source_t source)
{
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return (dispatch_source_t)MEMORY[0x1F40CBC98](type, handle, mask, queue);
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
{
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x1F40CBD30](when, delta);
}

dispatch_workloop_t dispatch_workloop_create_inactive(const char *label)
{
  return (dispatch_workloop_t)MEMORY[0x1F40CBD58](label);
}

uint64_t dispatch_workloop_set_qos_class_floor()
{
  return MEMORY[0x1F40CBD80]();
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return (void *)MEMORY[0x1F40CBDB8](__path, *(void *)&__mode);
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return (void *)MEMORY[0x1F40CBDC8](__handle, __symbol);
}

uint64_t dyld_program_sdk_at_least()
{
  return MEMORY[0x1F40CBEC8]();
}

uint64_t espresso_context_destroy()
{
  return MEMORY[0x1F4118648]();
}

uint64_t espresso_context_set_low_precision_accumulation()
{
  return MEMORY[0x1F4118658]();
}

uint64_t espresso_create_context()
{
  return MEMORY[0x1F4118668]();
}

uint64_t espresso_create_plan()
{
  return MEMORY[0x1F4118678]();
}

uint64_t espresso_network_bind_buffer()
{
  return MEMORY[0x1F41186E0]();
}

uint64_t espresso_network_bind_direct_cvpixelbuffer()
{
  return MEMORY[0x1F4118700]();
}

uint64_t espresso_network_bind_input_vimagebuffer_bgra8()
{
  return MEMORY[0x1F4118718]();
}

uint64_t espresso_network_declare_input()
{
  return MEMORY[0x1F4118760]();
}

uint64_t espresso_network_declare_output()
{
  return MEMORY[0x1F4118770]();
}

uint64_t espresso_network_get_version()
{
  return MEMORY[0x1F4118780]();
}

uint64_t espresso_network_query_blob_dimensions()
{
  return MEMORY[0x1F4118788]();
}

uint64_t espresso_network_select_configuration()
{
  return MEMORY[0x1F41187A0]();
}

uint64_t espresso_plan_add_network()
{
  return MEMORY[0x1F41187D8]();
}

uint64_t espresso_plan_build()
{
  return MEMORY[0x1F41187F0]();
}

uint64_t espresso_plan_build_clean()
{
  return MEMORY[0x1F41187F8]();
}

uint64_t espresso_plan_destroy()
{
  return MEMORY[0x1F4118818]();
}

uint64_t espresso_plan_execute_sync()
{
  return MEMORY[0x1F4118828]();
}

long double exp(long double __x)
{
  MEMORY[0x1F40CBFE0](__x);
  return result;
}

long double exp2(long double __x)
{
  MEMORY[0x1F40CBFE8](__x);
  return result;
}

float expf(float a1)
{
  MEMORY[0x1F40CBFF8](a1);
  return result;
}

int fflush(FILE *a1)
{
  return MEMORY[0x1F40CC0C8](a1);
}

int fileno(FILE *a1)
{
  return MEMORY[0x1F40CC110](a1);
}

long double fmod(long double __x, long double __y)
{
  MEMORY[0x1F40CC1A0](__x, __y);
  return result;
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x1F40CC1D8](a1, a2);
}

int fputs(const char *a1, FILE *a2)
{
  return MEMORY[0x1F40CC1F0](a1, a2);
}

void free(void *a1)
{
}

long double hypot(long double __x, long double __y)
{
  MEMORY[0x1F40CC630](__x, __y);
  return result;
}

int isatty(int a1)
{
  return MEMORY[0x1F40CC6B0](*(void *)&a1);
}

uint64_t kdebug_trace()
{
  return MEMORY[0x1F40CC700]();
}

long double log(long double __x)
{
  MEMORY[0x1F40CC878](__x);
  return result;
}

long double log10(long double __x)
{
  MEMORY[0x1F40CC880](__x);
  return result;
}

long double log2(long double __x)
{
  MEMORY[0x1F40CC8A8](__x);
  return result;
}

float log2f(float a1)
{
  MEMORY[0x1F40CC8B0](a1);
  return result;
}

float logf(float a1)
{
  MEMORY[0x1F40CC8C0](a1);
  return result;
}

uint64_t mach_absolute_time(void)
{
  return MEMORY[0x1F40CC910]();
}

uint64_t mach_get_times()
{
  return MEMORY[0x1F40CC948]();
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return MEMORY[0x1F40CCA60](info);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCB90](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCB98](size, type_id);
}

int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
{
  return MEMORY[0x1F40CCBA0](memptr, alignment, size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCBA8](ptr, size, type_id);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x1F40CCCE8](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1F40CCCF0](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x1F40CCD10](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x1F40CCD20](__b, *(void *)&__c, __len);
}

void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
{
}

uint32_t notify_cancel(int token)
{
  return MEMORY[0x1F40CD028](*(void *)&token);
}

uint32_t notify_get_state(int token, uint64_t *state64)
{
  return MEMORY[0x1F40CD040](*(void *)&token, state64);
}

uint32_t notify_register_dispatch(const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
{
  return MEMORY[0x1F40CD060](name, out_token, queue, handler);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x1F4181638](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x1F4181648]();
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x1F4181660](a1);
}

{
  MEMORY[0x1F4181668](context);
}

{
  return (void *)MEMORY[0x1F4181670]();
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x1F4181678](a1);
}

id objc_begin_catch(void *exc_buf)
{
  return (id)MEMORY[0x1F4181680](exc_buf);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x1F4181688]();
}

void objc_copyStruct(void *dest, const void *src, ptrdiff_t size, BOOL atomic, BOOL hasStrong)
{
}

void objc_copyWeak(id *to, id *from)
{
}

void objc_destroyWeak(id *location)
{
}

void objc_end_catch(void)
{
}

void objc_enumerateClasses(const void *image, const char *namePrefix, Protocol *conformingTo, Class subclassing, void *block)
{
}

void objc_enumerationMutation(id obj)
{
}

void objc_exception_rethrow(void)
{
}

void objc_exception_throw(id exception)
{
}

Class objc_getClass(const char *name)
{
  return (Class)MEMORY[0x1F4181728](name);
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return (id)MEMORY[0x1F4181748](self, _cmd, offset, atomic);
}

id objc_initWeak(id *location, id val)
{
  return (id)MEMORY[0x1F4181758](location, val);
}

id objc_loadWeakRetained(id *location)
{
  return (id)MEMORY[0x1F4181780](location);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x1F41817A8](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x1F41817B0]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x1F41817B8]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x1F41817C0]();
}

uint64_t objc_opt_respondsToSelector()
{
  return MEMORY[0x1F41817C8]();
}

uint64_t self
{
  return MEMORY[0x1F41817D0]();
}

void objc_release(id a1)
{
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x1F41818B0](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x1F41818B8](a1);
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x1F41818C0](a1);
}

id objc_retainAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x1F41818C8](a1);
}

id objc_retainBlock(id a1)
{
  return (id)MEMORY[0x1F41818D0](a1);
}

void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_setProperty_atomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_setProperty_nonatomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_setProperty_nonatomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_storeStrong(id *location, id obj)
{
}

id objc_storeWeak(id *location, id obj)
{
  return (id)MEMORY[0x1F4181A18](location, obj);
}

int objc_sync_enter(id obj)
{
  return MEMORY[0x1F4181A28](obj);
}

int objc_sync_exit(id obj)
{
  return MEMORY[0x1F4181A30](obj);
}

void objc_terminate(void)
{
}

id objc_unsafeClaimAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x1F4181A40](a1);
}

Class object_getClass(id a1)
{
  return (Class)MEMORY[0x1F4181A58](a1);
}

void object_setIvar(id obj, Ivar ivar, id value)
{
}

void os_activity_scope_enter(os_activity_t activity, os_activity_scope_state_t state)
{
}

void os_activity_scope_leave(os_activity_scope_state_t state)
{
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x1F40CD360](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x1F40CD3B8](oslog, type);
}

uint64_t os_transaction_create()
{
  return MEMORY[0x1F40CD5A0]();
}

void os_unfair_lock_assert_not_owner(const os_unfair_lock *lock)
{
}

void os_unfair_lock_assert_owner(const os_unfair_lock *lock)
{
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
}

uint64_t os_unfair_lock_lock_with_options()
{
  return MEMORY[0x1F40CD5E8]();
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
}

uint64_t os_variant_has_internal_content()
{
  return MEMORY[0x1F40CD648]();
}

long double pow(long double __x, long double __y)
{
  MEMORY[0x1F40CD818](__x, __y);
  return result;
}

float powf(float a1, float a2)
{
  MEMORY[0x1F40CD828](a1, a2);
  return result;
}

int printf(const char *a1, ...)
{
  return MEMORY[0x1F40CD838](a1);
}

int proc_listallpids(void *buffer, int buffersize)
{
  return MEMORY[0x1F40CD870](buffer, *(void *)&buffersize);
}

int proc_name(int pid, void *buffer, uint32_t buffersize)
{
  return MEMORY[0x1F40CD888](*(void *)&pid, buffer, *(void *)&buffersize);
}

char *__cdecl property_copyAttributeValue(objc_property_t property, const char *attributeName)
{
  return (char *)MEMORY[0x1F4181AC0](property, attributeName);
}

const char *__cdecl property_getName(objc_property_t property)
{
  return (const char *)MEMORY[0x1F4181AD0](property);
}

int pthread_attr_destroy(pthread_attr_t *a1)
{
  return MEMORY[0x1F40CD918](a1);
}

int pthread_attr_getschedparam(const pthread_attr_t *a1, sched_param *a2)
{
  return MEMORY[0x1F40CD920](a1, a2);
}

int pthread_attr_init(pthread_attr_t *a1)
{
  return MEMORY[0x1F40CD930](a1);
}

int pthread_attr_setinheritsched(pthread_attr_t *a1, int a2)
{
  return MEMORY[0x1F40CD948](a1, *(void *)&a2);
}

int pthread_attr_setschedparam(pthread_attr_t *a1, const sched_param *a2)
{
  return MEMORY[0x1F40CD950](a1, a2);
}

int pthread_attr_setschedpolicy(pthread_attr_t *a1, int a2)
{
  return MEMORY[0x1F40CD958](a1, *(void *)&a2);
}

uint64_t pthread_set_fixedpriority_self()
{
  return MEMORY[0x1F40CDB40]();
}

int puts(const char *a1)
{
  return MEMORY[0x1F40CDBB8](a1);
}

int rand(void)
{
  return MEMORY[0x1F40CDC08]();
}

int rand_r(unsigned int *a1)
{
  return MEMORY[0x1F40CDC10](a1);
}

float sinf(float a1)
{
  MEMORY[0x1F40CE060](a1);
  return result;
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x1F40CE080](__str, __size, __format);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x1F40CE158](__s1, __s2);
}

char *__cdecl strdup(const char *__s1)
{
  return (char *)MEMORY[0x1F40CE178](__s1);
}

char *__cdecl strerror(int __errnum)
{
  return (char *)MEMORY[0x1F40CE188](*(void *)&__errnum);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1F40CE1C8](__s);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x1F40CE1F0](__s1, __s2, __n);
}

int sysctl(int *a1, u_int a2, void *a3, size_t *a4, void *a5, size_t a6)
{
  return MEMORY[0x1F40CE3C0](a1, *(void *)&a2, a3, a4, a5, a6);
}

int sysctlnametomib(const char *a1, int *a2, size_t *a3)
{
  return MEMORY[0x1F40CE3E0](a1, a2, a3);
}

long double tan(long double __x)
{
  MEMORY[0x1F40CE420](__x);
  return result;
}

float tanf(float a1)
{
  MEMORY[0x1F40CE428](a1);
  return result;
}

kern_return_t task_info(task_name_t target_task, task_flavor_t flavor, task_info_t task_info_out, mach_msg_type_number_t *task_info_outCnt)
{
  return MEMORY[0x1F40CE470](*(void *)&target_task, *(void *)&flavor, task_info_out, task_info_outCnt);
}

time_t time(time_t *a1)
{
  return MEMORY[0x1F40CE588](a1);
}

vImage_Error vImageBuffer_Init(vImage_Buffer *buf, vImagePixelCount height, vImagePixelCount width, uint32_t pixelBits, vImage_Flags flags)
{
  return MEMORY[0x1F40D22A0](buf, height, width, *(void *)&pixelBits, *(void *)&flags);
}

void vImageCVImageFormat_Release(vImageCVImageFormatRef fmt)
{
}

vImage_Error vImageConvert_420Yp8_CbCr8ToARGB8888(const vImage_Buffer *srcYp, const vImage_Buffer *srcCbCr, const vImage_Buffer *dest, const vImage_YpCbCrToARGB *info, const uint8_t permuteMap[4], const uint8_t alpha, vImage_Flags flags)
{
  return MEMORY[0x1F40D23E8](srcYp, srcCbCr, dest, info, permuteMap, alpha, *(void *)&flags);
}

vImage_Error vImageConvert_Planar16FtoPlanarF(const vImage_Buffer *src, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1F40D25B0](src, dest, *(void *)&flags);
}

vImage_Error vImageConvert_YpCbCrToARGB_GenerateConversion(const vImage_YpCbCrToARGBMatrix *matrix, const vImage_YpCbCrPixelRange *pixelRange, vImage_YpCbCrToARGB *outInfo, vImageYpCbCrType inYpCbCrType, vImageARGBType outARGBType, vImage_Flags flags)
{
  return MEMORY[0x1F40D2780](matrix, pixelRange, outInfo, *(void *)&inYpCbCrType, *(void *)&outARGBType, *(void *)&flags);
}

vImage_Error vImageCopyBuffer(const vImage_Buffer *src, const vImage_Buffer *dest, size_t pixelSize, vImage_Flags flags)
{
  return MEMORY[0x1F40D2858](src, dest, pixelSize, *(void *)&flags);
}

vImage_Error vImageExtractChannel_ARGB8888(const vImage_Buffer *src, const vImage_Buffer *dest, uint64_t channelIndex, vImage_Flags flags)
{
  return MEMORY[0x1F40D28E0](src, dest, channelIndex, *(void *)&flags);
}

vImage_Error vImageHorizontalReflect_Planar8(const vImage_Buffer *src, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1F40D29C0](src, dest, *(void *)&flags);
}

uint64_t vImageMapping_CreateFromMap_Image8U()
{
  return MEMORY[0x1F40D2A48]();
}

uint64_t vImageMapping_Release()
{
  return MEMORY[0x1F40D2A50]();
}

vImage_Error vImageMin_PlanarF(const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImagePixelCount srcOffsetToROI_X, vImagePixelCount srcOffsetToROI_Y, vImagePixelCount kernel_height, vImagePixelCount kernel_width, vImage_Flags flags)
{
  return MEMORY[0x1F40D2AC0](src, dest, tempBuffer, srcOffsetToROI_X, srcOffsetToROI_Y, kernel_height, kernel_width, *(void *)&flags);
}

vImage_Error vImageOverwriteChannelsWithScalar_Planar16U(Pixel_16U scalar, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1F40D2B10](scalar, dest, *(void *)&flags);
}

vImage_Error vImageOverwriteChannelsWithScalar_Planar8(Pixel_8 scalar, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1F40D2B18](scalar, dest, *(void *)&flags);
}

vImage_Error vImagePermuteChannels_ARGB8888(const vImage_Buffer *src, const vImage_Buffer *dest, const uint8_t permuteMap[4], vImage_Flags flags)
{
  return MEMORY[0x1F40D2B60](src, dest, permuteMap, *(void *)&flags);
}

uint64_t vImageRemap_Image8U()
{
  return MEMORY[0x1F40D2C30]();
}

vImage_Error vImageRotate90_ARGB8888(const vImage_Buffer *src, const vImage_Buffer *dest, uint8_t rotationConstant, const Pixel_8888 backColor, vImage_Flags flags)
{
  return MEMORY[0x1F40D2C48](src, dest, rotationConstant, backColor, *(void *)&flags);
}

vImage_Error vImageRotate90_ARGBFFFF(const vImage_Buffer *src, const vImage_Buffer *dest, uint8_t rotationConstant, const Pixel_FFFF backColor, vImage_Flags flags)
{
  return MEMORY[0x1F40D2C58](src, dest, rotationConstant, backColor, *(void *)&flags);
}

vImage_Error vImageRotate90_Planar8(const vImage_Buffer *src, const vImage_Buffer *dest, uint8_t rotationConstant, Pixel_8 backColor, vImage_Flags flags)
{
  return MEMORY[0x1F40D2C78](src, dest, rotationConstant, backColor, *(void *)&flags);
}

vImage_Error vImageRotate90_PlanarF(const vImage_Buffer *src, const vImage_Buffer *dest, uint8_t rotationConstant, Pixel_F backColor, vImage_Flags flags)
{
  return MEMORY[0x1F40D2C80](src, dest, rotationConstant, *(void *)&flags, backColor);
}

vImage_Error vImageScale_ARGB8888(const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImage_Flags flags)
{
  return MEMORY[0x1F40D2CD8](src, dest, tempBuffer, *(void *)&flags);
}

vImage_Error vImageScale_Planar8(const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImage_Flags flags)
{
  return MEMORY[0x1F40D2D08](src, dest, tempBuffer, *(void *)&flags);
}

xpc_type_t xpc_get_type(xpc_object_t object)
{
  return (xpc_type_t)MEMORY[0x1F40CF148](object);
}