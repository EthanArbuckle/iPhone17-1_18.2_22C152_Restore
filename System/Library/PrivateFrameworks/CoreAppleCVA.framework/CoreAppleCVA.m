uint64_t cva::DictionaryHandler::getDictionary(cva::DictionaryHandler *this)
{
  return *(void *)this;
}

BOOL cva::Path::exists(const char **this)
{
  v1 = *this;
  if (v1[23] < 0) {
    v1 = *(const char **)v1;
  }
  return access(v1, 0) == 0;
}

void cva::Path::~Path(cva::Path *this)
{
  uint64_t v1 = *(void *)this;
  *(void *)this = 0;
  if (v1)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    MEMORY[0x2166B9890](v1, 0x1012C40EC159624);
  }
}

{
  uint64_t v1;

  uint64_t v1 = *(void *)this;
  *(void *)this = 0;
  if (v1)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    MEMORY[0x2166B9890](v1, 0x1012C40EC159624);
  }
}

void cva::Path::Path()
{
}

{
  operator new();
}

uint64_t cva::ItemHandler::getDictionary@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  if (!*(void *)this || (uint64_t v3 = this, objc_opt_class(), this = objc_opt_isKindOfClass(), (this & 1) == 0))
  {
    *a2 = 0;
    a2[1] = 0;
    return this;
  }
  v4 = *(const void **)v3;
  if (*(unsigned char *)(v3 + 8))
  {
    this = (uint64_t)operator new(0x28uLL);
    uint64_t v5 = this;
    *(void *)(this + 8) = 0;
    *(void *)(this + 16) = 0;
    *(void *)this = &unk_26C5FC400;
    *(void *)(this + 24) = v4;
    uint64_t v6 = this + 24;
    *(unsigned char *)(this + 32) = 1;
    if (!v4)
    {
      *(unsigned char *)(this + 32) = 0;
      goto LABEL_10;
    }
  }
  else
  {
    this = (uint64_t)operator new(0x28uLL);
    uint64_t v5 = this;
    *(void *)(this + 8) = 0;
    *(void *)(this + 16) = 0;
    *(void *)this = &unk_26C5FC400;
    *(void *)(this + 24) = v4;
    uint64_t v6 = this + 24;
    *(unsigned char *)(this + 32) = 0;
    if (!v4) {
      goto LABEL_10;
    }
  }
  this = (uint64_t)CFRetain(v4);
LABEL_10:
  *a2 = v6;
  a2[1] = v5;
  return this;
}

void sub_2153B8D4C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void cva::Path::Path(cva::Path *this, const cva::Path *a2)
{
}

{
  operator new();
}

CFTypeRef cva::DictionaryHandler::item@<X0>(id *this@<X0>, const __CFString *a2@<X1>, uint64_t a3@<X8>)
{
  CFTypeRef result = (CFTypeRef)[*this objectForKey:a2];
  char v6 = *((unsigned char *)this + 8);
  *(void *)a3 = result;
  *(unsigned char *)(a3 + 8) = v6;
  if (result)
  {
    return CFRetain(result);
  }
  else
  {
    *(unsigned char *)(a3 + 8) = 0;
  }
  return result;
}

BOOL cva::DictionaryHandler::hasKey(id *this, const __CFString *a2)
{
  v2 = [*this valueForKey:a2];
  BOOL v3 = v2 != 0;

  return v3;
}

BOOL cva::ItemHandler::isMatrixTypeOfSize(cva::ItemHandler *this, int a2, int a3)
{
  if (!cva::ItemHandler::isMatrixType(this)) {
    return 0;
  }
  cva::ItemHandler::getArray((uint64_t)this, &v23);
  if (!v23) {
    goto LABEL_25;
  }
  id v6 = *v23;
  if (*v23) {
    LODWORD(v6) = [v6 count];
  }
  if (v6 != a2)
  {
LABEL_25:
    BOOL v8 = 0;
    goto LABEL_26;
  }
  if (a2 < 1)
  {
    BOOL v8 = 1;
    goto LABEL_26;
  }
  uint64_t v7 = 0;
  BOOL v8 = 0;
  unint64_t v9 = a2;
  while (1)
  {
    v10 = v23;
    if (*v23 && v7 < (int)[*v23 count])
    {
      v11 = (const void *)[*v10 objectAtIndex:v7];
      v12 = v11;
      char v13 = *((unsigned char *)v10 + 8);
      v19 = v11;
      LOBYTE(v20) = v13;
      if (v11)
      {
        CFRetain(v11);
        goto LABEL_15;
      }
    }
    else
    {
      v19 = 0;
    }
    v12 = 0;
    LOBYTE(v20) = 0;
LABEL_15:
    cva::ItemHandler::getArray((uint64_t)&v19, &v21);
    if (v12) {
      CFRelease(v12);
    }
    if (!v21) {
      break;
    }
    v14 = *v21;
    if (*v21) {
      LODWORD(v14) = objc_msgSend(v14, "count", v19, v20);
    }
    if (v14 != a3) {
      break;
    }
    v15 = v22;
    if (v22 && !atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
    BOOL v8 = ++v7 >= v9;
    if (v9 == v7) {
      goto LABEL_26;
    }
  }
  v18 = v22;
  if (v22 && !atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
    std::__shared_weak_count::__release_weak(v18);
  }
LABEL_26:
  v16 = v24;
  if (v24 && !atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
  return v8;
}

void sub_2153B909C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_215436A24((uint64_t)va);
  _Unwind_Resume(a1);
}

void cva::ItemHandler::getMatrix<float>(cva::ItemHandler *a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  if (cva::ItemHandler::isMatrixType(a1))
  {
    cva::ItemHandler::getArray((uint64_t)a1, &v29);
    if (v29)
    {
      if (*v29)
      {
        int v24 = [*v29 count];
        if (v24 >= 1)
        {
          uint64_t v4 = 0;
          while (1)
          {
            uint64_t v5 = v29;
            if (!*v29 || v4 >= (int)[*v29 count]) {
              break;
            }
            id v6 = (void *)[*v5 objectAtIndex:v4];
            uint64_t v7 = v6;
            char v8 = *((unsigned char *)v5 + 8);
            memptr = v6;
            char v26 = v8;
            if (!v6) {
              goto LABEL_12;
            }
            CFRetain(v6);
LABEL_13:
            cva::ItemHandler::getArray((uint64_t)&memptr, &v27);
            if (v7) {
              CFRelease(v7);
            }
            unint64_t v9 = v27;
            if (v27)
            {
              if (v4)
              {
                int v11 = *(_DWORD *)(a2 + 16);
                int v10 = *(_DWORD *)(a2 + 20);
                v12 = *(_DWORD **)a2;
              }
              else
              {
                if (*v27) {
                  int v10 = [*v27 count];
                }
                else {
                  int v10 = 0;
                }
                *(_DWORD *)(a2 + 16) = v24;
                *(_DWORD *)(a2 + 20) = v10;
                unint64_t v13 = (v10 * v24);
                if (v13)
                {
                  v12 = *(_DWORD **)a2;
                  if (*(void *)(a2 + 8) < v13)
                  {
                    free(*(void **)a2);
                    size_t v14 = (4 * v13 + 31) & 0x7FFFFFFE0;
                    *(void *)a2 = 0;
                    *(void *)(a2 + 8) = v14 >> 2;
                    memptr = 0;
                    malloc_type_posix_memalign(&memptr, 0x20uLL, v14, 0x49090899uLL);
                    v12 = memptr;
                    *(void *)a2 = memptr;
                  }
                  int v11 = v24;
                }
                else
                {
                  free(*(void **)a2);
                  v12 = 0;
                  *(void *)a2 = 0;
                  *(void *)(a2 + 8) = 0;
                  int v11 = v24;
                }
              }
              uint64_t v15 = 0;
              for (int i = v4; ; i += v11)
              {
                id v17 = *v9;
                if (*v9) {
                  LODWORD(v17) = [v17 count];
                }
                int v18 = (int)v17 >= v10 ? v10 : (int)v17;
                if (v15 >= v18) {
                  break;
                }
                if (*v9
                  && v15 < (int)[*v9 count]
                  && (v19 = (const void *)[*v9 objectAtIndex:v15], (uint64_t v20 = (void *)v19) != 0))
                {
                  CFRetain(v19);
                  [v20 floatValue];
                  v12[i] = v21;
                  CFRelease(v20);
                }
                else
                {
                  v12[i] = 0;
                }
                ++v15;
              }
            }
            v22 = v28;
            if (v28 && !atomic_fetch_add(&v28->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
              std::__shared_weak_count::__release_weak(v22);
            }
            if (++v4 == v24) {
              goto LABEL_42;
            }
          }
          memptr = 0;
LABEL_12:
          uint64_t v7 = 0;
          char v26 = 0;
          goto LABEL_13;
        }
      }
    }
LABEL_42:
    v23 = v30;
    if (v30 && !atomic_fetch_add(&v30->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
}

void sub_2153B939C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_215436A24((uint64_t)va);
  free(0);
  _Unwind_Resume(a1);
}

uint64_t cva::ItemHandler::isMatrixType(cva::ItemHandler *this)
{
  if (!*(void *)this) {
    return 0;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    return 0;
  }
  cva::ItemHandler::getArray((uint64_t)this, &v28);
  if (!v28)
  {
LABEL_47:
    uint64_t v21 = 0;
    v23 = v29;
    if (!v29) {
      return v21;
    }
    goto LABEL_50;
  }
  if (*v28)
  {
    int v2 = [*v28 count];
    if (v2 >= 1)
    {
      uint64_t v3 = 0;
      uint64_t v4 = 0;
      uint64_t v5 = v2;
      do
      {
        id v6 = v28;
        if (!*v28) {
          goto LABEL_47;
        }
        if (v3 >= (int)[*v28 count]) {
          goto LABEL_47;
        }
        uint64_t v7 = (const void *)[*v6 objectAtIndex:v3];
        char v8 = v7;
        if (!v7) {
          goto LABEL_47;
        }
        CFRetain(v7);
        objc_opt_class();
        char isKindOfClass = objc_opt_isKindOfClass();
        CFRelease(v8);
        if ((isKindOfClass & 1) == 0) {
          goto LABEL_47;
        }
        if (*v6 && v3 < (int)[*v6 count])
        {
          int v10 = (const void *)[*v6 objectAtIndex:v3];
          int v11 = v10;
          char v12 = *((unsigned char *)v6 + 8);
          int v24 = v10;
          LOBYTE(v25) = v12;
          if (v10)
          {
            CFRetain(v10);
            goto LABEL_17;
          }
        }
        else
        {
          int v24 = 0;
        }
        int v11 = 0;
        LOBYTE(v25) = 0;
LABEL_17:
        cva::ItemHandler::getArray((uint64_t)&v24, &v26);
        if (v11) {
          CFRelease(v11);
        }
        unint64_t v13 = v26;
        if (!v26) {
          goto LABEL_36;
        }
        size_t v14 = *v26;
        if (v3)
        {
          if (v14)
          {
            if ([v14 count] != v4) {
              goto LABEL_36;
            }
          }
          else if (v4)
          {
            goto LABEL_36;
          }
          if ((int)v4 >= 1) {
            goto LABEL_27;
          }
LABEL_33:
          LOBYTE(v18) = 1;
          uint64_t v20 = v27;
          if (v27) {
            goto LABEL_38;
          }
          goto LABEL_40;
        }
        if (v14)
        {
          int v15 = objc_msgSend(v14, "count", v24, v25);
          uint64_t v4 = v15;
          if (v15 >= 1)
          {
LABEL_27:
            uint64_t v16 = 0;
            while (*v13 && v16 < (int)[*v13 count])
            {
              id v17 = (const void *)[*v13 objectAtIndex:v16];
              int v18 = v17;
              if (!v17) {
                goto LABEL_37;
              }
              CFRetain(v17);
              objc_opt_class();
              char v19 = objc_opt_isKindOfClass();
              CFRelease(v18);
              if ((v19 & 1) == 0) {
                break;
              }
              if (v4 == ++v16) {
                goto LABEL_33;
              }
            }
LABEL_36:
            LOBYTE(v18) = 0;
LABEL_37:
            uint64_t v20 = v27;
            if (!v27) {
              goto LABEL_40;
            }
LABEL_38:
            if (!atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
              std::__shared_weak_count::__release_weak(v20);
            }
            goto LABEL_40;
          }
          goto LABEL_33;
        }
        uint64_t v4 = 0;
        LOBYTE(v18) = 1;
        uint64_t v20 = v27;
        if (v27) {
          goto LABEL_38;
        }
LABEL_40:
        if ((v18 & 1) == 0) {
          goto LABEL_47;
        }
        ++v3;
      }
      while (v3 != v5);
    }
  }
  uint64_t v21 = 1;
  v23 = v29;
  if (v29)
  {
LABEL_50:
    if (!atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  return v21;
}

void sub_2153B9714(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_215436A24((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t cva::ItemHandler::getArray@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  if (!*(void *)this || (uint64_t v3 = this, objc_opt_class(), this = objc_opt_isKindOfClass(), (this & 1) == 0))
  {
    *a2 = 0;
    a2[1] = 0;
    return this;
  }
  uint64_t v4 = *(const void **)v3;
  if (*(unsigned char *)(v3 + 8))
  {
    this = (uint64_t)operator new(0x28uLL);
    uint64_t v5 = this;
    *(void *)(this + 8) = 0;
    *(void *)(this + 16) = 0;
    *(void *)this = &unk_26C5FC390;
    *(void *)(this + 24) = v4;
    uint64_t v6 = this + 24;
    *(unsigned char *)(this + 32) = 1;
    if (!v4)
    {
      *(unsigned char *)(this + 32) = 0;
      goto LABEL_10;
    }
  }
  else
  {
    this = (uint64_t)operator new(0x28uLL);
    uint64_t v5 = this;
    *(void *)(this + 8) = 0;
    *(void *)(this + 16) = 0;
    *(void *)this = &unk_26C5FC390;
    *(void *)(this + 24) = v4;
    uint64_t v6 = this + 24;
    *(unsigned char *)(this + 32) = 0;
    if (!v4) {
      goto LABEL_10;
    }
  }
  this = (uint64_t)CFRetain(v4);
LABEL_10:
  *a2 = v6;
  a2[1] = v5;
  return this;
}

void sub_2153B9874(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void cva::ItemHandler::~ItemHandler(const void **this)
{
  uint64_t v1 = *this;
  if (v1) {
    CFRelease(v1);
  }
}

{
  const void *v1;

  uint64_t v1 = *this;
  if (v1) {
    CFRelease(v1);
  }
}

void cva::DictionaryHandler::~DictionaryHandler(const void **this)
{
  uint64_t v1 = *this;
  if (v1) {
    CFRelease(v1);
  }
}

{
  const void *v1;

  uint64_t v1 = *this;
  if (v1) {
    CFRelease(v1);
  }
}

void *cva::ItemHandler::getValue<BOOL>(void **a1)
{
  CFTypeRef result = *a1;
  if (result) {
    return (void *)[result BOOLValue];
  }
  return result;
}

uint64_t *cva::DictionaryHandler::operator=(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *result;
  *CFTypeRef result = *a2;
  *a2 = v2;
  LOBYTE(v2) = *((unsigned char *)result + 8);
  *((unsigned char *)result + 8) = *((unsigned char *)a2 + 8);
  *((unsigned char *)a2 + 8) = v2;
  return result;
}

cva::DictionaryHandler *cva::DictionaryHandler::DictionaryHandler(cva::DictionaryHandler *this, CFTypeRef cf)
{
  *(void *)this = cf;
  *((unsigned char *)this + 8) = 0;
  if (cf) {
    CFRetain(cf);
  }
  return this;
}

{
  *(void *)this = cf;
  *((unsigned char *)this + 8) = 1;
  if (cf) {
    CFRetain(cf);
  }
  else {
    *((unsigned char *)this + 8) = 0;
  }
  return this;
}

{
  *(void *)this = cf;
  *((unsigned char *)this + 8) = 1;
  if (cf) {
    CFRetain(cf);
  }
  else {
    *((unsigned char *)this + 8) = 0;
  }
  return this;
}

{
  *(void *)this = cf;
  *((unsigned char *)this + 8) = 0;
  if (cf) {
    CFRetain(cf);
  }
  return this;
}

cva::DictionaryHandler *cva::DictionaryHandler::DictionaryHandler(cva::DictionaryHandler *this)
{
  *(void *)this = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFB78], MEMORY[0x263EFFF90]);
  *((unsigned char *)this + 8) = 1;
  return this;
}

{
  *(void *)this = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFB78], MEMORY[0x263EFFF90]);
  *((unsigned char *)this + 8) = 1;
  return this;
}

uint64_t cva::Path::string(cva::Path *this)
{
  return *(void *)this;
}

std::string *cva::Path::append(std::string **this, const std::string::value_type ***a2)
{
  uint64_t v4 = *this;
  if (SHIBYTE(v4->__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::size_type size = v4->__r_.__value_.__l.__size_;
    if (!size) {
      goto LABEL_14;
    }
    uint64_t v6 = (std::string *)v4->__r_.__value_.__r.__words[0];
  }
  else
  {
    std::string::size_type size = HIBYTE(v4->__r_.__value_.__r.__words[2]);
    if (!*((unsigned char *)&v4->__r_.__value_.__s + 23)) {
      goto LABEL_14;
    }
    uint64_t v6 = v4;
  }
  if (v6->__r_.__value_.__s.__data_[size - 1] != 47)
  {
    uint64_t v7 = *a2;
    if (*((char *)*a2 + 23) < 0)
    {
      if (!v7[1]) {
        goto LABEL_14;
      }
      uint64_t v7 = (const std::string::value_type **)*v7;
    }
    else if (!*((unsigned char *)*a2 + 23))
    {
      goto LABEL_14;
    }
    if (*(unsigned char *)v7 != 47)
    {
      std::string::push_back(v4, 47);
      uint64_t v4 = *this;
    }
  }
LABEL_14:
  int v8 = *((char *)*a2 + 23);
  if (v8 >= 0) {
    unint64_t v9 = (const std::string::value_type *)*a2;
  }
  else {
    unint64_t v9 = **a2;
  }
  if (v8 >= 0) {
    std::string::size_type v10 = *((unsigned __int8 *)*a2 + 23);
  }
  else {
    std::string::size_type v10 = (std::string::size_type)(*a2)[1];
  }
  return std::string::append(v4, v9, v10);
}

std::string *cva::Path::concatenate(std::string **a1, const std::string::value_type *a2)
{
  uint64_t v2 = *a1;
  std::string::size_type v3 = *((void *)a2 + 1);
  if (a2[23] >= 0)
  {
    std::string::size_type v4 = *((unsigned __int8 *)a2 + 23);
  }
  else
  {
    a2 = *(const std::string::value_type **)a2;
    std::string::size_type v4 = v3;
  }
  return std::string::append(v2, a2, v4);
}

void cva::Buffer<float>::doResize(uint64_t a1, _DWORD *a2)
{
  v15[5] = *(CVPixelBufferRef *)MEMORY[0x263EF8340];
  uint64_t v4 = a1 + 16;
  if (*a2 > *(_DWORD *)(a1 + 16)
    || (a2[1] <= *(_DWORD *)(a1 + 20) ? (BOOL v5 = a2[2] > *(_DWORD *)(a1 + 24)) : (BOOL v5 = 1), v5))
  {
    CVPixelBufferRelease(*(CVPixelBufferRef *)(a1 + 48));
    int v6 = 4 * *a2;
    int v7 = a2[2];
    unsigned int v8 = (a2[1] * v6 + 63) & 0xFFFFFFC0;
    uint64_t v9 = *(void *)a2;
    *(void *)(a1 + 8) = 0;
    *(void *)uint64_t v4 = v9;
    *(_DWORD *)(v4 + 8) = v7;
    *(_DWORD *)(a1 + 28) = 4;
    *(_DWORD *)(a1 + 32) = v6;
    *(_DWORD *)(a1 + 36) = v8;
    size_t v10 = *(unsigned int *)(a1 + 24);
    size_t v11 = (*(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16));
    AttributeDictionary = cva::createAttributeDictionary((cva *)v11, *(_DWORD *)(a1 + 24), 1278226534, 64, 64, 0, 0, 0, (BOOL)v15[0]);
    v15[0] = 0;
    CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v11, v10, 0x4C303066u, AttributeDictionary, v15);
    CFRelease(AttributeDictionary);
    *(CVPixelBufferRef *)(a1 + 48) = v15[0];
  }
  else
  {
    int v13 = a2[2];
    uint64_t v14 = *(void *)a2;
    *(void *)(a1 + 8) = 0;
    *(void *)uint64_t v4 = v14;
    *(_DWORD *)(a1 + 24) = v13;
  }
}

void cva::Buffer<float>::~Buffer(uint64_t a1)
{
  *(void *)a1 = &unk_26C5FBDB8;
  uint64_t v2 = *(void *)(a1 + 56);
  if (v2)
  {

    MEMORY[0x2166B9890](v2, 0xE0C400670D255);
  }
  uint64_t v3 = *(void *)(a1 + 64);
  if (v3)
  {

    MEMORY[0x2166B9890](v3, 0xE0C400670D255);
  }
  CVPixelBufferRelease(*(CVPixelBufferRef *)(a1 + 48));
  JUMPOUT(0x2166B9890);
}

uint64_t cva::Buffer<float>::~Buffer(uint64_t a1)
{
  *(void *)a1 = &unk_26C5FBDB8;
  uint64_t v2 = *(void *)(a1 + 56);
  if (v2)
  {

    MEMORY[0x2166B9890](v2, 0xE0C400670D255);
  }
  uint64_t v3 = *(void *)(a1 + 64);
  if (v3)
  {

    MEMORY[0x2166B9890](v3, 0xE0C400670D255);
  }
  CVPixelBufferRelease(*(CVPixelBufferRef *)(a1 + 48));
  return a1;
}

{
  uint64_t v2;
  uint64_t v3;

  *(void *)a1 = &unk_26C5FBDB8;
  uint64_t v2 = *(void *)(a1 + 56);
  if (v2)
  {

    MEMORY[0x2166B9890](v2, 0xE0C400670D255);
  }
  uint64_t v3 = *(void *)(a1 + 64);
  if (v3)
  {

    MEMORY[0x2166B9890](v3, 0xE0C400670D255);
  }
  CVPixelBufferRelease(*(CVPixelBufferRef *)(a1 + 48));
  return a1;
}

void cva::Buffer<unsigned short>::doResize(uint64_t a1, _DWORD *a2)
{
  v15[5] = *(CVPixelBufferRef *)MEMORY[0x263EF8340];
  uint64_t v4 = a1 + 16;
  if (*a2 > *(_DWORD *)(a1 + 16)
    || (a2[1] <= *(_DWORD *)(a1 + 20) ? (BOOL v5 = a2[2] > *(_DWORD *)(a1 + 24)) : (BOOL v5 = 1), v5))
  {
    CVPixelBufferRelease(*(CVPixelBufferRef *)(a1 + 48));
    int v6 = 2 * *a2;
    int v7 = a2[2];
    unsigned int v8 = (a2[1] * v6 + 63) & 0xFFFFFFC0;
    uint64_t v9 = *(void *)a2;
    *(void *)(a1 + 8) = 0;
    *(void *)uint64_t v4 = v9;
    *(_DWORD *)(v4 + 8) = v7;
    *(_DWORD *)(a1 + 28) = 2;
    *(_DWORD *)(a1 + 32) = v6;
    *(_DWORD *)(a1 + 36) = v8;
    size_t v10 = *(unsigned int *)(a1 + 24);
    size_t v11 = (*(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16));
    AttributeDictionary = cva::createAttributeDictionary((cva *)v11, *(_DWORD *)(a1 + 24), 2037741158, 64, 64, 0, 0, 0, (BOOL)v15[0]);
    v15[0] = 0;
    CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v11, v10, 0x79757666u, AttributeDictionary, v15);
    CFRelease(AttributeDictionary);
    *(CVPixelBufferRef *)(a1 + 48) = v15[0];
  }
  else
  {
    int v13 = a2[2];
    uint64_t v14 = *(void *)a2;
    *(void *)(a1 + 8) = 0;
    *(void *)uint64_t v4 = v14;
    *(_DWORD *)(a1 + 24) = v13;
  }
}

void cva::Buffer<unsigned short>::~Buffer(uint64_t a1)
{
  *(void *)a1 = &unk_26C5FBE48;
  uint64_t v2 = *(void *)(a1 + 56);
  if (v2)
  {

    MEMORY[0x2166B9890](v2, 0xE0C400670D255);
  }
  uint64_t v3 = *(void *)(a1 + 64);
  if (v3)
  {

    MEMORY[0x2166B9890](v3, 0xE0C400670D255);
  }
  CVPixelBufferRelease(*(CVPixelBufferRef *)(a1 + 48));
  JUMPOUT(0x2166B9890);
}

uint64_t cva::Buffer<unsigned short>::~Buffer(uint64_t a1)
{
  *(void *)a1 = &unk_26C5FBE48;
  uint64_t v2 = *(void *)(a1 + 56);
  if (v2)
  {

    MEMORY[0x2166B9890](v2, 0xE0C400670D255);
  }
  uint64_t v3 = *(void *)(a1 + 64);
  if (v3)
  {

    MEMORY[0x2166B9890](v3, 0xE0C400670D255);
  }
  CVPixelBufferRelease(*(CVPixelBufferRef *)(a1 + 48));
  return a1;
}

{
  uint64_t v2;
  uint64_t v3;

  *(void *)a1 = &unk_26C5FBE48;
  uint64_t v2 = *(void *)(a1 + 56);
  if (v2)
  {

    MEMORY[0x2166B9890](v2, 0xE0C400670D255);
  }
  uint64_t v3 = *(void *)(a1 + 64);
  if (v3)
  {

    MEMORY[0x2166B9890](v3, 0xE0C400670D255);
  }
  CVPixelBufferRelease(*(CVPixelBufferRef *)(a1 + 48));
  return a1;
}

void cva::Buffer<unsigned char>::doResize(uint64_t a1, int *a2)
{
  v15[5] = *(CVPixelBufferRef *)MEMORY[0x263EF8340];
  uint64_t v4 = a1 + 16;
  if (*a2 > *(_DWORD *)(a1 + 16)
    || (a2[1] <= *(_DWORD *)(a1 + 20) ? (BOOL v5 = a2[2] > *(_DWORD *)(a1 + 24)) : (BOOL v5 = 1), v5))
  {
    CVPixelBufferRelease(*(CVPixelBufferRef *)(a1 + 48));
    int v6 = *a2;
    int v7 = a2[2];
    unsigned int v8 = (a2[1] * *a2 + 63) & 0xFFFFFFC0;
    uint64_t v9 = *(void *)a2;
    *(void *)(a1 + 8) = 0;
    *(void *)uint64_t v4 = v9;
    *(_DWORD *)(v4 + 8) = v7;
    *(_DWORD *)(a1 + 28) = 1;
    *(_DWORD *)(a1 + 32) = v6;
    *(_DWORD *)(a1 + 36) = v8;
    size_t v10 = *(unsigned int *)(a1 + 24);
    size_t v11 = (*(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16));
    AttributeDictionary = cva::createAttributeDictionary((cva *)v11, *(_DWORD *)(a1 + 24), 1278226488, 64, 64, 0, 0, 0, (BOOL)v15[0]);
    v15[0] = 0;
    CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v11, v10, 0x4C303038u, AttributeDictionary, v15);
    CFRelease(AttributeDictionary);
    *(CVPixelBufferRef *)(a1 + 48) = v15[0];
  }
  else
  {
    int v13 = a2[2];
    uint64_t v14 = *(void *)a2;
    *(void *)(a1 + 8) = 0;
    *(void *)uint64_t v4 = v14;
    *(_DWORD *)(a1 + 24) = v13;
  }
}

void cva::Buffer<unsigned char>::~Buffer(uint64_t a1)
{
  *(void *)a1 = &unk_26C5FBDE8;
  uint64_t v2 = *(void *)(a1 + 56);
  if (v2)
  {

    MEMORY[0x2166B9890](v2, 0xE0C400670D255);
  }
  uint64_t v3 = *(void *)(a1 + 64);
  if (v3)
  {

    MEMORY[0x2166B9890](v3, 0xE0C400670D255);
  }
  CVPixelBufferRelease(*(CVPixelBufferRef *)(a1 + 48));
  JUMPOUT(0x2166B9890);
}

uint64_t cva::Buffer<unsigned char>::~Buffer(uint64_t a1)
{
  *(void *)a1 = &unk_26C5FBDE8;
  uint64_t v2 = *(void *)(a1 + 56);
  if (v2)
  {

    MEMORY[0x2166B9890](v2, 0xE0C400670D255);
  }
  uint64_t v3 = *(void *)(a1 + 64);
  if (v3)
  {

    MEMORY[0x2166B9890](v3, 0xE0C400670D255);
  }
  CVPixelBufferRelease(*(CVPixelBufferRef *)(a1 + 48));
  return a1;
}

{
  uint64_t v2;
  uint64_t v3;

  *(void *)a1 = &unk_26C5FBDE8;
  uint64_t v2 = *(void *)(a1 + 56);
  if (v2)
  {

    MEMORY[0x2166B9890](v2, 0xE0C400670D255);
  }
  uint64_t v3 = *(void *)(a1 + 64);
  if (v3)
  {

    MEMORY[0x2166B9890](v3, 0xE0C400670D255);
  }
  CVPixelBufferRelease(*(CVPixelBufferRef *)(a1 + 48));
  return a1;
}

void cva::Buffer<unsigned int>::doResize(uint64_t a1, _DWORD *a2)
{
  v15[5] = *(CVPixelBufferRef *)MEMORY[0x263EF8340];
  uint64_t v4 = a1 + 16;
  if (*a2 > *(_DWORD *)(a1 + 16)
    || (a2[1] <= *(_DWORD *)(a1 + 20) ? (BOOL v5 = a2[2] > *(_DWORD *)(a1 + 24)) : (BOOL v5 = 1), v5))
  {
    CVPixelBufferRelease(*(CVPixelBufferRef *)(a1 + 48));
    int v6 = 4 * *a2;
    int v7 = a2[2];
    unsigned int v8 = (a2[1] * v6 + 63) & 0xFFFFFFC0;
    uint64_t v9 = *(void *)a2;
    *(void *)(a1 + 8) = 0;
    *(void *)uint64_t v4 = v9;
    *(_DWORD *)(v4 + 8) = v7;
    *(_DWORD *)(a1 + 28) = 4;
    *(_DWORD *)(a1 + 32) = v6;
    *(_DWORD *)(a1 + 36) = v8;
    size_t v10 = *(unsigned int *)(a1 + 24);
    size_t v11 = (*(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16));
    AttributeDictionary = cva::createAttributeDictionary((cva *)v11, *(_DWORD *)(a1 + 24), 1111970369, 64, 64, 0, 0, 0, (BOOL)v15[0]);
    v15[0] = 0;
    CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v11, v10, 0x42475241u, AttributeDictionary, v15);
    CFRelease(AttributeDictionary);
    *(CVPixelBufferRef *)(a1 + 48) = v15[0];
  }
  else
  {
    int v13 = a2[2];
    uint64_t v14 = *(void *)a2;
    *(void *)(a1 + 8) = 0;
    *(void *)uint64_t v4 = v14;
    *(_DWORD *)(a1 + 24) = v13;
  }
}

void cva::Buffer<unsigned int>::~Buffer(uint64_t a1)
{
  *(void *)a1 = &unk_26C5FBE18;
  uint64_t v2 = *(void *)(a1 + 56);
  if (v2)
  {

    MEMORY[0x2166B9890](v2, 0xE0C400670D255);
  }
  uint64_t v3 = *(void *)(a1 + 64);
  if (v3)
  {

    MEMORY[0x2166B9890](v3, 0xE0C400670D255);
  }
  CVPixelBufferRelease(*(CVPixelBufferRef *)(a1 + 48));
  JUMPOUT(0x2166B9890);
}

uint64_t cva::Buffer<unsigned int>::~Buffer(uint64_t a1)
{
  *(void *)a1 = &unk_26C5FBE18;
  uint64_t v2 = *(void *)(a1 + 56);
  if (v2)
  {

    MEMORY[0x2166B9890](v2, 0xE0C400670D255);
  }
  uint64_t v3 = *(void *)(a1 + 64);
  if (v3)
  {

    MEMORY[0x2166B9890](v3, 0xE0C400670D255);
  }
  CVPixelBufferRelease(*(CVPixelBufferRef *)(a1 + 48));
  return a1;
}

{
  uint64_t v2;
  uint64_t v3;

  *(void *)a1 = &unk_26C5FBE18;
  uint64_t v2 = *(void *)(a1 + 56);
  if (v2)
  {

    MEMORY[0x2166B9890](v2, 0xE0C400670D255);
  }
  uint64_t v3 = *(void *)(a1 + 64);
  if (v3)
  {

    MEMORY[0x2166B9890](v3, 0xE0C400670D255);
  }
  CVPixelBufferRelease(*(CVPixelBufferRef *)(a1 + 48));
  return a1;
}

void cva::Buffer<cva::half>::doResize(uint64_t a1, _DWORD *a2)
{
  v15[5] = *(CVPixelBufferRef *)MEMORY[0x263EF8340];
  uint64_t v4 = a1 + 16;
  if (*a2 > *(_DWORD *)(a1 + 16)
    || (a2[1] <= *(_DWORD *)(a1 + 20) ? (BOOL v5 = a2[2] > *(_DWORD *)(a1 + 24)) : (BOOL v5 = 1), v5))
  {
    CVPixelBufferRelease(*(CVPixelBufferRef *)(a1 + 48));
    int v6 = 2 * *a2;
    int v7 = a2[2];
    unsigned int v8 = (a2[1] * v6 + 63) & 0xFFFFFFC0;
    uint64_t v9 = *(void *)a2;
    *(void *)(a1 + 8) = 0;
    *(void *)uint64_t v4 = v9;
    *(_DWORD *)(v4 + 8) = v7;
    *(_DWORD *)(a1 + 28) = 2;
    *(_DWORD *)(a1 + 32) = v6;
    *(_DWORD *)(a1 + 36) = v8;
    size_t v10 = *(unsigned int *)(a1 + 24);
    size_t v11 = (*(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16));
    AttributeDictionary = cva::createAttributeDictionary((cva *)v11, *(_DWORD *)(a1 + 24), 1278226536, 64, 64, 0, 0, 0, (BOOL)v15[0]);
    v15[0] = 0;
    CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v11, v10, 0x4C303068u, AttributeDictionary, v15);
    CFRelease(AttributeDictionary);
    *(CVPixelBufferRef *)(a1 + 48) = v15[0];
  }
  else
  {
    int v13 = a2[2];
    uint64_t v14 = *(void *)a2;
    *(void *)(a1 + 8) = 0;
    *(void *)uint64_t v4 = v14;
    *(_DWORD *)(a1 + 24) = v13;
  }
}

void cva::Buffer<cva::half>::~Buffer(uint64_t a1)
{
  *(void *)a1 = &unk_26C5FBD88;
  uint64_t v2 = *(void *)(a1 + 56);
  if (v2)
  {

    MEMORY[0x2166B9890](v2, 0xE0C400670D255);
  }
  uint64_t v3 = *(void *)(a1 + 64);
  if (v3)
  {

    MEMORY[0x2166B9890](v3, 0xE0C400670D255);
  }
  CVPixelBufferRelease(*(CVPixelBufferRef *)(a1 + 48));
  JUMPOUT(0x2166B9890);
}

uint64_t cva::Buffer<cva::half>::~Buffer(uint64_t a1)
{
  *(void *)a1 = &unk_26C5FBD88;
  uint64_t v2 = *(void *)(a1 + 56);
  if (v2)
  {

    MEMORY[0x2166B9890](v2, 0xE0C400670D255);
  }
  uint64_t v3 = *(void *)(a1 + 64);
  if (v3)
  {

    MEMORY[0x2166B9890](v3, 0xE0C400670D255);
  }
  CVPixelBufferRelease(*(CVPixelBufferRef *)(a1 + 48));
  return a1;
}

{
  uint64_t v2;
  uint64_t v3;

  *(void *)a1 = &unk_26C5FBD88;
  uint64_t v2 = *(void *)(a1 + 56);
  if (v2)
  {

    MEMORY[0x2166B9890](v2, 0xE0C400670D255);
  }
  uint64_t v3 = *(void *)(a1 + 64);
  if (v3)
  {

    MEMORY[0x2166B9890](v3, 0xE0C400670D255);
  }
  CVPixelBufferRelease(*(CVPixelBufferRef *)(a1 + 48));
  return a1;
}

double cva::Buffer<float>::Buffer(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)a1 = &unk_26C5FBDB8;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  return result;
}

{
  double result;

  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)a1 = &unk_26C5FBDB8;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  return result;
}

uint64_t cva::Buffer<float>::Buffer(uint64_t a1, _DWORD *a2)
{
  int v3 = 4 * *a2;
  *(void *)(a1 + 8) = 0;
  size_t v4 = a2[2];
  unsigned int v5 = (a2[1] * v3 + 63) & 0xFFFFFFC0;
  uint64_t v6 = *(void *)a2;
  *(void *)(a1 + 16) = *(void *)a2;
  *(_DWORD *)(a1 + 24) = v4;
  *(_DWORD *)(a1 + 28) = 4;
  *(_DWORD *)(a1 + 32) = v3;
  *(_DWORD *)(a1 + 36) = v5;
  *(void *)(a1 + 40) = 0;
  *(void *)a1 = &unk_26C5FBDB8;
  size_t v7 = (HIDWORD(v6) * v6);
  AttributeDictionary = cva::createAttributeDictionary((cva *)v7, v4, 1278226534, 64, 64, 0, 0, 0, v11);
  CVPixelBufferRef pixelBufferOut = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v7, v4, 0x4C303066u, AttributeDictionary, &pixelBufferOut);
  CFRelease(AttributeDictionary);
  CVPixelBufferRef v9 = pixelBufferOut;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = v9;
  return a1;
}

{
  int v3;
  size_t v4;
  unsigned int v5;
  uint64_t v6;
  size_t v7;
  __CFDictionary *AttributeDictionary;
  CVPixelBufferRef v9;
  BOOL v11;
  CVPixelBufferRef pixelBufferOut;

  int v3 = 4 * *a2;
  *(void *)(a1 + 8) = 0;
  size_t v4 = a2[2];
  unsigned int v5 = (a2[1] * v3 + 63) & 0xFFFFFFC0;
  uint64_t v6 = *(void *)a2;
  *(void *)(a1 + 16) = *(void *)a2;
  *(_DWORD *)(a1 + 24) = v4;
  *(_DWORD *)(a1 + 28) = 4;
  *(_DWORD *)(a1 + 32) = v3;
  *(_DWORD *)(a1 + 36) = v5;
  *(void *)(a1 + 40) = 0;
  *(void *)a1 = &unk_26C5FBDB8;
  size_t v7 = (HIDWORD(v6) * v6);
  AttributeDictionary = cva::createAttributeDictionary((cva *)v7, v4, 1278226534, 64, 64, 0, 0, 0, v11);
  CVPixelBufferRef pixelBufferOut = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v7, v4, 0x4C303066u, AttributeDictionary, &pixelBufferOut);
  CFRelease(AttributeDictionary);
  CVPixelBufferRef v9 = pixelBufferOut;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = v9;
  return a1;
}

_DWORD *cva::Buffer<float>::defaultStride@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X8>)
{
  int v2 = result[1];
  int v3 = 4 * *result;
  *a2 = 4;
  a2[1] = v3;
  a2[2] = (v2 * v3 + 63) & 0xFFFFFFC0;
  return result;
}

CVPixelBufferRef cva::Buffer<float>::allocate(_DWORD *a1)
{
  size_t v1 = (a1[1] * *a1);
  size_t v2 = a1[2];
  AttributeDictionary = cva::createAttributeDictionary((cva *)v1, v2, 1278226534, 64, 64, 0, 0, 0, v5);
  CVPixelBufferRef pixelBufferOut = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v1, v2, 0x4C303066u, AttributeDictionary, &pixelBufferOut);
  CFRelease(AttributeDictionary);
  return pixelBufferOut;
}

uint64_t cva::Buffer<float>::Buffer(uint64_t a1, int a2, int a3, unsigned int a4)
{
  *(_DWORD *)(a1 + 16) = a2;
  *(_DWORD *)(a1 + 20) = a3;
  *(_DWORD *)(a1 + 24) = a4;
  *(_DWORD *)(a1 + 28) = 4;
  *(_DWORD *)(a1 + 32) = 4 * a2;
  *(_DWORD *)(a1 + 36) = (4 * a2 * a3 + 63) & 0xFFFFFFC0;
  *(void *)(a1 + 40) = 0;
  *(void *)a1 = &unk_26C5FBDB8;
  *(void *)(a1 + 8) = 0;
  size_t v6 = (a3 * a2);
  AttributeDictionary = cva::createAttributeDictionary((cva *)v6, a4, 1278226534, 64, 64, 0, 0, 0, v10);
  CVPixelBufferRef pixelBufferOut = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v6, a4, 0x4C303066u, AttributeDictionary, &pixelBufferOut);
  CFRelease(AttributeDictionary);
  CVPixelBufferRef v8 = pixelBufferOut;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = v8;
  return a1;
}

{
  size_t v6;
  __CFDictionary *AttributeDictionary;
  CVPixelBufferRef v8;
  BOOL v10;
  CVPixelBufferRef pixelBufferOut;

  *(_DWORD *)(a1 + 16) = a2;
  *(_DWORD *)(a1 + 20) = a3;
  *(_DWORD *)(a1 + 24) = a4;
  *(_DWORD *)(a1 + 28) = 4;
  *(_DWORD *)(a1 + 32) = 4 * a2;
  *(_DWORD *)(a1 + 36) = (4 * a2 * a3 + 63) & 0xFFFFFFC0;
  *(void *)(a1 + 40) = 0;
  *(void *)a1 = &unk_26C5FBDB8;
  *(void *)(a1 + 8) = 0;
  size_t v6 = (a3 * a2);
  AttributeDictionary = cva::createAttributeDictionary((cva *)v6, a4, 1278226534, 64, 64, 0, 0, 0, v10);
  CVPixelBufferRef pixelBufferOut = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v6, a4, 0x4C303066u, AttributeDictionary, &pixelBufferOut);
  CFRelease(AttributeDictionary);
  CVPixelBufferRef v8 = pixelBufferOut;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = v8;
  return a1;
}

double cva::Buffer<float>::Buffer(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  uint64_t v2 = *(void *)(a2 + 16);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  *(void *)(a1 + 16) = v2;
  uint64_t v3 = *(void *)(a2 + 28);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(a2 + 36);
  *(void *)(a1 + 28) = v3;
  *(void *)a1 = &unk_26C5FBDB8;
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  *(void *)(a2 + 28) = 0;
  *(_DWORD *)(a2 + 36) = 0;
  double result = 0.0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  return result;
}

{
  uint64_t v2;
  uint64_t v3;
  double result;

  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  uint64_t v2 = *(void *)(a2 + 16);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  *(void *)(a1 + 16) = v2;
  uint64_t v3 = *(void *)(a2 + 28);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(a2 + 36);
  *(void *)(a1 + 28) = v3;
  *(void *)a1 = &unk_26C5FBDB8;
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  *(void *)(a2 + 28) = 0;
  *(_DWORD *)(a2 + 36) = 0;
  double result = 0.0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  return result;
}

__n128 cva::Buffer<float>::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v9 = *(void *)(a1 + 16);
  int v10 = *(_DWORD *)(a1 + 24);
  uint64_t v7 = *(void *)(a1 + 28);
  int v8 = *(_DWORD *)(a1 + 36);
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  uint64_t v3 = *(void *)(a2 + 16);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  *(void *)(a1 + 16) = v3;
  LODWORD(v3) = *(_DWORD *)(a2 + 36);
  *(void *)(a1 + 28) = *(void *)(a2 + 28);
  *(_DWORD *)(a1 + 36) = v3;
  *(void *)(a2 + 8) = v2;
  *(void *)(a2 + 16) = v9;
  *(_DWORD *)(a2 + 24) = v10;
  *(void *)(a2 + 28) = v7;
  *(_DWORD *)(a2 + 36) = v8;
  uint64_t v4 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = v4;
  uint64_t v5 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = v5;
  __n128 result = *(__n128 *)(a1 + 56);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(__n128 *)(a2 + 56) = result;
  return result;
}

uint64_t cva::Buffer<float>::Buffer(uint64_t a1, uint64_t a2)
{
  v39[3] = *(CVPixelBufferRef *)MEMORY[0x263EF8340];
  int v4 = *(_DWORD *)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 16);
  int v6 = 4 * *(_DWORD *)(a2 + 16);
  unsigned int v7 = (*(_DWORD *)(a2 + 20) * v6 + 63) & 0xFFFFFFC0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 24) = v4;
  *(_DWORD *)(a1 + 28) = 4;
  *(_DWORD *)(a1 + 32) = v6;
  *(_DWORD *)(a1 + 36) = v7;
  *(void *)(a1 + 40) = 0;
  *(void *)a1 = &unk_26C5FBDB8;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  size_t v8 = *(unsigned int *)(a1 + 24);
  size_t v9 = (*(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16));
  AttributeDictionary = cva::createAttributeDictionary((cva *)v9, v8, 1278226534, 64, 64, 0, 0, 0, (BOOL)v39[0]);
  v39[0] = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v9, v8, 0x4C303066u, AttributeDictionary, v39);
  CFRelease(AttributeDictionary);
  *(CVPixelBufferRef *)(a1 + 48) = v39[0];
  BOOL v11 = *(__CVBuffer **)(a2 + 48);
  if (v11 && !CVPixelBufferLockBaseAddress(v11, 1uLL))
  {
    CVPixelBufferGetWidth(*(CVPixelBufferRef *)(a2 + 48));
    CVPixelBufferGetHeight(*(CVPixelBufferRef *)(a2 + 48));
    CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)(a2 + 48));
    *(void *)(a2 + 40) = CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(a2 + 48));
    char v12 = *(__CVBuffer **)(a1 + 48);
    if (v12 && !CVPixelBufferLockBaseAddress(v12, 0))
    {
      CVPixelBufferGetWidth(*(CVPixelBufferRef *)(a1 + 48));
      CVPixelBufferGetHeight(*(CVPixelBufferRef *)(a1 + 48));
      CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)(a1 + 48));
      BaseAddress = (char *)CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(a1 + 48));
      *(void *)(a1 + 40) = BaseAddress;
      uint64_t v14 = *(unsigned int *)(a1 + 36);
      uint64_t v15 = *(unsigned int *)(a2 + 36);
      if (*(_DWORD *)(a1 + 28) == *(_DWORD *)(a2 + 28)
        && *(_DWORD *)(a1 + 32) == *(_DWORD *)(a2 + 32)
        && v14 == v15)
      {
        memcpy(BaseAddress, *(const void **)(a2 + 40), (*(_DWORD *)(a2 + 24) * v14));
      }
      else
      {
        uint64_t v16 = *(void *)(a2 + 40);
        if (v16) {
          id v17 = (_DWORD *)(v16 + *(void *)(a2 + 8));
        }
        else {
          id v17 = 0;
        }
        if (v16) {
          int v18 = (_DWORD *)(v16 + *(void *)(a2 + 8) + (*(_DWORD *)(a2 + 24) * v15));
        }
        else {
          int v18 = 0;
        }
        if (v17 != v18)
        {
          int v19 = 0;
          int v20 = 0;
          int v21 = 0;
          int v22 = 0;
          int v23 = *(_DWORD *)(a2 + 16);
          int v24 = *(_DWORD *)(a2 + 20);
          int v26 = *(_DWORD *)(a1 + 16);
          int v25 = *(_DWORD *)(a1 + 20);
          unint64_t v27 = *(void *)(a1 + 28);
          unint64_t v28 = *(void *)(a2 + 28);
          if (BaseAddress) {
            v29 = &BaseAddress[*(void *)(a1 + 8)];
          }
          else {
            v29 = 0;
          }
          uint64_t v30 = *(void *)(a2 + 28);
          unint64_t v31 = HIDWORD(v28);
          uint64_t v32 = *(void *)(a1 + 28);
          unint64_t v33 = HIDWORD(v27);
          uint64_t v34 = -(uint64_t)(v23 * v28);
          uint64_t v35 = -(uint64_t)(v26 * v27);
          do
          {
            *(_DWORD *)v29 = *v17;
            id v17 = (_DWORD *)((char *)v17 + v30);
            if (++v20 == v23)
            {
              int v20 = 0;
              id v17 = (_DWORD *)((char *)v17 + v34 + v31);
              int v36 = v19 + 1;
              if (v19 + 1 == v24) {
                int v19 = 0;
              }
              else {
                ++v19;
              }
              if (v36 == v24) {
                id v17 = (_DWORD *)((char *)v17 + v15 - (v36 * v31));
              }
            }
            v29 += v32;
            if (++v22 == v26)
            {
              int v22 = 0;
              v29 += v35 + v33;
              int v37 = v21 + 1;
              if (v21 + 1 == v25) {
                int v21 = 0;
              }
              else {
                ++v21;
              }
              if (v37 == v25) {
                v29 = &v29[v14 - (v37 * v33)];
              }
            }
          }
          while (v17 != v18);
        }
      }
      if (!CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a1 + 48), 0)) {
        *(void *)(a1 + 40) = 0;
      }
    }
    if (!CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a2 + 48), 1uLL)) {
      *(void *)(a2 + 40) = 0;
    }
  }
  return a1;
}

{
  int v4;
  uint64_t v5;
  int v6;
  unsigned int v7;
  size_t v8;
  size_t v9;
  __CFDictionary *AttributeDictionary;
  __CVBuffer *v11;
  char *BaseAddress;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _DWORD *v16;
  _DWORD *v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  unint64_t v26;
  unint64_t v27;
  char *v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  int v36;
  CVPixelBufferRef pixelBuffer[4];

  pixelBuffer[3] = *(CVPixelBufferRef *)MEMORY[0x263EF8340];
  int v4 = *(_DWORD *)(a2 + 16);
  uint64_t v5 = *(void *)(a2 + 8);
  int v6 = 4 * *(_DWORD *)(a2 + 8);
  unsigned int v7 = (*(_DWORD *)(a2 + 12) * v6 + 63) & 0xFFFFFFC0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 24) = v4;
  *(_DWORD *)(a1 + 28) = 4;
  *(_DWORD *)(a1 + 32) = v6;
  *(_DWORD *)(a1 + 36) = v7;
  *(void *)(a1 + 40) = 0;
  *(void *)a1 = &unk_26C5FBDB8;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  size_t v8 = *(unsigned int *)(a1 + 24);
  size_t v9 = (*(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16));
  AttributeDictionary = cva::createAttributeDictionary((cva *)v9, v8, 1278226534, 64, 64, 0, 0, 0, (BOOL)pixelBuffer[0]);
  pixelBuffer[0] = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v9, v8, 0x4C303066u, AttributeDictionary, pixelBuffer);
  CFRelease(AttributeDictionary);
  BOOL v11 = pixelBuffer[0];
  *(CVPixelBufferRef *)(a1 + 48) = pixelBuffer[0];
  if (v11 && !CVPixelBufferLockBaseAddress(v11, 0))
  {
    CVPixelBufferGetWidth(*(CVPixelBufferRef *)(a1 + 48));
    CVPixelBufferGetHeight(*(CVPixelBufferRef *)(a1 + 48));
    CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)(a1 + 48));
    BaseAddress = (char *)CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(a1 + 48));
    *(void *)(a1 + 40) = BaseAddress;
    int v13 = *(unsigned int *)(a1 + 36);
    uint64_t v14 = *(unsigned int *)(a2 + 28);
    if (*(_DWORD *)(a1 + 28) == *(_DWORD *)(a2 + 20)
      && *(_DWORD *)(a1 + 32) == *(_DWORD *)(a2 + 24)
      && v13 == v14)
    {
      memcpy(BaseAddress, *(const void **)(a2 + 32), (*(_DWORD *)(a2 + 16) * v13));
    }
    else
    {
      uint64_t v15 = *(void *)(a2 + 32);
      if (v15) {
        uint64_t v16 = (_DWORD *)(v15 + *(void *)a2);
      }
      else {
        uint64_t v16 = 0;
      }
      if (v15) {
        id v17 = (_DWORD *)(v15 + *(void *)a2 + (*(_DWORD *)(a2 + 16) * v14));
      }
      else {
        id v17 = 0;
      }
      if (v16 != v17)
      {
        int v18 = 0;
        int v19 = 0;
        int v20 = 0;
        int v21 = 0;
        int v22 = *(_DWORD *)(a2 + 8);
        int v23 = *(_DWORD *)(a2 + 12);
        int v25 = *(_DWORD *)(a1 + 16);
        int v24 = *(_DWORD *)(a1 + 20);
        int v26 = *(void *)(a1 + 28);
        unint64_t v27 = *(void *)(a2 + 20);
        if (BaseAddress) {
          unint64_t v28 = &BaseAddress[*(void *)(a1 + 8)];
        }
        else {
          unint64_t v28 = 0;
        }
        v29 = *(void *)(a2 + 20);
        uint64_t v30 = HIDWORD(v27);
        unint64_t v31 = *(void *)(a1 + 28);
        uint64_t v32 = HIDWORD(v26);
        unint64_t v33 = -(uint64_t)(v22 * v27);
        uint64_t v34 = -(uint64_t)(v25 * v26);
        do
        {
          *(_DWORD *)unint64_t v28 = *v16;
          uint64_t v16 = (_DWORD *)((char *)v16 + v29);
          if (++v19 == v22)
          {
            int v19 = 0;
            uint64_t v16 = (_DWORD *)((char *)v16 + v33 + v30);
            uint64_t v35 = v18 + 1;
            if (v18 + 1 == v23) {
              int v18 = 0;
            }
            else {
              ++v18;
            }
            if (v35 == v23) {
              uint64_t v16 = (_DWORD *)((char *)v16 + v14 - (v35 * v30));
            }
          }
          v28 += v31;
          if (++v21 == v25)
          {
            int v21 = 0;
            v28 += v34 + v32;
            int v36 = v20 + 1;
            if (v20 + 1 == v24) {
              int v20 = 0;
            }
            else {
              ++v20;
            }
            if (v36 == v24) {
              unint64_t v28 = &v28[v13 - (v36 * v32)];
            }
          }
        }
        while (v16 != v17);
      }
    }
    if (!CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a1 + 48), 0)) {
      *(void *)(a1 + 40) = 0;
    }
  }
  return a1;
}

__CVBuffer *cva::Buffer<float>::lock(uint64_t a1, CVPixelBufferLockFlags a2)
{
  __n128 result = *(__CVBuffer **)(a1 + 48);
  if (result)
  {
    if (CVPixelBufferLockBaseAddress(result, a2))
    {
      return 0;
    }
    else
    {
      CVPixelBufferGetWidth(*(CVPixelBufferRef *)(a1 + 48));
      CVPixelBufferGetHeight(*(CVPixelBufferRef *)(a1 + 48));
      CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)(a1 + 48));
      *(void *)(a1 + 40) = CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(a1 + 48));
      return (__CVBuffer *)1;
    }
  }
  return result;
}

BOOL cva::Buffer<float>::unlock(uint64_t a1, CVPixelBufferLockFlags a2)
{
  CVReturn v3 = CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a1 + 48), a2);
  if (!v3) {
    *(void *)(a1 + 40) = 0;
  }
  return v3 == 0;
}

uint64_t cva::Buffer<float>::operator=(uint64_t a1, uint64_t a2)
{
  CVReturn v3 = *(__CVBuffer **)(a2 + 48);
  if (v3 && !CVPixelBufferLockBaseAddress(v3, 1uLL))
  {
    CVPixelBufferGetWidth(*(CVPixelBufferRef *)(a2 + 48));
    CVPixelBufferGetHeight(*(CVPixelBufferRef *)(a2 + 48));
    CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)(a2 + 48));
    *(void *)(a2 + 40) = CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(a2 + 48));
    uint64_t v5 = *(__CVBuffer **)(a1 + 48);
    if (v5 && !CVPixelBufferLockBaseAddress(v5, 0))
    {
      CVPixelBufferGetWidth(*(CVPixelBufferRef *)(a1 + 48));
      CVPixelBufferGetHeight(*(CVPixelBufferRef *)(a1 + 48));
      CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)(a1 + 48));
      BaseAddress = (char *)CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(a1 + 48));
      *(void *)(a1 + 40) = BaseAddress;
      uint64_t v7 = *(void *)(a2 + 40);
      uint64_t v8 = *(unsigned int *)(a2 + 36);
      if (v7) {
        size_t v9 = (_DWORD *)(v7 + *(void *)(a2 + 8));
      }
      else {
        size_t v9 = 0;
      }
      if (v7) {
        int v10 = (_DWORD *)(v7 + *(void *)(a2 + 8) + (*(_DWORD *)(a2 + 24) * v8));
      }
      else {
        int v10 = 0;
      }
      if (v9 != v10)
      {
        int v11 = 0;
        int v12 = 0;
        int v13 = 0;
        int v14 = 0;
        unint64_t v15 = *(void *)(a1 + 28);
        unint64_t v16 = *(void *)(a2 + 28);
        int v17 = *(_DWORD *)(a1 + 16);
        int v18 = *(_DWORD *)(a1 + 20);
        int v20 = *(_DWORD *)(a2 + 16);
        int v19 = *(_DWORD *)(a2 + 20);
        unint64_t v21 = HIDWORD(v16);
        unint64_t v22 = HIDWORD(v15);
        uint64_t v23 = *(unsigned int *)(a1 + 36);
        if (BaseAddress) {
          int v24 = &BaseAddress[*(void *)(a1 + 8)];
        }
        else {
          int v24 = 0;
        }
        uint64_t v25 = *(void *)(a2 + 28);
        uint64_t v26 = *(void *)(a1 + 28);
        uint64_t v27 = -(uint64_t)(v20 * v16);
        uint64_t v28 = -(uint64_t)(v17 * v15);
        do
        {
          *(_DWORD *)int v24 = *v9;
          size_t v9 = (_DWORD *)((char *)v9 + v25);
          if (++v13 == v20)
          {
            int v13 = 0;
            size_t v9 = (_DWORD *)((char *)v9 + v27 + v21);
            int v29 = v14 + 1;
            if (v14 + 1 == v19) {
              int v14 = 0;
            }
            else {
              ++v14;
            }
            if (v29 == v19) {
              size_t v9 = (_DWORD *)((char *)v9 + v8 - (v29 * v21));
            }
          }
          v24 += v26;
          if (++v11 == v17)
          {
            int v11 = 0;
            v24 += v28 + v22;
            int v30 = v12 + 1;
            if (v12 + 1 == v18) {
              int v12 = 0;
            }
            else {
              ++v12;
            }
            if (v30 == v18) {
              int v24 = &v24[v23 - (v30 * v22)];
            }
          }
        }
        while (v9 != v10);
      }
      if (!CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a1 + 48), 0)) {
        *(void *)(a1 + 40) = 0;
      }
    }
    if (!CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a2 + 48), 1uLL)) {
      *(void *)(a2 + 40) = 0;
    }
  }
  return a1;
}

{
  __CVBuffer *v3;
  char *BaseAddress;
  uint64_t v6;
  uint64_t v7;
  _DWORD *v8;
  _DWORD *v9;
  int v10;
  int v11;
  int v12;
  int v13;
  unint64_t v14;
  unint64_t v15;
  int v16;
  int v17;
  int v18;
  int v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;

  CVReturn v3 = *(__CVBuffer **)(a1 + 48);
  if (v3 && !CVPixelBufferLockBaseAddress(v3, 0))
  {
    CVPixelBufferGetWidth(*(CVPixelBufferRef *)(a1 + 48));
    CVPixelBufferGetHeight(*(CVPixelBufferRef *)(a1 + 48));
    CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)(a1 + 48));
    BaseAddress = (char *)CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(a1 + 48));
    *(void *)(a1 + 40) = BaseAddress;
    int v6 = *(void *)(a2 + 32);
    uint64_t v7 = *(unsigned int *)(a2 + 28);
    if (v6) {
      uint64_t v8 = (_DWORD *)(v6 + *(void *)a2);
    }
    else {
      uint64_t v8 = 0;
    }
    if (v6) {
      size_t v9 = (_DWORD *)(v6 + *(void *)a2 + (*(_DWORD *)(a2 + 16) * v7));
    }
    else {
      size_t v9 = 0;
    }
    if (v8 != v9)
    {
      int v10 = 0;
      int v11 = 0;
      int v12 = 0;
      int v13 = 0;
      int v14 = *(void *)(a1 + 28);
      unint64_t v15 = *(void *)(a2 + 20);
      unint64_t v16 = *(_DWORD *)(a1 + 16);
      int v17 = *(_DWORD *)(a1 + 20);
      int v19 = *(_DWORD *)(a2 + 8);
      int v18 = *(_DWORD *)(a2 + 12);
      int v20 = HIDWORD(v15);
      unint64_t v21 = HIDWORD(v14);
      unint64_t v22 = *(unsigned int *)(a1 + 36);
      if (BaseAddress) {
        uint64_t v23 = &BaseAddress[*(void *)(a1 + 8)];
      }
      else {
        uint64_t v23 = 0;
      }
      int v24 = v15;
      uint64_t v25 = *(void *)(a1 + 28);
      uint64_t v26 = -(uint64_t)(v19 * v15);
      uint64_t v27 = -(uint64_t)(v16 * v14);
      do
      {
        *(_DWORD *)uint64_t v23 = *v8;
        uint64_t v8 = (_DWORD *)((char *)v8 + v24);
        if (++v12 == v19)
        {
          int v12 = 0;
          uint64_t v8 = (_DWORD *)((char *)v8 + v26 + v20);
          uint64_t v28 = v13 + 1;
          if (v13 + 1 == v18) {
            int v13 = 0;
          }
          else {
            ++v13;
          }
          if (v28 == v18) {
            uint64_t v8 = (_DWORD *)((char *)v8 + v7 - (v28 * v20));
          }
        }
        v23 += v25;
        if (++v10 == v16)
        {
          int v10 = 0;
          v23 += v27 + v21;
          int v29 = v11 + 1;
          if (v11 + 1 == v17) {
            int v11 = 0;
          }
          else {
            ++v11;
          }
          if (v29 == v17) {
            uint64_t v23 = &v23[v22 - (v29 * v21)];
          }
        }
      }
      while (v8 != v9);
    }
    if (!CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a1 + 48), 0)) {
      *(void *)(a1 + 40) = 0;
    }
  }
  return a1;
}

uint64_t cva::Buffer<float>::resize(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[7];
  if (v4)
  {

    MEMORY[0x2166B9890](v4, 0xE0C400670D255);
  }
  a1[7] = 0;
  uint64_t v5 = a1[8];
  if (v5)
  {

    MEMORY[0x2166B9890](v5, 0xE0C400670D255);
  }
  a1[8] = 0;
  int v6 = *(uint64_t (**)(void *, uint64_t))(*a1 + 16);
  return v6(a1, a2);
}

uint64_t cva::Buffer<float>::resize(void *a1, int a2, int a3, int a4)
{
  v8[0] = a2;
  v8[1] = a3;
  v8[2] = a4;
  uint64_t v5 = a1[7];
  if (v5)
  {

    MEMORY[0x2166B9890](v5, 0xE0C400670D255);
  }
  a1[7] = 0;
  uint64_t v6 = a1[8];
  if (v6)
  {

    MEMORY[0x2166B9890](v6, 0xE0C400670D255);
  }
  a1[8] = 0;
  return (*(uint64_t (**)(void *, _DWORD *))(*a1 + 16))(a1, v8);
}

uint64_t cva::Buffer<float>::operator __CVBuffer *(uint64_t a1)
{
  return *(void *)(a1 + 48);
}

CVPixelBufferRef cva::Buffer<float>::allocate(_DWORD *a1, OSType a2)
{
  size_t v3 = (a1[1] * *a1);
  size_t v4 = a1[2];
  AttributeDictionary = cva::createAttributeDictionary((cva *)v3, v4, a2, 64, 64, 0, 0, 0, v7);
  CVPixelBufferRef pixelBufferOut = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v3, v4, a2, AttributeDictionary, &pixelBufferOut);
  CFRelease(AttributeDictionary);
  return pixelBufferOut;
}

double cva::Buffer<unsigned short>::Buffer(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)a1 = &unk_26C5FBE48;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  return result;
}

{
  double result;

  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)a1 = &unk_26C5FBE48;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  return result;
}

uint64_t cva::Buffer<unsigned short>::Buffer(uint64_t a1, _DWORD *a2)
{
  int v3 = 2 * *a2;
  *(void *)(a1 + 8) = 0;
  size_t v4 = a2[2];
  unsigned int v5 = (a2[1] * v3 + 63) & 0xFFFFFFC0;
  uint64_t v6 = *(void *)a2;
  *(void *)(a1 + 16) = *(void *)a2;
  *(_DWORD *)(a1 + 24) = v4;
  *(_DWORD *)(a1 + 28) = 2;
  *(_DWORD *)(a1 + 32) = v3;
  *(_DWORD *)(a1 + 36) = v5;
  *(void *)(a1 + 40) = 0;
  *(void *)a1 = &unk_26C5FBE48;
  size_t v7 = (HIDWORD(v6) * v6);
  AttributeDictionary = cva::createAttributeDictionary((cva *)v7, v4, 2037741158, 64, 64, 0, 0, 0, v11);
  CVPixelBufferRef pixelBufferOut = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v7, v4, 0x79757666u, AttributeDictionary, &pixelBufferOut);
  CFRelease(AttributeDictionary);
  CVPixelBufferRef v9 = pixelBufferOut;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = v9;
  return a1;
}

{
  int v3;
  size_t v4;
  unsigned int v5;
  uint64_t v6;
  size_t v7;
  __CFDictionary *AttributeDictionary;
  CVPixelBufferRef v9;
  BOOL v11;
  CVPixelBufferRef pixelBufferOut;

  int v3 = 2 * *a2;
  *(void *)(a1 + 8) = 0;
  size_t v4 = a2[2];
  unsigned int v5 = (a2[1] * v3 + 63) & 0xFFFFFFC0;
  uint64_t v6 = *(void *)a2;
  *(void *)(a1 + 16) = *(void *)a2;
  *(_DWORD *)(a1 + 24) = v4;
  *(_DWORD *)(a1 + 28) = 2;
  *(_DWORD *)(a1 + 32) = v3;
  *(_DWORD *)(a1 + 36) = v5;
  *(void *)(a1 + 40) = 0;
  *(void *)a1 = &unk_26C5FBE48;
  size_t v7 = (HIDWORD(v6) * v6);
  AttributeDictionary = cva::createAttributeDictionary((cva *)v7, v4, 2037741158, 64, 64, 0, 0, 0, v11);
  CVPixelBufferRef pixelBufferOut = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v7, v4, 0x79757666u, AttributeDictionary, &pixelBufferOut);
  CFRelease(AttributeDictionary);
  CVPixelBufferRef v9 = pixelBufferOut;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = v9;
  return a1;
}

_DWORD *cva::Buffer<unsigned short>::defaultStride@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X8>)
{
  int v2 = result[1];
  int v3 = 2 * *result;
  *a2 = 2;
  a2[1] = v3;
  a2[2] = (v2 * v3 + 63) & 0xFFFFFFC0;
  return result;
}

CVPixelBufferRef cva::Buffer<unsigned short>::allocate(_DWORD *a1)
{
  size_t v1 = (a1[1] * *a1);
  size_t v2 = a1[2];
  AttributeDictionary = cva::createAttributeDictionary((cva *)v1, v2, 2037741158, 64, 64, 0, 0, 0, v5);
  CVPixelBufferRef pixelBufferOut = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v1, v2, 0x79757666u, AttributeDictionary, &pixelBufferOut);
  CFRelease(AttributeDictionary);
  return pixelBufferOut;
}

uint64_t cva::Buffer<unsigned short>::Buffer(uint64_t a1, int a2, int a3, unsigned int a4)
{
  *(_DWORD *)(a1 + 16) = a2;
  *(_DWORD *)(a1 + 20) = a3;
  *(_DWORD *)(a1 + 24) = a4;
  *(_DWORD *)(a1 + 28) = 2;
  *(_DWORD *)(a1 + 32) = 2 * a2;
  *(_DWORD *)(a1 + 36) = (2 * a2 * a3 + 63) & 0xFFFFFFC0;
  *(void *)(a1 + 40) = 0;
  *(void *)a1 = &unk_26C5FBE48;
  *(void *)(a1 + 8) = 0;
  size_t v6 = (a3 * a2);
  AttributeDictionary = cva::createAttributeDictionary((cva *)v6, a4, 2037741158, 64, 64, 0, 0, 0, v10);
  CVPixelBufferRef pixelBufferOut = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v6, a4, 0x79757666u, AttributeDictionary, &pixelBufferOut);
  CFRelease(AttributeDictionary);
  CVPixelBufferRef v8 = pixelBufferOut;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = v8;
  return a1;
}

{
  size_t v6;
  __CFDictionary *AttributeDictionary;
  CVPixelBufferRef v8;
  BOOL v10;
  CVPixelBufferRef pixelBufferOut;

  *(_DWORD *)(a1 + 16) = a2;
  *(_DWORD *)(a1 + 20) = a3;
  *(_DWORD *)(a1 + 24) = a4;
  *(_DWORD *)(a1 + 28) = 2;
  *(_DWORD *)(a1 + 32) = 2 * a2;
  *(_DWORD *)(a1 + 36) = (2 * a2 * a3 + 63) & 0xFFFFFFC0;
  *(void *)(a1 + 40) = 0;
  *(void *)a1 = &unk_26C5FBE48;
  *(void *)(a1 + 8) = 0;
  size_t v6 = (a3 * a2);
  AttributeDictionary = cva::createAttributeDictionary((cva *)v6, a4, 2037741158, 64, 64, 0, 0, 0, v10);
  CVPixelBufferRef pixelBufferOut = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v6, a4, 0x79757666u, AttributeDictionary, &pixelBufferOut);
  CFRelease(AttributeDictionary);
  CVPixelBufferRef v8 = pixelBufferOut;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = v8;
  return a1;
}

double cva::Buffer<unsigned short>::Buffer(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  uint64_t v2 = *(void *)(a2 + 16);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  *(void *)(a1 + 16) = v2;
  uint64_t v3 = *(void *)(a2 + 28);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(a2 + 36);
  *(void *)(a1 + 28) = v3;
  *(void *)a1 = &unk_26C5FBE48;
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  *(void *)(a2 + 28) = 0;
  *(_DWORD *)(a2 + 36) = 0;
  double result = 0.0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  return result;
}

{
  uint64_t v2;
  uint64_t v3;
  double result;

  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  uint64_t v2 = *(void *)(a2 + 16);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  *(void *)(a1 + 16) = v2;
  uint64_t v3 = *(void *)(a2 + 28);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(a2 + 36);
  *(void *)(a1 + 28) = v3;
  *(void *)a1 = &unk_26C5FBE48;
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  *(void *)(a2 + 28) = 0;
  *(_DWORD *)(a2 + 36) = 0;
  double result = 0.0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  return result;
}

__n128 cva::Buffer<unsigned short>::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v9 = *(void *)(a1 + 16);
  int v10 = *(_DWORD *)(a1 + 24);
  uint64_t v7 = *(void *)(a1 + 28);
  int v8 = *(_DWORD *)(a1 + 36);
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  uint64_t v3 = *(void *)(a2 + 16);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  *(void *)(a1 + 16) = v3;
  LODWORD(v3) = *(_DWORD *)(a2 + 36);
  *(void *)(a1 + 28) = *(void *)(a2 + 28);
  *(_DWORD *)(a1 + 36) = v3;
  *(void *)(a2 + 8) = v2;
  *(void *)(a2 + 16) = v9;
  *(_DWORD *)(a2 + 24) = v10;
  *(void *)(a2 + 28) = v7;
  *(_DWORD *)(a2 + 36) = v8;
  uint64_t v4 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = v4;
  uint64_t v5 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = v5;
  __n128 result = *(__n128 *)(a1 + 56);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(__n128 *)(a2 + 56) = result;
  return result;
}

uint64_t cva::Buffer<unsigned short>::Buffer(uint64_t a1, uint64_t a2)
{
  v39[3] = *(CVPixelBufferRef *)MEMORY[0x263EF8340];
  int v4 = *(_DWORD *)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 16);
  int v6 = 2 * *(_DWORD *)(a2 + 16);
  unsigned int v7 = (*(_DWORD *)(a2 + 20) * v6 + 63) & 0xFFFFFFC0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 24) = v4;
  *(_DWORD *)(a1 + 28) = 2;
  *(_DWORD *)(a1 + 32) = v6;
  *(_DWORD *)(a1 + 36) = v7;
  *(void *)(a1 + 40) = 0;
  *(void *)a1 = &unk_26C5FBE48;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  size_t v8 = *(unsigned int *)(a1 + 24);
  size_t v9 = (*(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16));
  AttributeDictionary = cva::createAttributeDictionary((cva *)v9, v8, 2037741158, 64, 64, 0, 0, 0, (BOOL)v39[0]);
  v39[0] = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v9, v8, 0x79757666u, AttributeDictionary, v39);
  CFRelease(AttributeDictionary);
  *(CVPixelBufferRef *)(a1 + 48) = v39[0];
  BOOL v11 = *(__CVBuffer **)(a2 + 48);
  if (v11 && !CVPixelBufferLockBaseAddress(v11, 1uLL))
  {
    CVPixelBufferGetWidth(*(CVPixelBufferRef *)(a2 + 48));
    CVPixelBufferGetHeight(*(CVPixelBufferRef *)(a2 + 48));
    CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)(a2 + 48));
    *(void *)(a2 + 40) = CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(a2 + 48));
    int v12 = *(__CVBuffer **)(a1 + 48);
    if (v12 && !CVPixelBufferLockBaseAddress(v12, 0))
    {
      CVPixelBufferGetWidth(*(CVPixelBufferRef *)(a1 + 48));
      CVPixelBufferGetHeight(*(CVPixelBufferRef *)(a1 + 48));
      CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)(a1 + 48));
      BaseAddress = (char *)CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(a1 + 48));
      *(void *)(a1 + 40) = BaseAddress;
      uint64_t v14 = *(unsigned int *)(a1 + 36);
      uint64_t v15 = *(unsigned int *)(a2 + 36);
      if (*(_DWORD *)(a1 + 28) == *(_DWORD *)(a2 + 28)
        && *(_DWORD *)(a1 + 32) == *(_DWORD *)(a2 + 32)
        && v14 == v15)
      {
        memcpy(BaseAddress, *(const void **)(a2 + 40), (*(_DWORD *)(a2 + 24) * v14));
      }
      else
      {
        uint64_t v16 = *(void *)(a2 + 40);
        if (v16) {
          int v17 = (_WORD *)(v16 + *(void *)(a2 + 8));
        }
        else {
          int v17 = 0;
        }
        if (v16) {
          int v18 = (_WORD *)(v16 + *(void *)(a2 + 8) + (*(_DWORD *)(a2 + 24) * v15));
        }
        else {
          int v18 = 0;
        }
        if (v17 != v18)
        {
          int v19 = 0;
          int v20 = 0;
          int v21 = 0;
          int v22 = 0;
          int v23 = *(_DWORD *)(a2 + 16);
          int v24 = *(_DWORD *)(a2 + 20);
          int v26 = *(_DWORD *)(a1 + 16);
          int v25 = *(_DWORD *)(a1 + 20);
          unint64_t v27 = *(void *)(a1 + 28);
          unint64_t v28 = *(void *)(a2 + 28);
          if (BaseAddress) {
            int v29 = &BaseAddress[*(void *)(a1 + 8)];
          }
          else {
            int v29 = 0;
          }
          uint64_t v30 = *(void *)(a2 + 28);
          unint64_t v31 = HIDWORD(v28);
          uint64_t v32 = *(void *)(a1 + 28);
          unint64_t v33 = HIDWORD(v27);
          uint64_t v34 = -(uint64_t)(v23 * v28);
          uint64_t v35 = -(uint64_t)(v26 * v27);
          do
          {
            *(_WORD *)int v29 = *v17;
            int v17 = (_WORD *)((char *)v17 + v30);
            if (++v20 == v23)
            {
              int v20 = 0;
              int v17 = (_WORD *)((char *)v17 + v34 + v31);
              int v36 = v19 + 1;
              if (v19 + 1 == v24) {
                int v19 = 0;
              }
              else {
                ++v19;
              }
              if (v36 == v24) {
                int v17 = (_WORD *)((char *)v17 + v15 - (v36 * v31));
              }
            }
            v29 += v32;
            if (++v22 == v26)
            {
              int v22 = 0;
              v29 += v35 + v33;
              int v37 = v21 + 1;
              if (v21 + 1 == v25) {
                int v21 = 0;
              }
              else {
                ++v21;
              }
              if (v37 == v25) {
                int v29 = &v29[v14 - (v37 * v33)];
              }
            }
          }
          while (v17 != v18);
        }
      }
      if (!CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a1 + 48), 0)) {
        *(void *)(a1 + 40) = 0;
      }
    }
    if (!CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a2 + 48), 1uLL)) {
      *(void *)(a2 + 40) = 0;
    }
  }
  return a1;
}

{
  int v4;
  uint64_t v5;
  int v6;
  unsigned int v7;
  size_t v8;
  size_t v9;
  __CFDictionary *AttributeDictionary;
  __CVBuffer *v11;
  char *BaseAddress;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _WORD *v16;
  _WORD *v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  unint64_t v26;
  unint64_t v27;
  char *v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  int v36;
  CVPixelBufferRef pixelBuffer[4];

  pixelBuffer[3] = *(CVPixelBufferRef *)MEMORY[0x263EF8340];
  int v4 = *(_DWORD *)(a2 + 16);
  uint64_t v5 = *(void *)(a2 + 8);
  int v6 = 2 * *(_DWORD *)(a2 + 8);
  unsigned int v7 = (*(_DWORD *)(a2 + 12) * v6 + 63) & 0xFFFFFFC0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 24) = v4;
  *(_DWORD *)(a1 + 28) = 2;
  *(_DWORD *)(a1 + 32) = v6;
  *(_DWORD *)(a1 + 36) = v7;
  *(void *)(a1 + 40) = 0;
  *(void *)a1 = &unk_26C5FBE48;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  size_t v8 = *(unsigned int *)(a1 + 24);
  size_t v9 = (*(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16));
  AttributeDictionary = cva::createAttributeDictionary((cva *)v9, v8, 2037741158, 64, 64, 0, 0, 0, (BOOL)pixelBuffer[0]);
  pixelBuffer[0] = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v9, v8, 0x79757666u, AttributeDictionary, pixelBuffer);
  CFRelease(AttributeDictionary);
  BOOL v11 = pixelBuffer[0];
  *(CVPixelBufferRef *)(a1 + 48) = pixelBuffer[0];
  if (v11 && !CVPixelBufferLockBaseAddress(v11, 0))
  {
    CVPixelBufferGetWidth(*(CVPixelBufferRef *)(a1 + 48));
    CVPixelBufferGetHeight(*(CVPixelBufferRef *)(a1 + 48));
    CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)(a1 + 48));
    BaseAddress = (char *)CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(a1 + 48));
    *(void *)(a1 + 40) = BaseAddress;
    int v13 = *(unsigned int *)(a1 + 36);
    uint64_t v14 = *(unsigned int *)(a2 + 28);
    if (*(_DWORD *)(a1 + 28) == *(_DWORD *)(a2 + 20)
      && *(_DWORD *)(a1 + 32) == *(_DWORD *)(a2 + 24)
      && v13 == v14)
    {
      memcpy(BaseAddress, *(const void **)(a2 + 32), (*(_DWORD *)(a2 + 16) * v13));
    }
    else
    {
      uint64_t v15 = *(void *)(a2 + 32);
      if (v15) {
        uint64_t v16 = (_WORD *)(v15 + *(void *)a2);
      }
      else {
        uint64_t v16 = 0;
      }
      if (v15) {
        int v17 = (_WORD *)(v15 + *(void *)a2 + (*(_DWORD *)(a2 + 16) * v14));
      }
      else {
        int v17 = 0;
      }
      if (v16 != v17)
      {
        int v18 = 0;
        int v19 = 0;
        int v20 = 0;
        int v21 = 0;
        int v22 = *(_DWORD *)(a2 + 8);
        int v23 = *(_DWORD *)(a2 + 12);
        int v25 = *(_DWORD *)(a1 + 16);
        int v24 = *(_DWORD *)(a1 + 20);
        int v26 = *(void *)(a1 + 28);
        unint64_t v27 = *(void *)(a2 + 20);
        if (BaseAddress) {
          unint64_t v28 = &BaseAddress[*(void *)(a1 + 8)];
        }
        else {
          unint64_t v28 = 0;
        }
        int v29 = *(void *)(a2 + 20);
        uint64_t v30 = HIDWORD(v27);
        unint64_t v31 = *(void *)(a1 + 28);
        uint64_t v32 = HIDWORD(v26);
        unint64_t v33 = -(uint64_t)(v22 * v27);
        uint64_t v34 = -(uint64_t)(v25 * v26);
        do
        {
          *(_WORD *)unint64_t v28 = *v16;
          uint64_t v16 = (_WORD *)((char *)v16 + v29);
          if (++v19 == v22)
          {
            int v19 = 0;
            uint64_t v16 = (_WORD *)((char *)v16 + v33 + v30);
            uint64_t v35 = v18 + 1;
            if (v18 + 1 == v23) {
              int v18 = 0;
            }
            else {
              ++v18;
            }
            if (v35 == v23) {
              uint64_t v16 = (_WORD *)((char *)v16 + v14 - (v35 * v30));
            }
          }
          v28 += v31;
          if (++v21 == v25)
          {
            int v21 = 0;
            v28 += v34 + v32;
            int v36 = v20 + 1;
            if (v20 + 1 == v24) {
              int v20 = 0;
            }
            else {
              ++v20;
            }
            if (v36 == v24) {
              unint64_t v28 = &v28[v13 - (v36 * v32)];
            }
          }
        }
        while (v16 != v17);
      }
    }
    if (!CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a1 + 48), 0)) {
      *(void *)(a1 + 40) = 0;
    }
  }
  return a1;
}

__CVBuffer *cva::Buffer<unsigned short>::lock(uint64_t a1, CVPixelBufferLockFlags a2)
{
  __n128 result = *(__CVBuffer **)(a1 + 48);
  if (result)
  {
    if (CVPixelBufferLockBaseAddress(result, a2))
    {
      return 0;
    }
    else
    {
      CVPixelBufferGetWidth(*(CVPixelBufferRef *)(a1 + 48));
      CVPixelBufferGetHeight(*(CVPixelBufferRef *)(a1 + 48));
      CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)(a1 + 48));
      *(void *)(a1 + 40) = CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(a1 + 48));
      return (__CVBuffer *)1;
    }
  }
  return result;
}

BOOL cva::Buffer<unsigned short>::unlock(uint64_t a1, CVPixelBufferLockFlags a2)
{
  CVReturn v3 = CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a1 + 48), a2);
  if (!v3) {
    *(void *)(a1 + 40) = 0;
  }
  return v3 == 0;
}

uint64_t cva::Buffer<unsigned short>::operator=(uint64_t a1, uint64_t a2)
{
  CVReturn v3 = *(__CVBuffer **)(a2 + 48);
  if (v3 && !CVPixelBufferLockBaseAddress(v3, 1uLL))
  {
    CVPixelBufferGetWidth(*(CVPixelBufferRef *)(a2 + 48));
    CVPixelBufferGetHeight(*(CVPixelBufferRef *)(a2 + 48));
    CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)(a2 + 48));
    *(void *)(a2 + 40) = CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(a2 + 48));
    uint64_t v5 = *(__CVBuffer **)(a1 + 48);
    if (v5 && !CVPixelBufferLockBaseAddress(v5, 0))
    {
      CVPixelBufferGetWidth(*(CVPixelBufferRef *)(a1 + 48));
      CVPixelBufferGetHeight(*(CVPixelBufferRef *)(a1 + 48));
      CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)(a1 + 48));
      BaseAddress = (char *)CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(a1 + 48));
      *(void *)(a1 + 40) = BaseAddress;
      uint64_t v7 = *(void *)(a2 + 40);
      uint64_t v8 = *(unsigned int *)(a2 + 36);
      if (v7) {
        size_t v9 = (_WORD *)(v7 + *(void *)(a2 + 8));
      }
      else {
        size_t v9 = 0;
      }
      if (v7) {
        int v10 = (_WORD *)(v7 + *(void *)(a2 + 8) + (*(_DWORD *)(a2 + 24) * v8));
      }
      else {
        int v10 = 0;
      }
      if (v9 != v10)
      {
        int v11 = 0;
        int v12 = 0;
        int v13 = 0;
        int v14 = 0;
        unint64_t v15 = *(void *)(a1 + 28);
        unint64_t v16 = *(void *)(a2 + 28);
        int v17 = *(_DWORD *)(a1 + 16);
        int v18 = *(_DWORD *)(a1 + 20);
        int v20 = *(_DWORD *)(a2 + 16);
        int v19 = *(_DWORD *)(a2 + 20);
        unint64_t v21 = HIDWORD(v16);
        unint64_t v22 = HIDWORD(v15);
        uint64_t v23 = *(unsigned int *)(a1 + 36);
        if (BaseAddress) {
          int v24 = &BaseAddress[*(void *)(a1 + 8)];
        }
        else {
          int v24 = 0;
        }
        uint64_t v25 = *(void *)(a2 + 28);
        uint64_t v26 = *(void *)(a1 + 28);
        uint64_t v27 = -(uint64_t)(v20 * v16);
        uint64_t v28 = -(uint64_t)(v17 * v15);
        do
        {
          *(_WORD *)int v24 = *v9;
          size_t v9 = (_WORD *)((char *)v9 + v25);
          if (++v13 == v20)
          {
            int v13 = 0;
            size_t v9 = (_WORD *)((char *)v9 + v27 + v21);
            int v29 = v14 + 1;
            if (v14 + 1 == v19) {
              int v14 = 0;
            }
            else {
              ++v14;
            }
            if (v29 == v19) {
              size_t v9 = (_WORD *)((char *)v9 + v8 - (v29 * v21));
            }
          }
          v24 += v26;
          if (++v11 == v17)
          {
            int v11 = 0;
            v24 += v28 + v22;
            int v30 = v12 + 1;
            if (v12 + 1 == v18) {
              int v12 = 0;
            }
            else {
              ++v12;
            }
            if (v30 == v18) {
              int v24 = &v24[v23 - (v30 * v22)];
            }
          }
        }
        while (v9 != v10);
      }
      if (!CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a1 + 48), 0)) {
        *(void *)(a1 + 40) = 0;
      }
    }
    if (!CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a2 + 48), 1uLL)) {
      *(void *)(a2 + 40) = 0;
    }
  }
  return a1;
}

{
  __CVBuffer *v3;
  char *BaseAddress;
  uint64_t v6;
  uint64_t v7;
  _WORD *v8;
  _WORD *v9;
  int v10;
  int v11;
  int v12;
  int v13;
  unint64_t v14;
  unint64_t v15;
  int v16;
  int v17;
  int v18;
  int v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;

  CVReturn v3 = *(__CVBuffer **)(a1 + 48);
  if (v3 && !CVPixelBufferLockBaseAddress(v3, 0))
  {
    CVPixelBufferGetWidth(*(CVPixelBufferRef *)(a1 + 48));
    CVPixelBufferGetHeight(*(CVPixelBufferRef *)(a1 + 48));
    CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)(a1 + 48));
    BaseAddress = (char *)CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(a1 + 48));
    *(void *)(a1 + 40) = BaseAddress;
    int v6 = *(void *)(a2 + 32);
    uint64_t v7 = *(unsigned int *)(a2 + 28);
    if (v6) {
      uint64_t v8 = (_WORD *)(v6 + *(void *)a2);
    }
    else {
      uint64_t v8 = 0;
    }
    if (v6) {
      size_t v9 = (_WORD *)(v6 + *(void *)a2 + (*(_DWORD *)(a2 + 16) * v7));
    }
    else {
      size_t v9 = 0;
    }
    if (v8 != v9)
    {
      int v10 = 0;
      int v11 = 0;
      int v12 = 0;
      int v13 = 0;
      int v14 = *(void *)(a1 + 28);
      unint64_t v15 = *(void *)(a2 + 20);
      unint64_t v16 = *(_DWORD *)(a1 + 16);
      int v17 = *(_DWORD *)(a1 + 20);
      int v19 = *(_DWORD *)(a2 + 8);
      int v18 = *(_DWORD *)(a2 + 12);
      int v20 = HIDWORD(v15);
      unint64_t v21 = HIDWORD(v14);
      unint64_t v22 = *(unsigned int *)(a1 + 36);
      if (BaseAddress) {
        uint64_t v23 = &BaseAddress[*(void *)(a1 + 8)];
      }
      else {
        uint64_t v23 = 0;
      }
      int v24 = v15;
      uint64_t v25 = *(void *)(a1 + 28);
      uint64_t v26 = -(uint64_t)(v19 * v15);
      uint64_t v27 = -(uint64_t)(v16 * v14);
      do
      {
        *(_WORD *)uint64_t v23 = *v8;
        uint64_t v8 = (_WORD *)((char *)v8 + v24);
        if (++v12 == v19)
        {
          int v12 = 0;
          uint64_t v8 = (_WORD *)((char *)v8 + v26 + v20);
          uint64_t v28 = v13 + 1;
          if (v13 + 1 == v18) {
            int v13 = 0;
          }
          else {
            ++v13;
          }
          if (v28 == v18) {
            uint64_t v8 = (_WORD *)((char *)v8 + v7 - (v28 * v20));
          }
        }
        v23 += v25;
        if (++v10 == v16)
        {
          int v10 = 0;
          v23 += v27 + v21;
          int v29 = v11 + 1;
          if (v11 + 1 == v17) {
            int v11 = 0;
          }
          else {
            ++v11;
          }
          if (v29 == v17) {
            uint64_t v23 = &v23[v22 - (v29 * v21)];
          }
        }
      }
      while (v8 != v9);
    }
    if (!CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a1 + 48), 0)) {
      *(void *)(a1 + 40) = 0;
    }
  }
  return a1;
}

uint64_t cva::Buffer<unsigned short>::resize(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[7];
  if (v4)
  {

    MEMORY[0x2166B9890](v4, 0xE0C400670D255);
  }
  a1[7] = 0;
  uint64_t v5 = a1[8];
  if (v5)
  {

    MEMORY[0x2166B9890](v5, 0xE0C400670D255);
  }
  a1[8] = 0;
  int v6 = *(uint64_t (**)(void *, uint64_t))(*a1 + 16);
  return v6(a1, a2);
}

uint64_t cva::Buffer<unsigned short>::resize(void *a1, int a2, int a3, int a4)
{
  v8[0] = a2;
  v8[1] = a3;
  v8[2] = a4;
  uint64_t v5 = a1[7];
  if (v5)
  {

    MEMORY[0x2166B9890](v5, 0xE0C400670D255);
  }
  a1[7] = 0;
  uint64_t v6 = a1[8];
  if (v6)
  {

    MEMORY[0x2166B9890](v6, 0xE0C400670D255);
  }
  a1[8] = 0;
  return (*(uint64_t (**)(void *, _DWORD *))(*a1 + 16))(a1, v8);
}

uint64_t cva::Buffer<unsigned short>::operator __CVBuffer *(uint64_t a1)
{
  return *(void *)(a1 + 48);
}

CVPixelBufferRef cva::Buffer<unsigned short>::allocate(_DWORD *a1, OSType a2)
{
  size_t v3 = (a1[1] * *a1);
  size_t v4 = a1[2];
  AttributeDictionary = cva::createAttributeDictionary((cva *)v3, v4, a2, 64, 64, 0, 0, 0, v7);
  CVPixelBufferRef pixelBufferOut = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v3, v4, a2, AttributeDictionary, &pixelBufferOut);
  CFRelease(AttributeDictionary);
  return pixelBufferOut;
}

double cva::Buffer<unsigned char>::Buffer(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)a1 = &unk_26C5FBDE8;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  return result;
}

{
  double result;

  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)a1 = &unk_26C5FBDE8;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  return result;
}

uint64_t cva::Buffer<unsigned char>::Buffer(uint64_t a1, int *a2)
{
  int v3 = *a2;
  *(void *)(a1 + 8) = 0;
  size_t v4 = a2[2];
  unsigned int v5 = (a2[1] * v3 + 63) & 0xFFFFFFC0;
  uint64_t v6 = *(void *)a2;
  *(void *)(a1 + 16) = *(void *)a2;
  *(_DWORD *)(a1 + 24) = v4;
  *(_DWORD *)(a1 + 28) = 1;
  *(_DWORD *)(a1 + 32) = v3;
  *(_DWORD *)(a1 + 36) = v5;
  *(void *)(a1 + 40) = 0;
  *(void *)a1 = &unk_26C5FBDE8;
  size_t v7 = (HIDWORD(v6) * v6);
  AttributeDictionary = cva::createAttributeDictionary((cva *)v7, v4, 1278226488, 64, 64, 0, 0, 0, v11);
  CVPixelBufferRef pixelBufferOut = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v7, v4, 0x4C303038u, AttributeDictionary, &pixelBufferOut);
  CFRelease(AttributeDictionary);
  CVPixelBufferRef v9 = pixelBufferOut;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = v9;
  return a1;
}

{
  int v3;
  size_t v4;
  unsigned int v5;
  uint64_t v6;
  size_t v7;
  __CFDictionary *AttributeDictionary;
  CVPixelBufferRef v9;
  BOOL v11;
  CVPixelBufferRef pixelBufferOut;

  int v3 = *a2;
  *(void *)(a1 + 8) = 0;
  size_t v4 = a2[2];
  unsigned int v5 = (a2[1] * v3 + 63) & 0xFFFFFFC0;
  uint64_t v6 = *(void *)a2;
  *(void *)(a1 + 16) = *(void *)a2;
  *(_DWORD *)(a1 + 24) = v4;
  *(_DWORD *)(a1 + 28) = 1;
  *(_DWORD *)(a1 + 32) = v3;
  *(_DWORD *)(a1 + 36) = v5;
  *(void *)(a1 + 40) = 0;
  *(void *)a1 = &unk_26C5FBDE8;
  size_t v7 = (HIDWORD(v6) * v6);
  AttributeDictionary = cva::createAttributeDictionary((cva *)v7, v4, 1278226488, 64, 64, 0, 0, 0, v11);
  CVPixelBufferRef pixelBufferOut = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v7, v4, 0x4C303038u, AttributeDictionary, &pixelBufferOut);
  CFRelease(AttributeDictionary);
  CVPixelBufferRef v9 = pixelBufferOut;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = v9;
  return a1;
}

int *cva::Buffer<unsigned char>::defaultStride@<X0>(int *result@<X0>, _DWORD *a2@<X8>)
{
  int v2 = *result;
  int v3 = result[1];
  *a2 = 1;
  a2[1] = v2;
  a2[2] = (v3 * v2 + 63) & 0xFFFFFFC0;
  return result;
}

CVPixelBufferRef cva::Buffer<unsigned char>::allocate(_DWORD *a1)
{
  size_t v1 = (a1[1] * *a1);
  size_t v2 = a1[2];
  AttributeDictionary = cva::createAttributeDictionary((cva *)v1, v2, 1278226488, 64, 64, 0, 0, 0, v5);
  CVPixelBufferRef pixelBufferOut = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v1, v2, 0x4C303038u, AttributeDictionary, &pixelBufferOut);
  CFRelease(AttributeDictionary);
  return pixelBufferOut;
}

uint64_t cva::Buffer<unsigned char>::Buffer(uint64_t a1, int a2, int a3, unsigned int a4)
{
  size_t v6 = (a3 * a2);
  *(_DWORD *)(a1 + 16) = a2;
  *(_DWORD *)(a1 + 20) = a3;
  *(_DWORD *)(a1 + 24) = a4;
  *(_DWORD *)(a1 + 28) = 1;
  *(_DWORD *)(a1 + 32) = a2;
  *(_DWORD *)(a1 + 36) = (v6 + 63) & 0xFFFFFFC0;
  *(void *)(a1 + 40) = 0;
  *(void *)a1 = &unk_26C5FBDE8;
  *(void *)(a1 + 8) = 0;
  AttributeDictionary = cva::createAttributeDictionary((cva *)v6, a4, 1278226488, 64, 64, 0, 0, 0, v10);
  CVPixelBufferRef pixelBufferOut = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v6, a4, 0x4C303038u, AttributeDictionary, &pixelBufferOut);
  CFRelease(AttributeDictionary);
  CVPixelBufferRef v8 = pixelBufferOut;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = v8;
  return a1;
}

{
  size_t v6;
  __CFDictionary *AttributeDictionary;
  CVPixelBufferRef v8;
  BOOL v10;
  CVPixelBufferRef pixelBufferOut;

  size_t v6 = (a3 * a2);
  *(_DWORD *)(a1 + 16) = a2;
  *(_DWORD *)(a1 + 20) = a3;
  *(_DWORD *)(a1 + 24) = a4;
  *(_DWORD *)(a1 + 28) = 1;
  *(_DWORD *)(a1 + 32) = a2;
  *(_DWORD *)(a1 + 36) = (v6 + 63) & 0xFFFFFFC0;
  *(void *)(a1 + 40) = 0;
  *(void *)a1 = &unk_26C5FBDE8;
  *(void *)(a1 + 8) = 0;
  AttributeDictionary = cva::createAttributeDictionary((cva *)v6, a4, 1278226488, 64, 64, 0, 0, 0, v10);
  CVPixelBufferRef pixelBufferOut = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v6, a4, 0x4C303038u, AttributeDictionary, &pixelBufferOut);
  CFRelease(AttributeDictionary);
  CVPixelBufferRef v8 = pixelBufferOut;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = v8;
  return a1;
}

double cva::Buffer<unsigned char>::Buffer(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  uint64_t v2 = *(void *)(a2 + 16);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  *(void *)(a1 + 16) = v2;
  uint64_t v3 = *(void *)(a2 + 28);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(a2 + 36);
  *(void *)(a1 + 28) = v3;
  *(void *)a1 = &unk_26C5FBDE8;
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  *(void *)(a2 + 28) = 0;
  *(_DWORD *)(a2 + 36) = 0;
  double result = 0.0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  return result;
}

{
  uint64_t v2;
  uint64_t v3;
  double result;

  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  uint64_t v2 = *(void *)(a2 + 16);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  *(void *)(a1 + 16) = v2;
  uint64_t v3 = *(void *)(a2 + 28);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(a2 + 36);
  *(void *)(a1 + 28) = v3;
  *(void *)a1 = &unk_26C5FBDE8;
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  *(void *)(a2 + 28) = 0;
  *(_DWORD *)(a2 + 36) = 0;
  double result = 0.0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  return result;
}

__n128 cva::Buffer<unsigned char>::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v9 = *(void *)(a1 + 16);
  int v10 = *(_DWORD *)(a1 + 24);
  uint64_t v7 = *(void *)(a1 + 28);
  int v8 = *(_DWORD *)(a1 + 36);
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  uint64_t v3 = *(void *)(a2 + 16);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  *(void *)(a1 + 16) = v3;
  LODWORD(v3) = *(_DWORD *)(a2 + 36);
  *(void *)(a1 + 28) = *(void *)(a2 + 28);
  *(_DWORD *)(a1 + 36) = v3;
  *(void *)(a2 + 8) = v2;
  *(void *)(a2 + 16) = v9;
  *(_DWORD *)(a2 + 24) = v10;
  *(void *)(a2 + 28) = v7;
  *(_DWORD *)(a2 + 36) = v8;
  uint64_t v4 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = v4;
  uint64_t v5 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = v5;
  __n128 result = *(__n128 *)(a1 + 56);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(__n128 *)(a2 + 56) = result;
  return result;
}

uint64_t cva::Buffer<unsigned char>::Buffer(uint64_t a1, uint64_t a2)
{
  v37[3] = *(CVPixelBufferRef *)MEMORY[0x263EF8340];
  int v4 = *(_DWORD *)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 16);
  int v6 = *(_DWORD *)(a2 + 16);
  unsigned int v7 = (*(_DWORD *)(a2 + 20) * v6 + 63) & 0xFFFFFFC0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 24) = v4;
  *(_DWORD *)(a1 + 28) = 1;
  *(_DWORD *)(a1 + 32) = v6;
  *(_DWORD *)(a1 + 36) = v7;
  *(void *)(a1 + 40) = 0;
  *(void *)a1 = &unk_26C5FBDE8;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  size_t v8 = *(unsigned int *)(a1 + 24);
  size_t v9 = (*(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16));
  AttributeDictionary = cva::createAttributeDictionary((cva *)v9, v8, 1278226488, 64, 64, 0, 0, 0, (BOOL)v37[0]);
  v37[0] = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v9, v8, 0x4C303038u, AttributeDictionary, v37);
  CFRelease(AttributeDictionary);
  *(CVPixelBufferRef *)(a1 + 48) = v37[0];
  BOOL v11 = *(__CVBuffer **)(a2 + 48);
  if (v11 && !CVPixelBufferLockBaseAddress(v11, 1uLL))
  {
    CVPixelBufferGetWidth(*(CVPixelBufferRef *)(a2 + 48));
    CVPixelBufferGetHeight(*(CVPixelBufferRef *)(a2 + 48));
    CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)(a2 + 48));
    *(void *)(a2 + 40) = CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(a2 + 48));
    int v12 = *(__CVBuffer **)(a1 + 48);
    if (v12 && !CVPixelBufferLockBaseAddress(v12, 0))
    {
      CVPixelBufferGetWidth(*(CVPixelBufferRef *)(a1 + 48));
      CVPixelBufferGetHeight(*(CVPixelBufferRef *)(a1 + 48));
      CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)(a1 + 48));
      BaseAddress = CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(a1 + 48));
      *(void *)(a1 + 40) = BaseAddress;
      uint64_t v14 = *(unsigned int *)(a1 + 28);
      uint64_t v15 = *(unsigned int *)(a1 + 32);
      uint64_t v16 = *(unsigned int *)(a1 + 36);
      uint64_t v17 = *(unsigned int *)(a2 + 28);
      uint64_t v18 = *(unsigned int *)(a2 + 32);
      uint64_t v19 = *(unsigned int *)(a2 + 36);
      if (__PAIR64__(v15, v14) == __PAIR64__(v18, v17) && v16 == v19)
      {
        memcpy(BaseAddress, *(const void **)(a2 + 40), (*(_DWORD *)(a2 + 24) * v16));
      }
      else
      {
        uint64_t v20 = *(void *)(a2 + 40);
        uint64_t v21 = *(void *)(a2 + 8);
        uint64_t v22 = v20 + v21;
        BOOL v23 = v20 == 0;
        if (v20) {
          int v24 = (unsigned char *)(v20 + v21);
        }
        else {
          int v24 = 0;
        }
        uint64_t v25 = (unsigned char *)(v22 + (v19 * *(_DWORD *)(a2 + 24)));
        if (v23) {
          uint64_t v25 = 0;
        }
        if (BaseAddress) {
          BaseAddress += *(void *)(a1 + 8);
        }
        if (v24 != v25)
        {
          int v26 = 0;
          int v27 = 0;
          int v28 = 0;
          int v29 = 0;
          int v30 = *(_DWORD *)(a2 + 16);
          int v31 = *(_DWORD *)(a2 + 20);
          int v32 = *(_DWORD *)(a1 + 16);
          int v33 = *(_DWORD *)(a1 + 20);
          do
          {
            unsigned char *BaseAddress = *v24;
            v24 += v17;
            if (++v26 == v30)
            {
              int v26 = 0;
              int v24 = &v24[v18 - (v17 * v30)];
              int v34 = v27 + 1;
              if (v27 + 1 == v31) {
                int v27 = 0;
              }
              else {
                ++v27;
              }
              if (v34 == v31) {
                int v24 = &v24[v19 - (v18 * v34)];
              }
            }
            BaseAddress += v14;
            if (++v28 == v32)
            {
              int v28 = 0;
              BaseAddress = &BaseAddress[v15 - (v14 * v32)];
              int v35 = v29 + 1;
              if (v29 + 1 == v33) {
                int v29 = 0;
              }
              else {
                ++v29;
              }
              if (v35 == v33) {
                BaseAddress = &BaseAddress[v16 - (v15 * v35)];
              }
            }
          }
          while (v24 != v25);
        }
      }
      if (!CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a1 + 48), 0)) {
        *(void *)(a1 + 40) = 0;
      }
    }
    if (!CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a2 + 48), 1uLL)) {
      *(void *)(a2 + 40) = 0;
    }
  }
  return a1;
}

{
  int v4;
  uint64_t v5;
  int v6;
  unsigned int v7;
  size_t v8;
  size_t v9;
  __CFDictionary *AttributeDictionary;
  __CVBuffer *v11;
  unsigned char *BaseAddress;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  BOOL v20;
  unsigned char *v21;
  unsigned char *v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  CVPixelBufferRef pixelBuffer[4];

  pixelBuffer[3] = *(CVPixelBufferRef *)MEMORY[0x263EF8340];
  int v4 = *(_DWORD *)(a2 + 16);
  uint64_t v5 = *(void *)(a2 + 8);
  int v6 = *(_DWORD *)(a2 + 8);
  unsigned int v7 = (*(_DWORD *)(a2 + 12) * v6 + 63) & 0xFFFFFFC0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 24) = v4;
  *(_DWORD *)(a1 + 28) = 1;
  *(_DWORD *)(a1 + 32) = v6;
  *(_DWORD *)(a1 + 36) = v7;
  *(void *)(a1 + 40) = 0;
  *(void *)a1 = &unk_26C5FBDE8;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  size_t v8 = *(unsigned int *)(a1 + 24);
  size_t v9 = (*(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16));
  AttributeDictionary = cva::createAttributeDictionary((cva *)v9, v8, 1278226488, 64, 64, 0, 0, 0, (BOOL)pixelBuffer[0]);
  pixelBuffer[0] = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v9, v8, 0x4C303038u, AttributeDictionary, pixelBuffer);
  CFRelease(AttributeDictionary);
  BOOL v11 = pixelBuffer[0];
  *(CVPixelBufferRef *)(a1 + 48) = pixelBuffer[0];
  if (v11 && !CVPixelBufferLockBaseAddress(v11, 0))
  {
    CVPixelBufferGetWidth(*(CVPixelBufferRef *)(a1 + 48));
    CVPixelBufferGetHeight(*(CVPixelBufferRef *)(a1 + 48));
    CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)(a1 + 48));
    BaseAddress = CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(a1 + 48));
    *(void *)(a1 + 40) = BaseAddress;
    int v13 = *(unsigned int *)(a1 + 28);
    uint64_t v14 = *(unsigned int *)(a1 + 32);
    uint64_t v15 = *(unsigned int *)(a1 + 36);
    uint64_t v16 = *(unsigned int *)(a2 + 20);
    uint64_t v17 = *(unsigned int *)(a2 + 24);
    uint64_t v18 = *(unsigned int *)(a2 + 28);
    if (__PAIR64__(v14, v13) == __PAIR64__(v17, v16) && v15 == v18)
    {
      memcpy(BaseAddress, *(const void **)(a2 + 32), (*(_DWORD *)(a2 + 16) * v15));
    }
    else
    {
      uint64_t v19 = *(void *)(a2 + 32);
      uint64_t v20 = v19 == 0;
      if (v19) {
        uint64_t v21 = (unsigned char *)(v19 + *(void *)a2);
      }
      else {
        uint64_t v21 = 0;
      }
      uint64_t v22 = (unsigned char *)(v19 + *(void *)a2 + (v18 * *(_DWORD *)(a2 + 16)));
      if (v20) {
        uint64_t v22 = 0;
      }
      if (BaseAddress) {
        BaseAddress += *(void *)(a1 + 8);
      }
      if (v21 != v22)
      {
        BOOL v23 = 0;
        int v24 = 0;
        uint64_t v25 = 0;
        int v26 = 0;
        int v27 = *(_DWORD *)(a2 + 8);
        int v28 = *(_DWORD *)(a2 + 12);
        int v29 = *(_DWORD *)(a1 + 16);
        int v30 = *(_DWORD *)(a1 + 20);
        do
        {
          unsigned char *BaseAddress = *v21;
          v21 += v16;
          if (++v23 == v27)
          {
            BOOL v23 = 0;
            uint64_t v21 = &v21[v17 - (v16 * v27)];
            int v31 = v24 + 1;
            if (v24 + 1 == v28) {
              int v24 = 0;
            }
            else {
              ++v24;
            }
            if (v31 == v28) {
              uint64_t v21 = &v21[v18 - (v17 * v31)];
            }
          }
          BaseAddress += v13;
          if (++v25 == v29)
          {
            uint64_t v25 = 0;
            BaseAddress = &BaseAddress[v14 - (v13 * v29)];
            int v32 = v26 + 1;
            if (v26 + 1 == v30) {
              int v26 = 0;
            }
            else {
              ++v26;
            }
            if (v32 == v30) {
              BaseAddress = &BaseAddress[v15 - (v14 * v32)];
            }
          }
        }
        while (v21 != v22);
      }
    }
    if (!CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a1 + 48), 0)) {
      *(void *)(a1 + 40) = 0;
    }
  }
  return a1;
}

__CVBuffer *cva::Buffer<unsigned char>::lock(uint64_t a1, CVPixelBufferLockFlags a2)
{
  __n128 result = *(__CVBuffer **)(a1 + 48);
  if (result)
  {
    if (CVPixelBufferLockBaseAddress(result, a2))
    {
      return 0;
    }
    else
    {
      CVPixelBufferGetWidth(*(CVPixelBufferRef *)(a1 + 48));
      CVPixelBufferGetHeight(*(CVPixelBufferRef *)(a1 + 48));
      CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)(a1 + 48));
      *(void *)(a1 + 40) = CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(a1 + 48));
      return (__CVBuffer *)1;
    }
  }
  return result;
}

BOOL cva::Buffer<unsigned char>::unlock(uint64_t a1, CVPixelBufferLockFlags a2)
{
  CVReturn v3 = CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a1 + 48), a2);
  if (!v3) {
    *(void *)(a1 + 40) = 0;
  }
  return v3 == 0;
}

uint64_t cva::Buffer<unsigned char>::operator=(uint64_t a1, uint64_t a2)
{
  CVReturn v3 = *(__CVBuffer **)(a2 + 48);
  if (v3 && !CVPixelBufferLockBaseAddress(v3, 1uLL))
  {
    CVPixelBufferGetWidth(*(CVPixelBufferRef *)(a2 + 48));
    CVPixelBufferGetHeight(*(CVPixelBufferRef *)(a2 + 48));
    CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)(a2 + 48));
    *(void *)(a2 + 40) = CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(a2 + 48));
    uint64_t v5 = *(__CVBuffer **)(a1 + 48);
    if (v5 && !CVPixelBufferLockBaseAddress(v5, 0))
    {
      CVPixelBufferGetWidth(*(CVPixelBufferRef *)(a1 + 48));
      CVPixelBufferGetHeight(*(CVPixelBufferRef *)(a1 + 48));
      CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)(a1 + 48));
      BaseAddress = (char *)CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(a1 + 48));
      *(void *)(a1 + 40) = BaseAddress;
      uint64_t v7 = *(void *)(a2 + 40);
      uint64_t v8 = *(unsigned int *)(a2 + 36);
      if (v7) {
        size_t v9 = (char *)(v7 + *(void *)(a2 + 8));
      }
      else {
        size_t v9 = 0;
      }
      if (v7) {
        int v10 = (char *)(v7 + *(void *)(a2 + 8) + (*(_DWORD *)(a2 + 24) * v8));
      }
      else {
        int v10 = 0;
      }
      if (v9 != v10)
      {
        int v11 = 0;
        int v12 = 0;
        int v13 = 0;
        int v14 = 0;
        int v15 = *(_DWORD *)(a1 + 16);
        int v16 = *(_DWORD *)(a1 + 20);
        int v17 = *(_DWORD *)(a2 + 16);
        int v18 = *(_DWORD *)(a2 + 20);
        unint64_t v19 = *(void *)(a2 + 28);
        uint64_t v20 = *(unsigned int *)(a1 + 36);
        unint64_t v21 = *(void *)(a1 + 28);
        if (BaseAddress) {
          uint64_t v22 = &BaseAddress[*(void *)(a1 + 8)];
        }
        else {
          uint64_t v22 = 0;
        }
        uint64_t v23 = *(void *)(a2 + 28);
        unint64_t v24 = HIDWORD(v19);
        uint64_t v25 = *(void *)(a1 + 28);
        unint64_t v26 = HIDWORD(v21);
        uint64_t v27 = -(uint64_t)(v17 * v19);
        uint64_t v28 = -(uint64_t)(v15 * v21);
        do
        {
          char v29 = *v9;
          v9 += v23;
          int v30 = v14 + 1;
          char *v22 = v29;
          int v31 = &v9[v27 + v24];
          if (v13 + 1 == v18) {
            int v32 = 0;
          }
          else {
            int v32 = v13 + 1;
          }
          if (v13 + 1 == v18) {
            int v31 = &v31[v8 - (v18 * v24)];
          }
          if (v30 == v17)
          {
            int v13 = v32;
            int v14 = 0;
          }
          else
          {
            ++v14;
          }
          if (v30 == v17) {
            size_t v9 = v31;
          }
          v22 += v25;
          int v33 = v12 + 1;
          int v34 = &v22[v28 + v26];
          if (v11 + 1 == v16) {
            int v35 = 0;
          }
          else {
            int v35 = v11 + 1;
          }
          if (v11 + 1 == v16) {
            int v34 = &v34[v20 - (v16 * v26)];
          }
          if (v33 == v15)
          {
            int v11 = v35;
            int v12 = 0;
          }
          else
          {
            ++v12;
          }
          if (v33 == v15) {
            uint64_t v22 = v34;
          }
        }
        while (v9 != v10);
      }
      if (!CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a1 + 48), 0)) {
        *(void *)(a1 + 40) = 0;
      }
    }
    if (!CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a2 + 48), 1uLL)) {
      *(void *)(a2 + 40) = 0;
    }
  }
  return a1;
}

{
  __CVBuffer *v3;
  char *BaseAddress;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  char *v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char v28;
  int v29;
  char *v30;
  int v31;
  int v32;
  char *v33;
  int v34;

  CVReturn v3 = *(__CVBuffer **)(a1 + 48);
  if (v3 && !CVPixelBufferLockBaseAddress(v3, 0))
  {
    CVPixelBufferGetWidth(*(CVPixelBufferRef *)(a1 + 48));
    CVPixelBufferGetHeight(*(CVPixelBufferRef *)(a1 + 48));
    CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)(a1 + 48));
    BaseAddress = (char *)CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(a1 + 48));
    *(void *)(a1 + 40) = BaseAddress;
    int v6 = *(void *)(a2 + 32);
    uint64_t v7 = *(unsigned int *)(a2 + 28);
    if (v6) {
      uint64_t v8 = (char *)(v6 + *(void *)a2);
    }
    else {
      uint64_t v8 = 0;
    }
    if (v6) {
      size_t v9 = (char *)(v6 + *(void *)a2 + (*(_DWORD *)(a2 + 16) * v7));
    }
    else {
      size_t v9 = 0;
    }
    if (v8 != v9)
    {
      int v10 = 0;
      int v11 = 0;
      int v12 = 0;
      int v13 = 0;
      int v14 = *(_DWORD *)(a1 + 16);
      int v15 = *(_DWORD *)(a1 + 20);
      int v16 = *(_DWORD *)(a2 + 8);
      int v17 = *(_DWORD *)(a2 + 12);
      int v18 = *(void *)(a2 + 20);
      unint64_t v19 = *(unsigned int *)(a1 + 36);
      uint64_t v20 = *(void *)(a1 + 28);
      if (BaseAddress) {
        unint64_t v21 = &BaseAddress[*(void *)(a1 + 8)];
      }
      else {
        unint64_t v21 = 0;
      }
      uint64_t v22 = *(void *)(a2 + 20);
      uint64_t v23 = HIDWORD(v18);
      unint64_t v24 = *(void *)(a1 + 28);
      uint64_t v25 = HIDWORD(v20);
      unint64_t v26 = -(uint64_t)(v16 * v18);
      uint64_t v27 = -(uint64_t)(v14 * v20);
      do
      {
        uint64_t v28 = *v8;
        v8 += v22;
        char v29 = v13 + 1;
        *unint64_t v21 = v28;
        int v30 = &v8[v26 + v23];
        if (v12 + 1 == v17) {
          int v31 = 0;
        }
        else {
          int v31 = v12 + 1;
        }
        if (v12 + 1 == v17) {
          int v30 = &v30[v7 - (v17 * v23)];
        }
        if (v29 == v16)
        {
          int v12 = v31;
          int v13 = 0;
        }
        else
        {
          ++v13;
        }
        if (v29 == v16) {
          uint64_t v8 = v30;
        }
        v21 += v24;
        int v32 = v11 + 1;
        int v33 = &v21[v27 + v25];
        if (v10 + 1 == v15) {
          int v34 = 0;
        }
        else {
          int v34 = v10 + 1;
        }
        if (v10 + 1 == v15) {
          int v33 = &v33[v19 - (v15 * v25)];
        }
        if (v32 == v14)
        {
          int v10 = v34;
          int v11 = 0;
        }
        else
        {
          ++v11;
        }
        if (v32 == v14) {
          unint64_t v21 = v33;
        }
      }
      while (v8 != v9);
    }
    if (!CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a1 + 48), 0)) {
      *(void *)(a1 + 40) = 0;
    }
  }
  return a1;
}

uint64_t cva::Buffer<unsigned char>::resize(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[7];
  if (v4)
  {

    MEMORY[0x2166B9890](v4, 0xE0C400670D255);
  }
  a1[7] = 0;
  uint64_t v5 = a1[8];
  if (v5)
  {

    MEMORY[0x2166B9890](v5, 0xE0C400670D255);
  }
  a1[8] = 0;
  int v6 = *(uint64_t (**)(void *, uint64_t))(*a1 + 16);
  return v6(a1, a2);
}

uint64_t cva::Buffer<unsigned char>::resize(void *a1, int a2, int a3, int a4)
{
  v8[0] = a2;
  v8[1] = a3;
  v8[2] = a4;
  uint64_t v5 = a1[7];
  if (v5)
  {

    MEMORY[0x2166B9890](v5, 0xE0C400670D255);
  }
  a1[7] = 0;
  uint64_t v6 = a1[8];
  if (v6)
  {

    MEMORY[0x2166B9890](v6, 0xE0C400670D255);
  }
  a1[8] = 0;
  return (*(uint64_t (**)(void *, _DWORD *))(*a1 + 16))(a1, v8);
}

uint64_t cva::Buffer<unsigned char>::operator __CVBuffer *(uint64_t a1)
{
  return *(void *)(a1 + 48);
}

CVPixelBufferRef cva::Buffer<unsigned char>::allocate(_DWORD *a1, OSType a2)
{
  size_t v3 = (a1[1] * *a1);
  size_t v4 = a1[2];
  AttributeDictionary = cva::createAttributeDictionary((cva *)v3, v4, a2, 64, 64, 0, 0, 0, v7);
  CVPixelBufferRef pixelBufferOut = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v3, v4, a2, AttributeDictionary, &pixelBufferOut);
  CFRelease(AttributeDictionary);
  return pixelBufferOut;
}

double cva::Buffer<unsigned int>::Buffer(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)a1 = &unk_26C5FBE18;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  return result;
}

{
  double result;

  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)a1 = &unk_26C5FBE18;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  return result;
}

uint64_t cva::Buffer<unsigned int>::Buffer(uint64_t a1, _DWORD *a2)
{
  int v3 = 4 * *a2;
  *(void *)(a1 + 8) = 0;
  size_t v4 = a2[2];
  unsigned int v5 = (a2[1] * v3 + 63) & 0xFFFFFFC0;
  uint64_t v6 = *(void *)a2;
  *(void *)(a1 + 16) = *(void *)a2;
  *(_DWORD *)(a1 + 24) = v4;
  *(_DWORD *)(a1 + 28) = 4;
  *(_DWORD *)(a1 + 32) = v3;
  *(_DWORD *)(a1 + 36) = v5;
  *(void *)(a1 + 40) = 0;
  *(void *)a1 = &unk_26C5FBE18;
  size_t v7 = (HIDWORD(v6) * v6);
  AttributeDictionary = cva::createAttributeDictionary((cva *)v7, v4, 1111970369, 64, 64, 0, 0, 0, v11);
  CVPixelBufferRef pixelBufferOut = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v7, v4, 0x42475241u, AttributeDictionary, &pixelBufferOut);
  CFRelease(AttributeDictionary);
  CVPixelBufferRef v9 = pixelBufferOut;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = v9;
  return a1;
}

{
  int v3;
  size_t v4;
  unsigned int v5;
  uint64_t v6;
  size_t v7;
  __CFDictionary *AttributeDictionary;
  CVPixelBufferRef v9;
  BOOL v11;
  CVPixelBufferRef pixelBufferOut;

  int v3 = 4 * *a2;
  *(void *)(a1 + 8) = 0;
  size_t v4 = a2[2];
  unsigned int v5 = (a2[1] * v3 + 63) & 0xFFFFFFC0;
  uint64_t v6 = *(void *)a2;
  *(void *)(a1 + 16) = *(void *)a2;
  *(_DWORD *)(a1 + 24) = v4;
  *(_DWORD *)(a1 + 28) = 4;
  *(_DWORD *)(a1 + 32) = v3;
  *(_DWORD *)(a1 + 36) = v5;
  *(void *)(a1 + 40) = 0;
  *(void *)a1 = &unk_26C5FBE18;
  size_t v7 = (HIDWORD(v6) * v6);
  AttributeDictionary = cva::createAttributeDictionary((cva *)v7, v4, 1111970369, 64, 64, 0, 0, 0, v11);
  CVPixelBufferRef pixelBufferOut = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v7, v4, 0x42475241u, AttributeDictionary, &pixelBufferOut);
  CFRelease(AttributeDictionary);
  CVPixelBufferRef v9 = pixelBufferOut;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = v9;
  return a1;
}

_DWORD *cva::Buffer<unsigned int>::defaultStride@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X8>)
{
  int v2 = result[1];
  int v3 = 4 * *result;
  *a2 = 4;
  a2[1] = v3;
  a2[2] = (v2 * v3 + 63) & 0xFFFFFFC0;
  return result;
}

CVPixelBufferRef cva::Buffer<unsigned int>::allocate(_DWORD *a1)
{
  size_t v1 = (a1[1] * *a1);
  size_t v2 = a1[2];
  AttributeDictionary = cva::createAttributeDictionary((cva *)v1, v2, 1111970369, 64, 64, 0, 0, 0, v5);
  CVPixelBufferRef pixelBufferOut = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v1, v2, 0x42475241u, AttributeDictionary, &pixelBufferOut);
  CFRelease(AttributeDictionary);
  return pixelBufferOut;
}

uint64_t cva::Buffer<unsigned int>::Buffer(uint64_t a1, int a2, int a3, unsigned int a4)
{
  *(_DWORD *)(a1 + 16) = a2;
  *(_DWORD *)(a1 + 20) = a3;
  *(_DWORD *)(a1 + 24) = a4;
  *(_DWORD *)(a1 + 28) = 4;
  *(_DWORD *)(a1 + 32) = 4 * a2;
  *(_DWORD *)(a1 + 36) = (4 * a2 * a3 + 63) & 0xFFFFFFC0;
  *(void *)(a1 + 40) = 0;
  *(void *)a1 = &unk_26C5FBE18;
  *(void *)(a1 + 8) = 0;
  size_t v6 = (a3 * a2);
  AttributeDictionary = cva::createAttributeDictionary((cva *)v6, a4, 1111970369, 64, 64, 0, 0, 0, v10);
  CVPixelBufferRef pixelBufferOut = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v6, a4, 0x42475241u, AttributeDictionary, &pixelBufferOut);
  CFRelease(AttributeDictionary);
  CVPixelBufferRef v8 = pixelBufferOut;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = v8;
  return a1;
}

{
  size_t v6;
  __CFDictionary *AttributeDictionary;
  CVPixelBufferRef v8;
  BOOL v10;
  CVPixelBufferRef pixelBufferOut;

  *(_DWORD *)(a1 + 16) = a2;
  *(_DWORD *)(a1 + 20) = a3;
  *(_DWORD *)(a1 + 24) = a4;
  *(_DWORD *)(a1 + 28) = 4;
  *(_DWORD *)(a1 + 32) = 4 * a2;
  *(_DWORD *)(a1 + 36) = (4 * a2 * a3 + 63) & 0xFFFFFFC0;
  *(void *)(a1 + 40) = 0;
  *(void *)a1 = &unk_26C5FBE18;
  *(void *)(a1 + 8) = 0;
  size_t v6 = (a3 * a2);
  AttributeDictionary = cva::createAttributeDictionary((cva *)v6, a4, 1111970369, 64, 64, 0, 0, 0, v10);
  CVPixelBufferRef pixelBufferOut = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v6, a4, 0x42475241u, AttributeDictionary, &pixelBufferOut);
  CFRelease(AttributeDictionary);
  CVPixelBufferRef v8 = pixelBufferOut;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = v8;
  return a1;
}

double cva::Buffer<unsigned int>::Buffer(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  uint64_t v2 = *(void *)(a2 + 16);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  *(void *)(a1 + 16) = v2;
  uint64_t v3 = *(void *)(a2 + 28);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(a2 + 36);
  *(void *)(a1 + 28) = v3;
  *(void *)a1 = &unk_26C5FBE18;
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  *(void *)(a2 + 28) = 0;
  *(_DWORD *)(a2 + 36) = 0;
  double result = 0.0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  return result;
}

{
  uint64_t v2;
  uint64_t v3;
  double result;

  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  uint64_t v2 = *(void *)(a2 + 16);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  *(void *)(a1 + 16) = v2;
  uint64_t v3 = *(void *)(a2 + 28);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(a2 + 36);
  *(void *)(a1 + 28) = v3;
  *(void *)a1 = &unk_26C5FBE18;
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  *(void *)(a2 + 28) = 0;
  *(_DWORD *)(a2 + 36) = 0;
  double result = 0.0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  return result;
}

__n128 cva::Buffer<unsigned int>::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v9 = *(void *)(a1 + 16);
  int v10 = *(_DWORD *)(a1 + 24);
  uint64_t v7 = *(void *)(a1 + 28);
  int v8 = *(_DWORD *)(a1 + 36);
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  uint64_t v3 = *(void *)(a2 + 16);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  *(void *)(a1 + 16) = v3;
  LODWORD(v3) = *(_DWORD *)(a2 + 36);
  *(void *)(a1 + 28) = *(void *)(a2 + 28);
  *(_DWORD *)(a1 + 36) = v3;
  *(void *)(a2 + 8) = v2;
  *(void *)(a2 + 16) = v9;
  *(_DWORD *)(a2 + 24) = v10;
  *(void *)(a2 + 28) = v7;
  *(_DWORD *)(a2 + 36) = v8;
  uint64_t v4 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = v4;
  uint64_t v5 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = v5;
  __n128 result = *(__n128 *)(a1 + 56);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(__n128 *)(a2 + 56) = result;
  return result;
}

uint64_t cva::Buffer<unsigned int>::Buffer(uint64_t a1, uint64_t a2)
{
  v39[3] = *(CVPixelBufferRef *)MEMORY[0x263EF8340];
  int v4 = *(_DWORD *)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 16);
  int v6 = 4 * *(_DWORD *)(a2 + 16);
  unsigned int v7 = (*(_DWORD *)(a2 + 20) * v6 + 63) & 0xFFFFFFC0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 24) = v4;
  *(_DWORD *)(a1 + 28) = 4;
  *(_DWORD *)(a1 + 32) = v6;
  *(_DWORD *)(a1 + 36) = v7;
  *(void *)(a1 + 40) = 0;
  *(void *)a1 = &unk_26C5FBE18;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  size_t v8 = *(unsigned int *)(a1 + 24);
  size_t v9 = (*(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16));
  AttributeDictionary = cva::createAttributeDictionary((cva *)v9, v8, 1111970369, 64, 64, 0, 0, 0, (BOOL)v39[0]);
  v39[0] = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v9, v8, 0x42475241u, AttributeDictionary, v39);
  CFRelease(AttributeDictionary);
  *(CVPixelBufferRef *)(a1 + 48) = v39[0];
  BOOL v11 = *(__CVBuffer **)(a2 + 48);
  if (v11 && !CVPixelBufferLockBaseAddress(v11, 1uLL))
  {
    CVPixelBufferGetWidth(*(CVPixelBufferRef *)(a2 + 48));
    CVPixelBufferGetHeight(*(CVPixelBufferRef *)(a2 + 48));
    CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)(a2 + 48));
    *(void *)(a2 + 40) = CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(a2 + 48));
    int v12 = *(__CVBuffer **)(a1 + 48);
    if (v12 && !CVPixelBufferLockBaseAddress(v12, 0))
    {
      CVPixelBufferGetWidth(*(CVPixelBufferRef *)(a1 + 48));
      CVPixelBufferGetHeight(*(CVPixelBufferRef *)(a1 + 48));
      CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)(a1 + 48));
      BaseAddress = (char *)CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(a1 + 48));
      *(void *)(a1 + 40) = BaseAddress;
      uint64_t v14 = *(unsigned int *)(a1 + 36);
      uint64_t v15 = *(unsigned int *)(a2 + 36);
      if (*(_DWORD *)(a1 + 28) == *(_DWORD *)(a2 + 28)
        && *(_DWORD *)(a1 + 32) == *(_DWORD *)(a2 + 32)
        && v14 == v15)
      {
        memcpy(BaseAddress, *(const void **)(a2 + 40), (*(_DWORD *)(a2 + 24) * v14));
      }
      else
      {
        uint64_t v16 = *(void *)(a2 + 40);
        if (v16) {
          int v17 = (_DWORD *)(v16 + *(void *)(a2 + 8));
        }
        else {
          int v17 = 0;
        }
        if (v16) {
          int v18 = (_DWORD *)(v16 + *(void *)(a2 + 8) + (*(_DWORD *)(a2 + 24) * v15));
        }
        else {
          int v18 = 0;
        }
        if (v17 != v18)
        {
          int v19 = 0;
          int v20 = 0;
          int v21 = 0;
          int v22 = 0;
          int v23 = *(_DWORD *)(a2 + 16);
          int v24 = *(_DWORD *)(a2 + 20);
          int v26 = *(_DWORD *)(a1 + 16);
          int v25 = *(_DWORD *)(a1 + 20);
          unint64_t v27 = *(void *)(a1 + 28);
          unint64_t v28 = *(void *)(a2 + 28);
          if (BaseAddress) {
            char v29 = &BaseAddress[*(void *)(a1 + 8)];
          }
          else {
            char v29 = 0;
          }
          uint64_t v30 = *(void *)(a2 + 28);
          unint64_t v31 = HIDWORD(v28);
          uint64_t v32 = *(void *)(a1 + 28);
          unint64_t v33 = HIDWORD(v27);
          uint64_t v34 = -(uint64_t)(v23 * v28);
          uint64_t v35 = -(uint64_t)(v26 * v27);
          do
          {
            *(_DWORD *)char v29 = *v17;
            int v17 = (_DWORD *)((char *)v17 + v30);
            if (++v20 == v23)
            {
              int v20 = 0;
              int v17 = (_DWORD *)((char *)v17 + v34 + v31);
              int v36 = v19 + 1;
              if (v19 + 1 == v24) {
                int v19 = 0;
              }
              else {
                ++v19;
              }
              if (v36 == v24) {
                int v17 = (_DWORD *)((char *)v17 + v15 - (v36 * v31));
              }
            }
            v29 += v32;
            if (++v22 == v26)
            {
              int v22 = 0;
              v29 += v35 + v33;
              int v37 = v21 + 1;
              if (v21 + 1 == v25) {
                int v21 = 0;
              }
              else {
                ++v21;
              }
              if (v37 == v25) {
                char v29 = &v29[v14 - (v37 * v33)];
              }
            }
          }
          while (v17 != v18);
        }
      }
      if (!CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a1 + 48), 0)) {
        *(void *)(a1 + 40) = 0;
      }
    }
    if (!CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a2 + 48), 1uLL)) {
      *(void *)(a2 + 40) = 0;
    }
  }
  return a1;
}

{
  int v4;
  uint64_t v5;
  int v6;
  unsigned int v7;
  size_t v8;
  size_t v9;
  __CFDictionary *AttributeDictionary;
  __CVBuffer *v11;
  char *BaseAddress;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _DWORD *v16;
  _DWORD *v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  unint64_t v26;
  unint64_t v27;
  char *v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  int v36;
  CVPixelBufferRef pixelBuffer[4];

  pixelBuffer[3] = *(CVPixelBufferRef *)MEMORY[0x263EF8340];
  int v4 = *(_DWORD *)(a2 + 16);
  uint64_t v5 = *(void *)(a2 + 8);
  int v6 = 4 * *(_DWORD *)(a2 + 8);
  unsigned int v7 = (*(_DWORD *)(a2 + 12) * v6 + 63) & 0xFFFFFFC0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 24) = v4;
  *(_DWORD *)(a1 + 28) = 4;
  *(_DWORD *)(a1 + 32) = v6;
  *(_DWORD *)(a1 + 36) = v7;
  *(void *)(a1 + 40) = 0;
  *(void *)a1 = &unk_26C5FBE18;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  size_t v8 = *(unsigned int *)(a1 + 24);
  size_t v9 = (*(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16));
  AttributeDictionary = cva::createAttributeDictionary((cva *)v9, v8, 1111970369, 64, 64, 0, 0, 0, (BOOL)pixelBuffer[0]);
  pixelBuffer[0] = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v9, v8, 0x42475241u, AttributeDictionary, pixelBuffer);
  CFRelease(AttributeDictionary);
  BOOL v11 = pixelBuffer[0];
  *(CVPixelBufferRef *)(a1 + 48) = pixelBuffer[0];
  if (v11 && !CVPixelBufferLockBaseAddress(v11, 0))
  {
    CVPixelBufferGetWidth(*(CVPixelBufferRef *)(a1 + 48));
    CVPixelBufferGetHeight(*(CVPixelBufferRef *)(a1 + 48));
    CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)(a1 + 48));
    BaseAddress = (char *)CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(a1 + 48));
    *(void *)(a1 + 40) = BaseAddress;
    int v13 = *(unsigned int *)(a1 + 36);
    uint64_t v14 = *(unsigned int *)(a2 + 28);
    if (*(_DWORD *)(a1 + 28) == *(_DWORD *)(a2 + 20)
      && *(_DWORD *)(a1 + 32) == *(_DWORD *)(a2 + 24)
      && v13 == v14)
    {
      memcpy(BaseAddress, *(const void **)(a2 + 32), (*(_DWORD *)(a2 + 16) * v13));
    }
    else
    {
      uint64_t v15 = *(void *)(a2 + 32);
      if (v15) {
        uint64_t v16 = (_DWORD *)(v15 + *(void *)a2);
      }
      else {
        uint64_t v16 = 0;
      }
      if (v15) {
        int v17 = (_DWORD *)(v15 + *(void *)a2 + (*(_DWORD *)(a2 + 16) * v14));
      }
      else {
        int v17 = 0;
      }
      if (v16 != v17)
      {
        int v18 = 0;
        int v19 = 0;
        int v20 = 0;
        int v21 = 0;
        int v22 = *(_DWORD *)(a2 + 8);
        int v23 = *(_DWORD *)(a2 + 12);
        int v25 = *(_DWORD *)(a1 + 16);
        int v24 = *(_DWORD *)(a1 + 20);
        int v26 = *(void *)(a1 + 28);
        unint64_t v27 = *(void *)(a2 + 20);
        if (BaseAddress) {
          unint64_t v28 = &BaseAddress[*(void *)(a1 + 8)];
        }
        else {
          unint64_t v28 = 0;
        }
        char v29 = *(void *)(a2 + 20);
        uint64_t v30 = HIDWORD(v27);
        unint64_t v31 = *(void *)(a1 + 28);
        uint64_t v32 = HIDWORD(v26);
        unint64_t v33 = -(uint64_t)(v22 * v27);
        uint64_t v34 = -(uint64_t)(v25 * v26);
        do
        {
          *(_DWORD *)unint64_t v28 = *v16;
          uint64_t v16 = (_DWORD *)((char *)v16 + v29);
          if (++v19 == v22)
          {
            int v19 = 0;
            uint64_t v16 = (_DWORD *)((char *)v16 + v33 + v30);
            uint64_t v35 = v18 + 1;
            if (v18 + 1 == v23) {
              int v18 = 0;
            }
            else {
              ++v18;
            }
            if (v35 == v23) {
              uint64_t v16 = (_DWORD *)((char *)v16 + v14 - (v35 * v30));
            }
          }
          v28 += v31;
          if (++v21 == v25)
          {
            int v21 = 0;
            v28 += v34 + v32;
            int v36 = v20 + 1;
            if (v20 + 1 == v24) {
              int v20 = 0;
            }
            else {
              ++v20;
            }
            if (v36 == v24) {
              unint64_t v28 = &v28[v13 - (v36 * v32)];
            }
          }
        }
        while (v16 != v17);
      }
    }
    if (!CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a1 + 48), 0)) {
      *(void *)(a1 + 40) = 0;
    }
  }
  return a1;
}

__CVBuffer *cva::Buffer<unsigned int>::lock(uint64_t a1, CVPixelBufferLockFlags a2)
{
  __n128 result = *(__CVBuffer **)(a1 + 48);
  if (result)
  {
    if (CVPixelBufferLockBaseAddress(result, a2))
    {
      return 0;
    }
    else
    {
      CVPixelBufferGetWidth(*(CVPixelBufferRef *)(a1 + 48));
      CVPixelBufferGetHeight(*(CVPixelBufferRef *)(a1 + 48));
      CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)(a1 + 48));
      *(void *)(a1 + 40) = CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(a1 + 48));
      return (__CVBuffer *)1;
    }
  }
  return result;
}

BOOL cva::Buffer<unsigned int>::unlock(uint64_t a1, CVPixelBufferLockFlags a2)
{
  CVReturn v3 = CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a1 + 48), a2);
  if (!v3) {
    *(void *)(a1 + 40) = 0;
  }
  return v3 == 0;
}

uint64_t cva::Buffer<unsigned int>::operator=(uint64_t a1, uint64_t a2)
{
  CVReturn v3 = *(__CVBuffer **)(a2 + 48);
  if (v3 && !CVPixelBufferLockBaseAddress(v3, 1uLL))
  {
    CVPixelBufferGetWidth(*(CVPixelBufferRef *)(a2 + 48));
    CVPixelBufferGetHeight(*(CVPixelBufferRef *)(a2 + 48));
    CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)(a2 + 48));
    *(void *)(a2 + 40) = CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(a2 + 48));
    uint64_t v5 = *(__CVBuffer **)(a1 + 48);
    if (v5 && !CVPixelBufferLockBaseAddress(v5, 0))
    {
      CVPixelBufferGetWidth(*(CVPixelBufferRef *)(a1 + 48));
      CVPixelBufferGetHeight(*(CVPixelBufferRef *)(a1 + 48));
      CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)(a1 + 48));
      BaseAddress = (char *)CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(a1 + 48));
      *(void *)(a1 + 40) = BaseAddress;
      uint64_t v7 = *(void *)(a2 + 40);
      uint64_t v8 = *(unsigned int *)(a2 + 36);
      if (v7) {
        size_t v9 = (_DWORD *)(v7 + *(void *)(a2 + 8));
      }
      else {
        size_t v9 = 0;
      }
      if (v7) {
        int v10 = (_DWORD *)(v7 + *(void *)(a2 + 8) + (*(_DWORD *)(a2 + 24) * v8));
      }
      else {
        int v10 = 0;
      }
      if (v9 != v10)
      {
        int v11 = 0;
        int v12 = 0;
        int v13 = 0;
        int v14 = 0;
        unint64_t v15 = *(void *)(a1 + 28);
        unint64_t v16 = *(void *)(a2 + 28);
        int v17 = *(_DWORD *)(a1 + 16);
        int v18 = *(_DWORD *)(a1 + 20);
        int v20 = *(_DWORD *)(a2 + 16);
        int v19 = *(_DWORD *)(a2 + 20);
        unint64_t v21 = HIDWORD(v16);
        unint64_t v22 = HIDWORD(v15);
        uint64_t v23 = *(unsigned int *)(a1 + 36);
        if (BaseAddress) {
          int v24 = &BaseAddress[*(void *)(a1 + 8)];
        }
        else {
          int v24 = 0;
        }
        uint64_t v25 = *(void *)(a2 + 28);
        uint64_t v26 = *(void *)(a1 + 28);
        uint64_t v27 = -(uint64_t)(v20 * v16);
        uint64_t v28 = -(uint64_t)(v17 * v15);
        do
        {
          *(_DWORD *)int v24 = *v9;
          size_t v9 = (_DWORD *)((char *)v9 + v25);
          if (++v13 == v20)
          {
            int v13 = 0;
            size_t v9 = (_DWORD *)((char *)v9 + v27 + v21);
            int v29 = v14 + 1;
            if (v14 + 1 == v19) {
              int v14 = 0;
            }
            else {
              ++v14;
            }
            if (v29 == v19) {
              size_t v9 = (_DWORD *)((char *)v9 + v8 - (v29 * v21));
            }
          }
          v24 += v26;
          if (++v11 == v17)
          {
            int v11 = 0;
            v24 += v28 + v22;
            int v30 = v12 + 1;
            if (v12 + 1 == v18) {
              int v12 = 0;
            }
            else {
              ++v12;
            }
            if (v30 == v18) {
              int v24 = &v24[v23 - (v30 * v22)];
            }
          }
        }
        while (v9 != v10);
      }
      if (!CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a1 + 48), 0)) {
        *(void *)(a1 + 40) = 0;
      }
    }
    if (!CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a2 + 48), 1uLL)) {
      *(void *)(a2 + 40) = 0;
    }
  }
  return a1;
}

{
  __CVBuffer *v3;
  char *BaseAddress;
  uint64_t v6;
  uint64_t v7;
  _DWORD *v8;
  _DWORD *v9;
  int v10;
  int v11;
  int v12;
  int v13;
  unint64_t v14;
  unint64_t v15;
  int v16;
  int v17;
  int v18;
  int v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;

  CVReturn v3 = *(__CVBuffer **)(a1 + 48);
  if (v3 && !CVPixelBufferLockBaseAddress(v3, 0))
  {
    CVPixelBufferGetWidth(*(CVPixelBufferRef *)(a1 + 48));
    CVPixelBufferGetHeight(*(CVPixelBufferRef *)(a1 + 48));
    CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)(a1 + 48));
    BaseAddress = (char *)CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(a1 + 48));
    *(void *)(a1 + 40) = BaseAddress;
    int v6 = *(void *)(a2 + 32);
    uint64_t v7 = *(unsigned int *)(a2 + 28);
    if (v6) {
      uint64_t v8 = (_DWORD *)(v6 + *(void *)a2);
    }
    else {
      uint64_t v8 = 0;
    }
    if (v6) {
      size_t v9 = (_DWORD *)(v6 + *(void *)a2 + (*(_DWORD *)(a2 + 16) * v7));
    }
    else {
      size_t v9 = 0;
    }
    if (v8 != v9)
    {
      int v10 = 0;
      int v11 = 0;
      int v12 = 0;
      int v13 = 0;
      int v14 = *(void *)(a1 + 28);
      unint64_t v15 = *(void *)(a2 + 20);
      unint64_t v16 = *(_DWORD *)(a1 + 16);
      int v17 = *(_DWORD *)(a1 + 20);
      int v19 = *(_DWORD *)(a2 + 8);
      int v18 = *(_DWORD *)(a2 + 12);
      int v20 = HIDWORD(v15);
      unint64_t v21 = HIDWORD(v14);
      unint64_t v22 = *(unsigned int *)(a1 + 36);
      if (BaseAddress) {
        uint64_t v23 = &BaseAddress[*(void *)(a1 + 8)];
      }
      else {
        uint64_t v23 = 0;
      }
      int v24 = v15;
      uint64_t v25 = *(void *)(a1 + 28);
      uint64_t v26 = -(uint64_t)(v19 * v15);
      uint64_t v27 = -(uint64_t)(v16 * v14);
      do
      {
        *(_DWORD *)uint64_t v23 = *v8;
        uint64_t v8 = (_DWORD *)((char *)v8 + v24);
        if (++v12 == v19)
        {
          int v12 = 0;
          uint64_t v8 = (_DWORD *)((char *)v8 + v26 + v20);
          uint64_t v28 = v13 + 1;
          if (v13 + 1 == v18) {
            int v13 = 0;
          }
          else {
            ++v13;
          }
          if (v28 == v18) {
            uint64_t v8 = (_DWORD *)((char *)v8 + v7 - (v28 * v20));
          }
        }
        v23 += v25;
        if (++v10 == v16)
        {
          int v10 = 0;
          v23 += v27 + v21;
          int v29 = v11 + 1;
          if (v11 + 1 == v17) {
            int v11 = 0;
          }
          else {
            ++v11;
          }
          if (v29 == v17) {
            uint64_t v23 = &v23[v22 - (v29 * v21)];
          }
        }
      }
      while (v8 != v9);
    }
    if (!CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a1 + 48), 0)) {
      *(void *)(a1 + 40) = 0;
    }
  }
  return a1;
}

uint64_t cva::Buffer<unsigned int>::resize(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[7];
  if (v4)
  {

    MEMORY[0x2166B9890](v4, 0xE0C400670D255);
  }
  a1[7] = 0;
  uint64_t v5 = a1[8];
  if (v5)
  {

    MEMORY[0x2166B9890](v5, 0xE0C400670D255);
  }
  a1[8] = 0;
  int v6 = *(uint64_t (**)(void *, uint64_t))(*a1 + 16);
  return v6(a1, a2);
}

uint64_t cva::Buffer<unsigned int>::resize(void *a1, int a2, int a3, int a4)
{
  v8[0] = a2;
  v8[1] = a3;
  v8[2] = a4;
  uint64_t v5 = a1[7];
  if (v5)
  {

    MEMORY[0x2166B9890](v5, 0xE0C400670D255);
  }
  a1[7] = 0;
  uint64_t v6 = a1[8];
  if (v6)
  {

    MEMORY[0x2166B9890](v6, 0xE0C400670D255);
  }
  a1[8] = 0;
  return (*(uint64_t (**)(void *, _DWORD *))(*a1 + 16))(a1, v8);
}

uint64_t cva::Buffer<unsigned int>::operator __CVBuffer *(uint64_t a1)
{
  return *(void *)(a1 + 48);
}

CVPixelBufferRef cva::Buffer<unsigned int>::allocate(_DWORD *a1, OSType a2)
{
  size_t v3 = (a1[1] * *a1);
  size_t v4 = a1[2];
  AttributeDictionary = cva::createAttributeDictionary((cva *)v3, v4, a2, 64, 64, 0, 0, 0, v7);
  CVPixelBufferRef pixelBufferOut = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v3, v4, a2, AttributeDictionary, &pixelBufferOut);
  CFRelease(AttributeDictionary);
  return pixelBufferOut;
}

double cva::Buffer<cva::half>::Buffer(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)a1 = &unk_26C5FBD88;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  return result;
}

{
  double result;

  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)a1 = &unk_26C5FBD88;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  return result;
}

uint64_t cva::Buffer<cva::half>::Buffer(uint64_t a1, _DWORD *a2)
{
  int v3 = 2 * *a2;
  *(void *)(a1 + 8) = 0;
  size_t v4 = a2[2];
  unsigned int v5 = (a2[1] * v3 + 63) & 0xFFFFFFC0;
  uint64_t v6 = *(void *)a2;
  *(void *)(a1 + 16) = *(void *)a2;
  *(_DWORD *)(a1 + 24) = v4;
  *(_DWORD *)(a1 + 28) = 2;
  *(_DWORD *)(a1 + 32) = v3;
  *(_DWORD *)(a1 + 36) = v5;
  *(void *)(a1 + 40) = 0;
  *(void *)a1 = &unk_26C5FBD88;
  size_t v7 = (HIDWORD(v6) * v6);
  AttributeDictionary = cva::createAttributeDictionary((cva *)v7, v4, 1278226536, 64, 64, 0, 0, 0, v11);
  CVPixelBufferRef pixelBufferOut = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v7, v4, 0x4C303068u, AttributeDictionary, &pixelBufferOut);
  CFRelease(AttributeDictionary);
  CVPixelBufferRef v9 = pixelBufferOut;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = v9;
  return a1;
}

{
  int v3;
  size_t v4;
  unsigned int v5;
  uint64_t v6;
  size_t v7;
  __CFDictionary *AttributeDictionary;
  CVPixelBufferRef v9;
  BOOL v11;
  CVPixelBufferRef pixelBufferOut;

  int v3 = 2 * *a2;
  *(void *)(a1 + 8) = 0;
  size_t v4 = a2[2];
  unsigned int v5 = (a2[1] * v3 + 63) & 0xFFFFFFC0;
  uint64_t v6 = *(void *)a2;
  *(void *)(a1 + 16) = *(void *)a2;
  *(_DWORD *)(a1 + 24) = v4;
  *(_DWORD *)(a1 + 28) = 2;
  *(_DWORD *)(a1 + 32) = v3;
  *(_DWORD *)(a1 + 36) = v5;
  *(void *)(a1 + 40) = 0;
  *(void *)a1 = &unk_26C5FBD88;
  size_t v7 = (HIDWORD(v6) * v6);
  AttributeDictionary = cva::createAttributeDictionary((cva *)v7, v4, 1278226536, 64, 64, 0, 0, 0, v11);
  CVPixelBufferRef pixelBufferOut = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v7, v4, 0x4C303068u, AttributeDictionary, &pixelBufferOut);
  CFRelease(AttributeDictionary);
  CVPixelBufferRef v9 = pixelBufferOut;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = v9;
  return a1;
}

_DWORD *cva::Buffer<cva::half>::defaultStride@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X8>)
{
  int v2 = result[1];
  int v3 = 2 * *result;
  *a2 = 2;
  a2[1] = v3;
  a2[2] = (v2 * v3 + 63) & 0xFFFFFFC0;
  return result;
}

CVPixelBufferRef cva::Buffer<cva::half>::allocate(_DWORD *a1)
{
  size_t v1 = (a1[1] * *a1);
  size_t v2 = a1[2];
  AttributeDictionary = cva::createAttributeDictionary((cva *)v1, v2, 1278226536, 64, 64, 0, 0, 0, v5);
  CVPixelBufferRef pixelBufferOut = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v1, v2, 0x4C303068u, AttributeDictionary, &pixelBufferOut);
  CFRelease(AttributeDictionary);
  return pixelBufferOut;
}

uint64_t cva::Buffer<cva::half>::Buffer(uint64_t a1, int a2, int a3, unsigned int a4)
{
  *(_DWORD *)(a1 + 16) = a2;
  *(_DWORD *)(a1 + 20) = a3;
  *(_DWORD *)(a1 + 24) = a4;
  *(_DWORD *)(a1 + 28) = 2;
  *(_DWORD *)(a1 + 32) = 2 * a2;
  *(_DWORD *)(a1 + 36) = (2 * a2 * a3 + 63) & 0xFFFFFFC0;
  *(void *)(a1 + 40) = 0;
  *(void *)a1 = &unk_26C5FBD88;
  *(void *)(a1 + 8) = 0;
  size_t v6 = (a3 * a2);
  AttributeDictionary = cva::createAttributeDictionary((cva *)v6, a4, 1278226536, 64, 64, 0, 0, 0, v10);
  CVPixelBufferRef pixelBufferOut = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v6, a4, 0x4C303068u, AttributeDictionary, &pixelBufferOut);
  CFRelease(AttributeDictionary);
  CVPixelBufferRef v8 = pixelBufferOut;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = v8;
  return a1;
}

{
  size_t v6;
  __CFDictionary *AttributeDictionary;
  CVPixelBufferRef v8;
  BOOL v10;
  CVPixelBufferRef pixelBufferOut;

  *(_DWORD *)(a1 + 16) = a2;
  *(_DWORD *)(a1 + 20) = a3;
  *(_DWORD *)(a1 + 24) = a4;
  *(_DWORD *)(a1 + 28) = 2;
  *(_DWORD *)(a1 + 32) = 2 * a2;
  *(_DWORD *)(a1 + 36) = (2 * a2 * a3 + 63) & 0xFFFFFFC0;
  *(void *)(a1 + 40) = 0;
  *(void *)a1 = &unk_26C5FBD88;
  *(void *)(a1 + 8) = 0;
  size_t v6 = (a3 * a2);
  AttributeDictionary = cva::createAttributeDictionary((cva *)v6, a4, 1278226536, 64, 64, 0, 0, 0, v10);
  CVPixelBufferRef pixelBufferOut = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v6, a4, 0x4C303068u, AttributeDictionary, &pixelBufferOut);
  CFRelease(AttributeDictionary);
  CVPixelBufferRef v8 = pixelBufferOut;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = v8;
  return a1;
}

double cva::Buffer<cva::half>::Buffer(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  uint64_t v2 = *(void *)(a2 + 16);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  *(void *)(a1 + 16) = v2;
  uint64_t v3 = *(void *)(a2 + 28);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(a2 + 36);
  *(void *)(a1 + 28) = v3;
  *(void *)a1 = &unk_26C5FBD88;
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  *(void *)(a2 + 28) = 0;
  *(_DWORD *)(a2 + 36) = 0;
  double result = 0.0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  return result;
}

{
  uint64_t v2;
  uint64_t v3;
  double result;

  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  uint64_t v2 = *(void *)(a2 + 16);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  *(void *)(a1 + 16) = v2;
  uint64_t v3 = *(void *)(a2 + 28);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(a2 + 36);
  *(void *)(a1 + 28) = v3;
  *(void *)a1 = &unk_26C5FBD88;
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  *(void *)(a2 + 28) = 0;
  *(_DWORD *)(a2 + 36) = 0;
  double result = 0.0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  return result;
}

__n128 cva::Buffer<cva::half>::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v9 = *(void *)(a1 + 16);
  int v10 = *(_DWORD *)(a1 + 24);
  uint64_t v7 = *(void *)(a1 + 28);
  int v8 = *(_DWORD *)(a1 + 36);
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  uint64_t v3 = *(void *)(a2 + 16);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  *(void *)(a1 + 16) = v3;
  LODWORD(v3) = *(_DWORD *)(a2 + 36);
  *(void *)(a1 + 28) = *(void *)(a2 + 28);
  *(_DWORD *)(a1 + 36) = v3;
  *(void *)(a2 + 8) = v2;
  *(void *)(a2 + 16) = v9;
  *(_DWORD *)(a2 + 24) = v10;
  *(void *)(a2 + 28) = v7;
  *(_DWORD *)(a2 + 36) = v8;
  uint64_t v4 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = v4;
  uint64_t v5 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = v5;
  __n128 result = *(__n128 *)(a1 + 56);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(__n128 *)(a2 + 56) = result;
  return result;
}

uint64_t cva::Buffer<cva::half>::Buffer(uint64_t a1, uint64_t a2)
{
  v39[3] = *(CVPixelBufferRef *)MEMORY[0x263EF8340];
  int v4 = *(_DWORD *)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 16);
  int v6 = 2 * *(_DWORD *)(a2 + 16);
  unsigned int v7 = (*(_DWORD *)(a2 + 20) * v6 + 63) & 0xFFFFFFC0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 24) = v4;
  *(_DWORD *)(a1 + 28) = 2;
  *(_DWORD *)(a1 + 32) = v6;
  *(_DWORD *)(a1 + 36) = v7;
  *(void *)(a1 + 40) = 0;
  *(void *)a1 = &unk_26C5FBD88;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  size_t v8 = *(unsigned int *)(a1 + 24);
  size_t v9 = (*(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16));
  AttributeDictionary = cva::createAttributeDictionary((cva *)v9, v8, 1278226536, 64, 64, 0, 0, 0, (BOOL)v39[0]);
  v39[0] = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v9, v8, 0x4C303068u, AttributeDictionary, v39);
  CFRelease(AttributeDictionary);
  *(CVPixelBufferRef *)(a1 + 48) = v39[0];
  BOOL v11 = *(__CVBuffer **)(a2 + 48);
  if (v11 && !CVPixelBufferLockBaseAddress(v11, 1uLL))
  {
    CVPixelBufferGetWidth(*(CVPixelBufferRef *)(a2 + 48));
    CVPixelBufferGetHeight(*(CVPixelBufferRef *)(a2 + 48));
    CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)(a2 + 48));
    *(void *)(a2 + 40) = CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(a2 + 48));
    int v12 = *(__CVBuffer **)(a1 + 48);
    if (v12 && !CVPixelBufferLockBaseAddress(v12, 0))
    {
      CVPixelBufferGetWidth(*(CVPixelBufferRef *)(a1 + 48));
      CVPixelBufferGetHeight(*(CVPixelBufferRef *)(a1 + 48));
      CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)(a1 + 48));
      BaseAddress = (char *)CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(a1 + 48));
      *(void *)(a1 + 40) = BaseAddress;
      uint64_t v14 = *(unsigned int *)(a1 + 36);
      uint64_t v15 = *(unsigned int *)(a2 + 36);
      if (*(_DWORD *)(a1 + 28) == *(_DWORD *)(a2 + 28)
        && *(_DWORD *)(a1 + 32) == *(_DWORD *)(a2 + 32)
        && v14 == v15)
      {
        memcpy(BaseAddress, *(const void **)(a2 + 40), (*(_DWORD *)(a2 + 24) * v14));
      }
      else
      {
        uint64_t v16 = *(void *)(a2 + 40);
        if (v16) {
          int v17 = (_WORD *)(v16 + *(void *)(a2 + 8));
        }
        else {
          int v17 = 0;
        }
        if (v16) {
          int v18 = (_WORD *)(v16 + *(void *)(a2 + 8) + (*(_DWORD *)(a2 + 24) * v15));
        }
        else {
          int v18 = 0;
        }
        if (v17 != v18)
        {
          int v19 = 0;
          int v20 = 0;
          int v21 = 0;
          int v22 = 0;
          int v23 = *(_DWORD *)(a2 + 16);
          int v24 = *(_DWORD *)(a2 + 20);
          int v26 = *(_DWORD *)(a1 + 16);
          int v25 = *(_DWORD *)(a1 + 20);
          unint64_t v27 = *(void *)(a1 + 28);
          unint64_t v28 = *(void *)(a2 + 28);
          if (BaseAddress) {
            int v29 = &BaseAddress[*(void *)(a1 + 8)];
          }
          else {
            int v29 = 0;
          }
          uint64_t v30 = *(void *)(a2 + 28);
          unint64_t v31 = HIDWORD(v28);
          uint64_t v32 = *(void *)(a1 + 28);
          unint64_t v33 = HIDWORD(v27);
          uint64_t v34 = -(uint64_t)(v23 * v28);
          uint64_t v35 = -(uint64_t)(v26 * v27);
          do
          {
            *(_WORD *)int v29 = *v17;
            int v17 = (_WORD *)((char *)v17 + v30);
            if (++v20 == v23)
            {
              int v20 = 0;
              int v17 = (_WORD *)((char *)v17 + v34 + v31);
              int v36 = v19 + 1;
              if (v19 + 1 == v24) {
                int v19 = 0;
              }
              else {
                ++v19;
              }
              if (v36 == v24) {
                int v17 = (_WORD *)((char *)v17 + v15 - (v36 * v31));
              }
            }
            v29 += v32;
            if (++v22 == v26)
            {
              int v22 = 0;
              v29 += v35 + v33;
              int v37 = v21 + 1;
              if (v21 + 1 == v25) {
                int v21 = 0;
              }
              else {
                ++v21;
              }
              if (v37 == v25) {
                int v29 = &v29[v14 - (v37 * v33)];
              }
            }
          }
          while (v17 != v18);
        }
      }
      if (!CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a1 + 48), 0)) {
        *(void *)(a1 + 40) = 0;
      }
    }
    if (!CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a2 + 48), 1uLL)) {
      *(void *)(a2 + 40) = 0;
    }
  }
  return a1;
}

{
  int v4;
  uint64_t v5;
  int v6;
  unsigned int v7;
  size_t v8;
  size_t v9;
  __CFDictionary *AttributeDictionary;
  __CVBuffer *v11;
  char *BaseAddress;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _WORD *v16;
  _WORD *v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  unint64_t v26;
  unint64_t v27;
  char *v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  int v36;
  CVPixelBufferRef pixelBuffer[4];

  pixelBuffer[3] = *(CVPixelBufferRef *)MEMORY[0x263EF8340];
  int v4 = *(_DWORD *)(a2 + 16);
  uint64_t v5 = *(void *)(a2 + 8);
  int v6 = 2 * *(_DWORD *)(a2 + 8);
  unsigned int v7 = (*(_DWORD *)(a2 + 12) * v6 + 63) & 0xFFFFFFC0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 24) = v4;
  *(_DWORD *)(a1 + 28) = 2;
  *(_DWORD *)(a1 + 32) = v6;
  *(_DWORD *)(a1 + 36) = v7;
  *(void *)(a1 + 40) = 0;
  *(void *)a1 = &unk_26C5FBD88;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  size_t v8 = *(unsigned int *)(a1 + 24);
  size_t v9 = (*(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16));
  AttributeDictionary = cva::createAttributeDictionary((cva *)v9, v8, 1278226536, 64, 64, 0, 0, 0, (BOOL)pixelBuffer[0]);
  pixelBuffer[0] = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v9, v8, 0x4C303068u, AttributeDictionary, pixelBuffer);
  CFRelease(AttributeDictionary);
  BOOL v11 = pixelBuffer[0];
  *(CVPixelBufferRef *)(a1 + 48) = pixelBuffer[0];
  if (v11 && !CVPixelBufferLockBaseAddress(v11, 0))
  {
    CVPixelBufferGetWidth(*(CVPixelBufferRef *)(a1 + 48));
    CVPixelBufferGetHeight(*(CVPixelBufferRef *)(a1 + 48));
    CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)(a1 + 48));
    BaseAddress = (char *)CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(a1 + 48));
    *(void *)(a1 + 40) = BaseAddress;
    int v13 = *(unsigned int *)(a1 + 36);
    uint64_t v14 = *(unsigned int *)(a2 + 28);
    if (*(_DWORD *)(a1 + 28) == *(_DWORD *)(a2 + 20)
      && *(_DWORD *)(a1 + 32) == *(_DWORD *)(a2 + 24)
      && v13 == v14)
    {
      memcpy(BaseAddress, *(const void **)(a2 + 32), (*(_DWORD *)(a2 + 16) * v13));
    }
    else
    {
      uint64_t v15 = *(void *)(a2 + 32);
      if (v15) {
        uint64_t v16 = (_WORD *)(v15 + *(void *)a2);
      }
      else {
        uint64_t v16 = 0;
      }
      if (v15) {
        int v17 = (_WORD *)(v15 + *(void *)a2 + (*(_DWORD *)(a2 + 16) * v14));
      }
      else {
        int v17 = 0;
      }
      if (v16 != v17)
      {
        int v18 = 0;
        int v19 = 0;
        int v20 = 0;
        int v21 = 0;
        int v22 = *(_DWORD *)(a2 + 8);
        int v23 = *(_DWORD *)(a2 + 12);
        int v25 = *(_DWORD *)(a1 + 16);
        int v24 = *(_DWORD *)(a1 + 20);
        int v26 = *(void *)(a1 + 28);
        unint64_t v27 = *(void *)(a2 + 20);
        if (BaseAddress) {
          unint64_t v28 = &BaseAddress[*(void *)(a1 + 8)];
        }
        else {
          unint64_t v28 = 0;
        }
        int v29 = *(void *)(a2 + 20);
        uint64_t v30 = HIDWORD(v27);
        unint64_t v31 = *(void *)(a1 + 28);
        uint64_t v32 = HIDWORD(v26);
        unint64_t v33 = -(uint64_t)(v22 * v27);
        uint64_t v34 = -(uint64_t)(v25 * v26);
        do
        {
          *(_WORD *)unint64_t v28 = *v16;
          uint64_t v16 = (_WORD *)((char *)v16 + v29);
          if (++v19 == v22)
          {
            int v19 = 0;
            uint64_t v16 = (_WORD *)((char *)v16 + v33 + v30);
            uint64_t v35 = v18 + 1;
            if (v18 + 1 == v23) {
              int v18 = 0;
            }
            else {
              ++v18;
            }
            if (v35 == v23) {
              uint64_t v16 = (_WORD *)((char *)v16 + v14 - (v35 * v30));
            }
          }
          v28 += v31;
          if (++v21 == v25)
          {
            int v21 = 0;
            v28 += v34 + v32;
            int v36 = v20 + 1;
            if (v20 + 1 == v24) {
              int v20 = 0;
            }
            else {
              ++v20;
            }
            if (v36 == v24) {
              unint64_t v28 = &v28[v13 - (v36 * v32)];
            }
          }
        }
        while (v16 != v17);
      }
    }
    if (!CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a1 + 48), 0)) {
      *(void *)(a1 + 40) = 0;
    }
  }
  return a1;
}

__CVBuffer *cva::Buffer<cva::half>::lock(uint64_t a1, CVPixelBufferLockFlags a2)
{
  __n128 result = *(__CVBuffer **)(a1 + 48);
  if (result)
  {
    if (CVPixelBufferLockBaseAddress(result, a2))
    {
      return 0;
    }
    else
    {
      CVPixelBufferGetWidth(*(CVPixelBufferRef *)(a1 + 48));
      CVPixelBufferGetHeight(*(CVPixelBufferRef *)(a1 + 48));
      CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)(a1 + 48));
      *(void *)(a1 + 40) = CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(a1 + 48));
      return (__CVBuffer *)1;
    }
  }
  return result;
}

BOOL cva::Buffer<cva::half>::unlock(uint64_t a1, CVPixelBufferLockFlags a2)
{
  CVReturn v3 = CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a1 + 48), a2);
  if (!v3) {
    *(void *)(a1 + 40) = 0;
  }
  return v3 == 0;
}

uint64_t cva::Buffer<cva::half>::operator=(uint64_t a1, uint64_t a2)
{
  CVReturn v3 = *(__CVBuffer **)(a2 + 48);
  if (v3 && !CVPixelBufferLockBaseAddress(v3, 1uLL))
  {
    CVPixelBufferGetWidth(*(CVPixelBufferRef *)(a2 + 48));
    CVPixelBufferGetHeight(*(CVPixelBufferRef *)(a2 + 48));
    CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)(a2 + 48));
    *(void *)(a2 + 40) = CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(a2 + 48));
    uint64_t v5 = *(__CVBuffer **)(a1 + 48);
    if (v5 && !CVPixelBufferLockBaseAddress(v5, 0))
    {
      CVPixelBufferGetWidth(*(CVPixelBufferRef *)(a1 + 48));
      CVPixelBufferGetHeight(*(CVPixelBufferRef *)(a1 + 48));
      CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)(a1 + 48));
      BaseAddress = (char *)CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(a1 + 48));
      *(void *)(a1 + 40) = BaseAddress;
      uint64_t v7 = *(void *)(a2 + 40);
      uint64_t v8 = *(unsigned int *)(a2 + 36);
      if (v7) {
        size_t v9 = (_WORD *)(v7 + *(void *)(a2 + 8));
      }
      else {
        size_t v9 = 0;
      }
      if (v7) {
        int v10 = (_WORD *)(v7 + *(void *)(a2 + 8) + (*(_DWORD *)(a2 + 24) * v8));
      }
      else {
        int v10 = 0;
      }
      if (v9 != v10)
      {
        int v11 = 0;
        int v12 = 0;
        int v13 = 0;
        int v14 = 0;
        unint64_t v15 = *(void *)(a1 + 28);
        unint64_t v16 = *(void *)(a2 + 28);
        int v17 = *(_DWORD *)(a1 + 16);
        int v18 = *(_DWORD *)(a1 + 20);
        int v20 = *(_DWORD *)(a2 + 16);
        int v19 = *(_DWORD *)(a2 + 20);
        unint64_t v21 = HIDWORD(v16);
        unint64_t v22 = HIDWORD(v15);
        uint64_t v23 = *(unsigned int *)(a1 + 36);
        if (BaseAddress) {
          int v24 = &BaseAddress[*(void *)(a1 + 8)];
        }
        else {
          int v24 = 0;
        }
        uint64_t v25 = *(void *)(a2 + 28);
        uint64_t v26 = *(void *)(a1 + 28);
        uint64_t v27 = -(uint64_t)(v20 * v16);
        uint64_t v28 = -(uint64_t)(v17 * v15);
        do
        {
          *(_WORD *)int v24 = *v9;
          size_t v9 = (_WORD *)((char *)v9 + v25);
          if (++v13 == v20)
          {
            int v13 = 0;
            size_t v9 = (_WORD *)((char *)v9 + v27 + v21);
            int v29 = v14 + 1;
            if (v14 + 1 == v19) {
              int v14 = 0;
            }
            else {
              ++v14;
            }
            if (v29 == v19) {
              size_t v9 = (_WORD *)((char *)v9 + v8 - (v29 * v21));
            }
          }
          v24 += v26;
          if (++v11 == v17)
          {
            int v11 = 0;
            v24 += v28 + v22;
            int v30 = v12 + 1;
            if (v12 + 1 == v18) {
              int v12 = 0;
            }
            else {
              ++v12;
            }
            if (v30 == v18) {
              int v24 = &v24[v23 - (v30 * v22)];
            }
          }
        }
        while (v9 != v10);
      }
      if (!CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a1 + 48), 0)) {
        *(void *)(a1 + 40) = 0;
      }
    }
    if (!CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a2 + 48), 1uLL)) {
      *(void *)(a2 + 40) = 0;
    }
  }
  return a1;
}

{
  __CVBuffer *v3;
  char *BaseAddress;
  uint64_t v6;
  uint64_t v7;
  _WORD *v8;
  _WORD *v9;
  int v10;
  int v11;
  int v12;
  int v13;
  unint64_t v14;
  unint64_t v15;
  int v16;
  int v17;
  int v18;
  int v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;

  CVReturn v3 = *(__CVBuffer **)(a1 + 48);
  if (v3 && !CVPixelBufferLockBaseAddress(v3, 0))
  {
    CVPixelBufferGetWidth(*(CVPixelBufferRef *)(a1 + 48));
    CVPixelBufferGetHeight(*(CVPixelBufferRef *)(a1 + 48));
    CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)(a1 + 48));
    BaseAddress = (char *)CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(a1 + 48));
    *(void *)(a1 + 40) = BaseAddress;
    int v6 = *(void *)(a2 + 32);
    uint64_t v7 = *(unsigned int *)(a2 + 28);
    if (v6) {
      uint64_t v8 = (_WORD *)(v6 + *(void *)a2);
    }
    else {
      uint64_t v8 = 0;
    }
    if (v6) {
      size_t v9 = (_WORD *)(v6 + *(void *)a2 + (*(_DWORD *)(a2 + 16) * v7));
    }
    else {
      size_t v9 = 0;
    }
    if (v8 != v9)
    {
      int v10 = 0;
      int v11 = 0;
      int v12 = 0;
      int v13 = 0;
      int v14 = *(void *)(a1 + 28);
      unint64_t v15 = *(void *)(a2 + 20);
      unint64_t v16 = *(_DWORD *)(a1 + 16);
      int v17 = *(_DWORD *)(a1 + 20);
      int v19 = *(_DWORD *)(a2 + 8);
      int v18 = *(_DWORD *)(a2 + 12);
      int v20 = HIDWORD(v15);
      unint64_t v21 = HIDWORD(v14);
      unint64_t v22 = *(unsigned int *)(a1 + 36);
      if (BaseAddress) {
        uint64_t v23 = &BaseAddress[*(void *)(a1 + 8)];
      }
      else {
        uint64_t v23 = 0;
      }
      int v24 = v15;
      uint64_t v25 = *(void *)(a1 + 28);
      uint64_t v26 = -(uint64_t)(v19 * v15);
      uint64_t v27 = -(uint64_t)(v16 * v14);
      do
      {
        *(_WORD *)uint64_t v23 = *v8;
        uint64_t v8 = (_WORD *)((char *)v8 + v24);
        if (++v12 == v19)
        {
          int v12 = 0;
          uint64_t v8 = (_WORD *)((char *)v8 + v26 + v20);
          uint64_t v28 = v13 + 1;
          if (v13 + 1 == v18) {
            int v13 = 0;
          }
          else {
            ++v13;
          }
          if (v28 == v18) {
            uint64_t v8 = (_WORD *)((char *)v8 + v7 - (v28 * v20));
          }
        }
        v23 += v25;
        if (++v10 == v16)
        {
          int v10 = 0;
          v23 += v27 + v21;
          int v29 = v11 + 1;
          if (v11 + 1 == v17) {
            int v11 = 0;
          }
          else {
            ++v11;
          }
          if (v29 == v17) {
            uint64_t v23 = &v23[v22 - (v29 * v21)];
          }
        }
      }
      while (v8 != v9);
    }
    if (!CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a1 + 48), 0)) {
      *(void *)(a1 + 40) = 0;
    }
  }
  return a1;
}

uint64_t cva::Buffer<cva::half>::resize(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[7];
  if (v4)
  {

    MEMORY[0x2166B9890](v4, 0xE0C400670D255);
  }
  a1[7] = 0;
  uint64_t v5 = a1[8];
  if (v5)
  {

    MEMORY[0x2166B9890](v5, 0xE0C400670D255);
  }
  a1[8] = 0;
  int v6 = *(uint64_t (**)(void *, uint64_t))(*a1 + 16);
  return v6(a1, a2);
}

uint64_t cva::Buffer<cva::half>::resize(void *a1, int a2, int a3, int a4)
{
  v8[0] = a2;
  v8[1] = a3;
  v8[2] = a4;
  uint64_t v5 = a1[7];
  if (v5)
  {

    MEMORY[0x2166B9890](v5, 0xE0C400670D255);
  }
  a1[7] = 0;
  uint64_t v6 = a1[8];
  if (v6)
  {

    MEMORY[0x2166B9890](v6, 0xE0C400670D255);
  }
  a1[8] = 0;
  return (*(uint64_t (**)(void *, _DWORD *))(*a1 + 16))(a1, v8);
}

uint64_t cva::Buffer<cva::half>::operator __CVBuffer *(uint64_t a1)
{
  return *(void *)(a1 + 48);
}

CVPixelBufferRef cva::Buffer<cva::half>::allocate(_DWORD *a1, OSType a2)
{
  size_t v3 = (a1[1] * *a1);
  size_t v4 = a1[2];
  AttributeDictionary = cva::createAttributeDictionary((cva *)v3, v4, a2, 64, 64, 0, 0, 0, v7);
  CVPixelBufferRef pixelBufferOut = 0;
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v3, v4, a2, AttributeDictionary, &pixelBufferOut);
  CFRelease(AttributeDictionary);
  return pixelBufferOut;
}

uint64_t cva::geo::Chart<float>::Chart(uint64_t result, int a2, int a3, int a4, int a5, float a6)
{
  *(unsigned char *)(result + 23) = 9;
  strcpy((char *)result, "Undefined");
  *(_DWORD *)(result + 24) = 1065353216;
  *(unsigned char *)(result + 28) = 1;
  *(_DWORD *)(result + 32) = 1065353216;
  *(unsigned char *)(result + 36) = 1;
  *(_DWORD *)(result + 40) = 0;
  *(unsigned char *)(result + 44) = 1;
  *(unsigned char *)(result + 56) = a4;
  int v6 = (2 * a3 - 1) * (2 * a2 - 1) - a3 * a2;
  if (!a4) {
    int v6 = 0;
  }
  *(_DWORD *)(result + 48) = a5;
  *(_DWORD *)(result + 52) = a5 + 2 * a3 * 2 * a2 + v6;
  *(_DWORD *)(result + 60) = a2;
  *(_DWORD *)(result + 64) = a3;
  *(float *)(result + 68) = a6;
  return result;
}

{
  int v6;

  *(unsigned char *)(result + 23) = 9;
  strcpy((char *)result, "Undefined");
  *(_DWORD *)(result + 24) = 1065353216;
  *(unsigned char *)(result + 28) = 1;
  *(_DWORD *)(result + 32) = 1065353216;
  *(unsigned char *)(result + 36) = 1;
  *(_DWORD *)(result + 40) = 0;
  *(unsigned char *)(result + 44) = 1;
  *(unsigned char *)(result + 56) = a4;
  int v6 = (2 * a3 - 1) * (2 * a2 - 1) - a3 * a2;
  if (!a4) {
    int v6 = 0;
  }
  *(_DWORD *)(result + 48) = a5;
  *(_DWORD *)(result + 52) = a5 + 2 * a3 * 2 * a2 + v6;
  *(_DWORD *)(result + 60) = a2;
  *(_DWORD *)(result + 64) = a3;
  *(float *)(result + 68) = a6;
  return result;
}

void cva::geo::Chart<float>::create()
{
}

void cva::geo::Chart<float>::clone()
{
}

void *sub_2153C0AE4(unsigned char *__dst, void *__src, unint64_t a3)
{
  uint64_t v5 = __dst;
  if (a3 > 0x16)
  {
    if (a3 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    uint64_t v6 = (a3 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a3 | 7) != 0x17) {
      uint64_t v6 = a3 | 7;
    }
    uint64_t v7 = v6 + 1;
    uint64_t v8 = operator new(v6 + 1);
    v5[1] = a3;
    v5[2] = v7 | 0x8000000000000000;
    *uint64_t v5 = v8;
    uint64_t v5 = v8;
  }
  else
  {
    __dst[23] = a3;
  }
  return memmove(v5, __src, a3 + 1);
}

unsigned char *cva::geo::Chart<float>::setFreeFixed(unsigned char *result, char a2)
{
  result[28] = a2;
  result[36] = a2;
  result[44] = a2;
  return result;
}

float cva::geo::Chart<float>::project@<S0>(float *a1@<X0>, float *a2@<X1>, uint64_t a3@<X8>)
{
  *(unsigned char *)(a3 + 12) = 1;
  float v5 = *a2;
  float v6 = a1[6];
  *(float *)a3 = (float)(*a2 * v6) * a1[8];
  __float2 v7 = __sincosf_stret(a1[10]);
  float result = (float)(a2[1] * (float)(v6 * v7.__cosval)) + (float)((float)(v6 * v7.__sinval) * v5);
  *(float *)(a3 + 4) = result;
  *(_DWORD *)(a3 + 8) = 0;
  return result;
}

uint64_t cva::geo::Chart<float>::project(float *a1, float *a2, uint64_t a3)
{
  *(float *)a3 = (float)(*a2 * a1[6]) * a1[8];
  float v5 = a1[6];
  __float2 v6 = __sincosf_stret(a1[10]);
  *(float *)(a3 + 4) = (float)((float)(v5 * v6.__cosval) * a2[1]) + (float)((float)(v5 * v6.__sinval) * *a2);
  *(_DWORD *)(a3 + 8) = 0;
  return 1;
}

float cva::geo::Chart<float>::unproject@<S0>(float *a1@<X0>, float *a2@<X1>, uint64_t a3@<X8>)
{
  *(unsigned char *)(a3 + 12) = 1;
  float v4 = a1[6];
  float v6 = *a2;
  float v5 = a2[1];
  *(float *)a3 = *a2 / (float)(v4 * a1[8]);
  float v7 = v5 / v4;
  __float2 v8 = __sincosf_stret(a1[10]);
  float result = (float)(v7 - (float)(v8.__sinval * v6)) / v8.__cosval;
  *(float *)(a3 + 4) = result;
  *(_DWORD *)(a3 + 8) = 0;
  return result;
}

uint64_t cva::geo::Chart<float>::unproject(float *a1, float *a2, uint64_t a3)
{
  *(float *)a3 = *a2 / (float)(a1[6] * a1[8]);
  float v5 = a2[1] / a1[6];
  __float2 v6 = __sincosf_stret(a1[10]);
  *(float *)(a3 + 4) = (float)(v5 - (float)(v6.__sinval * *a2)) / v6.__cosval;
  *(_DWORD *)(a3 + 8) = 0;
  return 1;
}

void *cva::geo::Chart<float>::print(uint64_t a1, void *a2)
{
  float v4 = sub_2153C1168(a2, (uint64_t)"[Name][", 7);
  int v5 = *(char *)(a1 + 23);
  if (v5 >= 0) {
    uint64_t v6 = a1;
  }
  else {
    uint64_t v6 = *(void *)a1;
  }
  if (v5 >= 0) {
    uint64_t v7 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    uint64_t v7 = *(void *)(a1 + 8);
  }
  __float2 v8 = sub_2153C1168(v4, v6, v7);
  size_t v9 = sub_2153C1168(v8, (uint64_t)"]\n", 2);
  sub_2153C1168(v9, (uint64_t)"[Rows, Columns][Square Size][", 29);
  int v10 = (void *)std::ostream::operator<<();
  sub_2153C1168(v10, (uint64_t)", ", 2);
  int v11 = (void *)std::ostream::operator<<();
  sub_2153C1168(v11, (uint64_t)"][", 2);
  int v12 = (void *)std::ostream::operator<<();
  sub_2153C1168(v12, (uint64_t)"]\n", 2);
  int v13 = sub_2153C1168(a2, (uint64_t)"[Has Dots][", 11);
  if (*(unsigned char *)(a1 + 56)) {
    int v14 = "True";
  }
  else {
    int v14 = "False";
  }
  if (*(unsigned char *)(a1 + 56)) {
    uint64_t v15 = 4;
  }
  else {
    uint64_t v15 = 5;
  }
  unint64_t v16 = sub_2153C1168(v13, (uint64_t)v14, v15);
  int v17 = sub_2153C1168(v16, (uint64_t)"]\n", 2);
  sub_2153C1168(v17, (uint64_t)"[Start ID, End ID][", 19);
  int v18 = (void *)std::ostream::operator<<();
  sub_2153C1168(v18, (uint64_t)", ", 2);
  int v19 = (void *)std::ostream::operator<<();
  sub_2153C1168(v19, (uint64_t)"]\n", 2);
  if (*(unsigned char *)(a1 + 28)) {
    int v20 = "[FREE]";
  }
  else {
    int v20 = "[FIXED]";
  }
  if (*(unsigned char *)(a1 + 28)) {
    size_t v21 = 6;
  }
  else {
    size_t v21 = 7;
  }
  unsigned __int8 v48 = v21;
  memcpy(&__dst, v20, v21);
  *(unsigned char *)((unint64_t)&__dst | v21) = 0;
  if ((v48 & 0x80u) == 0) {
    p_dst = (void **)&__dst;
  }
  else {
    p_dst = __dst;
  }
  if ((v48 & 0x80u) == 0) {
    uint64_t v23 = v48;
  }
  else {
    uint64_t v23 = v47;
  }
  int v24 = sub_2153C1168(a2, (uint64_t)p_dst, v23);
  uint64_t v25 = sub_2153C1168(v24, (uint64_t)"[", 1);
  HIBYTE(v45[2]) = 11;
  strcpy((char *)v45, "Chart Scale");
  uint64_t v26 = sub_2153C1168(v25, (uint64_t)v45, 11);
  sub_2153C1168(v26, (uint64_t)"] : ", 4);
  uint64_t v27 = (void *)std::ostream::operator<<();
  sub_2153C1168(v27, (uint64_t)"\n", 1);
  if (SHIBYTE(v45[2]) < 0)
  {
    operator delete(v45[0]);
    if (((char)v48 & 0x80000000) == 0) {
      goto LABEL_27;
    }
  }
  else if (((char)v48 & 0x80000000) == 0)
  {
    goto LABEL_27;
  }
  operator delete(__dst);
LABEL_27:
  if (*(unsigned char *)(a1 + 36)) {
    uint64_t v28 = "[FREE]";
  }
  else {
    uint64_t v28 = "[FIXED]";
  }
  if (*(unsigned char *)(a1 + 36)) {
    size_t v29 = 6;
  }
  else {
    size_t v29 = 7;
  }
  unsigned __int8 v48 = v29;
  memcpy(&__dst, v28, v29);
  *(unsigned char *)((unint64_t)&__dst | v29) = 0;
  if ((v48 & 0x80u) == 0) {
    int v30 = (void **)&__dst;
  }
  else {
    int v30 = __dst;
  }
  if ((v48 & 0x80u) == 0) {
    uint64_t v31 = v48;
  }
  else {
    uint64_t v31 = v47;
  }
  uint64_t v32 = sub_2153C1168(a2, (uint64_t)v30, v31);
  unint64_t v33 = sub_2153C1168(v32, (uint64_t)"[", 1);
  HIBYTE(v45[2]) = 18;
  strcpy((char *)v45, "Chart Aspect Ratio");
  uint64_t v34 = sub_2153C1168(v33, (uint64_t)v45, 18);
  sub_2153C1168(v34, (uint64_t)"] : ", 4);
  uint64_t v35 = (void *)std::ostream::operator<<();
  sub_2153C1168(v35, (uint64_t)"\n", 1);
  if (SHIBYTE(v45[2]) < 0)
  {
    operator delete(v45[0]);
    if (((char)v48 & 0x80000000) == 0) {
      goto LABEL_41;
    }
  }
  else if (((char)v48 & 0x80000000) == 0)
  {
    goto LABEL_41;
  }
  operator delete(__dst);
LABEL_41:
  if (*(unsigned char *)(a1 + 44)) {
    int v36 = "[FREE]";
  }
  else {
    int v36 = "[FIXED]";
  }
  if (*(unsigned char *)(a1 + 44)) {
    size_t v37 = 6;
  }
  else {
    size_t v37 = 7;
  }
  unsigned __int8 v48 = v37;
  memcpy(&__dst, v36, v37);
  *(unsigned char *)((unint64_t)&__dst | v37) = 0;
  if ((v48 & 0x80u) == 0) {
    v38 = (void **)&__dst;
  }
  else {
    v38 = __dst;
  }
  if ((v48 & 0x80u) == 0) {
    uint64_t v39 = v48;
  }
  else {
    uint64_t v39 = v47;
  }
  v40 = sub_2153C1168(a2, (uint64_t)v38, v39);
  v41 = sub_2153C1168(v40, (uint64_t)"[", 1);
  HIBYTE(v45[2]) = 10;
  strcpy((char *)v45, "Chart Skew");
  v42 = sub_2153C1168(v41, (uint64_t)v45, 10);
  sub_2153C1168(v42, (uint64_t)"] : ", 4);
  v43 = (void *)std::ostream::operator<<();
  sub_2153C1168(v43, (uint64_t)"\n", 1);
  if (SHIBYTE(v45[2]) < 0)
  {
    operator delete(v45[0]);
    if (((char)v48 & 0x80000000) == 0) {
      return a2;
    }
LABEL_61:
    operator delete(__dst);
    return a2;
  }
  if ((char)v48 < 0) {
    goto LABEL_61;
  }
  return a2;
}

void *sub_2153C1168(void *a1, uint64_t a2, uint64_t a3)
{
  MEMORY[0x2166B95F0](v23, a1);
  if (!v23[0]) {
    goto LABEL_32;
  }
  uint64_t v6 = (char *)a1 + *(void *)(*a1 - 24);
  uint64_t v7 = *((void *)v6 + 5);
  uint64_t v8 = a2 + a3;
  if ((*((_DWORD *)v6 + 2) & 0xB0) == 0x20) {
    uint64_t v9 = a2 + a3;
  }
  else {
    uint64_t v9 = a2;
  }
  int v10 = *((_DWORD *)v6 + 36);
  if (v10 == -1)
  {
    std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
    int v11 = std::locale::use_facet(&__b, MEMORY[0x263F8C108]);
    int v10 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 32);
    std::locale::~locale(&__b);
    *((_DWORD *)v6 + 36) = v10;
    if (!v7) {
      goto LABEL_31;
    }
  }
  else if (!v7)
  {
    goto LABEL_31;
  }
  uint64_t v12 = *((void *)v6 + 3);
  BOOL v13 = v12 <= a3;
  size_t v14 = v12 - a3;
  if (v13) {
    size_t v15 = 0;
  }
  else {
    size_t v15 = v14;
  }
  if (v9 - a2 >= 1
    && (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 96))(v7, a2, v9 - a2) != v9 - a2)
  {
    goto LABEL_31;
  }
  if ((uint64_t)v15 >= 1)
  {
    if (v15 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    if (v15 >= 0x17)
    {
      uint64_t v17 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v15 | 7) != 0x17) {
        uint64_t v17 = v15 | 7;
      }
      uint64_t v18 = v17 + 1;
      p_b = (std::locale::__imp *)operator new(v17 + 1);
      size_t v25 = v15;
      int64_t v26 = v18 | 0x8000000000000000;
      __b.__locale_ = p_b;
    }
    else
    {
      HIBYTE(v26) = v15;
      p_b = (std::locale::__imp *)&__b;
    }
    memset(p_b, v10, v15);
    *((unsigned char *)p_b + v15) = 0;
    if (v26 >= 0) {
      locale = &__b;
    }
    else {
      locale = __b.__locale_;
    }
    uint64_t v20 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v7 + 96))(v7, locale, v15);
    uint64_t v21 = v20;
    if ((SHIBYTE(v26) & 0x80000000) == 0)
    {
      if (v20 != v15) {
        goto LABEL_31;
      }
      goto LABEL_28;
    }
    operator delete(__b.__locale_);
    if (v21 != v15)
    {
LABEL_31:
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
      goto LABEL_32;
    }
  }
LABEL_28:
  if (v8 - v9 >= 1
    && (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 96))(v7, v9, v8 - v9) != v8 - v9)
  {
    goto LABEL_31;
  }
  *((void *)v6 + 3) = 0;
LABEL_32:
  MEMORY[0x2166B9600](v23);
  return a1;
}

BOOL cva::geo::Chart<float>::almostEqual(float *a1, float *a2, float a3)
{
  return (float)(a1[6] - a2[6]) < a3 && (float)(a1[8] - a2[8]) < a3 && (float)(a1[10] - a2[10]) < a3;
}

BOOL cva::geo::Chart<float>::hasTrackID(uint64_t a1, unsigned int a2)
{
  return *(_DWORD *)(a1 + 48) <= a2 && *(_DWORD *)(a1 + 52) > a2;
}

uint64_t cva::geo::Chart<float>::cornerType(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 48);
  BOOL v10 = a2 >= v2;
  unsigned int v3 = a2 - v2;
  if (!v10 || *(_DWORD *)(a1 + 52) <= a2) {
    return 3;
  }
  if (!*(unsigned char *)(a1 + 56)) {
    return 0;
  }
  int v4 = *(_DWORD *)(a1 + 64);
  unsigned int v5 = 4 * *(_DWORD *)(a1 + 60) * v4;
  BOOL v10 = v3 >= v5;
  unsigned int v6 = v3 - v5;
  if (!v10) {
    return 0;
  }
  unsigned int v8 = v6 % (3 * v4 - 2);
  unsigned int v9 = v4 - 1;
  BOOL v10 = (((_BYTE)v8 - (_BYTE)v9) & 1) != 0 && v8 >= v9;
  if (v10) {
    return 2;
  }
  else {
    return 1;
  }
}

uint64_t cva::geo::Chart<float>::startID(uint64_t a1)
{
  return *(unsigned int *)(a1 + 48);
}

uint64_t cva::geo::Chart<float>::endID(uint64_t a1)
{
  return *(unsigned int *)(a1 + 52);
}

uint64_t cva::geo::Chart<float>::hasDots(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 56);
}

uint64_t cva::geo::Chart<float>::rows(uint64_t a1)
{
  return *(unsigned int *)(a1 + 60);
}

uint64_t cva::geo::Chart<float>::columns(uint64_t a1)
{
  return *(unsigned int *)(a1 + 64);
}

float cva::geo::Chart<float>::squareSize(uint64_t a1)
{
  return *(float *)(a1 + 68);
}

uint64_t cva::geo::Chart<double>::Chart(uint64_t result, int a2, int a3, int a4, int a5, double a6)
{
  *(unsigned char *)(result + 23) = 9;
  strcpy((char *)result, "Undefined");
  *(void *)(result + 24) = 0x3FF0000000000000;
  *(unsigned char *)(result + 32) = 1;
  *(void *)(result + 40) = 0x3FF0000000000000;
  *(unsigned char *)(result + 48) = 1;
  *(void *)(result + 56) = 0;
  *(unsigned char *)(result + 64) = 1;
  *(unsigned char *)(result + 80) = a4;
  int v6 = (2 * a3 - 1) * (2 * a2 - 1) - a3 * a2;
  if (!a4) {
    int v6 = 0;
  }
  *(_DWORD *)(result + 72) = a5;
  *(_DWORD *)(result + 76) = a5 + 2 * a3 * 2 * a2 + v6;
  *(_DWORD *)(result + 84) = a2;
  *(_DWORD *)(result + 88) = a3;
  *(double *)(result + 96) = a6;
  return result;
}

{
  int v6;

  *(unsigned char *)(result + 23) = 9;
  strcpy((char *)result, "Undefined");
  *(void *)(result + 24) = 0x3FF0000000000000;
  *(unsigned char *)(result + 32) = 1;
  *(void *)(result + 40) = 0x3FF0000000000000;
  *(unsigned char *)(result + 48) = 1;
  *(void *)(result + 56) = 0;
  *(unsigned char *)(result + 64) = 1;
  *(unsigned char *)(result + 80) = a4;
  int v6 = (2 * a3 - 1) * (2 * a2 - 1) - a3 * a2;
  if (!a4) {
    int v6 = 0;
  }
  *(_DWORD *)(result + 72) = a5;
  *(_DWORD *)(result + 76) = a5 + 2 * a3 * 2 * a2 + v6;
  *(_DWORD *)(result + 84) = a2;
  *(_DWORD *)(result + 88) = a3;
  *(double *)(result + 96) = a6;
  return result;
}

void cva::geo::Chart<double>::create()
{
}

void cva::geo::Chart<double>::clone()
{
}

unsigned char *cva::geo::Chart<double>::setFreeFixed(unsigned char *result, char a2)
{
  result[32] = a2;
  result[48] = a2;
  result[64] = a2;
  return result;
}

double cva::geo::Chart<double>::project@<D0>(double *a1@<X0>, double *a2@<X1>, uint64_t a3@<X8>)
{
  *(unsigned char *)(a3 + 24) = 1;
  double v5 = *a2;
  double v6 = a1[3];
  *(double *)a3 = *a2 * v6 * a1[5];
  __double2 v7 = __sincos_stret(a1[7]);
  double result = a2[1] * (v6 * v7.__cosval) + v6 * v7.__sinval * v5;
  *(double *)(a3 + 8) = result;
  *(void *)(a3 + 16) = 0;
  return result;
}

uint64_t cva::geo::Chart<double>::project(double *a1, double *a2, uint64_t a3)
{
  *(double *)a3 = *a2 * a1[3] * a1[5];
  double v5 = a1[3];
  __double2 v6 = __sincos_stret(a1[7]);
  *(double *)(a3 + 8) = v5 * v6.__cosval * a2[1] + v5 * v6.__sinval * *a2;
  *(void *)(a3 + 16) = 0;
  return 1;
}

double cva::geo::Chart<double>::unproject@<D0>(double *a1@<X0>, double *a2@<X1>, uint64_t a3@<X8>)
{
  *(unsigned char *)(a3 + 24) = 1;
  double v4 = a1[3];
  double v6 = *a2;
  double v5 = a2[1];
  *(double *)a3 = *a2 / (v4 * a1[5]);
  double v7 = v5 / v4;
  __double2 v8 = __sincos_stret(a1[7]);
  double result = (v7 - v8.__sinval * v6) / v8.__cosval;
  *(double *)(a3 + 8) = result;
  *(void *)(a3 + 16) = 0;
  return result;
}

uint64_t cva::geo::Chart<double>::unproject(double *a1, double *a2, uint64_t a3)
{
  *(double *)a3 = *a2 / (a1[3] * a1[5]);
  double v5 = a2[1] / a1[3];
  __double2 v6 = __sincos_stret(a1[7]);
  *(double *)(a3 + 8) = (v5 - v6.__sinval * *a2) / v6.__cosval;
  *(void *)(a3 + 16) = 0;
  return 1;
}

void *cva::geo::Chart<double>::print(uint64_t a1, void *a2)
{
  double v4 = sub_2153C1168(a2, (uint64_t)"[Name][", 7);
  int v5 = *(char *)(a1 + 23);
  if (v5 >= 0) {
    uint64_t v6 = a1;
  }
  else {
    uint64_t v6 = *(void *)a1;
  }
  if (v5 >= 0) {
    uint64_t v7 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    uint64_t v7 = *(void *)(a1 + 8);
  }
  __double2 v8 = sub_2153C1168(v4, v6, v7);
  unsigned int v9 = sub_2153C1168(v8, (uint64_t)"]\n", 2);
  sub_2153C1168(v9, (uint64_t)"[Rows, Columns][Square Size][", 29);
  BOOL v10 = (void *)std::ostream::operator<<();
  sub_2153C1168(v10, (uint64_t)", ", 2);
  int v11 = (void *)std::ostream::operator<<();
  sub_2153C1168(v11, (uint64_t)"][", 2);
  uint64_t v12 = (void *)std::ostream::operator<<();
  sub_2153C1168(v12, (uint64_t)"]\n", 2);
  BOOL v13 = sub_2153C1168(a2, (uint64_t)"[Has Dots][", 11);
  if (*(unsigned char *)(a1 + 80)) {
    size_t v14 = "True";
  }
  else {
    size_t v14 = "False";
  }
  if (*(unsigned char *)(a1 + 80)) {
    uint64_t v15 = 4;
  }
  else {
    uint64_t v15 = 5;
  }
  unint64_t v16 = sub_2153C1168(v13, (uint64_t)v14, v15);
  uint64_t v17 = sub_2153C1168(v16, (uint64_t)"]\n", 2);
  sub_2153C1168(v17, (uint64_t)"[Start ID, End ID][", 19);
  uint64_t v18 = (void *)std::ostream::operator<<();
  sub_2153C1168(v18, (uint64_t)", ", 2);
  int v19 = (void *)std::ostream::operator<<();
  sub_2153C1168(v19, (uint64_t)"]\n", 2);
  if (*(unsigned char *)(a1 + 32)) {
    uint64_t v20 = "[FREE]";
  }
  else {
    uint64_t v20 = "[FIXED]";
  }
  if (*(unsigned char *)(a1 + 32)) {
    size_t v21 = 6;
  }
  else {
    size_t v21 = 7;
  }
  unsigned __int8 v48 = v21;
  memcpy(&__dst, v20, v21);
  *(unsigned char *)((unint64_t)&__dst | v21) = 0;
  if ((v48 & 0x80u) == 0) {
    p_dst = (void **)&__dst;
  }
  else {
    p_dst = __dst;
  }
  if ((v48 & 0x80u) == 0) {
    uint64_t v23 = v48;
  }
  else {
    uint64_t v23 = v47;
  }
  int v24 = sub_2153C1168(a2, (uint64_t)p_dst, v23);
  size_t v25 = sub_2153C1168(v24, (uint64_t)"[", 1);
  HIBYTE(v45[2]) = 11;
  strcpy((char *)v45, "Chart Scale");
  int64_t v26 = sub_2153C1168(v25, (uint64_t)v45, 11);
  sub_2153C1168(v26, (uint64_t)"] : ", 4);
  uint64_t v27 = (void *)std::ostream::operator<<();
  sub_2153C1168(v27, (uint64_t)"\n", 1);
  if (SHIBYTE(v45[2]) < 0)
  {
    operator delete(v45[0]);
    if (((char)v48 & 0x80000000) == 0) {
      goto LABEL_27;
    }
  }
  else if (((char)v48 & 0x80000000) == 0)
  {
    goto LABEL_27;
  }
  operator delete(__dst);
LABEL_27:
  if (*(unsigned char *)(a1 + 48)) {
    uint64_t v28 = "[FREE]";
  }
  else {
    uint64_t v28 = "[FIXED]";
  }
  if (*(unsigned char *)(a1 + 48)) {
    size_t v29 = 6;
  }
  else {
    size_t v29 = 7;
  }
  unsigned __int8 v48 = v29;
  memcpy(&__dst, v28, v29);
  *(unsigned char *)((unint64_t)&__dst | v29) = 0;
  if ((v48 & 0x80u) == 0) {
    int v30 = (void **)&__dst;
  }
  else {
    int v30 = __dst;
  }
  if ((v48 & 0x80u) == 0) {
    uint64_t v31 = v48;
  }
  else {
    uint64_t v31 = v47;
  }
  uint64_t v32 = sub_2153C1168(a2, (uint64_t)v30, v31);
  unint64_t v33 = sub_2153C1168(v32, (uint64_t)"[", 1);
  HIBYTE(v45[2]) = 18;
  strcpy((char *)v45, "Chart Aspect Ratio");
  uint64_t v34 = sub_2153C1168(v33, (uint64_t)v45, 18);
  sub_2153C1168(v34, (uint64_t)"] : ", 4);
  uint64_t v35 = (void *)std::ostream::operator<<();
  sub_2153C1168(v35, (uint64_t)"\n", 1);
  if (SHIBYTE(v45[2]) < 0)
  {
    operator delete(v45[0]);
    if (((char)v48 & 0x80000000) == 0) {
      goto LABEL_41;
    }
  }
  else if (((char)v48 & 0x80000000) == 0)
  {
    goto LABEL_41;
  }
  operator delete(__dst);
LABEL_41:
  if (*(unsigned char *)(a1 + 64)) {
    int v36 = "[FREE]";
  }
  else {
    int v36 = "[FIXED]";
  }
  if (*(unsigned char *)(a1 + 64)) {
    size_t v37 = 6;
  }
  else {
    size_t v37 = 7;
  }
  unsigned __int8 v48 = v37;
  memcpy(&__dst, v36, v37);
  *(unsigned char *)((unint64_t)&__dst | v37) = 0;
  if ((v48 & 0x80u) == 0) {
    v38 = (void **)&__dst;
  }
  else {
    v38 = __dst;
  }
  if ((v48 & 0x80u) == 0) {
    uint64_t v39 = v48;
  }
  else {
    uint64_t v39 = v47;
  }
  v40 = sub_2153C1168(a2, (uint64_t)v38, v39);
  v41 = sub_2153C1168(v40, (uint64_t)"[", 1);
  HIBYTE(v45[2]) = 10;
  strcpy((char *)v45, "Chart Skew");
  v42 = sub_2153C1168(v41, (uint64_t)v45, 10);
  sub_2153C1168(v42, (uint64_t)"] : ", 4);
  v43 = (void *)std::ostream::operator<<();
  sub_2153C1168(v43, (uint64_t)"\n", 1);
  if (SHIBYTE(v45[2]) < 0)
  {
    operator delete(v45[0]);
    if (((char)v48 & 0x80000000) == 0) {
      return a2;
    }
LABEL_61:
    operator delete(__dst);
    return a2;
  }
  if ((char)v48 < 0) {
    goto LABEL_61;
  }
  return a2;
}

BOOL cva::geo::Chart<double>::almostEqual(double *a1, double *a2, double a3)
{
  return a1[3] - a2[3] < a3 && a1[5] - a2[5] < a3 && a1[7] - a2[7] < a3;
}

BOOL cva::geo::Chart<double>::hasTrackID(uint64_t a1, unsigned int a2)
{
  return *(_DWORD *)(a1 + 72) <= a2 && *(_DWORD *)(a1 + 76) > a2;
}

uint64_t cva::geo::Chart<double>::cornerType(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 72);
  BOOL v10 = a2 >= v2;
  unsigned int v3 = a2 - v2;
  if (!v10 || *(_DWORD *)(a1 + 76) <= a2) {
    return 3;
  }
  if (!*(unsigned char *)(a1 + 80)) {
    return 0;
  }
  int v4 = *(_DWORD *)(a1 + 88);
  unsigned int v5 = 4 * *(_DWORD *)(a1 + 84) * v4;
  BOOL v10 = v3 >= v5;
  unsigned int v6 = v3 - v5;
  if (!v10) {
    return 0;
  }
  unsigned int v8 = v6 % (3 * v4 - 2);
  unsigned int v9 = v4 - 1;
  BOOL v10 = (((_BYTE)v8 - (_BYTE)v9) & 1) != 0 && v8 >= v9;
  if (v10) {
    return 2;
  }
  else {
    return 1;
  }
}

uint64_t cva::geo::Chart<double>::startID(uint64_t a1)
{
  return *(unsigned int *)(a1 + 72);
}

uint64_t cva::geo::Chart<double>::endID(uint64_t a1)
{
  return *(unsigned int *)(a1 + 76);
}

uint64_t cva::geo::Chart<double>::hasDots(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 80);
}

uint64_t cva::geo::Chart<double>::rows(uint64_t a1)
{
  return *(unsigned int *)(a1 + 84);
}

uint64_t cva::geo::Chart<double>::columns(uint64_t a1)
{
  return *(unsigned int *)(a1 + 88);
}

double cva::geo::Chart<double>::squareSize(uint64_t a1)
{
  return *(double *)(a1 + 96);
}

float cva::MEstimatorL2<float>::getREE95Threshold()
{
  return 1.0;
}

double cva::MEstimatorL2<double>::getREE95Threshold()
{
  return 1.0;
}

float cva::MEstimatorHuber<float>::getREE95Threshold()
{
  return 1.345;
}

double cva::MEstimatorHuber<double>::getREE95Threshold()
{
  return 1.345;
}

float cva::MEstimatorTukey<float>::getREE95Threshold()
{
  return 4.685;
}

double cva::MEstimatorTukey<double>::getREE95Threshold()
{
  return 4.685;
}

float cva::MEstimatorCauchy<float>::getREE95Threshold()
{
  return 2.385;
}

double cva::MEstimatorCauchy<double>::getREE95Threshold()
{
  return 2.385;
}

float cva::MEstimatorTukeyMAD<float>::getREE95Threshold()
{
  return 4.685;
}

double cva::MEstimatorTukeyMAD<double>::getREE95Threshold()
{
  return 4.685;
}

size_t cva::imageViewFromPixelBuffer<unsigned char>@<X0>(__CVBuffer *a1@<X0>, void *a2@<X8>)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  cva::formatDescription(PixelFormatType, (uint64_t)v15, v5);
  uint64_t PlaneCount = CVPixelBufferGetPlaneCount(a1);
  if (PlaneCount)
  {
    size_t v7 = 0;
    memset(v13, 0, sizeof(v13));
    do
    {
      v13[v7] = CVPixelBufferGetBaseAddressOfPlane(a1, v7);
      v14[v7] = CVPixelBufferGetBytesPerRowOfPlane(a1, v7);
      ++v7;
    }
    while (PlaneCount != v7);
    size_t BytesPerRow = v14[0];
    BaseAddress = (void *)v13[0];
  }
  else
  {
    BaseAddress = CVPixelBufferGetBaseAddress(a1);
    size_t BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
  }
  unsigned int Width = CVPixelBufferGetWidth(a1);
  size_t result = CVPixelBufferGetHeight(a1);
  size_t v12 = v15[0] | (BytesPerRow << 32);
  *a2 = 0;
  a2[1] = Width | ((unint64_t)result << 32);
  a2[2] = v12;
  a2[3] = BaseAddress;
  return result;
}

uint64_t cva::formatDescription(OSType pixelFormat, uint64_t a2, unsigned int *a3)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  int v28 = 0;
  uint64_t valuePtr = 0;
  int v26 = 0;
  uint64_t v25 = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 8) = 0;
  CFDictionaryRef v4 = CVPixelFormatDescriptionCreateWithPixelFormatType((CFAllocatorRef)*MEMORY[0x263EFFB08], pixelFormat);
  if (!v4) {
    return 4294960636;
  }
  CFDictionaryRef v5 = v4;
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(v4, (const void *)*MEMORY[0x263F042C8]);
  if (Value)
  {
    CFArrayRef v7 = Value;
    CFIndex Count = CFArrayGetCount(Value);
    if (Count < 1)
    {
      uint64_t v15 = 0;
    }
    else
    {
      if (Count >= 3) {
        uint64_t v9 = 3;
      }
      else {
        uint64_t v9 = Count;
      }
      BOOL v10 = (const void *)*MEMORY[0x263F04260];
      int v11 = (const void *)*MEMORY[0x263F04250];
      LODWORD(valuePtr) = 1;
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v7, 0);
      CFNumberRef v13 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, v10);
      if (v13) {
        CFNumberGetValue(v13, kCFNumberIntType, &valuePtr);
      }
      CFNumberRef v14 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, v11);
      if (v14)
      {
        CFNumberGetValue(v14, kCFNumberIntType, &v25);
        uint64_t v15 = 0;
      }
      else
      {
        uint64_t v15 = 4294960636;
      }
      *(_DWORD *)a2 = ((int)v25 / (int)valuePtr) >> 3;
      if (v9 != 1)
      {
        HIDWORD(valuePtr) = 1;
        CFDictionaryRef v18 = (const __CFDictionary *)CFArrayGetValueAtIndex(v7, 1);
        CFNumberRef v19 = (const __CFNumber *)CFDictionaryGetValue(v18, v10);
        if (v19) {
          CFNumberGetValue(v19, kCFNumberIntType, (char *)&valuePtr + 4);
        }
        CFNumberRef v20 = (const __CFNumber *)CFDictionaryGetValue(v18, v11);
        if (v20) {
          CFNumberGetValue(v20, kCFNumberIntType, (char *)&v25 + 4);
        }
        else {
          uint64_t v15 = 4294960636;
        }
        *(_DWORD *)(a2 + 4) = (SHIDWORD(v25) / SHIDWORD(valuePtr)) >> 3;
        if (v9 != 2)
        {
          int v28 = 1;
          CFDictionaryRef v21 = (const __CFDictionary *)CFArrayGetValueAtIndex(v7, 2);
          CFNumberRef v22 = (const __CFNumber *)CFDictionaryGetValue(v21, v10);
          if (v22) {
            CFNumberGetValue(v22, kCFNumberIntType, &v28);
          }
          CFNumberRef v23 = (const __CFNumber *)CFDictionaryGetValue(v21, v11);
          if (v23) {
            CFNumberGetValue(v23, kCFNumberIntType, &v26);
          }
          else {
            uint64_t v15 = 4294960636;
          }
          *(_DWORD *)(a2 + 8) = (v26 / v28) >> 3;
        }
      }
    }
  }
  else
  {
    LODWORD(valuePtr) = 1;
    CFNumberRef v16 = (const __CFNumber *)CFDictionaryGetValue(v5, (const void *)*MEMORY[0x263F04260]);
    if (v16) {
      CFNumberGetValue(v16, kCFNumberIntType, &valuePtr);
    }
    CFNumberRef v17 = (const __CFNumber *)CFDictionaryGetValue(v5, (const void *)*MEMORY[0x263F04250]);
    if (v17)
    {
      CFNumberGetValue(v17, kCFNumberIntType, &v25);
      uint64_t v15 = 0;
    }
    else
    {
      uint64_t v15 = 4294960636;
    }
    *(_DWORD *)a2 = ((int)v25 / (int)valuePtr) >> 3;
  }
  CFRelease(v5);
  return v15;
}

size_t cva::imageViewFromPixelBuffer<unsigned short>@<X0>(__CVBuffer *a1@<X0>, void *a2@<X8>)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  cva::formatDescription(PixelFormatType, (uint64_t)v15, v5);
  uint64_t PlaneCount = CVPixelBufferGetPlaneCount(a1);
  if (PlaneCount)
  {
    size_t v7 = 0;
    memset(v13, 0, sizeof(v13));
    do
    {
      v13[v7] = CVPixelBufferGetBaseAddressOfPlane(a1, v7);
      v14[v7] = CVPixelBufferGetBytesPerRowOfPlane(a1, v7);
      ++v7;
    }
    while (PlaneCount != v7);
    size_t BytesPerRow = v14[0];
    BaseAddress = (void *)v13[0];
  }
  else
  {
    BaseAddress = CVPixelBufferGetBaseAddress(a1);
    size_t BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
  }
  unsigned int Width = CVPixelBufferGetWidth(a1);
  size_t result = CVPixelBufferGetHeight(a1);
  size_t v12 = v15[0] | (BytesPerRow << 32);
  *a2 = 0;
  a2[1] = Width | ((unint64_t)result << 32);
  a2[2] = v12;
  a2[3] = BaseAddress;
  return result;
}

size_t cva::imageViewFromPixelBuffer<float>@<X0>(__CVBuffer *a1@<X0>, void *a2@<X8>)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  cva::formatDescription(PixelFormatType, (uint64_t)v15, v5);
  uint64_t PlaneCount = CVPixelBufferGetPlaneCount(a1);
  if (PlaneCount)
  {
    size_t v7 = 0;
    memset(v13, 0, sizeof(v13));
    do
    {
      v13[v7] = CVPixelBufferGetBaseAddressOfPlane(a1, v7);
      v14[v7] = CVPixelBufferGetBytesPerRowOfPlane(a1, v7);
      ++v7;
    }
    while (PlaneCount != v7);
    size_t BytesPerRow = v14[0];
    BaseAddress = (void *)v13[0];
  }
  else
  {
    BaseAddress = CVPixelBufferGetBaseAddress(a1);
    size_t BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
  }
  unsigned int Width = CVPixelBufferGetWidth(a1);
  size_t result = CVPixelBufferGetHeight(a1);
  size_t v12 = v15[0] | (BytesPerRow << 32);
  *a2 = 0;
  a2[1] = Width | ((unint64_t)result << 32);
  a2[2] = v12;
  a2[3] = BaseAddress;
  return result;
}

size_t cva::imageViewFromPixelBuffer<cva::Matrix<unsigned char,3u,1u,false>>@<X0>(__CVBuffer *a1@<X0>, void *a2@<X8>)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  cva::formatDescription(PixelFormatType, (uint64_t)v15, v5);
  uint64_t PlaneCount = CVPixelBufferGetPlaneCount(a1);
  if (PlaneCount)
  {
    size_t v7 = 0;
    memset(v13, 0, sizeof(v13));
    do
    {
      v13[v7] = CVPixelBufferGetBaseAddressOfPlane(a1, v7);
      v14[v7] = CVPixelBufferGetBytesPerRowOfPlane(a1, v7);
      ++v7;
    }
    while (PlaneCount != v7);
    size_t BytesPerRow = v14[0];
    BaseAddress = (void *)v13[0];
  }
  else
  {
    BaseAddress = CVPixelBufferGetBaseAddress(a1);
    size_t BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
  }
  unsigned int Width = CVPixelBufferGetWidth(a1);
  size_t result = CVPixelBufferGetHeight(a1);
  size_t v12 = v15[0] | (BytesPerRow << 32);
  *a2 = 0;
  a2[1] = Width | ((unint64_t)result << 32);
  a2[2] = v12;
  a2[3] = BaseAddress;
  return result;
}

size_t cva::imageViewFromPixelBuffer<cva::Matrix<unsigned char,4u,1u,false>>@<X0>(__CVBuffer *a1@<X0>, void *a2@<X8>)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  cva::formatDescription(PixelFormatType, (uint64_t)v15, v5);
  uint64_t PlaneCount = CVPixelBufferGetPlaneCount(a1);
  if (PlaneCount)
  {
    size_t v7 = 0;
    memset(v13, 0, sizeof(v13));
    do
    {
      v13[v7] = CVPixelBufferGetBaseAddressOfPlane(a1, v7);
      v14[v7] = CVPixelBufferGetBytesPerRowOfPlane(a1, v7);
      ++v7;
    }
    while (PlaneCount != v7);
    size_t BytesPerRow = v14[0];
    BaseAddress = (void *)v13[0];
  }
  else
  {
    BaseAddress = CVPixelBufferGetBaseAddress(a1);
    size_t BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
  }
  unsigned int Width = CVPixelBufferGetWidth(a1);
  size_t result = CVPixelBufferGetHeight(a1);
  size_t v12 = v15[0] | (BytesPerRow << 32);
  *a2 = 0;
  a2[1] = Width | ((unint64_t)result << 32);
  a2[2] = v12;
  a2[3] = BaseAddress;
  return result;
}

size_t cva::imageViewFromPixelBuffer<unsigned char>@<X0>(__CVBuffer *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  cva::formatDescription(PixelFormatType, (uint64_t)v17, v7);
  uint64_t PlaneCount = CVPixelBufferGetPlaneCount(a1);
  if (PlaneCount)
  {
    size_t v9 = 0;
    memset(v15, 0, sizeof(v15));
    do
    {
      v15[v9] = CVPixelBufferGetBaseAddressOfPlane(a1, v9);
      v16[v9] = CVPixelBufferGetBytesPerRowOfPlane(a1, v9);
      ++v9;
    }
    while (PlaneCount != v9);
    size_t result = v16[0];
    BaseAddress = (char *)v15[0];
  }
  else
  {
    BaseAddress = (char *)CVPixelBufferGetBaseAddress(a1);
    size_t result = CVPixelBufferGetBytesPerRow(a1);
  }
  size_t v12 = v17[0] | (result << 32);
  CFNumberRef v13 = &BaseAddress[*(_DWORD *)a2 * v17[0] + *(_DWORD *)(a2 + 4) * result];
  uint64_t v14 = *(void *)(a2 + 8);
  *a3 = 0;
  a3[1] = v14;
  a3[2] = v12;
  a3[3] = v13;
  return result;
}

size_t cva::imageViewFromPixelBuffer<unsigned short>@<X0>(__CVBuffer *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  cva::formatDescription(PixelFormatType, (uint64_t)v17, v7);
  uint64_t PlaneCount = CVPixelBufferGetPlaneCount(a1);
  if (PlaneCount)
  {
    size_t v9 = 0;
    memset(v15, 0, sizeof(v15));
    do
    {
      v15[v9] = CVPixelBufferGetBaseAddressOfPlane(a1, v9);
      v16[v9] = CVPixelBufferGetBytesPerRowOfPlane(a1, v9);
      ++v9;
    }
    while (PlaneCount != v9);
    size_t result = v16[0];
    BaseAddress = (char *)v15[0];
  }
  else
  {
    BaseAddress = (char *)CVPixelBufferGetBaseAddress(a1);
    size_t result = CVPixelBufferGetBytesPerRow(a1);
  }
  size_t v12 = v17[0] | (result << 32);
  CFNumberRef v13 = &BaseAddress[*(_DWORD *)a2 * v17[0] + *(_DWORD *)(a2 + 4) * result];
  uint64_t v14 = *(void *)(a2 + 8);
  *a3 = 0;
  a3[1] = v14;
  a3[2] = v12;
  a3[3] = v13;
  return result;
}

size_t cva::imageViewFromPixelBuffer<float>@<X0>(__CVBuffer *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  cva::formatDescription(PixelFormatType, (uint64_t)v17, v7);
  uint64_t PlaneCount = CVPixelBufferGetPlaneCount(a1);
  if (PlaneCount)
  {
    size_t v9 = 0;
    memset(v15, 0, sizeof(v15));
    do
    {
      v15[v9] = CVPixelBufferGetBaseAddressOfPlane(a1, v9);
      v16[v9] = CVPixelBufferGetBytesPerRowOfPlane(a1, v9);
      ++v9;
    }
    while (PlaneCount != v9);
    size_t result = v16[0];
    BaseAddress = (char *)v15[0];
  }
  else
  {
    BaseAddress = (char *)CVPixelBufferGetBaseAddress(a1);
    size_t result = CVPixelBufferGetBytesPerRow(a1);
  }
  size_t v12 = v17[0] | (result << 32);
  CFNumberRef v13 = &BaseAddress[*(_DWORD *)a2 * v17[0] + *(_DWORD *)(a2 + 4) * result];
  uint64_t v14 = *(void *)(a2 + 8);
  *a3 = 0;
  a3[1] = v14;
  a3[2] = v12;
  a3[3] = v13;
  return result;
}

size_t cva::imageViewFromPixelBuffer<cva::Matrix<unsigned char,3u,1u,false>>@<X0>(__CVBuffer *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  cva::formatDescription(PixelFormatType, (uint64_t)v17, v7);
  uint64_t PlaneCount = CVPixelBufferGetPlaneCount(a1);
  if (PlaneCount)
  {
    size_t v9 = 0;
    memset(v15, 0, sizeof(v15));
    do
    {
      v15[v9] = CVPixelBufferGetBaseAddressOfPlane(a1, v9);
      v16[v9] = CVPixelBufferGetBytesPerRowOfPlane(a1, v9);
      ++v9;
    }
    while (PlaneCount != v9);
    size_t result = v16[0];
    BaseAddress = (char *)v15[0];
  }
  else
  {
    BaseAddress = (char *)CVPixelBufferGetBaseAddress(a1);
    size_t result = CVPixelBufferGetBytesPerRow(a1);
  }
  size_t v12 = v17[0] | (result << 32);
  CFNumberRef v13 = &BaseAddress[*(_DWORD *)a2 * v17[0] + *(_DWORD *)(a2 + 4) * result];
  uint64_t v14 = *(void *)(a2 + 8);
  *a3 = 0;
  a3[1] = v14;
  a3[2] = v12;
  a3[3] = v13;
  return result;
}

size_t cva::imageViewFromPixelBuffer<cva::Matrix<unsigned char,4u,1u,false>>@<X0>(__CVBuffer *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  cva::formatDescription(PixelFormatType, (uint64_t)v17, v7);
  uint64_t PlaneCount = CVPixelBufferGetPlaneCount(a1);
  if (PlaneCount)
  {
    size_t v9 = 0;
    memset(v15, 0, sizeof(v15));
    do
    {
      v15[v9] = CVPixelBufferGetBaseAddressOfPlane(a1, v9);
      v16[v9] = CVPixelBufferGetBytesPerRowOfPlane(a1, v9);
      ++v9;
    }
    while (PlaneCount != v9);
    size_t result = v16[0];
    BaseAddress = (char *)v15[0];
  }
  else
  {
    BaseAddress = (char *)CVPixelBufferGetBaseAddress(a1);
    size_t result = CVPixelBufferGetBytesPerRow(a1);
  }
  size_t v12 = v17[0] | (result << 32);
  CFNumberRef v13 = &BaseAddress[*(_DWORD *)a2 * v17[0] + *(_DWORD *)(a2 + 4) * result];
  uint64_t v14 = *(void *)(a2 + 8);
  *a3 = 0;
  a3[1] = v14;
  a3[2] = v12;
  a3[3] = v13;
  return result;
}

uint64_t cva::createCVPixelBufferFromImageNoCopy<unsigned char>(uint64_t a1, CVPixelBufferRef *a2)
{
  return CVPixelBufferCreateWithBytes((CFAllocatorRef)*MEMORY[0x263EFFB08], *(unsigned int *)(a1 + 8), *(unsigned int *)(a1 + 12), 0x4C303038u, *(void **)(a1 + 24), *(unsigned int *)(a1 + 20), 0, 0, 0, a2);
}

uint64_t cva::getPixelBufferType()
{
  return 1278226488;
}

{
  return 1647392359;
}

{
  return 1278226534;
}

{
  return 24;
}

{
  return 32;
}

uint64_t cva::createCVPixelBufferFromImageNoCopy<unsigned short>(uint64_t a1, CVPixelBufferRef *a2)
{
  return CVPixelBufferCreateWithBytes((CFAllocatorRef)*MEMORY[0x263EFFB08], *(unsigned int *)(a1 + 8), *(unsigned int *)(a1 + 12), 0x62313667u, *(void **)(a1 + 24), *(unsigned int *)(a1 + 20), 0, 0, 0, a2);
}

uint64_t cva::createCVPixelBufferFromImageNoCopy<float>(uint64_t a1, CVPixelBufferRef *a2)
{
  return CVPixelBufferCreateWithBytes((CFAllocatorRef)*MEMORY[0x263EFFB08], *(unsigned int *)(a1 + 8), *(unsigned int *)(a1 + 12), 0x4C303066u, *(void **)(a1 + 24), *(unsigned int *)(a1 + 20), 0, 0, 0, a2);
}

uint64_t cva::createCVPixelBufferFromImageNoCopy<cva::Matrix<unsigned char,3u,1u,false>>(uint64_t a1, CVPixelBufferRef *a2)
{
  return CVPixelBufferCreateWithBytes((CFAllocatorRef)*MEMORY[0x263EFFB08], *(unsigned int *)(a1 + 8), *(unsigned int *)(a1 + 12), 0x18u, *(void **)(a1 + 24), *(unsigned int *)(a1 + 20), 0, 0, 0, a2);
}

uint64_t cva::createCVPixelBufferFromImageNoCopy<cva::Matrix<unsigned char,4u,1u,false>>(uint64_t a1, CVPixelBufferRef *a2)
{
  return CVPixelBufferCreateWithBytes((CFAllocatorRef)*MEMORY[0x263EFFB08], *(unsigned int *)(a1 + 8), *(unsigned int *)(a1 + 12), 0x20u, *(void **)(a1 + 24), *(unsigned int *)(a1 + 20), 0, 0, 0, a2);
}

uint64_t cva::createCVPixelBufferFromImageCopy<unsigned char>(uint64_t a1, CVPixelBufferRef *pixelBufferOut)
{
  uint64_t result = CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], *(unsigned int *)(a1 + 8), *(unsigned int *)(a1 + 12), 0x4C303038u, 0, pixelBufferOut);
  if (!result)
  {
    CVPixelBufferLockBaseAddress(*pixelBufferOut, 0);
    BaseAddress = (char *)CVPixelBufferGetBaseAddress(*pixelBufferOut);
    size_t BytesPerRow = CVPixelBufferGetBytesPerRow(*pixelBufferOut);
    if (*(_DWORD *)(a1 + 12))
    {
      size_t v7 = BytesPerRow;
      unsigned int v8 = 0;
      do
      {
        memcpy(BaseAddress, (const void *)(*(void *)(a1 + 24) + *(void *)a1 + *(_DWORD *)(a1 + 20) * v8), *(unsigned int *)(a1 + 8));
        BaseAddress += v7;
        ++v8;
      }
      while (v8 < *(_DWORD *)(a1 + 12));
    }
    CVPixelBufferUnlockBaseAddress(*pixelBufferOut, 0);
    return 0;
  }
  return result;
}

uint64_t cva::createCVPixelBufferFromImageCopy<unsigned short>(uint64_t a1, CVPixelBufferRef *pixelBufferOut)
{
  uint64_t result = CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], *(unsigned int *)(a1 + 8), *(unsigned int *)(a1 + 12), 0x62313667u, 0, pixelBufferOut);
  if (!result)
  {
    CVPixelBufferLockBaseAddress(*pixelBufferOut, 0);
    BaseAddress = (char *)CVPixelBufferGetBaseAddress(*pixelBufferOut);
    size_t BytesPerRow = CVPixelBufferGetBytesPerRow(*pixelBufferOut);
    if (*(_DWORD *)(a1 + 12))
    {
      size_t v7 = BytesPerRow;
      unsigned int v8 = 0;
      do
      {
        memcpy(BaseAddress, (const void *)(*(void *)(a1 + 24) + *(void *)a1 + *(_DWORD *)(a1 + 20) * v8), 2 * *(unsigned int *)(a1 + 8));
        BaseAddress += v7;
        ++v8;
      }
      while (v8 < *(_DWORD *)(a1 + 12));
    }
    CVPixelBufferUnlockBaseAddress(*pixelBufferOut, 0);
    return 0;
  }
  return result;
}

uint64_t cva::createCVPixelBufferFromImageCopy<float>(uint64_t a1, CVPixelBufferRef *pixelBufferOut)
{
  uint64_t result = CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], *(unsigned int *)(a1 + 8), *(unsigned int *)(a1 + 12), 0x4C303066u, 0, pixelBufferOut);
  if (!result)
  {
    CVPixelBufferLockBaseAddress(*pixelBufferOut, 0);
    BaseAddress = (char *)CVPixelBufferGetBaseAddress(*pixelBufferOut);
    size_t BytesPerRow = CVPixelBufferGetBytesPerRow(*pixelBufferOut);
    if (*(_DWORD *)(a1 + 12))
    {
      size_t v7 = BytesPerRow;
      unsigned int v8 = 0;
      do
      {
        memcpy(BaseAddress, (const void *)(*(void *)(a1 + 24) + *(void *)a1 + *(_DWORD *)(a1 + 20) * v8), 4 * *(unsigned int *)(a1 + 8));
        BaseAddress += v7;
        ++v8;
      }
      while (v8 < *(_DWORD *)(a1 + 12));
    }
    CVPixelBufferUnlockBaseAddress(*pixelBufferOut, 0);
    return 0;
  }
  return result;
}

uint64_t cva::createCVPixelBufferFromImageCopy<cva::Matrix<unsigned char,3u,1u,false>>(uint64_t a1, CVPixelBufferRef *pixelBufferOut)
{
  uint64_t result = CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], *(unsigned int *)(a1 + 8), *(unsigned int *)(a1 + 12), 0x18u, 0, pixelBufferOut);
  if (!result)
  {
    CVPixelBufferLockBaseAddress(*pixelBufferOut, 0);
    BaseAddress = (char *)CVPixelBufferGetBaseAddress(*pixelBufferOut);
    size_t BytesPerRow = CVPixelBufferGetBytesPerRow(*pixelBufferOut);
    if (*(_DWORD *)(a1 + 12))
    {
      size_t v7 = BytesPerRow;
      unsigned int v8 = 0;
      do
      {
        memcpy(BaseAddress, (const void *)(*(void *)(a1 + 24) + *(void *)a1 + *(_DWORD *)(a1 + 20) * v8), 3 * *(unsigned int *)(a1 + 8));
        BaseAddress += v7;
        ++v8;
      }
      while (v8 < *(_DWORD *)(a1 + 12));
    }
    CVPixelBufferUnlockBaseAddress(*pixelBufferOut, 0);
    return 0;
  }
  return result;
}

uint64_t cva::createCVPixelBufferFromImageCopy<cva::Matrix<unsigned char,4u,1u,false>>(uint64_t a1, CVPixelBufferRef *pixelBufferOut)
{
  uint64_t result = CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], *(unsigned int *)(a1 + 8), *(unsigned int *)(a1 + 12), 0x20u, 0, pixelBufferOut);
  if (!result)
  {
    CVPixelBufferLockBaseAddress(*pixelBufferOut, 0);
    BaseAddress = (char *)CVPixelBufferGetBaseAddress(*pixelBufferOut);
    size_t BytesPerRow = CVPixelBufferGetBytesPerRow(*pixelBufferOut);
    if (*(_DWORD *)(a1 + 12))
    {
      size_t v7 = BytesPerRow;
      unsigned int v8 = 0;
      do
      {
        memcpy(BaseAddress, (const void *)(*(void *)(a1 + 24) + *(void *)a1 + *(_DWORD *)(a1 + 20) * v8), 4 * *(unsigned int *)(a1 + 8));
        BaseAddress += v7;
        ++v8;
      }
      while (v8 < *(_DWORD *)(a1 + 12));
    }
    CVPixelBufferUnlockBaseAddress(*pixelBufferOut, 0);
    return 0;
  }
  return result;
}

uint64_t cva::pixelBufferConvertYCbCrToARGB(__CVBuffer *a1, uint64_t a2, int a3)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  if (a1)
  {
    signed int PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
    unsigned int Width = CVPixelBufferGetWidth(a1);
    unsigned int Height = CVPixelBufferGetHeight(a1);
    unsigned int v9 = Height;
    if (*(_DWORD *)(a2 + 8) >= Width && *(_DWORD *)(a2 + 12) >= Height)
    {
      size_t v12 = (const vImage_YpCbCrToARGBMatrix **)MEMORY[0x263EFAA38];
      if (!a3) {
        size_t v12 = (const vImage_YpCbCrToARGBMatrix **)MEMORY[0x263EFAA30];
      }
      CFNumberRef v13 = *v12;
      *(_DWORD *)permuteMap = 50462976;
      uint64_t v11 = 4294960636;
      if (PixelFormatType <= 875704437)
      {
        if (PixelFormatType == 846624121)
        {
          vImage_YpCbCrPixelRange pixelRange = *(vImage_YpCbCrPixelRange *)ymmword_215446000;
          if (!vImageConvert_YpCbCrToARGB_GenerateConversion(v13, &pixelRange, &outInfo, kvImage422CbYpCrYp8, kvImageARGB8888, 0))
          {
            srcYp.data = CVPixelBufferGetBaseAddress(a1);
            srcYp.height = v9;
            srcYp.width = Width;
            srcYp.rowBytes = CVPixelBufferGetBytesPerRow(a1);
            srcCbCr.data = *(void **)(a2 + 24);
            srcCbCr.height = v9;
            size_t v21 = *(unsigned int *)(a2 + 20);
            srcCbCr.width = Width;
            srcCbCr.rowBytes = v21;
            if (srcYp.data)
            {
              if (!vImageConvert_422CbYpCrYp8ToARGB8888(&srcYp, &srcCbCr, &outInfo, permuteMap, 0xFFu, 0)) {
                return 0;
              }
            }
          }
          return 4294960636;
        }
        if (PixelFormatType != 875704422) {
          return v11;
        }
        uint64_t v15 = &xmmword_215446020;
      }
      else
      {
        if (PixelFormatType != 875704438)
        {
          if (PixelFormatType == 2037741158)
          {
            uint64_t v14 = &xmmword_215446020;
          }
          else
          {
            if (PixelFormatType != 2037741171) {
              return v11;
            }
            uint64_t v14 = (long long *)ymmword_215446000;
          }
          long long v18 = v14[1];
          *(_OWORD *)&pixelRange.Yp_bias = *v14;
          *(_OWORD *)&pixelRange.YpMax = v18;
          if (!vImageConvert_YpCbCrToARGB_GenerateConversion(v13, &pixelRange, &outInfo, kvImage422YpCbYpCr8, kvImageARGB8888, 0))
          {
            srcYp.data = CVPixelBufferGetBaseAddress(a1);
            srcYp.height = v9;
            srcYp.width = Width;
            srcYp.rowBytes = CVPixelBufferGetBytesPerRow(a1);
            srcCbCr.data = *(void **)(a2 + 24);
            srcCbCr.height = v9;
            size_t v19 = *(unsigned int *)(a2 + 20);
            srcCbCr.width = Width;
            srcCbCr.rowBytes = v19;
            if (srcYp.data)
            {
              if (!vImageConvert_422YpCbYpCr8ToARGB8888(&srcYp, &srcCbCr, &outInfo, permuteMap, 0xFFu, 0)) {
                return 0;
              }
            }
          }
          return 4294960636;
        }
        uint64_t v15 = (long long *)ymmword_215446000;
      }
      long long v16 = v15[1];
      *(_OWORD *)&pixelRange.Yp_bias = *v15;
      *(_OWORD *)&pixelRange.YpMax = v16;
      if (!vImageConvert_YpCbCrToARGB_GenerateConversion(v13, &pixelRange, &outInfo, kvImage420Yp8_CbCr8, kvImageARGB8888, 0))
      {
        srcYp.data = CVPixelBufferGetBaseAddressOfPlane(a1, 0);
        srcYp.height = v9;
        srcYp.width = Width;
        srcYp.rowBytes = CVPixelBufferGetBytesPerRowOfPlane(a1, 0);
        srcCbCr.data = CVPixelBufferGetBaseAddressOfPlane(a1, 1uLL);
        srcCbCr.height = v9;
        srcCbCr.width = Width;
        srcCbCr.rowBytes = CVPixelBufferGetBytesPerRowOfPlane(a1, 1uLL);
        v22.data = *(void **)(a2 + 24);
        v22.height = v9;
        size_t v17 = *(unsigned int *)(a2 + 20);
        v22.width = Width;
        v22.rowBytes = v17;
        if (srcYp.data)
        {
          if (!vImageConvert_420Yp8_CbCr8ToARGB8888(&srcYp, &srcCbCr, &v22, &outInfo, permuteMap, 0xFFu, 0)) {
            return 0;
          }
        }
      }
      return 4294960636;
    }
  }
  return 4294960635;
}

uint64_t cva::pixelBufferConvertARGBToYpCbCr(uint64_t a1, CVPixelBufferRef pixelBuffer, int a3)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  if (!pixelBuffer) {
    return 4294960635;
  }
  signed int PixelFormatType = CVPixelBufferGetPixelFormatType(pixelBuffer);
  unsigned int Width = CVPixelBufferGetWidth(pixelBuffer);
  unsigned int Height = CVPixelBufferGetHeight(pixelBuffer);
  unsigned int v9 = Height;
  if (*(_DWORD *)(a1 + 8) > Width || *(_DWORD *)(a1 + 12) > Height) {
    return 4294960635;
  }
  size_t v12 = (const vImage_ARGBToYpCbCrMatrix **)MEMORY[0x263EFAA20];
  if (!a3) {
    size_t v12 = (const vImage_ARGBToYpCbCrMatrix **)MEMORY[0x263EFAA18];
  }
  CFNumberRef v13 = *v12;
  *(_DWORD *)permuteMap = 50462976;
  uint64_t v11 = 4294960636;
  if (PixelFormatType > 2037741157)
  {
    if (PixelFormatType == 2037741158)
    {
      uint64_t v15 = &xmmword_215446020;
    }
    else
    {
      if (PixelFormatType != 2037741171) {
        return v11;
      }
      uint64_t v15 = &xmmword_215446000;
    }
    long long v18 = v15[1];
    *(_OWORD *)&pixelRange.Yp_bias = *v15;
    *(_OWORD *)&pixelRange.YpMax = v18;
    if (!vImageConvert_ARGBToYpCbCr_GenerateConversion(v13, &pixelRange, &outInfo, kvImageARGB8888, kvImage422YpCbYpCr8, 0))
    {
      destYp.data = CVPixelBufferGetBaseAddress(pixelBuffer);
      destYp.height = v9;
      destYp.width = Width;
      destYp.rowBytes = CVPixelBufferGetBytesPerRow(pixelBuffer);
      destCbCr.data = *(void **)(a1 + 24);
      destCbCr.height = v9;
      size_t v20 = *(unsigned int *)(a1 + 20);
      destCbCr.width = Width;
      destCbCr.rowBytes = v20;
      if (destYp.data)
      {
        if (!vImageConvert_ARGB8888To422YpCbYpCr8(&destCbCr, &destYp, &outInfo, permuteMap, 0)) {
          return 0;
        }
      }
    }
    return 4294960636;
  }
  if (PixelFormatType == 875704422)
  {
    uint64_t v14 = &xmmword_215446020;
    goto LABEL_18;
  }
  if (PixelFormatType == 875704438)
  {
    uint64_t v14 = &xmmword_215446000;
LABEL_18:
    long long v16 = v14[1];
    *(_OWORD *)&pixelRange.Yp_bias = *v14;
    *(_OWORD *)&pixelRange.YpMax = v16;
    if (!vImageConvert_ARGBToYpCbCr_GenerateConversion(v13, &pixelRange, &outInfo, kvImageARGB8888, kvImage420Yp8_CbCr8, 0))
    {
      destYp.data = CVPixelBufferGetBaseAddressOfPlane(pixelBuffer, 0);
      destYp.height = v9;
      destYp.width = Width;
      destYp.rowBytes = CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, 0);
      destCbCr.data = CVPixelBufferGetBaseAddressOfPlane(pixelBuffer, 1uLL);
      destCbCr.height = v9;
      destCbCr.width = Width;
      destCbCr.rowBytes = CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, 1uLL);
      v21.data = *(void **)(a1 + 24);
      v21.height = v9;
      size_t v17 = *(unsigned int *)(a1 + 20);
      v21.width = Width;
      v21.rowBytes = v17;
      if (destYp.data)
      {
        if (!vImageConvert_ARGB8888To420Yp8_CbCr8(&v21, &destYp, &destCbCr, &outInfo, permuteMap, 0)) {
          return 0;
        }
      }
    }
    return 4294960636;
  }
  return v11;
}

void cva::pixelBufferConvertYCbCrToARGB(cva *this, __CVBuffer *a2, __CVBuffer *a3)
{
}

__CFDictionary *cva::createAttributeDictionary(cva *this, int a2, int a3, int a4, int a5, int a6, char a7, int a8, BOOL a9)
{
  int v32 = a2;
  int valuePtr = (int)this;
  int v30 = a4;
  int v31 = a3;
  int v28 = a6;
  int v29 = a5;
  CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  if (Mutable)
  {
    CFNumberRef v13 = CFNumberCreate(v11, kCFNumberIntType, &valuePtr);
    if (!v13) {
      goto LABEL_13;
    }
    CFNumberRef v14 = v13;
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x263F04240], v13);
    CFRelease(v14);
    CFNumberRef v15 = CFNumberCreate(v11, kCFNumberIntType, &v32);
    if (!v15) {
      goto LABEL_13;
    }
    CFNumberRef v16 = v15;
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x263F04118], v15);
    CFRelease(v16);
    CFNumberRef v17 = CFNumberCreate(v11, kCFNumberIntType, &v31);
    if (!v17) {
      goto LABEL_13;
    }
    CFNumberRef v18 = v17;
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x263F04180], v17);
    CFRelease(v18);
    CFNumberRef v19 = CFNumberCreate(v11, kCFNumberIntType, &v30);
    if (!v19) {
      goto LABEL_13;
    }
    CFNumberRef v20 = v19;
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x263F04078], v19);
    CFRelease(v20);
    CFNumberRef v21 = CFNumberCreate(v11, kCFNumberIntType, &v29);
    if (!v21) {
      goto LABEL_13;
    }
    CFNumberRef v22 = v21;
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x263F04198], v21);
    CFRelease(v22);
    CFNumberRef v23 = CFDictionaryCreateMutable(v11, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    if (v23)
    {
      int v24 = v23;
      uint64_t v25 = (const void *)*MEMORY[0x263EFFB40];
      CFDictionarySetValue(v23, (const void *)*MEMORY[0x263F0EE10], (const void *)*MEMORY[0x263EFFB40]);
      if ((a7 & 1) == 0) {
        CFDictionarySetValue(v24, (const void *)*MEMORY[0x263F0EF30], (const void *)*MEMORY[0x263EFFB38]);
      }
      if (a8) {
        CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x263F04158], v25);
      }
      CFNumberRef v26 = CFNumberCreate(v11, kCFNumberIntType, &v28);
      CFDictionarySetValue(v24, (const void *)*MEMORY[0x263F0ED58], v26);
      CFRelease(v26);
      CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x263F04130], v24);
    }
    else
    {
LABEL_13:
      int v24 = Mutable;
      Mutable = 0;
    }
    CFRelease(v24);
  }
  return Mutable;
}

uint64_t cva::pixelBufferPoolCreate(cva *this, int a2, int a3, CVPixelBufferPoolRef *a4, __CVPixelBufferPool **a5)
{
  AttributeDictionary = cva::createAttributeDictionary(this, a2, a3, 16, 16, 0, 1, 0, v10);
  if (AttributeDictionary)
  {
    size_t v7 = AttributeDictionary;
    uint64_t v8 = CVPixelBufferPoolCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, AttributeDictionary, a4);
    CFRelease(v7);
    if (!v8) {
      return v8;
    }
  }
  else
  {
    uint64_t v8 = 4294960636;
  }
  *a4 = 0;
  return v8;
}

uint64_t cva::pixelBufferCreate(cva *this, unsigned int a2, OSType a3, CVPixelBufferRef *a4, __CVBuffer **a5, int a6, int a7, char a8, BOOL a9, BOOL a10)
{
  unsigned int v13 = this;
  AttributeDictionary = cva::createAttributeDictionary(this, a2, a3, (int)a5, a6, a7, a8, a9, v18);
  if (AttributeDictionary)
  {
    CFNumberRef v15 = AttributeDictionary;
    uint64_t v16 = CVPixelBufferCreate(0, v13, a2, a3, AttributeDictionary, a4);
    CFRelease(v15);
    if (!v16) {
      return v16;
    }
  }
  else
  {
    uint64_t v16 = 4294960636;
  }
  *a4 = 0;
  return v16;
}

void cva::setNumberValue(cva *this, __CFDictionary *a2, const __CFString *a3)
{
  int valuePtr = (int)a3;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFDictionarySetValue(this, a2, v5);
  CFRelease(v5);
}

void cva::setDataValue(cva *this, __CFDictionary *a2, const __CFString *a3, UInt8 *bytes, const unsigned __int8 *a5)
{
  CFDataRef v7 = CFDataCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], bytes, (CFIndex)a3);
  CFDictionarySetValue(this, a2, v7);
  CFRelease(v7);
}

uint64_t sub_2153C3D60()
{
  return 0;
}

BOOL cva::experimental::ResizeStrategyLanczos<unsigned char,true>::Resize(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3 = *(void **)(a1 + 8);
  CFDictionaryRef v4 = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a2 + 20);
  v9.data = *(void **)(a3 + 24);
  uint64_t v7 = *(void *)(a3 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v9.height = vextq_s8(v6, v6, 8uLL);
  v9.rowBytes = *(unsigned int *)(a3 + 20);
  src.data = v4;
  return vImageScale_Planar8(&src, &v9, v3, 0x28u) >= 0;
}

void cva::experimental::ResizeStrategyLanczos<unsigned char,true>::Setup(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFDictionaryRef v4 = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a2 + 20);
  v33.data = *(void **)(a3 + 24);
  uint64_t v7 = *(void *)(a3 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v33.height = vextq_s8(v6, v6, 8uLL);
  v33.rowBytes = *(unsigned int *)(a3 + 20);
  src.data = v4;
  unint64_t v8 = vImageScale_Planar8(&src, &v33, 0, 0xA8u);
  if ((v8 & 0x8000000000000000) == 0)
  {
    unint64_t v9 = v8;
    CFAllocatorRef v11 = *(char **)(a1 + 8);
    BOOL v10 = *(char **)(a1 + 16);
    unint64_t v12 = v10 - v11;
    size_t v13 = v8 - (v10 - v11);
    if (v8 > v10 - v11)
    {
      uint64_t v14 = *(void *)(a1 + 24);
      if (v14 - (uint64_t)v10 >= v13)
      {
        bzero(*(void **)(a1 + 16), v13);
        *(void *)(a1 + 16) = &v10[v13];
        return;
      }
      unint64_t v15 = v14 - (void)v11;
      uint64_t v16 = 2 * v15;
      if (2 * v15 <= v8) {
        uint64_t v16 = v8;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v17 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v17 = v16;
      }
      BOOL v18 = (char *)operator new(v17);
      CFNumberRef v19 = &v18[v12];
      CFNumberRef v20 = &v18[v17];
      CFNumberRef v21 = &v18[v9];
      bzero(&v18[v12], v13);
      if (v10 == v11) {
        goto LABEL_29;
      }
      if (v12 < 8 || (unint64_t)(v11 - v18) < 0x20) {
        goto LABEL_26;
      }
      if (v12 >= 0x20)
      {
        unint64_t v22 = v12 & 0xFFFFFFFFFFFFFFE0;
        CFNumberRef v23 = v10 - 16;
        int v24 = &v18[v10 - 16 - v11];
        unint64_t v25 = v12 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v26 = *(_OWORD *)v23;
          *((_OWORD *)v24 - 1) = *((_OWORD *)v23 - 1);
          *(_OWORD *)int v24 = v26;
          v24 -= 32;
          v23 -= 32;
          v25 -= 32;
        }
        while (v25);
        if (v12 == v22) {
          goto LABEL_28;
        }
        if ((v12 & 0x18) == 0)
        {
          v19 -= v22;
          v10 -= v22;
          goto LABEL_26;
        }
      }
      else
      {
        unint64_t v22 = 0;
      }
      unint64_t v27 = v22 - (v12 & 0xFFFFFFFFFFFFFFF8);
      int v28 = &v10[-v22 - 8];
      int v29 = (char *)(v28 - v11);
      do
      {
        uint64_t v30 = *(void *)v28;
        v28 -= 8;
        *(void *)&v29[(void)v18] = v30;
        v29 -= 8;
        v27 += 8;
      }
      while (v27);
      if (v12 == (v12 & 0xFFFFFFFFFFFFFFF8)) {
        goto LABEL_28;
      }
      v19 -= v12 & 0xFFFFFFFFFFFFFFF8;
      v10 -= v12 & 0xFFFFFFFFFFFFFFF8;
LABEL_26:
      int v31 = v19 - 1;
      do
      {
        char v32 = *--v10;
        *v31-- = v32;
      }
      while (v10 != v11);
LABEL_28:
      BOOL v10 = v11;
      CFNumberRef v19 = v18;
LABEL_29:
      *(void *)(a1 + 8) = v19;
      *(void *)(a1 + 16) = v21;
      *(void *)(a1 + 24) = v20;
      if (v10) {
        operator delete(v10);
      }
      return;
    }
    if (v8 < v10 - v11) {
      *(void *)(a1 + 16) = &v11[v8];
    }
  }
}

void sub_2153C3FF8(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2166B9890);
}

uint64_t sub_2153C404C(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
  return a1;
}

BOOL cva::experimental::ResizeStrategyLanczos<unsigned char,false>::Resize(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3 = *(void **)(a1 + 8);
  CFDictionaryRef v4 = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a2 + 20);
  v9.data = *(void **)(a3 + 24);
  uint64_t v7 = *(void *)(a3 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v9.height = vextq_s8(v6, v6, 8uLL);
  v9.rowBytes = *(unsigned int *)(a3 + 20);
  src.data = v4;
  return vImageScale_Planar8(&src, &v9, v3, 8u) >= 0;
}

void cva::experimental::ResizeStrategyLanczos<unsigned char,false>::Setup(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFDictionaryRef v4 = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a2 + 20);
  v33.data = *(void **)(a3 + 24);
  uint64_t v7 = *(void *)(a3 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v33.height = vextq_s8(v6, v6, 8uLL);
  v33.rowBytes = *(unsigned int *)(a3 + 20);
  src.data = v4;
  unint64_t v8 = vImageScale_Planar8(&src, &v33, 0, 0x88u);
  if ((v8 & 0x8000000000000000) == 0)
  {
    unint64_t v9 = v8;
    CFAllocatorRef v11 = *(char **)(a1 + 8);
    BOOL v10 = *(char **)(a1 + 16);
    unint64_t v12 = v10 - v11;
    size_t v13 = v8 - (v10 - v11);
    if (v8 > v10 - v11)
    {
      uint64_t v14 = *(void *)(a1 + 24);
      if (v14 - (uint64_t)v10 >= v13)
      {
        bzero(*(void **)(a1 + 16), v13);
        *(void *)(a1 + 16) = &v10[v13];
        return;
      }
      unint64_t v15 = v14 - (void)v11;
      uint64_t v16 = 2 * v15;
      if (2 * v15 <= v8) {
        uint64_t v16 = v8;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v17 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v17 = v16;
      }
      BOOL v18 = (char *)operator new(v17);
      CFNumberRef v19 = &v18[v12];
      CFNumberRef v20 = &v18[v17];
      CFNumberRef v21 = &v18[v9];
      bzero(&v18[v12], v13);
      if (v10 == v11) {
        goto LABEL_29;
      }
      if (v12 < 8 || (unint64_t)(v11 - v18) < 0x20) {
        goto LABEL_26;
      }
      if (v12 >= 0x20)
      {
        unint64_t v22 = v12 & 0xFFFFFFFFFFFFFFE0;
        CFNumberRef v23 = v10 - 16;
        int v24 = &v18[v10 - 16 - v11];
        unint64_t v25 = v12 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v26 = *(_OWORD *)v23;
          *((_OWORD *)v24 - 1) = *((_OWORD *)v23 - 1);
          *(_OWORD *)int v24 = v26;
          v24 -= 32;
          v23 -= 32;
          v25 -= 32;
        }
        while (v25);
        if (v12 == v22) {
          goto LABEL_28;
        }
        if ((v12 & 0x18) == 0)
        {
          v19 -= v22;
          v10 -= v22;
          goto LABEL_26;
        }
      }
      else
      {
        unint64_t v22 = 0;
      }
      unint64_t v27 = v22 - (v12 & 0xFFFFFFFFFFFFFFF8);
      int v28 = &v10[-v22 - 8];
      int v29 = (char *)(v28 - v11);
      do
      {
        uint64_t v30 = *(void *)v28;
        v28 -= 8;
        *(void *)&v29[(void)v18] = v30;
        v29 -= 8;
        v27 += 8;
      }
      while (v27);
      if (v12 == (v12 & 0xFFFFFFFFFFFFFFF8)) {
        goto LABEL_28;
      }
      v19 -= v12 & 0xFFFFFFFFFFFFFFF8;
      v10 -= v12 & 0xFFFFFFFFFFFFFFF8;
LABEL_26:
      int v31 = v19 - 1;
      do
      {
        char v32 = *--v10;
        *v31-- = v32;
      }
      while (v10 != v11);
LABEL_28:
      BOOL v10 = v11;
      CFNumberRef v19 = v18;
LABEL_29:
      *(void *)(a1 + 8) = v19;
      *(void *)(a1 + 16) = v21;
      *(void *)(a1 + 24) = v20;
      if (v10) {
        operator delete(v10);
      }
      return;
    }
    if (v8 < v10 - v11) {
      *(void *)(a1 + 16) = &v11[v8];
    }
  }
}

void sub_2153C4310(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2166B9890);
}

uint64_t sub_2153C4364(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t sub_2153C4398()
{
  return 0;
}

BOOL cva::experimental::ResizeStrategyLanczos<unsigned short,true>::Resize(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3 = *(void **)(a1 + 8);
  CFDictionaryRef v4 = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a2 + 20);
  v9.data = *(void **)(a3 + 24);
  uint64_t v7 = *(void *)(a3 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v9.height = vextq_s8(v6, v6, 8uLL);
  v9.rowBytes = *(unsigned int *)(a3 + 20);
  src.data = v4;
  return vImageScale_Planar16U(&src, &v9, v3, 0x28u) >= 0;
}

void cva::experimental::ResizeStrategyLanczos<unsigned short,true>::Setup(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFDictionaryRef v4 = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a2 + 20);
  v33.data = *(void **)(a3 + 24);
  uint64_t v7 = *(void *)(a3 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v33.height = vextq_s8(v6, v6, 8uLL);
  v33.rowBytes = *(unsigned int *)(a3 + 20);
  src.data = v4;
  unint64_t v8 = vImageScale_Planar16U(&src, &v33, 0, 0xA8u);
  if ((v8 & 0x8000000000000000) == 0)
  {
    unint64_t v9 = v8;
    CFAllocatorRef v11 = *(char **)(a1 + 8);
    BOOL v10 = *(char **)(a1 + 16);
    unint64_t v12 = v10 - v11;
    size_t v13 = v8 - (v10 - v11);
    if (v8 > v10 - v11)
    {
      uint64_t v14 = *(void *)(a1 + 24);
      if (v14 - (uint64_t)v10 >= v13)
      {
        bzero(*(void **)(a1 + 16), v13);
        *(void *)(a1 + 16) = &v10[v13];
        return;
      }
      unint64_t v15 = v14 - (void)v11;
      uint64_t v16 = 2 * v15;
      if (2 * v15 <= v8) {
        uint64_t v16 = v8;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v17 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v17 = v16;
      }
      BOOL v18 = (char *)operator new(v17);
      CFNumberRef v19 = &v18[v12];
      CFNumberRef v20 = &v18[v17];
      CFNumberRef v21 = &v18[v9];
      bzero(&v18[v12], v13);
      if (v10 == v11) {
        goto LABEL_29;
      }
      if (v12 < 8 || (unint64_t)(v11 - v18) < 0x20) {
        goto LABEL_26;
      }
      if (v12 >= 0x20)
      {
        unint64_t v22 = v12 & 0xFFFFFFFFFFFFFFE0;
        CFNumberRef v23 = v10 - 16;
        int v24 = &v18[v10 - 16 - v11];
        unint64_t v25 = v12 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v26 = *(_OWORD *)v23;
          *((_OWORD *)v24 - 1) = *((_OWORD *)v23 - 1);
          *(_OWORD *)int v24 = v26;
          v24 -= 32;
          v23 -= 32;
          v25 -= 32;
        }
        while (v25);
        if (v12 == v22) {
          goto LABEL_28;
        }
        if ((v12 & 0x18) == 0)
        {
          v19 -= v22;
          v10 -= v22;
          goto LABEL_26;
        }
      }
      else
      {
        unint64_t v22 = 0;
      }
      unint64_t v27 = v22 - (v12 & 0xFFFFFFFFFFFFFFF8);
      int v28 = &v10[-v22 - 8];
      int v29 = (char *)(v28 - v11);
      do
      {
        uint64_t v30 = *(void *)v28;
        v28 -= 8;
        *(void *)&v29[(void)v18] = v30;
        v29 -= 8;
        v27 += 8;
      }
      while (v27);
      if (v12 == (v12 & 0xFFFFFFFFFFFFFFF8)) {
        goto LABEL_28;
      }
      v19 -= v12 & 0xFFFFFFFFFFFFFFF8;
      v10 -= v12 & 0xFFFFFFFFFFFFFFF8;
LABEL_26:
      int v31 = v19 - 1;
      do
      {
        char v32 = *--v10;
        *v31-- = v32;
      }
      while (v10 != v11);
LABEL_28:
      BOOL v10 = v11;
      CFNumberRef v19 = v18;
LABEL_29:
      *(void *)(a1 + 8) = v19;
      *(void *)(a1 + 16) = v21;
      *(void *)(a1 + 24) = v20;
      if (v10) {
        operator delete(v10);
      }
      return;
    }
    if (v8 < v10 - v11) {
      *(void *)(a1 + 16) = &v11[v8];
    }
  }
}

void sub_2153C4630(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2166B9890);
}

uint64_t sub_2153C4684(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
  return a1;
}

BOOL cva::experimental::ResizeStrategyLanczos<unsigned short,false>::Resize(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3 = *(void **)(a1 + 8);
  CFDictionaryRef v4 = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a2 + 20);
  v9.data = *(void **)(a3 + 24);
  uint64_t v7 = *(void *)(a3 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v9.height = vextq_s8(v6, v6, 8uLL);
  v9.rowBytes = *(unsigned int *)(a3 + 20);
  src.data = v4;
  return vImageScale_Planar16U(&src, &v9, v3, 8u) >= 0;
}

void cva::experimental::ResizeStrategyLanczos<unsigned short,false>::Setup(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFDictionaryRef v4 = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a2 + 20);
  v33.data = *(void **)(a3 + 24);
  uint64_t v7 = *(void *)(a3 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v33.height = vextq_s8(v6, v6, 8uLL);
  v33.rowBytes = *(unsigned int *)(a3 + 20);
  src.data = v4;
  unint64_t v8 = vImageScale_Planar16U(&src, &v33, 0, 0x88u);
  if ((v8 & 0x8000000000000000) == 0)
  {
    unint64_t v9 = v8;
    CFAllocatorRef v11 = *(char **)(a1 + 8);
    BOOL v10 = *(char **)(a1 + 16);
    unint64_t v12 = v10 - v11;
    size_t v13 = v8 - (v10 - v11);
    if (v8 > v10 - v11)
    {
      uint64_t v14 = *(void *)(a1 + 24);
      if (v14 - (uint64_t)v10 >= v13)
      {
        bzero(*(void **)(a1 + 16), v13);
        *(void *)(a1 + 16) = &v10[v13];
        return;
      }
      unint64_t v15 = v14 - (void)v11;
      uint64_t v16 = 2 * v15;
      if (2 * v15 <= v8) {
        uint64_t v16 = v8;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v17 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v17 = v16;
      }
      BOOL v18 = (char *)operator new(v17);
      CFNumberRef v19 = &v18[v12];
      CFNumberRef v20 = &v18[v17];
      CFNumberRef v21 = &v18[v9];
      bzero(&v18[v12], v13);
      if (v10 == v11) {
        goto LABEL_29;
      }
      if (v12 < 8 || (unint64_t)(v11 - v18) < 0x20) {
        goto LABEL_26;
      }
      if (v12 >= 0x20)
      {
        unint64_t v22 = v12 & 0xFFFFFFFFFFFFFFE0;
        CFNumberRef v23 = v10 - 16;
        int v24 = &v18[v10 - 16 - v11];
        unint64_t v25 = v12 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v26 = *(_OWORD *)v23;
          *((_OWORD *)v24 - 1) = *((_OWORD *)v23 - 1);
          *(_OWORD *)int v24 = v26;
          v24 -= 32;
          v23 -= 32;
          v25 -= 32;
        }
        while (v25);
        if (v12 == v22) {
          goto LABEL_28;
        }
        if ((v12 & 0x18) == 0)
        {
          v19 -= v22;
          v10 -= v22;
          goto LABEL_26;
        }
      }
      else
      {
        unint64_t v22 = 0;
      }
      unint64_t v27 = v22 - (v12 & 0xFFFFFFFFFFFFFFF8);
      int v28 = &v10[-v22 - 8];
      int v29 = (char *)(v28 - v11);
      do
      {
        uint64_t v30 = *(void *)v28;
        v28 -= 8;
        *(void *)&v29[(void)v18] = v30;
        v29 -= 8;
        v27 += 8;
      }
      while (v27);
      if (v12 == (v12 & 0xFFFFFFFFFFFFFFF8)) {
        goto LABEL_28;
      }
      v19 -= v12 & 0xFFFFFFFFFFFFFFF8;
      v10 -= v12 & 0xFFFFFFFFFFFFFFF8;
LABEL_26:
      int v31 = v19 - 1;
      do
      {
        char v32 = *--v10;
        *v31-- = v32;
      }
      while (v10 != v11);
LABEL_28:
      BOOL v10 = v11;
      CFNumberRef v19 = v18;
LABEL_29:
      *(void *)(a1 + 8) = v19;
      *(void *)(a1 + 16) = v21;
      *(void *)(a1 + 24) = v20;
      if (v10) {
        operator delete(v10);
      }
      return;
    }
    if (v8 < v10 - v11) {
      *(void *)(a1 + 16) = &v11[v8];
    }
  }
}

void sub_2153C4948(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2166B9890);
}

uint64_t sub_2153C499C(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t sub_2153C49D0()
{
  return 0;
}

BOOL cva::experimental::ResizeStrategyLanczos<short,true>::Resize(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3 = *(void **)(a1 + 8);
  CFDictionaryRef v4 = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a2 + 20);
  v9.data = *(void **)(a3 + 24);
  uint64_t v7 = *(void *)(a3 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v9.height = vextq_s8(v6, v6, 8uLL);
  v9.rowBytes = *(unsigned int *)(a3 + 20);
  src.data = v4;
  return vImageScale_Planar16S(&src, &v9, v3, 0x28u) >= 0;
}

void cva::experimental::ResizeStrategyLanczos<short,true>::Setup(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFDictionaryRef v4 = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a2 + 20);
  v33.data = *(void **)(a3 + 24);
  uint64_t v7 = *(void *)(a3 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v33.height = vextq_s8(v6, v6, 8uLL);
  v33.rowBytes = *(unsigned int *)(a3 + 20);
  src.data = v4;
  unint64_t v8 = vImageScale_Planar16S(&src, &v33, 0, 0xA8u);
  if ((v8 & 0x8000000000000000) == 0)
  {
    unint64_t v9 = v8;
    CFAllocatorRef v11 = *(char **)(a1 + 8);
    BOOL v10 = *(char **)(a1 + 16);
    unint64_t v12 = v10 - v11;
    size_t v13 = v8 - (v10 - v11);
    if (v8 > v10 - v11)
    {
      uint64_t v14 = *(void *)(a1 + 24);
      if (v14 - (uint64_t)v10 >= v13)
      {
        bzero(*(void **)(a1 + 16), v13);
        *(void *)(a1 + 16) = &v10[v13];
        return;
      }
      unint64_t v15 = v14 - (void)v11;
      uint64_t v16 = 2 * v15;
      if (2 * v15 <= v8) {
        uint64_t v16 = v8;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v17 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v17 = v16;
      }
      BOOL v18 = (char *)operator new(v17);
      CFNumberRef v19 = &v18[v12];
      CFNumberRef v20 = &v18[v17];
      CFNumberRef v21 = &v18[v9];
      bzero(&v18[v12], v13);
      if (v10 == v11) {
        goto LABEL_29;
      }
      if (v12 < 8 || (unint64_t)(v11 - v18) < 0x20) {
        goto LABEL_26;
      }
      if (v12 >= 0x20)
      {
        unint64_t v22 = v12 & 0xFFFFFFFFFFFFFFE0;
        CFNumberRef v23 = v10 - 16;
        int v24 = &v18[v10 - 16 - v11];
        unint64_t v25 = v12 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v26 = *(_OWORD *)v23;
          *((_OWORD *)v24 - 1) = *((_OWORD *)v23 - 1);
          *(_OWORD *)int v24 = v26;
          v24 -= 32;
          v23 -= 32;
          v25 -= 32;
        }
        while (v25);
        if (v12 == v22) {
          goto LABEL_28;
        }
        if ((v12 & 0x18) == 0)
        {
          v19 -= v22;
          v10 -= v22;
          goto LABEL_26;
        }
      }
      else
      {
        unint64_t v22 = 0;
      }
      unint64_t v27 = v22 - (v12 & 0xFFFFFFFFFFFFFFF8);
      int v28 = &v10[-v22 - 8];
      int v29 = (char *)(v28 - v11);
      do
      {
        uint64_t v30 = *(void *)v28;
        v28 -= 8;
        *(void *)&v29[(void)v18] = v30;
        v29 -= 8;
        v27 += 8;
      }
      while (v27);
      if (v12 == (v12 & 0xFFFFFFFFFFFFFFF8)) {
        goto LABEL_28;
      }
      v19 -= v12 & 0xFFFFFFFFFFFFFFF8;
      v10 -= v12 & 0xFFFFFFFFFFFFFFF8;
LABEL_26:
      int v31 = v19 - 1;
      do
      {
        char v32 = *--v10;
        *v31-- = v32;
      }
      while (v10 != v11);
LABEL_28:
      BOOL v10 = v11;
      CFNumberRef v19 = v18;
LABEL_29:
      *(void *)(a1 + 8) = v19;
      *(void *)(a1 + 16) = v21;
      *(void *)(a1 + 24) = v20;
      if (v10) {
        operator delete(v10);
      }
      return;
    }
    if (v8 < v10 - v11) {
      *(void *)(a1 + 16) = &v11[v8];
    }
  }
}

void sub_2153C4C68(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2166B9890);
}

uint64_t sub_2153C4CBC(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
  return a1;
}

BOOL cva::experimental::ResizeStrategyLanczos<short,false>::Resize(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3 = *(void **)(a1 + 8);
  CFDictionaryRef v4 = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a2 + 20);
  v9.data = *(void **)(a3 + 24);
  uint64_t v7 = *(void *)(a3 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v9.height = vextq_s8(v6, v6, 8uLL);
  v9.rowBytes = *(unsigned int *)(a3 + 20);
  src.data = v4;
  return vImageScale_Planar16S(&src, &v9, v3, 8u) >= 0;
}

void cva::experimental::ResizeStrategyLanczos<short,false>::Setup(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFDictionaryRef v4 = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a2 + 20);
  v33.data = *(void **)(a3 + 24);
  uint64_t v7 = *(void *)(a3 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v33.height = vextq_s8(v6, v6, 8uLL);
  v33.rowBytes = *(unsigned int *)(a3 + 20);
  src.data = v4;
  unint64_t v8 = vImageScale_Planar16S(&src, &v33, 0, 0x88u);
  if ((v8 & 0x8000000000000000) == 0)
  {
    unint64_t v9 = v8;
    CFAllocatorRef v11 = *(char **)(a1 + 8);
    BOOL v10 = *(char **)(a1 + 16);
    unint64_t v12 = v10 - v11;
    size_t v13 = v8 - (v10 - v11);
    if (v8 > v10 - v11)
    {
      uint64_t v14 = *(void *)(a1 + 24);
      if (v14 - (uint64_t)v10 >= v13)
      {
        bzero(*(void **)(a1 + 16), v13);
        *(void *)(a1 + 16) = &v10[v13];
        return;
      }
      unint64_t v15 = v14 - (void)v11;
      uint64_t v16 = 2 * v15;
      if (2 * v15 <= v8) {
        uint64_t v16 = v8;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v17 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v17 = v16;
      }
      BOOL v18 = (char *)operator new(v17);
      CFNumberRef v19 = &v18[v12];
      CFNumberRef v20 = &v18[v17];
      CFNumberRef v21 = &v18[v9];
      bzero(&v18[v12], v13);
      if (v10 == v11) {
        goto LABEL_29;
      }
      if (v12 < 8 || (unint64_t)(v11 - v18) < 0x20) {
        goto LABEL_26;
      }
      if (v12 >= 0x20)
      {
        unint64_t v22 = v12 & 0xFFFFFFFFFFFFFFE0;
        CFNumberRef v23 = v10 - 16;
        int v24 = &v18[v10 - 16 - v11];
        unint64_t v25 = v12 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v26 = *(_OWORD *)v23;
          *((_OWORD *)v24 - 1) = *((_OWORD *)v23 - 1);
          *(_OWORD *)int v24 = v26;
          v24 -= 32;
          v23 -= 32;
          v25 -= 32;
        }
        while (v25);
        if (v12 == v22) {
          goto LABEL_28;
        }
        if ((v12 & 0x18) == 0)
        {
          v19 -= v22;
          v10 -= v22;
          goto LABEL_26;
        }
      }
      else
      {
        unint64_t v22 = 0;
      }
      unint64_t v27 = v22 - (v12 & 0xFFFFFFFFFFFFFFF8);
      int v28 = &v10[-v22 - 8];
      int v29 = (char *)(v28 - v11);
      do
      {
        uint64_t v30 = *(void *)v28;
        v28 -= 8;
        *(void *)&v29[(void)v18] = v30;
        v29 -= 8;
        v27 += 8;
      }
      while (v27);
      if (v12 == (v12 & 0xFFFFFFFFFFFFFFF8)) {
        goto LABEL_28;
      }
      v19 -= v12 & 0xFFFFFFFFFFFFFFF8;
      v10 -= v12 & 0xFFFFFFFFFFFFFFF8;
LABEL_26:
      int v31 = v19 - 1;
      do
      {
        char v32 = *--v10;
        *v31-- = v32;
      }
      while (v10 != v11);
LABEL_28:
      BOOL v10 = v11;
      CFNumberRef v19 = v18;
LABEL_29:
      *(void *)(a1 + 8) = v19;
      *(void *)(a1 + 16) = v21;
      *(void *)(a1 + 24) = v20;
      if (v10) {
        operator delete(v10);
      }
      return;
    }
    if (v8 < v10 - v11) {
      *(void *)(a1 + 16) = &v11[v8];
    }
  }
}

void sub_2153C4F80(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2166B9890);
}

uint64_t sub_2153C4FD4(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t sub_2153C5008()
{
  return 0;
}

BOOL cva::experimental::ResizeStrategyLanczos<float,true>::Resize(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3 = *(void **)(a1 + 8);
  CFDictionaryRef v4 = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a2 + 20);
  v9.data = *(void **)(a3 + 24);
  uint64_t v7 = *(void *)(a3 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v9.height = vextq_s8(v6, v6, 8uLL);
  v9.rowBytes = *(unsigned int *)(a3 + 20);
  src.data = v4;
  return vImageScale_PlanarF(&src, &v9, v3, 0x28u) >= 0;
}

void cva::experimental::ResizeStrategyLanczos<float,true>::Setup(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFDictionaryRef v4 = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a2 + 20);
  v33.data = *(void **)(a3 + 24);
  uint64_t v7 = *(void *)(a3 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v33.height = vextq_s8(v6, v6, 8uLL);
  v33.rowBytes = *(unsigned int *)(a3 + 20);
  src.data = v4;
  unint64_t v8 = vImageScale_PlanarF(&src, &v33, 0, 0xA8u);
  if ((v8 & 0x8000000000000000) == 0)
  {
    unint64_t v9 = v8;
    CFAllocatorRef v11 = *(char **)(a1 + 8);
    BOOL v10 = *(char **)(a1 + 16);
    unint64_t v12 = v10 - v11;
    size_t v13 = v8 - (v10 - v11);
    if (v8 > v10 - v11)
    {
      uint64_t v14 = *(void *)(a1 + 24);
      if (v14 - (uint64_t)v10 >= v13)
      {
        bzero(*(void **)(a1 + 16), v13);
        *(void *)(a1 + 16) = &v10[v13];
        return;
      }
      unint64_t v15 = v14 - (void)v11;
      uint64_t v16 = 2 * v15;
      if (2 * v15 <= v8) {
        uint64_t v16 = v8;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v17 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v17 = v16;
      }
      BOOL v18 = (char *)operator new(v17);
      CFNumberRef v19 = &v18[v12];
      CFNumberRef v20 = &v18[v17];
      CFNumberRef v21 = &v18[v9];
      bzero(&v18[v12], v13);
      if (v10 == v11) {
        goto LABEL_29;
      }
      if (v12 < 8 || (unint64_t)(v11 - v18) < 0x20) {
        goto LABEL_26;
      }
      if (v12 >= 0x20)
      {
        unint64_t v22 = v12 & 0xFFFFFFFFFFFFFFE0;
        CFNumberRef v23 = v10 - 16;
        int v24 = &v18[v10 - 16 - v11];
        unint64_t v25 = v12 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v26 = *(_OWORD *)v23;
          *((_OWORD *)v24 - 1) = *((_OWORD *)v23 - 1);
          *(_OWORD *)int v24 = v26;
          v24 -= 32;
          v23 -= 32;
          v25 -= 32;
        }
        while (v25);
        if (v12 == v22) {
          goto LABEL_28;
        }
        if ((v12 & 0x18) == 0)
        {
          v19 -= v22;
          v10 -= v22;
          goto LABEL_26;
        }
      }
      else
      {
        unint64_t v22 = 0;
      }
      unint64_t v27 = v22 - (v12 & 0xFFFFFFFFFFFFFFF8);
      int v28 = &v10[-v22 - 8];
      int v29 = (char *)(v28 - v11);
      do
      {
        uint64_t v30 = *(void *)v28;
        v28 -= 8;
        *(void *)&v29[(void)v18] = v30;
        v29 -= 8;
        v27 += 8;
      }
      while (v27);
      if (v12 == (v12 & 0xFFFFFFFFFFFFFFF8)) {
        goto LABEL_28;
      }
      v19 -= v12 & 0xFFFFFFFFFFFFFFF8;
      v10 -= v12 & 0xFFFFFFFFFFFFFFF8;
LABEL_26:
      int v31 = v19 - 1;
      do
      {
        char v32 = *--v10;
        *v31-- = v32;
      }
      while (v10 != v11);
LABEL_28:
      BOOL v10 = v11;
      CFNumberRef v19 = v18;
LABEL_29:
      *(void *)(a1 + 8) = v19;
      *(void *)(a1 + 16) = v21;
      *(void *)(a1 + 24) = v20;
      if (v10) {
        operator delete(v10);
      }
      return;
    }
    if (v8 < v10 - v11) {
      *(void *)(a1 + 16) = &v11[v8];
    }
  }
}

void sub_2153C52A0(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2166B9890);
}

uint64_t sub_2153C52F4(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
  return a1;
}

BOOL cva::experimental::ResizeStrategyLanczos<float,false>::Resize(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3 = *(void **)(a1 + 8);
  CFDictionaryRef v4 = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a2 + 20);
  v9.data = *(void **)(a3 + 24);
  uint64_t v7 = *(void *)(a3 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v9.height = vextq_s8(v6, v6, 8uLL);
  v9.rowBytes = *(unsigned int *)(a3 + 20);
  src.data = v4;
  return vImageScale_PlanarF(&src, &v9, v3, 8u) >= 0;
}

void cva::experimental::ResizeStrategyLanczos<float,false>::Setup(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFDictionaryRef v4 = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a2 + 20);
  v33.data = *(void **)(a3 + 24);
  uint64_t v7 = *(void *)(a3 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v33.height = vextq_s8(v6, v6, 8uLL);
  v33.rowBytes = *(unsigned int *)(a3 + 20);
  src.data = v4;
  unint64_t v8 = vImageScale_PlanarF(&src, &v33, 0, 0x88u);
  if ((v8 & 0x8000000000000000) == 0)
  {
    unint64_t v9 = v8;
    CFAllocatorRef v11 = *(char **)(a1 + 8);
    BOOL v10 = *(char **)(a1 + 16);
    unint64_t v12 = v10 - v11;
    size_t v13 = v8 - (v10 - v11);
    if (v8 > v10 - v11)
    {
      uint64_t v14 = *(void *)(a1 + 24);
      if (v14 - (uint64_t)v10 >= v13)
      {
        bzero(*(void **)(a1 + 16), v13);
        *(void *)(a1 + 16) = &v10[v13];
        return;
      }
      unint64_t v15 = v14 - (void)v11;
      uint64_t v16 = 2 * v15;
      if (2 * v15 <= v8) {
        uint64_t v16 = v8;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v17 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v17 = v16;
      }
      BOOL v18 = (char *)operator new(v17);
      CFNumberRef v19 = &v18[v12];
      CFNumberRef v20 = &v18[v17];
      CFNumberRef v21 = &v18[v9];
      bzero(&v18[v12], v13);
      if (v10 == v11) {
        goto LABEL_29;
      }
      if (v12 < 8 || (unint64_t)(v11 - v18) < 0x20) {
        goto LABEL_26;
      }
      if (v12 >= 0x20)
      {
        unint64_t v22 = v12 & 0xFFFFFFFFFFFFFFE0;
        CFNumberRef v23 = v10 - 16;
        int v24 = &v18[v10 - 16 - v11];
        unint64_t v25 = v12 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v26 = *(_OWORD *)v23;
          *((_OWORD *)v24 - 1) = *((_OWORD *)v23 - 1);
          *(_OWORD *)int v24 = v26;
          v24 -= 32;
          v23 -= 32;
          v25 -= 32;
        }
        while (v25);
        if (v12 == v22) {
          goto LABEL_28;
        }
        if ((v12 & 0x18) == 0)
        {
          v19 -= v22;
          v10 -= v22;
          goto LABEL_26;
        }
      }
      else
      {
        unint64_t v22 = 0;
      }
      unint64_t v27 = v22 - (v12 & 0xFFFFFFFFFFFFFFF8);
      int v28 = &v10[-v22 - 8];
      int v29 = (char *)(v28 - v11);
      do
      {
        uint64_t v30 = *(void *)v28;
        v28 -= 8;
        *(void *)&v29[(void)v18] = v30;
        v29 -= 8;
        v27 += 8;
      }
      while (v27);
      if (v12 == (v12 & 0xFFFFFFFFFFFFFFF8)) {
        goto LABEL_28;
      }
      v19 -= v12 & 0xFFFFFFFFFFFFFFF8;
      v10 -= v12 & 0xFFFFFFFFFFFFFFF8;
LABEL_26:
      int v31 = v19 - 1;
      do
      {
        char v32 = *--v10;
        *v31-- = v32;
      }
      while (v10 != v11);
LABEL_28:
      BOOL v10 = v11;
      CFNumberRef v19 = v18;
LABEL_29:
      *(void *)(a1 + 8) = v19;
      *(void *)(a1 + 16) = v21;
      *(void *)(a1 + 24) = v20;
      if (v10) {
        operator delete(v10);
      }
      return;
    }
    if (v8 < v10 - v11) {
      *(void *)(a1 + 16) = &v11[v8];
    }
  }
}

void sub_2153C55B8(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2166B9890);
}

uint64_t sub_2153C560C(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t sub_2153C5640()
{
  return 0;
}

BOOL cva::experimental::ResizeStrategyLanczos<cva::Matrix<unsigned char,4u,1u,false>,true>::Resize(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3 = *(void **)(a1 + 8);
  CFDictionaryRef v4 = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a2 + 20);
  v9.data = *(void **)(a3 + 24);
  uint64_t v7 = *(void *)(a3 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v9.height = vextq_s8(v6, v6, 8uLL);
  v9.rowBytes = *(unsigned int *)(a3 + 20);
  src.data = v4;
  return vImageScale_ARGB8888(&src, &v9, v3, 0x28u) >= 0;
}

void cva::experimental::ResizeStrategyLanczos<cva::Matrix<unsigned char,4u,1u,false>,true>::Setup(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFDictionaryRef v4 = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a2 + 20);
  v33.data = *(void **)(a3 + 24);
  uint64_t v7 = *(void *)(a3 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v33.height = vextq_s8(v6, v6, 8uLL);
  v33.rowBytes = *(unsigned int *)(a3 + 20);
  src.data = v4;
  unint64_t v8 = vImageScale_ARGB8888(&src, &v33, 0, 0xA8u);
  if ((v8 & 0x8000000000000000) == 0)
  {
    unint64_t v9 = v8;
    CFAllocatorRef v11 = *(char **)(a1 + 8);
    BOOL v10 = *(char **)(a1 + 16);
    unint64_t v12 = v10 - v11;
    size_t v13 = v8 - (v10 - v11);
    if (v8 > v10 - v11)
    {
      uint64_t v14 = *(void *)(a1 + 24);
      if (v14 - (uint64_t)v10 >= v13)
      {
        bzero(*(void **)(a1 + 16), v13);
        *(void *)(a1 + 16) = &v10[v13];
        return;
      }
      unint64_t v15 = v14 - (void)v11;
      uint64_t v16 = 2 * v15;
      if (2 * v15 <= v8) {
        uint64_t v16 = v8;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v17 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v17 = v16;
      }
      BOOL v18 = (char *)operator new(v17);
      CFNumberRef v19 = &v18[v12];
      CFNumberRef v20 = &v18[v17];
      CFNumberRef v21 = &v18[v9];
      bzero(&v18[v12], v13);
      if (v10 == v11) {
        goto LABEL_29;
      }
      if (v12 < 8 || (unint64_t)(v11 - v18) < 0x20) {
        goto LABEL_26;
      }
      if (v12 >= 0x20)
      {
        unint64_t v22 = v12 & 0xFFFFFFFFFFFFFFE0;
        CFNumberRef v23 = v10 - 16;
        int v24 = &v18[v10 - 16 - v11];
        unint64_t v25 = v12 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v26 = *(_OWORD *)v23;
          *((_OWORD *)v24 - 1) = *((_OWORD *)v23 - 1);
          *(_OWORD *)int v24 = v26;
          v24 -= 32;
          v23 -= 32;
          v25 -= 32;
        }
        while (v25);
        if (v12 == v22) {
          goto LABEL_28;
        }
        if ((v12 & 0x18) == 0)
        {
          v19 -= v22;
          v10 -= v22;
          goto LABEL_26;
        }
      }
      else
      {
        unint64_t v22 = 0;
      }
      unint64_t v27 = v22 - (v12 & 0xFFFFFFFFFFFFFFF8);
      int v28 = &v10[-v22 - 8];
      int v29 = (char *)(v28 - v11);
      do
      {
        uint64_t v30 = *(void *)v28;
        v28 -= 8;
        *(void *)&v29[(void)v18] = v30;
        v29 -= 8;
        v27 += 8;
      }
      while (v27);
      if (v12 == (v12 & 0xFFFFFFFFFFFFFFF8)) {
        goto LABEL_28;
      }
      v19 -= v12 & 0xFFFFFFFFFFFFFFF8;
      v10 -= v12 & 0xFFFFFFFFFFFFFFF8;
LABEL_26:
      int v31 = v19 - 1;
      do
      {
        char v32 = *--v10;
        *v31-- = v32;
      }
      while (v10 != v11);
LABEL_28:
      BOOL v10 = v11;
      CFNumberRef v19 = v18;
LABEL_29:
      *(void *)(a1 + 8) = v19;
      *(void *)(a1 + 16) = v21;
      *(void *)(a1 + 24) = v20;
      if (v10) {
        operator delete(v10);
      }
      return;
    }
    if (v8 < v10 - v11) {
      *(void *)(a1 + 16) = &v11[v8];
    }
  }
}

void sub_2153C58D8(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2166B9890);
}

uint64_t sub_2153C592C(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
  return a1;
}

BOOL cva::experimental::ResizeStrategyLanczos<cva::Matrix<unsigned char,4u,1u,false>,false>::Resize(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3 = *(void **)(a1 + 8);
  CFDictionaryRef v4 = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a2 + 20);
  v9.data = *(void **)(a3 + 24);
  uint64_t v7 = *(void *)(a3 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v9.height = vextq_s8(v6, v6, 8uLL);
  v9.rowBytes = *(unsigned int *)(a3 + 20);
  src.data = v4;
  return vImageScale_ARGB8888(&src, &v9, v3, 8u) >= 0;
}

void cva::experimental::ResizeStrategyLanczos<cva::Matrix<unsigned char,4u,1u,false>,false>::Setup(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFDictionaryRef v4 = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a2 + 20);
  v33.data = *(void **)(a3 + 24);
  uint64_t v7 = *(void *)(a3 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v33.height = vextq_s8(v6, v6, 8uLL);
  v33.rowBytes = *(unsigned int *)(a3 + 20);
  src.data = v4;
  unint64_t v8 = vImageScale_ARGB8888(&src, &v33, 0, 0x88u);
  if ((v8 & 0x8000000000000000) == 0)
  {
    unint64_t v9 = v8;
    CFAllocatorRef v11 = *(char **)(a1 + 8);
    BOOL v10 = *(char **)(a1 + 16);
    unint64_t v12 = v10 - v11;
    size_t v13 = v8 - (v10 - v11);
    if (v8 > v10 - v11)
    {
      uint64_t v14 = *(void *)(a1 + 24);
      if (v14 - (uint64_t)v10 >= v13)
      {
        bzero(*(void **)(a1 + 16), v13);
        *(void *)(a1 + 16) = &v10[v13];
        return;
      }
      unint64_t v15 = v14 - (void)v11;
      uint64_t v16 = 2 * v15;
      if (2 * v15 <= v8) {
        uint64_t v16 = v8;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v17 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v17 = v16;
      }
      BOOL v18 = (char *)operator new(v17);
      CFNumberRef v19 = &v18[v12];
      CFNumberRef v20 = &v18[v17];
      CFNumberRef v21 = &v18[v9];
      bzero(&v18[v12], v13);
      if (v10 == v11) {
        goto LABEL_29;
      }
      if (v12 < 8 || (unint64_t)(v11 - v18) < 0x20) {
        goto LABEL_26;
      }
      if (v12 >= 0x20)
      {
        unint64_t v22 = v12 & 0xFFFFFFFFFFFFFFE0;
        CFNumberRef v23 = v10 - 16;
        int v24 = &v18[v10 - 16 - v11];
        unint64_t v25 = v12 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v26 = *(_OWORD *)v23;
          *((_OWORD *)v24 - 1) = *((_OWORD *)v23 - 1);
          *(_OWORD *)int v24 = v26;
          v24 -= 32;
          v23 -= 32;
          v25 -= 32;
        }
        while (v25);
        if (v12 == v22) {
          goto LABEL_28;
        }
        if ((v12 & 0x18) == 0)
        {
          v19 -= v22;
          v10 -= v22;
          goto LABEL_26;
        }
      }
      else
      {
        unint64_t v22 = 0;
      }
      unint64_t v27 = v22 - (v12 & 0xFFFFFFFFFFFFFFF8);
      int v28 = &v10[-v22 - 8];
      int v29 = (char *)(v28 - v11);
      do
      {
        uint64_t v30 = *(void *)v28;
        v28 -= 8;
        *(void *)&v29[(void)v18] = v30;
        v29 -= 8;
        v27 += 8;
      }
      while (v27);
      if (v12 == (v12 & 0xFFFFFFFFFFFFFFF8)) {
        goto LABEL_28;
      }
      v19 -= v12 & 0xFFFFFFFFFFFFFFF8;
      v10 -= v12 & 0xFFFFFFFFFFFFFFF8;
LABEL_26:
      int v31 = v19 - 1;
      do
      {
        char v32 = *--v10;
        *v31-- = v32;
      }
      while (v10 != v11);
LABEL_28:
      BOOL v10 = v11;
      CFNumberRef v19 = v18;
LABEL_29:
      *(void *)(a1 + 8) = v19;
      *(void *)(a1 + 16) = v21;
      *(void *)(a1 + 24) = v20;
      if (v10) {
        operator delete(v10);
      }
      return;
    }
    if (v8 < v10 - v11) {
      *(void *)(a1 + 16) = &v11[v8];
    }
  }
}

void sub_2153C5BF0(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2166B9890);
}

uint64_t sub_2153C5C44(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t sub_2153C5C78()
{
  return 0;
}

BOOL cva::experimental::ResizeStrategyLanczos<cva::Matrix<float,4u,1u,false>,true>::Resize(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3 = *(void **)(a1 + 8);
  CFDictionaryRef v4 = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a2 + 20);
  v9.data = *(void **)(a3 + 24);
  uint64_t v7 = *(void *)(a3 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v9.height = vextq_s8(v6, v6, 8uLL);
  v9.rowBytes = *(unsigned int *)(a3 + 20);
  src.data = v4;
  return vImageScale_ARGBFFFF(&src, &v9, v3, 0x28u) >= 0;
}

void cva::experimental::ResizeStrategyLanczos<cva::Matrix<float,4u,1u,false>,true>::Setup(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFDictionaryRef v4 = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a2 + 20);
  v33.data = *(void **)(a3 + 24);
  uint64_t v7 = *(void *)(a3 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v33.height = vextq_s8(v6, v6, 8uLL);
  v33.rowBytes = *(unsigned int *)(a3 + 20);
  src.data = v4;
  unint64_t v8 = vImageScale_ARGBFFFF(&src, &v33, 0, 0xA8u);
  if ((v8 & 0x8000000000000000) == 0)
  {
    unint64_t v9 = v8;
    CFAllocatorRef v11 = *(char **)(a1 + 8);
    BOOL v10 = *(char **)(a1 + 16);
    unint64_t v12 = v10 - v11;
    size_t v13 = v8 - (v10 - v11);
    if (v8 > v10 - v11)
    {
      uint64_t v14 = *(void *)(a1 + 24);
      if (v14 - (uint64_t)v10 >= v13)
      {
        bzero(*(void **)(a1 + 16), v13);
        *(void *)(a1 + 16) = &v10[v13];
        return;
      }
      unint64_t v15 = v14 - (void)v11;
      uint64_t v16 = 2 * v15;
      if (2 * v15 <= v8) {
        uint64_t v16 = v8;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v17 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v17 = v16;
      }
      BOOL v18 = (char *)operator new(v17);
      CFNumberRef v19 = &v18[v12];
      CFNumberRef v20 = &v18[v17];
      CFNumberRef v21 = &v18[v9];
      bzero(&v18[v12], v13);
      if (v10 == v11) {
        goto LABEL_29;
      }
      if (v12 < 8 || (unint64_t)(v11 - v18) < 0x20) {
        goto LABEL_26;
      }
      if (v12 >= 0x20)
      {
        unint64_t v22 = v12 & 0xFFFFFFFFFFFFFFE0;
        CFNumberRef v23 = v10 - 16;
        int v24 = &v18[v10 - 16 - v11];
        unint64_t v25 = v12 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v26 = *(_OWORD *)v23;
          *((_OWORD *)v24 - 1) = *((_OWORD *)v23 - 1);
          *(_OWORD *)int v24 = v26;
          v24 -= 32;
          v23 -= 32;
          v25 -= 32;
        }
        while (v25);
        if (v12 == v22) {
          goto LABEL_28;
        }
        if ((v12 & 0x18) == 0)
        {
          v19 -= v22;
          v10 -= v22;
          goto LABEL_26;
        }
      }
      else
      {
        unint64_t v22 = 0;
      }
      unint64_t v27 = v22 - (v12 & 0xFFFFFFFFFFFFFFF8);
      int v28 = &v10[-v22 - 8];
      int v29 = (char *)(v28 - v11);
      do
      {
        uint64_t v30 = *(void *)v28;
        v28 -= 8;
        *(void *)&v29[(void)v18] = v30;
        v29 -= 8;
        v27 += 8;
      }
      while (v27);
      if (v12 == (v12 & 0xFFFFFFFFFFFFFFF8)) {
        goto LABEL_28;
      }
      v19 -= v12 & 0xFFFFFFFFFFFFFFF8;
      v10 -= v12 & 0xFFFFFFFFFFFFFFF8;
LABEL_26:
      int v31 = v19 - 1;
      do
      {
        char v32 = *--v10;
        *v31-- = v32;
      }
      while (v10 != v11);
LABEL_28:
      BOOL v10 = v11;
      CFNumberRef v19 = v18;
LABEL_29:
      *(void *)(a1 + 8) = v19;
      *(void *)(a1 + 16) = v21;
      *(void *)(a1 + 24) = v20;
      if (v10) {
        operator delete(v10);
      }
      return;
    }
    if (v8 < v10 - v11) {
      *(void *)(a1 + 16) = &v11[v8];
    }
  }
}

void sub_2153C5F10(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2166B9890);
}

uint64_t sub_2153C5F64(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
  return a1;
}

BOOL cva::experimental::ResizeStrategyLanczos<cva::Matrix<float,4u,1u,false>,false>::Resize(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3 = *(void **)(a1 + 8);
  CFDictionaryRef v4 = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a2 + 20);
  v9.data = *(void **)(a3 + 24);
  uint64_t v7 = *(void *)(a3 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v9.height = vextq_s8(v6, v6, 8uLL);
  v9.rowBytes = *(unsigned int *)(a3 + 20);
  src.data = v4;
  return vImageScale_ARGBFFFF(&src, &v9, v3, 8u) >= 0;
}

void cva::experimental::ResizeStrategyLanczos<cva::Matrix<float,4u,1u,false>,false>::Setup(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFDictionaryRef v4 = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a2 + 20);
  v33.data = *(void **)(a3 + 24);
  uint64_t v7 = *(void *)(a3 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v33.height = vextq_s8(v6, v6, 8uLL);
  v33.rowBytes = *(unsigned int *)(a3 + 20);
  src.data = v4;
  unint64_t v8 = vImageScale_ARGBFFFF(&src, &v33, 0, 0x88u);
  if ((v8 & 0x8000000000000000) == 0)
  {
    unint64_t v9 = v8;
    CFAllocatorRef v11 = *(char **)(a1 + 8);
    BOOL v10 = *(char **)(a1 + 16);
    unint64_t v12 = v10 - v11;
    size_t v13 = v8 - (v10 - v11);
    if (v8 > v10 - v11)
    {
      uint64_t v14 = *(void *)(a1 + 24);
      if (v14 - (uint64_t)v10 >= v13)
      {
        bzero(*(void **)(a1 + 16), v13);
        *(void *)(a1 + 16) = &v10[v13];
        return;
      }
      unint64_t v15 = v14 - (void)v11;
      uint64_t v16 = 2 * v15;
      if (2 * v15 <= v8) {
        uint64_t v16 = v8;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v17 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v17 = v16;
      }
      BOOL v18 = (char *)operator new(v17);
      CFNumberRef v19 = &v18[v12];
      CFNumberRef v20 = &v18[v17];
      CFNumberRef v21 = &v18[v9];
      bzero(&v18[v12], v13);
      if (v10 == v11) {
        goto LABEL_29;
      }
      if (v12 < 8 || (unint64_t)(v11 - v18) < 0x20) {
        goto LABEL_26;
      }
      if (v12 >= 0x20)
      {
        unint64_t v22 = v12 & 0xFFFFFFFFFFFFFFE0;
        CFNumberRef v23 = v10 - 16;
        int v24 = &v18[v10 - 16 - v11];
        unint64_t v25 = v12 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v26 = *(_OWORD *)v23;
          *((_OWORD *)v24 - 1) = *((_OWORD *)v23 - 1);
          *(_OWORD *)int v24 = v26;
          v24 -= 32;
          v23 -= 32;
          v25 -= 32;
        }
        while (v25);
        if (v12 == v22) {
          goto LABEL_28;
        }
        if ((v12 & 0x18) == 0)
        {
          v19 -= v22;
          v10 -= v22;
          goto LABEL_26;
        }
      }
      else
      {
        unint64_t v22 = 0;
      }
      unint64_t v27 = v22 - (v12 & 0xFFFFFFFFFFFFFFF8);
      int v28 = &v10[-v22 - 8];
      int v29 = (char *)(v28 - v11);
      do
      {
        uint64_t v30 = *(void *)v28;
        v28 -= 8;
        *(void *)&v29[(void)v18] = v30;
        v29 -= 8;
        v27 += 8;
      }
      while (v27);
      if (v12 == (v12 & 0xFFFFFFFFFFFFFFF8)) {
        goto LABEL_28;
      }
      v19 -= v12 & 0xFFFFFFFFFFFFFFF8;
      v10 -= v12 & 0xFFFFFFFFFFFFFFF8;
LABEL_26:
      int v31 = v19 - 1;
      do
      {
        char v32 = *--v10;
        *v31-- = v32;
      }
      while (v10 != v11);
LABEL_28:
      BOOL v10 = v11;
      CFNumberRef v19 = v18;
LABEL_29:
      *(void *)(a1 + 8) = v19;
      *(void *)(a1 + 16) = v21;
      *(void *)(a1 + 24) = v20;
      if (v10) {
        operator delete(v10);
      }
      return;
    }
    if (v8 < v10 - v11) {
      *(void *)(a1 + 16) = &v11[v8];
    }
  }
}

void sub_2153C6228(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2166B9890);
}

uint64_t sub_2153C627C(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t sub_2153C62B0()
{
  return 0;
}

BOOL cva::experimental::ResizeStrategyLanczos<cva::Matrix<unsigned short,4u,1u,false>,true>::Resize(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3 = *(void **)(a1 + 8);
  CFDictionaryRef v4 = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a2 + 20);
  v9.data = *(void **)(a3 + 24);
  uint64_t v7 = *(void *)(a3 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v9.height = vextq_s8(v6, v6, 8uLL);
  v9.rowBytes = *(unsigned int *)(a3 + 20);
  src.data = v4;
  return vImageScale_ARGB16U(&src, &v9, v3, 0x28u) >= 0;
}

void cva::experimental::ResizeStrategyLanczos<cva::Matrix<unsigned short,4u,1u,false>,true>::Setup(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFDictionaryRef v4 = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a2 + 20);
  v33.data = *(void **)(a3 + 24);
  uint64_t v7 = *(void *)(a3 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v33.height = vextq_s8(v6, v6, 8uLL);
  v33.rowBytes = *(unsigned int *)(a3 + 20);
  src.data = v4;
  unint64_t v8 = vImageScale_ARGB16U(&src, &v33, 0, 0xA8u);
  if ((v8 & 0x8000000000000000) == 0)
  {
    unint64_t v9 = v8;
    CFAllocatorRef v11 = *(char **)(a1 + 8);
    BOOL v10 = *(char **)(a1 + 16);
    unint64_t v12 = v10 - v11;
    size_t v13 = v8 - (v10 - v11);
    if (v8 > v10 - v11)
    {
      uint64_t v14 = *(void *)(a1 + 24);
      if (v14 - (uint64_t)v10 >= v13)
      {
        bzero(*(void **)(a1 + 16), v13);
        *(void *)(a1 + 16) = &v10[v13];
        return;
      }
      unint64_t v15 = v14 - (void)v11;
      uint64_t v16 = 2 * v15;
      if (2 * v15 <= v8) {
        uint64_t v16 = v8;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v17 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v17 = v16;
      }
      BOOL v18 = (char *)operator new(v17);
      CFNumberRef v19 = &v18[v12];
      CFNumberRef v20 = &v18[v17];
      CFNumberRef v21 = &v18[v9];
      bzero(&v18[v12], v13);
      if (v10 == v11) {
        goto LABEL_29;
      }
      if (v12 < 8 || (unint64_t)(v11 - v18) < 0x20) {
        goto LABEL_26;
      }
      if (v12 >= 0x20)
      {
        unint64_t v22 = v12 & 0xFFFFFFFFFFFFFFE0;
        CFNumberRef v23 = v10 - 16;
        int v24 = &v18[v10 - 16 - v11];
        unint64_t v25 = v12 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v26 = *(_OWORD *)v23;
          *((_OWORD *)v24 - 1) = *((_OWORD *)v23 - 1);
          *(_OWORD *)int v24 = v26;
          v24 -= 32;
          v23 -= 32;
          v25 -= 32;
        }
        while (v25);
        if (v12 == v22) {
          goto LABEL_28;
        }
        if ((v12 & 0x18) == 0)
        {
          v19 -= v22;
          v10 -= v22;
          goto LABEL_26;
        }
      }
      else
      {
        unint64_t v22 = 0;
      }
      unint64_t v27 = v22 - (v12 & 0xFFFFFFFFFFFFFFF8);
      int v28 = &v10[-v22 - 8];
      int v29 = (char *)(v28 - v11);
      do
      {
        uint64_t v30 = *(void *)v28;
        v28 -= 8;
        *(void *)&v29[(void)v18] = v30;
        v29 -= 8;
        v27 += 8;
      }
      while (v27);
      if (v12 == (v12 & 0xFFFFFFFFFFFFFFF8)) {
        goto LABEL_28;
      }
      v19 -= v12 & 0xFFFFFFFFFFFFFFF8;
      v10 -= v12 & 0xFFFFFFFFFFFFFFF8;
LABEL_26:
      int v31 = v19 - 1;
      do
      {
        char v32 = *--v10;
        *v31-- = v32;
      }
      while (v10 != v11);
LABEL_28:
      BOOL v10 = v11;
      CFNumberRef v19 = v18;
LABEL_29:
      *(void *)(a1 + 8) = v19;
      *(void *)(a1 + 16) = v21;
      *(void *)(a1 + 24) = v20;
      if (v10) {
        operator delete(v10);
      }
      return;
    }
    if (v8 < v10 - v11) {
      *(void *)(a1 + 16) = &v11[v8];
    }
  }
}

void sub_2153C6548(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2166B9890);
}

uint64_t sub_2153C659C(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
  return a1;
}

BOOL cva::experimental::ResizeStrategyLanczos<cva::Matrix<unsigned short,4u,1u,false>,false>::Resize(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3 = *(void **)(a1 + 8);
  CFDictionaryRef v4 = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a2 + 20);
  v9.data = *(void **)(a3 + 24);
  uint64_t v7 = *(void *)(a3 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v9.height = vextq_s8(v6, v6, 8uLL);
  v9.rowBytes = *(unsigned int *)(a3 + 20);
  src.data = v4;
  return vImageScale_ARGB16U(&src, &v9, v3, 8u) >= 0;
}

void cva::experimental::ResizeStrategyLanczos<cva::Matrix<unsigned short,4u,1u,false>,false>::Setup(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFDictionaryRef v4 = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a2 + 20);
  v33.data = *(void **)(a3 + 24);
  uint64_t v7 = *(void *)(a3 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v33.height = vextq_s8(v6, v6, 8uLL);
  v33.rowBytes = *(unsigned int *)(a3 + 20);
  src.data = v4;
  unint64_t v8 = vImageScale_ARGB16U(&src, &v33, 0, 0x88u);
  if ((v8 & 0x8000000000000000) == 0)
  {
    unint64_t v9 = v8;
    CFAllocatorRef v11 = *(char **)(a1 + 8);
    BOOL v10 = *(char **)(a1 + 16);
    unint64_t v12 = v10 - v11;
    size_t v13 = v8 - (v10 - v11);
    if (v8 > v10 - v11)
    {
      uint64_t v14 = *(void *)(a1 + 24);
      if (v14 - (uint64_t)v10 >= v13)
      {
        bzero(*(void **)(a1 + 16), v13);
        *(void *)(a1 + 16) = &v10[v13];
        return;
      }
      unint64_t v15 = v14 - (void)v11;
      uint64_t v16 = 2 * v15;
      if (2 * v15 <= v8) {
        uint64_t v16 = v8;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v17 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v17 = v16;
      }
      BOOL v18 = (char *)operator new(v17);
      CFNumberRef v19 = &v18[v12];
      CFNumberRef v20 = &v18[v17];
      CFNumberRef v21 = &v18[v9];
      bzero(&v18[v12], v13);
      if (v10 == v11) {
        goto LABEL_29;
      }
      if (v12 < 8 || (unint64_t)(v11 - v18) < 0x20) {
        goto LABEL_26;
      }
      if (v12 >= 0x20)
      {
        unint64_t v22 = v12 & 0xFFFFFFFFFFFFFFE0;
        CFNumberRef v23 = v10 - 16;
        int v24 = &v18[v10 - 16 - v11];
        unint64_t v25 = v12 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v26 = *(_OWORD *)v23;
          *((_OWORD *)v24 - 1) = *((_OWORD *)v23 - 1);
          *(_OWORD *)int v24 = v26;
          v24 -= 32;
          v23 -= 32;
          v25 -= 32;
        }
        while (v25);
        if (v12 == v22) {
          goto LABEL_28;
        }
        if ((v12 & 0x18) == 0)
        {
          v19 -= v22;
          v10 -= v22;
          goto LABEL_26;
        }
      }
      else
      {
        unint64_t v22 = 0;
      }
      unint64_t v27 = v22 - (v12 & 0xFFFFFFFFFFFFFFF8);
      int v28 = &v10[-v22 - 8];
      int v29 = (char *)(v28 - v11);
      do
      {
        uint64_t v30 = *(void *)v28;
        v28 -= 8;
        *(void *)&v29[(void)v18] = v30;
        v29 -= 8;
        v27 += 8;
      }
      while (v27);
      if (v12 == (v12 & 0xFFFFFFFFFFFFFFF8)) {
        goto LABEL_28;
      }
      v19 -= v12 & 0xFFFFFFFFFFFFFFF8;
      v10 -= v12 & 0xFFFFFFFFFFFFFFF8;
LABEL_26:
      int v31 = v19 - 1;
      do
      {
        char v32 = *--v10;
        *v31-- = v32;
      }
      while (v10 != v11);
LABEL_28:
      BOOL v10 = v11;
      CFNumberRef v19 = v18;
LABEL_29:
      *(void *)(a1 + 8) = v19;
      *(void *)(a1 + 16) = v21;
      *(void *)(a1 + 24) = v20;
      if (v10) {
        operator delete(v10);
      }
      return;
    }
    if (v8 < v10 - v11) {
      *(void *)(a1 + 16) = &v11[v8];
    }
  }
}

void sub_2153C6860(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2166B9890);
}

uint64_t sub_2153C68B4(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t sub_2153C68E8()
{
  return 0;
}

BOOL cva::experimental::ResizeStrategyLanczos<cva::Matrix<short,4u,1u,false>,true>::Resize(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3 = *(void **)(a1 + 8);
  CFDictionaryRef v4 = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a2 + 20);
  v9.data = *(void **)(a3 + 24);
  uint64_t v7 = *(void *)(a3 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v9.height = vextq_s8(v6, v6, 8uLL);
  v9.rowBytes = *(unsigned int *)(a3 + 20);
  src.data = v4;
  return vImageScale_ARGB16S(&src, &v9, v3, 0x28u) >= 0;
}

void cva::experimental::ResizeStrategyLanczos<cva::Matrix<short,4u,1u,false>,true>::Setup(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFDictionaryRef v4 = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a2 + 20);
  v33.data = *(void **)(a3 + 24);
  uint64_t v7 = *(void *)(a3 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v33.height = vextq_s8(v6, v6, 8uLL);
  v33.rowBytes = *(unsigned int *)(a3 + 20);
  src.data = v4;
  unint64_t v8 = vImageScale_ARGB16S(&src, &v33, 0, 0xA8u);
  if ((v8 & 0x8000000000000000) == 0)
  {
    unint64_t v9 = v8;
    CFAllocatorRef v11 = *(char **)(a1 + 8);
    BOOL v10 = *(char **)(a1 + 16);
    unint64_t v12 = v10 - v11;
    size_t v13 = v8 - (v10 - v11);
    if (v8 > v10 - v11)
    {
      uint64_t v14 = *(void *)(a1 + 24);
      if (v14 - (uint64_t)v10 >= v13)
      {
        bzero(*(void **)(a1 + 16), v13);
        *(void *)(a1 + 16) = &v10[v13];
        return;
      }
      unint64_t v15 = v14 - (void)v11;
      uint64_t v16 = 2 * v15;
      if (2 * v15 <= v8) {
        uint64_t v16 = v8;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v17 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v17 = v16;
      }
      BOOL v18 = (char *)operator new(v17);
      CFNumberRef v19 = &v18[v12];
      CFNumberRef v20 = &v18[v17];
      CFNumberRef v21 = &v18[v9];
      bzero(&v18[v12], v13);
      if (v10 == v11) {
        goto LABEL_29;
      }
      if (v12 < 8 || (unint64_t)(v11 - v18) < 0x20) {
        goto LABEL_26;
      }
      if (v12 >= 0x20)
      {
        unint64_t v22 = v12 & 0xFFFFFFFFFFFFFFE0;
        CFNumberRef v23 = v10 - 16;
        int v24 = &v18[v10 - 16 - v11];
        unint64_t v25 = v12 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v26 = *(_OWORD *)v23;
          *((_OWORD *)v24 - 1) = *((_OWORD *)v23 - 1);
          *(_OWORD *)int v24 = v26;
          v24 -= 32;
          v23 -= 32;
          v25 -= 32;
        }
        while (v25);
        if (v12 == v22) {
          goto LABEL_28;
        }
        if ((v12 & 0x18) == 0)
        {
          v19 -= v22;
          v10 -= v22;
          goto LABEL_26;
        }
      }
      else
      {
        unint64_t v22 = 0;
      }
      unint64_t v27 = v22 - (v12 & 0xFFFFFFFFFFFFFFF8);
      int v28 = &v10[-v22 - 8];
      int v29 = (char *)(v28 - v11);
      do
      {
        uint64_t v30 = *(void *)v28;
        v28 -= 8;
        *(void *)&v29[(void)v18] = v30;
        v29 -= 8;
        v27 += 8;
      }
      while (v27);
      if (v12 == (v12 & 0xFFFFFFFFFFFFFFF8)) {
        goto LABEL_28;
      }
      v19 -= v12 & 0xFFFFFFFFFFFFFFF8;
      v10 -= v12 & 0xFFFFFFFFFFFFFFF8;
LABEL_26:
      int v31 = v19 - 1;
      do
      {
        char v32 = *--v10;
        *v31-- = v32;
      }
      while (v10 != v11);
LABEL_28:
      BOOL v10 = v11;
      CFNumberRef v19 = v18;
LABEL_29:
      *(void *)(a1 + 8) = v19;
      *(void *)(a1 + 16) = v21;
      *(void *)(a1 + 24) = v20;
      if (v10) {
        operator delete(v10);
      }
      return;
    }
    if (v8 < v10 - v11) {
      *(void *)(a1 + 16) = &v11[v8];
    }
  }
}

void sub_2153C6B80(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2166B9890);
}

uint64_t sub_2153C6BD4(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
  return a1;
}

BOOL cva::experimental::ResizeStrategyLanczos<cva::Matrix<short,4u,1u,false>,false>::Resize(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3 = *(void **)(a1 + 8);
  CFDictionaryRef v4 = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a2 + 20);
  v9.data = *(void **)(a3 + 24);
  uint64_t v7 = *(void *)(a3 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v9.height = vextq_s8(v6, v6, 8uLL);
  v9.rowBytes = *(unsigned int *)(a3 + 20);
  src.data = v4;
  return vImageScale_ARGB16S(&src, &v9, v3, 8u) >= 0;
}

void cva::experimental::ResizeStrategyLanczos<cva::Matrix<short,4u,1u,false>,false>::Setup(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFDictionaryRef v4 = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a2 + 20);
  v33.data = *(void **)(a3 + 24);
  uint64_t v7 = *(void *)(a3 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v33.height = vextq_s8(v6, v6, 8uLL);
  v33.rowBytes = *(unsigned int *)(a3 + 20);
  src.data = v4;
  unint64_t v8 = vImageScale_ARGB16S(&src, &v33, 0, 0x88u);
  if ((v8 & 0x8000000000000000) == 0)
  {
    unint64_t v9 = v8;
    CFAllocatorRef v11 = *(char **)(a1 + 8);
    BOOL v10 = *(char **)(a1 + 16);
    unint64_t v12 = v10 - v11;
    size_t v13 = v8 - (v10 - v11);
    if (v8 > v10 - v11)
    {
      uint64_t v14 = *(void *)(a1 + 24);
      if (v14 - (uint64_t)v10 >= v13)
      {
        bzero(*(void **)(a1 + 16), v13);
        *(void *)(a1 + 16) = &v10[v13];
        return;
      }
      unint64_t v15 = v14 - (void)v11;
      uint64_t v16 = 2 * v15;
      if (2 * v15 <= v8) {
        uint64_t v16 = v8;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v17 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v17 = v16;
      }
      BOOL v18 = (char *)operator new(v17);
      CFNumberRef v19 = &v18[v12];
      CFNumberRef v20 = &v18[v17];
      CFNumberRef v21 = &v18[v9];
      bzero(&v18[v12], v13);
      if (v10 == v11) {
        goto LABEL_29;
      }
      if (v12 < 8 || (unint64_t)(v11 - v18) < 0x20) {
        goto LABEL_26;
      }
      if (v12 >= 0x20)
      {
        unint64_t v22 = v12 & 0xFFFFFFFFFFFFFFE0;
        CFNumberRef v23 = v10 - 16;
        int v24 = &v18[v10 - 16 - v11];
        unint64_t v25 = v12 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v26 = *(_OWORD *)v23;
          *((_OWORD *)v24 - 1) = *((_OWORD *)v23 - 1);
          *(_OWORD *)int v24 = v26;
          v24 -= 32;
          v23 -= 32;
          v25 -= 32;
        }
        while (v25);
        if (v12 == v22) {
          goto LABEL_28;
        }
        if ((v12 & 0x18) == 0)
        {
          v19 -= v22;
          v10 -= v22;
          goto LABEL_26;
        }
      }
      else
      {
        unint64_t v22 = 0;
      }
      unint64_t v27 = v22 - (v12 & 0xFFFFFFFFFFFFFFF8);
      int v28 = &v10[-v22 - 8];
      int v29 = (char *)(v28 - v11);
      do
      {
        uint64_t v30 = *(void *)v28;
        v28 -= 8;
        *(void *)&v29[(void)v18] = v30;
        v29 -= 8;
        v27 += 8;
      }
      while (v27);
      if (v12 == (v12 & 0xFFFFFFFFFFFFFFF8)) {
        goto LABEL_28;
      }
      v19 -= v12 & 0xFFFFFFFFFFFFFFF8;
      v10 -= v12 & 0xFFFFFFFFFFFFFFF8;
LABEL_26:
      int v31 = v19 - 1;
      do
      {
        char v32 = *--v10;
        *v31-- = v32;
      }
      while (v10 != v11);
LABEL_28:
      BOOL v10 = v11;
      CFNumberRef v19 = v18;
LABEL_29:
      *(void *)(a1 + 8) = v19;
      *(void *)(a1 + 16) = v21;
      *(void *)(a1 + 24) = v20;
      if (v10) {
        operator delete(v10);
      }
      return;
    }
    if (v8 < v10 - v11) {
      *(void *)(a1 + 16) = &v11[v8];
    }
  }
}

void sub_2153C6E98(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2166B9890);
}

uint64_t sub_2153C6EEC(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
  return a1;
}

BOOL cva::experimental::getTempBufferSizeLanczos5<unsigned char>(uint64_t a1, uint64_t a2, vImage_Error *a3)
{
  CFDictionaryRef v4 = *(void **)(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  v10.data = *(void **)(a2 + 24);
  uint64_t v7 = *(void *)(a2 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v10.height = vextq_s8(v6, v6, 8uLL);
  v10.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v4;
  vImage_Error v8 = vImageScale_Planar8(&src, &v10, 0, 0xA8u);
  if ((v8 & 0x8000000000000000) == 0) {
    *a3 = v8;
  }
  return v8 >= 0;
}

BOOL cva::experimental::getTempBufferSizeLanczos3<unsigned char>(uint64_t a1, uint64_t a2, vImage_Error *a3)
{
  CFDictionaryRef v4 = *(void **)(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  v10.data = *(void **)(a2 + 24);
  uint64_t v7 = *(void *)(a2 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v10.height = vextq_s8(v6, v6, 8uLL);
  v10.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v4;
  vImage_Error v8 = vImageScale_Planar8(&src, &v10, 0, 0x88u);
  if ((v8 & 0x8000000000000000) == 0) {
    *a3 = v8;
  }
  return v8 >= 0;
}

BOOL cva::experimental::resizeLanczos3<unsigned char>(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v3 = *(void **)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 8);
  v5.i64[0] = v4;
  v5.i64[1] = HIDWORD(v4);
  *(int8x16_t *)&src.height = vextq_s8(v5, v5, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  v8.data = *(void **)(a2 + 24);
  uint64_t v6 = *(void *)(a2 + 8);
  v5.i64[0] = v6;
  v5.i64[1] = HIDWORD(v6);
  *(int8x16_t *)&v8.height = vextq_s8(v5, v5, 8uLL);
  v8.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v3;
  return vImageScale_Planar8(&src, &v8, a3, 8u) >= 0;
}

BOOL cva::experimental::resizeLanczos5<unsigned char>(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v3 = *(void **)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 8);
  v5.i64[0] = v4;
  v5.i64[1] = HIDWORD(v4);
  *(int8x16_t *)&src.height = vextq_s8(v5, v5, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  v8.data = *(void **)(a2 + 24);
  uint64_t v6 = *(void *)(a2 + 8);
  v5.i64[0] = v6;
  v5.i64[1] = HIDWORD(v6);
  *(int8x16_t *)&v8.height = vextq_s8(v5, v5, 8uLL);
  v8.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v3;
  return vImageScale_Planar8(&src, &v8, a3, 0x28u) >= 0;
}

BOOL cva::experimental::getTempBufferSizeLanczos5<unsigned short>(uint64_t a1, uint64_t a2, vImage_Error *a3)
{
  uint64_t v4 = *(void **)(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  v10.data = *(void **)(a2 + 24);
  uint64_t v7 = *(void *)(a2 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v10.height = vextq_s8(v6, v6, 8uLL);
  v10.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v4;
  vImage_Error v8 = vImageScale_Planar16U(&src, &v10, 0, 0xA8u);
  if ((v8 & 0x8000000000000000) == 0) {
    *a3 = v8;
  }
  return v8 >= 0;
}

BOOL cva::experimental::getTempBufferSizeLanczos3<unsigned short>(uint64_t a1, uint64_t a2, vImage_Error *a3)
{
  uint64_t v4 = *(void **)(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  v10.data = *(void **)(a2 + 24);
  uint64_t v7 = *(void *)(a2 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v10.height = vextq_s8(v6, v6, 8uLL);
  v10.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v4;
  vImage_Error v8 = vImageScale_Planar16U(&src, &v10, 0, 0x88u);
  if ((v8 & 0x8000000000000000) == 0) {
    *a3 = v8;
  }
  return v8 >= 0;
}

BOOL cva::experimental::resizeLanczos3<unsigned short>(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v3 = *(void **)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 8);
  v5.i64[0] = v4;
  v5.i64[1] = HIDWORD(v4);
  *(int8x16_t *)&src.height = vextq_s8(v5, v5, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  v8.data = *(void **)(a2 + 24);
  uint64_t v6 = *(void *)(a2 + 8);
  v5.i64[0] = v6;
  v5.i64[1] = HIDWORD(v6);
  *(int8x16_t *)&v8.height = vextq_s8(v5, v5, 8uLL);
  v8.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v3;
  return vImageScale_Planar16U(&src, &v8, a3, 8u) >= 0;
}

BOOL cva::experimental::resizeLanczos5<unsigned short>(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v3 = *(void **)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 8);
  v5.i64[0] = v4;
  v5.i64[1] = HIDWORD(v4);
  *(int8x16_t *)&src.height = vextq_s8(v5, v5, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  v8.data = *(void **)(a2 + 24);
  uint64_t v6 = *(void *)(a2 + 8);
  v5.i64[0] = v6;
  v5.i64[1] = HIDWORD(v6);
  *(int8x16_t *)&v8.height = vextq_s8(v5, v5, 8uLL);
  v8.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v3;
  return vImageScale_Planar16U(&src, &v8, a3, 0x28u) >= 0;
}

BOOL cva::experimental::getTempBufferSizeLanczos5<short>(uint64_t a1, uint64_t a2, vImage_Error *a3)
{
  uint64_t v4 = *(void **)(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  v10.data = *(void **)(a2 + 24);
  uint64_t v7 = *(void *)(a2 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v10.height = vextq_s8(v6, v6, 8uLL);
  v10.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v4;
  vImage_Error v8 = vImageScale_Planar16S(&src, &v10, 0, 0xA8u);
  if ((v8 & 0x8000000000000000) == 0) {
    *a3 = v8;
  }
  return v8 >= 0;
}

BOOL cva::experimental::getTempBufferSizeLanczos3<short>(uint64_t a1, uint64_t a2, vImage_Error *a3)
{
  uint64_t v4 = *(void **)(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  v10.data = *(void **)(a2 + 24);
  uint64_t v7 = *(void *)(a2 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v10.height = vextq_s8(v6, v6, 8uLL);
  v10.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v4;
  vImage_Error v8 = vImageScale_Planar16S(&src, &v10, 0, 0x88u);
  if ((v8 & 0x8000000000000000) == 0) {
    *a3 = v8;
  }
  return v8 >= 0;
}

BOOL cva::experimental::resizeLanczos3<short>(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v3 = *(void **)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 8);
  v5.i64[0] = v4;
  v5.i64[1] = HIDWORD(v4);
  *(int8x16_t *)&src.height = vextq_s8(v5, v5, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  v8.data = *(void **)(a2 + 24);
  uint64_t v6 = *(void *)(a2 + 8);
  v5.i64[0] = v6;
  v5.i64[1] = HIDWORD(v6);
  *(int8x16_t *)&v8.height = vextq_s8(v5, v5, 8uLL);
  v8.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v3;
  return vImageScale_Planar16S(&src, &v8, a3, 8u) >= 0;
}

BOOL cva::experimental::resizeLanczos5<short>(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v3 = *(void **)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 8);
  v5.i64[0] = v4;
  v5.i64[1] = HIDWORD(v4);
  *(int8x16_t *)&src.height = vextq_s8(v5, v5, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  v8.data = *(void **)(a2 + 24);
  uint64_t v6 = *(void *)(a2 + 8);
  v5.i64[0] = v6;
  v5.i64[1] = HIDWORD(v6);
  *(int8x16_t *)&v8.height = vextq_s8(v5, v5, 8uLL);
  v8.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v3;
  return vImageScale_Planar16S(&src, &v8, a3, 0x28u) >= 0;
}

BOOL cva::experimental::getTempBufferSizeLanczos5<float>(uint64_t a1, uint64_t a2, vImage_Error *a3)
{
  uint64_t v4 = *(void **)(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  v10.data = *(void **)(a2 + 24);
  uint64_t v7 = *(void *)(a2 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v10.height = vextq_s8(v6, v6, 8uLL);
  v10.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v4;
  vImage_Error v8 = vImageScale_PlanarF(&src, &v10, 0, 0xA8u);
  if ((v8 & 0x8000000000000000) == 0) {
    *a3 = v8;
  }
  return v8 >= 0;
}

BOOL cva::experimental::getTempBufferSizeLanczos3<float>(uint64_t a1, uint64_t a2, vImage_Error *a3)
{
  uint64_t v4 = *(void **)(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  v10.data = *(void **)(a2 + 24);
  uint64_t v7 = *(void *)(a2 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v10.height = vextq_s8(v6, v6, 8uLL);
  v10.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v4;
  vImage_Error v8 = vImageScale_PlanarF(&src, &v10, 0, 0x88u);
  if ((v8 & 0x8000000000000000) == 0) {
    *a3 = v8;
  }
  return v8 >= 0;
}

BOOL cva::experimental::resizeLanczos3<float>(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v3 = *(void **)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 8);
  v5.i64[0] = v4;
  v5.i64[1] = HIDWORD(v4);
  *(int8x16_t *)&src.height = vextq_s8(v5, v5, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  v8.data = *(void **)(a2 + 24);
  uint64_t v6 = *(void *)(a2 + 8);
  v5.i64[0] = v6;
  v5.i64[1] = HIDWORD(v6);
  *(int8x16_t *)&v8.height = vextq_s8(v5, v5, 8uLL);
  v8.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v3;
  return vImageScale_PlanarF(&src, &v8, a3, 8u) >= 0;
}

BOOL cva::experimental::resizeLanczos5<float>(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v3 = *(void **)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 8);
  v5.i64[0] = v4;
  v5.i64[1] = HIDWORD(v4);
  *(int8x16_t *)&src.height = vextq_s8(v5, v5, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  v8.data = *(void **)(a2 + 24);
  uint64_t v6 = *(void *)(a2 + 8);
  v5.i64[0] = v6;
  v5.i64[1] = HIDWORD(v6);
  *(int8x16_t *)&v8.height = vextq_s8(v5, v5, 8uLL);
  v8.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v3;
  return vImageScale_PlanarF(&src, &v8, a3, 0x28u) >= 0;
}

BOOL cva::experimental::getTempBufferSizeLanczos5<cva::Matrix<unsigned char,4u,1u,false>>(uint64_t a1, uint64_t a2, vImage_Error *a3)
{
  uint64_t v4 = *(void **)(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  v10.data = *(void **)(a2 + 24);
  uint64_t v7 = *(void *)(a2 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v10.height = vextq_s8(v6, v6, 8uLL);
  v10.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v4;
  vImage_Error v8 = vImageScale_ARGB8888(&src, &v10, 0, 0xA8u);
  if ((v8 & 0x8000000000000000) == 0) {
    *a3 = v8;
  }
  return v8 >= 0;
}

BOOL cva::experimental::getTempBufferSizeLanczos3<cva::Matrix<unsigned char,4u,1u,false>>(uint64_t a1, uint64_t a2, vImage_Error *a3)
{
  uint64_t v4 = *(void **)(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  v10.data = *(void **)(a2 + 24);
  uint64_t v7 = *(void *)(a2 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v10.height = vextq_s8(v6, v6, 8uLL);
  v10.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v4;
  vImage_Error v8 = vImageScale_ARGB8888(&src, &v10, 0, 0x88u);
  if ((v8 & 0x8000000000000000) == 0) {
    *a3 = v8;
  }
  return v8 >= 0;
}

BOOL cva::experimental::resizeLanczos3<cva::Matrix<unsigned char,4u,1u,false>>(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v3 = *(void **)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 8);
  v5.i64[0] = v4;
  v5.i64[1] = HIDWORD(v4);
  *(int8x16_t *)&src.height = vextq_s8(v5, v5, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  v8.data = *(void **)(a2 + 24);
  uint64_t v6 = *(void *)(a2 + 8);
  v5.i64[0] = v6;
  v5.i64[1] = HIDWORD(v6);
  *(int8x16_t *)&v8.height = vextq_s8(v5, v5, 8uLL);
  v8.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v3;
  return vImageScale_ARGB8888(&src, &v8, a3, 8u) >= 0;
}

BOOL cva::experimental::resizeLanczos5<cva::Matrix<unsigned char,4u,1u,false>>(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v3 = *(void **)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 8);
  v5.i64[0] = v4;
  v5.i64[1] = HIDWORD(v4);
  *(int8x16_t *)&src.height = vextq_s8(v5, v5, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  v8.data = *(void **)(a2 + 24);
  uint64_t v6 = *(void *)(a2 + 8);
  v5.i64[0] = v6;
  v5.i64[1] = HIDWORD(v6);
  *(int8x16_t *)&v8.height = vextq_s8(v5, v5, 8uLL);
  v8.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v3;
  return vImageScale_ARGB8888(&src, &v8, a3, 0x28u) >= 0;
}

BOOL cva::experimental::getTempBufferSizeLanczos5<cva::Matrix<float,4u,1u,false>>(uint64_t a1, uint64_t a2, vImage_Error *a3)
{
  uint64_t v4 = *(void **)(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  v10.data = *(void **)(a2 + 24);
  uint64_t v7 = *(void *)(a2 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v10.height = vextq_s8(v6, v6, 8uLL);
  v10.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v4;
  vImage_Error v8 = vImageScale_ARGBFFFF(&src, &v10, 0, 0xA8u);
  if ((v8 & 0x8000000000000000) == 0) {
    *a3 = v8;
  }
  return v8 >= 0;
}

BOOL cva::experimental::getTempBufferSizeLanczos3<cva::Matrix<float,4u,1u,false>>(uint64_t a1, uint64_t a2, vImage_Error *a3)
{
  uint64_t v4 = *(void **)(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  v10.data = *(void **)(a2 + 24);
  uint64_t v7 = *(void *)(a2 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v10.height = vextq_s8(v6, v6, 8uLL);
  v10.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v4;
  vImage_Error v8 = vImageScale_ARGBFFFF(&src, &v10, 0, 0x88u);
  if ((v8 & 0x8000000000000000) == 0) {
    *a3 = v8;
  }
  return v8 >= 0;
}

BOOL cva::experimental::resizeLanczos3<cva::Matrix<float,4u,1u,false>>(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v3 = *(void **)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 8);
  v5.i64[0] = v4;
  v5.i64[1] = HIDWORD(v4);
  *(int8x16_t *)&src.height = vextq_s8(v5, v5, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  v8.data = *(void **)(a2 + 24);
  uint64_t v6 = *(void *)(a2 + 8);
  v5.i64[0] = v6;
  v5.i64[1] = HIDWORD(v6);
  *(int8x16_t *)&v8.height = vextq_s8(v5, v5, 8uLL);
  v8.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v3;
  return vImageScale_ARGBFFFF(&src, &v8, a3, 8u) >= 0;
}

BOOL cva::experimental::resizeLanczos5<cva::Matrix<float,4u,1u,false>>(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v3 = *(void **)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 8);
  v5.i64[0] = v4;
  v5.i64[1] = HIDWORD(v4);
  *(int8x16_t *)&src.height = vextq_s8(v5, v5, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  v8.data = *(void **)(a2 + 24);
  uint64_t v6 = *(void *)(a2 + 8);
  v5.i64[0] = v6;
  v5.i64[1] = HIDWORD(v6);
  *(int8x16_t *)&v8.height = vextq_s8(v5, v5, 8uLL);
  v8.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v3;
  return vImageScale_ARGBFFFF(&src, &v8, a3, 0x28u) >= 0;
}

BOOL cva::experimental::getTempBufferSizeLanczos5<cva::Matrix<unsigned short,4u,1u,false>>(uint64_t a1, uint64_t a2, vImage_Error *a3)
{
  uint64_t v4 = *(void **)(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  v10.data = *(void **)(a2 + 24);
  uint64_t v7 = *(void *)(a2 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v10.height = vextq_s8(v6, v6, 8uLL);
  v10.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v4;
  vImage_Error v8 = vImageScale_ARGB16U(&src, &v10, 0, 0xA8u);
  if ((v8 & 0x8000000000000000) == 0) {
    *a3 = v8;
  }
  return v8 >= 0;
}

BOOL cva::experimental::getTempBufferSizeLanczos3<cva::Matrix<unsigned short,4u,1u,false>>(uint64_t a1, uint64_t a2, vImage_Error *a3)
{
  uint64_t v4 = *(void **)(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  v10.data = *(void **)(a2 + 24);
  uint64_t v7 = *(void *)(a2 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v10.height = vextq_s8(v6, v6, 8uLL);
  v10.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v4;
  vImage_Error v8 = vImageScale_ARGB16U(&src, &v10, 0, 0x88u);
  if ((v8 & 0x8000000000000000) == 0) {
    *a3 = v8;
  }
  return v8 >= 0;
}

BOOL cva::experimental::resizeLanczos3<cva::Matrix<unsigned short,4u,1u,false>>(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v3 = *(void **)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 8);
  v5.i64[0] = v4;
  v5.i64[1] = HIDWORD(v4);
  *(int8x16_t *)&src.height = vextq_s8(v5, v5, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  v8.data = *(void **)(a2 + 24);
  uint64_t v6 = *(void *)(a2 + 8);
  v5.i64[0] = v6;
  v5.i64[1] = HIDWORD(v6);
  *(int8x16_t *)&v8.height = vextq_s8(v5, v5, 8uLL);
  v8.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v3;
  return vImageScale_ARGB16U(&src, &v8, a3, 8u) >= 0;
}

BOOL cva::experimental::resizeLanczos5<cva::Matrix<unsigned short,4u,1u,false>>(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v3 = *(void **)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 8);
  v5.i64[0] = v4;
  v5.i64[1] = HIDWORD(v4);
  *(int8x16_t *)&src.height = vextq_s8(v5, v5, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  v8.data = *(void **)(a2 + 24);
  uint64_t v6 = *(void *)(a2 + 8);
  v5.i64[0] = v6;
  v5.i64[1] = HIDWORD(v6);
  *(int8x16_t *)&v8.height = vextq_s8(v5, v5, 8uLL);
  v8.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v3;
  return vImageScale_ARGB16U(&src, &v8, a3, 0x28u) >= 0;
}

BOOL cva::experimental::getTempBufferSizeLanczos5<cva::Matrix<short,4u,1u,false>>(uint64_t a1, uint64_t a2, vImage_Error *a3)
{
  uint64_t v4 = *(void **)(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  v10.data = *(void **)(a2 + 24);
  uint64_t v7 = *(void *)(a2 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v10.height = vextq_s8(v6, v6, 8uLL);
  v10.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v4;
  vImage_Error v8 = vImageScale_ARGB16S(&src, &v10, 0, 0xA8u);
  if ((v8 & 0x8000000000000000) == 0) {
    *a3 = v8;
  }
  return v8 >= 0;
}

BOOL cva::experimental::getTempBufferSizeLanczos3<cva::Matrix<short,4u,1u,false>>(uint64_t a1, uint64_t a2, vImage_Error *a3)
{
  uint64_t v4 = *(void **)(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  v10.data = *(void **)(a2 + 24);
  uint64_t v7 = *(void *)(a2 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v10.height = vextq_s8(v6, v6, 8uLL);
  v10.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v4;
  vImage_Error v8 = vImageScale_ARGB16S(&src, &v10, 0, 0x88u);
  if ((v8 & 0x8000000000000000) == 0) {
    *a3 = v8;
  }
  return v8 >= 0;
}

BOOL cva::experimental::resizeLanczos3<cva::Matrix<short,4u,1u,false>>(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v3 = *(void **)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 8);
  v5.i64[0] = v4;
  v5.i64[1] = HIDWORD(v4);
  *(int8x16_t *)&src.height = vextq_s8(v5, v5, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  v8.data = *(void **)(a2 + 24);
  uint64_t v6 = *(void *)(a2 + 8);
  v5.i64[0] = v6;
  v5.i64[1] = HIDWORD(v6);
  *(int8x16_t *)&v8.height = vextq_s8(v5, v5, 8uLL);
  v8.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v3;
  return vImageScale_ARGB16S(&src, &v8, a3, 8u) >= 0;
}

BOOL cva::experimental::resizeLanczos5<cva::Matrix<short,4u,1u,false>>(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v3 = *(void **)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 8);
  v5.i64[0] = v4;
  v5.i64[1] = HIDWORD(v4);
  *(int8x16_t *)&src.height = vextq_s8(v5, v5, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  v8.data = *(void **)(a2 + 24);
  uint64_t v6 = *(void *)(a2 + 8);
  v5.i64[0] = v6;
  v5.i64[1] = HIDWORD(v6);
  *(int8x16_t *)&v8.height = vextq_s8(v5, v5, 8uLL);
  v8.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v3;
  return vImageScale_ARGB16S(&src, &v8, a3, 0x28u) >= 0;
}

float cva::normalizeSO3Coefficients<float>(float *a1)
{
  float v2 = *a1;
  float v1 = a1[1];
  float v3 = a1[2];
  float v4 = (float)((float)(v1 * v1) + (float)(v2 * v2)) + (float)(v3 * v3);
  float result = 1.0;
  if (v4 > 9.8696)
  {
    float v6 = sqrtf(v4) / 3.1416;
    float v7 = ceilf(v6) + -1.0;
    int v8 = (int)v7;
    float v9 = v6 - v7;
    if (v8) {
      float v9 = v9 + -1.0;
    }
    float result = v9 / v6;
    *a1 = v2 * result;
    a1[1] = v1 * result;
    a1[2] = v3 * result;
  }
  return result;
}

double cva::normalizeSO3Coefficients<double>(double *a1)
{
  double v2 = *a1;
  double v1 = a1[1];
  double v3 = a1[2];
  double v4 = v1 * v1 + v2 * v2 + v3 * v3;
  double result = 1.0;
  if (v4 > 9.8696044)
  {
    double v6 = sqrt(v4) / 3.14159265;
    double v7 = ceil(v6) + -1.0;
    int v8 = (int)v7;
    double v9 = v6 - v7;
    if (v8) {
      double v9 = v9 + -1.0;
    }
    double result = v9 / v6;
    *a1 = v2 * result;
    a1[1] = v1 * result;
    a1[2] = v3 * result;
  }
  return result;
}

float *cva::ExponentialCoefficients<float,2>::ExponentialCoefficients(float *a1, float a2)
{
  __float2 v4 = __sincosf_stret(a2);
  a1[1] = v4.__cosval;
  a1[2] = v4.__sinval;
  float v5 = a2 * a2;
  *a1 = a2 * a2;
  if ((float)(a2 * a2) >= 0.0061)
  {
    float v6 = (float)(1.0 / a2) * v4.__sinval;
    float v7 = (float)(1.0 / a2) * (float)(1.0 - v4.__cosval);
  }
  else
  {
    float v6 = 1.0 - (float)(v5 * (float)((float)(v5 / -120.0) + 0.16667));
    float v7 = (float)((float)(v5 / -24.0) + 0.5) * a2;
  }
  a1[3] = v6;
  a1[4] = v7;
  return a1;
}

{
  __float2 v4;
  float v5;
  float v6;
  float v7;

  __float2 v4 = __sincosf_stret(a2);
  a1[1] = v4.__cosval;
  a1[2] = v4.__sinval;
  float v5 = a2 * a2;
  *a1 = a2 * a2;
  if ((float)(a2 * a2) >= 0.0061)
  {
    float v6 = (float)(1.0 / a2) * v4.__sinval;
    float v7 = (float)(1.0 / a2) * (float)(1.0 - v4.__cosval);
  }
  else
  {
    float v6 = 1.0 - (float)(v5 * (float)((float)(v5 / -120.0) + 0.16667));
    float v7 = (float)((float)(v5 / -24.0) + 0.5) * a2;
  }
  a1[3] = v6;
  a1[4] = v7;
  return a1;
}

float cva::ExponentialCoefficients<float,2>::compute(float *a1, float a2)
{
  float v2 = a2 * a2;
  *a1 = a2 * a2;
  if ((float)(a2 * a2) >= 0.0061)
  {
    float v4 = 1.0 / a2;
    float v5 = v4 * a1[2];
    float result = v4 * (float)(1.0 - a1[1]);
    a1[3] = v5;
  }
  else
  {
    float result = (float)((float)(v2 / -24.0) + 0.5) * a2;
    a1[3] = 1.0 - (float)(v2 * (float)((float)(v2 / -120.0) + 0.16667));
  }
  a1[4] = result;
  return result;
}

double *cva::ExponentialCoefficients<double,2>::ExponentialCoefficients(double *a1, double a2)
{
  __double2 v4 = __sincos_stret(a2);
  a1[1] = v4.__cosval;
  a1[2] = v4.__sinval;
  double v5 = a2 * a2;
  *a1 = a2 * a2;
  if (a2 * a2 >= 0.0000002635)
  {
    double v6 = 1.0 / a2 * v4.__sinval;
    double v7 = 1.0 / a2 * (1.0 - v4.__cosval);
  }
  else
  {
    double v6 = 1.0 - v5 * (v5 / -120.0 + 0.166666667);
    double v7 = (v5 / -24.0 + 0.5) * a2;
  }
  a1[3] = v6;
  a1[4] = v7;
  return a1;
}

{
  __double2 v4;
  double v5;
  double v6;
  double v7;

  __double2 v4 = __sincos_stret(a2);
  a1[1] = v4.__cosval;
  a1[2] = v4.__sinval;
  double v5 = a2 * a2;
  *a1 = a2 * a2;
  if (a2 * a2 >= 0.0000002635)
  {
    double v6 = 1.0 / a2 * v4.__sinval;
    double v7 = 1.0 / a2 * (1.0 - v4.__cosval);
  }
  else
  {
    double v6 = 1.0 - v5 * (v5 / -120.0 + 0.166666667);
    double v7 = (v5 / -24.0 + 0.5) * a2;
  }
  a1[3] = v6;
  a1[4] = v7;
  return a1;
}

double cva::ExponentialCoefficients<double,2>::compute(double *a1, double a2)
{
  double v2 = a2 * a2;
  *a1 = a2 * a2;
  if (a2 * a2 >= 0.0000002635)
  {
    double v4 = 1.0 / a2;
    double v5 = v4 * a1[2];
    double result = v4 * (1.0 - a1[1]);
    a1[3] = v5;
  }
  else
  {
    double result = (v2 / -24.0 + 0.5) * a2;
    a1[3] = 1.0 - v2 * (v2 / -120.0 + 0.166666667);
  }
  a1[4] = result;
  return result;
}

float *cva::ExponentialCoefficients<float,3>::ExponentialCoefficients(float *a1, float a2)
{
  if (a2 >= 0.0061)
  {
    float v8 = sqrtf(a2);
    __float2 v9 = __sincosf_stret(v8);
    float cosval = v9.__cosval;
    float v6 = v9.__sinval / v8;
    float v4 = (float)(1.0 / a2) * (float)(1.0 - v9.__cosval);
    float v5 = (float)(1.0 / a2) * (float)(1.0 - (float)(v9.__sinval / v8));
  }
  else
  {
    float v4 = 0.5 - (float)(a2 * (float)((float)(a2 / -720.0) + 0.041667));
    float v5 = 0.16667 - (float)(a2 * (float)((float)(a2 / -5040.0) + 0.0083333));
    float v6 = 1.0 - (float)(a2 * v5);
    float cosval = 1.0 - (float)(a2 * v4);
  }
  a1[2] = v4;
  a1[3] = v5;
  *a1 = cosval;
  a1[1] = v6;
  return a1;
}

{
  float v4;
  float v5;
  float v6;
  float cosval;
  float v8;
  __float2 v9;

  if (a2 >= 0.0061)
  {
    float v8 = sqrtf(a2);
    __float2 v9 = __sincosf_stret(v8);
    float cosval = v9.__cosval;
    float v6 = v9.__sinval / v8;
    float v4 = (float)(1.0 / a2) * (float)(1.0 - v9.__cosval);
    float v5 = (float)(1.0 / a2) * (float)(1.0 - (float)(v9.__sinval / v8));
  }
  else
  {
    float v4 = 0.5 - (float)(a2 * (float)((float)(a2 / -720.0) + 0.041667));
    float v5 = 0.16667 - (float)(a2 * (float)((float)(a2 / -5040.0) + 0.0083333));
    float v6 = 1.0 - (float)(a2 * v5);
    float cosval = 1.0 - (float)(a2 * v4);
  }
  a1[2] = v4;
  a1[3] = v5;
  *a1 = cosval;
  a1[1] = v6;
  return a1;
}

void cva::ExponentialCoefficients<float,3>::compute(float *a1, float a2)
{
  if (a2 >= 0.0061)
  {
    float v8 = sqrtf(a2);
    __float2 v9 = __sincosf_stret(v8);
    float cosval = v9.__cosval;
    float v6 = v9.__sinval / v8;
    float v4 = (float)(1.0 / a2) * (float)(1.0 - v9.__cosval);
    float v5 = (float)(1.0 / a2) * (float)(1.0 - (float)(v9.__sinval / v8));
  }
  else
  {
    float v4 = 0.5 - (float)(a2 * (float)((float)(a2 / -720.0) + 0.041667));
    float v5 = 0.16667 - (float)(a2 * (float)((float)(a2 / -5040.0) + 0.0083333));
    float v6 = 1.0 - (float)(a2 * v5);
    float cosval = 1.0 - (float)(a2 * v4);
  }
  a1[2] = v4;
  a1[3] = v5;
  *a1 = cosval;
  a1[1] = v6;
}

double *cva::ExponentialCoefficients<double,3>::ExponentialCoefficients(double *a1, double a2)
{
  if (a2 >= 0.0000002635)
  {
    double v8 = sqrt(a2);
    __double2 v9 = __sincos_stret(v8);
    double cosval = v9.__cosval;
    double v6 = v9.__sinval / v8;
    double v4 = 1.0 / a2 * (1.0 - v9.__cosval);
    double v5 = 1.0 / a2 * (1.0 - v9.__sinval / v8);
  }
  else
  {
    double v4 = 0.5 - a2 * (a2 / -720.0 + 0.0416666667);
    double v5 = 0.166666667 - a2 * (a2 / -5040.0 + 0.00833333333);
    double v6 = 1.0 - a2 * v5;
    double cosval = 1.0 - a2 * v4;
  }
  a1[2] = v4;
  a1[3] = v5;
  *a1 = cosval;
  a1[1] = v6;
  return a1;
}

{
  double v4;
  double v5;
  double v6;
  double cosval;
  double v8;
  __double2 v9;

  if (a2 >= 0.0000002635)
  {
    double v8 = sqrt(a2);
    __double2 v9 = __sincos_stret(v8);
    double cosval = v9.__cosval;
    double v6 = v9.__sinval / v8;
    double v4 = 1.0 / a2 * (1.0 - v9.__cosval);
    double v5 = 1.0 / a2 * (1.0 - v9.__sinval / v8);
  }
  else
  {
    double v4 = 0.5 - a2 * (a2 / -720.0 + 0.0416666667);
    double v5 = 0.166666667 - a2 * (a2 / -5040.0 + 0.00833333333);
    double v6 = 1.0 - a2 * v5;
    double cosval = 1.0 - a2 * v4;
  }
  a1[2] = v4;
  a1[3] = v5;
  *a1 = cosval;
  a1[1] = v6;
  return a1;
}

void cva::ExponentialCoefficients<double,3>::compute(double *a1, double a2)
{
  if (a2 >= 0.0000002635)
  {
    double v8 = sqrt(a2);
    __double2 v9 = __sincos_stret(v8);
    double cosval = v9.__cosval;
    double v6 = v9.__sinval / v8;
    double v4 = 1.0 / a2 * (1.0 - v9.__cosval);
    double v5 = 1.0 / a2 * (1.0 - v9.__sinval / v8);
  }
  else
  {
    double v4 = 0.5 - a2 * (a2 / -720.0 + 0.0416666667);
    double v5 = 0.166666667 - a2 * (a2 / -5040.0 + 0.00833333333);
    double v6 = 1.0 - a2 * v5;
    double cosval = 1.0 - a2 * v4;
  }
  a1[2] = v4;
  a1[3] = v5;
  *a1 = cosval;
  a1[1] = v6;
}

float *cva::DifferentialExponentialCoefficients<float,2>::DifferentialExponentialCoefficients(float *a1, float a2)
{
  __float2 v4 = __sincosf_stret(a2);
  a1[1] = v4.__cosval;
  a1[2] = v4.__sinval;
  float v5 = a2 * a2;
  if ((float)(a2 * a2) >= 0.0061)
  {
    float v8 = (float)(1.0 / a2) * v4.__sinval;
    float v10 = (float)(1.0 / a2) * (float)(1.0 - v4.__cosval);
    float v6 = (float)(1.0 / a2) * v10;
    float v9 = (float)(1.0 / a2) * (float)(1.0 - v8);
  }
  else
  {
    float v6 = 0.5 - (float)(v5 * (float)((float)(v5 / -720.0) + 0.041667));
    float v7 = 0.16667 - (float)(v5 * (float)((float)(v5 / -5040.0) + 0.0083333));
    float v8 = 1.0 - (float)(v5 * v7);
    float v9 = v7 * a2;
    float v10 = v6 * a2;
  }
  *a1 = v5;
  a1[5] = v6;
  a1[6] = v9;
  a1[3] = v8;
  a1[4] = v10;
  return a1;
}

{
  __float2 v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;

  __float2 v4 = __sincosf_stret(a2);
  a1[1] = v4.__cosval;
  a1[2] = v4.__sinval;
  float v5 = a2 * a2;
  if ((float)(a2 * a2) >= 0.0061)
  {
    float v8 = (float)(1.0 / a2) * v4.__sinval;
    float v10 = (float)(1.0 / a2) * (float)(1.0 - v4.__cosval);
    float v6 = (float)(1.0 / a2) * v10;
    float v9 = (float)(1.0 / a2) * (float)(1.0 - v8);
  }
  else
  {
    float v6 = 0.5 - (float)(v5 * (float)((float)(v5 / -720.0) + 0.041667));
    float v7 = 0.16667 - (float)(v5 * (float)((float)(v5 / -5040.0) + 0.0083333));
    float v8 = 1.0 - (float)(v5 * v7);
    float v9 = v7 * a2;
    float v10 = v6 * a2;
  }
  *a1 = v5;
  a1[5] = v6;
  a1[6] = v9;
  a1[3] = v8;
  a1[4] = v10;
  return a1;
}

float *cva::DifferentialExponentialCoefficients<float,2>::compute(float *result, float a2)
{
  float v2 = a2 * a2;
  *double result = a2 * a2;
  if ((float)(a2 * a2) >= 0.0061)
  {
    float v8 = 1.0 / a2;
    float v5 = (float)(1.0 / a2) * result[2];
    float v7 = (float)(1.0 / a2) * (float)(1.0 - result[1]);
    float v3 = v8 * v7;
    float v6 = v8 * (float)(1.0 - v5);
  }
  else
  {
    float v3 = 0.5 - (float)(v2 * (float)((float)(v2 / -720.0) + 0.041667));
    float v4 = 0.16667 - (float)(v2 * (float)((float)(v2 / -5040.0) + 0.0083333));
    float v5 = 1.0 - (float)(v2 * v4);
    float v6 = v4 * a2;
    float v7 = v3 * a2;
  }
  result[5] = v3;
  result[6] = v6;
  result[3] = v5;
  result[4] = v7;
  return result;
}

double *cva::DifferentialExponentialCoefficients<double,2>::DifferentialExponentialCoefficients(double *a1, double a2)
{
  __double2 v4 = __sincos_stret(a2);
  a1[1] = v4.__cosval;
  a1[2] = v4.__sinval;
  double v5 = a2 * a2;
  if (a2 * a2 >= 0.0000002635)
  {
    double v8 = 1.0 / a2 * v4.__sinval;
    double v10 = 1.0 / a2 * (1.0 - v4.__cosval);
    double v6 = 1.0 / a2 * v10;
    double v9 = 1.0 / a2 * (1.0 - v8);
  }
  else
  {
    double v6 = 0.5 - v5 * (v5 / -720.0 + 0.0416666667);
    double v7 = 0.166666667 - v5 * (v5 / -5040.0 + 0.00833333333);
    double v8 = 1.0 - v5 * v7;
    double v9 = v7 * a2;
    double v10 = v6 * a2;
  }
  *a1 = v5;
  a1[5] = v6;
  a1[6] = v9;
  a1[3] = v8;
  a1[4] = v10;
  return a1;
}

{
  __double2 v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;

  __double2 v4 = __sincos_stret(a2);
  a1[1] = v4.__cosval;
  a1[2] = v4.__sinval;
  double v5 = a2 * a2;
  if (a2 * a2 >= 0.0000002635)
  {
    double v8 = 1.0 / a2 * v4.__sinval;
    double v10 = 1.0 / a2 * (1.0 - v4.__cosval);
    double v6 = 1.0 / a2 * v10;
    double v9 = 1.0 / a2 * (1.0 - v8);
  }
  else
  {
    double v6 = 0.5 - v5 * (v5 / -720.0 + 0.0416666667);
    double v7 = 0.166666667 - v5 * (v5 / -5040.0 + 0.00833333333);
    double v8 = 1.0 - v5 * v7;
    double v9 = v7 * a2;
    double v10 = v6 * a2;
  }
  *a1 = v5;
  a1[5] = v6;
  a1[6] = v9;
  a1[3] = v8;
  a1[4] = v10;
  return a1;
}

double *cva::DifferentialExponentialCoefficients<double,2>::compute(double *result, double a2)
{
  double v2 = a2 * a2;
  *double result = a2 * a2;
  if (a2 * a2 >= 0.0000002635)
  {
    double v8 = 1.0 / a2;
    double v5 = 1.0 / a2 * result[2];
    double v7 = 1.0 / a2 * (1.0 - result[1]);
    double v3 = v8 * v7;
    double v6 = v8 * (1.0 - v5);
  }
  else
  {
    double v3 = 0.5 - v2 * (v2 / -720.0 + 0.0416666667);
    double v4 = 0.166666667 - v2 * (v2 / -5040.0 + 0.00833333333);
    double v5 = 1.0 - v2 * v4;
    double v6 = v4 * a2;
    double v7 = v3 * a2;
  }
  result[5] = v3;
  result[6] = v6;
  result[3] = v5;
  result[4] = v7;
  return result;
}

float *cva::DifferentialExponentialCoefficients<float,3>::DifferentialExponentialCoefficients(float *a1, float a2)
{
  if (a2 >= 0.0061)
  {
    float v11 = sqrtf(a2);
    __float2 v12 = __sincosf_stret(v11);
    float cosval = v12.__cosval;
    float v6 = v12.__sinval / v11;
    float v4 = (float)(1.0 / a2) * (float)(1.0 - v12.__cosval);
    float v5 = (float)(1.0 / a2) * (float)(1.0 - (float)(v12.__sinval / v11));
    float v8 = v5 - v4;
    float v9 = (float)(1.0 / a2) * (float)((float)(v12.__sinval / v11) + (float)(v4 * -2.0));
    float v10 = (float)(1.0 / a2) * (float)(v4 + (float)(v5 * -3.0));
  }
  else
  {
    float v4 = 0.5 - (float)(a2 * (float)((float)(a2 / -720.0) + 0.041667));
    float v5 = 0.16667 - (float)(a2 * (float)((float)(a2 / -5040.0) + 0.0083333));
    float v6 = 1.0 - (float)(a2 * v5);
    float cosval = 1.0 - (float)(a2 * v4);
    float v8 = (float)(a2 * (float)((float)(a2 * -0.0011905) + 0.033333)) + -0.33333;
    float v9 = (float)(a2 * (float)((float)(a2 * -0.00014881) + 0.0055556)) + -0.083333;
    float v10 = (float)(a2 * (float)((float)(a2 * -0.000016534) + 0.00079365)) + -0.016667;
  }
  a1[2] = v4;
  a1[3] = v5;
  *a1 = cosval;
  a1[1] = v6;
  a1[4] = v8;
  a1[5] = v9;
  a1[6] = v10;
  return a1;
}

{
  float v4;
  float v5;
  float v6;
  float cosval;
  float v8;
  float v9;
  float v10;
  float v11;
  __float2 v12;

  if (a2 >= 0.0061)
  {
    float v11 = sqrtf(a2);
    __float2 v12 = __sincosf_stret(v11);
    float cosval = v12.__cosval;
    float v6 = v12.__sinval / v11;
    float v4 = (float)(1.0 / a2) * (float)(1.0 - v12.__cosval);
    float v5 = (float)(1.0 / a2) * (float)(1.0 - (float)(v12.__sinval / v11));
    float v8 = v5 - v4;
    float v9 = (float)(1.0 / a2) * (float)((float)(v12.__sinval / v11) + (float)(v4 * -2.0));
    float v10 = (float)(1.0 / a2) * (float)(v4 + (float)(v5 * -3.0));
  }
  else
  {
    float v4 = 0.5 - (float)(a2 * (float)((float)(a2 / -720.0) + 0.041667));
    float v5 = 0.16667 - (float)(a2 * (float)((float)(a2 / -5040.0) + 0.0083333));
    float v6 = 1.0 - (float)(a2 * v5);
    float cosval = 1.0 - (float)(a2 * v4);
    float v8 = (float)(a2 * (float)((float)(a2 * -0.0011905) + 0.033333)) + -0.33333;
    float v9 = (float)(a2 * (float)((float)(a2 * -0.00014881) + 0.0055556)) + -0.083333;
    float v10 = (float)(a2 * (float)((float)(a2 * -0.000016534) + 0.00079365)) + -0.016667;
  }
  a1[2] = v4;
  a1[3] = v5;
  *a1 = cosval;
  a1[1] = v6;
  a1[4] = v8;
  a1[5] = v9;
  a1[6] = v10;
  return a1;
}

void cva::DifferentialExponentialCoefficients<float,3>::compute(float *a1, float a2)
{
  if (a2 >= 0.0061)
  {
    float v11 = sqrtf(a2);
    __float2 v12 = __sincosf_stret(v11);
    float cosval = v12.__cosval;
    float v6 = v12.__sinval / v11;
    float v4 = (float)(1.0 / a2) * (float)(1.0 - v12.__cosval);
    float v5 = (float)(1.0 / a2) * (float)(1.0 - (float)(v12.__sinval / v11));
    float v8 = v5 - v4;
    float v9 = (float)(1.0 / a2) * (float)((float)(v12.__sinval / v11) + (float)(v4 * -2.0));
    float v10 = (float)(1.0 / a2) * (float)(v4 + (float)(v5 * -3.0));
  }
  else
  {
    float v4 = 0.5 - (float)(a2 * (float)((float)(a2 / -720.0) + 0.041667));
    float v5 = 0.16667 - (float)(a2 * (float)((float)(a2 / -5040.0) + 0.0083333));
    float v6 = 1.0 - (float)(a2 * v5);
    float cosval = 1.0 - (float)(a2 * v4);
    float v8 = (float)(a2 * (float)((float)(a2 * -0.0011905) + 0.033333)) + -0.33333;
    float v9 = (float)(a2 * (float)((float)(a2 * -0.00014881) + 0.0055556)) + -0.083333;
    float v10 = (float)(a2 * (float)((float)(a2 * -0.000016534) + 0.00079365)) + -0.016667;
  }
  a1[2] = v4;
  a1[3] = v5;
  *a1 = cosval;
  a1[1] = v6;
  a1[4] = v8;
  a1[5] = v9;
  a1[6] = v10;
}

double *cva::DifferentialExponentialCoefficients<double,3>::DifferentialExponentialCoefficients(double *a1, double a2)
{
  if (a2 >= 0.0000002635)
  {
    double v11 = sqrt(a2);
    __double2 v12 = __sincos_stret(v11);
    double cosval = v12.__cosval;
    double v6 = v12.__sinval / v11;
    double v4 = 1.0 / a2 * (1.0 - v12.__cosval);
    double v5 = 1.0 / a2 * (1.0 - v12.__sinval / v11);
    double v8 = v5 - v4;
    double v9 = 1.0 / a2 * (v12.__sinval / v11 + v4 * -2.0);
    double v10 = 1.0 / a2 * (v4 + v5 * -3.0);
  }
  else
  {
    double v4 = 0.5 - a2 * (a2 / -720.0 + 0.0416666667);
    double v5 = 0.166666667 - a2 * (a2 / -5040.0 + 0.00833333333);
    double v6 = 1.0 - a2 * v5;
    double cosval = 1.0 - a2 * v4;
    double v8 = a2 * (a2 * -0.00119047619 + 0.0333333333) + -0.333333333;
    double v9 = a2 * (a2 * -0.000148809524 + 0.00555555556) + -0.0833333333;
    double v10 = a2 * (a2 * -0.0000165343915 + 0.000793650794) + -0.0166666667;
  }
  a1[2] = v4;
  a1[3] = v5;
  *a1 = cosval;
  a1[1] = v6;
  a1[4] = v8;
  a1[5] = v9;
  a1[6] = v10;
  return a1;
}

{
  double v4;
  double v5;
  double v6;
  double cosval;
  double v8;
  double v9;
  double v10;
  double v11;
  __double2 v12;

  if (a2 >= 0.0000002635)
  {
    double v11 = sqrt(a2);
    __double2 v12 = __sincos_stret(v11);
    double cosval = v12.__cosval;
    double v6 = v12.__sinval / v11;
    double v4 = 1.0 / a2 * (1.0 - v12.__cosval);
    double v5 = 1.0 / a2 * (1.0 - v12.__sinval / v11);
    double v8 = v5 - v4;
    double v9 = 1.0 / a2 * (v12.__sinval / v11 + v4 * -2.0);
    double v10 = 1.0 / a2 * (v4 + v5 * -3.0);
  }
  else
  {
    double v4 = 0.5 - a2 * (a2 / -720.0 + 0.0416666667);
    double v5 = 0.166666667 - a2 * (a2 / -5040.0 + 0.00833333333);
    double v6 = 1.0 - a2 * v5;
    double cosval = 1.0 - a2 * v4;
    double v8 = a2 * (a2 * -0.00119047619 + 0.0333333333) + -0.333333333;
    double v9 = a2 * (a2 * -0.000148809524 + 0.00555555556) + -0.0833333333;
    double v10 = a2 * (a2 * -0.0000165343915 + 0.000793650794) + -0.0166666667;
  }
  a1[2] = v4;
  a1[3] = v5;
  *a1 = cosval;
  a1[1] = v6;
  a1[4] = v8;
  a1[5] = v9;
  a1[6] = v10;
  return a1;
}

void cva::DifferentialExponentialCoefficients<double,3>::compute(double *a1, double a2)
{
  if (a2 >= 0.0000002635)
  {
    double v11 = sqrt(a2);
    __double2 v12 = __sincos_stret(v11);
    double cosval = v12.__cosval;
    double v6 = v12.__sinval / v11;
    double v4 = 1.0 / a2 * (1.0 - v12.__cosval);
    double v5 = 1.0 / a2 * (1.0 - v12.__sinval / v11);
    double v8 = v5 - v4;
    double v9 = 1.0 / a2 * (v12.__sinval / v11 + v4 * -2.0);
    double v10 = 1.0 / a2 * (v4 + v5 * -3.0);
  }
  else
  {
    double v4 = 0.5 - a2 * (a2 / -720.0 + 0.0416666667);
    double v5 = 0.166666667 - a2 * (a2 / -5040.0 + 0.00833333333);
    double v6 = 1.0 - a2 * v5;
    double cosval = 1.0 - a2 * v4;
    double v8 = a2 * (a2 * -0.00119047619 + 0.0333333333) + -0.333333333;
    double v9 = a2 * (a2 * -0.000148809524 + 0.00555555556) + -0.0833333333;
    double v10 = a2 * (a2 * -0.0000165343915 + 0.000793650794) + -0.0166666667;
  }
  a1[2] = v4;
  a1[3] = v5;
  *a1 = cosval;
  a1[1] = v6;
  a1[4] = v8;
  a1[5] = v9;
  a1[6] = v10;
}

uint64_t cva::adp::io::readVersion(std::string::size_type *a1, std::string *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t result = sub_2153C9660(a1, a2, a3);
  uint64_t v6 = 0;
  if (!result) {
    uint64_t v6 = 0x100000000;
  }
  *a4 = v6;
  return result;
}

uint64_t sub_2153C9660(std::string::size_type *a1, std::string *a2, uint64_t a3)
{
  cva::adp::io::PListSerializer::getPath(a1, a2, &v15);
  std::string::size_type v4 = v15;
  if (v15)
  {
    if (*(char *)(a3 + 23) >= 0) {
      double v5 = (const char *)a3;
    }
    else {
      double v5 = *(const char **)a3;
    }
    CFStringRef v6 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v5, 0x8000100u, (CFAllocatorRef)*MEMORY[0x263EFFB28]);
    CFStringRef v7 = (const __CFString *)[*(id *)v4 objectForKey:v6];
    CFStringRef v8 = v7;
    char v9 = *(unsigned char *)(v4 + 8);
    CFTypeRef cf = v7;
    char v14 = v9;
    if (v7)
    {
      CFRetain(v7);
      CFRelease(v6);
      if (cva::ItemHandler::isVectorType(&cf)) {
        cva::ItemHandler::getVector<unsigned int>();
      }
      CFStringRef v10 = v8;
    }
    else
    {
      char v14 = 0;
      CFStringRef v10 = v6;
    }
    CFRelease(v10);
  }
  double v11 = v16;
  if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  return 0;
}

void sub_2153C9828(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t cva::adp::io::writeVersion(cva::adp::io::PListSerializer *a1, std::string *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4 = *a4;
  cva::adp::io::PListSerializer::createPath(a1, a2, &v7);
  if (v7)
  {
    uint64_t v10 = 8;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, 0x20uLL, 0x49090899uLL);
    char v9 = memptr;
    int v11 = 2;
    *(void *)memptr = v4;
    cva::ItemHandler::createVector<unsigned int>();
  }
  double v5 = v8;
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  return 0;
}

void sub_2153C999C(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

double cva::SO3GroupStorage<float,cva::Matrix<float,3u,3u,false>>::SO3GroupStorage(uint64_t a1)
{
  *(_DWORD *)(a1 + 32) = 1065353216;
  *(void *)&double result = 1065353216;
  *(_OWORD *)a1 = xmmword_2154461C0;
  *(_OWORD *)(a1 + 16) = unk_2154461D0;
  return result;
}

{
  double result;

  *(_DWORD *)(a1 + 32) = 1065353216;
  *(void *)&double result = 1065353216;
  *(_OWORD *)a1 = xmmword_2154461C0;
  *(_OWORD *)(a1 + 16) = unk_2154461D0;
  return result;
}

float cva::SO3GroupStorage<float,cva::Matrix<float,3u,3u,false>>::angleInDegrees(float32x2_t *a1)
{
  float v3 = 0.0;
  uint64_t v2 = 0;
  sub_2153C9A50(a1, (float *)&v2);
  return (float)(sqrtf((float)((float)(*(float *)&v2 * *(float *)&v2) + (float)(*((float *)&v2 + 1) * *((float *)&v2 + 1)))+ (float)(v3 * v3))* 180.0)/ 3.1416;
}

void sub_2153C9A50(float32x2_t *a1, float *a2)
{
  float v4 = (float)(a1[2].f32[1] - a1[3].f32[1]) * 0.5;
  *a2 = v4;
  float v5 = (float)(a1[3].f32[0] - a1[1].f32[0]) * 0.5;
  a2[1] = v5;
  float v6 = (float)(a1->f32[1] - a1[1].f32[1]) * 0.5;
  a2[2] = v6;
  float v7 = a1->f32[0];
  float v8 = a1[2].f32[0];
  float v9 = a1[4].f32[0];
  float v10 = -1.0;
  float v11 = (float)((float)((float)(a1->f32[0] + v8) + v9) + -1.0) * 0.5;
  float v12 = (float)((float)(v5 * v5) + (float)(v4 * v4)) + (float)(v6 * v6);
  if (v11 >= -1.0 || (float)(v11 + 1.0) <= -0.00001)
  {
    BOOL v14 = v11 > 1.0;
    if ((float)(v11 + -1.0) >= 0.00001) {
      BOOL v14 = 0;
    }
    if (v11 <= 0.99 && !v14)
    {
      if (v11 <= -0.99)
      {
        float v10 = (float)((float)((float)(a1->f32[0] + v8) + v9) + -1.0) * 0.5;
        goto LABEL_17;
      }
      float v16 = acosf(v11) / sqrtf(v12);
      *a2 = v4 * v16;
      a2[1] = v5 * v16;
    }
    else
    {
      float v16 = (float)(v12 * (float)((float)(v12 * (float)((float)((float)(v12 * 5.0) / 112.0) + 0.075)) + 0.16667)) + 1.0;
      *a2 = v4 * v16;
      a2[1] = v5 * v16;
    }
    a2[2] = v6 * v16;
    return;
  }
LABEL_17:
  float v17 = asinf(sqrtf(v12));
  float v18 = (float)((float)(3.1416 - v17) * (float)(3.1416 - v17)) / (float)(1.0 - v10);
  float v19 = (float)(v7 - v10) * v18;
  float v20 = (float)(v8 - v10) * v18;
  float v21 = (float)(v9 - v10) * v18;
  if (v19 <= v20)
  {
    float v26 = v18 * 0.5;
    if (v20 <= v21)
    {
      float v33 = sqrtf(v21);
      if (v6 < 0.0) {
        float v33 = -v33;
      }
      a2[2] = v33;
      v34.i32[0] = a1[1].i32[0];
      v34.i32[1] = a1[2].i32[1];
      *(float32x2_t *)a2 = vmul_n_f32(vmul_n_f32(vadd_f32(a1[3], v34), v26), 1.0 / v33);
    }
    else
    {
      float v27 = sqrtf(v20);
      if (v5 < 0.0) {
        float v27 = -v27;
      }
      a2[1] = v27;
      float v28 = 1.0 / v27;
      float v29 = a1[3].f32[1] + a1[2].f32[1];
      *a2 = v28 * (float)(v26 * (float)(a1[1].f32[1] + a1->f32[1]));
      a2[2] = v28 * (float)(v26 * v29);
    }
  }
  else
  {
    float v22 = v18 * 0.5;
    float v23 = v22 * (float)(a1[3].f32[0] + a1[1].f32[0]);
    if (v19 <= v21)
    {
      float v30 = sqrtf(v21);
      if (v6 < 0.0) {
        float v30 = -v30;
      }
      a2[2] = v30;
      float v31 = 1.0 / v30;
      float v32 = v31 * (float)(v22 * (float)(a1[3].f32[1] + a1[2].f32[1]));
      *a2 = v31 * v23;
      a2[1] = v32;
    }
    else
    {
      float v24 = sqrtf(v19);
      if (v4 < 0.0) {
        float v24 = -v24;
      }
      *a2 = v24;
      float v25 = 1.0 / v24;
      a2[1] = v25 * (float)(v22 * (float)(a1[1].f32[1] + a1->f32[1]));
      a2[2] = v25 * v23;
    }
  }
}

float cva::SO3GroupStorage<float,cva::Matrix<float,3u,3u,false>>::angleInRadians(float32x2_t *a1)
{
  float v3 = 0.0;
  uint64_t v2 = 0;
  sub_2153C9A50(a1, (float *)&v2);
  return sqrtf((float)((float)(*(float *)&v2 * *(float *)&v2) + (float)(*((float *)&v2 + 1) * *((float *)&v2 + 1)))+ (float)(v3 * v3));
}

void cva::SO3GroupStorage<float,cva::Matrix<float,3u,3u,false>>::log(float32x2_t *a1@<X0>, uint64_t a2@<X8>)
{
  *(_DWORD *)(a2 + 8) = 0;
  *(void *)a2 = 0;
  sub_2153C9A50(a1, (float *)a2);
}

double cva::SO3GroupStorage<float,cva::Matrix<float,3u,3u,false>>::lplus(uint64_t a1, float *a2)
{
  float v4 = *a2;
  float v3 = a2[1];
  float v5 = a2[2];
  float v6 = (float)((float)(v4 * v4) + (float)(v3 * v3)) + (float)(v5 * v5);
  if (v6 >= 0.0061)
  {
    float v10 = sqrtf(v6);
    __float2 v11 = __sincosf_stret(v10);
    float cosval = v11.__cosval;
    float v8 = v11.__sinval / v10;
    float v7 = (float)(1.0 / v6) * (float)(1.0 - v11.__cosval);
  }
  else
  {
    float v7 = 0.5 - (float)(v6 * (float)((float)(v6 / -720.0) + 0.041667));
    float v8 = 1.0 - (float)(v6 * (float)(0.16667 - (float)(v6 * (float)((float)(v6 / -5040.0) + 0.0083333))));
    float cosval = 1.0 - (float)(v6 * v7);
  }
  float v12 = v3 * v7;
  float v13 = cosval + (float)((float)(v4 * v7) * v4);
  float v14 = cosval + (float)((float)(v3 * v7) * v3);
  *(float *)&v23[8] = cosval + (float)((float)(v5 * v7) * v5);
  float v15 = v3 * (float)(v4 * v7);
  float v16 = v5 * (float)(v4 * v7);
  float v17 = v5 * v12;
  float v18 = v4 * v8;
  float v19 = v5 * v8;
  *(float *)float v23 = v13;
  *(float *)&v23[1] = v15 + (float)(v5 * v8);
  float v20 = v3 * v8;
  *(float *)&v23[6] = v20 + v16;
  *(float *)&v23[7] = v17 - v18;
  *(float *)&v23[2] = v16 - v20;
  *(float *)&v23[3] = v15 - v19;
  *(float *)&v23[4] = v14;
  *(float *)&v23[5] = v17 + v18;
  v24[0] = (float *)v23;
  v24[1] = (float *)a1;
  long long v25 = 0u;
  long long v26 = 0u;
  int v27 = 0;
  sub_2153C9F40((uint64_t)&v25, v24);
  double result = *(double *)&v25;
  long long v22 = v26;
  *(_OWORD *)a1 = v25;
  *(_OWORD *)(a1 + 16) = v22;
  *(_DWORD *)(a1 + 32) = v27;
  return result;
}

__n64 sub_2153C9F40(uint64_t a1, float **a2)
{
  float v3 = *a2;
  if (*a2 == (float *)a1 || (float v4 = a2[1], v4 == (float *)a1))
  {
    int v9 = 0;
    long long v7 = 0u;
    long long v8 = 0u;
    sub_2153C9F40(&v7);
    result.n64_u64[0] = v7;
    long long v6 = v8;
    *(_OWORD *)a1 = v7;
    *(_OWORD *)(a1 + 16) = v6;
    *(_DWORD *)(a1 + 32) = v9;
  }
  else
  {
    result.n64_u32[1] = 0;
    *(float *)a1 = (float)((float)((float)(*v3 * *v4) + 0.0) + (float)(v3[3] * v4[1])) + (float)(v3[6] * v4[2]);
    *(float *)(a1 + 4) = (float)((float)((float)(v3[1] * *v4) + 0.0) + (float)(v3[4] * v4[1])) + (float)(v3[7] * v4[2]);
    *(float *)(a1 + 8) = (float)((float)((float)(v3[2] * *v4) + 0.0) + (float)(v3[5] * v4[1])) + (float)(v3[8] * v4[2]);
    *(float *)(a1 + 12) = (float)((float)((float)(*v3 * v4[3]) + 0.0) + (float)(v3[3] * v4[4])) + (float)(v3[6] * v4[5]);
    *(float *)(a1 + 16) = (float)((float)((float)(v3[1] * v4[3]) + 0.0) + (float)(v3[4] * v4[4]))
                        + (float)(v3[7] * v4[5]);
    *(float *)(a1 + 20) = (float)((float)((float)(v3[2] * v4[3]) + 0.0) + (float)(v3[5] * v4[4]))
                        + (float)(v3[8] * v4[5]);
    *(float *)(a1 + 24) = (float)((float)((float)(*v3 * v4[6]) + 0.0) + (float)(v3[3] * v4[7])) + (float)(v3[6] * v4[8]);
    *(float *)(a1 + 28) = (float)((float)((float)(v3[1] * v4[6]) + 0.0) + (float)(v3[4] * v4[7]))
                        + (float)(v3[7] * v4[8]);
    result.n64_f32[0] = (float)((float)((float)(v3[2] * v4[6]) + 0.0) + (float)(v3[5] * v4[7])) + (float)(v3[8] * v4[8]);
    *(_DWORD *)(a1 + 32) = result.n64_u32[0];
  }
  return result;
}

double cva::SO3AlgebraStorage<float,cva::MatrixRef<float const,3u,1u,false>>::SO3AlgebraStorage(void *a1, uint64_t a2)
{
  *a1 = a2;
  *(void *)&double result = 3;
  a1[1] = 3;
  return result;
}

{
  double result;

  *a1 = a2;
  *(void *)&double result = 3;
  a1[1] = 3;
  return result;
}

float cva::SO3AlgebraStorage<float,cva::MatrixRef<float const,3u,1u,false>>::exp@<S0>(float **a1@<X0>, float *a2@<X8>)
{
  float v3 = **a1;
  float v4 = (*a1)[1];
  float v5 = (*a1)[2];
  float v6 = (float)((float)(v3 * v3) + (float)(v4 * v4)) + (float)(v5 * v5);
  if (v6 >= 0.0061)
  {
    float v10 = sqrtf(v6);
    __float2 v11 = __sincosf_stret(v10);
    float cosval = v11.__cosval;
    float v8 = v11.__sinval / v10;
    float v7 = (float)(1.0 / v6) * (float)(1.0 - v11.__cosval);
  }
  else
  {
    float v7 = 0.5 - (float)(v6 * (float)((float)(v6 / -720.0) + 0.041667));
    float v8 = 1.0 - (float)(v6 * (float)(0.16667 - (float)(v6 * (float)((float)(v6 / -5040.0) + 0.0083333))));
    float cosval = 1.0 - (float)(v6 * v7);
  }
  float v12 = v3 * v7;
  float v13 = v4 * v7;
  float v14 = cosval + (float)((float)(v3 * v7) * v3);
  float v15 = cosval + (float)((float)(v5 * v7) * v5);
  float v16 = cosval + (float)(v13 * v4);
  a2[8] = v15;
  float v17 = v4 * v12;
  float v18 = v5 * v12;
  float v19 = v5 * v13;
  float v20 = v3 * v8;
  float v21 = v4 * v8;
  float v22 = v5 * v8;
  *a2 = v14;
  a2[1] = v17 + v22;
  a2[6] = v21 + v18;
  a2[7] = v19 - v20;
  a2[2] = v18 - v21;
  a2[3] = v17 - v22;
  float result = v19 + v20;
  a2[4] = v16;
  a2[5] = v19 + v20;
  return result;
}

double cva::SO3GroupStorage<float,cva::Matrix<float,3u,3u,false>>::rplus(uint64_t a1, float *a2)
{
  float v4 = *a2;
  float v3 = a2[1];
  float v5 = a2[2];
  float v6 = (float)((float)(v4 * v4) + (float)(v3 * v3)) + (float)(v5 * v5);
  if (v6 >= 0.0061)
  {
    float v10 = sqrtf(v6);
    __float2 v11 = __sincosf_stret(v10);
    float cosval = v11.__cosval;
    float v8 = v11.__sinval / v10;
    float v7 = (float)(1.0 / v6) * (float)(1.0 - v11.__cosval);
  }
  else
  {
    float v7 = 0.5 - (float)(v6 * (float)((float)(v6 / -720.0) + 0.041667));
    float v8 = 1.0 - (float)(v6 * (float)(0.16667 - (float)(v6 * (float)((float)(v6 / -5040.0) + 0.0083333))));
    float cosval = 1.0 - (float)(v6 * v7);
  }
  float v12 = v3 * v7;
  float v13 = cosval + (float)((float)(v4 * v7) * v4);
  float v14 = cosval + (float)((float)(v3 * v7) * v3);
  *(float *)&v23[8] = cosval + (float)((float)(v5 * v7) * v5);
  float v15 = v3 * (float)(v4 * v7);
  float v16 = v5 * (float)(v4 * v7);
  float v17 = v5 * v12;
  float v18 = v4 * v8;
  float v19 = v5 * v8;
  *(float *)float v23 = v13;
  *(float *)&v23[1] = v15 + (float)(v5 * v8);
  float v20 = v3 * v8;
  *(float *)&v23[6] = v20 + v16;
  *(float *)&v23[7] = v17 - v18;
  *(float *)&v23[2] = v16 - v20;
  *(float *)&v23[3] = v15 - v19;
  *(float *)&v23[4] = v14;
  *(float *)&v23[5] = v17 + v18;
  v24[0] = (float *)a1;
  v24[1] = (float *)v23;
  long long v25 = 0u;
  long long v26 = 0u;
  int v27 = 0;
  sub_2153C9F40((uint64_t)&v25, v24);
  double result = *(double *)&v25;
  long long v22 = v26;
  *(_OWORD *)a1 = v25;
  *(_OWORD *)(a1 + 16) = v22;
  *(_DWORD *)(a1 + 32) = v27;
  return result;
}

float *cva::SO3GroupStorage<float,cva::Matrix<float,3u,3u,false>>::transform@<X0>(float *a1@<X0>, float *a2@<X1>, uint64_t a3@<X8>)
{
  v4[0] = a1;
  v4[1] = a2;
  *(void *)a3 = 0;
  *(_DWORD *)(a3 + 8) = 0;
  return sub_2153CA404((float *)a3, v4);
}

float *sub_2153CA404(float *result, float **a2)
{
  uint64_t v2 = result;
  float v3 = *a2;
  if (*a2 == result || (float v4 = a2[1], v4 == result))
  {
    int v6 = 0;
    uint64_t v5 = 0;
    double result = (float *)sub_2153CA404(&v5);
    *(void *)uint64_t v2 = v5;
    *((_DWORD *)v2 + 2) = v6;
  }
  else
  {
    *double result = (float)((float)((float)(*v3 * *v4) + 0.0) + (float)(v3[3] * v4[1])) + (float)(v3[6] * v4[2]);
    result[1] = (float)((float)((float)(v3[1] * *v4) + 0.0) + (float)(v3[4] * v4[1])) + (float)(v3[7] * v4[2]);
    result[2] = (float)((float)((float)(v3[2] * *v4) + 0.0) + (float)(v3[5] * v4[1])) + (float)(v3[8] * v4[2]);
  }
  return result;
}

float *cva::SO3GroupStorage<float,cva::Matrix<float,3u,3u,false>>::inverseTransform@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = a1;
  v5[0] = &v4;
  v5[1] = a2;
  *(void *)a3 = 0;
  *(_DWORD *)(a3 + 8) = 0;
  return sub_2153CA514((float *)a3, (uint64_t)v5);
}

float *sub_2153CA514(float *result, uint64_t a2)
{
  uint64_t v2 = result;
  float v3 = *(float **)(a2 + 8);
  if (v3 == result)
  {
    int v6 = 0;
    uint64_t v5 = 0;
    double result = (float *)sub_2153CA514(&v5);
    *(void *)uint64_t v2 = v5;
    *((_DWORD *)v2 + 2) = v6;
  }
  else
  {
    uint64_t v4 = **(float ***)a2;
    *double result = (float)((float)((float)(v4[1] * v3[1]) + (float)(*v4 * *v3)) + 0.0) + (float)(v4[2] * v3[2]);
    result[1] = (float)((float)((float)(v4[4] * v3[1]) + (float)(v4[3] * *v3)) + 0.0) + (float)(v4[5] * v3[2]);
    result[2] = (float)((float)((float)(v4[7] * v3[1]) + (float)(v4[6] * *v3)) + 0.0) + (float)(v4[8] * v3[2]);
  }
  return result;
}

float cva::SO3GroupStorage<float,cva::Matrix<float,3u,3u,false>>::transformJacobian@<S0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  *(_DWORD *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  float v3 = *(float *)(a1 + 4);
  float result = *(float *)(a1 + 8);
  float v4 = *(float *)a1;
  if (a1 == a2)
  {
    float v5 = -*(float *)a1;
    *(_DWORD *)a1 = 0;
    *(float *)(a1 + 4) = -result;
    *(float *)(a1 + 8) = v3;
    *(float *)(a1 + 12) = result;
    *(_DWORD *)(a1 + 16) = 0;
    *(float *)(a1 + 20) = v5;
    *(float *)(a1 + 24) = -v3;
    *(float *)(a1 + 28) = v4;
    *(_DWORD *)(a1 + 32) = 0;
  }
  else
  {
    *(float *)(a2 + 4) = -result;
    *(float *)(a2 + 8) = v3;
    *(float *)(a2 + 12) = result;
    float result = -v4;
    *(float *)(a2 + 20) = -v4;
    *(float *)(a2 + 24) = -v3;
    *(float *)(a2 + 28) = v4;
  }
  return result;
}

float cva::SO3GroupStorage<float,cva::Matrix<float,3u,3u,false>>::inverseTransformJacobian@<S0>(float *a1@<X0>, float *a2@<X1>, float *a3@<X8>)
{
  float v3 = a1[1];
  float v4 = a1[2];
  float v5 = a1[3];
  float v6 = a1[4];
  float v7 = a1[5];
  float v8 = a1[6];
  float v9 = a1[7];
  float v10 = a1[8];
  float v12 = a2[1];
  float v11 = a2[2];
  float v13 = (float)(v3 * v11) - (float)(v4 * v12);
  float v14 = (float)(v6 * v11) - (float)(v7 * v12);
  float v15 = (float)(v9 * v11) - (float)(v10 * v12);
  float v16 = (float)(v4 * *a2) - (float)(*a1 * v11);
  float v17 = (float)(v7 * *a2) - (float)(v5 * v11);
  float v18 = (float)(v10 * *a2) - (float)(v8 * v11);
  float result = (float)(*a1 * v12) - (float)(v3 * *a2);
  float v20 = (float)(v5 * v12) - (float)(v6 * *a2);
  float v21 = v9 * *a2;
  *a3 = v13;
  a3[1] = v14;
  a3[2] = v15;
  a3[3] = v16;
  a3[4] = v17;
  a3[5] = v18;
  a3[6] = result;
  a3[7] = v20;
  a3[8] = (float)(v8 * v12) - v21;
  return result;
}

uint64_t cva::SO3AlgebraStorage<float,cva::Matrix<float,3u,1u,false>>::SO3AlgebraStorage(uint64_t result)
{
  *(_DWORD *)(result + 8) = 0;
  *(void *)float result = 0;
  return result;
}

{
  *(_DWORD *)(result + 8) = 0;
  *(void *)float result = 0;
  return result;
}

float cva::SO3GroupStorage<float,cva::Matrix<float,3u,3u,false>>::logJacobian@<S0>(float32x2_t *a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  sub_2153C9A50(a1, (float *)a2);
  float v3 = *(float *)a2;
  float v4 = *(float *)(a2 + 4);
  float v5 = *(float *)(a2 + 8);
  float v6 = (float)((float)(v3 * v3) + (float)(v4 * v4)) + (float)(v5 * v5);
  if (v6 >= 0.0061)
  {
    float v11 = sqrtf(v6);
    __float2 v12 = __sincosf_stret(v11);
    float cosval = v12.__cosval;
    float v9 = v12.__sinval / v11;
    float v7 = (float)(1.0 / v6) * (float)(1.0 - v12.__cosval);
    float v8 = (float)(1.0 / v6) * (float)(1.0 - (float)(v12.__sinval / v11));
  }
  else
  {
    float v7 = 0.5 - (float)(v6 * (float)((float)(v6 / -720.0) + 0.041667));
    float v8 = 0.16667 - (float)(v6 * (float)((float)(v6 / -5040.0) + 0.0083333));
    float v9 = 1.0 - (float)(v6 * v8);
    float cosval = 1.0 - (float)(v6 * v7);
  }
  float v13 = (float)-(float)(v8 - (float)(v7 * 0.5)) / v9;
  float v14 = (float)(v7 + (float)(v9 * -0.5)) / (float)(1.0 - cosval);
  if (cosval >= 0.9) {
    float v14 = v13;
  }
  float v15 = 1.0 - (float)(v6 * v14);
  float v16 = v3 * v14;
  float v17 = v14 * v4;
  float v18 = v15 + (float)((float)(v3 * v14) * v3);
  float v19 = v15 + (float)((float)(v14 * v5) * v5);
  float v20 = v15 + (float)(v17 * v4);
  *(float *)(a2 + 44) = v19;
  float v21 = v16 * v4;
  float v22 = v16 * v5;
  float v23 = v17 * v5;
  *(float *)(a2 + 12) = v18;
  *(float *)(a2 + 16) = v21 + (float)(v5 * -0.5);
  *(float *)(a2 + 36) = (float)(v4 * -0.5) + v22;
  *(float *)(a2 + 40) = v23 - (float)(v3 * -0.5);
  *(float *)(a2 + 20) = v22 - (float)(v4 * -0.5);
  *(float *)(a2 + 24) = v21 - (float)(v5 * -0.5);
  float result = v23 + (float)(v3 * -0.5);
  *(float *)(a2 + 28) = v20;
  *(float *)(a2 + 32) = result;
  return result;
}

float cva::SO3GroupStorage<float,cva::Matrix<float,3u,3u,false>>::inverse@<S0>(uint64_t a1@<X0>, _DWORD *a2@<X8>)
{
  float result = *(float *)a1;
  int v3 = *(_DWORD *)(a1 + 4);
  int v4 = *(_DWORD *)(a1 + 24);
  int v5 = *(_DWORD *)(a1 + 28);
  int v7 = *(_DWORD *)(a1 + 8);
  int v6 = *(_DWORD *)(a1 + 12);
  int v8 = *(_DWORD *)(a1 + 16);
  int v9 = *(_DWORD *)(a1 + 20);
  int v10 = *(_DWORD *)(a1 + 32);
  *a2 = *(_DWORD *)a1;
  a2[1] = v6;
  a2[2] = v4;
  a2[3] = v3;
  a2[4] = v8;
  a2[5] = v5;
  a2[6] = v7;
  a2[7] = v9;
  a2[8] = v10;
  return result;
}

__n128 cva::SO3GroupStorage<float,cva::Matrix<float,3u,3u,false>>::adjoint@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  __n128 result = *(__n128 *)a1;
  long long v3 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *(_OWORD *)(a2 + 16) = v3;
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(a1 + 32);
  return result;
}

float32_t cva::SO3GroupStorage<float,cva::Matrix<float,3u,3u,false>>::enforce(float32x2_t *a1)
{
  float v30 = 0.0;
  uint64_t v29 = 0;
  sub_2153C9A50(a1, (float *)&v29);
  float v2 = *((float *)&v29 + 1);
  float v3 = *(float *)&v29;
  float v4 = *((float *)&v29 + 1) * *((float *)&v29 + 1);
  float v5 = v30;
  float v6 = (float)((float)(*((float *)&v29 + 1) * *((float *)&v29 + 1)) + (float)(v3 * v3)) + (float)(v5 * v5);
  if (v6 > 9.8696)
  {
    float v7 = sqrtf(v6) / 3.1416;
    float v8 = ceilf(v7) + -1.0;
    int v9 = (int)v8;
    float v10 = v7 - v8;
    if (v9) {
      float v10 = v10 + -1.0;
    }
    float v11 = v10 / v7;
    float v3 = *(float *)&v29 * v11;
    float v2 = *((float *)&v29 + 1) * v11;
    float v5 = v30 * v11;
    float v4 = v2 * v2;
  }
  float v12 = (float)((float)(v3 * v3) + v4) + (float)(v5 * v5);
  if (v12 >= 0.0061)
  {
    float v16 = sqrtf(v12);
    __float2 v17 = __sincosf_stret(v16);
    float cosval = v17.__cosval;
    float v14 = v17.__sinval / v16;
    float v13 = (float)(1.0 / v12) * (float)(1.0 - v17.__cosval);
  }
  else
  {
    float v13 = 0.5 - (float)(v12 * (float)((float)(v12 / -720.0) + 0.041667));
    float v14 = 1.0 - (float)(v12 * (float)(0.16667 - (float)(v12 * (float)((float)(v12 / -5040.0) + 0.0083333))));
    float cosval = 1.0 - (float)(v12 * v13);
  }
  float v18 = v3 * v13;
  float v19 = v2 * v13;
  float32_t v20 = cosval + (float)((float)(v3 * v13) * v3);
  float32_t v21 = cosval + (float)((float)(v2 * v13) * v2);
  float32_t result = cosval + (float)((float)(v5 * v13) * v5);
  float v23 = v2 * v18;
  float v24 = v5 * v18;
  float v25 = v5 * v19;
  float v26 = v3 * v14;
  float v27 = v2 * v14;
  float v28 = v5 * v14;
  a1->f32[0] = v20;
  a1->f32[1] = v23 + v28;
  a1[1].f32[0] = v24 - v27;
  a1[1].f32[1] = v23 - v28;
  a1[2].f32[0] = v21;
  a1[2].f32[1] = v26 + v25;
  a1[3].f32[0] = v27 + v24;
  a1[3].f32[1] = v25 - v26;
  a1[4].f32[0] = result;
  return result;
}

float cva::SO3AlgebraStorage<float,cva::Matrix<float,3u,1u,false>>::enforce(float *a1)
{
  float v2 = *a1;
  float result = a1[1];
  float v3 = a1[2];
  float v4 = (float)((float)(result * result) + (float)(v2 * v2)) + (float)(v3 * v3);
  if (v4 > 9.8696)
  {
    float v5 = sqrtf(v4) / 3.1416;
    float v6 = ceilf(v5) + -1.0;
    int v7 = (int)v6;
    float v8 = v5 - v6;
    if (v7) {
      float v8 = v8 + -1.0;
    }
    float v9 = v8 / v5;
    *a1 = v2 * v9;
    a1[1] = result * v9;
    float result = v3 * v9;
    a1[2] = v3 * v9;
  }
  return result;
}

float cva::SO3AlgebraStorage<float,cva::Matrix<float,3u,1u,false>>::exp@<S0>(float *a1@<X0>, float *a2@<X8>)
{
  float v3 = *a1;
  float v4 = a1[1];
  float v5 = a1[2];
  float v6 = (float)((float)(v3 * v3) + (float)(v4 * v4)) + (float)(v5 * v5);
  if (v6 >= 0.0061)
  {
    float v10 = sqrtf(v6);
    __float2 v11 = __sincosf_stret(v10);
    float cosval = v11.__cosval;
    float v8 = v11.__sinval / v10;
    float v7 = (float)(1.0 / v6) * (float)(1.0 - v11.__cosval);
  }
  else
  {
    float v7 = 0.5 - (float)(v6 * (float)((float)(v6 / -720.0) + 0.041667));
    float v8 = 1.0 - (float)(v6 * (float)(0.16667 - (float)(v6 * (float)((float)(v6 / -5040.0) + 0.0083333))));
    float cosval = 1.0 - (float)(v6 * v7);
  }
  float v12 = v3 * v7;
  float v13 = v7 * v4;
  float v14 = cosval + (float)((float)(v3 * v7) * v3);
  float v15 = cosval + (float)((float)(v7 * v5) * v5);
  float v16 = cosval + (float)(v13 * v4);
  a2[8] = v15;
  float v17 = v12 * v4;
  float v18 = v12 * v5;
  float v19 = v13 * v5;
  float v20 = v3 * v8;
  float v21 = v8 * v4;
  float v22 = v8 * v5;
  *a2 = v14;
  a2[1] = v17 + v22;
  a2[6] = v21 + v18;
  a2[7] = v19 - v20;
  a2[2] = v18 - v21;
  a2[3] = v17 - v22;
  float result = v20 + v19;
  a2[4] = v16;
  a2[5] = v20 + v19;
  return result;
}

uint64_t cva::SO3GroupStorage<float,cva::Matrix<float,3u,3u,false>>::serialize()
{
  return std::ostream::write();
}

uint64_t cva::SO3GroupStorage<float,cva::Matrix<float,3u,3u,false>>::deserialize(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x270F98678](a2, a1, 36);
}

double cva::SO3GroupStorage<double,cva::Matrix<double,3u,3u,false>>::SO3GroupStorage(uint64_t a1)
{
  *(void *)(a1 + 64) = 0x3FF0000000000000;
  *(_OWORD *)a1 = xmmword_215446208;
  *(_OWORD *)(a1 + 16) = unk_215446218;
  double result = 1.0;
  *(_OWORD *)(a1 + 32) = xmmword_215446228;
  *(_OWORD *)(a1 + 48) = unk_215446238;
  return result;
}

{
  double result;

  *(void *)(a1 + 64) = 0x3FF0000000000000;
  *(_OWORD *)a1 = xmmword_215446208;
  *(_OWORD *)(a1 + 16) = unk_215446218;
  double result = 1.0;
  *(_OWORD *)(a1 + 32) = xmmword_215446228;
  *(_OWORD *)(a1 + 48) = unk_215446238;
  return result;
}

double cva::SO3GroupStorage<double,cva::Matrix<double,3u,3u,false>>::angleInDegrees(float64x2_t *a1)
{
  double v2 = 0.0;
  double v3 = 0.0;
  double v4 = 0.0;
  sub_2153CAD38(a1, &v2);
  return sqrt(v2 * v2 + v3 * v3 + v4 * v4) * 180.0 / 3.14159265;
}

void sub_2153CAD38(float64x2_t *a1, double *a2)
{
  double v4 = (a1[2].f64[1] - a1[3].f64[1]) * 0.5;
  *a2 = v4;
  double v5 = (a1[3].f64[0] - a1[1].f64[0]) * 0.5;
  a2[1] = v5;
  double v6 = (a1->f64[1] - a1[1].f64[1]) * 0.5;
  a2[2] = v6;
  double v7 = a1->f64[0];
  double v8 = a1[2].f64[0];
  double v9 = a1[4].f64[0];
  double v10 = -1.0;
  double v11 = (a1->f64[0] + v8 + v9 + -1.0) * 0.5;
  double v12 = v5 * v5 + v4 * v4 + v6 * v6;
  if (v11 >= -1.0 || v11 + 1.0 <= -0.00001)
  {
    BOOL v13 = v11 > 1.0;
    if (v11 + -1.0 >= 0.00001) {
      BOOL v13 = 0;
    }
    if (v11 > 0.99 || v13)
    {
      double v15 = v12 * (v12 * (v12 * 5.0 / 112.0 + 0.075) + 0.166666667) + 1.0;
LABEL_12:
      *a2 = v4 * v15;
      a2[1] = v5 * v15;
      a2[2] = v6 * v15;
      return;
    }
    if (v11 > -0.99)
    {
      double v15 = acos(v11) / sqrt(v12);
      goto LABEL_12;
    }
    double v10 = (a1->f64[0] + v8 + v9 + -1.0) * 0.5;
  }
  long double v16 = asin(sqrt(v12));
  double v17 = (3.14159265 - v16) * (3.14159265 - v16) / (1.0 - v10);
  double v18 = (v7 - v10) * v17;
  double v19 = (v8 - v10) * v17;
  double v20 = (v9 - v10) * v17;
  if (v18 <= v19)
  {
    double v25 = v17 * 0.5;
    if (v19 <= v20)
    {
      double v32 = sqrt(v20);
      if (v6 < 0.0) {
        double v32 = -v32;
      }
      a2[2] = v32;
      v33.f64[0] = a1[1].f64[0];
      v33.f64[1] = a1[2].f64[1];
      *(float64x2_t *)a2 = vmulq_n_f64(vmulq_n_f64(vaddq_f64(a1[3], v33), v25), 1.0 / v32);
    }
    else
    {
      double v26 = sqrt(v19);
      if (v5 < 0.0) {
        double v26 = -v26;
      }
      a2[1] = v26;
      double v27 = 1.0 / v26;
      float64_t v28 = a1[3].f64[1] + a1[2].f64[1];
      *a2 = v27 * (v25 * (a1[1].f64[1] + a1->f64[1]));
      a2[2] = v27 * (v25 * v28);
    }
  }
  else
  {
    double v21 = v17 * 0.5;
    double v22 = v21 * (a1[3].f64[0] + a1[1].f64[0]);
    if (v18 <= v20)
    {
      double v29 = sqrt(v20);
      if (v6 < 0.0) {
        double v29 = -v29;
      }
      a2[2] = v29;
      double v30 = 1.0 / v29;
      double v31 = v30 * (v21 * (a1[3].f64[1] + a1[2].f64[1]));
      *a2 = v30 * v22;
      a2[1] = v31;
    }
    else
    {
      double v23 = sqrt(v18);
      if (v4 < 0.0) {
        double v23 = -v23;
      }
      *a2 = v23;
      double v24 = 1.0 / v23;
      a2[1] = v24 * (v21 * (a1[1].f64[1] + a1->f64[1]));
      a2[2] = v24 * v22;
    }
  }
}

double cva::SO3GroupStorage<double,cva::Matrix<double,3u,3u,false>>::angleInRadians(float64x2_t *a1)
{
  double v2 = 0.0;
  double v3 = 0.0;
  double v4 = 0.0;
  sub_2153CAD38(a1, &v2);
  return sqrt(v2 * v2 + v3 * v3 + v4 * v4);
}

void cva::SO3GroupStorage<double,cva::Matrix<double,3u,3u,false>>::log(float64x2_t *a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  sub_2153CAD38(a1, (double *)a2);
}

__n128 cva::SO3GroupStorage<double,cva::Matrix<double,3u,3u,false>>::lplus(uint64_t a1, double *a2)
{
  double v4 = *a2;
  double v3 = a2[1];
  double v5 = a2[2];
  double v6 = v4 * v4 + v3 * v3 + v5 * v5;
  if (v6 >= 0.0000002635)
  {
    double v10 = sqrt(v6);
    __double2 v11 = __sincos_stret(v10);
    double cosval = v11.__cosval;
    double v8 = v11.__sinval / v10;
    double v7 = 1.0 / v6 * (1.0 - v11.__cosval);
  }
  else
  {
    double v7 = 0.5 - v6 * (v6 / -720.0 + 0.0416666667);
    double v8 = 1.0 - v6 * (0.166666667 - v6 * (v6 / -5040.0 + 0.00833333333));
    double cosval = 1.0 - v6 * v7;
  }
  double v12 = v3 * v7;
  double v13 = cosval + v4 * v7 * v4;
  double v14 = cosval + v3 * v7 * v3;
  *(double *)&v23[8] = cosval + v5 * v7 * v5;
  double v15 = v3 * (v4 * v7);
  double v16 = v5 * (v4 * v7);
  double v17 = v5 * v12;
  double v18 = v4 * v8;
  double v19 = v5 * v8;
  *(double *)double v23 = v13;
  *(double *)&v23[1] = v15 + v5 * v8;
  double v20 = v3 * v8;
  *(double *)&v23[6] = v20 + v16;
  *(double *)&v23[7] = v17 - v18;
  *(double *)&v23[2] = v16 - v20;
  *(double *)&v23[3] = v15 - v19;
  *(double *)&v23[4] = v14;
  *(double *)&v23[5] = v17 + v18;
  v24[0] = (double *)v23;
  v24[1] = (double *)a1;
  long long v25 = 0u;
  __n128 v26 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  uint64_t v29 = 0;
  sub_2153CB228((uint64_t)&v25, v24);
  long long v21 = v28;
  *(_OWORD *)(a1 + 32) = v27;
  *(_OWORD *)(a1 + 48) = v21;
  *(void *)(a1 + 64) = v29;
  __n128 result = v26;
  *(_OWORD *)a1 = v25;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 sub_2153CB228(uint64_t a1, double **a2)
{
  double v3 = *a2;
  if (*a2 == (double *)a1 || (double v4 = a2[1], v4 == (double *)a1))
  {
    uint64_t v11 = 0;
    long long v9 = 0u;
    long long v10 = 0u;
    long long v7 = 0u;
    __n128 v8 = 0u;
    sub_2153CB228(&v7);
    long long v6 = v10;
    *(_OWORD *)(a1 + 32) = v9;
    *(_OWORD *)(a1 + 48) = v6;
    *(void *)(a1 + 64) = v11;
    __n128 result = v8;
    *(_OWORD *)a1 = v7;
    *(__n128 *)(a1 + 16) = result;
  }
  else
  {
    *(double *)a1 = *v3 * *v4 + 0.0 + v3[3] * v4[1] + v3[6] * v4[2];
    *(double *)(a1 + 8) = v3[1] * *v4 + 0.0 + v3[4] * v4[1] + v3[7] * v4[2];
    *(double *)(a1 + 16) = v3[2] * *v4 + 0.0 + v3[5] * v4[1] + v3[8] * v4[2];
    *(double *)(a1 + 24) = *v3 * v4[3] + 0.0 + v3[3] * v4[4] + v3[6] * v4[5];
    *(double *)(a1 + 32) = v3[1] * v4[3] + 0.0 + v3[4] * v4[4] + v3[7] * v4[5];
    *(double *)(a1 + 40) = v3[2] * v4[3] + 0.0 + v3[5] * v4[4] + v3[8] * v4[5];
    *(double *)(a1 + 48) = *v3 * v4[6] + 0.0 + v3[3] * v4[7] + v3[6] * v4[8];
    *(double *)(a1 + 56) = v3[1] * v4[6] + 0.0 + v3[4] * v4[7] + v3[7] * v4[8];
    result.n128_f64[0] = v3[2] * v4[6] + 0.0 + v3[5] * v4[7] + v3[8] * v4[8];
    *(void *)(a1 + 64) = result.n128_u64[0];
  }
  return result;
}

double cva::SO3AlgebraStorage<double,cva::MatrixRef<double const,3u,1u,false>>::SO3AlgebraStorage(void *a1, uint64_t a2)
{
  *a1 = a2;
  *(void *)&double result = 3;
  a1[1] = 3;
  return result;
}

{
  double result;

  *a1 = a2;
  *(void *)&double result = 3;
  a1[1] = 3;
  return result;
}

double cva::SO3AlgebraStorage<double,cva::MatrixRef<double const,3u,1u,false>>::exp@<D0>(double **a1@<X0>, double *a2@<X8>)
{
  double v3 = **a1;
  double v4 = (*a1)[1];
  double v5 = (*a1)[2];
  double v6 = v3 * v3 + v4 * v4 + v5 * v5;
  if (v6 >= 0.0000002635)
  {
    double v10 = sqrt(v6);
    __double2 v11 = __sincos_stret(v10);
    double cosval = v11.__cosval;
    double v8 = v11.__sinval / v10;
    double v7 = 1.0 / v6 * (1.0 - v11.__cosval);
  }
  else
  {
    double v7 = 0.5 - v6 * (v6 / -720.0 + 0.0416666667);
    double v8 = 1.0 - v6 * (0.166666667 - v6 * (v6 / -5040.0 + 0.00833333333));
    double cosval = 1.0 - v6 * v7;
  }
  double v12 = v3 * v7;
  double v13 = v4 * v7;
  double v14 = cosval + v3 * v7 * v3;
  double v15 = cosval + v5 * v7 * v5;
  double v16 = cosval + v13 * v4;
  a2[8] = v15;
  double v17 = v4 * v12;
  double v18 = v5 * v12;
  double v19 = v5 * v13;
  double v20 = v3 * v8;
  double v21 = v4 * v8;
  double v22 = v5 * v8;
  *a2 = v14;
  a2[1] = v17 + v22;
  a2[6] = v21 + v18;
  a2[7] = v19 - v20;
  a2[2] = v18 - v21;
  a2[3] = v17 - v22;
  double result = v19 + v20;
  a2[4] = v16;
  a2[5] = v19 + v20;
  return result;
}

__n128 cva::SO3GroupStorage<double,cva::Matrix<double,3u,3u,false>>::rplus(uint64_t a1, double *a2)
{
  double v4 = *a2;
  double v3 = a2[1];
  double v5 = a2[2];
  double v6 = v4 * v4 + v3 * v3 + v5 * v5;
  if (v6 >= 0.0000002635)
  {
    double v10 = sqrt(v6);
    __double2 v11 = __sincos_stret(v10);
    double cosval = v11.__cosval;
    double v8 = v11.__sinval / v10;
    double v7 = 1.0 / v6 * (1.0 - v11.__cosval);
  }
  else
  {
    double v7 = 0.5 - v6 * (v6 / -720.0 + 0.0416666667);
    double v8 = 1.0 - v6 * (0.166666667 - v6 * (v6 / -5040.0 + 0.00833333333));
    double cosval = 1.0 - v6 * v7;
  }
  double v12 = v3 * v7;
  double v13 = cosval + v4 * v7 * v4;
  double v14 = cosval + v3 * v7 * v3;
  *(double *)&v23[8] = cosval + v5 * v7 * v5;
  double v15 = v3 * (v4 * v7);
  double v16 = v5 * (v4 * v7);
  double v17 = v5 * v12;
  double v18 = v4 * v8;
  double v19 = v5 * v8;
  *(double *)double v23 = v13;
  *(double *)&v23[1] = v15 + v5 * v8;
  double v20 = v3 * v8;
  *(double *)&v23[6] = v20 + v16;
  *(double *)&v23[7] = v17 - v18;
  *(double *)&v23[2] = v16 - v20;
  *(double *)&v23[3] = v15 - v19;
  *(double *)&v23[4] = v14;
  *(double *)&v23[5] = v17 + v18;
  v24[0] = (double *)a1;
  v24[1] = (double *)v23;
  long long v25 = 0u;
  __n128 v26 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  uint64_t v29 = 0;
  sub_2153CB228((uint64_t)&v25, v24);
  long long v21 = v28;
  *(_OWORD *)(a1 + 32) = v27;
  *(_OWORD *)(a1 + 48) = v21;
  *(void *)(a1 + 64) = v29;
  __n128 result = v26;
  *(_OWORD *)a1 = v25;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

double cva::SO3GroupStorage<double,cva::Matrix<double,3u,3u,false>>::transform@<D0>(double *a1@<X0>, double *a2@<X1>, void *a3@<X8>)
{
  v4[0] = a1;
  v4[1] = a2;
  a3[1] = 0;
  a3[2] = 0;
  *a3 = 0;
  return sub_2153CB718((uint64_t)a3, v4);
}

double sub_2153CB718(uint64_t a1, double **a2)
{
  double v3 = *a2;
  if (*a2 == (double *)a1 || (double v4 = a2[1], v4 == (double *)a1))
  {
    long long v6 = 0uLL;
    uint64_t v7 = 0;
    sub_2153CB718(&v6);
    double result = *(double *)&v6;
    *(_OWORD *)a1 = v6;
    *(void *)(a1 + 16) = v7;
  }
  else
  {
    *(double *)a1 = *v3 * *v4 + 0.0 + v3[3] * v4[1] + v3[6] * v4[2];
    *(double *)(a1 + 8) = v3[1] * *v4 + 0.0 + v3[4] * v4[1] + v3[7] * v4[2];
    double result = v3[2] * *v4 + 0.0 + v3[5] * v4[1] + v3[8] * v4[2];
    *(double *)(a1 + 16) = result;
  }
  return result;
}

double cva::SO3GroupStorage<double,cva::Matrix<double,3u,3u,false>>::inverseTransform@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v4 = a1;
  v5[0] = &v4;
  v5[1] = a2;
  a3[1] = 0;
  a3[2] = 0;
  *a3 = 0;
  return sub_2153CB828((uint64_t)a3, (uint64_t)v5);
}

double sub_2153CB828(uint64_t a1, uint64_t a2)
{
  double v3 = *(double **)(a2 + 8);
  if (v3 == (double *)a1)
  {
    long long v6 = 0uLL;
    uint64_t v7 = 0;
    sub_2153CB828(&v6);
    double result = *(double *)&v6;
    *(_OWORD *)a1 = v6;
    *(void *)(a1 + 16) = v7;
  }
  else
  {
    uint64_t v4 = **(double ***)a2;
    *(double *)a1 = v4[1] * v3[1] + *v4 * *v3 + 0.0 + v4[2] * v3[2];
    *(double *)(a1 + 8) = v4[4] * v3[1] + v4[3] * *v3 + 0.0 + v4[5] * v3[2];
    double result = v4[7] * v3[1] + v4[6] * *v3 + 0.0 + v4[8] * v3[2];
    *(double *)(a1 + 16) = result;
  }
  return result;
}

double cva::SO3GroupStorage<double,cva::Matrix<double,3u,3u,false>>::transformJacobian@<D0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 64) = 0;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  double v3 = *(double *)(a1 + 8);
  double result = *(double *)(a1 + 16);
  double v4 = *(double *)a1;
  if (a1 == a2)
  {
    double v5 = -*(double *)a1;
    *(void *)a1 = 0;
    *(double *)(a1 + 8) = -result;
    *(double *)(a1 + 16) = v3;
    *(double *)(a1 + 24) = result;
    *(void *)(a1 + 32) = 0;
    *(double *)(a1 + 40) = v5;
    *(double *)(a1 + 48) = -v3;
    *(double *)(a1 + 56) = v4;
    *(void *)(a1 + 64) = 0;
  }
  else
  {
    *(double *)(a2 + 8) = -result;
    *(double *)(a2 + 16) = v3;
    *(double *)(a2 + 24) = result;
    double result = -v4;
    *(double *)(a2 + 40) = -v4;
    *(double *)(a2 + 48) = -v3;
    *(double *)(a2 + 56) = v4;
  }
  return result;
}

double cva::SO3GroupStorage<double,cva::Matrix<double,3u,3u,false>>::inverseTransformJacobian@<D0>(double *a1@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  double v3 = a1[1];
  double v4 = a1[2];
  double v5 = a1[3];
  double v6 = a1[4];
  double v7 = a1[5];
  double v8 = a1[6];
  double v9 = a1[7];
  double v10 = a1[8];
  double v12 = a2[1];
  double v11 = a2[2];
  double v13 = v3 * v11 - v4 * v12;
  double v14 = v6 * v11 - v7 * v12;
  double v15 = v9 * v11 - v10 * v12;
  double v16 = v4 * *a2 - *a1 * v11;
  double v17 = v7 * *a2 - v5 * v11;
  double v18 = v10 * *a2 - v8 * v11;
  double result = *a1 * v12 - v3 * *a2;
  double v20 = v5 * v12 - v6 * *a2;
  double v21 = v9 * *a2;
  *a3 = v13;
  a3[1] = v14;
  a3[2] = v15;
  a3[3] = v16;
  a3[4] = v17;
  a3[5] = v18;
  a3[6] = result;
  a3[7] = v20;
  a3[8] = v8 * v12 - v21;
  return result;
}

void *cva::SO3AlgebraStorage<double,cva::Matrix<double,3u,1u,false>>::SO3AlgebraStorage(void *result)
{
  *double result = 0;
  result[1] = 0;
  result[2] = 0;
  return result;
}

{
  *double result = 0;
  result[1] = 0;
  result[2] = 0;
  return result;
}

double cva::SO3GroupStorage<double,cva::Matrix<double,3u,3u,false>>::logJacobian@<D0>(float64x2_t *a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  sub_2153CAD38(a1, (double *)a2);
  double v3 = *(double *)a2;
  double v4 = *(double *)(a2 + 8);
  double v5 = *(double *)(a2 + 16);
  double v6 = v3 * v3 + v4 * v4 + v5 * v5;
  if (v6 >= 0.0000002635)
  {
    double v11 = sqrt(v6);
    __double2 v12 = __sincos_stret(v11);
    double cosval = v12.__cosval;
    double v9 = v12.__sinval / v11;
    double v7 = 1.0 / v6 * (1.0 - v12.__cosval);
    double v8 = 1.0 / v6 * (1.0 - v12.__sinval / v11);
  }
  else
  {
    double v7 = 0.5 - v6 * (v6 / -720.0 + 0.0416666667);
    double v8 = 0.166666667 - v6 * (v6 / -5040.0 + 0.00833333333);
    double v9 = 1.0 - v6 * v8;
    double cosval = 1.0 - v6 * v7;
  }
  double v13 = -(v8 - v7 * 0.5) / v9;
  double v14 = (v7 + v9 * -0.5) / (1.0 - cosval);
  if (cosval >= 0.9) {
    double v14 = v13;
  }
  double v15 = 1.0 - v6 * v14;
  double v16 = v3 * v14;
  double v17 = v14 * v4;
  double v18 = v15 + v3 * v14 * v3;
  double v19 = v15 + v14 * v5 * v5;
  double v20 = v15 + v17 * v4;
  *(double *)(a2 + 88) = v19;
  double v21 = v16 * v4;
  double v22 = v16 * v5;
  double v23 = v17 * v5;
  *(double *)(a2 + 24) = v18;
  *(double *)(a2 + 32) = v21 + v5 * -0.5;
  *(double *)(a2 + 72) = v4 * -0.5 + v22;
  *(double *)(a2 + 80) = v23 - v3 * -0.5;
  *(double *)(a2 + 40) = v22 - v4 * -0.5;
  *(double *)(a2 + 48) = v21 - v5 * -0.5;
  double result = v23 + v3 * -0.5;
  *(double *)(a2 + 56) = v20;
  *(double *)(a2 + 64) = result;
  return result;
}

double cva::SO3GroupStorage<double,cva::Matrix<double,3u,3u,false>>::inverse@<D0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  double result = *(double *)a1;
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 48);
  uint64_t v5 = *(void *)(a1 + 56);
  uint64_t v7 = *(void *)(a1 + 16);
  uint64_t v6 = *(void *)(a1 + 24);
  uint64_t v8 = *(void *)(a1 + 32);
  uint64_t v9 = *(void *)(a1 + 40);
  uint64_t v10 = *(void *)(a1 + 64);
  *a2 = *(void *)a1;
  a2[1] = v6;
  a2[2] = v4;
  a2[3] = v3;
  a2[4] = v8;
  a2[5] = v5;
  a2[6] = v7;
  a2[7] = v9;
  a2[8] = v10;
  return result;
}

__n128 cva::SO3GroupStorage<double,cva::Matrix<double,3u,3u,false>>::adjoint@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  long long v2 = *(_OWORD *)(a1 + 48);
  *(_OWORD *)(a2 + 32) = *(_OWORD *)(a1 + 32);
  *(_OWORD *)(a2 + 48) = v2;
  *(void *)(a2 + 64) = *(void *)(a1 + 64);
  __n128 result = *(__n128 *)(a1 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *(__n128 *)(a2 + 16) = result;
  return result;
}

double cva::SO3GroupStorage<double,cva::Matrix<double,3u,3u,false>>::enforce(float64x2_t *a1)
{
  double v29 = 0.0;
  double v30 = 0.0;
  double v31 = 0.0;
  sub_2153CAD38(a1, &v29);
  double v3 = v29;
  double v2 = v30;
  double v4 = v2 * v2;
  double v5 = v31;
  double v6 = v2 * v2 + v3 * v3 + v5 * v5;
  if (v6 > 9.8696044)
  {
    double v7 = sqrt(v6) / 3.14159265;
    double v8 = ceil(v7) + -1.0;
    int v9 = (int)v8;
    double v10 = v7 - v8;
    if (v9) {
      double v10 = v10 + -1.0;
    }
    double v11 = v10 / v7;
    double v3 = v29 * v11;
    double v2 = v30 * v11;
    double v5 = v31 * v11;
    double v4 = v2 * v2;
  }
  double v12 = v3 * v3 + v4 + v5 * v5;
  if (v12 >= 0.0000002635)
  {
    double v16 = sqrt(v12);
    __double2 v17 = __sincos_stret(v16);
    double cosval = v17.__cosval;
    double v14 = v17.__sinval / v16;
    double v13 = 1.0 / v12 * (1.0 - v17.__cosval);
  }
  else
  {
    double v13 = 0.5 - v12 * (v12 / -720.0 + 0.0416666667);
    double v14 = 1.0 - v12 * (0.166666667 - v12 * (v12 / -5040.0 + 0.00833333333));
    double cosval = 1.0 - v12 * v13;
  }
  double v18 = v3 * v13;
  double v19 = v2 * v13;
  double v20 = cosval + v3 * v13 * v3;
  double v21 = cosval + v2 * v13 * v2;
  double result = cosval + v5 * v13 * v5;
  double v23 = v2 * v18;
  double v24 = v5 * v18;
  double v25 = v5 * v19;
  double v26 = v3 * v14;
  double v27 = v2 * v14;
  double v28 = v5 * v14;
  a1->f64[0] = v20;
  a1->f64[1] = v23 + v28;
  a1[1].f64[0] = v24 - v27;
  a1[1].f64[1] = v23 - v28;
  a1[2].f64[0] = v21;
  a1[2].f64[1] = v26 + v25;
  a1[3].f64[0] = v27 + v24;
  a1[3].f64[1] = v25 - v26;
  a1[4].f64[0] = result;
  return result;
}

double cva::SO3AlgebraStorage<double,cva::Matrix<double,3u,1u,false>>::enforce(double *a1)
{
  double v2 = *a1;
  double result = a1[1];
  double v3 = a1[2];
  double v4 = result * result + v2 * v2 + v3 * v3;
  if (v4 > 9.8696044)
  {
    double v5 = sqrt(v4) / 3.14159265;
    double v6 = ceil(v5) + -1.0;
    int v7 = (int)v6;
    double v8 = v5 - v6;
    if (v7) {
      double v8 = v8 + -1.0;
    }
    double v9 = v8 / v5;
    *a1 = v2 * v9;
    a1[1] = result * v9;
    double result = v3 * v9;
    a1[2] = v3 * v9;
  }
  return result;
}

double cva::SO3AlgebraStorage<double,cva::Matrix<double,3u,1u,false>>::exp@<D0>(double *a1@<X0>, double *a2@<X8>)
{
  double v3 = *a1;
  double v4 = a1[1];
  double v5 = a1[2];
  double v6 = v3 * v3 + v4 * v4 + v5 * v5;
  if (v6 >= 0.0000002635)
  {
    double v10 = sqrt(v6);
    __double2 v11 = __sincos_stret(v10);
    double cosval = v11.__cosval;
    double v8 = v11.__sinval / v10;
    double v7 = 1.0 / v6 * (1.0 - v11.__cosval);
  }
  else
  {
    double v7 = 0.5 - v6 * (v6 / -720.0 + 0.0416666667);
    double v8 = 1.0 - v6 * (0.166666667 - v6 * (v6 / -5040.0 + 0.00833333333));
    double cosval = 1.0 - v6 * v7;
  }
  double v12 = v3 * v7;
  double v13 = v7 * v4;
  double v14 = cosval + v3 * v7 * v3;
  double v15 = cosval + v7 * v5 * v5;
  double v16 = cosval + v13 * v4;
  a2[8] = v15;
  double v17 = v12 * v4;
  double v18 = v12 * v5;
  double v19 = v13 * v5;
  double v20 = v3 * v8;
  double v21 = v8 * v4;
  double v22 = v8 * v5;
  *a2 = v14;
  a2[1] = v17 + v22;
  a2[6] = v21 + v18;
  a2[7] = v19 - v20;
  a2[2] = v18 - v21;
  a2[3] = v17 - v22;
  double result = v20 + v19;
  a2[4] = v16;
  a2[5] = v20 + v19;
  return result;
}

uint64_t cva::SO3GroupStorage<double,cva::Matrix<double,3u,3u,false>>::serialize()
{
  return std::ostream::write();
}

uint64_t cva::SO3GroupStorage<double,cva::Matrix<double,3u,3u,false>>::deserialize(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x270F98678](a2, a1, 72);
}

double cva::SO3GroupStorage<float,cva::MatrixRef<float const,3u,3u,false>>::SO3GroupStorage(void *a1, uint64_t a2)
{
  *a1 = a2;
  *(void *)&double result = 3;
  a1[1] = 3;
  return result;
}

{
  double result;

  *a1 = a2;
  *(void *)&double result = 3;
  a1[1] = 3;
  return result;
}

float cva::SO3GroupStorage<float,cva::MatrixRef<float const,3u,3u,false>>::angleInDegrees(uint64_t a1)
{
  float v3 = 0.0;
  uint64_t v2 = 0;
  sub_2153CC034(*(float **)a1, *(_DWORD *)(a1 + 8), (float *)&v2);
  return (float)(sqrtf((float)((float)(*(float *)&v2 * *(float *)&v2) + (float)(*((float *)&v2 + 1) * *((float *)&v2 + 1)))+ (float)(v3 * v3))* 180.0)/ 3.1416;
}

void sub_2153CC034(float *a1, unsigned int a2, float *a3)
{
  uint64_t v5 = a2 + 2;
  uint64_t v6 = (2 * a2) | 1;
  float v7 = (float)(a1[v5] - a1[v6]) * 0.5;
  *a3 = v7;
  double v8 = (float32x2_t *)&a1[2 * a2];
  float v9 = (float)(v8->f32[0] - a1[2]) * 0.5;
  a3[1] = v9;
  float v10 = (float)(a1[1] - a1[a2]) * 0.5;
  a3[2] = v10;
  float v11 = a1[a2 + 1];
  float v12 = *a1;
  float v13 = a1[2 * a2 + 2];
  float v14 = -1.0;
  float v15 = (float)((float)((float)(*a1 + v11) + v13) + -1.0) * 0.5;
  float v16 = (float)((float)(v9 * v9) + (float)(v7 * v7)) + (float)(v10 * v10);
  if (v15 >= -1.0 || (float)(v15 + 1.0) <= -0.00001)
  {
    BOOL v18 = v15 > 1.0;
    if ((float)(v15 + -1.0) >= 0.00001) {
      BOOL v18 = 0;
    }
    if (v15 <= 0.99 && !v18)
    {
      if (v15 <= -0.99)
      {
        float v14 = (float)((float)((float)(*a1 + v11) + v13) + -1.0) * 0.5;
        goto LABEL_17;
      }
      float v20 = acosf(v15) / sqrtf(v16);
      *a3 = v7 * v20;
      a3[1] = v9 * v20;
    }
    else
    {
      float v20 = (float)(v16 * (float)((float)(v16 * (float)((float)((float)(v16 * 5.0) / 112.0) + 0.075)) + 0.16667)) + 1.0;
      *a3 = v7 * v20;
      a3[1] = v9 * v20;
    }
    a3[2] = v10 * v20;
    return;
  }
LABEL_17:
  uint64_t v21 = a2;
  float v22 = asinf(sqrtf(v16));
  float v23 = (float)((float)(3.1416 - v22) * (float)(3.1416 - v22)) / (float)(1.0 - v14);
  float v24 = (float)(v12 - v14) * v23;
  float v25 = (float)(v11 - v14) * v23;
  float v26 = (float)(v13 - v14) * v23;
  if (v24 <= v25)
  {
    float v31 = v23 * 0.5;
    if (v25 <= v26)
    {
      float v38 = sqrtf(v26);
      if (v10 < 0.0) {
        float v38 = -v38;
      }
      a3[2] = v38;
      v39.f32[0] = a1[2];
      v39.f32[1] = a1[v5];
      *(float32x2_t *)a3 = vmul_n_f32(vmul_n_f32(vadd_f32(*v8, v39), v31), 1.0 / v38);
    }
    else
    {
      float v32 = sqrtf(v25);
      if (v9 < 0.0) {
        float v32 = -v32;
      }
      a3[1] = v32;
      float v33 = 1.0 / v32;
      float v34 = a1[v6] + a1[v5];
      *a3 = v33 * (float)(v31 * (float)(a1[v21] + a1[1]));
      a3[2] = v33 * (float)(v31 * v34);
    }
  }
  else
  {
    float v27 = v23 * 0.5;
    float v28 = v27 * (float)(v8->f32[0] + a1[2]);
    if (v24 <= v26)
    {
      float v35 = sqrtf(v26);
      if (v10 < 0.0) {
        float v35 = -v35;
      }
      a3[2] = v35;
      float v36 = 1.0 / v35;
      float v37 = v36 * (float)(v27 * (float)(a1[v6] + a1[v5]));
      *a3 = v36 * v28;
      a3[1] = v37;
    }
    else
    {
      float v29 = sqrtf(v24);
      if (v7 < 0.0) {
        float v29 = -v29;
      }
      *a3 = v29;
      float v30 = 1.0 / v29;
      a3[1] = v30 * (float)(v27 * (float)(a1[v21] + a1[1]));
      a3[2] = v30 * v28;
    }
  }
}

float cva::SO3GroupStorage<float,cva::MatrixRef<float const,3u,3u,false>>::angleInRadians(uint64_t a1)
{
  float v3 = 0.0;
  uint64_t v2 = 0;
  sub_2153CC034(*(float **)a1, *(_DWORD *)(a1 + 8), (float *)&v2);
  return sqrtf((float)((float)(*(float *)&v2 * *(float *)&v2) + (float)(*((float *)&v2 + 1) * *((float *)&v2 + 1)))+ (float)(v3 * v3));
}

void cva::SO3GroupStorage<float,cva::MatrixRef<float const,3u,3u,false>>::log(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(_DWORD *)(a2 + 8) = 0;
  *(void *)a2 = 0;
  sub_2153CC034(*(float **)a1, *(_DWORD *)(a1 + 8), (float *)a2);
}

float *cva::SO3GroupStorage<float,cva::MatrixRef<float const,3u,3u,false>>::transform@<X0>(float *a1@<X0>, float *a2@<X1>, uint64_t a3@<X8>)
{
  v4[0] = a1;
  v4[1] = a2;
  *(void *)a3 = 0;
  *(_DWORD *)(a3 + 8) = 0;
  return sub_2153CC420((float *)a3, v4);
}

float *sub_2153CC420(float *result, float **a2)
{
  uint64_t v2 = result;
  uint64_t v3 = *(void *)*a2;
  if ((float *)(v3 - 4 * *((unsigned int *)*a2 + 3)) == result || (double v4 = a2[1], v4 == result))
  {
    int v21 = 0;
    uint64_t v20 = 0;
    double result = (float *)sub_2153CC420(&v20);
    *(void *)uint64_t v2 = v20;
    *((_DWORD *)v2 + 2) = v21;
  }
  else
  {
    uint64_t v5 = *((unsigned int *)*a2 + 2);
    if (v5)
    {
      uint64_t v6 = 0;
      uint64_t v7 = 4 * (3 * v5);
      uint64_t v8 = 4 * v5;
      float v9 = 0.0;
      float v10 = a2[1];
      do
      {
        float v11 = *v10++;
        float v9 = v9 + (float)(*(float *)(v3 + v6) * v11);
        v6 += v8;
      }
      while (v7 != v6);
      uint64_t v12 = 0;
      *double result = v9;
      float v13 = 0.0;
      float v14 = v4;
      do
      {
        float v15 = *v14++;
        float v13 = v13 + (float)(*(float *)(v3 + 4 + v12) * v15);
        v12 += v8;
      }
      while (v7 != v12);
      uint64_t v16 = 0;
      result[1] = v13;
      uint64_t v17 = v3 + 8;
      float v18 = 0.0;
      do
      {
        float v19 = *v4++;
        float v18 = v18 + (float)(*(float *)(v17 + v16) * v19);
        v16 += v8;
      }
      while (v7 != v16);
    }
    else
    {
      *(void *)double result = 0;
      float v18 = 0.0;
    }
    result[2] = v18;
  }
  return result;
}

float *cva::SO3GroupStorage<float,cva::MatrixRef<float const,3u,3u,false>>::inverseTransform@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = a1;
  v5[0] = &v4;
  v5[1] = a2;
  *(void *)a3 = 0;
  *(_DWORD *)(a3 + 8) = 0;
  return sub_2153CC568((float *)a3, v5);
}

float *sub_2153CC568(float *result, uint64_t **a2)
{
  uint64_t v2 = result;
  uint64_t v3 = (float *)a2[1];
  if (v3 == result)
  {
    int v8 = 0;
    uint64_t v7 = 0;
    double result = (float *)sub_2153CC568(&v7);
    *(void *)uint64_t v2 = v7;
    *((_DWORD *)v2 + 2) = v8;
  }
  else
  {
    uint64_t v4 = **a2;
    uint64_t v5 = *(float **)v4;
    uint64_t v6 = *(unsigned int *)(v4 + 8);
    *double result = (float)((float)((float)(v5[1] * v3[1]) + (float)(*v5 * *v3)) + 0.0) + (float)(v5[2] * v3[2]);
    result[1] = (float)((float)((float)(v5[v6 + 1] * v3[1]) + (float)(v5[v6] * *v3)) + 0.0)
              + (float)(v5[(v6 + 2)] * v3[2]);
    result[2] = (float)((float)((float)(v5[(2 * v6) + 1] * v3[1])
                              + (float)(v5[(2 * v6)] * *v3))
                      + 0.0)
              + (float)(v5[(2 * v6 + 2)] * v3[2]);
  }
  return result;
}

float cva::SO3GroupStorage<float,cva::MatrixRef<float const,3u,3u,false>>::transformJacobian@<S0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  *(_DWORD *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  float v3 = *(float *)(a1 + 4);
  float result = *(float *)(a1 + 8);
  float v4 = *(float *)a1;
  if (a1 == a2)
  {
    float v5 = -*(float *)a1;
    *(_DWORD *)a1 = 0;
    *(float *)(a1 + 4) = -result;
    *(float *)(a1 + 8) = v3;
    *(float *)(a1 + 12) = result;
    *(_DWORD *)(a1 + 16) = 0;
    *(float *)(a1 + 20) = v5;
    *(float *)(a1 + 24) = -v3;
    *(float *)(a1 + 28) = v4;
    *(_DWORD *)(a1 + 32) = 0;
  }
  else
  {
    *(float *)(a2 + 4) = -result;
    *(float *)(a2 + 8) = v3;
    *(float *)(a2 + 12) = result;
    float result = -v4;
    *(float *)(a2 + 20) = -v4;
    *(float *)(a2 + 24) = -v3;
    *(float *)(a2 + 28) = v4;
  }
  return result;
}

float cva::SO3GroupStorage<float,cva::MatrixRef<float const,3u,3u,false>>::inverseTransformJacobian@<S0>(uint64_t a1@<X0>, float *a2@<X1>, float *a3@<X8>)
{
  float v3 = **(float **)a1;
  float v4 = *(float *)(*(void *)a1 + 4);
  float v5 = *(float *)(*(void *)a1 + 8);
  uint64_t v6 = (*(_DWORD *)(a1 + 8) - 3);
  uint64_t v7 = (float *)(*(void *)a1 + v6 * 4);
  float v8 = v7[3];
  float v9 = v7[4];
  v7 += 3;
  float v10 = v7[2];
  float v11 = &v7[v6];
  float v12 = v11[3];
  float v13 = v11[4];
  float v14 = v11[5];
  float v16 = a2[1];
  float v15 = a2[2];
  float v17 = (float)(v4 * v15) - (float)(v5 * v16);
  float v18 = (float)(v9 * v15) - (float)(v10 * v16);
  float v19 = (float)(v13 * v15) - (float)(v14 * v16);
  float v20 = (float)(v5 * *a2) - (float)(v3 * v15);
  float v21 = (float)(v10 * *a2) - (float)(v8 * v15);
  float v22 = (float)(v14 * *a2) - (float)(v12 * v15);
  float result = (float)(v3 * v16) - (float)(v4 * *a2);
  float v24 = (float)(v8 * v16) - (float)(v9 * *a2);
  float v25 = v13 * *a2;
  *a3 = v17;
  a3[1] = v18;
  a3[2] = v19;
  a3[3] = v20;
  a3[4] = v21;
  a3[5] = v22;
  a3[6] = result;
  a3[7] = v24;
  a3[8] = (float)(v12 * v16) - v25;
  return result;
}

float cva::SO3GroupStorage<float,cva::MatrixRef<float const,3u,3u,false>>::logJacobian@<S0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  return sub_2153CC7A4(*(float **)a1, *(_DWORD *)(a1 + 8), (float *)a2, (float *)(a2 + 12));
}

float sub_2153CC7A4(float *a1, unsigned int a2, float *a3, float *a4)
{
  sub_2153CC034(a1, a2, a3);
  float v6 = *a3;
  float v7 = a3[1];
  float v8 = a3[2];
  float v9 = (float)((float)(v6 * v6) + (float)(v7 * v7)) + (float)(v8 * v8);
  if (v9 >= 0.0061)
  {
    float v14 = sqrtf(v9);
    __float2 v15 = __sincosf_stret(v14);
    float cosval = v15.__cosval;
    float v12 = v15.__sinval / v14;
    float v10 = (float)(1.0 / v9) * (float)(1.0 - v15.__cosval);
    float v11 = (float)(1.0 / v9) * (float)(1.0 - (float)(v15.__sinval / v14));
  }
  else
  {
    float v10 = 0.5 - (float)(v9 * (float)((float)(v9 / -720.0) + 0.041667));
    float v11 = 0.16667 - (float)(v9 * (float)((float)(v9 / -5040.0) + 0.0083333));
    float v12 = 1.0 - (float)(v9 * v11);
    float cosval = 1.0 - (float)(v9 * v10);
  }
  float v16 = (float)-(float)(v11 - (float)(v10 * 0.5)) / v12;
  float v17 = (float)(v10 + (float)(v12 * -0.5)) / (float)(1.0 - cosval);
  if (cosval >= 0.9) {
    float v17 = v16;
  }
  float v18 = 1.0 - (float)(v9 * v17);
  float v19 = v6 * v17;
  float v20 = v17 * v7;
  *a4 = v18 + (float)((float)(v6 * v17) * v6);
  a4[4] = v18 + (float)((float)(v17 * v7) * a3[1]);
  a4[8] = v18 + (float)((float)(v17 * v8) * a3[2]);
  float v21 = a3[1];
  float v22 = v19 * v21;
  float v23 = a3[2];
  float v24 = v19 * v23;
  float v25 = v20 * v23;
  float v26 = *a3 * -0.5;
  float v27 = v21 * -0.5;
  a4[6] = v27 + v24;
  a4[7] = v25 - v26;
  a4[1] = v22 + (float)(v23 * -0.5);
  a4[2] = v24 - v27;
  a4[3] = v22 - (float)(v23 * -0.5);
  float result = v25 + v26;
  a4[5] = v25 + v26;
  return result;
}

float cva::SO3GroupStorage<float,cva::MatrixRef<float const,3u,3u,false>>::inverse@<S0>(unsigned int *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = a1[2];
  float result = *(float *)(*(void *)a1 + 4 * v2);
  int v4 = *(_DWORD *)(*(void *)a1 + 4 * (2 * v2));
  int v5 = *(_DWORD *)(*(void *)a1 + 4);
  int v6 = *(_DWORD *)(*(void *)a1 + 4 * (v2 + 1));
  int v7 = *(_DWORD *)(*(void *)a1 + 4 * ((2 * v2) | 1u));
  int v8 = *(_DWORD *)(*(void *)a1 + 8);
  int v9 = *(_DWORD *)(*(void *)a1 + 4 * (v2 + 2));
  int v10 = *(_DWORD *)(*(void *)a1 + 4 * (2 * v2 + 2));
  *(_DWORD *)a2 = **(_DWORD **)a1;
  *(float *)(a2 + 4) = result;
  *(_DWORD *)(a2 + 8) = v4;
  *(_DWORD *)(a2 + 12) = v5;
  *(_DWORD *)(a2 + 16) = v6;
  *(_DWORD *)(a2 + 20) = v7;
  *(_DWORD *)(a2 + 24) = v8;
  *(_DWORD *)(a2 + 28) = v9;
  *(_DWORD *)(a2 + 32) = v10;
  return result;
}

int **cva::SO3GroupStorage<float,cva::MatrixRef<float const,3u,3u,false>>::adjoint@<X0>(int **result@<X0>, uint64_t a2@<X8>)
{
  *(_DWORD *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  uint64_t v2 = *result;
  uint64_t v3 = (*((_DWORD *)result + 2) - 3);
  int v4 = **result;
  if (&(*result)[-*((unsigned int *)result + 3)] == (int *)a2)
  {
    uint64_t v9 = v3;
    uint64_t v10 = *(void *)&v2[v9 + 3];
    *(void *)&long long v11 = *(void *)(v2 + 1);
    int v12 = v2[v9 + 5];
    float v13 = &v2[v9 + 3 + v9];
    int v14 = v13[5];
    *((void *)&v11 + 1) = v10;
    uint64_t v15 = *(void *)(v13 + 3);
    *(_DWORD *)a2 = v4;
    *(_OWORD *)(a2 + 4) = v11;
    *(_DWORD *)(a2 + 20) = v12;
    *(void *)(a2 + 24) = v15;
    *(_DWORD *)(a2 + 32) = v14;
  }
  else
  {
    *(_DWORD *)a2 = v4;
    *(_DWORD *)(a2 + 4) = v2[1];
    *(_DWORD *)(a2 + 8) = v2[2];
    uint64_t v5 = v3;
    int v6 = &v2[v5];
    int v7 = v6[3];
    v6 += 3;
    *(_DWORD *)(a2 + 12) = v7;
    *(_DWORD *)(a2 + 16) = v6[1];
    *(_DWORD *)(a2 + 20) = v6[2];
    int v8 = &v6[v5];
    *(_DWORD *)(a2 + 24) = v8[3];
    *(_DWORD *)(a2 + 28) = v8[4];
    *(_DWORD *)(a2 + 32) = v8[5];
  }
  return result;
}

uint64_t cva::SO3GroupStorage<float,cva::MatrixRef<float const,3u,3u,false>>::serialize(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 8);
  if (v1)
  {
    uint64_t v2 = *(void *)result;
    uint64_t v3 = *(void *)result + 4 * (3 * v1);
    unint64_t v4 = (unint64_t)(v1 - 3) << 32;
    do
    {
      float result = std::ostream::write();
      unint64_t v5 = HIDWORD(v4);
      if ((int)v4 < 2) {
        unint64_t v5 = 0;
      }
      uint64_t v6 = v2 + 4 * v5;
      uint64_t v7 = (v4 + 1);
      if ((int)v4 >= 2) {
        uint64_t v7 = 0;
      }
      unint64_t v4 = v7 | v4 & 0xFFFFFFFF00000000;
      uint64_t v2 = v6 + 4;
    }
    while (v6 + 4 != v3);
  }
  return result;
}

double cva::SO3GroupStorage<double,cva::MatrixRef<double const,3u,3u,false>>::SO3GroupStorage(void *a1, uint64_t a2)
{
  *a1 = a2;
  *(void *)&double result = 3;
  a1[1] = 3;
  return result;
}

{
  double result;

  *a1 = a2;
  *(void *)&double result = 3;
  a1[1] = 3;
  return result;
}

double cva::SO3GroupStorage<double,cva::MatrixRef<double const,3u,3u,false>>::angleInDegrees(uint64_t a1)
{
  double v2 = 0.0;
  double v3 = 0.0;
  double v4 = 0.0;
  sub_2153CCB88(*(double **)a1, *(_DWORD *)(a1 + 8), &v2);
  return sqrt(v2 * v2 + v3 * v3 + v4 * v4) * 180.0 / 3.14159265;
}

void sub_2153CCB88(double *a1, unsigned int a2, double *a3)
{
  uint64_t v5 = a2 + 2;
  uint64_t v6 = (2 * a2) | 1;
  double v7 = (a1[v5] - a1[v6]) * 0.5;
  *a3 = v7;
  int v8 = (float64x2_t *)&a1[2 * a2];
  double v9 = (v8->f64[0] - a1[2]) * 0.5;
  a3[1] = v9;
  double v10 = (a1[1] - a1[a2]) * 0.5;
  a3[2] = v10;
  double v11 = *a1;
  double v12 = a1[a2 + 1];
  double v13 = a1[2 * a2 + 2];
  double v14 = -1.0;
  double v15 = (*a1 + v12 + v13 + -1.0) * 0.5;
  double v16 = v9 * v9 + v7 * v7 + v10 * v10;
  if (v15 >= -1.0 || v15 + 1.0 <= -0.00001)
  {
    BOOL v17 = v15 > 1.0;
    if (v15 + -1.0 >= 0.00001) {
      BOOL v17 = 0;
    }
    if (v15 > 0.99 || v17)
    {
      double v19 = v16 * (v16 * (v16 * 5.0 / 112.0 + 0.075) + 0.166666667) + 1.0;
LABEL_12:
      *a3 = v7 * v19;
      a3[1] = v9 * v19;
      a3[2] = v10 * v19;
      return;
    }
    if (v15 > -0.99)
    {
      double v19 = acos(v15) / sqrt(v16);
      goto LABEL_12;
    }
    double v14 = (*a1 + v12 + v13 + -1.0) * 0.5;
  }
  uint64_t v20 = a2;
  long double v21 = asin(sqrt(v16));
  double v22 = (3.14159265 - v21) * (3.14159265 - v21) / (1.0 - v14);
  double v23 = (v11 - v14) * v22;
  double v24 = (v12 - v14) * v22;
  double v25 = (v13 - v14) * v22;
  if (v23 <= v24)
  {
    double v30 = v22 * 0.5;
    if (v24 <= v25)
    {
      double v37 = sqrt(v25);
      if (v10 < 0.0) {
        double v37 = -v37;
      }
      a3[2] = v37;
      v38.f64[0] = a1[2];
      v38.f64[1] = a1[v5];
      *(float64x2_t *)a3 = vmulq_n_f64(vmulq_n_f64(vaddq_f64(*v8, v38), v30), 1.0 / v37);
    }
    else
    {
      double v31 = sqrt(v24);
      if (v9 < 0.0) {
        double v31 = -v31;
      }
      a3[1] = v31;
      double v32 = 1.0 / v31;
      double v33 = a1[v6] + a1[v5];
      *a3 = v32 * (v30 * (a1[v20] + a1[1]));
      a3[2] = v32 * (v30 * v33);
    }
  }
  else
  {
    double v26 = v22 * 0.5;
    double v27 = v26 * (v8->f64[0] + a1[2]);
    if (v23 <= v25)
    {
      double v34 = sqrt(v25);
      if (v10 < 0.0) {
        double v34 = -v34;
      }
      a3[2] = v34;
      double v35 = 1.0 / v34;
      double v36 = v35 * (v26 * (a1[v6] + a1[v5]));
      *a3 = v35 * v27;
      a3[1] = v36;
    }
    else
    {
      double v28 = sqrt(v23);
      if (v7 < 0.0) {
        double v28 = -v28;
      }
      *a3 = v28;
      double v29 = 1.0 / v28;
      a3[1] = v29 * (v26 * (a1[v20] + a1[1]));
      a3[2] = v29 * v27;
    }
  }
}

double cva::SO3GroupStorage<double,cva::MatrixRef<double const,3u,3u,false>>::angleInRadians(uint64_t a1)
{
  double v2 = 0.0;
  double v3 = 0.0;
  double v4 = 0.0;
  sub_2153CCB88(*(double **)a1, *(_DWORD *)(a1 + 8), &v2);
  return sqrt(v2 * v2 + v3 * v3 + v4 * v4);
}

void cva::SO3GroupStorage<double,cva::MatrixRef<double const,3u,3u,false>>::log(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  sub_2153CCB88(*(double **)a1, *(_DWORD *)(a1 + 8), (double *)a2);
}

double *cva::SO3GroupStorage<double,cva::MatrixRef<double const,3u,3u,false>>::transform@<X0>(double *a1@<X0>, double *a2@<X1>, uint64_t a3@<X8>)
{
  v4[0] = a1;
  v4[1] = a2;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)a3 = 0;
  return sub_2153CCF54((double *)a3, v4);
}

double *sub_2153CCF54(double *result, double **a2)
{
  double v2 = result;
  uint64_t v3 = *(void *)*a2;
  if ((double *)(v3 - 8 * *((unsigned int *)*a2 + 3)) == result || (double v4 = a2[1], v4 == result))
  {
    long long v20 = 0uLL;
    uint64_t v21 = 0;
    double result = (double *)sub_2153CCF54(&v20);
    *(_OWORD *)double v2 = v20;
    *((void *)v2 + 2) = v21;
  }
  else
  {
    uint64_t v5 = *((unsigned int *)*a2 + 2);
    if (v5)
    {
      uint64_t v6 = 0;
      uint64_t v7 = 8 * (3 * v5);
      uint64_t v8 = 8 * v5;
      double v9 = 0.0;
      double v10 = a2[1];
      do
      {
        double v11 = *v10++;
        double v9 = v9 + *(double *)(v3 + v6) * v11;
        v6 += v8;
      }
      while (v7 != v6);
      uint64_t v12 = 0;
      *double result = v9;
      double v13 = 0.0;
      double v14 = v4;
      do
      {
        double v15 = *v14++;
        double v13 = v13 + *(double *)(v3 + 8 + v12) * v15;
        v12 += v8;
      }
      while (v7 != v12);
      uint64_t v16 = 0;
      result[1] = v13;
      uint64_t v17 = v3 + 16;
      double v18 = 0.0;
      do
      {
        double v19 = *v4++;
        double v18 = v18 + *(double *)(v17 + v16) * v19;
        v16 += v8;
      }
      while (v7 != v16);
    }
    else
    {
      *double result = 0.0;
      result[1] = 0.0;
      double v18 = 0.0;
    }
    result[2] = v18;
  }
  return result;
}

double cva::SO3GroupStorage<double,cva::MatrixRef<double const,3u,3u,false>>::inverseTransform@<D0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, void *a3@<X8>)
{
  uint64_t v4 = a1;
  v5[0] = &v4;
  v5[1] = a2;
  a3[1] = 0;
  a3[2] = 0;
  *a3 = 0;
  return sub_2153CD09C((uint64_t)a3, v5);
}

double sub_2153CD09C(uint64_t a1, uint64_t **a2)
{
  uint64_t v3 = (double *)a2[1];
  if (v3 == (double *)a1)
  {
    long long v8 = 0uLL;
    uint64_t v9 = 0;
    sub_2153CD09C(&v8);
    double result = *(double *)&v8;
    *(_OWORD *)a1 = v8;
    *(void *)(a1 + 16) = v9;
  }
  else
  {
    uint64_t v4 = **a2;
    uint64_t v5 = *(double **)v4;
    uint64_t v6 = *(unsigned int *)(v4 + 8);
    *(double *)a1 = v5[1] * v3[1] + *v5 * *v3 + 0.0 + v5[2] * v3[2];
    *(double *)(a1 + 8) = v5[v6 + 1] * v3[1] + v5[v6] * *v3 + 0.0 + v5[(v6 + 2)] * v3[2];
    double result = v5[(2 * v6) + 1] * v3[1]
           + v5[(2 * v6)] * *v3
           + 0.0
           + v5[(2 * v6 + 2)] * v3[2];
    *(double *)(a1 + 16) = result;
  }
  return result;
}

double cva::SO3GroupStorage<double,cva::MatrixRef<double const,3u,3u,false>>::transformJacobian@<D0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 64) = 0;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  double v3 = *(double *)(a1 + 8);
  double result = *(double *)(a1 + 16);
  double v4 = *(double *)a1;
  if (a1 == a2)
  {
    double v5 = -*(double *)a1;
    *(void *)a1 = 0;
    *(double *)(a1 + 8) = -result;
    *(double *)(a1 + 16) = v3;
    *(double *)(a1 + 24) = result;
    *(void *)(a1 + 32) = 0;
    *(double *)(a1 + 40) = v5;
    *(double *)(a1 + 48) = -v3;
    *(double *)(a1 + 56) = v4;
    *(void *)(a1 + 64) = 0;
  }
  else
  {
    *(double *)(a2 + 8) = -result;
    *(double *)(a2 + 16) = v3;
    *(double *)(a2 + 24) = result;
    double result = -v4;
    *(double *)(a2 + 40) = -v4;
    *(double *)(a2 + 48) = -v3;
    *(double *)(a2 + 56) = v4;
  }
  return result;
}

double cva::SO3GroupStorage<double,cva::MatrixRef<double const,3u,3u,false>>::inverseTransformJacobian@<D0>(uint64_t a1@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  double v3 = **(double **)a1;
  double v4 = *(double *)(*(void *)a1 + 8);
  double v5 = *(double *)(*(void *)a1 + 16);
  uint64_t v6 = (*(_DWORD *)(a1 + 8) - 3);
  uint64_t v7 = (double *)(*(void *)a1 + v6 * 8);
  double v8 = v7[3];
  double v9 = v7[4];
  v7 += 3;
  double v10 = v7[2];
  double v11 = &v7[v6];
  double v12 = v11[3];
  double v13 = v11[4];
  double v14 = v11[5];
  double v16 = a2[1];
  double v15 = a2[2];
  double v17 = v4 * v15 - v5 * v16;
  double v18 = v9 * v15 - v10 * v16;
  double v19 = v13 * v15 - v14 * v16;
  double v20 = v5 * *a2 - v3 * v15;
  double v21 = v10 * *a2 - v8 * v15;
  double v22 = v14 * *a2 - v12 * v15;
  double result = v3 * v16 - v4 * *a2;
  double v24 = v8 * v16 - v9 * *a2;
  double v25 = v13 * *a2;
  *a3 = v17;
  a3[1] = v18;
  a3[2] = v19;
  a3[3] = v20;
  a3[4] = v21;
  a3[5] = v22;
  a3[6] = result;
  a3[7] = v24;
  a3[8] = v12 * v16 - v25;
  return result;
}

double cva::SO3GroupStorage<double,cva::MatrixRef<double const,3u,3u,false>>::logJacobian@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  return sub_2153CD2E0(*(double **)a1, *(_DWORD *)(a1 + 8), (double *)a2, (double *)(a2 + 24));
}

double sub_2153CD2E0(double *a1, unsigned int a2, double *a3, double *a4)
{
  sub_2153CCB88(a1, a2, a3);
  double v6 = *a3;
  double v7 = a3[1];
  double v8 = a3[2];
  double v9 = v6 * v6 + v7 * v7 + v8 * v8;
  if (v9 >= 0.0000002635)
  {
    double v14 = sqrt(v9);
    __double2 v15 = __sincos_stret(v14);
    double cosval = v15.__cosval;
    double v12 = v15.__sinval / v14;
    double v10 = 1.0 / v9 * (1.0 - v15.__cosval);
    double v11 = 1.0 / v9 * (1.0 - v15.__sinval / v14);
  }
  else
  {
    double v10 = 0.5 - v9 * (v9 / -720.0 + 0.0416666667);
    double v11 = 0.166666667 - v9 * (v9 / -5040.0 + 0.00833333333);
    double v12 = 1.0 - v9 * v11;
    double cosval = 1.0 - v9 * v10;
  }
  double v16 = -(v11 - v10 * 0.5) / v12;
  double v17 = (v10 + v12 * -0.5) / (1.0 - cosval);
  if (cosval >= 0.9) {
    double v17 = v16;
  }
  double v18 = 1.0 - v9 * v17;
  double v19 = v6 * v17;
  double v20 = v17 * v7;
  *a4 = v18 + v6 * v17 * v6;
  a4[4] = v18 + v17 * v7 * a3[1];
  a4[8] = v18 + v17 * v8 * a3[2];
  double v21 = a3[1];
  double v22 = v19 * v21;
  double v23 = a3[2];
  double v24 = v19 * v23;
  double v25 = v20 * v23;
  double v26 = *a3 * -0.5;
  double v27 = v21 * -0.5;
  a4[6] = v27 + v24;
  a4[7] = v25 - v26;
  a4[1] = v22 + v23 * -0.5;
  a4[2] = v24 - v27;
  a4[3] = v22 - v23 * -0.5;
  double result = v25 + v26;
  a4[5] = v25 + v26;
  return result;
}

double cva::SO3GroupStorage<double,cva::MatrixRef<double const,3u,3u,false>>::inverse@<D0>(unsigned int *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = a1[2];
  double result = *(double *)(*(void *)a1 + 8 * v2);
  uint64_t v4 = *(void *)(*(void *)a1 + 8 * (2 * v2));
  uint64_t v5 = *(void *)(*(void *)a1 + 8);
  uint64_t v6 = *(void *)(*(void *)a1 + 8 * (v2 + 1));
  uint64_t v7 = *(void *)(*(void *)a1 + 8 * ((2 * v2) | 1u));
  uint64_t v8 = *(void *)(*(void *)a1 + 16);
  uint64_t v9 = *(void *)(*(void *)a1 + 8 * (v2 + 2));
  uint64_t v10 = *(void *)(*(void *)a1 + 8 * (2 * v2 + 2));
  *(void *)a2 = **(void **)a1;
  *(double *)(a2 + 8) = result;
  *(void *)(a2 + 16) = v4;
  *(void *)(a2 + 24) = v5;
  *(void *)(a2 + 32) = v6;
  *(void *)(a2 + 40) = v7;
  *(void *)(a2 + 48) = v8;
  *(void *)(a2 + 56) = v9;
  *(void *)(a2 + 64) = v10;
  return result;
}

uint64_t **cva::SO3GroupStorage<double,cva::MatrixRef<double const,3u,3u,false>>::adjoint@<X0>(uint64_t **result@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 64) = 0;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  uint64_t v2 = *result;
  uint64_t v3 = (*((_DWORD *)result + 2) - 3);
  uint64_t v4 = **result;
  if (&(*result)[-*((unsigned int *)result + 3)] == (uint64_t *)a2)
  {
    uint64_t v9 = v3;
    long long v10 = *(_OWORD *)&v2[v9 + 3];
    uint64_t v11 = v2[v9 + 5];
    double v12 = &v2[v9 + 3 + v9];
    uint64_t v13 = v12[5];
    long long v14 = *(_OWORD *)(v2 + 1);
    long long v15 = *(_OWORD *)(v12 + 3);
    *(void *)a2 = v4;
    *(_OWORD *)(a2 + 8) = v14;
    *(_OWORD *)(a2 + 24) = v10;
    *(void *)(a2 + 40) = v11;
    *(_OWORD *)(a2 + 48) = v15;
    *(void *)(a2 + 64) = v13;
  }
  else
  {
    *(void *)a2 = v4;
    *(void *)(a2 + 8) = v2[1];
    *(void *)(a2 + 16) = v2[2];
    uint64_t v5 = v3;
    uint64_t v6 = &v2[v5];
    uint64_t v7 = v6[3];
    v6 += 3;
    *(void *)(a2 + 24) = v7;
    *(void *)(a2 + 32) = v6[1];
    *(void *)(a2 + 40) = v6[2];
    uint64_t v8 = &v6[v5];
    *(void *)(a2 + 48) = v8[3];
    *(void *)(a2 + 56) = v8[4];
    *(void *)(a2 + 64) = v8[5];
  }
  return result;
}

uint64_t cva::SO3GroupStorage<double,cva::MatrixRef<double const,3u,3u,false>>::serialize(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 8);
  if (v1)
  {
    uint64_t v2 = *(void *)result;
    uint64_t v3 = *(void *)result + 8 * (3 * v1);
    unint64_t v4 = (unint64_t)(v1 - 3) << 32;
    do
    {
      double result = std::ostream::write();
      unint64_t v5 = HIDWORD(v4);
      if ((int)v4 < 2) {
        unint64_t v5 = 0;
      }
      uint64_t v6 = v2 + 8 * v5;
      uint64_t v7 = (v4 + 1);
      if ((int)v4 >= 2) {
        uint64_t v7 = 0;
      }
      unint64_t v4 = v7 | v4 & 0xFFFFFFFF00000000;
      uint64_t v2 = v6 + 8;
    }
    while (v6 + 8 != v3);
  }
  return result;
}

float cva::SO3AlgebraStorage<float,cva::Matrix<float,3u,1u,false>>::adjoint@<S0>(float *a1@<X0>, uint64_t a2@<X8>)
{
  float result = *a1;
  float v3 = a1[1];
  float v4 = a1[2];
  float v5 = -*a1;
  *(_DWORD *)a2 = 0;
  *(float *)(a2 + 4) = v4;
  *(float *)(a2 + 8) = -v3;
  *(float *)(a2 + 12) = -v4;
  *(_DWORD *)(a2 + 16) = 0;
  *(float *)(a2 + 20) = result;
  *(float *)(a2 + 24) = v3;
  *(float *)(a2 + 28) = v5;
  *(_DWORD *)(a2 + 32) = 0;
  return result;
}

float cva::SO3AlgebraStorage<float,cva::Matrix<float,3u,1u,false>>::hat@<S0>(float *a1@<X0>, uint64_t a2@<X8>)
{
  float result = *a1;
  float v3 = a1[1];
  float v4 = a1[2];
  float v5 = -*a1;
  *(_DWORD *)a2 = 0;
  *(float *)(a2 + 4) = v4;
  *(float *)(a2 + 8) = -v3;
  *(float *)(a2 + 12) = -v4;
  *(_DWORD *)(a2 + 16) = 0;
  *(float *)(a2 + 20) = result;
  *(float *)(a2 + 24) = v3;
  *(float *)(a2 + 28) = v5;
  *(_DWORD *)(a2 + 32) = 0;
  return result;
}

float cva::SO3AlgebraStorage<float,cva::Matrix<float,3u,1u,false>>::exp@<S0>(float *a1@<X0>, float *a2@<X8>, float a3@<S0>)
{
  float v4 = *a1 * a3;
  float v5 = a1[1] * a3;
  float v6 = a1[2] * a3;
  float v7 = (float)((float)(v4 * v4) + (float)(v5 * v5)) + (float)(v6 * v6);
  if (v7 >= 0.0061)
  {
    float v11 = sqrtf(v7);
    __float2 v12 = __sincosf_stret(v11);
    float cosval = v12.__cosval;
    float v9 = v12.__sinval / v11;
    float v8 = (float)(1.0 / v7) * (float)(1.0 - v12.__cosval);
  }
  else
  {
    float v8 = 0.5 - (float)(v7 * (float)((float)(v7 / -720.0) + 0.041667));
    float v9 = 1.0 - (float)(v7 * (float)(0.16667 - (float)(v7 * (float)((float)(v7 / -5040.0) + 0.0083333))));
    float cosval = 1.0 - (float)(v7 * v8);
  }
  float v13 = v4 * v8;
  float v14 = v5 * v8;
  float v15 = cosval + (float)((float)(v4 * v8) * v4);
  float v16 = cosval + (float)((float)(v6 * v8) * v6);
  float v17 = cosval + (float)(v14 * v5);
  a2[8] = v16;
  float v18 = v5 * v13;
  float v19 = v6 * v13;
  float v20 = v6 * v14;
  float v21 = v4 * v9;
  float v22 = v5 * v9;
  float v23 = v6 * v9;
  *a2 = v15;
  a2[1] = v18 + v23;
  a2[6] = v22 + v19;
  a2[7] = v20 - v21;
  a2[2] = v19 - v22;
  a2[3] = v18 - v23;
  float result = v20 + v21;
  a2[4] = v17;
  a2[5] = v20 + v21;
  return result;
}

float cva::SO3AlgebraStorage<float,cva::Matrix<float,3u,1u,false>>::expJacobian@<S0>(float *a1@<X0>, float *a2@<X8>)
{
  float v4 = *a1;
  float v3 = a1[1];
  float v5 = a1[2];
  float v6 = (float)((float)(v4 * v4) + (float)(v3 * v3)) + (float)(v5 * v5);
  if (v6 >= 0.0061)
  {
    float v11 = sqrtf(v6);
    __float2 v12 = __sincosf_stret(v11);
    float cosval = v12.__cosval;
    float v9 = v12.__sinval / v11;
    float v7 = (float)(1.0 / v6) * (float)(1.0 - v12.__cosval);
    float v8 = (float)(1.0 / v6) * (float)(1.0 - (float)(v12.__sinval / v11));
  }
  else
  {
    float v7 = 0.5 - (float)(v6 * (float)((float)(v6 / -720.0) + 0.041667));
    float v8 = 0.16667 - (float)(v6 * (float)((float)(v6 / -5040.0) + 0.0083333));
    float v9 = 1.0 - (float)(v6 * v8);
    float cosval = 1.0 - (float)(v6 * v7);
  }
  float v13 = v4 * v7;
  float v14 = v7 * v3;
  float v15 = v7 * v5;
  *a2 = cosval + (float)(v13 * v4);
  a2[1] = (float)(v13 * v3) + (float)(v9 * v5);
  a2[6] = (float)(v9 * v3) + (float)(v13 * v5);
  a2[7] = (float)(v14 * v5) - (float)(v9 * v4);
  a2[2] = (float)(v13 * v5) - (float)(v9 * v3);
  a2[3] = (float)(v13 * v3) - (float)(v9 * v5);
  a2[4] = cosval + (float)(v14 * v3);
  a2[5] = (float)(v14 * v5) + (float)(v9 * v4);
  float v16 = v8 * v4;
  float v17 = v8 * v3;
  a2[8] = cosval + (float)(v15 * v5);
  a2[9] = v9 + (float)((float)(v8 * v4) * v4);
  float v18 = v9 + (float)((float)(v8 * v3) * v3);
  float v19 = v9 + (float)((float)(v8 * v5) * v5);
  float v20 = (float)(v8 * v4) * v3;
  float v21 = v16 * v5;
  float v22 = v17 * v5;
  a2[12] = v20 - v15;
  a2[13] = v18;
  a2[16] = v22 - v13;
  a2[17] = v19;
  a2[10] = v20 + v15;
  a2[11] = v21 - v14;
  float result = v22 + v13;
  a2[14] = v22 + v13;
  a2[15] = v14 + v21;
  return result;
}

uint64_t cva::SO3AlgebraStorage<float,cva::Matrix<float,3u,1u,false>>::serialize()
{
  return std::ostream::write();
}

uint64_t cva::SO3AlgebraStorage<float,cva::Matrix<float,3u,1u,false>>::deserialize(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x270F98678](a2, a1, 12);
}

double cva::SO3AlgebraStorage<double,cva::Matrix<double,3u,1u,false>>::adjoint@<D0>(double *a1@<X0>, uint64_t a2@<X8>)
{
  double result = *a1;
  double v3 = a1[1];
  double v4 = a1[2];
  double v5 = -*a1;
  *(void *)a2 = 0;
  *(double *)(a2 + 8) = v4;
  *(double *)(a2 + 16) = -v3;
  *(double *)(a2 + 24) = -v4;
  *(void *)(a2 + 32) = 0;
  *(double *)(a2 + 40) = result;
  *(double *)(a2 + 48) = v3;
  *(double *)(a2 + 56) = v5;
  *(void *)(a2 + 64) = 0;
  return result;
}

double cva::SO3AlgebraStorage<double,cva::Matrix<double,3u,1u,false>>::hat@<D0>(double *a1@<X0>, uint64_t a2@<X8>)
{
  double result = *a1;
  double v3 = a1[1];
  double v4 = a1[2];
  double v5 = -*a1;
  *(void *)a2 = 0;
  *(double *)(a2 + 8) = v4;
  *(double *)(a2 + 16) = -v3;
  *(double *)(a2 + 24) = -v4;
  *(void *)(a2 + 32) = 0;
  *(double *)(a2 + 40) = result;
  *(double *)(a2 + 48) = v3;
  *(double *)(a2 + 56) = v5;
  *(void *)(a2 + 64) = 0;
  return result;
}

double cva::SO3AlgebraStorage<double,cva::Matrix<double,3u,1u,false>>::exp@<D0>(double *a1@<X0>, double *a2@<X8>, double a3@<D0>)
{
  double v4 = *a1 * a3;
  double v5 = a1[1] * a3;
  double v6 = a1[2] * a3;
  double v7 = v4 * v4 + v5 * v5 + v6 * v6;
  if (v7 >= 0.0000002635)
  {
    double v11 = sqrt(v7);
    __double2 v12 = __sincos_stret(v11);
    double cosval = v12.__cosval;
    double v9 = v12.__sinval / v11;
    double v8 = 1.0 / v7 * (1.0 - v12.__cosval);
  }
  else
  {
    double v8 = 0.5 - v7 * (v7 / -720.0 + 0.0416666667);
    double v9 = 1.0 - v7 * (0.166666667 - v7 * (v7 / -5040.0 + 0.00833333333));
    double cosval = 1.0 - v7 * v8;
  }
  double v13 = v4 * v8;
  double v14 = v5 * v8;
  double v15 = cosval + v4 * v8 * v4;
  double v16 = cosval + v6 * v8 * v6;
  double v17 = cosval + v14 * v5;
  a2[8] = v16;
  double v18 = v5 * v13;
  double v19 = v6 * v13;
  double v20 = v6 * v14;
  double v21 = v4 * v9;
  double v22 = v5 * v9;
  double v23 = v6 * v9;
  *a2 = v15;
  a2[1] = v18 + v23;
  a2[6] = v22 + v19;
  a2[7] = v20 - v21;
  a2[2] = v19 - v22;
  a2[3] = v18 - v23;
  double result = v20 + v21;
  a2[4] = v17;
  a2[5] = v20 + v21;
  return result;
}

double cva::SO3AlgebraStorage<double,cva::Matrix<double,3u,1u,false>>::expJacobian@<D0>(double *a1@<X0>, double *a2@<X8>)
{
  double v4 = *a1;
  double v3 = a1[1];
  double v5 = a1[2];
  double v6 = v4 * v4 + v3 * v3 + v5 * v5;
  if (v6 >= 0.0000002635)
  {
    double v11 = sqrt(v6);
    __double2 v12 = __sincos_stret(v11);
    double cosval = v12.__cosval;
    double v9 = v12.__sinval / v11;
    double v7 = 1.0 / v6 * (1.0 - v12.__cosval);
    double v8 = 1.0 / v6 * (1.0 - v12.__sinval / v11);
  }
  else
  {
    double v7 = 0.5 - v6 * (v6 / -720.0 + 0.0416666667);
    double v8 = 0.166666667 - v6 * (v6 / -5040.0 + 0.00833333333);
    double v9 = 1.0 - v6 * v8;
    double cosval = 1.0 - v6 * v7;
  }
  double v13 = v4 * v7;
  double v14 = v7 * v3;
  double v15 = v7 * v5;
  *a2 = cosval + v13 * v4;
  a2[1] = v13 * v3 + v9 * v5;
  a2[6] = v9 * v3 + v13 * v5;
  a2[7] = v14 * v5 - v9 * v4;
  a2[2] = v13 * v5 - v9 * v3;
  a2[3] = v13 * v3 - v9 * v5;
  a2[4] = cosval + v14 * v3;
  a2[5] = v14 * v5 + v9 * v4;
  double v16 = v8 * v4;
  double v17 = v8 * v3;
  a2[8] = cosval + v15 * v5;
  a2[9] = v9 + v8 * v4 * v4;
  double v18 = v9 + v8 * v3 * v3;
  double v19 = v9 + v8 * v5 * v5;
  double v20 = v8 * v4 * v3;
  double v21 = v16 * v5;
  double v22 = v17 * v5;
  a2[12] = v20 - v15;
  a2[13] = v18;
  a2[16] = v22 - v13;
  a2[17] = v19;
  a2[10] = v20 + v15;
  a2[11] = v21 - v14;
  double result = v22 + v13;
  a2[14] = v22 + v13;
  a2[15] = v14 + v21;
  return result;
}

uint64_t cva::SO3AlgebraStorage<double,cva::Matrix<double,3u,1u,false>>::serialize()
{
  return std::ostream::write();
}

uint64_t cva::SO3AlgebraStorage<double,cva::Matrix<double,3u,1u,false>>::deserialize(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x270F98678](a2, a1, 24);
}

float cva::SO3AlgebraStorage<float,cva::MatrixRef<float const,3u,1u,false>>::adjoint@<S0>(float **a1@<X0>, uint64_t a2@<X8>)
{
  float result = **a1;
  float v3 = (*a1)[1];
  float v4 = (*a1)[2];
  *(_DWORD *)a2 = 0;
  *(float *)(a2 + 4) = v4;
  *(float *)(a2 + 8) = -v3;
  *(float *)(a2 + 12) = -v4;
  *(_DWORD *)(a2 + 16) = 0;
  *(float *)(a2 + 20) = result;
  *(float *)(a2 + 24) = v3;
  *(float *)(a2 + 28) = -result;
  *(_DWORD *)(a2 + 32) = 0;
  return result;
}

float cva::SO3AlgebraStorage<float,cva::MatrixRef<float const,3u,1u,false>>::hat@<S0>(float **a1@<X0>, uint64_t a2@<X8>)
{
  float result = **a1;
  float v3 = (*a1)[1];
  float v4 = (*a1)[2];
  *(_DWORD *)a2 = 0;
  *(float *)(a2 + 4) = v4;
  *(float *)(a2 + 8) = -v3;
  *(float *)(a2 + 12) = -v4;
  *(_DWORD *)(a2 + 16) = 0;
  *(float *)(a2 + 20) = result;
  *(float *)(a2 + 24) = v3;
  *(float *)(a2 + 28) = -result;
  *(_DWORD *)(a2 + 32) = 0;
  return result;
}

float cva::SO3AlgebraStorage<float,cva::MatrixRef<float const,3u,1u,false>>::exp@<S0>(uint64_t a1@<X0>, float *a2@<X8>, float a3@<S0>)
{
  float v4 = **(float **)a1 * a3;
  float v5 = *(float *)(*(void *)a1 + 4) * a3;
  float v6 = *(float *)(*(void *)a1 + 8) * a3;
  float v7 = (float)((float)(v4 * v4) + (float)(v5 * v5)) + (float)(v6 * v6);
  if (v7 >= 0.0061)
  {
    float v11 = sqrtf(v7);
    __float2 v12 = __sincosf_stret(v11);
    float cosval = v12.__cosval;
    float v9 = v12.__sinval / v11;
    float v8 = (float)(1.0 / v7) * (float)(1.0 - v12.__cosval);
  }
  else
  {
    float v8 = 0.5 - (float)(v7 * (float)((float)(v7 / -720.0) + 0.041667));
    float v9 = 1.0 - (float)(v7 * (float)(0.16667 - (float)(v7 * (float)((float)(v7 / -5040.0) + 0.0083333))));
    float cosval = 1.0 - (float)(v7 * v8);
  }
  float v13 = v4 * v8;
  float v14 = v8 * v5;
  float v15 = cosval + (float)((float)(v4 * v8) * v4);
  float v16 = cosval + (float)((float)(v8 * v6) * v6);
  float v17 = cosval + (float)(v14 * v5);
  a2[8] = v16;
  float v18 = v13 * v5;
  float v19 = v13 * v6;
  float v20 = v14 * v6;
  float v21 = v4 * v9;
  float v22 = v9 * v5;
  float v23 = v9 * v6;
  *a2 = v15;
  a2[1] = v18 + v23;
  a2[6] = v22 + v19;
  a2[7] = v20 - v21;
  a2[2] = v19 - v22;
  a2[3] = v18 - v23;
  float result = v21 + v20;
  a2[4] = v17;
  a2[5] = v21 + v20;
  return result;
}

float cva::SO3AlgebraStorage<float,cva::MatrixRef<float const,3u,1u,false>>::expJacobian@<S0>(float **a1@<X0>, float *a2@<X8>)
{
  float v4 = **a1;
  float v3 = (*a1)[1];
  float v5 = (*a1)[2];
  float v6 = (float)((float)(v4 * v4) + (float)(v3 * v3)) + (float)(v5 * v5);
  if (v6 >= 0.0061)
  {
    float v11 = sqrtf(v6);
    __float2 v12 = __sincosf_stret(v11);
    float cosval = v12.__cosval;
    float v9 = v12.__sinval / v11;
    float v7 = (float)(1.0 / v6) * (float)(1.0 - v12.__cosval);
    float v8 = (float)(1.0 / v6) * (float)(1.0 - (float)(v12.__sinval / v11));
  }
  else
  {
    float v7 = 0.5 - (float)(v6 * (float)((float)(v6 / -720.0) + 0.041667));
    float v8 = 0.16667 - (float)(v6 * (float)((float)(v6 / -5040.0) + 0.0083333));
    float v9 = 1.0 - (float)(v6 * v8);
    float cosval = 1.0 - (float)(v6 * v7);
  }
  float v13 = v4 * v7;
  float v14 = v3 * v7;
  float v15 = v5 * v7;
  *a2 = cosval + (float)(v13 * v4);
  a2[1] = (float)(v13 * v3) + (float)(v9 * v5);
  a2[6] = (float)(v9 * v3) + (float)(v13 * v5);
  a2[7] = (float)(v14 * v5) - (float)(v9 * v4);
  a2[2] = (float)(v13 * v5) - (float)(v9 * v3);
  a2[3] = (float)(v13 * v3) - (float)(v9 * v5);
  a2[4] = cosval + (float)(v14 * v3);
  a2[5] = (float)(v14 * v5) + (float)(v9 * v4);
  float v16 = v8 * v4;
  float v17 = v8 * v3;
  a2[8] = cosval + (float)(v15 * v5);
  a2[9] = v9 + (float)((float)(v8 * v4) * v4);
  float v18 = v9 + (float)((float)(v8 * v3) * v3);
  float v19 = v9 + (float)((float)(v8 * v5) * v5);
  float v20 = (float)(v8 * v4) * v3;
  float v21 = v16 * v5;
  float v22 = v17 * v5;
  a2[12] = v20 - v15;
  a2[13] = v18;
  a2[16] = v22 - v13;
  a2[17] = v19;
  a2[10] = v20 + v15;
  a2[11] = v21 - v14;
  float result = v22 + v13;
  a2[14] = v22 + v13;
  a2[15] = v14 + v21;
  return result;
}

uint64_t cva::SO3AlgebraStorage<float,cva::MatrixRef<float const,3u,1u,false>>::serialize()
{
  return std::ostream::write();
}

double cva::SO3AlgebraStorage<double,cva::MatrixRef<double const,3u,1u,false>>::adjoint@<D0>(double **a1@<X0>, uint64_t a2@<X8>)
{
  double result = **a1;
  double v3 = (*a1)[1];
  double v4 = (*a1)[2];
  *(void *)a2 = 0;
  *(double *)(a2 + 8) = v4;
  *(double *)(a2 + 16) = -v3;
  *(double *)(a2 + 24) = -v4;
  *(void *)(a2 + 32) = 0;
  *(double *)(a2 + 40) = result;
  *(double *)(a2 + 48) = v3;
  *(double *)(a2 + 56) = -result;
  *(void *)(a2 + 64) = 0;
  return result;
}

double cva::SO3AlgebraStorage<double,cva::MatrixRef<double const,3u,1u,false>>::hat@<D0>(double **a1@<X0>, uint64_t a2@<X8>)
{
  double result = **a1;
  double v3 = (*a1)[1];
  double v4 = (*a1)[2];
  *(void *)a2 = 0;
  *(double *)(a2 + 8) = v4;
  *(double *)(a2 + 16) = -v3;
  *(double *)(a2 + 24) = -v4;
  *(void *)(a2 + 32) = 0;
  *(double *)(a2 + 40) = result;
  *(double *)(a2 + 48) = v3;
  *(double *)(a2 + 56) = -result;
  *(void *)(a2 + 64) = 0;
  return result;
}

double cva::SO3AlgebraStorage<double,cva::MatrixRef<double const,3u,1u,false>>::exp@<D0>(uint64_t a1@<X0>, double *a2@<X8>, double a3@<D0>)
{
  double v4 = **(double **)a1 * a3;
  double v5 = *(double *)(*(void *)a1 + 8) * a3;
  double v6 = *(double *)(*(void *)a1 + 16) * a3;
  double v7 = v4 * v4 + v5 * v5 + v6 * v6;
  if (v7 >= 0.0000002635)
  {
    double v11 = sqrt(v7);
    __double2 v12 = __sincos_stret(v11);
    double cosval = v12.__cosval;
    double v9 = v12.__sinval / v11;
    double v8 = 1.0 / v7 * (1.0 - v12.__cosval);
  }
  else
  {
    double v8 = 0.5 - v7 * (v7 / -720.0 + 0.0416666667);
    double v9 = 1.0 - v7 * (0.166666667 - v7 * (v7 / -5040.0 + 0.00833333333));
    double cosval = 1.0 - v7 * v8;
  }
  double v13 = v4 * v8;
  double v14 = v8 * v5;
  double v15 = cosval + v4 * v8 * v4;
  double v16 = cosval + v8 * v6 * v6;
  double v17 = cosval + v14 * v5;
  a2[8] = v16;
  double v18 = v13 * v5;
  double v19 = v13 * v6;
  double v20 = v14 * v6;
  double v21 = v4 * v9;
  double v22 = v9 * v5;
  double v23 = v9 * v6;
  *a2 = v15;
  a2[1] = v18 + v23;
  a2[6] = v22 + v19;
  a2[7] = v20 - v21;
  a2[2] = v19 - v22;
  a2[3] = v18 - v23;
  double result = v21 + v20;
  a2[4] = v17;
  a2[5] = v21 + v20;
  return result;
}

double cva::SO3AlgebraStorage<double,cva::MatrixRef<double const,3u,1u,false>>::expJacobian@<D0>(double **a1@<X0>, double *a2@<X8>)
{
  double v4 = **a1;
  double v3 = (*a1)[1];
  double v5 = (*a1)[2];
  double v6 = v4 * v4 + v3 * v3 + v5 * v5;
  if (v6 >= 0.0000002635)
  {
    double v11 = sqrt(v6);
    __double2 v12 = __sincos_stret(v11);
    double cosval = v12.__cosval;
    double v9 = v12.__sinval / v11;
    double v7 = 1.0 / v6 * (1.0 - v12.__cosval);
    double v8 = 1.0 / v6 * (1.0 - v12.__sinval / v11);
  }
  else
  {
    double v7 = 0.5 - v6 * (v6 / -720.0 + 0.0416666667);
    double v8 = 0.166666667 - v6 * (v6 / -5040.0 + 0.00833333333);
    double v9 = 1.0 - v6 * v8;
    double cosval = 1.0 - v6 * v7;
  }
  double v13 = v4 * v7;
  double v14 = v3 * v7;
  double v15 = v5 * v7;
  *a2 = cosval + v13 * v4;
  a2[1] = v13 * v3 + v9 * v5;
  a2[6] = v9 * v3 + v13 * v5;
  a2[7] = v14 * v5 - v9 * v4;
  a2[2] = v13 * v5 - v9 * v3;
  a2[3] = v13 * v3 - v9 * v5;
  a2[4] = cosval + v14 * v3;
  a2[5] = v14 * v5 + v9 * v4;
  double v16 = v8 * v4;
  double v17 = v8 * v3;
  a2[8] = cosval + v15 * v5;
  a2[9] = v9 + v8 * v4 * v4;
  double v18 = v9 + v8 * v3 * v3;
  double v19 = v9 + v8 * v5 * v5;
  double v20 = v8 * v4 * v3;
  double v21 = v16 * v5;
  double v22 = v17 * v5;
  a2[12] = v20 - v15;
  a2[13] = v18;
  a2[16] = v22 - v13;
  a2[17] = v19;
  a2[10] = v20 + v15;
  a2[11] = v21 - v14;
  double result = v22 + v13;
  a2[14] = v22 + v13;
  a2[15] = v14 + v21;
  return result;
}

uint64_t cva::SO3AlgebraStorage<double,cva::MatrixRef<double const,3u,1u,false>>::serialize()
{
  return std::ostream::write();
}

void cva::adp::io::FileDirectory::open(uint64_t a1, const std::string *a2, const std::string *a3, const std::string *a4)
{
  std::string::operator=((std::string *)a1, a2);
  std::string::operator=((std::string *)(a1 + 24), a3);
  double v7 = (unsigned char *)(a1 + 48);
  std::string::operator=((std::string *)(a1 + 48), a4);
  if (*(char *)(a1 + 71) < 0)
  {
    double v7 = *(unsigned char **)(a1 + 48);
    uint64_t v8 = *(void *)(a1 + 56);
  }
  else
  {
    uint64_t v8 = *(unsigned __int8 *)(a1 + 71);
  }
  double v9 = &v7[v8];
  while (v7 != v9)
  {
    *double v7 = __tolower((char)*v7);
    ++v7;
  }
  cva::adp::io::FileDirectory::parseDirectory((cva::adp::io::FileDirectory *)a1);
}

void cva::adp::io::FileDirectory::parseDirectory(cva::adp::io::FileDirectory *this)
{
}

void sub_2153CF0DC(char *a1)
{
  if (a1)
  {
    sub_2153CF0DC(*(void *)a1);
    sub_2153CF0DC(*((void *)a1 + 1));
    if (a1[63] < 0) {
      operator delete(*((void **)a1 + 5));
    }
    operator delete(a1);
  }
}

void *sub_2153CF138(void *a1, uint64_t a2, unsigned __int8 a3)
{
  MEMORY[0x2166B9550](&v11, a1, 1);
  if (!v11) {
    return a1;
  }
  if (*(char *)(a2 + 23) < 0)
  {
    **(unsigned char **)a2 = 0;
    *(void *)(a2 + 8) = 0;
  }
  else
  {
    *(unsigned char *)a2 = 0;
    *(unsigned char *)(a2 + 23) = 0;
  }
  uint64_t v6 = 0;
  while (1)
  {
    double v7 = *(void **)((char *)a1 + *(void *)(*a1 - 24) + 40);
    uint64_t v8 = (unsigned char *)v7[3];
    if (v8 != (unsigned char *)v7[4])
    {
      v7[3] = v8 + 1;
      LOBYTE(v7) = *v8;
      goto LABEL_9;
    }
    LODWORD(v7) = (*(uint64_t (**)(void *))(*v7 + 80))(v7);
    if (v7 == -1) {
      break;
    }
LABEL_9:
    if (v7 == a3)
    {
      int v9 = 0;
      goto LABEL_17;
    }
    ++v6;
    std::string::push_back((std::string *)a2, (std::string::value_type)v7);
    if (*(char *)(a2 + 23) < 0 && *(void *)(a2 + 8) == 0x7FFFFFFFFFFFFFF7)
    {
      int v9 = 4;
      goto LABEL_17;
    }
  }
  if (v6) {
    int v9 = 2;
  }
  else {
    int v9 = 6;
  }
LABEL_17:
  std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | v9);
  return a1;
}

uint64_t *sub_2153CF298(uint64_t *result, uint64_t *a2)
{
  *((unsigned char *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      uint64_t v2 = a2[2];
      if (*(unsigned char *)(v2 + 24)) {
        break;
      }
      double v3 = *(uint64_t **)(v2 + 16);
      uint64_t v4 = *v3;
      if (*v3 == v2)
      {
        uint64_t v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), double v5 = (unsigned char *)(v7 + 24), v8))
        {
          if (*(uint64_t **)v2 == a2)
          {
            int v9 = (uint64_t *)a2[2];
          }
          else
          {
            int v9 = *(uint64_t **)(v2 + 8);
            uint64_t v10 = *v9;
            *(void *)(v2 + 8) = *v9;
            if (v10)
            {
              *(void *)(v10 + 16) = v2;
              double v3 = *(uint64_t **)(v2 + 16);
            }
            v9[2] = (uint64_t)v3;
            *(void *)(*(void *)(v2 + 16) + 8 * (**(void **)(v2 + 16) != v2)) = v9;
            *int v9 = v2;
            *(void *)(v2 + 16) = v9;
            double v3 = (uint64_t *)v9[2];
            uint64_t v2 = *v3;
          }
          *((unsigned char *)v9 + 24) = 1;
          *((unsigned char *)v3 + 24) = 0;
          uint64_t v14 = *(void *)(v2 + 8);
          *double v3 = v14;
          if (v14) {
            *(void *)(v14 + 16) = v3;
          }
          *(void *)(v2 + 16) = v3[2];
          *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
          *(void *)(v2 + 8) = v3;
          v3[2] = v2;
          return result;
        }
      }
      else if (!v4 || (v6 = *(unsigned __int8 *)(v4 + 24), double v5 = (unsigned char *)(v4 + 24), v6))
      {
        if (*(uint64_t **)v2 == a2)
        {
          uint64_t v11 = a2[1];
          *(void *)uint64_t v2 = v11;
          if (v11)
          {
            *(void *)(v11 + 16) = v2;
            double v3 = *(uint64_t **)(v2 + 16);
          }
          a2[2] = (uint64_t)v3;
          *(void *)(*(void *)(v2 + 16) + 8 * (**(void **)(v2 + 16) != v2)) = a2;
          a2[1] = v2;
          *(void *)(v2 + 16) = a2;
          double v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((unsigned char *)a2 + 24) = 1;
        *((unsigned char *)v3 + 24) = 0;
        __double2 v12 = (uint64_t *)v3[1];
        uint64_t v13 = *v12;
        v3[1] = *v12;
        if (v13) {
          *(void *)(v13 + 16) = v3;
        }
        v12[2] = v3[2];
        *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v12;
        uint64_t *v12 = (uint64_t)v3;
        v3[2] = (uint64_t)v12;
        return result;
      }
      *(unsigned char *)(v2 + 24) = 1;
      a2 = v3;
      *((unsigned char *)v3 + 24) = v3 == result;
      *double v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

void cva::adp::io::FileDirectory::close(char **this)
{
  int v1 = this + 10;
  sub_2153CF0DC(this[10]);
  *(v1 - 1) = v1;
  void *v1 = 0;
  v1[1] = 0;
  v1[2] = v1;
}

void cva::adp::io::FileDirectory::rmdir()
{
}

uint64_t cva::adp::io::FileDirectory::currentFileName(cva::adp::io::FileDirectory *this)
{
  return *((void *)this + 12) + 40;
}

void cva::adp::io::FileDirectory::currentFilePath(cva::adp::io::FileDirectory *this@<X0>, std::string *a2@<X8>)
{
  int v3 = *((char *)this + 23);
  if (v3 >= 0) {
    size_t v4 = *((unsigned __int8 *)this + 23);
  }
  else {
    size_t v4 = *((void *)this + 1);
  }
  unint64_t v5 = v4 + 1;
  if (v4 + 1 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v5 >= 0x17)
  {
    uint64_t v8 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17) {
      uint64_t v8 = v5 | 7;
    }
    uint64_t v9 = v8 + 1;
    p_dst = (std::string *)operator new(v8 + 1);
    __dst.__r_.__value_.__l.__size_ = v4 + 1;
    __dst.__r_.__value_.__r.__words[2] = v9 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
  }
  else
  {
    memset(&__dst, 0, sizeof(__dst));
    p_dst = &__dst;
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v4 + 1;
    if (!v4) {
      goto LABEL_15;
    }
  }
  if (v3 >= 0) {
    uint64_t v10 = this;
  }
  else {
    uint64_t v10 = *(cva::adp::io::FileDirectory **)this;
  }
  memmove(p_dst, v10, v4);
LABEL_15:
  *(_WORD *)((char *)&p_dst->__r_.__value_.__l.__data_ + v4) = 47;
  uint64_t v11 = *((void *)this + 12);
  uint64_t v14 = *(const std::string::value_type **)(v11 + 40);
  uint64_t v12 = v11 + 40;
  uint64_t v13 = v14;
  int v15 = *(char *)(v12 + 23);
  if (v15 >= 0) {
    double v16 = (const std::string::value_type *)v12;
  }
  else {
    double v16 = v13;
  }
  if (v15 >= 0) {
    std::string::size_type v17 = *(unsigned __int8 *)(v12 + 23);
  }
  else {
    std::string::size_type v17 = *(void *)(v12 + 8);
  }
  double v18 = std::string::append(&__dst, v16, v17);
  *a2 = *v18;
  v18->__r_.__value_.__r.__words[0] = 0;
  v18->__r_.__value_.__l.__size_ = 0;
  v18->__r_.__value_.__r.__words[2] = 0;
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
}

double cva::adp::io::FileDirectory::currentID(cva::adp::io::FileDirectory *this)
{
  return *(double *)(*((void *)this + 12) + 32);
}

uint64_t cva::adp::io::FileDirectory::currentPosition(cva::adp::io::FileDirectory *this)
{
  int v1 = (void *)*((void *)this + 9);
  uint64_t v2 = (void *)*((void *)this + 12);
  if (v1 == v2) {
    return 0;
  }
  uint64_t result = 0;
  do
  {
    size_t v4 = (void *)v1[1];
    if (v4)
    {
      do
      {
        unint64_t v5 = v4;
        size_t v4 = (void *)*v4;
      }
      while (v4);
    }
    else
    {
      do
      {
        unint64_t v5 = (void *)v1[2];
        BOOL v6 = *v5 == (void)v1;
        int v1 = v5;
      }
      while (!v6);
    }
    ++result;
    int v1 = v5;
  }
  while (v5 != v2);
  return result;
}

uint64_t cva::adp::io::FileDirectory::numberOfFiles(cva::adp::io::FileDirectory *this)
{
  return *((void *)this + 11);
}

BOOL cva::adp::io::FileDirectory::forward(cva::adp::io::FileDirectory *this, uint64_t a2)
{
  if (!a2) {
    return 1;
  }
  uint64_t v2 = (char *)this + 80;
  int v3 = (char *)*((void *)this + 12);
  while (1)
  {
    size_t v4 = (char *)*((void *)v3 + 1);
    unint64_t v5 = v3;
    if (v4)
    {
      do
      {
        int v3 = v4;
        size_t v4 = *(char **)v4;
      }
      while (v4);
    }
    else
    {
      do
      {
        int v3 = (char *)*((void *)v5 + 2);
        BOOL v6 = *(void *)v3 == (void)v5;
        unint64_t v5 = v3;
      }
      while (!v6);
    }
    BOOL v7 = v3 != v2;
    if (v3 == v2) {
      break;
    }
    if (!--a2) {
      goto LABEL_13;
    }
  }
  int v3 = (char *)this + 80;
LABEL_13:
  *((void *)this + 12) = v3;
  return v7;
}

BOOL cva::adp::io::FileDirectory::backward(cva::adp::io::FileDirectory *this, uint64_t a2)
{
  if (!a2) {
    return 1;
  }
  uint64_t v2 = (void *)*((void *)this + 9);
  int v3 = (void *)*((void *)this + 12);
  while (1)
  {
    BOOL v4 = v3 != v2;
    if (v3 == v2) {
      break;
    }
    unint64_t v5 = (void *)*v3;
    if (*v3)
    {
      do
      {
        BOOL v6 = v5;
        unint64_t v5 = (void *)v5[1];
      }
      while (v5);
    }
    else
    {
      do
      {
        BOOL v6 = (void *)v3[2];
        BOOL v7 = *v6 == (void)v3;
        int v3 = v6;
      }
      while (v7);
    }
    *((void *)this + 12) = v6;
    int v3 = v6;
    if (!--a2) {
      return 1;
    }
  }
  return v4;
}

BOOL cva::adp::io::FileDirectory::isAtEnd(cva::adp::io::FileDirectory *this)
{
  return *((void *)this + 12) == (void)this + 80;
}

uint64_t cva::adp::io::FileDirectory::seekToFile(cva::adp::io::FileDirectory *this, double a2)
{
  uint64_t v2 = *((void *)this + 10);
  if (!v2) {
    return 0;
  }
  int v3 = (double *)((char *)this + 80);
  do
  {
    BOOL v4 = (uint64_t *)(v2 + 8);
    if (*(double *)(v2 + 32) >= a2)
    {
      BOOL v4 = (uint64_t *)v2;
      int v3 = (double *)v2;
    }
    uint64_t v2 = *v4;
  }
  while (*v4);
  if (v3 == (double *)((char *)this + 80) || v3[4] > a2) {
    return 0;
  }
  *((void *)this + 12) = v3;
  return 1;
}

BOOL cva::adp::io::FileDirectory::seekToPosition(cva::adp::io::FileDirectory *this, unint64_t a2)
{
  unint64_t v2 = *((void *)this + 11);
  if (v2 > a2)
  {
    int v3 = (void *)*((void *)this + 9);
    *((void *)this + 12) = v3;
    if ((a2 & 0x8000000000000000) != 0)
    {
      unint64_t v9 = a2;
      do
      {
        uint64_t v11 = (void *)*v3;
        if (*v3)
        {
          do
          {
            BOOL v7 = v11;
            uint64_t v11 = (void *)v11[1];
          }
          while (v11);
        }
        else
        {
          do
          {
            BOOL v7 = (void *)v3[2];
            BOOL v8 = *v7 == (void)v3;
            int v3 = v7;
          }
          while (v8);
        }
        int v3 = v7;
      }
      while (!__CFADD__(v9++, 1));
      goto LABEL_19;
    }
    if (a2)
    {
      uint64_t v4 = a2;
      do
      {
        BOOL v6 = (void *)v3[1];
        if (v6)
        {
          do
          {
            BOOL v7 = v6;
            BOOL v6 = (void *)*v6;
          }
          while (v6);
        }
        else
        {
          do
          {
            BOOL v7 = (void *)v3[2];
            BOOL v8 = *v7 == (void)v3;
            int v3 = v7;
          }
          while (!v8);
        }
        int v3 = v7;
      }
      while (v4-- > 1);
LABEL_19:
      *((void *)this + 12) = v7;
    }
  }
  return v2 > a2;
}

void cva::adp::io::isDirectory()
{
}

void cva::adp::io::isFile()
{
}

uint64_t cva::geo::SourceView::operator=(uint64_t result, uint64_t *a2)
{
  if ((uint64_t *)result != a2)
  {
    uint64_t v2 = *a2;
    *(void *)uint64_t result = *a2 & 0xFFFFFFFFFFFFFFLL | ((unint64_t)*(unsigned __int8 *)(result + 7) << 56);
    *(void *)uint64_t result = v2 & 0xFFFFFFFFFFFFFFLL | ((unint64_t)*((unsigned __int8 *)a2 + 7) << 56);
  }
  return result;
}

void *cva::geo::SourceView::SourceView(void *this, uint64_t a2)
{
  *this = a2;
  return this;
}

{
  *this = a2;
  return this;
}

unint64_t *cva::geo::SourceView::SourceView(unint64_t *this, uint64_t a2, unsigned __int8 a3)
{
  *this = a2 & 0xFFFFFFFFFFFFFFLL | ((unint64_t)a3 << 56);
  return this;
}

{
  *this = a2 & 0xFFFFFFFFFFFFFFLL | ((unint64_t)a3 << 56);
  return this;
}

BOOL cva::geo::operator<(void *a1, void *a2)
{
  return *a1 < *a2;
}

BOOL cva::geo::operator==(void *a1, void *a2)
{
  return *a1 == *a2;
}

BOOL cva::geo::operator!=(void *a1, void *a2)
{
  return *a1 != *a2;
}

double cva::PCA<float>::PCA(_OWORD *a1)
{
  double result = 0.0;
  a1[7] = 0u;
  a1[8] = 0u;
  a1[5] = 0u;
  a1[6] = 0u;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  *a1 = 0u;
  return result;
}

{
  double result;

  double result = 0.0;
  a1[7] = 0u;
  a1[8] = 0u;
  a1[5] = 0u;
  a1[6] = 0u;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  *a1 = 0u;
  return result;
}

uint64_t cva::PCA<float>::eigenvectors(uint64_t a1)
{
  return a1 + 24;
}

uint64_t cva::PCA<float>::operator()<cva::Matrix<float,0u,0u,false>,void>(uint64_t a1, uint64_t a2, int a3)
{
  LODWORD(v3) = a3;
  unsigned int v6 = *(_DWORD *)(a2 + 16);
  uint64_t v7 = *(unsigned int *)(a2 + 20);
  BOOL v8 = (void *)(a1 + 48);
  if (*(_DWORD *)(a1 + 64) != v6
    || (int v9 = *(_DWORD *)(a2 + 16), v10 = *(_DWORD *)(a2 + 20), v11 = v9, *(_DWORD *)(a1 + 68) != v6))
  {
    size_t v12 = (4 * v7 * v6 + 31) & 0x7FFFFFFE0;
    size_t v13 = v12 >> 2;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v12, 0x49090899uLL);
    uint64_t v14 = *(void **)(a1 + 48);
    *(void *)(a1 + 48) = memptr;
    *(void *)(a1 + 56) = v13;
    *(_DWORD *)(a1 + 64) = v6;
    *(_DWORD *)(a1 + 68) = v7;
    free(v14);
    int v11 = *(_DWORD *)(a2 + 16);
    int v10 = *(_DWORD *)(a2 + 20);
    if (v11 != *(_DWORD *)(a1 + 64)) {
      goto LABEL_7;
    }
    int v9 = *(_DWORD *)(a1 + 68);
  }
  if (v10 == v9)
  {
    int v15 = (_OWORD *)*v8;
    goto LABEL_19;
  }
LABEL_7:
  int v15 = (_OWORD *)*v8;
  if (*(void *)a2 == *v8)
  {
    size_t v18 = (4 * (v10 * v11) + 31) & 0x7FFFFFFE0;
    size_t v19 = v18 >> 2;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v18, 0x49090899uLL);
    double v20 = (char *)memptr;
    int v21 = *(_DWORD *)(a2 + 16);
    int v22 = *(_DWORD *)(a2 + 20);
    uint64_t v23 = (v22 * v21);
    if (v23)
    {
      double v24 = *(int **)a2;
      unint64_t v25 = (v23 - 1) & 0x3FFFFFFFFFFFFFFFLL;
      if (v25 < 7)
      {
        double v26 = (char *)memptr;
      }
      else
      {
        double v26 = (char *)memptr;
        if ((unint64_t)((unsigned char *)memptr - (unsigned char *)v24) >= 0x20)
        {
          unint64_t v27 = v25 + 1;
          uint64_t v28 = (v25 + 1) & 0x7FFFFFFFFFFFFFF8;
          double v29 = &v24[v28];
          double v30 = (char *)memptr + 16;
          double v31 = (long long *)(v24 + 4);
          uint64_t v32 = v28;
          do
          {
            long long v33 = *v31;
            *(v30 - 1) = *(v31 - 1);
            _OWORD *v30 = v33;
            v30 += 2;
            v31 += 2;
            v32 -= 8;
          }
          while (v32);
          if (v27 == v28) {
            goto LABEL_33;
          }
          double v26 = &v20[4 * v28];
          double v24 = v29;
        }
      }
      uint64_t v47 = &v20[4 * v23];
      do
      {
        int v48 = *v24++;
        *(_DWORD *)double v26 = v48;
        v26 += 4;
      }
      while (v26 != v47);
    }
LABEL_33:
    v49 = *(void **)(a1 + 48);
    *(void *)(a1 + 48) = v20;
    *(void *)(a1 + 56) = v19;
    *(_DWORD *)(a1 + 64) = v21;
    *(_DWORD *)(a1 + 68) = v22;
    free(v49);
    goto LABEL_34;
  }
  *(_DWORD *)(a1 + 64) = v11;
  *(_DWORD *)(a1 + 68) = v10;
  unint64_t v16 = (v10 * v11);
  if (v16)
  {
    if (*(void *)(a1 + 56) < v16)
    {
      free(v15);
      size_t v17 = (4 * v16 + 31) & 0x7FFFFFFE0;
      *(void *)(a1 + 48) = 0;
      *(void *)(a1 + 56) = v17 >> 2;
      memptr = 0;
      malloc_type_posix_memalign(&memptr, 0x20uLL, v17, 0x49090899uLL);
      int v15 = memptr;
      *(void *)(a1 + 48) = memptr;
    }
  }
  else
  {
    free(v15);
    int v15 = 0;
    *BOOL v8 = 0;
    v8[1] = 0;
  }
LABEL_19:
  uint64_t v34 = (*(_DWORD *)(a1 + 68) * *(_DWORD *)(a1 + 64));
  if (!v34) {
    goto LABEL_34;
  }
  double v35 = *(int **)a2;
  unint64_t v36 = (v34 - 1) & 0x3FFFFFFFFFFFFFFFLL;
  if (v36 < 7)
  {
    double v37 = v15;
LABEL_27:
    v45 = (_DWORD *)v15 + v34;
    do
    {
      int v46 = *v35++;
      *v37++ = v46;
    }
    while (v37 != v45);
    goto LABEL_34;
  }
  double v37 = v15;
  if ((unint64_t)((char *)v15 - (char *)v35) < 0x20) {
    goto LABEL_27;
  }
  unint64_t v38 = v36 + 1;
  uint64_t v39 = (v36 + 1) & 0x7FFFFFFFFFFFFFF8;
  v40 = &v35[v39];
  v41 = v15 + 1;
  v42 = (long long *)(v35 + 4);
  uint64_t v43 = v39;
  do
  {
    long long v44 = *v42;
    *(v41 - 1) = *(v42 - 1);
    _OWORD *v41 = v44;
    v41 += 2;
    v42 += 2;
    v43 -= 8;
  }
  while (v43);
  if (v38 != v39)
  {
    double v37 = (_DWORD *)v15 + v39;
    double v35 = v40;
    goto LABEL_27;
  }
LABEL_34:
  if (*(_DWORD *)(a1 + 88) != v6)
  {
    size_t v50 = (4 * v6 * v6 + 31) & 0x7FFFFFFE0;
    size_t v51 = v50 >> 2;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v50, 0x49090899uLL);
    v52 = *(void **)(a1 + 72);
    *(void *)(a1 + 72) = memptr;
    *(void *)(a1 + 80) = v51;
    *(_DWORD *)(a1 + 88) = v6;
    *(_DWORD *)(a1 + 92) = v6;
    free(v52);
  }
  if (v7 < v6) {
    unsigned int v6 = v7;
  }
  if (*(_DWORD *)(a1 + 112) != v6)
  {
    size_t v53 = (4 * v6 + 31) & 0x7FFFFFFE0;
    size_t v54 = v53 >> 2;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v53, 0x49090899uLL);
    v55 = *(void **)(a1 + 96);
    *(void *)(a1 + 96) = memptr;
    *(void *)(a1 + 104) = v54;
    *(_DWORD *)(a1 + 112) = v6;
    *(_DWORD *)(a1 + 116) = 1;
    free(v55);
  }
  if (*(_DWORD *)(a1 + 136) != v7)
  {
    size_t v56 = (4 * (v7 * v7) + 31) & 0x7FFFFFFE0;
    size_t v57 = v56 >> 2;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v56, 0x49090899uLL);
    v58 = *(void **)(a1 + 120);
    *(void *)(a1 + 120) = memptr;
    *(void *)(a1 + 128) = v57;
    *(_DWORD *)(a1 + 136) = v7;
    *(_DWORD *)(a1 + 140) = v7;
    free(v58);
  }
  if (sub_2153D034C((uint64_t)v8))
  {
    if (v7 >= v3) {
      uint64_t v3 = v3;
    }
    else {
      uint64_t v3 = v7;
    }
    if (*(_DWORD *)(a1 + 16) != v3)
    {
      size_t v59 = (4 * v3 + 31) & 0x7FFFFFFE0;
      size_t v60 = v59 >> 2;
      memptr = 0;
      malloc_type_posix_memalign(&memptr, 0x20uLL, v59, 0x49090899uLL);
      v61 = *(float32x4_t **)a1;
      *(void *)a1 = memptr;
      *(void *)(a1 + 8) = v60;
      *(_DWORD *)(a1 + 16) = v3;
      *(_DWORD *)(a1 + 20) = 1;
      free(v61);
      size_t v62 = (4 * (v3 * v7) + 31) & 0x7FFFFFFE0;
      size_t v63 = v62 >> 2;
      memptr = 0;
      malloc_type_posix_memalign(&memptr, 0x20uLL, v62, 0x49090899uLL);
      v64 = *(void **)(a1 + 24);
      *(void *)(a1 + 24) = memptr;
      *(void *)(a1 + 32) = v63;
      *(_DWORD *)(a1 + 40) = v7;
      *(_DWORD *)(a1 + 44) = v3;
      free(v64);
    }
    if (v3)
    {
      uint64_t v65 = 0;
      v66 = *(float32x4_t **)(a1 + 96);
      v67 = *(float32x4_t **)a1;
      if (v3 < 8) {
        goto LABEL_54;
      }
      if ((unint64_t)((char *)v67 - (char *)v66) <= 0x1F) {
        goto LABEL_54;
      }
      uint64_t v65 = v3 & 0xFFFFFFF8;
      v68 = v67 + 1;
      v69 = v66 + 1;
      uint64_t v70 = v65;
      do
      {
        float32x4_t v71 = vmulq_f32(*v69, *v69);
        v68[-1] = vmulq_f32(v69[-1], v69[-1]);
        float32x4_t *v68 = v71;
        v68 += 2;
        v69 += 2;
        v70 -= 8;
      }
      while (v70);
      if (v65 != v3)
      {
LABEL_54:
        uint64_t v72 = v3 - v65;
        uint64_t v73 = v65;
        v74 = &v67->f32[v65];
        v75 = &v66->f32[v73];
        do
        {
          float v76 = *v75++;
          *v74++ = v76 * v76;
          --v72;
        }
        while (v72);
      }
      int v77 = 0;
      uint64_t v78 = 0;
      int v79 = *(_DWORD *)(a1 + 136);
      uint64_t v80 = *(void *)(a1 + 120);
      int v81 = *(_DWORD *)(a1 + 40);
      uint64_t v82 = *(void *)(a1 + 24);
      int v83 = v7 - 1;
      uint64_t v84 = v7 & 0xFFFFFFF8;
      do
      {
        if (v7 >= 0x14)
        {
          uint64_t v85 = 0;
          BOOL v86 = __CFADD__(v81 * v78, v83);
          if (!__CFADD__(v78, v83)
            && v79 == 1
            && !v86
            && !((unint64_t)(v7 - 1) >> 32)
            && v82 + 4 * (unint64_t)(v81 * v78) - (v80 + 4 * v78) >= 0x20)
          {
            uint64_t v87 = 0;
            do
            {
              v88 = (long long *)(v80 + 4 * (v78 + v87));
              long long v89 = *v88;
              long long v90 = v88[1];
              v91 = (_OWORD *)(v82 + 4 * (v77 + v87));
              _OWORD *v91 = v89;
              v91[1] = v90;
              v87 += 8;
            }
            while (v84 != v87);
            uint64_t v85 = v7 & 0xFFFFFFF8;
            if (v84 == v7) {
              goto LABEL_57;
            }
          }
        }
        else
        {
          uint64_t v85 = 0;
        }
        unsigned int v92 = v78 + v79 * v85;
        do
        {
          *(_DWORD *)(v82 + 4 * (v77 + v85++)) = *(_DWORD *)(v80 + 4 * v92);
          v92 += v79;
        }
        while (v7 != v85);
LABEL_57:
        ++v78;
        v77 += v81;
      }
      while (v78 != v3);
    }
  }
  else
  {
    v93 = *(float32x4_t **)a1;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    free(v93);
    v94 = *(void **)(a1 + 24);
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 40) = 0;
    *(void *)(a1 + 24) = 0;
    free(v94);
  }
  return a1;
}

uint64_t sub_2153D034C(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 20) >= *(_DWORD *)(a1 + 16)) {
    int v1 = *(_DWORD *)(a1 + 16);
  }
  else {
    int v1 = *(_DWORD *)(a1 + 20);
  }
  if (4 * (8 * v1)) {
    uint64_t v2 = malloc_type_malloc(4 * (8 * v1), 0xA153FF5uLL);
  }
  else {
    uint64_t v2 = 0;
  }
  sgesdd_NEWLAPACK();
  if (4 * (int)0.0) {
    uint64_t v3 = malloc_type_malloc(4 * (int)0.0, 0xA153FF5uLL);
  }
  else {
    uint64_t v3 = 0;
  }
  sgesdd_NEWLAPACK();
  if (v3) {
    free(v3);
  }
  if (v2) {
    free(v2);
  }
  return 1;
}

uint64_t cva::PCA<float>::operator()<cva::MatrixRef<float,0u,0u,false>,void>(uint64_t a1, uint64_t a2, unsigned int a3)
{
  unsigned int v7 = *(_DWORD *)a2;
  uint64_t v6 = *(unsigned int *)(a2 + 4);
  BOOL v8 = (void *)(a1 + 48);
  if (*(_DWORD *)(a1 + 64) != *(_DWORD *)a2
    || (unsigned int v9 = *(_DWORD *)a2, v10 = *(_DWORD *)(a2 + 4), v11 = *(_DWORD *)a2, *(_DWORD *)(a1 + 68) != v7))
  {
    size_t v12 = (4 * v6 * v7 + 31) & 0x7FFFFFFE0;
    size_t v13 = v12 >> 2;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v12, 0x49090899uLL);
    uint64_t v14 = *(void **)(a1 + 48);
    *(void *)(a1 + 48) = memptr;
    *(void *)(a1 + 56) = v13;
    *(_DWORD *)(a1 + 64) = v7;
    *(_DWORD *)(a1 + 68) = v6;
    free(v14);
    unsigned int v11 = *(_DWORD *)a2;
    int v10 = *(_DWORD *)(a2 + 4);
    if (*(_DWORD *)a2 != *(_DWORD *)(a1 + 64)) {
      goto LABEL_7;
    }
    unsigned int v9 = *(_DWORD *)(a1 + 68);
  }
  if (v10 == v9)
  {
    int v15 = (_DWORD *)*v8;
    goto LABEL_23;
  }
LABEL_7:
  int v15 = (_DWORD *)*v8;
  if (*(void *)(a2 + 8) - 4 * *(unsigned int *)(a2 + 20) == *v8)
  {
    size_t v18 = (4 * v10 * v11 + 31) & 0x7FFFFFFE0;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v18, 0x49090899uLL);
    size_t v19 = (char *)memptr;
    signed int v21 = *(_DWORD *)a2;
    int v20 = *(_DWORD *)(a2 + 4);
    int v22 = *(_DWORD **)(a2 + 8);
    if (&v22[-*(unsigned int *)(a2 + 20)] == memptr)
    {
      int v111 = *(_DWORD *)(a2 + 4);
      unsigned int v112 = a3;
      uint64_t v54 = (v20 * v21);
      size_t v18 = (4 * v54 + 31) & 0x7FFFFFFE0;
      memptr = 0;
      malloc_type_posix_memalign(&memptr, 0x20uLL, v18, 0x49090899uLL);
      double v30 = memptr;
      if (v54)
      {
        int v55 = 0;
        signed int v56 = *(_DWORD *)a2;
        int v57 = *(_DWORD *)(a2 + 16) - *(_DWORD *)a2;
        v58 = *(_DWORD **)(a2 + 8);
        if (!(*(_DWORD *)(a2 + 4) * *(_DWORD *)a2)) {
          v58 = 0;
        }
        uint64_t v59 = 4 * v54;
        size_t v60 = memptr;
        do
        {
          *v60++ = *v58;
          if (v55 + 1 >= v56) {
            int v61 = v57;
          }
          else {
            int v61 = 0;
          }
          size_t v62 = &v58[v61];
          if (v55 + 1 < v56) {
            ++v55;
          }
          else {
            int v55 = 0;
          }
          v58 = v62 + 1;
          v59 -= 4;
        }
        while (v59);
      }
      free(v19);
      int v20 = v111;
      a3 = v112;
    }
    else
    {
      uint64_t v23 = (v20 * v21);
      if (v23)
      {
        uint64_t v24 = 0;
        int v25 = 0;
        int v26 = *(_DWORD *)(a2 + 16) - v21;
        uint64_t v27 = 4 * v23;
        do
        {
          *(_DWORD *)&v19[v24] = *v22;
          if (v25 + 1 >= v21) {
            int v28 = v26;
          }
          else {
            int v28 = 0;
          }
          double v29 = &v22[v28];
          if (v25 + 1 < v21) {
            ++v25;
          }
          else {
            int v25 = 0;
          }
          int v22 = v29 + 1;
          v24 += 4;
        }
        while (v27 != v24);
      }
      double v30 = v19;
    }
    size_t v53 = *(void **)(a1 + 48);
    *(void *)(a1 + 48) = v30;
    *(void *)(a1 + 56) = v18 >> 2;
    *(_DWORD *)(a1 + 64) = v21;
    *(_DWORD *)(a1 + 68) = v20;
    goto LABEL_62;
  }
  *(_DWORD *)(a1 + 64) = v11;
  *(_DWORD *)(a1 + 68) = v10;
  unint64_t v16 = v10 * v11;
  if (v16)
  {
    if (*(void *)(a1 + 56) < v16)
    {
      free(v15);
      size_t v17 = (4 * v16 + 31) & 0x7FFFFFFE0;
      *(void *)(a1 + 48) = 0;
      *(void *)(a1 + 56) = v17 >> 2;
      memptr = 0;
      malloc_type_posix_memalign(&memptr, 0x20uLL, v17, 0x49090899uLL);
      int v15 = memptr;
      *(void *)(a1 + 48) = memptr;
    }
  }
  else
  {
    free(v15);
    int v15 = 0;
    *BOOL v8 = 0;
    v8[1] = 0;
  }
LABEL_23:
  if ((_DWORD *)(*(void *)(a2 + 8) - 4 * *(unsigned int *)(a2 + 20)) == v15)
  {
    int v39 = *(_DWORD *)(a1 + 64);
    int v40 = *(_DWORD *)(a1 + 68);
    uint64_t v41 = (v40 * v39);
    size_t v42 = (4 * v41 + 31) & 0x7FFFFFFE0;
    size_t v43 = v42 >> 2;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v42, 0x49090899uLL);
    long long v44 = memptr;
    if (v41)
    {
      int v45 = 0;
      signed int v46 = *(_DWORD *)a2;
      int v47 = *(_DWORD *)(a2 + 16) - *(_DWORD *)a2;
      int v48 = *(_DWORD **)(a2 + 8);
      if (!(*(_DWORD *)(a2 + 4) * *(_DWORD *)a2)) {
        int v48 = 0;
      }
      uint64_t v49 = 4 * v41;
      size_t v50 = memptr;
      do
      {
        *v50++ = *v48;
        if (v45 + 1 >= v46) {
          int v51 = v47;
        }
        else {
          int v51 = 0;
        }
        v52 = &v48[v51];
        if (v45 + 1 < v46) {
          ++v45;
        }
        else {
          int v45 = 0;
        }
        int v48 = v52 + 1;
        v49 -= 4;
      }
      while (v49);
    }
    size_t v53 = *(void **)(a1 + 48);
    *(void *)(a1 + 48) = v44;
    *(void *)(a1 + 56) = v43;
    *(_DWORD *)(a1 + 64) = v39;
    *(_DWORD *)(a1 + 68) = v40;
LABEL_62:
    free(v53);
    goto LABEL_63;
  }
  uint64_t v31 = (*(_DWORD *)(a1 + 68) * *(_DWORD *)(a1 + 64));
  if (v31)
  {
    int v32 = 0;
    signed int v33 = *(_DWORD *)a2;
    int v34 = *(_DWORD *)(a2 + 16) - *(_DWORD *)a2;
    if (*(_DWORD *)(a2 + 4) * *(_DWORD *)a2) {
      double v35 = *(_DWORD **)(a2 + 8);
    }
    else {
      double v35 = 0;
    }
    uint64_t v36 = 4 * v31;
    do
    {
      *v15++ = *v35;
      if (v32 + 1 >= v33) {
        int v37 = v34;
      }
      else {
        int v37 = 0;
      }
      unint64_t v38 = &v35[v37];
      if (v32 + 1 < v33) {
        ++v32;
      }
      else {
        int v32 = 0;
      }
      double v35 = v38 + 1;
      v36 -= 4;
    }
    while (v36);
  }
LABEL_63:
  if (*(_DWORD *)(a1 + 88) != v7)
  {
    size_t v63 = (4 * v7 * v7 + 31) & 0x7FFFFFFE0;
    size_t v64 = v63 >> 2;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v63, 0x49090899uLL);
    uint64_t v65 = *(void **)(a1 + 72);
    *(void *)(a1 + 72) = memptr;
    *(void *)(a1 + 80) = v64;
    *(_DWORD *)(a1 + 88) = v7;
    *(_DWORD *)(a1 + 92) = v7;
    free(v65);
  }
  if (v6 >= v7) {
    unsigned int v66 = v7;
  }
  else {
    unsigned int v66 = v6;
  }
  if (*(_DWORD *)(a1 + 112) != v66)
  {
    size_t v67 = (4 * v66 + 31) & 0x7FFFFFFE0;
    size_t v68 = v67 >> 2;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v67, 0x49090899uLL);
    v69 = *(void **)(a1 + 96);
    *(void *)(a1 + 96) = memptr;
    *(void *)(a1 + 104) = v68;
    *(_DWORD *)(a1 + 112) = v66;
    *(_DWORD *)(a1 + 116) = 1;
    free(v69);
  }
  if (*(_DWORD *)(a1 + 136) != v6)
  {
    size_t v70 = (4 * (v6 * v6) + 31) & 0x7FFFFFFE0;
    size_t v71 = v70 >> 2;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v70, 0x49090899uLL);
    uint64_t v72 = *(void **)(a1 + 120);
    *(void *)(a1 + 120) = memptr;
    *(void *)(a1 + 128) = v71;
    *(_DWORD *)(a1 + 136) = v6;
    *(_DWORD *)(a1 + 140) = v6;
    free(v72);
  }
  if (sub_2153D034C((uint64_t)v8))
  {
    if (v6 >= a3) {
      uint64_t v73 = a3;
    }
    else {
      uint64_t v73 = v6;
    }
    if (*(_DWORD *)(a1 + 16) != v73)
    {
      size_t v74 = (4 * v73 + 31) & 0x7FFFFFFE0;
      size_t v75 = v74 >> 2;
      memptr = 0;
      malloc_type_posix_memalign(&memptr, 0x20uLL, v74, 0x49090899uLL);
      float v76 = *(float32x4_t **)a1;
      *(void *)a1 = memptr;
      *(void *)(a1 + 8) = v75;
      *(_DWORD *)(a1 + 16) = v73;
      *(_DWORD *)(a1 + 20) = 1;
      free(v76);
      size_t v77 = (4 * (v73 * v6) + 31) & 0x7FFFFFFE0;
      size_t v78 = v77 >> 2;
      memptr = 0;
      malloc_type_posix_memalign(&memptr, 0x20uLL, v77, 0x49090899uLL);
      int v79 = *(void **)(a1 + 24);
      *(void *)(a1 + 24) = memptr;
      *(void *)(a1 + 32) = v78;
      *(_DWORD *)(a1 + 40) = v6;
      *(_DWORD *)(a1 + 44) = v73;
      free(v79);
    }
    if (v73)
    {
      uint64_t v80 = 0;
      int v81 = *(float32x4_t **)(a1 + 96);
      uint64_t v82 = *(float32x4_t **)a1;
      if (v73 < 8) {
        goto LABEL_84;
      }
      if ((unint64_t)((char *)v82 - (char *)v81) <= 0x1F) {
        goto LABEL_84;
      }
      uint64_t v80 = v73 & 0xFFFFFFF8;
      int v83 = v82 + 1;
      uint64_t v84 = v81 + 1;
      uint64_t v85 = v80;
      do
      {
        float32x4_t v86 = vmulq_f32(*v84, *v84);
        v83[-1] = vmulq_f32(v84[-1], v84[-1]);
        *int v83 = v86;
        v83 += 2;
        v84 += 2;
        v85 -= 8;
      }
      while (v85);
      if (v80 != v73)
      {
LABEL_84:
        uint64_t v87 = v73 - v80;
        uint64_t v88 = v80;
        long long v89 = &v82->f32[v80];
        long long v90 = &v81->f32[v88];
        do
        {
          float v91 = *v90++;
          *v89++ = v91 * v91;
          --v87;
        }
        while (v87);
      }
      int v92 = 0;
      uint64_t v93 = 0;
      int v94 = *(_DWORD *)(a1 + 136);
      uint64_t v95 = *(void *)(a1 + 120);
      int v96 = *(_DWORD *)(a1 + 40);
      uint64_t v97 = *(void *)(a1 + 24);
      int v98 = v6 - 1;
      uint64_t v99 = v6 & 0xFFFFFFF8;
      do
      {
        if (v6 >= 0x14)
        {
          uint64_t v100 = 0;
          BOOL v102 = __CFADD__(v96 * v93, v98);
          if (!__CFADD__(v93, v98)
            && v94 == 1
            && !v102
            && !((unint64_t)(v6 - 1) >> 32)
            && v97 + 4 * (unint64_t)(v96 * v93) - (v95 + 4 * v93) >= 0x20)
          {
            uint64_t v103 = 0;
            do
            {
              v104 = (long long *)(v95 + 4 * (v93 + v103));
              long long v105 = *v104;
              long long v106 = v104[1];
              v107 = (_OWORD *)(v97 + 4 * (v92 + v103));
              _OWORD *v107 = v105;
              v107[1] = v106;
              v103 += 8;
            }
            while (v99 != v103);
            uint64_t v100 = v6 & 0xFFFFFFF8;
            if (v99 == v6) {
              goto LABEL_87;
            }
          }
        }
        else
        {
          uint64_t v100 = 0;
        }
        unsigned int v101 = v93 + v94 * v100;
        do
        {
          *(_DWORD *)(v97 + 4 * (v92 + v100++)) = *(_DWORD *)(v95 + 4 * v101);
          v101 += v94;
        }
        while (v6 != v100);
LABEL_87:
        ++v93;
        v92 += v96;
      }
      while (v93 != v73);
    }
  }
  else
  {
    v108 = *(float32x4_t **)a1;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    free(v108);
    v109 = *(void **)(a1 + 24);
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 40) = 0;
    *(void *)(a1 + 24) = 0;
    free(v109);
  }
  return a1;
}

void cva::PCA<float>::project<cva::Matrix<float,0u,0u,false>,void>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  uint64_t v6 = (void **)(a1 + 24);
  int v7 = *(_DWORD *)(a2 + 16);
  if (v7 != *(_DWORD *)(a3 + 16) || *(_DWORD *)(a1 + 44) != *(_DWORD *)(a3 + 20))
  {
    BOOL v8 = *(void **)a3;
    if (*(void *)a2 == *(void *)a3 || *v6 == v8)
    {
      size_t v12 = (4 * (*(_DWORD *)(a1 + 44) * v7) + 31) & 0x7FFFFFFE0;
      size_t v17 = v12 >> 2;
      memptr = 0;
      malloc_type_posix_memalign(&memptr, 0x20uLL, v12, 0x49090899uLL);
      unint64_t v16 = memptr;
      int v13 = *(_DWORD *)(a1 + 44);
      LODWORD(v18) = *(_DWORD *)(a2 + 16);
      HIDWORD(v18) = v13;
      uint64_t v20 = a2;
      signed int v21 = v6;
      int v22 = 1065353216;
      sub_2153D0D58((uint64_t)&v16, (uint64_t)&memptr);
      uint64_t v14 = *(void **)a3;
      size_t v15 = v17;
      *(void *)a3 = v16;
      *(void *)(a3 + 8) = v15;
      *(void *)(a3 + 16) = v18;
      free(v14);
      return;
    }
    int v9 = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a3 + 16) = v7;
    *(_DWORD *)(a3 + 20) = v9;
    unint64_t v10 = (v9 * v7);
    if (v10)
    {
      if (*(void *)(a3 + 8) < v10)
      {
        free(v8);
        size_t v11 = (4 * v10 + 31) & 0x7FFFFFFE0;
        *(void *)a3 = 0;
        *(void *)(a3 + 8) = v11 >> 2;
        memptr = 0;
        malloc_type_posix_memalign(&memptr, 0x20uLL, v11, 0x49090899uLL);
        *(void *)a3 = memptr;
      }
    }
    else
    {
      free(v8);
      *(void *)a3 = 0;
      *(void *)(a3 + 8) = 0;
    }
  }
  uint64_t v20 = a2;
  signed int v21 = v6;
  int v22 = 1065353216;
  sub_2153D0D58(a3, (uint64_t)&memptr);
}

void sub_2153D0D58(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void *)(a2 + 8);
  uint64_t v6 = *(void *)(a2 + 16);
  if (*(void **)v5 == v4 || *(void **)v6 == v4)
  {
    size_t v7 = (4 * (*(_DWORD *)(v6 + 20) * *(_DWORD *)(v5 + 16)) + 31) & 0x7FFFFFFE0;
    size_t v13 = v7 >> 2;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v7, 0x49090899uLL);
    size_t v12 = memptr;
    int v8 = *(_DWORD *)(*(void *)(a2 + 16) + 20);
    LODWORD(v14) = *(_DWORD *)(*(void *)(a2 + 8) + 16);
    HIDWORD(v14) = v8;
    sub_2153D0D58(&v12, a2);
    int v9 = *(void **)a1;
    size_t v10 = v13;
    *(void *)a1 = v12;
    *(void *)(a1 + 8) = v10;
    *(void *)(a1 + 16) = v14;
    free(v9);
  }
  else if (*(_DWORD *)(v5 + 20) * *(_DWORD *)(v5 + 16) && *(_DWORD *)(v6 + 20) * *(_DWORD *)(v6 + 16))
  {
    cblas_sgemm_NEWLAPACK();
  }
  else
  {
    unsigned int v11 = *(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16);
    if (v11)
    {
      bzero(v4, 4 * v11);
    }
  }
}

void cva::PCA<float>::project<cva::MatrixRef<float,0u,0u,false>,void>(uint64_t a1, int *a2, int *a3)
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  unint64_t v38 = a2;
  uint64_t v39 = a1 + 24;
  int v40 = 1065353216;
  uint64_t v6 = *((void *)a3 + 1);
  uint64_t v7 = v6 - 4 * a3[5];
  if (*((void *)a2 + 1) - 4 * a2[5] == v7 || *(void *)(a1 + 24) == v7)
  {
    size_t v8 = (4 * (*(_DWORD *)(a1 + 44) * *a2) + 31) & 0x7FFFFFFE0;
    v33[1] = (void *)(v8 >> 2);
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v8, 0x49090899uLL);
    v33[0] = memptr;
    int v9 = *(_DWORD *)(a1 + 44);
    int v34 = *a2;
    int v35 = v9;
    sub_2153D1098((uint64_t)v33, (uint64_t)v37);
    int v10 = *a3;
    int v11 = a3[1];
    int v12 = v11 * *a3;
    int v13 = a3[4];
    BOOL v14 = v12 == 0;
    if (v12) {
      size_t v15 = (_DWORD *)*((void *)a3 + 1);
    }
    else {
      size_t v15 = 0;
    }
    uint64_t v16 = *((void *)a3 + 1) + 4 * (v13 * v11);
    if (v14) {
      uint64_t v16 = 0;
    }
    size_t v17 = v33[0];
    if (v15 != (_DWORD *)v16)
    {
      int v18 = 0;
      unsigned int v19 = v13 - v10;
      uint64_t v20 = (int *)v33[0];
      do
      {
        int v21 = *v20++;
        _DWORD *v15 = v21;
        if (v18 + 1 >= v10) {
          unsigned int v22 = v19;
        }
        else {
          unsigned int v22 = 0;
        }
        v15 += v22 + 1;
        if (v18 + 1 < v10) {
          ++v18;
        }
        else {
          int v18 = 0;
        }
      }
      while (v15 != (_DWORD *)v16);
    }
    free(v17);
  }
  else if (a2[1] * *a2 && *(_DWORD *)(a1 + 44) * *(_DWORD *)(a1 + 40))
  {
    cblas_sgemm_NEWLAPACK();
  }
  else
  {
    int v23 = *a3;
    int v24 = a3[1];
    int v25 = v24 * *a3;
    int v26 = a3[4];
    BOOL v27 = v25 == 0;
    if (v25) {
      int v28 = (_DWORD *)*((void *)a3 + 1);
    }
    else {
      int v28 = 0;
    }
    double v29 = (_DWORD *)(v6 + 4 * (v26 * v24));
    if (v27) {
      double v29 = 0;
    }
    if (v28 != v29)
    {
      int v30 = 0;
      unsigned int v31 = v26 - v23;
      do
      {
        _DWORD *v28 = 0;
        if (v30 + 1 >= v23) {
          unsigned int v32 = v31;
        }
        else {
          unsigned int v32 = 0;
        }
        v28 += v32 + 1;
        if (v30 + 1 < v23) {
          ++v30;
        }
        else {
          int v30 = 0;
        }
      }
      while (v28 != v29);
    }
  }
}

void sub_2153D1098(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void *)(a2 + 8);
  uint64_t v6 = *(void *)(a2 + 16);
  if ((void *)(*(void *)(v5 + 8) - 4 * *(unsigned int *)(v5 + 20)) == v4 || *(void **)v6 == v4)
  {
    size_t v7 = (4 * (*(_DWORD *)(v6 + 20) * *(_DWORD *)v5) + 31) & 0x7FFFFFFE0;
    size_t v13 = v7 >> 2;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v7, 0x49090899uLL);
    int v12 = memptr;
    int v8 = *(_DWORD *)(*(void *)(a2 + 16) + 20);
    LODWORD(v14) = **(_DWORD **)(a2 + 8);
    HIDWORD(v14) = v8;
    sub_2153D1098(&v12, a2);
    int v9 = *(void **)a1;
    size_t v10 = v13;
    *(void *)a1 = v12;
    *(void *)(a1 + 8) = v10;
    *(void *)(a1 + 16) = v14;
    free(v9);
  }
  else if (*(_DWORD *)(v5 + 4) * *(_DWORD *)v5 && *(_DWORD *)(v6 + 20) * *(_DWORD *)(v6 + 16))
  {
    cblas_sgemm_NEWLAPACK();
  }
  else
  {
    unsigned int v11 = *(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16);
    if (v11)
    {
      bzero(v4, 4 * v11);
    }
  }
}

void cva::PCA<float>::backProject<cva::Matrix<float,0u,0u,false>,void>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  uint64_t v14 = a1 + 24;
  int v5 = *(_DWORD *)(a2 + 16);
  if (v5 != *(_DWORD *)(a3 + 16) || *(_DWORD *)(a1 + 40) != *(_DWORD *)(a3 + 20))
  {
    uint64_t v6 = *(void **)a3;
    if (*(void *)a2 == *(void *)a3 || *(void **)(a1 + 24) == v6)
    {
      size_t v10 = (4 * (*(_DWORD *)(a1 + 40) * v5) + 31) & 0x7FFFFFFE0;
      size_t v16 = v10 >> 2;
      memptr = 0;
      malloc_type_posix_memalign(&memptr, 0x20uLL, v10, 0x49090899uLL);
      size_t v15 = memptr;
      int v11 = *(_DWORD *)(v14 + 16);
      LODWORD(v17) = *(_DWORD *)(a2 + 16);
      HIDWORD(v17) = v11;
      uint64_t v19 = a2;
      uint64_t v20 = &v14;
      int v21 = 1065353216;
      sub_2153D1388((uint64_t)&v15, (uint64_t)&memptr);
      int v12 = *(void **)a3;
      size_t v13 = v16;
      *(void *)a3 = v15;
      *(void *)(a3 + 8) = v13;
      *(void *)(a3 + 16) = v17;
      free(v12);
      return;
    }
    int v7 = *(_DWORD *)(a1 + 40);
    *(_DWORD *)(a3 + 16) = v5;
    *(_DWORD *)(a3 + 20) = v7;
    unint64_t v8 = (v7 * v5);
    if (v8)
    {
      if (*(void *)(a3 + 8) < v8)
      {
        free(v6);
        size_t v9 = (4 * v8 + 31) & 0x7FFFFFFE0;
        *(void *)a3 = 0;
        *(void *)(a3 + 8) = v9 >> 2;
        memptr = 0;
        malloc_type_posix_memalign(&memptr, 0x20uLL, v9, 0x49090899uLL);
        *(void *)a3 = memptr;
      }
    }
    else
    {
      free(v6);
      *(void *)a3 = 0;
      *(void *)(a3 + 8) = 0;
    }
  }
  uint64_t v19 = a2;
  uint64_t v20 = &v14;
  int v21 = 1065353216;
  sub_2153D1388(a3, (uint64_t)&memptr);
}

void sub_2153D1388(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void *)(a2 + 8);
  uint64_t v6 = **(void **)(a2 + 16);
  if (*(void **)v5 == v4 || *(void **)v6 == v4)
  {
    size_t v7 = (4 * (*(_DWORD *)(v6 + 16) * *(_DWORD *)(v5 + 16)) + 31) & 0x7FFFFFFE0;
    size_t v13 = v7 >> 2;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v7, 0x49090899uLL);
    int v12 = memptr;
    int v8 = *(_DWORD *)(**(void **)(a2 + 16) + 16);
    LODWORD(v14) = *(_DWORD *)(*(void *)(a2 + 8) + 16);
    HIDWORD(v14) = v8;
    sub_2153D1388(&v12, a2);
    size_t v9 = *(void **)a1;
    size_t v10 = v13;
    *(void *)a1 = v12;
    *(void *)(a1 + 8) = v10;
    *(void *)(a1 + 16) = v14;
    free(v9);
  }
  else if (*(_DWORD *)(v5 + 20) * *(_DWORD *)(v5 + 16) && *(_DWORD *)(v6 + 16) * *(_DWORD *)(v6 + 20))
  {
    cblas_sgemm_NEWLAPACK();
  }
  else
  {
    unsigned int v11 = *(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16);
    if (v11)
    {
      bzero(v4, 4 * v11);
    }
  }
}

void cva::PCA<float>::backProject<cva::MatrixRef<float,0u,0u,false>,void>(uint64_t a1, int *a2, int *a3)
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  uint64_t v32 = a1 + 24;
  unint64_t v38 = a2;
  uint64_t v39 = &v32;
  int v40 = 1065353216;
  uint64_t v5 = *((void *)a3 + 1);
  uint64_t v6 = v5 - 4 * a3[5];
  if (*((void *)a2 + 1) - 4 * a2[5] == v6 || *(void *)(a1 + 24) == v6)
  {
    size_t v7 = (4 * (*(_DWORD *)(a1 + 40) * *a2) + 31) & 0x7FFFFFFE0;
    v33[1] = (void *)(v7 >> 2);
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v7, 0x49090899uLL);
    v33[0] = memptr;
    int v8 = *(_DWORD *)(v32 + 16);
    int v34 = *a2;
    int v35 = v8;
    sub_2153D16D0((uint64_t)v33, (uint64_t)v37);
    int v9 = *a3;
    int v10 = a3[1];
    int v11 = v10 * *a3;
    int v12 = a3[4];
    BOOL v13 = v11 == 0;
    if (v11) {
      uint64_t v14 = (_DWORD *)*((void *)a3 + 1);
    }
    else {
      uint64_t v14 = 0;
    }
    uint64_t v15 = *((void *)a3 + 1) + 4 * (v12 * v10);
    if (v13) {
      uint64_t v15 = 0;
    }
    size_t v16 = v33[0];
    if (v14 != (_DWORD *)v15)
    {
      int v17 = 0;
      unsigned int v18 = v12 - v9;
      uint64_t v19 = (int *)v33[0];
      do
      {
        int v20 = *v19++;
        _DWORD *v14 = v20;
        if (v17 + 1 >= v9) {
          unsigned int v21 = v18;
        }
        else {
          unsigned int v21 = 0;
        }
        v14 += v21 + 1;
        if (v17 + 1 < v9) {
          ++v17;
        }
        else {
          int v17 = 0;
        }
      }
      while (v14 != (_DWORD *)v15);
    }
    free(v16);
  }
  else if (a2[1] * *a2 && *(_DWORD *)(a1 + 40) * *(_DWORD *)(a1 + 44))
  {
    cblas_sgemm_NEWLAPACK();
  }
  else
  {
    int v22 = *a3;
    int v23 = a3[1];
    int v24 = v23 * *a3;
    int v25 = a3[4];
    BOOL v26 = v24 == 0;
    if (v24) {
      BOOL v27 = (_DWORD *)*((void *)a3 + 1);
    }
    else {
      BOOL v27 = 0;
    }
    int v28 = (_DWORD *)(v5 + 4 * (v25 * v23));
    if (v26) {
      int v28 = 0;
    }
    if (v27 != v28)
    {
      int v29 = 0;
      unsigned int v30 = v25 - v22;
      do
      {
        _DWORD *v27 = 0;
        if (v29 + 1 >= v22) {
          unsigned int v31 = v30;
        }
        else {
          unsigned int v31 = 0;
        }
        v27 += v31 + 1;
        if (v29 + 1 < v22) {
          ++v29;
        }
        else {
          int v29 = 0;
        }
      }
      while (v27 != v28);
    }
  }
}

void sub_2153D16D0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void *)(a2 + 8);
  uint64_t v6 = **(void **)(a2 + 16);
  if ((void *)(*(void *)(v5 + 8) - 4 * *(unsigned int *)(v5 + 20)) == v4 || *(void **)v6 == v4)
  {
    size_t v7 = (4 * (*(_DWORD *)(v6 + 16) * *(_DWORD *)v5) + 31) & 0x7FFFFFFE0;
    size_t v13 = v7 >> 2;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v7, 0x49090899uLL);
    int v12 = memptr;
    int v8 = *(_DWORD *)(**(void **)(a2 + 16) + 16);
    LODWORD(v14) = **(_DWORD **)(a2 + 8);
    HIDWORD(v14) = v8;
    sub_2153D16D0(&v12, a2);
    int v9 = *(void **)a1;
    size_t v10 = v13;
    *(void *)a1 = v12;
    *(void *)(a1 + 8) = v10;
    *(void *)(a1 + 16) = v14;
    free(v9);
  }
  else if (*(_DWORD *)(v5 + 4) * *(_DWORD *)v5 && *(_DWORD *)(v6 + 16) * *(_DWORD *)(v6 + 20))
  {
    cblas_sgemm_NEWLAPACK();
  }
  else
  {
    unsigned int v11 = *(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16);
    if (v11)
    {
      bzero(v4, 4 * v11);
    }
  }
}

double cva::PCA<double>::PCA(_OWORD *a1)
{
  double result = 0.0;
  a1[7] = 0u;
  a1[8] = 0u;
  a1[5] = 0u;
  a1[6] = 0u;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  *a1 = 0u;
  return result;
}

{
  double result;

  double result = 0.0;
  a1[7] = 0u;
  a1[8] = 0u;
  a1[5] = 0u;
  a1[6] = 0u;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  *a1 = 0u;
  return result;
}

uint64_t cva::PCA<double>::eigenvectors(uint64_t a1)
{
  return a1 + 24;
}

char **cva::PCA<double>::operator()<cva::Matrix<double,0u,0u,false>,void>(void **a1, uint64_t a2, int a3)
{
  LODWORD(v3) = a3;
  unsigned int v6 = *(_DWORD *)(a2 + 16);
  uint64_t v7 = *(unsigned int *)(a2 + 20);
  int v8 = a1 + 6;
  if (*((_DWORD *)a1 + 16) != v6
    || (int v9 = *(_DWORD *)(a2 + 16), v10 = *(_DWORD *)(a2 + 20), v11 = v9, *((_DWORD *)a1 + 17) != v6))
  {
    size_t v12 = (8 * v7 * v6 + 31) & 0xFFFFFFFE0;
    size_t v13 = v12 >> 3;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v12, 0x49090899uLL);
    uint64_t v14 = (char *)a1[6];
    a1[6] = memptr;
    a1[7] = (void *)v13;
    *((_DWORD *)a1 + 16) = v6;
    *((_DWORD *)a1 + 17) = v7;
    free(v14);
    int v11 = *(_DWORD *)(a2 + 16);
    int v10 = *(_DWORD *)(a2 + 20);
    if (v11 != *((_DWORD *)a1 + 16)) {
      goto LABEL_7;
    }
    int v9 = *((_DWORD *)a1 + 17);
  }
  if (v10 == v9)
  {
    uint64_t v15 = (_OWORD *)*v8;
    goto LABEL_19;
  }
LABEL_7:
  uint64_t v15 = (_OWORD *)*v8;
  if (*(void *)a2 == *v8)
  {
    size_t v18 = (8 * (v10 * v11) + 31) & 0xFFFFFFFE0;
    size_t v19 = v18 >> 3;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v18, 0x49090899uLL);
    int v20 = (char *)memptr;
    int v21 = *(_DWORD *)(a2 + 16);
    int v22 = *(_DWORD *)(a2 + 20);
    uint64_t v23 = (v22 * v21);
    if (v23)
    {
      int v24 = *(uint64_t **)a2;
      unint64_t v25 = (v23 - 1) & 0x1FFFFFFFFFFFFFFFLL;
      if (v25 < 3)
      {
        BOOL v26 = (char *)memptr;
      }
      else
      {
        BOOL v26 = (char *)memptr;
        if ((unint64_t)((unsigned char *)memptr - (unsigned char *)v24) >= 0x20)
        {
          unint64_t v27 = v25 + 1;
          uint64_t v28 = (v25 + 1) & 0x3FFFFFFFFFFFFFFCLL;
          int v29 = &v24[v28];
          unsigned int v30 = (char *)memptr + 16;
          unsigned int v31 = (long long *)(v24 + 2);
          uint64_t v32 = v28;
          do
          {
            long long v33 = *v31;
            *(v30 - 1) = *(v31 - 1);
            _OWORD *v30 = v33;
            v30 += 2;
            v31 += 2;
            v32 -= 4;
          }
          while (v32);
          if (v27 == v28) {
            goto LABEL_33;
          }
          BOOL v26 = &v20[8 * v28];
          int v24 = v29;
        }
      }
      int v47 = &v20[8 * v23];
      do
      {
        uint64_t v48 = *v24++;
        *(void *)BOOL v26 = v48;
        v26 += 8;
      }
      while (v26 != v47);
    }
LABEL_33:
    uint64_t v49 = (char *)a1[6];
    a1[6] = v20;
    a1[7] = (void *)v19;
    *((_DWORD *)a1 + 16) = v21;
    *((_DWORD *)a1 + 17) = v22;
    free(v49);
    goto LABEL_34;
  }
  *((_DWORD *)a1 + 16) = v11;
  *((_DWORD *)a1 + 17) = v10;
  unint64_t v16 = (v10 * v11);
  if (v16)
  {
    if ((unint64_t)a1[7] < v16)
    {
      free(v15);
      size_t v17 = (8 * v16 + 31) & 0xFFFFFFFE0;
      a1[6] = 0;
      a1[7] = (void *)(v17 >> 3);
      memptr = 0;
      malloc_type_posix_memalign(&memptr, 0x20uLL, v17, 0x49090899uLL);
      uint64_t v15 = memptr;
      a1[6] = memptr;
    }
  }
  else
  {
    free(v15);
    uint64_t v15 = 0;
    *int v8 = 0;
    v8[1] = 0;
  }
LABEL_19:
  uint64_t v34 = (*((_DWORD *)a1 + 17) * *((_DWORD *)a1 + 16));
  if (!v34) {
    goto LABEL_34;
  }
  int v35 = *(uint64_t **)a2;
  unint64_t v36 = (v34 - 1) & 0x1FFFFFFFFFFFFFFFLL;
  if (v36 < 3)
  {
    int v37 = v15;
LABEL_27:
    int v45 = (void *)v15 + v34;
    do
    {
      uint64_t v46 = *v35++;
      *v37++ = v46;
    }
    while (v37 != v45);
    goto LABEL_34;
  }
  int v37 = v15;
  if ((unint64_t)((char *)v15 - (char *)v35) < 0x20) {
    goto LABEL_27;
  }
  unint64_t v38 = v36 + 1;
  uint64_t v39 = (v36 + 1) & 0x3FFFFFFFFFFFFFFCLL;
  int v40 = &v35[v39];
  uint64_t v41 = v15 + 1;
  size_t v42 = (long long *)(v35 + 2);
  uint64_t v43 = v39;
  do
  {
    long long v44 = *v42;
    *(v41 - 1) = *(v42 - 1);
    _OWORD *v41 = v44;
    v41 += 2;
    v42 += 2;
    v43 -= 4;
  }
  while (v43);
  if (v38 != v39)
  {
    int v37 = (void *)v15 + v39;
    int v35 = v40;
    goto LABEL_27;
  }
LABEL_34:
  if (*((_DWORD *)a1 + 22) != v6)
  {
    size_t v50 = (8 * v6 * v6 + 31) & 0xFFFFFFFE0;
    size_t v51 = v50 >> 3;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v50, 0x49090899uLL);
    v52 = (char *)a1[9];
    a1[9] = memptr;
    a1[10] = (void *)v51;
    *((_DWORD *)a1 + 22) = v6;
    *((_DWORD *)a1 + 23) = v6;
    free(v52);
  }
  if (v7 < v6) {
    unsigned int v6 = v7;
  }
  if (*((_DWORD *)a1 + 28) != v6)
  {
    size_t v53 = (8 * v6 + 31) & 0xFFFFFFFE0;
    size_t v54 = v53 >> 3;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v53, 0x49090899uLL);
    int v55 = (char *)a1[12];
    a1[12] = memptr;
    a1[13] = (void *)v54;
    *((_DWORD *)a1 + 28) = v6;
    *((_DWORD *)a1 + 29) = 1;
    free(v55);
  }
  if (*((_DWORD *)a1 + 34) != v7)
  {
    size_t v56 = (8 * (v7 * v7) + 31) & 0xFFFFFFFE0;
    size_t v57 = v56 >> 3;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v56, 0x49090899uLL);
    v58 = (char *)a1[15];
    a1[15] = memptr;
    a1[16] = (void *)v57;
    *((_DWORD *)a1 + 34) = v7;
    *((_DWORD *)a1 + 35) = v7;
    free(v58);
  }
  if (sub_2153D1E30((uint64_t)v8))
  {
    if (v7 >= v3) {
      uint64_t v3 = v3;
    }
    else {
      uint64_t v3 = v7;
    }
    if (*((_DWORD *)a1 + 4) != v3)
    {
      size_t v59 = (8 * v3 + 31) & 0xFFFFFFFE0;
      size_t v60 = v59 >> 3;
      memptr = 0;
      malloc_type_posix_memalign(&memptr, 0x20uLL, v59, 0x49090899uLL);
      int v61 = *a1;
      *a1 = memptr;
      a1[1] = (void *)v60;
      *((_DWORD *)a1 + 4) = v3;
      *((_DWORD *)a1 + 5) = 1;
      free(v61);
      size_t v62 = (8 * (v3 * v7) + 31) & 0xFFFFFFFE0;
      size_t v63 = v62 >> 3;
      memptr = 0;
      malloc_type_posix_memalign(&memptr, 0x20uLL, v62, 0x49090899uLL);
      size_t v64 = (char *)a1[3];
      a1[3] = memptr;
      a1[4] = (void *)v63;
      *((_DWORD *)a1 + 10) = v7;
      *((_DWORD *)a1 + 11) = v3;
      free(v64);
    }
    if (v3)
    {
      uint64_t v65 = 0;
      unsigned int v66 = (float64x2_t *)a1[12];
      size_t v67 = (float64x2_t *)*a1;
      if (v3 < 4) {
        goto LABEL_54;
      }
      if ((unint64_t)((char *)v67 - (char *)v66) <= 0x1F) {
        goto LABEL_54;
      }
      uint64_t v65 = v3 & 0xFFFFFFFC;
      size_t v68 = v67 + 1;
      v69 = v66 + 1;
      uint64_t v70 = v65;
      do
      {
        float64x2_t v71 = vmulq_f64(*v69, *v69);
        v68[-1] = vmulq_f64(v69[-1], v69[-1]);
        float64x2_t *v68 = v71;
        v68 += 2;
        v69 += 2;
        v70 -= 4;
      }
      while (v70);
      if (v65 != v3)
      {
LABEL_54:
        uint64_t v72 = v3 - v65;
        uint64_t v73 = v65;
        size_t v74 = &v67->f64[v65];
        size_t v75 = &v66->f64[v73];
        do
        {
          double v76 = *v75++;
          *v74++ = v76 * v76;
          --v72;
        }
        while (v72);
      }
      int v77 = 0;
      uint64_t v78 = 0;
      int v79 = *((_DWORD *)a1 + 34);
      uint64_t v80 = (char *)a1[15];
      int v81 = *((_DWORD *)a1 + 10);
      uint64_t v82 = (char *)a1[3];
      int v83 = v7 - 1;
      uint64_t v84 = v7 & 0xFFFFFFFC;
      do
      {
        if (v7 >= 0x12)
        {
          uint64_t v85 = 0;
          BOOL v86 = __CFADD__(v81 * v78, v83);
          if (!__CFADD__(v78, v83)
            && v79 == 1
            && !v86
            && !((unint64_t)(v7 - 1) >> 32)
            && (unint64_t)(&v82[8 * (v81 * v78)] - &v80[8 * v78]) >= 0x20)
          {
            uint64_t v87 = 0;
            do
            {
              uint64_t v88 = (long long *)&v80[8 * (v78 + v87)];
              long long v89 = *v88;
              long long v90 = v88[1];
              float v91 = &v82[8 * (v77 + v87)];
              *(_OWORD *)float v91 = v89;
              *((_OWORD *)v91 + 1) = v90;
              v87 += 4;
            }
            while (v84 != v87);
            uint64_t v85 = v7 & 0xFFFFFFFC;
            if (v84 == v7) {
              goto LABEL_57;
            }
          }
        }
        else
        {
          uint64_t v85 = 0;
        }
        unsigned int v92 = v78 + v79 * v85;
        do
        {
          *(void *)&v82[8 * (v77 + v85++)] = *(void *)&v80[8 * v92];
          v92 += v79;
        }
        while (v7 != v85);
LABEL_57:
        ++v78;
        v77 += v81;
      }
      while (v78 != v3);
    }
  }
  else
  {
    uint64_t v93 = *a1;
    a1[1] = 0;
    a1[2] = 0;
    *a1 = 0;
    free(v93);
    int v94 = (char *)a1[3];
    a1[4] = 0;
    a1[5] = 0;
    a1[3] = 0;
    free(v94);
  }
  return (char **)a1;
}

uint64_t sub_2153D1E30(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 20) >= *(_DWORD *)(a1 + 16)) {
    int v1 = *(_DWORD *)(a1 + 16);
  }
  else {
    int v1 = *(_DWORD *)(a1 + 20);
  }
  if (4 * (8 * v1)) {
    uint64_t v2 = malloc_type_malloc(4 * (8 * v1), 0xA153FF5uLL);
  }
  else {
    uint64_t v2 = 0;
  }
  dgesdd_NEWLAPACK();
  if (8 * (int)0.0) {
    uint64_t v3 = malloc_type_malloc(8 * (int)0.0, 0xA153FF5uLL);
  }
  else {
    uint64_t v3 = 0;
  }
  dgesdd_NEWLAPACK();
  if (v3) {
    free(v3);
  }
  if (v2) {
    free(v2);
  }
  return 1;
}

char **cva::PCA<double>::operator()<cva::MatrixRef<double,0u,0u,false>,void>(void **a1, uint64_t a2, unsigned int a3)
{
  unsigned int v7 = *(_DWORD *)a2;
  uint64_t v6 = *(unsigned int *)(a2 + 4);
  int v8 = a1 + 6;
  if (*((_DWORD *)a1 + 16) != *(_DWORD *)a2
    || (unsigned int v9 = *(_DWORD *)a2, v10 = *(_DWORD *)(a2 + 4), v11 = *(_DWORD *)a2, *((_DWORD *)a1 + 17) != v7))
  {
    size_t v12 = (8 * v6 * v7 + 31) & 0xFFFFFFFE0;
    size_t v13 = v12 >> 3;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v12, 0x49090899uLL);
    uint64_t v14 = (char *)a1[6];
    a1[6] = memptr;
    a1[7] = (void *)v13;
    *((_DWORD *)a1 + 16) = v7;
    *((_DWORD *)a1 + 17) = v6;
    free(v14);
    unsigned int v11 = *(_DWORD *)a2;
    int v10 = *(_DWORD *)(a2 + 4);
    if (*(_DWORD *)a2 != *((_DWORD *)a1 + 16)) {
      goto LABEL_7;
    }
    unsigned int v9 = *((_DWORD *)a1 + 17);
  }
  if (v10 == v9)
  {
    uint64_t v15 = (void *)*v8;
    goto LABEL_23;
  }
LABEL_7:
  uint64_t v15 = (void *)*v8;
  if (*(void *)(a2 + 8) - 8 * *(unsigned int *)(a2 + 20) == *v8)
  {
    size_t v18 = (8 * v10 * v11 + 31) & 0xFFFFFFFE0;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v18, 0x49090899uLL);
    size_t v19 = (char *)memptr;
    signed int v21 = *(_DWORD *)a2;
    int v20 = *(_DWORD *)(a2 + 4);
    int v22 = *(void **)(a2 + 8);
    if (&v22[-*(unsigned int *)(a2 + 20)] == memptr)
    {
      int v111 = *(_DWORD *)(a2 + 4);
      unsigned int v112 = a3;
      uint64_t v54 = (v20 * v21);
      size_t v18 = (8 * v54 + 31) & 0xFFFFFFFE0;
      memptr = 0;
      malloc_type_posix_memalign(&memptr, 0x20uLL, v18, 0x49090899uLL);
      unsigned int v30 = (char *)memptr;
      if (v54)
      {
        int v55 = 0;
        signed int v56 = *(_DWORD *)a2;
        int v57 = *(_DWORD *)(a2 + 16) - *(_DWORD *)a2;
        v58 = *(void **)(a2 + 8);
        if (!(*(_DWORD *)(a2 + 4) * *(_DWORD *)a2)) {
          v58 = 0;
        }
        uint64_t v59 = 8 * v54;
        size_t v60 = memptr;
        do
        {
          *v60++ = *v58;
          if (v55 + 1 >= v56) {
            int v61 = v57;
          }
          else {
            int v61 = 0;
          }
          size_t v62 = &v58[v61];
          if (v55 + 1 < v56) {
            ++v55;
          }
          else {
            int v55 = 0;
          }
          v58 = v62 + 1;
          v59 -= 8;
        }
        while (v59);
      }
      free(v19);
      int v20 = v111;
      a3 = v112;
    }
    else
    {
      uint64_t v23 = (v20 * v21);
      if (v23)
      {
        uint64_t v24 = 0;
        int v25 = 0;
        int v26 = *(_DWORD *)(a2 + 16) - v21;
        uint64_t v27 = 8 * v23;
        do
        {
          *(void *)&v19[v24] = *v22;
          if (v25 + 1 >= v21) {
            int v28 = v26;
          }
          else {
            int v28 = 0;
          }
          int v29 = &v22[v28];
          if (v25 + 1 < v21) {
            ++v25;
          }
          else {
            int v25 = 0;
          }
          int v22 = v29 + 1;
          v24 += 8;
        }
        while (v27 != v24);
      }
      unsigned int v30 = v19;
    }
    size_t v53 = (char *)a1[6];
    a1[6] = v30;
    a1[7] = (void *)(v18 >> 3);
    *((_DWORD *)a1 + 16) = v21;
    *((_DWORD *)a1 + 17) = v20;
    goto LABEL_62;
  }
  *((_DWORD *)a1 + 16) = v11;
  *((_DWORD *)a1 + 17) = v10;
  unint64_t v16 = v10 * v11;
  if (v16)
  {
    if ((unint64_t)a1[7] < v16)
    {
      free(v15);
      size_t v17 = (8 * v16 + 31) & 0xFFFFFFFE0;
      a1[6] = 0;
      a1[7] = (void *)(v17 >> 3);
      memptr = 0;
      malloc_type_posix_memalign(&memptr, 0x20uLL, v17, 0x49090899uLL);
      uint64_t v15 = memptr;
      a1[6] = memptr;
    }
  }
  else
  {
    free(v15);
    uint64_t v15 = 0;
    *int v8 = 0;
    v8[1] = 0;
  }
LABEL_23:
  if ((void *)(*(void *)(a2 + 8) - 8 * *(unsigned int *)(a2 + 20)) == v15)
  {
    int v39 = *((_DWORD *)a1 + 16);
    int v40 = *((_DWORD *)a1 + 17);
    uint64_t v41 = (v40 * v39);
    size_t v42 = (8 * v41 + 31) & 0xFFFFFFFE0;
    size_t v43 = v42 >> 3;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v42, 0x49090899uLL);
    long long v44 = (char *)memptr;
    if (v41)
    {
      int v45 = 0;
      signed int v46 = *(_DWORD *)a2;
      int v47 = *(_DWORD *)(a2 + 16) - *(_DWORD *)a2;
      uint64_t v48 = *(void **)(a2 + 8);
      if (!(*(_DWORD *)(a2 + 4) * *(_DWORD *)a2)) {
        uint64_t v48 = 0;
      }
      uint64_t v49 = 8 * v41;
      size_t v50 = memptr;
      do
      {
        *v50++ = *v48;
        if (v45 + 1 >= v46) {
          int v51 = v47;
        }
        else {
          int v51 = 0;
        }
        v52 = &v48[v51];
        if (v45 + 1 < v46) {
          ++v45;
        }
        else {
          int v45 = 0;
        }
        uint64_t v48 = v52 + 1;
        v49 -= 8;
      }
      while (v49);
    }
    size_t v53 = (char *)a1[6];
    a1[6] = v44;
    a1[7] = (void *)v43;
    *((_DWORD *)a1 + 16) = v39;
    *((_DWORD *)a1 + 17) = v40;
LABEL_62:
    free(v53);
    goto LABEL_63;
  }
  uint64_t v31 = (*((_DWORD *)a1 + 17) * *((_DWORD *)a1 + 16));
  if (v31)
  {
    int v32 = 0;
    signed int v33 = *(_DWORD *)a2;
    int v34 = *(_DWORD *)(a2 + 16) - *(_DWORD *)a2;
    if (*(_DWORD *)(a2 + 4) * *(_DWORD *)a2) {
      int v35 = *(void **)(a2 + 8);
    }
    else {
      int v35 = 0;
    }
    uint64_t v36 = 8 * v31;
    do
    {
      *v15++ = *v35;
      if (v32 + 1 >= v33) {
        int v37 = v34;
      }
      else {
        int v37 = 0;
      }
      unint64_t v38 = &v35[v37];
      if (v32 + 1 < v33) {
        ++v32;
      }
      else {
        int v32 = 0;
      }
      int v35 = v38 + 1;
      v36 -= 8;
    }
    while (v36);
  }
LABEL_63:
  if (*((_DWORD *)a1 + 22) != v7)
  {
    size_t v63 = (8 * v7 * v7 + 31) & 0xFFFFFFFE0;
    size_t v64 = v63 >> 3;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v63, 0x49090899uLL);
    uint64_t v65 = (char *)a1[9];
    a1[9] = memptr;
    a1[10] = (void *)v64;
    *((_DWORD *)a1 + 22) = v7;
    *((_DWORD *)a1 + 23) = v7;
    free(v65);
  }
  if (v6 >= v7) {
    unsigned int v66 = v7;
  }
  else {
    unsigned int v66 = v6;
  }
  if (*((_DWORD *)a1 + 28) != v66)
  {
    size_t v67 = (8 * v66 + 31) & 0xFFFFFFFE0;
    size_t v68 = v67 >> 3;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v67, 0x49090899uLL);
    v69 = (char *)a1[12];
    a1[12] = memptr;
    a1[13] = (void *)v68;
    *((_DWORD *)a1 + 28) = v66;
    *((_DWORD *)a1 + 29) = 1;
    free(v69);
  }
  if (*((_DWORD *)a1 + 34) != v6)
  {
    size_t v70 = (8 * (v6 * v6) + 31) & 0xFFFFFFFE0;
    size_t v71 = v70 >> 3;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v70, 0x49090899uLL);
    uint64_t v72 = (char *)a1[15];
    a1[15] = memptr;
    a1[16] = (void *)v71;
    *((_DWORD *)a1 + 34) = v6;
    *((_DWORD *)a1 + 35) = v6;
    free(v72);
  }
  if (sub_2153D1E30((uint64_t)v8))
  {
    if (v6 >= a3) {
      uint64_t v73 = a3;
    }
    else {
      uint64_t v73 = v6;
    }
    if (*((_DWORD *)a1 + 4) != v73)
    {
      size_t v74 = (8 * v73 + 31) & 0xFFFFFFFE0;
      size_t v75 = v74 >> 3;
      memptr = 0;
      malloc_type_posix_memalign(&memptr, 0x20uLL, v74, 0x49090899uLL);
      double v76 = *a1;
      *a1 = memptr;
      a1[1] = (void *)v75;
      *((_DWORD *)a1 + 4) = v73;
      *((_DWORD *)a1 + 5) = 1;
      free(v76);
      size_t v77 = (8 * (v73 * v6) + 31) & 0xFFFFFFFE0;
      size_t v78 = v77 >> 3;
      memptr = 0;
      malloc_type_posix_memalign(&memptr, 0x20uLL, v77, 0x49090899uLL);
      int v79 = (char *)a1[3];
      a1[3] = memptr;
      a1[4] = (void *)v78;
      *((_DWORD *)a1 + 10) = v6;
      *((_DWORD *)a1 + 11) = v73;
      free(v79);
    }
    if (v73)
    {
      uint64_t v80 = 0;
      int v81 = (float64x2_t *)a1[12];
      uint64_t v82 = (float64x2_t *)*a1;
      if (v73 < 4) {
        goto LABEL_84;
      }
      if ((unint64_t)((char *)v82 - (char *)v81) <= 0x1F) {
        goto LABEL_84;
      }
      uint64_t v80 = v73 & 0xFFFFFFFC;
      int v83 = v82 + 1;
      uint64_t v84 = v81 + 1;
      uint64_t v85 = v80;
      do
      {
        float64x2_t v86 = vmulq_f64(*v84, *v84);
        v83[-1] = vmulq_f64(v84[-1], v84[-1]);
        *int v83 = v86;
        v83 += 2;
        v84 += 2;
        v85 -= 4;
      }
      while (v85);
      if (v80 != v73)
      {
LABEL_84:
        uint64_t v87 = v73 - v80;
        uint64_t v88 = v80;
        long long v89 = &v82->f64[v80];
        long long v90 = &v81->f64[v88];
        do
        {
          double v91 = *v90++;
          *v89++ = v91 * v91;
          --v87;
        }
        while (v87);
      }
      int v92 = 0;
      uint64_t v93 = 0;
      int v94 = *((_DWORD *)a1 + 34);
      uint64_t v95 = (char *)a1[15];
      int v96 = *((_DWORD *)a1 + 10);
      uint64_t v97 = (char *)a1[3];
      int v98 = v6 - 1;
      uint64_t v99 = v6 & 0xFFFFFFFC;
      do
      {
        if (v6 >= 0x12)
        {
          uint64_t v100 = 0;
          BOOL v102 = __CFADD__(v96 * v93, v98);
          if (!__CFADD__(v93, v98)
            && v94 == 1
            && !v102
            && !((unint64_t)(v6 - 1) >> 32)
            && (unint64_t)(&v97[8 * (v96 * v93)] - &v95[8 * v93]) >= 0x20)
          {
            uint64_t v103 = 0;
            do
            {
              v104 = (long long *)&v95[8 * (v93 + v103)];
              long long v105 = *v104;
              long long v106 = v104[1];
              v107 = &v97[8 * (v92 + v103)];
              *(_OWORD *)v107 = v105;
              *((_OWORD *)v107 + 1) = v106;
              v103 += 4;
            }
            while (v99 != v103);
            uint64_t v100 = v6 & 0xFFFFFFFC;
            if (v99 == v6) {
              goto LABEL_87;
            }
          }
        }
        else
        {
          uint64_t v100 = 0;
        }
        unsigned int v101 = v93 + v94 * v100;
        do
        {
          *(void *)&v97[8 * (v92 + v100++)] = *(void *)&v95[8 * v101];
          v101 += v94;
        }
        while (v6 != v100);
LABEL_87:
        ++v93;
        v92 += v96;
      }
      while (v93 != v73);
    }
  }
  else
  {
    v108 = *a1;
    a1[1] = 0;
    a1[2] = 0;
    *a1 = 0;
    free(v108);
    v109 = (char *)a1[3];
    a1[4] = 0;
    a1[5] = 0;
    a1[3] = 0;
    free(v109);
  }
  return (char **)a1;
}

void cva::PCA<double>::project<cva::Matrix<double,0u,0u,false>,void>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  uint64_t v6 = (void **)(a1 + 24);
  int v7 = *(_DWORD *)(a2 + 16);
  if (v7 != *(_DWORD *)(a3 + 16) || *(_DWORD *)(a1 + 44) != *(_DWORD *)(a3 + 20))
  {
    int v8 = *(void **)a3;
    if (*(void *)a2 == *(void *)a3 || *v6 == v8)
    {
      size_t v12 = (8 * (*(_DWORD *)(a1 + 44) * v7) + 31) & 0xFFFFFFFE0;
      size_t v17 = v12 >> 3;
      memptr = 0;
      malloc_type_posix_memalign(&memptr, 0x20uLL, v12, 0x49090899uLL);
      unint64_t v16 = memptr;
      int v13 = *(_DWORD *)(a1 + 44);
      LODWORD(v18) = *(_DWORD *)(a2 + 16);
      HIDWORD(v18) = v13;
      uint64_t v20 = a2;
      signed int v21 = v6;
      uint64_t v22 = 0x3FF0000000000000;
      sub_2153D2840((uint64_t)&v16, (uint64_t)&memptr);
      uint64_t v14 = *(void **)a3;
      size_t v15 = v17;
      *(void *)a3 = v16;
      *(void *)(a3 + 8) = v15;
      *(void *)(a3 + 16) = v18;
      free(v14);
      return;
    }
    int v9 = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a3 + 16) = v7;
    *(_DWORD *)(a3 + 20) = v9;
    unint64_t v10 = (v9 * v7);
    if (v10)
    {
      if (*(void *)(a3 + 8) < v10)
      {
        free(v8);
        size_t v11 = (8 * v10 + 31) & 0xFFFFFFFE0;
        *(void *)a3 = 0;
        *(void *)(a3 + 8) = v11 >> 3;
        memptr = 0;
        malloc_type_posix_memalign(&memptr, 0x20uLL, v11, 0x49090899uLL);
        *(void *)a3 = memptr;
      }
    }
    else
    {
      free(v8);
      *(void *)a3 = 0;
      *(void *)(a3 + 8) = 0;
    }
  }
  uint64_t v20 = a2;
  signed int v21 = v6;
  uint64_t v22 = 0x3FF0000000000000;
  sub_2153D2840(a3, (uint64_t)&memptr);
}

void sub_2153D2840(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void *)(a2 + 8);
  uint64_t v6 = *(void *)(a2 + 16);
  if (*(void **)v5 == v4 || *(void **)v6 == v4)
  {
    size_t v7 = (8 * (*(_DWORD *)(v6 + 20) * *(_DWORD *)(v5 + 16)) + 31) & 0xFFFFFFFE0;
    size_t v13 = v7 >> 3;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v7, 0x49090899uLL);
    size_t v12 = memptr;
    int v8 = *(_DWORD *)(*(void *)(a2 + 16) + 20);
    LODWORD(v14) = *(_DWORD *)(*(void *)(a2 + 8) + 16);
    HIDWORD(v14) = v8;
    sub_2153D2840(&v12, a2);
    int v9 = *(void **)a1;
    size_t v10 = v13;
    *(void *)a1 = v12;
    *(void *)(a1 + 8) = v10;
    *(void *)(a1 + 16) = v14;
    free(v9);
  }
  else if (*(_DWORD *)(v5 + 20) * *(_DWORD *)(v5 + 16) && *(_DWORD *)(v6 + 20) * *(_DWORD *)(v6 + 16))
  {
    cblas_dgemm_NEWLAPACK();
  }
  else
  {
    unsigned int v11 = *(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16);
    if (v11)
    {
      bzero(v4, 8 * v11);
    }
  }
}

void cva::PCA<double>::project<cva::MatrixRef<double,0u,0u,false>,void>(uint64_t a1, int *a2, int *a3)
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  unint64_t v38 = a2;
  uint64_t v39 = a1 + 24;
  uint64_t v40 = 0x3FF0000000000000;
  uint64_t v6 = *((void *)a3 + 1);
  uint64_t v7 = v6 - 8 * a3[5];
  if (*((void *)a2 + 1) - 8 * a2[5] == v7 || *(void *)(a1 + 24) == v7)
  {
    size_t v8 = (8 * (*(_DWORD *)(a1 + 44) * *a2) + 31) & 0xFFFFFFFE0;
    v33[1] = (void *)(v8 >> 3);
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v8, 0x49090899uLL);
    v33[0] = memptr;
    int v9 = *(_DWORD *)(a1 + 44);
    int v34 = *a2;
    int v35 = v9;
    sub_2153D2B80((uint64_t)v33, (uint64_t)v37);
    int v10 = *a3;
    int v11 = a3[1];
    int v12 = v11 * *a3;
    int v13 = a3[4];
    BOOL v14 = v12 == 0;
    if (v12) {
      size_t v15 = (void *)*((void *)a3 + 1);
    }
    else {
      size_t v15 = 0;
    }
    uint64_t v16 = *((void *)a3 + 1) + 8 * (v13 * v11);
    if (v14) {
      uint64_t v16 = 0;
    }
    size_t v17 = v33[0];
    if (v15 != (void *)v16)
    {
      int v18 = 0;
      unsigned int v19 = v13 - v10;
      uint64_t v20 = (uint64_t *)v33[0];
      do
      {
        uint64_t v21 = *v20++;
        void *v15 = v21;
        if (v18 + 1 >= v10) {
          unsigned int v22 = v19;
        }
        else {
          unsigned int v22 = 0;
        }
        v15 += v22 + 1;
        if (v18 + 1 < v10) {
          ++v18;
        }
        else {
          int v18 = 0;
        }
      }
      while (v15 != (void *)v16);
    }
    free(v17);
  }
  else if (a2[1] * *a2 && *(_DWORD *)(a1 + 44) * *(_DWORD *)(a1 + 40))
  {
    cblas_dgemm_NEWLAPACK();
  }
  else
  {
    int v23 = *a3;
    int v24 = a3[1];
    int v25 = v24 * *a3;
    int v26 = a3[4];
    BOOL v27 = v25 == 0;
    if (v25) {
      int v28 = (void *)*((void *)a3 + 1);
    }
    else {
      int v28 = 0;
    }
    int v29 = (void *)(v6 + 8 * (v26 * v24));
    if (v27) {
      int v29 = 0;
    }
    if (v28 != v29)
    {
      int v30 = 0;
      unsigned int v31 = v26 - v23;
      do
      {
        void *v28 = 0;
        if (v30 + 1 >= v23) {
          unsigned int v32 = v31;
        }
        else {
          unsigned int v32 = 0;
        }
        v28 += v32 + 1;
        if (v30 + 1 < v23) {
          ++v30;
        }
        else {
          int v30 = 0;
        }
      }
      while (v28 != v29);
    }
  }
}

void sub_2153D2B80(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void *)(a2 + 8);
  uint64_t v6 = *(void *)(a2 + 16);
  if ((void *)(*(void *)(v5 + 8) - 8 * *(unsigned int *)(v5 + 20)) == v4 || *(void **)v6 == v4)
  {
    size_t v7 = (8 * (*(_DWORD *)(v6 + 20) * *(_DWORD *)v5) + 31) & 0xFFFFFFFE0;
    size_t v13 = v7 >> 3;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v7, 0x49090899uLL);
    int v12 = memptr;
    int v8 = *(_DWORD *)(*(void *)(a2 + 16) + 20);
    LODWORD(v14) = **(_DWORD **)(a2 + 8);
    HIDWORD(v14) = v8;
    sub_2153D2B80(&v12, a2);
    int v9 = *(void **)a1;
    size_t v10 = v13;
    *(void *)a1 = v12;
    *(void *)(a1 + 8) = v10;
    *(void *)(a1 + 16) = v14;
    free(v9);
  }
  else if (*(_DWORD *)(v5 + 4) * *(_DWORD *)v5 && *(_DWORD *)(v6 + 20) * *(_DWORD *)(v6 + 16))
  {
    cblas_dgemm_NEWLAPACK();
  }
  else
  {
    unsigned int v11 = *(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16);
    if (v11)
    {
      bzero(v4, 8 * v11);
    }
  }
}

void cva::PCA<double>::backProject<cva::Matrix<double,0u,0u,false>,void>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  uint64_t v14 = a1 + 24;
  int v5 = *(_DWORD *)(a2 + 16);
  if (v5 != *(_DWORD *)(a3 + 16) || *(_DWORD *)(a1 + 40) != *(_DWORD *)(a3 + 20))
  {
    uint64_t v6 = *(void **)a3;
    if (*(void *)a2 == *(void *)a3 || *(void **)(a1 + 24) == v6)
    {
      size_t v10 = (8 * (*(_DWORD *)(a1 + 40) * v5) + 31) & 0xFFFFFFFE0;
      size_t v16 = v10 >> 3;
      memptr = 0;
      malloc_type_posix_memalign(&memptr, 0x20uLL, v10, 0x49090899uLL);
      size_t v15 = memptr;
      int v11 = *(_DWORD *)(v14 + 16);
      LODWORD(v17) = *(_DWORD *)(a2 + 16);
      HIDWORD(v17) = v11;
      uint64_t v19 = a2;
      uint64_t v20 = &v14;
      uint64_t v21 = 0x3FF0000000000000;
      sub_2153D2E70((uint64_t)&v15, (uint64_t)&memptr);
      int v12 = *(void **)a3;
      size_t v13 = v16;
      *(void *)a3 = v15;
      *(void *)(a3 + 8) = v13;
      *(void *)(a3 + 16) = v17;
      free(v12);
      return;
    }
    int v7 = *(_DWORD *)(a1 + 40);
    *(_DWORD *)(a3 + 16) = v5;
    *(_DWORD *)(a3 + 20) = v7;
    unint64_t v8 = (v7 * v5);
    if (v8)
    {
      if (*(void *)(a3 + 8) < v8)
      {
        free(v6);
        size_t v9 = (8 * v8 + 31) & 0xFFFFFFFE0;
        *(void *)a3 = 0;
        *(void *)(a3 + 8) = v9 >> 3;
        memptr = 0;
        malloc_type_posix_memalign(&memptr, 0x20uLL, v9, 0x49090899uLL);
        *(void *)a3 = memptr;
      }
    }
    else
    {
      free(v6);
      *(void *)a3 = 0;
      *(void *)(a3 + 8) = 0;
    }
  }
  uint64_t v19 = a2;
  uint64_t v20 = &v14;
  uint64_t v21 = 0x3FF0000000000000;
  sub_2153D2E70(a3, (uint64_t)&memptr);
}

void sub_2153D2E70(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void *)(a2 + 8);
  uint64_t v6 = **(void **)(a2 + 16);
  if (*(void **)v5 == v4 || *(void **)v6 == v4)
  {
    size_t v7 = (8 * (*(_DWORD *)(v6 + 16) * *(_DWORD *)(v5 + 16)) + 31) & 0xFFFFFFFE0;
    size_t v13 = v7 >> 3;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v7, 0x49090899uLL);
    int v12 = memptr;
    int v8 = *(_DWORD *)(**(void **)(a2 + 16) + 16);
    LODWORD(v14) = *(_DWORD *)(*(void *)(a2 + 8) + 16);
    HIDWORD(v14) = v8;
    sub_2153D2E70(&v12, a2);
    size_t v9 = *(void **)a1;
    size_t v10 = v13;
    *(void *)a1 = v12;
    *(void *)(a1 + 8) = v10;
    *(void *)(a1 + 16) = v14;
    free(v9);
  }
  else if (*(_DWORD *)(v5 + 20) * *(_DWORD *)(v5 + 16) && *(_DWORD *)(v6 + 16) * *(_DWORD *)(v6 + 20))
  {
    cblas_dgemm_NEWLAPACK();
  }
  else
  {
    unsigned int v11 = *(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16);
    if (v11)
    {
      bzero(v4, 8 * v11);
    }
  }
}

void cva::PCA<double>::backProject<cva::MatrixRef<double,0u,0u,false>,void>(uint64_t a1, int *a2, int *a3)
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  uint64_t v32 = a1 + 24;
  unint64_t v38 = a2;
  uint64_t v39 = &v32;
  uint64_t v40 = 0x3FF0000000000000;
  uint64_t v5 = *((void *)a3 + 1);
  uint64_t v6 = v5 - 8 * a3[5];
  if (*((void *)a2 + 1) - 8 * a2[5] == v6 || *(void *)(a1 + 24) == v6)
  {
    size_t v7 = (8 * (*(_DWORD *)(a1 + 40) * *a2) + 31) & 0xFFFFFFFE0;
    v33[1] = (void *)(v7 >> 3);
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v7, 0x49090899uLL);
    v33[0] = memptr;
    int v8 = *(_DWORD *)(v32 + 16);
    int v34 = *a2;
    int v35 = v8;
    sub_2153D31B8((uint64_t)v33, (uint64_t)v37);
    int v9 = *a3;
    int v10 = a3[1];
    int v11 = v10 * *a3;
    int v12 = a3[4];
    BOOL v13 = v11 == 0;
    if (v11) {
      uint64_t v14 = (void *)*((void *)a3 + 1);
    }
    else {
      uint64_t v14 = 0;
    }
    uint64_t v15 = *((void *)a3 + 1) + 8 * (v12 * v10);
    if (v13) {
      uint64_t v15 = 0;
    }
    size_t v16 = v33[0];
    if (v14 != (void *)v15)
    {
      int v17 = 0;
      unsigned int v18 = v12 - v9;
      uint64_t v19 = (uint64_t *)v33[0];
      do
      {
        uint64_t v20 = *v19++;
        void *v14 = v20;
        if (v17 + 1 >= v9) {
          unsigned int v21 = v18;
        }
        else {
          unsigned int v21 = 0;
        }
        v14 += v21 + 1;
        if (v17 + 1 < v9) {
          ++v17;
        }
        else {
          int v17 = 0;
        }
      }
      while (v14 != (void *)v15);
    }
    free(v16);
  }
  else if (a2[1] * *a2 && *(_DWORD *)(a1 + 40) * *(_DWORD *)(a1 + 44))
  {
    cblas_dgemm_NEWLAPACK();
  }
  else
  {
    int v22 = *a3;
    int v23 = a3[1];
    int v24 = v23 * *a3;
    int v25 = a3[4];
    BOOL v26 = v24 == 0;
    if (v24) {
      BOOL v27 = (void *)*((void *)a3 + 1);
    }
    else {
      BOOL v27 = 0;
    }
    int v28 = (void *)(v5 + 8 * (v25 * v23));
    if (v26) {
      int v28 = 0;
    }
    if (v27 != v28)
    {
      int v29 = 0;
      unsigned int v30 = v25 - v22;
      do
      {
        void *v27 = 0;
        if (v29 + 1 >= v22) {
          unsigned int v31 = v30;
        }
        else {
          unsigned int v31 = 0;
        }
        v27 += v31 + 1;
        if (v29 + 1 < v22) {
          ++v29;
        }
        else {
          int v29 = 0;
        }
      }
      while (v27 != v28);
    }
  }
}

void sub_2153D31B8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void *)(a2 + 8);
  uint64_t v6 = **(void **)(a2 + 16);
  if ((void *)(*(void *)(v5 + 8) - 8 * *(unsigned int *)(v5 + 20)) == v4 || *(void **)v6 == v4)
  {
    size_t v7 = (8 * (*(_DWORD *)(v6 + 16) * *(_DWORD *)v5) + 31) & 0xFFFFFFFE0;
    size_t v13 = v7 >> 3;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, 0x20uLL, v7, 0x49090899uLL);
    int v12 = memptr;
    int v8 = *(_DWORD *)(**(void **)(a2 + 16) + 16);
    LODWORD(v14) = **(_DWORD **)(a2 + 8);
    HIDWORD(v14) = v8;
    sub_2153D31B8(&v12, a2);
    int v9 = *(void **)a1;
    size_t v10 = v13;
    *(void *)a1 = v12;
    *(void *)(a1 + 8) = v10;
    *(void *)(a1 + 16) = v14;
    free(v9);
  }
  else if (*(_DWORD *)(v5 + 4) * *(_DWORD *)v5 && *(_DWORD *)(v6 + 16) * *(_DWORD *)(v6 + 20))
  {
    cblas_dgemm_NEWLAPACK();
  }
  else
  {
    unsigned int v11 = *(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16);
    if (v11)
    {
      bzero(v4, 8 * v11);
    }
  }
}

int *cva::Random<std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>>::instance()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_267869A60, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_267869A60))
  {
    unsigned int v1 = cva::Random<std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>>::m_seed;
    dword_267869098[0] = cva::Random<std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>>::m_seed;
    for (uint64_t i = 1; i != 624; ++i)
    {
      unsigned int v1 = i + 1812433253 * (v1 ^ (v1 >> 30));
      dword_267869098[i] = v1;
    }
    qword_267869A58 = 0;
    __cxa_guard_release(&qword_267869A60);
  }
  return dword_267869098;
}

double cva::SE2GroupStorage<float,cva::Matrix<float,3u,3u,false>>::SE2GroupStorage(uint64_t a1)
{
  *(_DWORD *)(a1 + 32) = 1065353216;
  *(void *)&double result = 1065353216;
  *(_OWORD *)a1 = xmmword_2154461C0;
  *(_OWORD *)(a1 + 16) = unk_2154461D0;
  return result;
}

{
  double result;

  *(_DWORD *)(a1 + 32) = 1065353216;
  *(void *)&double result = 1065353216;
  *(_OWORD *)a1 = xmmword_2154461C0;
  *(_OWORD *)(a1 + 16) = unk_2154461D0;
  return result;
}

uint64_t cva::SE2GroupStorage<float,cva::Matrix<float,3u,3u,false>>::SE2GroupStorage(uint64_t a1, _DWORD *a2, float a3)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(void *)(a1 + 24) = 0;
  __float2 v5 = __sincosf_stret(a3);
  *(float *)a1 = v5.__cosval;
  *(float *)(a1 + 4) = v5.__sinval;
  *(float *)(a1 + 12) = -v5.__sinval;
  *(float *)(a1 + 16) = v5.__cosval;
  *(_DWORD *)(a1 + 24) = *a2;
  *(_DWORD *)(a1 + 28) = a2[1];
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 32) = 1065353216;
  return a1;
}

{
  __float2 v5;

  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(void *)(a1 + 24) = 0;
  __float2 v5 = __sincosf_stret(a3);
  *(float *)a1 = v5.__cosval;
  *(float *)(a1 + 4) = v5.__sinval;
  *(float *)(a1 + 12) = -v5.__sinval;
  *(float *)(a1 + 16) = v5.__cosval;
  *(_DWORD *)(a1 + 24) = *a2;
  *(_DWORD *)(a1 + 28) = a2[1];
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 32) = 1065353216;
  return a1;
}

float cva::SE2GroupStorage<float,cva::Matrix<float,3u,3u,false>>::SE2GroupStorage(uint64_t a1, int *a2, uint64_t a3)
{
  uint64_t v3 = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  unint64_t v4 = 0x100000000;
  do
  {
    int v5 = *a2++;
    *(_DWORD *)(a1 + 4 * v3) = v5;
    unint64_t v6 = HIDWORD(v4);
    BOOL v7 = (int)v4 < 1;
    if ((int)v4 < 1) {
      unint64_t v6 = 0;
    }
    uint64_t v8 = v3 + v6;
    uint64_t v9 = (v4 + 1);
    unint64_t v10 = v4 & 0xFFFFFFFF00000000;
    if (!v7) {
      uint64_t v9 = 0;
    }
    unint64_t v4 = v9 | v10;
    uint64_t v3 = v8 + 1;
  }
  while (v3 != 6);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)a3;
  float result = *(float *)(a3 + 4);
  *(float *)(a1 + 28) = result;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 32) = 1065353216;
  return result;
}

{
  uint64_t v3;
  unint64_t v4;
  int v5;
  unint64_t v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  float result;

  uint64_t v3 = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  unint64_t v4 = 0x100000000;
  do
  {
    int v5 = *a2++;
    *(_DWORD *)(a1 + 4 * v3) = v5;
    unint64_t v6 = HIDWORD(v4);
    BOOL v7 = (int)v4 < 1;
    if ((int)v4 < 1) {
      unint64_t v6 = 0;
    }
    uint64_t v8 = v3 + v6;
    uint64_t v9 = (v4 + 1);
    unint64_t v10 = v4 & 0xFFFFFFFF00000000;
    if (!v7) {
      uint64_t v9 = 0;
    }
    unint64_t v4 = v9 | v10;
    uint64_t v3 = v8 + 1;
  }
  while (v3 != 6);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)a3;
  float result = *(float *)(a3 + 4);
  *(float *)(a1 + 28) = result;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 32) = 1065353216;
  return result;
}

uint64_t cva::SE2GroupStorage<float,cva::Matrix<float,3u,3u,false>>::T(uint64_t a1)
{
  return a1 + 24;
}

{
  return a1 + 24;
}

__n128 cva::SE2GroupStorage<float,cva::Matrix<float,3u,3u,false>>::affine@<Q0>(__n128 *a1@<X0>, __n128 *a2@<X8>)
{
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  if (a1 == a2)
  {
    result.n128_u64[0] = *(unint64_t *)((char *)&a1->n128_u64[1] + 4);
    result.n128_u64[1] = a1[1].n128_u64[1];
    *(__n128 *)((char *)a1 + 8) = result;
  }
  else
  {
    unint64_t v2 = a1->n128_u64[0];
    result.n128_u64[1] = *(unint64_t *)((char *)&a1->n128_u64[1] + 4);
    *a2 = result;
    result.n128_u64[0] = a1[1].n128_u64[1];
    a2[1].n128_u64[0] = result.n128_u64[0];
  }
  return result;
}

double cva::SE2GroupStorage<float,cva::Matrix<float,3u,3u,false>>::lplus(uint64_t a1, float *a2)
{
  float v3 = *a2;
  float v4 = a2[1];
  float v5 = a2[2];
  long long v12 = xmmword_2154461C0;
  long long v13 = unk_2154461D0;
  int v14 = 1065353216;
  __float2 v6 = __sincosf_stret(v3);
  float v7 = v3 * v3;
  if ((float)(v3 * v3) >= 0.0061)
  {
    float v8 = (float)(1.0 / v3) * v6.__sinval;
    float v9 = (float)(1.0 / v3) * (float)(1.0 - v6.__cosval);
  }
  else
  {
    float v8 = 1.0 - (float)(v7 * (float)((float)(v7 / -120.0) + 0.16667));
    float v9 = v3 * (float)((float)(v7 / -24.0) + 0.5);
  }
  *(void *)&long long v12 = __PAIR64__(LODWORD(v6.__sinval), LODWORD(v6.__cosval));
  *((float *)&v12 + 3) = -v6.__sinval;
  *(float *)&long long v13 = v6.__cosval;
  *((float *)&v13 + 2) = (float)(v8 * v4) - (float)(v9 * v5);
  *((float *)&v13 + 3) = (float)(v5 * v8) + (float)(v9 * v4);
  v15[0] = (float *)&v12;
  v15[1] = (float *)a1;
  long long v16 = 0u;
  long long v17 = 0u;
  int v18 = 0;
  sub_2153C9F40((uint64_t)&v16, v15);
  double result = *(double *)&v16;
  long long v11 = v17;
  *(_OWORD *)a1 = v16;
  *(_OWORD *)(a1 + 16) = v11;
  *(_DWORD *)(a1 + 32) = v18;
  return result;
}

double cva::SE2AlgebraStorage<float,cva::MatrixRef<float const,3u,1u,false>>::SE2AlgebraStorage(void *a1, uint64_t a2)
{
  *a1 = a2;
  *(void *)&double result = 3;
  a1[1] = 3;
  return result;
}

{
  double result;

  *a1 = a2;
  *(void *)&double result = 3;
  a1[1] = 3;
  return result;
}

{
  double result;

  *a1 = a2;
  *(void *)&double result = 3;
  a1[1] = 3;
  return result;
}

{
  double result;

  *a1 = a2;
  *(void *)&double result = 3;
  a1[1] = 3;
  return result;
}

float cva::SE2AlgebraStorage<float,cva::MatrixRef<float const,3u,1u,false>>::exp@<S0>(float **a1@<X0>, uint64_t a2@<X8>)
{
  *(_DWORD *)(a2 + 32) = 1065353216;
  *(_OWORD *)a2 = xmmword_2154461C0;
  *(_OWORD *)(a2 + 16) = unk_2154461D0;
  float v3 = *a1;
  float v4 = **a1;
  __float2 v5 = __sincosf_stret(v4);
  float v6 = v4 * v4;
  if ((float)(v4 * v4) >= 0.0061)
  {
    float v7 = (float)(1.0 / v4) * v5.__sinval;
    float v8 = (float)(1.0 / v4) * (float)(1.0 - v5.__cosval);
  }
  else
  {
    float v7 = 1.0 - (float)(v6 * (float)((float)(v6 / -120.0) + 0.16667));
    float v8 = v4 * (float)((float)(v6 / -24.0) + 0.5);
  }
  *(float *)a2 = v5.__cosval;
  *(float *)(a2 + 4) = v5.__sinval;
  *(float *)(a2 + 12) = -v5.__sinval;
  *(float *)(a2 + 16) = v5.__cosval;
  float v9 = v3[1];
  float v10 = v3[2];
  float v11 = (float)(v7 * v9) - (float)(v8 * v10);
  float result = (float)(v7 * v10) + (float)(v8 * v9);
  *(float *)(a2 + 24) = v11;
  *(float *)(a2 + 28) = result;
  return result;
}

double cva::SE2GroupStorage<float,cva::Matrix<float,3u,3u,false>>::rplus(uint64_t a1, float *a2)
{
  float v3 = *a2;
  float v4 = a2[1];
  float v5 = a2[2];
  long long v12 = xmmword_2154461C0;
  long long v13 = unk_2154461D0;
  int v14 = 1065353216;
  __float2 v6 = __sincosf_stret(v3);
  float v7 = v3 * v3;
  if ((float)(v3 * v3) >= 0.0061)
  {
    float v8 = (float)(1.0 / v3) * v6.__sinval;
    float v9 = (float)(1.0 / v3) * (float)(1.0 - v6.__cosval);
  }
  else
  {
    float v8 = 1.0 - (float)(v7 * (float)((float)(v7 / -120.0) + 0.16667));
    float v9 = v3 * (float)((float)(v7 / -24.0) + 0.5);
  }
  *(void *)&long long v12 = __PAIR64__(LODWORD(v6.__sinval), LODWORD(v6.__cosval));
  *((float *)&v12 + 3) = -v6.__sinval;
  *(float *)&long long v13 = v6.__cosval;
  *((float *)&v13 + 2) = (float)(v8 * v4) - (float)(v9 * v5);
  *((float *)&v13 + 3) = (float)(v5 * v8) + (float)(v9 * v4);
  v15[0] = (float *)a1;
  v15[1] = (float *)&v12;
  long long v16 = 0u;
  long long v17 = 0u;
  int v18 = 0;
  sub_2153C9F40((uint64_t)&v16, v15);
  double result = *(double *)&v16;
  long long v11 = v17;
  *(_OWORD *)a1 = v16;
  *(_OWORD *)(a1 + 16) = v11;
  *(_DWORD *)(a1 + 32) = v18;
  return result;
}

float cva::SE2GroupStorage<float,cva::Matrix<float,3u,3u,false>>::transform@<S0>(float *a1@<X0>, float *a2@<X1>, float *a3@<X8>)
{
  v7[0] = a1;
  v7[1] = 3;
  v8[0] = (float *)v7;
  v8[1] = a2;
  *(void *)float v9 = 0;
  sub_2153D398C(v9, v8);
  *(void *)a3 = 0;
  float result = v9[0] + a1[6];
  float v6 = v9[1] + a1[7];
  if (a1 == a3)
  {
    *a1 = result;
    a1[1] = v6;
  }
  else
  {
    *a3 = result;
    a3[1] = v6;
  }
  return result;
}

float *sub_2153D398C(float *result, float **a2)
{
  unint64_t v2 = result;
  uint64_t v3 = *(void *)*a2;
  if ((float *)(v3 - 4 * *((unsigned int *)*a2 + 3)) == result || (float v4 = a2[1], v4 == result))
  {
    uint64_t v17 = 0;
    float result = (float *)sub_2153D398C(&v17);
    *(void *)unint64_t v2 = v17;
  }
  else
  {
    uint64_t v5 = *((unsigned int *)*a2 + 2);
    uint64_t v6 = (2 * v5);
    if (v6)
    {
      uint64_t v7 = 0;
      uint64_t v8 = 4 * v6;
      uint64_t v9 = 4 * v5;
      float v10 = 0.0;
      long long v11 = a2[1];
      do
      {
        float v12 = *v11++;
        float v10 = v10 + (float)(*(float *)(v3 + v7) * v12);
        v7 += v9;
      }
      while (v8 != v7);
      uint64_t v13 = 0;
      *float result = v10;
      uint64_t v14 = v3 + 4;
      float v15 = 0.0;
      do
      {
        float v16 = *v4++;
        float v15 = v15 + (float)(*(float *)(v14 + v13) * v16);
        v13 += v9;
      }
      while (v8 != v13);
    }
    else
    {
      *float result = 0.0;
      float v15 = 0.0;
    }
    result[1] = v15;
  }
  return result;
}

float32x2_t cva::SE2GroupStorage<float,cva::Matrix<float,3u,3u,false>>::inverseTransform@<D0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, float32x2_t *a3@<X8>)
{
  v9[0] = a1;
  v9[1] = 3;
  float v10 = v9;
  v11[0] = (uint64_t *)&v10;
  v11[1] = a2;
  v6[0] = a1;
  v6[1] = 3;
  uint64_t v7 = v6;
  v5[0] = a1 + 24;
  v5[1] = 0x600000003;
  v8[0] = (uint64_t *)&v7;
  v8[1] = v5;
  float32x2_t v12 = 0;
  sub_2153D3AFC((float *)&v12, v11);
  float32x2_t v13 = 0;
  sub_2153D3B90((float *)&v13, v8);
  float32x2_t result = vsub_f32(v12, v13);
  *a3 = result;
  return result;
}

float *sub_2153D3AFC(float *result, uint64_t **a2)
{
  unint64_t v2 = result;
  uint64_t v3 = (float *)a2[1];
  if (v3 == result)
  {
    uint64_t v7 = 0;
    float32x2_t result = (float *)sub_2153D3AFC(&v7);
    *(void *)unint64_t v2 = v7;
  }
  else
  {
    uint64_t v4 = **a2;
    uint64_t v5 = *(float **)v4;
    uint64_t v6 = *(unsigned int *)(v4 + 8);
    *float32x2_t result = (float)((float)(v5[1] * v3[1]) + (float)(*v5 * *v3)) + 0.0;
    result[1] = (float)((float)(v5[v6 + 1] * v3[1]) + (float)(v5[v6] * *v3)) + 0.0;
  }
  return result;
}

float *sub_2153D3B90(float *result, uint64_t **a2)
{
  unint64_t v2 = result;
  uint64_t v3 = a2[1];
  uint64_t v4 = (float *)*v3;
  if ((float *)(*v3 - 4 * *((unsigned int *)v3 + 3)) == result)
  {
    uint64_t v8 = 0;
    float32x2_t result = (float *)sub_2153D3B90(&v8);
    *(void *)unint64_t v2 = v8;
  }
  else
  {
    uint64_t v5 = **a2;
    uint64_t v6 = *(float **)v5;
    uint64_t v7 = *(unsigned int *)(v5 + 8);
    *float32x2_t result = (float)((float)(v6[1] * v4[1]) + (float)(*v6 * *v4)) + 0.0;
    result[1] = (float)((float)(v6[v7 + 1] * v4[1]) + (float)(v6[v7] * *v4)) + 0.0;
  }
  return result;
}

double cva::SE2GroupStorage<float,cva::Matrix<float,3u,3u,false>>::transformJacobian@<D0>(float *a1@<X1>, uint64_t a2@<X8>)
{
  int v2 = *(_DWORD *)a1;
  *(float *)a2 = -a1[1];
  *(_DWORD *)(a2 + 4) = v2;
  *(void *)&double result = 1065353216;
  *(_OWORD *)(a2 + 8) = xmmword_215445EC0;
  return result;
}

float *cva::SE2GroupStorage<float,cva::Matrix<float,3u,3u,false>>::inverseTransformJacobian@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  float v5 = -*(float *)a2;
  *(_DWORD *)a3 = *(_DWORD *)(a2 + 4);
  *(float *)(a3 + 4) = v5;
  v26[0] = a1;
  v26[1] = 3;
  BOOL v27 = v26;
  uint64_t v28 = 0;
  v25[0] = a3;
  v25[1] = 2;
  int v29 = (uint64_t *)&v27;
  unsigned int v30 = v25;
  double result = sub_2153D3B90((float *)&v28, &v29);
  uint64_t v7 = v28;
  *(void *)a3 = v28;
  if (a1 == a3)
  {
    unint64_t v16 = 0;
    *(float *)&int v29 = -*(float *)&v7;
    HIDWORD(v29) = 0x80000000;
    *(float *)&unsigned int v30 = -*((float *)&v7 + 1);
    HIDWORD(v30) = 0x80000000;
    uint64_t v17 = &v29;
    for (uint64_t i = 2; i != 6; uint64_t i = v22 + 1)
    {
      int v19 = *(_DWORD *)v17;
      uint64_t v17 = (uint64_t **)((char *)v17 + 4);
      *(_DWORD *)(a3 + 4 * i) = v19;
      unint64_t v20 = HIDWORD(v16);
      BOOL v21 = (int)v16 < 1;
      if ((int)v16 < 1) {
        unint64_t v20 = 0;
      }
      unint64_t v22 = i + v20;
      uint64_t v23 = (v16 + 1);
      unint64_t v24 = v16 & 0xFFFFFFFF00000000;
      if (!v21) {
        uint64_t v23 = 0;
      }
      unint64_t v16 = v23 | v24;
    }
  }
  else
  {
    unint64_t v8 = 0;
    unint64_t v9 = 0;
    for (uint64_t j = 2; j != 6; uint64_t j = v13 + 1)
    {
      *(float *)(a3 + 4 * j) = -*(float *)(a1 + 4 * (3 * v9 + HIDWORD(v9)));
      if ((int)v9 >= 1) {
        unint64_t v9 = (v9 & 0xFFFFFFFF00000000) + 0x100000000;
      }
      else {
        unint64_t v9 = (v9 + 1) | v9 & 0xFFFFFFFF00000000;
      }
      unint64_t v11 = HIDWORD(v8);
      BOOL v12 = (int)v8 < 1;
      if ((int)v8 < 1) {
        unint64_t v11 = 0;
      }
      unint64_t v13 = j + v11;
      uint64_t v14 = (v8 + 1);
      unint64_t v15 = v8 & 0xFFFFFFFF00000000;
      if (!v12) {
        uint64_t v14 = 0;
      }
      unint64_t v8 = v14 | v15;
    }
  }
  return result;
}

float cva::SE2GroupStorage<float,cva::Matrix<float,3u,3u,false>>::log@<S0>(float *a1@<X0>, float *a2@<X8>)
{
  float v4 = atan2f(a1[1], *a1);
  float v5 = v4 * v4;
  if ((float)(v4 * v4) >= 0.0061)
  {
    __float2 v8 = __sincosf_stret(v4);
    float v6 = (float)(1.0 / v4) * v8.__sinval;
    float v7 = (float)(1.0 / v4) * (float)(1.0 - v8.__cosval);
  }
  else
  {
    float v6 = 1.0 - (float)(v5 * (float)((float)(v5 / -120.0) + 0.16667));
    float v7 = v4 * (float)((float)(v5 / -24.0) + 0.5);
  }
  float v9 = 1.0 / (float)((float)(v7 * v7) + (float)(v6 * v6));
  float v10 = a1[6];
  float v11 = a1[7];
  *a2 = v4;
  a2[1] = v9 * (float)((float)(v7 * v11) + (float)(v6 * v10));
  float result = v9 * (float)((float)(v6 * v11) - (float)(v7 * v10));
  a2[2] = result;
  return result;
}

uint64_t cva::SE2AlgebraStorage<float,cva::Matrix<float,3u,1u,false>>::SE2AlgebraStorage(uint64_t result)
{
  *(_DWORD *)(result + 8) = 0;
  *(void *)float result = 0;
  return result;
}

{
  *(_DWORD *)(result + 8) = 0;
  *(void *)float result = 0;
  return result;
}

void cva::SE2GroupStorage<float,cva::Matrix<float,3u,3u,false>>::logJacobian(float *a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 12) = 0u;
  float v4 = (_DWORD *)(a2 + 12);
  *(_DWORD *)(a2 + 44) = 0;
  *(_OWORD *)(a2 + 28) = 0u;
  float v5 = atan2f(a1[1], *a1);
  float v6 = v5 * v5;
  if ((float)(v5 * v5) >= 0.0061)
  {
    __float2 v12 = __sincosf_stret(v5);
    float v9 = (float)(1.0 / v5) * v12.__sinval;
    float v11 = (float)(1.0 / v5) * (float)(1.0 - v12.__cosval);
    float v7 = (float)(1.0 / v5) * v11;
    float v10 = (float)(1.0 / v5) * (float)(1.0 - v9);
  }
  else
  {
    float v7 = 0.5 - (float)(v6 * (float)((float)(v6 / -720.0) + 0.041667));
    float v8 = 0.16667 - (float)(v6 * (float)((float)(v6 / -5040.0) + 0.0083333));
    float v9 = 1.0 - (float)(v6 * v8);
    float v10 = v5 * v8;
    float v11 = v5 * v7;
  }
  float v13 = (float)(v11 * v11) + (float)(v9 * v9);
  float v14 = 1.0 / v13;
  float v15 = a1[6];
  float v16 = a1[7];
  float v17 = (float)(1.0 / v13) * (float)((float)(v11 * v16) + (float)(v9 * v15));
  *(float *)a2 = v5;
  *(float *)(a2 + 4) = v17;
  float v18 = (float)(1.0 / v13) * (float)((float)(v9 * v16) - (float)(v11 * v15));
  *(float *)(a2 + 8) = v18;
  if (fabsf(v13) >= 0.00001)
  {
    float v19 = v9 * v14;
    float v20 = v14 * (float)-v11;
    float v21 = v11 * v14;
    *(float *)unint64_t v38 = v19;
    *(float *)&v38[1] = v20;
    *(float *)&v38[2] = v21;
    *(float *)&v38[3] = v19;
    float v22 = (float)(v10 * v17) + (float)(v7 * v18);
    float v23 = (float)(v10 * v18) - (float)(v7 * v17);
    *(float *)int v37 = v22;
    *(float *)&v37[1] = v23;
    *(_DWORD *)(a2 + 12) = 1065353216;
    int v35 = v38;
    v36[0] = &v35;
    v36[1] = v37;
    if (v37 == v4)
    {
      uint64_t v39 = 0;
      sub_2153D4094((float *)&v39, (uint64_t)v36);
      float v25 = *((float *)&v39 + 1);
      float v24 = *(float *)&v39;
    }
    else
    {
      float v24 = (float)(0.0 - (float)(v19 * v22)) - (float)(v21 * v23);
      float v25 = (float)(0.0 - (float)(v20 * v22)) - (float)(v19 * v23);
    }
    *(float *)(a2 + 16) = v24;
    *(float *)(a2 + 20) = v25;
    *(_DWORD *)(a2 + 24) = 0;
    unint64_t v26 = 0x100000000;
    BOOL v27 = v38;
    uint64_t v28 = 4;
    *(_DWORD *)(a2 + 36) = 0;
    do
    {
      int v29 = *v27++;
      v4[v28] = v29;
      unint64_t v30 = HIDWORD(v26);
      BOOL v31 = (int)v26 < 1;
      if ((int)v26 < 1) {
        unint64_t v30 = 0;
      }
      unint64_t v32 = v28 + v30;
      uint64_t v33 = (v26 + 1);
      unint64_t v34 = v26 & 0xFFFFFFFF00000000;
      if (!v31) {
        uint64_t v33 = 0;
      }
      unint64_t v26 = v33 | v34;
      uint64_t v28 = v32 + 1;
    }
    while (v28 != 10);
  }
}

float *sub_2153D4094(float *result, uint64_t a2)
{
  int v2 = result;
  uint64_t v3 = *(float **)(a2 + 8);
  if (v3 == result)
  {
    uint64_t v7 = 0;
    float result = (float *)sub_2153D4094(&v7);
    *(void *)int v2 = v7;
  }
  else
  {
    float v4 = **(float ***)a2;
    float v5 = v4[1];
    float v6 = v4[3];
    *float result = (float)(0.0 - (float)(*v4 * *v3)) - (float)(v4[2] * v3[1]);
    result[1] = (float)(0.0 - (float)(v5 * *v3)) - (float)(v6 * v3[1]);
  }
  return result;
}

float cva::SE2GroupStorage<float,cva::Matrix<float,3u,3u,false>>::inverse@<S0>(float *a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)a2 = xmmword_2154461C0;
  *(_OWORD *)(a2 + 16) = unk_2154461D0;
  *(_DWORD *)(a2 + 32) = 1065353216;
  float v2 = *a1;
  float v3 = a1[1];
  float v4 = a1[3];
  float v5 = a1[4];
  *(float *)a2 = *a1;
  *(float *)(a2 + 4) = v4;
  *(float *)(a2 + 12) = v3;
  *(float *)(a2 + 16) = v5;
  float v6 = a1[6];
  float v7 = a1[7];
  float result = (float)-(float)(v3 * v7) - (float)(v2 * v6);
  *(float *)(a2 + 24) = result;
  *(float *)(a2 + 28) = (float)-(float)(v5 * v7) - (float)(v4 * v6);
  return result;
}

float cva::SE2GroupStorage<float,cva::Matrix<float,3u,3u,false>>::adjoint@<S0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 32) = 0;
  if (a1 == a2)
  {
    *(void *)&long long v16 = *(void *)a2;
    *((void *)&v16 + 1) = *(void *)(a2 + 12);
    long long v28 = v16;
    unint64_t v17 = 0x100000000;
    float v18 = (int *)&v28;
    for (uint64_t i = 4; i != 10; uint64_t i = v23 + 1)
    {
      int v20 = *v18++;
      *(_DWORD *)(a2 + 4 * i) = v20;
      unint64_t v21 = HIDWORD(v17);
      BOOL v22 = (int)v17 < 1;
      if ((int)v17 < 1) {
        unint64_t v21 = 0;
      }
      unint64_t v23 = i + v21;
      uint64_t v24 = (v17 + 1);
      unint64_t v25 = v17 & 0xFFFFFFFF00000000;
      if (!v22) {
        uint64_t v24 = 0;
      }
      unint64_t v17 = v24 | v25;
    }
  }
  else
  {
    unint64_t v2 = 0x100000000;
    uint64_t v3 = 4;
    float v4 = (_DWORD *)a1;
    unint64_t v5 = 0x100000000;
    do
    {
      *(_DWORD *)(a2 + 4 * v3) = *v4;
      unint64_t v6 = HIDWORD(v5);
      BOOL v7 = (int)v5 < 1;
      if ((int)v5 < 1) {
        unint64_t v6 = 0;
      }
      float v8 = &v4[v6];
      uint64_t v9 = (v5 + 1);
      unint64_t v10 = v5 & 0xFFFFFFFF00000000;
      if (!v7) {
        uint64_t v9 = 0;
      }
      unint64_t v5 = v9 | v10;
      float v4 = v8 + 1;
      unint64_t v11 = HIDWORD(v2);
      BOOL v12 = (int)v2 < 1;
      if ((int)v2 < 1) {
        unint64_t v11 = 0;
      }
      unint64_t v13 = v3 + v11;
      uint64_t v14 = (v2 + 1);
      unint64_t v15 = v2 & 0xFFFFFFFF00000000;
      if (!v12) {
        uint64_t v14 = 0;
      }
      unint64_t v2 = v14 | v15;
      uint64_t v3 = v13 + 1;
    }
    while (v3 != 10);
  }
  float result = *(float *)(a1 + 28);
  float v27 = -*(float *)(a1 + 24);
  *(float *)(a2 + 4) = result;
  *(float *)(a2 + 8) = v27;
  *(_DWORD *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)a2 = 1065353216;
  return result;
}

float cva::SE2GroupStorage<float,cva::Matrix<float,3u,3u,false>>::enforce(uint64_t a1)
{
  float v2 = atan2f(*(float *)(a1 + 4), *(float *)a1);
  float v3 = v2 * v2;
  if ((float)(v2 * v2) >= 0.0061)
  {
    __float2 v9 = __sincosf_stret(v2);
    float cosval = v9.__cosval;
    float sinval = v9.__sinval;
    float v4 = (float)(1.0 / v2) * v9.__sinval;
    float v5 = (float)(1.0 / v2) * (float)(1.0 - v9.__cosval);
  }
  else
  {
    float v4 = 1.0 - (float)(v3 * (float)((float)(v3 / -120.0) + 0.16667));
    float v5 = v2 * (float)((float)(v3 / -24.0) + 0.5);
    __float2 v8 = __sincosf_stret(v2);
    float cosval = v8.__cosval;
    float sinval = v8.__sinval;
  }
  float v10 = *(float *)(a1 + 24);
  float v11 = *(float *)(a1 + 28);
  float v12 = 1.0 / (float)((float)(v5 * v5) + (float)(v4 * v4));
  float v13 = v12 * (float)((float)(v4 * v11) - (float)(v5 * v10));
  float v14 = v12 * (float)((float)(v5 * v11) + (float)(v4 * v10));
  *(float *)a1 = cosval;
  *(float *)(a1 + 4) = sinval;
  *(_DWORD *)(a1 + 8) = 0;
  *(float *)(a1 + 12) = -sinval;
  *(float *)(a1 + 16) = cosval;
  float result = (float)(v13 * v4) + (float)(v5 * v14);
  *(_DWORD *)(a1 + 20) = 0;
  *(float *)(a1 + 24) = (float)(v4 * v14) - (float)(v5 * v13);
  *(float *)(a1 + 28) = result;
  *(_DWORD *)(a1 + 32) = 1065353216;
  return result;
}

float cva::SE2AlgebraStorage<float,cva::Matrix<float,3u,1u,false>>::exp@<S0>(float *a1@<X0>, uint64_t a2@<X8>)
{
  *(_DWORD *)(a2 + 32) = 1065353216;
  *(_OWORD *)a2 = xmmword_2154461C0;
  *(_OWORD *)(a2 + 16) = unk_2154461D0;
  float v4 = *a1;
  __float2 v5 = __sincosf_stret(*a1);
  float v6 = v4 * v4;
  if ((float)(v4 * v4) >= 0.0061)
  {
    float v7 = (float)(1.0 / v4) * v5.__sinval;
    float v8 = (float)(1.0 / v4) * (float)(1.0 - v5.__cosval);
  }
  else
  {
    float v7 = 1.0 - (float)(v6 * (float)((float)(v6 / -120.0) + 0.16667));
    float v8 = v4 * (float)((float)(v6 / -24.0) + 0.5);
  }
  *(float *)a2 = v5.__cosval;
  *(float *)(a2 + 4) = v5.__sinval;
  *(float *)(a2 + 12) = -v5.__sinval;
  *(float *)(a2 + 16) = v5.__cosval;
  float v9 = a1[1];
  float v10 = a1[2];
  float v11 = (float)(v7 * v9) - (float)(v8 * v10);
  float result = (float)(v7 * v10) + (float)(v8 * v9);
  *(float *)(a2 + 24) = v11;
  *(float *)(a2 + 28) = result;
  return result;
}

uint64_t cva::SE2GroupStorage<float,cva::Matrix<float,3u,3u,false>>::serialize()
{
  return std::ostream::write();
}

uint64_t cva::SE2GroupStorage<float,cva::Matrix<float,3u,3u,false>>::deserialize(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x270F98678](a2, a1, 36);
}

double cva::SE2GroupStorage<double,cva::Matrix<double,3u,3u,false>>::SE2GroupStorage(uint64_t a1)
{
  *(void *)(a1 + 64) = 0x3FF0000000000000;
  *(_OWORD *)a1 = xmmword_215446208;
  *(_OWORD *)(a1 + 16) = unk_215446218;
  double result = 1.0;
  *(_OWORD *)(a1 + 32) = xmmword_215446228;
  *(_OWORD *)(a1 + 48) = unk_215446238;
  return result;
}

{
  double result;

  *(void *)(a1 + 64) = 0x3FF0000000000000;
  *(_OWORD *)a1 = xmmword_215446208;
  *(_OWORD *)(a1 + 16) = unk_215446218;
  double result = 1.0;
  *(_OWORD *)(a1 + 32) = xmmword_215446228;
  *(_OWORD *)(a1 + 48) = unk_215446238;
  return result;
}

uint64_t cva::SE2GroupStorage<double,cva::Matrix<double,3u,3u,false>>::SE2GroupStorage(uint64_t a1, void *a2, double a3)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 48) = 0u;
  __double2 v5 = __sincos_stret(a3);
  *(double *)a1 = v5.__cosval;
  *(double *)(a1 + 8) = v5.__sinval;
  *(double *)(a1 + 24) = -v5.__sinval;
  *(double *)(a1 + 32) = v5.__cosval;
  *(void *)(a1 + 48) = *a2;
  *(void *)(a1 + 56) = a2[1];
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 64) = 0x3FF0000000000000;
  return a1;
}

{
  __double2 v5;

  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 48) = 0u;
  __double2 v5 = __sincos_stret(a3);
  *(double *)a1 = v5.__cosval;
  *(double *)(a1 + 8) = v5.__sinval;
  *(double *)(a1 + 24) = -v5.__sinval;
  *(double *)(a1 + 32) = v5.__cosval;
  *(void *)(a1 + 48) = *a2;
  *(void *)(a1 + 56) = a2[1];
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 64) = 0x3FF0000000000000;
  return a1;
}

double cva::SE2GroupStorage<double,cva::Matrix<double,3u,3u,false>>::SE2GroupStorage(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = 0;
  *(void *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  unint64_t v4 = 0x100000000;
  do
  {
    uint64_t v5 = *a2++;
    *(void *)(a1 + 8 * v3) = v5;
    unint64_t v6 = HIDWORD(v4);
    BOOL v7 = (int)v4 < 1;
    if ((int)v4 < 1) {
      unint64_t v6 = 0;
    }
    uint64_t v8 = v3 + v6;
    uint64_t v9 = (v4 + 1);
    unint64_t v10 = v4 & 0xFFFFFFFF00000000;
    if (!v7) {
      uint64_t v9 = 0;
    }
    unint64_t v4 = v9 | v10;
    uint64_t v3 = v8 + 1;
  }
  while (v3 != 6);
  *(void *)(a1 + 48) = *(void *)a3;
  double result = *(double *)(a3 + 8);
  *(double *)(a1 + 56) = result;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 64) = 0x3FF0000000000000;
  return result;
}

{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  double result;

  uint64_t v3 = 0;
  *(void *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  unint64_t v4 = 0x100000000;
  do
  {
    uint64_t v5 = *a2++;
    *(void *)(a1 + 8 * v3) = v5;
    unint64_t v6 = HIDWORD(v4);
    BOOL v7 = (int)v4 < 1;
    if ((int)v4 < 1) {
      unint64_t v6 = 0;
    }
    uint64_t v8 = v3 + v6;
    uint64_t v9 = (v4 + 1);
    unint64_t v10 = v4 & 0xFFFFFFFF00000000;
    if (!v7) {
      uint64_t v9 = 0;
    }
    unint64_t v4 = v9 | v10;
    uint64_t v3 = v8 + 1;
  }
  while (v3 != 6);
  *(void *)(a1 + 48) = *(void *)a3;
  double result = *(double *)(a3 + 8);
  *(double *)(a1 + 56) = result;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 64) = 0x3FF0000000000000;
  return result;
}

uint64_t cva::SE2GroupStorage<double,cva::Matrix<double,3u,3u,false>>::T(uint64_t a1)
{
  return a1 + 48;
}

{
  return a1 + 48;
}

__n128 cva::SE2GroupStorage<double,cva::Matrix<double,3u,3u,false>>::affine@<Q0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  a2[1] = 0u;
  a2[2] = 0u;
  *a2 = 0u;
  float v2 = (_OWORD *)a1;
  if ((_OWORD *)a1 != a2)
  {
    *a2 = *(_OWORD *)a1;
    float v2 = a2;
  }
  v2[1] = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 48);
  v2[2] = result;
  return result;
}

__n128 cva::SE2GroupStorage<double,cva::Matrix<double,3u,3u,false>>::lplus(uint64_t a1, double *a2)
{
  double v3 = *a2;
  double v4 = a2[1];
  double v5 = a2[2];
  long long v12 = xmmword_215446208;
  long long v13 = unk_215446218;
  long long v14 = xmmword_215446228;
  long long v15 = unk_215446238;
  uint64_t v16 = 0x3FF0000000000000;
  __double2 v6 = __sincos_stret(v3);
  double v7 = v3 * v3;
  if (v3 * v3 >= 0.0000002635)
  {
    double v8 = 1.0 / v3 * v6.__sinval;
    double v9 = 1.0 / v3 * (1.0 - v6.__cosval);
  }
  else
  {
    double v8 = 1.0 - v7 * (v7 / -120.0 + 0.166666667);
    double v9 = v3 * (v7 / -24.0 + 0.5);
  }
  *(double *)&long long v12 = v6.__cosval;
  *((void *)&v12 + 1) = *(void *)&v6.__sinval;
  *((double *)&v13 + 1) = -v6.__sinval;
  *(double *)&long long v14 = v6.__cosval;
  *(double *)&long long v15 = v8 * v4 - v9 * v5;
  *((double *)&v15 + 1) = v5 * v8 + v9 * v4;
  v17[0] = (double *)&v12;
  v17[1] = (double *)a1;
  long long v18 = 0u;
  __n128 v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  uint64_t v22 = 0;
  sub_2153CB228((uint64_t)&v18, v17);
  long long v10 = v21;
  *(_OWORD *)(a1 + 32) = v20;
  *(_OWORD *)(a1 + 48) = v10;
  *(void *)(a1 + 64) = v22;
  __n128 result = v19;
  *(_OWORD *)a1 = v18;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

double cva::SE2AlgebraStorage<double,cva::MatrixRef<double const,3u,1u,false>>::SE2AlgebraStorage(void *a1, uint64_t a2)
{
  *a1 = a2;
  *(void *)&double result = 3;
  a1[1] = 3;
  return result;
}

{
  double result;

  *a1 = a2;
  *(void *)&double result = 3;
  a1[1] = 3;
  return result;
}

{
  double result;

  *a1 = a2;
  *(void *)&double result = 3;
  a1[1] = 3;
  return result;
}

{
  double result;

  *a1 = a2;
  *(void *)&double result = 3;
  a1[1] = 3;
  return result;
}

double cva::SE2AlgebraStorage<double,cva::MatrixRef<double const,3u,1u,false>>::exp@<D0>(double **a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 64) = 0x3FF0000000000000;
  *(_OWORD *)a2 = xmmword_215446208;
  *(_OWORD *)(a2 + 16) = unk_215446218;
  *(_OWORD *)(a2 + 32) = xmmword_215446228;
  *(_OWORD *)(a2 + 48) = unk_215446238;
  double v3 = *a1;
  double v4 = **a1;
  __double2 v5 = __sincos_stret(v4);
  double v6 = v4 * v4;
  if (v4 * v4 >= 0.0000002635)
  {
    double v7 = 1.0 / v4 * v5.__sinval;
    double v8 = 1.0 / v4 * (1.0 - v5.__cosval);
  }
  else
  {
    double v7 = 1.0 - v6 * (v6 / -120.0 + 0.166666667);
    double v8 = v4 * (v6 / -24.0 + 0.5);
  }
  *(double *)a2 = v5.__cosval;
  *(double *)(a2 + 8) = v5.__sinval;
  *(double *)(a2 + 24) = -v5.__sinval;
  *(double *)(a2 + 32) = v5.__cosval;
  double v9 = v3[1];
  double v10 = v3[2];
  double v11 = v7 * v9 - v8 * v10;
  double result = v7 * v10 + v8 * v9;
  *(double *)(a2 + 48) = v11;
  *(double *)(a2 + 56) = result;
  return result;
}

__n128 cva::SE2GroupStorage<double,cva::Matrix<double,3u,3u,false>>::rplus(uint64_t a1, double *a2)
{
  double v3 = *a2;
  double v4 = a2[1];
  double v5 = a2[2];
  long long v12 = xmmword_215446208;
  long long v13 = unk_215446218;
  long long v14 = xmmword_215446228;
  long long v15 = unk_215446238;
  uint64_t v16 = 0x3FF0000000000000;
  __double2 v6 = __sincos_stret(v3);
  double v7 = v3 * v3;
  if (v3 * v3 >= 0.0000002635)
  {
    double v8 = 1.0 / v3 * v6.__sinval;
    double v9 = 1.0 / v3 * (1.0 - v6.__cosval);
  }
  else
  {
    double v8 = 1.0 - v7 * (v7 / -120.0 + 0.166666667);
    double v9 = v3 * (v7 / -24.0 + 0.5);
  }
  *(double *)&long long v12 = v6.__cosval;
  *((void *)&v12 + 1) = *(void *)&v6.__sinval;
  *((double *)&v13 + 1) = -v6.__sinval;
  *(double *)&long long v14 = v6.__cosval;
  *(double *)&long long v15 = v8 * v4 - v9 * v5;
  *((double *)&v15 + 1) = v5 * v8 + v9 * v4;
  v17[0] = (double *)a1;
  v17[1] = (double *)&v12;
  long long v18 = 0u;
  __n128 v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  uint64_t v22 = 0;
  sub_2153CB228((uint64_t)&v18, v17);
  long long v10 = v21;
  *(_OWORD *)(a1 + 32) = v20;
  *(_OWORD *)(a1 + 48) = v10;
  *(void *)(a1 + 64) = v22;
  __n128 result = v19;
  *(_OWORD *)a1 = v18;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

double cva::SE2GroupStorage<double,cva::Matrix<double,3u,3u,false>>::transform@<D0>(double *a1@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = a1;
  v7[1] = 3;
  v8[0] = (double *)v7;
  v8[1] = a2;
  double v9 = 0.0;
  double v10 = 0.0;
  sub_2153D4ABC(&v9, v8);
  *a3 = 0.0;
  a3[1] = 0.0;
  double result = v9 + a1[6];
  double v6 = v10 + a1[7];
  if (a1 == a3)
  {
    *a1 = result;
    a1[1] = v6;
  }
  else
  {
    *a3 = result;
    a3[1] = v6;
  }
  return result;
}

double *sub_2153D4ABC(double *result, double **a2)
{
  float v2 = result;
  uint64_t v3 = *(void *)*a2;
  if ((double *)(v3 - 8 * *((unsigned int *)*a2 + 3)) == result || (double v4 = a2[1], v4 == result))
  {
    long long v17 = 0uLL;
    double result = (double *)sub_2153D4ABC(&v17);
    *(_OWORD *)float v2 = v17;
  }
  else
  {
    uint64_t v5 = *((unsigned int *)*a2 + 2);
    uint64_t v6 = (2 * v5);
    if (v6)
    {
      uint64_t v7 = 0;
      uint64_t v8 = 8 * v6;
      uint64_t v9 = 8 * v5;
      double v10 = 0.0;
      uint64_t v11 = a2[1];
      do
      {
        double v12 = *v11++;
        double v10 = v10 + *(double *)(v3 + v7) * v12;
        v7 += v9;
      }
      while (v8 != v7);
      uint64_t v13 = 0;
      *double result = v10;
      uint64_t v14 = v3 + 8;
      double v15 = 0.0;
      do
      {
        double v16 = *v4++;
        double v15 = v15 + *(double *)(v14 + v13) * v16;
        v13 += v9;
      }
      while (v8 != v13);
    }
    else
    {
      *double result = 0.0;
      double v15 = 0.0;
    }
    result[1] = v15;
  }
  return result;
}

float64x2_t cva::SE2GroupStorage<double,cva::Matrix<double,3u,3u,false>>::inverseTransform@<Q0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, float64x2_t *a3@<X8>)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  v9[0] = a1;
  v9[1] = 3;
  double v10 = v9;
  v11[0] = (uint64_t *)&v10;
  v11[1] = a2;
  v6[0] = a1;
  v6[1] = 3;
  uint64_t v7 = v6;
  v5[0] = a1 + 48;
  v5[1] = 0x600000003;
  v8[0] = (uint64_t *)&v7;
  v8[1] = v5;
  float64x2_t v12 = 0uLL;
  sub_2153D4C54(v12.f64, v11);
  float64x2_t v13 = 0uLL;
  sub_2153D4CE8((uint64_t)&v13, v8);
  float64x2_t result = vsubq_f64(v12, v13);
  *a3 = result;
  return result;
}

double sub_2153D4C54(double *a1, uint64_t **a2)
{
  uint64_t v3 = (double *)a2[1];
  if (v3 == a1)
  {
    long long v8 = 0uLL;
    sub_2153D4C54(&v8);
    double result = *(double *)&v8;
    *(_OWORD *)a1 = v8;
  }
  else
  {
    uint64_t v4 = **a2;
    uint64_t v5 = *(double **)v4;
    uint64_t v6 = *(unsigned int *)(v4 + 8);
    *a1 = v5[1] * v3[1] + *v5 * *v3 + 0.0;
    double result = v5[v6 + 1] * v3[1] + v5[v6] * *v3 + 0.0;
    a1[1] = result;
  }
  return result;
}

double sub_2153D4CE8(uint64_t a1, uint64_t **a2)
{
  uint64_t v3 = a2[1];
  uint64_t v4 = (double *)*v3;
  if (*v3 - 8 * *((unsigned int *)v3 + 3) == a1)
  {
    long long v9 = 0uLL;
    sub_2153D4CE8(&v9);
    double result = *(double *)&v9;
    *(_OWORD *)a1 = v9;
  }
  else
  {
    uint64_t v5 = **a2;
    uint64_t v6 = *(double **)v5;
    uint64_t v7 = *(unsigned int *)(v5 + 8);
    *(double *)a1 = v6[1] * v4[1] + *v6 * *v4 + 0.0;
    double result = v6[v7 + 1] * v4[1] + v6[v7] * *v4 + 0.0;
    *(double *)(a1 + 8) = result;
  }
  return result;
}

double cva::SE2GroupStorage<double,cva::Matrix<double,3u,3u,false>>::transformJacobian@<D0>(double *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2 = *(void *)a1;
  double result = -a1[1];
  *(double *)a2 = result;
  *(void *)(a2 + 8) = v2;
  *(void *)(a2 + 16) = 0x3FF0000000000000;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0x3FF0000000000000;
  return result;
}

void cva::SE2GroupStorage<double,cva::Matrix<double,3u,3u,false>>::inverseTransformJacobian(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  double v5 = -*(double *)a2;
  *(void *)a3 = *(void *)(a2 + 8);
  *(double *)(a3 + 8) = v5;
  v26[0] = a1;
  v26[1] = 3;
  float v27 = v26;
  v25[0] = a3;
  v25[1] = 2;
  v28[0] = (uint64_t *)&v27;
  v28[1] = v25;
  double v29 = 0.0;
  unint64_t v30 = 0;
  sub_2153D4CE8((uint64_t)&v29, v28);
  double v7 = v29;
  double v6 = *(double *)&v30;
  *(double *)a3 = v29;
  *(double *)(a3 + 8) = v6;
  if (a1 == a3)
  {
    unint64_t v16 = 0;
    double v29 = -v7;
    unint64_t v30 = 0x8000000000000000;
    double v31 = -v6;
    unint64_t v32 = 0x8000000000000000;
    long long v17 = &v29;
    for (uint64_t i = 2; i != 6; uint64_t i = v22 + 1)
    {
      uint64_t v19 = *(void *)v17++;
      *(void *)(a3 + 8 * i) = v19;
      unint64_t v20 = HIDWORD(v16);
      BOOL v21 = (int)v16 < 1;
      if ((int)v16 < 1) {
        unint64_t v20 = 0;
      }
      unint64_t v22 = i + v20;
      uint64_t v23 = (v16 + 1);
      unint64_t v24 = v16 & 0xFFFFFFFF00000000;
      if (!v21) {
        uint64_t v23 = 0;
      }
      unint64_t v16 = v23 | v24;
    }
  }
  else
  {
    unint64_t v8 = 0;
    unint64_t v9 = 0;
    for (uint64_t j = 2; j != 6; uint64_t j = v13 + 1)
    {
      *(double *)(a3 + 8 * j) = -*(double *)(a1 + 8 * (3 * v9 + HIDWORD(v9)));
      if ((int)v9 >= 1) {
        unint64_t v9 = (v9 & 0xFFFFFFFF00000000) + 0x100000000;
      }
      else {
        unint64_t v9 = (v9 + 1) | v9 & 0xFFFFFFFF00000000;
      }
      unint64_t v11 = HIDWORD(v8);
      BOOL v12 = (int)v8 < 1;
      if ((int)v8 < 1) {
        unint64_t v11 = 0;
      }
      unint64_t v13 = j + v11;
      uint64_t v14 = (v8 + 1);
      unint64_t v15 = v8 & 0xFFFFFFFF00000000;
      if (!v12) {
        uint64_t v14 = 0;
      }
      unint64_t v8 = v14 | v15;
    }
  }
}

double cva::SE2GroupStorage<double,cva::Matrix<double,3u,3u,false>>::log@<D0>(uint64_t a1@<X0>, double *a2@<X8>)
{
  double v4 = atan2(*(long double *)(a1 + 8), *(long double *)a1);
  double v5 = v4 * v4;
  if (v4 * v4 >= 0.0000002635)
  {
    __double2 v8 = __sincos_stret(v4);
    double v6 = 1.0 / v4 * v8.__sinval;
    double v7 = 1.0 / v4 * (1.0 - v8.__cosval);
  }
  else
  {
    double v6 = 1.0 - v5 * (v5 / -120.0 + 0.166666667);
    double v7 = v4 * (v5 / -24.0 + 0.5);
  }
  double v9 = 1.0 / (v7 * v7 + v6 * v6);
  double v10 = *(double *)(a1 + 48);
  double v11 = *(double *)(a1 + 56);
  *a2 = v4;
  a2[1] = v9 * (v7 * v11 + v6 * v10);
  double result = v9 * (v6 * v11 - v7 * v10);
  a2[2] = result;
  return result;
}

void *cva::SE2AlgebraStorage<double,cva::Matrix<double,3u,1u,false>>::SE2AlgebraStorage(void *result)
{
  *double result = 0;
  result[1] = 0;
  result[2] = 0;
  return result;
}

{
  *double result = 0;
  result[1] = 0;
  result[2] = 0;
  return result;
}

void cva::SE2GroupStorage<double,cva::Matrix<double,3u,3u,false>>::logJacobian(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 24) = 0u;
  double v4 = (void *)(a2 + 24);
  *(void *)(a2 + 88) = 0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 72) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  double v5 = atan2(*(long double *)(a1 + 8), *(long double *)a1);
  double v6 = v5 * v5;
  if (v5 * v5 >= 0.0000002635)
  {
    __double2 v12 = __sincos_stret(v5);
    double v9 = 1.0 / v5 * v12.__sinval;
    double v11 = 1.0 / v5 * (1.0 - v12.__cosval);
    double v7 = 1.0 / v5 * v11;
    double v10 = 1.0 / v5 * (1.0 - v9);
  }
  else
  {
    double v7 = 0.5 - v6 * (v6 / -720.0 + 0.0416666667);
    double v8 = 0.166666667 - v6 * (v6 / -5040.0 + 0.00833333333);
    double v9 = 1.0 - v6 * v8;
    double v10 = v5 * v8;
    double v11 = v5 * v7;
  }
  double v13 = v11 * v11 + v9 * v9;
  double v14 = 1.0 / v13;
  double v15 = *(double *)(a1 + 48);
  double v16 = *(double *)(a1 + 56);
  double v17 = 1.0 / v13 * (v11 * v16 + v9 * v15);
  *(double *)a2 = v5;
  *(double *)(a2 + 8) = v17;
  double v18 = 1.0 / v13 * (v9 * v16 - v11 * v15);
  *(double *)(a2 + 16) = v18;
  if (fabs(v13) >= 0.00001)
  {
    double v19 = v9 * v14;
    double v20 = v14 * -v11;
    double v21 = v11 * v14;
    *(double *)unint64_t v38 = v19;
    *(double *)&v38[1] = v20;
    *(double *)&v38[2] = v21;
    *(double *)&v38[3] = v19;
    double v22 = v10 * v17 + v7 * v18;
    double v23 = v10 * v18 - v7 * v17;
    *(double *)int v37 = v22;
    *(double *)&v37[1] = v23;
    *(void *)(a2 + 24) = 0x3FF0000000000000;
    int v35 = v38;
    v36[0] = &v35;
    v36[1] = v37;
    if (v37 == v4)
    {
      double v39 = 0.0;
      double v40 = 0.0;
      sub_2153D51F0(&v39, (uint64_t)v36);
      double v24 = v39;
      double v25 = v40;
    }
    else
    {
      double v24 = 0.0 - v19 * v22 - v21 * v23;
      double v25 = 0.0 - v20 * v22 - v19 * v23;
    }
    *(double *)(a2 + 32) = v24;
    *(double *)(a2 + 40) = v25;
    *(void *)(a2 + 48) = 0;
    unint64_t v26 = 0x100000000;
    float v27 = v38;
    uint64_t v28 = 4;
    *(void *)(a2 + 72) = 0;
    do
    {
      uint64_t v29 = *v27++;
      v4[v28] = v29;
      unint64_t v30 = HIDWORD(v26);
      BOOL v31 = (int)v26 < 1;
      if ((int)v26 < 1) {
        unint64_t v30 = 0;
      }
      unint64_t v32 = v28 + v30;
      uint64_t v33 = (v26 + 1);
      unint64_t v34 = v26 & 0xFFFFFFFF00000000;
      if (!v31) {
        uint64_t v33 = 0;
      }
      unint64_t v26 = v33 | v34;
      uint64_t v28 = v32 + 1;
    }
    while (v28 != 10);
  }
}

double sub_2153D51F0(double *a1, uint64_t a2)
{
  uint64_t v3 = *(double **)(a2 + 8);
  if (v3 == a1)
  {
    long long v8 = 0uLL;
    sub_2153D51F0(&v8);
    double result = *(double *)&v8;
    *(_OWORD *)a1 = v8;
  }
  else
  {
    double v4 = **(double ***)a2;
    double v5 = v4[1];
    double v6 = v4[3];
    *a1 = 0.0 - *v4 * *v3 - v4[2] * v3[1];
    double result = 0.0 - v5 * *v3 - v6 * v3[1];
    a1[1] = result;
  }
  return result;
}

double cva::SE2GroupStorage<double,cva::Matrix<double,3u,3u,false>>::inverse@<D0>(double *a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)a2 = xmmword_215446208;
  *(_OWORD *)(a2 + 16) = unk_215446218;
  *(void *)(a2 + 64) = 0x3FF0000000000000;
  *(_OWORD *)(a2 + 32) = xmmword_215446228;
  *(_OWORD *)(a2 + 48) = unk_215446238;
  double v2 = *a1;
  double v3 = a1[1];
  double v4 = a1[3];
  double v5 = a1[4];
  *(double *)a2 = *a1;
  *(double *)(a2 + 8) = v4;
  *(double *)(a2 + 24) = v3;
  *(double *)(a2 + 32) = v5;
  double v6 = a1[6];
  double v7 = a1[7];
  double result = -(v3 * v7) - v2 * v6;
  *(double *)(a2 + 48) = result;
  *(double *)(a2 + 56) = -(v5 * v7) - v4 * v6;
  return result;
}

double cva::SE2GroupStorage<double,cva::Matrix<double,3u,3u,false>>::adjoint@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 64) = 0;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  if (a1 == a2)
  {
    long long v18 = *(_OWORD *)(a2 + 24);
    v31[0] = *(_OWORD *)a2;
    v31[1] = v18;
    unint64_t v19 = 0x100000000;
    double v20 = (uint64_t *)v31;
    for (uint64_t i = 4; i != 10; uint64_t i = v26 + 1)
    {
      uint64_t v22 = *v20++;
      *(void *)(a2 + 8 * i) = v22;
      unint64_t v23 = HIDWORD(v19);
      BOOL v25 = __OFSUB__(v19, 1);
      BOOL v24 = (int)v19 - 1 < 0;
      if ((int)v19 < 1) {
        unint64_t v23 = 0;
      }
      unint64_t v26 = i + v23;
      uint64_t v27 = (v19 + 1);
      unint64_t v28 = v19 & 0xFFFFFFFF00000000;
      if (v24 == v25) {
        uint64_t v27 = 0;
      }
      unint64_t v19 = v27 | v28;
    }
  }
  else
  {
    unint64_t v2 = 0x100000000;
    uint64_t v3 = 4;
    double v4 = (void *)a1;
    unint64_t v5 = 0x100000000;
    do
    {
      *(void *)(a2 + 8 * v3) = *v4;
      unint64_t v6 = HIDWORD(v5);
      BOOL v8 = __OFSUB__(v5, 1);
      BOOL v7 = (int)v5 - 1 < 0;
      if ((int)v5 < 1) {
        unint64_t v6 = 0;
      }
      double v9 = &v4[v6];
      uint64_t v10 = (v5 + 1);
      unint64_t v11 = v5 & 0xFFFFFFFF00000000;
      if (v7 == v8) {
        uint64_t v10 = 0;
      }
      unint64_t v5 = v10 | v11;
      double v4 = v9 + 1;
      unint64_t v12 = HIDWORD(v2);
      BOOL v14 = __OFSUB__(v2, 1);
      BOOL v13 = (int)v2 - 1 < 0;
      if ((int)v2 < 1) {
        unint64_t v12 = 0;
      }
      unint64_t v15 = v3 + v12;
      uint64_t v16 = (v2 + 1);
      unint64_t v17 = v2 & 0xFFFFFFFF00000000;
      if (v13 == v14) {
        uint64_t v16 = 0;
      }
      unint64_t v2 = v16 | v17;
      uint64_t v3 = v15 + 1;
    }
    while (v3 != 10);
  }
  double result = *(double *)(a1 + 56);
  double v30 = -*(double *)(a1 + 48);
  *(double *)(a2 + 8) = result;
  *(double *)(a2 + 16) = v30;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)a2 = 0x3FF0000000000000;
  return result;
}

double cva::SE2GroupStorage<double,cva::Matrix<double,3u,3u,false>>::enforce(uint64_t a1)
{
  double v2 = atan2(*(long double *)(a1 + 8), *(long double *)a1);
  double v3 = v2 * v2;
  if (v2 * v2 >= 0.0000002635)
  {
    __double2 v9 = __sincos_stret(v2);
    double cosval = v9.__cosval;
    double sinval = v9.__sinval;
    double v4 = 1.0 / v2 * v9.__sinval;
    double v5 = 1.0 / v2 * (1.0 - v9.__cosval);
  }
  else
  {
    double v4 = 1.0 - v3 * (v3 / -120.0 + 0.166666667);
    double v5 = v2 * (v3 / -24.0 + 0.5);
    __double2 v8 = __sincos_stret(v2);
    double cosval = v8.__cosval;
    double sinval = v8.__sinval;
  }
  double v10 = *(double *)(a1 + 48);
  double v11 = *(double *)(a1 + 56);
  double v12 = 1.0 / (v5 * v5 + v4 * v4);
  double v13 = v12 * (v4 * v11 - v5 * v10);
  double v14 = v12 * (v5 * v11 + v4 * v10);
  *(double *)a1 = cosval;
  *(double *)(a1 + 8) = sinval;
  *(void *)(a1 + 16) = 0;
  *(double *)(a1 + 24) = -sinval;
  *(double *)(a1 + 32) = cosval;
  double result = v13 * v4 + v5 * v14;
  *(void *)(a1 + 40) = 0;
  *(double *)(a1 + 48) = v4 * v14 - v5 * v13;
  *(double *)(a1 + 56) = result;
  *(void *)(a1 + 64) = 0x3FF0000000000000;
  return result;
}

double cva::SE2AlgebraStorage<double,cva::Matrix<double,3u,1u,false>>::exp@<D0>(double *a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 64) = 0x3FF0000000000000;
  *(_OWORD *)a2 = xmmword_215446208;
  *(_OWORD *)(a2 + 16) = unk_215446218;
  *(_OWORD *)(a2 + 32) = xmmword_215446228;
  *(_OWORD *)(a2 + 48) = unk_215446238;
  double v4 = *a1;
  __double2 v5 = __sincos_stret(*a1);
  double v6 = v4 * v4;
  if (v4 * v4 >= 0.0000002635)
  {
    double v7 = 1.0 / v4 * v5.__sinval;
    double v8 = 1.0 / v4 * (1.0 - v5.__cosval);
  }
  else
  {
    double v7 = 1.0 - v6 * (v6 / -120.0 + 0.166666667);
    double v8 = v4 * (v6 / -24.0 + 0.5);
  }
  *(double *)a2 = v5.__cosval;
  *(double *)(a2 + 8) = v5.__sinval;
  *(double *)(a2 + 24) = -v5.__sinval;
  *(double *)(a2 + 32) = v5.__cosval;
  double v9 = a1[1];
  double v10 = a1[2];
  double v11 = v7 * v9 - v8 * v10;
  double result = v7 * v10 + v8 * v9;
  *(double *)(a2 + 48) = v11;
  *(double *)(a2 + 56) = result;
  return result;
}

uint64_t cva::SE2GroupStorage<double,cva::Matrix<double,3u,3u,false>>::serialize()
{
  return std::ostream::write();
}

uint64_t cva::SE2GroupStorage<double,cva::Matrix<double,3u,3u,false>>::deserialize(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x270F98678](a2, a1, 72);
}

double cva::SE2GroupStorage<float,cva::MatrixRef<float const,3u,3u,false>>::SE2GroupStorage(void *a1, uint64_t a2)
{
  *a1 = a2;
  *(void *)&double result = 3;
  a1[1] = 3;
  return result;
}

{
  double result;

  *a1 = a2;
  *(void *)&double result = 3;
  a1[1] = 3;
  return result;
}

{
  double result;

  *a1 = a2;
  *(void *)&double result = 3;
  a1[1] = 3;
  return result;
}

{
  double result;

  *a1 = a2;
  *(void *)&double result = 3;
  a1[1] = 3;
  return result;
}

uint64_t cva::SE2GroupStorage<float,cva::MatrixRef<float const,3u,3u,false>>::R(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t cva::SE2GroupStorage<float,cva::MatrixRef<float const,3u,3u,false>>::T(uint64_t a1)
{
  return *(void *)a1
       - 4 * *(unsigned int *)(a1 + 12)
       + 4 * (*(_DWORD *)(a1 + 12) + 2 * *(_DWORD *)(a1 + 8));
}

uint64_t cva::SE2GroupStorage<float,cva::MatrixRef<float const,3u,3u,false>>::affine@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  double v2 = *(int **)result;
  int v4 = *(_DWORD *)(result + 8);
  uint64_t v3 = *(unsigned int *)(result + 12);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  __double2 v5 = &v2[-v3];
  uint64_t v6 = (v4 - 2);
  int v7 = *v2;
  if (v5 == (int *)a2)
  {
    int v12 = v2[1];
    uint64_t v13 = v6;
    double v14 = &v2[v13];
    *(void *)&long long v15 = *((void *)v14 + 1);
    uint64_t v16 = *(void *)&v14[v13 + 4];
    *(_DWORD *)a2 = v7;
    *(_DWORD *)(a2 + 4) = v12;
    *((void *)&v15 + 1) = v16;
    *(_OWORD *)(a2 + 8) = v15;
  }
  else
  {
    *(_DWORD *)a2 = v7;
    *(_DWORD *)(a2 + 4) = v2[1];
    uint64_t v8 = v6;
    double v9 = &v2[v8];
    int v10 = v9[2];
    v9 += 2;
    *(_DWORD *)(a2 + 8) = v10;
    *(_DWORD *)(a2 + 12) = v9[1];
    double v11 = &v9[v8];
    *(_DWORD *)(a2 + 16) = v11[2];
    *(_DWORD *)(a2 + 20) = v11[3];
  }
  return result;
}

float cva::SE2GroupStorage<float,cva::MatrixRef<float const,3u,3u,false>>::transform@<S0>(uint64_t a1@<X0>, float *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = *(unsigned int *)(a1 + 8);
  uint64_t v4 = *(unsigned int *)(a1 + 12);
  uint64_t v6 = *(void *)a1 - 4 * v4;
  v10[0] = *(void *)a1;
  v10[1] = v5 | (v4 << 32);
  v11[0] = (float *)v10;
  v11[1] = a2;
  int v7 = (float *)(v6 + 4 * (v4 + 2 * v5));
  *(void *)int v12 = 0;
  sub_2153D398C(v12, v11);
  *(void *)a3 = 0;
  float result = v12[0] + *v7;
  if (v6 == a3)
  {
    float v9 = v12[1] + v7[1];
    *(float *)a3 = result;
    *(float *)(a3 + 4) = v9;
  }
  else
  {
    *(float *)a3 = result;
    float result = v12[1] + v7[1];
    *(float *)(a3 + 4) = result;
  }
  return result;
}

float32x2_t cva::SE2GroupStorage<float,cva::MatrixRef<float const,3u,3u,false>>::inverseTransform@<D0>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, float32x2_t *a3@<X8>)
{
  uint64_t v5 = *((unsigned int *)a1 + 2);
  uint64_t v4 = *((unsigned int *)a1 + 3);
  uint64_t v6 = *a1 - 4 * v4;
  uint64_t v13 = *a1;
  uint64_t v14 = v5 | (v4 << 32);
  long long v15 = &v13;
  v16[0] = (uint64_t *)&v15;
  v16[1] = a2;
  v10[0] = v13;
  v10[1] = v14;
  double v11 = v10;
  uint64_t v7 = (v4 + 2 * v5);
  v9[0] = v6 + 4 * v7;
  v9[1] = v5 | (v7 << 32);
  v12[0] = (uint64_t *)&v11;
  v12[1] = v9;
  float32x2_t v17 = 0;
  sub_2153D3AFC((float *)&v17, v16);
  float32x2_t v18 = 0;
  sub_2153D3B90((float *)&v18, v12);
  float32x2_t result = vsub_f32(v17, v18);
  *a3 = result;
  return result;
}

double cva::SE2GroupStorage<float,cva::MatrixRef<float const,3u,3u,false>>::transformJacobian@<D0>(float *a1@<X1>, uint64_t a2@<X8>)
{
  int v2 = *(_DWORD *)a1;
  *(float *)a2 = -a1[1];
  *(_DWORD *)(a2 + 4) = v2;
  *(void *)&double result = 1065353216;
  *(_OWORD *)(a2 + 8) = xmmword_215445EC0;
  return result;
}

float *cva::SE2GroupStorage<float,cva::MatrixRef<float const,3u,3u,false>>::inverseTransformJacobian@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  float v4 = -*(float *)a2;
  *(_DWORD *)a3 = *(_DWORD *)(a2 + 4);
  *(float *)(a3 + 4) = v4;
  unint64_t v6 = a1[1];
  v29[0] = *a1;
  uint64_t v5 = (float *)v29[0];
  v29[1] = v6;
  double v30 = v29;
  uint64_t v31 = 0;
  v28[0] = a3;
  v28[1] = 2;
  unint64_t v32 = (uint64_t *)&v30;
  uint64_t v33 = v28;
  double result = sub_2153D3B90((float *)&v31, &v32);
  *(void *)a3 = v31;
  if (&v5[-HIDWORD(v6)] == (float *)a3)
  {
    unint64_t v16 = 0;
    float v17 = v5[1];
    float v18 = -v5[v6];
    *(float *)&unint64_t v32 = -*v5;
    *((float *)&v32 + 1) = v18;
    float v19 = -v5[(v6 + 1)];
    *(float *)&uint64_t v33 = -v17;
    *((float *)&v33 + 1) = v19;
    double v20 = &v32;
    for (uint64_t i = 2; i != 6; uint64_t i = v25 + 1)
    {
      int v22 = *(_DWORD *)v20;
      double v20 = (uint64_t **)((char *)v20 + 4);
      *(_DWORD *)(a3 + 4 * i) = v22;
      unint64_t v23 = HIDWORD(v16);
      BOOL v24 = (int)v16 < 1;
      if ((int)v16 < 1) {
        unint64_t v23 = 0;
      }
      unint64_t v25 = i + v23;
      uint64_t v26 = (v16 + 1);
      unint64_t v27 = v16 & 0xFFFFFFFF00000000;
      if (!v24) {
        uint64_t v26 = 0;
      }
      unint64_t v16 = v26 | v27;
    }
  }
  else
  {
    unint64_t v8 = 0;
    unint64_t v9 = 0;
    for (uint64_t j = 2; j != 6; uint64_t j = v13 + 1)
    {
      *(float *)(a3 + 4 * j) = -v5[(HIDWORD(v9) + v6 * v9)];
      if ((int)v9 >= 1) {
        unint64_t v9 = (v9 & 0xFFFFFFFF00000000) + 0x100000000;
      }
      else {
        unint64_t v9 = (v9 + 1) | v9 & 0xFFFFFFFF00000000;
      }
      unint64_t v11 = HIDWORD(v8);
      BOOL v12 = (int)v8 < 1;
      if ((int)v8 < 1) {
        unint64_t v11 = 0;
      }
      unint64_t v13 = j + v11;
      uint64_t v14 = (v8 + 1);
      unint64_t v15 = v8 & 0xFFFFFFFF00000000;
      if (!v12) {
        uint64_t v14 = 0;
      }
      unint64_t v8 = v14 | v15;
    }
  }
  return result;
}

float cva::SE2GroupStorage<float,cva::MatrixRef<float const,3u,3u,false>>::log@<S0>(float **a1@<X0>, float *a2@<X8>)
{
  float v4 = *a1;
  float v5 = atan2f((*a1)[1], **a1);
  float v6 = v5 * v5;
  if ((float)(v5 * v5) >= 0.0061)
  {
    __float2 v9 = __sincosf_stret(v5);
    float v7 = (float)(1.0 / v5) * v9.__sinval;
    float v8 = (float)(1.0 / v5) * (float)(1.0 - v9.__cosval);
  }
  else
  {
    float v7 = 1.0 - (float)(v6 * (float)((float)(v6 / -120.0) + 0.16667));
    float v8 = v5 * (float)((float)(v6 / -24.0) + 0.5);
  }
  float v10 = 1.0 / (float)((float)(v8 * v8) + (float)(v7 * v7));
  int v11 = *((_DWORD *)a1 + 2);
  float v12 = v4[2 * v11];
  float v13 = v4[(2 * v11) | 1];
  *a2 = v5;
  a2[1] = v10 * (float)((float)(v8 * v13) + (float)(v7 * v12));
  float result = v10 * (float)((float)(v7 * v13) - (float)(v8 * v12));
  a2[2] = result;
  return result;
}

void cva::SE2GroupStorage<float,cva::MatrixRef<float const,3u,3u,false>>::logJacobian(float **a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 12) = 0u;
  float v4 = (_DWORD *)(a2 + 12);
  *(_DWORD *)(a2 + 44) = 0;
  *(_OWORD *)(a2 + 28) = 0u;
  float v5 = *a1;
  float v6 = atan2f((*a1)[1], **a1);
  float v7 = v6 * v6;
  if ((float)(v6 * v6) >= 0.0061)
  {
    __float2 v13 = __sincosf_stret(v6);
    float v10 = (float)(1.0 / v6) * v13.__sinval;
    float v12 = (float)(1.0 / v6) * (float)(1.0 - v13.__cosval);
    float v8 = (float)(1.0 / v6) * v12;
    float v11 = (float)(1.0 / v6) * (float)(1.0 - v10);
  }
  else
  {
    float v8 = 0.5 - (float)(v7 * (float)((float)(v7 / -720.0) + 0.041667));
    float v9 = 0.16667 - (float)(v7 * (float)((float)(v7 / -5040.0) + 0.0083333));
    float v10 = 1.0 - (float)(v7 * v9);
    float v11 = v6 * v9;
    float v12 = v6 * v8;
  }
  float v14 = (float)(v12 * v12) + (float)(v10 * v10);
  float v15 = 1.0 / v14;
  *(float *)a2 = v6;
  int v16 = *((_DWORD *)a1 + 2);
  float v17 = v5[2 * v16];
  float v18 = v5[(2 * v16) | 1];
  float v19 = (float)(1.0 / v14) * (float)((float)(v12 * v18) + (float)(v10 * v17));
  float v20 = (float)(1.0 / v14) * (float)((float)(v10 * v18) - (float)(v12 * v17));
  *(float *)(a2 + 4) = v19;
  *(float *)(a2 + 8) = v20;
  if (fabsf(v14) >= 0.00001)
  {
    float v21 = v10 * v15;
    float v22 = v15 * (float)-v12;
    float v23 = v12 * v15;
    *(float *)double v40 = v21;
    *(float *)&v40[1] = v22;
    *(float *)&v40[2] = v23;
    *(float *)&v40[3] = v21;
    float v24 = (float)(v11 * v19) + (float)(v8 * v20);
    float v25 = (float)(v11 * v20) - (float)(v8 * v19);
    *(float *)double v39 = v24;
    *(float *)&v39[1] = v25;
    *(_DWORD *)(a2 + 12) = 1065353216;
    int v37 = v40;
    v38[0] = &v37;
    v38[1] = v39;
    if (v39 == v4)
    {
      uint64_t v41 = 0;
      sub_2153D4094((float *)&v41, (uint64_t)v38);
      float v27 = *((float *)&v41 + 1);
      float v26 = *(float *)&v41;
    }
    else
    {
      float v26 = (float)(0.0 - (float)(v21 * v24)) - (float)(v23 * v25);
      float v27 = (float)(0.0 - (float)(v22 * v24)) - (float)(v21 * v25);
    }
    *(float *)(a2 + 16) = v26;
    *(float *)(a2 + 20) = v27;
    *(_DWORD *)(a2 + 24) = 0;
    unint64_t v28 = 0x100000000;
    uint64_t v29 = v40;
    uint64_t v30 = 4;
    *(_DWORD *)(a2 + 36) = 0;
    do
    {
      int v31 = *v29++;
      v4[v30] = v31;
      unint64_t v32 = HIDWORD(v28);
      BOOL v33 = (int)v28 < 1;
      if ((int)v28 < 1) {
        unint64_t v32 = 0;
      }
      unint64_t v34 = v30 + v32;
      uint64_t v35 = (v28 + 1);
      unint64_t v36 = v28 & 0xFFFFFFFF00000000;
      if (!v33) {
        uint64_t v35 = 0;
      }
      unint64_t v28 = v35 | v36;
      uint64_t v30 = v34 + 1;
    }
    while (v30 != 10);
  }
}

float cva::SE2GroupStorage<float,cva::MatrixRef<float const,3u,3u,false>>::inverse@<S0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)a2 = xmmword_2154461C0;
  *(_OWORD *)(a2 + 16) = unk_2154461D0;
  *(_DWORD *)(a2 + 32) = 1065353216;
  int v2 = *(float **)a1;
  uint64_t v3 = *(unsigned int *)(a1 + 8);
  float v4 = *(float *)(*(void *)a1 + 4 * v3);
  float v5 = **(float **)a1;
  float v6 = *(float *)(*(void *)a1 + 4);
  *(float *)a2 = v5;
  *(float *)(a2 + 4) = v4;
  float v7 = v2[(v3 + 1)];
  *(float *)(a2 + 12) = v6;
  *(float *)(a2 + 16) = v7;
  float v8 = v2[(2 * v3)];
  float v9 = v2[(2 * v3) | 1];
  float result = (float)-(float)(v7 * v9) - (float)(v4 * v8);
  *(float *)(a2 + 24) = (float)-(float)(v6 * v9) - (float)(v5 * v8);
  *(float *)(a2 + 28) = result;
  return result;
}

float cva::SE2GroupStorage<float,cva::MatrixRef<float const,3u,3u,false>>::adjoint@<S0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 32) = 0;
  int v2 = *(void **)a1;
  int v3 = *(_DWORD *)(a1 + 8);
  if (*(void *)a1 - 4 * *(unsigned int *)(a1 + 12) == a2)
  {
    *(void *)&long long v18 = *v2;
    *((void *)&v18 + 1) = *(void *)((char *)v2 + 4 * (v3 - 2) + 8);
    long long v29 = v18;
    unint64_t v19 = 0x100000000;
    float v20 = (int *)&v29;
    for (uint64_t i = 4; i != 10; uint64_t i = v25 + 1)
    {
      int v22 = *v20++;
      *(_DWORD *)(a2 + 4 * i) = v22;
      unint64_t v23 = HIDWORD(v19);
      BOOL v24 = (int)v19 < 1;
      if ((int)v19 < 1) {
        unint64_t v23 = 0;
      }
      unint64_t v25 = i + v23;
      uint64_t v26 = (v19 + 1);
      unint64_t v27 = v19 & 0xFFFFFFFF00000000;
      if (!v24) {
        uint64_t v26 = 0;
      }
      unint64_t v19 = v26 | v27;
    }
  }
  else
  {
    unint64_t v4 = (unint64_t)(v3 - 2) << 32;
    unint64_t v5 = 0x100000000;
    uint64_t v6 = 4;
    float v7 = *(_DWORD **)a1;
    do
    {
      *(_DWORD *)(a2 + 4 * v6) = *v7;
      unint64_t v8 = HIDWORD(v4);
      BOOL v9 = (int)v4 < 1;
      if ((int)v4 < 1) {
        unint64_t v8 = 0;
      }
      float v10 = &v7[v8];
      uint64_t v11 = (v4 + 1);
      unint64_t v12 = v4 & 0xFFFFFFFF00000000;
      if (!v9) {
        uint64_t v11 = 0;
      }
      unint64_t v4 = v11 | v12;
      float v7 = v10 + 1;
      unint64_t v13 = HIDWORD(v5);
      BOOL v14 = (int)v5 < 1;
      if ((int)v5 < 1) {
        unint64_t v13 = 0;
      }
      unint64_t v15 = v6 + v13;
      uint64_t v16 = (v5 + 1);
      unint64_t v17 = v5 & 0xFFFFFFFF00000000;
      if (!v14) {
        uint64_t v16 = 0;
      }
      unint64_t v5 = v16 | v17;
      uint64_t v6 = v15 + 1;
    }
    while (v6 != 10);
  }
  *(_DWORD *)(a2 + 4) = *((_DWORD *)v2 + ((2 * v3) | 1u));
  float result = -*((float *)v2 + (2 * v3));
  *(float *)(a2 + 8) = result;
  *(_DWORD *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)a2 = 1065353216;
  return result;
}

uint64_t cva::SE2GroupStorage<float,cva::MatrixRef<float const,3u,3u,false>>::serialize(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 8);
  if (v1)
  {
    uint64_t v2 = *(void *)result;
    uint64_t v3 = *(void *)result + 4 * (3 * v1);
    unint64_t v4 = (unint64_t)(v1 - 3) << 32;
    do
    {
      float result = std::ostream::write();
      unint64_t v5 = HIDWORD(v4);
      if ((int)v4 < 2) {
        unint64_t v5 = 0;
      }
      uint64_t v6 = v2 + 4 * v5;
      uint64_t v7 = (v4 + 1);
      if ((int)v4 >= 2) {
        uint64_t v7 = 0;
      }
      unint64_t v4 = v7 | v4 & 0xFFFFFFFF00000000;
      uint64_t v2 = v6 + 4;
    }
    while (v6 + 4 != v3);
  }
  return result;
}

double cva::SE2GroupStorage<double,cva::MatrixRef<double const,3u,3u,false>>::SE2GroupStorage(void *a1, uint64_t a2)
{
  *a1 = a2;
  *(void *)&double result = 3;
  a1[1] = 3;
  return result;
}

{
  double result;

  *a1 = a2;
  *(void *)&double result = 3;
  a1[1] = 3;
  return result;
}

{
  double result;

  *a1 = a2;
  *(void *)&double result = 3;
  a1[1] = 3;
  return result;
}

{
  double result;

  *a1 = a2;
  *(void *)&double result = 3;
  a1[1] = 3;
  return result;
}

uint64_t cva::SE2GroupStorage<double,cva::MatrixRef<double const,3u,3u,false>>::R(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t cva::SE2GroupStorage<double,cva::MatrixRef<double const,3u,3u,false>>::T(uint64_t a1)
{
  return *(void *)a1
       - 8 * *(unsigned int *)(a1 + 12)
       + 8 * (*(_DWORD *)(a1 + 12) + 2 * *(_DWORD *)(a1 + 8));
}

uint64_t cva::SE2GroupStorage<double,cva::MatrixRef<double const,3u,3u,false>>::affine@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *(uint64_t **)result;
  int v4 = *(_DWORD *)(result + 8);
  uint64_t v3 = *(unsigned int *)(result + 12);
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  unint64_t v5 = &v2[-v3];
  uint64_t v6 = (v4 - 2);
  uint64_t v7 = *v2;
  if (v5 == (uint64_t *)a2)
  {
    uint64_t v12 = v2[1];
    uint64_t v13 = v6;
    BOOL v14 = &v2[v13];
    long long v15 = *((_OWORD *)v14 + 1);
    long long v16 = *(_OWORD *)&v14[v13 + 4];
    *(void *)a2 = v7;
    *(void *)(a2 + 8) = v12;
    *(_OWORD *)(a2 + 16) = v15;
    *(_OWORD *)(a2 + 32) = v16;
  }
  else
  {
    *(void *)a2 = v7;
    *(void *)(a2 + 8) = v2[1];
    uint64_t v8 = v6;
    BOOL v9 = &v2[v8];
    uint64_t v10 = v9[2];
    v9 += 2;
    *(void *)(a2 + 16) = v10;
    *(void *)(a2 + 24) = v9[1];
    uint64_t v11 = &v9[v8];
    *(void *)(a2 + 32) = v11[2];
    *(void *)(a2 + 40) = v11[3];
  }
  return result;
}

double cva::SE2GroupStorage<double,cva::MatrixRef<double const,3u,3u,false>>::transform@<D0>(uint64_t a1@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v5 = *(unsigned int *)(a1 + 8);
  uint64_t v4 = *(unsigned int *)(a1 + 12);
  uint64_t v6 = *(void *)a1 - 8 * v4;
  v10[0] = *(void *)a1;
  v10[1] = v5 | (v4 << 32);
  v11[0] = (double *)v10;
  v11[1] = a2;
  uint64_t v7 = (double *)(v6 + 8 * (v4 + 2 * v5));
  double v12 = 0.0;
  double v13 = 0.0;
  sub_2153D4ABC(&v12, v11);
  *a3 = 0.0;
  a3[1] = 0.0;
  double result = v12 + *v7;
  if ((double *)v6 == a3)
  {
    double v9 = v13 + v7[1];
    *a3 = result;
    a3[1] = v9;
  }
  else
  {
    *a3 = result;
    double result = v13 + v7[1];
    a3[1] = result;
  }
  return result;
}

float64x2_t cva::SE2GroupStorage<double,cva::MatrixRef<double const,3u,3u,false>>::inverseTransform@<Q0>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, float64x2_t *a3@<X8>)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  uint64_t v5 = *((unsigned int *)a1 + 2);
  uint64_t v4 = *((unsigned int *)a1 + 3);
  uint64_t v6 = *a1 - 8 * v4;
  uint64_t v13 = *a1;
  uint64_t v14 = v5 | (v4 << 32);
  long long v15 = &v13;
  v16[0] = (uint64_t *)&v15;
  v16[1] = a2;
  v10[0] = v13;
  v10[1] = v14;
  uint64_t v11 = v10;
  uint64_t v7 = (v4 + 2 * v5);
  v9[0] = v6 + 8 * v7;
  v9[1] = v5 | (v7 << 32);
  v12[0] = (uint64_t *)&v11;
  v12[1] = v9;
  float64x2_t v17 = 0uLL;
  sub_2153D4C54(v17.f64, v16);
  float64x2_t v18 = 0uLL;
  sub_2153D4CE8((uint64_t)&v18, v12);
  float64x2_t result = vsubq_f64(v17, v18);
  *a3 = result;
  return result;
}

double cva::SE2GroupStorage<double,cva::MatrixRef<double const,3u,3u,false>>::transformJacobian@<D0>(double *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2 = *(void *)a1;
  double result = -a1[1];
  *(double *)a2 = result;
  *(void *)(a2 + 8) = v2;
  *(void *)(a2 + 16) = 0x3FF0000000000000;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0x3FF0000000000000;
  return result;
}

void cva::SE2GroupStorage<double,cva::MatrixRef<double const,3u,3u,false>>::inverseTransformJacobian(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  double v4 = -*(double *)a2;
  *(void *)a3 = *(void *)(a2 + 8);
  *(double *)(a3 + 8) = v4;
  unint64_t v6 = a1[1];
  v25[0] = *a1;
  uint64_t v5 = (double *)v25[0];
  v25[1] = v6;
  uint64_t v26 = v25;
  v24[0] = a3;
  v24[1] = 2;
  v27[0] = (uint64_t *)&v26;
  v27[1] = v24;
  long long v28 = 0uLL;
  sub_2153D4CE8((uint64_t)&v28, v27);
  *(_OWORD *)a3 = v28;
  if (&v5[-HIDWORD(v6)] == (double *)a3)
  {
    unint64_t v15 = 0;
    *(double *)&long long v28 = -*v5;
    *((double *)&v28 + 1) = -v5[v6];
    double v29 = -v5[1];
    double v30 = -v5[(v6 + 1)];
    long long v16 = (uint64_t *)&v28;
    for (uint64_t i = 2; i != 6; uint64_t i = v21 + 1)
    {
      uint64_t v18 = *v16++;
      *(void *)(a3 + 8 * i) = v18;
      unint64_t v19 = HIDWORD(v15);
      BOOL v20 = (int)v15 < 1;
      if ((int)v15 < 1) {
        unint64_t v19 = 0;
      }
      unint64_t v21 = i + v19;
      uint64_t v22 = (v15 + 1);
      unint64_t v23 = v15 & 0xFFFFFFFF00000000;
      if (!v20) {
        uint64_t v22 = 0;
      }
      unint64_t v15 = v22 | v23;
    }
  }
  else
  {
    unint64_t v7 = 0;
    unint64_t v8 = 0;
    for (uint64_t j = 2; j != 6; uint64_t j = v12 + 1)
    {
      *(double *)(a3 + 8 * j) = -v5[(HIDWORD(v8) + v6 * v8)];
      if ((int)v8 >= 1) {
        unint64_t v8 = (v8 & 0xFFFFFFFF00000000) + 0x100000000;
      }
      else {
        unint64_t v8 = (v8 + 1) | v8 & 0xFFFFFFFF00000000;
      }
      unint64_t v10 = HIDWORD(v7);
      BOOL v11 = (int)v7 < 1;
      if ((int)v7 < 1) {
        unint64_t v10 = 0;
      }
      unint64_t v12 = j + v10;
      uint64_t v13 = (v7 + 1);
      unint64_t v14 = v7 & 0xFFFFFFFF00000000;
      if (!v11) {
        uint64_t v13 = 0;
      }
      unint64_t v7 = v13 | v14;
    }
  }
}

double cva::SE2GroupStorage<double,cva::MatrixRef<double const,3u,3u,false>>::log@<D0>(long double **a1@<X0>, double *a2@<X8>)
{
  double v4 = *a1;
  double v5 = atan2((*a1)[1], **a1);
  double v6 = v5 * v5;
  if (v5 * v5 >= 0.0000002635)
  {
    __double2 v9 = __sincos_stret(v5);
    double v7 = 1.0 / v5 * v9.__sinval;
    double v8 = 1.0 / v5 * (1.0 - v9.__cosval);
  }
  else
  {
    double v7 = 1.0 - v6 * (v6 / -120.0 + 0.166666667);
    double v8 = v5 * (v6 / -24.0 + 0.5);
  }
  double v10 = 1.0 / (v8 * v8 + v7 * v7);
  int v11 = *((_DWORD *)a1 + 2);
  double v12 = v4[2 * v11];
  double v13 = v4[(2 * v11) | 1u];
  *a2 = v5;
  a2[1] = v10 * (v8 * v13 + v7 * v12);
  double result = v10 * (v7 * v13 - v8 * v12);
  a2[2] = result;
  return result;
}

void cva::SE2GroupStorage<double,cva::MatrixRef<double const,3u,3u,false>>::logJacobian(long double **a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 24) = 0u;
  double v4 = (void *)(a2 + 24);
  *(void *)(a2 + 88) = 0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 72) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  double v5 = *a1;
  double v6 = atan2((*a1)[1], **a1);
  double v7 = v6 * v6;
  if (v6 * v6 >= 0.0000002635)
  {
    __double2 v13 = __sincos_stret(v6);
    double v10 = 1.0 / v6 * v13.__sinval;
    double v12 = 1.0 / v6 * (1.0 - v13.__cosval);
    double v8 = 1.0 / v6 * v12;
    double v11 = 1.0 / v6 * (1.0 - v10);
  }
  else
  {
    double v8 = 0.5 - v7 * (v7 / -720.0 + 0.0416666667);
    double v9 = 0.166666667 - v7 * (v7 / -5040.0 + 0.00833333333);
    double v10 = 1.0 - v7 * v9;
    double v11 = v6 * v9;
    double v12 = v6 * v8;
  }
  double v14 = v12 * v12 + v10 * v10;
  double v15 = 1.0 / v14;
  *(double *)a2 = v6;
  int v16 = *((_DWORD *)a1 + 2);
  double v17 = v5[2 * v16];
  double v18 = v5[(2 * v16) | 1u];
  double v19 = 1.0 / v14 * (v12 * v18 + v10 * v17);
  double v20 = 1.0 / v14 * (v10 * v18 - v12 * v17);
  *(double *)(a2 + 8) = v19;
  *(double *)(a2 + 16) = v20;
  if (fabs(v14) >= 0.00001)
  {
    double v21 = v10 * v15;
    double v22 = v15 * -v12;
    double v23 = v12 * v15;
    *(double *)double v40 = v21;
    *(double *)&v40[1] = v22;
    *(double *)&v40[2] = v23;
    *(double *)&v40[3] = v21;
    double v24 = v11 * v19 + v8 * v20;
    double v25 = v11 * v20 - v8 * v19;
    *(double *)double v39 = v24;
    *(double *)&v39[1] = v25;
    *(void *)(a2 + 24) = 0x3FF0000000000000;
    int v37 = v40;
    v38[0] = &v37;
    v38[1] = v39;
    if (v39 == v4)
    {
      double v41 = 0.0;
      double v42 = 0.0;
      sub_2153D51F0(&v41, (uint64_t)v38);
      double v26 = v41;
      double v27 = v42;
    }
    else
    {
      double v26 = 0.0 - v21 * v24 - v23 * v25;
      double v27 = 0.0 - v22 * v24 - v21 * v25;
    }
    *(double *)(a2 + 32) = v26;
    *(double *)(a2 + 40) = v27;
    *(void *)(a2 + 48) = 0;
    unint64_t v28 = 0x100000000;
    double v29 = v40;
    uint64_t v30 = 4;
    *(void *)(a2 + 72) = 0;
    do
    {
      uint64_t v31 = *v29++;
      v4[v30] = v31;
      unint64_t v32 = HIDWORD(v28);
      BOOL v33 = (int)v28 < 1;
      if ((int)v28 < 1) {
        unint64_t v32 = 0;
      }
      unint64_t v34 = v30 + v32;
      uint64_t v35 = (v28 + 1);
      unint64_t v36 = v28 & 0xFFFFFFFF00000000;
      if (!v33) {
        uint64_t v35 = 0;
      }
      unint64_t v28 = v35 | v36;
      uint64_t v30 = v34 + 1;
    }
    while (v30 != 10);
  }
}

double cva::SE2GroupStorage<double,cva::MatrixRef<double const,3u,3u,false>>::inverse@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)a2 = xmmword_215446208;
  *(_OWORD *)(a2 + 16) = unk_215446218;
  *(void *)(a2 + 64) = 0x3FF0000000000000;
  *(_OWORD *)(a2 + 32) = xmmword_215446228;
  *(_OWORD *)(a2 + 48) = unk_215446238;
  uint64_t v2 = *(double **)a1;
  uint64_t v3 = *(unsigned int *)(a1 + 8);
  double v4 = *(double *)(*(void *)a1 + 8 * v3);
  double v5 = **(double **)a1;
  double v6 = *(double *)(*(void *)a1 + 8);
  *(double *)a2 = v5;
  *(double *)(a2 + 8) = v4;
  double v7 = v2[(v3 + 1)];
  *(double *)(a2 + 24) = v6;
  *(double *)(a2 + 32) = v7;
  double v8 = v2[(2 * v3)];
  double v9 = v2[(2 * v3) | 1u];
  double result = -(v7 * v9) - v4 * v8;
  *(double *)(a2 + 48) = -(v6 * v9) - v5 * v8;
  *(double *)(a2 + 56) = result;
  return result;
}

double cva::SE2GroupStorage<double,cva::MatrixRef<double const,3u,3u,false>>::adjoint@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 64) = 0;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  uint64_t v2 = *(_OWORD **)a1;
  int v3 = *(_DWORD *)(a1 + 8);
  if (*(void *)a1 - 8 * *(unsigned int *)(a1 + 12) == a2)
  {
    long long v20 = *(_OWORD *)((char *)v2 + 8 * (v3 - 2) + 16);
    v32[0] = *v2;
    v32[1] = v20;
    unint64_t v21 = 0x100000000;
    double v22 = (uint64_t *)v32;
    for (uint64_t i = 4; i != 10; uint64_t i = v28 + 1)
    {
      uint64_t v24 = *v22++;
      *(void *)(a2 + 8 * i) = v24;
      unint64_t v25 = HIDWORD(v21);
      BOOL v27 = __OFSUB__(v21, 1);
      BOOL v26 = (int)v21 - 1 < 0;
      if ((int)v21 < 1) {
        unint64_t v25 = 0;
      }
      unint64_t v28 = i + v25;
      uint64_t v29 = (v21 + 1);
      unint64_t v30 = v21 & 0xFFFFFFFF00000000;
      if (v26 == v27) {
        uint64_t v29 = 0;
      }
      unint64_t v21 = v29 | v30;
    }
  }
  else
  {
    unint64_t v4 = (unint64_t)(v3 - 2) << 32;
    unint64_t v5 = 0x100000000;
    uint64_t v6 = 4;
    double v7 = *(void **)a1;
    do
    {
      *(void *)(a2 + 8 * v6) = *v7;
      unint64_t v8 = HIDWORD(v4);
      BOOL v10 = __OFSUB__(v4, 1);
      BOOL v9 = (int)v4 - 1 < 0;
      if ((int)v4 < 1) {
        unint64_t v8 = 0;
      }
      double v11 = &v7[v8];
      uint64_t v12 = (v4 + 1);
      unint64_t v13 = v4 & 0xFFFFFFFF00000000;
      if (v9 == v10) {
        uint64_t v12 = 0;
      }
      unint64_t v4 = v12 | v13;
      double v7 = v11 + 1;
      unint64_t v14 = HIDWORD(v5);
      BOOL v16 = __OFSUB__(v5, 1);
      BOOL v15 = (int)v5 - 1 < 0;
      if ((int)v5 < 1) {
        unint64_t v14 = 0;
      }
      unint64_t v17 = v6 + v14;
      uint64_t v18 = (v5 + 1);
      unint64_t v19 = v5 & 0xFFFFFFFF00000000;
      if (v15 == v16) {
        uint64_t v18 = 0;
      }
      unint64_t v5 = v18 | v19;
      uint64_t v6 = v17 + 1;
    }
    while (v6 != 10);
  }
  *(void *)(a2 + 8) = *((void *)v2 + ((2 * v3) | 1u));
  double result = -*((double *)v2 + (2 * v3));
  *(double *)(a2 + 16) = result;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)a2 = 0x3FF0000000000000;
  return result;
}

uint64_t cva::SE2GroupStorage<double,cva::MatrixRef<double const,3u,3u,false>>::serialize(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 8);
  if (v1)
  {
    uint64_t v2 = *(void *)result;
    uint64_t v3 = *(void *)result + 8 * (3 * v1);
    unint64_t v4 = (unint64_t)(v1 - 3) << 32;
    do
    {
      double result = std::ostream::write();
      unint64_t v5 = HIDWORD(v4);
      if ((int)v4 < 2) {
        unint64_t v5 = 0;
      }
      uint64_t v6 = v2 + 8 * v5;
      uint64_t v7 = (v4 + 1);
      if ((int)v4 >= 2) {
        uint64_t v7 = 0;
      }
      unint64_t v4 = v7 | v4 & 0xFFFFFFFF00000000;
      uint64_t v2 = v6 + 8;
    }
    while (v6 + 8 != v3);
  }
  return result;
}

float cva::SE2AlgebraStorage<float,cva::Matrix<float,3u,1u,false>>::SE2AlgebraStorage(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  *(_DWORD *)(a1 + 8) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)a1 = *a2;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)a3;
  float result = *(float *)(a3 + 4);
  *(float *)(a1 + 8) = result;
  return result;
}

{
  float result;

  *(_DWORD *)(a1 + 8) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)a1 = *a2;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)a3;
  float result = *(float *)(a3 + 4);
  *(float *)(a1 + 8) = result;
  return result;
}

uint64_t cva::SE2AlgebraStorage<float,cva::Matrix<float,3u,1u,false>>::T(uint64_t a1)
{
  return a1 + 4;
}

{
  return a1 + 4;
}

double cva::SE2AlgebraStorage<float,cva::Matrix<float,3u,1u,false>>::adjoint@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  float v2 = *(float *)a1;
  float v3 = -*(float *)(a1 + 4);
  *(_DWORD *)a2 = *(_DWORD *)(a1 + 8);
  *(float *)(a2 + 4) = v3;
  *(float *)(a2 + 16) = v2;
  *(float *)(a2 + 24) = -v2;
  double result = 0.0;
  *(void *)(a2 + 28) = 0;
  *(_DWORD *)(a2 + 20) = 0;
  *(void *)(a2 + 8) = 0;
  return result;
}

double cva::SE2AlgebraStorage<float,cva::Matrix<float,3u,1u,false>>::hat@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_DWORD *)(a2 + 32) = 0;
  float v2 = *(float *)a1;
  *(_DWORD *)(a2 + 4) = *(_DWORD *)a1;
  *(float *)(a2 + 12) = -v2;
  double result = *(double *)(a1 + 4);
  *(double *)(a2 + 24) = result;
  return result;
}

float cva::SE2AlgebraStorage<float,cva::Matrix<float,3u,1u,false>>::exp@<S0>(float *a1@<X0>, uint64_t a2@<X8>, float a3@<S0>)
{
  *(_DWORD *)(a2 + 32) = 1065353216;
  *(_OWORD *)a2 = xmmword_2154461C0;
  *(_OWORD *)(a2 + 16) = unk_2154461D0;
  float v5 = a1[1];
  float v6 = *a1 * a3;
  float v7 = a1[2];
  __float2 v8 = __sincosf_stret(v6);
  float v9 = v6 * v6;
  if ((float)(v6 * v6) >= 0.0061)
  {
    float v10 = (float)(1.0 / v6) * v8.__sinval;
    float v11 = (float)(1.0 / v6) * (float)(1.0 - v8.__cosval);
  }
  else
  {
    float v10 = 1.0 - (float)(v9 * (float)((float)(v9 / -120.0) + 0.16667));
    float v11 = v6 * (float)((float)(v9 / -24.0) + 0.5);
  }
  *(float *)a2 = v8.__cosval;
  *(float *)(a2 + 4) = v8.__sinval;
  *(float *)(a2 + 12) = -v8.__sinval;
  *(float *)(a2 + 16) = v8.__cosval;
  float result = (float)(v10 * (float)(v5 * a3)) - (float)(v11 * (float)(v7 * a3));
  *(float *)(a2 + 24) = result;
  *(float *)(a2 + 28) = (float)((float)(v7 * a3) * v10) + (float)(v11 * (float)(v5 * a3));
  return result;
}

float cva::SE2AlgebraStorage<float,cva::Matrix<float,3u,1u,false>>::expJacobian@<S0>(float *a1@<X0>, uint64_t a2@<X8>)
{
  *(_DWORD *)(a2 + 32) = 1065353216;
  *(_OWORD *)a2 = xmmword_2154461C0;
  *(_OWORD *)(a2 + 16) = unk_2154461D0;
  float v4 = *a1;
  __float2 v5 = __sincosf_stret(*a1);
  float v6 = v4 * v4;
  if ((float)(v4 * v4) >= 0.0061)
  {
    float v9 = (float)(1.0 / v4) * v5.__sinval;
    float v11 = (float)(1.0 / v4) * (float)(1.0 - v5.__cosval);
    float v7 = (float)(1.0 / v4) * v11;
    float v10 = (float)(1.0 / v4) * (float)(1.0 - v9);
  }
  else
  {
    float v7 = 0.5 - (float)(v6 * (float)((float)(v6 / -720.0) + 0.041667));
    float v8 = 0.16667 - (float)(v6 * (float)((float)(v6 / -5040.0) + 0.0083333));
    float v9 = 1.0 - (float)(v6 * v8);
    float v10 = v4 * v8;
    float v11 = v4 * v7;
  }
  *(float *)a2 = v5.__cosval;
  *(float *)(a2 + 4) = v5.__sinval;
  *(float *)(a2 + 12) = -v5.__sinval;
  *(float *)(a2 + 16) = v5.__cosval;
  float v12 = a1[1];
  float v13 = a1[2];
  *(float *)(a2 + 24) = (float)(v9 * v12) - (float)(v11 * v13);
  *(float *)(a2 + 28) = (float)(v9 * v13) + (float)(v11 * v12);
  *(_DWORD *)(a2 + 36) = 1065353216;
  float v14 = (float)(v10 * v12) + (float)(v7 * v13);
  float result = (float)(v10 * v13) - (float)(v7 * v12);
  *(float *)(a2 + 40) = v14;
  *(float *)(a2 + 44) = result;
  *(_DWORD *)(a2 + 48) = 0;
  *(float *)(a2 + 52) = v9;
  *(float *)(a2 + 56) = v11;
  *(_DWORD *)(a2 + 60) = 0;
  *(float *)(a2 + 64) = -v11;
  *(float *)(a2 + 68) = v9;
  return result;
}

float *cva::SE2AlgebraStorage<float,cva::Matrix<float,3u,1u,false>>::enforce(float *result)
{
  float v1 = *result;
  if (*result <= 0.0)
  {
    if (v1 > -3.1416) {
      return result;
    }
    do
      float v1 = v1 + 3.1416;
    while (v1 <= -3.1416);
  }
  else
  {
    if (v1 < 3.1416) {
      return result;
    }
    do
      float v1 = v1 + -3.1416;
    while (v1 >= 3.1416);
  }
  *float result = v1;
  return result;
}

uint64_t cva::SE2AlgebraStorage<float,cva::Matrix<float,3u,1u,false>>::serialize()
{
  return std::ostream::write();
}

uint64_t cva::SE2AlgebraStorage<float,cva::Matrix<float,3u,1u,false>>::deserialize(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x270F98678](a2, a1, 12);
}

double cva::SE2AlgebraStorage<double,cva::Matrix<double,3u,1u,false>>::SE2AlgebraStorage(double *a1, double *a2, double *a3)
{
  *a1 = 0.0;
  a1[1] = 0.0;
  a1[2] = 0.0;
  *a1 = *a2;
  a1[1] = *a3;
  double result = a3[1];
  a1[2] = result;
  return result;
}

{
  double result;

  *a1 = 0.0;
  a1[1] = 0.0;
  a1[2] = 0.0;
  *a1 = *a2;
  a1[1] = *a3;
  double result = a3[1];
  a1[2] = result;
  return result;
}

uint64_t cva::SE2AlgebraStorage<double,cva::Matrix<double,3u,1u,false>>::T(uint64_t a1)
{
  return a1 + 8;
}

{
  return a1 + 8;
}

double cva::SE2AlgebraStorage<double,cva::Matrix<double,3u,1u,false>>::adjoint@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  double v2 = *(double *)a1;
  double v3 = -*(double *)(a1 + 8);
  *(void *)a2 = *(void *)(a1 + 16);
  *(double *)(a2 + 8) = v3;
  *(double *)(a2 + 32) = v2;
  double result = -v2;
  *(double *)(a2 + 48) = -v2;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 64) = 0;
  return result;
}

double cva::SE2AlgebraStorage<double,cva::Matrix<double,3u,1u,false>>::hat@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  double result = 0.0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(void *)(a2 + 64) = 0;
  double v3 = *(double *)a1;
  *(void *)(a2 + 8) = *(void *)a1;
  *(double *)(a2 + 24) = -v3;
  long long v4 = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = v4;
  return result;
}

double cva::SE2AlgebraStorage<double,cva::Matrix<double,3u,1u,false>>::exp@<D0>(double *a1@<X0>, uint64_t a2@<X8>, double a3@<D0>)
{
  *(void *)(a2 + 64) = 0x3FF0000000000000;
  *(_OWORD *)a2 = xmmword_215446208;
  *(_OWORD *)(a2 + 16) = unk_215446218;
  *(_OWORD *)(a2 + 32) = xmmword_215446228;
  *(_OWORD *)(a2 + 48) = unk_215446238;
  double v5 = a1[1];
  double v6 = *a1 * a3;
  double v7 = a1[2];
  __double2 v8 = __sincos_stret(v6);
  double v9 = v6 * v6;
  if (v6 * v6 >= 0.0000002635)
  {
    double v10 = 1.0 / v6 * v8.__sinval;
    double v11 = 1.0 / v6 * (1.0 - v8.__cosval);
  }
  else
  {
    double v10 = 1.0 - v9 * (v9 / -120.0 + 0.166666667);
    double v11 = v6 * (v9 / -24.0 + 0.5);
  }
  *(double *)a2 = v8.__cosval;
  *(double *)(a2 + 8) = v8.__sinval;
  *(double *)(a2 + 24) = -v8.__sinval;
  *(double *)(a2 + 32) = v8.__cosval;
  double result = v10 * (v5 * a3) - v11 * (v7 * a3);
  *(double *)(a2 + 48) = result;
  *(double *)(a2 + 56) = v7 * a3 * v10 + v11 * (v5 * a3);
  return result;
}

double cva::SE2AlgebraStorage<double,cva::Matrix<double,3u,1u,false>>::expJacobian@<D0>(double *a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 64) = 0x3FF0000000000000;
  *(_OWORD *)a2 = xmmword_215446208;
  *(_OWORD *)(a2 + 16) = unk_215446218;
  *(_OWORD *)(a2 + 32) = xmmword_215446228;
  *(_OWORD *)(a2 + 48) = unk_215446238;
  double v4 = *a1;
  __double2 v5 = __sincos_stret(*a1);
  double v6 = v4 * v4;
  if (v4 * v4 >= 0.0000002635)
  {
    double v9 = 1.0 / v4 * v5.__sinval;
    double v11 = 1.0 / v4 * (1.0 - v5.__cosval);
    double v7 = 1.0 / v4 * v11;
    double v10 = 1.0 / v4 * (1.0 - v9);
  }
  else
  {
    double v7 = 0.5 - v6 * (v6 / -720.0 + 0.0416666667);
    double v8 = 0.166666667 - v6 * (v6 / -5040.0 + 0.00833333333);
    double v9 = 1.0 - v6 * v8;
    double v10 = v4 * v8;
    double v11 = v4 * v7;
  }
  *(double *)a2 = v5.__cosval;
  *(double *)(a2 + 8) = v5.__sinval;
  *(double *)(a2 + 24) = -v5.__sinval;
  *(double *)(a2 + 32) = v5.__cosval;
  double v12 = a1[1];
  double v13 = a1[2];
  *(double *)(a2 + 48) = v9 * v12 - v11 * v13;
  *(double *)(a2 + 56) = v9 * v13 + v11 * v12;
  *(void *)(a2 + 72) = 0x3FF0000000000000;
  double v14 = v10 * v12 + v7 * v13;
  double result = v10 * v13 - v7 * v12;
  *(double *)(a2 + 80) = v14;
  *(double *)(a2 + 88) = result;
  *(void *)(a2 + 96) = 0;
  *(double *)(a2 + 104) = v9;
  *(double *)(a2 + 112) = v11;
  *(void *)(a2 + 120) = 0;
  *(double *)(a2 + 128) = -v11;
  *(double *)(a2 + 136) = v9;
  return result;
}

double *cva::SE2AlgebraStorage<double,cva::Matrix<double,3u,1u,false>>::enforce(double *result)
{
  double v1 = *result;
  if (*result <= 0.0)
  {
    if (v1 > -3.14159265) {
      return result;
    }
    do
      double v1 = v1 + 3.14159265;
    while (v1 <= -3.14159265);
  }
  else
  {
    if (v1 < 3.14159265) {
      return result;
    }
    do
      double v1 = v1 + -3.14159265;
    while (v1 >= 3.14159265);
  }
  *double result = v1;
  return result;
}

uint64_t cva::SE2AlgebraStorage<double,cva::Matrix<double,3u,1u,false>>::serialize()
{
  return std::ostream::write();
}

uint64_t cva::SE2AlgebraStorage<double,cva::Matrix<double,3u,1u,false>>::deserialize(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x270F98678](a2, a1, 24);
}

uint64_t cva::SE2AlgebraStorage<float,cva::MatrixRef<float const,3u,1u,false>>::R(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t cva::SE2AlgebraStorage<float,cva::MatrixRef<float const,3u,1u,false>>::T(uint64_t a1)
{
  return *(void *)a1 - 4 * *(unsigned int *)(a1 + 12) + 4 * (*(_DWORD *)(a1 + 12) + 1);
}

double cva::SE2AlgebraStorage<float,cva::MatrixRef<float const,3u,1u,false>>::adjoint@<D0>(float **a1@<X0>, uint64_t a2@<X8>)
{
  float v2 = **a1;
  float v3 = -(*a1)[1];
  *(float *)a2 = (*a1)[2];
  *(float *)(a2 + 4) = v3;
  *(float *)(a2 + 16) = v2;
  *(float *)(a2 + 24) = -v2;
  double result = 0.0;
  *(void *)(a2 + 28) = 0;
  *(_DWORD *)(a2 + 20) = 0;
  *(void *)(a2 + 8) = 0;
  return result;
}

double cva::SE2AlgebraStorage<float,cva::MatrixRef<float const,3u,1u,false>>::hat@<D0>(float **a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_DWORD *)(a2 + 32) = 0;
  float v2 = *a1;
  float v3 = **a1;
  *(float *)(a2 + 4) = v3;
  *(float *)(a2 + 12) = -v3;
  double result = *(double *)(v2 + 1);
  *(double *)(a2 + 24) = result;
  return result;
}

float cva::SE2AlgebraStorage<float,cva::MatrixRef<float const,3u,1u,false>>::exp@<S0>(uint64_t a1@<X0>, uint64_t a2@<X8>, float a3@<S0>)
{
  *(_DWORD *)(a2 + 32) = 1065353216;
  *(_OWORD *)a2 = xmmword_2154461C0;
  *(_OWORD *)(a2 + 16) = unk_2154461D0;
  float v5 = *(float *)(*(void *)a1 + 4);
  float v6 = **(float **)a1 * a3;
  float v7 = *(float *)(*(void *)a1 + 8);
  __float2 v8 = __sincosf_stret(v6);
  float v9 = v6 * v6;
  if ((float)(v6 * v6) >= 0.0061)
  {
    float v10 = (float)(1.0 / v6) * v8.__sinval;
    float v11 = (float)(1.0 / v6) * (float)(1.0 - v8.__cosval);
  }
  else
  {
    float v10 = 1.0 - (float)(v9 * (float)((float)(v9 / -120.0) + 0.16667));
    float v11 = v6 * (float)((float)(v9 / -24.0) + 0.5);
  }
  *(float *)a2 = v8.__cosval;
  *(float *)(a2 + 4) = v8.__sinval;
  *(float *)(a2 + 12) = -v8.__sinval;
  *(float *)(a2 + 16) = v8.__cosval;
  float result = (float)(v10 * (float)(v5 * a3)) - (float)(v11 * (float)(v7 * a3));
  *(float *)(a2 + 24) = result;
  *(float *)(a2 + 28) = (float)(v10 * (float)(v7 * a3)) + (float)(v11 * (float)(v5 * a3));
  return result;
}

float cva::SE2AlgebraStorage<float,cva::MatrixRef<float const,3u,1u,false>>::expJacobian@<S0>(float **a1@<X0>, uint64_t a2@<X8>)
{
  *(_DWORD *)(a2 + 32) = 1065353216;
  *(_OWORD *)a2 = xmmword_2154461C0;
  *(_OWORD *)(a2 + 16) = unk_2154461D0;
  float v3 = *a1;
  float v4 = **a1;
  __float2 v5 = __sincosf_stret(v4);
  float v6 = v4 * v4;
  if ((float)(v4 * v4) >= 0.0061)
  {
    float v9 = (float)(1.0 / v4) * v5.__sinval;
    float v11 = (float)(1.0 / v4) * (float)(1.0 - v5.__cosval);
    float v7 = (float)(1.0 / v4) * v11;
    float v10 = (float)(1.0 / v4) * (float)(1.0 - v9);
  }
  else
  {
    float v7 = 0.5 - (float)(v6 * (float)((float)(v6 / -720.0) + 0.041667));
    float v8 = 0.16667 - (float)(v6 * (float)((float)(v6 / -5040.0) + 0.0083333));
    float v9 = 1.0 - (float)(v6 * v8);
    float v10 = v4 * v8;
    float v11 = v4 * v7;
  }
  *(float *)a2 = v5.__cosval;
  *(float *)(a2 + 4) = v5.__sinval;
  *(float *)(a2 + 12) = -v5.__sinval;
  *(float *)(a2 + 16) = v5.__cosval;
  float v12 = v3[1];
  float v13 = v3[2];
  *(float *)(a2 + 24) = (float)(v9 * v12) - (float)(v11 * v13);
  *(float *)(a2 + 28) = (float)(v9 * v13) + (float)(v11 * v12);
  *(_DWORD *)(a2 + 36) = 1065353216;
  float v14 = (float)(v10 * v12) + (float)(v7 * v13);
  float result = (float)(v10 * v13) - (float)(v7 * v12);
  *(float *)(a2 + 40) = v14;
  *(float *)(a2 + 44) = result;
  *(_DWORD *)(a2 + 48) = 0;
  *(float *)(a2 + 52) = v9;
  *(float *)(a2 + 56) = v11;
  *(_DWORD *)(a2 + 60) = 0;
  *(float *)(a2 + 64) = -v11;
  *(float *)(a2 + 68) = v9;
  return result;
}

uint64_t cva::SE2AlgebraStorage<float,cva::MatrixRef<float const,3u,1u,false>>::serialize()
{
  return std::ostream::write();
}

uint64_t cva::SE2AlgebraStorage<double,cva::MatrixRef<double const,3u,1u,false>>::R(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t cva::SE2AlgebraStorage<double,cva::MatrixRef<double const,3u,1u,false>>::T(uint64_t a1)
{
  return *(void *)a1 - 8 * *(unsigned int *)(a1 + 12) + 8 * (*(_DWORD *)(a1 + 12) + 1);
}

double cva::SE2AlgebraStorage<double,cva::MatrixRef<double const,3u,1u,false>>::adjoint@<D0>(double **a1@<X0>, uint64_t a2@<X8>)
{
  double v2 = **a1;
  double v3 = -(*a1)[1];
  *(double *)a2 = (*a1)[2];
  *(double *)(a2 + 8) = v3;
  *(double *)(a2 + 32) = v2;
  double result = -v2;
  *(double *)(a2 + 48) = -v2;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 64) = 0;
  return result;
}

double cva::SE2AlgebraStorage<double,cva::MatrixRef<double const,3u,1u,false>>::hat@<D0>(double **a1@<X0>, uint64_t a2@<X8>)
{
  double result = 0.0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(void *)(a2 + 64) = 0;
  double v3 = *a1;
  double v4 = **a1;
  *(double *)(a2 + 8) = v4;
  *(double *)(a2 + 24) = -v4;
  long long v5 = *(_OWORD *)(v3 + 1);
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = v5;
  return result;
}

double cva::SE2AlgebraStorage<double,cva::MatrixRef<double const,3u,1u,false>>::exp@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>, double a3@<D0>)
{
  *(void *)(a2 + 64) = 0x3FF0000000000000;
  *(_OWORD *)a2 = xmmword_215446208;
  *(_OWORD *)(a2 + 16) = unk_215446218;
  *(_OWORD *)(a2 + 32) = xmmword_215446228;
  *(_OWORD *)(a2 + 48) = unk_215446238;
  double v5 = *(double *)(*(void *)a1 + 8);
  double v6 = **(double **)a1 * a3;
  double v7 = *(double *)(*(void *)a1 + 16);
  __double2 v8 = __sincos_stret(v6);
  double v9 = v6 * v6;
  if (v6 * v6 >= 0.0000002635)
  {
    double v10 = 1.0 / v6 * v8.__sinval;
    double v11 = 1.0 / v6 * (1.0 - v8.__cosval);
  }
  else
  {
    double v10 = 1.0 - v9 * (v9 / -120.0 + 0.166666667);
    double v11 = v6 * (v9 / -24.0 + 0.5);
  }
  *(double *)a2 = v8.__cosval;
  *(double *)(a2 + 8) = v8.__sinval;
  *(double *)(a2 + 24) = -v8.__sinval;
  *(double *)(a2 + 32) = v8.__cosval;
  double result = v10 * (v5 * a3) - v11 * (v7 * a3);
  *(double *)(a2 + 48) = result;
  *(double *)(a2 + 56) = v10 * (v7 * a3) + v11 * (v5 * a3);
  return result;
}

double cva::SE2AlgebraStorage<double,cva::MatrixRef<double const,3u,1u,false>>::expJacobian@<D0>(double **a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 64) = 0x3FF0000000000000;
  *(_OWORD *)a2 = xmmword_215446208;
  *(_OWORD *)(a2 + 16) = unk_215446218;
  *(_OWORD *)(a2 + 32) = xmmword_215446228;
  *(_OWORD *)(a2 + 48) = unk_215446238;
  double v3 = *a1;
  double v4 = **a1;
  __double2 v5 = __sincos_stret(v4);
  double v6 = v4 * v4;
  if (v4 * v4 >= 0.0000002635)
  {
    double v9 = 1.0 / v4 * v5.__sinval;
    double v11 = 1.0 / v4 * (1.0 - v5.__cosval);
    double v7 = 1.0 / v4 * v11;
    double v10 = 1.0 / v4 * (1.0 - v9);
  }
  else
  {
    double v7 = 0.5 - v6 * (v6 / -720.0 + 0.0416666667);
    double v8 = 0.166666667 - v6 * (v6 / -5040.0 + 0.00833333333);
    double v9 = 1.0 - v6 * v8;
    double v10 = v4 * v8;
    double v11 = v4 * v7;
  }
  *(double *)a2 = v5.__cosval;
  *(double *)(a2 + 8) = v5.__sinval;
  *(double *)(a2 + 24) = -v5.__sinval;
  *(double *)(a2 + 32) = v5.__cosval;
  double v12 = v3[1];
  double v13 = v3[2];
  *(double *)(a2 + 48) = v9 * v12 - v11 * v13;
  *(double *)(a2 + 56) = v9 * v13 + v11 * v12;
  *(void *)(a2 + 72) = 0x3FF0000000000000;
  double v14 = v10 * v12 + v7 * v13;
  double result = v10 * v13 - v7 * v12;
  *(double *)(a2 + 80) = v14;
  *(double *)(a2 + 88) = result;
  *(void *)(a2 + 96) = 0;
  *(double *)(a2 + 104) = v9;
  *(double *)(a2 + 112) = v11;
  *(void *)(a2 + 120) = 0;
  *(double *)(a2 + 128) = -v11;
  *(double *)(a2 + 136) = v9;
  return result;
}

uint64_t cva::SE2AlgebraStorage<double,cva::MatrixRef<double const,3u,1u,false>>::serialize()
{
  return std::ostream::write();
}

double cva::SE3GroupStorage<float,cva::Matrix<float,4u,4u,false>>::SE3GroupStorage(_OWORD *a1)
{
  *a1 = xmmword_215446040;
  a1[1] = unk_215446050;
  double result = 0.0;
  a1[2] = xmmword_215446060;
  a1[3] = unk_215446070;
  return result;
}

{
  double result;

  *a1 = xmmword_215446040;
  a1[1] = unk_215446050;
  double result = 0.0;
  a1[2] = xmmword_215446060;
  a1[3] = unk_215446070;
  return result;
}

float cva::SE3GroupStorage<float,cva::Matrix<float,4u,4u,false>>::SE3GroupStorage(uint64_t a1, int *a2, uint64_t a3)
{
  uint64_t v3 = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  unint64_t v4 = 0x100000000;
  do
  {
    int v5 = *a2++;
    *(_DWORD *)(a1 + 4 * v3) = v5;
    unint64_t v6 = HIDWORD(v4);
    BOOL v7 = (int)v4 < 2;
    if ((int)v4 < 2) {
      unint64_t v6 = 0;
    }
    uint64_t v8 = v3 + v6;
    uint64_t v9 = (v4 + 1);
    unint64_t v10 = v4 & 0xFFFFFFFF00000000;
    if (!v7) {
      uint64_t v9 = 0;
    }
    unint64_t v4 = v9 | v10;
    uint64_t v3 = v8 + 1;
  }
  while (v3 != 12);
  *(_DWORD *)(a1 + 48) = *(_DWORD *)a3;
  *(_DWORD *)(a1 + 52) = *(_DWORD *)(a3 + 4);
  float result = *(float *)(a3 + 8);
  *(float *)(a1 + 56) = result;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 60) = 1065353216;
  return result;
}

{
  uint64_t v3;
  unint64_t v4;
  int v5;
  unint64_t v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  float result;

  uint64_t v3 = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  unint64_t v4 = 0x100000000;
  do
  {
    int v5 = *a2++;
    *(_DWORD *)(a1 + 4 * v3) = v5;
    unint64_t v6 = HIDWORD(v4);
    BOOL v7 = (int)v4 < 2;
    if ((int)v4 < 2) {
      unint64_t v6 = 0;
    }
    uint64_t v8 = v3 + v6;
    uint64_t v9 = (v4 + 1);
    unint64_t v10 = v4 & 0xFFFFFFFF00000000;
    if (!v7) {
      uint64_t v9 = 0;
    }
    unint64_t v4 = v9 | v10;
    uint64_t v3 = v8 + 1;
  }
  while (v3 != 12);
  *(_DWORD *)(a1 + 48) = *(_DWORD *)a3;
  *(_DWORD *)(a1 + 52) = *(_DWORD *)(a3 + 4);
  float result = *(float *)(a3 + 8);
  *(float *)(a1 + 56) = result;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 60) = 1065353216;
  return result;
}

uint64_t cva::SE3GroupStorage<float,cva::Matrix<float,4u,4u,false>>::T(uint64_t a1)
{
  return a1 + 48;
}

{
  return a1 + 48;
}

float32x4_t *cva::SE3GroupStorage<float,cva::Matrix<float,4u,4u,false>>::lplus(uint64_t a1, long long *a2)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  long long v20 = *a2;
  uint64_t v21 = *((void *)a2 + 2);
  v13[0] = &v20;
  v13[1] = 6;
  v14[0] = xmmword_215446040;
  v14[1] = unk_215446050;
  v14[2] = xmmword_215446060;
  _DWORD v14[3] = unk_215446070;
  float v3 = (float)((float)(*(float *)&v20 * *(float *)&v20) + (float)(*((float *)&v20 + 1) * *((float *)&v20 + 1)))
     + (float)(*((float *)&v20 + 2) * *((float *)&v20 + 2));
  if (v3 >= 0.0061)
  {
    float v8 = sqrtf(v3);
    __float2 v9 = __sincosf_stret(v8);
    float cosval = v9.__cosval;
    float v6 = v9.__sinval / v8;
    float v4 = (float)(1.0 / v3) * (float)(1.0 - v9.__cosval);
    float v5 = (float)(1.0 / v3) * (float)(1.0 - (float)(v9.__sinval / v8));
  }
  else
  {
    float v4 = 0.5 - (float)(v3 * (float)((float)(v3 / -720.0) + 0.041667));
    float v5 = 0.16667 - (float)(v3 * (float)((float)(v3 / -5040.0) + 0.0083333));
    float v6 = 1.0 - (float)(v3 * v5);
    float cosval = 1.0 - (float)(v3 * v4);
  }
  v16.f32[3] = v5;
  v16.f32[0] = cosval;
  *(uint64_t *)((char *)v16.i64 + 4) = __PAIR64__(LODWORD(v4), LODWORD(v6));
  sub_2153D78BC((uint64_t)v13, v16.f32, (float32x2_t *)v14);
  v15[0] = v14;
  v15[1] = a1;
  float32x4_t v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  float result = sub_2153D7A9C(&v16, (uint64_t)v15);
  long long v11 = v17;
  *(float32x4_t *)a1 = v16;
  *(_OWORD *)(a1 + 16) = v11;
  long long v12 = v19;
  *(_OWORD *)(a1 + 32) = v18;
  *(_OWORD *)(a1 + 48) = v12;
  return result;
}

uint64_t sub_2153D78BC(uint64_t result, float *a2, float32x2_t *a3)
{
  float v3 = *a2;
  float v4 = a2[1];
  float v5 = a2[2];
  float v6 = *(float **)result;
  float v7 = **(float **)result;
  float v8 = v5 * v7;
  float v9 = v5 * *(float *)(*(void *)result + 4);
  float v10 = v5 * *(float *)(*(void *)result + 8);
  a3->f32[0] = *a2 + (float)(v8 * v7);
  a3[2].f32[1] = v3 + (float)(v9 * v6[1]);
  a3[5].f32[0] = v3 + (float)(v10 * v6[2]);
  float v11 = v6[1];
  float v12 = v8 * v11;
  float v13 = v6[2];
  float v14 = v8 * v13;
  float v15 = v9 * v13;
  float v16 = v4 * *v6;
  float v17 = v4 * v11;
  float v18 = v4 * v13;
  a3[2].f32[0] = v12 - v18;
  a3[4].f32[0] = v17 + v14;
  a3[4].f32[1] = v15 - v16;
  a3->f32[1] = v12 + v18;
  a3[1].f32[0] = v14 - v17;
  a3[3].f32[0] = v15 + v16;
  unint64_t v37 = *(void *)(result + 8);
  long long v19 = &v6[-HIDWORD(v37)];
  long long v20 = (float32x2_t *)&v19[HIDWORD(v37) + 3];
  float v22 = v6[1];
  float v21 = v6[2];
  float v23 = v20->f32[1];
  float v24 = v20[1].f32[0];
  float v25 = (float)(v22 * v24) - (float)(v21 * v23);
  float v26 = (float)(v21 * v20->f32[0]) - (float)(*v6 * v24);
  *(float *)unint64_t v36 = v25;
  *(float *)&v36[4] = v26;
  float v27 = (float)(*v6 * v23) - (float)(v22 * v20->f32[0]);
  *(float *)&v36[8] = v27;
  float v29 = a2[2];
  float v28 = a2[3];
  if (v19 == (float *)a3 || &v6[-HIDWORD(v37)] == (float *)a3)
  {
    float v31 = v24 + (float)(v29 * v27);
    float32x2_t v32 = *(float32x2_t *)(v6 + 1);
    v33.i32[1] = v32.i32[1];
    v33.i32[0] = *(__int32 *)v6;
    v34.i32[0] = vdup_lane_s32(*(int32x2_t *)&v36[4], 1).u32[0];
    v34.f32[1] = v25;
    float32x2_t v35 = vadd_f32(vadd_f32(*v20, vmul_n_f32(*(float32x2_t *)v36, v29)), vmul_n_f32(vmla_f32(vmul_f32(*(float32x2_t *)&v36[4], vneg_f32((float32x2_t)vrev64_s32(v33))), v34, v32), v28));
    float v30 = (float)(v28 * vmlas_n_f32(-(float)(v32.f32[0] * v25), *v6, *(float *)&v36[4])) + v31;
    a3[6] = v35;
  }
  else
  {
    a3[6].f32[0] = (float)(v20->f32[0] + (float)(v25 * v29))
                 + (float)(v28 * (float)((float)(v6[1] * v27) - (float)(v6[2] * v26)));
    a3[6].f32[1] = (float)(v20->f32[1] + (float)(v26 * v29))
                 + (float)(v28 * (float)((float)(v6[2] * v25) - (float)(*v6 * v27)));
    float v30 = (float)(v20[1].f32[0] + (float)(v27 * v29))
        + (float)(v28 * (float)((float)(*v6 * v26) - (float)(v6[1] * v25)));
  }
  a3[7].f32[0] = v30;
  return result;
}

float32x4_t *sub_2153D7A9C(float32x4_t *result, uint64_t a2)
{
  double v2 = result;
  float v3 = *(float32x4_t **)a2;
  if (*(float32x4_t **)a2 == result || (float v4 = *(float **)(a2 + 8), v4 == (float *)result))
  {
    float32x4_t v9 = 0u;
    float32x4_t v10 = 0u;
    float32x4_t v7 = 0u;
    float32x4_t v8 = 0u;
    float result = (float32x4_t *)sub_2153D7A9C(&v7);
    float32x4_t v6 = v8;
    float32x4_t *v2 = v7;
    v2[1] = v6;
    float32x4_t v5 = v10;
    v2[2] = v9;
  }
  else
  {
    *float result = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32((float32x4_t)0, *v3, *v4), v3[1], v4[1]), v3[2], v4[2]), v3[3], v4[3]);
    result[1] = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32((float32x4_t)0, *v3, v4[4]), v3[1], v4[5]), v3[2], v4[6]), v3[3], v4[7]);
    result[2] = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32((float32x4_t)0, *v3, v4[8]), v3[1], v4[9]), v3[2], v4[10]), v3[3], v4[11]);
    float32x4_t v5 = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32((float32x4_t)0, *v3, v4[12]), v3[1], v4[13]), v3[2], v4[14]), v3[3], v4[15]);
  }
  v2[3] = v5;
  return result;
}

double cva::SE3AlgebraStorage<float,cva::MatrixRef<float const,6u,1u,false>>::SE3AlgebraStorage(void *a1, uint64_t a2)
{
  *a1 = a2;
  *(void *)&double result = 6;
  a1[1] = 6;
  return result;
}

{
  double result;

  *a1 = a2;
  *(void *)&double result = 6;
  a1[1] = 6;
  return result;
}

uint64_t cva::SE3AlgebraStorage<float,cva::MatrixRef<float const,6u,1u,false>>::exp@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)a2 = xmmword_215446040;
  *(_OWORD *)(a2 + 16) = unk_215446050;
  *(_OWORD *)(a2 + 32) = xmmword_215446060;
  *(_OWORD *)(a2 + 48) = unk_215446070;
  float v4 = (float)((float)(**(float **)a1 * **(float **)a1)
             + (float)(*(float *)(*(void *)a1 + 4) * *(float *)(*(void *)a1 + 4)))
     + (float)(*(float *)(*(void *)a1 + 8) * *(float *)(*(void *)a1 + 8));
  if (v4 >= 0.0061)
  {
    float v9 = sqrtf(v4);
    __float2 v10 = __sincosf_stret(v9);
    float cosval = v10.__cosval;
    float v7 = v10.__sinval / v9;
    float v5 = (float)(1.0 / v4) * (float)(1.0 - v10.__cosval);
    float v6 = (float)(1.0 / v4) * (float)(1.0 - (float)(v10.__sinval / v9));
  }
  else
  {
    float v5 = 0.5 - (float)(v4 * (float)((float)(v4 / -720.0) + 0.041667));
    float v6 = 0.16667 - (float)(v4 * (float)((float)(v4 / -5040.0) + 0.0083333));
    float v7 = 1.0 - (float)(v4 * v6);
    float cosval = 1.0 - (float)(v4 * v5);
  }
  v12[2] = v5;
  v12[3] = v6;
  v12[0] = cosval;
  v12[1] = v7;
  return sub_2153D78BC(a1, v12, (float32x2_t *)a2);
}

float32x4_t *cva::SE3GroupStorage<float,cva::Matrix<float,4u,4u,false>>::rplus(uint64_t a1, long long *a2)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  long long v20 = *a2;
  uint64_t v21 = *((void *)a2 + 2);
  v13[0] = &v20;
  v13[1] = 6;
  v14[0] = xmmword_215446040;
  v14[1] = unk_215446050;
  v14[2] = xmmword_215446060;
  _DWORD v14[3] = unk_215446070;
  float v3 = (float)((float)(*(float *)&v20 * *(float *)&v20) + (float)(*((float *)&v20 + 1) * *((float *)&v20 + 1)))
     + (float)(*((float *)&v20 + 2) * *((float *)&v20 + 2));
  if (v3 >= 0.0061)
  {
    float v8 = sqrtf(v3);
    __float2 v9 = __sincosf_stret(v8);
    float cosval = v9.__cosval;
    float v6 = v9.__sinval / v8;
    float v4 = (float)(1.0 / v3) * (float)(1.0 - v9.__cosval);
    float v5 = (float)(1.0 / v3) * (float)(1.0 - (float)(v9.__sinval / v8));
  }
  else
  {
    float v4 = 0.5 - (float)(v3 * (float)((float)(v3 / -720.0) + 0.041667));
    float v5 = 0.16667 - (float)(v3 * (float)((float)(v3 / -5040.0) + 0.0083333));
    float v6 = 1.0 - (float)(v3 * v5);
    float cosval = 1.0 - (float)(v3 * v4);
  }
  v16.f32[3] = v5;
  v16.f32[0] = cosval;
  *(uint64_t *)((char *)v16.i64 + 4) = __PAIR64__(LODWORD(v4), LODWORD(v6));
  sub_2153D78BC((uint64_t)v13, v16.f32, (float32x2_t *)v14);
  v15[0] = a1;
  v15[1] = v14;
  float32x4_t v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  double result = sub_2153D7A9C(&v16, (uint64_t)v15);
  long long v11 = v17;
  *(float32x4_t *)a1 = v16;
  *(_OWORD *)(a1 + 16) = v11;
  long long v12 = v19;
  *(_OWORD *)(a1 + 32) = v18;
  *(_OWORD *)(a1 + 48) = v12;
  return result;
}

float32x2_t cva::SE3GroupStorage<float,cva::Matrix<float,4u,4u,false>>::transform@<D0>(uint64_t a1@<X0>, float *a2@<X1>, uint64_t a3@<X8>)
{
  v6[0] = a1;
  v6[1] = 4;
  v7[0] = (float *)v6;
  v7[1] = a2;
  memset(v8, 0, 12);
  sub_2153CC420((float *)v8, v7);
  *(_DWORD *)(a3 + 8) = 0;
  *(void *)a3 = 0;
  if (a1 == a3) {
    a3 = a1;
  }
  *(float *)a3 = v8[0].f32[0] + *(float *)(a1 + 48);
  float32x2_t result = vadd_f32(*(float32x2_t *)((char *)v8 + 4), *(float32x2_t *)(a1 + 52));
  *(float32x2_t *)(a3 + 4) = result;
  return result;
}

float cva::SE3GroupStorage<float,cva::Matrix<float,4u,4u,false>>::inverseTransform@<S0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, float32x2_t *a3@<X8>)
{
  v9[0] = a1;
  v9[1] = 4;
  __float2 v10 = v9;
  v11[0] = (uint64_t *)&v10;
  v11[1] = a2;
  v6[0] = a1;
  v6[1] = 4;
  float v7 = v6;
  v5[0] = a1 + 48;
  v5[1] = 0xC00000004;
  v8[0] = (uint64_t *)&v7;
  v8[1] = v5;
  float v13 = 0.0;
  float32x2_t v12 = 0;
  sub_2153CC568((float *)&v12, v11);
  float v15 = 0.0;
  float32x2_t v14 = 0;
  sub_2153D7FB4((float *)&v14, v8);
  *a3 = vsub_f32(v12, v14);
  float result = v13 - v15;
  a3[1].f32[0] = v13 - v15;
  return result;
}

float *sub_2153D7FB4(float *result, uint64_t **a2)
{
  double v2 = result;
  float v3 = a2[1];
  float v4 = (float *)*v3;
  if ((float *)(*v3 - 4 * *((unsigned int *)v3 + 3)) == result)
  {
    int v9 = 0;
    uint64_t v8 = 0;
    float result = (float *)sub_2153D7FB4(&v8);
    *(void *)double v2 = v8;
    *((_DWORD *)v2 + 2) = v9;
  }
  else
  {
    uint64_t v5 = **a2;
    float v6 = *(float **)v5;
    uint64_t v7 = *(unsigned int *)(v5 + 8);
    *float result = (float)((float)((float)(v6[1] * v4[1]) + (float)(*v6 * *v4)) + 0.0) + (float)(v6[2] * v4[2]);
    result[1] = (float)((float)((float)(v6[v7 + 1] * v4[1]) + (float)(v6[v7] * *v4)) + 0.0)
              + (float)(v6[(v7 + 2)] * v4[2]);
    result[2] = (float)((float)((float)(v6[(2 * v7) + 1] * v4[1])
                              + (float)(v6[(2 * v7)] * *v4))
                      + 0.0)
              + (float)(v6[(2 * v7 + 2)] * v4[2]);
  }
  return result;
}

void cva::SE3GroupStorage<float,cva::Matrix<float,4u,4u,false>>::transformJacobian(float *a1@<X1>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 64) = 0;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  if (a1 == (float *)a2)
  {
    uint64_t v11 = 0;
    unint64_t v12 = 0;
    v30[0] = 0;
    float v14 = a1[1];
    float v13 = a1[2];
    float v15 = *a1;
    *(float *)&v30[1] = -v13;
    *(float *)&v30[2] = v14;
    *(float *)&v30[3] = v13;
    v30[4] = 0;
    *(float *)&v30[5] = -v15;
    *(float *)&v30[6] = -v14;
    *(float *)&v30[7] = v15;
    v30[8] = 0;
    float32x4_t v16 = (float *)v30;
    do
    {
      float v17 = *v16++;
      a1[v11] = v17;
      unint64_t v18 = HIDWORD(v12);
      BOOL v19 = (int)v12 < 2;
      if ((int)v12 < 2) {
        unint64_t v18 = 0;
      }
      uint64_t v20 = v11 + v18;
      uint64_t v21 = (v12 + 1);
      unint64_t v22 = v12 & 0xFFFFFFFF00000000;
      if (!v19) {
        uint64_t v21 = 0;
      }
      unint64_t v12 = v21 | v22;
      uint64_t v11 = v20 + 1;
    }
    while (v11 != 9);
  }
  else
  {
    uint64_t v2 = 0;
    unint64_t v3 = 0;
    unint64_t v4 = 0;
    do
    {
      float v10 = 0.0;
      if (HIDWORD(v4) != v4) {
        float v10 = a1[dword_215446130[(HIDWORD(v4) + 4 * v4)]]
      }
            * flt_215446100[(HIDWORD(v4) + 4 * v4)];
      *(float *)(a2 + 4 * v2) = v10;
      if ((int)v4 >= 2) {
        unint64_t v4 = (v4 & 0xFFFFFFFF00000000) + 0x100000000;
      }
      else {
        unint64_t v4 = (v4 + 1) | v4 & 0xFFFFFFFF00000000;
      }
      unint64_t v5 = HIDWORD(v3);
      BOOL v6 = (int)v3 < 2;
      if ((int)v3 < 2) {
        unint64_t v5 = 0;
      }
      uint64_t v7 = v2 + v5;
      uint64_t v8 = (v3 + 1);
      unint64_t v9 = v3 & 0xFFFFFFFF00000000;
      if (!v6) {
        uint64_t v8 = 0;
      }
      unint64_t v3 = v8 | v9;
      uint64_t v2 = v7 + 1;
    }
    while (v2 != 9);
  }
  unint64_t v23 = 0;
  for (uint64_t i = 9; i != 18; uint64_t i = v27 + 1)
  {
    *(_DWORD *)(a2 + 4 * i) = 0;
    unint64_t v25 = HIDWORD(v23);
    BOOL v26 = (int)v23 < 2;
    if ((int)v23 < 2) {
      unint64_t v25 = 0;
    }
    unint64_t v27 = i + v25;
    uint64_t v28 = (v23 + 1);
    unint64_t v29 = v23 & 0xFFFFFFFF00000000;
    if (!v26) {
      uint64_t v28 = 0;
    }
    unint64_t v23 = v28 | v29;
  }
  *(_DWORD *)(a2 + 36) = 1065353216;
  *(_DWORD *)(a2 + 52) = 1065353216;
  *(_DWORD *)(a2 + 68) = 1065353216;
}

uint64_t cva::SE3GroupStorage<float,cva::Matrix<float,4u,4u,false>>::inverseTransformJacobian@<X0>(float *a1@<X0>, float *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3 = 0;
  unint64_t v4 = 0;
  *(void *)(a3 + 64) = 0;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  float v5 = a1[1];
  float v6 = a1[2];
  float v7 = a1[4];
  float v8 = a1[5];
  float v9 = a1[6];
  float v10 = a1[8];
  float v11 = a1[9];
  float v12 = a1[10];
  float v14 = a2[1];
  float v13 = a2[2];
  *(float *)&unsigned int v15 = (float)(v5 * v13) - (float)(v6 * v14);
  *(float *)&unsigned int v16 = (float)(v8 * v13) - (float)(v9 * v14);
  *(float *)&unsigned int v17 = (float)(v11 * v13) - (float)(v12 * v14);
  *(float *)&unsigned int v18 = (float)(v6 * *a2) - (float)(*a1 * v13);
  float v19 = (float)(v9 * *a2) - (float)(v7 * v13);
  float v20 = (float)(v12 * *a2) - (float)(v10 * v13);
  float v21 = (float)(*a1 * v14) - (float)(v5 * *a2);
  float v22 = (float)(v7 * v14) - (float)(v8 * *a2);
  float v23 = (float)(v10 * v14) - (float)(v11 * *a2);
  unint64_t v33 = __PAIR64__(v16, v15);
  unint64_t v34 = __PAIR64__(v18, v17);
  float v35 = v19;
  float v36 = v20;
  float v37 = v21;
  float v38 = v22;
  float v39 = v23;
  float v24 = &v33;
  do
  {
    int v25 = *(_DWORD *)v24;
    float v24 = (unint64_t *)((char *)v24 + 4);
    *(_DWORD *)(a3 + 4 * v3) = v25;
    unint64_t v26 = HIDWORD(v4);
    BOOL v27 = (int)v4 < 2;
    if ((int)v4 < 2) {
      unint64_t v26 = 0;
    }
    uint64_t v28 = v3 + v26;
    uint64_t v29 = (v4 + 1);
    unint64_t v30 = v4 & 0xFFFFFFFF00000000;
    if (!v27) {
      uint64_t v29 = 0;
    }
    unint64_t v4 = v29 | v30;
    uint64_t v3 = v28 + 1;
  }
  while (v3 != 9);
  unint64_t v33 = (unint64_t)a1;
  unint64_t v34 = 4;
  v32[0] = a3 + 36;
  v32[1] = 0x900000003;
  return sub_2153D8350((uint64_t)v32, (uint64_t)&v33);
}

uint64_t sub_2153D8350(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(float **)result;
  uint64_t v3 = *(float **)a2;
  if (*(void *)a2 - 4 * *(unsigned int *)(a2 + 12) == *(void *)result - 4 * *(unsigned int *)(result + 12))
  {
    uint64_t v14 = *(unsigned int *)(a2 + 8);
    float v15 = v3[1];
    float v16 = -v3[v14];
    float v17 = v3[(2 * v14)];
    v30[0] = -*v3;
    v30[1] = v16;
    v30[2] = -v17;
    v30[3] = -v15;
    float v18 = -v3[(2 * v14) | 1];
    v30[4] = -v3[(v14 + 1)];
    v30[5] = v18;
    float v19 = -v3[(v14 + 2)];
    v30[6] = -v3[2];
    v30[7] = v19;
    v30[8] = -v3[(2 * v14 + 2)];
    int v20 = *(_DWORD *)(result + 8);
    if (v20)
    {
      float v21 = &v2[3 * v20];
      unint64_t v22 = (unint64_t)(v20 - 3) << 32;
      float v23 = v30;
      do
      {
        int v24 = *(_DWORD *)v23++;
        *(_DWORD *)uint64_t v2 = v24;
        unint64_t v25 = HIDWORD(v22);
        BOOL v26 = (int)v22 < 2;
        if ((int)v22 < 2) {
          unint64_t v25 = 0;
        }
        BOOL v27 = &v2[v25];
        uint64_t v28 = (v22 + 1);
        unint64_t v29 = v22 & 0xFFFFFFFF00000000;
        if (!v26) {
          uint64_t v28 = 0;
        }
        unint64_t v22 = v28 | v29;
        uint64_t v2 = v27 + 1;
      }
      while (v2 != v21);
    }
  }
  else
  {
    int v4 = *(_DWORD *)(result + 8);
    if (v4)
    {
      unint64_t v5 = 0;
      float v6 = &v2[3 * v4];
      unint64_t v7 = (unint64_t)(v4 - 3) << 32;
      int v8 = *(_DWORD *)(a2 + 8);
      do
      {
        float *v2 = -v3[(HIDWORD(v5) + v8 * v5)];
        if ((int)v5 >= 2) {
          unint64_t v5 = (v5 & 0xFFFFFFFF00000000) + 0x100000000;
        }
        else {
          unint64_t v5 = (v5 + 1) | v5 & 0xFFFFFFFF00000000;
        }
        unint64_t v9 = HIDWORD(v7);
        BOOL v10 = (int)v7 < 2;
        if ((int)v7 < 2) {
          unint64_t v9 = 0;
        }
        float v11 = &v2[v9];
        uint64_t v12 = (v7 + 1);
        unint64_t v13 = v7 & 0xFFFFFFFF00000000;
        if (!v10) {
          uint64_t v12 = 0;
        }
        unint64_t v7 = v12 | v13;
        uint64_t v2 = v11 + 1;
      }
      while (v2 != v6);
    }
  }
  return result;
}

void cva::SE3GroupStorage<float,cva::Matrix<float,4u,4u,false>>::log(float32x2_t *a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  sub_2153CC034((float *)a1, 4u, (float *)a2);
  float v4 = *(float *)a2;
  float v5 = *(float *)(a2 + 4);
  float v6 = *(float *)(a2 + 8);
  float v7 = (float)((float)(v4 * v4) + (float)(v5 * v5)) + (float)(v6 * v6);
  if (v7 >= 0.0061)
  {
    float v11 = sqrtf(v7);
    __float2 v12 = __sincosf_stret(v11);
    float v10 = v12.__sinval / v11;
    float v8 = (float)(1.0 / v7) * (float)(1.0 - v12.__cosval);
    float v9 = (float)(1.0 / v7) * (float)(1.0 - (float)(v12.__sinval / v11));
  }
  else
  {
    float v8 = 0.5 - (float)(v7 * (float)((float)(v7 / -720.0) + 0.041667));
    float v9 = 0.16667 - (float)(v7 * (float)((float)(v7 / -5040.0) + 0.0083333));
    float v10 = 1.0 - (float)(v7 * v9);
  }
  if (v7 >= 0.00000149)
  {
    if (v7 <= 9.0) {
      float v13 = (float)-(float)(v9 - (float)(v8 * 0.5)) / v10;
    }
    else {
      float v13 = (float)(v8 + (float)(v10 * -0.5)) / (float)(v7 * v8);
    }
  }
  else
  {
    float v13 = (float)((float)(v7 * 0.0013889) + 0.083333) + (float)(v7 * 0.000033069);
  }
  float v15 = a1[6].f32[0];
  float v14 = a1[6].f32[1];
  float v16 = a1[7].f32[0];
  float32_t v17 = (float)(v5 * v16) - (float)(v6 * v14);
  float32_t v23 = v17;
  *(float *)v24.i32 = (float)(v6 * v15) - (float)(v4 * v16);
  *(float *)&v24.i32[1] = (float)(v4 * v14) - (float)(v5 * v15);
  float32x2_t v18 = *(float32x2_t *)(a2 + 4);
  v19.i32[1] = v18.i32[1];
  v19.i32[0] = *(_DWORD *)a2;
  v20.i32[0] = vdup_lane_s32(v24, 1).u32[0];
  v20.f32[1] = v17;
  float32x2_t v21 = vadd_f32(vadd_f32(a1[6], vmul_f32(*(float32x2_t *)&v23, (float32x2_t)0xBF000000BF000000)), vmul_n_f32(vmla_f32(vmul_f32((float32x2_t)v24, vneg_f32((float32x2_t)vrev64_s32(v19))), v20, v18), v13));
  float v22 = (float)(v13 * vmlas_n_f32(-(float)(v18.f32[0] * v17), *(float *)a2, *(float *)v24.i32))
      + (float)(v16 + (float)(*(float *)&v24.i32[1] * -0.5));
  *(float32x2_t *)(a2 + 12) = v21;
  *(float *)(a2 + 20) = v22;
}

void *cva::SE3AlgebraStorage<float,cva::Matrix<float,6u,1u,false>>::SE3AlgebraStorage(void *result)
{
  *float result = 0;
  result[1] = 0;
  result[2] = 0;
  return result;
}

{
  *float result = 0;
  result[1] = 0;
  result[2] = 0;
  return result;
}

void cva::SE3GroupStorage<float,cva::Matrix<float,4u,4u,false>>::logJacobian(float *a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 152) = 0u;
  *(_OWORD *)(a2 + 140) = 0u;
  *(_OWORD *)(a2 + 124) = 0u;
  *(_OWORD *)(a2 + 108) = 0u;
  *(_OWORD *)(a2 + 92) = 0u;
  *(_OWORD *)(a2 + 76) = 0u;
  *(_OWORD *)(a2 + 60) = 0u;
  *(_OWORD *)(a2 + 44) = 0u;
  *(_OWORD *)(a2 + 28) = 0u;
  *(_OWORD *)(a2 + 12) = 0u;
  long long v80 = 0u;
  memset(v79, 0, sizeof(v79));
  sub_2153CC7A4(a1, 4u, (float *)v79, (float *)((unint64_t)v79 | 0xC));
  float v5 = *((float *)v79 + 1);
  float v4 = *(float *)v79;
  *(_DWORD *)a2 = v79[0];
  *(float *)(a2 + 4) = v5;
  _S11 = *((float *)v79 + 2);
  *(_DWORD *)(a2 + 8) = DWORD2(v79[0]);
  uint64_t v72 = a1 + 12;
  uint64_t v73 = 0xC00000004;
  *(void *)int v81 = (unint64_t)v79 | 0xC;
  *(void *)&v81[8] = &v72;
  if (((unint64_t)v79 | 0xC) == a2 || a1 == (float *)a2)
  {
    LODWORD(v71) = 0;
    size_t v70 = 0;
    sub_2153D8BEC((float *)&v70, (uint64_t)v81);
    _D19 = (float32x2_t)v70;
    float v11 = *(float *)&v71;
  }
  else
  {
    float v7 = a1[12];
    float v8 = a1[13];
    float v9 = a1[14];
    _D19 = vmla_n_f32(vmla_n_f32(vmla_n_f32(0, *(float32x2_t *)((char *)v79 + 12), v7), *(float32x2_t *)((char *)&v79[1] + 8), v8), *(float32x2_t *)((char *)&v80 + 4), v9);
    float v11 = (float)((float)((float)(*((float *)&v79[1] + 1) * v7) + 0.0) + (float)(*(float *)&v80 * v8))
        + (float)(*((float *)&v80 + 3) * v9);
  }
  *(float32x2_t *)(a2 + 12) = _D19;
  *(float *)(a2 + 20) = v11;
  float v12 = v4 * v4;
  float v13 = (float)((float)(v4 * v4) + (float)(v5 * v5)) + (float)(_S11 * _S11);
  if (v13 >= 0.0061)
  {
    float v66 = v4;
    float v19 = sqrtf(v13);
    float32x2_t v67 = _D19;
    __float2 v20 = __sincosf_stret(v19);
    _D19 = v67;
    float v21 = v20.__sinval / v19;
    float v4 = v66;
    _S0 = (float)(1.0 / v13) * (float)(1.0 - v20.__cosval);
    float v15 = (float)(1.0 / v13) * (float)(1.0 - v21);
    float v16 = v15 - _S0;
    float v17 = (float)(1.0 / v13) * (float)(v21 + (float)(_S0 * -2.0));
    float v18 = (float)(1.0 / v13) * (float)(_S0 + (float)(v15 * -3.0));
  }
  else
  {
    _S0 = 0.5 - (float)(v13 * (float)((float)(v13 / -720.0) + 0.041667));
    float v15 = 0.16667 - (float)(v13 * (float)((float)(v13 / -5040.0) + 0.0083333));
    float v16 = (float)(v13 * (float)((float)(v13 * -0.0011905) + 0.033333)) + -0.33333;
    float v17 = (float)(v13 * (float)((float)(v13 * -0.00014881) + 0.0055556)) + -0.083333;
    float v18 = (float)(v13 * (float)((float)(v13 * -0.000016534) + 0.00079365)) + -0.016667;
  }
  uint64_t v22 = 0;
  uint64_t v23 = a2 + 24;
  float v24 = vmuls_lane_f32(v5, _D19, 1);
  float v25 = (float)((float)(v4 * _D19.f32[0]) + v24) + (float)(_S11 * v11);
  float v26 = (float)((float)(v16 + (float)(v18 * v12)) * v25) + (float)((float)(v15 + v15) * (float)(v4 * _D19.f32[0]));
  float v27 = (float)((float)(v16 + (float)(v18 * (float)(v5 * v5))) * v25) + (float)((float)(v15 + v15) * v24);
  float v78 = (float)((float)(v16 + (float)(v18 * (float)(_S11 * _S11))) * v25)
      + (float)((float)(v15 + v15) * (float)(_S11 * v11));
  float v28 = v18 * v25;
  float v29 = (float)(v5 * (float)(v4 * (float)(v18 * v25)))
      + (float)(v15 * vmlas_n_f32(vmuls_lane_f32(v4, _D19, 1), v5, _D19.f32[0]));
  float v30 = (float)(_S11 * (float)(v4 * v28)) + (float)(v15 * vmlas_n_f32(v4 * v11, _S11, _D19.f32[0]));
  __asm { FMLA            S17, S11, V19.S[1] }
  float v36 = (float)(_S11 * (float)(v5 * v28)) + (float)(v15 * _S17);
  float v37 = v17 * v25;
  float v38 = (float)(_S11 * v37) + (float)(_S0 * v11);
  __asm { FMLA            S16, S0, V19.S[1] }
  float v40 = vmlas_n_f32(v4 * v37, _S0, _D19.f32[0]);
  *(float *)&uint64_t v72 = v26;
  *((float *)&v72 + 1) = v38 + v29;
  *(float *)&uint64_t v73 = v30 - _S16;
  *((float *)&v73 + 1) = v29 - v38;
  float v76 = _S16 + v30;
  float v77 = v36 - v40;
  float v74 = v27;
  float v75 = v40 + v36;
  unint64_t v41 = 0x300000000;
  uint64_t v42 = 12;
  do
  {
    *(_DWORD *)(v23 + 4 * v22) = *(_DWORD *)((char *)v79 + v42);
    unint64_t v43 = HIDWORD(v41);
    BOOL v44 = (int)v41 < 2;
    if ((int)v41 < 2) {
      unint64_t v43 = 0;
    }
    uint64_t v45 = v22 + v43;
    uint64_t v46 = (v41 + 1);
    unint64_t v47 = v41 & 0xFFFFFFFF00000000;
    if (!v44) {
      uint64_t v46 = 0;
    }
    unint64_t v41 = v46 | v47;
    uint64_t v22 = v45 + 1;
    v42 += 4;
  }
  while (v22 != 18);
  long long v48 = *(_OWORD *)(a2 + 28);
  long long v49 = *(_OWORD *)(a2 + 48);
  *((void *)&v48 + 1) = *(void *)(a2 + 48);
  *(_DWORD *)int v81 = *(_DWORD *)(a2 + 24);
  *(_OWORD *)&v81[4] = v48;
  size_t v50 = (int *)v81;
  int v82 = DWORD2(v49);
  uint64_t v83 = *(void *)(a2 + 72);
  int v84 = *(_DWORD *)(a2 + 80);
  unint64_t v51 = 0x300000000;
  for (uint64_t i = 21; i != 39; uint64_t i = v56 + 1)
  {
    int v53 = *v50++;
    *(_DWORD *)(v23 + 4 * i) = v53;
    unint64_t v54 = HIDWORD(v51);
    BOOL v55 = (int)v51 < 2;
    if ((int)v51 < 2) {
      unint64_t v54 = 0;
    }
    unint64_t v56 = i + v54;
    uint64_t v57 = (v51 + 1);
    unint64_t v58 = v51 & 0xFFFFFFFF00000000;
    if (!v55) {
      uint64_t v57 = 0;
    }
    unint64_t v51 = v57 | v58;
  }
  size_t v70 = &v69;
  size_t v71 = &v72;
  *(void *)int v81 = &v70;
  *(void *)&v81[8] = (unint64_t)v79 | 0xC;
  v68[0] = a2 + 36;
  v68[1] = 0x300000006;
  unint64_t v69 = (unint64_t)v79 | 0xC;
  sub_2153D8CCC((uint64_t)v68, (uint64_t *)v81);
  unint64_t v59 = 0x300000000;
  for (uint64_t j = 18; j != 36; uint64_t j = v63 + 1)
  {
    *(_DWORD *)(v23 + 4 * j) = 0;
    unint64_t v61 = HIDWORD(v59);
    BOOL v62 = (int)v59 < 2;
    if ((int)v59 < 2) {
      unint64_t v61 = 0;
    }
    unint64_t v63 = j + v61;
    uint64_t v64 = (v59 + 1);
    unint64_t v65 = v59 & 0xFFFFFFFF00000000;
    if (!v62) {
      uint64_t v64 = 0;
    }
    unint64_t v59 = v64 | v65;
  }
}

float *sub_2153D8BEC(float *result, uint64_t a2)
{
  uint64_t v2 = result;
  uint64_t v3 = *(float **)a2;
  if (*(float **)a2 == result
    || (uint64_t v4 = *(void *)(a2 + 8),
        float v5 = *(float **)v4,
        (float *)(*(void *)v4 - 4 * *(unsigned int *)(v4 + 12)) == result))
  {
    int v7 = 0;
    uint64_t v6 = 0;
    float result = (float *)sub_2153D8BEC(&v6);
    *(void *)uint64_t v2 = v6;
    *((_DWORD *)v2 + 2) = v7;
  }
  else
  {
    *float result = (float)((float)((float)(*v3 * *v5) + 0.0) + (float)(v3[3] * v5[1])) + (float)(v3[6] * v5[2]);
    result[1] = (float)((float)((float)(v3[1] * *v5) + 0.0) + (float)(v3[4] * v5[1])) + (float)(v3[7] * v5[2]);
    result[2] = (float)((float)((float)(v3[2] * *v5) + 0.0) + (float)(v3[5] * v5[1])) + (float)(v3[8] * v5[2]);
  }
  return result;
}

void sub_2153D8CCC(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = (float *)a2[1];
  uint64_t v4 = *(float **)a1;
  if (v3 == (float *)(*(void *)a1 - 4 * *(unsigned int *)(a1 + 12)))
  {
    float v31 = 0.0;
    long long v29 = 0u;
    long long v30 = 0u;
    sub_2153D8EA8((uint64_t)&v29, a2);
    int v18 = *(_DWORD *)(a1 + 8);
    if (v18)
    {
      float v19 = *(float **)a1;
      uint64_t v20 = *(void *)a1 + 4 * (3 * v18);
      unint64_t v21 = (unint64_t)(v18 - 3) << 32;
      uint64_t v22 = (int *)&v29;
      do
      {
        int v23 = *v22++;
        *(_DWORD *)float v19 = v23;
        unint64_t v24 = HIDWORD(v21);
        BOOL v25 = (int)v21 < 2;
        if ((int)v21 < 2) {
          unint64_t v24 = 0;
        }
        float v26 = &v19[v24];
        uint64_t v27 = (v21 + 1);
        unint64_t v28 = v21 & 0xFFFFFFFF00000000;
        if (!v25) {
          uint64_t v27 = 0;
        }
        unint64_t v21 = v27 | v28;
        float v19 = v26 + 1;
      }
      while (v19 != (float *)v20);
    }
  }
  else
  {
    uint64_t v5 = *a2;
    long long v29 = 0u;
    long long v30 = 0u;
    float v31 = 0.0;
    sub_2153D900C((uint64_t)&v29, v5);
    uint64_t v6 = *(unsigned int *)(a1 + 8);
    float v7 = *(float *)&v29;
    float v8 = *((float *)&v29 + 3);
    float v9 = *((float *)&v30 + 2);
    float *v4 = (float)((float)((float)(*(float *)&v29 * *v3) + 0.0) + (float)(*((float *)&v29 + 3) * v3[1]))
        + (float)(*((float *)&v30 + 2) * v3[2]);
    float v10 = *((float *)&v29 + 1);
    float v11 = *(float *)&v30;
    float v12 = *((float *)&v30 + 3);
    v4[1] = (float)((float)((float)(*((float *)&v29 + 1) * *v3) + 0.0) + (float)(*(float *)&v30 * v3[1]))
          + (float)(*((float *)&v30 + 3) * v3[2]);
    float v13 = *((float *)&v29 + 2);
    float v14 = *((float *)&v30 + 1);
    float v15 = v31;
    v4[2] = (float)((float)((float)(*((float *)&v29 + 2) * *v3) + 0.0) + (float)(*((float *)&v30 + 1) * v3[1]))
          + (float)(v31 * v3[2]);
    float v16 = &v4[v6];
    float *v16 = (float)((float)((float)(v7 * v3[3]) + 0.0) + (float)(v8 * v3[4])) + (float)(v9 * v3[5]);
    v16[1] = (float)((float)((float)(v10 * v3[3]) + 0.0) + (float)(v11 * v3[4])) + (float)(v12 * v3[5]);
    v16[2] = (float)((float)((float)(v13 * v3[3]) + 0.0) + (float)(v14 * v3[4])) + (float)(v15 * v3[5]);
    float v17 = &v4[(2 * v6)];
    *float v17 = (float)((float)((float)(v7 * v3[6]) + 0.0) + (float)(v8 * v3[7])) + (float)(v9 * v3[8]);
    v17[1] = (float)((float)((float)(v10 * v3[6]) + 0.0) + (float)(v11 * v3[7])) + (float)(v12 * v3[8]);
    v17[2] = (float)((float)((float)(v13 * v3[6]) + 0.0) + (float)(v14 * v3[7])) + (float)(v15 * v3[8]);
  }
}

__n64 sub_2153D8EA8(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = (float *)a2[1];
  if (v3 == (float *)a1)
  {
    float v13 = 0.0;
    long long v11 = 0u;
    long long v12 = 0u;
    sub_2153D8EA8(&v11);
    result.n64_u64[0] = v11;
    long long v10 = v12;
    *(_OWORD *)a1 = v11;
    *(_OWORD *)(a1 + 16) = v10;
    *(float *)(a1 + 32) = v13;
  }
  else
  {
    uint64_t v4 = *a2;
    long long v11 = 0u;
    long long v12 = 0u;
    float v13 = 0.0;
    sub_2153D900C((uint64_t)&v11, v4);
    result.n64_u32[1] = 0;
    long long v5 = v11;
    uint64_t v6 = *((void *)&v12 + 1);
    *(float *)a1 = (float)((float)((float)(*(float *)&v11 * *v3) + 0.0) + (float)(*((float *)&v11 + 3) * v3[1]))
                 + (float)(*((float *)&v12 + 2) * v3[2]);
    uint64_t v7 = v12;
    *(float *)(a1 + 4) = (float)((float)((float)(*((float *)&v5 + 1) * *v3) + 0.0) + (float)(*(float *)&v12 * v3[1]))
                       + (float)(*((float *)&v6 + 1) * v3[2]);
    float v8 = v13;
    *(float *)(a1 + 8) = (float)((float)((float)(*((float *)&v5 + 2) * *v3) + 0.0) + (float)(*((float *)&v7 + 1) * v3[1]))
                       + (float)(v13 * v3[2]);
    *(float *)(a1 + 12) = (float)((float)((float)(*(float *)&v5 * v3[3]) + 0.0) + (float)(*((float *)&v5 + 3) * v3[4]))
                        + (float)(*(float *)&v6 * v3[5]);
    *(float *)(a1 + 16) = (float)((float)((float)(*((float *)&v5 + 1) * v3[3]) + 0.0) + (float)(*(float *)&v7 * v3[4]))
                        + (float)(*((float *)&v6 + 1) * v3[5]);
    *(float *)(a1 + 20) = (float)((float)((float)(*((float *)&v5 + 2) * v3[3]) + 0.0)
                                + (float)(*((float *)&v7 + 1) * v3[4]))
                        + (float)(v8 * v3[5]);
    *(float *)(a1 + 24) = (float)((float)((float)(*(float *)&v5 * v3[6]) + 0.0) + (float)(*((float *)&v5 + 3) * v3[7]))
                        + (float)(*(float *)&v6 * v3[8]);
    *(float *)(a1 + 28) = (float)((float)((float)(*((float *)&v5 + 1) * v3[6]) + 0.0) + (float)(*(float *)&v7 * v3[7]))
                        + (float)(*((float *)&v6 + 1) * v3[8]);
    result.n64_f32[0] = (float)((float)((float)(*((float *)&v5 + 2) * v3[6]) + 0.0)
                              + (float)(*((float *)&v7 + 1) * v3[7]))
                      + (float)(v8 * v3[8]);
    *(_DWORD *)(a1 + 32) = result.n64_u32[0];
  }
  return result;
}

double sub_2153D900C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(float **)(a2 + 8);
  if (v3 == (float *)a1)
  {
    int v18 = 0;
    long long v16 = 0u;
    long long v17 = 0u;
    sub_2153D900C(&v16);
    double result = *(double *)&v16;
    long long v15 = v17;
    *(_OWORD *)a1 = v16;
    *(_OWORD *)(a1 + 16) = v15;
    *(_DWORD *)(a1 + 32) = v18;
  }
  else
  {
    uint64_t v4 = **(float ***)a2;
    float v5 = *v4;
    float v6 = v4[1];
    float v7 = v4[2];
    float v8 = v4[3];
    float v9 = v4[4];
    float v10 = v4[5];
    float v11 = v4[6];
    float v12 = v4[7];
    float v13 = v4[8];
    *(float *)a1 = (float)((float)(0.0 - (float)(*v4 * *v3)) - (float)(v8 * v3[1])) - (float)(v11 * v3[2]);
    *(float *)(a1 + 4) = (float)((float)(0.0 - (float)(v6 * *v3)) - (float)(v9 * v3[1])) - (float)(v12 * v3[2]);
    *(float *)(a1 + 8) = (float)((float)(0.0 - (float)(v7 * *v3)) - (float)(v10 * v3[1])) - (float)(v13 * v3[2]);
    *(float *)(a1 + 12) = (float)((float)(0.0 - (float)(v5 * v3[3])) - (float)(v8 * v3[4])) - (float)(v11 * v3[5]);
    *(float *)(a1 + 16) = (float)((float)(0.0 - (float)(v6 * v3[3])) - (float)(v9 * v3[4])) - (float)(v12 * v3[5]);
    *(float *)(a1 + 20) = (float)((float)(0.0 - (float)(v7 * v3[3])) - (float)(v10 * v3[4])) - (float)(v13 * v3[5]);
    *(float *)(a1 + 24) = (float)((float)(0.0 - (float)(v5 * v3[6])) - (float)(v8 * v3[7])) - (float)(v11 * v3[8]);
    *(float *)(a1 + 28) = (float)((float)(0.0 - (float)(v6 * v3[6])) - (float)(v9 * v3[7])) - (float)(v12 * v3[8]);
    *(float *)&double result = (float)((float)(0.0 - (float)(v7 * v3[6])) - (float)(v10 * v3[7])) - (float)(v13 * v3[8]);
    *(_DWORD *)(a1 + 32) = LODWORD(result);
  }
  return result;
}

uint64_t cva::SE3GroupStorage<float,cva::Matrix<float,4u,4u,false>>::inverse@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)a2 = xmmword_215446040;
  *(_OWORD *)(a2 + 16) = unk_215446050;
  *(_OWORD *)(a2 + 32) = xmmword_215446060;
  *(_OWORD *)(a2 + 48) = unk_215446070;
  long long v15 = (uint64_t *)a1;
  uint64_t v16 = 4;
  v14[0] = a2;
  v14[1] = 4;
  uint64_t result = sub_2153D9260((uint64_t)v14, (uint64_t)&v15);
  v13[0] = a2;
  v13[1] = 4;
  v14[0] = v13;
  v12[0] = a1 + 48;
  v12[1] = 0xC00000004;
  long long v15 = v14;
  uint64_t v16 = (uint64_t)v12;
  if (a1 == a2)
  {
    float v18 = 0.0;
    uint64_t v17 = 0;
    uint64_t result = (uint64_t)sub_2153D93A8((float *)&v17, &v15);
    *(void *)(a2 + 48) = v17;
    float v11 = v18;
  }
  else
  {
    float v8 = *(float *)(a2 + 8);
    float v9 = *(float *)(a2 + 24);
    float v10 = *(float *)(a2 + 40);
    v5.i32[0] = *(_DWORD *)(a1 + 48);
    v6.i32[0] = *(_DWORD *)(a1 + 52);
    v7.i32[0] = *(_DWORD *)(a1 + 56);
    *(float32x2_t *)(a2 + 48) = vmls_lane_f32(vmls_lane_f32(vmls_lane_f32(0, *(float32x2_t *)a2, v5, 0), *(float32x2_t *)(a2 + 16), v6, 0), *(float32x2_t *)(a2 + 32), v7, 0);
    float v11 = (float)((float)(0.0 - (float)(v8 * v5.f32[0])) - (float)(v9 * v6.f32[0])) - (float)(v10 * v7.f32[0]);
  }
  *(float *)(a2 + 56) = v11;
  return result;
}

uint64_t sub_2153D9260(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(_DWORD **)result;
  uint64_t v3 = *(_DWORD **)a2;
  if (*(void *)a2 - 4 * *(unsigned int *)(a2 + 12) == *(void *)result - 4 * *(unsigned int *)(result + 12))
  {
    uint64_t v14 = *(unsigned int *)(a2 + 8);
    int v15 = v3[v14];
    int v16 = v3[1];
    v30[0] = *v3;
    v30[1] = v15;
    int v17 = v3[(v14 + 1)];
    v30[2] = v3[(2 * v14)];
    v30[3] = v16;
    int v18 = v3[(2 * v14) | 1];
    v30[4] = v17;
    v30[5] = v18;
    int v19 = v3[(v14 + 2)];
    v30[6] = v3[2];
    v30[7] = v19;
    v30[8] = v3[(2 * v14 + 2)];
    int v20 = *(_DWORD *)(result + 8);
    if (v20)
    {
      unint64_t v21 = &v2[3 * v20];
      unint64_t v22 = (unint64_t)(v20 - 3) << 32;
      int v23 = v30;
      do
      {
        int v24 = *v23++;
        _DWORD *v2 = v24;
        unint64_t v25 = HIDWORD(v22);
        BOOL v26 = (int)v22 < 2;
        if ((int)v22 < 2) {
          unint64_t v25 = 0;
        }
        uint64_t v27 = &v2[v25];
        uint64_t v28 = (v22 + 1);
        unint64_t v29 = v22 & 0xFFFFFFFF00000000;
        if (!v26) {
          uint64_t v28 = 0;
        }
        unint64_t v22 = v28 | v29;
        uint64_t v2 = v27 + 1;
      }
      while (v2 != v21);
    }
  }
  else
  {
    int v4 = *(_DWORD *)(result + 8);
    if (v4)
    {
      unint64_t v5 = 0;
      float32x2_t v6 = &v2[3 * v4];
      unint64_t v7 = (unint64_t)(v4 - 3) << 32;
      int v8 = *(_DWORD *)(a2 + 8);
      do
      {
        _DWORD *v2 = v3[(HIDWORD(v5) + v8 * v5)];
        if ((int)v5 >= 2) {
          unint64_t v5 = (v5 & 0xFFFFFFFF00000000) + 0x100000000;
        }
        else {
          unint64_t v5 = (v5 + 1) | v5 & 0xFFFFFFFF00000000;
        }
        unint64_t v9 = HIDWORD(v7);
        BOOL v10 = (int)v7 < 2;
        if ((int)v7 < 2) {
          unint64_t v9 = 0;
        }
        float v11 = &v2[v9];
        uint64_t v12 = (v7 + 1);
        unint64_t v13 = v7 & 0xFFFFFFFF00000000;
        if (!v10) {
          uint64_t v12 = 0;
        }
        unint64_t v7 = v12 | v13;
        uint64_t v2 = v11 + 1;
      }
      while (v2 != v6);
    }
  }
  return result;
}

float *sub_2153D93A8(float *result, uint64_t **a2)
{
  uint64_t v2 = result;
  uint64_t v3 = a2[1];
  int v4 = (float *)*v3;
  if ((float *)(*v3 - 4 * *((unsigned int *)v3 + 3)) == result)
  {
    int v19 = 0;
    uint64_t v18 = 0;
    uint64_t result = (float *)sub_2153D93A8(&v18);
    *(void *)uint64_t v2 = v18;
    *((_DWORD *)v2 + 2) = v19;
  }
  else
  {
    uint64_t v5 = **a2;
    float32x2_t v6 = *(float **)v5;
    float v7 = **(float **)v5;
    float v8 = *(float *)(*(void *)v5 + 4);
    float v9 = *(float *)(*(void *)v5 + 8);
    uint64_t v10 = (*(_DWORD *)(v5 + 8) - 3);
    float v11 = &v6[v10];
    float v12 = v11[3];
    float v13 = v11[4];
    v11 += 3;
    float v14 = v11[2];
    int v15 = &v11[v10];
    float v16 = v15[4];
    float v17 = v15[5];
    *uint64_t result = (float)((float)(0.0 - (float)(v7 * *v4)) - (float)(v12 * v4[1])) - (float)(v15[3] * v4[2]);
    result[1] = (float)((float)(0.0 - (float)(v8 * *v4)) - (float)(v13 * v4[1])) - (float)(v16 * v4[2]);
    result[2] = (float)((float)(0.0 - (float)(v9 * *v4)) - (float)(v14 * v4[1])) - (float)(v17 * v4[2]);
  }
  return result;
}

uint64_t cva::SE3GroupStorage<float,cva::Matrix<float,4u,4u,false>>::adjoint@<X0>(uint64_t result@<X0>, int *a2@<X8>, int8x16_t a3@<Q1>, int32x4_t a4@<Q3>)
{
  v4.i64[1] = 0;
  *((_OWORD *)a2 + 7) = 0u;
  *((_OWORD *)a2 + 8) = 0u;
  *((_OWORD *)a2 + 5) = 0u;
  *((_OWORD *)a2 + 6) = 0u;
  *((_OWORD *)a2 + 3) = 0u;
  *((_OWORD *)a2 + 4) = 0u;
  *((_OWORD *)a2 + 1) = 0u;
  *((_OWORD *)a2 + 2) = 0u;
  *(_OWORD *)a2 = 0u;
  if ((int *)result == a2)
  {
    uint64_t v23 = 0;
    *(_DWORD *)float32x2_t v67 = *(_DWORD *)result;
    v4.i64[0] = *(void *)(result + 4);
    v4.i64[1] = *(void *)(result + 16);
    *(int32x4_t *)&v67[4] = v4;
    *(_DWORD *)&v67[20] = *(_DWORD *)(result + 24);
    *(void *)&v67[24] = *(void *)(result + 32);
    float v68 = *(float *)(result + 40);
    unint64_t v24 = 0x300000000;
    unint64_t v25 = (int *)v67;
    do
    {
      int v26 = *v25++;
      *(_DWORD *)(result + 4 * v23) = v26;
      unint64_t v27 = HIDWORD(v24);
      BOOL v28 = (int)v24 < 2;
      if ((int)v24 < 2) {
        unint64_t v27 = 0;
      }
      uint64_t v29 = v23 + v27;
      uint64_t v30 = (v24 + 1);
      unint64_t v31 = v24 & 0xFFFFFFFF00000000;
      if (!v28) {
        uint64_t v30 = 0;
      }
      unint64_t v24 = v30 | v31;
      uint64_t v23 = v29 + 1;
    }
    while (v23 != 18);
    a3.i64[0] = 0;
    long long v22 = 0uLL;
    float v21 = 0.0;
    int v20 = 0;
    int v19 = 0;
  }
  else
  {
    uint64_t v5 = 0;
    unint64_t v6 = 0x100000000;
    unint64_t v7 = 0x300000000;
    float v8 = (int *)result;
    do
    {
      a2[v5] = *v8;
      unint64_t v9 = HIDWORD(v6);
      BOOL v10 = (int)v6 < 2;
      if ((int)v6 < 2) {
        unint64_t v9 = 0;
      }
      float v11 = &v8[v9];
      uint64_t v12 = (v6 + 1);
      unint64_t v13 = v6 & 0xFFFFFFFF00000000;
      if (!v10) {
        uint64_t v12 = 0;
      }
      unint64_t v6 = v12 | v13;
      float v8 = v11 + 1;
      unint64_t v14 = HIDWORD(v7);
      BOOL v15 = (int)v7 < 2;
      if ((int)v7 < 2) {
        unint64_t v14 = 0;
      }
      uint64_t v16 = v5 + v14;
      uint64_t v17 = (v7 + 1);
      unint64_t v18 = v7 & 0xFFFFFFFF00000000;
      if (!v15) {
        uint64_t v17 = 0;
      }
      unint64_t v7 = v17 | v18;
      uint64_t v5 = v16 + 1;
    }
    while (v5 != 18);
    int v19 = *a2;
    int v20 = *((void *)a2 + 4);
    a3.i64[0] = *((void *)a2 + 6);
    float v21 = *((float *)a2 + 14);
    *(void *)&long long v22 = *(void *)(a2 + 1);
    *((void *)&v22 + 1) = *((void *)a2 + 3);
  }
  *(_DWORD *)float32x2_t v67 = v19;
  *(_OWORD *)&v67[4] = v22;
  *(_DWORD *)&v67[20] = v20;
  *(void *)&v67[24] = a3.i64[0];
  unint64_t v32 = 0x300000000;
  unint64_t v33 = (int *)v67;
  uint64_t v34 = 21;
  float v68 = v21;
  do
  {
    int v35 = *v33++;
    a2[v34] = v35;
    unint64_t v36 = HIDWORD(v32);
    BOOL v37 = (int)v32 < 2;
    if ((int)v32 < 2) {
      unint64_t v36 = 0;
    }
    unint64_t v38 = v34 + v36;
    uint64_t v39 = (v32 + 1);
    unint64_t v40 = v32 & 0xFFFFFFFF00000000;
    if (!v37) {
      uint64_t v39 = 0;
    }
    unint64_t v32 = v39 | v40;
    uint64_t v34 = v38 + 1;
  }
  while (v34 != 39);
  v4.i64[0] = *(void *)(result + 48);
  a3.i32[0] = *(_DWORD *)(result + 56);
  a4.i64[0] = *(void *)(result + 4);
  LODWORD(v22) = *(_DWORD *)(result + 24);
  float32x2_t v41 = *(float32x2_t *)(result + 36);
  float v42 = vmul_f32(*(float32x2_t *)v4.i8, v41).f32[0] - vmuls_lane_f32(*(float *)(result + 32), *(float32x2_t *)v4.i8, 1);
  int32x4_t v43 = vuzp2q_s32(v4, vzip1q_s32(v4, v4));
  float32x4_t v44 = (float32x4_t)v43;
  v44.i32[1] = a3.i32[0];
  v44.i32[3] = v43.i32[0];
  float32x4_t v45 = (float32x4_t)vuzp2q_s32(a4, vzip1q_s32(a4, a4));
  v45.i32[1] = *(_DWORD *)result;
  v45.i32[3] = v22;
  v46.i64[0] = *(void *)(result + 16);
  float32x4_t v47 = vmulq_f32(v44, v45);
  float32x4_t v48 = (float32x4_t)vextq_s8(vextq_s8(a3, a3, 4uLL), (int8x16_t)v4, 0xCuLL);
  v48.i32[3] = v48.i32[0];
  a4.i32[2] = *(_DWORD *)result;
  a4.i32[3] = v46.i32[1];
  *(int32x2_t *)v49.f32 = vzip1_s32(*(int32x2_t *)&v22, *(int32x2_t *)v46.f32);
  v46.i32[2] = vdup_lane_s32((int32x2_t)v41, 1).u32[0];
  v46.i32[3] = *(_DWORD *)(result + 32);
  v50.i64[0] = v4.i64[0];
  v50.i64[1] = __PAIR64__(v4.u32[0], a3.u32[0]);
  *(float32x2_t *)&v49.u32[2] = v41;
  *(float32x4_t *)float32x2_t v67 = vsubq_f32(v47, vmulq_f32(v48, (float32x4_t)a4));
  *(float32x4_t *)&v67[16] = vsubq_f32(vmulq_f32(v48, v46), vmulq_f32(v50, v49));
  float v68 = v42;
  unint64_t v51 = 0x300000000;
  v52 = (int *)v67;
  for (uint64_t i = 3; i != 21; uint64_t i = v57 + 1)
  {
    int v54 = *v52++;
    a2[i] = v54;
    unint64_t v55 = HIDWORD(v51);
    BOOL v56 = (int)v51 < 2;
    if ((int)v51 < 2) {
      unint64_t v55 = 0;
    }
    unint64_t v57 = i + v55;
    uint64_t v58 = (v51 + 1);
    unint64_t v59 = v51 & 0xFFFFFFFF00000000;
    if (!v56) {
      uint64_t v58 = 0;
    }
    unint64_t v51 = v58 | v59;
  }
  unint64_t v60 = 0x300000000;
  for (uint64_t j = 18; j != 36; uint64_t j = v64 + 1)
  {
    a2[j] = 0;
    unint64_t v62 = HIDWORD(v60);
    BOOL v63 = (int)v60 < 2;
    if ((int)v60 < 2) {
      unint64_t v62 = 0;
    }
    unint64_t v64 = j + v62;
    uint64_t v65 = (v60 + 1);
    unint64_t v66 = v60 & 0xFFFFFFFF00000000;
    if (!v63) {
      uint64_t v65 = 0;
    }
    unint64_t v60 = v65 | v66;
  }
  return result;
}

void cva::SE3GroupStorage<float,cva::Matrix<float,4u,4u,false>>::enforce()
{
}

uint64_t sub_2153D986C(uint64_t result, float *a2, float32x2_t *a3)
{
  float v3 = *a2;
  float v4 = a2[1];
  float v5 = a2[2];
  float v6 = v5 * *(float *)result;
  float v7 = v5 * *(float *)(result + 4);
  float v8 = v5 * *(float *)(result + 8);
  a3->f32[0] = *a2 + (float)(v6 * *(float *)result);
  a3[2].f32[1] = v3 + (float)(v7 * *(float *)(result + 4));
  a3[5].f32[0] = v3 + (float)(v8 * *(float *)(result + 8));
  float v9 = *(float *)(result + 4);
  float v10 = v6 * v9;
  float v11 = *(float *)(result + 8);
  float v12 = v6 * v11;
  float v13 = v7 * v11;
  float v14 = v4 * *(float *)result;
  float v15 = v4 * v9;
  float v16 = v4 * v11;
  a3[2].f32[0] = v10 - v16;
  a3[4].f32[0] = v15 + v12;
  a3[4].f32[1] = v13 - v14;
  a3->f32[1] = v10 + v16;
  a3[1].f32[0] = v12 - v15;
  a3[3].f32[0] = v13 + v14;
  float v17 = *(float *)(result + 8);
  float v18 = *(float *)(result + 12);
  float v19 = *(float *)(result + 16);
  float v20 = *(float *)(result + 20);
  float v21 = *(float *)(result + 4);
  float v22 = (float)(v21 * v20) - (float)(v17 * v19);
  float v23 = (float)(v17 * v18) - (float)(*(float *)result * v20);
  *(float *)unint64_t v33 = v22;
  *(float *)&v33[4] = v23;
  float v24 = (float)(*(float *)result * v19) - (float)(v21 * v18);
  *(float *)&v33[8] = v24;
  float v26 = a2[2];
  float v25 = a2[3];
  if ((float32x2_t *)result == a3)
  {
    float v28 = v20 + (float)(v26 * v24);
    float32x2_t v29 = *(float32x2_t *)(result + 4);
    v30.i32[1] = v29.i32[1];
    v30.i32[0] = *(_DWORD *)result;
    v31.i32[0] = vdup_lane_s32(*(int32x2_t *)&v33[4], 1).u32[0];
    v31.f32[1] = v22;
    float32x2_t v32 = vadd_f32(vadd_f32(*(float32x2_t *)(result + 12), vmul_n_f32(*(float32x2_t *)v33, v26)), vmul_n_f32(vmla_f32(vmul_f32(*(float32x2_t *)&v33[4], vneg_f32((float32x2_t)vrev64_s32(v30))), v31, v29), v25));
    float v27 = (float)(v25 * vmlas_n_f32(-(float)(v29.f32[0] * v22), *(float *)result, *(float *)&v33[4])) + v28;
    a3[6] = v32;
  }
  else
  {
    a3[6].f32[0] = (float)(v18 + (float)(v22 * v26))
                 + (float)(v25 * (float)((float)(*(float *)(result + 4) * v24) - (float)(*(float *)(result + 8) * v23)));
    a3[6].f32[1] = (float)(*(float *)(result + 16) + (float)(v23 * v26))
                 + (float)(v25 * (float)((float)(*(float *)(result + 8) * v22) - (float)(*(float *)result * v24)));
    float v27 = (float)(*(float *)(result + 20) + (float)(v24 * v26))
        + (float)(v25 * (float)((float)(*(float *)result * v23) - (float)(*(float *)(result + 4) * v22)));
  }
  a3[7].f32[0] = v27;
  return result;
}

uint64_t cva::SE3AlgebraStorage<float,cva::Matrix<float,6u,1u,false>>::exp@<X0>(float *a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)a2 = xmmword_215446040;
  *(_OWORD *)(a2 + 16) = unk_215446050;
  *(_OWORD *)(a2 + 32) = xmmword_215446060;
  *(_OWORD *)(a2 + 48) = unk_215446070;
  float v4 = (float)((float)(*a1 * *a1) + (float)(a1[1] * a1[1])) + (float)(a1[2] * a1[2]);
  if (v4 >= 0.0061)
  {
    float v9 = sqrtf(v4);
    __float2 v10 = __sincosf_stret(v9);
    float cosval = v10.__cosval;
    float v7 = v10.__sinval / v9;
    float v5 = (float)(1.0 / v4) * (float)(1.0 - v10.__cosval);
    float v6 = (float)(1.0 / v4) * (float)(1.0 - (float)(v10.__sinval / v9));
  }
  else
  {
    float v5 = 0.5 - (float)(v4 * (float)((float)(v4 / -720.0) + 0.041667));
    float v6 = 0.16667 - (float)(v4 * (float)((float)(v4 / -5040.0) + 0.0083333));
    float v7 = 1.0 - (float)(v4 * v6);
    float cosval = 1.0 - (float)(v4 * v5);
  }
  void v12[2] = v5;
  v12[3] = v6;
  v12[0] = cosval;
  v12[1] = v7;
  return sub_2153D986C((uint64_t)a1, v12, (float32x2_t *)a2);
}

uint64_t cva::SE3GroupStorage<float,cva::Matrix<float,4u,4u,false>>::serialize()
{
  return std::ostream::write();
}

uint64_t cva::SE3GroupStorage<float,cva::Matrix<float,4u,4u,false>>::deserialize(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x270F98678](a2, a1, 64);
}

double cva::SE3GroupStorage<double,cva::Matrix<double,4u,4u,false>>::SE3GroupStorage(_OWORD *a1)
{
  a1[4] = xmmword_2154460C0;
  a1[5] = unk_2154460D0;
  a1[6] = xmmword_2154460E0;
  a1[7] = unk_2154460F0;
  *a1 = xmmword_215446080;
  a1[1] = *(_OWORD *)algn_215446090;
  double result = 0.0;
  a1[2] = xmmword_2154460A0;
  a1[3] = unk_2154460B0;
  return result;
}

{
  double result;

  a1[4] = xmmword_2154460C0;
  a1[5] = unk_2154460D0;
  a1[6] = xmmword_2154460E0;
  a1[7] = unk_2154460F0;
  *a1 = xmmword_215446080;
  a1[1] = *(_OWORD *)algn_215446090;
  double result = 0.0;
  a1[2] = xmmword_2154460A0;
  a1[3] = unk_2154460B0;
  return result;
}

double cva::SE3GroupStorage<double,cva::Matrix<double,4u,4u,false>>::SE3GroupStorage(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = 0;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  unint64_t v4 = 0x100000000;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  do
  {
    uint64_t v5 = *a2++;
    *(void *)(a1 + 8 * v3) = v5;
    unint64_t v6 = HIDWORD(v4);
    BOOL v7 = (int)v4 < 2;
    if ((int)v4 < 2) {
      unint64_t v6 = 0;
    }
    uint64_t v8 = v3 + v6;
    uint64_t v9 = (v4 + 1);
    unint64_t v10 = v4 & 0xFFFFFFFF00000000;
    if (!v7) {
      uint64_t v9 = 0;
    }
    unint64_t v4 = v9 | v10;
    uint64_t v3 = v8 + 1;
  }
  while (v3 != 12);
  *(void *)(a1 + 96) = *(void *)a3;
  *(void *)(a1 + 104) = *(void *)(a3 + 8);
  double result = *(double *)(a3 + 16);
  *(double *)(a1 + 112) = result;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 120) = 0x3FF0000000000000;
  return result;
}

{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  double result;

  uint64_t v3 = 0;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  unint64_t v4 = 0x100000000;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  do
  {
    uint64_t v5 = *a2++;
    *(void *)(a1 + 8 * v3) = v5;
    unint64_t v6 = HIDWORD(v4);
    BOOL v7 = (int)v4 < 2;
    if ((int)v4 < 2) {
      unint64_t v6 = 0;
    }
    uint64_t v8 = v3 + v6;
    uint64_t v9 = (v4 + 1);
    unint64_t v10 = v4 & 0xFFFFFFFF00000000;
    if (!v7) {
      uint64_t v9 = 0;
    }
    unint64_t v4 = v9 | v10;
    uint64_t v3 = v8 + 1;
  }
  while (v3 != 12);
  *(void *)(a1 + 96) = *(void *)a3;
  *(void *)(a1 + 104) = *(void *)(a3 + 8);
  double result = *(double *)(a3 + 16);
  *(double *)(a1 + 112) = result;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 120) = 0x3FF0000000000000;
  return result;
}

uint64_t cva::SE3GroupStorage<double,cva::Matrix<double,4u,4u,false>>::T(uint64_t a1)
{
  return a1 + 96;
}

{
  return a1 + 96;
}

void cva::SE3GroupStorage<double,cva::Matrix<double,4u,4u,false>>::lplus(_OWORD *a1, long long *a2)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  long long v3 = a2[1];
  long long v26 = *a2;
  long long v27 = v3;
  long long v28 = a2[2];
  v15[0] = &v26;
  v15[1] = 6;
  v16[5] = (float64x2_t)unk_2154460D0;
  v16[6] = (float64x2_t)xmmword_2154460E0;
  v16[7] = (float64x2_t)unk_2154460F0;
  v16[0] = (float64x2_t)xmmword_215446080;
  v16[1] = *(float64x2_t *)algn_215446090;
  v16[2] = (float64x2_t)xmmword_2154460A0;
  memset(&v16[3], 0, 32);
  double v4 = *(double *)&v26 * *(double *)&v26
     + *((double *)&v26 + 1) * *((double *)&v26 + 1)
     + *(double *)&v27 * *(double *)&v27;
  if (v4 >= 0.0000002635)
  {
    double v9 = sqrt(v4);
    __double2 v10 = __sincos_stret(v9);
    double cosval = v10.__cosval;
    double v7 = v10.__sinval / v9;
    double v5 = 1.0 / v4 * (1.0 - v10.__cosval);
    double v6 = 1.0 / v4 * (1.0 - v10.__sinval / v9);
  }
  else
  {
    double v5 = 0.5 - v4 * (v4 / -720.0 + 0.0416666667);
    double v6 = 0.166666667 - v4 * (v4 / -5040.0 + 0.00833333333);
    double v7 = 1.0 - v4 * v6;
    double cosval = 1.0 - v4 * v5;
  }
  *(double *)&long long v19 = v5;
  *((double *)&v19 + 1) = v6;
  *(double *)&long long v18 = cosval;
  *((double *)&v18 + 1) = v7;
  sub_2153D9ED0((uint64_t)v15, (double *)&v18, v16);
  v17[0] = v16;
  v17[1] = a1;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  sub_2153DA084((double *)&v18, (uint64_t)v17);
  long long v11 = v23;
  a1[4] = v22;
  a1[5] = v11;
  long long v12 = v25;
  a1[6] = v24;
  a1[7] = v12;
  long long v13 = v19;
  *a1 = v18;
  a1[1] = v13;
  long long v14 = v21;
  a1[2] = v20;
  a1[3] = v14;
}

uint64_t sub_2153D9ED0(uint64_t result, double *a2, float64x2_t *a3)
{
  double v3 = *a2;
  double v4 = a2[1];
  double v5 = a2[2];
  double v6 = *(double **)result;
  double v7 = **(double **)result;
  double v8 = v5 * v7;
  double v9 = v5 * *(double *)(*(void *)result + 8);
  double v10 = v5 * *(double *)(*(void *)result + 16);
  a3->f64[0] = *a2 + v8 * v7;
  a3[2].f64[1] = v3 + v9 * v6[1];
  a3[5].f64[0] = v3 + v10 * v6[2];
  double v11 = v6[1];
  double v12 = v8 * v11;
  double v13 = v6[2];
  double v14 = v8 * v13;
  double v15 = v9 * v13;
  double v16 = v4 * *v6;
  double v17 = v4 * v11;
  double v18 = v4 * v13;
  a3[2].f64[0] = v12 - v18;
  a3[4].f64[0] = v17 + v14;
  a3[4].f64[1] = v15 - v16;
  a3->f64[1] = v12 + v18;
  a3[1].f64[0] = v14 - v17;
  a3[3].f64[0] = v15 + v16;
  uint64_t v19 = HIDWORD(*(void *)(result + 8));
  long long v20 = (float64x2_t *)&v6[-v19];
  long long v21 = (float64x2_t *)((char *)v20 + 8 * (v19 + 3));
  double v22 = v6[1];
  double v23 = v6[2];
  double v24 = v21->f64[1];
  double v25 = v21[1].f64[0];
  double v26 = v22 * v25 - v23 * v24;
  double v27 = v23 * v21->f64[0] - *v6 * v25;
  double v28 = *v6 * v24 - v22 * v21->f64[0];
  *(double *)&v36[16] = v28;
  double v30 = a2[2];
  double v29 = a2[3];
  if (v20 == a3)
  {
    double v32 = v25 + v30 * v28;
    float64x2_t v33 = *(float64x2_t *)(v6 + 1);
    v34.i64[1] = (uint64_t)v6[2];
    v34.i64[0] = *(uint64_t *)v6;
    *(void *)&v35.f64[0] = vdupq_laneq_s64(*(int64x2_t *)&v36[8], 1).u64[0];
    v35.f64[1] = v26;
    double v31 = v29 * vmlad_n_f64(-(v33.f64[0] * v26), *v6, *(double *)&v36[8]) + v32;
    a3[6] = vaddq_f64(vaddq_f64(*v21, vmulq_n_f64(*(float64x2_t *)v36, v30)), vmulq_n_f64(vmlaq_f64(vmulq_f64(*(float64x2_t *)&v36[8], vnegq_f64((float64x2_t)vextq_s8(v34, v34, 8uLL))), v35, v33), v29));
  }
  else
  {
    a3[6].f64[0] = v21->f64[0] + v26 * v30 + v29 * (v22 * v28 - v23 * v27);
    a3[6].f64[1] = v21->f64[1] + v27 * v30 + v29 * (v6[2] * v26 - *v6 * v28);
    double v31 = v21[1].f64[0] + v28 * v30 + v29 * (*v6 * v27 - v6[1] * v26);
  }
  a3[7].f64[0] = v31;
  return result;
}

float64_t sub_2153DA084(double *a1, uint64_t a2)
{
  double v3 = *(float64x2_t **)a2;
  if (*(double **)a2 == a1 || (double v4 = *(double **)(a2 + 8), v4 == a1))
  {
    long long v41 = 0u;
    long long v42 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    sub_2153DA084(&v35);
    long long v30 = v40;
    *((_OWORD *)a1 + 4) = v39;
    *((_OWORD *)a1 + 5) = v30;
    long long v31 = v42;
    *((_OWORD *)a1 + 6) = v41;
    *((_OWORD *)a1 + 7) = v31;
    long long v32 = v36;
    *(_OWORD *)a1 = v35;
    *((_OWORD *)a1 + 1) = v32;
    *(void *)&v28.f64[0] = v37;
    long long v33 = v38;
    *((_OWORD *)a1 + 2) = v37;
    *((_OWORD *)a1 + 3) = v33;
  }
  else
  {
    double v5 = *(const double **)(a2 + 8);
    float64x2_t v6 = vld1q_dup_f64(v5++);
    double v7 = v4[2];
    double v8 = v4[3];
    float64x2_t v9 = vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_f64((float64x2_t)0, v6, v3[1]), v3[3], *v5), v3[5], v7), v3[7], v8);
    *(float64x2_t *)a1 = vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_f64((float64x2_t)0, v6, *v3), v3[2], *v5), v3[4], v7), v3[6], v8);
    *((float64x2_t *)a1 + 1) = v9;
    v9.f64[0] = v4[4];
    double v10 = v4[5];
    float64x2_t v11 = vmlaq_n_f64(vmlaq_n_f64((float64x2_t)0, *v3, v9.f64[0]), v3[2], v10);
    float64x2_t v12 = vmlaq_n_f64(vmlaq_n_f64((float64x2_t)0, v3[1], v9.f64[0]), v3[3], v10);
    double v13 = v4[6];
    double v14 = v4[7];
    float64x2_t v15 = vmlaq_n_f64(vmlaq_n_f64(v12, v3[5], v13), v3[7], v14);
    *((float64x2_t *)a1 + 2) = vmlaq_n_f64(vmlaq_n_f64(v11, v3[4], v13), v3[6], v14);
    *((float64x2_t *)a1 + 3) = v15;
    v9.f64[0] = v4[8];
    double v16 = v4[9];
    float64x2_t v17 = vmlaq_n_f64(vmlaq_n_f64((float64x2_t)0, *v3, v9.f64[0]), v3[2], v16);
    float64x2_t v18 = vmlaq_n_f64(vmlaq_n_f64((float64x2_t)0, v3[1], v9.f64[0]), v3[3], v16);
    double v19 = v4[10];
    double v20 = v4[11];
    float64x2_t v21 = vmlaq_n_f64(vmlaq_n_f64(v18, v3[5], v19), v3[7], v20);
    *((float64x2_t *)a1 + 4) = vmlaq_n_f64(vmlaq_n_f64(v17, v3[4], v19), v3[6], v20);
    *((float64x2_t *)a1 + 5) = v21;
    double v22 = v4[12];
    double v23 = v4[13];
    float64x2_t v24 = vmlaq_n_f64(vmlaq_n_f64((float64x2_t)0, *v3, v22), v3[2], v23);
    float64x2_t v25 = vmlaq_n_f64(vmlaq_n_f64((float64x2_t)0, v3[1], v22), v3[3], v23);
    double v26 = v4[14];
    double v27 = v4[15];
    float64x2_t v28 = v3[7];
    float64x2_t v29 = vmlaq_n_f64(vmlaq_n_f64(v25, v3[5], v26), v28, v27);
    *((float64x2_t *)a1 + 6) = vmlaq_n_f64(vmlaq_n_f64(v24, v3[4], v26), v3[6], v27);
    *((float64x2_t *)a1 + 7) = v29;
  }
  return v28.f64[0];
}

double cva::SE3AlgebraStorage<double,cva::MatrixRef<double const,6u,1u,false>>::SE3AlgebraStorage(void *a1, uint64_t a2)
{
  *a1 = a2;
  *(void *)&double result = 6;
  a1[1] = 6;
  return result;
}

{
  double result;

  *a1 = a2;
  *(void *)&double result = 6;
  a1[1] = 6;
  return result;
}

uint64_t cva::SE3AlgebraStorage<double,cva::MatrixRef<double const,6u,1u,false>>::exp@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 64) = xmmword_2154460C0;
  *(_OWORD *)(a2 + 80) = unk_2154460D0;
  *(_OWORD *)(a2 + 96) = xmmword_2154460E0;
  *(_OWORD *)(a2 + 112) = unk_2154460F0;
  *(_OWORD *)a2 = xmmword_215446080;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)algn_215446090;
  *(_OWORD *)(a2 + 32) = xmmword_2154460A0;
  *(_OWORD *)(a2 + 48) = unk_2154460B0;
  double v4 = **(double **)a1 * **(double **)a1
     + *(double *)(*(void *)a1 + 8) * *(double *)(*(void *)a1 + 8)
     + *(double *)(*(void *)a1 + 16) * *(double *)(*(void *)a1 + 16);
  if (v4 >= 0.0000002635)
  {
    double v9 = sqrt(v4);
    __double2 v10 = __sincos_stret(v9);
    double cosval = v10.__cosval;
    double v7 = v10.__sinval / v9;
    double v5 = 1.0 / v4 * (1.0 - v10.__cosval);
    double v6 = 1.0 / v4 * (1.0 - v10.__sinval / v9);
  }
  else
  {
    double v5 = 0.5 - v4 * (v4 / -720.0 + 0.0416666667);
    double v6 = 0.166666667 - v4 * (v4 / -5040.0 + 0.00833333333);
    double v7 = 1.0 - v4 * v6;
    double cosval = 1.0 - v4 * v5;
  }
  void v12[2] = v5;
  v12[3] = v6;
  v12[0] = cosval;
  v12[1] = v7;
  return sub_2153D9ED0(a1, v12, (float64x2_t *)a2);
}

void cva::SE3GroupStorage<double,cva::Matrix<double,4u,4u,false>>::rplus(_OWORD *a1, long long *a2)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  long long v3 = a2[1];
  long long v26 = *a2;
  long long v27 = v3;
  long long v28 = a2[2];
  v15[0] = &v26;
  v15[1] = 6;
  v16[5] = (float64x2_t)unk_2154460D0;
  v16[6] = (float64x2_t)xmmword_2154460E0;
  v16[7] = (float64x2_t)unk_2154460F0;
  v16[0] = (float64x2_t)xmmword_215446080;
  v16[1] = *(float64x2_t *)algn_215446090;
  v16[2] = (float64x2_t)xmmword_2154460A0;
  memset(&v16[3], 0, 32);
  double v4 = *(double *)&v26 * *(double *)&v26
     + *((double *)&v26 + 1) * *((double *)&v26 + 1)
     + *(double *)&v27 * *(double *)&v27;
  if (v4 >= 0.0000002635)
  {
    double v9 = sqrt(v4);
    __double2 v10 = __sincos_stret(v9);
    double cosval = v10.__cosval;
    double v7 = v10.__sinval / v9;
    double v5 = 1.0 / v4 * (1.0 - v10.__cosval);
    double v6 = 1.0 / v4 * (1.0 - v10.__sinval / v9);
  }
  else
  {
    double v5 = 0.5 - v4 * (v4 / -720.0 + 0.0416666667);
    double v6 = 0.166666667 - v4 * (v4 / -5040.0 + 0.00833333333);
    double v7 = 1.0 - v4 * v6;
    double cosval = 1.0 - v4 * v5;
  }
  *(double *)&long long v19 = v5;
  *((double *)&v19 + 1) = v6;
  *(double *)&long long v18 = cosval;
  *((double *)&v18 + 1) = v7;
  sub_2153D9ED0((uint64_t)v15, (double *)&v18, v16);
  v17[0] = a1;
  v17[1] = v16;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  sub_2153DA084((double *)&v18, (uint64_t)v17);
  long long v11 = v23;
  a1[4] = v22;
  a1[5] = v11;
  long long v12 = v25;
  a1[6] = v24;
  a1[7] = v12;
  long long v13 = v19;
  *a1 = v18;
  a1[1] = v13;
  long long v14 = v21;
  a1[2] = v20;
  a1[3] = v14;
}

float64x2_t cva::SE3GroupStorage<double,cva::Matrix<double,4u,4u,false>>::transform@<Q0>(uint64_t a1@<X0>, double *a2@<X1>, void *a3@<X8>)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  v6[0] = a1;
  v6[1] = 4;
  v7[0] = (double *)v6;
  v7[1] = a2;
  float64x2_t v9 = 0uLL;
  double v8 = 0.0;
  sub_2153CCF54(&v8, v7);
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  if ((void *)a1 == a3) {
    a3 = (void *)a1;
  }
  *(double *)a3 = v8 + *(double *)(a1 + 96);
  float64x2_t result = vaddq_f64(v9, *(float64x2_t *)(a1 + 104));
  *(float64x2_t *)(a3 + 1) = result;
  return result;
}

double cva::SE3GroupStorage<double,cva::Matrix<double,4u,4u,false>>::inverseTransform@<D0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, float64x2_t *a3@<X8>)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  v9[0] = a1;
  v9[1] = 4;
  uint64_t v10 = v9;
  v11[0] = (uint64_t *)&v10;
  v11[1] = a2;
  v6[0] = a1;
  v6[1] = 4;
  double v7 = v6;
  v5[0] = a1 + 96;
  v5[1] = 0xC00000004;
  v8[0] = (uint64_t *)&v7;
  v8[1] = v5;
  float64x2_t v12 = 0uLL;
  double v13 = 0.0;
  sub_2153CD09C((uint64_t)&v12, v11);
  float64x2_t v14 = 0uLL;
  double v15 = 0.0;
  sub_2153DA6C4((uint64_t)&v14, v8);
  *a3 = vsubq_f64(v12, v14);
  double result = v13 - v15;
  a3[1].f64[0] = v13 - v15;
  return result;
}

double sub_2153DA6C4(uint64_t a1, uint64_t **a2)
{
  long long v3 = a2[1];
  double v4 = (double *)*v3;
  if (*v3 - 8 * *((unsigned int *)v3 + 3) == a1)
  {
    long long v9 = 0uLL;
    uint64_t v10 = 0;
    sub_2153DA6C4(&v9);
    double result = *(double *)&v9;
    *(_OWORD *)a1 = v9;
    *(void *)(a1 + 16) = v10;
  }
  else
  {
    uint64_t v5 = **a2;
    double v6 = *(double **)v5;
    uint64_t v7 = *(unsigned int *)(v5 + 8);
    *(double *)a1 = v6[1] * v4[1] + *v6 * *v4 + 0.0 + v6[2] * v4[2];
    *(double *)(a1 + 8) = v6[v7 + 1] * v4[1] + v6[v7] * *v4 + 0.0 + v6[(v7 + 2)] * v4[2];
    double result = v6[(2 * v7) + 1] * v4[1]
           + v6[(2 * v7)] * *v4
           + 0.0
           + v6[(2 * v7 + 2)] * v4[2];
    *(double *)(a1 + 16) = result;
  }
  return result;
}

void cva::SE3GroupStorage<double,cva::Matrix<double,4u,4u,false>>::transformJacobian(double *a1@<X1>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 112) = 0u;
  *(_OWORD *)(a2 + 128) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  if (a1 == (double *)a2)
  {
    uint64_t v11 = 0;
    unint64_t v12 = 0;
    v30[0] = 0;
    double v14 = a1[1];
    double v13 = a1[2];
    double v15 = *a1;
    *(double *)&v30[1] = -v13;
    *(double *)&v30[2] = v14;
    *(double *)&v30[3] = v13;
    v30[4] = 0;
    *(double *)&v30[5] = -v15;
    *(double *)&v30[6] = -v14;
    *(double *)&v30[7] = v15;
    v30[8] = 0;
    uint64_t v16 = (double *)v30;
    do
    {
      double v17 = *v16++;
      a1[v11] = v17;
      unint64_t v18 = HIDWORD(v12);
      BOOL v19 = (int)v12 < 2;
      if ((int)v12 < 2) {
        unint64_t v18 = 0;
      }
      uint64_t v20 = v11 + v18;
      uint64_t v21 = (v12 + 1);
      unint64_t v22 = v12 & 0xFFFFFFFF00000000;
      if (!v19) {
        uint64_t v21 = 0;
      }
      unint64_t v12 = v21 | v22;
      uint64_t v11 = v20 + 1;
    }
    while (v11 != 9);
  }
  else
  {
    uint64_t v2 = 0;
    unint64_t v3 = 0;
    unint64_t v4 = 0;
    do
    {
      double v10 = 0.0;
      if (HIDWORD(v4) != v4) {
        double v10 = a1[dword_215446130[(HIDWORD(v4) + 4 * v4)]]
      }
            * dbl_215446160[(HIDWORD(v4) + 4 * v4)];
      *(double *)(a2 + 8 * v2) = v10;
      if ((int)v4 >= 2) {
        unint64_t v4 = (v4 & 0xFFFFFFFF00000000) + 0x100000000;
      }
      else {
        unint64_t v4 = (v4 + 1) | v4 & 0xFFFFFFFF00000000;
      }
      unint64_t v5 = HIDWORD(v3);
      BOOL v6 = (int)v3 < 2;
      if ((int)v3 < 2) {
        unint64_t v5 = 0;
      }
      uint64_t v7 = v2 + v5;
      uint64_t v8 = (v3 + 1);
      unint64_t v9 = v3 & 0xFFFFFFFF00000000;
      if (!v6) {
        uint64_t v8 = 0;
      }
      unint64_t v3 = v8 | v9;
      uint64_t v2 = v7 + 1;
    }
    while (v2 != 9);
  }
  unint64_t v23 = 0;
  for (uint64_t i = 9; i != 18; uint64_t i = v27 + 1)
  {
    *(void *)(a2 + 8 * i) = 0;
    unint64_t v25 = HIDWORD(v23);
    BOOL v26 = (int)v23 < 2;
    if ((int)v23 < 2) {
      unint64_t v25 = 0;
    }
    unint64_t v27 = i + v25;
    uint64_t v28 = (v23 + 1);
    unint64_t v29 = v23 & 0xFFFFFFFF00000000;
    if (!v26) {
      uint64_t v28 = 0;
    }
    unint64_t v23 = v28 | v29;
  }
  *(void *)(a2 + 72) = 0x3FF0000000000000;
  *(void *)(a2 + 104) = 0x3FF0000000000000;
  *(void *)(a2 + 136) = 0x3FF0000000000000;
}

uint64_t cva::SE3GroupStorage<double,cva::Matrix<double,4u,4u,false>>::inverseTransformJacobian@<X0>(double *a1@<X0>, double *a2@<X1>, _OWORD *a3@<X8>)
{
  uint64_t v3 = 0;
  unint64_t v4 = 0;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  double v5 = a1[1];
  double v6 = a1[2];
  double v7 = a1[4];
  double v8 = a1[5];
  double v9 = a1[6];
  double v10 = a1[8];
  double v11 = a1[9];
  double v12 = a1[10];
  double v14 = a2[1];
  double v13 = a2[2];
  double v15 = v5 * v13 - v6 * v14;
  *(double *)&uint64_t v16 = v8 * v13 - v9 * v14;
  double v17 = v11 * v13 - v12 * v14;
  double v18 = v6 * *a2 - *a1 * v13;
  double v19 = v9 * *a2 - v7 * v13;
  double v20 = v12 * *a2 - v10 * v13;
  double v21 = *a1 * v14 - v5 * *a2;
  double v22 = v7 * v14 - v8 * *a2;
  double v23 = v10 * v14 - v11 * *a2;
  double v33 = v15;
  uint64_t v34 = v16;
  double v35 = v17;
  double v36 = v18;
  double v37 = v19;
  double v38 = v20;
  double v39 = v21;
  double v40 = v22;
  double v41 = v23;
  long long v24 = &v33;
  do
  {
    uint64_t v25 = *(void *)v24++;
    *((void *)a3 + v3) = v25;
    unint64_t v26 = HIDWORD(v4);
    BOOL v27 = (int)v4 < 2;
    if ((int)v4 < 2) {
      unint64_t v26 = 0;
    }
    uint64_t v28 = v3 + v26;
    uint64_t v29 = (v4 + 1);
    unint64_t v30 = v4 & 0xFFFFFFFF00000000;
    if (!v27) {
      uint64_t v29 = 0;
    }
    unint64_t v4 = v29 | v30;
    uint64_t v3 = v28 + 1;
  }
  while (v3 != 9);
  double v33 = *(double *)&a1;
  uint64_t v34 = 4;
  v32[0] = (char *)a3 + 72;
  v32[1] = 0x900000003;
  return sub_2153DAA6C((uint64_t)v32, (uint64_t)&v33);
}

uint64_t sub_2153DAA6C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(double **)result;
  uint64_t v3 = *(double **)a2;
  if (*(void *)a2 - 8 * *(unsigned int *)(a2 + 12) == *(void *)result - 8 * *(unsigned int *)(result + 12))
  {
    uint64_t v14 = *(unsigned int *)(a2 + 8);
    double v15 = v3[1];
    double v16 = -v3[v14];
    double v17 = v3[(2 * v14)];
    v30[0] = -*v3;
    v30[1] = v16;
    v30[2] = -v17;
    v30[3] = -v15;
    double v18 = -v3[(2 * v14) | 1u];
    v30[4] = -v3[(v14 + 1)];
    v30[5] = v18;
    double v19 = -v3[(v14 + 2)];
    v30[6] = -v3[2];
    v30[7] = v19;
    v30[8] = -v3[(2 * v14 + 2)];
    int v20 = *(_DWORD *)(result + 8);
    if (v20)
    {
      double v21 = &v2[3 * v20];
      unint64_t v22 = (unint64_t)(v20 - 3) << 32;
      double v23 = v30;
      do
      {
        uint64_t v24 = *(void *)v23++;
        *(void *)uint64_t v2 = v24;
        unint64_t v25 = HIDWORD(v22);
        BOOL v26 = (int)v22 < 2;
        if ((int)v22 < 2) {
          unint64_t v25 = 0;
        }
        BOOL v27 = &v2[v25];
        uint64_t v28 = (v22 + 1);
        unint64_t v29 = v22 & 0xFFFFFFFF00000000;
        if (!v26) {
          uint64_t v28 = 0;
        }
        unint64_t v22 = v28 | v29;
        uint64_t v2 = v27 + 1;
      }
      while (v2 != v21);
    }
  }
  else
  {
    int v4 = *(_DWORD *)(result + 8);
    if (v4)
    {
      unint64_t v5 = 0;
      double v6 = &v2[3 * v4];
      unint64_t v7 = (unint64_t)(v4 - 3) << 32;
      int v8 = *(_DWORD *)(a2 + 8);
      do
      {
        double *v2 = -v3[(HIDWORD(v5) + v8 * v5)];
        if ((int)v5 >= 2) {
          unint64_t v5 = (v5 & 0xFFFFFFFF00000000) + 0x100000000;
        }
        else {
          unint64_t v5 = (v5 + 1) | v5 & 0xFFFFFFFF00000000;
        }
        unint64_t v9 = HIDWORD(v7);
        BOOL v10 = (int)v7 < 2;
        if ((int)v7 < 2) {
          unint64_t v9 = 0;
        }
        double v11 = &v2[v9];
        uint64_t v12 = (v7 + 1);
        unint64_t v13 = v7 & 0xFFFFFFFF00000000;
        if (!v10) {
          uint64_t v12 = 0;
        }
        unint64_t v7 = v12 | v13;
        uint64_t v2 = v11 + 1;
      }
      while (v2 != v6);
    }
  }
  return result;
}

double cva::SE3GroupStorage<double,cva::Matrix<double,4u,4u,false>>::log@<D0>(float64x2_t *a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  sub_2153CCB88(a1->f64, 4u, (double *)a2);
  double v5 = *(double *)a2;
  double v4 = *(double *)(a2 + 8);
  double v6 = *(double *)(a2 + 16);
  double v7 = v5 * v5 + v4 * v4 + v6 * v6;
  if (v7 >= 0.0000002635)
  {
    double v11 = sqrt(v7);
    double v28 = *(double *)a2;
    __double2 v12 = __sincos_stret(v11);
    double v5 = v28;
    double v10 = v12.__sinval / v11;
    double v8 = 1.0 / v7 * (1.0 - v12.__cosval);
    double v9 = 1.0 / v7 * (1.0 - v12.__sinval / v11);
  }
  else
  {
    double v8 = 0.5 - v7 * (v7 / -720.0 + 0.0416666667);
    double v9 = 0.166666667 - v7 * (v7 / -5040.0 + 0.00833333333);
    double v10 = 1.0 - v7 * v9;
  }
  if (v7 >= 2.775e-15)
  {
    if (v7 <= 9.0) {
      double v13 = -(v9 - v8 * 0.5) / v10;
    }
    else {
      double v13 = (v8 + v10 * -0.5) / (v7 * v8);
    }
  }
  else
  {
    double v13 = v7 * 0.00138888889 + 0.0833333333 + v7 * 0.0000330687831;
  }
  double v14 = a1[6].f64[1];
  double v15 = a1[7].f64[0];
  double v16 = a1[6].f64[0];
  v29.f64[0] = v4 * v15 - v6 * v14;
  v29.f64[1] = v6 * v16 - v5 * v15;
  double v30 = v5 * v14 - v4 * v16;
  double v17 = v15 + v30 * -0.5;
  float64x2_t v18 = *(float64x2_t *)(a2 + 8);
  __asm { FMOV            V7.2D, #-0.5 }
  float64x2_t v24 = vaddq_f64(a1[6], vmulq_f64(v29, _Q7));
  v25.i64[1] = *(void *)(a2 + 16);
  *(double *)v25.i64 = v5;
  *(void *)&_Q7.f64[0] = vdupq_laneq_s64(*(int64x2_t *)((char *)&v29 + 8), 1).u64[0];
  _Q7.f64[1] = v29.f64[0];
  float64x2_t v26 = vaddq_f64(v24, vmulq_n_f64(vmlaq_f64(vmulq_f64(*(float64x2_t *)((char *)&v29 + 8), vnegq_f64((float64x2_t)vextq_s8(v25, v25, 8uLL))), _Q7, v18), v13));
  double result = v13 * vmlad_n_f64(-(v18.f64[0] * v29.f64[0]), v5, v29.f64[1]) + v17;
  *(float64x2_t *)(a2 + 24) = v26;
  *(double *)(a2 + 40) = result;
  return result;
}

double cva::SE3AlgebraStorage<double,cva::Matrix<double,6u,1u,false>>::SE3AlgebraStorage(_OWORD *a1)
{
  double result = 0.0;
  a1[1] = 0u;
  a1[2] = 0u;
  *a1 = 0u;
  return result;
}

{
  double result;

  double result = 0.0;
  a1[1] = 0u;
  a1[2] = 0u;
  *a1 = 0u;
  return result;
}

void cva::SE3GroupStorage<double,cva::Matrix<double,4u,4u,false>>::logJacobian(double *a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 328) = 0;
  *(_OWORD *)(a2 + 248) = 0u;
  *(_OWORD *)(a2 + 232) = 0u;
  *(_OWORD *)(a2 + 216) = 0u;
  *(_OWORD *)(a2 + 200) = 0u;
  *(_OWORD *)(a2 + 184) = 0u;
  *(_OWORD *)(a2 + 168) = 0u;
  *(_OWORD *)(a2 + 152) = 0u;
  *(_OWORD *)(a2 + 136) = 0u;
  *(_OWORD *)(a2 + 120) = 0u;
  *(_OWORD *)(a2 + 104) = 0u;
  *(_OWORD *)(a2 + 88) = 0u;
  *(_OWORD *)(a2 + 72) = 0u;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  double v4 = (_OWORD *)(a2 + 24);
  *(_OWORD *)(a2 + 40) = 0u;
  v4[17] = 0u;
  v4[18] = 0u;
  v4[15] = 0u;
  v4[16] = 0u;
  memset(v84, 0, sizeof(v84));
  float64x2_t v83 = 0u;
  memset(v82, 0, sizeof(v82));
  sub_2153CD2E0(a1, 4u, v82[0].f64, &v82[1].f64[1]);
  double v6 = v82[0].f64[1];
  double v5 = v82[0].f64[0];
  *(float64_t *)a2 = v82[0].f64[0];
  *(double *)(a2 + 8) = v6;
  _D11 = v82[1].f64[0];
  *(float64_t *)(a2 + 16) = v82[1].f64[0];
  long long v80 = (float64_t **)(a1 + 12);
  uint64_t v81 = 0xC00000004;
  double v71 = COERCE_DOUBLE((float64x2_t *)&v82[1].f64[1]);
  double v72 = COERCE_DOUBLE(&v80);
  if ((float64x2_t *)&v82[1].f64[1] == (float64x2_t *)a2 || a1 == (double *)a2)
  {
    float64x2_t v85 = 0uLL;
    double v86 = 0.0;
    sub_2153DB29C((uint64_t)&v85, (uint64_t)&v71);
    _Q19 = v85;
    double v12 = v86;
  }
  else
  {
    double v8 = a1[12];
    double v9 = a1[13];
    double v10 = a1[14];
    _Q19 = vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64((float64x2_t)0, *(float64x2_t *)((char *)&v82[1] + 8), v8), v83, v9), *(float64x2_t *)&v84[1], v10);
    double v12 = v82[2].f64[1] * v8 + 0.0 + v84[0] * v9 + v84[3] * v10;
  }
  *(float64x2_t *)(a2 + 24) = _Q19;
  *(double *)(a2 + 40) = v12;
  double v13 = v5 * v5;
  double v14 = v5 * v5 + v6 * v6 + _D11 * _D11;
  if (v14 >= 0.0000002635)
  {
    double v67 = v5;
    double v20 = sqrt(v14);
    float64x2_t v68 = _Q19;
    __double2 v21 = __sincos_stret(v20);
    _Q19 = v68;
    double v22 = v21.__sinval / v20;
    double v5 = v67;
    _D0 = 1.0 / v14 * (1.0 - v21.__cosval);
    double v16 = 1.0 / v14 * (1.0 - v22);
    double v17 = v16 - _D0;
    double v18 = 1.0 / v14 * (v22 + _D0 * -2.0);
    double v19 = 1.0 / v14 * (_D0 + v16 * -3.0);
  }
  else
  {
    _D0 = 0.5 - v14 * (v14 / -720.0 + 0.0416666667);
    double v16 = 0.166666667 - v14 * (v14 / -5040.0 + 0.00833333333);
    double v17 = v14 * (v14 * -0.00119047619 + 0.0333333333) + -0.333333333;
    double v18 = v14 * (v14 * -0.000148809524 + 0.00555555556) + -0.0833333333;
    double v19 = v14 * (v14 * -0.0000165343915 + 0.000793650794) + -0.0166666667;
  }
  uint64_t v23 = 0;
  uint64_t v24 = a2 + 48;
  double v25 = vmuld_lane_f64(v6, _Q19, 1);
  double v26 = v5 * _Q19.f64[0] + v25 + _D11 * v12;
  double v27 = (v17 + v19 * v13) * v26 + (v16 + v16) * (v5 * _Q19.f64[0]);
  double v28 = (v17 + v19 * (v6 * v6)) * v26 + (v16 + v16) * v25;
  double v79 = (v17 + v19 * (_D11 * _D11)) * v26 + (v16 + v16) * (_D11 * v12);
  double v29 = v19 * v26;
  double v30 = v6 * (v5 * (v19 * v26)) + v16 * vmlad_n_f64(vmuld_lane_f64(v5, _Q19, 1), v6, _Q19.f64[0]);
  double v31 = _D11 * (v5 * v29) + v16 * vmlad_n_f64(v5 * v12, _D11, _Q19.f64[0]);
  __asm { FMLA            D17, D11, V19.D[1] }
  double v37 = _D11 * (v6 * v29) + v16 * _D17;
  double v38 = v18 * v26;
  double v39 = _D11 * v38 + _D0 * v12;
  __asm { FMLA            D16, D0, V19.D[1] }
  double v41 = vmlad_n_f64(v5 * v38, _D0, _Q19.f64[0]);
  double v71 = v27;
  double v72 = v39 + v30;
  double v73 = v31 - _D16;
  double v74 = v30 - v39;
  double v77 = _D16 + v31;
  double v78 = v37 - v41;
  double v75 = v28;
  double v76 = v41 + v37;
  unint64_t v42 = 0x300000000;
  uint64_t v43 = 3;
  do
  {
    *(float64_t *)(v24 + 8 * v23) = v82[0].f64[v43];
    unint64_t v44 = HIDWORD(v42);
    BOOL v45 = (int)v42 < 2;
    if ((int)v42 < 2) {
      unint64_t v44 = 0;
    }
    uint64_t v46 = v23 + v44;
    uint64_t v47 = (v42 + 1);
    unint64_t v48 = v42 & 0xFFFFFFFF00000000;
    if (!v45) {
      uint64_t v47 = 0;
    }
    unint64_t v42 = v47 | v48;
    uint64_t v23 = v46 + 1;
    ++v43;
  }
  while (v23 != 18);
  float64x2_t v85 = *(float64x2_t *)(a2 + 48);
  double v49 = *(double *)(a2 + 64);
  long long v87 = *(_OWORD *)(a2 + 96);
  uint64_t v50 = *(void *)(a2 + 112);
  double v86 = v49;
  uint64_t v88 = v50;
  long long v89 = *(_OWORD *)(a2 + 144);
  unint64_t v51 = 0x300000000;
  v52 = &v85;
  uint64_t v53 = 21;
  uint64_t v90 = *(void *)(a2 + 160);
  do
  {
    float64_t v54 = v52->f64[0];
    v52 = (float64x2_t *)((char *)v52 + 8);
    *(float64_t *)(v24 + 8 * v53) = v54;
    unint64_t v55 = HIDWORD(v51);
    BOOL v56 = (int)v51 < 2;
    if ((int)v51 < 2) {
      unint64_t v55 = 0;
    }
    unint64_t v57 = v53 + v55;
    uint64_t v58 = (v51 + 1);
    unint64_t v59 = v51 & 0xFFFFFFFF00000000;
    if (!v56) {
      uint64_t v58 = 0;
    }
    unint64_t v51 = v58 | v59;
    uint64_t v53 = v57 + 1;
  }
  while (v53 != 39);
  long long v80 = &v70;
  uint64_t v81 = (uint64_t)&v71;
  *(void *)&v85.f64[0] = &v80;
  *(void *)&v85.f64[1] = &v82[1].f64[1];
  v69[0] = a2 + 72;
  v69[1] = 0x300000006;
  size_t v70 = &v82[1].f64[1];
  sub_2153DB37C((uint64_t)v69, (uint64_t *)&v85);
  unint64_t v60 = 0x300000000;
  for (uint64_t i = 18; i != 36; uint64_t i = v64 + 1)
  {
    *(void *)(v24 + 8 * i) = 0;
    unint64_t v62 = HIDWORD(v60);
    BOOL v63 = (int)v60 < 2;
    if ((int)v60 < 2) {
      unint64_t v62 = 0;
    }
    unint64_t v64 = i + v62;
    uint64_t v65 = (v60 + 1);
    unint64_t v66 = v60 & 0xFFFFFFFF00000000;
    if (!v63) {
      uint64_t v65 = 0;
    }
    unint64_t v60 = v65 | v66;
  }
}

double sub_2153DB29C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(double **)a2;
  if (*(void *)a2 == a1
    || (v4 = *(void *)(a2 + 8), double v5 = *(double **)v4, *(void *)v4 - 8 * *(unsigned int *)(v4 + 12) == a1))
  {
    long long v7 = 0uLL;
    uint64_t v8 = 0;
    sub_2153DB29C(&v7);
    double result = *(double *)&v7;
    *(_OWORD *)a1 = v7;
    *(void *)(a1 + 16) = v8;
  }
  else
  {
    *(double *)a1 = *v3 * *v5 + 0.0 + v3[3] * v5[1] + v3[6] * v5[2];
    *(double *)(a1 + 8) = v3[1] * *v5 + 0.0 + v3[4] * v5[1] + v3[7] * v5[2];
    double result = v3[2] * *v5 + 0.0 + v3[5] * v5[1] + v3[8] * v5[2];
    *(double *)(a1 + 16) = result;
  }
  return result;
}

void sub_2153DB37C(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = (double *)a2[1];
  uint64_t v4 = *(double **)a1;
  if (v3 == (double *)(*(void *)a1 - 8 * *(unsigned int *)(a1 + 12)))
  {
    double v33 = 0.0;
    long long v31 = 0u;
    long long v32 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    sub_2153DB560((uint64_t)&v29, a2);
    int v18 = *(_DWORD *)(a1 + 8);
    if (v18)
    {
      double v19 = *(double **)a1;
      uint64_t v20 = *(void *)a1 + 8 * (3 * v18);
      unint64_t v21 = (unint64_t)(v18 - 3) << 32;
      double v22 = (uint64_t *)&v29;
      do
      {
        uint64_t v23 = *v22++;
        *(void *)double v19 = v23;
        unint64_t v24 = HIDWORD(v21);
        BOOL v25 = (int)v21 < 2;
        if ((int)v21 < 2) {
          unint64_t v24 = 0;
        }
        double v26 = &v19[v24];
        uint64_t v27 = (v21 + 1);
        unint64_t v28 = v21 & 0xFFFFFFFF00000000;
        if (!v25) {
          uint64_t v27 = 0;
        }
        unint64_t v21 = v27 | v28;
        double v19 = v26 + 1;
      }
      while (v19 != (double *)v20);
    }
  }
  else
  {
    uint64_t v5 = *a2;
    long long v29 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    double v33 = 0.0;
    sub_2153DB6D4((uint64_t)&v29, v5);
    uint64_t v6 = *(unsigned int *)(a1 + 8);
    double v7 = *(double *)&v29;
    double v8 = *((double *)&v30 + 1);
    double v9 = *(double *)&v32;
    double *v4 = *(double *)&v29 * *v3 + 0.0 + *((double *)&v30 + 1) * v3[1] + *(double *)&v32 * v3[2];
    double v10 = *((double *)&v29 + 1);
    double v11 = *(double *)&v31;
    double v12 = *((double *)&v32 + 1);
    v4[1] = *((double *)&v29 + 1) * *v3 + 0.0 + *(double *)&v31 * v3[1] + *((double *)&v32 + 1) * v3[2];
    double v13 = *(double *)&v30;
    double v14 = *((double *)&v31 + 1);
    double v15 = v33;
    v4[2] = *(double *)&v30 * *v3 + 0.0 + *((double *)&v31 + 1) * v3[1] + v33 * v3[2];
    double v16 = &v4[v6];
    double *v16 = v7 * v3[3] + 0.0 + v8 * v3[4] + v9 * v3[5];
    v16[1] = v10 * v3[3] + 0.0 + v11 * v3[4] + v12 * v3[5];
    v16[2] = v13 * v3[3] + 0.0 + v14 * v3[4] + v15 * v3[5];
    double v17 = &v4[(2 * v6)];
    *double v17 = v7 * v3[6] + 0.0 + v8 * v3[7] + v9 * v3[8];
    v17[1] = v10 * v3[6] + 0.0 + v11 * v3[7] + v12 * v3[8];
    void v17[2] = v13 * v3[6] + 0.0 + v14 * v3[7] + v15 * v3[8];
  }
}

__n128 sub_2153DB560(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = (double *)a2[1];
  if (v3 == (double *)a1)
  {
    double v16 = 0.0;
    long long v14 = 0u;
    long long v15 = 0u;
    long long v12 = 0u;
    __n128 v13 = 0u;
    sub_2153DB560(&v12);
    long long v11 = v15;
    *(_OWORD *)(a1 + 32) = v14;
    *(_OWORD *)(a1 + 48) = v11;
    *(double *)(a1 + 64) = v16;
    __n128 result = v13;
    *(_OWORD *)a1 = v12;
    *(__n128 *)(a1 + 16) = result;
  }
  else
  {
    uint64_t v4 = *a2;
    long long v12 = 0u;
    __n128 v13 = 0u;
    long long v14 = 0u;
    long long v15 = 0u;
    double v16 = 0.0;
    sub_2153DB6D4((uint64_t)&v12, v4);
    long long v5 = v12;
    __n128 v6 = v13;
    long long v7 = v15;
    *(double *)a1 = *(double *)&v12 * *v3 + 0.0 + v13.n128_f64[1] * v3[1] + *(double *)&v15 * v3[2];
    long long v8 = v14;
    *(double *)(a1 + 8) = *((double *)&v5 + 1) * *v3 + 0.0 + *(double *)&v14 * v3[1] + *((double *)&v7 + 1) * v3[2];
    double v9 = v16;
    *(double *)(a1 + 16) = v6.n128_f64[0] * *v3 + 0.0 + *((double *)&v8 + 1) * v3[1] + v16 * v3[2];
    *(double *)(a1 + 24) = *(double *)&v5 * v3[3] + 0.0 + v6.n128_f64[1] * v3[4] + *(double *)&v7 * v3[5];
    *(double *)(a1 + 32) = *((double *)&v5 + 1) * v3[3] + 0.0 + *(double *)&v8 * v3[4] + *((double *)&v7 + 1) * v3[5];
    *(double *)(a1 + 40) = v6.n128_f64[0] * v3[3] + 0.0 + *((double *)&v8 + 1) * v3[4] + v9 * v3[5];
    *(double *)(a1 + 48) = *(double *)&v5 * v3[6] + 0.0 + v6.n128_f64[1] * v3[7] + *(double *)&v7 * v3[8];
    *(double *)(a1 + 56) = *((double *)&v5 + 1) * v3[6] + 0.0 + *(double *)&v8 * v3[7] + *((double *)&v7 + 1) * v3[8];
    result.n128_f64[0] = v6.n128_f64[0] * v3[6] + 0.0 + *((double *)&v8 + 1) * v3[7] + v9 * v3[8];
    *(void *)(a1 + 64) = result.n128_u64[0];
  }
  return result;
}

__n128 sub_2153DB6D4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(double **)(a2 + 8);
  if (v3 == (double *)a1)
  {
    uint64_t v20 = 0;
    long long v18 = 0u;
    long long v19 = 0u;
    long long v16 = 0u;
    __n128 v17 = 0u;
    sub_2153DB6D4(&v16);
    long long v15 = v19;
    *(_OWORD *)(a1 + 32) = v18;
    *(_OWORD *)(a1 + 48) = v15;
    *(void *)(a1 + 64) = v20;
    __n128 result = v17;
    *(_OWORD *)a1 = v16;
    *(__n128 *)(a1 + 16) = result;
  }
  else
  {
    uint64_t v4 = **(double ***)a2;
    double v5 = *v4;
    double v6 = v4[1];
    double v7 = v4[2];
    double v8 = v4[3];
    double v9 = v4[4];
    double v10 = v4[5];
    double v11 = v4[6];
    double v12 = v4[7];
    double v13 = v4[8];
    *(double *)a1 = 0.0 - *v4 * *v3 - v8 * v3[1] - v11 * v3[2];
    *(double *)(a1 + 8) = 0.0 - v6 * *v3 - v9 * v3[1] - v12 * v3[2];
    *(double *)(a1 + 16) = 0.0 - v7 * *v3 - v10 * v3[1] - v13 * v3[2];
    *(double *)(a1 + 24) = 0.0 - v5 * v3[3] - v8 * v3[4] - v11 * v3[5];
    *(double *)(a1 + 32) = 0.0 - v6 * v3[3] - v9 * v3[4] - v12 * v3[5];
    *(double *)(a1 + 40) = 0.0 - v7 * v3[3] - v10 * v3[4] - v13 * v3[5];
    *(double *)(a1 + 48) = 0.0 - v5 * v3[6] - v8 * v3[7] - v11 * v3[8];
    *(double *)(a1 + 56) = 0.0 - v6 * v3[6] - v9 * v3[7] - v12 * v3[8];
    result.n128_f64[0] = 0.0 - v7 * v3[6] - v10 * v3[7] - v13 * v3[8];
    *(void *)(a1 + 64) = result.n128_u64[0];
  }
  return result;
}

void cva::SE3GroupStorage<double,cva::Matrix<double,4u,4u,false>>::inverse(double *a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 64) = xmmword_2154460C0;
  *(_OWORD *)(a2 + 80) = unk_2154460D0;
  *(_OWORD *)(a2 + 96) = xmmword_2154460E0;
  *(_OWORD *)(a2 + 112) = unk_2154460F0;
  *(_OWORD *)a2 = xmmword_215446080;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)algn_215446090;
  *(_OWORD *)(a2 + 32) = xmmword_2154460A0;
  *(_OWORD *)(a2 + 48) = unk_2154460B0;
  *(void *)&long long v16 = a1;
  *((void *)&v16 + 1) = 4;
  long long v14 = (uint64_t *)a2;
  uint64_t v15 = 4;
  sub_2153DB944((uint64_t)&v14, (uint64_t)&v16);
  v12[0] = a2;
  v12[1] = 4;
  double v13 = v12;
  v11[0] = a1 + 12;
  v11[1] = 0xC00000004;
  long long v14 = (uint64_t *)&v13;
  uint64_t v15 = (uint64_t)v11;
  if (a1 == (double *)a2)
  {
    long long v16 = 0uLL;
    double v17 = 0.0;
    sub_2153DBA8C((uint64_t)&v16, &v14);
    *(_OWORD *)(a2 + 96) = v16;
    double v10 = v17;
  }
  else
  {
    double v4 = *(double *)(a2 + 16);
    double v5 = *(double *)(a2 + 48);
    double v6 = *(double *)(a2 + 80);
    double v7 = a1[12];
    double v8 = a1[13];
    double v9 = a1[14];
    *(float64x2_t *)(a2 + 96) = vmlsq_lane_f64(vmlsq_lane_f64(vmlsq_lane_f64((float64x2_t)0, *(float64x2_t *)a2, v7, 0), *(float64x2_t *)(a2 + 32), v8, 0), *(float64x2_t *)(a2 + 64), v9, 0);
    double v10 = 0.0 - v4 * v7 - v5 * v8 - v6 * v9;
  }
  *(double *)(a2 + 112) = v10;
}

uint64_t sub_2153DB944(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void **)result;
  uint64_t v3 = *(void **)a2;
  if (*(void *)a2 - 8 * *(unsigned int *)(a2 + 12) == *(void *)result - 8 * *(unsigned int *)(result + 12))
  {
    uint64_t v14 = *(unsigned int *)(a2 + 8);
    uint64_t v15 = v3[v14];
    uint64_t v16 = v3[1];
    v30[0] = *v3;
    v30[1] = v15;
    uint64_t v17 = v3[(v14 + 1)];
    v30[2] = v3[(2 * v14)];
    v30[3] = v16;
    uint64_t v18 = v3[(2 * v14) | 1u];
    v30[4] = v17;
    v30[5] = v18;
    uint64_t v19 = v3[(v14 + 2)];
    v30[6] = v3[2];
    v30[7] = v19;
    v30[8] = v3[(2 * v14 + 2)];
    int v20 = *(_DWORD *)(result + 8);
    if (v20)
    {
      unint64_t v21 = &v2[3 * v20];
      unint64_t v22 = (unint64_t)(v20 - 3) << 32;
      uint64_t v23 = v30;
      do
      {
        uint64_t v24 = *v23++;
        void *v2 = v24;
        unint64_t v25 = HIDWORD(v22);
        BOOL v26 = (int)v22 < 2;
        if ((int)v22 < 2) {
          unint64_t v25 = 0;
        }
        uint64_t v27 = &v2[v25];
        uint64_t v28 = (v22 + 1);
        unint64_t v29 = v22 & 0xFFFFFFFF00000000;
        if (!v26) {
          uint64_t v28 = 0;
        }
        unint64_t v22 = v28 | v29;
        uint64_t v2 = v27 + 1;
      }
      while (v2 != v21);
    }
  }
  else
  {
    int v4 = *(_DWORD *)(result + 8);
    if (v4)
    {
      unint64_t v5 = 0;
      double v6 = &v2[3 * v4];
      unint64_t v7 = (unint64_t)(v4 - 3) << 32;
      int v8 = *(_DWORD *)(a2 + 8);
      do
      {
        void *v2 = v3[(HIDWORD(v5) + v8 * v5)];
        if ((int)v5 >= 2) {
          unint64_t v5 = (v5 & 0xFFFFFFFF00000000) + 0x100000000;
        }
        else {
          unint64_t v5 = (v5 + 1) | v5 & 0xFFFFFFFF00000000;
        }
        unint64_t v9 = HIDWORD(v7);
        BOOL v10 = (int)v7 < 2;
        if ((int)v7 < 2) {
          unint64_t v9 = 0;
        }
        double v11 = &v2[v9];
        uint64_t v12 = (v7 + 1);
        unint64_t v13 = v7 & 0xFFFFFFFF00000000;
        if (!v10) {
          uint64_t v12 = 0;
        }
        unint64_t v7 = v12 | v13;
        uint64_t v2 = v11 + 1;
      }
      while (v2 != v6);
    }
  }
  return result;
}

double sub_2153DBA8C(uint64_t a1, uint64_t **a2)
{
  uint64_t v3 = a2[1];
  int v4 = (double *)*v3;
  if (*v3 - 8 * *((unsigned int *)v3 + 3) == a1)
  {
    long long v19 = 0uLL;
    uint64_t v20 = 0;
    sub_2153DBA8C(&v19);
    double result = *(double *)&v19;
    *(_OWORD *)a1 = v19;
    *(void *)(a1 + 16) = v20;
  }
  else
  {
    uint64_t v5 = **a2;
    double v6 = *(double **)v5;
    double v7 = **(double **)v5;
    double v8 = *(double *)(*(void *)v5 + 8);
    double v9 = *(double *)(*(void *)v5 + 16);
    uint64_t v10 = (*(_DWORD *)(v5 + 8) - 3);
    double v11 = &v6[v10];
    double v12 = v11[3];
    double v13 = v11[4];
    v11 += 3;
    double v14 = v11[2];
    uint64_t v15 = &v11[v10];
    double v16 = v15[4];
    double v17 = v15[5];
    *(double *)a1 = 0.0 - v7 * *v4 - v12 * v4[1] - v15[3] * v4[2];
    *(double *)(a1 + 8) = 0.0 - v8 * *v4 - v13 * v4[1] - v16 * v4[2];
    double result = 0.0 - v9 * *v4 - v14 * v4[1] - v17 * v4[2];
    *(double *)(a1 + 16) = result;
  }
  return result;
}

double *cva::SE3GroupStorage<double,cva::Matrix<double,4u,4u,false>>::adjoint@<X0>(double *result@<X0>, double *a2@<X8>)
{
  *((_OWORD *)a2 + 16) = 0u;
  *((_OWORD *)a2 + 17) = 0u;
  *((_OWORD *)a2 + 14) = 0u;
  *((_OWORD *)a2 + 15) = 0u;
  *((_OWORD *)a2 + 12) = 0u;
  *((_OWORD *)a2 + 13) = 0u;
  *((_OWORD *)a2 + 10) = 0u;
  *((_OWORD *)a2 + 11) = 0u;
  *((_OWORD *)a2 + 8) = 0u;
  *((_OWORD *)a2 + 9) = 0u;
  *((_OWORD *)a2 + 6) = 0u;
  *((_OWORD *)a2 + 7) = 0u;
  *((_OWORD *)a2 + 4) = 0u;
  *((_OWORD *)a2 + 5) = 0u;
  *((_OWORD *)a2 + 2) = 0u;
  *((_OWORD *)a2 + 3) = 0u;
  *(_OWORD *)a2 = 0u;
  *((_OWORD *)a2 + 1) = 0u;
  if (result == a2)
  {
    uint64_t v22 = 0;
    long long v70 = *(_OWORD *)result;
    double v71 = result[2];
    long long v72 = *((_OWORD *)result + 2);
    double v73 = result[6];
    long long v74 = *((_OWORD *)result + 4);
    unint64_t v23 = 0x300000000;
    uint64_t v24 = (uint64_t *)&v70;
    double v75 = result[10];
    do
    {
      double v25 = *(double *)v24++;
      result[v22] = v25;
      unint64_t v26 = HIDWORD(v23);
      BOOL v27 = (int)v23 < 2;
      if ((int)v23 < 2) {
        unint64_t v26 = 0;
      }
      uint64_t v28 = v22 + v26;
      uint64_t v29 = (v23 + 1);
      unint64_t v30 = v23 & 0xFFFFFFFF00000000;
      if (!v27) {
        uint64_t v29 = 0;
      }
      unint64_t v23 = v29 | v30;
      uint64_t v22 = v28 + 1;
    }
    while (v22 != 18);
    long long v16 = 0uLL;
    double v21 = 0.0;
    double v19 = 0.0;
    double v17 = 0.0;
    long long v18 = 0uLL;
    long long v20 = 0uLL;
  }
  else
  {
    uint64_t v2 = 0;
    unint64_t v3 = 0x100000000;
    unint64_t v4 = 0x300000000;
    uint64_t v5 = result;
    do
    {
      a2[v2] = *v5;
      unint64_t v6 = HIDWORD(v3);
      BOOL v7 = (int)v3 < 2;
      if ((int)v3 < 2) {
        unint64_t v6 = 0;
      }
      double v8 = &v5[v6];
      uint64_t v9 = (v3 + 1);
      unint64_t v10 = v3 & 0xFFFFFFFF00000000;
      if (!v7) {
        uint64_t v9 = 0;
      }
      unint64_t v3 = v9 | v10;
      uint64_t v5 = v8 + 1;
      unint64_t v11 = HIDWORD(v4);
      BOOL v12 = (int)v4 < 2;
      if ((int)v4 < 2) {
        unint64_t v11 = 0;
      }
      uint64_t v13 = v2 + v11;
      uint64_t v14 = (v4 + 1);
      unint64_t v15 = v4 & 0xFFFFFFFF00000000;
      if (!v12) {
        uint64_t v14 = 0;
      }
      unint64_t v4 = v14 | v15;
      uint64_t v2 = v13 + 1;
    }
    while (v2 != 18);
    long long v16 = *(_OWORD *)a2;
    double v17 = a2[2];
    long long v18 = *((_OWORD *)a2 + 3);
    double v19 = a2[8];
    long long v20 = *((_OWORD *)a2 + 6);
    double v21 = a2[14];
  }
  long long v70 = v16;
  double v71 = v17;
  long long v72 = v18;
  double v73 = v19;
  long long v74 = v20;
  unint64_t v31 = 0x300000000;
  long long v32 = (uint64_t *)&v70;
  uint64_t v33 = 21;
  double v75 = v21;
  do
  {
    double v34 = *(double *)v32++;
    a2[v33] = v34;
    unint64_t v35 = HIDWORD(v31);
    BOOL v36 = (int)v31 < 2;
    if ((int)v31 < 2) {
      unint64_t v35 = 0;
    }
    unint64_t v37 = v33 + v35;
    uint64_t v38 = (v31 + 1);
    unint64_t v39 = v31 & 0xFFFFFFFF00000000;
    if (!v36) {
      uint64_t v38 = 0;
    }
    unint64_t v31 = v38 | v39;
    uint64_t v33 = v37 + 1;
  }
  while (v33 != 39);
  double v40 = result[12];
  double v41 = result[13];
  double v42 = result[14];
  double v43 = result[1];
  double v44 = result[2];
  double v45 = result[4];
  double v46 = result[5];
  double v47 = result[6];
  double v48 = result[8];
  double v49 = result[9];
  double v50 = result[10];
  double v51 = v41 * v44 - v42 * v43;
  double v52 = v42 * *result - v40 * v44;
  double v53 = v40 * v43 - v41 * *result;
  *(double *)&long long v70 = v51;
  *((double *)&v70 + 1) = v52;
  double v71 = v53;
  *(double *)&long long v72 = v41 * v47 - v42 * v46;
  *((double *)&v72 + 1) = v42 * v45 - v40 * v47;
  double v73 = v40 * v46 - v41 * v45;
  *(double *)&long long v74 = v41 * v50 - v42 * v49;
  *((double *)&v74 + 1) = v42 * v48 - v40 * v50;
  double v75 = v40 * v49 - v41 * v48;
  unint64_t v54 = 0x300000000;
  unint64_t v55 = (uint64_t *)&v70;
  for (uint64_t i = 3; i != 21; uint64_t i = v60 + 1)
  {
    double v57 = *(double *)v55++;
    a2[i] = v57;
    unint64_t v58 = HIDWORD(v54);
    BOOL v59 = (int)v54 < 2;
    if ((int)v54 < 2) {
      unint64_t v58 = 0;
    }
    unint64_t v60 = i + v58;
    uint64_t v61 = (v54 + 1);
    unint64_t v62 = v54 & 0xFFFFFFFF00000000;
    if (!v59) {
      uint64_t v61 = 0;
    }
    unint64_t v54 = v61 | v62;
  }
  unint64_t v63 = 0x300000000;
  for (uint64_t j = 18; j != 36; uint64_t j = v67 + 1)
  {
    a2[j] = 0.0;
    unint64_t v65 = HIDWORD(v63);
    BOOL v66 = (int)v63 < 2;
    if ((int)v63 < 2) {
      unint64_t v65 = 0;
    }
    unint64_t v67 = j + v65;
    uint64_t v68 = (v63 + 1);
    unint64_t v69 = v63 & 0xFFFFFFFF00000000;
    if (!v66) {
      uint64_t v68 = 0;
    }
    unint64_t v63 = v68 | v69;
  }
  return result;
}

void cva::SE3GroupStorage<double,cva::Matrix<double,4u,4u,false>>::enforce()
{
}

uint64_t sub_2153DBF80(uint64_t result, double *a2, float64x2_t *a3)
{
  double v3 = *a2;
  double v4 = a2[1];
  double v5 = a2[2];
  double v6 = v5 * *(double *)result;
  double v7 = v5 * *(double *)(result + 8);
  double v8 = v5 * *(double *)(result + 16);
  a3->f64[0] = *a2 + v6 * *(double *)result;
  a3[2].f64[1] = v3 + v7 * *(double *)(result + 8);
  a3[5].f64[0] = v3 + v8 * *(double *)(result + 16);
  double v9 = *(double *)(result + 8);
  double v10 = v6 * v9;
  double v11 = *(double *)(result + 16);
  double v12 = v6 * v11;
  double v13 = v7 * v11;
  double v14 = v4 * *(double *)result;
  double v15 = v4 * v9;
  double v16 = v4 * v11;
  a3[2].f64[0] = v10 - v16;
  a3[4].f64[0] = v15 + v12;
  a3[4].f64[1] = v13 - v14;
  a3->f64[1] = v10 + v16;
  a3[1].f64[0] = v12 - v15;
  a3[3].f64[0] = v13 + v14;
  double v18 = *(double *)(result + 16);
  double v17 = *(double *)(result + 24);
  double v19 = *(double *)(result + 32);
  double v20 = *(double *)(result + 40);
  double v21 = *(double *)(result + 8);
  double v22 = v21 * v20 - v18 * v19;
  double v23 = v18 * v17 - *(double *)result * v20;
  double v24 = *(double *)result * v19 - v21 * v17;
  *(double *)&v32[16] = v24;
  double v26 = a2[2];
  double v25 = a2[3];
  if ((float64x2_t *)result == a3)
  {
    double v28 = v20 + v26 * v24;
    float64x2_t v29 = *(float64x2_t *)(result + 8);
    v30.i64[1] = *(void *)(result + 16);
    v30.i64[0] = *(void *)result;
    *(void *)&v31.f64[0] = vdupq_laneq_s64(*(int64x2_t *)&v32[8], 1).u64[0];
    v31.f64[1] = v22;
    double v27 = v25 * vmlad_n_f64(-(v29.f64[0] * v22), *(double *)result, *(double *)&v32[8]) + v28;
    a3[6] = vaddq_f64(vaddq_f64(*(float64x2_t *)(result + 24), vmulq_n_f64(*(float64x2_t *)v32, v26)), vmulq_n_f64(vmlaq_f64(vmulq_f64(*(float64x2_t *)&v32[8], vnegq_f64((float64x2_t)vextq_s8(v30, v30, 8uLL))), v31, v29), v25));
  }
  else
  {
    a3[6].f64[0] = v17 + v22 * v26 + v25 * (v21 * v24 - v18 * v23);
    a3[6].f64[1] = *(double *)(result + 32)
                 + v23 * v26
                 + v25 * (*(double *)(result + 16) * v22 - *(double *)result * v24);
    double v27 = *(double *)(result + 40) + v24 * v26 + v25 * (*(double *)result * v23 - *(double *)(result + 8) * v22);
  }
  a3[7].f64[0] = v27;
  return result;
}

uint64_t cva::SE3AlgebraStorage<double,cva::Matrix<double,6u,1u,false>>::exp@<X0>(double *a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 64) = xmmword_2154460C0;
  *(_OWORD *)(a2 + 80) = unk_2154460D0;
  *(_OWORD *)(a2 + 96) = xmmword_2154460E0;
  *(_OWORD *)(a2 + 112) = unk_2154460F0;
  *(_OWORD *)a2 = xmmword_215446080;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)algn_215446090;
  *(_OWORD *)(a2 + 32) = xmmword_2154460A0;
  *(_OWORD *)(a2 + 48) = unk_2154460B0;
  double v4 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
  if (v4 >= 0.0000002635)
  {
    double v9 = sqrt(v4);
    __double2 v10 = __sincos_stret(v9);
    double cosval = v10.__cosval;
    double v7 = v10.__sinval / v9;
    double v5 = 1.0 / v4 * (1.0 - v10.__cosval);
    double v6 = 1.0 / v4 * (1.0 - v10.__sinval / v9);
  }
  else
  {
    double v5 = 0.5 - v4 * (v4 / -720.0 + 0.0416666667);
    double v6 = 0.166666667 - v4 * (v4 / -5040.0 + 0.00833333333);
    double v7 = 1.0 - v4 * v6;
    double cosval = 1.0 - v4 * v5;
  }
  void v12[2] = v5;
  v12[3] = v6;
  v12[0] = cosval;
  v12[1] = v7;
  return sub_2153DBF80((uint64_t)a1, v12, (float64x2_t *)a2);
}

uint64_t cva::SE3GroupStorage<double,cva::Matrix<double,4u,4u,false>>::serialize()
{
  return std::ostream::write();
}

uint64_t cva::SE3GroupStorage<double,cva::Matrix<double,4u,4u,false>>::deserialize(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x270F98678](a2, a1, 128);
}

double cva::SE3GroupStorage<float,cva::MatrixRef<float const,4u,4u,false>>::SE3GroupStorage(void *a1, uint64_t a2)
{
  *a1 = a2;
  *(void *)&double result = 4;
  a1[1] = 4;
  return result;
}

{
  double result;

  *a1 = a2;
  *(void *)&double result = 4;
  a1[1] = 4;
  return result;
}

{
  double result;

  *a1 = a2;
  *(void *)&double result = 4;
  a1[1] = 4;
  return result;
}

{
  double result;

  *a1 = a2;
  *(void *)&double result = 4;
  a1[1] = 4;
  return result;
}

uint64_t cva::SE3GroupStorage<float,cva::MatrixRef<float const,4u,4u,false>>::R(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t cva::SE3GroupStorage<float,cva::MatrixRef<float const,4u,4u,false>>::T(uint64_t a1)
{
  return *(void *)a1
       - 4 * *(unsigned int *)(a1 + 12)
       + 4 * (3 * *(_DWORD *)(a1 + 8) + *(_DWORD *)(a1 + 12));
}

uint64_t *cva::SE3GroupStorage<float,cva::MatrixRef<float const,4u,4u,false>>::affine@<X0>(uint64_t *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = (int *)*result;
  int v4 = *((_DWORD *)result + 2);
  uint64_t v3 = *((unsigned int *)result + 3);
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  double v5 = &v2[-v3];
  uint64_t v6 = (v4 - 3);
  int v7 = *v2;
  if (v5 == (int *)a2)
  {
    *(void *)&long long v14 = *(void *)(v2 + 1);
    uint64_t v15 = v6;
    double v16 = &v2[v15];
    uint64_t v17 = *(void *)(v16 + 3);
    v16 += 3;
    uint64_t v18 = v17;
    int v19 = v16[2];
    double v20 = &v16[v15];
    LODWORD(v17) = v20[3];
    v20 += 3;
    *(void *)&long long v21 = *(void *)(v20 + 1);
    double v22 = &v20[v15];
    uint64_t v23 = *(void *)(v22 + 3);
    int v24 = v22[5];
    *(_DWORD *)a2 = v7;
    *((void *)&v14 + 1) = v18;
    *(_OWORD *)(a2 + 4) = v14;
    *(_DWORD *)(a2 + 20) = v19;
    *(_DWORD *)(a2 + 24) = v17;
    *((void *)&v21 + 1) = v23;
    *(_OWORD *)(a2 + 28) = v21;
    *(_DWORD *)(a2 + 44) = v24;
  }
  else
  {
    *(_DWORD *)a2 = v7;
    *(_DWORD *)(a2 + 4) = v2[1];
    *(_DWORD *)(a2 + 8) = v2[2];
    uint64_t v8 = v6;
    double v9 = &v2[v8];
    int v10 = v9[3];
    v9 += 3;
    *(_DWORD *)(a2 + 12) = v10;
    *(_DWORD *)(a2 + 16) = v9[1];
    *(_DWORD *)(a2 + 20) = v9[2];
    double v11 = &v9[v8];
    int v12 = v11[3];
    v11 += 3;
    *(_DWORD *)(a2 + 24) = v12;
    *(_DWORD *)(a2 + 28) = v11[1];
    *(_DWORD *)(a2 + 32) = v11[2];
    double v13 = &v11[v8];
    *(_DWORD *)(a2 + 36) = v13[3];
    *(_DWORD *)(a2 + 40) = v13[4];
    *(_DWORD *)(a2 + 44) = v13[5];
  }
  return result;
}

float *cva::SE3GroupStorage<float,cva::MatrixRef<float const,4u,4u,false>>::transform@<X0>(void *a1@<X0>, float *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v4 = a1[1];
  v11[0] = *a1;
  v11[1] = v4;
  v12[0] = (float *)v11;
  v12[1] = a2;
  uint64_t v5 = v11[0] - 4 * HIDWORD(v4);
  uint64_t v6 = v5 + 4 * (3 * v4 + HIDWORD(v4));
  memset(v13, 0, 12);
  double result = sub_2153CC420((float *)v13, v12);
  *(_DWORD *)(a3 + 8) = 0;
  *(void *)a3 = 0;
  float v8 = v13[0].f32[0] + *(float *)v6;
  if (v5 == a3)
  {
    float32x2_t v10 = vadd_f32(*(float32x2_t *)((char *)v13 + 4), *(float32x2_t *)(v6 + 4));
    *(float *)a3 = v8;
    *(float32x2_t *)(a3 + 4) = v10;
  }
  else
  {
    *(float *)a3 = v8;
    float v9 = v13[1].f32[0];
    *(float *)(a3 + 4) = v13[0].f32[1] + *(float *)(v6 + 4);
    *(float *)(a3 + 8) = v9 + *(float *)(v6 + 8);
  }
  return result;
}

float cva::SE3GroupStorage<float,cva::MatrixRef<float const,4u,4u,false>>::inverseTransform@<S0>(void *a1@<X0>, uint64_t *a2@<X1>, float32x2_t *a3@<X8>)
{
  unint64_t v4 = a1[1];
  v12[0] = *a1;
  v12[1] = v4;
  double v13 = v12;
  v14[0] = (uint64_t *)&v13;
  v14[1] = a2;
  v9[0] = v12[0];
  v9[1] = v4;
  float32x2_t v10 = v9;
  uint64_t v6 = v12[0] - 4 * HIDWORD(v4) + 4 * (3 * v4 + HIDWORD(v4));
  int v7 = v4;
  int v8 = 3 * v4 + HIDWORD(v4);
  v11[0] = (uint64_t *)&v10;
  v11[1] = &v6;
  float v16 = 0.0;
  float32x2_t v15 = 0;
  sub_2153CC568((float *)&v15, v14);
  float v18 = 0.0;
  float32x2_t v17 = 0;
  sub_2153D7FB4((float *)&v17, v11);
  *a3 = vsub_f32(v15, v17);
  float result = v16 - v18;
  a3[1].f32[0] = v16 - v18;
  return result;
}

void cva::SE3GroupStorage<float,cva::MatrixRef<float const,4u,4u,false>>::transformJacobian(float *a1@<X1>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 64) = 0;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  if (a1 == (float *)a2)
  {
    uint64_t v11 = 0;
    unint64_t v12 = 0;
    v30[0] = 0;
    float v14 = a1[1];
    float v13 = a1[2];
    float v15 = *a1;
    *(float *)&v30[1] = -v13;
    *(float *)&v30[2] = v14;
    *(float *)&v30[3] = v13;
    v30[4] = 0;
    *(float *)&v30[5] = -v15;
    *(float *)&v30[6] = -v14;
    *(float *)&v30[7] = v15;
    v30[8] = 0;
    float v16 = (float *)v30;
    do
    {
      float v17 = *v16++;
      a1[v11] = v17;
      unint64_t v18 = HIDWORD(v12);
      BOOL v19 = (int)v12 < 2;
      if ((int)v12 < 2) {
        unint64_t v18 = 0;
      }
      uint64_t v20 = v11 + v18;
      uint64_t v21 = (v12 + 1);
      unint64_t v22 = v12 & 0xFFFFFFFF00000000;
      if (!v19) {
        uint64_t v21 = 0;
      }
      unint64_t v12 = v21 | v22;
      uint64_t v11 = v20 + 1;
    }
    while (v11 != 9);
  }
  else
  {
    uint64_t v2 = 0;
    unint64_t v3 = 0;
    unint64_t v4 = 0;
    do
    {
      float v10 = 0.0;
      if (HIDWORD(v4) != v4) {
        float v10 = a1[dword_215446130[(HIDWORD(v4) + 4 * v4)]]
      }
            * flt_215446100[(HIDWORD(v4) + 4 * v4)];
      *(float *)(a2 + 4 * v2) = v10;
      if ((int)v4 >= 2) {
        unint64_t v4 = (v4 & 0xFFFFFFFF00000000) + 0x100000000;
      }
      else {
        unint64_t v4 = (v4 + 1) | v4 & 0xFFFFFFFF00000000;
      }
      unint64_t v5 = HIDWORD(v3);
      BOOL v6 = (int)v3 < 2;
      if ((int)v3 < 2) {
        unint64_t v5 = 0;
      }
      uint64_t v7 = v2 + v5;
      uint64_t v8 = (v3 + 1);
      unint64_t v9 = v3 & 0xFFFFFFFF00000000;
      if (!v6) {
        uint64_t v8 = 0;
      }
      unint64_t v3 = v8 | v9;
      uint64_t v2 = v7 + 1;
    }
    while (v2 != 9);
  }
  unint64_t v23 = 0;
  for (uint64_t i = 9; i != 18; uint64_t i = v27 + 1)
  {
    *(_DWORD *)(a2 + 4 * i) = 0;
    unint64_t v25 = HIDWORD(v23);
    BOOL v26 = (int)v23 < 2;
    if ((int)v23 < 2) {
      unint64_t v25 = 0;
    }
    unint64_t v27 = i + v25;
    uint64_t v28 = (v23 + 1);
    unint64_t v29 = v23 & 0xFFFFFFFF00000000;
    if (!v26) {
      uint64_t v28 = 0;
    }
    unint64_t v23 = v28 | v29;
  }
  *(_DWORD *)(a2 + 36) = 1065353216;
  *(_DWORD *)(a2 + 52) = 1065353216;
  *(_DWORD *)(a2 + 68) = 1065353216;
}

uint64_t cva::SE3GroupStorage<float,cva::MatrixRef<float const,4u,4u,false>>::inverseTransformJacobian@<X0>(uint64_t a1@<X0>, float *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3 = 0;
  unint64_t v4 = 0;
  *(void *)(a3 + 64) = 0;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  unint64_t v5 = *(float **)a1;
  unint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = (v6 - 3);
  uint64_t v8 = (float *)(*(void *)a1 + v7 * 4);
  float v9 = v8[3];
  float v10 = v8[4];
  v8 += 3;
  float v11 = v8[2];
  unint64_t v12 = &v8[v7];
  float v13 = v12[3];
  float v14 = v12[4];
  float v15 = v12[5];
  float v16 = **(float **)a1;
  float v17 = *(float *)(*(void *)a1 + 4);
  float v18 = *(float *)(*(void *)a1 + 8);
  float v20 = a2[1];
  float v19 = a2[2];
  *(float *)&unsigned int v21 = (float)(v17 * v19) - (float)(v18 * v20);
  *(float *)&unsigned int v22 = (float)(v10 * v19) - (float)(v11 * v20);
  *(float *)&unsigned int v23 = (float)(v14 * v19) - (float)(v15 * v20);
  *(float *)&unsigned int v24 = (float)(v18 * *a2) - (float)(v16 * v19);
  float v25 = (float)(v11 * *a2) - (float)(v9 * v19);
  float v26 = (float)(v15 * *a2) - (float)(v13 * v19);
  float v27 = (float)(v16 * v20) - (float)(v17 * *a2);
  float v28 = (float)(v9 * v20) - (float)(v10 * *a2);
  float v29 = (float)(v13 * v20) - (float)(v14 * *a2);
  unint64_t v39 = __PAIR64__(v22, v21);
  unint64_t v40 = __PAIR64__(v24, v23);
  float v41 = v25;
  float v42 = v26;
  float v43 = v27;
  float v44 = v28;
  float v45 = v29;
  int8x16_t v30 = &v39;
  do
  {
    int v31 = *(_DWORD *)v30;
    int8x16_t v30 = (unint64_t *)((char *)v30 + 4);
    *(_DWORD *)(a3 + 4 * v3) = v31;
    unint64_t v32 = HIDWORD(v4);
    BOOL v33 = (int)v4 < 2;
    if ((int)v4 < 2) {
      unint64_t v32 = 0;
    }
    uint64_t v34 = v3 + v32;
    uint64_t v35 = (v4 + 1);
    unint64_t v36 = v4 & 0xFFFFFFFF00000000;
    if (!v33) {
      uint64_t v35 = 0;
    }
    unint64_t v4 = v35 | v36;
    uint64_t v3 = v34 + 1;
  }
  while (v3 != 9);
  unint64_t v39 = (unint64_t)v5;
  unint64_t v40 = v6;
  v38[0] = a3 + 36;
  v38[1] = 0x900000003;
  return sub_2153D8350((uint64_t)v38, (uint64_t)&v39);
}

void cva::SE3GroupStorage<float,cva::MatrixRef<float const,4u,4u,false>>::log(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  unint64_t v4 = *(float **)a1;
  unint64_t v3 = *(void *)(a1 + 8);
  sub_2153CC034(*(float **)a1, v3, (float *)a2);
  float v5 = *(float *)a2;
  float v6 = *(float *)(a2 + 4);
  float v7 = *(float *)(a2 + 8);
  float v8 = (float)((float)(v5 * v5) + (float)(v6 * v6)) + (float)(v7 * v7);
  if (v8 >= 0.0061)
  {
    float v12 = sqrtf(v8);
    __float2 v13 = __sincosf_stret(v12);
    float v11 = v13.__sinval / v12;
    float v9 = (float)(1.0 / v8) * (float)(1.0 - v13.__cosval);
    float v10 = (float)(1.0 / v8) * (float)(1.0 - (float)(v13.__sinval / v12));
  }
  else
  {
    float v9 = 0.5 - (float)(v8 * (float)((float)(v8 / -720.0) + 0.041667));
    float v10 = 0.16667 - (float)(v8 * (float)((float)(v8 / -5040.0) + 0.0083333));
    float v11 = 1.0 - (float)(v8 * v10);
  }
  if (v8 >= 0.00000149)
  {
    if (v8 <= 9.0) {
      float v14 = (float)-(float)(v10 - (float)(v9 * 0.5)) / v11;
    }
    else {
      float v14 = (float)(v9 + (float)(v11 * -0.5)) / (float)(v8 * v9);
    }
  }
  else
  {
    float v14 = (float)((float)(v8 * 0.0013889) + 0.083333) + (float)(v8 * 0.000033069);
  }
  float v15 = (float32x2_t *)&v4[(3 * v3 + HIDWORD(v3)) - HIDWORD(v3)];
  float v16 = v15->f32[1];
  float v17 = v15[1].f32[0];
  *(float *)v24.i32 = (float)(v7 * v15->f32[0]) - (float)(v5 * v17);
  *(float *)&v24.i32[1] = (float)(v5 * v16) - (float)(v6 * v15->f32[0]);
  float32x2_t v18 = *(float32x2_t *)(a2 + 4);
  v19.i32[1] = v18.i32[1];
  v19.i32[0] = *(_DWORD *)a2;
  v20.i32[0] = vdup_lane_s32(v24, 1).u32[0];
  v20.f32[1] = (float)(v6 * v17) - (float)(v7 * v16);
  float32_t v23 = v20.f32[1];
  float32x2_t v21 = vadd_f32(vadd_f32(*v15, vmul_f32(*(float32x2_t *)((char *)&v24 - 4), (float32x2_t)0xBF000000BF000000)), vmul_n_f32(vmla_f32(vmul_f32((float32x2_t)v24, vneg_f32((float32x2_t)vrev64_s32(v19))), v20, v18), v14));
  float v22 = (float)(v14 * vmlas_n_f32(-(float)(v18.f32[0] * v20.f32[1]), *(float *)a2, *(float *)v24.i32))
      + (float)(v17 + (float)(*(float *)&v24.i32[1] * -0.5));
  *(float32x2_t *)(a2 + 12) = v21;
  *(float *)(a2 + 20) = v22;
}

void cva::SE3GroupStorage<float,cva::MatrixRef<float const,4u,4u,false>>::logJacobian(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 152) = 0u;
  *(_OWORD *)(a2 + 140) = 0u;
  *(_OWORD *)(a2 + 124) = 0u;
  *(_OWORD *)(a2 + 108) = 0u;
  *(_OWORD *)(a2 + 92) = 0u;
  *(_OWORD *)(a2 + 76) = 0u;
  *(_OWORD *)(a2 + 60) = 0u;
  *(_OWORD *)(a2 + 44) = 0u;
  *(_OWORD *)(a2 + 28) = 0u;
  *(_OWORD *)(a2 + 12) = 0u;
  unint64_t v3 = *(float **)a1;
  unint64_t v4 = *(void *)(a1 + 8);
  long long v83 = 0u;
  memset(v82, 0, sizeof(v82));
  sub_2153CC7A4(v3, v4, (float *)v82, (float *)((unint64_t)v82 | 0xC));
  float v6 = *((float *)v82 + 1);
  float v5 = *(float *)v82;
  *(_DWORD *)a2 = v82[0];
  *(float *)(a2 + 4) = v6;
  _S11 = *((float *)v82 + 2);
  *(_DWORD *)(a2 + 8) = DWORD2(v82[0]);
  float v8 = &v3[-HIDWORD(v4)];
  unsigned int v9 = 3 * v4 + HIDWORD(v4);
  float v10 = &v8[v9];
  double v75 = v10;
  unint64_t v76 = v4 | ((unint64_t)v9 << 32);
  *(void *)int v84 = (unint64_t)v82 | 0xC;
  *(void *)&v84[8] = &v75;
  if (((unint64_t)v82 | 0xC) == a2 || v8 == (float *)a2)
  {
    LODWORD(v74) = 0;
    double v73 = 0;
    sub_2153D8BEC((float *)&v73, (uint64_t)v84);
    _D19 = (float32x2_t)v73;
    float v14 = *(float *)&v74;
  }
  else
  {
    float v11 = v10[1];
    float v12 = v10[2];
    _D19 = vmla_n_f32(vmla_n_f32(vmla_n_f32(0, *(float32x2_t *)((char *)v82 + 12), *v10), *(float32x2_t *)((char *)&v82[1] + 8), v11), *(float32x2_t *)((char *)&v83 + 4), v12);
    float v14 = (float)((float)((float)(*((float *)&v82[1] + 1) * *v10) + 0.0) + (float)(*(float *)&v83 * v11))
        + (float)(*((float *)&v83 + 3) * v12);
  }
  *(float32x2_t *)(a2 + 12) = _D19;
  *(float *)(a2 + 20) = v14;
  float v15 = v5 * v5;
  float v16 = (float)((float)(v5 * v5) + (float)(v6 * v6)) + (float)(_S11 * _S11);
  if (v16 >= 0.0061)
  {
    float v69 = v5;
    float v22 = sqrtf(v16);
    float32x2_t v70 = _D19;
    __float2 v23 = __sincosf_stret(v22);
    _D19 = v70;
    float v24 = v23.__sinval / v22;
    float v5 = v69;
    _S0 = (float)(1.0 / v16) * (float)(1.0 - v23.__cosval);
    float v18 = (float)(1.0 / v16) * (float)(1.0 - v24);
    float v19 = v18 - _S0;
    float v20 = (float)(1.0 / v16) * (float)(v24 + (float)(_S0 * -2.0));
    float v21 = (float)(1.0 / v16) * (float)(_S0 + (float)(v18 * -3.0));
  }
  else
  {
    _S0 = 0.5 - (float)(v16 * (float)((float)(v16 / -720.0) + 0.041667));
    float v18 = 0.16667 - (float)(v16 * (float)((float)(v16 / -5040.0) + 0.0083333));
    float v19 = (float)(v16 * (float)((float)(v16 * -0.0011905) + 0.033333)) + -0.33333;
    float v20 = (float)(v16 * (float)((float)(v16 * -0.00014881) + 0.0055556)) + -0.083333;
    float v21 = (float)(v16 * (float)((float)(v16 * -0.000016534) + 0.00079365)) + -0.016667;
  }
  uint64_t v25 = 0;
  uint64_t v26 = a2 + 24;
  float v27 = vmuls_lane_f32(v6, _D19, 1);
  float v28 = (float)((float)(v5 * _D19.f32[0]) + v27) + (float)(_S11 * v14);
  float v29 = (float)((float)(v19 + (float)(v21 * v15)) * v28) + (float)((float)(v18 + v18) * (float)(v5 * _D19.f32[0]));
  float v30 = (float)((float)(v19 + (float)(v21 * (float)(v6 * v6))) * v28) + (float)((float)(v18 + v18) * v27);
  float v81 = (float)((float)(v19 + (float)(v21 * (float)(_S11 * _S11))) * v28)
      + (float)((float)(v18 + v18) * (float)(_S11 * v14));
  float v31 = v21 * v28;
  float v32 = (float)(v6 * (float)(v5 * (float)(v21 * v28)))
      + (float)(v18 * vmlas_n_f32(vmuls_lane_f32(v5, _D19, 1), v6, _D19.f32[0]));
  float v33 = (float)(_S11 * (float)(v5 * v31)) + (float)(v18 * vmlas_n_f32(v5 * v14, _S11, _D19.f32[0]));
  __asm { FMLA            S17, S11, V19.S[1] }
  float v39 = (float)(_S11 * (float)(v6 * v31)) + (float)(v18 * _S17);
  float v40 = v20 * v28;
  float v41 = (float)(_S11 * v40) + (float)(_S0 * v14);
  __asm { FMLA            S16, S0, V19.S[1] }
  float v43 = vmlas_n_f32(v5 * v40, _S0, _D19.f32[0]);
  *(float *)&double v75 = v29;
  *((float *)&v75 + 1) = v41 + v32;
  *(float *)&unint64_t v76 = v33 - _S16;
  *((float *)&v76 + 1) = v32 - v41;
  float v79 = _S16 + v33;
  float v80 = v39 - v43;
  float v77 = v30;
  float v78 = v43 + v39;
  unint64_t v44 = 0x300000000;
  uint64_t v45 = 12;
  do
  {
    *(_DWORD *)(v26 + 4 * v25) = *(_DWORD *)((char *)v82 + v45);
    unint64_t v46 = HIDWORD(v44);
    BOOL v47 = (int)v44 < 2;
    if ((int)v44 < 2) {
      unint64_t v46 = 0;
    }
    uint64_t v48 = v25 + v46;
    uint64_t v49 = (v44 + 1);
    unint64_t v50 = v44 & 0xFFFFFFFF00000000;
    if (!v47) {
      uint64_t v49 = 0;
    }
    unint64_t v44 = v49 | v50;
    uint64_t v25 = v48 + 1;
    v45 += 4;
  }
  while (v25 != 18);
  long long v51 = *(_OWORD *)(a2 + 28);
  long long v52 = *(_OWORD *)(a2 + 48);
  *((void *)&v51 + 1) = *(void *)(a2 + 48);
  *(_DWORD *)int v84 = *(_DWORD *)(a2 + 24);
  *(_OWORD *)&double v84[4] = v51;
  double v53 = (int *)v84;
  int v85 = DWORD2(v52);
  uint64_t v86 = *(void *)(a2 + 72);
  int v87 = *(_DWORD *)(a2 + 80);
  unint64_t v54 = 0x300000000;
  for (uint64_t i = 21; i != 39; uint64_t i = v59 + 1)
  {
    int v56 = *v53++;
    *(_DWORD *)(v26 + 4 * i) = v56;
    unint64_t v57 = HIDWORD(v54);
    BOOL v58 = (int)v54 < 2;
    if ((int)v54 < 2) {
      unint64_t v57 = 0;
    }
    unint64_t v59 = i + v57;
    uint64_t v60 = (v54 + 1);
    unint64_t v61 = v54 & 0xFFFFFFFF00000000;
    if (!v58) {
      uint64_t v60 = 0;
    }
    unint64_t v54 = v60 | v61;
  }
  double v73 = &v72;
  long long v74 = &v75;
  *(void *)int v84 = &v73;
  *(void *)&v84[8] = (unint64_t)v82 | 0xC;
  v71[0] = a2 + 36;
  v71[1] = 0x300000006;
  unint64_t v72 = (unint64_t)v82 | 0xC;
  sub_2153D8CCC((uint64_t)v71, (uint64_t *)v84);
  unint64_t v62 = 0x300000000;
  for (uint64_t j = 18; j != 36; uint64_t j = v66 + 1)
  {
    *(_DWORD *)(v26 + 4 * j) = 0;
    unint64_t v64 = HIDWORD(v62);
    BOOL v65 = (int)v62 < 2;
    if ((int)v62 < 2) {
      unint64_t v64 = 0;
    }
    unint64_t v66 = j + v64;
    uint64_t v67 = (v62 + 1);
    unint64_t v68 = v62 & 0xFFFFFFFF00000000;
    if (!v65) {
      uint64_t v67 = 0;
    }
    unint64_t v62 = v67 | v68;
  }
}

uint64_t cva::SE3GroupStorage<float,cva::MatrixRef<float const,4u,4u,false>>::inverse@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)a2 = xmmword_215446040;
  *(_OWORD *)(a2 + 16) = unk_215446050;
  *(_OWORD *)(a2 + 32) = xmmword_215446060;
  *(_OWORD *)(a2 + 48) = unk_215446070;
  unint64_t v4 = *(void **)(a1 + 8);
  float v21 = *(uint64_t **)a1;
  float v22 = v4;
  v20[0] = a2;
  v20[1] = 4;
  uint64_t result = sub_2153D9260((uint64_t)v20, (uint64_t)&v21);
  v19[0] = a2;
  v19[1] = 4;
  v20[0] = v19;
  uint64_t v7 = *(unsigned int *)(a1 + 8);
  uint64_t v6 = *(unsigned int *)(a1 + 12);
  uint64_t v8 = *(void *)a1 - 4 * v6;
  uint64_t v9 = (3 * v7 + v6);
  float v10 = (float *)(v8 + 4 * v9);
  v18[0] = v10;
  v18[1] = v7 | (v9 << 32);
  float v21 = v20;
  float v22 = v18;
  if (v8 == a2)
  {
    float v24 = 0.0;
    uint64_t v23 = 0;
    uint64_t result = (uint64_t)sub_2153D93A8((float *)&v23, &v21);
    *(void *)(a2 + 48) = v23;
    float v17 = v24;
  }
  else
  {
    float v11 = *(float *)(a2 + 4);
    float v12 = *(float *)(a2 + 8);
    float v13 = *(float *)(a2 + 20);
    float v14 = *(float *)(a2 + 24);
    float v15 = *(float *)(a2 + 36);
    float v16 = *(float *)(a2 + 40);
    *(float *)(a2 + 48) = (float)((float)(0.0 - (float)(*(float *)a2 * *v10)) - (float)(*(float *)(a2 + 16) * v10[1]))
                        - (float)(*(float *)(a2 + 32) * v10[2]);
    *(float *)(a2 + 52) = (float)((float)(0.0 - (float)(v11 * *v10)) - (float)(v13 * v10[1])) - (float)(v15 * v10[2]);
    float v17 = (float)((float)(0.0 - (float)(v12 * *v10)) - (float)(v14 * v10[1])) - (float)(v16 * v10[2]);
  }
  *(float *)(a2 + 56) = v17;
  return result;
}

unint64_t cva::SE3GroupStorage<float,cva::MatrixRef<float const,4u,4u,false>>::adjoint@<X0>(unint64_t result@<X0>, uint64_t a2@<X8>)
{
  v3.i64[1] = 0;
  *(_OWORD *)(a2 + 112) = 0u;
  *(_OWORD *)(a2 + 128) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  unint64_t v4 = *(_DWORD **)result;
  unint64_t v5 = *(void *)(result + 8);
  uint64_t v6 = *(void *)result - 4 * HIDWORD(v5);
  if (v6 == a2)
  {
    uint64_t v20 = 0;
    float v76 = *(float *)v4;
    v3.i64[0] = *(void *)(v4 + 1);
    uint64_t v21 = (v5 - 3);
    v3.i64[1] = *(void *)&v4[v21 + 3];
    float32x4_t v77 = (float32x4_t)v3;
    float v78 = *(float *)&v4[v21 + 5];
    uint64_t v22 = (uint64_t)&v4[v21 + 3 + v21];
    float32x2_t v79 = *(float32x2_t *)(v22 + 12);
    float v80 = *(float *)(v22 + 20);
    unint64_t v23 = 0x300000000;
    float v24 = &v76;
    do
    {
      int v25 = *(_DWORD *)v24++;
      *(_DWORD *)(a2 + 4 * v20) = v25;
      unint64_t v26 = HIDWORD(v23);
      BOOL v27 = (int)v23 < 2;
      if ((int)v23 < 2) {
        unint64_t v26 = 0;
      }
      uint64_t v28 = v20 + v26;
      uint64_t v29 = (v23 + 1);
      unint64_t v30 = v23 & 0xFFFFFFFF00000000;
      if (!v27) {
        uint64_t v29 = 0;
      }
      unint64_t v23 = v29 | v30;
      uint64_t v20 = v28 + 1;
    }
    while (v20 != 18);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v8 = (v5 << 32) - 0x300000000;
    unint64_t v9 = 0x300000000;
    float v10 = *(_DWORD **)result;
    do
    {
      *(_DWORD *)(a2 + 4 * v7) = *v10;
      unint64_t v11 = HIDWORD(v8);
      BOOL v12 = (int)v8 < 2;
      if ((int)v8 < 2) {
        unint64_t v11 = 0;
      }
      float v13 = &v10[v11];
      uint64_t v14 = (v8 + 1);
      unint64_t v15 = v8 & 0xFFFFFFFF00000000;
      if (!v12) {
        uint64_t v14 = 0;
      }
      unint64_t v8 = v14 | v15;
      float v10 = v13 + 1;
      unint64_t v16 = HIDWORD(v9);
      BOOL v17 = (int)v9 < 2;
      if ((int)v9 < 2) {
        unint64_t v16 = 0;
      }
      uint64_t v18 = v7 + v16;
      uint64_t result = (v9 + 1);
      unint64_t v19 = v9 & 0xFFFFFFFF00000000;
      if (!v17) {
        uint64_t result = 0;
      }
      unint64_t v9 = result | v19;
      uint64_t v7 = v18 + 1;
    }
    while (v7 != 18);
  }
  float32x4_t v31 = *(float32x4_t *)(a2 + 4);
  long long v32 = *(_OWORD *)(a2 + 24);
  v31.i64[1] = *(void *)(a2 + 24);
  float v76 = *(float *)a2;
  float32x4_t v77 = v31;
  float v33 = &v76;
  float v78 = *((float *)&v32 + 2);
  v3.i64[0] = *(void *)(a2 + 48);
  float32x2_t v79 = *(float32x2_t *)v3.i8;
  float v80 = *(float *)(a2 + 56);
  unint64_t v34 = 0x300000000;
  for (uint64_t i = 21; i != 39; uint64_t i = v39 + 1)
  {
    int v36 = *(_DWORD *)v33++;
    *(_DWORD *)(a2 + 4 * i) = v36;
    unint64_t v37 = HIDWORD(v34);
    BOOL v38 = (int)v34 < 2;
    if ((int)v34 < 2) {
      unint64_t v37 = 0;
    }
    unint64_t v39 = i + v37;
    uint64_t v40 = (v34 + 1);
    unint64_t v41 = v34 & 0xFFFFFFFF00000000;
    if (!v38) {
      uint64_t v40 = 0;
    }
    unint64_t v34 = v40 | v41;
  }
  uint64_t v42 = v6 + 4 * (3 * v5 + HIDWORD(v5));
  v3.i32[0] = *(_DWORD *)v42;
  v43.i64[0] = *(void *)v4;
  float v44 = *((float *)v4 + 2);
  uint64_t v45 = (v5 - 3);
  unint64_t v46 = &v4[v45];
  float v47 = *((float *)v46 + 3);
  v46 += 3;
  uint64_t v48 = (float32x2_t *)&v46[v45];
  v49.i64[0] = __PAIR64__(LODWORD(v44), v43.u32[0]);
  v2.i64[0] = *(void *)(v42 + 4);
  v43.f32[2] = v47;
  v43.i32[3] = HIDWORD(*(void *)(v46 + 1));
  v49.i64[1] = *(void *)(v46 + 1);
  float32x2_t v50 = v48[2];
  float v51 = (float)(*(float *)v42 * v49.f32[2]) - (float)(v47 * *(float *)v2.i32);
  v52.i32[0] = vdup_lane_s32((int32x2_t)v50, 1).u32[0];
  v52.i32[1] = v48[1].i32[1];
  v53.i32[0] = vdup_lane_s32(*(int32x2_t *)v2.i8, 1).u32[0];
  v53.i32[1] = *(_DWORD *)v42;
  float32x2_t v54 = vsub_f32(vmul_f32(*(float32x2_t *)v2.i8, v52), vmul_f32(v53, v50));
  v50.f32[0] = *(float *)v42 * v50.f32[0];
  float v55 = v48[1].f32[1] * *(float *)v2.i32;
  float v76 = (float)(v44 * *(float *)v2.i32) - COERCE_FLOAT(vmul_f32(*(float32x2_t *)&v2, *(float32x2_t *)&v43).i32[1]);
  int8x16_t v56 = vextq_s8((int8x16_t)v2, (int8x16_t)v2, 4uLL);
  float32x4_t v57 = (float32x4_t)v56;
  v57.i32[1] = v3.i32[0];
  v57.i32[2] = v56.i32[0];
  float32x4_t v58 = (float32x4_t)vzip1q_s32(v2, v3);
  v58.i32[1] = v3.i32[0];
  v58.i32[3] = v3.i32[0];
  int32x4_t v59 = (int32x4_t)vsubq_f32((float32x4_t)vrev64q_s32((int32x4_t)vmulq_f32(v57, v43)), vmulq_f32(v58, v49));
  v43.i64[0] = vrev64q_s32(v59).u64[0];
  v43.i64[1] = v59.i64[1];
  float32x4_t v77 = v43;
  float v78 = v51;
  float32x2_t v79 = v54;
  float v80 = v50.f32[0] - v55;
  unint64_t v60 = 0x300000000;
  unint64_t v61 = &v76;
  for (uint64_t j = 3; j != 21; uint64_t j = v66 + 1)
  {
    int v63 = *(_DWORD *)v61++;
    *(_DWORD *)(a2 + 4 * j) = v63;
    unint64_t v64 = HIDWORD(v60);
    BOOL v65 = (int)v60 < 2;
    if ((int)v60 < 2) {
      unint64_t v64 = 0;
    }
    unint64_t v66 = j + v64;
    uint64_t v67 = (v60 + 1);
    unint64_t v68 = v60 & 0xFFFFFFFF00000000;
    if (!v65) {
      uint64_t v67 = 0;
    }
    unint64_t v60 = v67 | v68;
  }
  unint64_t v69 = 0x300000000;
  for (uint64_t k = 18; k != 36; uint64_t k = v73 + 1)
  {
    *(_DWORD *)(a2 + 4 * k) = 0;
    unint64_t v71 = HIDWORD(v69);
    BOOL v72 = (int)v69 < 2;
    if ((int)v69 < 2) {
      unint64_t v71 = 0;
    }
    unint64_t v73 = k + v71;
    uint64_t v74 = (v69 + 1);
    unint64_t v75 = v69 & 0xFFFFFFFF00000000;
    if (!v72) {
      uint64_t v74 = 0;
    }
    unint64_t v69 = v74 | v75;
  }
  return result;
}

uint64_t cva::SE3GroupStorage<float,cva::MatrixRef<float const,4u,4u,false>>::serialize(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 8);
  if (4 * v1)
  {
    uint64_t v2 = *(void *)result;
    uint64_t v3 = *(void *)result + 4 * (4 * v1);
    unint64_t v4 = (unint64_t)(v1 - 4) << 32;
    do
    {
      uint64_t result = std::ostream::write();
      unint64_t v5 = HIDWORD(v4);
      if ((int)v4 < 3) {
        unint64_t v5 = 0;
      }
      uint64_t v6 = v2 + 4 * v5;
      uint64_t v7 = (v4 + 1);
      if ((int)v4 >= 3) {
        uint64_t v7 = 0;
      }
      unint64_t v4 = v7 | v4 & 0xFFFFFFFF00000000;
      uint64_t v2 = v6 + 4;
    }
    while (v6 + 4 != v3);
  }
  return result;
}

double cva::SE3GroupStorage<double,cva::MatrixRef<double const,4u,4u,false>>::SE3GroupStorage(void *a1, uint64_t a2)
{
  *a1 = a2;
  *(void *)&double result = 4;
  a1[1] = 4;
  return result;
}

{
  double result;

  *a1 = a2;
  *(void *)&double result = 4;
  a1[1] = 4;
  return result;
}

{
  double result;

  *a1 = a2;
  *(void *)&double result = 4;
  a1[1] = 4;
  return result;
}

{
  double result;

  *a1 = a2;
  *(void *)&double result = 4;
  a1[1] = 4;
  return result;
}

uint64_t cva::SE3GroupStorage<double,cva::MatrixRef<double const,4u,4u,false>>::R(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t cva::SE3GroupStorage<double,cva::MatrixRef<double const,4u,4u,false>>::T(uint64_t a1)
{
  return *(void *)a1
       - 8 * *(unsigned int *)(a1 + 12)
       + 8 * (3 * *(_DWORD *)(a1 + 8) + *(_DWORD *)(a1 + 12));
}

uint64_t **cva::SE3GroupStorage<double,cva::MatrixRef<double const,4u,4u,false>>::affine@<X0>(uint64_t **result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *result;
  int v4 = *((_DWORD *)result + 2);
  uint64_t v3 = *((unsigned int *)result + 3);
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  unint64_t v5 = &v2[-v3];
  uint64_t v6 = (v4 - 3);
  uint64_t v7 = *v2;
  if (v5 == (uint64_t *)a2)
  {
    uint64_t v14 = v6;
    long long v15 = *(_OWORD *)&v2[v14 + 3];
    uint64_t v16 = v2[v14 + 5];
    uint64_t v17 = (uint64_t)&v2[v14 + 3 + v14];
    long long v18 = *(_OWORD *)(v17 + 24);
    v17 += 24;
    uint64_t v19 = *(void *)(v17 + 16);
    uint64_t v20 = v17 + v14 * 8;
    uint64_t v21 = *(void *)(v20 + 40);
    long long v22 = *(_OWORD *)(v2 + 1);
    long long v23 = *(_OWORD *)(v20 + 24);
    *(void *)a2 = v7;
    *(_OWORD *)(a2 + 8) = v22;
    *(_OWORD *)(a2 + 24) = v15;
    *(void *)(a2 + 40) = v16;
    *(_OWORD *)(a2 + 48) = v18;
    *(void *)(a2 + 64) = v19;
    *(_OWORD *)(a2 + 72) = v23;
    *(void *)(a2 + 88) = v21;
  }
  else
  {
    *(void *)a2 = v7;
    *(void *)(a2 + 8) = v2[1];
    *(void *)(a2 + 16) = v2[2];
    uint64_t v8 = v6;
    unint64_t v9 = &v2[v8];
    uint64_t v10 = v9[3];
    v9 += 3;
    *(void *)(a2 + 24) = v10;
    *(void *)(a2 + 32) = v9[1];
    *(void *)(a2 + 40) = v9[2];
    unint64_t v11 = &v9[v8];
    uint64_t v12 = v11[3];
    v11 += 3;
    *(void *)(a2 + 48) = v12;
    *(void *)(a2 + 56) = v11[1];
    *(void *)(a2 + 64) = v11[2];
    float v13 = &v11[v8];
    *(void *)(a2 + 72) = v13[3];
    *(void *)(a2 + 80) = v13[4];
    *(void *)(a2 + 88) = v13[5];
  }
  return result;
}

double *cva::SE3GroupStorage<double,cva::MatrixRef<double const,4u,4u,false>>::transform@<X0>(void *a1@<X0>, double *a2@<X1>, void *a3@<X8>)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v4 = a1[1];
  v11[0] = *a1;
  v11[1] = v4;
  v12[0] = (double *)v11;
  v12[1] = a2;
  uint64_t v5 = v11[0] - 8 * HIDWORD(v4);
  uint64_t v6 = v5 + 8 * (3 * v4 + HIDWORD(v4));
  float64x2_t v14 = 0uLL;
  double v13 = 0.0;
  double result = sub_2153CCF54(&v13, v12);
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  double v8 = v13 + *(double *)v6;
  if ((void *)v5 == a3)
  {
    float64x2_t v10 = vaddq_f64(v14, *(float64x2_t *)(v6 + 8));
    *(double *)a3 = v8;
    *(float64x2_t *)(a3 + 1) = v10;
  }
  else
  {
    *(double *)a3 = v8;
    double v9 = v14.f64[1];
    *((double *)a3 + 1) = v14.f64[0] + *(double *)(v6 + 8);
    *((double *)a3 + 2) = v9 + *(double *)(v6 + 16);
  }
  return result;
}

double cva::SE3GroupStorage<double,cva::MatrixRef<double const,4u,4u,false>>::inverseTransform@<D0>(void *a1@<X0>, uint64_t *a2@<X1>, float64x2_t *a3@<X8>)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  unint64_t v4 = a1[1];
  v12[0] = *a1;
  v12[1] = v4;
  double v13 = v12;
  v14[0] = (uint64_t *)&v13;
  v14[1] = a2;
  v9[0] = v12[0];
  v9[1] = v4;
  float64x2_t v10 = v9;
  uint64_t v6 = v12[0] - 8 * HIDWORD(v4) + 8 * (3 * v4 + HIDWORD(v4));
  int v7 = v4;
  int v8 = 3 * v4 + HIDWORD(v4);
  v11[0] = (uint64_t *)&v10;
  v11[1] = &v6;
  float64x2_t v15 = 0uLL;
  double v16 = 0.0;
  sub_2153CD09C((uint64_t)&v15, v14);
  float64x2_t v17 = 0uLL;
  double v18 = 0.0;
  sub_2153DA6C4((uint64_t)&v17, v11);
  *a3 = vsubq_f64(v15, v17);
  double result = v16 - v18;
  a3[1].f64[0] = v16 - v18;
  return result;
}

void cva::SE3GroupStorage<double,cva::MatrixRef<double const,4u,4u,false>>::transformJacobian(double *a1@<X1>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 112) = 0u;
  *(_OWORD *)(a2 + 128) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  if (a1 == (double *)a2)
  {
    uint64_t v11 = 0;
    unint64_t v12 = 0;
    v30[0] = 0;
    double v14 = a1[1];
    double v13 = a1[2];
    double v15 = *a1;
    *(double *)&v30[1] = -v13;
    *(double *)&v30[2] = v14;
    *(double *)&v30[3] = v13;
    v30[4] = 0;
    *(double *)&v30[5] = -v15;
    *(double *)&v30[6] = -v14;
    *(double *)&v30[7] = v15;
    v30[8] = 0;
    double v16 = (double *)v30;
    do
    {
      double v17 = *v16++;
      a1[v11] = v17;
      unint64_t v18 = HIDWORD(v12);
      BOOL v19 = (int)v12 < 2;
      if ((int)v12 < 2) {
        unint64_t v18 = 0;
      }
      uint64_t v20 = v11 + v18;
      uint64_t v21 = (v12 + 1);
      unint64_t v22 = v12 & 0xFFFFFFFF00000000;
      if (!v19) {
        uint64_t v21 = 0;
      }
      unint64_t v12 = v21 | v22;
      uint64_t v11 = v20 + 1;
    }
    while (v11 != 9);
  }
  else
  {
    uint64_t v2 = 0;
    unint64_t v3 = 0;
    unint64_t v4 = 0;
    do
    {
      double v10 = 0.0;
      if (HIDWORD(v4) != v4) {
        double v10 = a1[dword_215446130[(HIDWORD(v4) + 4 * v4)]]
      }
            * dbl_215446160[(HIDWORD(v4) + 4 * v4)];
      *(double *)(a2 + 8 * v2) = v10;
      if ((int)v4 >= 2) {
        unint64_t v4 = (v4 & 0xFFFFFFFF00000000) + 0x100000000;
      }
      else {
        unint64_t v4 = (v4 + 1) | v4 & 0xFFFFFFFF00000000;
      }
      unint64_t v5 = HIDWORD(v3);
      BOOL v6 = (int)v3 < 2;
      if ((int)v3 < 2) {
        unint64_t v5 = 0;
      }
      uint64_t v7 = v2 + v5;
      uint64_t v8 = (v3 + 1);
      unint64_t v9 = v3 & 0xFFFFFFFF00000000;
      if (!v6) {
        uint64_t v8 = 0;
      }
      unint64_t v3 = v8 | v9;
      uint64_t v2 = v7 + 1;
    }
    while (v2 != 9);
  }
  unint64_t v23 = 0;
  for (uint64_t i = 9; i != 18; uint64_t i = v27 + 1)
  {
    *(void *)(a2 + 8 * i) = 0;
    unint64_t v25 = HIDWORD(v23);
    BOOL v26 = (int)v23 < 2;
    if ((int)v23 < 2) {
      unint64_t v25 = 0;
    }
    unint64_t v27 = i + v25;
    uint64_t v28 = (v23 + 1);
    unint64_t v29 = v23 & 0xFFFFFFFF00000000;
    if (!v26) {
      uint64_t v28 = 0;
    }
    unint64_t v23 = v28 | v29;
  }
  *(void *)(a2 + 72) = 0x3FF0000000000000;
  *(void *)(a2 + 104) = 0x3FF0000000000000;
  *(void *)(a2 + 136) = 0x3FF0000000000000;
}

uint64_t cva::SE3GroupStorage<double,cva::MatrixRef<double const,4u,4u,false>>::inverseTransformJacobian@<X0>(uint64_t a1@<X0>, double *a2@<X1>, _OWORD *a3@<X8>)
{
  uint64_t v3 = 0;
  unint64_t v4 = 0;
  a3[7] = 0u;
  a3[8] = 0u;
  a3[5] = 0u;
  a3[6] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  unint64_t v5 = *(double **)a1;
  double v6 = *(double *)(a1 + 8);
  uint64_t v7 = (LODWORD(v6) - 3);
  uint64_t v8 = (double *)(*(void *)a1 + v7 * 8);
  double v9 = v8[3];
  double v10 = v8[4];
  v8 += 3;
  double v11 = v8[2];
  unint64_t v12 = &v8[v7];
  double v13 = v12[3];
  double v14 = v12[4];
  double v15 = v12[5];
  double v16 = **(double **)a1;
  double v17 = *(double *)(*(void *)a1 + 8);
  double v18 = *(double *)(*(void *)a1 + 16);
  double v20 = a2[1];
  double v19 = a2[2];
  double v21 = v17 * v19 - v18 * v20;
  double v22 = v10 * v19 - v11 * v20;
  double v23 = v14 * v19 - v15 * v20;
  double v24 = v18 * *a2 - v16 * v19;
  double v25 = v11 * *a2 - v9 * v19;
  double v26 = v15 * *a2 - v13 * v19;
  double v27 = v16 * v20 - v17 * *a2;
  double v28 = v9 * v20 - v10 * *a2;
  double v29 = v13 * v20 - v14 * *a2;
  double v39 = v21;
  double v40 = v22;
  double v41 = v23;
  double v42 = v24;
  double v43 = v25;
  double v44 = v26;
  double v45 = v27;
  double v46 = v28;
  double v47 = v29;
  unint64_t v30 = &v39;
  do
  {
    uint64_t v31 = *(void *)v30++;
    *((void *)a3 + v3) = v31;
    unint64_t v32 = HIDWORD(v4);
    BOOL v33 = (int)v4 < 2;
    if ((int)v4 < 2) {
      unint64_t v32 = 0;
    }
    uint64_t v34 = v3 + v32;
    uint64_t v35 = (v4 + 1);
    unint64_t v36 = v4 & 0xFFFFFFFF00000000;
    if (!v33) {
      uint64_t v35 = 0;
    }
    unint64_t v4 = v35 | v36;
    uint64_t v3 = v34 + 1;
  }
  while (v3 != 9);
  double v39 = *(double *)&v5;
  double v40 = v6;
  v38[0] = (char *)a3 + 72;
  v38[1] = 0x900000003;
  return sub_2153DAA6C((uint64_t)v38, (uint64_t)&v39);
}

double cva::SE3GroupStorage<double,cva::MatrixRef<double const,4u,4u,false>>::log@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  unint64_t v4 = *(double **)a1;
  unint64_t v3 = *(void *)(a1 + 8);
  sub_2153CCB88(*(double **)a1, v3, (double *)a2);
  double v6 = *(double *)a2;
  double v5 = *(double *)(a2 + 8);
  double v7 = *(double *)(a2 + 16);
  double v8 = v6 * v6 + v5 * v5 + v7 * v7;
  if (v8 >= 0.0000002635)
  {
    double v12 = sqrt(v8);
    double v29 = *(double *)a2;
    __double2 v13 = __sincos_stret(v12);
    double v6 = v29;
    double v11 = v13.__sinval / v12;
    double v9 = 1.0 / v8 * (1.0 - v13.__cosval);
    double v10 = 1.0 / v8 * (1.0 - v13.__sinval / v12);
  }
  else
  {
    double v9 = 0.5 - v8 * (v8 / -720.0 + 0.0416666667);
    double v10 = 0.166666667 - v8 * (v8 / -5040.0 + 0.00833333333);
    double v11 = 1.0 - v8 * v10;
  }
  if (v8 >= 2.775e-15)
  {
    if (v8 <= 9.0) {
      double v14 = -(v10 - v9 * 0.5) / v11;
    }
    else {
      double v14 = (v9 + v11 * -0.5) / (v8 * v9);
    }
  }
  else
  {
    double v14 = v8 * 0.00138888889 + 0.0833333333 + v8 * 0.0000330687831;
  }
  double v15 = (float64x2_t *)&v4[(3 * v3 + HIDWORD(v3)) - HIDWORD(v3)];
  double v16 = v15->f64[1];
  double v17 = v15[1].f64[0];
  v30.f64[0] = v5 * v17 - v7 * v16;
  v30.f64[1] = v7 * v15->f64[0] - v6 * v17;
  double v31 = v6 * v16 - v5 * v15->f64[0];
  double v18 = v17 + v31 * -0.5;
  float64x2_t v19 = *(float64x2_t *)(a2 + 8);
  __asm { FMOV            V7.2D, #-0.5 }
  float64x2_t v25 = vaddq_f64(*v15, vmulq_f64(v30, _Q7));
  v26.i64[1] = *(void *)(a2 + 16);
  *(double *)v26.i64 = v6;
  *(void *)&_Q7.f64[0] = vdupq_laneq_s64(*(int64x2_t *)((char *)&v30 + 8), 1).u64[0];
  _Q7.f64[1] = v30.f64[0];
  float64x2_t v27 = vaddq_f64(v25, vmulq_n_f64(vmlaq_f64(vmulq_f64(*(float64x2_t *)((char *)&v30 + 8), vnegq_f64((float64x2_t)vextq_s8(v26, v26, 8uLL))), _Q7, v19), v14));
  double result = v14 * vmlad_n_f64(-(v19.f64[0] * v30.f64[0]), v6, v30.f64[1]) + v18;
  *(float64x2_t *)(a2 + 24) = v27;
  *(double *)(a2 + 40) = result;
  return result;
}

void cva::SE3GroupStorage<double,cva::MatrixRef<double const,4u,4u,false>>::logJacobian(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 328) = 0;
  *(_OWORD *)(a2 + 248) = 0u;
  *(_OWORD *)(a2 + 232) = 0u;
  *(_OWORD *)(a2 + 216) = 0u;
  *(_OWORD *)(a2 + 200) = 0u;
  *(_OWORD *)(a2 + 184) = 0u;
  *(_OWORD *)(a2 + 168) = 0u;
  *(_OWORD *)(a2 + 152) = 0u;
  *(_OWORD *)(a2 + 136) = 0u;
  *(_OWORD *)(a2 + 120) = 0u;
  *(_OWORD *)(a2 + 104) = 0u;
  *(_OWORD *)(a2 + 88) = 0u;
  *(_OWORD *)(a2 + 72) = 0u;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  unint64_t v3 = (_OWORD *)(a2 + 24);
  v3[17] = 0u;
  v3[18] = 0u;
  v3[15] = 0u;
  v3[16] = 0u;
  unint64_t v4 = *(double **)a1;
  unint64_t v5 = *(void *)(a1 + 8);
  memset(v87, 0, sizeof(v87));
  float64x2_t v86 = 0u;
  memset(v85, 0, sizeof(v85));
  sub_2153CD2E0(v4, v5, v85[0].f64, &v85[1].f64[1]);
  double v7 = v85[0].f64[1];
  double v6 = v85[0].f64[0];
  *(float64_t *)a2 = v85[0].f64[0];
  *(double *)(a2 + 8) = v7;
  _D11 = v85[1].f64[0];
  *(float64_t *)(a2 + 16) = v85[1].f64[0];
  double v9 = &v4[-HIDWORD(v5)];
  unsigned int v10 = 3 * v5 + HIDWORD(v5);
  double v11 = &v9[v10];
  long long v83 = (float64_t **)v11;
  int v84 = (float64_t **)(v5 | ((unint64_t)v10 << 32));
  double v74 = COERCE_DOUBLE((float64x2_t *)&v85[1].f64[1]);
  double v75 = COERCE_DOUBLE(&v83);
  if ((float64x2_t *)&v85[1].f64[1] == (float64x2_t *)a2 || v9 == (double *)a2)
  {
    float64x2_t v88 = 0uLL;
    double v89 = 0.0;
    sub_2153DB29C((uint64_t)&v88, (uint64_t)&v74);
    _Q19 = v88;
    double v15 = v89;
  }
  else
  {
    double v12 = v11[1];
    double v13 = v11[2];
    _Q19 = vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64((float64x2_t)0, *(float64x2_t *)((char *)&v85[1] + 8), *v11), v86, v12), *(float64x2_t *)&v87[1], v13);
    double v15 = v85[2].f64[1] * *v11 + 0.0 + v87[0] * v12 + v87[3] * v13;
  }
  *(float64x2_t *)(a2 + 24) = _Q19;
  *(double *)(a2 + 40) = v15;
  double v16 = v6 * v6;
  double v17 = v6 * v6 + v7 * v7 + _D11 * _D11;
  if (v17 >= 0.0000002635)
  {
    double v70 = v6;
    double v23 = sqrt(v17);
    float64x2_t v71 = _Q19;
    __double2 v24 = __sincos_stret(v23);
    _Q19 = v71;
    double v25 = v24.__sinval / v23;
    double v6 = v70;
    _D0 = 1.0 / v17 * (1.0 - v24.__cosval);
    double v19 = 1.0 / v17 * (1.0 - v25);
    double v20 = v19 - _D0;
    double v21 = 1.0 / v17 * (v25 + _D0 * -2.0);
    double v22 = 1.0 / v17 * (_D0 + v19 * -3.0);
  }
  else
  {
    _D0 = 0.5 - v17 * (v17 / -720.0 + 0.0416666667);
    double v19 = 0.166666667 - v17 * (v17 / -5040.0 + 0.00833333333);
    double v20 = v17 * (v17 * -0.00119047619 + 0.0333333333) + -0.333333333;
    double v21 = v17 * (v17 * -0.000148809524 + 0.00555555556) + -0.0833333333;
    double v22 = v17 * (v17 * -0.0000165343915 + 0.000793650794) + -0.0166666667;
  }
  uint64_t v26 = 0;
  uint64_t v27 = a2 + 48;
  double v28 = vmuld_lane_f64(v7, _Q19, 1);
  double v29 = v6 * _Q19.f64[0] + v28 + _D11 * v15;
  double v30 = (v20 + v22 * v16) * v29 + (v19 + v19) * (v6 * _Q19.f64[0]);
  double v31 = (v20 + v22 * (v7 * v7)) * v29 + (v19 + v19) * v28;
  double v82 = (v20 + v22 * (_D11 * _D11)) * v29 + (v19 + v19) * (_D11 * v15);
  double v32 = v22 * v29;
  double v33 = v7 * (v6 * (v22 * v29)) + v19 * vmlad_n_f64(vmuld_lane_f64(v6, _Q19, 1), v7, _Q19.f64[0]);
  double v34 = _D11 * (v6 * v32) + v19 * vmlad_n_f64(v6 * v15, _D11, _Q19.f64[0]);
  __asm { FMLA            D17, D11, V19.D[1] }
  double v40 = _D11 * (v7 * v32) + v19 * _D17;
  double v41 = v21 * v29;
  double v42 = _D11 * v41 + _D0 * v15;
  __asm { FMLA            D16, D0, V19.D[1] }
  double v44 = vmlad_n_f64(v6 * v41, _D0, _Q19.f64[0]);
  double v74 = v30;
  double v75 = v42 + v33;
  double v76 = v34 - _D16;
  double v77 = v33 - v42;
  double v80 = _D16 + v34;
  double v81 = v40 - v44;
  double v78 = v31;
  double v79 = v44 + v40;
  unint64_t v45 = 0x300000000;
  uint64_t v46 = 3;
  do
  {
    *(float64_t *)(v27 + 8 * v26) = v85[0].f64[v46];
    unint64_t v47 = HIDWORD(v45);
    BOOL v48 = (int)v45 < 2;
    if ((int)v45 < 2) {
      unint64_t v47 = 0;
    }
    uint64_t v49 = v26 + v47;
    uint64_t v50 = (v45 + 1);
    unint64_t v51 = v45 & 0xFFFFFFFF00000000;
    if (!v48) {
      uint64_t v50 = 0;
    }
    unint64_t v45 = v50 | v51;
    uint64_t v26 = v49 + 1;
    ++v46;
  }
  while (v26 != 18);
  float64x2_t v88 = *(float64x2_t *)(a2 + 48);
  double v52 = *(double *)(a2 + 64);
  long long v90 = *(_OWORD *)(a2 + 96);
  uint64_t v53 = *(void *)(a2 + 112);
  double v89 = v52;
  uint64_t v91 = v53;
  long long v92 = *(_OWORD *)(a2 + 144);
  unint64_t v54 = 0x300000000;
  float v55 = &v88;
  uint64_t v56 = 21;
  uint64_t v93 = *(void *)(a2 + 160);
  do
  {
    float64_t v57 = v55->f64[0];
    float v55 = (float64x2_t *)((char *)v55 + 8);
    *(float64_t *)(v27 + 8 * v56) = v57;
    unint64_t v58 = HIDWORD(v54);
    BOOL v59 = (int)v54 < 2;
    if ((int)v54 < 2) {
      unint64_t v58 = 0;
    }
    unint64_t v60 = v56 + v58;
    uint64_t v61 = (v54 + 1);
    unint64_t v62 = v54 & 0xFFFFFFFF00000000;
    if (!v59) {
      uint64_t v61 = 0;
    }
    unint64_t v54 = v61 | v62;
    uint64_t v56 = v60 + 1;
  }
  while (v56 != 39);
  long long v83 = &v73;
  int v84 = (float64_t **)&v74;
  *(void *)&v88.f64[0] = &v83;
  *(void *)&v88.f64[1] = &v85[1].f64[1];
  v72[0] = a2 + 72;
  v72[1] = 0x300000006;
  unint64_t v73 = &v85[1].f64[1];
  sub_2153DB37C((uint64_t)v72, (uint64_t *)&v88);
  unint64_t v63 = 0x300000000;
  for (uint64_t i = 18; i != 36; uint64_t i = v67 + 1)
  {
    *(void *)(v27 + 8 * i) = 0;
    unint64_t v65 = HIDWORD(v63);
    BOOL v66 = (int)v63 < 2;
    if ((int)v63 < 2) {
      unint64_t v65 = 0;
    }
    unint64_t v67 = i + v65;
    uint64_t v68 = (v63 + 1);
    unint64_t v69 = v63 & 0xFFFFFFFF00000000;
    if (!v66) {
      uint64_t v68 = 0;
    }
    unint64_t v63 = v68 | v69;
  }
}

void cva::SE3GroupStorage<double,cva::MatrixRef<double const,4u,4u,false>>::inverse(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 64) = xmmword_2154460C0;
  *(_OWORD *)(a2 + 80) = unk_2154460D0;
  *(_OWORD *)(a2 + 96) = xmmword_2154460E0;
  *(_OWORD *)(a2 + 112) = unk_2154460F0;
  *(_OWORD *)a2 = xmmword_215446080;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)algn_215446090;
  *(_OWORD *)(a2 + 32) = xmmword_2154460A0;
  *(_OWORD *)(a2 + 48) = unk_2154460B0;
  uint64_t v4 = *(void *)(a1 + 8);
  *(void *)&long long v22 = *(void *)a1;
  *((void *)&v22 + 1) = v4;
  double v20 = (uint64_t *)a2;
  uint64_t v21 = 4;
  sub_2153DB944((uint64_t)&v20, (uint64_t)&v22);
  v18[0] = a2;
  v18[1] = 4;
  double v19 = v18;
  uint64_t v6 = *(unsigned int *)(a1 + 8);
  uint64_t v5 = *(unsigned int *)(a1 + 12);
  uint64_t v7 = *(void *)a1 - 8 * v5;
  uint64_t v8 = (3 * v6 + v5);
  double v9 = (double *)(v7 + 8 * v8);
  v17[0] = v9;
  v17[1] = v6 | (v8 << 32);
  double v20 = (uint64_t *)&v19;
  uint64_t v21 = (uint64_t)v17;
  if (v7 == a2)
  {
    long long v22 = 0uLL;
    double v23 = 0.0;
    sub_2153DBA8C((uint64_t)&v22, &v20);
    *(_OWORD *)(a2 + 96) = v22;
    double v16 = v23;
  }
  else
  {
    double v10 = *(double *)(a2 + 8);
    double v11 = *(double *)(a2 + 16);
    double v12 = *(double *)(a2 + 40);
    double v13 = *(double *)(a2 + 48);
    double v14 = *(double *)(a2 + 72);
    double v15 = *(double *)(a2 + 80);
    *(double *)(a2 + 96) = 0.0 - *(double *)a2 * *v9 - *(double *)(a2 + 32) * v9[1] - *(double *)(a2 + 64) * v9[2];
    *(double *)(a2 + 104) = 0.0 - v10 * *v9 - v12 * v9[1] - v14 * v9[2];
    double v16 = 0.0 - v11 * *v9 - v13 * v9[1] - v15 * v9[2];
  }
  *(double *)(a2 + 112) = v16;
}

unint64_t cva::SE3GroupStorage<double,cva::MatrixRef<double const,4u,4u,false>>::adjoint@<X0>(unint64_t result@<X0>, _OWORD *a2@<X8>)
{
  a2[16] = 0u;
  a2[17] = 0u;
  a2[14] = 0u;
  a2[15] = 0u;
  a2[12] = 0u;
  a2[13] = 0u;
  a2[10] = 0u;
  a2[11] = 0u;
  a2[8] = 0u;
  a2[9] = 0u;
  a2[6] = 0u;
  a2[7] = 0u;
  a2[4] = 0u;
  a2[5] = 0u;
  a2[2] = 0u;
  a2[3] = 0u;
  uint64_t v2 = *(double **)result;
  unint64_t v3 = *(void *)(result + 8);
  uint64_t v4 = *(void *)result - 8 * HIDWORD(v3);
  *a2 = 0u;
  a2[1] = 0u;
  if ((_OWORD *)v4 == a2)
  {
    uint64_t v18 = 0;
    long long v78 = *(_OWORD *)v2;
    double v79 = v2[2];
    uint64_t v19 = (v3 - 3);
    long long v80 = *(_OWORD *)&v2[v19 + 3];
    double v81 = v2[v19 + 5];
    uint64_t v20 = (uint64_t)&v2[v19 + 3 + v19];
    long long v82 = *(_OWORD *)(v20 + 24);
    double v83 = *(double *)(v20 + 40);
    unint64_t v21 = 0x300000000;
    long long v22 = (uint64_t *)&v78;
    do
    {
      uint64_t v23 = *v22++;
      *((void *)a2 + v18) = v23;
      unint64_t v24 = HIDWORD(v21);
      BOOL v25 = (int)v21 < 2;
      if ((int)v21 < 2) {
        unint64_t v24 = 0;
      }
      uint64_t v26 = v18 + v24;
      uint64_t v27 = (v21 + 1);
      unint64_t v28 = v21 & 0xFFFFFFFF00000000;
      if (!v25) {
        uint64_t v27 = 0;
      }
      unint64_t v21 = v27 | v28;
      uint64_t v18 = v26 + 1;
    }
    while (v18 != 18);
  }
  else
  {
    uint64_t v5 = 0;
    unint64_t v6 = (v3 << 32) - 0x300000000;
    unint64_t v7 = 0x300000000;
    uint64_t v8 = v2;
    do
    {
      *((double *)a2 + v5) = *v8;
      unint64_t v9 = HIDWORD(v6);
      BOOL v10 = (int)v6 < 2;
      if ((int)v6 < 2) {
        unint64_t v9 = 0;
      }
      double v11 = &v8[v9];
      uint64_t v12 = (v6 + 1);
      unint64_t v13 = v6 & 0xFFFFFFFF00000000;
      if (!v10) {
        uint64_t v12 = 0;
      }
      unint64_t v6 = v12 | v13;
      uint64_t v8 = v11 + 1;
      unint64_t v14 = HIDWORD(v7);
      BOOL v15 = (int)v7 < 2;
      if ((int)v7 < 2) {
        unint64_t v14 = 0;
      }
      uint64_t v16 = v5 + v14;
      double result = (v7 + 1);
      unint64_t v17 = v7 & 0xFFFFFFFF00000000;
      if (!v15) {
        double result = 0;
      }
      unint64_t v7 = result | v17;
      uint64_t v5 = v16 + 1;
    }
    while (v5 != 18);
  }
  long long v78 = *a2;
  double v79 = *((double *)a2 + 2);
  long long v80 = a2[3];
  double v81 = *((double *)a2 + 8);
  long long v82 = a2[6];
  unint64_t v29 = 0x300000000;
  double v30 = (uint64_t *)&v78;
  uint64_t v31 = 21;
  double v83 = *((double *)a2 + 14);
  do
  {
    uint64_t v32 = *v30++;
    *((void *)a2 + v31) = v32;
    unint64_t v33 = HIDWORD(v29);
    BOOL v34 = (int)v29 < 2;
    if ((int)v29 < 2) {
      unint64_t v33 = 0;
    }
    unint64_t v35 = v31 + v33;
    uint64_t v36 = (v29 + 1);
    unint64_t v37 = v29 & 0xFFFFFFFF00000000;
    if (!v34) {
      uint64_t v36 = 0;
    }
    unint64_t v29 = v36 | v37;
    uint64_t v31 = v35 + 1;
  }
  while (v31 != 39);
  BOOL v38 = (double *)(v4 + 8 * (3 * v3 + HIDWORD(v3)));
  double v39 = v38[1];
  double v40 = v38[2];
  double v41 = *v2;
  double v42 = v2[1];
  double v43 = v2[2];
  uint64_t v44 = (v3 - 3);
  unint64_t v45 = &v2[v44];
  double v46 = v45[3];
  double v47 = v45[4];
  v45 += 3;
  double v48 = v45[2];
  uint64_t v49 = &v45[v44];
  double v50 = v49[3];
  double v51 = v49[4];
  double v52 = v49[5];
  double v53 = v39 * v43 - v40 * v42;
  double v54 = v40 * v41 - *v38 * v43;
  double v55 = *v38 * v42 - v39 * v41;
  double v56 = v39 * v48 - v40 * v47;
  double v57 = v40 * v46 - *v38 * v48;
  double v58 = *v38 * v47 - v39 * v46;
  double v59 = v39 * v52 - v40 * v51;
  double v60 = v40 * v50 - *v38 * v52;
  double v61 = *v38 * v51;
  *(double *)&long long v78 = v53;
  *((double *)&v78 + 1) = v54;
  double v79 = v55;
  *(double *)&long long v80 = v56;
  *((double *)&v80 + 1) = v57;
  double v81 = v58;
  *(double *)&long long v82 = v59;
  *((double *)&v82 + 1) = v60;
  double v83 = v61 - v39 * v50;
  unint64_t v62 = 0x300000000;
  unint64_t v63 = (uint64_t *)&v78;
  for (uint64_t i = 3; i != 21; uint64_t i = v68 + 1)
  {
    uint64_t v65 = *v63++;
    *((void *)a2 + i) = v65;
    unint64_t v66 = HIDWORD(v62);
    BOOL v67 = (int)v62 < 2;
    if ((int)v62 < 2) {
      unint64_t v66 = 0;
    }
    unint64_t v68 = i + v66;
    uint64_t v69 = (v62 + 1);
    unint64_t v70 = v62 & 0xFFFFFFFF00000000;
    if (!v67) {
      uint64_t v69 = 0;
    }
    unint64_t v62 = v69 | v70;
  }
  unint64_t v71 = 0x300000000;
  for (uint64_t j = 18; j != 36; uint64_t j = v75 + 1)
  {
    *((void *)a2 + j) = 0;
    unint64_t v73 = HIDWORD(v71);
    BOOL v74 = (int)v71 < 2;
    if ((int)v71 < 2) {
      unint64_t v73 = 0;
    }
    unint64_t v75 = j + v73;
    uint64_t v76 = (v71 + 1);
    unint64_t v77 = v71 & 0xFFFFFFFF00000000;
    if (!v74) {
      uint64_t v76 = 0;
    }
    unint64_t v71 = v76 | v77;
  }
  return result;
}

uint64_t cva::SE3GroupStorage<double,cva::MatrixRef<double const,4u,4u,false>>::serialize(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 8);
  if (4 * v1)
  {
    uint64_t v2 = *(void *)result;
    uint64_t v3 = *(void *)result + 8 * (4 * v1);
    unint64_t v4 = (unint64_t)(v1 - 4) << 32;
    do
    {
      double result = std::ostream::write();
      unint64_t v5 = HIDWORD(v4);
      if ((int)v4 < 3) {
        unint64_t v5 = 0;
      }
      uint64_t v6 = v2 + 8 * v5;
      uint64_t v7 = (v4 + 1);
      if ((int)v4 >= 3) {
        uint64_t v7 = 0;
      }
      unint64_t v4 = v7 | v4 & 0xFFFFFFFF00000000;
      uint64_t v2 = v6 + 8;
    }
    while (v6 + 8 != v3);
  }
  return result;
}

float cva::SE3AlgebraStorage<float,cva::Matrix<float,6u,1u,false>>::SE3AlgebraStorage(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)a1 = *a2;
  *(_DWORD *)(a1 + 4) = a2[1];
  *(_DWORD *)(a1 + 8) = a2[2];
  *(_DWORD *)(a1 + 12) = *(_DWORD *)a3;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a3 + 4);
  float result = *(float *)(a3 + 8);
  *(float *)(a1 + 20) = result;
  return result;
}

{
  float result;

  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)a1 = *a2;
  *(_DWORD *)(a1 + 4) = a2[1];
  *(_DWORD *)(a1 + 8) = a2[2];
  *(_DWORD *)(a1 + 12) = *(_DWORD *)a3;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a3 + 4);
  float result = *(float *)(a3 + 8);
  *(float *)(a1 + 20) = result;
  return result;
}

uint64_t cva::SE3AlgebraStorage<float,cva::Matrix<float,6u,1u,false>>::T(uint64_t a1)
{
  return a1 + 12;
}

{
  return a1 + 12;
}

float *cva::SE3AlgebraStorage<float,cva::Matrix<float,6u,1u,false>>::adjoint@<X0>(float *result@<X0>, int *a2@<X8>)
{
  uint64_t v2 = 0;
  *((_OWORD *)a2 + 7) = 0u;
  *((_OWORD *)a2 + 8) = 0u;
  *((_OWORD *)a2 + 5) = 0u;
  *((_OWORD *)a2 + 6) = 0u;
  *((_OWORD *)a2 + 3) = 0u;
  *((_OWORD *)a2 + 4) = 0u;
  *((_OWORD *)a2 + 1) = 0u;
  *((_OWORD *)a2 + 2) = 0u;
  *(_OWORD *)a2 = 0u;
  float v3 = *result;
  float v4 = result[1];
  float v5 = result[2];
  int v44 = 0;
  *(float *)&long long v45 = v5;
  *((float *)&v45 + 1) = -v4;
  *((float *)&v45 + 2) = -v5;
  HIDWORD(v45) = 0;
  float v46 = v3;
  *(float *)&uint64_t v47 = v4;
  *((float *)&v47 + 1) = -v3;
  unint64_t v6 = 0x300000000;
  uint64_t v7 = &v44;
  int v48 = 0;
  do
  {
    int v8 = *v7++;
    a2[v2] = v8;
    unint64_t v9 = HIDWORD(v6);
    BOOL v10 = (int)v6 < 2;
    if ((int)v6 < 2) {
      unint64_t v9 = 0;
    }
    uint64_t v11 = v2 + v9;
    uint64_t v12 = (v6 + 1);
    unint64_t v13 = v6 & 0xFFFFFFFF00000000;
    if (!v10) {
      uint64_t v12 = 0;
    }
    unint64_t v6 = v12 | v13;
    uint64_t v2 = v11 + 1;
  }
  while (v2 != 18);
  long long v14 = *(_OWORD *)(a2 + 1);
  long long v15 = *(_OWORD *)(a2 + 6);
  *((void *)&v14 + 1) = *((void *)a2 + 3);
  int v44 = *a2;
  long long v45 = v14;
  uint64_t v16 = &v44;
  float v46 = *((float *)&v15 + 2);
  uint64_t v47 = *((void *)a2 + 6);
  int v48 = a2[14];
  unint64_t v17 = 0x300000000;
  for (uint64_t i = 21; i != 39; uint64_t i = v22 + 1)
  {
    int v19 = *v16++;
    a2[i] = v19;
    unint64_t v20 = HIDWORD(v17);
    BOOL v21 = (int)v17 < 2;
    if ((int)v17 < 2) {
      unint64_t v20 = 0;
    }
    unint64_t v22 = i + v20;
    uint64_t v23 = (v17 + 1);
    unint64_t v24 = v17 & 0xFFFFFFFF00000000;
    if (!v21) {
      uint64_t v23 = 0;
    }
    unint64_t v17 = v23 | v24;
  }
  float v25 = result[3];
  float v26 = result[4];
  float v27 = result[5];
  int v44 = 0;
  *(float *)&long long v45 = v27;
  *((float *)&v45 + 1) = -v26;
  *((float *)&v45 + 2) = -v27;
  HIDWORD(v45) = 0;
  float v46 = v25;
  *(float *)&uint64_t v47 = v26;
  *((float *)&v47 + 1) = -v25;
  int v48 = 0;
  unint64_t v28 = 0x300000000;
  unint64_t v29 = &v44;
  for (uint64_t j = 3; j != 21; uint64_t j = v34 + 1)
  {
    int v31 = *v29++;
    a2[j] = v31;
    unint64_t v32 = HIDWORD(v28);
    BOOL v33 = (int)v28 < 2;
    if ((int)v28 < 2) {
      unint64_t v32 = 0;
    }
    unint64_t v34 = j + v32;
    uint64_t v35 = (v28 + 1);
    unint64_t v36 = v28 & 0xFFFFFFFF00000000;
    if (!v33) {
      uint64_t v35 = 0;
    }
    unint64_t v28 = v35 | v36;
  }
  unint64_t v37 = 0x300000000;
  for (uint64_t k = 18; k != 36; uint64_t k = v41 + 1)
  {
    a2[k] = 0;
    unint64_t v39 = HIDWORD(v37);
    BOOL v40 = (int)v37 < 2;
    if ((int)v37 < 2) {
      unint64_t v39 = 0;
    }
    unint64_t v41 = k + v39;
    uint64_t v42 = (v37 + 1);
    unint64_t v43 = v37 & 0xFFFFFFFF00000000;
    if (!v40) {
      uint64_t v42 = 0;
    }
    unint64_t v37 = v42 | v43;
  }
  return result;
}

float cva::SE3AlgebraStorage<float,cva::Matrix<float,6u,1u,false>>::hat@<S0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  float v2 = *(float *)(a1 + 8);
  *(float *)(a2 + 16) = -v2;
  float v4 = *(float *)a1;
  float v3 = *(float *)(a1 + 4);
  float v5 = -*(float *)a1;
  *(float *)(a2 + 32) = v3;
  *(float *)(a2 + 36) = v5;
  *(void *)(a2 + 48) = *(void *)(a1 + 12);
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 20) = 0;
  *(float *)(a2 + 4) = v2;
  *(float *)(a2 + 8) = -v3;
  *(float *)(a2 + 24) = v4;
  float result = *(float *)(a1 + 20);
  *(float *)(a2 + 56) = result;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 28) = 0;
  *(void *)(a2 + 40) = 0;
  *(_DWORD *)(a2 + 60) = 0;
  return result;
}

uint64_t cva::SE3AlgebraStorage<float,cva::Matrix<float,6u,1u,false>>::exp@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>, double a3@<D0>)
{
  *(_OWORD *)a2 = xmmword_215446040;
  *(_OWORD *)(a2 + 16) = unk_215446050;
  *(_OWORD *)(a2 + 32) = xmmword_215446060;
  *(_OWORD *)(a2 + 48) = unk_215446070;
  float32x4_t v14 = vmulq_n_f32(*(float32x4_t *)a1, *(float *)&a3);
  float32x2_t v15 = vmul_f32(*(float32x2_t *)(a1 + 16), (float32x2_t)*(_OWORD *)&vdupq_lane_s32(*(int32x2_t *)&a3, 0));
  float32x4_t v4 = vmulq_f32(v14, v14);
  float v5 = vaddq_f32(vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1)), (float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2)).f32[0];
  if (v5 >= 0.0061)
  {
    float v10 = sqrtf(v5);
    float v13 = v5;
    __float2 v11 = __sincosf_stret(v10);
    float cosval = v11.__cosval;
    float v8 = v11.__sinval / v10;
    float v6 = (float)(1.0 / v13) * (float)(1.0 - v11.__cosval);
    float v7 = (float)(1.0 / v13) * (float)(1.0 - (float)(v11.__sinval / v10));
  }
  else
  {
    float v6 = 0.5 - (float)(v5 * (float)((float)(v5 / -720.0) + 0.041667));
    float v7 = 0.16667 - (float)(v5 * (float)((float)(v5 / -5040.0) + 0.0083333));
    float v8 = 1.0 - (float)(v5 * v7);
    float cosval = 1.0 - (float)(v5 * v6);
  }
  v16[2] = v6;
  _DWORD v16[3] = v7;
  v16[0] = cosval;
  v16[1] = v8;
  return sub_2153D986C((uint64_t)&v14, v16, (float32x2_t *)a2);
}

void cva::SE3AlgebraStorage<float,cva::Matrix<float,6u,1u,false>>::expJacobian(float *a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)a2 = xmmword_215446040;
  *(_OWORD *)(a2 + 16) = unk_215446050;
  *(_OWORD *)(a2 + 32) = xmmword_215446060;
  *(_OWORD *)(a2 + 48) = unk_215446070;
  uint64_t v4 = a2 + 64;
  *(_OWORD *)(a2 + 76) = 0u;
  *(_OWORD *)(a2 + 92) = 0u;
  *(_OWORD *)(a2 + 108) = 0u;
  *(_OWORD *)(a2 + 124) = 0u;
  *(_OWORD *)(a2 + 140) = 0u;
  *(_OWORD *)(a2 + 156) = 0u;
  *(_OWORD *)(a2 + 172) = 0u;
  *(_OWORD *)(a2 + 188) = 0u;
  *(_DWORD *)(a2 + 204) = 0;
  v77[0] = a1 + 3;
  v77[1] = 0x300000006;
  float v5 = *a1;
  float v6 = a1[1];
  float v7 = v5 * v5;
  float v8 = v6 * v6;
  float v9 = a1[2];
  float v10 = v9 * v9;
  float v11 = (float)((float)(v5 * v5) + (float)(v6 * v6)) + (float)(v9 * v9);
  if (v11 >= 0.0061)
  {
    float v19 = sqrtf(v11);
    __float2 v20 = __sincosf_stret(v19);
    float cosval = v20.__cosval;
    float v7 = v5 * v5;
    float v10 = v9 * v9;
    float v14 = v20.__sinval / v19;
    float v12 = (float)(1.0 / v11) * (float)(1.0 - v20.__cosval);
    float v13 = (float)(1.0 / v11) * (float)(1.0 - v14);
    float v16 = v13 - v12;
    float v17 = (float)(1.0 / v11) * (float)(v14 + (float)(v12 * -2.0));
    float v18 = (float)(1.0 / v11) * (float)(v12 + (float)(v13 * -3.0));
  }
  else
  {
    float v12 = 0.5 - (float)(v11 * (float)((float)(v11 / -720.0) + 0.041667));
    float v13 = 0.16667 - (float)(v11 * (float)((float)(v11 / -5040.0) + 0.0083333));
    float v14 = 1.0 - (float)(v11 * v13);
    float cosval = 1.0 - (float)(v11 * v12);
    float v16 = (float)(v11 * (float)((float)(v11 * -0.0011905) + 0.033333)) + -0.33333;
    float v17 = (float)(v11 * (float)((float)(v11 * -0.00014881) + 0.0055556)) + -0.083333;
    float v18 = (float)(v11 * (float)((float)(v11 * -0.000016534) + 0.00079365)) + -0.016667;
  }
  float v21 = cosval + (float)((float)(v5 * v12) * v5);
  float v22 = cosval + (float)((float)(v6 * v12) * v6);
  *(float *)(a2 + 40) = cosval + (float)((float)(v9 * v12) * v9);
  float v23 = (float)(v5 * v12) * v6;
  float v24 = (float)(v5 * v12) * v9;
  float v25 = (float)(v6 * v12) * v9;
  *(float *)(a2 + 16) = v23 - (float)(v14 * v9);
  *(float *)(a2 + 20) = v22;
  *(float *)a2 = v21;
  *(float *)(a2 + 4) = v23 + (float)(v14 * v9);
  *(float *)(a2 + 32) = (float)(v14 * v6) + v24;
  *(float *)(a2 + 36) = v25 - (float)(v14 * v5);
  *(float *)(a2 + 8) = v24 - (float)(v14 * v6);
  *(float *)(a2 + 24) = v25 + (float)(v14 * v5);
  v76[0] = v4;
  v76[1] = 6;
  float v26 = v14 + (float)((float)(v13 * v5) * v5);
  float v27 = v14 + (float)((float)(v13 * v6) * v6);
  float v28 = v14 + (float)((float)(v13 * v9) * v9);
  float v29 = (float)(v13 * v5) * v6;
  float v30 = (float)(v13 * v5) * v9;
  float v31 = (float)(v13 * v6) * v9;
  float v32 = v29 - (float)(v9 * v12);
  *(float *)(a2 + 88) = v32;
  *(float *)(a2 + 92) = v27;
  float v33 = (float)(v6 * v12) + v30;
  float v34 = v29 + (float)(v9 * v12);
  *(float *)(a2 + 64) = v26;
  *(float *)(a2 + 68) = v34;
  float v35 = v31 - (float)(v5 * v12);
  *(float *)(a2 + 112) = v33;
  *(float *)(a2 + 116) = v35;
  *(float *)(a2 + 120) = v28;
  float v36 = v30 - (float)(v6 * v12);
  *(float *)(a2 + 72) = v36;
  float v37 = v31 + (float)(v5 * v12);
  *(float *)(a2 + 96) = v37;
  *(void *)long long v80 = v76;
  *(void *)&v80[8] = v77;
  if (a1 == (float *)a2)
  {
    float v79 = 0.0;
    uint64_t v78 = 0;
    float v75 = v17;
    float v43 = v10;
    float v44 = v7;
    float v74 = v18;
    sub_2153DEE60((float *)&v78, (uint64_t **)v80);
    float v18 = v74;
    float v17 = v75;
    float v7 = v44;
    float v10 = v43;
    float v8 = v6 * v6;
    *(void *)(a2 + 48) = v78;
    float v42 = v79;
    float v38 = a1[3];
    float v39 = a1[4];
    float v41 = a1[5];
  }
  else
  {
    float v38 = a1[3];
    float v39 = a1[4];
    float v40 = (float)((float)(v26 * v38) + 0.0) + (float)(v32 * v39);
    float v41 = a1[5];
    *(float *)(a2 + 48) = v40 + (float)(v33 * v41);
    *(float *)(a2 + 52) = (float)((float)((float)(v34 * v38) + 0.0) + (float)(v27 * v39)) + (float)(v35 * v41);
    float v42 = (float)((float)((float)(v36 * v38) + 0.0) + (float)(v37 * v39)) + (float)(v28 * v41);
  }
  *(float *)(a2 + 56) = v42;
  float v45 = (float)((float)(v5 * v38) + (float)(v6 * v39)) + (float)(v9 * v41);
  float v46 = (float)((float)(v16 + (float)(v18 * v7)) * v45) + (float)((float)(v13 + v13) * (float)(v5 * v38));
  float v47 = (float)((float)(v16 + (float)(v18 * v8)) * v45) + (float)((float)(v13 + v13) * (float)(v6 * v39));
  *(float *)(a2 + 132) = (float)((float)(v16 + (float)(v18 * v10)) * v45)
                       + (float)((float)(v13 + v13) * (float)(v9 * v41));
  float v48 = (float)(v18 * v45) * v5;
  float v49 = (float)(v6 * v48) + (float)(v13 * (float)((float)(v39 * v5) + (float)(v38 * v6)));
  float v50 = (float)(v48 * v9) + (float)(v13 * (float)((float)(v5 * v41) + (float)(v38 * v9)));
  float v51 = (float)((float)((float)(v18 * v45) * v6) * v9) + (float)(v13 * (float)((float)(v6 * v41) + (float)(v39 * v9)));
  float v52 = v17 * v45;
  float v53 = (float)(v52 * v9) + (float)(v12 * v41);
  float v54 = (float)(v52 * v6) + (float)(v12 * v39);
  float v55 = (float)(v52 * v5) + (float)(v12 * v38);
  *(float *)(a2 + 100) = v49 - v53;
  *(float *)(a2 + 104) = v47;
  *(float *)(a2 + 76) = v46;
  *(float *)(a2 + 80) = v49 + v53;
  *(float *)(a2 + 84) = v50 - v54;
  *(float *)(a2 + 124) = v54 + v50;
  *(float *)(a2 + 128) = v51 - v55;
  *(float *)(a2 + 108) = v55 + v51;
  unint64_t v56 = 0x300000000;
  for (uint64_t i = 18; i != 36; uint64_t i = v60 + 1)
  {
    *(_DWORD *)(v4 + 4 * i) = 0;
    unint64_t v58 = HIDWORD(v56);
    BOOL v59 = (int)v56 < 2;
    if ((int)v56 < 2) {
      unint64_t v58 = 0;
    }
    unint64_t v60 = i + v58;
    uint64_t v61 = (v56 + 1);
    unint64_t v62 = v56 & 0xFFFFFFFF00000000;
    if (!v59) {
      uint64_t v61 = 0;
    }
    unint64_t v56 = v61 | v62;
  }
  long long v63 = *(_OWORD *)(a2 + 68);
  long long v64 = *(_OWORD *)(a2 + 88);
  *((void *)&v63 + 1) = *(void *)(a2 + 88);
  *(_DWORD *)long long v80 = *(_DWORD *)(a2 + 64);
  *(_OWORD *)&v80[4] = v63;
  uint64_t v65 = (int *)v80;
  int v81 = DWORD2(v64);
  uint64_t v82 = *(void *)(a2 + 112);
  int v83 = *(_DWORD *)(a2 + 120);
  unint64_t v66 = 0x300000000;
  for (uint64_t j = 21; j != 39; uint64_t j = v71 + 1)
  {
    int v68 = *v65++;
    *(_DWORD *)(v4 + 4 * j) = v68;
    unint64_t v69 = HIDWORD(v66);
    BOOL v70 = (int)v66 < 2;
    if ((int)v66 < 2) {
      unint64_t v69 = 0;
    }
    unint64_t v71 = j + v69;
    uint64_t v72 = (v66 + 1);
    unint64_t v73 = v66 & 0xFFFFFFFF00000000;
    if (!v70) {
      uint64_t v72 = 0;
    }
    unint64_t v66 = v72 | v73;
  }
}

float *sub_2153DEE60(float *result, uint64_t **a2)
{
  float v2 = result;
  uint64_t v3 = **a2;
  if ((float *)(v3 - 4 * *((unsigned int *)*a2 + 3)) == result
    || (v4 = a2[1], float v5 = (float *)*v4, (float *)(*v4 - 4 * *((unsigned int *)v4 + 3)) == result))
  {
    int v22 = 0;
    uint64_t v21 = 0;
    float result = (float *)sub_2153DEE60(&v21);
    *(void *)float v2 = v21;
    *((_DWORD *)v2 + 2) = v22;
  }
  else
  {
    uint64_t v6 = *((unsigned int *)*a2 + 2);
    if (v6)
    {
      uint64_t v7 = 0;
      uint64_t v8 = 4 * (3 * v6);
      uint64_t v9 = 4 * v6;
      float v10 = 0.0;
      float v11 = v5;
      do
      {
        float v12 = *v11++;
        float v10 = v10 + (float)(*(float *)(v3 + v7) * v12);
        v7 += v9;
      }
      while (v8 != v7);
      uint64_t v13 = 0;
      *float result = v10;
      float v14 = 0.0;
      float32x2_t v15 = v5;
      do
      {
        float v16 = *v15++;
        float v14 = v14 + (float)(*(float *)(v3 + 4 + v13) * v16);
        v13 += v9;
      }
      while (v8 != v13);
      uint64_t v17 = 0;
      result[1] = v14;
      uint64_t v18 = v3 + 8;
      float v19 = 0.0;
      do
      {
        float v20 = *v5++;
        float v19 = v19 + (float)(*(float *)(v18 + v17) * v20);
        v17 += v9;
      }
      while (v8 != v17);
    }
    else
    {
      *(void *)float result = 0;
      float v19 = 0.0;
    }
    result[2] = v19;
  }
  return result;
}

void cva::SE3AlgebraStorage<float,cva::Matrix<float,6u,1u,false>>::enforce(float *a1)
{
  float v1 = *a1;
  float v2 = a1[1];
  float v3 = a1[2];
  float v4 = (float)((float)(v1 * v1) + (float)(v2 * v2)) + (float)(v3 * v3);
  if (v4 > 9.8696)
  {
    if (v4 >= 0.0061)
    {
      float v9 = sqrtf(v4);
      __float2 v10 = __sincosf_stret(v9);
      float v8 = v10.__sinval / v9;
      float v6 = (float)(1.0 / v4) * (float)(1.0 - v10.__cosval);
      float v7 = (float)(1.0 / v4) * (float)(1.0 - (float)(v10.__sinval / v9));
    }
    else
    {
      float v6 = 0.5 - (float)(v4 * (float)((float)(v4 / -720.0) + 0.041667));
      float v7 = 0.16667 - (float)(v4 * (float)((float)(v4 / -5040.0) + 0.0083333));
      float v8 = 1.0 - (float)(v4 * v7);
    }
    float v11 = a1[3];
    float v12 = a1[4];
    float v13 = a1[5];
    float v14 = (float)(v1 * v12) - (float)(v2 * v11);
    float v15 = (float)(v3 * v11) - (float)(v1 * v13);
    float v16 = (float)(v2 * v13) - (float)(v3 * v12);
    float v17 = (float)(v11 + (float)(v6 * v16)) + (float)(v7 * (float)((float)(v2 * v14) - (float)(v3 * v15)));
    float v18 = (float)(v12 + (float)(v6 * v15)) + (float)(v7 * (float)((float)(v3 * v16) - (float)(v1 * v14)));
    float v19 = (float)(v13 + (float)(v6 * v14)) + (float)(v7 * (float)((float)(v1 * v15) - (float)(v2 * v16)));
    float v20 = (float)((float)(v2 * v2) + (float)(v1 * v1)) + (float)(v3 * v3);
    if (v20 <= 9.8696)
    {
      float v26 = 1.0;
      float v25 = 1.0;
    }
    else
    {
      float v21 = sqrtf(v20) / 3.1416;
      float v22 = ceilf(v21) + -1.0;
      int v23 = (int)v22;
      float v24 = v21 - v22;
      if (v23) {
        float v24 = v24 + -1.0;
      }
      float v25 = v24 / v21;
      float v1 = v1 * v25;
      float v2 = v2 * v25;
      *a1 = v1;
      a1[1] = v2;
      float v3 = v3 * v25;
      a1[2] = v3;
      float v26 = v25 * v25;
      float v4 = v4 * (float)(v25 * v25);
      if (v25 >= -0.000244 && v25 <= 0.000244)
      {
        if (v4 >= 0.00000149)
        {
          if (v4 >= 0.0061)
          {
            float v38 = sqrtf(v4);
            __float2 v39 = __sincosf_stret(v38);
            float v37 = v39.__sinval / v38;
            float v35 = (float)(1.0 / v4) * (float)(1.0 - v39.__cosval);
            float v36 = (float)(1.0 / v4) * (float)(1.0 - (float)(v39.__sinval / v38));
          }
          else
          {
            float v35 = 0.5 - (float)(v4 * (float)((float)(v4 / -720.0) + 0.041667));
            float v36 = 0.16667 - (float)(v4 * (float)((float)(v4 / -5040.0) + 0.0083333));
            float v37 = 1.0 - (float)(v4 * v36);
          }
          float v28 = (float)-(float)(v36 - (float)(v35 * 0.5)) / v37;
        }
        else
        {
          float v28 = (float)((float)(v4 * 0.0013889) + 0.083333) + (float)(v4 * 0.000033069);
        }
        goto LABEL_18;
      }
    }
    float v29 = v8 / v25;
    float v30 = v6 / v26;
    float v31 = (float)((float)((float)-(float)(1.0 - v29) / v4) + (float)(v30 * 0.5)) / v29;
    float v28 = (float)(v30 + (float)(v29 * -0.5)) / (float)(v4 * v30);
    if (v4 <= 9.0) {
      float v28 = v31;
    }
LABEL_18:
    float v32 = (float)(v2 * v19) - (float)(v3 * v18);
    float v33 = (float)(v3 * v17) - (float)(v1 * v19);
    float v34 = (float)(v1 * v18) - (float)(v2 * v17);
    a1[3] = (float)(v17 - (float)(v32 * 0.5)) + (float)(v28 * (float)((float)(v2 * v34) - (float)(v3 * v33)));
    a1[4] = (float)(v18 - (float)(v33 * 0.5)) + (float)(v28 * (float)((float)(v3 * v32) - (float)(v1 * v34)));
    a1[5] = (float)(v19 - (float)(v34 * 0.5)) + (float)(v28 * (float)((float)(v1 * v33) - (float)(v2 * v32)));
  }
}

uint64_t cva::SE3AlgebraStorage<float,cva::Matrix<float,6u,1u,false>>::serialize()
{
  return std::ostream::write();
}

uint64_t cva::SE3AlgebraStorage<float,cva::Matrix<float,6u,1u,false>>::deserialize(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x270F98678](a2, a1, 24);
}

double cva::SE3AlgebraStorage<double,cva::Matrix<double,6u,1u,false>>::SE3AlgebraStorage(uint64_t a1, void *a2, uint64_t a3)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(void *)a1 = *a2;
  *(void *)(a1 + 8) = a2[1];
  *(void *)(a1 + 16) = a2[2];
  *(void *)(a1 + 24) = *(void *)a3;
  *(void *)(a1 + 32) = *(void *)(a3 + 8);
  double result = *(double *)(a3 + 16);
  *(double *)(a1 + 40) = result;
  return result;
}

{
  double result;

  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(void *)a1 = *a2;
  *(void *)(a1 + 8) = a2[1];
  *(void *)(a1 + 16) = a2[2];
  *(void *)(a1 + 24) = *(void *)a3;
  *(void *)(a1 + 32) = *(void *)(a3 + 8);
  double result = *(double *)(a3 + 16);
  *(double *)(a1 + 40) = result;
  return result;
}

uint64_t cva::SE3AlgebraStorage<double,cva::Matrix<double,6u,1u,false>>::T(uint64_t a1)
{
  return a1 + 24;
}

{
  return a1 + 24;
}

double *cva::SE3AlgebraStorage<double,cva::Matrix<double,6u,1u,false>>::adjoint@<X0>(double *result@<X0>, _OWORD *a2@<X8>)
{
  uint64_t v2 = 0;
  a2[16] = 0u;
  a2[17] = 0u;
  a2[14] = 0u;
  a2[15] = 0u;
  a2[12] = 0u;
  a2[13] = 0u;
  a2[10] = 0u;
  a2[11] = 0u;
  a2[8] = 0u;
  a2[9] = 0u;
  a2[6] = 0u;
  a2[7] = 0u;
  a2[4] = 0u;
  a2[5] = 0u;
  a2[2] = 0u;
  a2[3] = 0u;
  *a2 = 0u;
  a2[1] = 0u;
  double v3 = *result;
  double v4 = result[1];
  double v5 = -*result;
  double v6 = -result[2];
  *((double *)&v43 + 1) = result[2];
  double v44 = -v4;
  *(double *)&long long v45 = v6;
  *((void *)&v45 + 1) = 0;
  double v46 = v3;
  *(double *)&long long v47 = v4;
  *((double *)&v47 + 1) = v5;
  unint64_t v7 = 0x300000000;
  float v8 = (uint64_t *)&v43;
  uint64_t v48 = 0;
  do
  {
    uint64_t v9 = *v8++;
    *((void *)a2 + v2) = v9;
    unint64_t v10 = HIDWORD(v7);
    BOOL v11 = (int)v7 < 2;
    if ((int)v7 < 2) {
      unint64_t v10 = 0;
    }
    uint64_t v12 = v2 + v10;
    uint64_t v13 = (v7 + 1);
    unint64_t v14 = v7 & 0xFFFFFFFF00000000;
    if (!v11) {
      uint64_t v13 = 0;
    }
    unint64_t v7 = v13 | v14;
    uint64_t v2 = v12 + 1;
  }
  while (v2 != 18);
  long long v43 = *a2;
  double v44 = *((double *)a2 + 2);
  long long v45 = a2[3];
  double v46 = *((double *)a2 + 8);
  long long v47 = a2[6];
  unint64_t v15 = 0x300000000;
  float v16 = (uint64_t *)&v43;
  uint64_t v17 = 21;
  uint64_t v48 = *((void *)a2 + 14);
  do
  {
    uint64_t v18 = *v16++;
    *((void *)a2 + v17) = v18;
    unint64_t v19 = HIDWORD(v15);
    BOOL v20 = (int)v15 < 2;
    if ((int)v15 < 2) {
      unint64_t v19 = 0;
    }
    unint64_t v21 = v17 + v19;
    uint64_t v22 = (v15 + 1);
    unint64_t v23 = v15 & 0xFFFFFFFF00000000;
    if (!v20) {
      uint64_t v22 = 0;
    }
    unint64_t v15 = v22 | v23;
    uint64_t v17 = v21 + 1;
  }
  while (v17 != 39);
  double v24 = result[3];
  double v25 = result[4];
  double v26 = result[5];
  *(void *)&long long v43 = 0;
  *((double *)&v43 + 1) = v26;
  double v44 = -v25;
  *(double *)&long long v45 = -v26;
  *((void *)&v45 + 1) = 0;
  double v46 = v24;
  *(double *)&long long v47 = v25;
  *((double *)&v47 + 1) = -v24;
  uint64_t v48 = 0;
  unint64_t v27 = 0x300000000;
  float v28 = (uint64_t *)&v43;
  for (uint64_t i = 3; i != 21; uint64_t i = v33 + 1)
  {
    uint64_t v30 = *v28++;
    *((void *)a2 + i) = v30;
    unint64_t v31 = HIDWORD(v27);
    BOOL v32 = (int)v27 < 2;
    if ((int)v27 < 2) {
      unint64_t v31 = 0;
    }
    unint64_t v33 = i + v31;
    uint64_t v34 = (v27 + 1);
    unint64_t v35 = v27 & 0xFFFFFFFF00000000;
    if (!v32) {
      uint64_t v34 = 0;
    }
    unint64_t v27 = v34 | v35;
  }
  unint64_t v36 = 0x300000000;
  for (uint64_t j = 18; j != 36; uint64_t j = v40 + 1)
  {
    *((void *)a2 + j) = 0;
    unint64_t v38 = HIDWORD(v36);
    BOOL v39 = (int)v36 < 2;
    if ((int)v36 < 2) {
      unint64_t v38 = 0;
    }
    unint64_t v40 = j + v38;
    uint64_t v41 = (v36 + 1);
    unint64_t v42 = v36 & 0xFFFFFFFF00000000;
    if (!v39) {
      uint64_t v41 = 0;
    }
    unint64_t v36 = v41 | v42;
  }
  return result;
}

double cva::SE3AlgebraStorage<double,cva::Matrix<double,6u,1u,false>>::hat@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  double v2 = *(double *)(a1 + 16);
  *(double *)(a2 + 32) = -v2;
  double v4 = *(double *)a1;
  double v3 = *(double *)(a1 + 8);
  double v5 = -*(double *)a1;
  *(double *)(a2 + 64) = v3;
  *(double *)(a2 + 72) = v5;
  *(_OWORD *)(a2 + 96) = *(_OWORD *)(a1 + 24);
  *(void *)a2 = 0;
  *(void *)(a2 + 40) = 0;
  *(double *)(a2 + 8) = v2;
  *(double *)(a2 + 16) = -v3;
  *(double *)(a2 + 48) = v4;
  double result = *(double *)(a1 + 40);
  *(double *)(a2 + 112) = result;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 80) = 0;
  *(void *)(a2 + 88) = 0;
  *(void *)(a2 + 120) = 0;
  return result;
}

uint64_t cva::SE3AlgebraStorage<double,cva::Matrix<double,6u,1u,false>>::exp@<X0>(float64x2_t *a1@<X0>, uint64_t a2@<X8>, double a3@<D0>)
{
  *(_OWORD *)(a2 + 64) = xmmword_2154460C0;
  *(_OWORD *)(a2 + 80) = unk_2154460D0;
  *(_OWORD *)(a2 + 96) = xmmword_2154460E0;
  *(_OWORD *)(a2 + 112) = unk_2154460F0;
  *(_OWORD *)a2 = xmmword_215446080;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)algn_215446090;
  *(_OWORD *)(a2 + 32) = xmmword_2154460A0;
  *(_OWORD *)(a2 + 48) = unk_2154460B0;
  float64_t v4 = a1->f64[1] * a3;
  v15[0] = a1->f64[0] * a3;
  v15[1] = v4;
  float64x2_t v5 = vmulq_n_f64(a1[1], a3);
  float64x2_t v6 = vmulq_n_f64(a1[2], a3);
  float64x2_t v16 = v5;
  float64x2_t v17 = v6;
  double v7 = v15[0] * v15[0] + v4 * v4 + vmulq_f64(v5, v5).f64[0];
  if (v7 >= 0.0000002635)
  {
    double v12 = sqrt(v7);
    __double2 v13 = __sincos_stret(v12);
    double cosval = v13.__cosval;
    double v10 = v13.__sinval / v12;
    double v8 = 1.0 / v7 * (1.0 - v13.__cosval);
    double v9 = 1.0 / v7 * (1.0 - v13.__sinval / v12);
  }
  else
  {
    double v8 = 0.5 - v7 * (v7 / -720.0 + 0.0416666667);
    double v9 = 0.166666667 - v7 * (v7 / -5040.0 + 0.00833333333);
    double v10 = 1.0 - v7 * v9;
    double cosval = 1.0 - v7 * v8;
  }
  void v18[2] = v8;
  v18[3] = v9;
  v18[0] = cosval;
  v18[1] = v10;
  return sub_2153DBF80((uint64_t)v15, v18, (float64x2_t *)a2);
}

void cva::SE3AlgebraStorage<double,cva::Matrix<double,6u,1u,false>>::expJacobian(double *a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 64) = xmmword_2154460C0;
  *(_OWORD *)(a2 + 80) = unk_2154460D0;
  *(_OWORD *)(a2 + 96) = xmmword_2154460E0;
  *(_OWORD *)(a2 + 112) = unk_2154460F0;
  *(_OWORD *)a2 = xmmword_215446080;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)algn_215446090;
  *(_OWORD *)(a2 + 32) = xmmword_2154460A0;
  *(_OWORD *)(a2 + 48) = unk_2154460B0;
  uint64_t v4 = a2 + 128;
  *(_OWORD *)(a2 + 168) = 0u;
  *(_OWORD *)(a2 + 184) = 0u;
  *(_OWORD *)(a2 + 200) = 0u;
  *(_OWORD *)(a2 + 216) = 0u;
  *(_OWORD *)(a2 + 232) = 0u;
  *(_OWORD *)(a2 + 248) = 0u;
  *(void *)(a2 + 408) = 0;
  *(_OWORD *)(a2 + 264) = 0u;
  *(_OWORD *)(a2 + 280) = 0u;
  *(_OWORD *)(a2 + 296) = 0u;
  *(_OWORD *)(a2 + 312) = 0u;
  *(_OWORD *)(a2 + 328) = 0u;
  *(_OWORD *)(a2 + 344) = 0u;
  *(_OWORD *)(a2 + 360) = 0u;
  *(_OWORD *)(a2 + 376) = 0u;
  *(_OWORD *)(a2 + 152) = 0u;
  *(_OWORD *)(a2 + 392) = 0u;
  v76[0] = a1 + 3;
  v76[1] = 0x300000006;
  double v5 = *a1;
  double v6 = a1[1];
  double v7 = v5 * v5;
  double v8 = v6 * v6;
  double v9 = a1[2];
  double v10 = v9 * v9;
  double v11 = v5 * v5 + v6 * v6 + v9 * v9;
  if (v11 >= 0.0000002635)
  {
    double v19 = sqrt(v11);
    __double2 v20 = __sincos_stret(v19);
    double cosval = v20.__cosval;
    double v7 = v5 * v5;
    double v10 = v9 * v9;
    double v14 = v20.__sinval / v19;
    double v12 = 1.0 / v11 * (1.0 - v20.__cosval);
    double v13 = 1.0 / v11 * (1.0 - v14);
    double v16 = v13 - v12;
    double v17 = 1.0 / v11 * (v14 + v12 * -2.0);
    double v18 = 1.0 / v11 * (v12 + v13 * -3.0);
  }
  else
  {
    double v12 = 0.5 - v11 * (v11 / -720.0 + 0.0416666667);
    double v13 = 0.166666667 - v11 * (v11 / -5040.0 + 0.00833333333);
    double v14 = 1.0 - v11 * v13;
    double cosval = 1.0 - v11 * v12;
    double v16 = v11 * (v11 * -0.00119047619 + 0.0333333333) + -0.333333333;
    double v17 = v11 * (v11 * -0.000148809524 + 0.00555555556) + -0.0833333333;
    double v18 = v11 * (v11 * -0.0000165343915 + 0.000793650794) + -0.0166666667;
  }
  double v21 = cosval + v5 * v12 * v5;
  double v22 = cosval + v6 * v12 * v6;
  *(double *)(a2 + 80) = cosval + v9 * v12 * v9;
  double v23 = v5 * v12 * v6;
  double v24 = v5 * v12 * v9;
  double v25 = v6 * v12 * v9;
  *(double *)(a2 + 32) = v23 - v14 * v9;
  *(double *)(a2 + 40) = v22;
  *(double *)a2 = v21;
  *(double *)(a2 + 8) = v23 + v14 * v9;
  *(double *)(a2 + 64) = v14 * v6 + v24;
  *(double *)(a2 + 72) = v25 - v14 * v5;
  *(double *)(a2 + 16) = v24 - v14 * v6;
  *(double *)(a2 + 48) = v25 + v14 * v5;
  v75[0] = v4;
  v75[1] = 6;
  double v26 = v14 + v13 * v5 * v5;
  double v27 = v14 + v13 * v6 * v6;
  double v28 = v14 + v13 * v9 * v9;
  double v29 = v13 * v5 * v6;
  double v30 = v13 * v5 * v9;
  double v31 = v13 * v6 * v9;
  double v32 = v29 - v9 * v12;
  *(double *)(a2 + 176) = v32;
  *(double *)(a2 + 184) = v27;
  double v33 = v6 * v12 + v30;
  double v34 = v29 + v9 * v12;
  *(double *)(a2 + 128) = v26;
  *(double *)(a2 + 136) = v34;
  double v35 = v31 - v5 * v12;
  *(double *)(a2 + 224) = v33;
  *(double *)(a2 + 232) = v35;
  *(double *)(a2 + 240) = v28;
  double v36 = v30 - v6 * v12;
  *(double *)(a2 + 144) = v36;
  double v37 = v31 + v5 * v12;
  *(double *)(a2 + 192) = v37;
  v74[0] = v75;
  v74[1] = v76;
  if (a1 == (double *)a2)
  {
    long long v77 = 0uLL;
    double v78 = 0.0;
    double v73 = v17;
    double v43 = v10;
    double v44 = v7;
    double v72 = v18;
    sub_2153DFC78((double *)&v77, v74);
    double v18 = v72;
    double v17 = v73;
    double v7 = v44;
    double v10 = v43;
    double v8 = v6 * v6;
    *(_OWORD *)(a2 + 96) = v77;
    double v42 = v78;
    double v38 = a1[3];
    double v39 = a1[4];
    double v41 = a1[5];
  }
  else
  {
    double v38 = a1[3];
    double v39 = a1[4];
    double v40 = v26 * v38 + 0.0 + v32 * v39;
    double v41 = a1[5];
    *(double *)(a2 + 96) = v40 + v33 * v41;
    *(double *)(a2 + 104) = v34 * v38 + 0.0 + v27 * v39 + v35 * v41;
    double v42 = v36 * v38 + 0.0 + v37 * v39 + v28 * v41;
  }
  *(double *)(a2 + 112) = v42;
  double v45 = v5 * v38 + v6 * v39 + v9 * v41;
  double v46 = (v16 + v18 * v7) * v45 + (v13 + v13) * (v5 * v38);
  double v47 = (v16 + v18 * v8) * v45 + (v13 + v13) * (v6 * v39);
  *(double *)(a2 + 264) = (v16 + v18 * v10) * v45 + (v13 + v13) * (v9 * v41);
  double v48 = v18 * v45 * v5;
  double v49 = v6 * v48 + v13 * (v39 * v5 + v38 * v6);
  double v50 = v48 * v9 + v13 * (v5 * v41 + v38 * v9);
  double v51 = v18 * v45 * v6 * v9 + v13 * (v6 * v41 + v39 * v9);
  double v52 = v17 * v45;
  double v53 = v52 * v9 + v12 * v41;
  double v54 = v52 * v6 + v12 * v39;
  double v55 = v52 * v5 + v12 * v38;
  *(double *)(a2 + 200) = v49 - v53;
  *(double *)(a2 + 208) = v47;
  *(double *)(a2 + 152) = v46;
  *(double *)(a2 + 160) = v49 + v53;
  *(double *)(a2 + 168) = v50 - v54;
  *(double *)(a2 + 248) = v54 + v50;
  *(double *)(a2 + 256) = v51 - v55;
  *(double *)(a2 + 216) = v55 + v51;
  unint64_t v56 = 0x300000000;
  for (uint64_t i = 18; i != 36; uint64_t i = v60 + 1)
  {
    *(void *)(v4 + 8 * i) = 0;
    unint64_t v58 = HIDWORD(v56);
    BOOL v59 = (int)v56 < 2;
    if ((int)v56 < 2) {
      unint64_t v58 = 0;
    }
    unint64_t v60 = i + v58;
    uint64_t v61 = (v56 + 1);
    unint64_t v62 = v56 & 0xFFFFFFFF00000000;
    if (!v59) {
      uint64_t v61 = 0;
    }
    unint64_t v56 = v61 | v62;
  }
  long long v77 = *(_OWORD *)(a2 + 128);
  double v78 = *(double *)(a2 + 144);
  long long v79 = *(_OWORD *)(a2 + 176);
  uint64_t v80 = *(void *)(a2 + 192);
  long long v81 = *(_OWORD *)(a2 + 224);
  unint64_t v63 = 0x300000000;
  long long v64 = (uint64_t *)&v77;
  uint64_t v65 = 21;
  uint64_t v82 = *(void *)(a2 + 240);
  do
  {
    uint64_t v66 = *v64++;
    *(void *)(v4 + 8 * v65) = v66;
    unint64_t v67 = HIDWORD(v63);
    BOOL v68 = (int)v63 < 2;
    if ((int)v63 < 2) {
      unint64_t v67 = 0;
    }
    unint64_t v69 = v65 + v67;
    uint64_t v70 = (v63 + 1);
    unint64_t v71 = v63 & 0xFFFFFFFF00000000;
    if (!v68) {
      uint64_t v70 = 0;
    }
    unint64_t v63 = v70 | v71;
    uint64_t v65 = v69 + 1;
  }
  while (v65 != 39);
}

double *sub_2153DFC78(double *result, uint64_t **a2)
{
  double v2 = result;
  uint64_t v3 = **a2;
  if ((double *)(v3 - 8 * *((unsigned int *)*a2 + 3)) == result
    || (v4 = a2[1], double v5 = (double *)*v4, (double *)(*v4 - 8 * *((unsigned int *)v4 + 3)) == result))
  {
    long long v21 = 0uLL;
    uint64_t v22 = 0;
    double result = (double *)sub_2153DFC78(&v21);
    *(_OWORD *)double v2 = v21;
    *((void *)v2 + 2) = v22;
  }
  else
  {
    uint64_t v6 = *((unsigned int *)*a2 + 2);
    if (v6)
    {
      uint64_t v7 = 0;
      uint64_t v8 = 8 * (3 * v6);
      uint64_t v9 = 8 * v6;
      double v10 = 0.0;
      double v11 = v5;
      do
      {
        double v12 = *v11++;
        double v10 = v10 + *(double *)(v3 + v7) * v12;
        v7 += v9;
      }
      while (v8 != v7);
      uint64_t v13 = 0;
      *double result = v10;
      double v14 = 0.0;
      unint64_t v15 = v5;
      do
      {
        double v16 = *v15++;
        double v14 = v14 + *(double *)(v3 + 8 + v13) * v16;
        v13 += v9;
      }
      while (v8 != v13);
      uint64_t v17 = 0;
      result[1] = v14;
      uint64_t v18 = v3 + 16;
      double v19 = 0.0;
      do
      {
        double v20 = *v5++;
        double v19 = v19 + *(double *)(v18 + v17) * v20;
        v17 += v9;
      }
      while (v8 != v17);
    }
    else
    {
      *double result = 0.0;
      result[1] = 0.0;
      double v19 = 0.0;
    }
    result[2] = v19;
  }
  return result;
}

void cva::SE3AlgebraStorage<double,cva::Matrix<double,6u,1u,false>>::enforce(double *a1)
{
  double v1 = *a1;
  double v2 = a1[1];
  double v3 = a1[2];
  double v4 = v1 * v1 + v2 * v2 + v3 * v3;
  if (v4 > 9.8696044)
  {
    if (v4 >= 0.0000002635)
    {
      double v9 = sqrt(v4);
      __double2 v10 = __sincos_stret(v9);
      double v8 = v10.__sinval / v9;
      double v6 = 1.0 / v4 * (1.0 - v10.__cosval);
      double v7 = 1.0 / v4 * (1.0 - v10.__sinval / v9);
    }
    else
    {
      double v6 = 0.5 - v4 * (v4 / -720.0 + 0.0416666667);
      double v7 = 0.166666667 - v4 * (v4 / -5040.0 + 0.00833333333);
      double v8 = 1.0 - v4 * v7;
    }
    double v11 = a1[3];
    double v12 = a1[4];
    double v13 = a1[5];
    double v14 = v2 * v13 - v3 * v12;
    double v15 = v3 * v11 - v1 * v13;
    double v16 = v1 * v12 - v2 * v11;
    double v17 = v11 + v6 * v14 + v7 * (v2 * v16 - v3 * v15);
    double v18 = v12 + v6 * v15 + v7 * (v3 * v14 - v1 * v16);
    double v19 = v7 * (v1 * v15 - v2 * v14) + v13 + v6 * v16;
    double v20 = v2 * v2 + v1 * v1 + v3 * v3;
    if (v20 <= 9.8696044)
    {
      double v26 = 1.0;
      double v25 = 1.0;
    }
    else
    {
      double v21 = sqrt(v20) / 3.14159265;
      double v22 = ceil(v21) + -1.0;
      int v23 = (int)v22;
      double v24 = v21 - v22;
      if (v23) {
        double v24 = v24 + -1.0;
      }
      double v25 = v24 / v21;
      double v1 = v1 * v25;
      double v2 = v2 * v25;
      *a1 = v1;
      a1[1] = v2;
      double v3 = v3 * v25;
      a1[2] = v3;
      double v26 = v25 * v25;
      double v4 = v4 * (v25 * v25);
      if (v25 >= -0.00000001054 && v25 <= 0.00000001054)
      {
        if (v4 >= 2.775e-15)
        {
          if (v4 >= 0.0000002635)
          {
            double v37 = sqrt(v4);
            double v38 = v19;
            __double2 v39 = __sincos_stret(v37);
            double v19 = v38;
            double v36 = v39.__sinval / v37;
            double v34 = 1.0 / v4 * (1.0 - v39.__cosval);
            double v35 = 1.0 / v4 * (1.0 - v39.__sinval / v37);
          }
          else
          {
            double v34 = 0.5 - v4 * (v4 / -720.0 + 0.0416666667);
            double v35 = 0.166666667 - v4 * (v4 / -5040.0 + 0.00833333333);
            double v36 = 1.0 - v4 * v35;
          }
          double v27 = -(v35 - v34 * 0.5) / v36;
        }
        else
        {
          double v27 = v4 * 0.00138888889 + 0.0833333333 + v4 * 0.0000330687831;
        }
LABEL_15:
        double v31 = v2 * v19 - v3 * v18;
        double v32 = v3 * v17 - v1 * v19;
        double v33 = v1 * v18 - v2 * v17;
        a1[3] = v17 - v31 * 0.5 + v27 * (v2 * v33 - v3 * v32);
        a1[4] = v18 - v32 * 0.5 + v27 * (v3 * v31 - v1 * v33);
        a1[5] = v19 - v33 * 0.5 + v27 * (v1 * v32 - v2 * v31);
        return;
      }
    }
    double v28 = v8 / v25;
    double v29 = v6 / v26;
    double v30 = (-(1.0 - v28) / v4 + v29 * 0.5) / v28;
    double v27 = (v29 + v28 * -0.5) / (v4 * v29);
    if (v4 <= 9.0) {
      double v27 = v30;
    }
    goto LABEL_15;
  }
}

uint64_t cva::SE3AlgebraStorage<double,cva::Matrix<double,6u,1u,false>>::serialize()
{
  return std::ostream::write();
}

uint64_t cva::SE3AlgebraStorage<double,cva::Matrix<double,6u,1u,false>>::deserialize(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x270F98678](a2, a1, 48);
}

uint64_t cva::SE3AlgebraStorage<float,cva::MatrixRef<float const,6u,1u,false>>::R(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t cva::SE3AlgebraStorage<float,cva::MatrixRef<float const,6u,1u,false>>::T(uint64_t a1)
{
  return *(void *)a1 - 4 * *(unsigned int *)(a1 + 12) + 4 * (*(_DWORD *)(a1 + 12) + 3);
}

uint64_t cva::SE3AlgebraStorage<float,cva::MatrixRef<float const,6u,1u,false>>::adjoint@<X0>(uint64_t result@<X0>, int *a2@<X8>)
{
  uint64_t v2 = 0;
  *((_OWORD *)a2 + 7) = 0u;
  *((_OWORD *)a2 + 8) = 0u;
  *((_OWORD *)a2 + 5) = 0u;
  *((_OWORD *)a2 + 6) = 0u;
  *((_OWORD *)a2 + 3) = 0u;
  *((_OWORD *)a2 + 4) = 0u;
  *((_OWORD *)a2 + 1) = 0u;
  *((_OWORD *)a2 + 2) = 0u;
  *(_OWORD *)a2 = 0u;
  double v3 = *(float **)result;
  float v4 = **(float **)result;
  float v5 = *(float *)(*(void *)result + 4);
  float v6 = *(float *)(*(void *)result + 8);
  int v47 = 0;
  *(float *)&long long v48 = v6;
  *((float *)&v48 + 1) = -v5;
  *((float *)&v48 + 2) = -v6;
  HIDWORD(v48) = 0;
  float v49 = v4;
  *(float *)&unint64_t v50 = v5;
  *((float *)&v50 + 1) = -v4;
  int v51 = 0;
  unint64_t v7 = 0x300000000;
  double v8 = &v47;
  do
  {
    int v9 = *v8++;
    a2[v2] = v9;
    unint64_t v10 = HIDWORD(v7);
    BOOL v11 = (int)v7 < 2;
    if ((int)v7 < 2) {
      unint64_t v10 = 0;
    }
    uint64_t v12 = v2 + v10;
    uint64_t v13 = (v7 + 1);
    unint64_t v14 = v7 & 0xFFFFFFFF00000000;
    if (!v11) {
      uint64_t v13 = 0;
    }
    unint64_t v7 = v13 | v14;
    uint64_t v2 = v12 + 1;
  }
  while (v2 != 18);
  long long v15 = *(_OWORD *)(a2 + 1);
  long long v16 = *(_OWORD *)(a2 + 6);
  *((void *)&v15 + 1) = *((void *)a2 + 3);
  int v47 = *a2;
  long long v48 = v15;
  double v17 = &v47;
  float v49 = *((float *)&v16 + 2);
  unint64_t v50 = *((void *)a2 + 6);
  int v51 = a2[14];
  unint64_t v18 = 0x300000000;
  for (uint64_t i = 21; i != 39; uint64_t i = v23 + 1)
  {
    int v20 = *v17++;
    a2[i] = v20;
    unint64_t v21 = HIDWORD(v18);
    BOOL v22 = (int)v18 < 2;
    if ((int)v18 < 2) {
      unint64_t v21 = 0;
    }
    unint64_t v23 = i + v21;
    uint64_t v24 = (v18 + 1);
    unint64_t v25 = v18 & 0xFFFFFFFF00000000;
    if (!v22) {
      uint64_t v24 = 0;
    }
    unint64_t v18 = v24 | v25;
  }
  uint64_t v26 = (uint64_t)&v3[*(_DWORD *)(result + 12) + 3 - *(unsigned int *)(result + 12)];
  float v27 = *(float *)v26;
  float v28 = *(float *)(v26 + 4);
  float v29 = *(float *)(v26 + 8);
  *(float *)&unsigned int v30 = -*(float *)v26;
  int v47 = 0;
  *(float *)&long long v48 = v29;
  *((float *)&v48 + 1) = -v28;
  *((float *)&v48 + 2) = -v29;
  HIDWORD(v48) = 0;
  float v49 = v27;
  unint64_t v50 = __PAIR64__(v30, LODWORD(v28));
  int v51 = 0;
  unint64_t v31 = 0x300000000;
  double v32 = &v47;
  for (uint64_t j = 3; j != 21; uint64_t j = v37 + 1)
  {
    int v34 = *v32++;
    a2[j] = v34;
    unint64_t v35 = HIDWORD(v31);
    BOOL v36 = (int)v31 < 2;
    if ((int)v31 < 2) {
      unint64_t v35 = 0;
    }
    unint64_t v37 = j + v35;
    uint64_t v38 = (v31 + 1);
    unint64_t v39 = v31 & 0xFFFFFFFF00000000;
    if (!v36) {
      uint64_t v38 = 0;
    }
    unint64_t v31 = v38 | v39;
  }
  unint64_t v40 = 0x300000000;
  for (uint64_t k = 18; k != 36; uint64_t k = v44 + 1)
  {
    a2[k] = 0;
    unint64_t v42 = HIDWORD(v40);
    BOOL v43 = (int)v40 < 2;
    if ((int)v40 < 2) {
      unint64_t v42 = 0;
    }
    unint64_t v44 = k + v42;
    uint64_t v45 = (v40 + 1);
    unint64_t v46 = v40 & 0xFFFFFFFF00000000;
    if (!v43) {
      uint64_t v45 = 0;
    }
    unint64_t v40 = v45 | v46;
  }
  return result;
}

float cva::SE3AlgebraStorage<float,cva::MatrixRef<float const,6u,1u,false>>::hat@<S0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *a1;
  float v3 = *(float *)(*a1 + 8);
  *(float *)(a2 + 16) = -v3;
  float v5 = *(float *)v2;
  float v4 = *(float *)(v2 + 4);
  float v6 = -*(float *)v2;
  *(float *)(a2 + 32) = v4;
  *(float *)(a2 + 36) = v6;
  *(void *)(a2 + 48) = *(void *)(v2 + 12);
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 20) = 0;
  *(float *)(a2 + 4) = v3;
  *(float *)(a2 + 8) = -v4;
  *(float *)(a2 + 24) = v5;
  float result = *(float *)(v2 + 20);
  *(float *)(a2 + 56) = result;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 28) = 0;
  *(void *)(a2 + 40) = 0;
  *(_DWORD *)(a2 + 60) = 0;
  return result;
}

uint64_t cva::SE3AlgebraStorage<float,cva::MatrixRef<float const,6u,1u,false>>::exp@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>, float a3@<S0>)
{
  *(_OWORD *)a2 = xmmword_215446040;
  *(_OWORD *)(a2 + 16) = unk_215446050;
  *(_OWORD *)(a2 + 32) = xmmword_215446060;
  *(_OWORD *)(a2 + 48) = unk_215446070;
  memset(v18, 0, sizeof(v18));
  float v4 = *(float **)a1;
  float v5 = **(float **)a1 * a3;
  if ((unsigned char *)(*(void *)a1 - 4 * *(unsigned int *)(a1 + 12)) == v18)
  {
    float v7 = v4[5] * a3;
    *(float *)unint64_t v18 = **(float **)a1 * a3;
    float32x4_t v6 = vmulq_n_f32(*(float32x4_t *)(v4 + 1), a3);
    *(float32x4_t *)&double v18[4] = v6;
    *(float *)&v18[20] = v7;
  }
  else
  {
    *(float *)unint64_t v18 = **(float **)a1 * a3;
    float32x4_t v6 = vmulq_n_f32(*(float32x4_t *)(v4 + 1), a3);
    *(float32x4_t *)&double v18[4] = v6;
    *(float *)&v18[20] = v4[5] * a3;
  }
  float v8 = v5 * v5;
  unint64_t v9 = vmulq_f32(v6, v6).u64[0];
  float v10 = (float)(v8 + *(float *)&v9) + *((float *)&v9 + 1);
  if (v10 >= 0.0061)
  {
    float v15 = sqrtf(v10);
    __float2 v16 = __sincosf_stret(v15);
    float cosval = v16.__cosval;
    float v13 = v16.__sinval / v15;
    float v11 = (float)(1.0 / v10) * (float)(1.0 - v16.__cosval);
    float v12 = (float)(1.0 / v10) * (float)(1.0 - (float)(v16.__sinval / v15));
  }
  else
  {
    float v11 = 0.5 - (float)(v10 * (float)((float)(v10 / -720.0) + 0.041667));
    float v12 = 0.16667 - (float)(v10 * (float)((float)(v10 / -5040.0) + 0.0083333));
    float v13 = 1.0 - (float)(v10 * v12);
    float cosval = 1.0 - (float)(v10 * v11);
  }
  void v19[2] = v11;
  v19[3] = v12;
  v19[0] = cosval;
  v19[1] = v13;
  return sub_2153D986C((uint64_t)v18, v19, (float32x2_t *)a2);
}

void cva::SE3AlgebraStorage<float,cva::MatrixRef<float const,6u,1u,false>>::expJacobian(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)a2 = xmmword_215446040;
  *(_OWORD *)(a2 + 16) = unk_215446050;
  *(_OWORD *)(a2 + 32) = xmmword_215446060;
  *(_OWORD *)(a2 + 48) = unk_215446070;
  uint64_t v3 = a2 + 64;
  *(_OWORD *)(a2 + 76) = 0u;
  *(_OWORD *)(a2 + 92) = 0u;
  *(_OWORD *)(a2 + 108) = 0u;
  *(_OWORD *)(a2 + 124) = 0u;
  *(_OWORD *)(a2 + 140) = 0u;
  *(_OWORD *)(a2 + 156) = 0u;
  *(_OWORD *)(a2 + 172) = 0u;
  *(_OWORD *)(a2 + 188) = 0u;
  *(_DWORD *)(a2 + 204) = 0;
  float v4 = *(float **)a1;
  uint64_t v5 = *(unsigned int *)(a1 + 12);
  uint64_t v6 = *(void *)a1 - 4 * v5;
  uint64_t v7 = (v5 + 3);
  float v8 = (float *)(v6 + 4 * v7);
  unint64_t v9 = *(unsigned int *)(a1 + 8) | (unint64_t)(v7 << 32);
  v83[0] = v8;
  v83[1] = v9;
  float v10 = *v4;
  float v11 = v4[1];
  float v12 = v10 * v10;
  float v13 = v11 * v11;
  float v14 = v4[2];
  float v15 = v14 * v14;
  float v16 = (float)((float)(v10 * v10) + (float)(v11 * v11)) + (float)(v14 * v14);
  if (v16 >= 0.0061)
  {
    float v24 = sqrtf(v16);
    __float2 v25 = __sincosf_stret(v24);
    float cosval = v25.__cosval;
    float v12 = v10 * v10;
    float v15 = v14 * v14;
    float v19 = v25.__sinval / v24;
    float v17 = (float)(1.0 / v16) * (float)(1.0 - v25.__cosval);
    float v18 = (float)(1.0 / v16) * (float)(1.0 - v19);
    float v21 = v18 - v17;
    float v22 = (float)(1.0 / v16) * (float)(v19 + (float)(v17 * -2.0));
    float v23 = (float)(1.0 / v16) * (float)(v17 + (float)(v18 * -3.0));
  }
  else
  {
    float v17 = 0.5 - (float)(v16 * (float)((float)(v16 / -720.0) + 0.041667));
    float v18 = 0.16667 - (float)(v16 * (float)((float)(v16 / -5040.0) + 0.0083333));
    float v19 = 1.0 - (float)(v16 * v18);
    float cosval = 1.0 - (float)(v16 * v17);
    float v21 = (float)(v16 * (float)((float)(v16 * -0.0011905) + 0.033333)) + -0.33333;
    float v22 = (float)(v16 * (float)((float)(v16 * -0.00014881) + 0.0055556)) + -0.083333;
    float v23 = (float)(v16 * (float)((float)(v16 * -0.000016534) + 0.00079365)) + -0.016667;
  }
  float v26 = cosval + (float)((float)(v10 * v17) * v10);
  float v27 = cosval + (float)((float)(v11 * v17) * v11);
  *(float *)(a2 + 40) = cosval + (float)((float)(v14 * v17) * v14);
  float v28 = (float)(v10 * v17) * v11;
  float v29 = (float)(v10 * v17) * v14;
  float v30 = (float)(v11 * v17) * v14;
  *(float *)(a2 + 16) = v28 - (float)(v19 * v14);
  *(float *)(a2 + 20) = v27;
  *(float *)a2 = v26;
  *(float *)(a2 + 4) = v28 + (float)(v19 * v14);
  *(float *)(a2 + 32) = (float)(v19 * v11) + v29;
  *(float *)(a2 + 36) = v30 - (float)(v19 * v10);
  *(float *)(a2 + 8) = v29 - (float)(v19 * v11);
  *(float *)(a2 + 24) = v30 + (float)(v19 * v10);
  v82[0] = v3;
  v82[1] = 6;
  float v31 = v19 + (float)((float)(v18 * v10) * v10);
  float v32 = v19 + (float)((float)(v18 * v11) * v11);
  float v33 = v19 + (float)((float)(v18 * v14) * v14);
  float v34 = (float)(v18 * v10) * v11;
  float v35 = (float)(v18 * v10) * v14;
  float v36 = (float)(v18 * v11) * v14;
  float v37 = v34 - (float)(v14 * v17);
  *(float *)(a2 + 88) = v37;
  *(float *)(a2 + 92) = v32;
  float v38 = (float)(v11 * v17) + v35;
  float v39 = v34 + (float)(v14 * v17);
  *(float *)(a2 + 64) = v31;
  *(float *)(a2 + 68) = v39;
  float v40 = v36 - (float)(v10 * v17);
  *(float *)(a2 + 112) = v38;
  *(float *)(a2 + 116) = v40;
  *(float *)(a2 + 120) = v33;
  float v41 = v35 - (float)(v11 * v17);
  *(float *)(a2 + 72) = v41;
  float v42 = v36 + (float)(v10 * v17);
  *(float *)(a2 + 96) = v42;
  *(void *)float64x2_t v86 = v82;
  *(void *)&v86[8] = v83;
  if (v6 == a2)
  {
    int v85 = 0;
    uint64_t v84 = 0;
    float v81 = v22;
    float v49 = v15;
    float v50 = v12;
    float v80 = v23;
    sub_2153DEE60((float *)&v84, (uint64_t **)v86);
    float v23 = v80;
    float v22 = v81;
    float v12 = v50;
    float v15 = v49;
    float v13 = v11 * v11;
    *(void *)(a2 + 48) = v84;
    *(_DWORD *)(a2 + 56) = v85;
    float v43 = *v8;
    float v44 = v8[1];
    float v46 = v8[2];
  }
  else
  {
    float v43 = *v8;
    float v44 = v8[1];
    float v45 = (float)((float)(v31 * *v8) + 0.0) + (float)(v37 * v44);
    float v46 = v8[2];
    float v47 = v45 + (float)(v38 * v46);
    float v48 = (float)(v39 * *v8) + 0.0;
    *(float *)(a2 + 48) = v47;
    *(float *)(a2 + 52) = (float)(v48 + (float)(v32 * v44)) + (float)(v40 * v46);
    *(float *)(a2 + 56) = (float)((float)((float)(v41 * v43) + 0.0) + (float)(v42 * v44)) + (float)(v33 * v46);
  }
  float v51 = (float)((float)(v10 * v43) + (float)(v11 * v44)) + (float)(v14 * v46);
  float v52 = (float)((float)(v21 + (float)(v23 * v12)) * v51) + (float)((float)(v18 + v18) * (float)(v10 * v43));
  float v53 = (float)((float)(v21 + (float)(v23 * v13)) * v51) + (float)((float)(v18 + v18) * (float)(v11 * v44));
  *(float *)(a2 + 132) = (float)((float)(v21 + (float)(v23 * v15)) * v51)
                       + (float)((float)(v18 + v18) * (float)(v14 * v46));
  float v54 = (float)(v23 * v51) * v10;
  float v55 = (float)(v11 * v54) + (float)(v18 * (float)((float)(v44 * v10) + (float)(v43 * v11)));
  float v56 = (float)(v54 * v14) + (float)(v18 * (float)((float)(v10 * v46) + (float)(v43 * v14)));
  float v57 = (float)((float)((float)(v23 * v51) * v11) * v14)
      + (float)(v18 * (float)((float)(v11 * v46) + (float)(v44 * v14)));
  float v58 = v22 * v51;
  float v59 = (float)(v58 * v14) + (float)(v17 * v46);
  float v60 = (float)(v58 * v11) + (float)(v17 * v44);
  float v61 = (float)(v58 * v10) + (float)(v17 * v43);
  *(float *)(a2 + 100) = v55 - v59;
  *(float *)(a2 + 104) = v53;
  *(float *)(a2 + 76) = v52;
  *(float *)(a2 + 80) = v55 + v59;
  *(float *)(a2 + 84) = v56 - v60;
  *(float *)(a2 + 124) = v60 + v56;
  *(float *)(a2 + 128) = v57 - v61;
  *(float *)(a2 + 108) = v61 + v57;
  unint64_t v62 = 0x300000000;
  for (uint64_t i = 18; i != 36; uint64_t i = v66 + 1)
  {
    *(_DWORD *)(v3 + 4 * i) = 0;
    unint64_t v64 = HIDWORD(v62);
    BOOL v65 = (int)v62 < 2;
    if ((int)v62 < 2) {
      unint64_t v64 = 0;
    }
    unint64_t v66 = i + v64;
    uint64_t v67 = (v62 + 1);
    unint64_t v68 = v62 & 0xFFFFFFFF00000000;
    if (!v65) {
      uint64_t v67 = 0;
    }
    unint64_t v62 = v67 | v68;
  }
  long long v69 = *(_OWORD *)(a2 + 68);
  long long v70 = *(_OWORD *)(a2 + 88);
  *((void *)&v69 + 1) = *(void *)(a2 + 88);
  *(_DWORD *)float64x2_t v86 = *(_DWORD *)(a2 + 64);
  *(_OWORD *)&v86[4] = v69;
  unint64_t v71 = (int *)v86;
  int v87 = DWORD2(v70);
  uint64_t v88 = *(void *)(a2 + 112);
  int v89 = *(_DWORD *)(a2 + 120);
  unint64_t v72 = 0x300000000;
  for (uint64_t j = 21; j != 39; uint64_t j = v77 + 1)
  {
    int v74 = *v71++;
    *(_DWORD *)(v3 + 4 * j) = v74;
    unint64_t v75 = HIDWORD(v72);
    BOOL v76 = (int)v72 < 2;
    if ((int)v72 < 2) {
      unint64_t v75 = 0;
    }
    unint64_t v77 = j + v75;
    uint64_t v78 = (v72 + 1);
    unint64_t v79 = v72 & 0xFFFFFFFF00000000;
    if (!v76) {
      uint64_t v78 = 0;
    }
    unint64_t v72 = v78 | v79;
  }
}

uint64_t cva::SE3AlgebraStorage<float,cva::MatrixRef<float const,6u,1u,false>>::serialize()
{
  return std::ostream::write();
}

uint64_t cva::SE3AlgebraStorage<double,cva::MatrixRef<double const,6u,1u,false>>::R(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t cva::SE3AlgebraStorage<double,cva::MatrixRef<double const,6u,1u,false>>::T(uint64_t a1)
{
  return *(void *)a1 - 8 * *(unsigned int *)(a1 + 12) + 8 * (*(_DWORD *)(a1 + 12) + 3);
}

uint64_t cva::SE3AlgebraStorage<double,cva::MatrixRef<double const,6u,1u,false>>::adjoint@<X0>(uint64_t result@<X0>, _OWORD *a2@<X8>)
{
  uint64_t v2 = 0;
  a2[16] = 0u;
  a2[17] = 0u;
  a2[14] = 0u;
  a2[15] = 0u;
  a2[12] = 0u;
  a2[13] = 0u;
  a2[10] = 0u;
  a2[11] = 0u;
  a2[8] = 0u;
  a2[9] = 0u;
  a2[6] = 0u;
  a2[7] = 0u;
  a2[4] = 0u;
  a2[5] = 0u;
  a2[2] = 0u;
  a2[3] = 0u;
  *a2 = 0u;
  a2[1] = 0u;
  uint64_t v3 = *(double **)result;
  double v4 = **(double **)result;
  double v5 = *(double *)(*(void *)result + 8);
  double v6 = -*(double *)(*(void *)result + 16);
  *((void *)&v45 + 1) = *(void *)(*(void *)result + 16);
  double v46 = -v5;
  *(double *)&long long v47 = v6;
  *((void *)&v47 + 1) = 0;
  double v48 = v4;
  *(double *)&long long v49 = v5;
  *((double *)&v49 + 1) = -v4;
  unint64_t v7 = 0x300000000;
  float v8 = (uint64_t *)&v45;
  uint64_t v50 = 0;
  do
  {
    uint64_t v9 = *v8++;
    *((void *)a2 + v2) = v9;
    unint64_t v10 = HIDWORD(v7);
    BOOL v11 = (int)v7 < 2;
    if ((int)v7 < 2) {
      unint64_t v10 = 0;
    }
    uint64_t v12 = v2 + v10;
    uint64_t v13 = (v7 + 1);
    unint64_t v14 = v7 & 0xFFFFFFFF00000000;
    if (!v11) {
      uint64_t v13 = 0;
    }
    unint64_t v7 = v13 | v14;
    uint64_t v2 = v12 + 1;
  }
  while (v2 != 18);
  long long v45 = *a2;
  double v46 = *((double *)a2 + 2);
  long long v47 = a2[3];
  double v48 = *((double *)a2 + 8);
  long long v49 = a2[6];
  unint64_t v15 = 0x300000000;
  float v16 = (uint64_t *)&v45;
  uint64_t v17 = 21;
  uint64_t v50 = *((void *)a2 + 14);
  do
  {
    uint64_t v18 = *v16++;
    *((void *)a2 + v17) = v18;
    unint64_t v19 = HIDWORD(v15);
    BOOL v20 = (int)v15 < 2;
    if ((int)v15 < 2) {
      unint64_t v19 = 0;
    }
    unint64_t v21 = v17 + v19;
    uint64_t v22 = (v15 + 1);
    unint64_t v23 = v15 & 0xFFFFFFFF00000000;
    if (!v20) {
      uint64_t v22 = 0;
    }
    unint64_t v15 = v22 | v23;
    uint64_t v17 = v21 + 1;
  }
  while (v17 != 39);
  uint64_t v24 = (uint64_t)&v3[*(_DWORD *)(result + 12) + 3 - *(unsigned int *)(result + 12)];
  double v25 = *(double *)v24;
  double v26 = *(double *)(v24 + 8);
  double v27 = *(double *)(v24 + 16);
  double v28 = -*(double *)v24;
  *(void *)&long long v45 = 0;
  *((double *)&v45 + 1) = v27;
  double v46 = -v26;
  *(double *)&long long v47 = -v27;
  *((void *)&v47 + 1) = 0;
  double v48 = v25;
  *(double *)&long long v49 = v26;
  *((double *)&v49 + 1) = v28;
  uint64_t v50 = 0;
  unint64_t v29 = 0x300000000;
  float v30 = (uint64_t *)&v45;
  for (uint64_t i = 3; i != 21; uint64_t i = v35 + 1)
  {
    uint64_t v32 = *v30++;
    *((void *)a2 + i) = v32;
    unint64_t v33 = HIDWORD(v29);
    BOOL v34 = (int)v29 < 2;
    if ((int)v29 < 2) {
      unint64_t v33 = 0;
    }
    unint64_t v35 = i + v33;
    uint64_t v36 = (v29 + 1);
    unint64_t v37 = v29 & 0xFFFFFFFF00000000;
    if (!v34) {
      uint64_t v36 = 0;
    }
    unint64_t v29 = v36 | v37;
  }
  unint64_t v38 = 0x300000000;
  for (uint64_t j = 18; j != 36; uint64_t j = v42 + 1)
  {
    *((void *)a2 + j) = 0;
    unint64_t v40 = HIDWORD(v38);
    BOOL v41 = (int)v38 < 2;
    if ((int)v38 < 2) {
      unint64_t v40 = 0;
    }
    unint64_t v42 = j + v40;
    uint64_t v43 = (v38 + 1);
    unint64_t v44 = v38 & 0xFFFFFFFF00000000;
    if (!v41) {
      uint64_t v43 = 0;
    }
    unint64_t v38 = v43 | v44;
  }
  return result;
}

double cva::SE3AlgebraStorage<double,cva::MatrixRef<double const,6u,1u,false>>::hat@<D0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *a1;
  double v3 = *(double *)(*a1 + 16);
  *(double *)(a2 + 32) = -v3;
  double v5 = *(double *)v2;
  double v4 = *(double *)(v2 + 8);
  double v6 = -*(double *)v2;
  *(double *)(a2 + 64) = v4;
  *(double *)(a2 + 72) = v6;
  *(_OWORD *)(a2 + 96) = *(_OWORD *)(v2 + 24);
  *(void *)a2 = 0;
  *(void *)(a2 + 40) = 0;
  *(double *)(a2 + 8) = v3;
  *(double *)(a2 + 16) = -v4;
  *(double *)(a2 + 48) = v5;
  double result = *(double *)(v2 + 40);
  *(double *)(a2 + 112) = result;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 80) = 0;
  *(void *)(a2 + 88) = 0;
  *(void *)(a2 + 120) = 0;
  return result;
}

uint64_t cva::SE3AlgebraStorage<double,cva::MatrixRef<double const,6u,1u,false>>::exp@<X0>(float64x2_t **a1@<X0>, uint64_t a2@<X8>, double a3@<D0>)
{
  *(_OWORD *)(a2 + 64) = xmmword_2154460C0;
  *(_OWORD *)(a2 + 80) = unk_2154460D0;
  *(_OWORD *)(a2 + 96) = xmmword_2154460E0;
  *(_OWORD *)(a2 + 112) = unk_2154460F0;
  *(_OWORD *)a2 = xmmword_215446080;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)algn_215446090;
  *(_OWORD *)(a2 + 32) = xmmword_2154460A0;
  *(_OWORD *)(a2 + 48) = unk_2154460B0;
  float64x2_t v17 = 0u;
  float64x2_t v18 = 0u;
  long long v16 = 0u;
  double v4 = *a1;
  float64_t v5 = (*a1)->f64[1] * a3;
  *(double *)&long long v16 = (*a1)->f64[0] * a3;
  *((float64_t *)&v16 + 1) = v5;
  float64x2_t v6 = vmulq_n_f64(v4[1], a3);
  float64x2_t v7 = vmulq_n_f64(v4[2], a3);
  float64x2_t v17 = v6;
  float64x2_t v18 = v7;
  double v8 = *(double *)&v16 * *(double *)&v16 + v5 * v5 + vmulq_f64(v6, v6).f64[0];
  if (v8 >= 0.0000002635)
  {
    double v13 = sqrt(v8);
    __double2 v14 = __sincos_stret(v13);
    double cosval = v14.__cosval;
    double v11 = v14.__sinval / v13;
    double v9 = 1.0 / v8 * (1.0 - v14.__cosval);
    double v10 = 1.0 / v8 * (1.0 - v14.__sinval / v13);
  }
  else
  {
    double v9 = 0.5 - v8 * (v8 / -720.0 + 0.0416666667);
    double v10 = 0.166666667 - v8 * (v8 / -5040.0 + 0.00833333333);
    double v11 = 1.0 - v8 * v10;
    double cosval = 1.0 - v8 * v9;
  }
  void v19[2] = v9;
  v19[3] = v10;
  v19[0] = cosval;
  v19[1] = v11;
  return sub_2153DBF80((uint64_t)&v16, v19, (float64x2_t *)a2);
}

void cva::SE3AlgebraStorage<double,cva::MatrixRef<double const,6u,1u,false>>::expJacobian(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 64) = xmmword_2154460C0;
  *(_OWORD *)(a2 + 80) = unk_2154460D0;
  *(_OWORD *)(a2 + 96) = xmmword_2154460E0;
  *(_OWORD *)(a2 + 112) = unk_2154460F0;
  *(_OWORD *)a2 = xmmword_215446080;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)algn_215446090;
  *(_OWORD *)(a2 + 32) = xmmword_2154460A0;
  *(_OWORD *)(a2 + 48) = unk_2154460B0;
  uint64_t v3 = a2 + 128;
  *(_OWORD *)(a2 + 168) = 0u;
  *(_OWORD *)(a2 + 184) = 0u;
  *(_OWORD *)(a2 + 200) = 0u;
  *(_OWORD *)(a2 + 216) = 0u;
  *(_OWORD *)(a2 + 232) = 0u;
  *(_OWORD *)(a2 + 248) = 0u;
  *(void *)(a2 + 408) = 0;
  *(_OWORD *)(a2 + 264) = 0u;
  *(_OWORD *)(a2 + 280) = 0u;
  *(_OWORD *)(a2 + 296) = 0u;
  *(_OWORD *)(a2 + 312) = 0u;
  *(_OWORD *)(a2 + 328) = 0u;
  *(_OWORD *)(a2 + 344) = 0u;
  *(_OWORD *)(a2 + 360) = 0u;
  *(_OWORD *)(a2 + 376) = 0u;
  *(_OWORD *)(a2 + 152) = 0u;
  *(_OWORD *)(a2 + 392) = 0u;
  double v4 = *(double **)a1;
  uint64_t v5 = *(unsigned int *)(a1 + 12);
  uint64_t v6 = *(void *)a1 - 8 * v5;
  uint64_t v7 = (v5 + 3);
  double v8 = (double *)(v6 + 8 * v7);
  unint64_t v9 = *(unsigned int *)(a1 + 8) | (unint64_t)(v7 << 32);
  v82[0] = v8;
  v82[1] = v9;
  double v10 = *v4;
  double v11 = v4[1];
  double v12 = v10 * v10;
  double v13 = v11 * v11;
  double v14 = v4[2];
  double v15 = v14 * v14;
  double v16 = v10 * v10 + v11 * v11 + v14 * v14;
  if (v16 >= 0.0000002635)
  {
    double v24 = sqrt(v16);
    __double2 v25 = __sincos_stret(v24);
    double cosval = v25.__cosval;
    double v12 = v10 * v10;
    double v15 = v14 * v14;
    double v19 = v25.__sinval / v24;
    double v17 = 1.0 / v16 * (1.0 - v25.__cosval);
    double v18 = 1.0 / v16 * (1.0 - v19);
    double v21 = v18 - v17;
    double v22 = 1.0 / v16 * (v19 + v17 * -2.0);
    double v23 = 1.0 / v16 * (v17 + v18 * -3.0);
  }
  else
  {
    double v17 = 0.5 - v16 * (v16 / -720.0 + 0.0416666667);
    double v18 = 0.166666667 - v16 * (v16 / -5040.0 + 0.00833333333);
    double v19 = 1.0 - v16 * v18;
    double cosval = 1.0 - v16 * v17;
    double v21 = v16 * (v16 * -0.00119047619 + 0.0333333333) + -0.333333333;
    double v22 = v16 * (v16 * -0.000148809524 + 0.00555555556) + -0.0833333333;
    double v23 = v16 * (v16 * -0.0000165343915 + 0.000793650794) + -0.0166666667;
  }
  double v26 = cosval + v10 * v17 * v10;
  double v27 = cosval + v11 * v17 * v11;
  *(double *)(a2 + 80) = cosval + v14 * v17 * v14;
  double v28 = v10 * v17 * v11;
  double v29 = v10 * v17 * v14;
  double v30 = v11 * v17 * v14;
  *(double *)(a2 + 32) = v28 - v19 * v14;
  *(double *)(a2 + 40) = v27;
  *(double *)a2 = v26;
  *(double *)(a2 + 8) = v28 + v19 * v14;
  *(double *)(a2 + 64) = v19 * v11 + v29;
  *(double *)(a2 + 72) = v30 - v19 * v10;
  *(double *)(a2 + 16) = v29 - v19 * v11;
  *(double *)(a2 + 48) = v30 + v19 * v10;
  v81[0] = v3;
  v81[1] = 6;
  double v31 = v19 + v18 * v10 * v10;
  double v32 = v19 + v18 * v11 * v11;
  double v33 = v19 + v18 * v14 * v14;
  double v34 = v18 * v10 * v11;
  double v35 = v18 * v10 * v14;
  double v36 = v18 * v11 * v14;
  double v37 = v34 - v14 * v17;
  *(double *)(a2 + 176) = v37;
  *(double *)(a2 + 184) = v32;
  double v38 = v11 * v17 + v35;
  double v39 = v34 + v14 * v17;
  *(double *)(a2 + 128) = v31;
  *(double *)(a2 + 136) = v39;
  double v40 = v36 - v10 * v17;
  *(double *)(a2 + 224) = v38;
  *(double *)(a2 + 232) = v40;
  *(double *)(a2 + 240) = v33;
  double v41 = v35 - v11 * v17;
  *(double *)(a2 + 144) = v41;
  double v42 = v36 + v10 * v17;
  *(double *)(a2 + 192) = v42;
  v80[0] = v81;
  v80[1] = v82;
  if (v6 == a2)
  {
    long long v83 = 0uLL;
    uint64_t v84 = 0;
    double v79 = v22;
    double v49 = v15;
    double v50 = v12;
    double v78 = v23;
    sub_2153DFC78((double *)&v83, v80);
    double v23 = v78;
    double v22 = v79;
    double v12 = v50;
    double v15 = v49;
    double v13 = v11 * v11;
    *(_OWORD *)(a2 + 96) = v83;
    *(void *)(a2 + 112) = v84;
    double v43 = *v8;
    double v44 = v8[1];
    double v46 = v8[2];
  }
  else
  {
    double v43 = *v8;
    double v44 = v8[1];
    double v45 = v31 * *v8 + 0.0 + v37 * v44;
    double v46 = v8[2];
    double v47 = v45 + v38 * v46;
    double v48 = v39 * *v8 + 0.0;
    *(double *)(a2 + 96) = v47;
    *(double *)(a2 + 104) = v48 + v32 * v44 + v40 * v46;
    *(double *)(a2 + 112) = v41 * v43 + 0.0 + v42 * v44 + v33 * v46;
  }
  double v51 = v10 * v43 + v11 * v44 + v14 * v46;
  double v52 = (v21 + v23 * v12) * v51 + (v18 + v18) * (v10 * v43);
  double v53 = (v21 + v23 * v13) * v51 + (v18 + v18) * (v11 * v44);
  *(double *)(a2 + 264) = (v21 + v23 * v15) * v51 + (v18 + v18) * (v14 * v46);
  double v54 = v23 * v51 * v10;
  double v55 = v11 * v54 + v18 * (v44 * v10 + v43 * v11);
  double v56 = v54 * v14 + v18 * (v10 * v46 + v43 * v14);
  double v57 = v23 * v51 * v11 * v14 + v18 * (v11 * v46 + v44 * v14);
  double v58 = v22 * v51;
  double v59 = v58 * v14 + v17 * v46;
  double v60 = v58 * v11 + v17 * v44;
  double v61 = v58 * v10 + v17 * v43;
  *(double *)(a2 + 200) = v55 - v59;
  *(double *)(a2 + 208) = v53;
  *(double *)(a2 + 152) = v52;
  *(double *)(a2 + 160) = v55 + v59;
  *(double *)(a2 + 168) = v56 - v60;
  *(double *)(a2 + 248) = v60 + v56;
  *(double *)(a2 + 256) = v57 - v61;
  *(double *)(a2 + 216) = v61 + v57;
  unint64_t v62 = 0x300000000;
  for (uint64_t i = 18; i != 36; uint64_t i = v66 + 1)
  {
    *(void *)(v3 + 8 * i) = 0;
    unint64_t v64 = HIDWORD(v62);
    BOOL v65 = (int)v62 < 2;
    if ((int)v62 < 2) {
      unint64_t v64 = 0;
    }
    unint64_t v66 = i + v64;
    uint64_t v67 = (v62 + 1);
    unint64_t v68 = v62 & 0xFFFFFFFF00000000;
    if (!v65) {
      uint64_t v67 = 0;
    }
    unint64_t v62 = v67 | v68;
  }
  long long v83 = *(_OWORD *)(a2 + 128);
  uint64_t v84 = *(void *)(a2 + 144);
  long long v85 = *(_OWORD *)(a2 + 176);
  uint64_t v86 = *(void *)(a2 + 192);
  long long v87 = *(_OWORD *)(a2 + 224);
  unint64_t v69 = 0x300000000;
  long long v70 = (uint64_t *)&v83;
  uint64_t v71 = 21;
  uint64_t v88 = *(void *)(a2 + 240);
  do
  {
    uint64_t v72 = *v70++;
    *(void *)(v3 + 8 * v71) = v72;
    unint64_t v73 = HIDWORD(v69);
    BOOL v74 = (int)v69 < 2;
    if ((int)v69 < 2) {
      unint64_t v73 = 0;
    }
    unint64_t v75 = v71 + v73;
    uint64_t v76 = (v69 + 1);
    unint64_t v77 = v69 & 0xFFFFFFFF00000000;
    if (!v74) {
      uint64_t v76 = 0;
    }
    unint64_t v69 = v76 | v77;
    uint64_t v71 = v75 + 1;
  }
  while (v71 != 39);
}

uint64_t cva::SE3AlgebraStorage<double,cva::MatrixRef<double const,6u,1u,false>>::serialize()
{
  return std::ostream::write();
}

double cva::SO2GroupStorage<float,cva::Matrix<float,2u,2u,false>>::SO2GroupStorage(_OWORD *a1)
{
  *(void *)&double result = 1065353216;
  *a1 = xmmword_215445EC0;
  return result;
}

{
  double result;

  *(void *)&double result = 1065353216;
  *a1 = xmmword_215445EC0;
  return result;
}

float *cva::SO2GroupStorage<float,cva::Matrix<float,2u,2u,false>>::SO2GroupStorage(float *a1, float a2)
{
  __float2 v3 = __sincosf_stret(a2);
  *a1 = v3.__cosval;
  a1[1] = v3.__sinval;
  a1[2] = -v3.__sinval;
  a1[3] = v3.__cosval;
  return a1;
}

{
  __float2 v3;

  __float2 v3 = __sincosf_stret(a2);
  *a1 = v3.__cosval;
  a1[1] = v3.__sinval;
  a1[2] = -v3.__sinval;
  a1[3] = v3.__cosval;
  return a1;
}

double cva::SO2GroupStorage<float,cva::Matrix<float,2u,2u,false>>::lplus(float *a1, float *a2)
{
  __float2 v3 = __sincosf_stret(*a2);
  v5[0] = LODWORD(v3.__cosval);
  v5[1] = LODWORD(v3.__sinval);
  *(float *)&void v5[2] = -v3.__sinval;
  v5[3] = LODWORD(v3.__cosval);
  v6[0] = (float *)v5;
  v6[1] = a1;
  long long v7 = 0uLL;
  sub_2153E13E4((uint64_t)&v7, v6);
  double result = *(double *)&v7;
  *(_OWORD *)a1 = v7;
  return result;
}

double sub_2153E13E4(uint64_t a1, float **a2)
{
  __float2 v3 = *a2;
  if (*a2 == (float *)a1 || (double v4 = a2[1], v4 == (float *)a1))
  {
    long long v6 = 0uLL;
    sub_2153E13E4(&v6);
    double result = *(double *)&v6;
    *(_OWORD *)a1 = v6;
  }
  else
  {
    *(float *)a1 = (float)((float)(*v3 * *v4) + 0.0) + (float)(v3[2] * v4[1]);
    *(float *)(a1 + 4) = (float)((float)(v3[1] * *v4) + 0.0) + (float)(v3[3] * v4[1]);
    *(float *)(a1 + 8) = (float)((float)(*v3 * v4[2]) + 0.0) + (float)(v3[2] * v4[3]);
    *(float *)&double result = (float)((float)(v3[1] * v4[2]) + 0.0) + (float)(v3[3] * v4[3]);
    *(_DWORD *)(a1 + 12) = LODWORD(result);
  }
  return result;
}

double cva::SO2AlgebraStorage<float,cva::MatrixRef<float const,1u,1u,false>>::SO2AlgebraStorage(void *a1, uint64_t a2)
{
  *a1 = a2;
  *(void *)&double result = 1;
  a1[1] = 1;
  return result;
}

{
  double result;

  *a1 = a2;
  *(void *)&double result = 1;
  a1[1] = 1;
  return result;
}

{
  double result;

  *a1 = a2;
  *(void *)&double result = 1;
  a1[1] = 1;
  return result;
}

{
  double result;

  *a1 = a2;
  *(void *)&double result = 1;
  a1[1] = 1;
  return result;
}

float cva::SO2AlgebraStorage<float,cva::MatrixRef<float const,1u,1u,false>>::exp@<S0>(float **a1@<X0>, float *a2@<X8>)
{
  __float2 v3 = __sincosf_stret(**a1);
  *a2 = v3.__cosval;
  a2[1] = v3.__sinval;
  float result = -v3.__sinval;
  a2[2] = -v3.__sinval;
  a2[3] = v3.__cosval;
  return result;
}

double cva::SO2GroupStorage<float,cva::Matrix<float,2u,2u,false>>::rplus(float *a1, float *a2)
{
  __float2 v3 = __sincosf_stret(*a2);
  v5[0] = LODWORD(v3.__cosval);
  v5[1] = LODWORD(v3.__sinval);
  *(float *)&void v5[2] = -v3.__sinval;
  v5[3] = LODWORD(v3.__cosval);
  v6[0] = a1;
  v6[1] = (float *)v5;
  long long v7 = 0uLL;
  sub_2153E13E4((uint64_t)&v7, v6);
  double result = *(double *)&v7;
  *(_OWORD *)a1 = v7;
  return result;
}

float *cva::SO2GroupStorage<float,cva::Matrix<float,2u,2u,false>>::transform@<X0>(float *a1@<X0>, float *a2@<X1>, float *a3@<X8>)
{
  v4[0] = a1;
  v4[1] = a2;
  *(void *)a3 = 0;
  return sub_2153E1578(a3, v4);
}

float *sub_2153E1578(float *result, float **a2)
{
  uint64_t v2 = result;
  __float2 v3 = *a2;
  if (*a2 == result || (double v4 = a2[1], v4 == result))
  {
    uint64_t v5 = 0;
    double result = (float *)sub_2153E1578(&v5);
    *(void *)uint64_t v2 = v5;
  }
  else
  {
    *double result = (float)((float)(*v3 * *v4) + 0.0) + (float)(v3[2] * v4[1]);
    result[1] = (float)((float)(v3[1] * *v4) + 0.0) + (float)(v3[3] * v4[1]);
  }
  return result;
}

float *cva::SO2GroupStorage<float,cva::Matrix<float,2u,2u,false>>::inverseTransform@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, float *a3@<X8>)
{
  uint64_t v4 = a1;
  v5[0] = &v4;
  v5[1] = a2;
  *(void *)a3 = 0;
  return sub_2153E163C(a3, (uint64_t)v5);
}

float *sub_2153E163C(float *result, uint64_t a2)
{
  uint64_t v2 = result;
  __float2 v3 = *(float **)(a2 + 8);
  if (v3 == result)
  {
    uint64_t v5 = 0;
    double result = (float *)sub_2153E163C(&v5);
    *(void *)uint64_t v2 = v5;
  }
  else
  {
    uint64_t v4 = **(float ***)a2;
    *double result = (float)((float)(v4[1] * v3[1]) + (float)(*v4 * *v3)) + 0.0;
    result[1] = (float)((float)(v4[3] * v3[1]) + (float)(v4[2] * *v3)) + 0.0;
  }
  return result;
}

float cva::SO2GroupStorage<float,cva::Matrix<float,2u,2u,false>>::transformJacobian@<S0>(float *a1@<X1>, uint64_t a2@<X8>)
{
  int v2 = *(_DWORD *)a1;
  float result = -a1[1];
  *(float *)a2 = result;
  *(_DWORD *)(a2 + 4) = v2;
  return result;
}

float *cva::SO2GroupStorage<float,cva::Matrix<float,2u,2u,false>>::inverseTransformJacobian@<X0>(uint64_t a1@<X0>, float *a2@<X1>, float *a3@<X8>)
{
  float v3 = -*a2;
  *a3 = a2[1];
  a3[1] = v3;
  uint64_t v5 = a1;
  v6[0] = &v5;
  v6[1] = a3;
  return sub_2153E163C(a3, (uint64_t)v6);
}

void cva::SO2GroupStorage<float,cva::Matrix<float,2u,2u,false>>::log(float *a1@<X0>, float *a2@<X8>)
{
  float v3 = atan2f(a1[1], *a1);
  *a2 = v3;
  if (v3 <= 0.0)
  {
    if (v3 > -3.1416) {
      return;
    }
    do
      float v3 = v3 + 3.1416;
    while (v3 <= -3.1416);
  }
  else
  {
    if (v3 < 3.1416) {
      return;
    }
    do
      float v3 = v3 + -3.1416;
    while (v3 >= 3.1416);
  }
  *a2 = v3;
}

_DWORD *cva::SO2AlgebraStorage<float,cva::Matrix<float,1u,1u,false>>::SO2AlgebraStorage(_DWORD *result)
{
  *float result = 0;
  return result;
}

{
  *float result = 0;
  return result;
}

void cva::SO2GroupStorage<float,cva::Matrix<float,2u,2u,false>>::logJacobian(float *a1@<X0>, uint64_t a2@<X8>)
{
  float v3 = atan2f(a1[1], *a1);
  *(float *)a2 = v3;
  if (v3 <= 0.0)
  {
    if (v3 <= -3.1416)
    {
      do
        float v3 = v3 + 3.1416;
      while (v3 <= -3.1416);
      goto LABEL_7;
    }
  }
  else if (v3 >= 3.1416)
  {
    do
      float v3 = v3 + -3.1416;
    while (v3 >= 3.1416);
LABEL_7:
    *(float *)a2 = v3;
  }
  *(_DWORD *)(a2 + 4) = 1065353216;
}

float32x2x2_t *cva::SO2GroupStorage<float,cva::Matrix<float,2u,2u,false>>::inverse@<X0>(float32x2x2_t *result@<X0>, float *a2@<X8>)
{
  float32x2x2_t v2 = *result;
  unint64_t v3 = vextq_s8((int8x16_t)v2, (int8x16_t)v2, 8uLL).u64[0];
  vst2_f32(a2, v2);
  return result;
}

void cva::SO2GroupStorage<float,cva::Matrix<float,2u,2u,false>>::adjoint(_DWORD *a1@<X8>)
{
  *a1 = 1065353216;
}

void cva::SO2GroupStorage<float,cva::Matrix<float,2u,2u,false>>::enforce(float *a1)
{
  float v2 = atan2f(a1[1], *a1);
  if (v2 <= 0.0)
  {
    for (; v2 <= -3.1416; float v2 = v2 + 3.1416)
      ;
  }
  else
  {
    for (; v2 >= 3.1416; float v2 = v2 + -3.1416)
      ;
  }
  __float2 v3 = __sincosf_stret(v2);
  *a1 = v3.__cosval;
  a1[1] = v3.__sinval;
  a1[2] = -v3.__sinval;
  a1[3] = v3.__cosval;
}

float cva::SO2AlgebraStorage<float,cva::Matrix<float,1u,1u,false>>::exp@<S0>(float *a1@<X0>, float *a2@<X8>)
{
  __float2 v3 = __sincosf_stret(*a1);
  *a2 = v3.__cosval;
  a2[1] = v3.__sinval;
  float result = -v3.__sinval;
  a2[2] = -v3.__sinval;
  a2[3] = v3.__cosval;
  return result;
}

uint64_t cva::SO2GroupStorage<float,cva::Matrix<float,2u,2u,false>>::serialize()
{
  return std::ostream::write();
}

uint64_t cva::SO2GroupStorage<float,cva::Matrix<float,2u,2u,false>>::deserialize(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x270F98678](a2, a1, 16);
}

void *cva::SO2GroupStorage<double,cva::Matrix<double,2u,2u,false>>::SO2GroupStorage(void *result)
{
  *float result = 0x3FF0000000000000;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0x3FF0000000000000;
  return result;
}

{
  *float result = 0x3FF0000000000000;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0x3FF0000000000000;
  return result;
}

double *cva::SO2GroupStorage<double,cva::Matrix<double,2u,2u,false>>::SO2GroupStorage(double *a1, double a2)
{
  __double2 v3 = __sincos_stret(a2);
  *a1 = v3.__cosval;
  a1[1] = v3.__sinval;
  a1[2] = -v3.__sinval;
  a1[3] = v3.__cosval;
  return a1;
}

{
  __double2 v3;

  __double2 v3 = __sincos_stret(a2);
  *a1 = v3.__cosval;
  a1[1] = v3.__sinval;
  a1[2] = -v3.__sinval;
  a1[3] = v3.__cosval;
  return a1;
}

double cva::SO2GroupStorage<double,cva::Matrix<double,2u,2u,false>>::lplus(uint64_t a1, double *a2)
{
  __double2 v3 = __sincos_stret(*a2);
  v6[0] = *(void *)&v3.__cosval;
  v6[1] = *(void *)&v3.__sinval;
  *(double *)&void v6[2] = -v3.__sinval;
  v6[3] = *(void *)&v3.__cosval;
  v7[0] = (double *)v6;
  v7[1] = (double *)a1;
  long long v8 = 0u;
  long long v9 = 0u;
  sub_2153E1A90((uint64_t)&v8, v7);
  double result = *(double *)&v8;
  long long v5 = v9;
  *(_OWORD *)a1 = v8;
  *(_OWORD *)(a1 + 16) = v5;
  return result;
}

double sub_2153E1A90(uint64_t a1, double **a2)
{
  __double2 v3 = *a2;
  if (*a2 == (double *)a1 || (uint64_t v4 = a2[1], v4 == (double *)a1))
  {
    long long v7 = 0u;
    long long v8 = 0u;
    sub_2153E1A90(&v7);
    double result = *(double *)&v7;
    long long v6 = v8;
    *(_OWORD *)a1 = v7;
    *(_OWORD *)(a1 + 16) = v6;
  }
  else
  {
    *(double *)a1 = *v3 * *v4 + 0.0 + v3[2] * v4[1];
    *(double *)(a1 + 8) = v3[1] * *v4 + 0.0 + v3[3] * v4[1];
    *(double *)(a1 + 16) = *v3 * v4[2] + 0.0 + v3[2] * v4[3];
    double result = v3[1] * v4[2] + 0.0 + v3[3] * v4[3];
    *(double *)(a1 + 24) = result;
  }
  return result;
}

double cva::SO2AlgebraStorage<double,cva::MatrixRef<double const,1u,1u,false>>::SO2AlgebraStorage(void *a1, uint64_t a2)
{
  *a1 = a2;
  *(void *)&double result = 1;
  a1[1] = 1;
  return result;
}

{
  double result;

  *a1 = a2;
  *(void *)&double result = 1;
  a1[1] = 1;
  return result;
}

{
  double result;

  *a1 = a2;
  *(void *)&double result = 1;
  a1[1] = 1;
  return result;
}

{
  double result;

  *a1 = a2;
  *(void *)&double result = 1;
  a1[1] = 1;
  return result;
}

double cva::SO2AlgebraStorage<double,cva::MatrixRef<double const,1u,1u,false>>::exp@<D0>(double **a1@<X0>, double *a2@<X8>)
{
  __double2 v3 = __sincos_stret(**a1);
  *a2 = v3.__cosval;
  a2[1] = v3.__sinval;
  double result = -v3.__sinval;
  a2[2] = -v3.__sinval;
  a2[3] = v3.__cosval;
  return result;
}

double cva::SO2GroupStorage<double,cva::Matrix<double,2u,2u,false>>::rplus(uint64_t a1, double *a2)
{
  __double2 v3 = __sincos_stret(*a2);
  v6[0] = *(void *)&v3.__cosval;
  v6[1] = *(void *)&v3.__sinval;
  *(double *)&void v6[2] = -v3.__sinval;
  v6[3] = *(void *)&v3.__cosval;
  v7[0] = (double *)a1;
  v7[1] = (double *)v6;
  long long v8 = 0u;
  long long v9 = 0u;
  sub_2153E1A90((uint64_t)&v8, v7);
  double result = *(double *)&v8;
  long long v5 = v9;
  *(_OWORD *)a1 = v8;
  *(_OWORD *)(a1 + 16) = v5;
  return result;
}

double cva::SO2GroupStorage<double,cva::Matrix<double,2u,2u,false>>::transform@<D0>(double *a1@<X0>, double *a2@<X1>, uint64_t a3@<X8>)
{
  v4[0] = a1;
  v4[1] = a2;
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  return sub_2153E1C2C((double *)a3, v4);
}

double sub_2153E1C2C(double *a1, double **a2)
{
  __double2 v3 = *a2;
  if (*a2 == a1 || (uint64_t v4 = a2[1], v4 == a1))
  {
    long long v6 = 0uLL;
    sub_2153E1C2C(&v6);
    double result = *(double *)&v6;
    *(_OWORD *)a1 = v6;
  }
  else
  {
    *a1 = *v3 * *v4 + 0.0 + v3[2] * v4[1];
    double result = v3[1] * *v4 + 0.0 + v3[3] * v4[1];
    a1[1] = result;
  }
  return result;
}

double cva::SO2GroupStorage<double,cva::Matrix<double,2u,2u,false>>::inverseTransform@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = a1;
  v5[0] = &v4;
  v5[1] = a2;
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  return sub_2153E1CF0((double *)a3, (uint64_t)v5);
}

double sub_2153E1CF0(double *a1, uint64_t a2)
{
  __double2 v3 = *(double **)(a2 + 8);
  if (v3 == a1)
  {
    long long v6 = 0uLL;
    sub_2153E1CF0(&v6);
    double result = *(double *)&v6;
    *(_OWORD *)a1 = v6;
  }
  else
  {
    uint64_t v4 = **(double ***)a2;
    *a1 = v4[1] * v3[1] + *v4 * *v3 + 0.0;
    double result = v4[3] * v3[1] + v4[2] * *v3 + 0.0;
    a1[1] = result;
  }
  return result;
}

double cva::SO2GroupStorage<double,cva::Matrix<double,2u,2u,false>>::transformJacobian@<D0>(double *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2 = *(void *)a1;
  double result = -a1[1];
  *(double *)a2 = result;
  *(void *)(a2 + 8) = v2;
  return result;
}

double cva::SO2GroupStorage<double,cva::Matrix<double,2u,2u,false>>::inverseTransformJacobian@<D0>(uint64_t a1@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  double v3 = -*a2;
  *a3 = a2[1];
  a3[1] = v3;
  uint64_t v5 = a1;
  v6[0] = &v5;
  v6[1] = a3;
  return sub_2153E1CF0(a3, (uint64_t)v6);
}

void cva::SO2GroupStorage<double,cva::Matrix<double,2u,2u,false>>::log(long double *a1@<X0>, double *a2@<X8>)
{
  double v3 = atan2(a1[1], *a1);
  *a2 = v3;
  if (v3 <= 0.0)
  {
    if (v3 > -3.14159265) {
      return;
    }
    do
      double v3 = v3 + 3.14159265;
    while (v3 <= -3.14159265);
  }
  else
  {
    if (v3 < 3.14159265) {
      return;
    }
    do
      double v3 = v3 + -3.14159265;
    while (v3 >= 3.14159265);
  }
  *a2 = v3;
}

void *cva::SO2AlgebraStorage<double,cva::Matrix<double,1u,1u,false>>::SO2AlgebraStorage(void *result)
{
  *double result = 0;
  return result;
}

{
  *double result = 0;
  return result;
}

void cva::SO2GroupStorage<double,cva::Matrix<double,2u,2u,false>>::logJacobian(long double *a1@<X0>, uint64_t a2@<X8>)
{
  double v3 = atan2(a1[1], *a1);
  *(double *)a2 = v3;
  if (v3 <= 0.0)
  {
    if (v3 <= -3.14159265)
    {
      do
        double v3 = v3 + 3.14159265;
      while (v3 <= -3.14159265);
      goto LABEL_7;
    }
  }
  else if (v3 >= 3.14159265)
  {
    do
      double v3 = v3 + -3.14159265;
    while (v3 >= 3.14159265);
LABEL_7:
    *(double *)a2 = v3;
  }
  *(void *)(a2 + 8) = 0x3FF0000000000000;
}

int8x16_t cva::SO2GroupStorage<double,cva::Matrix<double,2u,2u,false>>::inverse@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *(void *)(a1 + 24);
  *(void *)a2 = *(void *)a1;
  int8x16_t result = vextq_s8(*(int8x16_t *)(a1 + 8), *(int8x16_t *)(a1 + 8), 8uLL);
  *(int8x16_t *)(a2 + 8) = result;
  *(void *)(a2 + 24) = v2;
  return result;
}

void cva::SO2GroupStorage<double,cva::Matrix<double,2u,2u,false>>::adjoint(void *a1@<X8>)
{
  *a1 = 0x3FF0000000000000;
}

void cva::SO2GroupStorage<double,cva::Matrix<double,2u,2u,false>>::enforce(uint64_t a1)
{
  double v2 = atan2(*(long double *)(a1 + 8), *(long double *)a1);
  if (v2 <= 0.0)
  {
    for (; v2 <= -3.14159265; double v2 = v2 + 3.14159265)
      ;
  }
  else
  {
    for (; v2 >= 3.14159265; double v2 = v2 + -3.14159265)
      ;
  }
  __double2 v3 = __sincos_stret(v2);
  *(double *)a1 = v3.__cosval;
  *(double *)(a1 + 8) = v3.__sinval;
  *(double *)(a1 + 16) = -v3.__sinval;
  *(double *)(a1 + 24) = v3.__cosval;
}

double cva::SO2AlgebraStorage<double,cva::Matrix<double,1u,1u,false>>::exp@<D0>(double *a1@<X0>, double *a2@<X8>)
{
  __double2 v3 = __sincos_stret(*a1);
  *a2 = v3.__cosval;
  a2[1] = v3.__sinval;
  double result = -v3.__sinval;
  a2[2] = -v3.__sinval;
  a2[3] = v3.__cosval;
  return result;
}

uint64_t cva::SO2GroupStorage<double,cva::Matrix<double,2u,2u,false>>::serialize()
{
  return std::ostream::write();
}

uint64_t cva::SO2GroupStorage<double,cva::Matrix<double,2u,2u,false>>::deserialize(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x270F98678](a2, a1, 32);
}

double cva::SO2GroupStorage<float,cva::MatrixRef<float const,2u,2u,false>>::SO2GroupStorage(void *a1, uint64_t a2)
{
  *a1 = a2;
  *(void *)&double result = 2;
  a1[1] = 2;
  return result;
}

{
  double result;

  *a1 = a2;
  *(void *)&double result = 2;
  a1[1] = 2;
  return result;
}

{
  double result;

  *a1 = a2;
  *(void *)&double result = 2;
  a1[1] = 2;
  return result;
}

{
  double result;

  *a1 = a2;
  *(void *)&double result = 2;
  a1[1] = 2;
  return result;
}

float *cva::SO2GroupStorage<float,cva::MatrixRef<float const,2u,2u,false>>::transform@<X0>(float *a1@<X0>, float *a2@<X1>, float *a3@<X8>)
{
  v4[0] = a1;
  v4[1] = a2;
  *(void *)a3 = 0;
  return sub_2153D398C(a3, v4);
}

float *cva::SO2GroupStorage<float,cva::MatrixRef<float const,2u,2u,false>>::inverseTransform@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, float *a3@<X8>)
{
  uint64_t v4 = a1;
  v5[0] = &v4;
  v5[1] = a2;
  *(void *)a3 = 0;
  return sub_2153D3AFC(a3, v5);
}

float cva::SO2GroupStorage<float,cva::MatrixRef<float const,2u,2u,false>>::transformJacobian@<S0>(float *a1@<X1>, uint64_t a2@<X8>)
{
  int v2 = *(_DWORD *)a1;
  float result = -a1[1];
  *(float *)a2 = result;
  *(_DWORD *)(a2 + 4) = v2;
  return result;
}

float *cva::SO2GroupStorage<float,cva::MatrixRef<float const,2u,2u,false>>::inverseTransformJacobian@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  float v3 = -*(float *)a2;
  *(_DWORD *)a3 = *(_DWORD *)(a2 + 4);
  *(float *)(a3 + 4) = v3;
  uint64_t v5 = a1;
  v6[0] = &v5;
  v6[1] = (uint64_t *)a3;
  return sub_2153D3AFC((float *)a3, v6);
}

void cva::SO2GroupStorage<float,cva::MatrixRef<float const,2u,2u,false>>::log(float **a1@<X0>, float *a2@<X8>)
{
  float v3 = atan2f((*a1)[1], **a1);
  *a2 = v3;
  if (v3 <= 0.0)
  {
    if (v3 > -3.1416) {
      return;
    }
    do
      float v3 = v3 + 3.1416;
    while (v3 <= -3.1416);
  }
  else
  {
    if (v3 < 3.1416) {
      return;
    }
    do
      float v3 = v3 + -3.1416;
    while (v3 >= 3.1416);
  }
  *a2 = v3;
}

void cva::SO2GroupStorage<float,cva::MatrixRef<float const,2u,2u,false>>::logJacobian(float **a1@<X0>, uint64_t a2@<X8>)
{
  float v3 = atan2f((*a1)[1], **a1);
  *(float *)a2 = v3;
  if (v3 <= 0.0)
  {
    if (v3 <= -3.1416)
    {
      do
        float v3 = v3 + 3.1416;
      while (v3 <= -3.1416);
      goto LABEL_7;
    }
  }
  else if (v3 >= 3.1416)
  {
    do
      float v3 = v3 + -3.1416;
    while (v3 >= 3.1416);
LABEL_7:
    *(float *)a2 = v3;
  }
  *(_DWORD *)(a2 + 4) = 1065353216;
}

float cva::SO2GroupStorage<float,cva::MatrixRef<float const,2u,2u,false>>::inverse@<S0>(unsigned int *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = a1[2];
  float result = *(float *)(*(void *)a1 + 4 * v2);
  int v4 = *(_DWORD *)(*(void *)a1 + 4);
  int v5 = *(_DWORD *)(*(void *)a1 + 4 * (v2 + 1));
  *(_DWORD *)a2 = **(_DWORD **)a1;
  *(float *)(a2 + 4) = result;
  *(_DWORD *)(a2 + 8) = v4;
  *(_DWORD *)(a2 + 12) = v5;
  return result;
}

void cva::SO2GroupStorage<float,cva::MatrixRef<float const,2u,2u,false>>::adjoint(_DWORD *a1@<X8>)
{
  *a1 = 1065353216;
}

uint64_t cva::SO2GroupStorage<float,cva::MatrixRef<float const,2u,2u,false>>::serialize(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 8);
  if (2 * v1)
  {
    uint64_t v2 = *(void *)result;
    uint64_t v3 = *(void *)result + 4 * (2 * v1);
    unint64_t v4 = (unint64_t)(v1 - 2) << 32;
    do
    {
      float result = std::ostream::write();
      unint64_t v5 = HIDWORD(v4);
      if ((int)v4 < 1) {
        unint64_t v5 = 0;
      }
      uint64_t v6 = v2 + 4 * v5;
      uint64_t v7 = (v4 + 1);
      if ((int)v4 >= 1) {
        uint64_t v7 = 0;
      }
      unint64_t v4 = v7 | v4 & 0xFFFFFFFF00000000;
      uint64_t v2 = v6 + 4;
    }
    while (v6 + 4 != v3);
  }
  return result;
}

double cva::SO2GroupStorage<double,cva::MatrixRef<double const,2u,2u,false>>::SO2GroupStorage(void *a1, uint64_t a2)
{
  *a1 = a2;
  *(void *)&double result = 2;
  a1[1] = 2;
  return result;
}

{
  double result;

  *a1 = a2;
  *(void *)&double result = 2;
  a1[1] = 2;
  return result;
}

{
  double result;

  *a1 = a2;
  *(void *)&double result = 2;
  a1[1] = 2;
  return result;
}

{
  double result;

  *a1 = a2;
  *(void *)&double result = 2;
  a1[1] = 2;
  return result;
}

double *cva::SO2GroupStorage<double,cva::MatrixRef<double const,2u,2u,false>>::transform@<X0>(double *a1@<X0>, double *a2@<X1>, uint64_t a3@<X8>)
{
  v4[0] = a1;
  v4[1] = a2;
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  return sub_2153D4ABC((double *)a3, v4);
}

double cva::SO2GroupStorage<double,cva::MatrixRef<double const,2u,2u,false>>::inverseTransform@<D0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = a1;
  v5[0] = &v4;
  v5[1] = a2;
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  return sub_2153D4C54((double *)a3, v5);
}

double cva::SO2GroupStorage<double,cva::MatrixRef<double const,2u,2u,false>>::transformJacobian@<D0>(double *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2 = *(void *)a1;
  double result = -a1[1];
  *(double *)a2 = result;
  *(void *)(a2 + 8) = v2;
  return result;
}

double cva::SO2GroupStorage<double,cva::MatrixRef<double const,2u,2u,false>>::inverseTransformJacobian@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  double v3 = -*(double *)a2;
  *(void *)a3 = *(void *)(a2 + 8);
  *(double *)(a3 + 8) = v3;
  uint64_t v5 = a1;
  v6[0] = &v5;
  v6[1] = (uint64_t *)a3;
  return sub_2153D4C54((double *)a3, v6);
}

void cva::SO2GroupStorage<double,cva::MatrixRef<double const,2u,2u,false>>::log(long double **a1@<X0>, double *a2@<X8>)
{
  double v3 = atan2((*a1)[1], **a1);
  *a2 = v3;
  if (v3 <= 0.0)
  {
    if (v3 > -3.14159265) {
      return;
    }
    do
      double v3 = v3 + 3.14159265;
    while (v3 <= -3.14159265);
  }
  else
  {
    if (v3 < 3.14159265) {
      return;
    }
    do
      double v3 = v3 + -3.14159265;
    while (v3 >= 3.14159265);
  }
  *a2 = v3;
}

void cva::SO2GroupStorage<double,cva::MatrixRef<double const,2u,2u,false>>::logJacobian(long double **a1@<X0>, uint64_t a2@<X8>)
{
  double v3 = atan2((*a1)[1], **a1);
  *(double *)a2 = v3;
  if (v3 <= 0.0)
  {
    if (v3 <= -3.14159265)
    {
      do
        double v3 = v3 + 3.14159265;
      while (v3 <= -3.14159265);
      goto LABEL_7;
    }
  }
  else if (v3 >= 3.14159265)
  {
    do
      double v3 = v3 + -3.14159265;
    while (v3 >= 3.14159265);
LABEL_7:
    *(double *)a2 = v3;
  }
  *(void *)(a2 + 8) = 0x3FF0000000000000;
}

double cva::SO2GroupStorage<double,cva::MatrixRef<double const,2u,2u,false>>::inverse@<D0>(unsigned int *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = a1[2];
  double result = *(double *)(*(void *)a1 + 8 * v2);
  uint64_t v4 = *(void *)(*(void *)a1 + 8);
  uint64_t v5 = *(void *)(*(void *)a1 + 8 * (v2 + 1));
  *(void *)a2 = **(void **)a1;
  *(double *)(a2 + 8) = result;
  *(void *)(a2 + 16) = v4;
  *(void *)(a2 + 24) = v5;
  return result;
}

void cva::SO2GroupStorage<double,cva::MatrixRef<double const,2u,2u,false>>::adjoint(void *a1@<X8>)
{
  *a1 = 0x3FF0000000000000;
}

uint64_t cva::SO2GroupStorage<double,cva::MatrixRef<double const,2u,2u,false>>::serialize(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 8);
  if (2 * v1)
  {
    uint64_t v2 = *(void *)result;
    uint64_t v3 = *(void *)result + 8 * (2 * v1);
    unint64_t v4 = (unint64_t)(v1 - 2) << 32;
    do
    {
      double result = std::ostream::write();
      unint64_t v5 = HIDWORD(v4);
      if ((int)v4 < 1) {
        unint64_t v5 = 0;
      }
      uint64_t v6 = v2 + 8 * v5;
      uint64_t v7 = (v4 + 1);
      if ((int)v4 >= 1) {
        uint64_t v7 = 0;
      }
      unint64_t v4 = v7 | v4 & 0xFFFFFFFF00000000;
      uint64_t v2 = v6 + 8;
    }
    while (v6 + 8 != v3);
  }
  return result;
}

void cva::SO2AlgebraStorage<float,cva::Matrix<float,1u,1u,false>>::adjoint(_DWORD *a1@<X8>)
{
  *a1 = 0;
}

float cva::SO2AlgebraStorage<float,cva::Matrix<float,1u,1u,false>>::hat@<S0>(float *a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  float result = *a1;
  float v3 = -*a1;
  *(float *)(a2 + 4) = *a1;
  *(float *)(a2 + 8) = v3;
  return result;
}

float cva::SO2AlgebraStorage<float,cva::Matrix<float,1u,1u,false>>::exp@<S0>(float *a1@<X0>, float *a2@<X8>, float a3@<S0>)
{
  __float2 v4 = __sincosf_stret(*a1 * a3);
  *a2 = v4.__cosval;
  a2[1] = v4.__sinval;
  float result = -v4.__sinval;
  a2[2] = -v4.__sinval;
  a2[3] = v4.__cosval;
  return result;
}

float cva::SO2AlgebraStorage<float,cva::Matrix<float,1u,1u,false>>::expJacobian@<S0>(float *a1@<X0>, uint64_t a2@<X8>)
{
  __float2 v3 = __sincosf_stret(*a1);
  *(float *)a2 = v3.__cosval;
  *(float *)(a2 + 4) = v3.__sinval;
  float result = -v3.__sinval;
  *(float *)(a2 + 8) = -v3.__sinval;
  *(float *)(a2 + 12) = v3.__cosval;
  *(_DWORD *)(a2 + 16) = 1065353216;
  return result;
}

float *cva::SO2AlgebraStorage<float,cva::Matrix<float,1u,1u,false>>::enforce(float *result)
{
  float v1 = *result;
  if (*result <= 0.0)
  {
    if (v1 > -3.1416) {
      return result;
    }
    do
      float v1 = v1 + 3.1416;
    while (v1 <= -3.1416);
  }
  else
  {
    if (v1 < 3.1416) {
      return result;
    }
    do
      float v1 = v1 + -3.1416;
    while (v1 >= 3.1416);
  }
  *float result = v1;
  return result;
}

uint64_t cva::SO2AlgebraStorage<float,cva::Matrix<float,1u,1u,false>>::serialize()
{
  return std::ostream::write();
}

uint64_t cva::SO2AlgebraStorage<float,cva::Matrix<float,1u,1u,false>>::deserialize(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x270F98678](a2, a1, 4);
}

void cva::SO2AlgebraStorage<double,cva::Matrix<double,1u,1u,false>>::adjoint(void *a1@<X8>)
{
  *a1 = 0;
}

double cva::SO2AlgebraStorage<double,cva::Matrix<double,1u,1u,false>>::hat@<D0>(double *a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  double result = *a1;
  double v3 = -*a1;
  *(double *)(a2 + 8) = *a1;
  *(double *)(a2 + 16) = v3;
  return result;
}

double cva::SO2AlgebraStorage<double,cva::Matrix<double,1u,1u,false>>::exp@<D0>(double *a1@<X0>, double *a2@<X8>, double a3@<D0>)
{
  __double2 v4 = __sincos_stret(*a1 * a3);
  *a2 = v4.__cosval;
  a2[1] = v4.__sinval;
  double result = -v4.__sinval;
  a2[2] = -v4.__sinval;
  a2[3] = v4.__cosval;
  return result;
}

double cva::SO2AlgebraStorage<double,cva::Matrix<double,1u,1u,false>>::expJacobian@<D0>(double *a1@<X0>, uint64_t a2@<X8>)
{
  __double2 v3 = __sincos_stret(*a1);
  *(double *)a2 = v3.__cosval;
  *(double *)(a2 + 8) = v3.__sinval;
  double result = -v3.__sinval;
  *(double *)(a2 + 16) = -v3.__sinval;
  *(double *)(a2 + 24) = v3.__cosval;
  *(void *)(a2 + 32) = 0x3FF0000000000000;
  return result;
}

double *cva::SO2AlgebraStorage<double,cva::Matrix<double,1u,1u,false>>::enforce(double *result)
{
  double v1 = *result;
  if (*result <= 0.0)
  {
    if (v1 > -3.14159265) {
      return result;
    }
    do
      double v1 = v1 + 3.14159265;
    while (v1 <= -3.14159265);
  }
  else
  {
    if (v1 < 3.14159265) {
      return result;
    }
    do
      double v1 = v1 + -3.14159265;
    while (v1 >= 3.14159265);
  }
  *double result = v1;
  return result;
}

uint64_t cva::SO2AlgebraStorage<double,cva::Matrix<double,1u,1u,false>>::serialize()
{
  return std::ostream::write();
}

uint64_t cva::SO2AlgebraStorage<double,cva::Matrix<double,1u,1u,false>>::deserialize(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x270F98678](a2, a1, 8);
}

void cva::SO2AlgebraStorage<float,cva::MatrixRef<float const,1u,1u,false>>::adjoint(_DWORD *a1@<X8>)
{
  *a1 = 0;
}

float cva::SO2AlgebraStorage<float,cva::MatrixRef<float const,1u,1u,false>>::hat@<S0>(float **a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  float result = **a1;
  *(float *)(a2 + 4) = result;
  *(float *)(a2 + 8) = -result;
  return result;
}

float cva::SO2AlgebraStorage<float,cva::MatrixRef<float const,1u,1u,false>>::exp@<S0>(float **a1@<X0>, float *a2@<X8>, float a3@<S0>)
{
  __float2 v4 = __sincosf_stret(**a1 * a3);
  *a2 = v4.__cosval;
  a2[1] = v4.__sinval;
  float result = -v4.__sinval;
  a2[2] = -v4.__sinval;
  a2[3] = v4.__cosval;
  return result;
}

float cva::SO2AlgebraStorage<float,cva::MatrixRef<float const,1u,1u,false>>::expJacobian@<S0>(float **a1@<X0>, uint64_t a2@<X8>)
{
  __float2 v3 = __sincosf_stret(**a1);
  *(float *)a2 = v3.__cosval;
  *(float *)(a2 + 4) = v3.__sinval;
  float result = -v3.__sinval;
  *(float *)(a2 + 8) = -v3.__sinval;
  *(float *)(a2 + 12) = v3.__cosval;
  *(_DWORD *)(a2 + 16) = 1065353216;
  return result;
}

uint64_t cva::SO2AlgebraStorage<float,cva::MatrixRef<float const,1u,1u,false>>::serialize()
{
  return std::ostream::write();
}

void cva::SO2AlgebraStorage<double,cva::MatrixRef<double const,1u,1u,false>>::adjoint(void *a1@<X8>)
{
  *a1 = 0;
}

double cva::SO2AlgebraStorage<double,cva::MatrixRef<double const,1u,1u,false>>::hat@<D0>(double **a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  double result = **a1;
  *(double *)(a2 + 8) = result;
  *(double *)(a2 + 16) = -result;
  return result;
}

double cva::SO2AlgebraStorage<double,cva::MatrixRef<double const,1u,1u,false>>::exp@<D0>(double **a1@<X0>, double *a2@<X8>, double a3@<D0>)
{
  __double2 v4 = __sincos_stret(**a1 * a3);
  *a2 = v4.__cosval;
  a2[1] = v4.__sinval;
  double result = -v4.__sinval;
  a2[2] = -v4.__sinval;
  a2[3] = v4.__cosval;
  return result;
}

double cva::SO2AlgebraStorage<double,cva::MatrixRef<double const,1u,1u,false>>::expJacobian@<D0>(double **a1@<X0>, uint64_t a2@<X8>)
{
  __double2 v3 = __sincos_stret(**a1);
  *(double *)a2 = v3.__cosval;
  *(double *)(a2 + 8) = v3.__sinval;
  double result = -v3.__sinval;
  *(double *)(a2 + 16) = -v3.__sinval;
  *(double *)(a2 + 24) = v3.__cosval;
  *(void *)(a2 + 32) = 0x3FF0000000000000;
  return result;
}

uint64_t cva::SO2AlgebraStorage<double,cva::MatrixRef<double const,1u,1u,false>>::serialize()
{
  return std::ostream::write();
}

uint64_t cva::VecLib<float>::gemm()
{
  return cblas_sgemm_NEWLAPACK();
}

uint64_t cva::VecLib<float>::gemv()
{
  return cblas_sgemv_NEWLAPACK();
}

uint64_t cva::VecLib<float>::ger()
{
  return cblas_sger_NEWLAPACK();
}

uint64_t cva::VecLib<float>::geadd()
{
  return appleblas_sgeadd_NEWLAPACK();
}

uint64_t cva::VecLib<float>::syrk()
{
  return cblas_ssyrk_NEWLAPACK();
}

uint64_t cva::VecLib<float>::trsm()
{
  return cblas_strsm_NEWLAPACK();
}

uint64_t cva::VecLib<float>::trsv()
{
  return cblas_strsv_NEWLAPACK();
}

uint64_t cva::VecLib<double>::gemm()
{
  return cblas_dgemm_NEWLAPACK();
}

uint64_t cva::VecLib<double>::gemv()
{
  return cblas_dgemv_NEWLAPACK();
}

uint64_t cva::VecLib<double>::ger()
{
  return cblas_dger_NEWLAPACK();
}

uint64_t cva::VecLib<double>::geadd()
{
  return appleblas_dgeadd_NEWLAPACK();
}

uint64_t cva::VecLib<double>::syrk()
{
  return cblas_dsyrk_NEWLAPACK();
}

uint64_t cva::VecLib<double>::trsm()
{
  return cblas_dtrsm_NEWLAPACK();
}

uint64_t cva::VecLib<double>::trsv()
{
  return cblas_dtrsv_NEWLAPACK();
}

uint64_t cva::VecLibLapack<float>::potrs()
{
  return 0xFFFFFFFFLL;
}

uint64_t cva::VecLibLapack<float>::potrf()
{
  return 0xFFFFFFFFLL;
}

uint64_t cva::VecLibLapack<float>::trtri()
{
  return 0xFFFFFFFFLL;
}

uint64_t cva::VecLibLapack<float>::trtrs()
{
  return 0xFFFFFFFFLL;
}

uint64_t cva::VecLibLapack<float>::sytrs()
{
  return 0xFFFFFFFFLL;
}

uint64_t cva::VecLibLapack<float>::sytrf()
{
  return 0xFFFFFFFFLL;
}

uint64_t cva::VecLibLapack<float>::pstrf()
{
  return 0xFFFFFFFFLL;
}

uint64_t cva::VecLibLapack<float>::ormqr()
{
  return 0xFFFFFFFFLL;
}

uint64_t cva::VecLibLapack<float>::getrs()
{
  return 0xFFFFFFFFLL;
}

uint64_t cva::VecLibLapack<float>::getrf()
{
  return 0xFFFFFFFFLL;
}

uint64_t cva::VecLibLapack<double>::potrs()
{
  return 0xFFFFFFFFLL;
}

uint64_t cva::VecLibLapack<double>::potrf()
{
  return 0xFFFFFFFFLL;
}

uint64_t cva::VecLibLapack<double>::trtri()
{
  return 0xFFFFFFFFLL;
}

uint64_t cva::VecLibLapack<double>::trtrs()
{
  return 0xFFFFFFFFLL;
}

uint64_t cva::VecLibLapack<double>::sytrs()
{
  return 0xFFFFFFFFLL;
}

uint64_t cva::VecLibLapack<double>::sytrf()
{
  return 0xFFFFFFFFLL;
}

uint64_t cva::VecLibLapack<double>::pstrf()
{
  return 0xFFFFFFFFLL;
}

uint64_t cva::VecLibLapack<double>::ormqr()
{
  return 0xFFFFFFFFLL;
}

uint64_t cva::VecLibLapack<double>::getrs()
{
  return 0xFFFFFFFFLL;
}

uint64_t cva::VecLibLapack<double>::getrf()
{
  return 0xFFFFFFFFLL;
}

uint64_t cva::vecLib::gesdd<float>()
{
  return sgesdd_NEWLAPACK();
}

uint64_t cva::vecLib::gesdd<double>()
{
  return dgesdd_NEWLAPACK();
}

uint64_t cva::vecLib::gesvd<float>()
{
  return sgesvd_NEWLAPACK();
}

uint64_t cva::vecLib::gesvd<double>()
{
  return dgesvd_NEWLAPACK();
}

uint64_t cva::vecLib::geev<float>()
{
  return sgeev_NEWLAPACK();
}

uint64_t cva::vecLib::geev<double>()
{
  return dgeev_NEWLAPACK();
}

uint64_t cva::vecLib::syev<float>()
{
  return ssyev_NEWLAPACK();
}

uint64_t cva::vecLib::syev<double>()
{
  return dsyev_NEWLAPACK();
}

uint64_t cva::vecLib::geqrf<float>()
{
  return sgeqrf_NEWLAPACK();
}

uint64_t cva::vecLib::geqrf<double>()
{
  return dgeqrf_NEWLAPACK();
}

uint64_t cva::vecLib::gerqf<float>()
{
  return sgerqf_NEWLAPACK();
}

uint64_t cva::vecLib::gerqf<double>()
{
  return dgerqf_NEWLAPACK();
}

uint64_t cva::vecLib::orgqr<float>()
{
  return sorgqr_NEWLAPACK();
}

uint64_t cva::vecLib::orgqr<double>()
{
  return dorgqr_NEWLAPACK();
}

uint64_t cva::vecLib::orgrq<float>()
{
  return sorgqr_NEWLAPACK();
}

uint64_t cva::vecLib::orgrq<double>()
{
  return dorgqr_NEWLAPACK();
}

uint64_t cva::vecLib::gelsd<float>()
{
  return sgelsd_NEWLAPACK();
}

uint64_t cva::vecLib::gelsd<double>()
{
  return dgelsd_NEWLAPACK();
}

uint64_t cva::vecLib::trtrs<float>()
{
  return strtrs_NEWLAPACK();
}

uint64_t cva::vecLib::trtrs<double>()
{
  return dtrtrs_NEWLAPACK();
}

uint64_t cva::vecLib::gels<float>()
{
  return sgels_NEWLAPACK();
}

uint64_t cva::vecLib::gels<double>()
{
  return dgels_NEWLAPACK();
}

uint64_t cva::vecLib::gelss<float>()
{
  return sgelss_NEWLAPACK();
}

uint64_t cva::vecLib::gelss<double>()
{
  return dgelss_NEWLAPACK();
}

uint64_t cva::vecLib::gesv<float>()
{
  return sgesv_NEWLAPACK();
}

uint64_t cva::vecLib::gesv<double>()
{
  return dgesv_NEWLAPACK();
}

uint64_t cva::vecLib::gbtrs<double>()
{
  return dgbtrs_NEWLAPACK();
}

uint64_t cva::vecLib::gbtrf<double>()
{
  return dgbtrf_NEWLAPACK();
}

uint64_t cva::vecLib::gbsv<double>()
{
  return dgbsv_NEWLAPACK();
}

uint64_t cva::vecLib::gbsv<float>()
{
  return sgbsv_NEWLAPACK();
}

uint64_t cva::vecLib::getri<float>()
{
  return sgetri_NEWLAPACK();
}

uint64_t cva::vecLib::getri<double>()
{
  return dgetri_NEWLAPACK();
}

uint64_t cva::vecLib::getrf<float>()
{
  return sgetrf_NEWLAPACK();
}

uint64_t cva::vecLib::getrf<double>()
{
  return dgetrf_NEWLAPACK();
}

uint64_t cva::vecLib::sysv<float>()
{
  return ssysv_NEWLAPACK();
}

uint64_t cva::vecLib::sysv<double>()
{
  return dsysv_NEWLAPACK();
}

uint64_t cva::vecLib::posv<float>()
{
  return sposv_NEWLAPACK();
}

uint64_t cva::vecLib::posv<double>()
{
  return dposv_NEWLAPACK();
}

uint64_t cva::vecLib::potrf<float>()
{
  return spotrf_NEWLAPACK();
}

uint64_t cva::vecLib::potrf<double>()
{
  return dpotrf_NEWLAPACK();
}

void *cva::Profiler::instance(cva::Profiler *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_267869AF8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_267869AF8))
  {
    sub_2153E44B4();
  }
  return &unk_267869A68;
}

void sub_2153E44B4()
{
  qword_267869A70 = (uint64_t)&qword_267869A70;
  qword_267869A78 = (uint64_t)&qword_267869A70;
  dword_267869A88 = 0;
  *((unsigned char *)&__str.__r_.__value_.__s + 23) = 4;
  strcpy((char *)&__str, "Root");
  xmmword_267869A90 = 0u;
  unk_267869AA0 = 0u;
  qword_267869AC0 = 0;
  xmmword_267869AB0 = 0u;
  qword_267869AD0 = (uint64_t)&qword_267869AD0;
  unk_267869AD8 = &qword_267869AD0;
  dword_267869AE8 = 0;
  std::string::operator=((std::string *)&xmmword_267869AB0, &__str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  byte_267869AF0 = 1;
  operator new();
}

uint64_t sub_2153E457C(uint64_t a1)
{
  sub_2153E4624(a1 + 40);
  if (*(_DWORD *)(a1 + 128))
  {
    uint64_t v2 = *(void **)(a1 + 112);
    do
    {
      __double2 v3 = (void *)v2[1];
      operator delete(v2);
      uint64_t v2 = v3;
      int v4 = *(_DWORD *)(a1 + 128) - 1;
      *(_DWORD *)(a1 + 128) = v4;
    }
    while (v4);
  }
  *(void *)(a1 + 104) = a1 + 104;
  *(void *)(a1 + 112) = a1 + 104;
  if (*(char *)(a1 + 95) < 0)
  {
    operator delete(*(void **)(a1 + 72));
    if (!*(_DWORD *)(a1 + 32)) {
      goto LABEL_10;
    }
  }
  else if (!*(_DWORD *)(a1 + 32))
  {
    goto LABEL_10;
  }
  unint64_t v5 = *(void **)(a1 + 16);
  do
  {
    uint64_t v6 = (void *)v5[1];
    operator delete(v5);
    unint64_t v5 = v6;
    int v7 = *(_DWORD *)(a1 + 32) - 1;
    *(_DWORD *)(a1 + 32) = v7;
  }
  while (v7);
LABEL_10:
  *(void *)(a1 + 8) = a1 + 8;
  *(void *)(a1 + 16) = a1 + 8;
  return a1;
}

double sub_2153E4624(uint64_t a1)
{
  uint64_t v2 = a1 + 64;
  for (uint64_t i = *(void *)(a1 + 72); i != v2; uint64_t i = *(void *)(i + 8))
  {
    uint64_t v4 = *(void *)(i + 16);
    if (v4)
    {
      sub_2153E4624(*(void *)(i + 16));
      if (*(_DWORD *)(v4 + 88))
      {
        unint64_t v5 = *(void **)(v4 + 72);
        do
        {
          uint64_t v6 = (void *)v5[1];
          operator delete(v5);
          unint64_t v5 = v6;
          int v7 = *(_DWORD *)(v4 + 88) - 1;
          *(_DWORD *)(v4 + 88) = v7;
        }
        while (v7);
      }
      *(void *)(v4 + 64) = v4 + 64;
      *(void *)(v4 + 72) = v4 + 64;
      if (*(char *)(v4 + 55) < 0) {
        operator delete(*(void **)(v4 + 32));
      }
      MEMORY[0x2166B9890](v4, 0x1032C40C8AE412DLL);
    }
  }
  if (*(_DWORD *)(a1 + 88))
  {
    long long v8 = *(void **)(a1 + 72);
    do
    {
      long long v9 = (void *)v8[1];
      operator delete(v8);
      long long v8 = v9;
      int v10 = *(_DWORD *)(a1 + 88) - 1;
      *(_DWORD *)(a1 + 88) = v10;
    }
    while (v10);
  }
  *(void *)(a1 + 64) = a1 + 64;
  *(void *)(a1 + 72) = v2;
  double result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

void cva::backTrace(cva *this, int a2, int a3, unsigned int a4, unsigned int a5)
{
  int v7 = (int)this;
  uint64_t v69 = *MEMORY[0x263EF8340];
  if (a5)
  {
    long long v8 = operator new(8 * a5);
    bzero(v8, 8 * a5);
  }
  else
  {
    long long v8 = 0;
  }
  unsigned int v50 = backtrace((void **)v8, a5);
  long long v9 = backtrace_symbols((void *const *)v8, v50);
  BOOL v65 = 0;
  double v56 = (void (**)(void **))&unk_26C5FBF60;
  double v57 = v9;
  double v59 = (void **)&v56;
  sub_2153E5128(&v56, v64);
  unsigned int v47 = a5;
  int v49 = v7;
  if (v59 == (void **)&v56)
  {
    v56[4]((void **)&v56);
  }
  else if (v59)
  {
    (*((void (**)(void))*v59 + 5))();
  }
  uint64_t v48 = MEMORY[0x263F8C328] + 24;
  uint64_t v10 = MEMORY[0x263F8C328] + 104;
  v63[0] = MEMORY[0x263F8C328] + 104;
  uint64_t v11 = MEMORY[0x263F8C328] + 64;
  uint64_t v58 = MEMORY[0x263F8C328] + 64;
  double v12 = (void *)MEMORY[0x263F8C2B8];
  double v13 = *(void (***)(void **))(MEMORY[0x263F8C2B8] + 24);
  double v56 = *(void (***)(void **))(MEMORY[0x263F8C2B8] + 16);
  *(void (***)(void **))((char *)&v56 + (void)*(v56 - 3)) = v13;
  double v57 = 0;
  double v14 = (std::ios_base *)((char *)&v56 + (void)*(v56 - 3));
  std::ios_base::init(v14, &v59);
  v14[1].__vftable = 0;
  v14[1].__fmtflags_ = -1;
  uint64_t v15 = v12[5];
  uint64_t v58 = v12[4];
  *(uint64_t *)((char *)&v58 + *(void *)(v58 - 24)) = v15;
  double v56 = (void (**)(void **))v12[1];
  *(void (***)(void **))((char *)&v56 + (void)*(v56 - 3)) = (void (**)(void **))v12[6];
  v63[0] = v10;
  double v56 = (void (**)(void **))v48;
  uint64_t v58 = v11;
  std::streambuf::basic_streambuf();
  uint64_t v46 = MEMORY[0x263F8C318] + 16;
  double v59 = (void **)(MEMORY[0x263F8C318] + 16);
  long long __p = 0u;
  long long v61 = 0u;
  int v62 = 24;
  if (v50 > a4)
  {
    uint64_t v16 = a4;
    uint64_t v17 = MEMORY[0x263EF8318];
    do
    {
      snprintf(__str, 0x20uLL, "%-3u 0x%016lx ", v16 - a4, *((void *)v8 + v16));
      size_t v20 = strlen(__str);
      sub_2153C1168(&v58, (uint64_t)__str, v20);
      double v21 = v9[v16];
      int v22 = *v21;
      if (v22 < 1) {
        goto LABEL_49;
      }
      if ((*(_DWORD *)(v17 + 4 * *v21 + 60) & 0x400) == 0)
      {
LABEL_14:
        if (v22 != 48) {
          goto LABEL_49;
        }
        if (v21[1] != 120) {
          goto LABEL_49;
        }
        int v23 = v21[2];
        if (v23 < 0 || (*(_DWORD *)(v17 + 4 * v21[2] + 60) & 0x10000) == 0) {
          goto LABEL_49;
        }
        if (v21[2])
        {
          v21 += 2;
          do
          {
            if ((*(_DWORD *)(v17 + 4 * v23 + 60) & 0x10000) == 0) {
              goto LABEL_47;
            }
            int v24 = *++v21;
            int v23 = v24;
          }
          while (v24 > 0);
          if (v23)
          {
            while (1)
            {
LABEL_47:
              if ((v23 & 0x80) != 0)
              {
                if (!__maskrune((char)v23, 0x4000uLL)) {
                  goto LABEL_49;
                }
              }
              else if ((*(_DWORD *)(v17 + 4 * (char)v23 + 60) & 0x4000) == 0)
              {
                goto LABEL_49;
              }
              int v31 = *++v21;
              LOBYTE(v23) = v31;
              if (!v31) {
                goto LABEL_49;
              }
            }
          }
          goto LABEL_49;
        }
        v21 += 2;
        if (!v49) {
          goto LABEL_10;
        }
LABEL_50:
        if (dladdr(*((const void **)v8 + v16), &v53)) {
          BOOL v32 = v53.dli_sname == 0;
        }
        else {
          BOOL v32 = 1;
        }
        if (v32) {
          goto LABEL_10;
        }
        double v55 = 0;
        *(void *)std::string __str = &unk_26C5FBFA8;
        uint64_t v67 = 0;
        unint64_t v68 = __str;
        sub_2153E5128(__str, v54);
        if (v68 == __str)
        {
          (*(void (**)(char *))(*(void *)__str + 32))(__str);
        }
        else if (v68)
        {
          (*(void (**)(void))(*(void *)v68 + 40))();
        }
        int v33 = -1;
        *(_DWORD *)std::string __str = -1;
        dli_sname = v53.dli_sname;
        if (a2 && *v53.dli_sname == 95)
        {
          double v35 = __cxa_demangle(v53.dli_sname, 0, 0, (int *)__str);
          int v33 = *(_DWORD *)__str;
          dli_sname = v53.dli_sname;
        }
        else
        {
          double v35 = 0;
        }
        if (dli_sname) {
          double v36 = dli_sname;
        }
        else {
          double v36 = v21;
        }
        if (v35) {
          BOOL v37 = v33 == 0;
        }
        else {
          BOOL v37 = 0;
        }
        if (v37) {
          double v38 = v35;
        }
        else {
          double v38 = v36;
        }
        size_t v39 = strlen(v38);
        double v40 = sub_2153C1168(&v58, (uint64_t)v38, v39);
        sub_2153C1168(v40, (uint64_t)" + ", 3);
        std::ostream::operator<<();
        if (a3 && v53.dli_fname)
        {
          double v41 = strrchr((char *)v53.dli_fname, 47);
          sub_2153C1168(&v58, (uint64_t)" (", 2);
          if (v41) {
            dli_fname = v41 + 1;
          }
          else {
            dli_fname = v53.dli_fname;
          }
          size_t v43 = strlen(dli_fname);
          double v44 = sub_2153C1168(&v58, (uint64_t)dli_fname, v43);
          sub_2153C1168(v44, (uint64_t)")", 1);
        }
        sub_2153C1168(&v58, (uint64_t)"\n", 1);
        if (v55)
        {
          (*(void (**)(void *))(*v55 + 48))(v55);
          if (v55 == v54)
          {
            (*(void (**)(void *))(v54[0] + 32))(v54);
          }
          else if (v55)
          {
            (*(void (**)(void))(*v55 + 40))();
          }
          goto LABEL_11;
        }
LABEL_97:
        sub_2153E5390();
      }
      do
      {
        if ((*(_DWORD *)(v17 + 4 * v22 + 60) & 0x400) == 0) {
          goto LABEL_30;
        }
        int v25 = *++v21;
        int v22 = v25;
      }
      while (v25 > 0);
      if (!v22) {
        goto LABEL_49;
      }
LABEL_30:
      while ((v22 & 0x80) != 0)
      {
        if (!__maskrune((char)v22, 0x4000uLL)) {
          goto LABEL_32;
        }
LABEL_29:
        int v26 = *++v21;
        LOBYTE(v22) = v26;
        if (!v26) {
          goto LABEL_49;
        }
      }
      if ((*(_DWORD *)(v17 + 4 * (char)v22 + 60) & 0x4000) != 0) {
        goto LABEL_29;
      }
LABEL_32:
      char v27 = *v21;
      if (!*v21) {
        goto LABEL_49;
      }
      while (2)
      {
        if (v27 < 0)
        {
          if (__maskrune(v27, 0x4000uLL)) {
            goto LABEL_38;
          }
LABEL_35:
          int v28 = *++v21;
          char v27 = v28;
          if (!v28) {
            goto LABEL_49;
          }
          continue;
        }
        break;
      }
      if ((*(_DWORD *)(v17 + 4 * v27 + 60) & 0x4000) == 0) {
        goto LABEL_35;
      }
LABEL_38:
      char v29 = *v21;
      if (*v21)
      {
        do
        {
          if (v29 < 0)
          {
            if (!__maskrune(v29, 0x4000uLL)) {
              goto LABEL_44;
            }
          }
          else if ((*(_DWORD *)(v17 + 4 * v29 + 60) & 0x4000) == 0)
          {
LABEL_44:
            LOBYTE(v22) = *v21;
            goto LABEL_14;
          }
          int v30 = *++v21;
          char v29 = v30;
        }
        while (v30);
      }
LABEL_49:
      if (v49) {
        goto LABEL_50;
      }
LABEL_10:
      size_t v18 = strlen(v21);
      double v19 = sub_2153C1168(&v58, (uint64_t)v21, v18);
      sub_2153C1168(v19, (uint64_t)"\n", 1);
LABEL_11:
      ++v16;
    }
    while (v16 != v50);
  }
  if (v50 == v47) {
    sub_2153C1168(&v58, (uint64_t)"...                    <redacted>\n", 34);
  }
  std::stringbuf::str();
  double v56 = (void (**)(void **))*MEMORY[0x263F8C2B8];
  uint64_t v45 = *(void *)(MEMORY[0x263F8C2B8] + 72);
  *(void (***)(void **))((char *)&v56 + (void)*(v56 - 3)) = *(void (***)(void **))(MEMORY[0x263F8C2B8] + 64);
  uint64_t v58 = v45;
  double v59 = (void **)v46;
  if (SBYTE7(v61) < 0) {
    operator delete((void *)__p);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2166B9860](v63);
  if (!v65) {
    goto LABEL_97;
  }
  (*(void (**)(void *))(*v65 + 48))(v65);
  if (v65 == v64)
  {
    (*(void (**)(void *))(v64[0] + 32))(v64);
    if (v8) {
LABEL_93:
    }
      operator delete(v8);
  }
  else
  {
    if (v65) {
      (*(void (**)(void))(*v65 + 40))();
    }
    if (v8) {
      goto LABEL_93;
    }
  }
}

void *sub_2153E5128(void *result, void *a2)
{
  v6[3] = *MEMORY[0x263EF8340];
  if (a2 != result)
  {
    __double2 v3 = result;
    uint64_t v4 = (void *)result[3];
    unint64_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        double result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        double result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      double result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

uint64_t sub_2153E5390()
{
  return sub_2153E53A8();
}

void sub_2153E53A8(uint64_t a1)
{
}

uint64_t sub_2153E53B8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26C5FBFA8;
  a2[1] = v2;
  return result;
}

void *sub_2153E53DC(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = &unk_26C5FBFA8;
  result[1] = v3;
  return result;
}

void sub_2153E5424()
{
}

void sub_2153E543C(uint64_t a1)
{
}

uint64_t sub_2153E544C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26C5FBF60;
  a2[1] = v2;
  return result;
}

void *sub_2153E5470(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = &unk_26C5FBF60;
  result[1] = v3;
  return result;
}

void sub_2153E54B8()
{
}

long long *cva::ProfilerAriadne::instance(cva::ProfilerAriadne *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_267869BA0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_267869BA0))
  {
    sub_2153E5544();
    __cxa_atexit((void (*)(void *))sub_2153E55D8, &xmmword_267869B00, &dword_2153B7000);
    __cxa_guard_release(&qword_267869BA0);
  }
  return &xmmword_267869B00;
}

uint64_t sub_2153E5544()
{
  uint64_t v2 = *MEMORY[0x263EF8340];
  xmmword_267869B00 = 0u;
  *(_OWORD *)algn_267869B10 = 0u;
  xmmword_267869B20 = 0u;
  unk_267869B30 = 0u;
  xmmword_267869B40 = 0u;
  dword_267869B50 = 1065353216;
  word_267869B58 = 0;
  pthread_mutexattr_init(&v1);
  pthread_mutexattr_settype(&v1, 2);
  return pthread_mutex_init(&stru_267869B60, &v1);
}

uint64_t sub_2153E55D8(uint64_t a1)
{
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 96));
  uint64_t v2 = *(void ***)(a1 + 64);
  if (v2)
  {
    do
    {
      unint64_t v5 = (void **)*v2;
      if (*((char *)v2 + 39) < 0) {
        operator delete(v2[2]);
      }
      operator delete(v2);
      uint64_t v2 = v5;
    }
    while (v5);
  }
  uint64_t v3 = *(void **)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v3) {
    operator delete(v3);
  }
  return sub_2153E565C(a1);
}

uint64_t sub_2153E565C(uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 8);
  uint64_t v3 = *(void ***)(a1 + 16);
  if (v3 == v2)
  {
    uint64_t v4 = (void *)(a1 + 40);
    uint64_t v3 = *(void ***)(a1 + 8);
  }
  else
  {
    uint64_t v4 = (void *)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = &v2[v5 / 0xAA];
    unint64_t v7 = (unint64_t)*v6;
    unint64_t v8 = (unint64_t)*v6 + 24 * (v5 % 0xAA);
    unint64_t v9 = (unint64_t)v2[(*(void *)(a1 + 40) + v5) / 0xAA] + 24 * ((*(void *)(a1 + 40) + v5) % 0xAA);
    if (v8 != v9)
    {
      do
      {
        if (*(char *)(v8 + 23) < 0)
        {
          operator delete(*(void **)v8);
          unint64_t v7 = (unint64_t)*v6;
        }
        v8 += 24;
        if (v8 - v7 == 4080)
        {
          unint64_t v10 = (unint64_t)v6[1];
          ++v6;
          unint64_t v7 = v10;
          unint64_t v8 = v10;
        }
      }
      while (v8 != v9);
      uint64_t v2 = *(void ***)(a1 + 8);
      uint64_t v3 = *(void ***)(a1 + 16);
    }
  }
  void *v4 = 0;
  unint64_t v11 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = *(void ***)(a1 + 16);
      uint64_t v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v11 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v12 = v11 >> 3;
  if (v12 == 1)
  {
    uint64_t v13 = 85;
    goto LABEL_17;
  }
  if (v12 == 2)
  {
    uint64_t v13 = 170;
LABEL_17:
    *(void *)(a1 + 32) = v13;
  }
  if (v2 != v3)
  {
    do
    {
      double v14 = *v2++;
      operator delete(v14);
    }
    while (v2 != v3);
    uint64_t v16 = *(void *)(a1 + 8);
    uint64_t v15 = *(void *)(a1 + 16);
    if (v15 != v16) {
      *(void *)(a1 + 16) = v15 + ((v16 - v15 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t cva::ProfilerAriadne::printPlist(cva::ProfilerAriadne *this)
{
  uint64_t v2 = MEMORY[0x263F8C340] + 24;
  uint64_t v3 = MEMORY[0x263F8C340] + 64;
  v30[0] = MEMORY[0x263F8C340] + 64;
  uint64_t v4 = *(void *)(MEMORY[0x263F8C2C8] + 16);
  uint64_t v25 = *(void *)(MEMORY[0x263F8C2C8] + 8);
  *(void *)((char *)&v26[-1] + *(void *)(v25 - 24)) = v4;
  unint64_t v5 = (std::ios_base *)((char *)&v26[-1] + *(void *)(v25 - 24));
  std::ios_base::init(v5, v26);
  v5[1].__vftable = 0;
  v5[1].__fmtflags_ = -1;
  uint64_t v25 = v2;
  v30[0] = v3;
  std::streambuf::basic_streambuf();
  v26[0] = MEMORY[0x263F8C318] + 16;
  *(_OWORD *)long long __p = 0u;
  long long v28 = 0u;
  int v29 = 16;
  int v23 = (pthread_mutex_t *)((char *)this + 96);
  uint64_t v24 = MEMORY[0x263F8C318] + 16;
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 96));
  sub_2153C1168(&v25, (uint64_t)"Ariadne custom signpost plist:\n", 31);
  sub_2153C1168(&v25, (uint64_t)"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n", 39);
  sub_2153C1168(&v25, (uint64_t)"<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n", 103);
  sub_2153C1168(&v25, (uint64_t)"<plist version=\"1.0\">\n", 22);
  sub_2153C1168(&v25, (uint64_t)"<array>\n", 8);
  sub_2153C1168(&v25, (uint64_t)"  <dict>\n", 9);
  sub_2153C1168(&v25, (uint64_t)"    <key>Name</key>\n", 20);
  sub_2153C1168(&v25, (uint64_t)"    <string>AppleCVA</string>\n", 30);
  sub_2153C1168(&v25, (uint64_t)"    <key>Children</key>\n", 24);
  sub_2153C1168(&v25, (uint64_t)"    <array>\n", 12);
  unint64_t v8 = (uint64_t **)*((void *)this + 8);
  unint64_t v7 = (void *)((char *)this + 64);
  for (uint64_t i = v8; i; uint64_t i = (uint64_t **)*i)
  {
    sub_2153C1168(&v25, (uint64_t)"      <dict>\n", 13);
    sub_2153C1168(&v25, (uint64_t)"        <key>Name</key>\n", 24);
    sub_2153C1168(&v25, (uint64_t)"        <string>", 16);
    int v9 = *((char *)i + 39);
    if (v9 >= 0) {
      uint64_t v10 = (uint64_t)(i + 2);
    }
    else {
      uint64_t v10 = (uint64_t)i[2];
    }
    if (v9 >= 0) {
      uint64_t v11 = *((unsigned __int8 *)i + 39);
    }
    else {
      uint64_t v11 = (uint64_t)i[3];
    }
    sub_2153C1168(&v25, v10, v11);
    sub_2153C1168(&v25, (uint64_t)"</string>\n", 10);
    sub_2153C1168(&v25, (uint64_t)"        <key>Type</key>\n", 24);
    sub_2153C1168(&v25, (uint64_t)"        <string>Interval</string>\n", 34);
    sub_2153C1168(&v25, (uint64_t)"        <key>Component</key>\n", 29);
    sub_2153C1168(&v25, (uint64_t)"        <string>", 16);
    uint64_t v12 = v25;
    *(_DWORD *)((char *)v26 + *(void *)(v25 - 24)) = *(_DWORD *)((unsigned char *)v26 + *(void *)(v25 - 24)) & 0xFFFFFFB5 | 8;
    *(_DWORD *)((char *)v26 + *(void *)(v12 - 24)) |= 0x200u;
    uint64_t v13 = (uint64_t *)std::ostream::operator<<();
    uint64_t v14 = *v13;
    *(_DWORD *)((char *)v13 + *(void *)(*v13 - 24) + 8) = *(_DWORD *)((unsigned char *)v13 + *(void *)(*v13 - 24) + 8) & 0xFFFFFFB5 | 2;
    *(_DWORD *)((char *)v13 + *(void *)(v14 - 24) + 8) &= ~0x200u;
    uint64_t v15 = sub_2153C1168(v13, (uint64_t)"</string>\n", 10);
    uint64_t v16 = sub_2153C1168(v15, (uint64_t)"        <key>CodeBegin</key>\n", 29);
    sub_2153C1168(v16, (uint64_t)"        <string>", 16);
    uint64_t v17 = (void *)std::ostream::operator<<();
    size_t v18 = sub_2153C1168(v17, (uint64_t)"</string>\n", 10);
    double v19 = sub_2153C1168(v18, (uint64_t)"        <key>CodeEnd</key>\n", 27);
    sub_2153C1168(v19, (uint64_t)"        <string>", 16);
    size_t v20 = (void *)std::ostream::operator<<();
    double v21 = sub_2153C1168(v20, (uint64_t)"</string>\n", 10);
    sub_2153C1168(v21, (uint64_t)"      </dict>\n", 14);
  }
  sub_2153C1168(&v25, (uint64_t)"    </array>\n", 13);
  sub_2153C1168(&v25, (uint64_t)"  </dict>\n", 10);
  sub_2153C1168(&v25, (uint64_t)"</array>\n", 9);
  sub_2153C1168(&v25, (uint64_t)"</plist>\n", 9);
  do
    unint64_t v7 = (void *)*v7;
  while (v7);
  pthread_mutex_unlock(v23);
  uint64_t v25 = *MEMORY[0x263F8C2C8];
  *(void *)((char *)&v26[-1] + *(void *)(v25 - 24)) = *(void *)(MEMORY[0x263F8C2C8] + 24);
  v26[0] = v24;
  if (SBYTE7(v28) < 0) {
    operator delete(__p[0]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x2166B9860](v30);
}

uint64_t cva::ProfilerAriadne::clear(cva::ProfilerAriadne *this)
{
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 96);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 96));
  long long v52 = 0u;
  long long v53 = 0u;
  long long v51 = 0u;
  uint64_t v4 = (void **)*((void *)this + 1);
  uint64_t v3 = *((void *)this + 2);
  if ((void **)v3 == v4)
  {
    unint64_t v5 = (void *)((char *)this + 40);
    uint64_t v3 = *((void *)this + 1);
  }
  else
  {
    unint64_t v5 = (void *)((char *)this + 40);
    unint64_t v6 = *((void *)this + 4);
    unint64_t v7 = &v4[v6 / 0xAA];
    unint64_t v8 = (unint64_t)*v7;
    unint64_t v9 = (unint64_t)*v7 + 24 * (v6 % 0xAA);
    unint64_t v10 = (unint64_t)v4[(*((void *)this + 5) + v6) / 0xAA] + 24 * ((*((void *)this + 5) + v6) % 0xAA);
    if (v9 != v10)
    {
      do
      {
        if (*(char *)(v9 + 23) < 0)
        {
          operator delete(*(void **)v9);
          unint64_t v8 = (unint64_t)*v7;
        }
        v9 += 24;
        if (v9 - v8 == 4080)
        {
          unint64_t v11 = (unint64_t)v7[1];
          ++v7;
          unint64_t v8 = v11;
          unint64_t v9 = v11;
        }
      }
      while (v9 != v10);
      uint64_t v4 = (void **)*((void *)this + 1);
      uint64_t v3 = *((void *)this + 2);
    }
  }
  *unint64_t v5 = 0;
  unint64_t v12 = v3 - (void)v4;
  if ((unint64_t)(v3 - (void)v4) >= 0x11)
  {
    do
    {
      operator delete(*v4);
      uint64_t v3 = *((void *)this + 2);
      uint64_t v4 = (void **)(*((void *)this + 1) + 8);
      *((void *)this + 1) = v4;
      unint64_t v12 = v3 - (void)v4;
    }
    while ((unint64_t)(v3 - (void)v4) > 0x10);
  }
  uint64_t v13 = (uint64_t *)((char *)this + 32);
  unint64_t v14 = v12 >> 3;
  if (v14 == 1)
  {
    uint64_t v15 = 85;
  }
  else
  {
    if (v14 != 2) {
      goto LABEL_18;
    }
    uint64_t v15 = 170;
  }
  *uint64_t v13 = v15;
LABEL_18:
  uint64_t v16 = *((void *)this + 5);
  if (v16)
  {
    uint64_t v17 = *v13;
    if ((unint64_t)*v13 >= 0xAA)
    {
      operator delete(*v4);
      uint64_t v3 = *((void *)this + 2);
      uint64_t v4 = (void **)(*((void *)this + 1) + 8);
      *((void *)this + 1) = v4;
      uint64_t v16 = *((void *)this + 5);
      uint64_t v17 = *((void *)this + 4) - 170;
      *((void *)this + 4) = v17;
    }
    uint64_t v18 = 170 * ((v3 - (uint64_t)v4) >> 3) - 1;
    if ((void **)v3 == v4) {
      uint64_t v18 = 0;
    }
    if ((unint64_t)(v18 - (v16 + v17)) >= 0xAA)
    {
      operator delete(*(void **)(v3 - 8));
      uint64_t v4 = (void **)*((void *)this + 1);
      uint64_t v3 = *((void *)this + 2) - 8;
      *((void *)this + 2) = v3;
    }
  }
  else
  {
    if ((void **)v3 != v4)
    {
      do
      {
        operator delete(*(void **)(v3 - 8));
        uint64_t v19 = *((void *)this + 1);
        uint64_t v3 = *((void *)this + 2) - 8;
        *((void *)this + 2) = v3;
      }
      while (v3 != v19);
    }
    *uint64_t v13 = 0;
    uint64_t v4 = (void **)v3;
  }
  size_t v20 = *(void **)this;
  uint64_t v21 = v3 - (void)v4;
  unint64_t v22 = (v3 - (uint64_t)v4) >> 3;
  if (v22 < (uint64_t)(*((void *)this + 3) - *(void *)this) >> 3)
  {
    if ((void **)v3 == v4)
    {
      int v23 = 0;
      uint64_t v3 = 8 * v22;
      goto LABEL_41;
    }
    if (v21 < 0) {
      goto LABEL_71;
    }
    int v23 = operator new(v3 - (void)v4);
    uint64_t v3 = (uint64_t)&v23[v22];
    if ((unint64_t)(v21 - 8) < 0x18)
    {
      char v27 = v23;
    }
    else if ((unint64_t)((char *)v23 - (char *)v4) < 0x20)
    {
      char v27 = v23;
    }
    else
    {
      uint64_t v24 = 0;
      unint64_t v25 = ((unint64_t)(v21 - 8) >> 3) + 1;
      uint64_t v26 = v25 & 0x3FFFFFFFFFFFFFFCLL;
      char v27 = &v23[v26];
      uint64_t v28 = v25 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        int v29 = &v23[v24];
        long long v30 = *(_OWORD *)&v4[v24 + 2];
        _OWORD *v29 = *(_OWORD *)&v4[v24];
        v29[1] = v30;
        v24 += 4;
        v28 -= 4;
      }
      while (v28);
      if (v25 == (v25 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_41:
        *(void *)this = v23;
        *((void *)this + 1) = v23;
        uint64_t v4 = (void **)v23;
        *((void *)this + 2) = v3;
        *((void *)this + 3) = v3;
        if (v20)
        {
          operator delete(v20);
          uint64_t v4 = (void **)*((void *)this + 1);
          uint64_t v3 = *((void *)this + 2);
        }
        goto LABEL_43;
      }
      uint64_t v4 = (void **)((char *)v4 + v26 * 8);
    }
    do
    {
      int v31 = *v4++;
      *v27++ = v31;
    }
    while (v27 != (void *)v3);
    goto LABEL_41;
  }
LABEL_43:
  if ((void **)v3 == v4)
  {
    BOOL v32 = v4;
  }
  else
  {
    BOOL v32 = (void **)(v3 + (((unint64_t)v4 - v3 + 7) & 0xFFFFFFFFFFFFFFF8));
    *((void *)this + 2) = v32;
    uint64_t v3 = (uint64_t)v32;
  }
  int v33 = *(void **)this;
  int64_t v34 = (char *)v32 - (char *)v4;
  unint64_t v35 = v32 - v4;
  if (v35 >= (uint64_t)(*((void *)this + 3) - *(void *)this) >> 3) {
    goto LABEL_61;
  }
  if ((void **)v3 == v4)
  {
    double v36 = 0;
    uint64_t v37 = 8 * v35;
    goto LABEL_59;
  }
  if (v34 < 0) {
LABEL_71:
  }
    sub_2153E6200();
  double v36 = operator new((char *)v32 - (char *)v4);
  uint64_t v37 = (uint64_t)&v36[v35];
  if ((unint64_t)(v34 - 8) < 0x18)
  {
    double v41 = v36;
    goto LABEL_58;
  }
  if ((unint64_t)((char *)v36 - (char *)v4) < 0x20)
  {
    double v41 = v36;
    do
    {
LABEL_58:
      uint64_t v45 = *v4++;
      *v41++ = v45;
    }
    while (v41 != (void *)v37);
    goto LABEL_59;
  }
  uint64_t v38 = 0;
  unint64_t v39 = ((unint64_t)(v34 - 8) >> 3) + 1;
  uint64_t v40 = v39 & 0x3FFFFFFFFFFFFFFCLL;
  double v41 = &v36[v40];
  uint64_t v42 = v39 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    size_t v43 = &v36[v38];
    long long v44 = *(_OWORD *)&v4[v38 + 2];
    _OWORD *v43 = *(_OWORD *)&v4[v38];
    v43[1] = v44;
    v38 += 4;
    v42 -= 4;
  }
  while (v42);
  if (v39 != (v39 & 0x3FFFFFFFFFFFFFFCLL))
  {
    uint64_t v4 = (void **)((char *)v4 + v40 * 8);
    goto LABEL_58;
  }
LABEL_59:
  *(void *)this = v36;
  *((void *)this + 1) = v36;
  *((void *)this + 2) = v37;
  *((void *)this + 3) = v37;
  if (v33) {
    operator delete(v33);
  }
LABEL_61:
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  *uint64_t v13 = 0;
  *((void *)this + 5) = 0;
  long long v53 = 0uLL;
  sub_2153E565C((uint64_t)&v51);
  if (*((void *)this + 9))
  {
    uint64_t v46 = (void **)*((void *)this + 8);
    if (v46)
    {
      do
      {
        unsigned int v50 = (void **)*v46;
        if (*((char *)v46 + 39) < 0) {
          operator delete(v46[2]);
        }
        operator delete(v46);
        uint64_t v46 = v50;
      }
      while (v50);
    }
    *((void *)this + 8) = 0;
    uint64_t v47 = *((void *)this + 7);
    if (v47)
    {
      for (uint64_t i = 0; i != v47; ++i)
        *(void *)(*((void *)this + 6) + 8 * i) = 0;
    }
    *((void *)this + 9) = 0;
  }
  *((_WORD *)this + 44) = 0;
  return pthread_mutex_unlock(v2);
}

void sub_2153E6200()
{
}

BOOL cva::safeDivision<float,void>(float *a1, float a2, float a3)
{
  if (a3 != 0.0) {
    *a1 = a2 / a3;
  }
  return a3 != 0.0;
}

BOOL cva::safeDivision<double,void>(double *a1, double a2, double a3)
{
  if (a3 != 0.0) {
    *a1 = a2 / a3;
  }
  return a3 != 0.0;
}

BOOL cva::safeReciprocal<float,void>(float *a1, float a2)
{
  if (a2 != 0.0) {
    *a1 = 1.0 / a2;
  }
  return a2 != 0.0;
}

BOOL cva::safeReciprocal<double,void>(double *a1, double a2)
{
  if (a2 != 0.0) {
    *a1 = 1.0 / a2;
  }
  return a2 != 0.0;
}

uint64_t cva::mtl::createMetal(cva::mtl *this, const char *const *a2, uint64_t a3, const char *a4)
{
  unsigned int v5 = a2;
  uint64_t v38 = *MEMORY[0x263EF8340];
  id v33 = MTLCreateSystemDefaultDevice();
  if (v33)
  {
    uint64_t v7 = v5;
    BOOL v32 = (void *)[objc_alloc(MEMORY[0x263EFF9A0]) initWithCapacity:v5];
    if (v5)
    {
      do
      {
        uint64_t v8 = *(void *)this;
        id v9 = v33;
        unint64_t v10 = [NSString stringWithCString:v8 encoding:1];
        if (a3)
        {
          unint64_t v11 = [NSString stringWithCString:a3 encoding:1];
          unint64_t v12 = [v10 stringByAppendingString:@".metallib"];
          uint64_t v13 = [v11 stringByAppendingPathComponent:v12];
          uint64_t v36 = 0;
          unint64_t v14 = (void *)[v9 newLibraryWithFile:v13 error:&v36];

          if (v14) {
            goto LABEL_20;
          }
        }
        bufstd::string::size_type size = 1025;
        if (!_NSGetExecutablePath(buf, &bufsize))
        {
          uint64_t v15 = [NSString stringWithCString:buf encoding:1];
          uint64_t v16 = [v15 stringByDeletingLastPathComponent];
          uint64_t v17 = [v10 stringByAppendingString:@".metallib"];
          uint64_t v18 = [v16 stringByAppendingPathComponent:v17];
          uint64_t v34 = 0;
          unint64_t v14 = (void *)[v9 newLibraryWithFile:v18 error:&v34];

          if (v14) {
            goto LABEL_20;
          }
          uint64_t v19 = [MEMORY[0x263F086E0] mainBundle];
          if (v19)
          {
            size_t v20 = [NSString stringWithFormat:@"/System/Library/PrivateFrameworks/CoreAppleCVA.framework/%@.metallib", v10];
            long long v30 = [NSString stringWithFormat:@"Frameworks/AppleCVA.framework/%@", v10];
            int v31 = [v19 pathForResource:v30 ofType:@"metallib"];
            id v21 = v20;
            if (v21)
            {
              *(void *)buf = 0;
              unint64_t v14 = (void *)[v9 newLibraryWithFile:v21 error:buf];
              id v22 = *(id *)buf;
              int v23 = v22;
              if (v14)
              {
                uint64_t v24 = v21;
                goto LABEL_17;
              }
              NSLog(&cfstr_FailedCreating_1.isa, v22);

              unint64_t v25 = v21;
            }
            else
            {
              unint64_t v25 = 0;
            }

            id v26 = v31;
            if (v26)
            {
              *(void *)buf = 0;
              uint64_t v24 = v26;
              unint64_t v14 = (void *)[v9 newLibraryWithFile:v26 error:buf];
              id v27 = *(id *)buf;
              int v23 = v27;
              if (!v14) {
                NSLog(&cfstr_FailedCreating_1.isa, v27);
              }
LABEL_17:
            }
            else
            {
              uint64_t v24 = 0;
              unint64_t v14 = 0;
            }

            goto LABEL_20;
          }
        }
        unint64_t v14 = 0;
LABEL_20:

        if (!v14) {
          goto LABEL_27;
        }
        uint64_t v28 = [NSString stringWithCString:*(void *)this encoding:1];
        [v32 setObject:v14 forKey:v28];

        this = (cva::mtl *)((char *)this + 8);
        --v7;
      }
      while (v7);
    }
    if ([v33 newCommandQueue]) {
      operator new();
    }
    NSLog(&cfstr_FailedCreating_0.isa);

LABEL_27:
  }
  else
  {
    NSLog(&cfstr_FailedCreating.isa);
  }

  return 0;
}

void sub_2153E66A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

uint64_t cva::mtl::createMetal(cva::mtl *this, const char *a2, const char *a3, const char *a4)
{
  unsigned int v5 = this;
  return cva::mtl::createMetal((cva::mtl *)&v5, (const char *const *)1, (uint64_t)a2, a4);
}

id *cva::mtl::destroyMetal(id *result)
{
  if (result)
  {
    pthread_mutexattr_t v1 = result;

    JUMPOUT(0x2166B9890);
  }
  return result;
}

uint64_t cva::mtl::createMetalBuffer(id *a1, unsigned int a2)
{
  id v3 = *a1;
  if ([v3 newBufferWithLength:a2 options:0]) {
    operator new();
  }

  return 0;
}

void sub_2153E68E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id CVAGetMetalDevice(id *a1)
{
  return *a1;
}

id *cva::mtl::destroyMetalBuffer(id *result)
{
  if (result)
  {

    JUMPOUT(0x2166B9890);
  }
  return result;
}

uint64_t cva::mtl::metalBufferData(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t cva::mtl::destroyMetalTexture(uint64_t result)
{
  if (result)
  {

    JUMPOUT(0x2166B9890);
  }
  return result;
}

uint64_t cva::mtl::metalTextureData(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t cva::mtl::metalBufferRef(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t cva::mtl::metalTextureOffset(_DWORD *a1)
{
  return (a1[4] - *(_DWORD *)(*(void *)a1 + 8));
}

uint64_t cva::mtl::createMetalCommandBuffer(uint64_t a1)
{
  id v1 = *(id *)(a1 + 8);
  [v1 commandBuffer];
  if (objc_claimAutoreleasedReturnValue()) {
    operator new();
  }

  return 0;
}

void sub_2153E6A54(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id CVAGetMetalCommandQueue(uint64_t a1)
{
  return *(id *)(a1 + 8);
}

id *cva::mtl::destroyMetalCommandBuffer(id *result)
{
  if (result)
  {

    JUMPOUT(0x2166B9890);
  }
  return result;
}

uint64_t cva::mtl::commitMetalCommandBuffer(void *a1)
{
  return MEMORY[0x270F9A6D0](*a1, sel_commit);
}

id CVAGetMetalCommandBuffer(id *a1)
{
  return *a1;
}

BOOL cva::mtl::waitUntilCompleted(id *a1)
{
  id v1 = *a1;
  [v1 waitUntilCompleted];
  BOOL v2 = [v1 status] == 4;

  return v2;
}

void sub_2153E6B20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id CVAGetMetalLibrary(uint64_t a1, uint64_t a2)
{
  id v3 = *(id *)(a1 + 16);
  uint64_t v4 = v3;
  if (a2 || [v3 count] != 1)
  {
    unsigned int v5 = [NSString stringWithCString:a2 encoding:1];
    uint64_t v6 = [v4 objectForKey:v5];
  }
  else
  {
    unsigned int v5 = [v4 allValues];
    uint64_t v6 = [v5 objectAtIndex:0];
  }
  uint64_t v7 = (void *)v6;

  return v7;
}

void sub_2153E6BE4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id CVAGetMetalBuffer(id *a1)
{
  return *a1;
}

id CVAGetMetalTexture(uint64_t a1)
{
  return *(id *)(a1 + 8);
}

id CVACreateMetalComputePipelineState(void *a1, void *a2, uint64_t a3)
{
  id v5 = a1;
  id v6 = a2;
  uint64_t v7 = [NSString stringWithCString:a3 encoding:1];
  uint64_t v8 = (void *)[v6 newFunctionWithName:v7];
  if (v8)
  {
    uint64_t v13 = 0;
    id v9 = (void *)[v5 newComputePipelineStateWithFunction:v8 error:&v13];
    unint64_t v10 = v9;
    if (v9) {
      id v11 = v9;
    }
  }
  else
  {
    unint64_t v10 = 0;
  }

  return v10;
}

void sub_2153E6CE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CVACreateTextureFromMetalTexture(void *a1)
{
  if (a1) {
    operator new();
  }

  return 0;
}

void sub_2153E6D74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CVACreateTextureFromBuffer(id *a1, unsigned int a2, unsigned int a3, unsigned int a4, uint64_t a5, unsigned int a6)
{
  unint64_t v12 = objc_opt_new();
  [v12 setWidth:a2];
  [v12 setHeight:a3];
  [v12 setPixelFormat:a5];
  id v13 = *a1;
  if ([v13 newTextureWithDescriptor:v12 offset:a6 bytesPerRow:a4]) {
    operator new();
  }

  return 0;
}

void sub_2153E6E70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id *cva::mtl::destroyMPSCNNKernel(id *result)
{
  if (result)
  {

    JUMPOUT(0x2166B9890);
  }
  return result;
}

id *cva::mtl::destroyMPSImage(id *result)
{
  if (result)
  {

    JUMPOUT(0x2166B9890);
  }
  return result;
}

id *cva::mtl::destroyMPSTemporaryImage(id *result)
{
  if (result)
  {

    JUMPOUT(0x2166B9890);
  }
  return result;
}

uint64_t CVACreateMPSCNNKernel(MPSCNNKernel *a1)
{
  if (a1) {
    operator new();
  }

  return 0;
}

void sub_2153E6FF0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id CVAGetMPSCNNKernel(id *a1)
{
  return *a1;
}

uint64_t CVACreateMPSImage(MPSImage *a1)
{
  if (a1) {
    operator new();
  }

  return 0;
}

void sub_2153E7064(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id CVAGetMPSImage(id *a1)
{
  return *a1;
}

uint64_t CVACreateMPSTemporaryImage(MPSTemporaryImage *a1)
{
  if (a1) {
    operator new();
  }

  return 0;
}

void sub_2153E70D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id CVAGetMPSTemporaryImage(id *a1)
{
  return *a1;
}

void cva::adp::Session<float>::loadDevice(uint64_t a1, uint64_t **a2, const std::string *a3)
{
  uint64_t v49 = *MEMORY[0x263EF8340];
  id v5 = (std::string::size_type *)(a1 + 56);
  if (!cva::adp::io::PListSerializer::read((void *)(a1 + 56), *a2) || !*v5) {
    return;
  }
  id v6 = (std::string *)(a1 + 72);
  std::string::operator=((std::string *)(a1 + 72), a3);
  *((unsigned char *)&v43.__r_.__value_.__s + 23) = 18;
  strcpy((char *)&v43, "Sensors/Intrinsics");
  if (*(char *)(a1 + 95) < 0)
  {
    sub_2153C0AE4(&__dst, *(void **)(a1 + 72), *(void *)(a1 + 80));
  }
  else
  {
    *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    __dst.__r_.__value_.__r.__words[2] = *(void *)(a1 + 88);
  }
  cva::adp::PListPath::convertToPath((unint64_t *)&v43, (uint64_t)v46);
  if (v47 >= 0) {
    uint64_t v7 = (const std::string::value_type *)v46;
  }
  else {
    uint64_t v7 = (const std::string::value_type *)v46[0];
  }
  if (v47 >= 0) {
    std::string::size_type v8 = v47;
  }
  else {
    std::string::size_type v8 = (std::string::size_type)v46[1];
  }
  std::string::append(&__dst, v7, v8);
  if (v47 < 0) {
    operator delete(v46[0]);
  }
  HIBYTE(v42[2]) = 18;
  strcpy((char *)v42, "Sensors/Extrinsics");
  if (*(char *)(a1 + 95) < 0)
  {
    sub_2153C0AE4(&v43, *(void **)(a1 + 72), *(void *)(a1 + 80));
  }
  else
  {
    *(_OWORD *)&v43.__r_.__value_.__l.__data_ = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v43.__r_.__value_.__r.__words[2] = *(void *)(a1 + 88);
  }
  cva::adp::PListPath::convertToPath((unint64_t *)v42, (uint64_t)v46);
  if (v47 >= 0) {
    id v9 = (const std::string::value_type *)v46;
  }
  else {
    id v9 = (const std::string::value_type *)v46[0];
  }
  if (v47 >= 0) {
    std::string::size_type v10 = v47;
  }
  else {
    std::string::size_type v10 = (std::string::size_type)v46[1];
  }
  std::string::append(&v43, v9, v10);
  if (v47 < 0) {
    operator delete(v46[0]);
  }
  memset(v42, 0, 24);
  if (!cva::adp::io::PListSerializer::getKeys(v5, &__dst, (void **)v42))
  {
    int v12 = 0;
    goto LABEL_65;
  }
  long long __p = 0;
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  if (!cva::adp::io::PListSerializer::getKeys(v5, &v43, &__p))
  {
    int v12 = 0;
    id v21 = (void **)__p;
    if (!__p) {
      goto LABEL_65;
    }
    goto LABEL_59;
  }
  uint64_t v37 = 0;
  uint64_t v38 = 0;
  id v11 = &v37;
  uint64_t v36 = &v37;
  char v47 = 6;
  strcpy((char *)v46, "Camera");
  int v12 = cva::adp::io::detail::keysToNames(v5, (const void **)&__dst.__r_.__value_.__l.__data_, v42, (uint64_t)v46, (uint64_t **)&v36);
  if (v47 < 0) {
    operator delete(v46[0]);
  }
  if (v12)
  {
    uint64_t v34 = 0;
    size_t __sz = 0;
    id v33 = (uint64_t *)&v34;
    char v47 = 8;
    strcpy((char *)v46, "Platform");
    int v12 = 0;
    if (cva::adp::io::detail::createFromToTree(&v36, (uint64_t *)&__p, (unsigned __int8 *)v46, &v33))
    {
      id v13 = v37;
      if (v37)
      {
        while (1)
        {
          while (1)
          {
            unint64_t v14 = (uint64_t **)v13;
            unint64_t v15 = v13[4];
            if (v15 < 0x100) {
              break;
            }
            id v13 = *v14;
            id v11 = v14;
            if (!*v14) {
              goto LABEL_39;
            }
          }
          if (v15 == 255) {
            break;
          }
          id v13 = v14[1];
          if (!v13)
          {
            id v11 = v14 + 1;
            goto LABEL_39;
          }
        }
      }
      else
      {
        unint64_t v14 = &v37;
LABEL_39:
        uint64_t v16 = (uint64_t *)v14;
        unint64_t v14 = (uint64_t **)operator new(0x40uLL);
        _OWORD v14[4] = (uint64_t *)255;
        v14[5] = 0;
        v14[6] = 0;
        v14[7] = 0;
        void *v14 = 0;
        v14[1] = 0;
        void v14[2] = v16;
        void *v11 = (uint64_t *)v14;
        uint64_t v17 = (uint64_t *)v14;
        if (*v36)
        {
          uint64_t v36 = (uint64_t **)*v36;
          uint64_t v17 = *v11;
        }
        sub_2153CF298(v37, v17);
        ++v38;
      }
      MEMORY[0x2166B9470](v14 + 5, "Platform");
      uint64_t v18 = (void **)operator new(0x40uLL);
      void *v18 = &unk_26C5FBF18;
      v18[1] = &v36;
      void v18[2] = v5;
      v18[3] = &__dst;
      double v18[4] = &v33;
      v18[5] = &v43;
      v18[6] = (void *)a1;
      v18[7] = v46;
      uint64_t v48 = v18;
      long long v30 = 0;
      unint64_t v31 = 0;
      BOOL v32 = 0;
      size_t v19 = __sz;
      if (__sz)
      {
        if ((__sz & 0x8000000000000000) != 0) {
          abort();
        }
        long long v30 = (char *)operator new(__sz);
        unint64_t v31 = (unint64_t)v30;
        BOOL v32 = &v30[v19];
      }
      cva::adp::io::detail::findChildNodes(&v33, 255, (unint64_t *)&v30);
      size_t v20 = v30;
      if (v30 == (char *)v31)
      {
        int v12 = 0;
      }
      else
      {
        char v45 = -1;
        if (!v48)
        {
          int v29 = (void *)sub_2153E5390();
          sub_2153E770C(v29);
          return;
        }
        int v12 = (*((uint64_t (**)(void **, char **, char *))*v48 + 6))(v48, &v30, &v45);
        size_t v20 = v30;
      }
      if (v20)
      {
        unint64_t v31 = (unint64_t)v20;
        operator delete(v20);
      }
      if (v48 == v46)
      {
        (*((void (**)(void **))v46[0] + 4))(v46);
      }
      else if (v48)
      {
        (*((void (**)(void))*v48 + 5))();
      }
    }
    sub_2153E770C(v34);
  }
  sub_2153CF0DC((char *)v37);
  id v21 = (void **)__p;
  if (__p)
  {
LABEL_59:
    for (uint64_t i = v40; i != v21; i -= 3)
    {
      if (*((char *)i - 1) < 0) {
        operator delete(*(i - 3));
      }
    }
    operator delete(v21);
  }
LABEL_65:
  int v23 = (std::string *)v42[0];
  if (v42[0])
  {
    for (uint64_t j = v42[1]; j != v23; --j)
    {
      if (SHIBYTE(j[-1].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(j[-1].__r_.__value_.__l.__data_);
      }
    }
    operator delete(v23);
  }
  if ((SHIBYTE(v43.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_74;
    }
LABEL_85:
    operator delete(__dst.__r_.__value_.__l.__data_);
    if (!v12) {
      return;
    }
    goto LABEL_75;
  }
  operator delete(v43.__r_.__value_.__l.__data_);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_85;
  }
LABEL_74:
  if (!v12) {
    return;
  }
LABEL_75:
  char v47 = 7;
  strcpy((char *)v46, "Version");
  __dst.__r_.__value_.__r.__words[0] = 0;
  int v25 = sub_2153C9660(v5, (std::string *)(a1 + 72), (uint64_t)v46);
  std::string::size_type v26 = __dst.__r_.__value_.__r.__words[0];
  if (!v25) {
    std::string::size_type v26 = 0x100000000;
  }
  *(void *)(a1 + 24) = v26;
  if (v47 < 0) {
    operator delete(v46[0]);
  }
  char v47 = 6;
  strcpy((char *)v46, "Device");
  uint64_t v27 = a1 + 32;
  char v28 = cva::adp::io::PListSerializer::getItem<std::string>(v5, v6, (uint64_t)v46);
  if (v47 < 0) {
    operator delete(v46[0]);
  }
  if ((v28 & 1) == 0) {
    MEMORY[0x2166B9470](v27, "Generic Device");
  }
}

void sub_2153E770C(void *a1)
{
  if (a1)
  {
    sub_2153E770C(*a1);
    sub_2153E770C(a1[1]);
    operator delete(a1);
  }
}

uint64_t sub_2153E7758(void *a1, unsigned __int8 **a2)
{
  if (*a2 != a2[1])
  {
    CFAllocatorRef v64 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    CFAllocatorRef v63 = (const __CFAllocator *)*MEMORY[0x263EFFB28];
    int32x2_t v2 = vdup_n_s32(0x3FC90FDBu);
    uint64_t v3 = a1[1];
    id v6 = *(void **)(v3 + 8);
    uint64_t v4 = (void *)(v3 + 8);
    id v5 = v6;
    if (!v6) {
      goto LABEL_13;
    }
    unint64_t v7 = **a2;
    std::string::size_type v8 = v4;
    do
    {
      unint64_t v9 = v5[4];
      BOOL v10 = v9 >= v7;
      if (v9 >= v7) {
        id v11 = v5;
      }
      else {
        id v11 = v5 + 1;
      }
      if (v10) {
        std::string::size_type v8 = v5;
      }
      id v5 = (void *)*v11;
    }
    while (*v11);
    if (v8 == v4 || v8[4] > v7) {
LABEL_13:
    }
      std::string::size_type v8 = v4;
    int v12 = (std::string::size_type *)a1[2];
    uint64_t v13 = a1[3];
    if (*(char *)(v13 + 23) < 0)
    {
      sub_2153C0AE4(&__dst, *(void **)v13, *(void *)(v13 + 8));
    }
    else
    {
      long long v14 = *(_OWORD *)v13;
      __dst.__r_.__value_.__r.__words[2] = *(void *)(v13 + 16);
      *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v14;
    }
    __s = v8 + 5;
    cva::adp::PListPath::convertToPath(v8 + 5, (uint64_t)__p);
    if (__p[23] >= 0) {
      unint64_t v15 = __p;
    }
    else {
      unint64_t v15 = *(const std::string::value_type **)__p;
    }
    if (__p[23] >= 0) {
      std::string::size_type v16 = __p[23];
    }
    else {
      std::string::size_type v16 = *(void *)&__p[8];
    }
    std::string::append(&__dst, v15, v16);
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
    int v74 = 0;
    v72[1] = 0;
    v72[0] = 0;
    uint64_t v73 = 0;
    __p[23] = 12;
    strcpy(__p, "Camera Model");
    if (!cva::adp::io::PListSerializer::getItem<std::string>(v12, &__dst, (uint64_t)__p))
    {
      if ((__p[23] & 0x80000000) != 0) {
        operator delete(*(void **)__p);
      }
LABEL_46:
      if (SHIBYTE(v73) < 0)
      {
        operator delete(v72[0]);
        if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          return 0;
        }
      }
      else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
        return 0;
      }
      operator delete(__dst.__r_.__value_.__l.__data_);
      return 0;
    }
    char v17 = sub_2153EDE90((int **)v72, &v74);
    char v18 = v17;
    if ((__p[23] & 0x80000000) != 0)
    {
      operator delete(*(void **)__p);
      if ((v18 & 1) == 0) {
        goto LABEL_46;
      }
    }
    else if ((v17 & 1) == 0)
    {
      goto LABEL_46;
    }
    int v71 = 1065353216;
    __p[23] = 18;
    strcpy(__p, "Standard Deviation");
    cva::adp::io::PListSerializer::getItem<float>(v12, &__dst, (uint64_t)__p, &v71);
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
    switch(v74)
    {
      case 0:
        *(_DWORD *)long long __p = 1065353216;
        __p[4] = 1;
        *(_DWORD *)&__p[8] = 1065353216;
        __p[12] = 1;
        *(void *)&__p[16] = 0;
        char v67 = 1;
        long long v68 = xmmword_215445ED0;
        uint64_t v69 = 0x200000002;
        if (sub_2153EE0BC(v12, v13, __s, (uint64_t)__p)) {
          operator new();
        }
        goto LABEL_46;
      case 1:
        *(_DWORD *)long long __p = 1065353216;
        __p[4] = 1;
        *(_DWORD *)&__p[8] = 1065353216;
        __p[12] = 1;
        *(void *)&__p[16] = 0;
        char v67 = 1;
        long long v68 = xmmword_215445ED0;
        uint64_t v69 = 0x200000002;
        *(_OWORD *)&v82.__r_.__value_.__l.__data_ = 0uLL;
        v82.__r_.__value_.__s.__data_[16] = 1;
        HIDWORD(v82.__r_.__value_.__r.__words[2]) = 1070141403;
        *(void *)long long v83 = 0xA00000000;
        if (!sub_2153EE0BC(v12, v13, __s, (uint64_t)__p)) {
          goto LABEL_46;
        }
        if (*(char *)(v13 + 23) < 0)
        {
          sub_2153C0AE4(&v86, *(void **)v13, *(void *)(v13 + 8));
        }
        else
        {
          long long v19 = *(_OWORD *)v13;
          v86.__r_.__value_.__r.__words[2] = *(void *)(v13 + 16);
          *(_OWORD *)&v86.__r_.__value_.__l.__data_ = v19;
        }
        cva::adp::PListPath::convertToPath(__s, (uint64_t)v88);
        if ((SBYTE7(v88[1]) & 0x80u) == 0) {
          int v23 = (const std::string::value_type *)v88;
        }
        else {
          int v23 = *(const std::string::value_type **)&v88[0];
        }
        if ((SBYTE7(v88[1]) & 0x80u) == 0) {
          std::string::size_type v24 = BYTE7(v88[1]);
        }
        else {
          std::string::size_type v24 = *((void *)&v88[0] + 1);
        }
        std::string::append(&v86, v23, v24);
        if (SBYTE7(v88[1]) < 0) {
          operator delete(*(void **)&v88[0]);
        }
        int v25 = (char *)operator new(0x20uLL);
        v87.__r_.__value_.__r.__words[0] = (std::string::size_type)v25;
        *(_OWORD *)&v87.__r_.__value_.__r.__words[1] = xmmword_215445EE0;
        strcpy(v25, "Kannala Radial Distortion");
        if (SHIBYTE(v86.__r_.__value_.__r.__words[2]) < 0) {
          sub_2153C0AE4(&__s1, v86.__r_.__value_.__l.__data_, v86.__r_.__value_.__l.__size_);
        }
        else {
          std::string __s1 = v86;
        }
        cva::adp::PListPath::convertToPath((unint64_t *)&v87, (uint64_t)v88);
        if ((SBYTE7(v88[1]) & 0x80u) == 0) {
          long long v30 = (const std::string::value_type *)v88;
        }
        else {
          long long v30 = *(const std::string::value_type **)&v88[0];
        }
        if ((SBYTE7(v88[1]) & 0x80u) == 0) {
          std::string::size_type v31 = BYTE7(v88[1]);
        }
        else {
          std::string::size_type v31 = *((void *)&v88[0] + 1);
        }
        std::string::append(&__s1, v30, v31);
        if (SBYTE7(v88[1]) < 0) {
          operator delete(*(void **)&v88[0]);
        }
        operator delete(v25);
        *((unsigned char *)&v81.__r_.__value_.__s + 23) = 16;
        strcpy((char *)&v81, "Symmetric Radial");
        if (SHIBYTE(__s1.__r_.__value_.__r.__words[2]) < 0) {
          sub_2153C0AE4(&v87, __s1.__r_.__value_.__l.__data_, __s1.__r_.__value_.__l.__size_);
        }
        else {
          std::string v87 = __s1;
        }
        cva::adp::PListPath::convertToPath((unint64_t *)&v81, (uint64_t)v88);
        if ((SBYTE7(v88[1]) & 0x80u) == 0) {
          uint64_t v46 = (const std::string::value_type *)v88;
        }
        else {
          uint64_t v46 = *(const std::string::value_type **)&v88[0];
        }
        if ((SBYTE7(v88[1]) & 0x80u) == 0) {
          std::string::size_type v47 = BYTE7(v88[1]);
        }
        else {
          std::string::size_type v47 = *((void *)&v88[0] + 1);
        }
        std::string::append(&v87, v46, v47);
        if (SBYTE7(v88[1]) < 0) {
          operator delete(*(void **)&v88[0]);
        }
        BYTE7(v88[1]) = 4;
        strcpy((char *)v88, "Data");
        int v48 = sub_2153F1A10(v12, &v87, (uint64_t)v88);
        int v49 = v48;
        if (SBYTE7(v88[1]) < 0)
        {
          operator delete(*(void **)&v88[0]);
          if (v49)
          {
LABEL_145:
            BYTE7(v88[1]) = 5;
            strcpy((char *)v88, "Fixed");
            int v50 = cva::adp::io::PListSerializer::getItem<BOOL>(v12, &v87, (uint64_t)v88, &v82.__r_.__value_.__s.__data_[16]);
            if (SBYTE7(v88[1]) < 0) {
              operator delete(*(void **)&v88[0]);
            }
            std::string::value_type v51 = v82.__r_.__value_.__s.__data_[16] ^ 1;
            if (!v50) {
              std::string::value_type v51 = 1;
            }
            v82.__r_.__value_.__s.__data_[16] = v51;
            if (SHIBYTE(v87.__r_.__value_.__r.__words[2]) < 0)
            {
LABEL_150:
              operator delete(v87.__r_.__value_.__l.__data_);
              if (v49)
              {
LABEL_183:
                *((unsigned char *)&v87.__r_.__value_.__s + 23) = 16;
                strcpy((char *)&v87, "Projection Model");
                memset(v88, 0, 24);
                char v59 = 0;
                if (cva::adp::io::PListSerializer::getItem<std::string>(v12, &v86, (uint64_t)&v87))
                {
                  char v59 = sub_2153F18B8((uint64_t **)v88, v83);
                  if (SBYTE7(v88[1]) < 0) {
                    goto LABEL_185;
                  }
                }
                else if (SBYTE7(v88[1]) < 0)
                {
LABEL_185:
                  operator delete(*(void **)&v88[0]);
                  if (SHIBYTE(v87.__r_.__value_.__r.__words[2]) < 0) {
                    goto LABEL_186;
                  }
                  goto LABEL_190;
                }
                if (SHIBYTE(v87.__r_.__value_.__r.__words[2]) < 0)
                {
LABEL_186:
                  operator delete(v87.__r_.__value_.__l.__data_);
                  if (v59)
                  {
LABEL_192:
                    BYTE7(v88[1]) = 13;
                    strcpy((char *)v88, "Field of View");
                    char v60 = cva::adp::io::PListSerializer::getItem<float>(v12, &__s1, (uint64_t)v88, (_DWORD *)&v82.__r_.__value_.__r.__words[2] + 1);
                    char v61 = v60;
                    if (SBYTE7(v88[1]) < 0)
                    {
                      operator delete(*(void **)&v88[0]);
                      if (v61)
                      {
LABEL_194:
                        if ((SHIBYTE(__s1.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                          goto LABEL_195;
                        }
                        goto LABEL_199;
                      }
                    }
                    else if (v60)
                    {
                      goto LABEL_194;
                    }
                    HIDWORD(v82.__r_.__value_.__r.__words[2]) = 1070141403;
                    if ((SHIBYTE(__s1.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                    {
LABEL_195:
                      if ((SHIBYTE(v86.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                        goto LABEL_196;
                      }
LABEL_200:
                      operator delete(v86.__r_.__value_.__l.__data_);
LABEL_196:
                      operator new();
                    }
LABEL_199:
                    operator delete(__s1.__r_.__value_.__l.__data_);
                    if ((SHIBYTE(v86.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                      goto LABEL_196;
                    }
                    goto LABEL_200;
                  }
LABEL_191:
                  *(_DWORD *)long long v83 = 0;
                  goto LABEL_192;
                }
LABEL_190:
                if (v59) {
                  goto LABEL_192;
                }
                goto LABEL_191;
              }
LABEL_182:
              *(_OWORD *)&v82.__r_.__value_.__l.__data_ = 0uLL;
              v82.__r_.__value_.__s.__data_[16] = 1;
              goto LABEL_183;
            }
LABEL_181:
            if (v49) {
              goto LABEL_183;
            }
            goto LABEL_182;
          }
        }
        else if (v48)
        {
          goto LABEL_145;
        }
        if (SHIBYTE(v87.__r_.__value_.__r.__words[2]) < 0) {
          goto LABEL_150;
        }
        goto LABEL_181;
      case 2:
        *(_DWORD *)long long __p = 1065353216;
        __p[4] = 1;
        *(_DWORD *)&__p[8] = 1065353216;
        __p[12] = 1;
        *(void *)&__p[16] = 0;
        char v67 = 1;
        long long v68 = xmmword_215445ED0;
        uint64_t v69 = 0x200000002;
        memset(&v82, 0, 20);
        v82.__r_.__value_.__s.__data_[20] = 1;
        *(_DWORD *)long long v83 = 10;
        if (!sub_2153EE0BC(v12, v13, __s, (uint64_t)__p)) {
          goto LABEL_46;
        }
        if (*(char *)(v13 + 23) < 0)
        {
          sub_2153C0AE4(&__s1, *(void **)v13, *(void *)(v13 + 8));
        }
        else
        {
          long long v20 = *(_OWORD *)v13;
          __s1.__r_.__value_.__r.__words[2] = *(void *)(v13 + 16);
          *(_OWORD *)&__s1.__r_.__value_.__l.__data_ = v20;
        }
        cva::adp::PListPath::convertToPath(__s, (uint64_t)v88);
        if ((SBYTE7(v88[1]) & 0x80u) == 0) {
          std::string::size_type v26 = (const std::string::value_type *)v88;
        }
        else {
          std::string::size_type v26 = *(const std::string::value_type **)&v88[0];
        }
        if ((SBYTE7(v88[1]) & 0x80u) == 0) {
          std::string::size_type v27 = BYTE7(v88[1]);
        }
        else {
          std::string::size_type v27 = *((void *)&v88[0] + 1);
        }
        std::string::append(&__s1, v26, v27);
        if (SBYTE7(v88[1]) < 0) {
          operator delete(*(void **)&v88[0]);
        }
        *((unsigned char *)&v87.__r_.__value_.__s + 23) = 19;
        strcpy((char *)&v87, "Heikkila Distortion");
        if (SHIBYTE(__s1.__r_.__value_.__r.__words[2]) < 0) {
          sub_2153C0AE4(&v81, __s1.__r_.__value_.__l.__data_, __s1.__r_.__value_.__l.__size_);
        }
        else {
          std::string v81 = __s1;
        }
        cva::adp::PListPath::convertToPath((unint64_t *)&v87, (uint64_t)v88);
        if ((SBYTE7(v88[1]) & 0x80u) == 0) {
          BOOL v32 = (const std::string::value_type *)v88;
        }
        else {
          BOOL v32 = *(const std::string::value_type **)&v88[0];
        }
        if ((SBYTE7(v88[1]) & 0x80u) == 0) {
          std::string::size_type v33 = BYTE7(v88[1]);
        }
        else {
          std::string::size_type v33 = *((void *)&v88[0] + 1);
        }
        std::string::append(&v81, v32, v33);
        if (SBYTE7(v88[1]) < 0) {
          operator delete(*(void **)&v88[0]);
        }
        HIBYTE(v80[2]) = 21;
        strcpy((char *)v80, "Radial And Tangential");
        if (SHIBYTE(v81.__r_.__value_.__r.__words[2]) < 0) {
          sub_2153C0AE4(&v87, v81.__r_.__value_.__l.__data_, v81.__r_.__value_.__l.__size_);
        }
        else {
          std::string v87 = v81;
        }
        cva::adp::PListPath::convertToPath(v80, (uint64_t)v88);
        if ((SBYTE7(v88[1]) & 0x80u) == 0) {
          long long v52 = (const std::string::value_type *)v88;
        }
        else {
          long long v52 = *(const std::string::value_type **)&v88[0];
        }
        if ((SBYTE7(v88[1]) & 0x80u) == 0) {
          std::string::size_type v53 = BYTE7(v88[1]);
        }
        else {
          std::string::size_type v53 = *((void *)&v88[0] + 1);
        }
        std::string::append(&v87, v52, v53);
        if (SBYTE7(v88[1]) < 0) {
          operator delete(*(void **)&v88[0]);
        }
        *((unsigned char *)&v86.__r_.__value_.__s + 23) = 4;
        strcpy((char *)&v86, "Data");
        cva::adp::io::PListSerializer::getPath(v12, &v87, &v78);
        std::string::size_type v54 = v78;
        if (v78)
        {
          double v55 = (v86.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
              ? &v86
              : (std::string *)v86.__r_.__value_.__r.__words[0];
          CFStringRef v56 = CFStringCreateWithCStringNoCopy(v64, (const char *)v55, 0x8000100u, v63);
          double v57 = (const void *)[*(id *)v54 objectForKey:v56];
          char v58 = *(unsigned char *)(v54 + 8);
          CFTypeRef cf = v57;
          char v77 = v58;
          if (v57) {
            CFRetain(v57);
          }
          else {
            char v77 = 0;
          }
          CFRelease(v56);
          if (cf)
          {
            if (cva::ItemHandler::isVectorType(&cf))
            {
              memset(v88, 0, 20);
              sub_2153E9F70();
            }
            if (cf) {
              CFRelease(cf);
            }
          }
        }
        int v62 = v79;
        if (v79 && !atomic_fetch_add(&v79->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v62->__on_zero_shared)(v62);
          std::__shared_weak_count::__release_weak(v62);
          if ((SHIBYTE(v86.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
LABEL_215:
            if (SHIBYTE(v87.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v87.__r_.__value_.__l.__data_);
            }
            memset(&v82, 0, 20);
            v82.__r_.__value_.__s.__data_[20] = 1;
            if (SHIBYTE(v81.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v81.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(__s1.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__s1.__r_.__value_.__l.__data_);
            }
            operator new();
          }
        }
        else if ((SHIBYTE(v86.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
          goto LABEL_215;
        }
        operator delete(v86.__r_.__value_.__l.__data_);
        goto LABEL_215;
      case 3:
        LODWORD(v82.__r_.__value_.__l.__data_) = 1065353216;
        v82.__r_.__value_.__s.__data_[4] = 1;
        LODWORD(v82.__r_.__value_.__r.__words[1]) = 1065353216;
        v82.__r_.__value_.__s.__data_[12] = 1;
        v82.__r_.__value_.__r.__words[2] = 0;
        v83[0] = 1;
        *(_OWORD *)&v83[4] = xmmword_215445ED0;
        uint64_t v84 = 0x200000002;
        *(int32x2_t *)long long __p = v2;
        *(void *)&__p[8] = 0;
        memset_pattern16(&__p[16], &unk_215445FE0, 0x400uLL);
        memset_pattern16(v70, &unk_215445FE0, 0x400uLL);
        if (!sub_2153EE0BC(v12, v13, __s, (uint64_t)&v82)) {
          goto LABEL_46;
        }
        if (*(char *)(v13 + 23) < 0)
        {
          sub_2153C0AE4(&v87, *(void **)v13, *(void *)(v13 + 8));
        }
        else
        {
          long long v21 = *(_OWORD *)v13;
          v87.__r_.__value_.__r.__words[2] = *(void *)(v13 + 16);
          *(_OWORD *)&v87.__r_.__value_.__l.__data_ = v21;
        }
        cva::adp::PListPath::convertToPath(__s, (uint64_t)v88);
        if ((SBYTE7(v88[1]) & 0x80u) == 0) {
          char v28 = (const std::string::value_type *)v88;
        }
        else {
          char v28 = *(const std::string::value_type **)&v88[0];
        }
        if ((SBYTE7(v88[1]) & 0x80u) == 0) {
          std::string::size_type v29 = BYTE7(v88[1]);
        }
        else {
          std::string::size_type v29 = *((void *)&v88[0] + 1);
        }
        std::string::append(&v87, v28, v29);
        if (SBYTE7(v88[1]) < 0) {
          operator delete(*(void **)&v88[0]);
        }
        strcpy((char *)&__s1, "Pinhole LUT Distortion");
        *((unsigned char *)&__s1.__r_.__value_.__s + 23) = 22;
        if (SHIBYTE(v87.__r_.__value_.__r.__words[2]) < 0) {
          sub_2153C0AE4(&v86, v87.__r_.__value_.__l.__data_, v87.__r_.__value_.__l.__size_);
        }
        else {
          std::string v86 = v87;
        }
        cva::adp::PListPath::convertToPath((unint64_t *)&__s1, (uint64_t)v88);
        if ((SBYTE7(v88[1]) & 0x80u) == 0) {
          uint64_t v34 = (const std::string::value_type *)v88;
        }
        else {
          uint64_t v34 = *(const std::string::value_type **)&v88[0];
        }
        if ((SBYTE7(v88[1]) & 0x80u) == 0) {
          std::string::size_type v35 = BYTE7(v88[1]);
        }
        else {
          std::string::size_type v35 = *((void *)&v88[0] + 1);
        }
        std::string::append(&v86, v34, v35);
        if (SBYTE7(v88[1]) < 0) {
          operator delete(*(void **)&v88[0]);
        }
        BYTE7(v88[1]) = 7;
        strcpy((char *)v88, "Distort");
        char v36 = sub_2153EFB18(v12, &v86, (uint64_t)v88);
        char v37 = v36;
        if (SBYTE7(v88[1]) < 0)
        {
          operator delete(*(void **)&v88[0]);
          if (v37)
          {
LABEL_120:
            BYTE7(v88[1]) = 13;
            strcpy((char *)v88, "Field Of View");
            char v38 = cva::adp::io::PListSerializer::getItem<float>(v12, &v86, (uint64_t)v88, __p);
            char v39 = v38;
            if (SBYTE7(v88[1]) < 0)
            {
              operator delete(*(void **)&v88[0]);
              if (v39)
              {
LABEL_123:
                BYTE7(v88[1]) = 9;
                strcpy((char *)v88, "Undistort");
                char v40 = sub_2153EFB18(v12, &v86, (uint64_t)v88);
                char v41 = v40;
                if (SBYTE7(v88[1]) < 0)
                {
                  operator delete(*(void **)&v88[0]);
                  if (v41)
                  {
LABEL_126:
                    BYTE7(v88[1]) = 21;
                    strcpy((char *)v88, "Inverse Field Of View");
                    char v42 = cva::adp::io::PListSerializer::getItem<float>(v12, &v86, (uint64_t)v88, &__p[4]);
                    char v43 = v42;
                    if (SBYTE7(v88[1]) < 0)
                    {
                      operator delete(*(void **)&v88[0]);
                      if (v43)
                      {
LABEL_129:
                        BYTE7(v88[1]) = 17;
                        strcpy((char *)v88, "Distortion Center");
                        char v44 = sub_2153EFDD4(v12, &v86, (uint64_t)v88);
                        char v45 = v44;
                        if (SBYTE7(v88[1]) < 0)
                        {
                          operator delete(*(void **)&v88[0]);
                          if (v45)
                          {
LABEL_131:
                            if ((SHIBYTE(v86.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                              goto LABEL_132;
                            }
                            goto LABEL_177;
                          }
                        }
                        else if (v44)
                        {
                          goto LABEL_131;
                        }
                        *(void *)&__p[8] = 0;
                        if ((SHIBYTE(v86.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                        {
LABEL_132:
                          if ((SHIBYTE(v87.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                            goto LABEL_133;
                          }
LABEL_178:
                          operator delete(v87.__r_.__value_.__l.__data_);
LABEL_133:
                          operator new();
                        }
LABEL_177:
                        operator delete(v86.__r_.__value_.__l.__data_);
                        if ((SHIBYTE(v87.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                          goto LABEL_133;
                        }
                        goto LABEL_178;
                      }
                    }
                    else if (v42)
                    {
                      goto LABEL_129;
                    }
                    *(_DWORD *)&__p[4] = 1070141403;
                    goto LABEL_129;
                  }
                }
                else if (v40)
                {
                  goto LABEL_126;
                }
                memset_pattern16(v70, &unk_215445FE0, 0x400uLL);
                goto LABEL_126;
              }
            }
            else if (v38)
            {
              goto LABEL_123;
            }
            *(_DWORD *)long long __p = 1070141403;
            goto LABEL_123;
          }
        }
        else if (v36)
        {
          goto LABEL_120;
        }
        memset_pattern16(&__p[16], &unk_215445FE0, 0x400uLL);
        goto LABEL_120;
      default:
        goto LABEL_46;
    }
  }
  return 1;
}

uint64_t sub_2153E9A74(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_2153E9AA4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2166B9890);
}

uint64_t sub_2153E9AE0(uint64_t result, char a2)
{
  *(unsigned char *)(result + 12) = a2;
  *(unsigned char *)(result + 20) = a2;
  return result;
}

uint64_t sub_2153E9AEC(uint64_t a1, uint64_t a2, float a3)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a2 + 16))(a2) != 1) {
    return 0;
  }
  unint64_t v7 = *(float **)(a1 + 24);
  id v6 = *(float **)(a1 + 32);
  if (v7 == v6) {
    return 0;
  }
  if (*v7 <= a3)
  {
    std::string::size_type v8 = v7 + 3;
    do
    {
      unint64_t v9 = v8;
      if (v8 == v6) {
        break;
      }
      v8 += 3;
    }
    while (*v9 <= a3);
    unint64_t v7 = v9 - 3;
  }
  *(float *)(a2 + 116) = (float)(v7[1] * *(float *)(a1 + 8)) + *(float *)(a1 + 16);
  uint64_t result = 1;
  *(unsigned char *)(a2 + 120) = 1;
  return result;
}

uint64_t sub_2153E9BB0()
{
  return 0;
}

void sub_2153E9BB8(void *a1)
{
  *a1 = &unk_26C5FBA50;
  int32x2_t v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2166B9890);
}

void *sub_2153E9C28(void *a1)
{
  *a1 = &unk_26C5FBA50;
  int32x2_t v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t sub_2153E9C78(std::string::size_type *a1, uint64_t a2, unint64_t *a3, _DWORD *a4)
{
  if (*(char *)(a2 + 23) < 0) {
    sub_2153C0AE4(&__dst, *(void **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string __dst = *(std::string *)a2;
  }
  cva::adp::PListPath::convertToPath(a3, (uint64_t)__p);
  if (v17 >= 0) {
    unint64_t v7 = __p;
  }
  else {
    unint64_t v7 = (void **)__p[0];
  }
  if (v17 >= 0) {
    std::string::size_type v8 = v17;
  }
  else {
    std::string::size_type v8 = (std::string::size_type)__p[1];
  }
  std::string::append(&__dst, (const std::string::value_type *)v7, v8);
  if (v17 < 0) {
    operator delete(__p[0]);
  }
  char v17 = 4;
  strcpy((char *)__p, "Data");
  uint64_t v9 = sub_2153E9DE8(a1, &__dst, (uint64_t)__p);
  uint64_t v10 = v9;
  if (v17 < 0)
  {
    operator delete(__p[0]);
    if (!v10)
    {
LABEL_14:
      if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        return v10;
      }
LABEL_22:
      operator delete(__dst.__r_.__value_.__l.__data_);
      return v10;
    }
  }
  else if (!v9)
  {
    goto LABEL_14;
  }
  *a4 = 0;
  int v12 = (char *)(a4 + 1);
  char v17 = 5;
  strcpy((char *)__p, "Fixed");
  int v13 = cva::adp::io::PListSerializer::getItem<BOOL>(a1, &__dst, (uint64_t)__p, v12);
  if (v17 < 0) {
    operator delete(__p[0]);
  }
  char v14 = *v12 ^ 1;
  if (!v13) {
    char v14 = 1;
  }
  char *v12 = v14;
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_22;
  }
  return v10;
}

uint64_t sub_2153E9DE8(std::string::size_type *a1, std::string *a2, uint64_t a3)
{
  cva::adp::io::PListSerializer::getPath(a1, a2, &v15);
  std::string::size_type v4 = v15;
  if (v15)
  {
    if (*(char *)(a3 + 23) >= 0) {
      id v5 = (const char *)a3;
    }
    else {
      id v5 = *(const char **)a3;
    }
    CFStringRef v6 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v5, 0x8000100u, (CFAllocatorRef)*MEMORY[0x263EFFB28]);
    CFStringRef v7 = (const __CFString *)[*(id *)v4 objectForKey:v6];
    CFStringRef v8 = v7;
    char v9 = *(unsigned char *)(v4 + 8);
    CFTypeRef cf = v7;
    char v14 = v9;
    if (v7)
    {
      CFRetain(v7);
      CFRelease(v6);
      if (cva::ItemHandler::isVectorType(&cf)) {
        sub_2153E9F70();
      }
      CFStringRef v10 = v8;
    }
    else
    {
      char v14 = 0;
      CFStringRef v10 = v6;
    }
    CFRelease(v10);
  }
  id v11 = v16;
  if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  return 0;
}

void sub_2153E9F5C(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

void sub_2153E9F70()
{
}

uint64_t sub_2153EA02C(uint64_t __s1, _DWORD *a2)
{
  uint64_t v3 = (const void *)__s1;
  if ((*(char *)(__s1 + 23) & 0x80000000) == 0)
  {
    size_t v4 = *(unsigned __int8 *)(__s1 + 23);
    if (*(unsigned char *)(__s1 + 23) != 6) {
      return __s1;
    }
    std::string __s1 = memcmp((const void *)__s1, "Static", *(unsigned __int8 *)(__s1 + 23));
    if (__s1)
    {
      std::string __s1 = memcmp(v3, "Linear", v4);
      if (__s1) {
        return __s1;
      }
      goto LABEL_16;
    }
LABEL_17:
    CFStringRef v10 = cva::adp::io::detail::EnumDescription<cva::geo::eExtrinsicsType,void>::names;
    goto LABEL_18;
  }
  if (*(void *)(__s1 + 8) != 6) {
    return __s1;
  }
  id v5 = *(int **)__s1;
  if (**(_DWORD **)__s1 == 1952543827 && *(_WORD *)(*(void *)__s1 + 4) == 25449) {
    goto LABEL_17;
  }
  int v7 = *v5;
  int v8 = *((unsigned __int16 *)v5 + 2);
  if (v7 == 1701734732 && v8 == 29281)
  {
LABEL_16:
    CFStringRef v10 = off_2642418A0;
LABEL_18:
    *a2 = (unint64_t)((char *)v10
                           - (char *)cva::adp::io::detail::EnumDescription<cva::geo::eExtrinsicsType,void>::names) >> 3;
  }
  return __s1;
}

uint64_t sub_2153EA118(std::string::size_type *a1, uint64_t a2, unint64_t *a3, char *a4)
{
  if (*(char *)(a2 + 23) < 0) {
    sub_2153C0AE4(&__dst, *(void **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string __dst = *(std::string *)a2;
  }
  CFStringRef p_p = (const __CFString *)&__p;
  cva::adp::PListPath::convertToPath(a3, (uint64_t)&__p);
  if (v26 >= 0) {
    int v8 = (const std::string::value_type *)&__p;
  }
  else {
    int v8 = (const std::string::value_type *)__p;
  }
  if (v26 >= 0) {
    std::string::size_type v9 = v26;
  }
  else {
    std::string::size_type v9 = v24;
  }
  std::string::append(&__dst, v8, v9);
  if (v26 < 0) {
    operator delete(__p);
  }
  char v21 = 4;
  strcpy(cStr, "Data");
  cva::adp::io::PListSerializer::getPath(a1, &__dst, &v29);
  std::string::size_type v10 = v29;
  if (v29)
  {
    CFStringRef v11 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], cStr, 0x8000100u, (CFAllocatorRef)*MEMORY[0x263EFFB28]);
    int v12 = (void **)[*(id *)v10 objectForKey:v11];
    CFStringRef p_p = (const __CFString *)v12;
    char v13 = *(unsigned char *)(v10 + 8);
    CFTypeRef cf = v12;
    char v28 = v13;
    if (v12)
    {
      CFRetain(v12);
      CFRelease(v11);
      if (cva::ItemHandler::isVectorType(&cf))
      {
        long long __p = 0;
        std::string::size_type v24 = 0;
        int v25 = 0;
        sub_2153E9F70();
      }
      CFStringRef v14 = p_p;
    }
    else
    {
      char v28 = 0;
      CFStringRef v14 = v11;
    }
    CFRelease(v14);
    LODWORD(v10) = 0;
  }
  std::string::size_type v15 = v30;
  if (v30 && !atomic_fetch_add(&v30->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  int v16 = p_p & v10;
  if (v21 < 0)
  {
    operator delete(*(void **)cStr);
    if (!v16)
    {
LABEL_24:
      if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        return p_p & v10;
      }
LABEL_32:
      operator delete(__dst.__r_.__value_.__l.__data_);
      return p_p & v10;
    }
  }
  else if (!v16)
  {
    goto LABEL_24;
  }
  char v26 = 5;
  strcpy((char *)&__p, "Fixed");
  int v18 = cva::adp::io::PListSerializer::getItem<BOOL>(a1, &__dst, (uint64_t)&__p, a4);
  if (v26 < 0) {
    operator delete(__p);
  }
  char v19 = *a4 ^ 1;
  if (!v18) {
    char v19 = 1;
  }
  *a4 = v19;
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_32;
  }
  return p_p & v10;
}

void sub_2153EA3EC(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_2153EA400(std::string::size_type *a1, uint64_t a2, unint64_t *a3, uint64_t a4)
{
  if (*(char *)(a2 + 23) < 0) {
    sub_2153C0AE4(&__dst, *(void **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string __dst = *(std::string *)a2;
  }
  CFStringRef p_p = (const __CFString *)&__p;
  cva::adp::PListPath::convertToPath(a3, (uint64_t)&__p);
  if (v27 >= 0) {
    int v8 = (const std::string::value_type *)&__p;
  }
  else {
    int v8 = (const std::string::value_type *)__p;
  }
  if (v27 >= 0) {
    std::string::size_type v9 = v27;
  }
  else {
    std::string::size_type v9 = v25;
  }
  std::string::append(&__dst, v8, v9);
  if (v27 < 0) {
    operator delete(__p);
  }
  char v22 = 4;
  strcpy(cStr, "Data");
  cva::adp::io::PListSerializer::getPath(a1, &__dst, &v30);
  std::string::size_type v10 = v30;
  if (v30)
  {
    CFStringRef v11 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], cStr, 0x8000100u, (CFAllocatorRef)*MEMORY[0x263EFFB28]);
    int v12 = (void **)[*(id *)v10 objectForKey:v11];
    CFStringRef p_p = (const __CFString *)v12;
    char v13 = *(unsigned char *)(v10 + 8);
    CFTypeRef cf = v12;
    char v29 = v13;
    if (v12)
    {
      CFRetain(v12);
      CFRelease(v11);
      if (cva::ItemHandler::isVectorType(&cf))
      {
        long long __p = 0;
        std::string::size_type v25 = 0;
        int v26 = 0;
        sub_2153E9F70();
      }
      CFStringRef v14 = p_p;
    }
    else
    {
      char v29 = 0;
      CFStringRef v14 = v11;
    }
    CFRelease(v14);
    LODWORD(v10) = 0;
  }
  std::string::size_type v15 = v31;
  if (v31 && !atomic_fetch_add(&v31->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  int v16 = p_p & v10;
  if (v22 < 0)
  {
    operator delete(*(void **)cStr);
    if (!v16)
    {
LABEL_24:
      if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        return p_p & v10;
      }
LABEL_32:
      operator delete(__dst.__r_.__value_.__l.__data_);
      return p_p & v10;
    }
  }
  else if (!v16)
  {
    goto LABEL_24;
  }
  char v27 = 5;
  strcpy((char *)&__p, "Fixed");
  int v18 = (char *)(a4 + 12);
  int v19 = cva::adp::io::PListSerializer::getItem<BOOL>(a1, &__dst, (uint64_t)&__p, v18);
  if (v27 < 0) {
    operator delete(__p);
  }
  char v20 = *v18 ^ 1;
  if (!v19) {
    char v20 = 1;
  }
  char *v18 = v20;
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_32;
  }
  return p_p & v10;
}

void sub_2153EA6A4(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

__n64 sub_2153EA6B8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(float **)a2;
  if (*(void *)a2 == a1)
  {
    int v9 = 0;
    long long v7 = 0u;
    long long v8 = 0u;
    sub_2153EA6B8(&v7);
    result.n64_u64[0] = v7;
    long long v6 = v8;
    *(_OWORD *)a1 = v7;
    *(_OWORD *)(a1 + 16) = v6;
    *(_DWORD *)(a1 + 32) = v9;
  }
  else
  {
    size_t v4 = **(float ***)(a2 + 8);
    result.n64_u32[1] = 0;
    *(float *)a1 = (float)((float)((float)(*v3 * *v4) + 0.0) + (float)(v3[3] * v4[3])) + (float)(v3[6] * v4[6]);
    *(float *)(a1 + 4) = (float)((float)((float)(v3[1] * *v4) + 0.0) + (float)(v3[4] * v4[3])) + (float)(v3[7] * v4[6]);
    *(float *)(a1 + 8) = (float)((float)((float)(v3[2] * *v4) + 0.0) + (float)(v3[5] * v4[3])) + (float)(v3[8] * v4[6]);
    *(float *)(a1 + 12) = (float)((float)((float)(*v3 * v4[1]) + 0.0) + (float)(v3[3] * v4[4])) + (float)(v3[6] * v4[7]);
    *(float *)(a1 + 16) = (float)((float)((float)(v3[1] * v4[1]) + 0.0) + (float)(v3[4] * v4[4]))
                        + (float)(v3[7] * v4[7]);
    *(float *)(a1 + 20) = (float)((float)((float)(v3[2] * v4[1]) + 0.0) + (float)(v3[5] * v4[4]))
                        + (float)(v3[8] * v4[7]);
    *(float *)(a1 + 24) = (float)((float)((float)(*v3 * v4[2]) + 0.0) + (float)(v3[3] * v4[5])) + (float)(v3[6] * v4[8]);
    *(float *)(a1 + 28) = (float)((float)((float)(v3[1] * v4[2]) + 0.0) + (float)(v3[4] * v4[5]))
                        + (float)(v3[7] * v4[8]);
    result.n64_f32[0] = (float)((float)((float)(v3[2] * v4[2]) + 0.0) + (float)(v3[5] * v4[5])) + (float)(v3[8] * v4[8]);
    *(_DWORD *)(a1 + 32) = result.n64_u32[0];
  }
  return result;
}

BOOL sub_2153EA888(float32x2_t *a1, float32x2_t *a2, float a3)
{
  if ((*(unsigned int (**)(float32x2_t *))(*(void *)a2 + 16))(a2) != 1) {
    return 0;
  }
  char v13 = (char *)&a2[1] + 4;
  CFStringRef v14 = (char *)&a1[1] + 4;
  std::string::size_type v15 = &v13;
  long long v16 = 0u;
  long long v17 = 0u;
  int v18 = 0;
  sub_2153EA6B8((uint64_t)&v16, (uint64_t)&v14);
  long long v10 = v16;
  long long v11 = v17;
  int v12 = v18;
  DWORD2(v16) = 0;
  *(void *)&long long v16 = 0;
  sub_2153C9A50((float32x2_t *)&v10, (float *)&v16);
  if (sqrtf((float)((float)(*(float *)&v16 * *(float *)&v16) + (float)(*((float *)&v16 + 1) * *((float *)&v16 + 1)))+ (float)(*((float *)&v16 + 2) * *((float *)&v16 + 2))) >= a3)return 0; {
  float v6 = a1[7].f32[0] - a2[7].f32[0];
  }
  float32x2_t v7 = vsub_f32(a1[6], a2[6]);
  if (sqrtf(vaddv_f32(vmul_f32(v7, v7)) + (float)(v6 * v6)) >= a3) {
    return 0;
  }
  char v13 = (char *)&a2[8] + 4;
  CFStringRef v14 = (char *)&a1[8] + 4;
  std::string::size_type v15 = &v13;
  long long v16 = 0u;
  long long v17 = 0u;
  int v18 = 0;
  sub_2153EA6B8((uint64_t)&v16, (uint64_t)&v14);
  long long v10 = v16;
  long long v11 = v17;
  int v12 = v18;
  DWORD2(v16) = 0;
  *(void *)&long long v16 = 0;
  sub_2153C9A50((float32x2_t *)&v10, (float *)&v16);
  if (sqrtf((float)((float)(*(float *)&v16 * *(float *)&v16) + (float)(*((float *)&v16 + 1) * *((float *)&v16 + 1)))+ (float)(*((float *)&v16 + 2) * *((float *)&v16 + 2))) >= a3)return 0; {
  if (a1[8].u8[0] == a2[8].u8[0]
  }
    && (float32x2_t v8 = vsub_f32(a1[13], a2[13]), sqrtf(vaddv_f32(vmul_f32(v8, v8))) < a3)
    && a1[14].u8[0] == a2[14].u8[0]
    && (float)(a1[14].f32[1] - a2[14].f32[1]) < a3)
  {
    return (float)(a1[15].f32[1] - a2[15].f32[1]) < a3;
  }
  else
  {
    return 0;
  }
}

uint64_t *sub_2153EAAA4(uint64_t a1, uint64_t *a2)
{
  sub_2153EAEB0((unsigned char *)(a1 + 8), a2);
  sub_2153EAFFC((uint64_t *)(a1 + 48), a2);
  if (*(unsigned char *)(a1 + 64)) {
    size_t v4 = "[FREE]";
  }
  else {
    size_t v4 = "[FIXED]";
  }
  if (*(unsigned char *)(a1 + 64)) {
    size_t v5 = 6;
  }
  else {
    size_t v5 = 7;
  }
  unsigned __int8 v44 = v5;
  memcpy(&__dst, v4, v5);
  *(unsigned char *)((unint64_t)&__dst | v5) = 0;
  if ((v44 & 0x80u) == 0) {
    p_dst = (void **)&__dst;
  }
  else {
    p_dst = __dst;
  }
  if ((v44 & 0x80u) == 0) {
    uint64_t v7 = v44;
  }
  else {
    uint64_t v7 = v43;
  }
  float32x2_t v8 = sub_2153C1168(a2, (uint64_t)p_dst, v7);
  int v9 = sub_2153C1168(v8, (uint64_t)"[", 1);
  char v41 = 14;
  strcpy(__p, "Delta Rotation");
  long long v10 = sub_2153C1168(v9, (uint64_t)__p, 14);
  sub_2153C1168(v10, (uint64_t)"] : ", 4);
  float v39 = 0.0;
  double v38 = 0.0;
  sub_2153C9A50((float32x2_t *)(a1 + 68), (float *)&v38);
  long long v11 = sub_2153EC538(a2, v38, v39);
  sub_2153C1168(v11, (uint64_t)"\n", 1);
  if (v41 < 0)
  {
    operator delete(*(void **)__p);
    if (((char)v44 & 0x80000000) == 0) {
      goto LABEL_15;
    }
  }
  else if (((char)v44 & 0x80000000) == 0)
  {
    goto LABEL_15;
  }
  operator delete(__dst);
LABEL_15:
  if (*(unsigned char *)(a1 + 112)) {
    int v12 = "[FREE]";
  }
  else {
    int v12 = "[FIXED]";
  }
  if (*(unsigned char *)(a1 + 112)) {
    size_t v13 = 6;
  }
  else {
    size_t v13 = 7;
  }
  unsigned __int8 v44 = v13;
  memcpy(&__dst, v12, v13);
  *(unsigned char *)((unint64_t)&__dst | v13) = 0;
  if ((v44 & 0x80u) == 0) {
    CFStringRef v14 = (void **)&__dst;
  }
  else {
    CFStringRef v14 = __dst;
  }
  if ((v44 & 0x80u) == 0) {
    uint64_t v15 = v44;
  }
  else {
    uint64_t v15 = v43;
  }
  long long v16 = sub_2153C1168(a2, (uint64_t)v14, v15);
  long long v17 = sub_2153C1168(v16, (uint64_t)"[", 1);
  char v41 = 17;
  strcpy(__p, "Delta Translation");
  int v18 = sub_2153C1168(v17, (uint64_t)__p, 17);
  int v19 = sub_2153C1168(v18, (uint64_t)"] : ", 4);
  char v20 = sub_2153EBB18(v19, *(double *)(a1 + 104));
  sub_2153C1168(v20, (uint64_t)"\n", 1);
  if (v41 < 0)
  {
    operator delete(*(void **)__p);
    if (((char)v44 & 0x80000000) == 0) {
      goto LABEL_29;
    }
  }
  else if (((char)v44 & 0x80000000) == 0)
  {
    goto LABEL_29;
  }
  operator delete(__dst);
LABEL_29:
  if (*(unsigned char *)(a1 + 120)) {
    char v21 = "[FREE]";
  }
  else {
    char v21 = "[FIXED]";
  }
  if (*(unsigned char *)(a1 + 120)) {
    size_t v22 = 6;
  }
  else {
    size_t v22 = 7;
  }
  unsigned __int8 v44 = v22;
  memcpy(&__dst, v21, v22);
  *(unsigned char *)((unint64_t)&__dst | v22) = 0;
  if ((v44 & 0x80u) == 0) {
    int v23 = (void **)&__dst;
  }
  else {
    int v23 = __dst;
  }
  if ((v44 & 0x80u) == 0) {
    uint64_t v24 = v44;
  }
  else {
    uint64_t v24 = v43;
  }
  std::string::size_type v25 = sub_2153C1168(a2, (uint64_t)v23, v24);
  int v26 = sub_2153C1168(v25, (uint64_t)"[", 1);
  char v41 = 15;
  strcpy(__p, "Linear Position");
  char v27 = sub_2153C1168(v26, (uint64_t)__p, 15);
  sub_2153C1168(v27, (uint64_t)"] : ", 4);
  char v28 = (void *)std::ostream::operator<<();
  sub_2153C1168(v28, (uint64_t)"\n", 1);
  if (v41 < 0)
  {
    operator delete(*(void **)__p);
    if (((char)v44 & 0x80000000) == 0) {
      goto LABEL_43;
    }
  }
  else if (((char)v44 & 0x80000000) == 0)
  {
    goto LABEL_43;
  }
  operator delete(__dst);
LABEL_43:
  if (*(unsigned char *)(a1 + 128)) {
    char v29 = "[FREE]";
  }
  else {
    char v29 = "[FIXED]";
  }
  if (*(unsigned char *)(a1 + 128)) {
    size_t v30 = 6;
  }
  else {
    size_t v30 = 7;
  }
  unsigned __int8 v44 = v30;
  memcpy(&__dst, v29, v30);
  *(unsigned char *)((unint64_t)&__dst | v30) = 0;
  if ((v44 & 0x80u) == 0) {
    std::string::size_type v31 = (void **)&__dst;
  }
  else {
    std::string::size_type v31 = __dst;
  }
  if ((v44 & 0x80u) == 0) {
    uint64_t v32 = v44;
  }
  else {
    uint64_t v32 = v43;
  }
  std::string::size_type v33 = sub_2153C1168(a2, (uint64_t)v31, v32);
  uint64_t v34 = sub_2153C1168(v33, (uint64_t)"[", 1);
  char v41 = 13;
  strcpy(__p, "Linear Length");
  std::string::size_type v35 = sub_2153C1168(v34, (uint64_t)__p, 13);
  sub_2153C1168(v35, (uint64_t)"] : ", 4);
  char v36 = (void *)std::ostream::operator<<();
  sub_2153C1168(v36, (uint64_t)"\n", 1);
  if (v41 < 0)
  {
    operator delete(*(void **)__p);
    if (((char)v44 & 0x80000000) == 0) {
      return a2;
    }
LABEL_65:
    operator delete(__dst);
    return a2;
  }
  if ((char)v44 < 0) {
    goto LABEL_65;
  }
  return a2;
}

uint64_t *sub_2153EAEB0(unsigned char *a1, uint64_t *a2)
{
  uint64_t v3 = (float32x2_t *)(a1 + 4);
  if (*a1) {
    size_t v4 = "[FREE]";
  }
  else {
    size_t v4 = "[FIXED]";
  }
  if (*a1) {
    size_t v5 = 6;
  }
  else {
    size_t v5 = 7;
  }
  unsigned __int8 v16 = v5;
  memcpy(__dst, v4, v5);
  *(unsigned char *)((unint64_t)__dst | v5) = 0;
  if ((v16 & 0x80u) == 0) {
    float v6 = __dst;
  }
  else {
    float v6 = (void **)__dst[0];
  }
  if ((v16 & 0x80u) == 0) {
    uint64_t v7 = v16;
  }
  else {
    uint64_t v7 = (uint64_t)__dst[1];
  }
  float32x2_t v8 = sub_2153C1168(a2, (uint64_t)v6, v7);
  int v9 = sub_2153C1168(v8, (uint64_t)"[", 1);
  char v14 = 19;
  strcpy(__p, "Extrinsics Rotation");
  long long v10 = sub_2153C1168(v9, (uint64_t)__p, 19);
  sub_2153C1168(v10, (uint64_t)"] : ", 4);
  float v18 = 0.0;
  double v17 = 0.0;
  sub_2153C9A50(v3, (float *)&v17);
  long long v11 = sub_2153EC538(a2, v17, v18);
  sub_2153C1168(v11, (uint64_t)"\n", 1);
  if (v14 < 0)
  {
    operator delete(*(void **)__p);
    if (((char)v16 & 0x80000000) == 0) {
      return a2;
    }
LABEL_17:
    operator delete(__dst[0]);
    return a2;
  }
  if ((char)v16 < 0) {
    goto LABEL_17;
  }
  return a2;
}

uint64_t *sub_2153EAFFC(uint64_t *a1, uint64_t *a2)
{
  if (*((unsigned char *)a1 + 12)) {
    size_t v4 = "[FREE]";
  }
  else {
    size_t v4 = "[FIXED]";
  }
  if (*((unsigned char *)a1 + 12)) {
    size_t v5 = 6;
  }
  else {
    size_t v5 = 7;
  }
  unsigned __int8 v96 = v5;
  memcpy(__dst, v4, v5);
  *(unsigned char *)((unint64_t)__dst | v5) = 0;
  if ((v96 & 0x80u) == 0) {
    float v6 = __dst;
  }
  else {
    float v6 = (void **)__dst[0];
  }
  if ((v96 & 0x80u) == 0) {
    uint64_t v7 = v96;
  }
  else {
    uint64_t v7 = (uint64_t)__dst[1];
  }
  float32x2_t v8 = sub_2153C1168(a2, (uint64_t)v6, v7);
  int v9 = sub_2153C1168(v8, (uint64_t)"[", 1);
  strcpy((char *)v94, "Extrinsics Translation");
  HIBYTE(v94[2]) = 22;
  long long v10 = sub_2153C1168(v9, (uint64_t)v94, 22);
  sub_2153C1168(v10, (uint64_t)"] : ", 4);
  uint64_t v103 = *a1;
  int v104 = *((_DWORD *)a1 + 2);
  long long v11 = (char *)a2 + *(void *)(*a2 - 24);
  int v12 = *((_DWORD *)v11 + 2);
  size_t v14 = *((void *)v11 + 2);
  int64_t v13 = *((void *)v11 + 3);
  if (v13)
  {
    if (v13 <= (uint64_t)(v14 + 2)) {
      int64_t v13 = v14 + 2;
    }
    size_t v15 = v13 + ~v14;
    double v16 = __exp10((double)-(uint64_t)v14);
    size_t v17 = v15 - 1;
    if (v15 - 1 > 0x7FFFFFFFFFFFFFF7) {
LABEL_149:
    }
      abort();
    double v18 = v16;
    if (v17 >= 0x17)
    {
      uint64_t v20 = (v17 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v17 | 7) != 0x17) {
        uint64_t v20 = v17 | 7;
      }
      uint64_t v21 = v20 + 1;
      p_b = (std::string *)operator new(v20 + 1);
      __b.__r_.__value_.__l.__size_ = v15 - 1;
      __b.__r_.__value_.__r.__words[2] = v21 | 0x8000000000000000;
      __b.__r_.__value_.__r.__words[0] = (std::string::size_type)p_b;
    }
    else
    {
      *((unsigned char *)&__b.__r_.__value_.__s + 23) = v15 - 1;
      p_b = &__b;
      if (v15 == 1)
      {
        LODWORD(v15) = 1;
        goto LABEL_25;
      }
    }
  }
  else
  {
    double v18 = __exp10((double)-(uint64_t)v14);
    size_t v17 = 3;
    *((unsigned char *)&__b.__r_.__value_.__s + 23) = 3;
    p_b = &__b;
    LODWORD(v15) = 4;
  }
  memset(p_b, 32, v17);
LABEL_25:
  p_b->__r_.__value_.__s.__data_[v17] = 0;
  size_t v22 = std::string::append(&__b, "0 ");
  std::string::size_type v23 = v22->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v105.__r_.__value_.__l.__data_ = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
  v105.__r_.__value_.__r.__words[2] = v23;
  v22->__r_.__value_.__l.__size_ = 0;
  v22->__r_.__value_.__r.__words[2] = 0;
  v22->__r_.__value_.__r.__words[0] = 0;
  if (v14 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_149;
  }
  if (v14 >= 0x17)
  {
    uint64_t v25 = (v14 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v14 | 7) != 0x17) {
      uint64_t v25 = v14 | 7;
    }
    uint64_t v26 = v25 + 1;
    uint64_t v24 = operator new(v25 + 1);
    std::string::size_type v98 = v14;
    int64_t v99 = v26 | 0x8000000000000000;
    uint64_t v97 = v24;
    goto LABEL_32;
  }
  HIBYTE(v99) = v14;
  uint64_t v24 = &v97;
  if (v14) {
LABEL_32:
  }
    memset(v24, 32, v14);
  *((unsigned char *)v24 + v14) = 0;
  if (v99 >= 0) {
    char v27 = (const std::string::value_type *)&v97;
  }
  else {
    char v27 = (const std::string::value_type *)v97;
  }
  if (v99 >= 0) {
    std::string::size_type v28 = HIBYTE(v99);
  }
  else {
    std::string::size_type v28 = v98;
  }
  char v29 = std::string::append(&v105, v27, v28);
  std::string::size_type v30 = v29->__r_.__value_.__r.__words[2];
  *(_OWORD *)long long __p = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
  uint64_t v102 = v30;
  v29->__r_.__value_.__l.__size_ = 0;
  v29->__r_.__value_.__r.__words[2] = 0;
  v29->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v99) < 0)
  {
    operator delete(v97);
    if ((SHIBYTE(v105.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_41;
    }
LABEL_146:
    operator delete(v105.__r_.__value_.__l.__data_);
    goto LABEL_41;
  }
  if (SHIBYTE(v105.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_146;
  }
LABEL_41:
  int v88 = v12;
  if (SHIBYTE(__b.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__b.__r_.__value_.__l.__data_);
  }
  long long v92 = a2 + 1;
  *(uint64_t *)((char *)a2 + *(void *)(*a2 - 24) + 24) = 0;
  v105.__r_.__value_.__s.__data_[0] = 91;
  sub_2153C1168(a2, (uint64_t)&v105, 1);
  uint64_t v32 = 0;
  uint64_t v93 = (int)v15 + (int)v14 + 1;
  uint64_t v90 = (int)v14;
  uint64_t v91 = (int)v14 - 3;
  while (1)
  {
    float v33 = *(float *)((char *)&v103 + v32);
    v31.n128_f64[0] = v33;
    uint64_t v34 = *a2;
    std::string::size_type v35 = (char *)a2 + *(void *)(*a2 - 24);
    if (v35[9]) {
      break;
    }
    if (fabs(v31.n128_f64[0]) < v18)
    {
      char v36 = (char *)HIBYTE(v102);
      char v37 = (char *)__p[1];
      if (v102 >= 0) {
        double v38 = __p;
      }
      else {
        double v38 = (void **)__p[0];
      }
      MEMORY[0x2166B95F0](&__b, a2);
      if (__b.__r_.__value_.__s.__data_[0])
      {
        if ((char)v36 >= 0) {
          float v39 = v36;
        }
        else {
          float v39 = v37;
        }
        char v40 = (char *)a2 + *(void *)(*a2 - 24);
        uint64_t v41 = *((void *)v40 + 5);
        char v42 = &v39[(void)v38];
        if ((*((_DWORD *)v40 + 2) & 0xB0) == 0x20) {
          uint64_t v43 = (void **)&v39[(void)v38];
        }
        else {
          uint64_t v43 = v38;
        }
        int v44 = *((_DWORD *)v40 + 36);
        if (v44 == -1)
        {
          long long v52 = v43;
          std::ios_base::getloc((const std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)));
          std::string::size_type v53 = std::locale::use_facet((const std::locale *)&v105, MEMORY[0x263F8C108]);
          int v44 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v53->__vftable[2].~facet_0)(v53, 32);
          std::locale::~locale((std::locale *)&v105);
          uint64_t v43 = v52;
          *((_DWORD *)v40 + 36) = v44;
          if (!v41) {
            goto LABEL_108;
          }
        }
        else if (!v41)
        {
          goto LABEL_108;
        }
        uint64_t v54 = *((void *)v40 + 3);
        BOOL v55 = v54 <= (uint64_t)v39;
        std::string::size_type v56 = v54 - (void)v39;
        if (v55) {
          std::string::size_type v57 = 0;
        }
        else {
          std::string::size_type v57 = v56;
        }
        int64_t v58 = (char *)v43 - (char *)v38;
        if ((char *)v43 - (char *)v38 >= 1)
        {
          char v59 = v43;
          uint64_t v60 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v41 + 96))(v41, v38, v58);
          uint64_t v43 = v59;
          if (v60 != v58) {
            goto LABEL_108;
          }
        }
        goto LABEL_92;
      }
      goto LABEL_109;
    }
    *((void *)v35 + 3) = v93;
    *(_DWORD *)((char *)v92 + *(void *)(v34 - 24)) = *(_DWORD *)((unsigned char *)v92 + *(void *)(v34 - 24)) & 0xFFFFFEFB | 4;
    *(_DWORD *)((char *)v92 + *(void *)(v34 - 24)) |= 0x400u;
    uint64_t v45 = *(void *)(v34 - 24);
    uint64_t v46 = a2 + 2;
    uint64_t v47 = v90;
LABEL_64:
    *(void *)((char *)v46 + v45) = v47;
    std::ostream::operator<<();
    if (v32 == 8) {
      goto LABEL_140;
    }
LABEL_110:
    LOBYTE(v97) = 44;
    MEMORY[0x2166B95F0](&__b, a2);
    if (__b.__r_.__value_.__s.__data_[0])
    {
      uint64_t v73 = (char *)a2 + *(void *)(*a2 - 24);
      uint64_t v74 = *((void *)v73 + 5);
      if ((*((_DWORD *)v73 + 2) & 0xB0) == 0x20) {
        unint64_t v75 = (void **)((char *)&v97 + 1);
      }
      else {
        unint64_t v75 = &v97;
      }
      int v76 = *((_DWORD *)v73 + 36);
      if (v76 == -1)
      {
        std::ios_base::getloc((const std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)));
        char v77 = std::locale::use_facet((const std::locale *)&v105, MEMORY[0x263F8C108]);
        int v76 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v77->__vftable[2].~facet_0)(v77, 32);
        std::locale::~locale((std::locale *)&v105);
        *((_DWORD *)v73 + 36) = v76;
        if (!v74) {
          goto LABEL_44;
        }
      }
      else if (!v74)
      {
        goto LABEL_44;
      }
      uint64_t v78 = *((void *)v73 + 3);
      BOOL v55 = v78 <= 1;
      std::string::size_type v79 = v78 - 1;
      if (v55) {
        std::string::size_type v80 = 0;
      }
      else {
        std::string::size_type v80 = v79;
      }
      if ((char *)v75 - (char *)&v97 >= 1
        && (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v74 + 96))(v74, &v97, (char *)v75 - (char *)&v97) != (char *)v75 - (char *)&v97)
      {
        goto LABEL_44;
      }
      if ((uint64_t)v80 >= 1)
      {
        if (v80 > 0x7FFFFFFFFFFFFFF7) {
          goto LABEL_149;
        }
        if (v80 >= 0x17)
        {
          uint64_t v82 = (v80 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v80 | 7) != 0x17) {
            uint64_t v82 = v80 | 7;
          }
          uint64_t v83 = v82 + 1;
          std::string v81 = operator new(v82 + 1);
          v105.__r_.__value_.__l.__size_ = v80;
          v105.__r_.__value_.__r.__words[2] = v83 | 0x8000000000000000;
          v105.__r_.__value_.__r.__words[0] = (std::string::size_type)v81;
        }
        else
        {
          *((unsigned char *)&v105.__r_.__value_.__s + 23) = v80;
          std::string v81 = &v105;
        }
        memset(v81, v76, v80);
        *((unsigned char *)v81 + v80) = 0;
        if ((v105.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v84 = &v105;
        }
        else {
          uint64_t v84 = (std::string *)v105.__r_.__value_.__r.__words[0];
        }
        uint64_t v85 = (*(uint64_t (**)(uint64_t, std::string *, std::string::size_type))(*(void *)v74 + 96))(v74, v84, v80);
        uint64_t v86 = v85;
        if (SHIBYTE(v105.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v105.__r_.__value_.__l.__data_);
          if (v86 != v80) {
            goto LABEL_44;
          }
        }
        else if (v85 != v80)
        {
          goto LABEL_44;
        }
      }
      if ((char *)&v97 + 1 - (char *)v75 >= 1
        && (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v74 + 96))(v74, v75, (char *)&v97 + 1 - (char *)v75) != (char *)&v97 + 1 - (char *)v75)
      {
LABEL_44:
        std::ios_base::clear((std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)), *(_DWORD *)((char *)a2 + *(void *)(*a2 - 24) + 32) | 5);
        goto LABEL_45;
      }
      *((void *)v73 + 3) = 0;
    }
LABEL_45:
    MEMORY[0x2166B9600](&__b);
    v32 += 4;
  }
  if (v33 != 0.0)
  {
    *((void *)v35 + 3) = v93;
    *(_DWORD *)((char *)v92 + *(void *)(v34 - 24)) |= 0x400u;
    uint64_t v45 = *(void *)(v34 - 24);
    uint64_t v46 = a2 + 2;
    uint64_t v47 = v91;
    goto LABEL_64;
  }
  int v48 = (char *)HIBYTE(v102);
  int v49 = (char *)__p[1];
  if (v102 >= 0) {
    int v50 = __p;
  }
  else {
    int v50 = (void **)__p[0];
  }
  MEMORY[0x2166B95F0](&__b, a2, v31);
  if (__b.__r_.__value_.__s.__data_[0])
  {
    if ((char)v48 >= 0) {
      std::string::value_type v51 = v48;
    }
    else {
      std::string::value_type v51 = v49;
    }
    char v40 = (char *)a2 + *(void *)(*a2 - 24);
    uint64_t v41 = *((void *)v40 + 5);
    char v42 = &v51[(void)v50];
    if ((*((_DWORD *)v40 + 2) & 0xB0) == 0x20) {
      uint64_t v43 = (void **)&v51[(void)v50];
    }
    else {
      uint64_t v43 = v50;
    }
    int v44 = *((_DWORD *)v40 + 36);
    if (v44 != -1)
    {
      if (!v41) {
        goto LABEL_108;
      }
LABEL_87:
      uint64_t v63 = *((void *)v40 + 3);
      BOOL v55 = v63 <= (uint64_t)v51;
      std::string::size_type v64 = v63 - (void)v51;
      if (v55) {
        std::string::size_type v57 = 0;
      }
      else {
        std::string::size_type v57 = v64;
      }
      int64_t v65 = (char *)v43 - (char *)v50;
      if ((char *)v43 - (char *)v50 >= 1)
      {
        unint64_t v66 = v43;
        uint64_t v67 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v41 + 96))(v41, v50, v65);
        uint64_t v43 = v66;
        if (v67 != v65) {
          goto LABEL_108;
        }
      }
LABEL_92:
      if ((uint64_t)v57 < 1) {
        goto LABEL_106;
      }
      if (v57 > 0x7FFFFFFFFFFFFFF7) {
        goto LABEL_149;
      }
      int v89 = v43;
      if (v57 >= 0x17)
      {
        uint64_t v69 = (v57 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v57 | 7) != 0x17) {
          uint64_t v69 = v57 | 7;
        }
        uint64_t v70 = v69 + 1;
        long long v68 = operator new(v69 + 1);
        v105.__r_.__value_.__l.__size_ = v57;
        v105.__r_.__value_.__r.__words[2] = v70 | 0x8000000000000000;
        v105.__r_.__value_.__r.__words[0] = (std::string::size_type)v68;
      }
      else
      {
        *((unsigned char *)&v105.__r_.__value_.__s + 23) = v57;
        long long v68 = &v105;
      }
      memset(v68, v44, v57);
      *((unsigned char *)v68 + v57) = 0;
      if ((v105.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v71 = &v105;
      }
      else {
        int v71 = (std::string *)v105.__r_.__value_.__r.__words[0];
      }
      uint64_t v72 = (*(uint64_t (**)(uint64_t, std::string *, std::string::size_type))(*(void *)v41 + 96))(v41, v71, v57);
      if (SHIBYTE(v105.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v105.__r_.__value_.__l.__data_);
      }
      uint64_t v43 = v89;
      if (v72 == v57)
      {
LABEL_106:
        if (v42 - (char *)v43 < 1
          || (*(uint64_t (**)(uint64_t))(*(void *)v41 + 96))(v41) == v42 - (char *)v43)
        {
          *((void *)v40 + 3) = 0;
          goto LABEL_109;
        }
      }
      goto LABEL_108;
    }
    char v61 = v43;
    std::ios_base::getloc((const std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)));
    int v62 = std::locale::use_facet((const std::locale *)&v105, MEMORY[0x263F8C108]);
    int v44 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v62->__vftable[2].~facet_0)(v62, 32);
    std::locale::~locale((std::locale *)&v105);
    uint64_t v43 = v61;
    *((_DWORD *)v40 + 36) = v44;
    if (v41) {
      goto LABEL_87;
    }
LABEL_108:
    std::ios_base::clear((std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)), *(_DWORD *)((char *)a2 + *(void *)(*a2 - 24) + 32) | 5);
  }
LABEL_109:
  MEMORY[0x2166B9600](&__b);
  if (v32 != 8) {
    goto LABEL_110;
  }
LABEL_140:
  sub_2153C1168(a2, (uint64_t)"   ]", 4);
  *(_DWORD *)((char *)a2 + *(void *)(*a2 - 24) + 8) = v88;
  if (SHIBYTE(v102) < 0) {
    operator delete(__p[0]);
  }
  sub_2153C1168(a2, (uint64_t)"\n", 1);
  if (SHIBYTE(v94[2]) < 0)
  {
    operator delete(v94[0]);
    if (((char)v96 & 0x80000000) == 0) {
      return a2;
    }
LABEL_148:
    operator delete(__dst[0]);
    return a2;
  }
  if ((char)v96 < 0) {
    goto LABEL_148;
  }
  return a2;
}

uint64_t *sub_2153EBB18(uint64_t *a1, double a2)
{
  double v93 = a2;
  uint64_t v3 = (char *)a1 + *(void *)(*a1 - 24);
  int v4 = *((_DWORD *)v3 + 2);
  size_t v6 = *((void *)v3 + 2);
  int64_t v5 = *((void *)v3 + 3);
  if (v5)
  {
    if (v5 <= (uint64_t)(v6 + 2)) {
      int64_t v5 = v6 + 2;
    }
    size_t v7 = v5 + ~v6;
    double v8 = __exp10((double)-(uint64_t)v6);
    size_t v9 = v7 - 1;
    if (v7 - 1 > 0x7FFFFFFFFFFFFFF7) {
LABEL_133:
    }
      abort();
    double v10 = v8;
    if (v9 >= 0x17)
    {
      uint64_t v12 = (v9 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v9 | 7) != 0x17) {
        uint64_t v12 = v9 | 7;
      }
      uint64_t v13 = v12 + 1;
      p_b = (std::string *)operator new(v12 + 1);
      __b.__r_.__value_.__l.__size_ = v7 - 1;
      __b.__r_.__value_.__r.__words[2] = v13 | 0x8000000000000000;
      __b.__r_.__value_.__r.__words[0] = (std::string::size_type)p_b;
    }
    else
    {
      *((unsigned char *)&__b.__r_.__value_.__s + 23) = v7 - 1;
      p_b = &__b;
      if (v7 == 1)
      {
        LODWORD(v7) = 1;
        goto LABEL_13;
      }
    }
  }
  else
  {
    double v10 = __exp10((double)-(uint64_t)v6);
    size_t v9 = 3;
    *((unsigned char *)&__b.__r_.__value_.__s + 23) = 3;
    p_b = &__b;
    LODWORD(v7) = 4;
  }
  memset(p_b, 32, v9);
LABEL_13:
  p_b->__r_.__value_.__s.__data_[v9] = 0;
  size_t v14 = std::string::append(&__b, "0 ");
  std::string::size_type v15 = v14->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v94.__r_.__value_.__l.__data_ = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  v94.__r_.__value_.__r.__words[2] = v15;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  if (v6 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_133;
  }
  if (v6 >= 0x17)
  {
    uint64_t v17 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17) {
      uint64_t v17 = v6 | 7;
    }
    uint64_t v18 = v17 + 1;
    double v16 = operator new(v17 + 1);
    std::string::size_type v88 = v6;
    int64_t v89 = v18 | 0x8000000000000000;
    std::string v87 = v16;
    goto LABEL_20;
  }
  HIBYTE(v89) = v6;
  double v16 = &v87;
  if (v6) {
LABEL_20:
  }
    memset(v16, 32, v6);
  *((unsigned char *)v16 + v6) = 0;
  if (v89 >= 0) {
    int v19 = (const std::string::value_type *)&v87;
  }
  else {
    int v19 = (const std::string::value_type *)v87;
  }
  if (v89 >= 0) {
    std::string::size_type v20 = HIBYTE(v89);
  }
  else {
    std::string::size_type v20 = v88;
  }
  uint64_t v21 = std::string::append(&v94, v19, v20);
  std::string::size_type v22 = v21->__r_.__value_.__r.__words[2];
  *(_OWORD *)long long __p = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
  uint64_t v92 = v22;
  v21->__r_.__value_.__l.__size_ = 0;
  v21->__r_.__value_.__r.__words[2] = 0;
  v21->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v89) < 0)
  {
    operator delete(v87);
    if ((SHIBYTE(v94.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_29;
    }
LABEL_132:
    operator delete(v94.__r_.__value_.__l.__data_);
    goto LABEL_29;
  }
  if (SHIBYTE(v94.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_132;
  }
LABEL_29:
  int v81 = v4;
  if (SHIBYTE(__b.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__b.__r_.__value_.__l.__data_);
  }
  uint64_t v85 = a1 + 1;
  *(uint64_t *)((char *)a1 + *(void *)(*a1 - 24) + 24) = 0;
  v94.__r_.__value_.__s.__data_[0] = 91;
  sub_2153C1168(a1, (uint64_t)&v94, 1);
  char v24 = 0;
  uint64_t v25 = 0;
  uint64_t v86 = (int)v7 + (int)v6 + 1;
  uint64_t v83 = (int)v6;
  uint64_t v84 = (int)v6 - 3;
  while (1)
  {
    float v26 = *((float *)&v93 + v25);
    v23.n128_f64[0] = v26;
    uint64_t v27 = *a1;
    std::string::size_type v28 = (char *)a1 + *(void *)(*a1 - 24);
    if (v28[9]) {
      break;
    }
    if (fabs(v23.n128_f64[0]) < v10)
    {
      char v29 = (char *)HIBYTE(v92);
      std::string::size_type v30 = (char *)__p[1];
      if (v92 >= 0) {
        __n128 v31 = __p;
      }
      else {
        __n128 v31 = (void **)__p[0];
      }
      MEMORY[0x2166B95F0](&__b, a1);
      if (__b.__r_.__value_.__s.__data_[0])
      {
        if ((char)v29 >= 0) {
          uint64_t v32 = v29;
        }
        else {
          uint64_t v32 = v30;
        }
        float v33 = (char *)a1 + *(void *)(*a1 - 24);
        uint64_t v34 = *((void *)v33 + 5);
        std::string::size_type v35 = &v32[(void)v31];
        if ((*((_DWORD *)v33 + 2) & 0xB0) == 0x20) {
          char v36 = (void **)&v32[(void)v31];
        }
        else {
          char v36 = v31;
        }
        int v37 = *((_DWORD *)v33 + 36);
        if (v37 == -1)
        {
          uint64_t v45 = v36;
          std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
          uint64_t v46 = std::locale::use_facet((const std::locale *)&v94, MEMORY[0x263F8C108]);
          int v37 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v46->__vftable[2].~facet_0)(v46, 32);
          std::locale::~locale((std::locale *)&v94);
          char v36 = v45;
          *((_DWORD *)v33 + 36) = v37;
          if (!v34) {
            goto LABEL_96;
          }
        }
        else if (!v34)
        {
          goto LABEL_96;
        }
        uint64_t v47 = *((void *)v33 + 3);
        BOOL v48 = v47 <= (uint64_t)v32;
        std::string::size_type v49 = v47 - (void)v32;
        if (v48) {
          std::string::size_type v50 = 0;
        }
        else {
          std::string::size_type v50 = v49;
        }
        int64_t v51 = (char *)v36 - (char *)v31;
        if ((char *)v36 - (char *)v31 >= 1)
        {
          long long v52 = v36;
          uint64_t v53 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v34 + 96))(v34, v31, v51);
          char v36 = v52;
          if (v53 != v51) {
            goto LABEL_96;
          }
        }
        goto LABEL_80;
      }
      goto LABEL_97;
    }
    *((void *)v28 + 3) = v86;
    *(_DWORD *)((char *)v85 + *(void *)(v27 - 24)) = *(_DWORD *)((unsigned char *)v85 + *(void *)(v27 - 24)) & 0xFFFFFEFB | 4;
    *(_DWORD *)((char *)v85 + *(void *)(v27 - 24)) |= 0x400u;
    uint64_t v38 = *(void *)(v27 - 24);
    float v39 = a1 + 2;
    uint64_t v40 = v83;
LABEL_52:
    *(void *)((char *)v39 + v38) = v40;
    std::ostream::operator<<();
    if (v24) {
      goto LABEL_128;
    }
LABEL_98:
    LOBYTE(v87) = 44;
    MEMORY[0x2166B95F0](&__b, a1);
    if (__b.__r_.__value_.__s.__data_[0])
    {
      unint64_t v66 = (char *)a1 + *(void *)(*a1 - 24);
      uint64_t v67 = *((void *)v66 + 5);
      if ((*((_DWORD *)v66 + 2) & 0xB0) == 0x20) {
        long long v68 = (void **)((char *)&v87 + 1);
      }
      else {
        long long v68 = &v87;
      }
      int v69 = *((_DWORD *)v66 + 36);
      if (v69 == -1)
      {
        std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
        uint64_t v70 = std::locale::use_facet((const std::locale *)&v94, MEMORY[0x263F8C108]);
        int v69 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v70->__vftable[2].~facet_0)(v70, 32);
        std::locale::~locale((std::locale *)&v94);
        *((_DWORD *)v66 + 36) = v69;
        if (!v67) {
          goto LABEL_32;
        }
      }
      else if (!v67)
      {
        goto LABEL_32;
      }
      uint64_t v71 = *((void *)v66 + 3);
      BOOL v48 = v71 <= 1;
      std::string::size_type v72 = v71 - 1;
      if (v48) {
        std::string::size_type v73 = 0;
      }
      else {
        std::string::size_type v73 = v72;
      }
      if ((char *)v68 - (char *)&v87 >= 1
        && (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v67 + 96))(v67, &v87, (char *)v68 - (char *)&v87) != (char *)v68 - (char *)&v87)
      {
        goto LABEL_32;
      }
      if ((uint64_t)v73 >= 1)
      {
        if (v73 > 0x7FFFFFFFFFFFFFF7) {
          goto LABEL_133;
        }
        if (v73 >= 0x17)
        {
          uint64_t v75 = (v73 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v73 | 7) != 0x17) {
            uint64_t v75 = v73 | 7;
          }
          uint64_t v76 = v75 + 1;
          uint64_t v74 = operator new(v75 + 1);
          v94.__r_.__value_.__l.__size_ = v73;
          v94.__r_.__value_.__r.__words[2] = v76 | 0x8000000000000000;
          v94.__r_.__value_.__r.__words[0] = (std::string::size_type)v74;
        }
        else
        {
          *((unsigned char *)&v94.__r_.__value_.__s + 23) = v73;
          uint64_t v74 = &v94;
        }
        memset(v74, v69, v73);
        *((unsigned char *)v74 + v73) = 0;
        if ((v94.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          char v77 = &v94;
        }
        else {
          char v77 = (std::string *)v94.__r_.__value_.__r.__words[0];
        }
        uint64_t v78 = (*(uint64_t (**)(uint64_t, std::string *, std::string::size_type))(*(void *)v67 + 96))(v67, v77, v73);
        uint64_t v79 = v78;
        if (SHIBYTE(v94.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v94.__r_.__value_.__l.__data_);
          if (v79 != v73) {
            goto LABEL_32;
          }
        }
        else if (v78 != v73)
        {
          goto LABEL_32;
        }
      }
      if ((char *)&v87 + 1 - (char *)v68 >= 1
        && (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v67 + 96))(v67, v68, (char *)&v87 + 1 - (char *)v68) != (char *)&v87 + 1 - (char *)v68)
      {
LABEL_32:
        std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
        goto LABEL_33;
      }
      *((void *)v66 + 3) = 0;
    }
LABEL_33:
    MEMORY[0x2166B9600](&__b);
    char v24 = 1;
    uint64_t v25 = 1;
  }
  if (v26 != 0.0)
  {
    *((void *)v28 + 3) = v86;
    *(_DWORD *)((char *)v85 + *(void *)(v27 - 24)) |= 0x400u;
    uint64_t v38 = *(void *)(v27 - 24);
    float v39 = a1 + 2;
    uint64_t v40 = v84;
    goto LABEL_52;
  }
  uint64_t v41 = (char *)HIBYTE(v92);
  char v42 = (char *)__p[1];
  if (v92 >= 0) {
    uint64_t v43 = __p;
  }
  else {
    uint64_t v43 = (void **)__p[0];
  }
  MEMORY[0x2166B95F0](&__b, a1, v23);
  if (__b.__r_.__value_.__s.__data_[0])
  {
    if ((char)v41 >= 0) {
      int v44 = v41;
    }
    else {
      int v44 = v42;
    }
    float v33 = (char *)a1 + *(void *)(*a1 - 24);
    uint64_t v34 = *((void *)v33 + 5);
    std::string::size_type v35 = &v44[(void)v43];
    if ((*((_DWORD *)v33 + 2) & 0xB0) == 0x20) {
      char v36 = (void **)&v44[(void)v43];
    }
    else {
      char v36 = v43;
    }
    int v37 = *((_DWORD *)v33 + 36);
    if (v37 != -1)
    {
      if (!v34) {
        goto LABEL_96;
      }
LABEL_75:
      uint64_t v56 = *((void *)v33 + 3);
      BOOL v48 = v56 <= (uint64_t)v44;
      std::string::size_type v57 = v56 - (void)v44;
      if (v48) {
        std::string::size_type v50 = 0;
      }
      else {
        std::string::size_type v50 = v57;
      }
      int64_t v58 = (char *)v36 - (char *)v43;
      if ((char *)v36 - (char *)v43 >= 1)
      {
        char v59 = v36;
        uint64_t v60 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v34 + 96))(v34, v43, v58);
        char v36 = v59;
        if (v60 != v58) {
          goto LABEL_96;
        }
      }
LABEL_80:
      if ((uint64_t)v50 < 1) {
        goto LABEL_94;
      }
      if (v50 > 0x7FFFFFFFFFFFFFF7) {
        goto LABEL_133;
      }
      uint64_t v82 = v36;
      if (v50 >= 0x17)
      {
        uint64_t v62 = (v50 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v50 | 7) != 0x17) {
          uint64_t v62 = v50 | 7;
        }
        uint64_t v63 = v62 + 1;
        char v61 = operator new(v62 + 1);
        v94.__r_.__value_.__l.__size_ = v50;
        v94.__r_.__value_.__r.__words[2] = v63 | 0x8000000000000000;
        v94.__r_.__value_.__r.__words[0] = (std::string::size_type)v61;
      }
      else
      {
        *((unsigned char *)&v94.__r_.__value_.__s + 23) = v50;
        char v61 = &v94;
      }
      memset(v61, v37, v50);
      *((unsigned char *)v61 + v50) = 0;
      if ((v94.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v64 = &v94;
      }
      else {
        std::string::size_type v64 = (std::string *)v94.__r_.__value_.__r.__words[0];
      }
      uint64_t v65 = (*(uint64_t (**)(uint64_t, std::string *, std::string::size_type))(*(void *)v34 + 96))(v34, v64, v50);
      if (SHIBYTE(v94.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v94.__r_.__value_.__l.__data_);
      }
      char v36 = v82;
      if (v65 == v50)
      {
LABEL_94:
        if (v35 - (char *)v36 < 1
          || (*(uint64_t (**)(uint64_t))(*(void *)v34 + 96))(v34) == v35 - (char *)v36)
        {
          *((void *)v33 + 3) = 0;
          goto LABEL_97;
        }
      }
      goto LABEL_96;
    }
    uint64_t v54 = v36;
    std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
    BOOL v55 = std::locale::use_facet((const std::locale *)&v94, MEMORY[0x263F8C108]);
    int v37 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v55->__vftable[2].~facet_0)(v55, 32);
    std::locale::~locale((std::locale *)&v94);
    char v36 = v54;
    *((_DWORD *)v33 + 36) = v37;
    if (v34) {
      goto LABEL_75;
    }
LABEL_96:
    std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
  }
LABEL_97:
  MEMORY[0x2166B9600](&__b);
  if ((v24 & 1) == 0) {
    goto LABEL_98;
  }
LABEL_128:
  sub_2153C1168(a1, (uint64_t)"   ]", 4);
  *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 8) = v81;
  if (SHIBYTE(v92) < 0) {
    operator delete(__p[0]);
  }
  return a1;
}

uint64_t *sub_2153EC538(uint64_t *a1, double a2, float a3)
{
  double v93 = a2;
  float v94 = a3;
  int v4 = (char *)a1 + *(void *)(*a1 - 24);
  int v5 = *((_DWORD *)v4 + 2);
  size_t v7 = *((void *)v4 + 2);
  int64_t v6 = *((void *)v4 + 3);
  if (v6)
  {
    if (v6 <= (uint64_t)(v7 + 2)) {
      int64_t v6 = v7 + 2;
    }
    size_t v8 = v6 + ~v7;
    double v9 = __exp10((double)-(uint64_t)v7);
    size_t v10 = v8 - 1;
    if (v8 - 1 > 0x7FFFFFFFFFFFFFF7) {
LABEL_133:
    }
      abort();
    double v11 = v9;
    if (v10 >= 0x17)
    {
      uint64_t v13 = (v10 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v10 | 7) != 0x17) {
        uint64_t v13 = v10 | 7;
      }
      uint64_t v14 = v13 + 1;
      p_b = (std::string *)operator new(v13 + 1);
      __b.__r_.__value_.__l.__size_ = v8 - 1;
      __b.__r_.__value_.__r.__words[2] = v14 | 0x8000000000000000;
      __b.__r_.__value_.__r.__words[0] = (std::string::size_type)p_b;
    }
    else
    {
      *((unsigned char *)&__b.__r_.__value_.__s + 23) = v8 - 1;
      p_b = &__b;
      if (v8 == 1)
      {
        LODWORD(v8) = 1;
        goto LABEL_13;
      }
    }
  }
  else
  {
    double v11 = __exp10((double)-(uint64_t)v7);
    size_t v10 = 3;
    *((unsigned char *)&__b.__r_.__value_.__s + 23) = 3;
    p_b = &__b;
    LODWORD(v8) = 4;
  }
  memset(p_b, 32, v10);
LABEL_13:
  p_b->__r_.__value_.__s.__data_[v10] = 0;
  std::string::size_type v15 = std::string::append(&__b, "0 ");
  std::string::size_type v16 = v15->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v95.__r_.__value_.__l.__data_ = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  v95.__r_.__value_.__r.__words[2] = v16;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  if (v7 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_133;
  }
  if (v7 >= 0x17)
  {
    uint64_t v18 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17) {
      uint64_t v18 = v7 | 7;
    }
    uint64_t v19 = v18 + 1;
    uint64_t v17 = operator new(v18 + 1);
    std::string::size_type v88 = v7;
    int64_t v89 = v19 | 0x8000000000000000;
    std::string v87 = v17;
    goto LABEL_20;
  }
  HIBYTE(v89) = v7;
  uint64_t v17 = &v87;
  if (v7) {
LABEL_20:
  }
    memset(v17, 32, v7);
  *((unsigned char *)v17 + v7) = 0;
  if (v89 >= 0) {
    std::string::size_type v20 = (const std::string::value_type *)&v87;
  }
  else {
    std::string::size_type v20 = (const std::string::value_type *)v87;
  }
  if (v89 >= 0) {
    std::string::size_type v21 = HIBYTE(v89);
  }
  else {
    std::string::size_type v21 = v88;
  }
  std::string::size_type v22 = std::string::append(&v95, v20, v21);
  std::string::size_type v23 = v22->__r_.__value_.__r.__words[2];
  *(_OWORD *)long long __p = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
  uint64_t v92 = v23;
  v22->__r_.__value_.__l.__size_ = 0;
  v22->__r_.__value_.__r.__words[2] = 0;
  v22->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v89) < 0)
  {
    operator delete(v87);
    if ((SHIBYTE(v95.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_29;
    }
LABEL_132:
    operator delete(v95.__r_.__value_.__l.__data_);
    goto LABEL_29;
  }
  if (SHIBYTE(v95.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_132;
  }
LABEL_29:
  int v81 = v5;
  if (SHIBYTE(__b.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__b.__r_.__value_.__l.__data_);
  }
  uint64_t v85 = a1 + 1;
  *(uint64_t *)((char *)a1 + *(void *)(*a1 - 24) + 24) = 0;
  v95.__r_.__value_.__s.__data_[0] = 91;
  sub_2153C1168(a1, (uint64_t)&v95, 1);
  uint64_t v25 = 0;
  uint64_t v86 = (int)v8 + (int)v7 + 1;
  uint64_t v83 = (int)v7;
  uint64_t v84 = (int)v7 - 3;
  while (1)
  {
    float v26 = *(float *)((char *)&v93 + v25);
    v24.n128_f64[0] = v26;
    uint64_t v27 = *a1;
    std::string::size_type v28 = (char *)a1 + *(void *)(*a1 - 24);
    if (v28[9]) {
      break;
    }
    if (fabs(v24.n128_f64[0]) < v11)
    {
      char v29 = (char *)HIBYTE(v92);
      std::string::size_type v30 = (char *)__p[1];
      if (v92 >= 0) {
        __n128 v31 = __p;
      }
      else {
        __n128 v31 = (void **)__p[0];
      }
      MEMORY[0x2166B95F0](&__b, a1);
      if (__b.__r_.__value_.__s.__data_[0])
      {
        if ((char)v29 >= 0) {
          uint64_t v32 = v29;
        }
        else {
          uint64_t v32 = v30;
        }
        float v33 = (char *)a1 + *(void *)(*a1 - 24);
        uint64_t v34 = *((void *)v33 + 5);
        std::string::size_type v35 = &v32[(void)v31];
        if ((*((_DWORD *)v33 + 2) & 0xB0) == 0x20) {
          char v36 = (void **)&v32[(void)v31];
        }
        else {
          char v36 = v31;
        }
        int v37 = *((_DWORD *)v33 + 36);
        if (v37 == -1)
        {
          uint64_t v45 = v36;
          std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
          uint64_t v46 = std::locale::use_facet((const std::locale *)&v95, MEMORY[0x263F8C108]);
          int v37 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v46->__vftable[2].~facet_0)(v46, 32);
          std::locale::~locale((std::locale *)&v95);
          char v36 = v45;
          *((_DWORD *)v33 + 36) = v37;
          if (!v34) {
            goto LABEL_96;
          }
        }
        else if (!v34)
        {
          goto LABEL_96;
        }
        uint64_t v47 = *((void *)v33 + 3);
        BOOL v48 = v47 <= (uint64_t)v32;
        std::string::size_type v49 = v47 - (void)v32;
        if (v48) {
          std::string::size_type v50 = 0;
        }
        else {
          std::string::size_type v50 = v49;
        }
        int64_t v51 = (char *)v36 - (char *)v31;
        if ((char *)v36 - (char *)v31 >= 1)
        {
          long long v52 = v36;
          uint64_t v53 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v34 + 96))(v34, v31, v51);
          char v36 = v52;
          if (v53 != v51) {
            goto LABEL_96;
          }
        }
        goto LABEL_80;
      }
      goto LABEL_97;
    }
    *((void *)v28 + 3) = v86;
    *(_DWORD *)((char *)v85 + *(void *)(v27 - 24)) = *(_DWORD *)((unsigned char *)v85 + *(void *)(v27 - 24)) & 0xFFFFFEFB | 4;
    *(_DWORD *)((char *)v85 + *(void *)(v27 - 24)) |= 0x400u;
    uint64_t v38 = *(void *)(v27 - 24);
    float v39 = a1 + 2;
    uint64_t v40 = v83;
LABEL_52:
    *(void *)((char *)v39 + v38) = v40;
    std::ostream::operator<<();
    if (v25 == 8) {
      goto LABEL_128;
    }
LABEL_98:
    LOBYTE(v87) = 44;
    MEMORY[0x2166B95F0](&__b, a1);
    if (__b.__r_.__value_.__s.__data_[0])
    {
      unint64_t v66 = (char *)a1 + *(void *)(*a1 - 24);
      uint64_t v67 = *((void *)v66 + 5);
      if ((*((_DWORD *)v66 + 2) & 0xB0) == 0x20) {
        long long v68 = (void **)((char *)&v87 + 1);
      }
      else {
        long long v68 = &v87;
      }
      int v69 = *((_DWORD *)v66 + 36);
      if (v69 == -1)
      {
        std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
        uint64_t v70 = std::locale::use_facet((const std::locale *)&v95, MEMORY[0x263F8C108]);
        int v69 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v70->__vftable[2].~facet_0)(v70, 32);
        std::locale::~locale((std::locale *)&v95);
        *((_DWORD *)v66 + 36) = v69;
        if (!v67) {
          goto LABEL_32;
        }
      }
      else if (!v67)
      {
        goto LABEL_32;
      }
      uint64_t v71 = *((void *)v66 + 3);
      BOOL v48 = v71 <= 1;
      std::string::size_type v72 = v71 - 1;
      if (v48) {
        std::string::size_type v73 = 0;
      }
      else {
        std::string::size_type v73 = v72;
      }
      if ((char *)v68 - (char *)&v87 >= 1
        && (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v67 + 96))(v67, &v87, (char *)v68 - (char *)&v87) != (char *)v68 - (char *)&v87)
      {
        goto LABEL_32;
      }
      if ((uint64_t)v73 >= 1)
      {
        if (v73 > 0x7FFFFFFFFFFFFFF7) {
          goto LABEL_133;
        }
        if (v73 >= 0x17)
        {
          uint64_t v75 = (v73 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v73 | 7) != 0x17) {
            uint64_t v75 = v73 | 7;
          }
          uint64_t v76 = v75 + 1;
          uint64_t v74 = operator new(v75 + 1);
          v95.__r_.__value_.__l.__size_ = v73;
          v95.__r_.__value_.__r.__words[2] = v76 | 0x8000000000000000;
          v95.__r_.__value_.__r.__words[0] = (std::string::size_type)v74;
        }
        else
        {
          *((unsigned char *)&v95.__r_.__value_.__s + 23) = v73;
          uint64_t v74 = &v95;
        }
        memset(v74, v69, v73);
        *((unsigned char *)v74 + v73) = 0;
        if ((v95.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          char v77 = &v95;
        }
        else {
          char v77 = (std::string *)v95.__r_.__value_.__r.__words[0];
        }
        uint64_t v78 = (*(uint64_t (**)(uint64_t, std::string *, std::string::size_type))(*(void *)v67 + 96))(v67, v77, v73);
        uint64_t v79 = v78;
        if (SHIBYTE(v95.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v95.__r_.__value_.__l.__data_);
          if (v79 != v73) {
            goto LABEL_32;
          }
        }
        else if (v78 != v73)
        {
          goto LABEL_32;
        }
      }
      if ((char *)&v87 + 1 - (char *)v68 >= 1
        && (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v67 + 96))(v67, v68, (char *)&v87 + 1 - (char *)v68) != (char *)&v87 + 1 - (char *)v68)
      {
LABEL_32:
        std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
        goto LABEL_33;
      }
      *((void *)v66 + 3) = 0;
    }
LABEL_33:
    MEMORY[0x2166B9600](&__b);
    v25 += 4;
  }
  if (v26 != 0.0)
  {
    *((void *)v28 + 3) = v86;
    *(_DWORD *)((char *)v85 + *(void *)(v27 - 24)) |= 0x400u;
    uint64_t v38 = *(void *)(v27 - 24);
    float v39 = a1 + 2;
    uint64_t v40 = v84;
    goto LABEL_52;
  }
  uint64_t v41 = (char *)HIBYTE(v92);
  char v42 = (char *)__p[1];
  if (v92 >= 0) {
    uint64_t v43 = __p;
  }
  else {
    uint64_t v43 = (void **)__p[0];
  }
  MEMORY[0x2166B95F0](&__b, a1, v24);
  if (__b.__r_.__value_.__s.__data_[0])
  {
    if ((char)v41 >= 0) {
      int v44 = v41;
    }
    else {
      int v44 = v42;
    }
    float v33 = (char *)a1 + *(void *)(*a1 - 24);
    uint64_t v34 = *((void *)v33 + 5);
    std::string::size_type v35 = &v44[(void)v43];
    if ((*((_DWORD *)v33 + 2) & 0xB0) == 0x20) {
      char v36 = (void **)&v44[(void)v43];
    }
    else {
      char v36 = v43;
    }
    int v37 = *((_DWORD *)v33 + 36);
    if (v37 != -1)
    {
      if (!v34) {
        goto LABEL_96;
      }
LABEL_75:
      uint64_t v56 = *((void *)v33 + 3);
      BOOL v48 = v56 <= (uint64_t)v44;
      std::string::size_type v57 = v56 - (void)v44;
      if (v48) {
        std::string::size_type v50 = 0;
      }
      else {
        std::string::size_type v50 = v57;
      }
      int64_t v58 = (char *)v36 - (char *)v43;
      if ((char *)v36 - (char *)v43 >= 1)
      {
        char v59 = v36;
        uint64_t v60 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v34 + 96))(v34, v43, v58);
        char v36 = v59;
        if (v60 != v58) {
          goto LABEL_96;
        }
      }
LABEL_80:
      if ((uint64_t)v50 < 1) {
        goto LABEL_94;
      }
      if (v50 > 0x7FFFFFFFFFFFFFF7) {
        goto LABEL_133;
      }
      uint64_t v82 = v36;
      if (v50 >= 0x17)
      {
        uint64_t v62 = (v50 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v50 | 7) != 0x17) {
          uint64_t v62 = v50 | 7;
        }
        uint64_t v63 = v62 + 1;
        char v61 = operator new(v62 + 1);
        v95.__r_.__value_.__l.__size_ = v50;
        v95.__r_.__value_.__r.__words[2] = v63 | 0x8000000000000000;
        v95.__r_.__value_.__r.__words[0] = (std::string::size_type)v61;
      }
      else
      {
        *((unsigned char *)&v95.__r_.__value_.__s + 23) = v50;
        char v61 = &v95;
      }
      memset(v61, v37, v50);
      *((unsigned char *)v61 + v50) = 0;
      if ((v95.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v64 = &v95;
      }
      else {
        std::string::size_type v64 = (std::string *)v95.__r_.__value_.__r.__words[0];
      }
      uint64_t v65 = (*(uint64_t (**)(uint64_t, std::string *, std::string::size_type))(*(void *)v34 + 96))(v34, v64, v50);
      if (SHIBYTE(v95.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v95.__r_.__value_.__l.__data_);
      }
      char v36 = v82;
      if (v65 == v50)
      {
LABEL_94:
        if (v35 - (char *)v36 < 1
          || (*(uint64_t (**)(uint64_t))(*(void *)v34 + 96))(v34) == v35 - (char *)v36)
        {
          *((void *)v33 + 3) = 0;
          goto LABEL_97;
        }
      }
      goto LABEL_96;
    }
    uint64_t v54 = v36;
    std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
    BOOL v55 = std::locale::use_facet((const std::locale *)&v95, MEMORY[0x263F8C108]);
    int v37 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v55->__vftable[2].~facet_0)(v55, 32);
    std::locale::~locale((std::locale *)&v95);
    char v36 = v54;
    *((_DWORD *)v33 + 36) = v37;
    if (v34) {
      goto LABEL_75;
    }
LABEL_96:
    std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
  }
LABEL_97:
  MEMORY[0x2166B9600](&__b);
  if (v25 != 8) {
    goto LABEL_98;
  }
LABEL_128:
  sub_2153C1168(a1, (uint64_t)"   ]", 4);
  *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 8) = v81;
  if (SHIBYTE(v92) < 0) {
    operator delete(__p[0]);
  }
  return a1;
}

uint64_t sub_2153ECF5C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 136);
  if (v2) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v2 + 24))(v2, a1);
  }
  else {
    return 1;
  }
}

BOOL sub_2153ECF94(uint64_t a1, void *a2)
{
  int v4 = (*(uint64_t (**)(void))(*(void *)*a2 + 16))();
  if (!v4)
  {
    uint64_t v7 = *a2;
    uint64_t v6 = a2[1];
    if (v6) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
    }
    size_t v8 = *(std::__shared_weak_count **)(a1 + 144);
    *(void *)(a1 + 136) = v7;
    *(void *)(a1 + 144) = v6;
    if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  return v4 == 0;
}

float32_t sub_2153ED05C@<S0>(uint64_t a1@<X0>, uint64_t a2@<X1>, float32x2_t *a3@<X8>)
{
  long long v27 = xmmword_2154461C0;
  char v26 = 1;
  int v29 = 1065353216;
  long long v28 = unk_2154461D0;
  *((void *)&v23 + 1) = 0x100000000;
  LODWORD(v22) = 0;
  std::string::size_type v21 = 0;
  sub_2153C9A50((float32x2_t *)(a1 + 68), (float *)&v21);
  float v6 = *(float *)(a1 + 116);
  *(float32x2_t *)&long long v23 = vmul_n_f32((float32x2_t)v21, v6);
  *((float *)&v23 + 2) = *(float *)&v22 * v6;
  sub_2153ED230((float *)&v23, (float *)(a1 + 12), (uint64_t)&v27);
  long long v14 = v27;
  long long v15 = v28;
  int v16 = v29;
  float v13 = *(float *)(a1 + 124);
  float v7 = *(float *)(a1 + 104);
  __float2 v8 = __sincosf_stret(*(float *)(a1 + 108));
  __float2 v9 = __sincosf_stret(v7);
  float v10 = *(float *)(a1 + 116);
  float v11 = *(float *)(a1 + 56);
  float32x2_t v17 = vadd_f32(vmul_n_f32(vmul_n_f32(vmul_n_f32((float32x2_t)__PAIR64__(LODWORD(v9.__sinval), LODWORD(v9.__cosval)), v13), v8.__sinval), v10), *(float32x2_t *)(a1 + 48));
  float v18 = (float)((float)(v13 * v8.__cosval) * v10) + v11;
  char v19 = 1;
  char v26 = 1;
  *(void *)&long long v27 = __PAIR64__(HIDWORD(v14), v14);
  *((void *)&v27 + 1) = __PAIR64__(DWORD1(v14), DWORD2(v15));
  *(void *)&long long v28 = __PAIR64__(HIDWORD(v15), v15);
  *((void *)&v28 + 1) = __PAIR64__(DWORD1(v15), DWORD2(v14));
  int v29 = v16;
  std::string::size_type v21 = &v27;
  uint64_t v22 = a2;
  v20[0] = (float *)&v27;
  v20[1] = (float *)&v17;
  *(void *)((char *)&v23 + 4) = 0;
  HIDWORD(v23) = 0;
  sub_2153CA404((float *)&v23 + 1, (float **)&v21);
  float v25 = 0.0;
  float32x2_t v24 = 0;
  sub_2153CA404((float *)&v24, v20);
  float32_t result = *((float *)&v23 + 3) - v25;
  *a3 = vsub_f32(*(float32x2_t *)((char *)&v23 + 4), v24);
  a3[1].f32[0] = result;
  a3[1].i8[4] = 1;
  return result;
}

double sub_2153ED230(float *a1, float *a2, uint64_t a3)
{
  float v5 = *a1;
  float v6 = a1[1];
  float v7 = a1[2];
  float v8 = (float)((float)(v5 * v5) + (float)(v6 * v6)) + (float)(v7 * v7);
  if (v8 >= 0.0061)
  {
    float v12 = sqrtf(v8);
    __float2 v13 = __sincosf_stret(v12);
    float cosval = v13.__cosval;
    float v10 = v13.__sinval / v12;
    float v9 = (float)(1.0 / v8) * (float)(1.0 - v13.__cosval);
  }
  else
  {
    float v9 = 0.5 - (float)(v8 * (float)((float)(v8 / -720.0) + 0.041667));
    float v10 = 1.0 - (float)(v8 * (float)(0.16667 - (float)(v8 * (float)((float)(v8 / -5040.0) + 0.0083333))));
    float cosval = 1.0 - (float)(v8 * v9);
  }
  float v14 = v6 * (float)(v5 * v9);
  float v15 = v7 * (float)(v5 * v9);
  float v16 = v7 * (float)(v6 * v9);
  float v17 = v5 * v10;
  float v18 = v6 * v10;
  float v19 = v7 * v10;
  v26[0] = cosval + (float)((float)(v5 * v9) * v5);
  v26[1] = v14 + v19;
  void v26[2] = v15 - v18;
  v26[3] = v14 - v19;
  v26[4] = cosval + (float)((float)(v6 * v9) * v6);
  v26[5] = v16 + v17;
  v26[6] = v18 + v15;
  v26[7] = v16 - v17;
  void v26[8] = cosval + (float)((float)(v7 * v9) * v7);
  v22[0] = v26;
  v22[1] = a2;
  long long v23 = 0u;
  long long v24 = 0u;
  int v25 = 0;
  sub_2153C9F40((uint64_t)&v23, v22);
  double result = *(double *)&v23;
  long long v21 = v24;
  *(_OWORD *)a3 = v23;
  *(_OWORD *)(a3 + 16) = v21;
  *(_DWORD *)(a3 + 32) = v25;
  return result;
}

float32_t sub_2153ED3B4@<S0>(uint64_t a1@<X0>, uint64_t a2@<X1>, float32x2_t *a3@<X8>)
{
  long long v22 = xmmword_2154461C0;
  char v21 = 1;
  int v24 = 1065353216;
  long long v23 = unk_2154461D0;
  uint64_t v26 = 0x100000000;
  float32x2_t v27 = 0;
  float v28 = 0.0;
  sub_2153C9A50((float32x2_t *)(a1 + 68), (float *)&v27);
  float v6 = *(float *)(a1 + 116);
  int v25 = (float *)vmul_n_f32(v27, v6);
  *(float *)&uint64_t v26 = v28 * v6;
  sub_2153ED230((float *)&v25, (float *)(a1 + 12), (uint64_t)&v22);
  v16[0] = v22;
  v16[1] = v23;
  int v17 = v24;
  float v15 = *(float *)(a1 + 124);
  float v7 = *(float *)(a1 + 104);
  __float2 v8 = __sincosf_stret(*(float *)(a1 + 108));
  __float2 v9 = __sincosf_stret(v7);
  float v10 = *(float *)(a1 + 116);
  float32x2_t v11 = vadd_f32(vmul_n_f32(vmul_n_f32(vmul_n_f32((float32x2_t)__PAIR64__(LODWORD(v9.__sinval), LODWORD(v9.__cosval)), v15), v8.__sinval), v10), *(float32x2_t *)(a1 + 48));
  float v12 = *(float *)(a1 + 56);
  float32x2_t v18 = v11;
  float v13 = (float)((float)(v15 * v8.__cosval) * v10) + v12;
  float v19 = v13;
  char v20 = 1;
  int v25 = (float *)v16;
  uint64_t v26 = a2;
  *(void *)&long long v22 = 0;
  DWORD2(v22) = 0;
  sub_2153CA404((float *)&v22, &v25);
  float32_t result = *((float *)&v22 + 2) + v13;
  *a3 = vadd_f32(*(float32x2_t *)&v22, v11);
  a3[1].f32[0] = result;
  a3[1].i8[4] = 1;
  return result;
}

float sub_2153ED530@<S0>(uint64_t a1@<X0>, float32x2_t *a2@<X8>)
{
  *(_OWORD *)&float v16[4] = xmmword_2154461C0;
  a2[1].i8[4] = 1;
  int v15 = 1;
  long long v17 = unk_2154461D0;
  int v18 = 1065353216;
  uint64_t v20 = 0x100000000;
  float32x2_t v21 = 0;
  float v22 = 0.0;
  sub_2153C9A50((float32x2_t *)(a1 + 68), (float *)&v21);
  float v4 = *(float *)(a1 + 116);
  float32x2_t v19 = vmul_n_f32(v21, v4);
  *(float *)&uint64_t v20 = v22 * v4;
  sub_2153ED230((float *)&v19, (float *)(a1 + 12), (uint64_t)&v16[4]);
  v12[0] = *(_DWORD *)&v16[4];
  v12[1] = *(_DWORD *)&v16[16];
  void v12[2] = DWORD2(v17);
  v12[3] = *(_DWORD *)&v16[8];
  double v12[4] = v17;
  v12[5] = HIDWORD(v17);
  v12[6] = *(_DWORD *)&v16[12];
  float v12[7] = DWORD1(v17);
  v12[8] = v18;
  float v11 = *(float *)(a1 + 124);
  float v5 = *(float *)(a1 + 104);
  __float2 v6 = __sincosf_stret(*(float *)(a1 + 108));
  __float2 v7 = __sincosf_stret(v5);
  float v8 = *(float *)(a1 + 116);
  float32x2_t v13 = vadd_f32(vmul_n_f32(vmul_n_f32(vmul_n_f32((float32x2_t)__PAIR64__(LODWORD(v7.__sinval), LODWORD(v7.__cosval)), v11), v6.__sinval), v8), *(float32x2_t *)(a1 + 48));
  float v14 = (float)((float)(v11 * v6.__cosval) * v8) + *(float *)(a1 + 56);
  *(void *)float v16 = v12;
  *(void *)&float64x2_t v16[8] = &v13;
  float32x2_t v19 = 0;
  LODWORD(v20) = 0;
  sub_2153CA404((float *)&v19, (float **)v16);
  float v9 = *(float *)&v20;
  *a2 = vneg_f32(v19);
  float result = -v9;
  a2[1].f32[0] = -v9;
  return result;
}

float sub_2153ED6B0@<S0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  long long v12 = xmmword_2154461C0;
  int v14 = 1065353216;
  long long v13 = unk_2154461D0;
  uint64_t v16 = 0x100000000;
  float v18 = 0.0;
  float32x2_t v17 = 0;
  sub_2153C9A50((float32x2_t *)(a1 + 68), (float *)&v17);
  float v4 = *(float *)(a1 + 116);
  float32x2_t v15 = vmul_n_f32(v17, v4);
  *(float *)&uint64_t v16 = v18 * v4;
  sub_2153ED230((float *)&v15, (float *)(a1 + 12), (uint64_t)&v12);
  *(unsigned char *)a2 = 1;
  *(_OWORD *)(a2 + 4) = v12;
  *(_OWORD *)(a2 + 20) = v13;
  *(_DWORD *)(a2 + 36) = v14;
  float v11 = *(float *)(a1 + 124);
  float v5 = *(float *)(a1 + 104);
  __float2 v6 = __sincosf_stret(*(float *)(a1 + 108));
  __float2 v7 = __sincosf_stret(v5);
  float v8 = *(float *)(a1 + 116);
  float v9 = *(float *)(a1 + 56);
  *(float32x2_t *)(a2 + 40) = vadd_f32(vmul_n_f32(vmul_n_f32(vmul_n_f32((float32x2_t)__PAIR64__(LODWORD(v7.__sinval), LODWORD(v7.__cosval)), v11), v6.__sinval), v8), *(float32x2_t *)(a1 + 48));
  float result = (float)((float)(v11 * v6.__cosval) * v8) + v9;
  *(float *)(a2 + 48) = result;
  *(unsigned char *)(a2 + 52) = 1;
  return result;
}

uint64_t sub_2153ED7E0(uint64_t a1, char a2)
{
  *(unsigned char *)(a1 + 8) = a2;
  *(unsigned char *)(a1 + 60) = a2;
  *(unsigned char *)(a1 + 64) = a2;
  *(unsigned char *)(a1 + 112) = a2;
  uint64_t result = *(void *)(a1 + 136);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 32))();
  }
  return result;
}

void sub_2153ED820()
{
}

uint64_t sub_2153ED90C()
{
  return 1;
}

void sub_2153ED914(void *a1)
{
  *a1 = &unk_26C5FB9A0;
  id v1 = (std::__shared_weak_count *)a1[18];
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  JUMPOUT(0x2166B9890);
}

void *sub_2153ED9BC(void *a1)
{
  *a1 = &unk_26C5FB9A0;
  uint64_t v2 = (std::__shared_weak_count *)a1[18];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

BOOL sub_2153EDA44(float32x2_t *a1, float32x2_t *a2, float a3)
{
  if ((*(unsigned int (**)(float32x2_t *))(*(void *)a2 + 16))(a2)) {
    return 0;
  }
  float v11 = (char *)&a2[1] + 4;
  v12[0] = (char *)a1 + 12;
  v12[1] = &v11;
  long long v13 = 0u;
  long long v14 = 0u;
  int v15 = 0;
  sub_2153EA6B8((uint64_t)&v13, (uint64_t)v12);
  v9[0] = v13;
  v9[1] = v14;
  int v10 = v15;
  DWORD2(v13) = 0;
  *(void *)&long long v13 = 0;
  sub_2153C9A50((float32x2_t *)v9, (float *)&v13);
  BOOL result = 0;
  if (sqrtf((float)((float)(*(float *)&v13 * *(float *)&v13) + (float)(*((float *)&v13 + 1) * *((float *)&v13 + 1)))+ (float)(*((float *)&v13 + 2) * *((float *)&v13 + 2))) < a3)
  {
    float v7 = a1[7].f32[0] - a2[7].f32[0];
    float32x2_t v8 = vsub_f32(a1[6], a2[6]);
    return sqrtf(vaddv_f32(vmul_f32(v8, v8)) + (float)(v7 * v7)) < a3;
  }
  return result;
}

uint64_t *sub_2153EDB70(uint64_t a1, uint64_t *a2)
{
  sub_2153EAEB0((unsigned char *)(a1 + 8), a2);
  return sub_2153EAFFC((uint64_t *)(a1 + 48), a2);
}

uint64_t sub_2153EDBB4()
{
  return 1;
}

uint64_t sub_2153EDBBC()
{
  return 0;
}

float32_t sub_2153EDBC4@<S0>(uint64_t a1@<X0>, float *a2@<X1>, float32x2_t *a3@<X8>)
{
  char v19 = 1;
  int v4 = *(_DWORD *)(a1 + 16);
  int v5 = *(_DWORD *)(a1 + 36);
  int v6 = *(_DWORD *)(a1 + 40);
  int v8 = *(_DWORD *)(a1 + 20);
  int v7 = *(_DWORD *)(a1 + 24);
  int v9 = *(_DWORD *)(a1 + 28);
  int v10 = *(_DWORD *)(a1 + 32);
  int v11 = *(_DWORD *)(a1 + 44);
  v20[0] = *(_DWORD *)(a1 + 12);
  v20[1] = v7;
  void v20[2] = v5;
  v20[3] = v4;
  v20[4] = v9;
  v20[5] = v6;
  v20[6] = v8;
  v20[7] = v10;
  v20[8] = v11;
  v14[0] = (float *)v20;
  v14[1] = a2;
  v13[0] = (float *)v20;
  v13[1] = (float *)(a1 + 48);
  float32x2_t v15 = 0;
  float v16 = 0.0;
  sub_2153CA404((float *)&v15, v14);
  float v18 = 0.0;
  float32x2_t v17 = 0;
  sub_2153CA404((float *)&v17, v13);
  float32_t result = v16 - v18;
  *a3 = vsub_f32(v15, v17);
  a3[1].f32[0] = result;
  a3[1].i8[4] = 1;
  return result;
}

float32_t sub_2153EDC88@<S0>(float32x2_t *a1@<X0>, float *a2@<X1>, float32x2_t *a3@<X8>)
{
  v6[0] = (float *)&a1[1] + 1;
  v6[1] = a2;
  float32x2_t v7 = 0;
  float v8 = 0.0;
  sub_2153CA404((float *)&v7, v6);
  float32_t result = v8 + a1[7].f32[0];
  *a3 = vadd_f32(v7, a1[6]);
  a3[1].f32[0] = result;
  a3[1].i8[4] = 1;
  return result;
}

float sub_2153EDCFC@<S0>(uint64_t a1@<X0>, float32x2_t *a2@<X8>)
{
  a2[1].i8[4] = 1;
  int v3 = *(_DWORD *)(a1 + 16);
  int v4 = *(_DWORD *)(a1 + 36);
  int v5 = *(_DWORD *)(a1 + 40);
  int v7 = *(_DWORD *)(a1 + 20);
  int v6 = *(_DWORD *)(a1 + 24);
  int v8 = *(_DWORD *)(a1 + 28);
  int v9 = *(_DWORD *)(a1 + 32);
  int v10 = *(_DWORD *)(a1 + 44);
  v13[0] = *(_DWORD *)(a1 + 12);
  v13[1] = v6;
  void v13[2] = v4;
  float32x2_t v13[3] = v3;
  v13[4] = v8;
  v13[5] = v5;
  v13[6] = v7;
  v13[7] = v9;
  v13[8] = v10;
  v16[0] = (float *)v13;
  v16[1] = (float *)(a1 + 48);
  float32x2_t v14 = 0;
  float v15 = 0.0;
  sub_2153CA404((float *)&v14, v16);
  float v11 = v15;
  *a2 = vneg_f32(v14);
  float result = -v11;
  a2[1].f32[0] = -v11;
  return result;
}

__n128 sub_2153EDD94@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(unsigned char *)a2 = *(unsigned char *)(a1 + 8);
  *(_OWORD *)(a2 + 4) = *(_OWORD *)(a1 + 12);
  __n128 result = *(__n128 *)(a1 + 28);
  *(__n128 *)(a2 + 20) = result;
  *(_DWORD *)(a2 + 36) = *(_DWORD *)(a1 + 44);
  *(void *)(a2 + 40) = *(void *)(a1 + 48);
  *(_DWORD *)(a2 + 48) = *(_DWORD *)(a1 + 56);
  *(unsigned char *)(a2 + 52) = *(unsigned char *)(a1 + 60);
  return result;
}

uint64_t sub_2153EDDD0(uint64_t result, char a2)
{
  *(unsigned char *)(result + 8) = a2;
  *(unsigned char *)(result + 60) = a2;
  return result;
}

void sub_2153EDDDC()
{
}

uint64_t sub_2153EDE70()
{
  return 0;
}

void sub_2153EDE78()
{
}

uint64_t sub_2153EDE90(int **__s1, _DWORD *a2)
{
  int v4 = *((char *)__s1 + 23);
  if (v4 < 0)
  {
    uint64_t result = 0;
    int v6 = __s1[1];
    int v7 = *__s1;
    switch((unint64_t)v6)
    {
      case 7uLL:
        int v8 = *v7;
        int v9 = *(int *)((char *)v7 + 3);
        if (v8 != 1752066384 || v9 != 1701605224) {
          goto LABEL_30;
        }
LABEL_11:
        float v11 = cva::adp::io::detail::EnumDescription<cva::geo::eCameraType,void>::names;
        goto LABEL_32;
      case 8uLL:
        if (*(void *)v7 != 0x616C696B6B696548) {
          goto LABEL_30;
        }
LABEL_19:
        float v11 = off_264241870;
        goto LABEL_32;
      case 0xBuLL:
        uint64_t v12 = *(void *)v7;
        uint64_t v13 = *(void *)((char *)v7 + 3);
        if (v12 != 0x20656C6F686E6950 || v13 != 0x54554C20656C6F68) {
          goto LABEL_30;
        }
LABEL_25:
        float v11 = off_264241878;
        goto LABEL_32;
      case 0xEuLL:
        uint64_t v15 = *(void *)v7;
        uint64_t v16 = *(void *)((char *)v7 + 6);
        if (v15 == 0x20616C616E6E614BLL && v16 == 0x6C61696461522061)
        {
LABEL_31:
          float v11 = off_264241868;
LABEL_32:
          *a2 = (unint64_t)((char *)v11
                                 - (char *)cva::adp::io::detail::EnumDescription<cva::geo::eCameraType,void>::names) >> 3;
          uint64_t result = 1;
        }
        else
        {
LABEL_30:
          uint64_t result = 0;
        }
        break;
      default:
        return result;
    }
  }
  else
  {
    uint64_t result = 0;
    switch((char)v4)
    {
      case 7:
        if (!memcmp(__s1, "Pinhole", v4)) {
          goto LABEL_11;
        }
        goto LABEL_30;
      case 8:
        if (!memcmp(__s1, "Heikkila", v4)) {
          goto LABEL_19;
        }
        goto LABEL_30;
      case 11:
        if (!memcmp(__s1, "Pinhole LUT", v4)) {
          goto LABEL_25;
        }
        goto LABEL_30;
      case 14:
        if (!memcmp(__s1, "Kannala Radial", v4)) {
          goto LABEL_31;
        }
        goto LABEL_30;
      default:
        return result;
    }
  }
  return result;
}

uint64_t sub_2153EE0BC(std::string::size_type *a1, uint64_t a2, unint64_t *a3, uint64_t a4)
{
  if (*(char *)(a2 + 23) < 0) {
    sub_2153C0AE4(&__dst, *(void **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string __dst = *(std::string *)a2;
  }
  cva::adp::PListPath::convertToPath(a3, (uint64_t)v44);
  if (v45 >= 0) {
    int v8 = (const std::string::value_type *)v44;
  }
  else {
    int v8 = (const std::string::value_type *)v44[0];
  }
  if (v45 >= 0) {
    std::string::size_type v9 = v45;
  }
  else {
    std::string::size_type v9 = v44[1];
  }
  std::string::append(&__dst, v8, v9);
  if (v45 < 0) {
    operator delete((void *)v44[0]);
  }
  v40[0] = 0;
  char v45 = 10;
  strcpy((char *)v44, "Resolution");
  uint64_t v10 = sub_2153C9660(a1, &__dst, (uint64_t)v44);
  uint64_t v11 = v10;
  if (v45 < 0)
  {
    operator delete((void *)v44[0]);
    if (!v11)
    {
LABEL_14:
      if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_15;
      }
      goto LABEL_24;
    }
  }
  else if (!v10)
  {
    goto LABEL_14;
  }
  *(_OWORD *)&v42.__r_.__value_.__l.__data_ = 0uLL;
  char v45 = 12;
  strcpy((char *)v44, "Image Bounds");
  char v12 = sub_2153F1A10(a1, &__dst, (uint64_t)v44);
  char v13 = v12;
  if (v45 < 0)
  {
    operator delete((void *)v44[0]);
    if (v13) {
      goto LABEL_20;
    }
  }
  else if (v12)
  {
LABEL_20:
    *(_OWORD *)(a4 + 28) = *(_OWORD *)&v42.__r_.__value_.__l.__data_;
    unint64_t v14 = v40[0];
    goto LABEL_23;
  }
  float v15 = (float)LODWORD(v40[0]);
  float v16 = (float)HIDWORD(v40[0]);
  unint64_t v14 = LODWORD(v40[0]) | ((unint64_t)HIDWORD(v40[0]) << 32);
  *(_DWORD *)(a4 + 28) = 0;
  *(float *)(a4 + 32) = v15;
  *(_DWORD *)(a4 + 36) = 0;
  *(float *)(a4 + 40) = v16;
LABEL_23:
  *(void *)(a4 + 44) = v14;
  if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_15:
    if (!v11) {
      return v11;
    }
LABEL_25:
    if (*(char *)(a2 + 23) < 0) {
      sub_2153C0AE4(&__dst, *(void **)a2, *(void *)(a2 + 8));
    }
    else {
      std::string __dst = *(std::string *)a2;
    }
    cva::adp::PListPath::convertToPath(a3, (uint64_t)v44);
    if (v45 >= 0) {
      float32x2_t v17 = (const std::string::value_type *)v44;
    }
    else {
      float32x2_t v17 = (const std::string::value_type *)v44[0];
    }
    if (v45 >= 0) {
      std::string::size_type v18 = v45;
    }
    else {
      std::string::size_type v18 = v44[1];
    }
    std::string::append(&__dst, v17, v18);
    if (v45 < 0) {
      operator delete((void *)v44[0]);
    }
    char v41 = 7;
    strcpy((char *)v40, "Pinhole");
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      sub_2153C0AE4(&v42, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
    }
    else {
      std::string v42 = __dst;
    }
    cva::adp::PListPath::convertToPath(v40, (uint64_t)v44);
    if (v45 >= 0) {
      char v19 = (const std::string::value_type *)v44;
    }
    else {
      char v19 = (const std::string::value_type *)v44[0];
    }
    if (v45 >= 0) {
      std::string::size_type v20 = v45;
    }
    else {
      std::string::size_type v20 = v44[1];
    }
    std::string::append(&v42, v19, v20);
    if (v45 < 0)
    {
      operator delete((void *)v44[0]);
      if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_47;
      }
    }
    else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_47;
    }
    operator delete(__dst.__r_.__value_.__l.__data_);
LABEL_47:
    int v38 = 0;
    char v39 = 1;
    char v45 = 12;
    strcpy((char *)v44, "Focal Length");
    int v21 = sub_2153F1F04(a1, (uint64_t)&v42, v44, (uint64_t)&v38);
    char v22 = v39;
    long long v23 = (int *)(a4 + 32);
    if (v21) {
      long long v23 = &v38;
    }
    else {
      char v22 = 1;
    }
    *(_DWORD *)a4 = *v23;
    *(unsigned char *)(a4 + 4) = v22;
    float v36 = 0.0;
    char v37 = 1;
    char v45 = 12;
    strcpy((char *)v44, "Aspect Ratio");
    int v24 = sub_2153F1F04(a1, (uint64_t)&v42, v44, (uint64_t)&v36);
    float v25 = v36;
    char v26 = v37;
    if (!v24)
    {
      float v25 = 1.0;
      char v26 = 1;
    }
    *(float *)(a4 + 8) = v25;
    *(unsigned char *)(a4 + 12) = v26;
    char v41 = 15;
    strcpy((char *)v40, "Principal Point");
    if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
      sub_2153C0AE4(&__dst, v42.__r_.__value_.__l.__data_, v42.__r_.__value_.__l.__size_);
    }
    else {
      std::string __dst = v42;
    }
    cva::adp::PListPath::convertToPath(v40, (uint64_t)v44);
    if (v45 >= 0) {
      float32x2_t v27 = (const std::string::value_type *)v44;
    }
    else {
      float32x2_t v27 = (const std::string::value_type *)v44[0];
    }
    if (v45 >= 0) {
      std::string::size_type v28 = v45;
    }
    else {
      std::string::size_type v28 = v44[1];
    }
    std::string::append(&__dst, v27, v28);
    if (v45 < 0) {
      operator delete((void *)v44[0]);
    }
    char v45 = 4;
    strcpy((char *)v44, "Data");
    int v29 = sub_2153EFDD4(a1, &__dst, (uint64_t)v44);
    int v30 = v29;
    if (v45 < 0)
    {
      operator delete((void *)v44[0]);
      if (!v30)
      {
LABEL_67:
        if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_68;
        }
        goto LABEL_77;
      }
    }
    else if (!v29)
    {
      goto LABEL_67;
    }
    char v45 = 5;
    strcpy((char *)v44, "Fixed");
    uint64_t v32 = (char *)(a4 + 24);
    int v33 = cva::adp::io::PListSerializer::getItem<BOOL>(a1, &__dst, (uint64_t)v44, (unsigned char *)(a4 + 24));
    if (v45 < 0) {
      operator delete((void *)v44[0]);
    }
    char v34 = *v32 ^ 1;
    if (!v33) {
      char v34 = 1;
    }
    *uint64_t v32 = v34;
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_68:
      if (v30) {
        goto LABEL_69;
      }
      goto LABEL_78;
    }
LABEL_77:
    operator delete(__dst.__r_.__value_.__l.__data_);
    if (v30)
    {
LABEL_69:
      if ((SHIBYTE(v42.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        return v11;
      }
LABEL_79:
      operator delete(v42.__r_.__value_.__l.__data_);
      return v11;
    }
LABEL_78:
    float v35 = *(float *)(a4 + 40) * 0.5;
    *(float *)(a4 + 16) = *(float *)(a4 + 32) * 0.5;
    *(float *)(a4 + 20) = v35;
    *(unsigned char *)(a4 + 24) = 1;
    if ((SHIBYTE(v42.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return v11;
    }
    goto LABEL_79;
  }
LABEL_24:
  operator delete(__dst.__r_.__value_.__l.__data_);
  if (v11) {
    goto LABEL_25;
  }
  return v11;
}

BOOL sub_2153EE5E8(uint64_t a1, uint64_t a2, float a3)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a2 + 16))(a2) != 3) {
    return 0;
  }
  if ((float)(*(float *)(a1 + 20) - *(float *)(a2 + 20)) >= a3) {
    return 0;
  }
  if ((float)(*(float *)(a1 + 28) - *(float *)(a2 + 28)) >= a3) {
    return 0;
  }
  float32x2_t v6 = vsub_f32(*(float32x2_t *)(a1 + 36), *(float32x2_t *)(a2 + 36));
  if (sqrtf(vaddv_f32(vmul_f32(v6, v6))) >= a3) {
    return 0;
  }
  if (*(unsigned __int8 *)(a1 + 44) != *(unsigned __int8 *)(a2 + 44)) {
    return 0;
  }
  float32x2_t v7 = vsub_f32(*(float32x2_t *)(a1 + 48), *(float32x2_t *)(a2 + 48));
  float32x2_t v8 = vmul_f32(v7, v7);
  float32x2_t v9 = vsub_f32(*(float32x2_t *)(a1 + 56), *(float32x2_t *)(a2 + 56));
  float32x2_t v10 = vmul_f32(v9, v9);
  if (sqrtf(vadd_f32(vadd_f32(vadd_f32(v8, (float32x2_t)vdup_lane_s32((int32x2_t)v8, 1)), v10), (float32x2_t)vdup_lane_s32((int32x2_t)v10, 1)).f32[0]) >= a3)return 0; {
  if (*(_DWORD *)(a1 + 64) != *(_DWORD *)(a2 + 64))
  }
    return 0;
  if (*(_DWORD *)(a1 + 68) != *(_DWORD *)(a2 + 68)) {
    return 0;
  }
  uint64_t v11 = 0;
  float v12 = (float)(*(float *)(a1 + 88) - *(float *)(a2 + 88)) * (float)(*(float *)(a1 + 88) - *(float *)(a2 + 88));
  do
  {
    float32x4_t v13 = vsubq_f32(*(float32x4_t *)(a1 + v11 + 92), *(float32x4_t *)(a2 + v11 + 92));
    float32x4_t v14 = vsubq_f32(*(float32x4_t *)(a1 + v11 + 108), *(float32x4_t *)(a2 + v11 + 108));
    float32x4_t v15 = vmulq_f32(v13, v13);
    float32x4_t v16 = vmulq_f32(v14, v14);
    float v12 = (float)((float)((float)((float)((float)((float)((float)(v12 + v15.f32[0]) + v15.f32[1]) + v15.f32[2])
                                        + v15.f32[3])
                                + v16.f32[0])
                        + v16.f32[1])
                + v16.f32[2])
        + v16.f32[3];
    v11 += 32;
  }
  while (v11 != 992);
  float v17 = *(float *)(a1 + 1084) - *(float *)(a2 + 1084);
  float v18 = v12 + (float)(v17 * v17);
  float32x2_t v19 = vsub_f32(*(float32x2_t *)(a1 + 1088), *(float32x2_t *)(a2 + 1088));
  float32x2_t v20 = vmul_f32(v19, v19);
  float v21 = (float)(v18 + v20.f32[0]) + v20.f32[1];
  float32x2_t v22 = vsub_f32(*(float32x2_t *)(a1 + 1096), *(float32x2_t *)(a2 + 1096));
  float32x2_t v23 = vmul_f32(v22, v22);
  float v24 = (float)(v21 + v23.f32[0]) + v23.f32[1];
  float32x2_t v25 = vsub_f32(*(float32x2_t *)(a1 + 1104), *(float32x2_t *)(a2 + 1104));
  float32x2_t v26 = vmul_f32(v25, v25);
  if (sqrtf((float)(v24 + v26.f32[0]) + v26.f32[1]) >= a3) {
    return 0;
  }
  uint64_t v27 = 0;
  float v28 = (float)(*(float *)(a1 + 1112) - *(float *)(a2 + 1112)) * (float)(*(float *)(a1 + 1112) - *(float *)(a2 + 1112));
  do
  {
    float32x4_t v29 = vsubq_f32(*(float32x4_t *)(a1 + v27 + 1116), *(float32x4_t *)(a2 + v27 + 1116));
    float32x4_t v30 = vsubq_f32(*(float32x4_t *)(a1 + v27 + 1132), *(float32x4_t *)(a2 + v27 + 1132));
    float32x4_t v31 = vmulq_f32(v29, v29);
    float32x4_t v32 = vmulq_f32(v30, v30);
    float v28 = (float)((float)((float)((float)((float)((float)((float)(v28 + v31.f32[0]) + v31.f32[1]) + v31.f32[2])
                                        + v31.f32[3])
                                + v32.f32[0])
                        + v32.f32[1])
                + v32.f32[2])
        + v32.f32[3];
    v27 += 32;
  }
  while (v27 != 992);
  float v33 = *(float *)(a1 + 2108) - *(float *)(a2 + 2108);
  float v34 = v28 + (float)(v33 * v33);
  float32x2_t v35 = vsub_f32(*(float32x2_t *)(a1 + 2112), *(float32x2_t *)(a2 + 2112));
  float32x2_t v36 = vmul_f32(v35, v35);
  float v37 = (float)(v34 + v36.f32[0]) + v36.f32[1];
  float32x2_t v38 = vsub_f32(*(float32x2_t *)(a1 + 2120), *(float32x2_t *)(a2 + 2120));
  float32x2_t v39 = vmul_f32(v38, v38);
  float v40 = (float)(v37 + v39.f32[0]) + v39.f32[1];
  float32x2_t v41 = vsub_f32(*(float32x2_t *)(a1 + 2128), *(float32x2_t *)(a2 + 2128));
  float32x2_t v42 = vmul_f32(v41, v41);
  if (sqrtf((float)(v40 + v42.f32[0]) + v42.f32[1]) >= a3
    || vabds_f32(*(float *)(a1 + 72), *(float *)(a1 + 72)) >= a3
    || vabds_f32(*(float *)(a1 + 76), *(float *)(a1 + 76)) >= a3)
  {
    return 0;
  }
  float32x2_t v43 = vsub_f32(*(float32x2_t *)(a1 + 80), *(float32x2_t *)(a2 + 80));
  return sqrtf(vaddv_f32(vmul_f32(v43, v43))) < a3;
}

void *sub_2153EE938(__n128 *a1, void *a2)
{
  uint64_t v4 = (uint64_t)a1[1].n128_i64 + 4;
  sub_2153EE9A0(a1 + 3, a2);
  sub_2153EEA44(v4, a2);
  sub_2153EEB74((uint64_t)&a1[1].n128_i64[1] + 4, a2);
  return sub_2153EECA4((uint64_t)a1[2].n128_i64 + 4, a2);
}

void *sub_2153EE9A0(__n128 *a1, void *a2)
{
  uint64_t v4 = sub_2153C1168(a2, (uint64_t)"[FIXED][", 8);
  char v10 = 16;
  strcpy(__p, "Width and Height");
  int v5 = sub_2153C1168(v4, (uint64_t)__p, 16);
  float32x2_t v6 = sub_2153C1168(v5, (uint64_t)"] : ", 4);
  float32x2_t v7 = sub_2153EEDD0(v6, *a1);
  sub_2153C1168(v7, (uint64_t)"\n", 1);
  if (v10 < 0) {
    operator delete(*(void **)__p);
  }
  return a2;
}

void *sub_2153EEA44(uint64_t a1, void *a2)
{
  if (*(unsigned char *)(a1 + 4)) {
    int v3 = "[FREE]";
  }
  else {
    int v3 = "[FIXED]";
  }
  if (*(unsigned char *)(a1 + 4)) {
    size_t v4 = 6;
  }
  else {
    size_t v4 = 7;
  }
  unsigned __int8 v15 = v4;
  memcpy(__dst, v3, v4);
  *(unsigned char *)((unint64_t)__dst | v4) = 0;
  if ((v15 & 0x80u) == 0) {
    int v5 = __dst;
  }
  else {
    int v5 = (void **)__dst[0];
  }
  if ((v15 & 0x80u) == 0) {
    uint64_t v6 = v15;
  }
  else {
    uint64_t v6 = (uint64_t)__dst[1];
  }
  float32x2_t v7 = sub_2153C1168(a2, (uint64_t)v5, v6);
  float32x2_t v8 = sub_2153C1168(v7, (uint64_t)"[", 1);
  char v13 = 12;
  strcpy((char *)__p, "Focal Length");
  float32x2_t v9 = sub_2153C1168(v8, (uint64_t)__p, 12);
  sub_2153C1168(v9, (uint64_t)"] : ", 4);
  char v10 = (void *)std::ostream::operator<<();
  sub_2153C1168(v10, (uint64_t)"\n", 1);
  if (v13 < 0)
  {
    operator delete(__p[0]);
    if (((char)v15 & 0x80000000) == 0) {
      return a2;
    }
LABEL_17:
    operator delete(__dst[0]);
    return a2;
  }
  if ((char)v15 < 0) {
    goto LABEL_17;
  }
  return a2;
}

void *sub_2153EEB74(uint64_t a1, void *a2)
{
  if (*(unsigned char *)(a1 + 4)) {
    int v3 = "[FREE]";
  }
  else {
    int v3 = "[FIXED]";
  }
  if (*(unsigned char *)(a1 + 4)) {
    size_t v4 = 6;
  }
  else {
    size_t v4 = 7;
  }
  unsigned __int8 v15 = v4;
  memcpy(__dst, v3, v4);
  *(unsigned char *)((unint64_t)__dst | v4) = 0;
  if ((v15 & 0x80u) == 0) {
    int v5 = __dst;
  }
  else {
    int v5 = (void **)__dst[0];
  }
  if ((v15 & 0x80u) == 0) {
    uint64_t v6 = v15;
  }
  else {
    uint64_t v6 = (uint64_t)__dst[1];
  }
  float32x2_t v7 = sub_2153C1168(a2, (uint64_t)v5, v6);
  float32x2_t v8 = sub_2153C1168(v7, (uint64_t)"[", 1);
  char v13 = 12;
  strcpy((char *)__p, "Aspect Ratio");
  float32x2_t v9 = sub_2153C1168(v8, (uint64_t)__p, 12);
  sub_2153C1168(v9, (uint64_t)"] : ", 4);
  char v10 = (void *)std::ostream::operator<<();
  sub_2153C1168(v10, (uint64_t)"\n", 1);
  if (v13 < 0)
  {
    operator delete(__p[0]);
    if (((char)v15 & 0x80000000) == 0) {
      return a2;
    }
LABEL_17:
    operator delete(__dst[0]);
    return a2;
  }
  if ((char)v15 < 0) {
    goto LABEL_17;
  }
  return a2;
}

void *sub_2153EECA4(uint64_t a1, void *a2)
{
  if (*(unsigned char *)(a1 + 8)) {
    size_t v4 = "[FREE]";
  }
  else {
    size_t v4 = "[FIXED]";
  }
  if (*(unsigned char *)(a1 + 8)) {
    size_t v5 = 6;
  }
  else {
    size_t v5 = 7;
  }
  unsigned __int8 v17 = v5;
  memcpy(__dst, v4, v5);
  *(unsigned char *)((unint64_t)__dst | v5) = 0;
  if ((v17 & 0x80u) == 0) {
    uint64_t v6 = __dst;
  }
  else {
    uint64_t v6 = (void **)__dst[0];
  }
  if ((v17 & 0x80u) == 0) {
    uint64_t v7 = v17;
  }
  else {
    uint64_t v7 = (uint64_t)__dst[1];
  }
  float32x2_t v8 = sub_2153C1168(a2, (uint64_t)v6, v7);
  float32x2_t v9 = sub_2153C1168(v8, (uint64_t)"[", 1);
  char v15 = 15;
  strcpy((char *)__p, "Principal Point");
  char v10 = sub_2153C1168(v9, (uint64_t)__p, 15);
  uint64_t v11 = sub_2153C1168(v10, (uint64_t)"] : ", 4);
  float v12 = sub_2153EBB18(v11, *(double *)a1);
  sub_2153C1168(v12, (uint64_t)"\n", 1);
  if (v15 < 0)
  {
    operator delete(__p[0]);
    if (((char)v17 & 0x80000000) == 0) {
      return a2;
    }
LABEL_17:
    operator delete(__dst[0]);
    return a2;
  }
  if ((char)v17 < 0) {
    goto LABEL_17;
  }
  return a2;
}

uint64_t *sub_2153EEDD0(uint64_t *a1, __n128 a2)
{
  __n128 v92 = a2;
  int v3 = (char *)a1 + *(void *)(*a1 - 24);
  int v4 = *((_DWORD *)v3 + 2);
  size_t v6 = *((void *)v3 + 2);
  int64_t v5 = *((void *)v3 + 3);
  if (v5)
  {
    if (v5 <= (uint64_t)(v6 + 2)) {
      int64_t v5 = v6 + 2;
    }
    size_t v7 = v5 + ~v6;
    double v8 = __exp10((double)-(uint64_t)v6);
    size_t v9 = v7 - 1;
    if (v7 - 1 > 0x7FFFFFFFFFFFFFF7) {
LABEL_133:
    }
      abort();
    double v10 = v8;
    if (v9 >= 0x17)
    {
      uint64_t v12 = (v9 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v9 | 7) != 0x17) {
        uint64_t v12 = v9 | 7;
      }
      uint64_t v13 = v12 + 1;
      p_b = (std::string *)operator new(v12 + 1);
      __b.__r_.__value_.__l.__size_ = v7 - 1;
      __b.__r_.__value_.__r.__words[2] = v13 | 0x8000000000000000;
      __b.__r_.__value_.__r.__words[0] = (std::string::size_type)p_b;
    }
    else
    {
      *((unsigned char *)&__b.__r_.__value_.__s + 23) = v7 - 1;
      p_b = &__b;
      if (v7 == 1)
      {
        LODWORD(v7) = 1;
        goto LABEL_13;
      }
    }
  }
  else
  {
    double v10 = __exp10((double)-(uint64_t)v6);
    size_t v9 = 3;
    *((unsigned char *)&__b.__r_.__value_.__s + 23) = 3;
    p_b = &__b;
    LODWORD(v7) = 4;
  }
  memset(p_b, 32, v9);
LABEL_13:
  p_b->__r_.__value_.__s.__data_[v9] = 0;
  float32x4_t v14 = std::string::append(&__b, "0 ");
  std::string::size_type v15 = v14->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v93.__r_.__value_.__l.__data_ = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  v93.__r_.__value_.__r.__words[2] = v15;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  if (v6 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_133;
  }
  if (v6 >= 0x17)
  {
    uint64_t v17 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17) {
      uint64_t v17 = v6 | 7;
    }
    uint64_t v18 = v17 + 1;
    float32x4_t v16 = operator new(v17 + 1);
    std::string::size_type v87 = v6;
    int64_t v88 = v18 | 0x8000000000000000;
    uint64_t v86 = v16;
    goto LABEL_20;
  }
  HIBYTE(v88) = v6;
  float32x4_t v16 = &v86;
  if (v6) {
LABEL_20:
  }
    memset(v16, 32, v6);
  *((unsigned char *)v16 + v6) = 0;
  if (v88 >= 0) {
    float32x2_t v19 = (const std::string::value_type *)&v86;
  }
  else {
    float32x2_t v19 = (const std::string::value_type *)v86;
  }
  if (v88 >= 0) {
    std::string::size_type v20 = HIBYTE(v88);
  }
  else {
    std::string::size_type v20 = v87;
  }
  float v21 = std::string::append(&v93, v19, v20);
  std::string::size_type v22 = v21->__r_.__value_.__r.__words[2];
  *(_OWORD *)long long __p = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
  uint64_t v91 = v22;
  v21->__r_.__value_.__l.__size_ = 0;
  v21->__r_.__value_.__r.__words[2] = 0;
  v21->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v88) < 0)
  {
    operator delete(v86);
    if ((SHIBYTE(v93.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_29;
    }
LABEL_132:
    operator delete(v93.__r_.__value_.__l.__data_);
    goto LABEL_29;
  }
  if (SHIBYTE(v93.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_132;
  }
LABEL_29:
  int v80 = v4;
  if (SHIBYTE(__b.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__b.__r_.__value_.__l.__data_);
  }
  uint64_t v84 = a1 + 1;
  *(uint64_t *)((char *)a1 + *(void *)(*a1 - 24) + 24) = 0;
  v93.__r_.__value_.__s.__data_[0] = 91;
  sub_2153C1168(a1, (uint64_t)&v93, 1);
  uint64_t v24 = 0;
  uint64_t v85 = (int)v7 + (int)v6 + 1;
  uint64_t v82 = (int)v6;
  uint64_t v83 = (int)v6 - 3;
  while (1)
  {
    float v25 = v92.n128_f32[v24];
    v23.n128_f64[0] = v25;
    uint64_t v26 = *a1;
    uint64_t v27 = (char *)a1 + *(void *)(*a1 - 24);
    if (v27[9]) {
      break;
    }
    if (fabs(v23.n128_f64[0]) < v10)
    {
      float v28 = (char *)HIBYTE(v91);
      float32x4_t v29 = (char *)__p[1];
      if (v91 >= 0) {
        float32x4_t v30 = __p;
      }
      else {
        float32x4_t v30 = (void **)__p[0];
      }
      MEMORY[0x2166B95F0](&__b, a1);
      if (__b.__r_.__value_.__s.__data_[0])
      {
        if ((char)v28 >= 0) {
          float32x4_t v31 = v28;
        }
        else {
          float32x4_t v31 = v29;
        }
        float32x4_t v32 = (char *)a1 + *(void *)(*a1 - 24);
        uint64_t v33 = *((void *)v32 + 5);
        float v34 = &v31[(void)v30];
        if ((*((_DWORD *)v32 + 2) & 0xB0) == 0x20) {
          float32x2_t v35 = (void **)&v31[(void)v30];
        }
        else {
          float32x2_t v35 = v30;
        }
        int v36 = *((_DWORD *)v32 + 36);
        if (v36 == -1)
        {
          int v44 = v35;
          std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
          char v45 = std::locale::use_facet((const std::locale *)&v93, MEMORY[0x263F8C108]);
          int v36 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v45->__vftable[2].~facet_0)(v45, 32);
          std::locale::~locale((std::locale *)&v93);
          float32x2_t v35 = v44;
          *((_DWORD *)v32 + 36) = v36;
          if (!v33) {
            goto LABEL_96;
          }
        }
        else if (!v33)
        {
          goto LABEL_96;
        }
        uint64_t v46 = *((void *)v32 + 3);
        BOOL v47 = v46 <= (uint64_t)v31;
        std::string::size_type v48 = v46 - (void)v31;
        if (v47) {
          std::string::size_type v49 = 0;
        }
        else {
          std::string::size_type v49 = v48;
        }
        int64_t v50 = (char *)v35 - (char *)v30;
        if ((char *)v35 - (char *)v30 >= 1)
        {
          int64_t v51 = v35;
          uint64_t v52 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v33 + 96))(v33, v30, v50);
          float32x2_t v35 = v51;
          if (v52 != v50) {
            goto LABEL_96;
          }
        }
        goto LABEL_80;
      }
      goto LABEL_97;
    }
    *((void *)v27 + 3) = v85;
    *(_DWORD *)((char *)v84 + *(void *)(v26 - 24)) = *(_DWORD *)((unsigned char *)v84 + *(void *)(v26 - 24)) & 0xFFFFFEFB | 4;
    *(_DWORD *)((char *)v84 + *(void *)(v26 - 24)) |= 0x400u;
    uint64_t v37 = *(void *)(v26 - 24);
    float32x2_t v38 = a1 + 2;
    uint64_t v39 = v82;
LABEL_52:
    *(void *)((char *)v38 + v37) = v39;
    std::ostream::operator<<();
    if (v24 == 3) {
      goto LABEL_128;
    }
LABEL_98:
    LOBYTE(v86) = 44;
    MEMORY[0x2166B95F0](&__b, a1);
    if (__b.__r_.__value_.__s.__data_[0])
    {
      uint64_t v65 = (char *)a1 + *(void *)(*a1 - 24);
      uint64_t v66 = *((void *)v65 + 5);
      if ((*((_DWORD *)v65 + 2) & 0xB0) == 0x20) {
        uint64_t v67 = (void **)((char *)&v86 + 1);
      }
      else {
        uint64_t v67 = &v86;
      }
      int v68 = *((_DWORD *)v65 + 36);
      if (v68 == -1)
      {
        std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
        int v69 = std::locale::use_facet((const std::locale *)&v93, MEMORY[0x263F8C108]);
        int v68 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v69->__vftable[2].~facet_0)(v69, 32);
        std::locale::~locale((std::locale *)&v93);
        *((_DWORD *)v65 + 36) = v68;
        if (!v66) {
          goto LABEL_32;
        }
      }
      else if (!v66)
      {
        goto LABEL_32;
      }
      uint64_t v70 = *((void *)v65 + 3);
      BOOL v47 = v70 <= 1;
      std::string::size_type v71 = v70 - 1;
      if (v47) {
        std::string::size_type v72 = 0;
      }
      else {
        std::string::size_type v72 = v71;
      }
      if ((char *)v67 - (char *)&v86 >= 1
        && (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v66 + 96))(v66, &v86, (char *)v67 - (char *)&v86) != (char *)v67 - (char *)&v86)
      {
        goto LABEL_32;
      }
      if ((uint64_t)v72 >= 1)
      {
        if (v72 > 0x7FFFFFFFFFFFFFF7) {
          goto LABEL_133;
        }
        if (v72 >= 0x17)
        {
          uint64_t v74 = (v72 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v72 | 7) != 0x17) {
            uint64_t v74 = v72 | 7;
          }
          uint64_t v75 = v74 + 1;
          std::string::size_type v73 = operator new(v74 + 1);
          v93.__r_.__value_.__l.__size_ = v72;
          v93.__r_.__value_.__r.__words[2] = v75 | 0x8000000000000000;
          v93.__r_.__value_.__r.__words[0] = (std::string::size_type)v73;
        }
        else
        {
          *((unsigned char *)&v93.__r_.__value_.__s + 23) = v72;
          std::string::size_type v73 = &v93;
        }
        memset(v73, v68, v72);
        *((unsigned char *)v73 + v72) = 0;
        if ((v93.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v76 = &v93;
        }
        else {
          uint64_t v76 = (std::string *)v93.__r_.__value_.__r.__words[0];
        }
        uint64_t v77 = (*(uint64_t (**)(uint64_t, std::string *, std::string::size_type))(*(void *)v66 + 96))(v66, v76, v72);
        uint64_t v78 = v77;
        if (SHIBYTE(v93.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v93.__r_.__value_.__l.__data_);
          if (v78 != v72) {
            goto LABEL_32;
          }
        }
        else if (v77 != v72)
        {
          goto LABEL_32;
        }
      }
      if ((char *)&v86 + 1 - (char *)v67 >= 1
        && (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v66 + 96))(v66, v67, (char *)&v86 + 1 - (char *)v67) != (char *)&v86 + 1 - (char *)v67)
      {
LABEL_32:
        std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
        goto LABEL_33;
      }
      *((void *)v65 + 3) = 0;
    }
LABEL_33:
    MEMORY[0x2166B9600](&__b);
    ++v24;
  }
  if (v25 != 0.0)
  {
    *((void *)v27 + 3) = v85;
    *(_DWORD *)((char *)v84 + *(void *)(v26 - 24)) |= 0x400u;
    uint64_t v37 = *(void *)(v26 - 24);
    float32x2_t v38 = a1 + 2;
    uint64_t v39 = v83;
    goto LABEL_52;
  }
  float v40 = (char *)HIBYTE(v91);
  float32x2_t v41 = (char *)__p[1];
  if (v91 >= 0) {
    float32x2_t v42 = __p;
  }
  else {
    float32x2_t v42 = (void **)__p[0];
  }
  MEMORY[0x2166B95F0](&__b, a1, v23);
  if (__b.__r_.__value_.__s.__data_[0])
  {
    if ((char)v40 >= 0) {
      float32x2_t v43 = v40;
    }
    else {
      float32x2_t v43 = v41;
    }
    float32x4_t v32 = (char *)a1 + *(void *)(*a1 - 24);
    uint64_t v33 = *((void *)v32 + 5);
    float v34 = &v43[(void)v42];
    if ((*((_DWORD *)v32 + 2) & 0xB0) == 0x20) {
      float32x2_t v35 = (void **)&v43[(void)v42];
    }
    else {
      float32x2_t v35 = v42;
    }
    int v36 = *((_DWORD *)v32 + 36);
    if (v36 != -1)
    {
      if (!v33) {
        goto LABEL_96;
      }
LABEL_75:
      uint64_t v55 = *((void *)v32 + 3);
      BOOL v47 = v55 <= (uint64_t)v43;
      std::string::size_type v56 = v55 - (void)v43;
      if (v47) {
        std::string::size_type v49 = 0;
      }
      else {
        std::string::size_type v49 = v56;
      }
      int64_t v57 = (char *)v35 - (char *)v42;
      if ((char *)v35 - (char *)v42 >= 1)
      {
        int64_t v58 = v35;
        uint64_t v59 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v33 + 96))(v33, v42, v57);
        float32x2_t v35 = v58;
        if (v59 != v57) {
          goto LABEL_96;
        }
      }
LABEL_80:
      if ((uint64_t)v49 < 1) {
        goto LABEL_94;
      }
      if (v49 > 0x7FFFFFFFFFFFFFF7) {
        goto LABEL_133;
      }
      int v81 = v35;
      if (v49 >= 0x17)
      {
        uint64_t v61 = (v49 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v49 | 7) != 0x17) {
          uint64_t v61 = v49 | 7;
        }
        uint64_t v62 = v61 + 1;
        uint64_t v60 = operator new(v61 + 1);
        v93.__r_.__value_.__l.__size_ = v49;
        v93.__r_.__value_.__r.__words[2] = v62 | 0x8000000000000000;
        v93.__r_.__value_.__r.__words[0] = (std::string::size_type)v60;
      }
      else
      {
        *((unsigned char *)&v93.__r_.__value_.__s + 23) = v49;
        uint64_t v60 = &v93;
      }
      memset(v60, v36, v49);
      *((unsigned char *)v60 + v49) = 0;
      if ((v93.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v63 = &v93;
      }
      else {
        uint64_t v63 = (std::string *)v93.__r_.__value_.__r.__words[0];
      }
      uint64_t v64 = (*(uint64_t (**)(uint64_t, std::string *, std::string::size_type))(*(void *)v33 + 96))(v33, v63, v49);
      if (SHIBYTE(v93.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v93.__r_.__value_.__l.__data_);
      }
      float32x2_t v35 = v81;
      if (v64 == v49)
      {
LABEL_94:
        if (v34 - (char *)v35 < 1
          || (*(uint64_t (**)(uint64_t))(*(void *)v33 + 96))(v33) == v34 - (char *)v35)
        {
          *((void *)v32 + 3) = 0;
          goto LABEL_97;
        }
      }
      goto LABEL_96;
    }
    uint64_t v53 = v35;
    std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
    uint64_t v54 = std::locale::use_facet((const std::locale *)&v93, MEMORY[0x263F8C108]);
    int v36 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v54->__vftable[2].~facet_0)(v54, 32);
    std::locale::~locale((std::locale *)&v93);
    float32x2_t v35 = v53;
    *((_DWORD *)v32 + 36) = v36;
    if (v33) {
      goto LABEL_75;
    }
LABEL_96:
    std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
  }
LABEL_97:
  MEMORY[0x2166B9600](&__b);
  if (v24 != 3) {
    goto LABEL_98;
  }
LABEL_128:
  sub_2153C1168(a1, (uint64_t)"   ]", 4);
  *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 8) = v80;
  if (SHIBYTE(v91) < 0) {
    operator delete(__p[0]);
  }
  return a1;
}

uint64_t sub_2153EF7F0(uint64_t a1, unint64_t *a2, float32x2_t *a3, int32x4_t a4)
{
  uint64_t result = 0;
  a4.i64[0] = *a2;
  float32x4_t v6 = (float32x4_t)vzip1q_s32(a4, a4);
  if ((vmaxv_u16((uint16x4_t)vtrn2_s16(vrev32_s16(vmovn_s32(vcgtq_f32(*(float32x4_t *)(a1 + 48), v6))), vmovn_s32(vcgeq_f32(v6, *(float32x4_t *)(a1 + 48))))) & 1) == 0)
  {
    float v7 = *(float *)(a1 + 20);
    float v8 = *(float *)(a1 + 28);
    if (v7 >= 0.000000014901 && v8 >= 0.000000014901)
    {
      v11.f32[0] = v7 * v8;
      v11.i32[1] = *(_DWORD *)(a1 + 20);
      float32x2_t v12 = vdiv_f32(vsub_f32(*(float32x2_t *)a4.i8, *(float32x2_t *)(a1 + 36)), v11);
      float v13 = atanf(sqrtf(vaddv_f32(vmul_f32(v12, v12))));
      float v14 = *(float *)(a1 + 76);
      if (v13 >= v14)
      {
        return 0;
      }
      else
      {
        float v15 = (float)(v13 / v14) * 255.0;
        unsigned int v16 = v15;
        if (v15 > 0xFE)
        {
          float v18 = *(float *)(a1 + 4 * v16 + 1112);
        }
        else
        {
          float v17 = *(float *)(a1 + 1112 + 4 * v16);
          float v18 = v17 + (float)((float)(v15 - (float)v16) * (float)(*(float *)(a1 + 1112 + 4 * (v16 + 1)) - v17));
        }
        *a3 = vmul_n_f32(v12, v18);
        return 1;
      }
    }
  }
  return result;
}

BOOL sub_2153EF8F8(float *a1, float *a2, float *a3)
{
  float v3 = a2[2];
  if (v3 <= 0.0) {
    return 0;
  }
  float v6 = a1[20];
  float v7 = a1[21];
  float v8 = *a2 - v6;
  float v9 = a2[1] - v7;
  float v10 = atan2f(sqrtf((float)(v8 * v8) + (float)(v9 * v9)), a2[2]);
  float v11 = a1[18];
  if (v10 >= v11) {
    return 0;
  }
  float v12 = (float)(v10 / v11) * 255.0;
  unsigned int v13 = v12;
  if (v12 > 0xFE)
  {
    float v15 = a1[v13 + 22];
  }
  else
  {
    float v14 = a1[v13 + 22];
    float v15 = v14 + (float)((float)(v12 - (float)v13) * (float)(a1[v13 + 23] - v14));
  }
  float v17 = v15 / v3;
  float v18 = a1[5];
  float v19 = a1[9] + (float)((float)(v18 * a1[7]) * (float)(v6 + (float)(v8 * v17)));
  float v20 = a1[10] + (float)(v18 * (float)(v7 + (float)(v9 * v17)));
  *a3 = v19;
  a3[1] = v20;
  BOOL v21 = a1[12] <= v19;
  if (a1[13] <= v19) {
    BOOL v21 = 0;
  }
  if (a1[14] > v20) {
    BOOL v21 = 0;
  }
  return a1[15] > v20 && v21;
}

unsigned char *sub_2153EFA1C(unsigned char *result, char a2)
{
  result[24] = a2;
  result[32] = a2;
  result[44] = a2;
  return result;
}

void sub_2153EFA2C()
{
}

uint64_t sub_2153EFAF0(uint64_t a1)
{
  return a1 + 48;
}

uint64_t sub_2153EFAF8()
{
  return 3;
}

void sub_2153EFB00()
{
}

uint64_t sub_2153EFB18(std::string::size_type *a1, std::string *a2, uint64_t a3)
{
  cva::adp::io::PListSerializer::getPath(a1, a2, &v15);
  std::string::size_type v4 = v15;
  if (!v15)
  {
    float v10 = v16;
    if (!v16) {
      return 0;
    }
    goto LABEL_13;
  }
  if (*(char *)(a3 + 23) >= 0) {
    int64_t v5 = (const char *)a3;
  }
  else {
    int64_t v5 = *(const char **)a3;
  }
  CFStringRef v6 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v5, 0x8000100u, (CFAllocatorRef)*MEMORY[0x263EFFB28]);
  CFStringRef v7 = (const __CFString *)[*(id *)v4 objectForKey:v6];
  CFStringRef v8 = v7;
  char v9 = *(unsigned char *)(v4 + 8);
  CFTypeRef cf = v7;
  char v14 = v9;
  if (v7)
  {
    CFRetain(v7);
    CFRelease(v6);
    if (cva::ItemHandler::isVectorType(&cf)) {
      sub_2153E9F70();
    }
    CFStringRef v11 = v8;
  }
  else
  {
    char v14 = 0;
    CFStringRef v11 = v6;
  }
  CFRelease(v11);
  float v10 = v16;
  if (v16)
  {
LABEL_13:
    if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  return 0;
}

void sub_2153EFDC0(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_2153EFDD4(std::string::size_type *a1, std::string *a2, uint64_t a3)
{
  cva::adp::io::PListSerializer::getPath(a1, a2, &v15);
  std::string::size_type v4 = v15;
  if (v15)
  {
    if (*(char *)(a3 + 23) >= 0) {
      int64_t v5 = (const char *)a3;
    }
    else {
      int64_t v5 = *(const char **)a3;
    }
    CFStringRef v6 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v5, 0x8000100u, (CFAllocatorRef)*MEMORY[0x263EFFB28]);
    CFStringRef v7 = (const __CFString *)[*(id *)v4 objectForKey:v6];
    CFStringRef v8 = v7;
    char v9 = *(unsigned char *)(v4 + 8);
    CFTypeRef cf = v7;
    char v14 = v9;
    if (v7)
    {
      CFRetain(v7);
      CFRelease(v6);
      if (cva::ItemHandler::isVectorType(&cf)) {
        sub_2153E9F70();
      }
      CFStringRef v10 = v8;
    }
    else
    {
      char v14 = 0;
      CFStringRef v10 = v6;
    }
    CFRelease(v10);
  }
  CFStringRef v11 = v16;
  if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  return 0;
}

void sub_2153EFF50(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

BOOL sub_2153EFF64(uint64_t a1, uint64_t a2, float a3)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a2 + 16))(a2) != 2) {
    return 0;
  }
  if ((float)(*(float *)(a1 + 20) - *(float *)(a2 + 20)) >= a3) {
    return 0;
  }
  if ((float)(*(float *)(a1 + 28) - *(float *)(a2 + 28)) >= a3) {
    return 0;
  }
  float32x2_t v6 = vsub_f32(*(float32x2_t *)(a1 + 36), *(float32x2_t *)(a2 + 36));
  if (sqrtf(vaddv_f32(vmul_f32(v6, v6))) >= a3) {
    return 0;
  }
  if (*(unsigned __int8 *)(a1 + 44) != *(unsigned __int8 *)(a2 + 44)) {
    return 0;
  }
  float32x2_t v7 = vsub_f32(*(float32x2_t *)(a1 + 48), *(float32x2_t *)(a2 + 48));
  float32x2_t v8 = vmul_f32(v7, v7);
  float32x2_t v9 = vsub_f32(*(float32x2_t *)(a1 + 56), *(float32x2_t *)(a2 + 56));
  float32x2_t v10 = vmul_f32(v9, v9);
  if (sqrtf(vadd_f32(vadd_f32(vadd_f32(v8, (float32x2_t)vdup_lane_s32((int32x2_t)v8, 1)), v10), (float32x2_t)vdup_lane_s32((int32x2_t)v10, 1)).f32[0]) >= a3)return 0; {
  if (*(_DWORD *)(a1 + 64) == *(_DWORD *)(a2 + 64)
  }
    && *(_DWORD *)(a1 + 68) == *(_DWORD *)(a2 + 68)
    && (float v11 = *(float *)(a1 + 80) - *(float *)(a2 + 80),
        float32x2_t v12 = vsub_f32(*(float32x2_t *)(a1 + 72), *(float32x2_t *)(a2 + 72)),
        float v13 = vaddv_f32(vmul_f32(v12, v12)) + (float)(v11 * v11),
        float32x2_t v14 = vsub_f32(*(float32x2_t *)(a1 + 84), *(float32x2_t *)(a2 + 84)),
        float32x2_t v15 = vmul_f32(v14, v14),
        sqrtf((float)(v13 + v15.f32[0]) + v15.f32[1]) < a3))
  {
    return *(unsigned __int8 *)(a1 + 92) == *(unsigned __int8 *)(a2 + 92);
  }
  else
  {
    return 0;
  }
}

uint64_t *sub_2153F00DC(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = a1 + 20;
  sub_2153EE9A0((__n128 *)(a1 + 48), a2);
  sub_2153EEA44(v4, a2);
  sub_2153EEB74(a1 + 28, a2);
  sub_2153EECA4(a1 + 36, a2);
  if (*(unsigned char *)(a1 + 92)) {
    int64_t v5 = "[FREE]";
  }
  else {
    int64_t v5 = "[FIXED]";
  }
  if (*(unsigned char *)(a1 + 92)) {
    size_t v6 = 6;
  }
  else {
    size_t v6 = 7;
  }
  unsigned __int8 v113 = v6;
  memcpy(__dst, v5, v6);
  *(unsigned char *)((unint64_t)__dst | v6) = 0;
  if ((v113 & 0x80u) == 0) {
    float32x2_t v7 = __dst;
  }
  else {
    float32x2_t v7 = (void **)__dst[0];
  }
  if ((v113 & 0x80u) == 0) {
    uint64_t v8 = v113;
  }
  else {
    uint64_t v8 = (uint64_t)__dst[1];
  }
  float32x2_t v9 = sub_2153C1168(a2, (uint64_t)v7, v8);
  sub_2153C1168(v9, (uint64_t)"[", 1);
  float32x2_t v10 = (char *)operator new(0x28uLL);
  strcpy(v10, "Heikkila Distortion Coefficients");
  float v11 = sub_2153C1168(a2, (uint64_t)v10, 32);
  sub_2153C1168(v11, (uint64_t)"] : ", 4);
  long long v120 = *(_OWORD *)(a1 + 72);
  int v121 = *(_DWORD *)(a1 + 88);
  float32x2_t v12 = (char *)a2 + *(void *)(*a2 - 24);
  int v13 = *((_DWORD *)v12 + 2);
  size_t v15 = *((void *)v12 + 2);
  int64_t v14 = *((void *)v12 + 3);
  if (v14)
  {
    if (v14 <= (uint64_t)(v15 + 2)) {
      int64_t v14 = v15 + 2;
    }
    size_t v16 = v14 + ~v15;
    double v17 = __exp10((double)-(uint64_t)v15);
    size_t v18 = v16 - 1;
    if (v16 - 1 > 0x7FFFFFFFFFFFFFF7) {
LABEL_161:
    }
      abort();
    double v19 = v17;
    if (v18 >= 0x17)
    {
      uint64_t v21 = (v18 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v18 | 7) != 0x17) {
        uint64_t v21 = v18 | 7;
      }
      uint64_t v22 = v21 + 1;
      p_b = (std::string *)operator new(v21 + 1);
      __b.__r_.__value_.__l.__size_ = v16 - 1;
      __b.__r_.__value_.__r.__words[2] = v22 | 0x8000000000000000;
      __b.__r_.__value_.__r.__words[0] = (std::string::size_type)p_b;
    }
    else
    {
      *((unsigned char *)&__b.__r_.__value_.__s + 23) = v16 - 1;
      p_b = &__b;
      if (v16 == 1)
      {
        LODWORD(v16) = 1;
        goto LABEL_25;
      }
    }
  }
  else
  {
    double v19 = __exp10((double)-(uint64_t)v15);
    size_t v18 = 3;
    *((unsigned char *)&__b.__r_.__value_.__s + 23) = 3;
    p_b = &__b;
    LODWORD(v16) = 4;
  }
  memset(p_b, 32, v18);
LABEL_25:
  p_b->__r_.__value_.__s.__data_[v18] = 0;
  __n128 v23 = std::string::append(&__b, "0 ");
  std::string::size_type v24 = v23->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v122.__r_.__value_.__l.__data_ = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
  v122.__r_.__value_.__r.__words[2] = v24;
  v23->__r_.__value_.__l.__size_ = 0;
  v23->__r_.__value_.__r.__words[2] = 0;
  v23->__r_.__value_.__r.__words[0] = 0;
  if (v15 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_161;
  }
  if (v15 >= 0x17)
  {
    uint64_t v26 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v15 | 7) != 0x17) {
      uint64_t v26 = v15 | 7;
    }
    uint64_t v27 = v26 + 1;
    float v25 = operator new(v26 + 1);
    std::string::size_type v115 = v15;
    int64_t v116 = v27 | 0x8000000000000000;
    v114 = v25;
    goto LABEL_32;
  }
  HIBYTE(v116) = v15;
  float v25 = &v114;
  if (v15) {
LABEL_32:
  }
    memset(v25, 32, v15);
  *((unsigned char *)v25 + v15) = 0;
  if (v116 >= 0) {
    float v28 = (const std::string::value_type *)&v114;
  }
  else {
    float v28 = (const std::string::value_type *)v114;
  }
  if (v116 >= 0) {
    std::string::size_type v29 = HIBYTE(v116);
  }
  else {
    std::string::size_type v29 = v115;
  }
  float32x4_t v30 = std::string::append(&v122, v28, v29);
  std::string::size_type v31 = v30->__r_.__value_.__r.__words[2];
  *(_OWORD *)long long __p = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
  uint64_t v119 = v31;
  v30->__r_.__value_.__l.__size_ = 0;
  v30->__r_.__value_.__r.__words[2] = 0;
  v30->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v116) < 0)
  {
    operator delete(v114);
    if ((SHIBYTE(v122.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_41;
    }
LABEL_160:
    operator delete(v122.__r_.__value_.__l.__data_);
    goto LABEL_41;
  }
  if (SHIBYTE(v122.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_160;
  }
LABEL_41:
  int v104 = v13;
  std::string v105 = v10;
  if (SHIBYTE(__b.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__b.__r_.__value_.__l.__data_);
  }
  v110 = a2 + 1;
  *(uint64_t *)((char *)a2 + *(void *)(*a2 - 24) + 24) = 0;
  v122.__r_.__value_.__s.__data_[0] = 91;
  sub_2153C1168(a2, (uint64_t)&v122, 1);
  uint64_t v33 = 0;
  uint64_t v111 = (int)v16 + (int)v15 + 1;
  uint64_t v108 = (int)v15;
  uint64_t v109 = (int)v15 - 3;
  while (1)
  {
    float v34 = *(float *)((char *)&v120 + v33);
    v32.n128_f64[0] = v34;
    uint64_t v35 = *a2;
    int v36 = (char *)a2 + *(void *)(*a2 - 24);
    if (v36[9]) {
      break;
    }
    if (fabs(v32.n128_f64[0]) < v19)
    {
      uint64_t v37 = (char *)HIBYTE(v119);
      float32x2_t v38 = (char *)__p[1];
      if (v119 >= 0) {
        uint64_t v39 = __p;
      }
      else {
        uint64_t v39 = (void **)__p[0];
      }
      MEMORY[0x2166B95F0](&__b, a2);
      if (__b.__r_.__value_.__s.__data_[0])
      {
        if ((char)v37 >= 0) {
          float v40 = v37;
        }
        else {
          float v40 = v38;
        }
        float32x2_t v41 = (char *)a2 + *(void *)(*a2 - 24);
        uint64_t v42 = *((void *)v41 + 5);
        float32x2_t v43 = &v40[(void)v39];
        if ((*((_DWORD *)v41 + 2) & 0xB0) == 0x20) {
          int v44 = (void **)&v40[(void)v39];
        }
        else {
          int v44 = v39;
        }
        int v45 = *((_DWORD *)v41 + 36);
        if (v45 == -1)
        {
          std::string::size_type v56 = v44;
          std::ios_base::getloc((const std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)));
          int64_t v57 = std::locale::use_facet((const std::locale *)&v122, MEMORY[0x263F8C108]);
          int v45 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v57->__vftable[2].~facet_0)(v57, 32);
          std::locale::~locale((std::locale *)&v122);
          int v44 = v56;
          *((_DWORD *)v41 + 36) = v45;
          if (!v42) {
            goto LABEL_122;
          }
        }
        else if (!v42)
        {
          goto LABEL_122;
        }
        uint64_t v58 = *((void *)v41 + 3);
        BOOL v59 = v58 <= (uint64_t)v40;
        std::string::size_type v60 = v58 - (void)v40;
        if (v59) {
          std::string::size_type v61 = 0;
        }
        else {
          std::string::size_type v61 = v60;
        }
        int64_t v62 = (char *)v44 - (char *)v39;
        if ((char *)v44 - (char *)v39 < 1
          || (uint64_t v63 = v44,
              uint64_t v64 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v42 + 96))(v42, v39, v62),
              int v44 = v63,
              v64 == v62))
        {
          if ((uint64_t)v61 < 1) {
            goto LABEL_108;
          }
          if (v61 > 0x7FFFFFFFFFFFFFF7) {
            goto LABEL_161;
          }
          long long v106 = v44;
          if (v61 >= 0x17)
          {
            uint64_t v80 = (v61 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v61 | 7) != 0x17) {
              uint64_t v80 = v61 | 7;
            }
            uint64_t v81 = v80 + 1;
            uint64_t v65 = operator new(v80 + 1);
            v122.__r_.__value_.__l.__size_ = v61;
            v122.__r_.__value_.__r.__words[2] = v81 | 0x8000000000000000;
            v122.__r_.__value_.__r.__words[0] = (std::string::size_type)v65;
          }
          else
          {
            *((unsigned char *)&v122.__r_.__value_.__s + 23) = v61;
            uint64_t v65 = &v122;
          }
          memset(v65, v45, v61);
          *((unsigned char *)v65 + v61) = 0;
          if ((v122.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v82 = &v122;
          }
          else {
            uint64_t v82 = (std::string *)v122.__r_.__value_.__r.__words[0];
          }
          uint64_t v83 = (*(uint64_t (**)(uint64_t, std::string *, std::string::size_type))(*(void *)v42 + 96))(v42, v82, v61);
          if (SHIBYTE(v122.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v122.__r_.__value_.__l.__data_);
          }
          int v44 = v106;
          if (v83 == v61)
          {
LABEL_108:
            uint64_t v84 = v43 - (char *)v44;
            if (v43 - (char *)v44 >= 1)
            {
LABEL_120:
              if ((*(uint64_t (**)(uint64_t))(*(void *)v42 + 96))(v42) != v84) {
                goto LABEL_122;
              }
            }
LABEL_121:
            *((void *)v41 + 3) = 0;
            goto LABEL_123;
          }
        }
LABEL_122:
        std::ios_base::clear((std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)), *(_DWORD *)((char *)a2 + *(void *)(*a2 - 24) + 32) | 5);
        goto LABEL_123;
      }
      goto LABEL_123;
    }
    *((void *)v36 + 3) = v111;
    *(_DWORD *)((char *)v110 + *(void *)(v35 - 24)) = *(_DWORD *)((unsigned char *)v110 + *(void *)(v35 - 24)) & 0xFFFFFEFB | 4;
    *(_DWORD *)((char *)v110 + *(void *)(v35 - 24)) |= 0x400u;
    uint64_t v46 = *(void *)(v35 - 24);
    BOOL v47 = a2 + 2;
    uint64_t v48 = v108;
LABEL_64:
    *(void *)((char *)v47 + v46) = v48;
    std::ostream::operator<<();
    if (v33 == 16) {
      goto LABEL_154;
    }
LABEL_124:
    LOBYTE(v114) = 44;
    MEMORY[0x2166B95F0](&__b, a2);
    if (__b.__r_.__value_.__s.__data_[0])
    {
      int64_t v89 = (char *)a2 + *(void *)(*a2 - 24);
      uint64_t v90 = *((void *)v89 + 5);
      if ((*((_DWORD *)v89 + 2) & 0xB0) == 0x20) {
        uint64_t v91 = (void **)((char *)&v114 + 1);
      }
      else {
        uint64_t v91 = &v114;
      }
      int v92 = *((_DWORD *)v89 + 36);
      if (v92 == -1)
      {
        std::ios_base::getloc((const std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)));
        std::string v93 = std::locale::use_facet((const std::locale *)&v122, MEMORY[0x263F8C108]);
        int v92 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v93->__vftable[2].~facet_0)(v93, 32);
        std::locale::~locale((std::locale *)&v122);
        *((_DWORD *)v89 + 36) = v92;
        if (!v90) {
          goto LABEL_44;
        }
      }
      else if (!v90)
      {
        goto LABEL_44;
      }
      uint64_t v94 = *((void *)v89 + 3);
      BOOL v59 = v94 <= 1;
      std::string::size_type v95 = v94 - 1;
      if (v59) {
        std::string::size_type v96 = 0;
      }
      else {
        std::string::size_type v96 = v95;
      }
      if ((char *)v91 - (char *)&v114 >= 1
        && (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v90 + 96))(v90, &v114, (char *)v91 - (char *)&v114) != (char *)v91 - (char *)&v114)
      {
        goto LABEL_44;
      }
      if ((uint64_t)v96 >= 1)
      {
        if (v96 > 0x7FFFFFFFFFFFFFF7) {
          goto LABEL_161;
        }
        if (v96 >= 0x17)
        {
          uint64_t v98 = (v96 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v96 | 7) != 0x17) {
            uint64_t v98 = v96 | 7;
          }
          uint64_t v99 = v98 + 1;
          uint64_t v97 = operator new(v98 + 1);
          v122.__r_.__value_.__l.__size_ = v96;
          v122.__r_.__value_.__r.__words[2] = v99 | 0x8000000000000000;
          v122.__r_.__value_.__r.__words[0] = (std::string::size_type)v97;
        }
        else
        {
          *((unsigned char *)&v122.__r_.__value_.__s + 23) = v96;
          uint64_t v97 = &v122;
        }
        memset(v97, v92, v96);
        *((unsigned char *)v97 + v96) = 0;
        if ((v122.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v100 = &v122;
        }
        else {
          uint64_t v100 = (std::string *)v122.__r_.__value_.__r.__words[0];
        }
        uint64_t v101 = (*(uint64_t (**)(uint64_t, std::string *, std::string::size_type))(*(void *)v90 + 96))(v90, v100, v96);
        uint64_t v102 = v101;
        if (SHIBYTE(v122.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v122.__r_.__value_.__l.__data_);
          if (v102 != v96) {
            goto LABEL_44;
          }
        }
        else if (v101 != v96)
        {
          goto LABEL_44;
        }
      }
      if ((char *)&v114 + 1 - (char *)v91 >= 1
        && (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v90 + 96))(v90, v91, (char *)&v114 + 1 - (char *)v91) != (char *)&v114 + 1 - (char *)v91)
      {
LABEL_44:
        std::ios_base::clear((std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)), *(_DWORD *)((char *)a2 + *(void *)(*a2 - 24) + 32) | 5);
        goto LABEL_45;
      }
      *((void *)v89 + 3) = 0;
    }
LABEL_45:
    MEMORY[0x2166B9600](&__b);
    v33 += 4;
  }
  if (v34 != 0.0)
  {
    *((void *)v36 + 3) = v111;
    *(_DWORD *)((char *)v110 + *(void *)(v35 - 24)) |= 0x400u;
    uint64_t v46 = *(void *)(v35 - 24);
    BOOL v47 = a2 + 2;
    uint64_t v48 = v109;
    goto LABEL_64;
  }
  std::string::size_type v49 = (char *)HIBYTE(v119);
  int64_t v50 = (char *)__p[1];
  if (v119 >= 0) {
    int64_t v51 = __p;
  }
  else {
    int64_t v51 = (void **)__p[0];
  }
  MEMORY[0x2166B95F0](&__b, a2, v32);
  if (__b.__r_.__value_.__s.__data_[0])
  {
    if ((char)v49 >= 0) {
      uint64_t v52 = v49;
    }
    else {
      uint64_t v52 = v50;
    }
    float32x2_t v41 = (char *)a2 + *(void *)(*a2 - 24);
    uint64_t v42 = *((void *)v41 + 5);
    uint64_t v53 = &v52[(void)v51];
    if ((*((_DWORD *)v41 + 2) & 0xB0) == 0x20) {
      uint64_t v54 = (void **)&v52[(void)v51];
    }
    else {
      uint64_t v54 = v51;
    }
    int v55 = *((_DWORD *)v41 + 36);
    if (v55 == -1)
    {
      uint64_t v66 = v54;
      std::ios_base::getloc((const std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)));
      uint64_t v67 = std::locale::use_facet((const std::locale *)&v122, MEMORY[0x263F8C108]);
      int v55 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v67->__vftable[2].~facet_0)(v67, 32);
      std::locale::~locale((std::locale *)&v122);
      uint64_t v54 = v66;
      *((_DWORD *)v41 + 36) = v55;
      if (!v42) {
        goto LABEL_122;
      }
    }
    else if (!v42)
    {
      goto LABEL_122;
    }
    uint64_t v68 = *((void *)v41 + 3);
    BOOL v59 = v68 <= (uint64_t)v52;
    std::string::size_type v69 = v68 - (void)v52;
    if (v59) {
      std::string::size_type v70 = 0;
    }
    else {
      std::string::size_type v70 = v69;
    }
    int64_t v71 = (char *)v54 - (char *)v51;
    if ((char *)v54 - (char *)v51 < 1) {
      goto LABEL_164;
    }
    std::string::size_type v72 = *(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v42 + 96);
    uint64_t v73 = v42;
    uint64_t v74 = v42;
    std::string::size_type v75 = v70;
    uint64_t v76 = v53;
    uint64_t v77 = v54;
    uint64_t v78 = v72(v73, v51, v71);
    uint64_t v54 = v77;
    uint64_t v53 = v76;
    std::string::size_type v70 = v75;
    uint64_t v42 = v74;
    if (v78 == v71)
    {
LABEL_164:
      if ((uint64_t)v70 < 1) {
        goto LABEL_119;
      }
      if (v70 > 0x7FFFFFFFFFFFFFF7) {
        goto LABEL_161;
      }
      v107 = v54;
      if (v70 >= 0x17)
      {
        uint64_t v85 = (v70 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v70 | 7) != 0x17) {
          uint64_t v85 = v70 | 7;
        }
        uint64_t v86 = v85 + 1;
        uint64_t v79 = operator new(v85 + 1);
        v122.__r_.__value_.__l.__size_ = v70;
        v122.__r_.__value_.__r.__words[2] = v86 | 0x8000000000000000;
        v122.__r_.__value_.__r.__words[0] = (std::string::size_type)v79;
      }
      else
      {
        *((unsigned char *)&v122.__r_.__value_.__s + 23) = v70;
        uint64_t v79 = &v122;
      }
      memset(v79, v55, v70);
      *((unsigned char *)v79 + v70) = 0;
      if ((v122.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v87 = &v122;
      }
      else {
        std::string::size_type v87 = (std::string *)v122.__r_.__value_.__r.__words[0];
      }
      uint64_t v88 = (*(uint64_t (**)(uint64_t, std::string *, std::string::size_type))(*(void *)v42 + 96))(v42, v87, v70);
      if (SHIBYTE(v122.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v122.__r_.__value_.__l.__data_);
      }
      uint64_t v54 = v107;
      if (v88 == v70)
      {
LABEL_119:
        uint64_t v84 = v53 - (char *)v54;
        if (v53 - (char *)v54 >= 1) {
          goto LABEL_120;
        }
        goto LABEL_121;
      }
    }
    goto LABEL_122;
  }
LABEL_123:
  MEMORY[0x2166B9600](&__b);
  if (v33 != 16) {
    goto LABEL_124;
  }
LABEL_154:
  sub_2153C1168(a2, (uint64_t)"   ]", 4);
  *(_DWORD *)((char *)a2 + *(void *)(*a2 - 24) + 8) = v104;
  if (SHIBYTE(v119) < 0) {
    operator delete(__p[0]);
  }
  sub_2153C1168(a2, (uint64_t)"\n", 1);
  operator delete(v105);
  if ((char)v113 < 0) {
    operator delete(__dst[0]);
  }
  return a2;
}

uint64_t sub_2153F0D0C(uint64_t a1, unint64_t *a2, float32x2_t *a3, double a4, double a5, double a6, double a7, double a8, int32x4_t a9)
{
  BOOL v9 = 0;
  a9.i64[0] = *a2;
  float32x4_t v10 = (float32x4_t)vzip1q_s32(a9, a9);
  if (vmaxv_u16((uint16x4_t)vtrn2_s16(vrev32_s16(vmovn_s32(vcgtq_f32(*(float32x4_t *)(a1 + 48), v10))), vmovn_s32(vcgeq_f32(v10, *(float32x4_t *)(a1 + 48))))))return v9; {
  float v11 = *(float *)(a1 + 20);
  }
  float v12 = *(float *)(a1 + 28);
  if (v11 < 0.000000014901 || v12 < 0.000000014901) {
    return v9;
  }
  v14.f32[0] = v11 * v12;
  unint64_t v15 = *(unsigned int *)(a1 + 96);
  float v16 = *(float *)(a1 + 72);
  float v17 = *(float *)(a1 + 76);
  float v18 = *(float *)(a1 + 80);
  float v19 = *(float *)(a1 + 84);
  float v20 = *(float *)(a1 + 88);
  v14.i32[1] = *(_DWORD *)(a1 + 20);
  float32x2_t v21 = vdiv_f32(vsub_f32(*(float32x2_t *)a9.i8, *(float32x2_t *)(a1 + 36)), v14);
  *a3 = v21;
  if (v15)
  {
    BOOL v9 = 0;
    uint64_t v22 = 0;
    float v24 = v21.f32[1];
    float v23 = v21.f32[0];
    do
    {
      float v25 = v24 * v24;
      float v26 = (float)(v23 * v23) + (float)(v24 * v24);
      float v27 = (float)((float)((float)(v16 * v26) + 1.0) + (float)(v17 * (float)(v26 * v26)))
          + (float)(v20 * (float)(v26 * (float)(v26 * v26)));
      if (v27 == 0.0) {
        break;
      }
      float v28 = v23 * v24;
      float v23 = (float)(v21.f32[0]
                  - (float)((float)(v19 * (float)(v26 + (float)((float)(v23 * v23) * 2.0)))
                          + (float)((float)(v18 + v18) * v28)))
          / v27;
      float v24 = (float)(v21.f32[1]
                  - (float)((float)((float)(v19 + v19) * v28) + (float)(v18 * (float)(v26 + (float)(v25 * 2.0)))))
          / v27;
      a3->f32[0] = v23;
      a3->f32[1] = v24;
      BOOL v9 = ++v22 >= v15;
    }
    while (v15 != v22);
    return v9;
  }
  return 1;
}

uint64_t sub_2153F0E2C(uint64_t a1, float32x2_t *a2, void *a3, double a4, double a5, double a6, int32x4_t a7)
{
  float v7 = a2[1].f32[0];
  if (v7 < 0.001) {
    return 0;
  }
  float32x2_t v8 = vmul_n_f32(*a2, 1.0 / v7);
  float32x2_t v9 = vmul_f32(v8, v8);
  float32x2_t v10 = vadd_f32(v9, (float32x2_t)vdup_lane_s32((int32x2_t)v9, 1));
  float32x2_t v11 = vmul_f32(v10, v10);
  float v12 = vmlas_n_f32((float)(*(float *)(a1 + 76) * v11.f32[0]) + (float)(*(float *)(a1 + 72) * vaddv_f32(v9)), *(float *)(a1 + 88), vmul_f32(v10, v11).f32[0])+ 1.0;
  v10.i32[0] = 0x40000000;
  v10.i32[1] = v8.i32[0];
  __asm { FMOV            V6.2S, #3.0 }
  float32x2_t v18 = vmla_n_f32(vmla_f32(vmul_lane_f32(vmul_f32((float32x2_t)__PAIR64__(2.0, v8.u32[0]), vmul_f32(v10, *(float32x2_t *)(a1 + 80))), v8, 1), vmla_f32((float32x2_t)vrev64_s32((int32x2_t)v9), _D6, v9), (float32x2_t)vrev64_s32(*(int32x2_t *)(a1 + 80))), v8, v12);
  v19.f32[0] = *(float *)(a1 + 20) * *(float *)(a1 + 28);
  v19.i32[1] = *(_DWORD *)(a1 + 20);
  *(float32x2_t *)a7.i8 = vmla_f32(*(float32x2_t *)(a1 + 36), v18, v19);
  float32x4_t v20 = (float32x4_t)vzip1q_s32(a7, a7);
  *a3 = a7.i64[0];
  return vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vtrn2_s16(vrev32_s16(vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)(a1 + 48), v20)))), vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vcgeq_f32(v20, *(float32x4_t *)(a1 + 48))))), 0xFuLL))) & 1;
}

unsigned char *sub_2153F0F24(unsigned char *result, char a2)
{
  result[24] = a2;
  result[32] = a2;
  result[44] = a2;
  result[92] = a2;
  return result;
}

void sub_2153F0F38()
{
}

uint64_t sub_2153F0FF0(uint64_t a1)
{
  return a1 + 48;
}

uint64_t sub_2153F0FF8()
{
  return 2;
}

void sub_2153F1000()
{
}

BOOL sub_2153F1018(uint64_t a1, uint64_t a2, float a3)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a2 + 16))(a2) != 1) {
    return 0;
  }
  if ((float)(*(float *)(a1 + 20) - *(float *)(a2 + 20)) >= a3) {
    return 0;
  }
  if ((float)(*(float *)(a1 + 28) - *(float *)(a2 + 28)) >= a3) {
    return 0;
  }
  float32x2_t v6 = vsub_f32(*(float32x2_t *)(a1 + 36), *(float32x2_t *)(a2 + 36));
  if (sqrtf(vaddv_f32(vmul_f32(v6, v6))) >= a3) {
    return 0;
  }
  if (*(unsigned __int8 *)(a1 + 44) != *(unsigned __int8 *)(a2 + 44)) {
    return 0;
  }
  float32x2_t v7 = vsub_f32(*(float32x2_t *)(a1 + 48), *(float32x2_t *)(a2 + 48));
  float32x2_t v8 = vmul_f32(v7, v7);
  float32x2_t v9 = vsub_f32(*(float32x2_t *)(a1 + 56), *(float32x2_t *)(a2 + 56));
  float32x2_t v10 = vmul_f32(v9, v9);
  if (sqrtf(vadd_f32(vadd_f32(vadd_f32(v8, (float32x2_t)vdup_lane_s32((int32x2_t)v8, 1)), v10), (float32x2_t)vdup_lane_s32((int32x2_t)v10, 1)).f32[0]) >= a3)return 0; {
  if (*(_DWORD *)(a1 + 64) == *(_DWORD *)(a2 + 64)
  }
    && *(_DWORD *)(a1 + 68) == *(_DWORD *)(a2 + 68)
    && (float32x2_t v11 = vsub_f32(*(float32x2_t *)(a1 + 72), *(float32x2_t *)(a2 + 72)),
        float32x2_t v12 = vmul_f32(v11, v11),
        float32x2_t v13 = vsub_f32(*(float32x2_t *)(a1 + 80), *(float32x2_t *)(a2 + 80)),
        float32x2_t v14 = vmul_f32(v13, v13),
        sqrtf(vadd_f32(vadd_f32(vadd_f32(v12, (float32x2_t)vdup_lane_s32((int32x2_t)v12, 1)), v14), (float32x2_t)vdup_lane_s32((int32x2_t)v14, 1)).f32[0]) < a3)&& *(unsigned __int8 *)(a1 + 88) == *(unsigned __int8 *)(a2 + 88)&& (float)(*(float *)(a1 + 92) - *(float *)(a2 + 92)) < a3)
  {
    return *(_DWORD *)(a1 + 96) == *(_DWORD *)(a2 + 96);
  }
  else
  {
    return 0;
  }
}

void *sub_2153F119C(uint64_t a1, void *a2)
{
  uint64_t v4 = a1 + 20;
  sub_2153EE9A0((__n128 *)(a1 + 48), a2);
  sub_2153EEA44(v4, a2);
  sub_2153EEB74(a1 + 28, a2);
  sub_2153EECA4(a1 + 36, a2);
  if (*(unsigned char *)(a1 + 88)) {
    int64_t v5 = "[FREE]";
  }
  else {
    int64_t v5 = "[FIXED]";
  }
  if (*(unsigned char *)(a1 + 88)) {
    size_t v6 = 6;
  }
  else {
    size_t v6 = 7;
  }
  char v19 = v6;
  memcpy(&__dst, v5, v6);
  *(unsigned char *)((unint64_t)&__dst | v6) = 0;
  if (v19 >= 0) {
    p_dst = &__dst;
  }
  else {
    p_dst = (long long *)__dst;
  }
  if (v19 >= 0) {
    uint64_t v8 = v19;
  }
  else {
    uint64_t v8 = *((void *)&__dst + 1);
  }
  float32x2_t v9 = sub_2153C1168(a2, (uint64_t)p_dst, v8);
  sub_2153C1168(v9, (uint64_t)"[", 1);
  float32x2_t v10 = (char *)operator new(0x28uLL);
  strcpy(v10, "Kannala-4 Distortion Coefficients");
  float32x2_t v11 = sub_2153C1168(a2, (uint64_t)v10, 33);
  float32x2_t v12 = sub_2153C1168(v11, (uint64_t)"] : ", 4);
  float32x2_t v13 = sub_2153EEDD0(v12, *(__n128 *)(a1 + 72));
  sub_2153C1168(v13, (uint64_t)"\n", 1);
  operator delete(v10);
  if (v19 < 0) {
    operator delete((void *)__dst);
  }
  float32x2_t v14 = sub_2153C1168(a2, (uint64_t)"[FIXED][", 8);
  char v19 = 13;
  strcpy((char *)&__dst, "Field of View");
  unint64_t v15 = sub_2153C1168(v14, (uint64_t)&__dst, 13);
  sub_2153C1168(v15, (uint64_t)"] : ", 4);
  float v16 = (void *)std::ostream::operator<<();
  sub_2153C1168(v16, (uint64_t)"\n", 1);
  if (v19 < 0) {
    operator delete((void *)__dst);
  }
  return a2;
}

uint64_t sub_2153F1364(uint64_t a1, unint64_t *a2, float32x2_t *a3, int32x4_t a4)
{
  uint64_t v4 = 0;
  a4.i64[0] = *a2;
  float32x4_t v5 = (float32x4_t)vzip1q_s32(a4, a4);
  if ((vmaxv_u16((uint16x4_t)vtrn2_s16(vrev32_s16(vmovn_s32(vcgtq_f32(*(float32x4_t *)(a1 + 48), v5))), vmovn_s32(vcgeq_f32(v5, *(float32x4_t *)(a1 + 48))))) & 1) == 0)
  {
    float v6 = *(float *)(a1 + 20);
    float v7 = *(float *)(a1 + 28);
    if (v6 >= 0.000000014901 && v7 >= 0.000000014901)
    {
      float v10 = v6 * v7;
      v12.i32[1] = *(_DWORD *)(a1 + 20);
      float32x2_t v11 = vdiv_f32(vsub_f32(*(float32x2_t *)a4.i8, *(float32x2_t *)(a1 + 36)), v12);
      v12.f32[0] = sqrtf(vmlas_n_f32(COERCE_FLOAT(vmul_f32(v11, v11).i32[1]), v11.f32[0], v11.f32[0]));
      if (v12.f32[0] < 0.000000014901)
      {
LABEL_7:
        *a3 = v11;
        return 1;
      }
      if (v12.f32[0] > 3.4028e38) {
        return 0;
      }
      float32x2_t v36 = v11;
      int32x2_t v37 = (int32x2_t)v12;
      int v14 = *(_DWORD *)(a1 + 100);
      float v15 = *(float *)(a1 + 92) * 0.9;
      if (v15 > 1.0) {
        float v15 = 1.0;
      }
      if (v14)
      {
        int v16 = *(_DWORD *)(a1 + 96);
        _S12 = *(float *)(a1 + 76);
        _S13 = *(float *)(a1 + 80);
        _S14 = *(float *)(a1 + 84);
        float v38 = *(float *)(a1 + 72) * 3.0;
        int v20 = v14 - 1;
        while (1)
        {
          int v21 = v20;
          v22.f32[0] = v15 * v15;
          float v42 = v22.f32[0] * v22.f32[0];
          float v43 = v15 * v15;
          v22.f32[1] = v22.f32[0] * v22.f32[0];
          float v40 = (float)(v15 * v15) * (float)(v22.f32[0] * (float)(v22.f32[0] * v22.f32[0]));
          float v41 = v22.f32[0] * (float)(v22.f32[0] * v22.f32[0]);
          v22.f32[2] = v41;
          v22.f32[3] = v40;
          _Q1 = vmulq_n_f32(v22, v15);
          float v39 = v15;
          __asm
          {
            FMLA            S9, S12, V1.S[1]
            FMLA            S9, S13, V1.S[2]
            FMLA            S9, S14, V1.S[3]
          }
          float v30 = cosf(_S9);
          if (v16 == 2)
          {
            float v31 = tanf(_S9);
            float v30 = 1.0 / (float)(v30 * v30);
          }
          else if (v16 == 1)
          {
            float v31 = sinf(_S9);
          }
          else
          {
            float v30 = 0.0;
            float v31 = 0.0;
            if (!v16)
            {
              float v30 = 1.0;
              float v31 = _S9;
            }
          }
          float v32 = (float)((float)((float)((float)((float)(v38 * v43) + 1.0) + (float)((float)(_S12 * 5.0) * v42))
                              + (float)((float)(_S13 * 7.0) * v41))
                      + (float)((float)(_S14 * 9.0) * v40))
              * v30;
          if (v32 == 0.0) {
            return 0;
          }
          float v33 = (float)(v31 - *(float *)v37.i32) / v32;
          unint64_t v34 = COERCE_UNSIGNED_INT(v39 - v33) | ((unint64_t)LODWORD(v33) << 32);
          float v35 = v33;
          float v15 = v39 - v33;
          if (fabsf(*((float *)&v34 + 1)) >= 0.0000011921)
          {
            int v20 = v21 - 1;
            if (v21) {
              continue;
            }
          }
          goto LABEL_28;
        }
      }
      float v35 = 3.4028e38;
LABEL_28:
      uint64_t v4 = 0;
      if (fabsf(v35) <= 0.001 && v15 >= 0.0 && v15 <= 1.5708)
      {
        float32x2_t v11 = vdiv_f32(vmul_n_f32(v36, tanf(v15)), (float32x2_t)vdup_lane_s32(v37, 0));
        goto LABEL_7;
      }
    }
  }
  return v4;
}

BOOL sub_2153F1654(uint64_t a1, float *a2, float *a3)
{
  float v3 = a2[2];
  if (v3 < 0.00034527) {
    return 0;
  }
  float v6 = *a2;
  float v7 = a2[1];
  float v8 = (float)(v7 * v7) + (float)(v6 * v6);
  if (v8 >= 0.00034527)
  {
    int v10 = *(_DWORD *)(a1 + 96);
    float v11 = *(float *)(a1 + 92);
    float v13 = *(float *)(a1 + 72);
    float v12 = *(float *)(a1 + 76);
    float v15 = *(float *)(a1 + 80);
    float v14 = *(float *)(a1 + 84);
    float v16 = sqrtf(v8);
    float v17 = atan2f(v16, v3);
    if (v17 <= v11)
    {
      float v18 = v17 * (float)(v17 * v17);
      float v19 = (float)(v17 * v17) * v18;
      float v20 = (float)(v17 * v17) * v19;
      float v21 = (float)(v17 * v17) * v20;
      if (v10 == 2)
      {
        float v22 = tanf((float)((float)((float)(v17 + (float)(v13 * v18)) + (float)(v12 * v19)) + (float)(v15 * v20))+ (float)(v14 * v21));
      }
      else if (v10 == 1)
      {
        float v22 = sinf((float)((float)((float)(v17 + (float)(v13 * v18)) + (float)(v12 * v19)) + (float)(v15 * v20))+ (float)(v14 * v21));
      }
      else
      {
        float v9 = 0.0;
        if (v10) {
          goto LABEL_13;
        }
        float v22 = (float)((float)((float)(v17 + (float)(v13 * v18)) + (float)(v12 * v19)) + (float)(v15 * v20))
            + (float)(v14 * v21);
      }
      float v9 = v22 / v16;
      goto LABEL_13;
    }
    return 0;
  }
  float v9 = 1.0 / v3;
LABEL_13:
  float v24 = *(float *)(a1 + 20);
  float v25 = *(float *)(a1 + 36) + (float)((float)(v24 * *(float *)(a1 + 28)) * (float)(v6 * v9));
  float v26 = *(float *)(a1 + 40) + (float)(v24 * (float)(v7 * v9));
  *a3 = v25;
  a3[1] = v26;
  BOOL v27 = *(float *)(a1 + 48) <= v25;
  if (*(float *)(a1 + 52) <= v25) {
    BOOL v27 = 0;
  }
  if (*(float *)(a1 + 56) > v26) {
    BOOL v27 = 0;
  }
  return *(float *)(a1 + 60) > v26 && v27;
}

unsigned char *sub_2153F17C4(unsigned char *result, char a2)
{
  result[24] = a2;
  result[32] = a2;
  result[44] = a2;
  result[88] = a2;
  return result;
}

void sub_2153F17D8()
{
}

uint64_t sub_2153F1890(uint64_t a1)
{
  return a1 + 48;
}

uint64_t sub_2153F1898()
{
  return 1;
}

void sub_2153F18A0()
{
}

uint64_t sub_2153F18B8(uint64_t **__s1, _DWORD *a2)
{
  if (*((char *)__s1 + 23) < 0)
  {
    float32x4_t v5 = *__s1;
    float v6 = __s1[1];
    if (v6 == (uint64_t *)12)
    {
      if (*v5 != 0x6874286E69732D66 || *((_DWORD *)v5 + 2) != 694252645)
      {
        uint64_t v9 = *v5;
        uint64_t v10 = *((unsigned int *)v5 + 2);
        if (v9 == 0x6874286E61742D66 && v10 == 694252645) {
          goto LABEL_23;
        }
        return 0;
      }
      goto LABEL_22;
    }
    if (v6 != (uint64_t *)8 || *v5 != 0x2961746568742866) {
      return 0;
    }
  }
  else
  {
    size_t v4 = *((unsigned __int8 *)__s1 + 23);
    if (*((unsigned char *)__s1 + 23) != 8)
    {
      if (v4 != 12) {
        return 0;
      }
      if (memcmp(__s1, "f-sin(theta)", v4))
      {
        if (!memcmp(__s1, "f-tan(theta)", v4))
        {
LABEL_23:
          float v7 = off_264241890;
          goto LABEL_24;
        }
        return 0;
      }
LABEL_22:
      float v7 = off_264241888;
      goto LABEL_24;
    }
    if (memcmp(__s1, "f(theta)", *((unsigned __int8 *)__s1 + 23))) {
      return 0;
    }
  }
  float v7 = cva::adp::io::detail::EnumDescription<cva::geo::eProjectionModelType,void>::names;
LABEL_24:
  *a2 = (unint64_t)((char *)v7
                         - (char *)cva::adp::io::detail::EnumDescription<cva::geo::eProjectionModelType,void>::names) >> 3;
  return 1;
}

uint64_t sub_2153F1A10(std::string::size_type *a1, std::string *a2, uint64_t a3)
{
  cva::adp::io::PListSerializer::getPath(a1, a2, &v15);
  std::string::size_type v4 = v15;
  if (v15)
  {
    if (*(char *)(a3 + 23) >= 0) {
      float32x4_t v5 = (const char *)a3;
    }
    else {
      float32x4_t v5 = *(const char **)a3;
    }
    CFStringRef v6 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v5, 0x8000100u, (CFAllocatorRef)*MEMORY[0x263EFFB28]);
    CFStringRef v7 = (const __CFString *)[*(id *)v4 objectForKey:v6];
    CFStringRef v8 = v7;
    char v9 = *(unsigned char *)(v4 + 8);
    CFTypeRef cf = v7;
    char v14 = v9;
    if (v7)
    {
      CFRetain(v7);
      CFRelease(v6);
      if (cva::ItemHandler::isVectorType(&cf)) {
        sub_2153E9F70();
      }
      CFStringRef v10 = v8;
    }
    else
    {
      char v14 = 0;
      CFStringRef v10 = v6;
    }
    CFRelease(v10);
  }
  float v11 = v16;
  if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  return 0;
}

void sub_2153F1B9C(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

BOOL sub_2153F1BB0(uint64_t a1, uint64_t a2, float a3)
{
  if (!(*(unsigned int (**)(uint64_t))(*(void *)a2 + 16))(a2)
    && (float)(*(float *)(a1 + 20) - *(float *)(a2 + 20)) < a3
    && (float)(*(float *)(a1 + 28) - *(float *)(a2 + 28)) < a3
    && (float32x2_t v6 = vsub_f32(*(float32x2_t *)(a1 + 36), *(float32x2_t *)(a2 + 36)), sqrtf(vaddv_f32(vmul_f32(v6, v6))) < a3)
    && *(unsigned __int8 *)(a1 + 44) == *(unsigned __int8 *)(a2 + 44)
    && (float32x2_t v7 = vsub_f32(*(float32x2_t *)(a1 + 48), *(float32x2_t *)(a2 + 48)),
        float32x2_t v8 = vmul_f32(v7, v7),
        float32x2_t v9 = vsub_f32(*(float32x2_t *)(a1 + 56), *(float32x2_t *)(a2 + 56)),
        float32x2_t v10 = vmul_f32(v9, v9),
        sqrtf(vadd_f32(vadd_f32(vadd_f32(v8, (float32x2_t)vdup_lane_s32((int32x2_t)v8, 1)), v10), (float32x2_t)vdup_lane_s32((int32x2_t)v10, 1)).f32[0]) < a3)&& *(_DWORD *)(a1 + 64) == *(_DWORD *)(a2 + 64))
  {
    return *(_DWORD *)(a1 + 68) == *(_DWORD *)(a2 + 68);
  }
  else
  {
    return 0;
  }
}

void *sub_2153F1CC4(__n128 *a1, void *a2)
{
  uint64_t v4 = (uint64_t)a1[1].n128_i64 + 4;
  sub_2153EE9A0(a1 + 3, a2);
  sub_2153EEA44(v4, a2);
  sub_2153EEB74((uint64_t)&a1[1].n128_i64[1] + 4, a2);
  return sub_2153EECA4((uint64_t)a1[2].n128_i64 + 4, a2);
}

BOOL sub_2153F1D2C(uint64_t a1, unint64_t *a2, float32x2_t *a3, double a4, int32x4_t a5)
{
  float v5 = *(float *)(a1 + 20);
  float v6 = *(float *)(a1 + 28);
  a5.i64[0] = *a2;
  float32x4_t v7 = (float32x4_t)vzip1q_s32(a5, a5);
  char v8 = vmaxv_u16((uint16x4_t)vtrn2_s16(vrev32_s16(vmovn_s32(vcgtq_f32(*(float32x4_t *)(a1 + 48), v7))), vmovn_s32(vcgeq_f32(v7, *(float32x4_t *)(a1 + 48))))) | (v5 < 0.000000014901) | (v6 < 0.000000014901);
  if ((v8 & 1) == 0)
  {
    v9.f32[0] = v5 * v6;
    v9.i32[1] = *(_DWORD *)(a1 + 20);
    *a3 = vdiv_f32(vsub_f32(*(float32x2_t *)a5.i8, *(float32x2_t *)(a1 + 36)), v9);
  }
  return (v8 & 1) == 0;
}

uint64_t sub_2153F1DA8(uint64_t a1, float32x2_t *a2, void *a3, double a4, double a5, double a6, int32x4_t a7)
{
  float v7 = a2[1].f32[0];
  if (v7 < 0.001) {
    return 0;
  }
  v8.f32[0] = *(float *)(a1 + 20) * *(float *)(a1 + 28);
  v8.i32[1] = *(_DWORD *)(a1 + 20);
  *(float32x2_t *)a7.i8 = vmla_f32(*(float32x2_t *)(a1 + 36), vmul_n_f32(*a2, 1.0 / v7), v8);
  float32x4_t v9 = (float32x4_t)vzip1q_s32(a7, a7);
  *a3 = a7.i64[0];
  return vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vtrn2_s16(vrev32_s16(vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)(a1 + 48), v9)))), vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vcgeq_f32(v9, *(float32x4_t *)(a1 + 48))))), 0xFuLL))) & 1;
}

unsigned char *sub_2153F1E34(unsigned char *result, char a2)
{
  result[24] = a2;
  result[32] = a2;
  result[44] = a2;
  return result;
}

void sub_2153F1E44()
{
}

uint64_t sub_2153F1EDC(uint64_t a1)
{
  return a1 + 48;
}

uint64_t sub_2153F1EE4()
{
  return 0;
}

void sub_2153F1EEC()
{
}

uint64_t sub_2153F1F04(std::string::size_type *a1, uint64_t a2, unint64_t *a3, uint64_t a4)
{
  if (*(char *)(a2 + 23) < 0) {
    sub_2153C0AE4(&v15, *(void **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string v15 = *(std::string *)a2;
  }
  cva::adp::PListPath::convertToPath(a3, (uint64_t)__p);
  if (v17 >= 0) {
    float v7 = __p;
  }
  else {
    float v7 = (void **)__p[0];
  }
  if (v17 >= 0) {
    std::string::size_type v8 = v17;
  }
  else {
    std::string::size_type v8 = (std::string::size_type)__p[1];
  }
  std::string::append(&v15, (const std::string::value_type *)v7, v8);
  if (v17 < 0) {
    operator delete(__p[0]);
  }
  char v17 = 4;
  strcpy((char *)__p, "Data");
  uint64_t v9 = sub_2153E9DE8(a1, &v15, (uint64_t)__p);
  uint64_t v10 = v9;
  if (v17 < 0)
  {
    operator delete(__p[0]);
    if (!v10)
    {
LABEL_14:
      if ((SHIBYTE(v15.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        return v10;
      }
LABEL_22:
      operator delete(v15.__r_.__value_.__l.__data_);
      return v10;
    }
  }
  else if (!v9)
  {
    goto LABEL_14;
  }
  char v17 = 5;
  strcpy((char *)__p, "Fixed");
  float v12 = (char *)(a4 + 4);
  int v13 = cva::adp::io::PListSerializer::getItem<BOOL>(a1, &v15, (uint64_t)__p, v12);
  if (v17 < 0) {
    operator delete(__p[0]);
  }
  char v14 = *v12 ^ 1;
  if (!v13) {
    char v14 = 1;
  }
  char *v12 = v14;
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_22;
  }
  return v10;
}

__n128 sub_2153F2074(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26C5FBF18;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  long long v4 = *(_OWORD *)(a1 + 40);
  *(void *)(a2 + 56) = *(void *)(a1 + 56);
  *(_OWORD *)(a2 + 40) = v4;
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_2153F20B4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x40uLL);
  *(void *)uint64_t v2 = &unk_26C5FBF18;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  *((void *)v2 + 7) = *(void *)(a1 + 56);
  return result;
}

void sub_2153F2118()
{
}

uint64_t cva::adp::Session<float>::loadImagePoint3TrackSet(void *a1)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  id v1 = (const char **)(a1 + 13);
  sub_2153F4E9C(&v10, a1);
  *(_OWORD *)float v11 = 0u;
  *(_OWORD *)float v12 = 0u;
  int v13 = 1065353216;
  if (sub_2153F4FDC(v1, &v10))
  {
    uint64_t v2 = *v1;
    if ((*v1)[23] < 0) {
      uint64_t v2 = *(const char **)v2;
    }
    int v3 = 0;
    if (!stat(v2, &v16) && (v16.st_mode & 0xF000) == 0x4000)
    {
      v9[0] = 0;
      uint64_t v14 = 0;
      uint64_t v15 = 0;
      int v3 = 1;
      if ((std::string::size_type *)v10.__r_.__value_.__l.__data_ != &v10.__r_.__value_.__r.__words[1]) {
        operator new();
      }
    }
  }
  else
  {
    int v3 = 0;
  }
  long long v4 = v12[0];
  if (v12[0])
  {
    do
    {
      float v6 = (void *)*v4;
      float v7 = (void *)v4[3];
      if (v7)
      {
        v4[4] = v7;
        operator delete(v7);
      }
      operator delete(v4);
      long long v4 = v6;
    }
    while (v6);
  }
  float v5 = v11[0];
  v11[0] = 0;
  if (v5) {
    operator delete(v5);
  }
  if (v3)
  {
    HIBYTE(v9[2]) = 16;
    strcpy((char *)v9, "scene-points.txt");
    operator new();
  }
  sub_2153CF0DC((char *)v10.__r_.__value_.__l.__size_);
  return 0;
}

std::string *sub_2153F4E9C(std::string *result, void *a2)
{
  result->__r_.__value_.__l.__size_ = 0;
  p_std::string::size_type size = &result->__r_.__value_.__l.__size_;
  result->__r_.__value_.__r.__words[2] = 0;
  result->__r_.__value_.__r.__words[0] = (std::string::size_type)&result->__r_.__value_.__l.__size_;
  int v3 = a2 + 1;
  long long v4 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    float v5 = result;
    do
    {
      float v6 = (unsigned __int8 *)*p_size;
      unsigned int v7 = *((unsigned __int8 *)v4 + 32);
      std::string::size_type v8 = (uint64_t **)p_size;
      uint64_t v9 = (char *)p_size;
      if (*p_size)
      {
        while (1)
        {
          while (1)
          {
            uint64_t v9 = (char *)v6;
            unsigned int v10 = v6[32];
            if (v7 >= v10) {
              break;
            }
            float v6 = *(unsigned __int8 **)v9;
            std::string::size_type v8 = (uint64_t **)v9;
            if (!*(void *)v9) {
              goto LABEL_11;
            }
          }
          if (v10 >= v7) {
            break;
          }
          float v6 = (unsigned __int8 *)*((void *)v9 + 1);
          if (!v6)
          {
            std::string::size_type v8 = (uint64_t **)(v9 + 8);
            goto LABEL_11;
          }
        }
      }
      else
      {
LABEL_11:
        float v11 = v9;
        uint64_t v9 = (char *)operator new(0x40uLL);
        v9[32] = v7;
        *((void *)v9 + 6) = 0;
        *((void *)v9 + 7) = 0;
        *((void *)v9 + 5) = 0;
        *(void *)uint64_t v9 = 0;
        *((void *)v9 + 1) = 0;
        *((void *)v9 + 2) = v11;
        *std::string::size_type v8 = (uint64_t *)v9;
        std::string::size_type v12 = *(void *)v5->__r_.__value_.__l.__data_;
        int v13 = (uint64_t *)v9;
        if (v12)
        {
          v5->__r_.__value_.__r.__words[0] = v12;
          int v13 = *v8;
        }
        sub_2153CF298((uint64_t *)v5->__r_.__value_.__l.__size_, v13);
        ++v5->__r_.__value_.__r.__words[2];
      }
      __n128 result = std::string::operator=((std::string *)(v9 + 40), (const std::string *)(v4 + 8));
      uint64_t v14 = (void *)v4[1];
      if (v14)
      {
        do
        {
          uint64_t v15 = v14;
          uint64_t v14 = (void *)*v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          uint64_t v15 = (void *)v4[2];
          BOOL v16 = *v15 == (void)v4;
          long long v4 = v15;
        }
        while (!v16);
      }
      long long v4 = v15;
    }
    while (v15 != v3);
  }
  return result;
}

uint64_t sub_2153F4FDC(const char **a1, void *a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  int v3 = *a1;
  if (v3[23] < 0) {
    int v3 = *(const char **)v3;
  }
  uint64_t v4 = 0;
  if (!stat(v3, &__dst) && (__dst.st_mode & 0xF000) == 0x4000)
  {
    *((unsigned char *)&__str.__r_.__value_.__s + 23) = 13;
    strcpy((char *)&__str, "image-points.");
    uint64_t v4 = 1;
    if ((void *)*a2 != a2 + 1) {
      operator new();
    }
  }
  return v4;
}

void *sub_2153F5ED4(void *a1)
{
  MEMORY[0x2166B9550](&v12, a1, 1);
  if (!v12) {
    return a1;
  }
  uint64_t v2 = a1 + 5;
  std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
  int v3 = std::locale::use_facet(&v11, MEMORY[0x263F8C108]);
  std::locale::~locale(&v11);
  while (1)
  {
    uint64_t v4 = *(void **)((char *)v2 + *(void *)(*a1 - 24));
    float v5 = (unsigned char *)v4[3];
    if (v5 == (unsigned char *)v4[4]) {
      break;
    }
    LOBYTE(v6) = *v5;
LABEL_7:
    if ((v6 & 0x80) != 0 || (*((_DWORD *)&v3[1].~facet + v6) & 0x4000) == 0)
    {
      int v9 = 0;
      goto LABEL_12;
    }
    unsigned int v7 = *(void **)((char *)v2 + *(void *)(*a1 - 24));
    uint64_t v8 = v7[3];
    if (v8 == v7[4]) {
      (*(void (**)(void *))(*v7 + 80))(v7);
    }
    else {
      v7[3] = v8 + 1;
    }
  }
  int v6 = (*(uint64_t (**)(void *))(*v4 + 72))(v4);
  if (v6 != -1) {
    goto LABEL_7;
  }
  int v9 = 2;
LABEL_12:
  std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | v9);
  return a1;
}

void *sub_2153F6054(void *a1, uint64_t a2)
{
  sub_2153F5ED4(a1);
  int v4 = std::istream::peek();
  std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
  float v5 = std::ctype<char>::classic_table();
  if (v4 == 91)
  {
    memmove(__dst, v5, 0x400uLL);
    v10 |= 0x4000u;
    v8 |= 0x4000u;
    v9 |= 0x4000u;
    std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
    operator new();
  }
  MEMORY[0x2166B9590](a1, a2);
  MEMORY[0x2166B9590](a1, a2 + 4);
  MEMORY[0x2166B9590](a1, a2 + 8);
  std::locale::~locale(&v11);
  return a1;
}

char *sub_2153F63D0(char **a1, char *a2, long long *a3)
{
  int v4 = a2;
  unsigned int v7 = *a1;
  unint64_t v6 = (unint64_t)a1[1];
  uint64_t v8 = a2 - *a1;
  uint64_t v9 = v8 >> 5;
  unint64_t v10 = (unint64_t)a1[2];
  if (v6 < v10)
  {
    if (a2 == (char *)v6)
    {
      *(void *)a2 = *(void *)a3;
      float v20 = &v7[32 * v9];
      *((void *)v20 + 1) = *((void *)a3 + 1);
      *((_OWORD *)v20 + 1) = a3[1];
      a1[1] = a2 + 32;
    }
    else
    {
      long long v11 = *a3;
      long long v35 = a3[1];
      char v12 = (char *)(v6 - 32);
      int v13 = a1[1];
      if (v6 >= 0x20)
      {
        unint64_t v14 = v6 - 32;
        int v13 = a1[1];
        do
        {
          *(void *)int v13 = *(void *)v14;
          *((void *)v13 + 1) = *(void *)(v14 + 8);
          *((_OWORD *)v13 + 1) = *(_OWORD *)(v14 + 16);
          v13 += 32;
          v14 += 32;
        }
        while (v14 < v6);
      }
      a1[1] = v13;
      if ((char *)v6 != a2 + 32)
      {
        do
        {
          if (v12 != (char *)v6)
          {
            uint64_t v15 = *((void *)v12 - 4);
            *(void *)(v6 - 32) = v15 & 0xFFFFFFFFFFFFFFLL | ((unint64_t)*(unsigned __int8 *)(v6 - 25) << 56);
            *(void *)(v6 - 32) = v15 & 0xFFFFFFFFFFFFFFLL | ((unint64_t)*(v12 - 25) << 56);
          }
          *(void *)(v6 - 24) = *((void *)v12 - 3);
          *(_OWORD *)(v6 - 16) = *((_OWORD *)v12 - 1);
          v12 -= 32;
          v6 -= 32;
        }
        while (v12 != a2);
      }
      *(_OWORD *)a2 = v11;
      *(_OWORD *)&v7[32 * v9 + 16] = v35;
    }
    return v4;
  }
  unint64_t v16 = ((uint64_t)(v6 - (void)v7) >> 5) + 1;
  if (v16 >> 59) {
    abort();
  }
  uint64_t v17 = v10 - (void)v7;
  if (v17 >> 4 > v16) {
    unint64_t v16 = v17 >> 4;
  }
  if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFE0) {
    unint64_t v18 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v18 = v16;
  }
  if (v18)
  {
    if (v18 >> 59) {
      goto LABEL_43;
    }
    float v19 = (char *)operator new(32 * v18);
  }
  else
  {
    float v19 = 0;
  }
  float v21 = &v19[32 * v9];
  float v22 = &v19[32 * v18];
  if (v9 == v18)
  {
    if (v8 >= 1)
    {
      unint64_t v23 = v9 + 2;
      if (v9 >= -1) {
        unint64_t v23 = v9 + 1;
      }
      v21 -= 32 * (v23 >> 1);
      goto LABEL_33;
    }
    if (v7 == v4) {
      unint64_t v24 = 1;
    }
    else {
      unint64_t v24 = v8 >> 4;
    }
    if (!(v24 >> 59))
    {
      float v25 = (char *)operator new(32 * v24);
      float v21 = &v25[32 * (v24 >> 2)];
      float v22 = &v25[32 * v24];
      if (v19) {
        operator delete(v19);
      }
      goto LABEL_33;
    }
LABEL_43:
    sub_2153E6200();
  }
LABEL_33:
  long long v26 = a3[1];
  *(_OWORD *)float v21 = *a3;
  *((_OWORD *)v21 + 1) = v26;
  BOOL v27 = v21 + 32;
  float v28 = *a1;
  std::string::size_type v29 = v21;
  if (*a1 != v4)
  {
    float v30 = v4;
    std::string::size_type v29 = v21;
    do
    {
      uint64_t v31 = *((void *)v30 - 4);
      v30 -= 32;
      *((void *)v29 - 4) = v31;
      v29 -= 32;
      *((void *)v29 + 1) = *((void *)v30 + 1);
      *((_OWORD *)v29 + 1) = *((_OWORD *)v30 + 1);
    }
    while (v30 != v28);
  }
  for (uint64_t i = a1[1]; v4 != i; v4 += 32)
  {
    *(void *)BOOL v27 = *(void *)v4;
    *((void *)v27 + 1) = *((void *)v4 + 1);
    v27[1] = *((_OWORD *)v4 + 1);
    v27 += 2;
  }
  float v33 = *a1;
  *a1 = v29;
  a1[1] = (char *)v27;
  a1[2] = v22;
  if (v33) {
    operator delete(v33);
  }
  return v21;
}

uint64_t sub_2153F6678()
{
  return sub_2153F6690();
}

void sub_2153F6690(uint64_t a1, unint64_t a2, void *a3)
{
  float v5 = *(char **)(*a3 + 24);
  int v4 = *(char **)(*a3 + 32);
  if (v4 == v5) {
    return;
  }
  unint64_t v9 = (v4 - v5) >> 5;
  do
  {
    unint64_t v10 = v9 >> 1;
    long long v11 = (unint64_t *)&v5[32 * (v9 >> 1)];
    unint64_t v13 = *v11;
    char v12 = (char *)(v11 + 4);
    v9 += ~(v9 >> 1);
    if (v13 < a2) {
      float v5 = v12;
    }
    else {
      unint64_t v9 = v10;
    }
  }
  while (v9);
  if (v5 == v4 || *(void *)v5 != a2) {
    return;
  }
  unint64_t v14 = *(void *)(a1 + 8);
  if (v14)
  {
    uint8x8_t v15 = (uint8x8_t)vcnt_s8((int8x8_t)v14);
    v15.i16[0] = vaddlv_u8(v15);
    if (v15.u32[0] > 1uLL)
    {
      unint64_t v16 = a2;
      if (v14 <= a2) {
        unint64_t v16 = a2 % v14;
      }
    }
    else
    {
      unint64_t v16 = (v14 - 1) & a2;
    }
    uint64_t v17 = *(void **)(*(void *)a1 + 8 * v16);
    if (v17)
    {
      unint64_t v18 = (void *)*v17;
      if (v18)
      {
        if (v15.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v20 = v18[1];
            if (v20 == a2)
            {
              if (v18[2] == a2) {
                goto LABEL_67;
              }
            }
            else if ((v20 & (v14 - 1)) != v16)
            {
              goto LABEL_30;
            }
            unint64_t v18 = (void *)*v18;
            if (!v18) {
              goto LABEL_30;
            }
          }
        }
        do
        {
          unint64_t v19 = v18[1];
          if (v19 == a2)
          {
            if (v18[2] == a2)
            {
LABEL_67:
              uint64_t v34 = (uint64_t)(v18 + 3);
              unint64_t v37 = *((void *)v5 + 3);
              float32x2_t v36 = (uint64_t *)(v5 + 24);
              unint64_t v35 = v37;
              goto LABEL_105;
            }
          }
          else
          {
            if (v19 >= v14) {
              v19 %= v14;
            }
            if (v19 != v16) {
              break;
            }
          }
          unint64_t v18 = (void *)*v18;
        }
        while (v18);
      }
    }
LABEL_30:
    if (v15.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v14 <= a2) {
        unint64_t v3 = a2 % v14;
      }
    }
    else
    {
      unint64_t v3 = (v14 - 1) & a2;
    }
    float v21 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v21)
    {
      float v22 = (char *)*v21;
      if (*v21)
      {
        if (v15.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v24 = *((void *)v22 + 1);
            if (v24 == a2)
            {
              if (*((void *)v22 + 2) == a2) {
                goto LABEL_88;
              }
            }
            else if ((v24 & (v14 - 1)) != v3)
            {
              goto LABEL_49;
            }
            float v22 = *(char **)v22;
            if (!v22) {
              goto LABEL_49;
            }
          }
        }
        do
        {
          unint64_t v23 = *((void *)v22 + 1);
          if (v23 == a2)
          {
            if (*((void *)v22 + 2) == a2) {
              goto LABEL_88;
            }
          }
          else
          {
            if (v23 >= v14) {
              v23 %= v14;
            }
            if (v23 != v3) {
              break;
            }
          }
          float v22 = *(char **)v22;
        }
        while (v22);
      }
    }
  }
LABEL_49:
  float v22 = (char *)operator new(0x40uLL);
  *(void *)float v22 = 0;
  *((void *)v22 + 1) = a2;
  *((void *)v22 + 2) = a2;
  *(_OWORD *)(v22 + 24) = 0u;
  *(_OWORD *)(v22 + 40) = 0u;
  *((_DWORD *)v22 + 14) = 1065353216;
  float v25 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v26 = *(float *)(a1 + 32);
  if (!v14 || (float)(v26 * (float)v14) < v25)
  {
    BOOL v27 = 1;
    if (v14 >= 3) {
      BOOL v27 = (v14 & (v14 - 1)) != 0;
    }
    unint64_t v28 = v27 | (2 * v14);
    unint64_t v29 = vcvtps_u32_f32(v25 / v26);
    if (v28 <= v29) {
      size_t prime = v29;
    }
    else {
      size_t prime = v28;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v14 = *(void *)(a1 + 8);
    }
    if (prime > v14) {
      goto LABEL_72;
    }
    if (prime < v14)
    {
      unint64_t v31 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v14 < 3 || (uint8x8_t v32 = (uint8x8_t)vcnt_s8((int8x8_t)v14), v32.i16[0] = vaddlv_u8(v32), v32.u32[0] > 1uLL))
      {
        unint64_t v31 = std::__next_prime(v31);
      }
      else
      {
        uint64_t v33 = 1 << -(char)__clz(v31 - 1);
        if (v31 >= 2) {
          unint64_t v31 = v33;
        }
      }
      if (prime <= v31) {
        size_t prime = v31;
      }
      if (prime < v14) {
LABEL_72:
      }
        sub_2153F6BC0(a1, prime);
    }
    unint64_t v14 = *(void *)(a1 + 8);
    if ((v14 & (v14 - 1)) != 0)
    {
      if (v14 <= a2) {
        unint64_t v3 = a2 % v14;
      }
      else {
        unint64_t v3 = a2;
      }
    }
    else
    {
      unint64_t v3 = (v14 - 1) & a2;
    }
  }
  uint64_t v38 = *(void *)a1;
  float v39 = *(void **)(*(void *)a1 + 8 * v3);
  if (v39)
  {
    *(void *)float v22 = *v39;
LABEL_86:
    *float v39 = v22;
    goto LABEL_87;
  }
  *(void *)float v22 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v22;
  *(void *)(v38 + 8 * v3) = a1 + 16;
  if (*(void *)v22)
  {
    unint64_t v40 = *(void *)(*(void *)v22 + 8);
    if ((v14 & (v14 - 1)) != 0)
    {
      if (v40 >= v14) {
        v40 %= v14;
      }
    }
    else
    {
      v40 &= v14 - 1;
    }
    float v39 = (void *)(*(void *)a1 + 8 * v40);
    goto LABEL_86;
  }
LABEL_87:
  ++*(void *)(a1 + 24);
LABEL_88:
  unint64_t v41 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 40) / *((float *)v22 + 14));
  if (v41 == 1)
  {
    unint64_t v41 = 2;
  }
  else if ((v41 & (v41 - 1)) != 0)
  {
    unint64_t v41 = std::__next_prime(v41);
  }
  int8x8_t v42 = *(int8x8_t *)(v22 + 32);
  if (v41 > *(void *)&v42) {
    goto LABEL_103;
  }
  if (v41 < *(void *)&v42)
  {
    unint64_t v43 = vcvtps_u32_f32((float)*((unint64_t *)v22 + 6) / *((float *)v22 + 14));
    if (*(void *)&v42 < 3uLL || (uint8x8_t v44 = (uint8x8_t)vcnt_s8(v42), v44.i16[0] = vaddlv_u8(v44), v44.u32[0] > 1uLL))
    {
      unint64_t v43 = std::__next_prime(v43);
    }
    else
    {
      uint64_t v45 = 1 << -(char)__clz(v43 - 1);
      if (v43 >= 2) {
        unint64_t v43 = v45;
      }
    }
    if (v41 <= v43) {
      unint64_t v41 = v43;
    }
    if (v41 < *(void *)&v42) {
LABEL_103:
    }
      sub_2153F6BC0((uint64_t)(v22 + 24), v41);
  }
  unint64_t v46 = *((void *)v5 + 3);
  float32x2_t v36 = (uint64_t *)(v5 + 24);
  unint64_t v35 = v46;
  uint64_t v34 = (uint64_t)(v22 + 24);
LABEL_105:
  BOOL v47 = sub_2153F71B8(v34, v35, v36);
  uint64_t v49 = *a3;
  uint64_t v48 = a3[1];
  if (v48) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v48 + 8), 1uLL, memory_order_relaxed);
  }
  int64_t v50 = (std::__shared_weak_count *)v47[4];
  v47[3] = v49;
  v47[4] = v48;
  if (v50 && !atomic_fetch_add(&v50->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
    std::__shared_weak_count::__release_weak(v50);
  }
}

void sub_2153F6BC0(uint64_t a1, unint64_t a2)
{
  if (!a2)
  {
    uint8x8_t v15 = *(void **)a1;
    *(void *)a1 = 0;
    if (v15) {
      operator delete(v15);
    }
    *(void *)(a1 + 8) = 0;
    return;
  }
  if (a2 >> 61) {
    sub_2153E6200();
  }
  int v4 = operator new(8 * a2);
  float v5 = *(void **)a1;
  *(void *)a1 = v4;
  if (v5) {
    operator delete(v5);
  }
  uint64_t v6 = 0;
  *(void *)(a1 + 8) = a2;
  do
    *(void *)(*(void *)a1 + 8 * v6++) = 0;
  while (a2 != v6);
  uint64_t v8 = a1 + 16;
  unsigned int v7 = *(void **)(a1 + 16);
  if (v7)
  {
    unint64_t v9 = v7[1];
    unint64_t v10 = a2 - 1;
    if ((a2 & (a2 - 1)) == 0)
    {
      uint64_t v11 = v9 & v10;
      *(void *)(*(void *)a1 + 8 * v11) = v8;
      while (1)
      {
        char v12 = (void *)*v7;
        if (!*v7) {
          break;
        }
        uint64_t v13 = v12[1] & v10;
        if (v13 == v11)
        {
          unsigned int v7 = (void *)*v7;
        }
        else if (*(void *)(*(void *)a1 + 8 * v13))
        {
          *unsigned int v7 = *v12;
          uint64_t v14 = 8 * v13;
          void *v12 = **(void **)(*(void *)a1 + v14);
          **(void **)(*(void *)a1 + v14) = v12;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v13) = v7;
          unsigned int v7 = v12;
          uint64_t v11 = v13;
        }
      }
      return;
    }
    if (v9 >= a2) {
      v9 %= a2;
    }
    *(void *)(*(void *)a1 + 8 * v9) = v8;
    unint64_t v16 = (void *)*v7;
    if (*v7)
    {
      do
      {
        unint64_t v18 = v16[1];
        if (v18 >= a2) {
          v18 %= a2;
        }
        if (v18 != v9)
        {
          if (!*(void *)(*(void *)a1 + 8 * v18))
          {
            *(void *)(*(void *)a1 + 8 * v18) = v7;
            goto LABEL_26;
          }
          *unsigned int v7 = *v16;
          uint64_t v17 = 8 * v18;
          void *v16 = **(void **)(*(void *)a1 + v17);
          **(void **)(*(void *)a1 + v17) = v16;
          unint64_t v16 = v7;
        }
        unint64_t v18 = v9;
LABEL_26:
        unsigned int v7 = v16;
        unint64_t v16 = (void *)*v16;
        unint64_t v9 = v18;
      }
      while (v16);
    }
  }
}

uint64_t sub_2153F6D68(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 24);
  if (v1)
  {
    *(unsigned char *)(v1 + 64) = 0;
    uint64_t v2 = *(void **)(v1 + 24);
    *(void *)(v1 + 32) = v2;
    if (v2) {
      operator delete(v2);
    }
    unint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
    if (v3) {
      std::__shared_weak_count::__release_weak(v3);
    }
    JUMPOUT(0x2166B9890);
  }
  return result;
}

void sub_2153F6DDC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2166B9890);
}

uint64_t *sub_2153F6E18(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  unint64_t v3 = a2;
  if (*a2)
  {
    int v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      unint64_t v3 = a2;
      goto LABEL_7;
    }
    do
    {
      unint64_t v3 = v4;
      int v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  uint64_t v2 = v3[1];
  if (v2)
  {
LABEL_7:
    int v5 = 0;
    *(void *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  int v5 = 1;
LABEL_8:
  uint64_t v6 = (uint64_t **)v3[2];
  unsigned int v7 = *v6;
  if (*v6 == v3)
  {
    *uint64_t v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      unsigned int v7 = 0;
      __n128 result = (uint64_t *)v2;
    }
    else
    {
      unsigned int v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (uint64_t *)v2;
  }
  int v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    uint64_t v9 = a2[2];
    v3[2] = v9;
    *(void *)(v9 + 8 * (*(void *)a2[2] != (void)a2)) = v3;
    uint64_t v11 = *a2;
    uint64_t v10 = a2[1];
    *(void *)(v11 + 16) = v3;
    *unint64_t v3 = v11;
    v3[1] = v10;
    if (v10) {
      *(void *)(v10 + 16) = v3;
    }
    *((unsigned char *)v3 + 24) = *((unsigned char *)a2 + 24);
    if (result == a2) {
      __n128 result = v3;
    }
  }
  if (!v8 || !result) {
    return result;
  }
  if (!v5)
  {
    *(unsigned char *)(v2 + 24) = 1;
    return result;
  }
  while (1)
  {
    uint64_t v14 = (uint64_t **)v7[2];
    if (*v14 != v7) {
      break;
    }
    if (*((unsigned char *)v7 + 24))
    {
      unint64_t v16 = (void *)*v7;
      if (*v7) {
        goto LABEL_50;
      }
    }
    else
    {
      *((unsigned char *)v7 + 24) = 1;
      *((unsigned char *)v14 + 24) = 0;
      uint64_t v20 = (uint64_t *)v7[1];
      void *v14 = v20;
      if (v20) {
        void v20[2] = (uint64_t)v14;
      }
      void v7[2] = (uint64_t)v14[2];
      v14[2][*v14[2] != (void)v14] = (uint64_t)v7;
      v7[1] = (uint64_t)v14;
      void v14[2] = v7;
      if (result == (uint64_t *)v14) {
        __n128 result = v7;
      }
      unsigned int v7 = *v14;
      unint64_t v16 = (void *)**v14;
      if (v16)
      {
LABEL_50:
        if (!*((unsigned char *)v16 + 24)) {
          goto LABEL_71;
        }
      }
    }
    float v21 = (uint64_t *)v7[1];
    if (v21 && !*((unsigned char *)v21 + 24))
    {
      if (v16 && !*((unsigned char *)v16 + 24))
      {
LABEL_71:
        float v21 = v7;
      }
      else
      {
        *((unsigned char *)v21 + 24) = 1;
        *((unsigned char *)v7 + 24) = 0;
        uint64_t v22 = *v21;
        v7[1] = *v21;
        if (v22) {
          *(void *)(v22 + 16) = v7;
        }
        v21[2] = v7[2];
        *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v21;
        *float v21 = (uint64_t)v7;
        void v7[2] = (uint64_t)v21;
        unint64_t v16 = v7;
      }
      BOOL v27 = (uint64_t *)v21[2];
      *((unsigned char *)v21 + 24) = *((unsigned char *)v27 + 24);
      *((unsigned char *)v27 + 24) = 1;
      *((unsigned char *)v16 + 24) = 1;
      uint64_t v28 = *v27;
      uint64_t v29 = *(void *)(*v27 + 8);
      uint64_t *v27 = v29;
      if (v29) {
        *(void *)(v29 + 16) = v27;
      }
      *(void *)(v28 + 16) = v27[2];
      *(void *)(v27[2] + 8 * (*(void *)v27[2] != (void)v27)) = v28;
      *(void *)(v28 + 8) = v27;
      v27[2] = v28;
      return result;
    }
    *((unsigned char *)v7 + 24) = 0;
    char v12 = (uint64_t *)v7[2];
    if (*((unsigned char *)v12 + 24)) {
      BOOL v13 = v12 == result;
    }
    else {
      BOOL v13 = 1;
    }
    if (v13) {
      goto LABEL_61;
    }
LABEL_26:
    unsigned int v7 = *(uint64_t **)(v12[2] + 8 * (*(void *)v12[2] == (void)v12));
  }
  if (*((unsigned char *)v7 + 24))
  {
    uint8x8_t v15 = (void *)*v7;
    if (!*v7)
    {
LABEL_40:
      unint64_t v19 = (uint64_t *)v7[1];
      if (v19 && !*((unsigned char *)v19 + 24)) {
        goto LABEL_67;
      }
      *((unsigned char *)v7 + 24) = 0;
      char v12 = (uint64_t *)v7[2];
      if (v12 == result)
      {
        char v12 = result;
LABEL_61:
        *((unsigned char *)v12 + 24) = 1;
        return result;
      }
      if (!*((unsigned char *)v12 + 24)) {
        goto LABEL_61;
      }
      goto LABEL_26;
    }
  }
  else
  {
    *((unsigned char *)v7 + 24) = 1;
    *((unsigned char *)v14 + 24) = 0;
    uint64_t v17 = v14[1];
    unint64_t v18 = (uint64_t *)*v17;
    v14[1] = (uint64_t *)*v17;
    if (v18) {
      void v18[2] = (uint64_t)v14;
    }
    void v17[2] = (uint64_t)v14[2];
    v14[2][*v14[2] != (void)v14] = (uint64_t)v17;
    *uint64_t v17 = (uint64_t)v14;
    void v14[2] = v17;
    if (result == (uint64_t *)*v7) {
      __n128 result = v7;
    }
    unsigned int v7 = *(uint64_t **)(*v7 + 8);
    uint8x8_t v15 = (void *)*v7;
    if (!*v7) {
      goto LABEL_40;
    }
  }
  if (*((unsigned char *)v15 + 24)) {
    goto LABEL_40;
  }
  unint64_t v19 = (uint64_t *)v7[1];
  if (v19 && !*((unsigned char *)v19 + 24))
  {
LABEL_67:
    uint8x8_t v15 = v7;
  }
  else
  {
    *((unsigned char *)v15 + 24) = 1;
    *((unsigned char *)v7 + 24) = 0;
    uint64_t v23 = v15[1];
    *unsigned int v7 = v23;
    if (v23) {
      *(void *)(v23 + 16) = v7;
    }
    double v15[2] = v7[2];
    *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v15;
    v15[1] = v7;
    void v7[2] = (uint64_t)v15;
    unint64_t v19 = v7;
  }
  uint64_t v24 = v15[2];
  *((unsigned char *)v15 + 24) = *(unsigned char *)(v24 + 24);
  *(unsigned char *)(v24 + 24) = 1;
  *((unsigned char *)v19 + 24) = 1;
  float v25 = *(uint64_t **)(v24 + 8);
  uint64_t v26 = *v25;
  *(void *)(v24 + 8) = *v25;
  if (v26) {
    *(void *)(v26 + 16) = v24;
  }
  void v25[2] = *(void *)(v24 + 16);
  *(void *)(*(void *)(v24 + 16) + 8 * (**(void **)(v24 + 16) != v24)) = v25;
  *float v25 = v24;
  *(void *)(v24 + 16) = v25;
  return result;
}

void *sub_2153F71B8(uint64_t a1, unint64_t a2, uint64_t *a3)
{
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            uint64_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  uint64_t v10 = operator new(0x28uLL);
  void *v10 = 0;
  v10[1] = a2;
  uint64_t v13 = *a3;
  v10[3] = 0;
  v10[4] = 0;
  void v10[2] = v13;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (!v7 || (float)(v15 * (float)v7) < v14)
  {
    BOOL v16 = 1;
    if (v7 >= 3) {
      BOOL v16 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v7);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t prime = v18;
    }
    else {
      size_t prime = v17;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_44;
    }
    if (prime < v7)
    {
      unint64_t v20 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v21 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v21.i16[0] = vaddlv_u8(v21), v21.u32[0] > 1uLL))
      {
        unint64_t v20 = std::__next_prime(v20);
      }
      else
      {
        uint64_t v22 = 1 << -(char)__clz(v20 - 1);
        if (v20 >= 2) {
          unint64_t v20 = v22;
        }
      }
      if (prime <= v20) {
        size_t prime = v20;
      }
      if (prime < v7) {
LABEL_44:
      }
        sub_2153F6BC0(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
      else {
        unint64_t v3 = a2;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
  }
  uint64_t v23 = *(void *)a1;
  uint64_t v24 = *(void **)(*(void *)a1 + 8 * v3);
  if (v24)
  {
    void *v10 = *v24;
LABEL_58:
    void *v24 = v10;
    goto LABEL_59;
  }
  void *v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v23 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v25 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v25 >= v7) {
        v25 %= v7;
      }
    }
    else
    {
      v25 &= v7 - 1;
    }
    uint64_t v24 = (void *)(*(void *)a1 + 8 * v25);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

uint64_t cva::adp::Session<float>::loadImageMeasurementsSet(void *a1)
{
  uint64_t v1 = (const char **)(a1 + 13);
  sub_2153F4E9C(&v4, a1);
  uint64_t v2 = sub_2153F4FDC(v1, &v4);
  sub_2153CF0DC((char *)v4.__r_.__value_.__l.__size_);
  return v2;
}

void cva::adp::Session<float>::loadDiscretePoses()
{
  uint64_t v1 = *MEMORY[0x263EF8340];
  __s[23] = 9;
  strcpy(__s, "WtoP.traj");
  operator new();
}

void cva::adp::Session<float>::setDataPath(int a1, cva::adp::io::Paths *this)
{
}

uint64_t cva::adp::Session<float>::setDataPath(uint64_t a1, const std::string **a2, const std::string **a3)
{
  uint64_t v6 = (const char *)*a2;
  if (SHIBYTE((*a2)->__r_.__value_.__r.__words[2]) < 0) {
    uint64_t v6 = *(const char **)v6;
  }
  int v7 = access(v6, 0);
  uint64_t result = 0;
  if (!v7)
  {
    uint64_t v9 = (const char *)*a3;
    if (SHIBYTE((*a3)->__r_.__value_.__r.__words[2]) < 0) {
      uint64_t v9 = *(const char **)v9;
    }
    int v10 = access(v9, 0);
    uint64_t result = 0;
    if (!v10)
    {
      if ((const std::string **)(a1 + 96) != a2) {
        std::string::operator=(*(std::string **)(a1 + 96), *a2);
      }
      if ((const std::string **)(a1 + 104) != a3) {
        std::string::operator=(*(std::string **)(a1 + 104), *a3);
      }
      return 1;
    }
  }
  return result;
}

uint64_t cva::adp::Session<float>::serializer(uint64_t a1)
{
  return a1 + 56;
}

uint64_t cva::adp::Session<float>::dataPath(uint64_t a1)
{
  return a1 + 96;
}

uint64_t cva::adp::Session<float>::sensorsPath(uint64_t a1)
{
  return a1 + 104;
}

uint64_t cva::adp::Session<double>::loadDevice(uint64_t a1, uint64_t **a2, const std::string *a3)
{
  uint64_t v50 = *MEMORY[0x263EF8340];
  int v5 = (std::string::size_type *)(a1 + 56);
  uint64_t result = cva::adp::io::PListSerializer::read((void *)(a1 + 56), *a2);
  if (!result) {
    return result;
  }
  if (!*v5) {
    return 0;
  }
  int v7 = (std::string *)(a1 + 72);
  std::string::operator=((std::string *)(a1 + 72), a3);
  *((unsigned char *)&v44.__r_.__value_.__s + 23) = 18;
  strcpy((char *)&v44, "Sensors/Intrinsics");
  if (*(char *)(a1 + 95) < 0)
  {
    sub_2153C0AE4(&__dst, *(void **)(a1 + 72), *(void *)(a1 + 80));
  }
  else
  {
    *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
    __dst.__r_.__value_.__r.__words[2] = *(void *)(a1 + 88);
  }
  cva::adp::PListPath::convertToPath((unint64_t *)&v44, (uint64_t)v47);
  if (v48 >= 0) {
    uint8x8_t v8 = (const std::string::value_type *)v47;
  }
  else {
    uint8x8_t v8 = (const std::string::value_type *)v47[0];
  }
  if (v48 >= 0) {
    std::string::size_type v9 = v48;
  }
  else {
    std::string::size_type v9 = (std::string::size_type)v47[1];
  }
  std::string::append(&__dst, v8, v9);
  if (v48 < 0) {
    operator delete(v47[0]);
  }
  HIBYTE(v43[2]) = 18;
  strcpy((char *)v43, "Sensors/Extrinsics");
  if (*(char *)(a1 + 95) < 0)
  {
    sub_2153C0AE4(&v44, *(void **)(a1 + 72), *(void *)(a1 + 80));
  }
  else
  {
    *(_OWORD *)&v44.__r_.__value_.__l.__data_ = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
    v44.__r_.__value_.__r.__words[2] = *(void *)(a1 + 88);
  }
  cva::adp::PListPath::convertToPath((unint64_t *)v43, (uint64_t)v47);
  if (v48 >= 0) {
    int v10 = (const std::string::value_type *)v47;
  }
  else {
    int v10 = (const std::string::value_type *)v47[0];
  }
  if (v48 >= 0) {
    std::string::size_type v11 = v48;
  }
  else {
    std::string::size_type v11 = (std::string::size_type)v47[1];
  }
  std::string::append(&v44, v10, v11);
  if (v48 < 0) {
    operator delete(v47[0]);
  }
  memset(v43, 0, 24);
  if (!cva::adp::io::PListSerializer::getKeys(v5, &__dst, (void **)v43))
  {
    int v13 = 0;
    goto LABEL_65;
  }
  long long __p = 0;
  unint64_t v41 = 0;
  uint64_t v42 = 0;
  if (!cva::adp::io::PListSerializer::getKeys(v5, &v44, &__p))
  {
    int v13 = 0;
    uint64_t v22 = (void **)__p;
    if (!__p) {
      goto LABEL_65;
    }
    goto LABEL_59;
  }
  uint64_t v38 = 0;
  uint64_t v39 = 0;
  uint64_t v12 = &v38;
  unint64_t v37 = &v38;
  char v48 = 6;
  strcpy((char *)v47, "Camera");
  int v13 = cva::adp::io::detail::keysToNames(v5, (const void **)&__dst.__r_.__value_.__l.__data_, v43, (uint64_t)v47, (uint64_t **)&v37);
  if (v48 < 0) {
    operator delete(v47[0]);
  }
  if (v13)
  {
    unint64_t v35 = 0;
    size_t __sz = 0;
    uint64_t v34 = (uint64_t *)&v35;
    char v48 = 8;
    strcpy((char *)v47, "Platform");
    int v13 = 0;
    if (cva::adp::io::detail::createFromToTree(&v37, (uint64_t *)&__p, (unsigned __int8 *)v47, &v34))
    {
      float v14 = v38;
      if (v38)
      {
        while (1)
        {
          while (1)
          {
            float v15 = (uint64_t **)v14;
            unint64_t v16 = v14[4];
            if (v16 < 0x100) {
              break;
            }
            float v14 = *v15;
            uint64_t v12 = v15;
            if (!*v15) {
              goto LABEL_39;
            }
          }
          if (v16 == 255) {
            break;
          }
          float v14 = v15[1];
          if (!v14)
          {
            uint64_t v12 = v15 + 1;
            goto LABEL_39;
          }
        }
      }
      else
      {
        float v15 = &v38;
LABEL_39:
        unint64_t v17 = (uint64_t *)v15;
        float v15 = (uint64_t **)operator new(0x40uLL);
        v15[4] = (uint64_t *)255;
        v15[5] = 0;
        CVPixelBufferRef v15[6] = 0;
        v15[7] = 0;
        void *v15 = 0;
        v15[1] = 0;
        double v15[2] = v17;
        uint64_t *v12 = (uint64_t *)v15;
        unint64_t v18 = (uint64_t *)v15;
        if (*v37)
        {
          unint64_t v37 = (uint64_t **)*v37;
          unint64_t v18 = *v12;
        }
        sub_2153CF298(v38, v18);
        ++v39;
      }
      MEMORY[0x2166B9470](v15 + 5, "Platform");
      unint64_t v19 = (void **)operator new(0x40uLL);
      uint64_t *v19 = &unk_26C5FBED0;
      v19[1] = &v37;
      void v19[2] = v5;
      v19[3] = &__dst;
      double v19[4] = &v34;
      v19[5] = &v44;
      v19[6] = (void *)a1;
      v19[7] = v47;
      uint64_t v49 = v19;
      unint64_t v31 = 0;
      unint64_t v32 = 0;
      uint64_t v33 = 0;
      size_t v20 = __sz;
      if (__sz)
      {
        if ((__sz & 0x8000000000000000) != 0) {
          abort();
        }
        unint64_t v31 = (char *)operator new(__sz);
        unint64_t v32 = (unint64_t)v31;
        uint64_t v33 = &v31[v20];
      }
      cva::adp::io::detail::findChildNodes(&v34, 255, (unint64_t *)&v31);
      uint8x8_t v21 = v31;
      if (v31 == (char *)v32)
      {
        int v13 = 0;
      }
      else
      {
        char v46 = -1;
        if (!v49)
        {
          uint64_t v30 = sub_2153E5390();
          return sub_2153F8520(v30);
        }
        int v13 = (*((uint64_t (**)(void **, char **, char *))*v49 + 6))(v49, &v31, &v46);
        uint8x8_t v21 = v31;
      }
      if (v21)
      {
        unint64_t v32 = (unint64_t)v21;
        operator delete(v21);
      }
      if (v49 == v47)
      {
        (*((void (**)(void **))v47[0] + 4))(v47);
      }
      else if (v49)
      {
        (*((void (**)(void))*v49 + 5))();
      }
    }
    sub_2153E770C(v35);
  }
  sub_2153CF0DC((char *)v38);
  uint64_t v22 = (void **)__p;
  if (__p)
  {
LABEL_59:
    for (uint64_t i = v41; i != v22; i -= 3)
    {
      if (*((char *)i - 1) < 0) {
        operator delete(*(i - 3));
      }
    }
    operator delete(v22);
  }
LABEL_65:
  uint64_t v24 = (std::string *)v43[0];
  if (v43[0])
  {
    for (uint64_t j = v43[1]; j != v24; --j)
    {
      if (SHIBYTE(j[-1].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(j[-1].__r_.__value_.__l.__data_);
      }
    }
    operator delete(v24);
  }
  if ((SHIBYTE(v44.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_74;
    }
    goto LABEL_85;
  }
  operator delete(v44.__r_.__value_.__l.__data_);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
LABEL_85:
    operator delete(__dst.__r_.__value_.__l.__data_);
    if (v13) {
      goto LABEL_75;
    }
    return 0;
  }
LABEL_74:
  if (!v13) {
    return 0;
  }
LABEL_75:
  char v48 = 7;
  strcpy((char *)v47, "Version");
  __dst.__r_.__value_.__r.__words[0] = 0;
  int v26 = sub_2153C9660(v5, (std::string *)(a1 + 72), (uint64_t)v47);
  std::string::size_type v27 = __dst.__r_.__value_.__r.__words[0];
  if (!v26) {
    std::string::size_type v27 = 0x100000000;
  }
  *(void *)(a1 + 24) = v27;
  if (v48 < 0) {
    operator delete(v47[0]);
  }
  char v48 = 6;
  strcpy((char *)v47, "Device");
  uint64_t v28 = a1 + 32;
  char v29 = cva::adp::io::PListSerializer::getItem<std::string>(v5, v7, (uint64_t)v47);
  if (v48 < 0) {
    operator delete(v47[0]);
  }
  if ((v29 & 1) == 0) {
    MEMORY[0x2166B9470](v28, "Generic Device");
  }
  return 1;
}

uint64_t sub_2153F8520()
{
  v0 = (void *)MEMORY[0x270FA5388]();
  if (*v1 != v1[1])
  {
    CFAllocatorRef v63 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    CFAllocatorRef v62 = (const __CFAllocator *)*MEMORY[0x263EFFB28];
    int64x2_t v64 = vdupq_n_s64(0x3FF921FB54442D18uLL);
    uint64_t v2 = v0[1];
    int v5 = *(void **)(v2 + 8);
    unint64_t v3 = (void *)(v2 + 8);
    std::string v4 = v5;
    if (!v5) {
      goto LABEL_13;
    }
    unint64_t v6 = **v1;
    int v7 = v3;
    do
    {
      unint64_t v8 = v4[4];
      BOOL v9 = v8 >= v6;
      if (v8 >= v6) {
        int v10 = v4;
      }
      else {
        int v10 = v4 + 1;
      }
      if (v9) {
        int v7 = v4;
      }
      std::string v4 = (void *)*v10;
    }
    while (*v10);
    if (v7 == v3 || v7[4] > v6) {
LABEL_13:
    }
      int v7 = v3;
    uint64_t v12 = (std::string::size_type *)v0[2];
    uint64_t v11 = v0[3];
    if (*(char *)(v11 + 23) < 0)
    {
      sub_2153C0AE4(&v79, *(void **)v11, *(void *)(v11 + 8));
    }
    else
    {
      long long v13 = *(_OWORD *)v11;
      v79.__r_.__value_.__r.__words[2] = *(void *)(v11 + 16);
      *(_OWORD *)&v79.__r_.__value_.__l.__data_ = v13;
    }
    __s = v7 + 5;
    cva::adp::PListPath::convertToPath(v7 + 5, (uint64_t)__p);
    if (__p[23] >= 0) {
      float v14 = __p;
    }
    else {
      float v14 = *(const std::string::value_type **)__p;
    }
    if (__p[23] >= 0) {
      std::string::size_type v15 = __p[23];
    }
    else {
      std::string::size_type v15 = *(void *)&__p[8];
    }
    std::string::append(&v79, v14, v15);
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
    int v78 = 0;
    v76[1] = 0;
    v76[0] = 0;
    uint64_t v77 = 0;
    __p[23] = 12;
    strcpy(__p, "Camera Model");
    if (!cva::adp::io::PListSerializer::getItem<std::string>(v12, &v79, (uint64_t)__p))
    {
      if ((__p[23] & 0x80000000) != 0) {
        operator delete(*(void **)__p);
      }
LABEL_47:
      if (SHIBYTE(v77) < 0)
      {
        operator delete(v76[0]);
        if ((SHIBYTE(v79.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          return 0;
        }
      }
      else if ((SHIBYTE(v79.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
        return 0;
      }
      operator delete(v79.__r_.__value_.__l.__data_);
      return 0;
    }
    char v16 = sub_2153EDE90((int **)v76, &v78);
    char v17 = v16;
    if ((__p[23] & 0x80000000) != 0)
    {
      operator delete(*(void **)__p);
      if ((v17 & 1) == 0) {
        goto LABEL_47;
      }
    }
    else if ((v16 & 1) == 0)
    {
      goto LABEL_47;
    }
    uint64_t v75 = 0x3FF0000000000000;
    __p[23] = 18;
    strcpy(__p, "Standard Deviation");
    cva::adp::io::PListSerializer::getItem<double>(v12, &v79, (uint64_t)__p, &v75);
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
    switch(v78)
    {
      case 0:
        *(void *)long long __p = 0x3FF0000000000000;
        __p[8] = 1;
        *(void *)&__p[16] = 0x3FF0000000000000;
        LOBYTE(v67) = 1;
        uint64_t v68 = 0;
        uint64_t v69 = 0;
        char v70 = 1;
        long long v71 = xmmword_2154461E8;
        long long v72 = unk_2154461F8;
        uint64_t v73 = 0x200000002;
        if (sub_2153FEFE8(v12, v11, __s, (uint64_t)__p)) {
          operator new();
        }
        goto LABEL_47;
      case 1:
        *(void *)long long __p = 0x3FF0000000000000;
        __p[8] = 1;
        *(void *)&__p[16] = 0x3FF0000000000000;
        LOBYTE(v67) = 1;
        uint64_t v68 = 0;
        uint64_t v69 = 0;
        char v70 = 1;
        long long v71 = xmmword_2154461E8;
        long long v72 = unk_2154461F8;
        uint64_t v73 = 0x200000002;
        long long v87 = 0u;
        *(_OWORD *)uint64_t v86 = 0u;
        LOBYTE(v88) = 1;
        uint64_t v89 = 0x3FF921FB54442D18;
        uint64_t v90 = 0xA00000000;
        if (!sub_2153FEFE8(v12, v11, __s, (uint64_t)__p)) {
          goto LABEL_47;
        }
        if (*(char *)(v11 + 23) < 0)
        {
          sub_2153C0AE4(&v95, *(void **)v11, *(void *)(v11 + 8));
        }
        else
        {
          long long v18 = *(_OWORD *)v11;
          v95.__r_.__value_.__r.__words[2] = *(void *)(v11 + 16);
          *(_OWORD *)&v95.__r_.__value_.__l.__data_ = v18;
        }
        cva::adp::PListPath::convertToPath(__s, (uint64_t)&__dst);
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_dst = &__dst;
        }
        else {
          p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
        }
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type size = __dst.__r_.__value_.__l.__size_;
        }
        std::string::append(&v95, (const std::string::value_type *)p_dst, size);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        uint64_t v24 = (char *)operator new(0x20uLL);
        v96.__r_.__value_.__r.__words[0] = (std::string::size_type)v24;
        *(_OWORD *)&v96.__r_.__value_.__r.__words[1] = xmmword_215445EE0;
        strcpy(v24, "Kannala Radial Distortion");
        if (SHIBYTE(v95.__r_.__value_.__r.__words[2]) < 0) {
          sub_2153C0AE4(&v94, v95.__r_.__value_.__l.__data_, v95.__r_.__value_.__l.__size_);
        }
        else {
          std::string v94 = v95;
        }
        cva::adp::PListPath::convertToPath((unint64_t *)&v96, (uint64_t)&__dst);
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          char v29 = &__dst;
        }
        else {
          char v29 = (std::string *)__dst.__r_.__value_.__r.__words[0];
        }
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v30 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v30 = __dst.__r_.__value_.__l.__size_;
        }
        std::string::append(&v94, (const std::string::value_type *)v29, v30);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        operator delete(v24);
        *((unsigned char *)&v85.__r_.__value_.__s + 23) = 16;
        strcpy((char *)&v85, "Symmetric Radial");
        if (SHIBYTE(v94.__r_.__value_.__r.__words[2]) < 0) {
          sub_2153C0AE4(&v96, v94.__r_.__value_.__l.__data_, v94.__r_.__value_.__l.__size_);
        }
        else {
          std::string v96 = v94;
        }
        cva::adp::PListPath::convertToPath((unint64_t *)&v85, (uint64_t)&__dst);
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v45 = &__dst;
        }
        else {
          uint64_t v45 = (std::string *)__dst.__r_.__value_.__r.__words[0];
        }
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v46 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v46 = __dst.__r_.__value_.__l.__size_;
        }
        std::string::append(&v96, (const std::string::value_type *)v45, v46);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 4;
        strcpy((char *)&__dst, "Data");
        int v47 = sub_2154025FC(v12, &v96, (uint64_t)&__dst);
        int v48 = v47;
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(__dst.__r_.__value_.__l.__data_);
          if (v48)
          {
LABEL_145:
            *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 5;
            strcpy((char *)&__dst, "Fixed");
            int v49 = cva::adp::io::PListSerializer::getItem<BOOL>(v12, &v96, (uint64_t)&__dst, &v88);
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__dst.__r_.__value_.__l.__data_);
            }
            char v50 = v88 ^ 1;
            if (!v49) {
              char v50 = 1;
            }
            LOBYTE(v88) = v50;
            if (SHIBYTE(v96.__r_.__value_.__r.__words[2]) < 0)
            {
LABEL_150:
              operator delete(v96.__r_.__value_.__l.__data_);
              if (v48)
              {
LABEL_183:
                *((unsigned char *)&v96.__r_.__value_.__s + 23) = 16;
                strcpy((char *)&v96, "Projection Model");
                memset(&__dst, 0, sizeof(__dst));
                char v58 = 0;
                if (cva::adp::io::PListSerializer::getItem<std::string>(v12, &v95, (uint64_t)&v96)) {
                  char v58 = sub_2153F18B8((uint64_t **)&__dst, &v90);
                }
                if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                {
                  operator delete(__dst.__r_.__value_.__l.__data_);
                  if ((SHIBYTE(v96.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                  {
LABEL_187:
                    if (v58) {
                      goto LABEL_189;
                    }
                    goto LABEL_188;
                  }
                }
                else if ((SHIBYTE(v96.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                {
                  goto LABEL_187;
                }
                operator delete(v96.__r_.__value_.__l.__data_);
                if (v58)
                {
LABEL_189:
                  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 13;
                  strcpy((char *)&__dst, "Field of View");
                  char v59 = cva::adp::io::PListSerializer::getItem<double>(v12, &v94, (uint64_t)&__dst, &v89);
                  char v60 = v59;
                  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                  {
                    operator delete(__dst.__r_.__value_.__l.__data_);
                    if (v60)
                    {
LABEL_191:
                      if ((SHIBYTE(v94.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                        goto LABEL_192;
                      }
                      goto LABEL_199;
                    }
                  }
                  else if (v59)
                  {
                    goto LABEL_191;
                  }
                  uint64_t v89 = 0x3FF921FB54442D18;
                  if ((SHIBYTE(v94.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                  {
LABEL_192:
                    if ((SHIBYTE(v95.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                      goto LABEL_193;
                    }
LABEL_200:
                    operator delete(v95.__r_.__value_.__l.__data_);
LABEL_193:
                    operator new();
                  }
LABEL_199:
                  operator delete(v94.__r_.__value_.__l.__data_);
                  if ((SHIBYTE(v95.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                    goto LABEL_193;
                  }
                  goto LABEL_200;
                }
LABEL_188:
                LODWORD(v90) = 0;
                goto LABEL_189;
              }
LABEL_182:
              long long v87 = 0u;
              *(_OWORD *)uint64_t v86 = 0u;
              LOBYTE(v88) = 1;
              goto LABEL_183;
            }
LABEL_181:
            if (v48) {
              goto LABEL_183;
            }
            goto LABEL_182;
          }
        }
        else if (v47)
        {
          goto LABEL_145;
        }
        if (SHIBYTE(v96.__r_.__value_.__r.__words[2]) < 0) {
          goto LABEL_150;
        }
        goto LABEL_181;
      case 2:
        *(void *)long long __p = 0x3FF0000000000000;
        __p[8] = 1;
        *(void *)&__p[16] = 0x3FF0000000000000;
        LOBYTE(v67) = 1;
        uint64_t v68 = 0;
        uint64_t v69 = 0;
        char v70 = 1;
        long long v71 = xmmword_2154461E8;
        long long v72 = unk_2154461F8;
        uint64_t v73 = 0x200000002;
        uint64_t v88 = 0;
        long long v87 = 0u;
        *(_OWORD *)uint64_t v86 = 0u;
        LOBYTE(v89) = 1;
        LODWORD(v90) = 10;
        if (!sub_2153FEFE8(v12, v11, __s, (uint64_t)__p)) {
          goto LABEL_47;
        }
        if (*(char *)(v11 + 23) < 0)
        {
          sub_2153C0AE4(&v94, *(void **)v11, *(void *)(v11 + 8));
        }
        else
        {
          long long v19 = *(_OWORD *)v11;
          v94.__r_.__value_.__r.__words[2] = *(void *)(v11 + 16);
          *(_OWORD *)&v94.__r_.__value_.__l.__data_ = v19;
        }
        cva::adp::PListPath::convertToPath(__s, (uint64_t)&__dst);
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          unint64_t v25 = &__dst;
        }
        else {
          unint64_t v25 = (std::string *)__dst.__r_.__value_.__r.__words[0];
        }
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v26 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v26 = __dst.__r_.__value_.__l.__size_;
        }
        std::string::append(&v94, (const std::string::value_type *)v25, v26);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        *((unsigned char *)&v96.__r_.__value_.__s + 23) = 19;
        strcpy((char *)&v96, "Heikkila Distortion");
        if (SHIBYTE(v94.__r_.__value_.__r.__words[2]) < 0) {
          sub_2153C0AE4(&v85, v94.__r_.__value_.__l.__data_, v94.__r_.__value_.__l.__size_);
        }
        else {
          std::string v85 = v94;
        }
        cva::adp::PListPath::convertToPath((unint64_t *)&v96, (uint64_t)&__dst);
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          unint64_t v31 = &__dst;
        }
        else {
          unint64_t v31 = (std::string *)__dst.__r_.__value_.__r.__words[0];
        }
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v32 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v32 = __dst.__r_.__value_.__l.__size_;
        }
        std::string::append(&v85, (const std::string::value_type *)v31, v32);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        HIBYTE(v84[2]) = 21;
        strcpy((char *)v84, "Radial And Tangential");
        if (SHIBYTE(v85.__r_.__value_.__r.__words[2]) < 0) {
          sub_2153C0AE4(&v96, v85.__r_.__value_.__l.__data_, v85.__r_.__value_.__l.__size_);
        }
        else {
          std::string v96 = v85;
        }
        cva::adp::PListPath::convertToPath(v84, (uint64_t)&__dst);
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          int64_t v51 = &__dst;
        }
        else {
          int64_t v51 = (std::string *)__dst.__r_.__value_.__r.__words[0];
        }
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v52 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v52 = __dst.__r_.__value_.__l.__size_;
        }
        std::string::append(&v96, (const std::string::value_type *)v51, v52);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        *((unsigned char *)&v95.__r_.__value_.__s + 23) = 4;
        strcpy((char *)&v95, "Data");
        cva::adp::io::PListSerializer::getPath(v12, &v96, &v82);
        std::string::size_type v53 = v82;
        if (v82)
        {
          uint64_t v54 = (v95.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
              ? &v95
              : (std::string *)v95.__r_.__value_.__r.__words[0];
          CFStringRef v55 = CFStringCreateWithCStringNoCopy(v63, (const char *)v54, 0x8000100u, v62);
          std::string::size_type v56 = (const void *)[*(id *)v53 objectForKey:v55];
          char v57 = *(unsigned char *)(v53 + 8);
          CFTypeRef cf = v56;
          char v81 = v57;
          if (v56) {
            CFRetain(v56);
          }
          else {
            char v81 = 0;
          }
          CFRelease(v55);
          if (cf)
          {
            if (cva::ItemHandler::isVectorType(&cf))
            {
              memset(&__dst, 0, 20);
              sub_2153FB048();
            }
            if (cf) {
              CFRelease(cf);
            }
          }
        }
        std::string::size_type v61 = v83;
        if (v83 && !atomic_fetch_add(&v83->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
          std::__shared_weak_count::__release_weak(v61);
          if ((SHIBYTE(v95.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
LABEL_211:
            if (SHIBYTE(v96.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v96.__r_.__value_.__l.__data_);
            }
            uint64_t v88 = 0;
            long long v87 = 0u;
            *(_OWORD *)uint64_t v86 = 0u;
            LOBYTE(v89) = 1;
            if (SHIBYTE(v85.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v85.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v94.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v94.__r_.__value_.__l.__data_);
            }
            operator new();
          }
        }
        else if ((SHIBYTE(v95.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
          goto LABEL_211;
        }
        operator delete(v95.__r_.__value_.__l.__data_);
        goto LABEL_211;
      case 3:
        LOBYTE(v86[1]) = 1;
        v86[0] = (void *)0x3FF0000000000000;
        *(void *)&long long v87 = 0x3FF0000000000000;
        BYTE8(v87) = 1;
        uint64_t v88 = 0;
        uint64_t v89 = 0;
        LOBYTE(v90) = 1;
        long long v91 = xmmword_2154461E8;
        long long v92 = unk_2154461F8;
        uint64_t v93 = 0x200000002;
        *(int64x2_t *)long long __p = v64;
        *(void *)&__p[16] = 0;
        uint64_t v67 = 0;
        memset_pattern16(&v68, &unk_215445FF0, 0x800uLL);
        memset_pattern16(v74, &unk_215445FF0, 0x800uLL);
        if (!sub_2153FEFE8(v12, v11, __s, (uint64_t)v86)) {
          goto LABEL_47;
        }
        if (*(char *)(v11 + 23) < 0)
        {
          sub_2153C0AE4(&v96, *(void **)v11, *(void *)(v11 + 8));
        }
        else
        {
          long long v20 = *(_OWORD *)v11;
          v96.__r_.__value_.__r.__words[2] = *(void *)(v11 + 16);
          *(_OWORD *)&v96.__r_.__value_.__l.__data_ = v20;
        }
        cva::adp::PListPath::convertToPath(__s, (uint64_t)&__dst);
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v27 = &__dst;
        }
        else {
          std::string::size_type v27 = (std::string *)__dst.__r_.__value_.__r.__words[0];
        }
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v28 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v28 = __dst.__r_.__value_.__l.__size_;
        }
        std::string::append(&v96, (const std::string::value_type *)v27, v28);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        strcpy((char *)&v94, "Pinhole LUT Distortion");
        *((unsigned char *)&v94.__r_.__value_.__s + 23) = 22;
        if (SHIBYTE(v96.__r_.__value_.__r.__words[2]) < 0) {
          sub_2153C0AE4(&v95, v96.__r_.__value_.__l.__data_, v96.__r_.__value_.__l.__size_);
        }
        else {
          std::string v95 = v96;
        }
        cva::adp::PListPath::convertToPath((unint64_t *)&v94, (uint64_t)&__dst);
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v33 = &__dst;
        }
        else {
          uint64_t v33 = (std::string *)__dst.__r_.__value_.__r.__words[0];
        }
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v34 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v34 = __dst.__r_.__value_.__l.__size_;
        }
        std::string::append(&v95, (const std::string::value_type *)v33, v34);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 7;
        strcpy((char *)&__dst, "Distort");
        char v35 = sub_2154009AC(v12, &v95, (uint64_t)&__dst);
        char v36 = v35;
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(__dst.__r_.__value_.__l.__data_);
          if (v36)
          {
LABEL_120:
            *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 13;
            strcpy((char *)&__dst, "Field Of View");
            char v37 = cva::adp::io::PListSerializer::getItem<double>(v12, &v95, (uint64_t)&__dst, __p);
            char v38 = v37;
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(__dst.__r_.__value_.__l.__data_);
              if (v38)
              {
LABEL_123:
                *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 9;
                strcpy((char *)&__dst, "Undistort");
                char v39 = sub_2154009AC(v12, &v95, (uint64_t)&__dst);
                char v40 = v39;
                if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                {
                  operator delete(__dst.__r_.__value_.__l.__data_);
                  if (v40)
                  {
LABEL_126:
                    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 21;
                    strcpy((char *)&__dst, "Inverse Field Of View");
                    char v41 = cva::adp::io::PListSerializer::getItem<double>(v12, &v95, (uint64_t)&__dst, &__p[8]);
                    char v42 = v41;
                    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                    {
                      operator delete(__dst.__r_.__value_.__l.__data_);
                      if (v42)
                      {
LABEL_129:
                        *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 17;
                        strcpy((char *)&__dst, "Distortion Center");
                        char v43 = sub_215400B88(v12, &v95, (uint64_t)&__dst);
                        char v44 = v43;
                        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                        {
                          operator delete(__dst.__r_.__value_.__l.__data_);
                          if (v44)
                          {
LABEL_131:
                            if ((SHIBYTE(v95.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                              goto LABEL_132;
                            }
                            goto LABEL_177;
                          }
                        }
                        else if (v43)
                        {
                          goto LABEL_131;
                        }
                        *(void *)&__p[16] = 0;
                        uint64_t v67 = 0;
                        if ((SHIBYTE(v95.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                        {
LABEL_132:
                          if ((SHIBYTE(v96.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                            goto LABEL_133;
                          }
LABEL_178:
                          operator delete(v96.__r_.__value_.__l.__data_);
LABEL_133:
                          operator new();
                        }
LABEL_177:
                        operator delete(v95.__r_.__value_.__l.__data_);
                        if ((SHIBYTE(v96.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                          goto LABEL_133;
                        }
                        goto LABEL_178;
                      }
                    }
                    else if (v41)
                    {
                      goto LABEL_129;
                    }
                    *(void *)&__p[8] = 0x3FF921FB54442D18;
                    goto LABEL_129;
                  }
                }
                else if (v39)
                {
                  goto LABEL_126;
                }
                memset_pattern16(v74, &unk_215445FF0, 0x800uLL);
                goto LABEL_126;
              }
            }
            else if (v37)
            {
              goto LABEL_123;
            }
            *(void *)long long __p = 0x3FF921FB54442D18;
            goto LABEL_123;
          }
        }
        else if (v35)
        {
          goto LABEL_120;
        }
        memset_pattern16(&v68, &unk_215445FF0, 0x800uLL);
        goto LABEL_120;
      default:
        goto LABEL_47;
    }
  }
  return 1;
}

uint64_t sub_2153FAB4C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_2153FAB7C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2166B9890);
}

uint64_t sub_2153FABB8(uint64_t result, char a2)
{
  *(unsigned char *)(result + 16) = a2;
  *(unsigned char *)(result + 32) = a2;
  return result;
}

uint64_t sub_2153FABC4(uint64_t a1, uint64_t a2, double a3)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a2 + 16))(a2) != 1) {
    return 0;
  }
  int v7 = *(double **)(a1 + 40);
  unint64_t v6 = *(double **)(a1 + 48);
  if (v7 == v6) {
    return 0;
  }
  if (*v7 <= a3)
  {
    unint64_t v8 = v7 + 3;
    do
    {
      BOOL v9 = v8;
      if (v8 == v6) {
        break;
      }
      v8 += 3;
    }
    while (*v9 <= a3);
    int v7 = v9 - 3;
  }
  *(double *)(a2 + 224) = v7[1] * *(double *)(a1 + 8) + *(double *)(a1 + 24);
  uint64_t result = 1;
  *(unsigned char *)(a2 + 232) = 1;
  return result;
}

uint64_t sub_2153FAC88()
{
  return 0;
}

void sub_2153FAC90(void *a1)
{
  *a1 = &unk_26C5FBA18;
  uint64_t v2 = (void *)a1[5];
  if (v2)
  {
    a1[6] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x2166B9890);
}

void *sub_2153FAD00(void *a1)
{
  *a1 = &unk_26C5FBA18;
  uint64_t v2 = (void *)a1[5];
  if (v2)
  {
    a1[6] = v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t sub_2153FAD50(std::string::size_type *a1, uint64_t a2, unint64_t *a3, void *a4)
{
  if (*(char *)(a2 + 23) < 0) {
    sub_2153C0AE4(&__dst, *(void **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string __dst = *(std::string *)a2;
  }
  cva::adp::PListPath::convertToPath(a3, (uint64_t)__p);
  if (v17 >= 0) {
    int v7 = __p;
  }
  else {
    int v7 = (void **)__p[0];
  }
  if (v17 >= 0) {
    std::string::size_type v8 = v17;
  }
  else {
    std::string::size_type v8 = (std::string::size_type)__p[1];
  }
  std::string::append(&__dst, (const std::string::value_type *)v7, v8);
  if (v17 < 0) {
    operator delete(__p[0]);
  }
  char v17 = 4;
  strcpy((char *)__p, "Data");
  uint64_t v9 = sub_2153FAEC0(a1, &__dst, (uint64_t)__p);
  uint64_t v10 = v9;
  if (v17 < 0)
  {
    operator delete(__p[0]);
    if (!v10)
    {
LABEL_14:
      if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        return v10;
      }
LABEL_22:
      operator delete(__dst.__r_.__value_.__l.__data_);
      return v10;
    }
  }
  else if (!v9)
  {
    goto LABEL_14;
  }
  *a4 = 0;
  uint64_t v12 = (char *)(a4 + 1);
  char v17 = 5;
  strcpy((char *)__p, "Fixed");
  int v13 = cva::adp::io::PListSerializer::getItem<BOOL>(a1, &__dst, (uint64_t)__p, v12);
  if (v17 < 0) {
    operator delete(__p[0]);
  }
  char v14 = *v12 ^ 1;
  if (!v13) {
    char v14 = 1;
  }
  char *v12 = v14;
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_22;
  }
  return v10;
}

uint64_t sub_2153FAEC0(std::string::size_type *a1, std::string *a2, uint64_t a3)
{
  cva::adp::io::PListSerializer::getPath(a1, a2, &v15);
  std::string::size_type v4 = v15;
  if (v15)
  {
    if (*(char *)(a3 + 23) >= 0) {
      int v5 = (const char *)a3;
    }
    else {
      int v5 = *(const char **)a3;
    }
    CFStringRef v6 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v5, 0x8000100u, (CFAllocatorRef)*MEMORY[0x263EFFB28]);
    CFStringRef v7 = (const __CFString *)[*(id *)v4 objectForKey:v6];
    CFStringRef v8 = v7;
    char v9 = *(unsigned char *)(v4 + 8);
    CFTypeRef cf = v7;
    char v14 = v9;
    if (v7)
    {
      CFRetain(v7);
      CFRelease(v6);
      if (cva::ItemHandler::isVectorType(&cf)) {
        sub_2153FB048();
      }
      CFStringRef v10 = v8;
    }
    else
    {
      char v14 = 0;
      CFStringRef v10 = v6;
    }
    CFRelease(v10);
  }
  uint64_t v11 = v16;
  if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  return 0;
}

void sub_2153FB034(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

void sub_2153FB048()
{
}

uint64_t sub_2153FB104(std::string::size_type *a1, uint64_t a2, unint64_t *a3, char *a4)
{
  if (*(char *)(a2 + 23) < 0) {
    sub_2153C0AE4(&__dst, *(void **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string __dst = *(std::string *)a2;
  }
  CFStringRef p_p = (const __CFString *)&__p;
  cva::adp::PListPath::convertToPath(a3, (uint64_t)&__p);
  if (v26 >= 0) {
    CFStringRef v8 = (const std::string::value_type *)&__p;
  }
  else {
    CFStringRef v8 = (const std::string::value_type *)__p;
  }
  if (v26 >= 0) {
    std::string::size_type v9 = v26;
  }
  else {
    std::string::size_type v9 = v24;
  }
  std::string::append(&__dst, v8, v9);
  if (v26 < 0) {
    operator delete(__p);
  }
  char v21 = 4;
  strcpy(cStr, "Data");
  cva::adp::io::PListSerializer::getPath(a1, &__dst, &v29);
  std::string::size_type v10 = v29;
  if (v29)
  {
    CFStringRef v11 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], cStr, 0x8000100u, (CFAllocatorRef)*MEMORY[0x263EFFB28]);
    uint64_t v12 = (void **)[*(id *)v10 objectForKey:v11];
    CFStringRef p_p = (const __CFString *)v12;
    char v13 = *(unsigned char *)(v10 + 8);
    CFTypeRef cf = v12;
    char v28 = v13;
    if (v12)
    {
      CFRetain(v12);
      CFRelease(v11);
      if (cva::ItemHandler::isVectorType(&cf))
      {
        long long __p = 0;
        std::string::size_type v24 = 0;
        int v25 = 0;
        sub_2153FB048();
      }
      CFStringRef v14 = p_p;
    }
    else
    {
      char v28 = 0;
      CFStringRef v14 = v11;
    }
    CFRelease(v14);
    LODWORD(v10) = 0;
  }
  std::string::size_type v15 = v30;
  if (v30 && !atomic_fetch_add(&v30->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  int v16 = p_p & v10;
  if (v21 < 0)
  {
    operator delete(*(void **)cStr);
    if (!v16)
    {
LABEL_24:
      if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        return p_p & v10;
      }
LABEL_32:
      operator delete(__dst.__r_.__value_.__l.__data_);
      return p_p & v10;
    }
  }
  else if (!v16)
  {
    goto LABEL_24;
  }
  char v26 = 5;
  strcpy((char *)&__p, "Fixed");
  int v18 = cva::adp::io::PListSerializer::getItem<BOOL>(a1, &__dst, (uint64_t)&__p, a4);
  if (v26 < 0) {
    operator delete(__p);
  }
  char v19 = *a4 ^ 1;
  if (!v18) {
    char v19 = 1;
  }
  *a4 = v19;
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_32;
  }
  return p_p & v10;
}

void sub_2153FB3D8(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_2153FB3EC(std::string::size_type *a1, uint64_t a2, unint64_t *a3, uint64_t a4)
{
  if (*(char *)(a2 + 23) < 0) {
    sub_2153C0AE4(&__dst, *(void **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string __dst = *(std::string *)a2;
  }
  CFStringRef p_p = (const __CFString *)&__p;
  cva::adp::PListPath::convertToPath(a3, (uint64_t)&__p);
  if (v27 >= 0) {
    CFStringRef v8 = (const std::string::value_type *)&__p;
  }
  else {
    CFStringRef v8 = (const std::string::value_type *)__p;
  }
  if (v27 >= 0) {
    std::string::size_type v9 = v27;
  }
  else {
    std::string::size_type v9 = v25;
  }
  std::string::append(&__dst, v8, v9);
  if (v27 < 0) {
    operator delete(__p);
  }
  char v22 = 4;
  strcpy(cStr, "Data");
  cva::adp::io::PListSerializer::getPath(a1, &__dst, &v30);
  std::string::size_type v10 = v30;
  if (v30)
  {
    CFStringRef v11 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], cStr, 0x8000100u, (CFAllocatorRef)*MEMORY[0x263EFFB28]);
    uint64_t v12 = (void **)[*(id *)v10 objectForKey:v11];
    CFStringRef p_p = (const __CFString *)v12;
    char v13 = *(unsigned char *)(v10 + 8);
    CFTypeRef cf = v12;
    char v29 = v13;
    if (v12)
    {
      CFRetain(v12);
      CFRelease(v11);
      if (cva::ItemHandler::isVectorType(&cf))
      {
        long long __p = 0;
        std::string::size_type v25 = 0;
        int v26 = 0;
        sub_2153FB048();
      }
      CFStringRef v14 = p_p;
    }
    else
    {
      char v29 = 0;
      CFStringRef v14 = v11;
    }
    CFRelease(v14);
    LODWORD(v10) = 0;
  }
  std::string::size_type v15 = v31;
  if (v31 && !atomic_fetch_add(&v31->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  int v16 = p_p & v10;
  if (v22 < 0)
  {
    operator delete(*(void **)cStr);
    if (!v16)
    {
LABEL_24:
      if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        return p_p & v10;
      }
LABEL_32:
      operator delete(__dst.__r_.__value_.__l.__data_);
      return p_p & v10;
    }
  }
  else if (!v16)
  {
    goto LABEL_24;
  }
  char v27 = 5;
  strcpy((char *)&__p, "Fixed");
  int v18 = (char *)(a4 + 24);
  int v19 = cva::adp::io::PListSerializer::getItem<BOOL>(a1, &__dst, (uint64_t)&__p, v18);
  if (v27 < 0) {
    operator delete(__p);
  }
  char v20 = *v18 ^ 1;
  if (!v19) {
    char v20 = 1;
  }
  char *v18 = v20;
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_32;
  }
  return p_p & v10;
}

void sub_2153FB690(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

__n128 sub_2153FB6A4(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(double **)a2;
  if (*(void *)a2 == a1)
  {
    uint64_t v11 = 0;
    long long v9 = 0u;
    long long v10 = 0u;
    long long v7 = 0u;
    __n128 v8 = 0u;
    sub_2153FB6A4(&v7);
    long long v6 = v10;
    *(_OWORD *)(a1 + 32) = v9;
    *(_OWORD *)(a1 + 48) = v6;
    *(void *)(a1 + 64) = v11;
    __n128 result = v8;
    *(_OWORD *)a1 = v7;
    *(__n128 *)(a1 + 16) = result;
  }
  else
  {
    std::string::size_type v4 = **(double ***)(a2 + 8);
    *(double *)a1 = *v3 * *v4 + 0.0 + v3[3] * v4[3] + v3[6] * v4[6];
    *(double *)(a1 + 8) = v3[1] * *v4 + 0.0 + v3[4] * v4[3] + v3[7] * v4[6];
    *(double *)(a1 + 16) = v3[2] * *v4 + 0.0 + v3[5] * v4[3] + v3[8] * v4[6];
    *(double *)(a1 + 24) = *v3 * v4[1] + 0.0 + v3[3] * v4[4] + v3[6] * v4[7];
    *(double *)(a1 + 32) = v3[1] * v4[1] + 0.0 + v3[4] * v4[4] + v3[7] * v4[7];
    *(double *)(a1 + 40) = v3[2] * v4[1] + 0.0 + v3[5] * v4[4] + v3[8] * v4[7];
    *(double *)(a1 + 48) = *v3 * v4[2] + 0.0 + v3[3] * v4[5] + v3[6] * v4[8];
    *(double *)(a1 + 56) = v3[1] * v4[2] + 0.0 + v3[4] * v4[5] + v3[7] * v4[8];
    result.n128_f64[0] = v3[2] * v4[2] + 0.0 + v3[5] * v4[5] + v3[8] * v4[8];
    *(void *)(a1 + 64) = result.n128_u64[0];
  }
  return result;
}

BOOL sub_2153FB880(uint64_t a1, uint64_t a2, double a3)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a2 + 16))(a2) != 1) {
    return 0;
  }
  uint64_t v15 = a2 + 16;
  uint64_t v16 = a1 + 16;
  char v17 = &v15;
  float64x2_t v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  uint64_t v22 = 0;
  sub_2153FB6A4((uint64_t)&v18, (uint64_t)&v16);
  long long v11 = v19;
  long long v12 = v20;
  long long v13 = v21;
  uint64_t v14 = v22;
  float64x2_t v10 = v18;
  float64x2_t v18 = 0uLL;
  *(void *)&long long v19 = 0;
  sub_2153CAD38(&v10, v18.f64);
  if (sqrt(v18.f64[0] * v18.f64[0] + v18.f64[1] * v18.f64[1] + *(double *)&v19 * *(double *)&v19) >= a3) {
    return 0;
  }
  double v6 = *(double *)(a1 + 104) - *(double *)(a2 + 104);
  float64x2_t v7 = vsubq_f64(*(float64x2_t *)(a1 + 88), *(float64x2_t *)(a2 + 88));
  if (sqrt(vaddvq_f64(vmulq_f64(v7, v7)) + v6 * v6) >= a3) {
    return 0;
  }
  uint64_t v15 = a2 + 128;
  uint64_t v16 = a1 + 128;
  char v17 = &v15;
  float64x2_t v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  uint64_t v22 = 0;
  sub_2153FB6A4((uint64_t)&v18, (uint64_t)&v16);
  long long v11 = v19;
  long long v12 = v20;
  long long v13 = v21;
  uint64_t v14 = v22;
  float64x2_t v10 = v18;
  float64x2_t v18 = 0uLL;
  *(void *)&long long v19 = 0;
  sub_2153CAD38(&v10, v18.f64);
  if (sqrt(v18.f64[0] * v18.f64[0] + v18.f64[1] * v18.f64[1] + *(double *)&v19 * *(double *)&v19) >= a3) {
    return 0;
  }
  if (*(unsigned __int8 *)(a1 + 120) == *(unsigned __int8 *)(a2 + 120)
    && (float64x2_t v8 = vsubq_f64(*(float64x2_t *)(a1 + 200), *(float64x2_t *)(a2 + 200)), sqrt(vaddvq_f64(vmulq_f64(v8, v8))) < a3)
    && *(unsigned __int8 *)(a1 + 216) == *(unsigned __int8 *)(a2 + 216)
    && *(double *)(a1 + 224) - *(double *)(a2 + 224) < a3)
  {
    return *(double *)(a1 + 240) - *(double *)(a2 + 240) < a3;
  }
  else
  {
    return 0;
  }
}

uint64_t *sub_2153FBAC0(uint64_t a1, uint64_t *a2)
{
  sub_2153FBECC((unsigned char *)(a1 + 8), a2);
  sub_2153FC018((long long *)(a1 + 88), a2);
  if (*(unsigned char *)(a1 + 120)) {
    std::string::size_type v4 = "[FREE]";
  }
  else {
    std::string::size_type v4 = "[FIXED]";
  }
  if (*(unsigned char *)(a1 + 120)) {
    size_t v5 = 6;
  }
  else {
    size_t v5 = 7;
  }
  char v41 = v5;
  memcpy(__dst, v4, v5);
  *(unsigned char *)((unint64_t)__dst | v5) = 0;
  if (v41 >= 0) {
    double v6 = __dst;
  }
  else {
    double v6 = *(char **)__dst;
  }
  if (v41 >= 0) {
    uint64_t v7 = v41;
  }
  else {
    uint64_t v7 = *(void *)&__dst[8];
  }
  float64x2_t v8 = sub_2153C1168(a2, (uint64_t)v6, v7);
  long long v9 = sub_2153C1168(v8, (uint64_t)"[", 1);
  char v39 = 14;
  strcpy((char *)__p, "Delta Rotation");
  float64x2_t v10 = sub_2153C1168(v9, (uint64_t)__p, 14);
  sub_2153C1168(v10, (uint64_t)"] : ", 4);
  v42[0] = 0;
  v42[1] = 0;
  double v43 = 0.0;
  sub_2153CAD38((float64x2_t *)(a1 + 128), (double *)v42);
  long long v11 = sub_2153FD54C(a2, *(__n128 *)v42, v43);
  sub_2153C1168(v11, (uint64_t)"\n", 1);
  if (v39 < 0)
  {
    operator delete(__p[0]);
    if ((v41 & 0x80000000) == 0) {
      goto LABEL_15;
    }
  }
  else if ((v41 & 0x80000000) == 0)
  {
    goto LABEL_15;
  }
  operator delete(*(void **)__dst);
LABEL_15:
  if (*(unsigned char *)(a1 + 216)) {
    long long v12 = "[FREE]";
  }
  else {
    long long v12 = "[FIXED]";
  }
  if (*(unsigned char *)(a1 + 216)) {
    size_t v13 = 6;
  }
  else {
    size_t v13 = 7;
  }
  HIBYTE(v43) = v13;
  memcpy(v42, v12, v13);
  *(unsigned char *)((unint64_t)v42 | v13) = 0;
  if (v43 >= 0.0) {
    uint64_t v14 = v42;
  }
  else {
    uint64_t v14 = (void **)v42[0];
  }
  if (v43 >= 0.0) {
    uint64_t v15 = HIBYTE(v43);
  }
  else {
    uint64_t v15 = (uint64_t)v42[1];
  }
  uint64_t v16 = sub_2153C1168(a2, (uint64_t)v14, v15);
  char v17 = sub_2153C1168(v16, (uint64_t)"[", 1);
  char v41 = 17;
  strcpy(__dst, "Delta Translation");
  float64x2_t v18 = sub_2153C1168(v17, (uint64_t)__dst, 17);
  long long v19 = sub_2153C1168(v18, (uint64_t)"] : ", 4);
  long long v20 = sub_2153FCB30(v19, *(__n128 *)(a1 + 200));
  sub_2153C1168(v20, (uint64_t)"\n", 1);
  if (v41 < 0)
  {
    operator delete(*(void **)__dst);
    if ((SHIBYTE(v43) & 0x80000000) == 0) {
      goto LABEL_29;
    }
  }
  else if ((SHIBYTE(v43) & 0x80000000) == 0)
  {
    goto LABEL_29;
  }
  operator delete(v42[0]);
LABEL_29:
  if (*(unsigned char *)(a1 + 232)) {
    long long v21 = "[FREE]";
  }
  else {
    long long v21 = "[FIXED]";
  }
  if (*(unsigned char *)(a1 + 232)) {
    size_t v22 = 6;
  }
  else {
    size_t v22 = 7;
  }
  HIBYTE(v43) = v22;
  memcpy(v42, v21, v22);
  *(unsigned char *)((unint64_t)v42 | v22) = 0;
  if (v43 >= 0.0) {
    uint64_t v23 = v42;
  }
  else {
    uint64_t v23 = (void **)v42[0];
  }
  if (v43 >= 0.0) {
    uint64_t v24 = HIBYTE(v43);
  }
  else {
    uint64_t v24 = (uint64_t)v42[1];
  }
  std::string::size_type v25 = sub_2153C1168(a2, (uint64_t)v23, v24);
  int v26 = sub_2153C1168(v25, (uint64_t)"[", 1);
  char v41 = 15;
  strcpy(__dst, "Linear Position");
  char v27 = sub_2153C1168(v26, (uint64_t)__dst, 15);
  sub_2153C1168(v27, (uint64_t)"] : ", 4);
  char v28 = (void *)std::ostream::operator<<();
  sub_2153C1168(v28, (uint64_t)"\n", 1);
  if (v41 < 0)
  {
    operator delete(*(void **)__dst);
    if ((SHIBYTE(v43) & 0x80000000) == 0) {
      goto LABEL_43;
    }
  }
  else if ((SHIBYTE(v43) & 0x80000000) == 0)
  {
    goto LABEL_43;
  }
  operator delete(v42[0]);
LABEL_43:
  if (*(unsigned char *)(a1 + 248)) {
    char v29 = "[FREE]";
  }
  else {
    char v29 = "[FIXED]";
  }
  if (*(unsigned char *)(a1 + 248)) {
    size_t v30 = 6;
  }
  else {
    size_t v30 = 7;
  }
  HIBYTE(v43) = v30;
  memcpy(v42, v29, v30);
  *(unsigned char *)((unint64_t)v42 | v30) = 0;
  if (v43 >= 0.0) {
    unint64_t v31 = v42;
  }
  else {
    unint64_t v31 = (void **)v42[0];
  }
  if (v43 >= 0.0) {
    uint64_t v32 = HIBYTE(v43);
  }
  else {
    uint64_t v32 = (uint64_t)v42[1];
  }
  uint64_t v33 = sub_2153C1168(a2, (uint64_t)v31, v32);
  std::string::size_type v34 = sub_2153C1168(v33, (uint64_t)"[", 1);
  char v41 = 13;
  strcpy(__dst, "Linear Length");
  char v35 = sub_2153C1168(v34, (uint64_t)__dst, 13);
  sub_2153C1168(v35, (uint64_t)"] : ", 4);
  char v36 = (void *)std::ostream::operator<<();
  sub_2153C1168(v36, (uint64_t)"\n", 1);
  if (v41 < 0)
  {
    operator delete(*(void **)__dst);
    if ((SHIBYTE(v43) & 0x80000000) == 0) {
      return a2;
    }
LABEL_65:
    operator delete(v42[0]);
    return a2;
  }
  if (SHIBYTE(v43) < 0) {
    goto LABEL_65;
  }
  return a2;
}

uint64_t *sub_2153FBECC(unsigned char *a1, uint64_t *a2)
{
  unint64_t v3 = (float64x2_t *)(a1 + 8);
  if (*a1) {
    std::string::size_type v4 = "[FREE]";
  }
  else {
    std::string::size_type v4 = "[FIXED]";
  }
  if (*a1) {
    size_t v5 = 6;
  }
  else {
    size_t v5 = 7;
  }
  unsigned __int8 v16 = v5;
  memcpy(__dst, v4, v5);
  *(unsigned char *)((unint64_t)__dst | v5) = 0;
  if ((v16 & 0x80u) == 0) {
    double v6 = __dst;
  }
  else {
    double v6 = (void **)__dst[0];
  }
  if ((v16 & 0x80u) == 0) {
    uint64_t v7 = v16;
  }
  else {
    uint64_t v7 = (uint64_t)__dst[1];
  }
  float64x2_t v8 = sub_2153C1168(a2, (uint64_t)v6, v7);
  long long v9 = sub_2153C1168(v8, (uint64_t)"[", 1);
  char v14 = 19;
  strcpy(__p, "Extrinsics Rotation");
  float64x2_t v10 = sub_2153C1168(v9, (uint64_t)__p, 19);
  sub_2153C1168(v10, (uint64_t)"] : ", 4);
  __n128 v17 = 0uLL;
  double v18 = 0.0;
  sub_2153CAD38(v3, v17.n128_f64);
  long long v11 = sub_2153FD54C(a2, v17, v18);
  sub_2153C1168(v11, (uint64_t)"\n", 1);
  if (v14 < 0)
  {
    operator delete(*(void **)__p);
    if (((char)v16 & 0x80000000) == 0) {
      return a2;
    }
LABEL_17:
    operator delete(__dst[0]);
    return a2;
  }
  if ((char)v16 < 0) {
    goto LABEL_17;
  }
  return a2;
}

uint64_t *sub_2153FC018(long long *a1, uint64_t *a2)
{
  if (*((unsigned char *)a1 + 24)) {
    std::string::size_type v4 = "[FREE]";
  }
  else {
    std::string::size_type v4 = "[FIXED]";
  }
  if (*((unsigned char *)a1 + 24)) {
    size_t v5 = 6;
  }
  else {
    size_t v5 = 7;
  }
  unsigned __int8 v95 = v5;
  memcpy(__dst, v4, v5);
  *(unsigned char *)((unint64_t)__dst | v5) = 0;
  if ((v95 & 0x80u) == 0) {
    double v6 = __dst;
  }
  else {
    double v6 = (void **)__dst[0];
  }
  if ((v95 & 0x80u) == 0) {
    uint64_t v7 = v95;
  }
  else {
    uint64_t v7 = (uint64_t)__dst[1];
  }
  float64x2_t v8 = sub_2153C1168(a2, (uint64_t)v6, v7);
  long long v9 = sub_2153C1168(v8, (uint64_t)"[", 1);
  strcpy((char *)v93, "Extrinsics Translation");
  HIBYTE(v93[2]) = 22;
  float64x2_t v10 = sub_2153C1168(v9, (uint64_t)v93, 22);
  sub_2153C1168(v10, (uint64_t)"] : ", 4);
  long long v102 = *a1;
  uint64_t v103 = *((void *)a1 + 2);
  long long v11 = (char *)a2 + *(void *)(*a2 - 24);
  int v12 = *((_DWORD *)v11 + 2);
  size_t v14 = *((void *)v11 + 2);
  int64_t v13 = *((void *)v11 + 3);
  if (v13)
  {
    if (v13 <= (uint64_t)(v14 + 2)) {
      int64_t v13 = v14 + 2;
    }
    size_t v15 = v13 + ~v14;
    double v16 = __exp10((double)-(uint64_t)v14);
    size_t v17 = v15 - 1;
    if (v15 - 1 > 0x7FFFFFFFFFFFFFF7) {
LABEL_149:
    }
      abort();
    double v18 = v16;
    if (v17 >= 0x17)
    {
      uint64_t v20 = (v17 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v17 | 7) != 0x17) {
        uint64_t v20 = v17 | 7;
      }
      uint64_t v21 = v20 + 1;
      p_b = (std::string *)operator new(v20 + 1);
      __b.__r_.__value_.__l.__size_ = v15 - 1;
      __b.__r_.__value_.__r.__words[2] = v21 | 0x8000000000000000;
      __b.__r_.__value_.__r.__words[0] = (std::string::size_type)p_b;
    }
    else
    {
      *((unsigned char *)&__b.__r_.__value_.__s + 23) = v15 - 1;
      p_b = &__b;
      if (v15 == 1)
      {
        LODWORD(v15) = 1;
        goto LABEL_25;
      }
    }
  }
  else
  {
    double v18 = __exp10((double)-(uint64_t)v14);
    size_t v17 = 3;
    *((unsigned char *)&__b.__r_.__value_.__s + 23) = 3;
    p_b = &__b;
    LODWORD(v15) = 4;
  }
  memset(p_b, 32, v17);
LABEL_25:
  p_b->__r_.__value_.__s.__data_[v17] = 0;
  size_t v22 = std::string::append(&__b, "0 ");
  std::string::size_type v23 = v22->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v104.__r_.__value_.__l.__data_ = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
  v104.__r_.__value_.__r.__words[2] = v23;
  v22->__r_.__value_.__l.__size_ = 0;
  v22->__r_.__value_.__r.__words[2] = 0;
  v22->__r_.__value_.__r.__words[0] = 0;
  if (v14 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_149;
  }
  if (v14 >= 0x17)
  {
    uint64_t v25 = (v14 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v14 | 7) != 0x17) {
      uint64_t v25 = v14 | 7;
    }
    uint64_t v26 = v25 + 1;
    uint64_t v24 = operator new(v25 + 1);
    std::string::size_type v97 = v14;
    int64_t v98 = v26 | 0x8000000000000000;
    std::string v96 = v24;
    goto LABEL_32;
  }
  HIBYTE(v98) = v14;
  uint64_t v24 = &v96;
  if (v14) {
LABEL_32:
  }
    memset(v24, 32, v14);
  *((unsigned char *)v24 + v14) = 0;
  if (v98 >= 0) {
    char v27 = (const std::string::value_type *)&v96;
  }
  else {
    char v27 = (const std::string::value_type *)v96;
  }
  if (v98 >= 0) {
    std::string::size_type v28 = HIBYTE(v98);
  }
  else {
    std::string::size_type v28 = v97;
  }
  char v29 = std::string::append(&v104, v27, v28);
  std::string::size_type v30 = v29->__r_.__value_.__r.__words[2];
  *(_OWORD *)long long __p = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
  uint64_t v101 = v30;
  v29->__r_.__value_.__l.__size_ = 0;
  v29->__r_.__value_.__r.__words[2] = 0;
  v29->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v98) < 0)
  {
    operator delete(v96);
    if ((SHIBYTE(v104.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_41;
    }
LABEL_146:
    operator delete(v104.__r_.__value_.__l.__data_);
    goto LABEL_41;
  }
  if (SHIBYTE(v104.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_146;
  }
LABEL_41:
  int v87 = v12;
  if (SHIBYTE(__b.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__b.__r_.__value_.__l.__data_);
  }
  long long v91 = a2 + 1;
  *(uint64_t *)((char *)a2 + *(void *)(*a2 - 24) + 24) = 0;
  v104.__r_.__value_.__s.__data_[0] = 91;
  sub_2153C1168(a2, (uint64_t)&v104, 1);
  uint64_t v31 = 0;
  uint64_t v92 = (int)v15 + (int)v14 + 1;
  uint64_t v89 = (int)v14;
  uint64_t v90 = (int)v14 - 3;
  while (1)
  {
    double v32 = *(double *)((char *)&v102 + v31);
    uint64_t v33 = *a2;
    std::string::size_type v34 = (char *)a2 + *(void *)(*a2 - 24);
    if (v34[9]) {
      break;
    }
    if (fabs(v32) < v18)
    {
      char v35 = (char *)HIBYTE(v101);
      char v36 = (char *)__p[1];
      if (v101 >= 0) {
        char v37 = __p;
      }
      else {
        char v37 = (void **)__p[0];
      }
      MEMORY[0x2166B95F0](&__b, a2);
      if (__b.__r_.__value_.__s.__data_[0])
      {
        if ((char)v35 >= 0) {
          char v38 = v35;
        }
        else {
          char v38 = v36;
        }
        char v39 = (char *)a2 + *(void *)(*a2 - 24);
        uint64_t v40 = *((void *)v39 + 5);
        char v41 = &v38[(void)v37];
        if ((*((_DWORD *)v39 + 2) & 0xB0) == 0x20) {
          char v42 = (void **)&v38[(void)v37];
        }
        else {
          char v42 = v37;
        }
        int v43 = *((_DWORD *)v39 + 36);
        if (v43 == -1)
        {
          int64_t v51 = v42;
          std::ios_base::getloc((const std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)));
          std::string::size_type v52 = std::locale::use_facet((const std::locale *)&v104, MEMORY[0x263F8C108]);
          int v43 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v52->__vftable[2].~facet_0)(v52, 32);
          std::locale::~locale((std::locale *)&v104);
          char v42 = v51;
          *((_DWORD *)v39 + 36) = v43;
          if (!v40) {
            goto LABEL_108;
          }
        }
        else if (!v40)
        {
          goto LABEL_108;
        }
        uint64_t v53 = *((void *)v39 + 3);
        BOOL v54 = v53 <= (uint64_t)v38;
        std::string::size_type v55 = v53 - (void)v38;
        if (v54) {
          std::string::size_type v56 = 0;
        }
        else {
          std::string::size_type v56 = v55;
        }
        int64_t v57 = (char *)v42 - (char *)v37;
        if ((char *)v42 - (char *)v37 >= 1)
        {
          char v58 = v42;
          uint64_t v59 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v40 + 96))(v40, v37, v57);
          char v42 = v58;
          if (v59 != v57) {
            goto LABEL_108;
          }
        }
        goto LABEL_92;
      }
      goto LABEL_109;
    }
    *((void *)v34 + 3) = v92;
    *(_DWORD *)((char *)v91 + *(void *)(v33 - 24)) = *(_DWORD *)((unsigned char *)v91 + *(void *)(v33 - 24)) & 0xFFFFFEFB | 4;
    *(_DWORD *)((char *)v91 + *(void *)(v33 - 24)) |= 0x400u;
    uint64_t v44 = *(void *)(v33 - 24);
    uint64_t v45 = a2 + 2;
    uint64_t v46 = v89;
LABEL_64:
    *(void *)((char *)v45 + v44) = v46;
    std::ostream::operator<<();
    if (v31 == 16) {
      goto LABEL_140;
    }
LABEL_110:
    LOBYTE(v96) = 44;
    MEMORY[0x2166B95F0](&__b, a2);
    if (__b.__r_.__value_.__s.__data_[0])
    {
      long long v72 = (char *)a2 + *(void *)(*a2 - 24);
      uint64_t v73 = *((void *)v72 + 5);
      if ((*((_DWORD *)v72 + 2) & 0xB0) == 0x20) {
        uint64_t v74 = (void **)((char *)&v96 + 1);
      }
      else {
        uint64_t v74 = &v96;
      }
      int v75 = *((_DWORD *)v72 + 36);
      if (v75 == -1)
      {
        std::ios_base::getloc((const std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)));
        uint64_t v76 = std::locale::use_facet((const std::locale *)&v104, MEMORY[0x263F8C108]);
        int v75 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v76->__vftable[2].~facet_0)(v76, 32);
        std::locale::~locale((std::locale *)&v104);
        *((_DWORD *)v72 + 36) = v75;
        if (!v73) {
          goto LABEL_44;
        }
      }
      else if (!v73)
      {
        goto LABEL_44;
      }
      uint64_t v77 = *((void *)v72 + 3);
      BOOL v54 = v77 <= 1;
      std::string::size_type v78 = v77 - 1;
      if (v54) {
        std::string::size_type v79 = 0;
      }
      else {
        std::string::size_type v79 = v78;
      }
      if ((char *)v74 - (char *)&v96 >= 1
        && (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v73 + 96))(v73, &v96, (char *)v74 - (char *)&v96) != (char *)v74 - (char *)&v96)
      {
        goto LABEL_44;
      }
      if ((uint64_t)v79 >= 1)
      {
        if (v79 > 0x7FFFFFFFFFFFFFF7) {
          goto LABEL_149;
        }
        if (v79 >= 0x17)
        {
          uint64_t v81 = (v79 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v79 | 7) != 0x17) {
            uint64_t v81 = v79 | 7;
          }
          uint64_t v82 = v81 + 1;
          uint64_t v80 = operator new(v81 + 1);
          v104.__r_.__value_.__l.__size_ = v79;
          v104.__r_.__value_.__r.__words[2] = v82 | 0x8000000000000000;
          v104.__r_.__value_.__r.__words[0] = (std::string::size_type)v80;
        }
        else
        {
          *((unsigned char *)&v104.__r_.__value_.__s + 23) = v79;
          uint64_t v80 = &v104;
        }
        memset(v80, v75, v79);
        *((unsigned char *)v80 + v79) = 0;
        if ((v104.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v83 = &v104;
        }
        else {
          uint64_t v83 = (std::string *)v104.__r_.__value_.__r.__words[0];
        }
        uint64_t v84 = (*(uint64_t (**)(uint64_t, std::string *, std::string::size_type))(*(void *)v73 + 96))(v73, v83, v79);
        uint64_t v85 = v84;
        if (SHIBYTE(v104.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v104.__r_.__value_.__l.__data_);
          if (v85 != v79) {
            goto LABEL_44;
          }
        }
        else if (v84 != v79)
        {
          goto LABEL_44;
        }
      }
      if ((char *)&v96 + 1 - (char *)v74 >= 1
        && (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v73 + 96))(v73, v74, (char *)&v96 + 1 - (char *)v74) != (char *)&v96 + 1 - (char *)v74)
      {
LABEL_44:
        std::ios_base::clear((std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)), *(_DWORD *)((char *)a2 + *(void *)(*a2 - 24) + 32) | 5);
        goto LABEL_45;
      }
      *((void *)v72 + 3) = 0;
    }
LABEL_45:
    MEMORY[0x2166B9600](&__b);
    v31 += 8;
  }
  if (v32 != 0.0)
  {
    *((void *)v34 + 3) = v92;
    *(_DWORD *)((char *)v91 + *(void *)(v33 - 24)) |= 0x400u;
    uint64_t v44 = *(void *)(v33 - 24);
    uint64_t v45 = a2 + 2;
    uint64_t v46 = v90;
    goto LABEL_64;
  }
  int v47 = (char *)HIBYTE(v101);
  int v48 = (char *)__p[1];
  if (v101 >= 0) {
    int v49 = __p;
  }
  else {
    int v49 = (void **)__p[0];
  }
  MEMORY[0x2166B95F0](&__b, a2);
  if (__b.__r_.__value_.__s.__data_[0])
  {
    if ((char)v47 >= 0) {
      char v50 = v47;
    }
    else {
      char v50 = v48;
    }
    char v39 = (char *)a2 + *(void *)(*a2 - 24);
    uint64_t v40 = *((void *)v39 + 5);
    char v41 = &v50[(void)v49];
    if ((*((_DWORD *)v39 + 2) & 0xB0) == 0x20) {
      char v42 = (void **)&v50[(void)v49];
    }
    else {
      char v42 = v49;
    }
    int v43 = *((_DWORD *)v39 + 36);
    if (v43 != -1)
    {
      if (!v40) {
        goto LABEL_108;
      }
LABEL_87:
      uint64_t v62 = *((void *)v39 + 3);
      BOOL v54 = v62 <= (uint64_t)v50;
      std::string::size_type v63 = v62 - (void)v50;
      if (v54) {
        std::string::size_type v56 = 0;
      }
      else {
        std::string::size_type v56 = v63;
      }
      int64_t v64 = (char *)v42 - (char *)v49;
      if ((char *)v42 - (char *)v49 >= 1)
      {
        uint64_t v65 = v42;
        uint64_t v66 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v40 + 96))(v40, v49, v64);
        char v42 = v65;
        if (v66 != v64) {
          goto LABEL_108;
        }
      }
LABEL_92:
      if ((uint64_t)v56 < 1) {
        goto LABEL_106;
      }
      if (v56 > 0x7FFFFFFFFFFFFFF7) {
        goto LABEL_149;
      }
      uint64_t v88 = v42;
      if (v56 >= 0x17)
      {
        uint64_t v68 = (v56 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v56 | 7) != 0x17) {
          uint64_t v68 = v56 | 7;
        }
        uint64_t v69 = v68 + 1;
        uint64_t v67 = operator new(v68 + 1);
        v104.__r_.__value_.__l.__size_ = v56;
        v104.__r_.__value_.__r.__words[2] = v69 | 0x8000000000000000;
        v104.__r_.__value_.__r.__words[0] = (std::string::size_type)v67;
      }
      else
      {
        *((unsigned char *)&v104.__r_.__value_.__s + 23) = v56;
        uint64_t v67 = &v104;
      }
      memset(v67, v43, v56);
      *((unsigned char *)v67 + v56) = 0;
      if ((v104.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        char v70 = &v104;
      }
      else {
        char v70 = (std::string *)v104.__r_.__value_.__r.__words[0];
      }
      uint64_t v71 = (*(uint64_t (**)(uint64_t, std::string *, std::string::size_type))(*(void *)v40 + 96))(v40, v70, v56);
      if (SHIBYTE(v104.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v104.__r_.__value_.__l.__data_);
      }
      char v42 = v88;
      if (v71 == v56)
      {
LABEL_106:
        if (v41 - (char *)v42 < 1
          || (*(uint64_t (**)(uint64_t))(*(void *)v40 + 96))(v40) == v41 - (char *)v42)
        {
          *((void *)v39 + 3) = 0;
          goto LABEL_109;
        }
      }
      goto LABEL_108;
    }
    char v60 = v42;
    std::ios_base::getloc((const std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)));
    std::string::size_type v61 = std::locale::use_facet((const std::locale *)&v104, MEMORY[0x263F8C108]);
    int v43 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v61->__vftable[2].~facet_0)(v61, 32);
    std::locale::~locale((std::locale *)&v104);
    char v42 = v60;
    *((_DWORD *)v39 + 36) = v43;
    if (v40) {
      goto LABEL_87;
    }
LABEL_108:
    std::ios_base::clear((std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)), *(_DWORD *)((char *)a2 + *(void *)(*a2 - 24) + 32) | 5);
  }
LABEL_109:
  MEMORY[0x2166B9600](&__b);
  if (v31 != 16) {
    goto LABEL_110;
  }
LABEL_140:
  sub_2153C1168(a2, (uint64_t)"   ]", 4);
  *(_DWORD *)((char *)a2 + *(void *)(*a2 - 24) + 8) = v87;
  if (SHIBYTE(v101) < 0) {
    operator delete(__p[0]);
  }
  sub_2153C1168(a2, (uint64_t)"\n", 1);
  if (SHIBYTE(v93[2]) < 0)
  {
    operator delete(v93[0]);
    if (((char)v95 & 0x80000000) == 0) {
      return a2;
    }
LABEL_148:
    operator delete(__dst[0]);
    return a2;
  }
  if ((char)v95 < 0) {
    goto LABEL_148;
  }
  return a2;
}

uint64_t *sub_2153FCB30(uint64_t *a1, __n128 a2)
{
  __n128 v92 = a2;
  unint64_t v3 = (char *)a1 + *(void *)(*a1 - 24);
  int v4 = *((_DWORD *)v3 + 2);
  size_t v6 = *((void *)v3 + 2);
  int64_t v5 = *((void *)v3 + 3);
  if (v5)
  {
    if (v5 <= (uint64_t)(v6 + 2)) {
      int64_t v5 = v6 + 2;
    }
    size_t v7 = v5 + ~v6;
    double v8 = __exp10((double)-(uint64_t)v6);
    size_t v9 = v7 - 1;
    if (v7 - 1 > 0x7FFFFFFFFFFFFFF7) {
LABEL_133:
    }
      abort();
    double v10 = v8;
    if (v9 >= 0x17)
    {
      uint64_t v12 = (v9 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v9 | 7) != 0x17) {
        uint64_t v12 = v9 | 7;
      }
      uint64_t v13 = v12 + 1;
      p_b = (std::string *)operator new(v12 + 1);
      __b.__r_.__value_.__l.__size_ = v7 - 1;
      __b.__r_.__value_.__r.__words[2] = v13 | 0x8000000000000000;
      __b.__r_.__value_.__r.__words[0] = (std::string::size_type)p_b;
    }
    else
    {
      *((unsigned char *)&__b.__r_.__value_.__s + 23) = v7 - 1;
      p_b = &__b;
      if (v7 == 1)
      {
        LODWORD(v7) = 1;
        goto LABEL_13;
      }
    }
  }
  else
  {
    double v10 = __exp10((double)-(uint64_t)v6);
    size_t v9 = 3;
    *((unsigned char *)&__b.__r_.__value_.__s + 23) = 3;
    p_b = &__b;
    LODWORD(v7) = 4;
  }
  memset(p_b, 32, v9);
LABEL_13:
  p_b->__r_.__value_.__s.__data_[v9] = 0;
  size_t v14 = std::string::append(&__b, "0 ");
  std::string::size_type v15 = v14->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v93.__r_.__value_.__l.__data_ = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  v93.__r_.__value_.__r.__words[2] = v15;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  if (v6 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_133;
  }
  if (v6 >= 0x17)
  {
    uint64_t v17 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17) {
      uint64_t v17 = v6 | 7;
    }
    uint64_t v18 = v17 + 1;
    double v16 = operator new(v17 + 1);
    std::string::size_type v87 = v6;
    int64_t v88 = v18 | 0x8000000000000000;
    uint64_t v86 = v16;
    goto LABEL_20;
  }
  HIBYTE(v88) = v6;
  double v16 = &v86;
  if (v6) {
LABEL_20:
  }
    memset(v16, 32, v6);
  *((unsigned char *)v16 + v6) = 0;
  if (v88 >= 0) {
    long long v19 = (const std::string::value_type *)&v86;
  }
  else {
    long long v19 = (const std::string::value_type *)v86;
  }
  if (v88 >= 0) {
    std::string::size_type v20 = HIBYTE(v88);
  }
  else {
    std::string::size_type v20 = v87;
  }
  uint64_t v21 = std::string::append(&v93, v19, v20);
  std::string::size_type v22 = v21->__r_.__value_.__r.__words[2];
  *(_OWORD *)long long __p = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
  uint64_t v91 = v22;
  v21->__r_.__value_.__l.__size_ = 0;
  v21->__r_.__value_.__r.__words[2] = 0;
  v21->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v88) < 0)
  {
    operator delete(v86);
    if ((SHIBYTE(v93.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_29;
    }
LABEL_132:
    operator delete(v93.__r_.__value_.__l.__data_);
    goto LABEL_29;
  }
  if (SHIBYTE(v93.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_132;
  }
LABEL_29:
  int v80 = v4;
  if (SHIBYTE(__b.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__b.__r_.__value_.__l.__data_);
  }
  uint64_t v84 = a1 + 1;
  *(uint64_t *)((char *)a1 + *(void *)(*a1 - 24) + 24) = 0;
  v93.__r_.__value_.__s.__data_[0] = 91;
  sub_2153C1168(a1, (uint64_t)&v93, 1);
  char v23 = 0;
  uint64_t v24 = 0;
  uint64_t v85 = (int)v7 + (int)v6 + 1;
  uint64_t v82 = (int)v6;
  uint64_t v83 = (int)v6 - 3;
  while (1)
  {
    double v25 = v92.n128_f64[v24];
    uint64_t v26 = *a1;
    char v27 = (char *)a1 + *(void *)(*a1 - 24);
    if (v27[9]) {
      break;
    }
    if (fabs(v25) < v10)
    {
      std::string::size_type v28 = (char *)HIBYTE(v91);
      char v29 = (char *)__p[1];
      if (v91 >= 0) {
        std::string::size_type v30 = __p;
      }
      else {
        std::string::size_type v30 = (void **)__p[0];
      }
      MEMORY[0x2166B95F0](&__b, a1);
      if (__b.__r_.__value_.__s.__data_[0])
      {
        if ((char)v28 >= 0) {
          uint64_t v31 = v28;
        }
        else {
          uint64_t v31 = v29;
        }
        double v32 = (char *)a1 + *(void *)(*a1 - 24);
        uint64_t v33 = *((void *)v32 + 5);
        std::string::size_type v34 = &v31[(void)v30];
        if ((*((_DWORD *)v32 + 2) & 0xB0) == 0x20) {
          char v35 = (void **)&v31[(void)v30];
        }
        else {
          char v35 = v30;
        }
        int v36 = *((_DWORD *)v32 + 36);
        if (v36 == -1)
        {
          uint64_t v44 = v35;
          std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
          uint64_t v45 = std::locale::use_facet((const std::locale *)&v93, MEMORY[0x263F8C108]);
          int v36 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v45->__vftable[2].~facet_0)(v45, 32);
          std::locale::~locale((std::locale *)&v93);
          char v35 = v44;
          *((_DWORD *)v32 + 36) = v36;
          if (!v33) {
            goto LABEL_96;
          }
        }
        else if (!v33)
        {
          goto LABEL_96;
        }
        uint64_t v46 = *((void *)v32 + 3);
        BOOL v47 = v46 <= (uint64_t)v31;
        std::string::size_type v48 = v46 - (void)v31;
        if (v47) {
          std::string::size_type v49 = 0;
        }
        else {
          std::string::size_type v49 = v48;
        }
        int64_t v50 = (char *)v35 - (char *)v30;
        if ((char *)v35 - (char *)v30 >= 1)
        {
          int64_t v51 = v35;
          uint64_t v52 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v33 + 96))(v33, v30, v50);
          char v35 = v51;
          if (v52 != v50) {
            goto LABEL_96;
          }
        }
        goto LABEL_80;
      }
      goto LABEL_97;
    }
    *((void *)v27 + 3) = v85;
    *(_DWORD *)((char *)v84 + *(void *)(v26 - 24)) = *(_DWORD *)((unsigned char *)v84 + *(void *)(v26 - 24)) & 0xFFFFFEFB | 4;
    *(_DWORD *)((char *)v84 + *(void *)(v26 - 24)) |= 0x400u;
    uint64_t v37 = *(void *)(v26 - 24);
    char v38 = a1 + 2;
    uint64_t v39 = v82;
LABEL_52:
    *(void *)((char *)v38 + v37) = v39;
    std::ostream::operator<<();
    if (v23) {
      goto LABEL_128;
    }
LABEL_98:
    LOBYTE(v86) = 44;
    MEMORY[0x2166B95F0](&__b, a1);
    if (__b.__r_.__value_.__s.__data_[0])
    {
      uint64_t v65 = (char *)a1 + *(void *)(*a1 - 24);
      uint64_t v66 = *((void *)v65 + 5);
      if ((*((_DWORD *)v65 + 2) & 0xB0) == 0x20) {
        uint64_t v67 = (void **)((char *)&v86 + 1);
      }
      else {
        uint64_t v67 = &v86;
      }
      int v68 = *((_DWORD *)v65 + 36);
      if (v68 == -1)
      {
        std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
        uint64_t v69 = std::locale::use_facet((const std::locale *)&v93, MEMORY[0x263F8C108]);
        int v68 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v69->__vftable[2].~facet_0)(v69, 32);
        std::locale::~locale((std::locale *)&v93);
        *((_DWORD *)v65 + 36) = v68;
        if (!v66) {
          goto LABEL_32;
        }
      }
      else if (!v66)
      {
        goto LABEL_32;
      }
      uint64_t v70 = *((void *)v65 + 3);
      BOOL v47 = v70 <= 1;
      std::string::size_type v71 = v70 - 1;
      if (v47) {
        std::string::size_type v72 = 0;
      }
      else {
        std::string::size_type v72 = v71;
      }
      if ((char *)v67 - (char *)&v86 >= 1
        && (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v66 + 96))(v66, &v86, (char *)v67 - (char *)&v86) != (char *)v67 - (char *)&v86)
      {
        goto LABEL_32;
      }
      if ((uint64_t)v72 >= 1)
      {
        if (v72 > 0x7FFFFFFFFFFFFFF7) {
          goto LABEL_133;
        }
        if (v72 >= 0x17)
        {
          uint64_t v74 = (v72 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v72 | 7) != 0x17) {
            uint64_t v74 = v72 | 7;
          }
          uint64_t v75 = v74 + 1;
          uint64_t v73 = operator new(v74 + 1);
          v93.__r_.__value_.__l.__size_ = v72;
          v93.__r_.__value_.__r.__words[2] = v75 | 0x8000000000000000;
          v93.__r_.__value_.__r.__words[0] = (std::string::size_type)v73;
        }
        else
        {
          *((unsigned char *)&v93.__r_.__value_.__s + 23) = v72;
          uint64_t v73 = &v93;
        }
        memset(v73, v68, v72);
        *((unsigned char *)v73 + v72) = 0;
        if ((v93.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v76 = &v93;
        }
        else {
          uint64_t v76 = (std::string *)v93.__r_.__value_.__r.__words[0];
        }
        uint64_t v77 = (*(uint64_t (**)(uint64_t, std::string *, std::string::size_type))(*(void *)v66 + 96))(v66, v76, v72);
        uint64_t v78 = v77;
        if (SHIBYTE(v93.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v93.__r_.__value_.__l.__data_);
          if (v78 != v72) {
            goto LABEL_32;
          }
        }
        else if (v77 != v72)
        {
          goto LABEL_32;
        }
      }
      if ((char *)&v86 + 1 - (char *)v67 >= 1
        && (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v66 + 96))(v66, v67, (char *)&v86 + 1 - (char *)v67) != (char *)&v86 + 1 - (char *)v67)
      {
LABEL_32:
        std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
        goto LABEL_33;
      }
      *((void *)v65 + 3) = 0;
    }
LABEL_33:
    MEMORY[0x2166B9600](&__b);
    char v23 = 1;
    uint64_t v24 = 1;
  }
  if (v25 != 0.0)
  {
    *((void *)v27 + 3) = v85;
    *(_DWORD *)((char *)v84 + *(void *)(v26 - 24)) |= 0x400u;
    uint64_t v37 = *(void *)(v26 - 24);
    char v38 = a1 + 2;
    uint64_t v39 = v83;
    goto LABEL_52;
  }
  uint64_t v40 = (char *)HIBYTE(v91);
  char v41 = (char *)__p[1];
  if (v91 >= 0) {
    char v42 = __p;
  }
  else {
    char v42 = (void **)__p[0];
  }
  MEMORY[0x2166B95F0](&__b, a1);
  if (__b.__r_.__value_.__s.__data_[0])
  {
    if ((char)v40 >= 0) {
      int v43 = v40;
    }
    else {
      int v43 = v41;
    }
    double v32 = (char *)a1 + *(void *)(*a1 - 24);
    uint64_t v33 = *((void *)v32 + 5);
    std::string::size_type v34 = &v43[(void)v42];
    if ((*((_DWORD *)v32 + 2) & 0xB0) == 0x20) {
      char v35 = (void **)&v43[(void)v42];
    }
    else {
      char v35 = v42;
    }
    int v36 = *((_DWORD *)v32 + 36);
    if (v36 != -1)
    {
      if (!v33) {
        goto LABEL_96;
      }
LABEL_75:
      uint64_t v55 = *((void *)v32 + 3);
      BOOL v47 = v55 <= (uint64_t)v43;
      std::string::size_type v56 = v55 - (void)v43;
      if (v47) {
        std::string::size_type v49 = 0;
      }
      else {
        std::string::size_type v49 = v56;
      }
      int64_t v57 = (char *)v35 - (char *)v42;
      if ((char *)v35 - (char *)v42 >= 1)
      {
        char v58 = v35;
        uint64_t v59 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v33 + 96))(v33, v42, v57);
        char v35 = v58;
        if (v59 != v57) {
          goto LABEL_96;
        }
      }
LABEL_80:
      if ((uint64_t)v49 < 1) {
        goto LABEL_94;
      }
      if (v49 > 0x7FFFFFFFFFFFFFF7) {
        goto LABEL_133;
      }
      uint64_t v81 = v35;
      if (v49 >= 0x17)
      {
        uint64_t v61 = (v49 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v49 | 7) != 0x17) {
          uint64_t v61 = v49 | 7;
        }
        uint64_t v62 = v61 + 1;
        char v60 = operator new(v61 + 1);
        v93.__r_.__value_.__l.__size_ = v49;
        v93.__r_.__value_.__r.__words[2] = v62 | 0x8000000000000000;
        v93.__r_.__value_.__r.__words[0] = (std::string::size_type)v60;
      }
      else
      {
        *((unsigned char *)&v93.__r_.__value_.__s + 23) = v49;
        char v60 = &v93;
      }
      memset(v60, v36, v49);
      *((unsigned char *)v60 + v49) = 0;
      if ((v93.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v63 = &v93;
      }
      else {
        std::string::size_type v63 = (std::string *)v93.__r_.__value_.__r.__words[0];
      }
      uint64_t v64 = (*(uint64_t (**)(uint64_t, std::string *, std::string::size_type))(*(void *)v33 + 96))(v33, v63, v49);
      if (SHIBYTE(v93.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v93.__r_.__value_.__l.__data_);
      }
      char v35 = v81;
      if (v64 == v49)
      {
LABEL_94:
        if (v34 - (char *)v35 < 1
          || (*(uint64_t (**)(uint64_t))(*(void *)v33 + 96))(v33) == v34 - (char *)v35)
        {
          *((void *)v32 + 3) = 0;
          goto LABEL_97;
        }
      }
      goto LABEL_96;
    }
    uint64_t v53 = v35;
    std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
    BOOL v54 = std::locale::use_facet((const std::locale *)&v93, MEMORY[0x263F8C108]);
    int v36 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v54->__vftable[2].~facet_0)(v54, 32);
    std::locale::~locale((std::locale *)&v93);
    char v35 = v53;
    *((_DWORD *)v32 + 36) = v36;
    if (v33) {
      goto LABEL_75;
    }
LABEL_96:
    std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
  }
LABEL_97:
  MEMORY[0x2166B9600](&__b);
  if ((v23 & 1) == 0) {
    goto LABEL_98;
  }
LABEL_128:
  sub_2153C1168(a1, (uint64_t)"   ]", 4);
  *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 8) = v80;
  if (SHIBYTE(v91) < 0) {
    operator delete(__p[0]);
  }
  return a1;
}

uint64_t *sub_2153FD54C(uint64_t *a1, __n128 a2, double a3)
{
  __n128 v92 = a2;
  double v93 = a3;
  int v4 = (char *)a1 + *(void *)(*a1 - 24);
  int v5 = *((_DWORD *)v4 + 2);
  size_t v7 = *((void *)v4 + 2);
  int64_t v6 = *((void *)v4 + 3);
  if (v6)
  {
    if (v6 <= (uint64_t)(v7 + 2)) {
      int64_t v6 = v7 + 2;
    }
    size_t v8 = v6 + ~v7;
    double v9 = __exp10((double)-(uint64_t)v7);
    size_t v10 = v8 - 1;
    if (v8 - 1 > 0x7FFFFFFFFFFFFFF7) {
LABEL_133:
    }
      abort();
    double v11 = v9;
    if (v10 >= 0x17)
    {
      uint64_t v13 = (v10 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v10 | 7) != 0x17) {
        uint64_t v13 = v10 | 7;
      }
      uint64_t v14 = v13 + 1;
      p_b = (std::string *)operator new(v13 + 1);
      __b.__r_.__value_.__l.__size_ = v8 - 1;
      __b.__r_.__value_.__r.__words[2] = v14 | 0x8000000000000000;
      __b.__r_.__value_.__r.__words[0] = (std::string::size_type)p_b;
    }
    else
    {
      *((unsigned char *)&__b.__r_.__value_.__s + 23) = v8 - 1;
      p_b = &__b;
      if (v8 == 1)
      {
        LODWORD(v8) = 1;
        goto LABEL_13;
      }
    }
  }
  else
  {
    double v11 = __exp10((double)-(uint64_t)v7);
    size_t v10 = 3;
    *((unsigned char *)&__b.__r_.__value_.__s + 23) = 3;
    p_b = &__b;
    LODWORD(v8) = 4;
  }
  memset(p_b, 32, v10);
LABEL_13:
  p_b->__r_.__value_.__s.__data_[v10] = 0;
  std::string::size_type v15 = std::string::append(&__b, "0 ");
  std::string::size_type v16 = v15->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v94.__r_.__value_.__l.__data_ = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  v94.__r_.__value_.__r.__words[2] = v16;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  if (v7 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_133;
  }
  if (v7 >= 0x17)
  {
    uint64_t v18 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17) {
      uint64_t v18 = v7 | 7;
    }
    uint64_t v19 = v18 + 1;
    uint64_t v17 = operator new(v18 + 1);
    std::string::size_type v87 = v7;
    int64_t v88 = v19 | 0x8000000000000000;
    uint64_t v86 = v17;
    goto LABEL_20;
  }
  HIBYTE(v88) = v7;
  uint64_t v17 = &v86;
  if (v7) {
LABEL_20:
  }
    memset(v17, 32, v7);
  *((unsigned char *)v17 + v7) = 0;
  if (v88 >= 0) {
    std::string::size_type v20 = (const std::string::value_type *)&v86;
  }
  else {
    std::string::size_type v20 = (const std::string::value_type *)v86;
  }
  if (v88 >= 0) {
    std::string::size_type v21 = HIBYTE(v88);
  }
  else {
    std::string::size_type v21 = v87;
  }
  std::string::size_type v22 = std::string::append(&v94, v20, v21);
  std::string::size_type v23 = v22->__r_.__value_.__r.__words[2];
  *(_OWORD *)long long __p = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
  uint64_t v91 = v23;
  v22->__r_.__value_.__l.__size_ = 0;
  v22->__r_.__value_.__r.__words[2] = 0;
  v22->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v88) < 0)
  {
    operator delete(v86);
    if ((SHIBYTE(v94.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_29;
    }
LABEL_132:
    operator delete(v94.__r_.__value_.__l.__data_);
    goto LABEL_29;
  }
  if (SHIBYTE(v94.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_132;
  }
LABEL_29:
  int v80 = v5;
  if (SHIBYTE(__b.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__b.__r_.__value_.__l.__data_);
  }
  uint64_t v84 = a1 + 1;
  *(uint64_t *)((char *)a1 + *(void *)(*a1 - 24) + 24) = 0;
  v94.__r_.__value_.__s.__data_[0] = 91;
  sub_2153C1168(a1, (uint64_t)&v94, 1);
  uint64_t v24 = 0;
  uint64_t v85 = (int)v8 + (int)v7 + 1;
  uint64_t v82 = (int)v7;
  uint64_t v83 = (int)v7 - 3;
  while (1)
  {
    double v25 = v92.n128_f64[v24];
    uint64_t v26 = *a1;
    char v27 = (char *)a1 + *(void *)(*a1 - 24);
    if (v27[9]) {
      break;
    }
    if (fabs(v25) < v11)
    {
      std::string::size_type v28 = (char *)HIBYTE(v91);
      char v29 = (char *)__p[1];
      if (v91 >= 0) {
        std::string::size_type v30 = __p;
      }
      else {
        std::string::size_type v30 = (void **)__p[0];
      }
      MEMORY[0x2166B95F0](&__b, a1);
      if (__b.__r_.__value_.__s.__data_[0])
      {
        if ((char)v28 >= 0) {
          uint64_t v31 = v28;
        }
        else {
          uint64_t v31 = v29;
        }
        double v32 = (char *)a1 + *(void *)(*a1 - 24);
        uint64_t v33 = *((void *)v32 + 5);
        std::string::size_type v34 = &v31[(void)v30];
        if ((*((_DWORD *)v32 + 2) & 0xB0) == 0x20) {
          char v35 = (void **)&v31[(void)v30];
        }
        else {
          char v35 = v30;
        }
        int v36 = *((_DWORD *)v32 + 36);
        if (v36 == -1)
        {
          uint64_t v44 = v35;
          std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
          uint64_t v45 = std::locale::use_facet((const std::locale *)&v94, MEMORY[0x263F8C108]);
          int v36 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v45->__vftable[2].~facet_0)(v45, 32);
          std::locale::~locale((std::locale *)&v94);
          char v35 = v44;
          *((_DWORD *)v32 + 36) = v36;
          if (!v33) {
            goto LABEL_96;
          }
        }
        else if (!v33)
        {
          goto LABEL_96;
        }
        uint64_t v46 = *((void *)v32 + 3);
        BOOL v47 = v46 <= (uint64_t)v31;
        std::string::size_type v48 = v46 - (void)v31;
        if (v47) {
          std::string::size_type v49 = 0;
        }
        else {
          std::string::size_type v49 = v48;
        }
        int64_t v50 = (char *)v35 - (char *)v30;
        if ((char *)v35 - (char *)v30 >= 1)
        {
          int64_t v51 = v35;
          uint64_t v52 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v33 + 96))(v33, v30, v50);
          char v35 = v51;
          if (v52 != v50) {
            goto LABEL_96;
          }
        }
        goto LABEL_80;
      }
      goto LABEL_97;
    }
    *((void *)v27 + 3) = v85;
    *(_DWORD *)((char *)v84 + *(void *)(v26 - 24)) = *(_DWORD *)((unsigned char *)v84 + *(void *)(v26 - 24)) & 0xFFFFFEFB | 4;
    *(_DWORD *)((char *)v84 + *(void *)(v26 - 24)) |= 0x400u;
    uint64_t v37 = *(void *)(v26 - 24);
    char v38 = a1 + 2;
    uint64_t v39 = v82;
LABEL_52:
    *(void *)((char *)v38 + v37) = v39;
    std::ostream::operator<<();
    if (v24 == 2) {
      goto LABEL_128;
    }
LABEL_98:
    LOBYTE(v86) = 44;
    MEMORY[0x2166B95F0](&__b, a1);
    if (__b.__r_.__value_.__s.__data_[0])
    {
      uint64_t v65 = (char *)a1 + *(void *)(*a1 - 24);
      uint64_t v66 = *((void *)v65 + 5);
      if ((*((_DWORD *)v65 + 2) & 0xB0) == 0x20) {
        uint64_t v67 = (void **)((char *)&v86 + 1);
      }
      else {
        uint64_t v67 = &v86;
      }
      int v68 = *((_DWORD *)v65 + 36);
      if (v68 == -1)
      {
        std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
        uint64_t v69 = std::locale::use_facet((const std::locale *)&v94, MEMORY[0x263F8C108]);
        int v68 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v69->__vftable[2].~facet_0)(v69, 32);
        std::locale::~locale((std::locale *)&v94);
        *((_DWORD *)v65 + 36) = v68;
        if (!v66) {
          goto LABEL_32;
        }
      }
      else if (!v66)
      {
        goto LABEL_32;
      }
      uint64_t v70 = *((void *)v65 + 3);
      BOOL v47 = v70 <= 1;
      std::string::size_type v71 = v70 - 1;
      if (v47) {
        std::string::size_type v72 = 0;
      }
      else {
        std::string::size_type v72 = v71;
      }
      if ((char *)v67 - (char *)&v86 >= 1
        && (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v66 + 96))(v66, &v86, (char *)v67 - (char *)&v86) != (char *)v67 - (char *)&v86)
      {
        goto LABEL_32;
      }
      if ((uint64_t)v72 >= 1)
      {
        if (v72 > 0x7FFFFFFFFFFFFFF7) {
          goto LABEL_133;
        }
        if (v72 >= 0x17)
        {
          uint64_t v74 = (v72 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v72 | 7) != 0x17) {
            uint64_t v74 = v72 | 7;
          }
          uint64_t v75 = v74 + 1;
          uint64_t v73 = operator new(v74 + 1);
          v94.__r_.__value_.__l.__size_ = v72;
          v94.__r_.__value_.__r.__words[2] = v75 | 0x8000000000000000;
          v94.__r_.__value_.__r.__words[0] = (std::string::size_type)v73;
        }
        else
        {
          *((unsigned char *)&v94.__r_.__value_.__s + 23) = v72;
          uint64_t v73 = &v94;
        }
        memset(v73, v68, v72);
        *((unsigned char *)v73 + v72) = 0;
        if ((v94.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v76 = &v94;
        }
        else {
          uint64_t v76 = (std::string *)v94.__r_.__value_.__r.__words[0];
        }
        uint64_t v77 = (*(uint64_t (**)(uint64_t, std::string *, std::string::size_type))(*(void *)v66 + 96))(v66, v76, v72);
        uint64_t v78 = v77;
        if (SHIBYTE(v94.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v94.__r_.__value_.__l.__data_);
          if (v78 != v72) {
            goto LABEL_32;
          }
        }
        else if (v77 != v72)
        {
          goto LABEL_32;
        }
      }
      if ((char *)&v86 + 1 - (char *)v67 >= 1
        && (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v66 + 96))(v66, v67, (char *)&v86 + 1 - (char *)v67) != (char *)&v86 + 1 - (char *)v67)
      {
LABEL_32:
        std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
        goto LABEL_33;
      }
      *((void *)v65 + 3) = 0;
    }
LABEL_33:
    MEMORY[0x2166B9600](&__b);
    ++v24;
  }
  if (v25 != 0.0)
  {
    *((void *)v27 + 3) = v85;
    *(_DWORD *)((char *)v84 + *(void *)(v26 - 24)) |= 0x400u;
    uint64_t v37 = *(void *)(v26 - 24);
    char v38 = a1 + 2;
    uint64_t v39 = v83;
    goto LABEL_52;
  }
  uint64_t v40 = (char *)HIBYTE(v91);
  char v41 = (char *)__p[1];
  if (v91 >= 0) {
    char v42 = __p;
  }
  else {
    char v42 = (void **)__p[0];
  }
  MEMORY[0x2166B95F0](&__b, a1);
  if (__b.__r_.__value_.__s.__data_[0])
  {
    if ((char)v40 >= 0) {
      int v43 = v40;
    }
    else {
      int v43 = v41;
    }
    double v32 = (char *)a1 + *(void *)(*a1 - 24);
    uint64_t v33 = *((void *)v32 + 5);
    std::string::size_type v34 = &v43[(void)v42];
    if ((*((_DWORD *)v32 + 2) & 0xB0) == 0x20) {
      char v35 = (void **)&v43[(void)v42];
    }
    else {
      char v35 = v42;
    }
    int v36 = *((_DWORD *)v32 + 36);
    if (v36 != -1)
    {
      if (!v33) {
        goto LABEL_96;
      }
LABEL_75:
      uint64_t v55 = *((void *)v32 + 3);
      BOOL v47 = v55 <= (uint64_t)v43;
      std::string::size_type v56 = v55 - (void)v43;
      if (v47) {
        std::string::size_type v49 = 0;
      }
      else {
        std::string::size_type v49 = v56;
      }
      int64_t v57 = (char *)v35 - (char *)v42;
      if ((char *)v35 - (char *)v42 >= 1)
      {
        char v58 = v35;
        uint64_t v59 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v33 + 96))(v33, v42, v57);
        char v35 = v58;
        if (v59 != v57) {
          goto LABEL_96;
        }
      }
LABEL_80:
      if ((uint64_t)v49 < 1) {
        goto LABEL_94;
      }
      if (v49 > 0x7FFFFFFFFFFFFFF7) {
        goto LABEL_133;
      }
      uint64_t v81 = v35;
      if (v49 >= 0x17)
      {
        uint64_t v61 = (v49 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v49 | 7) != 0x17) {
          uint64_t v61 = v49 | 7;
        }
        uint64_t v62 = v61 + 1;
        char v60 = operator new(v61 + 1);
        v94.__r_.__value_.__l.__size_ = v49;
        v94.__r_.__value_.__r.__words[2] = v62 | 0x8000000000000000;
        v94.__r_.__value_.__r.__words[0] = (std::string::size_type)v60;
      }
      else
      {
        *((unsigned char *)&v94.__r_.__value_.__s + 23) = v49;
        char v60 = &v94;
      }
      memset(v60, v36, v49);
      *((unsigned char *)v60 + v49) = 0;
      if ((v94.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v63 = &v94;
      }
      else {
        std::string::size_type v63 = (std::string *)v94.__r_.__value_.__r.__words[0];
      }
      uint64_t v64 = (*(uint64_t (**)(uint64_t, std::string *, std::string::size_type))(*(void *)v33 + 96))(v33, v63, v49);
      if (SHIBYTE(v94.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v94.__r_.__value_.__l.__data_);
      }
      char v35 = v81;
      if (v64 == v49)
      {
LABEL_94:
        if (v34 - (char *)v35 < 1
          || (*(uint64_t (**)(uint64_t))(*(void *)v33 + 96))(v33) == v34 - (char *)v35)
        {
          *((void *)v32 + 3) = 0;
          goto LABEL_97;
        }
      }
      goto LABEL_96;
    }
    uint64_t v53 = v35;
    std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
    BOOL v54 = std::locale::use_facet((const std::locale *)&v94, MEMORY[0x263F8C108]);
    int v36 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v54->__vftable[2].~facet_0)(v54, 32);
    std::locale::~locale((std::locale *)&v94);
    char v35 = v53;
    *((_DWORD *)v32 + 36) = v36;
    if (v33) {
      goto LABEL_75;
    }
LABEL_96:
    std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
  }
LABEL_97:
  MEMORY[0x2166B9600](&__b);
  if (v24 != 2) {
    goto LABEL_98;
  }
LABEL_128:
  sub_2153C1168(a1, (uint64_t)"   ]", 4);
  *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 8) = v80;
  if (SHIBYTE(v91) < 0) {
    operator delete(__p[0]);
  }
  return a1;
}

uint64_t sub_2153FDF6C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 256);
  if (v2) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v2 + 24))(v2, a1);
  }
  else {
    return 1;
  }
}

BOOL sub_2153FDFA4(uint64_t a1, void *a2)
{
  int v4 = (*(uint64_t (**)(void))(*(void *)*a2 + 16))();
  if (!v4)
  {
    uint64_t v7 = *a2;
    uint64_t v6 = a2[1];
    if (v6) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
    }
    size_t v8 = *(std::__shared_weak_count **)(a1 + 264);
    *(void *)(a1 + 256) = v7;
    *(void *)(a1 + 264) = v6;
    if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  return v4 == 0;
}

void sub_2153FE06C(uint64_t a1@<X0>, float64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v36 = *MEMORY[0x263EF8340];
  long long v25 = xmmword_215446208;
  long long v26 = unk_215446218;
  long long v27 = xmmword_215446228;
  char v24 = 1;
  uint64_t v29 = 0x3FF0000000000000;
  long long v28 = unk_215446238;
  *(void *)&v32[16] = 0;
  *(void *)&double v33 = 1;
  float64x2_t v30 = 0uLL;
  double v31 = 0.0;
  sub_2153CAD38((float64x2_t *)(a1 + 128), v30.f64);
  double v6 = *(double *)(a1 + 224);
  *(float64x2_t *)double v32 = vmulq_n_f64(v30, v6);
  *(double *)&v32[16] = v31 * v6;
  sub_2153FE288((double *)v32, (double *)(a1 + 16), (uint64_t)&v25);
  long long v16 = v26;
  long long v17 = v27;
  long long v18 = v28;
  uint64_t v19 = v29;
  long long v15 = v25;
  double v14 = *(double *)(a1 + 240);
  double v7 = *(double *)(a1 + 200);
  __double2 v8 = __sincos_stret(*(double *)(a1 + 208));
  __double2 v10 = __sincos_stret(v7);
  v9.f64[0] = v10.__cosval;
  v9.f64[1] = v10.__sinval;
  float64x2_t v11 = vmulq_n_f64(v9, v14);
  v9.f64[0] = *(float64_t *)(a1 + 224);
  double v12 = *(double *)(a1 + 104);
  float64x2_t v20 = vaddq_f64(vmulq_n_f64(vmulq_n_f64(v11, v8.__sinval), v9.f64[0]), *(float64x2_t *)(a1 + 88));
  double v21 = v14 * v8.__cosval * v9.f64[0] + v12;
  char v22 = 1;
  char v24 = 1;
  *(void *)&long long v25 = v15;
  *((void *)&v25 + 1) = *((void *)&v16 + 1);
  *(void *)&long long v26 = v18;
  *((void *)&v26 + 1) = *((void *)&v15 + 1);
  *(void *)&long long v27 = v17;
  *((void *)&v27 + 1) = *((void *)&v18 + 1);
  *(void *)&long long v28 = v16;
  *((void *)&v28 + 1) = *((void *)&v17 + 1);
  uint64_t v29 = v19;
  *(void *)&v30.f64[0] = &v25;
  v30.f64[1] = a2;
  v23[0] = (double *)&v25;
  v23[1] = (double *)&v20;
  *(void *)&v32[16] = 0;
  double v33 = 0.0;
  *(void *)&v32[8] = 0;
  sub_2153CB718((uint64_t)&v32[8], (double **)&v30);
  float64x2_t v34 = 0uLL;
  double v35 = 0.0;
  sub_2153CB718((uint64_t)&v34, v23);
  double v13 = v33 - v35;
  *(float64x2_t *)a3 = vsubq_f64(*(float64x2_t *)&v32[8], v34);
  *(double *)(a3 + 16) = v13;
  *(unsigned char *)(a3 + 24) = 1;
}

__n128 sub_2153FE288(double *a1, double *a2, uint64_t a3)
{
  double v5 = *a1;
  double v6 = a1[1];
  double v7 = a1[2];
  double v8 = v5 * v5 + v6 * v6 + v7 * v7;
  if (v8 >= 0.0000002635)
  {
    double v12 = sqrt(v8);
    __double2 v13 = __sincos_stret(v12);
    double cosval = v13.__cosval;
    double v10 = v13.__sinval / v12;
    double v9 = 1.0 / v8 * (1.0 - v13.__cosval);
  }
  else
  {
    double v9 = 0.5 - v8 * (v8 / -720.0 + 0.0416666667);
    double v10 = 1.0 - v8 * (0.166666667 - v8 * (v8 / -5040.0 + 0.00833333333));
    double cosval = 1.0 - v8 * v9;
  }
  double v14 = v6 * (v5 * v9);
  double v15 = v7 * (v5 * v9);
  double v16 = v7 * (v6 * v9);
  double v17 = v5 * v10;
  double v18 = v6 * v10;
  double v19 = v7 * v10;
  v28[0] = cosval + v5 * v9 * v5;
  v28[1] = v14 + v19;
  void v28[2] = v15 - v18;
  v28[3] = v14 - v19;
  v28[4] = cosval + v6 * v9 * v6;
  v28[5] = v16 + v17;
  v28[6] = v18 + v15;
  v28[7] = v16 - v17;
  v28[8] = cosval + v7 * v9 * v7;
  v22[0] = v28;
  v22[1] = a2;
  long long v23 = 0u;
  __n128 v24 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  uint64_t v27 = 0;
  sub_2153CB228((uint64_t)&v23, v22);
  long long v20 = v26;
  *(_OWORD *)(a3 + 32) = v25;
  *(_OWORD *)(a3 + 48) = v20;
  *(void *)(a3 + 64) = v27;
  __n128 result = v24;
  *(_OWORD *)a3 = v23;
  *(__n128 *)(a3 + 16) = result;
  return result;
}

void sub_2153FE418(uint64_t a1@<X0>, float64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  float64x2_t v28 = (float64x2_t)xmmword_215446208;
  long long v29 = unk_215446218;
  long long v30 = xmmword_215446228;
  char v27 = 1;
  uint64_t v32 = 0x3FF0000000000000;
  long long v31 = unk_215446238;
  double v23 = 0.0;
  uint64_t v24 = 1;
  float64x2_t v25 = 0uLL;
  double v26 = 0.0;
  sub_2153CAD38((float64x2_t *)(a1 + 128), v25.f64);
  double v6 = *(double *)(a1 + 224);
  float64x2_t v22 = vmulq_n_f64(v25, v6);
  double v23 = v26 * v6;
  sub_2153FE288(v22.f64, (double *)(a1 + 16), (uint64_t)&v28);
  v17[1] = v29;
  void v17[2] = v30;
  unsigned int v17[3] = v31;
  uint64_t v18 = v32;
  v17[0] = v28;
  double v15 = *(double *)(a1 + 240);
  double v7 = *(double *)(a1 + 200);
  __double2 v8 = __sincos_stret(*(double *)(a1 + 208));
  __double2 v10 = __sincos_stret(v7);
  v9.f64[0] = v10.__cosval;
  v9.f64[1] = v10.__sinval;
  double v11 = *(double *)(a1 + 224);
  double v12 = v15 * v8.__cosval * v11;
  float64x2_t v16 = vaddq_f64(vmulq_n_f64(vmulq_n_f64(vmulq_n_f64(v9, v15), v8.__sinval), v11), *(float64x2_t *)(a1 + 88));
  v9.f64[0] = *(float64_t *)(a1 + 104);
  float64x2_t v19 = v16;
  double v13 = v12 + v9.f64[0];
  double v20 = v12 + v9.f64[0];
  char v21 = 1;
  *(void *)&v22.f64[0] = v17;
  v22.f64[1] = a2;
  *(void *)&long long v29 = 0;
  float64x2_t v28 = 0uLL;
  sub_2153CB718((uint64_t)&v28, (double **)&v22);
  double v14 = *(double *)&v29 + v13;
  *(float64x2_t *)a3 = vaddq_f64(v28, v16);
  *(double *)(a3 + 16) = v14;
  *(unsigned char *)(a3 + 24) = 1;
}

double sub_2153FE5E8@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)&v17[8] = xmmword_215446208;
  long long v18 = unk_215446218;
  long long v19 = xmmword_215446228;
  *(unsigned char *)(a2 + 24) = 1;
  uint64_t v16 = 1;
  long long v20 = unk_215446238;
  uint64_t v21 = 0x3FF0000000000000;
  double v23 = 0.0;
  uint64_t v24 = 1;
  float64x2_t v25 = 0uLL;
  double v26 = 0.0;
  sub_2153CAD38((float64x2_t *)(a1 + 128), v25.f64);
  double v4 = *(double *)(a1 + 224);
  float64x2_t v22 = vmulq_n_f64(v25, v4);
  double v23 = v26 * v4;
  sub_2153FE288(v22.f64, (double *)(a1 + 16), (uint64_t)&v17[8]);
  v13[0] = *(void *)&v17[8];
  v13[1] = *((void *)&v18 + 1);
  void v13[2] = v20;
  float32x2_t v13[3] = *(void *)&v17[16];
  v13[4] = v19;
  v13[5] = *((void *)&v20 + 1);
  v13[6] = v18;
  v13[7] = *((void *)&v19 + 1);
  v13[8] = v21;
  double v12 = *(double *)(a1 + 240);
  double v5 = *(double *)(a1 + 200);
  __double2 v6 = __sincos_stret(*(double *)(a1 + 208));
  __double2 v8 = __sincos_stret(v5);
  v7.f64[0] = v8.__cosval;
  double v9 = *(double *)(a1 + 224);
  v7.f64[1] = v8.__sinval;
  float64x2_t v14 = vaddq_f64(vmulq_n_f64(vmulq_n_f64(vmulq_n_f64(v7, v12), v6.__sinval), v9), *(float64x2_t *)(a1 + 88));
  double v15 = v12 * v6.__cosval * v9 + *(double *)(a1 + 104);
  *(void *)&v22.f64[0] = v13;
  *(void *)&v22.f64[1] = &v14;
  memset(v17, 0, sizeof(v17));
  sub_2153CB718((uint64_t)v17, (double **)&v22);
  double v10 = *(double *)&v17[16];
  *(float64x2_t *)a2 = vnegq_f64(*(float64x2_t *)v17);
  double result = -v10;
  *(double *)(a2 + 16) = -v10;
  return result;
}

double sub_2153FE778@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  long long v13 = xmmword_215446208;
  long long v14 = unk_215446218;
  long long v15 = xmmword_215446228;
  uint64_t v17 = 0x3FF0000000000000;
  long long v16 = unk_215446238;
  double v19 = 0.0;
  uint64_t v20 = 1;
  float64x2_t v21 = 0uLL;
  double v22 = 0.0;
  sub_2153CAD38((float64x2_t *)(a1 + 128), v21.f64);
  double v4 = *(double *)(a1 + 224);
  float64x2_t v18 = vmulq_n_f64(v21, v4);
  double v19 = v22 * v4;
  sub_2153FE288(v18.f64, (double *)(a1 + 16), (uint64_t)&v13);
  *(unsigned char *)a2 = 1;
  *(_OWORD *)(a2 + 24) = v14;
  *(_OWORD *)(a2 + 40) = v15;
  *(_OWORD *)(a2 + 56) = v16;
  *(void *)(a2 + 72) = v17;
  *(_OWORD *)(a2 + 8) = v13;
  double v12 = *(double *)(a1 + 240);
  double v5 = *(double *)(a1 + 200);
  __double2 v6 = __sincos_stret(*(double *)(a1 + 208));
  __double2 v8 = __sincos_stret(v5);
  v7.f64[0] = v8.__cosval;
  v7.f64[1] = v8.__sinval;
  float64x2_t v9 = vmulq_n_f64(v7, v12);
  v7.f64[0] = *(float64_t *)(a1 + 224);
  double v10 = *(double *)(a1 + 104);
  *(float64x2_t *)(a2 + 80) = vaddq_f64(vmulq_n_f64(vmulq_n_f64(v9, v6.__sinval), v7.f64[0]), *(float64x2_t *)(a1 + 88));
  double result = v12 * v6.__cosval * v7.f64[0] + v10;
  *(double *)(a2 + 96) = result;
  *(unsigned char *)(a2 + 104) = 1;
  return result;
}

uint64_t sub_2153FE8C4(uint64_t a1, char a2)
{
  *(unsigned char *)(a1 + 8) = a2;
  *(unsigned char *)(a1 + 112) = a2;
  *(unsigned char *)(a1 + 120) = a2;
  *(unsigned char *)(a1 + 216) = a2;
  uint64_t result = *(void *)(a1 + 256);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 32))();
  }
  return result;
}

void sub_2153FE904()
{
}

uint64_t sub_2153FE9F0()
{
  return 1;
}

void sub_2153FE9F8(void *a1)
{
  *a1 = &unk_26C5FB928;
  uint64_t v1 = (std::__shared_weak_count *)a1[33];
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  JUMPOUT(0x2166B9890);
}

void *sub_2153FEAA0(void *a1)
{
  *a1 = &unk_26C5FB928;
  uint64_t v2 = (std::__shared_weak_count *)a1[33];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

BOOL sub_2153FEB28(uint64_t a1, uint64_t a2, double a3)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a2 + 16))(a2)) {
    return 0;
  }
  uint64_t v11 = a2 + 16;
  v12[0] = a1 + 16;
  v12[1] = &v11;
  float64x2_t v13 = 0u;
  float64x2_t v14 = 0u;
  float64x2_t v15 = 0u;
  float64x2_t v16 = 0u;
  uint64_t v17 = 0;
  sub_2153FB6A4((uint64_t)&v13, (uint64_t)v12);
  v9[1] = v14;
  _OWORD v9[2] = v15;
  void v9[3] = v16;
  uint64_t v10 = v17;
  v9[0] = v13;
  float64x2_t v13 = 0uLL;
  v14.f64[0] = 0.0;
  sub_2153CAD38(v9, v13.f64);
  if (sqrt(v13.f64[0] * v13.f64[0] + v13.f64[1] * v13.f64[1] + v14.f64[0] * v14.f64[0]) >= a3) {
    return 0;
  }
  double v6 = *(double *)(a1 + 104) - *(double *)(a2 + 104);
  float64x2_t v7 = vsubq_f64(*(float64x2_t *)(a1 + 88), *(float64x2_t *)(a2 + 88));
  return sqrt(vaddvq_f64(vmulq_f64(v7, v7)) + v6 * v6) < a3;
}

uint64_t *sub_2153FEC68(uint64_t a1, uint64_t *a2)
{
  sub_2153FBECC((unsigned char *)(a1 + 8), a2);
  return sub_2153FC018((long long *)(a1 + 88), a2);
}

uint64_t sub_2153FECAC()
{
  return 1;
}

uint64_t sub_2153FECB4()
{
  return 0;
}

double sub_2153FECBC@<D0>(uint64_t a1@<X0>, double *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  char v15 = 1;
  uint64_t v4 = *(void *)(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 64);
  uint64_t v6 = *(void *)(a1 + 72);
  uint64_t v8 = *(void *)(a1 + 32);
  uint64_t v7 = *(void *)(a1 + 40);
  uint64_t v9 = *(void *)(a1 + 48);
  uint64_t v10 = *(void *)(a1 + 56);
  uint64_t v11 = *(void *)(a1 + 80);
  v16[0] = *(void *)(a1 + 16);
  v16[1] = v7;
  _OWORD v16[2] = v5;
  _DWORD v16[3] = v4;
  float v16[4] = v9;
  v16[5] = v6;
  v16[6] = v8;
  v16[7] = v10;
  float64x2_t v16[8] = v11;
  v14[0] = (double *)v16;
  v14[1] = a2;
  v13[0] = (double *)v16;
  v13[1] = (double *)(a1 + 88);
  double v18 = 0.0;
  float64x2_t v17 = 0uLL;
  sub_2153CB718((uint64_t)&v17, v14);
  float64x2_t v19 = 0uLL;
  double v20 = 0.0;
  sub_2153CB718((uint64_t)&v19, v13);
  double result = v18 - v20;
  *(float64x2_t *)a3 = vsubq_f64(v17, v19);
  *(double *)(a3 + 16) = result;
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

double sub_2153FEDAC@<D0>(uint64_t a1@<X0>, double *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  v6[0] = (double *)(a1 + 16);
  v6[1] = a2;
  double v8 = 0.0;
  float64x2_t v7 = 0uLL;
  sub_2153CB718((uint64_t)&v7, v6);
  double result = v8 + *(double *)(a1 + 104);
  *(float64x2_t *)a3 = vaddq_f64(v7, *(float64x2_t *)(a1 + 88));
  *(double *)(a3 + 16) = result;
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

double sub_2153FEE4C@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(unsigned char *)(a2 + 24) = 1;
  uint64_t v3 = *(void *)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 64);
  uint64_t v5 = *(void *)(a1 + 72);
  uint64_t v7 = *(void *)(a1 + 32);
  uint64_t v6 = *(void *)(a1 + 40);
  uint64_t v8 = *(void *)(a1 + 48);
  uint64_t v9 = *(void *)(a1 + 56);
  uint64_t v10 = *(void *)(a1 + 80);
  v13[0] = *(void *)(a1 + 16);
  v13[1] = v6;
  void v13[2] = v4;
  float32x2_t v13[3] = v3;
  v13[4] = v8;
  v13[5] = v5;
  v13[6] = v7;
  v13[7] = v9;
  v13[8] = v10;
  v16[0] = (double *)v13;
  v16[1] = (double *)(a1 + 88);
  double v15 = 0.0;
  float64x2_t v14 = 0uLL;
  sub_2153CB718((uint64_t)&v14, v16);
  double v11 = v15;
  *(float64x2_t *)a2 = vnegq_f64(v14);
  double result = -v11;
  *(double *)(a2 + 16) = -v11;
  return result;
}

__n128 sub_2153FEEE4@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  long long v2 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 32);
  long long v3 = *(_OWORD *)(a1 + 64);
  *(_OWORD *)(a2 + 40) = *(_OWORD *)(a1 + 48);
  *(_OWORD *)(a2 + 56) = v3;
  *(unsigned char *)a2 = *(unsigned char *)(a1 + 8);
  *(void *)(a2 + 72) = *(void *)(a1 + 80);
  *(_OWORD *)(a2 + 8) = v2;
  __n128 result = *(__n128 *)(a1 + 88);
  *(__n128 *)(a2 + 80) = result;
  *(void *)(a2 + 96) = *(void *)(a1 + 104);
  *(unsigned char *)(a2 + 104) = *(unsigned char *)(a1 + 112);
  return result;
}

uint64_t sub_2153FEF28(uint64_t result, char a2)
{
  *(unsigned char *)(result + 8) = a2;
  *(unsigned char *)(result + 112) = a2;
  return result;
}

void sub_2153FEF34()
{
}

uint64_t sub_2153FEFC8()
{
  return 0;
}

void sub_2153FEFD0()
{
}

uint64_t sub_2153FEFE8(std::string::size_type *a1, uint64_t a2, unint64_t *a3, uint64_t a4)
{
  if (*(char *)(a2 + 23) < 0) {
    sub_2153C0AE4(&__dst, *(void **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string __dst = *(std::string *)a2;
  }
  cva::adp::PListPath::convertToPath(a3, (uint64_t)__p);
  if ((SBYTE7(v45) & 0x80u) == 0) {
    uint64_t v8 = __p;
  }
  else {
    uint64_t v8 = (void **)__p[0];
  }
  if ((SBYTE7(v45) & 0x80u) == 0) {
    std::string::size_type v9 = BYTE7(v45);
  }
  else {
    std::string::size_type v9 = (std::string::size_type)__p[1];
  }
  std::string::append(&__dst, (const std::string::value_type *)v8, v9);
  if (SBYTE7(v45) < 0) {
    operator delete(__p[0]);
  }
  v41[0] = 0;
  BYTE7(v45) = 10;
  strcpy((char *)__p, "Resolution");
  uint64_t v10 = sub_2153C9660(a1, &__dst, (uint64_t)__p);
  uint64_t v11 = v10;
  if (SBYTE7(v45) < 0)
  {
    operator delete(__p[0]);
    if (!v11)
    {
LABEL_14:
      if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_15;
      }
      goto LABEL_24;
    }
  }
  else if (!v10)
  {
    goto LABEL_14;
  }
  *(_OWORD *)long long __p = 0u;
  long long v45 = 0u;
  *((unsigned char *)&v43.__r_.__value_.__s + 23) = 12;
  strcpy((char *)&v43, "Image Bounds");
  char v12 = sub_2154025FC(a1, &__dst, (uint64_t)&v43);
  char v13 = v12;
  if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v43.__r_.__value_.__l.__data_);
    if (v13) {
      goto LABEL_20;
    }
  }
  else if (v12)
  {
LABEL_20:
    long long v14 = v45;
    *(_OWORD *)(a4 + 56) = *(_OWORD *)__p;
    *(_OWORD *)(a4 + 72) = v14;
    unint64_t v15 = v41[0];
    goto LABEL_23;
  }
  double v16 = (double)LODWORD(v41[0]);
  double v17 = (double)HIDWORD(v41[0]);
  unint64_t v15 = LODWORD(v41[0]) | ((unint64_t)HIDWORD(v41[0]) << 32);
  *(void *)(a4 + 56) = 0;
  *(double *)(a4 + 64) = v16;
  *(void *)(a4 + 72) = 0;
  *(double *)(a4 + 80) = v17;
LABEL_23:
  *(void *)(a4 + 88) = v15;
  if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_15:
    if (!v11) {
      return v11;
    }
LABEL_25:
    if (*(char *)(a2 + 23) < 0) {
      sub_2153C0AE4(&__dst, *(void **)a2, *(void *)(a2 + 8));
    }
    else {
      std::string __dst = *(std::string *)a2;
    }
    cva::adp::PListPath::convertToPath(a3, (uint64_t)__p);
    if ((SBYTE7(v45) & 0x80u) == 0) {
      double v18 = __p;
    }
    else {
      double v18 = (void **)__p[0];
    }
    if ((SBYTE7(v45) & 0x80u) == 0) {
      std::string::size_type v19 = BYTE7(v45);
    }
    else {
      std::string::size_type v19 = (std::string::size_type)__p[1];
    }
    std::string::append(&__dst, (const std::string::value_type *)v18, v19);
    if (SBYTE7(v45) < 0) {
      operator delete(__p[0]);
    }
    char v42 = 7;
    strcpy((char *)v41, "Pinhole");
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      sub_2153C0AE4(&v43, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
    }
    else {
      std::string v43 = __dst;
    }
    cva::adp::PListPath::convertToPath(v41, (uint64_t)__p);
    if ((SBYTE7(v45) & 0x80u) == 0) {
      double v20 = __p;
    }
    else {
      double v20 = (void **)__p[0];
    }
    if ((SBYTE7(v45) & 0x80u) == 0) {
      std::string::size_type v21 = BYTE7(v45);
    }
    else {
      std::string::size_type v21 = (std::string::size_type)__p[1];
    }
    std::string::append(&v43, (const std::string::value_type *)v20, v21);
    if (SBYTE7(v45) < 0)
    {
      operator delete(__p[0]);
      if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_47;
      }
    }
    else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_47;
    }
    operator delete(__dst.__r_.__value_.__l.__data_);
LABEL_47:
    uint64_t v39 = 0;
    char v40 = 1;
    BYTE7(v45) = 12;
    strcpy((char *)__p, "Focal Length");
    int v22 = sub_215402AE8(a1, (uint64_t)&v43, (unint64_t *)__p, (uint64_t)&v39);
    char v23 = v40;
    uint64_t v24 = (uint64_t *)(a4 + 64);
    if (v22) {
      uint64_t v24 = &v39;
    }
    else {
      char v23 = 1;
    }
    *(void *)a4 = *v24;
    *(unsigned char *)(a4 + 8) = v23;
    double v37 = 0.0;
    char v38 = 1;
    BYTE7(v45) = 12;
    strcpy((char *)__p, "Aspect Ratio");
    int v25 = sub_215402AE8(a1, (uint64_t)&v43, (unint64_t *)__p, (uint64_t)&v37);
    double v26 = v37;
    char v27 = v38;
    if (!v25)
    {
      double v26 = 1.0;
      char v27 = 1;
    }
    *(double *)(a4 + 16) = v26;
    *(unsigned char *)(a4 + 24) = v27;
    char v42 = 15;
    strcpy((char *)v41, "Principal Point");
    if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
      sub_2153C0AE4(&__dst, v43.__r_.__value_.__l.__data_, v43.__r_.__value_.__l.__size_);
    }
    else {
      std::string __dst = v43;
    }
    cva::adp::PListPath::convertToPath(v41, (uint64_t)__p);
    if ((SBYTE7(v45) & 0x80u) == 0) {
      float64x2_t v28 = __p;
    }
    else {
      float64x2_t v28 = (void **)__p[0];
    }
    if ((SBYTE7(v45) & 0x80u) == 0) {
      std::string::size_type v29 = BYTE7(v45);
    }
    else {
      std::string::size_type v29 = (std::string::size_type)__p[1];
    }
    std::string::append(&__dst, (const std::string::value_type *)v28, v29);
    if (SBYTE7(v45) < 0) {
      operator delete(__p[0]);
    }
    BYTE7(v45) = 4;
    strcpy((char *)__p, "Data");
    int v30 = sub_215400B88(a1, &__dst, (uint64_t)__p);
    int v31 = v30;
    if (SBYTE7(v45) < 0)
    {
      operator delete(__p[0]);
      if (!v31)
      {
LABEL_67:
        if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_68;
        }
        goto LABEL_77;
      }
    }
    else if (!v30)
    {
      goto LABEL_67;
    }
    BYTE7(v45) = 5;
    strcpy((char *)__p, "Fixed");
    uint64_t v33 = (char *)(a4 + 48);
    int v34 = cva::adp::io::PListSerializer::getItem<BOOL>(a1, &__dst, (uint64_t)__p, (unsigned char *)(a4 + 48));
    if (SBYTE7(v45) < 0) {
      operator delete(__p[0]);
    }
    char v35 = *v33 ^ 1;
    if (!v34) {
      char v35 = 1;
    }
    *uint64_t v33 = v35;
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_68:
      if (v31) {
        goto LABEL_69;
      }
      goto LABEL_78;
    }
LABEL_77:
    operator delete(__dst.__r_.__value_.__l.__data_);
    if (v31)
    {
LABEL_69:
      if ((SHIBYTE(v43.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        return v11;
      }
LABEL_79:
      operator delete(v43.__r_.__value_.__l.__data_);
      return v11;
    }
LABEL_78:
    double v36 = *(double *)(a4 + 80) * 0.5;
    *(double *)(a4 + 32) = *(double *)(a4 + 64) * 0.5;
    *(double *)(a4 + 40) = v36;
    *(unsigned char *)(a4 + 48) = 1;
    if ((SHIBYTE(v43.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return v11;
    }
    goto LABEL_79;
  }
LABEL_24:
  operator delete(__dst.__r_.__value_.__l.__data_);
  if (v11) {
    goto LABEL_25;
  }
  return v11;
}

BOOL sub_2153FF518(uint64_t a1, uint64_t a2, double a3)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a2 + 16))(a2) != 3) {
    return 0;
  }
  if (*(double *)(a1 + 32) - *(double *)(a2 + 32) >= a3) {
    return 0;
  }
  if (*(double *)(a1 + 48) - *(double *)(a2 + 48) >= a3) {
    return 0;
  }
  float64x2_t v6 = vsubq_f64(*(float64x2_t *)(a1 + 64), *(float64x2_t *)(a2 + 64));
  if (sqrt(vaddvq_f64(vmulq_f64(v6, v6))) >= a3) {
    return 0;
  }
  if (*(unsigned __int8 *)(a1 + 80) != *(unsigned __int8 *)(a2 + 80)) {
    return 0;
  }
  float64x2_t v7 = vsubq_f64(*(float64x2_t *)(a1 + 88), *(float64x2_t *)(a2 + 88));
  float64x2_t v8 = vmulq_f64(v7, v7);
  float64x2_t v9 = vsubq_f64(*(float64x2_t *)(a1 + 104), *(float64x2_t *)(a2 + 104));
  float64x2_t v10 = vmulq_f64(v9, v9);
  if (sqrt(vaddq_f64(vaddq_f64(vaddq_f64(v8, (float64x2_t)vdupq_laneq_s64((int64x2_t)v8, 1)), v10), (float64x2_t)vdupq_laneq_s64((int64x2_t)v10, 1)).f64[0]) >= a3)return 0; {
  if (*(_DWORD *)(a1 + 120) != *(_DWORD *)(a2 + 120))
  }
    return 0;
  if (*(_DWORD *)(a1 + 124) != *(_DWORD *)(a2 + 124)) {
    return 0;
  }
  uint64_t v11 = 0;
  double v12 = (*(double *)(a1 + 160) - *(double *)(a2 + 160)) * (*(double *)(a1 + 160) - *(double *)(a2 + 160));
  do
  {
    float64x2_t v13 = vsubq_f64(*(float64x2_t *)(a1 + v11 + 168), *(float64x2_t *)(a2 + v11 + 168));
    float64x2_t v14 = vsubq_f64(*(float64x2_t *)(a1 + v11 + 184), *(float64x2_t *)(a2 + v11 + 184));
    float64x2_t v15 = vmulq_f64(v13, v13);
    float64x2_t v16 = vmulq_f64(v14, v14);
    double v12 = v12 + v15.f64[0] + v15.f64[1] + v16.f64[0] + v16.f64[1];
    v11 += 32;
  }
  while (v11 != 2016);
  double v17 = *(double *)(a1 + 2184) - *(double *)(a2 + 2184);
  double v18 = v12 + v17 * v17;
  float64x2_t v19 = vsubq_f64(*(float64x2_t *)(a1 + 2192), *(float64x2_t *)(a2 + 2192));
  float64x2_t v20 = vmulq_f64(v19, v19);
  if (sqrt(v18 + v20.f64[0] + v20.f64[1]) >= a3) {
    return 0;
  }
  uint64_t v21 = 0;
  double v22 = (*(double *)(a1 + 2208) - *(double *)(a2 + 2208)) * (*(double *)(a1 + 2208) - *(double *)(a2 + 2208));
  do
  {
    float64x2_t v23 = vsubq_f64(*(float64x2_t *)(a1 + v21 + 2216), *(float64x2_t *)(a2 + v21 + 2216));
    float64x2_t v24 = vsubq_f64(*(float64x2_t *)(a1 + v21 + 2232), *(float64x2_t *)(a2 + v21 + 2232));
    float64x2_t v25 = vmulq_f64(v23, v23);
    float64x2_t v26 = vmulq_f64(v24, v24);
    double v22 = v22 + v25.f64[0] + v25.f64[1] + v26.f64[0] + v26.f64[1];
    v21 += 32;
  }
  while (v21 != 2016);
  double v27 = *(double *)(a1 + 4232) - *(double *)(a2 + 4232);
  double v28 = v22 + v27 * v27;
  float64x2_t v29 = vsubq_f64(*(float64x2_t *)(a1 + 4240), *(float64x2_t *)(a2 + 4240));
  float64x2_t v30 = vmulq_f64(v29, v29);
  if (sqrt(v28 + v30.f64[0] + v30.f64[1]) >= a3
    || vabdd_f64(*(double *)(a1 + 128), *(double *)(a1 + 128)) >= a3
    || vabdd_f64(*(double *)(a1 + 136), *(double *)(a1 + 136)) >= a3)
  {
    return 0;
  }
  float64x2_t v31 = vsubq_f64(*(float64x2_t *)(a1 + 144), *(float64x2_t *)(a2 + 144));
  return sqrt(vaddvq_f64(vmulq_f64(v31, v31))) < a3;
}

void *sub_2153FF7C0(uint64_t a1, void *a2)
{
  uint64_t v4 = a1 + 32;
  sub_2153FF828((__n128 *)(a1 + 88), a2);
  sub_2153FF8CC(v4, a2);
  sub_2153FF9FC(a1 + 48, a2);
  return sub_2153FFB2C((__n128 *)(a1 + 64), a2);
}

void *sub_2153FF828(__n128 *a1, void *a2)
{
  uint64_t v4 = sub_2153C1168(a2, (uint64_t)"[FIXED][", 8);
  char v10 = 16;
  strcpy(__p, "Width and Height");
  uint64_t v5 = sub_2153C1168(v4, (uint64_t)__p, 16);
  float64x2_t v6 = sub_2153C1168(v5, (uint64_t)"] : ", 4);
  float64x2_t v7 = sub_2153FFC58(v6, *a1, a1[1]);
  sub_2153C1168(v7, (uint64_t)"\n", 1);
  if (v10 < 0) {
    operator delete(*(void **)__p);
  }
  return a2;
}

void *sub_2153FF8CC(uint64_t a1, void *a2)
{
  if (*(unsigned char *)(a1 + 8)) {
    long long v3 = "[FREE]";
  }
  else {
    long long v3 = "[FIXED]";
  }
  if (*(unsigned char *)(a1 + 8)) {
    size_t v4 = 6;
  }
  else {
    size_t v4 = 7;
  }
  unsigned __int8 v15 = v4;
  memcpy(__dst, v3, v4);
  *(unsigned char *)((unint64_t)__dst | v4) = 0;
  if ((v15 & 0x80u) == 0) {
    uint64_t v5 = __dst;
  }
  else {
    uint64_t v5 = (void **)__dst[0];
  }
  if ((v15 & 0x80u) == 0) {
    uint64_t v6 = v15;
  }
  else {
    uint64_t v6 = (uint64_t)__dst[1];
  }
  float64x2_t v7 = sub_2153C1168(a2, (uint64_t)v5, v6);
  float64x2_t v8 = sub_2153C1168(v7, (uint64_t)"[", 1);
  char v13 = 12;
  strcpy((char *)__p, "Focal Length");
  float64x2_t v9 = sub_2153C1168(v8, (uint64_t)__p, 12);
  sub_2153C1168(v9, (uint64_t)"] : ", 4);
  char v10 = (void *)std::ostream::operator<<();
  sub_2153C1168(v10, (uint64_t)"\n", 1);
  if (v13 < 0)
  {
    operator delete(__p[0]);
    if (((char)v15 & 0x80000000) == 0) {
      return a2;
    }
LABEL_17:
    operator delete(__dst[0]);
    return a2;
  }
  if ((char)v15 < 0) {
    goto LABEL_17;
  }
  return a2;
}

void *sub_2153FF9FC(uint64_t a1, void *a2)
{
  if (*(unsigned char *)(a1 + 8)) {
    long long v3 = "[FREE]";
  }
  else {
    long long v3 = "[FIXED]";
  }
  if (*(unsigned char *)(a1 + 8)) {
    size_t v4 = 6;
  }
  else {
    size_t v4 = 7;
  }
  unsigned __int8 v15 = v4;
  memcpy(__dst, v3, v4);
  *(unsigned char *)((unint64_t)__dst | v4) = 0;
  if ((v15 & 0x80u) == 0) {
    uint64_t v5 = __dst;
  }
  else {
    uint64_t v5 = (void **)__dst[0];
  }
  if ((v15 & 0x80u) == 0) {
    uint64_t v6 = v15;
  }
  else {
    uint64_t v6 = (uint64_t)__dst[1];
  }
  float64x2_t v7 = sub_2153C1168(a2, (uint64_t)v5, v6);
  float64x2_t v8 = sub_2153C1168(v7, (uint64_t)"[", 1);
  char v13 = 12;
  strcpy((char *)__p, "Aspect Ratio");
  float64x2_t v9 = sub_2153C1168(v8, (uint64_t)__p, 12);
  sub_2153C1168(v9, (uint64_t)"] : ", 4);
  char v10 = (void *)std::ostream::operator<<();
  sub_2153C1168(v10, (uint64_t)"\n", 1);
  if (v13 < 0)
  {
    operator delete(__p[0]);
    if (((char)v15 & 0x80000000) == 0) {
      return a2;
    }
LABEL_17:
    operator delete(__dst[0]);
    return a2;
  }
  if ((char)v15 < 0) {
    goto LABEL_17;
  }
  return a2;
}

void *sub_2153FFB2C(__n128 *a1, void *a2)
{
  if (a1[1].n128_u8[0]) {
    size_t v4 = "[FREE]";
  }
  else {
    size_t v4 = "[FIXED]";
  }
  if (a1[1].n128_u8[0]) {
    size_t v5 = 6;
  }
  else {
    size_t v5 = 7;
  }
  unsigned __int8 v17 = v5;
  memcpy(__dst, v4, v5);
  *(unsigned char *)((unint64_t)__dst | v5) = 0;
  if ((v17 & 0x80u) == 0) {
    uint64_t v6 = __dst;
  }
  else {
    uint64_t v6 = (void **)__dst[0];
  }
  if ((v17 & 0x80u) == 0) {
    uint64_t v7 = v17;
  }
  else {
    uint64_t v7 = (uint64_t)__dst[1];
  }
  float64x2_t v8 = sub_2153C1168(a2, (uint64_t)v6, v7);
  float64x2_t v9 = sub_2153C1168(v8, (uint64_t)"[", 1);
  char v15 = 15;
  strcpy((char *)__p, "Principal Point");
  char v10 = sub_2153C1168(v9, (uint64_t)__p, 15);
  uint64_t v11 = sub_2153C1168(v10, (uint64_t)"] : ", 4);
  double v12 = sub_2153FCB30(v11, *a1);
  sub_2153C1168(v12, (uint64_t)"\n", 1);
  if (v15 < 0)
  {
    operator delete(__p[0]);
    if (((char)v17 & 0x80000000) == 0) {
      return a2;
    }
LABEL_17:
    operator delete(__dst[0]);
    return a2;
  }
  if ((char)v17 < 0) {
    goto LABEL_17;
  }
  return a2;
}

uint64_t *sub_2153FFC58(uint64_t *a1, __n128 a2, __n128 a3)
{
  v92[0] = a2;
  v92[1] = a3;
  size_t v4 = (char *)a1 + *(void *)(*a1 - 24);
  int v5 = *((_DWORD *)v4 + 2);
  size_t v7 = *((void *)v4 + 2);
  int64_t v6 = *((void *)v4 + 3);
  if (v6)
  {
    if (v6 <= (uint64_t)(v7 + 2)) {
      int64_t v6 = v7 + 2;
    }
    size_t v8 = v6 + ~v7;
    double v9 = __exp10((double)-(uint64_t)v7);
    size_t v10 = v8 - 1;
    if (v8 - 1 > 0x7FFFFFFFFFFFFFF7) {
LABEL_133:
    }
      abort();
    double v11 = v9;
    if (v10 >= 0x17)
    {
      uint64_t v13 = (v10 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v10 | 7) != 0x17) {
        uint64_t v13 = v10 | 7;
      }
      uint64_t v14 = v13 + 1;
      p_b = (std::string *)operator new(v13 + 1);
      __b.__r_.__value_.__l.__size_ = v8 - 1;
      __b.__r_.__value_.__r.__words[2] = v14 | 0x8000000000000000;
      __b.__r_.__value_.__r.__words[0] = (std::string::size_type)p_b;
    }
    else
    {
      *((unsigned char *)&__b.__r_.__value_.__s + 23) = v8 - 1;
      p_b = &__b;
      if (v8 == 1)
      {
        LODWORD(v8) = 1;
        goto LABEL_13;
      }
    }
  }
  else
  {
    double v11 = __exp10((double)-(uint64_t)v7);
    size_t v10 = 3;
    *((unsigned char *)&__b.__r_.__value_.__s + 23) = 3;
    p_b = &__b;
    LODWORD(v8) = 4;
  }
  memset(p_b, 32, v10);
LABEL_13:
  p_b->__r_.__value_.__s.__data_[v10] = 0;
  char v15 = std::string::append(&__b, "0 ");
  std::string::size_type v16 = v15->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v93.__r_.__value_.__l.__data_ = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  v93.__r_.__value_.__r.__words[2] = v16;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  if (v7 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_133;
  }
  if (v7 >= 0x17)
  {
    uint64_t v18 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17) {
      uint64_t v18 = v7 | 7;
    }
    uint64_t v19 = v18 + 1;
    unsigned __int8 v17 = operator new(v18 + 1);
    std::string::size_type v87 = v7;
    int64_t v88 = v19 | 0x8000000000000000;
    uint64_t v86 = v17;
    goto LABEL_20;
  }
  HIBYTE(v88) = v7;
  unsigned __int8 v17 = &v86;
  if (v7) {
LABEL_20:
  }
    memset(v17, 32, v7);
  *((unsigned char *)v17 + v7) = 0;
  if (v88 >= 0) {
    float64x2_t v20 = (const std::string::value_type *)&v86;
  }
  else {
    float64x2_t v20 = (const std::string::value_type *)v86;
  }
  if (v88 >= 0) {
    std::string::size_type v21 = HIBYTE(v88);
  }
  else {
    std::string::size_type v21 = v87;
  }
  double v22 = std::string::append(&v93, v20, v21);
  std::string::size_type v23 = v22->__r_.__value_.__r.__words[2];
  *(_OWORD *)long long __p = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
  uint64_t v91 = v23;
  v22->__r_.__value_.__l.__size_ = 0;
  v22->__r_.__value_.__r.__words[2] = 0;
  v22->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v88) < 0)
  {
    operator delete(v86);
    if ((SHIBYTE(v93.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_29;
    }
LABEL_132:
    operator delete(v93.__r_.__value_.__l.__data_);
    goto LABEL_29;
  }
  if (SHIBYTE(v93.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_132;
  }
LABEL_29:
  int v80 = v5;
  if (SHIBYTE(__b.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__b.__r_.__value_.__l.__data_);
  }
  uint64_t v84 = a1 + 1;
  *(uint64_t *)((char *)a1 + *(void *)(*a1 - 24) + 24) = 0;
  v93.__r_.__value_.__s.__data_[0] = 91;
  sub_2153C1168(a1, (uint64_t)&v93, 1);
  uint64_t v24 = 0;
  uint64_t v85 = (int)v8 + (int)v7 + 1;
  uint64_t v82 = (int)v7;
  uint64_t v83 = (int)v7 - 3;
  while (1)
  {
    double v25 = *(double *)((char *)v92 + v24);
    uint64_t v26 = *a1;
    double v27 = (char *)a1 + *(void *)(*a1 - 24);
    if (v27[9]) {
      break;
    }
    if (fabs(v25) < v11)
    {
      double v28 = (char *)HIBYTE(v91);
      float64x2_t v29 = (char *)__p[1];
      if (v91 >= 0) {
        float64x2_t v30 = __p;
      }
      else {
        float64x2_t v30 = (void **)__p[0];
      }
      MEMORY[0x2166B95F0](&__b, a1);
      if (__b.__r_.__value_.__s.__data_[0])
      {
        if ((char)v28 >= 0) {
          float64x2_t v31 = v28;
        }
        else {
          float64x2_t v31 = v29;
        }
        uint64_t v32 = (char *)a1 + *(void *)(*a1 - 24);
        uint64_t v33 = *((void *)v32 + 5);
        int v34 = &v31[(void)v30];
        if ((*((_DWORD *)v32 + 2) & 0xB0) == 0x20) {
          char v35 = (void **)&v31[(void)v30];
        }
        else {
          char v35 = v30;
        }
        int v36 = *((_DWORD *)v32 + 36);
        if (v36 == -1)
        {
          uint64_t v44 = v35;
          std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
          long long v45 = std::locale::use_facet((const std::locale *)&v93, MEMORY[0x263F8C108]);
          int v36 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v45->__vftable[2].~facet_0)(v45, 32);
          std::locale::~locale((std::locale *)&v93);
          char v35 = v44;
          *((_DWORD *)v32 + 36) = v36;
          if (!v33) {
            goto LABEL_96;
          }
        }
        else if (!v33)
        {
          goto LABEL_96;
        }
        uint64_t v46 = *((void *)v32 + 3);
        BOOL v47 = v46 <= (uint64_t)v31;
        std::string::size_type v48 = v46 - (void)v31;
        if (v47) {
          std::string::size_type v49 = 0;
        }
        else {
          std::string::size_type v49 = v48;
        }
        int64_t v50 = (char *)v35 - (char *)v30;
        if ((char *)v35 - (char *)v30 >= 1)
        {
          int64_t v51 = v35;
          uint64_t v52 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v33 + 96))(v33, v30, v50);
          char v35 = v51;
          if (v52 != v50) {
            goto LABEL_96;
          }
        }
        goto LABEL_80;
      }
      goto LABEL_97;
    }
    *((void *)v27 + 3) = v85;
    *(_DWORD *)((char *)v84 + *(void *)(v26 - 24)) = *(_DWORD *)((unsigned char *)v84 + *(void *)(v26 - 24)) & 0xFFFFFEFB | 4;
    *(_DWORD *)((char *)v84 + *(void *)(v26 - 24)) |= 0x400u;
    uint64_t v37 = *(void *)(v26 - 24);
    char v38 = a1 + 2;
    uint64_t v39 = v82;
LABEL_52:
    *(void *)((char *)v38 + v37) = v39;
    std::ostream::operator<<();
    if (v24 == 24) {
      goto LABEL_128;
    }
LABEL_98:
    LOBYTE(v86) = 44;
    MEMORY[0x2166B95F0](&__b, a1);
    if (__b.__r_.__value_.__s.__data_[0])
    {
      uint64_t v65 = (char *)a1 + *(void *)(*a1 - 24);
      uint64_t v66 = *((void *)v65 + 5);
      if ((*((_DWORD *)v65 + 2) & 0xB0) == 0x20) {
        uint64_t v67 = (void **)((char *)&v86 + 1);
      }
      else {
        uint64_t v67 = &v86;
      }
      int v68 = *((_DWORD *)v65 + 36);
      if (v68 == -1)
      {
        std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
        uint64_t v69 = std::locale::use_facet((const std::locale *)&v93, MEMORY[0x263F8C108]);
        int v68 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v69->__vftable[2].~facet_0)(v69, 32);
        std::locale::~locale((std::locale *)&v93);
        *((_DWORD *)v65 + 36) = v68;
        if (!v66) {
          goto LABEL_32;
        }
      }
      else if (!v66)
      {
        goto LABEL_32;
      }
      uint64_t v70 = *((void *)v65 + 3);
      BOOL v47 = v70 <= 1;
      std::string::size_type v71 = v70 - 1;
      if (v47) {
        std::string::size_type v72 = 0;
      }
      else {
        std::string::size_type v72 = v71;
      }
      if ((char *)v67 - (char *)&v86 >= 1
        && (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v66 + 96))(v66, &v86, (char *)v67 - (char *)&v86) != (char *)v67 - (char *)&v86)
      {
        goto LABEL_32;
      }
      if ((uint64_t)v72 >= 1)
      {
        if (v72 > 0x7FFFFFFFFFFFFFF7) {
          goto LABEL_133;
        }
        if (v72 >= 0x17)
        {
          uint64_t v74 = (v72 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v72 | 7) != 0x17) {
            uint64_t v74 = v72 | 7;
          }
          uint64_t v75 = v74 + 1;
          uint64_t v73 = operator new(v74 + 1);
          v93.__r_.__value_.__l.__size_ = v72;
          v93.__r_.__value_.__r.__words[2] = v75 | 0x8000000000000000;
          v93.__r_.__value_.__r.__words[0] = (std::string::size_type)v73;
        }
        else
        {
          *((unsigned char *)&v93.__r_.__value_.__s + 23) = v72;
          uint64_t v73 = &v93;
        }
        memset(v73, v68, v72);
        *((unsigned char *)v73 + v72) = 0;
        if ((v93.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v76 = &v93;
        }
        else {
          uint64_t v76 = (std::string *)v93.__r_.__value_.__r.__words[0];
        }
        uint64_t v77 = (*(uint64_t (**)(uint64_t, std::string *, std::string::size_type))(*(void *)v66 + 96))(v66, v76, v72);
        uint64_t v78 = v77;
        if (SHIBYTE(v93.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v93.__r_.__value_.__l.__data_);
          if (v78 != v72) {
            goto LABEL_32;
          }
        }
        else if (v77 != v72)
        {
          goto LABEL_32;
        }
      }
      if ((char *)&v86 + 1 - (char *)v67 >= 1
        && (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v66 + 96))(v66, v67, (char *)&v86 + 1 - (char *)v67) != (char *)&v86 + 1 - (char *)v67)
      {
LABEL_32:
        std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
        goto LABEL_33;
      }
      *((void *)v65 + 3) = 0;
    }
LABEL_33:
    MEMORY[0x2166B9600](&__b);
    v24 += 8;
  }
  if (v25 != 0.0)
  {
    *((void *)v27 + 3) = v85;
    *(_DWORD *)((char *)v84 + *(void *)(v26 - 24)) |= 0x400u;
    uint64_t v37 = *(void *)(v26 - 24);
    char v38 = a1 + 2;
    uint64_t v39 = v83;
    goto LABEL_52;
  }
  char v40 = (char *)HIBYTE(v91);
  char v41 = (char *)__p[1];
  if (v91 >= 0) {
    char v42 = __p;
  }
  else {
    char v42 = (void **)__p[0];
  }
  MEMORY[0x2166B95F0](&__b, a1);
  if (__b.__r_.__value_.__s.__data_[0])
  {
    if ((char)v40 >= 0) {
      std::string v43 = v40;
    }
    else {
      std::string v43 = v41;
    }
    uint64_t v32 = (char *)a1 + *(void *)(*a1 - 24);
    uint64_t v33 = *((void *)v32 + 5);
    int v34 = &v43[(void)v42];
    if ((*((_DWORD *)v32 + 2) & 0xB0) == 0x20) {
      char v35 = (void **)&v43[(void)v42];
    }
    else {
      char v35 = v42;
    }
    int v36 = *((_DWORD *)v32 + 36);
    if (v36 != -1)
    {
      if (!v33) {
        goto LABEL_96;
      }
LABEL_75:
      uint64_t v55 = *((void *)v32 + 3);
      BOOL v47 = v55 <= (uint64_t)v43;
      std::string::size_type v56 = v55 - (void)v43;
      if (v47) {
        std::string::size_type v49 = 0;
      }
      else {
        std::string::size_type v49 = v56;
      }
      int64_t v57 = (char *)v35 - (char *)v42;
      if ((char *)v35 - (char *)v42 >= 1)
      {
        char v58 = v35;
        uint64_t v59 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v33 + 96))(v33, v42, v57);
        char v35 = v58;
        if (v59 != v57) {
          goto LABEL_96;
        }
      }
LABEL_80:
      if ((uint64_t)v49 < 1) {
        goto LABEL_94;
      }
      if (v49 > 0x7FFFFFFFFFFFFFF7) {
        goto LABEL_133;
      }
      uint64_t v81 = v35;
      if (v49 >= 0x17)
      {
        uint64_t v61 = (v49 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v49 | 7) != 0x17) {
          uint64_t v61 = v49 | 7;
        }
        uint64_t v62 = v61 + 1;
        char v60 = operator new(v61 + 1);
        v93.__r_.__value_.__l.__size_ = v49;
        v93.__r_.__value_.__r.__words[2] = v62 | 0x8000000000000000;
        v93.__r_.__value_.__r.__words[0] = (std::string::size_type)v60;
      }
      else
      {
        *((unsigned char *)&v93.__r_.__value_.__s + 23) = v49;
        char v60 = &v93;
      }
      memset(v60, v36, v49);
      *((unsigned char *)v60 + v49) = 0;
      if ((v93.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v63 = &v93;
      }
      else {
        std::string::size_type v63 = (std::string *)v93.__r_.__value_.__r.__words[0];
      }
      uint64_t v64 = (*(uint64_t (**)(uint64_t, std::string *, std::string::size_type))(*(void *)v33 + 96))(v33, v63, v49);
      if (SHIBYTE(v93.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v93.__r_.__value_.__l.__data_);
      }
      char v35 = v81;
      if (v64 == v49)
      {
LABEL_94:
        if (v34 - (char *)v35 < 1
          || (*(uint64_t (**)(uint64_t))(*(void *)v33 + 96))(v33) == v34 - (char *)v35)
        {
          *((void *)v32 + 3) = 0;
          goto LABEL_97;
        }
      }
      goto LABEL_96;
    }
    uint64_t v53 = v35;
    std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
    BOOL v54 = std::locale::use_facet((const std::locale *)&v93, MEMORY[0x263F8C108]);
    int v36 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v54->__vftable[2].~facet_0)(v54, 32);
    std::locale::~locale((std::locale *)&v93);
    char v35 = v53;
    *((_DWORD *)v32 + 36) = v36;
    if (v33) {
      goto LABEL_75;
    }
LABEL_96:
    std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
  }
LABEL_97:
  MEMORY[0x2166B9600](&__b);
  if (v24 != 24) {
    goto LABEL_98;
  }
LABEL_128:
  sub_2153C1168(a1, (uint64_t)"   ]", 4);
  *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 8) = v80;
  if (SHIBYTE(v91) < 0) {
    operator delete(__p[0]);
  }
  return a1;
}

uint64_t sub_215400674(double *a1, double *a2, double *a3)
{
  double v3 = a1[4];
  double v4 = a1[6];
  double v5 = *a2;
  double v6 = a2[1];
  if (v4 < 0.0000000149011612 || v3 < 0.0000000149011612 || a1[11] > v5 || a1[12] <= v5 || a1[13] > v6 || a1[14] <= v6) {
    return 0;
  }
  double v14 = (v5 - a1[8]) / (v3 * v4);
  double v15 = (v6 - a1[9]) / v3;
  double v16 = atan(sqrt(v14 * v14 + v15 * v15));
  double v17 = a1[17];
  if (v16 >= v17) {
    return 0;
  }
  double v18 = v16 / v17 * 255.0;
  unsigned int v19 = v18;
  if (v18 > 0xFE)
  {
    double v21 = a1[v19 + 276];
  }
  else
  {
    double v20 = a1[v19 + 276];
    double v21 = v20 + (v18 - (double)v19) * (a1[v19 + 277] - v20);
  }
  *a3 = v14 * v21;
  a3[1] = v15 * v21;
  return 1;
}

BOOL sub_215400774(double *a1, double *a2, double *a3)
{
  double v3 = a2[2];
  if (v3 <= 0.0) {
    return 0;
  }
  double v6 = a1[18];
  double v7 = a1[19];
  double v8 = *a2 - v6;
  double v9 = a2[1] - v7;
  double v10 = atan2(sqrt(v8 * v8 + v9 * v9), a2[2]);
  double v11 = a1[16];
  if (v10 >= v11) {
    return 0;
  }
  double v12 = v10 / v11 * 255.0;
  unsigned int v13 = v12;
  if (v12 > 0xFE)
  {
    double v15 = a1[v13 + 20];
  }
  else
  {
    double v14 = a1[v13 + 20];
    double v15 = v14 + (v12 - (double)v13) * (a1[v13 + 21] - v14);
  }
  double v17 = v15 / v3;
  double v18 = a1[4];
  double v19 = a1[8] + v18 * a1[6] * (v6 + v8 * v17);
  double v20 = a1[9] + v18 * (v7 + v9 * v17);
  *a3 = v19;
  a3[1] = v20;
  BOOL v21 = a1[11] <= v19;
  if (a1[12] <= v19) {
    BOOL v21 = 0;
  }
  if (a1[13] > v20) {
    BOOL v21 = 0;
  }
  return a1[14] > v20 && v21;
}

unsigned char *sub_21540089C(unsigned char *result, char a2)
{
  result[40] = a2;
  result[56] = a2;
  result[80] = a2;
  return result;
}

void sub_2154008AC()
{
}

uint64_t sub_215400984(uint64_t a1)
{
  return a1 + 88;
}

uint64_t sub_21540098C()
{
  return 3;
}

void sub_215400994()
{
}

uint64_t sub_2154009AC(std::string::size_type *a1, std::string *a2, uint64_t a3)
{
  cva::adp::io::PListSerializer::getPath(a1, a2, &v15);
  std::string::size_type v4 = v15;
  if (!v15)
  {
    double v10 = v16;
    if (!v16) {
      return 0;
    }
    goto LABEL_13;
  }
  if (*(char *)(a3 + 23) >= 0) {
    double v5 = (const char *)a3;
  }
  else {
    double v5 = *(const char **)a3;
  }
  CFStringRef v6 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v5, 0x8000100u, (CFAllocatorRef)*MEMORY[0x263EFFB28]);
  CFStringRef v7 = (const __CFString *)[*(id *)v4 objectForKey:v6];
  CFStringRef v8 = v7;
  char v9 = *(unsigned char *)(v4 + 8);
  CFTypeRef cf = v7;
  char v14 = v9;
  if (v7)
  {
    CFRetain(v7);
    CFRelease(v6);
    if (cva::ItemHandler::isVectorType(&cf)) {
      sub_2153FB048();
    }
    CFStringRef v11 = v8;
  }
  else
  {
    char v14 = 0;
    CFStringRef v11 = v6;
  }
  CFRelease(v11);
  double v10 = v16;
  if (v16)
  {
LABEL_13:
    if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  return 0;
}

void sub_215400B74(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_215400B88(std::string::size_type *a1, std::string *a2, uint64_t a3)
{
  cva::adp::io::PListSerializer::getPath(a1, a2, &v15);
  std::string::size_type v4 = v15;
  if (v15)
  {
    if (*(char *)(a3 + 23) >= 0) {
      double v5 = (const char *)a3;
    }
    else {
      double v5 = *(const char **)a3;
    }
    CFStringRef v6 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v5, 0x8000100u, (CFAllocatorRef)*MEMORY[0x263EFFB28]);
    CFStringRef v7 = (const __CFString *)[*(id *)v4 objectForKey:v6];
    CFStringRef v8 = v7;
    char v9 = *(unsigned char *)(v4 + 8);
    CFTypeRef cf = v7;
    char v14 = v9;
    if (v7)
    {
      CFRetain(v7);
      CFRelease(v6);
      if (cva::ItemHandler::isVectorType(&cf)) {
        sub_2153FB048();
      }
      CFStringRef v10 = v8;
    }
    else
    {
      char v14 = 0;
      CFStringRef v10 = v6;
    }
    CFRelease(v10);
  }
  CFStringRef v11 = v16;
  if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  return 0;
}

void sub_215400D04(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

BOOL sub_215400D18(uint64_t a1, uint64_t a2, double a3)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a2 + 16))(a2) != 2) {
    return 0;
  }
  if (*(double *)(a1 + 32) - *(double *)(a2 + 32) >= a3) {
    return 0;
  }
  if (*(double *)(a1 + 48) - *(double *)(a2 + 48) >= a3) {
    return 0;
  }
  float64x2_t v6 = vsubq_f64(*(float64x2_t *)(a1 + 64), *(float64x2_t *)(a2 + 64));
  if (sqrt(vaddvq_f64(vmulq_f64(v6, v6))) >= a3) {
    return 0;
  }
  if (*(unsigned __int8 *)(a1 + 80) != *(unsigned __int8 *)(a2 + 80)) {
    return 0;
  }
  float64x2_t v7 = vsubq_f64(*(float64x2_t *)(a1 + 88), *(float64x2_t *)(a2 + 88));
  float64x2_t v8 = vmulq_f64(v7, v7);
  float64x2_t v9 = vsubq_f64(*(float64x2_t *)(a1 + 104), *(float64x2_t *)(a2 + 104));
  float64x2_t v10 = vmulq_f64(v9, v9);
  if (sqrt(vaddq_f64(vaddq_f64(vaddq_f64(v8, (float64x2_t)vdupq_laneq_s64((int64x2_t)v8, 1)), v10), (float64x2_t)vdupq_laneq_s64((int64x2_t)v10, 1)).f64[0]) >= a3)return 0; {
  if (*(_DWORD *)(a1 + 120) == *(_DWORD *)(a2 + 120)
  }
    && *(_DWORD *)(a1 + 124) == *(_DWORD *)(a2 + 124)
    && (double v11 = *(double *)(a1 + 144) - *(double *)(a2 + 144),
        float64x2_t v12 = vsubq_f64(*(float64x2_t *)(a1 + 128), *(float64x2_t *)(a2 + 128)),
        double v13 = vaddvq_f64(vmulq_f64(v12, v12)) + v11 * v11,
        float64x2_t v14 = vsubq_f64(*(float64x2_t *)(a1 + 152), *(float64x2_t *)(a2 + 152)),
        float64x2_t v15 = vmulq_f64(v14, v14),
        sqrt(v13 + v15.f64[0] + v15.f64[1]) < a3))
  {
    return *(unsigned __int8 *)(a1 + 168) == *(unsigned __int8 *)(a2 + 168);
  }
  else
  {
    return 0;
  }
}

uint64_t *sub_215400E98(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = a1 + 32;
  sub_2153FF828((__n128 *)(a1 + 88), a2);
  sub_2153FF8CC(v4, a2);
  sub_2153FF9FC(a1 + 48, a2);
  sub_2153FFB2C((__n128 *)(a1 + 64), a2);
  if (*(unsigned char *)(a1 + 168)) {
    double v5 = "[FREE]";
  }
  else {
    double v5 = "[FIXED]";
  }
  if (*(unsigned char *)(a1 + 168)) {
    size_t v6 = 6;
  }
  else {
    size_t v6 = 7;
  }
  unsigned __int8 v113 = v6;
  memcpy(__dst, v5, v6);
  *(unsigned char *)((unint64_t)__dst | v6) = 0;
  if ((v113 & 0x80u) == 0) {
    float64x2_t v7 = __dst;
  }
  else {
    float64x2_t v7 = (void **)__dst[0];
  }
  if ((v113 & 0x80u) == 0) {
    uint64_t v8 = v113;
  }
  else {
    uint64_t v8 = (uint64_t)__dst[1];
  }
  float64x2_t v9 = sub_2153C1168(a2, (uint64_t)v7, v8);
  sub_2153C1168(v9, (uint64_t)"[", 1);
  float64x2_t v10 = (char *)operator new(0x28uLL);
  strcpy(v10, "Heikkila Distortion Coefficients");
  double v11 = sub_2153C1168(a2, (uint64_t)v10, 32);
  sub_2153C1168(v11, (uint64_t)"] : ", 4);
  long long v12 = *(_OWORD *)(a1 + 144);
  v120[0] = *(_OWORD *)(a1 + 128);
  v120[1] = v12;
  uint64_t v121 = *(void *)(a1 + 160);
  double v13 = (char *)a2 + *(void *)(*a2 - 24);
  int v14 = *((_DWORD *)v13 + 2);
  size_t v16 = *((void *)v13 + 2);
  int64_t v15 = *((void *)v13 + 3);
  if (v15)
  {
    if (v15 <= (uint64_t)(v16 + 2)) {
      int64_t v15 = v16 + 2;
    }
    size_t v17 = v15 + ~v16;
    double v18 = __exp10((double)-(uint64_t)v16);
    size_t v19 = v17 - 1;
    if (v17 - 1 > 0x7FFFFFFFFFFFFFF7) {
LABEL_161:
    }
      abort();
    double v20 = v18;
    if (v19 >= 0x17)
    {
      uint64_t v22 = (v19 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v19 | 7) != 0x17) {
        uint64_t v22 = v19 | 7;
      }
      uint64_t v23 = v22 + 1;
      p_b = (std::string *)operator new(v22 + 1);
      __b.__r_.__value_.__l.__size_ = v17 - 1;
      __b.__r_.__value_.__r.__words[2] = v23 | 0x8000000000000000;
      __b.__r_.__value_.__r.__words[0] = (std::string::size_type)p_b;
    }
    else
    {
      *((unsigned char *)&__b.__r_.__value_.__s + 23) = v17 - 1;
      p_b = &__b;
      if (v17 == 1)
      {
        LODWORD(v17) = 1;
        goto LABEL_25;
      }
    }
  }
  else
  {
    double v20 = __exp10((double)-(uint64_t)v16);
    size_t v19 = 3;
    *((unsigned char *)&__b.__r_.__value_.__s + 23) = 3;
    p_b = &__b;
    LODWORD(v17) = 4;
  }
  memset(p_b, 32, v19);
LABEL_25:
  p_b->__r_.__value_.__s.__data_[v19] = 0;
  uint64_t v24 = std::string::append(&__b, "0 ");
  std::string::size_type v25 = v24->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v122.__r_.__value_.__l.__data_ = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
  v122.__r_.__value_.__r.__words[2] = v25;
  v24->__r_.__value_.__l.__size_ = 0;
  v24->__r_.__value_.__r.__words[2] = 0;
  v24->__r_.__value_.__r.__words[0] = 0;
  if (v16 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_161;
  }
  if (v16 >= 0x17)
  {
    uint64_t v27 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v16 | 7) != 0x17) {
      uint64_t v27 = v16 | 7;
    }
    uint64_t v28 = v27 + 1;
    uint64_t v26 = operator new(v27 + 1);
    std::string::size_type v115 = v16;
    int64_t v116 = v28 | 0x8000000000000000;
    v114 = v26;
    goto LABEL_32;
  }
  HIBYTE(v116) = v16;
  uint64_t v26 = &v114;
  if (v16) {
LABEL_32:
  }
    memset(v26, 32, v16);
  *((unsigned char *)v26 + v16) = 0;
  if (v116 >= 0) {
    float64x2_t v29 = (const std::string::value_type *)&v114;
  }
  else {
    float64x2_t v29 = (const std::string::value_type *)v114;
  }
  if (v116 >= 0) {
    std::string::size_type v30 = HIBYTE(v116);
  }
  else {
    std::string::size_type v30 = v115;
  }
  float64x2_t v31 = std::string::append(&v122, v29, v30);
  std::string::size_type v32 = v31->__r_.__value_.__r.__words[2];
  *(_OWORD *)long long __p = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
  uint64_t v119 = v32;
  v31->__r_.__value_.__l.__size_ = 0;
  v31->__r_.__value_.__r.__words[2] = 0;
  v31->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v116) < 0)
  {
    operator delete(v114);
    if ((SHIBYTE(v122.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_41;
    }
LABEL_160:
    operator delete(v122.__r_.__value_.__l.__data_);
    goto LABEL_41;
  }
  if (SHIBYTE(v122.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_160;
  }
LABEL_41:
  int v104 = v14;
  std::string v105 = v10;
  if (SHIBYTE(__b.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__b.__r_.__value_.__l.__data_);
  }
  v110 = a2 + 1;
  *(uint64_t *)((char *)a2 + *(void *)(*a2 - 24) + 24) = 0;
  v122.__r_.__value_.__s.__data_[0] = 91;
  sub_2153C1168(a2, (uint64_t)&v122, 1);
  uint64_t v33 = 0;
  uint64_t v111 = (int)v17 + (int)v16 + 1;
  uint64_t v108 = (int)v16;
  uint64_t v109 = (int)v16 - 3;
  while (1)
  {
    double v34 = *(double *)((char *)v120 + v33);
    uint64_t v35 = *a2;
    int v36 = (char *)a2 + *(void *)(*a2 - 24);
    if (v36[9]) {
      break;
    }
    if (fabs(v34) < v20)
    {
      uint64_t v37 = (char *)HIBYTE(v119);
      char v38 = (char *)__p[1];
      if (v119 >= 0) {
        uint64_t v39 = __p;
      }
      else {
        uint64_t v39 = (void **)__p[0];
      }
      MEMORY[0x2166B95F0](&__b, a2);
      if (__b.__r_.__value_.__s.__data_[0])
      {
        if ((char)v37 >= 0) {
          char v40 = v37;
        }
        else {
          char v40 = v38;
        }
        char v41 = (char *)a2 + *(void *)(*a2 - 24);
        uint64_t v42 = *((void *)v41 + 5);
        std::string v43 = &v40[(void)v39];
        if ((*((_DWORD *)v41 + 2) & 0xB0) == 0x20) {
          uint64_t v44 = (void **)&v40[(void)v39];
        }
        else {
          uint64_t v44 = v39;
        }
        int v45 = *((_DWORD *)v41 + 36);
        if (v45 == -1)
        {
          std::string::size_type v56 = v44;
          std::ios_base::getloc((const std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)));
          int64_t v57 = std::locale::use_facet((const std::locale *)&v122, MEMORY[0x263F8C108]);
          int v45 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v57->__vftable[2].~facet_0)(v57, 32);
          std::locale::~locale((std::locale *)&v122);
          uint64_t v44 = v56;
          *((_DWORD *)v41 + 36) = v45;
          if (!v42) {
            goto LABEL_122;
          }
        }
        else if (!v42)
        {
          goto LABEL_122;
        }
        uint64_t v58 = *((void *)v41 + 3);
        BOOL v59 = v58 <= (uint64_t)v40;
        std::string::size_type v60 = v58 - (void)v40;
        if (v59) {
          std::string::size_type v61 = 0;
        }
        else {
          std::string::size_type v61 = v60;
        }
        int64_t v62 = (char *)v44 - (char *)v39;
        if ((char *)v44 - (char *)v39 < 1
          || (std::string::size_type v63 = v44,
              uint64_t v64 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v42 + 96))(v42, v39, v62),
              uint64_t v44 = v63,
              v64 == v62))
        {
          if ((uint64_t)v61 < 1) {
            goto LABEL_108;
          }
          if (v61 > 0x7FFFFFFFFFFFFFF7) {
            goto LABEL_161;
          }
          long long v106 = v44;
          if (v61 >= 0x17)
          {
            uint64_t v80 = (v61 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v61 | 7) != 0x17) {
              uint64_t v80 = v61 | 7;
            }
            uint64_t v81 = v80 + 1;
            uint64_t v65 = operator new(v80 + 1);
            v122.__r_.__value_.__l.__size_ = v61;
            v122.__r_.__value_.__r.__words[2] = v81 | 0x8000000000000000;
            v122.__r_.__value_.__r.__words[0] = (std::string::size_type)v65;
          }
          else
          {
            *((unsigned char *)&v122.__r_.__value_.__s + 23) = v61;
            uint64_t v65 = &v122;
          }
          memset(v65, v45, v61);
          *((unsigned char *)v65 + v61) = 0;
          if ((v122.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v82 = &v122;
          }
          else {
            uint64_t v82 = (std::string *)v122.__r_.__value_.__r.__words[0];
          }
          uint64_t v83 = (*(uint64_t (**)(uint64_t, std::string *, std::string::size_type))(*(void *)v42 + 96))(v42, v82, v61);
          if (SHIBYTE(v122.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v122.__r_.__value_.__l.__data_);
          }
          uint64_t v44 = v106;
          if (v83 == v61)
          {
LABEL_108:
            uint64_t v84 = v43 - (char *)v44;
            if (v43 - (char *)v44 >= 1)
            {
LABEL_120:
              if ((*(uint64_t (**)(uint64_t))(*(void *)v42 + 96))(v42) != v84) {
                goto LABEL_122;
              }
            }
LABEL_121:
            *((void *)v41 + 3) = 0;
            goto LABEL_123;
          }
        }
LABEL_122:
        std::ios_base::clear((std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)), *(_DWORD *)((char *)a2 + *(void *)(*a2 - 24) + 32) | 5);
        goto LABEL_123;
      }
      goto LABEL_123;
    }
    *((void *)v36 + 3) = v111;
    *(_DWORD *)((char *)v110 + *(void *)(v35 - 24)) = *(_DWORD *)((unsigned char *)v110 + *(void *)(v35 - 24)) & 0xFFFFFEFB | 4;
    *(_DWORD *)((char *)v110 + *(void *)(v35 - 24)) |= 0x400u;
    uint64_t v46 = *(void *)(v35 - 24);
    BOOL v47 = a2 + 2;
    uint64_t v48 = v108;
LABEL_64:
    *(void *)((char *)v47 + v46) = v48;
    std::ostream::operator<<();
    if (v33 == 32) {
      goto LABEL_154;
    }
LABEL_124:
    LOBYTE(v114) = 44;
    MEMORY[0x2166B95F0](&__b, a2);
    if (__b.__r_.__value_.__s.__data_[0])
    {
      uint64_t v89 = (char *)a2 + *(void *)(*a2 - 24);
      uint64_t v90 = *((void *)v89 + 5);
      if ((*((_DWORD *)v89 + 2) & 0xB0) == 0x20) {
        uint64_t v91 = (void **)((char *)&v114 + 1);
      }
      else {
        uint64_t v91 = &v114;
      }
      int v92 = *((_DWORD *)v89 + 36);
      if (v92 == -1)
      {
        std::ios_base::getloc((const std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)));
        std::string v93 = std::locale::use_facet((const std::locale *)&v122, MEMORY[0x263F8C108]);
        int v92 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v93->__vftable[2].~facet_0)(v93, 32);
        std::locale::~locale((std::locale *)&v122);
        *((_DWORD *)v89 + 36) = v92;
        if (!v90) {
          goto LABEL_44;
        }
      }
      else if (!v90)
      {
        goto LABEL_44;
      }
      uint64_t v94 = *((void *)v89 + 3);
      BOOL v59 = v94 <= 1;
      std::string::size_type v95 = v94 - 1;
      if (v59) {
        std::string::size_type v96 = 0;
      }
      else {
        std::string::size_type v96 = v95;
      }
      if ((char *)v91 - (char *)&v114 >= 1
        && (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v90 + 96))(v90, &v114, (char *)v91 - (char *)&v114) != (char *)v91 - (char *)&v114)
      {
        goto LABEL_44;
      }
      if ((uint64_t)v96 >= 1)
      {
        if (v96 > 0x7FFFFFFFFFFFFFF7) {
          goto LABEL_161;
        }
        if (v96 >= 0x17)
        {
          uint64_t v98 = (v96 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v96 | 7) != 0x17) {
            uint64_t v98 = v96 | 7;
          }
          uint64_t v99 = v98 + 1;
          std::string::size_type v97 = operator new(v98 + 1);
          v122.__r_.__value_.__l.__size_ = v96;
          v122.__r_.__value_.__r.__words[2] = v99 | 0x8000000000000000;
          v122.__r_.__value_.__r.__words[0] = (std::string::size_type)v97;
        }
        else
        {
          *((unsigned char *)&v122.__r_.__value_.__s + 23) = v96;
          std::string::size_type v97 = &v122;
        }
        memset(v97, v92, v96);
        *((unsigned char *)v97 + v96) = 0;
        if ((v122.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v100 = &v122;
        }
        else {
          uint64_t v100 = (std::string *)v122.__r_.__value_.__r.__words[0];
        }
        uint64_t v101 = (*(uint64_t (**)(uint64_t, std::string *, std::string::size_type))(*(void *)v90 + 96))(v90, v100, v96);
        uint64_t v102 = v101;
        if (SHIBYTE(v122.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v122.__r_.__value_.__l.__data_);
          if (v102 != v96) {
            goto LABEL_44;
          }
        }
        else if (v101 != v96)
        {
          goto LABEL_44;
        }
      }
      if ((char *)&v114 + 1 - (char *)v91 >= 1
        && (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v90 + 96))(v90, v91, (char *)&v114 + 1 - (char *)v91) != (char *)&v114 + 1 - (char *)v91)
      {
LABEL_44:
        std::ios_base::clear((std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)), *(_DWORD *)((char *)a2 + *(void *)(*a2 - 24) + 32) | 5);
        goto LABEL_45;
      }
      *((void *)v89 + 3) = 0;
    }
LABEL_45:
    MEMORY[0x2166B9600](&__b);
    v33 += 8;
  }
  if (v34 != 0.0)
  {
    *((void *)v36 + 3) = v111;
    *(_DWORD *)((char *)v110 + *(void *)(v35 - 24)) |= 0x400u;
    uint64_t v46 = *(void *)(v35 - 24);
    BOOL v47 = a2 + 2;
    uint64_t v48 = v109;
    goto LABEL_64;
  }
  std::string::size_type v49 = (char *)HIBYTE(v119);
  int64_t v50 = (char *)__p[1];
  if (v119 >= 0) {
    int64_t v51 = __p;
  }
  else {
    int64_t v51 = (void **)__p[0];
  }
  MEMORY[0x2166B95F0](&__b, a2);
  if (__b.__r_.__value_.__s.__data_[0])
  {
    if ((char)v49 >= 0) {
      uint64_t v52 = v49;
    }
    else {
      uint64_t v52 = v50;
    }
    char v41 = (char *)a2 + *(void *)(*a2 - 24);
    uint64_t v42 = *((void *)v41 + 5);
    uint64_t v53 = &v52[(void)v51];
    if ((*((_DWORD *)v41 + 2) & 0xB0) == 0x20) {
      BOOL v54 = (void **)&v52[(void)v51];
    }
    else {
      BOOL v54 = v51;
    }
    int v55 = *((_DWORD *)v41 + 36);
    if (v55 == -1)
    {
      uint64_t v66 = v54;
      std::ios_base::getloc((const std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)));
      uint64_t v67 = std::locale::use_facet((const std::locale *)&v122, MEMORY[0x263F8C108]);
      int v55 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v67->__vftable[2].~facet_0)(v67, 32);
      std::locale::~locale((std::locale *)&v122);
      BOOL v54 = v66;
      *((_DWORD *)v41 + 36) = v55;
      if (!v42) {
        goto LABEL_122;
      }
    }
    else if (!v42)
    {
      goto LABEL_122;
    }
    uint64_t v68 = *((void *)v41 + 3);
    BOOL v59 = v68 <= (uint64_t)v52;
    std::string::size_type v69 = v68 - (void)v52;
    if (v59) {
      std::string::size_type v70 = 0;
    }
    else {
      std::string::size_type v70 = v69;
    }
    int64_t v71 = (char *)v54 - (char *)v51;
    if ((char *)v54 - (char *)v51 < 1) {
      goto LABEL_164;
    }
    std::string::size_type v72 = *(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v42 + 96);
    uint64_t v73 = v42;
    uint64_t v74 = v42;
    std::string::size_type v75 = v70;
    uint64_t v76 = v53;
    uint64_t v77 = v54;
    uint64_t v78 = v72(v73, v51, v71);
    BOOL v54 = v77;
    uint64_t v53 = v76;
    std::string::size_type v70 = v75;
    uint64_t v42 = v74;
    if (v78 == v71)
    {
LABEL_164:
      if ((uint64_t)v70 < 1) {
        goto LABEL_119;
      }
      if (v70 > 0x7FFFFFFFFFFFFFF7) {
        goto LABEL_161;
      }
      v107 = v54;
      if (v70 >= 0x17)
      {
        uint64_t v85 = (v70 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v70 | 7) != 0x17) {
          uint64_t v85 = v70 | 7;
        }
        uint64_t v86 = v85 + 1;
        std::string::size_type v79 = operator new(v85 + 1);
        v122.__r_.__value_.__l.__size_ = v70;
        v122.__r_.__value_.__r.__words[2] = v86 | 0x8000000000000000;
        v122.__r_.__value_.__r.__words[0] = (std::string::size_type)v79;
      }
      else
      {
        *((unsigned char *)&v122.__r_.__value_.__s + 23) = v70;
        std::string::size_type v79 = &v122;
      }
      memset(v79, v55, v70);
      *((unsigned char *)v79 + v70) = 0;
      if ((v122.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v87 = &v122;
      }
      else {
        std::string::size_type v87 = (std::string *)v122.__r_.__value_.__r.__words[0];
      }
      uint64_t v88 = (*(uint64_t (**)(uint64_t, std::string *, std::string::size_type))(*(void *)v42 + 96))(v42, v87, v70);
      if (SHIBYTE(v122.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v122.__r_.__value_.__l.__data_);
      }
      BOOL v54 = v107;
      if (v88 == v70)
      {
LABEL_119:
        uint64_t v84 = v53 - (char *)v54;
        if (v53 - (char *)v54 >= 1) {
          goto LABEL_120;
        }
        goto LABEL_121;
      }
    }
    goto LABEL_122;
  }
LABEL_123:
  MEMORY[0x2166B9600](&__b);
  if (v33 != 32) {
    goto LABEL_124;
  }
LABEL_154:
  sub_2153C1168(a2, (uint64_t)"   ]", 4);
  *(_DWORD *)((char *)a2 + *(void *)(*a2 - 24) + 8) = v104;
  if (SHIBYTE(v119) < 0) {
    operator delete(__p[0]);
  }
  sub_2153C1168(a2, (uint64_t)"\n", 1);
  operator delete(v105);
  if ((char)v113 < 0) {
    operator delete(__dst[0]);
  }
  return a2;
}

uint64_t sub_215401AC4(uint64_t a1, double *a2, double *a3)
{
  double v3 = *(double *)(a1 + 32);
  double v4 = *(double *)(a1 + 48);
  double v5 = *a2;
  double v6 = a2[1];
  if (v4 < 0.0000000149011612
    || v3 < 0.0000000149011612
    || *(double *)(a1 + 88) > v5
    || *(double *)(a1 + 96) <= v5
    || *(double *)(a1 + 104) > v6
    || *(double *)(a1 + 112) <= v6)
  {
    return 0;
  }
  double v12 = (v5 - *(double *)(a1 + 64)) / (v3 * v4);
  double v13 = (v6 - *(double *)(a1 + 72)) / v3;
  unint64_t v14 = *(unsigned int *)(a1 + 176);
  double v15 = *(double *)(a1 + 128);
  double v16 = *(double *)(a1 + 136);
  double v17 = *(double *)(a1 + 144);
  double v18 = *(double *)(a1 + 152);
  double v19 = *(double *)(a1 + 160);
  *a3 = v12;
  a3[1] = v13;
  if (!v14) {
    return 1;
  }
  BOOL v20 = 0;
  uint64_t v21 = 0;
  double v22 = v12;
  double v23 = v13;
  do
  {
    double v24 = v23 * v23;
    double v25 = v22 * v22 + v23 * v23;
    double v26 = v15 * v25 + 1.0 + v16 * (v25 * v25) + v19 * (v25 * (v25 * v25));
    if (v26 == 0.0) {
      break;
    }
    double v27 = v22 * v23;
    double v22 = (v12 - (v18 * (v25 + v22 * v22 * 2.0) + (v17 + v17) * v27)) / v26;
    double v23 = (v13 - ((v18 + v18) * v27 + v17 * (v25 + v24 * 2.0))) / v26;
    *a3 = v22;
    a3[1] = v23;
    BOOL v20 = ++v21 >= v14;
  }
  while (v14 != v21);
  return v20;
}

BOOL sub_215401BD4(double *a1, double *a2, double *a3)
{
  double v3 = a2[2];
  if (v3 < 0.001) {
    return 0;
  }
  double v4 = 1.0 / v3;
  double v5 = v4 * *a2;
  double v6 = v4 * a2[1];
  double v7 = a1[18];
  double v8 = a1[19];
  double v9 = v5 * v5 + v6 * v6;
  double v10 = v9 * v9 * a1[17] + a1[16] * v9 + a1[20] * (v9 * (v9 * v9)) + 1.0;
  double v11 = v5 * v8 + v5 * v8;
  double v12 = v5 * v5 + v6 * v6 * 3.0;
  double v13 = v6 * (v5 * (v7 + v7)) + v8 * (v6 * v6 + v5 * v5 * 3.0) + v10 * v5;
  double v14 = v6 * v11 + v7 * v12 + v10 * v6;
  double v15 = a1[4];
  double v16 = a1[8] + v15 * a1[6] * v13;
  double v17 = a1[9] + v15 * v14;
  *a3 = v16;
  a3[1] = v17;
  BOOL v18 = a1[11] <= v16;
  if (a1[12] <= v16) {
    BOOL v18 = 0;
  }
  if (a1[13] > v17) {
    BOOL v18 = 0;
  }
  return a1[14] > v17 && v18;
}

unsigned char *sub_215401CB0(unsigned char *result, char a2)
{
  result[40] = a2;
  result[56] = a2;
  result[80] = a2;
  result[168] = a2;
  return result;
}

void sub_215401CC4()
{
}

uint64_t sub_215401D88(uint64_t a1)
{
  return a1 + 88;
}

uint64_t sub_215401D90()
{
  return 2;
}

void sub_215401D98()
{
}

BOOL sub_215401DB0(uint64_t a1, uint64_t a2, double a3)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a2 + 16))(a2) != 1) {
    return 0;
  }
  if (*(double *)(a1 + 32) - *(double *)(a2 + 32) >= a3) {
    return 0;
  }
  if (*(double *)(a1 + 48) - *(double *)(a2 + 48) >= a3) {
    return 0;
  }
  float64x2_t v6 = vsubq_f64(*(float64x2_t *)(a1 + 64), *(float64x2_t *)(a2 + 64));
  if (sqrt(vaddvq_f64(vmulq_f64(v6, v6))) >= a3) {
    return 0;
  }
  if (*(unsigned __int8 *)(a1 + 80) != *(unsigned __int8 *)(a2 + 80)) {
    return 0;
  }
  float64x2_t v7 = vsubq_f64(*(float64x2_t *)(a1 + 88), *(float64x2_t *)(a2 + 88));
  float64x2_t v8 = vmulq_f64(v7, v7);
  float64x2_t v9 = vsubq_f64(*(float64x2_t *)(a1 + 104), *(float64x2_t *)(a2 + 104));
  float64x2_t v10 = vmulq_f64(v9, v9);
  if (sqrt(vaddq_f64(vaddq_f64(vaddq_f64(v8, (float64x2_t)vdupq_laneq_s64((int64x2_t)v8, 1)), v10), (float64x2_t)vdupq_laneq_s64((int64x2_t)v10, 1)).f64[0]) >= a3)return 0; {
  if (*(_DWORD *)(a1 + 120) == *(_DWORD *)(a2 + 120)
  }
    && *(_DWORD *)(a1 + 124) == *(_DWORD *)(a2 + 124)
    && (float64x2_t v11 = vsubq_f64(*(float64x2_t *)(a1 + 128), *(float64x2_t *)(a2 + 128)),
        float64x2_t v12 = vmulq_f64(v11, v11),
        float64x2_t v13 = vsubq_f64(*(float64x2_t *)(a1 + 144), *(float64x2_t *)(a2 + 144)),
        float64x2_t v14 = vmulq_f64(v13, v13),
        sqrt(vaddq_f64(vaddq_f64(vaddq_f64(v12, (float64x2_t)vdupq_laneq_s64((int64x2_t)v12, 1)), v14), (float64x2_t)vdupq_laneq_s64((int64x2_t)v14, 1)).f64[0]) < a3)&& *(unsigned __int8 *)(a1 + 160) == *(unsigned __int8 *)(a2 + 160)&& *(double *)(a1 + 168) - *(double *)(a2 + 168) < a3)
  {
    return *(_DWORD *)(a1 + 176) == *(_DWORD *)(a2 + 176);
  }
  else
  {
    return 0;
  }
}

void *sub_215401F3C(uint64_t a1, void *a2)
{
  uint64_t v4 = a1 + 32;
  sub_2153FF828((__n128 *)(a1 + 88), a2);
  sub_2153FF8CC(v4, a2);
  sub_2153FF9FC(a1 + 48, a2);
  sub_2153FFB2C((__n128 *)(a1 + 64), a2);
  if (*(unsigned char *)(a1 + 160)) {
    double v5 = "[FREE]";
  }
  else {
    double v5 = "[FIXED]";
  }
  if (*(unsigned char *)(a1 + 160)) {
    size_t v6 = 6;
  }
  else {
    size_t v6 = 7;
  }
  char v19 = v6;
  memcpy(&__dst, v5, v6);
  *(unsigned char *)((unint64_t)&__dst | v6) = 0;
  if (v19 >= 0) {
    p_dst = &__dst;
  }
  else {
    p_dst = (long long *)__dst;
  }
  if (v19 >= 0) {
    uint64_t v8 = v19;
  }
  else {
    uint64_t v8 = *((void *)&__dst + 1);
  }
  float64x2_t v9 = sub_2153C1168(a2, (uint64_t)p_dst, v8);
  sub_2153C1168(v9, (uint64_t)"[", 1);
  float64x2_t v10 = (char *)operator new(0x28uLL);
  strcpy(v10, "Kannala-4 Distortion Coefficients");
  float64x2_t v11 = sub_2153C1168(a2, (uint64_t)v10, 33);
  float64x2_t v12 = sub_2153C1168(v11, (uint64_t)"] : ", 4);
  float64x2_t v13 = sub_2153FFC58(v12, *(__n128 *)(a1 + 128), *(__n128 *)(a1 + 144));
  sub_2153C1168(v13, (uint64_t)"\n", 1);
  operator delete(v10);
  if (v19 < 0) {
    operator delete((void *)__dst);
  }
  float64x2_t v14 = sub_2153C1168(a2, (uint64_t)"[FIXED][", 8);
  char v19 = 13;
  strcpy((char *)&__dst, "Field of View");
  double v15 = sub_2153C1168(v14, (uint64_t)&__dst, 13);
  sub_2153C1168(v15, (uint64_t)"] : ", 4);
  double v16 = (void *)std::ostream::operator<<();
  sub_2153C1168(v16, (uint64_t)"\n", 1);
  if (v19 < 0) {
    operator delete((void *)__dst);
  }
  return a2;
}

uint64_t sub_215402104(uint64_t a1, double *a2, double *a3, __n128 a4)
{
  double v4 = *(double *)(a1 + 32);
  double v5 = *(double *)(a1 + 48);
  double v6 = *a2;
  double v7 = a2[1];
  if (v5 < 0.0000000149011612
    || v4 < 0.0000000149011612
    || *(double *)(a1 + 88) > v6
    || *(double *)(a1 + 96) <= v6
    || *(double *)(a1 + 104) > v7
    || *(double *)(a1 + 112) <= v7)
  {
    return 0;
  }
  double v14 = (v6 - *(double *)(a1 + 64)) / (v4 * v5);
  double v15 = (v7 - *(double *)(a1 + 72)) / v4;
  double v16 = sqrt(v15 * v15 + v14 * v14);
  if (v16 < 0.0000000149011612)
  {
    *a3 = v14;
    a3[1] = v15;
    return 1;
  }
  if (v16 > 1.79769313e308) {
    return 0;
  }
  double v38 = v14;
  double v39 = (v7 - *(double *)(a1 + 72)) / v4;
  int v18 = *(_DWORD *)(a1 + 180);
  a4.n128_f64[0] = *(double *)(a1 + 168) * 0.9;
  if (a4.n128_f64[0] > 1.0) {
    a4.n128_f64[0] = 1.0;
  }
  if (v18)
  {
    int v19 = *(_DWORD *)(a1 + 176);
    _D15 = *(double *)(a1 + 136);
    double v21 = *(double *)(a1 + 144);
    _D11 = *(double *)(a1 + 152);
    double v40 = *(double *)(a1 + 128) * 3.0;
    int v23 = v18 - 1;
    while (1)
    {
      double v24 = a4.n128_f64[0] * a4.n128_f64[0];
      v25.f64[0] = a4.n128_f64[0] * a4.n128_f64[0];
      v25.f64[1] = v24 * v24;
      _Q2 = vmulq_n_f64(v25, a4.n128_f64[0]);
      double v44 = v24 * v24;
      double v45 = a4.n128_f64[0] * a4.n128_f64[0];
      v25.f64[0] = v24 * (v24 * v24);
      double v42 = a4.n128_f64[0] * a4.n128_f64[0] * v25.f64[0];
      double v43 = v25.f64[0];
      v25.f64[1] = v42;
      _Q1 = vmulq_n_f64(v25, a4.n128_f64[0]);
      __n128 v41 = a4;
      __asm
      {
        FMLA            D9, D15, V2.D[1]
        FMLA            D9, D11, V1.D[1]
      }
      double v32 = cos(_D9);
      if (v19 == 2)
      {
        double v33 = tan(_D9);
        double v32 = 1.0 / (v32 * v32);
      }
      else if (v19 == 1)
      {
        double v33 = sin(_D9);
      }
      else
      {
        double v32 = 0.0;
        double v33 = 0.0;
        if (!v19)
        {
          double v32 = 1.0;
          double v33 = _D9;
        }
      }
      double v34 = (v40 * v45 + 1.0 + _D15 * 5.0 * v44 + v21 * 7.0 * v43 + _D11 * 9.0 * v42) * v32;
      if (v34 == 0.0) {
        return 0;
      }
      double v35 = (v33 - v16) / v34;
      a4.n128_u64[1] = v41.n128_u64[1];
      a4.n128_f64[0] = v41.n128_f64[0] - v35;
      if (fabs(v35) < 2.22044605e-15 || v23-- == 0) {
        goto LABEL_42;
      }
    }
  }
  double v35 = 1.79769313e308;
LABEL_42:
  uint64_t result = 0;
  if (fabs(v35) <= 0.001 && a4.n128_f64[0] >= 0.0 && a4.n128_f64[0] <= 1.57079633)
  {
    long double v37 = tan(a4.n128_f64[0]);
    *a3 = v37 * v38 / v16;
    a3[1] = v37 * v39 / v16;
    return 1;
  }
  return result;
}

BOOL sub_215402398(uint64_t a1, double *a2, double *a3)
{
  long double v3 = a2[2];
  if (v3 < 0.0000000149011612) {
    return 0;
  }
  double v6 = *a2;
  double v7 = a2[1];
  double v8 = v7 * v7 + v6 * v6;
  if (v8 >= 0.0000000149011612)
  {
    int v10 = *(_DWORD *)(a1 + 176);
    double v11 = *(double *)(a1 + 168);
    double v13 = *(double *)(a1 + 128);
    double v12 = *(double *)(a1 + 136);
    double v15 = *(double *)(a1 + 144);
    double v14 = *(double *)(a1 + 152);
    double v16 = sqrt(v8);
    double v17 = atan2(v16, v3);
    if (v17 <= v11)
    {
      double v18 = v17 * (v17 * v17);
      double v19 = v17 * v17 * v18;
      double v20 = v17 * v17 * v19;
      double v21 = v17 * v17 * v20;
      if (v10 == 2)
      {
        double v22 = tan(v17 + v13 * v18 + v12 * v19 + v15 * v20 + v14 * v21);
      }
      else if (v10 == 1)
      {
        double v22 = sin(v17 + v13 * v18 + v12 * v19 + v15 * v20 + v14 * v21);
      }
      else
      {
        double v9 = 0.0;
        if (v10) {
          goto LABEL_13;
        }
        double v22 = v17 + v13 * v18 + v12 * v19 + v15 * v20 + v14 * v21;
      }
      double v9 = v22 / v16;
      goto LABEL_13;
    }
    return 0;
  }
  double v9 = 1.0 / v3;
LABEL_13:
  double v24 = *(double *)(a1 + 32);
  double v25 = *(double *)(a1 + 64) + v24 * *(double *)(a1 + 48) * (v6 * v9);
  double v26 = *(double *)(a1 + 72) + v24 * (v7 * v9);
  *a3 = v25;
  a3[1] = v26;
  BOOL v27 = *(double *)(a1 + 88) <= v25;
  if (*(double *)(a1 + 96) <= v25) {
    BOOL v27 = 0;
  }
  if (*(double *)(a1 + 104) > v26) {
    BOOL v27 = 0;
  }
  return *(double *)(a1 + 112) > v26 && v27;
}

unsigned char *sub_215402504(unsigned char *result, char a2)
{
  result[40] = a2;
  result[56] = a2;
  result[80] = a2;
  result[160] = a2;
  return result;
}

void sub_215402518()
{
}

uint64_t sub_2154025D4(uint64_t a1)
{
  return a1 + 88;
}

uint64_t sub_2154025DC()
{
  return 1;
}

void sub_2154025E4()
{
}

uint64_t sub_2154025FC(std::string::size_type *a1, std::string *a2, uint64_t a3)
{
  cva::adp::io::PListSerializer::getPath(a1, a2, &v15);
  std::string::size_type v4 = v15;
  if (v15)
  {
    if (*(char *)(a3 + 23) >= 0) {
      double v5 = (const char *)a3;
    }
    else {
      double v5 = *(const char **)a3;
    }
    CFStringRef v6 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v5, 0x8000100u, (CFAllocatorRef)*MEMORY[0x263EFFB28]);
    CFStringRef v7 = (const __CFString *)[*(id *)v4 objectForKey:v6];
    CFStringRef v8 = v7;
    char v9 = *(unsigned char *)(v4 + 8);
    CFTypeRef cf = v7;
    char v14 = v9;
    if (v7)
    {
      CFRetain(v7);
      CFRelease(v6);
      if (cva::ItemHandler::isVectorType(&cf)) {
        sub_2153FB048();
      }
      CFStringRef v10 = v8;
    }
    else
    {
      char v14 = 0;
      CFStringRef v10 = v6;
    }
    CFRelease(v10);
  }
  double v11 = v16;
  if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  return 0;
}

void sub_215402788(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

BOOL sub_21540279C(uint64_t a1, uint64_t a2, double a3)
{
  if (!(*(unsigned int (**)(uint64_t))(*(void *)a2 + 16))(a2)
    && *(double *)(a1 + 32) - *(double *)(a2 + 32) < a3
    && *(double *)(a1 + 48) - *(double *)(a2 + 48) < a3
    && (float64x2_t v6 = vsubq_f64(*(float64x2_t *)(a1 + 64), *(float64x2_t *)(a2 + 64)), sqrt(vaddvq_f64(vmulq_f64(v6, v6))) < a3)
    && *(unsigned __int8 *)(a1 + 80) == *(unsigned __int8 *)(a2 + 80)
    && (float64x2_t v7 = vsubq_f64(*(float64x2_t *)(a1 + 88), *(float64x2_t *)(a2 + 88)),
        float64x2_t v8 = vmulq_f64(v7, v7),
        float64x2_t v9 = vsubq_f64(*(float64x2_t *)(a1 + 104), *(float64x2_t *)(a2 + 104)),
        float64x2_t v10 = vmulq_f64(v9, v9),
        sqrt(vaddq_f64(vaddq_f64(vaddq_f64(v8, (float64x2_t)vdupq_laneq_s64((int64x2_t)v8, 1)), v10), (float64x2_t)vdupq_laneq_s64((int64x2_t)v10, 1)).f64[0]) < a3)&& *(_DWORD *)(a1 + 120) == *(_DWORD *)(a2 + 120))
  {
    return *(_DWORD *)(a1 + 124) == *(_DWORD *)(a2 + 124);
  }
  else
  {
    return 0;
  }
}

void *sub_2154028B8(uint64_t a1, void *a2)
{
  uint64_t v4 = a1 + 32;
  sub_2153FF828((__n128 *)(a1 + 88), a2);
  sub_2153FF8CC(v4, a2);
  sub_2153FF9FC(a1 + 48, a2);
  return sub_2153FFB2C((__n128 *)(a1 + 64), a2);
}

BOOL sub_215402920(double *a1, double *a2, double *a3)
{
  double v3 = a1[4];
  double v4 = a2[1];
  BOOL v5 = a1[11] > *a2;
  if (a1[12] <= *a2) {
    BOOL v5 = 1;
  }
  double v6 = a1[6];
  if (a1[13] > v4) {
    BOOL v5 = 1;
  }
  if (a1[14] <= v4) {
    BOOL v5 = 1;
  }
  if (v3 < 0.0000000149011612) {
    BOOL v5 = 1;
  }
  if (v6 < 0.0000000149011612) {
    BOOL v5 = 1;
  }
  if (!v5)
  {
    double v7 = (*a2 - a1[8]) / (v3 * v6);
    double v8 = (v4 - a1[9]) / v3;
    *a3 = v7;
    a3[1] = v8;
  }
  return !v5;
}

BOOL sub_215402994(double *a1, double *a2, double *a3)
{
  double v3 = a2[2];
  if (v3 < 0.001) {
    return 0;
  }
  double v4 = 1.0 / v3;
  double v5 = a1[4];
  double v6 = a1[8] + v5 * a1[6] * (v4 * *a2);
  double v7 = a1[9] + v5 * (v4 * a2[1]);
  *a3 = v6;
  a3[1] = v7;
  BOOL v8 = a1[11] <= v6;
  if (a1[12] <= v6) {
    BOOL v8 = 0;
  }
  if (a1[13] > v7) {
    BOOL v8 = 0;
  }
  return a1[14] > v7 && v8;
}

unsigned char *sub_215402A0C(unsigned char *result, char a2)
{
  result[40] = a2;
  result[56] = a2;
  result[80] = a2;
  return result;
}

void sub_215402A1C()
{
}

uint64_t sub_215402AC0(uint64_t a1)
{
  return a1 + 88;
}

uint64_t sub_215402AC8()
{
  return 0;
}

void sub_215402AD0()
{
}

uint64_t sub_215402AE8(std::string::size_type *a1, uint64_t a2, unint64_t *a3, uint64_t a4)
{
  if (*(char *)(a2 + 23) < 0) {
    sub_2153C0AE4(&v15, *(void **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string v15 = *(std::string *)a2;
  }
  cva::adp::PListPath::convertToPath(a3, (uint64_t)__p);
  if (v17 >= 0) {
    double v7 = __p;
  }
  else {
    double v7 = (void **)__p[0];
  }
  if (v17 >= 0) {
    std::string::size_type v8 = v17;
  }
  else {
    std::string::size_type v8 = (std::string::size_type)__p[1];
  }
  std::string::append(&v15, (const std::string::value_type *)v7, v8);
  if (v17 < 0) {
    operator delete(__p[0]);
  }
  char v17 = 4;
  strcpy((char *)__p, "Data");
  uint64_t v9 = sub_2153FAEC0(a1, &v15, (uint64_t)__p);
  uint64_t v10 = v9;
  if (v17 < 0)
  {
    operator delete(__p[0]);
    if (!v10)
    {
LABEL_14:
      if ((SHIBYTE(v15.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        return v10;
      }
LABEL_22:
      operator delete(v15.__r_.__value_.__l.__data_);
      return v10;
    }
  }
  else if (!v9)
  {
    goto LABEL_14;
  }
  char v17 = 5;
  strcpy((char *)__p, "Fixed");
  double v12 = (char *)(a4 + 8);
  int v13 = cva::adp::io::PListSerializer::getItem<BOOL>(a1, &v15, (uint64_t)__p, v12);
  if (v17 < 0) {
    operator delete(__p[0]);
  }
  char v14 = *v12 ^ 1;
  if (!v13) {
    char v14 = 1;
  }
  char *v12 = v14;
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_22;
  }
  return v10;
}

__n128 sub_215402C58(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26C5FBED0;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  long long v4 = *(_OWORD *)(a1 + 40);
  *(void *)(a2 + 56) = *(void *)(a1 + 56);
  *(_OWORD *)(a2 + 40) = v4;
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_215402C98(uint64_t a1)
{
  long long v2 = (char *)operator new(0x40uLL);
  *(void *)long long v2 = &unk_26C5FBED0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  *((void *)v2 + 7) = *(void *)(a1 + 56);
  return result;
}

void sub_215402CFC()
{
}

uint64_t cva::adp::Session<double>::loadImagePoint3TrackSet(void *a1)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  uint64_t v1 = (const char **)(a1 + 13);
  sub_2153F4E9C(&v10, a1);
  *(_OWORD *)double v11 = 0u;
  *(_OWORD *)double v12 = 0u;
  int v13 = 1065353216;
  if (sub_215405AA4(v1, &v10))
  {
    long long v2 = *v1;
    if ((*v1)[23] < 0) {
      long long v2 = *(const char **)v2;
    }
    int v3 = 0;
    if (!stat(v2, &v15) && (v15.st_mode & 0xF000) == 0x4000)
    {
      v14[0] = 0;
      *(void *)uint64_t v9 = 0;
      v14[5] = 0;
      int v3 = 1;
      if ((std::string::size_type *)v10.__r_.__value_.__l.__data_ != &v10.__r_.__value_.__r.__words[1]) {
        operator new();
      }
    }
  }
  else
  {
    int v3 = 0;
  }
  long long v4 = v12[0];
  if (v12[0])
  {
    do
    {
      double v6 = (void *)*v4;
      double v7 = (void *)v4[3];
      if (v7)
      {
        v4[4] = v7;
        operator delete(v7);
      }
      operator delete(v4);
      long long v4 = v6;
    }
    while (v6);
  }
  double v5 = v11[0];
  v11[0] = 0;
  if (v5) {
    operator delete(v5);
  }
  if (v3)
  {
    v9[23] = 16;
    strcpy(v9, "scene-points.txt");
    operator new();
  }
  sub_2153CF0DC((char *)v10.__r_.__value_.__l.__size_);
  return 0;
}

uint64_t sub_215405AA4(const char **a1, void *a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  int v3 = *a1;
  if (v3[23] < 0) {
    int v3 = *(const char **)v3;
  }
  uint64_t v4 = 0;
  if (!stat(v3, &__dst) && (__dst.st_mode & 0xF000) == 0x4000)
  {
    *((unsigned char *)&__str.__r_.__value_.__s + 23) = 13;
    strcpy((char *)&__str, "image-points.");
    uint64_t v4 = 1;
    if ((void *)*a2 != a2 + 1) {
      operator new();
    }
  }
  return v4;
}

void *sub_215406980(void *a1, uint64_t a2)
{
  sub_2153F5ED4(a1);
  int v4 = std::istream::peek();
  std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
  double v5 = std::ctype<char>::classic_table();
  if (v4 == 91)
  {
    memmove(__dst, v5, 0x400uLL);
    v10 |= 0x4000u;
    v8 |= 0x4000u;
    v9 |= 0x4000u;
    std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
    operator new();
  }
  MEMORY[0x2166B9580](a1, a2);
  MEMORY[0x2166B9580](a1, a2 + 8);
  MEMORY[0x2166B9580](a1, a2 + 16);
  std::locale::~locale(&v11);
  return a1;
}

char *sub_215406CFC(char **a1, char *a2, uint64_t *a3)
{
  int v4 = a2;
  double v7 = *a1;
  unint64_t v6 = (unint64_t)a1[1];
  uint64_t v8 = a2 - *a1;
  int64_t v9 = 0xCCCCCCCCCCCCCCCDLL * (v8 >> 3);
  unint64_t v10 = (unint64_t)a1[2];
  if (v6 < v10)
  {
    std::locale v11 = a3 + 1;
    if (a2 == (char *)v6)
    {
      *(void *)a2 = *a3;
      double v22 = &v7[8 * (v8 >> 3)];
      *(_OWORD *)(v22 + 8) = *v11;
      *(_OWORD *)(v22 + 24) = *(_OWORD *)(a3 + 3);
      a1[1] = a2 + 40;
    }
    else
    {
      uint64_t v12 = *a3;
      long long v40 = *(_OWORD *)(a3 + 3);
      long long v41 = *v11;
      int v13 = (char *)(v6 - 40);
      char v14 = a1[1];
      if (v6 >= 0x28)
      {
        unint64_t v15 = v6 - 40;
        char v14 = a1[1];
        do
        {
          *(void *)char v14 = *(void *)v15;
          *(_OWORD *)(v14 + 8) = *(_OWORD *)(v15 + 8);
          *(_OWORD *)(v14 + 24) = *(_OWORD *)(v15 + 24);
          v14 += 40;
          v15 += 40;
        }
        while (v15 < v6);
      }
      a1[1] = v14;
      if ((char *)v6 != a2 + 40)
      {
        do
        {
          if (v13 != (char *)v6)
          {
            uint64_t v17 = *((void *)v13 - 5);
            *(void *)(v6 - 40) = v17 & 0xFFFFFFFFFFFFFFLL | ((unint64_t)*(unsigned __int8 *)(v6 - 33) << 56);
            *(void *)(v6 - 40) = v17 & 0xFFFFFFFFFFFFFFLL | ((unint64_t)*(v13 - 33) << 56);
          }
          *(_OWORD *)(v6 - 32) = *((_OWORD *)v13 - 2);
          *(_OWORD *)(v6 - 16) = *((_OWORD *)v13 - 1);
          v13 -= 40;
          v6 -= 40;
        }
        while (v13 != a2);
      }
      *(void *)a2 = v12;
      uint64_t v16 = &v7[8 * (v8 >> 3)];
      *(_OWORD *)(v16 + 8) = v41;
      *(_OWORD *)(v16 + 24) = v40;
    }
    return v4;
  }
  unint64_t v18 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v6 - (void)v7) >> 3) + 1;
  if (v18 > 0x666666666666666) {
    abort();
  }
  unint64_t v19 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v10 - (void)v7) >> 3);
  if (2 * v19 > v18) {
    unint64_t v18 = 2 * v19;
  }
  if (v19 >= 0x333333333333333) {
    unint64_t v20 = 0x666666666666666;
  }
  else {
    unint64_t v20 = v18;
  }
  if (v20)
  {
    if (v20 > 0x666666666666666) {
      goto LABEL_42;
    }
    double v21 = (char *)operator new(40 * v20);
  }
  else
  {
    double v21 = 0;
  }
  int v23 = &v21[8 * (v8 >> 3)];
  double v24 = &v21[40 * v20];
  if (v9 == v20)
  {
    if (v8 >= 1)
    {
      uint64_t v25 = v9 + 2;
      if (v9 >= -1) {
        uint64_t v25 = v9 + 1;
      }
      v23 -= 40 * (v25 >> 1);
      goto LABEL_32;
    }
    unint64_t v26 = 0x999999999999999ALL * (v8 >> 3);
    if (v7 == v4) {
      unint64_t v26 = 1;
    }
    if (v26 <= 0x666666666666666)
    {
      unint64_t v27 = v26 >> 2;
      uint64_t v28 = 40 * v26;
      float64x2_t v29 = (char *)operator new(40 * v26);
      int v23 = &v29[40 * v27];
      double v24 = &v29[v28];
      if (v21)
      {
        std::string::size_type v30 = v21;
        float64x2_t v31 = v24;
        operator delete(v30);
        double v24 = v31;
      }
      goto LABEL_32;
    }
LABEL_42:
    sub_2153E6200();
  }
LABEL_32:
  *(void *)int v23 = *a3;
  *(_OWORD *)(v23 + 8) = *(_OWORD *)(a3 + 1);
  *(_OWORD *)(v23 + 24) = *(_OWORD *)(a3 + 3);
  double v32 = v23 + 40;
  double v33 = *a1;
  double v34 = v23;
  if (*a1 != v4)
  {
    double v35 = v4;
    double v34 = v23;
    do
    {
      uint64_t v36 = *((void *)v35 - 5);
      v35 -= 40;
      *((void *)v34 - 5) = v36;
      v34 -= 40;
      *(_OWORD *)(v34 + 8) = *(_OWORD *)(v35 + 8);
      *(_OWORD *)(v34 + 24) = *(_OWORD *)(v35 + 24);
    }
    while (v35 != v33);
  }
  for (uint64_t i = a1[1]; v4 != i; v4 += 40)
  {
    *(void *)double v32 = *(void *)v4;
    *(_OWORD *)(v32 + 8) = *(_OWORD *)(v4 + 8);
    *(_OWORD *)(v32 + 24) = *(_OWORD *)(v4 + 24);
    v32 += 40;
  }
  double v38 = *a1;
  *a1 = v34;
  a1[1] = v32;
  a1[2] = v24;
  if (v38) {
    operator delete(v38);
  }
  return v23;
}

void sub_215407040(uint64_t a1, unint64_t a2, void *a3)
{
  double v5 = *(void **)(*a3 + 24);
  int v4 = *(void **)(*a3 + 32);
  if (v4 == v5) {
    return;
  }
  unint64_t v9 = 0xCCCCCCCCCCCCCCCDLL * (v4 - v5);
  do
  {
    unint64_t v10 = v9 >> 1;
    std::locale v11 = &v5[5 * (v9 >> 1)];
    unint64_t v13 = *v11;
    uint64_t v12 = v11 + 5;
    v9 += ~(v9 >> 1);
    if (v13 < a2) {
      double v5 = v12;
    }
    else {
      unint64_t v9 = v10;
    }
  }
  while (v9);
  if (v5 == v4 || *v5 != a2) {
    return;
  }
  unint64_t v14 = *(void *)(a1 + 8);
  if (v14)
  {
    uint8x8_t v15 = (uint8x8_t)vcnt_s8((int8x8_t)v14);
    v15.i16[0] = vaddlv_u8(v15);
    if (v15.u32[0] > 1uLL)
    {
      unint64_t v16 = a2;
      if (v14 <= a2) {
        unint64_t v16 = a2 % v14;
      }
    }
    else
    {
      unint64_t v16 = (v14 - 1) & a2;
    }
    uint64_t v17 = *(void **)(*(void *)a1 + 8 * v16);
    if (v17)
    {
      unint64_t v18 = (void *)*v17;
      if (v18)
      {
        if (v15.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v20 = v18[1];
            if (v20 == a2)
            {
              if (v18[2] == a2) {
                goto LABEL_67;
              }
            }
            else if ((v20 & (v14 - 1)) != v16)
            {
              goto LABEL_30;
            }
            unint64_t v18 = (void *)*v18;
            if (!v18) {
              goto LABEL_30;
            }
          }
        }
        do
        {
          unint64_t v19 = v18[1];
          if (v19 == a2)
          {
            if (v18[2] == a2)
            {
LABEL_67:
              uint64_t v34 = (uint64_t)(v18 + 3);
              unint64_t v37 = v5[4];
              uint64_t v36 = v5 + 4;
              unint64_t v35 = v37;
              goto LABEL_105;
            }
          }
          else
          {
            if (v19 >= v14) {
              v19 %= v14;
            }
            if (v19 != v16) {
              break;
            }
          }
          unint64_t v18 = (void *)*v18;
        }
        while (v18);
      }
    }
LABEL_30:
    if (v15.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v14 <= a2) {
        unint64_t v3 = a2 % v14;
      }
    }
    else
    {
      unint64_t v3 = (v14 - 1) & a2;
    }
    double v21 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v21)
    {
      double v22 = (char *)*v21;
      if (*v21)
      {
        if (v15.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v24 = *((void *)v22 + 1);
            if (v24 == a2)
            {
              if (*((void *)v22 + 2) == a2) {
                goto LABEL_88;
              }
            }
            else if ((v24 & (v14 - 1)) != v3)
            {
              goto LABEL_49;
            }
            double v22 = *(char **)v22;
            if (!v22) {
              goto LABEL_49;
            }
          }
        }
        do
        {
          unint64_t v23 = *((void *)v22 + 1);
          if (v23 == a2)
          {
            if (*((void *)v22 + 2) == a2) {
              goto LABEL_88;
            }
          }
          else
          {
            if (v23 >= v14) {
              v23 %= v14;
            }
            if (v23 != v3) {
              break;
            }
          }
          double v22 = *(char **)v22;
        }
        while (v22);
      }
    }
  }
LABEL_49:
  double v22 = (char *)operator new(0x40uLL);
  *(void *)double v22 = 0;
  *((void *)v22 + 1) = a2;
  *((void *)v22 + 2) = a2;
  *(_OWORD *)(v22 + 24) = 0u;
  *(_OWORD *)(v22 + 40) = 0u;
  *((_DWORD *)v22 + 14) = 1065353216;
  float v25 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v26 = *(float *)(a1 + 32);
  if (!v14 || (float)(v26 * (float)v14) < v25)
  {
    BOOL v27 = 1;
    if (v14 >= 3) {
      BOOL v27 = (v14 & (v14 - 1)) != 0;
    }
    unint64_t v28 = v27 | (2 * v14);
    unint64_t v29 = vcvtps_u32_f32(v25 / v26);
    if (v28 <= v29) {
      size_t prime = v29;
    }
    else {
      size_t prime = v28;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v14 = *(void *)(a1 + 8);
    }
    if (prime > v14) {
      goto LABEL_72;
    }
    if (prime < v14)
    {
      unint64_t v31 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v14 < 3 || (uint8x8_t v32 = (uint8x8_t)vcnt_s8((int8x8_t)v14), v32.i16[0] = vaddlv_u8(v32), v32.u32[0] > 1uLL))
      {
        unint64_t v31 = std::__next_prime(v31);
      }
      else
      {
        uint64_t v33 = 1 << -(char)__clz(v31 - 1);
        if (v31 >= 2) {
          unint64_t v31 = v33;
        }
      }
      if (prime <= v31) {
        size_t prime = v31;
      }
      if (prime < v14) {
LABEL_72:
      }
        sub_2153F6BC0(a1, prime);
    }
    unint64_t v14 = *(void *)(a1 + 8);
    if ((v14 & (v14 - 1)) != 0)
    {
      if (v14 <= a2) {
        unint64_t v3 = a2 % v14;
      }
      else {
        unint64_t v3 = a2;
      }
    }
    else
    {
      unint64_t v3 = (v14 - 1) & a2;
    }
  }
  uint64_t v38 = *(void *)a1;
  double v39 = *(void **)(*(void *)a1 + 8 * v3);
  if (v39)
  {
    *(void *)double v22 = *v39;
LABEL_86:
    *double v39 = v22;
    goto LABEL_87;
  }
  *(void *)double v22 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v22;
  *(void *)(v38 + 8 * v3) = a1 + 16;
  if (*(void *)v22)
  {
    unint64_t v40 = *(void *)(*(void *)v22 + 8);
    if ((v14 & (v14 - 1)) != 0)
    {
      if (v40 >= v14) {
        v40 %= v14;
      }
    }
    else
    {
      v40 &= v14 - 1;
    }
    double v39 = (void *)(*(void *)a1 + 8 * v40);
    goto LABEL_86;
  }
LABEL_87:
  ++*(void *)(a1 + 24);
LABEL_88:
  unint64_t v41 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 40) / *((float *)v22 + 14));
  if (v41 == 1)
  {
    unint64_t v41 = 2;
  }
  else if ((v41 & (v41 - 1)) != 0)
  {
    unint64_t v41 = std::__next_prime(v41);
  }
  int8x8_t v42 = *(int8x8_t *)(v22 + 32);
  if (v41 > *(void *)&v42) {
    goto LABEL_103;
  }
  if (v41 < *(void *)&v42)
  {
    unint64_t v43 = vcvtps_u32_f32((float)*((unint64_t *)v22 + 6) / *((float *)v22 + 14));
    if (*(void *)&v42 < 3uLL || (uint8x8_t v44 = (uint8x8_t)vcnt_s8(v42), v44.i16[0] = vaddlv_u8(v44), v44.u32[0] > 1uLL))
    {
      unint64_t v43 = std::__next_prime(v43);
    }
    else
    {
      uint64_t v45 = 1 << -(char)__clz(v43 - 1);
      if (v43 >= 2) {
        unint64_t v43 = v45;
      }
    }
    if (v41 <= v43) {
      unint64_t v41 = v43;
    }
    if (v41 < *(void *)&v42) {
LABEL_103:
    }
      sub_2153F6BC0((uint64_t)(v22 + 24), v41);
  }
  unint64_t v46 = v5[4];
  uint64_t v36 = v5 + 4;
  unint64_t v35 = v46;
  uint64_t v34 = (uint64_t)(v22 + 24);
LABEL_105:
  BOOL v47 = sub_2153F71B8(v34, v35, v36);
  uint64_t v49 = *a3;
  uint64_t v48 = a3[1];
  if (v48) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v48 + 8), 1uLL, memory_order_relaxed);
  }
  int64_t v50 = (std::__shared_weak_count *)v47[4];
  v47[3] = v49;
  v47[4] = v48;
  if (v50 && !atomic_fetch_add(&v50->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
    std::__shared_weak_count::__release_weak(v50);
  }
}

uint64_t sub_215407584(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 24);
  if (v1)
  {
    *(unsigned char *)(v1 + 80) = 0;
    long long v2 = *(void **)(v1 + 24);
    *(void *)(v1 + 32) = v2;
    if (v2) {
      operator delete(v2);
    }
    unint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
    if (v3) {
      std::__shared_weak_count::__release_weak(v3);
    }
    JUMPOUT(0x2166B9890);
  }
  return result;
}

void sub_2154075F8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2166B9890);
}

uint64_t cva::adp::Session<double>::loadImageMeasurementsSet(void *a1)
{
  uint64_t v1 = (const char **)(a1 + 13);
  sub_2153F4E9C(&v4, a1);
  uint64_t v2 = sub_215405AA4(v1, &v4);
  sub_2153CF0DC((char *)v4.__r_.__value_.__l.__size_);
  return v2;
}

void cva::adp::Session<double>::loadDiscretePoses()
{
  uint64_t v1 = *MEMORY[0x263EF8340];
  __s[23] = 9;
  strcpy(__s, "WtoP.traj");
  operator new();
}

void cva::adp::Session<double>::setDataPath(int a1, cva::adp::io::Paths *this)
{
}

uint64_t cva::adp::Session<double>::setDataPath(uint64_t a1, const std::string **a2, const std::string **a3)
{
  unint64_t v6 = (const char *)*a2;
  if (SHIBYTE((*a2)->__r_.__value_.__r.__words[2]) < 0) {
    unint64_t v6 = *(const char **)v6;
  }
  int v7 = access(v6, 0);
  uint64_t result = 0;
  if (!v7)
  {
    unint64_t v9 = (const char *)*a3;
    if (SHIBYTE((*a3)->__r_.__value_.__r.__words[2]) < 0) {
      unint64_t v9 = *(const char **)v9;
    }
    int v10 = access(v9, 0);
    uint64_t result = 0;
    if (!v10)
    {
      if ((const std::string **)(a1 + 96) != a2) {
        std::string::operator=(*(std::string **)(a1 + 96), *a2);
      }
      if ((const std::string **)(a1 + 104) != a3) {
        std::string::operator=(*(std::string **)(a1 + 104), *a3);
      }
      return 1;
    }
  }
  return result;
}

uint64_t cva::adp::Session<double>::serializer(uint64_t a1)
{
  return a1 + 56;
}

uint64_t cva::adp::Session<double>::dataPath(uint64_t a1)
{
  return a1 + 96;
}

uint64_t cva::adp::Session<double>::sensorsPath(uint64_t a1)
{
  return a1 + 104;
}

void *cva::operator<<(void *a1, uint64_t *a2)
{
  unint64_t v2 = a2[1];
  if (v2 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  uint64_t v4 = *a2;
  if (v2 > 0x16)
  {
    uint64_t v7 = (v2 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v2 | 7) != 0x17) {
      uint64_t v7 = v2 | 7;
    }
    uint64_t v8 = v7 + 1;
    CFStringRef p_p = operator new(v7 + 1);
    unint64_t v19 = v2;
    int64_t v20 = v8 | 0x8000000000000000;
    long long __p = p_p;
    if (v2 < 0x20)
    {
      unint64_t v6 = (char *)v4;
    }
    else
    {
      unint64_t v6 = (char *)v4;
      if ((unint64_t)&p_p[-v4] >= 0x20)
      {
        uint64_t v9 = v2 & 0x7FFFFFFFFFFFFFE0;
        unint64_t v6 = (char *)(v4 + (v2 & 0xFFFFFFFFFFFFFFE0));
        int v10 = p_p + 16;
        std::locale v11 = (long long *)(v4 + 16);
        unint64_t v12 = v2 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v13 = *v11;
          *(v10 - 1) = *(v11 - 1);
          _OWORD *v10 = v13;
          v10 += 2;
          v11 += 2;
          v12 -= 32;
        }
        while (v12);
        p_p += v9;
        if (v2 == v9) {
          goto LABEL_15;
        }
      }
    }
    goto LABEL_14;
  }
  HIBYTE(v20) = a2[1];
  CFStringRef p_p = &__p;
  unint64_t v6 = (char *)v4;
  if (v2)
  {
    do
    {
LABEL_14:
      char v14 = *v6++;
      *p_p++ = v14;
    }
    while (v6 != (char *)(v4 + v2));
  }
LABEL_15:
  *CFStringRef p_p = 0;
  if (v20 >= 0) {
    uint8x8_t v15 = &__p;
  }
  else {
    uint8x8_t v15 = __p;
  }
  if (v20 >= 0) {
    uint64_t v16 = HIBYTE(v20);
  }
  else {
    uint64_t v16 = v19;
  }
  sub_2153C1168(a1, (uint64_t)v15, v16);
  if (SHIBYTE(v20) < 0) {
    operator delete(__p);
  }
  return a1;
}

cva::MatrixRasterizerEngine *cva::MatrixRasterizerEngine::MatrixRasterizerEngine(cva::MatrixRasterizerEngine *this, int a2, int a3, double a4, unsigned int a5, unsigned __int32 a6, int a7)
{
  int v7 = a7;
  *(_DWORD *)this = a3;
  *((_DWORD *)this + 1) = a2;
  *((_DWORD *)this + 2) = LODWORD(a4);
  *((unsigned char *)this + 20) = a7;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 9) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0;
  *((void *)this + 12) = 0;
  if (*(float *)&a4 >= 1.0)
  {
    *(float *)&a4 = floorf(*(float *)&a4 + 0.5);
    *((_DWORD *)this + 2) = LODWORD(a4);
  }
  int32x2_t v9 = *(int32x2_t *)this;
  float32x2_t v10 = vcvt_f32_u32(*(uint32x2_t *)this);
  float32x2_t v11 = vmul_n_f32(v10, *(float *)&a4);
  int32x2_t v12 = vmax_s32(vadd_s32(vdup_n_s32(*(float *)&a4 >= 2.0), vcvt_s32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(*(float *)&a4 < 1.0), 0x1FuLL)), (int8x8_t)vrndp_f32(v11), (int8x8_t)v11))), (int32x2_t)0x100000001);
  *(int32x2_t *)((char *)this + 12) = v12;
  if (a5 && v12.i32[0] > a5 || a6 && v12.i32[1] > a6)
  {
    a4 = COERCE_DOUBLE(vdiv_f32(vcvt_f32_u32((uint32x2_t)vadd_s32((int32x2_t)__PAIR64__(a6, a5), (int32x2_t)vcge_u32((uint32x2_t)__PAIR64__(a6, a5), (uint32x2_t)vadd_s32(v9, v9)))), v10));
    if (*((float *)&a4 + 1) < *(float *)&a4) {
      *(float *)&a4 = *((float *)&a4 + 1);
    }
    float v13 = floorf(*(float *)&a4);
    if (*(float *)&a4 > 1.0) {
      *(float *)&a4 = v13;
    }
    *((_DWORD *)this + 2) = LODWORD(a4);
    float32x2_t v14 = vmul_n_f32(v10, *(float *)&a4);
    int32x2_t v12 = vmax_s32(vadd_s32(vdup_n_s32(*(float *)&a4 >= 2.0), vcvt_s32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(*(float *)&a4 < 1.0), 0x1FuLL)), (int8x8_t)vrndp_f32(v14), (int8x8_t)v14))), (int32x2_t)0x100000001);
    *(int32x2_t *)((char *)this + 12) = v12;
  }
  float v15 = 1.0;
  if (*(float *)&a4 >= 1.0)
  {
    int v18 = (int)(float)(*(float *)&a4 + 0.5);
    if (v18 < 2)
    {
      int v21 = 219;
    }
    else
    {
      float v19 = (float)(fminf((float)(v18 - 1) * 0.5, 1.0) * -0.25) + 1.0;
      float v20 = v19 * 255.0;
      float v15 = (float)((float)((float)((float)v18 * 0.86111) * (float)v18) - (float)(v19 * (float)(2 * v18 - 1)))
          / (float)((v18 - 1) * (v18 - 1));
      int v21 = (int)v20;
    }
    if (v21 >= 255) {
      int v21 = 255;
    }
    if ((int)(float)(v15 * 255.0) >= 255) {
      int v26 = 255;
    }
    else {
      int v26 = (int)(float)(v15 * 255.0);
    }
    unsigned int v27 = v21 & ~(v21 >> 31);
    int32x4_t v28 = vdupq_n_s32(v27);
    BOOL v29 = v15 >= 0.875 || *(float *)&a4 < 3.0;
    int32x4_t v30 = (int32x4_t)vandq_s8((int8x16_t)vmulq_s32(v28, (int32x4_t)xmmword_215445F30), (int8x16_t)xmmword_215445F40);
    unsigned long long v31 = *(_OWORD *)&vshrq_n_u32((uint32x4_t)vorrq_s8(vandq_s8((int8x16_t)vmulq_s32(v28, (int32x4_t)xmmword_215445F10), (int8x16_t)xmmword_215445F20), (int8x16_t)v30), 8uLL) | __PAIR128__(0xFF000000FF000000, 0xFF000000FF000000);
    int v32 = v26 & ~(v26 >> 31);
    if (!v29) {
      int v32 = 223;
    }
    v30.i64[0] = __PAIR64__(v32, v27);
    *(_OWORD *)((char *)this + 120) = v31;
    int32x4_t v33 = vzip1q_s32(v30, vdupq_lane_s32((int32x2_t)__PAIR64__(v32, v27), 1));
    *(_OWORD *)((char *)this + 136) = *(_OWORD *)&vshrq_n_u32((uint32x4_t)vorrq_s8(vandq_s8((int8x16_t)vmulq_s32(v33, (int32x4_t)xmmword_215445F50), (int8x16_t)xmmword_215445F60), vandq_s8((int8x16_t)vmulq_s32(v33, (int32x4_t)xmmword_215445F70), (int8x16_t)xmmword_215445F80)), 8uLL) | __PAIR128__(0xFF000000FF000000, 0xFF000000FF000000);
    *((_DWORD *)this + 38) = (((16646224 * v32) & 0xFF00FF00 | (43264 * v32) & 0xFF0000) >> 8) | 0xFF000000;
    *((_DWORD *)this + 39) = (((16449607 * v32) & 0xFF00FF00 | (23808 * v32) & 0x7F0000) >> 8) | 0xFF000000;
    *((void *)this + 3) = 0;
    if (a7)
    {
      *((void *)this + 4) = v12.u32[1] | ((unint64_t)v12.u32[0] << 32);
      *((void *)this + 5) = ((unint64_t)(((4 * v12.i32[1] + 15) & 0xFFFFFFF0) >> 4) << 36) | 4;
      size[0] = 0;
      unint64_t v34 = ((4 * v12.i32[1] + 15) & 0xFFFFFFF0) * (unint64_t)v12.u32[0];
    }
    else
    {
      *((int32x2_t *)this + 4) = v12;
      *((void *)this + 5) = ((unint64_t)(((4 * v12.i32[0] + 15) & 0xFFFFFFF0) >> 4) << 36) | 4;
      size[0] = 0;
      unint64_t v34 = ((4 * v12.i32[0] + 15) & 0xFFFFFFF0) * (unint64_t)v12.u32[1];
    }
    size[0] = v34;
    if (v34) {
      *((void *)this + 6) = malloc_type_malloc(size[0], 0xA153FF5uLL);
    }
    else {
      *((void *)this + 6) = 0;
    }
  }
  else
  {
    int32x2_t v56 = v12;
    *(_OWORD *)((char *)this + 120) = xmmword_215445F90;
    *((void *)this + 19) = 0xFFD64F3CFFD99044;
    *(_OWORD *)((char *)this + 136) = xmmword_215445FA0;
    if ((float)(logf(0.25 / (float)(*(float *)&a4 * *(float *)&a4)) / 0.69315) >= 24.0)
    {
      fwrite("error: roundoff will occur", 0x1AuLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
      int32x2_t v17 = *(int32x2_t *)((char *)this + 12);
      int v7 = *((unsigned __int8 *)this + 20);
      uint64_t v16 = *((void *)this + 8);
    }
    else
    {
      uint64_t v16 = 0;
      int32x2_t v17 = v56;
    }
    int32x2_t v22 = vadd_s32(v17, (int32x2_t)0x100000001);
    *(int32x2_t *)((char *)this + 12) = v22;
    if (v7)
    {
      uint64_t v23 = v22.u32[1];
      uint64_t v24 = v22.u32[0];
      if (v22.i32[1] <= v16 && v22.i32[0] <= HIDWORD(v16))
      {
LABEL_49:
        *((void *)this + 7) = 0;
        *((void *)this + 8) = v23 | (v24 << 32);
        goto LABEL_53;
      }
    }
    else
    {
      uint64_t v23 = v22.u32[0];
      uint64_t v24 = v22.u32[1];
      if (v22.i32[0] <= v16 && v22.i32[1] <= HIDWORD(v16)) {
        goto LABEL_49;
      }
    }
    uint64_t v36 = (void *)*((void *)this + 10);
    if (v36)
    {
      free(v36);
      *((void *)this + 10) = 0;
    }
    *((void *)this + 7) = 0;
    *((void *)this + 8) = v23 | (v24 << 32);
    *((void *)this + 9) = ((unint64_t)(((20 * v23 + 15) & 0xFFFFFFF0) >> 4) << 36) | 0x14;
    size[0] = ((20 * v23 + 15) & 0xFFFFFFF0) * (unint64_t)v24;
    if (size[0]) {
      unint64_t v37 = malloc_type_malloc(size[0], 0xA153FF5uLL);
    }
    else {
      unint64_t v37 = 0;
    }
    *((void *)this + 10) = v37;
  }
LABEL_53:
  if (*((float *)this + 2) >= 1.0)
  {
    uint64_t v47 = *((void *)this + 6);
    if (v47)
    {
      unint64_t v48 = *((void *)this + 5);
      uint64_t v49 = (*((_DWORD *)this + 9) * HIDWORD(v48));
      if (v49)
      {
        int v50 = 0;
        int v51 = *((_DWORD *)this + 8);
        uint64_t v52 = (_DWORD *)(v47 + *((void *)this + 3));
        uint64_t v53 = (_DWORD *)((char *)v52 + v49);
        do
        {
          _DWORD *v52 = -1;
          uint64_t v52 = (_DWORD *)((char *)v52 + v48);
          int v54 = v50 + 1;
          if (v50 + 1 == v51) {
            int v50 = 0;
          }
          else {
            ++v50;
          }
          if (v54 == v51) {
            uint64_t v52 = (_DWORD *)((char *)v52 + HIDWORD(v48) - (v54 * v48));
          }
        }
        while (v52 != v53);
      }
    }
  }
  else
  {
    size[0] = 0;
    size[1] = 0;
    int v58 = 0;
    uint64_t v38 = *((void *)this + 10);
    if (v38)
    {
      unint64_t v39 = *((void *)this + 9);
      uint64_t v40 = (*((_DWORD *)this + 17) * HIDWORD(v39));
      if (v40)
      {
        int v41 = 0;
        int v42 = *((_DWORD *)this + 16);
        unint64_t v43 = (size_t *)(v38 + *((void *)this + 7));
        uint8x8_t v44 = (size_t *)((char *)v43 + v40);
        do
        {
          if (v43 == size)
          {
            unint64_t v43 = size;
          }
          else
          {
            long long v45 = *(_OWORD *)size;
            *((_DWORD *)v43 + 4) = v58;
            *(_OWORD *)unint64_t v43 = v45;
          }
          unint64_t v43 = (size_t *)((char *)v43 + v39);
          int v46 = v41 + 1;
          if (v41 + 1 == v42) {
            int v41 = 0;
          }
          else {
            ++v41;
          }
          if (v46 == v42) {
            unint64_t v43 = (size_t *)((char *)v43 + HIDWORD(v39) - (v46 * v39));
          }
        }
        while (v43 != v44);
      }
    }
  }
  return this;
}

float32x2_t cva::MatrixRasterizerEngine::calculateImageSize(cva::MatrixRasterizerEngine *this, unsigned int a2, unsigned __int32 a3)
{
  float v3 = *((float *)this + 2);
  if (v3 >= 1.0)
  {
    float v3 = floorf(v3 + 0.5);
    *((float *)this + 2) = v3;
  }
  unsigned int v4 = v3 < 1.0;
  unsigned int v5 = v3 >= 2.0;
  int32x2_t v6 = *(int32x2_t *)this;
  float32x2_t result = vcvt_f32_u32(*(uint32x2_t *)this);
  float32x2_t v8 = vmul_n_f32(result, v3);
  int32x2_t v9 = vmax_s32(vadd_s32(vdup_n_s32(v5), vcvt_s32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v4), 0x1FuLL)), (int8x8_t)vrndp_f32(v8), (int8x8_t)v8))), (int32x2_t)0x100000001);
  *(int32x2_t *)((char *)this + 12) = v9;
  if (a2 && v9.i32[0] > a2 || a3 && v9.i32[1] > a3)
  {
    float32x2_t v10 = vdiv_f32(vcvt_f32_u32((uint32x2_t)vadd_s32((int32x2_t)__PAIR64__(a3, a2), (int32x2_t)vcge_u32((uint32x2_t)__PAIR64__(a3, a2), (uint32x2_t)vadd_s32(v6, v6)))), result);
    if (v10.f32[1] < v10.f32[0]) {
      v10.f32[0] = v10.f32[1];
    }
    float v11 = floorf(v10.f32[0]);
    if (v10.f32[0] > 1.0) {
      v10.f32[0] = v11;
    }
    *((_DWORD *)this + 2) = v10.i32[0];
    float32x2_t v12 = vmul_n_f32(result, v10.f32[0]);
    float32x2_t result = (float32x2_t)vmax_s32(vadd_s32(vdup_n_s32(v10.f32[0] >= 2.0), vcvt_s32_f32((float32x2_t)vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v10.f32[0] < 1.0), 0x1FuLL)), (int8x8_t)vrndp_f32(v12), (int8x8_t)v12))), (int32x2_t)0x100000001);
    *(float32x2_t *)((char *)this + 12) = result;
  }
  return result;
}

__n128 cva::MatrixRasterizerEngine::calculateMeanBrightnessPreservingColors(cva::MatrixRasterizerEngine *this, __n128 result)
{
  float v2 = *((float *)this + 2);
  float v3 = 1.0;
  if (v2 >= 1.0)
  {
    int v4 = (int)(float)(v2 + 0.5);
    if (v4 < 2)
    {
      int v7 = 219;
    }
    else
    {
      float v5 = (float)(fminf((float)(v4 - 1) * 0.5, 1.0) * -0.25) + 1.0;
      float v6 = v5 * 255.0;
      float v3 = (float)((float)((float)((float)v4 * 0.86111) * (float)v4) - (float)(v5 * (float)(2 * v4 - 1)))
         / (float)((v4 - 1) * (v4 - 1));
      int v7 = (int)v6;
    }
    if (v7 >= 255) {
      int v7 = 255;
    }
    if ((int)(float)(v3 * 255.0) >= 255) {
      int v8 = 255;
    }
    else {
      int v8 = (int)(float)(v3 * 255.0);
    }
    BOOL v9 = v3 >= 0.875 || v2 < 3.0;
    unsigned int v10 = v7 & ~(v7 >> 31);
    int32x4_t v11 = vdupq_n_s32(v10);
    unsigned long long v12 = *(_OWORD *)&vshrq_n_u32((uint32x4_t)vorrq_s8(vandq_s8((int8x16_t)vmulq_s32(v11, (int32x4_t)xmmword_215445F10), (int8x16_t)xmmword_215445F20), vandq_s8((int8x16_t)vmulq_s32(v11, (int32x4_t)xmmword_215445F30), (int8x16_t)xmmword_215445F40)), 8uLL) | __PAIR128__(0xFF000000FF000000, 0xFF000000FF000000);
    *(_OWORD *)((char *)this + 120) = v12;
    int v13 = v8 & ~(v8 >> 31);
    if (!v9) {
      int v13 = 223;
    }
    *(void *)&unsigned long long v12 = __PAIR64__(v13, v10);
    int32x4_t v14 = vzip1q_s32((int32x4_t)v12, vdupq_lane_s32((int32x2_t)__PAIR64__(v13, v10), 1));
    float32x2_t result = (__n128)(*(_OWORD *)&vshrq_n_u32((uint32x4_t)vorrq_s8(vandq_s8((int8x16_t)vmulq_s32(v14, (int32x4_t)xmmword_215445F50), (int8x16_t)xmmword_215445F60), vandq_s8((int8x16_t)vmulq_s32(v14, (int32x4_t)xmmword_215445F70), (int8x16_t)xmmword_215445F80)), 8uLL) | __PAIR128__(0xFF000000FF000000, 0xFF000000FF000000));
    *(__n128 *)((char *)this + 136) = result;
    *((_DWORD *)this + 38) = (((16646224 * v13) & 0xFF00FF00 | (43264 * v13) & 0xFF0000) >> 8) | 0xFF000000;
    *((_DWORD *)this + 39) = (((16449607 * v13) & 0xFF00FF00 | (23808 * v13) & 0x7F0000) >> 8) | 0xFF000000;
  }
  else
  {
    *(_OWORD *)((char *)this + 120) = xmmword_215445F90;
    *((_DWORD *)this + 38) = -2518972;
    result.n128_u64[0] = 0xFF5054A4FFD64F3CLL;
    *(_OWORD *)((char *)this + 136) = xmmword_215445FA0;
    *((_DWORD *)this + 39) = -2732228;
  }
  return result;
}

uint64_t cva::MatrixRasterizerEngine::clear(uint64_t this)
{
  if (*(float *)(this + 8) >= 1.0)
  {
    uint64_t v10 = *(void *)(this + 48);
    if (v10)
    {
      unint64_t v11 = *(void *)(this + 40);
      uint64_t v12 = (*(_DWORD *)(this + 36) * HIDWORD(v11));
      if (v12)
      {
        int v13 = 0;
        int v14 = *(_DWORD *)(this + 32);
        float v15 = (_DWORD *)(v10 + *(void *)(this + 24));
        uint64_t v16 = (_DWORD *)((char *)v15 + v12);
        do
        {
          _DWORD *v15 = -1;
          float v15 = (_DWORD *)((char *)v15 + v11);
          int v17 = v13 + 1;
          if (v13 + 1 == v14) {
            int v13 = 0;
          }
          else {
            ++v13;
          }
          if (v17 == v14) {
            float v15 = (_DWORD *)((char *)v15 + HIDWORD(v11) - (v17 * v11));
          }
        }
        while (v15 != v16);
      }
    }
  }
  else
  {
    long long v18 = 0uLL;
    int v19 = 0;
    uint64_t v1 = *(void *)(this + 80);
    if (v1)
    {
      unint64_t v2 = *(void *)(this + 72);
      uint64_t v3 = (*(_DWORD *)(this + 68) * HIDWORD(v2));
      if (v3)
      {
        int v4 = 0;
        int v5 = *(_DWORD *)(this + 64);
        float v6 = (long long *)(v1 + *(void *)(this + 56));
        int v7 = (long long *)((char *)v6 + v3);
        do
        {
          if (v6 == &v18)
          {
            float v6 = &v18;
          }
          else
          {
            long long v8 = v18;
            *((_DWORD *)v6 + 4) = v19;
            *float v6 = v8;
          }
          float v6 = (long long *)((char *)v6 + v2);
          int v9 = v4 + 1;
          if (v4 + 1 == v5) {
            int v4 = 0;
          }
          else {
            ++v4;
          }
          if (v9 == v5) {
            float v6 = (long long *)((char *)v6 + HIDWORD(v2) - (v9 * v2));
          }
        }
        while (v6 != v7);
      }
    }
  }
  return this;
}

char *cva::MatrixRasterizerEngine::getImage32(cva::MatrixRasterizerEngine *this)
{
  if (*((float *)this + 2) < 1.0) {
    return cva::MatrixRasterizerEngine::convertFloatImage(this);
  }
  if (*((unsigned char *)this + 20)) {
    return cva::MatrixRasterizerEngine::transposeRGBImage(this);
  }
  return (char *)this + 24;
}

char *cva::MatrixRasterizerEngine::transposeRGBImage(cva::MatrixRasterizerEngine *this)
{
  unint64_t v2 = (char *)this + 88;
  uint64_t v4 = *((unsigned int *)this + 3);
  uint64_t v3 = *((unsigned int *)this + 4);
  if (v4 > *((_DWORD *)this + 24) || v3 > *((_DWORD *)this + 25))
  {
    float v6 = (void *)*((void *)this + 14);
    if (v6)
    {
      free(v6);
      *((void *)this + 14) = 0;
    }
    *((void *)this + 11) = 0;
    *((void *)this + 12) = v4 | (v3 << 32);
    *((void *)this + 13) = ((unint64_t)(((4 * v4 + 15) & 0xFFFFFFF0) >> 4) << 36) | 4;
    unint64_t size = v3 * (unint64_t)((4 * v4 + 15) & 0xFFFFFFF0);
    if (size) {
      int v7 = malloc_type_malloc(size, 0xA153FF5uLL);
    }
    else {
      int v7 = 0;
    }
    *((void *)this + 14) = v7;
    LODWORD(v4) = *((_DWORD *)this + 3);
    LODWORD(v3) = *((_DWORD *)this + 4);
  }
  else
  {
    *((void *)this + 11) = 0;
    *((void *)this + 12) = v4 | (v3 << 32);
  }
  uint64_t v8 = *((void *)this + 6);
  if (v8) {
    int v9 = (_DWORD *)(v8 + *((void *)this + 3));
  }
  else {
    int v9 = 0;
  }
  if ((int)v4 >= 1 && (int)v3 >= 1)
  {
    int v10 = 0;
    int v11 = 0;
    unint64_t v12 = *((void *)this + 5);
    int v13 = *((_DWORD *)this + 8);
    uint64_t v14 = *((void *)this + 14);
    uint64_t v15 = *((void *)this + 11);
    do
    {
      int v16 = 0;
      do
      {
        *(_DWORD *)(v14 + v15 + (*((_DWORD *)this + 26) * v10 + *((_DWORD *)this + 27) * v16++)) = *v9;
        int v9 = (_DWORD *)((char *)v9 + v12);
        int v17 = v11 + 1;
        if (v11 + 1 == v13) {
          int v11 = 0;
        }
        else {
          ++v11;
        }
        if (v17 == v13) {
          int v9 = (_DWORD *)((char *)v9 + HIDWORD(v12) - (v17 * v12));
        }
      }
      while (v3 != v16);
      ++v10;
    }
    while (v10 != v4);
  }
  return v2;
}

char *cva::MatrixRasterizerEngine::convertFloatImage(cva::MatrixRasterizerEngine *this)
{
  float v2 = *((float *)this + 2);
  unsigned int v3 = *((_DWORD *)this + 3);
  uint64_t v4 = v3 - 1;
  uint64_t v5 = (*((_DWORD *)this + 4) - 1);
  if (v4 > *((_DWORD *)this + 24) || v5 > *((_DWORD *)this + 25))
  {
    int v7 = (void *)*((void *)this + 14);
    if (v7)
    {
      free(v7);
      *((void *)this + 14) = 0;
    }
    *((void *)this + 11) = 0;
    *((void *)this + 12) = v4 | (v5 << 32);
    *((void *)this + 13) = ((unint64_t)(((4 * v4 + 15) & 0xFFFFFFF0) >> 4) << 36) | 4;
    unint64_t size = ((4 * v4 + 15) & 0xFFFFFFF0) * (unint64_t)v5;
    if (size) {
      uint64_t v8 = malloc_type_malloc(size, 0xA153FF5uLL);
    }
    else {
      uint64_t v8 = 0;
    }
    *((void *)this + 14) = v8;
    unsigned int v3 = *((_DWORD *)this + 3);
    if (v3)
    {
LABEL_11:
      size_t v9 = 4 * v3;
      int v10 = (char *)operator new(v9);
      bzero(v10, v9);
      uint64_t v11 = *((unsigned int *)this + 4);
      if (v11) {
        goto LABEL_12;
      }
      goto LABEL_17;
    }
  }
  else
  {
    *((void *)this + 11) = 0;
    *((void *)this + 12) = v4 | (v5 << 32);
    if (v3) {
      goto LABEL_11;
    }
  }
  int v10 = 0;
  uint64_t v11 = *((unsigned int *)this + 4);
  if (v11)
  {
LABEL_12:
    size_t v12 = 4 * v11;
    int v13 = (char *)operator new(4 * v11);
    bzero(v13, v12);
    float v14 = *(float *)this;
    if (!*(_DWORD *)this) {
      goto LABEL_20;
    }
    goto LABEL_18;
  }
LABEL_17:
  int v13 = 0;
  float v14 = *(float *)this;
  if (!*(_DWORD *)this) {
    goto LABEL_20;
  }
LABEL_18:
  unsigned int v15 = 0;
  do
  {
    float v16 = v2 * (float)v15;
    int v17 = (int)v16;
    float v18 = v16 - (float)(int)v16;
    int v19 = (float *)&v10[4 * v17];
    float v20 = (float)(1.0 - v18) + *v19;
    float v21 = v18 + v19[1];
    float *v19 = v20;
    v19[1] = v21;
    ++v15;
  }
  while (LODWORD(v14) != v15);
LABEL_20:
  int v22 = *((_DWORD *)this + 1);
  if (v22)
  {
    for (unsigned int i = 0; i != v22; ++i)
    {
      float v24 = v2 * (float)i;
      int v25 = (int)v24;
      float v26 = v24 - (float)(int)v24;
      unsigned int v27 = (float *)&v13[4 * v25];
      float v28 = (float)(1.0 - v26) + *v27;
      float v29 = v26 + v27[1];
      float *v27 = v28;
      v27[1] = v29;
    }
  }
  int v30 = *((unsigned __int8 *)this + 20);
  if (*((unsigned char *)this + 20)) {
    unsigned long long v31 = (float *)v10;
  }
  else {
    unsigned long long v31 = (float *)v13;
  }
  if (*((unsigned char *)this + 20)) {
    int v10 = v13;
  }
  uint64_t v92 = (*((_DWORD *)this + 17) - 1);
  if ((int)v92 >= 1)
  {
    uint64_t v32 = (*((_DWORD *)this + 16) - 1);
    if ((int)v32 >= 1)
    {
      uint64_t v33 = 0;
      int v34 = 0;
      int v35 = *((_DWORD *)this + 16);
      unint64_t v37 = *((void *)this + 9);
      uint64_t v36 = *((void *)this + 10);
      unint64_t v38 = HIDWORD(v37);
      if (v36) {
        unint64_t v39 = (float *)(v36 + *((void *)this + 7));
      }
      else {
        unint64_t v39 = 0;
      }
      do
      {
        uint64_t v42 = 0;
        do
        {
          float v46 = v39[1];
          float v47 = v39[2];
          float v48 = v39[3];
          float v49 = v39[4];
          float v50 = (float)((float)((float)(*v39 + v46) + v47) + v48) + v49;
          if (v50 == 0.0)
          {
            uint64_t v86 = *((void *)this + 14);
            uint64_t v87 = *((void *)this + 11);
            int v89 = *((_DWORD *)this + 26);
            if (v30) {
              unsigned int v43 = v89 * v33 + *((_DWORD *)this + 27) * v42;
            }
            else {
              unsigned int v43 = v89 * v42 + *((_DWORD *)this + 27) * v33;
            }
            unsigned int v85 = -1;
          }
          else
          {
            float v51 = v31[v33] * *(float *)&v10[4 * v42];
            float v52 = *v39 / v51;
            float v53 = v46 / v51;
            float v54 = v47 / v51;
            float v55 = v48 / v51;
            float v56 = v50 / v51;
            float v57 = v49 / v51;
            if (v56 > 1.0)
            {
              float v52 = v52 / v56;
              float v53 = v53 / v56;
              float v54 = v54 / v56;
              float v55 = v55 / v56;
              float v57 = v57 / v56;
              float v56 = 1.0;
            }
            int v58 = (int)(float)((float)(1.0 - v56) * 255.0);
            if (v58 >= 255) {
              int v58 = 255;
            }
            unsigned int v59 = 16711935 * (v58 & ~(v58 >> 31));
            int v60 = (v59 >> 8) & 0xFF00FF;
            int v61 = v59 & 0xFF00;
            int v62 = (int)(float)(v57 * 255.0);
            if (v62 >= 255) {
              int v62 = 255;
            }
            int v63 = v62 & ~(v62 >> 31);
            unsigned int v65 = *((_DWORD *)this + 35);
            unsigned int v64 = *((_DWORD *)this + 36);
            unsigned int v66 = (((v64 & 0xFF00FF) * v63) >> 8) & 0xFF00FF;
            unsigned int v67 = (((v64 >> 8) & 0xFF00FF) * v63) & 0xFF00FF00;
            int v68 = (int)(float)(v55 * 255.0);
            if (v68 >= 255) {
              int v68 = 255;
            }
            int v69 = v68 & ~(v68 >> 31);
            unsigned int v70 = *((_DWORD *)this + 37);
            unsigned int v71 = (((v70 & 0xFF00FF) * v69) >> 8) & 0xFF00FF;
            unsigned int v72 = (((v70 >> 8) & 0xFF00FF) * v69) & 0xFF00FF00;
            int v73 = (int)(float)(v54 * 255.0);
            unsigned int v74 = *((_DWORD *)this + 39);
            if (v73 >= 255) {
              int v73 = 255;
            }
            int v75 = v73 & ~(v73 >> 31);
            unsigned int v76 = (((v74 & 0xFF00FF) * v75) >> 8) & 0xFF00FF;
            int v77 = ((v74 >> 8) & 0xFF00FF) * v75;
            int v78 = (int)(float)(v53 * 255.0);
            unsigned int v79 = v77 & 0xFF00FF00;
            if (v78 >= 255) {
              int v78 = 255;
            }
            int v80 = v78 & ~(v78 >> 31);
            unsigned int v81 = (((v65 & 0xFF00FF) * v80) >> 8) & 0xFF00FF;
            int v82 = ((v65 >> 8) & 0xFF00FF) * v80;
            int v83 = (int)(float)(v52 * 255.0);
            unsigned int v84 = v82 & 0xFF00FF00;
            if (v83 >= 255) {
              int v83 = 255;
            }
            unsigned int v85 = (v66 | v67)
                + v72
                + v71
                + v79
                + v76
                + v84
                + v81
                + v61
                + v60
                + ((((*((_DWORD *)this + 38) & 0xFF00FF) * (v83 & ~(v83 >> 31))) >> 8) & 0xFF00FF | (((*((_DWORD *)this + 38) >> 8) & 0xFF00FF) * (v83 & ~(v83 >> 31))) & 0xFF00FF00);
            uint64_t v86 = *((void *)this + 14);
            uint64_t v87 = *((void *)this + 11);
            int v88 = *((_DWORD *)this + 26);
            if (v30) {
              unsigned int v43 = v88 * v33 + *((_DWORD *)this + 27) * v42;
            }
            else {
              unsigned int v43 = v88 * v42 + *((_DWORD *)this + 27) * v33;
            }
          }
          *(_DWORD *)(v86 + v87 + v43) = v85;
          ++v42;
          uint8x8_t v44 = (float *)((char *)v39 + v37);
          int v45 = v34 + 1;
          unint64_t v39 = (float *)((char *)v44 + v38 - ((v34 + 1) * v37));
          if (v34 + 1 == v35) {
            int v34 = 0;
          }
          else {
            ++v34;
          }
          if (v45 != v35) {
            unint64_t v39 = v44;
          }
        }
        while (v32 != v42);
        uint64_t v40 = (float *)((char *)v39 + v37);
        int v41 = v34 + 1;
        unint64_t v39 = (float *)((char *)v40 + v38 - ((v34 + 1) * v37));
        if (v34 + 1 == v35) {
          int v34 = 0;
        }
        else {
          ++v34;
        }
        if (v41 != v35) {
          unint64_t v39 = v40;
        }
        ++v33;
      }
      while (v33 != v92);
    }
  }
  uint64_t v90 = (char *)this + 88;
  if (v31) {
    operator delete(v31);
  }
  if (v10) {
    operator delete(v10);
  }
  return v90;
}

unsigned char *cva::MatrixRasterizerEngine::getImageRGB@<X0>(cva::MatrixRasterizerEngine *this@<X0>, void *a2@<X8>)
{
  if (*((float *)this + 2) < 1.0)
  {
    unsigned int v3 = cva::MatrixRasterizerEngine::convertFloatImage(this);
LABEL_5:
    uint64_t v4 = v3;
    goto LABEL_7;
  }
  if (*((unsigned char *)this + 20))
  {
    unsigned int v3 = cva::MatrixRasterizerEngine::transposeRGBImage(this);
    goto LABEL_5;
  }
  uint64_t v4 = (char *)this + 24;
LABEL_7:
  uint64_t v6 = *((unsigned int *)v4 + 2);
  uint64_t v5 = *((unsigned int *)v4 + 3);
  uint64_t v7 = (3 * v6 + 15) & 0xFFFFFFF0;
  *a2 = 0;
  a2[1] = v6 | (v5 << 32);
  a2[2] = ((unint64_t)(((3 * v6 + 15) & 0xFFFFFFF0) >> 4) << 36) | 3;
  if (v5 * (unint64_t)v7)
  {
    float32x2_t result = malloc_type_malloc(v5 * (unint64_t)v7, 0xA153FF5uLL);
    int v9 = *((_DWORD *)v4 + 2);
    LODWORD(v5) = *((_DWORD *)v4 + 3);
  }
  else
  {
    float32x2_t result = 0;
    int v9 = v6;
  }
  a2[3] = result;
  int v10 = v5 * v9;
  if (v10 >= 1)
  {
    int v11 = 0;
    int v12 = 0;
    unint64_t v13 = *((void *)v4 + 2);
    uint64_t v14 = *((void *)v4 + 3);
    if (v14) {
      unsigned int v15 = (int *)(v14 + *(void *)v4);
    }
    else {
      unsigned int v15 = 0;
    }
    int v16 = *((_DWORD *)v4 + 2);
    do
    {
      int v17 = *v15;
      unsigned int v18 = *v15 >> 8;
      *float32x2_t result = BYTE2(*v15);
      result[1] = v18;
      result[2] = v17;
      unsigned int v15 = (int *)((char *)v15 + v13);
      int v19 = v11 + 1;
      if (v11 + 1 == v16) {
        int v11 = 0;
      }
      else {
        ++v11;
      }
      if (v19 == v16) {
        unsigned int v15 = (int *)((char *)v15 + HIDWORD(v13) - (v19 * v13));
      }
      float v20 = result + 3;
      int v21 = v12 + 1;
      float32x2_t result = &result[v7 + 3 - (3 * (v12 + 1))];
      if (v12 + 1 == v6) {
        int v12 = 0;
      }
      else {
        ++v12;
      }
      if (v21 != v6) {
        float32x2_t result = v20;
      }
      --v10;
    }
    while (v10);
  }
  return result;
}

uint64_t cva::MatrixRasterizerEngine::drawLargeElement(uint64_t this, int a2, int a3, int a4)
{
  int v4 = (int)(float)(*(float *)(this + 8) + 0.5);
  if (*(unsigned char *)(this + 20)) {
    int v5 = a2;
  }
  else {
    int v5 = a3;
  }
  if (*(unsigned char *)(this + 20)) {
    int v6 = a3;
  }
  else {
    int v6 = a2;
  }
  switch(a4)
  {
    case 0:
      uint64_t v7 = (int *)(this + 152);
      uint64_t v8 = (int *)(this + 132);
      break;
    case 1:
      uint64_t v7 = (int *)(this + 140);
      uint64_t v8 = (int *)(this + 120);
      break;
    case 2:
      uint64_t v7 = (int *)(this + 156);
      uint64_t v8 = (int *)(this + 136);
      break;
    case 3:
      uint64_t v7 = (int *)(this + 148);
      uint64_t v8 = (int *)(this + 128);
      break;
    default:
      uint64_t v7 = (int *)(this + 144);
      uint64_t v8 = (int *)(this + 124);
      break;
  }
  int v9 = v5 * v4;
  int v10 = *v8;
  int v11 = v6 * v4;
  if (v4 < 2)
  {
    *(_DWORD *)(*(void *)(this + 48)
              + *(void *)(this + 24)
              + (*(_DWORD *)(this + 40) * v9 + *(_DWORD *)(this + 44) * v11)) = v10;
  }
  else
  {
    int v12 = *v7;
    uint64_t v13 = *(void *)(this + 48);
    int v14 = 1;
    uint64_t v15 = *(void *)(this + 24);
    do
    {
      for (int i = 1; i != v4; ++i)
        *(_DWORD *)(v13 + v15 + (*(_DWORD *)(this + 40) * (v14 + v9) + *(_DWORD *)(this + 44) * (v11 + i))) = v12;
      ++v14;
    }
    while (v14 != v4);
    int v17 = v11 + v4;
    int v18 = v9 + v4;
    int v19 = v9;
    int v20 = v11;
    do
    {
      *(_DWORD *)(v13 + v15 + (*(_DWORD *)(this + 40) * v19++ + *(_DWORD *)(this + 44) * v11)) = v10;
      *(_DWORD *)(v13 + v15 + (*(_DWORD *)(this + 40) * v19 + *(_DWORD *)(this + 44) * v17)) = v10;
      *(_DWORD *)(v13 + v15 + (*(_DWORD *)(this + 40) * v9 + *(_DWORD *)(this + 44) * (v20 + 1))) = v10;
      *(_DWORD *)(v13 + v15 + (*(_DWORD *)(this + 40) * v18 + *(_DWORD *)(this + 44) * v20++)) = v10;
      --v4;
    }
    while (v4);
  }
  return this;
}

float cva::MatrixRasterizerEngine::drawSubpixelElement(cva::MatrixRasterizerEngine *this, unsigned int a2, unsigned int a3, unsigned int a4)
{
  float v4 = *((float *)this + 2);
  if (*((unsigned char *)this + 20)) {
    unsigned int v5 = a2;
  }
  else {
    unsigned int v5 = a3;
  }
  float v6 = (float)v5;
  if (*((unsigned char *)this + 20)) {
    unsigned int v7 = a3;
  }
  else {
    unsigned int v7 = a2;
  }
  float v8 = v4 * v6;
  float v9 = (float)v7;
  unsigned int v10 = v8;
  float v11 = v4 * v9;
  unsigned int v12 = v11;
  float v13 = v8 - (float)v8;
  float v14 = v11 - (float)v11;
  int v15 = *((_DWORD *)this + 18);
  int v16 = *((_DWORD *)this + 19);
  int v17 = v15 * v10;
  int v18 = v16 * v12;
  uint64_t v19 = *((void *)this + 10) + *((void *)this + 7);
  uint64_t v20 = 4 * a4;
  *(float *)(v19 + (v18 + v17) + v20) = *(float *)(v19 + (v18 + v17) + v20)
                                                    + (float)((float)(1.0 - v13) * (float)(1.0 - v14));
  *(float *)(v19 + (v15 + v17 + v18) + v20) = *(float *)(v19 + (v15 + v17 + v18) + v20)
                                                          + (float)(v13 * (float)(1.0 - v14));
  int v21 = v16 + v18;
  *(float *)(v19 + (v21 + v17) + v20) = *(float *)(v19 + (v21 + v17) + v20)
                                                    + (float)(v14 * (float)(1.0 - v13));
  uint64_t v22 = v19 + (v21 + v15 + v17);
  float result = (float)(v13 * v14) + *(float *)(v22 + v20);
  *(float *)(v22 + v20) = result;
  return result;
}

void cva::Sprintf::sprintf(cva::Sprintf *this@<X0>, uint64_t a2@<X8>, ...)
{
  va_start(va, a2);
  if (this)
  {
    int v5 = strlen((const char *)this);
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    int v6 = 2 * v5 + 50;
    *(void *)a2 = 0;
    while (1)
    {
      while (1)
      {
        std::string::resize((std::string *)a2, v6 + 1, 0);
        unsigned int v7 = *(char *)(a2 + 23) >= 0 ? (char *)a2 : *(char **)a2;
        int v8 = vsnprintf(v7, v6 + 1, (const char *)this, va);
        if ((v8 & 0x80000000) == 0) {
          break;
        }
        v6 *= 2;
      }
      if (v8 <= v6) {
        break;
      }
      int v6 = v8;
    }
    std::string::resize((std::string *)a2, v8, 0);
  }
  else
  {
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
  }
}

void cva::adp::io::Paths::imagePoints(char *a1@<X8>)
{
  a1[23] = 13;
  strcpy(a1, "image-points.");
}

void cva::adp::io::Paths::scenePoints(char *a1@<X8>)
{
  a1[23] = 16;
  strcpy(a1, "scene-points.txt");
}

void cva::adp::io::Paths::tracks(char *a1@<X8>)
{
  a1[23] = 10;
  strcpy(a1, "tracks.txt");
}

void cva::adp::io::Paths::encoder(char *a1@<X8>)
{
  a1[23] = 11;
  strcpy(a1, "encoder.txt");
}

void cva::adp::io::Paths::trajectory(char *a1@<X8>)
{
  a1[23] = 9;
  strcpy(a1, "WtoP.traj");
}

void cva::adp::io::Paths::sensorsDirectory(cva::adp::io::Paths *this, const cva::Path *a2)
{
  __s[23] = 8;
  strcpy(__s, "sensors/");
  operator new();
}

void cva::adp::io::Paths::sensorDirectory()
{
  __s[23] = 8;
  strcpy(__s, "sensors/");
  operator new();
}

void cva::adp::io::Paths::outputsDirectory(cva::adp::io::Paths *this, const cva::Path *a2)
{
  char v3 = 7;
  strcpy(__s, "output/");
  operator new();
}

void cva::adp::io::Paths::outputDirectory()
{
  char v1 = 7;
  strcpy(__s, "output/");
  operator new();
}

void cva::adp::io::Paths::sensorDirectory(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v5 = *(void *)(a2 + 8);
  uint64_t v3 = a2 + 8;
  uint64_t v4 = v5;
  if (v5)
  {
    uint64_t v6 = v3;
    do
    {
      unsigned int v7 = *(unsigned __int8 *)(v4 + 32);
      BOOL v8 = v7 >= a3;
      if (v7 >= a3) {
        float v9 = (uint64_t *)v4;
      }
      else {
        float v9 = (uint64_t *)(v4 + 8);
      }
      if (v8) {
        uint64_t v6 = v4;
      }
      uint64_t v4 = *v9;
    }
    while (*v9);
    if (v6 != v3 && *(unsigned __int8 *)(v6 + 32) <= a3)
    {
      char __s[23] = 8;
      strcpy(__s, "sensors/");
      operator new();
    }
  }
  *(void *)__s = "";
  sub_21543F31C();
}

void cva::adp::io::Paths::createOutputDirectory()
{
}

uint64_t cva::adp::io::Paths::createOutputDirectories(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v3 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    int v5 = *((char *)v3 + 63);
    if (v5 >= 0) {
      size_t v6 = *((unsigned __int8 *)v3 + 63);
    }
    else {
      size_t v6 = v3[6];
    }
    unint64_t v7 = v6 + 1;
    if (v6 + 1 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    if (v7 >= 0x17)
    {
      uint64_t v9 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v7 | 7) != 0x17) {
        uint64_t v9 = v7 | 7;
      }
      uint64_t v10 = v9 + 1;
      p_dst = (std::string *)operator new(v9 + 1);
      __dst.__r_.__value_.__l.__size_ = v6 + 1;
      __dst.__r_.__value_.__r.__words[2] = v10 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    }
    else
    {
      memset(&__dst, 0, sizeof(__dst));
      p_dst = &__dst;
      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v6 + 1;
      if (!v6) {
        goto LABEL_16;
      }
    }
    if (v5 >= 0) {
      float v11 = v3 + 5;
    }
    else {
      float v11 = (const void *)v3[5];
    }
    memmove(p_dst, v11, v6);
LABEL_16:
    *(_WORD *)((char *)&p_dst->__r_.__value_.__l.__data_ + v6) = 32;
    int v12 = *(char *)(a3 + 23);
    if (v12 >= 0) {
      float v13 = (const std::string::value_type *)a3;
    }
    else {
      float v13 = *(const std::string::value_type **)a3;
    }
    if (v12 >= 0) {
      std::string::size_type v14 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      std::string::size_type v14 = *(void *)(a3 + 8);
    }
    int v15 = std::string::append(&__dst, v13, v14);
    std::string::size_type v16 = v15->__r_.__value_.__r.__words[2];
    *(_OWORD *)long long __p = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
    std::string::size_type v20 = v16;
    v15->__r_.__value_.__l.__size_ = 0;
    v15->__r_.__value_.__r.__words[2] = 0;
    v15->__r_.__value_.__r.__words[0] = 0;
    cva::adp::io::Paths::outputDirectory();
  }
  return 1;
}

BOOL cva::experimental::copyPlane<unsigned char,2u>(uint64_t a1, uint64_t a2, unsigned int a3)
{
  srcChannels[1] = *(void **)MEMORY[0x263EF8340];
  uint64_t v7 = *(void *)(a2 + 24);
  uint64_t v3 = *(void *)(a2 + 8);
  v4.i64[0] = v3;
  v4.i64[1] = HIDWORD(v3);
  int8x16_t v8 = vextq_s8(v4, v4, 8uLL);
  uint64_t v9 = *(unsigned int *)(a2 + 20);
  int v5 = (void *)(*(void *)(a1 + 24) + a3);
  destPlanarBuffers = (vImage_Buffer *)&v7;
  srcChannels[0] = v5;
  return vImageConvert_ChunkyToPlanar8((const void **)srcChannels, (const vImage_Buffer **)&destPlanarBuffers, 1u, *(unsigned int *)(a1 + 16), *(unsigned int *)(a1 + 8), *(unsigned int *)(a1 + 12), *(unsigned int *)(a1 + 20), 0) == 0;
}

BOOL cva::experimental::copyPlane<unsigned char,3u>(uint64_t a1, uint64_t a2, unsigned int a3)
{
  srcChannels[1] = *(void **)MEMORY[0x263EF8340];
  uint64_t v7 = *(void *)(a2 + 24);
  uint64_t v3 = *(void *)(a2 + 8);
  v4.i64[0] = v3;
  v4.i64[1] = HIDWORD(v3);
  int8x16_t v8 = vextq_s8(v4, v4, 8uLL);
  uint64_t v9 = *(unsigned int *)(a2 + 20);
  int v5 = (void *)(*(void *)(a1 + 24) + a3);
  destPlanarBuffers = (vImage_Buffer *)&v7;
  srcChannels[0] = v5;
  return vImageConvert_ChunkyToPlanar8((const void **)srcChannels, (const vImage_Buffer **)&destPlanarBuffers, 1u, *(unsigned int *)(a1 + 16), *(unsigned int *)(a1 + 8), *(unsigned int *)(a1 + 12), *(unsigned int *)(a1 + 20), 0) == 0;
}

BOOL cva::experimental::copyPlane<unsigned char,4u>(uint64_t a1, uint64_t a2, unsigned int a3)
{
  srcChannels[1] = *(void **)MEMORY[0x263EF8340];
  uint64_t v7 = *(void *)(a2 + 24);
  uint64_t v3 = *(void *)(a2 + 8);
  v4.i64[0] = v3;
  v4.i64[1] = HIDWORD(v3);
  int8x16_t v8 = vextq_s8(v4, v4, 8uLL);
  uint64_t v9 = *(unsigned int *)(a2 + 20);
  int v5 = (void *)(*(void *)(a1 + 24) + a3);
  destPlanarBuffers = (vImage_Buffer *)&v7;
  srcChannels[0] = v5;
  return vImageConvert_ChunkyToPlanar8((const void **)srcChannels, (const vImage_Buffer **)&destPlanarBuffers, 1u, *(unsigned int *)(a1 + 16), *(unsigned int *)(a1 + 8), *(unsigned int *)(a1 + 12), *(unsigned int *)(a1 + 20), 0) == 0;
}

BOOL cva::experimental::copyPlane<float,2u>(uint64_t a1, uint64_t a2, unsigned int a3)
{
  srcChannels[1] = *(void **)MEMORY[0x263EF8340];
  uint64_t v7 = *(void *)(a2 + 24);
  uint64_t v3 = *(void *)(a2 + 8);
  v4.i64[0] = v3;
  v4.i64[1] = HIDWORD(v3);
  int8x16_t v8 = vextq_s8(v4, v4, 8uLL);
  uint64_t v9 = *(unsigned int *)(a2 + 20);
  int v5 = (void *)(*(void *)(a1 + 24) + 4 * a3);
  destPlanarBuffers = (vImage_Buffer *)&v7;
  srcChannels[0] = v5;
  return vImageConvert_ChunkyToPlanarF((const void **)srcChannels, (const vImage_Buffer **)&destPlanarBuffers, 1u, *(unsigned int *)(a1 + 16), *(unsigned int *)(a1 + 8), *(unsigned int *)(a1 + 12), *(unsigned int *)(a1 + 20), 0) == 0;
}

BOOL cva::experimental::copyPlane<float,3u>(uint64_t a1, uint64_t a2, unsigned int a3)
{
  srcChannels[1] = *(void **)MEMORY[0x263EF8340];
  uint64_t v7 = *(void *)(a2 + 24);
  uint64_t v3 = *(void *)(a2 + 8);
  v4.i64[0] = v3;
  v4.i64[1] = HIDWORD(v3);
  int8x16_t v8 = vextq_s8(v4, v4, 8uLL);
  uint64_t v9 = *(unsigned int *)(a2 + 20);
  int v5 = (void *)(*(void *)(a1 + 24) + 4 * a3);
  destPlanarBuffers = (vImage_Buffer *)&v7;
  srcChannels[0] = v5;
  return vImageConvert_ChunkyToPlanarF((const void **)srcChannels, (const vImage_Buffer **)&destPlanarBuffers, 1u, *(unsigned int *)(a1 + 16), *(unsigned int *)(a1 + 8), *(unsigned int *)(a1 + 12), *(unsigned int *)(a1 + 20), 0) == 0;
}

BOOL cva::experimental::copyPlane<float,4u>(uint64_t a1, uint64_t a2, unsigned int a3)
{
  srcChannels[1] = *(void **)MEMORY[0x263EF8340];
  uint64_t v7 = *(void *)(a2 + 24);
  uint64_t v3 = *(void *)(a2 + 8);
  v4.i64[0] = v3;
  v4.i64[1] = HIDWORD(v3);
  int8x16_t v8 = vextq_s8(v4, v4, 8uLL);
  uint64_t v9 = *(unsigned int *)(a2 + 20);
  int v5 = (void *)(*(void *)(a1 + 24) + 4 * a3);
  destPlanarBuffers = (vImage_Buffer *)&v7;
  srcChannels[0] = v5;
  return vImageConvert_ChunkyToPlanarF((const void **)srcChannels, (const vImage_Buffer **)&destPlanarBuffers, 1u, *(unsigned int *)(a1 + 16), *(unsigned int *)(a1 + 8), *(unsigned int *)(a1 + 12), *(unsigned int *)(a1 + 20), 0) == 0;
}

BOOL cva::experimental::extractPlanes<unsigned char,2u,2ul>(uint64_t a1, uint64_t a2)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  unint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = HIDWORD(v4);
  if (v4 > *(_DWORD *)(a2 + 8) || HIDWORD(v4) > *(_DWORD *)(a2 + 12))
  {
    uint64_t v7 = *(void **)(a2 + 24);
    if (v7)
    {
      free(v7);
      *(void *)(a2 + 24) = 0;
    }
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = v4;
    *(void *)(a2 + 16) = ((unint64_t)(((v4 + 15) & 0xFFFFFFF0) >> 4) << 36) | 1;
    size_t size = ((v4 + 15) & 0xFFFFFFF0) * (unint64_t)HIDWORD(v4);
    if (size)
    {
      int8x16_t v8 = malloc_type_malloc(size, 0xA153FF5uLL);
      LODWORD(v4) = *(_DWORD *)(a2 + 8);
      LODWORD(v5) = *(_DWORD *)(a2 + 12);
    }
    else
    {
      int8x16_t v8 = 0;
    }
    *(void *)(a2 + 24) = v8;
  }
  else
  {
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = v4;
    int8x16_t v8 = *(void **)(a2 + 24);
  }
  srcChannels = *(void **)(a1 + 24);
  uint64_t v20 = 0;
  uint64_t v9 = *(unsigned int *)(a2 + 20);
  v16[0] = v8;
  v16[1] = v5;
  _OWORD v16[2] = v4;
  _DWORD v16[3] = v9;
  destPlanarBuffers = (vImage_Buffer *)v16;
  uint64_t v22 = 0;
  unint64_t v10 = *(void *)(a1 + 8);
  unint64_t v11 = HIDWORD(v10);
  if (v10 > *(_DWORD *)(a2 + 40) || HIDWORD(v10) > *(_DWORD *)(a2 + 44))
  {
    float v13 = *(void **)(a2 + 56);
    if (v13)
    {
      free(v13);
      *(void *)(a2 + 56) = 0;
    }
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 40) = v10;
    *(void *)(a2 + 48) = ((unint64_t)(((v10 + 15) & 0xFFFFFFF0) >> 4) << 36) | 1;
    size_t size = ((v10 + 15) & 0xFFFFFFF0) * (unint64_t)HIDWORD(v10);
    if (size)
    {
      int v12 = malloc_type_malloc(size, 0xA153FF5uLL);
      LODWORD(v10) = *(_DWORD *)(a2 + 40);
      LODWORD(v11) = *(_DWORD *)(a2 + 44);
    }
    else
    {
      int v12 = 0;
    }
    *(void *)(a2 + 56) = v12;
  }
  else
  {
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 40) = v10;
    int v12 = *(void **)(a2 + 56);
  }
  uint64_t v20 = *(void *)(a1 + 24) + 1;
  uint64_t v14 = *(unsigned int *)(a2 + 52);
  v17[0] = v12;
  v17[1] = v11;
  void v17[2] = v10;
  unsigned int v17[3] = v14;
  uint64_t v22 = v17;
  return vImageConvert_ChunkyToPlanar8((const void **)&srcChannels, (const vImage_Buffer **)&destPlanarBuffers, 2u, *(unsigned int *)(a1 + 16), *(unsigned int *)(a1 + 8), *(unsigned int *)(a1 + 12), *(unsigned int *)(a1 + 20), 0) == 0;
}

BOOL sub_21540AE34(uint64_t a1, uint64_t a2)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  unint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = HIDWORD(v4);
  if (v4 > *(_DWORD *)(a2 + 8) || HIDWORD(v4) > *(_DWORD *)(a2 + 12))
  {
    uint64_t v7 = *(void **)(a2 + 24);
    if (v7)
    {
      free(v7);
      *(void *)(a2 + 24) = 0;
    }
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = v4;
    *(void *)(a2 + 16) = ((unint64_t)(((v4 + 15) & 0xFFFFFFF0) >> 4) << 36) | 1;
    size_t size = ((v4 + 15) & 0xFFFFFFF0) * (unint64_t)HIDWORD(v4);
    if (size)
    {
      int8x16_t v8 = malloc_type_malloc(size, 0xA153FF5uLL);
      LODWORD(v4) = *(_DWORD *)(a2 + 8);
      LODWORD(v5) = *(_DWORD *)(a2 + 12);
    }
    else
    {
      int8x16_t v8 = 0;
    }
    *(void *)(a2 + 24) = v8;
  }
  else
  {
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = v4;
    int8x16_t v8 = *(void **)(a2 + 24);
  }
  float v29 = 0;
  int v30 = 0;
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  srcChannels = *(void **)(a1 + 24);
  uint64_t v9 = *(unsigned int *)(a2 + 20);
  v21[0] = v8;
  v21[1] = v5;
  v21[2] = v4;
  v21[3] = v9;
  destPlanarBuffers = (vImage_Buffer *)v21;
  unint64_t v10 = *(void *)(a1 + 8);
  unint64_t v11 = HIDWORD(v10);
  if (v10 > *(_DWORD *)(a2 + 40) || HIDWORD(v10) > *(_DWORD *)(a2 + 44))
  {
    float v13 = *(void **)(a2 + 56);
    if (v13)
    {
      free(v13);
      *(void *)(a2 + 56) = 0;
    }
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 40) = v10;
    *(void *)(a2 + 48) = ((unint64_t)(((v10 + 15) & 0xFFFFFFF0) >> 4) << 36) | 1;
    size_t size = ((v10 + 15) & 0xFFFFFFF0) * (unint64_t)HIDWORD(v10);
    if (size)
    {
      int v12 = malloc_type_malloc(size, 0xA153FF5uLL);
      LODWORD(v10) = *(_DWORD *)(a2 + 40);
      LODWORD(v11) = *(_DWORD *)(a2 + 44);
    }
    else
    {
      int v12 = 0;
    }
    *(void *)(a2 + 56) = v12;
  }
  else
  {
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 40) = v10;
    int v12 = *(void **)(a2 + 56);
  }
  uint64_t v26 = *(void *)(a1 + 24) + 1;
  uint64_t v14 = *(unsigned int *)(a2 + 52);
  v22[0] = v12;
  v22[1] = v11;
  v22[2] = v10;
  v22[3] = v14;
  float v29 = v22;
  unint64_t v15 = *(void *)(a1 + 8);
  unint64_t v16 = HIDWORD(v15);
  if (v15 > *(_DWORD *)(a2 + 72) || HIDWORD(v15) > *(_DWORD *)(a2 + 76))
  {
    int v18 = *(void **)(a2 + 88);
    if (v18)
    {
      free(v18);
      *(void *)(a2 + 88) = 0;
    }
    *(void *)(a2 + 64) = 0;
    *(void *)(a2 + 72) = v15;
    *(void *)(a2 + 80) = ((unint64_t)(((v15 + 15) & 0xFFFFFFF0) >> 4) << 36) | 1;
    size_t size = ((v15 + 15) & 0xFFFFFFF0) * (unint64_t)HIDWORD(v15);
    if (size)
    {
      int v17 = malloc_type_malloc(size, 0xA153FF5uLL);
      LODWORD(v15) = *(_DWORD *)(a2 + 72);
      LODWORD(v16) = *(_DWORD *)(a2 + 76);
    }
    else
    {
      int v17 = 0;
    }
    *(void *)(a2 + 88) = v17;
  }
  else
  {
    *(void *)(a2 + 64) = 0;
    *(void *)(a2 + 72) = v15;
    int v17 = *(void **)(a2 + 88);
  }
  uint64_t v27 = *(void *)(a1 + 24) + 2;
  uint64_t v19 = *(unsigned int *)(a2 + 84);
  v23[0] = v17;
  v23[1] = v16;
  v23[2] = v15;
  v23[3] = v19;
  int v30 = v23;
  return vImageConvert_ChunkyToPlanar8((const void **)&srcChannels, (const vImage_Buffer **)&destPlanarBuffers, 3u, *(unsigned int *)(a1 + 16), *(unsigned int *)(a1 + 8), *(unsigned int *)(a1 + 12), *(unsigned int *)(a1 + 20), 0) == 0;
}

BOOL sub_21540B0F4(uint64_t a1, uint64_t a2)
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  unint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = HIDWORD(v4);
  if (v4 > *(_DWORD *)(a2 + 8) || HIDWORD(v4) > *(_DWORD *)(a2 + 12))
  {
    uint64_t v7 = *(void **)(a2 + 24);
    if (v7)
    {
      free(v7);
      *(void *)(a2 + 24) = 0;
    }
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = v4;
    *(void *)(a2 + 16) = ((unint64_t)(((v4 + 15) & 0xFFFFFFF0) >> 4) << 36) | 1;
    size_t size = ((v4 + 15) & 0xFFFFFFF0) * (unint64_t)HIDWORD(v4);
    if (size)
    {
      int8x16_t v8 = malloc_type_malloc(size, 0xA153FF5uLL);
      LODWORD(v4) = *(_DWORD *)(a2 + 8);
      LODWORD(v5) = *(_DWORD *)(a2 + 12);
    }
    else
    {
      int8x16_t v8 = 0;
    }
    *(void *)(a2 + 24) = v8;
  }
  else
  {
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = v4;
    int8x16_t v8 = *(void **)(a2 + 24);
  }
  uint64_t v36 = 0;
  unint64_t v37 = 0;
  unint64_t v38 = 0;
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  uint64_t v32 = 0;
  srcChannels = *(void **)(a1 + 24);
  uint64_t v9 = *(unsigned int *)(a2 + 20);
  v26[0] = v8;
  v26[1] = v5;
  void v26[2] = v4;
  v26[3] = v9;
  destPlanarBuffers = (vImage_Buffer *)v26;
  unint64_t v10 = *(void *)(a1 + 8);
  unint64_t v11 = HIDWORD(v10);
  if (v10 > *(_DWORD *)(a2 + 40) || HIDWORD(v10) > *(_DWORD *)(a2 + 44))
  {
    float v13 = *(void **)(a2 + 56);
    if (v13)
    {
      free(v13);
      *(void *)(a2 + 56) = 0;
    }
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 40) = v10;
    *(void *)(a2 + 48) = ((unint64_t)(((v10 + 15) & 0xFFFFFFF0) >> 4) << 36) | 1;
    size_t size = ((v10 + 15) & 0xFFFFFFF0) * (unint64_t)HIDWORD(v10);
    if (size)
    {
      int v12 = malloc_type_malloc(size, 0xA153FF5uLL);
      LODWORD(v10) = *(_DWORD *)(a2 + 40);
      LODWORD(v11) = *(_DWORD *)(a2 + 44);
    }
    else
    {
      int v12 = 0;
    }
    *(void *)(a2 + 56) = v12;
  }
  else
  {
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 40) = v10;
    int v12 = *(void **)(a2 + 56);
  }
  uint64_t v32 = *(void *)(a1 + 24) + 1;
  uint64_t v14 = *(unsigned int *)(a2 + 52);
  v27[0] = v12;
  v27[1] = v11;
  v27[2] = v10;
  v27[3] = v14;
  uint64_t v36 = v27;
  unint64_t v15 = *(void *)(a1 + 8);
  unint64_t v16 = HIDWORD(v15);
  if (v15 > *(_DWORD *)(a2 + 72) || HIDWORD(v15) > *(_DWORD *)(a2 + 76))
  {
    int v18 = *(void **)(a2 + 88);
    if (v18)
    {
      free(v18);
      *(void *)(a2 + 88) = 0;
    }
    *(void *)(a2 + 64) = 0;
    *(void *)(a2 + 72) = v15;
    *(void *)(a2 + 80) = ((unint64_t)(((v15 + 15) & 0xFFFFFFF0) >> 4) << 36) | 1;
    size_t size = ((v15 + 15) & 0xFFFFFFF0) * (unint64_t)HIDWORD(v15);
    if (size)
    {
      int v17 = malloc_type_malloc(size, 0xA153FF5uLL);
      LODWORD(v15) = *(_DWORD *)(a2 + 72);
      LODWORD(v16) = *(_DWORD *)(a2 + 76);
    }
    else
    {
      int v17 = 0;
    }
    *(void *)(a2 + 88) = v17;
  }
  else
  {
    *(void *)(a2 + 64) = 0;
    *(void *)(a2 + 72) = v15;
    int v17 = *(void **)(a2 + 88);
  }
  uint64_t v33 = *(void *)(a1 + 24) + 2;
  uint64_t v19 = *(unsigned int *)(a2 + 84);
  v28[0] = v17;
  v28[1] = v16;
  void v28[2] = v15;
  v28[3] = v19;
  unint64_t v37 = v28;
  unint64_t v20 = *(void *)(a1 + 8);
  unint64_t v21 = HIDWORD(v20);
  if (v20 > *(_DWORD *)(a2 + 104) || HIDWORD(v20) > *(_DWORD *)(a2 + 108))
  {
    uint64_t v23 = *(void **)(a2 + 120);
    if (v23)
    {
      free(v23);
      *(void *)(a2 + 120) = 0;
    }
    *(void *)(a2 + 96) = 0;
    *(void *)(a2 + 104) = v20;
    *(void *)(a2 + 112) = ((unint64_t)(((v20 + 15) & 0xFFFFFFF0) >> 4) << 36) | 1;
    size_t size = ((v20 + 15) & 0xFFFFFFF0) * (unint64_t)HIDWORD(v20);
    if (size)
    {
      uint64_t v22 = malloc_type_malloc(size, 0xA153FF5uLL);
      LODWORD(v20) = *(_DWORD *)(a2 + 104);
      LODWORD(v21) = *(_DWORD *)(a2 + 108);
    }
    else
    {
      uint64_t v22 = 0;
    }
    *(void *)(a2 + 120) = v22;
  }
  else
  {
    *(void *)(a2 + 96) = 0;
    *(void *)(a2 + 104) = v20;
    uint64_t v22 = *(void **)(a2 + 120);
  }
  uint64_t v34 = *(void *)(a1 + 24) + 3;
  uint64_t v24 = *(unsigned int *)(a2 + 116);
  v29[0] = v22;
  v29[1] = v21;
  void v29[2] = v20;
  v29[3] = v24;
  unint64_t v38 = v29;
  return vImageConvert_ChunkyToPlanar8((const void **)&srcChannels, (const vImage_Buffer **)&destPlanarBuffers, 4u, *(unsigned int *)(a1 + 16), *(unsigned int *)(a1 + 8), *(unsigned int *)(a1 + 12), *(unsigned int *)(a1 + 20), 0) == 0;
}

BOOL cva::experimental::copyPlane<unsigned char,3u>(void *a1, uint64_t a2, unsigned int a3)
{
  srcChannels[1] = *(void **)MEMORY[0x263EF8340];
  unint64_t v3 = a1[1];
  unint64_t v4 = a1[2];
  uint64_t v5 = a1[3];
  uint64_t v9 = *(void *)(a2 + 24);
  uint64_t v6 = *(void *)(a2 + 8);
  v7.i64[0] = v6;
  v7.i64[1] = HIDWORD(v6);
  int8x16_t v10 = vextq_s8(v7, v7, 8uLL);
  uint64_t v11 = *(unsigned int *)(a2 + 20);
  destPlanarBuffers = (vImage_Buffer *)&v9;
  srcChannels[0] = (void *)(v5 + a3);
  return vImageConvert_ChunkyToPlanar8((const void **)srcChannels, (const vImage_Buffer **)&destPlanarBuffers, 1u, v4, v3, HIDWORD(v3), HIDWORD(v4), 0) == 0;
}

BOOL cva::experimental::extractPlanes<unsigned char,3u,3ul>(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 24);
  uint64_t v4 = 0;
  long long v5 = *(_OWORD *)(a1 + 8);
  uint64_t v6 = v2;
  return sub_21540AE34((uint64_t)&v4, a2);
}

BOOL cva::experimental::extractPlanes<unsigned char,4u,4ul>(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 24);
  uint64_t v4 = 0;
  long long v5 = *(_OWORD *)(a1 + 8);
  uint64_t v6 = v2;
  return sub_21540B0F4((uint64_t)&v4, a2);
}

BOOL cva::experimental::extractPlanes<float,2u,2ul>(uint64_t a1, uint64_t a2)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  unint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = HIDWORD(v4);
  if (v4 > *(_DWORD *)(a2 + 8) || HIDWORD(v4) > *(_DWORD *)(a2 + 12))
  {
    int8x16_t v7 = *(void **)(a2 + 24);
    if (v7)
    {
      free(v7);
      *(void *)(a2 + 24) = 0;
    }
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = v4;
    *(void *)(a2 + 16) = ((unint64_t)(((4 * v4 + 15) & 0xFFFFFFF0) >> 4) << 36) | 4;
    size_t size = ((4 * v4 + 15) & 0xFFFFFFF0) * (unint64_t)HIDWORD(v4);
    if (size)
    {
      int8x16_t v8 = malloc_type_malloc(size, 0xA153FF5uLL);
      LODWORD(v4) = *(_DWORD *)(a2 + 8);
      LODWORD(v5) = *(_DWORD *)(a2 + 12);
    }
    else
    {
      int8x16_t v8 = 0;
    }
    *(void *)(a2 + 24) = v8;
  }
  else
  {
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = v4;
    int8x16_t v8 = *(void **)(a2 + 24);
  }
  srcChannels = *(void **)(a1 + 24);
  uint64_t v20 = 0;
  uint64_t v9 = *(unsigned int *)(a2 + 20);
  v16[0] = v8;
  v16[1] = v5;
  _OWORD v16[2] = v4;
  _DWORD v16[3] = v9;
  destPlanarBuffers = (vImage_Buffer *)v16;
  uint64_t v22 = 0;
  unint64_t v10 = *(void *)(a1 + 8);
  unint64_t v11 = HIDWORD(v10);
  if (v10 > *(_DWORD *)(a2 + 40) || HIDWORD(v10) > *(_DWORD *)(a2 + 44))
  {
    float v13 = *(void **)(a2 + 56);
    if (v13)
    {
      free(v13);
      *(void *)(a2 + 56) = 0;
    }
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 40) = v10;
    *(void *)(a2 + 48) = ((unint64_t)(((4 * v10 + 15) & 0xFFFFFFF0) >> 4) << 36) | 4;
    size_t size = ((4 * v10 + 15) & 0xFFFFFFF0) * (unint64_t)HIDWORD(v10);
    if (size)
    {
      int v12 = malloc_type_malloc(size, 0xA153FF5uLL);
      LODWORD(v10) = *(_DWORD *)(a2 + 40);
      LODWORD(v11) = *(_DWORD *)(a2 + 44);
    }
    else
    {
      int v12 = 0;
    }
    *(void *)(a2 + 56) = v12;
  }
  else
  {
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 40) = v10;
    int v12 = *(void **)(a2 + 56);
  }
  uint64_t v20 = *(void *)(a1 + 24) + 4;
  uint64_t v14 = *(unsigned int *)(a2 + 52);
  v17[0] = v12;
  v17[1] = v11;
  void v17[2] = v10;
  unsigned int v17[3] = v14;
  uint64_t v22 = v17;
  return vImageConvert_ChunkyToPlanarF((const void **)&srcChannels, (const vImage_Buffer **)&destPlanarBuffers, 2u, *(unsigned int *)(a1 + 16), *(unsigned int *)(a1 + 8), *(unsigned int *)(a1 + 12), *(unsigned int *)(a1 + 20), 0) == 0;
}

BOOL cva::experimental::extractPlanes<float,3u,3ul>(uint64_t a1, uint64_t a2)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  unint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = HIDWORD(v4);
  if (v4 > *(_DWORD *)(a2 + 8) || HIDWORD(v4) > *(_DWORD *)(a2 + 12))
  {
    int8x16_t v7 = *(void **)(a2 + 24);
    if (v7)
    {
      free(v7);
      *(void *)(a2 + 24) = 0;
    }
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = v4;
    *(void *)(a2 + 16) = ((unint64_t)(((4 * v4 + 15) & 0xFFFFFFF0) >> 4) << 36) | 4;
    size_t size = ((4 * v4 + 15) & 0xFFFFFFF0) * (unint64_t)HIDWORD(v4);
    if (size)
    {
      int8x16_t v8 = malloc_type_malloc(size, 0xA153FF5uLL);
      LODWORD(v4) = *(_DWORD *)(a2 + 8);
      LODWORD(v5) = *(_DWORD *)(a2 + 12);
    }
    else
    {
      int8x16_t v8 = 0;
    }
    *(void *)(a2 + 24) = v8;
  }
  else
  {
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = v4;
    int8x16_t v8 = *(void **)(a2 + 24);
  }
  float v29 = 0;
  int v30 = 0;
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  srcChannels = *(void **)(a1 + 24);
  uint64_t v9 = *(unsigned int *)(a2 + 20);
  v21[0] = v8;
  v21[1] = v5;
  v21[2] = v4;
  v21[3] = v9;
  destPlanarBuffers = (vImage_Buffer *)v21;
  unint64_t v10 = *(void *)(a1 + 8);
  unint64_t v11 = HIDWORD(v10);
  if (v10 > *(_DWORD *)(a2 + 40) || HIDWORD(v10) > *(_DWORD *)(a2 + 44))
  {
    float v13 = *(void **)(a2 + 56);
    if (v13)
    {
      free(v13);
      *(void *)(a2 + 56) = 0;
    }
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 40) = v10;
    *(void *)(a2 + 48) = ((unint64_t)(((4 * v10 + 15) & 0xFFFFFFF0) >> 4) << 36) | 4;
    size_t size = ((4 * v10 + 15) & 0xFFFFFFF0) * (unint64_t)HIDWORD(v10);
    if (size)
    {
      int v12 = malloc_type_malloc(size, 0xA153FF5uLL);
      LODWORD(v10) = *(_DWORD *)(a2 + 40);
      LODWORD(v11) = *(_DWORD *)(a2 + 44);
    }
    else
    {
      int v12 = 0;
    }
    *(void *)(a2 + 56) = v12;
  }
  else
  {
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 40) = v10;
    int v12 = *(void **)(a2 + 56);
  }
  uint64_t v26 = *(void *)(a1 + 24) + 4;
  uint64_t v14 = *(unsigned int *)(a2 + 52);
  v22[0] = v12;
  v22[1] = v11;
  v22[2] = v10;
  v22[3] = v14;
  float v29 = v22;
  unint64_t v15 = *(void *)(a1 + 8);
  unint64_t v16 = HIDWORD(v15);
  if (v15 > *(_DWORD *)(a2 + 72) || HIDWORD(v15) > *(_DWORD *)(a2 + 76))
  {
    int v18 = *(void **)(a2 + 88);
    if (v18)
    {
      free(v18);
      *(void *)(a2 + 88) = 0;
    }
    *(void *)(a2 + 64) = 0;
    *(void *)(a2 + 72) = v15;
    *(void *)(a2 + 80) = ((unint64_t)(((4 * v15 + 15) & 0xFFFFFFF0) >> 4) << 36) | 4;
    size_t size = ((4 * v15 + 15) & 0xFFFFFFF0) * (unint64_t)HIDWORD(v15);
    if (size)
    {
      int v17 = malloc_type_malloc(size, 0xA153FF5uLL);
      LODWORD(v15) = *(_DWORD *)(a2 + 72);
      LODWORD(v16) = *(_DWORD *)(a2 + 76);
    }
    else
    {
      int v17 = 0;
    }
    *(void *)(a2 + 88) = v17;
  }
  else
  {
    *(void *)(a2 + 64) = 0;
    *(void *)(a2 + 72) = v15;
    int v17 = *(void **)(a2 + 88);
  }
  uint64_t v27 = *(void *)(a1 + 24) + 8;
  uint64_t v19 = *(unsigned int *)(a2 + 84);
  v23[0] = v17;
  v23[1] = v16;
  v23[2] = v15;
  v23[3] = v19;
  int v30 = v23;
  return vImageConvert_ChunkyToPlanarF((const void **)&srcChannels, (const vImage_Buffer **)&destPlanarBuffers, 3u, *(unsigned int *)(a1 + 16), *(unsigned int *)(a1 + 8), *(unsigned int *)(a1 + 12), *(unsigned int *)(a1 + 20), 0) == 0;
}

BOOL cva::experimental::extractPlanes<float,4u,4ul>(uint64_t a1, uint64_t a2)
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  unint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = HIDWORD(v4);
  if (v4 > *(_DWORD *)(a2 + 8) || HIDWORD(v4) > *(_DWORD *)(a2 + 12))
  {
    int8x16_t v7 = *(void **)(a2 + 24);
    if (v7)
    {
      free(v7);
      *(void *)(a2 + 24) = 0;
    }
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = v4;
    *(void *)(a2 + 16) = ((unint64_t)(((4 * v4 + 15) & 0xFFFFFFF0) >> 4) << 36) | 4;
    size_t size = ((4 * v4 + 15) & 0xFFFFFFF0) * (unint64_t)HIDWORD(v4);
    if (size)
    {
      int8x16_t v8 = malloc_type_malloc(size, 0xA153FF5uLL);
      LODWORD(v4) = *(_DWORD *)(a2 + 8);
      LODWORD(v5) = *(_DWORD *)(a2 + 12);
    }
    else
    {
      int8x16_t v8 = 0;
    }
    *(void *)(a2 + 24) = v8;
  }
  else
  {
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = v4;
    int8x16_t v8 = *(void **)(a2 + 24);
  }
  uint64_t v36 = 0;
  unint64_t v37 = 0;
  unint64_t v38 = 0;
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  uint64_t v32 = 0;
  srcChannels = *(void **)(a1 + 24);
  uint64_t v9 = *(unsigned int *)(a2 + 20);
  v26[0] = v8;
  v26[1] = v5;
  void v26[2] = v4;
  v26[3] = v9;
  destPlanarBuffers = (vImage_Buffer *)v26;
  unint64_t v10 = *(void *)(a1 + 8);
  unint64_t v11 = HIDWORD(v10);
  if (v10 > *(_DWORD *)(a2 + 40) || HIDWORD(v10) > *(_DWORD *)(a2 + 44))
  {
    float v13 = *(void **)(a2 + 56);
    if (v13)
    {
      free(v13);
      *(void *)(a2 + 56) = 0;
    }
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 40) = v10;
    *(void *)(a2 + 48) = ((unint64_t)(((4 * v10 + 15) & 0xFFFFFFF0) >> 4) << 36) | 4;
    size_t size = ((4 * v10 + 15) & 0xFFFFFFF0) * (unint64_t)HIDWORD(v10);
    if (size)
    {
      int v12 = malloc_type_malloc(size, 0xA153FF5uLL);
      LODWORD(v10) = *(_DWORD *)(a2 + 40);
      LODWORD(v11) = *(_DWORD *)(a2 + 44);
    }
    else
    {
      int v12 = 0;
    }
    *(void *)(a2 + 56) = v12;
  }
  else
  {
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 40) = v10;
    int v12 = *(void **)(a2 + 56);
  }
  uint64_t v32 = *(void *)(a1 + 24) + 4;
  uint64_t v14 = *(unsigned int *)(a2 + 52);
  v27[0] = v12;
  v27[1] = v11;
  v27[2] = v10;
  v27[3] = v14;
  uint64_t v36 = v27;
  unint64_t v15 = *(void *)(a1 + 8);
  unint64_t v16 = HIDWORD(v15);
  if (v15 > *(_DWORD *)(a2 + 72) || HIDWORD(v15) > *(_DWORD *)(a2 + 76))
  {
    int v18 = *(void **)(a2 + 88);
    if (v18)
    {
      free(v18);
      *(void *)(a2 + 88) = 0;
    }
    *(void *)(a2 + 64) = 0;
    *(void *)(a2 + 72) = v15;
    *(void *)(a2 + 80) = ((unint64_t)(((4 * v15 + 15) & 0xFFFFFFF0) >> 4) << 36) | 4;
    size_t size = ((4 * v15 + 15) & 0xFFFFFFF0) * (unint64_t)HIDWORD(v15);
    if (size)
    {
      int v17 = malloc_type_malloc(size, 0xA153FF5uLL);
      LODWORD(v15) = *(_DWORD *)(a2 + 72);
      LODWORD(v16) = *(_DWORD *)(a2 + 76);
    }
    else
    {
      int v17 = 0;
    }
    *(void *)(a2 + 88) = v17;
  }
  else
  {
    *(void *)(a2 + 64) = 0;
    *(void *)(a2 + 72) = v15;
    int v17 = *(void **)(a2 + 88);
  }
  uint64_t v33 = *(void *)(a1 + 24) + 8;
  uint64_t v19 = *(unsigned int *)(a2 + 84);
  v28[0] = v17;
  v28[1] = v16;
  void v28[2] = v15;
  v28[3] = v19;
  unint64_t v37 = v28;
  unint64_t v20 = *(void *)(a1 + 8);
  unint64_t v21 = HIDWORD(v20);
  if (v20 > *(_DWORD *)(a2 + 104) || HIDWORD(v20) > *(_DWORD *)(a2 + 108))
  {
    uint64_t v23 = *(void **)(a2 + 120);
    if (v23)
    {
      free(v23);
      *(void *)(a2 + 120) = 0;
    }
    *(void *)(a2 + 96) = 0;
    *(void *)(a2 + 104) = v20;
    *(void *)(a2 + 112) = ((unint64_t)(((4 * v20 + 15) & 0xFFFFFFF0) >> 4) << 36) | 4;
    size_t size = ((4 * v20 + 15) & 0xFFFFFFF0) * (unint64_t)HIDWORD(v20);
    if (size)
    {
      uint64_t v22 = malloc_type_malloc(size, 0xA153FF5uLL);
      LODWORD(v20) = *(_DWORD *)(a2 + 104);
      LODWORD(v21) = *(_DWORD *)(a2 + 108);
    }
    else
    {
      uint64_t v22 = 0;
    }
    *(void *)(a2 + 120) = v22;
  }
  else
  {
    *(void *)(a2 + 96) = 0;
    *(void *)(a2 + 104) = v20;
    uint64_t v22 = *(void **)(a2 + 120);
  }
  uint64_t v34 = *(void *)(a1 + 24) + 12;
  uint64_t v24 = *(unsigned int *)(a2 + 116);
  v29[0] = v22;
  v29[1] = v21;
  void v29[2] = v20;
  v29[3] = v24;
  unint64_t v38 = v29;
  return vImageConvert_ChunkyToPlanarF((const void **)&srcChannels, (const vImage_Buffer **)&destPlanarBuffers, 4u, *(unsigned int *)(a1 + 16), *(unsigned int *)(a1 + 8), *(unsigned int *)(a1 + 12), *(unsigned int *)(a1 + 20), 0) == 0;
}

BOOL cva::experimental::convertPlanar16uToPlanar32f(uint64_t a1, uint64_t a2, float a3, float a4)
{
  unint64_t v5 = *(void **)(a1 + 24);
  uint64_t v6 = *(void *)(a1 + 8);
  v7.i64[0] = v6;
  v7.i64[1] = HIDWORD(v6);
  *(int8x16_t *)&src.height = vextq_s8(v7, v7, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  v10.data = *(void **)(a2 + 24);
  uint64_t v8 = *(void *)(a2 + 8);
  v7.i64[0] = v8;
  v7.i64[1] = HIDWORD(v8);
  *(int8x16_t *)&v10.height = vextq_s8(v7, v7, 8uLL);
  v10.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v5;
  return vImageConvert_16UToF(&src, &v10, a4, (float)(a3 - a4) / 65535.0, 0) == 0;
}

BOOL cva::experimental::convertPlanar32fToPlanar16u(uint64_t a1, uint64_t a2, float a3, float a4)
{
  unint64_t v5 = *(void **)(a1 + 24);
  uint64_t v6 = *(void *)(a1 + 8);
  v7.i64[0] = v6;
  v7.i64[1] = HIDWORD(v6);
  *(int8x16_t *)&src.height = vextq_s8(v7, v7, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  v10.data = *(void **)(a2 + 24);
  uint64_t v8 = *(void *)(a2 + 8);
  v7.i64[0] = v8;
  v7.i64[1] = HIDWORD(v8);
  *(int8x16_t *)&v10.height = vextq_s8(v7, v7, 8uLL);
  v10.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v5;
  return vImageConvert_FTo16U(&src, &v10, a4, (float)(a3 - a4) / 65535.0, 0) == 0;
}

BOOL cva::experimental::convertPlanar32fToPlanar8u(uint64_t a1, uint64_t a2, Pixel_F a3, Pixel_F a4)
{
  unint64_t v4 = *(void **)(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  v9.data = *(void **)(a2 + 24);
  uint64_t v7 = *(void *)(a2 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v9.height = vextq_s8(v6, v6, 8uLL);
  v9.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v4;
  return vImageConvert_PlanarFtoPlanar8(&src, &v9, a3, a4, 0) == 0;
}

BOOL cva::experimental::convertPlanar8uToPlanar32f(uint64_t a1, uint64_t a2, Pixel_F a3, Pixel_F a4)
{
  unint64_t v4 = *(void **)(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  v9.data = *(void **)(a2 + 24);
  uint64_t v7 = *(void *)(a2 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v9.height = vextq_s8(v6, v6, 8uLL);
  v9.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v4;
  return vImageConvert_Planar8toPlanarF(&src, &v9, a3, a4, 0) == 0;
}

BOOL cva::experimental::convertPlanar16uToPlanar8u(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 24);
  uint64_t v3 = *(void *)(a1 + 8);
  v4.i64[0] = v3;
  v4.i64[1] = HIDWORD(v3);
  *(int8x16_t *)&src.height = vextq_s8(v4, v4, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  v7.data = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v4.i64[0] = v5;
  v4.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&v7.height = vextq_s8(v4, v4, 8uLL);
  v7.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v2;
  return vImageConvert_Planar16UtoPlanar8_dithered(&src, &v7, 0, 0) == 0;
}

BOOL cva::experimental::convertPlanar8uToPlanar16u(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 24);
  uint64_t v3 = *(void *)(a1 + 8);
  v4.i64[0] = v3;
  v4.i64[1] = HIDWORD(v3);
  *(int8x16_t *)&src.height = vextq_s8(v4, v4, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  v7.data = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v4.i64[0] = v5;
  v4.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&v7.height = vextq_s8(v4, v4, 8uLL);
  v7.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v2;
  return vImageConvert_Planar8To16U(&src, &v7, 0) == 0;
}

uint64_t cva::experimental::convertPlanar16uToPlanar64f(void *a1, uint64_t a2, double a3, double a4)
{
  uint64_t v4 = a1[3];
  if (v4)
  {
    uint64_t v5 = a1[1];
    unint64_t v6 = a1[2];
    uint64_t v7 = (HIDWORD(v6) * HIDWORD(v5));
    if (v7)
    {
      int v8 = 0;
      int v9 = 0;
      double v10 = a3 - a4;
      double v11 = 65535.0;
      int v12 = (_WORD *)(v4 + *a1);
      float v13 = (_WORD *)((char *)v12 + v7);
      int v14 = *(_DWORD *)(a2 + 8);
      unint64_t v16 = *(void *)(a2 + 16);
      uint64_t v15 = *(void *)(a2 + 24);
      int v17 = (double *)(v15 + *(void *)a2);
      if (v15) {
        int v18 = v17;
      }
      else {
        int v18 = 0;
      }
      double v19 = v10 / 65535.0;
      do
      {
        LOWORD(v11) = *v12;
        double v11 = a4 + (double)*(unint64_t *)&v11 * v19;
        double *v18 = v11;
        int v12 = (_WORD *)((char *)v12 + v6);
        int v20 = v9 + 1;
        if (v9 + 1 == v5) {
          int v9 = 0;
        }
        else {
          ++v9;
        }
        if (v20 == v5) {
          int v12 = (_WORD *)((char *)v12 + HIDWORD(v6) - (v20 * v6));
        }
        int v18 = (double *)((char *)v18 + v16);
        int v21 = v8 + 1;
        if (v8 + 1 == v14) {
          int v8 = 0;
        }
        else {
          ++v8;
        }
        if (v21 == v14) {
          int v18 = (double *)((char *)v18 + HIDWORD(v16) - (v21 * v16));
        }
      }
      while (v12 != v13);
    }
  }
  return 1;
}

uint64_t cva::experimental::convertPlanar64fToPlanar16u(void *a1, uint64_t a2, double a3, double a4)
{
  uint64_t v4 = a1[3];
  if (v4)
  {
    uint64_t v5 = a1[1];
    unint64_t v6 = a1[2];
    uint64_t v7 = (HIDWORD(v6) * HIDWORD(v5));
    if (v7)
    {
      int v8 = 0;
      int v9 = 0;
      double v10 = (double *)(v4 + *a1);
      double v11 = (double *)((char *)v10 + v7);
      int v12 = *(_DWORD *)(a2 + 8);
      unint64_t v14 = *(void *)(a2 + 16);
      uint64_t v13 = *(void *)(a2 + 24);
      uint64_t v15 = (__int16 *)(v13 + *(void *)a2);
      if (v13) {
        unint64_t v16 = v15;
      }
      else {
        unint64_t v16 = 0;
      }
      do
      {
        double v17 = (*v10 - a4) * (65535.0 / (a3 - a4)) + 0.5;
        if (v17 < 0.0) {
          __int16 v18 = 0;
        }
        else {
          __int16 v18 = -1;
        }
        if (v17 <= 65535.0 && v17 >= 0.0) {
          __int16 v18 = (int)v17;
        }
        __int16 *v16 = v18;
        double v10 = (double *)((char *)v10 + v6);
        int v20 = v9 + 1;
        if (v9 + 1 == v5) {
          int v9 = 0;
        }
        else {
          ++v9;
        }
        if (v20 == v5) {
          double v10 = (double *)((char *)v10 + HIDWORD(v6) - (v20 * v6));
        }
        unint64_t v16 = (__int16 *)((char *)v16 + v14);
        int v21 = v8 + 1;
        if (v8 + 1 == v12) {
          int v8 = 0;
        }
        else {
          ++v8;
        }
        if (v21 == v12) {
          unint64_t v16 = (__int16 *)((char *)v16 + HIDWORD(v14) - (v21 * v14));
        }
      }
      while (v10 != v11);
    }
  }
  return 1;
}

uint64_t cva::experimental::convertPlanar8uToPlanar64f(void *a1, uint64_t a2, double a3, double a4)
{
  uint64_t v4 = a1[3];
  if (v4)
  {
    uint64_t v5 = a1[1];
    unint64_t v6 = a1[2];
    uint64_t v7 = (HIDWORD(v6) * HIDWORD(v5));
    if (v7)
    {
      int v8 = 0;
      int v9 = 0;
      double v10 = a3 - a4;
      double v11 = 255.0;
      int v12 = (unsigned char *)(v4 + *a1);
      uint64_t v13 = &v12[v7];
      int v14 = *(_DWORD *)(a2 + 8);
      unint64_t v16 = *(void *)(a2 + 16);
      uint64_t v15 = *(void *)(a2 + 24);
      double v17 = (double *)(v15 + *(void *)a2);
      if (v15) {
        __int16 v18 = v17;
      }
      else {
        __int16 v18 = 0;
      }
      double v19 = v10 / 255.0;
      do
      {
        LOBYTE(v11) = *v12;
        double v11 = a4 + (double)*(unint64_t *)&v11 * v19;
        double *v18 = v11;
        v12 += v6;
        int v20 = v9 + 1;
        if (v9 + 1 == v5) {
          int v9 = 0;
        }
        else {
          ++v9;
        }
        if (v20 == v5) {
          int v12 = &v12[HIDWORD(v6) - (v20 * v6)];
        }
        __int16 v18 = (double *)((char *)v18 + v16);
        int v21 = v8 + 1;
        if (v8 + 1 == v14) {
          int v8 = 0;
        }
        else {
          ++v8;
        }
        if (v21 == v14) {
          __int16 v18 = (double *)((char *)v18 + HIDWORD(v16) - (v21 * v16));
        }
      }
      while (v12 != v13);
    }
  }
  return 1;
}

uint64_t cva::experimental::convertPlanar64fToPlanar8u(void *a1, uint64_t a2, double a3, double a4)
{
  uint64_t v4 = a1[3];
  if (v4)
  {
    uint64_t v5 = a1[1];
    unint64_t v6 = a1[2];
    uint64_t v7 = (HIDWORD(v6) * HIDWORD(v5));
    if (v7)
    {
      int v8 = 0;
      int v9 = 0;
      double v10 = (double *)(v4 + *a1);
      double v11 = (double *)((char *)v10 + v7);
      int v12 = *(_DWORD *)(a2 + 8);
      unint64_t v14 = *(void *)(a2 + 16);
      uint64_t v13 = *(void *)(a2 + 24);
      uint64_t v15 = (char *)(v13 + *(void *)a2);
      if (v13) {
        unint64_t v16 = v15;
      }
      else {
        unint64_t v16 = 0;
      }
      do
      {
        double v17 = (*v10 - a4) * (255.0 / (a3 - a4)) + 0.5;
        if (v17 < 0.0) {
          char v18 = 0;
        }
        else {
          char v18 = -1;
        }
        if (v17 <= 255.0 && v17 >= 0.0) {
          char v18 = (int)v17;
        }
        char *v16 = v18;
        double v10 = (double *)((char *)v10 + v6);
        int v20 = v9 + 1;
        if (v9 + 1 == v5) {
          int v9 = 0;
        }
        else {
          ++v9;
        }
        if (v20 == v5) {
          double v10 = (double *)((char *)v10 + HIDWORD(v6) - (v20 * v6));
        }
        v16 += v14;
        int v21 = v8 + 1;
        if (v8 + 1 == v12) {
          int v8 = 0;
        }
        else {
          ++v8;
        }
        if (v21 == v12) {
          unint64_t v16 = &v16[HIDWORD(v14) - (v21 * v14)];
        }
      }
      while (v10 != v11);
    }
  }
  return 1;
}

uint64_t cva::experimental::convertPlanar64fToPlanar32f(void *a1, uint64_t a2)
{
  uint64_t v2 = a1[3];
  if (v2)
  {
    uint64_t v3 = a1[1];
    unint64_t v4 = a1[2];
    uint64_t v5 = (HIDWORD(v4) * HIDWORD(v3));
    if (v5)
    {
      int v6 = 0;
      int v7 = 0;
      int v8 = (double *)(v2 + *a1);
      int v9 = (double *)((char *)v8 + v5);
      int v10 = *(_DWORD *)(a2 + 8);
      unint64_t v12 = *(void *)(a2 + 16);
      uint64_t v11 = *(void *)(a2 + 24);
      uint64_t v13 = (float *)(v11 + *(void *)a2);
      if (v11) {
        unint64_t v14 = v13;
      }
      else {
        unint64_t v14 = 0;
      }
      do
      {
        float v15 = *v8;
        float *v14 = v15;
        int v8 = (double *)((char *)v8 + v4);
        int v16 = v7 + 1;
        if (v7 + 1 == v3) {
          int v7 = 0;
        }
        else {
          ++v7;
        }
        if (v16 == v3) {
          int v8 = (double *)((char *)v8 + HIDWORD(v4) - (v16 * v4));
        }
        unint64_t v14 = (float *)((char *)v14 + v12);
        int v17 = v6 + 1;
        if (v6 + 1 == v10) {
          int v6 = 0;
        }
        else {
          ++v6;
        }
        if (v17 == v10) {
          unint64_t v14 = (float *)((char *)v14 + HIDWORD(v12) - (v17 * v12));
        }
      }
      while (v8 != v9);
    }
  }
  return 1;
}

uint64_t cva::experimental::convertPlanar32fToPlanar64f(void *a1, uint64_t a2)
{
  uint64_t v2 = a1[3];
  if (v2)
  {
    uint64_t v3 = a1[1];
    unint64_t v4 = a1[2];
    uint64_t v5 = (HIDWORD(v4) * HIDWORD(v3));
    if (v5)
    {
      int v6 = 0;
      int v7 = 0;
      int v8 = (float *)(v2 + *a1);
      int v9 = (float *)((char *)v8 + v5);
      int v10 = *(_DWORD *)(a2 + 8);
      unint64_t v12 = *(void *)(a2 + 16);
      uint64_t v11 = *(void *)(a2 + 24);
      uint64_t v13 = (double *)(v11 + *(void *)a2);
      if (v11) {
        unint64_t v14 = v13;
      }
      else {
        unint64_t v14 = 0;
      }
      do
      {
        double *v14 = *v8;
        int v8 = (float *)((char *)v8 + v4);
        int v15 = v7 + 1;
        if (v7 + 1 == v3) {
          int v7 = 0;
        }
        else {
          ++v7;
        }
        if (v15 == v3) {
          int v8 = (float *)((char *)v8 + HIDWORD(v4) - (v15 * v4));
        }
        unint64_t v14 = (double *)((char *)v14 + v12);
        int v16 = v6 + 1;
        if (v6 + 1 == v10) {
          int v6 = 0;
        }
        else {
          ++v6;
        }
        if (v16 == v10) {
          unint64_t v14 = (double *)((char *)v14 + HIDWORD(v12) - (v16 * v12));
        }
      }
      while (v8 != v9);
    }
  }
  return 1;
}

BOOL cva::experimental::convertARGB8uToPlanar32f(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const float *a6, const float *a7)
{
  int v7 = *(void **)(a1 + 24);
  uint64_t v8 = *(void *)(a1 + 8);
  v9.i64[0] = v8;
  v9.i64[1] = HIDWORD(v8);
  *(int8x16_t *)&src.height = vextq_s8(v9, v9, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  alpha.data = *(void **)(a2 + 24);
  uint64_t v10 = *(void *)(a2 + 8);
  v9.i64[0] = v10;
  v9.i64[1] = HIDWORD(v10);
  *(int8x16_t *)&alpha.height = vextq_s8(v9, v9, 8uLL);
  alpha.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v7;
  uint64_t v11 = *(void **)(a3 + 24);
  uint64_t v12 = *(void *)(a3 + 8);
  v9.i64[0] = v12;
  v9.i64[1] = HIDWORD(v12);
  *(int8x16_t *)&red.height = vextq_s8(v9, v9, 8uLL);
  red.rowBytes = *(unsigned int *)(a3 + 20);
  uint64_t v13 = *(void **)(a4 + 24);
  uint64_t v14 = *(void *)(a4 + 8);
  v9.i64[0] = v14;
  v9.i64[1] = HIDWORD(v14);
  *(int8x16_t *)&green.height = vextq_s8(v9, v9, 8uLL);
  green.rowBytes = *(unsigned int *)(a4 + 20);
  red.data = v11;
  v17.data = *(void **)(a5 + 24);
  uint64_t v15 = *(void *)(a5 + 8);
  v9.i64[0] = v15;
  v9.i64[1] = HIDWORD(v15);
  *(int8x16_t *)&v17.height = vextq_s8(v9, v9, 8uLL);
  v17.rowBytes = *(unsigned int *)(a5 + 20);
  green.data = v13;
  return vImageConvert_ARGB8888toPlanarF(&src, &alpha, &red, &green, &v17, a6, a7, 0) == 0;
}

BOOL cva::experimental::convertRGBA8uToPlanar32f(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const float *a6, const float *a7)
{
  int v7 = *(void **)(a1 + 24);
  uint64_t v8 = *(void *)(a1 + 8);
  v9.i64[0] = v8;
  v9.i64[1] = HIDWORD(v8);
  *(int8x16_t *)&src.height = vextq_s8(v9, v9, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  alpha.data = *(void **)(a2 + 24);
  uint64_t v10 = *(void *)(a2 + 8);
  v9.i64[0] = v10;
  v9.i64[1] = HIDWORD(v10);
  *(int8x16_t *)&alpha.height = vextq_s8(v9, v9, 8uLL);
  alpha.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v7;
  uint64_t v11 = *(void **)(a3 + 24);
  uint64_t v12 = *(void *)(a3 + 8);
  v9.i64[0] = v12;
  v9.i64[1] = HIDWORD(v12);
  *(int8x16_t *)&red.height = vextq_s8(v9, v9, 8uLL);
  red.rowBytes = *(unsigned int *)(a3 + 20);
  uint64_t v13 = *(void **)(a4 + 24);
  uint64_t v14 = *(void *)(a4 + 8);
  v9.i64[0] = v14;
  v9.i64[1] = HIDWORD(v14);
  *(int8x16_t *)&green.height = vextq_s8(v9, v9, 8uLL);
  green.rowBytes = *(unsigned int *)(a4 + 20);
  red.data = v11;
  v17.data = *(void **)(a5 + 24);
  uint64_t v15 = *(void *)(a5 + 8);
  v9.i64[0] = v15;
  v9.i64[1] = HIDWORD(v15);
  *(int8x16_t *)&v17.height = vextq_s8(v9, v9, 8uLL);
  v17.rowBytes = *(unsigned int *)(a5 + 20);
  green.data = v13;
  return vImageConvert_ARGB8888toPlanarF(&src, &alpha, &red, &green, &v17, a6, a7, 0) == 0;
}

BOOL cva::experimental::convertBGRA8uToPlanar32f(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const float *a6, const float *a7)
{
  int v7 = *(void **)(a1 + 24);
  uint64_t v8 = *(void *)(a1 + 8);
  v9.i64[0] = v8;
  v9.i64[1] = HIDWORD(v8);
  *(int8x16_t *)&src.height = vextq_s8(v9, v9, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  alpha.data = *(void **)(a2 + 24);
  uint64_t v10 = *(void *)(a2 + 8);
  v9.i64[0] = v10;
  v9.i64[1] = HIDWORD(v10);
  *(int8x16_t *)&alpha.height = vextq_s8(v9, v9, 8uLL);
  alpha.rowBytes = *(unsigned int *)(a2 + 20);
  src.data = v7;
  uint64_t v11 = *(void **)(a3 + 24);
  uint64_t v12 = *(void *)(a3 + 8);
  v9.i64[0] = v12;
  v9.i64[1] = HIDWORD(v12);
  *(int8x16_t *)&red.height = vextq_s8(v9, v9, 8uLL);
  red.rowBytes = *(unsigned int *)(a3 + 20);
  uint64_t v13 = *(void **)(a4 + 24);
  uint64_t v14 = *(void *)(a4 + 8);
  v9.i64[0] = v14;
  v9.i64[1] = HIDWORD(v14);
  *(int8x16_t *)&green.height = vextq_s8(v9, v9, 8uLL);
  green.rowBytes = *(unsigned int *)(a4 + 20);
  red.data = v11;
  v17.data = *(void **)(a5 + 24);
  uint64_t v15 = *(void *)(a5 + 8);
  v9.i64[0] = v15;
  v9.i64[1] = HIDWORD(v15);
  *(int8x16_t *)&v17.height = vextq_s8(v9, v9, 8uLL);
  v17.rowBytes = *(unsigned int *)(a5 + 20);
  green.data = v13;
  return vImageConvert_ARGB8888toPlanarF(&src, &alpha, &red, &green, &v17, a6, a7, 0) == 0;
}

BOOL cva::experimental::convertPlanar8uToARGB8u(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *(void **)(a1 + 24);
  uint64_t v6 = *(void *)(a1 + 8);
  v7.i64[0] = v6;
  v7.i64[1] = HIDWORD(v6);
  *(int8x16_t *)&srcA.height = vextq_s8(v7, v7, 8uLL);
  srcA.rowBytes = *(unsigned int *)(a1 + 20);
  srcR.data = *(void **)(a2 + 24);
  uint64_t v8 = *(void *)(a2 + 8);
  v7.i64[0] = v8;
  v7.i64[1] = HIDWORD(v8);
  *(int8x16_t *)&srcR.height = vextq_s8(v7, v7, 8uLL);
  srcR.rowBytes = *(unsigned int *)(a2 + 20);
  srcA.data = v5;
  int8x16_t v9 = *(void **)(a3 + 24);
  uint64_t v10 = *(void *)(a3 + 8);
  v7.i64[0] = v10;
  v7.i64[1] = HIDWORD(v10);
  *(int8x16_t *)&srcG.height = vextq_s8(v7, v7, 8uLL);
  srcG.rowBytes = *(unsigned int *)(a3 + 20);
  uint64_t v11 = *(void **)(a4 + 24);
  uint64_t v12 = *(void *)(a4 + 8);
  v7.i64[0] = v12;
  v7.i64[1] = HIDWORD(v12);
  *(int8x16_t *)&srcB.height = vextq_s8(v7, v7, 8uLL);
  srcB.rowBytes = *(unsigned int *)(a4 + 20);
  srcG.data = v9;
  v15.data = *(void **)(a5 + 24);
  uint64_t v13 = *(void *)(a5 + 8);
  v7.i64[0] = v13;
  v7.i64[1] = HIDWORD(v13);
  *(int8x16_t *)&v15.height = vextq_s8(v7, v7, 8uLL);
  v15.rowBytes = *(unsigned int *)(a5 + 20);
  srcB.data = v11;
  return vImageConvert_Planar8toARGB8888(&srcA, &srcR, &srcG, &srcB, &v15, 0) == 0;
}

BOOL cva::experimental::convertPlanar8uToRGBA8u(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *(void **)(a1 + 24);
  uint64_t v6 = *(void *)(a1 + 8);
  v7.i64[0] = v6;
  v7.i64[1] = HIDWORD(v6);
  *(int8x16_t *)&srcA.height = vextq_s8(v7, v7, 8uLL);
  srcA.rowBytes = *(unsigned int *)(a1 + 20);
  srcR.data = *(void **)(a2 + 24);
  uint64_t v8 = *(void *)(a2 + 8);
  v7.i64[0] = v8;
  v7.i64[1] = HIDWORD(v8);
  *(int8x16_t *)&srcR.height = vextq_s8(v7, v7, 8uLL);
  srcR.rowBytes = *(unsigned int *)(a2 + 20);
  srcA.data = v5;
  int8x16_t v9 = *(void **)(a3 + 24);
  uint64_t v10 = *(void *)(a3 + 8);
  v7.i64[0] = v10;
  v7.i64[1] = HIDWORD(v10);
  *(int8x16_t *)&srcG.height = vextq_s8(v7, v7, 8uLL);
  srcG.rowBytes = *(unsigned int *)(a3 + 20);
  uint64_t v11 = *(void **)(a4 + 24);
  uint64_t v12 = *(void *)(a4 + 8);
  v7.i64[0] = v12;
  v7.i64[1] = HIDWORD(v12);
  *(int8x16_t *)&srcB.height = vextq_s8(v7, v7, 8uLL);
  srcB.rowBytes = *(unsigned int *)(a4 + 20);
  srcG.data = v9;
  v15.data = *(void **)(a5 + 24);
  uint64_t v13 = *(void *)(a5 + 8);
  v7.i64[0] = v13;
  v7.i64[1] = HIDWORD(v13);
  *(int8x16_t *)&v15.height = vextq_s8(v7, v7, 8uLL);
  v15.rowBytes = *(unsigned int *)(a5 + 20);
  srcB.data = v11;
  return vImageConvert_Planar8toARGB8888(&srcA, &srcR, &srcG, &srcB, &v15, 0) == 0;
}

BOOL cva::experimental::convertPlanar8uToBGRA8u(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *(void **)(a1 + 24);
  uint64_t v6 = *(void *)(a1 + 8);
  v7.i64[0] = v6;
  v7.i64[1] = HIDWORD(v6);
  *(int8x16_t *)&srcA.height = vextq_s8(v7, v7, 8uLL);
  srcA.rowBytes = *(unsigned int *)(a1 + 20);
  srcR.data = *(void **)(a2 + 24);
  uint64_t v8 = *(void *)(a2 + 8);
  v7.i64[0] = v8;
  v7.i64[1] = HIDWORD(v8);
  *(int8x16_t *)&srcR.height = vextq_s8(v7, v7, 8uLL);
  srcR.rowBytes = *(unsigned int *)(a2 + 20);
  srcA.data = v5;
  int8x16_t v9 = *(void **)(a3 + 24);
  uint64_t v10 = *(void *)(a3 + 8);
  v7.i64[0] = v10;
  v7.i64[1] = HIDWORD(v10);
  *(int8x16_t *)&srcG.height = vextq_s8(v7, v7, 8uLL);
  srcG.rowBytes = *(unsigned int *)(a3 + 20);
  uint64_t v11 = *(void **)(a4 + 24);
  uint64_t v12 = *(void *)(a4 + 8);
  v7.i64[0] = v12;
  v7.i64[1] = HIDWORD(v12);
  *(int8x16_t *)&srcB.height = vextq_s8(v7, v7, 8uLL);
  srcB.rowBytes = *(unsigned int *)(a4 + 20);
  srcG.data = v9;
  v15.data = *(void **)(a5 + 24);
  uint64_t v13 = *(void *)(a5 + 8);
  v7.i64[0] = v13;
  v7.i64[1] = HIDWORD(v13);
  *(int8x16_t *)&v15.height = vextq_s8(v7, v7, 8uLL);
  v15.rowBytes = *(unsigned int *)(a5 + 20);
  srcB.data = v11;
  return vImageConvert_Planar8toARGB8888(&srcA, &srcR, &srcG, &srcB, &v15, 0) == 0;
}

BOOL cva::experimental::convertPlanar8uToRGB8u(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  planarRed.data = *(void **)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 8);
  v5.i64[0] = v4;
  v5.i64[1] = HIDWORD(v4);
  *(int8x16_t *)&planarRed.height = vextq_s8(v5, v5, 8uLL);
  planarRed.rowBytes = *(unsigned int *)(a1 + 20);
  uint64_t v6 = *(void **)(a2 + 24);
  uint64_t v7 = *(void *)(a2 + 8);
  v5.i64[0] = v7;
  v5.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&planarGreen.height = vextq_s8(v5, v5, 8uLL);
  planarGreen.rowBytes = *(unsigned int *)(a2 + 20);
  uint64_t v8 = *(void **)(a3 + 24);
  uint64_t v9 = *(void *)(a3 + 8);
  v5.i64[0] = v9;
  v5.i64[1] = HIDWORD(v9);
  *(int8x16_t *)&planarBlue.height = vextq_s8(v5, v5, 8uLL);
  planarBlue.rowBytes = *(unsigned int *)(a3 + 20);
  planarGreen.data = v6;
  v12.data = *(void **)(a4 + 24);
  uint64_t v10 = *(void *)(a4 + 8);
  v5.i64[0] = v10;
  v5.i64[1] = HIDWORD(v10);
  *(int8x16_t *)&v12.height = vextq_s8(v5, v5, 8uLL);
  v12.rowBytes = *(unsigned int *)(a4 + 20);
  planarBlue.data = v8;
  return vImageConvert_Planar8toRGB888(&planarRed, &planarGreen, &planarBlue, &v12, 0) == 0;
}

BOOL cva::experimental::convertPlanar8uToBGR8u(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  planarRed.data = *(void **)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 8);
  v5.i64[0] = v4;
  v5.i64[1] = HIDWORD(v4);
  *(int8x16_t *)&planarRed.height = vextq_s8(v5, v5, 8uLL);
  planarRed.rowBytes = *(unsigned int *)(a1 + 20);
  uint64_t v6 = *(void **)(a2 + 24);
  uint64_t v7 = *(void *)(a2 + 8);
  v5.i64[0] = v7;
  v5.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&planarGreen.height = vextq_s8(v5, v5, 8uLL);
  planarGreen.rowBytes = *(unsigned int *)(a2 + 20);
  uint64_t v8 = *(void **)(a3 + 24);
  uint64_t v9 = *(void *)(a3 + 8);
  v5.i64[0] = v9;
  v5.i64[1] = HIDWORD(v9);
  *(int8x16_t *)&planarBlue.height = vextq_s8(v5, v5, 8uLL);
  planarBlue.rowBytes = *(unsigned int *)(a3 + 20);
  planarGreen.data = v6;
  v12.data = *(void **)(a4 + 24);
  uint64_t v10 = *(void *)(a4 + 8);
  v5.i64[0] = v10;
  v5.i64[1] = HIDWORD(v10);
  *(int8x16_t *)&v12.height = vextq_s8(v5, v5, 8uLL);
  v12.rowBytes = *(unsigned int *)(a4 + 20);
  planarBlue.data = v8;
  return vImageConvert_Planar8toRGB888(&planarRed, &planarGreen, &planarBlue, &v12, 0) == 0;
}

BOOL cva::experimental::convertPlanar32fToARGB8u(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const float *a6, const float *a7)
{
  uint64_t v7 = *(void **)(a1 + 24);
  uint64_t v8 = *(void *)(a1 + 8);
  v9.i64[0] = v8;
  v9.i64[1] = HIDWORD(v8);
  *(int8x16_t *)&alpha.height = vextq_s8(v9, v9, 8uLL);
  alpha.rowBytes = *(unsigned int *)(a1 + 20);
  red.data = *(void **)(a2 + 24);
  uint64_t v10 = *(void *)(a2 + 8);
  v9.i64[0] = v10;
  v9.i64[1] = HIDWORD(v10);
  *(int8x16_t *)&red.height = vextq_s8(v9, v9, 8uLL);
  red.rowBytes = *(unsigned int *)(a2 + 20);
  alpha.data = v7;
  uint64_t v11 = *(void **)(a3 + 24);
  uint64_t v12 = *(void *)(a3 + 8);
  v9.i64[0] = v12;
  v9.i64[1] = HIDWORD(v12);
  *(int8x16_t *)&green.height = vextq_s8(v9, v9, 8uLL);
  green.rowBytes = *(unsigned int *)(a3 + 20);
  uint64_t v13 = *(void **)(a4 + 24);
  uint64_t v14 = *(void *)(a4 + 8);
  v9.i64[0] = v14;
  v9.i64[1] = HIDWORD(v14);
  *(int8x16_t *)&blue.height = vextq_s8(v9, v9, 8uLL);
  blue.rowBytes = *(unsigned int *)(a4 + 20);
  green.data = v11;
  v17.data = *(void **)(a5 + 24);
  uint64_t v15 = *(void *)(a5 + 8);
  v9.i64[0] = v15;
  v9.i64[1] = HIDWORD(v15);
  *(int8x16_t *)&v17.height = vextq_s8(v9, v9, 8uLL);
  v17.rowBytes = *(unsigned int *)(a5 + 20);
  blue.data = v13;
  return vImageConvert_PlanarFToARGB8888(&alpha, &red, &green, &blue, &v17, a6, a7, 0) == 0;
}

BOOL cva::experimental::convertPlanar32fToRGBA8u(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const float *a6, const float *a7)
{
  uint64_t v7 = *(void **)(a1 + 24);
  uint64_t v8 = *(void *)(a1 + 8);
  v9.i64[0] = v8;
  v9.i64[1] = HIDWORD(v8);
  *(int8x16_t *)&alpha.height = vextq_s8(v9, v9, 8uLL);
  alpha.rowBytes = *(unsigned int *)(a1 + 20);
  red.data = *(void **)(a2 + 24);
  uint64_t v10 = *(void *)(a2 + 8);
  v9.i64[0] = v10;
  v9.i64[1] = HIDWORD(v10);
  *(int8x16_t *)&red.height = vextq_s8(v9, v9, 8uLL);
  red.rowBytes = *(unsigned int *)(a2 + 20);
  alpha.data = v7;
  uint64_t v11 = *(void **)(a3 + 24);
  uint64_t v12 = *(void *)(a3 + 8);
  v9.i64[0] = v12;
  v9.i64[1] = HIDWORD(v12);
  *(int8x16_t *)&green.height = vextq_s8(v9, v9, 8uLL);
  green.rowBytes = *(unsigned int *)(a3 + 20);
  uint64_t v13 = *(void **)(a4 + 24);
  uint64_t v14 = *(void *)(a4 + 8);
  v9.i64[0] = v14;
  v9.i64[1] = HIDWORD(v14);
  *(int8x16_t *)&blue.height = vextq_s8(v9, v9, 8uLL);
  blue.rowBytes = *(unsigned int *)(a4 + 20);
  green.data = v11;
  v17.data = *(void **)(a5 + 24);
  uint64_t v15 = *(void *)(a5 + 8);
  v9.i64[0] = v15;
  v9.i64[1] = HIDWORD(v15);
  *(int8x16_t *)&v17.height = vextq_s8(v9, v9, 8uLL);
  v17.rowBytes = *(unsigned int *)(a5 + 20);
  blue.data = v13;
  return vImageConvert_PlanarFToARGB8888(&alpha, &red, &green, &blue, &v17, a6, a7, 0) == 0;
}

BOOL cva::experimental::convertPlanar32fToBGRA8u(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const float *a6, const float *a7)
{
  uint64_t v7 = *(void **)(a1 + 24);
  uint64_t v8 = *(void *)(a1 + 8);
  v9.i64[0] = v8;
  v9.i64[1] = HIDWORD(v8);
  *(int8x16_t *)&alpha.height = vextq_s8(v9, v9, 8uLL);
  alpha.rowBytes = *(unsigned int *)(a1 + 20);
  red.data = *(void **)(a2 + 24);
  uint64_t v10 = *(void *)(a2 + 8);
  v9.i64[0] = v10;
  v9.i64[1] = HIDWORD(v10);
  *(int8x16_t *)&red.height = vextq_s8(v9, v9, 8uLL);
  red.rowBytes = *(unsigned int *)(a2 + 20);
  alpha.data = v7;
  uint64_t v11 = *(void **)(a3 + 24);
  uint64_t v12 = *(void *)(a3 + 8);
  v9.i64[0] = v12;
  v9.i64[1] = HIDWORD(v12);
  *(int8x16_t *)&green.height = vextq_s8(v9, v9, 8uLL);
  green.rowBytes = *(unsigned int *)(a3 + 20);
  uint64_t v13 = *(void **)(a4 + 24);
  uint64_t v14 = *(void *)(a4 + 8);
  v9.i64[0] = v14;
  v9.i64[1] = HIDWORD(v14);
  *(int8x16_t *)&blue.height = vextq_s8(v9, v9, 8uLL);
  blue.rowBytes = *(unsigned int *)(a4 + 20);
  green.data = v11;
  v17.data = *(void **)(a5 + 24);
  uint64_t v15 = *(void *)(a5 + 8);
  v9.i64[0] = v15;
  v9.i64[1] = HIDWORD(v15);
  *(int8x16_t *)&v17.height = vextq_s8(v9, v9, 8uLL);
  v17.rowBytes = *(unsigned int *)(a5 + 20);
  blue.data = v13;
  return vImageConvert_PlanarFToARGB8888(&alpha, &red, &green, &blue, &v17, a6, a7, 0) == 0;
}

BOOL cva::experimental::convertRGB8uToARGB8u(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v11.data = *(void **)(a1 + 24);
  uint64_t v3 = *(void *)(a1 + 8);
  v4.i64[0] = v3;
  v4.i64[1] = HIDWORD(v3);
  *(int8x16_t *)&v11.height = vextq_s8(v4, v4, 8uLL);
  v11.rowBytes = *(unsigned int *)(a1 + 20);
  int8x16_t v5 = *(void **)(a2 + 24);
  uint64_t v6 = *(void *)(a2 + 8);
  v4.i64[0] = v6;
  v4.i64[1] = HIDWORD(v6);
  *(int8x16_t *)&v10.height = vextq_s8(v4, v4, 8uLL);
  v10.rowBytes = *(unsigned int *)(a2 + 20);
  v9.data = *(void **)(a3 + 24);
  uint64_t v7 = *(void *)(a3 + 8);
  v4.i64[0] = v7;
  v4.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v9.height = vextq_s8(v4, v4, 8uLL);
  v9.rowBytes = *(unsigned int *)(a3 + 20);
  v10.data = v5;
  return vImageConvert_RGB888toARGB8888(&v11, &v10, 0, &v9, 0, 0) == 0;
}

BOOL cva::experimental::convertRGB8uToARGB8u(uint64_t a1, uint64_t a2, Pixel_8 a3)
{
  uint64_t v3 = *(void **)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 8);
  v5.i64[0] = v4;
  v5.i64[1] = HIDWORD(v4);
  *(int8x16_t *)&v9.height = vextq_s8(v5, v5, 8uLL);
  v9.rowBytes = *(unsigned int *)(a1 + 20);
  v8.data = *(void **)(a2 + 24);
  uint64_t v6 = *(void *)(a2 + 8);
  v5.i64[0] = v6;
  v5.i64[1] = HIDWORD(v6);
  *(int8x16_t *)&v8.height = vextq_s8(v5, v5, 8uLL);
  v8.rowBytes = *(unsigned int *)(a2 + 20);
  v9.data = v3;
  return vImageConvert_RGB888toARGB8888(&v9, 0, a3, &v8, 0, 0) == 0;
}

BOOL cva::experimental::convertRGB8uToBGRA8u(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v11.data = *(void **)(a1 + 24);
  uint64_t v3 = *(void *)(a1 + 8);
  v4.i64[0] = v3;
  v4.i64[1] = HIDWORD(v3);
  *(int8x16_t *)&v11.height = vextq_s8(v4, v4, 8uLL);
  v11.rowBytes = *(unsigned int *)(a1 + 20);
  int8x16_t v5 = *(void **)(a2 + 24);
  uint64_t v6 = *(void *)(a2 + 8);
  v4.i64[0] = v6;
  v4.i64[1] = HIDWORD(v6);
  *(int8x16_t *)&v10.height = vextq_s8(v4, v4, 8uLL);
  v10.rowBytes = *(unsigned int *)(a2 + 20);
  v9.data = *(void **)(a3 + 24);
  uint64_t v7 = *(void *)(a3 + 8);
  v4.i64[0] = v7;
  v4.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v9.height = vextq_s8(v4, v4, 8uLL);
  v9.rowBytes = *(unsigned int *)(a3 + 20);
  v10.data = v5;
  return vImageConvert_RGB888toBGRA8888(&v11, &v10, 0, &v9, 0, 0) == 0;
}

BOOL cva::experimental::convertRGB8uToRGBA8u(uint64_t a1, uint64_t a2, Pixel_8 a3)
{
  uint64_t v3 = *(void **)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 8);
  v5.i64[0] = v4;
  v5.i64[1] = HIDWORD(v4);
  *(int8x16_t *)&v9.height = vextq_s8(v5, v5, 8uLL);
  v9.rowBytes = *(unsigned int *)(a1 + 20);
  v8.data = *(void **)(a2 + 24);
  uint64_t v6 = *(void *)(a2 + 8);
  v5.i64[0] = v6;
  v5.i64[1] = HIDWORD(v6);
  *(int8x16_t *)&v8.height = vextq_s8(v5, v5, 8uLL);
  v8.rowBytes = *(unsigned int *)(a2 + 20);
  v9.data = v3;
  return vImageConvert_RGB888toRGBA8888(&v9, 0, a3, &v8, 0, 0) == 0;
}

BOOL cva::experimental::convertRGB8uToRGBA8u(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v11.data = *(void **)(a1 + 24);
  uint64_t v3 = *(void *)(a1 + 8);
  v4.i64[0] = v3;
  v4.i64[1] = HIDWORD(v3);
  *(int8x16_t *)&v11.height = vextq_s8(v4, v4, 8uLL);
  v11.rowBytes = *(unsigned int *)(a1 + 20);
  int8x16_t v5 = *(void **)(a2 + 24);
  uint64_t v6 = *(void *)(a2 + 8);
  v4.i64[0] = v6;
  v4.i64[1] = HIDWORD(v6);
  *(int8x16_t *)&v10.height = vextq_s8(v4, v4, 8uLL);
  v10.rowBytes = *(unsigned int *)(a2 + 20);
  v9.data = *(void **)(a3 + 24);
  uint64_t v7 = *(void *)(a3 + 8);
  v4.i64[0] = v7;
  v4.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v9.height = vextq_s8(v4, v4, 8uLL);
  v9.rowBytes = *(unsigned int *)(a3 + 20);
  v10.data = v5;
  return vImageConvert_RGB888toRGBA8888(&v11, &v10, 0, &v9, 0, 0) == 0;
}

BOOL cva::experimental::convertRGB8uToBGRA8u(uint64_t a1, uint64_t a2, Pixel_8 a3)
{
  uint64_t v3 = *(void **)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 8);
  v5.i64[0] = v4;
  v5.i64[1] = HIDWORD(v4);
  *(int8x16_t *)&v9.height = vextq_s8(v5, v5, 8uLL);
  v9.rowBytes = *(unsigned int *)(a1 + 20);
  v8.data = *(void **)(a2 + 24);
  uint64_t v6 = *(void *)(a2 + 8);
  v5.i64[0] = v6;
  v5.i64[1] = HIDWORD(v6);
  *(int8x16_t *)&v8.height = vextq_s8(v5, v5, 8uLL);
  v8.rowBytes = *(unsigned int *)(a2 + 20);
  v9.data = v3;
  return vImageConvert_RGB888toBGRA8888(&v9, 0, a3, &v8, 0, 0) == 0;
}

BOOL cva::experimental::convertBGR8uToBGRA8u(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v11.data = *(void **)(a1 + 24);
  uint64_t v3 = *(void *)(a1 + 8);
  v4.i64[0] = v3;
  v4.i64[1] = HIDWORD(v3);
  *(int8x16_t *)&v11.height = vextq_s8(v4, v4, 8uLL);
  v11.rowBytes = *(unsigned int *)(a1 + 20);
  int8x16_t v5 = *(void **)(a2 + 24);
  uint64_t v6 = *(void *)(a2 + 8);
  v4.i64[0] = v6;
  v4.i64[1] = HIDWORD(v6);
  *(int8x16_t *)&v10.height = vextq_s8(v4, v4, 8uLL);
  v10.rowBytes = *(unsigned int *)(a2 + 20);
  v9.data = *(void **)(a3 + 24);
  uint64_t v7 = *(void *)(a3 + 8);
  v4.i64[0] = v7;
  v4.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v9.height = vextq_s8(v4, v4, 8uLL);
  v9.rowBytes = *(unsigned int *)(a3 + 20);
  v10.data = v5;
  return vImageConvert_RGB888toRGBA8888(&v11, &v10, 0, &v9, 0, 0) == 0;
}

BOOL cva::experimental::convertBGR8uToBGRA8u(uint64_t a1, uint64_t a2, Pixel_8 a3)
{
  uint64_t v3 = *(void **)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 8);
  v5.i64[0] = v4;
  v5.i64[1] = HIDWORD(v4);
  *(int8x16_t *)&v9.height = vextq_s8(v5, v5, 8uLL);
  v9.rowBytes = *(unsigned int *)(a1 + 20);
  v8.data = *(void **)(a2 + 24);
  uint64_t v6 = *(void *)(a2 + 8);
  v5.i64[0] = v6;
  v5.i64[1] = HIDWORD(v6);
  *(int8x16_t *)&v8.height = vextq_s8(v5, v5, 8uLL);
  v8.rowBytes = *(unsigned int *)(a2 + 20);
  v9.data = v3;
  return vImageConvert_RGB888toRGBA8888(&v9, 0, a3, &v8, 0, 0) == 0;
}

BOOL cva::experimental::convertBGR8uToRGBA8u(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v11.data = *(void **)(a1 + 24);
  uint64_t v3 = *(void *)(a1 + 8);
  v4.i64[0] = v3;
  v4.i64[1] = HIDWORD(v3);
  *(int8x16_t *)&v11.height = vextq_s8(v4, v4, 8uLL);
  v11.rowBytes = *(unsigned int *)(a1 + 20);
  int8x16_t v5 = *(void **)(a2 + 24);
  uint64_t v6 = *(void *)(a2 + 8);
  v4.i64[0] = v6;
  v4.i64[1] = HIDWORD(v6);
  *(int8x16_t *)&v10.height = vextq_s8(v4, v4, 8uLL);
  v10.rowBytes = *(unsigned int *)(a2 + 20);
  v9.data = *(void **)(a3 + 24);
  uint64_t v7 = *(void *)(a3 + 8);
  v4.i64[0] = v7;
  v4.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v9.height = vextq_s8(v4, v4, 8uLL);
  v9.rowBytes = *(unsigned int *)(a3 + 20);
  v10.data = v5;
  return vImageConvert_RGB888toBGRA8888(&v11, &v10, 0, &v9, 0, 0) == 0;
}

BOOL cva::experimental::convertBGR8uToRGBA8u(uint64_t a1, uint64_t a2, Pixel_8 a3)
{
  uint64_t v3 = *(void **)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 8);
  v5.i64[0] = v4;
  v5.i64[1] = HIDWORD(v4);
  *(int8x16_t *)&v9.height = vextq_s8(v5, v5, 8uLL);
  v9.rowBytes = *(unsigned int *)(a1 + 20);
  v8.data = *(void **)(a2 + 24);
  uint64_t v6 = *(void *)(a2 + 8);
  v5.i64[0] = v6;
  v5.i64[1] = HIDWORD(v6);
  *(int8x16_t *)&v8.height = vextq_s8(v5, v5, 8uLL);
  v8.rowBytes = *(unsigned int *)(a2 + 20);
  v9.data = v3;
  return vImageConvert_RGB888toBGRA8888(&v9, 0, a3, &v8, 0, 0) == 0;
}

BOOL cva::experimental::convertARGB8uToRGB8u(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 24);
  uint64_t v3 = *(void *)(a1 + 8);
  v4.i64[0] = v3;
  v4.i64[1] = HIDWORD(v3);
  *(int8x16_t *)&v8.height = vextq_s8(v4, v4, 8uLL);
  v8.rowBytes = *(unsigned int *)(a1 + 20);
  v7.data = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v4.i64[0] = v5;
  v4.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&v7.height = vextq_s8(v4, v4, 8uLL);
  v7.rowBytes = *(unsigned int *)(a2 + 20);
  v8.data = v2;
  return vImageConvert_ARGB8888toRGB888(&v8, &v7, 0) == 0;
}

BOOL cva::experimental::convertBGRA8uToRGB8u(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 24);
  uint64_t v3 = *(void *)(a1 + 8);
  v4.i64[0] = v3;
  v4.i64[1] = HIDWORD(v3);
  *(int8x16_t *)&v8.height = vextq_s8(v4, v4, 8uLL);
  v8.rowBytes = *(unsigned int *)(a1 + 20);
  v7.data = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v4.i64[0] = v5;
  v4.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&v7.height = vextq_s8(v4, v4, 8uLL);
  v7.rowBytes = *(unsigned int *)(a2 + 20);
  v8.data = v2;
  return vImageConvert_BGRA8888toRGB888(&v8, &v7, 0) == 0;
}

BOOL cva::experimental::convertRGBA8uToRGB8u(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 24);
  uint64_t v3 = *(void *)(a1 + 8);
  v4.i64[0] = v3;
  v4.i64[1] = HIDWORD(v3);
  *(int8x16_t *)&v8.height = vextq_s8(v4, v4, 8uLL);
  v8.rowBytes = *(unsigned int *)(a1 + 20);
  v7.data = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v4.i64[0] = v5;
  v4.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&v7.height = vextq_s8(v4, v4, 8uLL);
  v7.rowBytes = *(unsigned int *)(a2 + 20);
  v8.data = v2;
  return vImageConvert_RGBA8888toRGB888(&v8, &v7, 0) == 0;
}

BOOL cva::experimental::convertRGBA8uToBGR8u(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 24);
  uint64_t v3 = *(void *)(a1 + 8);
  v4.i64[0] = v3;
  v4.i64[1] = HIDWORD(v3);
  *(int8x16_t *)&v8.height = vextq_s8(v4, v4, 8uLL);
  v8.rowBytes = *(unsigned int *)(a1 + 20);
  v7.data = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v4.i64[0] = v5;
  v4.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&v7.height = vextq_s8(v4, v4, 8uLL);
  v7.rowBytes = *(unsigned int *)(a2 + 20);
  v8.data = v2;
  return vImageConvert_BGRA8888toRGB888(&v8, &v7, 0) == 0;
}

BOOL cva::experimental::convertBGRA8uToBGR8u(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 24);
  uint64_t v3 = *(void *)(a1 + 8);
  v4.i64[0] = v3;
  v4.i64[1] = HIDWORD(v3);
  *(int8x16_t *)&v8.height = vextq_s8(v4, v4, 8uLL);
  v8.rowBytes = *(unsigned int *)(a1 + 20);
  v7.data = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v4.i64[0] = v5;
  v4.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&v7.height = vextq_s8(v4, v4, 8uLL);
  v7.rowBytes = *(unsigned int *)(a2 + 20);
  v8.data = v2;
  return vImageConvert_RGBA8888toRGB888(&v8, &v7, 0) == 0;
}

BOOL cva::experimental::convertRGBA8uToPlanar8u(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *(void **)(a1 + 24);
  uint64_t v6 = *(void *)(a1 + 8);
  v7.i64[0] = v6;
  v7.i64[1] = HIDWORD(v6);
  *(int8x16_t *)&srcARGB.height = vextq_s8(v7, v7, 8uLL);
  srcARGB.rowBytes = *(unsigned int *)(a1 + 20);
  destA.data = *(void **)(a2 + 24);
  uint64_t v8 = *(void *)(a2 + 8);
  v7.i64[0] = v8;
  v7.i64[1] = HIDWORD(v8);
  *(int8x16_t *)&destA.height = vextq_s8(v7, v7, 8uLL);
  destA.rowBytes = *(unsigned int *)(a2 + 20);
  srcARGB.data = v5;
  vImage_Buffer v9 = *(void **)(a3 + 24);
  uint64_t v10 = *(void *)(a3 + 8);
  v7.i64[0] = v10;
  v7.i64[1] = HIDWORD(v10);
  *(int8x16_t *)&destR.height = vextq_s8(v7, v7, 8uLL);
  destR.rowBytes = *(unsigned int *)(a3 + 20);
  vImage_Buffer v11 = *(void **)(a4 + 24);
  uint64_t v12 = *(void *)(a4 + 8);
  v7.i64[0] = v12;
  v7.i64[1] = HIDWORD(v12);
  *(int8x16_t *)&destG.height = vextq_s8(v7, v7, 8uLL);
  destG.rowBytes = *(unsigned int *)(a4 + 20);
  destR.data = v9;
  v15.data = *(void **)(a5 + 24);
  uint64_t v13 = *(void *)(a5 + 8);
  v7.i64[0] = v13;
  v7.i64[1] = HIDWORD(v13);
  *(int8x16_t *)&v15.height = vextq_s8(v7, v7, 8uLL);
  v15.rowBytes = *(unsigned int *)(a5 + 20);
  destG.data = v11;
  return vImageConvert_ARGB8888toPlanar8(&srcARGB, &destA, &destR, &destG, &v15, 0) == 0;
}

BOOL cva::experimental::convertARGB8uToPlanar8u(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *(void **)(a1 + 24);
  uint64_t v6 = *(void *)(a1 + 8);
  v7.i64[0] = v6;
  v7.i64[1] = HIDWORD(v6);
  *(int8x16_t *)&srcARGB.height = vextq_s8(v7, v7, 8uLL);
  srcARGB.rowBytes = *(unsigned int *)(a1 + 20);
  destA.data = *(void **)(a2 + 24);
  uint64_t v8 = *(void *)(a2 + 8);
  v7.i64[0] = v8;
  v7.i64[1] = HIDWORD(v8);
  *(int8x16_t *)&destA.height = vextq_s8(v7, v7, 8uLL);
  destA.rowBytes = *(unsigned int *)(a2 + 20);
  srcARGB.data = v5;
  vImage_Buffer v9 = *(void **)(a3 + 24);
  uint64_t v10 = *(void *)(a3 + 8);
  v7.i64[0] = v10;
  v7.i64[1] = HIDWORD(v10);
  *(int8x16_t *)&destR.height = vextq_s8(v7, v7, 8uLL);
  destR.rowBytes = *(unsigned int *)(a3 + 20);
  vImage_Buffer v11 = *(void **)(a4 + 24);
  uint64_t v12 = *(void *)(a4 + 8);
  v7.i64[0] = v12;
  v7.i64[1] = HIDWORD(v12);
  *(int8x16_t *)&destG.height = vextq_s8(v7, v7, 8uLL);
  destG.rowBytes = *(unsigned int *)(a4 + 20);
  destR.data = v9;
  v15.data = *(void **)(a5 + 24);
  uint64_t v13 = *(void *)(a5 + 8);
  v7.i64[0] = v13;
  v7.i64[1] = HIDWORD(v13);
  *(int8x16_t *)&v15.height = vextq_s8(v7, v7, 8uLL);
  v15.rowBytes = *(unsigned int *)(a5 + 20);
  destG.data = v11;
  return vImageConvert_ARGB8888toPlanar8(&srcARGB, &destA, &destR, &destG, &v15, 0) == 0;
}

BOOL cva::experimental::convertBGRA8uToPlanar8u(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *(void **)(a1 + 24);
  uint64_t v6 = *(void *)(a1 + 8);
  v7.i64[0] = v6;
  v7.i64[1] = HIDWORD(v6);
  *(int8x16_t *)&srcARGB.height = vextq_s8(v7, v7, 8uLL);
  srcARGB.rowBytes = *(unsigned int *)(a1 + 20);
  destA.data = *(void **)(a2 + 24);
  uint64_t v8 = *(void *)(a2 + 8);
  v7.i64[0] = v8;
  v7.i64[1] = HIDWORD(v8);
  *(int8x16_t *)&destA.height = vextq_s8(v7, v7, 8uLL);
  destA.rowBytes = *(unsigned int *)(a2 + 20);
  srcARGB.data = v5;
  vImage_Buffer v9 = *(void **)(a3 + 24);
  uint64_t v10 = *(void *)(a3 + 8);
  v7.i64[0] = v10;
  v7.i64[1] = HIDWORD(v10);
  *(int8x16_t *)&destR.height = vextq_s8(v7, v7, 8uLL);
  destR.rowBytes = *(unsigned int *)(a3 + 20);
  vImage_Buffer v11 = *(void **)(a4 + 24);
  uint64_t v12 = *(void *)(a4 + 8);
  v7.i64[0] = v12;
  v7.i64[1] = HIDWORD(v12);
  *(int8x16_t *)&destG.height = vextq_s8(v7, v7, 8uLL);
  destG.rowBytes = *(unsigned int *)(a4 + 20);
  destR.data = v9;
  v15.data = *(void **)(a5 + 24);
  uint64_t v13 = *(void *)(a5 + 8);
  v7.i64[0] = v13;
  v7.i64[1] = HIDWORD(v13);
  *(int8x16_t *)&v15.height = vextq_s8(v7, v7, 8uLL);
  v15.rowBytes = *(unsigned int *)(a5 + 20);
  destG.data = v11;
  return vImageConvert_ARGB8888toPlanar8(&srcARGB, &destA, &destR, &destG, &v15, 0) == 0;
}

BOOL cva::experimental::convertBGR8uToPlanar8u(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  rgbSrc.data = *(void **)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 8);
  v5.i64[0] = v4;
  v5.i64[1] = HIDWORD(v4);
  *(int8x16_t *)&rgbSrc.height = vextq_s8(v5, v5, 8uLL);
  rgbSrc.rowBytes = *(unsigned int *)(a1 + 20);
  uint64_t v6 = *(void **)(a2 + 24);
  uint64_t v7 = *(void *)(a2 + 8);
  v5.i64[0] = v7;
  v5.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&redDest.height = vextq_s8(v5, v5, 8uLL);
  redDest.rowBytes = *(unsigned int *)(a2 + 20);
  uint64_t v8 = *(void **)(a3 + 24);
  uint64_t v9 = *(void *)(a3 + 8);
  v5.i64[0] = v9;
  v5.i64[1] = HIDWORD(v9);
  *(int8x16_t *)&greenDest.height = vextq_s8(v5, v5, 8uLL);
  greenDest.rowBytes = *(unsigned int *)(a3 + 20);
  redDest.data = v6;
  v12.data = *(void **)(a4 + 24);
  uint64_t v10 = *(void *)(a4 + 8);
  v5.i64[0] = v10;
  v5.i64[1] = HIDWORD(v10);
  *(int8x16_t *)&v12.height = vextq_s8(v5, v5, 8uLL);
  v12.rowBytes = *(unsigned int *)(a4 + 20);
  greenDest.data = v8;
  return vImageConvert_RGB888toPlanar8(&rgbSrc, &redDest, &greenDest, &v12, 0) == 0;
}

BOOL cva::experimental::convertRGB8uToPlanar8u(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  rgbSrc.data = *(void **)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 8);
  v5.i64[0] = v4;
  v5.i64[1] = HIDWORD(v4);
  *(int8x16_t *)&rgbSrc.height = vextq_s8(v5, v5, 8uLL);
  rgbSrc.rowBytes = *(unsigned int *)(a1 + 20);
  uint64_t v6 = *(void **)(a2 + 24);
  uint64_t v7 = *(void *)(a2 + 8);
  v5.i64[0] = v7;
  v5.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&redDest.height = vextq_s8(v5, v5, 8uLL);
  redDest.rowBytes = *(unsigned int *)(a2 + 20);
  uint64_t v8 = *(void **)(a3 + 24);
  uint64_t v9 = *(void *)(a3 + 8);
  v5.i64[0] = v9;
  v5.i64[1] = HIDWORD(v9);
  *(int8x16_t *)&greenDest.height = vextq_s8(v5, v5, 8uLL);
  greenDest.rowBytes = *(unsigned int *)(a3 + 20);
  redDest.data = v6;
  v12.data = *(void **)(a4 + 24);
  uint64_t v10 = *(void *)(a4 + 8);
  v5.i64[0] = v10;
  v5.i64[1] = HIDWORD(v10);
  *(int8x16_t *)&v12.height = vextq_s8(v5, v5, 8uLL);
  v12.rowBytes = *(unsigned int *)(a4 + 20);
  greenDest.data = v8;
  return vImageConvert_RGB888toPlanar8(&rgbSrc, &redDest, &greenDest, &v12, 0) == 0;
}

uint64_t cva::experimental::convertRGB8uToGray8u(void *a1, uint64_t a2, unsigned __int8 ***a3)
{
  uint64_t v3 = a1[3];
  if (v3)
  {
    uint64_t v4 = a1[1];
    unint64_t v20 = a1[2];
    uint64_t v5 = (HIDWORD(v20) * HIDWORD(v4));
    if (v5)
    {
      int v7 = 0;
      int v8 = 0;
      unint64_t v9 = v3 + *a1;
      uint64_t v19 = v9 + v5;
      uint64_t v10 = *(void *)(a2 + 24);
      uint64_t v18 = HIDWORD(*(void *)(a2 + 16));
      if (v10) {
        vImage_Buffer v11 = (unsigned char *)(v10 + *(void *)a2);
      }
      else {
        vImage_Buffer v11 = 0;
      }
      int v17 = *(_DWORD *)(a2 + 8);
      uint64_t v12 = a1[2];
      unsigned int v13 = *(void *)(a2 + 16);
      do
      {
        unint64_t v21 = v9;
        uint64_t v22 = (uint64_t *)&v21;
        v23[0] = (unsigned __int8 ***)&v22;
        v23[1] = a3;
        __int16 v24 = 0;
        sub_21540DB18((uint64_t)&v24, v23);
        unsigned char *v11 = HIBYTE(v24);
        int v14 = v8 + 1;
        if (v8 + 1 == v4) {
          int v8 = 0;
        }
        else {
          ++v8;
        }
        if (v14 == v4) {
          unint64_t v9 = v9 + v12 - (v14 * v20) + HIDWORD(v20);
        }
        else {
          v9 += v12;
        }
        int v15 = v7 + 1;
        if (v7 + 1 == v17) {
          int v7 = 0;
        }
        else {
          ++v7;
        }
        if (v15 == v17) {
          vImage_Buffer v11 = &v11[v13 - v15 * v13 + v18];
        }
        else {
          v11 += v13;
        }
      }
      while (v9 != v19);
    }
  }
  return 1;
}

uint64_t sub_21540DB18(uint64_t result, unsigned __int8 ****a2)
{
  uint64_t v2 = (_WORD *)result;
  uint64_t v3 = a2[1];
  if (v3 == (_WORD *)result)
  {
    __int16 v5 = 0;
    float result = sub_21540DB18(&v5);
    __int16 v4 = v5;
  }
  else
  {
    __int16 v4 = *v3 * ****a2 + v3[1] * (***a2)[1] + v3[2] * (***a2)[2];
  }
  _WORD *v2 = v4;
  return result;
}

uint64_t cva::experimental::convertBGR8uToGray8u(void *a1, uint64_t a2, unsigned __int8 ***a3)
{
  uint64_t v3 = a1[3];
  if (v3)
  {
    uint64_t v4 = a1[1];
    unint64_t v20 = a1[2];
    uint64_t v5 = (HIDWORD(v20) * HIDWORD(v4));
    if (v5)
    {
      int v7 = 0;
      int v8 = 0;
      unint64_t v9 = v3 + *a1;
      uint64_t v19 = v9 + v5;
      uint64_t v10 = *(void *)(a2 + 24);
      uint64_t v18 = HIDWORD(*(void *)(a2 + 16));
      if (v10) {
        vImage_Buffer v11 = (unsigned char *)(v10 + *(void *)a2);
      }
      else {
        vImage_Buffer v11 = 0;
      }
      int v17 = *(_DWORD *)(a2 + 8);
      uint64_t v12 = a1[2];
      unsigned int v13 = *(void *)(a2 + 16);
      do
      {
        unint64_t v21 = v9;
        uint64_t v22 = (uint64_t *)&v21;
        v23[0] = (unsigned __int8 ***)&v22;
        v23[1] = a3;
        __int16 v24 = 0;
        sub_21540DB18((uint64_t)&v24, v23);
        unsigned char *v11 = HIBYTE(v24);
        int v14 = v8 + 1;
        if (v8 + 1 == v4) {
          int v8 = 0;
        }
        else {
          ++v8;
        }
        if (v14 == v4) {
          unint64_t v9 = v9 + v12 - (v14 * v20) + HIDWORD(v20);
        }
        else {
          v9 += v12;
        }
        int v15 = v7 + 1;
        if (v7 + 1 == v17) {
          int v7 = 0;
        }
        else {
          ++v7;
        }
        if (v15 == v17) {
          vImage_Buffer v11 = &v11[v13 - v15 * v13 + v18];
        }
        else {
          v11 += v13;
        }
      }
      while (v9 != v19);
    }
  }
  return 1;
}

uint64_t cva::experimental::convertGray8uToRGB8u(void *a1, uint64_t a2)
{
  uint64_t v2 = a1[3];
  if (v2)
  {
    uint64_t v3 = a1[1];
    unint64_t v4 = a1[2];
    uint64_t v5 = (HIDWORD(v4) * HIDWORD(v3));
    if (v5)
    {
      int v6 = 0;
      int v7 = 0;
      int v8 = (char *)(v2 + *a1);
      unint64_t v9 = &v8[v5];
      int v10 = *(_DWORD *)(a2 + 8);
      unint64_t v12 = *(void *)(a2 + 16);
      uint64_t v11 = *(void *)(a2 + 24);
      unsigned int v13 = (char *)(v11 + *(void *)a2);
      if (v11) {
        int v14 = v13;
      }
      else {
        int v14 = 0;
      }
      do
      {
        char v15 = *v8;
        char *v14 = *v8;
        v14[1] = v15;
        void v14[2] = v15;
        v8 += v4;
        int v16 = v7 + 1;
        if (v7 + 1 == v3) {
          int v7 = 0;
        }
        else {
          ++v7;
        }
        if (v16 == v3) {
          int v8 = &v8[HIDWORD(v4) - (v16 * v4)];
        }
        v14 += v12;
        int v17 = v6 + 1;
        if (v6 + 1 == v10) {
          int v6 = 0;
        }
        else {
          ++v6;
        }
        if (v17 == v10) {
          int v14 = &v14[HIDWORD(v12) - (v17 * v12)];
        }
      }
      while (v8 != v9);
    }
  }
  return 1;
}

uint64_t cva::experimental::convertGray8uToBGR8u(void *a1, uint64_t a2)
{
  uint64_t v2 = a1[3];
  if (v2)
  {
    uint64_t v3 = a1[1];
    unint64_t v4 = a1[2];
    uint64_t v5 = (HIDWORD(v4) * HIDWORD(v3));
    if (v5)
    {
      int v6 = 0;
      int v7 = 0;
      int v8 = (char *)(v2 + *a1);
      unint64_t v9 = &v8[v5];
      int v10 = *(_DWORD *)(a2 + 8);
      unint64_t v12 = *(void *)(a2 + 16);
      uint64_t v11 = *(void *)(a2 + 24);
      unsigned int v13 = (char *)(v11 + *(void *)a2);
      if (v11) {
        int v14 = v13;
      }
      else {
        int v14 = 0;
      }
      do
      {
        char v15 = *v8;
        char *v14 = *v8;
        v14[1] = v15;
        void v14[2] = v15;
        v8 += v4;
        int v16 = v7 + 1;
        if (v7 + 1 == v3) {
          int v7 = 0;
        }
        else {
          ++v7;
        }
        if (v16 == v3) {
          int v8 = &v8[HIDWORD(v4) - (v16 * v4)];
        }
        v14 += v12;
        int v17 = v6 + 1;
        if (v6 + 1 == v10) {
          int v6 = 0;
        }
        else {
          ++v6;
        }
        if (v17 == v10) {
          int v14 = &v14[HIDWORD(v12) - (v17 * v12)];
        }
      }
      while (v8 != v9);
    }
  }
  return 1;
}

uint64_t cva::experimental::convertGray8uToRGBA8u(void *a1, void *a2, uint64_t a3)
{
  uint64_t v3 = a2[3];
  if (v3) {
    unint64_t v4 = (unsigned __int8 *)(v3 + *a2);
  }
  else {
    unint64_t v4 = 0;
  }
  uint64_t v5 = a1[3];
  if (v5)
  {
    uint64_t v6 = a1[1];
    unint64_t v7 = a1[2];
    uint64_t v8 = (HIDWORD(v7) * HIDWORD(v6));
    if (v8)
    {
      int v9 = 0;
      int v10 = 0;
      int v11 = 0;
      uint64_t v12 = a2[1];
      unint64_t v13 = a2[2];
      int v14 = (unsigned __int8 *)(v5 + *a1);
      char v15 = &v14[v8];
      unint64_t v17 = *(void *)(a3 + 16);
      uint64_t v16 = *(void *)(a3 + 24);
      if (v16) {
        uint64_t v18 = (int *)(v16 + *(void *)a3);
      }
      else {
        uint64_t v18 = 0;
      }
      int v19 = *(_DWORD *)(a3 + 8);
      do
      {
        unint64_t v20 = &v4[v13];
        int v21 = v9 + 1;
        uint64_t v22 = &v20[HIDWORD(v13) - ((v9 + 1) * v13)];
        if (v9 + 1 == v12) {
          int v9 = 0;
        }
        else {
          ++v9;
        }
        int v23 = *v4;
        if (v21 == v12) {
          unint64_t v20 = v22;
        }
        int *v18 = (*v14 << 16) | (*v14 << 8) | (v23 << 24) | *v14;
        v14 += v7;
        int v24 = v11 + 1;
        if (v11 + 1 == v6) {
          int v11 = 0;
        }
        else {
          ++v11;
        }
        if (v24 == v6) {
          int v14 = &v14[HIDWORD(v7) - (v24 * v7)];
        }
        int v25 = (int *)((char *)v18 + v17);
        int v26 = v10 + 1;
        if (v10 + 1 == v19) {
          int v10 = 0;
        }
        else {
          ++v10;
        }
        if (v26 == v19) {
          uint64_t v18 = (int *)((char *)v25 + HIDWORD(v17) - (v26 * v17));
        }
        else {
          uint64_t v18 = v25;
        }
        unint64_t v4 = v20;
      }
      while (v14 != v15);
    }
  }
  return 1;
}

uint64_t cva::experimental::convertGray8uToARGB8u(void *a1, void *a2, uint64_t a3)
{
  uint64_t v3 = a2[3];
  if (v3) {
    unint64_t v4 = (unsigned __int8 *)(v3 + *a2);
  }
  else {
    unint64_t v4 = 0;
  }
  uint64_t v5 = a1[3];
  if (v5)
  {
    uint64_t v6 = a1[1];
    unint64_t v7 = a1[2];
    uint64_t v8 = (HIDWORD(v7) * HIDWORD(v6));
    if (v8)
    {
      int v9 = 0;
      int v10 = 0;
      int v11 = 0;
      uint64_t v12 = a2[1];
      unint64_t v13 = a2[2];
      int v14 = (unsigned __int8 *)(v5 + *a1);
      char v15 = &v14[v8];
      unint64_t v17 = *(void *)(a3 + 16);
      uint64_t v16 = *(void *)(a3 + 24);
      if (v16) {
        uint64_t v18 = (int *)(v16 + *(void *)a3);
      }
      else {
        uint64_t v18 = 0;
      }
      int v19 = *(_DWORD *)(a3 + 8);
      do
      {
        unint64_t v20 = &v4[v13];
        int v21 = v9 + 1;
        uint64_t v22 = &v20[HIDWORD(v13) - ((v9 + 1) * v13)];
        if (v9 + 1 == v12) {
          int v9 = 0;
        }
        else {
          ++v9;
        }
        int v23 = *v4;
        if (v21 == v12) {
          unint64_t v20 = v22;
        }
        int *v18 = (*v14 << 16) | (*v14 << 24) | (*v14 << 8) | v23;
        v14 += v7;
        int v24 = v11 + 1;
        if (v11 + 1 == v6) {
          int v11 = 0;
        }
        else {
          ++v11;
        }
        if (v24 == v6) {
          int v14 = &v14[HIDWORD(v7) - (v24 * v7)];
        }
        int v25 = (int *)((char *)v18 + v17);
        int v26 = v10 + 1;
        if (v10 + 1 == v19) {
          int v10 = 0;
        }
        else {
          ++v10;
        }
        if (v26 == v19) {
          uint64_t v18 = (int *)((char *)v25 + HIDWORD(v17) - (v26 * v17));
        }
        else {
          uint64_t v18 = v25;
        }
        unint64_t v4 = v20;
      }
      while (v14 != v15);
    }
  }
  return 1;
}

uint64_t cva::experimental::convertGray8uToBGRA8u(void *a1, void *a2, uint64_t a3)
{
  return 1;
}

uint64_t cva::experimental::convertGray8uToARGB8u(void *a1, uint64_t a2, int a3)
{
  uint64_t v3 = a1[3];
  if (v3)
  {
    uint64_t v4 = a1[1];
    unint64_t v5 = a1[2];
    uint64_t v6 = (HIDWORD(v5) * HIDWORD(v4));
    if (v6)
    {
      int v7 = 0;
      int v8 = 0;
      int v9 = (unsigned __int8 *)(v3 + *a1);
      int v10 = &v9[v6];
      unint64_t v11 = *(void *)(a2 + 16);
      uint64_t v12 = *(void *)(a2 + 24);
      unint64_t v13 = (int *)(v12 + *(void *)a2);
      BOOL v14 = v12 == 0;
      int v15 = *(_DWORD *)(a2 + 8);
      if (v14) {
        uint64_t v16 = 0;
      }
      else {
        uint64_t v16 = v13;
      }
      do
      {
        int *v16 = (16843008 * *v9) | a3;
        v9 += v5;
        int v17 = v8 + 1;
        if (v8 + 1 == v4) {
          int v8 = 0;
        }
        else {
          ++v8;
        }
        if (v17 == v4) {
          int v9 = &v9[HIDWORD(v5) - (v17 * v5)];
        }
        uint64_t v16 = (int *)((char *)v16 + v11);
        int v18 = v7 + 1;
        if (v7 + 1 == v15) {
          int v7 = 0;
        }
        else {
          ++v7;
        }
        if (v18 == v15) {
          uint64_t v16 = (int *)((char *)v16 + HIDWORD(v11) - (v18 * v11));
        }
      }
      while (v9 != v10);
    }
  }
  return 1;
}

uint64_t cva::experimental::convertGray8uToRGBA8u(void *a1, uint64_t a2, int a3)
{
  uint64_t v3 = a1[3];
  if (v3)
  {
    uint64_t v4 = a1[1];
    unint64_t v5 = a1[2];
    uint64_t v6 = (HIDWORD(v5) * HIDWORD(v4));
    if (v6)
    {
      int v7 = 0;
      int v8 = 0;
      int v9 = (unsigned __int8 *)(v3 + *a1);
      int v10 = &v9[v6];
      unint64_t v11 = *(void *)(a2 + 16);
      uint64_t v12 = *(void *)(a2 + 24);
      unint64_t v13 = (int *)(v12 + *(void *)a2);
      BOOL v14 = v12 == 0;
      int v15 = *(_DWORD *)(a2 + 8);
      if (v14) {
        uint64_t v16 = 0;
      }
      else {
        uint64_t v16 = v13;
      }
      do
      {
        int *v16 = (a3 << 24) | (*v9 << 16) | (*v9 << 8) | *v9;
        v9 += v5;
        int v17 = v8 + 1;
        if (v8 + 1 == v4) {
          int v8 = 0;
        }
        else {
          ++v8;
        }
        if (v17 == v4) {
          int v9 = &v9[HIDWORD(v5) - (v17 * v5)];
        }
        uint64_t v16 = (int *)((char *)v16 + v11);
        int v18 = v7 + 1;
        if (v7 + 1 == v15) {
          int v7 = 0;
        }
        else {
          ++v7;
        }
        if (v18 == v15) {
          uint64_t v16 = (int *)((char *)v16 + HIDWORD(v11) - (v18 * v11));
        }
      }
      while (v9 != v10);
    }
  }
  return 1;
}

uint64_t cva::experimental::convertGray8uToBGRA8u(void *a1, uint64_t a2, int a3)
{
  uint64_t v3 = a1[3];
  if (v3)
  {
    uint64_t v4 = a1[1];
    unint64_t v5 = a1[2];
    uint64_t v6 = (HIDWORD(v5) * HIDWORD(v4));
    if (v6)
    {
      int v7 = 0;
      int v8 = 0;
      int v9 = (unsigned __int8 *)(v3 + *a1);
      int v10 = &v9[v6];
      unint64_t v11 = *(void *)(a2 + 16);
      uint64_t v12 = *(void *)(a2 + 24);
      unint64_t v13 = (int *)(v12 + *(void *)a2);
      BOOL v14 = v12 == 0;
      int v15 = *(_DWORD *)(a2 + 8);
      if (v14) {
        uint64_t v16 = 0;
      }
      else {
        uint64_t v16 = v13;
      }
      do
      {
        int *v16 = (a3 << 24) | (*v9 << 16) | (*v9 << 8) | *v9;
        v9 += v5;
        int v17 = v8 + 1;
        if (v8 + 1 == v4) {
          int v8 = 0;
        }
        else {
          ++v8;
        }
        if (v17 == v4) {
          int v9 = &v9[HIDWORD(v5) - (v17 * v5)];
        }
        uint64_t v16 = (int *)((char *)v16 + v11);
        int v18 = v7 + 1;
        if (v7 + 1 == v15) {
          int v7 = 0;
        }
        else {
          ++v7;
        }
        if (v18 == v15) {
          uint64_t v16 = (int *)((char *)v16 + HIDWORD(v11) - (v18 * v11));
        }
      }
      while (v9 != v10);
    }
  }
  return 1;
}

BOOL cva::experimental::convertARGB8uToGray8u(uint64_t a1, uint64_t a2, void *a3)
{
  src.data = *(void **)(a1 + 24);
  uint64_t v3 = *(void *)(a1 + 8);
  v4.i64[0] = v3;
  v4.i64[1] = HIDWORD(v3);
  *(int8x16_t *)&src.height = vextq_s8(v4, v4, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  dest.data = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v4.i64[0] = v5;
  v4.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&dest.height = vextq_s8(v4, v4, 8uLL);
  dest.rowBytes = *(unsigned int *)(a2 + 20);
  *(void *)matrix = *a3;
  return vImageMatrixMultiply_ARGB8888ToPlanar8(&src, &dest, matrix, 256, 0, 0, 0) == 0;
}

BOOL cva::experimental::convertRGBA8uToGray8u(uint64_t a1, uint64_t a2, void *a3)
{
  src.data = *(void **)(a1 + 24);
  uint64_t v3 = *(void *)(a1 + 8);
  v4.i64[0] = v3;
  v4.i64[1] = HIDWORD(v3);
  *(int8x16_t *)&src.height = vextq_s8(v4, v4, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  dest.data = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v4.i64[0] = v5;
  v4.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&dest.height = vextq_s8(v4, v4, 8uLL);
  dest.rowBytes = *(unsigned int *)(a2 + 20);
  *(void *)matrix = *a3;
  return vImageMatrixMultiply_ARGB8888ToPlanar8(&src, &dest, matrix, 256, 0, 0, 0) == 0;
}

BOOL cva::experimental::convertBGRA8uToGray8u(uint64_t a1, uint64_t a2, void *a3)
{
  src.data = *(void **)(a1 + 24);
  uint64_t v3 = *(void *)(a1 + 8);
  v4.i64[0] = v3;
  v4.i64[1] = HIDWORD(v3);
  *(int8x16_t *)&src.height = vextq_s8(v4, v4, 8uLL);
  src.rowBytes = *(unsigned int *)(a1 + 20);
  dest.data = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v4.i64[0] = v5;
  v4.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&dest.height = vextq_s8(v4, v4, 8uLL);
  dest.rowBytes = *(unsigned int *)(a2 + 20);
  *(void *)matrix = *a3;
  return vImageMatrixMultiply_ARGB8888ToPlanar8(&src, &dest, matrix, 256, 0, 0, 0) == 0;
}

BOOL cva::experimental::overwriteChannels_ARGB8u(uint64_t a1, uint64_t a2, uint64_t a3, uint8_t a4)
{
  newSrc.data = *(void **)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 8);
  v5.i64[0] = v4;
  v5.i64[1] = HIDWORD(v4);
  *(int8x16_t *)&newSrc.height = vextq_s8(v5, v5, 8uLL);
  newSrc.rowBytes = *(unsigned int *)(a1 + 20);
  uint64_t v6 = *(void **)(a2 + 24);
  uint64_t v7 = *(void *)(a2 + 8);
  v5.i64[0] = v7;
  v5.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&origSrc.height = vextq_s8(v5, v5, 8uLL);
  origSrc.rowBytes = *(unsigned int *)(a2 + 20);
  v10.data = *(void **)(a3 + 24);
  uint64_t v8 = *(void *)(a3 + 8);
  v5.i64[0] = v8;
  v5.i64[1] = HIDWORD(v8);
  *(int8x16_t *)&v10.height = vextq_s8(v5, v5, 8uLL);
  v10.rowBytes = *(unsigned int *)(a3 + 20);
  origSrc.data = v6;
  return vImageOverwriteChannels_ARGB8888(&newSrc, &origSrc, &v10, a4, 0) == 0;
}

BOOL cva::experimental::overwriteChannelsWithScalar_ARGB8u(Pixel_8 a1, uint64_t a2, uint64_t a3, uint8_t a4)
{
  uint64_t v4 = *(void **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 8);
  v6.i64[0] = v5;
  v6.i64[1] = HIDWORD(v5);
  *(int8x16_t *)&src.height = vextq_s8(v6, v6, 8uLL);
  src.rowBytes = *(unsigned int *)(a2 + 20);
  v9.data = *(void **)(a3 + 24);
  uint64_t v7 = *(void *)(a3 + 8);
  v6.i64[0] = v7;
  v6.i64[1] = HIDWORD(v7);
  *(int8x16_t *)&v9.height = vextq_s8(v6, v6, 8uLL);
  v9.rowBytes = *(unsigned int *)(a3 + 20);
  src.data = v4;
  return vImageOverwriteChannelsWithScalar_ARGB8888(a1, &src, &v9, a4, 0) == 0;
}

uint64_t cva::experimental::createImageWithCVPixelBuffer(CVPixelBufferRef *a1, uint64_t a2)
{
  if (!CVPixelBufferLockBaseAddress(*a1, 1uLL))
  {
    signed int PixelFormatType = CVPixelBufferGetPixelFormatType(*a1);
    unsigned int Width = CVPixelBufferGetWidth(*a1);
    unsigned int Height = CVPixelBufferGetHeight(*a1);
    unsigned int v8 = Height;
    if (*(_DWORD *)(a2 + 8) >= Width && *(_DWORD *)(a2 + 12) >= Height)
    {
      *(void *)a2 = 0;
      *(void *)(a2 + 8) = Width | ((unint64_t)Height << 32);
    }
    else
    {
      vImage_Buffer v10 = *(void **)(a2 + 24);
      if (v10)
      {
        free(v10);
        *(void *)(a2 + 24) = 0;
      }
      *(void *)a2 = 0;
      *(void *)(a2 + 8) = Width | ((unint64_t)v8 << 32);
      *(void *)(a2 + 16) = ((unint64_t)(((3 * Width + 15) & 0xFFFFFFF0) >> 4) << 36) | 3;
      size.data = (void *)(((3 * Width + 15) & 0xFFFFFFF0) * (unint64_t)v8);
      if (size.data) {
        unint64_t v11 = malloc_type_malloc((size_t)size.data, 0xA153FF5uLL);
      }
      else {
        unint64_t v11 = 0;
      }
      *(void *)(a2 + 24) = v11;
    }
    uint64_t v4 = 0;
    if (PixelFormatType <= 875704437)
    {
      if (PixelFormatType <= 846624120)
      {
        if (PixelFormatType == 24) {
          cva::imageViewFromPixelBuffer<cva::Matrix<unsigned char,3u,1u,false>>();
        }
        if (PixelFormatType == 32) {
          cva::imageViewFromPixelBuffer<cva::Matrix<unsigned char,4u,1u,false>>();
        }
        goto LABEL_40;
      }
      if (PixelFormatType == 846624121) {
        goto LABEL_29;
      }
      int v12 = 875704422;
    }
    else
    {
      if (PixelFormatType <= 1380401728)
      {
        if (PixelFormatType != 875704438)
        {
          if (PixelFormatType == 1111970369) {
            cva::imageViewFromPixelBuffer<cva::Matrix<unsigned char,4u,1u,false>>();
          }
          goto LABEL_40;
        }
        goto LABEL_29;
      }
      if (PixelFormatType == 1380401729) {
        cva::imageViewFromPixelBuffer<cva::Matrix<unsigned char,4u,1u,false>>();
      }
      if (PixelFormatType == 2037741158)
      {
LABEL_29:
        unint64_t v20 = 0;
        unint64_t v21 = 0;
        uint64_t v22 = 0;
        if (v8 | Width)
        {
          size_t v13 = (4 * Width + 15) & 0xFFFFFFF0;
          unint64_t v14 = Width | ((unint64_t)v8 << 32);
          uint64_t v19 = 0;
          unint64_t v20 = v14;
          unint64_t v21 = ((unint64_t)(v13 >> 4) << 36) | 4;
          size.data = (void *)(v13 * (unint64_t)v8);
          if (size.data) {
            int v15 = malloc_type_malloc((size_t)size.data, 0xA153FF5uLL);
          }
          else {
            int v15 = 0;
          }
          uint64_t v22 = v15;
        }
        else
        {
          size_t v13 = 0;
          int v15 = 0;
          unint64_t v14 = Width | ((unint64_t)v8 << 32);
          uint64_t v19 = 0;
          unint64_t v20 = v14;
        }
        cva::pixelBufferConvertYCbCrToARGB(*a1, (uint64_t)&v19, 1);
        v16.i64[0] = v14;
        v16.i64[1] = HIDWORD(v14);
        *(int8x16_t *)&size.height = vextq_s8(v16, v16, 8uLL);
        size.rowBytes = v13;
        v23.data = *(void **)(a2 + 24);
        uint64_t v17 = *(void *)(a2 + 8);
        v16.i64[0] = v17;
        v16.i64[1] = HIDWORD(v17);
        *(int8x16_t *)&v23.height = vextq_s8(v16, v16, 8uLL);
        v23.rowBytes = *(unsigned int *)(a2 + 20);
        size.data = v15;
        vImageConvert_ARGB8888toRGB888(&size, &v23, 0);
        if (v15) {
          free(v15);
        }
        uint64_t v4 = 1;
        goto LABEL_40;
      }
      int v12 = 2037741171;
    }
    if (PixelFormatType != v12)
    {
LABEL_40:
      CVPixelBufferUnlockBaseAddress(*a1, 1uLL);
      return v4;
    }
    goto LABEL_29;
  }
  return 0;
}

{
  uint64_t v4;
  signed int PixelFormatType;
  unsigned int Width;
  unsigned int Height;
  unsigned int v8;
  void *v10;
  void *v11;
  unint64_t size;

  if (!CVPixelBufferLockBaseAddress(*a1, 1uLL))
  {
    signed int PixelFormatType = CVPixelBufferGetPixelFormatType(*a1);
    unsigned int Width = CVPixelBufferGetWidth(*a1);
    unsigned int Height = CVPixelBufferGetHeight(*a1);
    unsigned int v8 = Height;
    if (*(_DWORD *)(a2 + 8) >= Width && *(_DWORD *)(a2 + 12) >= Height)
    {
      *(void *)a2 = 0;
      *(void *)(a2 + 8) = Width | ((unint64_t)Height << 32);
    }
    else
    {
      vImage_Buffer v10 = *(void **)(a2 + 24);
      if (v10)
      {
        free(v10);
        *(void *)(a2 + 24) = 0;
      }
      *(void *)a2 = 0;
      *(void *)(a2 + 8) = Width | ((unint64_t)v8 << 32);
      *(void *)(a2 + 16) = ((unint64_t)(((4 * Width + 15) & 0xFFFFFFF0) >> 4) << 36) | 4;
      vImage_Buffer size = ((4 * Width + 15) & 0xFFFFFFF0) * (unint64_t)v8;
      if (size) {
        unint64_t v11 = malloc_type_malloc(size, 0xA153FF5uLL);
      }
      else {
        unint64_t v11 = 0;
      }
      *(void *)(a2 + 24) = v11;
    }
    uint64_t v4 = 0;
    if (PixelFormatType <= 875704421)
    {
      if (PixelFormatType == 24) {
        cva::imageViewFromPixelBuffer<cva::Matrix<unsigned char,3u,1u,false>>();
      }
      if (PixelFormatType == 32) {
        cva::imageViewFromPixelBuffer<cva::Matrix<unsigned char,4u,1u,false>>();
      }
      if (PixelFormatType != 846624121) {
        goto LABEL_28;
      }
    }
    else if (PixelFormatType > 2037741157)
    {
      if (PixelFormatType != 2037741158 && PixelFormatType != 2037741171) {
        goto LABEL_28;
      }
    }
    else if (PixelFormatType != 875704422 && PixelFormatType != 875704438)
    {
      goto LABEL_28;
    }
    uint64_t v4 = 1;
    cva::pixelBufferConvertYCbCrToARGB(*a1, a2, 1);
LABEL_28:
    CVPixelBufferUnlockBaseAddress(*a1, 1uLL);
    return v4;
  }
  return 0;
}

{
  uint64_t v4;
  unsigned int Width;
  unsigned int Height;
  signed int PixelFormatType;
  unsigned int BytesPerRow;
  char *BaseAddress;
  void *v11;
  void *v12;
  uint64_t v13;
  int8x16_t v14;
  void *v15;
  uint64_t v16;
  int8x16_t v17;
  vImagePixelCount v18;
  vImagePixelCount v19;
  size_t v20;
  size_t v21;
  unsigned int BytesPerRowOfPlane;
  char *BaseAddressOfPlane;
  uint64_t v24;
  int v25;
  int v26;
  unint64_t v27;
  uint64_t v28;
  int v29;
  char *v30;
  unsigned char *v31;
  char v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  int8x16_t v36;
  uint64_t v37;
  int8x16_t v38;
  uint64_t v39;
  int8x16_t v40;
  size_t size;
  int8x16_t v43;
  uint64_t v44;
  vImage_Buffer *destPlanarBuffers;
  void *srcChannels[2];

  srcChannels[1] = *(void **)MEMORY[0x263EF8340];
  if (!CVPixelBufferLockBaseAddress(*a1, 1uLL))
  {
    unsigned int Width = CVPixelBufferGetWidth(*a1);
    unsigned int Height = CVPixelBufferGetHeight(*a1);
    signed int PixelFormatType = CVPixelBufferGetPixelFormatType(*a1);
    size_t BytesPerRow = CVPixelBufferGetBytesPerRow(*a1);
    BaseAddress = (char *)CVPixelBufferGetBaseAddress(*a1);
    if (*(_DWORD *)(a2 + 8) >= Width && *(_DWORD *)(a2 + 12) >= Height)
    {
      *(void *)a2 = 0;
      *(void *)(a2 + 8) = Width | ((unint64_t)Height << 32);
    }
    else
    {
      unint64_t v11 = *(void **)(a2 + 24);
      if (v11)
      {
        free(v11);
        *(void *)(a2 + 24) = 0;
      }
      *(void *)a2 = 0;
      *(void *)(a2 + 8) = Width | ((unint64_t)Height << 32);
      *(void *)(a2 + 16) = ((unint64_t)(((Width + 15) & 0xFFFFFFF0) >> 4) << 36) | 1;
      vImage_Buffer size = Height * (unint64_t)((Width + 15) & 0xFFFFFFF0);
      if (size) {
        int v12 = malloc_type_malloc(size, 0xA153FF5uLL);
      }
      else {
        int v12 = 0;
      }
      *(void *)(a2 + 24) = v12;
    }
    uint64_t v4 = 0;
    if (PixelFormatType <= 875704437)
    {
      if (PixelFormatType <= 846624120)
      {
        if (PixelFormatType == 24)
        {
          vImage_Buffer size = *(void *)(a2 + 24);
          unint64_t v37 = *(void *)(a2 + 8);
          v38.i64[0] = v37;
          v38.i64[1] = HIDWORD(v37);
          unsigned int v43 = vextq_s8(v38, v38, 8uLL);
          uint8x8_t v44 = *(unsigned int *)(a2 + 20);
          destPlanarBuffers = (vImage_Buffer *)&size;
          srcChannels[0] = BaseAddress + 1;
          int v18 = Width;
          uint64_t v19 = Height;
          unint64_t v20 = BytesPerRow;
          uint64_t v4 = 1;
          unint64_t v21 = 3;
          goto LABEL_51;
        }
        if (PixelFormatType == 32)
        {
          vImage_Buffer size = *(void *)(a2 + 24);
          size_t v13 = *(void *)(a2 + 8);
          v14.i64[0] = v13;
          v14.i64[1] = HIDWORD(v13);
          unsigned int v43 = vextq_s8(v14, v14, 8uLL);
          uint8x8_t v44 = *(unsigned int *)(a2 + 20);
          int v15 = BaseAddress + 2;
LABEL_27:
          srcChannels[0] = v15;
          destPlanarBuffers = (vImage_Buffer *)&size;
          int v18 = Width;
          uint64_t v19 = Height;
          unint64_t v20 = BytesPerRow;
          uint64_t v4 = 1;
          unint64_t v21 = 4;
LABEL_51:
          vImageConvert_ChunkyToPlanar8((const void **)srcChannels, (const vImage_Buffer **)&destPlanarBuffers, 1u, v21, v18, v19, v20, 0);
        }
LABEL_52:
        CVPixelBufferUnlockBaseAddress(*a1, 1uLL);
        return v4;
      }
      if (PixelFormatType == 846624121)
      {
        vImage_Buffer size = *(void *)(a2 + 24);
        uint64_t v39 = *(void *)(a2 + 8);
        v40.i64[0] = v39;
        v40.i64[1] = HIDWORD(v39);
        unsigned int v43 = vextq_s8(v40, v40, 8uLL);
        uint8x8_t v44 = *(unsigned int *)(a2 + 20);
        srcChannels[0] = BaseAddress + 1;
LABEL_50:
        destPlanarBuffers = (vImage_Buffer *)&size;
        int v18 = Width;
        uint64_t v19 = Height;
        unint64_t v20 = BytesPerRow;
        uint64_t v4 = 1;
        unint64_t v21 = 2;
        goto LABEL_51;
      }
      if (PixelFormatType != 875704422) {
        goto LABEL_52;
      }
    }
    else
    {
      if (PixelFormatType > 1278226487)
      {
        if (PixelFormatType != 2037741171 && PixelFormatType != 2037741158)
        {
          if (PixelFormatType == 1278226488) {
            cva::imageViewFromPixelBuffer<unsigned char>();
          }
          goto LABEL_52;
        }
        vImage_Buffer size = *(void *)(a2 + 24);
        int v35 = *(void *)(a2 + 8);
        v36.i64[0] = v35;
        v36.i64[1] = HIDWORD(v35);
        unsigned int v43 = vextq_s8(v36, v36, 8uLL);
        uint8x8_t v44 = *(unsigned int *)(a2 + 20);
        srcChannels[0] = BaseAddress;
        goto LABEL_50;
      }
      if (PixelFormatType != 875704438)
      {
        if (PixelFormatType == 1111970369)
        {
          vImage_Buffer size = *(void *)(a2 + 24);
          int8x16_t v16 = *(void *)(a2 + 8);
          v17.i64[0] = v16;
          v17.i64[1] = HIDWORD(v16);
          unsigned int v43 = vextq_s8(v17, v17, 8uLL);
          uint8x8_t v44 = *(unsigned int *)(a2 + 20);
          int v15 = BaseAddress + 1;
          goto LABEL_27;
        }
        goto LABEL_52;
      }
    }
    BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(*a1, 0);
    BaseAddressOfPlane = (char *)CVPixelBufferGetBaseAddressOfPlane(*a1, 0);
    if (BaseAddressOfPlane)
    {
      int v24 = BytesPerRowOfPlane * Height;
      if (v24)
      {
        int v25 = 0;
        int v26 = 0;
        uint64_t v27 = *(void *)(a2 + 16);
        float v28 = *(void *)(a2 + 24);
        float v29 = *(_DWORD *)(a2 + 8);
        int v30 = &BaseAddressOfPlane[v24];
        if (v28) {
          uint64_t v31 = (unsigned char *)(v28 + *(void *)a2);
        }
        else {
          uint64_t v31 = 0;
        }
        do
        {
          uint64_t v32 = *BaseAddressOfPlane++;
          *uint64_t v31 = v32;
          uint64_t v33 = (v26 + 1);
          if (v33 == Width) {
            int v26 = 0;
          }
          else {
            ++v26;
          }
          if (v33 == Width) {
            BaseAddressOfPlane = &BaseAddressOfPlane[BytesPerRowOfPlane - v33];
          }
          v31 += v27;
          uint64_t v34 = v25 + 1;
          if (v25 + 1 == v29) {
            int v25 = 0;
          }
          else {
            ++v25;
          }
          if (v34 == v29) {
            uint64_t v31 = &v31[HIDWORD(v27) - (v34 * v27)];
          }
        }
        while (BaseAddressOfPlane != v30);
      }
    }
    uint64_t v4 = 1;
    goto LABEL_52;
  }
  return 0;
}

void cva::utils::string::increase_text_identifier(uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0)
  {
    sub_2153C0AE4(__p, *(void **)a1, *(void *)(a1 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a1;
    __p[2] = *(void **)(a1 + 16);
  }
  MEMORY[0x2166B9800](&v2);
  uint64_t v3 = std::locale::use_facet(&v2, MEMORY[0x263F8C108]);
  char v1 = std::locale::use_facet(&v2, MEMORY[0x263F8C130]);
  long long v5 = 0u;
  long long v6 = 0u;
  uint64_t v4 = v1;
  uint64_t v7 = 0;
  sub_21540FF70();
}

void sub_21540FF70()
{
}

uint64_t sub_2154107DC()
{
  return sub_2154107F4();
}

void *sub_2154107F4(uint64_t a1, unint64_t a2, long long *a3)
{
  uint64_t v6 = *(void *)(a1 + 16);
  float result = *(void **)a1;
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - (uint64_t)result) >> 3) < a2)
  {
    if (result)
    {
      *(void *)(a1 + 8) = result;
      operator delete(result);
      uint64_t v6 = 0;
      *(void *)a1 = 0;
      *(void *)(a1 + 8) = 0;
      *(void *)(a1 + 16) = 0;
    }
    if (a2 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_26;
    }
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * (v6 >> 3);
    uint64_t v9 = 2 * v8;
    if (2 * v8 <= a2) {
      uint64_t v9 = a2;
    }
    unint64_t v10 = v8 >= 0x555555555555555 ? 0xAAAAAAAAAAAAAAALL : v9;
    if (v10 > 0xAAAAAAAAAAAAAAALL) {
LABEL_26:
    }
      abort();
    uint64_t v11 = 3 * v10;
    float result = operator new(24 * v10);
    *(void *)a1 = result;
    *(void *)(a1 + 8) = result;
    *(void *)(a1 + 16) = &result[v11];
    uint64_t v12 = 24 * a2;
    size_t v13 = &result[3 * a2];
    do
    {
      *(_OWORD *)float result = *a3;
      result[2] = *((void *)a3 + 2);
      result += 3;
      v12 -= 24;
    }
    while (v12);
    goto LABEL_25;
  }
  uint64_t v14 = *(void *)(a1 + 8);
  unint64_t v15 = (v14 - (uint64_t)result) / 24;
  if (v15 >= a2) {
    uint64_t v16 = a2;
  }
  else {
    uint64_t v16 = (v14 - (uint64_t)result) / 24;
  }
  if (v16)
  {
    uint64_t v17 = result;
    do
    {
      *(_OWORD *)uint64_t v17 = *a3;
      *((unsigned char *)v17 + 16) = *((unsigned char *)a3 + 16);
      v17 += 3;
      --v16;
    }
    while (v16);
  }
  if (a2 <= v15)
  {
    size_t v13 = &result[3 * a2];
LABEL_25:
    *(void *)(a1 + 8) = v13;
    return result;
  }
  uint64_t v18 = v14 + 24 * (a2 - v15);
  uint64_t v19 = 24 * a2 - 24 * v15;
  do
  {
    long long v20 = *a3;
    *(void *)(v14 + 16) = *((void *)a3 + 2);
    *(_OWORD *)uint64_t v14 = v20;
    v14 += 24;
    v19 -= 24;
  }
  while (v19);
  *(void *)(a1 + 8) = v18;
  return result;
}

uint64_t sub_215410EC0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, int a5, char a6)
{
  long long v173 = 0u;
  long long v174 = 0u;
  long long v172 = 0u;
  uint64_t v6 = *(void *)(a1 + 40);
  if (!v6) {
    goto LABEL_141;
  }
  uint64_t v164 = a3 - a2;
  memset(&v166[4], 0, 24);
  sub_215412BF8((uint64_t)&v172);
  unint64_t v11 = *(void *)(*((void *)&v172 + 1) + 8 * ((*((void *)&v174 + 1) + (void)v174) / 0x2AuLL))
      + 96 * ((*((void *)&v174 + 1) + (void)v174) % 0x2AuLL);
  *(_DWORD *)unint64_t v11 = 0;
  *(_OWORD *)(v11 + 4) = *(_OWORD *)v166;
  *(_OWORD *)(v11 + 16) = *(_OWORD *)&v166[12];
  *(_OWORD *)(v11 + 32) = 0u;
  *(_OWORD *)(v11 + 48) = 0u;
  *(_OWORD *)(v11 + 64) = 0u;
  *(_OWORD *)(v11 + 77) = 0u;
  uint64_t v12 = *((void *)&v174 + 1);
  uint64_t v13 = ++*((void *)&v174 + 1);
  uint64_t v14 = *((void *)&v172 + 1);
  unint64_t v15 = v174 + v12;
  unint64_t v16 = 8 * (v15 / 0x2A);
  uint64_t v17 = a2;
  unint64_t v18 = v15 % 0x2A;
  unint64_t v19 = 96 * (v15 % 0x2A);
  unint64_t v20 = *(void *)(*((void *)&v172 + 1) + v16) + v19;
  *(_DWORD *)unint64_t v20 = 0;
  *(void *)(v20 + 8) = v17;
  uint64_t v161 = v17;
  *(void *)(*(void *)(v14 + v16) + v19 + 16) = v17;
  *(void *)(*(void *)(v14 + v16) + v19 + 24) = a3;
  unint64_t v21 = *(void *)(v14 + v16) + v19;
  uint64_t v24 = *(void *)(v21 + 56);
  unint64_t v22 = v21 + 56;
  uint64_t v23 = v24;
  unint64_t v25 = *(unsigned int *)(a1 + 32);
  unint64_t v26 = (*(void *)(v22 + 8) - v24) >> 4;
  if (v25 <= v26)
  {
    if (v25 < v26) {
      *(void *)(v22 + 8) = v23 + 16 * v25;
    }
  }
  else
  {
    sub_215412AC0((char **)v22, v25 - v26);
  }
  char v163 = 0;
  unsigned int v27 = 0;
  uint64_t v162 = 0;
  *(void *)(*(void *)(v14 + v16) + 96 * v18 + 80) = v6;
  uint64_t v28 = *(void *)(v14 + v16) + 96 * v18;
  *(_DWORD *)(v28 + 88) = a5;
  *(unsigned char *)(v28 + 92) = a6;
  uint64_t v29 = v164;
  while (2)
  {
    if ((++v27 & 0xFFF) == 0 && (int)(v27 >> 12) >= (int)v29)
    {
      sub_2154107DC();
LABEL_156:
      abort();
    }
    unint64_t v31 = v13 + v174 - 1;
    uint64_t v32 = *(void *)(*((void *)&v172 + 1) + 8 * (v31 / 0x2A));
    unint64_t v33 = v31 % 0x2A;
    uint64_t v34 = v32 + 96 * (v31 % 0x2A);
    uint64_t v36 = (void *)(v34 + 80);
    uint64_t v35 = *(void *)(v34 + 80);
    if (v35) {
      (*(void (**)(uint64_t, unint64_t))(*(void *)v35 + 16))(v35, v32 + 96 * v33);
    }
    switch(*(_DWORD *)v34)
    {
      case 0xFFFFFC18:
        uint64_t v37 = *(void *)(v32 + 96 * v33 + 16);
        if ((a5 & 0x20) != 0 && v37 == v161)
        {
          unint64_t v38 = *((void *)&v174 + 1) + v174 - 1;
          uint64_t v39 = *(void *)(*((void *)&v172 + 1) + 8 * (v38 / 0x2A));
          unint64_t v40 = v38 % 0x2A;
          int v41 = *(void **)(v39 + 96 * (v38 % 0x2A) + 56);
          if (v41)
          {
            *(void *)(v39 + 96 * v40 + 64) = v41;
            operator delete(v41);
          }
          uint64_t v42 = *(void **)(v39 + 96 * v40 + 32);
          if (v42)
          {
            *(void *)(v39 + 96 * v40 + 40) = v42;
            operator delete(v42);
          }
          uint64_t v43 = v173;
          BOOL v44 = (void)v173 == *((void *)&v172 + 1);
          uint64_t v45 = 42 * ((uint64_t)(v173 - *((void *)&v172 + 1)) >> 3) - 1;
LABEL_110:
          long long v119 = v174;
          --*((void *)&v174 + 1);
          if (v44) {
            uint64_t v45 = 0;
          }
          if ((unint64_t)(v45 - (*((void *)&v119 + 1) + v119) + 1) >= 0x54)
          {
            operator delete(*(void **)(v43 - 8));
            *(void *)&long long v173 = v173 - 8;
          }
          goto LABEL_8;
        }
        uint64_t v74 = v37 - *(void *)(v32 + 96 * v33 + 8);
        uint64_t v75 = v162;
        if ((v163 & (v162 >= v74)) == 0) {
          uint64_t v75 = v74;
        }
        if (v75 == v29)
        {
          unsigned int v76 = (void **)*((void *)&v172 + 1);
          uint64_t v77 = v173;
          if ((void)v173 == *((void *)&v172 + 1))
          {
            uint64_t v77 = *((void *)&v172 + 1);
          }
          else
          {
            int v78 = (void *)(*((void *)&v172 + 1) + 8 * ((unint64_t)v174 / 0x2A));
            unsigned int v79 = (void *)(*v78 + 96 * ((unint64_t)v174 % 0x2A));
            unint64_t v80 = *(void *)(*((void *)&v172 + 1) + 8 * ((*((void *)&v174 + 1) + (void)v174) / 0x2AuLL))
                + 96 * ((*((void *)&v174 + 1) + (void)v174) % 0x2AuLL);
            if (v79 != (void *)v80)
            {
              do
              {
                unsigned int v81 = (void *)v79[7];
                if (v81)
                {
                  v79[8] = v81;
                  operator delete(v81);
                }
                int v82 = (void *)v79[4];
                if (v82)
                {
                  v79[5] = v82;
                  operator delete(v82);
                }
                v79 += 12;
                if ((void *)((char *)v79 - *v78) == (void *)4032)
                {
                  int v83 = (void *)v78[1];
                  ++v78;
                  unsigned int v79 = v83;
                }
              }
              while (v79 != (void *)v80);
              unsigned int v76 = (void **)*((void *)&v172 + 1);
              uint64_t v77 = v173;
            }
          }
          *((void *)&v174 + 1) = 0;
          unint64_t v93 = v77 - (void)v76;
          if (v93 >= 0x11)
          {
            do
            {
              operator delete(*v76);
              unsigned int v76 = (void **)(*((void *)&v172 + 1) + 8);
              *((void *)&v172 + 1) = v76;
              unint64_t v93 = v173 - (void)v76;
            }
            while ((void)v173 - (void)v76 > 0x10uLL);
          }
          if (v93 >> 3 == 1)
          {
            uint64_t v94 = 21;
LABEL_88:
            *(void *)&long long v174 = v94;
          }
          else if (v93 >> 3 == 2)
          {
            uint64_t v94 = 42;
            goto LABEL_88;
          }
          char v163 = 1;
          uint64_t v162 = v29;
          goto LABEL_8;
        }
        uint64_t v162 = v75;
        unint64_t v86 = *((void *)&v174 + 1) + v174 - 1;
        uint64_t v87 = *(void *)(*((void *)&v172 + 1) + 8 * (v86 / 0x2A));
        unint64_t v88 = v86 % 0x2A;
        int v89 = *(void **)(v87 + 96 * (v86 % 0x2A) + 56);
        if (v89)
        {
          *(void *)(v87 + 96 * v88 + 64) = v89;
          operator delete(v89);
        }
        uint64_t v90 = *(void **)(v87 + 96 * v88 + 32);
        if (v90)
        {
          *(void *)(v87 + 96 * v88 + 40) = v90;
          operator delete(v90);
        }
        uint64_t v91 = 42 * ((uint64_t)(v173 - *((void *)&v172 + 1)) >> 3) - 1;
        long long v92 = v174;
        --*((void *)&v174 + 1);
        if ((void)v173 == *((void *)&v172 + 1)) {
          uint64_t v91 = 0;
        }
        if ((unint64_t)(v91 - (*((void *)&v92 + 1) + v92) + 1) >= 0x54)
        {
          operator delete(*(void **)(v173 - 8));
          *(void *)&long long v173 = v173 - 8;
        }
        char v163 = 1;
LABEL_8:
        uint64_t v13 = *((void *)&v174 + 1);
        if (*((void *)&v174 + 1)) {
          continue;
        }
        if (v163)
        {
          uint64_t v149 = *a4;
          *(void *)uint64_t v149 = v161;
          *(void *)(v149 + 8) = v161 + v162;
          uint64_t v150 = 1;
          *(unsigned char *)(v149 + 16) = 1;
          goto LABEL_142;
        }
LABEL_141:
        uint64_t v150 = 0;
LABEL_142:
        v151 = (void **)*((void *)&v172 + 1);
        v152 = (void **)v173;
        *((void *)&v174 + 1) = 0;
        unint64_t v153 = v173 - *((void *)&v172 + 1);
        if ((void)v173 - *((void *)&v172 + 1) >= 0x11uLL)
        {
          do
          {
            operator delete(*v151);
            v152 = (void **)v173;
            v151 = (void **)(*((void *)&v172 + 1) + 8);
            *((void *)&v172 + 1) = v151;
            unint64_t v153 = v173 - (void)v151;
          }
          while ((void)v173 - (void)v151 > 0x10uLL);
        }
        unint64_t v154 = v153 >> 3;
        if (v154 == 1)
        {
          uint64_t v155 = 21;
          goto LABEL_148;
        }
        if (v154 == 2)
        {
          uint64_t v155 = 42;
LABEL_148:
          *(void *)&long long v174 = v155;
        }
        if (v151 != v152)
        {
          do
          {
            v156 = *v151++;
            operator delete(v156);
          }
          while (v151 != v152);
          if ((void)v173 != *((void *)&v172 + 1)) {
            *(void *)&long long v173 = v173 + ((*((void *)&v172 + 1) - v173 + 7) & 0xFFFFFFFFFFFFFFF8);
          }
        }
        if ((void)v172) {
          operator delete((void *)v172);
        }
        return v150;
      case 0xFFFFFC19:
      case 0xFFFFFC1E:
      case 0xFFFFFC21:
        goto LABEL_8;
      case 0xFFFFFC1D:
        unint64_t v46 = v174;
        float v47 = (uint64_t *)*((void *)&v172 + 1);
        float v48 = (uint64_t *)v173;
        if ((void)v174) {
          goto LABEL_101;
        }
        unint64_t v84 = (uint64_t)(v173 - *((void *)&v172 + 1)) >> 3;
        uint64_t v85 = 42 * v84 - 1;
        if ((void)v173 == *((void *)&v172 + 1)) {
          uint64_t v85 = 0;
        }
        if ((unint64_t)(v85 - *((void *)&v174 + 1)) >= 0x2A)
        {
          *(void *)&long long v174 = 42;
          *(void *)v166 = *(void *)(v173 - 8);
          *(void *)&long long v173 = v173 - 8;
          sub_215413134((void **)&v172, v166);
          goto LABEL_100;
        }
        if (v84 < (uint64_t)(*((void *)&v173 + 1) - v172) >> 3)
        {
          if (*((void *)&v172 + 1) == (void)v172)
          {
            *(void *)v166 = operator new(0xFC0uLL);
            sub_2154132DC((char **)&v172, v166);
            *(void *)v166 = *(void *)(v173 - 8);
            *(void *)&long long v173 = v173 - 8;
          }
          else
          {
            *(void *)v166 = operator new(0xFC0uLL);
          }
          sub_215413134((void **)&v172, v166);
          uint64_t v100 = 21;
          if ((void)v173 - *((void *)&v172 + 1) != 8) {
            uint64_t v100 = v174 + 42;
          }
          *(void *)&long long v174 = v100;
          goto LABEL_100;
        }
        if (*((void *)&v173 + 1) == (void)v172) {
          unint64_t v95 = 1;
        }
        else {
          unint64_t v95 = (uint64_t)(*((void *)&v173 + 1) - v172) >> 2;
        }
        if (v95 >> 61) {
LABEL_158:
        }
          sub_2153E6200();
        std::string::size_type v96 = (char *)operator new(8 * v95);
        std::string::size_type v97 = operator new(0xFC0uLL);
        if (v95)
        {
          uint64_t v98 = &v96[8 * v95];
          uint64_t v99 = v96;
        }
        else
        {
          uint64_t v101 = v97;
          uint64_t v102 = (char *)operator new(8uLL);
          uint64_t v98 = v102 + 8;
          operator delete(v96);
          std::string::size_type v97 = v101;
          float v47 = (uint64_t *)*((void *)&v172 + 1);
          float v48 = (uint64_t *)v173;
          uint64_t v99 = v102;
        }
        *(void *)uint64_t v99 = v97;
        uint64_t v103 = v99 + 8;
        int v104 = v99;
        if (v47 == v48)
        {
LABEL_96:
          std::string v105 = (void *)v172;
          *(void *)&long long v172 = v99;
          *((void *)&v172 + 1) = v104;
          *(void *)&long long v173 = v103;
          *((void *)&v173 + 1) = v98;
          uint64_t v106 = v174 + 42;
          if (v103 - v104 == 8) {
            uint64_t v106 = 21;
          }
          *(void *)&long long v174 = v106;
          uint64_t v29 = v164;
          if (v105) {
            operator delete(v105);
          }
LABEL_100:
          unint64_t v46 = v174;
          float v47 = (uint64_t *)*((void *)&v172 + 1);
          float v48 = (uint64_t *)v173;
LABEL_101:
          v107 = &v47[v46 / 0x2A];
          uint64_t v108 = *v107 + 96 * (v46 % 0x2A);
          if (v48 == v47) {
            uint64_t v108 = 0;
          }
          if (v108 == *v107) {
            uint64_t v108 = *(v107 - 1) + 4032;
          }
          long long v109 = *(_OWORD *)(v34 + 16);
          *(_OWORD *)(v108 - 96) = *(_OWORD *)v34;
          *(_OWORD *)(v108 - 80) = v109;
          uint64_t v110 = v32 + 96 * v33;
          *(void *)(v108 - 56) = 0;
          *(void *)(v108 - 48) = 0;
          *(void *)(v108 - 64) = 0;
          *(_OWORD *)(v108 - 64) = *(_OWORD *)(v110 + 32);
          *(void *)(v108 - 48) = *(void *)(v110 + 48);
          *(void *)(v110 + 32) = 0;
          *(void *)(v110 + 40) = 0;
          *(void *)(v110 + 48) = 0;
          *(void *)(v108 - 40) = 0;
          *(void *)(v108 - 32) = 0;
          *(void *)(v108 - 24) = 0;
          *(_OWORD *)(v108 - 40) = *(_OWORD *)(v110 + 56);
          *(void *)(v108 - 24) = *(void *)(v110 + 72);
          *(void *)(v110 + 56) = 0;
          *(void *)(v110 + 64) = 0;
          *(void *)(v110 + 72) = 0;
          uint64_t v111 = *v36;
          *(void *)(v108 - 11) = *(void *)(v34 + 85);
          *(void *)(v108 - 16) = v111;
          uint64_t v112 = *((void *)&v174 + 1);
          *(void *)&long long v174 = v174 - 1;
          ++*((void *)&v174 + 1);
          uint64_t v113 = v112 + v174;
          unint64_t v114 = (v112 + (uint64_t)v174) / 0x2AuLL;
          uint64_t v115 = *(void *)(*((void *)&v172 + 1) + 8 * v114);
          uint64_t v116 = v113 - 42 * v114;
          v117 = *(void **)(v115 + 96 * v116 + 56);
          if (v117)
          {
            *(void *)(v115 + 96 * v116 + 64) = v117;
            operator delete(v117);
          }
          v118 = *(void **)(v115 + 96 * v116 + 32);
          if (v118)
          {
            *(void *)(v115 + 96 * v116 + 40) = v118;
            operator delete(v118);
          }
          uint64_t v43 = v173;
          BOOL v44 = (void)v173 == *((void *)&v172 + 1);
          uint64_t v45 = 42 * ((uint64_t)(v173 - *((void *)&v172 + 1)) >> 3) - 1;
          goto LABEL_110;
        }
        break;
      case 0xFFFFFC1F:
        unint64_t v49 = *((void *)&v174 + 1) + v174 - 1;
        uint64_t v50 = *(void *)(*((void *)&v172 + 1) + 8 * (v49 / 0x2A));
        unint64_t v51 = v49 % 0x2A;
        float v52 = *(void **)(v50 + 96 * (v49 % 0x2A) + 56);
        if (v52)
        {
          *(void *)(v50 + 96 * v51 + 64) = v52;
          operator delete(v52);
        }
        float v53 = *(void **)(v50 + 96 * v51 + 32);
        if (v53)
        {
          *(void *)(v50 + 96 * v51 + 40) = v53;
          operator delete(v53);
        }
        uint64_t v43 = v173;
        BOOL v44 = (void)v173 == *((void *)&v172 + 1);
        uint64_t v45 = 42 * ((uint64_t)(v173 - *((void *)&v172 + 1)) >> 3) - 1;
        goto LABEL_110;
      case 0xFFFFFC20:
        long long v54 = *(_OWORD *)(v34 + 16);
        *(_OWORD *)v166 = *(_OWORD *)v34;
        *(_OWORD *)&v166[16] = v54;
        uint64_t v55 = v32 + 96 * v33;
        v167[1] = 0;
        v168 = 0;
        v167[0] = 0;
        float v57 = *(unsigned char **)(v55 + 32);
        float v56 = *(unsigned char **)(v55 + 40);
        int64_t v58 = v56 - v57;
        if (v56 == v57) {
          goto LABEL_34;
        }
        if (0xAAAAAAAAAAAAAAABLL * (v58 >> 3) >= 0xAAAAAAAAAAAAAABLL) {
          goto LABEL_156;
        }
        unsigned int v59 = (char *)operator new(v58);
        v167[0] = v59;
        v167[1] = v59;
        v168 = &v59[8 * (v58 >> 3)];
        size_t v60 = 24 * ((v58 - 24) / 0x18uLL) + 24;
        memcpy(v59, v57, v60);
        v167[1] = &v59[v60];
LABEL_34:
        uint64_t v61 = v32 + 96 * v33;
        __p[0] = 0;
        __p[1] = 0;
        v170 = 0;
        int v63 = *(unsigned char **)(v61 + 56);
        int v62 = *(unsigned char **)(v61 + 64);
        uint64_t v64 = v62 - v63;
        if (v62 == v63) {
          goto LABEL_37;
        }
        if (v64 < 0) {
          goto LABEL_156;
        }
        unsigned int v65 = (char *)operator new(v62 - v63);
        __p[0] = v65;
        __p[1] = v65;
        v170 = &v65[16 * (v64 >> 4)];
        size_t v66 = v64 & 0xFFFFFFFFFFFFFFF0;
        memcpy(v65, v63, v66);
        __p[1] = &v65[v66];
LABEL_37:
        uint64_t v67 = *v36;
        *(void *)((char *)v171 + 5) = *(void *)(v34 + 85);
        v171[0] = v67;
        (*(void (**)(void, uint64_t, uint64_t))(*(void *)*v36 + 24))(*v36, 1, v34);
        (*(void (**)(void, void, unsigned char *))(*(void *)v171[0] + 24))(v171[0], 0, v166);
        uint64_t v68 = *((void *)&v172 + 1);
        if ((void)v173 == *((void *)&v172 + 1)) {
          uint64_t v69 = 0;
        }
        else {
          uint64_t v69 = 42 * ((uint64_t)(v173 - *((void *)&v172 + 1)) >> 3) - 1;
        }
        unint64_t v70 = *((void *)&v174 + 1) + v174;
        if (v69 == *((void *)&v174 + 1) + (void)v174)
        {
          sub_215412BF8((uint64_t)&v172);
          uint64_t v68 = *((void *)&v172 + 1);
          unint64_t v70 = *((void *)&v174 + 1) + v174;
        }
        unint64_t v71 = *(void *)(v68 + 8 * (v70 / 0x2A)) + 96 * (v70 % 0x2A);
        long long v72 = *(_OWORD *)&v166[16];
        *(_OWORD *)unint64_t v71 = *(_OWORD *)v166;
        *(_OWORD *)(v71 + 16) = v72;
        *(void *)(v71 + 40) = 0;
        *(void *)(v71 + 48) = 0;
        *(void *)(v71 + 32) = 0;
        *(_OWORD *)(v71 + 32) = *(_OWORD *)v167;
        *(void *)(v71 + 48) = v168;
        v167[0] = 0;
        v167[1] = 0;
        v168 = 0;
        *(void *)(v71 + 56) = 0;
        *(void *)(v71 + 64) = 0;
        *(void *)(v71 + 72) = 0;
        *(_OWORD *)(v71 + 56) = *(_OWORD *)__p;
        *(void *)(v71 + 72) = v170;
        __p[0] = 0;
        __p[1] = 0;
        v170 = 0;
        uint64_t v73 = v171[0];
        *(void *)(v71 + 85) = *(void *)((char *)v171 + 5);
        *(void *)(v71 + 80) = v73;
        ++*((void *)&v174 + 1);
        uint64_t v29 = v164;
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
        if (v167[0])
        {
          v167[1] = v167[0];
          operator delete(v167[0]);
        }
        goto LABEL_8;
      default:
        sub_2154107DC();
        goto LABEL_158;
    }
    break;
  }
  while (1)
  {
    if (v103 == v98)
    {
      if (v104 <= v99)
      {
        unint64_t v130 = (v103 - v99) >> 2;
        if (v103 == v99) {
          unint64_t v130 = 1;
        }
        if (v130 >> 61) {
          goto LABEL_158;
        }
        v131 = v99;
        unint64_t v132 = v130 >> 2;
        uint64_t v160 = 8 * v130;
        v133 = (char *)operator new(8 * v130);
        unint64_t v134 = v132;
        uint64_t v99 = v133;
        long long v120 = &v133[8 * v132];
        uint64_t v121 = v120;
        int64_t v135 = v103 - v104;
        if (v103 != v104)
        {
          uint64_t v121 = &v120[v135 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v136 = v135 - 8;
          if (v136 >= 0x38)
          {
            uint64_t v138 = 8 * v134;
            if ((unint64_t)(&v133[8 * v134] - v104) < 0x20)
            {
              v137 = v120;
              goto LABEL_136;
            }
            uint64_t v139 = (v136 >> 3) + 1;
            uint64_t v140 = 8 * (v139 & 0x3FFFFFFFFFFFFFFCLL);
            v137 = &v120[v140];
            v141 = (long long *)(v104 + 16);
            v142 = &v133[v138 + 16];
            uint64_t v143 = v139 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v144 = *v141;
              *((_OWORD *)v142 - 1) = *(v141 - 1);
              *(_OWORD *)v142 = v144;
              v141 += 2;
              v142 += 32;
              v143 -= 4;
            }
            while (v143);
            if (v139 != (v139 & 0x3FFFFFFFFFFFFFFCLL))
            {
              v104 += v140;
              goto LABEL_136;
            }
          }
          else
          {
            v137 = v120;
            do
            {
LABEL_136:
              uint64_t v145 = *(void *)v104;
              v104 += 8;
              *(void *)v137 = v145;
              v137 += 8;
            }
            while (v137 != v121);
          }
        }
        uint64_t v103 = &v133[v160];
        if (v131)
        {
          v146 = v131;
          v147 = v120;
          v148 = v99;
          operator delete(v146);
          long long v120 = v147;
          uint64_t v99 = v148;
        }
        goto LABEL_115;
      }
      uint64_t v123 = (v104 - v99) >> 3;
      if (v123 >= -1) {
        uint64_t v124 = v123 + 1;
      }
      else {
        uint64_t v124 = v123 + 2;
      }
      uint64_t v125 = v124 >> 1;
      v126 = &v104[-8 * (v124 >> 1)];
      v127 = v103;
      int64_t v128 = v103 - v104;
      if (v103 != v104)
      {
        v159 = v99;
        memmove(v126, v104, v103 - v104);
        int64_t v128 = v103 - v104;
        uint64_t v99 = v159;
        v127 = v104;
      }
      uint64_t v129 = -v125;
      uint64_t v121 = &v126[v128];
      long long v120 = &v127[8 * v129];
    }
    else
    {
      long long v120 = v104;
      uint64_t v121 = v103;
      uint64_t v103 = v98;
    }
LABEL_115:
    uint64_t v122 = *v47++;
    *(void *)uint64_t v121 = v122;
    int v104 = v120;
    uint64_t v98 = v103;
    uint64_t v103 = v121 + 8;
    if (v47 == (uint64_t *)v173) {
      goto LABEL_96;
    }
  }
}

char *sub_215412740(void **a1, uint64_t a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a1[1] - (unsigned char *)*a1) >> 5);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0x2AAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 5) > v3) {
    unint64_t v3 = 0x5555555555555556 * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 5);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 5) >= 0x155555555555555) {
    unint64_t v6 = 0x2AAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v6 = v3;
  }
  if (v6)
  {
    if (v6 > 0x2AAAAAAAAAAAAAALL) {
      sub_2153E6200();
    }
    uint64_t v7 = (char *)operator new(96 * v6);
  }
  else
  {
    uint64_t v7 = 0;
  }
  long long v8 = *(_OWORD *)(a2 + 16);
  uint64_t v9 = &v7[96 * v2];
  *(_OWORD *)uint64_t v9 = *(_OWORD *)a2;
  *((_OWORD *)v9 + 1) = v8;
  unint64_t v10 = &v7[96 * v6];
  *((_OWORD *)v9 + 2) = *(_OWORD *)(a2 + 32);
  *((void *)v9 + 6) = *(void *)(a2 + 48);
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  *(void *)(v9 + 85) = *(void *)(a2 + 85);
  uint64_t v11 = *(void *)(a2 + 72);
  uint64_t v12 = *(void *)(a2 + 80);
  *((void *)v9 + 9) = 0;
  *((void *)v9 + 10) = v12;
  *(_OWORD *)(v9 + 56) = *(_OWORD *)(a2 + 56);
  *((void *)v9 + 9) = v11;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  uint64_t v13 = v9 + 96;
  uint64_t v14 = (char *)*a1;
  unint64_t v15 = (char *)a1[1];
  if (v15 == *a1)
  {
    *a1 = v9;
    a1[1] = v13;
    a1[2] = v10;
  }
  else
  {
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = &v9[v16];
      unint64_t v18 = &v15[v16];
      long long v19 = *(_OWORD *)&v15[v16 - 80];
      *((_OWORD *)v17 - 6) = *(_OWORD *)&v15[v16 - 96];
      *((_OWORD *)v17 - 5) = v19;
      *((void *)v17 - 7) = 0;
      *((void *)v17 - 6) = 0;
      *((_OWORD *)v17 - 4) = *(_OWORD *)&v15[v16 - 64];
      *((void *)v17 - 6) = *(void *)&v15[v16 - 48];
      *((void *)v18 - 8) = 0;
      *((void *)v18 - 7) = 0;
      *((void *)v18 - 6) = 0;
      *((void *)v17 - 4) = 0;
      *((void *)v17 - 3) = 0;
      *(_OWORD *)(v17 - 40) = *(_OWORD *)&v15[v16 - 40];
      *((void *)v17 - 3) = *(void *)&v15[v16 - 24];
      *((void *)v18 - 5) = 0;
      *((void *)v18 - 4) = 0;
      *((void *)v18 - 3) = 0;
      uint64_t v20 = *(void *)&v15[v16 - 16];
      *(void *)(v17 - 11) = *(void *)&v15[v16 - 11];
      *((void *)v17 - 2) = v20;
      v16 -= 96;
    }
    while (&v15[v16] != v14);
    unint64_t v15 = (char *)*a1;
    unint64_t v21 = (char *)a1[1];
    *a1 = &v9[v16];
    a1[1] = v13;
    a1[2] = v10;
    while (v21 != v15)
    {
      unint64_t v22 = (void *)*((void *)v21 - 5);
      if (v22)
      {
        *((void *)v21 - 4) = v22;
        operator delete(v22);
      }
      uint64_t v23 = (void *)*((void *)v21 - 8);
      if (v23)
      {
        *((void *)v21 - 7) = v23;
        operator delete(v23);
      }
      v21 -= 96;
    }
  }
  if (v15) {
    operator delete(v15);
  }
  return v13;
}

void sub_215412910(void **a1, unint64_t a2, long long *a3)
{
  uint64_t v7 = (char *)a1[1];
  unint64_t v6 = a1[2];
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      uint64_t v13 = &v7[24 * a2];
      uint64_t v14 = 24 * a2;
      do
      {
        long long v15 = *a3;
        *((void *)v7 + 2) = *((void *)a3 + 2);
        *(_OWORD *)uint64_t v7 = v15;
        v7 += 24;
        v14 -= 24;
      }
      while (v14);
      uint64_t v7 = v13;
    }
    a1[1] = v7;
  }
  else
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - (unsigned char *)*a1) >> 3);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((v6 - (unsigned char *)*a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x555555555555555) {
      unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v9;
    }
    if (v11)
    {
      if (v11 > 0xAAAAAAAAAAAAAAALL) {
        sub_2153E6200();
      }
      uint64_t v12 = (char *)operator new(24 * v11);
    }
    else
    {
      uint64_t v12 = 0;
    }
    uint64_t v16 = &v12[24 * v8];
    uint64_t v17 = 24 * a2;
    unint64_t v18 = &v16[24 * a2];
    long long v19 = v16;
    do
    {
      long long v20 = *a3;
      *((void *)v19 + 2) = *((void *)a3 + 2);
      *(_OWORD *)long long v19 = v20;
      v19 += 24;
      v17 -= 24;
    }
    while (v17);
    unint64_t v21 = (char *)*a1;
    if (v7 != *a1)
    {
      do
      {
        long long v22 = *(_OWORD *)(v7 - 24);
        *((void *)v16 - 1) = *((void *)v7 - 1);
        *(_OWORD *)(v16 - 24) = v22;
        v16 -= 24;
        v7 -= 24;
      }
      while (v7 != v21);
      uint64_t v7 = (char *)*a1;
    }
    *a1 = v16;
    a1[1] = v18;
    a1[2] = &v12[24 * v11];
    if (v7)
    {
      operator delete(v7);
    }
  }
}

void sub_215412AC0(char **a1, unint64_t a2)
{
  long long v5 = a1[1];
  uint64_t v4 = a1[2];
  if (a2 <= (v4 - v5) >> 4)
  {
    if (a2)
    {
      uint64_t v12 = 16 * a2;
      bzero(a1[1], 16 * a2);
      v5 += v12;
    }
    a1[1] = v5;
  }
  else
  {
    unint64_t v6 = *a1;
    uint64_t v7 = (v5 - *a1) >> 4;
    unint64_t v8 = v7 + a2;
    if ((v7 + a2) >> 60) {
      abort();
    }
    uint64_t v9 = v4 - v6;
    if (v9 >> 3 > v8) {
      unint64_t v8 = v9 >> 3;
    }
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v10 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 >> 60) {
        sub_2153E6200();
      }
      unint64_t v11 = (char *)operator new(16 * v10);
    }
    else
    {
      unint64_t v11 = 0;
    }
    uint64_t v13 = &v11[16 * v7];
    size_t v14 = 16 * a2;
    long long v15 = &v11[16 * v10];
    bzero(v13, v14);
    uint64_t v16 = &v13[v14];
    if (v5 != v6)
    {
      do
      {
        *((_OWORD *)v13 - 1) = *((_OWORD *)v5 - 1);
        v13 -= 16;
        v5 -= 16;
      }
      while (v5 != v6);
      long long v5 = *a1;
    }
    *a1 = v13;
    a1[1] = v16;
    a1[2] = v15;
    if (v5)
    {
      operator delete(v5);
    }
  }
}

void sub_215412BF8(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = v2 >= 0x2A;
  unint64_t v4 = v2 - 42;
  if (v3)
  {
    *(void *)(a1 + 32) = v4;
    unint64_t v6 = *(void **)(a1 + 8);
    long long v5 = *(char **)(a1 + 16);
    uint64_t v7 = (char *)(v6 + 1);
    uint64_t v8 = *v6;
    *(void *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_77:
      *(void *)long long v5 = v8;
      *(void *)(a1 + 16) += 8;
      return;
    }
    uint64_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v30 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v30 = 1;
      }
      if (!(v30 >> 61))
      {
        unint64_t v31 = v30 >> 2;
        uint64_t v32 = 8 * v30;
        unint64_t v33 = (char *)operator new(8 * v30);
        uint64_t v34 = &v33[8 * v31];
        uint64_t v35 = &v33[v32];
        int64_t v37 = v5 - v7;
        BOOL v36 = v5 == v7;
        long long v5 = v34;
        if (!v36)
        {
          long long v5 = &v34[v37 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v38 = v37 - 8;
          if ((unint64_t)(v37 - 8) >= 0x38)
          {
            long long v72 = &v33[8 * v31];
            uint64_t v39 = v72;
            if ((unint64_t)(v72 - v7) >= 0x20)
            {
              uint64_t v73 = (v38 >> 3) + 1;
              uint64_t v74 = 8 * (v73 & 0x3FFFFFFFFFFFFFFCLL);
              uint64_t v39 = &v34[v74];
              uint64_t v75 = (long long *)(v6 + 3);
              unsigned int v76 = v72 + 16;
              uint64_t v77 = v73 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v78 = *v75;
                *(v76 - 1) = *(v75 - 1);
                *unsigned int v76 = v78;
                v75 += 2;
                v76 += 2;
                v77 -= 4;
              }
              while (v77);
              if (v73 == (v73 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_75;
              }
              v7 += v74;
            }
          }
          else
          {
            uint64_t v39 = &v33[8 * v31];
          }
          do
          {
            uint64_t v79 = *(void *)v7;
            v7 += 8;
            *(void *)uint64_t v39 = v79;
            v39 += 8;
          }
          while (v39 != v5);
        }
        goto LABEL_75;
      }
LABEL_86:
      sub_2153E6200();
    }
LABEL_5:
    uint64_t v11 = v10 >> 3;
    if (v11 >= -1) {
      uint64_t v12 = v11 + 1;
    }
    else {
      uint64_t v12 = v11 + 2;
    }
    uint64_t v13 = v12 >> 1;
    uint64_t v14 = -v13;
    long long v15 = &v7[-8 * v13];
    int64_t v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      uint64_t v7 = *(char **)(a1 + 8);
    }
    long long v5 = &v15[v16];
    *(void *)(a1 + 8) = &v7[8 * v14];
    *(void *)(a1 + 16) = &v15[v16];
    goto LABEL_77;
  }
  uint64_t v18 = *(void *)(a1 + 16);
  uint64_t v17 = *(void *)(a1 + 24);
  uint64_t v19 = *(void *)(a1 + 8);
  uint64_t v20 = v18 - v19;
  uint64_t v21 = (v18 - v19) >> 3;
  uint64_t v22 = v17 - *(void *)a1;
  if (v21 < (unint64_t)(v22 >> 3))
  {
    if (v17 != v18)
    {
      unint64_t v88 = operator new(0xFC0uLL);
      sub_2154132DC((char **)a1, &v88);
      return;
    }
    unint64_t v88 = operator new(0xFC0uLL);
    sub_215413134((void **)a1, &v88);
    unint64_t v40 = *(void **)(a1 + 8);
    long long v5 = *(char **)(a1 + 16);
    uint64_t v7 = (char *)(v40 + 1);
    uint64_t v8 = *v40;
    *(void *)(a1 + 8) = v40 + 1;
    if (v5 != *(char **)(a1 + 24)) {
      goto LABEL_77;
    }
    uint64_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v41 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v41 = 1;
      }
      if (!(v41 >> 61))
      {
        unint64_t v42 = v41 >> 2;
        uint64_t v43 = 8 * v41;
        unint64_t v33 = (char *)operator new(8 * v41);
        uint64_t v34 = &v33[8 * v42];
        uint64_t v35 = &v33[v43];
        int64_t v44 = v5 - v7;
        BOOL v36 = v5 == v7;
        long long v5 = v34;
        if (!v36)
        {
          long long v5 = &v34[v44 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v45 = v44 - 8;
          if ((unint64_t)(v44 - 8) >= 0x38)
          {
            unint64_t v80 = &v33[8 * v42];
            unint64_t v46 = v80;
            if ((unint64_t)(v80 - v7) >= 0x20)
            {
              uint64_t v81 = (v45 >> 3) + 1;
              uint64_t v82 = 8 * (v81 & 0x3FFFFFFFFFFFFFFCLL);
              unint64_t v46 = &v34[v82];
              int v83 = (long long *)(v40 + 3);
              unint64_t v84 = v80 + 16;
              uint64_t v85 = v81 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v86 = *v83;
                *(v84 - 1) = *(v83 - 1);
                *unint64_t v84 = v86;
                v83 += 2;
                v84 += 2;
                v85 -= 4;
              }
              while (v85);
              if (v81 == (v81 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_75;
              }
              v7 += v82;
            }
          }
          else
          {
            unint64_t v46 = &v33[8 * v42];
          }
          do
          {
            uint64_t v87 = *(void *)v7;
            v7 += 8;
            *(void *)unint64_t v46 = v87;
            v46 += 8;
          }
          while (v46 != v5);
        }
LABEL_75:
        *(void *)a1 = v33;
        *(void *)(a1 + 8) = v34;
        *(void *)(a1 + 16) = v5;
        *(void *)(a1 + 24) = v35;
        if (v9)
        {
          operator delete(v9);
          long long v5 = *(char **)(a1 + 16);
        }
        goto LABEL_77;
      }
      goto LABEL_86;
    }
    goto LABEL_5;
  }
  uint64_t v23 = v22 >> 2;
  if (v17 == *(void *)a1) {
    unint64_t v24 = 1;
  }
  else {
    unint64_t v24 = v23;
  }
  if (v24 >> 61) {
    goto LABEL_86;
  }
  unint64_t v25 = (char *)operator new(8 * v24);
  unint64_t v26 = &v25[8 * v21];
  unsigned int v27 = &v25[8 * v24];
  uint64_t v28 = operator new(0xFC0uLL);
  if (v21 == v24)
  {
    if (v20 < 1)
    {
      unint64_t v47 = v20 >> 2;
      if (v18 == v19) {
        unint64_t v47 = 1;
      }
      if (v47 >> 61) {
        goto LABEL_86;
      }
      uint64_t v48 = 8 * v47;
      unint64_t v26 = (char *)operator new(8 * v47);
      unsigned int v27 = &v26[v48];
      operator delete(v25);
      uint64_t v19 = *(void *)(a1 + 8);
      uint64_t v18 = *(void *)(a1 + 16);
      unint64_t v25 = v26;
    }
    else
    {
      unint64_t v29 = v21 + 2;
      if (v21 >= -1) {
        unint64_t v29 = v21 + 1;
      }
      v26 -= 8 * (v29 >> 1);
    }
  }
  *(void *)unint64_t v26 = v28;
  unint64_t v49 = v26 + 8;
  if (v18 != v19)
  {
    while (v26 != v25)
    {
      float v53 = v26;
      unint64_t v51 = v49;
LABEL_48:
      uint64_t v54 = *(void *)(v18 - 8);
      v18 -= 8;
      *((void *)v53 - 1) = v54;
      uint64_t v50 = v53 - 8;
      unint64_t v49 = v51;
      unint64_t v26 = v50;
      if (v18 == *(void *)(a1 + 8)) {
        goto LABEL_43;
      }
    }
    if (v49 < v27)
    {
      uint64_t v55 = (v27 - v49) >> 3;
      if (v55 >= -1) {
        unint64_t v56 = v55 + 1;
      }
      else {
        unint64_t v56 = v55 + 2;
      }
      unint64_t v51 = &v49[8 * (v56 >> 1)];
      float v53 = &v26[8 * (v56 >> 1)];
      if (v49 == v26)
      {
        unint64_t v25 = v49;
      }
      else
      {
        memmove(&v26[8 * (v56 >> 1)], v26, v49 - v26);
        unint64_t v25 = v26;
      }
      goto LABEL_48;
    }
    unint64_t v57 = (v27 - v26) >> 2;
    if (v27 == v26) {
      unint64_t v57 = 1;
    }
    if (v57 >> 61) {
      goto LABEL_86;
    }
    unint64_t v58 = (v57 + 3) >> 2;
    uint64_t v59 = 8 * v57;
    size_t v60 = (char *)operator new(8 * v57);
    unint64_t v25 = v60;
    float v53 = &v60[8 * v58];
    unint64_t v51 = v53;
    int64_t v61 = v49 - v26;
    if (v49 != v26)
    {
      unint64_t v51 = &v53[v61 & 0xFFFFFFFFFFFFFFF8];
      unint64_t v62 = v61 - 8;
      int v63 = &v60[8 * v58];
      uint64_t v64 = v26;
      if (v62 >= 0x38)
      {
        int v63 = &v60[8 * v58];
        uint64_t v64 = v26;
        if ((unint64_t)(v63 - v26) >= 0x20)
        {
          uint64_t v65 = (v62 >> 3) + 1;
          uint64_t v66 = 8 * (v65 & 0x3FFFFFFFFFFFFFFCLL);
          int v63 = &v53[v66];
          uint64_t v67 = (long long *)(v26 + 16);
          uint64_t v68 = &v60[8 * v58 + 16];
          uint64_t v69 = v65 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v70 = *v67;
            *((_OWORD *)v68 - 1) = *(v67 - 1);
            *(_OWORD *)uint64_t v68 = v70;
            v67 += 2;
            v68 += 32;
            v69 -= 4;
          }
          while (v69);
          if (v65 == (v65 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_67;
          }
          uint64_t v64 = &v26[v66];
        }
      }
      do
      {
        uint64_t v71 = *(void *)v64;
        v64 += 8;
        *(void *)int v63 = v71;
        v63 += 8;
      }
      while (v63 != v51);
    }
LABEL_67:
    unsigned int v27 = &v60[v59];
    operator delete(v26);
    goto LABEL_48;
  }
  uint64_t v50 = v26;
  unint64_t v51 = v26 + 8;
LABEL_43:
  float v52 = *(char **)a1;
  *(void *)a1 = v25;
  *(void *)(a1 + 8) = v50;
  *(void *)(a1 + 16) = v51;
  *(void *)(a1 + 24) = v27;
  if (v52)
  {
    operator delete(v52);
  }
}

void sub_215413134(void **a1, void *a2)
{
  unint64_t v4 = (char *)a1[1];
  if (v4 != *a1)
  {
    long long v5 = (char *)a1[1];
    goto LABEL_25;
  }
  uint64_t v7 = a1[2];
  unint64_t v6 = a1[3];
  if (v7 >= v6)
  {
    uint64_t v13 = v6 - v4;
    BOOL v12 = v13 == 0;
    unint64_t v14 = v13 >> 2;
    if (v12) {
      unint64_t v14 = 1;
    }
    if (v14 >> 61) {
      sub_2153E6200();
    }
    unint64_t v15 = (v14 + 3) >> 2;
    uint64_t v16 = 8 * v14;
    uint64_t v17 = (char *)operator new(8 * v14);
    long long v5 = &v17[8 * v15];
    uint64_t v18 = &v17[v16];
    uint64_t v19 = v5;
    uint64_t v20 = v7 - v4;
    if (v7 != v4)
    {
      uint64_t v19 = &v5[v20 & 0xFFFFFFFFFFFFFFF8];
      unint64_t v21 = v20 - 8;
      uint64_t v22 = &v17[8 * v15];
      uint64_t v23 = v4;
      if (v21 > 0x37)
      {
        unint64_t v24 = &v17[8 * v15];
        uint64_t v22 = v24;
        uint64_t v23 = v4;
        if ((unint64_t)(v24 - v4) >= 0x20)
        {
          uint64_t v25 = (v21 >> 3) + 1;
          uint64_t v26 = 8 * (v25 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v22 = &v5[v26];
          unsigned int v27 = (long long *)(v4 + 16);
          uint64_t v28 = v24 + 16;
          uint64_t v29 = v25 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v30 = *v27;
            *(v28 - 1) = *(v27 - 1);
            _OWORD *v28 = v30;
            v27 += 2;
            v28 += 2;
            v29 -= 4;
          }
          while (v29);
          if (v25 == (v25 & 0x3FFFFFFFFFFFFFFCLL))
          {
            *a1 = v17;
            a1[1] = v5;
            a1[2] = v19;
            a1[3] = v18;
            goto LABEL_24;
          }
          uint64_t v23 = &v4[v26];
        }
      }
      do
      {
        uint64_t v31 = *(void *)v23;
        v23 += 8;
        *(void *)uint64_t v22 = v31;
        v22 += 8;
      }
      while (v22 != v19);
    }
    *a1 = v17;
    a1[1] = v5;
    a1[2] = v19;
    a1[3] = v18;
    if (!v4) {
      goto LABEL_25;
    }
LABEL_24:
    operator delete(v4);
    long long v5 = (char *)a1[1];
    goto LABEL_25;
  }
  uint64_t v8 = (v6 - v7) >> 3;
  if (v8 >= -1) {
    uint64_t v9 = v8 + 1;
  }
  else {
    uint64_t v9 = v8 + 2;
  }
  uint64_t v10 = v9 >> 1;
  uint64_t v11 = &v7[8 * (v9 >> 1)];
  long long v5 = &v11[-(v7 - v4)];
  if (v7 != v4)
  {
    memmove(&v11[-(v7 - v4)], v4, v7 - v4);
    unint64_t v4 = (char *)a1[2];
  }
  a1[1] = v5;
  a1[2] = &v4[8 * v10];
LABEL_25:
  *((void *)v5 - 1) = *a2;
  a1[1] = (char *)a1[1] - 8;
}

void sub_2154132DC(char **a1, void *a2)
{
  unint64_t v4 = a1[2];
  if (v4 != a1[3]) {
    goto LABEL_23;
  }
  unint64_t v6 = *a1;
  long long v5 = a1[1];
  if (v5 > *a1)
  {
    uint64_t v7 = (v5 - *a1) >> 3;
    if (v7 >= -1) {
      uint64_t v8 = v7 + 1;
    }
    else {
      uint64_t v8 = v7 + 2;
    }
    uint64_t v9 = v8 >> 1;
    uint64_t v10 = -v9;
    uint64_t v11 = &v5[-8 * v9];
    int64_t v12 = v4 - v5;
    if (v4 != v5)
    {
      memmove(&v5[-8 * v9], a1[1], v4 - v5);
      unint64_t v4 = a1[1];
    }
    uint64_t v13 = &v4[8 * v10];
    unint64_t v4 = &v11[v12];
    a1[1] = v13;
    a1[2] = &v11[v12];
    goto LABEL_23;
  }
  unint64_t v14 = (v4 - v6) >> 2;
  if (v4 == v6) {
    unint64_t v14 = 1;
  }
  if (v14 >> 61) {
    sub_2153E6200();
  }
  unint64_t v15 = v14 >> 2;
  uint64_t v16 = 8 * v14;
  uint64_t v17 = (char *)operator new(8 * v14);
  uint64_t v18 = &v17[8 * v15];
  int64_t v20 = v4 - v5;
  BOOL v19 = v4 == v5;
  unint64_t v4 = v18;
  if (!v19)
  {
    unint64_t v4 = &v18[v20 & 0xFFFFFFFFFFFFFFF8];
    unint64_t v21 = v20 - 8;
    if ((unint64_t)(v20 - 8) < 0x38)
    {
      uint64_t v22 = &v17[8 * v15];
      goto LABEL_20;
    }
    uint64_t v23 = &v17[8 * v15];
    uint64_t v22 = v23;
    if ((unint64_t)(v23 - v5) < 0x20)
    {
      do
      {
LABEL_20:
        uint64_t v30 = *(void *)v5;
        v5 += 8;
        *(void *)uint64_t v22 = v30;
        v22 += 8;
      }
      while (v22 != v4);
      goto LABEL_21;
    }
    uint64_t v24 = (v21 >> 3) + 1;
    uint64_t v25 = 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
    uint64_t v22 = &v18[v25];
    uint64_t v26 = (long long *)(v5 + 16);
    unsigned int v27 = v23 + 16;
    uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v29 = *v26;
      *(v27 - 1) = *(v26 - 1);
      _OWORD *v27 = v29;
      v26 += 2;
      v27 += 2;
      v28 -= 4;
    }
    while (v28);
    if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
    {
      v5 += v25;
      goto LABEL_20;
    }
  }
LABEL_21:
  *a1 = v17;
  a1[1] = v18;
  a1[2] = v4;
  a1[3] = &v17[v16];
  if (v6)
  {
    operator delete(v6);
    unint64_t v4 = a1[2];
  }
LABEL_23:
  *(void *)unint64_t v4 = *a2;
  a1[2] += 8;
}

uint64_t sub_215413468(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  BOOL v3 = a2;
  if (a2 == a3) {
    return (uint64_t)a2;
  }
  unint64_t v4 = a3;
  if (*a2 == 94) {
    operator new();
  }
  if (a2 != a3)
  {
    while (v3 != v4)
    {
      unint64_t v6 = v3;
      uint64_t v7 = (unsigned __int8 *)sub_215419E28(a1, v3, v4);
      if (v7 != v3)
      {
        BOOL v3 = (unsigned __int8 *)sub_21541A134(a1, v7, v4);
        if (v3 != v6) {
          continue;
        }
      }
      if (v6 + 1 == v4 && *v6 == 36) {
        operator new();
      }
      uint64_t v9 = sub_2154107DC();
      return sub_215413608(v9);
    }
  }
  return (uint64_t)v4;
}

unsigned char *sub_215413608(uint64_t a1, unsigned char *a2, unsigned char *a3)
{
  uint64_t v6 = ((uint64_t (*)(void))loc_2154137BC)();
  if ((unsigned char *)v6 == a2) {
    goto LABEL_12;
  }
  do
  {
    uint64_t v7 = (unsigned char *)v6;
    uint64_t v6 = ((uint64_t (*)(uint64_t, uint64_t, unsigned char *))loc_2154137BC)(a1, v6, a3);
  }
  while ((unsigned char *)v6 != v7);
  if (v7 == a2) {
    goto LABEL_12;
  }
  if (v7 != a3)
  {
    if (*v7 == 124)
    {
      uint64_t v8 = v7 + 1;
      uint64_t v9 = ((uint64_t (*)(uint64_t, unsigned char *, unsigned char *))loc_2154137BC)(a1, v7 + 1, a3);
      if ((unsigned char *)v9 != v7 + 1)
      {
        do
        {
          uint64_t v10 = v9;
          uint64_t v9 = ((uint64_t (*)(uint64_t, uint64_t, unsigned char *))loc_2154137BC)(a1, v9, a3);
        }
        while (v9 != v10);
        if ((unsigned char *)v10 != v8) {
          operator new();
        }
      }
LABEL_12:
      sub_2154107DC();
      JUMPOUT(0x2154137BCLL);
    }
    return v7;
  }
  return a3;
}

unsigned char *sub_215413E80(uint64_t a1, unsigned char *a2, unsigned char *a3)
{
  if (a2 != a3 && *a2 == 91)
  {
    if (a2 + 1 != a3) {
      operator new();
    }
    sub_2154107DC();
    sub_2154107DC();
    abort();
  }
  return a2;
}

char *sub_215414CD4(uint64_t a1, char *a2, char *a3)
{
  if (a2 == a3) {
    return a2;
  }
  int v3 = *(_DWORD *)(a1 + 24) & 0x1F0;
  int v4 = *a2;
  if (v4 <= 62)
  {
    if (v4 == 42)
    {
      uint64_t v13 = a2 + 1;
      if (v3) {
        BOOL v14 = 1;
      }
      else {
        BOOL v14 = v13 == a3;
      }
      if (!v14 && *v13 == 63) {
        operator new();
      }
      operator new();
    }
    if (v4 == 43)
    {
      long long v5 = a2 + 1;
      if (!v3 && v5 != a3 && *v5 == 63) {
        operator new();
      }
      operator new();
    }
    return a2;
  }
  if (v4 == 63)
  {
    unint64_t v15 = a2 + 1;
    if (v3) {
      BOOL v16 = 1;
    }
    else {
      BOOL v16 = v15 == a3;
    }
    if (!v16 && *v15 == 63) {
      operator new();
    }
    operator new();
  }
  if (v4 == 123)
  {
    uint64_t v6 = (unsigned __int8 *)(a2 + 1);
    if (a2 + 1 != a3)
    {
      int v7 = *v6;
      if ((v7 & 0xF8) == 0x30 || (v7 & 0xFE) == 0x38)
      {
        int v8 = v7 - 48;
        uint64_t v9 = (unsigned __int8 *)(a2 + 2);
        if (a2 + 2 == a3)
        {
LABEL_19:
          uint64_t v9 = (unsigned __int8 *)a3;
        }
        else
        {
          while (1)
          {
            int v10 = *v9;
            if ((v10 & 0xF8) != 0x30 && (v10 & 0xFE) != 0x38) {
              break;
            }
            if (v8 >= 214748364) {
              goto LABEL_69;
            }
            int v8 = v10 + 10 * v8 - 48;
            if (++v9 == (unsigned __int8 *)a3) {
              goto LABEL_19;
            }
          }
        }
        if (v9 != v6)
        {
          if (v9 == (unsigned __int8 *)a3) {
            goto LABEL_70;
          }
          int v11 = (char)*v9;
          if (v11 == 44)
          {
            uint64_t v18 = (char *)(v9 + 1);
            if (v9 + 1 != (unsigned __int8 *)a3)
            {
              int v19 = *v18;
              if (v19 == 125)
              {
                int64_t v20 = (char *)(v9 + 2);
                if (!v3 && v20 != a3 && *v20 == 63) {
                  sub_2154156C4();
                }
                operator new();
              }
              if ((v19 & 0xF8) != 0x30 && (v19 & 0xFE) != 0x38) {
                goto LABEL_70;
              }
              int v21 = v19 - 48;
              uint64_t v22 = (char *)(v9 + 2);
              if (v22 == a3)
              {
LABEL_58:
                uint64_t v22 = a3;
              }
              else
              {
                while (1)
                {
                  int v23 = *v22;
                  if ((v23 & 0xF8) != 0x30 && (v23 & 0xFE) != 0x38) {
                    break;
                  }
                  if (v21 >= 214748364) {
                    goto LABEL_69;
                  }
                  int v21 = v23 + 10 * v21 - 48;
                  if (++v22 == a3) {
                    goto LABEL_58;
                  }
                }
              }
              if (v22 == v18 || v22 == a3 || *v22 != 125)
              {
LABEL_70:
                sub_2154107DC();
                sub_215415588();
              }
              if (v21 >= v8)
              {
                uint64_t v24 = v22 + 1;
                if (v3 || v24 == a3 || *v24 != 63) {
                  operator new();
                }
LABEL_66:
                sub_215415588();
              }
            }
          }
          else if (v11 == 125)
          {
            int64_t v12 = (char *)(v9 + 1);
            if (v3 || v12 == a3 || *v12 != 63) {
              operator new();
            }
            goto LABEL_66;
          }
        }
      }
    }
LABEL_69:
    sub_2154107DC();
    goto LABEL_70;
  }
  return a2;
}

void sub_215415588()
{
}

void sub_2154156C4()
{
}

uint64_t sub_215415804(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -991;
  *(void *)(a2 + 80) = *(void *)(result + 8);
  return result;
}

void sub_215415818()
{
}

uint64_t sub_215415830(uint64_t result, int a2, uint64_t a3)
{
  *(_DWORD *)a3 = -994;
  if (*(unsigned __int8 *)(result + 52) == a2)
  {
    *(void *)(a3 + 80) = *(void *)(result + 16);
    return result;
  }
  *(void *)(a3 + 80) = *(void *)(result + 8);
  int v3 = *(_DWORD *)(result + 44);
  *(void *)(*(void *)(a3 + 56) + 16 * *(unsigned int *)(result + 40) + 8) = *(void *)(a3 + 16);
  int v4 = *(_DWORD *)(result + 48);
  if (v3 != v4)
  {
    uint64_t v5 = (v4 - 1);
    uint64_t v6 = (v3 - 1);
    uint64_t v7 = *(void *)(a3 + 24);
    uint64_t v8 = *(void *)(a3 + 32);
    uint64_t v9 = v5 - v6;
    if ((unint64_t)(v5 - v6) < 2) {
      goto LABEL_9;
    }
    unint64_t v10 = v9 & 0xFFFFFFFFFFFFFFFELL;
    uint64_t v11 = v8 + 24 * v6 + 24;
    unint64_t v12 = v9 & 0xFFFFFFFFFFFFFFFELL;
    do
    {
      *(void *)(v11 - 24) = v7;
      *(void *)(v11 - 16) = v7;
      *(void *)uint64_t v11 = v7;
      *(void *)(v11 + 8) = v7;
      *(unsigned char *)(v11 - 8) = 0;
      *(unsigned char *)(v11 + 16) = 0;
      v11 += 48;
      v12 -= 2;
    }
    while (v12);
    if (v9 != v10)
    {
      v6 += v10;
LABEL_9:
      uint64_t v13 = v5 - v6;
      BOOL v14 = (unsigned char *)(v8 + 24 * v6 + 16);
      do
      {
        *((void *)v14 - 2) = v7;
        *((void *)v14 - 1) = v7;
        unsigned char *v14 = 0;
        v14 += 24;
        --v13;
      }
      while (v13);
    }
  }
  return result;
}

uint64_t sub_2154158F0(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(result + 40);
  uint64_t v3 = *(void *)(a2 + 56);
  int v4 = (unint64_t *)(v3 + 16 * v2);
  if (*(_DWORD *)a2 != -991)
  {
    unint64_t *v4 = 0;
    if (!*(void *)(result + 32))
    {
      *(_DWORD *)a2 = -994;
      goto LABEL_40;
    }
    if (*(void *)(result + 24))
    {
      *(_DWORD *)a2 = -994;
      *(void *)(a2 + 80) = *(void *)(result + 8);
      *(void *)(v3 + 16 * v2 + 8) = *(void *)(a2 + 16);
      int v24 = *(_DWORD *)(result + 44);
      int v25 = *(_DWORD *)(result + 48);
      if (v24 == v25) {
        return result;
      }
      uint64_t v26 = (v25 - 1);
      uint64_t v27 = (v24 - 1);
      uint64_t v28 = *(void *)(a2 + 24);
      uint64_t v29 = *(void *)(a2 + 32);
      uint64_t v30 = v26 - v27;
      if ((unint64_t)(v26 - v27) >= 2)
      {
        unint64_t v31 = v30 & 0xFFFFFFFFFFFFFFFELL;
        uint64_t v32 = v29 + 24 * v27 + 24;
        unint64_t v33 = v30 & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          *(void *)(v32 - 24) = v28;
          *(void *)(v32 - 16) = v28;
          *(void *)uint64_t v32 = v28;
          *(void *)(v32 + 8) = v28;
          *(unsigned char *)(v32 - 8) = 0;
          *(unsigned char *)(v32 + 16) = 0;
          v32 += 48;
          v33 -= 2;
        }
        while (v33);
        if (v30 == v31) {
          return result;
        }
        v27 += v31;
      }
      uint64_t v34 = v26 - v27;
      uint64_t v35 = (unsigned char *)(v29 + 24 * v27 + 16);
      do
      {
        *((void *)v35 - 2) = v28;
        *((void *)v35 - 1) = v28;
        *uint64_t v35 = 0;
        v35 += 24;
        --v34;
      }
      while (v34);
      return result;
    }
LABEL_38:
    *(_DWORD *)a2 = -992;
    return result;
  }
  unint64_t v5 = *v4 + 1;
  unint64_t *v4 = v5;
  unint64_t v6 = *(void *)(result + 24);
  unint64_t v7 = *(void *)(result + 32);
  BOOL v8 = v5 < v7;
  if (v5 < v7 && v5 >= v6) {
    BOOL v8 = v5 < v7 && *(void *)(v3 + 16 * v2 + 8) != *(void *)(a2 + 16);
  }
  if (v8 && v5 >= v6) {
    goto LABEL_38;
  }
  *(_DWORD *)a2 = -994;
  if (!v8)
  {
LABEL_40:
    *(void *)(a2 + 80) = *(void *)(result + 16);
    return result;
  }
  *(void *)(a2 + 80) = *(void *)(result + 8);
  *(void *)(v3 + 16 * v2 + 8) = *(void *)(a2 + 16);
  int v12 = *(_DWORD *)(result + 44);
  int v13 = *(_DWORD *)(result + 48);
  if (v12 == v13) {
    return result;
  }
  uint64_t v14 = (v13 - 1);
  uint64_t v15 = (v12 - 1);
  uint64_t v16 = *(void *)(a2 + 24);
  uint64_t v17 = *(void *)(a2 + 32);
  uint64_t v18 = v14 - v15;
  if ((unint64_t)(v14 - v15) < 2) {
    goto LABEL_24;
  }
  unint64_t v19 = v18 & 0xFFFFFFFFFFFFFFFELL;
  uint64_t v20 = v17 + 24 * v15 + 24;
  unint64_t v21 = v18 & 0xFFFFFFFFFFFFFFFELL;
  do
  {
    *(void *)(v20 - 24) = v16;
    *(void *)(v20 - 16) = v16;
    *(void *)uint64_t v20 = v16;
    *(void *)(v20 + 8) = v16;
    *(unsigned char *)(v20 - 8) = 0;
    *(unsigned char *)(v20 + 16) = 0;
    v20 += 48;
    v21 -= 2;
  }
  while (v21);
  if (v18 != v19)
  {
    v15 += v19;
LABEL_24:
    uint64_t v22 = v14 - v15;
    int v23 = (unsigned char *)(v17 + 24 * v15 + 16);
    do
    {
      *((void *)v23 - 2) = v16;
      *((void *)v23 - 1) = v16;
      unsigned char *v23 = 0;
      v23 += 24;
      --v22;
    }
    while (v22);
  }
  return result;
}

void sub_215415AC4(void *a1)
{
  *a1 = &unk_26C5FC1A0;
  uint64_t v2 = a1[2];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *a1 = &unk_26C5FC170;
  uint64_t v3 = a1[1];
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  JUMPOUT(0x2166B9890);
}

void sub_215415B9C(void *a1)
{
  *a1 = &unk_26C5FC170;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  JUMPOUT(0x2166B9890);
}

void *sub_215415C28(void *a1)
{
  *a1 = &unk_26C5FC170;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_215415C94(void *a1)
{
  *a1 = &unk_26C5FC1A0;
  uint64_t v2 = a1[2];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *a1 = &unk_26C5FC170;
  uint64_t v3 = a1[1];
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  JUMPOUT(0x2166B9890);
}

void *sub_215415D68(void *a1)
{
  *a1 = &unk_26C5FC1A0;
  uint64_t v2 = a1[2];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *a1 = &unk_26C5FC170;
  uint64_t v3 = a1[1];
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  return a1;
}

void *sub_215415E1C(void *a1)
{
  *a1 = &unk_26C5FC1A0;
  uint64_t v2 = a1[2];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *a1 = &unk_26C5FC170;
  uint64_t v3 = a1[1];
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  return a1;
}

uint64_t sub_215415ED0(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -994;
  uint64_t v2 = *(void *)(a2 + 32) + 24 * (*(_DWORD *)(result + 16) - 1);
  *(void *)(v2 + 8) = *(void *)(a2 + 16);
  *(unsigned char *)(v2 + 16) = 1;
  *(void *)(a2 + 80) = *(void *)(result + 8);
  return result;
}

void sub_215415F08(void *a1)
{
  *a1 = &unk_26C5FC170;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  JUMPOUT(0x2166B9890);
}

void *sub_215415F94(void *a1)
{
  *a1 = &unk_26C5FC170;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

uint64_t sub_215416000(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -994;
  *(void *)(*(void *)(a2 + 32) + 24 * (*(_DWORD *)(result + 16) - 1)) = *(void *)(a2 + 16);
  *(void *)(a2 + 80) = *(void *)(result + 8);
  return result;
}

void sub_215416030(void *a1)
{
  *a1 = &unk_26C5FC170;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  JUMPOUT(0x2166B9890);
}

void *sub_2154160BC(void *a1)
{
  *a1 = &unk_26C5FC170;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

uint64_t sub_215416128(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 **)(a2 + 16);
  if (v2 == *(unsigned __int8 **)(a2 + 24) && (*(unsigned char *)(a2 + 88) & 2) == 0
    || *(unsigned char *)(result + 16) && ((int v3 = *v2, v3 != 13) ? (v4 = v3 == 10) : (v4 = 1), v4))
  {
    *(_DWORD *)a2 = -994;
    *(void *)(a2 + 80) = *(void *)(result + 8);
  }
  else
  {
    *(_DWORD *)a2 = -993;
    *(void *)(a2 + 80) = 0;
  }
  return result;
}

void sub_215416178(void *a1)
{
  *a1 = &unk_26C5FC170;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  JUMPOUT(0x2166B9890);
}

void *sub_215416204(void *a1)
{
  *a1 = &unk_26C5FC170;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

uint64_t sub_215416270(uint64_t result, uint64_t a2)
{
  if (!*(unsigned char *)(a2 + 92))
  {
    if (!*(unsigned char *)(result + 16)) {
      goto LABEL_12;
    }
    int v2 = *(unsigned __int8 *)(*(void *)(a2 + 16) - 1);
    if (v2 != 13 && v2 != 10) {
      goto LABEL_12;
    }
LABEL_11:
    *(_DWORD *)a2 = -994;
    *(void *)(a2 + 80) = *(void *)(result + 8);
    return result;
  }
  if (*(void *)(a2 + 16) == *(void *)(a2 + 8) && (*(unsigned char *)(a2 + 88) & 1) == 0) {
    goto LABEL_11;
  }
LABEL_12:
  *(_DWORD *)a2 = -993;
  *(void *)(a2 + 80) = 0;
  return result;
}

void sub_2154162D0(void *a1)
{
  *a1 = &unk_26C5FC170;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  JUMPOUT(0x2166B9890);
}

void *sub_21541635C(void *a1)
{
  *a1 = &unk_26C5FC170;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

uint64_t sub_2154163C8(uint64_t a1, uint64_t a2, uint64_t a3, char a4, char a5, char a6)
{
  *(void *)a1 = &unk_26C5FC260;
  *(void *)(a1 + 8) = a3;
  uint64_t v11 = (const std::locale *)(a1 + 16);
  std::locale::locale((std::locale *)(a1 + 16), (const std::locale *)a2);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(unsigned char *)(a1 + 168) = a4;
  *(unsigned char *)(a1 + 169) = a5;
  *(unsigned char *)(a1 + 170) = a6;
  std::locale::locale(&v14, v11);
  std::locale::name(&v15, &v14);
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0)
  {
    BOOL v12 = v15.__r_.__value_.__l.__size_ != 1 || *v15.__r_.__value_.__l.__data_ != 67;
    operator delete(v15.__r_.__value_.__l.__data_);
  }
  else
  {
    BOOL v12 = SHIBYTE(v15.__r_.__value_.__r.__words[2]) != 1 || v15.__r_.__value_.__s.__data_[0] != 67;
  }
  std::locale::~locale(&v14);
  *(unsigned char *)(a1 + 171) = v12;
  return a1;
}

void sub_2154164E4(uint64_t a1, uint64_t a2)
{
  char v2 = a2;
  if (!*(unsigned char *)(a1 + 169))
  {
    unint64_t v5 = *(unsigned char **)(a1 + 48);
    unint64_t v12 = *(void *)(a1 + 56);
    if (*(unsigned char *)(a1 + 170))
    {
      if ((unint64_t)v5 < v12) {
        goto LABEL_22;
      }
      unint64_t v6 = *(unsigned char **)(a1 + 40);
      unint64_t v13 = v5 - v6;
      uint64_t v14 = v5 - v6 + 1;
      if (v14 >= 0)
      {
        unint64_t v15 = v12 - (void)v6;
        if (2 * v15 > v14) {
          uint64_t v14 = 2 * v15;
        }
        if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v16 = v14;
        }
        if (v16) {
          uint64_t v11 = operator new(v16);
        }
        else {
          uint64_t v11 = 0;
        }
        uint64_t v18 = (char *)v11 + v13;
        unint64_t v19 = (char *)v11 + v16;
        *((unsigned char *)v11 + v13) = v2;
        uint64_t v17 = (uint64_t)v11 + v13 + 1;
        if (v5 == v6) {
          goto LABEL_49;
        }
        if (v13 >= 8 && (unint64_t)(v6 - (unsigned char *)v11) >= 0x20)
        {
          if (v13 >= 0x20)
          {
            unint64_t v25 = v13 & 0xFFFFFFFFFFFFFFE0;
            uint64_t v35 = (long long *)(v5 - 16);
            BOOL v36 = (char *)v11 + v5 - 16 - v6;
            unint64_t v37 = v13 & 0xFFFFFFFFFFFFFFE0;
            do
            {
              long long v38 = *v35;
              *(v36 - 1) = *(v35 - 1);
              *BOOL v36 = v38;
              v36 -= 2;
              v35 -= 2;
              v37 -= 32;
            }
            while (v37);
            if (v13 == v25) {
              goto LABEL_73;
            }
            if ((v13 & 0x18) == 0)
            {
              v18 -= v25;
              v5 -= v25;
              goto LABEL_80;
            }
          }
          else
          {
            unint64_t v25 = 0;
          }
          unint64_t v39 = v25 - (v13 & 0xFFFFFFFFFFFFFFF8);
          unint64_t v40 = &v5[-v25 - 8];
          unint64_t v41 = (char *)(v40 - v6);
          do
          {
            uint64_t v42 = *(void *)v40;
            v40 -= 8;
            *(void *)&v41[(void)v11] = v42;
            v41 -= 8;
            v39 += 8;
          }
          while (v39);
          if (v13 == (v13 & 0xFFFFFFFFFFFFFFF8)) {
            goto LABEL_73;
          }
          v18 -= v13 & 0xFFFFFFFFFFFFFFF8;
          v5 -= v13 & 0xFFFFFFFFFFFFFFF8;
        }
LABEL_80:
        float v53 = v18 - 1;
        do
        {
          char v54 = *--v5;
          *v53-- = v54;
        }
        while (v5 != v6);
        goto LABEL_86;
      }
LABEL_90:
      abort();
    }
    if ((unint64_t)v5 < v12) {
      goto LABEL_22;
    }
    unint64_t v6 = *(unsigned char **)(a1 + 40);
    unint64_t v21 = v5 - v6;
    uint64_t v22 = v5 - v6 + 1;
    if (v22 < 0) {
      goto LABEL_90;
    }
    unint64_t v23 = v12 - (void)v6;
    if (2 * v23 > v22) {
      uint64_t v22 = 2 * v23;
    }
    if (v23 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v24 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v24 = v22;
    }
    if (v24) {
      uint64_t v11 = operator new(v24);
    }
    else {
      uint64_t v11 = 0;
    }
    uint64_t v18 = (char *)v11 + v21;
    unint64_t v19 = (char *)v11 + v24;
    *((unsigned char *)v11 + v21) = v2;
    uint64_t v17 = (uint64_t)v11 + v21 + 1;
    if (v5 == v6) {
      goto LABEL_49;
    }
    if (v21 >= 8 && (unint64_t)(v6 - (unsigned char *)v11) >= 0x20)
    {
      if (v21 >= 0x20)
      {
        unint64_t v26 = v21 & 0xFFFFFFFFFFFFFFE0;
        uint64_t v43 = (long long *)(v5 - 16);
        int64_t v44 = (char *)v11 + v5 - 16 - v6;
        unint64_t v45 = v21 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v46 = *v43;
          *(v44 - 1) = *(v43 - 1);
          *int64_t v44 = v46;
          v44 -= 2;
          v43 -= 2;
          v45 -= 32;
        }
        while (v45);
        if (v21 == v26) {
          goto LABEL_73;
        }
        if ((v21 & 0x18) == 0)
        {
          v18 -= v26;
          v5 -= v26;
          goto LABEL_84;
        }
      }
      else
      {
        unint64_t v26 = 0;
      }
      unint64_t v47 = v26 - (v21 & 0xFFFFFFFFFFFFFFF8);
      uint64_t v48 = &v5[-v26 - 8];
      unint64_t v49 = (char *)(v48 - v6);
      do
      {
        uint64_t v50 = *(void *)v48;
        v48 -= 8;
        *(void *)&v49[(void)v11] = v50;
        v49 -= 8;
        v47 += 8;
      }
      while (v47);
      if (v21 == (v21 & 0xFFFFFFFFFFFFFFF8)) {
        goto LABEL_73;
      }
      v18 -= v21 & 0xFFFFFFFFFFFFFFF8;
      v5 -= v21 & 0xFFFFFFFFFFFFFFF8;
    }
LABEL_84:
    uint64_t v55 = v18 - 1;
    do
    {
      char v56 = *--v5;
      *v55-- = v56;
    }
    while (v5 != v6);
    goto LABEL_86;
  }
  char v2 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), a2);
  unint64_t v5 = *(unsigned char **)(a1 + 48);
  unint64_t v4 = *(void *)(a1 + 56);
  if ((unint64_t)v5 < v4)
  {
LABEL_22:
    *unint64_t v5 = v2;
    uint64_t v17 = (uint64_t)(v5 + 1);
    goto LABEL_89;
  }
  unint64_t v6 = *(unsigned char **)(a1 + 40);
  unint64_t v7 = v5 - v6;
  uint64_t v8 = v5 - v6 + 1;
  if (v8 < 0) {
    goto LABEL_90;
  }
  unint64_t v9 = v4 - (void)v6;
  if (2 * v9 > v8) {
    uint64_t v8 = 2 * v9;
  }
  if (v9 >= 0x3FFFFFFFFFFFFFFFLL) {
    size_t v10 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    size_t v10 = v8;
  }
  if (v10) {
    uint64_t v11 = operator new(v10);
  }
  else {
    uint64_t v11 = 0;
  }
  uint64_t v18 = (char *)v11 + v7;
  unint64_t v19 = (char *)v11 + v10;
  *((unsigned char *)v11 + v7) = v2;
  uint64_t v17 = (uint64_t)v11 + v7 + 1;
  if (v5 == v6)
  {
LABEL_49:
    uint64_t v11 = v18;
    goto LABEL_87;
  }
  if (v7 < 8 || (unint64_t)(v6 - (unsigned char *)v11) < 0x20) {
    goto LABEL_75;
  }
  if (v7 < 0x20)
  {
    unint64_t v20 = 0;
    goto LABEL_54;
  }
  unint64_t v20 = v7 & 0xFFFFFFFFFFFFFFE0;
  uint64_t v27 = (long long *)(v5 - 16);
  uint64_t v28 = (char *)v11 + v5 - 16 - v6;
  unint64_t v29 = v7 & 0xFFFFFFFFFFFFFFE0;
  do
  {
    long long v30 = *v27;
    *(v28 - 1) = *(v27 - 1);
    _OWORD *v28 = v30;
    v28 -= 2;
    v27 -= 2;
    v29 -= 32;
  }
  while (v29);
  if (v7 == v20) {
    goto LABEL_73;
  }
  if ((v7 & 0x18) != 0)
  {
LABEL_54:
    unint64_t v31 = v20 - (v7 & 0xFFFFFFFFFFFFFFF8);
    uint64_t v32 = &v5[-v20 - 8];
    unint64_t v33 = (char *)(v32 - v6);
    do
    {
      uint64_t v34 = *(void *)v32;
      v32 -= 8;
      *(void *)&v33[(void)v11] = v34;
      v33 -= 8;
      v31 += 8;
    }
    while (v31);
    if (v7 != (v7 & 0xFFFFFFFFFFFFFFF8))
    {
      v18 -= v7 & 0xFFFFFFFFFFFFFFF8;
      v5 -= v7 & 0xFFFFFFFFFFFFFFF8;
      goto LABEL_75;
    }
LABEL_73:
    unint64_t v5 = v6;
    goto LABEL_87;
  }
  v18 -= v20;
  v5 -= v20;
LABEL_75:
  unint64_t v51 = v18 - 1;
  do
  {
    char v52 = *--v5;
    *v51-- = v52;
  }
  while (v5 != v6);
LABEL_86:
  unint64_t v5 = *(unsigned char **)(a1 + 40);
LABEL_87:
  *(void *)(a1 + 40) = v11;
  *(void *)(a1 + 48) = v17;
  *(void *)(a1 + 56) = v19;
  if (v5) {
    operator delete(v5);
  }
LABEL_89:
  *(void *)(a1 + 48) = v17;
}

void sub_215416924(uint64_t a1, uint64_t a2, unsigned char *__src, unsigned char *a4)
{
  size_t v4 = a4 - __src;
  if ((unint64_t)(a4 - __src) >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v4 <= 0x16)
  {
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = (_BYTE)a4 - (_BYTE)__src;
    p_dst = &__dst;
    if (__src == a4) {
      goto LABEL_9;
    }
LABEL_8:
    memcpy(p_dst, __src, v4);
    p_dst = (std::string *)((char *)p_dst + v4);
    goto LABEL_9;
  }
  uint64_t v10 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
  if ((v4 | 7) != 0x17) {
    uint64_t v10 = v4 | 7;
  }
  uint64_t v11 = v10 + 1;
  p_dst = (std::string *)operator new(v10 + 1);
  __dst.__r_.__value_.__l.__size_ = v4;
  __dst.__r_.__value_.__r.__words[2] = v11 | 0x8000000000000000;
  __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
  if (__src != a4) {
    goto LABEL_8;
  }
LABEL_9:
  p_dst->__r_.__value_.__s.__data_[0] = 0;
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    if (!__dst.__r_.__value_.__l.__size_) {
      goto LABEL_17;
    }
    unint64_t v12 = (std::string *)__dst.__r_.__value_.__r.__words[0];
  }
  else
  {
    if (!*((unsigned char *)&__dst.__r_.__value_.__s + 23)) {
      return;
    }
    unint64_t v12 = &__dst;
  }
  std::__get_collation_name(&v17, (const char *)v12);
  *(_OWORD *)a1 = *(_OWORD *)&v17.__r_.__value_.__l.__data_;
  unint64_t v13 = v17.__r_.__value_.__r.__words[2];
  *(void *)(a1 + 16) = *((void *)&v17.__r_.__value_.__l + 2);
  unint64_t v14 = HIBYTE(v13);
  if ((v14 & 0x80u) != 0) {
    unint64_t v14 = *(void *)(a1 + 8);
  }
  if (v14) {
    goto LABEL_17;
  }
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    if (__dst.__r_.__value_.__l.__size_ >= 3) {
      goto LABEL_17;
    }
  }
  else if (HIBYTE(__dst.__r_.__value_.__r.__words[2]) >= 3u)
  {
    return;
  }
  (*(void (**)(std::string *__return_ptr))(**(void **)(a2 + 16) + 32))(&v17);
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  *(std::string *)a1 = v17;
  if ((*(char *)(a1 + 23) & 0x80000000) == 0)
  {
    int v15 = *(unsigned __int8 *)(a1 + 23);
    if (v15 != 12 && v15 != 1)
    {
      *(unsigned char *)a1 = 0;
      *(unsigned char *)(a1 + 23) = 0;
      goto LABEL_17;
    }
    goto LABEL_31;
  }
  uint64_t v16 = *(void *)(a1 + 8);
  if (v16 == 1 || v16 == 12)
  {
LABEL_31:
    std::string::operator=((std::string *)a1, &__dst);
    goto LABEL_17;
  }
  **(unsigned char **)a1 = 0;
  *(void *)(a1 + 8) = 0;
LABEL_17:
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
}

unsigned char *sub_215416B34(int a1, unsigned char *a2, unsigned char *a3, std::string *this, uint64_t a5)
{
  if (a2 == a3)
  {
    sub_2154107DC();
    goto LABEL_111;
  }
  switch(*a2)
  {
    case 'D':
      *(_DWORD *)(a5 + 164) |= 0x400u;
      return a2 + 1;
    case 'E':
    case 'F':
    case 'G':
    case 'H':
    case 'I':
    case 'J':
    case 'K':
    case 'L':
    case 'M':
    case 'N':
    case 'O':
    case 'P':
    case 'Q':
    case 'R':
    case 'T':
    case 'U':
    case 'V':
    case 'X':
    case 'Y':
    case 'Z':
    case '[':
    case '\\':
    case ']':
    case '^':
    case '_':
    case 'a':
    case 'c':
    case 'e':
    case 'f':
    case 'g':
    case 'h':
    case 'i':
    case 'j':
    case 'k':
    case 'l':
    case 'm':
    case 'n':
    case 'o':
    case 'p':
    case 'q':
    case 'r':
    case 't':
    case 'u':
    case 'v':
      goto LABEL_6;
    case 'S':
      *(_DWORD *)(a5 + 164) |= 0x4000u;
      return a2 + 1;
    case 'W':
      *(_DWORD *)(a5 + 164) |= 0x500u;
      if (*(unsigned char *)(a5 + 169))
      {
        char v7 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a5 + 24) + 40))(*(void *)(a5 + 24), 95);
        char v8 = v7;
        uint64_t v10 = *(unsigned char **)(a5 + 72);
        unint64_t v9 = *(void *)(a5 + 80);
        if ((unint64_t)v10 < v9)
        {
          unsigned char *v10 = v7;
          *(void *)(a5 + 72) = v10 + 1;
          return a2 + 1;
        }
        unint64_t v19 = *(unsigned char **)(a5 + 64);
        unint64_t v20 = v10 - v19;
        uint64_t v21 = v10 - v19 + 1;
        if (v21 >= 0)
        {
          unint64_t v22 = v9 - (void)v19;
          if (2 * v22 > v21) {
            uint64_t v21 = 2 * v22;
          }
          if (v22 >= 0x3FFFFFFFFFFFFFFFLL) {
            size_t v23 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            size_t v23 = v21;
          }
          if (v23) {
            size_t v24 = operator new(v23);
          }
          else {
            size_t v24 = 0;
          }
          unint64_t v25 = (char *)v24 + v20;
          unint64_t v26 = (char *)v24 + v23;
          *((unsigned char *)v24 + v20) = v8;
          uint64_t v27 = (uint64_t)v24 + v20 + 1;
          if (v10 == v19)
          {
            size_t v24 = (char *)v24 + v20;
LABEL_94:
            *(void *)(a5 + 64) = v24;
            *(void *)(a5 + 72) = v27;
            *(void *)(a5 + 80) = v26;
            if (v10) {
              operator delete(v10);
            }
            *(void *)(a5 + 72) = v27;
            return a2 + 1;
          }
          if (v20 >= 8 && (unint64_t)(v19 - (unsigned char *)v24) >= 0x20)
          {
            if (v20 >= 0x20)
            {
              unint64_t v28 = v20 & 0xFFFFFFFFFFFFFFE0;
              long long v38 = (long long *)(v10 - 16);
              unint64_t v39 = (char *)v24 + v10 - 16 - v19;
              unint64_t v40 = v20 & 0xFFFFFFFFFFFFFFE0;
              do
              {
                long long v41 = *v38;
                *(v39 - 1) = *(v38 - 1);
                *unint64_t v39 = v41;
                v39 -= 2;
                v38 -= 2;
                v40 -= 32;
              }
              while (v40);
              if (v20 == v28) {
                goto LABEL_72;
              }
              if ((v20 & 0x18) == 0)
              {
                v25 -= v28;
                v10 -= v28;
                goto LABEL_91;
              }
            }
            else
            {
              unint64_t v28 = 0;
            }
            unint64_t v42 = v28 - (v20 & 0xFFFFFFFFFFFFFFF8);
            uint64_t v43 = &v10[-v28 - 8];
            int64_t v44 = (char *)(v43 - v19);
            do
            {
              uint64_t v45 = *(void *)v43;
              v43 -= 8;
              *(void *)&v44[(void)v24] = v45;
              v44 -= 8;
              v42 += 8;
            }
            while (v42);
            if (v20 == (v20 & 0xFFFFFFFFFFFFFFF8))
            {
LABEL_72:
              uint64_t v10 = v19;
              goto LABEL_94;
            }
            v25 -= v20 & 0xFFFFFFFFFFFFFFF8;
            v10 -= v20 & 0xFFFFFFFFFFFFFFF8;
          }
LABEL_91:
          unint64_t v62 = v25 - 1;
          do
          {
            char v63 = *--v10;
            *v62-- = v63;
          }
          while (v10 != v19);
          uint64_t v10 = *(unsigned char **)(a5 + 64);
          goto LABEL_94;
        }
LABEL_111:
        abort();
      }
      unint64_t v12 = *(unsigned char **)(a5 + 72);
      unint64_t v11 = *(void *)(a5 + 80);
      if (!*(unsigned char *)(a5 + 170))
      {
        if ((unint64_t)v12 < v11) {
          goto LABEL_36;
        }
        unint64_t v13 = *(unsigned char **)(a5 + 64);
        unint64_t v29 = v12 - v13;
        uint64_t v30 = v12 - v13 + 1;
        if (v30 < 0) {
          goto LABEL_111;
        }
        unint64_t v31 = v11 - (void)v13;
        if (2 * v31 > v30) {
          uint64_t v30 = 2 * v31;
        }
        if (v31 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v32 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v32 = v30;
        }
        if (v32) {
          uint64_t v18 = operator new(v32);
        }
        else {
          uint64_t v18 = 0;
        }
        unint64_t v33 = (char *)v18 + v29;
        uint64_t v34 = (char *)v18 + v32;
        *((unsigned char *)v18 + v29) = 95;
        uint64_t v35 = (uint64_t)v18 + v29 + 1;
        if (v12 == v13) {
          goto LABEL_64;
        }
        if (v29 >= 8 && (unint64_t)(v13 - (unsigned char *)v18) >= 0x20)
        {
          if (v29 >= 0x20)
          {
            unint64_t v37 = v29 & 0xFFFFFFFFFFFFFFE0;
            char v54 = (long long *)(v12 - 16);
            uint64_t v55 = (char *)v18 + v12 - 16 - v13;
            unint64_t v56 = v29 & 0xFFFFFFFFFFFFFFE0;
            do
            {
              long long v57 = *v54;
              *(v55 - 1) = *(v54 - 1);
              _OWORD *v55 = v57;
              v55 -= 2;
              v54 -= 2;
              v56 -= 32;
            }
            while (v56);
            if (v29 == v37) {
              goto LABEL_89;
            }
            if ((v29 & 0x18) == 0)
            {
              v33 -= v37;
              v12 -= v37;
              goto LABEL_103;
            }
          }
          else
          {
            unint64_t v37 = 0;
          }
          unint64_t v58 = v37 - (v29 & 0xFFFFFFFFFFFFFFF8);
          uint64_t v59 = &v12[-v37 - 8];
          size_t v60 = (char *)(v59 - v13);
          do
          {
            uint64_t v61 = *(void *)v59;
            v59 -= 8;
            *(void *)&v60[(void)v18] = v61;
            v60 -= 8;
            v58 += 8;
          }
          while (v58);
          if (v29 == (v29 & 0xFFFFFFFFFFFFFFF8)) {
            goto LABEL_89;
          }
          v33 -= v29 & 0xFFFFFFFFFFFFFFF8;
          v12 -= v29 & 0xFFFFFFFFFFFFFFF8;
        }
LABEL_103:
        uint64_t v66 = v33 - 1;
        do
        {
          char v67 = *--v12;
          *v66-- = v67;
        }
        while (v12 != v13);
        goto LABEL_105;
      }
      if ((unint64_t)v12 < v11)
      {
LABEL_36:
        unsigned char *v12 = 95;
        *(void *)(a5 + 72) = v12 + 1;
        return a2 + 1;
      }
      unint64_t v13 = *(unsigned char **)(a5 + 64);
      unint64_t v14 = v12 - v13;
      uint64_t v15 = v12 - v13 + 1;
      if (v15 < 0) {
        goto LABEL_111;
      }
      unint64_t v16 = v11 - (void)v13;
      if (2 * v16 > v15) {
        uint64_t v15 = 2 * v16;
      }
      if (v16 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v17 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v17 = v15;
      }
      if (v17) {
        uint64_t v18 = operator new(v17);
      }
      else {
        uint64_t v18 = 0;
      }
      unint64_t v33 = (char *)v18 + v14;
      uint64_t v34 = (char *)v18 + v17;
      *((unsigned char *)v18 + v14) = 95;
      uint64_t v35 = (uint64_t)v18 + v14 + 1;
      if (v12 != v13)
      {
        if (v14 < 8 || (unint64_t)(v13 - (unsigned char *)v18) < 0x20) {
          goto LABEL_99;
        }
        if (v14 < 0x20)
        {
          uint64_t v36 = 0;
LABEL_78:
          uint64_t v50 = v36 - (v14 & 0xFFFFFFFFFFFFFFF8);
          unint64_t v51 = &v12[-v36 - 8];
          char v52 = (char *)(v51 - v13);
          do
          {
            uint64_t v53 = *(void *)v51;
            v51 -= 8;
            *(void *)&v52[(void)v18] = v53;
            v52 -= 8;
            v50 += 8;
          }
          while (v50);
          if (v14 != (v14 & 0xFFFFFFFFFFFFFFF8))
          {
            v33 -= v14 & 0xFFFFFFFFFFFFFFF8;
            v12 -= v14 & 0xFFFFFFFFFFFFFFF8;
            goto LABEL_99;
          }
          goto LABEL_89;
        }
        uint64_t v36 = v14 & 0xFFFFFFFFFFFFFFE0;
        long long v46 = (long long *)(v12 - 16);
        unint64_t v47 = (char *)v18 + v12 - 16 - v13;
        unint64_t v48 = v14 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v49 = *v46;
          *(v47 - 1) = *(v46 - 1);
          *unint64_t v47 = v49;
          v47 -= 2;
          v46 -= 2;
          v48 -= 32;
        }
        while (v48);
        if (v14 != v36)
        {
          if ((v14 & 0x18) == 0)
          {
            v33 -= v36;
            v12 -= v36;
LABEL_99:
            uint64_t v64 = v33 - 1;
            do
            {
              char v65 = *--v12;
              *v64-- = v65;
            }
            while (v12 != v13);
LABEL_105:
            unint64_t v12 = *(unsigned char **)(a5 + 64);
            goto LABEL_106;
          }
          goto LABEL_78;
        }
LABEL_89:
        unint64_t v12 = v13;
        goto LABEL_106;
      }
LABEL_64:
      uint64_t v18 = v33;
LABEL_106:
      *(void *)(a5 + 64) = v18;
      *(void *)(a5 + 72) = v35;
      *(void *)(a5 + 80) = v34;
      if (v12) {
        operator delete(v12);
      }
      *(void *)(a5 + 72) = v35;
      return a2 + 1;
    case 'b':
      std::string::operator=(this, 8);
      return a2 + 1;
    case 'd':
      *(_DWORD *)(a5 + 160) |= 0x400u;
      return a2 + 1;
    case 's':
      *(_DWORD *)(a5 + 160) |= 0x4000u;
      return a2 + 1;
    case 'w':
      *(_DWORD *)(a5 + 160) |= 0x500u;
      sub_2154164E4(a5, 95);
      return a2 + 1;
    default:
      if (*a2)
      {
LABEL_6:
        JUMPOUT(0x2154181A0);
      }
      std::string::operator=(this, 0);
      return a2 + 1;
  }
}

void sub_2154174A8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!*(unsigned char *)(a1 + 169))
  {
    __int16 v10 = a2 | (unsigned __int16)((_WORD)a3 << 8);
    unint64_t v12 = *(char **)(a1 + 120);
    unint64_t v11 = *(void *)(a1 + 128);
    if (*(unsigned char *)(a1 + 170))
    {
      if ((unint64_t)v12 >= v11)
      {
        unint64_t v13 = *(char **)(a1 + 112);
        uint64_t v14 = v12 - v13;
        if (v12 - v13 <= -3) {
          goto LABEL_73;
        }
        uint64_t v15 = v14 >> 1;
        unint64_t v16 = v11 - (void)v13;
        if (v16 <= (v14 >> 1) + 1) {
          unint64_t v17 = v15 + 1;
        }
        else {
          unint64_t v17 = v16;
        }
        if (v16 >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v18 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v18 = v17;
        }
        if (v18)
        {
          if (v18 < 0) {
            goto LABEL_74;
          }
          unint64_t v19 = operator new(2 * v18);
        }
        else
        {
          unint64_t v19 = 0;
        }
        uint64_t v43 = &v19[2 * v15];
        int64_t v44 = &v19[2 * v18];
        _WORD *v43 = v10;
        unint64_t v9 = v43 + 1;
        if (v12 != v13)
        {
          unint64_t v45 = v12 - v13 - 2;
          if (v45 < 0x1E) {
            goto LABEL_77;
          }
          if (v12 - v19 - (v14 & 0xFFFFFFFFFFFFFFFELL) < 0x20) {
            goto LABEL_77;
          }
          uint64_t v46 = (v45 >> 1) + 1;
          unint64_t v47 = &v19[2 * v15 - 16];
          unint64_t v48 = v12 - 16;
          unint64_t v49 = v46 & 0xFFFFFFFFFFFFFFF0;
          do
          {
            long long v50 = *(_OWORD *)v48;
            *(v47 - 1) = *((_OWORD *)v48 - 1);
            *unint64_t v47 = v50;
            v47 -= 2;
            v48 -= 32;
            v49 -= 16;
          }
          while (v49);
          v43 -= v46 & 0xFFFFFFFFFFFFFFF0;
          v12 -= 2 * (v46 & 0xFFFFFFFFFFFFFFF0);
          if (v46 != (v46 & 0xFFFFFFFFFFFFFFF0))
          {
LABEL_77:
            do
            {
              __int16 v51 = *((_WORD *)v12 - 1);
              v12 -= 2;
              *--uint64_t v43 = v51;
            }
            while (v12 != v13);
LABEL_68:
            unint64_t v13 = *(char **)(a1 + 112);
            goto LABEL_70;
          }
          goto LABEL_70;
        }
        goto LABEL_69;
      }
    }
    else if ((unint64_t)v12 >= v11)
    {
      unint64_t v13 = *(char **)(a1 + 112);
      uint64_t v37 = v12 - v13;
      if (v12 - v13 <= -3) {
        goto LABEL_73;
      }
      uint64_t v38 = v37 >> 1;
      unint64_t v39 = v11 - (void)v13;
      if (v39 <= (v37 >> 1) + 1) {
        unint64_t v40 = v38 + 1;
      }
      else {
        unint64_t v40 = v39;
      }
      if (v39 >= 0x7FFFFFFFFFFFFFFELL) {
        uint64_t v41 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v41 = v40;
      }
      if (v41)
      {
        if (v41 < 0) {
          goto LABEL_74;
        }
        unint64_t v42 = operator new(2 * v41);
      }
      else
      {
        unint64_t v42 = 0;
      }
      uint64_t v43 = &v42[2 * v38];
      int64_t v44 = &v42[2 * v41];
      _WORD *v43 = v10;
      unint64_t v9 = v43 + 1;
      if (v12 != v13)
      {
        unint64_t v52 = v12 - v13 - 2;
        if (v52 < 0x1E) {
          goto LABEL_78;
        }
        if (v12 - v42 - (v37 & 0xFFFFFFFFFFFFFFFELL) < 0x20) {
          goto LABEL_78;
        }
        uint64_t v53 = (v52 >> 1) + 1;
        char v54 = &v42[2 * v38 - 16];
        uint64_t v55 = v12 - 16;
        unint64_t v56 = v53 & 0xFFFFFFFFFFFFFFF0;
        do
        {
          long long v57 = *(_OWORD *)v55;
          *(v54 - 1) = *((_OWORD *)v55 - 1);
          *char v54 = v57;
          v54 -= 2;
          v55 -= 32;
          v56 -= 16;
        }
        while (v56);
        v43 -= v53 & 0xFFFFFFFFFFFFFFF0;
        v12 -= 2 * (v53 & 0xFFFFFFFFFFFFFFF0);
        if (v53 != (v53 & 0xFFFFFFFFFFFFFFF0))
        {
LABEL_78:
          do
          {
            __int16 v58 = *((_WORD *)v12 - 1);
            v12 -= 2;
            *--uint64_t v43 = v58;
          }
          while (v12 != v13);
          goto LABEL_68;
        }
LABEL_70:
        *(void *)(a1 + 112) = v43;
        *(void *)(a1 + 120) = v9;
        *(void *)(a1 + 128) = v44;
        if (v13) {
          operator delete(v13);
        }
        goto LABEL_72;
      }
LABEL_69:
      unint64_t v13 = v12;
      goto LABEL_70;
    }
    *(_WORD *)unint64_t v12 = v10;
    unint64_t v9 = v12 + 2;
    goto LABEL_72;
  }
  unsigned __int8 v5 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), a2);
  __int16 v6 = v5 | (unsigned __int16)((*(unsigned __int16 (**)(void, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), a3) << 8);
  char v8 = *(char **)(a1 + 120);
  unint64_t v7 = *(void *)(a1 + 128);
  if ((unint64_t)v8 < v7)
  {
    *(_WORD *)char v8 = v6;
    unint64_t v9 = v8 + 2;
LABEL_72:
    *(void *)(a1 + 120) = v9;
    return;
  }
  unint64_t v20 = *(char **)(a1 + 112);
  uint64_t v21 = v8 - v20;
  if (v8 - v20 <= -3) {
LABEL_73:
  }
    abort();
  uint64_t v22 = v21 >> 1;
  unint64_t v23 = v7 - (void)v20;
  if (v23 <= (v21 >> 1) + 1) {
    unint64_t v24 = v22 + 1;
  }
  else {
    unint64_t v24 = v23;
  }
  if (v23 >= 0x7FFFFFFFFFFFFFFELL) {
    uint64_t v25 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    uint64_t v25 = v24;
  }
  if (!v25)
  {
    unint64_t v26 = 0;
    goto LABEL_29;
  }
  if (v25 < 0) {
LABEL_74:
  }
    sub_2153E6200();
  unint64_t v26 = operator new(2 * v25);
LABEL_29:
  uint64_t v27 = &v26[2 * v22];
  unint64_t v28 = &v26[2 * v25];
  _WORD *v27 = v6;
  unint64_t v29 = v27 + 1;
  if (v8 == v20)
  {
    unint64_t v20 = v8;
  }
  else
  {
    unint64_t v30 = v8 - v20 - 2;
    if (v30 < 0x1E) {
      goto LABEL_79;
    }
    if (v8 - v26 - (v21 & 0xFFFFFFFFFFFFFFFELL) < 0x20) {
      goto LABEL_79;
    }
    uint64_t v31 = (v30 >> 1) + 1;
    size_t v32 = &v26[2 * v22 - 16];
    unint64_t v33 = v8 - 16;
    unint64_t v34 = v31 & 0xFFFFFFFFFFFFFFF0;
    do
    {
      long long v35 = *(_OWORD *)v33;
      *(v32 - 1) = *((_OWORD *)v33 - 1);
      *size_t v32 = v35;
      v32 -= 2;
      v33 -= 32;
      v34 -= 16;
    }
    while (v34);
    v27 -= v31 & 0xFFFFFFFFFFFFFFF0;
    v8 -= 2 * (v31 & 0xFFFFFFFFFFFFFFF0);
    if (v31 != (v31 & 0xFFFFFFFFFFFFFFF0))
    {
LABEL_79:
      do
      {
        __int16 v36 = *((_WORD *)v8 - 1);
        v8 -= 2;
        *--uint64_t v27 = v36;
      }
      while (v8 != v20);
      unint64_t v20 = *(char **)(a1 + 112);
    }
  }
  *(void *)(a1 + 112) = v27;
  *(void *)(a1 + 120) = v29;
  *(void *)(a1 + 128) = v28;
  if (v20) {
    operator delete(v20);
  }
  *(void *)(a1 + 120) = v29;
}

void sub_215417894(uint64_t a1, uint64_t a2, char *a3, char *a4)
{
  unint64_t v4 = a4 - a3;
  if ((unint64_t)(a4 - a3) >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  __int16 v6 = a3;
  if (v4 <= 0x16)
  {
    HIBYTE(v22) = (_BYTE)a4 - (_BYTE)a3;
    CFStringRef p_p = &__p;
    if (a3 == a4) {
      goto LABEL_18;
    }
LABEL_8:
    if (v4 < 0x20 || (unint64_t)(p_p - v6) < 0x20)
    {
      unint64_t v12 = p_p;
    }
    else
    {
      unint64_t v11 = v4 & 0xFFFFFFFFFFFFFFE0;
      unint64_t v12 = &p_p[v4 & 0xFFFFFFFFFFFFFFE0];
      unint64_t v13 = (long long *)(v6 + 16);
      uint64_t v14 = p_p + 16;
      unint64_t v15 = v4 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        long long v16 = *v13;
        *(v14 - 1) = *(v13 - 1);
        _OWORD *v14 = v16;
        v13 += 2;
        v14 += 2;
        v15 -= 32;
      }
      while (v15);
      if (v4 == v11)
      {
        p_p += v4 & 0xFFFFFFFFFFFFFFE0;
        goto LABEL_18;
      }
      v6 += v11;
    }
    CFStringRef p_p = v12;
    do
    {
      char v17 = *v6++;
      *p_p++ = v17;
    }
    while (v6 != a4);
    goto LABEL_18;
  }
  uint64_t v9 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
  if ((v4 | 7) != 0x17) {
    uint64_t v9 = v4 | 7;
  }
  uint64_t v10 = v9 + 1;
  CFStringRef p_p = operator new(v9 + 1);
  unint64_t v21 = v4;
  int64_t v22 = v10 | 0x8000000000000000;
  long long __p = p_p;
  if (v6 != a4) {
    goto LABEL_8;
  }
LABEL_18:
  *CFStringRef p_p = 0;
  unint64_t v18 = HIBYTE(v22);
  if (v22 >= 0) {
    unint64_t v19 = (char *)&__p;
  }
  else {
    unint64_t v19 = (char *)__p;
  }
  if (v22 < 0) {
    unint64_t v18 = v21;
  }
  (*(void (**)(void, char *, char *))(**(void **)(a2 + 16) + 32))(*(void *)(a2 + 16), v19, &v19[v18]);
  if (SHIBYTE(v22) < 0) {
    operator delete(__p);
  }
}

char *sub_215417A0C(void **a1, uint64_t a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a1[1] - (unsigned char *)*a1) >> 4);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0x555555555555555) {
    abort();
  }
  if (0x5555555555555556 * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 4) > v3) {
    unint64_t v3 = 0x5555555555555556 * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 4);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v6 = 0x555555555555555;
  }
  else {
    unint64_t v6 = v3;
  }
  if (v6)
  {
    if (v6 > 0x555555555555555) {
      sub_2153E6200();
    }
    unint64_t v7 = (char *)operator new(48 * v6);
  }
  else
  {
    unint64_t v7 = 0;
  }
  char v8 = &v7[48 * v2];
  *((void *)v8 + 2) = *(void *)(a2 + 16);
  *(_OWORD *)char v8 = *(_OWORD *)a2;
  uint64_t v9 = &v7[48 * v6];
  long long v10 = *(_OWORD *)(a2 + 24);
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(_OWORD *)(v8 + 24) = v10;
  *((void *)v8 + 5) = *(void *)(a2 + 40);
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  unint64_t v11 = v8 + 48;
  unint64_t v12 = (void **)*a1;
  unint64_t v13 = (void **)a1[1];
  if (v13 != *a1)
  {
    do
    {
      long long v14 = *((_OWORD *)v13 - 3);
      *((void *)v8 - 4) = *(v13 - 4);
      *((_OWORD *)v8 - 3) = v14;
      *(v13 - 5) = 0;
      *(v13 - 4) = 0;
      *(v13 - 6) = 0;
      long long v15 = *(_OWORD *)(v13 - 3);
      *((void *)v8 - 1) = *(v13 - 1);
      *(_OWORD *)(v8 - 24) = v15;
      v8 -= 48;
      *(v13 - 2) = 0;
      *(v13 - 1) = 0;
      *(v13 - 3) = 0;
      v13 -= 6;
    }
    while (v13 != v12);
    unint64_t v13 = (void **)*a1;
    long long v16 = (void **)a1[1];
    *a1 = v8;
    a1[1] = v11;
    a1[2] = v9;
    while (1)
    {
      if (v16 == v13) {
        goto LABEL_22;
      }
      if (*((char *)v16 - 1) < 0)
      {
        operator delete(*(v16 - 3));
        if ((*((char *)v16 - 25) & 0x80000000) == 0) {
          goto LABEL_14;
        }
      }
      else if ((*((char *)v16 - 25) & 0x80000000) == 0)
      {
        goto LABEL_14;
      }
      operator delete(*(v16 - 6));
LABEL_14:
      v16 -= 6;
    }
  }
  *a1 = v8;
  a1[1] = v11;
  a1[2] = v9;
LABEL_22:
  if (v13) {
    operator delete(v13);
  }
  return v11;
}

void sub_215417BA8(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 24);
  if ((v1 & 1) == 0)
  {
    if ((v1 & 8) == 0) {
      operator new();
    }
    operator new();
  }
  operator new();
}

uint64_t sub_215417D14(uint64_t result, uint64_t a2)
{
  unint64_t v2 = *(unsigned __int8 **)(a2 + 16);
  if (v2 == *(unsigned __int8 **)(a2 + 24) || *v2 != *(unsigned __int8 *)(result + 16))
  {
    *(_DWORD *)a2 = -993;
    *(void *)(a2 + 80) = 0;
  }
  else
  {
    *(_DWORD *)a2 = -995;
    *(void *)(a2 + 16) = v2 + 1;
    *(void *)(a2 + 80) = *(void *)(result + 8);
  }
  return result;
}

void sub_215417D5C(void *a1)
{
  *a1 = &unk_26C5FC170;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  JUMPOUT(0x2166B9890);
}

void *sub_215417DE8(void *a1)
{
  *a1 = &unk_26C5FC170;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

uint64_t sub_215417E54(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 **)(a2 + 16);
  if (v2 == *(unsigned __int8 **)(a2 + 24) || *v2 != *(unsigned __int8 *)(result + 40))
  {
    *(_DWORD *)a2 = -993;
    *(void *)(a2 + 80) = 0;
  }
  else
  {
    *(_DWORD *)a2 = -995;
    *(void *)(a2 + 16) = v2 + 1;
    *(void *)(a2 + 80) = *(void *)(result + 8);
  }
  return result;
}

void sub_215417E9C(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_26C5FC2C0;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&unk_26C5FC170;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  JUMPOUT(0x2166B9890);
}

std::locale *sub_215417F48(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_26C5FC2C0;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&unk_26C5FC170;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  return a1;
}

uint64_t sub_215417FD4(uint64_t result, uint64_t a2)
{
  unint64_t v3 = *(char **)(a2 + 16);
  if (v3 == *(char **)(a2 + 24)
    || (uint64_t v4 = result,
        float result = (*(uint64_t (**)(void, void))(**(void **)(result + 24) + 40))(*(void *)(result + 24), *v3), *(unsigned __int8 *)(v4 + 40) != result))
  {
    uint64_t v5 = 0;
    *(_DWORD *)a2 = -993;
  }
  else
  {
    *(_DWORD *)a2 = -995;
    ++*(void *)(a2 + 16);
    uint64_t v5 = *(void *)(v4 + 8);
  }
  *(void *)(a2 + 80) = v5;
  return result;
}

void sub_215418068(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_26C5FC230;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&unk_26C5FC170;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  JUMPOUT(0x2166B9890);
}

std::locale *sub_215418114(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_26C5FC230;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&unk_26C5FC170;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  return a1;
}

char *sub_21541857C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void ***)a1;
  unint64_t v3 = *(void ***)(a1 + 8);
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v3 - *(void *)a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * ((uint64_t)(*(void *)(a1 + 16) - (void)v2) >> 3) > v5) {
    unint64_t v5 = 0x5555555555555556 * ((uint64_t)(*(void *)(a1 + 16) - (void)v2) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 16) - (void)v2) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v5;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      sub_2153E6200();
    }
    uint64_t v9 = (char *)operator new(24 * v8);
  }
  else
  {
    uint64_t v9 = 0;
  }
  long long v10 = &v9[24 * v4];
  if (*(char *)(a2 + 23) < 0)
  {
    sub_2153C0AE4(v10, *(void **)a2, *(void *)(a2 + 8));
    uint64_t v2 = *(void ***)a1;
    unint64_t v3 = *(void ***)(a1 + 8);
  }
  else
  {
    *(_OWORD *)long long v10 = *(_OWORD *)a2;
    *((void *)v10 + 2) = *(void *)(a2 + 16);
  }
  unint64_t v11 = &v9[24 * v8];
  unint64_t v12 = v10 + 24;
  if (v3 == v2)
  {
    *(void *)a1 = v10;
    *(void *)(a1 + 8) = v12;
    *(void *)(a1 + 16) = v11;
  }
  else
  {
    do
    {
      long long v13 = *(_OWORD *)(v3 - 3);
      *((void *)v10 - 1) = *(v3 - 1);
      *(_OWORD *)(v10 - 24) = v13;
      v10 -= 24;
      *(v3 - 2) = 0;
      *(v3 - 1) = 0;
      *(v3 - 3) = 0;
      v3 -= 3;
    }
    while (v3 != v2);
    uint64_t v2 = *(void ***)a1;
    long long v14 = *(void ***)(a1 + 8);
    *(void *)a1 = v10;
    *(void *)(a1 + 8) = v12;
    *(void *)(a1 + 16) = v11;
    while (v14 != v2)
    {
      if (*((char *)v14 - 1) < 0) {
        operator delete(*(v14 - 3));
      }
      v14 -= 3;
    }
  }
  if (v2) {
    operator delete(v2);
  }
  return v12;
}

void sub_2154186F4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  unint64_t v4 = *(unsigned __int8 **)(a2 + 16);
  unint64_t v5 = *(unsigned __int8 **)(a2 + 24);
  if (v4 == v5)
  {
    uint64_t v11 = 0;
    int v12 = *(unsigned __int8 *)(a1 + 168);
    goto LABEL_208;
  }
  if (!*(unsigned char *)(a1 + 171) || v4 + 1 == v5) {
    goto LABEL_66;
  }
  unsigned __int8 v6 = *v4;
  __int16 v7 = v4[1];
  if (*(unsigned char *)(a1 + 169))
  {
    unsigned __int8 v6 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), (char)v6);
    __int16 v7 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), (char)v7);
  }
  *((unsigned char *)&__s.__r_.__value_.__s + 23) = 2;
  __int16 v8 = v6 | (unsigned __int16)(v7 << 8);
  LOWORD(__s.__r_.__value_.__l.__data_) = v8;
  __s.__r_.__value_.__s.__data_[2] = 0;
  std::__get_collation_name(&v148, (const char *)&__s);
  std::string __p = v148;
  std::string::size_type size = HIBYTE(v148.__r_.__value_.__r.__words[2]);
  int v10 = SHIBYTE(v148.__r_.__value_.__r.__words[2]);
  if ((v148.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = v148.__r_.__value_.__l.__size_;
  }
  if (size) {
    goto LABEL_9;
  }
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
  {
    if (__s.__r_.__value_.__l.__size_ >= 3) {
      goto LABEL_9;
    }
  }
  else if (HIBYTE(__s.__r_.__value_.__r.__words[2]) >= 3u)
  {
    goto LABEL_14;
  }
  (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 32) + 32))(&v148);
  if (v10 < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  std::string __p = v148;
  if ((SHIBYTE(v148.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (HIBYTE(v148.__r_.__value_.__r.__words[2]) != 12 && HIBYTE(v148.__r_.__value_.__r.__words[2]) != 1)
    {
      __p.__r_.__value_.__s.__data_[0] = 0;
      *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
      goto LABEL_9;
    }
    goto LABEL_153;
  }
  if (__p.__r_.__value_.__l.__size_ == 1 || __p.__r_.__value_.__l.__size_ == 12)
  {
LABEL_153:
    std::string::operator=(&__p, &__s);
    goto LABEL_9;
  }
  *__p.__r_.__value_.__l.__data_ = 0;
  __p.__r_.__value_.__l.__size_ = 0;
LABEL_9:
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__s.__r_.__value_.__l.__data_);
  }
LABEL_14:
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (*((unsigned char *)&__p.__r_.__value_.__s + 23)) {
      goto LABEL_16;
    }
LABEL_66:
    int v39 = 0;
    uint64_t v11 = 1;
    goto LABEL_67;
  }
  std::string::size_type v41 = __p.__r_.__value_.__l.__size_;
  operator delete(__p.__r_.__value_.__l.__data_);
  if (!v41) {
    goto LABEL_66;
  }
LABEL_16:
  uint64_t v13 = *(void *)(a1 + 112);
  uint64_t v14 = *(void *)(a1 + 120) - v13;
  if (v14)
  {
    unint64_t v15 = v14 >> 1;
    if (v15 <= 1) {
      unint64_t v15 = 1;
    }
    long long v16 = (unsigned __int8 *)(v13 + 1);
    while (*(v16 - 1) != v6 || *v16 != v7)
    {
      v16 += 2;
      if (!--v15) {
        goto LABEL_24;
      }
    }
LABEL_289:
    int v12 = 1;
    uint64_t v11 = 2;
    goto LABEL_208;
  }
LABEL_24:
  if (!*(unsigned char *)(a1 + 170) || *(void *)(a1 + 88) == *(void *)(a1 + 96))
  {
    int v39 = 0;
    goto LABEL_160;
  }
  *((unsigned char *)&__s.__r_.__value_.__s + 23) = 2;
  __s.__r_.__value_.__s.__data_[0] = v6;
  __s.__r_.__value_.__s.__data_[1] = v7;
  __s.__r_.__value_.__s.__data_[2] = 0;
  (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 32) + 32))(&v148);
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__s.__r_.__value_.__l.__data_);
  }
  uint64_t v17 = *(void *)(a1 + 88);
  char v18 = HIBYTE(v148.__r_.__value_.__r.__words[2]);
  uint64_t v19 = *(void *)(a1 + 96) - v17;
  if (v19)
  {
    __int16 v140 = v6 | (unsigned __int16)(v7 << 8);
    char v132 = HIBYTE(v148.__r_.__value_.__r.__words[2]);
    unsigned __int8 v136 = v6;
    char v143 = v7;
    uint64_t v20 = 0;
    unint64_t v21 = v19 / 48;
    if ((v148.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v22 = HIBYTE(v148.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v22 = v148.__r_.__value_.__l.__size_;
    }
    if ((v148.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unint64_t v23 = &v148;
    }
    else {
      unint64_t v23 = (std::string *)v148.__r_.__value_.__r.__words[0];
    }
    if (v21 <= 1) {
      uint64_t v24 = 1;
    }
    else {
      uint64_t v24 = v19 / 48;
    }
    uint64_t v25 = (unsigned __int8 *)(v17 + 47);
    BOOL v26 = 1;
    do
    {
      int v27 = (char)*(v25 - 24);
      if (v27 >= 0) {
        size_t v28 = *(v25 - 24);
      }
      else {
        size_t v28 = *(void *)(v25 - 39);
      }
      if (v27 >= 0) {
        unint64_t v29 = (char *)(v25 - 47);
      }
      else {
        unint64_t v29 = *(char **)(v25 - 47);
      }
      if (v28 >= v22) {
        size_t v30 = v22;
      }
      else {
        size_t v30 = v28;
      }
      int v31 = memcmp(v23, v29, v30);
      BOOL v32 = v22 >= v28;
      if (v31) {
        BOOL v32 = v31 >= 0;
      }
      if (v32)
      {
        int v33 = (char)*v25;
        if (v33 >= 0) {
          size_t v34 = *v25;
        }
        else {
          size_t v34 = *(void *)(v25 - 15);
        }
        if (v33 >= 0) {
          long long v35 = (char *)(v25 - 23);
        }
        else {
          long long v35 = *(char **)(v25 - 23);
        }
        if (v22 >= v34) {
          size_t v36 = v34;
        }
        else {
          size_t v36 = v22;
        }
        int v37 = memcmp(v35, v23, v36);
        BOOL v38 = v34 >= v22;
        if (v37) {
          BOOL v38 = v37 >= 0;
        }
        if (v38)
        {
          int v39 = 1;
          int v40 = 5;
          goto LABEL_155;
        }
      }
      BOOL v26 = ++v20 < v21;
      v25 += 48;
    }
    while (v24 != v20);
    int v40 = 0;
    int v39 = 0;
LABEL_155:
    LOBYTE(v7) = v143;
    char v18 = v132;
    unsigned __int8 v6 = v136;
    __int16 v8 = v140;
  }
  else
  {
    BOOL v26 = 0;
    int v40 = 0;
    int v39 = 0;
  }
  if (v18 < 0) {
    operator delete(v148.__r_.__value_.__l.__data_);
  }
  if (!v26)
  {
LABEL_160:
    if (*(void *)(a1 + 136) == *(void *)(a1 + 144)) {
      goto LABEL_270;
    }
    *((unsigned char *)&__s.__r_.__value_.__s + 23) = 2;
    LOWORD(__s.__r_.__value_.__l.__data_) = v8;
    __s.__r_.__value_.__s.__data_[2] = 0;
    (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 32) + 32))(&v148);
    std::string::size_type v76 = HIBYTE(v148.__r_.__value_.__r.__words[2]);
    if ((v148.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v76 = v148.__r_.__value_.__l.__size_;
    }
    if (v76 != 1)
    {
      if (v76 == 12)
      {
        uint64_t v77 = &v148;
        if ((v148.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          uint64_t v77 = (std::string *)v148.__r_.__value_.__r.__words[0];
        }
        v77->__r_.__value_.__s.__data_[11] = v77->__r_.__value_.__s.__data_[3];
      }
      else if (SHIBYTE(v148.__r_.__value_.__r.__words[2]) < 0)
      {
        *v148.__r_.__value_.__l.__data_ = 0;
        v148.__r_.__value_.__l.__size_ = 0;
      }
      else
      {
        v148.__r_.__value_.__s.__data_[0] = 0;
        *((unsigned char *)&v148.__r_.__value_.__s + 23) = 0;
      }
    }
    if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__s.__r_.__value_.__l.__data_);
    }
    uint64_t v98 = *(void *)(a1 + 136);
    int v99 = SHIBYTE(v148.__r_.__value_.__r.__words[2]);
    uint64_t v100 = *(void *)(a1 + 144) - v98;
    if (v100)
    {
      unint64_t v101 = v100 / 24;
      std::string::size_type v102 = v148.__r_.__value_.__l.__size_;
      if ((v148.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v103 = HIBYTE(v148.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v103 = v148.__r_.__value_.__l.__size_;
      }
      if (SHIBYTE(v148.__r_.__value_.__r.__words[2]) < 0)
      {
        int v135 = SHIBYTE(v148.__r_.__value_.__r.__words[2]);
        unsigned __int8 v139 = v6;
        char v146 = v7;
        int v142 = v39;
        uint64_t v112 = 0;
        uint64_t v113 = (const void *)v148.__r_.__value_.__r.__words[0];
        if (v101 <= 1) {
          uint64_t v114 = 1;
        }
        else {
          uint64_t v114 = v100 / 24;
        }
        BOOL v106 = 1;
        do
        {
          uint64_t v115 = *(unsigned __int8 *)(v98 + 23);
          int v116 = (char)v115;
          if ((v115 & 0x80u) != 0) {
            uint64_t v115 = *(void *)(v98 + 8);
          }
          if (v103 == v115)
          {
            unint64_t v117 = v101;
            v118 = v116 >= 0 ? (const void *)v98 : *(const void **)v98;
            int v119 = memcmp(v113, v118, v102);
            unint64_t v101 = v117;
            if (!v119)
            {
              int v39 = 1;
              int v40 = 5;
              goto LABEL_251;
            }
          }
          BOOL v106 = ++v112 < v101;
          v98 += 24;
        }
        while (v114 != v112);
        int v40 = 0;
        int v39 = v142;
LABEL_251:
        LOBYTE(v7) = v146;
        int v99 = v135;
        unsigned __int8 v6 = v139;
LABEL_265:
        if (v99 < 0) {
          operator delete(v148.__r_.__value_.__l.__data_);
        }
        if (v106) {
          goto LABEL_268;
        }
LABEL_270:
        if ((v6 & 0x80) != 0)
        {
          int v131 = *(_DWORD *)(a1 + 164);
        }
        else
        {
          int v128 = *(_DWORD *)(a1 + 160);
          uint64_t v129 = *(void *)(*(void *)(a1 + 24) + 16);
          int v130 = *(_DWORD *)(v129 + 4 * v6);
          if (((v130 & v128) != 0 || v6 == 95 && (v128 & 0x80) != 0)
            && (v7 & 0x80) == 0
            && ((*(_DWORD *)(v129 + 4 * v7) & v128) != 0
             || (v128 & 0x80) != 0 && v7 == 95))
          {
            goto LABEL_289;
          }
          int v131 = *(_DWORD *)(a1 + 164);
          if ((v130 & v131) != 0 || v6 == 95 && (v131 & 0x80) != 0) {
            goto LABEL_287;
          }
        }
        if ((v7 & 0x80) != 0) {
          goto LABEL_289;
        }
        if ((*(_DWORD *)(*(void *)(*(void *)(a1 + 24) + 16) + 4 * v7) & v131) == 0)
        {
          int v12 = 1;
          if (v7 != 95 || (v131 & 0x80) == 0)
          {
LABEL_288:
            uint64_t v11 = 2;
            goto LABEL_208;
          }
        }
LABEL_287:
        int v12 = v39;
        goto LABEL_288;
      }
      if (*((unsigned char *)&v148.__r_.__value_.__s + 23))
      {
        uint64_t v104 = 0;
        if (v101 <= 1) {
          uint64_t v105 = 1;
        }
        else {
          uint64_t v105 = v100 / 24;
        }
        BOOL v106 = 1;
        do
        {
          v107 = (unsigned __int8 *)(v98 + 24 * v104);
          uint64_t v108 = v107[23];
          int v109 = (char)v108;
          if ((v108 & 0x80u) != 0) {
            uint64_t v108 = *((void *)v107 + 1);
          }
          if (v103 == v108)
          {
            if (v109 < 0) {
              v107 = *(unsigned __int8 **)v107;
            }
            uint64_t v110 = &v148;
            uint64_t v111 = HIBYTE(v148.__r_.__value_.__r.__words[2]);
            while (v110->__r_.__value_.__s.__data_[0] == *v107)
            {
              uint64_t v110 = (std::string *)((char *)v110 + 1);
              ++v107;
              if (!--v111) {
                goto LABEL_236;
              }
            }
          }
          BOOL v106 = ++v104 < v101;
        }
        while (v104 != v105);
      }
      else
      {
        uint64_t v120 = *(unsigned __int8 *)(v98 + 23);
        if ((v120 & 0x80u) != 0) {
          uint64_t v120 = *(void *)(v98 + 8);
        }
        if (v120 == HIBYTE(v148.__r_.__value_.__r.__words[2])) {
          goto LABEL_289;
        }
        unint64_t v121 = 0;
        if (v101 <= 1) {
          uint64_t v122 = 1;
        }
        else {
          uint64_t v122 = v101;
        }
        uint64_t v123 = v122 - 1;
        uint64_t v124 = (uint64_t *)(v98 + 32);
        while (v123 != v121)
        {
          ++v121;
          uint64_t v125 = *((unsigned __int8 *)v124 + 15);
          uint64_t v127 = *v124;
          v124 += 3;
          uint64_t v126 = v127;
          if ((v125 & 0x80u) != 0) {
            uint64_t v125 = v126;
          }
          if (v103 == v125)
          {
            BOOL v106 = v121 < v101;
LABEL_236:
            int v39 = 1;
            int v40 = 5;
            goto LABEL_265;
          }
        }
      }
    }
    BOOL v106 = 0;
    int v40 = 0;
    goto LABEL_265;
  }
LABEL_268:
  if (v40) {
    goto LABEL_287;
  }
  uint64_t v11 = 2;
LABEL_67:
  unsigned __int8 v42 = **(unsigned char **)(v2 + 16);
  if (*(unsigned char *)(a1 + 169)) {
    unsigned __int8 v42 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), (char)v42);
  }
  uint64_t v43 = *(unsigned __int8 **)(a1 + 40);
  unint64_t v44 = *(void *)(a1 + 48) - (void)v43;
  if (v44)
  {
    if (v44 <= 1) {
      unint64_t v44 = 1;
    }
    while (1)
    {
      int v45 = *v43++;
      if (v45 == v42) {
        break;
      }
      if (!--v44) {
        goto LABEL_74;
      }
    }
LABEL_206:
    int v39 = 1;
    goto LABEL_207;
  }
LABEL_74:
  unsigned int v46 = *(_DWORD *)(a1 + 164);
  if (v46 || *(void *)(a1 + 64) != *(void *)(a1 + 72))
  {
    if ((v42 & 0x80) != 0 || (*(_DWORD *)(*(void *)(*(void *)(a1 + 24) + 16) + 4 * v42) & v46) == 0) {
      int v47 = (v42 == 95) & (v46 >> 7);
    }
    else {
      LOBYTE(v47) = 1;
    }
    unint64_t v48 = *(void **)(a1 + 72);
    unint64_t v49 = memchr(*(void **)(a1 + 64), (char)v42, (size_t)v48 - *(void *)(a1 + 64));
    long long v50 = v49 ? v49 : v48;
    if ((v47 & 1) == 0 && v50 == v48) {
      goto LABEL_206;
    }
  }
  uint64_t v51 = *(void *)(a1 + 88);
  uint64_t v52 = *(void *)(a1 + 96);
  if (v51 != v52)
  {
    int v141 = v39;
    if (*(unsigned char *)(a1 + 170))
    {
      *((unsigned char *)&__s.__r_.__value_.__s + 23) = 1;
      LOWORD(__s.__r_.__value_.__l.__data_) = v42;
      (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 32) + 32))(&v148);
      if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__s.__r_.__value_.__l.__data_);
      }
      uint64_t v51 = *(void *)(a1 + 88);
      unsigned int v53 = HIBYTE(v148.__r_.__value_.__r.__words[2]);
      uint64_t v54 = *(void *)(a1 + 96) - v51;
      if (v54) {
        goto LABEL_90;
      }
    }
    else
    {
      unsigned int v53 = 1;
      *((unsigned char *)&v148.__r_.__value_.__s + 23) = 1;
      LOWORD(v148.__r_.__value_.__l.__data_) = v42;
      uint64_t v54 = v52 - v51;
      if (v54)
      {
LABEL_90:
        uint64_t v144 = v11;
        uint64_t v137 = v2;
        uint64_t v55 = 0;
        unint64_t v56 = v54 / 48;
        char v133 = v53;
        if ((v53 & 0x80u) == 0) {
          std::string::size_type v57 = v53;
        }
        else {
          std::string::size_type v57 = v148.__r_.__value_.__l.__size_;
        }
        if ((v53 & 0x80u) == 0) {
          __int16 v58 = &v148;
        }
        else {
          __int16 v58 = (std::string *)v148.__r_.__value_.__r.__words[0];
        }
        if (v56 <= 1) {
          uint64_t v59 = 1;
        }
        else {
          uint64_t v59 = v54 / 48;
        }
        size_t v60 = (unsigned __int8 *)(v51 + 47);
        BOOL v61 = 1;
        do
        {
          int v62 = (char)*(v60 - 24);
          if (v62 >= 0) {
            size_t v63 = *(v60 - 24);
          }
          else {
            size_t v63 = *(void *)(v60 - 39);
          }
          if (v62 >= 0) {
            uint64_t v64 = (char *)(v60 - 47);
          }
          else {
            uint64_t v64 = *(char **)(v60 - 47);
          }
          if (v63 >= v57) {
            size_t v65 = v57;
          }
          else {
            size_t v65 = v63;
          }
          int v66 = memcmp(v58, v64, v65);
          BOOL v67 = v57 >= v63;
          if (v66) {
            BOOL v67 = v66 >= 0;
          }
          if (v67)
          {
            int v68 = (char)*v60;
            if (v68 >= 0) {
              size_t v69 = *v60;
            }
            else {
              size_t v69 = *(void *)(v60 - 15);
            }
            if (v68 >= 0) {
              long long v70 = (char *)(v60 - 23);
            }
            else {
              long long v70 = *(char **)(v60 - 23);
            }
            if (v57 >= v69) {
              size_t v71 = v69;
            }
            else {
              size_t v71 = v57;
            }
            int v72 = memcmp(v70, v58, v71);
            BOOL v73 = v69 >= v57;
            if (v72) {
              BOOL v73 = v72 >= 0;
            }
            if (v73)
            {
              int v39 = 1;
              uint64_t v2 = v137;
              goto LABEL_128;
            }
          }
          BOOL v61 = ++v55 < v56;
          v60 += 48;
        }
        while (v59 != v55);
        uint64_t v2 = v137;
        int v39 = v141;
LABEL_128:
        uint64_t v11 = v144;
        if ((v133 & 0x80) == 0) {
          goto LABEL_130;
        }
        goto LABEL_129;
      }
    }
    BOOL v61 = 0;
    if ((v53 & 0x80) == 0)
    {
LABEL_130:
      if (v61) {
        goto LABEL_207;
      }
      goto LABEL_131;
    }
LABEL_129:
    operator delete(v148.__r_.__value_.__l.__data_);
    goto LABEL_130;
  }
LABEL_131:
  if (*(void *)(a1 + 136) == *(void *)(a1 + 144)) {
    goto LABEL_201;
  }
  *((unsigned char *)&__s.__r_.__value_.__s + 23) = 1;
  LOWORD(__s.__r_.__value_.__l.__data_) = v42;
  (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 32) + 32))(&v148);
  std::string::size_type v74 = HIBYTE(v148.__r_.__value_.__r.__words[2]);
  if ((v148.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v74 = v148.__r_.__value_.__l.__size_;
  }
  if (v74 != 1)
  {
    if (v74 == 12)
    {
      uint64_t v75 = &v148;
      if ((v148.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        uint64_t v75 = (std::string *)v148.__r_.__value_.__r.__words[0];
      }
      v75->__r_.__value_.__s.__data_[11] = v75->__r_.__value_.__s.__data_[3];
    }
    else if (SHIBYTE(v148.__r_.__value_.__r.__words[2]) < 0)
    {
      *v148.__r_.__value_.__l.__data_ = 0;
      v148.__r_.__value_.__l.__size_ = 0;
    }
    else
    {
      v148.__r_.__value_.__s.__data_[0] = 0;
      *((unsigned char *)&v148.__r_.__value_.__s + 23) = 0;
    }
  }
  uint64_t v145 = v11;
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__s.__r_.__value_.__l.__data_);
  }
  uint64_t v78 = *(void *)(a1 + 136);
  uint64_t v79 = HIBYTE(v148.__r_.__value_.__r.__words[2]);
  uint64_t v80 = *(void *)(a1 + 144) - v78;
  if (!v80)
  {
    if ((*((unsigned char *)&v148.__r_.__value_.__s + 23) & 0x80) != 0) {
      operator delete(v148.__r_.__value_.__l.__data_);
    }
    uint64_t v11 = v145;
LABEL_201:
    if ((v42 & 0x80) != 0) {
      goto LABEL_207;
    }
    unsigned int v94 = *(_DWORD *)(a1 + 160);
    if ((*(_DWORD *)(*(void *)(*(void *)(a1 + 24) + 16) + 4 * v42) & v94) == 0)
    {
      int v95 = (v94 >> 7) & 1;
      if (v42 != 95) {
        int v95 = 0;
      }
      if (v95 != 1) {
        goto LABEL_207;
      }
    }
    goto LABEL_206;
  }
  uint64_t v81 = 0;
  unint64_t v82 = v80 / 24;
  long long v83 = *(_OWORD *)&v148.__r_.__value_.__l.__data_;
  if ((v148.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v84 = HIBYTE(v148.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v84 = v148.__r_.__value_.__l.__size_;
  }
  if (v82 <= 1) {
    uint64_t v85 = 1;
  }
  else {
    uint64_t v85 = v80 / 24;
  }
  BOOL v86 = 1;
  while (1)
  {
    uint64_t v88 = v78 + 24 * v81;
    uint64_t v89 = *(unsigned __int8 *)(v88 + 23);
    int v90 = (char)v89;
    if ((v89 & 0x80u) != 0) {
      uint64_t v89 = *(void *)(v88 + 8);
    }
    if (v84 != v89) {
      goto LABEL_182;
    }
    uint64_t v91 = v90 >= 0 ? (unsigned __int8 *)(v78 + 24 * v81) : *(unsigned __int8 **)v88;
    if ((v79 & 0x80) == 0) {
      break;
    }
    uint64_t v134 = v85;
    unint64_t v138 = v82;
    int v87 = memcmp((const void *)v83, v91, *((size_t *)&v83 + 1));
    uint64_t v85 = v134;
    unint64_t v82 = v138;
    if (!v87)
    {
      int v39 = 1;
      uint64_t v11 = v145;
      goto LABEL_195;
    }
LABEL_182:
    BOOL v86 = ++v81 < v82;
    if (v81 == v85)
    {
      uint64_t v11 = v145;
      if ((v79 & 0x80) == 0)
      {
LABEL_196:
        if (!v86) {
          goto LABEL_201;
        }
        goto LABEL_207;
      }
LABEL_195:
      operator delete(v148.__r_.__value_.__l.__data_);
      goto LABEL_196;
    }
  }
  if (v79)
  {
    long long v92 = &v148;
    uint64_t v93 = v79;
    while (v92->__r_.__value_.__s.__data_[0] == *v91)
    {
      long long v92 = (std::string *)((char *)v92 + 1);
      ++v91;
      if (!--v93)
      {
        int v39 = 1;
        uint64_t v11 = v145;
        if ((v79 & 0x80) == 0) {
          goto LABEL_196;
        }
        goto LABEL_195;
      }
    }
    goto LABEL_182;
  }
  int v39 = 1;
  uint64_t v11 = v145;
  if (!v86) {
    goto LABEL_201;
  }
LABEL_207:
  int v12 = v39;
LABEL_208:
  if (v12 == *(unsigned __int8 *)(a1 + 168))
  {
    uint64_t v96 = 0;
    int v97 = -993;
  }
  else
  {
    *(void *)(v2 + 16) += v11;
    uint64_t v96 = *(void *)(a1 + 8);
    int v97 = -995;
  }
  *(_DWORD *)uint64_t v2 = v97;
  *(void *)(v2 + 80) = v96;
}

void sub_2154193DC(std::locale *a1)
{
  sub_215419414(a1);
  JUMPOUT(0x2166B9890);
}

std::locale *sub_215419414(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_26C5FC260;
  locale = a1[17].__locale_;
  if (locale)
  {
    unint64_t v3 = a1[18].__locale_;
    unint64_t v4 = a1[17].__locale_;
    if (v3 != locale)
    {
      do
      {
        if (*((char *)v3 - 1) < 0) {
          operator delete(*((void **)v3 - 3));
        }
        unint64_t v3 = (std::locale::__imp *)((char *)v3 - 24);
      }
      while (v3 != locale);
      unint64_t v4 = a1[17].__locale_;
    }
    a1[18].__locale_ = locale;
    operator delete(v4);
  }
  unint64_t v5 = a1[14].__locale_;
  if (v5)
  {
    a1[15].__locale_ = v5;
    operator delete(v5);
  }
  unsigned __int8 v6 = a1[11].__locale_;
  if (v6)
  {
    __int16 v7 = a1[12].__locale_;
    __int16 v8 = a1[11].__locale_;
    if (v7 == v6)
    {
LABEL_21:
      a1[12].__locale_ = v6;
      operator delete(v8);
      goto LABEL_22;
    }
    while (1)
    {
      if (*((char *)v7 - 1) < 0)
      {
        operator delete(*((void **)v7 - 3));
        if (*((char *)v7 - 25) < 0) {
LABEL_19:
        }
          operator delete(*((void **)v7 - 6));
      }
      else if (*((char *)v7 - 25) < 0)
      {
        goto LABEL_19;
      }
      __int16 v7 = (std::locale::__imp *)((char *)v7 - 48);
      if (v7 == v6)
      {
        __int16 v8 = a1[11].__locale_;
        goto LABEL_21;
      }
    }
  }
LABEL_22:
  uint64_t v9 = a1[8].__locale_;
  if (v9)
  {
    a1[9].__locale_ = v9;
    operator delete(v9);
  }
  int v10 = a1[5].__locale_;
  if (v10)
  {
    a1[6].__locale_ = v10;
    operator delete(v10);
  }
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&unk_26C5FC170;
  uint64_t v11 = a1[1].__locale_;
  if (v11) {
    (*(void (**)(std::locale::__imp *))(*(void *)v11 + 8))(v11);
  }
  return a1;
}

uint64_t sub_21541958C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned char **)(a2 + 16);
  if (v2 == *(unsigned char **)(a2 + 24) || !*v2)
  {
    *(_DWORD *)a2 = -993;
    *(void *)(a2 + 80) = 0;
  }
  else
  {
    *(_DWORD *)a2 = -995;
    *(void *)(a2 + 16) = v2 + 1;
    *(void *)(a2 + 80) = *(void *)(result + 8);
  }
  return result;
}

void sub_2154195CC(void *a1)
{
  *a1 = &unk_26C5FC170;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  JUMPOUT(0x2166B9890);
}

void *sub_215419658(void *a1)
{
  *a1 = &unk_26C5FC170;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

uint64_t sub_2154196C4(uint64_t a1, unsigned __int8 a2)
{
  if (((a2 & 0xF8) == 0x30 || (a2 & 0xFE) == 0x38) && a2 - 49 <= 8)
  {
    if (a2 - 48 <= *(_DWORD *)(a1 + 28)) {
      sub_215419728(a1);
    }
    uint64_t v3 = sub_2154107DC();
    sub_215419728(v3);
  }
  return 0;
}

void sub_215419728(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 24);
  if ((v1 & 1) == 0)
  {
    if ((v1 & 8) == 0) {
      operator new();
    }
    operator new();
  }
  operator new();
}

void sub_215419858(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(unsigned int *)(a1 + 16);
  uint64_t v3 = *(void *)(a2 + 32);
  if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(a2 + 40) - v3) >> 3) < v2)
  {
    uint64_t v11 = (void *)sub_2154107DC();
    sub_215419918(v11);
  }
  else
  {
    unsigned int v5 = v2 - 1;
    if (*(unsigned char *)(v3 + 24 * v5 + 16)
      && (uint64_t v7 = v3 + 24 * v5,
          int64_t v8 = *(void *)(v7 + 8) - *(void *)v7,
          uint64_t v9 = *(void *)(a2 + 16),
          *(void *)(a2 + 24) - v9 >= v8)
      && !memcmp(*(const void **)v7, *(const void **)(a2 + 16), v8))
    {
      *(_DWORD *)a2 = -994;
      *(void *)(a2 + 16) = v9 + v8;
      uint64_t v10 = *(void *)(a1 + 8);
    }
    else
    {
      uint64_t v10 = 0;
      *(_DWORD *)a2 = -993;
    }
    *(void *)(a2 + 80) = v10;
  }
}

void sub_215419918(void *a1)
{
  *a1 = &unk_26C5FC170;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  JUMPOUT(0x2166B9890);
}

void *sub_2154199A4(void *a1)
{
  *a1 = &unk_26C5FC170;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

uint64_t sub_215419A10(uint64_t result, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(result + 40) - 1;
  uint64_t v3 = *(void *)(a2 + 32);
  if (!*(unsigned char *)(v3 + 24 * v2 + 16)
    || (unint64_t v4 = (unsigned __int8 **)(v3 + 24 * v2),
        unsigned int v5 = *v4,
        uint64_t v6 = v4[1] - *v4,
        uint64_t v7 = *(void *)(a2 + 16),
        *(void *)(a2 + 24) - v7 < v6))
  {
LABEL_3:
    *(_DWORD *)a2 = -993;
    *(void *)(a2 + 80) = 0;
    return result;
  }
  if (v6 >= 1)
  {
    uint64_t v8 = v6;
    uint64_t v9 = *(unsigned __int8 **)(a2 + 16);
    do
    {
      int v11 = *v5++;
      int v10 = v11;
      int v12 = *v9++;
      if (v10 != v12) {
        goto LABEL_3;
      }
    }
    while (--v8);
  }
  *(_DWORD *)a2 = -994;
  *(void *)(a2 + 16) = v7 + v6;
  *(void *)(a2 + 80) = *(void *)(result + 8);
  return result;
}

void sub_215419AA0(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_26C5FC200;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&unk_26C5FC170;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  JUMPOUT(0x2166B9890);
}

std::locale *sub_215419B4C(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_26C5FC200;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&unk_26C5FC170;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  return a1;
}

uint64_t sub_215419BD8(uint64_t result, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 32) + 24 * (*(_DWORD *)(result + 40) - 1);
  if (*(unsigned char *)(v3 + 16))
  {
    uint64_t v4 = *(void *)(v3 + 8) - *(void *)v3;
    uint64_t v5 = *(void *)(a2 + 16);
    if (*(void *)(a2 + 24) - v5 >= v4)
    {
      uint64_t v7 = result;
      if (v4 < 1)
      {
LABEL_9:
        *(_DWORD *)a2 = -994;
        *(void *)(a2 + 16) = v5 + v4;
        uint64_t v6 = *(void *)(v7 + 8);
        goto LABEL_10;
      }
      uint64_t v8 = 0;
      while (1)
      {
        int v9 = (*(uint64_t (**)(void, void))(**(void **)(v7 + 24) + 40))(*(void *)(v7 + 24), *(char *)(*(void *)v3 + v8));
        float result = (*(uint64_t (**)(void, void))(**(void **)(v7 + 24) + 40))(*(void *)(v7 + 24), *(char *)(*(void *)(a2 + 16) + v8));
        if (v9 != result) {
          break;
        }
        if (v4 == ++v8)
        {
          uint64_t v5 = *(void *)(a2 + 16);
          goto LABEL_9;
        }
      }
    }
  }
  uint64_t v6 = 0;
  *(_DWORD *)a2 = -993;
LABEL_10:
  *(void *)(a2 + 80) = v6;
  return result;
}

void sub_215419CF0(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_26C5FC140;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&unk_26C5FC170;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  JUMPOUT(0x2166B9890);
}

std::locale *sub_215419D9C(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_26C5FC140;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&unk_26C5FC170;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  return a1;
}

uint64_t sub_215419E28(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (a2 != a3)
  {
    uint64_t v7 = a2 + 1;
    int v6 = *a2;
    if (a2 + 1 != a3 || v6 != 36)
    {
      if ((v6 - 46) > 0x2E || ((1 << (v6 - 46)) & 0x600000000001) == 0) {
        sub_215417BA8(a1);
      }
      if (v7 == a3 || v6 != 92)
      {
        if (v6 == 46) {
          operator new();
        }
      }
      else
      {
        unsigned int v13 = (char)*v7 - 36;
        if (v13 <= 0x3A && ((1 << v13) & 0x580000000000441) != 0) {
          sub_215417BA8(a1);
        }
      }
    }
  }
  uint64_t v8 = sub_215413E80(a1, a2, a3);
  int v9 = v8;
  if (v8 != a2 || v8 == a3) {
    return (uint64_t)v9;
  }
  if (a2 + 1 == a3 || *a2 != 92) {
    return (uint64_t)a2;
  }
  int v10 = a2[1];
  if (v10 == 40)
  {
    uint64_t v11 = (uint64_t)(a2 + 2);
    if ((*(unsigned char *)(a1 + 24) & 2) == 0) {
      operator new();
    }
    do
    {
      if ((unsigned __int8 *)v11 == a3) {
        goto LABEL_38;
      }
      uint64_t v14 = (unsigned char *)v11;
      unint64_t v15 = (unsigned __int8 *)sub_215419E28(a1, v11, a3);
      if (v15 == (unsigned __int8 *)v11) {
        break;
      }
      uint64_t v11 = sub_21541A134(a1, v15, a3);
    }
    while ((unsigned char *)v11 != v14);
    if (v14 + 1 == a3 || *v14 != 92 || v14[1] != 41)
    {
LABEL_38:
      sub_2154107DC();
      goto LABEL_39;
    }
    int v9 = &v14[2 * (v14[1] == 41)];
    if ((*(unsigned char *)(a1 + 24) & 2) == 0) {
      operator new();
    }
    return (uint64_t)v9;
  }
  if ((v10 & 0xF8) != 0x30 && (v10 & 0xFE) != 0x38 || (v10 - 49) > 8) {
    return (uint64_t)a2;
  }
  if ((v10 - 48) <= *(_DWORD *)(a1 + 28)) {
    sub_215419728(a1);
  }
LABEL_39:
  uint64_t v17 = sub_2154107DC();
  return sub_21541A134(v17, v18, v19);
}

uint64_t sub_21541A134(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (a2 == a3) {
    return (uint64_t)a2;
  }
  int v3 = *a2;
  if (v3 == 42) {
    operator new();
  }
  if (a2 + 1 == a3 || v3 != 92 || a2[1] != 123) {
    return (uint64_t)a2;
  }
  uint64_t v5 = &a2[2 * (a2[1] == 123)];
  if (v5 != a3)
  {
    int v6 = *v5;
    if ((v6 & 0xF8) == 0x30 || (v6 & 0xFE) == 0x38)
    {
      int v7 = v6 - 48;
      uint64_t v8 = v5 + 1;
      if (v5 + 1 == a3)
      {
LABEL_16:
        uint64_t v8 = a3;
      }
      else
      {
        while (1)
        {
          int v9 = *v8;
          if ((v9 & 0xF8) != 0x30 && (v9 & 0xFE) != 0x38) {
            break;
          }
          if (v7 >= 214748364) {
            goto LABEL_43;
          }
          int v7 = v9 + 10 * v7 - 48;
          if (++v8 == a3) {
            goto LABEL_16;
          }
        }
      }
      if (v8 != v5)
      {
        if (v8 != a3)
        {
          int v10 = v8 + 1;
          int v11 = *v8;
          if (v11 != 44)
          {
            if (v10 != a3 && v11 == 92 && *v10 == 125) {
              operator new();
            }
            goto LABEL_41;
          }
          if (v10 != a3)
          {
            int v12 = *v10;
            if ((v12 & 0xF8) == 0x30 || (v12 & 0xFE) == 0x38)
            {
              int v10 = v8 + 2;
              if (v8 + 2 == a3) {
                goto LABEL_41;
              }
              int v13 = v12 - 48;
              while (1)
              {
                int v12 = *v10;
                if ((v12 & 0xF8) != 0x30 && (v12 & 0xFE) != 0x38) {
                  break;
                }
                if (v13 >= 214748364) {
                  goto LABEL_43;
                }
                int v13 = v12 + 10 * v13 - 48;
                if (++v10 == a3) {
                  goto LABEL_41;
                }
              }
            }
            else
            {
              int v13 = -1;
            }
            if (v10 != a3 && v10 + 1 != a3 && v12 == 92 && v10[1] == 125)
            {
              if (v13 != -1)
              {
                if (v13 >= v7) {
                  operator new();
                }
                goto LABEL_43;
              }
LABEL_42:
              operator new();
            }
          }
        }
LABEL_41:
        sub_2154107DC();
        goto LABEL_42;
      }
    }
  }
LABEL_43:
  uint64_t v14 = sub_2154107DC();
  return sub_21541A670(v14, v15);
}

uint64_t sub_21541A670(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -994;
  *(void *)(a2 + 80) = *(void *)(result + 8);
  return result;
}

void sub_21541A684()
{
}

uint64_t sub_21541A69C(uint64_t result, int a2, uint64_t a3)
{
  *(_DWORD *)a3 = -994;
  uint64_t v3 = 8;
  if (a2) {
    uint64_t v3 = 16;
  }
  *(void *)(a3 + 80) = *(void *)(result + v3);
  return result;
}

void sub_21541A6C0(uint64_t a1, _DWORD *a2)
{
  *a2 = -992;
}

void sub_21541A6CC(void *a1)
{
  *a1 = &unk_26C5FC1A0;
  uint64_t v2 = a1[2];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *a1 = &unk_26C5FC170;
  uint64_t v3 = a1[1];
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  JUMPOUT(0x2166B9890);
}

void *sub_21541A7A0(void *a1)
{
  *a1 = &unk_26C5FC1A0;
  uint64_t v2 = a1[2];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *a1 = &unk_26C5FC170;
  uint64_t v3 = a1[1];
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  return a1;
}

char *sub_21541A854(uint64_t a1, char *a2, char *a3)
{
  if (a2 != a3)
  {
    int v6 = *a2;
    if (v6 > 91)
    {
      if (v6 == 92)
      {
        if (a2 + 1 != a3)
        {
          int v13 = a2[1];
          if (v13 == 66) {
            operator new();
          }
          if (v13 == 98) {
            operator new();
          }
        }
      }
      else if (v6 == 94)
      {
        operator new();
      }
    }
    else
    {
      if (v6 == 36) {
        operator new();
      }
      BOOL v8 = v6 == 40;
      int v7 = a2 + 1;
      BOOL v8 = !v8 || v7 == a3;
      if (!v8)
      {
        BOOL v8 = *v7 == 63;
        int v9 = a2 + 2;
        if (v8 && v9 != a3)
        {
          int v11 = *v9;
          if (v11 == 33 || v11 == 61)
          {
            sub_21541B688((uint64_t)v14);
            void v14[6] = *(_DWORD *)(a1 + 24);
            sub_21540FF70(v14, a2 + 3, a3);
            sub_21541B6E4();
          }
        }
      }
    }
  }
  return a2;
}

char *sub_21541B2D0(uint64_t a1, char *a2, char *a3)
{
  int v6 = a2;
  do
  {
    int v7 = v6;
    int v6 = sub_21541A854(a1, v6, a3);
    if (v6 != v7) {
      continue;
    }
    BOOL v8 = (char *)((uint64_t (*)(uint64_t, char *, char *))loc_21541AB4C)(a1, v7, a3);
    if (v8 == v7) {
      break;
    }
    int v6 = sub_215414CD4(a1, v8, a3);
  }
  while (v6 != v7);
  if (v7 == a2) {
    operator new();
  }
  if (v7 != a3)
  {
    if (*v7 == 124)
    {
      int v9 = v7 + 1;
      int v10 = v7 + 1;
      while (1)
      {
        int v11 = v10;
        int v10 = sub_21541A854(a1, v10, a3);
        if (v10 == v11)
        {
          int v12 = (char *)((uint64_t (*)(uint64_t, char *, char *))loc_21541AB4C)(a1, v11, a3);
          if (v12 == v11)
          {
LABEL_15:
            if (v11 == v9) {
              operator new();
            }
            operator new();
          }
          int v10 = sub_215414CD4(a1, v12, a3);
        }
        if (v10 == v11) {
          goto LABEL_15;
        }
      }
    }
    return v7;
  }
  return a3;
}

void sub_21541B590(void *a1)
{
  *a1 = &unk_26C5FC170;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  JUMPOUT(0x2166B9890);
}

void *sub_21541B61C(void *a1)
{
  *a1 = &unk_26C5FC170;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

uint64_t sub_21541B688(uint64_t a1)
{
  uint64_t v2 = (const std::locale *)MEMORY[0x2166B9800]();
  *(void *)(a1 + 8) = std::locale::use_facet(v2, MEMORY[0x263F8C108]);
  *(void *)(a1 + 16) = std::locale::use_facet((const std::locale *)a1, MEMORY[0x263F8C130]);
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(void *)(a1 + 56) = 0;
  return a1;
}

void sub_21541B6E4()
{
}

void sub_21541B7B4(std::locale *this)
{
  locale = (std::__shared_weak_count *)this[6].__locale_;
  if (locale && !atomic_fetch_add(&locale->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))locale->__on_zero_shared)(locale);
    std::__shared_weak_count::__release_weak(locale);
  }
  std::locale::~locale(this);
}

void sub_21541B830(uint64_t a1, uint64_t a2)
{
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  char v23 = 0;
  long long v24 = 0uLL;
  char v25 = 0;
  char v26 = 0;
  uint64_t v27 = 0;
  std::string __p = 0;
  uint64_t v17 = 0;
  uint64_t v4 = a1 + 16;
  unint64_t v5 = (*(_DWORD *)(a1 + 44) + 1);
  uint64_t v7 = *(void *)(a2 + 16);
  uint64_t v6 = *(void *)(a2 + 24);
  uint64_t v18 = 0;
  *(void *)&long long v19 = v6;
  *((void *)&v19 + 1) = v6;
  char v20 = 0;
  sub_2154107F4((uint64_t)&__p, v5, &v19);
  uint64_t v21 = v7;
  uint64_t v22 = v7;
  char v23 = 0;
  long long v24 = v19;
  char v25 = v20;
  uint64_t v27 = v7;
  char v26 = 1;
  if (*(unsigned __int8 *)(a1 + 84) == ((uint64_t (*)(uint64_t))loc_215410980)(v4))
  {
    *(_DWORD *)a2 = -993;
    *(void *)(a2 + 80) = 0;
    BOOL v8 = (char *)__p;
    goto LABEL_7;
  }
  *(_DWORD *)a2 = -994;
  *(void *)(a2 + 80) = *(void *)(a1 + 8);
  BOOL v8 = (char *)__p;
  unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((v17 - (uint64_t)__p) >> 3);
  if (v9 < 2)
  {
LABEL_7:
    if (!v8) {
      return;
    }
    goto LABEL_8;
  }
  int v10 = *(_DWORD *)(a1 + 80);
  uint64_t v11 = *(void *)(a2 + 32);
  unsigned int v12 = 2;
  for (unint64_t i = 1; i < v9; unint64_t i = v12++)
  {
    uint64_t v14 = &v8[24 * i];
    uint64_t v15 = v11 + 24 * (v10 + v12 - 2);
    *(_OWORD *)uint64_t v15 = *(_OWORD *)v14;
    *(unsigned char *)(v15 + 16) = v14[16];
  }
LABEL_8:
  operator delete(v8);
}

void sub_21541B9C0(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_26C5FC050;
  uint64_t v2 = a1 + 2;
  locale = (std::__shared_weak_count *)a1[8].__locale_;
  if (locale && !atomic_fetch_add(&locale->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))locale->__on_zero_shared)(locale);
    std::__shared_weak_count::__release_weak(locale);
  }
  std::locale::~locale(v2);
  a1->__locale_ = (std::locale::__imp *)&unk_26C5FC170;
  uint64_t v4 = a1[1].__locale_;
  if (v4) {
    (*(void (**)(std::locale::__imp *))(*(void *)v4 + 8))(v4);
  }
  JUMPOUT(0x2166B9890);
}

std::locale *sub_21541BAC4(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_26C5FC050;
  uint64_t v2 = a1 + 2;
  locale = (std::__shared_weak_count *)a1[8].__locale_;
  if (locale && !atomic_fetch_add(&locale->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))locale->__on_zero_shared)(locale);
    std::__shared_weak_count::__release_weak(locale);
  }
  std::locale::~locale(v2);
  a1->__locale_ = (std::locale::__imp *)&unk_26C5FC170;
  uint64_t v4 = a1[1].__locale_;
  if (v4) {
    (*(void (**)(std::locale::__imp *))(*(void *)v4 + 8))(v4);
  }
  return a1;
}

uint64_t sub_21541BBA8(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 **)(a2 + 8);
  uint64_t v3 = *(unsigned __int8 **)(a2 + 24);
  if (v2 == v3) {
    goto LABEL_18;
  }
  uint64_t v4 = *(unsigned __int8 **)(a2 + 16);
  if (v4 == v3)
  {
    if ((*(unsigned char *)(a2 + 88) & 8) == 0)
    {
      uint64_t v6 = *(v3 - 1);
      if (v6 != 95)
      {
LABEL_15:
        if ((v6 & 0x80) == 0 && (*(_DWORD *)(*(void *)(*(void *)(result + 24) + 16) + 4 * v6) & 0x500) != 0) {
          goto LABEL_17;
        }
        goto LABEL_18;
      }
LABEL_17:
      int v10 = 1;
      goto LABEL_25;
    }
LABEL_18:
    int v10 = 0;
    goto LABEL_25;
  }
  if (v4 == v2)
  {
    int v5 = *(_DWORD *)(a2 + 88);
    if ((v5 & 0x80) == 0)
    {
      if ((v5 & 4) == 0)
      {
        uint64_t v6 = *v2;
        if (v6 != 95) {
          goto LABEL_15;
        }
        goto LABEL_17;
      }
      goto LABEL_18;
    }
  }
  uint64_t v7 = *(v4 - 1);
  uint64_t v8 = *v4;
  if (v7 == 95 || (v7 & 0x80) == 0 && (*(_DWORD *)(*(void *)(*(void *)(result + 24) + 16) + 4 * v7) & 0x500) != 0)
  {
    int v9 = 1;
    if (v8 == 95) {
      goto LABEL_22;
    }
  }
  else
  {
    int v9 = 0;
    if (v8 == 95) {
      goto LABEL_22;
    }
  }
  if ((v8 & 0x80) != 0 || (*(_DWORD *)(*(void *)(*(void *)(result + 24) + 16) + 4 * v8) & 0x500) == 0)
  {
    int v11 = 0;
    goto LABEL_24;
  }
LABEL_22:
  int v11 = 1;
LABEL_24:
  int v10 = v9 != v11;
LABEL_25:
  if (*(unsigned __int8 *)(result + 40) == v10)
  {
    uint64_t v12 = 0;
    int v13 = -993;
  }
  else
  {
    uint64_t v12 = *(void *)(result + 8);
    int v13 = -994;
  }
  *(_DWORD *)a2 = v13;
  *(void *)(a2 + 80) = v12;
  return result;
}

void sub_21541BCCC(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_26C5FC110;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&unk_26C5FC170;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  JUMPOUT(0x2166B9890);
}

std::locale *sub_21541BD78(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_26C5FC110;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&unk_26C5FC170;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  return a1;
}

uint64_t sub_21541BE08(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_21541BE38(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2166B9890);
}

uint64_t sub_21541BE74(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -994;
  *(void *)(a2 + 80) = *(void *)(result + 8);
  return result;
}

void sub_21541BE88(void *a1)
{
  *a1 = &unk_26C5FC170;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  JUMPOUT(0x2166B9890);
}

void *sub_21541BF14(void *a1)
{
  *a1 = &unk_26C5FC170;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_21541BF80(uint64_t a1, _DWORD *a2)
{
  *a2 = -1000;
}

void sub_21541BF8C()
{
}

BOOL cva::utils::string::ignoreWhitespace(void *a1)
{
  unsigned __int8 v2 = 0;
  uint64_t v3 = a1 + 4;
  while (1)
  {
    int v4 = std::istream::get();
    if (v4 != -1) {
      unsigned __int8 v2 = v4;
    }
    int v5 = *(_DWORD *)((char *)v3 + *(void *)(*a1 - 24));
    if (v5) {
      break;
    }
    if (v2 > 0x20u || ((1 << v2) & 0x100002600) == 0)
    {
      std::istream::putback();
      return v5 == 0;
    }
  }
  return v5 == 0;
}

void cva::utils::string::ignoreComments(void *a1)
{
  if (!*(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32))
  {
    unsigned __int8 v2 = 0;
    uint64_t v3 = a1 + 4;
    while (1)
    {
      int v4 = std::istream::get();
      if (v4 != -1) {
        unsigned __int8 v2 = v4;
      }
      if (*(_DWORD *)((char *)v3 + *(void *)(*a1 - 24))) {
        break;
      }
      if (v2 > 0x20u || ((1 << v2) & 0x100002600) == 0)
      {
        std::istream::putback();
        break;
      }
    }
    if (std::istream::peek() == 35)
    {
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v10 = 0;
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
      uint64_t v6 = std::locale::use_facet(&v11, MEMORY[0x263F8C108]);
      unsigned __int8 v7 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v6->__vftable[2].~facet_0)(v6, 10);
      std::locale::~locale(&v11);
      uint64_t v8 = sub_2153CF138(a1, (uint64_t)__p, v7);
      cva::utils::string::ignoreComments(v8);
      if (SHIBYTE(v10) < 0) {
        operator delete(__p[0]);
      }
    }
  }
}

void *cva::utils::string::getline(void *a1, uint64_t a2)
{
  cva::utils::string::ignoreComments(a1);
  std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
  int v4 = std::locale::use_facet(&v7, MEMORY[0x263F8C108]);
  unsigned __int8 v5 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v4->__vftable[2].~facet_0)(v4, 10);
  std::locale::~locale(&v7);
  return sub_2153CF138(a1, a2, v5);
}

unint64_t cva::utils::string::trimmed@<X0>(unint64_t result@<X0>, void *a2@<X8>)
{
  unint64_t v2 = result;
  unint64_t v4 = *(unsigned __int8 *)(result + 23);
  BOOL v5 = *(char *)(result + 23) < 0;
  uint64_t v6 = *(void *)(result + 8);
  if (*(char *)(result + 23) >= 0) {
    uint64_t v6 = *(unsigned __int8 *)(result + 23);
  }
  uint64_t v7 = MEMORY[0x263EF8318];
  unint64_t v8 = 0;
  if (v6)
  {
    do
    {
      if (v5) {
        unint64_t v9 = *(void *)v2;
      }
      else {
        unint64_t v9 = v2;
      }
      unsigned int v10 = *(char *)(v9 + v8);
      if ((v10 & 0x80000000) != 0)
      {
        uint64_t result = __maskrune(v10, 0x4000uLL);
        unint64_t v4 = *(unsigned __int8 *)(v2 + 23);
        if (!result) {
          break;
        }
      }
      else
      {
        uint64_t result = *(_DWORD *)(v7 + 4 * v10 + 60) & 0x4000;
        if (!result) {
          break;
        }
      }
      ++v8;
      BOOL v5 = (v4 & 0x80u) != 0;
      unint64_t v11 = *(void *)(v2 + 8);
      if ((v4 & 0x80u) == 0) {
        unint64_t v11 = v4;
      }
    }
    while (v8 < v11);
  }
  if ((v4 & 0x80) != 0)
  {
    unint64_t v4 = *(void *)(v2 + 8);
    if (v8 == v4) {
      goto LABEL_16;
    }
  }
  else if (v8 == v4)
  {
LABEL_16:
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    return result;
  }
  unint64_t v12 = v4 - 1;
  do
  {
    while (1)
    {
      unint64_t v13 = v12;
      LODWORD(v14) = *(char *)(v2 + 23);
      if (v12 <= v8)
      {
        unint64_t v17 = v12 + 1;
        if ((v14 & 0x80) == 0) {
          goto LABEL_29;
        }
LABEL_26:
        unint64_t v14 = *(void *)(v2 + 8);
        if (v14 >= v8)
        {
          unint64_t v2 = *(void *)v2;
          goto LABEL_30;
        }
LABEL_42:
        abort();
      }
      unint64_t v15 = *(void *)v2;
      if ((v14 & 0x80000000) == 0) {
        unint64_t v15 = v2;
      }
      unsigned int v16 = *(char *)(v15 + v13);
      if ((v16 & 0x80000000) != 0) {
        break;
      }
      uint64_t result = *(_DWORD *)(v7 + 4 * v16 + 60) & 0x4000;
      unint64_t v12 = v13 - 1;
      if (!result) {
        goto LABEL_25;
      }
    }
    uint64_t result = __maskrune(v16, 0x4000uLL);
    unint64_t v12 = v13 - 1;
  }
  while (result);
LABEL_25:
  unint64_t v17 = v13 + 1;
  LOBYTE(v14) = *(unsigned char *)(v2 + 23);
  if ((v14 & 0x80) != 0) {
    goto LABEL_26;
  }
LABEL_29:
  unint64_t v14 = v14;
  if (v8 > v14) {
    goto LABEL_42;
  }
LABEL_30:
  size_t v18 = v17 - v8;
  size_t v19 = v14 - v8;
  if (v19 >= v18) {
    size_t v20 = v18;
  }
  else {
    size_t v20 = v19;
  }
  if (v20 >= 0x7FFFFFFFFFFFFFF8) {
    goto LABEL_42;
  }
  if (v20 >= 0x17)
  {
    uint64_t v21 = (v20 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v20 | 7) != 0x17) {
      uint64_t v21 = v20 | 7;
    }
    uint64_t v22 = v21 + 1;
    char v23 = operator new(v21 + 1);
    a2[1] = v20;
    a2[2] = v22 | 0x8000000000000000;
    *a2 = v23;
    a2 = v23;
    goto LABEL_40;
  }
  *((unsigned char *)a2 + 23) = v20;
  if (v20) {
LABEL_40:
  }
    uint64_t result = (unint64_t)memmove(a2, (const void *)(v2 + v8), v20);
  *((unsigned char *)a2 + v20) = 0;
  return result;
}

void cva::utils::string::replace_whitespace(std::string::value_type *a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  if (a1[23] >= 0) {
    std::string::size_type v4 = a1[23];
  }
  else {
    std::string::size_type v4 = *((void *)a1 + 1);
  }
  std::string::reserve((std::string *)a2, v4);
  uint64_t v5 = a1[23];
  uint64_t v6 = *(std::string::value_type **)a1;
  if ((v5 & 0x80u) == 0) {
    uint64_t v7 = a1;
  }
  else {
    uint64_t v7 = *(std::string::value_type **)a1;
  }
  uint64_t v8 = MEMORY[0x263EF8318];
LABEL_9:
  while (1)
  {
    int v9 = (char)v5;
    uint64_t v10 = *((void *)a1 + 1);
    while (1)
    {
      BOOL v11 = v9 < 0;
      uint64_t v12 = (uint64_t)(v9 >= 0 ? a1 : v6);
      uint64_t v13 = v11 ? v10 : v5;
      if (v7 == (std::string::value_type *)(v12 + v13)) {
        break;
      }
      unsigned int v14 = *v7;
      if ((v14 & 0x80000000) != 0)
      {
        int v15 = __maskrune(v14, 0x4000uLL);
        uint64_t v5 = a1[23];
        uint64_t v6 = *(std::string::value_type **)a1;
        uint64_t v10 = *((void *)a1 + 1);
        if (!v15) {
          break;
        }
      }
      else if ((*(_DWORD *)(v8 + 4 * v14 + 60) & 0x4000) == 0)
      {
        break;
      }
      ++v7;
      int v9 = (char)v5;
    }
    uint64_t v16 = (uint64_t)((v5 & 0x80u) == 0 ? a1 : v6);
    uint64_t v17 = (v5 & 0x80u) == 0 ? v5 : v10;
    if (v7 == (std::string::value_type *)(v16 + v17)) {
      break;
    }
    uint64_t v18 = *(unsigned __int8 *)(a2 + 23);
    if ((v18 & 0x80u) != 0) {
      uint64_t v18 = *(void *)(a2 + 8);
    }
    if (v18)
    {
      std::string::push_back((std::string *)a2, 95);
      uint64_t v5 = a1[23];
      uint64_t v6 = *(std::string::value_type **)a1;
      uint64_t v10 = *((void *)a1 + 1);
    }
    if ((v5 & 0x80u) == 0) {
      size_t v19 = a1;
    }
    else {
      size_t v19 = v6;
    }
    if ((v5 & 0x80u) == 0) {
      uint64_t v10 = v5;
    }
    if (v7 != &v19[v10])
    {
      while (1)
      {
        unsigned int v20 = *v7;
        if ((v20 & 0x80000000) != 0)
        {
          if (__maskrune(v20, 0x4000uLL))
          {
LABEL_8:
            uint64_t v5 = a1[23];
            uint64_t v6 = *(std::string::value_type **)a1;
            goto LABEL_9;
          }
        }
        else if ((*(_DWORD *)(v8 + 4 * v20 + 60) & 0x4000) != 0)
        {
          goto LABEL_8;
        }
        std::string::value_type v21 = *v7++;
        std::string::push_back((std::string *)a2, v21);
        uint64_t v5 = a1[23];
        uint64_t v6 = *(std::string::value_type **)a1;
        uint64_t v22 = *((void *)a1 + 1);
        if ((v5 & 0x80u) == 0) {
          char v23 = a1;
        }
        else {
          char v23 = *(std::string::value_type **)a1;
        }
        if ((v5 & 0x80u) == 0) {
          uint64_t v22 = a1[23];
        }
        if (v7 == &v23[v22]) {
          goto LABEL_9;
        }
      }
    }
  }
}

uint64_t cva::utils::string::get_block(void *a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    **(unsigned char **)a2 = 0;
    *(void *)(a2 + 8) = 0;
  }
  else
  {
    *(unsigned char *)a2 = 0;
    *(unsigned char *)(a2 + 23) = 0;
  }
  unsigned __int8 v4 = 0;
  uint64_t v5 = a1 + 4;
  while (1)
  {
    int v6 = std::istream::get();
    if (v6 != -1) {
      unsigned __int8 v4 = v6;
    }
    if (*(_DWORD *)((char *)v5 + *(void *)(*a1 - 24))) {
      break;
    }
    if (v4 > 0x20u || ((1 << v4) & 0x100002600) == 0)
    {
      std::istream::putback();
      break;
    }
  }
  int v8 = std::istream::get();
  uint64_t result = 0;
  if (v8 == -1) {
    LOBYTE(v8) = 0;
  }
  if ((*((unsigned char *)a1 + *(void *)(*a1 - 24) + 32) & 5) == 0)
  {
    if (v8 == 123)
    {
      char v10 = 123;
      while (1)
      {
        int v11 = std::istream::get();
        if (v11 != -1) {
          char v10 = v11;
        }
        if ((*((unsigned char *)v5 + *(void *)(*a1 - 24)) & 5) != 0) {
          return 0;
        }
        if (v10 == 125)
        {
          int v20 = *(char *)(a2 + 23);
          if (v20 >= 0) {
            size_t v21 = *(unsigned __int8 *)(a2 + 23);
          }
          else {
            size_t v21 = *(void *)(a2 + 8);
          }
          unint64_t v22 = v21 + 1;
          if (v21 + 1 > 0x7FFFFFFFFFFFFFF7) {
LABEL_60:
          }
            abort();
          if (v22 >= 0x17)
          {
            uint64_t v24 = (v22 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v22 | 7) != 0x17) {
              uint64_t v24 = v22 | 7;
            }
            uint64_t v25 = v24 + 1;
            p_dst = (long long *)operator new(v24 + 1);
            *((void *)&__dst + 1) = v21 + 1;
            unint64_t v28 = v25 | 0x8000000000000000;
            *(void *)&long long __dst = p_dst;
          }
          else
          {
            unint64_t v28 = 0;
            long long __dst = 0uLL;
            p_dst = &__dst;
            HIBYTE(v28) = v21 + 1;
            if (!v21)
            {
LABEL_56:
              *(_WORD *)((char *)p_dst + v21) = 10;
              if (*(char *)(a2 + 23) < 0) {
                operator delete(*(void **)a2);
              }
              *(_OWORD *)a2 = __dst;
              *(void *)(a2 + 16) = v28;
              return 1;
            }
          }
          if (v20 >= 0) {
            char v26 = (const void *)a2;
          }
          else {
            char v26 = *(const void **)a2;
          }
          memmove(p_dst, v26, v21);
          goto LABEL_56;
        }
        int v12 = *(char *)(a2 + 23);
        if (v12 >= 0) {
          size_t v13 = *(unsigned __int8 *)(a2 + 23);
        }
        else {
          size_t v13 = *(void *)(a2 + 8);
        }
        unint64_t v14 = v13 + 1;
        if (v13 + 1 > 0x7FFFFFFFFFFFFFF7) {
          goto LABEL_60;
        }
        if (v14 >= 0x17)
        {
          uint64_t v16 = (v14 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v14 | 7) != 0x17) {
            uint64_t v16 = v14 | 7;
          }
          uint64_t v17 = v16 + 1;
          int v15 = (long long *)operator new(v16 + 1);
          *((void *)&__dst + 1) = v13 + 1;
          unint64_t v28 = v17 | 0x8000000000000000;
          *(void *)&long long __dst = v15;
        }
        else
        {
          unint64_t v28 = 0;
          long long __dst = 0uLL;
          int v15 = &__dst;
          HIBYTE(v28) = v13 + 1;
          if (!v13) {
            goto LABEL_38;
          }
        }
        if (v12 >= 0) {
          uint64_t v18 = (const void *)a2;
        }
        else {
          uint64_t v18 = *(const void **)a2;
        }
        memmove(v15, v18, v13);
LABEL_38:
        size_t v19 = (char *)v15 + v13;
        char *v19 = v10;
        v19[1] = 0;
        if (*(char *)(a2 + 23) < 0) {
          operator delete(*(void **)a2);
        }
        *(_OWORD *)a2 = __dst;
        *(void *)(a2 + 16) = v28;
      }
    }
    std::istream::putback();
    return 0;
  }
  return result;
}

void *cva::utils::string::common_suffix@<X0>(void *result@<X0>, uint64_t *a2@<X1>, void *a3@<X8>)
{
  uint64_t v3 = result;
  size_t v5 = *((unsigned __int8 *)result + 23);
  unsigned __int8 v6 = v5;
  if ((v5 & 0x80u) != 0) {
    size_t v5 = *((void *)result + 1);
  }
  size_t v7 = *((unsigned __int8 *)a2 + 23);
  if ((v7 & 0x80u) != 0) {
    size_t v7 = a2[1];
  }
  if (v7 >= v5) {
    size_t v8 = v5;
  }
  else {
    size_t v8 = v7;
  }
  if (!v8)
  {
    size_t v10 = 0;
    if ((v6 & 0x80) == 0) {
      goto LABEL_24;
    }
LABEL_27:
    size_t v17 = v3[1];
    if (v17 < v10) {
      goto LABEL_38;
    }
    uint64_t v3 = (void *)*v3;
    goto LABEL_29;
  }
  size_t v10 = 0;
  uint64_t v11 = -1;
  while (1)
  {
    uint64_t v12 = *((unsigned __int8 *)v3 + 23);
    if ((v12 & 0x80u) == 0) {
      size_t v13 = v3;
    }
    else {
      size_t v13 = (void *)*v3;
    }
    if ((v12 & 0x80u) != 0) {
      uint64_t v12 = v3[1];
    }
    __darwin_ct_rune_t v14 = __toupper(*((char *)v13 + v12 + v11));
    uint64_t v15 = *((unsigned __int8 *)a2 + 23);
    if ((v15 & 0x80u) == 0) {
      uint64_t v16 = a2;
    }
    else {
      uint64_t v16 = (uint64_t *)*a2;
    }
    if ((v15 & 0x80u) != 0) {
      uint64_t v15 = a2[1];
    }
    uint64_t result = (void *)__toupper(*((char *)v16 + v15 + v11));
    if (v14 != result) {
      break;
    }
    ++v10;
    --v11;
    if (v8 == v10)
    {
      size_t v10 = v8;
      break;
    }
  }
  unsigned __int8 v6 = *((unsigned char *)v3 + 23);
  if ((v6 & 0x80) != 0) {
    goto LABEL_27;
  }
LABEL_24:
  size_t v17 = v6;
  if (v10 > v6) {
LABEL_38:
  }
    abort();
LABEL_29:
  if (v10 >= 0x7FFFFFFFFFFFFFF8) {
    goto LABEL_38;
  }
  if (v10 >= 0x17)
  {
    uint64_t v18 = (v10 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v10 | 7) != 0x17) {
      uint64_t v18 = v10 | 7;
    }
    uint64_t v19 = v18 + 1;
    int v20 = operator new(v18 + 1);
    a3[1] = v10;
    a3[2] = v19 | 0x8000000000000000;
    *a3 = v20;
    a3 = v20;
  }
  else
  {
    *((unsigned char *)a3 + 23) = v10;
    if (!v10) {
      goto LABEL_37;
    }
  }
  uint64_t result = memmove(a3, (char *)v3 + v17 - v10, v10);
LABEL_37:
  *((unsigned char *)a3 + v10) = 0;
  return result;
}

double cva::utils::string::common_suffix@<D0>(long long **a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *a1;
  unsigned __int8 v4 = a1[1];
  if (v4 == *a1)
  {
    *(unsigned char *)(a2 + 23) = 0;
    *(unsigned char *)a2 = 0;
  }
  else
  {
    if (*((char *)v3 + 23) < 0)
    {
      sub_2153C0AE4((unsigned char *)a2, *(void **)v3, *((void *)v3 + 1));
      uint64_t v3 = *a1;
      unsigned __int8 v4 = a1[1];
    }
    else
    {
      long long v6 = *v3;
      *(_OWORD *)a2 = *v3;
      *(void *)(a2 + 16) = *((void *)v3 + 2);
    }
    if ((int)(-1431655765 * ((unint64_t)((char *)v4 - (char *)v3) >> 3)) >= 1)
    {
      uint64_t v7 = 0;
      uint64_t v8 = 0;
      do
      {
        cva::utils::string::common_suffix((void *)a2, (uint64_t *)((char *)v3 + v7), &v10);
        if (*(char *)(a2 + 23) < 0) {
          operator delete(*(void **)a2);
        }
        *(void *)&long long v6 = v10;
        *(_OWORD *)a2 = v10;
        *(void *)(a2 + 16) = v11;
        ++v8;
        uint64_t v3 = *a1;
        v7 += 24;
      }
      while (v8 < (int)(-1431655765 * ((unint64_t)((char *)a1[1] - (char *)*a1) >> 3)));
    }
  }
  return *(double *)&v6;
}

void cva::utils::string::split(uint64_t a1, const std::string *a2, char *__s, char a4)
{
  size_t __n = strlen(__s);
  uint64_t v7 = *(void ***)a1;
  for (unint64_t i = *(void ***)(a1 + 8); i != v7; i -= 3)
  {
    if (*((char *)i - 1) < 0) {
      operator delete(*(i - 3));
    }
  }
  *(void *)(a1 + 8) = v7;
  std::string::size_type size = HIBYTE(a2->__r_.__value_.__r.__words[2]);
  LODWORD(v10) = (char)size;
  std::string::size_type v11 = 0;
  if ((size & 0x80u) != 0) {
    std::string::size_type size = a2->__r_.__value_.__l.__size_;
  }
  if (size)
  {
    do
    {
      std::string::size_type first_of = std::string::find_first_of(a2, __s, v11, __n);
      std::string::size_type v14 = HIBYTE(a2->__r_.__value_.__r.__words[2]);
      LODWORD(v10) = (char)v14;
      if (first_of == -1) {
        break;
      }
      std::string::size_type v15 = first_of;
      if ((char)v14 < 0)
      {
        std::string::size_type v14 = a2->__r_.__value_.__l.__size_;
        if (v14 < v11) {
          goto LABEL_86;
        }
        uint64_t v16 = (const std::string *)a2->__r_.__value_.__r.__words[0];
      }
      else
      {
        uint64_t v16 = a2;
        if (v11 > v14) {
          goto LABEL_86;
        }
      }
      size_t v17 = v14 - v11;
      if (v17 >= first_of - v11) {
        size_t v18 = first_of - v11;
      }
      else {
        size_t v18 = v17;
      }
      if (v18 > 0x7FFFFFFFFFFFFFF7) {
        goto LABEL_86;
      }
      if (v18 >= 0x17)
      {
        uint64_t v20 = (v18 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v18 | 7) != 0x17) {
          uint64_t v20 = v18 | 7;
        }
        uint64_t v21 = v20 + 1;
        p_dst = (long long *)operator new(v20 + 1);
        *((void *)&__dst + 1) = v18;
        unint64_t v53 = v21 | 0x8000000000000000;
        *(void *)&long long __dst = p_dst;
      }
      else
      {
        HIBYTE(v53) = v18;
        p_dst = &__dst;
        if (!v18) {
          goto LABEL_33;
        }
      }
      memmove(p_dst, (char *)v16 + v11, v18);
LABEL_33:
      *((unsigned char *)p_dst + v18) = 0;
      unint64_t v22 = *(void *)(a1 + 8);
      if (v22 >= *(void *)(a1 + 16))
      {
        char v23 = sub_21541D040((void **)a1, (uint64_t)&__dst);
        int v24 = SHIBYTE(v53);
        *(void *)(a1 + 8) = v23;
        if (v24 < 0) {
          operator delete((void *)__dst);
        }
      }
      else
      {
        *(_OWORD *)unint64_t v22 = __dst;
        *(void *)(v22 + 16) = v53;
        *(void *)(a1 + 8) = v22 + 24;
      }
      std::string::size_type first_not_of = std::string::find_first_not_of(a2, __s, v15, __n);
      std::string::size_type v26 = HIBYTE(a2->__r_.__value_.__r.__words[2]);
      if ((v26 & 0x80u) != 0) {
        std::string::size_type v26 = a2->__r_.__value_.__l.__size_;
      }
      if (v26 >= first_not_of) {
        std::string::size_type v11 = first_not_of;
      }
      else {
        std::string::size_type v11 = v26;
      }
      if ((a4 & 1) == 0)
      {
        unint64_t v28 = *(void ***)a1;
        uint64_t v27 = *(void ***)(a1 + 8);
        unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v27 - *(void *)a1) >> 3);
        unint64_t v30 = v11 + ~v15;
        unint64_t v31 = v30 - 0x5555555555555555 * (((uint64_t)v27 - *(void *)a1) >> 3);
        if (v29 >= v31)
        {
          if (v29 > v31)
          {
            std::string::size_type v41 = &v28[3 * v31];
            while (v27 != v41)
            {
              if (*((char *)v27 - 1) < 0) {
                operator delete(*(v27 - 3));
              }
              v27 -= 3;
            }
            *(void *)(a1 + 8) = v41;
          }
        }
        else
        {
          uint64_t v32 = *(void *)(a1 + 16);
          if (0xAAAAAAAAAAAAAAABLL * ((v32 - (uint64_t)v27) >> 3) >= v30)
          {
            if (v30)
            {
              bzero(*(void **)(a1 + 8), 24 * ((24 * v30 - 24) / 0x18) + 24);
              v27 += 3 * ((24 * v30 - 24) / 0x18) + 3;
            }
            *(void *)(a1 + 8) = v27;
          }
          else
          {
            if (v31 > 0xAAAAAAAAAAAAAAALL) {
              goto LABEL_86;
            }
            unint64_t v33 = 0xAAAAAAAAAAAAAAABLL * ((v32 - (uint64_t)v28) >> 3);
            if (2 * v33 > v31) {
              unint64_t v31 = 2 * v33;
            }
            if (v33 >= 0x555555555555555) {
              unint64_t v31 = 0xAAAAAAAAAAAAAAALL;
            }
            if (v31 > 0xAAAAAAAAAAAAAAALL) {
              sub_2153E6200();
            }
            uint64_t v34 = 24 * v31;
            long long v35 = (char *)operator new(24 * v31);
            size_t v36 = &v35[24 * v29];
            int v37 = &v35[v34];
            bzero(v36, 24 * ((24 * v30 - 24) / 0x18) + 24);
            BOOL v38 = &v36[24 * ((24 * v30 - 24) / 0x18) + 24];
            if (v27 == v28)
            {
              *(void *)a1 = v36;
              *(void *)(a1 + 8) = v38;
              *(void *)(a1 + 16) = v37;
            }
            else
            {
              do
              {
                long long v39 = *(_OWORD *)(v27 - 3);
                *((void *)v36 - 1) = *(v27 - 1);
                *(_OWORD *)(v36 - 24) = v39;
                v36 -= 24;
                *(v27 - 2) = 0;
                *(v27 - 1) = 0;
                *(v27 - 3) = 0;
                v27 -= 3;
              }
              while (v27 != v28);
              uint64_t v27 = *(void ***)a1;
              int v40 = *(void ***)(a1 + 8);
              *(void *)a1 = v36;
              *(void *)(a1 + 8) = v38;
              *(void *)(a1 + 16) = v37;
              while (v40 != v27)
              {
                if (*((char *)v40 - 1) < 0) {
                  operator delete(*(v40 - 3));
                }
                v40 -= 3;
              }
            }
            if (v27) {
              operator delete(v27);
            }
          }
        }
      }
      std::string::size_type v12 = HIBYTE(a2->__r_.__value_.__r.__words[2]);
      LODWORD(v10) = (char)v12;
      if ((v12 & 0x80u) != 0) {
        std::string::size_type v12 = a2->__r_.__value_.__l.__size_;
      }
    }
    while (v11 < v12);
  }
  if ((v10 & 0x80000000) != 0)
  {
    std::string::size_type v10 = a2->__r_.__value_.__l.__size_;
    if (v10 < v11) {
      goto LABEL_86;
    }
    a2 = (const std::string *)a2->__r_.__value_.__r.__words[0];
  }
  else
  {
    std::string::size_type v10 = v10;
    if (v11 > v10) {
LABEL_86:
    }
      abort();
  }
  size_t v42 = v10 - v11;
  if (v10 - v11 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_86;
  }
  if (v42 >= 0x17)
  {
    uint64_t v44 = (v42 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v42 | 7) != 0x17) {
      uint64_t v44 = v42 | 7;
    }
    uint64_t v45 = v44 + 1;
    uint64_t v43 = (long long *)operator new(v44 + 1);
    *((void *)&__dst + 1) = v42;
    unint64_t v53 = v45 | 0x8000000000000000;
    *(void *)&long long __dst = v43;
    goto LABEL_79;
  }
  HIBYTE(v53) = v10 - v11;
  uint64_t v43 = &__dst;
  if (v10 != v11) {
LABEL_79:
  }
    memmove(v43, (char *)a2 + v11, v42);
  *((unsigned char *)v43 + v42) = 0;
  unint64_t v46 = *(void *)(a1 + 8);
  if (v46 >= *(void *)(a1 + 16))
  {
    int v47 = sub_21541D040((void **)a1, (uint64_t)&__dst);
    int v48 = SHIBYTE(v53);
    *(void *)(a1 + 8) = v47;
    if (v48 < 0)
    {
      unint64_t v49 = (void *)__dst;
      operator delete(v49);
    }
  }
  else
  {
    *(_OWORD *)unint64_t v46 = __dst;
    *(void *)(v46 + 16) = v53;
    *(void *)(a1 + 8) = v46 + 24;
  }
}

char *sub_21541D040(void **a1, uint64_t a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a1[1] - (unsigned char *)*a1) >> 3);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3) > v3) {
    unint64_t v3 = 0x5555555555555556 * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3) >= 0x555555555555555) {
    unint64_t v6 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v6 = v3;
  }
  if (v6)
  {
    if (v6 > 0xAAAAAAAAAAAAAAALL) {
      sub_2153E6200();
    }
    uint64_t v7 = (char *)operator new(24 * v6);
  }
  else
  {
    uint64_t v7 = 0;
  }
  uint64_t v8 = &v7[24 * v2];
  int v9 = &v7[24 * v6];
  *(_OWORD *)uint64_t v8 = *(_OWORD *)a2;
  *((void *)v8 + 2) = *(void *)(a2 + 16);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  std::string::size_type v10 = v8 + 24;
  std::string::size_type v11 = (void **)*a1;
  std::string::size_type v12 = (void **)a1[1];
  if (v12 == *a1)
  {
    *a1 = v8;
    a1[1] = v10;
    a1[2] = v9;
  }
  else
  {
    do
    {
      long long v13 = *(_OWORD *)(v12 - 3);
      *((void *)v8 - 1) = *(v12 - 1);
      *(_OWORD *)(v8 - 24) = v13;
      v8 -= 24;
      *(v12 - 2) = 0;
      *(v12 - 1) = 0;
      *(v12 - 3) = 0;
      v12 -= 3;
    }
    while (v12 != v11);
    std::string::size_type v12 = (void **)*a1;
    std::string::size_type v14 = (void **)a1[1];
    *a1 = v8;
    a1[1] = v10;
    a1[2] = v9;
    while (v14 != v12)
    {
      if (*((char *)v14 - 1) < 0) {
        operator delete(*(v14 - 3));
      }
      v14 -= 3;
    }
  }
  if (v12) {
    operator delete(v12);
  }
  return v10;
}

long long **cva::utils::string::join@<X0>(long long **result@<X0>, uint64_t a2@<X1>, std::string *a3@<X8>)
{
  unsigned __int8 v4 = result;
  unint64_t v6 = *result;
  uint64_t v7 = (char *)result[1];
  if (*result == (long long *)v7)
  {
    a3->__r_.__value_.__r.__words[0] = 0;
    a3->__r_.__value_.__l.__size_ = 0;
    uint64_t v7 = (char *)v6;
    a3->__r_.__value_.__r.__words[2] = 0;
  }
  else if (*((char *)v6 + 23) < 0)
  {
    uint64_t result = (long long **)sub_2153C0AE4(a3, *(void **)v6, *((void *)v6 + 1));
    unint64_t v6 = *v4;
    uint64_t v7 = (char *)v4[1];
  }
  else
  {
    long long v8 = *v6;
    a3->__r_.__value_.__r.__words[2] = *((void *)v6 + 2);
    *(_OWORD *)&a3->__r_.__value_.__l.__data_ = v8;
  }
  if (0xAAAAAAAAAAAAAAABLL * ((v7 - (char *)v6) >> 3) >= 2)
  {
    uint64_t v9 = 0;
    unint64_t v10 = 1;
    do
    {
      int v11 = *(char *)(a2 + 23);
      if (v11 >= 0) {
        std::string::size_type v12 = (const std::string::value_type *)a2;
      }
      else {
        std::string::size_type v12 = *(const std::string::value_type **)a2;
      }
      if (v11 >= 0) {
        std::string::size_type v13 = *(unsigned __int8 *)(a2 + 23);
      }
      else {
        std::string::size_type v13 = *(void *)(a2 + 8);
      }
      std::string::append(a3, v12, v13);
      uint64_t v14 = (uint64_t)*v4 + v9;
      size_t v17 = *(const std::string::value_type **)(v14 + 24);
      uint64_t v15 = v14 + 24;
      uint64_t v16 = v17;
      int v18 = *(char *)(v15 + 23);
      if (v18 >= 0) {
        uint64_t v19 = (const std::string::value_type *)v15;
      }
      else {
        uint64_t v19 = v16;
      }
      if (v18 >= 0) {
        std::string::size_type v20 = *(unsigned __int8 *)(v15 + 23);
      }
      else {
        std::string::size_type v20 = *(void *)(v15 + 8);
      }
      uint64_t result = (long long **)std::string::append(a3, v19, v20);
      ++v10;
      v9 += 24;
    }
    while (v10 < 0xAAAAAAAAAAAAAAABLL * (((char *)v4[1] - (char *)*v4) >> 3));
  }
  return result;
}

uint64_t cva::utils::string::to_upper(uint64_t result)
{
  uint64_t v1 = *(unsigned __int8 *)(result + 23);
  int v2 = (char)v1;
  unint64_t v3 = (unsigned char *)(result + v1);
  if (v2 >= 0) {
    unsigned __int8 v4 = v3;
  }
  else {
    unsigned __int8 v4 = (unsigned char *)(*(void *)result + *(void *)(result + 8));
  }
  if (v2 >= 0) {
    size_t v5 = (unsigned char *)result;
  }
  else {
    size_t v5 = *(unsigned char **)result;
  }
  for (; v5 != v4; ++v5)
  {
    uint64_t result = __toupper((char)*v5);
    *size_t v5 = result;
  }
  return result;
}

uint64_t cva::utils::string::to_lower(uint64_t result)
{
  uint64_t v1 = *(unsigned __int8 *)(result + 23);
  int v2 = (char)v1;
  unint64_t v3 = (unsigned char *)(result + v1);
  if (v2 >= 0) {
    unsigned __int8 v4 = v3;
  }
  else {
    unsigned __int8 v4 = (unsigned char *)(*(void *)result + *(void *)(result + 8));
  }
  if (v2 >= 0) {
    size_t v5 = (unsigned char *)result;
  }
  else {
    size_t v5 = *(unsigned char **)result;
  }
  for (; v5 != v4; ++v5)
  {
    uint64_t result = __tolower((char)*v5);
    *size_t v5 = result;
  }
  return result;
}

uint64_t cva::utils::string::iequals(char *a1, char *a2)
{
  uint64_t v2 = a1[23];
  int v3 = (char)v2;
  if ((v2 & 0x80u) != 0) {
    uint64_t v2 = *((void *)a1 + 1);
  }
  uint64_t v4 = a2[23];
  int v5 = (char)v4;
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *((void *)a2 + 1);
  }
  if (v2 != v4) {
    return 0;
  }
  if (v5 >= 0) {
    unint64_t v6 = a2;
  }
  else {
    unint64_t v6 = *(char **)a2;
  }
  if (!v2) {
    return 1;
  }
  if (v3 >= 0) {
    uint64_t v7 = a1;
  }
  else {
    uint64_t v7 = *(char **)a1;
  }
  uint64_t v8 = v2 - 1;
  do
  {
    __darwin_ct_rune_t v10 = *v6++;
    __darwin_ct_rune_t v9 = v10;
    __darwin_ct_rune_t v11 = *v7++;
    __darwin_ct_rune_t v12 = __toupper(v9);
    BOOL v14 = v12 == __toupper(v11);
    uint64_t result = v14;
    BOOL v14 = !v14 || v8-- == 0;
  }
  while (!v14);
  return result;
}

uint64_t cva::utils::string::istarts_with(char *a1, char *a2)
{
  unint64_t v2 = a2[23];
  int v3 = (char)v2;
  if ((v2 & 0x80u) != 0) {
    unint64_t v2 = *((void *)a2 + 1);
  }
  unint64_t v4 = a1[23];
  int v5 = (char)v4;
  if ((v4 & 0x80u) != 0) {
    unint64_t v4 = *((void *)a1 + 1);
  }
  if (v2 > v4) {
    return 0;
  }
  if (v3 >= 0) {
    uint64_t v7 = a2;
  }
  else {
    uint64_t v7 = *(char **)a2;
  }
  if (!v2) {
    return 1;
  }
  if (v5 >= 0) {
    uint64_t v8 = a1;
  }
  else {
    uint64_t v8 = *(char **)a1;
  }
  unint64_t v9 = v2 - 1;
  do
  {
    __darwin_ct_rune_t v11 = *v7++;
    __darwin_ct_rune_t v10 = v11;
    __darwin_ct_rune_t v12 = *v8++;
    __darwin_ct_rune_t v13 = __toupper(v10);
    BOOL v14 = v13 == __toupper(v12);
    uint64_t result = v14;
    BOOL v14 = !v14 || v9-- == 0;
  }
  while (!v14);
  return result;
}

uint64_t cva::utils::string::iends_with(uint64_t *a1, char *a2)
{
  unint64_t v2 = a2[23];
  int v3 = (char)v2;
  if ((v2 & 0x80u) != 0) {
    unint64_t v2 = *((void *)a2 + 1);
  }
  unint64_t v4 = *((unsigned __int8 *)a1 + 23);
  int v5 = (char)v4;
  if ((v4 & 0x80u) != 0) {
    unint64_t v4 = a1[1];
  }
  if (v2 > v4) {
    return 0;
  }
  if (v3 >= 0) {
    uint64_t v7 = a2;
  }
  else {
    uint64_t v7 = *(char **)a2;
  }
  if (!v2) {
    return 1;
  }
  uint64_t v8 = (uint64_t *)*a1;
  if (v5 >= 0) {
    uint64_t v8 = a1;
  }
  uint64_t v9 = (uint64_t)v8 + v4;
  uint64_t v10 = -(uint64_t)v2;
  do
  {
    __darwin_ct_rune_t v11 = *v7++;
    __darwin_ct_rune_t v12 = *(char *)(v9 + v10);
    __darwin_ct_rune_t v13 = __toupper(v11);
    BOOL v14 = v13 == __toupper(v12);
    uint64_t result = v14;
    BOOL v14 = !v14 || v10++ == -1;
  }
  while (!v14);
  return result;
}

BOOL cva::utils::string::icontains(uint64_t a1, long long *a2)
{
  if (*(char *)(a1 + 23) < 0)
  {
    sub_2153C0AE4(__p, *(void **)a1, *(void *)(a1 + 8));
    if ((*((char *)a2 + 23) & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a1;
    uint64_t v27 = *(void *)(a1 + 16);
    if ((*((char *)a2 + 23) & 0x80000000) == 0)
    {
LABEL_3:
      long long v24 = *a2;
      uint64_t v25 = *((void *)a2 + 2);
      goto LABEL_6;
    }
  }
  sub_2153C0AE4(&v24, *(void **)a2, *((void *)a2 + 1));
LABEL_6:
  if (v27 >= 0) {
    int v3 = (void **)((char *)__p + HIBYTE(v27));
  }
  else {
    int v3 = (void **)((char *)__p[0] + (unint64_t)__p[1]);
  }
  if (v27 >= 0) {
    unint64_t v4 = __p;
  }
  else {
    unint64_t v4 = (void **)__p[0];
  }
  for (; v4 != v3; unint64_t v4 = (void **)((char *)v4 + 1))
    *(unsigned char *)unint64_t v4 = __toupper(*(char *)v4);
  int64_t v5 = HIBYTE(v25);
  char v6 = HIBYTE(v25);
  int64_t v7 = *((void *)&v24 + 1);
  uint64_t v8 = (char *)v24;
  uint64_t v9 = (char *)&v24;
  if (v25 >= 0) {
    uint64_t v10 = (char *)&v24 + HIBYTE(v25);
  }
  else {
    uint64_t v10 = (char *)(v24 + *((void *)&v24 + 1));
  }
  if (v25 >= 0) {
    __darwin_ct_rune_t v11 = (char *)&v24;
  }
  else {
    __darwin_ct_rune_t v11 = (char *)v24;
  }
  if (v11 != v10)
  {
    do
    {
      char *v11 = __toupper(*v11);
      ++v11;
    }
    while (v11 != v10);
    int64_t v5 = HIBYTE(v25);
    int64_t v7 = *((void *)&v24 + 1);
    uint64_t v8 = (char *)v24;
    char v6 = HIBYTE(v25);
  }
  char v12 = HIBYTE(v27);
  if (v27 >= 0) {
    __darwin_ct_rune_t v13 = __p;
  }
  else {
    __darwin_ct_rune_t v13 = (void **)__p[0];
  }
  if (v6 >= 0)
  {
    int64_t v14 = v5;
  }
  else
  {
    uint64_t v9 = v8;
    int64_t v14 = v7;
  }
  if (v14)
  {
    uint64_t v15 = (uint64_t)__p[1];
    if (v27 >= 0) {
      uint64_t v15 = HIBYTE(v27);
    }
    uint64_t v16 = (char *)v13 + v15;
    if (v15 >= v14)
    {
      int v20 = *v9;
      uint64_t v21 = v13;
      do
      {
        uint64_t v22 = v15 - v14;
        if (v22 == -1) {
          break;
        }
        char v23 = (char *)memchr(v21, v20, v22 + 1);
        if (!v23) {
          break;
        }
        size_t v17 = v23;
        if (!memcmp(v23, v9, v14)) {
          goto LABEL_34;
        }
        uint64_t v21 = (void **)(v17 + 1);
        uint64_t v15 = v16 - (v17 + 1);
      }
      while (v15 >= v14);
    }
    size_t v17 = v16;
LABEL_34:
    if (v17 == v16) {
      uint64_t v18 = -1;
    }
    else {
      uint64_t v18 = v17 - (char *)v13;
    }
    if (v6 < 0) {
      goto LABEL_38;
    }
  }
  else
  {
    uint64_t v18 = 0;
    if (v6 < 0)
    {
LABEL_38:
      operator delete(v8);
      char v12 = HIBYTE(v27);
    }
  }
  if (v12 < 0) {
    operator delete(__p[0]);
  }
  return v18 != -1;
}

void cva::VecLibSparse<float>::multiply(uint64_t a1, long long *a2, long long *a3)
{
  long long v3 = *(_OWORD *)(a1 + 16);
  v8[0] = *(_OWORD *)a1;
  v8[1] = v3;
  uint64_t v9 = *(void *)(a1 + 32);
  long long v6 = *a2;
  uint64_t v7 = *((void *)a2 + 2);
  long long v4 = *a3;
  uint64_t v5 = *((void *)a3 + 2);
  sub_21541D7D4((uint64_t)v8, (int *)&v6, (uint64_t)&v4, 1.0);
}

void sub_21541D7D4(uint64_t a1, int *a2, uint64_t a3, float a4)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  int v4 = *(_DWORD *)(a3 + 8);
  int v5 = *(_DWORD *)a3;
  if (v4 >= *(_DWORD *)a3)
  {
    int v7 = a2[2];
    int v8 = *a2;
    if (v7 >= *a2)
    {
      __int16 v9 = *(_WORD *)(a3 + 12);
      if ((v9 & 1) == 0) {
        int v5 = *(_DWORD *)(a3 + 4);
      }
      int v10 = a2[(a2[3] & 1) == 0];
      int v11 = *(_DWORD *)(a3 + 4 * (v9 & 1));
      int v12 = a2[a2[3] & 1];
      if (v5 == v10)
      {
        if (v5 <= 0)
        {
          if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315650;
            char v23 = "Y";
            __int16 v24 = 1024;
            int v25 = v11;
            __int16 v26 = 1024;
            *(_DWORD *)uint64_t v27 = v5;
            _os_log_error_impl(&dword_2153B7000, &_os_log_internal, OS_LOG_TYPE_ERROR, "%s (%dx%d) must represent at least one right-hand side.\n", buf, 0x18u);
          }
          goto LABEL_24;
        }
        int v13 = *(unsigned __int8 *)(a1 + 28);
        int v14 = *(_DWORD *)(a1 + 4 * (*(_WORD *)(a1 + 24) & 1)) * v13;
        int v15 = *(_DWORD *)(a1 + 4 * ((*(_WORD *)(a1 + 24) & 1) == 0)) * v13;
        if (v11 == v14)
        {
          if (v12 == v15)
          {
            long long v16 = *(_OWORD *)(a1 + 16);
            *(_OWORD *)&A.structure.rowCFIndex Count = *(_OWORD *)a1;
            *(_OWORD *)&A.structure.rowIndices = v16;
            A.data = *(float **)(a1 + 32);
            DenseMatrix_Float x = *(DenseMatrix_Float *)a2;
            DenseMatrix_Float v19 = *(DenseMatrix_Float *)a3;
            _SparseSpMV_Float(a4, &A, &x, 0, &v19);
            return;
          }
          if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
            goto LABEL_24;
          }
          *(_DWORD *)buf = 136316418;
          char v23 = "X";
          __int16 v24 = 1024;
          int v25 = v12;
          __int16 v26 = 1024;
          *(_DWORD *)uint64_t v27 = v5;
          *(_WORD *)&void v27[4] = 2080;
          *(void *)&v27[6] = "matrix A";
          __int16 v28 = 1024;
          int v29 = v15;
          __int16 v30 = 1024;
          int v31 = v14;
          size_t v17 = &_os_log_internal;
          uint64_t v18 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
        }
        else
        {
          if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
            goto LABEL_24;
          }
          *(_DWORD *)buf = 136316418;
          char v23 = "Y";
          __int16 v24 = 1024;
          int v25 = v11;
          __int16 v26 = 1024;
          *(_DWORD *)uint64_t v27 = v5;
          *(_WORD *)&void v27[4] = 2080;
          *(void *)&v27[6] = "matrix A";
          __int16 v28 = 1024;
          int v29 = v15;
          __int16 v30 = 1024;
          int v31 = v14;
          size_t v17 = &_os_log_internal;
          uint64_t v18 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
        }
      }
      else
      {
        if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
          goto LABEL_24;
        }
        *(_DWORD *)buf = 136316418;
        char v23 = "Y";
        __int16 v24 = 1024;
        int v25 = v11;
        __int16 v26 = 1024;
        *(_DWORD *)uint64_t v27 = v5;
        *(_WORD *)&void v27[4] = 2080;
        *(void *)&v27[6] = "X";
        __int16 v28 = 1024;
        int v29 = v12;
        __int16 v30 = 1024;
        int v31 = v10;
        size_t v17 = &_os_log_internal;
        uint64_t v18 = "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n";
      }
      _os_log_error_impl(&dword_2153B7000, v17, OS_LOG_TYPE_ERROR, v18, buf, 0x2Eu);
      goto LABEL_24;
    }
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      char v23 = "X";
      __int16 v24 = 1024;
      int v25 = v7;
      __int16 v26 = 2080;
      *(void *)uint64_t v27 = "X";
      *(_WORD *)&v27[8] = 1024;
      *(_DWORD *)&v27[10] = v8;
      long long v6 = &_os_log_internal;
      goto LABEL_7;
    }
  }
  else if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315906;
    char v23 = "Y";
    __int16 v24 = 1024;
    int v25 = v4;
    __int16 v26 = 2080;
    *(void *)uint64_t v27 = "Y";
    *(_WORD *)&v27[8] = 1024;
    *(_DWORD *)&v27[10] = v5;
    long long v6 = &_os_log_internal;
LABEL_7:
    _os_log_error_impl(&dword_2153B7000, v6, OS_LOG_TYPE_ERROR, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n", buf, 0x22u);
  }
LABEL_24:
  _SparseTrap();
}

void cva::VecLibSparse<float>::multiply(uint64_t a1, long long *a2, long long *a3, float a4)
{
  long long v4 = *(_OWORD *)(a1 + 16);
  v9[0] = *(_OWORD *)a1;
  v9[1] = v4;
  uint64_t v10 = *(void *)(a1 + 32);
  long long v7 = *a2;
  uint64_t v8 = *((void *)a2 + 2);
  long long v5 = *a3;
  uint64_t v6 = *((void *)a3 + 2);
  sub_21541D7D4((uint64_t)v9, (int *)&v7, (uint64_t)&v5, a4);
}

void cva::VecLibSparse<float>::multiply(uint64_t a1, uint64_t a2, uint64_t a3)
{
  long long v3 = *(_OWORD *)(a1 + 16);
  v4[0] = *(_OWORD *)a1;
  v4[1] = v3;
  uint64_t v5 = *(void *)(a1 + 32);
  sub_21541DC90((uint64_t)v4, *(void *)a2, *(float **)(a2 + 8), *(void *)a3, *(float **)(a3 + 8), 1.0);
}

void sub_21541DC90(uint64_t a1, int a2, float *a3, int a4, float *a5, float a6)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  int v7 = *(unsigned __int8 *)(a1 + 28);
  uint64_t v8 = *(_WORD *)(a1 + 24) & 1;
  BOOL v9 = v8 == 0;
  int v10 = *(_DWORD *)(a1 + 4 * v8);
  unsigned int v11 = v9;
  int v12 = v10 * v7;
  int v13 = *(_DWORD *)(a1 + 4 * v11) * v7;
  if (v13 != a2)
  {
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_10;
    }
    *(_DWORD *)buf = 67109888;
    int v22 = v12;
    __int16 v23 = 1024;
    int v24 = v13;
    __int16 v25 = 1024;
    int v26 = a2;
    __int16 v27 = 1024;
    int v28 = 1;
    long long v16 = &_os_log_internal;
    size_t v17 = "Matrix dimensions (%dx%d) do not match x vector dimensions %dx%d\n";
LABEL_13:
    _os_log_error_impl(&dword_2153B7000, v16, OS_LOG_TYPE_ERROR, v17, buf, 0x1Au);
    goto LABEL_10;
  }
  if (v12 == a4)
  {
    long long v15 = *(_OWORD *)(a1 + 16);
    *(_OWORD *)&A.structure.rowCFIndex Count = *(_OWORD *)a1;
    *(_OWORD *)&A.structure.rowIndices = v15;
    A.data = *(float **)(a1 + 32);
    x.rowCFIndex Count = a2;
    x.columnCFIndex Count = 1;
    x.columnStride = a2;
    x.attributes = 0;
    x.data = a3;
    v18.rowCFIndex Count = a4;
    v18.columnCFIndex Count = 1;
    v18.columnStride = a4;
    v18.attributes = 0;
    v18.data = a5;
    _SparseSpMV_Float(a6, &A, &x, 0, &v18);
    return;
  }
  if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 67109888;
    int v22 = v12;
    __int16 v23 = 1024;
    int v24 = a2;
    __int16 v25 = 1024;
    int v26 = a4;
    __int16 v27 = 1024;
    int v28 = 1;
    long long v16 = &_os_log_internal;
    size_t v17 = "Matrix dimensions (%dx%d) do not match y vector dimensions %dx%d\n";
    goto LABEL_13;
  }
LABEL_10:
  _SparseTrap();
}

void cva::VecLibSparse<float>::multiply(uint64_t a1, uint64_t a2, uint64_t a3, float a4)
{
  long long v4 = *(_OWORD *)(a1 + 16);
  v5[0] = *(_OWORD *)a1;
  v5[1] = v4;
  uint64_t v6 = *(void *)(a1 + 32);
  sub_21541DC90((uint64_t)v5, *(void *)a2, *(float **)(a2 + 8), *(void *)a3, *(float **)(a3 + 8), a4);
}

void cva::VecLibSparse<float>::multiplyAdd(uint64_t a1, long long *a2, long long *a3)
{
  long long v3 = *(_OWORD *)(a1 + 16);
  v8[0] = *(_OWORD *)a1;
  v8[1] = v3;
  uint64_t v9 = *(void *)(a1 + 32);
  long long v6 = *a2;
  uint64_t v7 = *((void *)a2 + 2);
  long long v4 = *a3;
  uint64_t v5 = *((void *)a3 + 2);
  sub_21541DEE0((uint64_t)v8, (int *)&v6, (uint64_t)&v4, 1.0);
}

void sub_21541DEE0(uint64_t a1, int *a2, uint64_t a3, float a4)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  int v4 = *(_DWORD *)(a3 + 8);
  int v5 = *(_DWORD *)a3;
  if (v4 >= *(_DWORD *)a3)
  {
    int v7 = a2[2];
    int v8 = *a2;
    if (v7 >= *a2)
    {
      __int16 v9 = *(_WORD *)(a3 + 12);
      if ((v9 & 1) == 0) {
        int v5 = *(_DWORD *)(a3 + 4);
      }
      int v10 = a2[(a2[3] & 1) == 0];
      int v11 = *(_DWORD *)(a3 + 4 * (v9 & 1));
      int v12 = a2[a2[3] & 1];
      if (v5 == v10)
      {
        if (v5 <= 0)
        {
          if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315650;
            __int16 v23 = "Y";
            __int16 v24 = 1024;
            int v25 = v11;
            __int16 v26 = 1024;
            *(_DWORD *)__int16 v27 = v5;
            _os_log_error_impl(&dword_2153B7000, &_os_log_internal, OS_LOG_TYPE_ERROR, "%s (%dx%d) must represent at least one right-hand side.\n", buf, 0x18u);
          }
          goto LABEL_24;
        }
        int v13 = *(unsigned __int8 *)(a1 + 28);
        int v14 = *(_DWORD *)(a1 + 4 * (*(_WORD *)(a1 + 24) & 1)) * v13;
        int v15 = *(_DWORD *)(a1 + 4 * ((*(_WORD *)(a1 + 24) & 1) == 0)) * v13;
        if (v11 == v14)
        {
          if (v12 == v15)
          {
            long long v16 = *(_OWORD *)(a1 + 16);
            *(_OWORD *)&A.structure.rowCFIndex Count = *(_OWORD *)a1;
            *(_OWORD *)&A.structure.rowIndices = v16;
            A.data = *(float **)(a1 + 32);
            DenseMatrix_Float x = *(DenseMatrix_Float *)a2;
            DenseMatrix_Float v19 = *(DenseMatrix_Float *)a3;
            _SparseSpMV_Float(a4, &A, &x, 1, &v19);
            return;
          }
          if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
            goto LABEL_24;
          }
          *(_DWORD *)buf = 136316418;
          __int16 v23 = "X";
          __int16 v24 = 1024;
          int v25 = v12;
          __int16 v26 = 1024;
          *(_DWORD *)__int16 v27 = v5;
          *(_WORD *)&void v27[4] = 2080;
          *(void *)&v27[6] = "matrix A";
          __int16 v28 = 1024;
          int v29 = v15;
          __int16 v30 = 1024;
          int v31 = v14;
          size_t v17 = &_os_log_internal;
          DenseMatrix_Float v18 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
        }
        else
        {
          if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
            goto LABEL_24;
          }
          *(_DWORD *)buf = 136316418;
          __int16 v23 = "Y";
          __int16 v24 = 1024;
          int v25 = v11;
          __int16 v26 = 1024;
          *(_DWORD *)__int16 v27 = v5;
          *(_WORD *)&void v27[4] = 2080;
          *(void *)&v27[6] = "matrix A";
          __int16 v28 = 1024;
          int v29 = v15;
          __int16 v30 = 1024;
          int v31 = v14;
          size_t v17 = &_os_log_internal;
          DenseMatrix_Float v18 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
        }
      }
      else
      {
        if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
          goto LABEL_24;
        }
        *(_DWORD *)buf = 136316418;
        __int16 v23 = "Y";
        __int16 v24 = 1024;
        int v25 = v11;
        __int16 v26 = 1024;
        *(_DWORD *)__int16 v27 = v5;
        *(_WORD *)&void v27[4] = 2080;
        *(void *)&v27[6] = "X";
        __int16 v28 = 1024;
        int v29 = v12;
        __int16 v30 = 1024;
        int v31 = v10;
        size_t v17 = &_os_log_internal;
        DenseMatrix_Float v18 = "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n";
      }
      _os_log_error_impl(&dword_2153B7000, v17, OS_LOG_TYPE_ERROR, v18, buf, 0x2Eu);
      goto LABEL_24;
    }
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      __int16 v23 = "X";
      __int16 v24 = 1024;
      int v25 = v7;
      __int16 v26 = 2080;
      *(void *)__int16 v27 = "X";
      *(_WORD *)&v27[8] = 1024;
      *(_DWORD *)&v27[10] = v8;
      long long v6 = &_os_log_internal;
      goto LABEL_7;
    }
  }
  else if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315906;
    __int16 v23 = "Y";
    __int16 v24 = 1024;
    int v25 = v4;
    __int16 v26 = 2080;
    *(void *)__int16 v27 = "Y";
    *(_WORD *)&v27[8] = 1024;
    *(_DWORD *)&v27[10] = v5;
    long long v6 = &_os_log_internal;
LABEL_7:
    _os_log_error_impl(&dword_2153B7000, v6, OS_LOG_TYPE_ERROR, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n", buf, 0x22u);
  }
LABEL_24:
  _SparseTrap();
}

void cva::VecLibSparse<float>::multiplyAdd(uint64_t a1, long long *a2, long long *a3, float a4)
{
  long long v4 = *(_OWORD *)(a1 + 16);
  v9[0] = *(_OWORD *)a1;
  v9[1] = v4;
  uint64_t v10 = *(void *)(a1 + 32);
  long long v7 = *a2;
  uint64_t v8 = *((void *)a2 + 2);
  long long v5 = *a3;
  uint64_t v6 = *((void *)a3 + 2);
  sub_21541DEE0((uint64_t)v9, (int *)&v7, (uint64_t)&v5, a4);
}

void cva::VecLibSparse<float>::multiplyAdd(uint64_t a1, uint64_t a2, uint64_t a3)
{
  long long v3 = *(_OWORD *)(a1 + 16);
  v4[0] = *(_OWORD *)a1;
  v4[1] = v3;
  uint64_t v5 = *(void *)(a1 + 32);
  sub_21541E39C((uint64_t)v4, *(void *)a2, *(float **)(a2 + 8), *(void *)a3, *(float **)(a3 + 8), 1.0);
}

void sub_21541E39C(uint64_t a1, int a2, float *a3, int a4, float *a5, float a6)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  int v7 = *(unsigned __int8 *)(a1 + 28);
  uint64_t v8 = *(_WORD *)(a1 + 24) & 1;
  BOOL v9 = v8 == 0;
  int v10 = *(_DWORD *)(a1 + 4 * v8);
  unsigned int v11 = v9;
  int v12 = v10 * v7;
  int v13 = *(_DWORD *)(a1 + 4 * v11) * v7;
  if (v13 != a2)
  {
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_10;
    }
    *(_DWORD *)buf = 67109888;
    int v22 = v12;
    __int16 v23 = 1024;
    int v24 = v13;
    __int16 v25 = 1024;
    int v26 = a2;
    __int16 v27 = 1024;
    int v28 = 1;
    long long v16 = &_os_log_internal;
    size_t v17 = "Matrix dimensions (%dx%d) do not match x vector dimensions %dx%d\n";
LABEL_13:
    _os_log_error_impl(&dword_2153B7000, v16, OS_LOG_TYPE_ERROR, v17, buf, 0x1Au);
    goto LABEL_10;
  }
  if (v12 == a4)
  {
    long long v15 = *(_OWORD *)(a1 + 16);
    *(_OWORD *)&A.structure.rowCFIndex Count = *(_OWORD *)a1;
    *(_OWORD *)&A.structure.rowIndices = v15;
    A.data = *(float **)(a1 + 32);
    x.rowCFIndex Count = a2;
    x.columnCFIndex Count = 1;
    x.columnStride = a2;
    x.attributes = 0;
    x.data = a3;
    v18.rowCFIndex Count = a4;
    v18.columnCFIndex Count = 1;
    v18.columnStride = a4;
    v18.attributes = 0;
    v18.data = a5;
    _SparseSpMV_Float(a6, &A, &x, 1, &v18);
    return;
  }
  if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 67109888;
    int v22 = v12;
    __int16 v23 = 1024;
    int v24 = a2;
    __int16 v25 = 1024;
    int v26 = a4;
    __int16 v27 = 1024;
    int v28 = 1;
    long long v16 = &_os_log_internal;
    size_t v17 = "Matrix dimensions (%dx%d) do not match y vector dimensions %dx%d\n";
    goto LABEL_13;
  }
LABEL_10:
  _SparseTrap();
}

void cva::VecLibSparse<float>::multiplyAdd(uint64_t a1, uint64_t a2, uint64_t a3, float a4)
{
  long long v4 = *(_OWORD *)(a1 + 16);
  v5[0] = *(_OWORD *)a1;
  v5[1] = v4;
  uint64_t v6 = *(void *)(a1 + 32);
  sub_21541E39C((uint64_t)v5, *(void *)a2, *(float **)(a2 + 8), *(void *)a3, *(float **)(a3 + 8), a4);
}

double cva::VecLibSparse<float>::transpose@<D0>(long long *a1@<X0>, _OWORD *a2@<X8>)
{
  long long v3 = a1[5];
  long long v16 = a1[4];
  long long v17 = v3;
  long long v4 = a1[7];
  long long v18 = a1[6];
  long long v19 = v4;
  long long v5 = a1[1];
  long long v12 = *a1;
  long long v13 = v5;
  long long v6 = a1[3];
  long long v14 = a1[2];
  long long v15 = v6;
  LOWORD(v12) = v12 ^ 1;
  _SparseRetainNumeric_Float((SparseOpaqueFactorization_Float *)((char *)&v12 + 8));
  long long v7 = v17;
  a2[4] = v16;
  a2[5] = v7;
  long long v8 = v19;
  a2[6] = v18;
  a2[7] = v8;
  long long v9 = v13;
  *a2 = v12;
  a2[1] = v9;
  double result = *(double *)&v14;
  long long v11 = v15;
  a2[2] = v14;
  a2[3] = v11;
  return result;
}

__n128 cva::VecLibSparse<float>::transpose@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  long long v3 = *(_OWORD *)(a1 + 80);
  *(_OWORD *)&v9.userFactorStorage = *(_OWORD *)(a1 + 64);
  *(_OWORD *)&v9.solveWorkspaceRequiredStatic = v3;
  uint64_t v10 = *(void *)(a1 + 96);
  long long v4 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)&v9.status = *(_OWORD *)a1;
  *(_OWORD *)&v9.symbolicFactorization.columnCFIndex Count = v4;
  long long v5 = *(_OWORD *)(a1 + 48);
  *(_OWORD *)&v9.symbolicFactorization.workspaceSize_Float = *(_OWORD *)(a1 + 32);
  *(_OWORD *)&v9.symbolicFactorization.factorSize_Float = v5;
  *(_WORD *)&v9.attributes ^= 1u;
  _SparseRetainNumeric_Float(&v9);
  long long v6 = *(_OWORD *)&v9.solveWorkspaceRequiredStatic;
  *(_OWORD *)(a2 + 64) = *(_OWORD *)&v9.userFactorStorage;
  *(_OWORD *)(a2 + 80) = v6;
  *(void *)(a2 + 96) = v10;
  long long v7 = *(_OWORD *)&v9.symbolicFactorization.columnCount;
  *(_OWORD *)a2 = *(_OWORD *)&v9.status;
  *(_OWORD *)(a2 + 16) = v7;
  __n128 result = *(__n128 *)&v9.symbolicFactorization.factorSize_Float;
  *(_OWORD *)(a2 + 32) = *(_OWORD *)&v9.symbolicFactorization.workspaceSize_Float;
  *(__n128 *)(a2 + 48) = result;
  return result;
}

{
  __n128 result;
  __int16 v3;

  __n128 result = *(__n128 *)a1;
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *(void *)(a2 + 16) = *(void *)(a1 + 16);
  long long v3 = *(_WORD *)(a1 + 24);
  *(void *)(a2 + 26) = *(void *)(a1 + 26);
  *(void *)(a2 + 32) = *(void *)(a1 + 32);
  *(_WORD *)(a2 + 24) = v3 ^ 1;
  return result;
}

void cva::VecLibSparse<float>::release(_OWORD *a1)
{
  long long v1 = a1[5];
  _DWORD v5[4] = a1[4];
  v5[5] = v1;
  long long v2 = a1[7];
  v5[6] = a1[6];
  v5[7] = v2;
  long long v3 = a1[1];
  v5[0] = *a1;
  v5[1] = v3;
  long long v4 = a1[3];
  _OWORD v5[2] = a1[2];
  v5[3] = v4;
  _SparseDestroyOpaqueNumeric_Float((SparseOpaqueFactorization_Float *)((char *)v5 + 8));
}

__n128 cva::VecLibSparse<float>::release(uint64_t a1)
{
  long long v1 = *(_OWORD *)(a1 + 80);
  *(_OWORD *)&v5.userFactorStorage = *(_OWORD *)(a1 + 64);
  *(_OWORD *)&v5.solveWorkspaceRequiredStatic = v1;
  uint64_t v6 = *(void *)(a1 + 96);
  long long v2 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)&v5.status = *(_OWORD *)a1;
  *(_OWORD *)&v5.symbolicFactorization.columnCFIndex Count = v2;
  long long v3 = *(_OWORD *)(a1 + 48);
  *(_OWORD *)&v5.symbolicFactorization.workspaceSize_Float = *(_OWORD *)(a1 + 32);
  *(_OWORD *)&v5.symbolicFactorization.factorSize_Float = v3;
  _SparseDestroyOpaqueNumeric_Float(&v5);
  return result;
}

void cva::VecLibSparse<float>::retain(uint64_t a1)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  long long v1 = *(_OWORD *)(a1 + 48);
  *(_OWORD *)&v6.symbolicFactorization.workspaceSize_Float = *(_OWORD *)(a1 + 32);
  *(_OWORD *)&v6.symbolicFactorization.factorSize_Float = v1;
  long long v2 = *(_OWORD *)(a1 + 80);
  *(_OWORD *)&v6.userFactorStorage = *(_OWORD *)(a1 + 64);
  *(_OWORD *)&v6.solveWorkspaceRequiredStatic = v2;
  uint64_t v7 = *(void *)(a1 + 96);
  long long v3 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)&v6.status = *(_OWORD *)a1;
  *(_OWORD *)&v6.symbolicFactorization.columnCFIndex Count = v3;
  if (v6.symbolicFactorization.status || !v6.symbolicFactorization.workspaceSize_Float)
  {
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long v8 = 0;
      SparseOpaqueFactorization_Float v5 = &_os_log_internal;
      goto LABEL_14;
    }
LABEL_7:
    _SparseTrap();
    return;
  }
  _SparseGetOptionsFromSymbolicFactor((SparseSymbolicFactorOptions *)v8, &v6.symbolicFactorization);
  long long v4 = *(void (**)(unsigned char *))&v8[40];
  if (v6.status == SparseStatusOK && v6.solveWorkspaceRequiredStatic)
  {
    _SparseRetainNumeric_Float(&v6);
    return;
  }
  if (!*(void *)&v8[40])
  {
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long v8 = 0;
      SparseOpaqueFactorization_Float v5 = &_os_log_internal;
LABEL_14:
      _os_log_error_impl(&dword_2153B7000, v5, OS_LOG_TYPE_ERROR, "Can only retain valid numeric factorizations.\n", v8, 2u);
      goto LABEL_7;
    }
    goto LABEL_7;
  }
  char v21 = 0;
  long long v20 = 0u;
  long long v19 = 0u;
  long long v18 = 0u;
  long long v17 = 0u;
  long long v16 = 0u;
  long long v15 = 0u;
  long long v14 = 0u;
  long long v13 = 0u;
  long long v12 = 0u;
  long long v11 = 0u;
  long long v10 = 0u;
  long long v9 = 0u;
  *(_OWORD *)&v8[47] = 0u;
  strcpy(v8, "Can only retain valid numeric factorizations.\n");
  v4(v8);
}

void cva::VecLibSparse<float>::retain(long long *a1)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  long long v1 = a1[5];
  long long v11 = a1[4];
  long long v12 = v1;
  long long v2 = a1[7];
  long long v13 = a1[6];
  long long v14 = v2;
  long long v3 = a1[1];
  long long v7 = *a1;
  long long v8 = v3;
  long long v4 = a1[3];
  long long v9 = a1[2];
  long long v10 = v4;
  if (v3 || !*((void *)&v9 + 1))
  {
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v15.control) = 0;
      SparseOpaqueFactorization_Float v6 = &_os_log_internal;
      goto LABEL_14;
    }
LABEL_7:
    _SparseTrap();
    return;
  }
  _SparseGetOptionsFromSymbolicFactor(&v15, (SparseOpaqueSymbolicFactorization *)&v8);
  reportError = v15.reportError;
  if (!DWORD2(v7) && *((void *)&v12 + 1))
  {
    _SparseRetainNumeric_Float((SparseOpaqueFactorization_Float *)((char *)&v7 + 8));
    return;
  }
  if (!v15.reportError)
  {
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v15.control) = 0;
      SparseOpaqueFactorization_Float v6 = &_os_log_internal;
LABEL_14:
      _os_log_error_impl(&dword_2153B7000, v6, OS_LOG_TYPE_ERROR, "Can only retain valid objects.\n", (uint8_t *)&v15, 2u);
      goto LABEL_7;
    }
    goto LABEL_7;
  }
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  *(_OWORD *)&v15.free = 0u;
  long long v16 = 0u;
  strcpy((char *)&v15, "Can only retain valid objects.\n");
  ((void (*)(SparseSymbolicFactorOptions *))reportError)(&v15);
}

double cva::VecLibSparse<float>::factor@<D0>(SparseFactorization_t factorType@<W1>, uint64_t a2@<X0>, uint64_t a3@<X8>)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  long long v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)&Matrix.structure.rowCFIndex Count = *(_OWORD *)a2;
  *(_OWORD *)&Matrix.structure.rowIndices = v4;
  Matrix.data = *(float **)(a2 + 32);
  SparseSymbolicFactorOptions sfoptions = *(SparseSymbolicFactorOptions *)byte_26C5FB310;
  SparseNumericFactorOptions v10 = *(SparseNumericFactorOptions *)ymmword_215446250;
  if (Matrix.structure.rowCount <= 0)
  {
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    *(_DWORD *)buf = 136315394;
    long long v14 = "Matrix.structure";
    __int16 v15 = 1024;
    LODWORD(v16) = Matrix.structure.rowCount;
    SparseOpaqueFactorization_Float v6 = &_os_log_internal;
    long long v7 = "%s.rowCount must be > 0, but is %d.\n";
LABEL_14:
    uint32_t v8 = 18;
    goto LABEL_15;
  }
  if (Matrix.structure.columnCount <= 0)
  {
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    *(_DWORD *)buf = 136315394;
    long long v14 = "Matrix.structure";
    __int16 v15 = 1024;
    LODWORD(v16) = Matrix.structure.rowCount;
    SparseOpaqueFactorization_Float v6 = &_os_log_internal;
    long long v7 = "%s.columnCount must be > 0, but is %d.\n";
    goto LABEL_14;
  }
  if (!*(&Matrix.structure.blockSize + 2))
  {
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    *(_DWORD *)buf = 136315394;
    long long v14 = "Matrix.structure";
    __int16 v15 = 1024;
    LODWORD(v16) = 0;
    SparseOpaqueFactorization_Float v6 = &_os_log_internal;
    long long v7 = "%s.blockSize must be > 0, but is %d.]n";
    goto LABEL_14;
  }
  int v5 = *(unsigned char *)&Matrix.structure.attributes & 0xC;
  if (Matrix.structure.rowCount == Matrix.structure.columnCount || v5 != 12)
  {
    if ((factorType & 0xFE) == 0x28)
    {
      _SparseFactorQR_Float((SparseOpaqueFactorization_Float *)a3, factorType, &Matrix, &sfoptions, &v10);
      return result;
    }
    if (v5 == 12)
    {
      _SparseFactorSymmetric_Float((SparseOpaqueFactorization_Float *)a3, factorType, &Matrix, &sfoptions, &v10);
      return result;
    }
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      SparseOpaqueFactorization_Float v6 = &_os_log_internal;
      long long v7 = "Cannot perform symmetric matrix factorization of non-square matrix.\n";
      uint32_t v8 = 2;
      goto LABEL_15;
    }
  }
  else if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136316162;
    long long v14 = "Matrix.structure";
    __int16 v15 = 2080;
    long long v16 = "Matrix.structure";
    __int16 v17 = 1024;
    rowCFIndex Count = Matrix.structure.rowCount;
    __int16 v19 = 2080;
    long long v20 = "Matrix.structure";
    __int16 v21 = 1024;
    columnCFIndex Count = Matrix.structure.columnCount;
    SparseOpaqueFactorization_Float v6 = &_os_log_internal;
    long long v7 = "%s.attributes.kind=SparseSymmetric, but %s.rowCount (%d) != %s.columnCount (%d).\n";
    uint32_t v8 = 44;
LABEL_15:
    _os_log_error_impl(&dword_2153B7000, v6, OS_LOG_TYPE_ERROR, v7, buf, v8);
  }
LABEL_21:
  _SparseTrap();
  double result = 0.0;
  *(void *)(a3 + 96) = 0;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_DWORD *)a3 = -4;
  *(_DWORD *)(a3 + 8) = -4;
  return result;
}

void cva::VecLibSparse<float>::refactor(long long *a1, SparseOpaqueFactorization_Float *factor)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  long long v11 = *a1;
  long long v12 = a1[1];
  long long v13 = (void (__cdecl *)(void *))*((void *)a1 + 4);
  p_symbolicFactorization = &factor->symbolicFactorization;
  if (factor->symbolicFactorization.status || !factor->symbolicFactorization.workspaceSize_Float)
  {
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_3;
    }
    LOWORD(v17.control) = 0;
    uint32_t v8 = &_os_log_internal;
    long long v9 = "Factorization does not hold a completed matrix factorization.\n";
LABEL_21:
    _os_log_error_impl(&dword_2153B7000, v8, OS_LOG_TYPE_ERROR, v9, (uint8_t *)&v17, 2u);
    goto LABEL_3;
  }
  memset(&v15, 0, sizeof(v15));
  _SparseGetOptionsFromNumericFactor_Float(&v15, factor);
  SparseNumericFactorOptions v14 = v15;
  if (factor->symbolicFactorization.status || !factor->symbolicFactorization.workspaceSize_Float)
  {
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_3;
    }
    LOWORD(v17.control) = 0;
    uint32_t v8 = &_os_log_internal;
    long long v9 = "Factorization does not hold a valid symbolic matrix factorization.\n";
    goto LABEL_21;
  }
  _SparseGetOptionsFromSymbolicFactor(&v17, p_symbolicFactorization);
  free = v17.free;
  reportError = v17.reportError;
  SparseOpaqueFactorization_Float v6 = (void *)((uint64_t (*)(size_t))v17.malloc)(factor->symbolicFactorization.workspaceSize_Double);
  if (!v6)
  {
    factor->status = SparseInternalError;
    if (reportError)
    {
      long long v29 = 0u;
      long long v30 = 0u;
      long long v27 = 0u;
      long long v28 = 0u;
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      long long v18 = 0u;
      memset(&v17, 0, sizeof(v17));
      snprintf((char *)&v17, 0x100uLL, "Failed to allocate workspace of size %ld.", factor->symbolicFactorization.workspaceSize_Double);
      ((void (*)(SparseSymbolicFactorOptions *))reportError)(&v17);
      return;
    }
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      size_t workspaceSize_Double = factor->symbolicFactorization.workspaceSize_Double;
      v17.control = 134217984;
      *(void *)&v17.orderMethod = workspaceSize_Double;
      _os_log_error_impl(&dword_2153B7000, &_os_log_internal, OS_LOG_TYPE_ERROR, "Failed to allocate workspace of size %ld.", (uint8_t *)&v17, 0xCu);
    }
LABEL_3:
    _SparseTrap();
    return;
  }
  long long v7 = v6;
  *(_OWORD *)&v17.control = v11;
  *(_OWORD *)&v17.ignoreRowsAndColumns = v12;
  v17.free = v13;
  SparseNumericFactorOptions nfoptions = v14;
  if (v11 == factor->symbolicFactorization.rowCount
    && *(_DWORD *)&v17.orderMethod == factor->symbolicFactorization.columnCount
    && BYTE4(v17.malloc) == LOBYTE(factor->symbolicFactorization.factorization)
    && ((*(_WORD *)&factor->symbolicFactorization.attributes ^ LOWORD(v17.malloc)) & 1) == 0)
  {
    if ((BYTE1(factor->symbolicFactorization.factorization) & 0xFE) == 0x28) {
      _SparseRefactorQR_Float((const SparseMatrix_Float *)&v17, factor, &nfoptions, v6);
    }
    else {
      _SparseRefactorSymmetric_Float((const SparseMatrix_Float *)&v17, factor, &nfoptions, v6);
    }
  }
  else
  {
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      uint64_t v32 = "Matrix";
      __int16 v33 = 2080;
      uint64_t v34 = "Factored->symbolicFactorization";
      _os_log_error_impl(&dword_2153B7000, &_os_log_internal, OS_LOG_TYPE_ERROR, "%s does not match that used for symbolic factorization stored in %s.\n", buf, 0x16u);
    }
    _SparseTrap();
  }
  ((void (*)(void *))free)(v7);
}

void cva::VecLibSparse<float>::solve(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v54 = *MEMORY[0x263EF8340];
  if (a4)
  {
    long long v4 = *(_OWORD *)(a1 + 80);
    *(_OWORD *)&Factored.userFactorStorage = *(_OWORD *)(a1 + 64);
    *(_OWORD *)&Factored.solveWorkspaceRequiredStatic = v4;
    uint64_t v37 = *(void *)(a1 + 96);
    long long v5 = *(_OWORD *)(a1 + 16);
    *(_OWORD *)&Factored.status = *(_OWORD *)a1;
    *(_OWORD *)&Factored.symbolicFactorization.columnCFIndex Count = v5;
    long long v6 = *(_OWORD *)(a1 + 48);
    *(_OWORD *)&Factored.symbolicFactorization.workspaceSize_Float = *(_OWORD *)(a1 + 32);
    *(_OWORD *)&Factored.symbolicFactorization.factorSize_Float = v6;
    if (Factored.symbolicFactorization.status == SparseStatusOK && Factored.symbolicFactorization.workspaceSize_Float)
    {
      SparseControl_t v12 = *(_DWORD *)a3;
      long long v13 = *(int **)(a3 + 8);
      int v14 = *(_DWORD *)a2;
      SparseNumericFactorOptions v15 = *(float **)(a2 + 8);
      _SparseGetOptionsFromSymbolicFactor(&v40, &Factored.symbolicFactorization);
      reportError = v40.reportError;
      if (Factored.symbolicFactorization.status == SparseStatusOK
        && Factored.symbolicFactorization.workspaceSize_Float
        && Factored.status == SparseStatusOK
        && Factored.solveWorkspaceRequiredStatic)
      {
        if ((*(unsigned char *)&Factored.attributes ^ *(unsigned char *)&Factored.symbolicFactorization.attributes)) {
          int v17 = Factored.symbolicFactorization.columnCount * LOBYTE(Factored.symbolicFactorization.factorization);
        }
        else {
          int v17 = Factored.symbolicFactorization.rowCount * LOBYTE(Factored.symbolicFactorization.factorization);
        }
        if ((*(unsigned char *)&Factored.attributes ^ *(unsigned char *)&Factored.symbolicFactorization.attributes)) {
          int v18 = Factored.symbolicFactorization.rowCount * LOBYTE(Factored.symbolicFactorization.factorization);
        }
        else {
          int v18 = Factored.symbolicFactorization.columnCount * LOBYTE(Factored.symbolicFactorization.factorization);
        }
        if (BYTE1(Factored.symbolicFactorization.factorization) == 40) {
          int v19 = v17;
        }
        else {
          int v19 = v18;
        }
        if (v18 == v14)
        {
          if (v19 == v12)
          {
            v40.control = v12;
            *(_DWORD *)&v40.orderMethod = 1;
            v40.ignoreRowsAndColumns = v13;
            v40.order = (int *)v12;
            Soln.rowCFIndex Count = v14;
            Soln.columnCFIndex Count = 1;
            *(_DWORD *)&Soln.attributes = 0;
            Soln.data = v15;
            Soln.columnStride = v14;
            _SparseSolveOpaque_Float(&Factored, (const DenseMatrix_Float *)&v40, &Soln, a4);
            return;
          }
          if (v40.reportError) {
            goto LABEL_62;
          }
          if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
          {
            v40.control = 136316162;
            *(void *)&v40.orderMethod = "b";
            *(_DWORD *)((char *)&v40.order + 6) = v12;
            WORD1(v40.ignoreRowsAndColumns) = 2080;
            WORD2(v40.order) = 1024;
            *(int **)((char *)&v40.ignoreRowsAndColumns + 4) = (int *)"Factored";
            WORD2(v40.malloc) = 1024;
            *(_DWORD *)((char *)&v40.malloc + 6) = v19;
            WORD1(v40.free) = 1024;
            HIDWORD(v40.free) = v14;
            __int16 v33 = &_os_log_internal;
            goto LABEL_72;
          }
LABEL_7:
          _SparseTrap();
          return;
        }
        if (v40.reportError) {
          goto LABEL_62;
        }
        if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
          goto LABEL_7;
        }
        v40.control = 136316162;
        *(void *)&v40.orderMethod = "x";
        *(_DWORD *)((char *)&v40.order + 6) = v14;
        WORD1(v40.ignoreRowsAndColumns) = 2080;
        WORD2(v40.order) = 1024;
        *(int **)((char *)&v40.ignoreRowsAndColumns + 4) = (int *)"Factored";
        WORD2(v40.malloc) = 1024;
        *(_DWORD *)((char *)&v40.malloc + 6) = v19;
        WORD1(v40.free) = 1024;
        HIDWORD(v40.free) = v18;
        __int16 v33 = &_os_log_internal;
LABEL_72:
        _os_log_error_impl(&dword_2153B7000, v33, OS_LOG_TYPE_ERROR, "%s (size %dx1) does not match dimensions of matrix factorization %s (%d x %d).\n", (uint8_t *)&v40, 0x28u);
        goto LABEL_7;
      }
      if (!v40.reportError)
      {
        if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
          goto LABEL_7;
        }
        v40.control = 136315138;
        *(void *)&v40.orderMethod = "Factored";
        int v31 = &_os_log_internal;
        uint64_t v32 = "%s does not hold a completed matrix factorization.\n";
        goto LABEL_58;
      }
      goto LABEL_47;
    }
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_7;
    }
    LOWORD(v40.control) = 0;
    long long v7 = &_os_log_internal;
LABEL_55:
    _os_log_error_impl(&dword_2153B7000, v7, OS_LOG_TYPE_ERROR, "Factored does not hold a completed matrix factorization.\n", (uint8_t *)&v40, 2u);
    goto LABEL_7;
  }
  long long v8 = *(_OWORD *)(a1 + 80);
  *(_OWORD *)&v34.userFactorStorage = *(_OWORD *)(a1 + 64);
  *(_OWORD *)&v34.solveWorkspaceRequiredStatic = v8;
  uint64_t v35 = *(void *)(a1 + 96);
  long long v9 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)&v34.status = *(_OWORD *)a1;
  *(_OWORD *)&v34.symbolicFactorization.columnCFIndex Count = v9;
  long long v10 = *(_OWORD *)(a1 + 48);
  *(_OWORD *)&v34.symbolicFactorization.workspaceSize_Float = *(_OWORD *)(a1 + 32);
  *(_OWORD *)&v34.symbolicFactorization.factorSize_Float = v10;
  if (v34.symbolicFactorization.status || !v34.symbolicFactorization.workspaceSize_Float)
  {
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_7;
    }
    LOWORD(v40.control) = 0;
    long long v7 = &_os_log_internal;
    goto LABEL_55;
  }
  int v20 = *(_DWORD *)a3;
  long long v21 = *(float **)(a3 + 8);
  int v22 = *(_DWORD *)a2;
  long long v23 = *(float **)(a2 + 8);
  _SparseGetOptionsFromSymbolicFactor(&v40, &v34.symbolicFactorization);
  reportError = v40.reportError;
  if (v34.symbolicFactorization.status == SparseStatusOK
    && v34.symbolicFactorization.workspaceSize_Float
    && v34.status == SparseStatusOK
    && v34.solveWorkspaceRequiredStatic)
  {
    if ((*(unsigned char *)&v34.attributes ^ *(unsigned char *)&v34.symbolicFactorization.attributes)) {
      int v24 = v34.symbolicFactorization.columnCount * LOBYTE(v34.symbolicFactorization.factorization);
    }
    else {
      int v24 = v34.symbolicFactorization.rowCount * LOBYTE(v34.symbolicFactorization.factorization);
    }
    if ((*(unsigned char *)&v34.attributes ^ *(unsigned char *)&v34.symbolicFactorization.attributes)) {
      int v25 = v34.symbolicFactorization.rowCount * LOBYTE(v34.symbolicFactorization.factorization);
    }
    else {
      int v25 = v34.symbolicFactorization.columnCount * LOBYTE(v34.symbolicFactorization.factorization);
    }
    if (BYTE1(v34.symbolicFactorization.factorization) == 40) {
      int v26 = v24;
    }
    else {
      int v26 = v25;
    }
    if (v25 != v22)
    {
      if (v40.reportError) {
        goto LABEL_62;
      }
      if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
        goto LABEL_7;
      }
      v40.control = 136316162;
      *(void *)&v40.orderMethod = "x";
      *(_DWORD *)((char *)&v40.order + 6) = v22;
      WORD1(v40.ignoreRowsAndColumns) = 2080;
      WORD2(v40.order) = 1024;
      *(int **)((char *)&v40.ignoreRowsAndColumns + 4) = (int *)"Factored";
      WORD2(v40.malloc) = 1024;
      *(_DWORD *)((char *)&v40.malloc + 6) = v26;
      WORD1(v40.free) = 1024;
      HIDWORD(v40.free) = v25;
      __int16 v33 = &_os_log_internal;
      goto LABEL_72;
    }
    if (v26 != v20)
    {
      if (!v40.reportError)
      {
        if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
        {
          v40.control = 136316162;
          *(void *)&v40.orderMethod = "b";
          *(_DWORD *)((char *)&v40.order + 6) = v20;
          WORD1(v40.ignoreRowsAndColumns) = 2080;
          WORD2(v40.order) = 1024;
          *(int **)((char *)&v40.ignoreRowsAndColumns + 4) = (int *)"Factored";
          WORD2(v40.malloc) = 1024;
          *(_DWORD *)((char *)&v40.malloc + 6) = v26;
          WORD1(v40.free) = 1024;
          HIDWORD(v40.free) = v22;
          __int16 v33 = &_os_log_internal;
          goto LABEL_72;
        }
        goto LABEL_7;
      }
LABEL_62:
      long long v52 = 0u;
      long long v53 = 0u;
      long long v50 = 0u;
      long long v51 = 0u;
      long long v48 = 0u;
      long long v49 = 0u;
      long long v46 = 0u;
      long long v47 = 0u;
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v41 = 0u;
      memset(&v40, 0, sizeof(v40));
      snprintf((char *)&v40, 0x100uLL, "%s (size %dx1) does not match dimensions of matrix factorization %s (%d x %d).\n");
      goto LABEL_63;
    }
    free = v40.free;
    Soln.rowCFIndex Count = v20;
    Soln.columnCFIndex Count = 1;
    *(_DWORD *)&Soln.attributes = 0;
    Soln.data = v21;
    Soln.columnStride = v20;
    *(_DWORD *)&v38.attributes = 0;
    v38.data = v23;
    v38.rowCFIndex Count = v22;
    v38.columnCFIndex Count = 1;
    v38.columnStride = v22;
    size_t v28 = v35 + v34.solveWorkspaceRequiredPerRHS;
    long long v29 = (void *)((uint64_t (*)(size_t))v40.malloc)(v35 + v34.solveWorkspaceRequiredPerRHS);
    if (v29)
    {
      long long v30 = v29;
      _SparseSolveOpaque_Float(&v34, &Soln, &v38, v29);
      ((void (*)(void *))free)(v30);
      return;
    }
    if (reportError)
    {
      long long v52 = 0u;
      long long v53 = 0u;
      long long v50 = 0u;
      long long v51 = 0u;
      long long v48 = 0u;
      long long v49 = 0u;
      long long v46 = 0u;
      long long v47 = 0u;
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v41 = 0u;
      memset(&v40, 0, sizeof(v40));
      snprintf((char *)&v40, 0x100uLL, "Failed to allocate workspace of size %ld for SparseSolve().\n");
      goto LABEL_63;
    }
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_7;
    }
    v40.control = 134217984;
    *(void *)&v40.orderMethod = v28;
    int v31 = &_os_log_internal;
    uint64_t v32 = "Failed to allocate workspace of size %ld for SparseSolve().\n";
LABEL_58:
    _os_log_error_impl(&dword_2153B7000, v31, OS_LOG_TYPE_ERROR, v32, (uint8_t *)&v40, 0xCu);
    goto LABEL_7;
  }
  if (!v40.reportError)
  {
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_7;
    }
    v40.control = 136315138;
    *(void *)&v40.orderMethod = "Factored";
    int v31 = &_os_log_internal;
    uint64_t v32 = "%s does not hold a completed matrix factorization.\n";
    goto LABEL_58;
  }
LABEL_47:
  long long v52 = 0u;
  long long v53 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v41 = 0u;
  memset(&v40, 0, sizeof(v40));
  snprintf((char *)&v40, 0x100uLL, "%s does not hold a completed matrix factorization.\n");
LABEL_63:
  ((void (*)(SparseSymbolicFactorOptions *))reportError)(&v40);
}

void cva::VecLibSparse<float>::solve(uint64_t a1, DenseMatrix_Float *a2, DenseMatrix_Float *a3, void *a4)
{
  uint64_t v62 = *MEMORY[0x263EF8340];
  if (a4)
  {
    long long v4 = *(_OWORD *)(a1 + 80);
    *(_OWORD *)&Factored.userFactorStorage = *(_OWORD *)(a1 + 64);
    *(_OWORD *)&Factored.solveWorkspaceRequiredStatic = v4;
    uint64_t v47 = *(void *)(a1 + 96);
    long long v5 = *(_OWORD *)(a1 + 16);
    *(_OWORD *)&Factored.status = *(_OWORD *)a1;
    *(_OWORD *)&Factored.symbolicFactorization.columnCFIndex Count = v5;
    long long v6 = *(_OWORD *)(a1 + 48);
    *(_OWORD *)&Factored.symbolicFactorization.workspaceSize_Float = *(_OWORD *)(a1 + 32);
    *(_OWORD *)&Factored.symbolicFactorization.factorSize_Float = v6;
    DenseMatrix_Float RHS = *a3;
    DenseMatrix_Float Soln = *a2;
    if (Factored.symbolicFactorization.status == SparseStatusOK && Factored.symbolicFactorization.workspaceSize_Float)
    {
      _SparseGetOptionsFromSymbolicFactor(&v48, &Factored.symbolicFactorization);
      reportError = v48.reportError;
      if (Factored.symbolicFactorization.status == SparseStatusOK
        && Factored.symbolicFactorization.workspaceSize_Float
        && Factored.status == SparseStatusOK
        && Factored.solveWorkspaceRequiredStatic)
      {
        if ((*(unsigned char *)&Factored.attributes ^ *(unsigned char *)&Factored.symbolicFactorization.attributes)) {
          int v13 = Factored.symbolicFactorization.columnCount * LOBYTE(Factored.symbolicFactorization.factorization);
        }
        else {
          int v13 = Factored.symbolicFactorization.rowCount * LOBYTE(Factored.symbolicFactorization.factorization);
        }
        if ((*(unsigned char *)&Factored.attributes ^ *(unsigned char *)&Factored.symbolicFactorization.attributes)) {
          int v14 = Factored.symbolicFactorization.rowCount * LOBYTE(Factored.symbolicFactorization.factorization);
        }
        else {
          int v14 = Factored.symbolicFactorization.columnCount * LOBYTE(Factored.symbolicFactorization.factorization);
        }
        if (BYTE1(Factored.symbolicFactorization.factorization) == 40) {
          int v15 = v13;
        }
        else {
          int v15 = v14;
        }
        if (RHS.columnStride < RHS.rowCount)
        {
          if (v48.reportError) {
            goto LABEL_48;
          }
          if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
          {
            v48.control = 136315906;
            *(void *)&v48.orderMethod = "B";
            WORD2(v48.order) = 1024;
            *(_DWORD *)((char *)&v48.order + 6) = RHS.columnStride;
            WORD1(v48.ignoreRowsAndColumns) = 2080;
            *(int **)((char *)&v48.ignoreRowsAndColumns + 4) = (int *)"B";
            WORD2(v48.malloc) = 1024;
            *(_DWORD *)((char *)&v48.malloc + 6) = RHS.rowCount;
            int v26 = &_os_log_internal;
LABEL_108:
            _os_log_error_impl(&dword_2153B7000, v26, OS_LOG_TYPE_ERROR, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n", (uint8_t *)&v48, 0x22u);
            goto LABEL_7;
          }
          goto LABEL_7;
        }
        if (Soln.columnStride < Soln.rowCount)
        {
          if (v48.reportError)
          {
LABEL_48:
            long long v60 = 0u;
            long long v61 = 0u;
            long long v58 = 0u;
            long long v59 = 0u;
            long long v56 = 0u;
            long long v57 = 0u;
            long long v54 = 0u;
            long long v55 = 0u;
            long long v52 = 0u;
            long long v53 = 0u;
            long long v50 = 0u;
            long long v51 = 0u;
            long long v49 = 0u;
            memset(&v48, 0, sizeof(v48));
            snprintf((char *)&v48, 0x100uLL, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n");
            goto LABEL_49;
          }
          if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
          {
            v48.control = 136315906;
            *(void *)&v48.orderMethod = "X";
            WORD2(v48.order) = 1024;
            *(_DWORD *)((char *)&v48.order + 6) = Soln.columnStride;
            WORD1(v48.ignoreRowsAndColumns) = 2080;
            *(int **)((char *)&v48.ignoreRowsAndColumns + 4) = (int *)"X";
            WORD2(v48.malloc) = 1024;
            *(_DWORD *)((char *)&v48.malloc + 6) = Soln.rowCount;
            int v26 = &_os_log_internal;
            goto LABEL_108;
          }
          goto LABEL_7;
        }
        if (*(unsigned char *)&RHS.attributes) {
          rowCFIndex Count = RHS.rowCount;
        }
        else {
          rowCFIndex Count = RHS.columnCount;
        }
        if (*(unsigned char *)&RHS.attributes) {
          columnCFIndex Count = RHS.columnCount;
        }
        else {
          columnCFIndex Count = RHS.rowCount;
        }
        if (*(unsigned char *)&Soln.attributes) {
          int v24 = Soln.rowCount;
        }
        else {
          int v24 = Soln.columnCount;
        }
        if (*(unsigned char *)&Soln.attributes) {
          int v25 = Soln.columnCount;
        }
        else {
          int v25 = Soln.rowCount;
        }
        if (rowCount != v24)
        {
          if (v48.reportError)
          {
            long long v60 = 0u;
            long long v61 = 0u;
            long long v58 = 0u;
            long long v59 = 0u;
            long long v56 = 0u;
            long long v57 = 0u;
            long long v54 = 0u;
            long long v55 = 0u;
            long long v52 = 0u;
            long long v53 = 0u;
            long long v50 = 0u;
            long long v51 = 0u;
            long long v49 = 0u;
            memset(&v48, 0, sizeof(v48));
            snprintf((char *)&v48, 0x100uLL, "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n", "B");
            goto LABEL_49;
          }
          if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
            goto LABEL_7;
          }
          v48.control = 136316418;
          *(void *)&v48.orderMethod = "B";
          WORD2(v48.order) = 1024;
          *(_DWORD *)((char *)&v48.order + 6) = columnCount;
          WORD1(v48.ignoreRowsAndColumns) = 1024;
          HIDWORD(v48.ignoreRowsAndColumns) = rowCount;
          LOWORD(v48.malloc) = 2080;
          *(void *(__cdecl **)(size_t))((char *)&v48.malloc + 2) = (void *(__cdecl *)(size_t))"X";
          WORD1(v48.free) = 1024;
          HIDWORD(v48.free) = v25;
          LOWORD(v48.reportError) = 1024;
          *(_DWORD *)((char *)&v48.reportError + 2) = v24;
          uint64_t v35 = &_os_log_internal;
          size_t v36 = "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n";
          goto LABEL_142;
        }
        if (rowCount > 0)
        {
          if (columnCount == v15)
          {
            if (v25 == v14)
            {
              _SparseSolveOpaque_Float(&Factored, &RHS, &Soln, a4);
              return;
            }
            if (v48.reportError)
            {
              long long v60 = 0u;
              long long v61 = 0u;
              long long v58 = 0u;
              long long v59 = 0u;
              long long v56 = 0u;
              long long v57 = 0u;
              long long v54 = 0u;
              long long v55 = 0u;
              long long v52 = 0u;
              long long v53 = 0u;
              long long v50 = 0u;
              long long v51 = 0u;
              long long v49 = 0u;
              memset(&v48, 0, sizeof(v48));
              uint64_t v37 = "X";
              goto LABEL_123;
            }
            if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
              goto LABEL_7;
            }
            v48.control = 136316418;
            *(void *)&v48.orderMethod = "X";
            WORD2(v48.order) = 1024;
            *(_DWORD *)((char *)&v48.order + 6) = v25;
            WORD1(v48.ignoreRowsAndColumns) = 1024;
            HIDWORD(v48.ignoreRowsAndColumns) = rowCount;
            LOWORD(v48.malloc) = 2080;
            *(void *(__cdecl **)(size_t))((char *)&v48.malloc + 2) = (void *(__cdecl *)(size_t))"matrix factorization Factored";
            WORD1(v48.free) = 1024;
            HIDWORD(v48.free) = v14;
            LOWORD(v48.reportError) = 1024;
            *(_DWORD *)((char *)&v48.reportError + 2) = v15;
            uint64_t v35 = &_os_log_internal;
            size_t v36 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
          }
          else
          {
            if (v48.reportError)
            {
              long long v60 = 0u;
              long long v61 = 0u;
              long long v58 = 0u;
              long long v59 = 0u;
              long long v56 = 0u;
              long long v57 = 0u;
              long long v54 = 0u;
              long long v55 = 0u;
              long long v52 = 0u;
              long long v53 = 0u;
              long long v50 = 0u;
              long long v51 = 0u;
              long long v49 = 0u;
              memset(&v48, 0, sizeof(v48));
              uint64_t v37 = "B";
LABEL_123:
              snprintf((char *)&v48, 0x100uLL, "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n", v37);
              goto LABEL_49;
            }
            if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
              goto LABEL_7;
            }
            v48.control = 136316418;
            *(void *)&v48.orderMethod = "B";
            WORD2(v48.order) = 1024;
            *(_DWORD *)((char *)&v48.order + 6) = columnCount;
            WORD1(v48.ignoreRowsAndColumns) = 1024;
            HIDWORD(v48.ignoreRowsAndColumns) = rowCount;
            LOWORD(v48.malloc) = 2080;
            *(void *(__cdecl **)(size_t))((char *)&v48.malloc + 2) = (void *(__cdecl *)(size_t))"matrix factorization Factored";
            WORD1(v48.free) = 1024;
            HIDWORD(v48.free) = v14;
            LOWORD(v48.reportError) = 1024;
            *(_DWORD *)((char *)&v48.reportError + 2) = v15;
            uint64_t v35 = &_os_log_internal;
            size_t v36 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
          }
LABEL_142:
          _os_log_error_impl(&dword_2153B7000, v35, OS_LOG_TYPE_ERROR, v36, (uint8_t *)&v48, 0x2Eu);
          goto LABEL_7;
        }
        if (v48.reportError)
        {
          long long v60 = 0u;
          long long v61 = 0u;
          long long v58 = 0u;
          long long v59 = 0u;
          long long v56 = 0u;
          long long v57 = 0u;
          long long v54 = 0u;
          long long v55 = 0u;
          long long v52 = 0u;
          long long v53 = 0u;
          long long v50 = 0u;
          long long v51 = 0u;
          long long v49 = 0u;
          memset(&v48, 0, sizeof(v48));
          snprintf((char *)&v48, 0x100uLL, "%s (%dx%d) must represent at least one right-hand side.\n");
          goto LABEL_49;
        }
        if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
          goto LABEL_7;
        }
        v48.control = 136315650;
        *(void *)&v48.orderMethod = "B";
        WORD2(v48.order) = 1024;
        *(_DWORD *)((char *)&v48.order + 6) = columnCount;
        WORD1(v48.ignoreRowsAndColumns) = 1024;
        HIDWORD(v48.ignoreRowsAndColumns) = rowCount;
        long long v39 = &_os_log_internal;
LABEL_133:
        _os_log_error_impl(&dword_2153B7000, v39, OS_LOG_TYPE_ERROR, "%s (%dx%d) must represent at least one right-hand side.\n", (uint8_t *)&v48, 0x18u);
        goto LABEL_7;
      }
      if (v48.reportError)
      {
        long long v60 = 0u;
        long long v61 = 0u;
        long long v58 = 0u;
        long long v59 = 0u;
        long long v56 = 0u;
        long long v57 = 0u;
        long long v54 = 0u;
        long long v55 = 0u;
        long long v52 = 0u;
        long long v53 = 0u;
        long long v50 = 0u;
        long long v51 = 0u;
        long long v49 = 0u;
        memset(&v48, 0, sizeof(v48));
        snprintf((char *)&v48, 0x100uLL, "%s does not hold a completed matrix factorization.\n");
LABEL_49:
        ((void (*)(SparseSymbolicFactorOptions *))reportError)(&v48);
        return;
      }
      if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
        goto LABEL_7;
      }
      v48.control = 136315138;
      *(void *)&v48.orderMethod = "Factored";
      int v20 = &_os_log_internal;
      long long v21 = "%s does not hold a completed matrix factorization.\n";
LABEL_77:
      _os_log_error_impl(&dword_2153B7000, v20, OS_LOG_TYPE_ERROR, v21, (uint8_t *)&v48, 0xCu);
      goto LABEL_7;
    }
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_7;
    }
    LOWORD(v48.control) = 0;
    long long v7 = &_os_log_internal;
LABEL_74:
    _os_log_error_impl(&dword_2153B7000, v7, OS_LOG_TYPE_ERROR, "Factored does not hold a completed matrix factorization.\n", (uint8_t *)&v48, 2u);
    goto LABEL_7;
  }
  long long v8 = *(_OWORD *)(a1 + 80);
  *(_OWORD *)&v42.userFactorStorage = *(_OWORD *)(a1 + 64);
  *(_OWORD *)&v42.solveWorkspaceRequiredStatic = v8;
  uint64_t v43 = *(void *)(a1 + 96);
  long long v9 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)&v42.status = *(_OWORD *)a1;
  *(_OWORD *)&v42.symbolicFactorization.columnCFIndex Count = v9;
  long long v10 = *(_OWORD *)(a1 + 48);
  *(_OWORD *)&v42.symbolicFactorization.workspaceSize_Float = *(_OWORD *)(a1 + 32);
  *(_OWORD *)&v42.symbolicFactorization.factorSize_Float = v10;
  DenseMatrix_Float v41 = *a3;
  DenseMatrix_Float v40 = *a2;
  if (v42.symbolicFactorization.status || !v42.symbolicFactorization.workspaceSize_Float)
  {
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_7;
    }
    LOWORD(v48.control) = 0;
    long long v7 = &_os_log_internal;
    goto LABEL_74;
  }
  _SparseGetOptionsFromSymbolicFactor(&v48, &v42.symbolicFactorization);
  long long v16 = v48.reportError;
  if (v42.symbolicFactorization.status
    || !v42.symbolicFactorization.workspaceSize_Float
    || v42.status
    || !v42.solveWorkspaceRequiredStatic)
  {
    if (!v48.reportError)
    {
      if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
        goto LABEL_7;
      }
      v48.control = 136315138;
      *(void *)&v48.orderMethod = "Factored";
      int v20 = &_os_log_internal;
      long long v21 = "%s does not hold a completed matrix factorization.\n";
      goto LABEL_77;
    }
    long long v60 = 0u;
    long long v61 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v49 = 0u;
    memset(&v48, 0, sizeof(v48));
    snprintf((char *)&v48, 0x100uLL, "%s does not hold a completed matrix factorization.\n");
LABEL_55:
    ((void (*)(SparseSymbolicFactorOptions *))v16)(&v48);
    return;
  }
  if ((*(unsigned char *)&v42.attributes ^ *(unsigned char *)&v42.symbolicFactorization.attributes)) {
    int v17 = v42.symbolicFactorization.columnCount * LOBYTE(v42.symbolicFactorization.factorization);
  }
  else {
    int v17 = v42.symbolicFactorization.rowCount * LOBYTE(v42.symbolicFactorization.factorization);
  }
  if ((*(unsigned char *)&v42.attributes ^ *(unsigned char *)&v42.symbolicFactorization.attributes)) {
    int v18 = v42.symbolicFactorization.rowCount * LOBYTE(v42.symbolicFactorization.factorization);
  }
  else {
    int v18 = v42.symbolicFactorization.columnCount * LOBYTE(v42.symbolicFactorization.factorization);
  }
  if (BYTE1(v42.symbolicFactorization.factorization) == 40) {
    int v19 = v17;
  }
  else {
    int v19 = v18;
  }
  if (v41.columnStride < v41.rowCount)
  {
    if (!v48.reportError)
    {
      if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
      {
        v48.control = 136315906;
        *(void *)&v48.orderMethod = "B";
        WORD2(v48.order) = 1024;
        *(_DWORD *)((char *)&v48.order + 6) = v41.columnStride;
        WORD1(v48.ignoreRowsAndColumns) = 2080;
        *(int **)((char *)&v48.ignoreRowsAndColumns + 4) = (int *)"B";
        WORD2(v48.malloc) = 1024;
        *(_DWORD *)((char *)&v48.malloc + 6) = v41.rowCount;
        int v26 = &_os_log_internal;
        goto LABEL_108;
      }
LABEL_7:
      _SparseTrap();
      return;
    }
    goto LABEL_54;
  }
  if (v40.columnStride < v40.rowCount)
  {
    if (!v48.reportError)
    {
      if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
      {
        v48.control = 136315906;
        *(void *)&v48.orderMethod = "X";
        WORD2(v48.order) = 1024;
        *(_DWORD *)((char *)&v48.order + 6) = v40.columnStride;
        WORD1(v48.ignoreRowsAndColumns) = 2080;
        *(int **)((char *)&v48.ignoreRowsAndColumns + 4) = (int *)"X";
        WORD2(v48.malloc) = 1024;
        *(_DWORD *)((char *)&v48.malloc + 6) = v40.rowCount;
        int v26 = &_os_log_internal;
        goto LABEL_108;
      }
      goto LABEL_7;
    }
LABEL_54:
    long long v60 = 0u;
    long long v61 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v49 = 0u;
    memset(&v48, 0, sizeof(v48));
    snprintf((char *)&v48, 0x100uLL, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n");
    goto LABEL_55;
  }
  if (*(unsigned char *)&v41.attributes) {
    uint64_t v27 = v41.rowCount;
  }
  else {
    uint64_t v27 = v41.columnCount;
  }
  if (*(unsigned char *)&v41.attributes) {
    int v28 = v41.columnCount;
  }
  else {
    int v28 = v41.rowCount;
  }
  if (*(unsigned char *)&v40.attributes) {
    int v29 = v40.rowCount;
  }
  else {
    int v29 = v40.columnCount;
  }
  if (*(unsigned char *)&v40.attributes) {
    int v30 = v40.columnCount;
  }
  else {
    int v30 = v40.rowCount;
  }
  if (v27 != v29)
  {
    if (!v48.reportError)
    {
      if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
        goto LABEL_7;
      }
      v48.control = 136316418;
      *(void *)&v48.orderMethod = "B";
      WORD2(v48.order) = 1024;
      *(_DWORD *)((char *)&v48.order + 6) = v28;
      WORD1(v48.ignoreRowsAndColumns) = 1024;
      HIDWORD(v48.ignoreRowsAndColumns) = v27;
      LOWORD(v48.malloc) = 2080;
      *(void *(__cdecl **)(size_t))((char *)&v48.malloc + 2) = (void *(__cdecl *)(size_t))"X";
      WORD1(v48.free) = 1024;
      HIDWORD(v48.free) = v30;
      LOWORD(v48.reportError) = 1024;
      *(_DWORD *)((char *)&v48.reportError + 2) = v29;
      uint64_t v35 = &_os_log_internal;
      size_t v36 = "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n";
      goto LABEL_142;
    }
    long long v60 = 0u;
    long long v61 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v49 = 0u;
    memset(&v48, 0, sizeof(v48));
    snprintf((char *)&v48, 0x100uLL, "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n", "B");
    goto LABEL_55;
  }
  if ((int)v27 <= 0)
  {
    if (!v48.reportError)
    {
      if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
        goto LABEL_7;
      }
      v48.control = 136315650;
      *(void *)&v48.orderMethod = "B";
      WORD2(v48.order) = 1024;
      *(_DWORD *)((char *)&v48.order + 6) = v28;
      WORD1(v48.ignoreRowsAndColumns) = 1024;
      HIDWORD(v48.ignoreRowsAndColumns) = v27;
      long long v39 = &_os_log_internal;
      goto LABEL_133;
    }
    long long v60 = 0u;
    long long v61 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v49 = 0u;
    memset(&v48, 0, sizeof(v48));
    snprintf((char *)&v48, 0x100uLL, "%s (%dx%d) must represent at least one right-hand side.\n");
    goto LABEL_55;
  }
  if (v28 != v19)
  {
    if (!v48.reportError)
    {
      if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
        goto LABEL_7;
      }
      v48.control = 136316418;
      *(void *)&v48.orderMethod = "B";
      WORD2(v48.order) = 1024;
      *(_DWORD *)((char *)&v48.order + 6) = v28;
      WORD1(v48.ignoreRowsAndColumns) = 1024;
      HIDWORD(v48.ignoreRowsAndColumns) = v27;
      LOWORD(v48.malloc) = 2080;
      *(void *(__cdecl **)(size_t))((char *)&v48.malloc + 2) = (void *(__cdecl *)(size_t))"matrix factorization Factored";
      WORD1(v48.free) = 1024;
      HIDWORD(v48.free) = v18;
      LOWORD(v48.reportError) = 1024;
      *(_DWORD *)((char *)&v48.reportError + 2) = v19;
      uint64_t v35 = &_os_log_internal;
      size_t v36 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
      goto LABEL_142;
    }
    long long v60 = 0u;
    long long v61 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v49 = 0u;
    memset(&v48, 0, sizeof(v48));
    DenseMatrix_Float v38 = "B";
    goto LABEL_130;
  }
  if (v30 != v18)
  {
    if (!v48.reportError)
    {
      if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
        goto LABEL_7;
      }
      v48.control = 136316418;
      *(void *)&v48.orderMethod = "X";
      WORD2(v48.order) = 1024;
      *(_DWORD *)((char *)&v48.order + 6) = v30;
      WORD1(v48.ignoreRowsAndColumns) = 1024;
      HIDWORD(v48.ignoreRowsAndColumns) = v27;
      LOWORD(v48.malloc) = 2080;
      *(void *(__cdecl **)(size_t))((char *)&v48.malloc + 2) = (void *(__cdecl *)(size_t))"matrix factorization Factored";
      WORD1(v48.free) = 1024;
      HIDWORD(v48.free) = v18;
      LOWORD(v48.reportError) = 1024;
      *(_DWORD *)((char *)&v48.reportError + 2) = v19;
      uint64_t v35 = &_os_log_internal;
      size_t v36 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
      goto LABEL_142;
    }
    long long v60 = 0u;
    long long v61 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v49 = 0u;
    memset(&v48, 0, sizeof(v48));
    DenseMatrix_Float v38 = "X";
LABEL_130:
    snprintf((char *)&v48, 0x100uLL, "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n", v38);
    goto LABEL_55;
  }
  free = v48.free;
  size_t v32 = v42.solveWorkspaceRequiredPerRHS + v43 * v27;
  __int16 v33 = (void *)((uint64_t (*)(size_t))v48.malloc)(v32);
  if (!v33)
  {
    if (!v16)
    {
      if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
        goto LABEL_7;
      }
      v48.control = 134217984;
      *(void *)&v48.orderMethod = v32;
      int v20 = &_os_log_internal;
      long long v21 = "Failed to allocate workspace of size %ld for SparseSolve().\n";
      goto LABEL_77;
    }
    long long v60 = 0u;
    long long v61 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v49 = 0u;
    memset(&v48, 0, sizeof(v48));
    snprintf((char *)&v48, 0x100uLL, "Failed to allocate workspace of size %ld for SparseSolve().\n");
    goto LABEL_55;
  }
  SparseOpaqueFactorization_Float v34 = v33;
  _SparseSolveOpaque_Float(&v42, &v41, &v40, v33);
  ((void (*)(void *))free)(v34);
}

void cva::VecLibSparse<float>::solve(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v45 = *MEMORY[0x263EF8340];
  if (a3)
  {
    long long v3 = *(_OWORD *)(a1 + 80);
    *(_OWORD *)&Factored.userFactorStorage = *(_OWORD *)(a1 + 64);
    *(_OWORD *)&Factored.solveWorkspaceRequiredStatic = v3;
    uint64_t v29 = *(void *)(a1 + 96);
    long long v4 = *(_OWORD *)(a1 + 16);
    *(_OWORD *)&Factored.status = *(_OWORD *)a1;
    *(_OWORD *)&Factored.symbolicFactorization.columnCFIndex Count = v4;
    long long v5 = *(_OWORD *)(a1 + 48);
    *(_OWORD *)&Factored.symbolicFactorization.workspaceSize_Float = *(_OWORD *)(a1 + 32);
    *(_OWORD *)&Factored.symbolicFactorization.factorSize_Float = v5;
    if (Factored.symbolicFactorization.status == SparseStatusOK && Factored.symbolicFactorization.workspaceSize_Float)
    {
      SparseControl_t v11 = *(_DWORD *)a2;
      SparseControl_t v12 = *(int **)(a2 + 8);
      _SparseGetOptionsFromSymbolicFactor(&v31, &Factored.symbolicFactorization);
      reportError = v31.reportError;
      if (Factored.symbolicFactorization.status == SparseStatusOK
        && Factored.symbolicFactorization.workspaceSize_Float
        && Factored.status == SparseStatusOK
        && Factored.solveWorkspaceRequiredStatic)
      {
        int v14 = Factored.symbolicFactorization.columnCount * LOBYTE(Factored.symbolicFactorization.factorization);
        if (Factored.symbolicFactorization.rowCount * LOBYTE(Factored.symbolicFactorization.factorization) > v14) {
          int v14 = Factored.symbolicFactorization.rowCount * LOBYTE(Factored.symbolicFactorization.factorization);
        }
        if (v14 == v11)
        {
          v31.control = v11;
          *(_DWORD *)&v31.orderMethod = 1;
          v31.ignoreRowsAndColumns = v12;
          v31.order = (int *)v11;
          _SparseSolveOpaque_Float(&Factored, 0, (const DenseMatrix_Float *)&v31, a3);
          return;
        }
        if (v31.reportError)
        {
          long long v43 = 0u;
          long long v44 = 0u;
          long long v41 = 0u;
          long long v42 = 0u;
          long long v39 = 0u;
          long long v40 = 0u;
          long long v37 = 0u;
          long long v38 = 0u;
          long long v35 = 0u;
          long long v36 = 0u;
          long long v33 = 0u;
          long long v34 = 0u;
          long long v32 = 0u;
          memset(&v31, 0, sizeof(v31));
          snprintf((char *)&v31, 0x100uLL, "%s.count (%d) is not equal to largest dimension of matrix factorization %s.\n");
          goto LABEL_34;
        }
        if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
          goto LABEL_7;
        }
        v31.control = 136315650;
        *(void *)&v31.orderMethod = "xb";
        WORD2(v31.order) = 1024;
        *(_DWORD *)((char *)&v31.order + 6) = v11;
        WORD1(v31.ignoreRowsAndColumns) = 2080;
        *(int **)((char *)&v31.ignoreRowsAndColumns + 4) = (int *)"Factored";
        int v25 = &_os_log_internal;
        goto LABEL_51;
      }
      if (v31.reportError)
      {
        long long v43 = 0u;
        long long v44 = 0u;
        long long v41 = 0u;
        long long v42 = 0u;
        long long v39 = 0u;
        long long v40 = 0u;
        long long v37 = 0u;
        long long v38 = 0u;
        long long v35 = 0u;
        long long v36 = 0u;
        long long v33 = 0u;
        long long v34 = 0u;
        long long v32 = 0u;
        memset(&v31, 0, sizeof(v31));
        snprintf((char *)&v31, 0x100uLL, "%s does not hold a completed matrix factorization.\n");
LABEL_34:
        ((void (*)(SparseSymbolicFactorOptions *))reportError)(&v31);
        return;
      }
      if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
        goto LABEL_7;
      }
      v31.control = 136315138;
      *(void *)&v31.orderMethod = "Factored";
      long long v23 = &_os_log_internal;
      int v24 = "%s does not hold a completed matrix factorization.\n";
      goto LABEL_43;
    }
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v31.control) = 0;
      long long v6 = &_os_log_internal;
LABEL_40:
      _os_log_error_impl(&dword_2153B7000, v6, OS_LOG_TYPE_ERROR, "Factored does not hold a completed matrix factorization.\n", (uint8_t *)&v31, 2u);
      goto LABEL_7;
    }
    goto LABEL_7;
  }
  long long v7 = *(_OWORD *)(a1 + 80);
  *(_OWORD *)&v26.userFactorStorage = *(_OWORD *)(a1 + 64);
  *(_OWORD *)&v26.solveWorkspaceRequiredStatic = v7;
  uint64_t v27 = *(void *)(a1 + 96);
  long long v8 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)&v26.status = *(_OWORD *)a1;
  *(_OWORD *)&v26.symbolicFactorization.columnCFIndex Count = v8;
  long long v9 = *(_OWORD *)(a1 + 48);
  *(_OWORD *)&v26.symbolicFactorization.workspaceSize_Float = *(_OWORD *)(a1 + 32);
  *(_OWORD *)&v26.symbolicFactorization.factorSize_Float = v9;
  if (v26.symbolicFactorization.status == SparseStatusOK && v26.symbolicFactorization.workspaceSize_Float)
  {
    int v15 = *(_DWORD *)a2;
    long long v16 = *(float **)(a2 + 8);
    _SparseGetOptionsFromSymbolicFactor(&v31, &v26.symbolicFactorization);
    int v17 = v31.reportError;
    if (v26.symbolicFactorization.status
      || !v26.symbolicFactorization.workspaceSize_Float
      || v26.status
      || !v26.solveWorkspaceRequiredStatic)
    {
      if (!v31.reportError)
      {
        if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
          goto LABEL_7;
        }
        v31.control = 136315138;
        *(void *)&v31.orderMethod = "Factored";
        long long v23 = &_os_log_internal;
        int v24 = "%s does not hold a completed matrix factorization.\n";
        goto LABEL_43;
      }
      long long v43 = 0u;
      long long v44 = 0u;
      long long v41 = 0u;
      long long v42 = 0u;
      long long v39 = 0u;
      long long v40 = 0u;
      long long v37 = 0u;
      long long v38 = 0u;
      long long v35 = 0u;
      long long v36 = 0u;
      long long v33 = 0u;
      long long v34 = 0u;
      long long v32 = 0u;
      memset(&v31, 0, sizeof(v31));
      snprintf((char *)&v31, 0x100uLL, "%s does not hold a completed matrix factorization.\n");
    }
    else
    {
      int v18 = v26.symbolicFactorization.columnCount * LOBYTE(v26.symbolicFactorization.factorization);
      if (v26.symbolicFactorization.rowCount * LOBYTE(v26.symbolicFactorization.factorization) > v18) {
        int v18 = v26.symbolicFactorization.rowCount * LOBYTE(v26.symbolicFactorization.factorization);
      }
      if (v18 == v15)
      {
        free = v31.free;
        Soln.rowCFIndex Count = v15;
        Soln.columnCFIndex Count = 1;
        *(_DWORD *)&Soln.attributes = 0;
        Soln.data = v16;
        Soln.columnStride = v15;
        size_t v20 = v27 + v26.solveWorkspaceRequiredPerRHS;
        long long v21 = (void *)((uint64_t (*)(size_t))v31.malloc)(v27 + v26.solveWorkspaceRequiredPerRHS);
        if (v21)
        {
          int v22 = v21;
          _SparseSolveOpaque_Float(&v26, 0, &Soln, v21);
          ((void (*)(void *))free)(v22);
          return;
        }
        if (v17)
        {
          long long v43 = 0u;
          long long v44 = 0u;
          long long v41 = 0u;
          long long v42 = 0u;
          long long v39 = 0u;
          long long v40 = 0u;
          long long v37 = 0u;
          long long v38 = 0u;
          long long v35 = 0u;
          long long v36 = 0u;
          long long v33 = 0u;
          long long v34 = 0u;
          long long v32 = 0u;
          memset(&v31, 0, sizeof(v31));
          snprintf((char *)&v31, 0x100uLL, "Failed to allocate workspace of size %ld for SparseSolve().\n");
          goto LABEL_48;
        }
        if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
          goto LABEL_7;
        }
        v31.control = 134217984;
        *(void *)&v31.orderMethod = v20;
        long long v23 = &_os_log_internal;
        int v24 = "Failed to allocate workspace of size %ld for SparseSolve().\n";
LABEL_43:
        _os_log_error_impl(&dword_2153B7000, v23, OS_LOG_TYPE_ERROR, v24, (uint8_t *)&v31, 0xCu);
        goto LABEL_7;
      }
      if (!v31.reportError)
      {
        if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
        {
          v31.control = 136315650;
          *(void *)&v31.orderMethod = "xb";
          WORD2(v31.order) = 1024;
          *(_DWORD *)((char *)&v31.order + 6) = v15;
          WORD1(v31.ignoreRowsAndColumns) = 2080;
          *(int **)((char *)&v31.ignoreRowsAndColumns + 4) = (int *)"Factored";
          int v25 = &_os_log_internal;
LABEL_51:
          _os_log_error_impl(&dword_2153B7000, v25, OS_LOG_TYPE_ERROR, "%s.count (%d) is not equal to largest dimension of matrix factorization %s.\n", (uint8_t *)&v31, 0x1Cu);
          goto LABEL_7;
        }
        goto LABEL_7;
      }
      long long v43 = 0u;
      long long v44 = 0u;
      long long v41 = 0u;
      long long v42 = 0u;
      long long v39 = 0u;
      long long v40 = 0u;
      long long v37 = 0u;
      long long v38 = 0u;
      long long v35 = 0u;
      long long v36 = 0u;
      long long v33 = 0u;
      long long v34 = 0u;
      long long v32 = 0u;
      memset(&v31, 0, sizeof(v31));
      snprintf((char *)&v31, 0x100uLL, "%s.count (%d) is not equal to largest dimension of matrix factorization %s.\n");
    }
LABEL_48:
    ((void (*)(SparseSymbolicFactorOptions *))v17)(&v31);
    return;
  }
  if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v31.control) = 0;
    long long v6 = &_os_log_internal;
    goto LABEL_40;
  }
LABEL_7:
  _SparseTrap();
}

void cva::VecLibSparse<float>::solve(uint64_t a1, DenseMatrix_Float *a2, void *a3)
{
  uint64_t v48 = *MEMORY[0x263EF8340];
  if (a3)
  {
    long long v3 = *(_OWORD *)(a1 + 80);
    *(_OWORD *)&Factored.userFactorStorage = *(_OWORD *)(a1 + 64);
    *(_OWORD *)&Factored.solveWorkspaceRequiredStatic = v3;
    uint64_t v33 = *(void *)(a1 + 96);
    long long v4 = *(_OWORD *)(a1 + 16);
    *(_OWORD *)&Factored.status = *(_OWORD *)a1;
    *(_OWORD *)&Factored.symbolicFactorization.columnCFIndex Count = v4;
    long long v5 = *(_OWORD *)(a1 + 48);
    *(_OWORD *)&Factored.symbolicFactorization.workspaceSize_Float = *(_OWORD *)(a1 + 32);
    *(_OWORD *)&Factored.symbolicFactorization.factorSize_Float = v5;
    DenseMatrix_Float Soln = *a2;
    if (Factored.symbolicFactorization.status == SparseStatusOK && Factored.symbolicFactorization.workspaceSize_Float)
    {
      _SparseGetOptionsFromSymbolicFactor(&v34, &Factored.symbolicFactorization);
      reportError = v34.reportError;
      if (Factored.symbolicFactorization.status == SparseStatusOK
        && Factored.symbolicFactorization.workspaceSize_Float
        && Factored.status == SparseStatusOK
        && Factored.solveWorkspaceRequiredStatic)
      {
        if (Soln.columnStride < Soln.rowCount)
        {
          if (v34.reportError)
          {
            long long v46 = 0u;
            long long v47 = 0u;
            long long v44 = 0u;
            long long v45 = 0u;
            long long v42 = 0u;
            long long v43 = 0u;
            long long v40 = 0u;
            long long v41 = 0u;
            long long v38 = 0u;
            long long v39 = 0u;
            long long v36 = 0u;
            long long v37 = 0u;
            long long v35 = 0u;
            memset(&v34, 0, sizeof(v34));
            snprintf((char *)&v34, 0x100uLL, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n");
LABEL_27:
            ((void (*)(SparseSymbolicFactorOptions *))reportError)(&v34);
            return;
          }
          if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
            goto LABEL_7;
          }
          v34.control = 136315906;
          *(void *)&v34.orderMethod = "XB";
          WORD2(v34.order) = 1024;
          *(_DWORD *)((char *)&v34.order + 6) = Soln.columnStride;
          WORD1(v34.ignoreRowsAndColumns) = 2080;
          *(int **)((char *)&v34.ignoreRowsAndColumns + 4) = (int *)"XB";
          WORD2(v34.malloc) = 1024;
          *(_DWORD *)((char *)&v34.malloc + 6) = Soln.rowCount;
          int v25 = &_os_log_internal;
          goto LABEL_71;
        }
        if (*(unsigned char *)&Soln.attributes) {
          columnCFIndex Count = Soln.columnCount;
        }
        else {
          columnCFIndex Count = Soln.rowCount;
        }
        if (*(unsigned char *)&Soln.attributes) {
          rowCFIndex Count = Soln.rowCount;
        }
        else {
          rowCFIndex Count = Soln.columnCount;
        }
        if (rowCount > 0)
        {
          if (Factored.symbolicFactorization.rowCount * LOBYTE(Factored.symbolicFactorization.factorization) <= Factored.symbolicFactorization.columnCount * LOBYTE(Factored.symbolicFactorization.factorization)) {
            int v15 = Factored.symbolicFactorization.columnCount * LOBYTE(Factored.symbolicFactorization.factorization);
          }
          else {
            int v15 = Factored.symbolicFactorization.rowCount * LOBYTE(Factored.symbolicFactorization.factorization);
          }
          if (columnCount == v15)
          {
            _SparseSolveOpaque_Float(&Factored, 0, &Soln, a3);
            return;
          }
          if (v34.reportError)
          {
            long long v46 = 0u;
            long long v47 = 0u;
            long long v44 = 0u;
            long long v45 = 0u;
            long long v42 = 0u;
            long long v43 = 0u;
            long long v40 = 0u;
            long long v41 = 0u;
            long long v38 = 0u;
            long long v39 = 0u;
            long long v36 = 0u;
            long long v37 = 0u;
            long long v35 = 0u;
            memset(&v34, 0, sizeof(v34));
            snprintf((char *)&v34, 0x100uLL, "%s (%dx%d) is not consistent with largest dimension of matrix factorization %s (%d).\n");
            goto LABEL_27;
          }
          if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
            goto LABEL_7;
          }
          v34.control = 136316162;
          *(void *)&v34.orderMethod = "XB";
          WORD2(v34.order) = 1024;
          *(_DWORD *)((char *)&v34.order + 6) = columnCount;
          WORD1(v34.ignoreRowsAndColumns) = 1024;
          HIDWORD(v34.ignoreRowsAndColumns) = rowCount;
          LOWORD(v34.malloc) = 2080;
          *(void *(__cdecl **)(size_t))((char *)&v34.malloc + 2) = (void *(__cdecl *)(size_t))"Factored";
          WORD1(v34.free) = 1024;
          HIDWORD(v34.free) = v15;
          uint64_t v27 = &_os_log_internal;
          goto LABEL_87;
        }
        if (v34.reportError)
        {
          long long v46 = 0u;
          long long v47 = 0u;
          long long v44 = 0u;
          long long v45 = 0u;
          long long v42 = 0u;
          long long v43 = 0u;
          long long v40 = 0u;
          long long v41 = 0u;
          long long v38 = 0u;
          long long v39 = 0u;
          long long v36 = 0u;
          long long v37 = 0u;
          long long v35 = 0u;
          memset(&v34, 0, sizeof(v34));
          snprintf((char *)&v34, 0x100uLL, "%s (%dx%d) must represent at least one right-hand side.\n");
          goto LABEL_27;
        }
        if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
          goto LABEL_7;
        }
        v34.control = 136315650;
        *(void *)&v34.orderMethod = "XB";
        WORD2(v34.order) = 1024;
        *(_DWORD *)((char *)&v34.order + 6) = columnCount;
        WORD1(v34.ignoreRowsAndColumns) = 1024;
        HIDWORD(v34.ignoreRowsAndColumns) = rowCount;
        SparseOpaqueFactorization_Float v26 = &_os_log_internal;
LABEL_82:
        _os_log_error_impl(&dword_2153B7000, v26, OS_LOG_TYPE_ERROR, "%s (%dx%d) must represent at least one right-hand side.\n", (uint8_t *)&v34, 0x18u);
        goto LABEL_7;
      }
      if (v34.reportError)
      {
        long long v46 = 0u;
        long long v47 = 0u;
        long long v44 = 0u;
        long long v45 = 0u;
        long long v42 = 0u;
        long long v43 = 0u;
        long long v40 = 0u;
        long long v41 = 0u;
        long long v38 = 0u;
        long long v39 = 0u;
        long long v36 = 0u;
        long long v37 = 0u;
        long long v35 = 0u;
        memset(&v34, 0, sizeof(v34));
        snprintf((char *)&v34, 0x100uLL, "%s does not hold a completed matrix factorization.\n");
        goto LABEL_27;
      }
      if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
        goto LABEL_7;
      }
      v34.control = 136315138;
      *(void *)&v34.orderMethod = "Factored";
      long long v16 = &_os_log_internal;
      int v17 = "%s does not hold a completed matrix factorization.\n";
      goto LABEL_62;
    }
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v34.control) = 0;
      long long v6 = &_os_log_internal;
LABEL_59:
      _os_log_error_impl(&dword_2153B7000, v6, OS_LOG_TYPE_ERROR, "Factored does not hold a completed matrix factorization.\n", (uint8_t *)&v34, 2u);
      goto LABEL_7;
    }
    goto LABEL_7;
  }
  long long v7 = *(_OWORD *)(a1 + 80);
  *(_OWORD *)&v29.userFactorStorage = *(_OWORD *)(a1 + 64);
  *(_OWORD *)&v29.solveWorkspaceRequiredStatic = v7;
  uint64_t v30 = *(void *)(a1 + 96);
  long long v8 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)&v29.status = *(_OWORD *)a1;
  *(_OWORD *)&v29.symbolicFactorization.columnCFIndex Count = v8;
  long long v9 = *(_OWORD *)(a1 + 48);
  *(_OWORD *)&v29.symbolicFactorization.workspaceSize_Float = *(_OWORD *)(a1 + 32);
  *(_OWORD *)&v29.symbolicFactorization.factorSize_Float = v9;
  DenseMatrix_Float v28 = *a2;
  if (v29.symbolicFactorization.status == SparseStatusOK && v29.symbolicFactorization.workspaceSize_Float)
  {
    _SparseGetOptionsFromSymbolicFactor(&v34, &v29.symbolicFactorization);
    SparseControl_t v12 = v34.reportError;
    if (v29.symbolicFactorization.status
      || !v29.symbolicFactorization.workspaceSize_Float
      || v29.status
      || !v29.solveWorkspaceRequiredStatic)
    {
      if (v34.reportError)
      {
        long long v46 = 0u;
        long long v47 = 0u;
        long long v44 = 0u;
        long long v45 = 0u;
        long long v42 = 0u;
        long long v43 = 0u;
        long long v40 = 0u;
        long long v41 = 0u;
        long long v38 = 0u;
        long long v39 = 0u;
        long long v36 = 0u;
        long long v37 = 0u;
        long long v35 = 0u;
        memset(&v34, 0, sizeof(v34));
        snprintf((char *)&v34, 0x100uLL, "%s does not hold a completed matrix factorization.\n");
        goto LABEL_30;
      }
      if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
        goto LABEL_7;
      }
      v34.control = 136315138;
      *(void *)&v34.orderMethod = "Factored";
      long long v16 = &_os_log_internal;
      int v17 = "%s does not hold a completed matrix factorization.\n";
    }
    else
    {
      if (v28.columnStride < v28.rowCount)
      {
        if (!v34.reportError)
        {
          if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
          {
            v34.control = 136315906;
            *(void *)&v34.orderMethod = "XB";
            WORD2(v34.order) = 1024;
            *(_DWORD *)((char *)&v34.order + 6) = v28.columnStride;
            WORD1(v34.ignoreRowsAndColumns) = 2080;
            *(int **)((char *)&v34.ignoreRowsAndColumns + 4) = (int *)"XB";
            WORD2(v34.malloc) = 1024;
            *(_DWORD *)((char *)&v34.malloc + 6) = v28.rowCount;
            int v25 = &_os_log_internal;
LABEL_71:
            _os_log_error_impl(&dword_2153B7000, v25, OS_LOG_TYPE_ERROR, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n", (uint8_t *)&v34, 0x22u);
            goto LABEL_7;
          }
          goto LABEL_7;
        }
        long long v46 = 0u;
        long long v47 = 0u;
        long long v44 = 0u;
        long long v45 = 0u;
        long long v42 = 0u;
        long long v43 = 0u;
        long long v40 = 0u;
        long long v41 = 0u;
        long long v38 = 0u;
        long long v39 = 0u;
        long long v36 = 0u;
        long long v37 = 0u;
        long long v35 = 0u;
        memset(&v34, 0, sizeof(v34));
        snprintf((char *)&v34, 0x100uLL, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n");
LABEL_30:
        ((void (*)(SparseSymbolicFactorOptions *))v12)(&v34);
        return;
      }
      if (*(unsigned char *)&v28.attributes) {
        int v18 = v28.columnCount;
      }
      else {
        int v18 = v28.rowCount;
      }
      if (*(unsigned char *)&v28.attributes) {
        uint64_t v19 = v28.rowCount;
      }
      else {
        uint64_t v19 = v28.columnCount;
      }
      if ((int)v19 <= 0)
      {
        if (!v34.reportError)
        {
          if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
            goto LABEL_7;
          }
          v34.control = 136315650;
          *(void *)&v34.orderMethod = "XB";
          WORD2(v34.order) = 1024;
          *(_DWORD *)((char *)&v34.order + 6) = v18;
          WORD1(v34.ignoreRowsAndColumns) = 1024;
          HIDWORD(v34.ignoreRowsAndColumns) = v19;
          SparseOpaqueFactorization_Float v26 = &_os_log_internal;
          goto LABEL_82;
        }
        long long v46 = 0u;
        long long v47 = 0u;
        long long v44 = 0u;
        long long v45 = 0u;
        long long v42 = 0u;
        long long v43 = 0u;
        long long v40 = 0u;
        long long v41 = 0u;
        long long v38 = 0u;
        long long v39 = 0u;
        long long v36 = 0u;
        long long v37 = 0u;
        long long v35 = 0u;
        memset(&v34, 0, sizeof(v34));
        snprintf((char *)&v34, 0x100uLL, "%s (%dx%d) must represent at least one right-hand side.\n");
        goto LABEL_30;
      }
      if (v29.symbolicFactorization.rowCount * LOBYTE(v29.symbolicFactorization.factorization) <= v29.symbolicFactorization.columnCount
                                                                                                 * LOBYTE(v29.symbolicFactorization.factorization))
        int v20 = v29.symbolicFactorization.columnCount * LOBYTE(v29.symbolicFactorization.factorization);
      else {
        int v20 = v29.symbolicFactorization.rowCount * LOBYTE(v29.symbolicFactorization.factorization);
      }
      if (v18 != v20)
      {
        if (!v34.reportError)
        {
          if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
            goto LABEL_7;
          }
          v34.control = 136316162;
          *(void *)&v34.orderMethod = "XB";
          WORD2(v34.order) = 1024;
          *(_DWORD *)((char *)&v34.order + 6) = v18;
          WORD1(v34.ignoreRowsAndColumns) = 1024;
          HIDWORD(v34.ignoreRowsAndColumns) = v19;
          LOWORD(v34.malloc) = 2080;
          *(void *(__cdecl **)(size_t))((char *)&v34.malloc + 2) = (void *(__cdecl *)(size_t))"Factored";
          WORD1(v34.free) = 1024;
          HIDWORD(v34.free) = v20;
          uint64_t v27 = &_os_log_internal;
LABEL_87:
          _os_log_error_impl(&dword_2153B7000, v27, OS_LOG_TYPE_ERROR, "%s (%dx%d) is not consistent with largest dimension of matrix factorization %s (%d).\n", (uint8_t *)&v34, 0x28u);
          goto LABEL_7;
        }
        long long v46 = 0u;
        long long v47 = 0u;
        long long v44 = 0u;
        long long v45 = 0u;
        long long v42 = 0u;
        long long v43 = 0u;
        long long v40 = 0u;
        long long v41 = 0u;
        long long v38 = 0u;
        long long v39 = 0u;
        long long v36 = 0u;
        long long v37 = 0u;
        long long v35 = 0u;
        memset(&v34, 0, sizeof(v34));
        snprintf((char *)&v34, 0x100uLL, "%s (%dx%d) is not consistent with largest dimension of matrix factorization %s (%d).\n");
        goto LABEL_30;
      }
      free = v34.free;
      size_t v22 = v29.solveWorkspaceRequiredPerRHS + v30 * v19;
      long long v23 = (void *)((uint64_t (*)(size_t))v34.malloc)(v22);
      if (v23)
      {
        int v24 = v23;
        _SparseSolveOpaque_Float(&v29, 0, &v28, v23);
        ((void (*)(void *))free)(v24);
        return;
      }
      if (v12)
      {
        long long v46 = 0u;
        long long v47 = 0u;
        long long v44 = 0u;
        long long v45 = 0u;
        long long v42 = 0u;
        long long v43 = 0u;
        long long v40 = 0u;
        long long v41 = 0u;
        long long v38 = 0u;
        long long v39 = 0u;
        long long v36 = 0u;
        long long v37 = 0u;
        long long v35 = 0u;
        memset(&v34, 0, sizeof(v34));
        snprintf((char *)&v34, 0x100uLL, "Failed to allocate workspace of size %ld for SparseSolve().\n");
        goto LABEL_30;
      }
      if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
        goto LABEL_7;
      }
      v34.control = 134217984;
      *(void *)&v34.orderMethod = v22;
      long long v16 = &_os_log_internal;
      int v17 = "Failed to allocate workspace of size %ld for SparseSolve().\n";
    }
LABEL_62:
    _os_log_error_impl(&dword_2153B7000, v16, OS_LOG_TYPE_ERROR, v17, (uint8_t *)&v34, 0xCu);
    goto LABEL_7;
  }
  if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v34.control) = 0;
    long long v6 = &_os_log_internal;
    goto LABEL_59;
  }
LABEL_7:
  _SparseTrap();
}

double cva::VecLibSparse<float>::subfactor@<D0>(int a1@<W0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  long long v4 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)&v21.userFactorStorage = *(_OWORD *)(a2 + 64);
  *(_OWORD *)&v21.solveWorkspaceRequiredStatic = v4;
  uint64_t v22 = *(void *)(a2 + 96);
  long long v5 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)&v21.status = *(_OWORD *)a2;
  *(_OWORD *)&v21.symbolicFactorization.columnCFIndex Count = v5;
  long long v6 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)&v21.symbolicFactorization.workspaceSize_Float = *(_OWORD *)(a2 + 32);
  *(_OWORD *)&v21.symbolicFactorization.factorSize_Float = v6;
  if (v21.symbolicFactorization.status == SparseStatusOK
    && v21.symbolicFactorization.workspaceSize_Float
    && v21.status == SparseStatusOK
    && v21.solveWorkspaceRequiredStatic)
  {
    _SparseGetOptionsFromSymbolicFactor((SparseSymbolicFactorOptions *)v25, &v21.symbolicFactorization);
    long long v8 = *(void (**)(unsigned char *))&v25[40];
    __int16 v9 = 2;
    switch(a1)
    {
      case 1:
        goto LABEL_24;
      case 2:
      case 4:
        if (BYTE1(v21.symbolicFactorization.factorization) - 2 < 3) {
          goto LABEL_24;
        }
        if (*(void *)&v25[40])
        {
          memset(&v25[53], 0, 203);
          strcpy(v25, "Subfactor Type only valid for LDL^T factorizations.\n");
          goto LABEL_32;
        }
        if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
          goto LABEL_10;
        }
        *(_WORD *)int v25 = 0;
        uint64_t v19 = &_os_log_internal;
        int v20 = "Subfactor Type only valid for LDL^T factorizations.\n";
        goto LABEL_29;
      case 3:
      case 5:
        if (a1 == 5) {
          __int16 v9 = 2;
        }
        else {
          __int16 v9 = 6;
        }
        if (BYTE1(v21.symbolicFactorization.factorization) <= 4u && BYTE1(v21.symbolicFactorization.factorization) != 1) {
          goto LABEL_24;
        }
        if (*(void *)&v25[40])
        {
          memset(&v25[66], 0, 190);
          strcpy(&v25[64], "\n");
          SparseControl_t v11 = "Subfactor Type only valid for Cholesky and LDL^T factorizations.\n";
          goto LABEL_27;
        }
        if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
          goto LABEL_10;
        }
        *(_WORD *)int v25 = 0;
        uint64_t v19 = &_os_log_internal;
        int v20 = "Subfactor Type only valid for Cholesky and LDL^T factorizations.\n";
        goto LABEL_29;
      case 6:
        if (BYTE1(v21.symbolicFactorization.factorization) == 40) {
          goto LABEL_24;
        }
        if (*(void *)&v25[40])
        {
          memset(&v25[52], 0, 204);
          strcpy(v25, "SparseSubfactorQ only valid for QR factorizations.\n");
          goto LABEL_32;
        }
        if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
          goto LABEL_10;
        }
        *(_WORD *)int v25 = 0;
        uint64_t v19 = &_os_log_internal;
        int v20 = "SparseSubfactorQ only valid for QR factorizations.\n";
        goto LABEL_29;
      case 7:
      case 8:
        if ((BYTE1(v21.symbolicFactorization.factorization) & 0xFE) == 0x28)
        {
          __int16 v9 = 4;
LABEL_24:
          _SparseRetainNumeric_Float(&v21);
          workPerDenseMatrix_Float RHS = 0;
          size_t workStatic = 0;
          *(SparseOpaqueFactorization_Float *)int v25 = v21;
          *(void *)&v25[96] = v22;
          _SparseGetWorkspaceRequired_Float((SparseSubfactor_t)a1, (SparseOpaqueFactorization_Float *)v25, &workStatic, &workPerRHS);
          long long v12 = *(_OWORD *)&v21.symbolicFactorization.workspaceSize_Float;
          *(_OWORD *)(a3 + 56) = *(_OWORD *)&v21.symbolicFactorization.factorSize_Float;
          long long v13 = *(_OWORD *)&v21.solveWorkspaceRequiredStatic;
          *(_OWORD *)(a3 + 72) = *(_OWORD *)&v21.userFactorStorage;
          *(_OWORD *)(a3 + 88) = v13;
          double result = *(double *)&v21.status;
          long long v14 = *(_OWORD *)&v21.symbolicFactorization.columnCount;
          *(_OWORD *)(a3 + 8) = *(_OWORD *)&v21.status;
          *(_OWORD *)(a3 + 24) = v14;
          *(_WORD *)a3 = v9;
          *(_WORD *)(a3 + 2) = 0;
          *(unsigned char *)(a3 + 4) = a1;
          uint64_t v15 = v22;
          *(_OWORD *)(a3 + 40) = v12;
          size_t v16 = workStatic;
          *(void *)(a3 + 104) = v15;
          *(void *)(a3 + 112) = v16;
          *(void *)(a3 + 120) = workPerRHS;
          return result;
        }
        if (*(void *)&v25[40])
        {
          memset(&v25[66], 0, 190);
          strcpy(&v25[64], "\n");
          SparseControl_t v11 = "Subfactor Type only valid for QR and CholeskyAtA factorizations.\n";
LABEL_27:
          long long v17 = *((_OWORD *)v11 + 1);
          *(_OWORD *)int v25 = *(_OWORD *)v11;
          *(_OWORD *)&v25[16] = v17;
          long long v18 = *((_OWORD *)v11 + 3);
          *(_OWORD *)&v25[32] = *((_OWORD *)v11 + 2);
          *(_OWORD *)&v25[48] = v18;
          goto LABEL_32;
        }
        if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
          goto LABEL_10;
        }
        *(_WORD *)int v25 = 0;
        uint64_t v19 = &_os_log_internal;
        int v20 = "Subfactor Type only valid for QR and CholeskyAtA factorizations.\n";
        goto LABEL_29;
      default:
        if (*(void *)&v25[40])
        {
          memset(&v25[24], 0, 232);
          strcpy(v25, "Invalid subfactor type.");
LABEL_32:
          v8(v25);
          goto LABEL_11;
        }
        if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
          goto LABEL_10;
        }
        *(_WORD *)int v25 = 0;
        uint64_t v19 = &_os_log_internal;
        int v20 = "Invalid subfactor type.";
        break;
    }
    goto LABEL_29;
  }
  if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)int v25 = 0;
    uint64_t v19 = &_os_log_internal;
    int v20 = "Bad factor.\n";
LABEL_29:
    _os_log_error_impl(&dword_2153B7000, v19, OS_LOG_TYPE_ERROR, v20, v25, 2u);
  }
LABEL_10:
  _SparseTrap();
LABEL_11:
  double result = 0.0;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_OWORD *)(a3 + 112) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_DWORD *)(a3 + 8) = -3;
  *(_DWORD *)(a3 + 16) = -3;
  return result;
}

void cva::VecLibSparse<float>::solve(_OWORD *a1, uint64_t a2, uint64_t a3, char *a4)
{
  long long v4 = a1[5];
  _OWORD v14[4] = a1[4];
  v14[5] = v4;
  long long v5 = a1[7];
  void v14[6] = a1[6];
  _DWORD v14[7] = v5;
  long long v6 = a1[1];
  v14[0] = *a1;
  v14[1] = v6;
  long long v7 = a1[3];
  void v14[2] = a1[2];
  _DWORD v14[3] = v7;
  uint64_t v8 = *(void *)(a3 + 8);
  int v9 = *(_DWORD *)a2;
  long long v10 = *(float **)(a2 + 8);
  v12[0] = *(_DWORD *)a3;
  v12[1] = 1;
  void v12[2] = v12[0];
  v12[3] = 0;
  uint64_t v13 = v8;
  v11.rowCFIndex Count = v9;
  v11.columnCFIndex Count = 1;
  v11.columnStride = v9;
  *(_DWORD *)&v11.attributes = 0;
  v11.data = v10;
  if (a4) {
    sub_215421A8C((const SparseOpaqueSubfactor_Float *)v14, (uint64_t)v12, &v11, a4);
  }
  else {
    sub_2154220E0((const SparseOpaqueSubfactor_Float *)v14, (uint64_t)v12, &v11);
  }
}

void sub_215421A8C(const SparseOpaqueSubfactor_Float *a1, uint64_t a2, const DenseMatrix_Float *a3, char *a4)
{
  uint64_t v47 = *MEMORY[0x263EF8340];
  if (!*((unsigned char *)&a1->contents + 2))
  {
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v33.control) = 0;
      _os_log_error_impl(&dword_2153B7000, &_os_log_internal, OS_LOG_TYPE_ERROR, "Subfactor does not hold a valid factor subobject.\n", (uint8_t *)&v33, 2u);
    }
    goto LABEL_58;
  }
  _SparseGetOptionsFromSymbolicFactor(&v33, &a1->factor.symbolicFactorization);
  reportError = v33.reportError;
  SparseAttributes_t attributes = a1->attributes;
  int factorization_low = LOBYTE(a1->factor.symbolicFactorization.factorization);
  int v11 = a1->factor.symbolicFactorization.rowCount * factorization_low;
  int v12 = a1->factor.symbolicFactorization.columnCount * factorization_low;
  if (v11 >= v12) {
    int v13 = a1->factor.symbolicFactorization.columnCount * factorization_low;
  }
  else {
    int v13 = a1->factor.symbolicFactorization.rowCount * factorization_low;
  }
  if (v11 <= v12) {
    int v11 = v12;
  }
  if (*((unsigned char *)&a1->contents + 2) == 6 && BYTE1(a1->factor.symbolicFactorization.factorization) == 40) {
    int v15 = v11;
  }
  else {
    int v15 = v13;
  }
  if (*(unsigned char *)&attributes) {
    int v16 = v15;
  }
  else {
    int v16 = v13;
  }
  if (*(unsigned char *)&attributes) {
    int v17 = v13;
  }
  else {
    int v17 = v15;
  }
  int v18 = *(_DWORD *)(a2 + 8);
  int v19 = *(_DWORD *)a2;
  if (v18 < *(_DWORD *)a2)
  {
    if (v33.reportError) {
      goto LABEL_26;
    }
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_58;
    }
    v33.control = 136315906;
    *(void *)&v33.orderMethod = "B";
    WORD2(v33.order) = 1024;
    *(_DWORD *)((char *)&v33.order + 6) = v18;
    WORD1(v33.ignoreRowsAndColumns) = 2080;
    *(int **)((char *)&v33.ignoreRowsAndColumns + 4) = (int *)"B";
    WORD2(v33.malloc) = 1024;
    *(_DWORD *)((char *)&v33.malloc + 6) = v19;
    uint64_t v26 = &_os_log_internal;
    goto LABEL_41;
  }
  int columnStride = a3->columnStride;
  rowCFIndex Count = a3->rowCount;
  if (columnStride >= a3->rowCount)
  {
    __int16 v22 = *(_WORD *)(a2 + 12);
    if ((v22 & 1) == 0) {
      int v19 = *(_DWORD *)(a2 + 4);
    }
    int v23 = *(&a3->rowCount + ((*(_WORD *)&a3->attributes & 1) == 0));
    unsigned int v24 = v22 & 1;
    int v25 = *(&a3->rowCount + (*(_WORD *)&a3->attributes & 1));
    if (v19 == v23)
    {
      if (v19 <= 0)
      {
        if (v33.reportError)
        {
          long long v45 = 0u;
          long long v46 = 0u;
          long long v43 = 0u;
          long long v44 = 0u;
          long long v41 = 0u;
          long long v42 = 0u;
          long long v39 = 0u;
          long long v40 = 0u;
          long long v37 = 0u;
          long long v38 = 0u;
          long long v35 = 0u;
          long long v36 = 0u;
          long long v34 = 0u;
          memset(&v33, 0, sizeof(v33));
          snprintf((char *)&v33, 0x100uLL, "%s (%dx%d) must represent at least one right-hand side.\n");
          goto LABEL_27;
        }
        int v31 = *(_DWORD *)(a2 + 4 * v24);
        if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
        {
          v33.control = 136315650;
          *(void *)&v33.orderMethod = "B";
          WORD2(v33.order) = 1024;
          *(_DWORD *)((char *)&v33.order + 6) = v31;
          WORD1(v33.ignoreRowsAndColumns) = 1024;
          HIDWORD(v33.ignoreRowsAndColumns) = v19;
          _os_log_error_impl(&dword_2153B7000, &_os_log_internal, OS_LOG_TYPE_ERROR, "%s (%dx%d) must represent at least one right-hand side.\n", (uint8_t *)&v33, 0x18u);
        }
        goto LABEL_58;
      }
      if (*(_DWORD *)(a2 + 4 * v24) == v17)
      {
        if (v25 == v16)
        {
          _SparseSolveSubfactor_Float(a1, (const DenseMatrix_Float *)a2, a3, a4);
          return;
        }
        if (v33.reportError)
        {
          long long v45 = 0u;
          long long v46 = 0u;
          long long v43 = 0u;
          long long v44 = 0u;
          long long v41 = 0u;
          long long v42 = 0u;
          long long v39 = 0u;
          long long v40 = 0u;
          long long v37 = 0u;
          long long v38 = 0u;
          long long v35 = 0u;
          long long v36 = 0u;
          long long v34 = 0u;
          memset(&v33, 0, sizeof(v33));
          uint64_t v30 = "X";
          goto LABEL_50;
        }
        if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
          goto LABEL_58;
        }
        v33.control = 136316418;
        *(void *)&v33.orderMethod = "X";
        WORD2(v33.order) = 1024;
        *(_DWORD *)((char *)&v33.order + 6) = v25;
        WORD1(v33.ignoreRowsAndColumns) = 1024;
        HIDWORD(v33.ignoreRowsAndColumns) = v19;
        LOWORD(v33.malloc) = 2080;
        *(void *(__cdecl **)(size_t))((char *)&v33.malloc + 2) = (void *(__cdecl *)(size_t))"subfactor dimension";
        WORD1(v33.free) = 1024;
        HIDWORD(v33.free) = v16;
        LOWORD(v33.reportError) = 1024;
        *(_DWORD *)((char *)&v33.reportError + 2) = v17;
        DenseMatrix_Float v28 = &_os_log_internal;
        SparseOpaqueFactorization_Float v29 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
      }
      else
      {
        if (v33.reportError)
        {
          long long v45 = 0u;
          long long v46 = 0u;
          long long v43 = 0u;
          long long v44 = 0u;
          long long v41 = 0u;
          long long v42 = 0u;
          long long v39 = 0u;
          long long v40 = 0u;
          long long v37 = 0u;
          long long v38 = 0u;
          long long v35 = 0u;
          long long v36 = 0u;
          long long v34 = 0u;
          memset(&v33, 0, sizeof(v33));
          uint64_t v30 = "B";
LABEL_50:
          snprintf((char *)&v33, 0x100uLL, "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n", v30);
          goto LABEL_27;
        }
        int v32 = *(_DWORD *)(a2 + 4 * v24);
        if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
          goto LABEL_58;
        }
        v33.control = 136316418;
        *(void *)&v33.orderMethod = "B";
        WORD2(v33.order) = 1024;
        *(_DWORD *)((char *)&v33.order + 6) = v32;
        WORD1(v33.ignoreRowsAndColumns) = 1024;
        HIDWORD(v33.ignoreRowsAndColumns) = v19;
        LOWORD(v33.malloc) = 2080;
        *(void *(__cdecl **)(size_t))((char *)&v33.malloc + 2) = (void *(__cdecl *)(size_t))"subfactor dimension";
        WORD1(v33.free) = 1024;
        HIDWORD(v33.free) = v16;
        LOWORD(v33.reportError) = 1024;
        *(_DWORD *)((char *)&v33.reportError + 2) = v17;
        DenseMatrix_Float v28 = &_os_log_internal;
        SparseOpaqueFactorization_Float v29 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
      }
    }
    else
    {
      if (v33.reportError)
      {
        long long v45 = 0u;
        long long v46 = 0u;
        long long v43 = 0u;
        long long v44 = 0u;
        long long v41 = 0u;
        long long v42 = 0u;
        long long v39 = 0u;
        long long v40 = 0u;
        long long v37 = 0u;
        long long v38 = 0u;
        long long v35 = 0u;
        long long v36 = 0u;
        long long v34 = 0u;
        memset(&v33, 0, sizeof(v33));
        snprintf((char *)&v33, 0x100uLL, "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n", "B");
        goto LABEL_27;
      }
      int v27 = *(_DWORD *)(a2 + 4 * v24);
      if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
        goto LABEL_58;
      }
      v33.control = 136316418;
      *(void *)&v33.orderMethod = "B";
      WORD2(v33.order) = 1024;
      *(_DWORD *)((char *)&v33.order + 6) = v27;
      WORD1(v33.ignoreRowsAndColumns) = 1024;
      HIDWORD(v33.ignoreRowsAndColumns) = v19;
      LOWORD(v33.malloc) = 2080;
      *(void *(__cdecl **)(size_t))((char *)&v33.malloc + 2) = (void *(__cdecl *)(size_t))"X";
      WORD1(v33.free) = 1024;
      HIDWORD(v33.free) = v25;
      LOWORD(v33.reportError) = 1024;
      *(_DWORD *)((char *)&v33.reportError + 2) = v23;
      DenseMatrix_Float v28 = &_os_log_internal;
      SparseOpaqueFactorization_Float v29 = "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n";
    }
    _os_log_error_impl(&dword_2153B7000, v28, OS_LOG_TYPE_ERROR, v29, (uint8_t *)&v33, 0x2Eu);
    goto LABEL_58;
  }
  if (v33.reportError)
  {
LABEL_26:
    long long v45 = 0u;
    long long v46 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v34 = 0u;
    memset(&v33, 0, sizeof(v33));
    snprintf((char *)&v33, 0x100uLL, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n");
LABEL_27:
    ((void (*)(SparseSymbolicFactorOptions *))reportError)(&v33);
    return;
  }
  if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
    goto LABEL_58;
  }
  v33.control = 136315906;
  *(void *)&v33.orderMethod = "X";
  WORD2(v33.order) = 1024;
  *(_DWORD *)((char *)&v33.order + 6) = columnStride;
  WORD1(v33.ignoreRowsAndColumns) = 2080;
  *(int **)((char *)&v33.ignoreRowsAndColumns + 4) = (int *)"X";
  WORD2(v33.malloc) = 1024;
  *(_DWORD *)((char *)&v33.malloc + 6) = rowCount;
  uint64_t v26 = &_os_log_internal;
LABEL_41:
  _os_log_error_impl(&dword_2153B7000, v26, OS_LOG_TYPE_ERROR, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n", (uint8_t *)&v33, 0x22u);
LABEL_58:
  _SparseTrap();
}

void sub_2154220E0(const SparseOpaqueSubfactor_Float *a1, uint64_t a2, const DenseMatrix_Float *a3)
{
  uint64_t v46 = *MEMORY[0x263EF8340];
  if (!*((unsigned char *)&a1->contents + 2))
  {
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v32.control) = 0;
      _os_log_error_impl(&dword_2153B7000, &_os_log_internal, OS_LOG_TYPE_ERROR, "Subfactor does not hold a valid factorization.\n", (uint8_t *)&v32, 2u);
    }
    goto LABEL_63;
  }
  _SparseGetOptionsFromSymbolicFactor(&v32, &a1->factor.symbolicFactorization);
  reportError = v32.reportError;
  SparseAttributes_t attributes = a1->attributes;
  int factorization_low = LOBYTE(a1->factor.symbolicFactorization.factorization);
  int v9 = a1->factor.symbolicFactorization.rowCount * factorization_low;
  int v10 = a1->factor.symbolicFactorization.columnCount * factorization_low;
  if (v9 >= v10) {
    int v11 = a1->factor.symbolicFactorization.columnCount * factorization_low;
  }
  else {
    int v11 = a1->factor.symbolicFactorization.rowCount * factorization_low;
  }
  if (v9 <= v10) {
    int v9 = v10;
  }
  if (*((unsigned char *)&a1->contents + 2) == 6 && BYTE1(a1->factor.symbolicFactorization.factorization) == 40) {
    int v13 = v9;
  }
  else {
    int v13 = v11;
  }
  if (*(unsigned char *)&attributes) {
    int v14 = v13;
  }
  else {
    int v14 = v11;
  }
  if (*(unsigned char *)&attributes) {
    int v15 = v11;
  }
  else {
    int v15 = v13;
  }
  int v16 = *(_DWORD *)(a2 + 8);
  int v17 = *(_DWORD *)a2;
  if (v16 < *(_DWORD *)a2)
  {
    if (v32.reportError) {
      goto LABEL_26;
    }
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_63;
    }
    v32.control = 136315906;
    *(void *)&v32.orderMethod = "B";
    WORD2(v32.order) = 1024;
    *(_DWORD *)((char *)&v32.order + 6) = v16;
    WORD1(v32.ignoreRowsAndColumns) = 2080;
    *(int **)((char *)&v32.ignoreRowsAndColumns + 4) = (int *)"B";
    WORD2(v32.malloc) = 1024;
    *(_DWORD *)((char *)&v32.malloc + 6) = v17;
    DenseMatrix_Float v28 = &_os_log_internal;
    goto LABEL_42;
  }
  int columnStride = a3->columnStride;
  rowCFIndex Count = a3->rowCount;
  if (columnStride < a3->rowCount)
  {
    if (v32.reportError)
    {
LABEL_26:
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      long long v36 = 0u;
      long long v37 = 0u;
      long long v34 = 0u;
      long long v35 = 0u;
      long long v33 = 0u;
      memset(&v32, 0, sizeof(v32));
      snprintf((char *)&v32, 0x100uLL, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n");
LABEL_27:
      ((void (*)(SparseSymbolicFactorOptions *))reportError)(&v32);
      return;
    }
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_63;
    }
    v32.control = 136315906;
    *(void *)&v32.orderMethod = "X";
    WORD2(v32.order) = 1024;
    *(_DWORD *)((char *)&v32.order + 6) = columnStride;
    WORD1(v32.ignoreRowsAndColumns) = 2080;
    *(int **)((char *)&v32.ignoreRowsAndColumns + 4) = (int *)"X";
    WORD2(v32.malloc) = 1024;
    *(_DWORD *)((char *)&v32.malloc + 6) = rowCount;
    DenseMatrix_Float v28 = &_os_log_internal;
LABEL_42:
    _os_log_error_impl(&dword_2153B7000, v28, OS_LOG_TYPE_ERROR, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n", (uint8_t *)&v32, 0x22u);
    goto LABEL_63;
  }
  __int16 v20 = *(_WORD *)(a2 + 12);
  if ((v20 & 1) == 0) {
    int v17 = *(_DWORD *)(a2 + 4);
  }
  int v21 = *(&a3->rowCount + ((*(_WORD *)&a3->attributes & 1) == 0));
  int v22 = *(_DWORD *)(a2 + 4 * (v20 & 1));
  int v23 = *(&a3->rowCount + (*(_WORD *)&a3->attributes & 1));
  if (v17 != v21)
  {
    if (v32.reportError)
    {
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      long long v36 = 0u;
      long long v37 = 0u;
      long long v34 = 0u;
      long long v35 = 0u;
      long long v33 = 0u;
      memset(&v32, 0, sizeof(v32));
      snprintf((char *)&v32, 0x100uLL, "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n", "B");
      goto LABEL_27;
    }
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_63;
    }
    v32.control = 136316418;
    *(void *)&v32.orderMethod = "B";
    WORD2(v32.order) = 1024;
    *(_DWORD *)((char *)&v32.order + 6) = v22;
    WORD1(v32.ignoreRowsAndColumns) = 1024;
    HIDWORD(v32.ignoreRowsAndColumns) = v17;
    LOWORD(v32.malloc) = 2080;
    *(void *(__cdecl **)(size_t))((char *)&v32.malloc + 2) = (void *(__cdecl *)(size_t))"X";
    WORD1(v32.free) = 1024;
    HIDWORD(v32.free) = v23;
    LOWORD(v32.reportError) = 1024;
    *(_DWORD *)((char *)&v32.reportError + 2) = v21;
    SparseOpaqueFactorization_Float v29 = &_os_log_internal;
    uint64_t v30 = "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n";
    goto LABEL_60;
  }
  if (v17 <= 0)
  {
    if (v32.reportError)
    {
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      long long v36 = 0u;
      long long v37 = 0u;
      long long v34 = 0u;
      long long v35 = 0u;
      long long v33 = 0u;
      memset(&v32, 0, sizeof(v32));
      snprintf((char *)&v32, 0x100uLL, "%s (%dx%d) must represent at least one right-hand side.\n");
      goto LABEL_27;
    }
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      v32.control = 136315650;
      *(void *)&v32.orderMethod = "B";
      WORD2(v32.order) = 1024;
      *(_DWORD *)((char *)&v32.order + 6) = v22;
      WORD1(v32.ignoreRowsAndColumns) = 1024;
      HIDWORD(v32.ignoreRowsAndColumns) = v17;
      _os_log_error_impl(&dword_2153B7000, &_os_log_internal, OS_LOG_TYPE_ERROR, "%s (%dx%d) must represent at least one right-hand side.\n", (uint8_t *)&v32, 0x18u);
    }
    goto LABEL_63;
  }
  if (v22 != v15)
  {
    if (v32.reportError)
    {
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      long long v36 = 0u;
      long long v37 = 0u;
      long long v34 = 0u;
      long long v35 = 0u;
      long long v33 = 0u;
      memset(&v32, 0, sizeof(v32));
      int v31 = "B";
LABEL_51:
      snprintf((char *)&v32, 0x100uLL, "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n", v31);
      goto LABEL_27;
    }
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_63;
    }
    v32.control = 136316418;
    *(void *)&v32.orderMethod = "B";
    WORD2(v32.order) = 1024;
    *(_DWORD *)((char *)&v32.order + 6) = v22;
    WORD1(v32.ignoreRowsAndColumns) = 1024;
    HIDWORD(v32.ignoreRowsAndColumns) = v17;
    LOWORD(v32.malloc) = 2080;
    *(void *(__cdecl **)(size_t))((char *)&v32.malloc + 2) = (void *(__cdecl *)(size_t))"subfactor dimension";
    WORD1(v32.free) = 1024;
    HIDWORD(v32.free) = v14;
    LOWORD(v32.reportError) = 1024;
    *(_DWORD *)((char *)&v32.reportError + 2) = v15;
    SparseOpaqueFactorization_Float v29 = &_os_log_internal;
    uint64_t v30 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
LABEL_60:
    _os_log_error_impl(&dword_2153B7000, v29, OS_LOG_TYPE_ERROR, v30, (uint8_t *)&v32, 0x2Eu);
    goto LABEL_63;
  }
  if (v23 != v14)
  {
    if (v32.reportError)
    {
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      long long v36 = 0u;
      long long v37 = 0u;
      long long v34 = 0u;
      long long v35 = 0u;
      long long v33 = 0u;
      memset(&v32, 0, sizeof(v32));
      int v31 = "X";
      goto LABEL_51;
    }
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_63;
    }
    v32.control = 136316418;
    *(void *)&v32.orderMethod = "X";
    WORD2(v32.order) = 1024;
    *(_DWORD *)((char *)&v32.order + 6) = v23;
    WORD1(v32.ignoreRowsAndColumns) = 1024;
    HIDWORD(v32.ignoreRowsAndColumns) = v17;
    LOWORD(v32.malloc) = 2080;
    *(void *(__cdecl **)(size_t))((char *)&v32.malloc + 2) = (void *(__cdecl *)(size_t))"subfactor dimension";
    WORD1(v32.free) = 1024;
    HIDWORD(v32.free) = v14;
    LOWORD(v32.reportError) = 1024;
    *(_DWORD *)((char *)&v32.reportError + 2) = v15;
    SparseOpaqueFactorization_Float v29 = &_os_log_internal;
    uint64_t v30 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
    goto LABEL_60;
  }
  free = v32.free;
  size_t v25 = a1->workspaceRequiredPerRHS + *(void *)&a1[1].attributes * v17;
  uint64_t v26 = (char *)((uint64_t (*)(size_t))v32.malloc)(v25);
  if (v26)
  {
    int v27 = v26;
    _SparseSolveSubfactor_Float(a1, (const DenseMatrix_Float *)a2, a3, v26);
    ((void (*)(char *))free)(v27);
    return;
  }
  if (reportError)
  {
    long long v44 = 0u;
    long long v45 = 0u;
    long long v42 = 0u;
    long long v43 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v33 = 0u;
    memset(&v32, 0, sizeof(v32));
    snprintf((char *)&v32, 0x100uLL, "Failed to allocate workspace of size %ld.\n");
    goto LABEL_27;
  }
  if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
  {
    v32.control = 134217984;
    *(void *)&v32.orderMethod = v25;
    _os_log_error_impl(&dword_2153B7000, &_os_log_internal, OS_LOG_TYPE_ERROR, "Failed to allocate workspace of size %ld.\n", (uint8_t *)&v32, 0xCu);
  }
LABEL_63:
  _SparseTrap();
}

__n128 cva::VecLibSparse<float>::solve(_OWORD *a1, DenseMatrix_Float *a2, long long *a3, char *a4)
{
  long long v4 = a1[5];
  if (a4)
  {
    void v21[4] = a1[4];
    v21[5] = v4;
    long long v5 = a1[7];
    v21[6] = a1[6];
    v21[7] = v5;
    long long v6 = a1[1];
    v21[0] = *a1;
    v21[1] = v6;
    long long v7 = a1[3];
    v21[2] = a1[2];
    v21[3] = v7;
    long long v8 = *a3;
    uint64_t v20 = *((void *)a3 + 2);
    long long v19 = v8;
    DenseMatrix_Float v18 = *a2;
    sub_215421A8C((const SparseOpaqueSubfactor_Float *)v21, (uint64_t)&v19, &v18, a4);
  }
  else
  {
    void v17[4] = a1[4];
    v17[5] = v4;
    long long v10 = a1[7];
    v17[6] = a1[6];
    v17[7] = v10;
    long long v11 = a1[1];
    v17[0] = *a1;
    v17[1] = v11;
    long long v12 = a1[3];
    void v17[2] = a1[2];
    unsigned int v17[3] = v12;
    long long v13 = *a3;
    uint64_t v16 = *((void *)a3 + 2);
    long long v15 = v13;
    DenseMatrix_Float v14 = *a2;
    sub_2154220E0((const SparseOpaqueSubfactor_Float *)v17, (uint64_t)&v15, &v14);
  }
  return result;
}

void cva::VecLibSparse<float>::solve(_OWORD *a1, uint64_t a2, char *a3)
{
  long long v3 = a1[5];
  v10[4] = a1[4];
  v10[5] = v3;
  long long v4 = a1[7];
  v10[6] = a1[6];
  v10[7] = v4;
  long long v5 = a1[1];
  v10[0] = *a1;
  v10[1] = v5;
  long long v6 = a1[3];
  void v10[2] = a1[2];
  v10[3] = v6;
  uint64_t v7 = *(void *)(a2 + 8);
  v8[0] = *(_DWORD *)a2;
  v8[1] = 1;
  _OWORD v8[2] = v8[0];
  float32x2_t v8[3] = 0;
  uint64_t v9 = v7;
  if (a3) {
    sub_21542295C((const SparseOpaqueSubfactor_Float *)v10, (uint64_t)v8, a3);
  }
  else {
    sub_215422BF8((const SparseOpaqueSubfactor_Float *)v10, (uint64_t)v8);
  }
}

void sub_21542295C(const SparseOpaqueSubfactor_Float *a1, uint64_t a2, char *a3)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  if (!*((unsigned char *)&a1->contents + 2))
  {
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_25;
    }
    *(_WORD *)uint64_t v20 = 0;
    DenseMatrix_Float v18 = &_os_log_internal;
    long long v19 = "Subfactor does not hold a valid factor subobject.\n";
LABEL_37:
    _os_log_error_impl(&dword_2153B7000, v18, OS_LOG_TYPE_ERROR, v19, v20, 2u);
    goto LABEL_25;
  }
  _SparseGetOptionsFromSymbolicFactor((SparseSymbolicFactorOptions *)v20, &a1->factor.symbolicFactorization);
  long long v6 = *(void (**)(unsigned char *))&v20[40];
  if (*(int *)(a2 + 4 * ((*(_WORD *)(a2 + 12) & 1) == 0)) > 0)
  {
    int v7 = *(_DWORD *)(a2 + 4 * (*(_WORD *)(a2 + 12) & 1));
    SparseAttributes_t attributes = a1->attributes;
    int factorization_low = LOBYTE(a1->factor.symbolicFactorization.factorization);
    int v10 = a1->factor.symbolicFactorization.rowCount * factorization_low;
    int v11 = a1->factor.symbolicFactorization.columnCount * factorization_low;
    if (v10 <= v11) {
      int v12 = v11;
    }
    else {
      int v12 = v10;
    }
    if (v10 < v11) {
      int v11 = v10;
    }
    if (*((unsigned char *)&a1->contents + 2) == 6 && BYTE1(a1->factor.symbolicFactorization.factorization) == 40) {
      int v14 = v12;
    }
    else {
      int v14 = v11;
    }
    BOOL v15 = (*(unsigned char *)&attributes & 1) == 0;
    if (*(unsigned char *)&attributes) {
      int v16 = v11;
    }
    else {
      int v16 = v14;
    }
    if (v15) {
      int v14 = v11;
    }
    if (v16 <= v14) {
      int v17 = v14;
    }
    else {
      int v17 = v16;
    }
    if (v7 == v17)
    {
      _SparseSolveSubfactor_Float(a1, 0, (const DenseMatrix_Float *)a2, a3);
      return;
    }
    if (*(void *)&v20[40])
    {
      memset(v20, 0, sizeof(v20));
      snprintf(v20, 0x100uLL, "XB dimension (%d) must match maximum subfactor dimension (%d).\n", v7, v17);
      goto LABEL_30;
    }
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t v20 = 67109376;
      *(_DWORD *)&v20[4] = v7;
      *(_WORD *)&v20[8] = 1024;
      *(_DWORD *)&v20[10] = v17;
      _os_log_error_impl(&dword_2153B7000, &_os_log_internal, OS_LOG_TYPE_ERROR, "XB dimension (%d) must match maximum subfactor dimension (%d).\n", v20, 0xEu);
    }
LABEL_25:
    _SparseTrap();
    return;
  }
  if (!*(void *)&v20[40])
  {
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_25;
    }
    *(_WORD *)uint64_t v20 = 0;
    DenseMatrix_Float v18 = &_os_log_internal;
    long long v19 = "XB must have non-zero dimension.\n";
    goto LABEL_37;
  }
  memset(&v20[34], 0, 222);
  strcpy(v20, "XB must have non-zero dimension.\n");
LABEL_30:
  v6(v20);
}

void sub_215422BF8(const SparseOpaqueSubfactor_Float *a1, uint64_t a2)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  if (!*((unsigned char *)&a1->contents + 2))
  {
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_26;
    }
    *(_WORD *)unsigned int v24 = 0;
    int v22 = &_os_log_internal;
    int v23 = "Subfactor does not hold a valid factorization.\n";
    goto LABEL_42;
  }
  _SparseGetOptionsFromSymbolicFactor((SparseSymbolicFactorOptions *)v24, &a1->factor.symbolicFactorization);
  long long v4 = *(void (**)(unsigned char *))&v24[40];
  uint64_t v5 = *(_WORD *)(a2 + 12) & 1;
  uint64_t v6 = *(unsigned int *)(a2 + 4 * (v5 == 0));
  if ((int)v6 <= 0)
  {
    if (*(void *)&v24[40])
    {
      memset(&v24[34], 0, 222);
      strcpy(v24, "XB must have non-zero dimension.\n");
      goto LABEL_35;
    }
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_26;
    }
    *(_WORD *)unsigned int v24 = 0;
    int v22 = &_os_log_internal;
    int v23 = "XB must have non-zero dimension.\n";
LABEL_42:
    _os_log_error_impl(&dword_2153B7000, v22, OS_LOG_TYPE_ERROR, v23, v24, 2u);
    goto LABEL_26;
  }
  int v7 = *(_DWORD *)(a2 + 4 * v5);
  SparseAttributes_t attributes = a1->attributes;
  int factorization_low = LOBYTE(a1->factor.symbolicFactorization.factorization);
  int v10 = a1->factor.symbolicFactorization.rowCount * factorization_low;
  int v11 = a1->factor.symbolicFactorization.columnCount * factorization_low;
  if (v10 <= v11) {
    int v12 = v11;
  }
  else {
    int v12 = v10;
  }
  if (v10 < v11) {
    int v11 = v10;
  }
  if (*((unsigned char *)&a1->contents + 2) == 6 && BYTE1(a1->factor.symbolicFactorization.factorization) == 40) {
    int v14 = v12;
  }
  else {
    int v14 = v11;
  }
  BOOL v15 = (*(unsigned char *)&attributes & 1) == 0;
  if (*(unsigned char *)&attributes) {
    int v16 = v11;
  }
  else {
    int v16 = v14;
  }
  if (v15) {
    int v14 = v11;
  }
  if (v16 <= v14) {
    int v17 = v14;
  }
  else {
    int v17 = v16;
  }
  if (v7 == v17)
  {
    DenseMatrix_Float v18 = *(void (**)(char *))&v24[32];
    uint64_t v19 = a1->workspaceRequiredPerRHS + *(void *)&a1[1].attributes * v6;
    uint64_t v20 = (char *)(*(uint64_t (**)(uint64_t))&v24[24])(v19);
    if (v20)
    {
      uint64_t v21 = v20;
      _SparseSolveSubfactor_Float(a1, 0, (const DenseMatrix_Float *)a2, v20);
      v18(v21);
      return;
    }
    if (v4)
    {
      memset(v24, 0, sizeof(v24));
      snprintf(v24, 0x100uLL, "Failed to allocate workspace of size %ld.\n");
      goto LABEL_35;
    }
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)unsigned int v24 = 134217984;
      *(void *)&v24[4] = v19;
      _os_log_error_impl(&dword_2153B7000, &_os_log_internal, OS_LOG_TYPE_ERROR, "Failed to allocate workspace of size %ld.\n", v24, 0xCu);
    }
LABEL_26:
    _SparseTrap();
    return;
  }
  if (!*(void *)&v24[40])
  {
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)unsigned int v24 = 67109376;
      *(_DWORD *)&v24[4] = v7;
      *(_WORD *)&v24[8] = 1024;
      *(_DWORD *)&v24[10] = v17;
      _os_log_error_impl(&dword_2153B7000, &_os_log_internal, OS_LOG_TYPE_ERROR, "XB dimension (%d) must match maximum subfactor dimension (%d).\n", v24, 0xEu);
    }
    goto LABEL_26;
  }
  memset(v24, 0, sizeof(v24));
  snprintf(v24, 0x100uLL, "XB dimension (%d) must match maximum subfactor dimension (%d).\n");
LABEL_35:
  v4(v24);
}

__n128 cva::VecLibSparse<float>::solve(_OWORD *a1, long long *a2, char *a3)
{
  long long v3 = a1[5];
  if (a3)
  {
    double v18[4] = a1[4];
    v18[5] = v3;
    long long v4 = a1[7];
    v18[6] = a1[6];
    v18[7] = v4;
    long long v5 = a1[1];
    v18[0] = *a1;
    v18[1] = v5;
    long long v6 = a1[3];
    void v18[2] = a1[2];
    v18[3] = v6;
    long long v7 = *a2;
    uint64_t v17 = *((void *)a2 + 2);
    long long v16 = v7;
    sub_21542295C((const SparseOpaqueSubfactor_Float *)v18, (uint64_t)&v16, a3);
  }
  else
  {
    v15[4] = a1[4];
    v15[5] = v3;
    long long v9 = a1[7];
    CVPixelBufferRef v15[6] = a1[6];
    v15[7] = v9;
    long long v10 = a1[1];
    v15[0] = *a1;
    v15[1] = v10;
    long long v11 = a1[3];
    double v15[2] = a1[2];
    void v15[3] = v11;
    long long v12 = *a2;
    uint64_t v14 = *((void *)a2 + 2);
    long long v13 = v12;
    sub_215422BF8((const SparseOpaqueSubfactor_Float *)v15, (uint64_t)&v13);
  }
  return result;
}

__n128 cva::VecLibSparse<float>::multiply(_OWORD *a1, long long *a2, long long *a3, char *a4)
{
  long long v4 = a1[5];
  if (a4)
  {
    void v21[4] = a1[4];
    v21[5] = v4;
    long long v5 = a1[7];
    v21[6] = a1[6];
    v21[7] = v5;
    long long v6 = a1[1];
    v21[0] = *a1;
    v21[1] = v6;
    long long v7 = a1[3];
    v21[2] = a1[2];
    v21[3] = v7;
    long long v8 = *a2;
    v20.data = (float *)*((void *)a2 + 2);
    *(_OWORD *)&v20.rowCFIndex Count = v8;
    uint64_t v19 = *((void *)a3 + 2);
    long long v18 = *a3;
    sub_2154230AC((const SparseOpaqueSubfactor_Float *)v21, &v20, (uint64_t)&v18, a4);
  }
  else
  {
    void v17[4] = a1[4];
    v17[5] = v4;
    long long v10 = a1[7];
    v17[6] = a1[6];
    v17[7] = v10;
    long long v11 = a1[1];
    v17[0] = *a1;
    v17[1] = v11;
    long long v12 = a1[3];
    void v17[2] = a1[2];
    unsigned int v17[3] = v12;
    long long v13 = *a2;
    uint64_t v16 = *((void *)a2 + 2);
    long long v15 = v13;
    DenseMatrix_Float v14 = *(DenseMatrix_Float *)a3;
    sub_215423700((const SparseOpaqueSubfactor_Float *)v17, (uint64_t)&v15, &v14);
  }
  return result;
}

void sub_2154230AC(const SparseOpaqueSubfactor_Float *a1, const DenseMatrix_Float *a2, uint64_t a3, char *a4)
{
  uint64_t v47 = *MEMORY[0x263EF8340];
  if (!*((unsigned char *)&a1->contents + 2))
  {
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v33.control) = 0;
      _os_log_error_impl(&dword_2153B7000, &_os_log_internal, OS_LOG_TYPE_ERROR, "Subfactor does not hold a valid factor subobject.\n", (uint8_t *)&v33, 2u);
    }
    goto LABEL_58;
  }
  _SparseGetOptionsFromSymbolicFactor(&v33, &a1->factor.symbolicFactorization);
  reportError = v33.reportError;
  SparseAttributes_t attributes = a1->attributes;
  int factorization_low = LOBYTE(a1->factor.symbolicFactorization.factorization);
  int v11 = a1->factor.symbolicFactorization.rowCount * factorization_low;
  int v12 = a1->factor.symbolicFactorization.columnCount * factorization_low;
  if (v11 >= v12) {
    int v13 = a1->factor.symbolicFactorization.columnCount * factorization_low;
  }
  else {
    int v13 = a1->factor.symbolicFactorization.rowCount * factorization_low;
  }
  if (v11 <= v12) {
    int v11 = v12;
  }
  if (*((unsigned char *)&a1->contents + 2) == 6 && BYTE1(a1->factor.symbolicFactorization.factorization) == 40) {
    int v15 = v11;
  }
  else {
    int v15 = v13;
  }
  if (*(unsigned char *)&attributes) {
    int v16 = v15;
  }
  else {
    int v16 = v13;
  }
  if (*(unsigned char *)&attributes) {
    int v17 = v13;
  }
  else {
    int v17 = v15;
  }
  int v18 = *(_DWORD *)(a3 + 8);
  int v19 = *(_DWORD *)a3;
  if (v18 < *(_DWORD *)a3)
  {
    if (v33.reportError) {
      goto LABEL_26;
    }
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_58;
    }
    v33.control = 136315906;
    *(void *)&v33.orderMethod = "Y";
    WORD2(v33.order) = 1024;
    *(_DWORD *)((char *)&v33.order + 6) = v18;
    WORD1(v33.ignoreRowsAndColumns) = 2080;
    *(int **)((char *)&v33.ignoreRowsAndColumns + 4) = (int *)"Y";
    WORD2(v33.malloc) = 1024;
    *(_DWORD *)((char *)&v33.malloc + 6) = v19;
    uint64_t v26 = &_os_log_internal;
    goto LABEL_41;
  }
  int columnStride = a2->columnStride;
  rowCFIndex Count = a2->rowCount;
  if (columnStride >= a2->rowCount)
  {
    __int16 v22 = *(_WORD *)(a3 + 12);
    if ((v22 & 1) == 0) {
      int v19 = *(_DWORD *)(a3 + 4);
    }
    int v23 = *(&a2->rowCount + ((*(_WORD *)&a2->attributes & 1) == 0));
    unsigned int v24 = v22 & 1;
    int v25 = *(&a2->rowCount + (*(_WORD *)&a2->attributes & 1));
    if (v19 == v23)
    {
      if (v19 <= 0)
      {
        if (v33.reportError)
        {
          long long v45 = 0u;
          long long v46 = 0u;
          long long v43 = 0u;
          long long v44 = 0u;
          long long v41 = 0u;
          long long v42 = 0u;
          long long v39 = 0u;
          long long v40 = 0u;
          long long v37 = 0u;
          long long v38 = 0u;
          long long v35 = 0u;
          long long v36 = 0u;
          long long v34 = 0u;
          memset(&v33, 0, sizeof(v33));
          snprintf((char *)&v33, 0x100uLL, "%s (%dx%d) must represent at least one right-hand side.\n");
          goto LABEL_27;
        }
        int v31 = *(_DWORD *)(a3 + 4 * v24);
        if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
        {
          v33.control = 136315650;
          *(void *)&v33.orderMethod = "Y";
          WORD2(v33.order) = 1024;
          *(_DWORD *)((char *)&v33.order + 6) = v31;
          WORD1(v33.ignoreRowsAndColumns) = 1024;
          HIDWORD(v33.ignoreRowsAndColumns) = v19;
          _os_log_error_impl(&dword_2153B7000, &_os_log_internal, OS_LOG_TYPE_ERROR, "%s (%dx%d) must represent at least one right-hand side.\n", (uint8_t *)&v33, 0x18u);
        }
        goto LABEL_58;
      }
      if (*(_DWORD *)(a3 + 4 * v24) == v17)
      {
        if (v25 == v16)
        {
          _SparseMultiplySubfactor_Float(a1, a2, (const DenseMatrix_Float *)a3, a4);
          return;
        }
        if (v33.reportError)
        {
          long long v45 = 0u;
          long long v46 = 0u;
          long long v43 = 0u;
          long long v44 = 0u;
          long long v41 = 0u;
          long long v42 = 0u;
          long long v39 = 0u;
          long long v40 = 0u;
          long long v37 = 0u;
          long long v38 = 0u;
          long long v35 = 0u;
          long long v36 = 0u;
          long long v34 = 0u;
          memset(&v33, 0, sizeof(v33));
          uint64_t v30 = "X";
          goto LABEL_50;
        }
        if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
          goto LABEL_58;
        }
        v33.control = 136316418;
        *(void *)&v33.orderMethod = "X";
        WORD2(v33.order) = 1024;
        *(_DWORD *)((char *)&v33.order + 6) = v25;
        WORD1(v33.ignoreRowsAndColumns) = 1024;
        HIDWORD(v33.ignoreRowsAndColumns) = v19;
        LOWORD(v33.malloc) = 2080;
        *(void *(__cdecl **)(size_t))((char *)&v33.malloc + 2) = (void *(__cdecl *)(size_t))"subfactor dimension";
        WORD1(v33.free) = 1024;
        HIDWORD(v33.free) = v16;
        LOWORD(v33.reportError) = 1024;
        *(_DWORD *)((char *)&v33.reportError + 2) = v17;
        DenseMatrix_Float v28 = &_os_log_internal;
        SparseOpaqueFactorization_Float v29 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
      }
      else
      {
        if (v33.reportError)
        {
          long long v45 = 0u;
          long long v46 = 0u;
          long long v43 = 0u;
          long long v44 = 0u;
          long long v41 = 0u;
          long long v42 = 0u;
          long long v39 = 0u;
          long long v40 = 0u;
          long long v37 = 0u;
          long long v38 = 0u;
          long long v35 = 0u;
          long long v36 = 0u;
          long long v34 = 0u;
          memset(&v33, 0, sizeof(v33));
          uint64_t v30 = "Y";
LABEL_50:
          snprintf((char *)&v33, 0x100uLL, "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n", v30);
          goto LABEL_27;
        }
        int v32 = *(_DWORD *)(a3 + 4 * v24);
        if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
          goto LABEL_58;
        }
        v33.control = 136316418;
        *(void *)&v33.orderMethod = "Y";
        WORD2(v33.order) = 1024;
        *(_DWORD *)((char *)&v33.order + 6) = v32;
        WORD1(v33.ignoreRowsAndColumns) = 1024;
        HIDWORD(v33.ignoreRowsAndColumns) = v19;
        LOWORD(v33.malloc) = 2080;
        *(void *(__cdecl **)(size_t))((char *)&v33.malloc + 2) = (void *(__cdecl *)(size_t))"subfactor dimension";
        WORD1(v33.free) = 1024;
        HIDWORD(v33.free) = v16;
        LOWORD(v33.reportError) = 1024;
        *(_DWORD *)((char *)&v33.reportError + 2) = v17;
        DenseMatrix_Float v28 = &_os_log_internal;
        SparseOpaqueFactorization_Float v29 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
      }
    }
    else
    {
      if (v33.reportError)
      {
        long long v45 = 0u;
        long long v46 = 0u;
        long long v43 = 0u;
        long long v44 = 0u;
        long long v41 = 0u;
        long long v42 = 0u;
        long long v39 = 0u;
        long long v40 = 0u;
        long long v37 = 0u;
        long long v38 = 0u;
        long long v35 = 0u;
        long long v36 = 0u;
        long long v34 = 0u;
        memset(&v33, 0, sizeof(v33));
        snprintf((char *)&v33, 0x100uLL, "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n", "Y");
        goto LABEL_27;
      }
      int v27 = *(_DWORD *)(a3 + 4 * v24);
      if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
        goto LABEL_58;
      }
      v33.control = 136316418;
      *(void *)&v33.orderMethod = "Y";
      WORD2(v33.order) = 1024;
      *(_DWORD *)((char *)&v33.order + 6) = v27;
      WORD1(v33.ignoreRowsAndColumns) = 1024;
      HIDWORD(v33.ignoreRowsAndColumns) = v19;
      LOWORD(v33.malloc) = 2080;
      *(void *(__cdecl **)(size_t))((char *)&v33.malloc + 2) = (void *(__cdecl *)(size_t))"X";
      WORD1(v33.free) = 1024;
      HIDWORD(v33.free) = v25;
      LOWORD(v33.reportError) = 1024;
      *(_DWORD *)((char *)&v33.reportError + 2) = v23;
      DenseMatrix_Float v28 = &_os_log_internal;
      SparseOpaqueFactorization_Float v29 = "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n";
    }
    _os_log_error_impl(&dword_2153B7000, v28, OS_LOG_TYPE_ERROR, v29, (uint8_t *)&v33, 0x2Eu);
    goto LABEL_58;
  }
  if (v33.reportError)
  {
LABEL_26:
    long long v45 = 0u;
    long long v46 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v34 = 0u;
    memset(&v33, 0, sizeof(v33));
    snprintf((char *)&v33, 0x100uLL, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n");
LABEL_27:
    ((void (*)(SparseSymbolicFactorOptions *))reportError)(&v33);
    return;
  }
  if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
    goto LABEL_58;
  }
  v33.control = 136315906;
  *(void *)&v33.orderMethod = "X";
  WORD2(v33.order) = 1024;
  *(_DWORD *)((char *)&v33.order + 6) = columnStride;
  WORD1(v33.ignoreRowsAndColumns) = 2080;
  *(int **)((char *)&v33.ignoreRowsAndColumns + 4) = (int *)"X";
  WORD2(v33.malloc) = 1024;
  *(_DWORD *)((char *)&v33.malloc + 6) = rowCount;
  uint64_t v26 = &_os_log_internal;
LABEL_41:
  _os_log_error_impl(&dword_2153B7000, v26, OS_LOG_TYPE_ERROR, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n", (uint8_t *)&v33, 0x22u);
LABEL_58:
  _SparseTrap();
}

void sub_215423700(const SparseOpaqueSubfactor_Float *a1, uint64_t a2, const DenseMatrix_Float *a3)
{
  uint64_t v46 = *MEMORY[0x263EF8340];
  if (!*((unsigned char *)&a1->contents + 2))
  {
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v32.control) = 0;
      _os_log_error_impl(&dword_2153B7000, &_os_log_internal, OS_LOG_TYPE_ERROR, "Subfactor does not hold a valid factor subobject.\n", (uint8_t *)&v32, 2u);
    }
    goto LABEL_63;
  }
  _SparseGetOptionsFromSymbolicFactor(&v32, &a1->factor.symbolicFactorization);
  reportError = v32.reportError;
  SparseAttributes_t attributes = a1->attributes;
  int factorization_low = LOBYTE(a1->factor.symbolicFactorization.factorization);
  int v9 = a1->factor.symbolicFactorization.rowCount * factorization_low;
  int v10 = a1->factor.symbolicFactorization.columnCount * factorization_low;
  if (v9 >= v10) {
    int v11 = a1->factor.symbolicFactorization.columnCount * factorization_low;
  }
  else {
    int v11 = a1->factor.symbolicFactorization.rowCount * factorization_low;
  }
  if (v9 <= v10) {
    int v9 = v10;
  }
  if (*((unsigned char *)&a1->contents + 2) == 6 && BYTE1(a1->factor.symbolicFactorization.factorization) == 40) {
    int v13 = v9;
  }
  else {
    int v13 = v11;
  }
  if (*(unsigned char *)&attributes) {
    int v14 = v13;
  }
  else {
    int v14 = v11;
  }
  if (*(unsigned char *)&attributes) {
    int v15 = v11;
  }
  else {
    int v15 = v13;
  }
  int v16 = *(_DWORD *)(a2 + 8);
  int v17 = *(_DWORD *)a2;
  if (v16 < *(_DWORD *)a2)
  {
    if (v32.reportError) {
      goto LABEL_26;
    }
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_63;
    }
    v32.control = 136315906;
    *(void *)&v32.orderMethod = "X";
    WORD2(v32.order) = 1024;
    *(_DWORD *)((char *)&v32.order + 6) = v16;
    WORD1(v32.ignoreRowsAndColumns) = 2080;
    *(int **)((char *)&v32.ignoreRowsAndColumns + 4) = (int *)"X";
    WORD2(v32.malloc) = 1024;
    *(_DWORD *)((char *)&v32.malloc + 6) = v17;
    DenseMatrix_Float v28 = &_os_log_internal;
    goto LABEL_42;
  }
  int columnStride = a3->columnStride;
  rowCFIndex Count = a3->rowCount;
  if (columnStride < a3->rowCount)
  {
    if (v32.reportError)
    {
LABEL_26:
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      long long v36 = 0u;
      long long v37 = 0u;
      long long v34 = 0u;
      long long v35 = 0u;
      long long v33 = 0u;
      memset(&v32, 0, sizeof(v32));
      snprintf((char *)&v32, 0x100uLL, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n");
LABEL_27:
      ((void (*)(SparseSymbolicFactorOptions *))reportError)(&v32);
      return;
    }
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_63;
    }
    v32.control = 136315906;
    *(void *)&v32.orderMethod = "Y";
    WORD2(v32.order) = 1024;
    *(_DWORD *)((char *)&v32.order + 6) = columnStride;
    WORD1(v32.ignoreRowsAndColumns) = 2080;
    *(int **)((char *)&v32.ignoreRowsAndColumns + 4) = (int *)"Y";
    WORD2(v32.malloc) = 1024;
    *(_DWORD *)((char *)&v32.malloc + 6) = rowCount;
    DenseMatrix_Float v28 = &_os_log_internal;
LABEL_42:
    _os_log_error_impl(&dword_2153B7000, v28, OS_LOG_TYPE_ERROR, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n", (uint8_t *)&v32, 0x22u);
    goto LABEL_63;
  }
  __int16 v20 = *(_WORD *)(a2 + 12);
  if ((v20 & 1) == 0) {
    int v17 = *(_DWORD *)(a2 + 4);
  }
  int v21 = *(&a3->rowCount + ((*(_WORD *)&a3->attributes & 1) == 0));
  int v22 = *(_DWORD *)(a2 + 4 * (v20 & 1));
  int v23 = *(&a3->rowCount + (*(_WORD *)&a3->attributes & 1));
  if (v17 != v21)
  {
    if (v32.reportError)
    {
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      long long v36 = 0u;
      long long v37 = 0u;
      long long v34 = 0u;
      long long v35 = 0u;
      long long v33 = 0u;
      memset(&v32, 0, sizeof(v32));
      snprintf((char *)&v32, 0x100uLL, "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n", "X");
      goto LABEL_27;
    }
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_63;
    }
    v32.control = 136316418;
    *(void *)&v32.orderMethod = "X";
    WORD2(v32.order) = 1024;
    *(_DWORD *)((char *)&v32.order + 6) = v22;
    WORD1(v32.ignoreRowsAndColumns) = 1024;
    HIDWORD(v32.ignoreRowsAndColumns) = v17;
    LOWORD(v32.malloc) = 2080;
    *(void *(__cdecl **)(size_t))((char *)&v32.malloc + 2) = (void *(__cdecl *)(size_t))"Y";
    WORD1(v32.free) = 1024;
    HIDWORD(v32.free) = v23;
    LOWORD(v32.reportError) = 1024;
    *(_DWORD *)((char *)&v32.reportError + 2) = v21;
    SparseOpaqueFactorization_Float v29 = &_os_log_internal;
    uint64_t v30 = "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n";
    goto LABEL_60;
  }
  if (v17 <= 0)
  {
    if (v32.reportError)
    {
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      long long v36 = 0u;
      long long v37 = 0u;
      long long v34 = 0u;
      long long v35 = 0u;
      long long v33 = 0u;
      memset(&v32, 0, sizeof(v32));
      snprintf((char *)&v32, 0x100uLL, "%s (%dx%d) must represent at least one right-hand side.\n");
      goto LABEL_27;
    }
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      v32.control = 136315650;
      *(void *)&v32.orderMethod = "X";
      WORD2(v32.order) = 1024;
      *(_DWORD *)((char *)&v32.order + 6) = v22;
      WORD1(v32.ignoreRowsAndColumns) = 1024;
      HIDWORD(v32.ignoreRowsAndColumns) = v17;
      _os_log_error_impl(&dword_2153B7000, &_os_log_internal, OS_LOG_TYPE_ERROR, "%s (%dx%d) must represent at least one right-hand side.\n", (uint8_t *)&v32, 0x18u);
    }
    goto LABEL_63;
  }
  if (v22 != v14)
  {
    if (v32.reportError)
    {
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      long long v36 = 0u;
      long long v37 = 0u;
      long long v34 = 0u;
      long long v35 = 0u;
      long long v33 = 0u;
      memset(&v32, 0, sizeof(v32));
      int v31 = "X";
LABEL_51:
      snprintf((char *)&v32, 0x100uLL, "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n", v31);
      goto LABEL_27;
    }
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_63;
    }
    v32.control = 136316418;
    *(void *)&v32.orderMethod = "X";
    WORD2(v32.order) = 1024;
    *(_DWORD *)((char *)&v32.order + 6) = v22;
    WORD1(v32.ignoreRowsAndColumns) = 1024;
    HIDWORD(v32.ignoreRowsAndColumns) = v17;
    LOWORD(v32.malloc) = 2080;
    *(void *(__cdecl **)(size_t))((char *)&v32.malloc + 2) = (void *(__cdecl *)(size_t))"subfactor dimension";
    WORD1(v32.free) = 1024;
    HIDWORD(v32.free) = v15;
    LOWORD(v32.reportError) = 1024;
    *(_DWORD *)((char *)&v32.reportError + 2) = v14;
    SparseOpaqueFactorization_Float v29 = &_os_log_internal;
    uint64_t v30 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
LABEL_60:
    _os_log_error_impl(&dword_2153B7000, v29, OS_LOG_TYPE_ERROR, v30, (uint8_t *)&v32, 0x2Eu);
    goto LABEL_63;
  }
  if (v23 != v15)
  {
    if (v32.reportError)
    {
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      long long v36 = 0u;
      long long v37 = 0u;
      long long v34 = 0u;
      long long v35 = 0u;
      long long v33 = 0u;
      memset(&v32, 0, sizeof(v32));
      int v31 = "Y";
      goto LABEL_51;
    }
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_63;
    }
    v32.control = 136316418;
    *(void *)&v32.orderMethod = "Y";
    WORD2(v32.order) = 1024;
    *(_DWORD *)((char *)&v32.order + 6) = v23;
    WORD1(v32.ignoreRowsAndColumns) = 1024;
    HIDWORD(v32.ignoreRowsAndColumns) = v17;
    LOWORD(v32.malloc) = 2080;
    *(void *(__cdecl **)(size_t))((char *)&v32.malloc + 2) = (void *(__cdecl *)(size_t))"subfactor dimension";
    WORD1(v32.free) = 1024;
    HIDWORD(v32.free) = v15;
    LOWORD(v32.reportError) = 1024;
    *(_DWORD *)((char *)&v32.reportError + 2) = v14;
    SparseOpaqueFactorization_Float v29 = &_os_log_internal;
    uint64_t v30 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
    goto LABEL_60;
  }
  free = v32.free;
  size_t v25 = a1->workspaceRequiredPerRHS + *(void *)&a1[1].attributes * v17;
  uint64_t v26 = (char *)((uint64_t (*)(size_t))v32.malloc)(v25);
  if (v26)
  {
    int v27 = v26;
    _SparseMultiplySubfactor_Float(a1, (const DenseMatrix_Float *)a2, a3, v26);
    ((void (*)(char *))free)(v27);
    return;
  }
  if (reportError)
  {
    long long v44 = 0u;
    long long v45 = 0u;
    long long v42 = 0u;
    long long v43 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v33 = 0u;
    memset(&v32, 0, sizeof(v32));
    snprintf((char *)&v32, 0x100uLL, "Failed to allocate workspace of size %ld.\n");
    goto LABEL_27;
  }
  if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
  {
    v32.control = 134217984;
    *(void *)&v32.orderMethod = v25;
    _os_log_error_impl(&dword_2153B7000, &_os_log_internal, OS_LOG_TYPE_ERROR, "Failed to allocate workspace of size %ld.\n", (uint8_t *)&v32, 0xCu);
  }
LABEL_63:
  _SparseTrap();
}

void cva::VecLibSparse<float>::multiply(_OWORD *a1, uint64_t a2, uint64_t a3, char *a4)
{
  long long v4 = a1[5];
  v13[4] = a1[4];
  v13[5] = v4;
  long long v5 = a1[7];
  v13[6] = a1[6];
  v13[7] = v5;
  long long v6 = a1[1];
  v13[0] = *a1;
  v13[1] = v6;
  long long v7 = a1[3];
  void v13[2] = a1[2];
  float32x2_t v13[3] = v7;
  long long v8 = *(float **)(a2 + 8);
  int v9 = *(_DWORD *)a3;
  int v10 = *(float **)(a3 + 8);
  v12.rowCFIndex Count = *(_DWORD *)a2;
  v12.columnCFIndex Count = 1;
  v12.int columnStride = v12.rowCount;
  *(_DWORD *)&v12.SparseAttributes_t attributes = 0;
  v12.data = v8;
  v11.rowCFIndex Count = v9;
  v11.columnCFIndex Count = 1;
  v11.int columnStride = v9;
  *(_DWORD *)&v11.SparseAttributes_t attributes = 0;
  v11.data = v10;
  if (a4) {
    sub_2154230AC((const SparseOpaqueSubfactor_Float *)v13, &v12, (uint64_t)&v11, a4);
  }
  else {
    sub_215423700((const SparseOpaqueSubfactor_Float *)v13, (uint64_t)&v12, &v11);
  }
}

void cva::VecLibSparse<double>::multiply(uint64_t a1, long long *a2, long long *a3)
{
  long long v3 = *(_OWORD *)(a1 + 16);
  v8[0] = *(_OWORD *)a1;
  v8[1] = v3;
  uint64_t v9 = *(void *)(a1 + 32);
  long long v6 = *a2;
  uint64_t v7 = *((void *)a2 + 2);
  long long v4 = *a3;
  uint64_t v5 = *((void *)a3 + 2);
  sub_215423F34((uint64_t)v8, (int *)&v6, (uint64_t)&v4, 1.0);
}

void sub_215423F34(uint64_t a1, int *a2, uint64_t a3, double a4)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  int v4 = *(_DWORD *)(a3 + 8);
  int v5 = *(_DWORD *)a3;
  if (v4 >= *(_DWORD *)a3)
  {
    int v7 = a2[2];
    int v8 = *a2;
    if (v7 >= *a2)
    {
      __int16 v9 = *(_WORD *)(a3 + 12);
      if ((v9 & 1) == 0) {
        int v5 = *(_DWORD *)(a3 + 4);
      }
      int v10 = a2[(a2[3] & 1) == 0];
      int v11 = *(_DWORD *)(a3 + 4 * (v9 & 1));
      int v12 = a2[a2[3] & 1];
      if (v5 == v10)
      {
        if (v5 <= 0)
        {
          if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315650;
            int v23 = "Y";
            __int16 v24 = 1024;
            int v25 = v11;
            __int16 v26 = 1024;
            *(_DWORD *)int v27 = v5;
            _os_log_error_impl(&dword_2153B7000, &_os_log_internal, OS_LOG_TYPE_ERROR, "%s (%dx%d) must represent at least one right-hand side.\n", buf, 0x18u);
          }
          goto LABEL_24;
        }
        int v13 = *(unsigned __int8 *)(a1 + 28);
        int v14 = *(_DWORD *)(a1 + 4 * (*(_WORD *)(a1 + 24) & 1)) * v13;
        int v15 = *(_DWORD *)(a1 + 4 * ((*(_WORD *)(a1 + 24) & 1) == 0)) * v13;
        if (v11 == v14)
        {
          if (v12 == v15)
          {
            long long v16 = *(_OWORD *)(a1 + 16);
            *(_OWORD *)&A.structure.rowCFIndex Count = *(_OWORD *)a1;
            *(_OWORD *)&A.structure.rowIndices = v16;
            A.data = *(double **)(a1 + 32);
            DenseMatrix_Double x = *(DenseMatrix_Double *)a2;
            DenseMatrix_Double v19 = *(DenseMatrix_Double *)a3;
            _SparseSpMV_Double(a4, &A, &x, 0, &v19);
            return;
          }
          if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
            goto LABEL_24;
          }
          *(_DWORD *)buf = 136316418;
          int v23 = "X";
          __int16 v24 = 1024;
          int v25 = v12;
          __int16 v26 = 1024;
          *(_DWORD *)int v27 = v5;
          *(_WORD *)&void v27[4] = 2080;
          *(void *)&v27[6] = "matrix A";
          __int16 v28 = 1024;
          int v29 = v15;
          __int16 v30 = 1024;
          int v31 = v14;
          int v17 = &_os_log_internal;
          int v18 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
        }
        else
        {
          if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
            goto LABEL_24;
          }
          *(_DWORD *)buf = 136316418;
          int v23 = "Y";
          __int16 v24 = 1024;
          int v25 = v11;
          __int16 v26 = 1024;
          *(_DWORD *)int v27 = v5;
          *(_WORD *)&void v27[4] = 2080;
          *(void *)&v27[6] = "matrix A";
          __int16 v28 = 1024;
          int v29 = v15;
          __int16 v30 = 1024;
          int v31 = v14;
          int v17 = &_os_log_internal;
          int v18 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
        }
      }
      else
      {
        if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
          goto LABEL_24;
        }
        *(_DWORD *)buf = 136316418;
        int v23 = "Y";
        __int16 v24 = 1024;
        int v25 = v11;
        __int16 v26 = 1024;
        *(_DWORD *)int v27 = v5;
        *(_WORD *)&void v27[4] = 2080;
        *(void *)&v27[6] = "X";
        __int16 v28 = 1024;
        int v29 = v12;
        __int16 v30 = 1024;
        int v31 = v10;
        int v17 = &_os_log_internal;
        int v18 = "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n";
      }
      _os_log_error_impl(&dword_2153B7000, v17, OS_LOG_TYPE_ERROR, v18, buf, 0x2Eu);
      goto LABEL_24;
    }
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      int v23 = "X";
      __int16 v24 = 1024;
      int v25 = v7;
      __int16 v26 = 2080;
      *(void *)int v27 = "X";
      *(_WORD *)&v27[8] = 1024;
      *(_DWORD *)&v27[10] = v8;
      long long v6 = &_os_log_internal;
      goto LABEL_7;
    }
  }
  else if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315906;
    int v23 = "Y";
    __int16 v24 = 1024;
    int v25 = v4;
    __int16 v26 = 2080;
    *(void *)int v27 = "Y";
    *(_WORD *)&v27[8] = 1024;
    *(_DWORD *)&v27[10] = v5;
    long long v6 = &_os_log_internal;
LABEL_7:
    _os_log_error_impl(&dword_2153B7000, v6, OS_LOG_TYPE_ERROR, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n", buf, 0x22u);
  }
LABEL_24:
  _SparseTrap();
}

void cva::VecLibSparse<double>::multiply(uint64_t a1, long long *a2, long long *a3, double a4)
{
  long long v4 = *(_OWORD *)(a1 + 16);
  v9[0] = *(_OWORD *)a1;
  v9[1] = v4;
  uint64_t v10 = *(void *)(a1 + 32);
  long long v7 = *a2;
  uint64_t v8 = *((void *)a2 + 2);
  long long v5 = *a3;
  uint64_t v6 = *((void *)a3 + 2);
  sub_215423F34((uint64_t)v9, (int *)&v7, (uint64_t)&v5, a4);
}

void cva::VecLibSparse<double>::multiply(uint64_t a1, uint64_t a2, uint64_t a3)
{
  long long v3 = *(_OWORD *)(a1 + 16);
  v4[0] = *(_OWORD *)a1;
  v4[1] = v3;
  uint64_t v5 = *(void *)(a1 + 32);
  sub_2154243F0((uint64_t)v4, *(void *)a2, *(double **)(a2 + 8), *(void *)a3, *(double **)(a3 + 8), 1.0);
}

void sub_2154243F0(uint64_t a1, int a2, double *a3, int a4, double *a5, double a6)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  int v7 = *(unsigned __int8 *)(a1 + 28);
  uint64_t v8 = *(_WORD *)(a1 + 24) & 1;
  BOOL v9 = v8 == 0;
  int v10 = *(_DWORD *)(a1 + 4 * v8);
  unsigned int v11 = v9;
  int v12 = v10 * v7;
  int v13 = *(_DWORD *)(a1 + 4 * v11) * v7;
  if (v13 != a2)
  {
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_10;
    }
    *(_DWORD *)buf = 67109888;
    int v22 = v12;
    __int16 v23 = 1024;
    int v24 = v13;
    __int16 v25 = 1024;
    int v26 = a2;
    __int16 v27 = 1024;
    int v28 = 1;
    long long v16 = &_os_log_internal;
    int v17 = "Matrix dimensions (%dx%d) do not match x vector dimensions %dx%d\n";
LABEL_13:
    _os_log_error_impl(&dword_2153B7000, v16, OS_LOG_TYPE_ERROR, v17, buf, 0x1Au);
    goto LABEL_10;
  }
  if (v12 == a4)
  {
    long long v15 = *(_OWORD *)(a1 + 16);
    *(_OWORD *)&A.structure.rowCFIndex Count = *(_OWORD *)a1;
    *(_OWORD *)&A.structure.rowIndices = v15;
    A.data = *(double **)(a1 + 32);
    x.rowCFIndex Count = a2;
    x.columnCFIndex Count = 1;
    x.int columnStride = a2;
    x.SparseAttributes_t attributes = 0;
    x.data = a3;
    v18.rowCFIndex Count = a4;
    v18.columnCFIndex Count = 1;
    v18.int columnStride = a4;
    v18.SparseAttributes_t attributes = 0;
    v18.data = a5;
    _SparseSpMV_Double(a6, &A, &x, 0, &v18);
    return;
  }
  if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 67109888;
    int v22 = v12;
    __int16 v23 = 1024;
    int v24 = a2;
    __int16 v25 = 1024;
    int v26 = a4;
    __int16 v27 = 1024;
    int v28 = 1;
    long long v16 = &_os_log_internal;
    int v17 = "Matrix dimensions (%dx%d) do not match y vector dimensions %dx%d\n";
    goto LABEL_13;
  }
LABEL_10:
  _SparseTrap();
}

void cva::VecLibSparse<double>::multiply(uint64_t a1, uint64_t a2, uint64_t a3, double a4)
{
  long long v4 = *(_OWORD *)(a1 + 16);
  v5[0] = *(_OWORD *)a1;
  v5[1] = v4;
  uint64_t v6 = *(void *)(a1 + 32);
  sub_2154243F0((uint64_t)v5, *(void *)a2, *(double **)(a2 + 8), *(void *)a3, *(double **)(a3 + 8), a4);
}

void cva::VecLibSparse<double>::multiplyAdd(uint64_t a1, long long *a2, long long *a3)
{
  long long v3 = *(_OWORD *)(a1 + 16);
  v8[0] = *(_OWORD *)a1;
  v8[1] = v3;
  uint64_t v9 = *(void *)(a1 + 32);
  long long v6 = *a2;
  uint64_t v7 = *((void *)a2 + 2);
  long long v4 = *a3;
  uint64_t v5 = *((void *)a3 + 2);
  sub_215424640((uint64_t)v8, (int *)&v6, (uint64_t)&v4, 1.0);
}

void sub_215424640(uint64_t a1, int *a2, uint64_t a3, double a4)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  int v4 = *(_DWORD *)(a3 + 8);
  int v5 = *(_DWORD *)a3;
  if (v4 >= *(_DWORD *)a3)
  {
    int v7 = a2[2];
    int v8 = *a2;
    if (v7 >= *a2)
    {
      __int16 v9 = *(_WORD *)(a3 + 12);
      if ((v9 & 1) == 0) {
        int v5 = *(_DWORD *)(a3 + 4);
      }
      int v10 = a2[(a2[3] & 1) == 0];
      int v11 = *(_DWORD *)(a3 + 4 * (v9 & 1));
      int v12 = a2[a2[3] & 1];
      if (v5 == v10)
      {
        if (v5 <= 0)
        {
          if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315650;
            __int16 v23 = "Y";
            __int16 v24 = 1024;
            int v25 = v11;
            __int16 v26 = 1024;
            *(_DWORD *)__int16 v27 = v5;
            _os_log_error_impl(&dword_2153B7000, &_os_log_internal, OS_LOG_TYPE_ERROR, "%s (%dx%d) must represent at least one right-hand side.\n", buf, 0x18u);
          }
          goto LABEL_24;
        }
        int v13 = *(unsigned __int8 *)(a1 + 28);
        int v14 = *(_DWORD *)(a1 + 4 * (*(_WORD *)(a1 + 24) & 1)) * v13;
        int v15 = *(_DWORD *)(a1 + 4 * ((*(_WORD *)(a1 + 24) & 1) == 0)) * v13;
        if (v11 == v14)
        {
          if (v12 == v15)
          {
            long long v16 = *(_OWORD *)(a1 + 16);
            *(_OWORD *)&A.structure.rowCFIndex Count = *(_OWORD *)a1;
            *(_OWORD *)&A.structure.rowIndices = v16;
            A.data = *(double **)(a1 + 32);
            DenseMatrix_Double x = *(DenseMatrix_Double *)a2;
            DenseMatrix_Double v19 = *(DenseMatrix_Double *)a3;
            _SparseSpMV_Double(a4, &A, &x, 1, &v19);
            return;
          }
          if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
            goto LABEL_24;
          }
          *(_DWORD *)buf = 136316418;
          __int16 v23 = "X";
          __int16 v24 = 1024;
          int v25 = v12;
          __int16 v26 = 1024;
          *(_DWORD *)__int16 v27 = v5;
          *(_WORD *)&void v27[4] = 2080;
          *(void *)&v27[6] = "matrix A";
          __int16 v28 = 1024;
          int v29 = v15;
          __int16 v30 = 1024;
          int v31 = v14;
          int v17 = &_os_log_internal;
          DenseMatrix_Double v18 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
        }
        else
        {
          if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
            goto LABEL_24;
          }
          *(_DWORD *)buf = 136316418;
          __int16 v23 = "Y";
          __int16 v24 = 1024;
          int v25 = v11;
          __int16 v26 = 1024;
          *(_DWORD *)__int16 v27 = v5;
          *(_WORD *)&void v27[4] = 2080;
          *(void *)&v27[6] = "matrix A";
          __int16 v28 = 1024;
          int v29 = v15;
          __int16 v30 = 1024;
          int v31 = v14;
          int v17 = &_os_log_internal;
          DenseMatrix_Double v18 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
        }
      }
      else
      {
        if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
          goto LABEL_24;
        }
        *(_DWORD *)buf = 136316418;
        __int16 v23 = "Y";
        __int16 v24 = 1024;
        int v25 = v11;
        __int16 v26 = 1024;
        *(_DWORD *)__int16 v27 = v5;
        *(_WORD *)&void v27[4] = 2080;
        *(void *)&v27[6] = "X";
        __int16 v28 = 1024;
        int v29 = v12;
        __int16 v30 = 1024;
        int v31 = v10;
        int v17 = &_os_log_internal;
        DenseMatrix_Double v18 = "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n";
      }
      _os_log_error_impl(&dword_2153B7000, v17, OS_LOG_TYPE_ERROR, v18, buf, 0x2Eu);
      goto LABEL_24;
    }
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      __int16 v23 = "X";
      __int16 v24 = 1024;
      int v25 = v7;
      __int16 v26 = 2080;
      *(void *)__int16 v27 = "X";
      *(_WORD *)&v27[8] = 1024;
      *(_DWORD *)&v27[10] = v8;
      long long v6 = &_os_log_internal;
      goto LABEL_7;
    }
  }
  else if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315906;
    __int16 v23 = "Y";
    __int16 v24 = 1024;
    int v25 = v4;
    __int16 v26 = 2080;
    *(void *)__int16 v27 = "Y";
    *(_WORD *)&v27[8] = 1024;
    *(_DWORD *)&v27[10] = v5;
    long long v6 = &_os_log_internal;
LABEL_7:
    _os_log_error_impl(&dword_2153B7000, v6, OS_LOG_TYPE_ERROR, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n", buf, 0x22u);
  }
LABEL_24:
  _SparseTrap();
}

void cva::VecLibSparse<double>::multiplyAdd(uint64_t a1, long long *a2, long long *a3, double a4)
{
  long long v4 = *(_OWORD *)(a1 + 16);
  v9[0] = *(_OWORD *)a1;
  v9[1] = v4;
  uint64_t v10 = *(void *)(a1 + 32);
  long long v7 = *a2;
  uint64_t v8 = *((void *)a2 + 2);
  long long v5 = *a3;
  uint64_t v6 = *((void *)a3 + 2);
  sub_215424640((uint64_t)v9, (int *)&v7, (uint64_t)&v5, a4);
}

void cva::VecLibSparse<double>::multiplyAdd(uint64_t a1, uint64_t a2, uint64_t a3)
{
  long long v3 = *(_OWORD *)(a1 + 16);
  v4[0] = *(_OWORD *)a1;
  v4[1] = v3;
  uint64_t v5 = *(void *)(a1 + 32);
  sub_215424AFC((uint64_t)v4, *(void *)a2, *(double **)(a2 + 8), *(void *)a3, *(double **)(a3 + 8), 1.0);
}

void sub_215424AFC(uint64_t a1, int a2, double *a3, int a4, double *a5, double a6)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  int v7 = *(unsigned __int8 *)(a1 + 28);
  uint64_t v8 = *(_WORD *)(a1 + 24) & 1;
  BOOL v9 = v8 == 0;
  int v10 = *(_DWORD *)(a1 + 4 * v8);
  unsigned int v11 = v9;
  int v12 = v10 * v7;
  int v13 = *(_DWORD *)(a1 + 4 * v11) * v7;
  if (v13 != a2)
  {
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_10;
    }
    *(_DWORD *)buf = 67109888;
    int v22 = v12;
    __int16 v23 = 1024;
    int v24 = v13;
    __int16 v25 = 1024;
    int v26 = a2;
    __int16 v27 = 1024;
    int v28 = 1;
    long long v16 = &_os_log_internal;
    int v17 = "Matrix dimensions (%dx%d) do not match x vector dimensions %dx%d\n";
LABEL_13:
    _os_log_error_impl(&dword_2153B7000, v16, OS_LOG_TYPE_ERROR, v17, buf, 0x1Au);
    goto LABEL_10;
  }
  if (v12 == a4)
  {
    long long v15 = *(_OWORD *)(a1 + 16);
    *(_OWORD *)&A.structure.rowCFIndex Count = *(_OWORD *)a1;
    *(_OWORD *)&A.structure.rowIndices = v15;
    A.data = *(double **)(a1 + 32);
    x.rowCFIndex Count = a2;
    x.columnCFIndex Count = 1;
    x.int columnStride = a2;
    x.SparseAttributes_t attributes = 0;
    x.data = a3;
    v18.rowCFIndex Count = a4;
    v18.columnCFIndex Count = 1;
    v18.int columnStride = a4;
    v18.SparseAttributes_t attributes = 0;
    v18.data = a5;
    _SparseSpMV_Double(a6, &A, &x, 1, &v18);
    return;
  }
  if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 67109888;
    int v22 = v12;
    __int16 v23 = 1024;
    int v24 = a2;
    __int16 v25 = 1024;
    int v26 = a4;
    __int16 v27 = 1024;
    int v28 = 1;
    long long v16 = &_os_log_internal;
    int v17 = "Matrix dimensions (%dx%d) do not match y vector dimensions %dx%d\n";
    goto LABEL_13;
  }
LABEL_10:
  _SparseTrap();
}

void cva::VecLibSparse<double>::multiplyAdd(uint64_t a1, uint64_t a2, uint64_t a3, double a4)
{
  long long v4 = *(_OWORD *)(a1 + 16);
  v5[0] = *(_OWORD *)a1;
  v5[1] = v4;
  uint64_t v6 = *(void *)(a1 + 32);
  sub_215424AFC((uint64_t)v5, *(void *)a2, *(double **)(a2 + 8), *(void *)a3, *(double **)(a3 + 8), a4);
}

double cva::VecLibSparse<double>::transpose@<D0>(long long *a1@<X0>, _OWORD *a2@<X8>)
{
  long long v3 = a1[5];
  long long v16 = a1[4];
  long long v17 = v3;
  long long v4 = a1[7];
  long long v18 = a1[6];
  long long v19 = v4;
  long long v5 = a1[1];
  long long v12 = *a1;
  long long v13 = v5;
  long long v6 = a1[3];
  long long v14 = a1[2];
  long long v15 = v6;
  LOWORD(v12) = v12 ^ 1;
  _SparseRetainNumeric_Double((SparseOpaqueFactorization_Double *)((char *)&v12 + 8));
  long long v7 = v17;
  a2[4] = v16;
  a2[5] = v7;
  long long v8 = v19;
  a2[6] = v18;
  a2[7] = v8;
  long long v9 = v13;
  *a2 = v12;
  a2[1] = v9;
  double result = *(double *)&v14;
  long long v11 = v15;
  a2[2] = v14;
  a2[3] = v11;
  return result;
}

__n128 cva::VecLibSparse<double>::transpose@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  long long v3 = *(_OWORD *)(a1 + 80);
  *(_OWORD *)&v9.userFactorStorage = *(_OWORD *)(a1 + 64);
  *(_OWORD *)&v9.solveWorkspaceRequiredStatic = v3;
  uint64_t v10 = *(void *)(a1 + 96);
  long long v4 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)&v9.status = *(_OWORD *)a1;
  *(_OWORD *)&v9.symbolicFactorization.columnCFIndex Count = v4;
  long long v5 = *(_OWORD *)(a1 + 48);
  *(_OWORD *)&v9.symbolicFactorization.workspaceSize_Float = *(_OWORD *)(a1 + 32);
  *(_OWORD *)&v9.symbolicFactorization.factorSize_Float = v5;
  *(_WORD *)&v9.attributes ^= 1u;
  _SparseRetainNumeric_Double(&v9);
  long long v6 = *(_OWORD *)&v9.solveWorkspaceRequiredStatic;
  *(_OWORD *)(a2 + 64) = *(_OWORD *)&v9.userFactorStorage;
  *(_OWORD *)(a2 + 80) = v6;
  *(void *)(a2 + 96) = v10;
  long long v7 = *(_OWORD *)&v9.symbolicFactorization.columnCount;
  *(_OWORD *)a2 = *(_OWORD *)&v9.status;
  *(_OWORD *)(a2 + 16) = v7;
  __n128 result = *(__n128 *)&v9.symbolicFactorization.factorSize_Float;
  *(_OWORD *)(a2 + 32) = *(_OWORD *)&v9.symbolicFactorization.workspaceSize_Float;
  *(__n128 *)(a2 + 48) = result;
  return result;
}

{
  __n128 result;
  __int16 v3;

  __n128 result = *(__n128 *)a1;
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *(void *)(a2 + 16) = *(void *)(a1 + 16);
  long long v3 = *(_WORD *)(a1 + 24);
  *(void *)(a2 + 26) = *(void *)(a1 + 26);
  *(void *)(a2 + 32) = *(void *)(a1 + 32);
  *(_WORD *)(a2 + 24) = v3 ^ 1;
  return result;
}

void cva::VecLibSparse<double>::release(_OWORD *a1)
{
  long long v1 = a1[5];
  _DWORD v5[4] = a1[4];
  v5[5] = v1;
  long long v2 = a1[7];
  v5[6] = a1[6];
  v5[7] = v2;
  long long v3 = a1[1];
  v5[0] = *a1;
  v5[1] = v3;
  long long v4 = a1[3];
  _OWORD v5[2] = a1[2];
  v5[3] = v4;
  _SparseDestroyOpaqueNumeric_Double((SparseOpaqueFactorization_Double *)((char *)v5 + 8));
}

__n128 cva::VecLibSparse<double>::release(uint64_t a1)
{
  long long v1 = *(_OWORD *)(a1 + 80);
  *(_OWORD *)&v5.userFactorStorage = *(_OWORD *)(a1 + 64);
  *(_OWORD *)&v5.solveWorkspaceRequiredStatic = v1;
  uint64_t v6 = *(void *)(a1 + 96);
  long long v2 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)&v5.status = *(_OWORD *)a1;
  *(_OWORD *)&v5.symbolicFactorization.columnCFIndex Count = v2;
  long long v3 = *(_OWORD *)(a1 + 48);
  *(_OWORD *)&v5.symbolicFactorization.workspaceSize_Float = *(_OWORD *)(a1 + 32);
  *(_OWORD *)&v5.symbolicFactorization.factorSize_Float = v3;
  _SparseDestroyOpaqueNumeric_Double(&v5);
  return result;
}

void cva::VecLibSparse<double>::retain(uint64_t a1)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  long long v1 = *(_OWORD *)(a1 + 48);
  *(_OWORD *)&v6.symbolicFactorization.workspaceSize_Float = *(_OWORD *)(a1 + 32);
  *(_OWORD *)&v6.symbolicFactorization.factorSize_Float = v1;
  long long v2 = *(_OWORD *)(a1 + 80);
  *(_OWORD *)&v6.userFactorStorage = *(_OWORD *)(a1 + 64);
  *(_OWORD *)&v6.solveWorkspaceRequiredStatic = v2;
  uint64_t v7 = *(void *)(a1 + 96);
  long long v3 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)&v6.status = *(_OWORD *)a1;
  *(_OWORD *)&v6.symbolicFactorization.columnCFIndex Count = v3;
  if (v6.symbolicFactorization.status || !v6.symbolicFactorization.workspaceSize_Float)
  {
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long v8 = 0;
      SparseOpaqueFactorization_Double v5 = &_os_log_internal;
      goto LABEL_14;
    }
LABEL_7:
    _SparseTrap();
    return;
  }
  _SparseGetOptionsFromSymbolicFactor((SparseSymbolicFactorOptions *)v8, &v6.symbolicFactorization);
  long long v4 = *(void (**)(unsigned char *))&v8[40];
  if (v6.status == SparseStatusOK && v6.solveWorkspaceRequiredStatic)
  {
    _SparseRetainNumeric_Double(&v6);
    return;
  }
  if (!*(void *)&v8[40])
  {
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long v8 = 0;
      SparseOpaqueFactorization_Double v5 = &_os_log_internal;
LABEL_14:
      _os_log_error_impl(&dword_2153B7000, v5, OS_LOG_TYPE_ERROR, "Can only retain valid numeric factorizations.\n", v8, 2u);
      goto LABEL_7;
    }
    goto LABEL_7;
  }
  char v21 = 0;
  long long v20 = 0u;
  long long v19 = 0u;
  long long v18 = 0u;
  long long v17 = 0u;
  long long v16 = 0u;
  long long v15 = 0u;
  long long v14 = 0u;
  long long v13 = 0u;
  long long v12 = 0u;
  long long v11 = 0u;
  long long v10 = 0u;
  long long v9 = 0u;
  *(_OWORD *)&v8[47] = 0u;
  strcpy(v8, "Can only retain valid numeric factorizations.\n");
  v4(v8);
}

void cva::VecLibSparse<double>::retain(long long *a1)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  long long v1 = a1[5];
  long long v11 = a1[4];
  long long v12 = v1;
  long long v2 = a1[7];
  long long v13 = a1[6];
  long long v14 = v2;
  long long v3 = a1[1];
  long long v7 = *a1;
  long long v8 = v3;
  long long v4 = a1[3];
  long long v9 = a1[2];
  long long v10 = v4;
  if (v3 || !*((void *)&v9 + 1))
  {
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v15.control) = 0;
      SparseOpaqueFactorization_Double v6 = &_os_log_internal;
      goto LABEL_14;
    }
LABEL_7:
    _SparseTrap();
    return;
  }
  _SparseGetOptionsFromSymbolicFactor(&v15, (SparseOpaqueSymbolicFactorization *)&v8);
  reportError = v15.reportError;
  if (!DWORD2(v7) && *((void *)&v12 + 1))
  {
    _SparseRetainNumeric_Double((SparseOpaqueFactorization_Double *)((char *)&v7 + 8));
    return;
  }
  if (!v15.reportError)
  {
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v15.control) = 0;
      SparseOpaqueFactorization_Double v6 = &_os_log_internal;
LABEL_14:
      _os_log_error_impl(&dword_2153B7000, v6, OS_LOG_TYPE_ERROR, "Can only retain valid objects.\n", (uint8_t *)&v15, 2u);
      goto LABEL_7;
    }
    goto LABEL_7;
  }
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  *(_OWORD *)&v15.free = 0u;
  long long v16 = 0u;
  strcpy((char *)&v15, "Can only retain valid objects.\n");
  ((void (*)(SparseSymbolicFactorOptions *))reportError)(&v15);
}

double cva::VecLibSparse<double>::factor@<D0>(SparseFactorization_t factorType@<W1>, uint64_t a2@<X0>, uint64_t a3@<X8>)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  long long v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)&Matrix.structure.rowCFIndex Count = *(_OWORD *)a2;
  *(_OWORD *)&Matrix.structure.rowIndices = v4;
  Matrix.data = *(double **)(a2 + 32);
  SparseSymbolicFactorOptions sfoptions = *(SparseSymbolicFactorOptions *)byte_26C5FB310;
  SparseNumericFactorOptions v10 = *(SparseNumericFactorOptions *)ymmword_215446270;
  if (Matrix.structure.rowCount <= 0)
  {
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    *(_DWORD *)buf = 136315394;
    long long v14 = "Matrix.structure";
    __int16 v15 = 1024;
    LODWORD(v16) = Matrix.structure.rowCount;
    SparseOpaqueFactorization_Double v6 = &_os_log_internal;
    long long v7 = "%s.rowCount must be > 0, but is %d.\n";
LABEL_14:
    uint32_t v8 = 18;
    goto LABEL_15;
  }
  if (Matrix.structure.columnCount <= 0)
  {
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    *(_DWORD *)buf = 136315394;
    long long v14 = "Matrix.structure";
    __int16 v15 = 1024;
    LODWORD(v16) = Matrix.structure.rowCount;
    SparseOpaqueFactorization_Double v6 = &_os_log_internal;
    long long v7 = "%s.columnCount must be > 0, but is %d.\n";
    goto LABEL_14;
  }
  if (!*(&Matrix.structure.blockSize + 2))
  {
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    *(_DWORD *)buf = 136315394;
    long long v14 = "Matrix.structure";
    __int16 v15 = 1024;
    LODWORD(v16) = 0;
    SparseOpaqueFactorization_Double v6 = &_os_log_internal;
    long long v7 = "%s.blockSize must be > 0, but is %d.]n";
    goto LABEL_14;
  }
  int v5 = *(unsigned char *)&Matrix.structure.attributes & 0xC;
  if (Matrix.structure.rowCount == Matrix.structure.columnCount || v5 != 12)
  {
    if ((factorType & 0xFE) == 0x28)
    {
      _SparseFactorQR_Double((SparseOpaqueFactorization_Double *)a3, factorType, &Matrix, &sfoptions, &v10);
      return result;
    }
    if (v5 == 12)
    {
      _SparseFactorSymmetric_Double((SparseOpaqueFactorization_Double *)a3, factorType, &Matrix, &sfoptions, &v10);
      return result;
    }
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      SparseOpaqueFactorization_Double v6 = &_os_log_internal;
      long long v7 = "Cannot perform symmetric matrix factorization of non-square matrix.\n";
      uint32_t v8 = 2;
      goto LABEL_15;
    }
  }
  else if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136316162;
    long long v14 = "Matrix.structure";
    __int16 v15 = 2080;
    long long v16 = "Matrix.structure";
    __int16 v17 = 1024;
    rowCFIndex Count = Matrix.structure.rowCount;
    __int16 v19 = 2080;
    long long v20 = "Matrix.structure";
    __int16 v21 = 1024;
    columnCFIndex Count = Matrix.structure.columnCount;
    SparseOpaqueFactorization_Double v6 = &_os_log_internal;
    long long v7 = "%s.attributes.kind=SparseSymmetric, but %s.rowCount (%d) != %s.columnCount (%d).\n";
    uint32_t v8 = 44;
LABEL_15:
    _os_log_error_impl(&dword_2153B7000, v6, OS_LOG_TYPE_ERROR, v7, buf, v8);
  }
LABEL_21:
  _SparseTrap();
  double result = 0.0;
  *(void *)(a3 + 96) = 0;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_DWORD *)a3 = -4;
  *(_DWORD *)(a3 + 8) = -4;
  return result;
}

void cva::VecLibSparse<double>::refactor(long long *a1, SparseOpaqueFactorization_Double *factor)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  long long v11 = *a1;
  long long v12 = a1[1];
  long long v13 = (void (__cdecl *)(void *))*((void *)a1 + 4);
  p_symbolicFactorization = &factor->symbolicFactorization;
  if (factor->symbolicFactorization.status || !factor->symbolicFactorization.workspaceSize_Float)
  {
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_3;
    }
    LOWORD(v17.control) = 0;
    uint32_t v8 = &_os_log_internal;
    long long v9 = "Factorization does not hold a completed matrix factorization.\n";
LABEL_21:
    _os_log_error_impl(&dword_2153B7000, v8, OS_LOG_TYPE_ERROR, v9, (uint8_t *)&v17, 2u);
    goto LABEL_3;
  }
  memset(&v15, 0, sizeof(v15));
  _SparseGetOptionsFromNumericFactor_Double(&v15, factor);
  SparseNumericFactorOptions v14 = v15;
  if (factor->symbolicFactorization.status || !factor->symbolicFactorization.workspaceSize_Float)
  {
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_3;
    }
    LOWORD(v17.control) = 0;
    uint32_t v8 = &_os_log_internal;
    long long v9 = "Factorization does not hold a valid symbolic matrix factorization.\n";
    goto LABEL_21;
  }
  _SparseGetOptionsFromSymbolicFactor(&v17, p_symbolicFactorization);
  free = v17.free;
  reportError = v17.reportError;
  SparseOpaqueFactorization_Double v6 = (void *)((uint64_t (*)(size_t))v17.malloc)(factor->symbolicFactorization.factorSize_Float);
  if (!v6)
  {
    factor->status = SparseInternalError;
    if (reportError)
    {
      long long v29 = 0u;
      long long v30 = 0u;
      long long v27 = 0u;
      long long v28 = 0u;
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      long long v18 = 0u;
      memset(&v17, 0, sizeof(v17));
      snprintf((char *)&v17, 0x100uLL, "Failed to allocate workspace of size %ld.", factor->symbolicFactorization.factorSize_Float);
      ((void (*)(SparseSymbolicFactorOptions *))reportError)(&v17);
      return;
    }
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      size_t factorSize_Float = factor->symbolicFactorization.factorSize_Float;
      v17.control = 134217984;
      *(void *)&v17.orderMethod = factorSize_Float;
      _os_log_error_impl(&dword_2153B7000, &_os_log_internal, OS_LOG_TYPE_ERROR, "Failed to allocate workspace of size %ld.", (uint8_t *)&v17, 0xCu);
    }
LABEL_3:
    _SparseTrap();
    return;
  }
  long long v7 = v6;
  *(_OWORD *)&v17.control = v11;
  *(_OWORD *)&v17.ignoreRowsAndColumns = v12;
  v17.free = v13;
  SparseNumericFactorOptions nfoptions = v14;
  if (v11 == factor->symbolicFactorization.rowCount
    && *(_DWORD *)&v17.orderMethod == factor->symbolicFactorization.columnCount
    && BYTE4(v17.malloc) == LOBYTE(factor->symbolicFactorization.factorization)
    && ((*(_WORD *)&factor->symbolicFactorization.attributes ^ LOWORD(v17.malloc)) & 1) == 0)
  {
    if ((BYTE1(factor->symbolicFactorization.factorization) & 0xFE) == 0x28) {
      _SparseRefactorQR_Double((const SparseMatrix_Double *)&v17, factor, &nfoptions, v6);
    }
    else {
      _SparseRefactorSymmetric_Double((const SparseMatrix_Double *)&v17, factor, &nfoptions, v6);
    }
  }
  else
  {
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      uint64_t v32 = "Matrix";
      __int16 v33 = 2080;
      long long v34 = "Factored->symbolicFactorization";
      _os_log_error_impl(&dword_2153B7000, &_os_log_internal, OS_LOG_TYPE_ERROR, "%s does not match that used for symbolic factorization stored in %s.\n", buf, 0x16u);
    }
    _SparseTrap();
  }
  ((void (*)(void *))free)(v7);
}

void cva::VecLibSparse<double>::solve(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v54 = *MEMORY[0x263EF8340];
  if (a4)
  {
    long long v4 = *(_OWORD *)(a1 + 80);
    *(_OWORD *)&Factored.userFactorStorage = *(_OWORD *)(a1 + 64);
    *(_OWORD *)&Factored.solveWorkspaceRequiredStatic = v4;
    uint64_t v37 = *(void *)(a1 + 96);
    long long v5 = *(_OWORD *)(a1 + 16);
    *(_OWORD *)&Factored.status = *(_OWORD *)a1;
    *(_OWORD *)&Factored.symbolicFactorization.columnCFIndex Count = v5;
    long long v6 = *(_OWORD *)(a1 + 48);
    *(_OWORD *)&Factored.symbolicFactorization.workspaceSize_Float = *(_OWORD *)(a1 + 32);
    *(_OWORD *)&Factored.symbolicFactorization.size_t factorSize_Float = v6;
    if (Factored.symbolicFactorization.status == SparseStatusOK && Factored.symbolicFactorization.workspaceSize_Float)
    {
      SparseControl_t v12 = *(_DWORD *)a3;
      long long v13 = *(int **)(a3 + 8);
      int v14 = *(_DWORD *)a2;
      SparseNumericFactorOptions v15 = *(double **)(a2 + 8);
      _SparseGetOptionsFromSymbolicFactor(&v40, &Factored.symbolicFactorization);
      reportError = v40.reportError;
      if (Factored.symbolicFactorization.status == SparseStatusOK
        && Factored.symbolicFactorization.workspaceSize_Float
        && Factored.status == SparseStatusOK
        && Factored.solveWorkspaceRequiredStatic)
      {
        if ((*(unsigned char *)&Factored.attributes ^ *(unsigned char *)&Factored.symbolicFactorization.attributes)) {
          int v17 = Factored.symbolicFactorization.columnCount * LOBYTE(Factored.symbolicFactorization.factorization);
        }
        else {
          int v17 = Factored.symbolicFactorization.rowCount * LOBYTE(Factored.symbolicFactorization.factorization);
        }
        if ((*(unsigned char *)&Factored.attributes ^ *(unsigned char *)&Factored.symbolicFactorization.attributes)) {
          int v18 = Factored.symbolicFactorization.rowCount * LOBYTE(Factored.symbolicFactorization.factorization);
        }
        else {
          int v18 = Factored.symbolicFactorization.columnCount * LOBYTE(Factored.symbolicFactorization.factorization);
        }
        if (BYTE1(Factored.symbolicFactorization.factorization) == 40) {
          int v19 = v17;
        }
        else {
          int v19 = v18;
        }
        if (v18 == v14)
        {
          if (v19 == v12)
          {
            v40.control = v12;
            *(_DWORD *)&v40.orderMethod = 1;
            v40.ignoreRowsAndColumns = v13;
            v40.order = (int *)v12;
            Soln.rowCFIndex Count = v14;
            Soln.columnCFIndex Count = 1;
            *(_DWORD *)&Soln.SparseAttributes_t attributes = 0;
            Soln.data = v15;
            Soln.int columnStride = v14;
            _SparseSolveOpaque_Double(&Factored, (const DenseMatrix_Double *)&v40, &Soln, a4);
            return;
          }
          if (v40.reportError) {
            goto LABEL_62;
          }
          if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
          {
            v40.control = 136316162;
            *(void *)&v40.orderMethod = "b";
            *(_DWORD *)((char *)&v40.order + 6) = v12;
            WORD1(v40.ignoreRowsAndColumns) = 2080;
            WORD2(v40.order) = 1024;
            *(int **)((char *)&v40.ignoreRowsAndColumns + 4) = (int *)"Factored";
            WORD2(v40.malloc) = 1024;
            *(_DWORD *)((char *)&v40.malloc + 6) = v19;
            WORD1(v40.free) = 1024;
            HIDWORD(v40.free) = v14;
            __int16 v33 = &_os_log_internal;
            goto LABEL_72;
          }
LABEL_7:
          _SparseTrap();
          return;
        }
        if (v40.reportError) {
          goto LABEL_62;
        }
        if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
          goto LABEL_7;
        }
        v40.control = 136316162;
        *(void *)&v40.orderMethod = "x";
        *(_DWORD *)((char *)&v40.order + 6) = v14;
        WORD1(v40.ignoreRowsAndColumns) = 2080;
        WORD2(v40.order) = 1024;
        *(int **)((char *)&v40.ignoreRowsAndColumns + 4) = (int *)"Factored";
        WORD2(v40.malloc) = 1024;
        *(_DWORD *)((char *)&v40.malloc + 6) = v19;
        WORD1(v40.free) = 1024;
        HIDWORD(v40.free) = v18;
        __int16 v33 = &_os_log_internal;
LABEL_72:
        _os_log_error_impl(&dword_2153B7000, v33, OS_LOG_TYPE_ERROR, "%s (size %dx1) does not match dimensions of matrix factorization %s (%d x %d).\n", (uint8_t *)&v40, 0x28u);
        goto LABEL_7;
      }
      if (!v40.reportError)
      {
        if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
          goto LABEL_7;
        }
        v40.control = 136315138;
        *(void *)&v40.orderMethod = "Factored";
        int v31 = &_os_log_internal;
        uint64_t v32 = "%s does not hold a completed matrix factorization.\n";
        goto LABEL_58;
      }
      goto LABEL_47;
    }
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_7;
    }
    LOWORD(v40.control) = 0;
    long long v7 = &_os_log_internal;
LABEL_55:
    _os_log_error_impl(&dword_2153B7000, v7, OS_LOG_TYPE_ERROR, "Factored does not hold a completed matrix factorization.\n", (uint8_t *)&v40, 2u);
    goto LABEL_7;
  }
  long long v8 = *(_OWORD *)(a1 + 80);
  *(_OWORD *)&v34.userFactorStorage = *(_OWORD *)(a1 + 64);
  *(_OWORD *)&v34.solveWorkspaceRequiredStatic = v8;
  uint64_t v35 = *(void *)(a1 + 96);
  long long v9 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)&v34.status = *(_OWORD *)a1;
  *(_OWORD *)&v34.symbolicFactorization.columnCFIndex Count = v9;
  long long v10 = *(_OWORD *)(a1 + 48);
  *(_OWORD *)&v34.symbolicFactorization.workspaceSize_Float = *(_OWORD *)(a1 + 32);
  *(_OWORD *)&v34.symbolicFactorization.size_t factorSize_Float = v10;
  if (v34.symbolicFactorization.status || !v34.symbolicFactorization.workspaceSize_Float)
  {
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_7;
    }
    LOWORD(v40.control) = 0;
    long long v7 = &_os_log_internal;
    goto LABEL_55;
  }
  int v20 = *(_DWORD *)a3;
  long long v21 = *(double **)(a3 + 8);
  int v22 = *(_DWORD *)a2;
  long long v23 = *(double **)(a2 + 8);
  _SparseGetOptionsFromSymbolicFactor(&v40, &v34.symbolicFactorization);
  reportError = v40.reportError;
  if (v34.symbolicFactorization.status == SparseStatusOK
    && v34.symbolicFactorization.workspaceSize_Float
    && v34.status == SparseStatusOK
    && v34.solveWorkspaceRequiredStatic)
  {
    if ((*(unsigned char *)&v34.attributes ^ *(unsigned char *)&v34.symbolicFactorization.attributes)) {
      int v24 = v34.symbolicFactorization.columnCount * LOBYTE(v34.symbolicFactorization.factorization);
    }
    else {
      int v24 = v34.symbolicFactorization.rowCount * LOBYTE(v34.symbolicFactorization.factorization);
    }
    if ((*(unsigned char *)&v34.attributes ^ *(unsigned char *)&v34.symbolicFactorization.attributes)) {
      int v25 = v34.symbolicFactorization.rowCount * LOBYTE(v34.symbolicFactorization.factorization);
    }
    else {
      int v25 = v34.symbolicFactorization.columnCount * LOBYTE(v34.symbolicFactorization.factorization);
    }
    if (BYTE1(v34.symbolicFactorization.factorization) == 40) {
      int v26 = v24;
    }
    else {
      int v26 = v25;
    }
    if (v25 != v22)
    {
      if (v40.reportError) {
        goto LABEL_62;
      }
      if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
        goto LABEL_7;
      }
      v40.control = 136316162;
      *(void *)&v40.orderMethod = "x";
      *(_DWORD *)((char *)&v40.order + 6) = v22;
      WORD1(v40.ignoreRowsAndColumns) = 2080;
      WORD2(v40.order) = 1024;
      *(int **)((char *)&v40.ignoreRowsAndColumns + 4) = (int *)"Factored";
      WORD2(v40.malloc) = 1024;
      *(_DWORD *)((char *)&v40.malloc + 6) = v26;
      WORD1(v40.free) = 1024;
      HIDWORD(v40.free) = v25;
      __int16 v33 = &_os_log_internal;
      goto LABEL_72;
    }
    if (v26 != v20)
    {
      if (!v40.reportError)
      {
        if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
        {
          v40.control = 136316162;
          *(void *)&v40.orderMethod = "b";
          *(_DWORD *)((char *)&v40.order + 6) = v20;
          WORD1(v40.ignoreRowsAndColumns) = 2080;
          WORD2(v40.order) = 1024;
          *(int **)((char *)&v40.ignoreRowsAndColumns + 4) = (int *)"Factored";
          WORD2(v40.malloc) = 1024;
          *(_DWORD *)((char *)&v40.malloc + 6) = v26;
          WORD1(v40.free) = 1024;
          HIDWORD(v40.free) = v22;
          __int16 v33 = &_os_log_internal;
          goto LABEL_72;
        }
        goto LABEL_7;
      }
LABEL_62:
      long long v52 = 0u;
      long long v53 = 0u;
      long long v50 = 0u;
      long long v51 = 0u;
      long long v48 = 0u;
      long long v49 = 0u;
      long long v46 = 0u;
      long long v47 = 0u;
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v41 = 0u;
      memset(&v40, 0, sizeof(v40));
      snprintf((char *)&v40, 0x100uLL, "%s (size %dx1) does not match dimensions of matrix factorization %s (%d x %d).\n");
      goto LABEL_63;
    }
    free = v40.free;
    Soln.rowCFIndex Count = v20;
    Soln.columnCFIndex Count = 1;
    *(_DWORD *)&Soln.SparseAttributes_t attributes = 0;
    Soln.data = v21;
    Soln.int columnStride = v20;
    *(_DWORD *)&v38.SparseAttributes_t attributes = 0;
    v38.data = v23;
    v38.rowCFIndex Count = v22;
    v38.columnCFIndex Count = 1;
    v38.int columnStride = v22;
    size_t v28 = v35 + v34.solveWorkspaceRequiredPerRHS;
    long long v29 = (void *)((uint64_t (*)(size_t))v40.malloc)(v35 + v34.solveWorkspaceRequiredPerRHS);
    if (v29)
    {
      long long v30 = v29;
      _SparseSolveOpaque_Double(&v34, &Soln, &v38, v29);
      ((void (*)(void *))free)(v30);
      return;
    }
    if (reportError)
    {
      long long v52 = 0u;
      long long v53 = 0u;
      long long v50 = 0u;
      long long v51 = 0u;
      long long v48 = 0u;
      long long v49 = 0u;
      long long v46 = 0u;
      long long v47 = 0u;
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v41 = 0u;
      memset(&v40, 0, sizeof(v40));
      snprintf((char *)&v40, 0x100uLL, "Failed to allocate workspace of size %ld for SparseSolve().\n");
      goto LABEL_63;
    }
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_7;
    }
    v40.control = 134217984;
    *(void *)&v40.orderMethod = v28;
    int v31 = &_os_log_internal;
    uint64_t v32 = "Failed to allocate workspace of size %ld for SparseSolve().\n";
LABEL_58:
    _os_log_error_impl(&dword_2153B7000, v31, OS_LOG_TYPE_ERROR, v32, (uint8_t *)&v40, 0xCu);
    goto LABEL_7;
  }
  if (!v40.reportError)
  {
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_7;
    }
    v40.control = 136315138;
    *(void *)&v40.orderMethod = "Factored";
    int v31 = &_os_log_internal;
    uint64_t v32 = "%s does not hold a completed matrix factorization.\n";
    goto LABEL_58;
  }
LABEL_47:
  long long v52 = 0u;
  long long v53 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v41 = 0u;
  memset(&v40, 0, sizeof(v40));
  snprintf((char *)&v40, 0x100uLL, "%s does not hold a completed matrix factorization.\n");
LABEL_63:
  ((void (*)(SparseSymbolicFactorOptions *))reportError)(&v40);
}

void cva::VecLibSparse<double>::solve(uint64_t a1, DenseMatrix_Double *a2, DenseMatrix_Double *a3, void *a4)
{
  uint64_t v62 = *MEMORY[0x263EF8340];
  if (a4)
  {
    long long v4 = *(_OWORD *)(a1 + 80);
    *(_OWORD *)&Factored.userFactorStorage = *(_OWORD *)(a1 + 64);
    *(_OWORD *)&Factored.solveWorkspaceRequiredStatic = v4;
    uint64_t v47 = *(void *)(a1 + 96);
    long long v5 = *(_OWORD *)(a1 + 16);
    *(_OWORD *)&Factored.status = *(_OWORD *)a1;
    *(_OWORD *)&Factored.symbolicFactorization.columnCFIndex Count = v5;
    long long v6 = *(_OWORD *)(a1 + 48);
    *(_OWORD *)&Factored.symbolicFactorization.workspaceSize_Float = *(_OWORD *)(a1 + 32);
    *(_OWORD *)&Factored.symbolicFactorization.size_t factorSize_Float = v6;
    DenseMatrix_Double RHS = *a3;
    DenseMatrix_Double Soln = *a2;
    if (Factored.symbolicFactorization.status == SparseStatusOK && Factored.symbolicFactorization.workspaceSize_Float)
    {
      _SparseGetOptionsFromSymbolicFactor(&v48, &Factored.symbolicFactorization);
      reportError = v48.reportError;
      if (Factored.symbolicFactorization.status == SparseStatusOK
        && Factored.symbolicFactorization.workspaceSize_Float
        && Factored.status == SparseStatusOK
        && Factored.solveWorkspaceRequiredStatic)
      {
        if ((*(unsigned char *)&Factored.attributes ^ *(unsigned char *)&Factored.symbolicFactorization.attributes)) {
          int v13 = Factored.symbolicFactorization.columnCount * LOBYTE(Factored.symbolicFactorization.factorization);
        }
        else {
          int v13 = Factored.symbolicFactorization.rowCount * LOBYTE(Factored.symbolicFactorization.factorization);
        }
        if ((*(unsigned char *)&Factored.attributes ^ *(unsigned char *)&Factored.symbolicFactorization.attributes)) {
          int v14 = Factored.symbolicFactorization.rowCount * LOBYTE(Factored.symbolicFactorization.factorization);
        }
        else {
          int v14 = Factored.symbolicFactorization.columnCount * LOBYTE(Factored.symbolicFactorization.factorization);
        }
        if (BYTE1(Factored.symbolicFactorization.factorization) == 40) {
          int v15 = v13;
        }
        else {
          int v15 = v14;
        }
        if (RHS.columnStride < RHS.rowCount)
        {
          if (v48.reportError) {
            goto LABEL_48;
          }
          if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
          {
            v48.control = 136315906;
            *(void *)&v48.orderMethod = "B";
            WORD2(v48.order) = 1024;
            *(_DWORD *)((char *)&v48.order + 6) = RHS.columnStride;
            WORD1(v48.ignoreRowsAndColumns) = 2080;
            *(int **)((char *)&v48.ignoreRowsAndColumns + 4) = (int *)"B";
            WORD2(v48.malloc) = 1024;
            *(_DWORD *)((char *)&v48.malloc + 6) = RHS.rowCount;
            int v26 = &_os_log_internal;
LABEL_108:
            _os_log_error_impl(&dword_2153B7000, v26, OS_LOG_TYPE_ERROR, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n", (uint8_t *)&v48, 0x22u);
            goto LABEL_7;
          }
          goto LABEL_7;
        }
        if (Soln.columnStride < Soln.rowCount)
        {
          if (v48.reportError)
          {
LABEL_48:
            long long v60 = 0u;
            long long v61 = 0u;
            long long v58 = 0u;
            long long v59 = 0u;
            long long v56 = 0u;
            long long v57 = 0u;
            long long v54 = 0u;
            long long v55 = 0u;
            long long v52 = 0u;
            long long v53 = 0u;
            long long v50 = 0u;
            long long v51 = 0u;
            long long v49 = 0u;
            memset(&v48, 0, sizeof(v48));
            snprintf((char *)&v48, 0x100uLL, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n");
            goto LABEL_49;
          }
          if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
          {
            v48.control = 136315906;
            *(void *)&v48.orderMethod = "X";
            WORD2(v48.order) = 1024;
            *(_DWORD *)((char *)&v48.order + 6) = Soln.columnStride;
            WORD1(v48.ignoreRowsAndColumns) = 2080;
            *(int **)((char *)&v48.ignoreRowsAndColumns + 4) = (int *)"X";
            WORD2(v48.malloc) = 1024;
            *(_DWORD *)((char *)&v48.malloc + 6) = Soln.rowCount;
            int v26 = &_os_log_internal;
            goto LABEL_108;
          }
          goto LABEL_7;
        }
        if (*(unsigned char *)&RHS.attributes) {
          rowCFIndex Count = RHS.rowCount;
        }
        else {
          rowCFIndex Count = RHS.columnCount;
        }
        if (*(unsigned char *)&RHS.attributes) {
          columnCFIndex Count = RHS.columnCount;
        }
        else {
          columnCFIndex Count = RHS.rowCount;
        }
        if (*(unsigned char *)&Soln.attributes) {
          int v24 = Soln.rowCount;
        }
        else {
          int v24 = Soln.columnCount;
        }
        if (*(unsigned char *)&Soln.attributes) {
          int v25 = Soln.columnCount;
        }
        else {
          int v25 = Soln.rowCount;
        }
        if (rowCount != v24)
        {
          if (v48.reportError)
          {
            long long v60 = 0u;
            long long v61 = 0u;
            long long v58 = 0u;
            long long v59 = 0u;
            long long v56 = 0u;
            long long v57 = 0u;
            long long v54 = 0u;
            long long v55 = 0u;
            long long v52 = 0u;
            long long v53 = 0u;
            long long v50 = 0u;
            long long v51 = 0u;
            long long v49 = 0u;
            memset(&v48, 0, sizeof(v48));
            snprintf((char *)&v48, 0x100uLL, "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n", "B");
            goto LABEL_49;
          }
          if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
            goto LABEL_7;
          }
          v48.control = 136316418;
          *(void *)&v48.orderMethod = "B";
          WORD2(v48.order) = 1024;
          *(_DWORD *)((char *)&v48.order + 6) = columnCount;
          WORD1(v48.ignoreRowsAndColumns) = 1024;
          HIDWORD(v48.ignoreRowsAndColumns) = rowCount;
          LOWORD(v48.malloc) = 2080;
          *(void *(__cdecl **)(size_t))((char *)&v48.malloc + 2) = (void *(__cdecl *)(size_t))"X";
          WORD1(v48.free) = 1024;
          HIDWORD(v48.free) = v25;
          LOWORD(v48.reportError) = 1024;
          *(_DWORD *)((char *)&v48.reportError + 2) = v24;
          uint64_t v35 = &_os_log_internal;
          long long v36 = "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n";
          goto LABEL_142;
        }
        if (rowCount > 0)
        {
          if (columnCount == v15)
          {
            if (v25 == v14)
            {
              _SparseSolveOpaque_Double(&Factored, &RHS, &Soln, a4);
              return;
            }
            if (v48.reportError)
            {
              long long v60 = 0u;
              long long v61 = 0u;
              long long v58 = 0u;
              long long v59 = 0u;
              long long v56 = 0u;
              long long v57 = 0u;
              long long v54 = 0u;
              long long v55 = 0u;
              long long v52 = 0u;
              long long v53 = 0u;
              long long v50 = 0u;
              long long v51 = 0u;
              long long v49 = 0u;
              memset(&v48, 0, sizeof(v48));
              uint64_t v37 = "X";
              goto LABEL_123;
            }
            if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
              goto LABEL_7;
            }
            v48.control = 136316418;
            *(void *)&v48.orderMethod = "X";
            WORD2(v48.order) = 1024;
            *(_DWORD *)((char *)&v48.order + 6) = v25;
            WORD1(v48.ignoreRowsAndColumns) = 1024;
            HIDWORD(v48.ignoreRowsAndColumns) = rowCount;
            LOWORD(v48.malloc) = 2080;
            *(void *(__cdecl **)(size_t))((char *)&v48.malloc + 2) = (void *(__cdecl *)(size_t))"matrix factorization Factored";
            WORD1(v48.free) = 1024;
            HIDWORD(v48.free) = v14;
            LOWORD(v48.reportError) = 1024;
            *(_DWORD *)((char *)&v48.reportError + 2) = v15;
            uint64_t v35 = &_os_log_internal;
            long long v36 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
          }
          else
          {
            if (v48.reportError)
            {
              long long v60 = 0u;
              long long v61 = 0u;
              long long v58 = 0u;
              long long v59 = 0u;
              long long v56 = 0u;
              long long v57 = 0u;
              long long v54 = 0u;
              long long v55 = 0u;
              long long v52 = 0u;
              long long v53 = 0u;
              long long v50 = 0u;
              long long v51 = 0u;
              long long v49 = 0u;
              memset(&v48, 0, sizeof(v48));
              uint64_t v37 = "B";
LABEL_123:
              snprintf((char *)&v48, 0x100uLL, "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n", v37);
              goto LABEL_49;
            }
            if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
              goto LABEL_7;
            }
            v48.control = 136316418;
            *(void *)&v48.orderMethod = "B";
            WORD2(v48.order) = 1024;
            *(_DWORD *)((char *)&v48.order + 6) = columnCount;
            WORD1(v48.ignoreRowsAndColumns) = 1024;
            HIDWORD(v48.ignoreRowsAndColumns) = rowCount;
            LOWORD(v48.malloc) = 2080;
            *(void *(__cdecl **)(size_t))((char *)&v48.malloc + 2) = (void *(__cdecl *)(size_t))"matrix factorization Factored";
            WORD1(v48.free) = 1024;
            HIDWORD(v48.free) = v14;
            LOWORD(v48.reportError) = 1024;
            *(_DWORD *)((char *)&v48.reportError + 2) = v15;
            uint64_t v35 = &_os_log_internal;
            long long v36 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
          }
LABEL_142:
          _os_log_error_impl(&dword_2153B7000, v35, OS_LOG_TYPE_ERROR, v36, (uint8_t *)&v48, 0x2Eu);
          goto LABEL_7;
        }
        if (v48.reportError)
        {
          long long v60 = 0u;
          long long v61 = 0u;
          long long v58 = 0u;
          long long v59 = 0u;
          long long v56 = 0u;
          long long v57 = 0u;
          long long v54 = 0u;
          long long v55 = 0u;
          long long v52 = 0u;
          long long v53 = 0u;
          long long v50 = 0u;
          long long v51 = 0u;
          long long v49 = 0u;
          memset(&v48, 0, sizeof(v48));
          snprintf((char *)&v48, 0x100uLL, "%s (%dx%d) must represent at least one right-hand side.\n");
          goto LABEL_49;
        }
        if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
          goto LABEL_7;
        }
        v48.control = 136315650;
        *(void *)&v48.orderMethod = "B";
        WORD2(v48.order) = 1024;
        *(_DWORD *)((char *)&v48.order + 6) = columnCount;
        WORD1(v48.ignoreRowsAndColumns) = 1024;
        HIDWORD(v48.ignoreRowsAndColumns) = rowCount;
        long long v39 = &_os_log_internal;
LABEL_133:
        _os_log_error_impl(&dword_2153B7000, v39, OS_LOG_TYPE_ERROR, "%s (%dx%d) must represent at least one right-hand side.\n", (uint8_t *)&v48, 0x18u);
        goto LABEL_7;
      }
      if (v48.reportError)
      {
        long long v60 = 0u;
        long long v61 = 0u;
        long long v58 = 0u;
        long long v59 = 0u;
        long long v56 = 0u;
        long long v57 = 0u;
        long long v54 = 0u;
        long long v55 = 0u;
        long long v52 = 0u;
        long long v53 = 0u;
        long long v50 = 0u;
        long long v51 = 0u;
        long long v49 = 0u;
        memset(&v48, 0, sizeof(v48));
        snprintf((char *)&v48, 0x100uLL, "%s does not hold a completed matrix factorization.\n");
LABEL_49:
        ((void (*)(SparseSymbolicFactorOptions *))reportError)(&v48);
        return;
      }
      if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
        goto LABEL_7;
      }
      v48.control = 136315138;
      *(void *)&v48.orderMethod = "Factored";
      int v20 = &_os_log_internal;
      long long v21 = "%s does not hold a completed matrix factorization.\n";
LABEL_77:
      _os_log_error_impl(&dword_2153B7000, v20, OS_LOG_TYPE_ERROR, v21, (uint8_t *)&v48, 0xCu);
      goto LABEL_7;
    }
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_7;
    }
    LOWORD(v48.control) = 0;
    long long v7 = &_os_log_internal;
LABEL_74:
    _os_log_error_impl(&dword_2153B7000, v7, OS_LOG_TYPE_ERROR, "Factored does not hold a completed matrix factorization.\n", (uint8_t *)&v48, 2u);
    goto LABEL_7;
  }
  long long v8 = *(_OWORD *)(a1 + 80);
  *(_OWORD *)&v42.userFactorStorage = *(_OWORD *)(a1 + 64);
  *(_OWORD *)&v42.solveWorkspaceRequiredStatic = v8;
  uint64_t v43 = *(void *)(a1 + 96);
  long long v9 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)&v42.status = *(_OWORD *)a1;
  *(_OWORD *)&v42.symbolicFactorization.columnCFIndex Count = v9;
  long long v10 = *(_OWORD *)(a1 + 48);
  *(_OWORD *)&v42.symbolicFactorization.workspaceSize_Float = *(_OWORD *)(a1 + 32);
  *(_OWORD *)&v42.symbolicFactorization.size_t factorSize_Float = v10;
  DenseMatrix_Double v41 = *a3;
  DenseMatrix_Double v40 = *a2;
  if (v42.symbolicFactorization.status || !v42.symbolicFactorization.workspaceSize_Float)
  {
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_7;
    }
    LOWORD(v48.control) = 0;
    long long v7 = &_os_log_internal;
    goto LABEL_74;
  }
  _SparseGetOptionsFromSymbolicFactor(&v48, &v42.symbolicFactorization);
  long long v16 = v48.reportError;
  if (v42.symbolicFactorization.status
    || !v42.symbolicFactorization.workspaceSize_Float
    || v42.status
    || !v42.solveWorkspaceRequiredStatic)
  {
    if (!v48.reportError)
    {
      if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
        goto LABEL_7;
      }
      v48.control = 136315138;
      *(void *)&v48.orderMethod = "Factored";
      int v20 = &_os_log_internal;
      long long v21 = "%s does not hold a completed matrix factorization.\n";
      goto LABEL_77;
    }
    long long v60 = 0u;
    long long v61 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v49 = 0u;
    memset(&v48, 0, sizeof(v48));
    snprintf((char *)&v48, 0x100uLL, "%s does not hold a completed matrix factorization.\n");
LABEL_55:
    ((void (*)(SparseSymbolicFactorOptions *))v16)(&v48);
    return;
  }
  if ((*(unsigned char *)&v42.attributes ^ *(unsigned char *)&v42.symbolicFactorization.attributes)) {
    int v17 = v42.symbolicFactorization.columnCount * LOBYTE(v42.symbolicFactorization.factorization);
  }
  else {
    int v17 = v42.symbolicFactorization.rowCount * LOBYTE(v42.symbolicFactorization.factorization);
  }
  if ((*(unsigned char *)&v42.attributes ^ *(unsigned char *)&v42.symbolicFactorization.attributes)) {
    int v18 = v42.symbolicFactorization.rowCount * LOBYTE(v42.symbolicFactorization.factorization);
  }
  else {
    int v18 = v42.symbolicFactorization.columnCount * LOBYTE(v42.symbolicFactorization.factorization);
  }
  if (BYTE1(v42.symbolicFactorization.factorization) == 40) {
    int v19 = v17;
  }
  else {
    int v19 = v18;
  }
  if (v41.columnStride < v41.rowCount)
  {
    if (!v48.reportError)
    {
      if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
      {
        v48.control = 136315906;
        *(void *)&v48.orderMethod = "B";
        WORD2(v48.order) = 1024;
        *(_DWORD *)((char *)&v48.order + 6) = v41.columnStride;
        WORD1(v48.ignoreRowsAndColumns) = 2080;
        *(int **)((char *)&v48.ignoreRowsAndColumns + 4) = (int *)"B";
        WORD2(v48.malloc) = 1024;
        *(_DWORD *)((char *)&v48.malloc + 6) = v41.rowCount;
        int v26 = &_os_log_internal;
        goto LABEL_108;
      }
LABEL_7:
      _SparseTrap();
      return;
    }
    goto LABEL_54;
  }
  if (v40.columnStride < v40.rowCount)
  {
    if (!v48.reportError)
    {
      if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
      {
        v48.control = 136315906;
        *(void *)&v48.orderMethod = "X";
        WORD2(v48.order) = 1024;
        *(_DWORD *)((char *)&v48.order + 6) = v40.columnStride;
        WORD1(v48.ignoreRowsAndColumns) = 2080;
        *(int **)((char *)&v48.ignoreRowsAndColumns + 4) = (int *)"X";
        WORD2(v48.malloc) = 1024;
        *(_DWORD *)((char *)&v48.malloc + 6) = v40.rowCount;
        int v26 = &_os_log_internal;
        goto LABEL_108;
      }
      goto LABEL_7;
    }
LABEL_54:
    long long v60 = 0u;
    long long v61 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v49 = 0u;
    memset(&v48, 0, sizeof(v48));
    snprintf((char *)&v48, 0x100uLL, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n");
    goto LABEL_55;
  }
  if (*(unsigned char *)&v41.attributes) {
    uint64_t v27 = v41.rowCount;
  }
  else {
    uint64_t v27 = v41.columnCount;
  }
  if (*(unsigned char *)&v41.attributes) {
    int v28 = v41.columnCount;
  }
  else {
    int v28 = v41.rowCount;
  }
  if (*(unsigned char *)&v40.attributes) {
    int v29 = v40.rowCount;
  }
  else {
    int v29 = v40.columnCount;
  }
  if (*(unsigned char *)&v40.attributes) {
    int v30 = v40.columnCount;
  }
  else {
    int v30 = v40.rowCount;
  }
  if (v27 != v29)
  {
    if (!v48.reportError)
    {
      if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
        goto LABEL_7;
      }
      v48.control = 136316418;
      *(void *)&v48.orderMethod = "B";
      WORD2(v48.order) = 1024;
      *(_DWORD *)((char *)&v48.order + 6) = v28;
      WORD1(v48.ignoreRowsAndColumns) = 1024;
      HIDWORD(v48.ignoreRowsAndColumns) = v27;
      LOWORD(v48.malloc) = 2080;
      *(void *(__cdecl **)(size_t))((char *)&v48.malloc + 2) = (void *(__cdecl *)(size_t))"X";
      WORD1(v48.free) = 1024;
      HIDWORD(v48.free) = v30;
      LOWORD(v48.reportError) = 1024;
      *(_DWORD *)((char *)&v48.reportError + 2) = v29;
      uint64_t v35 = &_os_log_internal;
      long long v36 = "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n";
      goto LABEL_142;
    }
    long long v60 = 0u;
    long long v61 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v49 = 0u;
    memset(&v48, 0, sizeof(v48));
    snprintf((char *)&v48, 0x100uLL, "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n", "B");
    goto LABEL_55;
  }
  if ((int)v27 <= 0)
  {
    if (!v48.reportError)
    {
      if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
        goto LABEL_7;
      }
      v48.control = 136315650;
      *(void *)&v48.orderMethod = "B";
      WORD2(v48.order) = 1024;
      *(_DWORD *)((char *)&v48.order + 6) = v28;
      WORD1(v48.ignoreRowsAndColumns) = 1024;
      HIDWORD(v48.ignoreRowsAndColumns) = v27;
      long long v39 = &_os_log_internal;
      goto LABEL_133;
    }
    long long v60 = 0u;
    long long v61 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v49 = 0u;
    memset(&v48, 0, sizeof(v48));
    snprintf((char *)&v48, 0x100uLL, "%s (%dx%d) must represent at least one right-hand side.\n");
    goto LABEL_55;
  }
  if (v28 != v19)
  {
    if (!v48.reportError)
    {
      if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
        goto LABEL_7;
      }
      v48.control = 136316418;
      *(void *)&v48.orderMethod = "B";
      WORD2(v48.order) = 1024;
      *(_DWORD *)((char *)&v48.order + 6) = v28;
      WORD1(v48.ignoreRowsAndColumns) = 1024;
      HIDWORD(v48.ignoreRowsAndColumns) = v27;
      LOWORD(v48.malloc) = 2080;
      *(void *(__cdecl **)(size_t))((char *)&v48.malloc + 2) = (void *(__cdecl *)(size_t))"matrix factorization Factored";
      WORD1(v48.free) = 1024;
      HIDWORD(v48.free) = v18;
      LOWORD(v48.reportError) = 1024;
      *(_DWORD *)((char *)&v48.reportError + 2) = v19;
      uint64_t v35 = &_os_log_internal;
      long long v36 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
      goto LABEL_142;
    }
    long long v60 = 0u;
    long long v61 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v49 = 0u;
    memset(&v48, 0, sizeof(v48));
    DenseMatrix_Double v38 = "B";
    goto LABEL_130;
  }
  if (v30 != v18)
  {
    if (!v48.reportError)
    {
      if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
        goto LABEL_7;
      }
      v48.control = 136316418;
      *(void *)&v48.orderMethod = "X";
      WORD2(v48.order) = 1024;
      *(_DWORD *)((char *)&v48.order + 6) = v30;
      WORD1(v48.ignoreRowsAndColumns) = 1024;
      HIDWORD(v48.ignoreRowsAndColumns) = v27;
      LOWORD(v48.malloc) = 2080;
      *(void *(__cdecl **)(size_t))((char *)&v48.malloc + 2) = (void *(__cdecl *)(size_t))"matrix factorization Factored";
      WORD1(v48.free) = 1024;
      HIDWORD(v48.free) = v18;
      LOWORD(v48.reportError) = 1024;
      *(_DWORD *)((char *)&v48.reportError + 2) = v19;
      uint64_t v35 = &_os_log_internal;
      long long v36 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
      goto LABEL_142;
    }
    long long v60 = 0u;
    long long v61 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v49 = 0u;
    memset(&v48, 0, sizeof(v48));
    DenseMatrix_Double v38 = "X";
LABEL_130:
    snprintf((char *)&v48, 0x100uLL, "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n", v38);
    goto LABEL_55;
  }
  free = v48.free;
  size_t v32 = v42.solveWorkspaceRequiredPerRHS + v43 * v27;
  __int16 v33 = (void *)((uint64_t (*)(size_t))v48.malloc)(v32);
  if (!v33)
  {
    if (!v16)
    {
      if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
        goto LABEL_7;
      }
      v48.control = 134217984;
      *(void *)&v48.orderMethod = v32;
      int v20 = &_os_log_internal;
      long long v21 = "Failed to allocate workspace of size %ld for SparseSolve().\n";
      goto LABEL_77;
    }
    long long v60 = 0u;
    long long v61 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v49 = 0u;
    memset(&v48, 0, sizeof(v48));
    snprintf((char *)&v48, 0x100uLL, "Failed to allocate workspace of size %ld for SparseSolve().\n");
    goto LABEL_55;
  }
  SparseOpaqueFactorization_Double v34 = v33;
  _SparseSolveOpaque_Double(&v42, &v41, &v40, v33);
  ((void (*)(void *))free)(v34);
}

void cva::VecLibSparse<double>::solve(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v45 = *MEMORY[0x263EF8340];
  if (a3)
  {
    long long v3 = *(_OWORD *)(a1 + 80);
    *(_OWORD *)&Factored.userFactorStorage = *(_OWORD *)(a1 + 64);
    *(_OWORD *)&Factored.solveWorkspaceRequiredStatic = v3;
    uint64_t v29 = *(void *)(a1 + 96);
    long long v4 = *(_OWORD *)(a1 + 16);
    *(_OWORD *)&Factored.status = *(_OWORD *)a1;
    *(_OWORD *)&Factored.symbolicFactorization.columnCFIndex Count = v4;
    long long v5 = *(_OWORD *)(a1 + 48);
    *(_OWORD *)&Factored.symbolicFactorization.workspaceSize_Float = *(_OWORD *)(a1 + 32);
    *(_OWORD *)&Factored.symbolicFactorization.size_t factorSize_Float = v5;
    if (Factored.symbolicFactorization.status == SparseStatusOK && Factored.symbolicFactorization.workspaceSize_Float)
    {
      SparseControl_t v11 = *(_DWORD *)a2;
      SparseControl_t v12 = *(int **)(a2 + 8);
      _SparseGetOptionsFromSymbolicFactor(&v31, &Factored.symbolicFactorization);
      reportError = v31.reportError;
      if (Factored.symbolicFactorization.status == SparseStatusOK
        && Factored.symbolicFactorization.workspaceSize_Float
        && Factored.status == SparseStatusOK
        && Factored.solveWorkspaceRequiredStatic)
      {
        int v14 = Factored.symbolicFactorization.columnCount * LOBYTE(Factored.symbolicFactorization.factorization);
        if (Factored.symbolicFactorization.rowCount * LOBYTE(Factored.symbolicFactorization.factorization) > v14) {
          int v14 = Factored.symbolicFactorization.rowCount * LOBYTE(Factored.symbolicFactorization.factorization);
        }
        if (v14 == v11)
        {
          v31.control = v11;
          *(_DWORD *)&v31.orderMethod = 1;
          v31.ignoreRowsAndColumns = v12;
          v31.order = (int *)v11;
          _SparseSolveOpaque_Double(&Factored, 0, (const DenseMatrix_Double *)&v31, a3);
          return;
        }
        if (v31.reportError)
        {
          long long v43 = 0u;
          long long v44 = 0u;
          long long v41 = 0u;
          long long v42 = 0u;
          long long v39 = 0u;
          long long v40 = 0u;
          long long v37 = 0u;
          long long v38 = 0u;
          long long v35 = 0u;
          long long v36 = 0u;
          long long v33 = 0u;
          long long v34 = 0u;
          long long v32 = 0u;
          memset(&v31, 0, sizeof(v31));
          snprintf((char *)&v31, 0x100uLL, "%s.count (%d) is not equal to largest dimension of matrix factorization %s.\n");
          goto LABEL_34;
        }
        if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
          goto LABEL_7;
        }
        v31.control = 136315650;
        *(void *)&v31.orderMethod = "xb";
        WORD2(v31.order) = 1024;
        *(_DWORD *)((char *)&v31.order + 6) = v11;
        WORD1(v31.ignoreRowsAndColumns) = 2080;
        *(int **)((char *)&v31.ignoreRowsAndColumns + 4) = (int *)"Factored";
        int v25 = &_os_log_internal;
        goto LABEL_51;
      }
      if (v31.reportError)
      {
        long long v43 = 0u;
        long long v44 = 0u;
        long long v41 = 0u;
        long long v42 = 0u;
        long long v39 = 0u;
        long long v40 = 0u;
        long long v37 = 0u;
        long long v38 = 0u;
        long long v35 = 0u;
        long long v36 = 0u;
        long long v33 = 0u;
        long long v34 = 0u;
        long long v32 = 0u;
        memset(&v31, 0, sizeof(v31));
        snprintf((char *)&v31, 0x100uLL, "%s does not hold a completed matrix factorization.\n");
LABEL_34:
        ((void (*)(SparseSymbolicFactorOptions *))reportError)(&v31);
        return;
      }
      if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
        goto LABEL_7;
      }
      v31.control = 136315138;
      *(void *)&v31.orderMethod = "Factored";
      long long v23 = &_os_log_internal;
      int v24 = "%s does not hold a completed matrix factorization.\n";
      goto LABEL_43;
    }
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v31.control) = 0;
      long long v6 = &_os_log_internal;
LABEL_40:
      _os_log_error_impl(&dword_2153B7000, v6, OS_LOG_TYPE_ERROR, "Factored does not hold a completed matrix factorization.\n", (uint8_t *)&v31, 2u);
      goto LABEL_7;
    }
    goto LABEL_7;
  }
  long long v7 = *(_OWORD *)(a1 + 80);
  *(_OWORD *)&v26.userFactorStorage = *(_OWORD *)(a1 + 64);
  *(_OWORD *)&v26.solveWorkspaceRequiredStatic = v7;
  uint64_t v27 = *(void *)(a1 + 96);
  long long v8 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)&v26.status = *(_OWORD *)a1;
  *(_OWORD *)&v26.symbolicFactorization.columnCFIndex Count = v8;
  long long v9 = *(_OWORD *)(a1 + 48);
  *(_OWORD *)&v26.symbolicFactorization.workspaceSize_Float = *(_OWORD *)(a1 + 32);
  *(_OWORD *)&v26.symbolicFactorization.size_t factorSize_Float = v9;
  if (v26.symbolicFactorization.status == SparseStatusOK && v26.symbolicFactorization.workspaceSize_Float)
  {
    int v15 = *(_DWORD *)a2;
    long long v16 = *(double **)(a2 + 8);
    _SparseGetOptionsFromSymbolicFactor(&v31, &v26.symbolicFactorization);
    int v17 = v31.reportError;
    if (v26.symbolicFactorization.status
      || !v26.symbolicFactorization.workspaceSize_Float
      || v26.status
      || !v26.solveWorkspaceRequiredStatic)
    {
      if (!v31.reportError)
      {
        if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
          goto LABEL_7;
        }
        v31.control = 136315138;
        *(void *)&v31.orderMethod = "Factored";
        long long v23 = &_os_log_internal;
        int v24 = "%s does not hold a completed matrix factorization.\n";
        goto LABEL_43;
      }
      long long v43 = 0u;
      long long v44 = 0u;
      long long v41 = 0u;
      long long v42 = 0u;
      long long v39 = 0u;
      long long v40 = 0u;
      long long v37 = 0u;
      long long v38 = 0u;
      long long v35 = 0u;
      long long v36 = 0u;
      long long v33 = 0u;
      long long v34 = 0u;
      long long v32 = 0u;
      memset(&v31, 0, sizeof(v31));
      snprintf((char *)&v31, 0x100uLL, "%s does not hold a completed matrix factorization.\n");
    }
    else
    {
      int v18 = v26.symbolicFactorization.columnCount * LOBYTE(v26.symbolicFactorization.factorization);
      if (v26.symbolicFactorization.rowCount * LOBYTE(v26.symbolicFactorization.factorization) > v18) {
        int v18 = v26.symbolicFactorization.rowCount * LOBYTE(v26.symbolicFactorization.factorization);
      }
      if (v18 == v15)
      {
        free = v31.free;
        Soln.rowCFIndex Count = v15;
        Soln.columnCFIndex Count = 1;
        *(_DWORD *)&Soln.SparseAttributes_t attributes = 0;
        Soln.data = v16;
        Soln.int columnStride = v15;
        size_t v20 = v27 + v26.solveWorkspaceRequiredPerRHS;
        long long v21 = (void *)((uint64_t (*)(size_t))v31.malloc)(v27 + v26.solveWorkspaceRequiredPerRHS);
        if (v21)
        {
          int v22 = v21;
          _SparseSolveOpaque_Double(&v26, 0, &Soln, v21);
          ((void (*)(void *))free)(v22);
          return;
        }
        if (v17)
        {
          long long v43 = 0u;
          long long v44 = 0u;
          long long v41 = 0u;
          long long v42 = 0u;
          long long v39 = 0u;
          long long v40 = 0u;
          long long v37 = 0u;
          long long v38 = 0u;
          long long v35 = 0u;
          long long v36 = 0u;
          long long v33 = 0u;
          long long v34 = 0u;
          long long v32 = 0u;
          memset(&v31, 0, sizeof(v31));
          snprintf((char *)&v31, 0x100uLL, "Failed to allocate workspace of size %ld for SparseSolve().\n");
          goto LABEL_48;
        }
        if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
          goto LABEL_7;
        }
        v31.control = 134217984;
        *(void *)&v31.orderMethod = v20;
        long long v23 = &_os_log_internal;
        int v24 = "Failed to allocate workspace of size %ld for SparseSolve().\n";
LABEL_43:
        _os_log_error_impl(&dword_2153B7000, v23, OS_LOG_TYPE_ERROR, v24, (uint8_t *)&v31, 0xCu);
        goto LABEL_7;
      }
      if (!v31.reportError)
      {
        if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
        {
          v31.control = 136315650;
          *(void *)&v31.orderMethod = "xb";
          WORD2(v31.order) = 1024;
          *(_DWORD *)((char *)&v31.order + 6) = v15;
          WORD1(v31.ignoreRowsAndColumns) = 2080;
          *(int **)((char *)&v31.ignoreRowsAndColumns + 4) = (int *)"Factored";
          int v25 = &_os_log_internal;
LABEL_51:
          _os_log_error_impl(&dword_2153B7000, v25, OS_LOG_TYPE_ERROR, "%s.count (%d) is not equal to largest dimension of matrix factorization %s.\n", (uint8_t *)&v31, 0x1Cu);
          goto LABEL_7;
        }
        goto LABEL_7;
      }
      long long v43 = 0u;
      long long v44 = 0u;
      long long v41 = 0u;
      long long v42 = 0u;
      long long v39 = 0u;
      long long v40 = 0u;
      long long v37 = 0u;
      long long v38 = 0u;
      long long v35 = 0u;
      long long v36 = 0u;
      long long v33 = 0u;
      long long v34 = 0u;
      long long v32 = 0u;
      memset(&v31, 0, sizeof(v31));
      snprintf((char *)&v31, 0x100uLL, "%s.count (%d) is not equal to largest dimension of matrix factorization %s.\n");
    }
LABEL_48:
    ((void (*)(SparseSymbolicFactorOptions *))v17)(&v31);
    return;
  }
  if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v31.control) = 0;
    long long v6 = &_os_log_internal;
    goto LABEL_40;
  }
LABEL_7:
  _SparseTrap();
}

void cva::VecLibSparse<double>::solve(uint64_t a1, DenseMatrix_Double *a2, void *a3)
{
  uint64_t v48 = *MEMORY[0x263EF8340];
  if (a3)
  {
    long long v3 = *(_OWORD *)(a1 + 80);
    *(_OWORD *)&Factored.userFactorStorage = *(_OWORD *)(a1 + 64);
    *(_OWORD *)&Factored.solveWorkspaceRequiredStatic = v3;
    uint64_t v33 = *(void *)(a1 + 96);
    long long v4 = *(_OWORD *)(a1 + 16);
    *(_OWORD *)&Factored.status = *(_OWORD *)a1;
    *(_OWORD *)&Factored.symbolicFactorization.columnCFIndex Count = v4;
    long long v5 = *(_OWORD *)(a1 + 48);
    *(_OWORD *)&Factored.symbolicFactorization.workspaceSize_Float = *(_OWORD *)(a1 + 32);
    *(_OWORD *)&Factored.symbolicFactorization.size_t factorSize_Float = v5;
    DenseMatrix_Double Soln = *a2;
    if (Factored.symbolicFactorization.status == SparseStatusOK && Factored.symbolicFactorization.workspaceSize_Float)
    {
      _SparseGetOptionsFromSymbolicFactor(&v34, &Factored.symbolicFactorization);
      reportError = v34.reportError;
      if (Factored.symbolicFactorization.status == SparseStatusOK
        && Factored.symbolicFactorization.workspaceSize_Float
        && Factored.status == SparseStatusOK
        && Factored.solveWorkspaceRequiredStatic)
      {
        if (Soln.columnStride < Soln.rowCount)
        {
          if (v34.reportError)
          {
            long long v46 = 0u;
            long long v47 = 0u;
            long long v44 = 0u;
            long long v45 = 0u;
            long long v42 = 0u;
            long long v43 = 0u;
            long long v40 = 0u;
            long long v41 = 0u;
            long long v38 = 0u;
            long long v39 = 0u;
            long long v36 = 0u;
            long long v37 = 0u;
            long long v35 = 0u;
            memset(&v34, 0, sizeof(v34));
            snprintf((char *)&v34, 0x100uLL, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n");
LABEL_27:
            ((void (*)(SparseSymbolicFactorOptions *))reportError)(&v34);
            return;
          }
          if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
            goto LABEL_7;
          }
          v34.control = 136315906;
          *(void *)&v34.orderMethod = "XB";
          WORD2(v34.order) = 1024;
          *(_DWORD *)((char *)&v34.order + 6) = Soln.columnStride;
          WORD1(v34.ignoreRowsAndColumns) = 2080;
          *(int **)((char *)&v34.ignoreRowsAndColumns + 4) = (int *)"XB";
          WORD2(v34.malloc) = 1024;
          *(_DWORD *)((char *)&v34.malloc + 6) = Soln.rowCount;
          int v25 = &_os_log_internal;
          goto LABEL_71;
        }
        if (*(unsigned char *)&Soln.attributes) {
          columnCFIndex Count = Soln.columnCount;
        }
        else {
          columnCFIndex Count = Soln.rowCount;
        }
        if (*(unsigned char *)&Soln.attributes) {
          rowCFIndex Count = Soln.rowCount;
        }
        else {
          rowCFIndex Count = Soln.columnCount;
        }
        if (rowCount > 0)
        {
          if (Factored.symbolicFactorization.rowCount * LOBYTE(Factored.symbolicFactorization.factorization) <= Factored.symbolicFactorization.columnCount * LOBYTE(Factored.symbolicFactorization.factorization)) {
            int v15 = Factored.symbolicFactorization.columnCount * LOBYTE(Factored.symbolicFactorization.factorization);
          }
          else {
            int v15 = Factored.symbolicFactorization.rowCount * LOBYTE(Factored.symbolicFactorization.factorization);
          }
          if (columnCount == v15)
          {
            _SparseSolveOpaque_Double(&Factored, 0, &Soln, a3);
            return;
          }
          if (v34.reportError)
          {
            long long v46 = 0u;
            long long v47 = 0u;
            long long v44 = 0u;
            long long v45 = 0u;
            long long v42 = 0u;
            long long v43 = 0u;
            long long v40 = 0u;
            long long v41 = 0u;
            long long v38 = 0u;
            long long v39 = 0u;
            long long v36 = 0u;
            long long v37 = 0u;
            long long v35 = 0u;
            memset(&v34, 0, sizeof(v34));
            snprintf((char *)&v34, 0x100uLL, "%s (%dx%d) is not consistent with largest dimension of matrix factorization %s (%d).\n");
            goto LABEL_27;
          }
          if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
            goto LABEL_7;
          }
          v34.control = 136316162;
          *(void *)&v34.orderMethod = "XB";
          WORD2(v34.order) = 1024;
          *(_DWORD *)((char *)&v34.order + 6) = columnCount;
          WORD1(v34.ignoreRowsAndColumns) = 1024;
          HIDWORD(v34.ignoreRowsAndColumns) = rowCount;
          LOWORD(v34.malloc) = 2080;
          *(void *(__cdecl **)(size_t))((char *)&v34.malloc + 2) = (void *(__cdecl *)(size_t))"Factored";
          WORD1(v34.free) = 1024;
          HIDWORD(v34.free) = v15;
          uint64_t v27 = &_os_log_internal;
          goto LABEL_87;
        }
        if (v34.reportError)
        {
          long long v46 = 0u;
          long long v47 = 0u;
          long long v44 = 0u;
          long long v45 = 0u;
          long long v42 = 0u;
          long long v43 = 0u;
          long long v40 = 0u;
          long long v41 = 0u;
          long long v38 = 0u;
          long long v39 = 0u;
          long long v36 = 0u;
          long long v37 = 0u;
          long long v35 = 0u;
          memset(&v34, 0, sizeof(v34));
          snprintf((char *)&v34, 0x100uLL, "%s (%dx%d) must represent at least one right-hand side.\n");
          goto LABEL_27;
        }
        if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
          goto LABEL_7;
        }
        v34.control = 136315650;
        *(void *)&v34.orderMethod = "XB";
        WORD2(v34.order) = 1024;
        *(_DWORD *)((char *)&v34.order + 6) = columnCount;
        WORD1(v34.ignoreRowsAndColumns) = 1024;
        HIDWORD(v34.ignoreRowsAndColumns) = rowCount;
        SparseOpaqueFactorization_Double v26 = &_os_log_internal;
LABEL_82:
        _os_log_error_impl(&dword_2153B7000, v26, OS_LOG_TYPE_ERROR, "%s (%dx%d) must represent at least one right-hand side.\n", (uint8_t *)&v34, 0x18u);
        goto LABEL_7;
      }
      if (v34.reportError)
      {
        long long v46 = 0u;
        long long v47 = 0u;
        long long v44 = 0u;
        long long v45 = 0u;
        long long v42 = 0u;
        long long v43 = 0u;
        long long v40 = 0u;
        long long v41 = 0u;
        long long v38 = 0u;
        long long v39 = 0u;
        long long v36 = 0u;
        long long v37 = 0u;
        long long v35 = 0u;
        memset(&v34, 0, sizeof(v34));
        snprintf((char *)&v34, 0x100uLL, "%s does not hold a completed matrix factorization.\n");
        goto LABEL_27;
      }
      if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
        goto LABEL_7;
      }
      v34.control = 136315138;
      *(void *)&v34.orderMethod = "Factored";
      long long v16 = &_os_log_internal;
      int v17 = "%s does not hold a completed matrix factorization.\n";
      goto LABEL_62;
    }
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v34.control) = 0;
      long long v6 = &_os_log_internal;
LABEL_59:
      _os_log_error_impl(&dword_2153B7000, v6, OS_LOG_TYPE_ERROR, "Factored does not hold a completed matrix factorization.\n", (uint8_t *)&v34, 2u);
      goto LABEL_7;
    }
    goto LABEL_7;
  }
  long long v7 = *(_OWORD *)(a1 + 80);
  *(_OWORD *)&v29.userFactorStorage = *(_OWORD *)(a1 + 64);
  *(_OWORD *)&v29.solveWorkspaceRequiredStatic = v7;
  uint64_t v30 = *(void *)(a1 + 96);
  long long v8 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)&v29.status = *(_OWORD *)a1;
  *(_OWORD *)&v29.symbolicFactorization.columnCFIndex Count = v8;
  long long v9 = *(_OWORD *)(a1 + 48);
  *(_OWORD *)&v29.symbolicFactorization.workspaceSize_Float = *(_OWORD *)(a1 + 32);
  *(_OWORD *)&v29.symbolicFactorization.size_t factorSize_Float = v9;
  DenseMatrix_Double v28 = *a2;
  if (v29.symbolicFactorization.status == SparseStatusOK && v29.symbolicFactorization.workspaceSize_Float)
  {
    _SparseGetOptionsFromSymbolicFactor(&v34, &v29.symbolicFactorization);
    SparseControl_t v12 = v34.reportError;
    if (v29.symbolicFactorization.status
      || !v29.symbolicFactorization.workspaceSize_Float
      || v29.status
      || !v29.solveWorkspaceRequiredStatic)
    {
      if (v34.reportError)
      {
        long long v46 = 0u;
        long long v47 = 0u;
        long long v44 = 0u;
        long long v45 = 0u;
        long long v42 = 0u;
        long long v43 = 0u;
        long long v40 = 0u;
        long long v41 = 0u;
        long long v38 = 0u;
        long long v39 = 0u;
        long long v36 = 0u;
        long long v37 = 0u;
        long long v35 = 0u;
        memset(&v34, 0, sizeof(v34));
        snprintf((char *)&v34, 0x100uLL, "%s does not hold a completed matrix factorization.\n");
        goto LABEL_30;
      }
      if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
        goto LABEL_7;
      }
      v34.control = 136315138;
      *(void *)&v34.orderMethod = "Factored";
      long long v16 = &_os_log_internal;
      int v17 = "%s does not hold a completed matrix factorization.\n";
    }
    else
    {
      if (v28.columnStride < v28.rowCount)
      {
        if (!v34.reportError)
        {
          if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
          {
            v34.control = 136315906;
            *(void *)&v34.orderMethod = "XB";
            WORD2(v34.order) = 1024;
            *(_DWORD *)((char *)&v34.order + 6) = v28.columnStride;
            WORD1(v34.ignoreRowsAndColumns) = 2080;
            *(int **)((char *)&v34.ignoreRowsAndColumns + 4) = (int *)"XB";
            WORD2(v34.malloc) = 1024;
            *(_DWORD *)((char *)&v34.malloc + 6) = v28.rowCount;
            int v25 = &_os_log_internal;
LABEL_71:
            _os_log_error_impl(&dword_2153B7000, v25, OS_LOG_TYPE_ERROR, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n", (uint8_t *)&v34, 0x22u);
            goto LABEL_7;
          }
          goto LABEL_7;
        }
        long long v46 = 0u;
        long long v47 = 0u;
        long long v44 = 0u;
        long long v45 = 0u;
        long long v42 = 0u;
        long long v43 = 0u;
        long long v40 = 0u;
        long long v41 = 0u;
        long long v38 = 0u;
        long long v39 = 0u;
        long long v36 = 0u;
        long long v37 = 0u;
        long long v35 = 0u;
        memset(&v34, 0, sizeof(v34));
        snprintf((char *)&v34, 0x100uLL, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n");
LABEL_30:
        ((void (*)(SparseSymbolicFactorOptions *))v12)(&v34);
        return;
      }
      if (*(unsigned char *)&v28.attributes) {
        int v18 = v28.columnCount;
      }
      else {
        int v18 = v28.rowCount;
      }
      if (*(unsigned char *)&v28.attributes) {
        uint64_t v19 = v28.rowCount;
      }
      else {
        uint64_t v19 = v28.columnCount;
      }
      if ((int)v19 <= 0)
      {
        if (!v34.reportError)
        {
          if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
            goto LABEL_7;
          }
          v34.control = 136315650;
          *(void *)&v34.orderMethod = "XB";
          WORD2(v34.order) = 1024;
          *(_DWORD *)((char *)&v34.order + 6) = v18;
          WORD1(v34.ignoreRowsAndColumns) = 1024;
          HIDWORD(v34.ignoreRowsAndColumns) = v19;
          SparseOpaqueFactorization_Double v26 = &_os_log_internal;
          goto LABEL_82;
        }
        long long v46 = 0u;
        long long v47 = 0u;
        long long v44 = 0u;
        long long v45 = 0u;
        long long v42 = 0u;
        long long v43 = 0u;
        long long v40 = 0u;
        long long v41 = 0u;
        long long v38 = 0u;
        long long v39 = 0u;
        long long v36 = 0u;
        long long v37 = 0u;
        long long v35 = 0u;
        memset(&v34, 0, sizeof(v34));
        snprintf((char *)&v34, 0x100uLL, "%s (%dx%d) must represent at least one right-hand side.\n");
        goto LABEL_30;
      }
      if (v29.symbolicFactorization.rowCount * LOBYTE(v29.symbolicFactorization.factorization) <= v29.symbolicFactorization.columnCount
                                                                                                 * LOBYTE(v29.symbolicFactorization.factorization))
        int v20 = v29.symbolicFactorization.columnCount * LOBYTE(v29.symbolicFactorization.factorization);
      else {
        int v20 = v29.symbolicFactorization.rowCount * LOBYTE(v29.symbolicFactorization.factorization);
      }
      if (v18 != v20)
      {
        if (!v34.reportError)
        {
          if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
            goto LABEL_7;
          }
          v34.control = 136316162;
          *(void *)&v34.orderMethod = "XB";
          WORD2(v34.order) = 1024;
          *(_DWORD *)((char *)&v34.order + 6) = v18;
          WORD1(v34.ignoreRowsAndColumns) = 1024;
          HIDWORD(v34.ignoreRowsAndColumns) = v19;
          LOWORD(v34.malloc) = 2080;
          *(void *(__cdecl **)(size_t))((char *)&v34.malloc + 2) = (void *(__cdecl *)(size_t))"Factored";
          WORD1(v34.free) = 1024;
          HIDWORD(v34.free) = v20;
          uint64_t v27 = &_os_log_internal;
LABEL_87:
          _os_log_error_impl(&dword_2153B7000, v27, OS_LOG_TYPE_ERROR, "%s (%dx%d) is not consistent with largest dimension of matrix factorization %s (%d).\n", (uint8_t *)&v34, 0x28u);
          goto LABEL_7;
        }
        long long v46 = 0u;
        long long v47 = 0u;
        long long v44 = 0u;
        long long v45 = 0u;
        long long v42 = 0u;
        long long v43 = 0u;
        long long v40 = 0u;
        long long v41 = 0u;
        long long v38 = 0u;
        long long v39 = 0u;
        long long v36 = 0u;
        long long v37 = 0u;
        long long v35 = 0u;
        memset(&v34, 0, sizeof(v34));
        snprintf((char *)&v34, 0x100uLL, "%s (%dx%d) is not consistent with largest dimension of matrix factorization %s (%d).\n");
        goto LABEL_30;
      }
      free = v34.free;
      size_t v22 = v29.solveWorkspaceRequiredPerRHS + v30 * v19;
      long long v23 = (void *)((uint64_t (*)(size_t))v34.malloc)(v22);
      if (v23)
      {
        int v24 = v23;
        _SparseSolveOpaque_Double(&v29, 0, &v28, v23);
        ((void (*)(void *))free)(v24);
        return;
      }
      if (v12)
      {
        long long v46 = 0u;
        long long v47 = 0u;
        long long v44 = 0u;
        long long v45 = 0u;
        long long v42 = 0u;
        long long v43 = 0u;
        long long v40 = 0u;
        long long v41 = 0u;
        long long v38 = 0u;
        long long v39 = 0u;
        long long v36 = 0u;
        long long v37 = 0u;
        long long v35 = 0u;
        memset(&v34, 0, sizeof(v34));
        snprintf((char *)&v34, 0x100uLL, "Failed to allocate workspace of size %ld for SparseSolve().\n");
        goto LABEL_30;
      }
      if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
        goto LABEL_7;
      }
      v34.control = 134217984;
      *(void *)&v34.orderMethod = v22;
      long long v16 = &_os_log_internal;
      int v17 = "Failed to allocate workspace of size %ld for SparseSolve().\n";
    }
LABEL_62:
    _os_log_error_impl(&dword_2153B7000, v16, OS_LOG_TYPE_ERROR, v17, (uint8_t *)&v34, 0xCu);
    goto LABEL_7;
  }
  if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v34.control) = 0;
    long long v6 = &_os_log_internal;
    goto LABEL_59;
  }
LABEL_7:
  _SparseTrap();
}

double cva::VecLibSparse<double>::subfactor@<D0>(int a1@<W0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  long long v4 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)&v21.userFactorStorage = *(_OWORD *)(a2 + 64);
  *(_OWORD *)&v21.solveWorkspaceRequiredStatic = v4;
  uint64_t v22 = *(void *)(a2 + 96);
  long long v5 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)&v21.status = *(_OWORD *)a2;
  *(_OWORD *)&v21.symbolicFactorization.columnCFIndex Count = v5;
  long long v6 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)&v21.symbolicFactorization.workspaceSize_Float = *(_OWORD *)(a2 + 32);
  *(_OWORD *)&v21.symbolicFactorization.size_t factorSize_Float = v6;
  if (v21.symbolicFactorization.status == SparseStatusOK
    && v21.symbolicFactorization.workspaceSize_Float
    && v21.status == SparseStatusOK
    && v21.solveWorkspaceRequiredStatic)
  {
    _SparseGetOptionsFromSymbolicFactor((SparseSymbolicFactorOptions *)v25, &v21.symbolicFactorization);
    long long v8 = *(void (**)(unsigned char *))&v25[40];
    __int16 v9 = 2;
    switch(a1)
    {
      case 1:
        goto LABEL_24;
      case 2:
      case 4:
        if (BYTE1(v21.symbolicFactorization.factorization) - 2 < 3) {
          goto LABEL_24;
        }
        if (*(void *)&v25[40])
        {
          memset(&v25[53], 0, 203);
          strcpy(v25, "Subfactor Type only valid for LDL^T factorizations.\n");
          goto LABEL_32;
        }
        if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
          goto LABEL_10;
        }
        *(_WORD *)int v25 = 0;
        uint64_t v19 = &_os_log_internal;
        int v20 = "Subfactor Type only valid for LDL^T factorizations.\n";
        goto LABEL_29;
      case 3:
      case 5:
        if (a1 == 5) {
          __int16 v9 = 2;
        }
        else {
          __int16 v9 = 6;
        }
        if (BYTE1(v21.symbolicFactorization.factorization) <= 4u && BYTE1(v21.symbolicFactorization.factorization) != 1) {
          goto LABEL_24;
        }
        if (*(void *)&v25[40])
        {
          memset(&v25[66], 0, 190);
          strcpy(&v25[64], "\n");
          SparseControl_t v11 = "Subfactor Type only valid for Cholesky and LDL^T factorizations.\n";
          goto LABEL_27;
        }
        if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
          goto LABEL_10;
        }
        *(_WORD *)int v25 = 0;
        uint64_t v19 = &_os_log_internal;
        int v20 = "Subfactor Type only valid for Cholesky and LDL^T factorizations.\n";
        goto LABEL_29;
      case 6:
        if (BYTE1(v21.symbolicFactorization.factorization) == 40) {
          goto LABEL_24;
        }
        if (*(void *)&v25[40])
        {
          memset(&v25[52], 0, 204);
          strcpy(v25, "SparseSubfactorQ only valid for QR factorizations.\n");
          goto LABEL_32;
        }
        if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
          goto LABEL_10;
        }
        *(_WORD *)int v25 = 0;
        uint64_t v19 = &_os_log_internal;
        int v20 = "SparseSubfactorQ only valid for QR factorizations.\n";
        goto LABEL_29;
      case 7:
      case 8:
        if ((BYTE1(v21.symbolicFactorization.factorization) & 0xFE) == 0x28)
        {
          __int16 v9 = 4;
LABEL_24:
          _SparseRetainNumeric_Double(&v21);
          workPerDenseMatrix_Double RHS = 0;
          size_t workStatic = 0;
          *(SparseOpaqueFactorization_Double *)int v25 = v21;
          *(void *)&v25[96] = v22;
          _SparseGetWorkspaceRequired_Double((SparseSubfactor_t)a1, (SparseOpaqueFactorization_Double *)v25, &workStatic, &workPerRHS);
          long long v12 = *(_OWORD *)&v21.symbolicFactorization.workspaceSize_Float;
          *(_OWORD *)(a3 + 56) = *(_OWORD *)&v21.symbolicFactorization.factorSize_Float;
          long long v13 = *(_OWORD *)&v21.solveWorkspaceRequiredStatic;
          *(_OWORD *)(a3 + 72) = *(_OWORD *)&v21.userFactorStorage;
          *(_OWORD *)(a3 + 88) = v13;
          double result = *(double *)&v21.status;
          long long v14 = *(_OWORD *)&v21.symbolicFactorization.columnCount;
          *(_OWORD *)(a3 + 8) = *(_OWORD *)&v21.status;
          *(_OWORD *)(a3 + 24) = v14;
          *(_WORD *)a3 = v9;
          *(_WORD *)(a3 + 2) = 0;
          *(unsigned char *)(a3 + 4) = a1;
          uint64_t v15 = v22;
          *(_OWORD *)(a3 + 40) = v12;
          size_t v16 = workStatic;
          *(void *)(a3 + 104) = v15;
          *(void *)(a3 + 112) = v16;
          *(void *)(a3 + 120) = workPerRHS;
          return result;
        }
        if (*(void *)&v25[40])
        {
          memset(&v25[66], 0, 190);
          strcpy(&v25[64], "\n");
          SparseControl_t v11 = "Subfactor Type only valid for QR and CholeskyAtA factorizations.\n";
LABEL_27:
          long long v17 = *((_OWORD *)v11 + 1);
          *(_OWORD *)int v25 = *(_OWORD *)v11;
          *(_OWORD *)&v25[16] = v17;
          long long v18 = *((_OWORD *)v11 + 3);
          *(_OWORD *)&v25[32] = *((_OWORD *)v11 + 2);
          *(_OWORD *)&v25[48] = v18;
          goto LABEL_32;
        }
        if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
          goto LABEL_10;
        }
        *(_WORD *)int v25 = 0;
        uint64_t v19 = &_os_log_internal;
        int v20 = "Subfactor Type only valid for QR and CholeskyAtA factorizations.\n";
        goto LABEL_29;
      default:
        if (*(void *)&v25[40])
        {
          memset(&v25[24], 0, 232);
          strcpy(v25, "Invalid subfactor type.");
LABEL_32:
          v8(v25);
          goto LABEL_11;
        }
        if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
          goto LABEL_10;
        }
        *(_WORD *)int v25 = 0;
        uint64_t v19 = &_os_log_internal;
        int v20 = "Invalid subfactor type.";
        break;
    }
    goto LABEL_29;
  }
  if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)int v25 = 0;
    uint64_t v19 = &_os_log_internal;
    int v20 = "Bad factor.\n";
LABEL_29:
    _os_log_error_impl(&dword_2153B7000, v19, OS_LOG_TYPE_ERROR, v20, v25, 2u);
  }
LABEL_10:
  _SparseTrap();
LABEL_11:
  double result = 0.0;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_OWORD *)(a3 + 112) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_DWORD *)(a3 + 8) = -3;
  *(_DWORD *)(a3 + 16) = -3;
  return result;
}

void cva::VecLibSparse<double>::solve(_OWORD *a1, uint64_t a2, uint64_t a3, char *a4)
{
  long long v4 = a1[5];
  _OWORD v14[4] = a1[4];
  v14[5] = v4;
  long long v5 = a1[7];
  void v14[6] = a1[6];
  _DWORD v14[7] = v5;
  long long v6 = a1[1];
  v14[0] = *a1;
  v14[1] = v6;
  long long v7 = a1[3];
  void v14[2] = a1[2];
  _DWORD v14[3] = v7;
  uint64_t v8 = *(void *)(a3 + 8);
  int v9 = *(_DWORD *)a2;
  long long v10 = *(double **)(a2 + 8);
  v12[0] = *(_DWORD *)a3;
  v12[1] = 1;
  void v12[2] = v12[0];
  v12[3] = 0;
  uint64_t v13 = v8;
  v11.rowCFIndex Count = v9;
  v11.columnCFIndex Count = 1;
  v11.int columnStride = v9;
  *(_DWORD *)&v11.SparseAttributes_t attributes = 0;
  v11.data = v10;
  if (a4) {
    sub_2154281EC((const SparseOpaqueSubfactor_Double *)v14, (uint64_t)v12, &v11, a4);
  }
  else {
    sub_215428840((const SparseOpaqueSubfactor_Double *)v14, (uint64_t)v12, &v11);
  }
}

void sub_2154281EC(const SparseOpaqueSubfactor_Double *a1, uint64_t a2, const DenseMatrix_Double *a3, char *a4)
{
  uint64_t v47 = *MEMORY[0x263EF8340];
  if (!*((unsigned char *)&a1->contents + 2))
  {
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v33.control) = 0;
      _os_log_error_impl(&dword_2153B7000, &_os_log_internal, OS_LOG_TYPE_ERROR, "Subfactor does not hold a valid factor subobject.\n", (uint8_t *)&v33, 2u);
    }
    goto LABEL_58;
  }
  _SparseGetOptionsFromSymbolicFactor(&v33, &a1->factor.symbolicFactorization);
  reportError = v33.reportError;
  SparseAttributes_t attributes = a1->attributes;
  int factorization_low = LOBYTE(a1->factor.symbolicFactorization.factorization);
  int v11 = a1->factor.symbolicFactorization.rowCount * factorization_low;
  int v12 = a1->factor.symbolicFactorization.columnCount * factorization_low;
  if (v11 >= v12) {
    int v13 = a1->factor.symbolicFactorization.columnCount * factorization_low;
  }
  else {
    int v13 = a1->factor.symbolicFactorization.rowCount * factorization_low;
  }
  if (v11 <= v12) {
    int v11 = v12;
  }
  if (*((unsigned char *)&a1->contents + 2) == 6 && BYTE1(a1->factor.symbolicFactorization.factorization) == 40) {
    int v15 = v11;
  }
  else {
    int v15 = v13;
  }
  if (*(unsigned char *)&attributes) {
    int v16 = v15;
  }
  else {
    int v16 = v13;
  }
  if (*(unsigned char *)&attributes) {
    int v17 = v13;
  }
  else {
    int v17 = v15;
  }
  int v18 = *(_DWORD *)(a2 + 8);
  int v19 = *(_DWORD *)a2;
  if (v18 < *(_DWORD *)a2)
  {
    if (v33.reportError) {
      goto LABEL_26;
    }
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_58;
    }
    v33.control = 136315906;
    *(void *)&v33.orderMethod = "B";
    WORD2(v33.order) = 1024;
    *(_DWORD *)((char *)&v33.order + 6) = v18;
    WORD1(v33.ignoreRowsAndColumns) = 2080;
    *(int **)((char *)&v33.ignoreRowsAndColumns + 4) = (int *)"B";
    WORD2(v33.malloc) = 1024;
    *(_DWORD *)((char *)&v33.malloc + 6) = v19;
    uint64_t v26 = &_os_log_internal;
    goto LABEL_41;
  }
  int columnStride = a3->columnStride;
  rowCFIndex Count = a3->rowCount;
  if (columnStride >= a3->rowCount)
  {
    __int16 v22 = *(_WORD *)(a2 + 12);
    if ((v22 & 1) == 0) {
      int v19 = *(_DWORD *)(a2 + 4);
    }
    int v23 = *(&a3->rowCount + ((*(_WORD *)&a3->attributes & 1) == 0));
    unsigned int v24 = v22 & 1;
    int v25 = *(&a3->rowCount + (*(_WORD *)&a3->attributes & 1));
    if (v19 == v23)
    {
      if (v19 <= 0)
      {
        if (v33.reportError)
        {
          long long v45 = 0u;
          long long v46 = 0u;
          long long v43 = 0u;
          long long v44 = 0u;
          long long v41 = 0u;
          long long v42 = 0u;
          long long v39 = 0u;
          long long v40 = 0u;
          long long v37 = 0u;
          long long v38 = 0u;
          long long v35 = 0u;
          long long v36 = 0u;
          long long v34 = 0u;
          memset(&v33, 0, sizeof(v33));
          snprintf((char *)&v33, 0x100uLL, "%s (%dx%d) must represent at least one right-hand side.\n");
          goto LABEL_27;
        }
        int v31 = *(_DWORD *)(a2 + 4 * v24);
        if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
        {
          v33.control = 136315650;
          *(void *)&v33.orderMethod = "B";
          WORD2(v33.order) = 1024;
          *(_DWORD *)((char *)&v33.order + 6) = v31;
          WORD1(v33.ignoreRowsAndColumns) = 1024;
          HIDWORD(v33.ignoreRowsAndColumns) = v19;
          _os_log_error_impl(&dword_2153B7000, &_os_log_internal, OS_LOG_TYPE_ERROR, "%s (%dx%d) must represent at least one right-hand side.\n", (uint8_t *)&v33, 0x18u);
        }
        goto LABEL_58;
      }
      if (*(_DWORD *)(a2 + 4 * v24) == v17)
      {
        if (v25 == v16)
        {
          _SparseSolveSubfactor_Double(a1, (const DenseMatrix_Double *)a2, a3, a4);
          return;
        }
        if (v33.reportError)
        {
          long long v45 = 0u;
          long long v46 = 0u;
          long long v43 = 0u;
          long long v44 = 0u;
          long long v41 = 0u;
          long long v42 = 0u;
          long long v39 = 0u;
          long long v40 = 0u;
          long long v37 = 0u;
          long long v38 = 0u;
          long long v35 = 0u;
          long long v36 = 0u;
          long long v34 = 0u;
          memset(&v33, 0, sizeof(v33));
          uint64_t v30 = "X";
          goto LABEL_50;
        }
        if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
          goto LABEL_58;
        }
        v33.control = 136316418;
        *(void *)&v33.orderMethod = "X";
        WORD2(v33.order) = 1024;
        *(_DWORD *)((char *)&v33.order + 6) = v25;
        WORD1(v33.ignoreRowsAndColumns) = 1024;
        HIDWORD(v33.ignoreRowsAndColumns) = v19;
        LOWORD(v33.malloc) = 2080;
        *(void *(__cdecl **)(size_t))((char *)&v33.malloc + 2) = (void *(__cdecl *)(size_t))"subfactor dimension";
        WORD1(v33.free) = 1024;
        HIDWORD(v33.free) = v16;
        LOWORD(v33.reportError) = 1024;
        *(_DWORD *)((char *)&v33.reportError + 2) = v17;
        DenseMatrix_Double v28 = &_os_log_internal;
        SparseOpaqueFactorization_Double v29 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
      }
      else
      {
        if (v33.reportError)
        {
          long long v45 = 0u;
          long long v46 = 0u;
          long long v43 = 0u;
          long long v44 = 0u;
          long long v41 = 0u;
          long long v42 = 0u;
          long long v39 = 0u;
          long long v40 = 0u;
          long long v37 = 0u;
          long long v38 = 0u;
          long long v35 = 0u;
          long long v36 = 0u;
          long long v34 = 0u;
          memset(&v33, 0, sizeof(v33));
          uint64_t v30 = "B";
LABEL_50:
          snprintf((char *)&v33, 0x100uLL, "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n", v30);
          goto LABEL_27;
        }
        int v32 = *(_DWORD *)(a2 + 4 * v24);
        if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
          goto LABEL_58;
        }
        v33.control = 136316418;
        *(void *)&v33.orderMethod = "B";
        WORD2(v33.order) = 1024;
        *(_DWORD *)((char *)&v33.order + 6) = v32;
        WORD1(v33.ignoreRowsAndColumns) = 1024;
        HIDWORD(v33.ignoreRowsAndColumns) = v19;
        LOWORD(v33.malloc) = 2080;
        *(void *(__cdecl **)(size_t))((char *)&v33.malloc + 2) = (void *(__cdecl *)(size_t))"subfactor dimension";
        WORD1(v33.free) = 1024;
        HIDWORD(v33.free) = v16;
        LOWORD(v33.reportError) = 1024;
        *(_DWORD *)((char *)&v33.reportError + 2) = v17;
        DenseMatrix_Double v28 = &_os_log_internal;
        SparseOpaqueFactorization_Double v29 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
      }
    }
    else
    {
      if (v33.reportError)
      {
        long long v45 = 0u;
        long long v46 = 0u;
        long long v43 = 0u;
        long long v44 = 0u;
        long long v41 = 0u;
        long long v42 = 0u;
        long long v39 = 0u;
        long long v40 = 0u;
        long long v37 = 0u;
        long long v38 = 0u;
        long long v35 = 0u;
        long long v36 = 0u;
        long long v34 = 0u;
        memset(&v33, 0, sizeof(v33));
        snprintf((char *)&v33, 0x100uLL, "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n", "B");
        goto LABEL_27;
      }
      int v27 = *(_DWORD *)(a2 + 4 * v24);
      if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
        goto LABEL_58;
      }
      v33.control = 136316418;
      *(void *)&v33.orderMethod = "B";
      WORD2(v33.order) = 1024;
      *(_DWORD *)((char *)&v33.order + 6) = v27;
      WORD1(v33.ignoreRowsAndColumns) = 1024;
      HIDWORD(v33.ignoreRowsAndColumns) = v19;
      LOWORD(v33.malloc) = 2080;
      *(void *(__cdecl **)(size_t))((char *)&v33.malloc + 2) = (void *(__cdecl *)(size_t))"X";
      WORD1(v33.free) = 1024;
      HIDWORD(v33.free) = v25;
      LOWORD(v33.reportError) = 1024;
      *(_DWORD *)((char *)&v33.reportError + 2) = v23;
      DenseMatrix_Double v28 = &_os_log_internal;
      SparseOpaqueFactorization_Double v29 = "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n";
    }
    _os_log_error_impl(&dword_2153B7000, v28, OS_LOG_TYPE_ERROR, v29, (uint8_t *)&v33, 0x2Eu);
    goto LABEL_58;
  }
  if (v33.reportError)
  {
LABEL_26:
    long long v45 = 0u;
    long long v46 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v34 = 0u;
    memset(&v33, 0, sizeof(v33));
    snprintf((char *)&v33, 0x100uLL, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n");
LABEL_27:
    ((void (*)(SparseSymbolicFactorOptions *))reportError)(&v33);
    return;
  }
  if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
    goto LABEL_58;
  }
  v33.control = 136315906;
  *(void *)&v33.orderMethod = "X";
  WORD2(v33.order) = 1024;
  *(_DWORD *)((char *)&v33.order + 6) = columnStride;
  WORD1(v33.ignoreRowsAndColumns) = 2080;
  *(int **)((char *)&v33.ignoreRowsAndColumns + 4) = (int *)"X";
  WORD2(v33.malloc) = 1024;
  *(_DWORD *)((char *)&v33.malloc + 6) = rowCount;
  uint64_t v26 = &_os_log_internal;
LABEL_41:
  _os_log_error_impl(&dword_2153B7000, v26, OS_LOG_TYPE_ERROR, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n", (uint8_t *)&v33, 0x22u);
LABEL_58:
  _SparseTrap();
}

void sub_215428840(const SparseOpaqueSubfactor_Double *a1, uint64_t a2, const DenseMatrix_Double *a3)
{
  uint64_t v46 = *MEMORY[0x263EF8340];
  if (!*((unsigned char *)&a1->contents + 2))
  {
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v32.control) = 0;
      _os_log_error_impl(&dword_2153B7000, &_os_log_internal, OS_LOG_TYPE_ERROR, "Subfactor does not hold a valid factorization.\n", (uint8_t *)&v32, 2u);
    }
    goto LABEL_63;
  }
  _SparseGetOptionsFromSymbolicFactor(&v32, &a1->factor.symbolicFactorization);
  reportError = v32.reportError;
  SparseAttributes_t attributes = a1->attributes;
  int factorization_low = LOBYTE(a1->factor.symbolicFactorization.factorization);
  int v9 = a1->factor.symbolicFactorization.rowCount * factorization_low;
  int v10 = a1->factor.symbolicFactorization.columnCount * factorization_low;
  if (v9 >= v10) {
    int v11 = a1->factor.symbolicFactorization.columnCount * factorization_low;
  }
  else {
    int v11 = a1->factor.symbolicFactorization.rowCount * factorization_low;
  }
  if (v9 <= v10) {
    int v9 = v10;
  }
  if (*((unsigned char *)&a1->contents + 2) == 6 && BYTE1(a1->factor.symbolicFactorization.factorization) == 40) {
    int v13 = v9;
  }
  else {
    int v13 = v11;
  }
  if (*(unsigned char *)&attributes) {
    int v14 = v13;
  }
  else {
    int v14 = v11;
  }
  if (*(unsigned char *)&attributes) {
    int v15 = v11;
  }
  else {
    int v15 = v13;
  }
  int v16 = *(_DWORD *)(a2 + 8);
  int v17 = *(_DWORD *)a2;
  if (v16 < *(_DWORD *)a2)
  {
    if (v32.reportError) {
      goto LABEL_26;
    }
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_63;
    }
    v32.control = 136315906;
    *(void *)&v32.orderMethod = "B";
    WORD2(v32.order) = 1024;
    *(_DWORD *)((char *)&v32.order + 6) = v16;
    WORD1(v32.ignoreRowsAndColumns) = 2080;
    *(int **)((char *)&v32.ignoreRowsAndColumns + 4) = (int *)"B";
    WORD2(v32.malloc) = 1024;
    *(_DWORD *)((char *)&v32.malloc + 6) = v17;
    DenseMatrix_Double v28 = &_os_log_internal;
    goto LABEL_42;
  }
  int columnStride = a3->columnStride;
  rowCFIndex Count = a3->rowCount;
  if (columnStride < a3->rowCount)
  {
    if (v32.reportError)
    {
LABEL_26:
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      long long v36 = 0u;
      long long v37 = 0u;
      long long v34 = 0u;
      long long v35 = 0u;
      long long v33 = 0u;
      memset(&v32, 0, sizeof(v32));
      snprintf((char *)&v32, 0x100uLL, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n");
LABEL_27:
      ((void (*)(SparseSymbolicFactorOptions *))reportError)(&v32);
      return;
    }
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_63;
    }
    v32.control = 136315906;
    *(void *)&v32.orderMethod = "X";
    WORD2(v32.order) = 1024;
    *(_DWORD *)((char *)&v32.order + 6) = columnStride;
    WORD1(v32.ignoreRowsAndColumns) = 2080;
    *(int **)((char *)&v32.ignoreRowsAndColumns + 4) = (int *)"X";
    WORD2(v32.malloc) = 1024;
    *(_DWORD *)((char *)&v32.malloc + 6) = rowCount;
    DenseMatrix_Double v28 = &_os_log_internal;
LABEL_42:
    _os_log_error_impl(&dword_2153B7000, v28, OS_LOG_TYPE_ERROR, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n", (uint8_t *)&v32, 0x22u);
    goto LABEL_63;
  }
  __int16 v20 = *(_WORD *)(a2 + 12);
  if ((v20 & 1) == 0) {
    int v17 = *(_DWORD *)(a2 + 4);
  }
  int v21 = *(&a3->rowCount + ((*(_WORD *)&a3->attributes & 1) == 0));
  int v22 = *(_DWORD *)(a2 + 4 * (v20 & 1));
  int v23 = *(&a3->rowCount + (*(_WORD *)&a3->attributes & 1));
  if (v17 != v21)
  {
    if (v32.reportError)
    {
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      long long v36 = 0u;
      long long v37 = 0u;
      long long v34 = 0u;
      long long v35 = 0u;
      long long v33 = 0u;
      memset(&v32, 0, sizeof(v32));
      snprintf((char *)&v32, 0x100uLL, "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n", "B");
      goto LABEL_27;
    }
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_63;
    }
    v32.control = 136316418;
    *(void *)&v32.orderMethod = "B";
    WORD2(v32.order) = 1024;
    *(_DWORD *)((char *)&v32.order + 6) = v22;
    WORD1(v32.ignoreRowsAndColumns) = 1024;
    HIDWORD(v32.ignoreRowsAndColumns) = v17;
    LOWORD(v32.malloc) = 2080;
    *(void *(__cdecl **)(size_t))((char *)&v32.malloc + 2) = (void *(__cdecl *)(size_t))"X";
    WORD1(v32.free) = 1024;
    HIDWORD(v32.free) = v23;
    LOWORD(v32.reportError) = 1024;
    *(_DWORD *)((char *)&v32.reportError + 2) = v21;
    SparseOpaqueFactorization_Double v29 = &_os_log_internal;
    uint64_t v30 = "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n";
    goto LABEL_60;
  }
  if (v17 <= 0)
  {
    if (v32.reportError)
    {
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      long long v36 = 0u;
      long long v37 = 0u;
      long long v34 = 0u;
      long long v35 = 0u;
      long long v33 = 0u;
      memset(&v32, 0, sizeof(v32));
      snprintf((char *)&v32, 0x100uLL, "%s (%dx%d) must represent at least one right-hand side.\n");
      goto LABEL_27;
    }
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      v32.control = 136315650;
      *(void *)&v32.orderMethod = "B";
      WORD2(v32.order) = 1024;
      *(_DWORD *)((char *)&v32.order + 6) = v22;
      WORD1(v32.ignoreRowsAndColumns) = 1024;
      HIDWORD(v32.ignoreRowsAndColumns) = v17;
      _os_log_error_impl(&dword_2153B7000, &_os_log_internal, OS_LOG_TYPE_ERROR, "%s (%dx%d) must represent at least one right-hand side.\n", (uint8_t *)&v32, 0x18u);
    }
    goto LABEL_63;
  }
  if (v22 != v15)
  {
    if (v32.reportError)
    {
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      long long v36 = 0u;
      long long v37 = 0u;
      long long v34 = 0u;
      long long v35 = 0u;
      long long v33 = 0u;
      memset(&v32, 0, sizeof(v32));
      int v31 = "B";
LABEL_51:
      snprintf((char *)&v32, 0x100uLL, "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n", v31);
      goto LABEL_27;
    }
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_63;
    }
    v32.control = 136316418;
    *(void *)&v32.orderMethod = "B";
    WORD2(v32.order) = 1024;
    *(_DWORD *)((char *)&v32.order + 6) = v22;
    WORD1(v32.ignoreRowsAndColumns) = 1024;
    HIDWORD(v32.ignoreRowsAndColumns) = v17;
    LOWORD(v32.malloc) = 2080;
    *(void *(__cdecl **)(size_t))((char *)&v32.malloc + 2) = (void *(__cdecl *)(size_t))"subfactor dimension";
    WORD1(v32.free) = 1024;
    HIDWORD(v32.free) = v14;
    LOWORD(v32.reportError) = 1024;
    *(_DWORD *)((char *)&v32.reportError + 2) = v15;
    SparseOpaqueFactorization_Double v29 = &_os_log_internal;
    uint64_t v30 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
LABEL_60:
    _os_log_error_impl(&dword_2153B7000, v29, OS_LOG_TYPE_ERROR, v30, (uint8_t *)&v32, 0x2Eu);
    goto LABEL_63;
  }
  if (v23 != v14)
  {
    if (v32.reportError)
    {
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      long long v36 = 0u;
      long long v37 = 0u;
      long long v34 = 0u;
      long long v35 = 0u;
      long long v33 = 0u;
      memset(&v32, 0, sizeof(v32));
      int v31 = "X";
      goto LABEL_51;
    }
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_63;
    }
    v32.control = 136316418;
    *(void *)&v32.orderMethod = "X";
    WORD2(v32.order) = 1024;
    *(_DWORD *)((char *)&v32.order + 6) = v23;
    WORD1(v32.ignoreRowsAndColumns) = 1024;
    HIDWORD(v32.ignoreRowsAndColumns) = v17;
    LOWORD(v32.malloc) = 2080;
    *(void *(__cdecl **)(size_t))((char *)&v32.malloc + 2) = (void *(__cdecl *)(size_t))"subfactor dimension";
    WORD1(v32.free) = 1024;
    HIDWORD(v32.free) = v14;
    LOWORD(v32.reportError) = 1024;
    *(_DWORD *)((char *)&v32.reportError + 2) = v15;
    SparseOpaqueFactorization_Double v29 = &_os_log_internal;
    uint64_t v30 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
    goto LABEL_60;
  }
  free = v32.free;
  size_t v25 = a1->workspaceRequiredPerRHS + *(void *)&a1[1].attributes * v17;
  uint64_t v26 = (char *)((uint64_t (*)(size_t))v32.malloc)(v25);
  if (v26)
  {
    int v27 = v26;
    _SparseSolveSubfactor_Double(a1, (const DenseMatrix_Double *)a2, a3, v26);
    ((void (*)(char *))free)(v27);
    return;
  }
  if (reportError)
  {
    long long v44 = 0u;
    long long v45 = 0u;
    long long v42 = 0u;
    long long v43 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v33 = 0u;
    memset(&v32, 0, sizeof(v32));
    snprintf((char *)&v32, 0x100uLL, "Failed to allocate workspace of size %ld.\n");
    goto LABEL_27;
  }
  if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
  {
    v32.control = 134217984;
    *(void *)&v32.orderMethod = v25;
    _os_log_error_impl(&dword_2153B7000, &_os_log_internal, OS_LOG_TYPE_ERROR, "Failed to allocate workspace of size %ld.\n", (uint8_t *)&v32, 0xCu);
  }
LABEL_63:
  _SparseTrap();
}

__n128 cva::VecLibSparse<double>::solve(_OWORD *a1, DenseMatrix_Double *a2, long long *a3, char *a4)
{
  long long v4 = a1[5];
  if (a4)
  {
    void v21[4] = a1[4];
    v21[5] = v4;
    long long v5 = a1[7];
    v21[6] = a1[6];
    v21[7] = v5;
    long long v6 = a1[1];
    v21[0] = *a1;
    v21[1] = v6;
    long long v7 = a1[3];
    v21[2] = a1[2];
    v21[3] = v7;
    long long v8 = *a3;
    uint64_t v20 = *((void *)a3 + 2);
    long long v19 = v8;
    DenseMatrix_Double v18 = *a2;
    sub_2154281EC((const SparseOpaqueSubfactor_Double *)v21, (uint64_t)&v19, &v18, a4);
  }
  else
  {
    void v17[4] = a1[4];
    v17[5] = v4;
    long long v10 = a1[7];
    v17[6] = a1[6];
    v17[7] = v10;
    long long v11 = a1[1];
    v17[0] = *a1;
    v17[1] = v11;
    long long v12 = a1[3];
    void v17[2] = a1[2];
    unsigned int v17[3] = v12;
    long long v13 = *a3;
    uint64_t v16 = *((void *)a3 + 2);
    long long v15 = v13;
    DenseMatrix_Double v14 = *a2;
    sub_215428840((const SparseOpaqueSubfactor_Double *)v17, (uint64_t)&v15, &v14);
  }
  return result;
}

void cva::VecLibSparse<double>::solve(_OWORD *a1, uint64_t a2, char *a3)
{
  long long v3 = a1[5];
  v10[4] = a1[4];
  v10[5] = v3;
  long long v4 = a1[7];
  v10[6] = a1[6];
  v10[7] = v4;
  long long v5 = a1[1];
  v10[0] = *a1;
  v10[1] = v5;
  long long v6 = a1[3];
  void v10[2] = a1[2];
  v10[3] = v6;
  uint64_t v7 = *(void *)(a2 + 8);
  v8[0] = *(_DWORD *)a2;
  v8[1] = 1;
  _OWORD v8[2] = v8[0];
  float32x2_t v8[3] = 0;
  uint64_t v9 = v7;
  if (a3) {
    sub_2154290BC((const SparseOpaqueSubfactor_Double *)v10, (uint64_t)v8, a3);
  }
  else {
    sub_215429358((const SparseOpaqueSubfactor_Double *)v10, (uint64_t)v8);
  }
}

void sub_2154290BC(const SparseOpaqueSubfactor_Double *a1, uint64_t a2, char *a3)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  if (!*((unsigned char *)&a1->contents + 2))
  {
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_25;
    }
    *(_WORD *)uint64_t v20 = 0;
    DenseMatrix_Double v18 = &_os_log_internal;
    long long v19 = "Subfactor does not hold a valid factor subobject.\n";
LABEL_37:
    _os_log_error_impl(&dword_2153B7000, v18, OS_LOG_TYPE_ERROR, v19, v20, 2u);
    goto LABEL_25;
  }
  _SparseGetOptionsFromSymbolicFactor((SparseSymbolicFactorOptions *)v20, &a1->factor.symbolicFactorization);
  long long v6 = *(void (**)(unsigned char *))&v20[40];
  if (*(int *)(a2 + 4 * ((*(_WORD *)(a2 + 12) & 1) == 0)) > 0)
  {
    int v7 = *(_DWORD *)(a2 + 4 * (*(_WORD *)(a2 + 12) & 1));
    SparseAttributes_t attributes = a1->attributes;
    int factorization_low = LOBYTE(a1->factor.symbolicFactorization.factorization);
    int v10 = a1->factor.symbolicFactorization.rowCount * factorization_low;
    int v11 = a1->factor.symbolicFactorization.columnCount * factorization_low;
    if (v10 <= v11) {
      int v12 = v11;
    }
    else {
      int v12 = v10;
    }
    if (v10 < v11) {
      int v11 = v10;
    }
    if (*((unsigned char *)&a1->contents + 2) == 6 && BYTE1(a1->factor.symbolicFactorization.factorization) == 40) {
      int v14 = v12;
    }
    else {
      int v14 = v11;
    }
    BOOL v15 = (*(unsigned char *)&attributes & 1) == 0;
    if (*(unsigned char *)&attributes) {
      int v16 = v11;
    }
    else {
      int v16 = v14;
    }
    if (v15) {
      int v14 = v11;
    }
    if (v16 <= v14) {
      int v17 = v14;
    }
    else {
      int v17 = v16;
    }
    if (v7 == v17)
    {
      _SparseSolveSubfactor_Double(a1, 0, (const DenseMatrix_Double *)a2, a3);
      return;
    }
    if (*(void *)&v20[40])
    {
      memset(v20, 0, sizeof(v20));
      snprintf(v20, 0x100uLL, "XB dimension (%d) must match maximum subfactor dimension (%d).\n", v7, v17);
      goto LABEL_30;
    }
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t v20 = 67109376;
      *(_DWORD *)&v20[4] = v7;
      *(_WORD *)&v20[8] = 1024;
      *(_DWORD *)&v20[10] = v17;
      _os_log_error_impl(&dword_2153B7000, &_os_log_internal, OS_LOG_TYPE_ERROR, "XB dimension (%d) must match maximum subfactor dimension (%d).\n", v20, 0xEu);
    }
LABEL_25:
    _SparseTrap();
    return;
  }
  if (!*(void *)&v20[40])
  {
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_25;
    }
    *(_WORD *)uint64_t v20 = 0;
    DenseMatrix_Double v18 = &_os_log_internal;
    long long v19 = "XB must have non-zero dimension.\n";
    goto LABEL_37;
  }
  memset(&v20[34], 0, 222);
  strcpy(v20, "XB must have non-zero dimension.\n");
LABEL_30:
  v6(v20);
}

void sub_215429358(const SparseOpaqueSubfactor_Double *a1, uint64_t a2)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  if (!*((unsigned char *)&a1->contents + 2))
  {
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_26;
    }
    *(_WORD *)unsigned int v24 = 0;
    int v22 = &_os_log_internal;
    int v23 = "Subfactor does not hold a valid factorization.\n";
    goto LABEL_42;
  }
  _SparseGetOptionsFromSymbolicFactor((SparseSymbolicFactorOptions *)v24, &a1->factor.symbolicFactorization);
  long long v4 = *(void (**)(unsigned char *))&v24[40];
  uint64_t v5 = *(_WORD *)(a2 + 12) & 1;
  uint64_t v6 = *(unsigned int *)(a2 + 4 * (v5 == 0));
  if ((int)v6 <= 0)
  {
    if (*(void *)&v24[40])
    {
      memset(&v24[34], 0, 222);
      strcpy(v24, "XB must have non-zero dimension.\n");
      goto LABEL_35;
    }
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_26;
    }
    *(_WORD *)unsigned int v24 = 0;
    int v22 = &_os_log_internal;
    int v23 = "XB must have non-zero dimension.\n";
LABEL_42:
    _os_log_error_impl(&dword_2153B7000, v22, OS_LOG_TYPE_ERROR, v23, v24, 2u);
    goto LABEL_26;
  }
  int v7 = *(_DWORD *)(a2 + 4 * v5);
  SparseAttributes_t attributes = a1->attributes;
  int factorization_low = LOBYTE(a1->factor.symbolicFactorization.factorization);
  int v10 = a1->factor.symbolicFactorization.rowCount * factorization_low;
  int v11 = a1->factor.symbolicFactorization.columnCount * factorization_low;
  if (v10 <= v11) {
    int v12 = v11;
  }
  else {
    int v12 = v10;
  }
  if (v10 < v11) {
    int v11 = v10;
  }
  if (*((unsigned char *)&a1->contents + 2) == 6 && BYTE1(a1->factor.symbolicFactorization.factorization) == 40) {
    int v14 = v12;
  }
  else {
    int v14 = v11;
  }
  BOOL v15 = (*(unsigned char *)&attributes & 1) == 0;
  if (*(unsigned char *)&attributes) {
    int v16 = v11;
  }
  else {
    int v16 = v14;
  }
  if (v15) {
    int v14 = v11;
  }
  if (v16 <= v14) {
    int v17 = v14;
  }
  else {
    int v17 = v16;
  }
  if (v7 == v17)
  {
    DenseMatrix_Double v18 = *(void (**)(char *))&v24[32];
    uint64_t v19 = a1->workspaceRequiredPerRHS + *(void *)&a1[1].attributes * v6;
    uint64_t v20 = (char *)(*(uint64_t (**)(uint64_t))&v24[24])(v19);
    if (v20)
    {
      uint64_t v21 = v20;
      _SparseSolveSubfactor_Double(a1, 0, (const DenseMatrix_Double *)a2, v20);
      v18(v21);
      return;
    }
    if (v4)
    {
      memset(v24, 0, sizeof(v24));
      snprintf(v24, 0x100uLL, "Failed to allocate workspace of size %ld.\n");
      goto LABEL_35;
    }
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)unsigned int v24 = 134217984;
      *(void *)&v24[4] = v19;
      _os_log_error_impl(&dword_2153B7000, &_os_log_internal, OS_LOG_TYPE_ERROR, "Failed to allocate workspace of size %ld.\n", v24, 0xCu);
    }
LABEL_26:
    _SparseTrap();
    return;
  }
  if (!*(void *)&v24[40])
  {
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)unsigned int v24 = 67109376;
      *(_DWORD *)&v24[4] = v7;
      *(_WORD *)&v24[8] = 1024;
      *(_DWORD *)&v24[10] = v17;
      _os_log_error_impl(&dword_2153B7000, &_os_log_internal, OS_LOG_TYPE_ERROR, "XB dimension (%d) must match maximum subfactor dimension (%d).\n", v24, 0xEu);
    }
    goto LABEL_26;
  }
  memset(v24, 0, sizeof(v24));
  snprintf(v24, 0x100uLL, "XB dimension (%d) must match maximum subfactor dimension (%d).\n");
LABEL_35:
  v4(v24);
}

__n128 cva::VecLibSparse<double>::solve(_OWORD *a1, long long *a2, char *a3)
{
  long long v3 = a1[5];
  if (a3)
  {
    double v18[4] = a1[4];
    v18[5] = v3;
    long long v4 = a1[7];
    v18[6] = a1[6];
    v18[7] = v4;
    long long v5 = a1[1];
    v18[0] = *a1;
    v18[1] = v5;
    long long v6 = a1[3];
    void v18[2] = a1[2];
    v18[3] = v6;
    long long v7 = *a2;
    uint64_t v17 = *((void *)a2 + 2);
    long long v16 = v7;
    sub_2154290BC((const SparseOpaqueSubfactor_Double *)v18, (uint64_t)&v16, a3);
  }
  else
  {
    v15[4] = a1[4];
    v15[5] = v3;
    long long v9 = a1[7];
    CVPixelBufferRef v15[6] = a1[6];
    v15[7] = v9;
    long long v10 = a1[1];
    v15[0] = *a1;
    v15[1] = v10;
    long long v11 = a1[3];
    double v15[2] = a1[2];
    void v15[3] = v11;
    long long v12 = *a2;
    uint64_t v14 = *((void *)a2 + 2);
    long long v13 = v12;
    sub_215429358((const SparseOpaqueSubfactor_Double *)v15, (uint64_t)&v13);
  }
  return result;
}

__n128 cva::VecLibSparse<double>::multiply(_OWORD *a1, long long *a2, long long *a3, char *a4)
{
  long long v4 = a1[5];
  if (a4)
  {
    void v21[4] = a1[4];
    v21[5] = v4;
    long long v5 = a1[7];
    v21[6] = a1[6];
    v21[7] = v5;
    long long v6 = a1[1];
    v21[0] = *a1;
    v21[1] = v6;
    long long v7 = a1[3];
    v21[2] = a1[2];
    v21[3] = v7;
    long long v8 = *a2;
    v20.data = (double *)*((void *)a2 + 2);
    *(_OWORD *)&v20.rowCFIndex Count = v8;
    uint64_t v19 = *((void *)a3 + 2);
    long long v18 = *a3;
    sub_21542980C((const SparseOpaqueSubfactor_Double *)v21, &v20, (uint64_t)&v18, a4);
  }
  else
  {
    void v17[4] = a1[4];
    v17[5] = v4;
    long long v10 = a1[7];
    v17[6] = a1[6];
    v17[7] = v10;
    long long v11 = a1[1];
    v17[0] = *a1;
    v17[1] = v11;
    long long v12 = a1[3];
    void v17[2] = a1[2];
    unsigned int v17[3] = v12;
    long long v13 = *a2;
    uint64_t v16 = *((void *)a2 + 2);
    long long v15 = v13;
    DenseMatrix_Double v14 = *(DenseMatrix_Double *)a3;
    sub_215429E60((const SparseOpaqueSubfactor_Double *)v17, (uint64_t)&v15, &v14);
  }
  return result;
}

void sub_21542980C(const SparseOpaqueSubfactor_Double *a1, const DenseMatrix_Double *a2, uint64_t a3, char *a4)
{
  uint64_t v47 = *MEMORY[0x263EF8340];
  if (!*((unsigned char *)&a1->contents + 2))
  {
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v33.control) = 0;
      _os_log_error_impl(&dword_2153B7000, &_os_log_internal, OS_LOG_TYPE_ERROR, "Subfactor does not hold a valid factor subobject.\n", (uint8_t *)&v33, 2u);
    }
    goto LABEL_58;
  }
  _SparseGetOptionsFromSymbolicFactor(&v33, &a1->factor.symbolicFactorization);
  reportError = v33.reportError;
  SparseAttributes_t attributes = a1->attributes;
  int factorization_low = LOBYTE(a1->factor.symbolicFactorization.factorization);
  int v11 = a1->factor.symbolicFactorization.rowCount * factorization_low;
  int v12 = a1->factor.symbolicFactorization.columnCount * factorization_low;
  if (v11 >= v12) {
    int v13 = a1->factor.symbolicFactorization.columnCount * factorization_low;
  }
  else {
    int v13 = a1->factor.symbolicFactorization.rowCount * factorization_low;
  }
  if (v11 <= v12) {
    int v11 = v12;
  }
  if (*((unsigned char *)&a1->contents + 2) == 6 && BYTE1(a1->factor.symbolicFactorization.factorization) == 40) {
    int v15 = v11;
  }
  else {
    int v15 = v13;
  }
  if (*(unsigned char *)&attributes) {
    int v16 = v15;
  }
  else {
    int v16 = v13;
  }
  if (*(unsigned char *)&attributes) {
    int v17 = v13;
  }
  else {
    int v17 = v15;
  }
  int v18 = *(_DWORD *)(a3 + 8);
  int v19 = *(_DWORD *)a3;
  if (v18 < *(_DWORD *)a3)
  {
    if (v33.reportError) {
      goto LABEL_26;
    }
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_58;
    }
    v33.control = 136315906;
    *(void *)&v33.orderMethod = "Y";
    WORD2(v33.order) = 1024;
    *(_DWORD *)((char *)&v33.order + 6) = v18;
    WORD1(v33.ignoreRowsAndColumns) = 2080;
    *(int **)((char *)&v33.ignoreRowsAndColumns + 4) = (int *)"Y";
    WORD2(v33.malloc) = 1024;
    *(_DWORD *)((char *)&v33.malloc + 6) = v19;
    uint64_t v26 = &_os_log_internal;
    goto LABEL_41;
  }
  int columnStride = a2->columnStride;
  rowCFIndex Count = a2->rowCount;
  if (columnStride >= a2->rowCount)
  {
    __int16 v22 = *(_WORD *)(a3 + 12);
    if ((v22 & 1) == 0) {
      int v19 = *(_DWORD *)(a3 + 4);
    }
    int v23 = *(&a2->rowCount + ((*(_WORD *)&a2->attributes & 1) == 0));
    unsigned int v24 = v22 & 1;
    int v25 = *(&a2->rowCount + (*(_WORD *)&a2->attributes & 1));
    if (v19 == v23)
    {
      if (v19 <= 0)
      {
        if (v33.reportError)
        {
          long long v45 = 0u;
          long long v46 = 0u;
          long long v43 = 0u;
          long long v44 = 0u;
          long long v41 = 0u;
          long long v42 = 0u;
          long long v39 = 0u;
          long long v40 = 0u;
          long long v37 = 0u;
          long long v38 = 0u;
          long long v35 = 0u;
          long long v36 = 0u;
          long long v34 = 0u;
          memset(&v33, 0, sizeof(v33));
          snprintf((char *)&v33, 0x100uLL, "%s (%dx%d) must represent at least one right-hand side.\n");
          goto LABEL_27;
        }
        int v31 = *(_DWORD *)(a3 + 4 * v24);
        if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
        {
          v33.control = 136315650;
          *(void *)&v33.orderMethod = "Y";
          WORD2(v33.order) = 1024;
          *(_DWORD *)((char *)&v33.order + 6) = v31;
          WORD1(v33.ignoreRowsAndColumns) = 1024;
          HIDWORD(v33.ignoreRowsAndColumns) = v19;
          _os_log_error_impl(&dword_2153B7000, &_os_log_internal, OS_LOG_TYPE_ERROR, "%s (%dx%d) must represent at least one right-hand side.\n", (uint8_t *)&v33, 0x18u);
        }
        goto LABEL_58;
      }
      if (*(_DWORD *)(a3 + 4 * v24) == v17)
      {
        if (v25 == v16)
        {
          _SparseMultiplySubfactor_Double(a1, a2, (const DenseMatrix_Double *)a3, a4);
          return;
        }
        if (v33.reportError)
        {
          long long v45 = 0u;
          long long v46 = 0u;
          long long v43 = 0u;
          long long v44 = 0u;
          long long v41 = 0u;
          long long v42 = 0u;
          long long v39 = 0u;
          long long v40 = 0u;
          long long v37 = 0u;
          long long v38 = 0u;
          long long v35 = 0u;
          long long v36 = 0u;
          long long v34 = 0u;
          memset(&v33, 0, sizeof(v33));
          uint64_t v30 = "X";
          goto LABEL_50;
        }
        if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
          goto LABEL_58;
        }
        v33.control = 136316418;
        *(void *)&v33.orderMethod = "X";
        WORD2(v33.order) = 1024;
        *(_DWORD *)((char *)&v33.order + 6) = v25;
        WORD1(v33.ignoreRowsAndColumns) = 1024;
        HIDWORD(v33.ignoreRowsAndColumns) = v19;
        LOWORD(v33.malloc) = 2080;
        *(void *(__cdecl **)(size_t))((char *)&v33.malloc + 2) = (void *(__cdecl *)(size_t))"subfactor dimension";
        WORD1(v33.free) = 1024;
        HIDWORD(v33.free) = v16;
        LOWORD(v33.reportError) = 1024;
        *(_DWORD *)((char *)&v33.reportError + 2) = v17;
        DenseMatrix_Double v28 = &_os_log_internal;
        SparseOpaqueFactorization_Double v29 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
      }
      else
      {
        if (v33.reportError)
        {
          long long v45 = 0u;
          long long v46 = 0u;
          long long v43 = 0u;
          long long v44 = 0u;
          long long v41 = 0u;
          long long v42 = 0u;
          long long v39 = 0u;
          long long v40 = 0u;
          long long v37 = 0u;
          long long v38 = 0u;
          long long v35 = 0u;
          long long v36 = 0u;
          long long v34 = 0u;
          memset(&v33, 0, sizeof(v33));
          uint64_t v30 = "Y";
LABEL_50:
          snprintf((char *)&v33, 0x100uLL, "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n", v30);
          goto LABEL_27;
        }
        int v32 = *(_DWORD *)(a3 + 4 * v24);
        if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
          goto LABEL_58;
        }
        v33.control = 136316418;
        *(void *)&v33.orderMethod = "Y";
        WORD2(v33.order) = 1024;
        *(_DWORD *)((char *)&v33.order + 6) = v32;
        WORD1(v33.ignoreRowsAndColumns) = 1024;
        HIDWORD(v33.ignoreRowsAndColumns) = v19;
        LOWORD(v33.malloc) = 2080;
        *(void *(__cdecl **)(size_t))((char *)&v33.malloc + 2) = (void *(__cdecl *)(size_t))"subfactor dimension";
        WORD1(v33.free) = 1024;
        HIDWORD(v33.free) = v16;
        LOWORD(v33.reportError) = 1024;
        *(_DWORD *)((char *)&v33.reportError + 2) = v17;
        DenseMatrix_Double v28 = &_os_log_internal;
        SparseOpaqueFactorization_Double v29 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
      }
    }
    else
    {
      if (v33.reportError)
      {
        long long v45 = 0u;
        long long v46 = 0u;
        long long v43 = 0u;
        long long v44 = 0u;
        long long v41 = 0u;
        long long v42 = 0u;
        long long v39 = 0u;
        long long v40 = 0u;
        long long v37 = 0u;
        long long v38 = 0u;
        long long v35 = 0u;
        long long v36 = 0u;
        long long v34 = 0u;
        memset(&v33, 0, sizeof(v33));
        snprintf((char *)&v33, 0x100uLL, "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n", "Y");
        goto LABEL_27;
      }
      int v27 = *(_DWORD *)(a3 + 4 * v24);
      if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
        goto LABEL_58;
      }
      v33.control = 136316418;
      *(void *)&v33.orderMethod = "Y";
      WORD2(v33.order) = 1024;
      *(_DWORD *)((char *)&v33.order + 6) = v27;
      WORD1(v33.ignoreRowsAndColumns) = 1024;
      HIDWORD(v33.ignoreRowsAndColumns) = v19;
      LOWORD(v33.malloc) = 2080;
      *(void *(__cdecl **)(size_t))((char *)&v33.malloc + 2) = (void *(__cdecl *)(size_t))"X";
      WORD1(v33.free) = 1024;
      HIDWORD(v33.free) = v25;
      LOWORD(v33.reportError) = 1024;
      *(_DWORD *)((char *)&v33.reportError + 2) = v23;
      DenseMatrix_Double v28 = &_os_log_internal;
      SparseOpaqueFactorization_Double v29 = "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n";
    }
    _os_log_error_impl(&dword_2153B7000, v28, OS_LOG_TYPE_ERROR, v29, (uint8_t *)&v33, 0x2Eu);
    goto LABEL_58;
  }
  if (v33.reportError)
  {
LABEL_26:
    long long v45 = 0u;
    long long v46 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v34 = 0u;
    memset(&v33, 0, sizeof(v33));
    snprintf((char *)&v33, 0x100uLL, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n");
LABEL_27:
    ((void (*)(SparseSymbolicFactorOptions *))reportError)(&v33);
    return;
  }
  if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
    goto LABEL_58;
  }
  v33.control = 136315906;
  *(void *)&v33.orderMethod = "X";
  WORD2(v33.order) = 1024;
  *(_DWORD *)((char *)&v33.order + 6) = columnStride;
  WORD1(v33.ignoreRowsAndColumns) = 2080;
  *(int **)((char *)&v33.ignoreRowsAndColumns + 4) = (int *)"X";
  WORD2(v33.malloc) = 1024;
  *(_DWORD *)((char *)&v33.malloc + 6) = rowCount;
  uint64_t v26 = &_os_log_internal;
LABEL_41:
  _os_log_error_impl(&dword_2153B7000, v26, OS_LOG_TYPE_ERROR, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n", (uint8_t *)&v33, 0x22u);
LABEL_58:
  _SparseTrap();
}

void sub_215429E60(const SparseOpaqueSubfactor_Double *a1, uint64_t a2, const DenseMatrix_Double *a3)
{
  uint64_t v46 = *MEMORY[0x263EF8340];
  if (!*((unsigned char *)&a1->contents + 2))
  {
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v32.control) = 0;
      _os_log_error_impl(&dword_2153B7000, &_os_log_internal, OS_LOG_TYPE_ERROR, "Subfactor does not hold a valid factor subobject.\n", (uint8_t *)&v32, 2u);
    }
    goto LABEL_63;
  }
  _SparseGetOptionsFromSymbolicFactor(&v32, &a1->factor.symbolicFactorization);
  reportError = v32.reportError;
  SparseAttributes_t attributes = a1->attributes;
  int factorization_low = LOBYTE(a1->factor.symbolicFactorization.factorization);
  int v9 = a1->factor.symbolicFactorization.rowCount * factorization_low;
  int v10 = a1->factor.symbolicFactorization.columnCount * factorization_low;
  if (v9 >= v10) {
    int v11 = a1->factor.symbolicFactorization.columnCount * factorization_low;
  }
  else {
    int v11 = a1->factor.symbolicFactorization.rowCount * factorization_low;
  }
  if (v9 <= v10) {
    int v9 = v10;
  }
  if (*((unsigned char *)&a1->contents + 2) == 6 && BYTE1(a1->factor.symbolicFactorization.factorization) == 40) {
    int v13 = v9;
  }
  else {
    int v13 = v11;
  }
  if (*(unsigned char *)&attributes) {
    int v14 = v13;
  }
  else {
    int v14 = v11;
  }
  if (*(unsigned char *)&attributes) {
    int v15 = v11;
  }
  else {
    int v15 = v13;
  }
  int v16 = *(_DWORD *)(a2 + 8);
  int v17 = *(_DWORD *)a2;
  if (v16 < *(_DWORD *)a2)
  {
    if (v32.reportError) {
      goto LABEL_26;
    }
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_63;
    }
    v32.control = 136315906;
    *(void *)&v32.orderMethod = "X";
    WORD2(v32.order) = 1024;
    *(_DWORD *)((char *)&v32.order + 6) = v16;
    WORD1(v32.ignoreRowsAndColumns) = 2080;
    *(int **)((char *)&v32.ignoreRowsAndColumns + 4) = (int *)"X";
    WORD2(v32.malloc) = 1024;
    *(_DWORD *)((char *)&v32.malloc + 6) = v17;
    DenseMatrix_Double v28 = &_os_log_internal;
    goto LABEL_42;
  }
  int columnStride = a3->columnStride;
  rowCFIndex Count = a3->rowCount;
  if (columnStride < a3->rowCount)
  {
    if (v32.reportError)
    {
LABEL_26:
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      long long v36 = 0u;
      long long v37 = 0u;
      long long v34 = 0u;
      long long v35 = 0u;
      long long v33 = 0u;
      memset(&v32, 0, sizeof(v32));
      snprintf((char *)&v32, 0x100uLL, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n");
LABEL_27:
      ((void (*)(SparseSymbolicFactorOptions *))reportError)(&v32);
      return;
    }
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_63;
    }
    v32.control = 136315906;
    *(void *)&v32.orderMethod = "Y";
    WORD2(v32.order) = 1024;
    *(_DWORD *)((char *)&v32.order + 6) = columnStride;
    WORD1(v32.ignoreRowsAndColumns) = 2080;
    *(int **)((char *)&v32.ignoreRowsAndColumns + 4) = (int *)"Y";
    WORD2(v32.malloc) = 1024;
    *(_DWORD *)((char *)&v32.malloc + 6) = rowCount;
    DenseMatrix_Double v28 = &_os_log_internal;
LABEL_42:
    _os_log_error_impl(&dword_2153B7000, v28, OS_LOG_TYPE_ERROR, "%s.columnStride (%d) must be at least %s.rowCount (%d).\n", (uint8_t *)&v32, 0x22u);
    goto LABEL_63;
  }
  __int16 v20 = *(_WORD *)(a2 + 12);
  if ((v20 & 1) == 0) {
    int v17 = *(_DWORD *)(a2 + 4);
  }
  int v21 = *(&a3->rowCount + ((*(_WORD *)&a3->attributes & 1) == 0));
  int v22 = *(_DWORD *)(a2 + 4 * (v20 & 1));
  int v23 = *(&a3->rowCount + (*(_WORD *)&a3->attributes & 1));
  if (v17 != v21)
  {
    if (v32.reportError)
    {
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      long long v36 = 0u;
      long long v37 = 0u;
      long long v34 = 0u;
      long long v35 = 0u;
      long long v33 = 0u;
      memset(&v32, 0, sizeof(v32));
      snprintf((char *)&v32, 0x100uLL, "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n", "X");
      goto LABEL_27;
    }
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_63;
    }
    v32.control = 136316418;
    *(void *)&v32.orderMethod = "X";
    WORD2(v32.order) = 1024;
    *(_DWORD *)((char *)&v32.order + 6) = v22;
    WORD1(v32.ignoreRowsAndColumns) = 1024;
    HIDWORD(v32.ignoreRowsAndColumns) = v17;
    LOWORD(v32.malloc) = 2080;
    *(void *(__cdecl **)(size_t))((char *)&v32.malloc + 2) = (void *(__cdecl *)(size_t))"Y";
    WORD1(v32.free) = 1024;
    HIDWORD(v32.free) = v23;
    LOWORD(v32.reportError) = 1024;
    *(_DWORD *)((char *)&v32.reportError + 2) = v21;
    SparseOpaqueFactorization_Double v29 = &_os_log_internal;
    uint64_t v30 = "%s (%dx%d) and %s (%dx%d) do not represent the same number of right-hand sides.\n";
    goto LABEL_60;
  }
  if (v17 <= 0)
  {
    if (v32.reportError)
    {
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      long long v36 = 0u;
      long long v37 = 0u;
      long long v34 = 0u;
      long long v35 = 0u;
      long long v33 = 0u;
      memset(&v32, 0, sizeof(v32));
      snprintf((char *)&v32, 0x100uLL, "%s (%dx%d) must represent at least one right-hand side.\n");
      goto LABEL_27;
    }
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      v32.control = 136315650;
      *(void *)&v32.orderMethod = "X";
      WORD2(v32.order) = 1024;
      *(_DWORD *)((char *)&v32.order + 6) = v22;
      WORD1(v32.ignoreRowsAndColumns) = 1024;
      HIDWORD(v32.ignoreRowsAndColumns) = v17;
      _os_log_error_impl(&dword_2153B7000, &_os_log_internal, OS_LOG_TYPE_ERROR, "%s (%dx%d) must represent at least one right-hand side.\n", (uint8_t *)&v32, 0x18u);
    }
    goto LABEL_63;
  }
  if (v22 != v14)
  {
    if (v32.reportError)
    {
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      long long v36 = 0u;
      long long v37 = 0u;
      long long v34 = 0u;
      long long v35 = 0u;
      long long v33 = 0u;
      memset(&v32, 0, sizeof(v32));
      int v31 = "X";
LABEL_51:
      snprintf((char *)&v32, 0x100uLL, "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n", v31);
      goto LABEL_27;
    }
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_63;
    }
    v32.control = 136316418;
    *(void *)&v32.orderMethod = "X";
    WORD2(v32.order) = 1024;
    *(_DWORD *)((char *)&v32.order + 6) = v22;
    WORD1(v32.ignoreRowsAndColumns) = 1024;
    HIDWORD(v32.ignoreRowsAndColumns) = v17;
    LOWORD(v32.malloc) = 2080;
    *(void *(__cdecl **)(size_t))((char *)&v32.malloc + 2) = (void *(__cdecl *)(size_t))"subfactor dimension";
    WORD1(v32.free) = 1024;
    HIDWORD(v32.free) = v15;
    LOWORD(v32.reportError) = 1024;
    *(_DWORD *)((char *)&v32.reportError + 2) = v14;
    SparseOpaqueFactorization_Double v29 = &_os_log_internal;
    uint64_t v30 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
LABEL_60:
    _os_log_error_impl(&dword_2153B7000, v29, OS_LOG_TYPE_ERROR, v30, (uint8_t *)&v32, 0x2Eu);
    goto LABEL_63;
  }
  if (v23 != v15)
  {
    if (v32.reportError)
    {
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      long long v36 = 0u;
      long long v37 = 0u;
      long long v34 = 0u;
      long long v35 = 0u;
      long long v33 = 0u;
      memset(&v32, 0, sizeof(v32));
      int v31 = "Y";
      goto LABEL_51;
    }
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      goto LABEL_63;
    }
    v32.control = 136316418;
    *(void *)&v32.orderMethod = "Y";
    WORD2(v32.order) = 1024;
    *(_DWORD *)((char *)&v32.order + 6) = v23;
    WORD1(v32.ignoreRowsAndColumns) = 1024;
    HIDWORD(v32.ignoreRowsAndColumns) = v17;
    LOWORD(v32.malloc) = 2080;
    *(void *(__cdecl **)(size_t))((char *)&v32.malloc + 2) = (void *(__cdecl *)(size_t))"subfactor dimension";
    WORD1(v32.free) = 1024;
    HIDWORD(v32.free) = v15;
    LOWORD(v32.reportError) = 1024;
    *(_DWORD *)((char *)&v32.reportError + 2) = v14;
    SparseOpaqueFactorization_Double v29 = &_os_log_internal;
    uint64_t v30 = "%s (size %dx%d) does not match dimensions of %s (%d x %d).\n";
    goto LABEL_60;
  }
  free = v32.free;
  size_t v25 = a1->workspaceRequiredPerRHS + *(void *)&a1[1].attributes * v17;
  uint64_t v26 = (char *)((uint64_t (*)(size_t))v32.malloc)(v25);
  if (v26)
  {
    int v27 = v26;
    _SparseMultiplySubfactor_Double(a1, (const DenseMatrix_Double *)a2, a3, v26);
    ((void (*)(char *))free)(v27);
    return;
  }
  if (reportError)
  {
    long long v44 = 0u;
    long long v45 = 0u;
    long long v42 = 0u;
    long long v43 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v33 = 0u;
    memset(&v32, 0, sizeof(v32));
    snprintf((char *)&v32, 0x100uLL, "Failed to allocate workspace of size %ld.\n");
    goto LABEL_27;
  }
  if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
  {
    v32.control = 134217984;
    *(void *)&v32.orderMethod = v25;
    _os_log_error_impl(&dword_2153B7000, &_os_log_internal, OS_LOG_TYPE_ERROR, "Failed to allocate workspace of size %ld.\n", (uint8_t *)&v32, 0xCu);
  }
LABEL_63:
  _SparseTrap();
}

void cva::VecLibSparse<double>::multiply(_OWORD *a1, uint64_t a2, uint64_t a3, char *a4)
{
  long long v4 = a1[5];
  v13[4] = a1[4];
  v13[5] = v4;
  long long v5 = a1[7];
  v13[6] = a1[6];
  v13[7] = v5;
  long long v6 = a1[1];
  v13[0] = *a1;
  v13[1] = v6;
  long long v7 = a1[3];
  void v13[2] = a1[2];
  float32x2_t v13[3] = v7;
  long long v8 = *(double **)(a2 + 8);
  int v9 = *(_DWORD *)a3;
  int v10 = *(double **)(a3 + 8);
  v12.rowCFIndex Count = *(_DWORD *)a2;
  v12.columnCFIndex Count = 1;
  v12.int columnStride = v12.rowCount;
  *(_DWORD *)&v12.SparseAttributes_t attributes = 0;
  v12.data = v8;
  v11.rowCFIndex Count = v9;
  v11.columnCFIndex Count = 1;
  v11.int columnStride = v9;
  *(_DWORD *)&v11.SparseAttributes_t attributes = 0;
  v11.data = v10;
  if (a4) {
    sub_21542980C((const SparseOpaqueSubfactor_Double *)v13, &v12, (uint64_t)&v11, a4);
  }
  else {
    sub_215429E60((const SparseOpaqueSubfactor_Double *)v13, (uint64_t)&v12, &v11);
  }
}

BOOL cva::adp::Version::operator<(_DWORD *a1, _DWORD *a2)
{
  if (*a1 < *a2) {
    return 1;
  }
  if (*a1 == *a2) {
    return a1[1] < a2[1];
  }
  return 0;
}

BOOL cva::adp::Version::operator==(_DWORD *a1, _DWORD *a2)
{
  return *a1 == *a2 && a1[1] == a2[1];
}

BOOL cva::adp::Version::operator>(_DWORD *a1, _DWORD *a2)
{
  if (*a1 > *a2) {
    return 1;
  }
  if (*a1 == *a2) {
    return a1[1] > a2[1];
  }
  return 0;
}

BOOL cva::adp::Version::isCurrent(cva::adp::Version *this)
{
  return !*(_DWORD *)this && *((_DWORD *)this + 1) == 9;
}

uint64_t cva::adp::Version::defaultVersion(cva::adp::Version *this)
{
  return 0x100000000;
}

uint64_t cva::adp::Version::currentVersion(cva::adp::Version *this)
{
  return 0x900000000;
}

uint64_t cva::adp::io::openInputStream@<X0>(const char **this@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v5 = MEMORY[0x263F8C308] + 24;
  uint64_t v6 = MEMORY[0x263F8C308] + 64;
  a2[53] = MEMORY[0x263F8C308] + 64;
  long long v7 = a2 + 2;
  uint64_t v8 = *(void *)(MEMORY[0x263F8C2A8] + 16);
  uint64_t v9 = *(void *)(MEMORY[0x263F8C2A8] + 8);
  *a2 = v9;
  *(uint64_t *)((char *)a2 + *(void *)(v9 - 24)) = v8;
  a2[1] = 0;
  int v10 = (std::ios_base *)((char *)a2 + *(void *)(*a2 - 24));
  std::ios_base::init(v10, v7);
  v10[1].__vftable = 0;
  v10[1].__fmtflags_ = -1;
  *a2 = v5;
  a2[53] = v6;
  MEMORY[0x2166B94F0](v7);
  DenseMatrix_Double v11 = *this;
  if ((*this)[23] < 0) {
    DenseMatrix_Double v11 = *(const char **)v11;
  }
  uint64_t result = access(v11, 0);
  if (!result)
  {
    int v13 = *this;
    if ((*this)[23] < 0) {
      int v13 = *(const char **)v13;
    }
    uint64_t result = stat(v13, &v15);
    if (!result && (v15.st_mode & 0xF000) == 0x8000)
    {
      int v14 = *this;
      return MEMORY[0x270F98868](a2, v14, 8);
    }
  }
  return result;
}

uint64_t cva::adp::io::openOutputStream@<X0>(cva::adp::io *this@<X0>, const cva::Path *a2@<X1>, char a3@<W2>, uint64_t *a4@<X8>)
{
  int v5 = (int)a2;
  uint64_t v8 = MEMORY[0x263F8C310] + 24;
  uint64_t v9 = MEMORY[0x263F8C310] + 64;
  a4[52] = MEMORY[0x263F8C310] + 64;
  int v10 = a4 + 1;
  uint64_t v11 = *(void *)(MEMORY[0x263F8C2B0] + 16);
  uint64_t v12 = *(void *)(MEMORY[0x263F8C2B0] + 8);
  *a4 = v12;
  *(uint64_t *)((char *)a4 + *(void *)(v12 - 24)) = v11;
  int v13 = (std::ios_base *)((char *)a4 + *(void *)(*a4 - 24));
  std::ios_base::init(v13, v10);
  v13[1].__vftable = 0;
  v13[1].__fmtflags_ = -1;
  *a4 = v8;
  a4[52] = v9;
  MEMORY[0x2166B94F0](v10);
  if (a3)
  {
    uint64_t v14 = 20;
  }
  else
  {
    *(uint64_t *)((char *)a4 + *(void *)(*a4 - 24) + 16) = v5;
    uint64_t v14 = 16;
  }
  uint64_t v15 = *(void *)this;
  return MEMORY[0x270F98880](a4, v15, v14);
}

uint64_t cva::adp::io::openOutputStream@<X0>(cva::adp::io *this@<X0>, const cva::Path *a2@<X1>, uint64_t *a3@<X8>)
{
  char v3 = (char)a2;
  uint64_t v6 = MEMORY[0x263F8C310] + 24;
  uint64_t v7 = MEMORY[0x263F8C310] + 64;
  a3[52] = MEMORY[0x263F8C310] + 64;
  uint64_t v8 = a3 + 1;
  uint64_t v9 = *(void *)(MEMORY[0x263F8C2B0] + 16);
  uint64_t v10 = *(void *)(MEMORY[0x263F8C2B0] + 8);
  *a3 = v10;
  *(uint64_t *)((char *)a3 + *(void *)(v10 - 24)) = v9;
  uint64_t v11 = (std::ios_base *)((char *)a3 + *(void *)(*a3 - 24));
  std::ios_base::init(v11, v8);
  v11[1].__vftable = 0;
  v11[1].__fmtflags_ = -1;
  *a3 = v6;
  a3[52] = v7;
  MEMORY[0x2166B94F0](v8);
  if (v3)
  {
    uint64_t v12 = 20;
  }
  else
  {
    uint64_t v12 = 16;
    *(uint64_t *)((char *)a3 + *(void *)(*a3 - 24) + 16) = 16;
  }
  uint64_t v13 = *(void *)this;
  return MEMORY[0x270F98880](a3, v13, v12);
}

BOOL cva::adp::io::createPath(const char **this, const cva::Path *a2)
{
  char v3 = *this;
  if (v3[23] < 0) {
    char v3 = *(const char **)v3;
  }
  if (!access(v3, 0)) {
    return 1;
  }
  long long v4 = *this;
  if ((*this)[23] < 0) {
    long long v4 = *(const char **)v4;
  }
  if (access(v4, 0))
  {
    int v5 = *this;
    if ((*this)[23] < 0) {
      int v5 = *(const char **)v5;
    }
    return !mkdir(v5, 0x1FFu);
  }
  uint64_t v7 = *this;
  if ((*this)[23] < 0) {
    uint64_t v7 = *(const char **)v7;
  }
  int v8 = stat(v7, &v9);
  BOOL result = 0;
  if (!v8 && (v9.st_mode & 0xF000) == 0x4000) {
    return 1;
  }
  return result;
}

uint64_t cva::adp::io::whiteSpace@<X0>(uint64_t this@<X0>, char *a2@<X8>)
{
  if (this)
  {
    char v2 = 0;
    char v3 = 0;
  }
  else
  {
    a2[1] = 0;
    char v3 = 32;
    char v2 = 1;
  }
  a2[23] = v2;
  *a2 = v3;
  return this;
}

uint64_t cva::adp::io::endLine@<X0>(uint64_t this@<X0>, char *a2@<X8>)
{
  if (this)
  {
    char v2 = 0;
    char v3 = 0;
  }
  else
  {
    a2[1] = 0;
    char v3 = 10;
    char v2 = 1;
  }
  a2[23] = v2;
  *a2 = v3;
  return this;
}

void cva::BufferTiled<float>::allocTexture(_DWORD *a1, id *a2, char a3, void *a4)
{
  id v7 = *a2;
  if ((a3 & 1) == 0)
  {
    if (a4[1]) {
      goto LABEL_24;
    }
    id v16 = v7;
    if (*a4)
    {
      id v10 = *(id *)(*a4 + 8);
      if ([v10 pixelFormat] == 55) {
        goto LABEL_23;
      }
      uint64_t v14 = (void *)[v10 newTextureViewWithPixelFormat:55];
      uint64_t v15 = *a4;
      if (*a4)
      {

        MEMORY[0x2166B9890](v15, 0xE0C400670D255);
      }
      id v13 = v14;
      if (v13) {
        operator new();
      }
    }
    else
    {
      id v10 = [MEMORY[0x263F12A50] texture2DDescriptorWithPixelFormat:55 width:(a1[5] * a1[4]) height:a1[6] mipmapped:0];
      id v13 = (id)[v16 newTextureWithDescriptor:v10];
      if (v13) {
        operator new();
      }
    }

    *a4 = 0;
    goto LABEL_22;
  }
  unsigned int v8 = a1[4];
  if ((v8 & 3) != 0) {
    goto LABEL_24;
  }
  id v16 = v7;
  uint64_t v9 = a4[1];
  if (!v9)
  {
    id v10 = [MEMORY[0x263F12A50] texture2DDescriptorWithPixelFormat:125 width:a1[5] * (v8 >> 2) height:a1[6] mipmapped:0];
    id v13 = (id)[v16 newTextureWithDescriptor:v10];
    if (v13) {
      operator new();
    }
    goto LABEL_20;
  }
  id v10 = *(id *)(v9 + 8);
  if ([v10 pixelFormat] != 125)
  {
    uint64_t v11 = (void *)[v10 newTextureViewWithPixelFormat:125];
    uint64_t v12 = a4[1];
    if (v12)
    {

      MEMORY[0x2166B9890](v12, 0xE0C400670D255);
    }
    id v13 = v11;
    if (v13) {
      operator new();
    }
LABEL_20:

    a4[1] = 0;
LABEL_22:
  }
LABEL_23:

  id v7 = v16;
LABEL_24:
}

void sub_21542AF7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t cva::BufferTiled<float>::doResize(uint64_t result, uint64_t *a2)
{
  int v2 = *((_DWORD *)a2 + 2);
  uint64_t v3 = *a2;
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = v3;
  *(_DWORD *)(result + 24) = v2;
  return result;
}

void sub_21542B028()
{
}

void cva::BufferTiled<unsigned short>::allocTexture(_DWORD *a1, id *a2, char a3, void *a4)
{
  id v7 = *a2;
  if ((a3 & 1) == 0)
  {
    if (a4[1]) {
      goto LABEL_24;
    }
    id v16 = v7;
    if (*a4)
    {
      id v10 = *(id *)(*a4 + 8);
      if ([v10 pixelFormat] == 23) {
        goto LABEL_23;
      }
      uint64_t v14 = (void *)[v10 newTextureViewWithPixelFormat:23];
      uint64_t v15 = *a4;
      if (*a4)
      {

        MEMORY[0x2166B9890](v15, 0xE0C400670D255);
      }
      id v13 = v14;
      if (v13) {
        operator new();
      }
    }
    else
    {
      id v10 = [MEMORY[0x263F12A50] texture2DDescriptorWithPixelFormat:23 width:(a1[5] * a1[4]) height:a1[6] mipmapped:0];
      id v13 = (id)[v16 newTextureWithDescriptor:v10];
      if (v13) {
        operator new();
      }
    }

    *a4 = 0;
    goto LABEL_22;
  }
  unsigned int v8 = a1[4];
  if ((v8 & 3) != 0) {
    goto LABEL_24;
  }
  id v16 = v7;
  uint64_t v9 = a4[1];
  if (!v9)
  {
    id v10 = [MEMORY[0x263F12A50] texture2DDescriptorWithPixelFormat:113 width:a1[5] * (v8 >> 2) height:a1[6] mipmapped:0];
    id v13 = (id)[v16 newTextureWithDescriptor:v10];
    if (v13) {
      operator new();
    }
    goto LABEL_20;
  }
  id v10 = *(id *)(v9 + 8);
  if ([v10 pixelFormat] != 113)
  {
    uint64_t v11 = (void *)[v10 newTextureViewWithPixelFormat:113];
    uint64_t v12 = a4[1];
    if (v12)
    {

      MEMORY[0x2166B9890](v12, 0xE0C400670D255);
    }
    id v13 = v11;
    if (v13) {
      operator new();
    }
LABEL_20:

    a4[1] = 0;
LABEL_22:
  }
LABEL_23:

  id v7 = v16;
LABEL_24:
}

void sub_21542B2D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t cva::BufferTiled<unsigned short>::doResize(uint64_t result, uint64_t *a2)
{
  int v2 = *((_DWORD *)a2 + 2);
  uint64_t v3 = *a2;
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = v3;
  *(_DWORD *)(result + 24) = v2;
  return result;
}

void sub_21542B380()
{
}

void cva::BufferTiled<unsigned char>::allocTexture(_DWORD *a1, id *a2, char a3, void *a4)
{
  id v7 = *a2;
  if ((a3 & 1) == 0)
  {
    if (a4[1]) {
      goto LABEL_24;
    }
    id v16 = v7;
    if (*a4)
    {
      id v10 = *(id *)(*a4 + 8);
      if ([v10 pixelFormat] == 13) {
        goto LABEL_23;
      }
      uint64_t v14 = (void *)[v10 newTextureViewWithPixelFormat:13];
      uint64_t v15 = *a4;
      if (*a4)
      {

        MEMORY[0x2166B9890](v15, 0xE0C400670D255);
      }
      id v13 = v14;
      if (v13) {
        operator new();
      }
    }
    else
    {
      id v10 = [MEMORY[0x263F12A50] texture2DDescriptorWithPixelFormat:13 width:(a1[5] * a1[4]) height:a1[6] mipmapped:0];
      id v13 = (id)[v16 newTextureWithDescriptor:v10];
      if (v13) {
        operator new();
      }
    }

    *a4 = 0;
    goto LABEL_22;
  }
  unsigned int v8 = a1[4];
  if ((v8 & 3) != 0) {
    goto LABEL_24;
  }
  id v16 = v7;
  uint64_t v9 = a4[1];
  if (!v9)
  {
    id v10 = [MEMORY[0x263F12A50] texture2DDescriptorWithPixelFormat:73 width:a1[5] * (v8 >> 2) height:a1[6] mipmapped:0];
    id v13 = (id)[v16 newTextureWithDescriptor:v10];
    if (v13) {
      operator new();
    }
    goto LABEL_20;
  }
  id v10 = *(id *)(v9 + 8);
  if ([v10 pixelFormat] != 73)
  {
    uint64_t v11 = (void *)[v10 newTextureViewWithPixelFormat:73];
    uint64_t v12 = a4[1];
    if (v12)
    {

      MEMORY[0x2166B9890](v12, 0xE0C400670D255);
    }
    id v13 = v11;
    if (v13) {
      operator new();
    }
LABEL_20:

    a4[1] = 0;
LABEL_22:
  }
LABEL_23:

  id v7 = v16;
LABEL_24:
}

void sub_21542B62C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t cva::BufferTiled<unsigned char>::doResize(uint64_t result, uint64_t *a2)
{
  int v2 = *((_DWORD *)a2 + 2);
  uint64_t v3 = *a2;
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = v3;
  *(_DWORD *)(result + 24) = v2;
  return result;
}

void sub_21542B6D8()
{
}

void cva::BufferTiled<unsigned int>::allocTexture(_DWORD *a1, id *a2, char a3, void *a4)
{
  id v7 = *a2;
  if ((a3 & 1) == 0)
  {
    if (a4[1]) {
      goto LABEL_24;
    }
    id v16 = v7;
    if (*a4)
    {
      id v10 = *(id *)(*a4 + 8);
      if ([v10 pixelFormat] == 53) {
        goto LABEL_23;
      }
      uint64_t v14 = (void *)[v10 newTextureViewWithPixelFormat:53];
      uint64_t v15 = *a4;
      if (*a4)
      {

        MEMORY[0x2166B9890](v15, 0xE0C400670D255);
      }
      id v13 = v14;
      if (v13) {
        operator new();
      }
    }
    else
    {
      id v10 = [MEMORY[0x263F12A50] texture2DDescriptorWithPixelFormat:53 width:(a1[5] * a1[4]) height:a1[6] mipmapped:0];
      id v13 = (id)[v16 newTextureWithDescriptor:v10];
      if (v13) {
        operator new();
      }
    }

    *a4 = 0;
    goto LABEL_22;
  }
  unsigned int v8 = a1[4];
  if ((v8 & 3) != 0) {
    goto LABEL_24;
  }
  id v16 = v7;
  uint64_t v9 = a4[1];
  if (!v9)
  {
    id v10 = [MEMORY[0x263F12A50] texture2DDescriptorWithPixelFormat:123 width:a1[5] * (v8 >> 2) height:a1[6] mipmapped:0];
    id v13 = (id)[v16 newTextureWithDescriptor:v10];
    if (v13) {
      operator new();
    }
    goto LABEL_20;
  }
  id v10 = *(id *)(v9 + 8);
  if ([v10 pixelFormat] != 123)
  {
    uint64_t v11 = (void *)[v10 newTextureViewWithPixelFormat:123];
    uint64_t v12 = a4[1];
    if (v12)
    {

      MEMORY[0x2166B9890](v12, 0xE0C400670D255);
    }
    id v13 = v11;
    if (v13) {
      operator new();
    }
LABEL_20:

    a4[1] = 0;
LABEL_22:
  }
LABEL_23:

  id v7 = v16;
LABEL_24:
}

void sub_21542B984(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t cva::BufferTiled<unsigned int>::doResize(uint64_t result, uint64_t *a2)
{
  int v2 = *((_DWORD *)a2 + 2);
  uint64_t v3 = *a2;
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = v3;
  *(_DWORD *)(result + 24) = v2;
  return result;
}

void sub_21542BA30()
{
}

void cva::BufferTiled<cva::half>::allocTexture(_DWORD *a1, id *a2, char a3, void *a4)
{
  id v7 = *a2;
  if ((a3 & 1) == 0)
  {
    if (a4[1]) {
      goto LABEL_24;
    }
    id v16 = v7;
    if (*a4)
    {
      id v10 = *(id *)(*a4 + 8);
      if ([v10 pixelFormat] == 25) {
        goto LABEL_23;
      }
      uint64_t v14 = (void *)[v10 newTextureViewWithPixelFormat:25];
      uint64_t v15 = *a4;
      if (*a4)
      {

        MEMORY[0x2166B9890](v15, 0xE0C400670D255);
      }
      id v13 = v14;
      if (v13) {
        operator new();
      }
    }
    else
    {
      id v10 = [MEMORY[0x263F12A50] texture2DDescriptorWithPixelFormat:25 width:(a1[5] * a1[4]) height:a1[6] mipmapped:0];
      id v13 = (id)[v16 newTextureWithDescriptor:v10];
      if (v13) {
        operator new();
      }
    }

    *a4 = 0;
    goto LABEL_22;
  }
  unsigned int v8 = a1[4];
  if ((v8 & 3) != 0) {
    goto LABEL_24;
  }
  id v16 = v7;
  uint64_t v9 = a4[1];
  if (!v9)
  {
    id v10 = [MEMORY[0x263F12A50] texture2DDescriptorWithPixelFormat:115 width:a1[5] * (v8 >> 2) height:a1[6] mipmapped:0];
    id v13 = (id)[v16 newTextureWithDescriptor:v10];
    if (v13) {
      operator new();
    }
    goto LABEL_20;
  }
  id v10 = *(id *)(v9 + 8);
  if ([v10 pixelFormat] != 115)
  {
    uint64_t v11 = (void *)[v10 newTextureViewWithPixelFormat:115];
    uint64_t v12 = a4[1];
    if (v12)
    {

      MEMORY[0x2166B9890](v12, 0xE0C400670D255);
    }
    id v13 = v11;
    if (v13) {
      operator new();
    }
LABEL_20:

    a4[1] = 0;
LABEL_22:
  }
LABEL_23:

  id v7 = v16;
LABEL_24:
}

void sub_21542BCDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t cva::BufferTiled<cva::half>::doResize(uint64_t result, uint64_t *a2)
{
  int v2 = *((_DWORD *)a2 + 2);
  uint64_t v3 = *a2;
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = v3;
  *(_DWORD *)(result + 24) = v2;
  return result;
}

void sub_21542BD88()
{
}

uint64_t cva::Buffer<float>::texture(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = a3;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 24))(a1, a2, a3, a1 + 56);
  uint64_t v5 = 56;
  if (v3) {
    uint64_t v5 = 64;
  }
  return *(void *)(a1 + v5);
}

void cva::Buffer<float>::allocTexture(uint64_t a1, id *a2, char a3, void *a4)
{
  if (a3)
  {
    if ((*(unsigned char *)(a1 + 36) & 0xF) != 0) {
      return;
    }
    uint64_t v6 = a4[1];
    if (v6)
    {
      id v18 = *(id *)(v6 + 8);
      if ([v18 pixelFormat] != 125)
      {
        id v7 = (void *)[v18 newTextureViewWithPixelFormat:125];
        uint64_t v8 = a4[1];
        if (v8)
        {

          MEMORY[0x2166B9890](v8, 0xE0C400670D255);
        }
        if (v7) {
          operator new();
        }

        a4[1] = 0;
LABEL_25:

        goto LABEL_26;
      }
      goto LABEL_26;
    }
    int v13 = *(_DWORD *)(a1 + 16);
    int v14 = *(_DWORD *)(a1 + 20);
    size_t v15 = *(unsigned int *)(a1 + 24);
    CVMetalTextureRef image = 0;
    id v16 = *a2;
    sub_21542C1B0(v16);
    CVMetalTextureCacheCreateTextureFromImage((CFAllocatorRef)*MEMORY[0x263EFFB08], (CVMetalTextureCacheRef)qword_267869BB0, *(CVImageBufferRef *)(a1 + 48), 0, MTLPixelFormatRGBA32Float, (v14 * v13 + 3) >> 2, v15, 0, &image);

    int v17 = CVMetalTextureGetTexture(image);
    CFRelease(image);
    if (v17) {
      operator new();
    }

    a4[1] = 0;
LABEL_22:

    return;
  }
  if (!*a4)
  {
    CVMetalTextureRef image = 0;
    id v11 = *a2;
    sub_21542C1B0(v11);
    CVMetalTextureCacheCreateTextureFromImage((CFAllocatorRef)*MEMORY[0x263EFFB08], (CVMetalTextureCacheRef)qword_267869BB0, *(CVImageBufferRef *)(a1 + 48), 0, MTLPixelFormatR32Float, (*(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16)), *(unsigned int *)(a1 + 24), 0, &image);

    uint64_t v12 = CVMetalTextureGetTexture(image);
    CFRelease(image);
    if (v12) {
      operator new();
    }

    *a4 = 0;
    goto LABEL_22;
  }
  id v18 = *(id *)(*a4 + 8);
  if ([v18 pixelFormat] != 55)
  {
    uint64_t v9 = (void *)[v18 newTextureViewWithPixelFormat:55];
    uint64_t v10 = *a4;
    if (*a4)
    {

      MEMORY[0x2166B9890](v10, 0xE0C400670D255);
    }
    if (v9) {
      operator new();
    }

    *a4 = 0;
    goto LABEL_25;
  }
LABEL_26:
}

void sub_21542C150(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id a11)
{
  _Unwind_Resume(a1);
}

uint64_t sub_21542C1B0(void *a1)
{
  id v1 = a1;
  id v2 = v1;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_267869BB8, memory_order_acquire) & 1) == 0)
  {
    long long v4 = v1;
    id v1 = (id)__cxa_guard_acquire(&qword_267869BB8);
    id v2 = v4;
    if (v1)
    {
      sub_21542C274(v4);
      __cxa_atexit((void (*)(void *))sub_21542C308, &qword_267869BA8, &dword_2153B7000);
      __cxa_guard_release(&qword_267869BB8);
      id v2 = v4;
    }
  }
  return MEMORY[0x270F9A758](v1, v2);
}

void sub_21542C254(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_21542C274(void *a1)
{
  qword_267869BA8 = a1;
  qword_267869BB0 = 0;
  id v1 = (id)qword_267869BA8;
  CVMetalTextureCacheCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, (id)qword_267869BA8, 0, (CVMetalTextureCacheRef *)&qword_267869BB0);
}

void sub_21542C2E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v11 = v10;

  _Unwind_Resume(a1);
}

id *sub_21542C308(id *a1)
{
  return a1;
}

uint64_t cva::Buffer<unsigned short>::texture(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = a3;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 24))(a1, a2, a3, a1 + 56);
  uint64_t v5 = 56;
  if (v3) {
    uint64_t v5 = 64;
  }
  return *(void *)(a1 + v5);
}

void cva::Buffer<unsigned short>::allocTexture(uint64_t a1, id *a2, char a3, void *a4)
{
  if (a3)
  {
    if ((*(unsigned char *)(a1 + 36) & 7) != 0) {
      return;
    }
    uint64_t v6 = a4[1];
    if (v6)
    {
      id v18 = *(id *)(v6 + 8);
      if ([v18 pixelFormat] != 113)
      {
        id v7 = (void *)[v18 newTextureViewWithPixelFormat:113];
        uint64_t v8 = a4[1];
        if (v8)
        {

          MEMORY[0x2166B9890](v8, 0xE0C400670D255);
        }
        if (v7) {
          operator new();
        }

        a4[1] = 0;
LABEL_25:

        goto LABEL_26;
      }
      goto LABEL_26;
    }
    int v13 = *(_DWORD *)(a1 + 16);
    int v14 = *(_DWORD *)(a1 + 20);
    size_t v15 = *(unsigned int *)(a1 + 24);
    CVMetalTextureRef image = 0;
    id v16 = *a2;
    sub_21542C1B0(v16);
    CVMetalTextureCacheCreateTextureFromImage((CFAllocatorRef)*MEMORY[0x263EFFB08], (CVMetalTextureCacheRef)qword_267869BB0, *(CVImageBufferRef *)(a1 + 48), 0, MTLPixelFormatRGBA16Uint, (v14 * v13 + 3) >> 2, v15, 0, &image);

    int v17 = CVMetalTextureGetTexture(image);
    CFRelease(image);
    if (v17) {
      operator new();
    }

    a4[1] = 0;
LABEL_22:

    return;
  }
  if (!*a4)
  {
    CVMetalTextureRef image = 0;
    id v11 = *a2;
    sub_21542C1B0(v11);
    CVMetalTextureCacheCreateTextureFromImage((CFAllocatorRef)*MEMORY[0x263EFFB08], (CVMetalTextureCacheRef)qword_267869BB0, *(CVImageBufferRef *)(a1 + 48), 0, MTLPixelFormatR16Uint, (*(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16)), *(unsigned int *)(a1 + 24), 0, &image);

    uint64_t v12 = CVMetalTextureGetTexture(image);
    CFRelease(image);
    if (v12) {
      operator new();
    }

    *a4 = 0;
    goto LABEL_22;
  }
  id v18 = *(id *)(*a4 + 8);
  if ([v18 pixelFormat] != 23)
  {
    uint64_t v9 = (void *)[v18 newTextureViewWithPixelFormat:23];
    uint64_t v10 = *a4;
    if (*a4)
    {

      MEMORY[0x2166B9890](v10, 0xE0C400670D255);
    }
    if (v9) {
      operator new();
    }

    *a4 = 0;
    goto LABEL_25;
  }
LABEL_26:
}

void sub_21542C6C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id a11)
{
  _Unwind_Resume(a1);
}

uint64_t cva::Buffer<unsigned char>::texture(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = a3;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 24))(a1, a2, a3, a1 + 56);
  uint64_t v5 = 56;
  if (v3) {
    uint64_t v5 = 64;
  }
  return *(void *)(a1 + v5);
}

void cva::Buffer<unsigned char>::allocTexture(uint64_t a1, id *a2, char a3, void *a4)
{
  if (a3)
  {
    if ((*(unsigned char *)(a1 + 36) & 3) != 0) {
      return;
    }
    uint64_t v6 = a4[1];
    if (v6)
    {
      id v18 = *(id *)(v6 + 8);
      if ([v18 pixelFormat] != 73)
      {
        id v7 = (void *)[v18 newTextureViewWithPixelFormat:73];
        uint64_t v8 = a4[1];
        if (v8)
        {

          MEMORY[0x2166B9890](v8, 0xE0C400670D255);
        }
        if (v7) {
          operator new();
        }

        a4[1] = 0;
LABEL_25:

        goto LABEL_26;
      }
      goto LABEL_26;
    }
    int v13 = *(_DWORD *)(a1 + 16);
    int v14 = *(_DWORD *)(a1 + 20);
    size_t v15 = *(unsigned int *)(a1 + 24);
    CVMetalTextureRef image = 0;
    id v16 = *a2;
    sub_21542C1B0(v16);
    CVMetalTextureCacheCreateTextureFromImage((CFAllocatorRef)*MEMORY[0x263EFFB08], (CVMetalTextureCacheRef)qword_267869BB0, *(CVImageBufferRef *)(a1 + 48), 0, MTLPixelFormatRGBA8Uint, (v14 * v13 + 3) >> 2, v15, 0, &image);

    int v17 = CVMetalTextureGetTexture(image);
    CFRelease(image);
    if (v17) {
      operator new();
    }

    a4[1] = 0;
LABEL_22:

    return;
  }
  if (!*a4)
  {
    CVMetalTextureRef image = 0;
    id v11 = *a2;
    sub_21542C1B0(v11);
    CVMetalTextureCacheCreateTextureFromImage((CFAllocatorRef)*MEMORY[0x263EFFB08], (CVMetalTextureCacheRef)qword_267869BB0, *(CVImageBufferRef *)(a1 + 48), 0, MTLPixelFormatR8Uint, (*(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16)), *(unsigned int *)(a1 + 24), 0, &image);

    uint64_t v12 = CVMetalTextureGetTexture(image);
    CFRelease(image);
    if (v12) {
      operator new();
    }

    *a4 = 0;
    goto LABEL_22;
  }
  id v18 = *(id *)(*a4 + 8);
  if ([v18 pixelFormat] != 13)
  {
    uint64_t v9 = (void *)[v18 newTextureViewWithPixelFormat:13];
    uint64_t v10 = *a4;
    if (*a4)
    {

      MEMORY[0x2166B9890](v10, 0xE0C400670D255);
    }
    if (v9) {
      operator new();
    }

    *a4 = 0;
    goto LABEL_25;
  }
LABEL_26:
}

void sub_21542CAAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id a11)
{
  _Unwind_Resume(a1);
}

uint64_t cva::Buffer<unsigned int>::texture(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = a3;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 24))(a1, a2, a3, a1 + 56);
  uint64_t v5 = 56;
  if (v3) {
    uint64_t v5 = 64;
  }
  return *(void *)(a1 + v5);
}

void cva::Buffer<unsigned int>::allocTexture(uint64_t a1, id *a2, char a3, void *a4)
{
  if (a3)
  {
    if ((*(unsigned char *)(a1 + 36) & 0xF) != 0) {
      return;
    }
    uint64_t v6 = a4[1];
    if (v6)
    {
      id v18 = *(id *)(v6 + 8);
      if ([v18 pixelFormat] != 123)
      {
        id v7 = (void *)[v18 newTextureViewWithPixelFormat:123];
        uint64_t v8 = a4[1];
        if (v8)
        {

          MEMORY[0x2166B9890](v8, 0xE0C400670D255);
        }
        if (v7) {
          operator new();
        }

        a4[1] = 0;
LABEL_25:

        goto LABEL_26;
      }
      goto LABEL_26;
    }
    int v13 = *(_DWORD *)(a1 + 16);
    int v14 = *(_DWORD *)(a1 + 20);
    size_t v15 = *(unsigned int *)(a1 + 24);
    CVMetalTextureRef image = 0;
    id v16 = *a2;
    sub_21542C1B0(v16);
    CVMetalTextureCacheCreateTextureFromImage((CFAllocatorRef)*MEMORY[0x263EFFB08], (CVMetalTextureCacheRef)qword_267869BB0, *(CVImageBufferRef *)(a1 + 48), 0, MTLPixelFormatRGBA32Uint, (v14 * v13 + 3) >> 2, v15, 0, &image);

    int v17 = CVMetalTextureGetTexture(image);
    CFRelease(image);
    if (v17) {
      operator new();
    }

    a4[1] = 0;
LABEL_22:

    return;
  }
  if (!*a4)
  {
    CVMetalTextureRef image = 0;
    id v11 = *a2;
    sub_21542C1B0(v11);
    CVMetalTextureCacheCreateTextureFromImage((CFAllocatorRef)*MEMORY[0x263EFFB08], (CVMetalTextureCacheRef)qword_267869BB0, *(CVImageBufferRef *)(a1 + 48), 0, MTLPixelFormatR32Uint, (*(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16)), *(unsigned int *)(a1 + 24), 0, &image);

    uint64_t v12 = CVMetalTextureGetTexture(image);
    CFRelease(image);
    if (v12) {
      operator new();
    }

    *a4 = 0;
    goto LABEL_22;
  }
  id v18 = *(id *)(*a4 + 8);
  if ([v18 pixelFormat] != 53)
  {
    uint64_t v9 = (void *)[v18 newTextureViewWithPixelFormat:53];
    uint64_t v10 = *a4;
    if (*a4)
    {

      MEMORY[0x2166B9890](v10, 0xE0C400670D255);
    }
    if (v9) {
      operator new();
    }

    *a4 = 0;
    goto LABEL_25;
  }
LABEL_26:
}

void sub_21542CE98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id a11)
{
  _Unwind_Resume(a1);
}

uint64_t cva::Buffer<cva::half>::texture(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = a3;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 24))(a1, a2, a3, a1 + 56);
  uint64_t v5 = 56;
  if (v3) {
    uint64_t v5 = 64;
  }
  return *(void *)(a1 + v5);
}

void cva::Buffer<cva::half>::allocTexture(uint64_t a1, id *a2, char a3, void *a4)
{
  if (a3)
  {
    if ((*(unsigned char *)(a1 + 36) & 7) != 0) {
      return;
    }
    uint64_t v6 = a4[1];
    if (v6)
    {
      id v18 = *(id *)(v6 + 8);
      if ([v18 pixelFormat] != 115)
      {
        id v7 = (void *)[v18 newTextureViewWithPixelFormat:115];
        uint64_t v8 = a4[1];
        if (v8)
        {

          MEMORY[0x2166B9890](v8, 0xE0C400670D255);
        }
        if (v7) {
          operator new();
        }

        a4[1] = 0;
LABEL_25:

        goto LABEL_26;
      }
      goto LABEL_26;
    }
    int v13 = *(_DWORD *)(a1 + 16);
    int v14 = *(_DWORD *)(a1 + 20);
    size_t v15 = *(unsigned int *)(a1 + 24);
    CVMetalTextureRef image = 0;
    id v16 = *a2;
    sub_21542C1B0(v16);
    CVMetalTextureCacheCreateTextureFromImage((CFAllocatorRef)*MEMORY[0x263EFFB08], (CVMetalTextureCacheRef)qword_267869BB0, *(CVImageBufferRef *)(a1 + 48), 0, MTLPixelFormatRGBA16Float, (v14 * v13 + 3) >> 2, v15, 0, &image);

    int v17 = CVMetalTextureGetTexture(image);
    CFRelease(image);
    if (v17) {
      operator new();
    }

    a4[1] = 0;
LABEL_22:

    return;
  }
  if (!*a4)
  {
    CVMetalTextureRef image = 0;
    id v11 = *a2;
    sub_21542C1B0(v11);
    CVMetalTextureCacheCreateTextureFromImage((CFAllocatorRef)*MEMORY[0x263EFFB08], (CVMetalTextureCacheRef)qword_267869BB0, *(CVImageBufferRef *)(a1 + 48), 0, MTLPixelFormatR16Float, (*(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16)), *(unsigned int *)(a1 + 24), 0, &image);

    uint64_t v12 = CVMetalTextureGetTexture(image);
    CFRelease(image);
    if (v12) {
      operator new();
    }

    *a4 = 0;
    goto LABEL_22;
  }
  id v18 = *(id *)(*a4 + 8);
  if ([v18 pixelFormat] != 25)
  {
    uint64_t v9 = (void *)[v18 newTextureViewWithPixelFormat:25];
    uint64_t v10 = *a4;
    if (*a4)
    {

      MEMORY[0x2166B9890](v10, 0xE0C400670D255);
    }
    if (v9) {
      operator new();
    }

    *a4 = 0;
    goto LABEL_25;
  }
LABEL_26:
}

void sub_21542D284(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id a11)
{
  _Unwind_Resume(a1);
}

double cva::BufferTiled<float>::BufferTiled(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)a1 = &unk_26C5FB3A8;
  return result;
}

{
  double result;

  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)a1 = &unk_26C5FB3A8;
  return result;
}

double cva::BufferTiled<float>::BufferTiled(uint64_t a1, uint64_t *a2)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)a1 = &unk_26C5FB3A8;
  int v3 = *((_DWORD *)a2 + 2);
  uint64_t v4 = *a2;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = v4;
  *(_DWORD *)(a1 + 24) = v3;
  return result;
}

{
  double result;
  int v3;
  uint64_t v4;

  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)a1 = &unk_26C5FB3A8;
  int v3 = *((_DWORD *)a2 + 2);
  uint64_t v4 = *a2;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = v4;
  *(_DWORD *)(a1 + 24) = v3;
  return result;
}

uint64_t cva::BufferTiled<float>::BufferTiled(uint64_t result, int a2, int a3, int a4)
{
  *(void *)(result + 36) = 0;
  *(void *)(result + 28) = 0;
  *(_DWORD *)(result + 44) = 0;
  *(void *)(result + 56) = 0;
  *(void *)(result + 64) = 0;
  *(void *)(result + 48) = 0;
  *(void *)double result = &unk_26C5FB3A8;
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = a2;
  *(_DWORD *)(result + 20) = a3;
  *(_DWORD *)(result + 24) = a4;
  return result;
}

{
  *(void *)(result + 36) = 0;
  *(void *)(result + 28) = 0;
  *(_DWORD *)(result + 44) = 0;
  *(void *)(result + 56) = 0;
  *(void *)(result + 64) = 0;
  *(void *)(result + 48) = 0;
  *(void *)double result = &unk_26C5FB3A8;
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = a2;
  *(_DWORD *)(result + 20) = a3;
  *(_DWORD *)(result + 24) = a4;
  return result;
}

double cva::BufferTiled<unsigned short>::BufferTiled(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)a1 = &unk_26C5FB438;
  return result;
}

{
  double result;

  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)a1 = &unk_26C5FB438;
  return result;
}

double cva::BufferTiled<unsigned short>::BufferTiled(uint64_t a1, uint64_t *a2)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)a1 = &unk_26C5FB438;
  int v3 = *((_DWORD *)a2 + 2);
  uint64_t v4 = *a2;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = v4;
  *(_DWORD *)(a1 + 24) = v3;
  return result;
}

{
  double result;
  int v3;
  uint64_t v4;

  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)a1 = &unk_26C5FB438;
  int v3 = *((_DWORD *)a2 + 2);
  uint64_t v4 = *a2;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = v4;
  *(_DWORD *)(a1 + 24) = v3;
  return result;
}

uint64_t cva::BufferTiled<unsigned short>::BufferTiled(uint64_t result, int a2, int a3, int a4)
{
  *(void *)(result + 36) = 0;
  *(void *)(result + 28) = 0;
  *(_DWORD *)(result + 44) = 0;
  *(void *)(result + 56) = 0;
  *(void *)(result + 64) = 0;
  *(void *)(result + 48) = 0;
  *(void *)double result = &unk_26C5FB438;
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = a2;
  *(_DWORD *)(result + 20) = a3;
  *(_DWORD *)(result + 24) = a4;
  return result;
}

{
  *(void *)(result + 36) = 0;
  *(void *)(result + 28) = 0;
  *(_DWORD *)(result + 44) = 0;
  *(void *)(result + 56) = 0;
  *(void *)(result + 64) = 0;
  *(void *)(result + 48) = 0;
  *(void *)double result = &unk_26C5FB438;
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = a2;
  *(_DWORD *)(result + 20) = a3;
  *(_DWORD *)(result + 24) = a4;
  return result;
}

double cva::BufferTiled<unsigned char>::BufferTiled(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)a1 = &unk_26C5FB3D8;
  return result;
}

{
  double result;

  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)a1 = &unk_26C5FB3D8;
  return result;
}

double cva::BufferTiled<unsigned char>::BufferTiled(uint64_t a1, uint64_t *a2)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)a1 = &unk_26C5FB3D8;
  int v3 = *((_DWORD *)a2 + 2);
  uint64_t v4 = *a2;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = v4;
  *(_DWORD *)(a1 + 24) = v3;
  return result;
}

{
  double result;
  int v3;
  uint64_t v4;

  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)a1 = &unk_26C5FB3D8;
  int v3 = *((_DWORD *)a2 + 2);
  uint64_t v4 = *a2;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = v4;
  *(_DWORD *)(a1 + 24) = v3;
  return result;
}

uint64_t cva::BufferTiled<unsigned char>::BufferTiled(uint64_t result, int a2, int a3, int a4)
{
  *(void *)(result + 36) = 0;
  *(void *)(result + 28) = 0;
  *(_DWORD *)(result + 44) = 0;
  *(void *)(result + 56) = 0;
  *(void *)(result + 64) = 0;
  *(void *)(result + 48) = 0;
  *(void *)double result = &unk_26C5FB3D8;
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = a2;
  *(_DWORD *)(result + 20) = a3;
  *(_DWORD *)(result + 24) = a4;
  return result;
}

{
  *(void *)(result + 36) = 0;
  *(void *)(result + 28) = 0;
  *(_DWORD *)(result + 44) = 0;
  *(void *)(result + 56) = 0;
  *(void *)(result + 64) = 0;
  *(void *)(result + 48) = 0;
  *(void *)double result = &unk_26C5FB3D8;
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = a2;
  *(_DWORD *)(result + 20) = a3;
  *(_DWORD *)(result + 24) = a4;
  return result;
}

double cva::BufferTiled<unsigned int>::BufferTiled(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)a1 = &unk_26C5FB408;
  return result;
}

{
  double result;

  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)a1 = &unk_26C5FB408;
  return result;
}

double cva::BufferTiled<unsigned int>::BufferTiled(uint64_t a1, uint64_t *a2)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)a1 = &unk_26C5FB408;
  int v3 = *((_DWORD *)a2 + 2);
  uint64_t v4 = *a2;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = v4;
  *(_DWORD *)(a1 + 24) = v3;
  return result;
}

{
  double result;
  int v3;
  uint64_t v4;

  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)a1 = &unk_26C5FB408;
  int v3 = *((_DWORD *)a2 + 2);
  uint64_t v4 = *a2;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = v4;
  *(_DWORD *)(a1 + 24) = v3;
  return result;
}

uint64_t cva::BufferTiled<unsigned int>::BufferTiled(uint64_t result, int a2, int a3, int a4)
{
  *(void *)(result + 36) = 0;
  *(void *)(result + 28) = 0;
  *(_DWORD *)(result + 44) = 0;
  *(void *)(result + 56) = 0;
  *(void *)(result + 64) = 0;
  *(void *)(result + 48) = 0;
  *(void *)double result = &unk_26C5FB408;
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = a2;
  *(_DWORD *)(result + 20) = a3;
  *(_DWORD *)(result + 24) = a4;
  return result;
}

{
  *(void *)(result + 36) = 0;
  *(void *)(result + 28) = 0;
  *(_DWORD *)(result + 44) = 0;
  *(void *)(result + 56) = 0;
  *(void *)(result + 64) = 0;
  *(void *)(result + 48) = 0;
  *(void *)double result = &unk_26C5FB408;
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = a2;
  *(_DWORD *)(result + 20) = a3;
  *(_DWORD *)(result + 24) = a4;
  return result;
}

double cva::BufferTiled<cva::half>::BufferTiled(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)a1 = &unk_26C5FB378;
  return result;
}

{
  double result;

  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)a1 = &unk_26C5FB378;
  return result;
}

double cva::BufferTiled<cva::half>::BufferTiled(uint64_t a1, uint64_t *a2)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)a1 = &unk_26C5FB378;
  int v3 = *((_DWORD *)a2 + 2);
  uint64_t v4 = *a2;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = v4;
  *(_DWORD *)(a1 + 24) = v3;
  return result;
}

{
  double result;
  int v3;
  uint64_t v4;

  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)a1 = &unk_26C5FB378;
  int v3 = *((_DWORD *)a2 + 2);
  uint64_t v4 = *a2;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = v4;
  *(_DWORD *)(a1 + 24) = v3;
  return result;
}

uint64_t cva::BufferTiled<cva::half>::BufferTiled(uint64_t result, int a2, int a3, int a4)
{
  *(void *)(result + 36) = 0;
  *(void *)(result + 28) = 0;
  *(_DWORD *)(result + 44) = 0;
  *(void *)(result + 56) = 0;
  *(void *)(result + 64) = 0;
  *(void *)(result + 48) = 0;
  *(void *)double result = &unk_26C5FB378;
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = a2;
  *(_DWORD *)(result + 20) = a3;
  *(_DWORD *)(result + 24) = a4;
  return result;
}

{
  *(void *)(result + 36) = 0;
  *(void *)(result + 28) = 0;
  *(_DWORD *)(result + 44) = 0;
  *(void *)(result + 56) = 0;
  *(void *)(result + 64) = 0;
  *(void *)(result + 48) = 0;
  *(void *)double result = &unk_26C5FB378;
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = a2;
  *(_DWORD *)(result + 20) = a3;
  *(_DWORD *)(result + 24) = a4;
  return result;
}

void *cva::adp::io::PListSerializer::PListSerializer(void *this)
{
  *this = 0;
  this[1] = 0;
  return this;
}

{
  *this = 0;
  this[1] = 0;
  return this;
}

void cva::adp::io::PListSerializer::~PListSerializer(cva::adp::io::PListSerializer *this)
{
  id v2 = (std::__shared_weak_count *)*((void *)this + 1);
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  if (v2)
  {
    if (!atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
    int v3 = (std::__shared_weak_count *)*((void *)this + 1);
    if (v3)
    {
      if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
    }
  }
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;

  id v2 = (std::__shared_weak_count *)*((void *)this + 1);
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  if (v2)
  {
    if (!atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
    int v3 = (std::__shared_weak_count *)*((void *)this + 1);
    if (v3)
    {
      if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
    }
  }
}

void cva::adp::io::PListSerializer::clear(cva::adp::io::PListSerializer *this)
{
  id v1 = (std::__shared_weak_count *)*((void *)this + 1);
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

void cva::adp::io::PListSerializer::create(cva::adp::io::PListSerializer *this)
{
  id v1 = (std::__shared_weak_count *)*((void *)this + 1);
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  if (v1)
  {
    if (!atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
  operator new();
}

uint64_t sub_21542DFA8(uint64_t result)
{
  id v1 = *(CFTypeRef **)(result + 24);
  if (v1)
  {
    if (*v1) {
      CFRelease(*v1);
    }
    JUMPOUT(0x2166B9890);
  }
  return result;
}

void sub_21542E008(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2166B9890);
}

BOOL cva::adp::io::PListSerializer::isValid(cva::adp::io::PListSerializer *this)
{
  return *(void *)this != 0;
}

BOOL cva::adp::io::PListSerializer::read(void *a1, uint64_t *a2)
{
  uint64_t v4 = (std::__shared_weak_count *)a1[1];
  *a1 = 0;
  a1[1] = 0;
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  cva::DictionaryHandler::readPlistFile(a2, &v9);
  long long v5 = v9;
  long long v9 = 0uLL;
  uint64_t v6 = (std::__shared_weak_count *)a1[1];
  *(_OWORD *)a1 = v5;
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
    id v7 = (std::__shared_weak_count *)*((void *)&v9 + 1);
    if (!*((void *)&v9 + 1)) {
      return *a1 != 0;
    }
  }
  else
  {
    id v7 = (std::__shared_weak_count *)*((void *)&v9 + 1);
    if (!*((void *)&v9 + 1)) {
      return *a1 != 0;
    }
  }
  if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  return *a1 != 0;
}

id *cva::adp::io::PListSerializer::write(id **a1, uint64_t *a2)
{
  double result = *a1;
  if (result) {
    return (id *)cva::DictionaryHandler::writePlistFile(result, a2);
  }
  return result;
}

BOOL cva::adp::io::processFullPath(std::string *__str, std::string *this)
{
  unsigned int v3 = HIBYTE(__str->__r_.__value_.__r.__words[2]);
  if (SHIBYTE(__str->__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::size_type size = __str->__r_.__value_.__l.__size_;
    if (size < 2)
    {
      if (!size) {
        return 0;
      }
      uint64_t v4 = (std::string *)__str->__r_.__value_.__r.__words[0];
LABEL_8:
      if (v4->__r_.__value_.__s.__data_[0] == 47)
      {
        std::string::operator=(this, __str);
        return 1;
      }
      return 0;
    }
    id v7 = (std::string *)__str->__r_.__value_.__r.__words[0];
  }
  else
  {
    if (v3 < 2)
    {
      uint64_t v4 = __str;
      if (!*((unsigned char *)&__str->__r_.__value_.__s + 23)) {
        return 0;
      }
      goto LABEL_8;
    }
    id v7 = __str;
    std::string::size_type size = HIBYTE(__str->__r_.__value_.__r.__words[2]);
  }
  uint64_t v8 = (std::string *)((char *)v7 + size);
  for (unint64_t i = v7; i->__r_.__value_.__s.__data_[0] != 47; unint64_t i = (std::string *)((char *)i + 1))
  {
    if (!--size) {
      return 0;
    }
  }
  if (i == v8 || (char *)i - (char *)v7 == -1) {
    return 0;
  }
  std::string::size_type v10 = i == v7;
  uint64_t v12 = (std::string *)__str->__r_.__value_.__r.__words[0];
  std::string::size_type v11 = __str->__r_.__value_.__l.__size_;
  int v13 = (v3 & 0x80u) == 0 ? __str : (std::string *)__str->__r_.__value_.__r.__words[0];
  std::string::size_type v14 = (v3 & 0x80u) == 0 ? HIBYTE(__str->__r_.__value_.__r.__words[2]) : __str->__r_.__value_.__l.__size_;
  do
  {
    if (!v14) {
      return 0;
    }
    int v15 = v13->__r_.__value_.__s.__data_[--v14];
  }
  while (v15 != 47);
  std::string::size_type v16 = v14;
  if (v14 + 1 < 2) {
    return 0;
  }
  if ((v3 & 0x80) != 0)
  {
    if (v11 < v10) {
      goto LABEL_46;
    }
  }
  else
  {
    std::string::size_type v11 = HIBYTE(__str->__r_.__value_.__r.__words[2]);
    uint64_t v12 = __str;
    if (v10 > v11) {
      goto LABEL_46;
    }
  }
  if (v11 - v10 >= v14) {
    size_t v17 = v14;
  }
  else {
    size_t v17 = v11 - v10;
  }
  if (v17 >= 0x7FFFFFFFFFFFFFF8) {
LABEL_46:
  }
    abort();
  if (v17 >= 0x17)
  {
    uint64_t v19 = (v17 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v17 | 7) != 0x17) {
      uint64_t v19 = v17 | 7;
    }
    uint64_t v20 = v19 + 1;
    p_dst = (long long *)operator new(v19 + 1);
    *((void *)&__dst + 1) = v17;
    unint64_t v22 = v20 | 0x8000000000000000;
    *(void *)&long long __dst = p_dst;
  }
  else
  {
    HIBYTE(v22) = v17;
    p_dst = &__dst;
    if (!v17) {
      goto LABEL_43;
    }
  }
  memmove(p_dst, (char *)v12 + v10, v17);
LABEL_43:
  *((unsigned char *)p_dst + v17) = 0;
  if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0) {
    operator delete(this->__r_.__value_.__l.__data_);
  }
  *(_OWORD *)&this->__r_.__value_.__l.__data_ = __dst;
  this->__r_.__value_.__r.__words[2] = v22;
  return v10 != v16;
}

BOOL cva::adp::io::PListSerializer::decomposePath(int a1, std::string *__str, uint64_t a3)
{
  memset(&v29, 0, sizeof(v29));
  BOOL v4 = cva::adp::io::processFullPath(__str, &v29);
  BOOL v5 = v4;
  if (v4)
  {
    BOOL v19 = v4;
    long long v27 = 0uLL;
    uint64_t v28 = 0;
    uint64_t v18 = MEMORY[0x263F8C328] + 24;
    uint64_t v6 = MEMORY[0x263F8C328] + 104;
    v26[0] = MEMORY[0x263F8C328] + 104;
    uint64_t v7 = MEMORY[0x263F8C328] + 64;
    uint64_t v21 = MEMORY[0x263F8C328] + 64;
    uint64_t v8 = (void *)MEMORY[0x263F8C2B8];
    uint64_t v9 = *(void *)(MEMORY[0x263F8C2B8] + 24);
    v20[0] = *(void *)(MEMORY[0x263F8C2B8] + 16);
    *(void *)((char *)v20 + *(void *)(v20[0] - 24)) = v9;
    v20[1] = 0;
    std::string::size_type v10 = (std::ios_base *)((char *)v20 + *(void *)(v20[0] - 24));
    std::ios_base::init(v10, v22);
    v10[1].__vftable = 0;
    v10[1].__fmtflags_ = -1;
    uint64_t v11 = v8[5];
    uint64_t v21 = v8[4];
    *(void *)((char *)&v22[-1] + *(void *)(v21 - 24)) = v11;
    v20[0] = v8[1];
    *(void *)((char *)v20 + *(void *)(v20[0] - 24)) = v8[6];
    v26[0] = v6;
    v20[0] = v18;
    uint64_t v21 = v7;
    std::streambuf::basic_streambuf();
    uint64_t v12 = MEMORY[0x263F8C318] + 16;
    v22[0] = MEMORY[0x263F8C318] + 16;
    *(_OWORD *)std::string __p = 0u;
    long long v24 = 0u;
    int v25 = 24;
    std::stringbuf::str();
    while (1)
    {
      sub_2153CF138(v20, (uint64_t)&v27, 0x2Fu);
      if ((*((unsigned char *)&v22[1] + *(void *)(v20[0] - 24)) & 5) != 0) {
        break;
      }
      uint64_t v13 = HIBYTE(v28);
      if (v28 < 0) {
        uint64_t v13 = *((void *)&v27 + 1);
      }
      if (v13)
      {
        unint64_t v14 = *(void *)(a3 + 8);
        if (v14 >= *(void *)(a3 + 16))
        {
          *(void *)(a3 + 8) = sub_21541857C(a3, (uint64_t)&v27);
        }
        else
        {
          if (SHIBYTE(v28) < 0)
          {
            sub_2153C0AE4(*(unsigned char **)(a3 + 8), (void *)v27, *((unint64_t *)&v27 + 1));
          }
          else
          {
            long long v15 = v27;
            *(void *)(v14 + 16) = v28;
            *(_OWORD *)unint64_t v14 = v15;
          }
          *(void *)(a3 + 8) = v14 + 24;
        }
      }
    }
    v20[0] = *v8;
    uint64_t v16 = v8[9];
    *(void *)((char *)v20 + *(void *)(v20[0] - 24)) = v8[8];
    uint64_t v21 = v16;
    v22[0] = v12;
    if (SBYTE7(v24) < 0) {
      operator delete(__p[0]);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2166B9860](v26);
    BOOL v5 = v19;
    if (SHIBYTE(v28) < 0)
    {
      operator delete((void *)v27);
      if ((SHIBYTE(v29.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        return v5;
      }
      goto LABEL_17;
    }
  }
  if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
LABEL_17:
  }
    operator delete(v29.__r_.__value_.__l.__data_);
  return v5;
}

void cva::adp::io::PListSerializer::createPath(cva::adp::io::PListSerializer *this@<X0>, std::string *__str@<X1>, void *a3@<X8>)
{
  if (!*(void *)this) {
    cva::adp::io::PListSerializer::create(this);
  }
  std::string __p = 0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  if (cva::adp::io::PListSerializer::decomposePath((int)this, __str, (uint64_t)&__p))
  {
    cva::adp::io::PListSerializer::createPath((uint64_t *)&__p, (uint64_t *)this, a3);
    BOOL v5 = (void **)__p;
    if (!__p) {
      return;
    }
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
    BOOL v5 = (void **)__p;
    if (!__p) {
      return;
    }
  }
  for (unint64_t i = v8; i != v5; i -= 3)
  {
    if (*((char *)i - 1) < 0) {
      operator delete(*(i - 3));
    }
  }
  operator delete(v5);
}

void cva::adp::io::PListSerializer::createPath(uint64_t *a1@<X1>, uint64_t *a2@<X2>, void *a3@<X8>)
{
  uint64_t v3 = *a2;
  BOOL v4 = (std::__shared_weak_count *)a2[1];
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *a1;
  uint64_t v6 = a1[1];
  if (*a1 != v6)
  {
    CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x263EFFB28];
    while (1)
    {
      if (*(char *)(v5 + 23) >= 0) {
        uint64_t v9 = (const char *)v5;
      }
      else {
        uint64_t v9 = *(const char **)v5;
      }
      CFStringRef v10 = CFStringCreateWithCStringNoCopy(v7, v9, 0x8000100u, v8);
      uint64_t v11 = [*(id *)v3 valueForKey:v10];

      CFRelease(v10);
      if (!v11)
      {
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v7, 0, MEMORY[0x263EFFB78], MEMORY[0x263EFFF90]);
        CFMutableDictionaryRef v13 = Mutable;
        if (Mutable) {
          CFRetain(Mutable);
        }
        if (*(char *)(v5 + 23) >= 0) {
          unint64_t v14 = (const char *)v5;
        }
        else {
          unint64_t v14 = *(const char **)v5;
        }
        CFStringRef v15 = CFStringCreateWithCStringNoCopy(v7, v14, 0x8000100u, v8);
        int v16 = *(unsigned __int8 *)(v3 + 8);
        if (*(unsigned char *)(v3 + 8)) {
          [*(id *)v3 setValue:v13 forKey:v15];
        }
        CFRelease(v15);
        if (v13)
        {
          CFRelease(v13);
          CFRelease(v13);
        }
        if (!v16)
        {
          *a3 = 0;
          a3[1] = 0;
          if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
            std::__shared_weak_count::__release_weak(v4);
          }
          return;
        }
      }
      if (*(char *)(v5 + 23) >= 0) {
        size_t v17 = (const char *)v5;
      }
      else {
        size_t v17 = *(const char **)v5;
      }
      CFStringRef v18 = CFStringCreateWithCStringNoCopy(v7, v17, 0x8000100u, v8);
      BOOL v19 = (const void *)[*(id *)v3 objectForKey:v18];
      char v20 = *(unsigned char *)(v3 + 8);
      CFTypeRef cf = v19;
      char v25 = v20;
      if (v19) {
        CFRetain(v19);
      }
      else {
        char v25 = 0;
      }
      CFRelease(v18);
      cva::ItemHandler::getDictionary((uint64_t)&cf, &v26);
      uint64_t v3 = v26;
      uint64_t v21 = v27;
      uint64_t v26 = 0;
      long long v27 = 0;
      if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
        unint64_t v22 = v27;
        if (v27)
        {
LABEL_29:
          if (!atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
            std::__shared_weak_count::__release_weak(v22);
          }
        }
      }
      else
      {
        unint64_t v22 = v27;
        if (v27) {
          goto LABEL_29;
        }
      }
      if (cf) {
        CFRelease(cf);
      }
      v5 += 24;
      BOOL v4 = v21;
      if (v5 == v6) {
        goto LABEL_35;
      }
    }
  }
  uint64_t v21 = v4;
LABEL_35:
  *a3 = v3;
  a3[1] = v21;
}

void sub_21542EC10(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t cva::adp::io::PListSerializer::hasPath(std::string::size_type *a1, std::string *a2)
{
  if (!*a1) {
    return 0;
  }
  std::string __p = 0;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  BOOL v3 = cva::adp::io::PListSerializer::decomposePath((int)a1, a2, (uint64_t)&__p);
  if (v3)
  {
    uint64_t hasPath = cva::adp::io::PListSerializer::hasPath(v3, (uint64_t *)&__p, a1);
    uint64_t v5 = (void **)__p;
    if (!__p) {
      return hasPath;
    }
  }
  else
  {
    uint64_t hasPath = 0;
    uint64_t v5 = (void **)__p;
    if (!__p) {
      return hasPath;
    }
  }
  for (unint64_t i = v9; i != v5; i -= 3)
  {
    if (*((char *)i - 1) < 0) {
      operator delete(*(i - 3));
    }
  }
  operator delete(v5);
  return hasPath;
}

uint64_t cva::adp::io::PListSerializer::hasPath(uint64_t a1, uint64_t *a2, std::string::size_type *a3)
{
  std::string::size_type v5 = *a3;
  BOOL v4 = (std::__shared_weak_count *)a3[1];
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  if (*a2 == v7)
  {
    uint64_t v19 = 1;
    if (v4) {
      goto LABEL_42;
    }
    return v19;
  }
  CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x263EFFB28];
  while (1)
  {
    uint64_t v10 = *(char *)(v6 + 23) >= 0 ? (const char *)v6 : *(const char **)v6;
    CFStringRef v11 = CFStringCreateWithCStringNoCopy(v8, v10, 0x8000100u, v9);
    uint64_t v12 = [*(id *)v5 valueForKey:v11];

    CFRelease(v11);
    if (!v12) {
      break;
    }
    if (*(char *)(v6 + 23) >= 0) {
      CFMutableDictionaryRef v13 = (const char *)v6;
    }
    else {
      CFMutableDictionaryRef v13 = *(const char **)v6;
    }
    CFStringRef v14 = CFStringCreateWithCStringNoCopy(v8, v13, 0x8000100u, v9);
    CFStringRef v15 = (const void *)[*(id *)v5 objectForKey:v14];
    char v16 = *(unsigned char *)(v5 + 8);
    CFTypeRef cf = v15;
    LOBYTE(v26) = v16;
    if (v15) {
      CFRetain(v15);
    }
    else {
      LOBYTE(v26) = 0;
    }
    CFRelease(v14);
    cva::ItemHandler::getDictionary((uint64_t)&cf, &v28);
    std::string::size_type size = v28.__r_.__value_.__l.__size_;
    std::string::size_type v5 = v28.__r_.__value_.__r.__words[0];
    *(_OWORD *)&v28.__r_.__value_.__l.__data_ = 0uLL;
    if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
      CFStringRef v18 = (std::__shared_weak_count *)v28.__r_.__value_.__l.__size_;
      if (v28.__r_.__value_.__l.__size_)
      {
LABEL_19:
        if (!atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
          std::__shared_weak_count::__release_weak(v18);
        }
      }
    }
    else
    {
      CFStringRef v18 = (std::__shared_weak_count *)v28.__r_.__value_.__l.__size_;
      if (v28.__r_.__value_.__l.__size_) {
        goto LABEL_19;
      }
    }
    if (cf) {
      CFRelease(cf);
    }
    v6 += 24;
    BOOL v4 = (std::__shared_weak_count *)size;
    if (v6 == v7)
    {
      uint64_t v19 = 1;
      BOOL v4 = (std::__shared_weak_count *)size;
      if (size) {
        goto LABEL_42;
      }
      return v19;
    }
  }
  memset(&v28, 0, sizeof(v28));
  uint64_t v20 = *a2;
  uint64_t v21 = a2[1];
  if (*a2 != v21)
  {
    do
    {
      std::operator+<char>();
      if ((v27 & 0x80u) == 0) {
        p_CFTypeRef cf = (const std::string::value_type *)&cf;
      }
      else {
        p_CFTypeRef cf = (const std::string::value_type *)cf;
      }
      if ((v27 & 0x80u) == 0) {
        std::string::size_type v23 = v27;
      }
      else {
        std::string::size_type v23 = v26;
      }
      std::string::append(&v28, p_cf, v23);
      if ((char)v27 < 0) {
        operator delete((void *)cf);
      }
      v20 += 24;
    }
    while (v20 != v21);
    if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v28.__r_.__value_.__l.__data_);
    }
  }
  uint64_t v19 = 0;
  if (!v4) {
    return v19;
  }
LABEL_42:
  if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  return v19;
}

void sub_21542EFB8(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

void cva::adp::io::PListSerializer::getPath(std::string::size_type *a1@<X0>, std::string *a2@<X1>, std::string::size_type *a3@<X8>)
{
  if (!*a1)
  {
    *a3 = 0;
    a3[1] = 0;
    return;
  }
  std::string __p = 0;
  CFAllocatorRef v8 = 0;
  uint64_t v9 = 0;
  if (cva::adp::io::PListSerializer::decomposePath((int)a1, a2, (uint64_t)&__p))
  {
    cva::adp::io::PListSerializer::getPath((uint64_t *)&__p, a1, a3);
    std::string::size_type v5 = (void **)__p;
    if (!__p) {
      return;
    }
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
    std::string::size_type v5 = (void **)__p;
    if (!__p) {
      return;
    }
  }
  for (unint64_t i = v8; i != v5; i -= 3)
  {
    if (*((char *)i - 1) < 0) {
      operator delete(*(i - 3));
    }
  }
  operator delete(v5);
}

{
  void **v5;
  void **i;
  void *__p;
  void **v8;
  uint64_t v9;
  uint64_t vars8;

  if (!*a1)
  {
    *a3 = 0;
    a3[1] = 0;
    return;
  }
  std::string __p = 0;
  CFAllocatorRef v8 = 0;
  uint64_t v9 = 0;
  if (cva::adp::io::PListSerializer::decomposePath((int)a1, a2, (uint64_t)&__p))
  {
    cva::adp::io::PListSerializer::getPath((uint64_t *)&__p, a1, a3);
    std::string::size_type v5 = (void **)__p;
    if (!__p) {
      return;
    }
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
    std::string::size_type v5 = (void **)__p;
    if (!__p) {
      return;
    }
  }
  for (unint64_t i = v8; i != v5; i -= 3)
  {
    if (*((char *)i - 1) < 0) {
      operator delete(*(i - 3));
    }
  }
  operator delete(v5);
}

void cva::adp::io::PListSerializer::getPath(uint64_t *a1@<X1>, std::string::size_type *a2@<X2>, std::string::size_type *a3@<X8>)
{
  std::string::size_type v5 = *a2;
  BOOL v4 = (std::__shared_weak_count *)a2[1];
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = *a1;
  uint64_t v7 = a1[1];
  if (*a1 != v7)
  {
    CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x263EFFB28];
    while (1)
    {
      if (*(char *)(v6 + 23) >= 0) {
        uint64_t v10 = (const char *)v6;
      }
      else {
        uint64_t v10 = *(const char **)v6;
      }
      CFStringRef v11 = CFStringCreateWithCStringNoCopy(v8, v10, 0x8000100u, v9);
      uint64_t v12 = [*(id *)v5 valueForKey:v11];

      CFRelease(v11);
      if (!v12)
      {
        memset(&v28, 0, sizeof(v28));
        uint64_t v20 = *a1;
        uint64_t v19 = a1[1];
        if (*a1 == v19)
        {
          *a3 = 0;
          a3[1] = 0;
        }
        else
        {
          do
          {
            std::operator+<char>();
            if ((v27 & 0x80u) == 0) {
              p_CFTypeRef cf = (const std::string::value_type *)&cf;
            }
            else {
              p_CFTypeRef cf = (const std::string::value_type *)cf;
            }
            if ((v27 & 0x80u) == 0) {
              std::string::size_type v22 = v27;
            }
            else {
              std::string::size_type v22 = v26;
            }
            std::string::append(&v28, p_cf, v22);
            if ((char)v27 < 0) {
              operator delete((void *)cf);
            }
            v20 += 24;
          }
          while (v20 != v19);
          int v23 = SHIBYTE(v28.__r_.__value_.__r.__words[2]);
          *a3 = 0;
          a3[1] = 0;
          if (v23 < 0) {
            operator delete(v28.__r_.__value_.__l.__data_);
          }
        }
        if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
          std::__shared_weak_count::__release_weak(v4);
        }
        return;
      }
      if (*(char *)(v6 + 23) >= 0) {
        CFMutableDictionaryRef v13 = (const char *)v6;
      }
      else {
        CFMutableDictionaryRef v13 = *(const char **)v6;
      }
      CFStringRef v14 = CFStringCreateWithCStringNoCopy(v8, v13, 0x8000100u, v9);
      CFStringRef v15 = (const void *)[*(id *)v5 objectForKey:v14];
      char v16 = *(unsigned char *)(v5 + 8);
      CFTypeRef cf = v15;
      LOBYTE(v26) = v16;
      if (v15) {
        CFRetain(v15);
      }
      else {
        LOBYTE(v26) = 0;
      }
      CFRelease(v14);
      cva::ItemHandler::getDictionary((uint64_t)&cf, &v28);
      std::string::size_type size = v28.__r_.__value_.__l.__size_;
      std::string::size_type v5 = v28.__r_.__value_.__r.__words[0];
      *(_OWORD *)&v28.__r_.__value_.__l.__data_ = 0uLL;
      if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
        CFStringRef v18 = (std::__shared_weak_count *)v28.__r_.__value_.__l.__size_;
        if (v28.__r_.__value_.__l.__size_)
        {
LABEL_19:
          if (!atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
            std::__shared_weak_count::__release_weak(v18);
          }
        }
      }
      else
      {
        CFStringRef v18 = (std::__shared_weak_count *)v28.__r_.__value_.__l.__size_;
        if (v28.__r_.__value_.__l.__size_) {
          goto LABEL_19;
        }
      }
      if (cf) {
        CFRelease(cf);
      }
      v6 += 24;
      BOOL v4 = (std::__shared_weak_count *)size;
      if (v6 == v7) {
        goto LABEL_25;
      }
    }
  }
  std::string::size_type size = (std::string::size_type)v4;
LABEL_25:
  *a3 = v5;
  a3[1] = size;
}

{
  std::__shared_weak_count *v4;
  std::string::size_type v5;
  uint64_t v6;
  uint64_t v7;
  CFAllocatorRef v8;
  CFAllocatorRef v9;
  const char *v10;
  CFStringRef v11;
  void *v12;
  const char *v13;
  CFStringRef v14;
  const void *v15;
  char v16;
  std::string::size_type size;
  std::__shared_weak_count *v18;
  uint64_t v19;
  uint64_t v20;
  const std::string::value_type *p_cf;
  std::string::size_type v22;
  int v23;
  CFTypeRef cf;
  std::string::size_type v26;
  unsigned __int8 v27;
  std::string v28;

  std::string::size_type v5 = *a2;
  BOOL v4 = (std::__shared_weak_count *)a2[1];
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = *a1;
  uint64_t v7 = a1[1];
  if (*a1 != v7)
  {
    CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x263EFFB28];
    while (1)
    {
      if (*(char *)(v6 + 23) >= 0) {
        uint64_t v10 = (const char *)v6;
      }
      else {
        uint64_t v10 = *(const char **)v6;
      }
      CFStringRef v11 = CFStringCreateWithCStringNoCopy(v8, v10, 0x8000100u, v9);
      uint64_t v12 = [*(id *)v5 valueForKey:v11];

      CFRelease(v11);
      if (!v12)
      {
        memset(&v28, 0, sizeof(v28));
        uint64_t v20 = *a1;
        uint64_t v19 = a1[1];
        if (*a1 == v19)
        {
          *a3 = 0;
          a3[1] = 0;
        }
        else
        {
          do
          {
            std::operator+<char>();
            if ((v27 & 0x80u) == 0) {
              p_CFTypeRef cf = (const std::string::value_type *)&cf;
            }
            else {
              p_CFTypeRef cf = (const std::string::value_type *)cf;
            }
            if ((v27 & 0x80u) == 0) {
              std::string::size_type v22 = v27;
            }
            else {
              std::string::size_type v22 = v26;
            }
            std::string::append(&v28, p_cf, v22);
            if ((char)v27 < 0) {
              operator delete((void *)cf);
            }
            v20 += 24;
          }
          while (v20 != v19);
          int v23 = SHIBYTE(v28.__r_.__value_.__r.__words[2]);
          *a3 = 0;
          a3[1] = 0;
          if (v23 < 0) {
            operator delete(v28.__r_.__value_.__l.__data_);
          }
        }
        if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
          std::__shared_weak_count::__release_weak(v4);
        }
        return;
      }
      if (*(char *)(v6 + 23) >= 0) {
        CFMutableDictionaryRef v13 = (const char *)v6;
      }
      else {
        CFMutableDictionaryRef v13 = *(const char **)v6;
      }
      CFStringRef v14 = CFStringCreateWithCStringNoCopy(v8, v13, 0x8000100u, v9);
      CFStringRef v15 = (const void *)[*(id *)v5 objectForKey:v14];
      char v16 = *(unsigned char *)(v5 + 8);
      CFTypeRef cf = v15;
      LOBYTE(v26) = v16;
      if (v15) {
        CFRetain(v15);
      }
      else {
        LOBYTE(v26) = 0;
      }
      CFRelease(v14);
      cva::ItemHandler::getDictionary((uint64_t)&cf, &v28);
      std::string::size_type size = v28.__r_.__value_.__l.__size_;
      std::string::size_type v5 = v28.__r_.__value_.__r.__words[0];
      *(_OWORD *)&v28.__r_.__value_.__l.__data_ = 0uLL;
      if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
        CFStringRef v18 = (std::__shared_weak_count *)v28.__r_.__value_.__l.__size_;
        if (v28.__r_.__value_.__l.__size_)
        {
LABEL_19:
          if (!atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
            std::__shared_weak_count::__release_weak(v18);
          }
        }
      }
      else
      {
        CFStringRef v18 = (std::__shared_weak_count *)v28.__r_.__value_.__l.__size_;
        if (v28.__r_.__value_.__l.__size_) {
          goto LABEL_19;
        }
      }
      if (cf) {
        CFRelease(cf);
      }
      v6 += 24;
      BOOL v4 = (std::__shared_weak_count *)size;
      if (v6 == v7) {
        goto LABEL_25;
      }
    }
  }
  std::string::size_type size = (std::string::size_type)v4;
LABEL_25:
  *a3 = v5;
  a3[1] = size;
}

void sub_21542F374(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

void sub_21542F730(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t cva::adp::io::PListSerializer::getKeys(std::string::size_type *a1, std::string *a2, void **a3)
{
  if (!*a1)
  {
    uint64_t v10 = 0;
    CFStringRef v14 = 0;
    CFStringRef v15 = 0;
    goto LABEL_23;
  }
  __p[0] = 0;
  __p[1] = 0;
  size_t v17 = 0;
  if (cva::adp::io::PListSerializer::decomposePath((int)a1, a2, (uint64_t)__p))
  {
    cva::adp::io::PListSerializer::getPath((uint64_t *)__p, a1, (std::string::size_type *)&v14);
    std::string::size_type v5 = (void **)__p[0];
    if (!__p[0]) {
      goto LABEL_4;
    }
LABEL_13:
    for (unint64_t i = (void **)__p[1]; i != v5; i -= 3)
    {
      if (*((char *)i - 1) < 0) {
        operator delete(*(i - 3));
      }
    }
    operator delete(v5);
    uint64_t v6 = (CFDictionaryRef *)v14;
    if (v14) {
      goto LABEL_5;
    }
LABEL_19:
    uint64_t v10 = 0;
    goto LABEL_23;
  }
  CFStringRef v14 = 0;
  CFStringRef v15 = 0;
  std::string::size_type v5 = (void **)__p[0];
  if (__p[0]) {
    goto LABEL_13;
  }
LABEL_4:
  uint64_t v6 = (CFDictionaryRef *)v14;
  if (!v14) {
    goto LABEL_19;
  }
LABEL_5:
  cva::DictionaryHandler::getKeys(v6, __p);
  uint64_t v7 = (void **)*a3;
  if (*a3)
  {
    CFAllocatorRef v8 = (void **)a3[1];
    CFAllocatorRef v9 = *a3;
    if (v8 != v7)
    {
      do
      {
        if (*((char *)v8 - 1) < 0) {
          operator delete(*(v8 - 3));
        }
        v8 -= 3;
      }
      while (v8 != v7);
      CFAllocatorRef v9 = *a3;
    }
    a3[1] = v7;
    operator delete(v9);
  }
  *(_OWORD *)a3 = *(_OWORD *)__p;
  a3[2] = v17;
  uint64_t v10 = 1;
LABEL_23:
  uint64_t v12 = v15;
  if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
  return v10;
}

uint64_t cva::adp::io::PListSerializer::getItem<int>(std::string::size_type *a1, std::string *a2, uint64_t a3, _DWORD *a4)
{
  if (!*a1)
  {
    uint64_t v10 = 0;
    CFStringRef v18 = 0;
    uint64_t v19 = 0;
    return v10;
  }
  std::string __p = 0;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  if (!cva::adp::io::PListSerializer::decomposePath((int)a1, a2, (uint64_t)&__p))
  {
    CFStringRef v18 = 0;
    uint64_t v19 = 0;
    uint64_t v7 = (void **)__p;
    if (__p) {
      goto LABEL_4;
    }
LABEL_13:
    CFAllocatorRef v9 = v18;
    if (!v18) {
      goto LABEL_24;
    }
    goto LABEL_14;
  }
  cva::adp::io::PListSerializer::getPath((uint64_t *)&__p, a1, (std::string::size_type *)&v18);
  uint64_t v7 = (void **)__p;
  if (!__p) {
    goto LABEL_13;
  }
LABEL_4:
  for (unint64_t i = v21; i != v7; i -= 3)
  {
    if (*((char *)i - 1) < 0) {
      operator delete(*(i - 3));
    }
  }
  operator delete(v7);
  CFAllocatorRef v9 = v18;
  if (!v18)
  {
LABEL_24:
    uint64_t v10 = 0;
    CFStringRef v15 = v19;
    if (!v19) {
      return v10;
    }
    goto LABEL_25;
  }
LABEL_14:
  if (*(char *)(a3 + 23) >= 0) {
    CFStringRef v11 = (const char *)a3;
  }
  else {
    CFStringRef v11 = *(const char **)a3;
  }
  CFStringRef v12 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v11, 0x8000100u, (CFAllocatorRef)*MEMORY[0x263EFFB28]);
  CFMutableDictionaryRef v13 = (__CFString *)[*v9 objectForKey:v12];
  CFStringRef v14 = v13;
  if (!v13)
  {
    CFStringRef v16 = v12;
LABEL_23:
    CFRelease(v16);
    goto LABEL_24;
  }
  CFRetain(v13);
  CFRelease(v12);
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    CFStringRef v16 = v14;
    goto LABEL_23;
  }
  *a4 = [(__CFString *)v14 intValue];
  CFRelease(v14);
  uint64_t v10 = 1;
  CFStringRef v15 = v19;
  if (!v19) {
    return v10;
  }
LABEL_25:
  if (!atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  return v10;
}

void sub_21542FA8C(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t cva::adp::io::PListSerializer::getItem<long long>(std::string::size_type *a1, std::string *a2, uint64_t a3, void *a4)
{
  if (!*a1)
  {
    uint64_t v10 = 0;
    CFStringRef v18 = 0;
    uint64_t v19 = 0;
    return v10;
  }
  std::string __p = 0;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  if (!cva::adp::io::PListSerializer::decomposePath((int)a1, a2, (uint64_t)&__p))
  {
    CFStringRef v18 = 0;
    uint64_t v19 = 0;
    uint64_t v7 = (void **)__p;
    if (__p) {
      goto LABEL_4;
    }
LABEL_13:
    CFAllocatorRef v9 = v18;
    if (!v18) {
      goto LABEL_24;
    }
    goto LABEL_14;
  }
  cva::adp::io::PListSerializer::getPath((uint64_t *)&__p, a1, (std::string::size_type *)&v18);
  uint64_t v7 = (void **)__p;
  if (!__p) {
    goto LABEL_13;
  }
LABEL_4:
  for (unint64_t i = v21; i != v7; i -= 3)
  {
    if (*((char *)i - 1) < 0) {
      operator delete(*(i - 3));
    }
  }
  operator delete(v7);
  CFAllocatorRef v9 = v18;
  if (!v18)
  {
LABEL_24:
    uint64_t v10 = 0;
    CFStringRef v15 = v19;
    if (!v19) {
      return v10;
    }
    goto LABEL_25;
  }
LABEL_14:
  if (*(char *)(a3 + 23) >= 0) {
    CFStringRef v11 = (const char *)a3;
  }
  else {
    CFStringRef v11 = *(const char **)a3;
  }
  CFStringRef v12 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v11, 0x8000100u, (CFAllocatorRef)*MEMORY[0x263EFFB28]);
  CFMutableDictionaryRef v13 = (__CFString *)[*v9 objectForKey:v12];
  CFStringRef v14 = v13;
  if (!v13)
  {
    CFStringRef v16 = v12;
LABEL_23:
    CFRelease(v16);
    goto LABEL_24;
  }
  CFRetain(v13);
  CFRelease(v12);
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    CFStringRef v16 = v14;
    goto LABEL_23;
  }
  *a4 = [(__CFString *)v14 longLongValue];
  CFRelease(v14);
  uint64_t v10 = 1;
  CFStringRef v15 = v19;
  if (!v19) {
    return v10;
  }
LABEL_25:
  if (!atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  return v10;
}

void sub_21542FC6C(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t cva::adp::io::PListSerializer::getItem<unsigned int>(std::string::size_type *a1, std::string *a2, uint64_t a3, _DWORD *a4)
{
  if (!*a1)
  {
    uint64_t v10 = 0;
    CFStringRef v18 = 0;
    uint64_t v19 = 0;
    return v10;
  }
  std::string __p = 0;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  if (!cva::adp::io::PListSerializer::decomposePath((int)a1, a2, (uint64_t)&__p))
  {
    CFStringRef v18 = 0;
    uint64_t v19 = 0;
    uint64_t v7 = (void **)__p;
    if (__p) {
      goto LABEL_4;
    }
LABEL_13:
    CFAllocatorRef v9 = v18;
    if (!v18) {
      goto LABEL_24;
    }
    goto LABEL_14;
  }
  cva::adp::io::PListSerializer::getPath((uint64_t *)&__p, a1, (std::string::size_type *)&v18);
  uint64_t v7 = (void **)__p;
  if (!__p) {
    goto LABEL_13;
  }
LABEL_4:
  for (unint64_t i = v21; i != v7; i -= 3)
  {
    if (*((char *)i - 1) < 0) {
      operator delete(*(i - 3));
    }
  }
  operator delete(v7);
  CFAllocatorRef v9 = v18;
  if (!v18)
  {
LABEL_24:
    uint64_t v10 = 0;
    CFStringRef v15 = v19;
    if (!v19) {
      return v10;
    }
    goto LABEL_25;
  }
LABEL_14:
  if (*(char *)(a3 + 23) >= 0) {
    CFStringRef v11 = (const char *)a3;
  }
  else {
    CFStringRef v11 = *(const char **)a3;
  }
  CFStringRef v12 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v11, 0x8000100u, (CFAllocatorRef)*MEMORY[0x263EFFB28]);
  CFMutableDictionaryRef v13 = (__CFString *)[*v9 objectForKey:v12];
  CFStringRef v14 = v13;
  if (!v13)
  {
    CFStringRef v16 = v12;
LABEL_23:
    CFRelease(v16);
    goto LABEL_24;
  }
  CFRetain(v13);
  CFRelease(v12);
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    CFStringRef v16 = v14;
    goto LABEL_23;
  }
  *a4 = [(__CFString *)v14 unsignedIntValue];
  CFRelease(v14);
  uint64_t v10 = 1;
  CFStringRef v15 = v19;
  if (!v19) {
    return v10;
  }
LABEL_25:
  if (!atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  return v10;
}

void sub_21542FE4C(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t cva::adp::io::PListSerializer::getItem<unsigned long long>(std::string::size_type *a1, std::string *a2, uint64_t a3, void *a4)
{
  if (!*a1)
  {
    uint64_t v10 = 0;
    CFStringRef v18 = 0;
    uint64_t v19 = 0;
    return v10;
  }
  std::string __p = 0;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  if (!cva::adp::io::PListSerializer::decomposePath((int)a1, a2, (uint64_t)&__p))
  {
    CFStringRef v18 = 0;
    uint64_t v19 = 0;
    uint64_t v7 = (void **)__p;
    if (__p) {
      goto LABEL_4;
    }
LABEL_13:
    CFAllocatorRef v9 = v18;
    if (!v18) {
      goto LABEL_24;
    }
    goto LABEL_14;
  }
  cva::adp::io::PListSerializer::getPath((uint64_t *)&__p, a1, (std::string::size_type *)&v18);
  uint64_t v7 = (void **)__p;
  if (!__p) {
    goto LABEL_13;
  }
LABEL_4:
  for (unint64_t i = v21; i != v7; i -= 3)
  {
    if (*((char *)i - 1) < 0) {
      operator delete(*(i - 3));
    }
  }
  operator delete(v7);
  CFAllocatorRef v9 = v18;
  if (!v18)
  {
LABEL_24:
    uint64_t v10 = 0;
    CFStringRef v15 = v19;
    if (!v19) {
      return v10;
    }
    goto LABEL_25;
  }
LABEL_14:
  if (*(char *)(a3 + 23) >= 0) {
    CFStringRef v11 = (const char *)a3;
  }
  else {
    CFStringRef v11 = *(const char **)a3;
  }
  CFStringRef v12 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v11, 0x8000100u, (CFAllocatorRef)*MEMORY[0x263EFFB28]);
  CFMutableDictionaryRef v13 = (__CFString *)[*v9 objectForKey:v12];
  CFStringRef v14 = v13;
  if (!v13)
  {
    CFStringRef v16 = v12;
LABEL_23:
    CFRelease(v16);
    goto LABEL_24;
  }
  CFRetain(v13);
  CFRelease(v12);
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    CFStringRef v16 = v14;
    goto LABEL_23;
  }
  *a4 = [(__CFString *)v14 unsignedLongLongValue];
  CFRelease(v14);
  uint64_t v10 = 1;
  CFStringRef v15 = v19;
  if (!v19) {
    return v10;
  }
LABEL_25:
  if (!atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  return v10;
}

void sub_21543002C(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t cva::adp::io::PListSerializer::getItem<float>(std::string::size_type *a1, std::string *a2, uint64_t a3, _DWORD *a4)
{
  if (!*a1)
  {
    uint64_t v10 = 0;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    return v10;
  }
  std::string __p = 0;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  if (!cva::adp::io::PListSerializer::decomposePath((int)a1, a2, (uint64_t)&__p))
  {
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v7 = (void **)__p;
    if (__p) {
      goto LABEL_4;
    }
LABEL_13:
    CFAllocatorRef v9 = v19;
    if (!v19) {
      goto LABEL_24;
    }
    goto LABEL_14;
  }
  cva::adp::io::PListSerializer::getPath((uint64_t *)&__p, a1, (std::string::size_type *)&v19);
  uint64_t v7 = (void **)__p;
  if (!__p) {
    goto LABEL_13;
  }
LABEL_4:
  for (unint64_t i = v22; i != v7; i -= 3)
  {
    if (*((char *)i - 1) < 0) {
      operator delete(*(i - 3));
    }
  }
  operator delete(v7);
  CFAllocatorRef v9 = v19;
  if (!v19)
  {
LABEL_24:
    uint64_t v10 = 0;
    CFStringRef v16 = v20;
    if (!v20) {
      return v10;
    }
    goto LABEL_25;
  }
LABEL_14:
  if (*(char *)(a3 + 23) >= 0) {
    CFStringRef v11 = (const char *)a3;
  }
  else {
    CFStringRef v11 = *(const char **)a3;
  }
  CFStringRef v12 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v11, 0x8000100u, (CFAllocatorRef)*MEMORY[0x263EFFB28]);
  CFMutableDictionaryRef v13 = (__CFString *)[*v9 objectForKey:v12];
  CFStringRef v14 = v13;
  if (!v13)
  {
    CFStringRef v17 = v12;
LABEL_23:
    CFRelease(v17);
    goto LABEL_24;
  }
  CFRetain(v13);
  CFRelease(v12);
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    CFStringRef v17 = v14;
    goto LABEL_23;
  }
  [(__CFString *)v14 floatValue];
  *a4 = v15;
  CFRelease(v14);
  uint64_t v10 = 1;
  CFStringRef v16 = v20;
  if (!v20) {
    return v10;
  }
LABEL_25:
  if (!atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
  return v10;
}

void sub_21543020C(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t cva::adp::io::PListSerializer::getItem<double>(std::string::size_type *a1, std::string *a2, uint64_t a3, void *a4)
{
  if (!*a1)
  {
    uint64_t v10 = 0;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    return v10;
  }
  std::string __p = 0;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  if (!cva::adp::io::PListSerializer::decomposePath((int)a1, a2, (uint64_t)&__p))
  {
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v7 = (void **)__p;
    if (__p) {
      goto LABEL_4;
    }
LABEL_13:
    CFAllocatorRef v9 = v19;
    if (!v19) {
      goto LABEL_24;
    }
    goto LABEL_14;
  }
  cva::adp::io::PListSerializer::getPath((uint64_t *)&__p, a1, (std::string::size_type *)&v19);
  uint64_t v7 = (void **)__p;
  if (!__p) {
    goto LABEL_13;
  }
LABEL_4:
  for (unint64_t i = v22; i != v7; i -= 3)
  {
    if (*((char *)i - 1) < 0) {
      operator delete(*(i - 3));
    }
  }
  operator delete(v7);
  CFAllocatorRef v9 = v19;
  if (!v19)
  {
LABEL_24:
    uint64_t v10 = 0;
    CFStringRef v16 = v20;
    if (!v20) {
      return v10;
    }
    goto LABEL_25;
  }
LABEL_14:
  if (*(char *)(a3 + 23) >= 0) {
    CFStringRef v11 = (const char *)a3;
  }
  else {
    CFStringRef v11 = *(const char **)a3;
  }
  CFStringRef v12 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v11, 0x8000100u, (CFAllocatorRef)*MEMORY[0x263EFFB28]);
  CFMutableDictionaryRef v13 = (__CFString *)[*v9 objectForKey:v12];
  CFStringRef v14 = v13;
  if (!v13)
  {
    CFStringRef v17 = v12;
LABEL_23:
    CFRelease(v17);
    goto LABEL_24;
  }
  CFRetain(v13);
  CFRelease(v12);
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    CFStringRef v17 = v14;
    goto LABEL_23;
  }
  [(__CFString *)v14 doubleValue];
  *a4 = v15;
  CFRelease(v14);
  uint64_t v10 = 1;
  CFStringRef v16 = v20;
  if (!v20) {
    return v10;
  }
LABEL_25:
  if (!atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
  return v10;
}

void sub_2154303EC(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t cva::adp::io::PListSerializer::getItem<BOOL>(std::string::size_type *a1, std::string *a2, uint64_t a3, unsigned char *a4)
{
  if (*a1)
  {
    std::string __p = 0;
    uint64_t v21 = 0;
    uint64_t v22 = 0;
    if (cva::adp::io::PListSerializer::decomposePath((int)a1, a2, (uint64_t)&__p))
    {
      cva::adp::io::PListSerializer::getPath((uint64_t *)&__p, a1, (std::string::size_type *)&v18);
      uint64_t v7 = (void **)__p;
      if (!__p) {
        goto LABEL_4;
      }
    }
    else
    {
      CFStringRef v18 = 0;
      uint64_t v19 = 0;
      uint64_t v7 = (void **)__p;
      if (!__p)
      {
LABEL_4:
        CFAllocatorRef v8 = v18;
        if (!v18) {
          goto LABEL_23;
        }
LABEL_14:
        if (*(char *)(a3 + 23) >= 0) {
          CFStringRef v11 = (const char *)a3;
        }
        else {
          CFStringRef v11 = *(const char **)a3;
        }
        CFStringRef v12 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v11, 0x8000100u, (CFAllocatorRef)*MEMORY[0x263EFFB28]);
        CFMutableDictionaryRef v13 = (__CFString *)[*v8 objectForKey:v12];
        CFStringRef v14 = v13;
        if (v13)
        {
          CFRetain(v13);
          CFRelease(v12);
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            *a4 = [(__CFString *)v14 BOOLValue];
            CFRelease(v14);
            uint64_t v9 = 1;
            goto LABEL_24;
          }
          CFStringRef v15 = v14;
        }
        else
        {
          CFStringRef v15 = v12;
        }
        CFRelease(v15);
LABEL_23:
        uint64_t v9 = 0;
        goto LABEL_24;
      }
    }
    for (unint64_t i = v21; i != v7; i -= 3)
    {
      if (*((char *)i - 1) < 0) {
        operator delete(*(i - 3));
      }
    }
    operator delete(v7);
    CFAllocatorRef v8 = v18;
    if (!v18) {
      goto LABEL_23;
    }
    goto LABEL_14;
  }
  uint64_t v9 = 0;
  CFStringRef v18 = 0;
  uint64_t v19 = 0;
LABEL_24:
  CFStringRef v16 = v19;
  if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
  return v9;
}

void sub_2154305BC(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t cva::adp::io::PListSerializer::getItem<std::string>(std::string::size_type *a1, std::string *a2, uint64_t a3)
{
  if (!*a1)
  {
    CFStringRef v15 = 0;
    CFStringRef v16 = 0;
    goto LABEL_23;
  }
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v18 = 0;
  if (cva::adp::io::PListSerializer::decomposePath((int)a1, a2, (uint64_t)__p))
  {
    cva::adp::io::PListSerializer::getPath((uint64_t *)__p, a1, (std::string::size_type *)&v15);
    std::string::size_type v5 = (void **)__p[0];
    if (!__p[0]) {
      goto LABEL_4;
    }
  }
  else
  {
    CFStringRef v15 = 0;
    CFStringRef v16 = 0;
    std::string::size_type v5 = (void **)__p[0];
    if (!__p[0])
    {
LABEL_4:
      uint64_t v6 = v15;
      if (!v15) {
        goto LABEL_23;
      }
      goto LABEL_14;
    }
  }
  for (unint64_t i = (void **)__p[1]; i != v5; i -= 3)
  {
    if (*((char *)i - 1) < 0) {
      operator delete(*(i - 3));
    }
  }
  operator delete(v5);
  uint64_t v6 = v15;
  if (v15)
  {
LABEL_14:
    if (*(char *)(a3 + 23) >= 0) {
      CFAllocatorRef v8 = (const char *)a3;
    }
    else {
      CFAllocatorRef v8 = *(const char **)a3;
    }
    CFStringRef v9 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v8, 0x8000100u, (CFAllocatorRef)*MEMORY[0x263EFFB28]);
    CFStringRef v10 = (const __CFString *)[*v6 objectForKey:v9];
    CFStringRef v11 = v10;
    if (v10)
    {
      CFRetain(v10);
      CFRelease(v9);
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        cva::ItemHandler::getValue<std::string>();
      }
      CFStringRef v12 = v11;
    }
    else
    {
      CFStringRef v12 = v9;
    }
    CFRelease(v12);
  }
LABEL_23:
  CFMutableDictionaryRef v13 = v16;
  if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  return 0;
}

void sub_2154307C0(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

BOOL cva::adp::io::PListSerializer::setItem<int>(cva::adp::io::PListSerializer *a1, std::string *a2, uint64_t a3, unsigned int *a4)
{
  cva::adp::io::PListSerializer::createPath(a1, a2, &v14);
  uint64_t v6 = v14;
  if (!v14 || (id v7 = (id)[objc_alloc(NSNumber) initWithInt:*a4]) == 0)
  {
    BOOL v11 = 0;
    CFStringRef v12 = v15;
    if (!v15) {
      return v11;
    }
    goto LABEL_11;
  }
  CFAllocatorRef v8 = v7;
  CFRetain(v7);
  if (*(char *)(a3 + 23) >= 0) {
    CFStringRef v9 = (const char *)a3;
  }
  else {
    CFStringRef v9 = *(const char **)a3;
  }
  CFStringRef v10 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v9, 0x8000100u, (CFAllocatorRef)*MEMORY[0x263EFFB28]);
  BOOL v11 = *(unsigned char *)(v6 + 8) != 0;
  if (*(unsigned char *)(v6 + 8)) {
    [*(id *)v6 setValue:v8 forKey:v10];
  }
  CFRelease(v10);
  CFRelease(v8);
  CFStringRef v12 = v15;
  if (v15)
  {
LABEL_11:
    if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  return v11;
}

void sub_215430904(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

BOOL cva::adp::io::PListSerializer::setItem<long long>(cva::adp::io::PListSerializer *a1, std::string *a2, uint64_t a3, void *a4)
{
  cva::adp::io::PListSerializer::createPath(a1, a2, &v14);
  uint64_t v6 = v14;
  if (!v14
    || (id v7 = (id)[objc_alloc(NSNumber) initWithLongLong:*a4]) == 0)
  {
    BOOL v11 = 0;
    CFStringRef v12 = v15;
    if (!v15) {
      return v11;
    }
    goto LABEL_11;
  }
  CFAllocatorRef v8 = v7;
  CFRetain(v7);
  if (*(char *)(a3 + 23) >= 0) {
    CFStringRef v9 = (const char *)a3;
  }
  else {
    CFStringRef v9 = *(const char **)a3;
  }
  CFStringRef v10 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v9, 0x8000100u, (CFAllocatorRef)*MEMORY[0x263EFFB28]);
  BOOL v11 = *(unsigned char *)(v6 + 8) != 0;
  if (*(unsigned char *)(v6 + 8)) {
    [*(id *)v6 setValue:v8 forKey:v10];
  }
  CFRelease(v10);
  CFRelease(v8);
  CFStringRef v12 = v15;
  if (v15)
  {
LABEL_11:
    if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  return v11;
}

void sub_215430A48(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

BOOL cva::adp::io::PListSerializer::setItem<unsigned int>(cva::adp::io::PListSerializer *a1, std::string *a2, uint64_t a3, unsigned int *a4)
{
  cva::adp::io::PListSerializer::createPath(a1, a2, &v14);
  uint64_t v6 = v14;
  if (!v14
    || (id v7 = (id)[objc_alloc(NSNumber) initWithUnsignedInt:*a4]) == 0)
  {
    BOOL v11 = 0;
    CFStringRef v12 = v15;
    if (!v15) {
      return v11;
    }
    goto LABEL_11;
  }
  CFAllocatorRef v8 = v7;
  CFRetain(v7);
  if (*(char *)(a3 + 23) >= 0) {
    CFStringRef v9 = (const char *)a3;
  }
  else {
    CFStringRef v9 = *(const char **)a3;
  }
  CFStringRef v10 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v9, 0x8000100u, (CFAllocatorRef)*MEMORY[0x263EFFB28]);
  BOOL v11 = *(unsigned char *)(v6 + 8) != 0;
  if (*(unsigned char *)(v6 + 8)) {
    [*(id *)v6 setValue:v8 forKey:v10];
  }
  CFRelease(v10);
  CFRelease(v8);
  CFStringRef v12 = v15;
  if (v15)
  {
LABEL_11:
    if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  return v11;
}

void sub_215430B8C(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

BOOL cva::adp::io::PListSerializer::setItem<unsigned long long>(cva::adp::io::PListSerializer *a1, std::string *a2, uint64_t a3, void *a4)
{
  cva::adp::io::PListSerializer::createPath(a1, a2, &v14);
  uint64_t v6 = v14;
  if (!v14
    || (id v7 = (id)[objc_alloc(NSNumber) initWithUnsignedLongLong:*a4]) == 0)
  {
    BOOL v11 = 0;
    CFStringRef v12 = v15;
    if (!v15) {
      return v11;
    }
    goto LABEL_11;
  }
  CFAllocatorRef v8 = v7;
  CFRetain(v7);
  if (*(char *)(a3 + 23) >= 0) {
    CFStringRef v9 = (const char *)a3;
  }
  else {
    CFStringRef v9 = *(const char **)a3;
  }
  CFStringRef v10 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v9, 0x8000100u, (CFAllocatorRef)*MEMORY[0x263EFFB28]);
  BOOL v11 = *(unsigned char *)(v6 + 8) != 0;
  if (*(unsigned char *)(v6 + 8)) {
    [*(id *)v6 setValue:v8 forKey:v10];
  }
  CFRelease(v10);
  CFRelease(v8);
  CFStringRef v12 = v15;
  if (v15)
  {
LABEL_11:
    if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  return v11;
}

void sub_215430CD0(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

BOOL cva::adp::io::PListSerializer::setItem<float>(cva::adp::io::PListSerializer *a1, std::string *a2, uint64_t a3, int *a4)
{
  cva::adp::io::PListSerializer::createPath(a1, a2, &v17);
  uint64_t v6 = v17;
  if (!v17
    || (int v7 = *a4,
        id v8 = objc_alloc(NSNumber),
        LODWORD(v9) = v7,
        (id v10 = (id)[v8 initWithFloat:v9]) == 0))
  {
    BOOL v14 = 0;
    CFStringRef v15 = v18;
    if (!v18) {
      return v14;
    }
    goto LABEL_11;
  }
  BOOL v11 = v10;
  CFRetain(v10);
  if (*(char *)(a3 + 23) >= 0) {
    CFStringRef v12 = (const char *)a3;
  }
  else {
    CFStringRef v12 = *(const char **)a3;
  }
  CFStringRef v13 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v12, 0x8000100u, (CFAllocatorRef)*MEMORY[0x263EFFB28]);
  BOOL v14 = *(unsigned char *)(v6 + 8) != 0;
  if (*(unsigned char *)(v6 + 8)) {
    [*(id *)v6 setValue:v11 forKey:v13];
  }
  CFRelease(v13);
  CFRelease(v11);
  CFStringRef v15 = v18;
  if (v18)
  {
LABEL_11:
    if (!atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  return v14;
}

void sub_215430E1C(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

BOOL cva::adp::io::PListSerializer::setItem<double>(cva::adp::io::PListSerializer *a1, std::string *a2, uint64_t a3, double *a4)
{
  cva::adp::io::PListSerializer::createPath(a1, a2, &v14);
  uint64_t v6 = v14;
  if (!v14 || (id v7 = (id)[objc_alloc(NSNumber) initWithDouble:*a4]) == 0)
  {
    BOOL v11 = 0;
    CFStringRef v12 = v15;
    if (!v15) {
      return v11;
    }
    goto LABEL_11;
  }
  id v8 = v7;
  CFRetain(v7);
  if (*(char *)(a3 + 23) >= 0) {
    double v9 = (const char *)a3;
  }
  else {
    double v9 = *(const char **)a3;
  }
  CFStringRef v10 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v9, 0x8000100u, (CFAllocatorRef)*MEMORY[0x263EFFB28]);
  BOOL v11 = *(unsigned char *)(v6 + 8) != 0;
  if (*(unsigned char *)(v6 + 8)) {
    [*(id *)v6 setValue:v8 forKey:v10];
  }
  CFRelease(v10);
  CFRelease(v8);
  CFStringRef v12 = v15;
  if (v15)
  {
LABEL_11:
    if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  return v11;
}

void sub_215430F68(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

BOOL cva::adp::io::PListSerializer::setItem<BOOL>(cva::adp::io::PListSerializer *a1, std::string *a2, uint64_t a3, unsigned __int8 *a4)
{
  cva::adp::io::PListSerializer::createPath(a1, a2, &v14);
  uint64_t v6 = v14;
  if (!v14 || (id v7 = (id)[objc_alloc(NSNumber) initWithBool:*a4]) == 0)
  {
    BOOL v11 = 0;
    CFStringRef v12 = v15;
    if (!v15) {
      return v11;
    }
    goto LABEL_11;
  }
  id v8 = v7;
  CFRetain(v7);
  if (*(char *)(a3 + 23) >= 0) {
    double v9 = (const char *)a3;
  }
  else {
    double v9 = *(const char **)a3;
  }
  CFStringRef v10 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v9, 0x8000100u, (CFAllocatorRef)*MEMORY[0x263EFFB28]);
  BOOL v11 = *(unsigned char *)(v6 + 8) != 0;
  if (*(unsigned char *)(v6 + 8)) {
    [*(id *)v6 setValue:v8 forKey:v10];
  }
  CFRelease(v10);
  CFRelease(v8);
  CFStringRef v12 = v15;
  if (v15)
  {
LABEL_11:
    if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  return v11;
}

void sub_2154310AC(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

BOOL cva::adp::io::PListSerializer::setItem<std::string>(cva::adp::io::PListSerializer *a1, std::string *a2, uint64_t a3, uint64_t *a4)
{
  cva::adp::io::PListSerializer::createPath(a1, a2, &v14);
  uint64_t v6 = v14;
  if (!v14) {
    goto LABEL_12;
  }
  if (*((char *)a4 + 23) < 0) {
    a4 = (uint64_t *)*a4;
  }
  id v7 = (id)[[NSString alloc] initWithUTF8String:a4];
  if (!v7)
  {
LABEL_12:
    BOOL v11 = 0;
    CFStringRef v12 = v15;
    if (!v15) {
      return v11;
    }
    goto LABEL_13;
  }
  id v8 = v7;
  CFRetain(v7);
  if (*(char *)(a3 + 23) >= 0) {
    double v9 = (const char *)a3;
  }
  else {
    double v9 = *(const char **)a3;
  }
  CFStringRef v10 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v9, 0x8000100u, (CFAllocatorRef)*MEMORY[0x263EFFB28]);
  BOOL v11 = *(unsigned char *)(v6 + 8) != 0;
  if (*(unsigned char *)(v6 + 8)) {
    [*(id *)v6 setValue:v8 forKey:v10];
  }
  CFRelease(v10);
  CFRelease(v8);
  CFStringRef v12 = v15;
  if (v15)
  {
LABEL_13:
    if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  return v11;
}

void sub_2154311FC(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

void cva::ProgramOptions::ProgramOptions()
{
}

{
  operator new();
}

void cva::ProgramOptions::~ProgramOptions(cva::ProgramOptions *this)
{
  uint64_t v2 = *(void *)this;
  *(void *)this = 0;
  if (v2)
  {
    uint64_t v3 = sub_215431440(v2);
    MEMORY[0x2166B9890](v3, 0x1032C407DCE974ALL);
  }
}

{
  uint64_t v2;
  uint64_t v3;

  uint64_t v2 = *(void *)this;
  *(void *)this = 0;
  if (v2)
  {
    uint64_t v3 = sub_215431440(v2);
    MEMORY[0x2166B9890](v3, 0x1032C407DCE974ALL);
  }
}

uint64_t sub_215431440(uint64_t a1)
{
  uint64_t v3 = (void **)(a1 + 120);
  uint64_t v2 = *(void *)(a1 + 120);
  if (v2)
  {
    sub_21543151C(a1 + 120, v2);
    operator delete(*v3);
  }
  sub_21543160C(*(char **)(a1 + 104));
  uint64_t v4 = *(void *)(a1 + 72);
  if (v4)
  {
    uint64_t v5 = *(void *)(a1 + 80);
    uint64_t v6 = *(void **)(a1 + 72);
    if (v5 != v4)
    {
      do
      {
        if (*(char *)(v5 - 1) < 0) {
          operator delete(*(void **)(v5 - 24));
        }
        v5 -= 24;
      }
      while (v5 != v4);
      uint64_t v6 = *(void **)(a1 + 72);
    }
    *(void *)(a1 + 80) = v4;
    operator delete(v6);
  }
  if ((*(char *)(a1 + 71) & 0x80000000) == 0)
  {
    if ((*(char *)(a1 + 47) & 0x80000000) == 0) {
      goto LABEL_13;
    }
LABEL_16:
    operator delete(*(void **)(a1 + 24));
    if ((*(char *)(a1 + 23) & 0x80000000) == 0) {
      return a1;
    }
LABEL_17:
    operator delete(*(void **)a1);
    return a1;
  }
  operator delete(*(void **)(a1 + 48));
  if (*(char *)(a1 + 47) < 0) {
    goto LABEL_16;
  }
LABEL_13:
  if (*(char *)(a1 + 23) < 0) {
    goto LABEL_17;
  }
  return a1;
}

void sub_21543151C(uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(void *)(a1 + 8); i != a2; i -= 96)
  {
    if (*(char *)(i - 9) < 0)
    {
      operator delete(*(void **)(i - 32));
      uint64_t v5 = *(std::__shared_weak_count **)(i - 40);
      if (!v5) {
        goto LABEL_9;
      }
    }
    else
    {
      uint64_t v5 = *(std::__shared_weak_count **)(i - 40);
      if (!v5) {
        goto LABEL_9;
      }
    }
    if (atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
LABEL_9:
      if ((*(char *)(i - 49) & 0x80000000) == 0) {
        goto LABEL_10;
      }
      goto LABEL_13;
    }
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
    if ((*(char *)(i - 49) & 0x80000000) == 0)
    {
LABEL_10:
      if (*(char *)(i - 73) < 0) {
        goto LABEL_14;
      }
      continue;
    }
LABEL_13:
    operator delete(*(void **)(i - 72));
    if (*(char *)(i - 73) < 0) {
LABEL_14:
    }
      operator delete(*(void **)(i - 96));
  }
  *(void *)(a1 + 8) = a2;
}

void sub_21543160C(char *a1)
{
  if (!a1) {
    return;
  }
  sub_21543160C(*(void *)a1);
  sub_21543160C(*((void *)a1 + 1));
  uint64_t v2 = *((void *)a1 + 10);
  if (v2)
  {
    uint64_t v3 = *((void *)a1 + 11);
    uint64_t v4 = (void *)*((void *)a1 + 10);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0) {
          operator delete(*(void **)(v3 - 24));
        }
        v3 -= 24;
      }
      while (v3 != v2);
      uint64_t v4 = (void *)*((void *)a1 + 10);
    }
    *((void *)a1 + 11) = v2;
    operator delete(v4);
  }
  if (a1[79] < 0)
  {
    operator delete(*((void **)a1 + 7));
    if ((a1[55] & 0x80000000) == 0) {
      goto LABEL_13;
    }
LABEL_17:
    operator delete(*((void **)a1 + 4));
    goto LABEL_13;
  }
  if (a1[55] < 0) {
    goto LABEL_17;
  }
LABEL_13:
  operator delete(a1);
}

void cva::ProgramOptions::Private::registerCommand(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 120);
  uint64_t v3 = *(void *)(a1 + 128);
  if (v2 != v3)
  {
    while (!sub_215431814(v2, a2))
    {
      v2 += 96;
      if (v2 == v3) {
        return;
      }
    }
    uint64_t v6 = (uint64_t **)(a1 + 96);
    if (*(char *)(v2 + 23) < 0)
    {
      sub_2153C0AE4(v7, *(void **)v2, *(void *)(v2 + 8));
    }
    else
    {
      *(_OWORD *)id v7 = *(_OWORD *)v2;
      uint64_t v8 = *(void *)(v2 + 16);
    }
    if (*(char *)(v2 + 47) < 0)
    {
      sub_2153C0AE4(&__p, *(void **)(v2 + 24), *(void *)(v2 + 32));
    }
    else
    {
      long long __p = *(_OWORD *)(v2 + 24);
      uint64_t v10 = *(void *)(v2 + 40);
    }
    sub_2154318D8(v6, v7, (uint64_t)v7);
    if ((SHIBYTE(v10) & 0x80000000) == 0)
    {
      if ((SHIBYTE(v8) & 0x80000000) == 0) {
        return;
      }
LABEL_15:
      operator delete(v7[0]);
      return;
    }
    operator delete((void *)__p);
    if (SHIBYTE(v8) < 0) {
      goto LABEL_15;
    }
  }
}

BOOL sub_215431814(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a1 + 23) < 0)
  {
    sub_2153C0AE4(v6, *(void **)a1, *(void *)(a1 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t v6 = *(_OWORD *)a1;
    uint64_t v7 = *(void *)(a1 + 16);
  }
  if (*(char *)(a1 + 47) < 0)
  {
    sub_2153C0AE4(&__p, *(void **)(a1 + 24), *(void *)(a1 + 32));
  }
  else
  {
    long long __p = *(_OWORD *)(a1 + 24);
    uint64_t v9 = *(void *)(a1 + 40);
  }
  BOOL v4 = sub_215431AC8((unsigned __int8 *)v6, a2);
  if (SHIBYTE(v9) < 0)
  {
    operator delete((void *)__p);
    if ((SHIBYTE(v7) & 0x80000000) == 0) {
      return v4;
    }
LABEL_11:
    operator delete(v6[0]);
    return v4;
  }
  if (SHIBYTE(v7) < 0) {
    goto LABEL_11;
  }
  return v4;
}

char *sub_2154318D8(uint64_t **a1, void *a2, uint64_t a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v8 = (char *)v5;
        uint64_t v9 = v5 + 4;
        if (!sub_2154319E4(a2, v5 + 4)) {
          break;
        }
        uint64_t v5 = *(uint64_t **)v8;
        uint64_t v6 = (uint64_t **)v8;
        if (!*(void *)v8) {
          goto LABEL_9;
        }
      }
      if (!sub_2154319E4(v9, a2)) {
        break;
      }
      uint64_t v6 = (uint64_t **)(v8 + 8);
      uint64_t v5 = (uint64_t *)*((void *)v8 + 1);
      if (!v5) {
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v8 = (char *)(a1 + 1);
LABEL_9:
    uint64_t v10 = v8;
    uint64_t v8 = (char *)operator new(0x68uLL);
    *((_OWORD *)v8 + 2) = *(_OWORD *)a3;
    *((void *)v8 + 6) = *(void *)(a3 + 16);
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(_OWORD *)(v8 + 56) = *(_OWORD *)(a3 + 24);
    uint64_t v11 = *(void *)(a3 + 40);
    *(void *)(a3 + 16) = 0;
    *(void *)(a3 + 24) = 0;
    *(void *)(a3 + 32) = 0;
    *(void *)(a3 + 40) = 0;
    *((void *)v8 + 9) = v11;
    *((void *)v8 + 10) = 0;
    *((void *)v8 + 11) = 0;
    *((void *)v8 + 12) = 0;
    *(void *)uint64_t v8 = 0;
    *((void *)v8 + 1) = 0;
    *((void *)v8 + 2) = v10;
    *uint64_t v6 = (uint64_t *)v8;
    CFStringRef v12 = (uint64_t *)v8;
    CFStringRef v13 = (uint64_t *)**a1;
    if (v13)
    {
      *a1 = v13;
      CFStringRef v12 = *v6;
    }
    sub_2153CF298(a1[1], v12);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v8;
}

uint64_t sub_2154319E4(void *a1, void *a2)
{
  uint64_t v2 = a2;
  uint64_t v3 = a1;
  int v4 = *((char *)a2 + 23);
  int v5 = *((char *)a1 + 23);
  if (v5 >= 0) {
    size_t v6 = *((unsigned __int8 *)a1 + 23);
  }
  else {
    size_t v6 = a1[1];
  }
  if (v5 < 0) {
    a1 = (void *)*a1;
  }
  if (v4 >= 0) {
    size_t v7 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v7 = a2[1];
  }
  if (v4 < 0) {
    a2 = (void *)*a2;
  }
  if (v7 >= v6) {
    size_t v8 = v6;
  }
  else {
    size_t v8 = v7;
  }
  int v9 = memcmp(a1, a2, v8);
  if (v6 < v7) {
    unsigned int v10 = -1;
  }
  else {
    unsigned int v10 = v7 < v6;
  }
  if (v9) {
    unsigned int v10 = v9;
  }
  if (!v10)
  {
    CFStringRef v13 = (const void *)v2[3];
    CFStringRef v12 = v2 + 3;
    uint64_t v11 = v13;
    int v14 = *((char *)v12 + 23);
    uint64_t v17 = (const void *)v3[3];
    CFStringRef v16 = v3 + 3;
    CFStringRef v15 = v17;
    int v18 = *((char *)v16 + 23);
    if (v18 >= 0) {
      size_t v19 = *((unsigned __int8 *)v16 + 23);
    }
    else {
      size_t v19 = v16[1];
    }
    if (v18 >= 0) {
      uint64_t v20 = v16;
    }
    else {
      uint64_t v20 = v15;
    }
    if (v14 >= 0) {
      size_t v21 = *((unsigned __int8 *)v12 + 23);
    }
    else {
      size_t v21 = v12[1];
    }
    if (v14 >= 0) {
      uint64_t v22 = v12;
    }
    else {
      uint64_t v22 = v11;
    }
    if (v21 >= v19) {
      size_t v23 = v19;
    }
    else {
      size_t v23 = v21;
    }
    int v24 = memcmp(v20, v22, v23);
    if (v19 < v21) {
      unsigned int v10 = -1;
    }
    else {
      unsigned int v10 = v21 < v19;
    }
    if (v24) {
      unsigned int v10 = v24;
    }
  }
  return v10 >> 31;
}

BOOL sub_215431AC8(unsigned __int8 *a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 *)(a2 + 23);
  size_t v3 = *(void *)(a2 + 8);
  if ((v2 & 0x80u) == 0) {
    uint64_t v4 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v4 = *(void *)(a2 + 8);
  }
  if (!v4) {
    return 0;
  }
  int v5 = (const void **)a2;
  uint64_t v7 = a1[23];
  int v8 = (char)v7;
  if ((v7 & 0x80u) != 0) {
    uint64_t v7 = *((void *)a1 + 1);
  }
  if (v4 == v7)
  {
    if (v8 >= 0) {
      int v9 = a1;
    }
    else {
      int v9 = *(unsigned __int8 **)a1;
    }
    if ((v2 & 0x80) != 0)
    {
      if (!memcmp(*v5, v9, v3)) {
        return 1;
      }
    }
    else
    {
      if (!v2) {
        return 1;
      }
      unsigned int v10 = v5;
      uint64_t v11 = v2;
      while (*(unsigned __int8 *)v10 == *v9)
      {
        unsigned int v10 = (const void **)((char *)v10 + 1);
        ++v9;
        if (!--v11) {
          return 1;
        }
      }
    }
  }
  uint64_t v12 = a1[47];
  int v13 = (char)v12;
  if ((v12 & 0x80u) != 0) {
    uint64_t v12 = *((void *)a1 + 4);
  }
  if (v4 != v12) {
    return 0;
  }
  CFStringRef v16 = (unsigned __int8 *)*((void *)a1 + 3);
  CFStringRef v15 = a1 + 24;
  int v14 = v16;
  if (v13 >= 0) {
    uint64_t v17 = v15;
  }
  else {
    uint64_t v17 = v14;
  }
  if ((v2 & 0x80) != 0) {
    return memcmp(*v5, v17, v3) == 0;
  }
  if (!v2) {
    return 1;
  }
  uint64_t v18 = v2 - 1;
  do
  {
    int v20 = *(unsigned __int8 *)v5;
    int v5 = (const void **)((char *)v5 + 1);
    int v19 = v20;
    int v22 = *v17++;
    int v21 = v22;
    BOOL v24 = v18-- != 0;
    BOOL result = v19 == v21;
  }
  while (v19 == v21 && v24);
  return result;
}

unsigned char *cva::ProgramOptions::Description::Option::key@<X0>(cva::ProgramOptions::Description::Option *this@<X0>, uint64_t a2@<X8>)
{
  if (*((char *)this + 23) < 0)
  {
    sub_2153C0AE4((unsigned char *)a2, *(void **)this, *((void *)this + 1));
  }
  else
  {
    *(_OWORD *)a2 = *(_OWORD *)this;
    *(void *)(a2 + 16) = *((void *)this + 2);
  }
  BOOL result = (unsigned char *)(a2 + 24);
  if (*((char *)this + 47) < 0)
  {
    int v5 = (void *)*((void *)this + 3);
    unint64_t v6 = *((void *)this + 4);
    return sub_2153C0AE4(result, v5, v6);
  }
  else
  {
    *(_OWORD *)BOOL result = *(_OWORD *)((char *)this + 24);
    *(void *)(a2 + 40) = *((void *)this + 5);
  }
  return result;
}

void cva::ProgramOptions::Private::addValue(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 120);
  uint64_t v4 = *(void *)(a1 + 128);
  if (v3 != v4)
  {
    while (!sub_215431814(v3, a2))
    {
      v3 += 96;
      if (v3 == v4) {
        return;
      }
    }
    int v8 = (uint64_t **)(a1 + 96);
    if (*(char *)(v3 + 23) < 0)
    {
      sub_2153C0AE4(v14, *(void **)v3, *(void *)(v3 + 8));
    }
    else
    {
      *(_OWORD *)int v14 = *(_OWORD *)v3;
      uint64_t v15 = *(void *)(v3 + 16);
    }
    if (*(char *)(v3 + 47) < 0)
    {
      sub_2153C0AE4(&__p, *(void **)(v3 + 24), *(void *)(v3 + 32));
    }
    else
    {
      long long __p = *(_OWORD *)(v3 + 24);
      uint64_t v17 = *(void *)(v3 + 40);
    }
    int v9 = sub_2154318D8(v8, v14, (uint64_t)v14);
    unsigned int v10 = v9;
    unint64_t v11 = *((void *)v9 + 11);
    if (v11 >= *((void *)v9 + 12))
    {
      int v13 = sub_21541857C((uint64_t)(v9 + 80), a3);
    }
    else
    {
      if (*(char *)(a3 + 23) < 0)
      {
        sub_2153C0AE4(*((unsigned char **)v9 + 11), *(void **)a3, *(void *)(a3 + 8));
      }
      else
      {
        long long v12 = *(_OWORD *)a3;
        *(void *)(v11 + 16) = *(void *)(a3 + 16);
        *(_OWORD *)unint64_t v11 = v12;
      }
      int v13 = (char *)(v11 + 24);
    }
    *((void *)v10 + 11) = v13;
    if ((SHIBYTE(v17) & 0x80000000) == 0)
    {
      if ((SHIBYTE(v15) & 0x80000000) == 0) {
        return;
      }
LABEL_21:
      operator delete(v14[0]);
      return;
    }
    operator delete((void *)__p);
    if (SHIBYTE(v15) < 0) {
      goto LABEL_21;
    }
  }
}

void cva::ProgramOptions::Private::checkCommand(cva::ProgramOptions::Private *this)
{
  uint64_t v2 = *((void *)this + 15);
  uint64_t v1 = *((void *)this + 16);
  if (v2 != v1)
  {
    uint64_t v4 = (uint64_t *)((char *)this + 104);
    long long v53 = (void **)((char *)this + 72);
    long long v54 = (uint64_t **)((char *)this + 96);
    while (1)
    {
      uint64_t v6 = *(char *)(v2 + 23) < 0 ? *(void *)(v2 + 8) : *(unsigned __int8 *)(v2 + 23);
      uint64_t v7 = (unsigned __int8 *)(v6 ? v2 : v2 + 24);
      if (!*(unsigned char *)(v2 + 92)) {
        break;
      }
      uint64_t v8 = v7[23];
      size_t v9 = *((void *)v7 + 1);
      if ((v8 & 0x80u) == 0) {
        uint64_t v10 = v7[23];
      }
      else {
        uint64_t v10 = *((void *)v7 + 1);
      }
      if (v10)
      {
        unint64_t v11 = *v54;
        if (*v54 != v4)
        {
          do
          {
            uint64_t v12 = *((unsigned __int8 *)v11 + 55);
            int v13 = (char)v12;
            if ((v12 & 0x80u) != 0) {
              uint64_t v12 = v11[5];
            }
            if (v10 == v12)
            {
              if (v13 >= 0) {
                int v14 = (unsigned __int8 *)(v11 + 4);
              }
              else {
                int v14 = (unsigned __int8 *)v11[4];
              }
              if ((v8 & 0x80) != 0)
              {
                if (!memcmp(*(const void **)v7, v14, v9)) {
                  goto LABEL_54;
                }
              }
              else
              {
                if (!v8) {
                  goto LABEL_54;
                }
                uint64_t v15 = v7;
                uint64_t v16 = v8;
                while (*v15 == *v14)
                {
                  ++v15;
                  ++v14;
                  if (!--v16) {
                    goto LABEL_54;
                  }
                }
              }
            }
            uint64_t v17 = *((unsigned __int8 *)v11 + 79);
            int v18 = (char)v17;
            if ((v17 & 0x80u) != 0) {
              uint64_t v17 = v11[8];
            }
            if (v10 == v17)
            {
              if (v18 >= 0) {
                int v19 = (unsigned __int8 *)(v11 + 7);
              }
              else {
                int v19 = (unsigned __int8 *)v11[7];
              }
              if ((v8 & 0x80) != 0)
              {
                if (!memcmp(*(const void **)v7, v19, v9)) {
                  goto LABEL_54;
                }
              }
              else
              {
                if (!v8) {
                  goto LABEL_54;
                }
                int v20 = v7;
                uint64_t v21 = v8;
                while (*v20 == *v19)
                {
                  ++v20;
                  ++v19;
                  if (!--v21) {
                    goto LABEL_54;
                  }
                }
              }
            }
            int v22 = (uint64_t *)v11[1];
            if (v22)
            {
              do
              {
                size_t v23 = v22;
                int v22 = (uint64_t *)*v22;
              }
              while (v22);
            }
            else
            {
              do
              {
                size_t v23 = (uint64_t *)v11[2];
                BOOL v24 = *v23 == (void)v11;
                unint64_t v11 = v23;
              }
              while (!v24);
            }
            unint64_t v11 = v23;
          }
          while (v23 != v4);
        }
      }
      std::operator+<char>();
      char v25 = std::string::append(&v58, " is required!");
      std::string __p = *v25;
      v25->__r_.__value_.__r.__words[0] = 0;
      v25->__r_.__value_.__l.__size_ = 0;
      v25->__r_.__value_.__r.__words[2] = 0;
      std::string::size_type v26 = (std::string *)*((void *)this + 10);
      if ((unint64_t)v26 >= *((void *)this + 11))
      {
        unsigned __int8 v27 = sub_21541D040(v53, (uint64_t)&__p);
        int v28 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
        *((void *)this + 10) = v27;
        if (v28 < 0)
        {
          operator delete(__p.__r_.__value_.__l.__data_);
          if ((SHIBYTE(v58.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            break;
          }
        }
        else if ((SHIBYTE(v58.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
          break;
        }
      }
      else
      {
        *std::string::size_type v26 = __p;
        *((void *)this + 10) = v26 + 1;
        if ((SHIBYTE(v58.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          break;
        }
      }
      operator delete(v58.__r_.__value_.__l.__data_);
      if ((*(_DWORD *)(v2 + 88) & 0x80000000) != 0) {
        goto LABEL_4;
      }
LABEL_55:
      uint64_t v29 = v7[23];
      size_t v30 = *((void *)v7 + 1);
      if ((v29 & 0x80u) == 0) {
        uint64_t v31 = v7[23];
      }
      else {
        uint64_t v31 = *((void *)v7 + 1);
      }
      if (!v31) {
        goto LABEL_4;
      }
      SparseSymbolicFactorOptions v32 = *v54;
      if (*v54 == v4) {
        goto LABEL_4;
      }
      while (1)
      {
        uint64_t v33 = *((unsigned __int8 *)v32 + 55);
        int v34 = (char)v33;
        if ((v33 & 0x80u) != 0) {
          uint64_t v33 = v32[5];
        }
        if (v31 == v33)
        {
          if (v34 >= 0) {
            long long v35 = (unsigned __int8 *)(v32 + 4);
          }
          else {
            long long v35 = (unsigned __int8 *)v32[4];
          }
          if ((v29 & 0x80) != 0)
          {
            if (!memcmp(*(const void **)v7, v35, v30)) {
              goto LABEL_93;
            }
          }
          else
          {
            if (!v29) {
              goto LABEL_93;
            }
            long long v36 = v7;
            uint64_t v37 = v29;
            while (*v36 == *v35)
            {
              ++v36;
              ++v35;
              if (!--v37) {
                goto LABEL_93;
              }
            }
          }
        }
        uint64_t v38 = *((unsigned __int8 *)v32 + 79);
        int v39 = (char)v38;
        if ((v38 & 0x80u) != 0) {
          uint64_t v38 = v32[8];
        }
        if (v31 != v38) {
          goto LABEL_86;
        }
        long long v40 = v39 >= 0 ? v32 + 7 : (uint64_t *)v32[7];
        if ((v29 & 0x80) != 0) {
          break;
        }
        if (!v29) {
          goto LABEL_93;
        }
        long long v41 = v7;
        uint64_t v42 = v29;
        while (*v41 == *(unsigned __int8 *)v40)
        {
          ++v41;
          long long v40 = (uint64_t *)((char *)v40 + 1);
          if (!--v42) {
            goto LABEL_93;
          }
        }
LABEL_86:
        long long v43 = (uint64_t *)v32[1];
        if (v43)
        {
          do
          {
            long long v44 = v43;
            long long v43 = (uint64_t *)*v43;
          }
          while (v43);
        }
        else
        {
          do
          {
            long long v44 = (uint64_t *)v32[2];
            BOOL v24 = *v44 == (void)v32;
            SparseSymbolicFactorOptions v32 = v44;
          }
          while (!v24);
        }
        SparseSymbolicFactorOptions v32 = v44;
        if (v44 == v4) {
          goto LABEL_4;
        }
      }
      if (memcmp(*(const void **)v7, v40, v30)) {
        goto LABEL_86;
      }
LABEL_93:
      if (*(char *)(v2 + 23) < 0)
      {
        sub_2153C0AE4(&__p, *(void **)v2, *(void *)(v2 + 8));
        if (*(char *)(v2 + 47) < 0) {
          goto LABEL_97;
        }
LABEL_95:
        long long v56 = *(_OWORD *)(v2 + 24);
        uint64_t v57 = *(void *)(v2 + 40);
      }
      else
      {
        std::string __p = *(std::string *)v2;
        if ((*(char *)(v2 + 47) & 0x80000000) == 0) {
          goto LABEL_95;
        }
LABEL_97:
        sub_2153C0AE4(&v56, *(void **)(v2 + 24), *(void *)(v2 + 32));
      }
      long long v45 = sub_2154318D8(v54, &__p, (uint64_t)&__p);
      uint64_t v47 = *((void *)v45 + 10);
      uint64_t v46 = *((void *)v45 + 11);
      if (SHIBYTE(v57) < 0)
      {
        operator delete((void *)v56);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
LABEL_100:
        }
          operator delete(__p.__r_.__value_.__l.__data_);
      }
      else if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        goto LABEL_100;
      }
      int v48 = -1431655765 * ((unint64_t)(v46 - v47) >> 3);
      int v49 = *(_DWORD *)(v2 + 88);
      if (v49 > v48 || v49 < v48)
      {
        std::operator+<char>();
        unint64_t v50 = *((void *)this + 10);
        if (v50 < *((void *)this + 11))
        {
          long long v5 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
          *(void *)(v50 + 16) = *((void *)&__p.__r_.__value_.__l + 2);
          *(_OWORD *)unint64_t v50 = v5;
          *((void *)this + 10) = v50 + 24;
        }
        else
        {
          long long v51 = sub_21541D040(v53, (uint64_t)&__p);
          int v52 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
          *((void *)this + 10) = v51;
          if (v52 < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
        }
      }
LABEL_4:
      v2 += 96;
      if (v2 == v1) {
        return;
      }
    }
LABEL_54:
    if ((*(_DWORD *)(v2 + 88) & 0x80000000) != 0) {
      goto LABEL_4;
    }
    goto LABEL_55;
  }
}

BOOL cva::ProgramOptions::Private::hasCommand(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 *)(a2 + 23);
  if ((v2 & 0x80u) != 0) {
    uint64_t v2 = *(void *)(a2 + 8);
  }
  if (!v2) {
    return 0;
  }
  uint64_t v3 = *(unsigned __int8 **)(a1 + 96);
  uint64_t v4 = (unsigned __int8 *)(a1 + 104);
  if (v3 == (unsigned __int8 *)(a1 + 104)) {
    return 0;
  }
  do
  {
    BOOL result = sub_215431AC8(v3 + 32, a2);
    if (result) {
      break;
    }
    uint64_t v7 = (unsigned __int8 *)*((void *)v3 + 1);
    if (v7)
    {
      do
      {
        uint64_t v8 = v7;
        uint64_t v7 = *(unsigned __int8 **)v7;
      }
      while (v7);
    }
    else
    {
      do
      {
        uint64_t v8 = (unsigned __int8 *)*((void *)v3 + 2);
        BOOL v9 = *(void *)v8 == (void)v3;
        uint64_t v3 = v8;
      }
      while (!v9);
    }
    uint64_t v3 = v8;
  }
  while (v8 != v4);
  return result;
}

uint64_t *cva::ProgramOptions::Private::getValues(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 **)(a1 + 96);
  uint64_t v3 = (unsigned __int8 *)(a1 + 104);
  if (v2 == (unsigned __int8 *)(a1 + 104))
  {
LABEL_11:
    if (atomic_load_explicit((atomic_uchar *volatile)&qword_267869BD8, memory_order_acquire))
    {
      return &qword_267869BC0;
    }
    else
    {
      uint64_t v8 = &qword_267869BC0;
      if (__cxa_guard_acquire(&qword_267869BD8))
      {
        qword_267869BC0 = 0;
        *(void *)algn_267869BC8 = 0;
        qword_267869BD0 = 0;
        __cxa_atexit((void (*)(void *))sub_215432484, &qword_267869BC0, &dword_2153B7000);
        __cxa_guard_release(&qword_267869BD8);
      }
    }
  }
  else
  {
    while (!sub_215431AC8(v2 + 32, a2))
    {
      long long v5 = (unsigned __int8 *)*((void *)v2 + 1);
      if (v5)
      {
        do
        {
          uint64_t v6 = v5;
          long long v5 = *(unsigned __int8 **)v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          uint64_t v6 = (unsigned __int8 *)*((void *)v2 + 2);
          BOOL v7 = *(void *)v6 == (void)v2;
          uint64_t v2 = v6;
        }
        while (!v7);
      }
      uint64_t v2 = v6;
      if (v6 == v3) {
        goto LABEL_11;
      }
    }
    return (uint64_t *)(v2 + 80);
  }
  return v8;
}

void **sub_215432484(void **a1)
{
  uint64_t v2 = (void **)*a1;
  if (*a1)
  {
    uint64_t v3 = (void **)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        if (*((char *)v3 - 1) < 0) {
          operator delete(*(v3 - 3));
        }
        v3 -= 3;
      }
      while (v3 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

uint64_t cva::ProgramOptions::areUnregisteredCommandsAllowed(cva::ProgramOptions *this)
{
  return *(unsigned __int8 *)(*(void *)this + 144);
}

uint64_t cva::ProgramOptions::setUnregisteredCommandsAllowed(uint64_t this, char a2)
{
  *(unsigned char *)(*(void *)this + 144) = a2;
  return this;
}

uint64_t cva::ProgramOptions::parseCommands(uint64_t **this, int a2, const char *const *a3, const cva::ProgramOptions::Description *a4, char a5)
{
  BOOL v9 = *this;
  uint64_t v10 = (*this)[9];
  for (uint64_t i = (*this)[10]; i != v10; i -= 24)
  {
    if (*(char *)(i - 1) < 0) {
      operator delete(*(void **)(i - 24));
    }
  }
  v9[10] = v10;
  uint64_t v12 = (uint64_t)(*this + 13);
  sub_21543160C(*(char **)v12);
  *(void *)(v12 - 8) = v12;
  *(void *)uint64_t v12 = 0;
  *(void *)(v12 + 8) = 0;
  int v13 = *this;
  uint64_t v14 = (uint64_t)(*this + 15);
  if ((const cva::ProgramOptions::Description *)v14 != a4)
  {
    uint64_t v16 = *(void *)a4;
    uint64_t v15 = *((void *)a4 + 1);
    unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * ((v15 - *(void *)a4) >> 5);
    uint64_t v18 = v13[17];
    int v19 = (std::string *)v13[15];
    if (0xAAAAAAAAAAAAAAABLL * ((v18 - (uint64_t)v19) >> 5) < v17)
    {
      if (v19)
      {
        sub_21543151C((uint64_t)(*this + 15), v13[15]);
        operator delete(*(void **)v14);
        uint64_t v18 = 0;
        *(void *)uint64_t v14 = 0;
        *(void *)(v14 + 8) = 0;
        *(void *)(v14 + 16) = 0;
      }
      if (v17 > 0x2AAAAAAAAAAAAAALL) {
        goto LABEL_247;
      }
      unint64_t v20 = 0xAAAAAAAAAAAAAAABLL * (v18 >> 5);
      uint64_t v21 = 2 * v20;
      if (2 * v20 <= v17) {
        uint64_t v21 = v17;
      }
      unint64_t v22 = v20 >= 0x155555555555555 ? 0x2AAAAAAAAAAAAAALL : v21;
      if (v22 > 0x2AAAAAAAAAAAAAALL) {
LABEL_247:
      }
        abort();
      uint64_t v23 = 96 * v22;
      BOOL v24 = operator new(96 * v22);
      v13[15] = (uint64_t)v24;
      v13[16] = (uint64_t)v24;
      v13[17] = (uint64_t)v24 + v23;
      uint64_t v25 = v16;
      goto LABEL_20;
    }
    if (0xAAAAAAAAAAAAAAABLL * ((v13[16] - (uint64_t)v19) >> 5) < v17)
    {
      std::string::size_type v26 = (std::string *)(v16 + 32 * ((v13[16] - (uint64_t)v19) >> 5));
      sub_215433E98(*(std::string **)a4, v26, v19);
      BOOL v24 = (void *)v13[16];
      uint64_t v25 = (uint64_t)v26;
LABEL_20:
      v13[16] = sub_215433FA0(v25, v15, (uint64_t)v24);
      goto LABEL_22;
    }
    unsigned __int8 v27 = sub_215433E98(*(std::string **)a4, *((std::string **)a4 + 1), v19);
    sub_21543151C(v14, (uint64_t)v27);
  }
LABEL_22:
  uint64_t v124 = a4;
  memset(&v132, 0, sizeof(v132));
  if (a2 >= 2)
  {
    int v28 = 0;
    uint64_t v29 = a2;
    uint64_t v30 = 1;
    while (1)
    {
      uint64_t v31 = a3[v30];
      size_t v32 = strlen(v31);
      if (v32 > 0x7FFFFFFFFFFFFFF7) {
        goto LABEL_247;
      }
      size_t v33 = v32;
      if (v32 >= 0x17) {
        break;
      }
      HIBYTE(v131) = v32;
      p_dst = &__dst;
      if (v32) {
        goto LABEL_33;
      }
LABEL_34:
      *((unsigned char *)p_dst + v33) = 0;
      unint64_t v37 = HIBYTE(v131);
      if (v131 < 0)
      {
        if (v130 != 2)
        {
          if (v130 <= 2) {
            goto LABEL_98;
          }
          long long v60 = (char **)__dst;
LABEL_97:
          if (*(_WORD *)v60 != 11565)
          {
LABEL_98:
            memset(&__p, 0, sizeof(__p));
LABEL_99:
            if (v28)
            {
              std::string::size_type size = HIBYTE(v132.__r_.__value_.__r.__words[2]);
              if ((v132.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                std::string::size_type size = v132.__r_.__value_.__l.__size_;
              }
              if (!size) {
                goto LABEL_212;
              }
              cva::ProgramOptions::Private::addValue((uint64_t)*this, (uint64_t)&v132, (uint64_t)&__dst);
              if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                goto LABEL_24;
              }
LABEL_213:
              if ((SHIBYTE(v131) & 0x80000000) == 0) {
                goto LABEL_25;
              }
LABEL_214:
              operator delete(__dst);
              goto LABEL_25;
            }
            uint64_t v62 = (uint64_t)*this;
            std::operator+<char>();
            size_t v63 = std::string::append(&v126, " while parsing command ");
            std::string::size_type v64 = v63->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v127.__r_.__value_.__l.__data_ = *(_OWORD *)&v63->__r_.__value_.__l.__data_;
            v127.__r_.__value_.__r.__words[2] = v64;
            v63->__r_.__value_.__l.__size_ = 0;
            v63->__r_.__value_.__r.__words[2] = 0;
            v63->__r_.__value_.__r.__words[0] = 0;
            if ((v132.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              size_t v65 = &v132;
            }
            else {
              size_t v65 = (std::string *)v132.__r_.__value_.__r.__words[0];
            }
            if ((v132.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              std::string::size_type v66 = HIBYTE(v132.__r_.__value_.__r.__words[2]);
            }
            else {
              std::string::size_type v66 = v132.__r_.__value_.__l.__size_;
            }
            BOOL v67 = std::string::append(&v127, (const std::string::value_type *)v65, v66);
            *(_OWORD *)&v133[0].__locale_ = *(_OWORD *)&v67->__r_.__value_.__l.__data_;
            int64_t v134 = v67->__r_.__value_.__r.__words[2];
            v67->__r_.__value_.__r.__words[0] = 0;
            v67->__r_.__value_.__l.__size_ = 0;
            v67->__r_.__value_.__r.__words[2] = 0;
            unint64_t v68 = *(void *)(v62 + 80);
            if (v68 >= *(void *)(v62 + 88))
            {
              size_t v69 = sub_21541D040((void **)(v62 + 72), (uint64_t)v133);
              int v70 = SHIBYTE(v134);
              *(void *)(v62 + 80) = v69;
              if (v70 < 0)
              {
                operator delete(v133[0].__locale_);
                if ((SHIBYTE(v127.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                  goto LABEL_117;
                }
              }
              else if ((SHIBYTE(v127.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              {
                goto LABEL_117;
              }
LABEL_113:
              operator delete(v127.__r_.__value_.__l.__data_);
              if ((SHIBYTE(v126.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              {
LABEL_118:
                int v28 = 0;
                if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                  goto LABEL_213;
                }
                goto LABEL_24;
              }
            }
            else
            {
              *(_OWORD *)unint64_t v68 = *(_OWORD *)&v133[0].__locale_;
              *(void *)(v68 + 16) = v134;
              *(void *)(v62 + 80) = v68 + 24;
              if (SHIBYTE(v127.__r_.__value_.__r.__words[2]) < 0) {
                goto LABEL_113;
              }
LABEL_117:
              if ((SHIBYTE(v126.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                goto LABEL_118;
              }
            }
            operator delete(v126.__r_.__value_.__l.__data_);
            goto LABEL_118;
          }
          if (v131 < 0)
          {
            unint64_t v37 = v130;
            if (v130 < 2) {
              goto LABEL_247;
            }
            uint64_t v96 = __dst + 2;
          }
          else
          {
            uint64_t v96 = (char *)&__dst + 2;
          }
          std::string::size_type v99 = v37 - 2;
          if (v37 - 2 > 0x7FFFFFFFFFFFFFF7) {
            goto LABEL_247;
          }
          if (v99 >= 0x17)
          {
            uint64_t v101 = (v99 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v99 | 7) != 0x17) {
              uint64_t v101 = v99 | 7;
            }
            uint64_t v102 = v101 + 1;
            CFStringRef p_p = (std::string *)operator new(v101 + 1);
            __p.__r_.__value_.__l.__size_ = v99;
            __p.__r_.__value_.__r.__words[2] = v102 | 0x8000000000000000;
            __p.__r_.__value_.__r.__words[0] = (std::string::size_type)p_p;
          }
          else
          {
            *((unsigned char *)&__p.__r_.__value_.__s + 23) = v37 - 2;
            CFStringRef p_p = &__p;
            if (v37 == 2)
            {
LABEL_206:
              p_p->__r_.__value_.__s.__data_[v99] = 0;
              std::string::size_type v103 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
              if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                std::string::size_type v103 = __p.__r_.__value_.__l.__size_;
              }
              if (!v103) {
                goto LABEL_99;
              }
              goto LABEL_41;
            }
          }
          memmove(p_p, v96, v99);
          goto LABEL_206;
        }
        uint64_t v38 = (char **)__dst;
        if (*__dst != 45) {
          goto LABEL_98;
        }
      }
      else
      {
        if (HIBYTE(v131) != 2)
        {
          if (HIBYTE(v131) <= 2u) {
            goto LABEL_98;
          }
          long long v60 = &__dst;
          goto LABEL_97;
        }
        if (__dst != 45) {
          goto LABEL_98;
        }
        uint64_t v38 = &__dst;
      }
      *((unsigned char *)&__p.__r_.__value_.__s + 23) = 1;
      LOWORD(__p.__r_.__value_.__l.__data_) = *((unsigned __int8 *)v38 + 1);
LABEL_41:
      uint64_t v39 = (uint64_t)*this;
      uint64_t v40 = (*this)[15];
      uint64_t v41 = (*this)[16];
      if (v40 == v41) {
        goto LABEL_172;
      }
      while (1)
      {
        if (*(char *)(v40 + 23) < 0)
        {
          sub_2153C0AE4(v133, *(void **)v40, *(void *)(v40 + 8));
          if ((*(char *)(v40 + 47) & 0x80000000) == 0)
          {
LABEL_44:
            long long v135 = *(_OWORD *)(v40 + 24);
            uint64_t v136 = *(void *)(v40 + 40);
            goto LABEL_47;
          }
        }
        else
        {
          *(_OWORD *)&v133[0].__locale_ = *(_OWORD *)v40;
          int64_t v134 = *(void *)(v40 + 16);
          if ((*(char *)(v40 + 47) & 0x80000000) == 0) {
            goto LABEL_44;
          }
        }
        sub_2153C0AE4(&v135, *(void **)(v40 + 24), *(void *)(v40 + 32));
LABEL_47:
        uint64_t v42 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        std::string::size_type v43 = __p.__r_.__value_.__l.__size_;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v44 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v44 = __p.__r_.__value_.__l.__size_;
        }
        if (!v44) {
          goto LABEL_82;
        }
        locale = (std::locale::__imp *)HIBYTE(v134);
        if (v134 < 0) {
          locale = v133[1].__locale_;
        }
        if ((std::locale::__imp *)v44 == locale)
        {
          if (v134 >= 0) {
            uint64_t v46 = (unsigned __int8 *)v133;
          }
          else {
            uint64_t v46 = (unsigned __int8 *)v133[0].__locale_;
          }
          if ((*((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x80) != 0)
          {
            if (!memcmp(__p.__r_.__value_.__l.__data_, v46, __p.__r_.__value_.__l.__size_))
            {
LABEL_87:
              BOOL v59 = 1;
              if ((SHIBYTE(v136) & 0x80000000) == 0) {
                goto LABEL_79;
              }
              goto LABEL_83;
            }
          }
          else
          {
            if (!*((unsigned char *)&__p.__r_.__value_.__s + 23)) {
              goto LABEL_87;
            }
            uint64_t v47 = &__p;
            uint64_t v48 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
            while (v47->__r_.__value_.__s.__data_[0] == *v46)
            {
              uint64_t v47 = (std::string *)((char *)v47 + 1);
              ++v46;
              if (!--v48) {
                goto LABEL_87;
              }
            }
          }
        }
        uint64_t v49 = HIBYTE(v136);
        if (v136 < 0) {
          uint64_t v49 = *((void *)&v135 + 1);
        }
        if (v44 != v49)
        {
LABEL_82:
          BOOL v59 = 0;
          if ((SHIBYTE(v136) & 0x80000000) == 0) {
            goto LABEL_79;
          }
          goto LABEL_83;
        }
        unint64_t v50 = v136 >= 0 ? &v135 : (long long *)v135;
        if ((v42 & 0x80) != 0)
        {
          BOOL v59 = memcmp(__p.__r_.__value_.__l.__data_, v50, v43) == 0;
          if ((SHIBYTE(v136) & 0x80000000) == 0) {
            goto LABEL_79;
          }
        }
        else if (v42)
        {
          uint64_t v51 = v42 - 1;
          int v52 = &__p;
          do
          {
            int v54 = v52->__r_.__value_.__s.__data_[0];
            int v52 = (std::string *)((char *)v52 + 1);
            int v53 = v54;
            int v56 = *(unsigned __int8 *)v50;
            unint64_t v50 = (long long *)((char *)v50 + 1);
            int v55 = v56;
            BOOL v57 = v51-- != 0;
            char v58 = v57;
            BOOL v59 = v53 == v55;
          }
          while (v53 == v55 && (v58 & 1) != 0);
          if ((SHIBYTE(v136) & 0x80000000) == 0)
          {
LABEL_79:
            if ((SHIBYTE(v134) & 0x80000000) == 0) {
              goto LABEL_80;
            }
            goto LABEL_84;
          }
        }
        else
        {
          BOOL v59 = 1;
          if ((SHIBYTE(v136) & 0x80000000) == 0) {
            goto LABEL_79;
          }
        }
LABEL_83:
        operator delete((void *)v135);
        if ((SHIBYTE(v134) & 0x80000000) == 0)
        {
LABEL_80:
          if (v59) {
            break;
          }
          goto LABEL_85;
        }
LABEL_84:
        operator delete(v133[0].__locale_);
        if (v59) {
          break;
        }
LABEL_85:
        v40 += 96;
        if (v40 == v41)
        {
          uint64_t v39 = (uint64_t)*this;
LABEL_172:
          if (*(unsigned char *)(v39 + 144)) {
            goto LABEL_192;
          }
          std::operator+<char>();
          int v90 = std::string::append(&v126, " while parsing token ");
          std::string::size_type v91 = v90->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v127.__r_.__value_.__l.__data_ = *(_OWORD *)&v90->__r_.__value_.__l.__data_;
          v127.__r_.__value_.__r.__words[2] = v91;
          v90->__r_.__value_.__l.__size_ = 0;
          v90->__r_.__value_.__r.__words[2] = 0;
          v90->__r_.__value_.__r.__words[0] = 0;
          if (v131 >= 0) {
            long long v92 = (const std::string::value_type *)&__dst;
          }
          else {
            long long v92 = __dst;
          }
          if (v131 >= 0) {
            std::string::size_type v93 = HIBYTE(v131);
          }
          else {
            std::string::size_type v93 = v130;
          }
          unsigned int v94 = std::string::append(&v127, v92, v93);
          *(_OWORD *)&v133[0].__locale_ = *(_OWORD *)&v94->__r_.__value_.__l.__data_;
          int64_t v134 = v94->__r_.__value_.__r.__words[2];
          v94->__r_.__value_.__r.__words[0] = 0;
          v94->__r_.__value_.__l.__size_ = 0;
          v94->__r_.__value_.__r.__words[2] = 0;
          unint64_t v95 = *(void *)(v39 + 80);
          if (v95 >= *(void *)(v39 + 88))
          {
            int v97 = sub_21541D040((void **)(v39 + 72), (uint64_t)v133);
            int v98 = SHIBYTE(v134);
            *(void *)(v39 + 80) = v97;
            if (v98 < 0)
            {
              operator delete(v133[0].__locale_);
              if ((SHIBYTE(v127.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                goto LABEL_191;
              }
            }
            else if ((SHIBYTE(v127.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
              goto LABEL_191;
            }
LABEL_181:
            operator delete(v127.__r_.__value_.__l.__data_);
            if (SHIBYTE(v126.__r_.__value_.__r.__words[2]) < 0) {
              goto LABEL_182;
            }
LABEL_192:
            if ((SHIBYTE(v132.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_193;
            }
LABEL_183:
            *v132.__r_.__value_.__l.__data_ = 0;
            v132.__r_.__value_.__l.__size_ = 0;
          }
          else
          {
            *(_OWORD *)unint64_t v95 = *(_OWORD *)&v133[0].__locale_;
            *(void *)(v95 + 16) = v134;
            *(void *)(v39 + 80) = v95 + 24;
            if (SHIBYTE(v127.__r_.__value_.__r.__words[2]) < 0) {
              goto LABEL_181;
            }
LABEL_191:
            if ((SHIBYTE(v126.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_192;
            }
LABEL_182:
            operator delete(v126.__r_.__value_.__l.__data_);
            if (SHIBYTE(v132.__r_.__value_.__r.__words[2]) < 0) {
              goto LABEL_183;
            }
LABEL_193:
            v132.__r_.__value_.__s.__data_[0] = 0;
            *((unsigned char *)&v132.__r_.__value_.__s + 23) = 0;
          }
          int v28 = -1;
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_213;
          }
          goto LABEL_24;
        }
      }
      uint64_t v71 = (*this)[15];
      uint64_t v72 = (*this)[16];
      if (v71 == v72)
      {
LABEL_186:
        int v28 = 0;
        goto LABEL_211;
      }
      while (2)
      {
        if (*(char *)(v71 + 23) < 0)
        {
          sub_2153C0AE4(v133, *(void **)v71, *(void *)(v71 + 8));
          if (*(char *)(v71 + 47) < 0) {
            goto LABEL_125;
          }
LABEL_123:
          long long v135 = *(_OWORD *)(v71 + 24);
          uint64_t v136 = *(void *)(v71 + 40);
        }
        else
        {
          *(_OWORD *)&v133[0].__locale_ = *(_OWORD *)v71;
          int64_t v134 = *(void *)(v71 + 16);
          if ((*(char *)(v71 + 47) & 0x80000000) == 0) {
            goto LABEL_123;
          }
LABEL_125:
          sub_2153C0AE4(&v135, *(void **)(v71 + 24), *(void *)(v71 + 32));
        }
        uint64_t v73 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        std::string::size_type v74 = __p.__r_.__value_.__l.__size_;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v75 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v75 = __p.__r_.__value_.__l.__size_;
        }
        if (!v75) {
          goto LABEL_161;
        }
        std::string::size_type v76 = (std::locale::__imp *)HIBYTE(v134);
        if (v134 < 0) {
          std::string::size_type v76 = v133[1].__locale_;
        }
        if ((std::locale::__imp *)v75 != v76) {
          goto LABEL_143;
        }
        if (v134 >= 0) {
          uint64_t v77 = (unsigned __int8 *)v133;
        }
        else {
          uint64_t v77 = (unsigned __int8 *)v133[0].__locale_;
        }
        if ((*((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x80) != 0)
        {
          if (memcmp(__p.__r_.__value_.__l.__data_, v77, __p.__r_.__value_.__l.__size_)) {
            goto LABEL_143;
          }
LABEL_166:
          BOOL v89 = 1;
          if ((SHIBYTE(v136) & 0x80000000) == 0) {
            goto LABEL_158;
          }
LABEL_162:
          operator delete((void *)v135);
          if ((SHIBYTE(v134) & 0x80000000) == 0) {
            goto LABEL_159;
          }
          goto LABEL_163;
        }
        if (!*((unsigned char *)&__p.__r_.__value_.__s + 23)) {
          goto LABEL_166;
        }
        uint64_t v78 = &__p;
        uint64_t v79 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        while (v78->__r_.__value_.__s.__data_[0] == *v77)
        {
          uint64_t v78 = (std::string *)((char *)v78 + 1);
          ++v77;
          if (!--v79) {
            goto LABEL_166;
          }
        }
LABEL_143:
        uint64_t v80 = HIBYTE(v136);
        if (v136 < 0) {
          uint64_t v80 = *((void *)&v135 + 1);
        }
        if (v75 != v80)
        {
LABEL_161:
          BOOL v89 = 0;
          if ((SHIBYTE(v136) & 0x80000000) == 0) {
            goto LABEL_158;
          }
          goto LABEL_162;
        }
        if (v136 >= 0) {
          uint64_t v81 = &v135;
        }
        else {
          uint64_t v81 = (long long *)v135;
        }
        if ((v73 & 0x80) != 0)
        {
          BOOL v89 = memcmp(__p.__r_.__value_.__l.__data_, v81, v74) == 0;
          if ((SHIBYTE(v136) & 0x80000000) == 0) {
            goto LABEL_158;
          }
          goto LABEL_162;
        }
        if (!v73)
        {
          BOOL v89 = 1;
          if ((SHIBYTE(v136) & 0x80000000) == 0) {
            goto LABEL_158;
          }
          goto LABEL_162;
        }
        uint64_t v82 = v73 - 1;
        long long v83 = &__p;
        do
        {
          int v85 = v83->__r_.__value_.__s.__data_[0];
          long long v83 = (std::string *)((char *)v83 + 1);
          int v84 = v85;
          int v87 = *(unsigned __int8 *)v81;
          uint64_t v81 = (long long *)((char *)v81 + 1);
          int v86 = v87;
          BOOL v57 = v82-- != 0;
          char v88 = v57;
          BOOL v89 = v84 == v86;
        }
        while (v84 == v86 && (v88 & 1) != 0);
        if (SHIBYTE(v136) < 0) {
          goto LABEL_162;
        }
LABEL_158:
        if ((SHIBYTE(v134) & 0x80000000) == 0)
        {
LABEL_159:
          if (v89) {
            break;
          }
          goto LABEL_164;
        }
LABEL_163:
        operator delete(v133[0].__locale_);
        if (!v89)
        {
LABEL_164:
          v71 += 96;
          if (v71 == v72) {
            goto LABEL_186;
          }
          continue;
        }
        break;
      }
      int v28 = *(_DWORD *)(v71 + 88);
LABEL_211:
      std::string::operator=(&v132, &__p);
      cva::ProgramOptions::Private::registerCommand((uint64_t)*this, (uint64_t)&__p);
LABEL_212:
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_213;
      }
LABEL_24:
      operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v131) < 0) {
        goto LABEL_214;
      }
LABEL_25:
      if (++v30 == v29) {
        goto LABEL_217;
      }
    }
    uint64_t v35 = (v32 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v32 | 7) != 0x17) {
      uint64_t v35 = v32 | 7;
    }
    uint64_t v36 = v35 + 1;
    p_dst = (char **)operator new(v35 + 1);
    unint64_t v130 = v33;
    int64_t v131 = v36 | 0x8000000000000000;
    long long __dst = (char *)p_dst;
LABEL_33:
    memmove(p_dst, v31, v33);
    goto LABEL_34;
  }
LABEL_217:
  uint64_t v104 = *this;
  if (a5)
  {
    HIBYTE(v134) = 4;
    strcpy((char *)v133, "help");
    uint64_t v105 = (unsigned __int8 *)v104[12];
    if (v105 != (unsigned __int8 *)(v104 + 13))
    {
      while (!sub_215431AC8(v105 + 32, (uint64_t)v133))
      {
        BOOL v106 = (uint64_t *)*((void *)v105 + 1);
        if (v106)
        {
          do
          {
            v107 = v106;
            BOOL v106 = (uint64_t *)*v106;
          }
          while (v106);
        }
        else
        {
          do
          {
            v107 = (uint64_t *)*((void *)v105 + 2);
            BOOL v108 = *v107 == (void)v105;
            uint64_t v105 = (unsigned __int8 *)v107;
          }
          while (!v108);
        }
        uint64_t v105 = (unsigned __int8 *)v107;
        if (v107 == v104 + 13) {
          goto LABEL_228;
        }
      }
      cva::ProgramOptions::display_help(this, v124);
      uint64_t v109 = (uint64_t)*this;
      uint64_t v122 = (*this)[9];
      uint64_t v123 = (*this)[10];
      int v120 = 1;
      if (v122 != v123)
      {
        int v119 = 0;
        if ((SHIBYTE(v132.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          return v119 & (v120 ^ 1u);
        }
        goto LABEL_239;
      }
LABEL_242:
      cva::ProgramOptions::Description::set_default_arguments((uint64_t *)(v109 + 120), (uint64_t **)(v109 + 96));
      int v119 = 1;
      if ((SHIBYTE(v132.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        return v119 & (v120 ^ 1u);
      }
      goto LABEL_239;
    }
  }
LABEL_228:
  cva::ProgramOptions::Private::checkCommand((cva::ProgramOptions::Private *)v104);
  uint64_t v109 = (uint64_t)*this;
  if ((*this)[9] == (*this)[10])
  {
    int v120 = 0;
    goto LABEL_242;
  }
  uint64_t v110 = (void *)MEMORY[0x263F8C100];
  sub_2153C1168(MEMORY[0x263F8C100], (uint64_t)"Could not parse commandline:", 28);
  std::ios_base::getloc((const std::ios_base *)((char *)v110 + *(void *)(*v110 - 24)));
  uint64_t v111 = std::locale::use_facet(v133, MEMORY[0x263F8C108]);
  ((void (*)(const std::locale::facet *, uint64_t))v111->__vftable[2].~facet_0)(v111, 10);
  std::locale::~locale(v133);
  std::ostream::put();
  std::ostream::flush();
  uint64_t v112 = (*this)[9];
  uint64_t v113 = (*this)[10];
  if (v112 != v113)
  {
    uint64_t v114 = (std::locale::id *)MEMORY[0x263F8C108];
    do
    {
      int v115 = *(char *)(v112 + 23);
      if (v115 >= 0) {
        uint64_t v116 = v112;
      }
      else {
        uint64_t v116 = *(void *)v112;
      }
      if (v115 >= 0) {
        uint64_t v117 = *(unsigned __int8 *)(v112 + 23);
      }
      else {
        uint64_t v117 = *(void *)(v112 + 8);
      }
      sub_2153C1168(v110, v116, v117);
      std::ios_base::getloc((const std::ios_base *)((char *)v110 + *(void *)(*v110 - 24)));
      v118 = std::locale::use_facet(v133, v114);
      ((void (*)(const std::locale::facet *, uint64_t))v118->__vftable[2].~facet_0)(v118, 10);
      std::locale::~locale(v133);
      std::ostream::put();
      std::ostream::flush();
      v112 += 24;
    }
    while (v112 != v113);
  }
  int v119 = 0;
  int v120 = 0;
  if (SHIBYTE(v132.__r_.__value_.__r.__words[2]) < 0) {
LABEL_239:
  }
    operator delete(v132.__r_.__value_.__l.__data_);
  return v119 & (v120 ^ 1u);
}