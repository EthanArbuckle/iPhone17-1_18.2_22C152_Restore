void sub_20F465FC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,char a37)
{
  std::__shared_weak_count *v37;
  void *v38;
  int v39;

  if (a28 < 0) {
    operator delete(__p);
  }
  if (a22 < 0)
  {
    operator delete(a17);
    if ((v39 & 1) == 0)
    {
LABEL_8:
      if (a35 < 0) {
        operator delete(a30);
      }
      if (v37) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v37);
      }
      std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a37);
      _Unwind_Resume(a1);
    }
  }
  else if (!v39)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v38);
  goto LABEL_8;
}

uint64_t MIL::Text::BasicSerializer::Val<MIL::UInt3>(uint64_t a1, MIL::IRTensorValue *a2)
{
  uint64_t v4 = *(void *)(a1 + 384);
  if (v4)
  {
    Type = (MIL::IRValueType *)MIL::IRTypedTensorValue<MIL::UInt3>::GetType((uint64_t)a2);
    uint64_t v6 = MIL::IRValueType::AsTensorType(Type);
    unint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 16))(v6);
    int v8 = v7 >= (*(uint64_t (**)(void))(**(void **)(a1 + 320) + 136))(*(void *)(a1 + 320));
  }
  else
  {
    int v8 = MIL::IRTypedTensorValue<MIL::UInt3>::UsesFileStorage((uint64_t)a2);
  }
  v9 = (MIL::IRValueType *)MIL::IRTypedTensorValue<MIL::UInt3>::GetType((uint64_t)a2);
  uint64_t v10 = MIL::IRValueType::AsTensorType(v9);
  unsigned int v11 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 88))(v10);
  int v12 = v11;
  if (!v4 || !v8 || (v11 <= 0x19 ? (BOOL v13 = ((1 << v11) & 0x3F9EE30) == 0) : (BOOL v13 = 1), !v13))
  {
    if (v8)
    {
      memset(v71, 0, sizeof(v71));
      int v72 = 1065353216;
      if (!v4)
      {
        uint64_t FileProperties = MIL::IRTypedTensorValue<MIL::UInt3>::GetFileProperties((uint64_t)a2);
        if (v71 != (_OWORD *)FileProperties)
        {
          int v72 = *(_DWORD *)(FileProperties + 32);
          std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *> *>>(v71, *(uint64_t **)(FileProperties + 16), 0);
        }
        std::string::basic_string[abi:ne180100]<0>(&__str, "type");
        v56 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>(v71, (unsigned __int8 *)&__str);
        if (v56)
        {
          MIL::IRValue::GetScalar<std::string>(*((const void **)v56 + 5), &__p);
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          std::string::basic_string[abi:ne180100]<0>(&__str, "type");
          std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__erase_unique<std::string>(v71, (unsigned __int8 *)&__str);
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          std::string::basic_string[abi:ne180100]<0>(&__str, "path");
          v57 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>(v71, (unsigned __int8 *)&__str);
          if (v57)
          {
            v59 = (const void *)*((void *)v57 + 5);
            uint64_t v58 = *((void *)v57 + 6);
            if (v58) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v58 + 8), 1uLL, memory_order_relaxed);
            }
            if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__str.__r_.__value_.__l.__data_);
            }
            MIL::IRValue::GetScalar<std::string>(v59, &__str);
            v60 = (void *)(*(uint64_t (**)(void))(**(void **)(a1 + 320) + 32))(*(void *)(a1 + 320));
            MIL::Util::ReplaceModelPaths(&__str, v60);
            v61 = (MIL::IRValueType *)(*(uint64_t (**)(const void *))(*(void *)v59 + 32))(v59);
            v62 = (_anonymous_namespace_ *)MIL::IRValueType::AsTensorType(v61);
            std::string v67 = __str;
            memset(&__str, 0, sizeof(__str));
            MIL::IRTensorValueType::MakeStringValue(v62, (const MIL::IRTensorValueType *)&v67);
          }
          std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
        }
        std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
      }
      uint64_t v14 = a1 + 368;
      if (MIL::IRTypedTensorValue<MIL::UInt3>::UsesFileStorage((uint64_t)a2))
      {
        v15 = (void *)MIL::IRTypedTensorValue<MIL::UInt3>::GetFileProperties((uint64_t)a2);
        std::string::basic_string[abi:ne180100]<0>(&__p, "path");
        v16 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v15, (unsigned __int8 *)&__p);
        if (!v16) {
          std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
        }
        v17 = (const void *)*((void *)v16 + 5);
        v18 = (std::__shared_weak_count *)*((void *)v16 + 6);
        if (v18) {
          atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        MIL::IRValue::GetScalar<std::string>(v17, &__p);
        __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p;
        v19 = std::__tree<std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)(a1 + 368), (const void **)&__p.__r_.__value_.__l.__data_, (uint64_t)&std::piecewise_construct, &__str);
        v21 = (MIL::Blob::StorageWriter *)*((void *)v19 + 7);
        uint64_t v20 = *((void *)v19 + 8);
        if (v20) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (v18) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v18);
        }
      }
      else
      {
        v21 = *(MIL::Blob::StorageWriter **)(*(void *)v14 + 56);
        uint64_t v23 = *(void *)(*(void *)v14 + 64);
        if (v23) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v23 + 8), 1uLL, memory_order_relaxed);
        }
      }
      memset(&__p, 0, sizeof(__p));
      uint64_t v73 = 0;
      if (!MIL::IRTypedTensorValue<MIL::UInt3>::UsesFileStorage((uint64_t)a2)) {
        goto LABEL_59;
      }
      v24 = (void *)MIL::IRTypedTensorValue<MIL::UInt3>::GetFileProperties((uint64_t)a2);
      std::string::basic_string[abi:ne180100]<0>(&__str, "path");
      v25 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v24, (unsigned __int8 *)&__str);
      if (!v25) {
        std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
      }
      v27 = (const void *)*((void *)v25 + 5);
      v26 = (std::__shared_weak_count *)*((void *)v25 + 6);
      if (v26) {
        atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str.__r_.__value_.__l.__data_);
      }
      MIL::IRValue::GetScalar<std::string>(v27, &__str);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      std::string __p = __str;
      std::string::basic_string[abi:ne180100]<0>(&__str, "offset");
      v28 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v24, (unsigned __int8 *)&__str);
      v29 = v28;
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__str.__r_.__value_.__l.__data_);
        if (v29)
        {
LABEL_39:
          std::string::basic_string[abi:ne180100]<0>(&__str, "offset");
          v30 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v24, (unsigned __int8 *)&__str);
          if (!v30) {
            std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
          }
          v31 = (const void *)*((void *)v30 + 5);
          v32 = (std::__shared_weak_count *)*((void *)v30 + 6);
          if (v32) {
            atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          uint64_t v73 = MIL::IRValue::GetScalar<unsigned long long>(v31);
          if (std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>((void *)(a1 + 328), (unsigned __int8 *)&__p))
          {
            v33 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>((void *)(a1 + 328), (unsigned __int8 *)&__p);
            if (!v33) {
              goto LABEL_94;
            }
            v34 = v33 + 40;
            if (std::__hash_table<std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>>>::find<unsigned long long>((void *)v33 + 5, (unint64_t *)&v73))
            {
              if (std::__hash_table<std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>>>::find<unsigned long long>(v34, (unint64_t *)&v73))
              {
                char v35 = 1;
                goto LABEL_50;
              }
LABEL_94:
              std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
            }
          }
          char v35 = 0;
LABEL_50:
          if (v32) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v32);
          }
          if (v26) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v26);
          }
          if (v35)
          {
LABEL_78:
            uint64_t v55 = MIL::IRTypedTensorValue<MIL::UInt3>::GetType((uint64_t)a2);
            (*(void (**)(uint64_t))(*(void *)v55 + 24))(v55);
            MIL::Blob::StorageWriter::GetFilePath(v21, &__str);
            MIL::IRTensorValueType::MakeValueFromBlobFile();
          }
LABEL_59:
          switch(v12)
          {
            case 4:
              v36 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::Fp16>(v36);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::Fp16>((uint64_t *)v21);
              break;
            case 5:
              v51 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<float>(v51);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<float>((uint64_t *)v21);
              break;
            case 9:
              v48 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<signed char>(v48);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<signed char>((uint64_t *)v21);
              break;
            case 10:
              v50 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<short>(v50);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<short>((uint64_t *)v21);
              break;
            case 11:
              v45 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<int>(v45);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<int>((uint64_t *)v21);
              break;
            case 13:
              v47 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::Int4>(v47);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::Int4>((uint64_t *)v21);
              break;
            case 14:
              v52 = (void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<unsigned char>(v52);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<unsigned char>((uint64_t *)v21);
              break;
            case 15:
              v49 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<unsigned short>(v49);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<unsigned short>((uint64_t *)v21);
              break;
            case 16:
              v42 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<unsigned int>(v42);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<unsigned int>((uint64_t *)v21);
              break;
            case 19:
              v39 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::UInt2>(v39);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::UInt2>((uint64_t *)v21);
              break;
            case 20:
              v41 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::UInt4>(v41);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::UInt4>((uint64_t *)v21);
              break;
            case 21:
              v38 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::UInt1>(v38);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::UInt1>((uint64_t *)v21);
              break;
            case 22:
              v40 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::UInt3>(v40);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::UInt3>((uint64_t *)v21);
              break;
            case 23:
              v43 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::UInt6>(v43);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::UInt6>((uint64_t *)v21);
              break;
            case 24:
              v44 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::Fp8E4M3FN>(v44);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::Fp8E4M3FN>((uint64_t *)v21);
              break;
            case 25:
              v46 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::Fp8E5M2>(v46);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::Fp8E5M2>((uint64_t *)v21);
              break;
            default:
              exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
              MIL::IRDataTypeToString(v12, &v68);
              v65 = std::string::insert(&v68, 0, "[MIL Serialization] Unsupported Data type ");
              long long v66 = *(_OWORD *)&v65->__r_.__value_.__l.__data_;
              __str.__r_.__value_.__r.__words[2] = v65->__r_.__value_.__r.__words[2];
              *(_OWORD *)&__str.__r_.__value_.__l.__data_ = v66;
              v65->__r_.__value_.__l.__size_ = 0;
              v65->__r_.__value_.__r.__words[2] = 0;
              v65->__r_.__value_.__r.__words[0] = 0;
              std::logic_error::logic_error(exception, &__str);
              exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
              __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
          }
          unint64_t v53 = v37;
          if (MIL::IRTypedTensorValue<MIL::UInt3>::UsesFileStorage((uint64_t)a2))
          {
            __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p;
            v54 = std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1 + 328, (unsigned __int8 *)&__p, (uint64_t)&std::piecewise_construct, (long long **)&__str);
            __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&v73;
            std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t)(v54 + 40), (unint64_t *)&v73, (uint64_t)&std::piecewise_construct, &__str)[3] = v53;
          }
          goto LABEL_78;
        }
      }
      else if (v28)
      {
        goto LABEL_39;
      }
      if (v26) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v26);
      }
      goto LABEL_59;
    }
  }
  ValHelperForSubByteTypes<MIL::UInt3>((uint64_t)a2, *(void **)(a1 + 40));
  return a1;
}

void sub_20F466E80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,char a37)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a22 < 0)
  {
    operator delete(a17);
    if ((v39 & 1) == 0)
    {
LABEL_8:
      if (a35 < 0) {
        operator delete(a30);
      }
      if (v37) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v37);
      }
      std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a37);
      _Unwind_Resume(a1);
    }
  }
  else if (!v39)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v38);
  goto LABEL_8;
}

uint64_t MIL::Text::BasicSerializer::Val<MIL::UInt4>(uint64_t a1, MIL::IRTensorValue *a2)
{
  uint64_t v4 = *(void *)(a1 + 384);
  if (v4)
  {
    Type = (MIL::IRValueType *)MIL::IRTypedTensorValue<MIL::UInt4>::GetType((uint64_t)a2);
    uint64_t v6 = MIL::IRValueType::AsTensorType(Type);
    unint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 16))(v6);
    int v8 = v7 >= (*(uint64_t (**)(void))(**(void **)(a1 + 320) + 136))(*(void *)(a1 + 320));
  }
  else
  {
    int v8 = MIL::IRTypedTensorValue<MIL::UInt4>::UsesFileStorage((uint64_t)a2);
  }
  v9 = (MIL::IRValueType *)MIL::IRTypedTensorValue<MIL::UInt4>::GetType((uint64_t)a2);
  uint64_t v10 = MIL::IRValueType::AsTensorType(v9);
  unsigned int v11 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 88))(v10);
  int v12 = v11;
  if (!v4 || !v8 || (v11 <= 0x19 ? (BOOL v13 = ((1 << v11) & 0x3F9EE30) == 0) : (BOOL v13 = 1), !v13))
  {
    if (v8)
    {
      memset(v71, 0, sizeof(v71));
      int v72 = 1065353216;
      if (!v4)
      {
        uint64_t FileProperties = MIL::IRTypedTensorValue<MIL::UInt4>::GetFileProperties((uint64_t)a2);
        if (v71 != (_OWORD *)FileProperties)
        {
          int v72 = *(_DWORD *)(FileProperties + 32);
          std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *> *>>(v71, *(uint64_t **)(FileProperties + 16), 0);
        }
        std::string::basic_string[abi:ne180100]<0>(&__str, "type");
        v56 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>(v71, (unsigned __int8 *)&__str);
        if (v56)
        {
          MIL::IRValue::GetScalar<std::string>(*((const void **)v56 + 5), &__p);
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          std::string::basic_string[abi:ne180100]<0>(&__str, "type");
          std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__erase_unique<std::string>(v71, (unsigned __int8 *)&__str);
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          std::string::basic_string[abi:ne180100]<0>(&__str, "path");
          v57 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>(v71, (unsigned __int8 *)&__str);
          if (v57)
          {
            v59 = (const void *)*((void *)v57 + 5);
            uint64_t v58 = *((void *)v57 + 6);
            if (v58) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v58 + 8), 1uLL, memory_order_relaxed);
            }
            if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__str.__r_.__value_.__l.__data_);
            }
            MIL::IRValue::GetScalar<std::string>(v59, &__str);
            v60 = (void *)(*(uint64_t (**)(void))(**(void **)(a1 + 320) + 32))(*(void *)(a1 + 320));
            MIL::Util::ReplaceModelPaths(&__str, v60);
            v61 = (MIL::IRValueType *)(*(uint64_t (**)(const void *))(*(void *)v59 + 32))(v59);
            v62 = (_anonymous_namespace_ *)MIL::IRValueType::AsTensorType(v61);
            std::string v67 = __str;
            memset(&__str, 0, sizeof(__str));
            MIL::IRTensorValueType::MakeStringValue(v62, (const MIL::IRTensorValueType *)&v67);
          }
          std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
        }
        std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
      }
      uint64_t v14 = a1 + 368;
      if (MIL::IRTypedTensorValue<MIL::UInt4>::UsesFileStorage((uint64_t)a2))
      {
        v15 = (void *)MIL::IRTypedTensorValue<MIL::UInt4>::GetFileProperties((uint64_t)a2);
        std::string::basic_string[abi:ne180100]<0>(&__p, "path");
        v16 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v15, (unsigned __int8 *)&__p);
        if (!v16) {
          std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
        }
        v17 = (const void *)*((void *)v16 + 5);
        v18 = (std::__shared_weak_count *)*((void *)v16 + 6);
        if (v18) {
          atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        MIL::IRValue::GetScalar<std::string>(v17, &__p);
        __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p;
        v19 = std::__tree<std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)(a1 + 368), (const void **)&__p.__r_.__value_.__l.__data_, (uint64_t)&std::piecewise_construct, &__str);
        v21 = (MIL::Blob::StorageWriter *)*((void *)v19 + 7);
        uint64_t v20 = *((void *)v19 + 8);
        if (v20) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (v18) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v18);
        }
      }
      else
      {
        v21 = *(MIL::Blob::StorageWriter **)(*(void *)v14 + 56);
        uint64_t v23 = *(void *)(*(void *)v14 + 64);
        if (v23) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v23 + 8), 1uLL, memory_order_relaxed);
        }
      }
      memset(&__p, 0, sizeof(__p));
      uint64_t v73 = 0;
      if (!MIL::IRTypedTensorValue<MIL::UInt4>::UsesFileStorage((uint64_t)a2)) {
        goto LABEL_59;
      }
      v24 = (void *)MIL::IRTypedTensorValue<MIL::UInt4>::GetFileProperties((uint64_t)a2);
      std::string::basic_string[abi:ne180100]<0>(&__str, "path");
      v25 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v24, (unsigned __int8 *)&__str);
      if (!v25) {
        std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
      }
      v27 = (const void *)*((void *)v25 + 5);
      v26 = (std::__shared_weak_count *)*((void *)v25 + 6);
      if (v26) {
        atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str.__r_.__value_.__l.__data_);
      }
      MIL::IRValue::GetScalar<std::string>(v27, &__str);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      std::string __p = __str;
      std::string::basic_string[abi:ne180100]<0>(&__str, "offset");
      v28 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v24, (unsigned __int8 *)&__str);
      v29 = v28;
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__str.__r_.__value_.__l.__data_);
        if (v29)
        {
LABEL_39:
          std::string::basic_string[abi:ne180100]<0>(&__str, "offset");
          v30 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v24, (unsigned __int8 *)&__str);
          if (!v30) {
            std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
          }
          v31 = (const void *)*((void *)v30 + 5);
          v32 = (std::__shared_weak_count *)*((void *)v30 + 6);
          if (v32) {
            atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          uint64_t v73 = MIL::IRValue::GetScalar<unsigned long long>(v31);
          if (std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>((void *)(a1 + 328), (unsigned __int8 *)&__p))
          {
            v33 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>((void *)(a1 + 328), (unsigned __int8 *)&__p);
            if (!v33) {
              goto LABEL_94;
            }
            v34 = v33 + 40;
            if (std::__hash_table<std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>>>::find<unsigned long long>((void *)v33 + 5, (unint64_t *)&v73))
            {
              if (std::__hash_table<std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>>>::find<unsigned long long>(v34, (unint64_t *)&v73))
              {
                char v35 = 1;
                goto LABEL_50;
              }
LABEL_94:
              std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
            }
          }
          char v35 = 0;
LABEL_50:
          if (v32) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v32);
          }
          if (v26) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v26);
          }
          if (v35)
          {
LABEL_78:
            uint64_t v55 = MIL::IRTypedTensorValue<MIL::UInt4>::GetType((uint64_t)a2);
            (*(void (**)(uint64_t))(*(void *)v55 + 24))(v55);
            MIL::Blob::StorageWriter::GetFilePath(v21, &__str);
            MIL::IRTensorValueType::MakeValueFromBlobFile();
          }
LABEL_59:
          switch(v12)
          {
            case 4:
              v36 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::Fp16>(v36);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::Fp16>((uint64_t *)v21);
              break;
            case 5:
              v51 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<float>(v51);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<float>((uint64_t *)v21);
              break;
            case 9:
              v48 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<signed char>(v48);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<signed char>((uint64_t *)v21);
              break;
            case 10:
              v50 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<short>(v50);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<short>((uint64_t *)v21);
              break;
            case 11:
              v45 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<int>(v45);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<int>((uint64_t *)v21);
              break;
            case 13:
              v47 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::Int4>(v47);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::Int4>((uint64_t *)v21);
              break;
            case 14:
              v52 = (void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<unsigned char>(v52);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<unsigned char>((uint64_t *)v21);
              break;
            case 15:
              v49 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<unsigned short>(v49);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<unsigned short>((uint64_t *)v21);
              break;
            case 16:
              v42 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<unsigned int>(v42);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<unsigned int>((uint64_t *)v21);
              break;
            case 19:
              int v39 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::UInt2>(v39);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::UInt2>((uint64_t *)v21);
              break;
            case 20:
              v41 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::UInt4>(v41);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::UInt4>((uint64_t *)v21);
              break;
            case 21:
              v38 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::UInt1>(v38);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::UInt1>((uint64_t *)v21);
              break;
            case 22:
              v40 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::UInt3>(v40);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::UInt3>((uint64_t *)v21);
              break;
            case 23:
              v43 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::UInt6>(v43);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::UInt6>((uint64_t *)v21);
              break;
            case 24:
              v44 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::Fp8E4M3FN>(v44);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::Fp8E4M3FN>((uint64_t *)v21);
              break;
            case 25:
              v46 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::Fp8E5M2>(v46);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::Fp8E5M2>((uint64_t *)v21);
              break;
            default:
              exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
              MIL::IRDataTypeToString(v12, &v68);
              v65 = std::string::insert(&v68, 0, "[MIL Serialization] Unsupported Data type ");
              long long v66 = *(_OWORD *)&v65->__r_.__value_.__l.__data_;
              __str.__r_.__value_.__r.__words[2] = v65->__r_.__value_.__r.__words[2];
              *(_OWORD *)&__str.__r_.__value_.__l.__data_ = v66;
              v65->__r_.__value_.__l.__size_ = 0;
              v65->__r_.__value_.__r.__words[2] = 0;
              v65->__r_.__value_.__r.__words[0] = 0;
              std::logic_error::logic_error(exception, &__str);
              exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
              __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
          }
          unint64_t v53 = v37;
          if (MIL::IRTypedTensorValue<MIL::UInt4>::UsesFileStorage((uint64_t)a2))
          {
            __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p;
            v54 = std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1 + 328, (unsigned __int8 *)&__p, (uint64_t)&std::piecewise_construct, (long long **)&__str);
            __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&v73;
            std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t)(v54 + 40), (unint64_t *)&v73, (uint64_t)&std::piecewise_construct, &__str)[3] = v53;
          }
          goto LABEL_78;
        }
      }
      else if (v28)
      {
        goto LABEL_39;
      }
      if (v26) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v26);
      }
      goto LABEL_59;
    }
  }
  ValHelperForSubByteTypes<MIL::UInt4>((uint64_t)a2, *(void **)(a1 + 40));
  return a1;
}

void sub_20F467D40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,char a37)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a22 < 0)
  {
    operator delete(a17);
    if ((v39 & 1) == 0)
    {
LABEL_8:
      if (a35 < 0) {
        operator delete(a30);
      }
      if (v37) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v37);
      }
      std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a37);
      _Unwind_Resume(a1);
    }
  }
  else if (!v39)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v38);
  goto LABEL_8;
}

uint64_t MIL::Text::BasicSerializer::Val<MIL::UInt6>(uint64_t a1, MIL::IRTensorValue *a2)
{
  uint64_t v4 = *(void *)(a1 + 384);
  if (v4)
  {
    Type = (MIL::IRValueType *)MIL::IRTypedTensorValue<MIL::UInt6>::GetType((uint64_t)a2);
    uint64_t v6 = MIL::IRValueType::AsTensorType(Type);
    unint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 16))(v6);
    int v8 = v7 >= (*(uint64_t (**)(void))(**(void **)(a1 + 320) + 136))(*(void *)(a1 + 320));
  }
  else
  {
    int v8 = MIL::IRTypedTensorValue<MIL::UInt6>::UsesFileStorage((uint64_t)a2);
  }
  v9 = (MIL::IRValueType *)MIL::IRTypedTensorValue<MIL::UInt6>::GetType((uint64_t)a2);
  uint64_t v10 = MIL::IRValueType::AsTensorType(v9);
  unsigned int v11 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 88))(v10);
  int v12 = v11;
  if (!v4 || !v8 || (v11 <= 0x19 ? (BOOL v13 = ((1 << v11) & 0x3F9EE30) == 0) : (BOOL v13 = 1), !v13))
  {
    if (v8)
    {
      memset(v71, 0, sizeof(v71));
      int v72 = 1065353216;
      if (!v4)
      {
        uint64_t FileProperties = MIL::IRTypedTensorValue<MIL::UInt6>::GetFileProperties((uint64_t)a2);
        if (v71 != (_OWORD *)FileProperties)
        {
          int v72 = *(_DWORD *)(FileProperties + 32);
          std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *> *>>(v71, *(uint64_t **)(FileProperties + 16), 0);
        }
        std::string::basic_string[abi:ne180100]<0>(&__str, "type");
        v56 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>(v71, (unsigned __int8 *)&__str);
        if (v56)
        {
          MIL::IRValue::GetScalar<std::string>(*((const void **)v56 + 5), &__p);
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          std::string::basic_string[abi:ne180100]<0>(&__str, "type");
          std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__erase_unique<std::string>(v71, (unsigned __int8 *)&__str);
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          std::string::basic_string[abi:ne180100]<0>(&__str, "path");
          v57 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>(v71, (unsigned __int8 *)&__str);
          if (v57)
          {
            v59 = (const void *)*((void *)v57 + 5);
            uint64_t v58 = *((void *)v57 + 6);
            if (v58) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v58 + 8), 1uLL, memory_order_relaxed);
            }
            if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__str.__r_.__value_.__l.__data_);
            }
            MIL::IRValue::GetScalar<std::string>(v59, &__str);
            v60 = (void *)(*(uint64_t (**)(void))(**(void **)(a1 + 320) + 32))(*(void *)(a1 + 320));
            MIL::Util::ReplaceModelPaths(&__str, v60);
            v61 = (MIL::IRValueType *)(*(uint64_t (**)(const void *))(*(void *)v59 + 32))(v59);
            v62 = (_anonymous_namespace_ *)MIL::IRValueType::AsTensorType(v61);
            std::string v67 = __str;
            memset(&__str, 0, sizeof(__str));
            MIL::IRTensorValueType::MakeStringValue(v62, (const MIL::IRTensorValueType *)&v67);
          }
          std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
        }
        std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
      }
      uint64_t v14 = a1 + 368;
      if (MIL::IRTypedTensorValue<MIL::UInt6>::UsesFileStorage((uint64_t)a2))
      {
        v15 = (void *)MIL::IRTypedTensorValue<MIL::UInt6>::GetFileProperties((uint64_t)a2);
        std::string::basic_string[abi:ne180100]<0>(&__p, "path");
        v16 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v15, (unsigned __int8 *)&__p);
        if (!v16) {
          std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
        }
        v17 = (const void *)*((void *)v16 + 5);
        v18 = (std::__shared_weak_count *)*((void *)v16 + 6);
        if (v18) {
          atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        MIL::IRValue::GetScalar<std::string>(v17, &__p);
        __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p;
        v19 = std::__tree<std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)(a1 + 368), (const void **)&__p.__r_.__value_.__l.__data_, (uint64_t)&std::piecewise_construct, &__str);
        v21 = (MIL::Blob::StorageWriter *)*((void *)v19 + 7);
        uint64_t v20 = *((void *)v19 + 8);
        if (v20) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (v18) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v18);
        }
      }
      else
      {
        v21 = *(MIL::Blob::StorageWriter **)(*(void *)v14 + 56);
        uint64_t v23 = *(void *)(*(void *)v14 + 64);
        if (v23) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v23 + 8), 1uLL, memory_order_relaxed);
        }
      }
      memset(&__p, 0, sizeof(__p));
      uint64_t v73 = 0;
      if (!MIL::IRTypedTensorValue<MIL::UInt6>::UsesFileStorage((uint64_t)a2)) {
        goto LABEL_59;
      }
      v24 = (void *)MIL::IRTypedTensorValue<MIL::UInt6>::GetFileProperties((uint64_t)a2);
      std::string::basic_string[abi:ne180100]<0>(&__str, "path");
      v25 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v24, (unsigned __int8 *)&__str);
      if (!v25) {
        std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
      }
      v27 = (const void *)*((void *)v25 + 5);
      v26 = (std::__shared_weak_count *)*((void *)v25 + 6);
      if (v26) {
        atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str.__r_.__value_.__l.__data_);
      }
      MIL::IRValue::GetScalar<std::string>(v27, &__str);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      std::string __p = __str;
      std::string::basic_string[abi:ne180100]<0>(&__str, "offset");
      v28 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v24, (unsigned __int8 *)&__str);
      v29 = v28;
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__str.__r_.__value_.__l.__data_);
        if (v29)
        {
LABEL_39:
          std::string::basic_string[abi:ne180100]<0>(&__str, "offset");
          v30 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v24, (unsigned __int8 *)&__str);
          if (!v30) {
            std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
          }
          v31 = (const void *)*((void *)v30 + 5);
          v32 = (std::__shared_weak_count *)*((void *)v30 + 6);
          if (v32) {
            atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          uint64_t v73 = MIL::IRValue::GetScalar<unsigned long long>(v31);
          if (std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>((void *)(a1 + 328), (unsigned __int8 *)&__p))
          {
            v33 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>((void *)(a1 + 328), (unsigned __int8 *)&__p);
            if (!v33) {
              goto LABEL_94;
            }
            v34 = v33 + 40;
            if (std::__hash_table<std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>>>::find<unsigned long long>((void *)v33 + 5, (unint64_t *)&v73))
            {
              if (std::__hash_table<std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>>>::find<unsigned long long>(v34, (unint64_t *)&v73))
              {
                char v35 = 1;
                goto LABEL_50;
              }
LABEL_94:
              std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
            }
          }
          char v35 = 0;
LABEL_50:
          if (v32) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v32);
          }
          if (v26) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v26);
          }
          if (v35)
          {
LABEL_78:
            uint64_t v55 = MIL::IRTypedTensorValue<MIL::UInt6>::GetType((uint64_t)a2);
            (*(void (**)(uint64_t))(*(void *)v55 + 24))(v55);
            MIL::Blob::StorageWriter::GetFilePath(v21, &__str);
            MIL::IRTensorValueType::MakeValueFromBlobFile();
          }
LABEL_59:
          switch(v12)
          {
            case 4:
              v36 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::Fp16>(v36);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::Fp16>((uint64_t *)v21);
              break;
            case 5:
              v51 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<float>(v51);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<float>((uint64_t *)v21);
              break;
            case 9:
              v48 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<signed char>(v48);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<signed char>((uint64_t *)v21);
              break;
            case 10:
              v50 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<short>(v50);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<short>((uint64_t *)v21);
              break;
            case 11:
              v45 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<int>(v45);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<int>((uint64_t *)v21);
              break;
            case 13:
              v47 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::Int4>(v47);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::Int4>((uint64_t *)v21);
              break;
            case 14:
              v52 = (void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<unsigned char>(v52);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<unsigned char>((uint64_t *)v21);
              break;
            case 15:
              v49 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<unsigned short>(v49);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<unsigned short>((uint64_t *)v21);
              break;
            case 16:
              v42 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<unsigned int>(v42);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<unsigned int>((uint64_t *)v21);
              break;
            case 19:
              int v39 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::UInt2>(v39);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::UInt2>((uint64_t *)v21);
              break;
            case 20:
              v41 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::UInt4>(v41);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::UInt4>((uint64_t *)v21);
              break;
            case 21:
              v38 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::UInt1>(v38);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::UInt1>((uint64_t *)v21);
              break;
            case 22:
              v40 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::UInt3>(v40);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::UInt3>((uint64_t *)v21);
              break;
            case 23:
              v43 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::UInt6>(v43);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::UInt6>((uint64_t *)v21);
              break;
            case 24:
              v44 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::Fp8E4M3FN>(v44);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::Fp8E4M3FN>((uint64_t *)v21);
              break;
            case 25:
              v46 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::Fp8E5M2>(v46);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::Fp8E5M2>((uint64_t *)v21);
              break;
            default:
              exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
              MIL::IRDataTypeToString(v12, &v68);
              v65 = std::string::insert(&v68, 0, "[MIL Serialization] Unsupported Data type ");
              long long v66 = *(_OWORD *)&v65->__r_.__value_.__l.__data_;
              __str.__r_.__value_.__r.__words[2] = v65->__r_.__value_.__r.__words[2];
              *(_OWORD *)&__str.__r_.__value_.__l.__data_ = v66;
              v65->__r_.__value_.__l.__size_ = 0;
              v65->__r_.__value_.__r.__words[2] = 0;
              v65->__r_.__value_.__r.__words[0] = 0;
              std::logic_error::logic_error(exception, &__str);
              exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
              __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
          }
          unint64_t v53 = v37;
          if (MIL::IRTypedTensorValue<MIL::UInt6>::UsesFileStorage((uint64_t)a2))
          {
            __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p;
            v54 = std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1 + 328, (unsigned __int8 *)&__p, (uint64_t)&std::piecewise_construct, (long long **)&__str);
            __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&v73;
            std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t)(v54 + 40), (unint64_t *)&v73, (uint64_t)&std::piecewise_construct, &__str)[3] = v53;
          }
          goto LABEL_78;
        }
      }
      else if (v28)
      {
        goto LABEL_39;
      }
      if (v26) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v26);
      }
      goto LABEL_59;
    }
  }
  ValHelperForSubByteTypes<MIL::UInt6>((uint64_t)a2, *(void **)(a1 + 40));
  return a1;
}

void sub_20F468C00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,char a37)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a22 < 0)
  {
    operator delete(a17);
    if ((v39 & 1) == 0)
    {
LABEL_8:
      if (a35 < 0) {
        operator delete(a30);
      }
      if (v37) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v37);
      }
      std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a37);
      _Unwind_Resume(a1);
    }
  }
  else if (!v39)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v38);
  goto LABEL_8;
}

uint64_t MIL::Text::BasicSerializer::Val<unsigned char>(uint64_t a1, MIL::IRTensorValue *a2)
{
  uint64_t v4 = *(void *)(a1 + 384);
  if (v4)
  {
    Type = (MIL::IRValueType *)MIL::IRTypedTensorValue<unsigned char>::GetType((uint64_t)a2);
    uint64_t v6 = MIL::IRValueType::AsTensorType(Type);
    unint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 16))(v6);
    int v8 = v7 >= (*(uint64_t (**)(void))(**(void **)(a1 + 320) + 136))(*(void *)(a1 + 320));
  }
  else
  {
    int v8 = MIL::IRTypedTensorValue<unsigned char>::UsesFileStorage((uint64_t)a2);
  }
  v9 = (MIL::IRValueType *)MIL::IRTypedTensorValue<unsigned char>::GetType((uint64_t)a2);
  uint64_t v10 = MIL::IRValueType::AsTensorType(v9);
  unsigned int v11 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 88))(v10);
  int v12 = v11;
  if (!v4 || !v8 || (v11 <= 0x19 ? (BOOL v13 = ((1 << v11) & 0x3F9EE30) == 0) : (BOOL v13 = 1), !v13))
  {
    if (v8)
    {
      memset(v71, 0, sizeof(v71));
      int v72 = 1065353216;
      if (!v4)
      {
        uint64_t FileProperties = MIL::IRTypedTensorValue<unsigned char>::GetFileProperties((uint64_t)a2);
        if (v71 != (_OWORD *)FileProperties)
        {
          int v72 = *(_DWORD *)(FileProperties + 32);
          std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *> *>>(v71, *(uint64_t **)(FileProperties + 16), 0);
        }
        std::string::basic_string[abi:ne180100]<0>(&__str, "type");
        v56 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>(v71, (unsigned __int8 *)&__str);
        if (v56)
        {
          MIL::IRValue::GetScalar<std::string>(*((const void **)v56 + 5), &__p);
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          std::string::basic_string[abi:ne180100]<0>(&__str, "type");
          std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__erase_unique<std::string>(v71, (unsigned __int8 *)&__str);
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          std::string::basic_string[abi:ne180100]<0>(&__str, "path");
          v57 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>(v71, (unsigned __int8 *)&__str);
          if (v57)
          {
            v59 = (const void *)*((void *)v57 + 5);
            uint64_t v58 = *((void *)v57 + 6);
            if (v58) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v58 + 8), 1uLL, memory_order_relaxed);
            }
            if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__str.__r_.__value_.__l.__data_);
            }
            MIL::IRValue::GetScalar<std::string>(v59, &__str);
            v60 = (void *)(*(uint64_t (**)(void))(**(void **)(a1 + 320) + 32))(*(void *)(a1 + 320));
            MIL::Util::ReplaceModelPaths(&__str, v60);
            v61 = (MIL::IRValueType *)(*(uint64_t (**)(const void *))(*(void *)v59 + 32))(v59);
            v62 = (_anonymous_namespace_ *)MIL::IRValueType::AsTensorType(v61);
            std::string v67 = __str;
            memset(&__str, 0, sizeof(__str));
            MIL::IRTensorValueType::MakeStringValue(v62, (const MIL::IRTensorValueType *)&v67);
          }
          std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
        }
        std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
      }
      uint64_t v14 = a1 + 368;
      if (MIL::IRTypedTensorValue<unsigned char>::UsesFileStorage((uint64_t)a2))
      {
        v15 = (void *)MIL::IRTypedTensorValue<unsigned char>::GetFileProperties((uint64_t)a2);
        std::string::basic_string[abi:ne180100]<0>(&__p, "path");
        v16 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v15, (unsigned __int8 *)&__p);
        if (!v16) {
          std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
        }
        v17 = (const void *)*((void *)v16 + 5);
        v18 = (std::__shared_weak_count *)*((void *)v16 + 6);
        if (v18) {
          atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        MIL::IRValue::GetScalar<std::string>(v17, &__p);
        __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p;
        v19 = std::__tree<std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)(a1 + 368), (const void **)&__p.__r_.__value_.__l.__data_, (uint64_t)&std::piecewise_construct, &__str);
        v21 = (MIL::Blob::StorageWriter *)*((void *)v19 + 7);
        uint64_t v20 = *((void *)v19 + 8);
        if (v20) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (v18) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v18);
        }
      }
      else
      {
        v21 = *(MIL::Blob::StorageWriter **)(*(void *)v14 + 56);
        uint64_t v23 = *(void *)(*(void *)v14 + 64);
        if (v23) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v23 + 8), 1uLL, memory_order_relaxed);
        }
      }
      memset(&__p, 0, sizeof(__p));
      uint64_t v73 = 0;
      if (!MIL::IRTypedTensorValue<unsigned char>::UsesFileStorage((uint64_t)a2)) {
        goto LABEL_59;
      }
      v24 = (void *)MIL::IRTypedTensorValue<unsigned char>::GetFileProperties((uint64_t)a2);
      std::string::basic_string[abi:ne180100]<0>(&__str, "path");
      v25 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v24, (unsigned __int8 *)&__str);
      if (!v25) {
        std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
      }
      v27 = (const void *)*((void *)v25 + 5);
      v26 = (std::__shared_weak_count *)*((void *)v25 + 6);
      if (v26) {
        atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str.__r_.__value_.__l.__data_);
      }
      MIL::IRValue::GetScalar<std::string>(v27, &__str);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      std::string __p = __str;
      std::string::basic_string[abi:ne180100]<0>(&__str, "offset");
      v28 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v24, (unsigned __int8 *)&__str);
      v29 = v28;
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__str.__r_.__value_.__l.__data_);
        if (v29)
        {
LABEL_39:
          std::string::basic_string[abi:ne180100]<0>(&__str, "offset");
          v30 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v24, (unsigned __int8 *)&__str);
          if (!v30) {
            std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
          }
          v31 = (const void *)*((void *)v30 + 5);
          v32 = (std::__shared_weak_count *)*((void *)v30 + 6);
          if (v32) {
            atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          uint64_t v73 = MIL::IRValue::GetScalar<unsigned long long>(v31);
          if (std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>((void *)(a1 + 328), (unsigned __int8 *)&__p))
          {
            v33 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>((void *)(a1 + 328), (unsigned __int8 *)&__p);
            if (!v33) {
              goto LABEL_94;
            }
            v34 = v33 + 40;
            if (std::__hash_table<std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>>>::find<unsigned long long>((void *)v33 + 5, (unint64_t *)&v73))
            {
              if (std::__hash_table<std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>>>::find<unsigned long long>(v34, (unint64_t *)&v73))
              {
                char v35 = 1;
                goto LABEL_50;
              }
LABEL_94:
              std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
            }
          }
          char v35 = 0;
LABEL_50:
          if (v32) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v32);
          }
          if (v26) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v26);
          }
          if (v35)
          {
LABEL_78:
            uint64_t v55 = MIL::IRTypedTensorValue<unsigned char>::GetType((uint64_t)a2);
            (*(void (**)(uint64_t))(*(void *)v55 + 24))(v55);
            MIL::Blob::StorageWriter::GetFilePath(v21, &__str);
            MIL::IRTensorValueType::MakeValueFromBlobFile();
          }
LABEL_59:
          switch(v12)
          {
            case 4:
              v36 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::Fp16>(v36);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::Fp16>((uint64_t *)v21);
              break;
            case 5:
              v51 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<float>(v51);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<float>((uint64_t *)v21);
              break;
            case 9:
              v48 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<signed char>(v48);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<signed char>((uint64_t *)v21);
              break;
            case 10:
              v50 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<short>(v50);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<short>((uint64_t *)v21);
              break;
            case 11:
              v45 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<int>(v45);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<int>((uint64_t *)v21);
              break;
            case 13:
              v47 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::Int4>(v47);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::Int4>((uint64_t *)v21);
              break;
            case 14:
              v52 = (void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<unsigned char>(v52);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<unsigned char>((uint64_t *)v21);
              break;
            case 15:
              v49 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<unsigned short>(v49);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<unsigned short>((uint64_t *)v21);
              break;
            case 16:
              v42 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<unsigned int>(v42);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<unsigned int>((uint64_t *)v21);
              break;
            case 19:
              int v39 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::UInt2>(v39);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::UInt2>((uint64_t *)v21);
              break;
            case 20:
              v41 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::UInt4>(v41);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::UInt4>((uint64_t *)v21);
              break;
            case 21:
              v38 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::UInt1>(v38);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::UInt1>((uint64_t *)v21);
              break;
            case 22:
              v40 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::UInt3>(v40);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::UInt3>((uint64_t *)v21);
              break;
            case 23:
              v43 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::UInt6>(v43);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::UInt6>((uint64_t *)v21);
              break;
            case 24:
              v44 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::Fp8E4M3FN>(v44);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::Fp8E4M3FN>((uint64_t *)v21);
              break;
            case 25:
              v46 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::Fp8E5M2>(v46);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::Fp8E5M2>((uint64_t *)v21);
              break;
            default:
              exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
              MIL::IRDataTypeToString(v12, &v68);
              v65 = std::string::insert(&v68, 0, "[MIL Serialization] Unsupported Data type ");
              long long v66 = *(_OWORD *)&v65->__r_.__value_.__l.__data_;
              __str.__r_.__value_.__r.__words[2] = v65->__r_.__value_.__r.__words[2];
              *(_OWORD *)&__str.__r_.__value_.__l.__data_ = v66;
              v65->__r_.__value_.__l.__size_ = 0;
              v65->__r_.__value_.__r.__words[2] = 0;
              v65->__r_.__value_.__r.__words[0] = 0;
              std::logic_error::logic_error(exception, &__str);
              exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
              __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
          }
          unint64_t v53 = v37;
          if (MIL::IRTypedTensorValue<unsigned char>::UsesFileStorage((uint64_t)a2))
          {
            __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p;
            v54 = std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1 + 328, (unsigned __int8 *)&__p, (uint64_t)&std::piecewise_construct, (long long **)&__str);
            __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&v73;
            std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t)(v54 + 40), (unint64_t *)&v73, (uint64_t)&std::piecewise_construct, &__str)[3] = v53;
          }
          goto LABEL_78;
        }
      }
      else if (v28)
      {
        goto LABEL_39;
      }
      if (v26) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v26);
      }
      goto LABEL_59;
    }
  }
  ValHelper<unsigned char>((uint64_t)a2, *(void **)(a1 + 40));
  return a1;
}

void sub_20F469AC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,char a37)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a22 < 0)
  {
    operator delete(a17);
    if ((v39 & 1) == 0)
    {
LABEL_8:
      if (a35 < 0) {
        operator delete(a30);
      }
      if (v37) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v37);
      }
      std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a37);
      _Unwind_Resume(a1);
    }
  }
  else if (!v39)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v38);
  goto LABEL_8;
}

void ValHelper<unsigned char>(uint64_t a1, void *a2)
{
  uint64_t Type = MIL::IRTypedTensorValue<unsigned char>::GetType(a1);
  uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)Type + 96))(Type);
  int v8 = 0;
  uint64_t v9 = 0;
  std::string __p = 0;
  std::vector<MIL::IRDimension const*>::__init_with_size[abi:ne180100]<MIL::IRDimension const**,MIL::IRDimension const**>(&__p, *(const void **)v5, *(void *)(v5 + 8), (uint64_t)(*(void *)(v5 + 8) - *(void *)v5) >> 3);
  if (__p == v8)
  {
    MIL::IRTypedTensorValue<BOOL>::GetScalarValue(a1);
    std::ostream::operator<<();
  }
  uint64_t Values = MIL::IRTypedTensorValue<BOOL>::GetValues(a1);
  if (__p)
  {
    int v8 = (MIL::IRDimension **)__p;
    operator delete(__p);
  }
}

void sub_20F469E50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::Text::BasicSerializer::Val<unsigned short>(uint64_t a1, MIL::IRTensorValue *a2)
{
  uint64_t v4 = *(void *)(a1 + 384);
  if (v4)
  {
    uint64_t Type = (MIL::IRValueType *)MIL::IRTypedTensorValue<unsigned short>::GetType((uint64_t)a2);
    uint64_t v6 = MIL::IRValueType::AsTensorType(Type);
    unint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 16))(v6);
    int v8 = v7 >= (*(uint64_t (**)(void))(**(void **)(a1 + 320) + 136))(*(void *)(a1 + 320));
  }
  else
  {
    int v8 = MIL::IRTypedTensorValue<unsigned short>::UsesFileStorage((uint64_t)a2);
  }
  uint64_t v9 = (MIL::IRValueType *)MIL::IRTypedTensorValue<unsigned short>::GetType((uint64_t)a2);
  uint64_t v10 = MIL::IRValueType::AsTensorType(v9);
  unsigned int v11 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 88))(v10);
  int v12 = v11;
  if (!v4 || !v8 || (v11 <= 0x19 ? (BOOL v13 = ((1 << v11) & 0x3F9EE30) == 0) : (BOOL v13 = 1), !v13))
  {
    if (v8)
    {
      memset(v71, 0, sizeof(v71));
      int v72 = 1065353216;
      if (!v4)
      {
        uint64_t FileProperties = MIL::IRTypedTensorValue<unsigned short>::GetFileProperties((uint64_t)a2);
        if (v71 != (_OWORD *)FileProperties)
        {
          int v72 = *(_DWORD *)(FileProperties + 32);
          std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *> *>>(v71, *(uint64_t **)(FileProperties + 16), 0);
        }
        std::string::basic_string[abi:ne180100]<0>(&__str, "type");
        v56 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>(v71, (unsigned __int8 *)&__str);
        if (v56)
        {
          MIL::IRValue::GetScalar<std::string>(*((const void **)v56 + 5), &__p);
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          std::string::basic_string[abi:ne180100]<0>(&__str, "type");
          std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__erase_unique<std::string>(v71, (unsigned __int8 *)&__str);
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          std::string::basic_string[abi:ne180100]<0>(&__str, "path");
          v57 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>(v71, (unsigned __int8 *)&__str);
          if (v57)
          {
            v59 = (const void *)*((void *)v57 + 5);
            uint64_t v58 = *((void *)v57 + 6);
            if (v58) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v58 + 8), 1uLL, memory_order_relaxed);
            }
            if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__str.__r_.__value_.__l.__data_);
            }
            MIL::IRValue::GetScalar<std::string>(v59, &__str);
            v60 = (void *)(*(uint64_t (**)(void))(**(void **)(a1 + 320) + 32))(*(void *)(a1 + 320));
            MIL::Util::ReplaceModelPaths(&__str, v60);
            v61 = (MIL::IRValueType *)(*(uint64_t (**)(const void *))(*(void *)v59 + 32))(v59);
            v62 = (_anonymous_namespace_ *)MIL::IRValueType::AsTensorType(v61);
            std::string v67 = __str;
            memset(&__str, 0, sizeof(__str));
            MIL::IRTensorValueType::MakeStringValue(v62, (const MIL::IRTensorValueType *)&v67);
          }
          std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
        }
        std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
      }
      uint64_t v14 = a1 + 368;
      if (MIL::IRTypedTensorValue<unsigned short>::UsesFileStorage((uint64_t)a2))
      {
        v15 = (void *)MIL::IRTypedTensorValue<unsigned short>::GetFileProperties((uint64_t)a2);
        std::string::basic_string[abi:ne180100]<0>(&__p, "path");
        v16 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v15, (unsigned __int8 *)&__p);
        if (!v16) {
          std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
        }
        v17 = (const void *)*((void *)v16 + 5);
        v18 = (std::__shared_weak_count *)*((void *)v16 + 6);
        if (v18) {
          atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        MIL::IRValue::GetScalar<std::string>(v17, &__p);
        __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p;
        v19 = std::__tree<std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)(a1 + 368), (const void **)&__p.__r_.__value_.__l.__data_, (uint64_t)&std::piecewise_construct, &__str);
        v21 = (MIL::Blob::StorageWriter *)*((void *)v19 + 7);
        uint64_t v20 = *((void *)v19 + 8);
        if (v20) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (v18) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v18);
        }
      }
      else
      {
        v21 = *(MIL::Blob::StorageWriter **)(*(void *)v14 + 56);
        uint64_t v23 = *(void *)(*(void *)v14 + 64);
        if (v23) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v23 + 8), 1uLL, memory_order_relaxed);
        }
      }
      memset(&__p, 0, sizeof(__p));
      uint64_t v73 = 0;
      if (!MIL::IRTypedTensorValue<unsigned short>::UsesFileStorage((uint64_t)a2)) {
        goto LABEL_59;
      }
      v24 = (void *)MIL::IRTypedTensorValue<unsigned short>::GetFileProperties((uint64_t)a2);
      std::string::basic_string[abi:ne180100]<0>(&__str, "path");
      v25 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v24, (unsigned __int8 *)&__str);
      if (!v25) {
        std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
      }
      v27 = (const void *)*((void *)v25 + 5);
      v26 = (std::__shared_weak_count *)*((void *)v25 + 6);
      if (v26) {
        atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str.__r_.__value_.__l.__data_);
      }
      MIL::IRValue::GetScalar<std::string>(v27, &__str);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      std::string __p = __str;
      std::string::basic_string[abi:ne180100]<0>(&__str, "offset");
      v28 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v24, (unsigned __int8 *)&__str);
      v29 = v28;
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__str.__r_.__value_.__l.__data_);
        if (v29)
        {
LABEL_39:
          std::string::basic_string[abi:ne180100]<0>(&__str, "offset");
          v30 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v24, (unsigned __int8 *)&__str);
          if (!v30) {
            std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
          }
          v31 = (const void *)*((void *)v30 + 5);
          v32 = (std::__shared_weak_count *)*((void *)v30 + 6);
          if (v32) {
            atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          uint64_t v73 = MIL::IRValue::GetScalar<unsigned long long>(v31);
          if (std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>((void *)(a1 + 328), (unsigned __int8 *)&__p))
          {
            v33 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>((void *)(a1 + 328), (unsigned __int8 *)&__p);
            if (!v33) {
              goto LABEL_94;
            }
            v34 = v33 + 40;
            if (std::__hash_table<std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>>>::find<unsigned long long>((void *)v33 + 5, (unint64_t *)&v73))
            {
              if (std::__hash_table<std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>>>::find<unsigned long long>(v34, (unint64_t *)&v73))
              {
                char v35 = 1;
                goto LABEL_50;
              }
LABEL_94:
              std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
            }
          }
          char v35 = 0;
LABEL_50:
          if (v32) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v32);
          }
          if (v26) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v26);
          }
          if (v35)
          {
LABEL_78:
            uint64_t v55 = MIL::IRTypedTensorValue<unsigned short>::GetType((uint64_t)a2);
            (*(void (**)(uint64_t))(*(void *)v55 + 24))(v55);
            MIL::Blob::StorageWriter::GetFilePath(v21, &__str);
            MIL::IRTensorValueType::MakeValueFromBlobFile();
          }
LABEL_59:
          switch(v12)
          {
            case 4:
              v36 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::Fp16>(v36);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::Fp16>((uint64_t *)v21);
              break;
            case 5:
              v51 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<float>(v51);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<float>((uint64_t *)v21);
              break;
            case 9:
              v48 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<signed char>(v48);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<signed char>((uint64_t *)v21);
              break;
            case 10:
              v50 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<short>(v50);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<short>((uint64_t *)v21);
              break;
            case 11:
              v45 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<int>(v45);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<int>((uint64_t *)v21);
              break;
            case 13:
              v47 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::Int4>(v47);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::Int4>((uint64_t *)v21);
              break;
            case 14:
              v52 = (void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<unsigned char>(v52);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<unsigned char>((uint64_t *)v21);
              break;
            case 15:
              v49 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<unsigned short>(v49);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<unsigned short>((uint64_t *)v21);
              break;
            case 16:
              v42 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<unsigned int>(v42);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<unsigned int>((uint64_t *)v21);
              break;
            case 19:
              int v39 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::UInt2>(v39);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::UInt2>((uint64_t *)v21);
              break;
            case 20:
              v41 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::UInt4>(v41);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::UInt4>((uint64_t *)v21);
              break;
            case 21:
              v38 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::UInt1>(v38);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::UInt1>((uint64_t *)v21);
              break;
            case 22:
              v40 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::UInt3>(v40);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::UInt3>((uint64_t *)v21);
              break;
            case 23:
              v43 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::UInt6>(v43);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::UInt6>((uint64_t *)v21);
              break;
            case 24:
              v44 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::Fp8E4M3FN>(v44);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::Fp8E4M3FN>((uint64_t *)v21);
              break;
            case 25:
              v46 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::Fp8E5M2>(v46);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::Fp8E5M2>((uint64_t *)v21);
              break;
            default:
              exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
              MIL::IRDataTypeToString(v12, &v68);
              v65 = std::string::insert(&v68, 0, "[MIL Serialization] Unsupported Data type ");
              long long v66 = *(_OWORD *)&v65->__r_.__value_.__l.__data_;
              __str.__r_.__value_.__r.__words[2] = v65->__r_.__value_.__r.__words[2];
              *(_OWORD *)&__str.__r_.__value_.__l.__data_ = v66;
              v65->__r_.__value_.__l.__size_ = 0;
              v65->__r_.__value_.__r.__words[2] = 0;
              v65->__r_.__value_.__r.__words[0] = 0;
              std::logic_error::logic_error(exception, &__str);
              exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
              __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
          }
          unint64_t v53 = v37;
          if (MIL::IRTypedTensorValue<unsigned short>::UsesFileStorage((uint64_t)a2))
          {
            __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p;
            v54 = std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1 + 328, (unsigned __int8 *)&__p, (uint64_t)&std::piecewise_construct, (long long **)&__str);
            __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&v73;
            std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t)(v54 + 40), (unint64_t *)&v73, (uint64_t)&std::piecewise_construct, &__str)[3] = v53;
          }
          goto LABEL_78;
        }
      }
      else if (v28)
      {
        goto LABEL_39;
      }
      if (v26) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v26);
      }
      goto LABEL_59;
    }
  }
  ValHelper<unsigned short>((uint64_t)a2, *(void **)(a1 + 40));
  return a1;
}

void sub_20F46AA60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,char a37)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a22 < 0)
  {
    operator delete(a17);
    if ((v39 & 1) == 0)
    {
LABEL_8:
      if (a35 < 0) {
        operator delete(a30);
      }
      if (v37) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v37);
      }
      std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a37);
      _Unwind_Resume(a1);
    }
  }
  else if (!v39)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v38);
  goto LABEL_8;
}

void ValHelper<unsigned short>(uint64_t a1, void *a2)
{
  uint64_t Type = MIL::IRTypedTensorValue<unsigned short>::GetType(a1);
  uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)Type + 96))(Type);
  int v8 = 0;
  uint64_t v9 = 0;
  std::string __p = 0;
  std::vector<MIL::IRDimension const*>::__init_with_size[abi:ne180100]<MIL::IRDimension const**,MIL::IRDimension const**>(&__p, *(const void **)v5, *(void *)(v5 + 8), (uint64_t)(*(void *)(v5 + 8) - *(void *)v5) >> 3);
  if (__p == v8)
  {
    MIL::IRTypedTensorValue<unsigned short>::GetScalarValue(a1);
    std::ostream::operator<<();
  }
  uint64_t Values = MIL::IRTypedTensorValue<unsigned short>::GetValues(a1);
  if (__p)
  {
    int v8 = (MIL::IRDimension **)__p;
    operator delete(__p);
  }
}

void sub_20F46ADF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::Text::BasicSerializer::Val<unsigned int>(uint64_t a1, MIL::IRTensorValue *a2)
{
  uint64_t v4 = *(void *)(a1 + 384);
  if (v4)
  {
    uint64_t Type = (MIL::IRValueType *)MIL::IRTypedTensorValue<unsigned int>::GetType((uint64_t)a2);
    uint64_t v6 = MIL::IRValueType::AsTensorType(Type);
    unint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 16))(v6);
    int v8 = v7 >= (*(uint64_t (**)(void))(**(void **)(a1 + 320) + 136))(*(void *)(a1 + 320));
  }
  else
  {
    int v8 = MIL::IRTypedTensorValue<unsigned int>::UsesFileStorage((uint64_t)a2);
  }
  uint64_t v9 = (MIL::IRValueType *)MIL::IRTypedTensorValue<unsigned int>::GetType((uint64_t)a2);
  uint64_t v10 = MIL::IRValueType::AsTensorType(v9);
  unsigned int v11 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 88))(v10);
  int v12 = v11;
  if (!v4 || !v8 || (v11 <= 0x19 ? (BOOL v13 = ((1 << v11) & 0x3F9EE30) == 0) : (BOOL v13 = 1), !v13))
  {
    if (v8)
    {
      memset(v71, 0, sizeof(v71));
      int v72 = 1065353216;
      if (!v4)
      {
        uint64_t FileProperties = MIL::IRTypedTensorValue<unsigned int>::GetFileProperties((uint64_t)a2);
        if (v71 != (_OWORD *)FileProperties)
        {
          int v72 = *(_DWORD *)(FileProperties + 32);
          std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *> *>>(v71, *(uint64_t **)(FileProperties + 16), 0);
        }
        std::string::basic_string[abi:ne180100]<0>(&__str, "type");
        v56 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>(v71, (unsigned __int8 *)&__str);
        if (v56)
        {
          MIL::IRValue::GetScalar<std::string>(*((const void **)v56 + 5), &__p);
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          std::string::basic_string[abi:ne180100]<0>(&__str, "type");
          std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__erase_unique<std::string>(v71, (unsigned __int8 *)&__str);
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          std::string::basic_string[abi:ne180100]<0>(&__str, "path");
          v57 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>(v71, (unsigned __int8 *)&__str);
          if (v57)
          {
            v59 = (const void *)*((void *)v57 + 5);
            uint64_t v58 = *((void *)v57 + 6);
            if (v58) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v58 + 8), 1uLL, memory_order_relaxed);
            }
            if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__str.__r_.__value_.__l.__data_);
            }
            MIL::IRValue::GetScalar<std::string>(v59, &__str);
            v60 = (void *)(*(uint64_t (**)(void))(**(void **)(a1 + 320) + 32))(*(void *)(a1 + 320));
            MIL::Util::ReplaceModelPaths(&__str, v60);
            v61 = (MIL::IRValueType *)(*(uint64_t (**)(const void *))(*(void *)v59 + 32))(v59);
            v62 = (_anonymous_namespace_ *)MIL::IRValueType::AsTensorType(v61);
            std::string v67 = __str;
            memset(&__str, 0, sizeof(__str));
            MIL::IRTensorValueType::MakeStringValue(v62, (const MIL::IRTensorValueType *)&v67);
          }
          std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
        }
        std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
      }
      uint64_t v14 = a1 + 368;
      if (MIL::IRTypedTensorValue<unsigned int>::UsesFileStorage((uint64_t)a2))
      {
        v15 = (void *)MIL::IRTypedTensorValue<unsigned int>::GetFileProperties((uint64_t)a2);
        std::string::basic_string[abi:ne180100]<0>(&__p, "path");
        v16 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v15, (unsigned __int8 *)&__p);
        if (!v16) {
          std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
        }
        v17 = (const void *)*((void *)v16 + 5);
        v18 = (std::__shared_weak_count *)*((void *)v16 + 6);
        if (v18) {
          atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        MIL::IRValue::GetScalar<std::string>(v17, &__p);
        __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p;
        v19 = std::__tree<std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)(a1 + 368), (const void **)&__p.__r_.__value_.__l.__data_, (uint64_t)&std::piecewise_construct, &__str);
        v21 = (MIL::Blob::StorageWriter *)*((void *)v19 + 7);
        uint64_t v20 = *((void *)v19 + 8);
        if (v20) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (v18) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v18);
        }
      }
      else
      {
        v21 = *(MIL::Blob::StorageWriter **)(*(void *)v14 + 56);
        uint64_t v23 = *(void *)(*(void *)v14 + 64);
        if (v23) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v23 + 8), 1uLL, memory_order_relaxed);
        }
      }
      memset(&__p, 0, sizeof(__p));
      uint64_t v73 = 0;
      if (!MIL::IRTypedTensorValue<unsigned int>::UsesFileStorage((uint64_t)a2)) {
        goto LABEL_59;
      }
      v24 = (void *)MIL::IRTypedTensorValue<unsigned int>::GetFileProperties((uint64_t)a2);
      std::string::basic_string[abi:ne180100]<0>(&__str, "path");
      v25 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v24, (unsigned __int8 *)&__str);
      if (!v25) {
        std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
      }
      v27 = (const void *)*((void *)v25 + 5);
      v26 = (std::__shared_weak_count *)*((void *)v25 + 6);
      if (v26) {
        atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str.__r_.__value_.__l.__data_);
      }
      MIL::IRValue::GetScalar<std::string>(v27, &__str);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      std::string __p = __str;
      std::string::basic_string[abi:ne180100]<0>(&__str, "offset");
      v28 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v24, (unsigned __int8 *)&__str);
      v29 = v28;
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__str.__r_.__value_.__l.__data_);
        if (v29)
        {
LABEL_39:
          std::string::basic_string[abi:ne180100]<0>(&__str, "offset");
          v30 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v24, (unsigned __int8 *)&__str);
          if (!v30) {
            std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
          }
          v31 = (const void *)*((void *)v30 + 5);
          v32 = (std::__shared_weak_count *)*((void *)v30 + 6);
          if (v32) {
            atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          uint64_t v73 = MIL::IRValue::GetScalar<unsigned long long>(v31);
          if (std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>((void *)(a1 + 328), (unsigned __int8 *)&__p))
          {
            v33 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>((void *)(a1 + 328), (unsigned __int8 *)&__p);
            if (!v33) {
              goto LABEL_94;
            }
            v34 = v33 + 40;
            if (std::__hash_table<std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>>>::find<unsigned long long>((void *)v33 + 5, (unint64_t *)&v73))
            {
              if (std::__hash_table<std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>>>::find<unsigned long long>(v34, (unint64_t *)&v73))
              {
                char v35 = 1;
                goto LABEL_50;
              }
LABEL_94:
              std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
            }
          }
          char v35 = 0;
LABEL_50:
          if (v32) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v32);
          }
          if (v26) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v26);
          }
          if (v35)
          {
LABEL_78:
            uint64_t v55 = MIL::IRTypedTensorValue<unsigned int>::GetType((uint64_t)a2);
            (*(void (**)(uint64_t))(*(void *)v55 + 24))(v55);
            MIL::Blob::StorageWriter::GetFilePath(v21, &__str);
            MIL::IRTensorValueType::MakeValueFromBlobFile();
          }
LABEL_59:
          switch(v12)
          {
            case 4:
              v36 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::Fp16>(v36);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::Fp16>((uint64_t *)v21);
              break;
            case 5:
              v51 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<float>(v51);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<float>((uint64_t *)v21);
              break;
            case 9:
              v48 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<signed char>(v48);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<signed char>((uint64_t *)v21);
              break;
            case 10:
              v50 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<short>(v50);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<short>((uint64_t *)v21);
              break;
            case 11:
              v45 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<int>(v45);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<int>((uint64_t *)v21);
              break;
            case 13:
              v47 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::Int4>(v47);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::Int4>((uint64_t *)v21);
              break;
            case 14:
              v52 = (void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<unsigned char>(v52);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<unsigned char>((uint64_t *)v21);
              break;
            case 15:
              v49 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<unsigned short>(v49);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<unsigned short>((uint64_t *)v21);
              break;
            case 16:
              v42 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<unsigned int>(v42);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<unsigned int>((uint64_t *)v21);
              break;
            case 19:
              int v39 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::UInt2>(v39);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::UInt2>((uint64_t *)v21);
              break;
            case 20:
              v41 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::UInt4>(v41);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::UInt4>((uint64_t *)v21);
              break;
            case 21:
              v38 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::UInt1>(v38);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::UInt1>((uint64_t *)v21);
              break;
            case 22:
              v40 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::UInt3>(v40);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::UInt3>((uint64_t *)v21);
              break;
            case 23:
              v43 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::UInt6>(v43);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::UInt6>((uint64_t *)v21);
              break;
            case 24:
              v44 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::Fp8E4M3FN>(v44);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::Fp8E4M3FN>((uint64_t *)v21);
              break;
            case 25:
              v46 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::Fp8E5M2>(v46);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::Fp8E5M2>((uint64_t *)v21);
              break;
            default:
              exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
              MIL::IRDataTypeToString(v12, &v68);
              v65 = std::string::insert(&v68, 0, "[MIL Serialization] Unsupported Data type ");
              long long v66 = *(_OWORD *)&v65->__r_.__value_.__l.__data_;
              __str.__r_.__value_.__r.__words[2] = v65->__r_.__value_.__r.__words[2];
              *(_OWORD *)&__str.__r_.__value_.__l.__data_ = v66;
              v65->__r_.__value_.__l.__size_ = 0;
              v65->__r_.__value_.__r.__words[2] = 0;
              v65->__r_.__value_.__r.__words[0] = 0;
              std::logic_error::logic_error(exception, &__str);
              exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
              __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
          }
          unint64_t v53 = v37;
          if (MIL::IRTypedTensorValue<unsigned int>::UsesFileStorage((uint64_t)a2))
          {
            __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p;
            v54 = std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1 + 328, (unsigned __int8 *)&__p, (uint64_t)&std::piecewise_construct, (long long **)&__str);
            __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&v73;
            std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t)(v54 + 40), (unint64_t *)&v73, (uint64_t)&std::piecewise_construct, &__str)[3] = v53;
          }
          goto LABEL_78;
        }
      }
      else if (v28)
      {
        goto LABEL_39;
      }
      if (v26) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v26);
      }
      goto LABEL_59;
    }
  }
  ValHelper<unsigned int>((uint64_t)a2, *(void **)(a1 + 40));
  return a1;
}

void sub_20F46BA00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,char a37)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a22 < 0)
  {
    operator delete(a17);
    if ((v39 & 1) == 0)
    {
LABEL_8:
      if (a35 < 0) {
        operator delete(a30);
      }
      if (v37) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v37);
      }
      std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a37);
      _Unwind_Resume(a1);
    }
  }
  else if (!v39)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v38);
  goto LABEL_8;
}

void ValHelper<unsigned int>(uint64_t a1, void *a2)
{
  uint64_t Type = MIL::IRTypedTensorValue<unsigned int>::GetType(a1);
  uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)Type + 96))(Type);
  int v8 = 0;
  uint64_t v9 = 0;
  std::string __p = 0;
  std::vector<MIL::IRDimension const*>::__init_with_size[abi:ne180100]<MIL::IRDimension const**,MIL::IRDimension const**>(&__p, *(const void **)v5, *(void *)(v5 + 8), (uint64_t)(*(void *)(v5 + 8) - *(void *)v5) >> 3);
  if (__p == v8)
  {
    MIL::IRTypedTensorValue<unsigned int>::GetScalarValue(a1);
    std::ostream::operator<<();
  }
  uint64_t Values = MIL::IRTypedTensorValue<unsigned int>::GetValues(a1);
  if (__p)
  {
    int v8 = (MIL::IRDimension **)__p;
    operator delete(__p);
  }
}

void sub_20F46BD90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::Text::BasicSerializer::Val<unsigned long long>(uint64_t a1, MIL::IRTensorValue *a2)
{
  uint64_t v4 = *(void *)(a1 + 384);
  if (v4)
  {
    uint64_t Type = (MIL::IRValueType *)MIL::IRTypedTensorValue<unsigned long long>::GetType((uint64_t)a2);
    uint64_t v6 = MIL::IRValueType::AsTensorType(Type);
    unint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 16))(v6);
    int v8 = v7 >= (*(uint64_t (**)(void))(**(void **)(a1 + 320) + 136))(*(void *)(a1 + 320));
  }
  else
  {
    int v8 = MIL::IRTypedTensorValue<unsigned long long>::UsesFileStorage((uint64_t)a2);
  }
  uint64_t v9 = (MIL::IRValueType *)MIL::IRTypedTensorValue<unsigned long long>::GetType((uint64_t)a2);
  uint64_t v10 = MIL::IRValueType::AsTensorType(v9);
  unsigned int v11 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 88))(v10);
  int v12 = v11;
  if (!v4 || !v8 || (v11 <= 0x19 ? (BOOL v13 = ((1 << v11) & 0x3F9EE30) == 0) : (BOOL v13 = 1), !v13))
  {
    if (v8)
    {
      memset(v71, 0, sizeof(v71));
      int v72 = 1065353216;
      if (!v4)
      {
        uint64_t FileProperties = MIL::IRTypedTensorValue<unsigned long long>::GetFileProperties((uint64_t)a2);
        if (v71 != (_OWORD *)FileProperties)
        {
          int v72 = *(_DWORD *)(FileProperties + 32);
          std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *> *>>(v71, *(uint64_t **)(FileProperties + 16), 0);
        }
        std::string::basic_string[abi:ne180100]<0>(&__str, "type");
        v56 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>(v71, (unsigned __int8 *)&__str);
        if (v56)
        {
          MIL::IRValue::GetScalar<std::string>(*((const void **)v56 + 5), &__p);
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          std::string::basic_string[abi:ne180100]<0>(&__str, "type");
          std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__erase_unique<std::string>(v71, (unsigned __int8 *)&__str);
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          std::string::basic_string[abi:ne180100]<0>(&__str, "path");
          v57 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>(v71, (unsigned __int8 *)&__str);
          if (v57)
          {
            v59 = (const void *)*((void *)v57 + 5);
            uint64_t v58 = *((void *)v57 + 6);
            if (v58) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v58 + 8), 1uLL, memory_order_relaxed);
            }
            if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__str.__r_.__value_.__l.__data_);
            }
            MIL::IRValue::GetScalar<std::string>(v59, &__str);
            v60 = (void *)(*(uint64_t (**)(void))(**(void **)(a1 + 320) + 32))(*(void *)(a1 + 320));
            MIL::Util::ReplaceModelPaths(&__str, v60);
            v61 = (MIL::IRValueType *)(*(uint64_t (**)(const void *))(*(void *)v59 + 32))(v59);
            v62 = (_anonymous_namespace_ *)MIL::IRValueType::AsTensorType(v61);
            std::string v67 = __str;
            memset(&__str, 0, sizeof(__str));
            MIL::IRTensorValueType::MakeStringValue(v62, (const MIL::IRTensorValueType *)&v67);
          }
          std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
        }
        std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
      }
      uint64_t v14 = a1 + 368;
      if (MIL::IRTypedTensorValue<unsigned long long>::UsesFileStorage((uint64_t)a2))
      {
        v15 = (void *)MIL::IRTypedTensorValue<unsigned long long>::GetFileProperties((uint64_t)a2);
        std::string::basic_string[abi:ne180100]<0>(&__p, "path");
        v16 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v15, (unsigned __int8 *)&__p);
        if (!v16) {
          std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
        }
        v17 = (const void *)*((void *)v16 + 5);
        v18 = (std::__shared_weak_count *)*((void *)v16 + 6);
        if (v18) {
          atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        MIL::IRValue::GetScalar<std::string>(v17, &__p);
        __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p;
        v19 = std::__tree<std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)(a1 + 368), (const void **)&__p.__r_.__value_.__l.__data_, (uint64_t)&std::piecewise_construct, &__str);
        v21 = (MIL::Blob::StorageWriter *)*((void *)v19 + 7);
        uint64_t v20 = *((void *)v19 + 8);
        if (v20) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (v18) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v18);
        }
      }
      else
      {
        v21 = *(MIL::Blob::StorageWriter **)(*(void *)v14 + 56);
        uint64_t v23 = *(void *)(*(void *)v14 + 64);
        if (v23) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v23 + 8), 1uLL, memory_order_relaxed);
        }
      }
      memset(&__p, 0, sizeof(__p));
      uint64_t v73 = 0;
      if (!MIL::IRTypedTensorValue<unsigned long long>::UsesFileStorage((uint64_t)a2)) {
        goto LABEL_59;
      }
      v24 = (void *)MIL::IRTypedTensorValue<unsigned long long>::GetFileProperties((uint64_t)a2);
      std::string::basic_string[abi:ne180100]<0>(&__str, "path");
      v25 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v24, (unsigned __int8 *)&__str);
      if (!v25) {
        std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
      }
      v27 = (const void *)*((void *)v25 + 5);
      v26 = (std::__shared_weak_count *)*((void *)v25 + 6);
      if (v26) {
        atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str.__r_.__value_.__l.__data_);
      }
      MIL::IRValue::GetScalar<std::string>(v27, &__str);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      std::string __p = __str;
      std::string::basic_string[abi:ne180100]<0>(&__str, "offset");
      v28 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v24, (unsigned __int8 *)&__str);
      v29 = v28;
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__str.__r_.__value_.__l.__data_);
        if (v29)
        {
LABEL_39:
          std::string::basic_string[abi:ne180100]<0>(&__str, "offset");
          v30 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v24, (unsigned __int8 *)&__str);
          if (!v30) {
            std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
          }
          v31 = (const void *)*((void *)v30 + 5);
          v32 = (std::__shared_weak_count *)*((void *)v30 + 6);
          if (v32) {
            atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          uint64_t v73 = MIL::IRValue::GetScalar<unsigned long long>(v31);
          if (std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>((void *)(a1 + 328), (unsigned __int8 *)&__p))
          {
            v33 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>((void *)(a1 + 328), (unsigned __int8 *)&__p);
            if (!v33) {
              goto LABEL_94;
            }
            v34 = v33 + 40;
            if (std::__hash_table<std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>>>::find<unsigned long long>((void *)v33 + 5, (unint64_t *)&v73))
            {
              if (std::__hash_table<std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,MIL::Blob::LegacyStorageReader::FileInfo>>>::find<unsigned long long>(v34, (unint64_t *)&v73))
              {
                char v35 = 1;
                goto LABEL_50;
              }
LABEL_94:
              std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
            }
          }
          char v35 = 0;
LABEL_50:
          if (v32) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v32);
          }
          if (v26) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v26);
          }
          if (v35)
          {
LABEL_78:
            uint64_t v55 = MIL::IRTypedTensorValue<unsigned long long>::GetType((uint64_t)a2);
            (*(void (**)(uint64_t))(*(void *)v55 + 24))(v55);
            MIL::Blob::StorageWriter::GetFilePath(v21, &__str);
            MIL::IRTensorValueType::MakeValueFromBlobFile();
          }
LABEL_59:
          switch(v12)
          {
            case 4:
              v36 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::Fp16>(v36);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::Fp16>((uint64_t *)v21);
              break;
            case 5:
              v51 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<float>(v51);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<float>((uint64_t *)v21);
              break;
            case 9:
              v48 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<signed char>(v48);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<signed char>((uint64_t *)v21);
              break;
            case 10:
              v50 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<short>(v50);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<short>((uint64_t *)v21);
              break;
            case 11:
              v45 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<int>(v45);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<int>((uint64_t *)v21);
              break;
            case 13:
              v47 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::Int4>(v47);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::Int4>((uint64_t *)v21);
              break;
            case 14:
              v52 = (void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<unsigned char>(v52);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<unsigned char>((uint64_t *)v21);
              break;
            case 15:
              v49 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<unsigned short>(v49);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<unsigned short>((uint64_t *)v21);
              break;
            case 16:
              v42 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<unsigned int>(v42);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<unsigned int>((uint64_t *)v21);
              break;
            case 19:
              int v39 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::UInt2>(v39);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::UInt2>((uint64_t *)v21);
              break;
            case 20:
              v41 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::UInt4>(v41);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::UInt4>((uint64_t *)v21);
              break;
            case 21:
              v38 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::UInt1>(v38);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::UInt1>((uint64_t *)v21);
              break;
            case 22:
              v40 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::UInt3>(v40);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::UInt3>((uint64_t *)v21);
              break;
            case 23:
              v43 = (const void *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::UInt6>(v43);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::UInt6>((uint64_t *)v21);
              break;
            case 24:
              v44 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::Fp8E4M3FN>(v44);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::Fp8E4M3FN>((uint64_t *)v21);
              break;
            case 25:
              v46 = (uint64_t *)MIL::IRTensorValue::TryAsTensor(a2);
              MIL::IRTensorValue::GetDataView<MIL::Fp8E5M2>(v46);
              unint64_t v37 = MIL::Blob::StorageWriter::WriteData<MIL::Fp8E5M2>((uint64_t *)v21);
              break;
            default:
              exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
              MIL::IRDataTypeToString(v12, &v68);
              v65 = std::string::insert(&v68, 0, "[MIL Serialization] Unsupported Data type ");
              long long v66 = *(_OWORD *)&v65->__r_.__value_.__l.__data_;
              __str.__r_.__value_.__r.__words[2] = v65->__r_.__value_.__r.__words[2];
              *(_OWORD *)&__str.__r_.__value_.__l.__data_ = v66;
              v65->__r_.__value_.__l.__size_ = 0;
              v65->__r_.__value_.__r.__words[2] = 0;
              v65->__r_.__value_.__r.__words[0] = 0;
              std::logic_error::logic_error(exception, &__str);
              exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
              __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
          }
          unint64_t v53 = v37;
          if (MIL::IRTypedTensorValue<unsigned long long>::UsesFileStorage((uint64_t)a2))
          {
            __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p;
            v54 = std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1 + 328, (unsigned __int8 *)&__p, (uint64_t)&std::piecewise_construct, (long long **)&__str);
            __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&v73;
            std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t)(v54 + 40), (unint64_t *)&v73, (uint64_t)&std::piecewise_construct, &__str)[3] = v53;
          }
          goto LABEL_78;
        }
      }
      else if (v28)
      {
        goto LABEL_39;
      }
      if (v26) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v26);
      }
      goto LABEL_59;
    }
  }
  ValHelper<unsigned long long>((uint64_t)a2, *(void **)(a1 + 40));
  return a1;
}

void sub_20F46C9A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,char a37)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a22 < 0)
  {
    operator delete(a17);
    if ((v39 & 1) == 0)
    {
LABEL_8:
      if (a35 < 0) {
        operator delete(a30);
      }
      if (v37) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v37);
      }
      std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a37);
      _Unwind_Resume(a1);
    }
  }
  else if (!v39)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v38);
  goto LABEL_8;
}

void ValHelper<unsigned long long>(uint64_t a1, void *a2)
{
  uint64_t Type = MIL::IRTypedTensorValue<unsigned long long>::GetType(a1);
  uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)Type + 96))(Type);
  int v8 = 0;
  uint64_t v9 = 0;
  std::string __p = 0;
  std::vector<MIL::IRDimension const*>::__init_with_size[abi:ne180100]<MIL::IRDimension const**,MIL::IRDimension const**>(&__p, *(const void **)v5, *(void *)(v5 + 8), (uint64_t)(*(void *)(v5 + 8) - *(void *)v5) >> 3);
  if (__p == v8)
  {
    MIL::IRTypedTensorValue<unsigned long long>::GetScalarValue(a1);
    std::ostream::operator<<();
  }
  uint64_t Values = MIL::IRTypedTensorValue<unsigned long long>::GetValues(a1);
  if (__p)
  {
    int v8 = (MIL::IRDimension **)__p;
    operator delete(__p);
  }
}

void sub_20F46CD30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_emplace<std::unordered_map<std::string,std::string>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C25CB30;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::unordered_map<std::string,std::string>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C25CB30;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21056C700);
}

uint64_t std::__shared_ptr_emplace<std::unordered_map<std::string,std::string>>::__on_zero_shared(uint64_t a1)
{
  return std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table(a1 + 24);
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>>>::__deallocate_node(a1, *(void **)(a1 + 16));
  v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>>>::__deallocate_node(uint64_t a1, void *a2)
{
  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (void *)*v2;
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::unordered_map<unsigned long long,unsigned long long>>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::unordered_map<unsigned long long,unsigned long long>>,0>(uint64_t a1)
{
  std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table(a1 + 24);
  if (*(char *)(a1 + 23) < 0)
  {
    v2 = *(void **)a1;
    operator delete(v2);
  }
}

void std::__tree<std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>>>::destroy(a1, a2[1]);
    std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::shared_ptr<MIL::IRValue const>>,0>((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void *std::allocate_shared[abi:ne180100]<MIL::Blob::StorageWriter,std::allocator<MIL::Blob::StorageWriter>,std::string const&,BOOL,void>@<X0>(uint64_t a1@<X1>, unsigned __int8 *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x20uLL);
  result = std::__shared_ptr_emplace<MIL::Blob::StorageWriter>::__shared_ptr_emplace[abi:ne180100]<std::string const&,BOOL,std::allocator<MIL::Blob::StorageWriter>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_20F46CF50(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<MIL::Blob::StorageWriter>::__shared_ptr_emplace[abi:ne180100]<std::string const&,BOOL,std::allocator<MIL::Blob::StorageWriter>,0>(void *a1, uint64_t a2, unsigned __int8 *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_26C25CB80;
  MIL::Blob::StorageWriter::StorageWriter(a1 + 3, a2, *a3);
  return a1;
}

void sub_20F46CFB0(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<MIL::Blob::StorageWriter>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C25CB80;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<MIL::Blob::StorageWriter>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C25CB80;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21056C700);
}

void std::__shared_ptr_emplace<MIL::Blob::StorageWriter>::__on_zero_shared(uint64_t a1)
{
}

uint64_t *std::__tree<std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t **a1, const void **a2, uint64_t a3, long long **a4)
{
  uint64_t v6 = (uint64_t **)std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__find_equal<std::string>((uint64_t)a1, &v11, a2);
  unint64_t v7 = *v6;
  if (!*v6)
  {
    int v8 = v6;
    std::__tree<std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)a1, a4, (uint64_t)v10);
    std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__insert_node_at(a1, v11, v8, v10[0]);
    unint64_t v7 = v10[0];
    v10[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>,void *>>>>::reset[abi:ne180100]((uint64_t)v10, 0);
  }
  return v7;
}

void std::__tree<std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1@<X0>, long long **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  uint64_t v6 = operator new(0x48uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  unint64_t v7 = (std::string *)(v6 + 4);
  int v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)v8, *((void *)v8 + 1));
  }
  else
  {
    long long v9 = *v8;
    v6[6] = *((void *)v8 + 2);
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v9;
  }
  v6[7] = 0;
  v6[8] = 0;
  *(unsigned char *)(a3 + 16) = 1;
}

void sub_20F46D16C(_Unwind_Exception *a1)
{
  std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::shared_ptr<MIL::IRValue const>>,0>((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }
}

_OWORD *std::__tree<std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(uint64_t **a1, const void **a2, uint64_t a3, _OWORD **a4)
{
  uint64_t v6 = (void **)std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__find_equal<std::string>((uint64_t)a1, &v14, a2);
  unint64_t v7 = *v6;
  if (!*v6)
  {
    int v8 = (uint64_t **)v6;
    unint64_t v7 = operator new(0x48uLL);
    v12[1] = a1 + 1;
    long long v9 = *a4;
    uint64_t v10 = *((void *)*a4 + 2);
    v7[2] = **a4;
    *((void *)v7 + 6) = v10;
    v9[1] = 0;
    v9[2] = 0;
    void *v9 = 0;
    *((void *)v7 + 7) = 0;
    *((void *)v7 + 8) = 0;
    char v13 = 1;
    std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__insert_node_at(a1, v14, v8, (uint64_t *)v7);
    v12[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::shared_ptr<MIL::Blob::StorageWriter>>,void *>>>>::reset[abi:ne180100]((uint64_t)v12, 0);
  }
  return v7;
}

void *std::allocate_shared[abi:ne180100]<MIL::Blob::StorageWriter,std::allocator<MIL::Blob::StorageWriter>,std::string &,BOOL,void>@<X0>(uint64_t a1@<X1>, unsigned __int8 *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x20uLL);
  result = std::__shared_ptr_emplace<MIL::Blob::StorageWriter>::__shared_ptr_emplace[abi:ne180100]<std::string &,BOOL,std::allocator<MIL::Blob::StorageWriter>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_20F46D2F0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<MIL::Blob::StorageWriter>::__shared_ptr_emplace[abi:ne180100]<std::string &,BOOL,std::allocator<MIL::Blob::StorageWriter>,0>(void *a1, uint64_t a2, unsigned __int8 *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_26C25CB80;
  MIL::Blob::StorageWriter::StorageWriter(a1 + 3, a2, *a3);
  return a1;
}

void sub_20F46D350(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

MIL::IRDimension **anonymous namespace'::SerializeImmediateTensorDim<BOOL,MIL::Util::Span<BOOL const,18446744073709551615ul>>(MIL::IRDimension **result, MIL::IRDimension **a2, unint64_t *a3, void *a4)
{
  if (result != a2)
  {
    int v8 = result;
    uint64_t v9 = MIL::IRDimension::AsConstant(*result);
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 48))(v9);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)"[", 1);
    if (v10)
    {
      if (a2 - 1 == v8)
      {
        if (v10 >= 1)
        {
          uint64_t v14 = "";
          unint64_t v15 = *a3 + v10;
          do
          {
            size_t v16 = strlen(v14);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)v14, v16);
            if (*(unsigned char *)*a3) {
              v17 = "true";
            }
            else {
              v17 = "false";
            }
            if (*(unsigned char *)*a3) {
              uint64_t v18 = 4;
            }
            else {
              uint64_t v18 = 5;
            }
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)v17, v18);
            unint64_t v19 = *a3 + 1;
            *a3 = v19;
            uint64_t v14 = ", ";
          }
          while (v19 < v15);
        }
      }
      else
      {
        uint64_t v11 = v8 + 1;
        int v12 = "";
        do
        {
          size_t v13 = strlen(v12);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)v12, v13);
          int v12 = ", ";
          --v10;
        }
        while (v10);
      }
    }
    return (MIL::IRDimension **)std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)"]", 1);
  }
  return result;
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1, unsigned __int8 *a2, uint64_t a3, long long **a4)
{
  int v8 = (void *)(a1 + 24);
  unint64_t v9 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  unint64_t v10 = v9;
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    unint64_t v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v4 = v9;
      if (v9 >= v11) {
        unint64_t v4 = v9 % v11;
      }
    }
    else
    {
      unint64_t v4 = (v11 - 1) & v9;
    }
    uint64_t v14 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v4);
    if (v14)
    {
      for (i = *v14; i; i = *(unsigned __int8 **)i)
      {
        unint64_t v16 = *((void *)i + 1);
        if (v16 == v10)
        {
          if (std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2)) {
            return i;
          }
        }
        else
        {
          if (v13 > 1)
          {
            if (v16 >= v11) {
              v16 %= v11;
            }
          }
          else
          {
            v16 &= v11 - 1;
          }
          if (v16 != v4) {
            break;
          }
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1, v10, a4, (uint64_t)v26);
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v18 = *(float *)(a1 + 32);
  if (!v11 || (float)(v18 * (float)v11) < v17)
  {
    BOOL v19 = 1;
    if (v11 >= 3) {
      BOOL v19 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v11);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v22);
    unint64_t v11 = *(void *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11) {
        unint64_t v4 = v10 % v11;
      }
      else {
        unint64_t v4 = v10;
      }
    }
    else
    {
      unint64_t v4 = (v11 - 1) & v10;
    }
  }
  uint64_t v23 = *(void **)(*(void *)a1 + 8 * v4);
  if (v23)
  {
    *(void *)v26[0] = *v23;
    *uint64_t v23 = v26[0];
  }
  else
  {
    *(void *)v26[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v26[0];
    *(void *)(*(void *)a1 + 8 * v4) = a1 + 16;
    if (*(void *)v26[0])
    {
      unint64_t v24 = *(void *)(*(void *)v26[0] + 8);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v24 >= v11) {
          v24 %= v11;
        }
      }
      else
      {
        v24 &= v11 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v24) = v26[0];
    }
  }
  i = (unsigned __int8 *)v26[0];
  v26[0] = 0;
  ++*v8;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,void *>>>>::reset[abi:ne180100]((uint64_t)v26, 0);
  return i;
}

void sub_20F46D77C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

double std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, long long **a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  int v8 = (char *)operator new(0x50uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *(unsigned char *)(a4 + 16) = 0;
  *(void *)int v8 = 0;
  *((void *)v8 + 1) = a2;
  unint64_t v9 = (std::string *)(v8 + 16);
  unint64_t v10 = *a3;
  if (*((char *)*a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)v10, *((void *)v10 + 1));
  }
  else
  {
    long long v11 = *v10;
    *((void *)v8 + 4) = *((void *)v10 + 2);
    *(_OWORD *)&v9->__r_.__value_.__l.__data_ = v11;
  }
  double result = 0.0;
  *(_OWORD *)(v8 + 56) = 0u;
  *(_OWORD *)(v8 + 40) = 0u;
  *((_DWORD *)v8 + 18) = 1065353216;
  *(unsigned char *)(a4 + 16) = 1;
  return result;
}

void sub_20F46D82C(_Unwind_Exception *a1)
{
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<unsigned long long,unsigned long long>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::unordered_map<unsigned long long,unsigned long long>>,0>((uint64_t)v2 + 16);
    }
    operator delete(v2);
  }
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(uint64_t a1, unint64_t *a2, uint64_t a3, void **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
    unint64_t v10 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      for (i = *v10; i; i = (void *)*i)
      {
        unint64_t v12 = i[1];
        if (v12 == v7)
        {
          if (i[2] == v7) {
            return i;
          }
        }
        else
        {
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= v8) {
              v12 %= v8;
            }
          }
          else
          {
            v12 &= v8 - 1;
          }
          if (v12 != v4) {
            break;
          }
        }
      }
    }
  }
  i = operator new(0x20uLL);
  void *i = 0;
  i[1] = v7;
  i[2] = **a4;
  i[3] = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v8 || (float)(v14 * (float)v8) < v13)
  {
    BOOL v15 = 1;
    if (v8 >= 3) {
      BOOL v15 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v8);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v18);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }
  uint64_t v19 = *(void *)a1;
  unint64_t v20 = *(void **)(*(void *)a1 + 8 * v4);
  if (v20)
  {
    void *i = *v20;
LABEL_38:
    *unint64_t v20 = i;
    goto LABEL_39;
  }
  void *i = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(v19 + 8 * v4) = a1 + 16;
  if (*i)
  {
    unint64_t v21 = *(void *)(*i + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v21 >= v8) {
        v21 %= v8;
      }
    }
    else
    {
      v21 &= v8 - 1;
    }
    unint64_t v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_20F46DAA8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *> *>>(void *a1, uint64_t *a2, uint64_t *a3)
{
  unint64_t v4 = a2;
  uint64_t v6 = a1[1];
  if (v6)
  {
    for (uint64_t i = 0; i != v6; ++i)
      *(void *)(*a1 + 8 * i) = 0;
    unint64_t v8 = (void *)a1[2];
    a1[2] = 0;
    a1[3] = 0;
    if (v8) {
      BOOL v9 = a2 == a3;
    }
    else {
      BOOL v9 = 1;
    }
    if (v9)
    {
      unint64_t v10 = v8;
    }
    else
    {
      do
      {
        v12[0] = v8 + 2;
        v12[1] = v8 + 5;
        std::pair<std::string &,std::shared_ptr<MIL::IRValue const> &>::operator=[abi:ne180100]<std::string const,std::shared_ptr<MIL::IRValue const>,(void *)0>((uint64_t)v12, (const std::string *)(v4 + 2));
        unint64_t v10 = (void *)*v8;
        std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__node_insert_multi(a1, v8);
        unint64_t v4 = (uint64_t *)*v4;
        if (v10) {
          BOOL v11 = v4 == a3;
        }
        else {
          BOOL v11 = 1;
        }
        unint64_t v8 = v10;
      }
      while (!v11);
    }
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__deallocate_node((uint64_t)a1, v10);
  }
  while (v4 != a3)
  {
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__emplace_multi<std::pair<std::string const,std::shared_ptr<MIL::IRValue const>> const&>(a1, (long long *)v4 + 1);
    unint64_t v4 = (uint64_t *)*v4;
  }
}

void sub_20F46DB9C(void *a1)
{
  __cxa_begin_catch(a1);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__deallocate_node(v1, v2);
  __cxa_rethrow();
}

void sub_20F46DBB8(_Unwind_Exception *a1)
{
}

void *std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__node_insert_multi(void *a1, void *a2)
{
  unint64_t v4 = (unsigned __int8 *)(a2 + 2);
  unint64_t v5 = std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)(a1 + 3), (uint64_t)(a2 + 2));
  a2[1] = v5;
  inserted = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__node_insert_multi_prepare((uint64_t)a1, v5, v4);
  std::__hash_table<std::shared_ptr<MIL::Builder::OperationBuilder>,std::hash<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::equal_to<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::allocator<std::shared_ptr<MIL::Builder::OperationBuilder>>>::__node_insert_multi_perform(a1, a2, inserted);
  return a2;
}

uint64_t std::pair<std::string &,std::shared_ptr<MIL::IRValue const> &>::operator=[abi:ne180100]<std::string const,std::shared_ptr<MIL::IRValue const>,(void *)0>(uint64_t a1, const std::string *a2)
{
  std::string::operator=(*(std::string **)a1, a2);
  unint64_t v4 = *(std::string::pointer **)(a1 + 8);
  std::string::pointer data = a2[1].__r_.__value_.__l.__data_;
  std::string::size_type size = a2[1].__r_.__value_.__l.__size_;
  if (size) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(size + 8), 1uLL, memory_order_relaxed);
  }
  unint64_t v7 = (std::__shared_weak_count *)v4[1];
  *unint64_t v4 = data;
  v4[1] = (std::string::pointer)size;
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  return a1;
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__node_insert_multi_prepare(uint64_t a1, unint64_t a2, unsigned __int8 *a3)
{
  uint64_t v6 = a1 + 32;
  float v7 = *(float *)(a1 + 32);
  unint64_t v8 = *(void *)(a1 + 8);
  float v9 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  if (!v8 || (float)(v7 * (float)v8) < v9)
  {
    BOOL v10 = 1;
    if (v8 >= 3) {
      BOOL v10 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v11 = v10 | (2 * v8);
    unint64_t v12 = vcvtps_u32_f32(v9 / v7);
    if (v11 <= v12) {
      size_t v13 = v12;
    }
    else {
      size_t v13 = v11;
    }
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<false>(a1, v13);
    unint64_t v8 = *(void *)(a1 + 8);
  }
  uint8x8_t v14 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
  v14.i16[0] = vaddlv_u8(v14);
  unint64_t v15 = v14.u32[0];
  if (v14.u32[0] > 1uLL)
  {
    unint64_t v16 = a2;
    if (v8 <= a2) {
      unint64_t v16 = a2 % v8;
    }
  }
  else
  {
    unint64_t v16 = (v8 - 1) & a2;
  }
  unint64_t v17 = *(unsigned __int8 **)(*(void *)a1 + 8 * v16);
  if (v17)
  {
    size_t v18 = *(unsigned __int8 **)v17;
    if (*(void *)v17)
    {
      int v19 = 0;
      do
      {
        unint64_t v20 = *((void *)v18 + 1);
        if (v15 > 1)
        {
          unint64_t v21 = *((void *)v18 + 1);
          if (v20 >= v8) {
            unint64_t v21 = v20 % v8;
          }
        }
        else
        {
          unint64_t v21 = v20 & (v8 - 1);
        }
        if (v21 != v16) {
          break;
        }
        int v22 = v20 == a2 ? std::equal_to<std::string>::operator()[abi:ne180100](v6, v18 + 16, a3) : 0;
        if (v19 & (v22 ^ 1)) {
          break;
        }
        v19 |= v22;
        unint64_t v17 = *(unsigned __int8 **)v17;
        size_t v18 = *(unsigned __int8 **)v17;
      }
      while (*(void *)v17);
    }
  }
  return v17;
}

void std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<false>(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2;
  }
  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }
  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(void *)&v4) {
    goto LABEL_16;
  }
  if (prime < *(void *)&v4)
  {
    unint64_t v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      unint64_t v5 = std::__next_prime(v5);
    }
    else
    {
      uint64_t v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2) {
        unint64_t v5 = v7;
      }
    }
    if (prime <= v5) {
      size_t prime = v5;
    }
    if (prime < *(void *)&v4)
    {
LABEL_16:
      std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__do_rehash<false>(a1, prime);
    }
  }
}

void std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__do_rehash<false>(uint64_t a1, unint64_t a2)
{
  if (a2)
  {
    if (a2 >> 61) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    int8x8_t v4 = operator new(8 * a2);
    unint64_t v5 = *(void **)a1;
    *(void *)a1 = v4;
    if (v5) {
      operator delete(v5);
    }
    uint64_t v6 = 0;
    *(void *)(a1 + 8) = a2;
    do
      *(void *)(*(void *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    uint64_t v7 = *(unsigned __int8 ***)(a1 + 16);
    if (v7)
    {
      unint64_t v8 = (unint64_t)v7[1];
      uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      unint64_t v10 = v9.u32[0];
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2) {
          v8 %= a2;
        }
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v8) = a1 + 16;
      unint64_t v12 = *v7;
      if (*v7)
      {
        unint64_t v18 = v9.u32[0];
        do
        {
          unint64_t v13 = *((void *)v12 + 1);
          if (v10 > 1)
          {
            if (v13 >= a2) {
              v13 %= a2;
            }
          }
          else
          {
            v13 &= a2 - 1;
          }
          if (v13 == v8)
          {
            uint64_t v7 = (unsigned __int8 **)v12;
          }
          else if (*(void *)(*(void *)a1 + 8 * v13))
          {
            uint8x8_t v14 = *(unsigned __int8 **)v12;
            if (*(void *)v12)
            {
              unint64_t v15 = v12;
              while (1)
              {
                int v16 = std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, v12 + 16, v14 + 16);
                unint64_t v17 = *(unsigned __int8 **)v15;
                if (!v16) {
                  break;
                }
                uint8x8_t v14 = *(unsigned __int8 **)v17;
                unint64_t v15 = *(unsigned __int8 **)v15;
                if (!*(void *)v17) {
                  goto LABEL_32;
                }
              }
              uint8x8_t v14 = *(unsigned __int8 **)v15;
              unint64_t v17 = v15;
LABEL_32:
              unint64_t v10 = v18;
            }
            else
            {
              unint64_t v17 = v12;
            }
            *uint64_t v7 = v14;
            *(void *)unint64_t v17 = **(void **)(*(void *)a1 + 8 * v13);
            **(void **)(*(void *)a1 + 8 * v13) = v12;
          }
          else
          {
            *(void *)(*(void *)a1 + 8 * v13) = v7;
            uint64_t v7 = (unsigned __int8 **)v12;
            unint64_t v8 = v13;
          }
          unint64_t v12 = *v7;
        }
        while (*v7);
      }
    }
  }
  else
  {
    unint64_t v11 = *(void **)a1;
    *(void *)a1 = 0;
    if (v11) {
      operator delete(v11);
    }
    *(void *)(a1 + 8) = 0;
  }
}

void *std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__emplace_multi<std::pair<std::string const,std::shared_ptr<MIL::IRValue const>> const&>(void *a1, long long *a2)
{
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__construct_node<std::pair<std::string const,std::shared_ptr<MIL::IRValue const>> const&>((uint64_t)a1, a2, (uint64_t)v5);
  inserted = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__node_insert_multi(a1, v5[0]);
  v5[0] = 0;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100]((uint64_t)v5, 0);
  return inserted;
}

void sub_20F46E110(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

unint64_t std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__construct_node<std::pair<std::string const,std::shared_ptr<MIL::IRValue const>> const&>@<X0>(uint64_t a1@<X0>, long long *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = a1 + 16;
  uint64_t v7 = (char *)operator new(0x38uLL);
  *(void *)a3 = v7;
  *(void *)(a3 + 8) = v6;
  *(unsigned char *)(a3 + 16) = 0;
  *(void *)uint64_t v7 = 0;
  *((void *)v7 + 1) = 0;
  std::pair<std::string const,std::shared_ptr<MIL::IRValue const>>::pair[abi:ne180100]((std::string *)(v7 + 16), a2);
  *(unsigned char *)(a3 + 16) = 1;
  unint64_t result = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)(v7 + 16));
  *((void *)v7 + 1) = result;
  return result;
}

void sub_20F46E1A4(_Unwind_Exception *a1)
{
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

void anonymous namespace'::ScalarToString<std::string>(uint64_t *a1, void *a2)
{
  v3 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"\"", 1);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v16);
  BOOL v4 = *((char *)a1 + 23) < 0;
  uint64_t v5 = *((unsigned __int8 *)a1 + 23);
  if ((v5 & 0x80u) != 0) {
    uint64_t v5 = a1[1];
  }
  if (v5)
  {
    unint64_t v6 = 0;
    do
    {
      if (v4) {
        uint64_t v7 = (uint64_t *)*a1;
      }
      else {
        uint64_t v7 = a1;
      }
      int v8 = *((unsigned __int8 *)v7 + v6);
      if (v8 == 92 || v8 == 34)
      {
        char v20 = 92;
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)&v20, 1);
      }
      char v20 = v8;
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)&v20, 1);
      ++v6;
      BOOL v4 = *((char *)a1 + 23) < 0;
      unint64_t v9 = *((unsigned __int8 *)a1 + 23);
      if ((v9 & 0x80u) != 0) {
        unint64_t v9 = a1[1];
      }
    }
    while (v6 < v9);
  }
  std::stringbuf::str();
  v16[0] = *MEMORY[0x263F8C2B8];
  uint64_t v10 = *(void *)(MEMORY[0x263F8C2B8] + 72);
  *(void *)((char *)v16 + *(void *)(v16[0] - 24)) = *(void *)(MEMORY[0x263F8C2B8] + 64);
  v17[0] = v10;
  v17[1] = MEMORY[0x263F8C318] + 16;
  if (v18 < 0) {
    operator delete((void *)v17[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x21056C620](&v19);
  if ((v15 & 0x80u) == 0) {
    unint64_t v11 = v14;
  }
  else {
    unint64_t v11 = (void **)v14[0];
  }
  if ((v15 & 0x80u) == 0) {
    uint64_t v12 = v15;
  }
  else {
    uint64_t v12 = (uint64_t)v14[1];
  }
  unint64_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)v11, v12);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)"\"", 1);
  if ((char)v15 < 0) {
    operator delete(v14[0]);
  }
}

void sub_20F46E418(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
}

MIL::IRDimension **anonymous namespace'::SerializeImmediateTensorDim<std::string,MIL::Util::Span<std::string const,18446744073709551615ul>>(MIL::IRDimension **result, MIL::IRDimension **a2, uint64_t **a3, void *a4)
{
  if (result != a2)
  {
    int v8 = result;
    uint64_t v9 = MIL::IRDimension::AsConstant(*result);
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 48))(v9);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)"[", 1);
    if (v10)
    {
      if (a2 - 1 == v8)
      {
        if (v10 >= 1)
        {
          unint64_t v14 = (unint64_t)&(*a3)[3 * v10];
          unsigned __int8 v15 = "";
          do
          {
            size_t v16 = strlen(v15);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)v15, v16);
            unint64_t v17 = (unint64_t)(*a3 + 3);
            *a3 = (uint64_t *)v17;
            unsigned __int8 v15 = ", ";
          }
          while (v17 < v14);
        }
      }
      else
      {
        unint64_t v11 = v8 + 1;
        uint64_t v12 = "";
        do
        {
          size_t v13 = strlen(v12);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)v12, v13);
          uint64_t v12 = ", ";
          --v10;
        }
        while (v10);
      }
    }
    return (MIL::IRDimension **)std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)"]", 1);
  }
  return result;
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = MEMORY[0x263F8C328] + 104;
  *(void *)(a1 + 128) = MEMORY[0x263F8C328] + 104;
  uint64_t v3 = a1 + 16;
  uint64_t v4 = MEMORY[0x263F8C328] + 64;
  *(void *)(a1 + 16) = MEMORY[0x263F8C328] + 64;
  uint64_t v5 = (void *)MEMORY[0x263F8C2B8];
  uint64_t v6 = *(void *)(MEMORY[0x263F8C2B8] + 24);
  uint64_t v7 = *(void *)(MEMORY[0x263F8C2B8] + 16);
  *(void *)a1 = v7;
  *(void *)(a1 + *(void *)(v7 - 24)) = v6;
  *(void *)(a1 + 8) = 0;
  int v8 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24));
  std::ios_base::init(v8, (void *)(a1 + 24));
  uint64_t v9 = MEMORY[0x263F8C328] + 24;
  v8[1].__vftable = 0;
  v8[1].__fmtflags_ = -1;
  uint64_t v10 = v5[5];
  uint64_t v11 = v5[4];
  *(void *)(a1 + 16) = v11;
  *(void *)(v3 + *(void *)(v11 - 24)) = v10;
  uint64_t v12 = v5[1];
  *(void *)a1 = v12;
  *(void *)(a1 + *(void *)(v12 - 24)) = v5[6];
  *(void *)a1 = v9;
  *(void *)(a1 + 128) = v2;
  *(void *)(a1 + 16) = v4;
  std::streambuf::basic_streambuf();
  *(void *)(a1 + 24) = MEMORY[0x263F8C318] + 16;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_DWORD *)(a1 + 120) = 24;
  return a1;
}

void sub_20F46E86C(_Unwind_Exception *a1)
{
  std::iostream::~basic_iostream();
  MEMORY[0x21056C620](v1);
  _Unwind_Resume(a1);
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x263F8C2B8];
  uint64_t v3 = *MEMORY[0x263F8C2B8];
  *(void *)a1 = *MEMORY[0x263F8C2B8];
  uint64_t v4 = *(void *)(v2 + 72);
  *(void *)(a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 64);
  *(void *)(a1 + 16) = v4;
  *(void *)(a1 + 24) = MEMORY[0x263F8C318] + 16;
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x21056C620](a1 + 128);
  return a1;
}

MIL::IRDimension **anonymous namespace'::SerializeImmediateTensorDim<MIL::Bf16,MIL::Util::Span<MIL::Bf16 const,18446744073709551615ul>>(MIL::IRDimension **result, MIL::IRDimension **a2, MIL::Bf16 **a3, void *a4, uint64_t a5)
{
  if (result != a2)
  {
    uint64_t v10 = result;
    uint64_t v11 = MIL::IRDimension::AsConstant(*result);
    uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 48))(v11);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)"[", 1);
    if (v12)
    {
      if (a2 - 1 == v10)
      {
        if (v12 >= 1)
        {
          unint64_t v16 = (unint64_t)*a3 + 2 * v12;
          unint64_t v17 = "";
          do
          {
            size_t v18 = strlen(v17);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)v17, v18);
            MIL::Bf16::GetFloat(*a3);
            unint64_t v19 = (unint64_t)*a3 + 2;
            *a3 = (MIL::Bf16 *)v19;
            unint64_t v17 = ", ";
          }
          while (v19 < v16);
        }
      }
      else
      {
        size_t v13 = v10 + 1;
        unint64_t v14 = "";
        do
        {
          size_t v15 = strlen(v14);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)v14, v15);
          unint64_t v14 = ", ";
          --v12;
        }
        while (v12);
      }
    }
    return (MIL::IRDimension **)std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)"]", 1);
  }
  return result;
}

void *anonymous namespace'::FloatToString<float>(uint64_t a1, void *a2, uint64_t a3)
{
  int v4 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 80))(a3, a1);
  if (v4 == 1)
  {
    *(_DWORD *)((char *)a2 + *(void *)(*a2 - 24) + 8) |= 0x104u;
    unint64_t result = (void *)std::ostream::operator<<();
    *(_DWORD *)((char *)result + *(void *)(*result - 24) + 8) = *(_DWORD *)((unsigned char *)result
                                                                              + *(void *)(*result - 24)
                                                                              + 8) & 0xFFFFFEFB | 4;
  }
  else
  {
    if (v4)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Unexpected float serialization mode.");
      __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
    }
    *(void *)((char *)a2 + *(void *)(*a2 - 24) + 16) = 9;
    return (void *)std::ostream::operator<<();
  }
  return result;
}

void sub_20F46ECC8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

MIL::IRDimension **anonymous namespace'::SerializeImmediateTensorDim<MIL::Fp16,MIL::Util::Span<MIL::Fp16 const,18446744073709551615ul>>(MIL::IRDimension **result, MIL::IRDimension **a2, MIL::Fp16 **a3, void *a4, uint64_t a5)
{
  if (result != a2)
  {
    uint64_t v10 = result;
    uint64_t v11 = MIL::IRDimension::AsConstant(*result);
    uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 48))(v11);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)"[", 1);
    if (v12)
    {
      if (a2 - 1 == v10)
      {
        if (v12 >= 1)
        {
          unint64_t v16 = (unint64_t)*a3 + 2 * v12;
          unint64_t v17 = "";
          do
          {
            size_t v18 = strlen(v17);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)v17, v18);
            MIL::Fp16::GetFloat(*a3);
            unint64_t v19 = (unint64_t)*a3 + 2;
            *a3 = (MIL::Fp16 *)v19;
            unint64_t v17 = ", ";
          }
          while (v19 < v16);
        }
      }
      else
      {
        size_t v13 = v10 + 1;
        unint64_t v14 = "";
        do
        {
          size_t v15 = strlen(v14);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)v14, v15);
          unint64_t v14 = ", ";
          --v12;
        }
        while (v12);
      }
    }
    return (MIL::IRDimension **)std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)"]", 1);
  }
  return result;
}

MIL::IRDimension **anonymous namespace'::SerializeImmediateTensorDim<MIL::Fp8E5M2,MIL::Util::Span<MIL::Fp8E5M2 const,18446744073709551615ul>>(MIL::IRDimension **result, MIL::IRDimension **a2, MIL::Fp8E5M2 **a3, void *a4, uint64_t a5)
{
  if (result != a2)
  {
    uint64_t v10 = result;
    uint64_t v11 = MIL::IRDimension::AsConstant(*result);
    uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 48))(v11);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)"[", 1);
    if (v12)
    {
      if (a2 - 1 == v10)
      {
        if (v12 >= 1)
        {
          unint64_t v16 = (char *)*a3 + v12;
          unint64_t v17 = "";
          do
          {
            size_t v18 = strlen(v17);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)v17, v18);
            MIL::Fp8E5M2::GetFloat(*a3);
            unint64_t v19 = (unint64_t)*a3 + 1;
            *a3 = (MIL::Fp8E5M2 *)v19;
            unint64_t v17 = ", ";
          }
          while (v19 < (unint64_t)v16);
        }
      }
      else
      {
        size_t v13 = v10 + 1;
        unint64_t v14 = "";
        do
        {
          size_t v15 = strlen(v14);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)v14, v15);
          unint64_t v14 = ", ";
          --v12;
        }
        while (v12);
      }
    }
    return (MIL::IRDimension **)std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)"]", 1);
  }
  return result;
}

MIL::IRDimension **anonymous namespace'::SerializeImmediateTensorDim<MIL::Fp8E4M3FN,MIL::Util::Span<MIL::Fp8E4M3FN const,18446744073709551615ul>>(MIL::IRDimension **result, MIL::IRDimension **a2, MIL::Fp8E4M3FN **a3, void *a4, uint64_t a5)
{
  if (result != a2)
  {
    uint64_t v10 = result;
    uint64_t v11 = MIL::IRDimension::AsConstant(*result);
    uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 48))(v11);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)"[", 1);
    if (v12)
    {
      if (a2 - 1 == v10)
      {
        if (v12 >= 1)
        {
          unint64_t v16 = (char *)*a3 + v12;
          unint64_t v17 = "";
          do
          {
            size_t v18 = strlen(v17);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)v17, v18);
            MIL::Fp8E4M3FN::GetFloat(*a3);
            unint64_t v19 = (unint64_t)*a3 + 1;
            *a3 = (MIL::Fp8E4M3FN *)v19;
            unint64_t v17 = ", ";
          }
          while (v19 < (unint64_t)v16);
        }
      }
      else
      {
        size_t v13 = v10 + 1;
        unint64_t v14 = "";
        do
        {
          size_t v15 = strlen(v14);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)v14, v15);
          unint64_t v14 = ", ";
          --v12;
        }
        while (v12);
      }
    }
    return (MIL::IRDimension **)std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)"]", 1);
  }
  return result;
}

MIL::IRDimension **anonymous namespace'::SerializeImmediateTensorDim<float,MIL::Util::Span<float const,18446744073709551615ul>>(MIL::IRDimension **result, MIL::IRDimension **a2, unint64_t *a3, void *a4, uint64_t a5)
{
  if (result != a2)
  {
    uint64_t v10 = result;
    uint64_t v11 = MIL::IRDimension::AsConstant(*result);
    uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 48))(v11);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)"[", 1);
    if (v12)
    {
      if (a2 - 1 == v10)
      {
        if (v12 >= 1)
        {
          unint64_t v16 = *a3 + 4 * v12;
          unint64_t v17 = "";
          do
          {
            size_t v18 = strlen(v17);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)v17, v18);
            unint64_t v19 = *a3 + 4;
            *a3 = v19;
            unint64_t v17 = ", ";
          }
          while (v19 < v16);
        }
      }
      else
      {
        size_t v13 = v10 + 1;
        unint64_t v14 = "";
        do
        {
          size_t v15 = strlen(v14);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)v14, v15);
          unint64_t v14 = ", ";
          --v12;
        }
        while (v12);
      }
    }
    return (MIL::IRDimension **)std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)"]", 1);
  }
  return result;
}

void *anonymous namespace'::ScalarToString<double>(uint64_t a1, void *a2, uint64_t a3)
{
  int v4 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 80))(a3, 6);
  if (v4 == 1)
  {
    *(_DWORD *)((char *)a2 + *(void *)(*a2 - 24) + 8) |= 0x104u;
    unint64_t result = (void *)std::ostream::operator<<();
    *(_DWORD *)((char *)result + *(void *)(*result - 24) + 8) = *(_DWORD *)((unsigned char *)result
                                                                              + *(void *)(*result - 24)
                                                                              + 8) & 0xFFFFFEFB | 4;
  }
  else
  {
    if (v4)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Unexpected float serialization mode.");
      __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
    }
    *(void *)((char *)a2 + *(void *)(*a2 - 24) + 16) = 17;
    return (void *)std::ostream::operator<<();
  }
  return result;
}

void sub_20F46F464(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

MIL::IRDimension **anonymous namespace'::SerializeImmediateTensorDim<double,MIL::Util::Span<double const,18446744073709551615ul>>(MIL::IRDimension **result, MIL::IRDimension **a2, uint64_t *a3, void *a4, uint64_t a5)
{
  if (result != a2)
  {
    uint64_t v10 = result;
    uint64_t v11 = MIL::IRDimension::AsConstant(*result);
    uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 48))(v11);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)"[", 1);
    if (v12)
    {
      if (a2 - 1 == v10)
      {
        if (v12 >= 1)
        {
          unint64_t v16 = *a3 + 8 * v12;
          unint64_t v17 = "";
          do
          {
            size_t v18 = strlen(v17);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)v17, v18);
            unint64_t v19 = *a3 + 8;
            *a3 = v19;
            unint64_t v17 = ", ";
          }
          while (v19 < v16);
        }
      }
      else
      {
        size_t v13 = v10 + 1;
        unint64_t v14 = "";
        do
        {
          size_t v15 = strlen(v14);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)v14, v15);
          unint64_t v14 = ", ";
          --v12;
        }
        while (v12);
      }
    }
    return (MIL::IRDimension **)std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)"]", 1);
  }
  return result;
}

void ValHelperForSubByteTypes<MIL::Int4>(uint64_t a1, void *a2)
{
  uint64_t Type = MIL::IRTypedTensorValue<MIL::Int4>::GetType(a1);
  uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)Type + 96))(Type);
  char v35 = 0;
  uint64_t v36 = 0;
  v34 = 0;
  std::vector<MIL::IRDimension const*>::__init_with_size[abi:ne180100]<MIL::IRDimension const**,MIL::IRDimension const**>(&v34, *(const void **)v5, *(void *)(v5 + 8), (uint64_t)(*(void *)(v5 + 8) - *(void *)v5) >> 3);
  if (v34 == v35)
  {
    LOBYTE(v32) = MIL::IRTypedTensorValue<MIL::Int4>::GetScalarValue(a1);
    MIL::Int4::GetInt((MIL::Int4 *)&v32);
    std::ostream::operator<<();
  }
  MIL::IRTypedTensorValue<MIL::Int4>::GetValues(a1);
  size_t v8 = ((v7 >> 1) & 0x1FFFFFFFFFFFFFFFLL) + (v7 & 1);
  if (v8) {
    uint64_t v9 = v6;
  }
  else {
    uint64_t v9 = 0;
  }
  std::string __p = 0;
  v30 = 0;
  v31 = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(&__p, v9, (uint64_t)v9 + v8, v8);
  uint64_t v10 = MIL::IRTypedTensorValue<MIL::Int4>::GetType(a1);
  uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 16))(v10);
  MIL::UnPackSubByteVec<MIL::Int4>(&v32, &__p, v11);
  if (__p)
  {
    v30 = __p;
    operator delete(__p);
  }
  std::string __p = 0;
  v30 = 0;
  v31 = 0;
  uint64_t v12 = (char *)v32;
  size_t v13 = v33;
  if (v32 == v33)
  {
    unint64_t v14 = 0;
    v26 = 0;
  }
  else
  {
    unint64_t v14 = 0;
    do
    {
      if (v14 >= v31)
      {
        unint64_t v15 = (unint64_t)__p;
        uint64_t v16 = v14 - (unsigned char *)__p;
        uint64_t v17 = v14 - (unsigned char *)__p + 1;
        if (v17 < 0) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v18 = v31 - (unsigned char *)__p;
        if (2 * (v31 - (unsigned char *)__p) > (unint64_t)v17) {
          uint64_t v17 = 2 * v18;
        }
        if (v18 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v19 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v19 = v17;
        }
        if (v19) {
          char v20 = (char *)operator new(v19);
        }
        else {
          char v20 = 0;
        }
        unint64_t v21 = &v20[v16];
        int v22 = &v20[v16];
        *int v22 = *v12;
        uint64_t v23 = v22 + 1;
        if (v14 != (char *)v15)
        {
          unint64_t v24 = &v14[~v15];
          do
          {
            char v25 = *--v14;
            (v24--)[(void)v20] = v25;
          }
          while (v14 != (char *)v15);
          unint64_t v14 = (char *)__p;
          unint64_t v21 = v20;
        }
        std::string __p = v21;
        v30 = v23;
        v31 = &v20[v19];
        if (v14) {
          operator delete(v14);
        }
        unint64_t v14 = v23;
      }
      else
      {
        *v14++ = *v12;
      }
      v30 = v14;
      ++v12;
    }
    while (v12 != v13);
    v26 = (char *)__p;
  }
  if (v14 == v26) {
    unint64_t v27 = 0;
  }
  else {
    unint64_t v27 = (unint64_t)v26;
  }
  unint64_t v28 = v27;
  if (v26) {
    operator delete(v26);
  }
  if (v32)
  {
    v33 = (char *)v32;
    operator delete(v32);
  }
  if (v34)
  {
    char v35 = (MIL::IRDimension **)v34;
    operator delete(v34);
  }
}

void sub_20F46F868(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  if (v17) {
    operator delete(v17);
  }
  if (__p) {
    operator delete(__p);
  }
  if (a16) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

MIL::IRDimension **anonymous namespace'::SerializeImmediateTensorDim<signed char,MIL::Util::Span<signed char const,18446744073709551615ul>>(MIL::IRDimension **result, MIL::IRDimension **a2, unint64_t *a3, void *a4)
{
  if (result != a2)
  {
    size_t v8 = result;
    uint64_t v9 = MIL::IRDimension::AsConstant(*result);
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 48))(v9);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)"[", 1);
    if (v10)
    {
      if (a2 - 1 == v8)
      {
        if (v10 >= 1)
        {
          unint64_t v14 = *a3 + v10;
          unint64_t v15 = "";
          do
          {
            size_t v16 = strlen(v15);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)v15, v16);
            std::ostream::operator<<();
            unint64_t v17 = *a3 + 1;
            *a3 = v17;
            unint64_t v15 = ", ";
          }
          while (v17 < v14);
        }
      }
      else
      {
        uint64_t v11 = v8 + 1;
        uint64_t v12 = "";
        do
        {
          size_t v13 = strlen(v12);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)v12, v13);
          uint64_t v12 = ", ";
          --v10;
        }
        while (v10);
      }
    }
    return (MIL::IRDimension **)std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)"]", 1);
  }
  return result;
}

MIL::IRDimension **anonymous namespace'::SerializeImmediateTensorDim<short,MIL::Util::Span<short const,18446744073709551615ul>>(MIL::IRDimension **result, MIL::IRDimension **a2, unint64_t *a3, void *a4)
{
  if (result != a2)
  {
    size_t v8 = result;
    uint64_t v9 = MIL::IRDimension::AsConstant(*result);
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 48))(v9);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)"[", 1);
    if (v10)
    {
      if (a2 - 1 == v8)
      {
        if (v10 >= 1)
        {
          unint64_t v14 = *a3 + 2 * v10;
          unint64_t v15 = "";
          do
          {
            size_t v16 = strlen(v15);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)v15, v16);
            std::ostream::operator<<();
            unint64_t v17 = *a3 + 2;
            *a3 = v17;
            unint64_t v15 = ", ";
          }
          while (v17 < v14);
        }
      }
      else
      {
        uint64_t v11 = v8 + 1;
        uint64_t v12 = "";
        do
        {
          size_t v13 = strlen(v12);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)v12, v13);
          uint64_t v12 = ", ";
          --v10;
        }
        while (v10);
      }
    }
    return (MIL::IRDimension **)std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)"]", 1);
  }
  return result;
}

MIL::IRDimension **anonymous namespace'::SerializeImmediateTensorDim<int,MIL::Util::Span<int const,18446744073709551615ul>>(MIL::IRDimension **result, MIL::IRDimension **a2, unint64_t *a3, void *a4)
{
  if (result != a2)
  {
    size_t v8 = result;
    uint64_t v9 = MIL::IRDimension::AsConstant(*result);
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 48))(v9);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)"[", 1);
    if (v10)
    {
      if (a2 - 1 == v8)
      {
        if (v10 >= 1)
        {
          unint64_t v14 = *a3 + 4 * v10;
          unint64_t v15 = "";
          do
          {
            size_t v16 = strlen(v15);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)v15, v16);
            std::ostream::operator<<();
            unint64_t v17 = *a3 + 4;
            *a3 = v17;
            unint64_t v15 = ", ";
          }
          while (v17 < v14);
        }
      }
      else
      {
        uint64_t v11 = v8 + 1;
        uint64_t v12 = "";
        do
        {
          size_t v13 = strlen(v12);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)v12, v13);
          uint64_t v12 = ", ";
          --v10;
        }
        while (v10);
      }
    }
    return (MIL::IRDimension **)std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)"]", 1);
  }
  return result;
}

MIL::IRDimension **anonymous namespace'::SerializeImmediateTensorDim<long long,MIL::Util::Span<long long const,18446744073709551615ul>>(MIL::IRDimension **result, MIL::IRDimension **a2, unint64_t *a3, void *a4)
{
  if (result != a2)
  {
    size_t v8 = result;
    uint64_t v9 = MIL::IRDimension::AsConstant(*result);
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 48))(v9);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)"[", 1);
    if (v10)
    {
      if (a2 - 1 == v8)
      {
        if (v10 >= 1)
        {
          unint64_t v14 = *a3 + 8 * v10;
          unint64_t v15 = "";
          do
          {
            size_t v16 = strlen(v15);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)v15, v16);
            std::ostream::operator<<();
            unint64_t v17 = *a3 + 8;
            *a3 = v17;
            unint64_t v15 = ", ";
          }
          while (v17 < v14);
        }
      }
      else
      {
        uint64_t v11 = v8 + 1;
        uint64_t v12 = "";
        do
        {
          size_t v13 = strlen(v12);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)v12, v13);
          uint64_t v12 = ", ";
          --v10;
        }
        while (v10);
      }
    }
    return (MIL::IRDimension **)std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)"]", 1);
  }
  return result;
}

void ValHelperForSubByteTypes<MIL::UInt1>(uint64_t a1, void *a2)
{
  uint64_t Type = MIL::IRTypedTensorValue<MIL::UInt1>::GetType(a1);
  uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)Type + 96))(Type);
  char v35 = 0;
  uint64_t v36 = 0;
  v34 = 0;
  std::vector<MIL::IRDimension const*>::__init_with_size[abi:ne180100]<MIL::IRDimension const**,MIL::IRDimension const**>(&v34, *(const void **)v5, *(void *)(v5 + 8), (uint64_t)(*(void *)(v5 + 8) - *(void *)v5) >> 3);
  if (v34 == v35)
  {
    LOBYTE(v32) = MIL::IRTypedTensorValue<MIL::UInt1>::GetScalarValue(a1);
    MIL::UInt1::GetInt((MIL::UInt1 *)&v32);
    std::ostream::operator<<();
  }
  MIL::IRTypedTensorValue<MIL::UInt1>::GetValues(a1);
  if ((v7 & 7) != 0) {
    size_t v8 = (v7 >> 3) + 1;
  }
  else {
    size_t v8 = v7 >> 3;
  }
  if (v8) {
    uint64_t v9 = v6;
  }
  else {
    uint64_t v9 = 0;
  }
  std::string __p = 0;
  v30 = 0;
  v31 = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(&__p, v9, (uint64_t)v9 + v8, v8);
  uint64_t v10 = MIL::IRTypedTensorValue<MIL::UInt1>::GetType(a1);
  uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 16))(v10);
  MIL::UnPackSubByteVec<MIL::UInt1>(&v32, &__p, v11);
  if (__p)
  {
    v30 = __p;
    operator delete(__p);
  }
  std::string __p = 0;
  v30 = 0;
  v31 = 0;
  uint64_t v12 = (char *)v32;
  size_t v13 = v33;
  if (v32 == v33)
  {
    unint64_t v14 = 0;
    v26 = 0;
  }
  else
  {
    unint64_t v14 = 0;
    do
    {
      if (v14 >= v31)
      {
        unint64_t v15 = (unint64_t)__p;
        uint64_t v16 = v14 - (unsigned char *)__p;
        uint64_t v17 = v14 - (unsigned char *)__p + 1;
        if (v17 < 0) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v18 = v31 - (unsigned char *)__p;
        if (2 * (v31 - (unsigned char *)__p) > (unint64_t)v17) {
          uint64_t v17 = 2 * v18;
        }
        if (v18 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v19 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v19 = v17;
        }
        if (v19) {
          char v20 = (char *)operator new(v19);
        }
        else {
          char v20 = 0;
        }
        unint64_t v21 = &v20[v16];
        int v22 = &v20[v16];
        *int v22 = *v12;
        uint64_t v23 = v22 + 1;
        if (v14 != (char *)v15)
        {
          unint64_t v24 = &v14[~v15];
          do
          {
            char v25 = *--v14;
            (v24--)[(void)v20] = v25;
          }
          while (v14 != (char *)v15);
          unint64_t v14 = (char *)__p;
          unint64_t v21 = v20;
        }
        std::string __p = v21;
        v30 = v23;
        v31 = &v20[v19];
        if (v14) {
          operator delete(v14);
        }
        unint64_t v14 = v23;
      }
      else
      {
        *v14++ = *v12;
      }
      v30 = v14;
      ++v12;
    }
    while (v12 != v13);
    v26 = (char *)__p;
  }
  if (v14 == v26) {
    unint64_t v27 = 0;
  }
  else {
    unint64_t v27 = (unint64_t)v26;
  }
  unint64_t v28 = v27;
  if (v26) {
    operator delete(v26);
  }
  if (v32)
  {
    v33 = (char *)v32;
    operator delete(v32);
  }
  if (v34)
  {
    char v35 = (MIL::IRDimension **)v34;
    operator delete(v34);
  }
}

void sub_20F470120(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  if (v17) {
    operator delete(v17);
  }
  if (__p) {
    operator delete(__p);
  }
  if (a16) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

MIL::IRDimension **anonymous namespace'::SerializeImmediateTensorDim<unsigned char,MIL::Util::Span<unsigned char const,18446744073709551615ul>>(MIL::IRDimension **result, MIL::IRDimension **a2, unint64_t *a3, void *a4)
{
  if (result != a2)
  {
    size_t v8 = result;
    uint64_t v9 = MIL::IRDimension::AsConstant(*result);
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 48))(v9);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)"[", 1);
    if (v10)
    {
      if (a2 - 1 == v8)
      {
        if (v10 >= 1)
        {
          unint64_t v14 = *a3 + v10;
          unint64_t v15 = "";
          do
          {
            size_t v16 = strlen(v15);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)v15, v16);
            std::ostream::operator<<();
            unint64_t v17 = *a3 + 1;
            *a3 = v17;
            unint64_t v15 = ", ";
          }
          while (v17 < v14);
        }
      }
      else
      {
        uint64_t v11 = v8 + 1;
        uint64_t v12 = "";
        do
        {
          size_t v13 = strlen(v12);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)v12, v13);
          uint64_t v12 = ", ";
          --v10;
        }
        while (v10);
      }
    }
    return (MIL::IRDimension **)std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)"]", 1);
  }
  return result;
}

void ValHelperForSubByteTypes<MIL::UInt2>(uint64_t a1, void *a2)
{
  uint64_t Type = MIL::IRTypedTensorValue<MIL::UInt2>::GetType(a1);
  uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)Type + 96))(Type);
  char v35 = 0;
  uint64_t v36 = 0;
  v34 = 0;
  std::vector<MIL::IRDimension const*>::__init_with_size[abi:ne180100]<MIL::IRDimension const**,MIL::IRDimension const**>(&v34, *(const void **)v5, *(void *)(v5 + 8), (uint64_t)(*(void *)(v5 + 8) - *(void *)v5) >> 3);
  if (v34 == v35)
  {
    LOBYTE(v32) = MIL::IRTypedTensorValue<MIL::UInt2>::GetScalarValue(a1);
    MIL::UInt2::GetInt((MIL::UInt2 *)&v32);
    std::ostream::operator<<();
  }
  MIL::IRTypedTensorValue<MIL::UInt2>::GetValues(a1);
  if ((v7 & 3) != 0) {
    size_t v8 = ((v7 >> 2) & 0x1FFFFFFFFFFFFFFFLL) + 1;
  }
  else {
    size_t v8 = (v7 >> 2) & 0x1FFFFFFFFFFFFFFFLL;
  }
  if (v8) {
    uint64_t v9 = v6;
  }
  else {
    uint64_t v9 = 0;
  }
  std::string __p = 0;
  v30 = 0;
  v31 = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(&__p, v9, (uint64_t)v9 + v8, v8);
  uint64_t v10 = MIL::IRTypedTensorValue<MIL::UInt2>::GetType(a1);
  uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 16))(v10);
  MIL::UnPackSubByteVec<MIL::UInt2>(&v32, &__p, v11);
  if (__p)
  {
    v30 = __p;
    operator delete(__p);
  }
  std::string __p = 0;
  v30 = 0;
  v31 = 0;
  uint64_t v12 = (char *)v32;
  size_t v13 = v33;
  if (v32 == v33)
  {
    unint64_t v14 = 0;
    v26 = 0;
  }
  else
  {
    unint64_t v14 = 0;
    do
    {
      if (v14 >= v31)
      {
        unint64_t v15 = (unint64_t)__p;
        uint64_t v16 = v14 - (unsigned char *)__p;
        uint64_t v17 = v14 - (unsigned char *)__p + 1;
        if (v17 < 0) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v18 = v31 - (unsigned char *)__p;
        if (2 * (v31 - (unsigned char *)__p) > (unint64_t)v17) {
          uint64_t v17 = 2 * v18;
        }
        if (v18 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v19 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v19 = v17;
        }
        if (v19) {
          char v20 = (char *)operator new(v19);
        }
        else {
          char v20 = 0;
        }
        unint64_t v21 = &v20[v16];
        int v22 = &v20[v16];
        *int v22 = *v12;
        uint64_t v23 = v22 + 1;
        if (v14 != (char *)v15)
        {
          unint64_t v24 = &v14[~v15];
          do
          {
            char v25 = *--v14;
            (v24--)[(void)v20] = v25;
          }
          while (v14 != (char *)v15);
          unint64_t v14 = (char *)__p;
          unint64_t v21 = v20;
        }
        std::string __p = v21;
        v30 = v23;
        v31 = &v20[v19];
        if (v14) {
          operator delete(v14);
        }
        unint64_t v14 = v23;
      }
      else
      {
        *v14++ = *v12;
      }
      v30 = v14;
      ++v12;
    }
    while (v12 != v13);
    v26 = (char *)__p;
  }
  if (v14 == v26) {
    unint64_t v27 = 0;
  }
  else {
    unint64_t v27 = (unint64_t)v26;
  }
  unint64_t v28 = v27;
  if (v26) {
    operator delete(v26);
  }
  if (v32)
  {
    v33 = (char *)v32;
    operator delete(v32);
  }
  if (v34)
  {
    char v35 = (MIL::IRDimension **)v34;
    operator delete(v34);
  }
}

void sub_20F47057C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  if (v17) {
    operator delete(v17);
  }
  if (__p) {
    operator delete(__p);
  }
  if (a16) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void ValHelperForSubByteTypes<MIL::UInt3>(uint64_t a1, void *a2)
{
  uint64_t Type = MIL::IRTypedTensorValue<MIL::UInt3>::GetType(a1);
  uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)Type + 96))(Type);
  char v35 = 0;
  uint64_t v36 = 0;
  v34 = 0;
  std::vector<MIL::IRDimension const*>::__init_with_size[abi:ne180100]<MIL::IRDimension const**,MIL::IRDimension const**>(&v34, *(const void **)v5, *(void *)(v5 + 8), (uint64_t)(*(void *)(v5 + 8) - *(void *)v5) >> 3);
  if (v34 == v35)
  {
    LOBYTE(v32) = MIL::IRTypedTensorValue<MIL::UInt3>::GetScalarValue(a1);
    MIL::UInt3::GetInt((MIL::UInt3 *)&v32);
    std::ostream::operator<<();
  }
  MIL::IRTypedTensorValue<MIL::UInt3>::GetValues(a1);
  if (((3 * v7) & 7) != 0) {
    size_t v8 = ((unint64_t)(3 * v7) >> 3) + 1;
  }
  else {
    size_t v8 = (unint64_t)(3 * v7) >> 3;
  }
  if (v8) {
    uint64_t v9 = v6;
  }
  else {
    uint64_t v9 = 0;
  }
  std::string __p = 0;
  v30 = 0;
  v31 = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(&__p, v9, (uint64_t)v9 + v8, v8);
  uint64_t v10 = MIL::IRTypedTensorValue<MIL::UInt3>::GetType(a1);
  uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 16))(v10);
  MIL::UnPackSubByteVec<MIL::UInt3>(&v32, &__p, v11);
  if (__p)
  {
    v30 = __p;
    operator delete(__p);
  }
  std::string __p = 0;
  v30 = 0;
  v31 = 0;
  uint64_t v12 = (char *)v32;
  size_t v13 = v33;
  if (v32 == v33)
  {
    unint64_t v14 = 0;
    v26 = 0;
  }
  else
  {
    unint64_t v14 = 0;
    do
    {
      if (v14 >= v31)
      {
        unint64_t v15 = (unint64_t)__p;
        uint64_t v16 = v14 - (unsigned char *)__p;
        uint64_t v17 = v14 - (unsigned char *)__p + 1;
        if (v17 < 0) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v18 = v31 - (unsigned char *)__p;
        if (2 * (v31 - (unsigned char *)__p) > (unint64_t)v17) {
          uint64_t v17 = 2 * v18;
        }
        if (v18 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v19 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v19 = v17;
        }
        if (v19) {
          char v20 = (char *)operator new(v19);
        }
        else {
          char v20 = 0;
        }
        unint64_t v21 = &v20[v16];
        int v22 = &v20[v16];
        *int v22 = *v12;
        uint64_t v23 = v22 + 1;
        if (v14 != (char *)v15)
        {
          unint64_t v24 = &v14[~v15];
          do
          {
            char v25 = *--v14;
            (v24--)[(void)v20] = v25;
          }
          while (v14 != (char *)v15);
          unint64_t v14 = (char *)__p;
          unint64_t v21 = v20;
        }
        std::string __p = v21;
        v30 = v23;
        v31 = &v20[v19];
        if (v14) {
          operator delete(v14);
        }
        unint64_t v14 = v23;
      }
      else
      {
        *v14++ = *v12;
      }
      v30 = v14;
      ++v12;
    }
    while (v12 != v13);
    v26 = (char *)__p;
  }
  if (v14 == v26) {
    unint64_t v27 = 0;
  }
  else {
    unint64_t v27 = (unint64_t)v26;
  }
  unint64_t v28 = v27;
  if (v26) {
    operator delete(v26);
  }
  if (v32)
  {
    v33 = (char *)v32;
    operator delete(v32);
  }
  if (v34)
  {
    char v35 = (MIL::IRDimension **)v34;
    operator delete(v34);
  }
}

void sub_20F470868(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  if (v17) {
    operator delete(v17);
  }
  if (__p) {
    operator delete(__p);
  }
  if (a16) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void ValHelperForSubByteTypes<MIL::UInt4>(uint64_t a1, void *a2)
{
  uint64_t Type = MIL::IRTypedTensorValue<MIL::UInt4>::GetType(a1);
  uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)Type + 96))(Type);
  char v35 = 0;
  uint64_t v36 = 0;
  v34 = 0;
  std::vector<MIL::IRDimension const*>::__init_with_size[abi:ne180100]<MIL::IRDimension const**,MIL::IRDimension const**>(&v34, *(const void **)v5, *(void *)(v5 + 8), (uint64_t)(*(void *)(v5 + 8) - *(void *)v5) >> 3);
  if (v34 == v35)
  {
    LOBYTE(v32) = MIL::IRTypedTensorValue<MIL::UInt4>::GetScalarValue(a1);
    MIL::UInt4::GetInt((MIL::UInt4 *)&v32);
    std::ostream::operator<<();
  }
  MIL::IRTypedTensorValue<MIL::UInt4>::GetValues(a1);
  size_t v8 = ((v7 >> 1) & 0x1FFFFFFFFFFFFFFFLL) + (v7 & 1);
  if (v8) {
    uint64_t v9 = v6;
  }
  else {
    uint64_t v9 = 0;
  }
  std::string __p = 0;
  v30 = 0;
  v31 = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(&__p, v9, (uint64_t)v9 + v8, v8);
  uint64_t v10 = MIL::IRTypedTensorValue<MIL::UInt4>::GetType(a1);
  uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 16))(v10);
  MIL::UnPackSubByteVec<MIL::UInt4>(&v32, &__p, v11);
  if (__p)
  {
    v30 = __p;
    operator delete(__p);
  }
  std::string __p = 0;
  v30 = 0;
  v31 = 0;
  uint64_t v12 = (char *)v32;
  size_t v13 = v33;
  if (v32 == v33)
  {
    unint64_t v14 = 0;
    v26 = 0;
  }
  else
  {
    unint64_t v14 = 0;
    do
    {
      if (v14 >= v31)
      {
        unint64_t v15 = (unint64_t)__p;
        uint64_t v16 = v14 - (unsigned char *)__p;
        uint64_t v17 = v14 - (unsigned char *)__p + 1;
        if (v17 < 0) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v18 = v31 - (unsigned char *)__p;
        if (2 * (v31 - (unsigned char *)__p) > (unint64_t)v17) {
          uint64_t v17 = 2 * v18;
        }
        if (v18 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v19 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v19 = v17;
        }
        if (v19) {
          char v20 = (char *)operator new(v19);
        }
        else {
          char v20 = 0;
        }
        unint64_t v21 = &v20[v16];
        int v22 = &v20[v16];
        *int v22 = *v12;
        uint64_t v23 = v22 + 1;
        if (v14 != (char *)v15)
        {
          unint64_t v24 = &v14[~v15];
          do
          {
            char v25 = *--v14;
            (v24--)[(void)v20] = v25;
          }
          while (v14 != (char *)v15);
          unint64_t v14 = (char *)__p;
          unint64_t v21 = v20;
        }
        std::string __p = v21;
        v30 = v23;
        v31 = &v20[v19];
        if (v14) {
          operator delete(v14);
        }
        unint64_t v14 = v23;
      }
      else
      {
        *v14++ = *v12;
      }
      v30 = v14;
      ++v12;
    }
    while (v12 != v13);
    v26 = (char *)__p;
  }
  if (v14 == v26) {
    unint64_t v27 = 0;
  }
  else {
    unint64_t v27 = (unint64_t)v26;
  }
  unint64_t v28 = v27;
  if (v26) {
    operator delete(v26);
  }
  if (v32)
  {
    v33 = (char *)v32;
    operator delete(v32);
  }
  if (v34)
  {
    char v35 = (MIL::IRDimension **)v34;
    operator delete(v34);
  }
}

void sub_20F470B4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  if (v17) {
    operator delete(v17);
  }
  if (__p) {
    operator delete(__p);
  }
  if (a16) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void ValHelperForSubByteTypes<MIL::UInt6>(uint64_t a1, void *a2)
{
  uint64_t Type = MIL::IRTypedTensorValue<MIL::UInt6>::GetType(a1);
  uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)Type + 96))(Type);
  char v35 = 0;
  uint64_t v36 = 0;
  v34 = 0;
  std::vector<MIL::IRDimension const*>::__init_with_size[abi:ne180100]<MIL::IRDimension const**,MIL::IRDimension const**>(&v34, *(const void **)v5, *(void *)(v5 + 8), (uint64_t)(*(void *)(v5 + 8) - *(void *)v5) >> 3);
  if (v34 == v35)
  {
    LOBYTE(v32) = MIL::IRTypedTensorValue<MIL::UInt6>::GetScalarValue(a1);
    MIL::UInt6::GetInt((MIL::UInt6 *)&v32);
    std::ostream::operator<<();
  }
  MIL::IRTypedTensorValue<MIL::UInt6>::GetValues(a1);
  if (((6 * v7) & 6) != 0) {
    size_t v8 = (((unint64_t)(3 * v7) >> 2) & 0x1FFFFFFFFFFFFFFFLL) + 1;
  }
  else {
    size_t v8 = ((unint64_t)(3 * v7) >> 2) & 0x1FFFFFFFFFFFFFFFLL;
  }
  if (v8) {
    uint64_t v9 = v6;
  }
  else {
    uint64_t v9 = 0;
  }
  std::string __p = 0;
  v30 = 0;
  v31 = 0;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(&__p, v9, (uint64_t)v9 + v8, v8);
  uint64_t v10 = MIL::IRTypedTensorValue<MIL::UInt6>::GetType(a1);
  uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 16))(v10);
  MIL::UnPackSubByteVec<MIL::UInt6>(&v32, &__p, v11);
  if (__p)
  {
    v30 = __p;
    operator delete(__p);
  }
  std::string __p = 0;
  v30 = 0;
  v31 = 0;
  uint64_t v12 = (char *)v32;
  size_t v13 = v33;
  if (v32 == v33)
  {
    unint64_t v14 = 0;
    v26 = 0;
  }
  else
  {
    unint64_t v14 = 0;
    do
    {
      if (v14 >= v31)
      {
        unint64_t v15 = (unint64_t)__p;
        uint64_t v16 = v14 - (unsigned char *)__p;
        uint64_t v17 = v14 - (unsigned char *)__p + 1;
        if (v17 < 0) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v18 = v31 - (unsigned char *)__p;
        if (2 * (v31 - (unsigned char *)__p) > (unint64_t)v17) {
          uint64_t v17 = 2 * v18;
        }
        if (v18 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v19 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v19 = v17;
        }
        if (v19) {
          char v20 = (char *)operator new(v19);
        }
        else {
          char v20 = 0;
        }
        unint64_t v21 = &v20[v16];
        int v22 = &v20[v16];
        *int v22 = *v12;
        uint64_t v23 = v22 + 1;
        if (v14 != (char *)v15)
        {
          unint64_t v24 = &v14[~v15];
          do
          {
            char v25 = *--v14;
            (v24--)[(void)v20] = v25;
          }
          while (v14 != (char *)v15);
          unint64_t v14 = (char *)__p;
          unint64_t v21 = v20;
        }
        std::string __p = v21;
        v30 = v23;
        v31 = &v20[v19];
        if (v14) {
          operator delete(v14);
        }
        unint64_t v14 = v23;
      }
      else
      {
        *v14++ = *v12;
      }
      v30 = v14;
      ++v12;
    }
    while (v12 != v13);
    v26 = (char *)__p;
  }
  if (v14 == v26) {
    unint64_t v27 = 0;
  }
  else {
    unint64_t v27 = (unint64_t)v26;
  }
  unint64_t v28 = v27;
  if (v26) {
    operator delete(v26);
  }
  if (v32)
  {
    v33 = (char *)v32;
    operator delete(v32);
  }
  if (v34)
  {
    char v35 = (MIL::IRDimension **)v34;
    operator delete(v34);
  }
}

void sub_20F470E3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  if (v17) {
    operator delete(v17);
  }
  if (__p) {
    operator delete(__p);
  }
  if (a16) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

MIL::IRDimension **anonymous namespace'::SerializeImmediateTensorDim<unsigned short,MIL::Util::Span<unsigned short const,18446744073709551615ul>>(MIL::IRDimension **result, MIL::IRDimension **a2, unint64_t *a3, void *a4)
{
  if (result != a2)
  {
    size_t v8 = result;
    uint64_t v9 = MIL::IRDimension::AsConstant(*result);
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 48))(v9);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)"[", 1);
    if (v10)
    {
      if (a2 - 1 == v8)
      {
        if (v10 >= 1)
        {
          unint64_t v14 = *a3 + 2 * v10;
          unint64_t v15 = "";
          do
          {
            size_t v16 = strlen(v15);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)v15, v16);
            std::ostream::operator<<();
            unint64_t v17 = *a3 + 2;
            *a3 = v17;
            unint64_t v15 = ", ";
          }
          while (v17 < v14);
        }
      }
      else
      {
        uint64_t v11 = v8 + 1;
        uint64_t v12 = "";
        do
        {
          size_t v13 = strlen(v12);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)v12, v13);
          uint64_t v12 = ", ";
          --v10;
        }
        while (v10);
      }
    }
    return (MIL::IRDimension **)std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)"]", 1);
  }
  return result;
}

MIL::IRDimension **anonymous namespace'::SerializeImmediateTensorDim<unsigned int,MIL::Util::Span<unsigned int const,18446744073709551615ul>>(MIL::IRDimension **result, MIL::IRDimension **a2, unint64_t *a3, void *a4)
{
  if (result != a2)
  {
    size_t v8 = result;
    uint64_t v9 = MIL::IRDimension::AsConstant(*result);
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 48))(v9);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)"[", 1);
    if (v10)
    {
      if (a2 - 1 == v8)
      {
        if (v10 >= 1)
        {
          unint64_t v14 = *a3 + 4 * v10;
          unint64_t v15 = "";
          do
          {
            size_t v16 = strlen(v15);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)v15, v16);
            std::ostream::operator<<();
            unint64_t v17 = *a3 + 4;
            *a3 = v17;
            unint64_t v15 = ", ";
          }
          while (v17 < v14);
        }
      }
      else
      {
        uint64_t v11 = v8 + 1;
        uint64_t v12 = "";
        do
        {
          size_t v13 = strlen(v12);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)v12, v13);
          uint64_t v12 = ", ";
          --v10;
        }
        while (v10);
      }
    }
    return (MIL::IRDimension **)std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)"]", 1);
  }
  return result;
}

MIL::IRDimension **anonymous namespace'::SerializeImmediateTensorDim<unsigned long long,MIL::Util::Span<unsigned long long const,18446744073709551615ul>>(MIL::IRDimension **result, MIL::IRDimension **a2, unint64_t *a3, void *a4)
{
  if (result != a2)
  {
    size_t v8 = result;
    uint64_t v9 = MIL::IRDimension::AsConstant(*result);
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 48))(v9);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)"[", 1);
    if (v10)
    {
      if (a2 - 1 == v8)
      {
        if (v10 >= 1)
        {
          unint64_t v14 = *a3 + 8 * v10;
          unint64_t v15 = "";
          do
          {
            size_t v16 = strlen(v15);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)v15, v16);
            std::ostream::operator<<();
            unint64_t v17 = *a3 + 8;
            *a3 = v17;
            unint64_t v15 = ", ";
          }
          while (v17 < v14);
        }
      }
      else
      {
        uint64_t v11 = v8 + 1;
        uint64_t v12 = "";
        do
        {
          size_t v13 = strlen(v12);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)v12, v13);
          uint64_t v12 = ", ";
          --v10;
        }
        while (v10);
      }
    }
    return (MIL::IRDimension **)std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a4, (uint64_t)"]", 1);
  }
  return result;
}

MIL::Text::BasicSerializer *MIL::Text::BasicSerializer::PropertyItem<long long>(MIL::Text::BasicSerializer *a1, MIL::IRProperty *this)
{
  uint64_t v4 = (MIL::IRConstantProperty *)MIL::IRProperty::TryAsConstant(this);
  if (v4)
  {
    MIL::IRConstantProperty::GetInt64ScalarValue(v4);
    std::ostream::operator<<();
  }
  else
  {
    uint64_t v5 = (const MIL::IRUnknownProperty *)MIL::IRProperty::TryAsUnknown(this);
    if (!v5)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Property type is not supported by the serializer.");
      __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
    }
    MIL::Text::BasicSerializer::PropertyItem(a1, v5);
  }
  return a1;
}

void sub_20F4713A4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

MIL::Text::BasicSerializer *MIL::Text::BasicSerializer::PropertyItem<unsigned char>(MIL::Text::BasicSerializer *a1, MIL::IRProperty *this)
{
  uint64_t v4 = (MIL::IRConstantProperty *)MIL::IRProperty::TryAsConstant(this);
  if (v4)
  {
    MIL::IRConstantProperty::GetUInt8ScalarValue(v4);
    std::ostream::operator<<();
  }
  else
  {
    uint64_t v5 = (const MIL::IRUnknownProperty *)MIL::IRProperty::TryAsUnknown(this);
    if (!v5)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Property type is not supported by the serializer.");
      __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
    }
    MIL::Text::BasicSerializer::PropertyItem(a1, v5);
  }
  return a1;
}

void sub_20F471454(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t std::regex_match[abi:ne180100]<std::__wrap_iter<char const*>,std::allocator<std::sub_match<std::__wrap_iter<char const*>>>,char,std::regex_traits<char>>(char *__f, char *__l, uint64_t a3, uint64_t a4, int a5)
{
  __int16 v5 = a5;
  memset(&__p.__prefix_, 0, 17);
  memset(&__p.__suffix_, 0, 17);
  __p.__ready_ = 0;
  __p.__position_start_ = 0;
  memset(&__p, 0, 41);
  int v9 = std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>(a4, __f, __l, &__p, a5 | 0x1040u);
  std::match_results<std::__wrap_iter<char const*>>::__assign[abi:ne180100]<char const*,std::allocator<std::sub_match<char const*>>>((std::vector<std::ssub_match> *)a3, (uint64_t)__f, (std::sub_match<std::__wrap_iter<const char *>> *)__l, (uint64_t *)&__p, (v5 & 0x800) != 0);
  if (__p.__matches_.__begin_)
  {
    __p.__matches_.__end_ = __p.__matches_.__begin_;
    operator delete(__p.__matches_.__begin_);
  }
  if (!v9) {
    return 0;
  }
  if (!*(unsigned char *)(a3 + 88)) {
    return 1;
  }
  uint64_t result = 0;
  *(void *)(a3 + 8) = *(void *)a3;
  return result;
}

void sub_20F4715BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::match_results<std::__wrap_iter<char const*>>::__assign[abi:ne180100]<char const*,std::allocator<std::sub_match<char const*>>>(std::vector<std::ssub_match> *a1, uint64_t a2, std::sub_match<std::__wrap_iter<const char *>> *a3, uint64_t *a4, char a5)
{
  uint64_t v10 = a4[6];
  std::vector<std::sub_match<std::__wrap_iter<char const*>>>::resize(a1, 0xAAAAAAAAAAAAAAABLL * ((a4[1] - *a4) >> 3));
  std::vector<std::ssub_match>::pointer begin = a1->__begin_;
  if (a1->__end_ != a1->__begin_)
  {
    unint64_t v12 = 0;
    unint64_t v13 = 0;
    uint64_t v15 = *a4;
    uint64_t v14 = a4[1];
    do
    {
      unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v14 - v15) >> 3);
      unint64_t v17 = (void *)(v15 + v12 * 24);
      if (v16 <= v13) {
        unint64_t v18 = a4 + 3;
      }
      else {
        unint64_t v18 = v17;
      }
      begin[v12].first.__i_ = (std::__wrap_iter<const char *>::iterator_type)(a2 + *v18 - v10);
      if (0xAAAAAAAAAAAAAAABLL * ((a4[1] - *a4) >> 3) <= v13) {
        size_t v19 = a4 + 3;
      }
      else {
        size_t v19 = (uint64_t *)(*a4 + v12 * 24);
      }
      a1->__begin_[v12].second.__i_ = (std::__wrap_iter<const char *>::iterator_type)(a2 + v19[1] - v10);
      uint64_t v15 = *a4;
      uint64_t v14 = a4[1];
      if (0xAAAAAAAAAAAAAAABLL * ((v14 - *a4) >> 3) <= v13) {
        char v20 = a4 + 3;
      }
      else {
        char v20 = (uint64_t *)(*a4 + v12 * 24);
      }
      char v21 = *((unsigned char *)v20 + 16);
      std::vector<std::ssub_match>::pointer begin = a1->__begin_;
      std::vector<std::ssub_match>::pointer end = a1->__end_;
      a1->__begin_[v12].matched = v21;
      ++v13;
      ++v12;
    }
    while (v13 < 0xAAAAAAAAAAAAAAABLL * (((char *)end - (char *)begin) >> 3));
  }
  a1[1].__begin_ = a3;
  a1[1].__end_ = a3;
  LOBYTE(a1[1].__end_cap_.__value_) = 0;
  uint64_t v23 = (std::sub_match<std::__wrap_iter<const char *>> *)(a2 + a4[6] - v10);
  a1[2].__begin_ = v23;
  a1[2].__end_ = (std::vector<std::ssub_match>::pointer)(a2 + a4[7] - v10);
  LOBYTE(a1[2].__end_cap_.__value_) = *((unsigned char *)a4 + 64);
  a1[3].__begin_ = (std::vector<std::ssub_match>::pointer)(a2 + a4[9] - v10);
  a1[3].__end_ = (std::vector<std::ssub_match>::pointer)(a2 + a4[10] - v10);
  LOBYTE(a1[3].__end_cap_.__value_) = *((unsigned char *)a4 + 88);
  if ((a5 & 1) == 0) {
    a1[4].__end_ = v23;
  }
  LOBYTE(a1[4].__begin_) = *((unsigned char *)a4 + 96);
}

void std::vector<std::sub_match<std::__wrap_iter<char const*>>>::resize(std::vector<std::ssub_match> *this, std::vector<std::ssub_match>::size_type __sz)
{
  std::vector<std::ssub_match>::size_type v2 = 0xAAAAAAAAAAAAAAABLL * (((char *)this->__end_ - (char *)this->__begin_) >> 3);
  BOOL v3 = __sz >= v2;
  std::vector<std::ssub_match>::size_type v4 = __sz - v2;
  if (v4 != 0 && v3)
  {
    std::vector<std::sub_match<std::__wrap_iter<char const*>>>::__append(this, v4);
  }
  else if (!v3)
  {
    this->__end_ = &this->__begin_[__sz];
  }
}

void std::vector<std::sub_match<std::__wrap_iter<char const*>>>::__append(std::vector<std::ssub_match> *this, std::vector<std::ssub_match>::size_type __n)
{
  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  __int16 v5 = value;
  uint64_t v7 = p_end_cap[-1].__value_;
  if (0xAAAAAAAAAAAAAAABLL * (((char *)value - (char *)v7) >> 3) >= __n)
  {
    if (__n)
    {
      unint64_t v13 = &v7[__n];
      std::vector<std::ssub_match>::size_type v14 = 24 * __n;
      do
      {
        v7->first.__i_ = 0;
        v7->second.__i_ = 0;
        v7->matched = 0;
        ++v7;
        v14 -= 24;
      }
      while (v14);
      uint64_t v7 = v13;
    }
    this->__end_ = v7;
  }
  else
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * (((char *)v7 - (char *)this->__begin_) >> 3);
    unint64_t v9 = v8 + __n;
    if (v8 + __n > 0xAAAAAAAAAAAAAAALL) {
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (((char *)v5 - (char *)this->__begin_) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x555555555555555) {
      unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v9;
    }
    if (v11) {
      unint64_t v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)p_end_cap, v11);
    }
    else {
      unint64_t v12 = 0;
    }
    uint64_t v15 = (std::sub_match<std::__wrap_iter<const char *>> *)&v12[24 * v8];
    unint64_t v16 = &v15[__n];
    std::vector<std::ssub_match>::size_type v17 = 24 * __n;
    unint64_t v18 = v15;
    do
    {
      v18->first.__i_ = 0;
      v18->second.__i_ = 0;
      v18->matched = 0;
      ++v18;
      v17 -= 24;
    }
    while (v17);
    size_t v19 = (std::sub_match<std::__wrap_iter<const char *>> *)&v12[24 * v11];
    std::vector<std::ssub_match>::pointer begin = this->__begin_;
    std::vector<std::ssub_match>::pointer end = this->__end_;
    if (end != this->__begin_)
    {
      do
      {
        std::pair<std::__wrap_iter<const char *>, std::__wrap_iter<const char *>> v22 = end[-1].std::pair<std::__wrap_iter<const char *>, std::__wrap_iter<const char *>>;
        *(void *)&v15[-1].matched = *(void *)&end[-1].matched;
        v15[-1].std::pair<std::__wrap_iter<const char *>, std::__wrap_iter<const char *>> = v22;
        --v15;
        --end;
      }
      while (end != begin);
      std::vector<std::ssub_match>::pointer end = this->__begin_;
    }
    this->__begin_ = v15;
    this->__end_ = v16;
    this->__end_cap_.__value_ = v19;
    if (end)
    {
      operator delete(end);
    }
  }
}

void MIL::Text::ParseProgram(void *a1, uint64_t a2)
{
  uint64_t v2 = a1[1];
  v5[0] = *a1;
  v5[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  if (*(char *)(a2 + 23) < 0)
  {
    uint64_t v4 = a2;
    a2 = *(void *)a2;
    uint64_t v3 = *(void *)(v4 + 8);
  }
  else
  {
    uint64_t v3 = *(unsigned __int8 *)(a2 + 23);
  }
  MIL::Text::ParseProgramView((MIL::ParserOptions *)v5, a2, v3);
}

void sub_20F4719F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void MIL::Text::ParseProgramView(MIL::ParserOptions *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a2;
  uint64_t v4 = a3;
  MIL::ParserOptions::Make(a1);
}

void sub_20F471B60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,std::__shared_weak_count *a26)
{
  if (a26) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a26);
  }
  if (a19) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a19);
  }
  v29 = *(std::__shared_weak_count **)(v26 - 80);
  if (v29) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v29);
  }
  uint64_t v30 = *(void *)(v26 - 72);
  *(void *)(v26 - 72) = 0;
  if (v30) {
    (*(void (**)(uint64_t))(*(void *)v30 + 8))(v30);
  }
  uint64_t v31 = *(void *)(v26 - 64);
  *(void *)(v26 - 64) = 0;
  if (v31) {
    (*(void (**)(uint64_t))(*(void *)v31 + 8))(v31);
  }
  if (a2 == 2)
  {
    __cxa_begin_catch(exception_object);
    __cxa_rethrow();
  }
  if (a2 == 1)
  {
    __cxa_begin_catch(exception_object);
    exception = (MIL::UnknownLocation *)__cxa_allocate_exception(0x48uLL);
    MIL::UnknownLocation::Make(exception);
  }
  _Unwind_Resume(exception_object);
}

void MIL::Text::ParseProgram(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a1[1];
  v7[0] = *a1;
  v7[1] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  if (*(char *)(a2 + 23) < 0)
  {
    uint64_t v6 = a2;
    a2 = *(void *)a2;
    uint64_t v5 = *(void *)(v6 + 8);
  }
  else
  {
    uint64_t v5 = *(unsigned __int8 *)(a2 + 23);
  }
  MIL::Text::ParseProgramView((uint64_t)v7, a2, v5, a3);
}

void sub_20F471E74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void MIL::Text::ParseProgramView(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = a3;
  (*(void (**)(uint64_t))(*(void *)a4 + 24))(a4);
  MIL::Scanner::Make();
}

void sub_20F471FB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, long long a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,std::__shared_weak_count *a30)
{
  uint64_t v32 = v30;
  a24 = &unk_26C25A458;
  if (a30) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a30);
  }
  if (a22) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a22);
  }
  char v35 = *(std::__shared_weak_count **)(v31 - 72);
  if (v35) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v35);
  }
  uint64_t v36 = *(void *)(v31 - 64);
  *(void *)(v31 - 64) = 0;
  if (v36) {
    (*(void (**)(uint64_t))(*(void *)v36 + 8))(v36);
  }
  if (a2 == 2)
  {
    __cxa_begin_catch(exception_object);
    __cxa_rethrow();
  }
  if (a2 == 1)
  {
    __cxa_begin_catch(exception_object);
    __cxa_allocate_exception(0x48uLL);
    uint64_t v37 = (*(uint64_t (**)(uint64_t))(*(void *)v32 + 24))(v32);
    if (*(char *)(v37 + 23) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)&a16, *(const std::string::value_type **)v37, *(void *)(v37 + 8));
    }
    else
    {
      long long v38 = *(_OWORD *)v37;
      a17 = *(void *)(v37 + 16);
      a16 = v38;
    }
    MIL::TextFileLocation::Make();
  }
  _Unwind_Resume(exception_object);
}

void MIL::Text::TryParseProgram(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a1[1];
  *(void *)&long long v7 = *a1;
  *((void *)&v7 + 1) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  if (*(char *)(a2 + 23) < 0)
  {
    uint64_t v6 = a2;
    a2 = *(void *)a2;
    uint64_t v5 = *(void *)(v6 + 8);
  }
  else
  {
    uint64_t v5 = *(unsigned __int8 *)(a2 + 23);
  }
  MIL::Text::TryParseProgramView(&v7, a2, v5, a3);
}

void sub_20F472318(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void MIL::Text::TryParseProgramView(long long *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  long long v4 = *a1;
  *(void *)a1 = 0;
  *((void *)a1 + 1) = 0;
  MIL::Text::ParseProgramView((uint64_t)&v4, a2, a3, a4);
}

void sub_20F4723B4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, std::__shared_weak_count *a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,long long a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,std::string *a31,uint64_t a32,long long a33,uint64_t a34)
{
  uint64_t v40 = *v34;
  uint64_t *v34 = 0;
  if (v40) {
    MIL::Pass::Run(v40);
  }
  if (a2 == 4)
  {
    v41 = (MIL::ParseError *)__cxa_begin_catch(a1);
    uint64_t ParseResult = MIL::ParseError::GetParseResult(v41);
    MIL::MILResult::operator=((std::string *)v35, (const std::string *)ParseResult);
    *(_DWORD *)(v35 + 48) = *(_DWORD *)(ParseResult + 48);
  }
  else
  {
    if (a2 != 3)
    {
      __cxa_begin_catch(a1);
      if (a2 == 2)
      {
        uint64_t v46 = (*(uint64_t (**)(uint64_t))(*(void *)v36 + 24))(v36);
        if (*(char *)(v46 + 23) < 0)
        {
          std::string::__init_copy_ctor_external((std::string *)&a23, *(const std::string::value_type **)v46, *(void *)(v46 + 8));
        }
        else
        {
          long long v47 = *(_OWORD *)v46;
          a24 = *(void *)(v46 + 16);
          a23 = v47;
        }
        MIL::TextFileLocation::Make();
      }
      uint64_t v48 = (*(uint64_t (**)(uint64_t))(*(void *)v36 + 24))(v36);
      if (*(char *)(v48 + 23) < 0)
      {
        std::string::__init_copy_ctor_external((std::string *)&a33, *(const std::string::value_type **)v48, *(void *)(v48 + 8));
      }
      else
      {
        long long v49 = *(_OWORD *)v48;
        a34 = *(void *)(v48 + 16);
        a33 = v49;
      }
      MIL::TextFileLocation::Make();
    }
    v43 = __cxa_begin_catch(a1);
    v44 = (uint64_t *)(*(uint64_t (**)(void *))(*(void *)v43 + 48))(v43);
    v45 = (std::__shared_weak_count *)v44[1];
    a15 = *v44;
    a16 = v45;
    if (v45) {
      atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(void **__return_ptr, void *))(*(void *)v43 + 24))(&__p, v43);
    MIL::ParseResult::ParseResult(v37 - 120, &a15, 1, &__p);
    MIL::MILResult::operator=(v35, v37 - 120);
    *(_DWORD *)(v35 + 48) = *(_DWORD *)(v37 - 72);
    MIL::ParseResult::~ParseResult((MIL::ParseResult *)(v37 - 120));
    if (a14 < 0) {
      operator delete(__p);
    }
    if (a16) {
      std::__shared_weak_count::__release_shared[abi:ne180100](a16);
    }
  }
  uint64_t *v34 = 0;
  __cxa_end_catch();
  JUMPOUT(0x20F47239CLL);
}

void sub_20F4727CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,void *__p,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  uint64_t v44 = *(void *)(v42 - 144);
  *(void *)(v42 - 144) = 0;
  if (v44) {
    (*(void (**)(uint64_t))(*(void *)v44 + 8))(v44);
  }
  if (a42 < 0) {
    operator delete(__p);
  }
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void MIL::Text::ParseProgramFromFile(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 24))(a2);
  if (*(char *)(v2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&v4, *(const std::string::value_type **)v2, *(void *)(v2 + 8));
  }
  else
  {
    long long v3 = *(_OWORD *)v2;
    v4.__r_.__value_.__r.__words[2] = *(void *)(v2 + 16);
    *(_OWORD *)&v4.__r_.__value_.__l.__data_ = v3;
  }
  MIL::Blob::MakeMMapFileReader();
}

void sub_20F472AE0(_Unwind_Exception *a1, std::string *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *__p, uint64_t a9, int a10, __int16 a11, char a12, char a13, std::string *a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, std::string *a20,void *__pa,uint64_t a22,uint64_t a23,long long a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,std::__shared_weak_count *a30,void *a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,std::__shared_weak_count *a37)
{
  int v39 = (int)a2;
  a31 = &unk_26C25A458;
  if (a37) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a37);
  }
  if (a30) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a30);
  }
  v41 = *(std::__shared_weak_count **)(v38 - 104);
  if (v41) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v41);
  }
  uint64_t v42 = *(void *)(v38 - 96);
  *(void *)(v38 - 96) = 0;
  if (v42) {
    (*(void (**)(uint64_t, std::string *, void *, uint64_t, uint64_t, uint64_t, uint64_t, void *))(*(void *)v42 + 8))(v42, a2, a3, a4, a5, a6, a7, __p);
  }
  std::unique_ptr<MIL::Blob::MMapFileReader const>::reset[abi:ne180100]((MIL::Blob::MMapFileReader **)(v38 - 88), 0);
  switch(v39)
  {
    case 3:
      __cxa_begin_catch(a1);
      __cxa_rethrow();
    case 2:
      __cxa_begin_catch(a1);
      exception = (MIL::UnknownLocation *)__cxa_allocate_exception(0x48uLL);
      MIL::UnknownLocation::Make(exception);
    case 1:
      __cxa_begin_catch(a1);
      __cxa_allocate_exception(0x48uLL);
      uint64_t v44 = (*(uint64_t (**)(uint64_t))(*(void *)v37 + 24))(v37);
      if (*(char *)(v44 + 23) < 0)
      {
        std::string::__init_copy_ctor_external((std::string *)&a24, *(const std::string::value_type **)v44, *(void *)(v44 + 8));
      }
      else
      {
        long long v45 = *(_OWORD *)v44;
        a25 = *(void *)(v44 + 16);
        a24 = v45;
      }
      MIL::TextFileLocation::Make();
  }
  if (*(char *)(v38 - 57) < 0) {
    operator delete(*(void **)(v38 - 80));
  }
  _Unwind_Resume(a1);
}

void MIL::Text::ParseValue(MIL::ParserOptions *a1)
{
}

void sub_20F47316C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  char v21 = *(std::__shared_weak_count **)(v18 - 64);
  if (v21) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v21);
  }
  uint64_t v22 = *(void *)(v18 - 56);
  *(void *)(v18 - 56) = 0;
  if (v22) {
    (*(void (**)(uint64_t))(*(void *)v22 + 8))(v22);
  }
  uint64_t v23 = *(void *)(v18 - 48);
  *(void *)(v18 - 48) = 0;
  if (v23) {
    (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
  }
  if (a2 == 2)
  {
    __cxa_begin_catch(exception_object);
    __cxa_rethrow();
  }
  if (a2 == 1)
  {
    __cxa_begin_catch(exception_object);
    exception = (MIL::UnknownLocation *)__cxa_allocate_exception(0x48uLL);
    MIL::UnknownLocation::Make(exception);
  }
  _Unwind_Resume(exception_object);
}

void MIL::Text::ParseValue(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_20F473504(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  char v20 = *(std::__shared_weak_count **)(v17 - 56);
  if (v20) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v20);
  }
  uint64_t v21 = *(void *)(v17 - 48);
  *(void *)(v17 - 48) = 0;
  if (v21) {
    (*(void (**)(uint64_t))(*(void *)v21 + 8))(v21);
  }
  if (a2 == 2)
  {
    __cxa_begin_catch(exception_object);
    __cxa_rethrow();
  }
  if (a2 == 1)
  {
    __cxa_begin_catch(exception_object);
    exception = (MIL::UnknownLocation *)__cxa_allocate_exception(0x48uLL);
    MIL::UnknownLocation::Make(exception);
  }
  _Unwind_Resume(exception_object);
}

void MIL::Text::ParseValueType(MIL::ParserOptions *a1)
{
}

void sub_20F4737C4(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  MIL::Text::ParseValueType((uint64_t *)(v23 - 56), a1, a2, v23 - 48);
  int v26 = *(_DWORD *)(v23 - 40);
  if (v26 == 2)
  {
    __cxa_begin_catch(*(void **)(v23 - 48));
    __cxa_rethrow();
  }
  if (v26 == 1)
  {
    __cxa_begin_catch(*(void **)(v23 - 48));
    exception = (MIL::UnknownLocation *)__cxa_allocate_exception(0x48uLL);
    MIL::UnknownLocation::Make(exception);
  }
  _Unwind_Resume(*(_Unwind_Exception **)(v23 - 48));
}

void MIL::Text::ParseValueType(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_20F473B00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  char v20 = *(std::__shared_weak_count **)(v17 - 56);
  if (v20) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v20);
  }
  uint64_t v21 = *(void *)(v17 - 48);
  *(void *)(v17 - 48) = 0;
  if (v21) {
    (*(void (**)(uint64_t))(*(void *)v21 + 8))(v21);
  }
  if (a2 == 2)
  {
    __cxa_begin_catch(exception_object);
    __cxa_rethrow();
  }
  if (a2 == 1)
  {
    __cxa_begin_catch(exception_object);
    exception = (MIL::UnknownLocation *)__cxa_allocate_exception(0x48uLL);
    MIL::UnknownLocation::Make(exception);
  }
  _Unwind_Resume(exception_object);
}

void *std::allocate_shared[abi:ne180100]<MIL::ParserContext,std::allocator<MIL::ParserContext>,MIL::ParserOptions const&,void>@<X0>(const MIL::ParserOptions *a1@<X1>, void *a2@<X8>)
{
  std::string v4 = operator new(0xE18uLL);
  uint64_t result = std::__shared_ptr_emplace<MIL::ParserContext>::__shared_ptr_emplace[abi:ne180100]<MIL::ParserOptions const&,std::allocator<MIL::ParserContext>,0>(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_20F473D5C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<MIL::ParserContext>::__shared_ptr_emplace[abi:ne180100]<MIL::ParserOptions const&,std::allocator<MIL::ParserContext>,0>(void *a1, const MIL::ParserOptions *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_26C25C0F0;
  MIL::ParserContext::ParserContext((MIL::ParserContext *)(a1 + 3), a2);
  return a1;
}

void sub_20F473DB8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void MIL::ScanError::~ScanError(std::runtime_error *this)
{
  this->__vftable = (std::runtime_error_vtbl *)&unk_26C25A1B0;
  MIL::ParseResult::~ParseResult((MIL::ParseResult *)&this[1]);

  std::runtime_error::~runtime_error(this);
}

{
  uint64_t vars8;

  this->__vftable = (std::runtime_error_vtbl *)&unk_26C25A1B0;
  MIL::ParseResult::~ParseResult((MIL::ParseResult *)&this[1]);

  std::runtime_error::~runtime_error(this);
}

{
  uint64_t vars8;

  this->__vftable = (std::runtime_error_vtbl *)&unk_26C25A1B0;
  MIL::ParseResult::~ParseResult((MIL::ParseResult *)&this[1]);
  std::runtime_error::~runtime_error(this);

  JUMPOUT(0x21056C700);
}

void *MIL::ScanError::ScanError(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  long long v8 = *(_OWORD *)a2;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(_OWORD *)std::match_results<const char *> __p = *(_OWORD *)a3;
  uint64_t v7 = *(void *)(a3 + 16);
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)a3 = 0;
  MIL::ParseError::ParseError((uint64_t)a1, &v8, (uint64_t)__p, a4);
  if (SHIBYTE(v7) < 0) {
    operator delete(__p[0]);
  }
  if (*((void *)&v8 + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v8 + 1));
  }
  *a1 = &unk_26C25CBD0;
  return a1;
}

void sub_20F473F70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a17) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a17);
  }
  _Unwind_Resume(exception_object);
}

void MIL::UnexpectedTokenTypeError::~UnexpectedTokenTypeError(std::runtime_error *this)
{
  this->__vftable = (std::runtime_error_vtbl *)&unk_26C25CC20;
  UnknownLocationImpl::~UnknownLocationImpl((UnknownLocationImpl *)&this[5]);
  this->__vftable = (std::runtime_error_vtbl *)&unk_26C25A1B0;
  MIL::ParseResult::~ParseResult((MIL::ParseResult *)&this[1]);

  std::runtime_error::~runtime_error(this);
}

{
  uint64_t vars8;

  MIL::UnexpectedTokenTypeError::~UnexpectedTokenTypeError(this);

  JUMPOUT(0x21056C700);
}

uint64_t MIL::UnexpectedTokenTypeError::UnexpectedTokenTypeError(uint64_t a1, uint64_t *a2, unsigned int a3, MIL::ParserContext *a4, uint64_t a5)
{
  unint64_t v9 = (std::__shared_weak_count *)a2[1];
  uint64_t v24 = *a2;
  char v25 = v9;
  *a2 = 0;
  a2[1] = 0;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v28);
  int v10 = *(char *)(a5 + 23);
  if (v10 >= 0) {
    uint64_t v11 = a5;
  }
  else {
    uint64_t v11 = *(void *)a5;
  }
  if (v10 >= 0) {
    uint64_t v12 = *(unsigned __int8 *)(a5 + 23);
  }
  else {
    uint64_t v12 = *(void *)(a5 + 8);
  }
  unint64_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v28, v11, v12);
  std::vector<std::ssub_match>::size_type v14 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)": got '", 7);
  ProgramFirstSet = (uint64_t *)MIL::ParserContext::GetProgramFirstSet(a4);
  unint64_t v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, *ProgramFirstSet, ProgramFirstSet[1]);
  uint64_t v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)"' when expecting token of type '", 32);
  MIL::GetTokenName(a3, __p);
  if ((v27 & 0x80u) == 0) {
    uint64_t v18 = __p;
  }
  else {
    uint64_t v18 = (void **)__p[0];
  }
  if ((v27 & 0x80u) == 0) {
    uint64_t v19 = v27;
  }
  else {
    uint64_t v19 = (uint64_t)__p[1];
  }
  char v20 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)v18, v19);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, (uint64_t)"'.", 2);
  if ((char)v27 < 0) {
    operator delete(__p[0]);
  }
  std::stringbuf::str();
  v28[0] = *MEMORY[0x263F8C2C8];
  *(void *)((char *)v28 + *(void *)(v28[0] - 24)) = *(void *)(MEMORY[0x263F8C2C8] + 24);
  v28[1] = MEMORY[0x263F8C318] + 16;
  if (v29 < 0) {
    operator delete((void *)v28[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x21056C620](&v30);
  MIL::ScanError::ScanError((void *)a1, (uint64_t)&v24, (uint64_t)&v22, 201);
  if (v23 < 0) {
    operator delete(v22);
  }
  if (v25) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v25);
  }
  *(void *)a1 = &unk_26C25CC20;
  *(_DWORD *)(a1 + 72) = a3;
  MIL::Scanner::Token::Token((_OWORD *)(a1 + 80), (uint64_t)a4);
  return a1;
}

void sub_20F4742A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a17) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::UnexpectedTokenTypeError::GetExpectedTokenType(MIL::UnexpectedTokenTypeError *this)
{
  return *((unsigned int *)this + 18);
}

uint64_t MIL::UnexpectedTokenTypeError::GetActualToken(MIL::UnexpectedTokenTypeError *this)
{
  return (uint64_t)this + 80;
}

void MIL::UnexpectedTokenValueError::~UnexpectedTokenValueError(std::runtime_error *this)
{
  this->__vftable = (std::runtime_error_vtbl *)&unk_26C25CC70;
  UnknownLocationImpl::~UnknownLocationImpl((UnknownLocationImpl *)&this[6]);
  if (SHIBYTE(this[5].__imp_.__imp_) < 0) {
    operator delete((void *)this[4].__imp_.__imp_);
  }
  this->__vftable = (std::runtime_error_vtbl *)&unk_26C25A1B0;
  MIL::ParseResult::~ParseResult((MIL::ParseResult *)&this[1]);

  std::runtime_error::~runtime_error(this);
}

{
  uint64_t vars8;

  MIL::UnexpectedTokenValueError::~UnexpectedTokenValueError(this);

  JUMPOUT(0x21056C700);
}

uint64_t MIL::UnexpectedTokenValueError::UnexpectedTokenValueError(uint64_t a1, uint64_t *a2, uint64_t a3, MIL::ParserContext *a4, uint64_t a5)
{
  unint64_t v9 = (std::__shared_weak_count *)a2[1];
  uint64_t v26 = *a2;
  unsigned __int8 v27 = v9;
  *a2 = 0;
  a2[1] = 0;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v28);
  int v10 = *(char *)(a5 + 23);
  if (v10 >= 0) {
    uint64_t v11 = a5;
  }
  else {
    uint64_t v11 = *(void *)a5;
  }
  if (v10 >= 0) {
    uint64_t v12 = *(unsigned __int8 *)(a5 + 23);
  }
  else {
    uint64_t v12 = *(void *)(a5 + 8);
  }
  unint64_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v28, v11, v12);
  std::vector<std::ssub_match>::size_type v14 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)": got '", 7);
  ProgramFirstSet = (uint64_t *)MIL::ParserContext::GetProgramFirstSet(a4);
  unint64_t v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, *ProgramFirstSet, ProgramFirstSet[1]);
  uint64_t v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)"' when expecting '", 18);
  int v18 = *(char *)(a3 + 23);
  if (v18 >= 0) {
    uint64_t v19 = a3;
  }
  else {
    uint64_t v19 = *(void *)a3;
  }
  if (v18 >= 0) {
    uint64_t v20 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    uint64_t v20 = *(void *)(a3 + 8);
  }
  uint64_t v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, v19, v20);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)"'.", 2);
  std::stringbuf::str();
  v28[0] = *MEMORY[0x263F8C2C8];
  *(void *)((char *)v28 + *(void *)(v28[0] - 24)) = *(void *)(MEMORY[0x263F8C2C8] + 24);
  v28[1] = MEMORY[0x263F8C318] + 16;
  if (v29 < 0) {
    operator delete((void *)v28[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x21056C620](&v30);
  MIL::ScanError::ScanError((void *)a1, (uint64_t)&v26, (uint64_t)&v24, 202);
  if (v25 < 0) {
    operator delete(v24);
  }
  if (v27) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v27);
  }
  *(void *)a1 = &unk_26C25CC70;
  long long v22 = *(_OWORD *)a3;
  *(void *)(a1 + 88) = *(void *)(a3 + 16);
  *(_OWORD *)(a1 + 72) = v22;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)a3 = 0;
  MIL::Scanner::Token::Token((_OWORD *)(a1 + 96), (uint64_t)a4);
  return a1;
}

void sub_20F474624(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, std::__shared_weak_count *a16, char a17)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::UnexpectedTokenValueError::GetExpectedTokenValue(MIL::UnexpectedTokenValueError *this)
{
  return (uint64_t)this + 72;
}

uint64_t MIL::UnexpectedTokenValueError::GetActualToken(MIL::UnexpectedTokenValueError *this)
{
  return (uint64_t)this + 96;
}

void MIL::UnexpectedEOFError::~UnexpectedEOFError(std::runtime_error *this)
{
  this->__vftable = (std::runtime_error_vtbl *)&unk_26C25A1B0;
  MIL::ParseResult::~ParseResult((MIL::ParseResult *)&this[1]);

  std::runtime_error::~runtime_error(this);
}

{
  uint64_t vars8;

  this->__vftable = (std::runtime_error_vtbl *)&unk_26C25A1B0;
  MIL::ParseResult::~ParseResult((MIL::ParseResult *)&this[1]);
  std::runtime_error::~runtime_error(this);

  JUMPOUT(0x21056C700);
}

void *MIL::UnexpectedEOFError::UnexpectedEOFError(void *a1, long long *a2, uint64_t a3)
{
  long long v7 = *a2;
  *(void *)a2 = 0;
  *((void *)a2 + 1) = 0;
  *(_OWORD *)std::match_results<const char *> __p = *(_OWORD *)a3;
  uint64_t v6 = *(void *)(a3 + 16);
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)a3 = 0;
  MIL::ScanError::ScanError(a1, (uint64_t)&v7, (uint64_t)__p, 1);
  if (SHIBYTE(v6) < 0) {
    operator delete(__p[0]);
  }
  if (*((void *)&v7 + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v7 + 1));
  }
  *a1 = &unk_26C25CCC0;
  return a1;
}

void sub_20F4747D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a17) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a17);
  }
  _Unwind_Resume(exception_object);
}

__n128 MIL::Scanner::Token::Token(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

__n128 MIL::Scanner::Token::operator=(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  __n128 result = *(__n128 *)(a2 + 8);
  *(__n128 *)(a1 + 8) = result;
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  return result;
}

uint64_t MIL::Scanner::Token::Token(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(_DWORD *)__n128 result = a2;
  *(void *)(result + 8) = a3;
  *(void *)(result + 16) = a4;
  *(void *)(result + 24) = a5;
  return result;
}

uint64_t MIL::Scanner::Token::Token(uint64_t result, int a2, uint64_t a3, uint64_t a4)
{
  *(_DWORD *)__n128 result = a2;
  *(void *)(result + 8) = a3;
  *(void *)(result + 16) = a4;
  *(void *)(result + 24) = 0;
  return result;
}

BOOL MIL::Scanner::Token::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a1 == *(_DWORD *)a2
    && (size_t v4 = *(void *)(a1 + 16), v4 == *(void *)(a2 + 16))
    && !memcmp(*(const void **)(a1 + 8), *(const void **)(a2 + 8), v4)
    && *(_DWORD *)(a1 + 24) == *(_DWORD *)(a2 + 24))
  {
    return *(_DWORD *)(a1 + 28) == *(_DWORD *)(a2 + 28);
  }
  else
  {
    return 0;
  }
}

uint64_t MIL::Scanner::Token::GetType(MIL::Scanner::Token *this)
{
  return *(unsigned int *)this;
}

BOOL MIL::Scanner::Token::operator!=(uint64_t a1, uint64_t a2)
{
  return !MIL::Scanner::Token::operator==(a1, a2);
}

uint64_t MIL::Scanner::Token::GetLocation(MIL::Scanner::Token *this)
{
  return (uint64_t)this + 24;
}

void *MIL::Scanner::Scanner(void *this)
{
  *this = &unk_26C25CD70;
  return this;
}

uint64_t MIL::Scanner::Expect(uint64_t a1, int a2, uint64_t a3)
{
  if (*(_DWORD *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1) != a2)
  {
    if (*(char *)(a3 + 23) < 0) {
      std::string::__init_copy_ctor_external(&v8, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
    }
    else {
      std::string v8 = *(std::string *)a3;
    }
    if (SHIBYTE(v8.__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external(&v7, v8.__r_.__value_.__l.__data_, v8.__r_.__value_.__l.__size_);
    }
    else {
      std::string v7 = v8;
    }
    MIL::TextFileLocation::Make();
  }
  uint64_t v5 = *(uint64_t (**)(uint64_t))(*(void *)a1 + 16);

  return v5(a1);
}

void sub_20F474B04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v29 = *(void *)(v27 - 88);
  *(void *)(v27 - 88) = 0;
  if (v29) {
    MIL::Builder::BlockBuilder::BlockBuilderImpl::BlockBuilderImpl(v29);
  }
  if (a27 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v27 - 57) < 0) {
    operator delete(*(void **)(v27 - 80));
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::Scanner::Expect(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1);
  if (*(_DWORD *)a2 != *(_DWORD *)v6)
  {
    if (*(char *)(a3 + 23) < 0) {
      std::string::__init_copy_ctor_external(&v12, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
    }
    else {
      std::string v12 = *(std::string *)a3;
    }
    if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external(&v11, v12.__r_.__value_.__l.__data_, v12.__r_.__value_.__l.__size_);
    }
    else {
      std::string v11 = v12;
    }
    MIL::TextFileLocation::Make();
  }
  size_t v7 = *(void *)(a2 + 16);
  if (v7 != *(void *)(v6 + 16) || memcmp(*(const void **)(a2 + 8), *(const void **)(v6 + 8), v7))
  {
    if (*(char *)(a3 + 23) < 0) {
      std::string::__init_copy_ctor_external(&v12, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
    }
    else {
      std::string v12 = *(std::string *)a3;
    }
    if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external(&v10, v12.__r_.__value_.__l.__data_, v12.__r_.__value_.__l.__size_);
    }
    else {
      std::string v10 = v12;
    }
    MIL::TextFileLocation::Make();
  }
  std::string v8 = *(uint64_t (**)(uint64_t))(*(void *)a1 + 16);

  return v8(a1);
}

void sub_20F474F40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,std::__shared_weak_count *a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45)
{
  if (a27) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a27);
  }
  __cxa_free_exception(v46);
  if (a33 < 0) {
    operator delete(__p);
  }
  if (v45) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v45);
  }
  if (*(char *)(v47 - 73) < 0) {
    operator delete(*(void **)(v47 - 96));
  }
  _Unwind_Resume(exception_object);
}

void MIL::Scanner::Make()
{
}

{
  operator new();
}

{
  operator new();
}

{
  operator new();
}

void sub_20F475144(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  MEMORY[0x21056C700](v21, 0x10D3C4074676381);
  _Unwind_Resume(a1);
}

void sub_20F475238(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  MEMORY[0x21056C700](v14, 0x10D3C4074676381);
  _Unwind_Resume(a1);
}

void sub_20F475300(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  MEMORY[0x21056C700](v15, 0x10D3C40F412050CLL);
  _Unwind_Resume(a1);
}

void sub_20F475398(_Unwind_Exception *a1)
{
  MEMORY[0x21056C700](v1, 0x10D3C40F412050CLL);
  _Unwind_Resume(a1);
}

void *MIL::GetTokenName@<X0>(unsigned int a1@<W0>, void *a2@<X8>)
{
  if (a1 >= 0x39)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Internal error");
    __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
  }
  uint64_t v2 = off_26412C4C8[a1];

  return std::string::basic_string[abi:ne180100]<0>(a2, v2);
}

void sub_20F475438(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t anonymous namespace'::ScannerImpl<std::string>::ScannerImpl(uint64_t a1, long long *a2, long long *a3)
{
  *(void *)a1 = &unk_26C25CDB0;
  uint64_t v5 = (_OWORD *)(a1 + 8);
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a1 + 8), *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v6 = *a2;
    *(void *)(a1 + 24) = *((void *)a2 + 2);
    *uint64_t v5 = v6;
  }
  size_t v7 = v5;
  if (*(char *)(a1 + 31) < 0) {
    size_t v7 = *(_OWORD **)v5;
  }
  *(void *)(a1 + 32) = v7;
  *(void *)(a1 + 40) = v7;
  *(void *)(a1 + 48) = v7;
  *(void *)(a1 + 56) = v7;
  *(void *)(a1 + 64) = 1;
  std::string v8 = (std::string *)(a1 + 72);
  if (*((char *)a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v8, *(const std::string::value_type **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v9 = *a3;
    *(void *)(a1 + 88) = *((void *)a3 + 2);
    *(_OWORD *)&v8->__r_.__value_.__l.__data_ = v9;
  }
  *(_DWORD *)(a1 + 96) = 55;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 104) = "";
  return a1;
}

void sub_20F475528(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t anonymous namespace'::ScannerImpl<std::string>::~ScannerImpl(uint64_t a1)
{
  *(void *)a1 = &unk_26C25CDB0;
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void anonymous namespace'::ScannerImpl<std::string>::~ScannerImpl(uint64_t a1)
{
  *(void *)a1 = &unk_26C25CDB0;
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }

  JUMPOUT(0x21056C700);
}

__n128 anonymous namespace'::ScannerImpl<std::string>::Next@<Q0>(void *a1@<X0>, _OWORD *a2@<X8>)
{
  uint64_t v4 = (*(uint64_t (**)(void *))(*a1 + 24))(a1);
  __n128 result = *(__n128 *)v4;
  long long v6 = *(_OWORD *)(v4 + 16);
  *a2 = *(_OWORD *)v4;
  a2[1] = v6;
  a1[4] = a1[5];
  return result;
}

uint64_t anonymous namespace'::ScannerImpl<std::string>::Peek(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v2 = a1 + 32;
  if (v4 != v3) {
    return a1 + 96;
  }
  if (*(char *)(a1 + 31) < 0)
  {
    uint64_t v6 = *(void *)(a1 + 8);
    uint64_t v7 = *(void *)(a1 + 16);
  }
  else
  {
    uint64_t v6 = a1 + 8;
    uint64_t v7 = *(unsigned __int8 *)(a1 + 31);
  }
  MIL::NextToken(v2, v6 + v7, (uint64_t)&v9);
  *(_DWORD *)(a1 + 96) = v9;
  uint64_t v5 = a1 + 96;
  *(_OWORD *)(v5 + 8) = v10;
  *(void *)(v5 + 24) = v11;
  return v5;
}

uint64_t anonymous namespace'::ScannerImpl<std::string_view>::ScannerImpl(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4)
{
  *(void *)a1 = &unk_26C25CDF8;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = a3;
  *(void *)(a1 + 24) = a2;
  *(void *)(a1 + 32) = a2;
  *(void *)(a1 + 40) = a2;
  *(void *)(a1 + 48) = a2;
  *(void *)(a1 + 56) = 1;
  uint64_t v5 = (std::string *)(a1 + 64);
  if (*((char *)a4 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v5, *(const std::string::value_type **)a4, *((void *)a4 + 1));
  }
  else
  {
    long long v6 = *a4;
    v5->__r_.__value_.__r.__words[2] = *((void *)a4 + 2);
    *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
  }
  *(_DWORD *)(a1 + 88) = 55;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 96) = "";
  return a1;
}

uint64_t anonymous namespace'::ScannerImpl<std::string_view>::~ScannerImpl(uint64_t a1)
{
  *(void *)a1 = &unk_26C25CDF8;
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  return a1;
}

void anonymous namespace'::ScannerImpl<std::string_view>::~ScannerImpl(uint64_t a1)
{
  *(void *)a1 = &unk_26C25CDF8;
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }

  JUMPOUT(0x21056C700);
}

__n128 anonymous namespace'::ScannerImpl<std::string_view>::Next@<Q0>(void *a1@<X0>, _OWORD *a2@<X8>)
{
  uint64_t v4 = (*(uint64_t (**)(void *))(*a1 + 24))(a1);
  __n128 result = *(__n128 *)v4;
  long long v6 = *(_OWORD *)(v4 + 16);
  *a2 = *(_OWORD *)v4;
  a2[1] = v6;
  a1[3] = a1[4];
  return result;
}

uint64_t anonymous namespace'::ScannerImpl<std::string_view>::Peek(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v2 = a1 + 24;
  if (v4 != v3) {
    return a1 + 88;
  }
  MIL::NextToken(v2, *(void *)(a1 + 8) + *(void *)(a1 + 16), (uint64_t)&v7);
  *(_DWORD *)(a1 + 88) = v7;
  uint64_t v5 = a1 + 88;
  *(_OWORD *)(v5 + 8) = v8;
  *(void *)(v5 + 24) = v9;
  return v5;
}

void MIL::Text::Serialize(MIL::Text *this, const MIL::IRProgram *a2)
{
}

void sub_20F47597C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    MIL::IRProgram::ToString(a10);
  }
  _Unwind_Resume(exception_object);
}

void MIL::Text::Serialize(MIL::Text *this, const MIL::IRProgram *a2, const MIL::Text::SerializerOptions *a3)
{
  MIL::Text::BasicSerializer::BasicSerializer((MIL::Text::BasicSerializer *)v5, a2);
  uint64_t v4 = MIL::Text::BasicSerializer::Program((MIL::Text::BasicSerializer *)v5, this);
  MIL::Text::BasicSerializer::GetOutput(v4);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v5);
}

void sub_20F4759F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)va);
  _Unwind_Resume(a1);
}

void MIL::Text::SerializeToStream(const MIL::IRProgram *a1, uint64_t a2, uint64_t a3)
{
  MIL::Text::BasicSerializer::BasicSerializer(v4, a3, a2);
  MIL::Text::BasicSerializer::Program((MIL::Text::BasicSerializer *)v4, a1);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v4);
}

void sub_20F475A54(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)va);
  _Unwind_Resume(a1);
}

uint64_t MIL::Text::SerializeToFile(MIL::Text *this, const MIL::IRProgram *a2, const MIL::Text::SerializerOptions *a3)
{
  v12[19] = *MEMORY[0x263EF8340];
  uint64_t v5 = (*(uint64_t (**)(const MIL::IRProgram *))(*(void *)a2 + 16))(a2);
  uint64_t v6 = *(unsigned __int8 *)(v5 + 23);
  if ((v6 & 0x80u) != 0) {
    uint64_t v6 = *(void *)(v5 + 8);
  }
  if (!v6)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "A file path must be provided to serialize to file. The file path is set by SerializerOptions.");
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  (*(void (**)(const MIL::IRProgram *))(*(void *)a2 + 16))(a2);
  std::ofstream::basic_ofstream(&v10);
  MIL::Text::BasicSerializer::BasicSerializer(v9, &v10, a2);
  MIL::Text::BasicSerializer::Program((MIL::Text::BasicSerializer *)v9, this);
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)v9);
  uint64_t v10 = *MEMORY[0x263F8C2B0];
  *(uint64_t *)((char *)&v10 + *(void *)(v10 - 24)) = *(void *)(MEMORY[0x263F8C2B0] + 24);
  MEMORY[0x21056C330](&v11);
  std::ostream::~ostream();
  return MEMORY[0x21056C620](v12);
}

void sub_20F475C48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59)
{
  __cxa_free_exception(v59);
  _Unwind_Resume(a1);
}

BOOL MIL::Text::ModelPathLengthComparator::operator()(int a1, void *a2, void *__s1)
{
  size_t v3 = *((unsigned __int8 *)a2 + 23);
  int v4 = (char)v3;
  if ((v3 & 0x80u) != 0) {
    size_t v3 = a2[1];
  }
  if (*((char *)__s1 + 23) < 0)
  {
    size_t v5 = __s1[1];
    if (v3 != v5) {
      return v3 > v5;
    }
    __s1 = (void *)*__s1;
  }
  else
  {
    size_t v5 = *((unsigned __int8 *)__s1 + 23);
    if (v3 != v5) {
      return v3 > v5;
    }
  }
  if (v4 < 0) {
    a2 = (void *)*a2;
  }
  return memcmp(__s1, a2, v3) != 0;
}

void *MIL::Text::SerializerOptions::SerializerOptions(void *this)
{
  *this = &unk_26C25CE40;
  return this;
}

void MIL::Text::SerializerOptions::Make(MIL::Text::SerializerOptions *this)
{
}

void anonymous namespace'::SerializerOptionsImpl::~SerializerOptionsImpl(_anonymous_namespace_::SerializerOptionsImpl *this)
{
  if (*((char *)this + 175) < 0) {
    operator delete(*((void **)this + 19));
  }
  if (*((char *)this + 143) < 0) {
    operator delete(*((void **)this + 15));
  }
  std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::destroy((uint64_t)this + 80, *((char **)this + 11));
  std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table((uint64_t)this + 40);
  if (*((char *)this + 31) < 0) {
    operator delete(*((void **)this + 1));
  }
}

{
  uint64_t vars8;

  JUMPOUT(0x21056C700);
}

uint64_t anonymous namespace'::SerializerOptionsImpl::GetModelFilePath(_anonymous_namespace_::SerializerOptionsImpl *this)
{
  return (uint64_t)this + 8;
}

__n128 anonymous namespace'::SerializerOptionsImpl::SetModelFilePath(uint64_t a1, __n128 *a2)
{
  uint64_t v3 = a1 + 8;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)v3);
  }
  __n128 result = *a2;
  *(void *)(v3 + 16) = a2[1].n128_u64[0];
  *(__n128 *)uint64_t v3 = result;
  a2[1].n128_u8[7] = 0;
  a2->n128_u8[0] = 0;
  return result;
}

uint64_t anonymous namespace'::SerializerOptionsImpl::GetModelPaths(_anonymous_namespace_::SerializerOptionsImpl *this)
{
  return (uint64_t)this + 80;
}

void anonymous namespace'::SerializerOptionsImpl::SetModelPaths(uint64_t a1, void *a2)
{
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  unint64_t v13 = &v14;
  uint64_t v3 = a2 + 1;
  int v4 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      if (*((char *)v4 + 55) < 0) {
        std::string::__init_copy_ctor_external(&__p, (const std::string::value_type *)v4[4], v4[5]);
      }
      else {
        std::string __p = *(std::string *)(v4 + 4);
      }
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      size_t v5 = (void *)v4[1];
      if (v5)
      {
        do
        {
          uint64_t v6 = v5;
          size_t v5 = (void *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          uint64_t v6 = (void *)v4[2];
          BOOL v7 = *v6 == (void)v4;
          int v4 = v6;
        }
        while (!v7);
      }
      int v4 = v6;
    }
    while (v6 != v3);
  }
  uint64_t v9 = *(char **)(a1 + 88);
  long long v8 = (void *)(a1 + 88);
  std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::destroy((uint64_t)(v8 - 1), v9);
  uint64_t v10 = v14;
  *(v8 - 1) = v13;
  *long long v8 = v10;
  uint64_t v11 = v15;
  v8[1] = v15;
  if (v11)
  {
    *(void *)(v10 + 16) = v8;
    unint64_t v13 = &v14;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    uint64_t v10 = 0;
  }
  else
  {
    *(v8 - 1) = v8;
  }
  std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::destroy((uint64_t)&v13, (char *)v10);
}

void sub_20F476010(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, char *a16)
{
}

void anonymous namespace'::SerializerOptionsImpl::SetModelPathsFromVector(uint64_t a1, long long **a2)
{
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  std::string v12 = &v13;
  uint64_t v3 = *a2;
  int v4 = a2[1];
  while (v3 != v4)
  {
    if (*((char *)v3 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(&v11, *(const std::string::value_type **)v3, *((void *)v3 + 1));
    }
    else
    {
      long long v5 = *v3;
      v11.__r_.__value_.__r.__words[2] = *((void *)v3 + 2);
      *(_OWORD *)&v11.__r_.__value_.__l.__data_ = v5;
    }
    std::string __p = v11;
    memset(&v11, 0, sizeof(v11));
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v11.__r_.__value_.__l.__data_);
    }
    uint64_t v3 = (long long *)((char *)v3 + 24);
  }
  BOOL v7 = *(char **)(a1 + 88);
  uint64_t v6 = (void *)(a1 + 88);
  std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::destroy((uint64_t)(v6 - 1), v7);
  uint64_t v8 = v13;
  *(v6 - 1) = v12;
  *uint64_t v6 = v8;
  uint64_t v9 = v14;
  v6[1] = v14;
  if (v9)
  {
    *(void *)(v8 + 16) = v6;
    std::string v12 = &v13;
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    uint64_t v8 = 0;
  }
  else
  {
    *(v6 - 1) = v6;
  }
  std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::destroy((uint64_t)&v12, (char *)v8);
}

void sub_20F476144(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,char *a23)
{
}

uint64_t anonymous namespace'::SerializerOptionsImpl::AddModelPath(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)std::string __p = *(_OWORD *)a2;
  uint64_t v5 = *(void *)(a2 + 16);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  if (SHIBYTE(v5) < 0) {
    operator delete(__p[0]);
  }
  return v2;
}

void sub_20F4761E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL anonymous namespace'::SerializerOptionsImpl::RemoveModelPath(uint64_t a1, uint64_t *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    uint64_t v2 = a2[1];
    if (!v2) {
      goto LABEL_10;
    }
  }
  else
  {
    if (!*((unsigned char *)a2 + 23)) {
      goto LABEL_10;
    }
    uint64_t v2 = *((unsigned __int8 *)a2 + 23);
  }
  if (*((char *)a2 + 23) >= 0) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = (uint64_t *)*a2;
  }
  if (*((unsigned char *)v3 + v2 - 1) == 47)
  {
    uint64_t v4 = std::__tree<std::string,MIL::Text::ModelPathLengthComparator,std::allocator<std::string>>::__erase_unique<std::string>((uint64_t **)(a1 + 80), a2);
    return v4 != 0;
  }
LABEL_10:
  uint64_t v5 = (uint64_t **)(a1 + 80);
  std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((const void **)a2, 47, (uint64_t)__p);
  uint64_t v4 = std::__tree<std::string,MIL::Text::ModelPathLengthComparator,std::allocator<std::string>>::__erase_unique<std::string>(v5, __p);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  return v4 != 0;
}

void sub_20F4762B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t anonymous namespace'::SerializerOptionsImpl::GetFloatSerializeMode(_anonymous_namespace_::SerializerOptionsImpl *this)
{
  return *((unsigned int *)this + 8);
}

uint64_t anonymous namespace'::SerializerOptionsImpl::GetFloatSerializeMode(uint64_t a1, int a2)
{
  int v6 = a2;
  uint64_t v3 = std::__hash_table<std::__hash_value_type<int,std::unordered_map<std::string,std::shared_ptr<MIL::Edge const>>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_map<std::string,std::shared_ptr<MIL::Edge const>>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_map<std::string,std::shared_ptr<MIL::Edge const>>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_map<std::string,std::shared_ptr<MIL::Edge const>>>>>::find<int>((void *)(a1 + 40), &v6);
  uint64_t v4 = (unsigned int *)(a1 + 32);
  if (v3) {
    uint64_t v4 = (unsigned int *)v3 + 5;
  }
  return *v4;
}

uint64_t anonymous namespace'::SerializerOptionsImpl::SetFloatSerializeMode(uint64_t result, int a2)
{
  *(_DWORD *)(result + 32) = a2;
  return result;
}

void *anonymous namespace'::SerializerOptionsImpl::SetFloatSerializeMode(uint64_t a1, int a2, int a3)
{
  int v5 = a3;
  int v6 = &v5;
  __n128 result = std::__hash_table<std::__hash_value_type<MIL::IRDataType,MIL::Text::SerializerOptions::FloatSerializeMode>,std::__unordered_map_hasher<MIL::IRDataType,std::__hash_value_type<MIL::IRDataType,MIL::Text::SerializerOptions::FloatSerializeMode>,std::hash<MIL::IRDataType>,std::equal_to<MIL::IRDataType>,true>,std::__unordered_map_equal<MIL::IRDataType,std::__hash_value_type<MIL::IRDataType,MIL::Text::SerializerOptions::FloatSerializeMode>,std::equal_to<MIL::IRDataType>,std::hash<MIL::IRDataType>,true>,std::allocator<std::__hash_value_type<MIL::IRDataType,MIL::Text::SerializerOptions::FloatSerializeMode>>>::__emplace_unique_key_args<MIL::IRDataType,std::piecewise_construct_t const&,std::tuple<MIL::IRDataType const&>,std::tuple<>>(a1 + 40, &v5, (uint64_t)&std::piecewise_construct, &v6);
  *((_DWORD *)result + 5) = a2;
  return result;
}

uint64_t anonymous namespace'::SerializerOptionsImpl::GetSyntaxVersion(_anonymous_namespace_::SerializerOptionsImpl *this)
{
  return *((unsigned int *)this + 26);
}

uint64_t anonymous namespace'::SerializerOptionsImpl::SetSyntaxVersion(uint64_t result, int a2)
{
  *(_DWORD *)(result + 104) = a2;
  return result;
}

uint64_t anonymous namespace'::SerializerOptionsImpl::GetWeightsFilePath(_anonymous_namespace_::SerializerOptionsImpl *this)
{
  return (uint64_t)this + 120;
}

__n128 anonymous namespace'::SerializerOptionsImpl::SetWeightsFilePath(uint64_t a1, __n128 *a2)
{
  uint64_t v3 = a1 + 120;
  if (*(char *)(a1 + 143) < 0) {
    operator delete(*(void **)v3);
  }
  __n128 result = *a2;
  *(void *)(v3 + 16) = a2[1].n128_u64[0];
  *(__n128 *)uint64_t v3 = result;
  a2[1].n128_u8[7] = 0;
  a2->n128_u8[0] = 0;
  return result;
}

uint64_t anonymous namespace'::SerializerOptionsImpl::GetWeightsBlobNumElementsThreshold(_anonymous_namespace_::SerializerOptionsImpl *this)
{
  return *((void *)this + 14);
}

uint64_t anonymous namespace'::SerializerOptionsImpl::SetWeightsBlobNumElementsThreshold(uint64_t this, uint64_t a2)
{
  *(void *)(this + 112) = a2;
  return this;
}

uint64_t anonymous namespace'::SerializerOptionsImpl::SetSerializeTraceabilityInfoFlag(uint64_t this, char a2)
{
  *(unsigned char *)(this + 144) = a2;
  return this;
}

uint64_t anonymous namespace'::SerializerOptionsImpl::GetSerializeTraceabilityInfoFlag(_anonymous_namespace_::SerializerOptionsImpl *this)
{
  return *((unsigned __int8 *)this + 144);
}

std::string *anonymous namespace'::SerializerOptionsImpl::SetWeightsDirectory(uint64_t a1, const std::string *a2)
{
  return std::string::operator=((std::string *)(a1 + 152), a2);
}

uint64_t anonymous namespace'::SerializerOptionsImpl::GetWeightsDirectory(_anonymous_namespace_::SerializerOptionsImpl *this)
{
  return (uint64_t)this + 152;
}

uint64_t anonymous namespace'::SerializerOptionsImpl::AddModelPath(uint64_t a1, uint64_t **a2)
{
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v4 = *(void *)(a1 + 8);
    if (!v4) {
      goto LABEL_9;
    }
  }
  else
  {
    if (!*(unsigned char *)(a1 + 23)) {
      goto LABEL_9;
    }
    uint64_t v4 = *(unsigned __int8 *)(a1 + 23);
  }
  uint64_t v5 = v4 - 1;
  uint64_t v6 = a1;
  if ((*(unsigned char *)(a1 + 23) & 0x80) != 0) {
    uint64_t v6 = *(void *)a1;
  }
  if (*(unsigned char *)(v6 + v5) == 47)
  {
    std::__tree<std::string,MIL::Text::ModelPathLengthComparator,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string>(a2, (void *)a1, a1);
    char v8 = v7;
    return v8 & 1;
  }
LABEL_9:
  std::string::push_back((std::string *)a1, 47);
  *(_OWORD *)std::string __p = *(_OWORD *)a1;
  uint64_t v12 = *(void *)(a1 + 16);
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  std::__tree<std::string,MIL::Text::ModelPathLengthComparator,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string>(a2, __p, (uint64_t)__p);
  char v8 = v9;
  if (SHIBYTE(v12) < 0) {
    operator delete(__p[0]);
  }
  return v8 & 1;
}

void sub_20F4764DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

_OWORD *std::__tree<std::string,MIL::Text::ModelPathLengthComparator,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string>(uint64_t **a1, void *a2, uint64_t a3)
{
  uint64_t v5 = (void **)std::__tree<std::string,MIL::Text::ModelPathLengthComparator,std::allocator<std::string>>::__find_equal<std::string>((uint64_t)a1, &v9, a2);
  uint64_t v6 = *v5;
  if (!*v5)
  {
    char v7 = (uint64_t **)v5;
    uint64_t v6 = operator new(0x38uLL);
    v6[2] = *(_OWORD *)a3;
    *((void *)v6 + 6) = *(void *)(a3 + 16);
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__insert_node_at(a1, v9, v7, (uint64_t *)v6);
  }
  return v6;
}

void *std::__tree<std::string,MIL::Text::ModelPathLengthComparator,std::allocator<std::string>>::__find_equal<std::string>(uint64_t a1, void *a2, void *a3)
{
  uint64_t v5 = (void *)(a1 + 8);
  uint64_t v4 = *(void **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        char v7 = v4;
        char v8 = v4 + 4;
        LODWORD(a1) = MIL::Text::ModelPathLengthComparator::operator()(a1, a3, v4 + 4);
        if (!a1) {
          break;
        }
        uint64_t v4 = (void *)*v7;
        uint64_t v5 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      LODWORD(a1) = MIL::Text::ModelPathLengthComparator::operator()(0, v8, a3);
      if (!a1) {
        break;
      }
      uint64_t v5 = v7 + 1;
      uint64_t v4 = (void *)v7[1];
    }
    while (v4);
  }
  else
  {
    char v7 = (void *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

uint64_t std::__tree<std::string,MIL::Text::ModelPathLengthComparator,std::allocator<std::string>>::__erase_unique<std::string>(uint64_t **a1, void *a2)
{
  uint64_t v3 = (uint64_t **)std::__tree<std::string,MIL::Text::ModelPathLengthComparator,std::allocator<std::string>>::find<std::string>((uint64_t)a1, a2);
  if (a1 + 1 == v3) {
    return 0;
  }
  std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::erase(a1, (uint64_t)v3);
  return 1;
}

void *std::__tree<std::string,MIL::Text::ModelPathLengthComparator,std::allocator<std::string>>::find<std::string>(uint64_t a1, void *__s1)
{
  uint64_t v2 = (void *)(a1 + 8);
  uint64_t v3 = *(void **)(a1 + 8);
  if (!v3) {
    return v2;
  }
  uint64_t v5 = (void *)(a1 + 8);
  do
  {
    LODWORD(a1) = MIL::Text::ModelPathLengthComparator::operator()(a1, v3 + 4, __s1);
    uint64_t v6 = v3 + 1;
    if (!a1)
    {
      uint64_t v6 = v3;
      uint64_t v5 = v3;
    }
    uint64_t v3 = (void *)*v6;
  }
  while (*v6);
  if (v5 == v2 || MIL::Text::ModelPathLengthComparator::operator()(a1, __s1, v5 + 4)) {
    return v2;
  }
  return v5;
}

void *std::__hash_table<std::__hash_value_type<MIL::IRDataType,MIL::Text::SerializerOptions::FloatSerializeMode>,std::__unordered_map_hasher<MIL::IRDataType,std::__hash_value_type<MIL::IRDataType,MIL::Text::SerializerOptions::FloatSerializeMode>,std::hash<MIL::IRDataType>,std::equal_to<MIL::IRDataType>,true>,std::__unordered_map_equal<MIL::IRDataType,std::__hash_value_type<MIL::IRDataType,MIL::Text::SerializerOptions::FloatSerializeMode>,std::equal_to<MIL::IRDataType>,std::hash<MIL::IRDataType>,true>,std::allocator<std::__hash_value_type<MIL::IRDataType,MIL::Text::SerializerOptions::FloatSerializeMode>>>::__emplace_unique_key_args<MIL::IRDataType,std::piecewise_construct_t const&,std::tuple<MIL::IRDataType const&>,std::tuple<>>(uint64_t a1, int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
    uint64_t v10 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      std::string v11 = *v10;
      if (*v10)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v12 == v7)
          {
            if (*((_DWORD *)v11 + 4) == v7) {
              return v11;
            }
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8) {
                v12 %= v8;
              }
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v4) {
              break;
            }
          }
          std::string v11 = (void *)*v11;
        }
        while (v11);
      }
    }
  }
  std::string v11 = operator new(0x18uLL);
  *std::string v11 = 0;
  v11[1] = v7;
  *((_DWORD *)v11 + 4) = **a4;
  *((_DWORD *)v11 + 5) = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v8 || (float)(v14 * (float)v8) < v13)
  {
    BOOL v15 = 1;
    if (v8 >= 3) {
      BOOL v15 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v8);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v18);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }
  uint64_t v19 = *(void *)a1;
  uint64_t v20 = *(void **)(*(void *)a1 + 8 * v4);
  if (v20)
  {
    *std::string v11 = *v20;
LABEL_38:
    *uint64_t v20 = v11;
    goto LABEL_39;
  }
  *std::string v11 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v11;
  *(void *)(v19 + 8 * v4) = a1 + 16;
  if (*v11)
  {
    unint64_t v21 = *(void *)(*v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v21 >= v8) {
        v21 %= v8;
      }
    }
    else
    {
      v21 &= v8 - 1;
    }
    uint64_t v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v11;
}

void sub_20F4768F0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::Text::Parser::TensorVal::ParseToken<MIL::Fp8E4M3FN>(uint64_t a1, MIL::Scanner::Token *a2)
{
  uint64_t Options = MIL::ParserContext::GetOptions(*(MIL::ParserContext **)(a1 + 24));
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)Options + 24))(Options);
  uint64_t v5 = *(void *)MIL::Scanner::Token::GetLocation(a2);
  if (MIL::Scanner::Token::GetType(a2) != 19 && MIL::Scanner::Token::GetType(a2) != 18)
  {
    __cxa_allocate_exception(0x48uLL);
    MIL::TextLocationFromScannerLocation(v5, v4);
  }
  uint64_t ProgramFirstSet = MIL::ParserContext::GetProgramFirstSet(a2);
  std::string::size_type v7 = *(void *)(ProgramFirstSet + 8);
  if (v7 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  unint64_t v8 = *(const void **)ProgramFirstSet;
  if (v7 >= 0x17)
  {
    uint64_t v10 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17) {
      uint64_t v10 = v7 | 7;
    }
    uint64_t v11 = v10 + 1;
    p_dst = (std::string *)operator new(v10 + 1);
    __dst.__r_.__value_.__l.__size_ = v7;
    __dst.__r_.__value_.__r.__words[2] = v11 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_10;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = *(void *)(ProgramFirstSet + 8);
  p_dst = &__dst;
  if (v7) {
LABEL_10:
  }
    memmove(p_dst, v8, v7);
  p_dst->__r_.__value_.__s.__data_[v7] = 0;
  float v12 = MIL::Util::stof(&__dst, v5, v4);
  uint64_t v14 = MIL::Fp8E4M3FN::FromFloat(v13, v12);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  return v14;
}

void sub_20F476ABC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17, void *a18, std::__shared_weak_count *a19, int a20,__int16 a21,char a22,char a23)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a17) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a17);
  }
  if (a19)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](a19);
    if ((v24 & 1) == 0) {
      goto LABEL_10;
    }
  }
  else if (!v24)
  {
LABEL_10:
    _Unwind_Resume(exception_object);
  }
  __cxa_free_exception(v23);
  goto LABEL_10;
}

uint64_t MIL::Text::Parser::TensorVal::ParseToken<MIL::Fp8E5M2>(uint64_t a1, MIL::Scanner::Token *a2)
{
  uint64_t Options = MIL::ParserContext::GetOptions(*(MIL::ParserContext **)(a1 + 24));
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)Options + 24))(Options);
  uint64_t v5 = *(void *)MIL::Scanner::Token::GetLocation(a2);
  if (MIL::Scanner::Token::GetType(a2) != 19 && MIL::Scanner::Token::GetType(a2) != 18)
  {
    __cxa_allocate_exception(0x48uLL);
    MIL::TextLocationFromScannerLocation(v5, v4);
  }
  uint64_t ProgramFirstSet = MIL::ParserContext::GetProgramFirstSet(a2);
  std::string::size_type v7 = *(void *)(ProgramFirstSet + 8);
  if (v7 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  unint64_t v8 = *(const void **)ProgramFirstSet;
  if (v7 >= 0x17)
  {
    uint64_t v10 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17) {
      uint64_t v10 = v7 | 7;
    }
    uint64_t v11 = v10 + 1;
    p_dst = (std::string *)operator new(v10 + 1);
    __dst.__r_.__value_.__l.__size_ = v7;
    __dst.__r_.__value_.__r.__words[2] = v11 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_10;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = *(void *)(ProgramFirstSet + 8);
  p_dst = &__dst;
  if (v7) {
LABEL_10:
  }
    memmove(p_dst, v8, v7);
  p_dst->__r_.__value_.__s.__data_[v7] = 0;
  float v12 = MIL::Util::stof(&__dst, v5, v4);
  uint64_t v14 = MIL::Fp8E5M2::FromFloat(v13, v12);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  return v14;
}

void sub_20F476CE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17, void *a18, std::__shared_weak_count *a19, int a20,__int16 a21,char a22,char a23)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a17) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a17);
  }
  if (a19)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](a19);
    if ((v24 & 1) == 0) {
      goto LABEL_10;
    }
  }
  else if (!v24)
  {
LABEL_10:
    _Unwind_Resume(exception_object);
  }
  __cxa_free_exception(v23);
  goto LABEL_10;
}

uint64_t MIL::Text::Parser::TensorVal::ParseToken<MIL::Bf16>(uint64_t a1, MIL::Scanner::Token *a2)
{
  uint64_t Options = MIL::ParserContext::GetOptions(*(MIL::ParserContext **)(a1 + 24));
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)Options + 24))(Options);
  uint64_t v5 = *(void *)MIL::Scanner::Token::GetLocation(a2);
  if (MIL::Scanner::Token::GetType(a2) != 19 && MIL::Scanner::Token::GetType(a2) != 18)
  {
    __cxa_allocate_exception(0x48uLL);
    MIL::TextLocationFromScannerLocation(v5, v4);
  }
  uint64_t ProgramFirstSet = MIL::ParserContext::GetProgramFirstSet(a2);
  std::string::size_type v7 = *(void *)(ProgramFirstSet + 8);
  if (v7 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  unint64_t v8 = *(const void **)ProgramFirstSet;
  if (v7 >= 0x17)
  {
    uint64_t v10 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17) {
      uint64_t v10 = v7 | 7;
    }
    uint64_t v11 = v10 + 1;
    p_dst = (std::string *)operator new(v10 + 1);
    __dst.__r_.__value_.__l.__size_ = v7;
    __dst.__r_.__value_.__r.__words[2] = v11 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_10;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = *(void *)(ProgramFirstSet + 8);
  p_dst = &__dst;
  if (v7) {
LABEL_10:
  }
    memmove(p_dst, v8, v7);
  p_dst->__r_.__value_.__s.__data_[v7] = 0;
  float v13 = MIL::Util::stof(&__dst, v5, v4);
  float v14 = fabsf(v13);
  if (v14 != INFINITY && v13 != 0.0 && (v14 > 3.3895e38 || v14 < COERCE_FLOAT(0x10000)))
  {
    __cxa_allocate_exception(0x48uLL);
    MIL::TextLocationFromScannerLocation(v5, v4);
  }
  uint64_t v16 = MIL::Bf16::FromFloat(v12, v13);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  return v16;
}

void sub_20F476FCC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,std::__shared_weak_count *a26,uint64_t a27,std::__shared_weak_count *a28)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a28) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a28);
  }
  if (a26)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](a26);
    if ((v28 & 1) == 0) {
      goto LABEL_10;
    }
  }
  else if (!v28)
  {
LABEL_10:
    if (*(char *)(v30 - 57) < 0) {
      operator delete(*(void **)(v30 - 80));
    }
    _Unwind_Resume(exception_object);
  }
  __cxa_free_exception(v29);
  goto LABEL_10;
}

uint64_t MIL::Text::Parser::TensorVal::ParseToken<MIL::Fp16>(uint64_t a1, MIL::Scanner::Token *a2)
{
  uint64_t Options = MIL::ParserContext::GetOptions(*(MIL::ParserContext **)(a1 + 24));
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)Options + 24))(Options);
  uint64_t v5 = *(void *)MIL::Scanner::Token::GetLocation(a2);
  if (MIL::Scanner::Token::GetType(a2) != 19 && MIL::Scanner::Token::GetType(a2) != 18)
  {
    __cxa_allocate_exception(0x48uLL);
    MIL::TextLocationFromScannerLocation(v5, v4);
  }
  uint64_t ProgramFirstSet = MIL::ParserContext::GetProgramFirstSet(a2);
  std::string::size_type v7 = *(void *)(ProgramFirstSet + 8);
  if (v7 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  unint64_t v8 = *(const void **)ProgramFirstSet;
  if (v7 >= 0x17)
  {
    uint64_t v10 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17) {
      uint64_t v10 = v7 | 7;
    }
    uint64_t v11 = v10 + 1;
    p_dst = (std::string *)operator new(v10 + 1);
    __dst.__r_.__value_.__l.__size_ = v7;
    __dst.__r_.__value_.__r.__words[2] = v11 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_10;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = *(void *)(ProgramFirstSet + 8);
  p_dst = &__dst;
  if (v7) {
LABEL_10:
  }
    memmove(p_dst, v8, v7);
  p_dst->__r_.__value_.__s.__data_[v7] = 0;
  float v13 = MIL::Util::stof(&__dst, v5, v4);
  float v14 = fabsf(v13);
  if (v14 != INFINITY && v13 != 0.0 && (v14 > 65504.0 || v14 < 0.000000059605))
  {
    __cxa_allocate_exception(0x48uLL);
    MIL::TextLocationFromScannerLocation(v5, v4);
  }
  uint64_t v16 = MIL::Fp16::FromFloat(v12, v13);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  return v16;
}

void sub_20F477308(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,std::__shared_weak_count *a26,uint64_t a27,std::__shared_weak_count *a28)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a28) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a28);
  }
  if (a26)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](a26);
    if ((v28 & 1) == 0) {
      goto LABEL_10;
    }
  }
  else if (!v28)
  {
LABEL_10:
    if (*(char *)(v30 - 57) < 0) {
      operator delete(*(void **)(v30 - 80));
    }
    _Unwind_Resume(exception_object);
  }
  __cxa_free_exception(v29);
  goto LABEL_10;
}

float MIL::Text::Parser::TensorVal::ParseToken<float>(uint64_t a1, MIL::Scanner::Token *a2)
{
  uint64_t Options = MIL::ParserContext::GetOptions(*(MIL::ParserContext **)(a1 + 24));
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)Options + 24))(Options);
  uint64_t v5 = *(void *)MIL::Scanner::Token::GetLocation(a2);
  if (MIL::Scanner::Token::GetType(a2) != 19 && MIL::Scanner::Token::GetType(a2) != 18)
  {
    __cxa_allocate_exception(0x48uLL);
    MIL::TextLocationFromScannerLocation(v5, v4);
  }
  uint64_t ProgramFirstSet = MIL::ParserContext::GetProgramFirstSet(a2);
  std::string::size_type v7 = *(void *)(ProgramFirstSet + 8);
  if (v7 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  unint64_t v8 = *(const void **)ProgramFirstSet;
  if (v7 >= 0x17)
  {
    uint64_t v10 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17) {
      uint64_t v10 = v7 | 7;
    }
    uint64_t v11 = v10 + 1;
    p_dst = (std::string *)operator new(v10 + 1);
    __dst.__r_.__value_.__l.__size_ = v7;
    __dst.__r_.__value_.__r.__words[2] = v11 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_10;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = *(void *)(ProgramFirstSet + 8);
  p_dst = &__dst;
  if (v7) {
LABEL_10:
  }
    memmove(p_dst, v8, v7);
  p_dst->__r_.__value_.__s.__data_[v7] = 0;
  float v12 = MIL::Util::stof(&__dst, v5, v4);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  return v12;
}

void sub_20F477590(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17, void *a18, std::__shared_weak_count *a19, int a20,__int16 a21,char a22,char a23)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a17) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a17);
  }
  if (a19)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](a19);
    if ((v24 & 1) == 0) {
      goto LABEL_10;
    }
  }
  else if (!v24)
  {
LABEL_10:
    _Unwind_Resume(exception_object);
  }
  __cxa_free_exception(v23);
  goto LABEL_10;
}

double MIL::Text::Parser::TensorVal::ParseToken<double>(uint64_t a1, MIL::Scanner::Token *a2)
{
  uint64_t Options = MIL::ParserContext::GetOptions(*(MIL::ParserContext **)(a1 + 24));
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)Options + 24))(Options);
  uint64_t v5 = *(void *)MIL::Scanner::Token::GetLocation(a2);
  if (MIL::Scanner::Token::GetType(a2) != 19 && MIL::Scanner::Token::GetType(a2) != 18)
  {
    __cxa_allocate_exception(0x48uLL);
    MIL::TextLocationFromScannerLocation(v5, v4);
  }
  uint64_t ProgramFirstSet = MIL::ParserContext::GetProgramFirstSet(a2);
  std::string::size_type v7 = *(void *)(ProgramFirstSet + 8);
  if (v7 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  unint64_t v8 = *(const void **)ProgramFirstSet;
  if (v7 >= 0x17)
  {
    uint64_t v10 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17) {
      uint64_t v10 = v7 | 7;
    }
    uint64_t v11 = v10 + 1;
    p_dst = (std::string *)operator new(v10 + 1);
    __dst.__r_.__value_.__l.__size_ = v7;
    __dst.__r_.__value_.__r.__words[2] = v11 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_10;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = *(void *)(ProgramFirstSet + 8);
  p_dst = &__dst;
  if (v7) {
LABEL_10:
  }
    memmove(p_dst, v8, v7);
  p_dst->__r_.__value_.__s.__data_[v7] = 0;
  double v12 = MIL::Util::stod(&__dst, v5, v4);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  return v12;
}

void sub_20F4777C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17, void *a18, std::__shared_weak_count *a19, int a20,__int16 a21,char a22,char a23)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a17) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a17);
  }
  if (a19)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](a19);
    if ((v24 & 1) == 0) {
      goto LABEL_10;
    }
  }
  else if (!v24)
  {
LABEL_10:
    _Unwind_Resume(exception_object);
  }
  __cxa_free_exception(v23);
  goto LABEL_10;
}

BOOL MIL::Text::Parser::TensorVal::ParseToken<BOOL>(uint64_t a1, MIL::Scanner::Token *this)
{
  uint64_t v4 = *(void *)MIL::Scanner::Token::GetLocation(this);
  uint64_t Options = MIL::ParserContext::GetOptions(*(MIL::ParserContext **)(a1 + 24));
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)Options + 24))(Options);
  if (MIL::Scanner::Token::GetType(this) == 18)
  {
    std::string::basic_string[abi:ne180100]<0>(&__p, "BOOLean");
    if (MIL::Scanner::Token::GetType(this) != 18)
    {
      __cxa_allocate_exception(0x48uLL);
      MIL::TextLocationFromScannerLocation(v4, v6);
    }
    uint64_t ProgramFirstSet = MIL::ParserContext::GetProgramFirstSet(this);
    std::string::size_type v8 = *(void *)(ProgramFirstSet + 8);
    if (v8 > 0x7FFFFFFFFFFFFFF7) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    uint8x8_t v9 = *(const void **)ProgramFirstSet;
    if (v8 >= 0x17)
    {
      uint64_t v16 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v8 | 7) != 0x17) {
        uint64_t v16 = v8 | 7;
      }
      uint64_t v17 = v16 + 1;
      p_dst = (std::string *)operator new(v16 + 1);
      __dst.__r_.__value_.__l.__size_ = v8;
      __dst.__r_.__value_.__r.__words[2] = v17 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    }
    else
    {
      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = *(void *)(ProgramFirstSet + 8);
      p_dst = &__dst;
      if (!v8)
      {
LABEL_18:
        p_dst->__r_.__value_.__s.__data_[v8] = 0;
        int BaseAndPrepIntStringForParse = MIL::Util::GetBaseAndPrepIntStringForParse(&__dst);
        unsigned int v19 = std::stoi(&__dst, 0, BaseAndPrepIntStringForParse);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        if (v26 < 0) {
          operator delete(__p);
        }
        BOOL v15 = v19 != 0;
        if (v19 > 1) {
          goto LABEL_37;
        }
        return v15;
      }
    }
    memmove(p_dst, v9, v8);
    goto LABEL_18;
  }
  if (MIL::Scanner::Token::GetType(this) != 19)
  {
    if (MIL::Scanner::Token::GetType(this) == 21) {
      return 1;
    }
    if (MIL::Scanner::Token::GetType(this) != 22) {
      goto LABEL_37;
    }
    return 0;
  }
  uint64_t v11 = MIL::ParserContext::GetProgramFirstSet(this);
  std::string::size_type v12 = *(void *)(v11 + 8);
  if (v12 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  float v13 = *(const void **)v11;
  if (v12 >= 0x17)
  {
    uint64_t v20 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v12 | 7) != 0x17) {
      uint64_t v20 = v12 | 7;
    }
    uint64_t v21 = v20 + 1;
    float v14 = (std::string *)operator new(v20 + 1);
    __dst.__r_.__value_.__l.__size_ = v12;
    __dst.__r_.__value_.__r.__words[2] = v21 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v14;
    goto LABEL_29;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = *(void *)(v11 + 8);
  float v14 = &__dst;
  if (v12) {
LABEL_29:
  }
    memmove(v14, v13, v12);
  v14->__r_.__value_.__s.__data_[v12] = 0;
  double v22 = MIL::Util::stod(&__dst, v4, v6);
  BOOL v15 = v22 != 0.0;
  BOOL v23 = v22 != 0.0 && v22 != 1.0;
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  if (v23)
  {
LABEL_37:
    __cxa_allocate_exception(0x48uLL);
    MIL::TextLocationFromScannerLocation(v4, v6);
  }
  return v15;
}

void sub_20F477CB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,void *__p,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  if (a42 < 0) {
    operator delete(__p);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  uint64_t v46 = *(std::__shared_weak_count **)(v44 - 120);
  if (v46) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v46);
  }
  uint64_t v47 = *(std::__shared_weak_count **)(v44 - 136);
  if (v47)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v47);
    if ((v42 & 1) == 0) {
      goto LABEL_14;
    }
  }
  else if (!v42)
  {
LABEL_14:
    if (*(char *)(v44 - 89) < 0) {
      operator delete(*(void **)(v44 - 112));
    }
    if (a23 < 0) {
      operator delete(a18);
    }
    _Unwind_Resume(exception_object);
  }
  __cxa_free_exception(v43);
  goto LABEL_14;
}

uint64_t MIL::Text::Parser::TensorVal::ParseToken<unsigned char>(uint64_t a1, MIL::Scanner::Token *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  std::string::basic_string[abi:ne180100]<0>(__p, "8 bit unsigned integer");
  uint64_t Options = MIL::ParserContext::GetOptions(*(MIL::ParserContext **)(a1 + 24));
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)Options + 24))(Options);
  if (v10 < 0) {
    operator delete(__p[0]);
  }
  return v7;
}

void sub_20F477F24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t anonymous namespace'::TokenToInt<unsigned char,unsigned short,unsigned long>(MIL::Scanner::Token *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (MIL::Scanner::Token::GetType(a1) != 18)
  {
    __cxa_allocate_exception(0x48uLL);
    MIL::TextLocationFromScannerLocation(a2, a4);
  }
  uint64_t ProgramFirstSet = MIL::ParserContext::GetProgramFirstSet(a1);
  std::string::size_type v8 = *(void *)(ProgramFirstSet + 8);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  uint8x8_t v9 = *(const void **)ProgramFirstSet;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    p_dst = (std::string *)operator new(v11 + 1);
    __dst.__r_.__value_.__l.__size_ = v8;
    __dst.__r_.__value_.__r.__words[2] = v12 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_9;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = *(void *)(ProgramFirstSet + 8);
  p_dst = &__dst;
  if (v8) {
LABEL_9:
  }
    memmove(p_dst, v9, v8);
  p_dst->__r_.__value_.__s.__data_[v8] = 0;
  int BaseAndPrepIntStringForParse = MIL::Util::GetBaseAndPrepIntStringForParse(&__dst);
  unsigned int v14 = (unsigned __int16)std::stoul(&__dst, 0, BaseAndPrepIntStringForParse);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  if (v14 > 0xFF)
  {
    uint64_t v16 = MIL::ParserContext::GetProgramFirstSet(a1);
    std::string::basic_string<std::string_view,0>(&__dst, v16);
    __cxa_allocate_exception(0x48uLL);
    MIL::TextLocationFromScannerLocation(a2, a4);
  }
  return v14;
}

void sub_20F4781CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,std::__shared_weak_count *a31,uint64_t a32,std::__shared_weak_count *a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  if (a33) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a33);
  }
  if (a31)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](a31);
    if ((v40 & 1) == 0) {
      goto LABEL_14;
    }
  }
  else if (!v40)
  {
LABEL_14:
    if (*(char *)(v42 - 89) < 0) {
      operator delete(*(void **)(v42 - 112));
    }
    _Unwind_Resume(exception_object);
  }
  __cxa_free_exception(v41);
  goto LABEL_14;
}

uint64_t MIL::Text::Parser::TensorVal::ParseToken<unsigned short>(uint64_t a1, MIL::Scanner::Token *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  std::string::basic_string[abi:ne180100]<0>(&__p, "16 bit unsigned integer");
  uint64_t Options = MIL::ParserContext::GetOptions(*(MIL::ParserContext **)(a1 + 24));
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)Options + 24))(Options);
  if (MIL::Scanner::Token::GetType(a2) != 18)
  {
    __cxa_allocate_exception(0x48uLL);
    MIL::TextLocationFromScannerLocation(v4, v6);
  }
  uint64_t ProgramFirstSet = MIL::ParserContext::GetProgramFirstSet(a2);
  std::string::size_type v8 = *(void *)(ProgramFirstSet + 8);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  uint8x8_t v9 = *(const void **)ProgramFirstSet;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    p_dst = (std::string *)operator new(v11 + 1);
    __dst.__r_.__value_.__l.__size_ = v8;
    __dst.__r_.__value_.__r.__words[2] = v12 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_9;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = *(void *)(ProgramFirstSet + 8);
  p_dst = &__dst;
  if (v8) {
LABEL_9:
  }
    memmove(p_dst, v9, v8);
  p_dst->__r_.__value_.__s.__data_[v8] = 0;
  int BaseAndPrepIntStringForParse = MIL::Util::GetBaseAndPrepIntStringForParse(&__dst);
  int v14 = std::stoul(&__dst, 0, BaseAndPrepIntStringForParse);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  if ((v14 & 0xFFFF0000) != 0)
  {
    uint64_t v16 = MIL::ParserContext::GetProgramFirstSet(a2);
    std::string::basic_string<std::string_view,0>(&__dst, v16);
    __cxa_allocate_exception(0x48uLL);
    MIL::TextLocationFromScannerLocation(v4, v6);
  }
  if (v18 < 0) {
    operator delete(__p);
  }
  return (unsigned __int16)v14;
}

void sub_20F4785F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,uint64_t a35,std::__shared_weak_count *a36)
{
  if (a33 < 0) {
    operator delete(__p);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  int v40 = *(std::__shared_weak_count **)(v38 - 104);
  if (v40) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v40);
  }
  if (a36)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](a36);
    if ((v36 & 1) == 0) {
      goto LABEL_14;
    }
  }
  else if (!v36)
  {
LABEL_14:
    if (*(char *)(v38 - 65) < 0) {
      operator delete(*(void **)(v38 - 88));
    }
    if (a14 < 0) {
      operator delete(a9);
    }
    _Unwind_Resume(exception_object);
  }
  __cxa_free_exception(v37);
  goto LABEL_14;
}

unint64_t MIL::Text::Parser::TensorVal::ParseToken<unsigned int>(uint64_t a1, MIL::Scanner::Token *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  std::string::basic_string[abi:ne180100]<0>(&__p, "32 bit unsigned integer");
  uint64_t Options = MIL::ParserContext::GetOptions(*(MIL::ParserContext **)(a1 + 24));
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)Options + 24))(Options);
  if (MIL::Scanner::Token::GetType(a2) != 18)
  {
    __cxa_allocate_exception(0x48uLL);
    MIL::TextLocationFromScannerLocation(v4, v6);
  }
  uint64_t ProgramFirstSet = MIL::ParserContext::GetProgramFirstSet(a2);
  std::string::size_type v8 = *(void *)(ProgramFirstSet + 8);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  uint8x8_t v9 = *(const void **)ProgramFirstSet;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    p_dst = (std::string *)operator new(v11 + 1);
    __dst.__r_.__value_.__l.__size_ = v8;
    __dst.__r_.__value_.__r.__words[2] = v12 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_9;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = *(void *)(ProgramFirstSet + 8);
  p_dst = &__dst;
  if (v8) {
LABEL_9:
  }
    memmove(p_dst, v9, v8);
  p_dst->__r_.__value_.__s.__data_[v8] = 0;
  int BaseAndPrepIntStringForParse = MIL::Util::GetBaseAndPrepIntStringForParse(&__dst);
  unint64_t v14 = std::stoull(&__dst, 0, BaseAndPrepIntStringForParse);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  if (HIDWORD(v14))
  {
    uint64_t v16 = MIL::ParserContext::GetProgramFirstSet(a2);
    std::string::basic_string<std::string_view,0>(&__dst, v16);
    __cxa_allocate_exception(0x48uLL);
    MIL::TextLocationFromScannerLocation(v4, v6);
  }
  if (v18 < 0) {
    operator delete(__p);
  }
  return v14;
}

void sub_20F478A38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,uint64_t a35,std::__shared_weak_count *a36)
{
  if (a33 < 0) {
    operator delete(__p);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  int v40 = *(std::__shared_weak_count **)(v38 - 104);
  if (v40) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v40);
  }
  if (a36)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](a36);
    if ((v36 & 1) == 0) {
      goto LABEL_14;
    }
  }
  else if (!v36)
  {
LABEL_14:
    if (*(char *)(v38 - 65) < 0) {
      operator delete(*(void **)(v38 - 88));
    }
    if (a14 < 0) {
      operator delete(a9);
    }
    _Unwind_Resume(exception_object);
  }
  __cxa_free_exception(v37);
  goto LABEL_14;
}

unint64_t MIL::Text::Parser::TensorVal::ParseToken<unsigned long long>(uint64_t a1, MIL::Scanner::Token *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  std::string::basic_string[abi:ne180100]<0>(&__p, "64 bit unsigned integer");
  uint64_t Options = MIL::ParserContext::GetOptions(*(MIL::ParserContext **)(a1 + 24));
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)Options + 24))(Options);
  if (MIL::Scanner::Token::GetType(a2) != 18)
  {
    __cxa_allocate_exception(0x48uLL);
    MIL::TextLocationFromScannerLocation(v4, v6);
  }
  uint64_t ProgramFirstSet = MIL::ParserContext::GetProgramFirstSet(a2);
  std::string::size_type v8 = *(void *)(ProgramFirstSet + 8);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  uint8x8_t v9 = *(const void **)ProgramFirstSet;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    p_dst = (std::string *)operator new(v11 + 1);
    __dst.__r_.__value_.__l.__size_ = v8;
    __dst.__r_.__value_.__r.__words[2] = v12 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_9;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = *(void *)(ProgramFirstSet + 8);
  p_dst = &__dst;
  if (v8) {
LABEL_9:
  }
    memmove(p_dst, v9, v8);
  p_dst->__r_.__value_.__s.__data_[v8] = 0;
  int BaseAndPrepIntStringForParse = MIL::Util::GetBaseAndPrepIntStringForParse(&__dst);
  unint64_t v14 = std::stoull(&__dst, 0, BaseAndPrepIntStringForParse);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  if (v17 < 0) {
    operator delete(__p);
  }
  return v14;
}

void sub_20F478E70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,uint64_t a35,std::__shared_weak_count *a36)
{
  if (a33 < 0) {
    operator delete(__p);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  int v40 = *(std::__shared_weak_count **)(v38 - 104);
  if (v40) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v40);
  }
  if (a36)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](a36);
    if ((v36 & 1) == 0) {
      goto LABEL_14;
    }
  }
  else if (!v36)
  {
LABEL_14:
    if (*(char *)(v38 - 65) < 0) {
      operator delete(*(void **)(v38 - 88));
    }
    if (a14 < 0) {
      operator delete(a9);
    }
    _Unwind_Resume(exception_object);
  }
  __cxa_free_exception(v37);
  goto LABEL_14;
}

uint64_t MIL::Text::Parser::TensorVal::ParseToken<MIL::UInt1>(uint64_t a1, MIL::Scanner::Token *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  std::string::basic_string[abi:ne180100]<0>(__p, "1 bit unsigned integer");
  uint64_t Options = MIL::ParserContext::GetOptions(*(MIL::ParserContext **)(a1 + 24));
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)Options + 24))(Options);
  MIL::UInt1::UInt1((MIL::UInt1 *)&v11, v7);
  if (v10 < 0) {
    operator delete(__p[0]);
  }
  return v11;
}

void sub_20F479080(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::Text::Parser::TensorVal::ParseToken<MIL::UInt2>(uint64_t a1, MIL::Scanner::Token *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  std::string::basic_string[abi:ne180100]<0>(__p, "2 bit unsigned integer");
  uint64_t Options = MIL::ParserContext::GetOptions(*(MIL::ParserContext **)(a1 + 24));
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)Options + 24))(Options);
  MIL::UInt2::UInt2((MIL::UInt2 *)&v11, v7);
  if (v10 < 0) {
    operator delete(__p[0]);
  }
  return v11;
}

void sub_20F479144(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::Text::Parser::TensorVal::ParseToken<MIL::UInt3>(uint64_t a1, MIL::Scanner::Token *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  std::string::basic_string[abi:ne180100]<0>(__p, "3 bit unsigned integer");
  uint64_t Options = MIL::ParserContext::GetOptions(*(MIL::ParserContext **)(a1 + 24));
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)Options + 24))(Options);
  MIL::UInt3::UInt3((MIL::UInt3 *)&v11, v7);
  if (v10 < 0) {
    operator delete(__p[0]);
  }
  return v11;
}

void sub_20F479208(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::Text::Parser::TensorVal::ParseToken<MIL::UInt4>(uint64_t a1, MIL::Scanner::Token *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  std::string::basic_string[abi:ne180100]<0>(__p, "4 bit unsigned integer");
  uint64_t Options = MIL::ParserContext::GetOptions(*(MIL::ParserContext **)(a1 + 24));
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)Options + 24))(Options);
  MIL::UInt4::UInt4((MIL::UInt4 *)&v11, v7);
  if (v10 < 0) {
    operator delete(__p[0]);
  }
  return v11;
}

void sub_20F4792CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::Text::Parser::TensorVal::ParseToken<MIL::UInt6>(uint64_t a1, MIL::Scanner::Token *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  std::string::basic_string[abi:ne180100]<0>(__p, "6 bit unsigned integer");
  uint64_t Options = MIL::ParserContext::GetOptions(*(MIL::ParserContext **)(a1 + 24));
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)Options + 24))(Options);
  MIL::UInt6::UInt6((MIL::UInt6 *)&v11, v7);
  if (v10 < 0) {
    operator delete(__p[0]);
  }
  return v11;
}

void sub_20F479390(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::Text::Parser::TensorVal::ParseToken<MIL::Int4>(uint64_t a1, MIL::Scanner::Token *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  std::string::basic_string[abi:ne180100]<0>(__p, "4 bit integer");
  uint64_t Options = MIL::ParserContext::GetOptions(*(MIL::ParserContext **)(a1 + 24));
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)Options + 24))(Options);
  MIL::Int4::Int4((MIL::Int4 *)&v11, v7);
  if (v10 < 0) {
    operator delete(__p[0]);
  }
  return v11;
}

void sub_20F479454(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t anonymous namespace'::TokenToInt<signed char,short,int>(MIL::Scanner::Token *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (MIL::Scanner::Token::GetType(a1) != 18)
  {
    __cxa_allocate_exception(0x48uLL);
    MIL::TextLocationFromScannerLocation(a2, a4);
  }
  uint64_t ProgramFirstSet = MIL::ParserContext::GetProgramFirstSet(a1);
  std::string::size_type v8 = *(void *)(ProgramFirstSet + 8);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  uint8x8_t v9 = *(const void **)ProgramFirstSet;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    p_dst = (std::string *)operator new(v11 + 1);
    __dst.__r_.__value_.__l.__size_ = v8;
    __dst.__r_.__value_.__r.__words[2] = v12 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_9;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = *(void *)(ProgramFirstSet + 8);
  p_dst = &__dst;
  if (v8) {
LABEL_9:
  }
    memmove(p_dst, v9, v8);
  p_dst->__r_.__value_.__s.__data_[v8] = 0;
  int BaseAndPrepIntStringForParse = MIL::Util::GetBaseAndPrepIntStringForParse(&__dst);
  __int16 v14 = std::stoi(&__dst, 0, BaseAndPrepIntStringForParse);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  if (v14 > 127 || v14 < -128)
  {
    uint64_t v16 = MIL::ParserContext::GetProgramFirstSet(a1);
    std::string::basic_string<std::string_view,0>(&__dst, v16);
    __cxa_allocate_exception(0x48uLL);
    MIL::TextLocationFromScannerLocation(a2, a4);
  }
  return (char)v14;
}

void sub_20F47970C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,std::__shared_weak_count *a31,uint64_t a32,std::__shared_weak_count *a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  if (a33) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a33);
  }
  if (a31)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](a31);
    if ((v40 & 1) == 0) {
      goto LABEL_14;
    }
  }
  else if (!v40)
  {
LABEL_14:
    if (*(char *)(v42 - 89) < 0) {
      operator delete(*(void **)(v42 - 112));
    }
    _Unwind_Resume(exception_object);
  }
  __cxa_free_exception(v41);
  goto LABEL_14;
}

uint64_t MIL::Text::Parser::TensorVal::ParseToken<signed char>(uint64_t a1, MIL::Scanner::Token *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  std::string::basic_string[abi:ne180100]<0>(__p, "8 bit integer");
  uint64_t Options = MIL::ParserContext::GetOptions(*(MIL::ParserContext **)(a1 + 24));
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)Options + 24))(Options);
  if (v10 < 0) {
    operator delete(__p[0]);
  }
  return v7;
}

void sub_20F4798FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::Text::Parser::TensorVal::ParseToken<short>(uint64_t a1, MIL::Scanner::Token *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  std::string::basic_string[abi:ne180100]<0>(&__p, "16 bit integer");
  uint64_t Options = MIL::ParserContext::GetOptions(*(MIL::ParserContext **)(a1 + 24));
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)Options + 24))(Options);
  if (MIL::Scanner::Token::GetType(a2) != 18)
  {
    __cxa_allocate_exception(0x48uLL);
    MIL::TextLocationFromScannerLocation(v4, v6);
  }
  uint64_t ProgramFirstSet = MIL::ParserContext::GetProgramFirstSet(a2);
  std::string::size_type v8 = *(void *)(ProgramFirstSet + 8);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  uint8x8_t v9 = *(const void **)ProgramFirstSet;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    p_dst = (std::string *)operator new(v11 + 1);
    __dst.__r_.__value_.__l.__size_ = v8;
    __dst.__r_.__value_.__r.__words[2] = v12 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_9;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = *(void *)(ProgramFirstSet + 8);
  p_dst = &__dst;
  if (v8) {
LABEL_9:
  }
    memmove(p_dst, v9, v8);
  p_dst->__r_.__value_.__s.__data_[v8] = 0;
  int BaseAndPrepIntStringForParse = MIL::Util::GetBaseAndPrepIntStringForParse(&__dst);
  int v14 = std::stoi(&__dst, 0, BaseAndPrepIntStringForParse);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  if (v14 >= 0x8000 || v14 < -32768)
  {
    uint64_t v16 = MIL::ParserContext::GetProgramFirstSet(a2);
    std::string::basic_string<std::string_view,0>(&__dst, v16);
    __cxa_allocate_exception(0x48uLL);
    MIL::TextLocationFromScannerLocation(v4, v6);
  }
  if (v18 < 0) {
    operator delete(__p);
  }
  return (__int16)v14;
}

void sub_20F479BF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,uint64_t a35,std::__shared_weak_count *a36)
{
  if (a33 < 0) {
    operator delete(__p);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  int v40 = *(std::__shared_weak_count **)(v38 - 104);
  if (v40) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v40);
  }
  if (a36)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](a36);
    if ((v36 & 1) == 0) {
      goto LABEL_14;
    }
  }
  else if (!v36)
  {
LABEL_14:
    if (*(char *)(v38 - 65) < 0) {
      operator delete(*(void **)(v38 - 88));
    }
    if (a14 < 0) {
      operator delete(a9);
    }
    _Unwind_Resume(exception_object);
  }
  __cxa_free_exception(v37);
  goto LABEL_14;
}

uint64_t MIL::Text::Parser::TensorVal::ParseToken<int>(uint64_t a1, MIL::Scanner::Token *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  std::string::basic_string[abi:ne180100]<0>(&__p, "32 bit integer");
  uint64_t Options = MIL::ParserContext::GetOptions(*(MIL::ParserContext **)(a1 + 24));
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)Options + 24))(Options);
  if (MIL::Scanner::Token::GetType(a2) != 18)
  {
    __cxa_allocate_exception(0x48uLL);
    MIL::TextLocationFromScannerLocation(v4, v6);
  }
  uint64_t ProgramFirstSet = MIL::ParserContext::GetProgramFirstSet(a2);
  std::string::size_type v8 = *(void *)(ProgramFirstSet + 8);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  uint8x8_t v9 = *(const void **)ProgramFirstSet;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    p_dst = (std::string *)operator new(v11 + 1);
    __dst.__r_.__value_.__l.__size_ = v8;
    __dst.__r_.__value_.__r.__words[2] = v12 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_9;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = *(void *)(ProgramFirstSet + 8);
  p_dst = &__dst;
  if (v8) {
LABEL_9:
  }
    memmove(p_dst, v9, v8);
  p_dst->__r_.__value_.__s.__data_[v8] = 0;
  int BaseAndPrepIntStringForParse = MIL::Util::GetBaseAndPrepIntStringForParse(&__dst);
  uint64_t v14 = std::stoll(&__dst, 0, BaseAndPrepIntStringForParse);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  if (v14 > 0x7FFFFFFF || v14 < (uint64_t)0xFFFFFFFF80000000)
  {
    uint64_t v16 = MIL::ParserContext::GetProgramFirstSet(a2);
    std::string::basic_string<std::string_view,0>(&__dst, v16);
    __cxa_allocate_exception(0x48uLL);
    MIL::TextLocationFromScannerLocation(v4, v6);
  }
  if (v18 < 0) {
    operator delete(__p);
  }
  return v14;
}

void sub_20F47A048(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,uint64_t a35,std::__shared_weak_count *a36)
{
  if (a33 < 0) {
    operator delete(__p);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  int v40 = *(std::__shared_weak_count **)(v38 - 104);
  if (v40) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v40);
  }
  if (a36)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](a36);
    if ((v36 & 1) == 0) {
      goto LABEL_14;
    }
  }
  else if (!v36)
  {
LABEL_14:
    if (*(char *)(v38 - 65) < 0) {
      operator delete(*(void **)(v38 - 88));
    }
    if (a14 < 0) {
      operator delete(a9);
    }
    _Unwind_Resume(exception_object);
  }
  __cxa_free_exception(v37);
  goto LABEL_14;
}

uint64_t MIL::Text::Parser::TensorVal::ParseToken<long long>(uint64_t a1, MIL::Scanner::Token *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  std::string::basic_string[abi:ne180100]<0>(&__p, "64 bit integer");
  uint64_t Options = MIL::ParserContext::GetOptions(*(MIL::ParserContext **)(a1 + 24));
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)Options + 24))(Options);
  if (MIL::Scanner::Token::GetType(a2) != 18)
  {
    __cxa_allocate_exception(0x48uLL);
    MIL::TextLocationFromScannerLocation(v4, v6);
  }
  uint64_t ProgramFirstSet = MIL::ParserContext::GetProgramFirstSet(a2);
  std::string::size_type v8 = *(void *)(ProgramFirstSet + 8);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  uint8x8_t v9 = *(const void **)ProgramFirstSet;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    p_dst = (std::string *)operator new(v11 + 1);
    __dst.__r_.__value_.__l.__size_ = v8;
    __dst.__r_.__value_.__r.__words[2] = v12 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_9;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = *(void *)(ProgramFirstSet + 8);
  p_dst = &__dst;
  if (v8) {
LABEL_9:
  }
    memmove(p_dst, v9, v8);
  p_dst->__r_.__value_.__s.__data_[v8] = 0;
  int BaseAndPrepIntStringForParse = MIL::Util::GetBaseAndPrepIntStringForParse(&__dst);
  uint64_t v14 = std::stoll(&__dst, 0, BaseAndPrepIntStringForParse);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  if (v17 < 0) {
    operator delete(__p);
  }
  return v14;
}

void sub_20F47A478(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,uint64_t a35,std::__shared_weak_count *a36)
{
  if (a33 < 0) {
    operator delete(__p);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  int v40 = *(std::__shared_weak_count **)(v38 - 104);
  if (v40) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v40);
  }
  if (a36)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](a36);
    if ((v36 & 1) == 0) {
      goto LABEL_14;
    }
  }
  else if (!v36)
  {
LABEL_14:
    if (*(char *)(v38 - 65) < 0) {
      operator delete(*(void **)(v38 - 88));
    }
    if (a14 < 0) {
      operator delete(a9);
    }
    _Unwind_Resume(exception_object);
  }
  __cxa_free_exception(v37);
  goto LABEL_14;
}

void MIL::Text::Parser::TensorVal::ParseToken<std::string>(MIL::Scanner::Token *this@<X1>, uint64_t a2@<X0>, std::string *a3@<X8>)
{
  if (MIL::Scanner::Token::GetType(this) != 20)
  {
    __cxa_allocate_exception(0x48uLL);
    uint64_t v23 = *(void *)(a2 + 32);
    uint64_t Options = MIL::ParserContext::GetOptions(*(MIL::ParserContext **)(a2 + 24));
    uint64_t v25 = (*(uint64_t (**)(uint64_t))(*(void *)Options + 24))(Options);
    MIL::TextLocationFromScannerLocation(v23, v25);
  }
  uint64_t ProgramFirstSet = MIL::ParserContext::GetProgramFirstSet(this);
  std::string::size_type v7 = *(void *)(ProgramFirstSet + 8);
  if (v7 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  std::string::size_type v8 = *(const void **)ProgramFirstSet;
  if (v7 >= 0x17)
  {
    uint64_t v10 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17) {
      uint64_t v10 = v7 | 7;
    }
    uint64_t v11 = v10 + 1;
    p_dst = (std::string *)operator new(v10 + 1);
    __dst.__r_.__value_.__l.__size_ = v7;
    __dst.__r_.__value_.__r.__words[2] = v11 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_9;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = *(void *)(ProgramFirstSet + 8);
  p_dst = &__dst;
  if (v7) {
LABEL_9:
  }
    memmove(p_dst, v8, v7);
  p_dst->__r_.__value_.__s.__data_[v7] = 0;
  int v12 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&v26, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
  }
  else {
    std::string v26 = __dst;
  }
  if ((SHIBYTE(v26.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    std::string::size_type size = HIBYTE(v26.__r_.__value_.__r.__words[2]);
    if (HIBYTE(v26.__r_.__value_.__r.__words[2]) > 1u)
    {
      uint64_t v14 = &v26.__r_.__value_.__s.__data_[1];
      BOOL v15 = &v26;
      goto LABEL_20;
    }
LABEL_17:
    *a3 = v26;
    memset(&v26, 0, sizeof(v26));
    if ((v12 & 0x80000000) == 0) {
      return;
    }
    goto LABEL_30;
  }
  std::string::size_type size = v26.__r_.__value_.__l.__size_;
  if (v26.__r_.__value_.__l.__size_ < 2) {
    goto LABEL_17;
  }
  BOOL v15 = (std::string *)v26.__r_.__value_.__r.__words[0];
  uint64_t v14 = (char *)(v26.__r_.__value_.__r.__words[0] + 1);
LABEL_20:
  std::string::__init_with_size[abi:ne180100]<char *,char *>(a3, v14, (char *)v15 + size - 1, (char *)v15 + size - 1 - v14);
  std::string::size_type v16 = HIBYTE(a3->__r_.__value_.__r.__words[2]);
  if ((v16 & 0x80u) == 0) {
    char v17 = a3;
  }
  else {
    char v17 = (std::string *)a3->__r_.__value_.__r.__words[0];
  }
  if ((v16 & 0x80u) != 0) {
    std::string::size_type v16 = a3->__r_.__value_.__l.__size_;
  }
  unsigned __int8 v28 = 92;
  char v18 = std::remove[abi:ne180100]<std::__wrap_iter<char *>,char>(v17, (unsigned __int8 *)v17 + v16, &v28);
  uint64_t v19 = HIBYTE(a3->__r_.__value_.__r.__words[2]);
  int v20 = (char)v19;
  std::string::size_type v21 = (std::string::size_type)a3 + v19;
  if (v20 >= 0)
  {
    std::string::size_type v22 = (std::string::size_type)a3;
  }
  else
  {
    std::string::size_type v21 = a3->__r_.__value_.__r.__words[0] + a3->__r_.__value_.__l.__size_;
    std::string::size_type v22 = a3->__r_.__value_.__r.__words[0];
  }
  std::string::erase(a3, (std::string::size_type)&v18[-v22], v21 - (void)v18);
  if ((SHIBYTE(v26.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v12 & 0x80000000) == 0) {
      return;
    }
    goto LABEL_30;
  }
  operator delete(v26.__r_.__value_.__l.__data_);
  if (v12 < 0) {
LABEL_30:
  }
    operator delete(__dst.__r_.__value_.__l.__data_);
}

void sub_20F47A868(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,std::__shared_weak_count *a26)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a17) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a17);
  }
  if (a26)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](a26);
    if ((v27 & 1) == 0) {
      goto LABEL_10;
    }
  }
  else if (!v27)
  {
LABEL_10:
    _Unwind_Resume(exception_object);
  }
  __cxa_free_exception(v26);
  goto LABEL_10;
}

void MIL::Text::Parser::TensorVal::ParseTokens<BOOL,unsigned char>(uint64_t a1@<X0>, MIL::Scanner::Token **a2@<X1>, unint64_t *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  std::vector<unsigned char>::reserve(a3, (a2[1] - *a2) >> 5);
  uint64_t v6 = *a2;
  std::string::size_type v7 = a2[1];
  if (*a2 != v7)
  {
    do
    {
      BOOL v8 = MIL::Text::Parser::TensorVal::ParseToken<BOOL>(a1, v6);
      BOOL v9 = v8;
      uint64_t v11 = (unsigned char *)a3[1];
      unint64_t v10 = a3[2];
      if ((unint64_t)v11 >= v10)
      {
        unint64_t v13 = *a3;
        uint64_t v14 = &v11[-*a3];
        unint64_t v15 = (unint64_t)(v14 + 1);
        if ((uint64_t)(v14 + 1) < 0) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v16 = v10 - v13;
        if (2 * v16 > v15) {
          unint64_t v15 = 2 * v16;
        }
        if (v16 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v17 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v17 = v15;
        }
        if (v17) {
          char v18 = (char *)operator new(v17);
        }
        else {
          char v18 = 0;
        }
        uint64_t v19 = &v14[(void)v18];
        int v20 = &v14[(void)v18];
        *int v20 = v9;
        int v12 = v20 + 1;
        if (v11 != (unsigned char *)v13)
        {
          std::string::size_type v21 = &v11[~v13];
          do
          {
            char v22 = *--v11;
            (v21--)[(void)v18] = v22;
          }
          while (v11 != (unsigned char *)v13);
          uint64_t v11 = (unsigned char *)*a3;
          uint64_t v19 = v18;
        }
        *a3 = (unint64_t)v19;
        a3[1] = (unint64_t)v12;
        a3[2] = (unint64_t)&v18[v17];
        if (v11) {
          operator delete(v11);
        }
      }
      else
      {
        *uint64_t v11 = v8;
        int v12 = v11 + 1;
      }
      a3[1] = (unint64_t)v12;
      uint64_t v6 = (MIL::Scanner::Token *)((char *)v6 + 32);
    }
    while (v6 != v7);
  }
}

void sub_20F47AA54(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void MIL::Text::Parser::TensorVal::ParseScalar(MIL::Text::Parser::TensorVal *this, const MIL::IRTensorValueType *a2)
{
  uint64_t v4 = *((void *)this + 4);
  uint64_t Options = MIL::ParserContext::GetOptions(*((MIL::ParserContext **)this + 3));
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)Options + 24))(Options);
  if (MIL::IRTensorValueType::IsScalar(a2))
  {
    switch((*(unsigned int (**)(const MIL::IRTensorValueType *))(*(void *)a2 + 88))(a2))
    {
      case 2u:
        (*(void (**)(std::string *__return_ptr))(**((void **)this + 2) + 16))(&v39);
        BOOL v7 = MIL::Text::Parser::TensorVal::ParseToken<BOOL>((uint64_t)this, (MIL::Scanner::Token *)&v39);
        MIL::IRTensorValueType::MakeBoolValue(a2, (const MIL::IRTensorValueType *)v7);
      case 3u:
        (*(void (**)(std::string *__return_ptr))(**((void **)this + 2) + 16))(&v39);
        MIL::Text::Parser::TensorVal::ParseToken<std::string>((MIL::Scanner::Token *)&v39, (uint64_t)this, &v36);
        MIL::IRTensorValueType::MakeStringValue(a2, (const MIL::IRTensorValueType *)&v36);
      case 4u:
        (*(void (**)(std::string *__return_ptr))(**((void **)this + 2) + 16))(&v39);
        unsigned __int16 v31 = MIL::Text::Parser::TensorVal::ParseToken<MIL::Fp16>((uint64_t)this, (MIL::Scanner::Token *)&v39);
        MIL::IRTensorValueType::MakeFloat16Value(a2, (const MIL::IRTensorValueType *)v31);
      case 5u:
        (*(void (**)(std::string *__return_ptr))(**((void **)this + 2) + 16))(&v39);
        float v22 = MIL::Text::Parser::TensorVal::ParseToken<float>((uint64_t)this, (MIL::Scanner::Token *)&v39);
        MIL::IRTensorValueType::MakeFloat32Value(a2, v22, v23);
      case 6u:
        (*(void (**)(std::string *__return_ptr))(**((void **)this + 2) + 16))(&v39);
        double v29 = MIL::Text::Parser::TensorVal::ParseToken<double>((uint64_t)this, (MIL::Scanner::Token *)&v39);
        MIL::IRTensorValueType::MakeFloat64Value(a2, v29, v30);
      case 7u:
        (*(void (**)(std::string *__return_ptr))(**((void **)this + 2) + 16))(&v39);
        unsigned __int16 v33 = MIL::Text::Parser::TensorVal::ParseToken<MIL::Bf16>((uint64_t)this, (MIL::Scanner::Token *)&v39);
        MIL::IRTensorValueType::MakeBFloat16Value(a2, (const MIL::IRTensorValueType *)v33);
      case 9u:
        (*(void (**)(std::string *__return_ptr))(**((void **)this + 2) + 16))(&v39);
        unint64_t v16 = (const MIL::IRTensorValueType *)MIL::Text::Parser::TensorVal::ParseToken<signed char>((uint64_t)this, (MIL::Scanner::Token *)&v39);
        MIL::IRTensorValueType::MakeInt8Value(a2, v16);
      case 0xAu:
        (*(void (**)(std::string *__return_ptr))(**((void **)this + 2) + 16))(&v39);
        uint64_t v32 = (const MIL::IRTensorValueType *)MIL::Text::Parser::TensorVal::ParseToken<short>((uint64_t)this, (MIL::Scanner::Token *)&v39);
        MIL::IRTensorValueType::MakeInt16Value(a2, v32);
      case 0xBu:
        (*(void (**)(std::string *__return_ptr))(**((void **)this + 2) + 16))(&v39);
        size_t v17 = (const MIL::IRTensorValueType *)MIL::Text::Parser::TensorVal::ParseToken<int>((uint64_t)this, (MIL::Scanner::Token *)&v39);
        MIL::IRTensorValueType::MakeInt32Value(a2, v17);
      case 0xCu:
        (*(void (**)(std::string *__return_ptr))(**((void **)this + 2) + 16))(&v39);
        unint64_t v10 = (const MIL::IRTensorValueType *)MIL::Text::Parser::TensorVal::ParseToken<long long>((uint64_t)this, (MIL::Scanner::Token *)&v39);
        MIL::IRTensorValueType::MakeInt64Value(a2, v10);
      case 0xDu:
        (*(void (**)(std::string *__return_ptr))(**((void **)this + 2) + 16))(&v39);
        char v14 = MIL::Text::Parser::TensorVal::ParseToken<MIL::Int4>((uint64_t)this, (MIL::Scanner::Token *)&v39);
        unint64_t v15 = operator new(1uLL);
        v37.__r_.__value_.__r.__words[0] = (std::string::size_type)v15;
        unsigned char *v15 = v14;
        v37.__r_.__value_.__l.__size_ = (std::string::size_type)(v15 + 1);
        v37.__r_.__value_.__r.__words[2] = (std::string::size_type)(v15 + 1);
        MIL::PackSubByteVec((uint64_t *)&v37, &__p);
        MIL::IRTensorValueType::MakeInt4Value(a2, (const MIL::IRTensorValueType *)*(unsigned __int8 *)__p);
      case 0xEu:
        (*(void (**)(std::string *__return_ptr))(**((void **)this + 2) + 16))(&v39);
        BOOL v8 = (const MIL::IRTensorValueType *)MIL::Text::Parser::TensorVal::ParseToken<unsigned char>((uint64_t)this, (MIL::Scanner::Token *)&v39);
        MIL::IRTensorValueType::MakeUInt8Value(a2, v8);
      case 0xFu:
        (*(void (**)(std::string *__return_ptr))(**((void **)this + 2) + 16))(&v39);
        unint64_t v13 = (const MIL::IRTensorValueType *)MIL::Text::Parser::TensorVal::ParseToken<unsigned short>((uint64_t)this, (MIL::Scanner::Token *)&v39);
        MIL::IRTensorValueType::MakeUInt16Value(a2, v13);
      case 0x10u:
        (*(void (**)(std::string *__return_ptr))(**((void **)this + 2) + 16))(&v39);
        char v18 = (const MIL::IRTensorValueType *)MIL::Text::Parser::TensorVal::ParseToken<unsigned int>((uint64_t)this, (MIL::Scanner::Token *)&v39);
        MIL::IRTensorValueType::MakeUInt32Value(a2, v18);
      case 0x11u:
        (*(void (**)(std::string *__return_ptr))(**((void **)this + 2) + 16))(&v39);
        int v24 = (const MIL::IRTensorValueType *)MIL::Text::Parser::TensorVal::ParseToken<unsigned long long>((uint64_t)this, (MIL::Scanner::Token *)&v39);
        MIL::IRTensorValueType::MakeUInt64Value(a2, v24);
      case 0x13u:
        (*(void (**)(std::string *__return_ptr))(**((void **)this + 2) + 16))(&v39);
        char v27 = MIL::Text::Parser::TensorVal::ParseToken<MIL::UInt2>((uint64_t)this, (MIL::Scanner::Token *)&v39);
        unsigned __int8 v28 = operator new(1uLL);
        v37.__r_.__value_.__r.__words[0] = (std::string::size_type)v28;
        unsigned char *v28 = v27;
        v37.__r_.__value_.__l.__size_ = (std::string::size_type)(v28 + 1);
        v37.__r_.__value_.__r.__words[2] = (std::string::size_type)(v28 + 1);
        MIL::PackSubByteVec((uint64_t *)&v37, &__p);
        MIL::IRTensorValueType::MakeUInt2Value(a2, (const MIL::IRTensorValueType *)*(unsigned __int8 *)__p);
      case 0x14u:
        (*(void (**)(std::string *__return_ptr))(**((void **)this + 2) + 16))(&v39);
        char v25 = MIL::Text::Parser::TensorVal::ParseToken<MIL::UInt4>((uint64_t)this, (MIL::Scanner::Token *)&v39);
        std::string v26 = operator new(1uLL);
        v37.__r_.__value_.__r.__words[0] = (std::string::size_type)v26;
        unsigned char *v26 = v25;
        v37.__r_.__value_.__l.__size_ = (std::string::size_type)(v26 + 1);
        v37.__r_.__value_.__r.__words[2] = (std::string::size_type)(v26 + 1);
        MIL::PackSubByteVec((uint64_t *)&v37, &__p);
        MIL::IRTensorValueType::MakeUInt4Value(a2, (const MIL::IRTensorValueType *)*(unsigned __int8 *)__p);
      case 0x15u:
        (*(void (**)(std::string *__return_ptr))(**((void **)this + 2) + 16))(&v39);
        char v19 = MIL::Text::Parser::TensorVal::ParseToken<MIL::UInt1>((uint64_t)this, (MIL::Scanner::Token *)&v39);
        int v20 = operator new(1uLL);
        v37.__r_.__value_.__r.__words[0] = (std::string::size_type)v20;
        *int v20 = v19;
        v37.__r_.__value_.__l.__size_ = (std::string::size_type)(v20 + 1);
        v37.__r_.__value_.__r.__words[2] = (std::string::size_type)(v20 + 1);
        MIL::PackSubByteVec((uint64_t *)&v37, &__p);
        MIL::IRTensorValueType::MakeUInt1Value(a2, (const MIL::IRTensorValueType *)*(unsigned __int8 *)__p);
      case 0x16u:
        (*(void (**)(std::string *__return_ptr))(**((void **)this + 2) + 16))(&v39);
        char v34 = MIL::Text::Parser::TensorVal::ParseToken<MIL::UInt3>((uint64_t)this, (MIL::Scanner::Token *)&v39);
        uint64_t v35 = operator new(1uLL);
        v37.__r_.__value_.__r.__words[0] = (std::string::size_type)v35;
        *uint64_t v35 = v34;
        v37.__r_.__value_.__l.__size_ = (std::string::size_type)(v35 + 1);
        v37.__r_.__value_.__r.__words[2] = (std::string::size_type)(v35 + 1);
        MIL::PackSubByteVec((unsigned __int8 **)&v37, &__p);
        MIL::IRTensorValueType::MakeUInt3Value(a2, (const MIL::IRTensorValueType *)*(unsigned __int8 *)__p);
      case 0x17u:
        (*(void (**)(std::string *__return_ptr))(**((void **)this + 2) + 16))(&v39);
        char v11 = MIL::Text::Parser::TensorVal::ParseToken<MIL::UInt6>((uint64_t)this, (MIL::Scanner::Token *)&v39);
        int v12 = operator new(1uLL);
        v37.__r_.__value_.__r.__words[0] = (std::string::size_type)v12;
        *int v12 = v11;
        v37.__r_.__value_.__l.__size_ = (std::string::size_type)(v12 + 1);
        v37.__r_.__value_.__r.__words[2] = (std::string::size_type)(v12 + 1);
        MIL::PackSubByteVec((unsigned __int8 **)&v37, &__p);
        MIL::IRTensorValueType::MakeUInt6Value(a2, (const MIL::IRTensorValueType *)*(unsigned __int8 *)__p);
      case 0x18u:
        (*(void (**)(std::string *__return_ptr))(**((void **)this + 2) + 16))(&v39);
        unsigned __int8 v9 = MIL::Text::Parser::TensorVal::ParseToken<MIL::Fp8E4M3FN>((uint64_t)this, (MIL::Scanner::Token *)&v39);
        MIL::IRTensorValueType::MakeFloat8E4M3FNValue(a2, (const MIL::IRTensorValueType *)v9);
      case 0x19u:
        (*(void (**)(std::string *__return_ptr))(**((void **)this + 2) + 16))(&v39);
        unsigned __int8 v21 = MIL::Text::Parser::TensorVal::ParseToken<MIL::Fp8E5M2>((uint64_t)this, (MIL::Scanner::Token *)&v39);
        MIL::IRTensorValueType::MakeFloat8E5M2Value(a2, (const MIL::IRTensorValueType *)v21);
      default:
        __cxa_allocate_exception(0x48uLL);
        MIL::TextLocationFromScannerLocation(v4, v6);
    }
  }
  __cxa_allocate_exception(0x48uLL);
  MIL::TextLocationFromScannerLocation(v4, v6);
}

void sub_20F47B4D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,std::__shared_weak_count *a24,uint64_t a25,std::__shared_weak_count *a26,uint64_t a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  if (*(char *)(v46 - 121) < 0) {
    operator delete(*(void **)(v46 - 144));
  }
  if (a44 < 0) {
    operator delete(a39);
  }
  if (a38 < 0) {
    operator delete(a33);
  }
  if (a26) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a26);
  }
  if (a24)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](a24);
    if ((v45 & 1) == 0) {
LABEL_18:
    }
      _Unwind_Resume(a1);
  }
  else if (!v45)
  {
    goto LABEL_18;
  }
  __cxa_free_exception(v44);
  goto LABEL_18;
}

void MIL::Text::Parser::TensorVal::ParseDim(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  v56[2] = *MEMORY[0x263EF8340];
  MIL::Text::Parser::Rule<MIL::Text::Parser::Program,std::unique_ptr<MIL::IRProgram>>::Expect(a1, 3);
  UnknownLocationImpl::~UnknownLocationImpl((UnknownLocationImpl *)v52);
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  uint64_t v6 = operator new(0x14uLL);
  v6[4] = 22;
  *(_OWORD *)uint64_t v6 = xmmword_20F91692C;
  long long v49 = 0;
  v50 = 0;
  uint64_t v51 = 0;
  std::vector<MIL::Scanner::TokenType>::__init_with_size[abi:ne180100]<MIL::Scanner::TokenType*,MIL::Scanner::TokenType*>(&v49, v6, (uint64_t)(v6 + 5), 5uLL);
  BOOL v7 = (MIL::Scanner::Token *)(*(uint64_t (**)(void))(**(void **)(a1 + 16) + 24))(*(void *)(a1 + 16));
  if (MIL::Scanner::Token::GetType(v7) == 3)
  {
    uint64_t v53 = 0;
    v54[0] = 0;
    v54[1] = 0;
    MIL::Text::Parser::TensorVal::ParseDim(&__p, a1, a2);
    std::vector<std::vector<unsigned long>>::push_back[abi:ne180100](&v53, (uint64_t)&__p);
    if (__p)
    {
      uint64_t v47 = __p;
      operator delete(__p);
    }
    for (uint64_t i = 1; ; ++i)
    {
      unsigned __int8 v9 = (MIL::Scanner::Token *)(*(uint64_t (**)(void))(**(void **)(a1 + 16) + 24))(*(void *)(a1 + 16));
      if (MIL::Scanner::Token::GetType(v9) != 9) {
        break;
      }
      (*(void (**)(void **__return_ptr))(**(void **)(a1 + 16) + 16))(v45);
      UnknownLocationImpl::~UnknownLocationImpl((UnknownLocationImpl *)v45);
      MIL::Text::Parser::TensorVal::ParseDim(&__p, a1, a2);
      std::vector<std::vector<unsigned long>>::push_back[abi:ne180100](&v53, (uint64_t)&__p);
      if (__p)
      {
        uint64_t v47 = __p;
        operator delete(__p);
      }
    }
    uint64_t v47 = 0;
    uint64_t v48 = 0;
    std::string __p = 0;
    std::vector<unsigned long>::__init_with_size[abi:ne180100]<unsigned long *,unsigned long *>(&__p, *(const void **)v53, *(void *)(v53 + 8), (uint64_t)(*(void *)(v53 + 8) - *(void *)v53) >> 3);
    uint64_t v18 = v53;
    uint64_t v19 = v54[0];
    if (v53 != v54[0])
    {
      int v20 = __p;
      size_t v21 = v47 - (unsigned char *)__p;
      do
      {
        if (*(void *)(v18 + 8) - *(void *)v18 != v21 || memcmp(*(const void **)v18, v20, v21))
        {
          __cxa_allocate_exception(0x48uLL);
          uint64_t v37 = *(void *)(a1 + 32);
          uint64_t Options = MIL::ParserContext::GetOptions(*(MIL::ParserContext **)(a1 + 24));
          uint64_t v39 = (*(uint64_t (**)(uint64_t))(*(void *)Options + 24))(Options);
          MIL::TextLocationFromScannerLocation(v37, v39);
        }
        v18 += 24;
      }
      while (v18 != v19);
    }
    uint64_t __src = i;
    std::vector<unsigned long long>::__assign_with_size[abi:ne180100]<unsigned long long const*,unsigned long long const*>((char *)a3, (char *)&__src, (uint64_t)v56, 1uLL);
    float v22 = __p;
    uint64_t v23 = v47;
    if (__p != v47)
    {
      int v24 = (void *)(a3 + 16);
      char v25 = *(void **)(a3 + 8);
      do
      {
        uint64_t v26 = *v22;
        if ((unint64_t)v25 >= *v24)
        {
          unsigned __int8 v28 = *(void **)a3;
          uint64_t v29 = ((uint64_t)v25 - *(void *)a3) >> 3;
          unint64_t v30 = v29 + 1;
          if ((unint64_t)(v29 + 1) >> 61) {
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v31 = *v24 - (void)v28;
          if (v31 >> 2 > v30) {
            unint64_t v30 = v31 >> 2;
          }
          if ((unint64_t)v31 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v32 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v32 = v30;
          }
          if (v32)
          {
            unsigned __int16 v33 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>(a3 + 16, v32);
            unsigned __int8 v28 = *(void **)a3;
            char v25 = *(void **)(a3 + 8);
          }
          else
          {
            unsigned __int16 v33 = 0;
          }
          char v34 = &v33[8 * v29];
          *(void *)char v34 = v26;
          char v27 = v34 + 8;
          while (v25 != v28)
          {
            uint64_t v35 = *--v25;
            *((void *)v34 - 1) = v35;
            v34 -= 8;
          }
          *(void *)a3 = v34;
          *(void *)(a3 + 8) = v27;
          *(void *)(a3 + 16) = &v33[8 * v32];
          if (v28) {
            operator delete(v28);
          }
        }
        else
        {
          void *v25 = v26;
          char v27 = v25 + 1;
        }
        *(void *)(a3 + 8) = v27;
        ++v22;
        char v25 = v27;
      }
      while (v22 != v23);
      float v22 = __p;
    }
    if (v22)
    {
      uint64_t v47 = v22;
      operator delete(v22);
    }
    std::string __p = &v53;
    std::vector<std::vector<unsigned long long>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  }
  else
  {
    unint64_t v10 = (MIL::Scanner::Token *)(*(uint64_t (**)(void))(**(void **)(a1 + 16) + 24))(*(void *)(a1 + 16));
    int Type = MIL::Scanner::Token::GetType(v10);
    int v12 = v49;
    if (v49 != v50)
    {
      while (*v12 != Type)
      {
        if (++v12 == v50)
        {
          int v12 = v50;
          break;
        }
      }
    }
    if (v12 == v50)
    {
      std::string v36 = (MIL::Scanner::Token *)(*(uint64_t (**)(void))(**(void **)(a1 + 16) + 24))(*(void *)(a1 + 16));
      if (MIL::Scanner::Token::GetType(v36) == 4)
      {
        uint64_t v53 = 0;
        std::vector<unsigned long long>::__assign_with_size[abi:ne180100]<unsigned long long const*,unsigned long long const*>((char *)a3, (char *)&v53, (uint64_t)v54, 1uLL);
      }
    }
    else
    {
      (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 16) + 16))(&v53);
      std::vector<MIL::Scanner::Token>::push_back[abi:ne180100](a2, (uint64_t)&v53);
      UnknownLocationImpl::~UnknownLocationImpl((UnknownLocationImpl *)&v53);
      for (uint64_t j = 1; ; ++j)
      {
        char v14 = (MIL::Scanner::Token *)(*(uint64_t (**)(void))(**(void **)(a1 + 16) + 24))(*(void *)(a1 + 16));
        if (MIL::Scanner::Token::GetType(v14) != 9) {
          break;
        }
        (*(void (**)(void *__return_ptr))(**(void **)(a1 + 16) + 16))(v44);
        UnknownLocationImpl::~UnknownLocationImpl((UnknownLocationImpl *)v44);
        unint64_t v15 = (MIL::Scanner::Token *)(*(uint64_t (**)(void))(**(void **)(a1 + 16) + 24))(*(void *)(a1 + 16));
        int v16 = MIL::Scanner::Token::GetType(v15);
        size_t v17 = v49;
        if (v49 != v50)
        {
          while (*v17 != v16)
          {
            if (++v17 == v50)
            {
              size_t v17 = v50;
              break;
            }
          }
        }
        if (v17 == v50)
        {
          __cxa_allocate_exception(0x48uLL);
          uint64_t v40 = *(void *)(a1 + 32);
          uint64_t v41 = MIL::ParserContext::GetOptions(*(MIL::ParserContext **)(a1 + 24));
          uint64_t v42 = (*(uint64_t (**)(uint64_t))(*(void *)v41 + 24))(v41);
          MIL::TextLocationFromScannerLocation(v40, v42);
        }
        (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 16) + 16))(&v53);
        std::vector<MIL::Scanner::Token>::push_back[abi:ne180100](a2, (uint64_t)&v53);
        UnknownLocationImpl::~UnknownLocationImpl((UnknownLocationImpl *)&v53);
      }
      uint64_t v53 = j;
      std::vector<unsigned long long>::__assign_with_size[abi:ne180100]<unsigned long long const*,unsigned long long const*>((char *)a3, (char *)&v53, (uint64_t)v54, 1uLL);
    }
  }
  MIL::Text::Parser::Rule<MIL::Text::Parser::Program,std::unique_ptr<MIL::IRProgram>>::Expect(a1, 4);
  UnknownLocationImpl::~UnknownLocationImpl((UnknownLocationImpl *)v43);
  if (v49)
  {
    v50 = v49;
    operator delete(v49);
  }
  operator delete(v6);
}

void sub_20F47BE10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,uint64_t a41,void *__p,uint64_t a43)
{
  if (__p) {
    operator delete(__p);
  }
  operator delete(v44);
  uint64_t v46 = *(void **)v43;
  if (*(void *)v43)
  {
    *(void *)(v43 + 8) = v46;
    operator delete(v46);
  }
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::vector<unsigned long>>::push_back[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  BOOL v7 = *(void **)(result - 8);
  if ((unint64_t)v7 >= v6)
  {
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v7 - *a1) >> 3);
    unint64_t v10 = v9 + 1;
    if (v9 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 3);
    if (2 * v11 > v10) {
      unint64_t v10 = 2 * v11;
    }
    if (v11 >= 0x555555555555555) {
      unint64_t v12 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v12 = v10;
    }
    v16[4] = result;
    unint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(result, v12);
    char v14 = &v13[24 * v9];
    v16[0] = v13;
    v16[1] = v14;
    v16[3] = &v13[24 * v15];
    *((void *)v14 + 1) = 0;
    *((void *)v14 + 2) = 0;
    *(void *)char v14 = 0;
    *(_OWORD *)char v14 = *(_OWORD *)a2;
    *((void *)v14 + 2) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    void v16[2] = v14 + 24;
    std::vector<std::vector<unsigned long>>::__swap_out_circular_buffer(a1, v16);
    BOOL v8 = (void *)a1[1];
    uint64_t result = std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)v16);
  }
  else
  {
    *BOOL v7 = 0;
    v7[1] = 0;
    void v7[2] = 0;
    *(_OWORD *)BOOL v7 = *(_OWORD *)a2;
    void v7[2] = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    BOOL v8 = v7 + 3;
    a1[1] = (uint64_t)(v7 + 3);
  }
  a1[1] = (uint64_t)v8;
  return result;
}

void sub_20F47C0A4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::vector<MIL::Scanner::Token>::push_back[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= v6)
  {
    uint64_t v9 = (uint64_t)(v7 - *a1) >> 5;
    if ((unint64_t)(v9 + 1) >> 59) {
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v5 - *a1;
    uint64_t v11 = v10 >> 4;
    if (v10 >> 4 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v12 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    uint64_t v18 = v4;
    if (v12) {
      unint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::function<void ()(MIL::Transform::ProgramTransformer &)>>>(v4, v12);
    }
    else {
      unint64_t v13 = 0;
    }
    char v14 = v13;
    uint64_t v15 = &v13[32 * v9];
    size_t v17 = &v13[32 * v12];
    MIL::Scanner::Token::Token(v15, a2);
    int v16 = v15 + 32;
    std::vector<MIL::Scanner::Token>::__swap_out_circular_buffer(a1, &v14);
    uint64_t v8 = a1[1];
    std::__split_buffer<MIL::Scanner::Token>::~__split_buffer((uint64_t)&v14);
  }
  else
  {
    MIL::Scanner::Token::Token(*(_OWORD **)(v4 - 8), a2);
    uint64_t v8 = v7 + 32;
    a1[1] = v7 + 32;
  }
  a1[1] = v8;
}

void sub_20F47C1A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<MIL::Scanner::Token>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void MIL::Text::Parser::TensorVal::ParseTensor(MIL::IRConstantDimension **this, const MIL::IRTensorValueType *a2)
{
  if (!MIL::IRTensorValueType::IsScalar(a2))
  {
    memset(v37, 0, sizeof(v37));
    MIL::Text::Parser::TensorVal::ParseDim((uint64_t)this, v37, (uint64_t)&v35);
    memset(v34, 0, sizeof(v34));
    std::vector<unsigned long>::__init_with_size[abi:ne180100]<unsigned long *,unsigned long *>(v34, v35, (uint64_t)v36, v36 - v35);
    uint64_t v31 = 0;
    unint64_t v32 = 0;
    unsigned __int16 v33 = 0;
    uint64_t v4 = v35;
    unint64_t v5 = v36;
    if (v35 != v36)
    {
      do
      {
        uint64_t v6 = MIL::IRConstantDimension::Make(this[1], *v4);
        uint64_t v7 = v6;
        if (v32 >= (uint64_t *)v33)
        {
          uint64_t v9 = ((char *)v32 - v31) >> 3;
          if ((unint64_t)(v9 + 1) >> 61) {
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v10 = (v33 - v31) >> 2;
          if (v10 <= v9 + 1) {
            unint64_t v10 = v9 + 1;
          }
          if ((unint64_t)(v33 - v31) >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v11 = v10;
          }
          if (v11) {
            unint64_t v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v33, v11);
          }
          else {
            unint64_t v12 = 0;
          }
          unint64_t v13 = (uint64_t *)&v12[8 * v9];
          *unint64_t v13 = v7;
          uint64_t v8 = v13 + 1;
          char v14 = v32;
          if (v32 != (uint64_t *)v31)
          {
            do
            {
              uint64_t v15 = *--v14;
              *--unint64_t v13 = v15;
            }
            while (v14 != (uint64_t *)v31);
            char v14 = (uint64_t *)v31;
          }
          uint64_t v31 = (char *)v13;
          unsigned __int16 v33 = &v12[8 * v11];
          if (v14) {
            operator delete(v14);
          }
        }
        else
        {
          uint64_t *v32 = v6;
          uint64_t v8 = v32 + 1;
        }
        unint64_t v32 = v8;
        ++v4;
      }
      while (v4 != v5);
      if (v31 != (char *)v8)
      {
        uint64_t v16 = MIL::IRDimension::AsConstant((MIL::IRDimension *)*(v8 - 1));
        if (!(*(uint64_t (**)(uint64_t))(*(void *)v16 + 48))(v16))
        {
          for (unint64_t i = ((char *)v8 - v31) >> 3; ; ++i)
          {
            uint64_t v18 = (void *)(*(uint64_t (**)(const MIL::IRTensorValueType *))(*(void *)a2 + 96))(a2);
            if (i >= (uint64_t)(v18[1] - *v18) >> 3) {
              break;
            }
            uint64_t v19 = *(void *)(*(uint64_t (**)(const MIL::IRTensorValueType *))(*(void *)a2 + 96))(a2);
            if (v32 >= (uint64_t *)v33)
            {
              uint64_t v21 = ((char *)v32 - v31) >> 3;
              if ((unint64_t)(v21 + 1) >> 61) {
                std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
              }
              unint64_t v22 = (v33 - v31) >> 2;
              if (v22 <= v21 + 1) {
                unint64_t v22 = v21 + 1;
              }
              if ((unint64_t)(v33 - v31) >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v23 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v23 = v22;
              }
              if (v23) {
                int v24 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v33, v23);
              }
              else {
                int v24 = 0;
              }
              char v25 = &v24[8 * v21];
              *(void *)char v25 = *(void *)(v19 + 8 * i);
              int v20 = (uint64_t *)(v25 + 8);
              uint64_t v26 = v32;
              if (v32 != (uint64_t *)v31)
              {
                do
                {
                  uint64_t v27 = *--v26;
                  *((void *)v25 - 1) = v27;
                  v25 -= 8;
                }
                while (v26 != (uint64_t *)v31);
                uint64_t v26 = (uint64_t *)v31;
              }
              uint64_t v31 = v25;
              unsigned __int16 v33 = &v24[8 * v23];
              if (v26) {
                operator delete(v26);
              }
            }
            else
            {
              uint64_t *v32 = *(void *)(v19 + 8 * i);
              int v20 = v32 + 1;
            }
            unint64_t v32 = v20;
          }
        }
      }
    }
    (*(void (**)(const MIL::IRTensorValueType *))(*(void *)a2 + 88))(a2);
    MIL::IRTensorValueType::MakeWithShape();
  }
  __cxa_allocate_exception(0x48uLL);
  uint64_t v28 = (uint64_t)this[4];
  uint64_t Options = MIL::ParserContext::GetOptions(this[3]);
  uint64_t v30 = (*(uint64_t (**)(uint64_t))(*(void *)Options + 24))(Options);
  MIL::TextLocationFromScannerLocation(v28, v30);
}

void sub_20F47CD10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28)
{
  if (SLOBYTE(STACK[0x2B7]) < 0) {
    operator delete((void *)STACK[0x2A0]);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  if (SLOBYTE(STACK[0x297]) < 0) {
    operator delete((void *)STACK[0x280]);
  }
  if (SLOBYTE(STACK[0x277]) < 0) {
    operator delete((void *)STACK[0x260]);
  }
  if (SLOBYTE(STACK[0x21F]) < 0) {
    operator delete((void *)STACK[0x208]);
  }
  MIL::Text::BasicSerializer::~BasicSerializer((MIL::Text::BasicSerializer *)&a28);
  if (SLOBYTE(STACK[0x257]) < 0) {
    operator delete((void *)STACK[0x240]);
  }
  if (SLOBYTE(STACK[0x237]) < 0) {
    operator delete((void *)STACK[0x220]);
  }
  unint64_t v32 = *(std::__shared_weak_count **)(v30 - 248);
  if (v32) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v32);
  }
  if (STACK[0x2C8])
  {
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)STACK[0x2C8]);
    if ((v28 & 1) == 0) {
      goto LABEL_22;
    }
  }
  else if (!v28)
  {
LABEL_22:
    uint64_t v33 = *(void *)(v30 - 240);
    *(void *)(v30 - 240) = 0;
    if (v33) {
      (*(void (**)(uint64_t))(*(void *)v33 + 8))(v33);
    }
    char v34 = *(void **)(v30 - 232);
    if (v34)
    {
      *(void *)(v30 - 224) = v34;
      operator delete(v34);
    }
    uint64_t v35 = *(void **)(v30 - 208);
    if (v35)
    {
      *(void *)(v30 - 200) = v35;
      operator delete(v35);
    }
    std::string v36 = *(void **)(v30 - 184);
    if (v36)
    {
      *(void *)(v30 - std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)this + 176) = v36;
      operator delete(v36);
    }
    a28 = (void *)(v30 - 160);
    std::vector<MIL::Scanner::Token>::__destroy_vector::operator()[abi:ne180100]((void ***)&a28);
    _Unwind_Resume(a1);
  }
  __cxa_free_exception(v29);
  goto LABEL_22;
}

void sub_20F47D18C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,std::__shared_weak_count *a29)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a17) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a17);
  }
  if (a29)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](a29);
    if ((v29 & 1) == 0) {
      goto LABEL_10;
    }
  }
  else if (!v29)
  {
LABEL_10:
    __cxa_end_catch();
    uint64_t v33 = *(void **)(v31 - 232);
    if (v33)
    {
      *(void *)(v31 - 224) = v33;
      operator delete(v33);
    }
    char v34 = *(void **)(v31 - 208);
    if (v34)
    {
      *(void *)(v31 - 200) = v34;
      operator delete(v34);
    }
    uint64_t v35 = *(void **)(v31 - 184);
    if (v35)
    {
      *(void *)(v31 - std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)this + 176) = v35;
      operator delete(v35);
    }
    a28 = v31 - 160;
    std::vector<MIL::Scanner::Token>::__destroy_vector::operator()[abi:ne180100]((void ***)&a28);
    _Unwind_Resume(a1);
  }
  __cxa_free_exception(v30);
  goto LABEL_10;
}

void sub_20F47D1E8()
{
}

void sub_20F47D1F0()
{
}

void sub_20F47D1F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void **a25)
{
  __cxa_end_catch();
  uint64_t v27 = *(void **)(v25 - 232);
  if (v27)
  {
    *(void *)(v25 - 224) = v27;
    operator delete(v27);
  }
  int v28 = *(void **)(v25 - 208);
  if (v28)
  {
    *(void *)(v25 - 200) = v28;
    operator delete(v28);
  }
  int v29 = *(void **)(v25 - 184);
  if (v29)
  {
    *(void *)(v25 - std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)this + 176) = v29;
    operator delete(v29);
  }
  a25 = (void **)(v25 - 160);
  std::vector<MIL::Scanner::Token>::__destroy_vector::operator()[abi:ne180100](&a25);
  _Unwind_Resume(a1);
}

uint64_t MIL::Text::Parser::TensorVal::ParseTensor(MIL::IRTensorValueType const*)::$_0::operator()(unint64_t **a1)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v16);
  unint64_t v13 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  if (*a1 != v3)
  {
    do
    {
      unint64_t v4 = *v2;
      if (v15 >= 0) {
        unint64_t v5 = &v13;
      }
      else {
        unint64_t v5 = v13;
      }
      if (v15 >= 0) {
        uint64_t v6 = HIBYTE(v15);
      }
      else {
        uint64_t v6 = v14;
      }
      uint64_t v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)v5, v6);
      std::to_string(&__p, v4);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = __p.__r_.__value_.__l.__size_;
      }
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)p_p, size);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      MEMORY[0x21056C240](&v13, ", ");
      ++v2;
    }
    while (v2 != v3);
  }
  std::stringbuf::str();
  if (SHIBYTE(v15) < 0) {
    operator delete(v13);
  }
  v16[0] = *MEMORY[0x263F8C2B8];
  uint64_t v10 = *(void *)(MEMORY[0x263F8C2B8] + 72);
  *(void *)((char *)v16 + *(void *)(v16[0] - 24)) = *(void *)(MEMORY[0x263F8C2B8] + 64);
  v17[0] = v10;
  v17[1] = MEMORY[0x263F8C318] + 16;
  if (v18 < 0) {
    operator delete((void *)v17[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x21056C620](&v19);
}

void sub_20F47D4EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a21);
  _Unwind_Resume(a1);
}

void MIL::Text::Parser::TensorVal::ParseTokens<MIL::Fp8E4M3FN,MIL::Fp8E4M3FN>(uint64_t a1@<X0>, MIL::Scanner::Token **a2@<X1>, unint64_t *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  std::vector<unsigned char>::reserve(a3, (a2[1] - *a2) >> 5);
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  if (*a2 != v7)
  {
    do
    {
      char v8 = MIL::Text::Parser::TensorVal::ParseToken<MIL::Fp8E4M3FN>(a1, v6);
      char v9 = v8;
      unint64_t v11 = (unsigned char *)a3[1];
      unint64_t v10 = a3[2];
      if ((unint64_t)v11 >= v10)
      {
        unint64_t v13 = *a3;
        uint64_t v14 = &v11[-*a3];
        unint64_t v15 = (unint64_t)(v14 + 1);
        if ((uint64_t)(v14 + 1) < 0) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v16 = v10 - v13;
        if (2 * v16 > v15) {
          unint64_t v15 = 2 * v16;
        }
        if (v16 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v17 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v17 = v15;
        }
        if (v17) {
          char v18 = (char *)operator new(v17);
        }
        else {
          char v18 = 0;
        }
        uint64_t v19 = &v14[(void)v18];
        int v20 = &v14[(void)v18];
        *int v20 = v9;
        unint64_t v12 = v20 + 1;
        if (v11 != (unsigned char *)v13)
        {
          uint64_t v21 = &v11[~v13];
          do
          {
            char v22 = *--v11;
            (v21--)[(void)v18] = v22;
          }
          while (v11 != (unsigned char *)v13);
          unint64_t v11 = (unsigned char *)*a3;
          uint64_t v19 = v18;
        }
        *a3 = (unint64_t)v19;
        a3[1] = (unint64_t)v12;
        a3[2] = (unint64_t)&v18[v17];
        if (v11) {
          operator delete(v11);
        }
      }
      else
      {
        *unint64_t v11 = v8;
        unint64_t v12 = v11 + 1;
      }
      a3[1] = (unint64_t)v12;
      uint64_t v6 = (MIL::Scanner::Token *)((char *)v6 + 32);
    }
    while (v6 != v7);
  }
}

void sub_20F47D678(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void MIL::Text::Parser::TensorVal::ParseTokens<MIL::Fp8E5M2,MIL::Fp8E5M2>(uint64_t a1@<X0>, MIL::Scanner::Token **a2@<X1>, unint64_t *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  std::vector<unsigned char>::reserve(a3, (a2[1] - *a2) >> 5);
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  if (*a2 != v7)
  {
    do
    {
      char v8 = MIL::Text::Parser::TensorVal::ParseToken<MIL::Fp8E5M2>(a1, v6);
      char v9 = v8;
      unint64_t v11 = (unsigned char *)a3[1];
      unint64_t v10 = a3[2];
      if ((unint64_t)v11 >= v10)
      {
        unint64_t v13 = *a3;
        uint64_t v14 = &v11[-*a3];
        unint64_t v15 = (unint64_t)(v14 + 1);
        if ((uint64_t)(v14 + 1) < 0) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v16 = v10 - v13;
        if (2 * v16 > v15) {
          unint64_t v15 = 2 * v16;
        }
        if (v16 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v17 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v17 = v15;
        }
        if (v17) {
          char v18 = (char *)operator new(v17);
        }
        else {
          char v18 = 0;
        }
        uint64_t v19 = &v14[(void)v18];
        int v20 = &v14[(void)v18];
        *int v20 = v9;
        unint64_t v12 = v20 + 1;
        if (v11 != (unsigned char *)v13)
        {
          uint64_t v21 = &v11[~v13];
          do
          {
            char v22 = *--v11;
            (v21--)[(void)v18] = v22;
          }
          while (v11 != (unsigned char *)v13);
          unint64_t v11 = (unsigned char *)*a3;
          uint64_t v19 = v18;
        }
        *a3 = (unint64_t)v19;
        a3[1] = (unint64_t)v12;
        a3[2] = (unint64_t)&v18[v17];
        if (v11) {
          operator delete(v11);
        }
      }
      else
      {
        *unint64_t v11 = v8;
        unint64_t v12 = v11 + 1;
      }
      a3[1] = (unint64_t)v12;
      uint64_t v6 = (MIL::Scanner::Token *)((char *)v6 + 32);
    }
    while (v6 != v7);
  }
}

void sub_20F47D7E4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void MIL::Text::Parser::TensorVal::ParseTokens<MIL::Bf16,MIL::Bf16>(uint64_t a1@<X0>, MIL::Scanner::Token **a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  std::vector<MIL::Fp16>::reserve((void **)a3, (a2[1] - *a2) >> 5);
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  if (*a2 != v7)
  {
    do
    {
      __int16 v8 = MIL::Text::Parser::TensorVal::ParseToken<MIL::Bf16>(a1, v6);
      __int16 v9 = v8;
      unint64_t v11 = *(_WORD **)(a3 + 8);
      unint64_t v10 = *(void *)(a3 + 16);
      if ((unint64_t)v11 >= v10)
      {
        unint64_t v13 = *(_WORD **)a3;
        uint64_t v14 = (uint64_t)v11 - *(void *)a3;
        if (v14 <= -3) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v15 = v14 >> 1;
        unint64_t v16 = v10 - (void)v13;
        if (v16 <= (v14 >> 1) + 1) {
          unint64_t v17 = v15 + 1;
        }
        else {
          unint64_t v17 = v16;
        }
        if (v16 >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v18 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v18 = v17;
        }
        if (v18)
        {
          uint64_t v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MIL::Fp16>>(a3 + 16, v18);
          unint64_t v13 = *(_WORD **)a3;
          unint64_t v11 = *(_WORD **)(a3 + 8);
        }
        else
        {
          uint64_t v19 = 0;
        }
        int v20 = &v19[2 * v15];
        *(_WORD *)int v20 = v9;
        unint64_t v12 = v20 + 2;
        while (v11 != v13)
        {
          __int16 v21 = *--v11;
          *((_WORD *)v20 - 1) = v21;
          v20 -= 2;
        }
        *(void *)a3 = v20;
        *(void *)(a3 + 8) = v12;
        *(void *)(a3 + 16) = &v19[2 * v18];
        if (v13) {
          operator delete(v13);
        }
      }
      else
      {
        *unint64_t v11 = v8;
        unint64_t v12 = v11 + 1;
      }
      *(void *)(a3 + 8) = v12;
      uint64_t v6 = (MIL::Scanner::Token *)((char *)v6 + 32);
    }
    while (v6 != v7);
  }
}

void sub_20F47D944(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void MIL::Text::Parser::TensorVal::ParseTokens<MIL::Fp16,MIL::Fp16>(uint64_t a1@<X0>, MIL::Scanner::Token **a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  std::vector<MIL::Fp16>::reserve((void **)a3, (a2[1] - *a2) >> 5);
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  if (*a2 != v7)
  {
    do
    {
      __int16 v8 = MIL::Text::Parser::TensorVal::ParseToken<MIL::Fp16>(a1, v6);
      __int16 v9 = v8;
      unint64_t v11 = *(_WORD **)(a3 + 8);
      unint64_t v10 = *(void *)(a3 + 16);
      if ((unint64_t)v11 >= v10)
      {
        unint64_t v13 = *(_WORD **)a3;
        uint64_t v14 = (uint64_t)v11 - *(void *)a3;
        if (v14 <= -3) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v15 = v14 >> 1;
        unint64_t v16 = v10 - (void)v13;
        if (v16 <= (v14 >> 1) + 1) {
          unint64_t v17 = v15 + 1;
        }
        else {
          unint64_t v17 = v16;
        }
        if (v16 >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v18 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v18 = v17;
        }
        if (v18)
        {
          uint64_t v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MIL::Fp16>>(a3 + 16, v18);
          unint64_t v13 = *(_WORD **)a3;
          unint64_t v11 = *(_WORD **)(a3 + 8);
        }
        else
        {
          uint64_t v19 = 0;
        }
        int v20 = &v19[2 * v15];
        *(_WORD *)int v20 = v9;
        unint64_t v12 = v20 + 2;
        while (v11 != v13)
        {
          __int16 v21 = *--v11;
          *((_WORD *)v20 - 1) = v21;
          v20 -= 2;
        }
        *(void *)a3 = v20;
        *(void *)(a3 + 8) = v12;
        *(void *)(a3 + 16) = &v19[2 * v18];
        if (v13) {
          operator delete(v13);
        }
      }
      else
      {
        *unint64_t v11 = v8;
        unint64_t v12 = v11 + 1;
      }
      *(void *)(a3 + 8) = v12;
      uint64_t v6 = (MIL::Scanner::Token *)((char *)v6 + 32);
    }
    while (v6 != v7);
  }
}

void sub_20F47DAA4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void MIL::Text::Parser::TensorVal::ParseTokens<float,float>(uint64_t a1@<X0>, MIL::Scanner::Token **a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  std::vector<float>::reserve((void **)a3, (a2[1] - *a2) >> 5);
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  if (*a2 != v7)
  {
    do
    {
      float v8 = MIL::Text::Parser::TensorVal::ParseToken<float>(a1, v6);
      float v9 = v8;
      unint64_t v11 = *(float **)(a3 + 8);
      unint64_t v10 = *(void *)(a3 + 16);
      if ((unint64_t)v11 >= v10)
      {
        unint64_t v13 = *(float **)a3;
        uint64_t v14 = ((uint64_t)v11 - *(void *)a3) >> 2;
        unint64_t v15 = v14 + 1;
        if ((unint64_t)(v14 + 1) >> 62) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v16 = v10 - (void)v13;
        if (v16 >> 1 > v15) {
          unint64_t v15 = v16 >> 1;
        }
        if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v17 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v17 = v15;
        }
        if (v17)
        {
          uint64_t v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(a3 + 16, v17);
          unint64_t v13 = *(float **)a3;
          unint64_t v11 = *(float **)(a3 + 8);
        }
        else
        {
          uint64_t v18 = 0;
        }
        uint64_t v19 = (float *)&v18[4 * v14];
        float *v19 = v9;
        unint64_t v12 = v19 + 1;
        while (v11 != v13)
        {
          int v20 = *((_DWORD *)v11-- - 1);
          *((_DWORD *)v19-- - 1) = v20;
        }
        *(void *)a3 = v19;
        *(void *)(a3 + 8) = v12;
        *(void *)(a3 + 16) = &v18[4 * v17];
        if (v13) {
          operator delete(v13);
        }
      }
      else
      {
        *unint64_t v11 = v8;
        unint64_t v12 = v11 + 1;
      }
      *(void *)(a3 + 8) = v12;
      uint64_t v6 = (MIL::Scanner::Token *)((char *)v6 + 32);
    }
    while (v6 != v7);
  }
}

void sub_20F47DC08(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void MIL::Text::Parser::TensorVal::ParseTokens<double,double>(uint64_t a1@<X0>, MIL::Scanner::Token **a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  std::vector<double>::reserve((void **)a3, (a2[1] - *a2) >> 5);
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  if (*a2 != v7)
  {
    do
    {
      double v8 = MIL::Text::Parser::TensorVal::ParseToken<double>(a1, v6);
      double v9 = v8;
      unint64_t v11 = *(double **)(a3 + 8);
      unint64_t v10 = *(void *)(a3 + 16);
      if ((unint64_t)v11 >= v10)
      {
        unint64_t v13 = *(double **)a3;
        uint64_t v14 = ((uint64_t)v11 - *(void *)a3) >> 3;
        unint64_t v15 = v14 + 1;
        if ((unint64_t)(v14 + 1) >> 61) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v16 = v10 - (void)v13;
        if (v16 >> 2 > v15) {
          unint64_t v15 = v16 >> 2;
        }
        if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v17 = v15;
        }
        if (v17)
        {
          uint64_t v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>(a3 + 16, v17);
          unint64_t v13 = *(double **)a3;
          unint64_t v11 = *(double **)(a3 + 8);
        }
        else
        {
          uint64_t v18 = 0;
        }
        uint64_t v19 = (double *)&v18[8 * v14];
        double *v19 = v9;
        unint64_t v12 = v19 + 1;
        while (v11 != v13)
        {
          uint64_t v20 = *((void *)v11-- - 1);
          *((void *)v19-- - 1) = v20;
        }
        *(void *)a3 = v19;
        *(void *)(a3 + 8) = v12;
        *(void *)(a3 + 16) = &v18[8 * v17];
        if (v13) {
          operator delete(v13);
        }
      }
      else
      {
        *unint64_t v11 = v8;
        unint64_t v12 = v11 + 1;
      }
      *(void *)(a3 + 8) = v12;
      uint64_t v6 = (MIL::Scanner::Token *)((char *)v6 + 32);
    }
    while (v6 != v7);
  }
}

void sub_20F47DD6C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void MIL::Text::Parser::TensorVal::ParseTokens<MIL::Int4,MIL::Int4>(uint64_t a1@<X0>, MIL::Scanner::Token **a2@<X1>, unint64_t *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  std::vector<unsigned char>::reserve(a3, (a2[1] - *a2) >> 5);
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  if (*a2 != v7)
  {
    do
    {
      char v8 = MIL::Text::Parser::TensorVal::ParseToken<MIL::Int4>(a1, v6);
      char v9 = v8;
      unint64_t v11 = (unsigned char *)a3[1];
      unint64_t v10 = a3[2];
      if ((unint64_t)v11 >= v10)
      {
        unint64_t v13 = *a3;
        uint64_t v14 = &v11[-*a3];
        unint64_t v15 = (unint64_t)(v14 + 1);
        if ((uint64_t)(v14 + 1) < 0) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v16 = v10 - v13;
        if (2 * v16 > v15) {
          unint64_t v15 = 2 * v16;
        }
        if (v16 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v17 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v17 = v15;
        }
        if (v17) {
          uint64_t v18 = (char *)operator new(v17);
        }
        else {
          uint64_t v18 = 0;
        }
        uint64_t v19 = &v14[(void)v18];
        uint64_t v20 = &v14[(void)v18];
        *uint64_t v20 = v9;
        unint64_t v12 = v20 + 1;
        if (v11 != (unsigned char *)v13)
        {
          __int16 v21 = &v11[~v13];
          do
          {
            char v22 = *--v11;
            (v21--)[(void)v18] = v22;
          }
          while (v11 != (unsigned char *)v13);
          unint64_t v11 = (unsigned char *)*a3;
          uint64_t v19 = v18;
        }
        *a3 = (unint64_t)v19;
        a3[1] = (unint64_t)v12;
        a3[2] = (unint64_t)&v18[v17];
        if (v11) {
          operator delete(v11);
        }
      }
      else
      {
        *unint64_t v11 = v8;
        unint64_t v12 = v11 + 1;
      }
      a3[1] = (unint64_t)v12;
      uint64_t v6 = (MIL::Scanner::Token *)((char *)v6 + 32);
    }
    while (v6 != v7);
  }
}

void sub_20F47DED8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void MIL::Text::Parser::TensorVal::ParseTokens<MIL::UInt6,MIL::UInt6>(uint64_t a1@<X0>, MIL::Scanner::Token **a2@<X1>, unint64_t *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  std::vector<unsigned char>::reserve(a3, (a2[1] - *a2) >> 5);
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  if (*a2 != v7)
  {
    do
    {
      char v8 = MIL::Text::Parser::TensorVal::ParseToken<MIL::UInt6>(a1, v6);
      char v9 = v8;
      unint64_t v11 = (unsigned char *)a3[1];
      unint64_t v10 = a3[2];
      if ((unint64_t)v11 >= v10)
      {
        unint64_t v13 = *a3;
        uint64_t v14 = &v11[-*a3];
        unint64_t v15 = (unint64_t)(v14 + 1);
        if ((uint64_t)(v14 + 1) < 0) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v16 = v10 - v13;
        if (2 * v16 > v15) {
          unint64_t v15 = 2 * v16;
        }
        if (v16 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v17 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v17 = v15;
        }
        if (v17) {
          uint64_t v18 = (char *)operator new(v17);
        }
        else {
          uint64_t v18 = 0;
        }
        uint64_t v19 = &v14[(void)v18];
        uint64_t v20 = &v14[(void)v18];
        *uint64_t v20 = v9;
        unint64_t v12 = v20 + 1;
        if (v11 != (unsigned char *)v13)
        {
          __int16 v21 = &v11[~v13];
          do
          {
            char v22 = *--v11;
            (v21--)[(void)v18] = v22;
          }
          while (v11 != (unsigned char *)v13);
          unint64_t v11 = (unsigned char *)*a3;
          uint64_t v19 = v18;
        }
        *a3 = (unint64_t)v19;
        a3[1] = (unint64_t)v12;
        a3[2] = (unint64_t)&v18[v17];
        if (v11) {
          operator delete(v11);
        }
      }
      else
      {
        *unint64_t v11 = v8;
        unint64_t v12 = v11 + 1;
      }
      a3[1] = (unint64_t)v12;
      uint64_t v6 = (MIL::Scanner::Token *)((char *)v6 + 32);
    }
    while (v6 != v7);
  }
}

void sub_20F47E044(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void MIL::Text::Parser::TensorVal::ParseTokens<MIL::UInt4,MIL::UInt4>(uint64_t a1@<X0>, MIL::Scanner::Token **a2@<X1>, unint64_t *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  std::vector<unsigned char>::reserve(a3, (a2[1] - *a2) >> 5);
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  if (*a2 != v7)
  {
    do
    {
      char v8 = MIL::Text::Parser::TensorVal::ParseToken<MIL::UInt4>(a1, v6);
      char v9 = v8;
      unint64_t v11 = (unsigned char *)a3[1];
      unint64_t v10 = a3[2];
      if ((unint64_t)v11 >= v10)
      {
        unint64_t v13 = *a3;
        uint64_t v14 = &v11[-*a3];
        unint64_t v15 = (unint64_t)(v14 + 1);
        if ((uint64_t)(v14 + 1) < 0) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v16 = v10 - v13;
        if (2 * v16 > v15) {
          unint64_t v15 = 2 * v16;
        }
        if (v16 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v17 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v17 = v15;
        }
        if (v17) {
          uint64_t v18 = (char *)operator new(v17);
        }
        else {
          uint64_t v18 = 0;
        }
        uint64_t v19 = &v14[(void)v18];
        uint64_t v20 = &v14[(void)v18];
        *uint64_t v20 = v9;
        unint64_t v12 = v20 + 1;
        if (v11 != (unsigned char *)v13)
        {
          __int16 v21 = &v11[~v13];
          do
          {
            char v22 = *--v11;
            (v21--)[(void)v18] = v22;
          }
          while (v11 != (unsigned char *)v13);
          unint64_t v11 = (unsigned char *)*a3;
          uint64_t v19 = v18;
        }
        *a3 = (unint64_t)v19;
        a3[1] = (unint64_t)v12;
        a3[2] = (unint64_t)&v18[v17];
        if (v11) {
          operator delete(v11);
        }
      }
      else
      {
        *unint64_t v11 = v8;
        unint64_t v12 = v11 + 1;
      }
      a3[1] = (unint64_t)v12;
      uint64_t v6 = (MIL::Scanner::Token *)((char *)v6 + 32);
    }
    while (v6 != v7);
  }
}

void sub_20F47E1B0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void MIL::Text::Parser::TensorVal::ParseTokens<MIL::UInt3,MIL::UInt3>(uint64_t a1@<X0>, MIL::Scanner::Token **a2@<X1>, unint64_t *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  std::vector<unsigned char>::reserve(a3, (a2[1] - *a2) >> 5);
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  if (*a2 != v7)
  {
    do
    {
      char v8 = MIL::Text::Parser::TensorVal::ParseToken<MIL::UInt3>(a1, v6);
      char v9 = v8;
      unint64_t v11 = (unsigned char *)a3[1];
      unint64_t v10 = a3[2];
      if ((unint64_t)v11 >= v10)
      {
        unint64_t v13 = *a3;
        uint64_t v14 = &v11[-*a3];
        unint64_t v15 = (unint64_t)(v14 + 1);
        if ((uint64_t)(v14 + 1) < 0) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v16 = v10 - v13;
        if (2 * v16 > v15) {
          unint64_t v15 = 2 * v16;
        }
        if (v16 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v17 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v17 = v15;
        }
        if (v17) {
          uint64_t v18 = (char *)operator new(v17);
        }
        else {
          uint64_t v18 = 0;
        }
        uint64_t v19 = &v14[(void)v18];
        uint64_t v20 = &v14[(void)v18];
        *uint64_t v20 = v9;
        unint64_t v12 = v20 + 1;
        if (v11 != (unsigned char *)v13)
        {
          __int16 v21 = &v11[~v13];
          do
          {
            char v22 = *--v11;
            (v21--)[(void)v18] = v22;
          }
          while (v11 != (unsigned char *)v13);
          unint64_t v11 = (unsigned char *)*a3;
          uint64_t v19 = v18;
        }
        *a3 = (unint64_t)v19;
        a3[1] = (unint64_t)v12;
        a3[2] = (unint64_t)&v18[v17];
        if (v11) {
          operator delete(v11);
        }
      }
      else
      {
        *unint64_t v11 = v8;
        unint64_t v12 = v11 + 1;
      }
      a3[1] = (unint64_t)v12;
      uint64_t v6 = (MIL::Scanner::Token *)((char *)v6 + 32);
    }
    while (v6 != v7);
  }
}

void sub_20F47E31C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void MIL::Text::Parser::TensorVal::ParseTokens<MIL::UInt2,MIL::UInt2>(uint64_t a1@<X0>, MIL::Scanner::Token **a2@<X1>, unint64_t *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  std::vector<unsigned char>::reserve(a3, (a2[1] - *a2) >> 5);
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  if (*a2 != v7)
  {
    do
    {
      char v8 = MIL::Text::Parser::TensorVal::ParseToken<MIL::UInt2>(a1, v6);
      char v9 = v8;
      unint64_t v11 = (unsigned char *)a3[1];
      unint64_t v10 = a3[2];
      if ((unint64_t)v11 >= v10)
      {
        unint64_t v13 = *a3;
        uint64_t v14 = &v11[-*a3];
        unint64_t v15 = (unint64_t)(v14 + 1);
        if ((uint64_t)(v14 + 1) < 0) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v16 = v10 - v13;
        if (2 * v16 > v15) {
          unint64_t v15 = 2 * v16;
        }
        if (v16 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v17 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v17 = v15;
        }
        if (v17) {
          uint64_t v18 = (char *)operator new(v17);
        }
        else {
          uint64_t v18 = 0;
        }
        uint64_t v19 = &v14[(void)v18];
        uint64_t v20 = &v14[(void)v18];
        *uint64_t v20 = v9;
        unint64_t v12 = v20 + 1;
        if (v11 != (unsigned char *)v13)
        {
          __int16 v21 = &v11[~v13];
          do
          {
            char v22 = *--v11;
            (v21--)[(void)v18] = v22;
          }
          while (v11 != (unsigned char *)v13);
          unint64_t v11 = (unsigned char *)*a3;
          uint64_t v19 = v18;
        }
        *a3 = (unint64_t)v19;
        a3[1] = (unint64_t)v12;
        a3[2] = (unint64_t)&v18[v17];
        if (v11) {
          operator delete(v11);
        }
      }
      else
      {
        *unint64_t v11 = v8;
        unint64_t v12 = v11 + 1;
      }
      a3[1] = (unint64_t)v12;
      uint64_t v6 = (MIL::Scanner::Token *)((char *)v6 + 32);
    }
    while (v6 != v7);
  }
}

void sub_20F47E488(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void MIL::Text::Parser::TensorVal::ParseTokens<MIL::UInt1,MIL::UInt1>(uint64_t a1@<X0>, MIL::Scanner::Token **a2@<X1>, unint64_t *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  std::vector<unsigned char>::reserve(a3, (a2[1] - *a2) >> 5);
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  if (*a2 != v7)
  {
    do
    {
      char v8 = MIL::Text::Parser::TensorVal::ParseToken<MIL::UInt1>(a1, v6);
      char v9 = v8;
      unint64_t v11 = (unsigned char *)a3[1];
      unint64_t v10 = a3[2];
      if ((unint64_t)v11 >= v10)
      {
        unint64_t v13 = *a3;
        uint64_t v14 = &v11[-*a3];
        unint64_t v15 = (unint64_t)(v14 + 1);
        if ((uint64_t)(v14 + 1) < 0) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v16 = v10 - v13;
        if (2 * v16 > v15) {
          unint64_t v15 = 2 * v16;
        }
        if (v16 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v17 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v17 = v15;
        }
        if (v17) {
          uint64_t v18 = (char *)operator new(v17);
        }
        else {
          uint64_t v18 = 0;
        }
        uint64_t v19 = &v14[(void)v18];
        uint64_t v20 = &v14[(void)v18];
        *uint64_t v20 = v9;
        unint64_t v12 = v20 + 1;
        if (v11 != (unsigned char *)v13)
        {
          __int16 v21 = &v11[~v13];
          do
          {
            char v22 = *--v11;
            (v21--)[(void)v18] = v22;
          }
          while (v11 != (unsigned char *)v13);
          unint64_t v11 = (unsigned char *)*a3;
          uint64_t v19 = v18;
        }
        *a3 = (unint64_t)v19;
        a3[1] = (unint64_t)v12;
        a3[2] = (unint64_t)&v18[v17];
        if (v11) {
          operator delete(v11);
        }
      }
      else
      {
        *unint64_t v11 = v8;
        unint64_t v12 = v11 + 1;
      }
      a3[1] = (unint64_t)v12;
      uint64_t v6 = (MIL::Scanner::Token *)((char *)v6 + 32);
    }
    while (v6 != v7);
  }
}

void sub_20F47E5F4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void MIL::Text::Parser::TensorVal::ParseTokens<unsigned char,unsigned char>(uint64_t a1@<X0>, MIL::Scanner::Token **a2@<X1>, unint64_t *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  std::vector<unsigned char>::reserve(a3, (a2[1] - *a2) >> 5);
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  if (*a2 != v7)
  {
    do
    {
      char v8 = MIL::Text::Parser::TensorVal::ParseToken<unsigned char>(a1, v6);
      char v9 = v8;
      unint64_t v11 = (unsigned char *)a3[1];
      unint64_t v10 = a3[2];
      if ((unint64_t)v11 >= v10)
      {
        unint64_t v13 = *a3;
        uint64_t v14 = &v11[-*a3];
        unint64_t v15 = (unint64_t)(v14 + 1);
        if ((uint64_t)(v14 + 1) < 0) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v16 = v10 - v13;
        if (2 * v16 > v15) {
          unint64_t v15 = 2 * v16;
        }
        if (v16 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v17 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v17 = v15;
        }
        if (v17) {
          uint64_t v18 = (char *)operator new(v17);
        }
        else {
          uint64_t v18 = 0;
        }
        uint64_t v19 = &v14[(void)v18];
        uint64_t v20 = &v14[(void)v18];
        *uint64_t v20 = v9;
        unint64_t v12 = v20 + 1;
        if (v11 != (unsigned char *)v13)
        {
          __int16 v21 = &v11[~v13];
          do
          {
            char v22 = *--v11;
            (v21--)[(void)v18] = v22;
          }
          while (v11 != (unsigned char *)v13);
          unint64_t v11 = (unsigned char *)*a3;
          uint64_t v19 = v18;
        }
        *a3 = (unint64_t)v19;
        a3[1] = (unint64_t)v12;
        a3[2] = (unint64_t)&v18[v17];
        if (v11) {
          operator delete(v11);
        }
      }
      else
      {
        *unint64_t v11 = v8;
        unint64_t v12 = v11 + 1;
      }
      a3[1] = (unint64_t)v12;
      uint64_t v6 = (MIL::Scanner::Token *)((char *)v6 + 32);
    }
    while (v6 != v7);
  }
}

void sub_20F47E760(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void MIL::Text::Parser::TensorVal::ParseTokens<unsigned short,unsigned short>(uint64_t a1@<X0>, MIL::Scanner::Token **a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  std::vector<MIL::Fp16>::reserve((void **)a3, (a2[1] - *a2) >> 5);
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  if (*a2 != v7)
  {
    do
    {
      __int16 v8 = MIL::Text::Parser::TensorVal::ParseToken<unsigned short>(a1, v6);
      __int16 v9 = v8;
      unint64_t v11 = *(_WORD **)(a3 + 8);
      unint64_t v10 = *(void *)(a3 + 16);
      if ((unint64_t)v11 >= v10)
      {
        unint64_t v13 = *(_WORD **)a3;
        uint64_t v14 = (uint64_t)v11 - *(void *)a3;
        if (v14 <= -3) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v15 = v14 >> 1;
        unint64_t v16 = v10 - (void)v13;
        if (v16 <= (v14 >> 1) + 1) {
          unint64_t v17 = v15 + 1;
        }
        else {
          unint64_t v17 = v16;
        }
        if (v16 >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v18 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v18 = v17;
        }
        if (v18)
        {
          uint64_t v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MIL::Fp16>>(a3 + 16, v18);
          unint64_t v13 = *(_WORD **)a3;
          unint64_t v11 = *(_WORD **)(a3 + 8);
        }
        else
        {
          uint64_t v19 = 0;
        }
        uint64_t v20 = &v19[2 * v15];
        *(_WORD *)uint64_t v20 = v9;
        unint64_t v12 = v20 + 2;
        while (v11 != v13)
        {
          __int16 v21 = *--v11;
          *((_WORD *)v20 - 1) = v21;
          v20 -= 2;
        }
        *(void *)a3 = v20;
        *(void *)(a3 + 8) = v12;
        *(void *)(a3 + 16) = &v19[2 * v18];
        if (v13) {
          operator delete(v13);
        }
      }
      else
      {
        *unint64_t v11 = v8;
        unint64_t v12 = v11 + 1;
      }
      *(void *)(a3 + 8) = v12;
      uint64_t v6 = (MIL::Scanner::Token *)((char *)v6 + 32);
    }
    while (v6 != v7);
  }
}

void sub_20F47E8C0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void MIL::Text::Parser::TensorVal::ParseTokens<unsigned int,unsigned int>(uint64_t a1@<X0>, MIL::Scanner::Token **a2@<X1>, std::vector<unsigned int> *a3@<X8>)
{
  a3->__begin_ = 0;
  a3->__end_ = 0;
  a3->__end_cap_.__value_ = 0;
  std::vector<int>::reserve(a3, (a2[1] - *a2) >> 5);
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  if (*a2 != v7)
  {
    do
    {
      unsigned int v8 = MIL::Text::Parser::TensorVal::ParseToken<unsigned int>(a1, v6);
      unsigned int v9 = v8;
      std::vector<unsigned int>::pointer end = a3->__end_;
      value = a3->__end_cap_.__value_;
      if (end >= value)
      {
        std::vector<unsigned int>::pointer begin = a3->__begin_;
        uint64_t v14 = end - a3->__begin_;
        unint64_t v15 = v14 + 1;
        if ((unint64_t)(v14 + 1) >> 62) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v16 = (char *)value - (char *)begin;
        if (v16 >> 1 > v15) {
          unint64_t v15 = v16 >> 1;
        }
        if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v17 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v17 = v15;
        }
        if (v17)
        {
          uint64_t v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&a3->__end_cap_, v17);
          std::vector<unsigned int>::pointer begin = a3->__begin_;
          std::vector<unsigned int>::pointer end = a3->__end_;
        }
        else
        {
          uint64_t v18 = 0;
        }
        uint64_t v19 = (unsigned int *)&v18[4 * v14];
        unsigned int *v19 = v9;
        unint64_t v12 = v19 + 1;
        while (end != begin)
        {
          unsigned int v20 = *--end;
          *--uint64_t v19 = v20;
        }
        a3->__begin_ = v19;
        a3->__end_ = v12;
        a3->__end_cap_.__value_ = (unsigned int *)&v18[4 * v17];
        if (begin) {
          operator delete(begin);
        }
      }
      else
      {
        *std::vector<unsigned int>::pointer end = v8;
        unint64_t v12 = end + 1;
      }
      a3->__end_ = v12;
      uint64_t v6 = (MIL::Scanner::Token *)((char *)v6 + 32);
    }
    while (v6 != v7);
  }
}

void sub_20F47EA24(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void MIL::Text::Parser::TensorVal::ParseTokens<unsigned long long,unsigned long long>(uint64_t a1@<X0>, MIL::Scanner::Token **a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  std::vector<unsigned long long>::reserve((void **)a3, (a2[1] - *a2) >> 5);
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  if (*a2 != v7)
  {
    do
    {
      unint64_t v8 = MIL::Text::Parser::TensorVal::ParseToken<unsigned long long>(a1, v6);
      unint64_t v9 = v8;
      unint64_t v11 = *(unint64_t **)(a3 + 8);
      unint64_t v10 = *(void *)(a3 + 16);
      if ((unint64_t)v11 >= v10)
      {
        unint64_t v13 = *(unint64_t **)a3;
        uint64_t v14 = ((uint64_t)v11 - *(void *)a3) >> 3;
        unint64_t v15 = v14 + 1;
        if ((unint64_t)(v14 + 1) >> 61) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v16 = v10 - (void)v13;
        if (v16 >> 2 > v15) {
          unint64_t v15 = v16 >> 2;
        }
        if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v17 = v15;
        }
        if (v17)
        {
          uint64_t v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>(a3 + 16, v17);
          unint64_t v13 = *(unint64_t **)a3;
          unint64_t v11 = *(unint64_t **)(a3 + 8);
        }
        else
        {
          uint64_t v18 = 0;
        }
        uint64_t v19 = (unint64_t *)&v18[8 * v14];
        unint64_t *v19 = v9;
        unint64_t v12 = v19 + 1;
        while (v11 != v13)
        {
          unint64_t v20 = *--v11;
          *--uint64_t v19 = v20;
        }
        *(void *)a3 = v19;
        *(void *)(a3 + 8) = v12;
        *(void *)(a3 + 16) = &v18[8 * v17];
        if (v13) {
          operator delete(v13);
        }
      }
      else
      {
        *unint64_t v11 = v8;
        unint64_t v12 = v11 + 1;
      }
      *(void *)(a3 + 8) = v12;
      uint64_t v6 = (MIL::Scanner::Token *)((char *)v6 + 32);
    }
    while (v6 != v7);
  }
}

void sub_20F47EB88(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void MIL::Text::Parser::TensorVal::ParseTokens<signed char,signed char>(uint64_t a1@<X0>, MIL::Scanner::Token **a2@<X1>, unint64_t *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  std::vector<unsigned char>::reserve(a3, (a2[1] - *a2) >> 5);
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  if (*a2 != v7)
  {
    do
    {
      char v8 = MIL::Text::Parser::TensorVal::ParseToken<signed char>(a1, v6);
      char v9 = v8;
      unint64_t v11 = (unsigned char *)a3[1];
      unint64_t v10 = a3[2];
      if ((unint64_t)v11 >= v10)
      {
        unint64_t v13 = *a3;
        uint64_t v14 = &v11[-*a3];
        unint64_t v15 = (unint64_t)(v14 + 1);
        if ((uint64_t)(v14 + 1) < 0) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v16 = v10 - v13;
        if (2 * v16 > v15) {
          unint64_t v15 = 2 * v16;
        }
        if (v16 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v17 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v17 = v15;
        }
        if (v17) {
          uint64_t v18 = (char *)operator new(v17);
        }
        else {
          uint64_t v18 = 0;
        }
        uint64_t v19 = &v14[(void)v18];
        unint64_t v20 = &v14[(void)v18];
        *unint64_t v20 = v9;
        unint64_t v12 = v20 + 1;
        if (v11 != (unsigned char *)v13)
        {
          __int16 v21 = &v11[~v13];
          do
          {
            char v22 = *--v11;
            (v21--)[(void)v18] = v22;
          }
          while (v11 != (unsigned char *)v13);
          unint64_t v11 = (unsigned char *)*a3;
          uint64_t v19 = v18;
        }
        *a3 = (unint64_t)v19;
        a3[1] = (unint64_t)v12;
        a3[2] = (unint64_t)&v18[v17];
        if (v11) {
          operator delete(v11);
        }
      }
      else
      {
        *unint64_t v11 = v8;
        unint64_t v12 = v11 + 1;
      }
      a3[1] = (unint64_t)v12;
      uint64_t v6 = (MIL::Scanner::Token *)((char *)v6 + 32);
    }
    while (v6 != v7);
  }
}

void sub_20F47ECF4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void MIL::Text::Parser::TensorVal::ParseTokens<short,short>(uint64_t a1@<X0>, MIL::Scanner::Token **a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  std::vector<MIL::Fp16>::reserve((void **)a3, (a2[1] - *a2) >> 5);
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  if (*a2 != v7)
  {
    do
    {
      __int16 v8 = MIL::Text::Parser::TensorVal::ParseToken<short>(a1, v6);
      __int16 v9 = v8;
      unint64_t v11 = *(_WORD **)(a3 + 8);
      unint64_t v10 = *(void *)(a3 + 16);
      if ((unint64_t)v11 >= v10)
      {
        unint64_t v13 = *(_WORD **)a3;
        uint64_t v14 = (uint64_t)v11 - *(void *)a3;
        if (v14 <= -3) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v15 = v14 >> 1;
        unint64_t v16 = v10 - (void)v13;
        if (v16 <= (v14 >> 1) + 1) {
          unint64_t v17 = v15 + 1;
        }
        else {
          unint64_t v17 = v16;
        }
        if (v16 >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v18 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v18 = v17;
        }
        if (v18)
        {
          uint64_t v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MIL::Fp16>>(a3 + 16, v18);
          unint64_t v13 = *(_WORD **)a3;
          unint64_t v11 = *(_WORD **)(a3 + 8);
        }
        else
        {
          uint64_t v19 = 0;
        }
        unint64_t v20 = &v19[2 * v15];
        *(_WORD *)unint64_t v20 = v9;
        unint64_t v12 = v20 + 2;
        while (v11 != v13)
        {
          __int16 v21 = *--v11;
          *((_WORD *)v20 - 1) = v21;
          v20 -= 2;
        }
        *(void *)a3 = v20;
        *(void *)(a3 + 8) = v12;
        *(void *)(a3 + 16) = &v19[2 * v18];
        if (v13) {
          operator delete(v13);
        }
      }
      else
      {
        *unint64_t v11 = v8;
        unint64_t v12 = v11 + 1;
      }
      *(void *)(a3 + 8) = v12;
      uint64_t v6 = (MIL::Scanner::Token *)((char *)v6 + 32);
    }
    while (v6 != v7);
  }
}

void sub_20F47EE54(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void MIL::Text::Parser::TensorVal::ParseTokens<int,int>(uint64_t a1@<X0>, MIL::Scanner::Token **a2@<X1>, std::vector<unsigned int> *a3@<X8>)
{
  a3->__begin_ = 0;
  a3->__end_ = 0;
  a3->__end_cap_.__value_ = 0;
  std::vector<int>::reserve(a3, (a2[1] - *a2) >> 5);
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  if (*a2 != v7)
  {
    do
    {
      unsigned int v8 = MIL::Text::Parser::TensorVal::ParseToken<int>(a1, v6);
      unsigned int v9 = v8;
      std::vector<unsigned int>::pointer end = a3->__end_;
      value = a3->__end_cap_.__value_;
      if (end >= value)
      {
        std::vector<unsigned int>::pointer begin = a3->__begin_;
        uint64_t v14 = end - a3->__begin_;
        unint64_t v15 = v14 + 1;
        if ((unint64_t)(v14 + 1) >> 62) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v16 = (char *)value - (char *)begin;
        if (v16 >> 1 > v15) {
          unint64_t v15 = v16 >> 1;
        }
        if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v17 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v17 = v15;
        }
        if (v17)
        {
          uint64_t v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&a3->__end_cap_, v17);
          std::vector<unsigned int>::pointer begin = a3->__begin_;
          std::vector<unsigned int>::pointer end = a3->__end_;
        }
        else
        {
          uint64_t v18 = 0;
        }
        uint64_t v19 = (unsigned int *)&v18[4 * v14];
        unsigned int *v19 = v9;
        unint64_t v12 = v19 + 1;
        while (end != begin)
        {
          unsigned int v20 = *--end;
          *--uint64_t v19 = v20;
        }
        a3->__begin_ = v19;
        a3->__end_ = v12;
        a3->__end_cap_.__value_ = (unsigned int *)&v18[4 * v17];
        if (begin) {
          operator delete(begin);
        }
      }
      else
      {
        *std::vector<unsigned int>::pointer end = v8;
        unint64_t v12 = end + 1;
      }
      a3->__end_ = v12;
      uint64_t v6 = (MIL::Scanner::Token *)((char *)v6 + 32);
    }
    while (v6 != v7);
  }
}

void sub_20F47EFB8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void MIL::Text::Parser::TensorVal::ParseTokens<long long,long long>(uint64_t a1@<X0>, MIL::Scanner::Token **a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  std::vector<unsigned long long>::reserve((void **)a3, (a2[1] - *a2) >> 5);
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  if (*a2 != v7)
  {
    do
    {
      uint64_t v8 = MIL::Text::Parser::TensorVal::ParseToken<long long>(a1, v6);
      uint64_t v9 = v8;
      unint64_t v11 = *(uint64_t **)(a3 + 8);
      unint64_t v10 = *(void *)(a3 + 16);
      if ((unint64_t)v11 >= v10)
      {
        unint64_t v13 = *(uint64_t **)a3;
        uint64_t v14 = ((uint64_t)v11 - *(void *)a3) >> 3;
        unint64_t v15 = v14 + 1;
        if ((unint64_t)(v14 + 1) >> 61) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v16 = v10 - (void)v13;
        if (v16 >> 2 > v15) {
          unint64_t v15 = v16 >> 2;
        }
        if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v17 = v15;
        }
        if (v17)
        {
          uint64_t v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>(a3 + 16, v17);
          unint64_t v13 = *(uint64_t **)a3;
          unint64_t v11 = *(uint64_t **)(a3 + 8);
        }
        else
        {
          uint64_t v18 = 0;
        }
        uint64_t v19 = (uint64_t *)&v18[8 * v14];
        uint64_t *v19 = v9;
        unint64_t v12 = v19 + 1;
        while (v11 != v13)
        {
          uint64_t v20 = *--v11;
          *--uint64_t v19 = v20;
        }
        *(void *)a3 = v19;
        *(void *)(a3 + 8) = v12;
        *(void *)(a3 + 16) = &v18[8 * v17];
        if (v13) {
          operator delete(v13);
        }
      }
      else
      {
        *unint64_t v11 = v8;
        unint64_t v12 = v11 + 1;
      }
      *(void *)(a3 + 8) = v12;
      uint64_t v6 = (MIL::Scanner::Token *)((char *)v6 + 32);
    }
    while (v6 != v7);
  }
}

void sub_20F47F11C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void MIL::Text::Parser::TensorVal::ParseTokens<std::string,std::string>(uint64_t a1@<X0>, MIL::Scanner::Token **a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  std::vector<std::string>::reserve((std::vector<std::string> *)a3, (a2[1] - *a2) >> 5);
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  if (*a2 != v7)
  {
    do
    {
      MIL::Text::Parser::TensorVal::ParseToken<std::string>(v6, a1, &__p);
      unint64_t v9 = *(void *)(a3 + 8);
      unint64_t v8 = *(void *)(a3 + 16);
      if (v9 >= v8)
      {
        unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v9 - *(void *)a3) >> 3);
        unint64_t v12 = v11 + 1;
        if (v11 + 1 > 0xAAAAAAAAAAAAAAALL) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v8 - *(void *)a3) >> 3);
        if (2 * v13 > v12) {
          unint64_t v12 = 2 * v13;
        }
        if (v13 >= 0x555555555555555) {
          unint64_t v14 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v14 = v12;
        }
        __v.__end_cap_.__value_ = (std::allocator<std::string> *)(a3 + 16);
        if (v14) {
          unint64_t v15 = (std::string *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(a3 + 16, v14);
        }
        else {
          unint64_t v15 = 0;
        }
        uint64_t v16 = v15 + v11;
        __v.__first_ = v15;
        __v.__begin_ = v16;
        __v.__end_cap_.__value_ = &v15[v14];
        long long v17 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
        v16->__r_.__value_.__r.__words[2] = __p.__r_.__value_.__r.__words[2];
        *(_OWORD *)&v16->__r_.__value_.__l.__data_ = v17;
        memset(&__p, 0, sizeof(__p));
        __v.__end_ = v16 + 1;
        std::vector<std::string>::__swap_out_circular_buffer((std::vector<std::string> *)a3, &__v);
        uint64_t v18 = *(void *)(a3 + 8);
        std::__split_buffer<std::string>::~__split_buffer(&__v);
        int v19 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
        *(void *)(a3 + 8) = v18;
        if (v19 < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
      }
      else
      {
        long long v10 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
        *(void *)(v9 + 16) = *((void *)&__p.__r_.__value_.__l + 2);
        *(_OWORD *)unint64_t v9 = v10;
        *(void *)(a3 + 8) = v9 + 24;
      }
      uint64_t v6 = (MIL::Scanner::Token *)((char *)v6 + 32);
    }
    while (v6 != v7);
  }
}

void sub_20F47F2D4(_Unwind_Exception *__p, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, std::__split_buffer<std::string> *a7, ...)
{
  va_start(__pa, a7);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)__pa);
  _Unwind_Resume(__p);
}

unsigned __int8 *std::remove[abi:ne180100]<std::__wrap_iter<char *>,char>(void *a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  uint64_t result = (unsigned __int8 *)memchr(a1, (char)*a3, a2 - (unsigned char *)a1);
  if (!result) {
    uint64_t result = a2;
  }
  uint64_t v6 = result + 1;
  if (result != a2 && v6 != a2)
  {
    do
    {
      int v8 = *v6;
      if (v8 != *a3) {
        *result++ = v8;
      }
      ++v6;
    }
    while (v6 != a2);
  }
  return result;
}

void *std::vector<MIL::Scanner::TokenType>::__init_with_size[abi:ne180100]<MIL::Scanner::TokenType*,MIL::Scanner::TokenType*>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = std::vector<float>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_20F47F3E4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<std::vector<unsigned long>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<unsigned long>>,std::reverse_iterator<std::vector<unsigned long>*>,std::reverse_iterator<std::vector<unsigned long>*>,std::reverse_iterator<std::vector<unsigned long>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<unsigned long>>,std::reverse_iterator<std::vector<unsigned long>*>,std::reverse_iterator<std::vector<unsigned long>*>,std::reverse_iterator<std::vector<unsigned long>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v14 = a6;
  *((void *)&v14 + 1) = a7;
  long long v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    uint64_t v9 = a6;
  }
  else
  {
    do
    {
      *(void *)(v7 - 24) = 0;
      *(void *)(v7 - 16) = 0;
      *(void *)(v7 - 8) = 0;
      long long v8 = *(_OWORD *)(a3 - 3);
      a3 -= 3;
      *(_OWORD *)(v7 - 24) = v8;
      *(void *)(v7 - 8) = a3[2];
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      uint64_t v7 = *((void *)&v14 + 1) - 24;
      *((void *)&v14 + 1) -= 24;
    }
    while (a3 != a5);
    uint64_t v9 = v14;
  }
  char v12 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<unsigned long>>,std::reverse_iterator<std::vector<unsigned long>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<unsigned long>>,std::reverse_iterator<std::vector<unsigned long>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::reverse_iterator<std::vector<float>*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void *std::vector<unsigned long>::__init_with_size[abi:ne180100]<unsigned long *,unsigned long *>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = std::vector<unsigned long long>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_20F47F5B4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<MIL::Scanner::Token>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  uint64_t v6 = a2[1];
  while (v4 != v5)
  {
    v4 -= 32;
    MIL::Scanner::Token::Token((_OWORD *)(v6 - 32), v4);
  }
  a2[1] = v6;
  uint64_t v7 = *a1;
  *a1 = v6;
  a2[1] = v7;
  uint64_t v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
}

uint64_t std::__split_buffer<MIL::Scanner::Token>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 32;
    UnknownLocationImpl::~UnknownLocationImpl((UnknownLocationImpl *)(i - 32));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::vector<MIL::Scanner::Token>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        UnknownLocationImpl::~UnknownLocationImpl((UnknownLocationImpl *)(v4 - 32));
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<double>::reserve(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 3)
  {
    if (a2 >> 61) {
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    uint64_t v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>(v3, a2);
    uint64_t v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    uint64_t v9 = &v6[8 * v8];
    long long v10 = (char *)*a1;
    unint64_t v11 = (char *)a1[1];
    char v12 = v7;
    if (v11 != *a1)
    {
      char v12 = v7;
      do
      {
        uint64_t v13 = *((void *)v11 - 1);
        v11 -= 8;
        *((void *)v12 - 1) = v13;
        v12 -= 8;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

void *MIL::PackSubByteVec@<X0>(uint64_t *a1@<X0>, void *a2@<X8>)
{
  uint64_t v2 = a1[1];
  uint64_t v3 = v2 - *a1;
  if (v2 == *a1) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = *a1;
  }
  return MIL::PackSubByteVecImpl<MIL::Int4>(v4, v3, a2);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  uint64_t v2 = a1[1];
  uint64_t v3 = v2 - *a1;
  if (v2 == *a1) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = *a1;
  }
  return MIL::PackSubByteVecImpl<MIL::UInt4>(v4, v3, a2);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  uint64_t v2 = a1[1];
  uint64_t v3 = v2 - *a1;
  if (v2 == *a1) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = *a1;
  }
  return MIL::PackSubByteVecImpl<MIL::UInt2>(v4, v3, a2);
}

{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;

  uint64_t v2 = a1[1];
  uint64_t v3 = v2 - *a1;
  if (v2 == *a1) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = *a1;
  }
  return MIL::PackSubByteVecImpl<MIL::UInt1>(v4, v3, a2);
}

void *MIL::PackSubByteVecImpl<MIL::Int4>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t result = std::vector<unsigned char>::vector(a3, vcvtpd_u64_f64((double)(unint64_t)(4 * a2) * 0.125));
  if (a2)
  {
    unint64_t v7 = 0;
    do
    {
      char v8 = *(unsigned char *)(a1 + v7);
      if ((v8 + 8) >= 0x10u)
      {
        unint64_t v9 = v7;
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::to_string(&v29, *(char *)(a1 + v9));
        unint64_t v11 = std::string::insert(&v29, 0, "Value ");
        long long v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
        v30.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v12;
        v11->__r_.__value_.__l.__size_ = 0;
        v11->__r_.__value_.__r.__words[2] = 0;
        v11->__r_.__value_.__r.__words[0] = 0;
        uint64_t v13 = std::string::append(&v30, " is outside allowed subbyte datatype range [");
        long long v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
        v31.__r_.__value_.__r.__words[2] = v13->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v14;
        v13->__r_.__value_.__l.__size_ = 0;
        v13->__r_.__value_.__r.__words[2] = 0;
        v13->__r_.__value_.__r.__words[0] = 0;
        std::to_string(&v28, -8);
        if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          unint64_t v15 = &v28;
        }
        else {
          unint64_t v15 = (std::string *)v28.__r_.__value_.__r.__words[0];
        }
        if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type size = HIBYTE(v28.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type size = v28.__r_.__value_.__l.__size_;
        }
        long long v17 = std::string::append(&v31, (const std::string::value_type *)v15, size);
        long long v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
        v32.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v32.__r_.__value_.__l.__data_ = v18;
        v17->__r_.__value_.__l.__size_ = 0;
        v17->__r_.__value_.__r.__words[2] = 0;
        v17->__r_.__value_.__r.__words[0] = 0;
        int v19 = std::string::append(&v32, ", ");
        long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
        v33.__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v33.__r_.__value_.__l.__data_ = v20;
        v19->__r_.__value_.__l.__size_ = 0;
        v19->__r_.__value_.__r.__words[2] = 0;
        v19->__r_.__value_.__r.__words[0] = 0;
        std::to_string(&v27, 7);
        if ((v27.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          __int16 v21 = &v27;
        }
        else {
          __int16 v21 = (std::string *)v27.__r_.__value_.__r.__words[0];
        }
        if ((v27.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v22 = HIBYTE(v27.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v22 = v27.__r_.__value_.__l.__size_;
        }
        unint64_t v23 = std::string::append(&v33, (const std::string::value_type *)v21, v22);
        long long v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
        v34.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v34.__r_.__value_.__l.__data_ = v24;
        v23->__r_.__value_.__l.__size_ = 0;
        v23->__r_.__value_.__r.__words[2] = 0;
        v23->__r_.__value_.__r.__words[0] = 0;
        uint64_t v25 = std::string::append(&v34, "].");
        long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
        v35.__r_.__value_.__r.__words[2] = v25->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v35.__r_.__value_.__l.__data_ = v26;
        v25->__r_.__value_.__l.__size_ = 0;
        v25->__r_.__value_.__r.__words[2] = 0;
        v25->__r_.__value_.__r.__words[0] = 0;
        std::runtime_error::runtime_error(exception, &v35);
        exception->__vftable = (std::runtime_error_vtbl *)(MEMORY[0x263F8C370] + 16);
        __cxa_throw(exception, (struct type_info *)off_26412C1D0, MEMORY[0x263F8C050]);
      }
      *(unsigned char *)(*a3 + (v7 >> 1)) |= (v8 & 0xF) << (4 * (v7 & 1));
      ++v7;
    }
    while (a2 != v7);
  }
  return result;
}

void sub_20F47FA30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47)
{
  if (*(char *)(v50 - 57) < 0) {
    operator delete(*(void **)(v50 - 80));
  }
  if (*(char *)(v50 - 89) < 0) {
    operator delete(*(void **)(v50 - 112));
  }
  if (a15 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v50 - 121) < 0) {
    operator delete(*(void **)(v50 - 144));
  }
  if (a47 < 0) {
    operator delete(a42);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a40 < 0) {
    operator delete(a35);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  if (a27 < 0)
  {
    operator delete(a22);
    if ((v49 & 1) == 0)
    {
LABEL_22:
      v52 = *(void **)v47;
      if (*(void *)v47)
      {
        *(void *)(v47 + 8) = v52;
        operator delete(v52);
      }
      _Unwind_Resume(a1);
    }
  }
  else if (!v49)
  {
    goto LABEL_22;
  }
  __cxa_free_exception(v48);
  goto LABEL_22;
}

void *MIL::PackSubByteVec@<X0>(unsigned __int8 **a1@<X0>, void *a2@<X8>)
{
  uint64_t v2 = a1[1];
  uint64_t v3 = v2 - *a1;
  if (v2 == *a1) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = *a1;
  }
  return MIL::PackSubByteVecForNonByteAligned<MIL::UInt6>(v4, v3, a2);
}

{
  unsigned __int8 *v2;
  uint64_t v3;
  unsigned __int8 *v4;

  uint64_t v2 = a1[1];
  uint64_t v3 = v2 - *a1;
  if (v2 == *a1) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = *a1;
  }
  return MIL::PackSubByteVecForNonByteAligned<MIL::UInt3>(v4, v3, a2);
}

void *MIL::PackSubByteVecImpl<MIL::UInt4>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t result = std::vector<unsigned char>::vector(a3, vcvtpd_u64_f64((double)(unint64_t)(4 * a2) * 0.125));
  if (a2)
  {
    unint64_t v7 = 0;
    do
    {
      unsigned int v8 = *(unsigned __int8 *)(a1 + v7);
      if (v8 > 0xF)
      {
        unint64_t v9 = v7;
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::to_string(&v29, *(unsigned __int8 *)(a1 + v9));
        unint64_t v11 = std::string::insert(&v29, 0, "Value ");
        long long v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
        v30.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v12;
        v11->__r_.__value_.__l.__size_ = 0;
        v11->__r_.__value_.__r.__words[2] = 0;
        v11->__r_.__value_.__r.__words[0] = 0;
        uint64_t v13 = std::string::append(&v30, " is outside allowed subbyte datatype range [");
        long long v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
        v31.__r_.__value_.__r.__words[2] = v13->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v14;
        v13->__r_.__value_.__l.__size_ = 0;
        v13->__r_.__value_.__r.__words[2] = 0;
        v13->__r_.__value_.__r.__words[0] = 0;
        std::to_string(&v28, 0);
        if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          unint64_t v15 = &v28;
        }
        else {
          unint64_t v15 = (std::string *)v28.__r_.__value_.__r.__words[0];
        }
        if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type size = HIBYTE(v28.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type size = v28.__r_.__value_.__l.__size_;
        }
        long long v17 = std::string::append(&v31, (const std::string::value_type *)v15, size);
        long long v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
        v32.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v32.__r_.__value_.__l.__data_ = v18;
        v17->__r_.__value_.__l.__size_ = 0;
        v17->__r_.__value_.__r.__words[2] = 0;
        v17->__r_.__value_.__r.__words[0] = 0;
        int v19 = std::string::append(&v32, ", ");
        long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
        v33.__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v33.__r_.__value_.__l.__data_ = v20;
        v19->__r_.__value_.__l.__size_ = 0;
        v19->__r_.__value_.__r.__words[2] = 0;
        v19->__r_.__value_.__r.__words[0] = 0;
        std::to_string(&v27, 15);
        if ((v27.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          __int16 v21 = &v27;
        }
        else {
          __int16 v21 = (std::string *)v27.__r_.__value_.__r.__words[0];
        }
        if ((v27.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v22 = HIBYTE(v27.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v22 = v27.__r_.__value_.__l.__size_;
        }
        unint64_t v23 = std::string::append(&v33, (const std::string::value_type *)v21, v22);
        long long v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
        v34.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v34.__r_.__value_.__l.__data_ = v24;
        v23->__r_.__value_.__l.__size_ = 0;
        v23->__r_.__value_.__r.__words[2] = 0;
        v23->__r_.__value_.__r.__words[0] = 0;
        uint64_t v25 = std::string::append(&v34, "].");
        long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
        v35.__r_.__value_.__r.__words[2] = v25->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v35.__r_.__value_.__l.__data_ = v26;
        v25->__r_.__value_.__l.__size_ = 0;
        v25->__r_.__value_.__r.__words[2] = 0;
        v25->__r_.__value_.__r.__words[0] = 0;
        std::runtime_error::runtime_error(exception, &v35);
        exception->__vftable = (std::runtime_error_vtbl *)(MEMORY[0x263F8C370] + 16);
        __cxa_throw(exception, (struct type_info *)off_26412C1D0, MEMORY[0x263F8C050]);
      }
      *(unsigned char *)(*a3 + (v7 >> 1)) |= (_BYTE)v8 << (4 * (v7 & 1));
      ++v7;
    }
    while (a2 != v7);
  }
  return result;
}

void sub_20F47FDC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47)
{
  if (*(char *)(v50 - 57) < 0) {
    operator delete(*(void **)(v50 - 80));
  }
  if (*(char *)(v50 - 89) < 0) {
    operator delete(*(void **)(v50 - 112));
  }
  if (a15 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v50 - 121) < 0) {
    operator delete(*(void **)(v50 - 144));
  }
  if (a47 < 0) {
    operator delete(a42);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a40 < 0) {
    operator delete(a35);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  if (a27 < 0)
  {
    operator delete(a22);
    if ((v49 & 1) == 0)
    {
LABEL_22:
      v52 = *(void **)v47;
      if (*(void *)v47)
      {
        *(void *)(v47 + 8) = v52;
        operator delete(v52);
      }
      _Unwind_Resume(a1);
    }
  }
  else if (!v49)
  {
    goto LABEL_22;
  }
  __cxa_free_exception(v48);
  goto LABEL_22;
}

void *MIL::PackSubByteVecImpl<MIL::UInt2>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t result = std::vector<unsigned char>::vector(a3, vcvtpd_u64_f64((double)(unint64_t)(2 * a2) * 0.125));
  if (a2)
  {
    unint64_t v7 = 0;
    do
    {
      unsigned int v8 = *(unsigned __int8 *)(a1 + v7);
      if (v8 > 3)
      {
        unint64_t v9 = v7;
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::to_string(&v29, *(unsigned __int8 *)(a1 + v9));
        unint64_t v11 = std::string::insert(&v29, 0, "Value ");
        long long v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
        v30.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v12;
        v11->__r_.__value_.__l.__size_ = 0;
        v11->__r_.__value_.__r.__words[2] = 0;
        v11->__r_.__value_.__r.__words[0] = 0;
        uint64_t v13 = std::string::append(&v30, " is outside allowed subbyte datatype range [");
        long long v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
        v31.__r_.__value_.__r.__words[2] = v13->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v14;
        v13->__r_.__value_.__l.__size_ = 0;
        v13->__r_.__value_.__r.__words[2] = 0;
        v13->__r_.__value_.__r.__words[0] = 0;
        std::to_string(&v28, 0);
        if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          unint64_t v15 = &v28;
        }
        else {
          unint64_t v15 = (std::string *)v28.__r_.__value_.__r.__words[0];
        }
        if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type size = HIBYTE(v28.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type size = v28.__r_.__value_.__l.__size_;
        }
        long long v17 = std::string::append(&v31, (const std::string::value_type *)v15, size);
        long long v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
        v32.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v32.__r_.__value_.__l.__data_ = v18;
        v17->__r_.__value_.__l.__size_ = 0;
        v17->__r_.__value_.__r.__words[2] = 0;
        v17->__r_.__value_.__r.__words[0] = 0;
        int v19 = std::string::append(&v32, ", ");
        long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
        v33.__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v33.__r_.__value_.__l.__data_ = v20;
        v19->__r_.__value_.__l.__size_ = 0;
        v19->__r_.__value_.__r.__words[2] = 0;
        v19->__r_.__value_.__r.__words[0] = 0;
        std::to_string(&v27, 3);
        if ((v27.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          __int16 v21 = &v27;
        }
        else {
          __int16 v21 = (std::string *)v27.__r_.__value_.__r.__words[0];
        }
        if ((v27.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v22 = HIBYTE(v27.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v22 = v27.__r_.__value_.__l.__size_;
        }
        unint64_t v23 = std::string::append(&v33, (const std::string::value_type *)v21, v22);
        long long v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
        v34.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v34.__r_.__value_.__l.__data_ = v24;
        v23->__r_.__value_.__l.__size_ = 0;
        v23->__r_.__value_.__r.__words[2] = 0;
        v23->__r_.__value_.__r.__words[0] = 0;
        uint64_t v25 = std::string::append(&v34, "].");
        long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
        v35.__r_.__value_.__r.__words[2] = v25->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v35.__r_.__value_.__l.__data_ = v26;
        v25->__r_.__value_.__l.__size_ = 0;
        v25->__r_.__value_.__r.__words[2] = 0;
        v25->__r_.__value_.__r.__words[0] = 0;
        std::runtime_error::runtime_error(exception, &v35);
        exception->__vftable = (std::runtime_error_vtbl *)(MEMORY[0x263F8C370] + 16);
        __cxa_throw(exception, (struct type_info *)off_26412C1D0, MEMORY[0x263F8C050]);
      }
      *(unsigned char *)(*a3 + (v7 >> 2)) |= (_BYTE)v8 << (2 * (v7 & 3));
      ++v7;
    }
    while (a2 != v7);
  }
  return result;
}

void sub_20F480158(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47)
{
  if (*(char *)(v50 - 57) < 0) {
    operator delete(*(void **)(v50 - 80));
  }
  if (*(char *)(v50 - 89) < 0) {
    operator delete(*(void **)(v50 - 112));
  }
  if (a15 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v50 - 121) < 0) {
    operator delete(*(void **)(v50 - 144));
  }
  if (a47 < 0) {
    operator delete(a42);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a40 < 0) {
    operator delete(a35);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  if (a27 < 0)
  {
    operator delete(a22);
    if ((v49 & 1) == 0)
    {
LABEL_22:
      v52 = *(void **)v47;
      if (*(void *)v47)
      {
        *(void *)(v47 + 8) = v52;
        operator delete(v52);
      }
      _Unwind_Resume(a1);
    }
  }
  else if (!v49)
  {
    goto LABEL_22;
  }
  __cxa_free_exception(v48);
  goto LABEL_22;
}

void *MIL::PackSubByteVecImpl<MIL::UInt1>@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t result = std::vector<unsigned char>::vector(a3, vcvtpd_u64_f64((double)a2 * 0.125));
  if (a2)
  {
    unint64_t v7 = 0;
    do
    {
      unsigned int v8 = *(unsigned __int8 *)(a1 + v7);
      if (v8 > 1)
      {
        unint64_t v9 = v7;
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::to_string(&v29, *(unsigned __int8 *)(a1 + v9));
        unint64_t v11 = std::string::insert(&v29, 0, "Value ");
        long long v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
        v30.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v12;
        v11->__r_.__value_.__l.__size_ = 0;
        v11->__r_.__value_.__r.__words[2] = 0;
        v11->__r_.__value_.__r.__words[0] = 0;
        uint64_t v13 = std::string::append(&v30, " is outside allowed subbyte datatype range [");
        long long v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
        v31.__r_.__value_.__r.__words[2] = v13->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v14;
        v13->__r_.__value_.__l.__size_ = 0;
        v13->__r_.__value_.__r.__words[2] = 0;
        v13->__r_.__value_.__r.__words[0] = 0;
        std::to_string(&v28, 0);
        if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          unint64_t v15 = &v28;
        }
        else {
          unint64_t v15 = (std::string *)v28.__r_.__value_.__r.__words[0];
        }
        if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type size = HIBYTE(v28.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type size = v28.__r_.__value_.__l.__size_;
        }
        long long v17 = std::string::append(&v31, (const std::string::value_type *)v15, size);
        long long v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
        v32.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v32.__r_.__value_.__l.__data_ = v18;
        v17->__r_.__value_.__l.__size_ = 0;
        v17->__r_.__value_.__r.__words[2] = 0;
        v17->__r_.__value_.__r.__words[0] = 0;
        int v19 = std::string::append(&v32, ", ");
        long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
        v33.__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v33.__r_.__value_.__l.__data_ = v20;
        v19->__r_.__value_.__l.__size_ = 0;
        v19->__r_.__value_.__r.__words[2] = 0;
        v19->__r_.__value_.__r.__words[0] = 0;
        std::to_string(&v27, 1);
        if ((v27.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          __int16 v21 = &v27;
        }
        else {
          __int16 v21 = (std::string *)v27.__r_.__value_.__r.__words[0];
        }
        if ((v27.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v22 = HIBYTE(v27.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v22 = v27.__r_.__value_.__l.__size_;
        }
        unint64_t v23 = std::string::append(&v33, (const std::string::value_type *)v21, v22);
        long long v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
        v34.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v34.__r_.__value_.__l.__data_ = v24;
        v23->__r_.__value_.__l.__size_ = 0;
        v23->__r_.__value_.__r.__words[2] = 0;
        v23->__r_.__value_.__r.__words[0] = 0;
        uint64_t v25 = std::string::append(&v34, "].");
        long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
        v35.__r_.__value_.__r.__words[2] = v25->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v35.__r_.__value_.__l.__data_ = v26;
        v25->__r_.__value_.__l.__size_ = 0;
        v25->__r_.__value_.__r.__words[2] = 0;
        v25->__r_.__value_.__r.__words[0] = 0;
        std::runtime_error::runtime_error(exception, &v35);
        exception->__vftable = (std::runtime_error_vtbl *)(MEMORY[0x263F8C370] + 16);
        __cxa_throw(exception, (struct type_info *)off_26412C1D0, MEMORY[0x263F8C050]);
      }
      *(unsigned char *)(*a3 + (v7 >> 3)) |= (_BYTE)v8 << (v7 & 7);
      ++v7;
    }
    while (a2 != v7);
  }
  return result;
}

void sub_20F4804D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47)
{
  if (*(char *)(v50 - 57) < 0) {
    operator delete(*(void **)(v50 - 80));
  }
  if (*(char *)(v50 - 89) < 0) {
    operator delete(*(void **)(v50 - 112));
  }
  if (a15 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v50 - 121) < 0) {
    operator delete(*(void **)(v50 - 144));
  }
  if (a47 < 0) {
    operator delete(a42);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a40 < 0) {
    operator delete(a35);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  if (a27 < 0)
  {
    operator delete(a22);
    if ((v49 & 1) == 0)
    {
LABEL_22:
      v52 = *(void **)v47;
      if (*(void *)v47)
      {
        *(void *)(v47 + 8) = v52;
        operator delete(v52);
      }
      _Unwind_Resume(a1);
    }
  }
  else if (!v49)
  {
    goto LABEL_22;
  }
  __cxa_free_exception(v48);
  goto LABEL_22;
}

uint64_t MIL::UnPackSubByteVecImpl<MIL::Int4>@<X0>(uint64_t *a1@<X0>, size_t a2@<X1>, void *a3@<X8>)
{
  uint64_t result = (uint64_t)std::vector<MIL::Int4>::vector(a3, a2);
  uint64_t v7 = *a1;
  if (a1[1] - *a1 != vcvtpd_u64_f64((double)(4 * a2) * 0.125))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Unpacking to sub-byte type vector has invalid number of elements. Sub-byte vector with NumElements requires exactly vec.size() bytes.");
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  if (!a2) {
    uint64_t v7 = 0;
  }
  v10[0] = v7;
  v10[1] = a2;
  if (a2)
  {
    unint64_t v8 = 0;
    do
    {
      uint64_t result = MIL::Util::Span<MIL::Int4,18446744073709551615ul>::ValueAt(v10, v8);
      *(unsigned char *)(*a3 + v8++) = result;
    }
    while (a2 != v8);
  }
  return result;
}

void sub_20F480700(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::UnPackSubByteVecImpl<MIL::UInt6>@<X0>(uint64_t *a1@<X0>, size_t a2@<X1>, void *a3@<X8>)
{
  uint64_t result = (uint64_t)std::vector<MIL::UInt6>::vector(a3, a2);
  uint64_t v7 = *a1;
  if (a1[1] - *a1 != vcvtpd_u64_f64((double)(6 * a2) * 0.125))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Unpacking to sub-byte type vector has invalid number of elements. Sub-byte vector with NumElements requires exactly vec.size() bytes.");
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  if (!a2) {
    uint64_t v7 = 0;
  }
  v10[0] = v7;
  v10[1] = a2;
  if (a2)
  {
    unint64_t v8 = 0;
    do
    {
      uint64_t result = MIL::Util::Span<MIL::UInt6,18446744073709551615ul>::ValueAt(v10, v8);
      *(unsigned char *)(*a3 + v8++) = result;
    }
    while (a2 != v8);
  }
  return result;
}

void sub_20F480828(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::UnPackSubByteVecImpl<MIL::UInt4>@<X0>(uint64_t *a1@<X0>, size_t a2@<X1>, void *a3@<X8>)
{
  uint64_t result = (uint64_t)std::vector<MIL::UInt4>::vector(a3, a2);
  uint64_t v7 = *a1;
  if (a1[1] - *a1 != vcvtpd_u64_f64((double)(4 * a2) * 0.125))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Unpacking to sub-byte type vector has invalid number of elements. Sub-byte vector with NumElements requires exactly vec.size() bytes.");
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  if (!a2) {
    uint64_t v7 = 0;
  }
  v10[0] = v7;
  v10[1] = a2;
  if (a2)
  {
    unint64_t v8 = 0;
    do
    {
      uint64_t result = MIL::Util::Span<MIL::UInt4,18446744073709551615ul>::ValueAt(v10, v8);
      *(unsigned char *)(*a3 + v8++) = result;
    }
    while (a2 != v8);
  }
  return result;
}

void sub_20F48094C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::UnPackSubByteVecImpl<MIL::UInt3>@<X0>(uint64_t *a1@<X0>, size_t a2@<X1>, void *a3@<X8>)
{
  uint64_t result = (uint64_t)std::vector<MIL::UInt3>::vector(a3, a2);
  uint64_t v7 = *a1;
  if (a1[1] - *a1 != vcvtpd_u64_f64((double)(3 * a2) * 0.125))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Unpacking to sub-byte type vector has invalid number of elements. Sub-byte vector with NumElements requires exactly vec.size() bytes.");
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  if (!a2) {
    uint64_t v7 = 0;
  }
  v10[0] = v7;
  v10[1] = a2;
  if (a2)
  {
    unint64_t v8 = 0;
    do
    {
      uint64_t result = MIL::Util::Span<MIL::UInt3,18446744073709551615ul>::ValueAt(v10, v8);
      *(unsigned char *)(*a3 + v8++) = result;
    }
    while (a2 != v8);
  }
  return result;
}

void sub_20F480A70(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::UnPackSubByteVecImpl<MIL::UInt2>@<X0>(uint64_t *a1@<X0>, size_t a2@<X1>, void *a3@<X8>)
{
  uint64_t result = (uint64_t)std::vector<MIL::UInt2>::vector(a3, a2);
  uint64_t v7 = *a1;
  if (a1[1] - *a1 != vcvtpd_u64_f64((double)(2 * a2) * 0.125))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Unpacking to sub-byte type vector has invalid number of elements. Sub-byte vector with NumElements requires exactly vec.size() bytes.");
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  if (!a2) {
    uint64_t v7 = 0;
  }
  v10[0] = v7;
  v10[1] = a2;
  if (a2)
  {
    unint64_t v8 = 0;
    do
    {
      uint64_t result = MIL::Util::Span<MIL::UInt2,18446744073709551615ul>::ValueAt(v10, v8);
      *(unsigned char *)(*a3 + v8++) = result;
    }
    while (a2 != v8);
  }
  return result;
}

void sub_20F480B94(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::UnPackSubByteVecImpl<MIL::UInt1>@<X0>(uint64_t *a1@<X0>, size_t a2@<X1>, void *a3@<X8>)
{
  uint64_t result = (uint64_t)std::vector<MIL::UInt1>::vector(a3, a2);
  uint64_t v7 = *a1;
  if (a1[1] - *a1 != vcvtpd_u64_f64((double)a2 * 0.125))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Unpacking to sub-byte type vector has invalid number of elements. Sub-byte vector with NumElements requires exactly vec.size() bytes.");
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  if (!a2) {
    uint64_t v7 = 0;
  }
  v10[0] = v7;
  v10[1] = a2;
  if (a2)
  {
    unint64_t v8 = 0;
    do
    {
      uint64_t result = MIL::Util::Span<MIL::UInt1,18446744073709551615ul>::ValueAt(v10, v8);
      *(unsigned char *)(*a3 + v8++) = result;
    }
    while (a2 != v8);
  }
  return result;
}

void sub_20F480CB4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unsigned char *MIL::Int4::Int4(unsigned char *this, char a2)
{
  if ((a2 + 8) >= 0x10u)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::range_error::range_error[abi:ne180100](exception, "Int4 value is out of range.");
    __cxa_throw(exception, (struct type_info *)off_26412C1D0, MEMORY[0x263F8C050]);
  }
  *this = a2;
  return this;
}

void sub_20F480D64(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::Int4::FromInt(MIL::Int4 *this)
{
  unsigned __int8 v2 = 0;
  MIL::Int4::SetInt(&v2, (int)this);
  return v2;
}

unsigned char *MIL::Int4::SetInt(unsigned char *this, int a2)
{
  if ((a2 + 8) >= 0x10)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::range_error::range_error[abi:ne180100](exception, "Int4 value is out of range.");
    __cxa_throw(exception, (struct type_info *)off_26412C1D0, MEMORY[0x263F8C050]);
  }
  *this = a2;
  return this;
}

void sub_20F480E10(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::Int4::GetInt(MIL::Int4 *this)
{
  return *(char *)this;
}

BOOL MIL::operator==(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 == *a2;
}

{
  return *a1 == *a2;
}

{
  return *a1 == *a2;
}

{
  return *a1 == *a2;
}

{
  return *a1 == *a2;
}

{
  return *a1 == *a2;
}

BOOL MIL::operator!=(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 != *a2;
}

{
  return *a1 != *a2;
}

{
  return *a1 != *a2;
}

{
  return *a1 != *a2;
}

{
  return *a1 != *a2;
}

{
  return *a1 != *a2;
}

unsigned char *MIL::UInt6::UInt6(unsigned char *this, unsigned int a2)
{
  if (a2 >= 0x40)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::range_error::range_error[abi:ne180100](exception, "UInt6 value is out of range.");
    __cxa_throw(exception, (struct type_info *)off_26412C1D0, MEMORY[0x263F8C050]);
  }
  *this = a2;
  return this;
}

void sub_20F480EB4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::UInt6::FromInt(MIL::UInt6 *this)
{
  unsigned __int8 v2 = 0;
  MIL::UInt6::SetInt(&v2, this);
  return v2;
}

unsigned char *MIL::UInt6::SetInt(unsigned char *this, unsigned int a2)
{
  if (a2 >= 0x40)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::range_error::range_error[abi:ne180100](exception, "UInt6 value is out of range.");
    __cxa_throw(exception, (struct type_info *)off_26412C1D0, MEMORY[0x263F8C050]);
  }
  *this = a2;
  return this;
}

void sub_20F480F5C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::UInt6::GetInt(MIL::UInt6 *this)
{
  return *(unsigned __int8 *)this;
}

unsigned char *MIL::UInt4::UInt4(unsigned char *this, unsigned int a2)
{
  if (a2 >= 0x10)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::range_error::range_error[abi:ne180100](exception, "UInt4 value is out of range.");
    __cxa_throw(exception, (struct type_info *)off_26412C1D0, MEMORY[0x263F8C050]);
  }
  *this = a2;
  return this;
}

void sub_20F481000(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::UInt4::FromInt(MIL::UInt4 *this)
{
  unsigned __int8 v2 = 0;
  MIL::UInt4::SetInt(&v2, this);
  return v2;
}

unsigned char *MIL::UInt4::SetInt(unsigned char *this, unsigned int a2)
{
  if (a2 >= 0x10)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::range_error::range_error[abi:ne180100](exception, "UInt4 value is out of range.");
    __cxa_throw(exception, (struct type_info *)off_26412C1D0, MEMORY[0x263F8C050]);
  }
  *this = a2;
  return this;
}

void sub_20F4810A8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::UInt4::GetInt(MIL::UInt4 *this)
{
  return *(unsigned __int8 *)this;
}

unsigned char *MIL::UInt3::UInt3(unsigned char *this, unsigned int a2)
{
  if (a2 >= 8)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::range_error::range_error[abi:ne180100](exception, "UInt3 value is out of range.");
    __cxa_throw(exception, (struct type_info *)off_26412C1D0, MEMORY[0x263F8C050]);
  }
  *this = a2;
  return this;
}

void sub_20F48114C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::UInt3::FromInt(MIL::UInt3 *this)
{
  unsigned __int8 v2 = 0;
  MIL::UInt3::SetInt(&v2, this);
  return v2;
}

unsigned char *MIL::UInt3::SetInt(unsigned char *this, unsigned int a2)
{
  if (a2 >= 8)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::range_error::range_error[abi:ne180100](exception, "UInt3 value is out of range.");
    __cxa_throw(exception, (struct type_info *)off_26412C1D0, MEMORY[0x263F8C050]);
  }
  *this = a2;
  return this;
}

void sub_20F4811F4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::UInt3::GetInt(MIL::UInt3 *this)
{
  return *(unsigned __int8 *)this;
}

unsigned char *MIL::UInt2::UInt2(unsigned char *this, unsigned int a2)
{
  if (a2 >= 4)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::range_error::range_error[abi:ne180100](exception, "UInt2 value is out of range.");
    __cxa_throw(exception, (struct type_info *)off_26412C1D0, MEMORY[0x263F8C050]);
  }
  *this = a2;
  return this;
}

void sub_20F481298(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::UInt2::FromInt(MIL::UInt2 *this)
{
  unsigned __int8 v2 = 0;
  MIL::UInt2::SetInt(&v2, this);
  return v2;
}

unsigned char *MIL::UInt2::SetInt(unsigned char *this, unsigned int a2)
{
  if (a2 >= 4)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::range_error::range_error[abi:ne180100](exception, "UInt2 value is out of range.");
    __cxa_throw(exception, (struct type_info *)off_26412C1D0, MEMORY[0x263F8C050]);
  }
  *this = a2;
  return this;
}

void sub_20F481340(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::UInt2::GetInt(MIL::UInt2 *this)
{
  return *(unsigned __int8 *)this;
}

unsigned char *MIL::UInt1::UInt1(unsigned char *this, unsigned int a2)
{
  if (a2 >= 2)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::range_error::range_error[abi:ne180100](exception, "UInt1 value is out of range.");
    __cxa_throw(exception, (struct type_info *)off_26412C1D0, MEMORY[0x263F8C050]);
  }
  *this = a2;
  return this;
}

void sub_20F4813E4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::UInt1::FromInt(MIL::UInt1 *this)
{
  unsigned __int8 v2 = 0;
  MIL::UInt1::SetInt(&v2, this);
  return v2;
}

unsigned char *MIL::UInt1::SetInt(unsigned char *this, unsigned int a2)
{
  if (a2 >= 2)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::range_error::range_error[abi:ne180100](exception, "UInt1 value is out of range.");
    __cxa_throw(exception, (struct type_info *)off_26412C1D0, MEMORY[0x263F8C050]);
  }
  *this = a2;
  return this;
}

void sub_20F48148C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::UInt1::GetInt(MIL::UInt1 *this)
{
  return *(unsigned __int8 *)this;
}

uint64_t std::hash<MIL::Int4>::operator()(uint64_t a1, char *a2)
{
  return *a2 + 128;
}

uint64_t std::hash<MIL::UInt6>::operator()(uint64_t a1, unsigned __int8 *a2)
{
  return *a2 + 128;
}

uint64_t std::hash<MIL::UInt4>::operator()(uint64_t a1, unsigned __int8 *a2)
{
  return *a2 + 128;
}

uint64_t std::hash<MIL::UInt3>::operator()(uint64_t a1, unsigned __int8 *a2)
{
  return *a2 + 128;
}

uint64_t std::hash<MIL::UInt2>::operator()(uint64_t a1, unsigned __int8 *a2)
{
  return *a2 + 128;
}

uint64_t std::hash<MIL::UInt1>::operator()(uint64_t a1, unsigned __int8 *a2)
{
  return *a2 + 128;
}

void *MIL::PackSubByteVecForNonByteAligned<MIL::UInt6>@<X0>(unsigned __int8 *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v3 = a2;
  v34.__r_.__value_.__s.__data_[0] = 0;
  uint64_t result = std::vector<unsigned char>::vector(a3, vcvtpd_u64_f64((double)(unint64_t)(6 * a2) * 0.125), &v34);
  if (v3)
  {
    unint64_t v7 = 0;
    do
    {
      unsigned int v8 = *a1;
      if (v8 > 0x3F)
      {
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::to_string(&v28, *a1);
        long long v10 = std::string::insert(&v28, 0, "Value ");
        long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
        v29.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v29.__r_.__value_.__l.__data_ = v11;
        v10->__r_.__value_.__l.__size_ = 0;
        v10->__r_.__value_.__r.__words[2] = 0;
        v10->__r_.__value_.__r.__words[0] = 0;
        long long v12 = std::string::append(&v29, " is outside allowed subbyte datatype range [");
        long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
        v30.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v13;
        v12->__r_.__value_.__l.__size_ = 0;
        v12->__r_.__value_.__r.__words[2] = 0;
        v12->__r_.__value_.__r.__words[0] = 0;
        std::to_string(&v27, 0);
        if ((v27.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          long long v14 = &v27;
        }
        else {
          long long v14 = (std::string *)v27.__r_.__value_.__r.__words[0];
        }
        if ((v27.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type size = HIBYTE(v27.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type size = v27.__r_.__value_.__l.__size_;
        }
        uint64_t v16 = std::string::append(&v30, (const std::string::value_type *)v14, size);
        long long v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
        v31.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v17;
        v16->__r_.__value_.__l.__size_ = 0;
        v16->__r_.__value_.__r.__words[2] = 0;
        v16->__r_.__value_.__r.__words[0] = 0;
        long long v18 = std::string::append(&v31, ", ");
        long long v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
        v32.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v32.__r_.__value_.__l.__data_ = v19;
        v18->__r_.__value_.__l.__size_ = 0;
        v18->__r_.__value_.__r.__words[2] = 0;
        v18->__r_.__value_.__r.__words[0] = 0;
        std::to_string(&v26, 63);
        if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          long long v20 = &v26;
        }
        else {
          long long v20 = (std::string *)v26.__r_.__value_.__r.__words[0];
        }
        if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v21 = HIBYTE(v26.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v21 = v26.__r_.__value_.__l.__size_;
        }
        std::string::size_type v22 = std::string::append(&v32, (const std::string::value_type *)v20, v21);
        long long v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
        v33.__r_.__value_.__r.__words[2] = v22->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v33.__r_.__value_.__l.__data_ = v23;
        v22->__r_.__value_.__l.__size_ = 0;
        v22->__r_.__value_.__r.__words[2] = 0;
        v22->__r_.__value_.__r.__words[0] = 0;
        long long v24 = std::string::append(&v33, "].");
        long long v25 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
        v34.__r_.__value_.__r.__words[2] = v24->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v34.__r_.__value_.__l.__data_ = v25;
        v24->__r_.__value_.__l.__size_ = 0;
        v24->__r_.__value_.__r.__words[2] = 0;
        v24->__r_.__value_.__r.__words[0] = 0;
        std::runtime_error::runtime_error(exception, &v34);
        exception->__vftable = (std::runtime_error_vtbl *)(MEMORY[0x263F8C370] + 16);
        __cxa_throw(exception, (struct type_info *)off_26412C1D0, MEMORY[0x263F8C050]);
      }
      *(unsigned char *)(*a3 + (v7 >> 3)) |= (_BYTE)v8 << (v7 & 6);
      if ((v7 & 6) > 2) {
        *(unsigned char *)((v7 >> 3) + *a3 + 1) |= *a1 >> (8 - (v7 & 6));
      }
      ++a1;
      v7 += 6;
      --v3;
    }
    while (v3);
  }
  return result;
}

void sub_20F481790(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47)
{
  if (*(char *)(v50 - 57) < 0) {
    operator delete(*(void **)(v50 - 80));
  }
  if (*(char *)(v50 - 89) < 0) {
    operator delete(*(void **)(v50 - 112));
  }
  if (a15 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v50 - 121) < 0) {
    operator delete(*(void **)(v50 - 144));
  }
  if (a47 < 0) {
    operator delete(a42);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a40 < 0) {
    operator delete(a35);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  if (a27 < 0)
  {
    operator delete(a22);
    if ((v49 & 1) == 0)
    {
LABEL_22:
      v52 = *(void **)v47;
      if (*(void *)v47)
      {
        *(void *)(v47 + 8) = v52;
        operator delete(v52);
      }
      _Unwind_Resume(a1);
    }
  }
  else if (!v49)
  {
    goto LABEL_22;
  }
  __cxa_free_exception(v48);
  goto LABEL_22;
}

void *MIL::PackSubByteVecForNonByteAligned<MIL::UInt3>@<X0>(unsigned __int8 *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v3 = a2;
  v34.__r_.__value_.__s.__data_[0] = 0;
  uint64_t result = std::vector<unsigned char>::vector(a3, vcvtpd_u64_f64((double)(unint64_t)(3 * a2) * 0.125), &v34);
  if (v3)
  {
    unint64_t v7 = 0;
    do
    {
      unsigned int v8 = *a1;
      if (v8 > 7)
      {
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::to_string(&v28, *a1);
        long long v10 = std::string::insert(&v28, 0, "Value ");
        long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
        v29.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v29.__r_.__value_.__l.__data_ = v11;
        v10->__r_.__value_.__l.__size_ = 0;
        v10->__r_.__value_.__r.__words[2] = 0;
        v10->__r_.__value_.__r.__words[0] = 0;
        long long v12 = std::string::append(&v29, " is outside allowed subbyte datatype range [");
        long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
        v30.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v13;
        v12->__r_.__value_.__l.__size_ = 0;
        v12->__r_.__value_.__r.__words[2] = 0;
        v12->__r_.__value_.__r.__words[0] = 0;
        std::to_string(&v27, 0);
        if ((v27.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          long long v14 = &v27;
        }
        else {
          long long v14 = (std::string *)v27.__r_.__value_.__r.__words[0];
        }
        if ((v27.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type size = HIBYTE(v27.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type size = v27.__r_.__value_.__l.__size_;
        }
        uint64_t v16 = std::string::append(&v30, (const std::string::value_type *)v14, size);
        long long v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
        v31.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v17;
        v16->__r_.__value_.__l.__size_ = 0;
        v16->__r_.__value_.__r.__words[2] = 0;
        v16->__r_.__value_.__r.__words[0] = 0;
        long long v18 = std::string::append(&v31, ", ");
        long long v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
        v32.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v32.__r_.__value_.__l.__data_ = v19;
        v18->__r_.__value_.__l.__size_ = 0;
        v18->__r_.__value_.__r.__words[2] = 0;
        v18->__r_.__value_.__r.__words[0] = 0;
        std::to_string(&v26, 7);
        if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          long long v20 = &v26;
        }
        else {
          long long v20 = (std::string *)v26.__r_.__value_.__r.__words[0];
        }
        if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v21 = HIBYTE(v26.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v21 = v26.__r_.__value_.__l.__size_;
        }
        std::string::size_type v22 = std::string::append(&v32, (const std::string::value_type *)v20, v21);
        long long v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
        v33.__r_.__value_.__r.__words[2] = v22->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v33.__r_.__value_.__l.__data_ = v23;
        v22->__r_.__value_.__l.__size_ = 0;
        v22->__r_.__value_.__r.__words[2] = 0;
        v22->__r_.__value_.__r.__words[0] = 0;
        long long v24 = std::string::append(&v33, "].");
        long long v25 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
        v34.__r_.__value_.__r.__words[2] = v24->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v34.__r_.__value_.__l.__data_ = v25;
        v24->__r_.__value_.__l.__size_ = 0;
        v24->__r_.__value_.__r.__words[2] = 0;
        v24->__r_.__value_.__r.__words[0] = 0;
        std::runtime_error::runtime_error(exception, &v34);
        exception->__vftable = (std::runtime_error_vtbl *)(MEMORY[0x263F8C370] + 16);
        __cxa_throw(exception, (struct type_info *)off_26412C1D0, MEMORY[0x263F8C050]);
      }
      *(unsigned char *)(*a3 + (v7 >> 3)) |= (_BYTE)v8 << (v7 & 7);
      if ((v7 & 7) > 5) {
        *(unsigned char *)((v7 >> 3) + *a3 + 1) |= *a1 >> (8 - (v7 & 7));
      }
      ++a1;
      v7 += 3;
      --v3;
    }
    while (v3);
  }
  return result;
}

void sub_20F481B38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47)
{
  if (*(char *)(v50 - 57) < 0) {
    operator delete(*(void **)(v50 - 80));
  }
  if (*(char *)(v50 - 89) < 0) {
    operator delete(*(void **)(v50 - 112));
  }
  if (a15 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v50 - 121) < 0) {
    operator delete(*(void **)(v50 - 144));
  }
  if (a47 < 0) {
    operator delete(a42);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a40 < 0) {
    operator delete(a35);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  if (a27 < 0)
  {
    operator delete(a22);
    if ((v49 & 1) == 0)
    {
LABEL_22:
      v52 = *(void **)v47;
      if (*(void *)v47)
      {
        *(void *)(v47 + 8) = v52;
        operator delete(v52);
      }
      _Unwind_Resume(a1);
    }
  }
  else if (!v49)
  {
    goto LABEL_22;
  }
  __cxa_free_exception(v48);
  goto LABEL_22;
}

uint64_t MIL::Util::Span<MIL::Int4,18446744073709551615ul>::ValueAt(void *a1, unint64_t a2)
{
  if (a1[1] <= a2)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "index out of bounds.");
    __cxa_throw(exception, (struct type_info *)off_26412C1E0, MEMORY[0x263F8C068]);
  }
  unsigned int v2 = ((15 << ((4 * a2) & 4)) & *(unsigned __int8 *)(*a1 + ((a2 >> 1) & 0x1FFFFFFFFFFFFFFFLL))) >> ((4 * a2) & 4);
  if ((v2 & 8) != 0) {
    LOBYTE(v2) = v2 | 0xF0;
  }
  MIL::Int4::Int4(&v5, v2);
  return v5;
}

void sub_20F481D14(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *std::vector<MIL::Int4>::vector(void *a1, size_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<unsigned char>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v4 = (char *)a1[1];
    unsigned __int8 v5 = &v4[a2];
    bzero(v4, a2);
    a1[1] = v5;
  }
  return a1;
}

void sub_20F481D80(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::Util::Span<MIL::UInt6,18446744073709551615ul>::ValueAt(void *a1, unint64_t a2)
{
  if (a1[1] <= a2)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "index out of bounds.");
    __cxa_throw(exception, (struct type_info *)off_26412C1E0, MEMORY[0x263F8C068]);
  }
  unint64_t v2 = (6 * a2) & 6;
  uint64_t v3 = (unsigned __int8 *)(*a1 + ((6 * a2) >> 3));
  unsigned int v4 = ((63 << v2) & *v3) >> v2;
  if (v2 >= 3)
  {
    uint64_t v5 = ((_BYTE)v2 + 13) & 0x10;
    int32x4_t v6 = (int32x4_t)xmmword_20F90EB80;
    int32x4_t v7 = (int32x4_t)xmmword_20F90EB90;
    int32x4_t v8 = (int32x4_t)xmmword_20F90EBA0;
    int32x4_t v9 = (int32x4_t)xmmword_20F90EBB0;
    int64x2_t v10 = (int64x2_t)xmmword_20F90EBC0;
    int64x2_t v11 = (int64x2_t)xmmword_20F90EBD0;
    int64x2_t v12 = (int64x2_t)xmmword_20F90EBE0;
    int64x2_t v13 = (int64x2_t)xmmword_20F90EBF0;
    int64x2_t v14 = (int64x2_t)xmmword_20F90EC00;
    int64x2_t v15 = (int64x2_t)xmmword_20F90EC10;
    int64x2_t v16 = (int64x2_t)xmmword_20F90EC20;
    int8x16_t v17 = 0uLL;
    int64x2_t v18 = (int64x2_t)xmmword_20F90EC30;
    v19.i64[0] = 0x100000001;
    v19.i64[1] = 0x100000001;
    uint64x2_t v20 = (uint64x2_t)vdupq_n_s64(v2 - 3);
    v21.i64[0] = 0x1000000010;
    v21.i64[1] = 0x1000000010;
    int64x2_t v22 = vdupq_n_s64(0x10uLL);
    do
    {
      int8x16_t v23 = v17;
      uint64x2_t v24 = (uint64x2_t)v10;
      uint64x2_t v25 = (uint64x2_t)v11;
      uint64x2_t v26 = (uint64x2_t)v12;
      uint64x2_t v27 = (uint64x2_t)v13;
      uint64x2_t v28 = (uint64x2_t)v14;
      uint64x2_t v29 = (uint64x2_t)v15;
      int8x16_t v17 = vorrq_s8(v17, vuzp1q_s8((int8x16_t)vuzp1q_s16((int16x8_t)vshlq_u32(v19, (uint32x4_t)v9), (int16x8_t)vshlq_u32(v19, (uint32x4_t)v8)), (int8x16_t)vuzp1q_s16((int16x8_t)vshlq_u32(v19, (uint32x4_t)v7), (int16x8_t)vshlq_u32(v19, (uint32x4_t)v6))));
      uint64x2_t v30 = (uint64x2_t)v16;
      int64x2_t v15 = vaddq_s64(v15, v22);
      uint64x2_t v31 = (uint64x2_t)v18;
      int64x2_t v16 = vaddq_s64(v16, v22);
      int64x2_t v18 = vaddq_s64(v18, v22);
      int64x2_t v14 = vaddq_s64(v14, v22);
      int64x2_t v13 = vaddq_s64(v13, v22);
      int64x2_t v12 = vaddq_s64(v12, v22);
      int64x2_t v11 = vaddq_s64(v11, v22);
      int64x2_t v10 = vaddq_s64(v10, v22);
      int32x4_t v9 = vaddq_s32(v9, v21);
      int32x4_t v8 = vaddq_s32(v8, v21);
      int32x4_t v7 = vaddq_s32(v7, v21);
      int32x4_t v6 = vaddq_s32(v6, v21);
      v5 -= 16;
    }
    while (v5);
    int8x16_t v32 = vbslq_s8(vuzp1q_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgtq_u64(v31, v20), (int32x4_t)vcgtq_u64(v30, v20)), (int16x8_t)vuzp1q_s32((int32x4_t)vcgtq_u64(v29, v20), (int32x4_t)vcgtq_u64(v28, v20))), (int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgtq_u64(v27, v20), (int32x4_t)vcgtq_u64(v26, v20)), (int16x8_t)vuzp1q_s32((int32x4_t)vcgtq_u64(v25, v20), (int32x4_t)vcgtq_u64(v24, v20)))), v23, v17);
    *(int8x8_t *)v32.i8 = vorr_s8(*(int8x8_t *)v32.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v32, v32, 8uLL));
    v4 |= ((v32.i32[0] | v32.i32[1] | ((unint64_t)(v32.i64[0] | HIDWORD(v32.i64[0])) >> 16) | ((v32.i32[0] | v32.i32[1] | ((unint64_t)(v32.i64[0] | HIDWORD(v32.i64[0])) >> 16)) >> 8)) & v3[1]) << (8 - v2);
  }
  MIL::UInt6::UInt6(&v35, v4);
  return v35;
}

void sub_20F481FBC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *std::vector<MIL::UInt6>::vector(void *a1, size_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<unsigned char>::__vallocate[abi:ne180100](a1, a2);
    unsigned int v4 = (char *)a1[1];
    uint64_t v5 = &v4[a2];
    bzero(v4, a2);
    a1[1] = v5;
  }
  return a1;
}

void sub_20F482028(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::Util::Span<MIL::UInt4,18446744073709551615ul>::ValueAt(void *a1, unint64_t a2)
{
  if (a1[1] <= a2)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "index out of bounds.");
    __cxa_throw(exception, (struct type_info *)off_26412C1E0, MEMORY[0x263F8C068]);
  }
  MIL::UInt4::UInt4(&v4, ((15 << ((4 * a2) & 4)) & *(unsigned __int8 *)(*a1 + ((a2 >> 1) & 0x1FFFFFFFFFFFFFFFLL))) >> ((4 * a2) & 4));
  return v4;
}

void sub_20F4820DC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *std::vector<MIL::UInt4>::vector(void *a1, size_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<unsigned char>::__vallocate[abi:ne180100](a1, a2);
    unsigned __int8 v4 = (char *)a1[1];
    uint64_t v5 = &v4[a2];
    bzero(v4, a2);
    a1[1] = v5;
  }
  return a1;
}

void sub_20F482148(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::Util::Span<MIL::UInt3,18446744073709551615ul>::ValueAt(void *a1, unint64_t a2)
{
  if (a1[1] <= a2)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "index out of bounds.");
    __cxa_throw(exception, (struct type_info *)off_26412C1E0, MEMORY[0x263F8C068]);
  }
  unint64_t v2 = (3 * a2) & 7;
  uint64_t v3 = (unsigned __int8 *)(*a1 + ((3 * a2) >> 3));
  unsigned int v4 = ((7 << v2) & *v3) >> v2;
  if (v2 >= 6)
  {
    uint64_t v5 = v2 - ((3 * (_BYTE)a2) & 1) - 4;
    int32x2_t v6 = (int32x2_t)0x100000000;
    int8x8_t v7 = 0;
    uint64x2_t v8 = (uint64x2_t)vdupq_n_s64(v2 - 6);
    int64x2_t v9 = (int64x2_t)xmmword_20F90EC30;
    int64x2_t v10 = vdupq_n_s64(2uLL);
    do
    {
      int8x8_t v11 = v7;
      uint64x2_t v12 = (uint64x2_t)v9;
      int8x8_t v7 = vorr_s8(v7, (int8x8_t)vshl_u32((uint32x2_t)0x100000001, (uint32x2_t)v6));
      int64x2_t v9 = vaddq_s64(v9, v10);
      int32x2_t v6 = vadd_s32(v6, (int32x2_t)0x200000002);
      v5 -= 2;
    }
    while (v5);
    int8x8_t v13 = vbsl_s8((int8x8_t)vmovn_s64((int64x2_t)vcgtq_u64(v12, v8)), v11, v7);
    v4 |= ((v13.i32[0] | v13.i32[1]) & v3[1]) << (8 - v2);
  }
  MIL::UInt3::UInt3(&v16, v4);
  return v16;
}

void sub_20F48228C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *std::vector<MIL::UInt3>::vector(void *a1, size_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<unsigned char>::__vallocate[abi:ne180100](a1, a2);
    unsigned int v4 = (char *)a1[1];
    uint64_t v5 = &v4[a2];
    bzero(v4, a2);
    a1[1] = v5;
  }
  return a1;
}

void sub_20F4822F8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::Util::Span<MIL::UInt2,18446744073709551615ul>::ValueAt(void *a1, unint64_t a2)
{
  if (a1[1] <= a2)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "index out of bounds.");
    __cxa_throw(exception, (struct type_info *)off_26412C1E0, MEMORY[0x263F8C068]);
  }
  MIL::UInt2::UInt2(&v4, ((3 << ((2 * a2) & 6)) & *(unsigned __int8 *)(*a1 + ((a2 >> 2) & 0x1FFFFFFFFFFFFFFFLL))) >> ((2 * a2) & 6));
  return v4;
}

void sub_20F4823AC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *std::vector<MIL::UInt2>::vector(void *a1, size_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<unsigned char>::__vallocate[abi:ne180100](a1, a2);
    unsigned __int8 v4 = (char *)a1[1];
    uint64_t v5 = &v4[a2];
    bzero(v4, a2);
    a1[1] = v5;
  }
  return a1;
}

void sub_20F482418(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::Util::Span<MIL::UInt1,18446744073709551615ul>::ValueAt(void *a1, unint64_t a2)
{
  if (a1[1] <= a2)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "index out of bounds.");
    __cxa_throw(exception, (struct type_info *)off_26412C1E0, MEMORY[0x263F8C068]);
  }
  MIL::UInt1::UInt1(&v4, ((1 << (a2 & 7)) & *(unsigned __int8 *)(*a1 + (a2 >> 3))) >> (a2 & 7));
  return v4;
}

void sub_20F4824C8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *std::vector<MIL::UInt1>::vector(void *a1, size_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<unsigned char>::__vallocate[abi:ne180100](a1, a2);
    unsigned __int8 v4 = (char *)a1[1];
    uint64_t v5 = &v4[a2];
    bzero(v4, a2);
    a1[1] = v5;
  }
  return a1;
}

void sub_20F482534(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

__n128 MIL::Transform::NewOperationOutput::NewOperationOutput(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

{
  __n128 result;

  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

{
  __n128 result;

  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

{
  __n128 result;

  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

__n128 MIL::Transform::NewOperationOutput::operator=(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

{
  __n128 result;

  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

__n128 MIL::Transform::NewOperationOutputList::NewOperationOutputList(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

{
  __n128 result;

  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

{
  __n128 result;

  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

{
  __n128 result;

  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

__n128 MIL::Transform::NewOperationOutputList::operator=(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

{
  __n128 result;

  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

void *MIL::Transform::NewOperationOutputList::operator[]@<X0>(void *result@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  *a3 = *result;
  a3[1] = a2;
  return result;
}

uint64_t MIL::Transform::NewOperationOutputList::size(MIL::Transform::NewOperationOutputList *this)
{
  return *((void *)this + 1);
}

uint64_t MIL::Transform::ArgumentDescription::operator=(uint64_t a1, uint64_t a2)
{
  MIL::Util::OpaqueStorage<32ul,8ul,MIL::Transform::ArgumentDescription::ArgumentDescriptionImpl>::operator=(a1, a2);
  return a1;
}

{
  MIL::Util::OpaqueStorage<32ul,8ul,MIL::Transform::ArgumentDescription::ArgumentDescriptionImpl>::operator=(a1, a2);
  return a1;
}

uint64_t MIL::Util::OpaqueStorage<32ul,8ul,MIL::Transform::ArgumentDescription::ArgumentDescriptionImpl>::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 24);
  uint64_t v4 = *(unsigned int *)(a2 + 24);
  if (v3 == -1)
  {
    if (v4 == -1) {
      return a1;
    }
LABEL_5:
    uint64_t v6 = a1;
    ((void (*)(uint64_t *, uint64_t, uint64_t))off_26C25D170[v4])(&v6, a1, a2);
    return a1;
  }
  if (v4 != -1) {
    goto LABEL_5;
  }
  ((void (*)(char *, uint64_t, uint64_t))off_26C25CFE8[v3])(&v7, a1, a2);
  *(_DWORD *)(a1 + 24) = -1;
  return a1;
}

{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  char v7;

  uint64_t v3 = *(unsigned int *)(a1 + 24);
  uint64_t v4 = *(unsigned int *)(a2 + 24);
  if (v3 == -1)
  {
    if (v4 == -1) {
      return a1;
    }
LABEL_5:
    uint64_t v6 = a1;
    ((void (*)(uint64_t *, uint64_t, uint64_t))off_26C25D1D8[v4])(&v6, a1, a2);
    return a1;
  }
  if (v4 != -1) {
    goto LABEL_5;
  }
  ((void (*)(char *, uint64_t, uint64_t))off_26C25CFE8[v3])(&v7, a1, a2);
  *(_DWORD *)(a1 + 24) = -1;
  return a1;
}

MIL::Transform::ArgumentDescription *MIL::Transform::ArgumentDescription::ArgumentDescription(MIL::Transform::ArgumentDescription *this, const MIL::Matching::ArgumentView *a2)
{
  MIL::MatchingPrivate::MatchPrivate::GetIRArgumentFromArgumentView((uint64_t)a2, &v7);
  uint64_t v4 = v7;
  uint64_t v3 = v8;
  uint64_t v7 = 0;
  uint64x2_t v8 = 0;
  *(void *)this = v4;
  *((void *)this + 1) = v3;
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    uint64_t v5 = v8;
    *((_DWORD *)this + 6) = 1;
    if (v5) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v5);
    }
  }
  else
  {
    *((_DWORD *)this + 6) = 1;
  }
  return this;
}

void MIL::Transform::ArgumentDescription::ArgumentDescription(MIL::Transform::ArgumentDescription *this, const MIL::Matching::OutputView *a2)
{
  uint64_t Name = MIL::Matching::OutputView::GetName(a2);
  if (*(char *)(Name + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)Name, *(void *)(Name + 8));
  }
  else
  {
    long long v3 = *(_OWORD *)Name;
    __p.__r_.__value_.__r.__words[2] = *(void *)(Name + 16);
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v3;
  }
  MIL::IRArgument::Make();
}

void sub_20F4828C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a15) {
    MIL::Builder::OperationBuilder::OperationBuilderImpl::RenameInput();
  }
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::Util::OpaqueStorage<32ul,8ul,MIL::Transform::ArgumentDescription::ArgumentDescriptionImpl>::OpaqueStorage<std::in_place_type_t<anonymous namespace'::Argument> const&,std::unique_ptr<MIL::IRArgument>>(uint64_t a1, uint64_t *a2)
{
  std::shared_ptr<MIL::IRArgument>::shared_ptr[abi:ne180100]<MIL::IRArgument,std::default_delete<MIL::IRArgument>,void>(&v5, a2);
  long long v3 = v6;
  *(void *)a1 = v5;
  *(void *)(a1 + 8) = v3;
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    if (v6) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v6);
    }
  }
  *(_DWORD *)(a1 + 24) = 1;
  return a1;
}

__n128 MIL::Transform::ArgumentDescription::ArgumentDescription(MIL::Transform::ArgumentDescription *this, __n128 *a2)
{
  __n128 result = *a2;
  *(__n128 *)this = *a2;
  *((_DWORD *)this + 6) = 2;
  return result;
}

{
  __n128 result;

  __n128 result = *a2;
  *(__n128 *)this = *a2;
  *((_DWORD *)this + 6) = 2;
  return result;
}

void MIL::Transform::ArgumentDescription::ArgumentDescription(uint64_t a1, void *a2)
{
  *a2 = 0;
  a2[1] = 0;
  MIL::IRArgument::Make();
}

void sub_20F482A10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    MIL::Builder::OperationBuilder::OperationBuilderImpl::RenameInput();
  }
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::Transform::ArgumentDescription::ArgumentDescription(uint64_t this, int a2)
{
  *(void *)this = a2;
  *(_DWORD *)(this + 8) = 9;
  *(_DWORD *)(this + 24) = 3;
  return this;
}

{
  *(void *)this = a2;
  *(_DWORD *)(this + 8) = 9;
  *(_DWORD *)(this + 24) = 3;
  return this;
}

{
  *(void *)this = a2;
  *(_DWORD *)(this + 8) = 10;
  *(_DWORD *)(this + 24) = 3;
  return this;
}

{
  *(void *)this = a2;
  *(_DWORD *)(this + 8) = 10;
  *(_DWORD *)(this + 24) = 3;
  return this;
}

{
  *(void *)this = a2;
  *(_DWORD *)(this + 8) = 11;
  *(_DWORD *)(this + 24) = 3;
  return this;
}

{
  *(void *)this = a2;
  *(_DWORD *)(this + 8) = 11;
  *(_DWORD *)(this + 24) = 3;
  return this;
}

uint64_t MIL::Transform::ArgumentDescription::ArgumentDescription(uint64_t this, uint64_t a2)
{
  *(void *)this = a2;
  *(_DWORD *)(this + 8) = 12;
  *(_DWORD *)(this + 24) = 3;
  return this;
}

{
  *(void *)this = a2;
  *(_DWORD *)(this + 8) = 12;
  *(_DWORD *)(this + 24) = 3;
  return this;
}

{
  *(void *)this = a2;
  *(_DWORD *)(this + 8) = 17;
  *(_DWORD *)(this + 24) = 4;
  return this;
}

{
  *(void *)this = a2;
  *(_DWORD *)(this + 8) = 17;
  *(_DWORD *)(this + 24) = 4;
  return this;
}

uint64_t MIL::Transform::ArgumentDescription::ArgumentDescription(uint64_t this, unsigned int a2)
{
  *(void *)this = a2;
  *(_DWORD *)(this + 8) = 14;
  *(_DWORD *)(this + 24) = 4;
  return this;
}

{
  *(void *)this = a2;
  *(_DWORD *)(this + 8) = 14;
  *(_DWORD *)(this + 24) = 4;
  return this;
}

{
  *(void *)this = a2;
  *(_DWORD *)(this + 8) = 15;
  *(_DWORD *)(this + 24) = 4;
  return this;
}

{
  *(void *)this = a2;
  *(_DWORD *)(this + 8) = 15;
  *(_DWORD *)(this + 24) = 4;
  return this;
}

{
  *(void *)this = a2;
  *(_DWORD *)(this + 8) = 16;
  *(_DWORD *)(this + 24) = 4;
  return this;
}

{
  *(void *)this = a2;
  *(_DWORD *)(this + 8) = 16;
  *(_DWORD *)(this + 24) = 4;
  return this;
}

uint64_t MIL::Transform::ArgumentDescription::ArgumentDescription(uint64_t result, __int16 a2)
{
  *(_WORD *)__n128 result = a2;
  *(_DWORD *)(result + 24) = 7;
  return result;
}

{
  *(_WORD *)__n128 result = a2;
  *(_DWORD *)(result + 24) = 7;
  return result;
}

{
  *(_WORD *)__n128 result = a2;
  *(_DWORD *)(result + 24) = 8;
  return result;
}

{
  *(_WORD *)__n128 result = a2;
  *(_DWORD *)(result + 24) = 8;
  return result;
}

uint64_t MIL::Transform::ArgumentDescription::ArgumentDescription(uint64_t result, char a2)
{
  *(unsigned char *)__n128 result = a2;
  *(_DWORD *)(result + 24) = 9;
  return result;
}

{
  *(unsigned char *)__n128 result = a2;
  *(_DWORD *)(result + 24) = 9;
  return result;
}

{
  *(unsigned char *)__n128 result = a2;
  *(_DWORD *)(result + 24) = 10;
  return result;
}

{
  *(unsigned char *)__n128 result = a2;
  *(_DWORD *)(result + 24) = 10;
  return result;
}

uint64_t MIL::Transform::ArgumentDescription::ArgumentDescription(uint64_t this, float a2)
{
  *(float *)this = a2;
  *(_DWORD *)(this + 24) = 5;
  return this;
}

{
  *(float *)this = a2;
  *(_DWORD *)(this + 24) = 5;
  return this;
}

uint64_t MIL::Transform::ArgumentDescription::ArgumentDescription(uint64_t this, double a2)
{
  *(double *)this = a2;
  *(_DWORD *)(this + 24) = 6;
  return this;
}

{
  *(double *)this = a2;
  *(_DWORD *)(this + 24) = 6;
  return this;
}

uint64_t MIL::Transform::ArgumentDescription::ArgumentDescription(uint64_t this, char a2)
{
  *(unsigned char *)this = a2;
  *(_DWORD *)(this + 24) = 0;
  return this;
}

{
  *(unsigned char *)this = a2;
  *(_DWORD *)(this + 24) = 0;
  return this;
}

MIL::Transform::ArgumentDescription *MIL::Transform::ArgumentDescription::ArgumentDescription(MIL::Transform::ArgumentDescription *this, const char *__s)
{
  *(unsigned char *)this = 0;
  *((_DWORD *)this + 6) = 0;
  size_t v4 = strlen(__s);
  MIL::Transform::ArgumentDescription::ArgumentDescriptionImpl::SetString((uint64_t)this, __s, v4);
  return this;
}

void sub_20F482D14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void MIL::Transform::ArgumentDescription::ArgumentDescriptionImpl::SetString(uint64_t a1, const void *a2, size_t a3)
{
  if (a3 > 0x17)
  {
    if (a3 >= 0x7FFFFFFFFFFFFFF8) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    __p[1] = (void *)a3;
    unint64_t v8 = ((a3 | 7) + 1) | 0x8000000000000000;
    __p[0] = operator new((a3 | 7) + 1);
    memmove(__p[0], a2, a3);
    *((unsigned char *)__p[0] + a3) = 0;
    if (SHIBYTE(v8) < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    uint64_t v6 = *(unsigned int *)(a1 + 24);
    if (v6 != -1) {
      ((void (*)(void **, uint64_t))off_26C25CFE8[v6])(__p, a1);
    }
    *(_DWORD *)(a1 + 24) = -1;
    *(_DWORD *)(a1 + 24) = 11;
  }
}

void sub_20F482E1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::Transform::ArgumentDescription::ArgumentDescription(uint64_t a1, void *a2)
{
  *(unsigned char *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  size_t v3 = a2[1];
  if (*((char *)a2 + 23) >= 0)
  {
    size_t v4 = *((unsigned __int8 *)a2 + 23);
  }
  else
  {
    a2 = (void *)*a2;
    size_t v4 = v3;
  }
  MIL::Transform::ArgumentDescription::ArgumentDescriptionImpl::SetString(a1, a2, v4);
  return a1;
}

void sub_20F482E84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t MIL::Transform::ArgumentDescription::ArgumentDescription(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  MIL::Transform::ArgumentDescription::ArgumentDescriptionImpl::SetString(a1, a2);
  return a1;
}

void sub_20F482ECC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

unsigned char *MIL::Transform::ArgumentDescription::ArgumentDescriptionImpl::SetString(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(unsigned __int8 *)(a2 + 23);
  if ((v4 & 0x80u) != 0) {
    unint64_t v4 = *(void *)(a2 + 8);
  }
  if (v4 > 0x17)
  {
  }
  else
  {
    uint64_t v5 = *(unsigned int *)(a1 + 24);
    if (v5 != -1) {
      ((void (*)(char *, uint64_t))off_26C25CFE8[v5])(&v10, a1);
    }
    *(_DWORD *)(a1 + 24) = -1;
    int v6 = *(char *)(a2 + 23);
    if (v6 >= 0) {
      uint64_t v7 = (const void *)a2;
    }
    else {
      uint64_t v7 = *(const void **)a2;
    }
    if (v6 >= 0) {
      size_t v8 = *(unsigned __int8 *)(a2 + 23);
    }
    else {
      size_t v8 = *(void *)(a2 + 8);
    }
    *(_DWORD *)(a1 + 24) = 11;
  }
  return result;
}

unsigned __int8 *MIL::Transform::ArgumentDescription::ArgumentDescriptionImpl::CreateIRArgument@<X0>(unsigned __int8 *result@<X0>, _anonymous_namespace_ *a2@<X1>, uint64_t a3@<X2>, void *a4@<X3>, uint64_t a5@<X8>)
{
  int v6 = result;
  int v8 = *((_DWORD *)result + 6);
  switch(v8)
  {
    case 12:
      MIL::IRTensorValueType::MakeScalar();
    case 11:
      MIL::IRTensorValueType::MakeScalar();
    case 10:
      char v10 = (_anonymous_namespace_ *)*result;
      uint64_t v11 = 25;
      goto LABEL_17;
    case 9:
      char v10 = (_anonymous_namespace_ *)*result;
      uint64_t v11 = 24;
      goto LABEL_17;
    case 8:
      char v10 = (_anonymous_namespace_ *)*(unsigned __int16 *)result;
      uint64_t v11 = 4;
      goto LABEL_17;
    case 7:
      char v10 = (_anonymous_namespace_ *)*(unsigned __int16 *)result;
      uint64_t v11 = 7;
      goto LABEL_17;
    case 6:
      char v10 = *(_anonymous_namespace_ **)result;
      uint64_t v11 = 6;
      goto LABEL_17;
    case 5:
      char v10 = (_anonymous_namespace_ *)*(unsigned int *)result;
      uint64_t v11 = 5;
LABEL_17:
    case 4:
      int v36 = *((_DWORD *)result + 2);
      uint64x2_t v12 = *(uint64_t ***)(a3 + 16);
      if (v12)
      {
        char v13 = 0;
        char v14 = 0;
        char v15 = 0;
        char v16 = 0;
        do
        {
          int8x16_t v17 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t *))(*v12[2] + 24))(v12[2]);
          if (v17)
          {
            uint32x4_t v19 = v17;
            {
              switch((*(unsigned int (**)(_anonymous_namespace_ *))(*(void *)v19 + 88))(v19))
              {
                case 0xEu:
                  goto LABEL_27;
                case 0xFu:
                  char v14 = 1;
                  break;
                case 0x10u:
                  char v15 = 1;
                  break;
                case 0x11u:
                  char v16 = 1;
                  break;
                case 0x12u:
                  char v16 = 1;
                  char v15 = 1;
                  char v14 = 1;
LABEL_27:
                  char v13 = 1;
                  break;
                default:
                  break;
              }
            }
          }
          uint64x2_t v12 = (uint64_t **)*v12;
        }
        while (v12);
      }
      else
      {
        char v16 = 0;
        char v15 = 0;
        char v14 = 0;
        char v13 = 0;
      }
      switch(v36)
      {
        case 14:
          if (v13) {
            MIL::IRTensorValueType::MakeScalar();
          }
          goto LABEL_53;
        case 15:
LABEL_53:
          if (v14) {
            MIL::IRTensorValueType::MakeScalar();
          }
          goto LABEL_55;
        case 16:
LABEL_55:
          if (v15) {
            MIL::IRTensorValueType::MakeScalar();
          }
          goto LABEL_57;
        case 17:
LABEL_57:
          if (v16) {
            MIL::IRTensorValueType::MakeScalar();
          }
          exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
          std::logic_error::logic_error(exception, &v38);
          exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
          __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
        default:
          break;
      }
LABEL_78:
      unsigned __int8 v35 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::logic_error::logic_error(v35, "Unexpected type");
      goto LABEL_80;
    case 3:
      int v37 = *((_DWORD *)result + 2);
      uint64x2_t v20 = *(uint64_t ***)(a3 + 16);
      if (v20)
      {
        char v21 = 0;
        char v22 = 0;
        char v23 = 0;
        char v24 = 0;
        do
        {
          uint64x2_t v25 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t *))(*v20[2] + 24))(v20[2]);
          if (v25)
          {
            uint64x2_t v27 = v25;
            {
              switch((*(unsigned int (**)(_anonymous_namespace_ *))(*(void *)v27 + 88))(v27))
              {
                case 9u:
                  goto LABEL_42;
                case 0xAu:
                  char v22 = 1;
                  break;
                case 0xBu:
                  char v23 = 1;
                  break;
                case 0xCu:
                  char v24 = 1;
                  break;
                case 0x12u:
                  char v24 = 1;
                  char v23 = 1;
                  char v22 = 1;
LABEL_42:
                  char v21 = 1;
                  break;
                default:
                  break;
              }
            }
          }
          uint64x2_t v20 = (uint64_t **)*v20;
        }
        while (v20);
      }
      else
      {
        char v24 = 0;
        char v23 = 0;
        char v22 = 0;
        char v21 = 0;
      }
      switch(v37)
      {
        case 9:
          if (v21) {
            MIL::IRTensorValueType::MakeScalar();
          }
          goto LABEL_66;
        case 10:
LABEL_66:
          if (v22) {
            MIL::IRTensorValueType::MakeScalar();
          }
          goto LABEL_68;
        case 11:
LABEL_68:
          if (v23) {
            MIL::IRTensorValueType::MakeScalar();
          }
          goto LABEL_70;
        case 12:
LABEL_70:
          if (v24) {
            MIL::IRTensorValueType::MakeScalar();
          }
          std::string v34 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
          std::logic_error::logic_error(v34, &v38);
          v34->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
          __cxa_throw(v34, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
        default:
          goto LABEL_78;
      }
      goto LABEL_78;
    case 2:
      if (*(void *)result < (unint64_t)((uint64_t)(a4[1] - *a4) >> 4))
      {
        uint64x2_t v28 = (MIL::Builder::OperationBuilder **)(*a4 + 16 * *(void *)result);
        uint64_t v39 = 0;
        uint64_t v40 = 0;
        uint64_t Operator = MIL::Builder::OperationBuilder::GetOperator(*v28);
        if ((*(unsigned int (**)(uint64_t))(*(void *)Operator + 104))(Operator)) {
          MIL::Builder::OperationBuilder::CreateOperation((const void ****)*v28);
        }
        Outputint Type = (MIL::IRTypedArgument *)MIL::Builder::OperationBuilder::GetOutputType((MIL::Builder::OperationBuilder::OperationBuilderImpl **)*v28, *((void *)v6 + 1));
        MIL::IRTypedArgument::Make(OutputType, v33);
      }
      std::vector<MIL::IRDimension const*>::__throw_out_of_range[abi:ne180100]();
  }
  if (v8 != 1)
  {
    if (!v8) {
      MIL::IRTensorValueType::MakeScalar();
    }
    unsigned __int8 v35 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v35, "Trying to visit a std::variant that is in an invalid state");
LABEL_80:
    __cxa_throw(v35, MEMORY[0x263F8C1E0], MEMORY[0x263F8C048]);
  }
  uint64_t v30 = *((void *)result + 1);
  *(void *)a5 = *(void *)result;
  *(void *)(a5 + 8) = v30;
  if (v30) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v30 + 8), 1uLL, memory_order_relaxed);
  }
  *(unsigned char *)(a5 + 40) = 0;
  *(void *)(a5 + 16) = 0;
  *(void *)(a5 + 24) = 0;
  *(unsigned char *)(a5 + 32) = 0;
  return result;
}

void sub_20F484220(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, std::__shared_weak_count *a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25)
{
  if (a23) {
    MIL::Builder::OperationBuilder::OperationBuilderImpl::RenameInput();
  }
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a16);
  }
  if (a14) {
    (*(void (**)(uint64_t))(*(void *)a14 + 8))(a14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::TransformPrivate::ArgumentDescriptionPrivate::CreateNewOperationOutput@<X0>(uint64_t this@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  *a3 = this;
  a3[1] = a2;
  return this;
}

uint64_t std::variant<anonymous namespace'::BooleanScalar,anonymous namespace'::Argument,anonymous namespace'::FromNewOperationOutput,anonymous namespace'::SignedIntegerScalar,anonymous namespace'::UnsignedIntegerScalar,anonymous namespace'::FloatScalar<float>,anonymous namespace'::FloatScalar<double>,anonymous namespace'::FloatScalar<MIL::Bf16>,anonymous namespace'::FloatScalar<MIL::Fp16>,anonymous namespace'::FloatScalar<MIL::Fp8E4M3FN>,anonymous namespace'::FloatScalar<MIL::Fp8E5M2>,anonymous namespace'::SmallStringConstant,anonymous namespace'::LargeStringConstant>::emplace[abi:ne180100]<anonymous namespace'::LargeStringConstant,std::string,12ul,0>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 24);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))off_26C25CFE8[v4])(&v7, a1);
  }
  *(_DWORD *)(a1 + 24) = -1;
  uint64_t v5 = (char *)operator new(0x30uLL);
  *((void *)v5 + 1) = 0;
  *((void *)v5 + 2) = 0;
  *(void *)uint64_t v5 = &unk_26C25D060;
  *(_OWORD *)(v5 + 24) = *(_OWORD *)a2;
  *((void *)v5 + 5) = *(void *)(a2 + 16);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a1 = v5 + 24;
  *(void *)(a1 + 8) = v5;
  *(_DWORD *)(a1 + 24) = 12;
  return a1;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILST_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEEEEEDcSV_DpT0_(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(std::__shared_weak_count **)(a2 + 8);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm12EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILST_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEEEEEDcSV_DpT0_(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(std::__shared_weak_count **)(a2 + 8);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
}

unsigned char *anonymous namespace'::SmallStringConstant::SmallStringConstant(unsigned char *a1, const void *a2, size_t a3)
{
  *a1 = a3;
  if (a3 >= 0x18)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "String is too long");
    __cxa_throw(exception, MEMORY[0x263F8C1E0], MEMORY[0x263F8C048]);
  }
  memcpy(a1 + 1, a2, a3);
  return a1;
}

void sub_20F484764(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<std::string>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C25D060;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::string>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C25D060;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21056C700);
}

void std::__shared_ptr_emplace<std::string>::__on_zero_shared(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
}

void anonymous namespace'::CreateIRArgumentFromFloatScalar(_anonymous_namespace_ *CanTakeScalar, const MIL::IRTensorValueType *a2, _anonymous_namespace_ *a3, uint64_t a4)
{
  int v4 = (int)a2;
  double v5 = *(double *)&CanTakeScalar;
  int v6 = *(uint64_t ***)(a4 + 16);
  if (v6)
  {
    char v7 = 0;
    char v8 = 0;
    char v9 = 0;
    char v10 = 0;
    char v11 = 0;
    char v12 = 0;
    do
    {
      CanTakeScalar = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t *))(*v6[2] + 24))(v6[2]);
      if (CanTakeScalar)
      {
        char v13 = CanTakeScalar;
        if (CanTakeScalar)
        {
          CanTakeScalar = (_anonymous_namespace_ *)(*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)v13 + 88))(v13);
          if ((int)CanTakeScalar <= 17)
          {
            switch((int)CanTakeScalar)
            {
              case 4:
                char v8 = 1;
                goto LABEL_17;
              case 5:
                char v9 = 1;
                goto LABEL_17;
              case 6:
                char v10 = 1;
                goto LABEL_17;
              case 7:
                goto LABEL_13;
              default:
                goto LABEL_17;
            }
          }
          switch(CanTakeScalar)
          {
            case 0x12:
              char v12 = 1;
              char v11 = 1;
              char v10 = 1;
              char v9 = 1;
              char v8 = 1;
LABEL_13:
              char v7 = 1;
              break;
            case 0x18:
              char v11 = 1;
              break;
            case 0x19:
              char v12 = 1;
              break;
          }
        }
      }
LABEL_17:
      int v6 = (uint64_t **)*v6;
    }
    while (v6);
    if (v7) {
      goto LABEL_26;
    }
  }
  else
  {
    char v12 = 0;
    char v11 = 0;
    char v10 = 0;
    char v9 = 0;
    char v8 = 0;
    char v7 = 0;
  }
  if ((v8 & 1) == 0 && (v9 & 1) == 0 && (v10 & 1) == 0 && (v12 & 1) == 0 && (v11 & 1) == 0)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, &v22);
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
LABEL_26:
  float Float = *(float *)&v5;
  switch(v4)
  {
    case 4:
      if (v8) {
      LOWORD(v22.__r_.__value_.__l.__data_) = LOWORD(v5);
      }
      float Float = MIL::Fp16::GetFloat((MIL::Fp16 *)&v22);
      goto LABEL_47;
    case 5:
LABEL_47:
      if (v9) {
        goto LABEL_48;
      }
      goto LABEL_41;
    case 6:
      double v15 = v5;
      if (v10) {
        goto LABEL_42;
      }
      if (v9)
      {
        float v16 = v5;
      }
      goto LABEL_43;
    case 7:
      if (v7) {
        MIL::IRTensorValueType::MakeScalar();
      }
      LOWORD(v22.__r_.__value_.__l.__data_) = LOWORD(v5);
      float Float = MIL::Bf16::GetFloat((MIL::Bf16 *)&v22);
      if ((v9 & 1) == 0) {
        goto LABEL_41;
      }
      goto LABEL_48;
    default:
      if (v4 == 25)
      {
        if (v12) {
          MIL::IRTensorValueType::MakeScalar();
        }
        v22.__r_.__value_.__s.__data_[0] = LOBYTE(v5);
        float Float = MIL::Fp8E5M2::GetFloat((MIL::Fp8E5M2 *)&v22);
        if ((v9 & 1) == 0)
        {
LABEL_41:
          double v15 = Float;
          if (v10) {
LABEL_42:
          }
            MIL::IRTensorValueType::MakeScalar();
LABEL_43:
          float v17 = v15;
          MIL::Fp16::FromFloat(CanTakeScalar, v17);
        }
      }
      else
      {
        if (v4 != 24)
        {
          uint32x4_t v19 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
          std::logic_error::logic_error(v19, "Unexpected type");
          __cxa_throw(v19, MEMORY[0x263F8C1E0], MEMORY[0x263F8C048]);
        }
        if (v11) {
          MIL::IRTensorValueType::MakeScalar();
        }
        v22.__r_.__value_.__s.__data_[0] = LOBYTE(v5);
        float Float = MIL::Fp8E4M3FN::GetFloat((MIL::Fp8E4M3FN *)&v22);
        if ((v9 & 1) == 0) {
          goto LABEL_41;
        }
      }
LABEL_48:
  }
}

void sub_20F484FCC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19)
{
  if (__p) {
    MIL::Builder::OperationBuilder::OperationBuilderImpl::RenameInput();
  }
  _Unwind_Resume(exception_object);
}

uint64_t anonymous namespace'::CanTakeScalar(_anonymous_namespace_ *this, const MIL::IRTensorValueType *a2)
{
  if (MIL::IRTensorValueType::IsScalar(this)) {
    return 1;
  }
  int v4 = (void *)(*(uint64_t (**)(_anonymous_namespace_ *))(*(void *)this + 96))(this);
  if (v4[1] - *v4 == 8) {
    return (*(unsigned int (**)(_anonymous_namespace_ *))(*(void *)this + 104))(this) ^ 1;
  }
  else {
    return 0;
  }
}

uint64_t anonymous namespace'::MakeCantConvertErrorMessage(int a1, uint64_t a2)
{
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v17);
  int v4 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)"Can't convert a scalar of type ", 31);
  MIL::IRDataTypeToString(a1, &__p);
  if ((v16 & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = __p;
  }
  if ((v16 & 0x80u) == 0) {
    uint64_t v6 = v16;
  }
  else {
    uint64_t v6 = v15;
  }
  char v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)p_p, v6);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)" to any of the following types: ", 32);
  if ((char)v16 < 0) {
    operator delete(__p);
  }
  char v8 = *(void **)(a2 + 16);
  if (v8)
  {
    char v9 = 1;
    do
    {
      uint64_t v10 = v8[2];
      if ((v9 & 1) == 0) {
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)", ", 2);
      }
      (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v10 + 56))(&__p, v10);
      if ((v16 & 0x80u) == 0) {
        char v11 = &__p;
      }
      else {
        char v11 = __p;
      }
      if ((v16 & 0x80u) == 0) {
        uint64_t v12 = v16;
      }
      else {
        uint64_t v12 = v15;
      }
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)v11, v12);
      if ((char)v16 < 0) {
        operator delete(__p);
      }
      char v9 = 0;
      char v8 = (void *)*v8;
    }
    while (v8);
  }
  std::stringbuf::str();
  v17[0] = *MEMORY[0x263F8C2C8];
  *(void *)((char *)v17 + *(void *)(v17[0] - 24)) = *(void *)(MEMORY[0x263F8C2C8] + 24);
  v17[1] = MEMORY[0x263F8C318] + 16;
  if (v18 < 0) {
    operator delete((void *)v17[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x21056C620](&v19);
}

void sub_20F48541C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
}

void anonymous namespace'::MakeFloat16Value()
{
}

void sub_20F48553C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8))(a10);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::MakeFloat32Value(_anonymous_namespace_ *this, MIL::MILContext *a2, float a3)
{
}

void sub_20F485674(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8))(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::Util::OpaqueStorage<32ul,8ul,MIL::Transform::ArgumentDescription::ArgumentDescriptionImpl>::OpaqueStorage(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = 0;
  *(_DWORD *)(a1 + 24) = -1;
  uint64_t v3 = *(unsigned int *)(a2 + 24);
  if (v3 != -1)
  {
    ((void (*)(char *, uint64_t, uint64_t))off_26C25D0A0[v3])(&v5, a1, a2);
    *(_DWORD *)(a1 + 24) = v3;
  }
  return a1;
}

{
  uint64_t v3;
  char v5;

  *(unsigned char *)a1 = 0;
  *(_DWORD *)(a1 + 24) = -1;
  uint64_t v3 = *(unsigned int *)(a2 + 24);
  if (v3 != -1)
  {
    ((void (*)(char *, uint64_t, uint64_t))off_26C25D108[v3])(&v5, a1, a2);
    *(_DWORD *)(a1 + 24) = v3;
  }
  return a1;
}

void sub_20F485728(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<anonymous namespace'::BooleanScalar,anonymous namespace'::Argument,anonymous namespace'::FromNewOperationOutput,anonymous namespace'::SignedIntegerScalar,anonymous namespace'::UnsignedIntegerScalar,anonymous namespace'::FloatScalar<float>,anonymous namespace'::FloatScalar<double>,anonymous namespace'::FloatScalar<MIL::Bf16>,anonymous namespace'::FloatScalar<MIL::Fp16>,anonymous namespace'::FloatScalar<MIL::Fp8E4M3FN>,anonymous namespace'::FloatScalar<MIL::Fp8E5M2>,anonymous namespace'::SmallStringConstant,anonymous namespace'::LargeStringConstant>,(std::__variant_detail::_Trait)1>::~__copy_constructor(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 24);
  if (v2 != -1) {
    ((void (*)(char *, uint64_t))off_26C25CFE8[v2])(&v4, a1);
  }
  *(_DWORD *)(a1 + 24) = -1;
  return a1;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE19__generic_constructB8ne180100IRKNS0_18__copy_constructorISS_LNS0_6_TraitE1EEEEEvRST_OT_EUlRS11_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEERKS19_EEEDcS11_DpT0_(uint64_t a1, unsigned char *a2, unsigned char *a3)
{
  *a2 = *a3;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE19__generic_constructB8ne180100IRKNS0_18__copy_constructorISS_LNS0_6_TraitE1EEEEEvRST_OT_EUlRS11_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEERKS19_EEEDcS11_DpT0_(uint64_t a1, void *a2, void *a3)
{
  uint64_t v3 = a3[1];
  *a2 = *a3;
  a2[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE19__generic_constructB8ne180100IRKNS0_18__copy_constructorISS_LNS0_6_TraitE1EEEEEvRST_OT_EUlRS11_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEERKS19_EEEDcS11_DpT0_(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result = *a3;
  *a2 = *a3;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3ELm3EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE19__generic_constructB8ne180100IRKNS0_18__copy_constructorISS_LNS0_6_TraitE1EEEEEvRST_OT_EUlRS11_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEERKS19_EEEDcS11_DpT0_(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result = *a3;
  *a2 = *a3;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm4ELm4EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE19__generic_constructB8ne180100IRKNS0_18__copy_constructorISS_LNS0_6_TraitE1EEEEEvRST_OT_EUlRS11_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEERKS19_EEEDcS11_DpT0_(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result = *a3;
  *a2 = *a3;
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm5ELm5EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE19__generic_constructB8ne180100IRKNS0_18__copy_constructorISS_LNS0_6_TraitE1EEEEEvRST_OT_EUlRS11_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEERKS19_EEEDcS11_DpT0_(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  *a2 = *a3;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm6ELm6EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE19__generic_constructB8ne180100IRKNS0_18__copy_constructorISS_LNS0_6_TraitE1EEEEEvRST_OT_EUlRS11_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEERKS19_EEEDcS11_DpT0_(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm7ELm7EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE19__generic_constructB8ne180100IRKNS0_18__copy_constructorISS_LNS0_6_TraitE1EEEEEvRST_OT_EUlRS11_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEERKS19_EEEDcS11_DpT0_(uint64_t a1, _WORD *a2, _WORD *a3)
{
  *a2 = *a3;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm8ELm8EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE19__generic_constructB8ne180100IRKNS0_18__copy_constructorISS_LNS0_6_TraitE1EEEEEvRST_OT_EUlRS11_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEERKS19_EEEDcS11_DpT0_(uint64_t a1, _WORD *a2, _WORD *a3)
{
  *a2 = *a3;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm9ELm9EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE19__generic_constructB8ne180100IRKNS0_18__copy_constructorISS_LNS0_6_TraitE1EEEEEvRST_OT_EUlRS11_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEERKS19_EEEDcS11_DpT0_(uint64_t a1, unsigned char *a2, unsigned char *a3)
{
  *a2 = *a3;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm10ELm10EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE19__generic_constructB8ne180100IRKNS0_18__copy_constructorISS_LNS0_6_TraitE1EEEEEvRST_OT_EUlRS11_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEERKS19_EEEDcS11_DpT0_(uint64_t a1, unsigned char *a2, unsigned char *a3)
{
  *a2 = *a3;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm11ELm11EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE19__generic_constructB8ne180100IRKNS0_18__copy_constructorISS_LNS0_6_TraitE1EEEEEvRST_OT_EUlRS11_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEERKS19_EEEDcS11_DpT0_(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result = *a3;
  a2[1].n128_u64[0] = a3[1].n128_u64[0];
  *a2 = result;
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm12ELm12EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE19__generic_constructB8ne180100IRKNS0_18__copy_constructorISS_LNS0_6_TraitE1EEEEEvRST_OT_EUlRS11_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEERKS19_EEEDcS11_DpT0_(uint64_t a1, void *a2, void *a3)
{
  uint64_t v3 = a3[1];
  *a2 = *a3;
  a2[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE19__generic_constructB8ne180100INS0_18__move_constructorISS_LNS0_6_TraitE1EEEEEvRST_OT_EUlRSZ_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEEOS17_EEEDcSZ_DpT0_(uint64_t a1, unsigned char *a2, unsigned char *a3)
{
  *a2 = *a3;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE19__generic_constructB8ne180100INS0_18__move_constructorISS_LNS0_6_TraitE1EEEEEvRST_OT_EUlRSZ_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEEOS17_EEEDcSZ_DpT0_(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result = *a3;
  *a2 = *a3;
  a3->n128_u64[0] = 0;
  a3->n128_u64[1] = 0;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE19__generic_constructB8ne180100INS0_18__move_constructorISS_LNS0_6_TraitE1EEEEEvRST_OT_EUlRSZ_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEEOS17_EEEDcSZ_DpT0_(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result = *a3;
  *a2 = *a3;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3ELm3EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE19__generic_constructB8ne180100INS0_18__move_constructorISS_LNS0_6_TraitE1EEEEEvRST_OT_EUlRSZ_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEEOS17_EEEDcSZ_DpT0_(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result = *a3;
  *a2 = *a3;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm4ELm4EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE19__generic_constructB8ne180100INS0_18__move_constructorISS_LNS0_6_TraitE1EEEEEvRST_OT_EUlRSZ_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEEOS17_EEEDcSZ_DpT0_(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result = *a3;
  *a2 = *a3;
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm5ELm5EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE19__generic_constructB8ne180100INS0_18__move_constructorISS_LNS0_6_TraitE1EEEEEvRST_OT_EUlRSZ_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEEOS17_EEEDcSZ_DpT0_(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  *a2 = *a3;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm6ELm6EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE19__generic_constructB8ne180100INS0_18__move_constructorISS_LNS0_6_TraitE1EEEEEvRST_OT_EUlRSZ_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEEOS17_EEEDcSZ_DpT0_(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm7ELm7EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE19__generic_constructB8ne180100INS0_18__move_constructorISS_LNS0_6_TraitE1EEEEEvRST_OT_EUlRSZ_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEEOS17_EEEDcSZ_DpT0_(uint64_t a1, _WORD *a2, _WORD *a3)
{
  *a2 = *a3;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm8ELm8EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE19__generic_constructB8ne180100INS0_18__move_constructorISS_LNS0_6_TraitE1EEEEEvRST_OT_EUlRSZ_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEEOS17_EEEDcSZ_DpT0_(uint64_t a1, _WORD *a2, _WORD *a3)
{
  *a2 = *a3;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm9ELm9EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE19__generic_constructB8ne180100INS0_18__move_constructorISS_LNS0_6_TraitE1EEEEEvRST_OT_EUlRSZ_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEEOS17_EEEDcSZ_DpT0_(uint64_t a1, unsigned char *a2, unsigned char *a3)
{
  *a2 = *a3;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm10ELm10EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE19__generic_constructB8ne180100INS0_18__move_constructorISS_LNS0_6_TraitE1EEEEEvRST_OT_EUlRSZ_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEEOS17_EEEDcSZ_DpT0_(uint64_t a1, unsigned char *a2, unsigned char *a3)
{
  *a2 = *a3;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm11ELm11EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE19__generic_constructB8ne180100INS0_18__move_constructorISS_LNS0_6_TraitE1EEEEEvRST_OT_EUlRSZ_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEEOS17_EEEDcSZ_DpT0_(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result = *a3;
  a2[1].n128_u64[0] = a3[1].n128_u64[0];
  *a2 = result;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm12ELm12EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE19__generic_constructB8ne180100INS0_18__move_constructorISS_LNS0_6_TraitE1EEEEEvRST_OT_EUlRSZ_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEEOS17_EEEDcSZ_DpT0_(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result = *a3;
  *a2 = *a3;
  a3->n128_u64[0] = 0;
  a3->n128_u64[1] = 0;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentISS_LNS0_6_TraitE1EEEEEvOT_EUlRS10_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEERKS18_EEEDcS10_DpT0_(uint64_t result, unsigned char *a2, unsigned char *a3)
{
  uint64_t v4 = *(void *)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 24);
  if (v5 != -1)
  {
    if (!v5)
    {
      *a2 = *a3;
      return result;
    }
    __n128 result = ((uint64_t (*)(char *, uint64_t))off_26C25CFE8[v5])(&v6, v4);
  }
  *(unsigned char *)uint64_t v4 = *a3;
  *(_DWORD *)(v4 + 24) = 0;
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentISS_LNS0_6_TraitE1EEEEEvOT_EUlRS10_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEERKS18_EEEDcS10_DpT0_(uint64_t *a1, void *a2, uint64_t *a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *(unsigned int *)(*a1 + 24);
  if (v5 != -1)
  {
    if (v5 == 1)
    {
      uint64_t v7 = *a3;
      uint64_t v6 = a3[1];
      if (v6) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
      }
      char v8 = (std::__shared_weak_count *)a2[1];
      *a2 = v7;
      a2[1] = v6;
      if (v8)
      {
        std::__shared_weak_count::__release_shared[abi:ne180100](v8);
      }
      return;
    }
    ((void (*)(char *, uint64_t))off_26C25CFE8[v5])(&v10, v4);
  }
  *(_DWORD *)(v4 + 24) = -1;
  uint64_t v9 = a3[1];
  *(void *)uint64_t v4 = *a3;
  *(void *)(v4 + 8) = v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)(v4 + 24) = 1;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentISS_LNS0_6_TraitE1EEEEEvOT_EUlRS10_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEERKS18_EEEDcS10_DpT0_(__n128 **a1, __n128 *a2, __n128 *a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = (*a1)[1].n128_u32[2];
  if (v5 != -1)
  {
    if (v5 == 2)
    {
      __n128 result = *a3;
      *a2 = *a3;
      return result;
    }
    ((void (*)(char *, __n128 *))off_26C25CFE8[v5])(&v7, v4);
  }
  v4[1].n128_u32[2] = -1;
  __n128 result = *a3;
  *uint64_t v4 = *a3;
  v4[1].n128_u32[2] = 2;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3ELm3EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentISS_LNS0_6_TraitE1EEEEEvOT_EUlRS10_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEERKS18_EEEDcS10_DpT0_(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *(unsigned int *)(*a1 + 24);
  if (v5 != -1)
  {
    if (v5 == 3)
    {
      uint64_t v6 = *a3;
      *(_DWORD *)(a2 + 8) = *((_DWORD *)a3 + 2);
      *(void *)a2 = v6;
      return result;
    }
    ((void (*)(char *, uint64_t))off_26C25CFE8[v5])(&v8, v4);
  }
  *(_DWORD *)(v4 + 24) = -1;
  __n128 result = *(__n128 *)a3;
  *(_OWORD *)uint64_t v4 = *(_OWORD *)a3;
  *(_DWORD *)(v4 + 24) = 3;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm4ELm4EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentISS_LNS0_6_TraitE1EEEEEvOT_EUlRS10_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEERKS18_EEEDcS10_DpT0_(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *(unsigned int *)(*a1 + 24);
  if (v5 != -1)
  {
    if (v5 == 4)
    {
      uint64_t v6 = *a3;
      *(_DWORD *)(a2 + 8) = *((_DWORD *)a3 + 2);
      *(void *)a2 = v6;
      return result;
    }
    ((void (*)(char *, uint64_t))off_26C25CFE8[v5])(&v8, v4);
  }
  *(_DWORD *)(v4 + 24) = -1;
  __n128 result = *(__n128 *)a3;
  *(_OWORD *)uint64_t v4 = *(_OWORD *)a3;
  *(_DWORD *)(v4 + 24) = 4;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm5ELm5EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentISS_LNS0_6_TraitE1EEEEEvOT_EUlRS10_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEERKS18_EEEDcS10_DpT0_(uint64_t result, _DWORD *a2, _DWORD *a3)
{
  uint64_t v4 = *(_DWORD **)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 24);
  if (v5 != -1)
  {
    if (v5 == 5)
    {
      *a2 = *a3;
      return result;
    }
    __n128 result = ((uint64_t (*)(char *, _DWORD *))off_26C25CFE8[v5])(&v6, v4);
  }
  *uint64_t v4 = *a3;
  v4[6] = 5;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm6ELm6EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentISS_LNS0_6_TraitE1EEEEEvOT_EUlRS10_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEERKS18_EEEDcS10_DpT0_(uint64_t result, void *a2, void *a3)
{
  uint64_t v4 = *(void *)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 24);
  if (v5 != -1)
  {
    if (v5 == 6)
    {
      *a2 = *a3;
      return result;
    }
    __n128 result = ((uint64_t (*)(char *, uint64_t))off_26C25CFE8[v5])(&v6, v4);
  }
  *(void *)uint64_t v4 = *a3;
  *(_DWORD *)(v4 + 24) = 6;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm7ELm7EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentISS_LNS0_6_TraitE1EEEEEvOT_EUlRS10_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEERKS18_EEEDcS10_DpT0_(uint64_t result, _WORD *a2, _WORD *a3)
{
  uint64_t v4 = *(void *)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 24);
  if (v5 != -1)
  {
    if (v5 == 7)
    {
      *a2 = *a3;
      return result;
    }
    __n128 result = ((uint64_t (*)(char *, uint64_t))off_26C25CFE8[v5])(&v6, v4);
  }
  *(_WORD *)uint64_t v4 = *a3;
  *(_DWORD *)(v4 + 24) = 7;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm8ELm8EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentISS_LNS0_6_TraitE1EEEEEvOT_EUlRS10_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEERKS18_EEEDcS10_DpT0_(uint64_t result, _WORD *a2, _WORD *a3)
{
  uint64_t v4 = *(void *)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 24);
  if (v5 != -1)
  {
    if (v5 == 8)
    {
      *a2 = *a3;
      return result;
    }
    __n128 result = ((uint64_t (*)(char *, uint64_t))off_26C25CFE8[v5])(&v6, v4);
  }
  *(_WORD *)uint64_t v4 = *a3;
  *(_DWORD *)(v4 + 24) = 8;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm9ELm9EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentISS_LNS0_6_TraitE1EEEEEvOT_EUlRS10_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEERKS18_EEEDcS10_DpT0_(uint64_t result, unsigned char *a2, unsigned char *a3)
{
  uint64_t v4 = *(void *)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 24);
  if (v5 != -1)
  {
    if (v5 == 9)
    {
      *a2 = *a3;
      return result;
    }
    __n128 result = ((uint64_t (*)(char *, uint64_t))off_26C25CFE8[v5])(&v6, v4);
  }
  *(_DWORD *)(v4 + 24) = -1;
  *(unsigned char *)uint64_t v4 = *a3;
  *(_DWORD *)(v4 + 24) = 9;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm10ELm10EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentISS_LNS0_6_TraitE1EEEEEvOT_EUlRS10_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEERKS18_EEEDcS10_DpT0_(uint64_t result, unsigned char *a2, unsigned char *a3)
{
  uint64_t v4 = *(void *)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 24);
  if (v5 != -1)
  {
    if (v5 == 10)
    {
      *a2 = *a3;
      return result;
    }
    __n128 result = ((uint64_t (*)(char *, uint64_t))off_26C25CFE8[v5])(&v6, v4);
  }
  *(_DWORD *)(v4 + 24) = -1;
  *(unsigned char *)uint64_t v4 = *a3;
  *(_DWORD *)(v4 + 24) = 10;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm11ELm11EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentISS_LNS0_6_TraitE1EEEEEvOT_EUlRS10_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEERKS18_EEEDcS10_DpT0_(__n128 **a1, __n128 *a2, __n128 *a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = (*a1)[1].n128_u32[2];
  if (v5 != -1)
  {
    if (v5 == 11)
    {
      __n128 result = *a3;
      a2[1].n128_u64[0] = a3[1].n128_u64[0];
      *a2 = result;
      return result;
    }
    ((void (*)(char *, __n128 *))off_26C25CFE8[v5])(&v7, v4);
  }
  v4[1].n128_u32[2] = -1;
  __n128 result = *a3;
  v4[1].n128_u64[0] = a3[1].n128_u64[0];
  *uint64_t v4 = result;
  v4[1].n128_u32[2] = 11;
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm12ELm12EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentISS_LNS0_6_TraitE1EEEEEvOT_EUlRS10_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEERKS18_EEEDcS10_DpT0_(uint64_t *a1, void *a2, uint64_t *a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *(unsigned int *)(*a1 + 24);
  if (v5 != -1)
  {
    if (v5 == 12)
    {
      uint64_t v7 = *a3;
      uint64_t v6 = a3[1];
      if (v6) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
      }
      char v8 = (std::__shared_weak_count *)a2[1];
      *a2 = v7;
      a2[1] = v6;
      if (v8)
      {
        std::__shared_weak_count::__release_shared[abi:ne180100](v8);
      }
      return;
    }
    ((void (*)(char *, uint64_t))off_26C25CFE8[v5])(&v10, v4);
  }
  *(_DWORD *)(v4 + 24) = -1;
  uint64_t v9 = a3[1];
  *(void *)uint64_t v4 = *a3;
  *(void *)(v4 + 8) = v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)(v4 + 24) = 12;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE16__generic_assignB8ne180100INS0_17__move_assignmentISS_LNS0_6_TraitE1EEEEEvOT_EUlRSY_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEEOS16_EEEDcSY_DpT0_(uint64_t result, unsigned char *a2, unsigned char *a3)
{
  uint64_t v4 = *(void *)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 24);
  if (v5 != -1)
  {
    if (!v5)
    {
      *a2 = *a3;
      return result;
    }
    __n128 result = ((uint64_t (*)(char *, uint64_t))off_26C25CFE8[v5])(&v6, v4);
  }
  *(unsigned char *)uint64_t v4 = *a3;
  *(_DWORD *)(v4 + 24) = 0;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE16__generic_assignB8ne180100INS0_17__move_assignmentISS_LNS0_6_TraitE1EEEEEvOT_EUlRSY_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEEOS16_EEEDcSY_DpT0_(__n128 **a1, __n128 *a2, __n128 *a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = (*a1)[1].n128_u32[2];
  if (v5 == -1) {
    goto LABEL_8;
  }
  if (v5 != 1)
  {
    ((void (*)(char *, __n128 *))off_26C25CFE8[v5])(&v8, v4);
LABEL_8:
    __n128 result = *a3;
    *uint64_t v4 = *a3;
    a3->n128_u64[0] = 0;
    a3->n128_u64[1] = 0;
    v4[1].n128_u32[2] = 1;
    return result;
  }
  __n128 result = *a3;
  a3->n128_u64[0] = 0;
  a3->n128_u64[1] = 0;
  uint64_t v7 = (std::__shared_weak_count *)a2->n128_u64[1];
  *a2 = result;
  if (v7)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE16__generic_assignB8ne180100INS0_17__move_assignmentISS_LNS0_6_TraitE1EEEEEvOT_EUlRSY_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEEOS16_EEEDcSY_DpT0_(__n128 **a1, __n128 *a2, __n128 *a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = (*a1)[1].n128_u32[2];
  if (v5 != -1)
  {
    if (v5 == 2)
    {
      __n128 result = *a3;
      *a2 = *a3;
      return result;
    }
    ((void (*)(char *, __n128 *))off_26C25CFE8[v5])(&v7, v4);
  }
  v4[1].n128_u32[2] = -1;
  __n128 result = *a3;
  *uint64_t v4 = *a3;
  v4[1].n128_u32[2] = 2;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3ELm3EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE16__generic_assignB8ne180100INS0_17__move_assignmentISS_LNS0_6_TraitE1EEEEEvOT_EUlRSY_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEEOS16_EEEDcSY_DpT0_(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *(unsigned int *)(*a1 + 24);
  if (v5 != -1)
  {
    if (v5 == 3)
    {
      uint64_t v6 = *a3;
      *(_DWORD *)(a2 + 8) = *((_DWORD *)a3 + 2);
      *(void *)a2 = v6;
      return result;
    }
    ((void (*)(char *, uint64_t))off_26C25CFE8[v5])(&v8, v4);
  }
  *(_DWORD *)(v4 + 24) = -1;
  __n128 result = *(__n128 *)a3;
  *(_OWORD *)uint64_t v4 = *(_OWORD *)a3;
  *(_DWORD *)(v4 + 24) = 3;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm4ELm4EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE16__generic_assignB8ne180100INS0_17__move_assignmentISS_LNS0_6_TraitE1EEEEEvOT_EUlRSY_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEEOS16_EEEDcSY_DpT0_(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *(unsigned int *)(*a1 + 24);
  if (v5 != -1)
  {
    if (v5 == 4)
    {
      uint64_t v6 = *a3;
      *(_DWORD *)(a2 + 8) = *((_DWORD *)a3 + 2);
      *(void *)a2 = v6;
      return result;
    }
    ((void (*)(char *, uint64_t))off_26C25CFE8[v5])(&v8, v4);
  }
  *(_DWORD *)(v4 + 24) = -1;
  __n128 result = *(__n128 *)a3;
  *(_OWORD *)uint64_t v4 = *(_OWORD *)a3;
  *(_DWORD *)(v4 + 24) = 4;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm5ELm5EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE16__generic_assignB8ne180100INS0_17__move_assignmentISS_LNS0_6_TraitE1EEEEEvOT_EUlRSY_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEEOS16_EEEDcSY_DpT0_(uint64_t result, _DWORD *a2, _DWORD *a3)
{
  uint64_t v4 = *(_DWORD **)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 24);
  if (v5 != -1)
  {
    if (v5 == 5)
    {
      *a2 = *a3;
      return result;
    }
    __n128 result = ((uint64_t (*)(char *, _DWORD *))off_26C25CFE8[v5])(&v6, v4);
  }
  *uint64_t v4 = *a3;
  v4[6] = 5;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm6ELm6EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE16__generic_assignB8ne180100INS0_17__move_assignmentISS_LNS0_6_TraitE1EEEEEvOT_EUlRSY_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEEOS16_EEEDcSY_DpT0_(uint64_t result, void *a2, void *a3)
{
  uint64_t v4 = *(void *)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 24);
  if (v5 != -1)
  {
    if (v5 == 6)
    {
      *a2 = *a3;
      return result;
    }
    __n128 result = ((uint64_t (*)(char *, uint64_t))off_26C25CFE8[v5])(&v6, v4);
  }
  *(void *)uint64_t v4 = *a3;
  *(_DWORD *)(v4 + 24) = 6;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm7ELm7EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE16__generic_assignB8ne180100INS0_17__move_assignmentISS_LNS0_6_TraitE1EEEEEvOT_EUlRSY_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEEOS16_EEEDcSY_DpT0_(uint64_t result, _WORD *a2, _WORD *a3)
{
  uint64_t v4 = *(void *)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 24);
  if (v5 != -1)
  {
    if (v5 == 7)
    {
      *a2 = *a3;
      return result;
    }
    __n128 result = ((uint64_t (*)(char *, uint64_t))off_26C25CFE8[v5])(&v6, v4);
  }
  *(_WORD *)uint64_t v4 = *a3;
  *(_DWORD *)(v4 + 24) = 7;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm8ELm8EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE16__generic_assignB8ne180100INS0_17__move_assignmentISS_LNS0_6_TraitE1EEEEEvOT_EUlRSY_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEEOS16_EEEDcSY_DpT0_(uint64_t result, _WORD *a2, _WORD *a3)
{
  uint64_t v4 = *(void *)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 24);
  if (v5 != -1)
  {
    if (v5 == 8)
    {
      *a2 = *a3;
      return result;
    }
    __n128 result = ((uint64_t (*)(char *, uint64_t))off_26C25CFE8[v5])(&v6, v4);
  }
  *(_WORD *)uint64_t v4 = *a3;
  *(_DWORD *)(v4 + 24) = 8;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm9ELm9EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE16__generic_assignB8ne180100INS0_17__move_assignmentISS_LNS0_6_TraitE1EEEEEvOT_EUlRSY_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEEOS16_EEEDcSY_DpT0_(uint64_t result, unsigned char *a2, unsigned char *a3)
{
  uint64_t v4 = *(void *)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 24);
  if (v5 != -1)
  {
    if (v5 == 9)
    {
      *a2 = *a3;
      return result;
    }
    __n128 result = ((uint64_t (*)(char *, uint64_t))off_26C25CFE8[v5])(&v6, v4);
  }
  *(_DWORD *)(v4 + 24) = -1;
  *(unsigned char *)uint64_t v4 = *a3;
  *(_DWORD *)(v4 + 24) = 9;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm10ELm10EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE16__generic_assignB8ne180100INS0_17__move_assignmentISS_LNS0_6_TraitE1EEEEEvOT_EUlRSY_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEEOS16_EEEDcSY_DpT0_(uint64_t result, unsigned char *a2, unsigned char *a3)
{
  uint64_t v4 = *(void *)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 24);
  if (v5 != -1)
  {
    if (v5 == 10)
    {
      *a2 = *a3;
      return result;
    }
    __n128 result = ((uint64_t (*)(char *, uint64_t))off_26C25CFE8[v5])(&v6, v4);
  }
  *(_DWORD *)(v4 + 24) = -1;
  *(unsigned char *)uint64_t v4 = *a3;
  *(_DWORD *)(v4 + 24) = 10;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm11ELm11EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE16__generic_assignB8ne180100INS0_17__move_assignmentISS_LNS0_6_TraitE1EEEEEvOT_EUlRSY_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEEOS16_EEEDcSY_DpT0_(__n128 **a1, __n128 *a2, __n128 *a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = (*a1)[1].n128_u32[2];
  if (v5 != -1)
  {
    if (v5 == 11)
    {
      __n128 result = *a3;
      a2[1].n128_u64[0] = a3[1].n128_u64[0];
      *a2 = result;
      return result;
    }
    ((void (*)(char *, __n128 *))off_26C25CFE8[v5])(&v7, v4);
  }
  v4[1].n128_u32[2] = -1;
  __n128 result = *a3;
  v4[1].n128_u64[0] = a3[1].n128_u64[0];
  *uint64_t v4 = result;
  v4[1].n128_u32[2] = 11;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm12ELm12EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_113BooleanScalarENS8_8ArgumentENS8_22FromNewOperationOutputENS8_19SignedIntegerScalarENS8_21UnsignedIntegerScalarENS8_11FloatScalarIfEENSE_IdEENSE_IN3MIL4Bf16EEENSE_INSH_4Fp16EEENSE_INSH_9Fp8E4M3FNEEENSE_INSH_7Fp8E5M2EEENS8_19SmallStringConstantENS8_19LargeStringConstantEEEEE16__generic_assignB8ne180100INS0_17__move_assignmentISS_LNS0_6_TraitE1EEEEEvOT_EUlRSY_OT0_E_JRNS0_6__baseILSW_1EJS9_SA_SB_SC_SD_SF_SG_SJ_SL_SN_SP_SQ_SR_EEEOS16_EEEDcSY_DpT0_(__n128 **a1, __n128 *a2, __n128 *a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = (*a1)[1].n128_u32[2];
  if (v5 == -1) {
    goto LABEL_8;
  }
  if (v5 != 12)
  {
    ((void (*)(char *, __n128 *))off_26C25CFE8[v5])(&v8, v4);
LABEL_8:
    __n128 result = *a3;
    *uint64_t v4 = *a3;
    a3->n128_u64[0] = 0;
    a3->n128_u64[1] = 0;
    v4[1].n128_u32[2] = 12;
    return result;
  }
  __n128 result = *a3;
  a3->n128_u64[0] = 0;
  a3->n128_u64[1] = 0;
  char v7 = (std::__shared_weak_count *)a2->n128_u64[1];
  *a2 = result;
  if (v7)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  return result;
}

MIL::Transform::NameGenerator *MIL::Transform::NameGenerator::NameGenerator(MIL::Transform::NameGenerator **this, const MIL::IRProgram *a2)
{
  v15[4] = *MEMORY[0x263EF8340];
  uint64_t v4 = std::string::basic_string[abi:ne180100]<0>(this, "tmp_");
  v4[3] = 0;
  v4[4] = 0;
  uint64_t v5 = (uint64_t)(v4 + 3);
  v4[5] = 0;
  if (*((char *)v4 + 23) < 0)
  {
    char v7 = *this;
    char v6 = this[1];
  }
  else
  {
    char v6 = (MIL::Transform::NameGenerator *)*((unsigned __int8 *)v4 + 23);
    char v7 = (MIL::Transform::NameGenerator *)this;
  }
  v14[0] = v7;
  v14[1] = v6;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  std::string __p = 0;
  v15[0] = &unk_26C25D250;
  v15[1] = v14;
  v15[2] = &__p;
  v15[3] = v15;
  MIL::Util::ForEachVariableName((uint64_t)a2, (uint64_t)v15);
  std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100](v15);
  if (SHIBYTE(v13) < 0)
  {
    uint64_t v8 = v12;
    if (v12)
    {
      p_p = __p;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v8 = HIBYTE(v13);
    if (HIBYTE(v13))
    {
      p_p = &__p;
LABEL_9:
      std::string::__assign_with_sentinel[abi:ne180100]<std::reverse_iterator<std::__wrap_iter<char *>>,std::reverse_iterator<std::__wrap_iter<char *>>>(v5, (uint64_t)p_p + v8, (uint64_t)p_p + v8, (uint64_t)p_p, (uint64_t)p_p);
      goto LABEL_11;
    }
  }
  MEMORY[0x21056C240](v5, "0");
LABEL_11:
  if (SHIBYTE(v13) < 0) {
    operator delete(__p);
  }
  return (MIL::Transform::NameGenerator *)this;
}

void sub_20F486864(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100](&a17);
  if (a14 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v17 + 47) < 0) {
    operator delete(*v18);
  }
  if (*(char *)(v17 + 23) < 0) {
    operator delete(*(void **)v17);
  }
  _Unwind_Resume(a1);
}

void anonymous namespace'::Increment(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 *)(a1 + 23);
  if ((v1 & 0x80u) == 0) {
    uint64_t v2 = (unsigned char *)a1;
  }
  else {
    uint64_t v2 = *(unsigned char **)a1;
  }
  if ((v1 & 0x80u) != 0) {
    uint64_t v1 = *(void *)(a1 + 8);
  }
  if (v1)
  {
    while (1)
    {
      int v3 = (char)*v2;
      BOOL v4 = v3 <= 56;
      char v5 = v3 <= 56 ? v3 + 1 : 48;
      unsigned char *v2 = v5;
      if (v4) {
        break;
      }
      ++v2;
      if (!--v1) {
        goto LABEL_12;
      }
    }
  }
  else
  {
LABEL_12:
    std::string::push_back((std::string *)a1, 49);
  }
}

void MIL::Transform::NameGenerator::GenerateTmpName(MIL::Transform::NameGenerator *this@<X0>, std::string *a2@<X8>)
{
  a2->__r_.__value_.__r.__words[0] = 0;
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  if (*((char *)this + 23) < 0) {
    uint64_t v4 = *((void *)this + 1);
  }
  else {
    uint64_t v4 = *((unsigned __int8 *)this + 23);
  }
  if (*((char *)this + 47) < 0) {
    uint64_t v5 = *((void *)this + 4);
  }
  else {
    uint64_t v5 = *((unsigned __int8 *)this + 47);
  }
  std::string::reserve(a2, v5 + v4);
  int v6 = *((char *)this + 23);
  if (v6 >= 0) {
    char v7 = (const std::string::value_type *)this;
  }
  else {
    char v7 = *(const std::string::value_type **)this;
  }
  if (v6 >= 0) {
    std::string::size_type v8 = *((unsigned __int8 *)this + 23);
  }
  else {
    std::string::size_type v8 = *((void *)this + 1);
  }
  std::string::append(a2, v7, v8);
  uint64_t v9 = (char *)this + 24;
  if (*((char *)this + 47) < 0)
  {
    char v11 = (char *)*((void *)this + 3);
    uint64_t v10 = (uint64_t)&v11[*((void *)this + 4)];
  }
  else
  {
    uint64_t v10 = (uint64_t)&v9[*((unsigned __int8 *)this + 47)];
    char v11 = (char *)this + 24;
  }
  if ((char *)v10 != v11)
  {
    std::string::__init_with_size[abi:ne180100]<std::reverse_iterator<std::__wrap_iter<char *>>,std::reverse_iterator<std::__wrap_iter<char *>>>(__p, v10, v10, (uint64_t)v11, (uint64_t)v11, v10 - (void)v11);
    if ((v15 & 0x80u) == 0) {
      uint64_t v12 = __p;
    }
    else {
      uint64_t v12 = (void **)__p[0];
    }
    if ((v15 & 0x80u) == 0) {
      std::string::size_type v13 = v15;
    }
    else {
      std::string::size_type v13 = (std::string::size_type)__p[1];
    }
    std::string::append(a2, (const std::string::value_type *)v12, v13);
    if ((char)v15 < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_20F486A08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v15 + 23) < 0) {
    operator delete(*(void **)v15);
  }
  _Unwind_Resume(exception_object);
}

void MIL::Transform::NameGenerator::TakeBack(uint64_t a1, const void **a2)
{
  size_t v4 = *((unsigned __int8 *)a2 + 23);
  if ((v4 & 0x80u) == 0) {
    uint64_t v5 = a2;
  }
  else {
    uint64_t v5 = *a2;
  }
  if ((v4 & 0x80u) != 0) {
    size_t v4 = (size_t)a2[1];
  }
  if (*(char *)(a1 + 23) < 0)
  {
    char v7 = *(const void **)a1;
    size_t v6 = *(void *)(a1 + 8);
  }
  else
  {
    size_t v6 = *(unsigned __int8 *)(a1 + 23);
    char v7 = (const void *)a1;
  }
  if (v4 < v6 || memcmp(v5, v7, v6)) {
    return;
  }
  std::string::size_type v8 = (unsigned char *)(a1 + 24);
  unsigned int v9 = *(unsigned __int8 *)(a1 + 47);
  if (*(char *)(a1 + 47) < 0)
  {
    char v11 = *(unsigned char **)(a1 + 24);
    uint64_t v10 = *(void *)(a1 + 32);
    if (v10 == 1)
    {
      if (*v11 == 48) {
        return;
      }
      uint64_t v12 = v11 + 1;
      goto LABEL_21;
    }
  }
  else
  {
    if (v9 == 1 && *v8 == 48) {
      return;
    }
    uint64_t v10 = *(unsigned __int8 *)(a1 + 47);
    char v11 = (unsigned char *)(a1 + 24);
  }
  if (!v10) {
    goto LABEL_31;
  }
  uint64_t v12 = &v11[v10];
LABEL_21:
  std::string::size_type v13 = v11 + 1;
  do
  {
    int v14 = (char)*(v13 - 1);
    BOOL v15 = v14 <= 48;
    if (v14 <= 48) {
      char v16 = 57;
    }
    else {
      char v16 = v14 - 1;
    }
    *(v13 - 1) = v16;
  }
  while (v15 && v13++ != v12);
  unsigned int v9 = *(unsigned __int8 *)(a1 + 47);
LABEL_31:
  if ((v9 & 0x80) != 0)
  {
    unint64_t v20 = *(void *)(a1 + 32);
    if (v20 < 2) {
      goto LABEL_39;
    }
    uint64_t v19 = *(void *)(a1 + 24);
    if (*(unsigned char *)(v19 + v20 - 1) != 48) {
      goto LABEL_39;
    }
    uint64_t v18 = v20 - 1;
    *(void *)(a1 + 32) = v18;
  }
  else
  {
    if (v9 < 2 || v8[v9 - 1] != 48) {
      goto LABEL_39;
    }
    uint64_t v18 = v9 - 1;
    *(unsigned char *)(a1 + 47) = v18 & 0x7F;
    uint64_t v19 = a1 + 24;
  }
  *(unsigned char *)(v19 + v18) = 0;
LABEL_39:
  char v21 = *((unsigned char *)a2 + 23);
  std::string v22 = (char *)*a2;
  if (v21 >= 0) {
    std::string v22 = (char *)a2;
  }
  if (*(char *)(a1 + 23) < 0) {
    char v23 = *(char **)(a1 + 8);
  }
  else {
    char v23 = (char *)*(unsigned __int8 *)(a1 + 23);
  }
  char v24 = &v23[(void)v22];
  if (v21 >= 0) {
    uint64x2_t v25 = (char *)*((unsigned __int8 *)a2 + 23);
  }
  else {
    uint64x2_t v25 = (char *)a2[1];
  }
  uint64x2_t v26 = (unsigned __int8 *)&v25[(void)v22];
  if (*(char *)(a1 + 47) < 0)
  {
    uint64x2_t v28 = *(unsigned __int8 **)(a1 + 24);
    uint64x2_t v27 = &v28[*(void *)(a1 + 32)];
  }
  else
  {
    uint64x2_t v27 = &v8[*(unsigned __int8 *)(a1 + 47)];
    uint64x2_t v28 = (unsigned __int8 *)(a1 + 24);
  }
  uint64_t v29 = v26 - (unsigned __int8 *)v24;
  if (v26 - (unsigned __int8 *)v24 == v27 - v28)
  {
    if (v23 == v25)
    {
LABEL_57:
      if (v27 == v28) {
        return;
      }
    }
    else
    {
      uint64_t v30 = &v27[v24 - (char *)v26];
      while (v27 != v28)
      {
        int v31 = *--v27;
        if (*v24 != v31) {
          break;
        }
        ++v24;
        if (!--v29)
        {
          uint64x2_t v27 = v30;
          goto LABEL_57;
        }
      }
    }
  }
}

void std::__function::__func<anonymous namespace'::FindLargestTmpSuffixInProgram(MIL::IRProgram const&,std::string_view)::$_0,std::allocator<anonymous namespace'::FindLargestTmpSuffixInProgram(MIL::IRProgram const&,std::string_view)::$_0>,void ()(std::string const&)>::~__func()
{
}

__n128 std::__function::__func<anonymous namespace'::FindLargestTmpSuffixInProgram(MIL::IRProgram const&,std::string_view)::$_0,std::allocator<anonymous namespace'::FindLargestTmpSuffixInProgram(MIL::IRProgram const&,std::string_view)::$_0>,void ()(std::string const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_26C25D250;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<anonymous namespace'::FindLargestTmpSuffixInProgram(MIL::IRProgram const&,std::string_view)::$_0,std::allocator<anonymous namespace'::FindLargestTmpSuffixInProgram(MIL::IRProgram const&,std::string_view)::$_0>,void ()(std::string const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26C25D250;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<anonymous namespace'::FindLargestTmpSuffixInProgram(MIL::IRProgram const&,std::string_view)::$_0,std::allocator<anonymous namespace'::FindLargestTmpSuffixInProgram(MIL::IRProgram const&,std::string_view)::$_0>,void ()(std::string const&)>::operator()(uint64_t result, uint64_t a2)
{
  int v2 = *(char *)(a2 + 23);
  if (v2 >= 0) {
    unint64_t v3 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    unint64_t v3 = *(void *)(a2 + 8);
  }
  uint64_t v4 = *(void *)(result + 8);
  size_t v5 = *(void *)(v4 + 8);
  if (v3 >= v5)
  {
    uint64_t v6 = result;
    char v7 = *(const void **)v4;
    std::string::size_type v8 = v2 >= 0 ? (char *)a2 : *(char **)a2;
    __n128 result = memcmp(v8, v7, v5);
    if (!result)
    {
      unsigned int v9 = &v8[v5];
      size_t v10 = v3 - v5;
      if (!v10) {
        goto LABEL_17;
      }
      do
      {
        if (*v9 != 48)
        {
          uint64_t v11 = 0;
          while (v9[v11] - 48 < 0xA)
          {
            if (v10 == ++v11) {
              goto LABEL_17;
            }
          }
          return result;
        }
        ++v9;
        --v10;
      }
      while (v10);
      unsigned int v9 = &v8[v3];
LABEL_17:
      uint64_t v12 = *(char **)(v6 + 16);
      if (v12[23] < 0)
      {
        int v14 = *(char **)v12;
        size_t v13 = *((void *)v12 + 1);
      }
      else
      {
        size_t v13 = v12[23];
        int v14 = v12;
      }
      if (v10 == v13)
      {
        __n128 result = memcmp(v9, v14, v10);
        if ((int)result > 0)
        {
LABEL_24:
          JUMPOUT(0x21056C250);
        }
      }
      else if (v10 > v13)
      {
        goto LABEL_24;
      }
    }
  }
  return result;
}

uint64_t std::__function::__func<anonymous namespace'::FindLargestTmpSuffixInProgram(MIL::IRProgram const&,std::string_view)::$_0,std::allocator<anonymous namespace'::FindLargestTmpSuffixInProgram(MIL::IRProgram const&,std::string_view)::$_0>,void ()(std::string const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<anonymous namespace'::FindLargestTmpSuffixInProgram(MIL::IRProgram const&,std::string_view)::$_0,std::allocator<anonymous namespace'::FindLargestTmpSuffixInProgram(MIL::IRProgram const&,std::string_view)::$_0>,void ()(std::string const&)>::target_type()
{
}

void *std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100](void *a1)
{
  int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::string::__assign_with_sentinel[abi:ne180100]<std::reverse_iterator<std::__wrap_iter<char *>>,std::reverse_iterator<std::__wrap_iter<char *>>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  std::string::__init_with_sentinel[abi:ne180100]<std::reverse_iterator<std::__wrap_iter<char *>>,std::reverse_iterator<std::__wrap_iter<char *>>>(&__p, a2, a3, a4, a5);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  MEMORY[0x21056C250](a1, p_p, size);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_20F486F50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::string::__init_with_sentinel[abi:ne180100]<std::reverse_iterator<std::__wrap_iter<char *>>,std::reverse_iterator<std::__wrap_iter<char *>>>(std::string *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(_OWORD *)&this->__r_.__value_.__l.__data_ = 0uLL;
  this->__r_.__value_.__r.__words[2] = 0;
  while (a3 != a5)
  {
    std::string::value_type v8 = *(unsigned char *)--a3;
    std::string::push_back(this, v8);
  }
}

void sub_20F486FBC(void *a1)
{
  __cxa_begin_catch(a1);
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  __cxa_rethrow();
}

void sub_20F486FD8(_Unwind_Exception *a1)
{
}

void *std::string::__init_with_size[abi:ne180100]<std::reverse_iterator<std::__wrap_iter<char *>>,std::reverse_iterator<std::__wrap_iter<char *>>>(void *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  uint64_t v6 = result;
  if (a6 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (a6 > 0x16)
  {
    uint64_t v10 = (a6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a6 | 7) != 0x17) {
      uint64_t v10 = a6 | 7;
    }
    uint64_t v11 = v10 + 1;
    __n128 result = operator new(v10 + 1);
    v6[1] = a6;
    v6[2] = v11 | 0x8000000000000000;
    *uint64_t v6 = result;
    uint64_t v6 = result;
  }
  else
  {
    *((unsigned char *)result + 23) = a6;
  }
  while (a3 != a5)
  {
    char v12 = *(unsigned char *)--a3;
    *(unsigned char *)uint64_t v6 = v12;
    uint64_t v6 = (void *)((char *)v6 + 1);
  }
  *(unsigned char *)uint64_t v6 = 0;
  return result;
}

uint64_t MIL::Transform::OperationChange::operator=(uint64_t a1, uint64_t a2)
{
  MIL::Util::OpaqueStorage<128ul,8ul,MIL::Transform::OperationChange::OperationChangeImpl>::operator=(a1, a2);
  return a1;
}

{
  MIL::Util::OpaqueStorage<128ul,8ul,MIL::Transform::OperationChange::OperationChangeImpl>::operator=(a1, a2);
  return a1;
}

uint64_t MIL::Util::OpaqueStorage<128ul,8ul,MIL::Transform::OperationChange::OperationChangeImpl>::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 64);
  uint64_t v4 = *(unsigned int *)(a2 + 64);
  if (v3 == -1)
  {
    if (v4 == -1) {
      return a1;
    }
LABEL_5:
    uint64_t v6 = a1;
    off_26C25D348[v4]((int)&v6, (std::string *)a1, (std::string *)a2);
    return a1;
  }
  if (v4 != -1) {
    goto LABEL_5;
  }
  ((void (*)(char *, uint64_t, uint64_t))off_26C25D2D0[v3])(&v7, a1, a2);
  *(_DWORD *)(a1 + 64) = -1;
  return a1;
}

{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  char v7;

  uint64_t v3 = *(unsigned int *)(a1 + 64);
  uint64_t v4 = *(unsigned int *)(a2 + 64);
  if (v3 == -1)
  {
    if (v4 == -1) {
      return a1;
    }
LABEL_5:
    uint64_t v6 = a1;
    ((void (*)(uint64_t *, uint64_t, uint64_t))off_26C25D370[v4])(&v6, a1, a2);
    return a1;
  }
  if (v4 != -1) {
    goto LABEL_5;
  }
  ((void (*)(char *, uint64_t, uint64_t))off_26C25D2D0[v3])(&v7, a1, a2);
  *(_DWORD *)(a1 + 64) = -1;
  return a1;
}

double MIL::Transform::ChangeOperator@<D0>(MIL::Transform *this@<X0>, uint64_t a2@<X8>)
{
  std::string::basic_string[abi:ne180100]<0>(&v5, (char *)this);
  double result = *(double *)&v5;
  *(_OWORD *)a2 = v5;
  *(void *)(a2 + 16) = v6;
  *(_DWORD *)(a2 + 64) = 1;
  return result;
}

__n128 MIL::Transform::ChangeOperator@<Q0>(__n128 *a1@<X0>, __n128 *a2@<X8>)
{
  __n128 result = *a1;
  *a2 = *a1;
  a2[1].n128_u64[0] = a1[1].n128_u64[0];
  a1->n128_u64[1] = 0;
  a1[1].n128_u64[0] = 0;
  a1->n128_u64[0] = 0;
  a2[4].n128_u32[0] = 1;
  return result;
}

void MIL::Transform::ChangeArgument(char *__s@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  std::string::basic_string[abi:ne180100]<0>(__p, __s);
  *(_OWORD *)a4 = *(_OWORD *)__p;
  uint64_t v7 = v9;
  __p[1] = 0;
  uint64_t v9 = 0;
  __p[0] = 0;
  *(void *)(a4 + 16) = v7;
  *(void *)(a4 + 24) = a2;
  MIL::Transform::ArgumentDescription::ArgumentDescription(a4 + 32, a3);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  *(_DWORD *)(a4 + 64) = 2;
}

void sub_20F487314(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (*(char *)(v2 + 23) < 0) {
    operator delete(*(void **)v2);
  }
  MIL::Builder::BlockBuilder::ReplaceUsesOfInputVariable((uint64_t)va);
  _Unwind_Resume(a1);
}

void MIL::Transform::ReplaceArgument(char *__s@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  std::string::basic_string[abi:ne180100]<0>(__p, __s);
  *(_OWORD *)a3 = *(_OWORD *)__p;
  *(void *)(a3 + 16) = v6;
  __p[1] = 0;
  uint64_t v6 = 0;
  __p[0] = 0;
  MIL::Transform::ArgumentDescription::ArgumentDescription(a3 + 24, a2);
  if (SHIBYTE(v6) < 0) {
    operator delete(__p[0]);
  }
  *(_DWORD *)(a3 + 64) = 3;
}

void sub_20F4873AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (*(char *)(v2 + 23) < 0) {
    operator delete(*(void **)v2);
  }
  MIL::Builder::BlockBuilder::ReplaceUsesOfInputVariable((uint64_t)va);
  _Unwind_Resume(a1);
}

__n128 MIL::Transform::ReplaceArguments@<Q0>(char *__s@<X0>, __n128 *a2@<X1>, uint64_t a3@<X8>)
{
  std::string::basic_string[abi:ne180100]<0>(&v6, __s);
  *(_OWORD *)a3 = v6;
  *(void *)(a3 + 16) = v7;
  __n128 result = *a2;
  *(__n128 *)(a3 + 24) = *a2;
  *(void *)(a3 + 40) = a2[1].n128_u64[0];
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  *(_DWORD *)(a3 + 64) = 4;
  return result;
}

__n128 MIL::Transform::ReplaceAttribute@<Q0>(char *__s@<X0>, __n128 *a2@<X1>, uint64_t a3@<X8>)
{
  std::string::basic_string[abi:ne180100]<0>(&v6, __s);
  __n128 result = *a2;
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  *(_OWORD *)a3 = v6;
  *(void *)(a3 + 16) = v7;
  *(__n128 *)(a3 + 24) = result;
  *(_DWORD *)(a3 + 64) = 0;
  return result;
}

void MIL::TransformPrivate::OperationChangePrivate::ApplyChange(uint64_t *a1, std::string::size_type a2, uint64_t a3, uint64_t a4)
{
}

void MIL::Transform::OperationChange::OperationChangeImpl::ApplyChange(std::string::size_type a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  int v8 = *(_DWORD *)(a1 + 64);
  if (v8 == 4) {
    std::string::size_type v9 = a1;
  }
  else {
    std::string::size_type v9 = 0;
  }
  if (v8 == 4)
  {
    uint64_t v11 = (uint64_t)(a2 + 2);
    uint64_t v10 = *a2;
    int v12 = *(char *)(a1 + 23);
    if (v12 >= 0) {
      size_t v13 = (const std::string::value_type *)a1;
    }
    else {
      size_t v13 = *(const std::string::value_type **)a1;
    }
    if (v12 >= 0) {
      std::string::size_type v14 = *(unsigned __int8 *)(a1 + 23);
    }
    else {
      std::string::size_type v14 = *(void *)(a1 + 8);
    }
    uint64_t Parameter = MIL::Transform::GetParameter(v10, v13, v14);
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)Parameter + 16))(Parameter);
    *(void *)&long long v76 = a1;
    uint64_t v17 = (uint64_t *)std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v11, (unsigned __int8 *)a1, (uint64_t)&std::piecewise_construct, (long long **)&v76);
    uint64_t v18 = v17[5];
    for (uint64_t i = v17[6];
          i != v18;
          std::allocator<MIL::TransformPrivate::ArgumentAndType>::destroy[abi:ne180100]((uint64_t)(v17 + 7), i))
    {
      i -= 48;
    }
    v17[6] = v18;
    uint64_t v20 = *(void *)(v9 + 24);
    for (uint64_t j = *(void *)(v9 + 32); v20 != j; v20 += 32)
    {
      MIL::TransformPrivate::ArgumentDescriptionPrivate::CreateIRArgument(&v76, v20, a3, v16, a4);
      std::string v22 = (_OWORD *)v17[6];
      if ((unint64_t)v22 >= v17[7])
      {
        uint64_t v23 = std::vector<MIL::TransformPrivate::ArgumentAndType>::__push_back_slow_path<MIL::TransformPrivate::ArgumentAndType>(v17 + 5, (uint64_t)&v76);
        char v24 = (std::__shared_weak_count *)*((void *)&v77 + 1);
        v17[6] = v23;
        if (v24) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v24);
        }
      }
      else
      {
        *std::string v22 = v76;
        long long v76 = 0uLL;
        v22[1] = v77;
        long long v77 = 0uLL;
        v22[2] = v78;
        v17[6] = (uint64_t)(v22 + 3);
      }
      if (*((void *)&v76 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v76 + 1));
      }
    }
  }
  else
  {
    switch(v8)
    {
      case 0:
        if (!std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(a2 + 10, (unsigned __int8 *)a1))
        {
          exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
          uint64_t v66 = (*(uint64_t (**)(void))(*(void *)*a2 + 16))();
          std::string v67 = (char *)v66;
          if (*(char *)(v66 + 23) >= 0) {
            size_t v68 = *(unsigned __int8 *)(v66 + 23);
          }
          else {
            size_t v68 = *(void *)(v66 + 8);
          }
          v69 = &v79;
          std::string::basic_string[abi:ne180100]((uint64_t)&v79, v68 + 21);
          if ((v79.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            v69 = (std::string *)v79.__r_.__value_.__r.__words[0];
          }
          if (v68)
          {
            if (v67[23] >= 0) {
              v70 = v67;
            }
            else {
              v70 = *(char **)v67;
            }
            memmove(v69, v70, v68);
          }
          strcpy((char *)v69 + v68, ": No attribute named ");
          int v71 = *(char *)(a1 + 23);
          if (v71 >= 0) {
            int v72 = (const std::string::value_type *)a1;
          }
          else {
            int v72 = *(const std::string::value_type **)a1;
          }
          if (v71 >= 0) {
            std::string::size_type v73 = *(unsigned __int8 *)(a1 + 23);
          }
          else {
            std::string::size_type v73 = *(void *)(a1 + 8);
          }
          v74 = std::string::append(&v79, v72, v73);
          long long v75 = *(_OWORD *)&v74->__r_.__value_.__l.__data_;
          *(void *)&long long v77 = *((void *)&v74->__r_.__value_.__l + 2);
          long long v76 = v75;
          v74->__r_.__value_.__l.__size_ = 0;
          v74->__r_.__value_.__r.__words[2] = 0;
          v74->__r_.__value_.__r.__words[0] = 0;
          std::logic_error::logic_error(exception, (const std::string *)&v76);
          exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
          __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
        }
        *(void *)&long long v76 = a1;
        uint64x2_t v25 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a2 + 10), (unsigned __int8 *)a1, (uint64_t)&std::piecewise_construct, (long long **)&v76);
        uint64_t v27 = *(void *)(a1 + 24);
        uint64_t v26 = *(void *)(a1 + 32);
        if (v26) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v26 + 8), 1uLL, memory_order_relaxed);
        }
        uint64x2_t v28 = (std::__shared_weak_count *)*((void *)v25 + 6);
        *((void *)v25 + 5) = v27;
        *((void *)v25 + 6) = v26;
        if (!v28) {
          return;
        }
        uint64_t v29 = v28;
        goto LABEL_62;
      case 1:
        int v59 = *(char *)(a1 + 23);
        if (v59 >= 0) {
          v60 = (unsigned __int8 *)a1;
        }
        else {
          v60 = *(unsigned __int8 **)a1;
        }
        if (v59 >= 0) {
          unint64_t v61 = *(unsigned __int8 *)(a1 + 23);
        }
        else {
          unint64_t v61 = *(void *)(a1 + 8);
        }
        MIL::Matching::GetOperatorByQualifiedName(a3, v60, v61, &v76);
        long long v62 = v76;
        long long v76 = 0uLL;
        uint64_t v48 = (std::__shared_weak_count *)a2[1];
        *(_OWORD *)a2 = v62;
        if (!v48) {
          return;
        }
        goto LABEL_60;
      case 2:
        uint64_t v31 = (uint64_t)(a2 + 2);
        uint64_t v30 = *a2;
        int v32 = *(char *)(a1 + 23);
        if (v32 >= 0) {
          std::string v33 = (const std::string::value_type *)a1;
        }
        else {
          std::string v33 = *(const std::string::value_type **)a1;
        }
        if (v32 >= 0) {
          std::string::size_type v34 = *(unsigned __int8 *)(a1 + 23);
        }
        else {
          std::string::size_type v34 = *(void *)(a1 + 8);
        }
        uint64_t v35 = MIL::Transform::GetParameter(v30, v33, v34);
        uint64_t v36 = (*(uint64_t (**)(uint64_t))(*(void *)v35 + 16))(v35);
        MIL::TransformPrivate::ArgumentDescriptionPrivate::CreateIRArgument(&v76, a1 + 32, a3, v36, a4);
        v79.__r_.__value_.__r.__words[0] = a1;
        int v37 = std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v31, (unsigned __int8 *)a1, (uint64_t)&std::piecewise_construct, (long long **)&v79);
        uint64_t v38 = *((void *)v37 + 5);
        unint64_t v39 = *(void *)(a1 + 24);
        if (0xAAAAAAAAAAAAAAABLL * ((*((void *)v37 + 6) - v38) >> 4) <= v39) {
          std::vector<MIL::IRDimension const*>::__throw_out_of_range[abi:ne180100]();
        }
        uint64_t v40 = v38 + 48 * v39;
        long long v41 = v76;
        long long v76 = 0uLL;
        uint64_t v42 = *(std::__shared_weak_count **)(v40 + 8);
        *(_OWORD *)uint64_t v40 = v41;
        if (v42) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v42);
        }
        uint64_t v43 = v38 + 48 * v39;
        long long v44 = v77;
        long long v77 = 0uLL;
        int v45 = *(std::__shared_weak_count **)(v43 + 24);
        *(_OWORD *)(v43 + 16) = v44;
        if (v45) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v45);
        }
        uint64_t v46 = v38 + 48 * v39;
        uint64_t v47 = v78;
        *(unsigned char *)(v46 + 40) = BYTE8(v78);
        *(void *)(v46 + 32) = v47;
        uint64_t v48 = (std::__shared_weak_count *)*((void *)&v77 + 1);
        if (!*((void *)&v77 + 1)) {
          goto LABEL_61;
        }
        goto LABEL_60;
      case 3:
        uint64_t v50 = (uint64_t)(a2 + 2);
        uint64_t v49 = *a2;
        int v51 = *(char *)(a1 + 23);
        if (v51 >= 0) {
          v52 = (const std::string::value_type *)a1;
        }
        else {
          v52 = *(const std::string::value_type **)a1;
        }
        if (v51 >= 0) {
          std::string::size_type v53 = *(unsigned __int8 *)(a1 + 23);
        }
        else {
          std::string::size_type v53 = *(void *)(a1 + 8);
        }
        uint64_t v54 = MIL::Transform::GetParameter(v49, v52, v53);
        uint64_t v55 = (*(uint64_t (**)(uint64_t))(*(void *)v54 + 16))(v54);
        MIL::TransformPrivate::ArgumentDescriptionPrivate::CreateIRArgument(&v76, a1 + 24, a3, v55, a4);
        v79.__r_.__value_.__r.__words[0] = a1;
        v56 = (uint64_t *)std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v50, (unsigned __int8 *)a1, (uint64_t)&std::piecewise_construct, (long long **)&v79);
        v57 = (_OWORD *)v56[5];
        for (uint64_t k = v56[6];
              (_OWORD *)k != v57;
              std::allocator<MIL::TransformPrivate::ArgumentAndType>::destroy[abi:ne180100]((uint64_t)(v56 + 7), k))
        {
          k -= 48;
        }
        v56[6] = (uint64_t)v57;
        if ((unint64_t)v57 >= v56[7])
        {
          uint64_t v63 = std::vector<MIL::TransformPrivate::ArgumentAndType>::__push_back_slow_path<MIL::TransformPrivate::ArgumentAndType>(v56 + 5, (uint64_t)&v76);
          uint64_t v48 = (std::__shared_weak_count *)*((void *)&v77 + 1);
          v56[6] = v63;
          if (v48) {
LABEL_60:
          }
            std::__shared_weak_count::__release_shared[abi:ne180100](v48);
        }
        else
        {
          _OWORD *v57 = v76;
          long long v76 = 0uLL;
          v57[1] = v77;
          long long v77 = 0uLL;
          v57[2] = v78;
          v56[6] = (uint64_t)(v57 + 3);
        }
LABEL_61:
        uint64_t v29 = (std::__shared_weak_count *)*((void *)&v76 + 1);
        if (*((void *)&v76 + 1)) {
LABEL_62:
        }
          std::__shared_weak_count::__release_shared[abi:ne180100](v29);
        break;
      default:
        v64 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(v64, "Trying to visit a std::variant that is in an invalid state");
        __cxa_throw(v64, MEMORY[0x263F8C1E0], MEMORY[0x263F8C048]);
    }
  }
}

void sub_20F487AA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a23 < 0)
  {
    operator delete(a18);
    if ((v24 & 1) == 0) {
LABEL_8:
    }
      _Unwind_Resume(a1);
  }
  else if (!v24)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v23);
  goto LABEL_8;
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1, unsigned __int8 *a2, uint64_t a3, long long **a4)
{
  int v8 = (void *)(a1 + 24);
  unint64_t v9 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  unint64_t v10 = v9;
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    unint64_t v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v4 = v9;
      if (v9 >= v11) {
        unint64_t v4 = v9 % v11;
      }
    }
    else
    {
      unint64_t v4 = (v11 - 1) & v9;
    }
    std::string::size_type v14 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v4);
    if (v14)
    {
      for (uint64_t i = *v14; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v16 = *((void *)i + 1);
        if (v16 == v10)
        {
          if (std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2)) {
            return i;
          }
        }
        else
        {
          if (v13 > 1)
          {
            if (v16 >= v11) {
              v16 %= v11;
            }
          }
          else
          {
            v16 &= v11 - 1;
          }
          if (v16 != v4) {
            break;
          }
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1, v10, a4, (uint64_t)v26);
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v18 = *(float *)(a1 + 32);
  if (!v11 || (float)(v18 * (float)v11) < v17)
  {
    BOOL v19 = 1;
    if (v11 >= 3) {
      BOOL v19 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v11);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v22);
    unint64_t v11 = *(void *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11) {
        unint64_t v4 = v10 % v11;
      }
      else {
        unint64_t v4 = v10;
      }
    }
    else
    {
      unint64_t v4 = (v11 - 1) & v10;
    }
  }
  uint64_t v23 = *(void **)(*(void *)a1 + 8 * v4);
  if (v23)
  {
    *(void *)v26[0] = *v23;
    *uint64_t v23 = v26[0];
  }
  else
  {
    *(void *)v26[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v26[0];
    *(void *)(*(void *)a1 + 8 * v4) = a1 + 16;
    if (*(void *)v26[0])
    {
      unint64_t v24 = *(void *)(*(void *)v26[0] + 8);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v24 >= v11) {
          v24 %= v11;
        }
      }
      else
      {
        v24 &= v11 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v24) = v26[0];
    }
  }
  uint64_t i = (unsigned __int8 *)v26[0];
  v26[0] = 0;
  ++*v8;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,void *>>>>::reset[abi:ne180100]((uint64_t)v26, 0);
  return i;
}

void sub_20F487DC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1@<X0>, uint64_t a2@<X1>, long long **a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  int v8 = operator new(0x40uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *(unsigned char *)(a4 + 16) = 0;
  *int v8 = 0;
  v8[1] = a2;
  unint64_t v9 = (std::string *)(v8 + 2);
  unint64_t v10 = *a3;
  if (*((char *)*a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)v10, *((void *)v10 + 1));
  }
  else
  {
    long long v11 = *v10;
    v8[4] = *((void *)v10 + 2);
    *(_OWORD *)&v9->__r_.__value_.__l.__data_ = v11;
  }
  v8[5] = 0;
  v8[6] = 0;
  v8[7] = 0;
  *(unsigned char *)(a4 + 16) = 1;
}

void sub_20F487E6C(_Unwind_Exception *a1)
{
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::vector<MIL::TransformPrivate::ArgumentAndType>>,0>((uint64_t)v2 + 16);
    }
    operator delete(v2);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::vector<MIL::TransformPrivate::ArgumentAndType>>,0>(uint64_t a1)
{
  uint64_t v2 = (void **)(a1 + 24);
  std::vector<MIL::TransformPrivate::ArgumentAndType>::__destroy_vector::operator()[abi:ne180100](&v2);
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
}

void std::vector<MIL::TransformPrivate::ArgumentAndType>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    long long v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 48;
        std::allocator<MIL::TransformPrivate::ArgumentAndType>::destroy[abi:ne180100]((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      long long v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::allocator<MIL::TransformPrivate::ArgumentAndType>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a2 + 24);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a2 + 8);
  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
}

uint64_t std::vector<MIL::TransformPrivate::ArgumentAndType>::__push_back_slow_path<MIL::TransformPrivate::ArgumentAndType>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 4);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x555555555555555) {
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 4);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v9 = 0x555555555555555;
  }
  else {
    unint64_t v9 = v5;
  }
  v14[4] = a1 + 2;
  if (v9) {
    unint64_t v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<std::string,std::string>>>(v7, v9);
  }
  else {
    unint64_t v10 = 0;
  }
  long long v11 = &v10[48 * v4];
  v14[0] = v10;
  v14[1] = v11;
  v14[3] = &v10[48 * v9];
  *(_OWORD *)long long v11 = *(_OWORD *)a2;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *((_OWORD *)v11 + 1) = *(_OWORD *)(a2 + 16);
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *((_OWORD *)v11 + 2) = *(_OWORD *)(a2 + 32);
  void v14[2] = v11 + 48;
  std::vector<MIL::TransformPrivate::ArgumentAndType>::__swap_out_circular_buffer(a1, v14);
  uint64_t v12 = a1[1];
  std::__split_buffer<MIL::TransformPrivate::ArgumentAndType>::~__split_buffer(v14);
  return v12;
}

void sub_20F488110(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<MIL::TransformPrivate::ArgumentAndType>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<MIL::TransformPrivate::ArgumentAndType>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<MIL::TransformPrivate::ArgumentAndType>,std::reverse_iterator<MIL::TransformPrivate::ArgumentAndType*>,std::reverse_iterator<MIL::TransformPrivate::ArgumentAndType*>,std::reverse_iterator<MIL::TransformPrivate::ArgumentAndType*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<MIL::TransformPrivate::ArgumentAndType>,std::reverse_iterator<MIL::TransformPrivate::ArgumentAndType*>,std::reverse_iterator<MIL::TransformPrivate::ArgumentAndType*>,std::reverse_iterator<MIL::TransformPrivate::ArgumentAndType*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v14 = a6;
  *((void *)&v14 + 1) = a7;
  long long v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    uint64_t v9 = a6;
  }
  else
  {
    do
    {
      long long v8 = *(_OWORD *)(a3 - 48);
      a3 -= 48;
      *(_OWORD *)(v7 - 48) = v8;
      *(void *)a3 = 0;
      *(void *)(a3 + 8) = 0;
      *(_OWORD *)(v7 - 32) = *(_OWORD *)(a3 + 16);
      *(void *)(a3 + 16) = 0;
      *(void *)(a3 + 24) = 0;
      *(_OWORD *)(v7 - 16) = *(_OWORD *)(a3 + 32);
      uint64_t v7 = *((void *)&v14 + 1) - 48;
      *((void *)&v14 + 1) -= 48;
    }
    while (a3 != a5);
    uint64_t v9 = v14;
  }
  char v12 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<MIL::TransformPrivate::ArgumentAndType>,std::reverse_iterator<MIL::TransformPrivate::ArgumentAndType*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<MIL::TransformPrivate::ArgumentAndType>,std::reverse_iterator<MIL::TransformPrivate::ArgumentAndType*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<MIL::TransformPrivate::ArgumentAndType>,std::reverse_iterator<MIL::TransformPrivate::ArgumentAndType*>>::operator()[abi:ne180100]((uint64_t *)a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<MIL::TransformPrivate::ArgumentAndType>,std::reverse_iterator<MIL::TransformPrivate::ArgumentAndType*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v1 = *(void *)(a1[2] + 8);
  uint64_t v2 = *(void *)(a1[1] + 8);
  if (v1 != v2)
  {
    uint64_t v3 = *a1;
    do
    {
      std::allocator<MIL::TransformPrivate::ArgumentAndType>::destroy[abi:ne180100](v3, v1);
      v1 += 48;
    }
    while (v1 != v2);
  }
}

void **std::__split_buffer<MIL::TransformPrivate::ArgumentAndType>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void std::__split_buffer<MIL::TransformPrivate::ArgumentAndType>::clear[abi:ne180100](void *a1)
{
  uint64_t v2 = a1[1];
  for (uint64_t i = a1[2]; i != v2; uint64_t i = a1[2])
  {
    uint64_t v4 = a1[4];
    a1[2] = i - 48;
    std::allocator<MIL::TransformPrivate::ArgumentAndType>::destroy[abi:ne180100](v4, i - 48);
  }
}

uint64_t MIL::Util::OpaqueStorage<128ul,8ul,MIL::Transform::OperationChange::OperationChangeImpl>::OpaqueStorage(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = 0;
  *(_DWORD *)(a1 + 64) = -1;
  uint64_t v3 = *(unsigned int *)(a2 + 64);
  if (v3 != -1)
  {
    ((void (*)(char *, uint64_t, uint64_t))off_26C25D2F8[v3])(&v5, a1, a2);
    *(_DWORD *)(a1 + 64) = v3;
  }
  return a1;
}

{
  uint64_t v3;
  char v5;

  *(unsigned char *)a1 = 0;
  *(_DWORD *)(a1 + 64) = -1;
  uint64_t v3 = *(unsigned int *)(a2 + 64);
  if (v3 != -1)
  {
    ((void (*)(char *, uint64_t, uint64_t))off_26C25D320[v3])(&v5, a1, a2);
    *(_DWORD *)(a1 + 64) = v3;
  }
  return a1;
}

void sub_20F4883AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILSF_1EJS9_SA_SB_SC_SD_EEEEEEDcSH_DpT0_(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a2 + 32);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  if (*(char *)(a2 + 23) < 0)
  {
    uint64_t v4 = *(void **)a2;
    operator delete(v4);
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILSF_1EJS9_SA_SB_SC_SD_EEEEEEDcSH_DpT0_(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILSF_1EJS9_SA_SB_SC_SD_EEEEEEDcSH_DpT0_(uint64_t a1, uint64_t a2)
{
  MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)(a2 + 32));
  if (*(char *)(a2 + 23) < 0)
  {
    uint64_t v3 = *(void **)a2;
    operator delete(v3);
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILSF_1EJS9_SA_SB_SC_SD_EEEEEEDcSH_DpT0_(uint64_t a1, uint64_t a2)
{
  MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)(a2 + 24));
  if (*(char *)(a2 + 23) < 0)
  {
    uint64_t v3 = *(void **)a2;
    operator delete(v3);
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm4EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILSF_1EJS9_SA_SB_SC_SD_EEEEEEDcSH_DpT0_(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void **)(a2 + 24);
  std::vector<MIL::Transform::ArgumentDescription>::__destroy_vector::operator()[abi:ne180100](&v3);
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
}

void std::vector<MIL::Transform::ArgumentDescription>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    char v5 = v2;
    if (v4 != v2)
    {
      do
        MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)(v4 - 32));
      while (v4 != v2);
      char v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEEE19__generic_constructB8ne180100IRKNS0_18__copy_constructorISE_LNS0_6_TraitE1EEEEEvRSF_OT_EUlRSN_OT0_E_JRNS0_6__baseILSI_1EJS9_SA_SB_SC_SD_EEERKSV_EEEDcSN_DpT0_(int a1, std::string *this, long long *a3)
{
  if (*((char *)a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v5 = *a3;
    this->__r_.__value_.__r.__words[2] = *((void *)a3 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v5;
  }
  std::string::size_type v6 = *((void *)a3 + 4);
  this[1].__r_.__value_.__r.__words[0] = *((void *)a3 + 3);
  this[1].__r_.__value_.__l.__size_ = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEEE19__generic_constructB8ne180100IRKNS0_18__copy_constructorISE_LNS0_6_TraitE1EEEEEvRSF_OT_EUlRSN_OT0_E_JRNS0_6__baseILSI_1EJS9_SA_SB_SC_SD_EEERKSV_EEEDcSN_DpT0_(int a1, std::string *this, long long *a3)
{
  if (*((char *)a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v3 = *a3;
    this->__r_.__value_.__r.__words[2] = *((void *)a3 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v3;
  }
}

std::string *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEEE19__generic_constructB8ne180100IRKNS0_18__copy_constructorISE_LNS0_6_TraitE1EEEEEvRSF_OT_EUlRSN_OT0_E_JRNS0_6__baseILSI_1EJS9_SA_SB_SC_SD_EEERKSV_EEEDcSN_DpT0_(int a1, std::string *this, long long *a3)
{
}

std::string *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3ELm3EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEEE19__generic_constructB8ne180100IRKNS0_18__copy_constructorISE_LNS0_6_TraitE1EEEEEvRSF_OT_EUlRSN_OT0_E_JRNS0_6__baseILSI_1EJS9_SA_SB_SC_SD_EEERKSV_EEEDcSN_DpT0_(int a1, std::string *this, long long *a3)
{
}

void *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm4ELm4EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEEE19__generic_constructB8ne180100IRKNS0_18__copy_constructorISE_LNS0_6_TraitE1EEEEEvRSF_OT_EUlRSN_OT0_E_JRNS0_6__baseILSI_1EJS9_SA_SB_SC_SD_EEERKSV_EEEDcSN_DpT0_(int a1, std::string *this, long long *a3)
{
  if (*((char *)a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v5 = *a3;
    this->__r_.__value_.__r.__words[2] = *((void *)a3 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v5;
  }
  this[1].__r_.__value_.__r.__words[0] = 0;
  this[1].__r_.__value_.__l.__size_ = 0;
  this[1].__r_.__value_.__r.__words[2] = 0;
  return std::vector<MIL::Transform::ArgumentDescription>::__init_with_size[abi:ne180100]<MIL::Transform::ArgumentDescription*,MIL::Transform::ArgumentDescription*>(this[1].__r_.__value_.__r.__words, *((void *)a3 + 3), *((void *)a3 + 4), (uint64_t)(*((void *)a3 + 4) - *((void *)a3 + 3)) >> 5);
}

void sub_20F4886A4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

std::string *std::__variant_detail::__ctor<std::__variant_detail::__traits<anonymous namespace'::AttributeReplacement,anonymous namespace'::OperatorChange,anonymous namespace'::SingleArgumentChange,anonymous namespace'::SingleArgumentReplacement,anonymous namespace'::VariadicArgumentReplacement>>::__construct_alt[abi:ne180100]<2ul,anonymous namespace'::SingleArgumentChange,anonymous namespace'::SingleArgumentChange const&>(std::string *this, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    this->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v4;
  }
  this[1].__r_.__value_.__r.__words[0] = *((void *)a2 + 3);
  MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)&this[1].__r_.__value_.__r.__words[1], (const MIL::Transform::ArgumentDescription *)(a2 + 2));
  return this;
}

void sub_20F488724(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

std::string *std::__variant_detail::__ctor<std::__variant_detail::__traits<anonymous namespace'::AttributeReplacement,anonymous namespace'::OperatorChange,anonymous namespace'::SingleArgumentChange,anonymous namespace'::SingleArgumentReplacement,anonymous namespace'::VariadicArgumentReplacement>>::__construct_alt[abi:ne180100]<3ul,anonymous namespace'::SingleArgumentReplacement,anonymous namespace'::SingleArgumentReplacement const&>(std::string *this, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    this->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v4;
  }
  MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)&this[1], (const MIL::Transform::ArgumentDescription *)((char *)a2 + 24));
  return this;
}

void sub_20F48879C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<MIL::Transform::ArgumentDescription>::__init_with_size[abi:ne180100]<MIL::Transform::ArgumentDescription*,MIL::Transform::ArgumentDescription*>(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    std::string::size_type v6 = result;
    std::vector<MIL::MatchingPrivate::MatchItem>::__vallocate[abi:ne180100](result, a4);
    uint64_t result = (void *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<MIL::Transform::ArgumentDescription>,MIL::Transform::ArgumentDescription*,MIL::Transform::ArgumentDescription*,MIL::Transform::ArgumentDescription*>((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_20F488820(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  std::vector<MIL::Transform::ArgumentDescription>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<MIL::Transform::ArgumentDescription>,MIL::Transform::ArgumentDescription*,MIL::Transform::ArgumentDescription*,MIL::Transform::ArgumentDescription*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)(a4 + v7), (const MIL::Transform::ArgumentDescription *)(a2 + v7));
      v7 += 32;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_20F4888A0(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 32;
    do
    {
      MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)(v4 + v2));
      v2 -= 32;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__variant_detail::__move_constructor<std::__variant_detail::__traits<anonymous namespace'::AttributeReplacement,anonymous namespace'::OperatorChange,anonymous namespace'::SingleArgumentChange,anonymous namespace'::SingleArgumentReplacement,anonymous namespace'::VariadicArgumentReplacement>,(std::__variant_detail::_Trait)1>::~__move_constructor(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 64);
  if (v2 != -1) {
    ((void (*)(char *, uint64_t))off_26C25D2D0[v2])(&v4, a1);
  }
  *(_DWORD *)(a1 + 64) = -1;
  return a1;
}

void sub_20F488984(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEEE19__generic_constructB8ne180100INS0_18__move_constructorISE_LNS0_6_TraitE1EEEEEvRSF_OT_EUlRSL_OT0_E_JRNS0_6__baseILSI_1EJS9_SA_SB_SC_SD_EEEOST_EEEDcSL_DpT0_(uint64_t a1, uint64_t a2, long long *a3)
{
  long long v3 = *a3;
  *(void *)(a2 + 16) = *((void *)a3 + 2);
  *(_OWORD *)a2 = v3;
  *((void *)a3 + 1) = 0;
  *((void *)a3 + 2) = 0;
  *(void *)a3 = 0;
  __n128 result = *(__n128 *)((char *)a3 + 24);
  *(__n128 *)(a2 + 24) = result;
  *((void *)a3 + 3) = 0;
  *((void *)a3 + 4) = 0;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEEE19__generic_constructB8ne180100INS0_18__move_constructorISE_LNS0_6_TraitE1EEEEEvRSF_OT_EUlRSL_OT0_E_JRNS0_6__baseILSI_1EJS9_SA_SB_SC_SD_EEEOST_EEEDcSL_DpT0_(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result = *a3;
  a2[1].n128_u64[0] = a3[1].n128_u64[0];
  *a2 = result;
  a3->n128_u64[1] = 0;
  a3[1].n128_u64[0] = 0;
  a3->n128_u64[0] = 0;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEEE19__generic_constructB8ne180100INS0_18__move_constructorISE_LNS0_6_TraitE1EEEEEvRSF_OT_EUlRSL_OT0_E_JRNS0_6__baseILSI_1EJS9_SA_SB_SC_SD_EEEOST_EEEDcSL_DpT0_(uint64_t a1, uint64_t a2, long long *a3)
{
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3ELm3EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEEE19__generic_constructB8ne180100INS0_18__move_constructorISE_LNS0_6_TraitE1EEEEEvRSF_OT_EUlRSL_OT0_E_JRNS0_6__baseILSI_1EJS9_SA_SB_SC_SD_EEEOST_EEEDcSL_DpT0_(uint64_t a1, uint64_t a2, long long *a3)
{
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm4ELm4EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEEE19__generic_constructB8ne180100INS0_18__move_constructorISE_LNS0_6_TraitE1EEEEEvRSF_OT_EUlRSL_OT0_E_JRNS0_6__baseILSI_1EJS9_SA_SB_SC_SD_EEEOST_EEEDcSL_DpT0_(uint64_t a1, uint64_t a2, long long *a3)
{
  long long v3 = *a3;
  *(void *)(a2 + 16) = *((void *)a3 + 2);
  *(_OWORD *)a2 = v3;
  *((void *)a3 + 1) = 0;
  *((void *)a3 + 2) = 0;
  *(void *)a3 = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  __n128 result = *(__n128 *)((char *)a3 + 24);
  *(__n128 *)(a2 + 24) = result;
  *(void *)(a2 + 40) = *((void *)a3 + 5);
  *((void *)a3 + 3) = 0;
  *((void *)a3 + 4) = 0;
  *((void *)a3 + 5) = 0;
  return result;
}

uint64_t std::__variant_detail::__ctor<std::__variant_detail::__traits<anonymous namespace'::AttributeReplacement,anonymous namespace'::OperatorChange,anonymous namespace'::SingleArgumentChange,anonymous namespace'::SingleArgumentReplacement,anonymous namespace'::VariadicArgumentReplacement>>::__construct_alt[abi:ne180100]<2ul,anonymous namespace'::SingleArgumentChange,anonymous namespace'::SingleArgumentChange>(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v3;
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *(void *)a2 = 0;
  *(void *)(a1 + 24) = *((void *)a2 + 3);
  MIL::Transform::ArgumentDescription::ArgumentDescription(a1 + 32, a2 + 2);
  return a1;
}

void sub_20F488A80(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__variant_detail::__ctor<std::__variant_detail::__traits<anonymous namespace'::AttributeReplacement,anonymous namespace'::OperatorChange,anonymous namespace'::SingleArgumentChange,anonymous namespace'::SingleArgumentReplacement,anonymous namespace'::VariadicArgumentReplacement>>::__construct_alt[abi:ne180100]<3ul,anonymous namespace'::SingleArgumentReplacement,anonymous namespace'::SingleArgumentReplacement>(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v3;
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *(void *)a2 = 0;
  MIL::Transform::ArgumentDescription::ArgumentDescription(a1 + 24, (char *)a2 + 24);
  return a1;
}

void sub_20F488ADC(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentISE_LNS0_6_TraitE1EEEEEvOT_EUlRSM_OT0_E_JRNS0_6__baseILSI_1EJS9_SA_SB_SC_SD_EEERKSU_EEEDcSM_DpT0_(uint64_t *a1, std::string *this, std::string *__str)
{
  uint64_t v4 = *a1;
  if (*(_DWORD *)(*a1 + 64))
  {
    if (SHIBYTE(__str->__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external(&__p, __str->__r_.__value_.__l.__data_, __str->__r_.__value_.__l.__size_);
    }
    else {
      std::string __p = *__str;
    }
    std::string::size_type size = (std::__shared_weak_count *)__str[1].__r_.__value_.__l.__size_;
    std::string::pointer data = __str[1].__r_.__value_.__l.__data_;
    char v12 = size;
    if (size) {
      atomic_fetch_add_explicit(&size->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v12) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v12);
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    std::string::operator=(this, __str);
    std::string::pointer v7 = __str[1].__r_.__value_.__l.__data_;
    std::string::size_type v6 = __str[1].__r_.__value_.__l.__size_;
    if (v6) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
    }
    long long v8 = (std::__shared_weak_count *)this[1].__r_.__value_.__l.__size_;
    this[1].__r_.__value_.__r.__words[0] = (std::string::size_type)v7;
    this[1].__r_.__value_.__l.__size_ = v6;
    if (v8)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v8);
    }
  }
}

void sub_20F488BF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13)
{
  if (a13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a13);
  }
  MIL::Builder::BlockBuilder::ReplaceUsesOfInputVariable((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentISE_LNS0_6_TraitE1EEEEEvOT_EUlRSM_OT0_E_JRNS0_6__baseILSI_1EJS9_SA_SB_SC_SD_EEERKSU_EEEDcSM_DpT0_(uint64_t *a1, std::string *this, std::string *__str)
{
  uint64_t v3 = *a1;
  if (*(_DWORD *)(*a1 + 64) == 1)
  {
    std::string::operator=(this, __str);
  }
  else
  {
    if (SHIBYTE(__str->__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external(&__p, __str->__r_.__value_.__l.__data_, __str->__r_.__value_.__l.__size_);
    }
    else {
      std::string __p = *__str;
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
}

void sub_20F488CB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

std::string *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentISE_LNS0_6_TraitE1EEEEEvOT_EUlRSM_OT0_E_JRNS0_6__baseILSI_1EJS9_SA_SB_SC_SD_EEERKSU_EEEDcSM_DpT0_(uint64_t *a1, std::string *this, std::string *__str)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *(unsigned int *)(*a1 + 64);
  if (v5 == -1) {
    goto LABEL_7;
  }
  if (v5 != 2)
  {
    ((void (*)(char *, uint64_t))off_26C25D2D0[v5])(&v8, v4);
LABEL_7:
    *(_DWORD *)(v4 + 64) = -1;
    *(_DWORD *)(v4 + 64) = 2;
    return result;
  }
  std::string::operator=(this, __str);
  this[1].__r_.__value_.__r.__words[0] = __str[1].__r_.__value_.__r.__words[0];

  return (std::string *)MIL::Transform::ArgumentDescription::operator=((uint64_t)&this[1].__r_.__value_.__l.__size_, (uint64_t)&__str[1].__r_.__value_.__l.__size_);
}

std::string *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3ELm3EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentISE_LNS0_6_TraitE1EEEEEvOT_EUlRSM_OT0_E_JRNS0_6__baseILSI_1EJS9_SA_SB_SC_SD_EEERKSU_EEEDcSM_DpT0_(uint64_t *a1, std::string *this, std::string *__str)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *(unsigned int *)(*a1 + 64);
  if (v5 == -1) {
    goto LABEL_7;
  }
  if (v5 != 3)
  {
    ((void (*)(char *, uint64_t))off_26C25D2D0[v5])(&v8, v4);
LABEL_7:
    *(_DWORD *)(v4 + 64) = -1;
    *(_DWORD *)(v4 + 64) = 3;
    return result;
  }
  std::string::operator=(this, __str);

  return (std::string *)MIL::Transform::ArgumentDescription::operator=((uint64_t)&this[1], (uint64_t)&__str[1]);
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm4ELm4EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentISE_LNS0_6_TraitE1EEEEEvOT_EUlRSM_OT0_E_JRNS0_6__baseILSI_1EJS9_SA_SB_SC_SD_EEERKSU_EEEDcSM_DpT0_(uint64_t *a1, std::string *this, std::string *__str)
{
  uint64_t v4 = *a1;
  if (*(_DWORD *)(*a1 + 64) == 4)
  {
    std::string::operator=(this, __str);
    if (this != __str)
    {
      std::string::pointer data = __str[1].__r_.__value_.__l.__data_;
      std::string::size_type size = __str[1].__r_.__value_.__l.__size_;
      std::vector<MIL::Transform::ArgumentDescription>::__assign_with_size[abi:ne180100]<MIL::Transform::ArgumentDescription*,MIL::Transform::ArgumentDescription*>((void **)&this[1].__r_.__value_.__l.__data_, (uint64_t)data, size, (uint64_t)(size - (void)data) >> 5);
    }
  }
  else
  {
    if (SHIBYTE(__str->__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external(&__p, __str->__r_.__value_.__l.__data_, __str->__r_.__value_.__l.__size_);
    }
    else {
      std::string __p = *__str;
    }
    memset(v9, 0, 24);
    std::vector<MIL::Transform::ArgumentDescription>::__init_with_size[abi:ne180100]<MIL::Transform::ArgumentDescription*,MIL::Transform::ArgumentDescription*>(v9, (uint64_t)__str[1].__r_.__value_.__l.__data_, __str[1].__r_.__value_.__l.__size_, (uint64_t)(__str[1].__r_.__value_.__l.__size_ - __str[1].__r_.__value_.__r.__words[0]) >> 5);
    uint64_t v10 = (void **)v9;
    std::vector<MIL::Transform::ArgumentDescription>::__destroy_vector::operator()[abi:ne180100](&v10);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
}

void sub_20F488F4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  *(void *)(v15 - 40) = v14;
  std::vector<MIL::Transform::ArgumentDescription>::__destroy_vector::operator()[abi:ne180100]((void ***)(v15 - 40));
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<anonymous namespace'::AttributeReplacement,anonymous namespace'::OperatorChange,anonymous namespace'::SingleArgumentChange,anonymous namespace'::SingleArgumentReplacement,anonymous namespace'::VariadicArgumentReplacement>>::__emplace[abi:ne180100]<0ul,anonymous namespace'::AttributeReplacement>(uint64_t a1, long long *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 64);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))off_26C25D2D0[v4])(&v7, a1);
  }
  *(_DWORD *)(a1 + 64) = -1;
  long long v5 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v5;
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *(void *)a2 = 0;
  *(_OWORD *)(a1 + 24) = *(long long *)((char *)a2 + 24);
  *((void *)a2 + 3) = 0;
  *((void *)a2 + 4) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<anonymous namespace'::AttributeReplacement,anonymous namespace'::OperatorChange,anonymous namespace'::SingleArgumentChange,anonymous namespace'::SingleArgumentReplacement,anonymous namespace'::VariadicArgumentReplacement>>::__emplace[abi:ne180100]<1ul,anonymous namespace'::OperatorChange>(uint64_t a1, long long *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 64);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))off_26C25D2D0[v4])(&v7, a1);
  }
  *(_DWORD *)(a1 + 64) = -1;
  long long v5 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v5;
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a1 + 64) = 1;
  return a1;
}

void std::vector<MIL::Transform::ArgumentDescription>::__assign_with_size[abi:ne180100]<MIL::Transform::ArgumentDescription*,MIL::Transform::ArgumentDescription*>(void **a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v6 = a2;
  uint64_t v8 = (uint64_t)(a1 + 2);
  uint64_t v9 = (char *)*a1;
  if (a4 > ((unsigned char *)a1[2] - (unsigned char *)*a1) >> 5)
  {
    std::vector<MIL::Transform::ArgumentDescription>::__vdeallocate(a1);
    if (a4 >> 59) {
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = (unsigned char *)a1[2] - (unsigned char *)*a1;
    uint64_t v11 = v10 >> 4;
    if (v10 >> 4 <= a4) {
      uint64_t v11 = a4;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v12 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    std::vector<MIL::MatchingPrivate::MatchItem>::__vallocate[abi:ne180100](a1, v12);
    uint64_t v13 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<MIL::Transform::ArgumentDescription>,MIL::Transform::ArgumentDescription*,MIL::Transform::ArgumentDescription*,MIL::Transform::ArgumentDescription*>(v8, v6, a3, (uint64_t)a1[1]);
LABEL_15:
    a1[1] = (void *)v13;
    return;
  }
  uint64_t v14 = (char *)a1[1];
  unint64_t v15 = (v14 - v9) >> 5;
  if (v15 < a4)
  {
    uint64_t v16 = a2 + 32 * v15;
    if (v14 != v9)
    {
      uint64_t v17 = 32 * v15;
      do
      {
        MIL::Transform::ArgumentDescription::operator=((uint64_t)v9, v6);
        v6 += 32;
        v9 += 32;
        v17 -= 32;
      }
      while (v17);
      uint64_t v9 = (char *)a1[1];
    }
    uint64_t v13 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<MIL::Transform::ArgumentDescription>,MIL::Transform::ArgumentDescription*,MIL::Transform::ArgumentDescription*,MIL::Transform::ArgumentDescription*>(v8, v16, a3, (uint64_t)v9);
    goto LABEL_15;
  }
  if (a2 == a3)
  {
    float v18 = v9;
  }
  else
  {
    float v18 = v9;
    do
    {
      MIL::Transform::ArgumentDescription::operator=((uint64_t)v9, v6);
      v6 += 32;
      v9 += 32;
      v18 += 32;
    }
    while (v6 != a3);
    uint64_t v14 = (char *)a1[1];
  }
  while (v14 != v18)
    MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)(v14 - 32));
  a1[1] = v18;
}

void sub_20F4891F4(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void std::vector<MIL::Transform::ArgumentDescription>::__vdeallocate(void **a1)
{
  uint64_t v1 = (char *)*a1;
  if (*a1)
  {
    uint64_t v3 = (char *)a1[1];
    uint64_t v4 = v1;
    if (v3 != v1)
    {
      do
        MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)(v3 - 32));
      while (v3 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<anonymous namespace'::AttributeReplacement,anonymous namespace'::OperatorChange,anonymous namespace'::SingleArgumentChange,anonymous namespace'::SingleArgumentReplacement,anonymous namespace'::VariadicArgumentReplacement>>::__emplace[abi:ne180100]<4ul,anonymous namespace'::VariadicArgumentReplacement>(uint64_t a1, long long *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 64);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))off_26C25D2D0[v4])(&v7, a1);
  }
  *(_DWORD *)(a1 + 64) = -1;
  long long v5 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v5;
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *(void *)a2 = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(_OWORD *)(a1 + 24) = *(long long *)((char *)a2 + 24);
  *(void *)(a1 + 40) = *((void *)a2 + 5);
  *((void *)a2 + 3) = 0;
  *((void *)a2 + 4) = 0;
  *((void *)a2 + 5) = 0;
  *(_DWORD *)(a1 + 64) = 4;
  return a1;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEEE16__generic_assignB8ne180100INS0_17__move_assignmentISE_LNS0_6_TraitE1EEEEEvOT_EUlRSK_OT0_E_JRNS0_6__baseILSI_1EJS9_SA_SB_SC_SD_EEEOSS_EEEDcSK_DpT0_(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *a1;
  if (*(_DWORD *)(v4 + 64))
  {
  }
  else
  {
    if (*(char *)(a2 + 23) < 0) {
      operator delete(*(void **)a2);
    }
    long long v6 = *(_OWORD *)a3;
    *(void *)(a2 + 16) = *(void *)(a3 + 16);
    *(_OWORD *)a2 = v6;
    *(unsigned char *)(a3 + 23) = 0;
    *(unsigned char *)a3 = 0;
    long long v7 = *(_OWORD *)(a3 + 24);
    *(void *)(a3 + 24) = 0;
    *(void *)(a3 + 32) = 0;
    uint64_t v8 = *(std::__shared_weak_count **)(a2 + 32);
    *(_OWORD *)(a2 + 24) = v7;
    if (v8)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v8);
    }
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEEE16__generic_assignB8ne180100INS0_17__move_assignmentISE_LNS0_6_TraitE1EEEEEvOT_EUlRSK_OT0_E_JRNS0_6__baseILSI_1EJS9_SA_SB_SC_SD_EEEOSS_EEEDcSK_DpT0_(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *a1;
  if (*(_DWORD *)(v4 + 64) == 1)
  {
    if (*(char *)(a2 + 23) < 0) {
      operator delete(*(void **)a2);
    }
    long long v6 = *(_OWORD *)a3;
    *(void *)(a2 + 16) = *(void *)(a3 + 16);
    *(_OWORD *)a2 = v6;
    *(unsigned char *)(a3 + 23) = 0;
    *(unsigned char *)a3 = 0;
  }
  else
  {
  }
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEEE16__generic_assignB8ne180100INS0_17__move_assignmentISE_LNS0_6_TraitE1EEEEEvOT_EUlRSK_OT0_E_JRNS0_6__baseILSI_1EJS9_SA_SB_SC_SD_EEEOSS_EEEDcSK_DpT0_(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *(unsigned int *)(*a1 + 64);
  if (v5 == -1) {
    goto LABEL_9;
  }
  if (v5 != 2)
  {
    ((void (*)(char *, uint64_t))off_26C25D2D0[v5])(&v9, v4);
LABEL_9:
    *(_DWORD *)(v4 + 64) = -1;
    *(_DWORD *)(v4 + 64) = 2;
    return result;
  }
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
  long long v7 = *(_OWORD *)a3;
  *(void *)(a2 + 16) = *(void *)(a3 + 16);
  *(_OWORD *)a2 = v7;
  *(unsigned char *)(a3 + 23) = 0;
  *(unsigned char *)a3 = 0;
  *(void *)(a2 + 24) = *(void *)(a3 + 24);

  return MIL::Transform::ArgumentDescription::operator=(a2 + 32, a3 + 32);
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3ELm3EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEEE16__generic_assignB8ne180100INS0_17__move_assignmentISE_LNS0_6_TraitE1EEEEEvOT_EUlRSK_OT0_E_JRNS0_6__baseILSI_1EJS9_SA_SB_SC_SD_EEEOSS_EEEDcSK_DpT0_(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *(unsigned int *)(*a1 + 64);
  if (v5 == -1) {
    goto LABEL_9;
  }
  if (v5 != 3)
  {
    ((void (*)(char *, uint64_t))off_26C25D2D0[v5])(&v9, v4);
LABEL_9:
    *(_DWORD *)(v4 + 64) = -1;
    *(_DWORD *)(v4 + 64) = 3;
    return result;
  }
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
  long long v7 = *(_OWORD *)a3;
  *(void *)(a2 + 16) = *(void *)(a3 + 16);
  *(_OWORD *)a2 = v7;
  *(unsigned char *)(a3 + 23) = 0;
  *(unsigned char *)a3 = 0;

  return MIL::Transform::ArgumentDescription::operator=(a2 + 24, a3 + 24);
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm4ELm4EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN12_GLOBAL__N_120AttributeReplacementENS8_14OperatorChangeENS8_20SingleArgumentChangeENS8_25SingleArgumentReplacementENS8_27VariadicArgumentReplacementEEEEE16__generic_assignB8ne180100INS0_17__move_assignmentISE_LNS0_6_TraitE1EEEEEvOT_EUlRSK_OT0_E_JRNS0_6__baseILSI_1EJS9_SA_SB_SC_SD_EEEOSS_EEEDcSK_DpT0_(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *a1;
  if (*(_DWORD *)(v4 + 64) == 4)
  {
    if (*(char *)(a2 + 23) < 0) {
      operator delete(*(void **)a2);
    }
    long long v6 = *(_OWORD *)a3;
    *(void *)(a2 + 16) = *(void *)(a3 + 16);
    *(_OWORD *)a2 = v6;
    *(unsigned char *)(a3 + 23) = 0;
    *(unsigned char *)a3 = 0;
    std::vector<MIL::Transform::ArgumentDescription>::__vdeallocate((void **)(a2 + 24));
    *(_OWORD *)(a2 + 24) = *(_OWORD *)(a3 + 24);
    *(void *)(a2 + 40) = *(void *)(a3 + 40);
    *(void *)(a3 + 24) = 0;
    *(void *)(a3 + 32) = 0;
    *(void *)(a3 + 40) = 0;
  }
  else
  {
  }
}

uint64_t MIL::Transform::GetParameter(uint64_t a1, const void *a2, std::string::size_type a3)
{
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 64))(a1);
  if (a3 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  long long v7 = (void *)v6;
  if (a3 >= 0x17)
  {
    uint64_t v9 = (a3 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a3 | 7) != 0x17) {
      uint64_t v9 = a3 | 7;
    }
    uint64_t v10 = v9 + 1;
    p_dst = (std::string *)operator new(v9 + 1);
    __dst.__r_.__value_.__l.__size_ = a3;
    __dst.__r_.__value_.__r.__words[2] = v10 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_8;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = a3;
  p_dst = &__dst;
  if (a3) {
LABEL_8:
  }
    memmove(p_dst, a2, a3);
  p_dst->__r_.__value_.__s.__data_[a3] = 0;
  uint64_t v11 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v7, (unsigned __int8 *)&__dst);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  if (!v11)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, &__dst);
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  return *((void *)v11 + 5);
}

void sub_20F4897EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((v15 & 1) == 0) {
LABEL_6:
    }
      _Unwind_Resume(a1);
  }
  else if (!v15)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v16);
  goto LABEL_6;
}

uint64_t MIL::Transform::anonymous namespace'::MakeNoSuchParameterErrorMessage(uint64_t a1, uint64_t a2, uint64_t a3)
{
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v38);
  uint64_t v6 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v38, (uint64_t)"No such parameter '", 19);
  long long v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, a1, a2);
  uint64_t v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)"' defined for operator '", 24);
  uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 16))(a3);
  int v10 = *(char *)(v9 + 23);
  if (v10 >= 0) {
    uint64_t v11 = v9;
  }
  else {
    uint64_t v11 = *(void *)v9;
  }
  if (v10 >= 0) {
    uint64_t v12 = *(unsigned __int8 *)(v9 + 23);
  }
  else {
    uint64_t v12 = *(void *)(v9 + 8);
  }
  uint64_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, v11, v12);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)"'. ", 3);
  if (*(void *)((*(uint64_t (**)(uint64_t))(*(void *)a3 + 64))(a3) + 24))
  {
    std::string __p = 0;
    uint64_t v36 = 0;
    int v37 = 0;
    uint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 64))(a3);
    std::vector<MIL::Passes::BlockInfo>::reserve(&__p, *(void *)(v14 + 24));
    int v15 = *(uint64_t **)((*(uint64_t (**)(uint64_t))(*(void *)a3 + 64))(a3) + 16);
    if (v15)
    {
      do
      {
        if (*((char *)v15 + 39) < 0)
        {
          uint64_t v16 = (uint64_t *)v15[2];
          uint64_t v17 = v15[3];
        }
        else
        {
          uint64_t v16 = v15 + 2;
          uint64_t v17 = *((unsigned __int8 *)v15 + 39);
        }
        float v18 = v36;
        if (v36 >= v37)
        {
          uint64_t v20 = (v36 - (unsigned char *)__p) >> 4;
          unint64_t v21 = v20 + 1;
          if ((unint64_t)(v20 + 1) >> 60) {
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v22 = v37 - (unsigned char *)__p;
          if ((v37 - (unsigned char *)__p) >> 3 > v21) {
            unint64_t v21 = v22 >> 3;
          }
          if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v23 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v23 = v21;
          }
          if (v23) {
            unint64_t v24 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<MIL::IRBlock>>>((uint64_t)&v37, v23);
          }
          else {
            unint64_t v24 = 0;
          }
          uint64x2_t v25 = &v24[16 * v20];
          *(void *)uint64x2_t v25 = v16;
          *((void *)v25 + 1) = v17;
          uint64_t v27 = (char *)__p;
          uint64_t v26 = v36;
          uint64x2_t v28 = v25;
          if (v36 != __p)
          {
            do
            {
              *((_OWORD *)v28 - 1) = *((_OWORD *)v26 - 1);
              v28 -= 16;
              v26 -= 16;
            }
            while (v26 != v27);
            uint64_t v26 = (char *)__p;
          }
          BOOL v19 = v25 + 16;
          std::string __p = v28;
          uint64_t v36 = v25 + 16;
          int v37 = &v24[16 * v23];
          if (v26) {
            operator delete(v26);
          }
        }
        else
        {
          *(void *)uint64_t v36 = v16;
          *((void *)v18 + 1) = v17;
          BOOL v19 = v18 + 16;
        }
        uint64_t v36 = v19;
        int v15 = (uint64_t *)*v15;
      }
      while (v15);
    }
    else
    {
      BOOL v19 = v36;
    }
    unint64_t v29 = 126 - 2 * __clz((v19 - (unsigned char *)__p) >> 4);
    if (v19 == __p) {
      uint64_t v30 = 0;
    }
    else {
      uint64_t v30 = v29;
    }
    std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *,false>((long long *)__p, (long long *)v19, (uint64_t)&v41, v30, 1);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v38, (uint64_t)"Valid parameter names are: ", 27);
    uint64_t v31 = (char *)__p;
    if (v36 != __p)
    {
      uint64_t v32 = 0;
      unint64_t v33 = 0;
      do
      {
        if (v33)
        {
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v38, (uint64_t)", ", 2);
          uint64_t v31 = (char *)__p;
        }
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v38, *(void *)&v31[v32], *(void *)&v31[v32 + 8]);
        ++v33;
        uint64_t v31 = (char *)__p;
        v32 += 16;
      }
      while (v33 < (v36 - (unsigned char *)__p) >> 4);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v38, (uint64_t)".", 1);
    if (__p)
    {
      uint64_t v36 = (char *)__p;
      operator delete(__p);
    }
  }
  else
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v38, (uint64_t)"This operator has no defined parameters.", 40);
  }
  std::stringbuf::str();
  v38[0] = *MEMORY[0x263F8C2C8];
  *(void *)((char *)v38 + *(void *)(v38[0] - 24)) = *(void *)(MEMORY[0x263F8C2C8] + 24);
  v38[1] = MEMORY[0x263F8C318] + 16;
  if (v39 < 0) {
    operator delete((void *)v38[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x21056C620](&v40);
}

void sub_20F489C80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13)
{
  if (__p) {
    operator delete(__p);
  }
  std::ostringstream::~ostringstream((uint64_t)&a13);
  _Unwind_Resume(a1);
}

BOOL MIL::Transform::HasWriteEffectAndNoOutputs(MIL::Builder::OperationBuilder **a1)
{
  uint64_t Operator = MIL::Builder::OperationBuilder::GetOperator(*a1);
  BOOL result = 0;
  if ((*(uint64_t (**)(uint64_t))(*(void *)Operator + 240))(Operator))
  {
    uint64_t v3 = MIL::Builder::OperationBuilder::GetOperator(*a1);
    uint64_t v4 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v3 + 240))(v3);
    if (MIL::IRMemoryEffect::TryAsStateWriteEffect(v4))
    {
      if (!MIL::Builder::OperationBuilder::GetNumOutputs(*a1)) {
        return 1;
      }
    }
  }
  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *,false>(long long *a1, long long *a2, uint64_t a3, uint64_t a4, char a5)
{
uint64_t std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(const void **)a2;
  size_t v4 = *(void *)(a2 + 8);
  char v5 = *(const void **)a3;
  size_t v6 = *(void *)(a3 + 8);
  if (v6 >= v4) {
    size_t v7 = v4;
  }
  else {
    size_t v7 = *(void *)(a3 + 8);
  }
  int v8 = memcmp(v3, v5, v7);
  if (v4 < v6) {
    unsigned int v9 = -1;
  }
  else {
    unsigned int v9 = 1;
  }
  if (v4 == v6) {
    unsigned int v9 = 0;
  }
  if (v8) {
    unsigned int v9 = v8;
  }
  return v9 >> 31;
}

uint64_t std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(uint64_t result, long long *a2, uint64_t a3)
{
  if ((long long *)result != a2)
  {
    uint64_t v15 = v3;
    uint64_t v16 = v4;
    size_t v6 = (_OWORD *)result;
    uint64_t v7 = result + 16;
    if ((long long *)(result + 16) != a2)
    {
      uint64_t v9 = 0;
      int v10 = (long long *)result;
      do
      {
        uint64_t v11 = (uint64_t)v10;
        int v10 = (long long *)v7;
        BOOL result = std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(a3, v7, v11);
        if (result)
        {
          long long v14 = *v10;
          uint64_t v12 = v9;
          while (1)
          {
            *(_OWORD *)((char *)v6 + v12 + 16) = *(_OWORD *)((char *)v6 + v12);
            if (!v12) {
              break;
            }
            v12 -= 16;
            BOOL result = std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(a3, (uint64_t)&v14, (uint64_t)v6 + v12);
            if ((result & 1) == 0)
            {
              uint64_t v13 = (_OWORD *)((char *)v6 + v12 + 16);
              goto LABEL_10;
            }
          }
          uint64_t v13 = v6;
LABEL_10:
          *uint64_t v13 = v14;
        }
        uint64_t v7 = (uint64_t)(v10 + 1);
        v9 += 16;
      }
      while (v10 + 1 != a2);
    }
  }
  return result;
}

uint64_t std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(uint64_t result, long long *a2, uint64_t a3)
{
  if ((long long *)result != a2)
  {
    uint64_t v13 = v3;
    uint64_t v14 = v4;
    size_t v6 = (long long *)result;
    uint64_t v7 = result + 16;
    if ((long long *)(result + 16) != a2)
    {
      uint64_t v9 = result - 16;
      do
      {
        uint64_t v10 = (uint64_t)v6;
        size_t v6 = (long long *)v7;
        BOOL result = std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(a3, v7, v10);
        if (result)
        {
          long long v12 = *v6;
          uint64_t v11 = v9;
          do
          {
            *(_OWORD *)(v11 + 32) = *(_OWORD *)(v11 + 16);
            BOOL result = std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(a3, (uint64_t)&v12, v11);
            v11 -= 16;
          }
          while ((result & 1) != 0);
          *(_OWORD *)(v11 + 32) = v12;
        }
        uint64_t v7 = (uint64_t)(v6 + 1);
        v9 += 16;
      }
      while (v6 + 1 != a2);
    }
  }
  return result;
}

uint64_t std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(long long *a1, long long *a2, long long *a3, uint64_t a4)
{
  char v8 = std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(a4, (uint64_t)a2, (uint64_t)a1);
  uint64_t result = std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(a4, (uint64_t)a3, (uint64_t)a2);
  if ((v8 & 1) == 0)
  {
    if (!result) {
      return result;
    }
    long long v11 = *a2;
    *a2 = *a3;
    *a3 = v11;
    if (!std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(a4, (uint64_t)a2, (uint64_t)a1))return 1; {
    long long v12 = *a1;
    }
    *a1 = *a2;
    *a2 = v12;
    return 2;
  }
  if (!result)
  {
    long long v13 = *a1;
    *a1 = *a2;
    *a2 = v13;
    if (!std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(a4, (uint64_t)a3, (uint64_t)a2))return 1; {
    long long v14 = *a2;
    }
    *a2 = *a3;
    *a3 = v14;
    return 2;
  }
  long long v10 = *a1;
  *a1 = *a3;
  *a3 = v10;
  return 1;
}

long long *std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,std::string_view *,std::__less<void,void> &>(long long *a1, long long *a2, uint64_t a3)
{
  uint64_t v4 = a2;
  long long v11 = *a1;
  if (std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(a3, (uint64_t)&v11, (uint64_t)(a2 - 1)))
  {
    size_t v6 = a1;
    do
      ++v6;
    while ((std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(a3, (uint64_t)&v11, (uint64_t)v6) & 1) == 0);
  }
  else
  {
    unint64_t v7 = (unint64_t)(a1 + 1);
    do
    {
      size_t v6 = (long long *)v7;
      if (v7 >= (unint64_t)v4) {
        break;
      }
      int v8 = std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(a3, (uint64_t)&v11, v7);
      unint64_t v7 = (unint64_t)(v6 + 1);
    }
    while (!v8);
  }
  if (v6 < v4)
  {
    do
      --v4;
    while ((std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(a3, (uint64_t)&v11, (uint64_t)v4) & 1) != 0);
  }
  while (v6 < v4)
  {
    long long v12 = *v6;
    *size_t v6 = *v4;
    *uint64_t v4 = v12;
    do
      ++v6;
    while (!std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(a3, (uint64_t)&v11, (uint64_t)v6));
    do
      --v4;
    while ((std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(a3, (uint64_t)&v11, (uint64_t)v4) & 1) != 0);
  }
  uint64_t v9 = v6 - 1;
  if (v6 - 1 != a1) {
    *a1 = *v9;
  }
  long long *v9 = v11;
  return v6;
}

long long *std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,std::string_view *,std::__less<void,void> &>(long long *a1, unint64_t a2, uint64_t a3)
{
  uint64_t v6 = 0;
  long long v13 = *a1;
  do
    ++v6;
  while ((std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(a3, (uint64_t)&a1[v6], (uint64_t)&v13) & 1) != 0);
  unint64_t v7 = &a1[v6];
  int v8 = &a1[v6 - 1];
  if (v6 == 1)
  {
    do
    {
      if ((unint64_t)v7 >= a2) {
        break;
      }
      a2 -= 16;
    }
    while ((std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(a3, a2, (uint64_t)&v13) & 1) == 0);
  }
  else
  {
    do
      a2 -= 16;
    while (!std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(a3, a2, (uint64_t)&v13));
  }
  if ((unint64_t)v7 < a2)
  {
    uint64_t v9 = &a1[v6];
    long long v10 = (long long *)a2;
    do
    {
      long long v14 = *v9;
      long long v11 = v14;
      long long *v9 = *v10;
      *long long v10 = v11;
      do
        ++v9;
      while ((std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(a3, (uint64_t)v9, (uint64_t)&v13) & 1) != 0);
      do
        --v10;
      while (!std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(a3, (uint64_t)v10, (uint64_t)&v13));
    }
    while (v9 < v10);
    int v8 = v9 - 1;
  }
  if (v8 != a1) {
    *a1 = *v8;
  }
  *int v8 = v13;
  return v8;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(long long *a1, long long *a2, uint64_t a3)
{
  uint64_t v6 = a2 - a1;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      int v8 = a2 - 1;
      if (std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(a3, (uint64_t)(a2 - 1), (uint64_t)a1))
      {
        long long v9 = *a1;
        *a1 = *v8;
        *int v8 = v9;
      }
      return 1;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(a1, a1 + 1, a2 - 1, a3);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, a3);
      return 1;
    default:
      uint64_t v10 = (uint64_t)(a1 + 2);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(a1, a1 + 1, a1 + 2, a3);
      long long v11 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      uint64_t v12 = 0;
      int v13 = 0;
      break;
  }
  while (1)
  {
    if (std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(a3, (uint64_t)v11, v10))
    {
      long long v17 = *v11;
      uint64_t v14 = v12;
      while (1)
      {
        uint64_t v15 = (char *)a1 + v14;
        *(long long *)((char *)a1 + v14 + 48) = *(long long *)((char *)a1 + v14 + 32);
        if (v14 == -32) {
          break;
        }
        v14 -= 16;
        if ((std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(a3, (uint64_t)&v17, (uint64_t)(v15 + 16)) & 1) == 0)
        {
          uint64_t v16 = (long long *)((char *)a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      uint64_t v16 = a1;
LABEL_12:
      long long *v16 = v17;
      if (++v13 == 8) {
        return v11 + 1 == a2;
      }
    }
    uint64_t v10 = (uint64_t)v11;
    v12 += 16;
    if (++v11 == a2) {
      return 1;
    }
  }
}

__n128 std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(long long *a1, long long *a2, long long *a3, long long *a4, uint64_t a5)
{
  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(a1, a2, a3, a5);
  if (std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(a5, (uint64_t)a4, (uint64_t)a3))
  {
    long long v11 = *a3;
    *a3 = *a4;
    *a4 = v11;
    if (std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(a5, (uint64_t)a3, (uint64_t)a2))
    {
      long long v12 = *a2;
      *a2 = *a3;
      *a3 = v12;
      if (std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(a5, (uint64_t)a2, (uint64_t)a1))
      {
        __n128 result = (__n128)*a1;
        *a1 = *a2;
        *a2 = (__int128)result;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(long long *a1, long long *a2, long long *a3, long long *a4, long long *a5, uint64_t a6)
{
  std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(a1, a2, a3, a4, a6);
  if (std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(a6, (uint64_t)a5, (uint64_t)a4))
  {
    long long v13 = *a4;
    *a4 = *a5;
    *a5 = v13;
    if (std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(a6, (uint64_t)a4, (uint64_t)a3))
    {
      long long v14 = *a3;
      *a3 = *a4;
      *a4 = v14;
      if (std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(a6, (uint64_t)a3, (uint64_t)a2))
      {
        long long v15 = *a2;
        *a2 = *a3;
        *a3 = v15;
        if (std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(a6, (uint64_t)a2, (uint64_t)a1))
        {
          __n128 result = (__n128)*a1;
          *a1 = *a2;
          *a2 = (__int128)result;
        }
      }
    }
  }
  return result;
}

long long *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *,std::string_view *>(long long *a1, long long *a2, long long *a3, uint64_t a4)
{
  if (a1 != a2)
  {
    uint64_t v8 = (char *)a2 - (char *)a1;
    uint64_t v9 = a2 - a1;
    if ((char *)a2 - (char *)a1 >= 17)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      long long v12 = &a1[v10];
      do
      {
        std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>((uint64_t)a1, a4, v9, v12--);
        --v11;
      }
      while (v11);
    }
    long long v13 = a2;
    if (a2 != a3)
    {
      long long v14 = a2;
      do
      {
        if (std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(a4, (uint64_t)v14, (uint64_t)a1))
        {
          long long v15 = *v14;
          *long long v14 = *a1;
          *a1 = v15;
          std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>((uint64_t)a1, a4, v9, a1);
        }
        ++v14;
      }
      while (v14 != a3);
      long long v13 = a3;
    }
    if (v8 >= 17)
    {
      uint64_t v16 = (unint64_t)v8 >> 4;
      long long v17 = a2 - 1;
      do
      {
        long long v21 = *a1;
        float v18 = std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(a1, a4, v16);
        if (v17 == v18)
        {
          long long *v18 = v21;
        }
        else
        {
          long long *v18 = *v17;
          long long *v17 = v21;
          std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>((uint64_t)a1, (uint64_t)(v18 + 1), a4, v18 + 1 - a1);
        }
        --v17;
      }
      while (v16-- > 2);
    }
    return v13;
  }
  return a3;
}

double std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4)
{
  unint64_t v6 = a3 - 2;
  if (a3 >= 2)
  {
    uint64_t v21 = v4;
    uint64_t v22 = v5;
    unint64_t v7 = a4;
    int64_t v9 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) >= ((uint64_t)a4 - a1) >> 4)
    {
      uint64_t v12 = ((uint64_t)a4 - a1) >> 3;
      uint64_t v13 = v12 + 1;
      long long v14 = (long long *)(a1 + 16 * (v12 + 1));
      uint64_t v15 = v12 + 2;
      if (v12 + 2 < a3
        && std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(a2, a1 + 16 * (v12 + 1), (uint64_t)(v14 + 1)))
      {
        ++v14;
        uint64_t v13 = v15;
      }
      if ((std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(a2, (uint64_t)v14, (uint64_t)v7) & 1) == 0)
      {
        long long v20 = *v7;
        do
        {
          long long v17 = v14;
          *unint64_t v7 = *v14;
          if (v9 < v13) {
            break;
          }
          uint64_t v18 = (2 * v13) | 1;
          long long v14 = (long long *)(a1 + 16 * v18);
          uint64_t v19 = 2 * v13 + 2;
          if (v19 < a3)
          {
            if (std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(a2, a1 + 16 * v18, (uint64_t)(v14 + 1)))
            {
              ++v14;
              uint64_t v18 = v19;
            }
          }
          unint64_t v7 = v17;
          uint64_t v13 = v18;
        }
        while (!std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(a2, (uint64_t)v14, (uint64_t)&v20));
        double result = *(double *)&v20;
        long long *v17 = v20;
      }
    }
  }
  return result;
}

_OWORD *std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(_OWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = 0;
  uint64_t v7 = a3 - 2;
  if (a3 < 2) {
    uint64_t v7 = a3 - 1;
  }
  uint64_t v8 = v7 >> 1;
  do
  {
    int64_t v9 = &a1[v6 + 1];
    uint64_t v10 = (2 * v6) | 1;
    uint64_t v11 = 2 * v6 + 2;
    if (v11 < a3
      && std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(a2, (uint64_t)&a1[v6 + 1], (uint64_t)&a1[v6 + 2]))
    {
      ++v9;
      uint64_t v10 = v11;
    }
    *a1 = *v9;
    a1 = v9;
    uint64_t v6 = v10;
  }
  while (v10 <= v8);
  return v9;
}

double std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v6 = a4 - 2;
  if (a4 >= 2)
  {
    uint64_t v15 = v4;
    uint64_t v16 = v5;
    unint64_t v9 = v6 >> 1;
    uint64_t v10 = (long long *)(a1 + 16 * (v6 >> 1));
    uint64_t v11 = (long long *)(a2 - 16);
    if (std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(a3, (uint64_t)v10, a2 - 16))
    {
      long long v14 = *v11;
      do
      {
        uint64_t v13 = v10;
        *uint64_t v11 = *v10;
        if (!v9) {
          break;
        }
        unint64_t v9 = (v9 - 1) >> 1;
        uint64_t v10 = (long long *)(a1 + 16 * v9);
        uint64_t v11 = v13;
      }
      while ((std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string_view>(a3, (uint64_t)v10, (uint64_t)&v14) & 1) != 0);
      double result = *(double *)&v14;
      *uint64_t v13 = v14;
    }
  }
  return result;
}

uint64_t MIL::Transform::MatchContext::GetMILContext(MIL::Transform::MatchContext *this)
{
  return **(void **)this;
}

void **MIL::Transform::MatchContext::GetMILContextPtr@<X0>(void **this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = (*this)[1];
  *a2 = **this;
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return this;
}

uint64_t MIL::Transform::MatchContext::RejectMatch(uint64_t this)
{
  *(unsigned char *)(*(void *)this + 48) = 1;
  return this;
}

void MIL::Transform::MatchContext::AddOperation(uint64_t **a1, char *a2, uint64_t *a3)
{
  unint64_t v3 = a3[1];
  if (v3) {
    uint64_t v4 = *a3;
  }
  else {
    uint64_t v4 = 0;
  }
  MIL::Transform::MatchContext::AddOperation(a1, a2, v4, v3);
}

{
  unint64_t v3;
  uint64_t v4;

  unint64_t v3 = a3[1];
  if (v3) {
    uint64_t v4 = *a3;
  }
  else {
    uint64_t v4 = 0;
  }
  MIL::Transform::MatchContext::MatchContextImpl::AddOperation(*a1, a2, 1, v4, v3);
}

void MIL::Transform::MatchContext::AddOperation(uint64_t **a1, char *a2, uint64_t a3, unint64_t a4)
{
  long long v4 = 0u;
  long long v5 = 0u;
  int v6 = 1065353216;
  MIL::Transform::MatchContext::MatchContextImpl::AddOperation(*a1, a2, 1, a3, a4);
}

{
  MIL::Transform::MatchContext::MatchContextImpl::AddOperation(*a1, a2, 1, a3, a4);
}

void sub_20F48AE98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void MIL::Transform::MatchContext::AddVariadicParamOperation(uint64_t **a1, char *a2)
{
}

{
  long long v2;
  long long v3;
  int v4;

  uint64_t v2 = 0u;
  unint64_t v3 = 0u;
  long long v4 = 1065353216;
  MIL::Transform::MatchContext::MatchContextImpl::AddVariadicParamOperation(*a1, a2);
}

{
  MIL::Transform::MatchContext::MatchContextImpl::AddVariadicParamOperation(*a1, a2);
}

{
  MIL::Transform::MatchContext::MatchContextImpl::AddVariadicParamOperation(*a1, a2);
}

void sub_20F48AF24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void MIL::Transform::MatchContext::AddOperationWithSpecifiedOpsetName(uint64_t **a1, char *a2, uint64_t *a3)
{
  unint64_t v3 = *a1;
  unint64_t v4 = a3[1];
  if (v4) {
    uint64_t v5 = *a3;
  }
  else {
    uint64_t v5 = 0;
  }
  MIL::Transform::MatchContext::MatchContextImpl::AddOperation(v3, a2, 1, v5, v4);
}

void MIL::Transform::MatchContext::MatchContextImpl::AddOperation(uint64_t *a1, char *a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  uint64_t v25 = 0;
  unint64_t v26 = 0;
  v27[0] = 0;
  std::vector<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>>::reserve(&v25, a5);
  if (a5)
  {
    uint64_t v7 = 40 * a5;
    uint64_t v8 = (const MIL::Transform::ArgumentDescription *)(a4 + 8);
    do
    {
      MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)v33, v8);
      long long v20 = 0;
      uint64_t v21 = 0;
      uint64_t v22 = 0;
      uint64x2_t v28 = (void **)&v20;
      LOBYTE(v29) = 0;
      long long v20 = (char *)operator new(0x20uLL);
      uint64_t v21 = v20;
      uint64_t v22 = v20 + 32;
      uint64_t v21 = (unsigned char *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<MIL::Transform::ArgumentDescription>,MIL::Transform::ArgumentDescription const*,MIL::Transform::ArgumentDescription const*,MIL::Transform::ArgumentDescription*>((uint64_t)&v22, (uint64_t)v33, (uint64_t)&v34, (uint64_t)v20);
      *(_OWORD *)long long v23 = *((unint64_t *)v8 - 1);
      *(void *)&v23[16] = 0;
      unint64_t v24 = 0;
      std::vector<MIL::Transform::ArgumentDescription>::__init_with_size[abi:ne180100]<MIL::Transform::ArgumentDescription*,MIL::Transform::ArgumentDescription*>(&v23[8], (uint64_t)v20, (uint64_t)v21, (v21 - v20) >> 5);
      unint64_t v9 = v26;
      if (v26 >= v27[0])
      {
        uint64_t v11 = (uint64_t)(v26 - v25) >> 5;
        unint64_t v12 = v11 + 1;
        if ((unint64_t)(v11 + 1) >> 59) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v13 = v27[0] - v25;
        if ((v27[0] - v25) >> 4 > v12) {
          unint64_t v12 = v13 >> 4;
        }
        if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v14 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v14 = v12;
        }
        uint64_t v32 = v27;
        uint64_t v15 = (void **)std::__allocate_at_least[abi:ne180100]<std::allocator<std::function<void ()(MIL::Transform::ProgramTransformer &)>>>((uint64_t)v27, v14);
        uint64_t v16 = &v15[4 * v11];
        uint64x2_t v28 = v15;
        unint64_t v29 = v16;
        uint64_t v31 = &v15[4 * v17];
        long long *v16 = *(void **)v23;
        v16[1] = 0;
        void v16[2] = 0;
        v16[3] = 0;
        *(_OWORD *)(v16 + 1) = *(_OWORD *)&v23[8];
        v16[3] = v24;
        *(void *)&v23[8] = 0;
        *(void *)&v23[16] = 0;
        unint64_t v24 = 0;
        uint64_t v30 = v16 + 4;
        std::vector<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>>::__swap_out_circular_buffer(&v25, &v28);
        unint64_t v10 = v26;
        std::__split_buffer<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>>::~__split_buffer((void **)&v28);
      }
      else
      {
        *(void *)(v26 + 8) = 0;
        *(void *)(v9 + 16) = 0;
        *(void *)(v9 + 24) = 0;
        *(_OWORD *)unint64_t v9 = *(_OWORD *)v23;
        *(void *)(v9 + 16) = *(void *)&v23[16];
        *(void *)(v9 + 24) = v24;
        *(void *)&v23[8] = 0;
        *(void *)&v23[16] = 0;
        unint64_t v24 = 0;
        unint64_t v10 = v9 + 32;
      }
      unint64_t v26 = v10;
      uint64x2_t v28 = (void **)&v23[8];
      std::vector<MIL::Transform::ArgumentDescription>::__destroy_vector::operator()[abi:ne180100](&v28);
      uint64x2_t v28 = (void **)&v20;
      std::vector<MIL::Transform::ArgumentDescription>::__destroy_vector::operator()[abi:ne180100](&v28);
      MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)v33);
      uint64_t v8 = (const MIL::Transform::ArgumentDescription *)((char *)v8 + 40);
      v7 -= 40;
    }
    while (v7);
  }
  MIL::Transform::MatchContext::MatchContextImpl::AddVariadicParamOperation(a1, a2);
}

void sub_20F48B2C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void **a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
  a17 = (void **)&a22;
  std::vector<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>>::__destroy_vector::operator()[abi:ne180100](&a17);
  _Unwind_Resume(a1);
}

void MIL::Transform::MatchContext::AddOperationWithSpecifiedOpsetName(uint64_t **a1, char *a2, uint64_t a3, unint64_t a4)
{
}

void MIL::Transform::MatchContext::MatchContextImpl::AddVariadicParamOperation(uint64_t *a1, char *__s)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v3 = *a1;
  size_t v4 = strlen(__s);
  MIL::Matching::GetOperatorByQualifiedName(v3, (unsigned __int8 *)__s, v4, &v9);
  long long v6 = 0u;
  long long v7 = 0u;
  int v8 = 1065353216;
  v5[0] = v9;
  v5[1] = v10;
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
  MIL::Builder::OperationBuilder::Make((uint64_t)v5);
}

void sub_20F48BB04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,int a47,__int16 a48,char a49,char a50,void *__p,uint64_t a52,int a53,__int16 a54,char a55,char a56)
{
  if (*(char *)(v58 - 153) < 0) {
    operator delete(*(void **)(v58 - 176));
  }
  if (a56 < 0) {
    operator delete(__p);
  }
  if (a38 < 0) {
    operator delete(a33);
  }
  if (*(char *)(v58 - 105) < 0) {
    operator delete(*(void **)(v58 - 128));
  }
  if (a50 < 0)
  {
    operator delete(a45);
    if ((v57 & 1) == 0)
    {
LABEL_14:
      v60 = *(std::__shared_weak_count **)(v58 - 248);
      if (v60) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v60);
      }
      std::__hash_table<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>>>::~__hash_table(v58 - 240);
      unint64_t v61 = *(std::__shared_weak_count **)(v58 - 184);
      if (v61) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v61);
      }
      _Unwind_Resume(a1);
    }
  }
  else if (!v57)
  {
    goto LABEL_14;
  }
  __cxa_free_exception(v56);
  goto LABEL_14;
}

void MIL::Transform::MatchContext::AddOperation(uint64_t **a1, void *a2, std::string::size_type *a3)
{
  uint64_t v3 = a3[1];
  if (v3) {
    std::string::size_type v4 = *a3;
  }
  else {
    std::string::size_type v4 = 0;
  }
  MIL::Transform::MatchContext::AddOperation(a1, a2, v4, v3);
}

void MIL::Transform::MatchContext::AddOperation(uint64_t **a1, void *a2, std::string::size_type a3, uint64_t a4)
{
  MIL::Matching::MatchView::MatchView(&v9, a2);
  Operation = (MIL::Builder::OperationBuilder *)MIL::MatchingPrivate::MatchPrivate::GetOperation(&v9);
  MIL::Matching::MatchView::~MatchView((MIL::Matching::MatchView *)&v9);
  if (MIL::Builder::OperationBuilder::GetNumOutputs(Operation) == 1) {
    MIL::Transform::MatchContext::MatchContextImpl::AddOperationFromPrototype(*a1, Operation, a3, a4);
  }
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::invalid_argument::invalid_argument[abi:ne180100](exception, "Source operation does not have exactly one output. Please use AddMultiOutputOperation() instead.");
  __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
}

void sub_20F48BDDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  __cxa_free_exception(v10);
  _Unwind_Resume(a1);
}

void MIL::Transform::MatchContext::MatchContextImpl::AddOperationFromPrototype(uint64_t *a1, MIL::Builder::OperationBuilder *this, std::string::size_type a3, uint64_t a4)
{
  MIL::Builder::OperationBuilder::TryGetOperatorSharedPtr((uint64_t)this, &v12);
  Parameters = (void *)MIL::Builder::OperationBuilder::GetParameters(this);
  MIL::Transform::MatchContext::MatchContextImpl::ConvertParamMap(Parameters, (uint64_t)&v13);
  MIL::Builder::OperationBuilder::GetBlocks(this, v14);
  uint64_t Attributes = MIL::Builder::OperationBuilder::GetAttributes(this);
  std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>::unordered_map((uint64_t)&v15, Attributes);
  if (a4)
  {
    uint64_t v11 = a4 << 7;
    do
    {
      MIL::TransformPrivate::OperationChangePrivate::ApplyChange(&v12, a3, *a1, (uint64_t)(a1 + 7));
      a3 += 128;
      v11 -= 128;
    }
    while (v11);
  }
  MIL::Transform::MatchContext::MatchContextImpl::CreateOperationBuilderFromProperties((MIL::Transform::MatchContext::MatchContextImpl *)&v12, v10);
}

void sub_20F48C0F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,std::__shared_weak_count *a26,uint64_t a27,char a28)
{
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  std::__hash_table<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>>>::~__hash_table((uint64_t)&a19);
  if (a26) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a26);
  }
  MIL::TransformPrivate::OperationProperties::~OperationProperties((MIL::TransformPrivate::OperationProperties *)&a28);
  _Unwind_Resume(a1);
}

void MIL::Transform::MatchContext::AddMultiOutputOperation(uint64_t **a1, char *a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v4 = a4[1];
  if (v4) {
    uint64_t v5 = *a4;
  }
  else {
    uint64_t v5 = 0;
  }
  MIL::Transform::MatchContext::AddMultiOutputOperation(a1, a2, a3, v5, v4);
}

{
  unint64_t v4;
  uint64_t v5;

  unint64_t v4 = a4[1];
  if (v4) {
    uint64_t v5 = *a4;
  }
  else {
    uint64_t v5 = 0;
  }
  MIL::Transform::MatchContext::MatchContextImpl::AddOperation(*a1, a2, a3, v5, v4);
}

void MIL::Transform::MatchContext::AddMultiOutputOperation(uint64_t **a1, char *a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  long long v5 = 0u;
  long long v6 = 0u;
  int v7 = 1065353216;
  MIL::Transform::MatchContext::MatchContextImpl::AddOperation(*a1, a2, a3, a4, a5);
}

{
  MIL::Transform::MatchContext::MatchContextImpl::AddOperation(*a1, a2, a3, a4, a5);
}

void sub_20F48C220(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void MIL::Transform::MatchContext::AddMultiOutputOperation(uint64_t **a1, void *a2, std::string::size_type *a3)
{
  uint64_t v3 = a3[1];
  if (v3) {
    std::string::size_type v4 = *a3;
  }
  else {
    std::string::size_type v4 = 0;
  }
  MIL::Transform::MatchContext::AddMultiOutputOperation(a1, a2, v4, v3);
}

void MIL::Transform::MatchContext::AddMultiOutputOperation(uint64_t **a1, void *a2, std::string::size_type a3, uint64_t a4)
{
  MIL::Matching::MatchView::MatchView(&v8, a2);
  Operation = (MIL::Builder::OperationBuilder *)MIL::MatchingPrivate::MatchPrivate::GetOperation(&v8);
  MIL::Matching::MatchView::~MatchView((MIL::Matching::MatchView *)&v8);
  MIL::Transform::MatchContext::MatchContextImpl::AddOperationFromPrototype(*a1, Operation, a3, a4);
}

void sub_20F48C374(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  MIL::Matching::MatchView::~MatchView((MIL::Matching::MatchView *)va);
  _Unwind_Resume(a1);
}

void MIL::Transform::MatchContext::MapOutput(MIL::Transform::MatchContext *this, const MIL::Transform::NewOperationOutput *a2, const MIL::Matching::OutputView *a3)
{
  uint64_t OperationAndOutputIndex = MIL::MatchingPrivate::MatchPrivate::GetOperationAndOutputIndex(a3, a2);
  int v7 = v6;
  uint64_t v8 = MIL::MatchingPrivate::MatchPrivate::GetOperationAndOutputIndex(a2, v6);
  uint64_t v10 = v8;
  uint64_t v11 = v9;
  uint64_t v12 = *(void **)this;
  unint64_t v14 = (uint64_t *)v12[11];
  unint64_t v13 = v12[12];
  if ((unint64_t)v14 >= v13)
  {
    uint64_t v16 = (uint64_t *)v12[10];
    uint64_t v17 = ((char *)v14 - (char *)v16) >> 5;
    unint64_t v18 = v17 + 1;
    if ((unint64_t)(v17 + 1) >> 59) {
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v19 = v13 - (void)v16;
    if (v19 >> 4 > v18) {
      unint64_t v18 = v19 >> 4;
    }
    if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v20 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v20 = v18;
    }
    if (v20)
    {
      if (v20 >> 59) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint64_t v21 = (char *)operator new(32 * v20);
    }
    else
    {
      uint64_t v21 = 0;
    }
    uint64_t v22 = (uint64_t *)&v21[32 * v17];
    *uint64_t v22 = OperationAndOutputIndex;
    v22[1] = (uint64_t)v7;
    v22[2] = v10;
    v22[3] = v11;
    uint64_t v15 = v22 + 4;
    if (v14 != v16)
    {
      do
      {
        long long v23 = *((_OWORD *)v14 - 1);
        *((_OWORD *)v22 - 2) = *((_OWORD *)v14 - 2);
        *((_OWORD *)v22 - 1) = v23;
        v22 -= 4;
        v14 -= 4;
      }
      while (v14 != v16);
      unint64_t v14 = (uint64_t *)v12[10];
    }
    v12[10] = v22;
    v12[11] = v15;
    v12[12] = &v21[32 * v20];
    if (v14) {
      operator delete(v14);
    }
  }
  else
  {
    *unint64_t v14 = OperationAndOutputIndex;
    v14[1] = (uint64_t)v7;
    uint64_t v15 = v14 + 4;
    void v14[2] = v8;
    void v14[3] = v9;
  }
  v12[11] = v15;
}

void MIL::Transform::ProgramTransformer::~ProgramTransformer(MIL::Transform::ProgramTransformer *this)
{
  uint64_t v1 = *(void *)this;
  *(void *)this = 0;
  if (v1) {
    std::default_delete<MIL::Transform::ProgramTransformer::ProgramTransformerImpl>::operator()[abi:ne180100]((uint64_t)this, v1);
  }
}

{
  uint64_t v1;

  uint64_t v1 = *(void *)this;
  *(void *)this = 0;
  if (v1) {
    std::default_delete<MIL::Transform::ProgramTransformer::ProgramTransformerImpl>::operator()[abi:ne180100]((uint64_t)this, v1);
  }
}

void MIL::Transform::ProgramTransformer::ProgramTransformer(MIL::Transform::ProgramTransformer *this, const MIL::IRProgram *a2)
{
  (*(void (**)(long long *__return_ptr, const MIL::IRProgram *))(*(void *)a2 + 48))(&v2, a2);
  operator new();
}

void sub_20F48C5DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  MEMORY[0x21056C700](v12, 0x1022C40DEB6DFD1);
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(a1);
}

void MIL::Transform::ProgramTransformer::MatchAndReplace(void **a1, uint64_t a2, uint64_t a3)
{
}

void MIL::Transform::ProgramTransformer::ProgramTransformerImpl::MatchAndReplace(void *a1, uint64_t a2, uint64_t a3)
{
  MIL::Transform::ProgramTransformer::ProgramTransformerImpl::MatchAndReplaceHelper::MatchAndReplaceHelper((uint64_t)v6, a1, a1 + 2);
  MIL::Transform::ProgramTransformer::ProgramTransformerImpl::DoMatchAndReplace((uint64_t)a1, (uint64_t)v6, a2, a3);
  MIL::Transform::ProgramTransformer::ProgramTransformerImpl::MatchAndReplaceHelper::~MatchAndReplaceHelper((MIL::Transform::ProgramTransformer::ProgramTransformerImpl::MatchAndReplaceHelper *)v6);
}

void sub_20F48C690(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void MIL::Transform::ProgramTransformer::MatchAndReplace(MIL::MILContext ***a1, const MIL::Matching::Pattern *a2, uint64_t a3)
{
  MIL::Matching::CompiledPattern::CompiledPattern((MIL::Matching::CompiledPattern *)v5, a2, **a1);
  MIL::Transform::ProgramTransformer::ProgramTransformerImpl::MatchAndReplace(*a1, (uint64_t)v5, a3);
  MIL::Matching::CompiledPattern::~CompiledPattern((MIL::Matching::CompiledPattern *)v5);
}

void sub_20F48C6F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t MIL::Transform::ProgramTransformer::EliminateDeadNodes(MIL::Builder::ProgramBuilder ***this)
{
  return MIL::Transform::ProgramTransformer::ProgramTransformerImpl::EliminateDeadNodes(*this);
}

uint64_t MIL::Transform::ProgramTransformer::ProgramTransformerImpl::EliminateDeadNodes(MIL::Builder::ProgramBuilder **this)
{
  uint64_t result = MIL::Builder::ProgramBuilder::GetFunctions(this[4]);
  for (uint64_t i = *(uint64_t ***)(result + 16); i; uint64_t i = (uint64_t **)*i)
  {
    memset(v15, 0, sizeof(v15));
    int v16 = 1065353216;
    MIL::Builder::FunctionBuilder::GetInputs((MIL::Builder::FunctionBuilder::FunctionBuilderImpl **)i[5], (uint64_t)&v12);
    for (uint64_t j = (uint64_t **)v13; j; uint64_t j = (uint64_t **)*j)
    {
      uint64_t Name = (unsigned __int8 *)MIL::Builder::Variable::GetName((MIL::Builder::Variable::VariableImpl **)j[2]);
      std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t)v15, Name, (uint64_t)Name);
    }
    std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table((uint64_t)&v12);
    long long v12 = 0u;
    long long v13 = 0u;
    int v14 = 1065353216;
    long long v6 = (void *)(MIL::Builder::FunctionBuilder::GetSpecializations((MIL::Builder::FunctionBuilder *)i[5]) + 16);
    while (1)
    {
      long long v6 = (void *)*v6;
      if (!v6) {
        break;
      }
      int v7 = (std::__shared_weak_count *)v6[6];
      uint64_t v9 = (MIL::Builder::BlockBuilder *)v6[5];
      uint64_t v10 = v7;
      if (v7) {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::Transform::ProgramTransformer::ProgramTransformerImpl::GetBlockOutsAndWriteEffectOpIns(&v9, &v11);
      MIL::Transform::ProgramTransformer::ProgramTransformerImpl::RemoveRedundantOps((uint64_t)this, v6 + 5, v15, (uint64_t *)&v11, &v12);
      uint64_t v17 = &v11;
      std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v17);
      if (v10) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v10);
      }
      if (*((void *)&v13 + 1))
      {
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "found unresolved names! please check your inputs & outputs");
        __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
      }
    }
    std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&v12);
    uint64_t result = std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v15);
  }
  return result;
}

void sub_20F48C890(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)va);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)va1);
  _Unwind_Resume(a1);
}

void MIL::Transform::ProgramTransformer::ExtractSubProgram(uint64_t *a1, unsigned __int8 **a2, uint64_t *a3, unsigned __int8 *a4)
{
}

void MIL::Transform::ProgramTransformer::ProgramTransformerImpl::ExtractSubProgram(uint64_t a1, unsigned __int8 **a2, uint64_t *a3, unsigned __int8 *a4)
{
  MIL::Builder::ProgramBuilder::GetFunction(*(void *)(a1 + 32), a4, &v52);
  int v7 = v52;
  uint64_t v8 = (unsigned __int8 *)MIL::Builder::FunctionBuilder::SelectedSpecialization((MIL::Builder::FunctionBuilder *)v52);
  MIL::Builder::FunctionBuilder::GetBlock((uint64_t)v7, v8, &v50);
  MIL::Builder::BlockBuilder::GetOperations(v50, v46);
  uint64_t v10 = *((void *)&v46[0] + 1);
  for (uint64_t i = *(void *)&v46[0]; i != v10; i += 16)
  {
    uint64_t v11 = *(MIL::Builder::OperationBuilder **)i;
    uint64_t v12 = *(std::__shared_weak_count **)(i + 8);
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v49 = v12;
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    else
    {
      uint64_t v49 = 0;
    }
    uint64_t v48 = v11;
    BOOL v13 = MIL::Transform::HasWriteEffectAndNoOutputs(&v48);
    if (v49) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v49);
    }
    if (v13)
    {
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::logic_error::logic_error(exception, "This ExtractSubProgram function with inputs/outputs arguments is not supported currently for programs with ops that have write-state-effect and no outputs. The other ExtractSubProgram overload with op indices is supported.");
      exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
      __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
    }
    if (v12) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v12);
    }
  }
  *(void *)&long long v44 = v46;
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v44);
  memset(v46, 0, sizeof(v46));
  int v47 = 1065353216;
  MIL::Builder::FunctionBuilder::GetInputs(v52, (uint64_t)&v44);
  for (uint64_t j = v45; j; uint64_t j = (void *)*j)
  {
    uint64_t v15 = (MIL::Builder::Variable::VariableImpl **)j[2];
    uint64_t Type = MIL::Builder::Variable::TryGetType(v15);
    uint64_t Name = (unsigned __int8 *)MIL::Builder::Variable::GetName(v15);
    if (!Type)
    {
      uint64_t v34 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::operator+<char>();
      std::runtime_error::runtime_error(v34, (const std::string *)v42);
      __cxa_throw(v34, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
    }
    *(void *)uint64_t v42 = Name;
    *((void *)std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v46, Name, (uint64_t)&std::piecewise_construct, (long long **)v42)+ 5) = Type;
  }
  uint64_t v38 = a1;
  char v39 = a2;
  std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table((uint64_t)&v44);
  MIL::Builder::BlockBuilder::GetOperations(v50, &v44);
  uint64_t v19 = *((void *)&v44 + 1);
  for (uint64_t k = v44; k != v19; k += 16)
  {
    unint64_t v20 = *(MIL::Builder::OperationBuilder::OperationBuilderImpl ***)k;
    uint64_t v21 = *(std::__shared_weak_count **)(k + 8);
    if (v21) {
      atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    MIL::Builder::OperationBuilder::GetOutputs(v20, (void **)v42);
    uint64_t v22 = *(MIL::Builder::Variable::VariableImpl ****)&v42[8];
    long long v23 = *(MIL::Builder::Variable::VariableImpl ****)v42;
    if (*(void *)v42 != *(void *)&v42[8])
    {
      do
      {
        unint64_t v24 = *v23;
        if (!*v23)
        {
          uint64_t v32 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(v32, "invalid operation output variable.");
          __cxa_throw(v32, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
        }
        uint64_t v25 = (long long *)MIL::Builder::Variable::GetName(*v23);
        uint64_t v26 = MIL::Builder::Variable::TryGetType(v24);
        uint64_t v54 = v25;
        *((void *)std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v46, (unsigned __int8 *)v25, (uint64_t)&std::piecewise_construct, &v54)+ 5) = v26;
        ++v23;
      }
      while (v23 != v22);
      long long v23 = *(MIL::Builder::Variable::VariableImpl ****)v42;
    }
    if (v23)
    {
      *(void *)&v42[8] = v23;
      operator delete(v23);
    }
    if (v21) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v21);
    }
  }
  *(void *)uint64_t v42 = &v44;
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100]((void ***)v42);
  if (*a3 == a3[1])
  {
    uint64_t v36 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v36, "output names cannot be empty");
    v36->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(v36, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  std::unordered_set<std::string>::unordered_set<std::__wrap_iter<std::string const*>>((uint64_t)&v44, *v39, v39[1]);
  memset(v42, 0, sizeof(v42));
  int v43 = 1065353216;
  MIL::Transform::ProgramTransformer::ProgramTransformerImpl::RemoveRedundantOps(v38, (uint64_t *)&v50, &v44, a3, v42);
  if (*(void *)&v42[24])
  {
    int v37 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v37, "found unresolved names! please check your inputs & outputs");
    __cxa_throw(v37, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
  }
  MIL::Builder::BlockBuilder::UpdateOutputNames((uint64_t)v50, (long long **)a3);
  MIL::Builder::FunctionBuilder::ClearInputs((MIL::Builder::FunctionBuilder *)v52);
  uint64_t v27 = *v39;
  uint64x2_t v28 = v39[1];
  if (*v39 != v28)
  {
    do
    {
      if (!std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>(v46, v27))
      {
        uint64_t v35 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::operator+<char>();
        std::runtime_error::runtime_error(v35, &v41);
        __cxa_throw(v35, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
      }
      unint64_t v29 = v52;
      if ((char)v27[23] < 0)
      {
        std::string::__init_copy_ctor_external(&v40, *(const std::string::value_type **)v27, *((void *)v27 + 1));
      }
      else
      {
        long long v30 = *(_OWORD *)v27;
        v40.__r_.__value_.__r.__words[2] = *((void *)v27 + 2);
        *(_OWORD *)&v40.__r_.__value_.__l.__data_ = v30;
      }
      v41.__r_.__value_.__r.__words[0] = (std::string::size_type)v27;
      uint64_t v31 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v46, v27, (uint64_t)&std::piecewise_construct, (long long **)&v41);
      MIL::Builder::FunctionBuilder::AddInput((uint64_t)v29, (uint64_t)&v40, *((void *)v31 + 5));
      if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v40.__r_.__value_.__l.__data_);
      }
      v27 += 24;
    }
    while (v27 != v28);
  }
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v42);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&v44);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v46);
  if (v51) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v51);
  }
  if (v53) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v53);
  }
}

void sub_20F48CE5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36)
{
  __cxa_free_exception(v36);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&a23);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&a31);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&a36);
  char v39 = *(std::__shared_weak_count **)(v37 - 128);
  if (v39) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v39);
  }
  std::string v40 = *(std::__shared_weak_count **)(v37 - 112);
  if (v40) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v40);
  }
  _Unwind_Resume(a1);
}

void MIL::Transform::ProgramTransformer::ExtractSubProgram(uint64_t **a1, unint64_t a2, unint64_t a3, unsigned __int8 *a4)
{
}

void MIL::Transform::ProgramTransformer::ProgramTransformerImpl::ExtractSubProgram(uint64_t *a1, unint64_t a2, unint64_t a3, unsigned __int8 *a4)
{
  MIL::Builder::ProgramBuilder::GetFunction(a1[4], a4, &v55);
  uint64_t v8 = v55;
  uint64_t v9 = (unsigned __int8 *)MIL::Builder::FunctionBuilder::SelectedSpecialization(v55);
  MIL::Builder::FunctionBuilder::GetBlock((uint64_t)v8, v9, &v53);
  if (MIL::Builder::BlockBuilder::GetNumOperations((MIL::Builder::BlockBuilder *)v53) < a3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::to_string(&v49, a3);
    long long v23 = std::string::insert(&v49, 0, "Attempted to extract upto opIdxEnd ");
    long long v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
    v50.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v50.__r_.__value_.__l.__data_ = v24;
    v23->__r_.__value_.__l.__size_ = 0;
    v23->__r_.__value_.__r.__words[2] = 0;
    v23->__r_.__value_.__r.__words[0] = 0;
    uint64_t v25 = std::string::append(&v50, " , but block contains only a total of ");
    long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
    v51.__r_.__value_.__r.__words[2] = v25->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v51.__r_.__value_.__l.__data_ = v26;
    v25->__r_.__value_.__l.__size_ = 0;
    v25->__r_.__value_.__r.__words[2] = 0;
    v25->__r_.__value_.__r.__words[0] = 0;
    unint64_t NumOperations = MIL::Builder::BlockBuilder::GetNumOperations((MIL::Builder::BlockBuilder *)v53);
    std::to_string(&v48, NumOperations);
    if ((v48.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64x2_t v28 = &v48;
    }
    else {
      uint64x2_t v28 = (std::string *)v48.__r_.__value_.__r.__words[0];
    }
    if ((v48.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v48.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v48.__r_.__value_.__l.__size_;
    }
    long long v30 = std::string::append(&v51, (const std::string::value_type *)v28, size);
    long long v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
    v52.__r_.__value_.__r.__words[2] = v30->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v31;
    v30->__r_.__value_.__l.__size_ = 0;
    v30->__r_.__value_.__r.__words[2] = 0;
    v30->__r_.__value_.__r.__words[0] = 0;
    uint64_t v32 = std::string::append(&v52, " operations.");
    long long v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
    v46.__r_.__value_.__r.__words[2] = v32->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v46.__r_.__value_.__l.__data_ = v33;
    v32->__r_.__value_.__l.__size_ = 0;
    v32->__r_.__value_.__r.__words[2] = 0;
    v32->__r_.__value_.__r.__words[0] = 0;
    std::logic_error::logic_error(exception, &v46);
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  if (a2 >= a3)
  {
    uint64_t v34 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    unint64_t v35 = a2;
    uint64_t v36 = v34;
    std::to_string(&v50, v35);
    uint64_t v37 = std::string::insert(&v50, 0, "opIdxBegin ");
    long long v38 = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
    v51.__r_.__value_.__r.__words[2] = v37->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v51.__r_.__value_.__l.__data_ = v38;
    v37->__r_.__value_.__l.__size_ = 0;
    v37->__r_.__value_.__r.__words[2] = 0;
    v37->__r_.__value_.__r.__words[0] = 0;
    char v39 = std::string::append(&v51, " needs to be strictly less than opIdxEnd ");
    long long v40 = *(_OWORD *)&v39->__r_.__value_.__l.__data_;
    v52.__r_.__value_.__r.__words[2] = v39->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v40;
    v39->__r_.__value_.__l.__size_ = 0;
    v39->__r_.__value_.__r.__words[2] = 0;
    v39->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v49, a3);
    if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string v41 = &v49;
    }
    else {
      std::string v41 = (std::string *)v49.__r_.__value_.__r.__words[0];
    }
    if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v42 = HIBYTE(v49.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v42 = v49.__r_.__value_.__l.__size_;
    }
    int v43 = std::string::append(&v52, (const std::string::value_type *)v41, v42);
    long long v44 = *(_OWORD *)&v43->__r_.__value_.__l.__data_;
    v46.__r_.__value_.__r.__words[2] = v43->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v46.__r_.__value_.__l.__data_ = v44;
    v43->__r_.__value_.__l.__size_ = 0;
    v43->__r_.__value_.__r.__words[2] = 0;
    v43->__r_.__value_.__r.__words[0] = 0;
    std::logic_error::logic_error(v36, &v46);
    v36->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(v36, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  MIL::Transform::ProgramTransformer::ProgramTransformerImpl::GetInputsAndOutputs(a1, a4, a2, a3, &v46);
  MIL::Builder::FunctionBuilder::ClearInputs(v55);
  std::string::size_type v11 = v46.__r_.__value_.__l.__size_;
  for (uint64_t i = v46.__r_.__value_.__r.__words[0]; i != v11; i += 24)
  {
    uint64_t Type = MIL::Builder::BlockBuilder::GetType((uint64_t)v53, i);
    if (Type)
    {
      BOOL v13 = v55;
      if (*(char *)(i + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)i, *(void *)(i + 8));
      }
      else
      {
        long long v14 = *(_OWORD *)i;
        __p.__r_.__value_.__r.__words[2] = *(void *)(i + 16);
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v14;
      }
      MIL::Builder::FunctionBuilder::AddInput((uint64_t)v13, (uint64_t)&__p, Type);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
  }
  uint64_t v15 = MIL::Builder::BlockBuilder::GetNumOperations((MIL::Builder::BlockBuilder *)v53);
  std::vector<unsigned long>::vector(&v52, a2 - a3 + v15);
  std::string::size_type v16 = v52.__r_.__value_.__r.__words[0];
  uint64_t v17 = (void *)(v52.__r_.__value_.__r.__words[0] + 8 * (int)a2);
  if (a2 << 32)
  {
    uint64_t v18 = 0;
    uint64_t v19 = 8 * (int)a2;
    do
    {
      *(void *)(v16 + 8 * v18) = v18;
      ++v18;
      v19 -= 8;
    }
    while (v19);
  }
  std::string::size_type v20 = v52.__r_.__value_.__l.__size_;
  while (v17 != (void *)v20)
    *v17++ = a3++;
  if (v20 == v16) {
    uint64_t v21 = 0;
  }
  else {
    uint64_t v21 = (void *)v16;
  }
  MIL::Builder::BlockBuilder::RemoveOperations((uint64_t)v53, v21, (uint64_t)(v20 - v16) >> 3, 1);
  MIL::Builder::BlockBuilder::UpdateOutputNames((uint64_t)v53, v47);
  MIL::Builder::BlockBuilder::UpdateStateDependencyMap(v53);
  if (v52.__r_.__value_.__r.__words[0])
  {
    v52.__r_.__value_.__l.__size_ = v52.__r_.__value_.__r.__words[0];
    operator delete(v52.__r_.__value_.__l.__data_);
  }
  v52.__r_.__value_.__r.__words[0] = (std::string::size_type)v47;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v52);
  v52.__r_.__value_.__r.__words[0] = (std::string::size_type)&v46;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v52);
  if (v54) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v54);
  }
  if (v56) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v56);
  }
}

void sub_20F48D454(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,void *a44,uint64_t a45,int a46,__int16 a47,char a48,char a49)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v51 - 121) < 0) {
    operator delete(*(void **)(v51 - 144));
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  if (a49 < 0) {
    operator delete(a44);
  }
  if (a42 < 0) {
    operator delete(a37);
  }
  if (a36 < 0)
  {
    operator delete(a31);
    if ((v50 & 1) == 0)
    {
LABEL_16:
      std::string::size_type v53 = *(std::__shared_weak_count **)(v51 - 104);
      if (v53) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v53);
      }
      uint64_t v54 = *(std::__shared_weak_count **)(v51 - 88);
      if (v54) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v54);
      }
      _Unwind_Resume(a1);
    }
  }
  else if (!v50)
  {
    goto LABEL_16;
  }
  __cxa_free_exception(v49);
  goto LABEL_16;
}

void MIL::Transform::ProgramTransformer::ExtractSubProgram(uint64_t **a1, void *a2, unsigned __int8 *a3)
{
}

void MIL::Transform::ProgramTransformer::ProgramTransformerImpl::ExtractSubProgram(uint64_t *a1, void *a2, unsigned __int8 *a3)
{
  MIL::Builder::ProgramBuilder::GetFunction(a1[4], a3, &v63);
  long long v6 = v63;
  int v7 = (unsigned __int8 *)MIL::Builder::FunctionBuilder::SelectedSpecialization(v63);
  MIL::Builder::FunctionBuilder::GetBlock((uint64_t)v6, v7, &v61);
  if (!a2[2])
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "opIndices cannot be empty.");
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  uint64_t v9 = a2 + 1;
  uint64_t v8 = (void *)a2[1];
  if (v8)
  {
    do
    {
      uint64_t v10 = v8;
      uint64_t v8 = (void *)v8[1];
    }
    while (v8);
  }
  else
  {
    std::string::size_type v11 = a2 + 1;
    do
    {
      uint64_t v10 = (void *)v11[2];
      BOOL v12 = *v10 == (void)v11;
      std::string::size_type v11 = v10;
    }
    while (v12);
  }
  unint64_t v13 = v10[4];
  if (v13 >= MIL::Builder::BlockBuilder::GetNumOperations((MIL::Builder::BlockBuilder *)v61))
  {
    char v39 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    long long v40 = (void *)*v9;
    if (*v9)
    {
      do
      {
        std::string v41 = v40;
        long long v40 = (void *)v40[1];
      }
      while (v40);
    }
    else
    {
      do
      {
        std::string v41 = (void *)v9[2];
        BOOL v12 = *v41 == (void)v9;
        uint64_t v9 = v41;
      }
      while (v12);
    }
    std::to_string(&v57, v41[4]);
    std::string::size_type v42 = std::string::insert(&v57, 0, "Attempted to extract upto opIdx ");
    long long v43 = *(_OWORD *)&v42->__r_.__value_.__l.__data_;
    v58.__r_.__value_.__r.__words[2] = v42->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v58.__r_.__value_.__l.__data_ = v43;
    v42->__r_.__value_.__l.__size_ = 0;
    v42->__r_.__value_.__r.__words[2] = 0;
    v42->__r_.__value_.__r.__words[0] = 0;
    long long v44 = std::string::append(&v58, " , but block contains only a total of ");
    long long v45 = *(_OWORD *)&v44->__r_.__value_.__l.__data_;
    v59.__r_.__value_.__r.__words[2] = v44->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v59.__r_.__value_.__l.__data_ = v45;
    v44->__r_.__value_.__l.__size_ = 0;
    v44->__r_.__value_.__r.__words[2] = 0;
    v44->__r_.__value_.__r.__words[0] = 0;
    unint64_t NumOperations = MIL::Builder::BlockBuilder::GetNumOperations((MIL::Builder::BlockBuilder *)v61);
    std::to_string(&v56, NumOperations);
    if ((v56.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int v47 = &v56;
    }
    else {
      int v47 = (std::string *)v56.__r_.__value_.__r.__words[0];
    }
    if ((v56.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v56.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v56.__r_.__value_.__l.__size_;
    }
    std::string v49 = std::string::append(&v59, (const std::string::value_type *)v47, size);
    long long v50 = *(_OWORD *)&v49->__r_.__value_.__l.__data_;
    v60.__r_.__value_.__r.__words[2] = v49->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v60.__r_.__value_.__l.__data_ = v50;
    v49->__r_.__value_.__l.__size_ = 0;
    v49->__r_.__value_.__r.__words[2] = 0;
    v49->__r_.__value_.__r.__words[0] = 0;
    uint64_t v51 = std::string::append(&v60, " operations.");
    long long v52 = *(_OWORD *)&v51->__r_.__value_.__l.__data_;
    v54.__r_.__value_.__r.__words[2] = v51->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v54.__r_.__value_.__l.__data_ = v52;
    v51->__r_.__value_.__l.__size_ = 0;
    v51->__r_.__value_.__r.__words[2] = 0;
    v51->__r_.__value_.__r.__words[0] = 0;
    std::logic_error::logic_error(v39, &v54);
    v39->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(v39, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  MIL::Transform::ProgramTransformer::ProgramTransformerImpl::GetInputsAndOutputs(a1, a3, a2, (uint64_t)&v54);
  MIL::Builder::FunctionBuilder::ClearInputs(v63);
  std::string::size_type v15 = v54.__r_.__value_.__l.__size_;
  for (uint64_t i = v54.__r_.__value_.__r.__words[0]; i != v15; i += 24)
  {
    uint64_t Type = MIL::Builder::BlockBuilder::GetType((uint64_t)v61, i);
    if (Type)
    {
      uint64_t v17 = v63;
      if (*(char *)(i + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)i, *(void *)(i + 8));
      }
      else
      {
        long long v18 = *(_OWORD *)i;
        __p.__r_.__value_.__r.__words[2] = *(void *)(i + 16);
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v18;
      }
      MIL::Builder::FunctionBuilder::AddInput((uint64_t)v17, (uint64_t)&__p, Type);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
  }
  uint64_t v19 = a2[2];
  memset(&v60, 0, sizeof(v60));
  uint64_t v20 = MIL::Builder::BlockBuilder::GetNumOperations((MIL::Builder::BlockBuilder *)v61);
  std::vector<unsigned long long>::reserve((void **)&v60.__r_.__value_.__l.__data_, v20 - v19);
  for (unint64_t j = 0; j < MIL::Builder::BlockBuilder::GetNumOperations((MIL::Builder::BlockBuilder *)v61); ++j)
  {
    uint64_t v22 = (void *)*v9;
    if (!*v9) {
      goto LABEL_30;
    }
    long long v23 = v9;
    do
    {
      unint64_t v24 = v22[4];
      BOOL v25 = v24 >= j;
      if (v24 >= j) {
        long long v26 = v22;
      }
      else {
        long long v26 = v22 + 1;
      }
      if (v25) {
        long long v23 = v22;
      }
      uint64_t v22 = (void *)*v26;
    }
    while (*v26);
    if (v23 == v9 || j < v23[4])
    {
LABEL_30:
      std::string::size_type v27 = v60.__r_.__value_.__l.__size_;
      if (v60.__r_.__value_.__l.__size_ >= v60.__r_.__value_.__r.__words[2])
      {
        unint64_t v29 = (void *)v60.__r_.__value_.__r.__words[0];
        uint64_t v30 = (uint64_t)(v60.__r_.__value_.__l.__size_ - v60.__r_.__value_.__r.__words[0]) >> 3;
        unint64_t v31 = v30 + 1;
        if ((unint64_t)(v30 + 1) >> 61) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        int64_t v32 = v60.__r_.__value_.__r.__words[2] - v60.__r_.__value_.__r.__words[0];
        if ((uint64_t)(v60.__r_.__value_.__r.__words[2] - v60.__r_.__value_.__r.__words[0]) >> 2 > v31) {
          unint64_t v31 = v32 >> 2;
        }
        if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v33 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v33 = v31;
        }
        if (v33)
        {
          uint64_t v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v60.__r_.__value_.__r.__words[2], v33);
          std::string::size_type v27 = v60.__r_.__value_.__l.__size_;
          unint64_t v29 = (void *)v60.__r_.__value_.__r.__words[0];
        }
        else
        {
          uint64_t v34 = 0;
        }
        unint64_t v35 = (unint64_t *)&v34[8 * v30];
        *unint64_t v35 = j;
        std::string::size_type v28 = (std::string::size_type)(v35 + 1);
        while ((void *)v27 != v29)
        {
          unint64_t v36 = *(void *)(v27 - 8);
          v27 -= 8;
          *--unint64_t v35 = v36;
        }
        v60.__r_.__value_.__r.__words[0] = (std::string::size_type)v35;
        v60.__r_.__value_.__l.__size_ = v28;
        v60.__r_.__value_.__r.__words[2] = (std::string::size_type)&v34[8 * v33];
        if (v29) {
          operator delete(v29);
        }
      }
      else
      {
        *(void *)v60.__r_.__value_.__l.__size_ = j;
        std::string::size_type v28 = v27 + 8;
      }
      v60.__r_.__value_.__l.__size_ = v28;
    }
  }
  if (v60.__r_.__value_.__l.__size_ == v60.__r_.__value_.__r.__words[0]) {
    uint64_t v37 = 0;
  }
  else {
    uint64_t v37 = (void *)v60.__r_.__value_.__r.__words[0];
  }
  MIL::Builder::BlockBuilder::RemoveOperations((uint64_t)v61, v37, (uint64_t)(v60.__r_.__value_.__l.__size_ - v60.__r_.__value_.__r.__words[0]) >> 3, 1);
  MIL::Builder::BlockBuilder::UpdateOutputNames((uint64_t)v61, v55);
  MIL::Builder::BlockBuilder::UpdateStateDependencyMap(v61);
  if (v60.__r_.__value_.__r.__words[0])
  {
    v60.__r_.__value_.__l.__size_ = v60.__r_.__value_.__r.__words[0];
    operator delete(v60.__r_.__value_.__l.__data_);
  }
  v60.__r_.__value_.__r.__words[0] = (std::string::size_type)v55;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v60);
  v60.__r_.__value_.__r.__words[0] = (std::string::size_type)&v54;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v60);
  if (v62) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v62);
  }
  if (v64) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v64);
  }
}

void sub_20F48DAE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,void *a44,uint64_t a45,int a46,__int16 a47,char a48,char a49)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v51 - 105) < 0) {
    operator delete(*(void **)(v51 - 128));
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  if (a49 < 0) {
    operator delete(a44);
  }
  if (a42 < 0) {
    operator delete(a37);
  }
  if (a36 < 0)
  {
    operator delete(a31);
    if ((v50 & 1) == 0)
    {
LABEL_16:
      std::string::size_type v53 = *(std::__shared_weak_count **)(v51 - 88);
      if (v53) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v53);
      }
      std::string v54 = *(std::__shared_weak_count **)(v51 - 72);
      if (v54) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v54);
      }
      _Unwind_Resume(a1);
    }
  }
  else if (!v50)
  {
    goto LABEL_16;
  }
  __cxa_free_exception(v49);
  goto LABEL_16;
}

uint64_t MIL::Transform::ProgramTransformer::FoldConstantNodes(MIL::Transform::ProgramTransformer *this)
{
  uint64_t v1 = *(void *)this;
  long long v2 = *(MIL::Builder::ProgramBuilder **)(*(void *)this + 32);
  uint64_t v4 = v1;
  return MIL::Transform::ProgramTransformer::ProgramTransformerImpl::ForEachBlock<MIL::Transform::ProgramTransformer::ProgramTransformerImpl::FoldConstantNodes(void)::{lambda(std::shared_ptr<MIL::Builder::BlockBuilder> const&)#1}>(v2, &v4);
}

void MIL::Transform::ProgramTransformer::GetProgram(MIL::Transform::ProgramTransformer *this)
{
}

void sub_20F48DD78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((v17 & 1) == 0)
    {
LABEL_6:
      std::pair<std::unique_ptr<MIL::IRProgram>,MIL::ValidationResult>::~pair(&a16);
      _Unwind_Resume(a1);
    }
  }
  else if (!v17)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v16);
  goto LABEL_6;
}

uint64_t *std::pair<std::unique_ptr<MIL::IRProgram>,MIL::ValidationResult>::~pair(uint64_t *a1)
{
  MIL::ValidationResult::~ValidationResult((MIL::ValidationResult *)(a1 + 1));
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void MIL::Transform::ProgramTransformer::GetProgramWithoutValidation(MIL::Transform::ProgramTransformer *this)
{
}

uint64_t MIL::Transform::ProgramTransformer::GetProgramBuilder@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(*(void *)this + 40);
  *a2 = *(void *)(*(void *)this + 32);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return this;
}

void **std::vector<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>>::reserve(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (void **)(a1 + 2);
  if (a2 > (v4 - *a1) >> 5)
  {
    if (a2 >> 59) {
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v5 = a1[1] - *a1;
    v7[4] = result;
    v7[0] = std::__allocate_at_least[abi:ne180100]<std::allocator<std::function<void ()(MIL::Transform::ProgramTransformer &)>>>((uint64_t)result, a2);
    v7[1] = (char *)v7[0] + v5;
    void v7[2] = (char *)v7[0] + v5;
    v7[3] = (char *)v7[0] + 32 * v6;
    std::vector<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>>::__swap_out_circular_buffer(a1, v7);
    return std::__split_buffer<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>>::~__split_buffer(v7);
  }
  return result;
}

void sub_20F48DEC8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>>,std::reverse_iterator<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>*>,std::reverse_iterator<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>*>,std::reverse_iterator<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>>,std::reverse_iterator<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>*>,std::reverse_iterator<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>*>,std::reverse_iterator<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v14 = a6;
  *((void *)&v14 + 1) = a7;
  long long v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    uint64_t v9 = a6;
  }
  else
  {
    do
    {
      uint64_t v8 = *(void *)(a3 - 32);
      a3 -= 32;
      *(void *)(v7 - 32) = v8;
      *(void *)(v7 - 24) = 0;
      *(void *)(v7 - 16) = 0;
      *(void *)(v7 - 8) = 0;
      *(_OWORD *)(v7 - 24) = *(_OWORD *)(a3 + 8);
      *(void *)(v7 - 8) = *(void *)(a3 + 24);
      *(void *)(a3 + 8) = 0;
      *(void *)(a3 + 16) = 0;
      *(void *)(a3 + 24) = 0;
      uint64_t v7 = *((void *)&v14 + 1) - 32;
      *((void *)&v14 + 1) -= 32;
    }
    while (a3 != a5);
    uint64_t v9 = v14;
  }
  char v12 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>>,std::reverse_iterator<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>>,std::reverse_iterator<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>>,std::reverse_iterator<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>>,std::reverse_iterator<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    uint64_t v3 = (void **)(v1 + 8);
    std::vector<MIL::Transform::ArgumentDescription>::__destroy_vector::operator()[abi:ne180100](&v3);
    v1 += 32;
  }
}

void **std::__split_buffer<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void std::__split_buffer<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>>::clear[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 32;
    uint64_t v4 = (void **)(i - 24);
    std::vector<MIL::Transform::ArgumentDescription>::__destroy_vector::operator()[abi:ne180100](&v4);
  }
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<MIL::Transform::ArgumentDescription>,MIL::Transform::ArgumentDescription const*,MIL::Transform::ArgumentDescription const*,MIL::Transform::ArgumentDescription*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      MIL::Transform::ArgumentDescription::ArgumentDescription((MIL::Transform::ArgumentDescription *)(a4 + v7), (const MIL::Transform::ArgumentDescription *)(a2 + v7));
      v7 += 32;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_20F48E170(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 32;
    do
    {
      MIL::Transform::ArgumentDescription::~ArgumentDescription((MIL::Transform::ArgumentDescription *)(v4 + v2));
      v2 -= 32;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<std::pair<char const*,std::vector<MIL::Transform::ArgumentDescription>>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v6 = v4 - 32;
        uint64_t v7 = (void **)(v4 - 24);
        std::vector<MIL::Transform::ArgumentDescription>::__destroy_vector::operator()[abi:ne180100](&v7);
        uint64_t v4 = v6;
      }
      while (v6 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void **std::vector<std::shared_ptr<MIL::IRArgument>>::reserve(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (void **)(a1 + 2);
  if (a2 > (v4 - *a1) >> 4)
  {
    if (a2 >> 60) {
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v5 = a1[1] - *a1;
    v7[4] = result;
    v7[0] = std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<MIL::IRBlock>>>((uint64_t)result, a2);
    v7[1] = (char *)v7[0] + v5;
    void v7[2] = (char *)v7[0] + v5;
    v7[3] = (char *)v7[0] + 16 * v6;
    std::vector<std::shared_ptr<MIL::IRArgument>>::__swap_out_circular_buffer(a1, v7);
    return std::__split_buffer<std::shared_ptr<MIL::IRBlock>>::~__split_buffer(v7);
  }
  return result;
}

void sub_20F48E290(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::shared_ptr<MIL::IRBlock>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void MIL::Transform::MatchContext::MatchContextImpl::GetTypedArgument(MIL::IRArgument *a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  (*(void (**)(uint64_t *__return_ptr))(*(void *)a1 + 48))(&v17);
  if (v17)
  {
    uint64_t v15 = v17;
    std::string::size_type v16 = v18;
    if (v18) {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    MIL::IRTypedArgument::Make();
  }
  if (!*a2)
  {
    uint64_t Name = (long long *)MIL::IRArgument::GetName(a1);
    MIL::Builder::BlockBuilder::GetValue(a3, Name, &v13);
    if (v13)
    {
      if (v14) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
      }
      MIL::IRTypedArgument::Make();
    }
    uint64_t v10 = MIL::IRArgument::GetName(a1);
    uint64_t Type = (MIL::IRTypedArgument *)MIL::Builder::BlockBuilder::GetType(a3, v10);
    MIL::IRTypedArgument::Make(Type, v12);
  }
  uint64_t v8 = a2[1];
  *a4 = *a2;
  a4[1] = v8;
  *a2 = 0;
  a2[1] = 0;
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v18);
  }
}

void sub_20F48E4E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16)
{
  if (a12) {
    MIL::Passes::PropagateValueTypes();
  }
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  long long v18 = *(std::__shared_weak_count **)(v16 - 40);
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v18);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::NewOperationDependencyMap::AddDependency(_anonymous_namespace_::NewOperationDependencyMap *this, uint64_t a2)
{
  uint64_t v4 = (char *)this + 16;
  unint64_t v5 = *((void *)this + 2);
  uint64_t v6 = (void *)*((void *)this + 1);
  if ((unint64_t)v6 >= v5)
  {
    uint64_t v8 = *(void **)this;
    uint64_t v9 = ((uint64_t)v6 - *(void *)this) >> 3;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = v5 - (void)v8;
    if (v11 >> 2 > v10) {
      unint64_t v10 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)v4, v12);
      uint64_t v8 = *(void **)this;
      uint64_t v6 = (void *)*((void *)this + 1);
    }
    else
    {
      uint64_t v13 = 0;
    }
    uint64_t v14 = &v13[8 * v9];
    uint64_t v15 = &v13[8 * v12];
    *(void *)uint64_t v14 = a2;
    uint64_t v7 = v14 + 8;
    while (v6 != v8)
    {
      uint64_t v16 = *--v6;
      *((void *)v14 - 1) = v16;
      v14 -= 8;
    }
    *(void *)this = v14;
    *((void *)this + 1) = v7;
    *((void *)this + 2) = v15;
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    *uint64_t v6 = a2;
    uint64_t v7 = v6 + 1;
  }
  *((void *)this + 1) = v7;
}

void anonymous namespace'::NewOperationDependencyMap::NextOperation(_anonymous_namespace_::NewOperationDependencyMap *this)
{
  uint64_t v2 = (uint64_t)(*((void *)this + 1) - *(void *)this) >> 3;
  uint64_t v3 = (uint64_t *)*((void *)this + 4);
  uint64_t v4 = (char *)this + 40;
  unint64_t v5 = *((void *)this + 5);
  if ((unint64_t)v3 >= v5)
  {
    uint64_t v7 = (uint64_t *)*((void *)this + 3);
    uint64_t v8 = v3 - v7;
    if ((unint64_t)(v8 + 1) >> 61) {
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v9 = v5 - (void)v7;
    unint64_t v10 = (uint64_t)(v5 - (void)v7) >> 2;
    if (v10 <= v8 + 1) {
      unint64_t v10 = v8 + 1;
    }
    if (v9 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    if (v11)
    {
      unint64_t v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)v4, v11);
      uint64_t v7 = (uint64_t *)*((void *)this + 3);
      uint64_t v3 = (uint64_t *)*((void *)this + 4);
    }
    else
    {
      unint64_t v12 = 0;
    }
    uint64_t v13 = (uint64_t *)&v12[8 * v8];
    uint64_t v14 = &v12[8 * v11];
    *uint64_t v13 = v2;
    uint64_t v6 = v13 + 1;
    while (v3 != v7)
    {
      uint64_t v15 = *--v3;
      *--uint64_t v13 = v15;
    }
    *((void *)this + 3) = v13;
    *((void *)this + 4) = v6;
    *((void *)this + 5) = v14;
    if (v7) {
      operator delete(v7);
    }
  }
  else
  {
    uint64_t *v3 = v2;
    uint64_t v6 = v3 + 1;
  }
  *((void *)this + 4) = v6;
}

void MIL::Transform::MatchContext::MatchContextImpl::InferOutputTypesAndAddOperation(uint64_t a1, uint64_t a2, uint64_t a3, MIL::Builder::OperationBuilder **a4)
{
  memset(v27, 0, 24);
  uint64_t BlocksRef = MIL::Builder::OperationBuilder::GetBlocksRef(*a4);
  unint64_t v5 = *(MIL::Builder::BlockBuilder::BlockBuilderImpl ****)BlocksRef;
  uint64_t v6 = *(MIL::Builder::BlockBuilder::BlockBuilderImpl ****)(BlocksRef + 8);
  if (*(MIL::Builder::BlockBuilder::BlockBuilderImpl ****)BlocksRef != v6)
  {
    do
    {
      __p[0] = 0;
      __p[1] = 0;
      unint64_t v24 = 0;
      MIL::Builder::BlockBuilder::GetOutputs(*v5, (void **)&v25);
      uint64_t v8 = v25;
      uint64_t v7 = v26;
      if (v25 != v26)
      {
        do
        {
          uint64_t Type = MIL::Builder::Variable::TryGetType(*v8);
          uint64_t v10 = Type;
          unint64_t v11 = (char *)__p[1];
          if (__p[1] >= v24)
          {
            int64_t v13 = ((char *)__p[1] - (char *)__p[0]) >> 3;
            if ((unint64_t)(v13 + 1) >> 61) {
              std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v14 = (v24 - (char *)__p[0]) >> 2;
            if (v14 <= v13 + 1) {
              unint64_t v14 = v13 + 1;
            }
            if ((unint64_t)(v24 - (char *)__p[0]) >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v15 = v14;
            }
            if (v15) {
              uint64_t v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v24, v15);
            }
            else {
              uint64_t v16 = 0;
            }
            uint64_t v17 = (uint64_t *)&v16[8 * v13];
            uint64_t *v17 = v10;
            unint64_t v12 = v17 + 1;
            uint64_t v19 = (char *)__p[0];
            long long v18 = (char *)__p[1];
            if (__p[1] != __p[0])
            {
              do
              {
                uint64_t v20 = *((void *)v18 - 1);
                v18 -= 8;
                *--uint64_t v17 = v20;
              }
              while (v18 != v19);
              long long v18 = (char *)__p[0];
            }
            __p[0] = v17;
            __p[1] = v12;
            unint64_t v24 = &v16[8 * v15];
            if (v18) {
              operator delete(v18);
            }
          }
          else
          {
            *(void *)__p[1] = Type;
            unint64_t v12 = v11 + 8;
          }
          __p[1] = v12;
          ++v8;
        }
        while (v8 != v7);
        uint64_t v8 = v25;
      }
      if (v8)
      {
        long long v26 = v8;
        operator delete(v8);
      }
      std::vector<std::vector<MIL::IRValueType const*>>::push_back[abi:ne180100](v27, (uint64_t)__p);
      if (__p[0])
      {
        __p[1] = __p[0];
        operator delete(__p[0]);
      }
      v5 += 2;
    }
    while (v5 != v6);
  }
  uint64_t Operator = (MIL::UnknownLocation *)MIL::Builder::OperationBuilder::GetOperator(*a4);
  MIL::UnknownLocation::Make(Operator);
}

void sub_20F48EC34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a27 < 0)
  {
    operator delete(__p);
    if ((v34 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a28);
      uint64_t v37 = *(void **)(v35 - 136);
      if (v37)
      {
        *(void *)(v35 - 128) = v37;
        operator delete(v37);
      }
      a28 = (void *)(v35 - 112);
      std::vector<std::vector<unsigned long long>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a28);
      _Unwind_Resume(a1);
    }
  }
  else if (!v34)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v33);
  goto LABEL_6;
}

uint64_t std::unordered_set<MIL::IRValueType const*>::unordered_set(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, *(void *)(a2 + 8));
  for (uint64_t i = *(void **)(a2 + 16); i; uint64_t i = (void *)*i)
    std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::__emplace_unique_key_args<MIL::IRValueType const*,MIL::IRValueType const* const&>(a1, i + 2, i + 2);
  return a1;
}

void sub_20F48EDE4(_Unwind_Exception *a1)
{
  std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(uint64_t a1, unsigned __int8 *a2, uint64_t a3, long long **a4)
{
  uint64_t v8 = (void *)(a1 + 24);
  unint64_t v9 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  unint64_t v10 = v9;
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    unint64_t v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v4 = v9;
      if (v9 >= v11) {
        unint64_t v4 = v9 % v11;
      }
    }
    else
    {
      unint64_t v4 = (v11 - 1) & v9;
    }
    unint64_t v14 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v4);
    if (v14)
    {
      for (uint64_t i = *v14; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v16 = *((void *)i + 1);
        if (v16 == v10)
        {
          if (std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2)) {
            return i;
          }
        }
        else
        {
          if (v13 > 1)
          {
            if (v16 >= v11) {
              v16 %= v11;
            }
          }
          else
          {
            v16 &= v11 - 1;
          }
          if (v16 != v4) {
            break;
          }
        }
      }
    }
  }
  uint64_t v17 = operator new(0x40uLL);
  v29[0] = v17;
  v29[1] = a1 + 16;
  void *v17 = 0;
  v17[1] = v10;
  long long v18 = *a4;
  long long v19 = **a4;
  v17[4] = *((void *)*a4 + 2);
  *((_OWORD *)v17 + 1) = v19;
  *((void *)v18 + 1) = 0;
  *((void *)v18 + 2) = 0;
  *(void *)long long v18 = 0;
  v17[6] = 0;
  v17[7] = 0;
  v17[5] = 0;
  char v30 = 1;
  float v20 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v21 = *(float *)(a1 + 32);
  if (!v11 || (float)(v21 * (float)v11) < v20)
  {
    BOOL v22 = 1;
    if (v11 >= 3) {
      BOOL v22 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v23 = v22 | (2 * v11);
    unint64_t v24 = vcvtps_u32_f32(v20 / v21);
    if (v23 <= v24) {
      size_t v25 = v24;
    }
    else {
      size_t v25 = v23;
    }
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v25);
    unint64_t v11 = *(void *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11) {
        unint64_t v4 = v10 % v11;
      }
      else {
        unint64_t v4 = v10;
      }
    }
    else
    {
      unint64_t v4 = (v11 - 1) & v10;
    }
  }
  long long v26 = *(void **)(*(void *)a1 + 8 * v4);
  if (v26)
  {
    *(void *)v29[0] = *v26;
    void *v26 = v29[0];
  }
  else
  {
    *(void *)v29[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v29[0];
    *(void *)(*(void *)a1 + 8 * v4) = a1 + 16;
    if (*(void *)v29[0])
    {
      unint64_t v27 = *(void *)(*(void *)v29[0] + 8);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v27 >= v11) {
          v27 %= v11;
        }
      }
      else
      {
        v27 &= v11 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v27) = v29[0];
    }
  }
  uint64_t i = (unsigned __int8 *)v29[0];
  v29[0] = 0;
  ++*v8;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,void *>>>>::reset[abi:ne180100]((uint64_t)v29, 0);
  return i;
}

void sub_20F48F08C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::vector<MIL::IRValueType const*>>::push_back[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  uint64_t v7 = *(void **)(result - 8);
  if ((unint64_t)v7 >= v6)
  {
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v7 - *a1) >> 3);
    unint64_t v10 = v9 + 1;
    if (v9 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 3);
    if (2 * v11 > v10) {
      unint64_t v10 = 2 * v11;
    }
    if (v11 >= 0x555555555555555) {
      unint64_t v12 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v12 = v10;
    }
    v16[4] = result;
    unint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(result, v12);
    unint64_t v14 = &v13[24 * v9];
    v16[0] = v13;
    v16[1] = v14;
    v16[3] = &v13[24 * v15];
    *((void *)v14 + 1) = 0;
    *((void *)v14 + 2) = 0;
    *(void *)unint64_t v14 = 0;
    *(_OWORD *)unint64_t v14 = *(_OWORD *)a2;
    *((void *)v14 + 2) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    void v16[2] = v14 + 24;
    std::vector<std::vector<MIL::IRValueType const*>>::__swap_out_circular_buffer(a1, v16);
    uint64_t v8 = (void *)a1[1];
    uint64_t result = std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)v16);
  }
  else
  {
    *uint64_t v7 = 0;
    v7[1] = 0;
    void v7[2] = 0;
    *(_OWORD *)uint64_t v7 = *(_OWORD *)a2;
    void v7[2] = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    uint64_t v8 = v7 + 3;
    a1[1] = (uint64_t)(v7 + 3);
  }
  a1[1] = (uint64_t)v8;
  return result;
}

void sub_20F48F1D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void **std::vector<std::shared_ptr<MIL::Builder::OperationBuilder>>::push_back[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (void **)(a1 + 2);
  unint64_t v5 = v6;
  uint64_t v7 = *(result - 1);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v9 = ((uint64_t)v7 - *a1) >> 4;
    if ((unint64_t)(v9 + 1) >> 60) {
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v5 - *a1;
    uint64_t v11 = v10 >> 3;
    if (v10 >> 3 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v12 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    v16[4] = result;
    unint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<MIL::IRBlock>>>((uint64_t)result, v12);
    unint64_t v14 = &v13[16 * v9];
    v16[0] = v13;
    v16[1] = v14;
    v16[3] = &v13[16 * v15];
    *(_OWORD *)unint64_t v14 = *(_OWORD *)a2;
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    void v16[2] = v14 + 16;
    std::vector<std::shared_ptr<MIL::Builder::OperationBuilder>>::__swap_out_circular_buffer(a1, v16);
    uint64_t v8 = (_OWORD *)a1[1];
    uint64_t result = std::__split_buffer<std::shared_ptr<MIL::IRBlock>>::~__split_buffer(v16);
  }
  else
  {
    *uint64_t v7 = *(_OWORD *)a2;
    uint64_t v8 = v7 + 1;
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    a1[1] = (uint64_t)v8;
  }
  a1[1] = (uint64_t)v8;
  return result;
}

void sub_20F48F2C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::shared_ptr<MIL::IRBlock>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void MIL::Transform::MatchContext::MatchContextImpl::ConvertParamMap(void *a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_DWORD *)(a2 + 32) = 1065353216;
  uint64_t v3 = (unsigned __int8 *)(a1 + 1);
  unint64_t v4 = (unsigned __int8 *)*a1;
  if ((void *)*a1 != a1 + 1)
  {
    do
    {
      uint64_t v18 = 0;
      long long v19 = 0;
      unint64_t v20 = 0;
      std::vector<MIL::TransformPrivate::ArgumentAndType>::reserve(&v18, (uint64_t)(*((void *)v4 + 8) - *((void *)v4 + 7)) >> 4);
      unint64_t v5 = (void ***)*((void *)v4 + 7);
      unint64_t v6 = (void ***)*((void *)v4 + 8);
      while (v5 != v6)
      {
        uint64_t v7 = *v5;
        unint64_t v13 = *v5;
        uint64_t v8 = (std::__shared_weak_count *)v5[1];
        unint64_t v14 = v8;
        if (v8) {
          atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        BYTE8(v17) = 0;
        uint64_t v15 = 0;
        unint64_t v16 = 0;
        LOBYTE(v17) = 0;
        uint64_t v9 = v19;
        if ((unint64_t)v19 >= v20)
        {
          long long v19 = (void *)std::vector<MIL::TransformPrivate::ArgumentAndType>::__push_back_slow_path<MIL::TransformPrivate::ArgumentAndType>(&v18, (uint64_t)&v13);
          if (v16) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v16);
          }
        }
        else
        {
          void *v19 = v7;
          v9[1] = v14;
          v9[2] = 0;
          unint64_t v13 = 0;
          unint64_t v14 = 0;
          v9[3] = 0;
          uint64_t v15 = 0;
          unint64_t v16 = 0;
          *((_OWORD *)v9 + 2) = v17;
          long long v19 = v9 + 6;
        }
        if (v14) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v14);
        }
        v5 += 2;
      }
      std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>>>::__emplace_unique_key_args<std::string,std::string const&,std::vector<MIL::TransformPrivate::ArgumentAndType>>(a2, v4 + 32, (long long *)v4 + 2, (uint64_t)&v18);
      unint64_t v13 = (void **)&v18;
      std::vector<MIL::TransformPrivate::ArgumentAndType>::__destroy_vector::operator()[abi:ne180100](&v13);
      uint64_t v10 = (unsigned __int8 *)*((void *)v4 + 1);
      if (v10)
      {
        do
        {
          uint64_t v11 = v10;
          uint64_t v10 = *(unsigned __int8 **)v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          uint64_t v11 = (unsigned __int8 *)*((void *)v4 + 2);
          BOOL v12 = *(void *)v11 == (void)v4;
          unint64_t v4 = v11;
        }
        while (!v12);
      }
      unint64_t v4 = v11;
    }
    while (v11 != v3);
  }
}

void sub_20F48F464(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
  a10 = (void **)&a16;
  std::vector<MIL::TransformPrivate::ArgumentAndType>::__destroy_vector::operator()[abi:ne180100](&a10);
  std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>>>::~__hash_table(v16);
  _Unwind_Resume(a1);
}

void MIL::Transform::MatchContext::MatchContextImpl::CreateOperationBuilderFromProperties(MIL::Transform::MatchContext::MatchContextImpl *this, const MIL::TransformPrivate::OperationProperties *a2)
{
  uint64_t v2 = *((void *)this + 1);
  v3[0] = *(void *)this;
  v3[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  MIL::Builder::OperationBuilder::Make((uint64_t)v3);
}

void sub_20F48F694(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  unint64_t v31 = *(std::__shared_weak_count **)(v29 - 72);
  if (v31) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v31);
  }
  _Unwind_Resume(exception_object);
}

void MIL::TransformPrivate::OperationProperties::~OperationProperties(MIL::TransformPrivate::OperationProperties *this)
{
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)this + 80);
  uint64_t v3 = (void **)((char *)this + 56);
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100](&v3);
  std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>>>::~__hash_table((uint64_t)this + 16);
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 1);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
}

void **std::vector<MIL::TransformPrivate::ArgumentAndType>::reserve(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (void **)(a1 + 2);
  if (0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 4) < a2)
  {
    if (a2 >= 0x555555555555556) {
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v5 = a1[1] - *a1;
    v7[4] = result;
    v7[0] = std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<std::string,std::string>>>((uint64_t)result, a2);
    v7[1] = (char *)v7[0] + v5;
    void v7[2] = (char *)v7[0] + v5;
    v7[3] = (char *)v7[0] + 48 * v6;
    std::vector<MIL::TransformPrivate::ArgumentAndType>::__swap_out_circular_buffer(a1, v7);
    return std::__split_buffer<MIL::TransformPrivate::ArgumentAndType>::~__split_buffer(v7);
  }
  return result;
}

void sub_20F48F810(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<MIL::TransformPrivate::ArgumentAndType>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>>>::__emplace_unique_key_args<std::string,std::string const&,std::vector<MIL::TransformPrivate::ArgumentAndType>>(uint64_t a1, unsigned __int8 *a2, long long *a3, uint64_t a4)
{
  uint64_t v9 = (void *)(a1 + 24);
  unint64_t v10 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  unint64_t v11 = v10;
  unint64_t v12 = *(void *)(a1 + 8);
  if (v12)
  {
    uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    unint64_t v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v4 = v10;
      if (v10 >= v12) {
        unint64_t v4 = v10 % v12;
      }
    }
    else
    {
      unint64_t v4 = (v12 - 1) & v10;
    }
    uint64_t v15 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v4);
    if (v15)
    {
      for (uint64_t i = *v15; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v17 = *((void *)i + 1);
        if (v17 == v11)
        {
          if (std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2)) {
            return i;
          }
        }
        else
        {
          if (v14 > 1)
          {
            if (v17 >= v12) {
              v17 %= v12;
            }
          }
          else
          {
            v17 &= v12 - 1;
          }
          if (v17 != v4) {
            break;
          }
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>>>::__construct_node_hash<std::string const&,std::vector<MIL::TransformPrivate::ArgumentAndType>>(a1, v11, a3, a4, (uint64_t)v27);
  float v18 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v19 = *(float *)(a1 + 32);
  if (!v12 || (float)(v19 * (float)v12) < v18)
  {
    BOOL v20 = 1;
    if (v12 >= 3) {
      BOOL v20 = (v12 & (v12 - 1)) != 0;
    }
    unint64_t v21 = v20 | (2 * v12);
    unint64_t v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22) {
      size_t v23 = v22;
    }
    else {
      size_t v23 = v21;
    }
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v23);
    unint64_t v12 = *(void *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12) {
        unint64_t v4 = v11 % v12;
      }
      else {
        unint64_t v4 = v11;
      }
    }
    else
    {
      unint64_t v4 = (v12 - 1) & v11;
    }
  }
  unint64_t v24 = *(void **)(*(void *)a1 + 8 * v4);
  if (v24)
  {
    *(void *)v27[0] = *v24;
    void *v24 = v27[0];
  }
  else
  {
    *(void *)v27[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v27[0];
    *(void *)(*(void *)a1 + 8 * v4) = a1 + 16;
    if (*(void *)v27[0])
    {
      unint64_t v25 = *(void *)(*(void *)v27[0] + 8);
      if ((v12 & (v12 - 1)) != 0)
      {
        if (v25 >= v12) {
          v25 %= v12;
        }
      }
      else
      {
        v25 &= v12 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v25) = v27[0];
    }
  }
  uint64_t i = (unsigned __int8 *)v27[0];
  v27[0] = 0;
  ++*v9;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,void *>>>>::reset[abi:ne180100]((uint64_t)v27, 0);
  return i;
}

void sub_20F48FA98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

std::string *std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>>>::__construct_node_hash<std::string const&,std::vector<MIL::TransformPrivate::ArgumentAndType>>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, long long *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v9 = a1 + 16;
  unint64_t v10 = (char *)operator new(0x40uLL);
  *(void *)a5 = v10;
  *(void *)(a5 + 8) = v9;
  *(unsigned char *)(a5 + 16) = 0;
  *(void *)unint64_t v10 = 0;
  *((void *)v10 + 1) = a2;
  uint64_t result = std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>>::pair[abi:ne180100]<std::string const&,std::vector<std::shared_ptr<MIL::IRArgument>>,0>((std::string *)(v10 + 16), a3, a4);
  *(unsigned char *)(a5 + 16) = 1;
  return result;
}

void sub_20F48FB20(_Unwind_Exception *a1)
{
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>>>::__deallocate_node(a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::TransformPrivate::ArgumentAndType>>>>::__deallocate_node(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    do
    {
      uint64_t v3 = (void *)*v2;
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::vector<MIL::TransformPrivate::ArgumentAndType>>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

uint64_t MIL::Transform::ProgramTransformer::ProgramTransformerImpl::DoMatchAndReplace(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  do
  {
    char v11 = 0;
    uint64_t v8 = *(MIL::Builder::ProgramBuilder **)(a1 + 32);
    v10[0] = a1;
    v10[1] = a2;
    void v10[2] = a3;
    v10[3] = a4;
    v10[4] = &v11;
    uint64_t result = MIL::Transform::ProgramTransformer::ProgramTransformerImpl::ForEachBlock<MIL::Transform::ProgramTransformer::ProgramTransformerImpl::DoMatchAndReplace(MIL::Transform::ProgramTransformer::ProgramTransformerImpl::MatchAndReplaceHelper &,MIL::Matching::CompiledPattern const&,std::function<void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)> const&)::{lambda(std::shared_ptr<MIL::Builder::BlockBuilder> const&)#1}>(v8, (uint64_t)v10);
  }
  while (v11);
  return result;
}

uint64_t MIL::Transform::ProgramTransformer::ProgramTransformerImpl::MatchAndReplaceHelper::MatchAndReplaceHelper(uint64_t a1, void *a2, uint64_t *a3)
{
  uint64_t matched = MIL::Transform::MatchContext::MatchContextImpl::MatchContextImpl(a1, a2, a3);
  *(void *)(matched + 152) = matched;
  MIL::Matching::Match::Match((MIL::Matching::Match *)(matched + 160));
  *(_OWORD *)(a1 + 544) = 0u;
  *(_OWORD *)(a1 + 560) = 0u;
  *(_OWORD *)(a1 + 528) = 0u;
  *(_OWORD *)(a1 + 600) = 0u;
  *(_OWORD *)(a1 + 616) = 0u;
  *(_OWORD *)(a1 + 632) = 0u;
  *(_OWORD *)(a1 + 656) = 0u;
  *(_OWORD *)(a1 + 672) = 0u;
  *(_OWORD *)(a1 + 688) = 0u;
  *(_OWORD *)(a1 + 704) = 0u;
  *(_OWORD *)(a1 + 720) = 0u;
  *(_OWORD *)(a1 + 736) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(void *)(a1 + 280) = 0;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(void *)(a1 + 360) = 0;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 504) = 0u;
  *(_OWORD *)(a1 + 488) = 0u;
  *(_OWORD *)(a1 + 472) = 0u;
  *(_OWORD *)(a1 + 456) = 0u;
  *(_OWORD *)(a1 + 440) = 0u;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 376) = 0u;
  return a1;
}

void sub_20F48FCE4(_Unwind_Exception *a1)
{
  MIL::Transform::MatchContext::MatchContextImpl::~MatchContextImpl(v1);
  _Unwind_Resume(a1);
}

uint64_t MIL::Transform::MatchContext::MatchContextImpl::MatchContextImpl(uint64_t a1, void *a2, uint64_t *a3)
{
  uint64_t v4 = a2[1];
  *(void *)a1 = *a2;
  *(void *)(a1 + 8) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = *a3;
  uint64_t v5 = a3[1];
  *(void *)(a1 + 24) = v5;
  *(void *)(a1 + 16) = v6;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(unsigned char *)(a1 + 48) = 0;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  uint64_t v7 = operator new(8uLL);
  *uint64_t v7 = 0;
  *(void *)(a1 + 136) = v7 + 1;
  *(void *)(a1 + 144) = v7 + 1;
  *(void *)(a1 + 128) = v7;
  return a1;
}

void sub_20F48FDA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  unint64_t v14 = v13;
  a10 = v14;
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100](&a10);
  uint64_t v16 = *(std::__shared_weak_count **)(v10 + 40);
  if (v16) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v16);
  }
  std::make_unique[abi:ne180100]<MIL::IRTensorBufferValueTypeImpl,MIL::IRDataType &,std::shared_ptr<std::vector<MIL::IRDimension const*>> &,std::shared_ptr<std::vector<MIL::IRProperty const*>> &,decltype(nullptr),std::shared_ptr<std::vector<MIL::IRProperty const*>> &,std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>>>(v12, v11);
  _Unwind_Resume(a1);
}

void MIL::Transform::MatchContext::MatchContextImpl::~MatchContextImpl(MIL::Transform::MatchContext::MatchContextImpl *this)
{
  uint64_t v2 = (void *)*((void *)this + 16);
  if (v2)
  {
    *((void *)this + 17) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 13);
  if (v3)
  {
    *((void *)this + 14) = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)*((void *)this + 10);
  if (v4)
  {
    *((void *)this + 11) = v4;
    operator delete(v4);
  }
  uint64_t v8 = (void **)((char *)this + 56);
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100](&v8);
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
  uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 1);
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
}

uint64_t MIL::Transform::ProgramTransformer::ProgramTransformerImpl::ForEachBlock<MIL::Transform::ProgramTransformer::ProgramTransformerImpl::DoMatchAndReplace(MIL::Transform::ProgramTransformer::ProgramTransformerImpl::MatchAndReplaceHelper &,MIL::Matching::CompiledPattern const&,std::function<void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)> const&)::{lambda(std::shared_ptr<MIL::Builder::BlockBuilder> const&)#1}>(MIL::Builder::ProgramBuilder *a1, uint64_t a2)
{
  uint64_t result = MIL::Builder::ProgramBuilder::GetFunctions(a1);
  for (uint64_t i = *(uint64_t ***)(result + 16); i; uint64_t i = (uint64_t **)*i)
  {
    uint64_t result = MIL::Builder::FunctionBuilder::GetSpecializations((MIL::Builder::FunctionBuilder *)i[5]);
    for (unint64_t j = *(MIL::Builder::BlockBuilder::BlockBuilderImpl ****)(result + 16);
          j;
          unint64_t j = (MIL::Builder::BlockBuilder::BlockBuilderImpl ***)*j)
    {
      uint64_t result = MIL::Transform::ProgramTransformer::ProgramTransformerImpl::ForEachBlock<MIL::Transform::ProgramTransformer::ProgramTransformerImpl::DoMatchAndReplace(MIL::Transform::ProgramTransformer::ProgramTransformerImpl::MatchAndReplaceHelper &,MIL::Matching::CompiledPattern const&,std::function<void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)> const&)::{lambda(std::shared_ptr<MIL::Builder::BlockBuilder> const&)#1}>(j + 5, a2);
    }
  }
  return result;
}

uint64_t MIL::Transform::ProgramTransformer::ProgramTransformerImpl::ForEachBlock<MIL::Transform::ProgramTransformer::ProgramTransformerImpl::DoMatchAndReplace(MIL::Transform::ProgramTransformer::ProgramTransformerImpl::MatchAndReplaceHelper &,MIL::Matching::CompiledPattern const&,std::function<void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)> const&)::{lambda(std::shared_ptr<MIL::Builder::BlockBuilder> const&)#1}>(MIL::Builder::BlockBuilder::BlockBuilderImpl ***a1, uint64_t a2)
{
  if (MIL::Builder::BlockBuilder::GetNumOperations((MIL::Builder::BlockBuilder *)*a1))
  {
    unint64_t v4 = 0;
    do
    {
      MIL::Builder::BlockBuilder::GetOperation(*a1, v4, &v11);
      MIL::Builder::OperationBuilder::GetBlocks((MIL::Builder::OperationBuilder *)v11, v10);
      uint64_t v5 = v10[0];
      uint64_t v6 = v10[1];
      while (v5 != v6)
      {
        MIL::Transform::ProgramTransformer::ProgramTransformerImpl::ForEachBlock<MIL::Transform::ProgramTransformer::ProgramTransformerImpl::DoMatchAndReplace(MIL::Transform::ProgramTransformer::ProgramTransformerImpl::MatchAndReplaceHelper &,MIL::Matching::CompiledPattern const&,std::function<void ()(MIL::Transform::MatchContext &,MIL::Matching::MatchView)> const&)::{lambda(std::shared_ptr<MIL::Builder::BlockBuilder> const&)#1}>(v5, a2);
        v5 += 16;
      }
      unint64_t v12 = (void **)v10;
      std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100](&v12);
      if (*((void *)&v11 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v11 + 1));
      }
      ++v4;
    }
    while (v4 < MIL::Builder::BlockBuilder::GetNumOperations((MIL::Builder::BlockBuilder *)*a1));
  }
  uint64_t result = MIL::Transform::ProgramTransformer::ProgramTransformerImpl::MatchAndReplaceWithinBlock(*(MIL::Transform::ProgramTransformer::ProgramTransformerImpl **)a2, *(void *)(a2 + 8), *(const MIL::Matching::CompiledPattern **)(a2 + 16), *(void *)(a2 + 24), (uint64_t)a1);
  uint64_t v8 = *(char **)(a2 + 32);
  if (*v8) {
    char v9 = 1;
  }
  else {
    char v9 = result;
  }
  *uint64_t v8 = v9;
  return result;
}

void sub_20F48FFA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, uint64_t a14)
{
  if (a13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a13);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::Transform::ProgramTransformer::ProgramTransformerImpl::MatchAndReplaceWithinBlock(MIL::Transform::ProgramTransformer::ProgramTransformerImpl *a1, uint64_t a2, const MIL::Matching::CompiledPattern *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = *(void *)(a2 + 152);
  unint64_t v12 = *(MIL::Builder::BlockBuilder::BlockBuilderImpl ***)a5;
  uint64_t v11 = *(void *)(a5 + 8);
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  uint8x8_t v13 = *(std::__shared_weak_count **)(v10 + 40);
  *(void *)(v10 + 32) = v12;
  *(void *)(v10 + 40) = v11;
  if (v13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v13);
  }
  char v14 = 0;
  if (MIL::Builder::BlockBuilder::GetNumOperations(*(MIL::Builder::BlockBuilder **)a5))
  {
    unint64_t v15 = 0;
    do
    {
      MIL::Builder::BlockBuilder::GetOperation(*(MIL::Builder::BlockBuilder::BlockBuilderImpl ***)a5, v15, &v18);
      uint64_t v16 = MIL::Transform::ProgramTransformer::ProgramTransformerImpl::PrepareMatcher(a1, *(MIL::Builder::BlockBuilder **)a5, (MIL::Builder::OperationBuilder *)v18, a3);
      while (!MIL::Matching::Matcher::FindNextMatch((uint64_t)v16, (uint64_t *)(a2 + 160), 0x7FFFFFFFFFFFFFFFLL))
      {
        if (MIL::Transform::ProgramTransformer::ProgramTransformerImpl::ProcessMatch((uint64_t)a1, a2, a4, *(MIL::Builder::BlockBuilder **)a5))
        {
          char v14 = 1;
          break;
        }
      }
      if (*((void *)&v18 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v18 + 1));
      }
      ++v15;
    }
    while (v15 < MIL::Builder::BlockBuilder::GetNumOperations(*(MIL::Builder::BlockBuilder **)a5));
  }
  return v14 & 1;
}

void sub_20F4900E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

char *MIL::Transform::ProgramTransformer::ProgramTransformerImpl::PrepareMatcher(MIL::Transform::ProgramTransformer::ProgramTransformerImpl *this, MIL::Builder::BlockBuilder *a2, MIL::Builder::OperationBuilder *a3, const MIL::Matching::CompiledPattern *a4)
{
  uint64_t v6 = a3;
  uint64_t v7 = a2;
  unint64_t v4 = (char *)this + 48;
  if (*((unsigned char *)this + 56)) {
    MIL::Matching::Matcher::Reset((MIL::Transform::ProgramTransformer::ProgramTransformerImpl *)((char *)this + 48), a2, a3, a4);
  }
  else {
    std::optional<MIL::Matching::Matcher>::emplace[abi:ne180100]<MIL::Builder::BlockBuilder *&,MIL::Builder::OperationBuilder *&,MIL::Matching::CompiledPattern const&,void>((MIL::Transform::ProgramTransformer::ProgramTransformerImpl *)((char *)this + 48), &v7, &v6, a4);
  }
  return v4;
}

uint64_t MIL::Transform::ProgramTransformer::ProgramTransformerImpl::ProcessMatch(uint64_t a1, uint64_t a2, uint64_t a3, MIL::Builder::BlockBuilder *a4)
{
  uint64_t v8 = a2 + 168;
  *(void *)(a2 + std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)this + 176) = *(void *)(a2 + 168);
  uint64_t v9 = a2 + 160;
  MIL::MatchingPrivate::MatchPrivate::GetAllMatchedOperations((uint64_t ***)(a2 + 160), (void **)(a2 + 168));
  uint64_t v10 = *(const void **)v8;
  uint64_t v11 = *(void *)(v8 + 8);
  if (*(void *)v8 == v11) {
    return 0;
  }
  std::string __p = 0;
  v309 = 0;
  uint64_t v310 = 0;
  std::vector<MIL::Builder::OperationBuilder *>::__init_with_size[abi:ne180100]<MIL::Builder::OperationBuilder **,MIL::Builder::OperationBuilder **>(&__p, v10, v11, (v11 - (uint64_t)v10) >> 3);
  v305 = (uint64_t *)(a2 + 192);
  MIL::Transform::ProgramTransformer::ProgramTransformerImpl::GetOperationIndices((uint64_t)&__p, a4, (unint64_t **)(a2 + 192), (char **)(a2 + 216));
  if (__p)
  {
    v309 = __p;
    operator delete(__p);
  }
  MIL::Transform::MatchContext::MatchContextImpl::PrepareForNewMatch((MIL::Transform::MatchContext::MatchContextImpl *)a2);
  MIL::Matching::Match::GetRootView(v9, &v307);
  uint64_t v12 = *(void *)(a3 + 24);
  if (!v12) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v12 + 48))(v12, a2 + 152, &v307);
  MIL::Matching::MatchView::~MatchView((MIL::Matching::MatchView *)&v307);
  if (*(unsigned char *)(a2 + 48)) {
    return 0;
  }
  v299 = (const MIL::Builder::OperationBuilder *)(a2 + 216);
  uint64_t v301 = a1;
  v292 = a4;
  unint64_t v293 = **(void **)(a2 + 192);
  v297 = *(MIL::Transform::ProgramTransformer::ProgramTransformerImpl **)(*(void *)(a2 + 200) - 8);
  MIL::Builder::BlockBuilder::GetOperation((MIL::Builder::BlockBuilder::BlockBuilderImpl **)a4, (unint64_t)v297, &v312);
  v303 = (MIL::Transform::_anonymous_namespace_::TopoSortViaDepthFirstSearch *)(a2 + 56);
  uint64_t v14 = *(void *)(a2 + 64);
  if (*(void *)(a2 + 56) == v14)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Match callback returned an empty replacement. If you want to remove the matched operations from the graph, you must instead add an identity operation, and then run an identity elimination pass. Otherwise, your intent may be ambiguous, as there could be several different options to what is considered the input to the identity operation.");
    goto LABEL_389;
  }
  if (*(void *)(a2 + 80) != *(void *)(a2 + 88)) {
    goto LABEL_30;
  }
  unint64_t v15 = (MIL::Builder::OperationBuilder *)v312.__r_.__value_.__r.__words[0];
  uint64_t v16 = *(MIL::Builder::OperationBuilder **)(v14 - 16);
  uint64_t NumOutputs = MIL::Builder::OperationBuilder::GetNumOutputs((MIL::Builder::OperationBuilder *)v312.__r_.__value_.__l.__data_);
  if (NumOutputs != MIL::Builder::OperationBuilder::GetNumOutputs(v16))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Last replacement operation does not have the same number of outputs as the old operation");
LABEL_389:
    __cxa_throw(exception, MEMORY[0x263F8C1E0], MEMORY[0x263F8C048]);
  }
  if (MIL::Builder::OperationBuilder::GetNumOutputs(v15))
  {
    unint64_t v18 = 0;
    do
    {
      uint64_t v19 = ((uint64_t)(*(void *)(a2 + 64) - *(void *)(a2 + 56)) >> 4) - 1;
      unint64_t v21 = *(MIL::Builder::OperationBuilder ***)(a2 + 88);
      unint64_t v20 = *(void *)(a2 + 96);
      if ((unint64_t)v21 >= v20)
      {
        size_t v23 = *(char **)(a2 + 80);
        uint64_t v24 = ((char *)v21 - v23) >> 5;
        unint64_t v25 = v24 + 1;
        if ((unint64_t)(v24 + 1) >> 59) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v26 = v20 - (void)v23;
        if (v26 >> 4 > v25) {
          unint64_t v25 = v26 >> 4;
        }
        if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v27 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v27 = v25;
        }
        if (v27)
        {
          if (v27 >> 59) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          std::string::size_type v28 = (char *)operator new(32 * v27);
        }
        else
        {
          std::string::size_type v28 = 0;
        }
        uint64_t v29 = (MIL::Builder::OperationBuilder **)&v28[32 * v24];
        void *v29 = v15;
        v29[1] = (MIL::Builder::OperationBuilder *)v18;
        void v29[2] = (MIL::Builder::OperationBuilder *)v19;
        v29[3] = (MIL::Builder::OperationBuilder *)v18;
        char v30 = v29;
        if (v21 != (MIL::Builder::OperationBuilder **)v23)
        {
          do
          {
            long long v31 = *((_OWORD *)v21 - 1);
            *((_OWORD *)v30 - 2) = *((_OWORD *)v21 - 2);
            *((_OWORD *)v30 - 1) = v31;
            v30 -= 4;
            v21 -= 4;
          }
          while (v21 != (MIL::Builder::OperationBuilder **)v23);
          unint64_t v21 = *(MIL::Builder::OperationBuilder ***)(a2 + 80);
        }
        unint64_t v22 = v29 + 4;
        *(void *)(a2 + 80) = v30;
        *(void *)(a2 + 88) = v29 + 4;
        *(void *)(a2 + 96) = &v28[32 * v27];
        if (v21) {
          operator delete(v21);
        }
      }
      else
      {
        void *v21 = v15;
        v21[1] = (MIL::Builder::OperationBuilder *)v18;
        unint64_t v22 = v21 + 4;
        v21[2] = (MIL::Builder::OperationBuilder *)v19;
        v21[3] = (MIL::Builder::OperationBuilder *)v18;
      }
      *(void *)(a2 + 88) = v22;
      ++v18;
    }
    while (v18 < MIL::Builder::OperationBuilder::GetNumOutputs(v15));
  }
LABEL_30:
  if (v312.__r_.__value_.__l.__size_) {
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v312.__r_.__value_.__l.__size_);
  }
  unint64_t v32 = (uint64_t)(*(void *)(a2 + 200) - *(void *)(a2 + 192)) >> 3;
  *(void *)(a2 + 288) = 0;
  *(void *)(a2 + 304) = 0;
  std::vector<BOOL>::resize(a2 + 296, v32, 0);
  *(void *)(a2 + 328) = *(void *)(a2 + 320);
  unint64_t v33 = (char **)(a2 + 264);
  *(void *)(a2 + 272) = *(void *)(a2 + 264);
  std::vector<MIL::Passes::BlockInfo>::reserve((void **)(a2 + 264), (uint64_t)(*(void *)(a2 + 88) - *(void *)(a2 + 80)) >> 5);
  uint64_t v34 = *(void *)(a2 + 80);
  uint64_t v35 = *(void *)(a2 + 88);
  if (v34 == v35)
  {
    std::string::size_type v42 = *(long long **)(a2 + 272);
  }
  else
  {
    do
    {
      Outputuint64_t Name = MIL::Builder::OperationBuilder::GetOutputName(*(MIL::Builder::OperationBuilder::OperationBuilderImpl ***)v34, *(void *)(v34 + 8));
      int v37 = *(char *)(OutputName + 23);
      if (v37 >= 0) {
        uint64_t v38 = OutputName;
      }
      else {
        uint64_t v38 = *(void *)OutputName;
      }
      if (v37 >= 0) {
        uint64_t v39 = *(unsigned __int8 *)(OutputName + 23);
      }
      else {
        uint64_t v39 = *(void *)(OutputName + 8);
      }
      std::string v41 = *(uint64_t **)(a2 + 272);
      unint64_t v40 = *(void *)(a2 + 280);
      if ((unint64_t)v41 >= v40)
      {
        uint64_t v43 = ((char *)v41 - *v33) >> 4;
        unint64_t v44 = v43 + 1;
        if ((unint64_t)(v43 + 1) >> 60) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v45 = v40 - (void)*v33;
        if (v45 >> 3 > v44) {
          unint64_t v44 = v45 >> 3;
        }
        if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v46 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v46 = v44;
        }
        if (v46) {
          int v47 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<MIL::IRBlock>>>(a2 + 280, v46);
        }
        else {
          int v47 = 0;
        }
        std::string v48 = (uint64_t *)&v47[16 * v43];
        uint64_t *v48 = v38;
        v48[1] = v39;
        int v50 = *(char **)(a2 + 264);
        std::string v49 = *(char **)(a2 + 272);
        uint64_t v51 = v48;
        if (v49 != v50)
        {
          do
          {
            *((_OWORD *)v51 - 1) = *((_OWORD *)v49 - 1);
            v51 -= 2;
            v49 -= 16;
          }
          while (v49 != v50);
          std::string v49 = *v33;
        }
        std::string::size_type v42 = (long long *)(v48 + 2);
        *(void *)(a2 + 264) = v51;
        *(void *)(a2 + 272) = v48 + 2;
        *(void *)(a2 + 280) = &v47[16 * v46];
        if (v49) {
          operator delete(v49);
        }
      }
      else
      {
        uint64_t *v41 = v38;
        v41[1] = v39;
        std::string::size_type v42 = (long long *)(v41 + 2);
      }
      *(void *)(a2 + 272) = v42;
      v34 += 32;
    }
    while (v34 != v35);
  }
  long long v52 = *(long long **)(a2 + 264);
  unint64_t v53 = 126 - 2 * __clz(v42 - v52);
  if (v42 == v52) {
    uint64_t v54 = 0;
  }
  else {
    uint64_t v54 = v53;
  }
  std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string_view *,false>(v52, v42, (uint64_t)&v312, v54, 1);
  uint64_t v55 = *(MIL::BuilderPrivate::OperationBuilderPrivate ***)(a2 + 56);
  std::string v56 = *(MIL::BuilderPrivate::OperationBuilderPrivate ***)(a2 + 64);
  while (v55 != v56)
  {
    std::string v57 = *v55;
    v55 += 2;
    MIL::Transform::ProgramTransformer::ProgramTransformerImpl::AddMatchedDependencies(v57, v299, (uint64_t *)(a2 + 264), (uint64_t)v292, (MIL::Transform::_anonymous_namespace_::IndexSet *)(a2 + 288));
  }
  uint64_t v58 = *(void *)(a2 + 320);
  if (*(void *)(a2 + 328) != v58)
  {
    unint64_t v59 = 0;
    do
    {
      unint64_t v60 = v59 + 1;
      MIL::Transform::ProgramTransformer::ProgramTransformerImpl::AddMatchedDependencies(*(MIL::BuilderPrivate::OperationBuilderPrivate **)(*(void *)(a2 + 56) + 16 * *(void *)(v58 + 8 * v59)), v299, (uint64_t *)(a2 + 264), (uint64_t)v292, (MIL::Transform::_anonymous_namespace_::IndexSet *)(a2 + 288));
      uint64_t v58 = *(void *)(a2 + 320);
      unint64_t v59 = v60;
    }
    while (v60 < (*(void *)(a2 + 328) - v58) >> 3);
  }
  unint64_t v61 = *(long long **)(a2 + 240);
  *(void *)(a2 + 248) = v61;
  uint64_t v63 = *(char **)(a2 + 80);
  long long v62 = *(char **)(a2 + 88);
  unint64_t v64 = v62 - v63;
  unint64_t v65 = (v62 - v63) >> 5;
  if (v65 > (uint64_t)(*(void *)(a2 + 256) - (void)v61) >> 4)
  {
    if ((v64 & 0x8000000000000000) != 0) {
LABEL_361:
    }
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    uint64_t v66 = (long long *)operator new(v64 >> 1);
    *(void *)(a2 + 240) = v66;
    *(void *)(a2 + 248) = v66;
    *(void *)(a2 + 256) = &v66[v65];
    if (v61)
    {
      operator delete(v61);
      unint64_t v61 = *(long long **)(a2 + 248);
      uint64_t v63 = *(char **)(a2 + 80);
      long long v62 = *(char **)(a2 + 88);
    }
    else
    {
      unint64_t v61 = v66;
    }
  }
  if (v63 == v62)
  {
    size_t v68 = v61;
  }
  else
  {
    do
    {
      unint64_t v67 = *(void *)(a2 + 256);
      if ((unint64_t)v61 >= v67)
      {
        v69 = *(_OWORD **)(a2 + 240);
        uint64_t v70 = v61 - v69;
        unint64_t v71 = v70 + 1;
        if ((unint64_t)(v70 + 1) >> 60) {
          goto LABEL_361;
        }
        uint64_t v72 = v67 - (void)v69;
        if (v72 >> 3 > v71) {
          unint64_t v71 = v72 >> 3;
        }
        if ((unint64_t)v72 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v73 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v73 = v71;
        }
        if (v73)
        {
          if (v73 >> 60) {
            goto LABEL_373;
          }
          v74 = (char *)operator new(16 * v73);
        }
        else
        {
          v74 = 0;
        }
        long long v75 = &v74[16 * v70];
        *(_OWORD *)long long v75 = *(_OWORD *)v63;
        long long v76 = v75;
        if (v61 != v69)
        {
          do
          {
            *((_OWORD *)v76 - 1) = *(v61 - 1);
            v76 -= 16;
            --v61;
          }
          while (v61 != v69);
          unint64_t v61 = *(long long **)(a2 + 240);
        }
        size_t v68 = (long long *)(v75 + 16);
        *(void *)(a2 + 240) = v76;
        *(void *)(a2 + 248) = v75 + 16;
        *(void *)(a2 + 256) = &v74[16 * v73];
        if (v61) {
          operator delete(v61);
        }
      }
      else
      {
        long long *v61 = *(_OWORD *)v63;
        size_t v68 = v61 + 1;
      }
      *(void *)(a2 + 248) = v68;
      v63 += 32;
      unint64_t v61 = v68;
    }
    while (v63 != v62);
  }
  unint64_t v77 = *(void *)(a2 + 240);
  unint64_t v78 = 126 - 2 * __clz((uint64_t)((uint64_t)v68 - v77) >> 4);
  if (v68 == (long long *)v77) {
    uint64_t v79 = 0;
  }
  else {
    uint64_t v79 = v78;
  }
  uint64_t v80 = *(void *)(a2 + 168);
  if (*(void *)(a2 + 176) != v80)
  {
    unint64_t v81 = 0;
    do
    {
      v82 = *(MIL::Builder::OperationBuilder::OperationBuilderImpl ***)(v80 + 8 * v81);
      {
        unint64_t v83 = 0;
        do
        {
          v84 = *(char **)(a2 + 240);
          v85 = *(char **)(a2 + 248);
          if (v85 != v84)
          {
            unint64_t v86 = (v85 - v84) >> 4;
            do
            {
              unint64_t v87 = v86 >> 1;
              v88 = (unint64_t *)&v84[16 * (v86 >> 1)];
              unint64_t v91 = *v88;
              v89 = v88 + 1;
              unint64_t v90 = v91;
              if (v91 < (unint64_t)v82 || (unint64_t)v82 >= v90 && *v89 < v83)
              {
                v84 += 16 * (v86 >> 1) + 16;
                unint64_t v87 = v86 + ~v87;
              }
              unint64_t v86 = v87;
            }
            while (v87);
          }
          if (v84 == v85
            || (unint64_t)v82 < *(void *)v84
            || *(void *)v84 >= (unint64_t)v82 && v83 < *((void *)v84 + 1))
          {
            v92 = (unsigned __int8 *)MIL::Builder::OperationBuilder::GetOutputName(v82, v83);
            v93 = MIL::Builder::BlockBuilder::GetDataDependenciesByVariableName((uint64_t)v292, v92) + 2;
            while (1)
            {
              v93 = (void *)*v93;
              if (!v93) {
                break;
              }
              MIL::Builder::DataDependency::GetConsumer((uint64_t)(v93 + 2), &v312);
              std::string::size_type v94 = v312.__r_.__value_.__r.__words[0];
              if (v312.__r_.__value_.__l.__size_) {
                std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v312.__r_.__value_.__l.__size_);
              }
              if (v94)
              {
                MIL::Builder::DataDependency::GetConsumer((uint64_t)(v93 + 2), &v312);
                v95 = *(void **)(a2 + 168);
                v96 = *(void **)(a2 + 176);
                if (v95 != v96)
                {
                  while (*v95 != v312.__r_.__value_.__r.__words[0])
                  {
                    if (++v95 == v96)
                    {
                      v95 = *(void **)(a2 + 176);
                      break;
                    }
                  }
                }
                if (v312.__r_.__value_.__l.__size_) {
                  std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v312.__r_.__value_.__l.__size_);
                }
                if (v95 != v96) {
                  continue;
                }
              }
              return 0;
            }
          }
          ++v83;
        }
        while (v83 < MIL::Builder::OperationBuilder::GetNumOutputs((MIL::Builder::OperationBuilder *)v82));
      }
      ++v81;
      uint64_t v80 = *(void *)(a2 + 168);
    }
    while (v81 < (*(void *)(a2 + 176) - v80) >> 3);
  }
  v97 = *(void **)(a2 + 320);
  v98 = *(void **)(a2 + 328);
  if (v97 != v98)
  {
    uint64_t v99 = *(void *)(a2 + 216);
    v100 = *(char **)(a2 + 240);
    v101 = *(MIL::Builder::OperationBuilder::OperationBuilderImpl ****)(a2 + 248);
    do
    {
      if ((unint64_t)((*(void *)(a2 + 224) - v99) >> 3) <= *v97) {
        std::vector<MIL::IRDimension const*>::__throw_out_of_range[abi:ne180100]();
      }
      unint64_t v102 = *(void *)(v99 + 8 * *v97);
      v103 = *(MIL::Builder::OperationBuilder::OperationBuilderImpl ****)(a2 + 240);
      if (v101 != (MIL::Builder::OperationBuilder::OperationBuilderImpl ***)v100)
      {
        v103 = *(MIL::Builder::OperationBuilder::OperationBuilderImpl ****)(a2 + 240);
        unint64_t v104 = ((char *)v101 - v100) >> 4;
        do
        {
          unint64_t v105 = v104 >> 1;
          v106 = (unint64_t *)&v103[2 * (v104 >> 1)];
          unint64_t v108 = *v106;
          v107 = (MIL::Builder::OperationBuilder::OperationBuilderImpl ***)(v106 + 2);
          v104 += ~(v104 >> 1);
          if (v108 < v102) {
            v103 = v107;
          }
          else {
            unint64_t v104 = v105;
          }
        }
        while (v104);
      }
      if (v103 != v101 && *v103 == (MIL::Builder::OperationBuilder::OperationBuilderImpl **)v102)
      {
        std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v312);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v312, (uint64_t)"One of the operations that has been matched is being used as a dependency ", 74);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v312, (uint64_t)"for a newly added operation, and thus must be kept in the graph. ", 65);
        v283 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v312, (uint64_t)"On the other hand, its output named '", 37);
        uint64_t v284 = MIL::Builder::OperationBuilder::GetOutputName(*v103, (unint64_t)v103[1]);
        int v285 = *(char *)(v284 + 23);
        if (v285 >= 0) {
          uint64_t v286 = v284;
        }
        else {
          uint64_t v286 = *(void *)v284;
        }
        if (v285 >= 0) {
          uint64_t v287 = *(unsigned __int8 *)(v284 + 23);
        }
        else {
          uint64_t v287 = *(void *)(v284 + 8);
        }
        v288 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v283, v286, v287);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v288, (uint64_t)"' has been remapped ", 20);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v312, (uint64_t)"to another newly added operation using MatchContext::MapOutput(). ", 66);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v312, (uint64_t)"This is currently disallowed.", 29);
        v289 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::stringbuf::str();
        std::logic_error::logic_error(v289, &v311);
        v289->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
        __cxa_throw(v289, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
      }
      ++v97;
    }
    while (v97 != v98);
  }
  uint64_t v109 = *(void *)(a2 + 88);
  if (v109 != *(void *)(a2 + 80))
  {
    uint64_t v110 = *(void *)(v301 + 16);
    uint64_t v111 = *(void *)(a2 + 88);
    v112 = *(MIL::Builder::OperationBuilder::OperationBuilderImpl ***)(*(void *)v303 + 16 * *(void *)(v109 - 16));
    v113 = (const void **)MIL::Builder::OperationBuilder::GetOutputName(v112, *(void *)(v109 - 8));
    MIL::Transform::NameGenerator::TakeBack(v110, v113);
    unint64_t v114 = *(void *)(v109 - 8);
    uint64_t v115 = MIL::Builder::OperationBuilder::GetOutputName(*(MIL::Builder::OperationBuilder::OperationBuilderImpl ***)(v111 - 32), *(void *)(v111 - 24));
    if (*(char *)(v115 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(&v312, *(const std::string::value_type **)v115, *(void *)(v115 + 8));
    }
    else
    {
      long long v116 = *(_OWORD *)v115;
      v312.__r_.__value_.__r.__words[2] = *(void *)(v115 + 16);
      *(_OWORD *)&v312.__r_.__value_.__l.__data_ = v116;
    }
    MIL::Builder::OperationBuilder::RenameOutput((uint64_t)v112, v114, (std::string::size_type)&v312, (uint64_t *)&v311);
  }
  v117 = (void **)(a2 + 344);
  *(void *)(a2 + 352) = *(void *)(a2 + 344);
  std::vector<unsigned long long>::reserve((void **)(a2 + 344), (uint64_t)(*(void *)(a2 + 200) - *(void *)(a2 + 192)) >> 3);
  if (*(void *)(a2 + 200) != *(void *)(a2 + 192))
  {
    unint64_t v118 = 0;
    do
    {
      uint64_t v120 = *v305;
      if ((v119 & 1) == 0)
      {
        v122 = *(char **)(a2 + 352);
        unint64_t v121 = *(void *)(a2 + 360);
        if ((unint64_t)v122 >= v121)
        {
          v124 = (char *)*v117;
          uint64_t v125 = (v122 - (unsigned char *)*v117) >> 3;
          unint64_t v126 = v125 + 1;
          if ((unint64_t)(v125 + 1) >> 61) {
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v127 = v121 - (void)v124;
          if (v127 >> 2 > v126) {
            unint64_t v126 = v127 >> 2;
          }
          if ((unint64_t)v127 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v128 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v128 = v126;
          }
          if (v128)
          {
            v129 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>(a2 + 360, v128);
            v124 = *(char **)(a2 + 344);
            v122 = *(char **)(a2 + 352);
          }
          else
          {
            v129 = 0;
          }
          v130 = &v129[8 * v125];
          *(void *)v130 = *(void *)(v120 + 8 * v118);
          v123 = v130 + 8;
          while (v122 != v124)
          {
            uint64_t v131 = *((void *)v122 - 1);
            v122 -= 8;
            *((void *)v130 - 1) = v131;
            v130 -= 8;
          }
          *(void *)(a2 + 344) = v130;
          *(void *)(a2 + 352) = v123;
          *(void *)(a2 + 360) = &v129[8 * v128];
          if (v124) {
            operator delete(v124);
          }
        }
        else
        {
          *(void *)v122 = *(void *)(v120 + 8 * v118);
          v123 = v122 + 8;
        }
        *(void *)(a2 + 352) = v123;
        uint64_t v120 = *(void *)(a2 + 192);
      }
      ++v118;
    }
    while (v118 < (*(void *)(a2 + 200) - v120) >> 3);
  }
  v132 = (void **)(a2 + 424);
  unint64_t v133 = (uint64_t)(*(void *)(a2 + 64) - *(void *)(a2 + 56)) >> 4;
  *(void *)(a2 + 368) = 0;
  *(void *)(a2 + 384) = 0;
  std::vector<BOOL>::resize(a2 + 376, v133, 0);
  *(void *)(a2 + 408) = *(void *)(a2 + 400);
  *(void *)(a2 + 432) = *(void *)(a2 + 424);
  std::vector<MIL::Passes::BlockInfo>::reserve((void **)(a2 + 424), (uint64_t)(*(void *)(a2 + 64) - *(void *)(a2 + 56)) >> 4);
  v134 = *(uint64_t **)(a2 + 80);
  v302 = *(uint64_t **)(a2 + 88);
  if (v134 != v302)
  {
    unint64_t v135 = 0;
    while (1)
    {
      {
        uint64_t MatchedOperationIndex = MIL::Transform::ProgramTransformer::ProgramTransformerImpl::GetMatchedOperationIndex(*v134, v305, (uint64_t)v299);
        uint64_t v137 = *(void *)(a2 + 400);
        if (v135 < (*(void *)(a2 + 408) - v137) >> 3) {
          break;
        }
      }
LABEL_194:
      v134 += 4;
      if (v134 == v302) {
        goto LABEL_195;
      }
    }
    uint64_t v138 = MatchedOperationIndex;
    while (1)
    {
      unint64_t v139 = *(void *)(v137 + 8 * v135);
      v141 = *(char **)(a2 + 432);
      unint64_t v140 = *(void *)(a2 + 440);
      if ((unint64_t)v141 >= v140)
      {
        v143 = (char *)*v132;
        uint64_t v144 = (v141 - (unsigned char *)*v132) >> 4;
        unint64_t v145 = v144 + 1;
        if ((unint64_t)(v144 + 1) >> 60) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v146 = v140 - (void)v143;
        if (v146 >> 3 > v145) {
          unint64_t v145 = v146 >> 3;
        }
        if ((unint64_t)v146 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v147 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v147 = v145;
        }
        if (v147)
        {
          v148 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<MIL::IRBlock>>>(a2 + 440, v147);
          v143 = *(char **)(a2 + 424);
          v141 = *(char **)(a2 + 432);
        }
        else
        {
          v148 = 0;
        }
        v149 = (uint64_t *)&v148[16 * v144];
        uint64_t *v149 = v138;
        v149[1] = v139;
        v150 = v149;
        if (v141 != v143)
        {
          do
          {
            *((_OWORD *)v150 - 1) = *((_OWORD *)v141 - 1);
            v150 -= 2;
            v141 -= 16;
          }
          while (v141 != v143);
          v143 = (char *)*v132;
        }
        v142 = v149 + 2;
        *(void *)(a2 + 424) = v150;
        *(void *)(a2 + 432) = v149 + 2;
        *(void *)(a2 + 440) = &v148[16 * v147];
        if (v143) {
          operator delete(v143);
        }
      }
      else
      {
        *(void *)v141 = v138;
        *((void *)v141 + 1) = v139;
        v142 = v141 + 16;
      }
      *(void *)(a2 + 432) = v142;
      uint64_t v151 = *(void *)(a2 + 128);
      unint64_t v152 = (*(void *)(a2 + 136) - v151) >> 3;
      if (v152 <= v139 || v152 <= v139 + 1) {
        break;
      }
      uint64_t v153 = *(void *)(v151 + 8 * v139);
      uint64_t v154 = *(void *)(v151 + 8 * (v139 + 1));
      if (v154 == v153) {
        v155 = 0;
      }
      else {
        v155 = (uint64_t *)(*(void *)(a2 + 104) + 8 * v153);
      }
      if (v154 != v153)
      {
        uint64_t v156 = 8 * v154 - 8 * v153;
        do
        {
          uint64_t v157 = *v155++;
          v156 -= 8;
        }
        while (v156);
      }
      ++v135;
      uint64_t v137 = *(void *)(a2 + 400);
      if (v135 >= (*(void *)(a2 + 408) - v137) >> 3) {
        goto LABEL_194;
      }
    }
LABEL_357:
    std::vector<MIL::IRDimension const*>::__throw_out_of_range[abi:ne180100]();
  }
LABEL_195:
  if (*(void *)(a2 + 64) != *(void *)(a2 + 56))
  {
    uint64_t v158 = 0;
    unint64_t v159 = 0;
    do
    {
      {
        std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v312);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v312, (uint64_t)"Replacement callback has added an operation whose outputs are not used anywhere. ", 81);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v312, (uint64_t)"(The operation's index is ", 26);
        std::ostream::operator<<();
        v274 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v312, (uint64_t)" and the operator name is '", 27);
        uint64_t v275 = *(void *)(a2 + 56);
        if (v159 < (*(void *)(a2 + 64) - v275) >> 4)
        {
          v276 = v274;
          uint64_t Operator = MIL::Builder::OperationBuilder::GetOperator(*(MIL::Builder::OperationBuilder **)(v275 + v158));
          uint64_t v278 = (*(uint64_t (**)(uint64_t))(*(void *)Operator + 16))(Operator);
          int v279 = *(char *)(v278 + 23);
          if (v279 >= 0) {
            uint64_t v280 = v278;
          }
          else {
            uint64_t v280 = *(void *)v278;
          }
          if (v279 >= 0) {
            uint64_t v281 = *(unsigned __int8 *)(v278 + 23);
          }
          else {
            uint64_t v281 = *(void *)(v278 + 8);
          }
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v276, v280, v281);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v312, (uint64_t)"'.) You likely meant to do one of the following things:\n", 56);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v312, (uint64_t)"    1. Add another operation that consumes this operation's output.\n", 68);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v312, (uint64_t)"    2. Use MatchContext::MapOutput() to map the output of this operation to\n", 76);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v312, (uint64_t)"       an output of some matched operation.\n", 44);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v312, (uint64_t)"    3. Remove the MatchContext::AddOperation()/AddMultiOutputOperation() call\n", 78);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v312, (uint64_t)"       that is responsible for adding this operation.\n", 54);
          v282 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
          std::stringbuf::str();
          std::logic_error::logic_error(v282, &v311);
          v282->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
          __cxa_throw(v282, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
        }
        std::vector<MIL::IRDimension const*>::__throw_out_of_range[abi:ne180100]();
      }
      ++v159;
      v158 += 16;
    }
    while (v159 < (uint64_t)(*(void *)(a2 + 64) - *(void *)(a2 + 56)) >> 4);
  }
  v160 = *(unint64_t **)(a2 + 424);
  v161 = *(unint64_t **)(a2 + 432);
  unint64_t v162 = 126 - 2 * __clz(((char *)v161 - (char *)v160) >> 4);
  if (v161 == v160) {
    uint64_t v163 = 0;
  }
  else {
    uint64_t v163 = v162;
  }
  std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *,false>(v160, v161, (uint64_t)&v312, v163, 1);
  uint64_t v164 = *(void *)(a2 + 352) - *(void *)(a2 + 344);
  if (v164) {
    v165 = *(void **)(a2 + 344);
  }
  else {
    v165 = 0;
  }
  MIL::Builder::BlockBuilder::RemoveOperations((uint64_t)v292, v165, v164 >> 3, 1);
  MIL::Transform::ProgramTransformer::ProgramTransformerImpl::AdjustInsertionPositionsAfterRemoval((unint64_t **)(a2 + 344), (unint64_t **)(a2 + 424));
  MIL::Transform::ProgramTransformer::ProgramTransformerImpl::GetOperationsToInsertAndTheirPositions(v303, a2 + 424, (uint64_t *)(a2 + 448), a2 + 472);
  uint64_t v166 = *(void *)(a2 + 456) - *(void *)(a2 + 448);
  unint64_t v167 = v166 >> 4;
  if (v166) {
    uint64_t v168 = *(void *)(a2 + 448);
  }
  else {
    uint64_t v168 = 0;
  }
  uint64_t v169 = *(void *)(a2 + 480) - *(void *)(a2 + 472);
  if (v169) {
    v170 = *(unint64_t **)(a2 + 472);
  }
  else {
    v170 = 0;
  }
  MIL::Builder::BlockBuilder::InsertOperations(v292, v168, v167, v170, v169 >> 3);
  unint64_t v171 = v293;
  unint64_t v295 = MIL::Transform::ProgramTransformer::ProgramTransformerImpl::AdjustMaxIndex(v297, (uint64_t)(*(void *)(a2 + 352) - *(void *)(a2 + 344)) >> 3, (uint64_t)(*(void *)(a2 + 480) - *(void *)(a2 + 472)) >> 3);
  unint64_t v172 = v295 - v293;
  if (v295 < v293)
  {
    v291 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v291, "maxIndex must be greater or equal to minIndex");
    __cxa_throw(v291, MEMORY[0x263F8C1E0], MEMORY[0x263F8C048]);
  }
  v173 = (char **)(a2 + 496);
  *(void *)(a2 + 504) = *(void *)(a2 + 496);
  do
  {
    MIL::Builder::BlockBuilder::GetOperation((MIL::Builder::BlockBuilder::BlockBuilderImpl **)v292, v171, &v312);
    std::string::size_type v174 = v312.__r_.__value_.__r.__words[0];
    v176 = *(void **)(a2 + 504);
    unint64_t v175 = *(void *)(a2 + 512);
    if ((unint64_t)v176 >= v175)
    {
      uint64_t v178 = ((char *)v176 - *v173) >> 4;
      unint64_t v179 = v178 + 1;
      if ((unint64_t)(v178 + 1) >> 60) {
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v180 = v175 - (void)*v173;
      if (v180 >> 3 > v179) {
        unint64_t v179 = v180 >> 3;
      }
      if ((unint64_t)v180 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v181 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v181 = v179;
      }
      if (v181) {
        v182 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<MIL::IRBlock>>>(a2 + 512, v181);
      }
      else {
        v182 = 0;
      }
      v183 = (std::string::size_type *)&v182[16 * v178];
      std::string::size_type *v183 = v174;
      v183[1] = v171;
      v185 = *(char **)(a2 + 496);
      v184 = *(char **)(a2 + 504);
      v186 = v183;
      if (v184 != v185)
      {
        do
        {
          *((_OWORD *)v186 - 1) = *((_OWORD *)v184 - 1);
          v186 -= 2;
          v184 -= 16;
        }
        while (v184 != v185);
        v184 = *v173;
      }
      v177 = v183 + 2;
      *(void *)(a2 + 496) = v186;
      *(void *)(a2 + 504) = v183 + 2;
      *(void *)(a2 + 512) = &v182[16 * v181];
      if (v184) {
        operator delete(v184);
      }
    }
    else
    {
      void *v176 = v312.__r_.__value_.__r.__words[0];
      v176[1] = v171;
      v177 = v176 + 2;
    }
    *(void *)(a2 + 504) = v177;
    if (v312.__r_.__value_.__l.__size_) {
      std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v312.__r_.__value_.__l.__size_);
    }
    ++v171;
  }
  while (v171 <= v295);
  uint64_t v187 = *(void *)(a2 + 496);
  v188 = *(unint64_t **)(a2 + 504);
  unint64_t v189 = 126 - 2 * __clz(((uint64_t)v188 - v187) >> 4);
  if (v188 == (unint64_t *)v187) {
    uint64_t v190 = 0;
  }
  else {
    uint64_t v190 = v189;
  }
  std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *,false>(v187, v188, (uint64_t)&v312, v190, 1);
  *(void *)(a2 + 576) = v292;
  *(void *)(a2 + 592) = v173;
  *(void *)(a2 + 584) = v293;
  v306 = (void **)(a2 + 624);
  std::vector<unsigned long>::resize(a2 + 624, 1uLL);
  v191 = *(char **)(a2 + 600);
  *(void *)(a2 + 608) = v191;
  size_t v192 = v172 + 1;
  if (v172 == -1)
  {
    *(void *)(a2 + 648) = v293;
    *(void *)(a2 + 664) = *(void *)(a2 + 656);
    unint64_t v193 = v293;
  }
  else
  {
    uint64_t v194 = *(void *)(a2 + 616) - (void)v191;
    if (v192 <= v194 >> 4)
    {
      bzero(v191, 16 * v172 + 16);
      *(void *)(a2 + 608) = &v191[16 * v192];
    }
    else
    {
      if (v192 >> 60) {
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v195 = v194 >> 3;
      if (v194 >> 3 <= v192) {
        uint64_t v195 = v172 + 1;
      }
      if ((unint64_t)v194 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v196 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v196 = v195;
      }
      if (v196 >> 60) {
LABEL_373:
      }
        std::__throw_bad_array_new_length[abi:ne180100]();
      v197 = (char *)operator new(16 * v196);
      bzero(v197, 16 * v172 + 16);
      *(void *)(a2 + 600) = v197;
      *(void *)(a2 + 608) = &v197[16 * v192];
      *(void *)(a2 + 616) = &v197[16 * v196];
      if (v191) {
        operator delete(v191);
      }
    }
    *(void *)(a2 + 648) = v293;
    v198 = *(char **)(a2 + 656);
    *(void *)(a2 + 664) = v198;
    unint64_t v199 = *(void *)(a2 + 672) - (void)v198;
    if (v199 >= v192)
    {
      bzero(v198, v172 + 1);
      unint64_t v193 = v293;
      *(void *)(a2 + 664) = &v198[v192];
    }
    else
    {
      if ((v192 & 0x8000000000000000) != 0) {
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v200 = 2 * v199;
      if (2 * v199 <= v192) {
        uint64_t v200 = v172 + 1;
      }
      if (v199 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v201 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v201 = v200;
      }
      v202 = (char *)operator new(v201);
      bzero(v202, v192);
      *(void *)(a2 + 656) = v202;
      *(void *)(a2 + 664) = &v202[v192];
      *(void *)(a2 + 672) = &v202[v201];
      unint64_t v193 = v293;
      if (v198)
      {
        operator delete(v198);
        unint64_t v193 = v293;
      }
    }
  }
  *(void *)(a2 + 712) = *(void *)(a2 + 704);
  v304 = (MIL::Transform::_anonymous_namespace_::TopoSortViaDepthFirstSearch *)(a2 + 576);
  v296 = (void **)(a2 + 704);
  uint64_t v203 = *(void *)(a2 + 680);
  uint64_t v204 = v193;
  do
  {
    *(void *)(a2 + 688) = v203;
    uint64_t v294 = v204;
    uint64_t v203 = *(void *)(a2 + 680);
    if (v203 != *(void *)(a2 + 688))
    {
      uint64_t v203 = *(void *)(a2 + 688);
      do
      {
        unint64_t v205 = *(void *)(v203 - 8);
        unint64_t v206 = v205 - *(void *)(a2 + 584);
        uint64_t v207 = *(void *)(a2 + 600);
        if (v206 >= (*(void *)(a2 + 608) - v207) >> 4) {
          std::vector<MIL::IRDimension const*>::__throw_out_of_range[abi:ne180100]();
        }
        v208 = (uint64_t *)(v207 + 16 * v206);
        uint64_t v209 = *v208;
        if (!*v208)
        {
          v298 = (MIL::Transform::ProgramTransformer::ProgramTransformerImpl *)(v207 + 16 * v206);
          unint64_t v300 = v205;
          MIL::Builder::BlockBuilder::GetOperation(*(MIL::Builder::BlockBuilder::BlockBuilderImpl ***)(a2 + 576), v205, &v311);
          uint64_t v210 = v311.__r_.__value_.__r.__words[0];
          uint64_t v211 = *(void *)(a2 + 632);
          uint64_t v212 = *(void *)(a2 + 624);
          Parameters = (void *)MIL::BuilderPrivate::OperationBuilderPrivate::GetParameters((MIL::BuilderPrivate::OperationBuilderPrivate *)v311.__r_.__value_.__l.__data_, v213);
          uint64_t v209 = (v211 - v212) >> 3;
          v215 = (unsigned __int8 *)(Parameters + 1);
          v216 = (unsigned __int8 *)*Parameters;
          uint64_t v217 = v209;
          if ((void *)*Parameters != Parameters + 1)
          {
            uint64_t v217 = v209;
            do
            {
              for (uint64_t i = (uint64_t **)*((void *)MIL::Builder::BlockBuilder::GetDataDependenciesForConsumerParam(*(void *)v304, v210, v216 + 32)+ 2); i; uint64_t i = (uint64_t **)*i)
              {
                MIL::Builder::DataDependency::GetProducer(i + 2, &v312);
                if (v312.__r_.__value_.__r.__words[0])
                {
                  v219 = *(char ***)(a2 + 592);
                  v221 = *v219;
                  v220 = v219[1];
                  if (v220 != v221)
                  {
                    unint64_t v222 = (v220 - v221) >> 4;
                    do
                    {
                      unint64_t v223 = v222 >> 1;
                      v224 = (std::string::size_type *)&v221[16 * (v222 >> 1)];
                      std::string::size_type v226 = *v224;
                      v225 = (char *)(v224 + 2);
                      v222 += ~(v222 >> 1);
                      if (v226 < v312.__r_.__value_.__r.__words[0]) {
                        v221 = v225;
                      }
                      else {
                        unint64_t v222 = v223;
                      }
                    }
                    while (v222);
                  }
                  if (v221 != v220 && *(void *)v221 == v312.__r_.__value_.__r.__words[0])
                  {
                    v227 = *(char **)(a2 + 632);
                    unint64_t v228 = *(void *)(a2 + 640);
                    if ((unint64_t)v227 >= v228)
                    {
                      v230 = (char *)*v306;
                      uint64_t v231 = (v227 - (unsigned char *)*v306) >> 3;
                      unint64_t v232 = v231 + 1;
                      if ((unint64_t)(v231 + 1) >> 61) {
                        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
                      }
                      uint64_t v233 = v228 - (void)v230;
                      if (v233 >> 2 > v232) {
                        unint64_t v232 = v233 >> 2;
                      }
                      if ((unint64_t)v233 >= 0x7FFFFFFFFFFFFFF8) {
                        unint64_t v234 = 0x1FFFFFFFFFFFFFFFLL;
                      }
                      else {
                        unint64_t v234 = v232;
                      }
                      if (v234)
                      {
                        v235 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>(a2 + 640, v234);
                        v227 = *(char **)(a2 + 632);
                        v230 = *(char **)(a2 + 624);
                      }
                      else
                      {
                        v235 = 0;
                      }
                      v236 = &v235[8 * v231];
                      *(void *)v236 = *((void *)v221 + 1);
                      v229 = v236 + 8;
                      while (v227 != v230)
                      {
                        uint64_t v237 = *((void *)v227 - 1);
                        v227 -= 8;
                        *((void *)v236 - 1) = v237;
                        v236 -= 8;
                      }
                      *(void *)(a2 + 624) = v236;
                      *(void *)(a2 + 632) = v229;
                      *(void *)(a2 + 640) = &v235[8 * v234];
                      if (v230) {
                        operator delete(v230);
                      }
                    }
                    else
                    {
                      *(void *)v227 = *((void *)v221 + 1);
                      v229 = v227 + 8;
                    }
                    *(void *)(a2 + 632) = v229;
                    ++v217;
                  }
                }
                if (v312.__r_.__value_.__l.__size_) {
                  std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v312.__r_.__value_.__l.__size_);
                }
              }
              v238 = (unsigned __int8 *)*((void *)v216 + 1);
              if (v238)
              {
                do
                {
                  v239 = v238;
                  v238 = *(unsigned __int8 **)v238;
                }
                while (v238);
              }
              else
              {
                do
                {
                  v239 = (unsigned __int8 *)*((void *)v216 + 2);
                  BOOL v240 = *(void *)v239 == (void)v216;
                  v216 = v239;
                }
                while (!v240);
              }
              v216 = v239;
            }
            while (v239 != v215);
          }
          std::__sort<std::__less<unsigned long,unsigned long> &,unsigned long *>();
          v208 = (uint64_t *)v298;
          *(void *)v298 = v209;
          *((void *)v298 + 1) = v217;
          if (v311.__r_.__value_.__l.__size_)
          {
            std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v311.__r_.__value_.__l.__size_);
            uint64_t v209 = *(void *)v298;
          }
          unint64_t v205 = v300;
        }
        if (v209 == v208[1])
        {
          unint64_t v241 = v205 - *(void *)(a2 + 648);
          uint64_t v242 = *(void *)(a2 + 656);
          if (*(void *)(a2 + 664) - v242 <= v241) {
            std::vector<MIL::IRDimension const*>::__throw_out_of_range[abi:ne180100]();
          }
          *(unsigned char *)(v242 + v241) = 2;
          v243 = *(unint64_t **)(a2 + 712);
          unint64_t v244 = *(void *)(a2 + 720);
          if ((unint64_t)v243 >= v244)
          {
            v246 = (unint64_t *)*v296;
            uint64_t v247 = ((char *)v243 - (unsigned char *)*v296) >> 3;
            unint64_t v248 = v247 + 1;
            if ((unint64_t)(v247 + 1) >> 61) {
              std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v249 = v244 - (void)v246;
            if (v249 >> 2 > v248) {
              unint64_t v248 = v249 >> 2;
            }
            if ((unint64_t)v249 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v250 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v250 = v248;
            }
            if (v250)
            {
              v251 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>(a2 + 720, v250);
              v243 = *(unint64_t **)(a2 + 712);
              v246 = *(unint64_t **)(a2 + 704);
            }
            else
            {
              v251 = 0;
            }
            v252 = (unint64_t *)&v251[8 * v247];
            unint64_t *v252 = v205;
            v245 = v252 + 1;
            while (v243 != v246)
            {
              unint64_t v253 = *--v243;
              *--v252 = v253;
            }
            *(void *)(a2 + 704) = v252;
            *(void *)(a2 + 712) = v245;
            *(void *)(a2 + 720) = &v251[8 * v250];
            if (v246) {
              operator delete(v246);
            }
          }
          else
          {
            unint64_t *v243 = v205;
            v245 = v243 + 1;
          }
          *(void *)(a2 + 712) = v245;
          uint64_t v203 = *(void *)(a2 + 688) - 8;
          *(void *)(a2 + 688) = v203;
        }
        else
        {
          uint64_t *v208 = v209 + 1;
          uint64_t v203 = *(void *)(a2 + 688);
        }
      }
      while (*(void *)(a2 + 680) != v203);
    }
    uint64_t v204 = v294 + 1;
  }
  while (v294 + 1 <= v295);
  uint64_t v254 = *(void *)(a2 + 712);
  uint64_t v255 = *(void *)(a2 + 704);
  v256 = (void **)(a2 + 728);
  unint64_t v257 = (v254 - v255) >> 3;
  *(void *)(a2 + 736) = *(void *)(a2 + 728);
  std::vector<unsigned long long>::reserve((void **)(a2 + 728), v257);
  if (v254 != v255)
  {
    unint64_t v258 = 0;
    if (v257 <= 1) {
      unint64_t v257 = 1;
    }
    uint64_t v259 = v293;
    while (1)
    {
      uint64_t v260 = *(void *)(a2 + 704);
      if (v258 >= (*(void *)(a2 + 712) - v260) >> 3) {
        goto LABEL_357;
      }
      uint64_t v261 = *(void *)(v260 + 8 * v258) - v259;
      v262 = *(char **)(a2 + 736);
      unint64_t v263 = *(void *)(a2 + 744);
      if ((unint64_t)v262 >= v263)
      {
        v265 = (char *)*v256;
        uint64_t v266 = (v262 - (unsigned char *)*v256) >> 3;
        unint64_t v267 = v266 + 1;
        if ((unint64_t)(v266 + 1) >> 61) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v268 = v263 - (void)v265;
        if (v268 >> 2 > v267) {
          unint64_t v267 = v268 >> 2;
        }
        if ((unint64_t)v268 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v269 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v269 = v267;
        }
        if (v269)
        {
          v270 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>(a2 + 744, v269);
          v262 = *(char **)(a2 + 736);
          v265 = *(char **)(a2 + 728);
        }
        else
        {
          v270 = 0;
        }
        v271 = (uint64_t *)&v270[8 * v266];
        uint64_t *v271 = v261;
        v264 = (char *)(v271 + 1);
        while (v262 != v265)
        {
          uint64_t v272 = *((void *)v262 - 1);
          v262 -= 8;
          *--v271 = v272;
        }
        *(void *)(a2 + 728) = v271;
        *(void *)(a2 + 736) = v264;
        *(void *)(a2 + 744) = &v270[8 * v269];
        if (v265) {
          operator delete(v265);
        }
        uint64_t v259 = v293;
      }
      else
      {
        *(void *)v262 = v261;
        v264 = v262 + 8;
      }
      *(void *)(a2 + 736) = v264;
      if (++v258 == v257) {
        goto LABEL_351;
      }
    }
  }
  v264 = *(char **)(a2 + 736);
  uint64_t v259 = v293;
LABEL_351:
  if (v264 == *v256) {
    uint64_t v273 = 0;
  }
  else {
    uint64_t v273 = (uint64_t)*v256;
  }
  MIL::BuilderPrivate::BlockBuilderPrivate::PermuteOperations((uint64_t)v292, v259, v273, (v264 - (unsigned char *)*v256) >> 3);
  return 1;
}

void sub_20F491958(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,void *a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  if (a31 < 0)
  {
    operator delete(__p);
    if ((v38 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a32);
      _Unwind_Resume(a1);
    }
  }
  else if (!v38)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v37);
  goto LABEL_6;
}

uint64_t std::optional<MIL::Matching::Matcher>::emplace[abi:ne180100]<MIL::Builder::BlockBuilder *&,MIL::Builder::OperationBuilder *&,MIL::Matching::CompiledPattern const&,void>(MIL::Matching::Matcher *a1, MIL::Builder::BlockBuilder **a2, MIL::Builder::OperationBuilder **a3, MIL::Matching::CompiledPattern *a4)
{
  if (*((unsigned char *)a1 + 8))
  {
    MIL::Matching::Matcher::~Matcher(a1);
    *((unsigned char *)a1 + 8) = 0;
  }
  uint64_t result = MIL::Matching::Matcher::Matcher(a1, *a2, *a3, a4);
  *(unsigned char *)(result + 8) = 1;
  return result;
}

unint64_t MIL::Transform::ProgramTransformer::ProgramTransformerImpl::GetOperationIndices(uint64_t a1, MIL::Builder::BlockBuilder *this, unint64_t **a3, char **a4)
{
  a3[1] = *a3;
  a4[1] = *a4;
  unint64_t result = MIL::Builder::BlockBuilder::GetNumOperations(this);
  if (result)
  {
    for (unint64_t i = 0; i < result; ++i)
    {
      MIL::Builder::BlockBuilder::GetOperation((MIL::Builder::BlockBuilder::BlockBuilderImpl **)this, i, &v36);
      uint64_t v10 = v36;
      if (*((void *)&v36 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v36 + 1));
      }
      uint64_t v12 = *(void **)a1;
      uint64_t v11 = *(void **)(a1 + 8);
      if (*(void **)a1 != v11)
      {
        while (*v12 != v10)
        {
          if (++v12 == v11)
          {
            uint64_t v12 = *(void **)(a1 + 8);
            break;
          }
        }
      }
      if (v12 != v11)
      {
        uint64_t v14 = a3[1];
        unint64_t v13 = (unint64_t)a3[2];
        if ((unint64_t)v14 >= v13)
        {
          uint64_t v16 = *a3;
          uint64_t v17 = v14 - *a3;
          unint64_t v18 = v17 + 1;
          if ((unint64_t)(v17 + 1) >> 61) {
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v19 = v13 - (void)v16;
          if (v19 >> 2 > v18) {
            unint64_t v18 = v19 >> 2;
          }
          if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v20 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v20 = v18;
          }
          if (v20)
          {
            unint64_t v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(a3 + 2), v20);
            uint64_t v16 = *a3;
            uint64_t v14 = a3[1];
          }
          else
          {
            unint64_t v21 = 0;
          }
          unint64_t v22 = (unint64_t *)&v21[8 * v17];
          *unint64_t v22 = i;
          unint64_t v15 = v22 + 1;
          while (v14 != v16)
          {
            unint64_t v23 = *--v14;
            *--unint64_t v22 = v23;
          }
          *a3 = v22;
          a3[1] = v15;
          a3[2] = (unint64_t *)&v21[8 * v20];
          if (v16) {
            operator delete(v16);
          }
        }
        else
        {
          *uint64_t v14 = i;
          unint64_t v15 = v14 + 1;
        }
        a3[1] = v15;
        unint64_t v25 = a4[1];
        unint64_t v24 = (unint64_t)a4[2];
        if ((unint64_t)v25 >= v24)
        {
          uint64_t v27 = (v25 - *a4) >> 3;
          if ((unint64_t)(v27 + 1) >> 61) {
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v28 = v24 - (void)*a4;
          uint64_t v29 = v28 >> 2;
          if (v28 >> 2 <= (unint64_t)(v27 + 1)) {
            uint64_t v29 = v27 + 1;
          }
          if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v30 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v30 = v29;
          }
          if (v30) {
            long long v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(a4 + 2), v30);
          }
          else {
            long long v31 = 0;
          }
          unint64_t v32 = &v31[8 * v27];
          *(void *)unint64_t v32 = v10;
          uint64_t v26 = v32 + 8;
          uint64_t v34 = *a4;
          unint64_t v33 = a4[1];
          if (v33 != *a4)
          {
            do
            {
              uint64_t v35 = *((void *)v33 - 1);
              v33 -= 8;
              *((void *)v32 - 1) = v35;
              v32 -= 8;
            }
            while (v33 != v34);
            unint64_t v33 = *a4;
          }
          *a4 = v32;
          a4[1] = v26;
          a4[2] = &v31[8 * v30];
          if (v33) {
            operator delete(v33);
          }
        }
        else
        {
          *(void *)unint64_t v25 = v10;
          uint64_t v26 = v25 + 8;
        }
        a4[1] = v26;
      }
      unint64_t result = MIL::Builder::BlockBuilder::GetNumOperations(this);
    }
  }
  return result;
}

void MIL::Transform::MatchContext::MatchContextImpl::PrepareForNewMatch(MIL::Transform::MatchContext::MatchContextImpl *this)
{
  *((unsigned char *)this + 48) = 0;
  std::vector<std::shared_ptr<MIL::IRBlock>>::__clear[abi:ne180100]((uint64_t *)this + 7);
  *((void *)this + 11) = *((void *)this + 10);
  std::vector<unsigned long>::resize((uint64_t)this + 104, 1uLL);

  std::vector<unsigned long>::resize((uint64_t)this + 128, 1uLL);
}

unint64_t **MIL::Transform::ProgramTransformer::ProgramTransformerImpl::AdjustInsertionPositionsAfterRemoval(unint64_t **result, unint64_t **a2)
{
  uint64_t v2 = *result;
  uint64_t v3 = result[1];
  uint64_t v5 = *a2;
  unint64_t v4 = a2[1];
  if (*result == v3)
  {
    uint64_t v6 = 0;
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v7 = *a2;
    do
    {
      uint64_t v5 = v4;
      if (v7 != v4)
      {
        unint64_t v8 = *v2;
        while (*v7 <= v8)
        {
          *v7 -= v6;
          v7 += 2;
          if (v7 == v4)
          {
            uint64_t v5 = v4;
            goto LABEL_9;
          }
        }
        uint64_t v5 = v7;
      }
LABEL_9:
      ++v6;
      ++v2;
      uint64_t v7 = v5;
    }
    while (v2 != v3);
  }
  while (v5 != v4)
  {
    *v5 -= v6;
    v5 += 2;
  }
  return result;
}

void MIL::Transform::ProgramTransformer::ProgramTransformerImpl::GetOperationsToInsertAndTheirPositions(void *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  std::vector<std::shared_ptr<MIL::IRBlock>>::__clear[abi:ne180100](a3);
  std::vector<std::shared_ptr<MIL::Builder::OperationBuilder>>::reserve(a3, (uint64_t)(a1[1] - *a1) >> 4);
  *(void *)(a4 + 8) = *(void *)a4;
  std::vector<unsigned long long>::reserve((void **)a4, (uint64_t)(a1[1] - *a1) >> 4);
  unint64_t v8 = *(void **)a2;
  uint64_t v9 = *(void **)(a2 + 8);
  if (*(void **)a2 != v9)
  {
    do
    {
      unint64_t v10 = v8[1];
      if (v10 >= (uint64_t)(a1[1] - *a1) >> 4) {
        std::vector<MIL::IRDimension const*>::__throw_out_of_range[abi:ne180100]();
      }
      std::vector<std::shared_ptr<MIL::Builder::OperationBuilder>>::push_back[abi:ne180100](a3, (long long *)(*a1 + 16 * v10));
      uint64_t v12 = *(void **)(a4 + 8);
      unint64_t v11 = *(void *)(a4 + 16);
      if ((unint64_t)v12 >= v11)
      {
        uint64_t v14 = *(void **)a4;
        uint64_t v15 = ((uint64_t)v12 - *(void *)a4) >> 3;
        unint64_t v16 = v15 + 1;
        if ((unint64_t)(v15 + 1) >> 61) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v17 = v11 - (void)v14;
        if (v17 >> 2 > v16) {
          unint64_t v16 = v17 >> 2;
        }
        if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v18 = v16;
        }
        if (v18)
        {
          uint64_t v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>(a4 + 16, v18);
          uint64_t v14 = *(void **)a4;
          uint64_t v12 = *(void **)(a4 + 8);
        }
        else
        {
          uint64_t v19 = 0;
        }
        unint64_t v20 = &v19[8 * v15];
        *(void *)unint64_t v20 = *v8;
        unint64_t v13 = v20 + 8;
        while (v12 != v14)
        {
          uint64_t v21 = *--v12;
          *((void *)v20 - 1) = v21;
          v20 -= 8;
        }
        *(void *)a4 = v20;
        *(void *)(a4 + 8) = v13;
        *(void *)(a4 + 16) = &v19[8 * v18];
        if (v14) {
          operator delete(v14);
        }
      }
      else
      {
        *uint64_t v12 = *v8;
        unint64_t v13 = v12 + 1;
      }
      *(void *)(a4 + 8) = v13;
      v8 += 2;
    }
    while (v8 != v9);
  }
}

uint64_t MIL::Transform::ProgramTransformer::ProgramTransformerImpl::AdjustMaxIndex(MIL::Transform::ProgramTransformer::ProgramTransformerImpl *this, unint64_t a2, uint64_t a3)
{
  if ((unint64_t)this + 1 < a2)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "numRemoved is too big");
    goto LABEL_6;
  }
  if (!a3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "numInserted is zero");
LABEL_6:
    __cxa_throw(exception, MEMORY[0x263F8C1E0], MEMORY[0x263F8C048]);
  }
  return (uint64_t)this + a3 - a2;
}

void sub_20F491FCC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *std::vector<MIL::Builder::OperationBuilder *>::__init_with_size[abi:ne180100]<MIL::Builder::OperationBuilder **,MIL::Builder::OperationBuilder **>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    unint64_t result = std::vector<unsigned long long>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      unint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_20F492044(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<unsigned long>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 8 * a2;
    }
  }
  else
  {
    std::vector<unsigned long>::__append((char **)a1, a2 - v2);
  }
}

void std::vector<unsigned long>::__append(char **a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    size_t v8 = *a1;
    uint64_t v9 = v7 - *a1;
    unint64_t v10 = a2 + (v9 >> 3);
    if (v10 >> 61) {
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = v9 >> 3;
    uint64_t v12 = v5 - v8;
    if (v12 >> 2 > v10) {
      unint64_t v10 = v12 >> 2;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v10;
    }
    if (v13)
    {
      uint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>(v4, v13);
      size_t v8 = *a1;
      uint64_t v7 = a1[1];
    }
    else
    {
      uint64_t v14 = 0;
    }
    uint64_t v15 = &v14[8 * v11];
    unint64_t v16 = &v14[8 * v13];
    bzero(v15, 8 * a2);
    uint64_t v17 = &v15[8 * a2];
    while (v7 != v8)
    {
      uint64_t v18 = *((void *)v7 - 1);
      v7 -= 8;
      *((void *)v15 - 1) = v18;
      v15 -= 8;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

void std::vector<BOOL>::resize(uint64_t a1, unint64_t a2, int a3)
{
  unint64_t v5 = *(void *)(a1 + 8);
  unint64_t v6 = a2 - v5;
  if (a2 <= v5)
  {
    *(void *)(a1 + 8) = a2;
  }
  else
  {
    uint64_t v8 = *(void *)(a1 + 16);
    unint64_t v9 = v8 << 6;
    if (v8 << 6 < v6 || v5 > (v8 << 6) - v6)
    {
      uint64_t v21 = 0;
      long long v22 = 0uLL;
      if ((a2 & 0x8000000000000000) != 0) {
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v11 = v8 << 7;
      if (v11 <= ((a2 + 63) & 0xFFFFFFFFFFFFFFC0)) {
        unint64_t v11 = (a2 + 63) & 0xFFFFFFFFFFFFFFC0;
      }
      if (v9 <= 0x3FFFFFFFFFFFFFFELL) {
        unint64_t v12 = v11;
      }
      else {
        unint64_t v12 = 0x7FFFFFFFFFFFFFFFLL;
      }
      std::vector<BOOL>::reserve(&v21, v12);
      unint64_t v13 = *(unint64_t **)a1;
      unint64_t v14 = *(void *)(a1 + 8);
      *(void *)&long long v22 = v14 + v6;
      unint64_t v23 = v21;
      int v24 = 0;
      std::__copy_aligned[abi:ne180100]<std::vector<BOOL>,true>(v13, 0, (uint64_t)&v13[v14 >> 6], v14 & 0x3F, (uint64_t)&v23, (uint64_t)&v19);
      uint64_t v17 = v19;
      LODWORD(v18) = v20;
      uint64_t v15 = *(char **)a1;
      *(void *)a1 = v21;
      uint64_t v21 = v15;
      long long v16 = *(_OWORD *)(a1 + 8);
      *(_OWORD *)(a1 + 8) = v22;
      long long v22 = v16;
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      uint64_t v17 = (char *)(*(void *)a1 + 8 * (v5 >> 6));
      uint64_t v18 = *(void *)(a1 + 8) & 0x3FLL;
      *(void *)(a1 + 8) = a2;
    }
    if (a2 != v5)
    {
      if (a3)
      {
        uint64_t v21 = v17;
        LODWORD(v22) = v18;
        std::__fill_n[abi:ne180100]<true,std::vector<BOOL>>(&v21, v6);
      }
      else
      {
        uint64_t v21 = v17;
        LODWORD(v22) = v18;
        std::__fill_n[abi:ne180100]<false,std::vector<BOOL>>((uint64_t)&v21, v6);
      }
    }
  }
}

void sub_20F492314(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<BOOL>::reserve(char **a1, unint64_t a2)
{
  if (a2 > (void)a1[2] << 6)
  {
    if ((a2 & 0x8000000000000000) != 0) {
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0;
    long long v11 = 0uLL;
    std::vector<BOOL>::__vallocate[abi:ne180100](&v10, a2);
    unint64_t v3 = (unint64_t)a1[1];
    uint64_t v8 = *a1;
    int v9 = 0;
    unint64_t v6 = &v8[8 * (v3 >> 6)];
    int v7 = v3 & 0x3F;
    std::vector<BOOL>::__construct_at_end<std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>>(&v10, (uint64_t)&v8, (uint64_t)&v6, v3);
    uint64_t v4 = *a1;
    *a1 = v10;
    unint64_t v10 = v4;
    long long v5 = *(_OWORD *)(a1 + 1);
    *(_OWORD *)(a1 + 1) = v11;
    long long v11 = v5;
    if (v4) {
      operator delete(v4);
    }
  }
}

void sub_20F4923D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<BOOL>::__construct_at_end<std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>>(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = a1[1];
  unint64_t v5 = v4 + a4;
  a1[1] = v4 + a4;
  if (!v4 || ((v5 - 1) ^ (v4 - 1)) >= 0x40)
  {
    if (v5 >= 0x41) {
      unint64_t v6 = (v5 - 1) >> 6;
    }
    else {
      unint64_t v6 = 0;
    }
    *(void *)(*a1 + 8 * v6) = 0;
  }
  int v7 = *(_DWORD *)(a2 + 8);
  uint64_t v8 = *(void *)a3;
  int v9 = *(_DWORD *)(a3 + 8);
  uint64_t v10 = *a1 + 8 * (v4 >> 6);
  uint64_t v16 = *(void *)a2;
  int v17 = v7;
  uint64_t v14 = v8;
  int v15 = v9;
  uint64_t v12 = v10;
  int v13 = v4 & 0x3F;
  std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>,0>(&v16, &v14, &v12, (uint64_t)&v11);
}

void std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>,0>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  int v5 = *((_DWORD *)a1 + 2);
  uint64_t v6 = *a2;
  int v7 = *((_DWORD *)a2 + 2);
  uint64_t v16 = *a1;
  int v17 = v5;
  uint64_t v14 = v6;
  int v15 = v7;
  int v8 = *((_DWORD *)a3 + 2);
  uint64_t v12 = *a3;
  int v13 = v8;
  std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>>((uint64_t)&v16, (uint64_t)&v14, (uint64_t)&v12, (uint64_t)&v18);
  int v9 = v19;
  uint64_t v10 = v20;
  int v11 = v21;
  *(void *)a4 = v18;
  *(_DWORD *)(a4 + 8) = v9;
  *(void *)(a4 + 16) = v10;
  *(_DWORD *)(a4 + 24) = v11;
}

void std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  unint64_t v4 = *(void **)a1;
  int v5 = *(_DWORD *)(a1 + 8);
  for (i = *(_DWORD *)(a3 + 8); *(void *)a1 != *(void *)a2 || v5 != *(_DWORD *)(a2 + 8); int v5 = *(_DWORD *)(a1 + 8))
  {
    int v8 = *(uint64_t **)a3;
    uint64_t v9 = 1 << i;
    if ((*v4 >> v5)) {
      uint64_t v10 = *v8 | v9;
    }
    else {
      uint64_t v10 = *v8 & ~v9;
    }
    *int v8 = v10;
    if (v5 == 63)
    {
      int v11 = 0;
      *(void *)a1 = v4 + 1;
    }
    else
    {
      int v11 = v5 + 1;
    }
    *(_DWORD *)(a1 + 8) = v11;
    int v12 = *(_DWORD *)(a3 + 8);
    if (v12 == 63)
    {
      int i = 0;
      *(void *)a3 += 8;
    }
    else
    {
      int i = v12 + 1;
    }
    *(_DWORD *)(a3 + 8) = i;
    unint64_t v4 = *(void **)a1;
  }
  *(void *)a4 = v4;
  *(_DWORD *)(a4 + 8) = v5;
  *(void *)(a4 + 16) = *(void *)a3;
  *(_DWORD *)(a4 + 24) = i;
}

unint64_t *std::__copy_aligned[abi:ne180100]<std::vector<BOOL>,true>@<X0>(unint64_t *__src@<X0>, unsigned int a2@<W1>, uint64_t a3@<X2>, unsigned int a4@<W3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  int64_t v8 = a4 - (unint64_t)a2 + 8 * (a3 - (void)__src);
  if (v8 <= 0)
  {
    uint64_t v16 = *(unint64_t **)a5;
  }
  else
  {
    uint64_t v9 = __src;
    uint64_t __src = *(unint64_t **)a5;
    if (a2)
    {
      if (v8 >= (unint64_t)(64 - a2)) {
        int64_t v10 = 64 - a2;
      }
      else {
        int64_t v10 = v8;
      }
      v8 -= v10;
      uint64_t v11 = *v9++;
      *uint64_t __src = *__src & ~((0xFFFFFFFFFFFFFFFFLL >> (64 - a2 - v10)) & (-1 << a2)) | v11 & (0xFFFFFFFFFFFFFFFFLL >> (64 - a2 - v10)) & (-1 << a2);
      unint64_t v12 = v10 + *(unsigned int *)(a5 + 8);
      uint64_t __src = (unint64_t *)((char *)__src + ((v12 >> 3) & 0x3FFFFFF8));
      *(void *)a5 = __src;
      *(_DWORD *)(a5 + 8) = v12 & 0x3F;
    }
    if (v8 >= 0) {
      uint64_t v13 = v8;
    }
    else {
      uint64_t v13 = v8 + 63;
    }
    uint64_t v14 = v13 >> 6;
    if ((unint64_t)(v8 + 63) >= 0x7F)
    {
      memmove(__src, v9, 8 * v14);
      uint64_t __src = *(unint64_t **)a5;
    }
    uint64_t v15 = v8 - (v14 << 6);
    uint64_t v16 = &__src[v14];
    *(void *)a5 = v16;
    if (v15 >= 1)
    {
      unint64_t *v16 = *v16 & ~(0xFFFFFFFFFFFFFFFFLL >> (((_BYTE)v14 << 6) - v8)) | v9[v14] & (0xFFFFFFFFFFFFFFFFLL >> (((_BYTE)v14 << 6) - v8));
      *(_DWORD *)(a5 + 8) = v15;
    }
  }
  *(void *)a6 = v16;
  *(_DWORD *)(a6 + 8) = *(_DWORD *)(a5 + 8);
  return __src;
}

void MIL::Transform::ProgramTransformer::ProgramTransformerImpl::AddMatchedDependencies(MIL::BuilderPrivate::OperationBuilderPrivate *a1, const MIL::Builder::OperationBuilder *a2, uint64_t *a3, uint64_t a4, MIL::Transform::_anonymous_namespace_::IndexSet *a5)
{
  Parameters = (void *)MIL::BuilderPrivate::OperationBuilderPrivate::GetParameters(a1, a2);
  uint64_t v6 = (void *)*Parameters;
  int v21 = Parameters + 1;
  if ((void *)*Parameters != Parameters + 1)
  {
    do
    {
      uint64_t v8 = v6[7];
      uint64_t v7 = v6[8];
      while (v8 != v7)
      {
        uint64_t v9 = (*(uint64_t (**)(void))(**(void **)v8 + 32))();
        if (v9)
        {
          int64_t v10 = (const void **)v9;
          uint64_t v12 = *a3;
          uint64_t v11 = a3[1];
          if (v11 == *a3) {
            goto LABEL_15;
          }
          unint64_t v13 = (v11 - *a3) >> 4;
          do
          {
            uint64_t v14 = v12 + 16 * (v13 >> 1);
            int v15 = std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string>((uint64_t)&v26, v14, v10);
            if (v15) {
              v13 += ~(v13 >> 1);
            }
            else {
              v13 >>= 1;
            }
            if (v15) {
              uint64_t v12 = v14 + 16;
            }
          }
          while (v13);
          if (v12 == v11
            || std::__less<void,void>::operator()[abi:ne180100]<std::string,std::string_view>((uint64_t)&v26, v10, v12))
          {
LABEL_15:
            MIL::Builder::BlockBuilder::TryGetOperation(a4, (unsigned __int8 *)v10, &v26);
            if (v26)
            {
              uint64_t v16 = (void *)*((void *)a2 + 1);
              int v17 = *(void **)a2;
              if (*(void **)a2 != v16)
              {
                while (*v17 != v26)
                {
                  if (++v17 == v16)
                  {
                    int v17 = (void *)*((void *)a2 + 1);
                    break;
                  }
                }
              }
              if (v17 != v16) {
            }
              }
            if (v27) {
              std::__shared_weak_count::__release_shared[abi:ne180100](v27);
            }
          }
        }
        v8 += 16;
      }
      uint64_t v18 = (void *)v6[1];
      if (v18)
      {
        do
        {
          int v19 = v18;
          uint64_t v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          int v19 = (void *)v6[2];
          BOOL v20 = *v19 == (void)v6;
          uint64_t v6 = v19;
        }
        while (!v20);
      }
      uint64_t v6 = v19;
    }
    while (v19 != v21);
  }
}

void sub_20F49290C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a16);
  }
  _Unwind_Resume(exception_object);
}

BOOL MIL::Transform::anonymous namespace'::IndexSet::Add(MIL::Transform::_anonymous_namespace_::IndexSet *this, uint64_t a2)
{
  unint64_t v3 = (void *)((char *)this + 8);
  unint64_t v4 = a2 - *(void *)this;
  if (*((void *)this + 2) <= v4) {
    std::vector<MIL::IRDimension const*>::__throw_out_of_range[abi:ne180100]();
  }
  uint64_t v5 = *(void *)(*v3 + ((v4 >> 3) & 0x1FFFFFFFFFFFFFF8)) & (1 << v4);
  if (!v5)
  {
    unint64_t v7 = *((void *)this + 6);
    uint64_t v8 = (char *)*((void *)this + 5);
    if ((unint64_t)v8 >= v7)
    {
      int64_t v10 = (char *)*((void *)this + 4);
      uint64_t v11 = (v8 - v10) >> 3;
      if ((unint64_t)(v11 + 1) >> 61) {
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v12 = v7 - (void)v10;
      unint64_t v13 = (uint64_t)(v7 - (void)v10) >> 2;
      if (v13 <= v11 + 1) {
        unint64_t v13 = v11 + 1;
      }
      if (v12 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v13;
      }
      if (v14)
      {
        int v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)this + 48, v14);
        int64_t v10 = (char *)*((void *)this + 4);
        uint64_t v8 = (char *)*((void *)this + 5);
      }
      else
      {
        int v15 = 0;
      }
      uint64_t v16 = &v15[8 * v11];
      int v17 = &v15[8 * v14];
      *(void *)uint64_t v16 = a2;
      uint64_t v9 = v16 + 8;
      while (v8 != v10)
      {
        uint64_t v18 = *((void *)v8 - 1);
        v8 -= 8;
        *((void *)v16 - 1) = v18;
        v16 -= 8;
      }
      *((void *)this + 4) = v16;
      *((void *)this + 5) = v9;
      *((void *)this + 6) = v17;
      if (v10) {
        operator delete(v10);
      }
    }
    else
    {
      *(void *)uint64_t v8 = a2;
      uint64_t v9 = v8 + 8;
    }
    *((void *)this + 5) = v9;
    *(void *)(*((void *)this + 1) + (((unint64_t)(a2 - *(void *)this) >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << (a2 - *(unsigned char *)this);
  }
  return v5 == 0;
}

uint64_t std::__less<void,void>::operator()[abi:ne180100]<std::string,std::string_view>(uint64_t a1, const void **a2, uint64_t a3)
{
  int v3 = *((char *)a2 + 23);
  if (v3 >= 0) {
    unint64_t v4 = a2;
  }
  else {
    unint64_t v4 = *a2;
  }
  if (v3 >= 0) {
    size_t v5 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v5 = (size_t)a2[1];
  }
  uint64_t v6 = *(const void **)a3;
  size_t v7 = *(void *)(a3 + 8);
  if (v7 >= v5) {
    size_t v8 = v5;
  }
  else {
    size_t v8 = *(void *)(a3 + 8);
  }
  int v9 = memcmp(v4, v6, v8);
  if (v5 < v7) {
    unsigned int v10 = -1;
  }
  else {
    unsigned int v10 = 1;
  }
  if (v5 == v7) {
    unsigned int v10 = 0;
  }
  if (v9) {
    unsigned int v10 = v9;
  }
  return v10 >> 31;
}

uint64_t std::__less<void,void>::operator()[abi:ne180100]<std::string_view,std::string>(uint64_t a1, uint64_t a2, const void **a3)
{
  int v3 = *(const void **)a2;
  size_t v4 = *(void *)(a2 + 8);
  int v5 = *((char *)a3 + 23);
  if (v5 >= 0) {
    uint64_t v6 = a3;
  }
  else {
    uint64_t v6 = *a3;
  }
  if (v5 >= 0) {
    size_t v7 = *((unsigned __int8 *)a3 + 23);
  }
  else {
    size_t v7 = (size_t)a3[1];
  }
  if (v7 >= v4) {
    size_t v8 = v4;
  }
  else {
    size_t v8 = v7;
  }
  int v9 = memcmp(v3, v6, v8);
  if (v4 < v7) {
    unsigned int v10 = -1;
  }
  else {
    unsigned int v10 = 1;
  }
  if (v4 == v7) {
    unsigned int v10 = 0;
  }
  if (v9) {
    unsigned int v10 = v9;
  }
  return v10 >> 31;
}

void std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,anonymous namespace'::OldOutput *,false>(unint64_t a1, long long *a2, uint64_t a3, char a4)
{
long long *std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,anonymous namespace'::OldOutput *>(long long *result, unint64_t *a2, long long *a3)
{
  unint64_t v3 = *a2;
  if (*a2 >= *(void *)result && (*(void *)result < v3 || a2[1] >= *((void *)result + 1)))
  {
    if (*(void *)a3 < v3 || v3 >= *(void *)a3 && *((void *)a3 + 1) < a2[1])
    {
      long long v5 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *a3;
      *a3 = v5;
      if (*a2 < *(void *)result || *(void *)result >= *a2 && a2[1] < *((void *)result + 1))
      {
        long long v6 = *result;
        std::string *result = *(_OWORD *)a2;
        *(_OWORD *)a2 = v6;
      }
    }
  }
  else
  {
    if (*(void *)a3 < v3 || v3 >= *(void *)a3 && *((void *)a3 + 1) < a2[1])
    {
      long long v4 = *result;
      std::string *result = *a3;
LABEL_17:
      *a3 = v4;
      return result;
    }
    long long v7 = *result;
    std::string *result = *(_OWORD *)a2;
    *(_OWORD *)a2 = v7;
    if (*(void *)a3 < *a2 || *a2 >= *(void *)a3 && *((void *)a3 + 1) < a2[1])
    {
      long long v4 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *a3;
      goto LABEL_17;
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,anonymous namespace'::OldOutput *>(uint64_t a1, long long *a2)
{
  uint64_t v4 = ((uint64_t)a2 - a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      long long v6 = a2 - 1;
      unint64_t v7 = *((void *)a2 - 2);
      if (v7 < *(void *)a1 || *(void *)a1 >= v7 && *((void *)a2 - 1) < *(void *)(a1 + 8))
      {
        long long v8 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *v6;
        *long long v6 = v8;
      }
      return result;
    case 3:
      return 1;
    case 4:
      return 1;
    case 5:
      uint64_t v19 = (long long *)(a1 + 16);
      unint64_t v20 = (long long *)(a1 + 32);
      unint64_t v21 = (long long *)(a1 + 48);
      unint64_t v22 = a2 - 1;
      unint64_t v23 = *((void *)a2 - 2);
      unint64_t v24 = *(void *)(a1 + 48);
      if (v23 < v24 || v24 >= v23 && *((void *)a2 - 1) < *(void *)(a1 + 56))
      {
        long long v25 = *v21;
        long long *v21 = *v22;
        *unint64_t v22 = v25;
        unint64_t v26 = *(void *)(a1 + 48);
        unint64_t v27 = *(void *)(a1 + 32);
        if (v26 < v27 || v27 >= v26 && *(void *)(a1 + 56) < *(void *)(a1 + 40))
        {
          long long v28 = *v20;
          *unint64_t v20 = *v21;
          long long *v21 = v28;
          unint64_t v29 = *(void *)(a1 + 32);
          unint64_t v30 = *(void *)(a1 + 16);
          if (v29 < v30 || v30 >= v29 && *(void *)(a1 + 40) < *(void *)(a1 + 24))
          {
            long long v31 = *v19;
            long long *v19 = *v20;
            *unint64_t v20 = v31;
            unint64_t v32 = *(void *)(a1 + 16);
            if (v32 < *(void *)a1 || *(void *)a1 >= v32 && *(void *)(a1 + 24) < *(void *)(a1 + 8))
            {
              long long v33 = *(_OWORD *)a1;
              *(_OWORD *)a1 = *v19;
              long long *v19 = v33;
            }
          }
        }
      }
      return 1;
    default:
      int v9 = (long long *)(a1 + 32);
      unsigned int v10 = (long long *)(a1 + 48);
      if ((long long *)(a1 + 48) == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  while (1)
  {
    unint64_t v13 = *(void *)v10;
    if (*(void *)v10 < *(void *)v9) {
      break;
    }
    if (*(void *)v9 >= v13)
    {
      unint64_t v14 = *((void *)v10 + 1);
      if (v14 < *((void *)v9 + 1)) {
        goto LABEL_10;
      }
    }
LABEL_20:
    int v9 = v10;
    v11 += 16;
    if (++v10 == a2) {
      return 1;
    }
  }
  unint64_t v14 = *((void *)v10 + 1);
LABEL_10:
  *unsigned int v10 = *v9;
  int v15 = (void *)a1;
  if (v9 != (long long *)a1)
  {
    uint64_t v16 = v11;
    while (1)
    {
      uint64_t v17 = a1 + v16;
      unint64_t v18 = *(void *)(a1 + v16 + 16);
      if (v13 >= v18)
      {
        if (v18 < v13)
        {
          int v15 = v9;
          goto LABEL_19;
        }
        if (v14 >= *(void *)(v17 + 24)) {
          break;
        }
      }
      --v9;
      *(_OWORD *)(v17 + 32) = *(_OWORD *)(a1 + v16 + 16);
      v16 -= 16;
      if (v16 == -32)
      {
        int v15 = (void *)a1;
        goto LABEL_19;
      }
    }
    int v15 = (void *)(a1 + v16 + 32);
  }
LABEL_19:
  void *v15 = v13;
  v15[1] = v14;
  if (++v12 != 8) {
    goto LABEL_20;
  }
  return v10 + 1 == a2;
}

__n128 std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,anonymous namespace'::OldOutput *>(uint64_t a1, unint64_t *a2, uint64_t a3, uint64_t a4)
{
  if (*(void *)a4 < *(void *)a3 || *(void *)a3 >= *(void *)a4 && *(void *)(a4 + 8) < *(void *)(a3 + 8))
  {
    __n128 result = *(__n128 *)a3;
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(__n128 *)a4 = result;
    if (*(void *)a3 < *a2 || *a2 >= *(void *)a3 && *(void *)(a3 + 8) < a2[1])
    {
      __n128 result = *(__n128 *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(__n128 *)a3 = result;
      if (*a2 < *(void *)a1 || *(void *)a1 >= *a2 && a2[1] < *(void *)(a1 + 8))
      {
        __n128 result = *(__n128 *)a1;
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(__n128 *)a2 = result;
      }
    }
  }
  return result;
}

uint64_t MIL::Transform::anonymous namespace'::IndexSet::Contains(MIL::Transform::_anonymous_namespace_::IndexSet *this, uint64_t a2)
{
  unint64_t v3 = (void *)((char *)this + 8);
  unint64_t v4 = a2 - *(void *)this;
  if (*((void *)this + 2) <= v4) {
    std::vector<MIL::IRDimension const*>::__throw_out_of_range[abi:ne180100]();
  }
  return (*(void *)(*v3 + ((v4 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v4) & 1;
}

uint64_t MIL::Transform::ProgramTransformer::ProgramTransformerImpl::GetMatchedOperationIndex(uint64_t a1, void *a2, uint64_t a3)
{
  unint64_t v3 = *(void **)(a3 + 8);
  unint64_t v4 = *(void **)a3;
  if (*(void **)a3 != v3)
  {
    while (*v4 != a1)
    {
      if (++v4 == v3)
      {
        unint64_t v4 = *(void **)(a3 + 8);
        break;
      }
    }
  }
  if (v4 == v3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Operation not found in list of matched ops");
    __cxa_throw(exception, MEMORY[0x263F8C1E0], MEMORY[0x263F8C048]);
  }
  unint64_t v5 = ((uint64_t)v4 - *(void *)a3) >> 3;
  if (v5 >= (uint64_t)(a2[1] - *a2) >> 3) {
    std::vector<MIL::IRDimension const*>::__throw_out_of_range[abi:ne180100]();
  }
  return *(void *)(*a2 + 8 * v5);
}

void sub_20F493BA0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *,false>(unint64_t *a1, unint64_t *a2, uint64_t a3, uint64_t a4, char a5)
{
unint64_t *std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *>(unint64_t *result, unint64_t *a2)
{
  if (result != a2)
  {
    unint64_t v2 = result + 2;
    if (result + 2 != a2)
    {
      uint64_t v3 = 0;
      unint64_t v4 = result;
      while (1)
      {
        char v5 = v4;
        unint64_t v4 = v2;
        unint64_t v6 = v5[2];
        if (v6 < *v5) {
          break;
        }
        if (*v5 >= v6)
        {
          unint64_t v7 = v5[3];
          if (v7 < v5[1]) {
            goto LABEL_6;
          }
        }
LABEL_19:
        unint64_t v2 = v4 + 2;
        v3 += 16;
        if (v4 + 2 == a2) {
          return result;
        }
      }
      unint64_t v7 = v5[3];
LABEL_6:
      *(_OWORD *)unint64_t v4 = *(_OWORD *)v5;
      long long v8 = result;
      if (v5 != result)
      {
        uint64_t v9 = v3;
        while (1)
        {
          unsigned int v10 = (_OWORD *)((char *)result + v9);
          unint64_t v11 = *(unint64_t *)((char *)result + v9 - 16);
          if (v6 >= v11)
          {
            if (v11 < v6)
            {
              long long v8 = v5;
              goto LABEL_18;
            }
            if (v7 >= *((void *)v10 - 1)) {
              break;
            }
          }
          v5 -= 2;
          *unsigned int v10 = *(_OWORD *)((char *)result + v9 - 16);
          v9 -= 16;
          if (!v9)
          {
            long long v8 = result;
            goto LABEL_18;
          }
        }
        long long v8 = (unint64_t *)((char *)result + v9);
      }
LABEL_18:
      *long long v8 = v6;
      v8[1] = v7;
      goto LABEL_19;
    }
  }
  return result;
}

unint64_t *std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *>(unint64_t *result, unint64_t *a2)
{
  if (result != a2)
  {
    while (1)
    {
      if (result + 2 == a2) {
        return result;
      }
      unint64_t v2 = result;
      result += 2;
      unint64_t v3 = v2[2];
      if (v3 >= *v2)
      {
        if (*v2 >= v3)
        {
          unint64_t v4 = v2[3];
          if (v4 < v2[1]) {
            goto LABEL_7;
          }
        }
      }
      else
      {
        unint64_t v4 = v2[3];
        do
        {
          do
          {
LABEL_7:
            char v5 = v2;
            *((_OWORD *)v2 + 1) = *(_OWORD *)v2;
            unint64_t v7 = *(v2 - 2);
            v2 -= 2;
            unint64_t v6 = v7;
          }
          while (v3 < v7);
        }
        while (v6 >= v3 && v4 < *(v5 - 1));
        *char v5 = v3;
        v5[1] = v4;
      }
    }
  }
  return result;
}

uint64_t std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *>(long long *a1, unint64_t *a2, long long *a3)
{
  unint64_t v3 = *a2;
  if (*a2 < *(void *)a1 || *(void *)a1 >= v3 && a2[1] < *((void *)a1 + 1))
  {
    if (*(void *)a3 < v3 || v3 >= *(void *)a3 && *((void *)a3 + 1) < a2[1])
    {
      long long v4 = *a1;
      *a1 = *a3;
      *a3 = v4;
    }
    else
    {
      long long v8 = *a1;
      *a1 = *(_OWORD *)a2;
      *(_OWORD *)a2 = v8;
      if (*(void *)a3 < *a2 || *a2 >= *(void *)a3 && *((void *)a3 + 1) < a2[1])
      {
        long long v9 = *(_OWORD *)a2;
        *(_OWORD *)a2 = *a3;
        *a3 = v9;
        return 2;
      }
    }
    return 1;
  }
  if (*(void *)a3 < v3 || v3 >= *(void *)a3 && *((void *)a3 + 1) < a2[1])
  {
    long long v6 = *(_OWORD *)a2;
    *(_OWORD *)a2 = *a3;
    *a3 = v6;
    if (*a2 < *(void *)a1 || *(void *)a1 >= *a2 && a2[1] < *((void *)a1 + 1))
    {
      long long v7 = *a1;
      *a1 = *(_OWORD *)a2;
      *(_OWORD *)a2 = v7;
      return 2;
    }
    return 1;
  }
  return 0;
}

unint64_t *std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *,std::__less<void,void> &>(unint64_t *a1, unint64_t a2)
{
  unint64_t v2 = *a1;
  unint64_t v3 = a1[1];
  unint64_t v4 = *(void *)(a2 - 16);
  if (*a1 >= v4 && (v4 < v2 || v3 >= *(void *)(a2 - 8)))
  {
    for (int i = a1 + 2; (unint64_t)i < a2 && v2 >= *i && (*i < v2 || v3 >= i[1]); i += 2)
      ;
  }
  else
  {
    int i = a1;
    do
    {
      unint64_t v7 = i[2];
      i += 2;
      unint64_t v6 = v7;
    }
    while (v2 >= v7 && (v6 < v2 || v3 >= i[1]));
  }
  if ((unint64_t)i < a2)
  {
    for (a2 -= 16; v2 < v4 || v4 >= v2 && v3 < *(void *)(a2 + 8); a2 -= 16)
    {
      unint64_t v8 = *(void *)(a2 - 16);
      unint64_t v4 = v8;
    }
  }
  while ((unint64_t)i < a2)
  {
    long long v14 = *(_OWORD *)i;
    *(_OWORD *)int i = *(_OWORD *)a2;
    *(_OWORD *)a2 = v14;
    do
    {
      unint64_t v10 = i[2];
      i += 2;
      unint64_t v9 = v10;
    }
    while (v2 >= v10 && (v9 < v2 || v3 >= i[1]));
    do
    {
      do
      {
        unint64_t v12 = *(void *)(a2 - 16);
        a2 -= 16;
        unint64_t v11 = v12;
      }
      while (v2 < v12);
    }
    while (v11 >= v2 && v3 < *(void *)(a2 + 8));
  }
  if (i - 2 != a1) {
    *(_OWORD *)a1 = *((_OWORD *)i - 1);
  }
  *(i - 2) = v2;
  *(i - 1) = v3;
  return i;
}

unint64_t std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *,std::__less<void,void> &>(unint64_t *a1, unint64_t a2)
{
  uint64_t v2 = 0;
  unint64_t v3 = *a1;
  unint64_t v4 = a1[1];
  while (1)
  {
    unint64_t v5 = a1[v2 + 2];
    if (v5 >= v3 && (v3 < v5 || a1[v2 + 3] >= v4)) {
      break;
    }
    v2 += 2;
  }
  unint64_t v6 = (unint64_t)&a1[v2 + 2];
  if (v2 * 8)
  {
    do
    {
      unint64_t v8 = *(void *)(a2 - 16);
      a2 -= 16;
      unint64_t v7 = v8;
    }
    while (v8 >= v3 && (v3 < v7 || *(void *)(a2 + 8) >= v4));
  }
  else
  {
LABEL_19:
    if (v6 < a2)
    {
      do
      {
        unint64_t v10 = *(void *)(a2 - 16);
        a2 -= 16;
        unint64_t v9 = v10;
        if (v10 < v3) {
          break;
        }
        if (v3 < v9) {
          goto LABEL_19;
        }
      }
      while (*(void *)(a2 + 8) >= v4 && v6 < a2);
    }
  }
  unint64_t v12 = v6;
  if (v6 < a2)
  {
    unint64_t v13 = a2;
    do
    {
      long long v19 = *(_OWORD *)v12;
      *(_OWORD *)unint64_t v12 = *(_OWORD *)v13;
      *(_OWORD *)unint64_t v13 = v19;
      do
      {
        do
        {
          unint64_t v15 = *(void *)(v12 + 16);
          v12 += 16;
          unint64_t v14 = v15;
        }
        while (v15 < v3);
      }
      while (v3 >= v14 && *(void *)(v12 + 8) < v4);
      do
      {
        unint64_t v17 = *(void *)(v13 - 16);
        v13 -= 16;
        unint64_t v16 = v17;
      }
      while (v17 >= v3 && (v3 < v16 || *(void *)(v13 + 8) >= v4));
    }
    while (v12 < v13);
  }
  if ((unint64_t *)(v12 - 16) != a1) {
    *(_OWORD *)a1 = *(_OWORD *)(v12 - 16);
  }
  *(void *)(v12 - 16) = v3;
  *(void *)(v12 - 8) = v4;
  return v12 - 16;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *>(uint64_t a1, long long *a2)
{
  uint64_t v4 = ((uint64_t)a2 - a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      unint64_t v6 = a2 - 1;
      unint64_t v7 = *((void *)a2 - 2);
      if (v7 < *(void *)a1 || *(void *)a1 >= v7 && *((void *)a2 - 1) < *(void *)(a1 + 8))
      {
        long long v8 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *v6;
        *unint64_t v6 = v8;
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *>((long long *)a1, (unint64_t *)(a1 + 16), a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *>(a1, (unint64_t *)(a1 + 16), a1 + 32, (uint64_t)(a2 - 1));
      return 1;
    case 5:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *>((__n128 *)a1, (unint64_t *)(a1 + 16), (__n128 *)(a1 + 32), (__n128 *)(a1 + 48), (__n128 *)a2 - 1);
      return 1;
    default:
      unint64_t v9 = (long long *)(a1 + 32);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *>((long long *)a1, (unint64_t *)(a1 + 16), (long long *)(a1 + 32));
      unint64_t v10 = (long long *)(a1 + 48);
      if ((long long *)(a1 + 48) == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  while (1)
  {
    unint64_t v13 = *(void *)v10;
    if (*(void *)v10 < *(void *)v9) {
      break;
    }
    if (*(void *)v9 >= v13)
    {
      unint64_t v14 = *((void *)v10 + 1);
      if (v14 < *((void *)v9 + 1)) {
        goto LABEL_12;
      }
    }
LABEL_22:
    unint64_t v9 = v10;
    v11 += 16;
    if (++v10 == a2) {
      return 1;
    }
  }
  unint64_t v14 = *((void *)v10 + 1);
LABEL_12:
  *unint64_t v10 = *v9;
  unint64_t v15 = (void *)a1;
  if (v9 != (long long *)a1)
  {
    uint64_t v16 = v11;
    while (1)
    {
      uint64_t v17 = a1 + v16;
      unint64_t v18 = *(void *)(a1 + v16 + 16);
      if (v13 >= v18)
      {
        if (v18 < v13)
        {
          unint64_t v15 = v9;
          goto LABEL_21;
        }
        if (v14 >= *(void *)(v17 + 24)) {
          break;
        }
      }
      --v9;
      *(_OWORD *)(v17 + 32) = *(_OWORD *)(a1 + v16 + 16);
      v16 -= 16;
      if (v16 == -32)
      {
        unint64_t v15 = (void *)a1;
        goto LABEL_21;
      }
    }
    unint64_t v15 = (void *)(a1 + v16 + 32);
  }
LABEL_21:
  void *v15 = v13;
  v15[1] = v14;
  if (++v12 != 8) {
    goto LABEL_22;
  }
  return v10 + 1 == a2;
}

__n128 std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *>(uint64_t a1, unint64_t *a2, uint64_t a3, uint64_t a4)
{
  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *>((long long *)a1, a2, (long long *)a3);
  if (*(void *)a4 < *(void *)a3 || *(void *)a3 >= *(void *)a4 && *(void *)(a4 + 8) < *(void *)(a3 + 8))
  {
    __n128 result = *(__n128 *)a3;
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(__n128 *)a4 = result;
    if (*(void *)a3 < *a2 || *a2 >= *(void *)a3 && *(void *)(a3 + 8) < a2[1])
    {
      __n128 result = *(__n128 *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(__n128 *)a3 = result;
      if (*a2 < *(void *)a1 || *(void *)a1 >= *a2 && a2[1] < *(void *)(a1 + 8))
      {
        __n128 result = *(__n128 *)a1;
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(__n128 *)a2 = result;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *>(__n128 *a1, unint64_t *a2, __n128 *a3, __n128 *a4, __n128 *a5)
{
  result.n128_u64[0] = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *>((uint64_t)a1, a2, (uint64_t)a3, (uint64_t)a4).n128_u64[0];
  if (a5->n128_u64[0] < a4->n128_u64[0] || a4->n128_u64[0] >= a5->n128_u64[0] && a5->n128_u64[1] < a4->n128_u64[1])
  {
    __n128 result = *a4;
    *a4 = *a5;
    *a5 = result;
    if (a4->n128_u64[0] < a3->n128_u64[0] || a3->n128_u64[0] >= a4->n128_u64[0] && a4->n128_u64[1] < a3->n128_u64[1])
    {
      __n128 result = *a3;
      *a3 = *a4;
      *a4 = result;
      if (a3->n128_u64[0] < *a2 || *a2 >= a3->n128_u64[0] && a3->n128_u64[1] < a2[1])
      {
        __n128 result = *(__n128 *)a2;
        *(__n128 *)a2 = *a3;
        *a3 = result;
        if (*a2 < a1->n128_u64[0] || a1->n128_u64[0] >= *a2 && a2[1] < a1->n128_u64[1])
        {
          __n128 result = *a1;
          *a1 = *(__n128 *)a2;
          *(__n128 *)a2 = result;
        }
      }
    }
  }
  return result;
}

unint64_t *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *>(unint64_t *a1, unint64_t *a2, unint64_t *a3, uint64_t a4)
{
  if (a1 != a2)
  {
    uint64_t v8 = (char *)a2 - (char *)a1;
    uint64_t v9 = ((char *)a2 - (char *)a1) >> 4;
    if ((char *)a2 - (char *)a1 >= 17)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      int v12 = &a1[2 * v10];
      do
      {
        std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *>((uint64_t)a1, a4, v9, v12);
        v12 -= 2;
        --v11;
      }
      while (v11);
    }
    unint64_t v13 = a2;
    if (a2 != a3)
    {
      unint64_t v14 = a2;
      do
      {
        if (*v14 < *a1 || *a1 >= *v14 && v14[1] < a1[1])
        {
          long long v15 = *(_OWORD *)v14;
          *(_OWORD *)unint64_t v14 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v15;
          std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *>((uint64_t)a1, a4, v9, a1);
        }
        v14 += 2;
      }
      while (v14 != a3);
      unint64_t v13 = a3;
    }
    if (v8 >= 17)
    {
      uint64_t v16 = (unint64_t)v8 >> 4;
      uint64_t v17 = a2 - 2;
      do
      {
        long long v21 = *(_OWORD *)a1;
        std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *>(a1, a4, v16);
        if (v17 == v18)
        {
          *(_OWORD *)unint64_t v18 = v21;
        }
        else
        {
          *(_OWORD *)unint64_t v18 = *(_OWORD *)v17;
          *(_OWORD *)uint64_t v17 = v21;
          std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *>((uint64_t)a1, (uint64_t)(v18 + 2), a4, ((char *)(v18 + 2) - (char *)a1) >> 4);
        }
        v17 -= 2;
      }
      while (v16-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *>(uint64_t result, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  if (a3 >= 2)
  {
    uint64_t v4 = (uint64_t)a4 - result;
    int64_t v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 4)
    {
      uint64_t v6 = v4 >> 3;
      uint64_t v7 = (v4 >> 3) + 1;
      uint64_t v8 = (unint64_t *)(result + 16 * v7);
      uint64_t v9 = v6 + 2;
      if (v9 < a3)
      {
        unint64_t v10 = v8[2];
        if (*v8 < v10 || v10 >= *v8 && v8[1] < v8[3])
        {
          v8 += 2;
          uint64_t v7 = v9;
        }
      }
      unint64_t v11 = *a4;
      if (*v8 >= *a4)
      {
        unint64_t v12 = a4[1];
        if (v11 < *v8 || v8[1] >= v12)
        {
          *(_OWORD *)a4 = *(_OWORD *)v8;
          if (v5 >= v7)
          {
            while (1)
            {
              uint64_t v14 = 2 * v7;
              uint64_t v7 = (2 * v7) | 1;
              unint64_t v13 = (unint64_t *)(result + 16 * v7);
              uint64_t v15 = v14 + 2;
              if (v15 < a3)
              {
                unint64_t v16 = v13[2];
                if (*v13 < v16 || v16 >= *v13 && v13[1] < v13[3])
                {
                  v13 += 2;
                  uint64_t v7 = v15;
                }
              }
              if (*v13 < v11 || v11 >= *v13 && v13[1] < v12) {
                break;
              }
              *(_OWORD *)uint64_t v8 = *(_OWORD *)v13;
              uint64_t v8 = v13;
              if (v5 < v7) {
                goto LABEL_22;
              }
            }
          }
          unint64_t v13 = v8;
LABEL_22:
          *unint64_t v13 = v11;
          v13[1] = v12;
        }
      }
    }
  }
  return result;
}

__n128 std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = 0;
  uint64_t v4 = a3 - 2;
  if (a3 < 2) {
    uint64_t v4 = a3 - 1;
  }
  uint64_t v5 = v4 >> 1;
  do
  {
    uint64_t v6 = a1;
    a1 += 2 * v3 + 2;
    uint64_t v7 = 2 * v3;
    uint64_t v3 = (2 * v3) | 1;
    uint64_t v8 = v7 + 2;
    if (v8 < a3)
    {
      unint64_t v9 = a1[2];
      if (*a1 < v9 || v9 >= *a1 && a1[1] < a1[3])
      {
        a1 += 2;
        uint64_t v3 = v8;
      }
    }
    __n128 result = *(__n128 *)a1;
    *(_OWORD *)uint64_t v6 = *(_OWORD *)a1;
  }
  while (v3 <= v5);
  return result;
}

uint64_t std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,MIL::Transform::ProgramTransformer::ProgramTransformerImpl::InsertionPosition *>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = a4 - 2;
  if (a4 >= 2)
  {
    unint64_t v5 = v4 >> 1;
    uint64_t v6 = (unint64_t *)(result + 16 * (v4 >> 1));
    unint64_t v7 = *(void *)(a2 - 16);
    if (*v6 >= v7)
    {
      if (v7 < *v6) {
        return result;
      }
      unint64_t v8 = *(void *)(a2 - 8);
      if (v6[1] >= v8) {
        return result;
      }
    }
    else
    {
      unint64_t v8 = *(void *)(a2 - 8);
    }
    *(_OWORD *)(a2 - 16) = *(_OWORD *)v6;
    if (v4 >= 2)
    {
      while (1)
      {
        unint64_t v10 = v5 - 1;
        unint64_t v5 = (v5 - 1) >> 1;
        unint64_t v9 = (unint64_t *)(result + 16 * v5);
        if (*v9 >= v7 && (v7 < *v9 || v9[1] >= v8)) {
          break;
        }
        *(_OWORD *)uint64_t v6 = *(_OWORD *)v9;
        uint64_t v6 = (unint64_t *)(result + 16 * v5);
        if (v10 <= 1) {
          goto LABEL_12;
        }
      }
    }
    unint64_t v9 = v6;
LABEL_12:
    unint64_t *v9 = v7;
    v9[1] = v8;
  }
  return result;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *,false>(uint64_t result, unint64_t *a2, uint64_t a3, uint64_t a4, char a5)
{
  unint64_t v10 = (unint64_t *)result;
LABEL_2:
  unint64_t v11 = v10;
LABEL_3:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    unint64_t v10 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = (char *)a2 - (char *)v11;
    unint64_t v15 = ((char *)a2 - (char *)v11) >> 4;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          unint64_t v25 = *(a2 - 2);
          unint64_t v26 = *v11;
          if (v25 >= *v11)
          {
            if (v26 < v25) {
              return result;
            }
            unint64_t v28 = *(a2 - 1);
            unint64_t v27 = v11[1];
            if (v28 >= v27) {
              return result;
            }
          }
          else
          {
            unint64_t v27 = v11[1];
            unint64_t v28 = *(a2 - 1);
          }
          *unint64_t v11 = v25;
          v11[1] = v28;
          *(a2 - 2) = v26;
          *(a2 - 1) = v27;
          return result;
        case 3uLL:
          return std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *>(v11, v11 + 2, a2 - 2);
        case 4uLL:
          return std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *>(v11, v11 + 2, v11 + 4, a2 - 2);
        case 5uLL:
          return std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *>(v11, v11 + 2, v11 + 4, v11 + 6, a2 - 2);
        default:
          JUMPOUT(0);
      }
    }
    if (v14 <= 383) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != a2)
      {
        return (uint64_t)std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *>(v11, a2, a2, a3);
      }
      return result;
    }
    unint64_t v16 = v15 >> 1;
    uint64_t v17 = &v11[2 * (v15 >> 1)];
    if ((unint64_t)v14 >= 0x801)
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *>(v11, &v11[2 * (v15 >> 1)], a2 - 2);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *>(v11 + 2, v17 - 2, a2 - 4);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *>(v11 + 4, &v11[2 * v16 + 2], a2 - 6);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *>(v17 - 2, v17, &v11[2 * v16 + 2]);
      unint64_t v18 = *v11;
      unint64_t v19 = v11[1];
      unint64_t v20 = v17[1];
      *unint64_t v11 = *v17;
      v11[1] = v20;
      unint64_t *v17 = v18;
      v17[1] = v19;
      if (a5) {
        goto LABEL_16;
      }
    }
    else
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *>(&v11[2 * (v15 >> 1)], v11, a2 - 2);
      if (a5) {
        goto LABEL_16;
      }
    }
    unint64_t v21 = *(v11 - 2);
    if (v21 >= *v11 && (*v11 < v21 || *(v11 - 1) >= v11[1]))
    {
      __n128 result = (uint64_t)std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *,std::__less<void,void> &>(v11, a2);
      unint64_t v11 = (unint64_t *)result;
      goto LABEL_21;
    }
LABEL_16:
    unint64_t v22 = std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *,std::__less<void,void> &>(v11, a2);
    if ((v23 & 1) == 0) {
      goto LABEL_19;
    }
    BOOL v24 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *>(v11, v22);
    unint64_t v11 = v22 + 2;
    __n128 result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *>(v22 + 2, a2);
    if (result)
    {
      a4 = -v13;
      a2 = v22;
      if (v24) {
        return result;
      }
      goto LABEL_2;
    }
    uint64_t v12 = v13 + 1;
    if (!v24)
    {
LABEL_19:
      __n128 result = std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *,false>(v10, v22, a3, -v13, a5 & 1);
      unint64_t v11 = v22 + 2;
LABEL_21:
      a5 = 0;
      a4 = -v13;
      goto LABEL_3;
    }
  }
  if (a5)
  {
    return (uint64_t)std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *>(v11, a2);
  }
  else
  {
    return (uint64_t)std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *>(v11, a2);
  }
}

unint64_t *std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *>(unint64_t *result, unint64_t *a2)
{
  if (result == a2) {
    return result;
  }
  uint64_t v2 = result + 2;
  if (result + 2 == a2) {
    return result;
  }
  uint64_t v3 = 0;
  unint64_t v4 = result;
  do
  {
    char v5 = v4;
    unint64_t v4 = v2;
    unint64_t v6 = v5[2];
    unint64_t v7 = *v5;
    if (v6 >= *v5)
    {
      if (v7 < v6) {
        goto LABEL_19;
      }
      unint64_t v8 = v5[3];
      unint64_t v9 = v5[1];
      if (v8 >= v9) {
        goto LABEL_19;
      }
    }
    else
    {
      unint64_t v8 = v5[3];
      unint64_t v9 = v5[1];
    }
    void v5[2] = v7;
    v4[1] = v9;
    unint64_t v10 = result;
    if (v5 == result) {
      goto LABEL_18;
    }
    uint64_t v11 = v3;
    while (1)
    {
      unint64_t v12 = *(unint64_t *)((char *)result + v11 - 16);
      if (v6 >= v12) {
        break;
      }
      unint64_t v13 = *(unint64_t *)((char *)result + v11 - 8);
LABEL_12:
      v5 -= 2;
      uint64_t v14 = (unint64_t *)((char *)result + v11);
      *uint64_t v14 = v12;
      v14[1] = v13;
      v11 -= 16;
      if (!v11)
      {
        unint64_t v10 = result;
        goto LABEL_18;
      }
    }
    if (v12 >= v6)
    {
      unint64_t v10 = (unint64_t *)((char *)result + v11);
      unint64_t v13 = *(unint64_t *)((char *)result + v11 - 8);
      if (v8 >= v13) {
        goto LABEL_18;
      }
      goto LABEL_12;
    }
    unint64_t v10 = v5;
LABEL_18:
    *unint64_t v10 = v6;
    v10[1] = v8;
LABEL_19:
    uint64_t v2 = v4 + 2;
    v3 += 16;
  }
  while (v4 + 2 != a2);
  return result;
}

unint64_t *std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *>(unint64_t *result, unint64_t *a2)
{
  if (result != a2)
  {
    uint64_t v2 = result + 2;
    if (result + 2 != a2)
    {
      for (int i = result + 1; ; i += 2)
      {
        unint64_t v4 = result;
        __n128 result = v2;
        unint64_t v5 = v4[2];
        unint64_t v6 = *v4;
        if (v5 < *v4) {
          break;
        }
        if (v6 >= v5)
        {
          unint64_t v7 = v4[3];
          if (v7 < v4[1]) {
            goto LABEL_6;
          }
        }
LABEL_14:
        uint64_t v2 = result + 2;
        if (result + 2 == a2) {
          return result;
        }
      }
      unint64_t v7 = v4[3];
LABEL_6:
      for (unint64_t j = i; ; j -= 2)
      {
        unint64_t v9 = *j;
        j[1] = v6;
        j[2] = v9;
        unint64_t v6 = *(j - 3);
        if (v5 >= v6 && (v6 < v5 || v7 >= *(j - 2))) {
          break;
        }
      }
      *(j - 1) = v5;
      *unint64_t j = v7;
      goto LABEL_14;
    }
  }
  return result;
}

uint64_t std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *>(unint64_t *a1, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3 = *a2;
  unint64_t v4 = *a1;
  if (*a2 >= *a1 && (v4 < v3 || a2[1] >= a1[1]))
  {
    unint64_t v9 = *a3;
    if (*a3 >= v3)
    {
      if (v3 < v9) {
        return 0;
      }
      unint64_t v11 = a3[1];
      unint64_t v10 = a2[1];
      if (v11 >= v10) {
        return 0;
      }
    }
    else
    {
      unint64_t v10 = a2[1];
      unint64_t v11 = a3[1];
    }
    *a2 = v9;
    a2[1] = v11;
    *a3 = v3;
    a3[1] = v10;
    unint64_t v12 = *a2;
    unint64_t v13 = *a1;
    if (*a2 >= *a1)
    {
      if (v13 < v12) {
        return 1;
      }
      unint64_t v15 = a2[1];
      unint64_t v14 = a1[1];
      if (v15 >= v14) {
        return 1;
      }
    }
    else
    {
      unint64_t v14 = a1[1];
      unint64_t v15 = a2[1];
    }
    *a1 = v12;
    a1[1] = v15;
    uint64_t result = 2;
    *a2 = v13;
    a2[1] = v14;
  }
  else
  {
    unint64_t v5 = *a3;
    if (*a3 < v3)
    {
      unint64_t v6 = a3[1];
LABEL_6:
      unint64_t v7 = a1[1];
      *a1 = v5;
      a1[1] = v6;
      *a3 = v4;
      a3[1] = v7;
      return 1;
    }
    if (v3 >= v5)
    {
      unint64_t v6 = a3[1];
      unint64_t v16 = a2[1];
      if (v6 < v16) {
        goto LABEL_6;
      }
    }
    else
    {
      unint64_t v16 = a2[1];
    }
    unint64_t v17 = a1[1];
    *a1 = v3;
    a1[1] = v16;
    *a2 = v4;
    a2[1] = v17;
    unint64_t v18 = *a3;
    if (*a3 >= v4)
    {
      if (v4 < v18) {
        return 1;
      }
      unint64_t v19 = a3[1];
      if (v19 >= v17) {
        return 1;
      }
    }
    else
    {
      unint64_t v19 = a3[1];
    }
    *a2 = v18;
    a2[1] = v19;
    uint64_t result = 2;
    *a3 = v4;
    a3[1] = v17;
  }
  return result;
}

unint64_t *std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *,std::__less<void,void> &>(unint64_t *a1, unint64_t *a2)
{
  unint64_t v2 = *a1;
  unint64_t v3 = a1[1];
  unint64_t v4 = *(a2 - 2);
  if (*a1 >= v4 && (v4 < v2 || v3 >= *(a2 - 1)))
  {
    for (int i = a1 + 2; i < a2 && v2 >= *i && (*i < v2 || v3 >= i[1]); i += 2)
      ;
  }
  else
  {
    int i = a1;
    do
    {
      unint64_t v7 = i[2];
      i += 2;
      unint64_t v6 = v7;
    }
    while (v2 >= v7 && (v6 < v2 || v3 >= i[1]));
  }
  if (i < a2)
  {
    for (a2 -= 2; v2 < v4 || v4 >= v2 && v3 < a2[1]; a2 -= 2)
    {
      unint64_t v8 = *(a2 - 2);
      unint64_t v4 = v8;
    }
  }
  if (i < a2)
  {
    unint64_t v9 = *i;
    unint64_t v10 = *a2;
    do
    {
      unint64_t *i = v10;
      *a2 = v9;
      unint64_t v11 = i[2];
      i += 2;
      unint64_t v9 = v11;
      unint64_t v12 = *(i - 1);
      *(i - 1) = a2[1];
      a2[1] = v12;
      while (v2 >= v9 && (v9 < v2 || v3 >= i[1]))
      {
        unint64_t v13 = i[2];
        i += 2;
        unint64_t v9 = v13;
      }
      do
      {
        do
        {
          unint64_t v14 = *(a2 - 2);
          a2 -= 2;
          unint64_t v10 = v14;
        }
        while (v2 < v14);
      }
      while (v10 >= v2 && v3 < a2[1]);
    }
    while (i < a2);
  }
  if (i - 2 != a1)
  {
    unint64_t v15 = *(i - 1);
    *a1 = *(i - 2);
    a1[1] = v15;
  }
  *(i - 2) = v2;
  *(i - 1) = v3;
  return i;
}

unint64_t *std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *,std::__less<void,void> &>(unint64_t *a1, unint64_t *a2)
{
  uint64_t v2 = 0;
  unint64_t v3 = *a1;
  unint64_t v4 = a1[1];
  while (1)
  {
    unint64_t v5 = a1[v2 + 2];
    if (v5 >= v3 && (v3 < v5 || a1[v2 + 3] >= v4)) {
      break;
    }
    v2 += 2;
  }
  unint64_t v6 = (unint64_t)&a1[v2 + 2];
  if (v2 * 8)
  {
    do
    {
      unint64_t v8 = *(a2 - 2);
      a2 -= 2;
      unint64_t v7 = v8;
    }
    while (v8 >= v3 && (v3 < v7 || a2[1] >= v4));
  }
  else
  {
LABEL_19:
    if (v6 < (unint64_t)a2)
    {
      do
      {
        unint64_t v10 = *(a2 - 2);
        a2 -= 2;
        unint64_t v9 = v10;
        if (v10 < v3) {
          break;
        }
        if (v3 < v9) {
          goto LABEL_19;
        }
      }
      while (a2[1] >= v4 && v6 < (unint64_t)a2);
    }
  }
  if (v6 >= (unint64_t)a2)
  {
    unint64_t v13 = (unint64_t *)v6;
  }
  else
  {
    unint64_t v12 = *a2;
    unint64_t v13 = (unint64_t *)v6;
    unint64_t v14 = a2;
    do
    {
      unint64_t v15 = v13[1];
      unint64_t v16 = v14[1];
      *unint64_t v13 = v12;
      v13[1] = v16;
      *unint64_t v14 = v5;
      v14[1] = v15;
      do
      {
        do
        {
          unint64_t v17 = v13[2];
          v13 += 2;
          unint64_t v5 = v17;
        }
        while (v17 < v3);
      }
      while (v3 >= v5 && v13[1] < v4);
      do
      {
        unint64_t v18 = *(v14 - 2);
        v14 -= 2;
        unint64_t v12 = v18;
      }
      while (v18 >= v3 && (v3 < v12 || v14[1] >= v4));
    }
    while (v13 < v14);
  }
  if (v13 - 2 != a1)
  {
    unint64_t v19 = *(v13 - 1);
    *a1 = *(v13 - 2);
    a1[1] = v19;
  }
  *(v13 - 2) = v3;
  *(v13 - 1) = v4;
  return v13 - 2;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *>(unint64_t *a1, unint64_t *a2)
{
  uint64_t v4 = ((char *)a2 - (char *)a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      unint64_t v6 = *(a2 - 2);
      unint64_t v7 = *a1;
      if (v6 < *a1)
      {
        unint64_t v8 = a1[1];
        unint64_t v9 = *(a2 - 1);
LABEL_30:
        *a1 = v6;
        a1[1] = v9;
        *(a2 - 2) = v7;
        *(a2 - 1) = v8;
        return result;
      }
      if (v7 >= v6)
      {
        unint64_t v9 = *(a2 - 1);
        unint64_t v8 = a1[1];
        if (v9 < v8) {
          goto LABEL_30;
        }
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *>(a1, a1 + 2, a2 - 2);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *>(a1, a1 + 2, a1 + 4, a2 - 2);
      return 1;
    case 5:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *>(a1, a1 + 2, a1 + 4, a1 + 6, a2 - 2);
      return 1;
    default:
      unint64_t v10 = a1 + 4;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *>(a1, a1 + 2, a1 + 4);
      unint64_t v11 = a1 + 6;
      if (a1 + 6 == a2) {
        return 1;
      }
      uint64_t v12 = 0;
      int v13 = 0;
      break;
  }
LABEL_6:
  unint64_t v14 = *v11;
  unint64_t v15 = *v10;
  if (*v11 >= *v10)
  {
    if (v15 < v14) {
      goto LABEL_21;
    }
    unint64_t v16 = v11[1];
    unint64_t v17 = v10[1];
    if (v16 >= v17) {
      goto LABEL_21;
    }
  }
  else
  {
    unint64_t v16 = v11[1];
    unint64_t v17 = v10[1];
  }
  *unint64_t v11 = v15;
  v11[1] = v17;
  unint64_t v18 = a1;
  if (v10 == a1) {
    goto LABEL_20;
  }
  uint64_t v19 = v12;
  while (1)
  {
    unint64_t v20 = (char *)a1 + v19;
    unint64_t v21 = *(unint64_t *)((char *)a1 + v19 + 16);
    if (v14 >= v21)
    {
      if (v21 < v14)
      {
        unint64_t v18 = v10;
        goto LABEL_20;
      }
      unint64_t v22 = *(unint64_t *)((char *)a1 + v19 + 24);
      if (v16 >= v22)
      {
        unint64_t v18 = (unint64_t *)((char *)a1 + v19 + 32);
LABEL_20:
        unint64_t *v18 = v14;
        v18[1] = v16;
        if (++v13 == 8) {
          return v11 + 2 == a2;
        }
LABEL_21:
        unint64_t v10 = v11;
        v12 += 16;
        v11 += 2;
        if (v11 == a2) {
          return 1;
        }
        goto LABEL_6;
      }
    }
    else
    {
      unint64_t v22 = *((void *)v20 + 3);
    }
    v10 -= 2;
    *((void *)v20 + 4) = v21;
    *(unint64_t *)((char *)a1 + v19 + 40) = v22;
    v19 -= 16;
    if (v19 == -32)
    {
      unint64_t v18 = a1;
      goto LABEL_20;
    }
  }
}

uint64_t std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *>(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  uint64_t result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *>(a1, a2, a3);
  unint64_t v9 = *a4;
  unint64_t v10 = *a3;
  if (*a4 >= *a3)
  {
    if (v10 < v9) {
      return result;
    }
    unint64_t v12 = a4[1];
    unint64_t v11 = a3[1];
    if (v12 >= v11) {
      return result;
    }
  }
  else
  {
    unint64_t v11 = a3[1];
    unint64_t v12 = a4[1];
  }
  *a3 = v9;
  a3[1] = v12;
  *a4 = v10;
  a4[1] = v11;
  unint64_t v13 = *a3;
  unint64_t v14 = *a2;
  if (*a3 >= *a2)
  {
    if (v14 < v13) {
      return result;
    }
    unint64_t v16 = a3[1];
    unint64_t v15 = a2[1];
    if (v16 >= v15) {
      return result;
    }
  }
  else
  {
    unint64_t v15 = a2[1];
    unint64_t v16 = a3[1];
  }
  *a2 = v13;
  a2[1] = v16;
  *a3 = v14;
  a3[1] = v15;
  unint64_t v17 = *a2;
  unint64_t v18 = *a1;
  if (*a2 < *a1)
  {
    unint64_t v19 = a1[1];
    unint64_t v20 = a2[1];
LABEL_15:
    *a1 = v17;
    a1[1] = v20;
    *a2 = v18;
    a2[1] = v19;
    return result;
  }
  if (v18 >= v17)
  {
    unint64_t v20 = a2[1];
    unint64_t v19 = a1[1];
    if (v20 < v19) {
      goto LABEL_15;
    }
  }
  return result;
}

uint64_t std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *>(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4, unint64_t *a5)
{
  uint64_t result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *>(a1, a2, a3, a4);
  unint64_t v11 = *a5;
  unint64_t v12 = *a4;
  if (*a5 >= *a4)
  {
    if (v12 < v11) {
      return result;
    }
    unint64_t v14 = a5[1];
    unint64_t v13 = a4[1];
    if (v14 >= v13) {
      return result;
    }
  }
  else
  {
    unint64_t v13 = a4[1];
    unint64_t v14 = a5[1];
  }
  *a4 = v11;
  a4[1] = v14;
  *a5 = v12;
  a5[1] = v13;
  unint64_t v15 = *a4;
  unint64_t v16 = *a3;
  if (*a4 >= *a3)
  {
    if (v16 < v15) {
      return result;
    }
    unint64_t v18 = a4[1];
    unint64_t v17 = a3[1];
    if (v18 >= v17) {
      return result;
    }
  }
  else
  {
    unint64_t v17 = a3[1];
    unint64_t v18 = a4[1];
  }
  *a3 = v15;
  a3[1] = v18;
  *a4 = v16;
  a4[1] = v17;
  unint64_t v19 = *a3;
  unint64_t v20 = *a2;
  if (*a3 >= *a2)
  {
    if (v20 < v19) {
      return result;
    }
    unint64_t v22 = a3[1];
    unint64_t v21 = a2[1];
    if (v22 >= v21) {
      return result;
    }
  }
  else
  {
    unint64_t v21 = a2[1];
    unint64_t v22 = a3[1];
  }
  *a2 = v19;
  a2[1] = v22;
  *a3 = v20;
  a3[1] = v21;
  unint64_t v23 = *a2;
  unint64_t v24 = *a1;
  if (*a2 < *a1)
  {
    unint64_t v25 = a1[1];
    unint64_t v26 = a2[1];
LABEL_9:
    *a1 = v23;
    a1[1] = v26;
    *a2 = v24;
    a2[1] = v25;
    return result;
  }
  if (v24 >= v23)
  {
    unint64_t v26 = a2[1];
    unint64_t v25 = a1[1];
    if (v26 < v25) {
      goto LABEL_9;
    }
  }
  return result;
}

unint64_t *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *>(unint64_t *a1, unint64_t *a2, unint64_t *a3, uint64_t a4)
{
  if (a1 != a2)
  {
    uint64_t v8 = (char *)a2 - (char *)a1;
    uint64_t v9 = ((char *)a2 - (char *)a1) >> 4;
    if ((char *)a2 - (char *)a1 >= 17)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      unint64_t v12 = &a1[2 * v10];
      do
      {
        std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *>((uint64_t)a1, a4, v9, v12);
        v12 -= 2;
        --v11;
      }
      while (v11);
    }
    unint64_t v13 = a2;
    if (a2 != a3)
    {
      unint64_t v14 = a2;
      while (1)
      {
        unint64_t v15 = *v14;
        unint64_t v16 = *a1;
        if (*v14 >= *a1)
        {
          if (v16 < v15) {
            goto LABEL_12;
          }
          unint64_t v17 = v14[1];
          unint64_t v18 = a1[1];
          if (v17 >= v18) {
            goto LABEL_12;
          }
        }
        else
        {
          unint64_t v17 = v14[1];
          unint64_t v18 = a1[1];
        }
        *unint64_t v14 = v16;
        v14[1] = v18;
        *a1 = v15;
        a1[1] = v17;
        std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *>((uint64_t)a1, a4, v9, a1);
LABEL_12:
        v14 += 2;
        if (v14 == a3)
        {
          unint64_t v13 = a3;
          break;
        }
      }
    }
    if (v8 >= 17)
    {
      uint64_t v19 = (unint64_t)v8 >> 4;
      unint64_t v20 = a2 - 2;
      do
      {
        unint64_t v22 = *a1;
        unint64_t v21 = a1[1];
        unint64_t v23 = std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *>(a1, a4, v19);
        if (v20 == v23)
        {
          *unint64_t v23 = v22;
          v23[1] = v21;
        }
        else
        {
          unint64_t v24 = v20[1];
          *unint64_t v23 = *v20;
          v23[1] = v24;
          *unint64_t v20 = v22;
          v20[1] = v21;
          std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *>((uint64_t)a1, (uint64_t)(v23 + 2), a4, ((char *)(v23 + 2) - (char *)a1) >> 4);
        }
        v20 -= 2;
      }
      while (v19-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *>(uint64_t result, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  if (a3 >= 2)
  {
    uint64_t v4 = (uint64_t)a4 - result;
    int64_t v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 4)
    {
      uint64_t v6 = v4 >> 3;
      uint64_t v7 = (v4 >> 3) + 1;
      uint64_t v8 = (unint64_t *)(result + 16 * v7);
      uint64_t v9 = v6 + 2;
      if (v9 < a3)
      {
        unint64_t v10 = v8[2];
        if (*v8 < v10 || v10 >= *v8 && *(void *)(result + 16 * v7 + 8) < v8[3])
        {
          v8 += 2;
          uint64_t v7 = v9;
        }
      }
      unint64_t v11 = *v8;
      unint64_t v12 = *a4;
      if (*v8 >= *a4)
      {
        if (v12 >= v11)
        {
          unint64_t v14 = v8[1];
          unint64_t v13 = a4[1];
          if (v14 < v13) {
            return result;
          }
        }
        else
        {
          unint64_t v13 = a4[1];
          unint64_t v14 = v8[1];
        }
        *a4 = v11;
        a4[1] = v14;
        if (v5 >= v7)
        {
          while (1)
          {
            uint64_t v16 = 2 * v7;
            uint64_t v7 = (2 * v7) | 1;
            unint64_t v15 = (unint64_t *)(result + 16 * v7);
            uint64_t v17 = v16 + 2;
            if (v17 < a3)
            {
              unint64_t v18 = v15[2];
              if (*v15 < v18 || v18 >= *v15 && *(void *)(result + 16 * v7 + 8) < v15[3])
              {
                v15 += 2;
                uint64_t v7 = v17;
              }
            }
            unint64_t v19 = *v15;
            if (*v15 < v12) {
              break;
            }
            unint64_t v20 = v15[1];
            if (v12 >= v19 && v20 < v13) {
              break;
            }
            *uint64_t v8 = v19;
            v8[1] = v20;
            uint64_t v8 = v15;
            if (v5 < v7) {
              goto LABEL_14;
            }
          }
        }
        unint64_t v15 = v8;
LABEL_14:
        unint64_t *v15 = v12;
        v15[1] = v13;
      }
    }
  }
  return result;
}

unint64_t *std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *>(unint64_t *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = 0;
  uint64_t v4 = a3 - 2;
  if (a3 < 2) {
    uint64_t v4 = a3 - 1;
  }
  uint64_t v5 = v4 >> 1;
  do
  {
    uint64_t v6 = result;
    uint64_t v7 = v3 + 1;
    result += 2 * v3 + 2;
    uint64_t v8 = 2 * v3;
    uint64_t v3 = (2 * v3) | 1;
    uint64_t v9 = v8 + 2;
    if (v9 < a3)
    {
      unint64_t v10 = result[2];
      if (*result < v10 || v10 >= *result && v6[2 * v7 + 1] < result[3])
      {
        result += 2;
        uint64_t v3 = v9;
      }
    }
    unint64_t v11 = result[1];
    *uint64_t v6 = *result;
    v6[1] = v11;
  }
  while (v3 <= v5);
  return result;
}

uint64_t std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<MIL::Builder::OperationBuilder *,unsigned long> *>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = a4 - 2;
  if (a4 >= 2)
  {
    unint64_t v5 = v4 >> 1;
    uint64_t v6 = (unint64_t *)(result + 16 * (v4 >> 1));
    unint64_t v7 = *v6;
    unint64_t v8 = *(void *)(a2 - 16);
    if (*v6 >= v8)
    {
      if (v8 < v7) {
        return result;
      }
      unint64_t v10 = *(void *)(result + 16 * v5 + 8);
      unint64_t v9 = *(void *)(a2 - 8);
      if (v10 >= v9) {
        return result;
      }
    }
    else
    {
      unint64_t v9 = *(void *)(a2 - 8);
      unint64_t v10 = v6[1];
    }
    *(void *)(a2 - 16) = v7;
    *(void *)(a2 - 8) = v10;
    if (v4 >= 2)
    {
      while (1)
      {
        unint64_t v12 = v5 - 1;
        unint64_t v5 = (v5 - 1) >> 1;
        unint64_t v11 = (unint64_t *)(result + 16 * v5);
        unint64_t v13 = *v11;
        if (*v11 >= v8)
        {
          if (v8 < v13) {
            break;
          }
          unint64_t v14 = *(void *)(result + 16 * v5 + 8);
          if (v14 >= v9) {
            break;
          }
        }
        else
        {
          unint64_t v14 = v11[1];
        }
        *uint64_t v6 = v13;
        v6[1] = v14;
        uint64_t v6 = (unint64_t *)(result + 16 * v5);
        if (v12 <= 1) {
          goto LABEL_13;
        }
      }
    }
    unint64_t v11 = v6;
LABEL_13:
    *unint64_t v11 = v8;
    v11[1] = v9;
  }
  return result;
}

void MIL::Transform::anonymous namespace'::TopoSortViaDepthFirstSearch::Push(MIL::Transform::_anonymous_namespace_::TopoSortViaDepthFirstSearch *this, uint64_t a2)
{
  uint64_t v2 = *((void *)this + 10);
  unint64_t v3 = a2 - *((void *)this + 9);
  if (*((void *)this + 11) - v2 <= v3) {
    std::vector<MIL::IRDimension const*>::__throw_out_of_range[abi:ne180100]();
  }
  if (*(unsigned char *)(v2 + v3))
  {
    if (*(unsigned char *)(v2 + v3) == 1)
    {
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::invalid_argument::invalid_argument[abi:ne180100](exception, "Program's data dependency graph has a cycle");
      __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
    }
  }
  else
  {
    *(unsigned char *)(v2 + v3) = 1;
    unint64_t v7 = (char *)this + 120;
    unint64_t v8 = *((void *)this + 15);
    unint64_t v9 = (char *)*((void *)this + 14);
    if ((unint64_t)v9 >= v8)
    {
      unint64_t v11 = (char *)*((void *)this + 13);
      uint64_t v12 = (v9 - v11) >> 3;
      if ((unint64_t)(v12 + 1) >> 61) {
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v13 = v8 - (void)v11;
      unint64_t v14 = (uint64_t)(v8 - (void)v11) >> 2;
      if (v14 <= v12 + 1) {
        unint64_t v14 = v12 + 1;
      }
      if (v13 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v15 = v14;
      }
      if (v15)
      {
        uint64_t v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)v7, v15);
        unint64_t v11 = (char *)*((void *)this + 13);
        unint64_t v9 = (char *)*((void *)this + 14);
      }
      else
      {
        uint64_t v16 = 0;
      }
      uint64_t v17 = &v16[8 * v12];
      unint64_t v18 = &v16[8 * v15];
      *(void *)uint64_t v17 = a2;
      unint64_t v10 = v17 + 8;
      while (v9 != v11)
      {
        uint64_t v19 = *((void *)v9 - 1);
        v9 -= 8;
        *((void *)v17 - 1) = v19;
        v17 -= 8;
      }
      *((void *)this + 13) = v17;
      *((void *)this + 14) = v10;
      *((void *)this + 15) = v18;
      if (v11) {
        operator delete(v11);
      }
    }
    else
    {
      *(void *)unint64_t v9 = a2;
      unint64_t v10 = v9 + 8;
    }
    *((void *)this + 14) = v10;
  }
}

void sub_20F495F7C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void MIL::Transform::ProgramTransformer::ProgramTransformerImpl::MatchAndReplaceHelper::~MatchAndReplaceHelper(MIL::Transform::ProgramTransformer::ProgramTransformerImpl::MatchAndReplaceHelper *this)
{
  uint64_t v2 = (void *)*((void *)this + 91);
  if (v2)
  {
    *((void *)this + 92) = v2;
    operator delete(v2);
  }
  unint64_t v3 = (void *)*((void *)this + 88);
  if (v3)
  {
    *((void *)this + 89) = v3;
    operator delete(v3);
  }
  unint64_t v4 = (void *)*((void *)this + 85);
  if (v4)
  {
    *((void *)this + 86) = v4;
    operator delete(v4);
  }
  unint64_t v5 = (void *)*((void *)this + 82);
  if (v5)
  {
    *((void *)this + 83) = v5;
    operator delete(v5);
  }
  uint64_t v6 = (void *)*((void *)this + 78);
  if (v6)
  {
    *((void *)this + 79) = v6;
    operator delete(v6);
  }
  unint64_t v7 = (void *)*((void *)this + 75);
  if (v7)
  {
    *((void *)this + 76) = v7;
    operator delete(v7);
  }
  unint64_t v8 = (void *)*((void *)this + 69);
  if (v8)
  {
    *((void *)this + 70) = v8;
    operator delete(v8);
  }
  unint64_t v9 = (void *)*((void *)this + 66);
  if (v9) {
    operator delete(v9);
  }
  unint64_t v10 = (void *)*((void *)this + 62);
  if (v10)
  {
    *((void *)this + 63) = v10;
    operator delete(v10);
  }
  unint64_t v11 = (void *)*((void *)this + 59);
  if (v11)
  {
    *((void *)this + 60) = v11;
    operator delete(v11);
  }
  unint64_t v23 = (void **)((char *)this + 448);
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100](&v23);
  uint64_t v12 = (void *)*((void *)this + 53);
  if (v12)
  {
    *((void *)this + 54) = v12;
    operator delete(v12);
  }
  unint64_t v13 = (void *)*((void *)this + 50);
  if (v13)
  {
    *((void *)this + 51) = v13;
    operator delete(v13);
  }
  unint64_t v14 = (void *)*((void *)this + 47);
  if (v14) {
    operator delete(v14);
  }
  unint64_t v15 = (void *)*((void *)this + 43);
  if (v15)
  {
    *((void *)this + 44) = v15;
    operator delete(v15);
  }
  uint64_t v16 = (void *)*((void *)this + 40);
  if (v16)
  {
    *((void *)this + 41) = v16;
    operator delete(v16);
  }
  uint64_t v17 = (void *)*((void *)this + 37);
  if (v17) {
    operator delete(v17);
  }
  unint64_t v18 = (void *)*((void *)this + 33);
  if (v18)
  {
    *((void *)this + 34) = v18;
    operator delete(v18);
  }
  uint64_t v19 = (void *)*((void *)this + 30);
  if (v19)
  {
    *((void *)this + 31) = v19;
    operator delete(v19);
  }
  unint64_t v20 = (void *)*((void *)this + 27);
  if (v20)
  {
    *((void *)this + 28) = v20;
    operator delete(v20);
  }
  unint64_t v21 = (void *)*((void *)this + 24);
  if (v21)
  {
    *((void *)this + 25) = v21;
    operator delete(v21);
  }
  unint64_t v22 = (void *)*((void *)this + 21);
  if (v22)
  {
    *((void *)this + 22) = v22;
    operator delete(v22);
  }
  MIL::Matching::Match::~Match((MIL::Transform::ProgramTransformer::ProgramTransformerImpl::MatchAndReplaceHelper *)((char *)this + 160));
  MIL::Transform::MatchContext::MatchContextImpl::~MatchContextImpl(this);
}

uint64_t MIL::Transform::ProgramTransformer::ProgramTransformerImpl::RemoveRedundantOps(uint64_t a1, uint64_t *a2, _OWORD *a3, uint64_t *a4, _OWORD *a5)
{
  unint64_t v10 = a3 + 1;
  while (1)
  {
    unint64_t v10 = (void *)*v10;
    if (!v10) {
      break;
    }
    if (!MIL::Builder::BlockBuilder::TryGetVariable(*a2, (uint64_t)(v10 + 2)))
    {
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::operator+<char>();
      std::logic_error::logic_error(exception, (const std::string *)v62);
      exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
      __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
    }
  }
  uint64_t v12 = *a4;
  uint64_t v13 = a4[1];
  while (v12 != v13)
  {
    if (!MIL::Builder::BlockBuilder::TryGetVariable(*a2, v12))
    {
      unint64_t v44 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::operator+<char>();
      std::logic_error::logic_error(v44, (const std::string *)v62);
      v44->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
      __cxa_throw(v44, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
    }
    v12 += 24;
  }
  size_t NumOperations = MIL::Builder::BlockBuilder::GetNumOperations((MIL::Builder::BlockBuilder *)*a2);
  long long v64 = 0u;
  long long v65 = 0u;
  int v66 = 1065353216;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>((uint64_t)&v64, NumOperations);
  unint64_t v46 = (char *)NumOperations;
  if (NumOperations)
  {
    for (unint64_t i = 0; i != NumOperations; ++i)
    {
      MIL::Builder::BlockBuilder::GetOperation((MIL::Builder::BlockBuilder::BlockBuilderImpl **)*a2, i, v62);
      v61[0] = v62;
      *((unsigned char *)std::__hash_table<std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,BOOL>,std::__unordered_map_hasher<std::shared_ptr<MIL::Builder::OperationBuilder>,std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,BOOL>,std::hash<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::equal_to<std::shared_ptr<MIL::Builder::OperationBuilder>>,true>,std::__unordered_map_equal<std::shared_ptr<MIL::Builder::OperationBuilder>,std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,BOOL>,std::equal_to<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::hash<std::shared_ptr<MIL::Builder::OperationBuilder>>,true>,std::allocator<std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,BOOL>>>::__emplace_unique_key_args<std::shared_ptr<MIL::Builder::OperationBuilder>,std::piecewise_construct_t const&,std::tuple<std::shared_ptr<MIL::Builder::OperationBuilder>&&>,std::tuple<>>((uint64_t)&v64, v62, (uint64_t)&std::piecewise_construct, v61)+ 32) = 0;
      if (*(void *)&v62[8]) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&v62[8]);
      }
    }
  }
  long long v63 = 0u;
  memset(v62, 0, sizeof(v62));
  v61[0] = a2;
  v61[1] = a3;
  v61[2] = &v64;
  v61[3] = v62;
  v61[4] = a5;
  uint64_t v17 = (unsigned __int8 *)*a4;
  uint64_t v16 = (unsigned __int8 *)a4[1];
  if ((unsigned __int8 *)*a4 != v16)
  {
    do
    {
      MIL::Transform::ProgramTransformer::ProgramTransformerImpl::RemoveRedundantOps(std::shared_ptr<MIL::Builder::BlockBuilder> const&,std::unordered_set<std::string> const&,std::vector<std::string> const&,std::unordered_set<std::string>&)::{lambda(std::string const&)#1}::operator()((uint64_t)v61, v17);
      v17 += 24;
    }
    while (v17 != v16);
    while (*((void *)&v63 + 1))
    {
      uint64_t v18 = *(void *)(*(void *)&v62[8] + (((unint64_t)v63 >> 5) & 0x7FFFFFFFFFFFFF8))
          + 16 * v63;
      unint64_t v20 = *(MIL::Builder::OperationBuilder **)v18;
      uint64_t v19 = *(std::__shared_weak_count **)(v18 + 8);
      if (v19) {
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::Builder::OperationBuilder::GetBlocks(v20, v60);
      unint64_t v22 = (MIL::Builder::BlockBuilder::BlockBuilderImpl ***)v60[0];
      unint64_t v21 = (MIL::Builder::BlockBuilder::BlockBuilderImpl ***)v60[1];
      while (v22 != v21)
      {
        unint64_t v23 = *v22;
        unint64_t v24 = (std::__shared_weak_count *)v22[1];
        unint64_t v58 = (MIL::Builder::BlockBuilder *)*v22;
        unint64_t v59 = v24;
        if (v24) {
          atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        MIL::Builder::BlockBuilder::GetInputNames(v23, &v57);
        std::unordered_set<std::string>::unordered_set<std::__wrap_iter<std::string*>>((uint64_t)&__p, (unsigned __int8 *)v57.__begin_, (unsigned __int8 *)v57.__end_);
        long long v51 = 0u;
        long long v52 = 0u;
        int v53 = 1065353216;
        std::string v48 = v58;
        unint64_t v49 = v59;
        if (v59) {
          atomic_fetch_add_explicit(&v59->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        MIL::Transform::ProgramTransformer::ProgramTransformerImpl::GetBlockOutsAndWriteEffectOpIns(&v48, &v50);
        MIL::Transform::ProgramTransformer::ProgramTransformerImpl::RemoveRedundantOps(a1, &v58, &__p, &v50, &v51);
        unint64_t v67 = &v50;
        std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v67);
        if (v49) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v49);
        }
        for (unint64_t j = (unsigned __int8 *)v52; j; unint64_t j = *(unsigned __int8 **)j)
          MIL::Transform::ProgramTransformer::ProgramTransformerImpl::RemoveRedundantOps(std::shared_ptr<MIL::Builder::BlockBuilder> const&,std::unordered_set<std::string> const&,std::vector<std::string> const&,std::unordered_set<std::string>&)::{lambda(std::string const&)#1}::operator()((uint64_t)v61, j + 16);
        std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&v51);
        std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&__p);
        std::string __p = &v57;
        std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
        if (v59) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v59);
        }
        v22 += 2;
      }
      std::string __p = v60;
      std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
      MIL::Builder::OperationBuilder::GetInputArguments((MIL::Builder::OperationBuilder::OperationBuilderImpl **)v20, (uint64_t)&__p);
      unint64_t v26 = (MIL::Builder::Variable::VariableImpl ***)v56;
      if (v56)
      {
        do
        {
          uint64_t Name = (unsigned __int8 *)MIL::Builder::Variable::TryGetName(v26[2]);
          if (Name) {
            MIL::Transform::ProgramTransformer::ProgramTransformerImpl::RemoveRedundantOps(std::shared_ptr<MIL::Builder::BlockBuilder> const&,std::unordered_set<std::string> const&,std::vector<std::string> const&,std::unordered_set<std::string>&)::{lambda(std::string const&)#1}::operator()((uint64_t)v61, Name);
          }
          unint64_t v26 = (MIL::Builder::Variable::VariableImpl ***)*v26;
        }
        while (v26);
      }
      std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table((uint64_t)&__p);
      std::deque<std::shared_ptr<MIL::Builder::OperationBuilder>>::pop_front(v62);
      if (v19) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v19);
      }
    }
  }
  std::string __p = 0;
  unint64_t v55 = 0;
  unint64_t v56 = 0;
  unint64_t v28 = v46;
  if (v46)
  {
    for (unint64_t k = 0; (char *)k != v46; ++k)
    {
      MIL::Builder::BlockBuilder::GetOperation((MIL::Builder::BlockBuilder::BlockBuilderImpl **)*a2, k, &v51);
      v60[0] = &v51;
      if (!*((unsigned char *)std::__hash_table<std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,BOOL>,std::__unordered_map_hasher<std::shared_ptr<MIL::Builder::OperationBuilder>,std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,BOOL>,std::hash<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::equal_to<std::shared_ptr<MIL::Builder::OperationBuilder>>,true>,std::__unordered_map_equal<std::shared_ptr<MIL::Builder::OperationBuilder>,std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,BOOL>,std::equal_to<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::hash<std::shared_ptr<MIL::Builder::OperationBuilder>>,true>,std::allocator<std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,BOOL>>>::__emplace_unique_key_args<std::shared_ptr<MIL::Builder::OperationBuilder>,std::piecewise_construct_t const&,std::tuple<std::shared_ptr<MIL::Builder::OperationBuilder> const&>,std::tuple<>>((uint64_t)&v64, &v51, (uint64_t)&std::piecewise_construct, v60)+ 32))
      {
        long long v47 = v51;
        if (*((void *)&v51 + 1)) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v51 + 1) + 8), 1uLL, memory_order_relaxed);
        }
        BOOL v30 = MIL::Transform::HasWriteEffectAndNoOutputs((MIL::Builder::OperationBuilder **)&v47);
        if (*((void *)&v47 + 1)) {
          std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v47 + 1));
        }
        if (!v30)
        {
          long long v31 = v55;
          if (v55 >= v56)
          {
            long long v33 = (char *)__p;
            uint64_t v34 = (v55 - (unsigned char *)__p) >> 3;
            unint64_t v35 = v34 + 1;
            if ((unint64_t)(v34 + 1) >> 61) {
              std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v36 = v56 - (unsigned char *)__p;
            if ((v56 - (unsigned char *)__p) >> 2 > v35) {
              unint64_t v35 = v36 >> 2;
            }
            if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v37 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v37 = v35;
            }
            if (v37)
            {
              unint64_t v38 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v56, v37);
              long long v33 = (char *)__p;
              long long v31 = v55;
            }
            else
            {
              unint64_t v38 = 0;
            }
            unint64_t v39 = (unint64_t *)&v38[8 * v34];
            unint64_t *v39 = k;
            unint64_t v32 = (char *)(v39 + 1);
            while (v31 != v33)
            {
              unint64_t v40 = *((void *)v31 - 1);
              v31 -= 8;
              *--unint64_t v39 = v40;
            }
            std::string __p = v39;
            unint64_t v55 = v32;
            unint64_t v56 = &v38[8 * v37];
            if (v33) {
              operator delete(v33);
            }
          }
          else
          {
            *(void *)unint64_t v55 = k;
            unint64_t v32 = v31 + 8;
          }
          unint64_t v55 = v32;
        }
      }
      if (*((void *)&v51 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v51 + 1));
      }
    }
    unint64_t v28 = (char *)__p;
  }
  uint64_t v41 = (v55 - v28) >> 3;
  if (*((void *)&v65 + 1) && v41 == *((void *)&v65 + 1))
  {
    uint64_t v45 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v45, "produced an empty program!");
    __cxa_throw(v45, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
  }
  if (v55 == v28) {
    unint64_t v42 = 0;
  }
  else {
    unint64_t v42 = v28;
  }
  MIL::Builder::BlockBuilder::RemoveOperations(*a2, v42, v41, 1);
  if (__p)
  {
    unint64_t v55 = (char *)__p;
    operator delete(__p);
  }
  std::deque<std::shared_ptr<MIL::Builder::OperationBuilder>>::~deque[abi:ne180100](v62);
  return std::__hash_table<std::shared_ptr<MIL::Builder::OperationBuilder>,std::hash<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::equal_to<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::allocator<std::shared_ptr<MIL::Builder::OperationBuilder>>>::~__hash_table((uint64_t)&v64);
}

void sub_20F496700(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
  if (__p) {
    operator delete(__p);
  }
  std::deque<std::shared_ptr<MIL::Builder::OperationBuilder>>::~deque[abi:ne180100]((void *)(v35 - 192));
  std::__hash_table<std::shared_ptr<MIL::Builder::OperationBuilder>,std::hash<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::equal_to<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::allocator<std::shared_ptr<MIL::Builder::OperationBuilder>>>::~__hash_table(v35 - 144);
  _Unwind_Resume(a1);
}

unint64_t MIL::Transform::ProgramTransformer::ProgramTransformerImpl::GetBlockOutsAndWriteEffectOpIns@<X0>(MIL::Builder::BlockBuilder **a1@<X1>, std::string *a2@<X8>)
{
  MIL::Builder::BlockBuilder::GetOutputNames(*a1, a2);
  for (unint64_t i = 0; ; ++i)
  {
    unint64_t result = MIL::Builder::BlockBuilder::GetNumOperations(*a1);
    if (i >= result) {
      break;
    }
    MIL::Builder::BlockBuilder::GetOperation((MIL::Builder::BlockBuilder::BlockBuilderImpl **)*a1, i, &v15);
    long long v14 = v15;
    if (*((void *)&v15 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v15 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    BOOL v6 = MIL::Transform::HasWriteEffectAndNoOutputs((MIL::Builder::OperationBuilder **)&v14);
    if (*((void *)&v14 + 1)) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v14 + 1));
    }
    if (v6)
    {
      MIL::Builder::OperationBuilder::GetInputArguments((MIL::Builder::OperationBuilder::OperationBuilderImpl **)v15, (uint64_t)v12);
      for (unint64_t j = v13; j; unint64_t j = (uint64_t **)*j)
      {
        uint64_t Name = (long long *)MIL::Builder::Variable::TryGetName((MIL::Builder::Variable::VariableImpl **)j[2]);
        if (Name)
        {
          uint64_t Type = (void *)MIL::Builder::Variable::TryGetType((MIL::Builder::Variable::VariableImpl **)j[2]);
          if (!MIL::IRValueType::TryCastAsStateType(Type))
          {
            std::string::size_type size = a2->__r_.__value_.__l.__size_;
            if (size >= a2->__r_.__value_.__r.__words[2])
            {
              uint64_t v11 = std::vector<std::string>::__push_back_slow_path<std::string const&>((uint64_t *)a2, Name);
            }
            else
            {
              std::vector<std::string>::__construct_one_at_end[abi:ne180100]<std::string const&>((uint64_t)a2, Name);
              uint64_t v11 = size + 24;
            }
            a2->__r_.__value_.__l.__size_ = v11;
          }
        }
      }
      std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table((uint64_t)v12);
    }
    if (*((void *)&v15 + 1)) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v15 + 1));
    }
  }
  return result;
}

void sub_20F4969AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18)
{
  if (a18) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a18);
  }
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&a10);
  _Unwind_Resume(a1);
}

void MIL::Transform::ProgramTransformer::ProgramTransformerImpl::RemoveRedundantOps(std::shared_ptr<MIL::Builder::BlockBuilder> const&,std::unordered_set<std::string> const&,std::vector<std::string> const&,std::unordered_set<std::string>&)::{lambda(std::string const&)#1}::operator()(uint64_t a1, unsigned __int8 *a2)
{
  if (!std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(*(void **)(a1 + 8), a2))
  {
    MIL::Builder::BlockBuilder::TryGetOperation(**(void **)a1, a2, &v6);
    if ((void)v6)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      unint64_t v7 = &v6;
      if (!*((unsigned char *)std::__hash_table<std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,BOOL>,std::__unordered_map_hasher<std::shared_ptr<MIL::Builder::OperationBuilder>,std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,BOOL>,std::hash<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::equal_to<std::shared_ptr<MIL::Builder::OperationBuilder>>,true>,std::__unordered_map_equal<std::shared_ptr<MIL::Builder::OperationBuilder>,std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,BOOL>,std::equal_to<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::hash<std::shared_ptr<MIL::Builder::OperationBuilder>>,true>,std::allocator<std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,BOOL>>>::__emplace_unique_key_args<std::shared_ptr<MIL::Builder::OperationBuilder>,std::piecewise_construct_t const&,std::tuple<std::shared_ptr<MIL::Builder::OperationBuilder> const&>,std::tuple<>>(v4, &v6, (uint64_t)&std::piecewise_construct, (void **)&v7)+ 32))
      {
        uint64_t v5 = *(void *)(a1 + 16);
        unint64_t v7 = &v6;
        *((unsigned char *)std::__hash_table<std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,BOOL>,std::__unordered_map_hasher<std::shared_ptr<MIL::Builder::OperationBuilder>,std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,BOOL>,std::hash<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::equal_to<std::shared_ptr<MIL::Builder::OperationBuilder>>,true>,std::__unordered_map_equal<std::shared_ptr<MIL::Builder::OperationBuilder>,std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,BOOL>,std::equal_to<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::hash<std::shared_ptr<MIL::Builder::OperationBuilder>>,true>,std::allocator<std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,BOOL>>>::__emplace_unique_key_args<std::shared_ptr<MIL::Builder::OperationBuilder>,std::piecewise_construct_t const&,std::tuple<std::shared_ptr<MIL::Builder::OperationBuilder> const&>,std::tuple<>>(v5, &v6, (uint64_t)&std::piecewise_construct, (void **)&v7)+ 32) = 1;
        std::deque<std::shared_ptr<MIL::Builder::OperationBuilder>>::push_back(*(void **)(a1 + 24), &v6);
      }
    }
    else
    {
      std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>(*(void *)(a1 + 32), a2, (uint64_t)a2);
    }
    if (*((void *)&v6 + 1)) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v6 + 1));
    }
  }
}

void sub_20F496AE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::deque<std::shared_ptr<MIL::Builder::OperationBuilder>>::pop_front(void *a1)
{
  unint64_t v2 = a1[4];
  unint64_t v3 = *(std::__shared_weak_count **)(*(void *)(a1[1] + ((v2 >> 5) & 0x7FFFFFFFFFFFFF8))
                                    + 16 * v2
                                    + 8);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    unint64_t v2 = a1[4];
  }
  uint64_t v4 = a1[5] - 1;
  a1[4] = v2 + 1;
  a1[5] = v4;

  return std::deque<std::shared_ptr<MIL::Builder::OperationBuilder>>::__maybe_remove_front_spare[abi:ne180100]((uint64_t)a1, 1);
}

void *std::__hash_table<std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,BOOL>,std::__unordered_map_hasher<std::shared_ptr<MIL::Builder::OperationBuilder>,std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,BOOL>,std::hash<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::equal_to<std::shared_ptr<MIL::Builder::OperationBuilder>>,true>,std::__unordered_map_equal<std::shared_ptr<MIL::Builder::OperationBuilder>,std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,BOOL>,std::equal_to<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::hash<std::shared_ptr<MIL::Builder::OperationBuilder>>,true>,std::allocator<std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,BOOL>>>::__emplace_unique_key_args<std::shared_ptr<MIL::Builder::OperationBuilder>,std::piecewise_construct_t const&,std::tuple<std::shared_ptr<MIL::Builder::OperationBuilder>&&>,std::tuple<>>(uint64_t a1, void *a2, uint64_t a3, _OWORD **a4)
{
  unint64_t v7 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  unint64_t v8 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v7 >> 47) ^ v7);
  unint64_t v9 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v4 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
      if (v9 >= v10) {
        unint64_t v4 = v9 % v10;
      }
    }
    else
    {
      unint64_t v4 = v9 & (v10 - 1);
    }
    uint64_t v12 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v12)
    {
      uint64_t v13 = *v12;
      if (*v12)
      {
        do
        {
          unint64_t v14 = v13[1];
          if (v14 == v9)
          {
            if (v13[2] == *a2) {
              return v13;
            }
          }
          else
          {
            if (v11.u32[0] > 1uLL)
            {
              if (v14 >= v10) {
                v14 %= v10;
              }
            }
            else
            {
              v14 &= v10 - 1;
            }
            if (v14 != v4) {
              break;
            }
          }
          uint64_t v13 = (void *)*v13;
        }
        while (v13);
      }
    }
  }
  long long v15 = (void *)(a1 + 16);
  uint64_t v13 = operator new(0x28uLL);
  *uint64_t v13 = 0;
  v13[1] = v9;
  uint64_t v16 = *a4;
  *((_OWORD *)v13 + 1) = **a4;
  void *v16 = 0;
  v16[1] = 0;
  *((unsigned char *)v13 + 32) = 0;
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v18 = *(float *)(a1 + 32);
  if (!v10 || (float)(v18 * (float)v10) < v17)
  {
    BOOL v19 = 1;
    if (v10 >= 3) {
      BOOL v19 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v10);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v22);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v4 = v9 % v10;
      }
      else {
        unint64_t v4 = v9;
      }
    }
    else
    {
      unint64_t v4 = (v10 - 1) & v9;
    }
  }
  uint64_t v23 = *(void *)a1;
  unint64_t v24 = *(void **)(*(void *)a1 + 8 * v4);
  if (v24)
  {
    *uint64_t v13 = *v24;
LABEL_38:
    void *v24 = v13;
    goto LABEL_39;
  }
  *uint64_t v13 = *v15;
  void *v15 = v13;
  *(void *)(v23 + 8 * v4) = v15;
  if (*v13)
  {
    unint64_t v25 = *(void *)(*v13 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v25 >= v10) {
        v25 %= v10;
      }
    }
    else
    {
      v25 &= v10 - 1;
    }
    unint64_t v24 = (void *)(*(void *)a1 + 8 * v25);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v13;
}

void sub_20F496DDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::shared_ptr<MIL::Builder::OperationBuilder>,void *>>>::operator()[abi:ne180100](v11, v10);
  _Unwind_Resume(a1);
}

void std::deque<std::shared_ptr<MIL::Builder::OperationBuilder>>::push_back(void *a1, long long *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = 32 * (v4 - v5) - 1;
  }
  uint64_t v7 = a1[5];
  unint64_t v8 = v7 + a1[4];
  if (v6 == v8)
  {
    std::deque<std::shared_ptr<MIL::Builder::OperationBuilder>>::__add_back_capacity(a1);
    uint64_t v5 = a1[1];
    uint64_t v7 = a1[5];
    unint64_t v8 = v7 + a1[4];
  }
  long long v9 = *a2;
  *(_OWORD *)(*(void *)(v5 + ((v8 >> 5) & 0x7FFFFFFFFFFFFF8)) + 16 * v8) = *a2;
  if (*((void *)&v9 + 1))
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v9 + 1) + 8), 1uLL, memory_order_relaxed);
    uint64_t v7 = a1[5];
  }
  a1[5] = v7 + 1;
}

void std::deque<std::shared_ptr<MIL::Builder::OperationBuilder>>::__add_back_capacity(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x100;
  unint64_t v4 = v2 - 256;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    long long v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>(v5, v33);
      uint64_t v35 = &v34[8 * (v33 >> 2)];
      unint64_t v37 = &v34[8 * v36];
      unint64_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        uint64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)uint64_t v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    BOOL v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      long long v9 = (char *)a1[1];
    }
    unint64_t v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0x1000uLL);
      std::__split_buffer<std::__state<char> *,std::allocator<std::__state<char> *>>::push_back(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0x1000uLL);
    std::__split_buffer<std::__state<char> *,std::allocator<std::__state<char> *>>::push_front((uint64_t)a1, &v54);
    unint64_t v44 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    long long v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(a1 + 3), v46);
      uint64_t v35 = &v34[8 * (v46 >> 2)];
      unint64_t v37 = &v34[8 * v47];
      std::string v48 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        unint64_t v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        long long v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)long long v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      uint64_t v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        unint64_t v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  unint64_t v56 = a1 + 3;
  *(void *)&long long v54 = std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  int v53 = operator new(0x1000uLL);
  std::__split_buffer<std::__state<char> *,std::allocator<std::__state<char> *> &>::push_back(&v54, &v53);
  unint64_t v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    std::__split_buffer<std::__state<char> *,std::allocator<std::__state<char> *> &>::push_front((uint64_t)&v54, v27);
  }
  unint64_t v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_20F497164(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t std::deque<std::shared_ptr<MIL::Builder::OperationBuilder>>::__maybe_remove_front_spare[abi:ne180100](uint64_t a1, int a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 < 0x100) {
    a2 = 1;
  }
  if (v2 < 0x200) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8;
    *(void *)(a1 + 32) -= 256;
  }
  return v4 ^ 1u;
}

void *std::__hash_table<std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,BOOL>,std::__unordered_map_hasher<std::shared_ptr<MIL::Builder::OperationBuilder>,std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,BOOL>,std::hash<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::equal_to<std::shared_ptr<MIL::Builder::OperationBuilder>>,true>,std::__unordered_map_equal<std::shared_ptr<MIL::Builder::OperationBuilder>,std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,BOOL>,std::equal_to<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::hash<std::shared_ptr<MIL::Builder::OperationBuilder>>,true>,std::allocator<std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,BOOL>>>::__emplace_unique_key_args<std::shared_ptr<MIL::Builder::OperationBuilder>,std::piecewise_construct_t const&,std::tuple<std::shared_ptr<MIL::Builder::OperationBuilder> const&>,std::tuple<>>(uint64_t a1, void *a2, uint64_t a3, void **a4)
{
  unint64_t v7 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  unint64_t v8 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v7 >> 47) ^ v7);
  unint64_t v9 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v4 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
      if (v9 >= v10) {
        unint64_t v4 = v9 % v10;
      }
    }
    else
    {
      unint64_t v4 = v9 & (v10 - 1);
    }
    uint64_t v12 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v12)
    {
      for (unint64_t i = *v12; i; unint64_t i = (void *)*i)
      {
        unint64_t v14 = i[1];
        if (v14 == v9)
        {
          if (i[2] == *a2) {
            return i;
          }
        }
        else
        {
          if (v11.u32[0] > 1uLL)
          {
            if (v14 >= v10) {
              v14 %= v10;
            }
          }
          else
          {
            v14 &= v10 - 1;
          }
          if (v14 != v4) {
            break;
          }
        }
      }
    }
  }
  uint64_t v15 = (void *)(a1 + 16);
  uint64_t v16 = operator new(0x28uLL);
  unint64_t i = v16;
  void *v16 = 0;
  v16[1] = v9;
  uint64_t v17 = *a4;
  void v16[2] = **a4;
  uint64_t v18 = v17[1];
  v16[3] = v18;
  if (v18) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v18 + 8), 1uLL, memory_order_relaxed);
  }
  *((unsigned char *)v16 + 32) = 0;
  float v19 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v20 = *(float *)(a1 + 32);
  if (!v10 || (float)(v20 * (float)v10) < v19)
  {
    BOOL v21 = 1;
    if (v10 >= 3) {
      BOOL v21 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v22 = v21 | (2 * v10);
    unint64_t v23 = vcvtps_u32_f32(v19 / v20);
    if (v22 <= v23) {
      size_t v24 = v23;
    }
    else {
      size_t v24 = v22;
    }
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v24);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v4 = v9 % v10;
      }
      else {
        unint64_t v4 = v9;
      }
    }
    else
    {
      unint64_t v4 = (v10 - 1) & v9;
    }
  }
  uint64_t v25 = *(void *)a1;
  uint64_t v26 = *(void **)(*(void *)a1 + 8 * v4);
  if (v26)
  {
    void *i = *v26;
LABEL_40:
    void *v26 = i;
    goto LABEL_41;
  }
  void *i = *v15;
  void *v15 = i;
  *(void *)(v25 + 8 * v4) = v15;
  if (*i)
  {
    unint64_t v27 = *(void *)(*i + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v27 >= v10) {
        v27 %= v10;
      }
    }
    else
    {
      v27 &= v10 - 1;
    }
    uint64_t v26 = (void *)(*(void *)a1 + 8 * v27);
    goto LABEL_40;
  }
LABEL_41:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_20F497494(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::shared_ptr<MIL::Builder::OperationBuilder>,void *>>>::operator()[abi:ne180100](v11, v10);
  _Unwind_Resume(a1);
}

uint64_t std::deque<std::shared_ptr<MIL::Builder::OperationBuilder>>::~deque[abi:ne180100](void *a1)
{
  unint64_t v2 = (void **)a1[1];
  BOOL v3 = (void **)a1[2];
  if (v3 == v2)
  {
    unint64_t v4 = a1 + 5;
    BOOL v3 = (void **)a1[1];
  }
  else
  {
    unint64_t v4 = a1 + 5;
    unint64_t v5 = a1[4];
    uint64_t v6 = &v2[v5 >> 8];
    uint64_t v7 = (uint64_t)*v6;
    uint64_t v8 = (uint64_t)*v6 + 16 * v5;
    uint64_t v9 = *(uint64_t *)((char *)v2 + (((a1[5] + v5) >> 5) & 0x7FFFFFFFFFFFFF8))
       + 16 * (*((unsigned char *)a1 + 40) + v5);
    if (v8 != v9)
    {
      do
      {
        unint64_t v10 = *(std::__shared_weak_count **)(v8 + 8);
        if (v10)
        {
          std::__shared_weak_count::__release_shared[abi:ne180100](v10);
          uint64_t v7 = (uint64_t)*v6;
        }
        v8 += 16;
        if (v8 - v7 == 4096)
        {
          uint64_t v11 = (uint64_t)v6[1];
          ++v6;
          uint64_t v7 = v11;
          uint64_t v8 = v11;
        }
      }
      while (v8 != v9);
      unint64_t v2 = (void **)a1[1];
      BOOL v3 = (void **)a1[2];
    }
  }
  *unint64_t v4 = 0;
  unint64_t v12 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      BOOL v3 = (void **)a1[2];
      unint64_t v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v12 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v13 = v12 >> 3;
  if (v13 == 1)
  {
    uint64_t v14 = 128;
  }
  else
  {
    if (v13 != 2) {
      goto LABEL_18;
    }
    uint64_t v14 = 256;
  }
  a1[4] = v14;
LABEL_18:
  while (v2 != v3)
  {
    uint64_t v15 = *v2++;
    operator delete(v15);
  }

  return std::__split_buffer<std::__state<char> *,std::allocator<std::__state<char> *>>::~__split_buffer((uint64_t)a1);
}

uint64_t std::unordered_set<std::string>::unordered_set<std::__wrap_iter<std::string const*>>(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (a2 != a3)
  {
    unint64_t v5 = a2;
    do
    {
      std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>(a1, v5, (uint64_t)v5);
      v5 += 24;
    }
    while (v5 != a3);
  }
  return a1;
}

void sub_20F497650(_Unwind_Exception *a1)
{
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void MIL::Transform::ProgramTransformer::ProgramTransformerImpl::GetInputsAndOutputs(uint64_t *a1@<X0>, unsigned __int8 *a2@<X1>, unint64_t a3@<X2>, unint64_t a4@<X3>, std::string *a5@<X8>)
{
  MIL::Builder::ProgramBuilder::GetFunction(a1[4], a2, &v51);
  uint64_t v8 = v51;
  uint64_t v9 = (unsigned __int8 *)MIL::Builder::FunctionBuilder::SelectedSpecialization(v51);
  MIL::Builder::FunctionBuilder::GetBlock((uint64_t)v8, v9, &v49);
  unint64_t v29 = a5;
  MIL::Builder::BlockBuilder::GetOperations(v49, &v47);
  memset(v45, 0, sizeof(v45));
  int v46 = 1065353216;
  memset(v43, 0, sizeof(v43));
  int v44 = 1065353216;
  uint64_t v10 = v47;
  if (v48 != v47)
  {
    unint64_t v11 = 0;
    do
    {
      uint64_t v12 = v10 + 16 * v11;
      uint64_t v14 = *(unsigned __int8 ***)v12;
      unint64_t v13 = *(std::__shared_weak_count **)(v12 + 8);
      if (v13) {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::Transform::ProgramTransformer::ProgramTransformerImpl::GetAllConsumedVariableNames((MIL::Transform::ProgramTransformer::ProgramTransformerImpl *)a1, v14, (uint64_t)v41);
      for (unint64_t i = v42; i; unint64_t i = (uint64_t *)*i)
      {
        v31[0] = (long long *)(i + 2);
        *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v45, (unsigned __int8 *)i + 16, (uint64_t)&std::piecewise_construct, v31)+ 5) = v11;
      }
      std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v41);
      for (unint64_t j = 0; j < MIL::Builder::OperationBuilder::GetNumOutputs((MIL::Builder::OperationBuilder *)v14); ++j)
      {
        v41[0] = (long long *)MIL::Builder::OperationBuilder::GetOutputName((MIL::Builder::OperationBuilder::OperationBuilderImpl **)v14, j);
        *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v43, (unsigned __int8 *)v41[0], (uint64_t)&std::piecewise_construct, v41)+ 5) = v11;
      }
      if (v13) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v13);
      }
      ++v11;
      uint64_t v10 = v47;
    }
    while (v11 < (v48 - v47) >> 4);
  }
  MIL::Builder::BlockBuilder::GetOutputNames(v49, &v40);
  std::unordered_set<std::string>::unordered_set<std::__wrap_iter<std::string*>>((uint64_t)v41, (unsigned __int8 *)v40.__r_.__value_.__l.__data_, (unsigned __int8 *)v40.__r_.__value_.__l.__size_);
  memset(&v39, 0, sizeof(v39));
  uint64_t v36 = 0;
  unint64_t v37 = 0;
  unint64_t v38 = 0;
  uint64_t v34 = 0;
  std::vector<std::string>::size_type __sz = 0;
  *(void *)unint64_t v33 = &v34;
  if (a3 < a4)
  {
    unint64_t v17 = a3;
    do
    {
      uint64_t v18 = v47 + 16 * v17;
      float v20 = *(unsigned __int8 ***)v18;
      float v19 = *(std::__shared_weak_count **)(v18 + 8);
      if (v19) {
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::Transform::ProgramTransformer::ProgramTransformerImpl::GetAllConsumedVariableNames((MIL::Transform::ProgramTransformer::ProgramTransformerImpl *)a1, v20, (uint64_t)v31);
      for (unint64_t k = v32; k; unint64_t k = *(unsigned __int8 **)k)
      {
        unint64_t v22 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>(v43, k + 16);
        if (!v22 || *((void *)v22 + 5) < a3) {
          std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t **)v33, (const void **)k + 2, (uint64_t)(k + 16));
        }
      }
      std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v31);
      for (unint64_t m = 0; m < MIL::Builder::OperationBuilder::GetNumOutputs((MIL::Builder::OperationBuilder *)v20); ++m)
      {
        Outputuint64_t Name = MIL::Builder::OperationBuilder::GetOutputName((MIL::Builder::OperationBuilder::OperationBuilderImpl **)v20, m);
        v31[0] = (long long *)OutputName;
        if (*((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v45, (unsigned __int8 *)OutputName, (uint64_t)&std::piecewise_construct, v31)+ 5) >= a4|| std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>(v41, (unsigned __int8 *)OutputName))
        {
          uint64_t v25 = v37;
          if ((unint64_t)v37 >= v38)
          {
            unint64_t v27 = (std::string *)std::vector<std::string>::__push_back_slow_path<std::string const&>((uint64_t *)&v36, (long long *)OutputName);
          }
          else
          {
            if (*(char *)(OutputName + 23) < 0)
            {
              std::string::__init_copy_ctor_external(v37, *(const std::string::value_type **)OutputName, *(void *)(OutputName + 8));
            }
            else
            {
              long long v26 = *(_OWORD *)OutputName;
              v37->__r_.__value_.__r.__words[2] = *(void *)(OutputName + 16);
              *(_OWORD *)&v25->__r_.__value_.__l.__data_ = v26;
            }
            unint64_t v27 = v25 + 1;
          }
          unint64_t v37 = v27;
        }
      }
      if (v19) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v19);
      }
      ++v17;
    }
    while (v17 != a4);
  }
  std::vector<std::string>::resize(&v39, __sz);
  std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__tree_const_iterator<std::string,std::__tree_node<std::string,void *> *,long>,std::__tree_const_iterator<std::string,std::__tree_node<std::string,void *> *,long>,std::string*>((int)v31, *(void **)v33, &v34, v39.__begin_);
  std::pair<std::vector<std::string>,std::vector<std::string>>::pair[abi:ne180100]<std::vector<std::string>&,std::vector<std::string>&,0>(v29, (long long **)&v39, &v36);
  std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::destroy((uint64_t)v33, v34);
  v31[0] = (long long *)&v36;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)v31);
  v31[0] = (long long *)&v39;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)v31);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v41);
  v41[0] = (long long *)&v40;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)v41);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v43);
  uint64_t v28 = (void ***)std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v45);
  *(void *)&v45[0] = &v47;
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100](v28);
  if (v50) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v50);
  }
  if (v52) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v52);
  }
}

void sub_20F497A28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,void **a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
  a30 = (void **)&a27;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&a30);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&a35);
  unint64_t v37 = (void ***)std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(v35 - 192);
  *(void *)(v35 - 192) = v35 - 152;
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100](v37);
  unint64_t v38 = *(std::__shared_weak_count **)(v35 - 120);
  if (v38) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v38);
  }
  std::vector<std::string> v39 = *(std::__shared_weak_count **)(v35 - 104);
  if (v39) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v39);
  }
  _Unwind_Resume(a1);
}

void **std::pair<std::vector<std::string>,std::vector<std::string>>::~pair(void **a1)
{
  BOOL v3 = a1 + 3;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v3);
  BOOL v3 = a1;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v3);
  return a1;
}

void MIL::Transform::ProgramTransformer::ProgramTransformerImpl::GetAllConsumedVariableNames(MIL::Transform::ProgramTransformer::ProgramTransformerImpl *this@<X0>, unsigned __int8 **a2@<X1>, uint64_t a3@<X8>)
{
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_DWORD *)(a3 + 32) = 1065353216;
  MIL::Builder::OperationBuilder::GetParameterNames(a2, (uint64_t)&v30);
  for (unint64_t i = (const void **)v31; i; unint64_t i = (const void **)*i)
  {
    uint64_t NumArguments = MIL::Builder::OperationBuilder::GetNumArguments((uint64_t)a2, i + 2);
    if (NumArguments)
    {
      for (uint64_t j = 0; j != NumArguments; ++j)
      {
        ArgumentForuint64_t Parameter = (MIL::Builder::Variable::VariableImpl **)MIL::Builder::OperationBuilder::GetArgumentForParameter((uint64_t)a2, (uint64_t)(i + 2), j);
        uint64_t Name = (unsigned __int8 *)MIL::Builder::Variable::TryGetName(ArgumentForParameter);
        if (Name) {
          std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>(a3, Name, (uint64_t)Name);
        }
      }
    }
  }
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&v30);
  uint64_t BlocksRef = (uint64_t *)MIL::Builder::OperationBuilder::GetBlocksRef((MIL::Builder::OperationBuilder *)a2);
  uint64_t v12 = *BlocksRef;
  uint64_t v26 = BlocksRef[1];
  if (*BlocksRef != v26)
  {
    do
    {
      uint64_t v14 = *(MIL::Builder::BlockBuilder::BlockBuilderImpl ***)v12;
      unint64_t v13 = *(std::__shared_weak_count **)(v12 + 8);
      if (v13) {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      unint64_t v27 = v13;
      long long v30 = 0u;
      long long v31 = 0u;
      int v32 = 1065353216;
      MIL::Builder::BlockBuilder::GetInputNames(v14, (std::vector<std::string> *)&v28);
      std::string::size_type size = v28.__r_.__value_.__l.__size_;
      for (unint64_t k = (unsigned __int8 *)v28.__r_.__value_.__r.__words[0]; k != (unsigned __int8 *)size; k += 24)
        std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t)&v30, k, (uint64_t)k);
      v29[0] = (void **)&v28;
      std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](v29);
      MIL::Builder::BlockBuilder::GetOperations((MIL::Builder::BlockBuilder *)v14, v29);
      uint64_t v18 = v29[0];
      unint64_t v17 = v29[1];
      while (v18 != v17)
      {
        float v20 = (MIL::Builder::OperationBuilder::OperationBuilderImpl **)*v18;
        float v19 = (std::__shared_weak_count *)v18[1];
        if (v19) {
          atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        for (unint64_t m = 0; m < MIL::Builder::OperationBuilder::GetNumOutputs((MIL::Builder::OperationBuilder *)v20); ++m)
        {
          Outputuint64_t Name = (unsigned __int8 *)MIL::Builder::OperationBuilder::GetOutputName(v20, m);
          std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t)&v30, OutputName, (uint64_t)OutputName);
        }
        MIL::Transform::ProgramTransformer::ProgramTransformerImpl::GetAllConsumedVariableNames((uint64_t *)&v28, this, (const MIL::Builder::OperationBuilder *)v20);
        unint64_t v23 = (unsigned __int8 *)v28.__r_.__value_.__r.__words[2];
        if (v28.__r_.__value_.__r.__words[2])
        {
          do
          {
            if (!std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(&v30, v23 + 16))std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>(a3, v23 + 16, (uint64_t)(v23 + 16)); {
            unint64_t v23 = *(unsigned __int8 **)v23;
            }
          }
          while (v23);
        }
        std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&v28);
        if (v19) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v19);
        }
        v18 += 2;
      }
      v28.__r_.__value_.__r.__words[0] = (std::string::size_type)v29;
      std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v28);
      MIL::Builder::BlockBuilder::GetOutputNames((MIL::Builder::BlockBuilder *)v14, &v28);
      std::string::size_type v24 = v28.__r_.__value_.__l.__size_;
      for (n = (unsigned __int8 *)v28.__r_.__value_.__r.__words[0]; n != (unsigned __int8 *)v24; n += 24)
      {
        if (!std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(&v30, n))std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>(a3, n, (uint64_t)n); {
      }
        }
      v29[0] = (void **)&v28;
      std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](v29);
      std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&v30);
      if (v27) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v27);
      }
      v12 += 16;
    }
    while (v12 != v26);
  }
}

void sub_20F497E14(_Unwind_Exception *a1)
{
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

uint64_t anonymous namespace'::ReorderSubProgramOutputs(std::string **a1, uint64_t *a2)
{
  memset(v23, 0, sizeof(v23));
  int v24 = 1065353216;
  uint64_t v3 = *a2;
  if (a2[1] != *a2)
  {
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    do
    {
      float v20 = (long long *)(v3 + v5);
      *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v23, (unsigned __int8 *)(v3 + v5), (uint64_t)&std::piecewise_construct, &v20)+ 5) = v6++;
      uint64_t v3 = *a2;
      v5 += 24;
    }
    while (v6 < 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3));
  }
  float v20 = 0;
  BOOL v21 = 0;
  unint64_t v22 = 0;
  uint64_t v7 = *a1;
  uint64_t v8 = a1[1];
  if (*a1 == v8)
  {
    uint64_t v12 = 0;
    unint64_t v13 = 0;
  }
  else
  {
    do
    {
      if (std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v23, (unsigned __int8 *)v7))
      {
        uint64_t v9 = v21;
        if ((unint64_t)v21 >= v22)
        {
          unint64_t v11 = (std::string *)std::vector<std::string>::__push_back_slow_path<std::string const&>((uint64_t *)&v20, (long long *)v7);
        }
        else
        {
          if (SHIBYTE(v7->__r_.__value_.__r.__words[2]) < 0)
          {
            std::string::__init_copy_ctor_external(v21, v7->__r_.__value_.__l.__data_, v7->__r_.__value_.__l.__size_);
          }
          else
          {
            long long v10 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
            v21->__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v9->__r_.__value_.__l.__data_ = v10;
          }
          unint64_t v11 = v9 + 1;
        }
        BOOL v21 = v11;
      }
      ++v7;
    }
    while (v7 != v8);
    uint64_t v12 = v20;
    unint64_t v13 = v21;
  }
  unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * (((char *)v13 - (char *)v12) >> 3);
  if (v14 >= 2)
  {
    uint64_t v25 = v23;
    unint64_t v15 = 126 - 2 * __clz(v14);
    uint64_t v16 = v13 == (std::string *)v12 ? 0 : v15;
    unint64_t v17 = *a1;
    if (*a1 != a1[1])
    {
      uint64_t v18 = (const std::string *)v20;
      do
      {
        if (std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v23, (unsigned __int8 *)v17))
        {
          std::string::operator=(v17, v18++);
        }
        ++v17;
      }
      while (v17 != a1[1]);
    }
  }
  uint64_t v26 = &v20;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v26);
  return std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v23);
}

void sub_20F498098(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  *(void *)(v2 - 56) = va;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)(v2 - 56));
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)va1);
  _Unwind_Resume(a1);
}

void std::vector<std::string>::resize(std::vector<std::string> *this, std::vector<std::string>::size_type __sz)
{
  std::vector<std::string>::pointer end = this->__end_;
  std::vector<std::string>::size_type v4 = 0xAAAAAAAAAAAAAAABLL * (((char *)end - (char *)this->__begin_) >> 3);
  BOOL v5 = __sz >= v4;
  std::vector<std::string>::size_type v6 = __sz - v4;
  if (v6 != 0 && v5)
  {
    std::vector<std::string>::__append(this, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = &this->__begin_[__sz];
    while (end != v7)
    {
      if (SHIBYTE(end[-1].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(end[-1].__r_.__value_.__l.__data_);
      }
      --end;
    }
    this->__end_ = v7;
  }
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1, unsigned __int8 *a2, uint64_t a3, long long **a4)
{
  uint64_t v8 = (void *)(a1 + 24);
  unint64_t v9 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  unint64_t v10 = v9;
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    unint64_t v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v4 = v9;
      if (v9 >= v11) {
        unint64_t v4 = v9 % v11;
      }
    }
    else
    {
      unint64_t v4 = (v11 - 1) & v9;
    }
    unint64_t v14 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v4);
    if (v14)
    {
      for (unint64_t i = *v14; i; unint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v16 = *((void *)i + 1);
        if (v16 == v10)
        {
          if (std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2)) {
            return i;
          }
        }
        else
        {
          if (v13 > 1)
          {
            if (v16 >= v11) {
              v16 %= v11;
            }
          }
          else
          {
            v16 &= v11 - 1;
          }
          if (v16 != v4) {
            break;
          }
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1, v10, a4, (uint64_t)v26);
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v18 = *(float *)(a1 + 32);
  if (!v11 || (float)(v18 * (float)v11) < v17)
  {
    BOOL v19 = 1;
    if (v11 >= 3) {
      BOOL v19 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v11);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v22);
    unint64_t v11 = *(void *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11) {
        unint64_t v4 = v10 % v11;
      }
      else {
        unint64_t v4 = v10;
      }
    }
    else
    {
      unint64_t v4 = (v11 - 1) & v10;
    }
  }
  unint64_t v23 = *(void **)(*(void *)a1 + 8 * v4);
  if (v23)
  {
    *(void *)v26[0] = *v23;
    *unint64_t v23 = v26[0];
  }
  else
  {
    *(void *)v26[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v26[0];
    *(void *)(*(void *)a1 + 8 * v4) = a1 + 16;
    if (*(void *)v26[0])
    {
      unint64_t v24 = *(void *)(*(void *)v26[0] + 8);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v24 >= v11) {
          v24 %= v11;
        }
      }
      else
      {
        v24 &= v11 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v24) = v26[0];
    }
  }
  unint64_t i = (unsigned __int8 *)v26[0];
  ++*v8;
  return i;
}

void sub_20F4983EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void **__p, uint64_t a13)
{
  if (__p) {
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:ne180100]((uint64_t)&a13, __p);
  }
  _Unwind_Resume(exception_object);
}

void std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1@<X0>, uint64_t a2@<X1>, long long **a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  uint64_t v8 = operator new(0x30uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *(unsigned char *)(a4 + 16) = 0;
  *uint64_t v8 = 0;
  v8[1] = a2;
  unint64_t v9 = (std::string *)(v8 + 2);
  unint64_t v10 = *a3;
  if (*((char *)*a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)v10, *((void *)v10 + 1));
  }
  else
  {
    long long v11 = *v10;
    v8[4] = *((void *)v10 + 2);
    *(_OWORD *)&v9->__r_.__value_.__l.__data_ = v11;
  }
  v8[5] = 0;
  *(unsigned char *)(a4 + 16) = 1;
}

void sub_20F4984A0(_Unwind_Exception *a1)
{
  void *v1 = 0;
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>(uint64_t **a1, const void **a2, uint64_t a3)
{
  BOOL v5 = (uint64_t **)std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__find_equal<std::string>((uint64_t)a1, &v8, a2);
  unint64_t result = *v5;
  if (!*v5)
  {
    std::__tree<std::string>::__construct_node<std::string const&>((uint64_t)a1, a3, (uint64_t)&v7);
    std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::__insert_node_at(a1, v8, v5, v7);
    return v7;
  }
  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,anonymous namespace'::ReorderSubProgramOutputs(std::vector<std::string> &,std::vector<std::string> const&)::$_0 &,std::string*,false>(unint64_t a1, _OWORD *a2, uint64_t *a3, uint64_t a4, char a5)
{
  uint64_t v184 = *MEMORY[0x263EF8340];
  while (2)
  {
    uint64_t v173 = (uint64_t)a2 - 24;
    unint64_t v176 = (unint64_t)a2;
    uint64_t v168 = (uint64_t)a2 - 72;
    uint64_t v169 = (uint64_t)(a2 - 3);
    unint64_t v10 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v10;
          uint64_t v11 = (uint64_t)a2 - v10;
          unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)a2 - v10) >> 3);
          if (v6 || !v5)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                uint64_t v76 = *a3;
                *(void *)&long long v180 = v173;
                unint64_t v77 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v76, (unsigned __int8 *)v173, (uint64_t)&std::piecewise_construct, (long long **)&v180)+ 5);
                uint64_t v78 = *a3;
                *(void *)&long long v180 = a1;
                if (v77 < *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v78, (unsigned __int8 *)a1, (uint64_t)&std::piecewise_construct, (long long **)&v180)+ 5))
                {
                  long long v79 = *(_OWORD *)a1;
                  uint64_t v181 = *(void *)(a1 + 16);
                  long long v180 = v79;
                  long long v80 = *(_OWORD *)v173;
                  *(void *)(a1 + 16) = *(void *)(v173 + 16);
                  *(_OWORD *)a1 = v80;
                  long long v81 = v180;
                  *(void *)(v173 + 16) = v181;
                  *(_OWORD *)uint64_t v173 = v81;
                }
                break;
              case 3uLL:
                break;
              case 4uLL:
                break;
              case 5uLL:
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v11 <= 575)
          {
            if (a5)
            {
              if ((_OWORD *)a1 != a2)
              {
                uint64_t v82 = (unsigned __int8 *)(a1 + 24);
                if ((_OWORD *)(a1 + 24) != a2)
                {
                  uint64_t v83 = 0;
                  uint64_t v84 = (unsigned __int8 *)a1;
                  do
                  {
                    uint64_t v85 = v82;
                    uint64_t v86 = *a3;
                    *(void *)&long long v180 = v82;
                    unint64_t v87 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v86, v82, (uint64_t)&std::piecewise_construct, (long long **)&v180)+ 5);
                    uint64_t v88 = *a3;
                    *(void *)&long long v180 = v84;
                    if (v87 < *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v88, v84, (uint64_t)&std::piecewise_construct, (long long **)&v180)+ 5))
                    {
                      long long v89 = *(_OWORD *)v85;
                      uint64_t v181 = *((void *)v85 + 2);
                      long long v180 = v89;
                      *((void *)v85 + 1) = 0;
                      *((void *)v85 + 2) = 0;
                      *(void *)uint64_t v85 = 0;
                      uint64_t v90 = v83;
                      do
                      {
                        uint64_t v91 = a1 + v90;
                        unint64_t v92 = (void **)(a1 + v90 + 24);
                        if (*(char *)(a1 + v90 + 47) < 0) {
                          operator delete(*v92);
                        }
                        *(_OWORD *)unint64_t v92 = *(_OWORD *)v91;
                        *(void *)(a1 + v90 + 40) = *(void *)(v91 + 16);
                        *(unsigned char *)(v91 + 23) = 0;
                        *(unsigned char *)uint64_t v91 = 0;
                        if (!v90)
                        {
                          uint64_t v97 = a1;
                          goto LABEL_78;
                        }
                        uint64_t v93 = *a3;
                        *(void *)&long long v182 = &v180;
                        unint64_t v94 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v93, (unsigned __int8 *)&v180, (uint64_t)&std::piecewise_construct, (long long **)&v182)+ 5);
                        uint64_t v95 = *a3;
                        *(void *)&long long v182 = a1 + v90 - 24;
                        v90 -= 24;
                      }
                      while (v94 < *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v95, (unsigned __int8 *)v182, (uint64_t)&std::piecewise_construct, (long long **)&v182)+ 5));
                      int v96 = *(char *)(a1 + v90 + 47);
                      uint64_t v97 = a1 + v90 + 24;
                      if (v96 < 0) {
                        operator delete(*(void **)v97);
                      }
LABEL_78:
                      long long v98 = v180;
                      *(void *)(v97 + 16) = v181;
                      *(_OWORD *)uint64_t v97 = v98;
                    }
                    uint64_t v82 = v85 + 24;
                    v83 += 24;
                    uint64_t v84 = v85;
                  }
                  while (v85 + 24 != (unsigned __int8 *)v176);
                }
              }
            }
            else if ((_OWORD *)a1 != a2)
            {
              unint64_t v152 = (unsigned __int8 *)(a1 + 24);
              if ((_OWORD *)(a1 + 24) != a2)
              {
                unint64_t v153 = a1 - 24;
                do
                {
                  uint64_t v154 = v152;
                  uint64_t v155 = *a3;
                  *(void *)&long long v180 = v152;
                  unint64_t v156 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v155, v152, (uint64_t)&std::piecewise_construct, (long long **)&v180)+ 5);
                  uint64_t v157 = *a3;
                  *(void *)&long long v180 = a1;
                  if (v156 < *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v157, (unsigned __int8 *)a1, (uint64_t)&std::piecewise_construct, (long long **)&v180)+ 5))
                  {
                    long long v158 = *(_OWORD *)v154;
                    uint64_t v181 = *((void *)v154 + 2);
                    long long v180 = v158;
                    *((void *)v154 + 1) = 0;
                    *((void *)v154 + 2) = 0;
                    *(void *)uint64_t v154 = 0;
                    unint64_t v159 = v153;
                    do
                    {
                      v160 = (void **)(v159 + 48);
                      if (*(char *)(v159 + 71) < 0) {
                        operator delete(*v160);
                      }
                      *(_OWORD *)v160 = *(_OWORD *)(v159 + 24);
                      *(void *)(v159 + 64) = *(void *)(v159 + 40);
                      *(unsigned char *)(v159 + 47) = 0;
                      *(unsigned char *)(v159 + 24) = 0;
                      uint64_t v161 = *a3;
                      *(void *)&long long v182 = &v180;
                      unint64_t v162 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v161, (unsigned __int8 *)&v180, (uint64_t)&std::piecewise_construct, (long long **)&v182)+ 5);
                      uint64_t v163 = *a3;
                      *(void *)&long long v182 = v159;
                      uint64_t v164 = std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v163, (unsigned __int8 *)v159, (uint64_t)&std::piecewise_construct, (long long **)&v182);
                      v159 -= 24;
                    }
                    while (v162 < *((void *)v164 + 5));
                    int v165 = *(char *)(v159 + 71);
                    unint64_t v166 = v159 + 48;
                    if (v165 < 0) {
                      operator delete(*(void **)v166);
                    }
                    long long v167 = v180;
                    *(void *)(v166 + 16) = v181;
                    *(_OWORD *)unint64_t v166 = v167;
                  }
                  unint64_t v152 = v154 + 24;
                  v153 += 24;
                  a1 = (unint64_t)v154;
                }
                while (v154 + 24 != (unsigned __int8 *)v176);
              }
            }
            return;
          }
          if (!a4)
          {
            if ((_OWORD *)a1 != a2)
            {
              int64_t v99 = (v12 - 2) >> 1;
              v100 = &std::piecewise_construct;
              int64_t v174 = v99;
              do
              {
                int64_t v101 = v99;
                if (v174 >= v99)
                {
                  int64_t v171 = v99;
                  uint64_t v102 = (2 * v99) | 1;
                  unint64_t v103 = a1 + 24 * v102;
                  uint64_t v104 = 2 * v99 + 2;
                  if (v104 < (uint64_t)v12)
                  {
                    uint64_t v105 = *a3;
                    *(void *)&long long v180 = a1 + 24 * v102;
                    unint64_t v106 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v105, (unsigned __int8 *)v180, (uint64_t)v100, (long long **)&v180)+ 5);
                    uint64_t v107 = *a3;
                    *(void *)&long long v180 = v103 + 24;
                    if (v106 < *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v107, (unsigned __int8 *)(v103 + 24), (uint64_t)v100, (long long **)&v180)+ 5))
                    {
                      v103 += 24;
                      uint64_t v102 = v104;
                    }
                  }
                  uint64_t v108 = *a3;
                  *(void *)&long long v180 = v103;
                  unint64_t v109 = a1 + 24 * v171;
                  unint64_t v110 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v108, (unsigned __int8 *)v103, (uint64_t)v100, (long long **)&v180)+ 5);
                  uint64_t v111 = *a3;
                  *(void *)&long long v180 = v109;
                  v112 = std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v111, (unsigned __int8 *)v109, (uint64_t)v100, (long long **)&v180);
                  a2 = (_OWORD *)v176;
                  int64_t v101 = v171;
                  if (v110 >= *((void *)v112 + 5))
                  {
                    long long v113 = *(_OWORD *)v109;
                    uint64_t v181 = *(void *)(v109 + 16);
                    long long v180 = v113;
                    *(void *)(v109 + 8) = 0;
                    *(void *)(v109 + 16) = 0;
                    *(void *)unint64_t v109 = 0;
                    while (1)
                    {
                      unint64_t v114 = v103;
                      if (*(char *)(v109 + 23) < 0) {
                        operator delete(*(void **)v109);
                      }
                      long long v115 = *(_OWORD *)v103;
                      *(void *)(v109 + 16) = *(void *)(v103 + 16);
                      *(_OWORD *)unint64_t v109 = v115;
                      *(unsigned char *)(v103 + 23) = 0;
                      *(unsigned char *)unint64_t v103 = 0;
                      if (v174 < v102) {
                        break;
                      }
                      uint64_t v116 = (2 * v102) | 1;
                      unint64_t v103 = a1 + 24 * v116;
                      uint64_t v102 = 2 * v102 + 2;
                      if (v102 < (uint64_t)v12)
                      {
                        uint64_t v117 = *a3;
                        *(void *)&long long v182 = a1 + 24 * v116;
                        uint64_t v118 = (uint64_t)v100;
                        unint64_t v119 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v117, (unsigned __int8 *)v182, (uint64_t)v100, (long long **)&v182)+ 5);
                        uint64_t v120 = *a3;
                        *(void *)&long long v182 = v103 + 24;
                        if (v119 >= *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v120, (unsigned __int8 *)(v103 + 24), v118, (long long **)&v182)+ 5))uint64_t v102 = v116; {
                        else
                        }
                          v103 += 24;
                        v100 = (void *)v118;
                      }
                      else
                      {
                        uint64_t v102 = v116;
                      }
                      uint64_t v121 = *a3;
                      *(void *)&long long v182 = v103;
                      unint64_t v122 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v121, (unsigned __int8 *)v103, (uint64_t)v100, (long long **)&v182)+ 5);
                      uint64_t v123 = *a3;
                      *(void *)&long long v182 = &v180;
                      unint64_t v109 = v114;
                      if (v122 < *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v123, (unsigned __int8 *)&v180, (uint64_t)v100, (long long **)&v182)+ 5))
                      {
                        if (*(char *)(v114 + 23) < 0) {
                          operator delete(*(void **)v114);
                        }
                        break;
                      }
                    }
                    long long v124 = v180;
                    *(void *)(v114 + 16) = v181;
                    *(_OWORD *)unint64_t v114 = v124;
                    a2 = (_OWORD *)v176;
                    int64_t v101 = v171;
                  }
                }
                int64_t v99 = v101 - 1;
              }
              while (v101);
              int64_t v125 = v11 / 0x18uLL;
              do
              {
                uint64_t v126 = 0;
                unint64_t v127 = a1;
                unint64_t v172 = a2;
                uint64_t v175 = *(void *)a1;
                *(void *)&long long v182 = *(void *)(a1 + 8);
                *(void *)((char *)&v182 + 7) = *(void *)(a1 + 15);
                char v177 = *(unsigned char *)(a1 + 23);
                *(void *)(a1 + 8) = 0;
                *(void *)(a1 + 16) = 0;
                *(void *)a1 = 0;
                do
                {
                  uint64_t v128 = v127 + 24 * v126 + 24;
                  uint64_t v129 = 2 * v126;
                  uint64_t v126 = (2 * v126) | 1;
                  uint64_t v130 = v129 + 2;
                  if (v129 + 2 < v125)
                  {
                    uint64_t v131 = *a3;
                    *(void *)&long long v180 = v128;
                    unint64_t v132 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v131, (unsigned __int8 *)v128, (uint64_t)&std::piecewise_construct, (long long **)&v180)+ 5);
                    uint64_t v133 = *a3;
                    *(void *)&long long v180 = v128 + 24;
                    if (v132 < *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v133, (unsigned __int8 *)(v128 + 24), (uint64_t)&std::piecewise_construct, (long long **)&v180)+ 5))
                    {
                      v128 += 24;
                      uint64_t v126 = v130;
                    }
                  }
                  if (*(char *)(v127 + 23) < 0) {
                    operator delete(*(void **)v127);
                  }
                  long long v134 = *(_OWORD *)v128;
                  *(void *)(v127 + 16) = *(void *)(v128 + 16);
                  *(_OWORD *)unint64_t v127 = v134;
                  *(unsigned char *)(v128 + 23) = 0;
                  *(unsigned char *)uint64_t v128 = 0;
                  unint64_t v127 = v128;
                }
                while (v126 <= (uint64_t)((unint64_t)(v125 - 2) >> 1));
                a2 = (_OWORD *)((char *)v172 - 24);
                if ((_OWORD *)v128 == (_OWORD *)((char *)v172 - 24))
                {
                  *(void *)uint64_t v128 = v175;
                  uint64_t v150 = *(void *)((char *)&v182 + 7);
                  *(void *)(v128 + 8) = v182;
                  *(void *)(v128 + 15) = v150;
                  *(unsigned char *)(v128 + 23) = v177;
                }
                else
                {
                  long long v135 = *a2;
                  *(void *)(v128 + 16) = *((void *)v172 - 1);
                  *(_OWORD *)uint64_t v128 = v135;
                  *((void *)v172 - 3) = v175;
                  uint64_t v136 = v182;
                  *(void *)((char *)v172 - 9) = *(void *)((char *)&v182 + 7);
                  *((void *)v172 - 2) = v136;
                  *((unsigned char *)v172 - 1) = v177;
                  uint64_t v137 = v128 - a1 + 24;
                  if (v137 >= 25)
                  {
                    unint64_t v138 = (v137 / 0x18uLL - 2) >> 1;
                    unint64_t v139 = a1 + 24 * v138;
                    uint64_t v140 = *a3;
                    *(void *)&long long v180 = v139;
                    unint64_t v141 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v140, (unsigned __int8 *)v139, (uint64_t)&std::piecewise_construct, (long long **)&v180)+ 5);
                    uint64_t v142 = *a3;
                    *(void *)&long long v180 = v128;
                    if (v141 < *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v142, (unsigned __int8 *)v128, (uint64_t)&std::piecewise_construct, (long long **)&v180)+ 5))
                    {
                      long long v143 = *(_OWORD *)v128;
                      uint64_t v181 = *(void *)(v128 + 16);
                      long long v180 = v143;
                      *(void *)(v128 + 8) = 0;
                      *(void *)(v128 + 16) = 0;
                      *(void *)uint64_t v128 = 0;
                      while (1)
                      {
                        uint64_t v144 = v139;
                        if (*(char *)(v128 + 23) < 0) {
                          operator delete(*(void **)v128);
                        }
                        long long v145 = *(_OWORD *)v139;
                        *(void *)(v128 + 16) = *(void *)(v139 + 16);
                        *(_OWORD *)uint64_t v128 = v145;
                        *(unsigned char *)(v139 + 23) = 0;
                        *(unsigned char *)unint64_t v139 = 0;
                        if (!v138) {
                          break;
                        }
                        unint64_t v138 = (v138 - 1) >> 1;
                        unint64_t v139 = a1 + 24 * v138;
                        uint64_t v146 = *a3;
                        unint64_t v179 = (long long *)v139;
                        unint64_t v147 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v146, (unsigned __int8 *)v139, (uint64_t)&std::piecewise_construct, &v179)+ 5);
                        uint64_t v148 = *a3;
                        unint64_t v179 = &v180;
                        uint64_t v128 = v144;
                        if (v147 >= *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v148, (unsigned __int8 *)&v180, (uint64_t)&std::piecewise_construct, &v179)+ 5))
                        {
                          if (*(char *)(v144 + 23) < 0) {
                            operator delete(*(void **)v144);
                          }
                          break;
                        }
                      }
                      long long v149 = v180;
                      *(void *)(v144 + 16) = v181;
                      *(_OWORD *)uint64_t v144 = v149;
                    }
                  }
                }
              }
              while (v125-- > 2);
            }
            return;
          }
          unint64_t v13 = v12 >> 1;
          uint64_t v14 = a1 + 24 * (v12 >> 1);
          if ((unint64_t)v11 >= 0xC01)
          {
            unint64_t v10 = a1;
            long long v15 = *(_OWORD *)a1;
            uint64_t v181 = *(void *)(a1 + 16);
            long long v180 = v15;
            long long v16 = *(_OWORD *)v14;
            *(void *)(a1 + 16) = *(void *)(v14 + 16);
            *(_OWORD *)a1 = v16;
            long long v17 = v180;
            *(void *)(v14 + 16) = v181;
            *(_OWORD *)uint64_t v14 = v17;
          }
          else
          {
            unint64_t v10 = a1;
          }
          --a4;
          if (a5) {
            break;
          }
          uint64_t v18 = *a3;
          *(void *)&long long v180 = v10 - 24;
          unint64_t v19 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v18, (unsigned __int8 *)(v10 - 24), (uint64_t)&std::piecewise_construct, (long long **)&v180)+ 5);
          uint64_t v20 = *a3;
          *(void *)&long long v180 = a1;
          unint64_t v10 = a1;
          if (v19 < *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v20, (unsigned __int8 *)a1, (uint64_t)&std::piecewise_construct, (long long **)&v180)+ 5))break; {
          long long v48 = *(_OWORD *)a1;
          }
          uint64_t v183 = *(void *)(a1 + 16);
          long long v182 = v48;
          *(void *)(a1 + 8) = 0;
          *(void *)(a1 + 16) = 0;
          *(void *)a1 = 0;
          uint64_t v49 = *a3;
          *(void *)&long long v180 = &v182;
          unint64_t v50 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v49, (unsigned __int8 *)&v182, (uint64_t)&std::piecewise_construct, (long long **)&v180)+ 5);
          uint64_t v51 = *a3;
          *(void *)&long long v180 = v173;
          a2 = (_OWORD *)v176;
          if (v50 >= *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v51, (unsigned __int8 *)v173, (uint64_t)&std::piecewise_construct, (long long **)&v180)+ 5))
          {
            unint64_t v55 = a1 + 24;
            do
            {
              unint64_t v10 = v55;
              if (v55 >= v176) {
                break;
              }
              uint64_t v56 = *a3;
              *(void *)&long long v180 = &v182;
              unint64_t v57 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v56, (unsigned __int8 *)&v182, (uint64_t)&std::piecewise_construct, (long long **)&v180)+ 5);
              uint64_t v58 = *a3;
              *(void *)&long long v180 = v10;
              unint64_t v59 = std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v58, (unsigned __int8 *)v10, (uint64_t)&std::piecewise_construct, (long long **)&v180);
              unint64_t v55 = v10 + 24;
            }
            while (v57 >= *((void *)v59 + 5));
          }
          else
          {
            do
            {
              uint64_t v52 = *a3;
              *(void *)&long long v180 = &v182;
              v10 += 24;
              unint64_t v53 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v52, (unsigned __int8 *)&v182, (uint64_t)&std::piecewise_construct, (long long **)&v180)+ 5);
              uint64_t v54 = *a3;
              *(void *)&long long v180 = v10;
            }
            while (v53 >= *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v54, (unsigned __int8 *)v10, (uint64_t)&std::piecewise_construct, (long long **)&v180)+ 5));
          }
          unint64_t v60 = v176;
          if (v10 < v176)
          {
            unint64_t v60 = v176;
            do
            {
              uint64_t v61 = *a3;
              *(void *)&long long v180 = &v182;
              v60 -= 24;
              unint64_t v62 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v61, (unsigned __int8 *)&v182, (uint64_t)&std::piecewise_construct, (long long **)&v180)+ 5);
              uint64_t v63 = *a3;
              *(void *)&long long v180 = v60;
            }
            while (v62 < *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v63, (unsigned __int8 *)v60, (uint64_t)&std::piecewise_construct, (long long **)&v180)+ 5));
          }
          while (v10 < v60)
          {
            long long v64 = *(_OWORD *)v10;
            uint64_t v181 = *(void *)(v10 + 16);
            long long v180 = v64;
            long long v65 = *(_OWORD *)v60;
            *(void *)(v10 + 16) = *(void *)(v60 + 16);
            *(_OWORD *)unint64_t v10 = v65;
            long long v66 = v180;
            *(void *)(v60 + 16) = v181;
            *(_OWORD *)unint64_t v60 = v66;
            do
            {
              uint64_t v67 = *a3;
              *(void *)&long long v180 = &v182;
              v10 += 24;
              unint64_t v68 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v67, (unsigned __int8 *)&v182, (uint64_t)&std::piecewise_construct, (long long **)&v180)+ 5);
              uint64_t v69 = *a3;
              *(void *)&long long v180 = v10;
            }
            while (v68 >= *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v69, (unsigned __int8 *)v10, (uint64_t)&std::piecewise_construct, (long long **)&v180)+ 5));
            do
            {
              uint64_t v70 = *a3;
              *(void *)&long long v180 = &v182;
              v60 -= 24;
              unint64_t v71 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v70, (unsigned __int8 *)&v182, (uint64_t)&std::piecewise_construct, (long long **)&v180)+ 5);
              uint64_t v72 = *a3;
              *(void *)&long long v180 = v60;
            }
            while (v71 < *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v72, (unsigned __int8 *)v60, (uint64_t)&std::piecewise_construct, (long long **)&v180)+ 5));
          }
          int64_t v73 = (long long *)(v10 - 24);
          BOOL v5 = v10 - 24 >= a1;
          BOOL v6 = v10 - 24 == a1;
          if (v10 - 24 == a1)
          {
            if (*(char *)(v10 - 1) < 0) {
              operator delete(*(void **)a1);
            }
          }
          else
          {
            if (*(char *)(a1 + 23) < 0) {
              operator delete(*(void **)a1);
            }
            long long v74 = *v73;
            *(void *)(a1 + 16) = *(void *)(v10 - 8);
            *(_OWORD *)a1 = v74;
            *(unsigned char *)(v10 - 1) = 0;
            *(unsigned char *)(v10 - 24) = 0;
          }
          a5 = 0;
          long long v75 = v182;
          *(void *)(v10 - 8) = v183;
          *int64_t v73 = v75;
        }
        uint64_t v21 = 0;
        long long v22 = *(_OWORD *)v10;
        uint64_t v183 = *(void *)(v10 + 16);
        long long v182 = v22;
        *(void *)(v10 + 8) = 0;
        *(void *)(v10 + 16) = 0;
        *(void *)unint64_t v10 = 0;
        do
        {
          uint64_t v23 = *a3;
          *(void *)&long long v180 = v10 + v21 + 24;
          unint64_t v24 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v23, (unsigned __int8 *)v180, (uint64_t)&std::piecewise_construct, (long long **)&v180)+ 5);
          uint64_t v25 = *a3;
          *(void *)&long long v180 = &v182;
          v21 += 24;
        }
        while (v24 < *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v25, (unsigned __int8 *)&v182, (uint64_t)&std::piecewise_construct, (long long **)&v180)+ 5));
        unint64_t v26 = v10 + v21;
        unint64_t v27 = (unsigned __int8 *)v176;
        if (v21 == 24)
        {
          unint64_t v27 = (unsigned __int8 *)v176;
          do
          {
            if (v26 >= (unint64_t)v27) {
              break;
            }
            v27 -= 24;
            uint64_t v31 = *a3;
            *(void *)&long long v180 = v27;
            unint64_t v32 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v31, v27, (uint64_t)&std::piecewise_construct, (long long **)&v180)+ 5);
            uint64_t v33 = *a3;
            *(void *)&long long v180 = &v182;
          }
          while (v32 >= *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v33, (unsigned __int8 *)&v182, (uint64_t)&std::piecewise_construct, (long long **)&v180)+ 5));
        }
        else
        {
          do
          {
            v27 -= 24;
            uint64_t v28 = *a3;
            *(void *)&long long v180 = v27;
            unint64_t v29 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v28, v27, (uint64_t)&std::piecewise_construct, (long long **)&v180)+ 5);
            uint64_t v30 = *a3;
            *(void *)&long long v180 = &v182;
          }
          while (v29 >= *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v30, (unsigned __int8 *)&v182, (uint64_t)&std::piecewise_construct, (long long **)&v180)+ 5));
        }
        unint64_t v10 = v26;
        if (v26 < (unint64_t)v27)
        {
          uint64_t v34 = v27;
          do
          {
            long long v35 = *(_OWORD *)v10;
            uint64_t v181 = *(void *)(v10 + 16);
            long long v180 = v35;
            long long v36 = *(_OWORD *)v34;
            *(void *)(v10 + 16) = *((void *)v34 + 2);
            *(_OWORD *)unint64_t v10 = v36;
            long long v37 = v180;
            *((void *)v34 + 2) = v181;
            *(_OWORD *)uint64_t v34 = v37;
            do
            {
              v10 += 24;
              uint64_t v38 = *a3;
              *(void *)&long long v180 = v10;
              unint64_t v39 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v38, (unsigned __int8 *)v10, (uint64_t)&std::piecewise_construct, (long long **)&v180)+ 5);
              uint64_t v40 = *a3;
              *(void *)&long long v180 = &v182;
            }
            while (v39 < *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v40, (unsigned __int8 *)&v182, (uint64_t)&std::piecewise_construct, (long long **)&v180)+ 5));
            do
            {
              v34 -= 24;
              uint64_t v41 = *a3;
              *(void *)&long long v180 = v34;
              unint64_t v42 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v41, v34, (uint64_t)&std::piecewise_construct, (long long **)&v180)+ 5);
              uint64_t v43 = *a3;
              *(void *)&long long v180 = &v182;
            }
            while (v42 >= *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v43, (unsigned __int8 *)&v182, (uint64_t)&std::piecewise_construct, (long long **)&v180)+ 5));
          }
          while (v10 < (unint64_t)v34);
        }
        int v44 = (long long *)(v10 - 24);
        if (v10 - 24 == a1)
        {
          if (*(char *)(v10 - 1) < 0) {
            operator delete(*(void **)a1);
          }
        }
        else
        {
          if (*(char *)(a1 + 23) < 0) {
            operator delete(*(void **)a1);
          }
          long long v45 = *v44;
          *(void *)(a1 + 16) = *(void *)(v10 - 8);
          *(_OWORD *)a1 = v45;
          *(unsigned char *)(v10 - 1) = 0;
          *(unsigned char *)(v10 - 24) = 0;
        }
        long long v46 = v182;
        *(void *)(v10 - 8) = v183;
        long long *v44 = v46;
        if (v26 >= (unint64_t)v27) {
          break;
        }
LABEL_35:
        a5 = 0;
        a2 = (_OWORD *)v176;
      }
      {
        break;
      }
      a2 = (_OWORD *)v176;
      if (!v47) {
        goto LABEL_35;
      }
    }
    a2 = (_OWORD *)(v10 - 24);
    if (!v47) {
      continue;
    }
    break;
  }
}

void sub_20F4995B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a29 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

__n128 std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,anonymous namespace'::ReorderSubProgramOutputs(std::vector<std::string> &,std::vector<std::string> const&)::$_0 &,std::string*,0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v12 = *a6;
  v36[0] = (long long *)a5;
  unint64_t v13 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v12, (unsigned __int8 *)a5, (uint64_t)&std::piecewise_construct, v36)+ 5);
  uint64_t v14 = *a6;
  v36[0] = (long long *)a4;
  if (v13 < *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v14, (unsigned __int8 *)a4, (uint64_t)&std::piecewise_construct, v36)+ 5))
  {
    uint64_t v16 = *(void *)(a4 + 16);
    long long v17 = *(_OWORD *)a4;
    uint64_t v18 = *(void *)(a5 + 16);
    *(_OWORD *)a4 = *(_OWORD *)a5;
    *(void *)(a4 + 16) = v18;
    *(_OWORD *)a5 = v17;
    *(void *)(a5 + 16) = v16;
    uint64_t v19 = *a6;
    v36[0] = (long long *)a4;
    unint64_t v20 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v19, (unsigned __int8 *)a4, (uint64_t)&std::piecewise_construct, v36)+ 5);
    uint64_t v21 = *a6;
    v36[0] = (long long *)a3;
    if (v20 < *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v21, (unsigned __int8 *)a3, (uint64_t)&std::piecewise_construct, v36)+ 5))
    {
      uint64_t v22 = *(void *)(a3 + 16);
      long long v23 = *(_OWORD *)a3;
      uint64_t v24 = *(void *)(a4 + 16);
      *(_OWORD *)a3 = *(_OWORD *)a4;
      *(void *)(a3 + 16) = v24;
      *(_OWORD *)a4 = v23;
      *(void *)(a4 + 16) = v22;
      uint64_t v25 = *a6;
      v36[0] = (long long *)a3;
      unint64_t v26 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v25, (unsigned __int8 *)a3, (uint64_t)&std::piecewise_construct, v36)+ 5);
      uint64_t v27 = *a6;
      v36[0] = (long long *)a2;
      if (v26 < *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v27, (unsigned __int8 *)a2, (uint64_t)&std::piecewise_construct, v36)+ 5))
      {
        uint64_t v28 = *(void *)(a2 + 16);
        long long v29 = *(_OWORD *)a2;
        uint64_t v30 = *(void *)(a3 + 16);
        *(_OWORD *)a2 = *(_OWORD *)a3;
        *(void *)(a2 + 16) = v30;
        *(_OWORD *)a3 = v29;
        *(void *)(a3 + 16) = v28;
        uint64_t v31 = *a6;
        v36[0] = (long long *)a2;
        unint64_t v32 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v31, (unsigned __int8 *)a2, (uint64_t)&std::piecewise_construct, v36)+ 5);
        uint64_t v33 = *a6;
        v36[0] = (long long *)a1;
        if (v32 < *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v33, (unsigned __int8 *)a1, (uint64_t)&std::piecewise_construct, v36)+ 5))
        {
          uint64_t v34 = *(void *)(a1 + 16);
          __n128 result = *(__n128 *)a1;
          uint64_t v35 = *(void *)(a2 + 16);
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(void *)(a1 + 16) = v35;
          *(__n128 *)a2 = result;
          *(void *)(a2 + 16) = v34;
        }
      }
    }
  }
  return result;
}

unsigned __int8 *std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,anonymous namespace'::ReorderSubProgramOutputs(std::vector<std::string> &,std::vector<std::string> const&)::$_0 &,std::string*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8 = *a4;
  v37[0] = (long long *)a2;
  unint64_t v9 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v8, (unsigned __int8 *)a2, (uint64_t)&std::piecewise_construct, v37)+ 5);
  uint64_t v10 = *a4;
  v37[0] = (long long *)a1;
  unint64_t v11 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v10, (unsigned __int8 *)a1, (uint64_t)&std::piecewise_construct, v37)+ 5);
  uint64_t v12 = *a4;
  if (v9 >= v11)
  {
    v37[0] = (long long *)a3;
    unint64_t v19 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v12, (unsigned __int8 *)a3, (uint64_t)&std::piecewise_construct, v37)+ 5);
    uint64_t v20 = *a4;
    v37[0] = (long long *)a2;
    __n128 result = std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v20, (unsigned __int8 *)a2, (uint64_t)&std::piecewise_construct, v37);
    if (v19 < *((void *)result + 5))
    {
      uint64_t v21 = *(void *)(a2 + 16);
      long long v22 = *(_OWORD *)a2;
      uint64_t v23 = *(void *)(a3 + 16);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(void *)(a2 + 16) = v23;
      *(_OWORD *)a3 = v22;
      *(void *)(a3 + 16) = v21;
      uint64_t v24 = *a4;
      v37[0] = (long long *)a2;
      unint64_t v25 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v24, (unsigned __int8 *)a2, (uint64_t)&std::piecewise_construct, v37)+ 5);
      uint64_t v26 = *a4;
      v37[0] = (long long *)a1;
      __n128 result = std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v26, (unsigned __int8 *)a1, (uint64_t)&std::piecewise_construct, v37);
      if (v25 < *((void *)result + 5))
      {
        uint64_t v27 = *(void *)(a1 + 16);
        long long v28 = *(_OWORD *)a1;
        uint64_t v29 = *(void *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(void *)(a1 + 16) = v29;
        *(_OWORD *)a2 = v28;
        *(void *)(a2 + 16) = v27;
      }
    }
  }
  else
  {
    v37[0] = (long long *)a3;
    unint64_t v13 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v12, (unsigned __int8 *)a3, (uint64_t)&std::piecewise_construct, v37)+ 5);
    uint64_t v14 = *a4;
    v37[0] = (long long *)a2;
    __n128 result = std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v14, (unsigned __int8 *)a2, (uint64_t)&std::piecewise_construct, v37);
    if (v13 >= *((void *)result + 5))
    {
      uint64_t v30 = *(void *)(a1 + 16);
      long long v31 = *(_OWORD *)a1;
      uint64_t v32 = *(void *)(a2 + 16);
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(void *)(a1 + 16) = v32;
      *(_OWORD *)a2 = v31;
      *(void *)(a2 + 16) = v30;
      uint64_t v33 = *a4;
      v37[0] = (long long *)a3;
      unint64_t v34 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v33, (unsigned __int8 *)a3, (uint64_t)&std::piecewise_construct, v37)+ 5);
      uint64_t v35 = *a4;
      v37[0] = (long long *)a2;
      __n128 result = std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v35, (unsigned __int8 *)a2, (uint64_t)&std::piecewise_construct, v37);
      if (v34 >= *((void *)result + 5)) {
        return result;
      }
      uint64_t v16 = *(void *)(a2 + 16);
      long long v17 = *(_OWORD *)a2;
      uint64_t v36 = *(void *)(a3 + 16);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(void *)(a2 + 16) = v36;
    }
    else
    {
      uint64_t v16 = *(void *)(a1 + 16);
      long long v17 = *(_OWORD *)a1;
      uint64_t v18 = *(void *)(a3 + 16);
      *(_OWORD *)a1 = *(_OWORD *)a3;
      *(void *)(a1 + 16) = v18;
    }
    *(_OWORD *)a3 = v17;
    *(void *)(a3 + 16) = v16;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,anonymous namespace'::ReorderSubProgramOutputs(std::vector<std::string> &,std::vector<std::string> const&)::$_0 &,std::string*>(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = a2;
  uint64_t v6 = (a2 - a1) >> 3;
  BOOL result = 1;
  switch(0xAAAAAAAAAAAAAAABLL * v6)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      uint64_t v8 = (_OWORD *)(a2 - 24);
      uint64_t v9 = *a3;
      *(void *)&long long v31 = a2 - 24;
      unint64_t v10 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v9, (unsigned __int8 *)(a2 - 24), (uint64_t)&std::piecewise_construct, (long long **)&v31)+ 5);
      uint64_t v11 = *a3;
      *(void *)&long long v31 = a1;
      if (v10 < *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v11, (unsigned __int8 *)a1, (uint64_t)&std::piecewise_construct, (long long **)&v31)+ 5))
      {
        uint64_t v12 = *(void *)(a1 + 16);
        long long v13 = *(_OWORD *)a1;
        uint64_t v14 = *(void *)(v4 - 8);
        *(_OWORD *)a1 = *v8;
        *(void *)(a1 + 16) = v14;
        *uint64_t v8 = v13;
        *(void *)(v4 - 8) = v12;
      }
      return 1;
    case 3uLL:
      return 1;
    case 4uLL:
      return 1;
    case 5uLL:
      return 1;
    default:
      long long v15 = (unsigned __int8 *)(a1 + 48);
      uint64_t v16 = a1 + 72;
      if (a1 + 72 == v4) {
        return 1;
      }
      uint64_t v17 = 0;
      int v18 = 0;
      uint64_t v30 = v4;
      break;
  }
  while (1)
  {
    uint64_t v19 = *a3;
    *(void *)&long long v31 = v16;
    unint64_t v20 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v19, (unsigned __int8 *)v16, (uint64_t)&std::piecewise_construct, (long long **)&v31)+ 5);
    uint64_t v21 = *a3;
    *(void *)&long long v31 = v15;
    if (v20 < *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v21, v15, (uint64_t)&std::piecewise_construct, (long long **)&v31)+ 5))
    {
      long long v31 = *(_OWORD *)v16;
      uint64_t v32 = *(void *)(v16 + 16);
      *(void *)(v16 + 8) = 0;
      *(void *)(v16 + 16) = 0;
      *(void *)uint64_t v16 = 0;
      uint64_t v22 = v17;
      do
      {
        uint64_t v23 = a1 + v22;
        uint64_t v24 = (void **)(a1 + v22 + 72);
        if (*(char *)(a1 + v22 + 95) < 0) {
          operator delete(*v24);
        }
        *(_OWORD *)uint64_t v24 = *(_OWORD *)(v23 + 48);
        *(void *)(a1 + v22 + 88) = *(void *)(v23 + 64);
        *(unsigned char *)(v23 + 71) = 0;
        *(unsigned char *)(v23 + 48) = 0;
        if (v22 == -48)
        {
          uint64_t v29 = a1;
          goto LABEL_15;
        }
        uint64_t v25 = *a3;
        uint64_t v33 = (unsigned __int8 *)&v31;
        unint64_t v26 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v25, (unsigned __int8 *)&v31, (uint64_t)&std::piecewise_construct, (long long **)&v33)+ 5);
        uint64_t v27 = *a3;
        uint64_t v33 = (unsigned __int8 *)(a1 + v22 + 24);
        v22 -= 24;
      }
      while (v26 < *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v27, v33, (uint64_t)&std::piecewise_construct, (long long **)&v33)+ 5));
      int v28 = *(char *)(a1 + v22 + 95);
      uint64_t v29 = a1 + v22 + 72;
      if (v28 < 0) {
        operator delete(*(void **)v29);
      }
LABEL_15:
      uint64_t v4 = v30;
      *(_OWORD *)uint64_t v29 = v31;
      *(void *)(v29 + 16) = v32;
      if (++v18 == 8) {
        return v16 + 24 == v30;
      }
    }
    long long v15 = (unsigned __int8 *)v16;
    v17 += 24;
    v16 += 24;
    if (v16 == v4) {
      return 1;
    }
  }
}

void sub_20F499DB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

__n128 std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,anonymous namespace'::ReorderSubProgramOutputs(std::vector<std::string> &,std::vector<std::string> const&)::$_0 &,std::string*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v10 = *a5;
  v28[0] = (long long *)a4;
  unint64_t v11 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v10, (unsigned __int8 *)a4, (uint64_t)&std::piecewise_construct, v28)+ 5);
  uint64_t v12 = *a5;
  v28[0] = (long long *)a3;
  if (v11 < *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v12, (unsigned __int8 *)a3, (uint64_t)&std::piecewise_construct, v28)+ 5))
  {
    uint64_t v14 = *(void *)(a3 + 16);
    long long v15 = *(_OWORD *)a3;
    uint64_t v16 = *(void *)(a4 + 16);
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(void *)(a3 + 16) = v16;
    *(_OWORD *)a4 = v15;
    *(void *)(a4 + 16) = v14;
    uint64_t v17 = *a5;
    v28[0] = (long long *)a3;
    unint64_t v18 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v17, (unsigned __int8 *)a3, (uint64_t)&std::piecewise_construct, v28)+ 5);
    uint64_t v19 = *a5;
    v28[0] = (long long *)a2;
    if (v18 < *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v19, (unsigned __int8 *)a2, (uint64_t)&std::piecewise_construct, v28)+ 5))
    {
      uint64_t v20 = *(void *)(a2 + 16);
      long long v21 = *(_OWORD *)a2;
      uint64_t v22 = *(void *)(a3 + 16);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(void *)(a2 + 16) = v22;
      *(_OWORD *)a3 = v21;
      *(void *)(a3 + 16) = v20;
      uint64_t v23 = *a5;
      v28[0] = (long long *)a2;
      unint64_t v24 = *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v23, (unsigned __int8 *)a2, (uint64_t)&std::piecewise_construct, v28)+ 5);
      uint64_t v25 = *a5;
      v28[0] = (long long *)a1;
      if (v24 < *((void *)std::__hash_table<std::__hash_value_type<std::string,unsigned long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v25, (unsigned __int8 *)a1, (uint64_t)&std::piecewise_construct, v28)+ 5))
      {
        uint64_t v26 = *(void *)(a1 + 16);
        __n128 result = *(__n128 *)a1;
        uint64_t v27 = *(void *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(void *)(a1 + 16) = v27;
        *(__n128 *)a2 = result;
        *(void *)(a2 + 16) = v26;
      }
    }
  }
  return result;
}

void std::vector<std::string>::__append(std::vector<std::string> *this, std::vector<std::string>::size_type __n)
{
  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  BOOL v5 = value;
  uint64_t v7 = p_end_cap[-1].__value_;
  if (0xAAAAAAAAAAAAAAABLL * (((char *)value - (char *)v7) >> 3) >= __n)
  {
    if (__n)
    {
      size_t v13 = 24 * ((24 * __n - 24) / 0x18) + 24;
      bzero(p_end_cap[-1].__value_, v13);
      uint64_t v7 = (std::string *)((char *)v7 + v13);
    }
    this->__end_ = v7;
  }
  else
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * (((char *)v7 - (char *)this->__begin_) >> 3);
    unint64_t v9 = v8 + __n;
    if (v8 + __n > 0xAAAAAAAAAAAAAAALL) {
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (((char *)v5 - (char *)this->__begin_) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x555555555555555) {
      unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v9;
    }
    __v.__end_cap_.__value_ = (std::allocator<std::string> *)p_end_cap;
    if (v11) {
      uint64_t v12 = (std::string *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)p_end_cap, v11);
    }
    else {
      uint64_t v12 = 0;
    }
    __v.__first_ = v12;
    __v.__begin_ = v12 + v8;
    __v.__end_cap_.__value_ = &v12[v11];
    size_t v14 = 24 * ((24 * __n - 24) / 0x18) + 24;
    bzero(__v.__begin_, v14);
    __v.__end_ = (std::__split_buffer<std::string>::pointer)((char *)__v.__begin_ + v14);
    std::vector<std::string>::__swap_out_circular_buffer(this, &__v);
    std::__split_buffer<std::string>::~__split_buffer(&__v);
  }
}

void sub_20F49A0E8(_Unwind_Exception *a1, std::__split_buffer<std::string> *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__tree_const_iterator<std::string,std::__tree_node<std::string,void *> *,long>,std::__tree_const_iterator<std::string,std::__tree_node<std::string,void *> *,long>,std::string*>(int a1, void *a2, void *a3, std::string *this)
{
  BOOL v5 = a2;
  if (a2 != a3)
  {
    do
    {
      std::string::operator=(this, (const std::string *)(v5 + 4));
      uint64_t v7 = (void *)v5[1];
      if (v7)
      {
        do
        {
          unint64_t v8 = v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          unint64_t v8 = (void *)v5[2];
          BOOL v9 = *v8 == (void)v5;
          BOOL v5 = v8;
        }
        while (!v9);
      }
      ++this;
      BOOL v5 = v8;
    }
    while (v8 != a3);
    return a3;
  }
  return v5;
}

std::string *std::pair<std::vector<std::string>,std::vector<std::string>>::pair[abi:ne180100]<std::vector<std::string>&,std::vector<std::string>&,0>(std::string *a1, long long **a2, long long **a3)
{
  a1->__r_.__value_.__r.__words[0] = 0;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(a1, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * (((char *)a2[1] - (char *)*a2) >> 3));
  a1[1].__r_.__value_.__r.__words[0] = 0;
  a1[1].__r_.__value_.__l.__size_ = 0;
  a1[1].__r_.__value_.__r.__words[2] = 0;
  std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(a1 + 1, *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * (((char *)a3[1] - (char *)*a3) >> 3));
  return a1;
}

void sub_20F49A208(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

void *std::vector<unsigned long>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<unsigned long long>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_20F49A27C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void MIL::Transform::ProgramTransformer::ProgramTransformerImpl::GetInputsAndOutputs(uint64_t *a1@<X0>, unsigned __int8 *a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  MIL::Builder::ProgramBuilder::GetFunction(a1[4], a2, &v55);
  uint64_t v7 = v55;
  unint64_t v8 = (unsigned __int8 *)MIL::Builder::FunctionBuilder::SelectedSpecialization(v55);
  MIL::Builder::FunctionBuilder::GetBlock((uint64_t)v7, v8, &v53);
  MIL::Builder::BlockBuilder::GetOperations(v53, &v51);
  uint64_t v49 = 0;
  std::vector<std::string>::size_type v50 = 0;
  *(void *)long long v48 = &v49;
  BOOL v9 = a3 + 1;
  if (a3 + 1 == (void *)*a3)
  {
    std::vector<std::string>::size_type v21 = 0;
  }
  else
  {
    unint64_t v10 = a3 + 1;
    do
    {
      unint64_t v11 = (void *)*v10;
      uint64_t v12 = v10;
      if (*v10)
      {
        do
        {
          size_t v13 = v11;
          unint64_t v11 = (void *)v11[1];
        }
        while (v11);
      }
      else
      {
        do
        {
          size_t v13 = (void *)v12[2];
          BOOL v14 = *v13 == (void)v12;
          uint64_t v12 = v13;
        }
        while (v14);
      }
      long long v15 = (unsigned __int8 ***)(v51 + 16 * v13[4]);
      MIL::Transform::ProgramTransformer::ProgramTransformerImpl::GetAllConsumedVariableNames((MIL::Transform::ProgramTransformer::ProgramTransformerImpl *)a1, *v15, (uint64_t)v46);
      for (unint64_t i = v47; i; unint64_t i = (const void **)*i)
        std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t **)v48, i + 2, (uint64_t)(i + 2));
      std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v46);
      for (unint64_t j = 0; j < MIL::Builder::OperationBuilder::GetNumOutputs((MIL::Builder::OperationBuilder *)*v15); ++j)
      {
        Outputuint64_t Name = (const void **)MIL::Builder::OperationBuilder::GetOutputName((MIL::Builder::OperationBuilder::OperationBuilderImpl **)*v15, j);
        std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::__erase_unique<std::string>((uint64_t **)v48, OutputName);
      }
      uint64_t v19 = (void *)*v10;
      if (*v10)
      {
        do
        {
          uint64_t v20 = v19;
          uint64_t v19 = (void *)v19[1];
        }
        while (v19);
      }
      else
      {
        do
        {
          uint64_t v20 = (void *)v10[2];
          BOOL v14 = *v20 == (void)v10;
          unint64_t v10 = v20;
        }
        while (v14);
      }
      unint64_t v10 = v20;
    }
    while (v20 != (void *)*a3);
    std::vector<std::string>::size_type v21 = v50;
  }
  std::vector<std::string>::vector(&v45, v21);
  std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__tree_const_iterator<std::string,std::__tree_node<std::string,void *> *,long>,std::__tree_const_iterator<std::string,std::__tree_node<std::string,void *> *,long>,std::string*>((int)v46, *(void **)v48, &v49, v45.__begin_);
  v44[0] = 0;
  v44[1] = 0;
  uint64_t v43 = v44;
  unint64_t v22 = *(void *)(*a3 + 32);
  uint64_t v24 = v51;
  uint64_t v23 = v52;
  while (v22 < (v23 - v24) >> 4)
  {
    uint64_t v25 = (void *)*v9;
    if (!*v9) {
      goto LABEL_32;
    }
    uint64_t v26 = a3 + 1;
    do
    {
      unint64_t v27 = v25[4];
      BOOL v28 = v27 >= v22;
      if (v27 >= v22) {
        uint64_t v29 = v25;
      }
      else {
        uint64_t v29 = v25 + 1;
      }
      if (v28) {
        uint64_t v26 = v25;
      }
      uint64_t v25 = (void *)*v29;
    }
    while (*v29);
    if (v26 == v9 || v22 < v26[4])
    {
LABEL_32:
      MIL::Transform::ProgramTransformer::ProgramTransformerImpl::GetAllConsumedVariableNames((MIL::Transform::ProgramTransformer::ProgramTransformerImpl *)a1, *(unsigned __int8 ***)(v24 + 16 * v22), (uint64_t)v46);
      for (unint64_t k = v47; k; unint64_t k = (const void **)*k)
        std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t **)&v43, k + 2, (uint64_t)(k + 2));
      std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v46);
      uint64_t v24 = v51;
      uint64_t v23 = v52;
    }
    ++v22;
  }
  MIL::Builder::BlockBuilder::GetOutputNames(v53, &v42);
  std::unordered_set<std::string>::unordered_set<std::__wrap_iter<std::string const*>>((uint64_t)v46, (unsigned __int8 *)v42.__r_.__value_.__l.__data_, (unsigned __int8 *)v42.__r_.__value_.__l.__size_);
  long long v40 = 0uLL;
  unint64_t v41 = 0;
  long long v31 = (void *)*a3;
  if ((void *)*a3 != v9)
  {
    do
    {
      unint64_t v32 = 0;
      uint64_t v33 = (MIL::Builder::OperationBuilder::OperationBuilderImpl ***)(v51 + 16 * v31[4]);
      while (v32 < MIL::Builder::OperationBuilder::GetNumOutputs((MIL::Builder::OperationBuilder *)*v33))
      {
        uint64_t v34 = MIL::Builder::OperationBuilder::GetOutputName(*v33, v32);
        if (v44 != (char **)std::__tree<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<MIL::IRBlock>>>>::find<std::string>((uint64_t)&v43, (const void **)v34)|| std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>(v46, (unsigned __int8 *)v34))
        {
          uint64_t v35 = (long long *)*((void *)&v40 + 1);
          if (*((void *)&v40 + 1) >= v41)
          {
            uint64_t v37 = std::vector<std::string>::__emplace_back_slow_path<std::string const&>((uint64_t *)&v40, (long long *)v34);
          }
          else
          {
            if (*(char *)(v34 + 23) < 0)
            {
              std::string::__init_copy_ctor_external(*((std::string **)&v40 + 1), *(const std::string::value_type **)v34, *(void *)(v34 + 8));
            }
            else
            {
              long long v36 = *(_OWORD *)v34;
              *(void *)(*((void *)&v40 + 1) + 16) = *(void *)(v34 + 16);
              *uint64_t v35 = v36;
            }
            uint64_t v37 = (uint64_t)v35 + 24;
          }
          *((void *)&v40 + 1) = v37;
        }
        ++v32;
      }
      uint64_t v38 = (void *)v31[1];
      if (v38)
      {
        do
        {
          unint64_t v39 = v38;
          uint64_t v38 = (void *)*v38;
        }
        while (v38);
      }
      else
      {
        do
        {
          unint64_t v39 = (void *)v31[2];
          BOOL v14 = *v39 == (void)v31;
          long long v31 = v39;
        }
        while (!v14);
      }
      long long v31 = v39;
    }
    while (v39 != v9);
  }
  *(std::vector<std::string> *)a4 = v45;
  memset(&v45, 0, sizeof(v45));
  *(_OWORD *)(a4 + 24) = v40;
  *(void *)(a4 + 40) = v41;
  long long v40 = 0uLL;
  unint64_t v41 = 0;
  unint64_t v57 = (void **)&v40;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v57);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v46);
  v46[0] = (void **)&v42;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](v46);
  std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::destroy((uint64_t)&v43, v44[0]);
  v46[0] = (void **)&v45;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](v46);
  std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::destroy((uint64_t)v48, v49);
  v46[0] = (void **)&v51;
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100](v46);
  if (v54) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v54);
  }
  if (v56) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v56);
  }
}

void sub_20F49A6B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, void **a16, char *a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,void **a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void **a28,char *a29)
{
  *(void *)(v29 - 88) = &a9;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)(v29 - 88));
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&a23);
  a23 = (void **)&a13;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&a23);
  std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::destroy((uint64_t)&a16, a17);
  a16 = (void **)&a19;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&a16);
  std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::destroy((uint64_t)&a28, a29);
  a28 = (void **)(v29 - 144);
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100](&a28);
  long long v31 = *(std::__shared_weak_count **)(v29 - 112);
  if (v31) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v31);
  }
  unint64_t v32 = *(std::__shared_weak_count **)(v29 - 96);
  if (v32) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v32);
  }
  _Unwind_Resume(a1);
}

std::vector<std::string> *__cdecl std::vector<std::string>::vector(std::vector<std::string> *this, std::vector<std::string>::size_type __n)
{
  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  if (__n)
  {
    std::vector<std::string>::__vallocate[abi:ne180100](this, __n);
    std::vector<std::string>::pointer end = this->__end_;
    size_t v5 = 24 * ((24 * __n - 24) / 0x18) + 24;
    bzero(end, v5);
    this->__end_ = (std::vector<std::string>::pointer)((char *)end + v5);
  }
  return this;
}

void sub_20F49A844(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

uint64_t MIL::Transform::ProgramTransformer::ProgramTransformerImpl::ForEachBlock<MIL::Transform::ProgramTransformer::ProgramTransformerImpl::FoldConstantNodes(void)::{lambda(std::shared_ptr<MIL::Builder::BlockBuilder> const&)#1}>(MIL::Builder::ProgramBuilder *a1, uint64_t *a2)
{
  uint64_t result = MIL::Builder::ProgramBuilder::GetFunctions(a1);
  for (unint64_t i = *(uint64_t ***)(result + 16); i; unint64_t i = (uint64_t **)*i)
  {
    uint64_t result = MIL::Builder::FunctionBuilder::GetSpecializations((MIL::Builder::FunctionBuilder *)i[5]);
    for (unint64_t j = *(MIL::Builder::BlockBuilder::BlockBuilderImpl ****)(result + 16);
          j;
          unint64_t j = (MIL::Builder::BlockBuilder::BlockBuilderImpl ***)*j)
    {
      uint64_t result = MIL::Transform::ProgramTransformer::ProgramTransformerImpl::ForEachBlock<MIL::Transform::ProgramTransformer::ProgramTransformerImpl::FoldConstantNodes(void)::{lambda(std::shared_ptr<MIL::Builder::BlockBuilder> const&)#1}>(j + 5, a2);
    }
  }
  return result;
}

uint64_t MIL::Transform::ProgramTransformer::ProgramTransformerImpl::ForEachBlock<MIL::Transform::ProgramTransformer::ProgramTransformerImpl::FoldConstantNodes(void)::{lambda(std::shared_ptr<MIL::Builder::BlockBuilder> const&)#1}>(MIL::Builder::BlockBuilder::BlockBuilderImpl ***a1, uint64_t *a2)
{
  if (MIL::Builder::BlockBuilder::GetNumOperations((MIL::Builder::BlockBuilder *)*a1))
  {
    unint64_t v4 = 0;
    do
    {
      MIL::Builder::BlockBuilder::GetOperation(*a1, v4, &v9);
      MIL::Builder::OperationBuilder::GetBlocks((MIL::Builder::OperationBuilder *)v9, v8);
      uint64_t v5 = v8[0];
      uint64_t v6 = v8[1];
      while (v5 != v6)
      {
        MIL::Transform::ProgramTransformer::ProgramTransformerImpl::ForEachBlock<MIL::Transform::ProgramTransformer::ProgramTransformerImpl::FoldConstantNodes(void)::{lambda(std::shared_ptr<MIL::Builder::BlockBuilder> const&)#1}>(v5, a2);
        v5 += 16;
      }
      unint64_t v10 = (void **)v8;
      std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100](&v10);
      if (*((void *)&v9 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v9 + 1));
      }
      ++v4;
    }
    while (v4 < MIL::Builder::BlockBuilder::GetNumOperations((MIL::Builder::BlockBuilder *)*a1));
  }
  return MIL::Transform::ProgramTransformer::ProgramTransformerImpl::FoldConstantNodesWithinBlock(*a2, (MIL::Builder::BlockBuilder **)a1);
}

void sub_20F49A97C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, uint64_t a14)
{
  if (a13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a13);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::Transform::ProgramTransformer::ProgramTransformerImpl::FoldConstantNodesWithinBlock(uint64_t a1, MIL::Builder::BlockBuilder **a2)
{
  long long v48 = 0u;
  long long v49 = 0u;
  int v50 = 1065353216;
  MIL::Transform::ProgramTransformer::ProgramTransformerImpl::FindAllConstantOpsWithinBlock(a1, a2, &v48, (uint64_t)v47);
  unint64_t v3 = 0;
  memset(v45, 0, sizeof(v45));
  int v46 = 1065353216;
  while (v3 < MIL::Builder::BlockBuilder::GetNumOperations(*a2))
  {
    MIL::Builder::BlockBuilder::GetOperation((MIL::Builder::BlockBuilder::BlockBuilderImpl **)*a2, v3, &v42);
    std::string __p = &v42;
    std::__hash_table<std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,unsigned long>,std::__unordered_map_hasher<std::shared_ptr<MIL::Builder::OperationBuilder>,std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,unsigned long>,std::hash<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::equal_to<std::shared_ptr<MIL::Builder::OperationBuilder>>,true>,std::__unordered_map_equal<std::shared_ptr<MIL::Builder::OperationBuilder>,std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,unsigned long>,std::equal_to<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::hash<std::shared_ptr<MIL::Builder::OperationBuilder>>,true>,std::allocator<std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,unsigned long>>>::__emplace_unique_key_args<std::shared_ptr<MIL::Builder::OperationBuilder>,std::piecewise_construct_t const&,std::tuple<std::shared_ptr<MIL::Builder::OperationBuilder>&&>,std::tuple<>>((uint64_t)v45, &v42, (uint64_t)&std::piecewise_construct, (_OWORD **)&__p)[4] = v3;
    if (*((void *)&v42 + 1)) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v42 + 1));
    }
    ++v3;
  }
  long long v42 = 0u;
  long long v43 = 0u;
  int v44 = 1065353216;
  for (unint64_t i = (unsigned __int8 *)v49; i; unint64_t i = *(unsigned __int8 **)i)
  {
    OperationsByInput = MIL::Builder::BlockBuilder::GetOperationsByInput((uint64_t)*a2, i + 16);
    std::unordered_set<std::shared_ptr<MIL::Builder::OperationBuilder>>::unordered_set((uint64_t)&__p, (uint64_t)OperationsByInput);
    uint64_t v6 = v41;
    if (!v41) {
      goto LABEL_19;
    }
    char v7 = 0;
    do
    {
      if (!std::__hash_table<std::__hash_value_type<std::shared_ptr<MIL::Builder::DataDependency::ProducerInfo>,std::unordered_set<MIL::Builder::DataDependency>>,std::__unordered_map_hasher<std::shared_ptr<MIL::Builder::DataDependency::ProducerInfo>,std::__hash_value_type<std::shared_ptr<MIL::Builder::DataDependency::ProducerInfo>,std::unordered_set<MIL::Builder::DataDependency>>,std::hash<std::shared_ptr<MIL::Builder::DataDependency::ProducerInfo>>,std::equal_to<std::shared_ptr<MIL::Builder::DataDependency::ProducerInfo>>,true>,std::__unordered_map_equal<std::shared_ptr<MIL::Builder::DataDependency::ProducerInfo>,std::__hash_value_type<std::shared_ptr<MIL::Builder::DataDependency::ProducerInfo>,std::unordered_set<MIL::Builder::DataDependency>>,std::equal_to<std::shared_ptr<MIL::Builder::DataDependency::ProducerInfo>>,std::hash<std::shared_ptr<MIL::Builder::DataDependency::ProducerInfo>>,true>,std::allocator<std::__hash_value_type<std::shared_ptr<MIL::Builder::DataDependency::ProducerInfo>,std::unordered_set<MIL::Builder::DataDependency>>>>::find<std::shared_ptr<MIL::Builder::DataDependency::ProducerInfo>>(v47, v6 + 2))
      {
        if (!std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>(&v42, i + 16)|| (v38.__r_.__value_.__r.__words[0] = (std::string::size_type)(v6 + 2), unint64_t v8 = std::__hash_table<std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,unsigned long>,std::__unordered_map_hasher<std::shared_ptr<MIL::Builder::OperationBuilder>,std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,unsigned long>,std::hash<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::equal_to<std::shared_ptr<MIL::Builder::OperationBuilder>>,true>,std::__unordered_map_equal<std::shared_ptr<MIL::Builder::OperationBuilder>,std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,unsigned long>,std::equal_to<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::hash<std::shared_ptr<MIL::Builder::OperationBuilder>>,true>,std::allocator<std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,unsigned long>>>::__emplace_unique_key_args<std::shared_ptr<MIL::Builder::OperationBuilder>,std::piecewise_construct_t const&,std::tuple<std::shared_ptr<MIL::Builder::OperationBuilder> const&>,std::tuple<>>((uint64_t)v45, v6 + 2, (uint64_t)&std::piecewise_construct, &v38)[4], v38.__r_.__value_.__r.__words[0] = (std::string::size_type)(i + 16), v38.__r_.__value_.__r.__words[0] = (std::string::size_type)(std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::Builder::OperationBuilder>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::Builder::OperationBuilder>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::Builder::OperationBuilder>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::Builder::OperationBuilder>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)&v42, i + 16, (uint64_t)&std::piecewise_construct, (long long **)&v38)+ 40), v8 < std::__hash_table<std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,unsigned long>,std::__unordered_map_hasher<std::shared_ptr<MIL::Builder::OperationBuilder>,std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,unsigned long>,std::hash<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::equal_to<std::shared_ptr<MIL::Builder::OperationBuilder>>,true>,std::__unordered_map_equal<std::shared_ptr<MIL::Builder::OperationBuilder>,std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,unsigned long>,std::equal_to<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::hash<std::shared_ptr<MIL::Builder::OperationBuilder>>,true>,std::allocator<std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,unsigned long>>>::__emplace_unique_key_args<std::shared_ptr<MIL::Builder::OperationBuilder>,std::piecewise_construct_t const&,std::tuple<std::shared_ptr<MIL::Builder::OperationBuilder> const&>,std::tuple<>>((uint64_t)v45, v38.__r_.__value_.__l.__data_, (uint64_t)&std::piecewise_construct,
                     &v38)[4]))
        {
          v38.__r_.__value_.__r.__words[0] = (std::string::size_type)(i + 16);
          long long v9 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::Builder::OperationBuilder>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::Builder::OperationBuilder>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::Builder::OperationBuilder>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::Builder::OperationBuilder>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)&v42, i + 16, (uint64_t)&std::piecewise_construct, (long long **)&v38);
          unint64_t v11 = v6[2];
          unint64_t v10 = v6[3];
          if (v10) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
          }
          uint64_t v12 = (std::__shared_weak_count *)*((void *)v9 + 6);
          *((void *)v9 + 5) = v11;
          *((void *)v9 + 6) = v10;
          if (v12) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v12);
          }
        }
        char v7 = 1;
      }
      uint64_t v6 = (unint64_t *)*v6;
    }
    while (v6);
    if ((v7 & 1) == 0)
    {
LABEL_19:
      MIL::Builder::BlockBuilder::GetOutputNames(*a2, &v38);
      uint64_t v13 = std::__find_impl[abi:ne180100]<std::string *,std::string *,std::string,std::__identity>((uint64_t)v38.__r_.__value_.__l.__data_, v38.__r_.__value_.__l.__size_, (unsigned __int8 **)i + 2);
      if (v13 != v38.__r_.__value_.__l.__size_)
      {
        uint64_t v51 = (long long *)(i + 16);
        BOOL v14 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::Builder::OperationBuilder>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::Builder::OperationBuilder>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::Builder::OperationBuilder>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::Builder::OperationBuilder>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)&v42, i + 16, (uint64_t)&std::piecewise_construct, &v51);
        long long v15 = (std::__shared_weak_count *)*((void *)v14 + 6);
        *((void *)v14 + 5) = 0;
        *((void *)v14 + 6) = 0;
        if (v15) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v15);
        }
      }
      uint64_t v52 = &v38;
      std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v52);
    }
    std::__hash_table<std::shared_ptr<MIL::Builder::OperationBuilder>,std::hash<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::equal_to<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::allocator<std::shared_ptr<MIL::Builder::OperationBuilder>>>::~__hash_table((uint64_t)&__p);
  }
  std::string __p = 0;
  long long v40 = 0;
  unint64_t v41 = 0;
  std::vector<unsigned long long>::reserve(&__p, v47[3]);
  for (unint64_t j = 0; j < MIL::Builder::BlockBuilder::GetNumOperations(*a2); ++j)
  {
    MIL::Builder::BlockBuilder::GetOperation((MIL::Builder::BlockBuilder::BlockBuilderImpl **)*a2, j, &v38);
    uint64_t v17 = std::__hash_table<std::__hash_value_type<std::shared_ptr<MIL::Builder::DataDependency::ProducerInfo>,std::unordered_set<MIL::Builder::DataDependency>>,std::__unordered_map_hasher<std::shared_ptr<MIL::Builder::DataDependency::ProducerInfo>,std::__hash_value_type<std::shared_ptr<MIL::Builder::DataDependency::ProducerInfo>,std::unordered_set<MIL::Builder::DataDependency>>,std::hash<std::shared_ptr<MIL::Builder::DataDependency::ProducerInfo>>,std::equal_to<std::shared_ptr<MIL::Builder::DataDependency::ProducerInfo>>,true>,std::__unordered_map_equal<std::shared_ptr<MIL::Builder::DataDependency::ProducerInfo>,std::__hash_value_type<std::shared_ptr<MIL::Builder::DataDependency::ProducerInfo>,std::unordered_set<MIL::Builder::DataDependency>>,std::equal_to<std::shared_ptr<MIL::Builder::DataDependency::ProducerInfo>>,std::hash<std::shared_ptr<MIL::Builder::DataDependency::ProducerInfo>>,true>,std::allocator<std::__hash_value_type<std::shared_ptr<MIL::Builder::DataDependency::ProducerInfo>,std::unordered_set<MIL::Builder::DataDependency>>>>::find<std::shared_ptr<MIL::Builder::DataDependency::ProducerInfo>>(v47, &v38);
    if (v38.__r_.__value_.__l.__size_) {
      std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v38.__r_.__value_.__l.__size_);
    }
    if (v17)
    {
      unint64_t v18 = v40;
      if (v40 >= v41)
      {
        uint64_t v20 = (unint64_t *)__p;
        uint64_t v21 = ((char *)v40 - (unsigned char *)__p) >> 3;
        unint64_t v22 = v21 + 1;
        if ((unint64_t)(v21 + 1) >> 61) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v23 = (char *)v41 - (unsigned char *)__p;
        if (((char *)v41 - (unsigned char *)__p) >> 2 > v22) {
          unint64_t v22 = v23 >> 2;
        }
        if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v24 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v24 = v22;
        }
        if (v24)
        {
          uint64_t v25 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v41, v24);
          uint64_t v20 = (unint64_t *)__p;
          unint64_t v18 = v40;
        }
        else
        {
          uint64_t v25 = 0;
        }
        uint64_t v26 = (unint64_t *)&v25[8 * v21];
        unint64_t *v26 = j;
        uint64_t v19 = v26 + 1;
        while (v18 != v20)
        {
          unint64_t v27 = *--v18;
          *--uint64_t v26 = v27;
        }
        std::string __p = v26;
        long long v40 = v19;
        unint64_t v41 = (unint64_t *)&v25[8 * v24];
        if (v20) {
          operator delete(v20);
        }
      }
      else
      {
        unint64_t *v40 = j;
        uint64_t v19 = v18 + 1;
      }
      long long v40 = v19;
    }
  }
  if (v40 == __p) {
    BOOL v28 = 0;
  }
  else {
    BOOL v28 = __p;
  }
  MIL::Builder::BlockBuilder::RemoveOperations((uint64_t)*a2, v28, ((char *)v40 - (unsigned char *)__p) >> 3, 1);
  uint64_t v29 = v43;
  if ((void)v43)
  {
    uint64_t v30 = *a2;
    if (*(char *)(v43 + 39) < 0) {
      std::string::__init_copy_ctor_external(&v37, *(const std::string::value_type **)(v43 + 16), *(void *)(v43 + 24));
    }
    else {
      std::string v37 = *(std::string *)(v43 + 16);
    }
    v38.__r_.__value_.__r.__words[0] = v29 + 16;
    long long v31 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)&v48, (unsigned __int8 *)(v29 + 16), (uint64_t)&std::piecewise_construct, (long long **)&v38);
    uint64_t v32 = *((void *)v31 + 6);
    v36[0] = *((void *)v31 + 5);
    v36[1] = v32;
    if (v32) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v32 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v33 = *(void *)(v29 + 48);
    v35[0] = *(void *)(v29 + 40);
    v35[1] = v33;
    if (v33) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v33 + 8), 1uLL, memory_order_relaxed);
    }
    MIL::Builder::BlockBuilder::AddConst((uint64_t)v30, (uint64_t)&v37, v36, v35);
  }
  if (__p)
  {
    long long v40 = (unint64_t *)__p;
    operator delete(__p);
  }
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&v42);
  std::__hash_table<std::shared_ptr<MIL::Builder::OperationBuilder>,std::hash<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::equal_to<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::allocator<std::shared_ptr<MIL::Builder::OperationBuilder>>>::~__hash_table((uint64_t)v45);
  std::__hash_table<std::shared_ptr<MIL::Builder::OperationBuilder>,std::hash<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::equal_to<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::allocator<std::shared_ptr<MIL::Builder::OperationBuilder>>>::~__hash_table((uint64_t)v47);
  return std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&v48);
}

void sub_20F49AE4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
  if (__p) {
    operator delete(__p);
  }
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table((uint64_t)&a28);
  std::__hash_table<std::shared_ptr<MIL::Builder::OperationBuilder>,std::hash<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::equal_to<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::allocator<std::shared_ptr<MIL::Builder::OperationBuilder>>>::~__hash_table((uint64_t)&a34);
  std::__hash_table<std::shared_ptr<MIL::Builder::OperationBuilder>,std::hash<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::equal_to<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::allocator<std::shared_ptr<MIL::Builder::OperationBuilder>>>::~__hash_table(v34 - 184);
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::~__hash_table(v34 - 144);
  _Unwind_Resume(a1);
}

unint64_t MIL::Transform::ProgramTransformer::ProgramTransformerImpl::FindAllConstantOpsWithinBlock@<X0>(uint64_t a1@<X0>, MIL::Builder::BlockBuilder **a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v5 = a2;
  unint64_t v6 = 0;
  *(_OWORD *)a4 = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  *(_DWORD *)(a4 + 32) = 1065353216;
  while (1)
  {
    unint64_t result = MIL::Builder::BlockBuilder::GetNumOperations(*v5);
    if (v6 >= result) {
      return result;
    }
    MIL::Builder::BlockBuilder::GetOperation((MIL::Builder::BlockBuilder::BlockBuilderImpl **)*v5, v6, &v50);
    MIL::Builder::OperationBuilder::GetInputArguments((MIL::Builder::OperationBuilder::OperationBuilderImpl **)v50, (uint64_t)&v51);
    unint64_t v8 = (uint64_t **)v51.__r_.__value_.__r.__words[2];
    if (v51.__r_.__value_.__r.__words[2])
    {
      while (1)
      {
        uint64_t Name = (unsigned __int8 *)MIL::Builder::Variable::TryGetName((MIL::Builder::Variable::VariableImpl **)v8[2]);
        if (Name)
        {
          if (!std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(a3, Name))break; {
        }
          }
        unint64_t v8 = (uint64_t **)*v8;
        if (!v8) {
          goto LABEL_7;
        }
      }
      std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table((uint64_t)&v51);
    }
    else
    {
LABEL_7:
      std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table((uint64_t)&v51);
      uint64_t Operator = MIL::Builder::OperationBuilder::GetOperator((MIL::Builder::OperationBuilder *)v50);
      if ((*(uint64_t (**)(uint64_t))(*(void *)Operator + 224))(Operator))
      {
        std::__hash_table<std::shared_ptr<MIL::Builder::OperationBuilder>,std::hash<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::equal_to<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::allocator<std::shared_ptr<MIL::Builder::OperationBuilder>>>::__emplace_unique_key_args<std::shared_ptr<MIL::Builder::OperationBuilder>,std::shared_ptr<MIL::Builder::OperationBuilder> const&>(a4, &v50, &v50);
        unint64_t v41 = v6;
        memset(v48, 0, sizeof(v48));
        int v49 = 1065353216;
        Parameters = (void *)MIL::Builder::OperationBuilder::GetParameters((MIL::Builder::OperationBuilder *)v50);
        uint64_t v13 = (unsigned __int8 *)(Parameters + 1);
        uint64_t v12 = (unsigned __int8 *)*Parameters;
        if ((void *)*Parameters != Parameters + 1)
        {
          do
          {
            std::vector<std::string> v45 = 0;
            int v46 = 0;
            unint64_t v47 = 0;
            std::vector<std::shared_ptr<MIL::IRValue const>>::reserve((uint64_t *)&v45, (uint64_t)(*((void *)v12 + 8) - *((void *)v12 + 7)) >> 4);
            BOOL v14 = (MIL::IRArgument **)*((void *)v12 + 7);
            long long v15 = (MIL::IRArgument **)*((void *)v12 + 8);
            while (v14 != v15)
            {
              if ((*(unsigned int (**)(void))(*(void *)*v14 + 24))())
              {
                (*(void (**)(long long *__return_ptr))(*(void *)*v14 + 48))(&v44);
                uint64_t v16 = v46;
                if ((unint64_t)v46 >= v47)
                {
                  int64_t v19 = (v46 - v45) >> 4;
                  unint64_t v20 = v19 + 1;
                  if ((unint64_t)(v19 + 1) >> 60) {
                    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
                  }
                  uint64_t v21 = v47 - (void)v45;
                  if ((uint64_t)(v47 - (void)v45) >> 3 > v20) {
                    unint64_t v20 = v21 >> 3;
                  }
                  if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF0) {
                    unint64_t v22 = 0xFFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v22 = v20;
                  }
                  unint64_t v53 = (std::__shared_weak_count *)&v47;
                  uint64_t v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<MIL::IRBlock>>>((uint64_t)&v47, v22);
                  unint64_t v24 = &v23[16 * v19];
                  v51.__r_.__value_.__r.__words[0] = (std::string::size_type)v23;
                  v51.__r_.__value_.__l.__size_ = (std::string::size_type)v24;
                  uint64_t v52 = &v23[16 * v25];
                  *(_OWORD *)unint64_t v24 = v44;
                  long long v44 = 0uLL;
                  v51.__r_.__value_.__r.__words[2] = (std::string::size_type)(v24 + 16);
                  std::vector<std::shared_ptr<MIL::IRValue const>>::__swap_out_circular_buffer((uint64_t *)&v45, &v51);
                  uint64_t v26 = (uint64_t *)v46;
                  std::__split_buffer<std::shared_ptr<MIL::IRBlock>>::~__split_buffer((void **)&v51.__r_.__value_.__l.__data_);
                  int v46 = (char *)v26;
                  if (*((void *)&v44 + 1)) {
                    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v44 + 1));
                  }
                }
                else
                {
                  *(_OWORD *)int v46 = v44;
                  int v46 = v16 + 16;
                }
              }
              else
              {
                uint64_t v17 = (unsigned __int8 *)MIL::IRArgument::GetName(*v14);
                unint64_t v18 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::find<std::string>(a3, v17);
                if (!v18) {
                  std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
                }
                std::vector<std::shared_ptr<MIL::IRValue const>>::push_back[abi:ne180100]((uint64_t *)&v45, (long long *)(v18 + 40));
              }
              v14 += 2;
            }
            v51.__r_.__value_.__r.__words[0] = (std::string::size_type)(v12 + 32);
            unint64_t v27 = (uint64_t **)(std::__hash_table<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRValue const>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRValue const>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRValue const>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRValue const>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v48, v12 + 32, (uint64_t)&std::piecewise_construct, (long long **)&v51)+ 40);
            if (v27 != (uint64_t **)&v45) {
              std::vector<std::shared_ptr<MIL::IRValue const>>::__assign_with_size[abi:ne180100]<std::shared_ptr<MIL::IRValue const>*,std::shared_ptr<MIL::IRValue const>*>((uint64_t)v27, (uint64_t *)v45, (uint64_t *)v46, (v46 - v45) >> 4);
            }
            v51.__r_.__value_.__r.__words[0] = (std::string::size_type)&v45;
            std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v51);
            BOOL v28 = (unsigned __int8 *)*((void *)v12 + 1);
            if (v28)
            {
              do
              {
                uint64_t v29 = v28;
                BOOL v28 = *(unsigned __int8 **)v28;
              }
              while (v28);
            }
            else
            {
              do
              {
                uint64_t v29 = (unsigned __int8 *)*((void *)v12 + 2);
                BOOL v30 = *(void *)v29 == (void)v12;
                uint64_t v12 = v29;
              }
              while (!v30);
            }
            uint64_t v12 = v29;
          }
          while (v29 != v13);
        }
        std::vector<std::string> v45 = 0;
        int v46 = 0;
        unint64_t v47 = 0;
        MIL::Builder::OperationBuilder::GetBlocks((MIL::Builder::OperationBuilder *)v50, &v51);
        std::vector<std::shared_ptr<MIL::IRBlock>>::reserve((uint64_t *)&v45, (uint64_t)(v51.__r_.__value_.__l.__size_ - v51.__r_.__value_.__r.__words[0]) >> 4);
        *(void *)&long long v44 = &v51;
        std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v44);
        MIL::Builder::OperationBuilder::GetBlocks((MIL::Builder::OperationBuilder *)v50, &v44);
        if ((void)v44 != *((void *)&v44 + 1)) {
          MIL::Builder::BlockBuilder::CreateBlock(*(long long ****)v44);
        }
        v51.__r_.__value_.__r.__words[0] = (std::string::size_type)&v44;
        std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v51);
        uint64_t v31 = MIL::Builder::OperationBuilder::GetOperator((MIL::Builder::OperationBuilder *)v50);
        LocationPtr = (uint64_t *)MIL::Builder::OperationBuilder::GetLocationPtr((MIL::Builder::OperationBuilder *)v50);
        uint64_t v33 = (std::__shared_weak_count *)LocationPtr[1];
        uint64_t v42 = *LocationPtr;
        long long v43 = v33;
        if (v33) {
          atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t Attributes = MIL::Builder::OperationBuilder::GetAttributes((MIL::Builder::OperationBuilder *)v50);
        (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, uint64_t *, _OWORD *, uint64_t, char **, uint64_t))(*(void *)v31 + 208))(&v44, v31, a1, &v42, v48, Attributes, &v45, 0xFFFFFFFFLL);
        if (v43) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v43);
        }
        uint64_t v35 = 0;
        for (unint64_t i = 0; i < MIL::Builder::OperationBuilder::GetNumOutputs((MIL::Builder::OperationBuilder *)v50); ++i)
        {
          Outputuint64_t Name = (long long *)MIL::Builder::OperationBuilder::GetOutputName((MIL::Builder::OperationBuilder::OperationBuilderImpl **)v50, i);
          std::pair<std::string const,std::shared_ptr<MIL::Blob::LegacyStorageReader>>::pair[abi:ne180100]<std::string const&,std::shared_ptr<MIL::Blob::LegacyStorageReader>&,0>(&v51, OutputName, (std::string::size_type *)(v44 + v35));
          std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::shared_ptr<MIL::IRValue const>>>((uint64_t)a3, (unsigned __int8 *)&v51, (long long *)&v51);
          if (v53) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v53);
          }
          if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v51.__r_.__value_.__l.__data_);
          }
          v35 += 16;
        }
        v51.__r_.__value_.__r.__words[0] = (std::string::size_type)&v44;
        std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v51);
        v51.__r_.__value_.__r.__words[0] = (std::string::size_type)&v45;
        std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v51);
        std::__hash_table<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>>>::~__hash_table((uint64_t)v48);
        uint64_t v5 = a2;
        unint64_t v6 = v41;
      }
    }
    if (*((void *)&v50 + 1)) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v50 + 1));
    }
    ++v6;
  }
}

void sub_20F49B534(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,std::__shared_weak_count *a27)
{
  *(void *)(v27 - 96) = &a18;
  std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v27 - 96));
  std::__hash_table<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>>>::~__hash_table((uint64_t)&a21);
  if (a27) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a27);
  }
  std::__hash_table<std::shared_ptr<MIL::Builder::OperationBuilder>,std::hash<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::equal_to<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::allocator<std::shared_ptr<MIL::Builder::OperationBuilder>>>::~__hash_table(a11);
  _Unwind_Resume(a1);
}

void **std::vector<std::shared_ptr<MIL::IRValue const>>::push_back[abi:ne180100](uint64_t *a1, long long *a2)
{
  unint64_t v6 = a1[2];
  unint64_t result = (void **)(a1 + 2);
  unint64_t v5 = v6;
  char v7 = *(result - 1);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v10 = ((uint64_t)v7 - *a1) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v12 = v5 - *a1;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    v18[4] = result;
    BOOL v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<MIL::IRBlock>>>((uint64_t)result, v13);
    long long v15 = &v14[16 * v10];
    v18[0] = v14;
    v18[1] = v15;
    v18[3] = &v14[16 * v16];
    long long v17 = *a2;
    *(_OWORD *)long long v15 = *a2;
    if (*((void *)&v17 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v17 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    v18[2] = v15 + 16;
    std::vector<std::shared_ptr<MIL::IRValue const>>::__swap_out_circular_buffer(a1, v18);
    long long v9 = (void *)a1[1];
    unint64_t result = std::__split_buffer<std::shared_ptr<MIL::IRBlock>>::~__split_buffer(v18);
  }
  else
  {
    *char v7 = *(void *)a2;
    uint64_t v8 = *((void *)a2 + 1);
    v7[1] = v8;
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    }
    long long v9 = v7 + 2;
    a1[1] = (uint64_t)(v7 + 2);
  }
  a1[1] = (uint64_t)v9;
  return result;
}

void sub_20F49B7C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::shared_ptr<MIL::IRBlock>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,unsigned long>,std::__unordered_map_hasher<std::shared_ptr<MIL::Builder::OperationBuilder>,std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,unsigned long>,std::hash<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::equal_to<std::shared_ptr<MIL::Builder::OperationBuilder>>,true>,std::__unordered_map_equal<std::shared_ptr<MIL::Builder::OperationBuilder>,std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,unsigned long>,std::equal_to<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::hash<std::shared_ptr<MIL::Builder::OperationBuilder>>,true>,std::allocator<std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,unsigned long>>>::__emplace_unique_key_args<std::shared_ptr<MIL::Builder::OperationBuilder>,std::piecewise_construct_t const&,std::tuple<std::shared_ptr<MIL::Builder::OperationBuilder>&&>,std::tuple<>>(uint64_t a1, void *a2, uint64_t a3, _OWORD **a4)
{
  unint64_t v7 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  unint64_t v8 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v7 >> 47) ^ v7);
  unint64_t v9 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v4 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
      if (v9 >= v10) {
        unint64_t v4 = v9 % v10;
      }
    }
    else
    {
      unint64_t v4 = v9 & (v10 - 1);
    }
    uint64_t v12 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v12)
    {
      for (unint64_t i = *v12; i; unint64_t i = (void *)*i)
      {
        unint64_t v14 = i[1];
        if (v14 == v9)
        {
          if (i[2] == *a2) {
            return i;
          }
        }
        else
        {
          if (v11.u32[0] > 1uLL)
          {
            if (v14 >= v10) {
              v14 %= v10;
            }
          }
          else
          {
            v14 &= v10 - 1;
          }
          if (v14 != v4) {
            break;
          }
        }
      }
    }
  }
  long long v15 = (void *)(a1 + 16);
  unint64_t i = operator new(0x28uLL);
  void *i = 0;
  i[1] = v9;
  uint64_t v16 = *a4;
  *((_OWORD *)i + 1) = **a4;
  void *v16 = 0;
  v16[1] = 0;
  i[4] = 0;
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v18 = *(float *)(a1 + 32);
  if (!v10 || (float)(v18 * (float)v10) < v17)
  {
    BOOL v19 = 1;
    if (v10 >= 3) {
      BOOL v19 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v10);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v22);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v4 = v9 % v10;
      }
      else {
        unint64_t v4 = v9;
      }
    }
    else
    {
      unint64_t v4 = (v10 - 1) & v9;
    }
  }
  uint64_t v23 = *(void *)a1;
  unint64_t v24 = *(void **)(*(void *)a1 + 8 * v4);
  if (v24)
  {
    void *i = *v24;
LABEL_38:
    void *v24 = i;
    goto LABEL_39;
  }
  void *i = *v15;
  void *v15 = i;
  *(void *)(v23 + 8 * v4) = v15;
  if (*i)
  {
    unint64_t v25 = *(void *)(*i + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v25 >= v10) {
        v25 %= v10;
      }
    }
    else
    {
      v25 &= v10 - 1;
    }
    unint64_t v24 = (void *)(*(void *)a1 + 8 * v25);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_20F49BA48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::shared_ptr<MIL::Builder::OperationBuilder>,void *>>>::operator()[abi:ne180100](v11, v10);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,unsigned long>,std::__unordered_map_hasher<std::shared_ptr<MIL::Builder::OperationBuilder>,std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,unsigned long>,std::hash<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::equal_to<std::shared_ptr<MIL::Builder::OperationBuilder>>,true>,std::__unordered_map_equal<std::shared_ptr<MIL::Builder::OperationBuilder>,std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,unsigned long>,std::equal_to<std::shared_ptr<MIL::Builder::OperationBuilder>>,std::hash<std::shared_ptr<MIL::Builder::OperationBuilder>>,true>,std::allocator<std::__hash_value_type<std::shared_ptr<MIL::Builder::OperationBuilder>,unsigned long>>>::__emplace_unique_key_args<std::shared_ptr<MIL::Builder::OperationBuilder>,std::piecewise_construct_t const&,std::tuple<std::shared_ptr<MIL::Builder::OperationBuilder> const&>,std::tuple<>>(uint64_t a1, void *a2, uint64_t a3, void **a4)
{
  unint64_t v7 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  unint64_t v8 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v7 >> 47) ^ v7);
  unint64_t v9 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v4 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
      if (v9 >= v10) {
        unint64_t v4 = v9 % v10;
      }
    }
    else
    {
      unint64_t v4 = v9 & (v10 - 1);
    }
    uint64_t v12 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v12)
    {
      for (unint64_t i = *v12; i; unint64_t i = (void *)*i)
      {
        unint64_t v14 = i[1];
        if (v14 == v9)
        {
          if (i[2] == *a2) {
            return i;
          }
        }
        else
        {
          if (v11.u32[0] > 1uLL)
          {
            if (v14 >= v10) {
              v14 %= v10;
            }
          }
          else
          {
            v14 &= v10 - 1;
          }
          if (v14 != v4) {
            break;
          }
        }
      }
    }
  }
  long long v15 = (void *)(a1 + 16);
  uint64_t v16 = operator new(0x28uLL);
  unint64_t i = v16;
  void *v16 = 0;
  v16[1] = v9;
  float v17 = *a4;
  void v16[2] = **a4;
  uint64_t v18 = v17[1];
  v16[3] = v18;
  if (v18) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v18 + 8), 1uLL, memory_order_relaxed);
  }
  v16[4] = 0;
  float v19 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v20 = *(float *)(a1 + 32);
  if (!v10 || (float)(v20 * (float)v10) < v19)
  {
    BOOL v21 = 1;
    if (v10 >= 3) {
      BOOL v21 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v22 = v21 | (2 * v10);
    unint64_t v23 = vcvtps_u32_f32(v19 / v20);
    if (v22 <= v23) {
      size_t v24 = v23;
    }
    else {
      size_t v24 = v22;
    }
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v24);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v4 = v9 % v10;
      }
      else {
        unint64_t v4 = v9;
      }
    }
    else
    {
      unint64_t v4 = (v10 - 1) & v9;
    }
  }
  uint64_t v25 = *(void *)a1;
  uint64_t v26 = *(void **)(*(void *)a1 + 8 * v4);
  if (v26)
  {
    void *i = *v26;
LABEL_40:
    void *v26 = i;
    goto LABEL_41;
  }
  void *i = *v15;
  void *v15 = i;
  *(void *)(v25 + 8 * v4) = v15;
  if (*i)
  {
    unint64_t v27 = *(void *)(*i + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v27 >= v10) {
        v27 %= v10;
      }
    }
    else
    {
      v27 &= v10 - 1;
    }
    uint64_t v26 = (void *)(*(void *)a1 + 8 * v27);
    goto LABEL_40;
  }
LABEL_41:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_20F49BCE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::shared_ptr<MIL::Builder::OperationBuilder>,void *>>>::operator()[abi:ne180100](v11, v10);
  _Unwind_Resume(a1);
}

void std::default_delete<MIL::Transform::ProgramTransformer::ProgramTransformerImpl>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (*(unsigned char *)(a2 + 56)) {
      MIL::Matching::Matcher::~Matcher((MIL::Matching::Matcher *)(a2 + 48));
    }
    unint64_t v3 = *(std::__shared_weak_count **)(a2 + 40);
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    }
    unint64_t v4 = *(std::__shared_weak_count **)(a2 + 24);
    if (v4) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v4);
    }
    unint64_t v5 = *(std::__shared_weak_count **)(a2 + 8);
    if (v5) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v5);
    }
    JUMPOUT(0x21056C700);
  }
}

void MIL::Transform::ProgramTransformer::ProgramTransformerImpl::ProgramTransformerImpl(void *a1, void *a2, const MIL::IRProgram *a3)
{
  *a1 = *a2;
  uint64_t v4 = a2[1];
  a1[1] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  std::allocate_shared[abi:ne180100]<MIL::Transform::NameGenerator,std::allocator<MIL::Transform::NameGenerator>,MIL::IRProgram const&,void>(a3, a1 + 2);
  uint64_t v5 = a2[1];
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  MIL::Builder::ProgramBuilder::Make();
}

void sub_20F49BE84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12)
{
  if (a12) {
    MIL::Transform::ProgramTransformer::ProgramTransformerImpl::ProgramTransformerImpl();
  }
  if (a11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a11);
  }
  unint64_t v14 = *(std::__shared_weak_count **)(v12 + 24);
  if (v14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v14);
  }
  long long v15 = *(std::__shared_weak_count **)(v12 + 8);
  if (v15) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v15);
  }
  _Unwind_Resume(exception_object);
}

void *std::allocate_shared[abi:ne180100]<MIL::Transform::NameGenerator,std::allocator<MIL::Transform::NameGenerator>,MIL::IRProgram const&,void>@<X0>(const MIL::IRProgram *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x48uLL);
  unint64_t result = std::__shared_ptr_emplace<MIL::Transform::NameGenerator>::__shared_ptr_emplace[abi:ne180100]<MIL::IRProgram const&,std::allocator<MIL::Transform::NameGenerator>,0>(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_20F49BF1C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<MIL::Transform::NameGenerator>::__shared_ptr_emplace[abi:ne180100]<MIL::IRProgram const&,std::allocator<MIL::Transform::NameGenerator>,0>(void *a1, const MIL::IRProgram *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_26C25D3A8;
  MIL::Transform::NameGenerator::NameGenerator((MIL::Transform::NameGenerator *)(a1 + 3), a2);
  return a1;
}

void sub_20F49BF78(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<MIL::Transform::NameGenerator>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C25D3A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<MIL::Transform::NameGenerator>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C25D3A8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21056C700);
}

void std::__shared_ptr_emplace<MIL::Transform::NameGenerator>::__on_zero_shared(uint64_t a1)
{
  std::allocator<std::pair<std::string,std::string>>::destroy[abi:ne180100]((uint64_t)&v1, a1 + 24);
}

void std::__shared_ptr_pointer<MIL::Builder::ProgramBuilder  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21056C700);
}

uint64_t std::__shared_ptr_pointer<MIL::Builder::ProgramBuilder  *>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<MIL::Builder::ProgramBuilder  *>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void MIL::Util::FindBlobFilePaths(MIL::Util *this@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  *(_OWORD *)&v5.__r_.__value_.__l.__data_ = 0uLL;
  uint64_t v4 = &v5;
  v5.__r_.__value_.__r.__words[2] = (std::string::size_type)&unk_26C25D458;
  unint64_t v6 = &v4;
  unint64_t v7 = &v5.__r_.__value_.__s.__data_[16];
  MIL::Util::Walk((uint64_t)this, (uint64_t)&v5.__r_.__value_.__r.__words[2]);
  std::__function::__value_func<BOOL ()(MIL::IROperation const&)>::~__value_func[abi:ne180100](&v5.__r_.__value_.__r.__words[2]);
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  std::vector<std::string>::insert<std::__tree_const_iterator<std::string,std::__tree_node<std::string,void *> *,long>,0>(a2, 0, v4, &v5);
  std::__tree<std::__value_type<std::string,MIL::IRValueType const*>,std::__map_value_compare<std::string,std::__value_type<std::string,MIL::IRValueType const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MIL::IRValueType const*>>>::destroy((uint64_t)&v4, v5.__r_.__value_.__l.__data_);
}

void sub_20F49C19C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char *a10, uint64_t a11, void **a12)
{
}

std::string *std::vector<std::string>::insert<std::__tree_const_iterator<std::string,std::__tree_node<std::string,void *> *,long>,0>(uint64_t *a1, std::string *a2, std::string *a3, std::string *a4)
{
  if (a3 == a4)
  {
    uint64_t v4 = 0;
  }
  else
  {
    uint64_t v4 = 0;
    std::string v5 = a3;
    do
    {
      std::string::size_type size = (std::string *)v5->__r_.__value_.__l.__size_;
      if (size)
      {
        do
        {
          unint64_t v7 = size;
          std::string::size_type size = (std::string *)size->__r_.__value_.__r.__words[0];
        }
        while (size);
      }
      else
      {
        do
        {
          unint64_t v7 = (std::string *)v5->__r_.__value_.__r.__words[2];
          BOOL v8 = v7->__r_.__value_.__r.__words[0] == (void)v5;
          std::string v5 = v7;
        }
        while (!v8);
      }
      ++v4;
      std::string v5 = v7;
    }
    while (v7 != a4);
  }
  return std::vector<std::string>::__insert_with_size[abi:ne180100]<std::__tree_const_iterator<std::string,std::__tree_node<std::string,void *> *,long>,std::__tree_const_iterator<std::string,std::__tree_node<std::string,void *> *,long>>(a1, a2, a3, a4, v4);
}

void std::__function::__func<MIL::Util::FindBlobFilePaths(MIL::IRProgram const&)::$_0,std::allocator<MIL::Util::FindBlobFilePaths(MIL::IRProgram const&)::$_0>,BOOL ()(MIL::IROperation const&)>::~__func()
{
}

void *std::__function::__func<MIL::Util::FindBlobFilePaths(MIL::IRProgram const&)::$_0,std::allocator<MIL::Util::FindBlobFilePaths(MIL::IRProgram const&)::$_0>,BOOL ()(MIL::IROperation const&)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_26C25D458;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<MIL::Util::FindBlobFilePaths(MIL::IRProgram const&)::$_0,std::allocator<MIL::Util::FindBlobFilePaths(MIL::IRProgram const&)::$_0>,BOOL ()(MIL::IROperation const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26C25D458;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<MIL::Util::FindBlobFilePaths(MIL::IRProgram const&)::$_0,std::allocator<MIL::Util::FindBlobFilePaths(MIL::IRProgram const&)::$_0>,BOOL ()(MIL::IROperation const&)>::operator()(uint64_t a1, MIL::IRObject *this)
{
  for (unint64_t i = *(uint64_t ***)(MIL::IRObject::GetAttributes(this) + 16); i; unint64_t i = (uint64_t **)*i)
  {
    uint64_t v5 = (*(uint64_t (**)(uint64_t *))(*i[5] + 40))(i[5]);
    if (v5)
    {
      uint64_t v6 = v5;
      if ((*(unsigned int (**)(uint64_t))(*(void *)v5 + 80))(v5))
      {
        unint64_t v7 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v6 + 88))(v6);
        BOOL v8 = *(uint64_t ***)(a1 + 8);
        MIL::Util::FindBlobFilePaths(MIL::IRProgram const&)::$_0::operator() const(MIL::IROperation const&)::{lambda(std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>> const&)#1}::operator()(v7, &v23);
        MIL::IRValue::GetScalar<std::string>(v23, &__p);
        std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string>(v8, (const void **)&__p.__r_.__value_.__l.__data_, (uint64_t)&__p);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (v24) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v24);
        }
      }
    }
  }
  unint64_t v9 = (void *)(*(uint64_t (**)(MIL::IRObject *))(*(void *)this + 160))(this);
  unint64_t v10 = v9 + 1;
  uint64_t v11 = (void *)*v9;
  if ((void *)*v9 != v9 + 1)
  {
    do
    {
      uint64_t v12 = (MIL::IRArgument **)v11[7];
      unint64_t v13 = (MIL::IRArgument **)v11[8];
      while (v12 != v13)
      {
        if ((*(unsigned int (**)(void))(*(void *)*v12 + 24))())
        {
          uint64_t Value = MIL::IRArgument::GetValue(*v12);
          uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)Value + 40))(Value);
          if (v15)
          {
            uint64_t v16 = v15;
            if ((*(unsigned int (**)(uint64_t))(*(void *)v15 + 80))(v15))
            {
              float v17 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v16 + 88))(v16);
              uint64_t v18 = *(uint64_t ***)(a1 + 8);
              MIL::Util::FindBlobFilePaths(MIL::IRProgram const&)::$_0::operator() const(MIL::IROperation const&)::{lambda(std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>> const&)#1}::operator()(v17, &v23);
              MIL::IRValue::GetScalar<std::string>(v23, &__p);
              std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string>(v18, (const void **)&__p.__r_.__value_.__l.__data_, (uint64_t)&__p);
              if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(__p.__r_.__value_.__l.__data_);
              }
              if (v24) {
                std::__shared_weak_count::__release_shared[abi:ne180100](v24);
              }
            }
          }
        }
        v12 += 2;
      }
      float v19 = (void *)v11[1];
      if (v19)
      {
        do
        {
          float v20 = v19;
          float v19 = (void *)*v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          float v20 = (void *)v11[2];
          BOOL v21 = *v20 == (void)v11;
          uint64_t v11 = v20;
        }
        while (!v21);
      }
      uint64_t v11 = v20;
    }
    while (v20 != v10);
  }
  return 1;
}

void sub_20F49C548(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__func<MIL::Util::FindBlobFilePaths(MIL::IRProgram const&)::$_0,std::allocator<MIL::Util::FindBlobFilePaths(MIL::IRProgram const&)::$_0>,BOOL ()(MIL::IROperation const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<MIL::Util::FindBlobFilePaths(MIL::IRProgram const&)::$_0,std::allocator<MIL::Util::FindBlobFilePaths(MIL::IRProgram const&)::$_0>,BOOL ()(MIL::IROperation const&)>::target_type()
{
}

void MIL::Util::FindBlobFilePaths(MIL::IRProgram const&)::$_0::operator() const(MIL::IROperation const&)::{lambda(std::unordered_map<std::string,std::shared_ptr<MIL::IRValue const>> const&)#1}::operator()(void *a1@<X0>, void *a2@<X8>)
{
  std::string::basic_string[abi:ne180100]<0>(__p, "path");
  uint64_t v4 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(a1, (unsigned __int8 *)__p);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  if (!v4)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "Invalid file properties: Blob file path property not found.");
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  uint64_t v5 = *((void *)v4 + 6);
  *a2 = *((void *)v4 + 5);
  a2[1] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
}

void sub_20F49C67C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  __cxa_free_exception(v15);
  _Unwind_Resume(a1);
}

std::string *std::vector<std::string>::__insert_with_size[abi:ne180100]<std::__tree_const_iterator<std::string,std::__tree_node<std::string,void *> *,long>,std::__tree_const_iterator<std::string,std::__tree_node<std::string,void *> *,long>>(uint64_t *a1, std::string *a2, std::string *a3, void *a4, uint64_t a5)
{
  uint64_t v5 = a2;
  if (a5 >= 1)
  {
    uint64_t v10 = (uint64_t)(a1 + 2);
    uint64_t v9 = a1[2];
    uint64_t v11 = (std::string *)a1[1];
    if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((v9 - (uint64_t)v11) >> 3)) >= a5)
    {
      v23.__first_ = a3;
      std::__advance[abi:ne180100]<std::__tree_const_iterator<std::string,std::__tree_node<std::string,void *> *,long>>(&v23, a5);
      uint64_t v20 = a1[1] - (void)v5;
      uint64_t v21 = 0xAAAAAAAAAAAAAAABLL * (v20 >> 3);
      if (v21 >= a5
        || (v23.__first_ = a3,
            std::__advance[abi:ne180100]<std::__tree_const_iterator<std::string,std::__tree_node<std::string,void *> *,long>>(&v23, v21), a1[1] = (uint64_t)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::string>,std::__tree_const_iterator<std::string,std::__tree_node<std::string,void *> *,long>,std::__tree_const_iterator<std::string,std::__tree_node<std::string,void *> *,long>,std::string*>(v10, v23.__first_->__r_.__value_.__r.__words, a4, (std::string *)a1[1]), v20 >= 1))
      {
        std::vector<std::string>::__move_range((std::vector<std::string> *)a1, v5, v11, &v5[a5]);
        std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__tree_const_iterator<std::string,std::__tree_node<std::string,void *> *,long>,std::__tree_const_iterator<std::string,std::__tree_node<std::string,void *> *,long>,std::string*>((int)&v24, a3, v23.__first_->__r_.__value_.__r.__words, v5);
      }
    }
    else
    {
      uint64_t v12 = *a1;
      unint64_t v13 = a5 - 0x5555555555555555 * (((uint64_t)v11 - *a1) >> 3);
      if (v13 > 0xAAAAAAAAAAAAAAALL) {
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)a2 - v12) >> 3);
      unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((v9 - v12) >> 3);
      uint64_t v16 = 2 * v15;
      if (2 * v15 <= v13) {
        uint64_t v16 = v13;
      }
      if (v15 >= 0x555555555555555) {
        unint64_t v17 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v17 = v16;
      }
      v23.__end_cap_.__value_ = (std::allocator<std::string> *)(a1 + 2);
      if (v17) {
        uint64_t v18 = (std::string *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)(a1 + 2), v17);
      }
      else {
        uint64_t v18 = 0;
      }
      v23.__first_ = v18;
      v23.__begin_ = v18 + v14;
      v23.__end_ = v23.__begin_;
      v23.__end_cap_.__value_ = &v18[v17];
      std::__split_buffer<std::string>::__construct_at_end_with_size<std::__tree_const_iterator<std::string,std::__tree_node<std::string,void *> *,long>>((uint64_t)&v23, a3, a5);
      uint64_t v5 = std::vector<std::string>::__swap_out_circular_buffer((std::vector<std::string> *)a1, &v23, v5);
      std::__split_buffer<std::string>::~__split_buffer(&v23);
    }
  }
  return v5;
}

void sub_20F49C888(_Unwind_Exception *exception_object)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(exception_object);
}

void std::vector<std::string>::__move_range(std::vector<std::string> *this, std::vector<std::string>::pointer __from_s, std::vector<std::string>::pointer __from_e, std::vector<std::string>::pointer __to)
{
  std::vector<std::string>::pointer end = this->__end_;
  unint64_t v7 = (char *)__from_s + (char *)end - (char *)__to;
  std::vector<std::string>::pointer v8 = end;
  if (v7 < (char *)__from_e)
  {
    unint64_t v9 = (unint64_t)v7;
    std::vector<std::string>::pointer v8 = this->__end_;
    do
    {
      long long v10 = *(_OWORD *)v9;
      v8->__r_.__value_.__r.__words[2] = *(void *)(v9 + 16);
      *(_OWORD *)&v8->__r_.__value_.__l.__data_ = v10;
      ++v8;
      *(void *)(v9 + 8) = 0;
      *(void *)(v9 + 16) = 0;
      *(void *)unint64_t v9 = 0;
      v9 += 24;
    }
    while (v9 < (unint64_t)__from_e);
  }
  this->__end_ = v8;
  std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::string *,std::string *,std::string *>((uint64_t)&v11, (uint64_t)__from_s, (uint64_t)v7, (uint64_t)end);
}

void std::__split_buffer<std::string>::__construct_at_end_with_size<std::__tree_const_iterator<std::string,std::__tree_node<std::string,void *> *,long>>(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v4 = *(std::string **)(a1 + 16);
  if (a3)
  {
    uint64_t v6 = &v4[a3];
    do
    {
      if (*((char *)a2 + 55) < 0)
      {
        std::string::__init_copy_ctor_external(v4, (const std::string::value_type *)a2[4], a2[5]);
      }
      else
      {
        long long v7 = *((_OWORD *)a2 + 2);
        v4->__r_.__value_.__r.__words[2] = a2[6];
        *(_OWORD *)&v4->__r_.__value_.__l.__data_ = v7;
      }
      std::vector<std::string>::pointer v8 = (void *)a2[1];
      if (v8)
      {
        do
        {
          unint64_t v9 = v8;
          std::vector<std::string>::pointer v8 = (void *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          unint64_t v9 = (void *)a2[2];
          BOOL v10 = *v9 == (void)a2;
          a2 = v9;
        }
        while (!v10);
      }
      ++v4;
      a2 = v9;
    }
    while (v4 != v6);
    uint64_t v4 = v6;
  }
  *(void *)(a1 + 16) = v4;
}

void sub_20F49C9C4(_Unwind_Exception *a1)
{
  *(void *)(v1 + 16) = v2;
  _Unwind_Resume(a1);
}

std::vector<std::string>::pointer std::vector<std::string>::__swap_out_circular_buffer(std::vector<std::string> *this, std::__split_buffer<std::string> *__v, std::vector<std::string>::pointer __p)
{
  std::vector<unsigned int>::pointer begin = __v->__begin_;
  p_end_cap = &this->__end_cap_;
  std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::string>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>>((uint64_t)&this->__end_cap_, (uint64_t)__p, (uint64_t)__p, (uint64_t)this->__begin_, (uint64_t)this->__begin_, (uint64_t)begin, (uint64_t)begin);
  __v->__begin_ = v8;
  __v->__end_ = (std::__split_buffer<std::string>::pointer)std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::string>,std::string*,std::string*,std::string*>((uint64_t)p_end_cap, (long long *)__p, (long long *)this->__end_, (uint64_t)__v->__end_);
  unint64_t v9 = this->__begin_;
  this->__begin_ = __v->__begin_;
  __v->__begin_ = v9;
  std::vector<std::string>::pointer end = this->__end_;
  this->__end_ = __v->__end_;
  __v->__end_ = end;
  value = this->__end_cap_.__value_;
  this->__end_cap_.__value_ = __v->__end_cap_.__value_;
  __v->__end_cap_.__value_ = value;
  __v->__first_ = __v->__begin_;
  return begin;
}

void **std::__advance[abi:ne180100]<std::__tree_const_iterator<std::string,std::__tree_node<std::string,void *> *,long>>(void **result, uint64_t a2)
{
  if (a2 < 0)
  {
    long long v7 = *result;
    do
    {
      std::vector<std::string>::pointer v8 = (void *)*v7;
      if (*v7)
      {
        do
        {
          uint64_t v4 = v8;
          std::vector<std::string>::pointer v8 = (void *)v8[1];
        }
        while (v8);
      }
      else
      {
        do
        {
          uint64_t v4 = (void *)v7[2];
          BOOL v5 = *v4 == (void)v7;
          long long v7 = v4;
        }
        while (v5);
      }
      long long v7 = v4;
    }
    while (!__CFADD__(a2++, 1));
  }
  else
  {
    if (!a2) {
      return result;
    }
    uint64_t v2 = *result;
    do
    {
      uint64_t v3 = (void *)v2[1];
      if (v3)
      {
        do
        {
          uint64_t v4 = v3;
          uint64_t v3 = (void *)*v3;
        }
        while (v3);
      }
      else
      {
        do
        {
          uint64_t v4 = (void *)v2[2];
          BOOL v5 = *v4 == (void)v2;
          uint64_t v2 = v4;
        }
        while (!v5);
      }
      uint64_t v2 = v4;
    }
    while (a2-- > 1);
  }
  void *result = v4;
  return result;
}

std::string *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::string>,std::__tree_const_iterator<std::string,std::__tree_node<std::string,void *> *,long>,std::__tree_const_iterator<std::string,std::__tree_node<std::string,void *> *,long>,std::string*>(uint64_t a1, void *a2, void *a3, std::string *this)
{
  uint64_t v4 = this;
  unint64_t v14 = this;
  unint64_t v15 = this;
  v12[0] = a1;
  v12[1] = &v14;
  void v12[2] = &v15;
  char v13 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      if (*((char *)v6 + 55) < 0)
      {
        std::string::__init_copy_ctor_external(v4, (const std::string::value_type *)v6[4], v6[5]);
      }
      else
      {
        long long v7 = *((_OWORD *)v6 + 2);
        v4->__r_.__value_.__r.__words[2] = v6[6];
        *(_OWORD *)&v4->__r_.__value_.__l.__data_ = v7;
      }
      std::vector<std::string>::pointer v8 = (void *)v6[1];
      if (v8)
      {
        do
        {
          unint64_t v9 = v8;
          std::vector<std::string>::pointer v8 = (void *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          unint64_t v9 = (void *)v6[2];
          BOOL v10 = *v9 == (void)v6;
          uint64_t v6 = v9;
        }
        while (!v10);
      }
      uint64_t v4 = ++v15;
      uint64_t v6 = v9;
    }
    while (v9 != a3);
  }
  char v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::string*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v4;
}

void sub_20F49CBE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::string *,std::string *,std::string *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3 != a2)
  {
    uint64_t v6 = a3;
    do
    {
      uint64_t v7 = a4 - 24;
      if (*(char *)(a4 - 1) < 0) {
        operator delete(*(void **)v7);
      }
      long long v8 = *(_OWORD *)(v6 - 24);
      *(void *)(v7 + 16) = *(void *)(v6 - 8);
      *(_OWORD *)uint64_t v7 = v8;
      *(unsigned char *)(v6 - 1) = 0;
      *(unsigned char *)(v6 - 24) = 0;
      a4 = v7;
      v6 -= 24;
    }
    while (v6 != a2);
  }
  return a3;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::string>,std::string*,std::string*,std::string*>(uint64_t a1, long long *a2, long long *a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v10 = a4;
  uint64_t v9 = a4;
  v7[0] = a1;
  v7[1] = &v9;
  void v7[2] = &v10;
  if (a2 != a3)
  {
    do
    {
      long long v5 = *a2;
      *(void *)(v4 + 16) = *((void *)a2 + 2);
      *(_OWORD *)uint64_t v4 = v5;
      v4 += 24;
      *((void *)a2 + 1) = 0;
      *((void *)a2 + 2) = 0;
      *(void *)a2 = 0;
      a2 = (long long *)((char *)a2 + 24);
    }
    while (a2 != a3);
    uint64_t v10 = v4;
  }
  char v8 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::string*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v7);
  return v4;
}

uint64_t ***MIL::Util::ForEachVariableName(uint64_t a1, uint64_t a2)
{
  uint64_t result = (uint64_t ***)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 72))(a1);
  for (unint64_t i = result[2]; i; unint64_t i = (uint64_t **)*i)
  {
    long long v5 = i[5];
    uint64_t v6 = (void *)(*(uint64_t (**)(uint64_t *))(*v5 + 128))(v5);
    uint64_t v7 = v6 + 1;
    char v8 = (void *)*v6;
    if ((void *)*v6 != v6 + 1)
    {
      do
      {
        uint64_t v9 = *(void *)(a2 + 24);
        if (!v9) {
          std::__throw_bad_function_call[abi:ne180100]();
        }
        (*(void (**)(uint64_t, void *))(*(void *)v9 + 48))(v9, v8 + 4);
        uint64_t v10 = (void *)v8[1];
        if (v10)
        {
          do
          {
            char v11 = v10;
            uint64_t v10 = (void *)*v10;
          }
          while (v10);
        }
        else
        {
          do
          {
            char v11 = (void *)v8[2];
            BOOL v12 = *v11 == (void)v8;
            char v8 = v11;
          }
          while (!v12);
        }
        char v8 = v11;
      }
      while (v11 != v7);
    }
    uint64_t result = (uint64_t ***)(*(uint64_t (**)(uint64_t *))(*v5 + 112))(v5);
    char v13 = result + 1;
    unint64_t v14 = *result;
    if (*result != (uint64_t **)(result + 1))
    {
      do
      {
        unint64_t v15 = v14[1];
        if (v15)
        {
          do
          {
            uint64_t v16 = (uint64_t **)v15;
            unint64_t v15 = (uint64_t *)*v15;
          }
          while (v15);
        }
        else
        {
          do
          {
            uint64_t v16 = (uint64_t **)v14[2];
            BOOL v12 = *v16 == (uint64_t *)v14;
            unint64_t v14 = v16;
          }
          while (!v12);
        }
        unint64_t v14 = v16;
      }
      while (v16 != (uint64_t **)v13);
    }
  }
  return result;
}

uint64_t ***MIL::Util::anonymous namespace'::ForEachVariableName(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  long long v5 = *(MIL::IRNamedValueType ***)v4;
  uint64_t v6 = *(MIL::IRNamedValueType ***)(v4 + 8);
  while (v5 != v6)
  {
    uint64_t Name = MIL::IRNamedValueType::GetName(*v5);
    uint64_t v8 = *(void *)(a2 + 24);
    if (!v8) {
LABEL_33:
    }
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(uint64_t, uint64_t))(*(void *)v8 + 48))(v8, Name);
    v5 += 2;
  }
  uint64_t v9 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 88))(a1);
  uint64_t v10 = *v9;
  uint64_t v11 = v9[1];
  while (v10 != v11)
  {
    uint64_t v12 = *(void *)(a2 + 24);
    if (!v12) {
      goto LABEL_33;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v12 + 48))(v12, v10);
    v10 += 24;
  }
  uint64_t result = (uint64_t ***)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 56))(a1);
  unint64_t v14 = **result;
  unint64_t v15 = (*result)[1];
  while (v14 != v15)
  {
    uint64_t v16 = *v14;
    unint64_t v17 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)*v14 + 160))(*v14);
    uint64_t v18 = v17 + 1;
    float v19 = (void *)*v17;
    if ((void *)*v17 != v17 + 1)
    {
      do
      {
        uint64_t v20 = v19[7];
        uint64_t v21 = v19[8];
        while (v20 != v21)
        {
          uint64_t v22 = (*(uint64_t (**)(void))(**(void **)v20 + 32))();
          if (v22)
          {
            uint64_t v23 = v22;
            uint64_t v24 = *(void *)(a2 + 24);
            if (!v24) {
              goto LABEL_33;
            }
            (*(void (**)(uint64_t, uint64_t))(*(void *)v24 + 48))(v24, v23);
          }
          v20 += 16;
        }
        uint64_t v25 = (void *)v19[1];
        if (v25)
        {
          do
          {
            uint64_t v26 = v25;
            uint64_t v25 = (void *)*v25;
          }
          while (v25);
        }
        else
        {
          do
          {
            uint64_t v26 = (void *)v19[2];
            BOOL v27 = *v26 == (void)v19;
            float v19 = v26;
          }
          while (!v27);
        }
        float v19 = v26;
      }
      while (v26 != v18);
    }
    uint64_t v28 = (*(uint64_t (**)(uint64_t))(*(void *)v16 + 176))(v16);
    uint64_t v29 = *(MIL::IRNamedValueType ***)v28;
    BOOL v30 = *(MIL::IRNamedValueType ***)(v28 + 8);
    while (v29 != v30)
    {
      uint64_t v31 = MIL::IRNamedValueType::GetName(*v29);
      uint64_t v32 = *(void *)(a2 + 24);
      if (!v32) {
        goto LABEL_33;
      }
      (*(void (**)(uint64_t, uint64_t))(*(void *)v32 + 48))(v32, v31);
      v29 += 2;
    }
    uint64_t result = (uint64_t ***)(*(uint64_t (**)(uint64_t))(*(void *)v16 + 208))(v16);
    uint64_t v33 = **result;
    uint64_t v34 = (*result)[1];
    while (v33 != v34)
    {
      uint64_t v35 = *v33;
      v33 += 2;
    }
    v14 += 2;
  }
  return result;
}

BOOL MIL::Util::DblApproxEqual(MIL::Util *this, double a2, double a3, double a4)
{
  if (a2 == a3) {
    return 1;
  }
  uint64_t v4 = 0;
  if (a2 > 0.0 != a3 > 0.0) {
    return v4;
  }
  if (vabdd_f64(a2, a3) <= fmax(a2, a3) * a4) {
    return 1;
  }
  uint64_t v5 = *(void *)&a2 - *(void *)&a3;
  if ((uint64_t)(*(void *)&a2 - *(void *)&a3) < 0) {
    uint64_t v5 = *(void *)&a3 - *(void *)&a2;
  }
  return v5 <= (int)this;
}

BOOL MIL::Util::FltApproxEqual(MIL::Util *this, float a2, float a3, float a4)
{
  if (a2 == a3) {
    return 1;
  }
  uint64_t v4 = 0;
  if (a2 > 0.0 != a3 > 0.0) {
    return v4;
  }
  if (vabds_f32(a2, a3) <= (float)(fmaxf(a2, a3) * a4)) {
    return 1;
  }
  int v5 = LODWORD(a2) - LODWORD(a3);
  if (LODWORD(a2) - LODWORD(a3) < 0) {
    int v5 = LODWORD(a3) - LODWORD(a2);
  }
  return v5 <= (int)this;
}

void *MIL::Util::HashCombine(void *this, unint64_t *a2)
{
  *this ^= (unint64_t)&a2[8 * *this + 331804471] + (*this >> 2) + 1;
  return this;
}

uint64_t MIL::Util::Walk(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, a1);
  if (result)
  {
    uint64_t v6 = (uint64_t **)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 208))(a1);
    uint64_t v7 = **v6;
    uint64_t v8 = (*v6)[1];
    if (v7 == v8)
    {
      return 1;
    }
    else
    {
      uint64_t v9 = v7 + 16;
      do
      {
        uint64_t result = MIL::Util::Walk(*(void *)(v9 - 16), a2);
        if (result) {
          BOOL v10 = v9 == v8;
        }
        else {
          BOOL v10 = 1;
        }
        v9 += 16;
      }
      while (!v10);
    }
  }
  return result;
}

{
  uint64_t **v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  BOOL v8;

  uint64_t v3 = (uint64_t **)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 56))(a1);
  uint64_t v4 = **v3;
  int v5 = (*v3)[1];
  if (v4 == v5) {
    return 1;
  }
  uint64_t v6 = v4 + 16;
  do
  {
    uint64_t result = MIL::Util::Walk(*(void *)(v6 - 16), a2);
    if (result) {
      uint64_t v8 = v6 == v5;
    }
    else {
      uint64_t v8 = 1;
    }
    v6 += 16;
  }
  while (!v8);
  return result;
}

{
  uint64_t **v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  BOOL v8;

  uint64_t v3 = (uint64_t **)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 208))(a1);
  uint64_t v4 = **v3;
  int v5 = (*v3)[1];
  if (v4 == v5) {
    return 1;
  }
  uint64_t v6 = v4 + 16;
  do
  {
    uint64_t result = MIL::Util::Walk(*(void *)(v6 - 16), a2);
    if (result) {
      uint64_t v8 = v6 == v5;
    }
    else {
      uint64_t v8 = 1;
    }
    v6 += 16;
  }
  while (!v8);
  return result;
}

{
  uint64_t v3;
  uint64_t result;
  uint64_t **v6;
  uint64_t v7;
  uint64_t v8;
  void **v9;
  void *v10;
  void *v11;

  uint64_t v3 = *(void *)(a2 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, a1);
  if (result)
  {
    uint64_t v6 = (uint64_t **)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 56))(a1);
    uint64_t v7 = **v6;
    uint64_t v8 = (*v6)[1];
    if (v7 == v8)
    {
      return 1;
    }
    else
    {
      while (2)
      {
        uint64_t v9 = (void **)(*(uint64_t (**)(void))(**(void **)v7 + 208))();
        BOOL v10 = (void *)**v9;
        uint64_t v11 = (void *)(*v9)[1];
        while (v10 != v11)
        {
          if ((MIL::Util::Walk(*v10, a2) & 1) == 0) {
            return 0;
          }
          v10 += 2;
        }
        v7 += 16;
        uint64_t result = 1;
        if (v7 != v8) {
          continue;
        }
        break;
      }
    }
  }
  return result;
}

{
  void *v3;
  void *v4;
  void *v5;
  uint64_t result;
  void *v7;
  void *v8;
  BOOL v9;

  uint64_t v3 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 112))(a1);
  uint64_t v4 = v3 + 1;
  int v5 = (void *)*v3;
  if ((void *)*v3 == v3 + 1) {
    return 1;
  }
  do
  {
    uint64_t result = MIL::Util::Walk(v5[7], a2);
    if (!result) {
      break;
    }
    uint64_t v7 = (void *)v5[1];
    if (v7)
    {
      do
      {
        uint64_t v8 = v7;
        uint64_t v7 = (void *)*v7;
      }
      while (v7);
    }
    else
    {
      do
      {
        uint64_t v8 = (void *)v5[2];
        uint64_t v9 = *v8 == (void)v5;
        int v5 = v8;
      }
      while (!v9);
    }
    int v5 = v8;
  }
  while (v8 != v4);
  return result;
}

{
  void *v3;
  void *v4;
  void *v5;
  uint64_t result;
  void *v7;
  void *v8;
  BOOL v9;

  uint64_t v3 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 112))(a1);
  uint64_t v4 = v3 + 1;
  int v5 = (void *)*v3;
  if ((void *)*v3 == v3 + 1) {
    return 1;
  }
  do
  {
    uint64_t result = MIL::Util::Walk(v5[7], a2);
    if (!result) {
      break;
    }
    uint64_t v7 = (void *)v5[1];
    if (v7)
    {
      do
      {
        uint64_t v8 = v7;
        uint64_t v7 = (void *)*v7;
      }
      while (v7);
    }
    else
    {
      do
      {
        uint64_t v8 = (void *)v5[2];
        uint64_t v9 = *v8 == (void)v5;
        int v5 = v8;
      }
      while (!v9);
    }
    int v5 = v8;
  }
  while (v8 != v4);
  return result;
}

uint64_t MIL::Util::Rewrite(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, a1);
  if (result)
  {
    uint64_t v6 = (uint64_t **)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 208))(a1);
    uint64_t v7 = **v6;
    uint64_t v8 = (*v6)[1];
    if (v7 == v8)
    {
      return 1;
    }
    else
    {
      uint64_t v9 = v7 + 16;
      do
      {
        uint64_t result = MIL::Util::Rewrite(*(void *)(v9 - 16), a2);
        if (result) {
          BOOL v10 = v9 == v8;
        }
        else {
          BOOL v10 = 1;
        }
        v9 += 16;
      }
      while (!v10);
    }
  }
  return result;
}

{
  uint64_t **v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  BOOL v8;

  uint64_t v3 = (uint64_t **)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 64))(a1);
  uint64_t v4 = **v3;
  int v5 = (*v3)[1];
  if (v4 == v5) {
    return 1;
  }
  uint64_t v6 = v4 + 16;
  do
  {
    uint64_t result = MIL::Util::Rewrite(*(void *)(v6 - 16), a2);
    if (result) {
      uint64_t v8 = v6 == v5;
    }
    else {
      uint64_t v8 = 1;
    }
    v6 += 16;
  }
  while (!v8);
  return result;
}

{
  uint64_t **v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  BOOL v8;

  uint64_t v3 = (uint64_t **)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 208))(a1);
  uint64_t v4 = **v3;
  int v5 = (*v3)[1];
  if (v4 == v5) {
    return 1;
  }
  uint64_t v6 = v4 + 16;
  do
  {
    uint64_t result = MIL::Util::Rewrite(*(void *)(v6 - 16), a2);
    if (result) {
      uint64_t v8 = v6 == v5;
    }
    else {
      uint64_t v8 = 1;
    }
    v6 += 16;
  }
  while (!v8);
  return result;
}

{
  uint64_t v3;
  uint64_t result;
  uint64_t **v6;
  uint64_t v7;
  uint64_t v8;
  void **v9;
  void *v10;
  void *v11;

  uint64_t v3 = *(void *)(a2 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, a1);
  if (result)
  {
    uint64_t v6 = (uint64_t **)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 64))(a1);
    uint64_t v7 = **v6;
    uint64_t v8 = (*v6)[1];
    if (v7 == v8)
    {
      return 1;
    }
    else
    {
      while (2)
      {
        uint64_t v9 = (void **)(*(uint64_t (**)(void))(**(void **)v7 + 208))();
        BOOL v10 = (void *)**v9;
        uint64_t v11 = (void *)(*v9)[1];
        while (v10 != v11)
        {
          if ((MIL::Util::Rewrite(*v10, a2) & 1) == 0) {
            return 0;
          }
          v10 += 2;
        }
        v7 += 16;
        uint64_t result = 1;
        if (v7 != v8) {
          continue;
        }
        break;
      }
    }
  }
  return result;
}

{
  void *v3;
  void *v4;
  void *v5;
  uint64_t result;
  void *v7;
  void *v8;
  BOOL v9;

  uint64_t v3 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 120))(a1);
  uint64_t v4 = v3 + 1;
  int v5 = (void *)*v3;
  if ((void *)*v3 == v3 + 1) {
    return 1;
  }
  do
  {
    uint64_t result = MIL::Util::Rewrite(v5[7], a2);
    if (!result) {
      break;
    }
    uint64_t v7 = (void *)v5[1];
    if (v7)
    {
      do
      {
        uint64_t v8 = v7;
        uint64_t v7 = (void *)*v7;
      }
      while (v7);
    }
    else
    {
      do
      {
        uint64_t v8 = (void *)v5[2];
        uint64_t v9 = *v8 == (void)v5;
        int v5 = v8;
      }
      while (!v9);
    }
    int v5 = v8;
  }
  while (v8 != v4);
  return result;
}

{
  void *v3;
  void *v4;
  void *v5;
  uint64_t result;
  void *v7;
  void *v8;
  BOOL v9;

  uint64_t v3 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 120))(a1);
  uint64_t v4 = v3 + 1;
  int v5 = (void *)*v3;
  if ((void *)*v3 == v3 + 1) {
    return 1;
  }
  do
  {
    uint64_t result = MIL::Util::Rewrite(v5[7], a2);
    if (!result) {
      break;
    }
    uint64_t v7 = (void *)v5[1];
    if (v7)
    {
      do
      {
        uint64_t v8 = v7;
        uint64_t v7 = (void *)*v7;
      }
      while (v7);
    }
    else
    {
      do
      {
        uint64_t v8 = (void *)v5[2];
        uint64_t v9 = *v8 == (void)v5;
        int v5 = v8;
      }
      while (!v9);
    }
    int v5 = v8;
  }
  while (v8 != v4);
  return result;
}

BOOL MIL::Util::Walk(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 72))(a1) + 16);
  do
    uint64_t v3 = (void *)*v3;
  while (v3 && (MIL::Util::Walk(v3[5], a2) & 1) != 0);
  return v3 == 0;
}

{
  void *v3;

  uint64_t v3 = (void *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 72))(a1) + 16);
  do
    uint64_t v3 = (void *)*v3;
  while (v3 && (MIL::Util::Walk(v3[5], a2) & 1) != 0);
  return v3 == 0;
}

{
  void *v3;
  uint64_t v4;

  uint64_t v3 = (void *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 72))(a1) + 16);
  do
  {
    uint64_t v3 = (void *)*v3;
    if (!v3) {
      break;
    }
    uint64_t v4 = *(void *)(a2 + 24);
    if (!v4) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
  }
  while (((*(uint64_t (**)(uint64_t, void))(*(void *)v4 + 48))(v4, v3[5]) & 1) != 0);
  return v3 == 0;
}

BOOL MIL::Util::Rewrite(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 72))(a1) + 16);
  do
    uint64_t v3 = (void *)*v3;
  while (v3 && (MIL::Util::Rewrite(v3[5], a2) & 1) != 0);
  return v3 == 0;
}

{
  void *v3;

  uint64_t v3 = (void *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 72))(a1) + 16);
  do
    uint64_t v3 = (void *)*v3;
  while (v3 && (MIL::Util::Rewrite(v3[5], a2) & 1) != 0);
  return v3 == 0;
}

{
  void *v3;
  uint64_t v4;

  uint64_t v3 = (void *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 72))(a1) + 16);
  do
  {
    uint64_t v3 = (void *)*v3;
    if (!v3) {
      break;
    }
    uint64_t v4 = *(void *)(a2 + 24);
    if (!v4) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
  }
  while (((*(uint64_t (**)(uint64_t, void))(*(void *)v4 + 48))(v4, v3[5]) & 1) != 0);
  return v3 == 0;
}

void MIL::Util::OnScopeExit::~OnScopeExit(MIL::Util::OnScopeExit *this)
{
  uint64_t v2 = *((void *)this + 3);
  if (!v2) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  (*(void (**)(uint64_t))(*(void *)v2 + 48))(v2);

  std::__function::__value_func<void ()(void)>::~__value_func[abi:ne180100](this);
}

void sub_20F49DE20(void *a1)
{
}

uint64_t std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

BOOL MIL::Util::OpMatchesPattern(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (uint64_t *)(a2 + 16);
  do
  {
    uint64_t v3 = (uint64_t *)*v3;
    if (!v3) {
      break;
    }
    uint64_t v4 = (const char *)(v3 + 2);
    if (*((char *)v3 + 39) < 0) {
      uint64_t v4 = *(const char **)v4;
    }
    int v5 = *(char *)(a1 + 23) >= 0 ? (const char *)a1 : *(const char **)a1;
  }
  while (fnmatch(v4, v5, 0));
  return v3 != 0;
}

uint64_t MIL::Util::IsConstexprOpTakingInputs(MIL::Util *this, const MIL::IROperator *a2)
{
  uint64_t result = (*(uint64_t (**)(MIL::Util *, const MIL::IROperator *))(*(void *)this + 104))(this, a2);
  if (result) {
    return (*(uint64_t (**)(MIL::Util *))(*(void *)this + 24))(this) != 0;
  }
  return result;
}

uint64_t MIL::Util::ValidTensorDataTypesStr(MIL::Util *this)
{
  uint64_t v1 = (MIL *)std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v16);
  ValidTensorDataTypes = (int *)MIL::GetValidTensorDataTypes(v1);
  if (v3)
  {
    uint64_t v4 = ValidTensorDataTypes;
    uint64_t v5 = 4 * v3;
    uint64_t v6 = "";
    do
    {
      int v7 = *v4;
      size_t v8 = strlen(v6);
      uint64_t v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)v6, v8);
      MIL::IRDataTypeToString(v7, __p);
      if ((v15 & 0x80u) == 0) {
        BOOL v10 = __p;
      }
      else {
        BOOL v10 = (void **)__p[0];
      }
      if ((v15 & 0x80u) == 0) {
        uint64_t v11 = v15;
      }
      else {
        uint64_t v11 = (uint64_t)__p[1];
      }
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)v10, v11);
      if ((char)v15 < 0) {
        operator delete(__p[0]);
      }
      ++v4;
      uint64_t v6 = ", ";
      v5 -= 4;
    }
    while (v5);
  }
  std::stringbuf::str();
  v16[0] = *MEMORY[0x263F8C2B8];
  uint64_t v12 = *(void *)(MEMORY[0x263F8C2B8] + 72);
  *(void *)((char *)v16 + *(void *)(v16[0] - 24)) = *(void *)(MEMORY[0x263F8C2B8] + 64);
  v17[0] = v12;
  v17[1] = MEMORY[0x263F8C318] + 16;
  if (v18 < 0) {
    operator delete((void *)v17[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x21056C620](&v19);
}

void sub_20F49E194(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
}

uint64_t MIL::Util::ApplyModelPath(uint64_t result, uint64_t a2, void *a3)
{
  unint64_t v3 = *(unsigned __int8 *)(result + 23);
  if ((v3 & 0x80u) == 0) {
    uint64_t v4 = (unsigned char *)result;
  }
  else {
    uint64_t v4 = *(unsigned char **)result;
  }
  if ((v3 & 0x80u) != 0) {
    unint64_t v3 = *(void *)(result + 8);
  }
  if (v3 >= 0xB) {
    unint64_t v3 = 11;
  }
  if (v3)
  {
    uint64_t v5 = &v4[v3];
    uint64_t v6 = v4;
    int v7 = v5;
    do
    {
      if (*v6 == 64)
      {
        uint64_t v8 = 1u;
        while (v8 != 11)
        {
          if (&v6[v8] == v5) {
            goto LABEL_19;
          }
          int v9 = v6[v8];
          int v10 = aModelPath_0[v8++];
          if (v9 != v10) {
            goto LABEL_11;
          }
        }
        int v7 = v6;
      }
LABEL_11:
      ++v6;
    }
    while (v6 != v5);
LABEL_19:
    if (v7 != v5 && v7 == v4)
    {
      uint64_t v11 = *(unsigned __int8 *)(a2 + 23);
      if ((v11 & 0x80u) != 0) {
        uint64_t v11 = *(void *)(a2 + 8);
      }
      if (v11) {
        std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100](v15, "@model_path", 0);
      }
      exception = __cxa_allocate_exception(0x48uLL);
      uint64_t v14 = a3[1];
      *(void *)&long long v17 = *a3;
      *((void *)&v17 + 1) = v14;
      if (v14) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
      }
      std::string::basic_string[abi:ne180100]<0>(v16, "Cannot interpret @model_path when ModelPath is unset");
      MIL::ParseError::ParseError((uint64_t)exception, &v17, (uint64_t)v16, 109);
    }
  }
  return result;
}

void sub_20F49E468(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,std::locale a22)
{
}

uint64_t MIL::Util::ApplyModelPath(uint64_t result, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(unsigned __int8 *)(result + 23);
  if ((v3 & 0x80u) == 0) {
    uint64_t v4 = (unsigned char *)result;
  }
  else {
    uint64_t v4 = *(unsigned char **)result;
  }
  if ((v3 & 0x80u) != 0) {
    unint64_t v3 = *(void *)(result + 8);
  }
  if (v3 >= 0xB) {
    unint64_t v3 = 11;
  }
  if (v3)
  {
    uint64_t v5 = result;
    uint64_t v6 = &v4[v3];
    int v7 = v4;
    uint64_t v8 = v6;
    do
    {
      if (*v7 == 64)
      {
        uint64_t v9 = 1u;
        while (v9 != 11)
        {
          if (&v7[v9] == v6) {
            goto LABEL_19;
          }
          int v10 = v7[v9];
          int v11 = aModelPath_0[v9++];
          if (v10 != v11) {
            goto LABEL_11;
          }
        }
        uint64_t v8 = v7;
      }
LABEL_11:
      ++v7;
    }
    while (v7 != v6);
LABEL_19:
    if (v8 != v6 && v8 == v4)
    {
      uint64_t v12 = *(unsigned __int8 *)(a3 + 23);
      if ((v12 & 0x80u) != 0) {
        uint64_t v12 = *(void *)(a3 + 8);
      }
      if (v12) {
        std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100](v14, "@model_path", 0);
      }
      __cxa_allocate_exception(0x48uLL);
      MIL::TextLocationFromScannerLocation(a2, v5);
    }
  }
  return result;
}

void sub_20F49E780(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,std::locale a23,std::__shared_weak_count *a24)
{
  if (*(char *)(v26 - 49) < 0) {
    operator delete(*(void **)(v26 - 72));
  }
  uint64_t v28 = *(std::__shared_weak_count **)(v26 - 40);
  if (v28) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v28);
  }
  if (a24)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](a24);
    if ((v25 & 1) == 0) {
      goto LABEL_10;
    }
  }
  else if (!v25)
  {
LABEL_10:
    _Unwind_Resume(exception_object);
  }
  __cxa_free_exception(v24);
  goto LABEL_10;
}

void MIL::Util::ReplaceModelPaths(std::string *__str, void *a2)
{
  v34[2] = *MEMORY[0x263EF8340];
  uint64_t v4 = (void *)*a2;
  uint64_t v2 = a2 + 1;
  unint64_t v3 = v4;
  if (v4 == v2) {
    return;
  }
  std::string::size_type size = HIBYTE(__str->__r_.__value_.__r.__words[2]);
  p_std::string::size_type size = &__str->__r_.__value_.__l.__size_;
  if ((size & 0x80u) == 0) {
    uint64_t v8 = __str;
  }
  else {
    uint64_t v8 = (std::string *)__str->__r_.__value_.__r.__words[0];
  }
  if ((size & 0x80u) != 0) {
    std::string::size_type size = __str->__r_.__value_.__l.__size_;
  }
  while (1)
  {
    char v9 = *((unsigned char *)v3 + 55);
    if (v9 < 0) {
      break;
    }
    if (*((unsigned char *)v3 + 55)) {
      goto LABEL_11;
    }
LABEL_32:
    uint64_t v16 = (void *)v3[1];
    if (v16)
    {
      do
      {
        long long v17 = v16;
        uint64_t v16 = (void *)*v16;
      }
      while (v16);
    }
    else
    {
      do
      {
        long long v17 = (void *)v3[2];
        BOOL v14 = *v17 == (void)v3;
        unint64_t v3 = v17;
      }
      while (!v14);
    }
    unint64_t v3 = v17;
    if (v17 == v2) {
      return;
    }
  }
  if (!v3[5]) {
    goto LABEL_32;
  }
LABEL_11:
  if (v9 >= 0) {
    int v10 = (unsigned __int8 *)(v3 + 4);
  }
  else {
    int v10 = (unsigned __int8 *)v3[4];
  }
  if (v9 >= 0) {
    std::string::size_type v11 = *((unsigned __int8 *)v3 + 55);
  }
  else {
    std::string::size_type v11 = v3[5];
  }
  if (size >= v11) {
    std::string::size_type v12 = v11;
  }
  else {
    std::string::size_type v12 = size;
  }
  char v13 = (unsigned __int8 *)v8 + v12;
  if (v11) {
    BOOL v14 = v12 == 0;
  }
  else {
    BOOL v14 = 1;
  }
  if (v14)
  {
    uint64_t v19 = (std::string *)((char *)v8 + v12);
  }
  else
  {
    char v18 = v8;
    uint64_t v19 = (std::string *)((char *)v8 + v12);
    do
    {
      if (v18->__r_.__value_.__s.__data_[0] == *v10)
      {
        uint64_t v20 = 1;
        while (v11 != v20)
        {
          if ((unsigned __int8 *)((char *)v18 + v20) == v13) {
            goto LABEL_26;
          }
          int v21 = v18->__r_.__value_.__s.__data_[v20];
          int v22 = v10[v20++];
          if (v21 != v22) {
            goto LABEL_40;
          }
        }
        uint64_t v19 = v18;
      }
LABEL_40:
      char v18 = (std::string *)((char *)v18 + 1);
    }
    while (v18 != (std::string *)v13);
  }
LABEL_26:
  BOOL v15 = v19 != (std::string *)v13 || v11 == 0;
  if (!v15 || v19 != v8) {
    goto LABEL_32;
  }
  std::string::basic_string(&__stra, __str, v11, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v32);
  if ((__stra.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_stra = &__stra;
  }
  else {
    p_stra = (std::string *)__stra.__r_.__value_.__r.__words[0];
  }
  if (p_stra->__r_.__value_.__s.__data_[0] == 47)
  {
    std::string::basic_string(&v32, &__stra, 1uLL, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v31);
    if (SHIBYTE(__stra.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__stra.__r_.__value_.__l.__data_);
    }
    std::string __stra = v32;
  }
  std::string::basic_string[abi:ne180100]<0>(&v31, "/");
  uint64_t v24 = std::string::insert(&v31, 0, "@model_path");
  long long v25 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
  v32.__r_.__value_.__r.__words[2] = v24->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v32.__r_.__value_.__l.__data_ = v25;
  v24->__r_.__value_.__l.__size_ = 0;
  v24->__r_.__value_.__r.__words[2] = 0;
  v24->__r_.__value_.__r.__words[0] = 0;
  if ((__stra.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v26 = &__stra;
  }
  else {
    uint64_t v26 = (std::string *)__stra.__r_.__value_.__r.__words[0];
  }
  if ((__stra.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v27 = HIBYTE(__stra.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v27 = __stra.__r_.__value_.__l.__size_;
  }
  uint64_t v28 = std::string::append(&v32, (const std::string::value_type *)v26, v27);
  std::string::size_type v29 = v28->__r_.__value_.__r.__words[0];
  v34[0] = v28->__r_.__value_.__l.__size_;
  *(void *)((char *)v34 + 7) = *(std::string::size_type *)((char *)&v28->__r_.__value_.__r.__words[1] + 7);
  char v30 = HIBYTE(v28->__r_.__value_.__r.__words[2]);
  v28->__r_.__value_.__l.__size_ = 0;
  v28->__r_.__value_.__r.__words[2] = 0;
  v28->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(__str->__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str->__r_.__value_.__l.__data_);
  }
  __str->__r_.__value_.__r.__words[0] = v29;
  *p_std::string::size_type size = v34[0];
  *(std::string::size_type *)((char *)p_size + 7) = *(void *)((char *)v34 + 7);
  *((unsigned char *)&__str->__r_.__value_.__s + 23) = v30;
  if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v32.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v31.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__stra.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__stra.__r_.__value_.__l.__data_);
  }
}

void sub_20F49EAE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::Util::GetBaseAndPrepIntStringForParse(std::string *a1)
{
  uint64_t v2 = (unsigned __int8 *)HIBYTE(a1->__r_.__value_.__r.__words[2]);
  int v3 = HIBYTE(a1->__r_.__value_.__r.__words[2]);
  if (SHIBYTE(a1->__r_.__value_.__r.__words[2]) < 0)
  {
    if (a1->__r_.__value_.__l.__size_) {
      std::string::size_type v5 = *(unsigned __int8 *)a1->__r_.__value_.__l.__data_ == 45;
    }
    else {
      std::string::size_type v5 = 0;
    }
    uint64_t v6 = (std::string *)a1->__r_.__value_.__r.__words[0];
    std::string::size_type size = (unsigned __int8 *)a1->__r_.__value_.__l.__size_;
  }
  else
  {
    if (*((unsigned char *)&a1->__r_.__value_.__s + 23)) {
      BOOL v4 = a1->__r_.__value_.__s.__data_[0] == 45;
    }
    else {
      BOOL v4 = 0;
    }
    std::string::size_type v5 = v4;
    uint64_t v6 = a1;
    std::string::size_type size = (unsigned __int8 *)HIBYTE(a1->__r_.__value_.__r.__words[2]);
  }
  if ((unint64_t)size >= v5)
  {
    uint64_t v8 = (char *)v6 + v5;
    char v9 = (char *)&size[(void)v6];
    uint64_t v10 = (uint64_t)&size[-v5];
    if (v10 >= 2)
    {
      do
      {
        std::string::size_type v11 = (char *)memchr(v8, 48, v10 - 1);
        if (!v11) {
          break;
        }
        if (*(_WORD *)v11 == 30768)
        {
          if (v11 != v9 && v11 - (char *)v6 == v5)
          {
LABEL_36:
            std::string::erase(a1, v5, 2uLL);
            return 16;
          }
          break;
        }
        uint64_t v8 = v11 + 1;
        uint64_t v10 = v9 - v8;
      }
      while (v9 - v8 >= 2);
    }
  }
  std::string::size_type v12 = (unsigned __int8 *)a1->__r_.__value_.__r.__words[0];
  char v13 = (unsigned __int8 *)a1->__r_.__value_.__l.__size_;
  if ((v3 & 0x80u) == 0) {
    BOOL v14 = a1;
  }
  else {
    BOOL v14 = (std::string *)a1->__r_.__value_.__r.__words[0];
  }
  if ((v3 & 0x80u) == 0) {
    BOOL v15 = v2;
  }
  else {
    BOOL v15 = (unsigned __int8 *)a1->__r_.__value_.__l.__size_;
  }
  if ((unint64_t)v15 >= v5)
  {
    uint64_t v16 = (char *)v14 + v5;
    long long v17 = (char *)&v15[(void)v14];
    uint64_t v18 = (uint64_t)&v15[-v5];
    if ((uint64_t)&v15[-v5] >= 2)
    {
      uint64_t v19 = &v15[-v5];
      uint64_t v20 = (char *)v14 + v5;
      do
      {
        int v21 = (char *)memchr(v20, 48, (size_t)(v19 - 1));
        if (!v21) {
          break;
        }
        if (*(_WORD *)v21 == 22576)
        {
          if (v21 != v17 && v21 - (char *)v14 == v5) {
            goto LABEL_36;
          }
          break;
        }
        uint64_t v20 = v21 + 1;
        uint64_t v19 = (unsigned __int8 *)(v17 - v20);
      }
      while (v17 - v20 >= 2);
      if (v18 < 2) {
        goto LABEL_48;
      }
      uint64_t v23 = v18;
      uint64_t v24 = (char *)v14 + v5;
      while (1)
      {
        long long v25 = (char *)memchr(v24, 48, v23 - 1);
        if (!v25) {
          goto LABEL_45;
        }
        if (*(_WORD *)v25 == 25136) {
          break;
        }
        uint64_t v24 = v25 + 1;
        uint64_t v23 = v17 - v24;
        if (v17 - v24 < 2) {
          goto LABEL_45;
        }
      }
      if (v25 != v17 && v25 - (char *)v14 == v5)
      {
LABEL_60:
        uint64_t v22 = 2;
        std::string::erase(a1, v5, 2uLL);
        return v22;
      }
LABEL_45:
      do
      {
        uint64_t v26 = (char *)memchr(v16, 48, v18 - 1);
        if (!v26) {
          break;
        }
        if (*(_WORD *)v26 == 16944)
        {
          if (v26 == v17 || v26 - (char *)v14 != v5) {
            break;
          }
          goto LABEL_60;
        }
        uint64_t v16 = v26 + 1;
        uint64_t v18 = v17 - (v26 + 1);
      }
      while (v18 >= 2);
    }
  }
LABEL_48:
  if ((v3 & 0x80) == 0)
  {
    if (v3)
    {
      int v27 = v12;
      goto LABEL_53;
    }
    return 10;
  }
  if (!v13) {
    return 10;
  }
  int v27 = *v12;
LABEL_53:
  if (v27 == 48) {
    return 8;
  }
  else {
    return 10;
  }
}

float MIL::Util::stof(const std::string *a1, uint64_t a2, uint64_t a3)
{
  *__error() = 0;
  std::string::size_type v6 = HIBYTE(a1->__r_.__value_.__r.__words[2]);
  if ((SHIBYTE(a1->__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (v6 <= 1 || a1->__r_.__value_.__s.__data_[v6 - 1] != 102)
    {
      v24.__r_.__value_.__r.__words[0] = 0;
      uint64_t v10 = (const char *)a1;
      goto LABEL_21;
    }
    int v7 = (const char *)a1->__r_.__value_.__r.__words[0];
    uint64_t v8 = (const char *)a1;
    unint64_t size = HIBYTE(a1->__r_.__value_.__r.__words[2]);
    goto LABEL_8;
  }
  uint64_t v8 = (const char *)a1->__r_.__value_.__r.__words[0];
  unint64_t size = a1->__r_.__value_.__l.__size_;
  if (size > 1)
  {
    int v7 = (const char *)a1->__r_.__value_.__r.__words[0];
    if (v8[size - 1] == 102)
    {
LABEL_8:
      int v11 = v8[size - 2];
      if (v11 < 0)
      {
        uint64_t v8 = v7;
      }
      else
      {
        int v12 = *(_DWORD *)(MEMORY[0x263EF8318] + 4 * v11 + 60);
        uint64_t v8 = v7;
        if ((v12 & 0x400) != 0)
        {
          if ((v6 & 0x80u) != 0) {
            std::string::size_type v6 = a1->__r_.__value_.__l.__size_;
          }
          std::string::basic_string(&v24, a1, 0, v6 - 1, (std::allocator<char> *)&v23);
          uint64_t v23 = 0;
          if ((v24.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            char v13 = &v24;
          }
          else {
            char v13 = (std::string *)v24.__r_.__value_.__r.__words[0];
          }
          float v14 = strtof_l((const char *)v13, &v23, 0);
          BOOL v15 = v23;
          if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
          {
            uint64_t v16 = (char *)(v24.__r_.__value_.__r.__words[0] + v24.__r_.__value_.__l.__size_);
            operator delete(v24.__r_.__value_.__l.__data_);
          }
          else
          {
            uint64_t v16 = (char *)&v24 + HIBYTE(v24.__r_.__value_.__r.__words[2]);
          }
          BOOL v19 = v15 == v16;
          goto LABEL_27;
        }
      }
    }
  }
  v24.__r_.__value_.__r.__words[0] = 0;
  if ((v6 & 0x80u) == 0) {
    uint64_t v10 = (const char *)a1;
  }
  else {
    uint64_t v10 = v8;
  }
LABEL_21:
  float v14 = strtof_l(v10, &v24.__r_.__value_.__l.__data_, 0);
  std::string::size_type v17 = HIBYTE(a1->__r_.__value_.__r.__words[2]);
  if ((v17 & 0x80u) == 0) {
    uint64_t v18 = a1;
  }
  else {
    uint64_t v18 = (const std::string *)a1->__r_.__value_.__r.__words[0];
  }
  if ((v17 & 0x80u) != 0) {
    std::string::size_type v17 = a1->__r_.__value_.__l.__size_;
  }
  BOOL v19 = v24.__r_.__value_.__r.__words[0] == (void)v18 + v17;
LABEL_27:
  char v20 = v19;
  if (*__error() == 34 && (v14 > 1.1755e-38 || v14 == 0.0 || v14 < -1.1755e-38))
  {
    __cxa_allocate_exception(0x48uLL);
    MIL::TextLocationFromScannerLocation(a2, a3);
  }
  if (!*__error())
  {
    if (v20) {
      return v14;
    }
LABEL_41:
    __cxa_allocate_exception(0x48uLL);
    MIL::TextLocationFromScannerLocation(a2, a3);
  }
  if (*__error() == 34) {
    char v21 = v20;
  }
  else {
    char v21 = 0;
  }
  if ((v21 & 1) == 0) {
    goto LABEL_41;
  }
  return v14;
}

void sub_20F49F0B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26)
{
  if (*(char *)(v26 - 73) < 0) {
    operator delete(*(void **)(v26 - 96));
  }
  _Unwind_Resume(exception_object);
}

double MIL::Util::stod(const std::string *a1, uint64_t a2, uint64_t a3)
{
  if (SHIBYTE(a1->__r_.__value_.__r.__words[2]) < 0)
  {
    unint64_t size = a1->__r_.__value_.__l.__size_;
    if (size <= 1) {
      goto LABEL_9;
    }
    uint64_t v8 = (const std::string *)a1->__r_.__value_.__r.__words[0];
    int v7 = *(unsigned __int8 *)(a1->__r_.__value_.__r.__words[0] + size - 1);
  }
  else
  {
    unint64_t size = HIBYTE(a1->__r_.__value_.__r.__words[2]);
    if (size <= 1) {
      goto LABEL_9;
    }
    int v7 = a1->__r_.__value_.__s.__data_[size - 1];
    uint64_t v8 = a1;
  }
  if (v7 == 102)
  {
    int v9 = v8->__r_.__value_.__s.__data_[size - 2];
    if ((v9 & 0x80000000) == 0 && (*(_DWORD *)(MEMORY[0x263EF8318] + 4 * v9 + 60) & 0x400) != 0) {
      return MIL::Util::stof(a1, a2, a3);
    }
  }
LABEL_9:
  *__error() = 0;
  uint64_t v16 = 0;
  if ((a1->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v10 = (const char *)a1;
  }
  else {
    uint64_t v10 = (const char *)a1->__r_.__value_.__r.__words[0];
  }
  double v11 = strtod_l(v10, &v16, 0);
  if (*__error() == 34)
  {
    if (v11 > 2.22507386e-308 || (v11 != 0.0 ? (BOOL v12 = v11 < -2.22507386e-308) : (BOOL v12 = 1), v12))
    {
      __cxa_allocate_exception(0x48uLL);
      MIL::TextLocationFromScannerLocation(a2, a3);
    }
  }
  if (*__error() && *__error() != 34) {
    goto LABEL_28;
  }
  std::string::size_type v13 = HIBYTE(a1->__r_.__value_.__r.__words[2]);
  uint64_t v14 = (v13 & 0x80u) == 0 ? (uint64_t)a1 : a1->__r_.__value_.__r.__words[0];
  if ((v13 & 0x80u) != 0) {
    std::string::size_type v13 = a1->__r_.__value_.__l.__size_;
  }
  if (v16 != (char *)(v14 + v13))
  {
LABEL_28:
    __cxa_allocate_exception(0x48uLL);
    MIL::TextLocationFromScannerLocation(a2, a3);
  }
  return v11;
}

void sub_20F49F3BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,std::__shared_weak_count *a26)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  char v30 = *(std::__shared_weak_count **)(v28 - 72);
  if (v30) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v30);
  }
  if (a26) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a26);
  }
  if (v27) {
    __cxa_free_exception(v26);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::Util::stoi(const std::string *a1, int __base)
{
  return std::stoi(a1, 0, __base);
}

uint64_t MIL::Util::stoui8(const std::string *a1, int a2, uint64_t a3, uint64_t a4)
{
  LODWORD(result) = MIL::Util::stoi(a1, a2);
  if (result >= 0x100)
  {
    __cxa_allocate_exception(0x48uLL);
    MIL::TextLocationFromScannerLocation(a3, a4);
  }
  return result;
}

void sub_20F49F72C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, std::__shared_weak_count *a19)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a19) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a19);
  }
  if (a17)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](a17);
    if ((v20 & 1) == 0) {
      goto LABEL_10;
    }
  }
  else if (!v20)
  {
LABEL_10:
    _Unwind_Resume(exception_object);
  }
  __cxa_free_exception(v19);
  goto LABEL_10;
}

uint64_t MIL::Util::stoll(const std::string *a1, int __base)
{
  return std::stoll(a1, 0, __base);
}

unint64_t MIL::Util::stoull(std::string *__str, int __base, uint64_t a3, uint64_t a4)
{
  if ((__str->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v6 = __str;
  }
  else {
    std::string::size_type v6 = (std::string *)__str->__r_.__value_.__r.__words[0];
  }
  if (v6->__r_.__value_.__s.__data_[0] == 45)
  {
    __cxa_allocate_exception(0x48uLL);
    MIL::TextLocationFromScannerLocation(a3, a4);
  }
  return std::stoull(__str, 0, __base);
}

void sub_20F49FA94(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, long long a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, long long a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
}

void sub_20F49FC0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,std::__shared_weak_count *a26)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a26) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a26);
  }
  char v30 = *(std::__shared_weak_count **)(v28 - 72);
  if (v30)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v30);
    if ((v26 & 1) == 0) {
      goto LABEL_10;
    }
  }
  else if (!v26)
  {
LABEL_10:
    __cxa_end_catch();
    _Unwind_Resume(a1);
  }
  __cxa_free_exception(v27);
  goto LABEL_10;
}

void sub_20F49FC80()
{
}

void MIL::Util::ValidateIsIdentifier()
{
}

{
  MIL::Scanner::Make();
}

void sub_20F49FE14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21,uint64_t a22,std::__shared_weak_count *a23)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  UnknownLocationImpl::~UnknownLocationImpl((UnknownLocationImpl *)&a16);
  if (a23) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a23);
  }
  if (a21)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](a21);
    if ((v24 & 1) == 0) {
      goto LABEL_10;
    }
  }
  else if (!v24)
  {
LABEL_10:
    UnknownLocationImpl::~UnknownLocationImpl((UnknownLocationImpl *)(v25 - 72));
    uint64_t v27 = *(void *)(v25 - 40);
    *(void *)(v25 - 40) = 0;
    if (v27) {
      (*(void (**)(uint64_t))(*(void *)v27 + 8))(v27);
    }
    _Unwind_Resume(a1);
  }
  __cxa_free_exception(v23);
  goto LABEL_10;
}

void sub_20F49FFF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20,char a21)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  UnknownLocationImpl::~UnknownLocationImpl((UnknownLocationImpl *)&a15);
  if (a20) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a20);
  }
  if (v22) {
    __cxa_free_exception(v21);
  }
  UnknownLocationImpl::~UnknownLocationImpl((UnknownLocationImpl *)&a21);
  uint64_t v25 = *(void *)(v23 - 40);
  *(void *)(v23 - 40) = 0;
  if (v25) {
    (*(void (**)(uint64_t))(*(void *)v25 + 8))(v25);
  }
  _Unwind_Resume(a1);
}

void std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100](std::regex_traits<char> *a1, const char *a2, int a3)
{
  std::string::size_type v5 = std::regex_traits<char>::regex_traits(a1);
  LODWORD(v5[1].__loc_.__locale_) = a3;
  *(_OWORD *)((char *)&v5[1].__loc_.__locale_ + 4) = 0u;
  *(_OWORD *)((char *)&v5[1].__col_ + 4) = 0u;
  HIDWORD(v5[2].__ct_) = 0;
  strlen(a2);
  std::basic_regex<char,std::regex_traits<char>>::__parse<char const*>();
}

void sub_20F4A00F4(_Unwind_Exception *a1)
{
  locale = (std::__shared_weak_count *)v1[6].__locale_;
  if (locale) {
    std::__shared_weak_count::__release_shared[abi:ne180100](locale);
  }
  std::locale::~locale(v1);
  _Unwind_Resume(a1);
}

void std::basic_regex<char,std::regex_traits<char>>::__parse<char const*>()
{
}

void sub_20F4A02D4(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse_ecma_exp<char const*>(std::basic_regex<char> *a1, unsigned __int8 *a2, char *a3)
{
  std::vector<std::string>::pointer end = a1->__end_;
  int v7 = a2;
  do
  {
    uint64_t v8 = v7;
    int v7 = std::basic_regex<char,std::regex_traits<char>>::__parse_term<char const*>(a1, (char *)v7, a3);
  }
  while (v7 != v8);
  if (v8 == a2) {
    operator new();
  }
  while (v8 != (unsigned __int8 *)a3)
  {
    if (*v8 != 124) {
      return (char *)v8;
    }
    int v9 = a1->__end_;
    uint64_t v10 = v8 + 1;
    double v11 = v8 + 1;
    do
    {
      uint64_t v8 = v11;
      double v11 = std::basic_regex<char,std::regex_traits<char>>::__parse_term<char const*>(a1, (char *)v11, a3);
    }
    while (v11 != v8);
    if (v8 == v10) {
      operator new();
    }
    std::basic_regex<char,std::regex_traits<char>>::__push_alternation(a1, end, v9);
  }
  return a3;
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse_basic_reg_exp<char const*>(std::basic_regex<char> *this, unsigned __int8 *a2, unsigned __int8 *a3)
{
  int v3 = a2;
  if (a2 == a3) {
    return (char *)a2;
  }
  BOOL v4 = (char *)a3;
  if (*a2 == 94)
  {
    std::basic_regex<char,std::regex_traits<char>>::__push_l_anchor(this);
    ++v3;
  }
  if (v3 != (unsigned __int8 *)v4)
  {
    do
    {
      std::string::size_type v6 = v3;
      int v3 = std::basic_regex<char,std::regex_traits<char>>::__parse_simple_RE<char const*>(this, (char *)v3, v4);
    }
    while (v3 != v6);
    if (v6 != (unsigned __int8 *)v4)
    {
      if (v6 + 1 != (unsigned __int8 *)v4 || *v6 != 36) {
        std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)15>();
      }
      std::basic_regex<char,std::regex_traits<char>>::__push_r_anchor(this);
    }
  }
  return v4;
}

std::basic_regex<char> *std::basic_regex<char,std::regex_traits<char>>::__parse_extended_reg_exp<char const*>(std::basic_regex<char> *a1, std::basic_regex<char> *a2, std::basic_regex<char> *a3)
{
  int v3 = a3;
  std::vector<std::string>::pointer end = a1->__end_;
  int v7 = std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_branch<char const*>(a1, a2, a3);
  if (v7 == (unsigned __int8 *)a2) {
LABEL_9:
  }
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)15>();
  uint64_t v8 = v7;
  while (v8 != (unsigned __int8 *)v3)
  {
    if (*v8 != 124) {
      return (std::basic_regex<char> *)v8;
    }
    int v9 = a1->__end_;
    uint64_t v10 = std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_branch<char const*>(a1, (std::basic_regex<char> *)(v8 + 1), v3);
    if (v10 == v8 + 1) {
      goto LABEL_9;
    }
    uint64_t v8 = v10;
    std::basic_regex<char,std::regex_traits<char>>::__push_alternation(a1, end, v9);
  }
  return v3;
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_grep<char const*>(std::basic_regex<char> *a1, unsigned __int8 *__s, unsigned __int8 *a3)
{
  std::vector<std::string>::pointer end = a1->__end_;
  int v7 = (unsigned __int8 *)memchr(__s, 10, a3 - __s);
  if (v7) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = a3;
  }
  if (v8 == __s) {
    operator new();
  }
  std::basic_regex<char,std::regex_traits<char>>::__parse_basic_reg_exp<char const*>(a1, __s, v8);
  while (1)
  {
    double v11 = v8 == a3 ? v8 : v8 + 1;
    if (v11 == a3) {
      break;
    }
    int v9 = (unsigned __int8 *)memchr(v11, 10, a3 - v11);
    if (v9) {
      uint64_t v8 = v9;
    }
    else {
      uint64_t v8 = a3;
    }
    uint64_t v10 = a1->__end_;
    if (v8 == v11) {
      operator new();
    }
    std::basic_regex<char,std::regex_traits<char>>::__parse_basic_reg_exp<char const*>(a1, v11, v8);
    std::basic_regex<char,std::regex_traits<char>>::__push_alternation(a1, end, v10);
  }
  return a3;
}

std::basic_regex<char> *std::basic_regex<char,std::regex_traits<char>>::__parse_egrep<char const*>(std::basic_regex<char> *a1, std::basic_regex<char> *__s, std::basic_regex<char> *a3)
{
  std::vector<std::string>::pointer end = a1->__end_;
  int v7 = (std::basic_regex<char> *)memchr(__s, 10, (char *)a3 - (char *)__s);
  if (v7) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = a3;
  }
  if (v8 == __s) {
    operator new();
  }
  std::basic_regex<char,std::regex_traits<char>>::__parse_extended_reg_exp<char const*>(a1, __s, v8);
  while (1)
  {
    double v11 = v8 == a3 ? v8 : (std::basic_regex<char> *)((char *)&v8->__traits_.__loc_.__locale_ + 1);
    if (v11 == a3) {
      break;
    }
    int v9 = (std::basic_regex<char> *)memchr(v11, 10, (char *)a3 - (char *)v11);
    if (v9) {
      uint64_t v8 = v9;
    }
    else {
      uint64_t v8 = a3;
    }
    uint64_t v10 = a1->__end_;
    if (v8 == v11) {
      operator new();
    }
    std::basic_regex<char,std::regex_traits<char>>::__parse_extended_reg_exp<char const*>(a1, v11, v8);
    std::basic_regex<char,std::regex_traits<char>>::__push_alternation(a1, end, v10);
  }
  return a3;
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_term<char const*>(std::basic_regex<char> *a1, char *a2, char *a3)
{
  uint64_t result = (unsigned __int8 *)std::basic_regex<char,std::regex_traits<char>>::__parse_assertion<char const*>(a1, a2, a3);
  if (result == (unsigned __int8 *)a2)
  {
    std::vector<std::string>::pointer end = a1->__end_;
    unsigned int marked_count = a1->__marked_count_;
    int v9 = std::basic_regex<char,std::regex_traits<char>>::__parse_atom<char const*>(a1, a2, a3);
    uint64_t result = (unsigned __int8 *)a2;
    if (v9 != (unsigned __int8 *)a2)
    {
      size_t v10 = a1->__marked_count_ + 1;
      return std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_dupl_symbol<char const*>((uint64_t)a1, v9, (unsigned __int8 *)a3, end, marked_count + 1, v10);
    }
  }
  return result;
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse_assertion<char const*>(std::basic_regex<char> *this, char *a2, char *a3)
{
  int v3 = a2;
  if (a2 == a3) {
    return v3;
  }
  int v6 = *a2;
  if (v6 <= 91)
  {
    if (v6 != 36)
    {
      BOOL v8 = v6 == 40;
      int v7 = a2 + 1;
      BOOL v8 = !v8 || v7 == a3;
      if (!v8)
      {
        BOOL v8 = *v7 == 63;
        int v9 = a2 + 2;
        if (v8 && v9 != a3)
        {
          int v11 = *v9;
          if (v11 == 33)
          {
            std::regex_traits<char>::regex_traits(&v18.__traits_);
            memset(&v18.__flags_, 0, 40);
            v18.__flags_ = this->__flags_;
            BOOL v12 = (char *)std::basic_regex<char,std::regex_traits<char>>::__parse<char const*>(&v18, v3 + 3, a3);
            unsigned int marked_count = v18.__marked_count_;
            std::basic_regex<char,std::regex_traits<char>>::__push_lookahead(this, &v18, 1, this->__marked_count_);
            this->__marked_count_ += marked_count;
            if (v12 == a3 || *v12 != 41) {
              std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)6>();
            }
            goto LABEL_31;
          }
          if (v11 == 61)
          {
            std::regex_traits<char>::regex_traits(&v18.__traits_);
            memset(&v18.__flags_, 0, 40);
            v18.__flags_ = this->__flags_;
            BOOL v12 = (char *)std::basic_regex<char,std::regex_traits<char>>::__parse<char const*>(&v18, v3 + 3, a3);
            unsigned int v13 = v18.__marked_count_;
            std::basic_regex<char,std::regex_traits<char>>::__push_lookahead(this, &v18, 0, this->__marked_count_);
            this->__marked_count_ += v13;
            if (v12 == a3 || *v12 != 41) {
              std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)6>();
            }
LABEL_31:
            int v3 = v12 + 1;
            std::basic_regex<char,std::regex_traits<char>>::~basic_regex(&v18.__traits_.__loc_);
            return v3;
          }
        }
      }
      return v3;
    }
    std::basic_regex<char,std::regex_traits<char>>::__push_r_anchor(this);
    return ++v3;
  }
  if (v6 != 92)
  {
    if (v6 != 94) {
      return v3;
    }
    std::basic_regex<char,std::regex_traits<char>>::__push_l_anchor(this);
    return ++v3;
  }
  if (a2 + 1 != a3)
  {
    int v15 = a2[1];
    if (v15 == 66)
    {
      BOOL v16 = 1;
    }
    else
    {
      if (v15 != 98) {
        return v3;
      }
      BOOL v16 = 0;
    }
    std::basic_regex<char,std::regex_traits<char>>::__push_word_boundary(this, v16);
    v3 += 2;
  }
  return v3;
}

void sub_20F4A0B24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::locale a9)
{
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_atom<char const*>(std::basic_regex<char> *this, char *a2, char *a3)
{
  int v3 = a2;
  if (a2 == a3) {
    return (unsigned __int8 *)v3;
  }
  int v6 = *a2;
  if (v6 <= 62)
  {
    if (v6 != 40)
    {
      if (v6 == 46) {
        operator new();
      }
      if ((v6 - 42) >= 2) {
        goto LABEL_28;
      }
LABEL_34:
      std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)11>();
    }
    if (a2 + 1 != a3)
    {
      if (a2 + 2 != a3 && a2[1] == 63 && a2[2] == 58)
      {
        p_open_count = &this->__open_count_;
        ++this->__open_count_;
        int v9 = (char *)std::basic_regex<char,std::regex_traits<char>>::__parse_ecma_exp<char const*>(this, a2 + 3, a3);
        if (v9 == a3) {
          goto LABEL_35;
        }
        size_t v10 = v9;
        if (*v9 != 41) {
          goto LABEL_35;
        }
        goto LABEL_25;
      }
      std::basic_regex<char,std::regex_traits<char>>::__push_begin_marked_subexpression(this);
      unsigned int marked_count = this->__marked_count_;
      p_open_count = &this->__open_count_;
      ++this->__open_count_;
      BOOL v12 = (char *)std::basic_regex<char,std::regex_traits<char>>::__parse_ecma_exp<char const*>(this, v3 + 1, a3);
      if (v12 != a3)
      {
        size_t v10 = v12;
        if (*v12 == 41)
        {
          std::basic_regex<char,std::regex_traits<char>>::__push_end_marked_subexpression(this, marked_count);
LABEL_25:
          --*p_open_count;
          return (unsigned __int8 *)(v10 + 1);
        }
      }
    }
LABEL_35:
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)6>();
  }
  if (v6 <= 91)
  {
    if (v6 == 91)
    {
      return (unsigned __int8 *)std::basic_regex<char,std::regex_traits<char>>::__parse_bracket_expression<char const*>((uint64_t)this, a2, a3);
    }
    if (v6 == 63) {
      goto LABEL_34;
    }
LABEL_28:
    return std::basic_regex<char,std::regex_traits<char>>::__parse_pattern_character<std::__wrap_iter<char const*>>(this, a2, a3);
  }
  if (v6 != 92)
  {
    if (v6 == 123) {
      goto LABEL_34;
    }
    goto LABEL_28;
  }

  return std::basic_regex<char,std::regex_traits<char>>::__parse_atom_escape<char const*>(this, (unsigned __int8 *)a2, (unsigned __int8 *)a3);
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_dupl_symbol<char const*>(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3, std::__owns_one_state<char> *__s, size_t a5, size_t a6)
{
  if (a2 == a3) {
    return a2;
  }
  unsigned int v6 = a6;
  unsigned int v7 = a5;
  uint64_t v10 = a1;
  int v11 = *(_DWORD *)(a1 + 24) & 0x1F0;
  int v12 = (char)*a2;
  if (v12 > 62)
  {
    if (v12 == 63)
    {
      unsigned int v13 = a2 + 1;
      if (v11) {
        BOOL v20 = 1;
      }
      else {
        BOOL v20 = v13 == a3;
      }
      if (!v20 && *v13 == 63)
      {
        unsigned int v13 = a2 + 2;
        a5 = a5;
        a6 = a6;
        size_t v14 = 0;
        size_t v18 = 1;
        goto LABEL_33;
      }
      a5 = a5;
      a6 = a6;
      size_t v14 = 0;
      size_t v18 = 1;
      goto LABEL_45;
    }
    if (v12 != 123) {
      return a2;
    }
    int v15 = a2 + 1;
    BOOL v16 = std::basic_regex<char,std::regex_traits<char>>::__parse_DUP_COUNT<std::__wrap_iter<char const*>>(a1, a2 + 1, a3, (int *)&__max);
    if (v16 != v15)
    {
      if (v16 != a3)
      {
        int v17 = (char)*v16;
        if (v17 != 44)
        {
          if (v17 == 125)
          {
            unsigned int v13 = v16 + 1;
            if (!v11 && v13 != a3 && *v13 == 63)
            {
              unsigned int v13 = v16 + 2;
              size_t v14 = (int)__max;
              a5 = v7;
              a6 = v6;
              a1 = v10;
              size_t v18 = (int)__max;
LABEL_33:
              char v21 = __s;
              BOOL v22 = 0;
LABEL_46:
              std::basic_regex<char,std::regex_traits<char>>::__push_loop((std::basic_regex<char> *)a1, v14, v18, v21, a5, a6, v22);
              return v13;
            }
            size_t v14 = (int)__max;
            a5 = v7;
            a6 = v6;
            a1 = v10;
            size_t v18 = (int)__max;
LABEL_45:
            char v21 = __s;
            BOOL v22 = 1;
            goto LABEL_46;
          }
          goto LABEL_58;
        }
        uint64_t v23 = v16 + 1;
        if (v16 + 1 == a3) {
          goto LABEL_58;
        }
        if (*v23 == 125)
        {
          unsigned int v13 = v16 + 2;
          if (!v11 && v13 != a3 && *v13 == 63)
          {
            unsigned int v13 = v16 + 3;
            size_t v14 = (int)__max;
            a5 = v7;
            a6 = v6;
            a1 = v10;
            goto LABEL_26;
          }
          size_t v14 = (int)__max;
          a5 = v7;
          a6 = v6;
          a1 = v10;
LABEL_36:
          size_t v18 = -1;
          goto LABEL_45;
        }
        int v27 = -1;
        uint64_t v25 = std::basic_regex<char,std::regex_traits<char>>::__parse_DUP_COUNT<std::__wrap_iter<char const*>>(v10, v23, a3, &v27);
        if (v25 != v23 && v25 != a3 && *v25 == 125)
        {
          size_t v18 = v27;
          size_t v14 = (int)__max;
          if (v27 >= (int)__max)
          {
            unsigned int v13 = v25 + 1;
            BOOL v22 = 1;
            if (!v11 && v13 != a3)
            {
              int v26 = v25[1];
              BOOL v22 = v26 != 63;
              if (v26 == 63) {
                unsigned int v13 = v25 + 2;
              }
            }
            a5 = v7;
            a6 = v6;
            a1 = v10;
            char v21 = __s;
            goto LABEL_46;
          }
          goto LABEL_58;
        }
      }
      std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)7>();
    }
LABEL_58:
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)8>();
  }
  if (v12 == 42)
  {
    unsigned int v13 = a2 + 1;
    if (v11) {
      BOOL v19 = 1;
    }
    else {
      BOOL v19 = v13 == a3;
    }
    if (!v19 && *v13 == 63)
    {
      unsigned int v13 = a2 + 2;
      a5 = a5;
      a6 = a6;
      size_t v14 = 0;
      goto LABEL_26;
    }
    a5 = a5;
    a6 = a6;
    size_t v14 = 0;
    goto LABEL_36;
  }
  if (v12 == 43)
  {
    unsigned int v13 = a2 + 1;
    if (!v11 && v13 != a3 && *v13 == 63)
    {
      unsigned int v13 = a2 + 2;
      a5 = a5;
      a6 = a6;
      size_t v14 = 1;
LABEL_26:
      size_t v18 = -1;
      goto LABEL_33;
    }
    a5 = a5;
    a6 = a6;
    size_t v14 = 1;
    goto LABEL_36;
  }
  return a2;
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_atom_escape<char const*>(std::basic_regex<char> *a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (a2 == a3 || *a2 != 92) {
    return a2;
  }
  std::string::size_type v5 = a2 + 1;
  if (a2 + 1 == a3) {
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)3>();
  }
  uint64_t result = std::basic_regex<char,std::regex_traits<char>>::__parse_decimal_escape<char const*>(a1, a2 + 1, a3);
  if (result == v5)
  {
    uint64_t result = (unsigned __int8 *)std::basic_regex<char,std::regex_traits<char>>::__parse_character_class_escape<std::__wrap_iter<char const*>>(a1, (char *)a2 + 1, (char *)a3);
    if (result == v5)
    {
      uint64_t result = (unsigned __int8 *)std::basic_regex<char,std::regex_traits<char>>::__parse_character_escape<char const*>(a1, (std::basic_regex<char> *)(a2 + 1), (std::basic_regex<char> *)a3, 0);
      if (result == v5) {
        return a2;
      }
    }
  }
  return result;
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse_bracket_expression<char const*>(uint64_t a1, char *a2, char *a3)
{
  if (a2 != a3 && *a2 == 91)
  {
    if (a2 + 1 == a3) {
      goto LABEL_20;
    }
    std::string::size_type v5 = a2[1] == 94 ? a2 + 2 : a2 + 1;
    started = std::basic_regex<char,std::regex_traits<char>>::__start_matching_list((std::basic_regex<char> *)a1, a2[1] == 94);
    if (v5 == a3) {
      goto LABEL_20;
    }
    unsigned int v7 = (uint64_t *)started;
    if ((*(_WORD *)(a1 + 24) & 0x1F0) != 0 && *v5 == 93)
    {
      std::__bracket_expression<char,std::regex_traits<char>>::__add_char[abi:ne180100]((uint64_t)started, 93);
      ++v5;
    }
    if (v5 == a3) {
      goto LABEL_20;
    }
    do
    {
      BOOL v8 = v5;
      std::string::size_type v5 = std::basic_regex<char,std::regex_traits<char>>::__parse_expression_term<char const*>(a1, v5, a3, v7);
    }
    while (v5 != v8);
    if (v8 == a3) {
      goto LABEL_20;
    }
    if (*v8 == 45)
    {
      std::__bracket_expression<char,std::regex_traits<char>>::__add_char[abi:ne180100]((uint64_t)v7, 45);
      ++v8;
    }
    if (v8 == a3 || *v8 != 93) {
LABEL_20:
    }
      std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)5>();
    return v8 + 1;
  }
  return a2;
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_decimal_escape<char const*>(std::basic_regex<char> *a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (a2 == a3) {
    return a2;
  }
  int v4 = *a2;
  unsigned int v5 = v4 - 48;
  if (v4 == 48)
  {
    std::basic_regex<char,std::regex_traits<char>>::__push_char(a1, v5);
    return a2 + 1;
  }
  if ((v4 - 49) > 8) {
    return a2;
  }
  unsigned int v6 = a3;
  unsigned int v7 = a2 + 1;
  if (a2 + 1 != a3)
  {
    while (1)
    {
      int v8 = *v7;
      if ((v8 - 48) > 9) {
        break;
      }
      if (v5 >= 0x19999999) {
        goto LABEL_16;
      }
      ++v7;
      unsigned int v5 = v8 + 10 * v5 - 48;
      if (v7 == a3) {
        goto LABEL_12;
      }
    }
    unsigned int v6 = v7;
LABEL_12:
    if (!v5) {
      goto LABEL_16;
    }
  }
  if (v5 > a1->__marked_count_) {
LABEL_16:
  }
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)4>();
  std::basic_regex<char,std::regex_traits<char>>::__push_back_ref(a1, v5);
  return v6;
}

std::basic_regex<char> *std::basic_regex<char,std::regex_traits<char>>::__parse_character_escape<char const*>(std::basic_regex<char> *a1, std::basic_regex<char> *this, std::basic_regex<char> *a3, std::string *a4)
{
  int v4 = this;
  if (this != a3)
  {
    int locale_low = SLOBYTE(this->__traits_.__loc_.__locale_);
    if (locale_low > 109)
    {
      char v6 = 0;
      switch(LOBYTE(this->__traits_.__loc_.__locale_))
      {
        case 'n':
          if (a4)
          {
            unsigned int v7 = a4;
            std::basic_regex<char>::value_type locale = 10;
            goto LABEL_50;
          }
          std::basic_regex<char>::value_type locale = 10;
          goto LABEL_59;
        case 'r':
          if (a4)
          {
            unsigned int v7 = a4;
            std::basic_regex<char>::value_type locale = 13;
            goto LABEL_50;
          }
          std::basic_regex<char>::value_type locale = 13;
          goto LABEL_59;
        case 't':
          if (a4)
          {
            unsigned int v7 = a4;
            std::basic_regex<char>::value_type locale = 9;
            goto LABEL_50;
          }
          std::basic_regex<char>::value_type locale = 9;
          goto LABEL_59;
        case 'u':
          if ((std::basic_regex<char> *)((char *)&this->__traits_.__loc_.__locale_ + 1) == a3) {
            goto LABEL_64;
          }
          int v9 = BYTE1(this->__traits_.__loc_.__locale_);
          if ((v9 & 0xF8) != 0x30 && (v9 & 0xFE) != 0x38 && (v9 | 0x20u) - 97 >= 6) {
            goto LABEL_64;
          }
          int v4 = (std::basic_regex<char> *)((char *)&this->__traits_.__loc_.__locale_ + 2);
          if ((std::basic_regex<char> *)((char *)&this->__traits_.__loc_.__locale_ + 2) == a3) {
            goto LABEL_64;
          }
          int v10 = LOBYTE(v4->__traits_.__loc_.__locale_);
          char v11 = -48;
          if ((v10 & 0xF8) == 0x30 || (v10 & 0xFE) == 0x38) {
            goto LABEL_24;
          }
          v10 |= 0x20u;
          if ((v10 - 97) >= 6) {
            goto LABEL_64;
          }
          char v11 = -87;
LABEL_24:
          char v6 = 16 * (v11 + v10);
LABEL_25:
          if ((std::basic_regex<char> *)((char *)&v4->__traits_.__loc_.__locale_ + 1) == a3) {
            goto LABEL_64;
          }
          int v12 = BYTE1(v4->__traits_.__loc_.__locale_);
          char v13 = -48;
          if ((v12 & 0xF8) == 0x30 || (v12 & 0xFE) == 0x38) {
            goto LABEL_30;
          }
          v12 |= 0x20u;
          if ((v12 - 97) >= 6) {
            goto LABEL_64;
          }
          char v13 = -87;
LABEL_30:
          if ((std::basic_regex<char> *)((char *)&v4->__traits_.__loc_.__locale_ + 2) == a3) {
            goto LABEL_64;
          }
          int v14 = BYTE2(v4->__traits_.__loc_.__locale_);
          char v15 = -48;
          if ((v14 & 0xF8) == 0x30 || (v14 & 0xFE) == 0x38) {
            goto LABEL_35;
          }
          v14 |= 0x20u;
          if ((v14 - 97) >= 6) {
            goto LABEL_64;
          }
          char v15 = -87;
LABEL_35:
          std::string::value_type v16 = v15 + v14 + 16 * (v13 + v12 + v6);
          if (a4) {
            std::string::operator=(a4, v16);
          }
          else {
            std::basic_regex<char,std::regex_traits<char>>::__push_char(a1, v16);
          }
          return (std::basic_regex<char> *)((char *)v4 + 3);
        case 'v':
          if (a4)
          {
            unsigned int v7 = a4;
            std::basic_regex<char>::value_type locale = 11;
            goto LABEL_50;
          }
          std::basic_regex<char>::value_type locale = 11;
          break;
        case 'x':
          goto LABEL_25;
        default:
          goto LABEL_45;
      }
      goto LABEL_59;
    }
    if (locale_low == 48)
    {
      if (a4)
      {
        unsigned int v7 = a4;
        std::basic_regex<char>::value_type locale = 0;
        goto LABEL_50;
      }
      std::basic_regex<char>::value_type locale = 0;
LABEL_59:
      std::basic_regex<char,std::regex_traits<char>>::__push_char(a1, locale);
      return (std::basic_regex<char> *)((char *)v4 + 1);
    }
    if (locale_low != 99)
    {
      if (locale_low == 102)
      {
        if (a4)
        {
          unsigned int v7 = a4;
          std::basic_regex<char>::value_type locale = 12;
LABEL_50:
          std::string::operator=(v7, locale);
          return (std::basic_regex<char> *)((char *)v4 + 1);
        }
        std::basic_regex<char>::value_type locale = 12;
        goto LABEL_59;
      }
LABEL_45:
      if (LOBYTE(this->__traits_.__loc_.__locale_) != 95
        && ((locale_low & 0x80) != 0
         || (a1->__traits_.__ct_->__tab_[LOBYTE(this->__traits_.__loc_.__locale_)] & 0x500) == 0))
      {
        std::basic_regex<char>::value_type locale = (std::basic_regex<char>::value_type)this->__traits_.__loc_.__locale_;
        if (a4)
        {
          unsigned int v7 = a4;
          goto LABEL_50;
        }
        goto LABEL_59;
      }
LABEL_64:
      std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)3>();
    }
    if ((std::basic_regex<char> *)((char *)&this->__traits_.__loc_.__locale_ + 1) == a3) {
      goto LABEL_64;
    }
    char v17 = BYTE1(this->__traits_.__loc_.__locale_);
    if (((v17 & 0xDF) - 65) > 0x19u) {
      goto LABEL_64;
    }
    std::string::value_type v18 = v17 & 0x1F;
    if (a4) {
      std::string::operator=(a4, v18);
    }
    else {
      std::basic_regex<char,std::regex_traits<char>>::__push_char(a1, v18);
    }
    return (std::basic_regex<char> *)((char *)v4 + 2);
  }
  return v4;
}

unsigned char *std::basic_regex<char,std::regex_traits<char>>::__parse_expression_term<char const*>(uint64_t a1, char *a2, char *a3, uint64_t *a4)
{
  int v4 = a2;
  if (a2 == a3) {
    return v4;
  }
  int v5 = *a2;
  if (v5 == 93) {
    return v4;
  }
  uint64_t v6 = (uint64_t)a4;
  memset(&v26, 0, sizeof(v26));
  if (a2 + 1 == a3 || v5 != 91)
  {
LABEL_9:
    int v11 = *(_DWORD *)(a1 + 24) & 0x1F0;
    goto LABEL_10;
  }
  int v9 = a2[1];
  if (v9 != 46)
  {
    if (v9 == 58)
    {
      uint64_t v10 = std::basic_regex<char,std::regex_traits<char>>::__parse_character_class<char const*>(a1, a2 + 2, a3, (uint64_t)a4);
      goto LABEL_34;
    }
    if (v9 == 61)
    {
      uint64_t v10 = std::basic_regex<char,std::regex_traits<char>>::__parse_equivalence_class<char const*>(a1, a2 + 2, a3, a4);
LABEL_34:
      uint64_t v6 = v10;
      char v20 = 0;
      goto LABEL_38;
    }
    goto LABEL_9;
  }
  uint64_t v18 = std::basic_regex<char,std::regex_traits<char>>::__parse_collating_symbol<char const*>(a1, a2 + 2, a3, (uint64_t)&v26);
  int v4 = (unsigned char *)v18;
  int v11 = *(_DWORD *)(a1 + 24) & 0x1F0;
  std::string::size_type size = HIBYTE(v26.__r_.__value_.__r.__words[2]);
  if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = v26.__r_.__value_.__l.__size_;
  }
  int v14 = (char *)v18;
  if (!size)
  {
LABEL_10:
    if ((v11 | 0x40) == 0x40)
    {
      int v12 = *v4;
      if (v12 == 92)
      {
        char v13 = v4 + 1;
        if (v11)
        {
          int v14 = std::basic_regex<char,std::regex_traits<char>>::__parse_awk_escape<char const*>((std::basic_regex<char> *)a1, v13, a3, &v26);
        }
        else
        {
          int v14 = (char *)std::basic_regex<char,std::regex_traits<char>>::__parse_class_escape<char const*>((std::basic_regex<char> *)a1, (std::basic_regex<char> *)v13, (std::basic_regex<char> *)a3, &v26, v6);
          int v11 = 0;
        }
        goto LABEL_16;
      }
    }
    else
    {
      LOBYTE(v12) = *v4;
    }
    std::string::operator=(&v26, v12);
    int v14 = v4 + 1;
  }
LABEL_16:
  if (v14 == a3
    || (int v15 = *v14, v15 == 93)
    || (std::string::value_type v16 = v14 + 1, v14 + 1 == a3)
    || v15 != 45
    || *v16 == 93)
  {
    if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0)
    {
      if (v26.__r_.__value_.__l.__size_)
      {
        if (v26.__r_.__value_.__l.__size_ != 1)
        {
          char v17 = (std::string *)v26.__r_.__value_.__r.__words[0];
LABEL_36:
          std::__bracket_expression<char,std::regex_traits<char>>::__add_digraph[abi:ne180100](v6, v17->__r_.__value_.__s.__data_[0], v17->__r_.__value_.__s.__data_[1]);
          goto LABEL_37;
        }
        char v17 = (std::string *)v26.__r_.__value_.__r.__words[0];
        goto LABEL_28;
      }
    }
    else if (*((unsigned char *)&v26.__r_.__value_.__s + 23))
    {
      char v17 = &v26;
      if (HIBYTE(v26.__r_.__value_.__r.__words[2]) != 1) {
        goto LABEL_36;
      }
LABEL_28:
      std::__bracket_expression<char,std::regex_traits<char>>::__add_char[abi:ne180100](v6, v17->__r_.__value_.__s.__data_[0]);
    }
LABEL_37:
    char v20 = 1;
    int v4 = v14;
    goto LABEL_38;
  }
  memset(&v25, 0, sizeof(v25));
  int v4 = v14 + 2;
  if (v14 + 2 != a3 && *v16 == 91 && *v4 == 46)
  {
    uint64_t v22 = std::basic_regex<char,std::regex_traits<char>>::__parse_collating_symbol<char const*>(a1, v14 + 3, a3, (uint64_t)&v25);
LABEL_55:
    int v4 = (unsigned char *)v22;
    goto LABEL_56;
  }
  if ((v11 | 0x40) == 0x40)
  {
    LODWORD(v16) = *v16;
    if (v16 == 92)
    {
      if (v11) {
        uint64_t v22 = (uint64_t)std::basic_regex<char,std::regex_traits<char>>::__parse_awk_escape<char const*>((std::basic_regex<char> *)a1, v14 + 2, a3, &v25);
      }
      else {
        uint64_t v22 = (uint64_t)std::basic_regex<char,std::regex_traits<char>>::__parse_class_escape<char const*>((std::basic_regex<char> *)a1, (std::basic_regex<char> *)(v14 + 2), (std::basic_regex<char> *)a3, &v25, v6);
      }
      goto LABEL_55;
    }
  }
  else
  {
    LOBYTE(v16) = *v16;
  }
  std::string::operator=(&v25, (std::string::value_type)v16);
LABEL_56:
  std::string v24 = v26;
  memset(&v26, 0, sizeof(v26));
  std::string __p = v25;
  memset(&v25, 0, sizeof(v25));
  std::__bracket_expression<char,std::regex_traits<char>>::__add_range[abi:ne180100](v6, (char *)&v24, (char *)&__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v24.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v25.__r_.__value_.__l.__data_);
  }
  char v20 = 1;
LABEL_38:
  if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v26.__r_.__value_.__l.__data_);
  }
  if (v20) {
    return v4;
  }
  return (unsigned char *)v6;
}

void sub_20F4A195C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  if (*(char *)(v28 - 49) < 0) {
    operator delete(*(void **)(v28 - 72));
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::basic_regex<char,std::regex_traits<char>>::__parse_equivalence_class<char const*>(uint64_t a1, char *a2, char *a3, uint64_t *a4)
{
  if (a3 - a2 < 2 || a3 - 1 == a2) {
    goto LABEL_33;
  }
  for (uint64_t i = 0; a2[i] != 61 || a2[i + 1] != 93; ++i)
  {
    if (a3 - a2 - 2 == i) {
      goto LABEL_33;
    }
  }
  if (&a2[i] == a3) {
LABEL_33:
  }
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)5>();
  std::regex_traits<char>::__lookup_collatename<char const*>(a1, a2, &a2[i], (uint64_t)&v17);
  if (((char)v19 & 0x80000000) == 0)
  {
    uint64_t v8 = v19;
    if (v19)
    {
      int v9 = (char *)&v17;
      goto LABEL_14;
    }
LABEL_34:
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)1>();
  }
  uint64_t v8 = v18;
  if (!v18) {
    goto LABEL_34;
  }
  int v9 = (char *)v17;
LABEL_14:
  std::regex_traits<char>::__transform_primary<std::__wrap_iter<char *>>(a1, v9, &v9[v8], (uint64_t)__p);
  unint64_t v10 = v16;
  if ((v16 & 0x80u) != 0) {
    unint64_t v10 = (unint64_t)__p[1];
  }
  if (v10)
  {
    std::__bracket_expression<char,std::regex_traits<char>>::__add_equivalence[abi:ne180100](a4, (long long *)__p);
  }
  else
  {
    uint64_t v11 = v19;
    if ((v19 & 0x80u) != 0) {
      uint64_t v11 = v18;
    }
    if (v11 == 2)
    {
      char v13 = (char *)&v17;
      if ((v19 & 0x80u) != 0) {
        char v13 = (char *)v17;
      }
      std::__bracket_expression<char,std::regex_traits<char>>::__add_digraph[abi:ne180100]((uint64_t)a4, *v13, v13[1]);
    }
    else
    {
      if (v11 != 1) {
        std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)1>();
      }
      int v12 = (char *)&v17;
      if ((v19 & 0x80u) != 0) {
        int v12 = (char *)v17;
      }
      std::__bracket_expression<char,std::regex_traits<char>>::__add_char[abi:ne180100]((uint64_t)a4, *v12);
    }
  }
  if ((char)v16 < 0) {
    operator delete(__p[0]);
  }
  if ((char)v19 < 0) {
    operator delete(v17);
  }
  return (uint64_t)&a2[i + 2];
}

void sub_20F4A1B64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::basic_regex<char,std::regex_traits<char>>::__parse_character_class<char const*>(uint64_t a1, char *a2, char *a3, uint64_t a4)
{
  if (a3 - a2 < 2 || a3 - 1 == a2) {
    goto LABEL_11;
  }
  for (uint64_t i = 0; a2[i] != 58 || a2[i + 1] != 93; ++i)
  {
    if (a3 - a2 - 2 == i) {
      goto LABEL_11;
    }
  }
  if (&a2[i] == a3) {
LABEL_11:
  }
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)5>();
  int v7 = std::regex_traits<char>::__lookup_classname<char const*>(a1, a2, &a2[i], *(unsigned char *)(a1 + 24) & 1);
  if (!v7) {
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)2>();
  }
  *(_DWORD *)(a4 + 160) |= v7;
  return (uint64_t)&a2[i + 2];
}

uint64_t std::basic_regex<char,std::regex_traits<char>>::__parse_collating_symbol<char const*>(uint64_t a1, char *a2, char *a3, uint64_t a4)
{
  if (a3 - a2 < 2 || a3 - 1 == a2) {
    goto LABEL_15;
  }
  for (uint64_t i = 0; a2[i] != 46 || a2[i + 1] != 93; ++i)
  {
    if (a3 - a2 - 2 == i) {
      goto LABEL_15;
    }
  }
  if (&a2[i] == a3) {
LABEL_15:
  }
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)5>();
  std::regex_traits<char>::__lookup_collatename<char const*>(a1, a2, &a2[i], (uint64_t)&v10);
  if (*(char *)(a4 + 23) < 0) {
    operator delete(*(void **)a4);
  }
  *(_OWORD *)a4 = v10;
  unint64_t v7 = v11;
  *(void *)(a4 + 16) = v11;
  unint64_t v8 = HIBYTE(v7);
  if ((v8 & 0x80u) != 0) {
    unint64_t v8 = *(void *)(a4 + 8);
  }
  if (v8 - 1 >= 2) {
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)1>();
  }
  return (uint64_t)&a2[i + 2];
}

std::basic_regex<char> *std::basic_regex<char,std::regex_traits<char>>::__parse_class_escape<char const*>(std::basic_regex<char> *a1, std::basic_regex<char> *this, std::basic_regex<char> *a3, std::string *a4, uint64_t a5)
{
  if (this == a3) {
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)3>();
  }
  int locale_low = SLOBYTE(this->__traits_.__loc_.__locale_);
  if (locale_low > 97)
  {
    if (locale_low > 114)
    {
      if (locale_low != 115)
      {
        if (locale_low != 119) {
          goto LABEL_25;
        }
        *(_DWORD *)(a5 + 160) |= 0x500u;
        std::__bracket_expression<char,std::regex_traits<char>>::__add_char[abi:ne180100](a5, 95);
        return (std::basic_regex<char> *)((char *)&this->__traits_.__loc_.__locale_ + 1);
      }
      int v8 = *(_DWORD *)(a5 + 160) | 0x4000;
    }
    else
    {
      if (locale_low == 98)
      {
        long long v10 = a4;
        std::string::value_type v9 = 8;
LABEL_19:
        std::string::operator=(v10, v9);
        return (std::basic_regex<char> *)((char *)&this->__traits_.__loc_.__locale_ + 1);
      }
      if (locale_low != 100) {
        goto LABEL_25;
      }
      int v8 = *(_DWORD *)(a5 + 160) | 0x400;
    }
    *(_DWORD *)(a5 + 160) = v8;
    return (std::basic_regex<char> *)((char *)&this->__traits_.__loc_.__locale_ + 1);
  }
  if (locale_low <= 82)
  {
    if (LOBYTE(this->__traits_.__loc_.__locale_))
    {
      if (locale_low == 68)
      {
        int v7 = *(_DWORD *)(a5 + 164) | 0x400;
LABEL_21:
        *(_DWORD *)(a5 + 164) = v7;
        return (std::basic_regex<char> *)((char *)&this->__traits_.__loc_.__locale_ + 1);
      }
      goto LABEL_25;
    }
    std::string::value_type v9 = 0;
    long long v10 = a4;
    goto LABEL_19;
  }
  if (locale_low == 83)
  {
    int v7 = *(_DWORD *)(a5 + 164) | 0x4000;
    goto LABEL_21;
  }
  if (locale_low == 87)
  {
    *(_DWORD *)(a5 + 164) |= 0x500u;
    std::__bracket_expression<char,std::regex_traits<char>>::__add_neg_char[abi:ne180100](a5, 95);
    return (std::basic_regex<char> *)((char *)&this->__traits_.__loc_.__locale_ + 1);
  }
LABEL_25:

  return std::basic_regex<char,std::regex_traits<char>>::__parse_character_escape<char const*>(a1, this, a3, a4);
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse_awk_escape<char const*>(std::basic_regex<char> *a1, char *a2, char *a3, std::string *this)
{
  if (a2 == a3) {
LABEL_52:
  }
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)3>();
  int v5 = *a2;
  if (v5 > 97)
  {
    switch(v5)
    {
      case 'n':
        if (this)
        {
          uint64_t v6 = this;
          LOBYTE(v5) = 10;
          goto LABEL_16;
        }
        LOBYTE(v5) = 10;
        goto LABEL_49;
      case 'o':
      case 'p':
      case 'q':
      case 's':
      case 'u':
        goto LABEL_21;
      case 'r':
        if (this)
        {
          uint64_t v6 = this;
          LOBYTE(v5) = 13;
          goto LABEL_16;
        }
        LOBYTE(v5) = 13;
        goto LABEL_49;
      case 't':
        if (this)
        {
          uint64_t v6 = this;
          LOBYTE(v5) = 9;
          goto LABEL_16;
        }
        LOBYTE(v5) = 9;
        goto LABEL_49;
      case 'v':
        if (this)
        {
          uint64_t v6 = this;
          LOBYTE(v5) = 11;
          goto LABEL_16;
        }
        LOBYTE(v5) = 11;
        goto LABEL_49;
      default:
        if (v5 == 98)
        {
          if (this)
          {
            uint64_t v6 = this;
            LOBYTE(v5) = 8;
            goto LABEL_16;
          }
          LOBYTE(v5) = 8;
        }
        else
        {
          if (v5 != 102) {
            goto LABEL_21;
          }
          if (this)
          {
            uint64_t v6 = this;
            LOBYTE(v5) = 12;
            goto LABEL_16;
          }
          LOBYTE(v5) = 12;
        }
        break;
    }
    goto LABEL_49;
  }
  if (v5 > 91)
  {
    if (v5 != 92)
    {
      if (v5 != 97) {
        goto LABEL_21;
      }
      if (this)
      {
        uint64_t v6 = this;
        LOBYTE(v5) = 7;
LABEL_16:
        std::string::operator=(v6, v5);
        return a2 + 1;
      }
      LOBYTE(v5) = 7;
LABEL_49:
      std::basic_regex<char,std::regex_traits<char>>::__push_char(a1, v5);
      return a2 + 1;
    }
LABEL_14:
    if (this)
    {
      uint64_t v6 = this;
      goto LABEL_16;
    }
    goto LABEL_49;
  }
  if (v5 == 34 || v5 == 47) {
    goto LABEL_14;
  }
LABEL_21:
  if ((v5 & 0xFFFFFFF8) != 0x30) {
    goto LABEL_52;
  }
  std::string::value_type v7 = v5 - 48;
  int v8 = a2 + 1;
  if (a2 + 1 != a3)
  {
    if ((*v8 & 0xF8) != 0x30) {
      goto LABEL_39;
    }
    std::string::value_type v7 = *v8 + 8 * v7 - 48;
    if (a2 + 2 != a3)
    {
      char v9 = a2[2];
      int v10 = v9 & 0xF8;
      std::string::value_type v11 = v9 + 8 * v7 - 48;
      if (v10 == 48) {
        int v8 = a2 + 3;
      }
      else {
        int v8 = a2 + 2;
      }
      if (v10 == 48) {
        std::string::value_type v7 = v11;
      }
      goto LABEL_39;
    }
  }
  int v8 = a3;
LABEL_39:
  if (this) {
    std::string::operator=(this, v7);
  }
  else {
    std::basic_regex<char,std::regex_traits<char>>::__push_char(a1, v7);
  }
  return v8;
}

void std::regex_traits<char>::__lookup_collatename<char const*>(uint64_t a1@<X0>, char *a2@<X1>, char *a3@<X2>, uint64_t a4@<X8>)
{
  std::string::__init_with_size[abi:ne180100]<char *,char *>(&__s, a2, a3, a3 - a2);
  *(void *)a4 = 0;
  *(void *)(a4 + 8) = 0;
  *(void *)(a4 + 16) = 0;
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
  {
    if (!__s.__r_.__value_.__l.__size_) {
      goto LABEL_9;
    }
    p_s = (std::string *)__s.__r_.__value_.__r.__words[0];
  }
  else
  {
    if (!*((unsigned char *)&__s.__r_.__value_.__s + 23)) {
      return;
    }
    p_s = &__s;
  }
  std::__get_collation_name(&v11, (const char *)p_s);
  *(_OWORD *)a4 = *(_OWORD *)&v11.__r_.__value_.__l.__data_;
  unint64_t v7 = v11.__r_.__value_.__r.__words[2];
  *(void *)(a4 + 16) = *((void *)&v11.__r_.__value_.__l + 2);
  unint64_t v8 = HIBYTE(v7);
  if ((v8 & 0x80u) != 0) {
    unint64_t v8 = *(void *)(a4 + 8);
  }
  if (v8) {
    goto LABEL_9;
  }
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
  {
    if (__s.__r_.__value_.__l.__size_ >= 3) {
      goto LABEL_9;
    }
  }
  else if (HIBYTE(__s.__r_.__value_.__r.__words[2]) >= 3u)
  {
    return;
  }
  (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 16) + 32))(&v11);
  if (*(char *)(a4 + 23) < 0) {
    operator delete(*(void **)a4);
  }
  *(std::string *)a4 = v11;
  if ((*(char *)(a4 + 23) & 0x80000000) == 0)
  {
    int v9 = *(unsigned __int8 *)(a4 + 23);
    if (v9 != 12 && v9 != 1)
    {
      *(unsigned char *)a4 = 0;
      *(unsigned char *)(a4 + 23) = 0;
      goto LABEL_9;
    }
    goto LABEL_23;
  }
  uint64_t v10 = *(void *)(a4 + 8);
  if (v10 == 1 || v10 == 12)
  {
LABEL_23:
    std::string::operator=((std::string *)a4, &__s);
    goto LABEL_9;
  }
  **(unsigned char **)a4 = 0;
  *(void *)(a4 + 8) = 0;
LABEL_9:
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__s.__r_.__value_.__l.__data_);
  }
}

void sub_20F4A2208(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (*(char *)(v17 + 23) < 0) {
    operator delete(*(void **)v17);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::regex_traits<char>::__lookup_classname<char const*>(uint64_t a1, char *a2, char *a3, BOOL a4)
{
  std::string::__init_with_size[abi:ne180100]<char *,char *>(__p, a2, a3, a3 - a2);
  unint64_t v6 = v12;
  if ((v12 & 0x80u) == 0) {
    unint64_t v7 = __p;
  }
  else {
    unint64_t v7 = (void **)__p[0];
  }
  if ((v12 & 0x80u) != 0) {
    unint64_t v6 = (unint64_t)__p[1];
  }
  (*(void (**)(void, void **, char *))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8), v7, (char *)v7 + v6);
  if ((v12 & 0x80u) == 0) {
    unint64_t v8 = __p;
  }
  else {
    unint64_t v8 = (void **)__p[0];
  }
  uint64_t classname = std::__get_classname((const char *)v8, a4);
  if ((char)v12 < 0) {
    operator delete(__p[0]);
  }
  return classname;
}

void sub_20F4A22F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_simple_RE<char const*>(std::basic_regex<char> *a1, char *a2, char *a3)
{
  if (a2 == a3) {
    return (unsigned __int8 *)a2;
  }
  std::vector<std::string>::pointer end = a1->__end_;
  unsigned int marked_count = a1->__marked_count_;
  unint64_t v8 = (unsigned __int8 *)std::basic_regex<char,std::regex_traits<char>>::__parse_nondupl_RE<char const*>(a1, a2, a3);
  if (v8 == (unsigned __int8 *)a2) {
    return (unsigned __int8 *)a2;
  }
  size_t v9 = a1->__marked_count_ + 1;

  return std::basic_regex<char,std::regex_traits<char>>::__parse_RE_dupl_symbol<char const*>(a1, v8, (unsigned __int8 *)a3, end, marked_count + 1, v9);
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse_nondupl_RE<char const*>(std::basic_regex<char> *a1, char *a2, char *a3)
{
  unint64_t v6 = std::basic_regex<char,std::regex_traits<char>>::__parse_one_char_or_coll_elem_RE<char const*>(a1, a2, a3);
  unint64_t v7 = v6;
  if (v6 == a2 && v6 != a3)
  {
    if (a2 + 1 == a3 || *a2 != 92)
    {
      return a2;
    }
    else
    {
      int v8 = a2[1];
      if (v8 == 40)
      {
        uint64_t v9 = (uint64_t)(a2 + 2);
        std::basic_regex<char,std::regex_traits<char>>::__push_begin_marked_subexpression(a1);
        unsigned int marked_count = a1->__marked_count_;
        do
        {
          std::string v11 = (char *)v9;
          uint64_t v9 = std::basic_regex<char,std::regex_traits<char>>::__parse_simple_RE<char const*>(a1, v9, a3);
        }
        while ((char *)v9 != v11);
        if (v11 == a3 || v11 + 1 == a3 || *v11 != 92 || v11[1] != 41) {
          std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)6>();
        }
        unint64_t v7 = v11 + 2;
        std::basic_regex<char,std::regex_traits<char>>::__push_end_marked_subexpression(a1, marked_count);
      }
      else
      {
        BOOL v13 = std::basic_regex<char,std::regex_traits<char>>::__test_back_ref(a1, v8);
        uint64_t v14 = 2;
        if (!v13) {
          uint64_t v14 = 0;
        }
        return &a2[v14];
      }
    }
  }
  return v7;
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_RE_dupl_symbol<char const*>(std::basic_regex<char> *this, unsigned __int8 *a2, unsigned __int8 *a3, std::__owns_one_state<char> *__s, size_t __mexp_begin, size_t __mexp_end)
{
  unint64_t v6 = a2;
  if (a2 != a3)
  {
    unsigned int v7 = __mexp_end;
    unsigned int v8 = __mexp_begin;
    int v11 = *a2;
    if (v11 == 42)
    {
      std::basic_regex<char,std::regex_traits<char>>::__push_loop(this, 0, 0xFFFFFFFFFFFFFFFFLL, __s, __mexp_begin, __mexp_end, 1);
      return ++v6;
    }
    if (a2 + 1 != a3 && v11 == 92 && a2[1] == 123)
    {
      BOOL v13 = a2 + 2;
      int v25 = 0;
      uint64_t v14 = std::basic_regex<char,std::regex_traits<char>>::__parse_DUP_COUNT<std::__wrap_iter<char const*>>((uint64_t)this, a2 + 2, a3, &v25);
      if (v14 == v13) {
        goto LABEL_16;
      }
      if (v14 != a3)
      {
        int v15 = v14 + 1;
        int v16 = *v14;
        if (v16 == 44)
        {
          int v24 = -1;
          uint64_t v17 = std::basic_regex<char,std::regex_traits<char>>::__parse_DUP_COUNT<std::__wrap_iter<char const*>>((uint64_t)this, v15, a3, &v24);
          if (v17 != a3 && v17 + 1 != a3 && *v17 == 92 && v17[1] == 125)
          {
            size_t v19 = v24;
            size_t v18 = v25;
            if (v24 == -1)
            {
              size_t v19 = -1;
            }
            else if (v24 < v25)
            {
LABEL_16:
              std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)8>();
            }
            unint64_t v6 = &v17[2 * (v17[1] == 125)];
            size_t v20 = v8;
            size_t v21 = v7;
            uint64_t v22 = this;
LABEL_23:
            std::basic_regex<char,std::regex_traits<char>>::__push_loop(v22, v18, v19, __s, v20, v21, 1);
            return v6;
          }
        }
        else if (v15 != a3 && v16 == 92 && *v15 == 125)
        {
          unint64_t v6 = v14 + 2;
          size_t v18 = v25;
          size_t v20 = v8;
          size_t v21 = v7;
          uint64_t v22 = this;
          size_t v19 = v25;
          goto LABEL_23;
        }
      }
      std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)7>();
    }
  }
  return v6;
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse_one_char_or_coll_elem_RE<char const*>(std::basic_regex<char> *this, char *a2, char *a3)
{
  if (a2 == a3)
  {
    uint64_t result = std::basic_regex<char,std::regex_traits<char>>::__parse_QUOTED_CHAR<std::__wrap_iter<char const*>>(this, a2, a3);
    if (result != a2) {
      return result;
    }
  }
  else
  {
    int v6 = *a2;
    if ((a2 + 1 != a3 || v6 != 36)
      && ((v6 - 46) > 0x2E || ((1 << (v6 - 46)) & 0x600000000001) == 0))
    {
      std::basic_regex<char,std::regex_traits<char>>::__push_char(this, v6);
      return a2 + 1;
    }
    uint64_t result = std::basic_regex<char,std::regex_traits<char>>::__parse_QUOTED_CHAR<std::__wrap_iter<char const*>>(this, a2, a3);
    if (result != a2) {
      return result;
    }
    if (*a2 == 46) {
      operator new();
    }
  }

  return std::basic_regex<char,std::regex_traits<char>>::__parse_bracket_expression<char const*>((uint64_t)this, a2, a3);
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_branch<char const*>(std::basic_regex<char> *a1, std::basic_regex<char> *a2, std::basic_regex<char> *a3)
{
  int v6 = std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_expression<char const*>(a1, a2, a3);
  if (v6 == (unsigned __int8 *)a2) {
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)15>();
  }
  do
  {
    unsigned int v7 = v6;
    int v6 = std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_expression<char const*>(a1, (std::basic_regex<char> *)v6, a3);
  }
  while (v6 != v7);
  return v7;
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_expression<char const*>(std::basic_regex<char> *a1, std::basic_regex<char> *a2, std::basic_regex<char> *a3)
{
  std::vector<std::string>::pointer end = a1->__end_;
  unsigned int marked_count = a1->__marked_count_;
  unsigned int v8 = std::basic_regex<char,std::regex_traits<char>>::__parse_one_char_or_coll_elem_ERE<char const*>(a1, a2, a3);
  uint64_t v9 = (unsigned __int8 *)v8;
  if (v8 != (char *)a2 || v8 == (char *)a3) {
    goto LABEL_12;
  }
  int locale_low = SLOBYTE(a2->__traits_.__loc_.__locale_);
  if (locale_low == 36)
  {
    std::basic_regex<char,std::regex_traits<char>>::__push_r_anchor(a1);
    goto LABEL_8;
  }
  if (locale_low == 40)
  {
    std::basic_regex<char,std::regex_traits<char>>::__push_begin_marked_subexpression(a1);
    unsigned int v11 = a1->__marked_count_;
    ++a1->__open_count_;
    unsigned __int8 v12 = (std::basic_regex<char> *)std::basic_regex<char,std::regex_traits<char>>::__parse_extended_reg_exp<char const*>(a1, (char *)&a2->__traits_.__loc_.__locale_ + 1, a3);
    if (v12 == a3 || (BOOL v13 = v12, LOBYTE(v12->__traits_.__loc_.__locale_) != 41)) {
      std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)6>();
    }
    std::basic_regex<char,std::regex_traits<char>>::__push_end_marked_subexpression(a1, v11);
    --a1->__open_count_;
    uint64_t v9 = (unsigned __int8 *)&v13->__traits_.__loc_.__locale_ + 1;
LABEL_12:
    if (v9 != (unsigned __int8 *)a2) {
      goto LABEL_13;
    }
    return (unsigned __int8 *)a2;
  }
  if (locale_low != 94) {
    return (unsigned __int8 *)a2;
  }
  std::basic_regex<char,std::regex_traits<char>>::__push_l_anchor(a1);
LABEL_8:
  uint64_t v9 = (unsigned __int8 *)&a2->__traits_.__loc_.__locale_ + 1;
LABEL_13:
  size_t v14 = a1->__marked_count_ + 1;

  return std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_dupl_symbol<char const*>((uint64_t)a1, v9, (unsigned __int8 *)a3, end, marked_count + 1, v14);
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse_one_char_or_coll_elem_ERE<char const*>(std::basic_regex<char> *a1, std::basic_regex<char> *a2, std::basic_regex<char> *a3)
{
  uint64_t result = (char *)std::basic_regex<char,std::regex_traits<char>>::__parse_ORD_CHAR_ERE<std::__wrap_iter<char const*>>(a1, a2, a3);
  if (result == (char *)a2)
  {
    uint64_t result = std::basic_regex<char,std::regex_traits<char>>::__parse_QUOTED_CHAR_ERE<char const*>((uint64_t)a1, (char *)a2, (char *)a3);
    if (result == (char *)a2)
    {
      if (a2 != a3 && LOBYTE(a2->__traits_.__loc_.__locale_) == 46) {
        operator new();
      }
      return std::basic_regex<char,std::regex_traits<char>>::__parse_bracket_expression<char const*>((uint64_t)a1, (char *)a2, (char *)a3);
    }
  }
  return result;
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse_QUOTED_CHAR_ERE<char const*>(uint64_t a1, char *a2, char *a3)
{
  int v3 = a2;
  if (a2 == a3) {
    return v3;
  }
  int v4 = a2 + 1;
  if (v3 + 1 == a3 || *v3 != 92) {
    return v3;
  }
  int v5 = *v4;
  std::basic_regex<char>::value_type v6 = *v4;
  BOOL v7 = (v5 - 36) > 0x3A || ((1 << (*v4 - 36)) & 0x5800000080004F1) == 0;
  if (!v7 || (v5 - 123) < 3)
  {
    std::basic_regex<char,std::regex_traits<char>>::__push_char((std::basic_regex<char> *)a1, v6);
    v3 += 2;
    return v3;
  }
  if ((*(_DWORD *)(a1 + 24) & 0x1F0) != 0x40)
  {
    BOOL v9 = std::basic_regex<char,std::regex_traits<char>>::__test_back_ref((std::basic_regex<char> *)a1, v6);
    uint64_t v10 = 2;
    if (!v9) {
      uint64_t v10 = 0;
    }
    v3 += v10;
    return v3;
  }

  return std::basic_regex<char,std::regex_traits<char>>::__parse_awk_escape<char const*>((std::basic_regex<char> *)a1, v4, a3, 0);
}

std::string *std::regex_replace[abi:ne180100]<std::back_insert_iterator<std::string>,std::__wrap_iter<char const*>,std::regex_traits<char>,char>(std::string *a1, std::__wrap_iter<const char *> a2, std::__wrap_iter<const char *> a3, const std::regex_iterator<std::__wrap_iter<const char *>, char>::regex_type *a4, char *a5, unsigned __int32 __m)
{
  __int16 v6 = __m;
  uint64_t i = (std::string::value_type *)a2.__i_;
  std::regex_iterator<std::__wrap_iter<char const*>,char,std::regex_traits<char>>::regex_iterator(&v18, a2, a3, a4, (std::regex_constants::match_flag_type)__m);
  memset(&v17.__match_.__prefix_, 0, 17);
  memset(&v17.__match_.__suffix_, 0, 17);
  v17.__match_.__ready_ = 0;
  v17.__match_.__position_start_.__i_ = 0;
  memset(&v17.__match_, 0, 41);
  memset(&v17, 0, 28);
  if (std::regex_iterator<std::__wrap_iter<char const*>,char,std::regex_traits<char>>::operator==(&v18, &v17))
  {
    if ((v6 & 0x200) == 0)
    {
      while (i != a3.__i_)
        std::string::push_back(a1, *i++);
    }
  }
  else
  {
    std::__wrap_iter<const char *>::iterator_type v11 = 0;
    unsigned __int8 v12 = 0;
    BOOL v13 = (unsigned __int8 *)&a5[strlen(a5)];
    while (!std::regex_iterator<std::__wrap_iter<char const*>,char,std::regex_traits<char>>::operator==(&v18, &v17))
    {
      if ((v6 & 0x200) == 0)
      {
        size_t v14 = (std::string::value_type *)v18.__match_.__prefix_.first.__i_;
        std::__wrap_iter<const char *>::iterator_type v15 = v18.__match_.__prefix_.second.__i_;
        while (v14 != v15)
          std::string::push_back(a1, *v14++);
      }
      a1 = std::match_results<std::__wrap_iter<char const*>>::format<std::back_insert_iterator<std::string>>((std::string::value_type ***)&v18.__match_, a1, (unsigned __int8 *)a5, v13, v6);
      unsigned __int8 v12 = (std::string::value_type *)v18.__match_.__suffix_.first.__i_;
      std::__wrap_iter<const char *>::iterator_type v11 = v18.__match_.__suffix_.second.__i_;
      if ((v6 & 0x400) != 0) {
        break;
      }
      std::regex_iterator<std::__wrap_iter<char const*>,char,std::regex_traits<char>>::operator++(&v18);
    }
    if ((v6 & 0x200) == 0)
    {
      while (v12 != v11)
        std::string::push_back(a1, *v12++);
    }
  }
  if (v17.__match_.__matches_.__begin_)
  {
    v17.__match_.__matches_.__end_ = v17.__match_.__matches_.__begin_;
    operator delete(v17.__match_.__matches_.__begin_);
  }
  if (v18.__match_.__matches_.__begin_)
  {
    v18.__match_.__matches_.__end_ = v18.__match_.__matches_.__begin_;
    operator delete(v18.__match_.__matches_.__begin_);
  }
  return a1;
}

void sub_20F4A2C7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32)
{
  if (__p) {
    operator delete(__p);
  }
  if (a31) {
    operator delete(a31);
  }
  _Unwind_Resume(exception_object);
}

BOOL std::regex_iterator<std::__wrap_iter<char const*>,char,std::regex_traits<char>>::operator==(const std::regex_iterator<std::__wrap_iter<const char *>, char> *this, const std::regex_iterator<std::__wrap_iter<const char *>, char> *__x)
{
  p_match = &this->__match_;
  std::vector<std::ssub_match>::pointer begin = this->__match_.__matches_.__begin_;
  std::vector<std::string>::pointer end = p_match->__matches_.__end_;
  BOOL v9 = &__x->__match_;
  std::vector<std::ssub_match>::pointer v7 = __x->__match_.__matches_.__begin_;
  unsigned int v8 = v9->__matches_.__end_;
  BOOL v10 = v8 == v7 && end == begin;
  if (end != begin && v8 != v7) {
    return this->__begin_.__i_ == __x->__begin_.__i_
  }
        && this->__end_.__i_ == __x->__end_.__i_
        && this->__pregex_ == __x->__pregex_
        && this->__flags_ == __x->__flags_
        && std::sub_match<std::__wrap_iter<char const*>>::compare[abi:ne180100]((uint64_t)begin, (uint64_t)v7) == 0;
  return v10;
}

std::string *std::match_results<std::__wrap_iter<char const*>>::format<std::back_insert_iterator<std::string>>(std::string::value_type ***a1, std::string *this, unsigned __int8 *a3, unsigned __int8 *a4, __int16 a5)
{
  __int16 v6 = a3;
  if ((a5 & 0x100) != 0)
  {
    if (a3 == a4) {
      return this;
    }
    while (1)
    {
      int v30 = *v6;
      if (v30 == 92)
      {
        uint64_t v34 = v6 + 1;
        if (v6 + 1 != a4)
        {
          int v30 = *v34;
          if ((v30 - 48) <= 9u)
          {
            unint64_t v35 = (v30 - 48);
            if (0xAAAAAAAAAAAAAAABLL * (a1[1] - *a1) <= v35) {
              uint64_t v36 = (uint64_t)(a1 + 3);
            }
            else {
              uint64_t v36 = (uint64_t)&(*a1)[3 * v35];
            }
            std::string v37 = *(std::string::value_type **)v36;
            std::string v38 = *(std::string::value_type **)(v36 + 8);
            while (v37 != v38)
            {
              std::string::value_type v39 = *v37++;
              std::string::push_back(this, v39);
            }
            goto LABEL_55;
          }
          ++v6;
        }
      }
      else if (v30 == 38)
      {
        std::string v31 = **a1;
        std::string v32 = (*a1)[1];
        while (v31 != v32)
        {
          std::string::value_type v33 = *v31++;
          std::string::push_back(this, v33);
        }
        goto LABEL_54;
      }
      std::string::push_back(this, v30);
LABEL_54:
      uint64_t v34 = v6;
LABEL_55:
      __int16 v6 = v34 + 1;
      if (v34 + 1 == a4) {
        return this;
      }
    }
  }
  if (a3 != a4)
  {
    do
    {
      int v9 = *v6;
      BOOL v10 = v6 + 1;
      if (v9 == 36 && v10 != a4)
      {
        int v12 = (char)*v10;
        int v9 = *v10;
        if (v12 > 38)
        {
          if (v12 == 39)
          {
            size_t v19 = (std::string::value_type *)a1[9];
            size_t v20 = (std::string::value_type *)a1[10];
            while (v19 != v20)
            {
              std::string::value_type v21 = *v19++;
              std::string::push_back(this, v21);
            }
            goto LABEL_10;
          }
          if (v12 == 96)
          {
            int v16 = (std::string::value_type *)a1[6];
            std::regex_iterator<std::__wrap_iter<const char *>, char> v17 = (std::string::value_type *)a1[7];
            while (v16 != v17)
            {
              std::string::value_type v18 = *v16++;
              std::string::push_back(this, v18);
            }
            goto LABEL_10;
          }
        }
        else
        {
          if (v12 == 36) {
            goto LABEL_9;
          }
          if (v12 == 38)
          {
            BOOL v13 = **a1;
            size_t v14 = (*a1)[1];
            while (v13 != v14)
            {
              std::string::value_type v15 = *v13++;
              std::string::push_back(this, v15);
            }
            goto LABEL_10;
          }
        }
        if ((v9 - 48) <= 9)
        {
          unint64_t v22 = *v10 - 48;
          if (v6 + 2 != a4)
          {
            uint64_t v23 = v6[2];
            unsigned int v24 = v23 - 48;
            uint64_t v25 = v23 + 10 * (int)v22 - 48;
            if (v24 > 9)
            {
              BOOL v10 = v6 + 1;
            }
            else
            {
              unint64_t v22 = v25;
              BOOL v10 = v6 + 2;
            }
          }
          if (0xAAAAAAAAAAAAAAABLL * (a1[1] - *a1) <= v22) {
            uint64_t v26 = (uint64_t)(a1 + 3);
          }
          else {
            uint64_t v26 = (uint64_t)&(*a1)[3 * (int)v22];
          }
          int v27 = *(std::string::value_type **)v26;
          uint64_t v28 = *(std::string::value_type **)(v26 + 8);
          while (v27 != v28)
          {
            std::string::value_type v29 = *v27++;
            std::string::push_back(this, v29);
          }
          goto LABEL_10;
        }
        LOBYTE(v9) = 36;
      }
      BOOL v10 = v6;
LABEL_9:
      std::string::push_back(this, v9);
LABEL_10:
      __int16 v6 = v10 + 1;
    }
    while (v10 + 1 != a4);
  }
  return this;
}

std::regex_iterator<std::__wrap_iter<const char *>, char> *__cdecl std::regex_iterator<std::__wrap_iter<char const*>,char,std::regex_traits<char>>::operator++(std::regex_iterator<std::__wrap_iter<const char *>, char> *this)
{
  p_match = &this->__match_;
  std::vector<std::ssub_match>::pointer begin = this->__match_.__matches_.__begin_;
  int i = (int)p_match[-1].__position_start_.__i_;
  unsigned __int32 flags = i | 0x800;
  LODWORD(p_match[-1].__position_start_.__i_) = i | 0x800;
  if (p_match->__matches_.__end_ == begin) {
    p_unuint64_t matched = &p_match->__unmatched_;
  }
  else {
    p_unuint64_t matched = begin;
  }
  std::vector<std::ssub_match>::pointer v7 = (char *)p_unmatched->second.__i_;
  if (p_unmatched->first.__i_ != v7)
  {
LABEL_5:
    this->__flags_ = flags | 0x80;
    int v9 = (char *)this->__end_.__i_;
    pregex = this->__pregex_;
    memset(&__p.__prefix_, 0, 17);
    memset(&__p.__suffix_, 0, 17);
    __p.__ready_ = 0;
    __p.__position_start_ = 0;
    memset(&__p, 0, 41);
    char v10 = std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>((uint64_t)pregex, v7, v9, &__p, flags | 0x80);
    std::match_results<std::__wrap_iter<char const*>>::__assign[abi:ne180100]<char const*,std::allocator<std::sub_match<char const*>>>(&p_match->__matches_, (uint64_t)v7, (std::sub_match<std::__wrap_iter<const char *>> *)v9, (uint64_t *)&__p, (flags & 0x800) != 0);
    if (__p.__matches_.__begin_)
    {
      __p.__matches_.__end_ = __p.__matches_.__begin_;
      operator delete(__p.__matches_.__begin_);
    }
    if ((v10 & 1) == 0)
    {
      std::vector<std::ssub_match>::pointer begin = p_match->__matches_.__begin_;
LABEL_14:
      if (begin)
      {
        this->__match_.__matches_.__end_ = begin;
        operator delete(begin);
        p_match->__matches_.__begin_ = 0;
        p_match->__matches_.__end_ = 0;
        p_match->__matches_.__end_cap_.__value_ = 0;
      }
      this->__match_.__ready_ = 0;
      *(_OWORD *)&p_match->__matches_.__begin_ = 0u;
      *(_OWORD *)&p_match->__matches_.__end_cap_.__value_ = 0u;
      *(std::pair<std::__wrap_iter<const char *>, std::__wrap_iter<const char *>> *)((char *)&p_match->__unmatched_.std::pair<std::__wrap_iter<const char *>, std::__wrap_iter<const char *>>
                                                                                   + 1) = 0u;
      this->__match_.__prefix_.first.__i_ = 0;
      this->__match_.__prefix_.second.__i_ = 0;
      this->__match_.__prefix_.uint64_t matched = 0;
      this->__match_.__suffix_.first.__i_ = 0;
      this->__match_.__suffix_.second.__i_ = 0;
      this->__match_.__suffix_.uint64_t matched = 0;
      this->__match_.__position_start_.__i_ = 0;
      return this;
    }
    return this;
  }
  std::__wrap_iter<const char *>::iterator_type v11 = (char *)this->__end_.__i_;
  if (v11 == v7) {
    goto LABEL_14;
  }
  int v12 = this->__pregex_;
  memset(&__p.__prefix_, 0, 17);
  memset(&__p.__suffix_, 0, 17);
  __p.__ready_ = 0;
  __p.__position_start_ = 0;
  memset(&__p, 0, 41);
  char v13 = std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>((uint64_t)v12, v7, v11, &__p, i | 0x860u);
  std::match_results<std::__wrap_iter<char const*>>::__assign[abi:ne180100]<char const*,std::allocator<std::sub_match<char const*>>>(&p_match->__matches_, (uint64_t)v7, (std::sub_match<std::__wrap_iter<const char *>> *)v11, (uint64_t *)&__p, 1);
  if (__p.__matches_.__begin_)
  {
    __p.__matches_.__end_ = __p.__matches_.__begin_;
    operator delete(__p.__matches_.__begin_);
  }
  if ((v13 & 1) == 0)
  {
    ++v7;
    unsigned __int32 flags = this->__flags_;
    goto LABEL_5;
  }
  return this;
}

void sub_20F4A3164(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

std::regex_iterator<std::__wrap_iter<const char *>, char> *__cdecl std::regex_iterator<std::__wrap_iter<char const*>,char,std::regex_traits<char>>::regex_iterator(std::regex_iterator<std::__wrap_iter<const char *>, char> *this, std::__wrap_iter<const char *> __a, std::__wrap_iter<const char *> __b, const std::regex_iterator<std::__wrap_iter<const char *>, char>::regex_type *__re, std::regex_constants::match_flag_type __m)
{
  __int16 v5 = __m;
  this->__begin_ = __a;
  this->__end_ = __b;
  this->__pregex_ = __re;
  this->__flags_ = __m;
  *(_OWORD *)&this->__match_.__matches_.__begin_ = 0u;
  p_match = &this->__match_;
  this->__match_.__prefix_.first.__i_ = 0;
  this->__match_.__prefix_.second.__i_ = 0;
  this->__match_.__prefix_.uint64_t matched = 0;
  this->__match_.__suffix_.first.__i_ = 0;
  this->__match_.__suffix_.second.__i_ = 0;
  this->__match_.__suffix_.uint64_t matched = 0;
  this->__match_.__ready_ = 0;
  this->__match_.__position_start_.__i_ = 0;
  *(_OWORD *)&this->__match_.__matches_.__end_cap_.__value_ = 0u;
  *(std::pair<std::__wrap_iter<const char *>, std::__wrap_iter<const char *>> *)((char *)&this->__match_.__unmatched_.std::pair<std::__wrap_iter<const char *>, std::__wrap_iter<const char *>>
                                                                               + 1) = 0u;
  memset(&__p.__prefix_, 0, 17);
  memset(&__p.__suffix_, 0, 17);
  __p.__ready_ = 0;
  __p.__position_start_ = 0;
  memset(&__p, 0, 41);
  std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>((uint64_t)__re, (char *)__a.__i_, (char *)__b.__i_, &__p, __m);
  std::match_results<std::__wrap_iter<char const*>>::__assign[abi:ne180100]<char const*,std::allocator<std::sub_match<char const*>>>(&p_match->__matches_, (uint64_t)__a.__i_, (std::sub_match<std::__wrap_iter<const char *>> *)__b.__i_, (uint64_t *)&__p, (v5 & 0x800) != 0);
  if (__p.__matches_.__begin_)
  {
    __p.__matches_.__end_ = __p.__matches_.__begin_;
    operator delete(__p.__matches_.__begin_);
  }
  return this;
}

void sub_20F4A325C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  char v13 = *v11;
  if (*v11)
  {
    *(void *)(v10 + 40) = v13;
    operator delete(v13);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::sub_match<std::__wrap_iter<char const*>>::compare[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 16))
  {
    std::string::__init_with_size[abi:ne180100]<char *,char *>(&__p, *(char **)a1, *(char **)(a1 + 8), *(void *)(a1 + 8) - *(void *)a1);
  }
  else
  {
    std::match_results<const char *> __p = 0;
    size_t v19 = 0;
    uint64_t v20 = 0;
  }
  if (*(unsigned char *)(a2 + 16))
  {
    std::string::__init_with_size[abi:ne180100]<char *,char *>(&v15, *(char **)a2, *(char **)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
    unsigned int v3 = HIBYTE(v17);
    __int16 v5 = v15;
    size_t v4 = v16;
  }
  else
  {
    size_t v4 = 0;
    __int16 v5 = 0;
    unsigned int v3 = 0;
    std::string::value_type v15 = 0;
    size_t v16 = 0;
    uint64_t v17 = 0;
  }
  char v6 = HIBYTE(v20);
  if (v20 >= 0) {
    size_t v7 = HIBYTE(v20);
  }
  else {
    size_t v7 = v19;
  }
  if (v20 >= 0) {
    p_p = &__p;
  }
  else {
    p_p = __p;
  }
  if ((v3 & 0x80u) == 0) {
    size_t v9 = v3;
  }
  else {
    size_t v9 = v4;
  }
  if ((v3 & 0x80u) == 0) {
    uint64_t v10 = (void **)&v15;
  }
  else {
    uint64_t v10 = v5;
  }
  if (v9 >= v7) {
    size_t v11 = v7;
  }
  else {
    size_t v11 = v9;
  }
  unsigned int v12 = memcmp(p_p, v10, v11);
  if ((v3 & 0x80) != 0)
  {
    operator delete(v5);
    if ((v20 & 0x8000000000000000) == 0) {
      goto LABEL_24;
    }
  }
  else if ((v6 & 0x80) == 0)
  {
    goto LABEL_24;
  }
  operator delete(__p);
LABEL_24:
  unsigned int v13 = v9 < v7;
  if (v7 < v9) {
    unsigned int v13 = -1;
  }
  if (v12) {
    return v12;
  }
  else {
    return v13;
  }
}

void sub_20F4A339C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *MIL::Validation::Constraints::Constraints(void *this)
{
  *this = &unk_26C25D4D8;
  return this;
}

void *MIL::Validation::PossibleStringValuesConstraints::PossibleStringValuesConstraints(void *this)
{
  *this = &unk_26C25D500;
  return this;
}

void MIL::Validation::PossibleStringValuesConstraints::Make(MIL::Validation::PossibleStringValuesConstraints *this)
{
}

void *MIL::Validation::TensorDTypeConstraints::TensorDTypeConstraints(void *this)
{
  *this = &unk_26C25D530;
  return this;
}

void MIL::Validation::TensorDTypeConstraints::Make(MIL::Validation::TensorDTypeConstraints *this)
{
}

void *MIL::Validation::TensorRankValueConstraints::TensorRankValueConstraints(void *this)
{
  *this = &unk_26C25D568;
  return this;
}

void MIL::Validation::TensorRankValueConstraints::Make(MIL::Validation::TensorRankValueConstraints *this)
{
}

void *MIL::Validation::TensorSymbolicShapeConstraints::TensorSymbolicShapeConstraints(void *this)
{
  *this = &unk_26C25D5A0;
  return this;
}

void MIL::Validation::TensorSymbolicShapeConstraints::Make(MIL::Validation::TensorSymbolicShapeConstraints *this)
{
}

void anonymous namespace'::PossibleStringValuesConstraintsImpl::~PossibleStringValuesConstraintsImpl(_anonymous_namespace_::PossibleStringValuesConstraintsImpl *this)
{
  *(void *)this = &unk_26C25D650;
  uint64_t v1 = (void **)((char *)this + 8);
  std::vector<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::unordered_set<std::string>,BOOL>>::__destroy_vector::operator()[abi:ne180100](&v1);
}

{
  void **v2;

  *(void *)this = &unk_26C25D650;
  uint64_t v2 = (void **)((char *)this + 8);
  std::vector<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::unordered_set<std::string>,BOOL>>::__destroy_vector::operator()[abi:ne180100](&v2);
  MEMORY[0x21056C700](this, 0xA1C4030951706);
}

void anonymous namespace'::PossibleStringValuesConstraintsImpl::Check(_anonymous_namespace_::PossibleStringValuesConstraintsImpl *this@<X0>, MIL::IRTensorValueType **a2@<X1>, MIL::ValidationResult *a3@<X8>)
{
  size_t v4 = (const MIL::IROperation **)*((void *)this + 1);
  __int16 v5 = (const MIL::IROperation **)*((void *)this + 2);
  if (v4 == v5)
  {
LABEL_66:
    MIL::ValidationResult::ValidationResult(a3);
    return;
  }
  std::string::size_type v51 = *MEMORY[0x263F8C2C8];
  std::string::size_type v50 = *(void *)(MEMORY[0x263F8C2C8] + 24);
  while (1)
  {
    size_t v7 = *v4;
    uint64_t v64 = 0;
    if (!MIL::ValidationResult::IsGood(a3)) {
      return;
    }
    MIL::ValidationResult::~ValidationResult(a3);
    if (!v64) {
      goto LABEL_56;
    }
    if ((*(unsigned int (**)(uint64_t))(*(void *)v64 + 88))(v64) != 3)
    {
      LocationPtr = (uint64_t *)MIL::IRObject::GetLocationPtr((MIL::IRObject *)a2);
      std::string v38 = (std::__shared_weak_count *)LocationPtr[1];
      uint64_t v62 = *LocationPtr;
      uint64_t v63 = v38;
      if (v38) {
        atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      (*(void (**)(std::string *__return_ptr))(*(void *)*v4 + 48))(&v69);
      std::string::value_type v39 = std::string::append(&v69, " is not a string tensor.");
      long long v40 = *(_OWORD *)&v39->__r_.__value_.__l.__data_;
      std::string::size_type v61 = v39->__r_.__value_.__r.__words[2];
      *(_OWORD *)unint64_t v60 = v40;
      v39->__r_.__value_.__l.__size_ = 0;
      v39->__r_.__value_.__r.__words[2] = 0;
      v39->__r_.__value_.__r.__words[0] = 0;
      MIL::ValidationResult::ValidationResult(a3, &v62, 319, v60);
      if (SHIBYTE(v61) < 0) {
        operator delete(v60[0]);
      }
      if (SHIBYTE(v69.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v69.__r_.__value_.__l.__data_);
      }
      unint64_t v41 = v63;
      if (v63) {
        goto LABEL_74;
      }
      return;
    }
    if (!(*(uint64_t (**)(const MIL::IROperation *, MIL::IRTensorValueType **))(*(void *)*v4 + 32))(*v4, a2))break; {
    uint64_t v8 = MIL::IRValue::TryGetScalar<std::string>();
    }
    if (!v8)
    {
      int v46 = (uint64_t *)MIL::IRObject::GetLocationPtr((MIL::IRObject *)a2);
      unint64_t v47 = (std::__shared_weak_count *)v46[1];
      uint64_t v54 = *v46;
      unint64_t v55 = v47;
      if (v47) {
        atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      (*(void (**)(std::string *__return_ptr))(*(void *)*v4 + 48))(&v73);
      long long v48 = std::string::insert(&v73, 0, "String value missing for ");
      long long v49 = *(_OWORD *)&v48->__r_.__value_.__l.__data_;
      v69.__r_.__value_.__r.__words[2] = v48->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v69.__r_.__value_.__l.__data_ = v49;
      v48->__r_.__value_.__l.__size_ = 0;
      v48->__r_.__value_.__r.__words[2] = 0;
      v48->__r_.__value_.__r.__words[0] = 0;
      std::string::push_back(&v69, 46);
      std::string v53 = v69;
      memset(&v69, 0, sizeof(v69));
      MIL::ValidationResult::ValidationResult(a3, &v54, 319, &v53);
      if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v53.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v69.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v69.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v73.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v73.__r_.__value_.__l.__data_);
      }
      unint64_t v41 = v55;
      if (!v55) {
        return;
      }
LABEL_74:
      std::__shared_weak_count::__release_shared[abi:ne180100](v41);
      return;
    }
    if (*(char *)(v8 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(&v52, *(const std::string::value_type **)v8, *(void *)(v8 + 8));
    }
    else
    {
      long long v9 = *(_OWORD *)v8;
      v52.__r_.__value_.__r.__words[2] = *(void *)(v8 + 16);
      *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v9;
    }
    if (!*((unsigned char *)v4 + 56))
    {
      if ((v52.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        unint64_t v35 = (std::string *)((char *)&v52 + HIBYTE(v52.__r_.__value_.__r.__words[2]));
      }
      else {
        unint64_t v35 = (std::string *)(v52.__r_.__value_.__r.__words[0] + v52.__r_.__value_.__l.__size_);
      }
      if ((v52.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v36 = &v52;
      }
      else {
        uint64_t v36 = (std::string *)v52.__r_.__value_.__r.__words[0];
      }
      while (v36 != v35)
      {
        v36->__r_.__value_.__s.__data_[0] = __tolower(v36->__r_.__value_.__s.__data_[0]);
        uint64_t v36 = (std::string *)((char *)v36 + 1);
      }
    }
    uint64_t v10 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v4 + 2, (unsigned __int8 *)&v52);
    if (!v10)
    {
      size_t v11 = *v4;
      unsigned int v12 = (uint64_t *)v4[4];
      memset(&v73, 0, sizeof(v73));
      unint64_t v13 = 0;
      if (v12)
      {
        size_t v14 = v12;
        do
        {
          ++v13;
          size_t v14 = (uint64_t *)*v14;
        }
        while (v14);
      }
      std::vector<std::string>::__init_with_size[abi:ne180100]<std::__hash_const_iterator<std::__hash_node<std::string,void *> *>,std::__hash_const_iterator<std::__hash_node<std::string,void *> *>>(&v73, v12, 0, v13);
      unint64_t v15 = 126
          - 2
          * __clz(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v73.__r_.__value_.__l.__size_ - v73.__r_.__value_.__r.__words[0]) >> 3));
      if (v73.__r_.__value_.__l.__size_ == v73.__r_.__value_.__r.__words[0]) {
        uint64_t v16 = 0;
      }
      else {
        uint64_t v16 = v15;
      }
      std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *,false>((uint64_t)v73.__r_.__value_.__l.__data_, (long long *)v73.__r_.__value_.__l.__size_, (uint64_t)__p, v16, 1);
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v69);
      uint64_t v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v69, (uint64_t)"Unexpected value for ", 21);
      (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)v11 + 48))(__p, v11);
      if ((v68 & 0x80u) == 0) {
        std::string::value_type v18 = __p;
      }
      else {
        std::string::value_type v18 = (void **)__p[0];
      }
      if ((v68 & 0x80u) == 0) {
        uint64_t v19 = v68;
      }
      else {
        uint64_t v19 = (uint64_t)__p[1];
      }
      uint64_t v20 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)v18, v19);
      std::string::value_type v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, (uint64_t)" \"", 2);
      if ((v52.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        unint64_t v22 = &v52;
      }
      else {
        unint64_t v22 = (std::string *)v52.__r_.__value_.__r.__words[0];
      }
      if ((v52.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(v52.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = v52.__r_.__value_.__l.__size_;
      }
      unsigned int v24 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)v22, size);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)"\" not in (", 10);
      if ((char)v68 < 0) {
        operator delete(__p[0]);
      }
      std::string::size_type v26 = v73.__r_.__value_.__l.__size_;
      std::string::size_type v25 = v73.__r_.__value_.__r.__words[0];
      if (v73.__r_.__value_.__r.__words[0] != v73.__r_.__value_.__l.__size_)
      {
        char v27 = 1;
        do
        {
          if ((v27 & 1) == 0) {
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v69, (uint64_t)", ", 2);
          }
          uint64_t v28 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v69, (uint64_t)"\"", 1);
          int v29 = *(char *)(v25 + 23);
          if (v29 >= 0) {
            uint64_t v30 = v25;
          }
          else {
            uint64_t v30 = *(void *)v25;
          }
          if (v29 >= 0) {
            uint64_t v31 = *(unsigned __int8 *)(v25 + 23);
          }
          else {
            uint64_t v31 = *(void *)(v25 + 8);
          }
          std::string v32 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v28, v30, v31);
          LOBYTE(__p[0]) = 34;
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v32, (uint64_t)__p, 1);
          char v27 = 0;
          v25 += 24;
        }
        while (v25 != v26);
      }
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v69, (uint64_t)").", 2);
      std::string::value_type v33 = (uint64_t *)MIL::IRObject::GetLocationPtr((MIL::IRObject *)a2);
      uint64_t v34 = (std::__shared_weak_count *)v33[1];
      uint64_t v65 = *v33;
      long long v66 = v34;
      if (v34) {
        atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      std::stringbuf::str();
      MIL::ValidationResult::ValidationResult(a3, &v65, 319, __p);
      if ((char)v68 < 0) {
        operator delete(__p[0]);
      }
      if (v66) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v66);
      }
      v69.__r_.__value_.__r.__words[0] = v51;
      *(std::string::size_type *)((char *)v69.__r_.__value_.__r.__words + *(void *)(v51 - 24)) = v50;
      v69.__r_.__value_.__l.__size_ = MEMORY[0x263F8C318] + 16;
      if (v71 < 0) {
        operator delete(v70);
      }
      std::streambuf::~streambuf();
      std::ostream::~ostream();
      MEMORY[0x21056C620](&v72);
      v69.__r_.__value_.__r.__words[0] = (std::string::size_type)&v73;
      std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v69);
    }
    if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v52.__r_.__value_.__l.__data_);
    }
    if (!v10) {
      return;
    }
LABEL_56:
    v4 += 8;
    if (v4 == v5) {
      goto LABEL_66;
    }
  }
  uint64_t v42 = (uint64_t *)MIL::IRObject::GetLocationPtr((MIL::IRObject *)a2);
  long long v43 = (std::__shared_weak_count *)v42[1];
  uint64_t v58 = *v42;
  unint64_t v59 = v43;
  if (v43) {
    atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(std::string *__return_ptr))(*(void *)*v4 + 48))(&v69);
  long long v44 = std::string::append(&v69, " has no value.");
  long long v45 = *(_OWORD *)&v44->__r_.__value_.__l.__data_;
  std::string::size_type v57 = v44->__r_.__value_.__r.__words[2];
  *(_OWORD *)uint64_t v56 = v45;
  v44->__r_.__value_.__l.__size_ = 0;
  v44->__r_.__value_.__r.__words[2] = 0;
  v44->__r_.__value_.__r.__words[0] = 0;
  MIL::ValidationResult::ValidationResult(a3, &v58, 319, v56);
  if (SHIBYTE(v57) < 0) {
    operator delete(v56[0]);
  }
  if (SHIBYTE(v69.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v69.__r_.__value_.__l.__data_);
  }
  unint64_t v41 = v59;
  if (v59) {
    goto LABEL_74;
  }
}

void sub_20F4A3E08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,std::__shared_weak_count *a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,void *a50,uint64_t a51,int a52,__int16 a53,char a54,char a55,void *a56,uint64_t a57,int a58,__int16 a59,char a60,char a61)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  if (a61 < 0) {
    operator delete(a56);
  }
  if (*(char *)(v61 - 89) < 0) {
    operator delete(*(void **)(v61 - 112));
  }
  if (a28) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a28);
  }
  _Unwind_Resume(exception_object);
}

uint64_t anonymous namespace'::PossibleStringValuesConstraintsImpl::Add(uint64_t *a1, uint64_t a2, uint64_t *a3, char a4)
{
  char v18 = a4;
  if (a4)
  {
    unint64_t v7 = a1[2];
    if (v7 >= a1[3])
    {
      uint64_t result = std::vector<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::unordered_set<std::string>,BOOL>>::__emplace_back_slow_path<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::unordered_set<std::string>,BOOL &>(a1 + 1, a2, a3, &v18);
    }
    else
    {
      *(_OWORD *)unint64_t v7 = *(_OWORD *)a2;
      *(void *)a2 = 0;
      *(void *)(a2 + 8) = 0;
      std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(v7 + 16, a3);
      *(unsigned char *)(v7 + 56) = a4;
      uint64_t result = v7 + 64;
    }
    a1[2] = result;
  }
  else
  {
    memset(v16, 0, sizeof(v16));
    int v17 = 1065353216;
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>((uint64_t)v16, (unint64_t)(float)(unint64_t)a3[3]);
    for (uint64_t i = a3[2]; i; uint64_t i = *(void *)i)
    {
      if (*(char *)(i + 39) < 0) {
        std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)(i + 16), *(void *)(i + 24));
      }
      else {
        std::string __p = *(std::string *)(i + 16);
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        size_t v11 = (std::string *)((char *)&__p + HIBYTE(__p.__r_.__value_.__r.__words[2]));
      }
      else {
        size_t v11 = (std::string *)(__p.__r_.__value_.__r.__words[0] + __p.__r_.__value_.__l.__size_);
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      while (p_p != v11)
      {
        p_p->__r_.__value_.__s.__data_[0] = __tolower(p_p->__r_.__value_.__s.__data_[0]);
        p_p = (std::string *)((char *)p_p + 1);
      }
      std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string>((uint64_t)v16, (unsigned __int8 *)&__p, (uint64_t)&__p);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    unint64_t v13 = a1[2];
    if (v13 >= a1[3])
    {
      uint64_t v14 = std::vector<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::unordered_set<std::string>,BOOL>>::__emplace_back_slow_path<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::unordered_set<std::string>,BOOL &>(a1 + 1, a2, (uint64_t *)v16, &v18);
    }
    else
    {
      *(_OWORD *)unint64_t v13 = *(_OWORD *)a2;
      *(void *)a2 = 0;
      *(void *)(a2 + 8) = 0;
      std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(v13 + 16, (uint64_t *)v16);
      *(unsigned char *)(v13 + 56) = v18;
      uint64_t v14 = v13 + 64;
    }
    a1[2] = v14;
    return std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v16);
  }
  return result;
}

void sub_20F4A4138(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
}

void std::vector<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::unordered_set<std::string>,BOOL>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v2 = (uint64_t *)*a1;
  if (*v2)
  {
    std::vector<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::unordered_set<std::string>,BOOL>>::__base_destruct_at_end[abi:ne180100]((uint64_t)v2, *v2);
    unsigned int v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::unordered_set<std::string>,BOOL>>::__base_destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(void *)(a1 + 8); i != a2; i -= 64)
  {
    std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(i - 48);
    __int16 v5 = *(std::__shared_weak_count **)(i - 56);
    if (v5) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v5);
    }
  }
  *(void *)(a1 + 8) = a2;
}

void anonymous namespace'::GetTargetTensorType(_anonymous_namespace_ *this@<X0>, const MIL::IRTensorValueType **a2@<X1>, const MIL::IROperation *a3@<X2>, MIL::ValidationResult *a4@<X8>)
{
  uint64_t v9 = (*(uint64_t (**)(const MIL::IROperation *))(*(void *)a3 + 24))(a3);
  if (v9)
  {
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 24))(v9);
    if (v10)
    {
      *(void *)this = v10;
LABEL_5:
      MIL::ValidationResult::ValidationResult(a4);
      return;
    }
    LocationPtr = (uint64_t *)MIL::IRObject::GetLocationPtr((MIL::IRObject *)a2);
    unsigned int v12 = (std::__shared_weak_count *)LocationPtr[1];
    uint64_t v22 = *LocationPtr;
    uint64_t v23 = v12;
    if (v12) {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(std::string *__return_ptr, const MIL::IROperation *))(*(void *)a3 + 48))(&v25, a3);
    unint64_t v13 = std::string::append(&v25, " is not a tensor.");
    long long v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    std::string::size_type v21 = v13->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = v14;
    v13->__r_.__value_.__l.__size_ = 0;
    v13->__r_.__value_.__r.__words[2] = 0;
    v13->__r_.__value_.__r.__words[0] = 0;
    MIL::ValidationResult::ValidationResult(a4, &v22, 319, __p);
    if (SHIBYTE(v21) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v25.__r_.__value_.__l.__data_);
    }
    unint64_t v15 = v23;
    if (v23) {
LABEL_15:
    }
      std::__shared_weak_count::__release_shared[abi:ne180100](v15);
  }
  else
  {
    if ((*(unsigned int (**)(const MIL::IROperation *))(*(void *)a3 + 16))(a3)) {
      goto LABEL_5;
    }
    uint64_t v16 = (uint64_t *)MIL::IRObject::GetLocationPtr((MIL::IRObject *)a2);
    int v17 = (std::__shared_weak_count *)v16[1];
    uint64_t v27 = *v16;
    uint64_t v28 = v17;
    if (v17) {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(std::string *__return_ptr, const MIL::IROperation *))(*(void *)a3 + 48))(&v24, a3);
    char v18 = std::string::insert(&v24, 0, "Could not find type of ");
    long long v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
    v25.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v25.__r_.__value_.__l.__data_ = v19;
    v18->__r_.__value_.__l.__size_ = 0;
    v18->__r_.__value_.__r.__words[2] = 0;
    v18->__r_.__value_.__r.__words[0] = 0;
    std::string::push_back(&v25, 46);
    std::string v26 = v25;
    memset(&v25, 0, sizeof(v25));
    MIL::ValidationResult::ValidationResult(a4, &v27, 319, &v26);
    if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v26.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v25.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v24.__r_.__value_.__l.__data_);
    }
    unint64_t v15 = v28;
    if (v28) {
      goto LABEL_15;
    }
  }
}

void sub_20F4A44A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (*(char *)(v25 - 57) < 0) {
    operator delete(*(void **)(v25 - 80));
  }
  if (a25 < 0) {
    operator delete(__p);
  }
  if (a19 < 0) {
    operator delete(a14);
  }
  uint64_t v27 = *(std::__shared_weak_count **)(v25 - 40);
  if (v27) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v27);
  }
  _Unwind_Resume(exception_object);
}

void sub_20F4A4508(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  if (!a16) {
    JUMPOUT(0x20F4A4500);
  }
  JUMPOUT(0x20F4A44FCLL);
}

std::string *std::vector<std::string>::__init_with_size[abi:ne180100]<std::__hash_const_iterator<std::__hash_node<std::string,void *> *>,std::__hash_const_iterator<std::__hash_node<std::string,void *> *>>(std::string *result, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  if (a4)
  {
    char v6 = result;
    std::vector<std::string>::__vallocate[abi:ne180100](result, a4);
    uint64_t result = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::string>,std::__hash_const_iterator<std::__hash_node<std::string,void *> *>,std::__hash_const_iterator<std::__hash_node<std::string,void *> *>,std::string*>((uint64_t)&v6->__r_.__value_.__r.__words[2], a2, a3, (std::string *)v6->__r_.__value_.__l.__size_);
    v6->__r_.__value_.__l.__size_ = (std::string::size_type)result;
  }
  return result;
}

void sub_20F4A45B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

std::string *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::string>,std::__hash_const_iterator<std::__hash_node<std::string,void *> *>,std::__hash_const_iterator<std::__hash_node<std::string,void *> *>,std::string*>(uint64_t a1, uint64_t *a2, uint64_t *a3, std::string *this)
{
  size_t v4 = this;
  size_t v11 = this;
  unsigned int v12 = this;
  v9[0] = a1;
  v9[1] = &v11;
  v9[2] = &v12;
  char v10 = 0;
  if (a2 != a3)
  {
    char v6 = a2;
    do
    {
      if (*((char *)v6 + 39) < 0)
      {
        std::string::__init_copy_ctor_external(v4, (const std::string::value_type *)v6[2], v6[3]);
        size_t v4 = v12;
      }
      else
      {
        long long v7 = *((_OWORD *)v6 + 1);
        v4->__r_.__value_.__r.__words[2] = v6[4];
        *(_OWORD *)&v4->__r_.__value_.__l.__data_ = v7;
      }
      char v6 = (uint64_t *)*v6;
      unsigned int v12 = ++v4;
    }
    while (v6 != a3);
  }
  char v10 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::string*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v9);
  return v4;
}

void sub_20F4A4680(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string>(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  long long v7 = (void *)(a1 + 24);
  unint64_t v8 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  unint64_t v9 = v8;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v3 = v8;
      if (v8 >= v10) {
        unint64_t v3 = v8 % v10;
      }
    }
    else
    {
      unint64_t v3 = (v10 - 1) & v8;
    }
    unint64_t v13 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v13)
    {
      for (uint64_t i = *v13; i; uint64_t i = *(void **)i)
      {
        unint64_t v15 = *((void *)i + 1);
        if (v15 == v9)
        {
          if (std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, (unsigned __int8 *)i + 16, a2)) {
            return i;
          }
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10) {
              v15 %= v10;
            }
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v3) {
            break;
          }
        }
      }
    }
  }
  uint64_t v16 = (void *)(a1 + 16);
  uint64_t i = operator new(0x28uLL);
  *(void *)uint64_t i = 0;
  *((void *)i + 1) = v9;
  *((_OWORD *)i + 1) = *(_OWORD *)a3;
  *((void *)i + 4) = *(void *)(a3 + 16);
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v18 = *(float *)(a1 + 32);
  if (!v10 || (float)(v18 * (float)v10) < v17)
  {
    BOOL v19 = 1;
    if (v10 >= 3) {
      BOOL v19 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v10);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v22);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v3 = v9 % v10;
      }
      else {
        unint64_t v3 = v9;
      }
    }
    else
    {
      unint64_t v3 = (v10 - 1) & v9;
    }
  }
  uint64_t v23 = *(void *)a1;
  std::string v24 = *(void **)(*(void *)a1 + 8 * v3);
  if (v24)
  {
    *(void *)uint64_t i = *v24;
LABEL_38:
    void *v24 = i;
    goto LABEL_39;
  }
  *(void *)uint64_t i = *v16;
  void *v16 = i;
  *(void *)(v23 + 8 * v3) = v16;
  if (*(void *)i)
  {
    unint64_t v25 = *(void *)(*(void *)i + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v25 >= v10) {
        v25 %= v10;
      }
    }
    else
    {
      v25 &= v10 - 1;
    }
    std::string v24 = (void *)(*(void *)a1 + 8 * v25);
    goto LABEL_38;
  }
LABEL_39:
  ++*v7;
  return i;
}

void sub_20F4A48FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:ne180100](v11, v10);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::unordered_set<std::string>,BOOL>>::__emplace_back_slow_path<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::unordered_set<std::string>,BOOL &>(uint64_t *a1, uint64_t a2, uint64_t *a3, char *a4)
{
  uint64_t v5 = *a1;
  uint64_t v6 = (a1[1] - *a1) >> 6;
  unint64_t v7 = v6 + 1;
  if ((unint64_t)(v6 + 1) >> 58) {
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v11 = (uint64_t)(a1 + 2);
  uint64_t v12 = a1[2] - v5;
  if (v12 >> 5 > v7) {
    unint64_t v7 = v12 >> 5;
  }
  if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFC0) {
    unint64_t v13 = 0x3FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v13 = v7;
  }
  v18[4] = a1 + 2;
  if (v13) {
    long long v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MIL::ValueInference::Tensor<unsigned char>>>(v11, v13);
  }
  else {
    long long v14 = 0;
  }
  unint64_t v15 = &v14[64 * v6];
  v18[0] = v14;
  v18[1] = v15;
  v18[3] = &v14[64 * v13];
  *(_OWORD *)unint64_t v15 = *(_OWORD *)a2;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table((uint64_t)(v15 + 16), a3);
  v15[56] = *a4;
  v18[2] = v15 + 64;
  std::vector<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::unordered_set<std::string>,BOOL>>::__swap_out_circular_buffer(a1, v18);
  uint64_t v16 = a1[1];
  std::__split_buffer<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::unordered_set<std::string>,BOOL>>::~__split_buffer((uint64_t)v18);
  return v16;
}

void sub_20F4A4A0C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::unordered_set<std::string>,BOOL>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::unordered_set<std::string>,BOOL>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::unordered_set<std::string>,BOOL>>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::unordered_set<std::string>,BOOL>*>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::unordered_set<std::string>,BOOL>*>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::unordered_set<std::string>,BOOL>*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::unordered_set<std::string>,BOOL>>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::unordered_set<std::string>,BOOL>*>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::unordered_set<std::string>,BOOL>*>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::unordered_set<std::string>,BOOL>*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  char v14 = 0;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v9 = a3;
    do
    {
      long long v10 = *(_OWORD *)(v9 - 64);
      v9 -= 64;
      *(_OWORD *)(v7 - 64) = v10;
      *(void *)uint64_t v9 = 0;
      *(void *)(v9 + 8) = 0;
      std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__hash_table(v7 - 48, (uint64_t *)(v9 + 16));
      *(unsigned char *)(v7 - 8) = *(unsigned char *)(v9 + 56);
      uint64_t v7 = *((void *)&v16 + 1) - 64;
      *((void *)&v16 + 1) -= 64;
    }
    while (v9 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::unordered_set<std::string>,BOOL>>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::unordered_set<std::string>,BOOL>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::unordered_set<std::string>,BOOL>>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::unordered_set<std::string>,BOOL>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::unordered_set<std::string>,BOOL>>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::unordered_set<std::string>,BOOL>*>>::operator()[abi:ne180100]((uint64_t *)a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::unordered_set<std::string>,BOOL>>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::unordered_set<std::string>,BOOL>*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  uint64_t v1 = (uint64_t *)a1[2];
  uint64_t v3 = *v1;
  uint64_t v2 = v1[1];
  uint64_t v14 = v3;
  uint64_t v15 = v2;
  uint64_t v16 = v3;
  uint64_t v17 = v2;
  uint64_t v4 = *a1;
  uint64_t v5 = (uint64_t *)a1[1];
  uint64_t v7 = *v5;
  uint64_t v6 = v5[1];
  uint64_t v9 = v7;
  uint64_t v10 = v6;
  uint64_t v11 = v7;
  uint64_t v12 = v6;
  std::__allocator_destroy[abi:ne180100]<std::allocator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::unordered_set<std::string>,BOOL>>,std::reverse_iterator<std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::unordered_set<std::string>,BOOL>*>>,std::reverse_iterator<std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::unordered_set<std::string>,BOOL>*>>>(v4, (uint64_t)v13, (uint64_t)v8);
}

void std::__allocator_destroy[abi:ne180100]<std::allocator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::unordered_set<std::string>,BOOL>>,std::reverse_iterator<std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::unordered_set<std::string>,BOOL>*>>,std::reverse_iterator<std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::unordered_set<std::string>,BOOL>*>>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  for (uint64_t i = *(void *)(a2 + 32); i != *(void *)(a3 + 32); *(void *)(a2 + 32) = i)
  {
    std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(i + 16);
    uint64_t v6 = *(std::__shared_weak_count **)(i + 8);
    if (v6) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v6);
    }
    uint64_t i = *(void *)(a2 + 32) + 64;
  }
}

uint64_t std::__split_buffer<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::unordered_set<std::string>,BOOL>>::~__split_buffer(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__split_buffer<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::unordered_set<std::string>,BOOL>>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(void *)(a1 + 16); i != a2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 64;
    std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(i - 48);
    uint64_t v5 = *(std::__shared_weak_count **)(i - 56);
    if (v5) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v5);
    }
  }
}

void anonymous namespace'::TensorDTypeConstraintsImpl::~TensorDTypeConstraintsImpl(_anonymous_namespace_::TensorDTypeConstraintsImpl *this)
{
  *(void *)this = &unk_26C25D698;
  uint64_t v1 = (void **)((char *)this + 8);
  std::vector<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>::__destroy_vector::operator()[abi:ne180100](&v1);
}

{
  void **v2;

  *(void *)this = &unk_26C25D698;
  uint64_t v2 = (void **)((char *)this + 8);
  std::vector<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>::__destroy_vector::operator()[abi:ne180100](&v2);
  MEMORY[0x21056C700](this, 0xA1C4030951706);
}

uint64_t anonymous namespace'::TensorDTypeConstraintsImpl::Check@<X0>(_anonymous_namespace_::TensorDTypeConstraintsImpl *this@<X0>, MIL::IRValueType **a2@<X1>, MIL::ValidationResult *a3@<X8>)
{
  memset(v87, 0, sizeof(v87));
  int v88 = 1065353216;
  uint64_t v4 = *((void *)this + 1);
  uint64_t v5 = *((void *)this + 2);
  if (v4 == v5)
  {
LABEL_13:
    MIL::ValidationResult::ValidationResult(a3);
    return std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v87);
  }
  while (1)
  {
    uint64_t v8 = *(const MIL::IROperation **)v4;
    uint64_t v86 = 0;
    if (!MIL::ValidationResult::IsGood(a3)) {
      return std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v87);
    }
    MIL::ValidationResult::~ValidationResult(a3);
    uint64_t v9 = v86;
    if (v86) {
      break;
    }
LABEL_12:
    v4 += 40;
    if (v4 == v5) {
      goto LABEL_13;
    }
  }
  int v85 = 0;
  uint64_t v10 = (*(uint64_t (**)(void *))(*(void *)v86 + 24))(v86);
  if (v10)
  {
    Datauint64_t Type = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 88))(v10);
  }
  else
  {
    uint64_t v12 = MIL::IRValueType::TryCastAsMemoryLayoutType(v9);
    unint64_t v13 = (MIL::IRTensorBufferValueType *)MIL::IRMemoryLayoutValueType::TryAsTensorBufferType(v12);
    if (v13)
    {
      Datauint64_t Type = MIL::IRTensorBufferValueType::GetDataType(v13);
    }
    else
    {
      uint64_t v14 = MIL::IRValueType::TryCastAsMemoryLayoutType(v9);
      uint64_t v15 = (MIL::IRCircularBufferValueType *)MIL::IRMemoryLayoutValueType::TryAsCircularBufferType(v14);
      if (!v15)
      {
        std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&__v);
        unint64_t v59 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&__v, (uint64_t)"A pixel buffer is unexpected in '", 33);
        uint64_t v60 = (*((uint64_t (**)(MIL::IRValueType **))*a2 + 8))(a2);
        uint64_t v61 = (*(uint64_t (**)(uint64_t))(*(void *)v60 + 16))(v60);
        int v62 = *(char *)(v61 + 23);
        if (v62 >= 0) {
          uint64_t v63 = v61;
        }
        else {
          uint64_t v63 = *(void *)v61;
        }
        if (v62 >= 0) {
          uint64_t v64 = *(unsigned __int8 *)(v61 + 23);
        }
        else {
          uint64_t v64 = *(void *)(v61 + 8);
        }
        uint64_t v65 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v59, v63, v64);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v65, (uint64_t)".", 1);
        LocationPtr = (uint64_t *)MIL::IRObject::GetLocationPtr((MIL::IRObject *)a2);
        uint64_t v67 = (std::__shared_weak_count *)LocationPtr[1];
        uint64_t v83 = *LocationPtr;
        uint64_t v84 = v67;
        if (v67) {
          atomic_fetch_add_explicit(&v67->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        std::stringbuf::str();
        MIL::ValidationResult::ValidationResult(a3, &v83, 319, &v81);
        if (v82 < 0) {
          operator delete(v81);
        }
        if (v84) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v84);
        }
        __v.__first_ = (std::__split_buffer<std::string>::pointer)*MEMORY[0x263F8C2C8];
        *(std::__split_buffer<std::string>::pointer *)((char *)&__v.__first_
                                                     + __v.__first_[-1].__r_.__value_.__r.__words[0]) = *(std::__split_buffer<std::string>::pointer *)(MEMORY[0x263F8C2C8] + 24);
        __v.__begin_ = (std::__split_buffer<std::string>::pointer)(MEMORY[0x263F8C318] + 16);
        if (v91 < 0) {
          operator delete(v90);
        }
        std::streambuf::~streambuf();
        std::ostream::~ostream();
        MEMORY[0x21056C620](v92);
        return std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v87);
      }
      Datauint64_t Type = MIL::IRCircularBufferValueType::GetDataType(v15);
    }
  }
  int v85 = DataType;
  __v.__first_ = (std::__split_buffer<std::string>::pointer)(v4 + 16);
  __p[0] = &v85;
  uint64_t v16 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRDataType>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRDataType>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRDataType>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRDataType>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<MIL::IRDataType&>>((uint64_t)v87, (unsigned __int8 *)(v4 + 16), (uint64_t)&std::piecewise_construct, (long long **)&__v, (_DWORD **)__p);
  if (v17 || *((_DWORD *)v16 + 10) == v85) {
    goto LABEL_12;
  }
  memset(&v80, 0, sizeof(v80));
  uint64_t v19 = *((void *)this + 1);
  uint64_t v20 = *((void *)this + 2);
  if (v19 != v20)
  {
    while (1)
    {
      uint64_t v21 = *(unsigned __int8 *)(v19 + 39);
      if ((v21 & 0x80u) == 0) {
        uint64_t v22 = *(unsigned __int8 *)(v19 + 39);
      }
      else {
        uint64_t v22 = *(void *)(v19 + 24);
      }
      uint64_t v23 = *(unsigned __int8 *)(v4 + 39);
      int v24 = (char)v23;
      if ((v23 & 0x80u) != 0) {
        uint64_t v23 = *(void *)(v4 + 24);
      }
      if (v22 != v23) {
        goto LABEL_45;
      }
      unint64_t v25 = v24 >= 0 ? (unsigned __int8 *)(v4 + 16) : *(unsigned __int8 **)(v4 + 16);
      if ((v21 & 0x80) == 0) {
        break;
      }
      if (!memcmp(*(const void **)(v19 + 16), v25, *(void *)(v19 + 24))) {
        goto LABEL_32;
      }
LABEL_45:
      v19 += 40;
      if (v19 == v20) {
        goto LABEL_46;
      }
    }
    if (*(unsigned char *)(v19 + 39))
    {
      uint64_t v26 = 0;
      while (*(unsigned __int8 *)(v19 + v26 + 16) == v25[v26])
      {
        if (v21 == ++v26) {
          goto LABEL_32;
        }
      }
      goto LABEL_45;
    }
LABEL_32:
    (*(void (**)(void **__return_ptr))(**(void **)v19 + 48))(__p);
    std::vector<std::string>::pointer end = v80.__end_;
    if (v80.__end_ >= v80.__end_cap_.__value_)
    {
      unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * (((char *)v80.__end_ - (char *)v80.__begin_) >> 3);
      unint64_t v30 = v29 + 1;
      if (v29 + 1 > 0xAAAAAAAAAAAAAAALL) {
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      }
      if (0x5555555555555556 * (((char *)v80.__end_cap_.__value_ - (char *)v80.__begin_) >> 3) > v30) {
        unint64_t v30 = 0x5555555555555556 * (((char *)v80.__end_cap_.__value_ - (char *)v80.__begin_) >> 3);
      }
      if (0xAAAAAAAAAAAAAAABLL * (((char *)v80.__end_cap_.__value_ - (char *)v80.__begin_) >> 3) >= 0x555555555555555) {
        unint64_t v31 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v31 = v30;
      }
      __v.__end_cap_.__value_ = (std::allocator<std::string> *)&v80.__end_cap_;
      if (v31) {
        std::string v32 = (std::string *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)&v80.__end_cap_, v31);
      }
      else {
        std::string v32 = 0;
      }
      std::string::value_type v33 = v32 + v29;
      __v.__first_ = v32;
      __v.__begin_ = v33;
      __v.__end_cap_.__value_ = &v32[v31];
      long long v34 = *(_OWORD *)__p;
      v33->__r_.__value_.__r.__words[2] = v76;
      *(_OWORD *)&v33->__r_.__value_.__l.__data_ = v34;
      __p[1] = 0;
      std::string::size_type v76 = 0;
      __p[0] = 0;
      __v.__end_ = v33 + 1;
      std::vector<std::string>::__swap_out_circular_buffer(&v80, &__v);
      unint64_t v35 = v80.__end_;
      std::__split_buffer<std::string>::~__split_buffer(&__v);
      v80.__end_ = v35;
      if (SHIBYTE(v76) < 0) {
        operator delete(__p[0]);
      }
    }
    else
    {
      long long v28 = *(_OWORD *)__p;
      v80.__end_->__r_.__value_.__r.__words[2] = v76;
      *(_OWORD *)&end->__r_.__value_.__l.__data_ = v28;
      v80.__end_ = end + 1;
    }
    goto LABEL_45;
  }
LABEL_46:
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)__p);
  uint64_t v36 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(__p, (uint64_t)"In '", 4);
  uint64_t v37 = (*((uint64_t (**)(MIL::IRValueType **))*a2 + 8))(a2);
  uint64_t v38 = (*(uint64_t (**)(uint64_t))(*(void *)v37 + 16))(v37);
  int v39 = *(char *)(v38 + 23);
  if (v39 >= 0) {
    uint64_t v40 = v38;
  }
  else {
    uint64_t v40 = *(void *)v38;
  }
  if (v39 >= 0) {
    uint64_t v41 = *(unsigned __int8 *)(v38 + 23);
  }
  else {
    uint64_t v41 = *(void *)(v38 + 8);
  }
  uint64_t v42 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v36, v40, v41);
  unsigned __int8 v68 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v42, (uint64_t)"' operations, tensors", 21);
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&__v);
  if (v80.__end_ != v80.__begin_)
  {
    uint64_t v43 = 0;
    unint64_t v44 = 0;
    unint64_t v45 = 0xAAAAAAAAAAAAAAABLL * (((char *)v80.__end_ - (char *)v80.__begin_) >> 3);
    do
    {
      if (v44)
      {
        unint64_t v46 = v45 - 1;
        if (v44 == v46) {
          unint64_t v47 = ", and ";
        }
        else {
          unint64_t v47 = ", ";
        }
        if (v44 == v46) {
          uint64_t v48 = 6;
        }
        else {
          uint64_t v48 = 2;
        }
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&__v, (uint64_t)v47, v48);
      }
      else
      {
        v93[0] = 32;
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&__v, (uint64_t)v93, 1);
      }
      int v49 = SHIBYTE(v80.__begin_[v43].__r_.__value_.__r.__words[2]);
      if (v49 >= 0) {
        std::string::pointer data = &v80.__begin_[v43];
      }
      else {
        std::string::pointer data = (std::string *)v80.__begin_[v43].__r_.__value_.__l.__data_;
      }
      if (v49 >= 0) {
        std::string::size_type size = HIBYTE(v80.__begin_[v43].__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = v80.__begin_[v43].__r_.__value_.__l.__size_;
      }
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&__v, (uint64_t)data, size);
      ++v44;
      unint64_t v45 = 0xAAAAAAAAAAAAAAABLL * (((char *)v80.__end_ - (char *)v80.__begin_) >> 3);
      ++v43;
    }
    while (v44 < v45);
  }
  std::stringbuf::str();
  __v.__first_ = (std::__split_buffer<std::string>::pointer)*MEMORY[0x263F8C2C8];
  std::__split_buffer<std::string>::pointer first = __v.__first_;
  std::string v53 = *(std::string **)(MEMORY[0x263F8C2C8] + 24);
  *(std::__split_buffer<std::string>::pointer *)((char *)&__v.__first_ + __v.__first_[-1].__r_.__value_.__r.__words[0]) = v53;
  __v.__begin_ = (std::__split_buffer<std::string>::pointer)(MEMORY[0x263F8C318] + 16);
  if (v91 < 0) {
    operator delete(v90);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x21056C620](v92);
  if ((v74 & 0x80u) == 0) {
    uint64_t v54 = v73;
  }
  else {
    uint64_t v54 = (void **)v73[0];
  }
  if ((v74 & 0x80u) == 0) {
    uint64_t v55 = v74;
  }
  else {
    uint64_t v55 = (uint64_t)v73[1];
  }
  uint64_t v56 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v68, (uint64_t)v54, v55);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v56, (uint64_t)" must have the same data type.", 30);
  if ((char)v74 < 0) {
    operator delete(v73[0]);
  }
  std::string::size_type v57 = (uint64_t *)MIL::IRObject::GetLocationPtr((MIL::IRObject *)a2);
  uint64_t v58 = (std::__shared_weak_count *)v57[1];
  uint64_t v71 = *v57;
  uint64_t v72 = v58;
  if (v58) {
    atomic_fetch_add_explicit(&v58->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  std::stringbuf::str();
  MIL::ValidationResult::ValidationResult(a3, &v71, 319, &v69);
  if (v70 < 0) {
    operator delete(v69);
  }
  if (v72) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v72);
  }
  __p[0] = first;
  *(void **)((char *)__p + first[-1].__r_.__value_.__r.__words[0]) = v53;
  __p[1] = (void *)(MEMORY[0x263F8C318] + 16);
  if (v78 < 0) {
    operator delete(v77);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x21056C620](&v79);
  __v.__first_ = (std::__split_buffer<std::string>::pointer)&v80;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&__v);
  return std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v87);
}

void sub_20F4A56A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,void *__p,uint64_t a55,int a56,__int16 a57,char a58,char a59,uint64_t a60,std::__shared_weak_count *a61,uint64_t a62,uint64_t a63)
{
  if (a59 < 0) {
    operator delete(__p);
  }
  if (a61) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a61);
  }
  std::ostringstream::~ostringstream((uint64_t)&a70);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&a64);
  _Unwind_Resume(a1);
}

void anonymous namespace'::TensorDTypeConstraintsImpl::Add(uint64_t a1, long long *a2, long long *a3)
{
  long long v3 = *a2;
  *(void *)a2 = 0;
  *((void *)a2 + 1) = 0;
  long long v4 = *a3;
  long long v5 = v3;
  *(_OWORD *)std::string __p = v4;
  uint64_t v7 = *((void *)a3 + 2);
  *((void *)a3 + 1) = 0;
  *((void *)a3 + 2) = 0;
  *(void *)a3 = 0;
  std::vector<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>::emplace_back<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>((uint64_t *)(a1 + 8), (uint64_t)&v5);
  if (SHIBYTE(v7) < 0) {
    operator delete(__p[0]);
  }
  if (*((void *)&v5 + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v5 + 1));
  }
}

void sub_20F4A583C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void anonymous namespace'::TensorDTypeConstraintsImpl::AddParameter(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)uint64_t v2 = *(_OWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  MIL::Validation::OpParameterConstraintTarget::Make();
}

void sub_20F4A59A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  uint64_t v23 = *(void *)(v21 - 40);
  *(void *)(v21 - 40) = 0;
  if (v23) {
    (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
  }
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    long long v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 40;
        std::allocator<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>::destroy[abi:ne180100]((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      long long v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::allocator<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 39) < 0) {
    operator delete(*(void **)(a2 + 16));
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a2 + 8);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
}

uint64_t std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>::~pair(uint64_t a1)
{
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  return a1;
}

void anonymous namespace'::GetTargetTensorOrMemoryLayoutType(_anonymous_namespace_ *this@<X0>, const MIL::IRValueType **a2@<X1>, const MIL::IROperation *a3@<X2>, MIL::ValidationResult *a4@<X8>)
{
  uint64_t v9 = (*(uint64_t (**)(const MIL::IROperation *))(*(void *)a3 + 24))(a3);
  if (!v9)
  {
    if ((*(unsigned int (**)(const MIL::IROperation *))(*(void *)a3 + 16))(a3)) {
      goto LABEL_6;
    }
    LocationPtr = (uint64_t *)MIL::IRObject::GetLocationPtr((MIL::IRObject *)a2);
    unint64_t v13 = (std::__shared_weak_count *)LocationPtr[1];
    uint64_t v28 = *LocationPtr;
    unint64_t v29 = v13;
    if (v13) {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(std::string *__return_ptr, const MIL::IROperation *))(*(void *)a3 + 48))(&v25, a3);
    uint64_t v14 = std::string::insert(&v25, 0, "Could not find type of ");
    long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    v26.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v26.__r_.__value_.__l.__data_ = v15;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    std::string::push_back(&v26, 46);
    std::string __p = v26;
    memset(&v26, 0, sizeof(v26));
    MIL::ValidationResult::ValidationResult(a4, &v28, 319, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v26.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v25.__r_.__value_.__l.__data_);
    }
    uint64_t v16 = v29;
    if (!v29) {
      return;
    }
LABEL_18:
    std::__shared_weak_count::__release_shared[abi:ne180100](v16);
    return;
  }
  uint64_t v10 = (void *)v9;
  uint64_t v11 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v9 + 24))(v9);
  if (v11 || (uint64_t v11 = MIL::IRValueType::TryCastAsMemoryLayoutType(v10)) != 0)
  {
    *(void *)this = v11;
LABEL_6:
    MIL::ValidationResult::ValidationResult(a4);
    return;
  }
  char v17 = (uint64_t *)MIL::IRObject::GetLocationPtr((MIL::IRObject *)a2);
  uint64_t v18 = (std::__shared_weak_count *)v17[1];
  uint64_t v23 = *v17;
  int v24 = v18;
  if (v18) {
    atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(std::string *__return_ptr, const MIL::IROperation *))(*(void *)a3 + 48))(&v26, a3);
  uint64_t v19 = std::string::append(&v26, " is not a tensor.");
  long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
  std::string::size_type v22 = v19->__r_.__value_.__r.__words[2];
  *(_OWORD *)uint64_t v21 = v20;
  v19->__r_.__value_.__l.__size_ = 0;
  v19->__r_.__value_.__r.__words[2] = 0;
  v19->__r_.__value_.__r.__words[0] = 0;
  MIL::ValidationResult::ValidationResult(a4, &v23, 319, v21);
  if (SHIBYTE(v22) < 0) {
    operator delete(v21[0]);
  }
  if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v26.__r_.__value_.__l.__data_);
  }
  uint64_t v16 = v24;
  if (v24) {
    goto LABEL_18;
  }
}

void sub_20F4A5DEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, std::__shared_weak_count *a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a16);
  }
  _Unwind_Resume(exception_object);
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,MIL::IRDataType>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRDataType>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRDataType>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRDataType>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<MIL::IRDataType&>>(uint64_t a1, unsigned __int8 *a2, uint64_t a3, long long **a4, _DWORD **a5)
{
  uint64_t v10 = (void *)(a1 + 24);
  unint64_t v11 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  unint64_t v12 = v11;
  unint64_t v13 = *(void *)(a1 + 8);
  if (v13)
  {
    uint8x8_t v14 = (uint8x8_t)vcnt_s8((int8x8_t)v13);
    v14.i16[0] = vaddlv_u8(v14);
    unint64_t v15 = v14.u32[0];
    if (v14.u32[0] > 1uLL)
    {
      unint64_t v5 = v11;
      if (v11 >= v13) {
        unint64_t v5 = v11 % v13;
      }
    }
    else
    {
      unint64_t v5 = (v13 - 1) & v11;
    }
    uint64_t v16 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v5);
    if (v16)
    {
      for (uint64_t i = *v16; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v18 = *((void *)i + 1);
        if (v18 == v12)
        {
          if (std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2)) {
            return i;
          }
        }
        else
        {
          if (v15 > 1)
          {
            if (v18 >= v13) {
              v18 %= v13;
            }
          }
          else
          {
            v18 &= v13 - 1;
          }
          if (v18 != v5) {
            break;
          }
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,MIL::IRDataType>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRDataType>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRDataType>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRDataType>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<MIL::IRDataType&>>(a1, v12, a4, a5, (uint64_t)v28);
  float v19 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v20 = *(float *)(a1 + 32);
  if (!v13 || (float)(v20 * (float)v13) < v19)
  {
    BOOL v21 = 1;
    if (v13 >= 3) {
      BOOL v21 = (v13 & (v13 - 1)) != 0;
    }
    unint64_t v22 = v21 | (2 * v13);
    unint64_t v23 = vcvtps_u32_f32(v19 / v20);
    if (v22 <= v23) {
      size_t v24 = v23;
    }
    else {
      size_t v24 = v22;
    }
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v24);
    unint64_t v13 = *(void *)(a1 + 8);
    if ((v13 & (v13 - 1)) != 0)
    {
      if (v12 >= v13) {
        unint64_t v5 = v12 % v13;
      }
      else {
        unint64_t v5 = v12;
      }
    }
    else
    {
      unint64_t v5 = (v13 - 1) & v12;
    }
  }
  std::string v25 = *(void **)(*(void *)a1 + 8 * v5);
  if (v25)
  {
    *(void *)v28[0] = *v25;
    void *v25 = v28[0];
  }
  else
  {
    *(void *)v28[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v28[0];
    *(void *)(*(void *)a1 + 8 * v5) = a1 + 16;
    if (*(void *)v28[0])
    {
      unint64_t v26 = *(void *)(*(void *)v28[0] + 8);
      if ((v13 & (v13 - 1)) != 0)
      {
        if (v26 >= v13) {
          v26 %= v13;
        }
      }
      else
      {
        v26 &= v13 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v26) = v28[0];
    }
  }
  uint64_t i = (unsigned __int8 *)v28[0];
  ++*v10;
  return i;
}

void sub_20F4A6100(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void **__p, uint64_t a13)
{
  if (__p) {
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:ne180100]((uint64_t)&a13, __p);
  }
  _Unwind_Resume(exception_object);
}

void std::__hash_table<std::__hash_value_type<std::string,MIL::IRDataType>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRDataType>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRDataType>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRDataType>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<MIL::IRDataType&>>(uint64_t a1@<X0>, uint64_t a2@<X1>, long long **a3@<X3>, _DWORD **a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v9 = a1 + 16;
  uint64_t v10 = (char *)operator new(0x30uLL);
  *(void *)a5 = v10;
  *(void *)(a5 + 8) = v9;
  *(unsigned char *)(a5 + 16) = 0;
  *(void *)uint64_t v10 = 0;
  *((void *)v10 + 1) = a2;
  unint64_t v11 = (std::string *)(v10 + 16);
  unint64_t v12 = *a3;
  unint64_t v13 = *a4;
  if (*((char *)*a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v11, *(const std::string::value_type **)v12, *((void *)v12 + 1));
  }
  else
  {
    long long v14 = *v12;
    *((void *)v10 + 4) = *((void *)v12 + 2);
    *(_OWORD *)&v11->__r_.__value_.__l.__data_ = v14;
  }
  *((_DWORD *)v10 + 10) = *v13;
  *(unsigned char *)(a5 + 16) = 1;
}

void sub_20F4A61C8(_Unwind_Exception *a1)
{
  void *v1 = 0;
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>::emplace_back<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>(uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = a1 + 2;
  unint64_t v5 = v6;
  unint64_t v7 = *(v4 - 1);
  if (v7 >= v6)
  {
    unint64_t v10 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v7 - *a1) >> 3);
    unint64_t v11 = v10 + 1;
    if (v10 + 1 > 0x666666666666666) {
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v5 - *a1) >> 3);
    if (2 * v12 > v11) {
      unint64_t v11 = 2 * v12;
    }
    if (v12 >= 0x333333333333333) {
      unint64_t v13 = 0x666666666666666;
    }
    else {
      unint64_t v13 = v11;
    }
    v18[4] = v4;
    if (v13) {
      long long v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<char const*,MIL::Transform::ArgumentDescription>>>((uint64_t)v4, v13);
    }
    else {
      long long v14 = 0;
    }
    unint64_t v15 = &v14[40 * v10];
    v18[0] = v14;
    v18[1] = v15;
    v18[3] = &v14[40 * v13];
    *(_OWORD *)unint64_t v15 = *(_OWORD *)a2;
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    long long v16 = *(_OWORD *)(a2 + 16);
    *((void *)v15 + 4) = *(void *)(a2 + 32);
    *((_OWORD *)v15 + 1) = v16;
    *(void *)(a2 + 24) = 0;
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 16) = 0;
    v18[2] = v15 + 40;
    std::vector<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>::__swap_out_circular_buffer(a1, v18);
    uint64_t v9 = a1[1];
    std::__split_buffer<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>::~__split_buffer(v18);
  }
  else
  {
    *(_OWORD *)unint64_t v7 = *(_OWORD *)a2;
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    long long v8 = *(_OWORD *)(a2 + 16);
    *(void *)(v7 + 32) = *(void *)(a2 + 32);
    *(_OWORD *)(v7 + 16) = v8;
    *(void *)(a2 + 24) = 0;
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 16) = 0;
    uint64_t v9 = v7 + 40;
    a1[1] = v7 + 40;
  }
  a1[1] = v9;
  return v9 - 40;
}

void sub_20F4A6328(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>,std::reverse_iterator<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>*>,std::reverse_iterator<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>*>,std::reverse_iterator<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>,std::reverse_iterator<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>*>,std::reverse_iterator<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>*>,std::reverse_iterator<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = a7 - 40;
    do
    {
      long long v9 = *(_OWORD *)(a3 - 40);
      a3 -= 40;
      *(_OWORD *)uint64_t v8 = v9;
      *(void *)a3 = 0;
      *(void *)(a3 + 8) = 0;
      long long v10 = *(_OWORD *)(a3 + 16);
      *(void *)(v8 + 32) = *(void *)(a3 + 32);
      *(_OWORD *)(v8 + 16) = v10;
      *(void *)(a3 + 24) = 0;
      *(void *)(a3 + 32) = 0;
      *(void *)(a3 + 16) = 0;
      *((void *)&v16 + 1) = v8;
      v8 -= 40;
      v7 -= 40;
    }
    while (a3 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>,std::reverse_iterator<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>,std::reverse_iterator<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>,std::reverse_iterator<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>*>>::operator()[abi:ne180100]((uint64_t *)a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>,std::reverse_iterator<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v1 = *(void *)(a1[2] + 8);
  uint64_t v2 = *(void *)(a1[1] + 8);
  if (v1 != v2)
  {
    uint64_t v3 = *a1;
    do
    {
      std::allocator<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>::destroy[abi:ne180100](v3, v1);
      v1 += 40;
    }
    while (v1 != v2);
  }
}

void **std::__split_buffer<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void std::__split_buffer<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>::clear[abi:ne180100](void *a1)
{
  uint64_t v2 = a1[1];
  for (uint64_t i = a1[2]; i != v2; uint64_t i = a1[2])
  {
    uint64_t v4 = a1[4];
    a1[2] = i - 40;
    std::allocator<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>::destroy[abi:ne180100](v4, i - 40);
  }
}

void std::__shared_ptr_pointer<MIL::Validation::OpParameterConstraintTarget  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21056C700);
}

uint64_t std::__shared_ptr_pointer<MIL::Validation::OpParameterConstraintTarget  *>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<MIL::Validation::OpParameterConstraintTarget  *>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void anonymous namespace'::TensorRankValueConstraintsImpl::~TensorRankValueConstraintsImpl(_anonymous_namespace_::TensorRankValueConstraintsImpl *this)
{
  *(void *)this = &unk_26C25D748;
  uint64_t v1 = (void **)((char *)this + 8);
  std::vector<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,long long,long long>>::__destroy_vector::operator()[abi:ne180100](&v1);
}

{
  void **v2;

  *(void *)this = &unk_26C25D748;
  uint64_t v2 = (void **)((char *)this + 8);
  std::vector<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,long long,long long>>::__destroy_vector::operator()[abi:ne180100](&v2);
  MEMORY[0x21056C700](this, 0xA1C4030951706);
}

void anonymous namespace'::TensorRankValueConstraintsImpl::Check(_anonymous_namespace_::TensorRankValueConstraintsImpl *this@<X0>, MIL::IRTensorValueType **a2@<X1>, MIL::ValidationResult *a3@<X8>)
{
  uint64_t v4 = *((void *)this + 1);
  uint64_t v5 = *((void *)this + 2);
  if (v4 != v5)
  {
    while (1)
    {
      uint64_t v42 = 0;
      if (!MIL::ValidationResult::IsGood(a3)) {
        return;
      }
      MIL::ValidationResult::~ValidationResult(a3);
      if (v42)
      {
        uint64_t v7 = MIL::IRTensorValueType::Rank(v42);
        uint64_t v8 = v7;
        if (*(void *)(v4 + 16) > v7 || v7 > *(void *)(v4 + 24)) {
          break;
        }
      }
      v4 += 32;
      if (v4 == v5) {
        goto LABEL_7;
      }
    }
    (*(void (**)(std::string *__return_ptr))(**(void **)v4 + 48))(&v38);
    long long v9 = std::string::append(&v38, " has invalid rank ");
    long long v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    v39.__r_.__value_.__r.__words[2] = v9->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v39.__r_.__value_.__l.__data_ = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v37, v8);
    if ((v37.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v11 = &v37;
    }
    else {
      uint64_t v11 = (std::string *)v37.__r_.__value_.__r.__words[0];
    }
    if ((v37.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v37.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v37.__r_.__value_.__l.__size_;
    }
    unint64_t v13 = std::string::append(&v39, (const std::string::value_type *)v11, size);
    long long v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    v40.__r_.__value_.__r.__words[2] = v13->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v40.__r_.__value_.__l.__data_ = v14;
    v13->__r_.__value_.__l.__size_ = 0;
    v13->__r_.__value_.__r.__words[2] = 0;
    v13->__r_.__value_.__r.__words[0] = 0;
    long long v15 = std::string::append(&v40, ", expected ");
    long long v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
    v41.__r_.__value_.__r.__words[2] = v15->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v41.__r_.__value_.__l.__data_ = v16;
    v15->__r_.__value_.__l.__size_ = 0;
    v15->__r_.__value_.__r.__words[2] = 0;
    v15->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v40.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v37.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v39.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v38.__r_.__value_.__l.__data_);
    }
    uint64_t v17 = *(void *)(v4 + 16);
    if (v17 == *(void *)(v4 + 24))
    {
      std::to_string(&v40, v17);
      if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        unint64_t v18 = &v40;
      }
      else {
        unint64_t v18 = (std::string *)v40.__r_.__value_.__r.__words[0];
      }
      if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v19 = HIBYTE(v40.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v19 = v40.__r_.__value_.__l.__size_;
      }
      std::string::append(&v41, (const std::string::value_type *)v18, v19);
      if ((SHIBYTE(v40.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_61;
      }
      float v20 = (void *)v40.__r_.__value_.__r.__words[0];
    }
    else
    {
      std::to_string(&v36, v17);
      if ((v36.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        v21.__i_ = (std::__wrap_iter<const char *>::iterator_type)&v36;
      }
      else {
        v21.__i_ = (std::__wrap_iter<const char *>::iterator_type)v36.__r_.__value_.__r.__words[0];
      }
      std::string::insert(&v36, v21, 91);
      std::string v37 = v36;
      memset(&v36, 0, sizeof(v36));
      unint64_t v22 = std::string::append(&v37, ", ");
      long long v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
      v38.__r_.__value_.__r.__words[2] = v22->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v38.__r_.__value_.__l.__data_ = v23;
      v22->__r_.__value_.__l.__size_ = 0;
      v22->__r_.__value_.__r.__words[2] = 0;
      v22->__r_.__value_.__r.__words[0] = 0;
      std::to_string(&v35, *(void *)(v4 + 24));
      if ((v35.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        size_t v24 = &v35;
      }
      else {
        size_t v24 = (std::string *)v35.__r_.__value_.__r.__words[0];
      }
      if ((v35.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v25 = HIBYTE(v35.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v25 = v35.__r_.__value_.__l.__size_;
      }
      unint64_t v26 = std::string::append(&v38, (const std::string::value_type *)v24, v25);
      long long v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
      v39.__r_.__value_.__r.__words[2] = v26->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v39.__r_.__value_.__l.__data_ = v27;
      v26->__r_.__value_.__l.__size_ = 0;
      v26->__r_.__value_.__r.__words[2] = 0;
      v26->__r_.__value_.__r.__words[0] = 0;
      std::string::push_back(&v39, 93);
      std::string v40 = v39;
      memset(&v39, 0, sizeof(v39));
      if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v28 = &v40;
      }
      else {
        uint64_t v28 = (std::string *)v40.__r_.__value_.__r.__words[0];
      }
      if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v29 = HIBYTE(v40.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v29 = v40.__r_.__value_.__l.__size_;
      }
      std::string::append(&v41, (const std::string::value_type *)v28, v29);
      if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v40.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v39.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v35.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v38.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v37.__r_.__value_.__l.__data_);
      }
      if ((SHIBYTE(v36.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_61;
      }
      float v20 = (void *)v36.__r_.__value_.__r.__words[0];
    }
    operator delete(v20);
LABEL_61:
    std::string::push_back(&v41, 46);
    LocationPtr = (uint64_t *)MIL::IRObject::GetLocationPtr((MIL::IRObject *)a2);
    unint64_t v31 = (std::__shared_weak_count *)LocationPtr[1];
    uint64_t v33 = *LocationPtr;
    long long v34 = v31;
    if (v31) {
      atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    std::string __p = v41;
    memset(&v41, 0, sizeof(v41));
    MIL::ValidationResult::ValidationResult(a3, &v33, 319, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (v34) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v34);
    }
    if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v41.__r_.__value_.__l.__data_);
    }
    return;
  }
LABEL_7:

  MIL::ValidationResult::ValidationResult(a3);
}

void sub_20F4A6AD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  if (*(char *)(v42 - 89) < 0) {
    operator delete(*(void **)(v42 - 112));
  }
  if (*(char *)(v42 - 121) < 0) {
    operator delete(*(void **)(v42 - 144));
  }
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a42 < 0) {
    operator delete(a37);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  if (*(char *)(v42 - 57) < 0) {
    operator delete(*(void **)(v42 - 80));
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::TensorRankValueConstraintsImpl::Add(uint64_t a1, long long *a2, uint64_t a3)
{
  long long v3 = *a2;
  *(void *)a2 = 0;
  *((void *)a2 + 1) = 0;
  (*(void (**)(uint64_t, long long *, uint64_t, uint64_t))(*(void *)a1 + 32))(a1, &v3, a3, a3);
  if (*((void *)&v3 + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v3 + 1));
  }
}

void sub_20F4A6C98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t anonymous namespace'::TensorRankValueConstraintsImpl::Add(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a4;
  uint64_t v6 = a3;
  return std::vector<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,long long,long long>>::emplace_back<std::shared_ptr<MIL::Validation::ConstraintTarget const>,long long &,long long &>((uint64_t *)(a1 + 8), a2, &v6, &v5);
}

void std::vector<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,long long,long long>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,long long,long long>>::__clear[abi:ne180100]((uint64_t *)v2);
    long long v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,long long,long long>>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 32)
  {
    uint64_t v4 = *(std::__shared_weak_count **)(i - 24);
    if (v4) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v4);
    }
  }
  a1[1] = v2;
}

uint64_t std::vector<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,long long,long long>>::emplace_back<std::shared_ptr<MIL::Validation::ConstraintTarget const>,long long &,long long &>(uint64_t *a1, uint64_t a2, void *a3, void *a4)
{
  unint64_t v10 = a1[2];
  uint64_t v8 = a1 + 2;
  unint64_t v9 = v10;
  unint64_t v11 = *(v8 - 1);
  if (v11 >= v10)
  {
    uint64_t v13 = (uint64_t)(v11 - *a1) >> 5;
    unint64_t v14 = v13 + 1;
    if ((unint64_t)(v13 + 1) >> 59) {
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v15 = v9 - *a1;
    if (v15 >> 4 > v14) {
      unint64_t v14 = v15 >> 4;
    }
    if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v16 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v16 = v14;
    }
    v20[4] = v8;
    if (v16) {
      uint64_t v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::function<void ()(MIL::Transform::ProgramTransformer &)>>>((uint64_t)v8, v16);
    }
    else {
      uint64_t v17 = 0;
    }
    unint64_t v18 = &v17[32 * v13];
    v20[0] = v17;
    v20[1] = v18;
    v20[3] = &v17[32 * v16];
    *(_OWORD *)unint64_t v18 = *(_OWORD *)a2;
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *((void *)v18 + 2) = *a3;
    *((void *)v18 + 3) = *a4;
    v20[2] = v18 + 32;
    std::vector<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,long long,long long>>::__swap_out_circular_buffer(a1, v20);
    uint64_t v12 = a1[1];
    std::__split_buffer<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,long long,long long>>::~__split_buffer(v20);
  }
  else
  {
    *(_OWORD *)unint64_t v11 = *(_OWORD *)a2;
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(v11 + 16) = *a3;
    *(void *)(v11 + 24) = *a4;
    uint64_t v12 = v11 + 32;
    a1[1] = v11 + 32;
  }
  a1[1] = v12;
  return v12 - 32;
}

void sub_20F4A6EA4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,long long,long long>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,long long,long long>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,long long,long long>>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,long long,long long>*>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,long long,long long>*>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,long long,long long>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,long long,long long>>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,long long,long long>*>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,long long,long long>*>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,long long,long long>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  void v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = a7 - 32;
    do
    {
      long long v9 = *((_OWORD *)a3 - 2);
      a3 -= 4;
      *(_OWORD *)uint64_t v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *(void *)(v8 + 16) = a3[2];
      *(void *)(v8 + 24) = a3[3];
      *((void *)&v15 + 1) = v8;
      v8 -= 32;
      v7 -= 32;
    }
    while (a3 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,long long,long long>>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,long long,long long>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,long long,long long>>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,long long,long long>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,long long,long long>>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,long long,long long>*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,long long,long long>>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,long long,long long>*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    long long v3 = *(std::__shared_weak_count **)(v1 + 8);
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    }
    v1 += 32;
  }
}

void **std::__split_buffer<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,long long,long long>>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void std::__split_buffer<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,long long,long long>>::clear[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v1 = *(void *)(a1 + 16);
  while (v1 != v2)
  {
    *(void *)(a1 + 16) = v1 - 32;
    uint64_t v4 = *(std::__shared_weak_count **)(v1 - 24);
    if (v4)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v4);
      uint64_t v1 = *(void *)(a1 + 16);
    }
    else
    {
      v1 -= 32;
    }
  }
}

void anonymous namespace'::TensorSymbolicShapeConstraintsImpl::~TensorSymbolicShapeConstraintsImpl(_anonymous_namespace_::TensorSymbolicShapeConstraintsImpl *this)
{
  *(void *)this = &unk_26C25D798;
  uint64_t v2 = (void **)((char *)this + 8);
  long long v3 = (void **)((char *)this + 56);
  std::vector<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>::__destroy_vector::operator()[abi:ne180100](&v3);
  long long v3 = (void **)((char *)this + 32);
  std::vector<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long,long long>>::__destroy_vector::operator()[abi:ne180100](&v3);
  long long v3 = v2;
  std::vector<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long>>::__destroy_vector::operator()[abi:ne180100](&v3);
}

{
  void **v2;
  void **v3;

  *(void *)this = &unk_26C25D798;
  uint64_t v2 = (void **)((char *)this + 8);
  long long v3 = (void **)((char *)this + 56);
  std::vector<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>::__destroy_vector::operator()[abi:ne180100](&v3);
  long long v3 = (void **)((char *)this + 32);
  std::vector<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long,long long>>::__destroy_vector::operator()[abi:ne180100](&v3);
  long long v3 = v2;
  std::vector<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long>>::__destroy_vector::operator()[abi:ne180100](&v3);
  MEMORY[0x21056C700](this, 0xA1C405040A028);
}

uint64_t anonymous namespace'::TensorSymbolicShapeConstraintsImpl::Check@<X0>(_anonymous_namespace_::TensorSymbolicShapeConstraintsImpl *this@<X0>, MIL::IRValueType **a2@<X1>, MIL::ValidationResult *a3@<X8>)
{
  memset(v138, 0, sizeof(v138));
  int v139 = 1065353216;
  memset(v136, 0, sizeof(v136));
  int v137 = 1065353216;
  uint64_t v5 = (const MIL::IROperation **)*((void *)this + 7);
  uint64_t v6 = (const MIL::IROperation **)*((void *)this + 8);
  if (v5 == v6)
  {
LABEL_32:
    MIL::ValidationResult::ValidationResult(a3);
  }
  else
  {
    uint64_t v133 = (void *)*MEMORY[0x263F8C2C8];
    uint64_t v130 = *(void **)(MEMORY[0x263F8C2C8] + 24);
    while (1)
    {
      uint64_t v7 = *v5;
      unint64_t v159 = 0;
      if (!MIL::ValidationResult::IsGood(a3)) {
        break;
      }
      MIL::ValidationResult::~ValidationResult(a3);
      if (v159)
      {
        unint64_t v156 = (void *)v152;
        if ((v152 & 0x8000000000000000) != 0)
        {
          int v11 = 3;
        }
        else
        {
          v165[0] = v5 + 2;
          __p[0] = &v156;
          long long v9 = std::__hash_table<std::__hash_value_type<std::string,long long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,long long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,long long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,long long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<long long &>>((uint64_t)v138, (unsigned __int8 *)v5 + 16, (uint64_t)&std::piecewise_construct, (long long **)v165, (void **)__p);
          if (v10 || *((void **)v9 + 5) == v156)
          {
            int v11 = 0;
          }
          else
          {
            std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v165);
            uint64_t v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v165, (uint64_t)"Tensor ", 7);
            (*(void (**)(void **__return_ptr))(*(void *)*v5 + 48))(__p);
            if (v145 >= 0) {
              char v13 = __p;
            }
            else {
              char v13 = (void **)__p[0];
            }
            if (v145 >= 0) {
              uint64_t v14 = HIBYTE(v145);
            }
            else {
              uint64_t v14 = (uint64_t)__p[1];
            }
            long long v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)v13, v14);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)" has unexpected rank ", 21);
            unint64_t v16 = (void *)std::ostream::operator<<();
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)"; expected ", 11);
            uint64_t v17 = (void *)std::ostream::operator<<();
            LOBYTE(v147[0]) = 46;
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)v147, 1);
            if (SHIBYTE(v145) < 0) {
              operator delete(__p[0]);
            }
            uint64_t LocationPtr = MIL::IRObject::GetLocationPtr((MIL::IRObject *)a2);
            std::string::size_type v19 = *(std::__shared_weak_count **)(LocationPtr + 8);
            unint64_t v162 = *(void **)LocationPtr;
            uint64_t v163 = v19;
            if (v19) {
              atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            std::stringbuf::str();
            MIL::ValidationResult::ValidationResult(a3, &v162, 319, &v170);
            if (SHIBYTE(v172) < 0) {
              operator delete(v170);
            }
            if (v163) {
              std::__shared_weak_count::__release_shared[abi:ne180100](v163);
            }
            v165[0] = v133;
            *(void **)((char *)v165 + *((void *)v133 - 3)) = v130;
            v165[1] = (void *)(MEMORY[0x263F8C318] + 16);
            if (v168 < 0) {
              operator delete(v167);
            }
            std::streambuf::~streambuf();
            std::ostream::~ostream();
            MEMORY[0x21056C620](v169);
            int v11 = 1;
          }
        }
        if (v153)
        {
          uint64_t v154 = v153;
          operator delete(v153);
        }
        if (v11 != 3 && v11) {
          break;
        }
      }
      v5 += 5;
      if (v5 == v6) {
        goto LABEL_32;
      }
    }
  }
  if (MIL::ValidationResult::IsGood(a3))
  {
    MIL::ValidationResult::~ValidationResult(a3);
    std::string::const_iterator v21 = (const MIL::IROperation **)*((void *)this + 1);
    float v20 = (const MIL::IROperation **)*((void *)this + 2);
    if (v21 != v20)
    {
      long long v134 = (void *)*MEMORY[0x263F8C2C8];
      unint64_t v22 = *(void **)(MEMORY[0x263F8C2C8] + 24);
      while (1)
      {
        long long v23 = *v21;
        v147[0] = 0;
        if (!MIL::ValidationResult::IsGood(a3)) {
          goto LABEL_85;
        }
        MIL::ValidationResult::~ValidationResult(a3);
        if (v147[0]) {
          break;
        }
LABEL_68:
        v21 += 6;
        if (v21 == v20) {
          goto LABEL_84;
        }
      }
      if ((v152 & 0x8000000000000000) != 0)
      {
        int v29 = 3;
        goto LABEL_64;
      }
      uint64_t v25 = (uint64_t)v21[5];
      if (v25 < 0 && (v25 += v152, v25 < 0))
      {
        std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v165);
        unint64_t v30 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v165, (uint64_t)"Tensor ", 7);
        (*(void (**)(void **__return_ptr))(*(void *)*v21 + 48))(__p);
        if (v145 >= 0) {
          unint64_t v31 = __p;
        }
        else {
          unint64_t v31 = (void **)__p[0];
        }
        if (v145 >= 0) {
          uint64_t v32 = HIBYTE(v145);
        }
        else {
          uint64_t v32 = (uint64_t)__p[1];
        }
        uint64_t v33 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v30, (uint64_t)v31, v32);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v33, (uint64_t)" has a constraint on dimension ", 31);
        long long v34 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v34, (uint64_t)", which is out of bounds for given tensor of rank ", 50);
        std::string v35 = (void *)std::ostream::operator<<();
        LOBYTE(v140[0]) = 46;
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v35, (uint64_t)v140, 1);
        if (SHIBYTE(v145) < 0) {
          operator delete(__p[0]);
        }
        uint64_t v36 = MIL::IRObject::GetLocationPtr((MIL::IRObject *)a2);
        std::string v37 = *(std::__shared_weak_count **)(v36 + 8);
        unint64_t v159 = *(_anonymous_namespace_::TensorSymbolicShapeConstraintsImpl **)v36;
        v160 = v37;
        if (v37) {
          atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        std::stringbuf::str();
        MIL::ValidationResult::ValidationResult(a3, &v159, 319, &v170);
        if (SHIBYTE(v172) < 0) {
          operator delete(v170);
        }
        std::string v38 = v160;
        if (!v160) {
          goto LABEL_61;
        }
      }
      else
      {
        if (v25 >= (unint64_t)((v154 - (unsigned char *)v153) >> 3)) {
          std::vector<MIL::IRDimension const*>::__throw_out_of_range[abi:ne180100]();
        }
        uint64_t v26 = (*(uint64_t (**)(void))(**((void **)v153 + v25) + 16))(*((void *)v153 + v25));
        if (!v26
          || (v140[0] = 0,
              v140[0] = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v26 + 48))(v26),
              v165[0] = v21 + 2,
              __p[0] = v140,
              long long v27 = std::__hash_table<std::__hash_value_type<std::string,long long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,long long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,long long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,long long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<long long &>>((uint64_t)v138, (unsigned __int8 *)v21 + 16, (uint64_t)&std::piecewise_construct, (long long **)v165, (void **)__p), v28)|| *((void **)v27 + 5) == v140[0])
        {
          int v29 = 0;
          goto LABEL_64;
        }
        std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v165);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v165, (uint64_t)"Dimension ", 10);
        std::string v39 = (void *)std::ostream::operator<<();
        std::string v40 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v39, (uint64_t)" of tensor ", 11);
        (*(void (**)(void **__return_ptr))(*(void *)*v21 + 48))(__p);
        if (v145 >= 0) {
          std::string v41 = __p;
        }
        else {
          std::string v41 = (void **)__p[0];
        }
        if (v145 >= 0) {
          uint64_t v42 = HIBYTE(v145);
        }
        else {
          uint64_t v42 = (uint64_t)__p[1];
        }
        uint64_t v43 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v40, (uint64_t)v41, v42);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v43, (uint64_t)" has unexpected length ", 23);
        unint64_t v44 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v44, (uint64_t)"; expected ", 11);
        unint64_t v45 = (void *)std::ostream::operator<<();
        LOBYTE(v149) = 46;
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v45, (uint64_t)&v149, 1);
        if (SHIBYTE(v145) < 0) {
          operator delete(__p[0]);
        }
        uint64_t v46 = MIL::IRObject::GetLocationPtr((MIL::IRObject *)a2);
        unint64_t v47 = *(std::__shared_weak_count **)(v46 + 8);
        unint64_t v156 = *(void **)v46;
        uint64_t v157 = v47;
        if (v47) {
          atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        std::stringbuf::str();
        MIL::ValidationResult::ValidationResult(a3, &v156, 319, &v162);
        if ((char)v164 < 0) {
          operator delete(v162);
        }
        std::string v38 = v157;
        if (!v157) {
          goto LABEL_61;
        }
      }
      std::__shared_weak_count::__release_shared[abi:ne180100](v38);
LABEL_61:
      v165[0] = v134;
      *(void **)((char *)v165 + *((void *)v134 - 3)) = v22;
      v165[1] = (void *)(MEMORY[0x263F8C318] + 16);
      if (v168 < 0) {
        operator delete(v167);
      }
      std::streambuf::~streambuf();
      std::ostream::~ostream();
      MEMORY[0x21056C620](v169);
      int v29 = 1;
LABEL_64:
      if (v153)
      {
        uint64_t v154 = v153;
        operator delete(v153);
      }
      if (v29 != 3 && v29) {
        goto LABEL_85;
      }
      goto LABEL_68;
    }
LABEL_84:
    MIL::ValidationResult::ValidationResult(a3);
LABEL_85:
    if (MIL::ValidationResult::IsGood(a3))
    {
      MIL::ValidationResult::~ValidationResult(a3);
      uint64_t v48 = (const MIL::IROperation **)*((void *)this + 4);
      int v49 = (const MIL::IROperation **)*((void *)this + 5);
      if (v48 != v49)
      {
        uint64_t v131 = *(void **)(MEMORY[0x263F8C2C8] + 24);
        unint64_t v132 = (void *)*MEMORY[0x263F8C2C8];
        while (1)
        {
          std::string::size_type v50 = *v48;
          uint64_t v155 = 0;
          if (!MIL::ValidationResult::IsGood(a3)) {
            goto LABEL_242;
          }
          MIL::ValidationResult::~ValidationResult(a3);
          if (v155) {
            break;
          }
LABEL_212:
          v48 += 7;
          if (v48 == v49) {
            goto LABEL_241;
          }
        }
        if ((v152 & 0x8000000000000000) != 0)
        {
          int v63 = 3;
          goto LABEL_208;
        }
        unint64_t v52 = (unint64_t)v48[5];
        std::string v53 = (char *)v48[6] + v152;
        uint64_t v151 = (uint64_t)&v53[-v52 + 1];
        if ((uint64_t)&v53[-v52] <= -2)
        {
          std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v165);
          uint64_t v54 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v165, (uint64_t)"Tensor ", 7);
          (*(void (**)(void **__return_ptr))(*(void *)*v48 + 48))(__p);
          if (v145 >= 0) {
            uint64_t v55 = __p;
          }
          else {
            uint64_t v55 = (void **)__p[0];
          }
          if (v145 >= 0) {
            uint64_t v56 = HIBYTE(v145);
          }
          else {
            uint64_t v56 = (uint64_t)__p[1];
          }
          std::string::size_type v57 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v54, (uint64_t)v55, v56);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v57, (uint64_t)" has a constraint on dimension [", 32);
          uint64_t v58 = (void *)std::ostream::operator<<();
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v58, (uint64_t)", ", 2);
          unint64_t v59 = (void *)std::ostream::operator<<();
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v59, (uint64_t)"] which is out of bounds for given tensor of rank ", 50);
          uint64_t v60 = (void *)std::ostream::operator<<();
          LOBYTE(v170) = 46;
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v60, (uint64_t)&v170, 1);
          if (SHIBYTE(v145) < 0) {
            operator delete(__p[0]);
          }
          uint64_t v61 = (uint64_t *)MIL::IRObject::GetLocationPtr((MIL::IRObject *)a2);
          int v62 = (std::__shared_weak_count *)v61[1];
          uint64_t v149 = *v61;
          uint64_t v150 = v62;
          if (v62) {
            atomic_fetch_add_explicit(&v62->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          std::stringbuf::str();
          MIL::ValidationResult::ValidationResult(a3, &v149, 319, v147);
          if (v148 < 0) {
            operator delete(v147[0]);
          }
          if (v150) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v150);
          }
          v165[0] = v132;
          *(void **)((char *)v165 + *((void *)v132 - 3)) = v131;
          v165[1] = (void *)(MEMORY[0x263F8C318] + 16);
          if (v168 < 0) {
            operator delete(v167);
          }
          std::streambuf::~streambuf();
          std::ostream::~ostream();
          MEMORY[0x21056C620](v169);
          int v63 = 1;
          goto LABEL_208;
        }
        v165[0] = 0;
        v165[1] = 0;
        v166[0] = 0;
        std::vector<unsigned long long>::reserve(v165, (unint64_t)&v53[-v52 + 1]);
        if ((uint64_t)v53 < (uint64_t)v52)
        {
          int v64 = 0;
LABEL_151:
          *(_OWORD *)std::string __p = *(_OWORD *)v165;
          uint64_t v145 = v166[0];
          char v146 = v64;
          if (v64)
          {
            int v63 = 3;
            goto LABEL_206;
          }
          uint64_t v86 = *v48;
          uint64_t v87 = MIL::IRObject::GetLocationPtr((MIL::IRObject *)a2);
          v165[0] = v48 + 2;
          v170 = __p;
          int v88 = std::__hash_table<std::__hash_value_type<std::string,std::vector<long long>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<long long>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<long long>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<long long>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<std::vector<long long>&>>((uint64_t)v136, (unsigned __int8 *)v48 + 16, (uint64_t)&std::piecewise_construct, (long long **)v165, (uint64_t *)&v170);
          if (v89)
          {
            MIL::ValidationResult::ValidationResult(a3);
          }
          else
          {
            v170 = 0;
            int64_t v171 = 0;
            uint64_t v172 = 0;
            std::vector<long long>::__init_with_size[abi:ne180100]<long long *,long long *>(&v170, *((const void **)v88 + 5), *((void *)v88 + 6), (uint64_t)(*((void *)v88 + 6) - *((void *)v88 + 5)) >> 3);
            uint64_t v90 = v170;
            unint64_t v91 = (void **)v171 - v170;
            unint64_t v92 = (uint64_t *)__p[0];
            if (v91 == ((char *)__p[1] - (char *)__p[0]) >> 3)
            {
              if (v171 != v170)
              {
                if (v91 <= 1) {
                  unint64_t v91 = 1;
                }
                do
                {
                  uint64_t v93 = *v90;
                  uint64_t v95 = (void *)*v92++;
                  unint64_t v94 = v95;
                  if (*v90 == (void *)-1)
                  {
                    uint64_t v93 = v94;
                  }
                  else if (v93 != v94)
                  {
                    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v165);
                    long long v115 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v165, (uint64_t)"Variadic dimension in tensor ", 29);
                    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)v86 + 48))(&v162, v86);
                    if ((v164 & 0x80u) == 0) {
                      uint64_t v116 = &v162;
                    }
                    else {
                      uint64_t v116 = v162;
                    }
                    if ((v164 & 0x80u) == 0) {
                      uint64_t v117 = v164;
                    }
                    else {
                      uint64_t v117 = (uint64_t)v163;
                    }
                    uint64_t v118 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v115, (uint64_t)v116, v117);
                    unint64_t v119 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v118, (uint64_t)" has unexpected shape ", 22);
                    if ((v161 & 0x80u) == 0) {
                      uint64_t v120 = &v159;
                    }
                    else {
                      uint64_t v120 = v159;
                    }
                    if ((v161 & 0x80u) == 0) {
                      uint64_t v121 = v161;
                    }
                    else {
                      uint64_t v121 = (uint64_t)v160;
                    }
                    unint64_t v122 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v119, (uint64_t)v120, v121);
                    uint64_t v123 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v122, (uint64_t)"; expected ",
                             11);
                    if ((v158 & 0x80u) == 0) {
                      long long v124 = &v156;
                    }
                    else {
                      long long v124 = v156;
                    }
                    if ((v158 & 0x80u) == 0) {
                      uint64_t v125 = v158;
                    }
                    else {
                      uint64_t v125 = (uint64_t)v157;
                    }
                    uint64_t v126 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v123, (uint64_t)v124, v125);
                    v173[0] = 46;
                    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v126, (uint64_t)v173, 1);
                    if ((char)v158 < 0) {
                      operator delete(v156);
                    }
                    if ((char)v161 < 0) {
                      operator delete(v159);
                    }
                    if ((char)v164 < 0) {
                      operator delete(v162);
                    }
                    unint64_t v127 = *(std::__shared_weak_count **)(v87 + 8);
                    unint64_t v159 = *(_anonymous_namespace_::TensorSymbolicShapeConstraintsImpl **)v87;
                    v160 = v127;
                    if (v127) {
                      atomic_fetch_add_explicit(&v127->__shared_owners_, 1uLL, memory_order_relaxed);
                    }
                    goto LABEL_175;
                  }
                  *v90++ = v93;
                  --v91;
                }
                while (v91);
              }
              MIL::ValidationResult::ValidationResult(a3);
            }
            else
            {
              std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v165);
              int v96 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v165, (uint64_t)"Variadic dimension in tensor ", 29);
              (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)v86 + 48))(&v162, v86);
              if ((v164 & 0x80u) == 0) {
                uint64_t v97 = &v162;
              }
              else {
                uint64_t v97 = v162;
              }
              if ((v164 & 0x80u) == 0) {
                uint64_t v98 = v164;
              }
              else {
                uint64_t v98 = (uint64_t)v163;
              }
              int64_t v99 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v96, (uint64_t)v97, v98);
              std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v99, (uint64_t)" has unexpected length ", 23);
              v100 = (void *)std::ostream::operator<<();
              std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v100, (uint64_t)"; expected ",
                11);
              int64_t v101 = (void *)std::ostream::operator<<();
              LOBYTE(v159) = 46;
              std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v101, (uint64_t)&v159, 1);
              if ((char)v164 < 0) {
                operator delete(v162);
              }
              uint64_t v102 = *(std::__shared_weak_count **)(v87 + 8);
              unint64_t v159 = *(_anonymous_namespace_::TensorSymbolicShapeConstraintsImpl **)v87;
              v160 = v102;
              if (v102) {
                atomic_fetch_add_explicit(&v102->__shared_owners_, 1uLL, memory_order_relaxed);
              }
LABEL_175:
              std::stringbuf::str();
              MIL::ValidationResult::ValidationResult(a3, &v159, 319, &v162);
              if ((char)v164 < 0) {
                operator delete(v162);
              }
              if (v160) {
                std::__shared_weak_count::__release_shared[abi:ne180100](v160);
              }
              v165[0] = v132;
              *(void **)((char *)v165 + *((void *)v132 - 3)) = v131;
              v165[1] = (void *)(MEMORY[0x263F8C318] + 16);
              if (v168 < 0) {
                operator delete(v167);
              }
              std::streambuf::~streambuf();
              std::ostream::~ostream();
              MEMORY[0x21056C620](v169);
            }
            if (v170)
            {
              int64_t v171 = v170;
              operator delete(v170);
            }
          }
          if (MIL::ValidationResult::IsGood(a3))
          {
            MIL::ValidationResult::~ValidationResult(a3);
            v165[0] = v48 + 2;
            v170 = (void **)&v151;
            unint64_t v103 = std::__hash_table<std::__hash_value_type<std::string,long long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,long long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,long long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,long long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<long long &>>((uint64_t)v138, (unsigned __int8 *)v48 + 16, (uint64_t)&std::piecewise_construct, (long long **)v165, &v170);
            if (v104 || *((void *)v103 + 5) == v151)
            {
              int v63 = 0;
              goto LABEL_206;
            }
            std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v165);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v165, (uint64_t)"Variadic dimension at [", 23);
            uint64_t v105 = (void *)std::ostream::operator<<();
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v105, (uint64_t)", ", 2);
            unint64_t v106 = (void *)std::ostream::operator<<();
            uint64_t v107 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v106, (uint64_t)"] of tensor ", 12);
            (*(void (**)(void ***__return_ptr))(*(void *)*v48 + 48))(&v170);
            if (v172 >= 0) {
              uint64_t v108 = &v170;
            }
            else {
              uint64_t v108 = (void **)v170;
            }
            if (v172 >= 0) {
              uint64_t v109 = HIBYTE(v172);
            }
            else {
              uint64_t v109 = (uint64_t)v171;
            }
            unint64_t v110 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v107, (uint64_t)v108, v109);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v110, (uint64_t)" have unexpected length ", 24);
            uint64_t v111 = (void *)std::ostream::operator<<();
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v111, (uint64_t)"; expected ", 11);
            v112 = (void *)std::ostream::operator<<();
            LOBYTE(v162) = 46;
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v112, (uint64_t)&v162, 1);
            if (SHIBYTE(v172) < 0) {
              operator delete(v170);
            }
            long long v113 = (uint64_t *)MIL::IRObject::GetLocationPtr((MIL::IRObject *)a2);
            unint64_t v114 = (std::__shared_weak_count *)v113[1];
            uint64_t v142 = *v113;
            long long v143 = v114;
            if (v114) {
              atomic_fetch_add_explicit(&v114->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            std::stringbuf::str();
            MIL::ValidationResult::ValidationResult(a3, &v142, 319, v140);
            if (v141 < 0) {
              operator delete(v140[0]);
            }
            if (v143) {
              std::__shared_weak_count::__release_shared[abi:ne180100](v143);
            }
            v165[0] = v132;
            *(void **)((char *)v165 + *((void *)v132 - 3)) = v131;
            v165[1] = (void *)(MEMORY[0x263F8C318] + 16);
            if (v168 < 0) {
              operator delete(v167);
            }
            std::streambuf::~streambuf();
            std::ostream::~ostream();
            MEMORY[0x21056C620](v169);
          }
          int v63 = 1;
LABEL_206:
          if (__p[0])
          {
            __p[1] = __p[0];
            operator delete(__p[0]);
          }
LABEL_208:
          if (v153)
          {
            uint64_t v154 = v153;
            operator delete(v153);
          }
          if (v63 != 3 && v63) {
            goto LABEL_242;
          }
          goto LABEL_212;
        }
        int v64 = 0;
        while (1)
        {
          if (v52 >= (v154 - (unsigned char *)v153) >> 3) {
            std::vector<MIL::IRDimension const*>::__throw_out_of_range[abi:ne180100]();
          }
          uint64_t v65 = *((void *)v153 + v52);
          if (((*(uint64_t (**)(uint64_t))(*(void *)v65 + 32))(v65) & 1) == 0) {
            break;
          }
          int v64 = 1;
LABEL_149:
          if (v52++ == (void)v53) {
            goto LABEL_151;
          }
        }
        uint64_t v66 = (*(uint64_t (**)(uint64_t))(*(void *)v65 + 16))(v65);
        if (v66)
        {
          uint64_t v67 = (*(uint64_t (**)(uint64_t))(*(void *)v66 + 48))(v66);
          uint64_t v68 = v67;
          std::string v69 = (char *)v165[1];
          if (v165[1] < (void *)v166[0])
          {
            *(void *)v165[1] = v67;
            char v70 = v69 + 8;
LABEL_121:
            uint64_t v72 = v70;
LABEL_148:
            v165[1] = v72;
            goto LABEL_149;
          }
          std::string v73 = (char *)v165[0];
          int64_t v74 = ((char *)v165[1] - (char *)v165[0]) >> 3;
          unint64_t v75 = v74 + 1;
          if ((unint64_t)(v74 + 1) >> 61) {
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          }
          int64_t v76 = v166[0] - (unint64_t)v165[0];
          if ((uint64_t)(v166[0] - (unint64_t)v165[0]) >> 2 > v75) {
            unint64_t v75 = v76 >> 2;
          }
          if ((unint64_t)v76 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v77 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v77 = v75;
          }
          if (v77)
          {
            char v78 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)v166, v77);
            std::string v73 = (char *)v165[0];
            std::string v69 = (char *)v165[1];
          }
          else
          {
            char v78 = 0;
          }
          char v82 = &v78[8 * v74];
          *(void *)char v82 = v68;
          uint64_t v72 = v82 + 8;
          while (v69 != v73)
          {
            uint64_t v83 = *((void *)v69 - 1);
            v69 -= 8;
            *((void *)v82 - 1) = v83;
            v82 -= 8;
          }
        }
        else
        {
          uint64_t v71 = (char *)v165[1];
          if (v165[1] < (void *)v166[0])
          {
            *(void *)v165[1] = -1;
            char v70 = v71 + 8;
            goto LABEL_121;
          }
          std::string v73 = (char *)v165[0];
          int64_t v79 = ((char *)v165[1] - (char *)v165[0]) >> 3;
          unint64_t v80 = v79 + 1;
          if ((unint64_t)(v79 + 1) >> 61) {
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          }
          int64_t v81 = v166[0] - (unint64_t)v165[0];
          if ((uint64_t)(v166[0] - (unint64_t)v165[0]) >> 2 > v80) {
            unint64_t v80 = v81 >> 2;
          }
          if ((unint64_t)v81 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v77 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v77 = v80;
          }
          if (v77)
          {
            char v78 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)v166, v77);
            std::string v73 = (char *)v165[0];
            uint64_t v71 = (char *)v165[1];
          }
          else
          {
            char v78 = 0;
          }
          char v82 = &v78[8 * v79];
          *(void *)char v82 = -1;
          uint64_t v72 = v82 + 8;
          while (v71 != v73)
          {
            uint64_t v84 = *((void *)v71 - 1);
            v71 -= 8;
            *((void *)v82 - 1) = v84;
            v82 -= 8;
          }
        }
        v165[0] = v82;
        v165[1] = v72;
        v166[0] = &v78[8 * v77];
        if (v73) {
          operator delete(v73);
        }
        goto LABEL_148;
      }
LABEL_241:
      MIL::ValidationResult::ValidationResult(a3);
LABEL_242:
      if (MIL::ValidationResult::IsGood(a3))
      {
        MIL::ValidationResult::~ValidationResult(a3);
        MIL::ValidationResult::ValidationResult(v128);
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>>>::~__hash_table((uint64_t)v136);
  return std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v138);
}

void sub_20F4A869C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,void *a42,uint64_t a43,uint64_t a44,uint64_t a45,void *a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,uint64_t a51,void *__p,uint64_t a53,int a54,__int16 a55,char a56,char a57,uint64_t a58)
{
  if (a57 < 0) {
    operator delete(__p);
  }
  if (a50) {
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)a50);
  }
  std::ostringstream::~ostringstream((uint64_t)&a58);
  uint64_t v60 = *(void **)(v58 - 120);
  if (v60)
  {
    *(void *)(v58 - 112) = v60;
    operator delete(v60);
  }
  if (a31)
  {
    a32 = (uint64_t)a31;
    operator delete(a31);
  }
  if (a42)
  {
    a43 = (uint64_t)a42;
    operator delete(a42);
  }
  std::__hash_table<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>>>::~__hash_table((uint64_t)&a15);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&a21);
  _Unwind_Resume(a1);
}

uint64_t anonymous namespace'::TensorSymbolicShapeConstraintsImpl::AddDimension(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4)
{
  uint64_t v5 = a3;
  return std::vector<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long>>::emplace_back<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long &>((uint64_t *)(a1 + 8), a2, a4, &v5);
}

uint64_t anonymous namespace'::TensorSymbolicShapeConstraintsImpl::AddDimension(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, long long *a5)
{
  uint64_t v7 = a4;
  uint64_t v8 = a3;
  if (a3 < 0)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "startIndex must be non-negative.");
    goto LABEL_6;
  }
  if ((a4 & 0x8000000000000000) == 0)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "endIndex must be negative.");
LABEL_6:
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  return std::vector<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long,long long>>::emplace_back<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long &,long long &>((uint64_t *)(a1 + 32), a2, a5, &v8, &v7);
}

void sub_20F4A8A60(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t anonymous namespace'::TensorSymbolicShapeConstraintsImpl::AddRank(uint64_t a1, uint64_t a2, long long *a3)
{
  return std::vector<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>::emplace_back<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>((uint64_t *)(a1 + 56), a2, a3);
}

void std::vector<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long,long long>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 56;
        std::allocator<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>::destroy[abi:ne180100]((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 48;
        std::allocator<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>::destroy[abi:ne180100]((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *anonymous namespace'::TensorSymbolicShapeConstraintsImpl::GetRankAndShape@<X0>(_anonymous_namespace_::TensorSymbolicShapeConstraintsImpl *this@<X0>, const MIL::IRValueType *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v5 = (MIL::IRTensorValueType *)(*(uint64_t (**)(_anonymous_namespace_::TensorSymbolicShapeConstraintsImpl *, const MIL::IRValueType *))(*(void *)this + 24))(this, a2);
  if (v5)
  {
    uint64_t v6 = v5;
    Ranunint64_t k = MIL::IRTensorValueType::Rank(v5);
    uint64_t Shape = (*(uint64_t (**)(MIL::IRTensorValueType *))(*(void *)v6 + 96))(v6);
LABEL_7:
    *a3 = Rank;
LABEL_8:
    a3[2] = 0;
    a3[3] = 0;
    a3[1] = 0;
    long long v15 = *(const void **)Shape;
    uint64_t v16 = *(void *)(Shape + 8);
    unint64_t v17 = (v16 - *(void *)Shape) >> 3;
    unint64_t v18 = a3 + 1;
    goto LABEL_9;
  }
  long long v9 = MIL::IRValueType::TryCastAsMemoryLayoutType(this);
  char v10 = (MIL::IRPixelBufferValueType *)MIL::IRMemoryLayoutValueType::TryAsPixelBufferType(v9);
  if (v10)
  {
    int v11 = v10;
    Ranunint64_t k = MIL::IRPixelBufferValueType::GetRank(v10);
    uint64_t Shape = MIL::IRPixelBufferValueType::GetShape(v11);
    goto LABEL_7;
  }
  uint64_t v12 = MIL::IRValueType::TryCastAsMemoryLayoutType(this);
  char v13 = (MIL::IRTensorBufferValueType *)MIL::IRMemoryLayoutValueType::TryAsTensorBufferType(v12);
  if (v13)
  {
    uint64_t v14 = v13;
    Ranunint64_t k = MIL::IRTensorBufferValueType::GetRank(v13);
    uint64_t Shape = MIL::IRTensorBufferValueType::GetShape(v14);
    goto LABEL_7;
  }
  float v20 = MIL::IRValueType::TryCastAsMemoryLayoutType(this);
  std::string::const_iterator v21 = (MIL::IRCircularBufferValueType *)MIL::IRMemoryLayoutValueType::TryAsCircularBufferType(v20);
  if (v21)
  {
    unint64_t v22 = v21;
    uint64_t v23 = MIL::IRCircularBufferValueType::GetRank(v21);
    uint64_t Shape = MIL::IRCircularBufferValueType::GetShape(v22);
    *a3 = v23;
    goto LABEL_8;
  }
  *a3 = -1;
  a3[2] = 0;
  a3[3] = 0;
  a3[1] = 0;
  unint64_t v18 = a3 + 1;
  long long v15 = 0;
  uint64_t v16 = 0;
  unint64_t v17 = 0;
LABEL_9:

  return std::vector<MIL::IRDimension const*>::__init_with_size[abi:ne180100]<MIL::IRDimension const**,MIL::IRDimension const**>(v18, v15, v16, v17);
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,long long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,long long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,long long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,long long>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<long long &>>(uint64_t a1, unsigned __int8 *a2, uint64_t a3, long long **a4, void **a5)
{
  char v10 = (void *)(a1 + 24);
  unint64_t v11 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  unint64_t v12 = v11;
  unint64_t v13 = *(void *)(a1 + 8);
  if (v13)
  {
    uint8x8_t v14 = (uint8x8_t)vcnt_s8((int8x8_t)v13);
    v14.i16[0] = vaddlv_u8(v14);
    unint64_t v15 = v14.u32[0];
    if (v14.u32[0] > 1uLL)
    {
      unint64_t v5 = v11;
      if (v11 >= v13) {
        unint64_t v5 = v11 % v13;
      }
    }
    else
    {
      unint64_t v5 = (v13 - 1) & v11;
    }
    uint64_t v16 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v5);
    if (v16)
    {
      for (uint64_t i = *v16; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v18 = *((void *)i + 1);
        if (v18 == v12)
        {
          if (std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2)) {
            return i;
          }
        }
        else
        {
          if (v15 > 1)
          {
            if (v18 >= v13) {
              v18 %= v13;
            }
          }
          else
          {
            v18 &= v13 - 1;
          }
          if (v18 != v5) {
            break;
          }
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,long long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,long long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,long long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,long long>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<long long &>>(a1, v12, a4, a5, (uint64_t)v28);
  float v19 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v20 = *(float *)(a1 + 32);
  if (!v13 || (float)(v20 * (float)v13) < v19)
  {
    BOOL v21 = 1;
    if (v13 >= 3) {
      BOOL v21 = (v13 & (v13 - 1)) != 0;
    }
    unint64_t v22 = v21 | (2 * v13);
    unint64_t v23 = vcvtps_u32_f32(v19 / v20);
    if (v22 <= v23) {
      size_t v24 = v23;
    }
    else {
      size_t v24 = v22;
    }
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v24);
    unint64_t v13 = *(void *)(a1 + 8);
    if ((v13 & (v13 - 1)) != 0)
    {
      if (v12 >= v13) {
        unint64_t v5 = v12 % v13;
      }
      else {
        unint64_t v5 = v12;
      }
    }
    else
    {
      unint64_t v5 = (v13 - 1) & v12;
    }
  }
  uint64_t v25 = *(void **)(*(void *)a1 + 8 * v5);
  if (v25)
  {
    *(void *)v28[0] = *v25;
    void *v25 = v28[0];
  }
  else
  {
    *(void *)v28[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v28[0];
    *(void *)(*(void *)a1 + 8 * v5) = a1 + 16;
    if (*(void *)v28[0])
    {
      unint64_t v26 = *(void *)(*(void *)v28[0] + 8);
      if ((v13 & (v13 - 1)) != 0)
      {
        if (v26 >= v13) {
          v26 %= v13;
        }
      }
      else
      {
        v26 &= v13 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v26) = v28[0];
    }
  }
  uint64_t i = (unsigned __int8 *)v28[0];
  ++*v10;
  return i;
}

void sub_20F4A8F78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void **__p, uint64_t a13)
{
  if (__p) {
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:ne180100]((uint64_t)&a13, __p);
  }
  _Unwind_Resume(exception_object);
}

void std::__hash_table<std::__hash_value_type<std::string,long long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,long long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,long long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,long long>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<long long &>>(uint64_t a1@<X0>, uint64_t a2@<X1>, long long **a3@<X3>, void **a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v9 = a1 + 16;
  char v10 = operator new(0x30uLL);
  *(void *)a5 = v10;
  *(void *)(a5 + 8) = v9;
  *(unsigned char *)(a5 + 16) = 0;
  *char v10 = 0;
  v10[1] = a2;
  unint64_t v11 = (std::string *)(v10 + 2);
  unint64_t v12 = *a3;
  unint64_t v13 = *a4;
  if (*((char *)*a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v11, *(const std::string::value_type **)v12, *((void *)v12 + 1));
  }
  else
  {
    long long v14 = *v12;
    v10[4] = *((void *)v12 + 2);
    *(_OWORD *)&v11->__r_.__value_.__l.__data_ = v14;
  }
  void v10[5] = *v13;
  *(unsigned char *)(a5 + 16) = 1;
}

void sub_20F4A9040(_Unwind_Exception *a1)
{
  void *v1 = 0;
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

uint64_t anonymous namespace'::FormatShape(void *a1)
{
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v4);
  char v7 = 91;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)&v7, 1);
  if (a1[1] != *a1)
  {
    unint64_t v2 = 0;
    do
    {
      if (v2) {
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)", ", 2);
      }
      std::ostream::operator<<();
      ++v2;
    }
    while (v2 < (uint64_t)(a1[1] - *a1) >> 3);
  }
  char v7 = 93;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)&v7, 1);
  std::stringbuf::str();
  v4[0] = *MEMORY[0x263F8C2C8];
  *(void *)((char *)v4 + *(void *)(v4[0] - 24)) = *(void *)(MEMORY[0x263F8C2C8] + 24);
  v4[1] = MEMORY[0x263F8C318] + 16;
  if (v5 < 0) {
    operator delete((void *)v4[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x21056C620](&v6);
}

void sub_20F4A920C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::vector<long long>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<long long>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<long long>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<long long>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<std::vector<long long>&>>(uint64_t a1, unsigned __int8 *a2, uint64_t a3, long long **a4, uint64_t *a5)
{
  char v10 = (void *)(a1 + 24);
  unint64_t v11 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  unint64_t v12 = v11;
  unint64_t v13 = *(void *)(a1 + 8);
  if (v13)
  {
    uint8x8_t v14 = (uint8x8_t)vcnt_s8((int8x8_t)v13);
    v14.i16[0] = vaddlv_u8(v14);
    unint64_t v15 = v14.u32[0];
    if (v14.u32[0] > 1uLL)
    {
      unint64_t v5 = v11;
      if (v11 >= v13) {
        unint64_t v5 = v11 % v13;
      }
    }
    else
    {
      unint64_t v5 = (v13 - 1) & v11;
    }
    uint64_t v16 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v5);
    if (v16)
    {
      for (uint64_t i = *v16; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v18 = *((void *)i + 1);
        if (v18 == v12)
        {
          if (std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2)) {
            return i;
          }
        }
        else
        {
          if (v15 > 1)
          {
            if (v18 >= v13) {
              v18 %= v13;
            }
          }
          else
          {
            v18 &= v13 - 1;
          }
          if (v18 != v5) {
            break;
          }
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,std::vector<long long>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<long long>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<long long>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<long long>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<std::vector<long long>&>>(a1, v12, a4, a5, (uint64_t)v28);
  float v19 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v20 = *(float *)(a1 + 32);
  if (!v13 || (float)(v20 * (float)v13) < v19)
  {
    BOOL v21 = 1;
    if (v13 >= 3) {
      BOOL v21 = (v13 & (v13 - 1)) != 0;
    }
    unint64_t v22 = v21 | (2 * v13);
    unint64_t v23 = vcvtps_u32_f32(v19 / v20);
    if (v22 <= v23) {
      size_t v24 = v23;
    }
    else {
      size_t v24 = v22;
    }
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v24);
    unint64_t v13 = *(void *)(a1 + 8);
    if ((v13 & (v13 - 1)) != 0)
    {
      if (v12 >= v13) {
        unint64_t v5 = v12 % v13;
      }
      else {
        unint64_t v5 = v12;
      }
    }
    else
    {
      unint64_t v5 = (v13 - 1) & v12;
    }
  }
  uint64_t v25 = *(void **)(*(void *)a1 + 8 * v5);
  if (v25)
  {
    *(void *)v28[0] = *v25;
    void *v25 = v28[0];
  }
  else
  {
    *(void *)v28[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v28[0];
    *(void *)(*(void *)a1 + 8 * v5) = a1 + 16;
    if (*(void *)v28[0])
    {
      unint64_t v26 = *(void *)(*(void *)v28[0] + 8);
      if ((v13 & (v13 - 1)) != 0)
      {
        if (v26 >= v13) {
          v26 %= v13;
        }
      }
      else
      {
        v26 &= v13 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v26) = v28[0];
    }
  }
  uint64_t i = (unsigned __int8 *)v28[0];
  v28[0] = 0;
  ++*v10;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,void *>>>>::reset[abi:ne180100]((uint64_t)v28, 0);
  return i;
}

void sub_20F4A94A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

std::string *std::__hash_table<std::__hash_value_type<std::string,std::vector<long long>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<long long>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<long long>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<long long>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<std::vector<long long>&>>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, long long **a3@<X3>, uint64_t *a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v9 = a1 + 16;
  char v10 = (char *)operator new(0x40uLL);
  *(void *)a5 = v10;
  *(void *)(a5 + 8) = v9;
  *(unsigned char *)(a5 + 16) = 0;
  *(void *)char v10 = 0;
  *((void *)v10 + 1) = a2;
  uint64_t result = std::pair<std::string const,std::vector<long long>>::pair[abi:ne180100]<std::string const&,std::vector<long long>&>((std::string *)(v10 + 16), *a3, *a4);
  *(unsigned char *)(a5 + 16) = 1;
  return result;
}

void sub_20F4A9528(_Unwind_Exception *a1)
{
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<MIL::IRDimension const*>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

std::string *std::pair<std::string const,std::vector<long long>>::pair[abi:ne180100]<std::string const&,std::vector<long long>&>(std::string *this, long long *a2, uint64_t a3)
{
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v5 = *a2;
    this->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v5;
  }
  this[1].__r_.__value_.__r.__words[0] = 0;
  this[1].__r_.__value_.__l.__size_ = 0;
  this[1].__r_.__value_.__r.__words[2] = 0;
  std::vector<long long>::__init_with_size[abi:ne180100]<long long *,long long *>(this[1].__r_.__value_.__r.__words, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 3);
  return this;
}

void sub_20F4A95B0(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<long long>::__init_with_size[abi:ne180100]<long long *,long long *>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = std::vector<unsigned long long>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_20F4A962C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long>>::emplace_back<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long &>(uint64_t *a1, uint64_t a2, long long *a3, void *a4)
{
  unint64_t v10 = a1[2];
  size_t v8 = a1 + 2;
  unint64_t v9 = v10;
  unint64_t v11 = *(v8 - 1);
  if (v11 >= v10)
  {
    unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - *a1) >> 4);
    unint64_t v15 = v14 + 1;
    if (v14 + 1 > 0x555555555555555) {
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v9 - *a1) >> 4);
    if (2 * v16 > v15) {
      unint64_t v15 = 2 * v16;
    }
    if (v16 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v17 = 0x555555555555555;
    }
    else {
      unint64_t v17 = v15;
    }
    v22[4] = v8;
    if (v17) {
      unint64_t v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<std::string,std::string>>>((uint64_t)v8, v17);
    }
    else {
      unint64_t v18 = 0;
    }
    float v19 = &v18[48 * v14];
    v22[0] = v18;
    v22[1] = v19;
    v22[3] = &v18[48 * v17];
    *(_OWORD *)float v19 = *(_OWORD *)a2;
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    long long v20 = *a3;
    *((void *)v19 + 4) = *((void *)a3 + 2);
    *((_OWORD *)v19 + 1) = v20;
    *((void *)a3 + 1) = 0;
    *((void *)a3 + 2) = 0;
    *(void *)a3 = 0;
    *((void *)v19 + 5) = *a4;
    v22[2] = v19 + 48;
    std::vector<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long>>::__swap_out_circular_buffer(a1, v22);
    uint64_t v13 = a1[1];
    std::__split_buffer<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long>>::~__split_buffer(v22);
  }
  else
  {
    *(_OWORD *)unint64_t v11 = *(_OWORD *)a2;
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    long long v12 = *a3;
    *(void *)(v11 + 32) = *((void *)a3 + 2);
    *(_OWORD *)(v11 + 16) = v12;
    *((void *)a3 + 1) = 0;
    *((void *)a3 + 2) = 0;
    *(void *)a3 = 0;
    *(void *)(v11 + 40) = *a4;
    uint64_t v13 = v11 + 48;
    a1[1] = v11 + 48;
  }
  a1[1] = v13;
  return v13 - 48;
}

void sub_20F4A97AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long>>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long>*>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long>*>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long>*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long>>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long>*>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long>*>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long>*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = a3 + v7;
      *(_OWORD *)(a7 + v7 - 48) = *(_OWORD *)(a3 + v7 - 48);
      uint64_t v9 = a7 + v7 - 48;
      *(void *)(v8 - 48) = 0;
      *(void *)(v8 - 40) = 0;
      long long v10 = *(_OWORD *)(a3 + v7 - 32);
      *(void *)(v9 + 32) = *(void *)(a3 + v7 - 16);
      *(_OWORD *)(v9 + 16) = v10;
      *(void *)(v8 - 24) = 0;
      *(void *)(v8 - 16) = 0;
      *(void *)(v8 - 32) = 0;
      *(void *)(v9 + 40) = *(void *)(a3 + v7 - 8);
      *((void *)&v16 + 1) = v9;
      v7 -= 48;
    }
    while (a3 + v7 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long>>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long>>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long>>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long>*>>::operator()[abi:ne180100]((uint64_t *)a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long>>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long>*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v1 = *(void *)(a1[2] + 8);
  uint64_t v2 = *(void *)(a1[1] + 8);
  if (v1 != v2)
  {
    uint64_t v3 = *a1;
    do
    {
      std::allocator<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>::destroy[abi:ne180100](v3, v1);
      v1 += 48;
    }
    while (v1 != v2);
  }
}

void **std::__split_buffer<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long>>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void std::__split_buffer<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long>>::clear[abi:ne180100](void *a1)
{
  uint64_t v2 = a1[1];
  for (uint64_t i = a1[2]; i != v2; uint64_t i = a1[2])
  {
    uint64_t v4 = a1[4];
    a1[2] = i - 48;
    std::allocator<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>::destroy[abi:ne180100](v4, i - 48);
  }
}

uint64_t std::vector<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long,long long>>::emplace_back<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long &,long long &>(uint64_t *a1, uint64_t a2, long long *a3, void *a4, void *a5)
{
  unint64_t v12 = a1[2];
  long long v10 = a1 + 2;
  unint64_t v11 = v12;
  unint64_t v13 = *(v10 - 1);
  if (v13 >= v12)
  {
    uint64_t v16 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v13 - *a1) >> 3);
    unint64_t v17 = v16 + 1;
    if ((unint64_t)(v16 + 1) > 0x492492492492492) {
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v18 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v11 - *a1) >> 3);
    if (2 * v18 > v17) {
      unint64_t v17 = 2 * v18;
    }
    if (v18 >= 0x249249249249249) {
      unint64_t v19 = 0x492492492492492;
    }
    else {
      unint64_t v19 = v17;
    }
    v24[4] = v10;
    if (v19) {
      long long v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long,long long>>>((uint64_t)v10, v19);
    }
    else {
      long long v20 = 0;
    }
    BOOL v21 = &v20[56 * v16];
    v24[0] = v20;
    v24[1] = v21;
    v24[3] = &v20[56 * v19];
    *(_OWORD *)BOOL v21 = *(_OWORD *)a2;
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    long long v22 = *a3;
    *((void *)v21 + 4) = *((void *)a3 + 2);
    *((_OWORD *)v21 + 1) = v22;
    *((void *)a3 + 1) = 0;
    *((void *)a3 + 2) = 0;
    *(void *)a3 = 0;
    *((void *)v21 + 5) = *a4;
    *((void *)v21 + 6) = *a5;
    v24[2] = v21 + 56;
    std::vector<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long,long long>>::__swap_out_circular_buffer(a1, v24);
    uint64_t v15 = a1[1];
    std::__split_buffer<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long,long long>>::~__split_buffer(v24);
  }
  else
  {
    *(_OWORD *)unint64_t v13 = *(_OWORD *)a2;
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    long long v14 = *a3;
    *(void *)(v13 + 32) = *((void *)a3 + 2);
    *(_OWORD *)(v13 + 16) = v14;
    *((void *)a3 + 1) = 0;
    *((void *)a3 + 2) = 0;
    *(void *)a3 = 0;
    *(void *)(v13 + 40) = *a4;
    *(void *)(v13 + 48) = *a5;
    uint64_t v15 = v13 + 56;
    a1[1] = v13 + 56;
  }
  a1[1] = v15;
  return v15 - 56;
}

void sub_20F4A9B90(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long,long long>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long,long long>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long,long long>>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long,long long>*>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long,long long>*>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long,long long>*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long,long long>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x492492492492493) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(56 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long,long long>>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long,long long>*>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long,long long>*>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long,long long>*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = a3 + v7;
      *(_OWORD *)(a7 + v7 - 56) = *(_OWORD *)(a3 + v7 - 56);
      uint64_t v9 = a7 + v7 - 56;
      *(void *)(v8 - 56) = 0;
      *(void *)(v8 - 48) = 0;
      long long v10 = *(_OWORD *)(a3 + v7 - 40);
      *(void *)(v9 + 32) = *(void *)(a3 + v7 - 24);
      *(_OWORD *)(v9 + 16) = v10;
      *(void *)(v8 - 32) = 0;
      *(void *)(v8 - 24) = 0;
      *(void *)(v8 - 40) = 0;
      *(void *)(v9 + 40) = *(void *)(a3 + v7 - 16);
      *(void *)(v9 + 48) = *(void *)(a3 + v7 - 8);
      *((void *)&v16 + 1) = v9;
      v7 -= 56;
    }
    while (a3 + v7 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long,long long>>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long,long long>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long,long long>>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long,long long>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long,long long>>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long,long long>*>>::operator()[abi:ne180100]((uint64_t *)a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long,long long>>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long,long long>*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v1 = *(void *)(a1[2] + 8);
  uint64_t v2 = *(void *)(a1[1] + 8);
  if (v1 != v2)
  {
    uint64_t v3 = *a1;
    do
    {
      std::allocator<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>::destroy[abi:ne180100](v3, v1);
      v1 += 56;
    }
    while (v1 != v2);
  }
}

void **std::__split_buffer<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long,long long>>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void std::__split_buffer<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string,long long,long long>>::clear[abi:ne180100](void *a1)
{
  uint64_t v2 = a1[1];
  for (uint64_t i = a1[2]; i != v2; uint64_t i = a1[2])
  {
    uint64_t v4 = a1[4];
    a1[2] = i - 56;
    std::allocator<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>::destroy[abi:ne180100](v4, i - 56);
  }
}

uint64_t std::vector<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>::emplace_back<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>(uint64_t *a1, uint64_t a2, long long *a3)
{
  unint64_t v8 = a1[2];
  uint64_t v6 = a1 + 2;
  unint64_t v7 = v8;
  unint64_t v9 = *(v6 - 1);
  if (v9 >= v8)
  {
    unint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v9 - *a1) >> 3);
    unint64_t v13 = v12 + 1;
    if (v12 + 1 > 0x666666666666666) {
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v14 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v7 - *a1) >> 3);
    if (2 * v14 > v13) {
      unint64_t v13 = 2 * v14;
    }
    if (v14 >= 0x333333333333333) {
      unint64_t v15 = 0x666666666666666;
    }
    else {
      unint64_t v15 = v13;
    }
    v20[4] = v6;
    if (v15) {
      long long v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<char const*,MIL::Transform::ArgumentDescription>>>((uint64_t)v6, v15);
    }
    else {
      long long v16 = 0;
    }
    unint64_t v17 = &v16[40 * v12];
    v20[0] = v16;
    v20[1] = v17;
    v20[3] = &v16[40 * v15];
    *(_OWORD *)unint64_t v17 = *(_OWORD *)a2;
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    long long v18 = *a3;
    *((void *)v17 + 4) = *((void *)a3 + 2);
    *((_OWORD *)v17 + 1) = v18;
    *((void *)a3 + 1) = 0;
    *((void *)a3 + 2) = 0;
    *(void *)a3 = 0;
    v20[2] = v17 + 40;
    std::vector<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>::__swap_out_circular_buffer(a1, v20);
    uint64_t v11 = a1[1];
    std::__split_buffer<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>::~__split_buffer(v20);
  }
  else
  {
    *(_OWORD *)unint64_t v9 = *(_OWORD *)a2;
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    long long v10 = *a3;
    *(void *)(v9 + 32) = *((void *)a3 + 2);
    *(_OWORD *)(v9 + 16) = v10;
    *((void *)a3 + 1) = 0;
    *((void *)a3 + 2) = 0;
    *(void *)a3 = 0;
    uint64_t v11 = v9 + 40;
    a1[1] = v9 + 40;
  }
  a1[1] = v11;
  return v11 - 40;
}

void sub_20F4A9F80(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>*>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>*>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>*>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>*>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = a7 - 40;
    do
    {
      long long v9 = *(_OWORD *)(a3 - 40);
      a3 -= 40;
      *(_OWORD *)uint64_t v8 = v9;
      *(void *)a3 = 0;
      *(void *)(a3 + 8) = 0;
      long long v10 = *(_OWORD *)(a3 + 16);
      *(void *)(v8 + 32) = *(void *)(a3 + 32);
      *(_OWORD *)(v8 + 16) = v10;
      *(void *)(a3 + 24) = 0;
      *(void *)(a3 + 32) = 0;
      *(void *)(a3 + 16) = 0;
      *((void *)&v16 + 1) = v8;
      v8 -= 40;
      v7 -= 40;
    }
    while (a3 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>,std::reverse_iterator<std::tuple<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>>,std::reverse_iterator<std::pair<std::shared_ptr<MIL::Validation::ConstraintTarget const>,std::string>*>>::operator()[abi:ne180100]((uint64_t *)a1);
  }
  return a1;
}

void *MIL::Validation::ConstraintTarget::ConstraintTarget(void *this)
{
  *this = &unk_26C25D7F0;
  return this;
}

void *MIL::Validation::OpParameterConstraintTarget::OpParameterConstraintTarget(void *this)
{
  *this = &unk_26C25D838;
  return this;
}

void MIL::Validation::OpParameterConstraintTarget::Make()
{
}

{
  operator new();
}

void *MIL::Validation::OpOutputConstraintTarget::OpOutputConstraintTarget(void *this)
{
  *this = &unk_26C25D880;
  return this;
}

void MIL::Validation::OpOutputConstraintTarget::Make(MIL::Validation::OpOutputConstraintTarget *this)
{
}

void *MIL::Validation::OpAttributeConstraintTarget::OpAttributeConstraintTarget(void *this)
{
  *this = &unk_26C25D8C8;
  return this;
}

void MIL::Validation::OpAttributeConstraintTarget::Make()
{
}

void anonymous namespace'::OpParameterConstraintTargetImpl::~OpParameterConstraintTargetImpl(void **this)
{
  *this = &unk_26C25D968;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_26C25D968;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x21056C700);
}

uint64_t anonymous namespace'::OpParameterConstraintTargetImpl::IsOptional(_anonymous_namespace_::OpParameterConstraintTargetImpl *this)
{
  return *((unsigned __int8 *)this + 36);
}

uint64_t anonymous namespace'::OpParameterConstraintTargetImpl::TryGetType(_anonymous_namespace_::OpParameterConstraintTargetImpl *this, const MIL::IROperation *a2)
{
  (*(void (**)(uint64_t *__return_ptr))(*(void *)this + 40))(&v7);
  if (v7) {
    Parameteruint64_t Type = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 32))(v7);
  }
  else {
    Parameteruint64_t Type = MIL::IROperation::TryGetParameterType(a2, (uint64_t)this + 8, *((unsigned int *)this + 8));
  }
  uint64_t v5 = ParameterType;
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  }
  return v5;
}

void sub_20F4AA52C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t anonymous namespace'::OpParameterConstraintTargetImpl::TryGetValue(_anonymous_namespace_::OpParameterConstraintTargetImpl *this, const MIL::IROperation *a2)
{
  return MIL::IROperation::TryGetParameterValue(a2, (uint64_t)this + 8, *((unsigned int *)this + 8));
}

void anonymous namespace'::OpParameterConstraintTargetImpl::TryGetValueSharedPtr(_anonymous_namespace_::OpParameterConstraintTargetImpl *this@<X0>, const MIL::IROperation *a2@<X1>, uint64_t *a3@<X8>)
{
}

void anonymous namespace'::OpParameterConstraintTargetImpl::ToString(_anonymous_namespace_::OpParameterConstraintTargetImpl *this@<X0>, std::string *a2@<X8>)
{
  std::operator+<char>();
  std::string::push_back(&v9, 91);
  std::string v10 = v9;
  memset(&v9, 0, sizeof(v9));
  std::to_string(&__p, *((_DWORD *)this + 8));
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  uint64_t v6 = std::string::append(&v10, (const std::string::value_type *)p_p, size);
  long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  v11.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v11.__r_.__value_.__l.__data_ = v7;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  std::string::push_back(&v11, 93);
  *a2 = v11;
  memset(&v11, 0, sizeof(v11));
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v9.__r_.__value_.__l.__data_);
  }
}

void sub_20F4AA66C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (*(char *)(v26 - 25) < 0) {
    operator delete(*(void **)(v26 - 48));
  }
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::OpOutputConstraintTargetImpl::~OpOutputConstraintTargetImpl(_anonymous_namespace_::OpOutputConstraintTargetImpl *this)
{
}

uint64_t anonymous namespace'::OpOutputConstraintTargetImpl::IsOptional(_anonymous_namespace_::OpOutputConstraintTargetImpl *this)
{
  return *((unsigned __int8 *)this + 16);
}

uint64_t anonymous namespace'::OpOutputConstraintTargetImpl::TryGetType(_anonymous_namespace_::OpOutputConstraintTargetImpl *this, const MIL::IROperation *a2)
{
  (*(void (**)(uint64_t *__return_ptr))(*(void *)this + 40))(&v7);
  if (v7) {
    Outputuint64_t Type = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 32))(v7);
  }
  else {
    Outputuint64_t Type = MIL::IROperation::TryGetOutputType(a2, *((void *)this + 1));
  }
  uint64_t v5 = OutputType;
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  }
  return v5;
}

void sub_20F4AA794(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t anonymous namespace'::OpOutputConstraintTargetImpl::TryGetValue(_anonymous_namespace_::OpOutputConstraintTargetImpl *this, const MIL::IROperation *a2)
{
  (*(void (**)(uint64_t *__return_ptr))(*(void *)this + 40))(&v4);
  if (!v5) {
    return v4;
  }
  if (v5->__shared_owners_) {
    uint64_t v2 = v4;
  }
  else {
    uint64_t v2 = 0;
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  return v2;
}

void anonymous namespace'::OpOutputConstraintTargetImpl::TryGetValueSharedPtr(_anonymous_namespace_::OpOutputConstraintTargetImpl *this@<X0>, const MIL::IROperation *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = (*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 64))(a2);
  if ((*(unsigned int (**)(uint64_t))(*(void *)v6 + 104))(v6))
  {
    uint64_t v7 = (*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 64))(a2);
    (*(void (**)(void *__return_ptr))(*(void *)v7 + 248))(v9);
    long long v8 = *(_OWORD *)(v9[0] + 16 * *((void *)this + 1));
    *(_OWORD *)a3 = v8;
    if (*((void *)&v8 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v8 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    std::string v10 = (void **)v9;
    std::vector<std::shared_ptr<MIL::IRBlock>>::__destroy_vector::operator()[abi:ne180100](&v10);
  }
  else
  {
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
  }
}

void anonymous namespace'::OpOutputConstraintTargetImpl::ToString(_anonymous_namespace_::OpOutputConstraintTargetImpl *this@<X0>, std::string *a2@<X8>)
{
  std::to_string(&v4, *((void *)this + 1));
  uint64_t v3 = std::string::insert(&v4, 0, "output at index ");
  *a2 = *v3;
  v3->__r_.__value_.__l.__size_ = 0;
  v3->__r_.__value_.__r.__words[2] = 0;
  v3->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v4.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v4.__r_.__value_.__l.__data_);
  }
}

void sub_20F4AA9A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::OpAttributeConstraintTargetImpl::~OpAttributeConstraintTargetImpl(void **this)
{
  *this = &unk_26C25DA28;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_26C25DA28;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x21056C700);
}

uint64_t anonymous namespace'::OpAttributeConstraintTargetImpl::IsOptional(_anonymous_namespace_::OpAttributeConstraintTargetImpl *this)
{
  return *((unsigned __int8 *)this + 32);
}

uint64_t anonymous namespace'::OpAttributeConstraintTargetImpl::TryGetType(_anonymous_namespace_::OpAttributeConstraintTargetImpl *this, const MIL::IROperation *a2)
{
  (*(void (**)(uint64_t *__return_ptr))(*(void *)this + 40))(&v7);
  if (v7) {
    Parameteruint64_t Type = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 32))(v7);
  }
  else {
    Parameteruint64_t Type = MIL::IROperation::TryGetParameterType(a2, (uint64_t)this + 8, 0);
  }
  uint64_t v5 = ParameterType;
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  }
  return v5;
}

void sub_20F4AAB34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t anonymous namespace'::OpAttributeConstraintTargetImpl::TryGetValue(_anonymous_namespace_::OpAttributeConstraintTargetImpl *this, const MIL::IROperation *a2)
{
  return MIL::IRObject::TryGetAttribute((uint64_t)a2, (unsigned __int8 *)this + 8);
}

unsigned __int8 *anonymous namespace'::OpAttributeConstraintTargetImpl::TryGetValueSharedPtr@<X0>(_anonymous_namespace_::OpAttributeConstraintTargetImpl *this@<X0>, const MIL::IROperation *a2@<X1>, void *a3@<X8>)
{
  return MIL::IRObject::TryGetAttributeSharedPtr((uint64_t)a2, (unsigned __int8 *)this + 8, a3);
}

uint64_t anonymous namespace'::OpAttributeConstraintTargetImpl::ToString(_anonymous_namespace_::OpAttributeConstraintTargetImpl *this)
{
  return std::operator+<char>();
}

void MIL::Validation::VerifyInputTensorDimAtGivenAxis(MIL::IRObject *a1@<X0>, uint64_t a2@<X2>, unint64_t a3@<X3>, MIL::ValidationResult *a4@<X8>)
{
  Parameteruint64_t Type = (MIL::IRValueType *)MIL::IROperation::GetParameterType(a1);
  uint64_t v9 = MIL::IRValueType::AsTensorType(ParameterType);
  if (v9
    && (std::string v10 = (MIL::IRTensorValueType *)v9, (*(unsigned int (**)(uint64_t))(*(void *)v9 + 104))(v9))
    && (unint64_t v11 = (MIL::IRTensorValueType::Rank(v10) & (a2 >> 63)) + a2,
        unint64_t v12 = (void *)(*(uint64_t (**)(MIL::IRTensorValueType *))(*(void *)v10 + 96))(v10),
        v11 < (uint64_t)(v12[1] - *v12) >> 3)
    && (unint64_t v13 = v12, (v14 = *(void *)(*v12 + 8 * v11)) != 0)
    && (*(uint64_t (**)(uint64_t))(*(void *)v14 + 16))(v14)
    && (uint64_t v15 = (*(uint64_t (**)(void))(**(void **)(*v13 + 8 * v11) + 16))(*(void *)(*v13 + 8 * v11)),
        uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)v15 + 48))(v15),
        v16 != a3))
  {
    unint64_t v17 = v16;
    std::operator+<char>();
    long long v18 = std::string::append(&v48, "', the value of dimension at axis ");
    long long v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
    v49.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v49.__r_.__value_.__l.__data_ = v19;
    v18->__r_.__value_.__l.__size_ = 0;
    v18->__r_.__value_.__r.__words[2] = 0;
    v18->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v47, a2);
    if ((v47.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      long long v20 = &v47;
    }
    else {
      long long v20 = (std::string *)v47.__r_.__value_.__r.__words[0];
    }
    if ((v47.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v47.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v47.__r_.__value_.__l.__size_;
    }
    long long v22 = std::string::append(&v49, (const std::string::value_type *)v20, size);
    long long v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
    v50.__r_.__value_.__r.__words[2] = v22->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v50.__r_.__value_.__l.__data_ = v23;
    v22->__r_.__value_.__l.__size_ = 0;
    v22->__r_.__value_.__r.__words[2] = 0;
    v22->__r_.__value_.__r.__words[0] = 0;
    size_t v24 = std::string::append(&v50, " must be ");
    long long v25 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
    v51.__r_.__value_.__r.__words[2] = v24->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v51.__r_.__value_.__l.__data_ = v25;
    v24->__r_.__value_.__l.__size_ = 0;
    v24->__r_.__value_.__r.__words[2] = 0;
    v24->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v46, a3);
    if ((v46.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v26 = &v46;
    }
    else {
      uint64_t v26 = (std::string *)v46.__r_.__value_.__r.__words[0];
    }
    if ((v46.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v27 = HIBYTE(v46.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v27 = v46.__r_.__value_.__l.__size_;
    }
    char v28 = std::string::append(&v51, (const std::string::value_type *)v26, v27);
    long long v29 = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
    v52.__r_.__value_.__r.__words[2] = v28->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v29;
    v28->__r_.__value_.__l.__size_ = 0;
    v28->__r_.__value_.__r.__words[2] = 0;
    v28->__r_.__value_.__r.__words[0] = 0;
    unint64_t v30 = std::string::append(&v52, " but it is ");
    long long v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
    v53.__r_.__value_.__r.__words[2] = v30->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v31;
    v30->__r_.__value_.__l.__size_ = 0;
    v30->__r_.__value_.__r.__words[2] = 0;
    v30->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v45, v17);
    if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v32 = &v45;
    }
    else {
      uint64_t v32 = (std::string *)v45.__r_.__value_.__r.__words[0];
    }
    if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v33 = HIBYTE(v45.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v33 = v45.__r_.__value_.__l.__size_;
    }
    long long v34 = std::string::append(&v53, (const std::string::value_type *)v32, v33);
    long long v35 = *(_OWORD *)&v34->__r_.__value_.__l.__data_;
    v54.__r_.__value_.__r.__words[2] = v34->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v54.__r_.__value_.__l.__data_ = v35;
    v34->__r_.__value_.__l.__size_ = 0;
    v34->__r_.__value_.__r.__words[2] = 0;
    v34->__r_.__value_.__r.__words[0] = 0;
    uint64_t v36 = std::string::append(&v54, " instead");
    std::string v37 = (std::string::value_type *)v36->__r_.__value_.__r.__words[0];
    std::string::size_type v38 = v36->__r_.__value_.__l.__size_;
    v55[0] = v36->__r_.__value_.__r.__words[2];
    *(_DWORD *)((char *)v55 + 3) = *(_DWORD *)((char *)&v36->__r_.__value_.__r.__words[2] + 3);
    int v39 = SHIBYTE(v36->__r_.__value_.__r.__words[2]);
    v36->__r_.__value_.__l.__size_ = 0;
    v36->__r_.__value_.__r.__words[2] = 0;
    v36->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v54.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v45.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v53.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v52.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v46.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v51.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v50.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v47.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v49.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v48.__r_.__value_.__l.__data_);
    }
    uint64_t LocationPtr = (uint64_t *)MIL::IRObject::GetLocationPtr(a1);
    std::string v41 = (std::__shared_weak_count *)LocationPtr[1];
    uint64_t v43 = *LocationPtr;
    unint64_t v44 = v41;
    if (v41) {
      atomic_fetch_add_explicit(&v41->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v39 < 0)
    {
      std::string::__init_copy_ctor_external(&v42, v37, v38);
    }
    else
    {
      v42.__r_.__value_.__r.__words[0] = (std::string::size_type)v37;
      v42.__r_.__value_.__l.__size_ = v38;
      LODWORD(v42.__r_.__value_.__r.__words[2]) = v55[0];
      *(_DWORD *)((char *)&v42.__r_.__value_.__r.__words[2] + 3) = *(_DWORD *)((char *)v55 + 3);
      *((unsigned char *)&v42.__r_.__value_.__s + 23) = v39;
    }
    MIL::ValidationResult::ValidationResult(a4, &v43, 315, &v42);
    if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v42.__r_.__value_.__l.__data_);
    }
    if (v44) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v44);
    }
    if (v39 < 0) {
      operator delete(v37);
    }
  }
  else
  {
    MIL::ValidationResult::ValidationResult(a4);
  }
}

void sub_20F4AAFD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,int a38,__int16 a39,char a40,char a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47,uint64_t a48,void *a49,uint64_t a50,int a51,__int16 a52,char a53,char a54)
{
  if (a17) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a17);
  }
  if (v55 < 0) {
    operator delete(v54);
  }
  _Unwind_Resume(exception_object);
}

void sub_20F4AB0F4()
{
}

void sub_20F4AB0FC()
{
}

void MIL::Validation::VerifyOutputShapeMatchesInput(MIL::IRObject *a1@<X0>, MIL::ValidationResult *a2@<X8>)
{
  Parameteruint64_t Type = MIL::IROperation::GetParameterType(a1);
  uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)ParameterType + 24))(ParameterType);
  Outputuint64_t Type = MIL::IROperation::GetOutputType(a1, 0);
  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)OutputType + 24))(OutputType);
  if (v5) {
    BOOL v8 = v7 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8)
  {
    uint64_t LocationPtr = (uint64_t *)MIL::IRObject::GetLocationPtr(a1);
    std::string v10 = (std::__shared_weak_count *)LocationPtr[1];
    uint64_t v29 = *LocationPtr;
    unint64_t v30 = v10;
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    std::operator+<char>();
    unint64_t v11 = std::string::append(&v26, " and output must both be tensors");
    long long v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    std::string::size_type v28 = v11->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = v12;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    v11->__r_.__value_.__r.__words[0] = 0;
    MIL::ValidationResult::ValidationResult(a2, &v29, 313, __p);
    if (SHIBYTE(v28) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v26.__r_.__value_.__l.__data_);
    }
    unint64_t v13 = v30;
    if (v30) {
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v14 = v7;
    uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 96))(v5);
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 96))(v14);
    size_t v17 = *(void *)(v15 + 8) - *(void *)v15;
    if (v17 != *(void *)(v16 + 8) - *(void *)v16 || memcmp(*(const void **)v15, *(const void **)v16, v17))
    {
      long long v18 = (uint64_t *)MIL::IRObject::GetLocationPtr(a1);
      long long v19 = (std::__shared_weak_count *)v18[1];
      uint64_t v24 = *v18;
      long long v25 = v19;
      if (v19) {
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      std::operator+<char>();
      long long v20 = std::string::append(&v26, " shape should match output shape");
      long long v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
      std::string::size_type v23 = v20->__r_.__value_.__r.__words[2];
      *(_OWORD *)long long v22 = v21;
      v20->__r_.__value_.__l.__size_ = 0;
      v20->__r_.__value_.__r.__words[2] = 0;
      v20->__r_.__value_.__r.__words[0] = 0;
      MIL::ValidationResult::ValidationResult(a2, &v24, 313, v22);
      if (SHIBYTE(v23) < 0) {
        operator delete(v22[0]);
      }
      if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v26.__r_.__value_.__l.__data_);
      }
      unint64_t v13 = v25;
      if (!v25) {
        return;
      }
LABEL_13:
      std::__shared_weak_count::__release_shared[abi:ne180100](v13);
      return;
    }
    MIL::ValidationResult::ValidationResult(a2);
  }
}

void sub_20F4AB390(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, std::__shared_weak_count *a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a16);
  }
  _Unwind_Resume(exception_object);
}

BOOL MIL::Validation::TypeShapeAndDataTypeMatch(MIL::Validation *this, const MIL::IRValueType *a2, const MIL::IRValueType *a3)
{
  if (this == a2) {
    return 1;
  }
  if (MIL::IRValueType::TryCastAsMemoryLayoutType(this) || MIL::IRValueType::TryCastAsMemoryLayoutType(a2))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "TypeShapeAndDataTypeMatch currently only supports tensors.");
    __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
  }
  uint64_t v5 = (*(uint64_t (**)(MIL::Validation *))(*(void *)this + 24))(this);
  uint64_t v6 = (*(uint64_t (**)(const MIL::IRValueType *))(*(void *)a2 + 24))(a2);
  if (v5) {
    BOOL v7 = v6 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7) {
    return 0;
  }
  uint64_t v8 = v6;
  uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 96))(v5);
  uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 96))(v8);
  size_t v11 = *(void *)(v9 + 8) - *(void *)v9;
  if (v11 != *(void *)(v10 + 8) - *(void *)v10 || memcmp(*(const void **)v9, *(const void **)v10, v11)) {
    return 0;
  }
  int v13 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 88))(v5);
  return v13 == (*(unsigned int (**)(uint64_t))(*(void *)v8 + 88))(v8);
}

void sub_20F4AB5E0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void MIL::Validation::VerifyDimSizeIsNumChannels(MIL::IRValueType *a1@<X0>, MIL::IRValueType *a2@<X1>, uint64_t a3@<X2>, MIL::IRObject *a4@<X4>, int a5@<W5>, MIL::ValidationResult *a6@<X8>)
{
  uint64_t v11 = MIL::IRValueType::AsTensorType(a1);
  uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 96))(v11);
  int64_t v79 = 0;
  uint64_t v80 = 0;
  char v78 = 0;
  std::vector<MIL::IRDimension const*>::__init_with_size[abi:ne180100]<MIL::IRDimension const**,MIL::IRDimension const**>(&v78, *(const void **)v12, *(void *)(v12 + 8), (uint64_t)(*(void *)(v12 + 8) - *(void *)v12) >> 3);
  if ((unint64_t)(v79 - v78) <= 0x17)
  {
    uint64_t LocationPtr = (uint64_t *)MIL::IRObject::GetLocationPtr(a4);
    uint64_t v14 = (std::__shared_weak_count *)LocationPtr[1];
    uint64_t v76 = *LocationPtr;
    unint64_t v77 = v14;
    if (v14) {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    std::operator+<char>();
    uint64_t v15 = std::string::append(&v73, " should be at least rank 3");
    long long v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
    std::string::size_type v75 = v15->__r_.__value_.__r.__words[2];
    long long v74 = v16;
    v15->__r_.__value_.__l.__size_ = 0;
    v15->__r_.__value_.__r.__words[2] = 0;
    v15->__r_.__value_.__r.__words[0] = 0;
    MIL::ValidationResult::ValidationResult(a6, &v76, 315, &v74);
    if (SHIBYTE(v75) < 0) {
      operator delete((void *)v74);
    }
    if (SHIBYTE(v73.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v73.__r_.__value_.__l.__data_);
    }
    if (v77) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v77);
    }
    goto LABEL_26;
  }
  uint64_t v17 = MIL::IRValueType::AsTensorType(a2);
  uint64_t v18 = (*(uint64_t (**)(uint64_t))(*(void *)v17 + 96))(v17);
  memset(&v73, 0, sizeof(v73));
  std::vector<MIL::IRDimension const*>::__init_with_size[abi:ne180100]<MIL::IRDimension const**,MIL::IRDimension const**>(&v73, *(const void **)v18, *(void *)(v18 + 8), (uint64_t)(*(void *)(v18 + 8) - *(void *)v18) >> 3);
  if (v73.__r_.__value_.__l.__size_ - v73.__r_.__value_.__r.__words[0] == 8)
  {
    uint64_t v19 = (*(uint64_t (**)(void))(**(void **)v73.__r_.__value_.__l.__data_ + 16))();
    if (v19)
    {
      uint64_t v20 = (*(uint64_t (**)(void *))(**((void **)v78 + 1) + 16))(*((void **)v78 + 1));
      uint64_t v21 = v20;
      if (!v20) {
        goto LABEL_15;
      }
      if (!(*(uint64_t (**)(uint64_t))(*(void *)v20 + 48))(v20)) {
        goto LABEL_15;
      }
      uint64_t v22 = (*(uint64_t (**)(uint64_t))(*(void *)v21 + 48))(v21);
      if (v22 == (*(uint64_t (**)(uint64_t))(*(void *)v19 + 48))(v19)) {
        goto LABEL_15;
      }
      if (a5)
      {
        if ((*(uint64_t (**)(uint64_t))(*(void *)v19 + 48))(v19) == 1)
        {
LABEL_15:
          MIL::ValidationResult::ValidationResult(a6);
          goto LABEL_24;
        }
        uint64_t v32 = (uint64_t *)MIL::IRObject::GetLocationPtr(a4);
        std::string::size_type v33 = (std::__shared_weak_count *)v32[1];
        uint64_t v62 = *v32;
        int v63 = v33;
        if (v33) {
          atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        std::operator+<char>();
        long long v34 = std::string::append(&v58, "' shape: dimension 0 should be either 1 or equal ");
        long long v35 = *(_OWORD *)&v34->__r_.__value_.__l.__data_;
        v59.__r_.__value_.__r.__words[2] = v34->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v59.__r_.__value_.__l.__data_ = v35;
        v34->__r_.__value_.__l.__size_ = 0;
        v34->__r_.__value_.__r.__words[2] = 0;
        v34->__r_.__value_.__r.__words[0] = 0;
        uint64_t v36 = std::string::append(&v59, "to the size of the number of channels (the size of dimension 1) of input ");
        long long v37 = *(_OWORD *)&v36->__r_.__value_.__l.__data_;
        v68.__r_.__value_.__r.__words[2] = v36->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v68.__r_.__value_.__l.__data_ = v37;
        v36->__r_.__value_.__l.__size_ = 0;
        v36->__r_.__value_.__r.__words[2] = 0;
        v36->__r_.__value_.__r.__words[0] = 0;
        int v38 = *(char *)(a3 + 23);
        if (v38 >= 0) {
          int v39 = (const std::string::value_type *)a3;
        }
        else {
          int v39 = *(const std::string::value_type **)a3;
        }
        if (v38 >= 0) {
          std::string::size_type v40 = *(unsigned __int8 *)(a3 + 23);
        }
        else {
          std::string::size_type v40 = *(void *)(a3 + 8);
        }
        std::string v41 = std::string::append(&v68, v39, v40);
        long long v42 = *(_OWORD *)&v41->__r_.__value_.__l.__data_;
        std::string::size_type v61 = v41->__r_.__value_.__r.__words[2];
        *(_OWORD *)uint64_t v60 = v42;
        v41->__r_.__value_.__l.__size_ = 0;
        v41->__r_.__value_.__r.__words[2] = 0;
        v41->__r_.__value_.__r.__words[0] = 0;
        MIL::ValidationResult::ValidationResult(a6, &v62, 315, v60);
        if (SHIBYTE(v61) < 0) {
          operator delete(v60[0]);
        }
        if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v68.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v59.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v58.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v58.__r_.__value_.__l.__data_);
        }
        std::string::size_type v27 = v63;
        if (!v63) {
          goto LABEL_24;
        }
      }
      else
      {
        uint64_t v43 = (uint64_t *)MIL::IRObject::GetLocationPtr(a4);
        unint64_t v44 = (std::__shared_weak_count *)v43[1];
        uint64_t v56 = *v43;
        std::string::size_type v57 = v44;
        if (v44) {
          atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        std::operator+<char>();
        std::string v45 = std::string::append(&v58, "' shape: dimension 0 should be equal ");
        long long v46 = *(_OWORD *)&v45->__r_.__value_.__l.__data_;
        v59.__r_.__value_.__r.__words[2] = v45->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v59.__r_.__value_.__l.__data_ = v46;
        v45->__r_.__value_.__l.__size_ = 0;
        v45->__r_.__value_.__r.__words[2] = 0;
        v45->__r_.__value_.__r.__words[0] = 0;
        std::string v47 = std::string::append(&v59, "to the size of the number of channels (the size of dimension 1) of input ");
        long long v48 = *(_OWORD *)&v47->__r_.__value_.__l.__data_;
        v68.__r_.__value_.__r.__words[2] = v47->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v68.__r_.__value_.__l.__data_ = v48;
        v47->__r_.__value_.__l.__size_ = 0;
        v47->__r_.__value_.__r.__words[2] = 0;
        v47->__r_.__value_.__r.__words[0] = 0;
        int v49 = *(char *)(a3 + 23);
        if (v49 >= 0) {
          std::string v50 = (const std::string::value_type *)a3;
        }
        else {
          std::string v50 = *(const std::string::value_type **)a3;
        }
        if (v49 >= 0) {
          std::string::size_type v51 = *(unsigned __int8 *)(a3 + 23);
        }
        else {
          std::string::size_type v51 = *(void *)(a3 + 8);
        }
        std::string v52 = std::string::append(&v68, v50, v51);
        long long v53 = *(_OWORD *)&v52->__r_.__value_.__l.__data_;
        std::string::size_type v55 = v52->__r_.__value_.__r.__words[2];
        *(_OWORD *)std::string v54 = v53;
        v52->__r_.__value_.__l.__size_ = 0;
        v52->__r_.__value_.__r.__words[2] = 0;
        v52->__r_.__value_.__r.__words[0] = 0;
        MIL::ValidationResult::ValidationResult(a6, &v56, 315, v54);
        if (SHIBYTE(v55) < 0) {
          operator delete(v54[0]);
        }
        if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v68.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v59.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v58.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v58.__r_.__value_.__l.__data_);
        }
        std::string::size_type v27 = v57;
        if (!v57) {
          goto LABEL_24;
        }
      }
    }
    else
    {
      std::string::size_type v28 = (uint64_t *)MIL::IRObject::GetLocationPtr(a4);
      uint64_t v29 = (std::__shared_weak_count *)v28[1];
      uint64_t v66 = *v28;
      uint64_t v67 = v29;
      if (v29) {
        atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      std::operator+<char>();
      unint64_t v30 = std::string::append(&v68, "' shape: dimension 0 should be known at compilation");
      long long v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
      std::string::size_type v65 = v30->__r_.__value_.__r.__words[2];
      *(_OWORD *)std::string __p = v31;
      v30->__r_.__value_.__l.__size_ = 0;
      v30->__r_.__value_.__r.__words[2] = 0;
      v30->__r_.__value_.__r.__words[0] = 0;
      MIL::ValidationResult::ValidationResult(a6, &v66, 315, __p);
      if (SHIBYTE(v65) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v68.__r_.__value_.__l.__data_);
      }
      std::string::size_type v27 = v67;
      if (!v67) {
        goto LABEL_24;
      }
    }
  }
  else
  {
    std::string::size_type v23 = (uint64_t *)MIL::IRObject::GetLocationPtr(a4);
    uint64_t v24 = (std::__shared_weak_count *)v23[1];
    uint64_t v71 = *v23;
    uint64_t v72 = v24;
    if (v24) {
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    std::operator+<char>();
    long long v25 = std::string::append(&v68, " should be rank 1");
    long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
    std::string::size_type v70 = v25->__r_.__value_.__r.__words[2];
    long long v69 = v26;
    v25->__r_.__value_.__l.__size_ = 0;
    v25->__r_.__value_.__r.__words[2] = 0;
    v25->__r_.__value_.__r.__words[0] = 0;
    MIL::ValidationResult::ValidationResult(a6, &v71, 315, &v69);
    if (SHIBYTE(v70) < 0) {
      operator delete((void *)v69);
    }
    if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v68.__r_.__value_.__l.__data_);
    }
    std::string::size_type v27 = v72;
    if (!v72) {
      goto LABEL_24;
    }
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v27);
LABEL_24:
  if (v73.__r_.__value_.__r.__words[0])
  {
    v73.__r_.__value_.__l.__size_ = v73.__r_.__value_.__r.__words[0];
    operator delete(v73.__r_.__value_.__l.__data_);
  }
LABEL_26:
  if (v78)
  {
    int64_t v79 = v78;
    operator delete(v78);
  }
}

void sub_20F4ABC50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,std::__shared_weak_count *a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44,uint64_t a45,uint64_t a46,uint64_t a47,void *a48,uint64_t a49,int a50,__int16 a51,char a52,char a53)
{
  if (a35 < 0) {
    operator delete(__p);
  }
  if (a53 < 0) {
    operator delete(a48);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  if (a38) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a38);
  }
  std::string::size_type v55 = *(void **)(v53 - 152);
  if (v55)
  {
    *(void *)(v53 - 144) = v55;
    operator delete(v55);
  }
  uint64_t v56 = *(void **)(v53 - 88);
  if (v56)
  {
    *(void *)(v53 - 80) = v56;
    operator delete(v56);
  }
  _Unwind_Resume(exception_object);
}

BOOL MIL::Validation::HasUniqueElementsInAxes(MIL::Validation *this, const MIL::IRTensorValue *a2)
{
  int v2 = (int)a2;
  long long v14 = 0u;
  long long v15 = 0u;
  int v16 = 1065353216;
  std::string v4 = (uint64_t *)MIL::IRValue::AsTensor(this);
  uint64_t Data = MIL::IRTensorValue::GetDataView<int>(v4);
  if (v6)
  {
    BOOL v7 = (int *)Data;
    uint64_t v8 = 4 * v6;
    do
    {
      int v13 = (v2 & (*v7 >> 31)) + *v7;
      std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int>((uint64_t)&v14, &v13, &v13);
      ++v7;
      v8 -= 4;
    }
    while (v8);
  }
  uint64_t v9 = *((void *)&v15 + 1);
  uint64_t v10 = (*(uint64_t (**)(MIL::Validation *))(*(void *)this + 32))(this);
  BOOL v11 = v9 == (*(uint64_t (**)(uint64_t))(*(void *)v10 + 16))(v10);
  std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table((uint64_t)&v14);
  return v11;
}

void sub_20F4ABF20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table((uint64_t)va);
  _Unwind_Resume(a1);
}

BOOL MIL::Validation::IsAxisValidForRank(MIL::Validation *this, int a2)
{
  return (int)this < a2 && -a2 <= (int)this;
}

void MIL::Validation::OpToTypeInferenceParams(MIL::IRObject *a1@<X0>, uint64_t a2@<X1>, MIL::ValidationResult *a3@<X8>)
{
  std::string v4 = (void *)(*(uint64_t (**)(MIL::IRObject *))(*(void *)a1 + 160))(a1);
  uint64_t v5 = (void *)*v4;
  std::string::size_type v27 = v4 + 1;
  if ((void *)*v4 == v4 + 1)
  {
LABEL_24:
    MIL::ValidationResult::ValidationResult(a3);
    return;
  }
  uint64_t v6 = (char *)a1 + 64;
  while ((*((char *)v5 + 55) & 0x80000000) == 0)
  {
    if (!*((unsigned char *)v5 + 55)) {
      goto LABEL_42;
    }
LABEL_7:
    v43.__r_.__value_.__r.__words[0] = (std::string::size_type)(v5 + 4);
    BOOL v7 = std::__hash_table<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a2, (unsigned __int8 *)v5 + 32, (uint64_t)&std::piecewise_construct, (long long **)&v43);
    std::vector<std::shared_ptr<MIL::IRTypedArgument>>::__assign_with_size[abi:ne180100]<std::shared_ptr<MIL::IRTypedArgument> const*,std::shared_ptr<MIL::IRTypedArgument> const*>((uint64_t)(v7 + 40), 0, 0, 0);
    uint64_t v8 = v5[7];
    if (v8 != v5[8])
    {
      uint64_t v9 = (*(uint64_t (**)(void))(**(void **)v8 + 32))();
      if (!v9)
      {
        v43.__r_.__value_.__r.__words[0] = (std::string::size_type)(v5 + 4);
        std::__hash_table<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a2, (unsigned __int8 *)v5 + 32, (uint64_t)&std::piecewise_construct, (long long **)&v43);
        (*(void (**)(uint64_t *__return_ptr))(**(void **)v8 + 48))(&v28);
        MIL::IRTypedArgument::Make();
      }
      uint64_t v10 = v9;
      if (*(char *)(v9 + 23) < 0)
      {
        if (!*(void *)(v9 + 8)) {
          goto LABEL_25;
        }
      }
      else if (!*(unsigned char *)(v9 + 23))
      {
LABEL_25:
        uint64_t LocationPtr = (uint64_t *)MIL::IRObject::GetLocationPtr(a1);
        uint64_t v17 = (std::__shared_weak_count *)LocationPtr[1];
        uint64_t v37 = *LocationPtr;
        int v38 = v17;
        if (v17) {
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        std::string::basic_string[abi:ne180100]<0>(__p, "Operation argument names must be non-empty.");
        MIL::ValidationResult::ValidationResult(a3, &v37, 301, __p);
        if (v36 < 0) {
          operator delete(__p[0]);
        }
        uint64_t v18 = v38;
        if (v38) {
          goto LABEL_30;
        }
        return;
      }
      (*(void (**)(long long *__return_ptr, char *, uint64_t, uint64_t))(*(void *)v6 + 56))(&v34, v6, v9, 1);
      if ((void)v34)
      {
        v43.__r_.__value_.__r.__words[0] = (std::string::size_type)(v5 + 4);
        std::__hash_table<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a2, (unsigned __int8 *)v5 + 32, (uint64_t)&std::piecewise_construct, (long long **)&v43);
        long long v33 = v34;
        long long v34 = 0uLL;
        MIL::IRTypedArgument::Make();
      }
      BOOL v11 = (MIL::IRTypedArgument *)(*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)v6 + 24))(v6, v10, 1);
      if (v11)
      {
        v43.__r_.__value_.__r.__words[0] = (std::string::size_type)(v5 + 4);
        std::__hash_table<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a2, (unsigned __int8 *)v5 + 32, (uint64_t)&std::piecewise_construct, (long long **)&v43);
        MIL::IRTypedArgument::Make(v11, v12);
      }
      uint64_t v19 = (uint64_t *)MIL::IRObject::GetLocationPtr(a1);
      uint64_t v20 = (std::__shared_weak_count *)v19[1];
      uint64_t v31 = *v19;
      uint64_t v32 = v20;
      if (v20) {
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      std::operator+<char>();
      uint64_t v21 = std::string::append(&v43, "' used as operation input.");
      long long v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
      std::string::size_type v30 = v21->__r_.__value_.__r.__words[2];
      *(_OWORD *)uint64_t v29 = v22;
      v21->__r_.__value_.__l.__size_ = 0;
      v21->__r_.__value_.__r.__words[2] = 0;
      v21->__r_.__value_.__r.__words[0] = 0;
      MIL::ValidationResult::ValidationResult(a3, &v31, 305, v29);
      if (SHIBYTE(v30) < 0) {
        operator delete(v29[0]);
      }
      if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v43.__r_.__value_.__l.__data_);
      }
      if (v32) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v32);
      }
      uint64_t v18 = (std::__shared_weak_count *)*((void *)&v34 + 1);
      if (*((void *)&v34 + 1)) {
        goto LABEL_30;
      }
      return;
    }
    int v13 = (void *)v5[1];
    if (v13)
    {
      do
      {
        long long v14 = v13;
        int v13 = (void *)*v13;
      }
      while (v13);
    }
    else
    {
      do
      {
        long long v14 = (void *)v5[2];
        BOOL v15 = *v14 == (void)v5;
        uint64_t v5 = v14;
      }
      while (!v15);
    }
    uint64_t v5 = v14;
    if (v14 == v27) {
      goto LABEL_24;
    }
  }
  if (v5[5]) {
    goto LABEL_7;
  }
LABEL_42:
  std::string::size_type v23 = (uint64_t *)MIL::IRObject::GetLocationPtr(a1);
  uint64_t v24 = (std::__shared_weak_count *)v23[1];
  uint64_t v41 = *v23;
  long long v42 = v24;
  if (v24) {
    atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  std::string::basic_string[abi:ne180100]<0>(v39, "Operation parameter names must be non-empty.");
  MIL::ValidationResult::ValidationResult(a3, &v41, 316, v39);
  if (v40 < 0) {
    operator delete(v39[0]);
  }
  uint64_t v18 = v42;
  if (v42) {
LABEL_30:
  }
    std::__shared_weak_count::__release_shared[abi:ne180100](v18);
}

void sub_20F4AC738(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37)
{
  if (*(char *)(v37 - 145) < 0) {
    operator delete(*(void **)(v37 - 168));
  }
  int v39 = *(std::__shared_weak_count **)(v37 - 136);
  if (v39) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v39);
  }
  _Unwind_Resume(exception_object);
}

BOOL MIL::Validation::IsZeroOutOfRangeForReshape(void *a1, MIL::IRTensorValueType *this)
{
  uint64_t v2 = 4 * a1[1];
  while (v2)
  {
    int v3 = *(_DWORD *)(*a1 - 4 + v2);
    v2 -= 4;
    if (!v3) {
      return MIL::IRTensorValueType::Rank(this) < (v2 + 4) >> 2;
    }
  }
  return 0;
}

BOOL MIL::Validation::VariadicTensorsDTypesMatch(MIL::IRObject *a1, uint64_t a2)
{
  Parameteruint64_t Type = (MIL::IRValueType *)MIL::IROperation::GetParameterType(a1);
  uint64_t v5 = MIL::IRValueType::AsTensorType(ParameterType);
  int v6 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 88))(v5);
  unsigned int v7 = (*(uint64_t (**)(MIL::IRObject *, uint64_t))(*(void *)a1 + 152))(a1, a2);
  if (v7 < 2) {
    return 1;
  }
  unsigned int v9 = v7;
  uint64_t v10 = (MIL::IRValueType *)MIL::IROperation::GetParameterType(a1);
  uint64_t v11 = MIL::IRValueType::AsTensorType(v10);
  if ((*(unsigned int (**)(uint64_t))(*(void *)v11 + 88))(v11) != v6) {
    return 0;
  }
  int v12 = 2;
  do
  {
    unsigned int v13 = v12;
    if (v9 == v12) {
      break;
    }
    long long v14 = (MIL::IRValueType *)MIL::IROperation::GetParameterType(a1);
    uint64_t v15 = MIL::IRValueType::AsTensorType(v14);
    int v16 = (*(uint64_t (**)(uint64_t))(*(void *)v15 + 88))(v15);
    int v12 = v13 + 1;
  }
  while (v16 == v6);
  return v13 >= v9;
}

uint64_t MIL::Validation::IsEqualConstShape(uint64_t *a1, void *a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  if (v3 - *a1 != a2[1] - *a2) {
    return 0;
  }
  if (v3 == v2) {
    return 1;
  }
  unint64_t v6 = 0;
  while (1)
  {
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(v2 + 8 * v6) + 16))(*(void *)(v2 + 8 * v6));
    if (!result) {
      break;
    }
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(*a2 + 8 * v6) + 16))(*(void *)(*a2 + 8 * v6));
    if (!result) {
      break;
    }
    uint64_t v8 = (*(uint64_t (**)(void))(**(void **)(*a1 + 8 * v6) + 16))(*(void *)(*a1 + 8 * v6));
    uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 48))(v8);
    uint64_t v10 = (*(uint64_t (**)(void))(**(void **)(*a2 + 8 * v6) + 16))(*(void *)(*a2 + 8 * v6));
    if (v9 != (*(uint64_t (**)(uint64_t))(*(void *)v10 + 48))(v10)) {
      return 0;
    }
    ++v6;
    uint64_t v2 = *a1;
    if (v6 >= (a1[1] - *a1) >> 3) {
      return 1;
    }
  }
  return result;
}

void MIL::Validation::ValidateBaseArgReductionCommon(MIL::Validation *this@<X0>, MIL::ValidationResult *a2@<X8>)
{
  std::string::basic_string[abi:ne180100]<0>(&v49, "output_dtype");
  BOOL IsParameterSet = MIL::IROperation::IsParameterSet((uint64_t)this, (const void **)&v49.__r_.__value_.__l.__data_);
  BOOL v6 = IsParameterSet;
  if ((SHIBYTE(v49.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (!IsParameterSet) {
      goto LABEL_17;
    }
LABEL_5:
    Outputuint64_t Type = (MIL::IRValueType *)MIL::IROperation::GetOutputType(this, 0);
    uint64_t v8 = MIL::IRValueType::AsTensorType(OutputType);
    int v9 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 88))(v8);
    std::string::basic_string[abi:ne180100]<0>(&v48, "output_dtype");
    Parameteruint64_t Value = (MIL::IRValue *)MIL::IROperation::GetParameterValue(this);
    uint64_t v11 = (const void *)MIL::IRValue::AsTensor(ParameterValue);
    MIL::IRValue::GetScalar<std::string>(v11, &v49);
    if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v48.__r_.__value_.__l.__data_);
    }
    int v12 = MIL::StringToIRDataType((const void **)&v49.__r_.__value_.__l.__data_, 0);
    if (v12 != v9)
    {
      uint64_t LocationPtr = (uint64_t *)MIL::IRObject::GetLocationPtr(this);
      long long v14 = (std::__shared_weak_count *)LocationPtr[1];
      uint64_t v46 = *LocationPtr;
      std::string v47 = v14;
      if (v14) {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      std::string::basic_string[abi:ne180100]<0>(__p, "output_dtype, if set, must match the datatype of the output");
      MIL::ValidationResult::ValidationResult(a2, &v46, 315, __p);
      if (v45 < 0) {
        operator delete(__p[0]);
      }
      if (v47) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v47);
      }
    }
    if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v49.__r_.__value_.__l.__data_);
    }
    if (v12 != v9) {
      return;
    }
    goto LABEL_17;
  }
  operator delete(v49.__r_.__value_.__l.__data_);
  if (v6) {
    goto LABEL_5;
  }
LABEL_17:
  std::string::basic_string[abi:ne180100]<0>(&v49, "axis");
  BOOL v15 = MIL::IROperation::IsParameterSet((uint64_t)this, (const void **)&v49.__r_.__value_.__l.__data_);
  BOOL v16 = v15;
  if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v49.__r_.__value_.__l.__data_);
    if (!v16)
    {
LABEL_28:
      MIL::ValidationResult::ValidationResult(a2);
      return;
    }
  }
  else if (!v15)
  {
    goto LABEL_28;
  }
  std::string::basic_string[abi:ne180100]<0>(&v49, "x");
  Parameteruint64_t Type = (MIL::IRValueType *)MIL::IROperation::GetParameterType(this);
  uint64_t v18 = (MIL::IRTensorValueType *)MIL::IRValueType::AsTensorType(ParameterType);
  if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v49.__r_.__value_.__l.__data_);
  }
  if (((*(uint64_t (**)(MIL::IRTensorValueType *))(*(void *)v18 + 104))(v18) & 1) == 0) {
    goto LABEL_28;
  }
  int v19 = MIL::IRTensorValueType::Rank(v18);
  std::string::basic_string[abi:ne180100]<0>(&v49, "axis");
  uint64_t v20 = (const void *)MIL::IROperation::GetParameterValue(this);
  int v21 = MIL::IRValue::GetScalar<int>(v20);
  if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v49.__r_.__value_.__l.__data_);
  }
  if (v21 < v19 && v21 >= -v19) {
    goto LABEL_28;
  }
  long long v22 = (uint64_t *)MIL::IRObject::GetLocationPtr(this);
  std::string::size_type v23 = (std::__shared_weak_count *)v22[1];
  uint64_t v42 = *v22;
  std::string v43 = v23;
  if (v23) {
    atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(MIL::Validation *))(*(void *)this + 56))(this);
  std::operator+<char>();
  uint64_t v24 = std::string::append(&v38, ", 'axis' must be within range (-x_rank - 1, x_rank) (exclusive). Provided axis: ");
  long long v25 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
  v39.__r_.__value_.__r.__words[2] = v24->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v39.__r_.__value_.__l.__data_ = v25;
  v24->__r_.__value_.__l.__size_ = 0;
  v24->__r_.__value_.__r.__words[2] = 0;
  v24->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v37, v21);
  if ((v37.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    long long v26 = &v37;
  }
  else {
    long long v26 = (std::string *)v37.__r_.__value_.__r.__words[0];
  }
  if ((v37.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v37.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v37.__r_.__value_.__l.__size_;
  }
  uint64_t v28 = std::string::append(&v39, (const std::string::value_type *)v26, size);
  long long v29 = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
  v48.__r_.__value_.__r.__words[2] = v28->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v48.__r_.__value_.__l.__data_ = v29;
  v28->__r_.__value_.__l.__size_ = 0;
  v28->__r_.__value_.__r.__words[2] = 0;
  v28->__r_.__value_.__r.__words[0] = 0;
  std::string::size_type v30 = std::string::append(&v48, "for input with rank: ");
  long long v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
  v49.__r_.__value_.__r.__words[2] = v30->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v49.__r_.__value_.__l.__data_ = v31;
  v30->__r_.__value_.__l.__size_ = 0;
  v30->__r_.__value_.__r.__words[2] = 0;
  v30->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v36, v19);
  if ((v36.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v32 = &v36;
  }
  else {
    uint64_t v32 = (std::string *)v36.__r_.__value_.__r.__words[0];
  }
  if ((v36.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v33 = HIBYTE(v36.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v33 = v36.__r_.__value_.__l.__size_;
  }
  long long v34 = std::string::append(&v49, (const std::string::value_type *)v32, v33);
  long long v35 = *(_OWORD *)&v34->__r_.__value_.__l.__data_;
  std::string::size_type v41 = v34->__r_.__value_.__r.__words[2];
  *(_OWORD *)char v40 = v35;
  v34->__r_.__value_.__l.__size_ = 0;
  v34->__r_.__value_.__r.__words[2] = 0;
  v34->__r_.__value_.__r.__words[0] = 0;
  MIL::ValidationResult::ValidationResult(a2, &v42, 315, v40);
  if (SHIBYTE(v41) < 0) {
    operator delete(v40[0]);
  }
  if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v36.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v49.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v48.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v37.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v39.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v38.__r_.__value_.__l.__data_);
  }
  if (v43) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v43);
  }
}

void sub_20F4AD098(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,std::__shared_weak_count *a42,void *a43,uint64_t a44,int a45,__int16 a46,char a47,char a48)
{
  if (a40 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  if (*(char *)(v48 - 57) < 0) {
    operator delete(*(void **)(v48 - 80));
  }
  if (*(char *)(v48 - 89) < 0) {
    operator delete(*(void **)(v48 - 112));
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  if (a42) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a42);
  }
  _Unwind_Resume(exception_object);
}

void MIL::Validation::GetIntTensorValueCasted(MIL::Validation *this@<X0>, const MIL::IRTensorValue *a2@<X1>, char **a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  uint64_t v5 = (*(uint64_t (**)(MIL::Validation *, const MIL::IRTensorValue *))(*(void *)this + 32))(this, a2);
  switch((*(unsigned int (**)(uint64_t))(*(void *)v5 + 88))(v5))
  {
    case 9u:
      uint64_t Data = MIL::IRTensorValue::GetDataView<signed char>((uint64_t *)this);
      if (v7)
      {
        uint64_t v8 = (char *)Data;
        int v9 = (char *)(Data + v7);
        uint64_t v10 = a3 + 2;
        uint64_t v11 = a3[1];
        do
        {
          int v12 = *v8;
          if ((unint64_t)v11 >= *v10)
          {
            long long v14 = *a3;
            uint64_t v15 = (v11 - *a3) >> 2;
            unint64_t v16 = v15 + 1;
            if ((unint64_t)(v15 + 1) >> 62) {
              std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v17 = *v10 - (void)v14;
            if (v17 >> 1 > v16) {
              unint64_t v16 = v17 >> 1;
            }
            if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v18 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v18 = v16;
            }
            if (v18)
            {
              int v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(a3 + 2), v18);
              long long v14 = *a3;
              uint64_t v11 = a3[1];
            }
            else
            {
              int v19 = 0;
            }
            uint64_t v20 = &v19[4 * v15];
            *(_DWORD *)uint64_t v20 = v12;
            unsigned int v13 = v20 + 4;
            while (v11 != v14)
            {
              int v21 = *((_DWORD *)v11 - 1);
              v11 -= 4;
              *((_DWORD *)v20 - 1) = v21;
              v20 -= 4;
            }
            *a3 = v20;
            a3[1] = v13;
            a3[2] = &v19[4 * v18];
            if (v14) {
              operator delete(v14);
            }
          }
          else
          {
            *(_DWORD *)uint64_t v11 = v12;
            unsigned int v13 = v11 + 4;
          }
          a3[1] = v13;
          ++v8;
          uint64_t v11 = v13;
        }
        while (v8 != v9);
      }
      break;
    case 0xAu:
      uint64_t v70 = MIL::IRTensorValue::GetDataView<short>((uint64_t *)this);
      if (v71)
      {
        uint64_t v72 = (__int16 *)v70;
        std::string v73 = a3 + 2;
        long long v74 = a3[1];
        std::string::size_type v75 = (__int16 *)(v70 + 2 * v71);
        do
        {
          int v76 = *v72;
          if ((unint64_t)v74 >= *v73)
          {
            char v78 = *a3;
            uint64_t v79 = (v74 - *a3) >> 2;
            unint64_t v80 = v79 + 1;
            if ((unint64_t)(v79 + 1) >> 62) {
              std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v81 = *v73 - (void)v78;
            if (v81 >> 1 > v80) {
              unint64_t v80 = v81 >> 1;
            }
            if ((unint64_t)v81 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v82 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v82 = v80;
            }
            if (v82)
            {
              uint64_t v83 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(a3 + 2), v82);
              char v78 = *a3;
              long long v74 = a3[1];
            }
            else
            {
              uint64_t v83 = 0;
            }
            uint64_t v84 = &v83[4 * v79];
            *(_DWORD *)uint64_t v84 = v76;
            unint64_t v77 = v84 + 4;
            while (v74 != v78)
            {
              int v85 = *((_DWORD *)v74 - 1);
              v74 -= 4;
              *((_DWORD *)v84 - 1) = v85;
              v84 -= 4;
            }
            *a3 = v84;
            a3[1] = v77;
            a3[2] = &v83[4 * v82];
            if (v78) {
              operator delete(v78);
            }
          }
          else
          {
            *(_DWORD *)long long v74 = v76;
            unint64_t v77 = v74 + 4;
          }
          a3[1] = v77;
          ++v72;
          long long v74 = v77;
        }
        while (v72 != v75);
      }
      break;
    case 0xBu:
      uint64_t v38 = MIL::IRTensorValue::GetDataView<int>((uint64_t *)this);
      if (v39)
      {
        char v40 = (int *)v38;
        std::string::size_type v41 = a3 + 2;
        uint64_t v42 = a3[1];
        std::string v43 = (int *)(v38 + 4 * v39);
        do
        {
          int v44 = *v40;
          if ((unint64_t)v42 >= *v41)
          {
            uint64_t v46 = *a3;
            uint64_t v47 = (v42 - *a3) >> 2;
            unint64_t v48 = v47 + 1;
            if ((unint64_t)(v47 + 1) >> 62) {
              std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v49 = *v41 - (void)v46;
            if (v49 >> 1 > v48) {
              unint64_t v48 = v49 >> 1;
            }
            if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v50 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v50 = v48;
            }
            if (v50)
            {
              std::string::size_type v51 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(a3 + 2), v50);
              uint64_t v46 = *a3;
              uint64_t v42 = a3[1];
            }
            else
            {
              std::string::size_type v51 = 0;
            }
            std::string v52 = &v51[4 * v47];
            *(_DWORD *)std::string v52 = v44;
            char v45 = v52 + 4;
            while (v42 != v46)
            {
              int v53 = *((_DWORD *)v42 - 1);
              v42 -= 4;
              *((_DWORD *)v52 - 1) = v53;
              v52 -= 4;
            }
            *a3 = v52;
            a3[1] = v45;
            a3[2] = &v51[4 * v50];
            if (v46) {
              operator delete(v46);
            }
          }
          else
          {
            *(_DWORD *)uint64_t v42 = v44;
            char v45 = v42 + 4;
          }
          a3[1] = v45;
          ++v40;
          uint64_t v42 = v45;
        }
        while (v40 != v43);
      }
      break;
    case 0xEu:
      uint64_t v54 = MIL::IRTensorValue::GetDataView<unsigned char>(this);
      if (v55)
      {
        uint64_t v56 = (unsigned __int8 *)v54;
        std::string::size_type v57 = (unsigned __int8 *)(v54 + v55);
        std::string v58 = a3 + 2;
        std::string v59 = a3[1];
        do
        {
          int v60 = *v56;
          if ((unint64_t)v59 >= *v58)
          {
            uint64_t v62 = *a3;
            uint64_t v63 = (v59 - *a3) >> 2;
            unint64_t v64 = v63 + 1;
            if ((unint64_t)(v63 + 1) >> 62) {
              std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v65 = *v58 - (void)v62;
            if (v65 >> 1 > v64) {
              unint64_t v64 = v65 >> 1;
            }
            if ((unint64_t)v65 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v66 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v66 = v64;
            }
            if (v66)
            {
              uint64_t v67 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(a3 + 2), v66);
              uint64_t v62 = *a3;
              std::string v59 = a3[1];
            }
            else
            {
              uint64_t v67 = 0;
            }
            std::string v68 = &v67[4 * v63];
            *(_DWORD *)std::string v68 = v60;
            std::string::size_type v61 = v68 + 4;
            while (v59 != v62)
            {
              int v69 = *((_DWORD *)v59 - 1);
              v59 -= 4;
              *((_DWORD *)v68 - 1) = v69;
              v68 -= 4;
            }
            *a3 = v68;
            a3[1] = v61;
            a3[2] = &v67[4 * v66];
            if (v62) {
              operator delete(v62);
            }
          }
          else
          {
            *(_DWORD *)std::string v59 = v60;
            std::string::size_type v61 = v59 + 4;
          }
          a3[1] = v61;
          ++v56;
          std::string v59 = v61;
        }
        while (v56 != v57);
      }
      break;
    case 0xFu:
      uint64_t v22 = MIL::IRTensorValue::GetDataView<unsigned short>((uint64_t *)this);
      if (v23)
      {
        uint64_t v24 = (unsigned __int16 *)v22;
        long long v25 = a3 + 2;
        long long v26 = a3[1];
        std::string::size_type v27 = (unsigned __int16 *)(v22 + 2 * v23);
        do
        {
          int v28 = *v24;
          if ((unint64_t)v26 >= *v25)
          {
            std::string::size_type v30 = *a3;
            uint64_t v31 = (v26 - *a3) >> 2;
            unint64_t v32 = v31 + 1;
            if ((unint64_t)(v31 + 1) >> 62) {
              std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v33 = *v25 - (void)v30;
            if (v33 >> 1 > v32) {
              unint64_t v32 = v33 >> 1;
            }
            if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v34 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v34 = v32;
            }
            if (v34)
            {
              long long v35 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(a3 + 2), v34);
              std::string::size_type v30 = *a3;
              long long v26 = a3[1];
            }
            else
            {
              long long v35 = 0;
            }
            std::string v36 = &v35[4 * v31];
            *(_DWORD *)std::string v36 = v28;
            long long v29 = v36 + 4;
            while (v26 != v30)
            {
              int v37 = *((_DWORD *)v26 - 1);
              v26 -= 4;
              *((_DWORD *)v36 - 1) = v37;
              v36 -= 4;
            }
            *a3 = v36;
            a3[1] = v29;
            a3[2] = &v35[4 * v34];
            if (v30) {
              operator delete(v30);
            }
          }
          else
          {
            *(_DWORD *)long long v26 = v28;
            long long v29 = v26 + 4;
          }
          a3[1] = v29;
          ++v24;
          long long v26 = v29;
        }
        while (v24 != v27);
      }
      break;
    default:
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Unsupported shape cast to int32_t.");
      __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
  }
}

void sub_20F4AD724(_Unwind_Exception *a1)
{
  __cxa_free_exception(v2);
  std::string v4 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(a1);
}

void MIL::Validation::ValidateViaTypeInference(MIL::Validation *this, const MIL::IROperation *a2)
{
  memset(v21, 0, sizeof(v21));
  int v22 = 1065353216;
  uint64_t v3 = (MIL::MILContext **)(*(uint64_t (**)(MIL::Validation *, const MIL::IROperation *))(*(void *)this
                                                                                                  + 160))(this, a2);
  BOOL v6 = *v3;
  std::string v4 = (MIL::MILContext *)(v3 + 1);
  uint64_t v5 = v6;
  if (v6 != v4)
  {
    uint64_t v15 = v4;
    do
    {
      *(void *)&long long v16 = (char *)v5 + 32;
      uint64_t v7 = std::__hash_table<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v21, (unsigned __int8 *)v5 + 32, (uint64_t)&std::piecewise_construct, (long long **)&v16);
      std::vector<std::shared_ptr<MIL::IRTypedArgument>>::__assign_with_size[abi:ne180100]<std::shared_ptr<MIL::IRTypedArgument> const*,std::shared_ptr<MIL::IRTypedArgument> const*>((uint64_t)(v7 + 40), 0, 0, 0);
      if (*((void *)v5 + 8) != *((void *)v5 + 7))
      {
        MIL::IROperation::TryGetParameterValueSharedPtr(this, (uint64_t)v5 + 32, 0, &v17);
        Parameteruint64_t Type = (MIL::IRValueType *)MIL::IROperation::GetParameterType(this);
        uint64_t v9 = MIL::IRValueType::AsTensorType(ParameterType);
        if (v17)
        {
          *(void *)&long long v16 = (char *)v5 + 32;
          std::__hash_table<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v21, (unsigned __int8 *)v5 + 32, (uint64_t)&std::piecewise_construct, (long long **)&v16);
          uint64_t v19 = v17;
          uint64_t v20 = v18;
          if (v18) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v18 + 8), 1uLL, memory_order_relaxed);
          }
          MIL::IRTypedArgument::Make();
        }
        uint64_t v10 = (MIL::IRTypedArgument *)v9;
        *(void *)&long long v16 = (char *)v5 + 32;
        std::__hash_table<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v21, (unsigned __int8 *)v5 + 32, (uint64_t)&std::piecewise_construct, (long long **)&v16);
        MIL::IRTypedArgument::Make(v10, v11);
      }
      int v12 = (MIL::MILContext *)*((void *)v5 + 1);
      if (v12)
      {
        do
        {
          unsigned int v13 = v12;
          int v12 = *(MIL::MILContext **)v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          unsigned int v13 = (MIL::MILContext *)*((void *)v5 + 2);
          BOOL v14 = *(void *)v13 == (void)v5;
          uint64_t v5 = v13;
        }
        while (!v14);
      }
      uint64_t v5 = v13;
      std::string v4 = v15;
    }
    while (v13 != v15);
  }
  MIL::MILContext::Make(v4);
}

void sub_20F4AE2D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, std::__shared_weak_count *a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a19) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a19);
  }
  std::ostringstream::~ostringstream((uint64_t)&a36);
  operator delete(v36);
  uint64_t v39 = *(std::__shared_weak_count **)(v37 - 168);
  if (v39) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v39);
  }
  std::__hash_table<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::shared_ptr<MIL::IRTypedArgument>>>>>::~__hash_table(v37 - 144);
  _Unwind_Resume(a1);
}

BOOL MIL::Validation::CanBroadcastShapes(uint64_t *a1)
{
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  std::vector<std::vector<MIL::IRDimension const*>>::reserve((uint64_t *)&v23, 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3));
  uint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  if (*a1 != v3)
  {
    unint64_t v4 = 0;
    do
    {
      if (v4 <= (uint64_t)(*(void *)(v2 + 8) - *(void *)v2) >> 3) {
        unint64_t v4 = (uint64_t)(*(void *)(v2 + 8) - *(void *)v2) >> 3;
      }
      std::string __p = 0;
      int v21 = 0;
      uint64_t v22 = 0;
      std::vector<MIL::IRDimension const*>::__init_with_size[abi:ne180100]<MIL::IRDimension const**,MIL::IRDimension const**>(&__p, *(const void **)v2, *(void *)(v2 + 8), (uint64_t)(*(void *)(v2 + 8) - *(void *)v2) >> 3);
      uint64_t v5 = v21 - 8;
      if (__p != v21 && v5 > __p)
      {
        uint64_t v7 = (char *)__p + 8;
        do
        {
          uint64_t v8 = *((void *)v7 - 1);
          *((void *)v7 - 1) = *(void *)v5;
          *(void *)uint64_t v5 = v8;
          v5 -= 8;
          BOOL v9 = v7 >= v5;
          v7 += 8;
        }
        while (!v9);
      }
      std::vector<std::vector<MIL::IRDimension const*>>::push_back[abi:ne180100]((uint64_t *)&v23, (uint64_t)&__p);
      if (__p)
      {
        int v21 = (char *)__p;
        operator delete(__p);
      }
      v2 += 24;
    }
    while (v2 != v3);
    if (v4)
    {
      BOOL v10 = 0;
      for (i = 0; i != v4; BOOL v10 = i >= v4)
      {
        int v12 = v23;
        unsigned int v13 = v24;
        if (v23 != v24)
        {
          unint64_t v14 = 1;
          do
          {
            if (i < (uint64_t)(v12[1] - *v12) >> 3)
            {
              uint64_t v15 = (*(uint64_t (**)(void))(**(void **)(*v12 + 8 * i) + 16))(*(void *)(*v12 + 8 * i));
              if (v15)
              {
                unint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)v15 + 48))(v15);
                if (v16 != 1 && v14 != 1 && v16 != v14) {
                  goto LABEL_35;
                }
                if (v16 > v14) {
                  unint64_t v14 = v16;
                }
              }
            }
            v12 += 3;
          }
          while (v12 != v13);
        }
        ++i;
      }
    }
  }
  BOOL v10 = 1;
LABEL_35:
  std::string __p = &v23;
  std::vector<std::vector<unsigned long long>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  return v10;
}

void sub_20F4AE864(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char *__p, uint64_t a10, uint64_t a11, char a12)
{
  std::string __p = &a12;
  std::vector<std::vector<unsigned long long>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::vector<MIL::IRDimension const*>>::reserve(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  if (0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3) < a2)
  {
    if (a2 >= 0xAAAAAAAAAAAAAABLL) {
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v5 = a1[1] - *a1;
    v7[4] = result;
    v7[0] = std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(result, a2);
    v7[1] = v7[0] + v5;
    void v7[2] = v7[0] + v5;
    void v7[3] = v7[0] + 24 * v6;
    std::vector<std::vector<MIL::IRDimension const*>>::__swap_out_circular_buffer(a1, v7);
    return std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)v7);
  }
  return result;
}

void sub_20F4AE944(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::vector<MIL::IRDimension const*>>::push_back[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  uint64_t v7 = *(void **)(result - 8);
  if ((unint64_t)v7 >= v6)
  {
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v7 - *a1) >> 3);
    unint64_t v10 = v9 + 1;
    if (v9 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 3);
    if (2 * v11 > v10) {
      unint64_t v10 = 2 * v11;
    }
    if (v11 >= 0x555555555555555) {
      unint64_t v12 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v12 = v10;
    }
    v16[4] = result;
    unsigned int v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(result, v12);
    unint64_t v14 = &v13[24 * v9];
    v16[0] = v13;
    v16[1] = v14;
    void v16[3] = &v13[24 * v15];
    *((void *)v14 + 1) = 0;
    *((void *)v14 + 2) = 0;
    *(void *)unint64_t v14 = 0;
    *(_OWORD *)unint64_t v14 = *(_OWORD *)a2;
    *((void *)v14 + 2) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    _OWORD v16[2] = v14 + 24;
    std::vector<std::vector<MIL::IRDimension const*>>::__swap_out_circular_buffer(a1, v16);
    uint64_t v8 = (void *)a1[1];
    uint64_t result = std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)v16);
  }
  else
  {
    *uint64_t v7 = 0;
    v7[1] = 0;
    void v7[2] = 0;
    *(_OWORD *)uint64_t v7 = *(_OWORD *)a2;
    void v7[2] = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    uint64_t v8 = v7 + 3;
    a1[1] = (uint64_t)(v7 + 3);
  }
  a1[1] = (uint64_t)v8;
  return result;
}

void sub_20F4AEA84(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void *std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int>(uint64_t a1, int *a2, _DWORD *a3)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = *a2;
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
    unint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      unint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == v6)
          {
            if (*((_DWORD *)v10 + 4) == v6) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          unint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  unint64_t v10 = operator new(0x18uLL);
  *unint64_t v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v18 = *(void *)a1;
  uint64_t v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    *unint64_t v10 = *v19;
LABEL_38:
    void *v19 = v10;
    goto LABEL_39;
  }
  *unint64_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }
    else
    {
      v20 &= v7 - 1;
    }
    uint64_t v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_20F4AECA0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::vector<std::shared_ptr<MIL::IRTypedArgument>>::__assign_with_size[abi:ne180100]<std::shared_ptr<MIL::IRTypedArgument> const*,std::shared_ptr<MIL::IRTypedArgument> const*>(uint64_t a1, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v8 = a1 + 16;
  unint64_t v9 = *(void **)a1;
  if (a4 > (uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 4)
  {
    std::vector<std::shared_ptr<MIL::IRNamedValueType>>::__vdeallocate((uint64_t *)a1);
    if (a4 >> 60) {
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = *(void *)(a1 + 16) - *(void *)a1;
    uint64_t v11 = v10 >> 3;
    if (v10 >> 3 <= a4) {
      uint64_t v11 = a4;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v12 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    std::vector<std::shared_ptr<MIL::IRNamedValueType>>::__vallocate[abi:ne180100]((void *)a1, v12);
    float v13 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::shared_ptr<MIL::IRTypedArgument>>,std::shared_ptr<MIL::IRTypedArgument>*,std::shared_ptr<MIL::IRTypedArgument>*,std::shared_ptr<MIL::IRTypedArgument>*>(v8, a2, a3, *(void **)(a1 + 8));
    goto LABEL_11;
  }
  unint64_t v14 = (uint64_t)(*(void *)(a1 + 8) - (void)v9) >> 4;
  if (v14 < a4)
  {
    unint64_t v15 = &a2[2 * v14];
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::shared_ptr<MIL::IRArgument> const*,std::shared_ptr<MIL::IRArgument> const*,std::shared_ptr<MIL::IRArgument>*>((uint64_t)&v20, a2, v15, v9);
    float v13 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::shared_ptr<MIL::IRTypedArgument>>,std::shared_ptr<MIL::IRTypedArgument>*,std::shared_ptr<MIL::IRTypedArgument>*,std::shared_ptr<MIL::IRTypedArgument>*>(v8, v15, a3, *(void **)(a1 + 8));
LABEL_11:
    *(void *)(a1 + 8) = v13;
    return;
  }
  std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::shared_ptr<MIL::IRArgument> const*,std::shared_ptr<MIL::IRArgument> const*,std::shared_ptr<MIL::IRArgument>*>((uint64_t)&v21, a2, a3, v9);
  uint64_t v17 = v16;
  uint64_t v18 = *(void *)(a1 + 8);
  if (v18 != v16)
  {
    do
    {
      uint64_t v19 = *(std::__shared_weak_count **)(v18 - 8);
      if (v19) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v19);
      }
      v18 -= 16;
    }
    while (v18 != v17);
  }
  *(void *)(a1 + 8) = v17;
}

void sub_20F4AEDF8(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_20F4AEE00(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<MIL::MILContext  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21056C700);
}

uint64_t std::__shared_ptr_pointer<MIL::MILContext  *>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<MIL::MILContext  *>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else {
    return 0;
  }
}

uint64_t std::vector<std::vector<MIL::IRDimension const*>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<MIL::IRDimension const*>>,std::reverse_iterator<std::vector<MIL::IRDimension const*>*>,std::reverse_iterator<std::vector<MIL::IRDimension const*>*>,std::reverse_iterator<std::vector<MIL::IRDimension const*>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<MIL::IRDimension const*>>,std::reverse_iterator<std::vector<MIL::IRDimension const*>*>,std::reverse_iterator<std::vector<MIL::IRDimension const*>*>,std::reverse_iterator<std::vector<MIL::IRDimension const*>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v14 = a6;
  *((void *)&v14 + 1) = a7;
  long long v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    uint64_t v9 = a6;
  }
  else
  {
    do
    {
      *(void *)(v7 - 24) = 0;
      *(void *)(v7 - 16) = 0;
      *(void *)(v7 - 8) = 0;
      long long v8 = *(_OWORD *)(a3 - 3);
      a3 -= 3;
      *(_OWORD *)(v7 - 24) = v8;
      *(void *)(v7 - 8) = a3[2];
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      uint64_t v7 = *((void *)&v14 + 1) - 24;
      *((void *)&v14 + 1) -= 24;
    }
    while (a3 != a5);
    uint64_t v9 = v14;
  }
  char v12 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<MIL::IRDimension const*>>,std::reverse_iterator<std::vector<MIL::IRDimension const*>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<MIL::IRDimension const*>>,std::reverse_iterator<std::vector<MIL::IRDimension const*>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::reverse_iterator<std::vector<float>*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void MIL::IRProgramValidator::Validate(MIL::IRProgramValidator *this@<X0>, const MIL::IRProgram *a2@<X1>, MIL::ValidationResult *a3@<X8>)
{
  uint64_t v4 = *(uint64_t ***)((*(uint64_t (**)(MIL::IRProgramValidator *, const MIL::IRProgram *))(*(void *)this + 72))(this, a2)+ 16);
  if (!v4)
  {
LABEL_86:
    MIL::ValidationResult::ValidationResult(a3);
    return;
  }
  while (1)
  {
    uint64_t v5 = (uint64_t *)*((unsigned __int8 *)v4 + 39);
    if ((char)v5 < 0) {
      uint64_t v5 = v4[3];
    }
    if (!v5)
    {
      uint64_t LocationPtr = (std::string::size_type *)MIL::IRObject::GetLocationPtr(this);
      std::string::size_type v38 = LocationPtr[1];
      v65.__r_.__value_.__r.__words[0] = *LocationPtr;
      v65.__r_.__value_.__l.__size_ = v38;
      if (v38) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v38 + 8), 1uLL, memory_order_relaxed);
      }
      std::string::basic_string[abi:ne180100]<0>(&v66, "Function names must be non-empty.");
      MIL::ValidationResult::ValidationResult(v58, &v65, 202, &v66);
      goto LABEL_59;
    }
    Function = (MIL::IRObject *)MIL::IRProgram::GetFunction((uint64_t)this);
    uint64_t v7 = (void *)(*(uint64_t (**)(MIL::IRObject *))(*(void *)Function + 128))(Function);
    uint64_t v9 = v7 + 1;
    long long v8 = (void *)*v7;
    if ((void *)*v7 == v7 + 1)
    {
LABEL_18:
      (*(void (**)(long long *__return_ptr, MIL::IRObject *))(*(void *)Function + 160))(&v66, Function);
      long long v13 = v66;
      uint64_t v14 = (*(uint64_t (**)(MIL::IRObject *))(*(void *)Function + 40))(Function);
      unint64_t v15 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)v14 + 88))(v14);
      uint64_t v17 = *v15;
      uint64_t v16 = v15[1];
      if ((void)v66)
      {
        *((void *)&v66 + 1) = v66;
        operator delete((void *)v66);
      }
      if ((uint64_t)(*((void *)&v13 + 1) - v13) >> 3 == 0xAAAAAAAAAAAAAAABLL * ((v16 - v17) >> 3))
      {
        uint64_t v18 = (*(uint64_t (**)(MIL::IRProgramValidator *))(*(void *)this + 40))(this);
        uint64_t v19 = (*(uint64_t (**)(MIL::IRObject *))(*(void *)Function + 32))(Function);
        if ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v18 + 16))(v18, v19))
        {
          char v20 = (void *)(*(uint64_t (**)(MIL::IRObject *))(*(void *)Function + 112))(Function);
          uint64_t v22 = v20 + 1;
          char v21 = (void *)*v20;
          if ((void *)*v20 == v20 + 1)
          {
LABEL_30:
            (*(void (**)(long long *__return_ptr, MIL::IRObject *))(*(void *)Function + 160))(&v66, Function);
            if (*((void *)&v66 + 1) == (void)v66)
            {
LABEL_43:
              MIL::ValidationResult::ValidationResult((MIL::ValidationResult *)v58);
            }
            else
            {
              uint64_t v28 = 0;
              unint64_t v29 = 0;
              if ((unint64_t)((uint64_t)(*((void *)&v66 + 1) - v66) >> 3) <= 1) {
                uint64_t v30 = 1;
              }
              else {
                uint64_t v30 = (uint64_t)(*((void *)&v66 + 1) - v66) >> 3;
              }
              while (1)
              {
                if (v29 >= (uint64_t)(*((void *)&v66 + 1) - v66) >> 3) {
                  std::vector<MIL::IRDimension const*>::__throw_out_of_range[abi:ne180100]();
                }
                uint64_t v31 = *(void *)(v66 + 8 * v29);
                uint64_t v32 = (*(uint64_t (**)(MIL::IRObject *))(*(void *)Function + 40))(Function);
                uint64_t v33 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v32 + 88))(v32);
                if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v33[1] - *v33) >> 3) <= v29) {
                  std::vector<MIL::IRDimension const*>::__throw_out_of_range[abi:ne180100]();
                }
                unint64_t v34 = (long long *)(*v33 + v28);
                if (*((char *)v34 + 23) < 0)
                {
                  std::string::__init_copy_ctor_external(&v65, *(const std::string::value_type **)v34, *((void *)v34 + 1));
                }
                else
                {
                  long long v35 = *v34;
                  v65.__r_.__value_.__r.__words[2] = *((void *)v34 + 2);
                  *(_OWORD *)&v65.__r_.__value_.__l.__data_ = v35;
                }
                uint64_t v36 = (*(uint64_t (**)(MIL::IRObject *))(*(void *)Function + 40))(Function);
                if (v31 != (*(uint64_t (**)(void))(*(void *)(v36 + 64) + 16))()) {
                  break;
                }
                if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v65.__r_.__value_.__l.__data_);
                }
                ++v29;
                v28 += 24;
                if (v30 == v29) {
                  goto LABEL_43;
                }
              }
              uint64_t v54 = (uint64_t *)MIL::IRObject::GetLocationPtr(Function);
              uint64_t v55 = (std::__shared_weak_count *)v54[1];
              uint64_t v63 = *v54;
              unint64_t v64 = v55;
              if (v55) {
                atomic_fetch_add_explicit(&v55->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              std::string::basic_string[abi:ne180100]<0>(&__p, "A function must return the same types as its block.");
              MIL::ValidationResult::ValidationResult(v58, &v63, 201, &__p);
              if (v62 < 0) {
                operator delete(__p);
              }
              if (v64) {
                std::__shared_weak_count::__release_shared[abi:ne180100](v64);
              }
              if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v65.__r_.__value_.__l.__data_);
              }
            }
            if ((void)v66)
            {
              *((void *)&v66 + 1) = v66;
              operator delete((void *)v66);
            }
          }
          else
          {
            while (1)
            {
              uint64_t v23 = (*(uint64_t (**)(MIL::IRProgramValidator *))(*(void *)this + 40))(this);
              uint64_t v24 = (MIL::IROpset *)(*(uint64_t (**)(uint64_t, void *))(*(void *)v23 + 16))(v23, v21 + 4);
              uint64_t v25 = (*(uint64_t (**)(MIL::IRProgramValidator *))(*(void *)this + 40))(this);
              MIL::IROpset::GetReversedOperatorNamesMap(v24, (uint64_t)&v65);
              std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)&v65);
              if (((*(uint64_t (**)(long long *))(v66 + 16))(&v66) & 1) == 0) {
                break;
              }
              MIL::ValidationResult::~ValidationResult((MIL::ValidationResult *)&v66);
              long long v26 = (void *)v21[1];
              if (v26)
              {
                do
                {
                  std::string::size_type v27 = v26;
                  long long v26 = (void *)*v26;
                }
                while (v26);
              }
              else
              {
                do
                {
                  std::string::size_type v27 = (void *)v21[2];
                  BOOL v12 = *v27 == (void)v21;
                  char v21 = v27;
                }
                while (!v12);
              }
              char v21 = v27;
              if (v27 == v22) {
                goto LABEL_30;
              }
            }
            MIL::MILResult::MILResult(v58, (uint64_t)&v66);
            v58[0].__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_26C25DB50;
            int v59 = v68;
            MIL::ValidationResult::~ValidationResult((MIL::ValidationResult *)&v66);
          }
          goto LABEL_63;
        }
        uint64_t v50 = MIL::IRObject::GetLocationPtr(Function);
        std::string::size_type v51 = *(std::__shared_weak_count **)(v50 + 8);
        std::string __p = *(void **)v50;
        std::string::size_type v61 = v51;
        if (v51) {
          atomic_fetch_add_explicit(&v51->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        (*(void (**)(MIL::IRObject *))(*(void *)Function + 32))(Function);
        std::operator+<char>();
        std::string v52 = std::string::append(&v65, "' not in context.");
        long long v53 = *(_OWORD *)&v52->__r_.__value_.__l.__data_;
        std::string::size_type v67 = v52->__r_.__value_.__r.__words[2];
        long long v66 = v53;
        v52->__r_.__value_.__l.__size_ = 0;
        v52->__r_.__value_.__r.__words[2] = 0;
        v52->__r_.__value_.__r.__words[0] = 0;
        MIL::ValidationResult::ValidationResult(v58, &__p, 204, &v66);
        goto LABEL_69;
      }
      uint64_t v39 = (std::string::size_type *)MIL::IRObject::GetLocationPtr(Function);
      std::string::size_type v40 = v39[1];
      v65.__r_.__value_.__r.__words[0] = *v39;
      v65.__r_.__value_.__l.__size_ = v40;
      if (v40) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v40 + 8), 1uLL, memory_order_relaxed);
      }
      std::string::basic_string[abi:ne180100]<0>(&v66, "A function must return the same number of values as its block.");
      MIL::ValidationResult::ValidationResult(v58, &v65, 200, &v66);
LABEL_59:
      if (SHIBYTE(v67) < 0) {
        operator delete((void *)v66);
      }
      std::string::size_type size = (std::__shared_weak_count *)v65.__r_.__value_.__l.__size_;
      if (v65.__r_.__value_.__l.__size_) {
        goto LABEL_62;
      }
      goto LABEL_63;
    }
    while (1)
    {
      if (*((char *)v8 + 55) < 0)
      {
        if (!v8[5])
        {
LABEL_50:
          std::string::size_type v41 = (std::string::size_type *)MIL::IRObject::GetLocationPtr(Function);
          std::string::size_type v42 = v41[1];
          v65.__r_.__value_.__r.__words[0] = *v41;
          v65.__r_.__value_.__l.__size_ = v42;
          if (v42) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v42 + 8), 1uLL, memory_order_relaxed);
          }
          std::string::basic_string[abi:ne180100]<0>(&v66, "Function parameter names must be non-empty.");
          MIL::ValidationResult::ValidationResult(v58, &v65, 206, &v66);
          goto LABEL_59;
        }
      }
      else if (!*((unsigned char *)v8 + 55))
      {
        goto LABEL_50;
      }
      if ((*(uint64_t (**)(char *, void *, uint64_t))(*((void *)this + 8) + 24))((char *)this + 64, v8 + 4, 1))
      {
        break;
      }
      if (!v8[7])
      {
        uint64_t v47 = (std::string::size_type *)MIL::IRObject::GetLocationPtr(Function);
        std::string::size_type v48 = v47[1];
        v65.__r_.__value_.__r.__words[0] = *v47;
        v65.__r_.__value_.__l.__size_ = v48;
        if (v48) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v48 + 8), 1uLL, memory_order_relaxed);
        }
        std::string::basic_string[abi:ne180100]<0>(&v66, "Function parameter types must be non-null.");
        MIL::ValidationResult::ValidationResult(v58, &v65, 208, &v66);
        goto LABEL_59;
      }
      uint64_t v10 = (void *)v8[1];
      if (v10)
      {
        do
        {
          uint64_t v11 = v10;
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          uint64_t v11 = (void *)v8[2];
          BOOL v12 = *v11 == (void)v8;
          long long v8 = v11;
        }
        while (!v12);
      }
      long long v8 = v11;
      if (v11 == v9) {
        goto LABEL_18;
      }
    }
    uint64_t v43 = MIL::IRObject::GetLocationPtr(Function);
    int v44 = *(std::__shared_weak_count **)(v43 + 8);
    std::string __p = *(void **)v43;
    std::string::size_type v61 = v44;
    if (v44) {
      atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    std::operator+<char>();
    char v45 = std::string::append(&v65, "' shadows an earlier declaration.");
    long long v46 = *(_OWORD *)&v45->__r_.__value_.__l.__data_;
    std::string::size_type v67 = v45->__r_.__value_.__r.__words[2];
    long long v66 = v46;
    v45->__r_.__value_.__l.__size_ = 0;
    v45->__r_.__value_.__r.__words[2] = 0;
    v45->__r_.__value_.__r.__words[0] = 0;
    MIL::ValidationResult::ValidationResult(v58, &__p, 207, &v66);
LABEL_69:
    if (SHIBYTE(v67) < 0) {
      operator delete((void *)v66);
    }
    if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v65.__r_.__value_.__l.__data_);
    }
    std::string::size_type size = v61;
    if (v61) {
LABEL_62:
    }
      std::__shared_weak_count::__release_shared[abi:ne180100](size);
LABEL_63:
    if (((*(uint64_t (**)(std::string *))(v58[0].__r_.__value_.__r.__words[0] + 16))(v58) & 1) == 0) {
      break;
    }
    MIL::ValidationResult::~ValidationResult((MIL::ValidationResult *)v58);
    uint64_t v4 = (uint64_t **)*v4;
    if (!v4) {
      goto LABEL_86;
    }
  }
  uint64_t v56 = MIL::MILResult::MILResult((std::string *)a3, (uint64_t)v58);
  v56->__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_26C25DB50;
  LODWORD(v56[2].__r_.__value_.__l.__data_) = v59;
  MIL::ValidationResult::~ValidationResult((MIL::ValidationResult *)v58);
}

void sub_20F4AF950(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,std::__shared_weak_count *a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a25) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a25);
  }
  if (a31 < 0) {
    operator delete(a26);
  }
  uint64_t v33 = *(void **)(v31 - 144);
  if (v33)
  {
    *(void *)(v31 - 136) = v33;
    operator delete(v33);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::ValidateBlock(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, MIL::IRObject *a4@<X3>, MIL::ValidationResult *a5@<X8>)
{
  long long v8 = (char *)a4 + 64;
  uint64_t v9 = (*(uint64_t (**)(uint64_t))(*((void *)a4 + 8) + 72))((uint64_t)a4 + 64);
  uint64_t v10 = (*(uint64_t (**)(MIL::IRObject *))(*(void *)a4 + 40))(a4);
  uint64_t v11 = *(MIL::IRNamedValueType ***)v10;
  BOOL v12 = *(MIL::IRNamedValueType ***)(v10 + 8);
  while (v11 != v12)
  {
    uint64_t Name = MIL::IRNamedValueType::GetName(*v11);
    uint64_t v14 = *(unsigned __int8 *)(Name + 23);
    if ((v14 & 0x80u) != 0) {
      uint64_t v14 = *(void *)(Name + 8);
    }
    if (!v14)
    {
      uint64_t LocationPtr = (uint64_t *)MIL::IRObject::GetLocationPtr(a4);
      uint64_t v116 = (std::__shared_weak_count *)LocationPtr[1];
      uint64_t v147 = *LocationPtr;
      char v148 = v116;
      if (v116) {
        atomic_fetch_add_explicit(&v116->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      std::string::basic_string[abi:ne180100]<0>(v145, "Block parameter names must be non-empty.");
      MIL::ValidationResult::ValidationResult(a5, &v147, 105, v145);
      if (v146 < 0) {
        operator delete(v145[0]);
      }
      uint64_t v117 = v148;
      if (!v148) {
        return;
      }
      goto LABEL_199;
    }
    if (v9 && (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v9 + 24))(v9, Name, 1))
    {
      uint64_t v118 = (uint64_t *)MIL::IRObject::GetLocationPtr(a4);
      unint64_t v119 = (std::__shared_weak_count *)v118[1];
      uint64_t v143 = *v118;
      uint64_t v144 = v119;
      if (v119) {
        atomic_fetch_add_explicit(&v119->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      std::operator+<char>();
      uint64_t v120 = std::string::append(__p, "' shadows an earlier declaration.");
      long long v121 = *(_OWORD *)&v120->__r_.__value_.__l.__data_;
      std::string::size_type v142 = v120->__r_.__value_.__r.__words[2];
      long long v141 = v121;
      v120->__r_.__value_.__l.__size_ = 0;
      v120->__r_.__value_.__r.__words[2] = 0;
      v120->__r_.__value_.__r.__words[0] = 0;
      MIL::ValidationResult::ValidationResult(a5, &v143, 106, &v141);
      if (SHIBYTE(v142) < 0) {
        operator delete((void *)v141);
      }
      if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p[0].__r_.__value_.__l.__data_);
      }
      uint64_t v117 = v144;
      if (!v144) {
        return;
      }
      goto LABEL_199;
    }
    v11 += 2;
  }
  unint64_t v15 = (uint64_t *)(*(uint64_t (**)(MIL::IRObject *))(*(void *)a4 + 88))(a4);
  uint64_t v17 = *v15;
  uint64_t v16 = v15[1];
  while (1)
  {
    if (v17 == v16)
    {
      uint64_t v18 = (MIL::IRObject ****)(*(uint64_t (**)(MIL::IRObject *))(*(void *)a4 + 56))(a4);
      char v20 = **v18;
      uint64_t v19 = (*v18)[1];
      if (v20 == v19)
      {
LABEL_177:
        MIL::ValidationResult::ValidationResult(a5);
        return;
      }
      while (1)
      {
        char v21 = *v20;
        uint64_t v22 = (*(uint64_t (**)(MIL::IRObject *))(*(void *)*v20 + 104))(*v20);
        uint64_t v23 = v22 ? (*(uint64_t (**)(void))(*(void *)(v22 + 64) + 72))() : 0;
        (*(void (**)(std::string *__return_ptr, MIL::IRObject *))(*(void *)v21 + 200))(__p, v21);
        std::string::size_type size = __p[0].__r_.__value_.__l.__size_;
        for (std::string::size_type i = __p[0].__r_.__value_.__r.__words[0]; i != size; i += 24)
        {
          if (v23
            && (*(uint64_t (**)(uint64_t, std::string::size_type, uint64_t))(*(void *)v23 + 24))(v23, i, 1))
          {
            uint64_t v37 = (std::string::size_type *)MIL::IRObject::GetLocationPtr(v21);
            std::string::size_type v38 = v37[1];
            v155.__r_.__value_.__r.__words[0] = *v37;
            v155.__r_.__value_.__l.__size_ = v38;
            if (v38) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v38 + 8), 1uLL, memory_order_relaxed);
            }
            std::operator+<char>();
            uint64_t v39 = std::string::append(&v158, "' shadows an earlier declaration.");
            long long v40 = *(_OWORD *)&v39->__r_.__value_.__l.__data_;
            __dst.__r_.__value_.__r.__words[2] = v39->__r_.__value_.__r.__words[2];
            *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v40;
            v39->__r_.__value_.__l.__size_ = 0;
            v39->__r_.__value_.__r.__words[2] = 0;
            v39->__r_.__value_.__r.__words[0] = 0;
            MIL::ValidationResult::ValidationResult(v131, &v155, 312, &__dst);
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__dst.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v158.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v158.__r_.__value_.__l.__data_);
            }
            if (v155.__r_.__value_.__l.__size_) {
              std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v155.__r_.__value_.__l.__size_);
            }
            v158.__r_.__value_.__r.__words[0] = (std::string::size_type)__p;
            std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v158);
            goto LABEL_123;
          }
        }
        __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)__p;
        std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&__dst);
        uint64_t v26 = (*(uint64_t (**)(MIL::IRObject *))(*(void *)v21 + 72))(v21);
        if (v26) {
          break;
        }
        uint64_t v33 = (std::string::size_type *)MIL::IRObject::GetLocationPtr(v21);
        std::string::size_type v34 = v33[1];
        v158.__r_.__value_.__r.__words[0] = *v33;
        v158.__r_.__value_.__l.__size_ = v34;
        if (v34) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v34 + 8), 1uLL, memory_order_relaxed);
        }
        (*(void (**)(MIL::IRObject *))(*(void *)v21 + 56))(v21);
        std::operator+<char>();
        long long v35 = std::string::append(&__dst, " does not exist in this context.");
        long long v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
        __p[0].__r_.__value_.__r.__words[2] = v35->__r_.__value_.__r.__words[2];
        *(_OWORD *)&__p[0].__r_.__value_.__l.__data_ = v36;
        v35->__r_.__value_.__l.__size_ = 0;
        v35->__r_.__value_.__r.__words[2] = 0;
        v35->__r_.__value_.__r.__words[0] = 0;
        MIL::ValidationResult::ValidationResult(v131, &v158, 309, __p);
        if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p[0].__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        if (v158.__r_.__value_.__l.__size_) {
          std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v158.__r_.__value_.__l.__size_);
        }
LABEL_123:
        if (((*(uint64_t (**)(std::string *))(v131[0].__r_.__value_.__r.__words[0] + 16))(v131) & 1) == 0)
        {
          uint64_t v128 = MIL::MILResult::MILResult((std::string *)a5, (uint64_t)v131);
          v128->__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_26C25DB50;
          LODWORD(v128[2].__r_.__value_.__l.__data_) = v132;
          MIL::ValidationResult::~ValidationResult((MIL::ValidationResult *)v131);
          return;
        }
        MIL::ValidationResult::~ValidationResult((MIL::ValidationResult *)v131);
        v20 += 2;
        if (v20 == v19) {
          goto LABEL_177;
        }
      }
      uint64_t v27 = v26;
      uint64_t v28 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
      if (v29 > 0x7FFFFFFFFFFFFFF7) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      uint64_t v30 = (const void *)v28;
      std::string::size_type v31 = v29;
      if (v29 >= 0x17)
      {
        uint64_t v41 = (v29 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v29 | 7) != 0x17) {
          uint64_t v41 = v29 | 7;
        }
        uint64_t v42 = v41 + 1;
        p_dst = operator new(v41 + 1);
        __dst.__r_.__value_.__l.__size_ = v31;
        __dst.__r_.__value_.__r.__words[2] = v42 | 0x8000000000000000;
        __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
      }
      else
      {
        *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v29;
        p_dst = &__dst;
        if (!v29)
        {
LABEL_52:
          p_dst[v31] = 0;
          if ((*(uint64_t (**)(MIL::IRObject *))(*(void *)v21 + 232))(v21))
          {
            uint64_t v43 = (*(uint64_t (**)(MIL::IRObject *))(*(void *)v21 + 232))(v21);
            uint64_t v44 = (*(uint64_t (**)(uint64_t))(*(void *)v43 + 16))(v43);
            MEMORY[0x21056C250](&__dst, v44, v45);
            uint64_t v46 = (*(uint64_t (**)(uint64_t, std::string *))(*(void *)a1 + 16))(a1, &__dst);
            if (v46 != (*(uint64_t (**)(MIL::IRObject *))(*(void *)v21 + 232))(v21))
            {
              uint64_t v47 = (std::string::size_type *)MIL::IRObject::GetLocationPtr(v21);
              std::string::size_type v48 = v47[1];
              v155.__r_.__value_.__r.__words[0] = *v47;
              v155.__r_.__value_.__l.__size_ = v48;
              if (v48) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(v48 + 8), 1uLL, memory_order_relaxed);
              }
              std::operator+<char>();
              uint64_t v49 = std::string::append(&v158, " does not exist in this context.");
              long long v50 = *(_OWORD *)&v49->__r_.__value_.__l.__data_;
              __p[0].__r_.__value_.__r.__words[2] = v49->__r_.__value_.__r.__words[2];
              *(_OWORD *)&__p[0].__r_.__value_.__l.__data_ = v50;
              v49->__r_.__value_.__l.__size_ = 0;
              v49->__r_.__value_.__r.__words[2] = 0;
              v49->__r_.__value_.__r.__words[0] = 0;
              MIL::ValidationResult::ValidationResult(v131, &v155, 309, __p);
              goto LABEL_57;
            }
            uint64_t v64 = (*(uint64_t (**)(MIL::IRObject *))(*(void *)v21 + 232))(v21);
            std::string v65 = (MIL::IROpset *)(*(uint64_t (**)(MIL::IRObject *))(*(void *)v21 + 232))(v21);
            MIL::IROpset::GetReversedOperatorNamesMap(v65, (uint64_t)__p);
            long long v66 = (unsigned __int8 *)(*(uint64_t (**)(uint64_t))(*(void *)v27 + 16))(v27);
            std::string::size_type v67 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(__p, v66);
            if (v67) {
              uint64_t Operator = MIL::IROpset::TryGetOperator(v64, v67 + 40);
            }
            else {
              uint64_t Operator = 0;
            }
            std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)__p);
            if (!Operator)
            {
LABEL_92:
              unint64_t v77 = (uint64_t *)MIL::IRObject::GetLocationPtr(v21);
              char v78 = (std::__shared_weak_count *)v77[1];
              uint64_t v156 = *v77;
              uint64_t v157 = v78;
              if (v78) {
                atomic_fetch_add_explicit(&v78->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              (*(void (**)(MIL::IRObject *))(*(void *)v21 + 56))(v21);
              std::operator+<char>();
              uint64_t v79 = std::string::append(&v154, " does not exist in opset ");
              long long v80 = *(_OWORD *)&v79->__r_.__value_.__l.__data_;
              v155.__r_.__value_.__r.__words[2] = v79->__r_.__value_.__r.__words[2];
              *(_OWORD *)&v155.__r_.__value_.__l.__data_ = v80;
              v79->__r_.__value_.__l.__size_ = 0;
              v79->__r_.__value_.__r.__words[2] = 0;
              v79->__r_.__value_.__r.__words[0] = 0;
              uint64_t v81 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
              size_t v83 = v82;
              if (v82 > 0x7FFFFFFFFFFFFFF7) {
                std::string::__throw_length_error[abi:ne180100]();
              }
              uint64_t v84 = (const void *)v81;
              if (v82 >= 0x17)
              {
                uint64_t v86 = (v82 & 0xFFFFFFFFFFFFFFF8) + 8;
                if ((v82 | 7) != 0x17) {
                  uint64_t v86 = v82 | 7;
                }
                uint64_t v87 = v86 + 1;
                int v85 = (void **)operator new(v86 + 1);
                size_t v152 = v83;
                int64_t v153 = v87 | 0x8000000000000000;
                uint64_t v151 = v85;
              }
              else
              {
                HIBYTE(v153) = v82;
                int v85 = (void **)&v151;
                if (!v82) {
                  goto LABEL_102;
                }
              }
              memmove(v85, v84, v83);
LABEL_102:
              *((unsigned char *)v85 + v83) = 0;
              if (v153 >= 0) {
                int v88 = (const std::string::value_type *)&v151;
              }
              else {
                int v88 = (const std::string::value_type *)v151;
              }
              if (v153 >= 0) {
                std::string::size_type v89 = HIBYTE(v153);
              }
              else {
                std::string::size_type v89 = v152;
              }
              uint64_t v90 = std::string::append(&v155, v88, v89);
              long long v91 = *(_OWORD *)&v90->__r_.__value_.__l.__data_;
              v158.__r_.__value_.__r.__words[2] = v90->__r_.__value_.__r.__words[2];
              *(_OWORD *)&v158.__r_.__value_.__l.__data_ = v91;
              v90->__r_.__value_.__l.__size_ = 0;
              v90->__r_.__value_.__r.__words[2] = 0;
              v90->__r_.__value_.__r.__words[0] = 0;
              unint64_t v92 = std::string::append(&v158, ".");
              long long v93 = *(_OWORD *)&v92->__r_.__value_.__l.__data_;
              __p[0].__r_.__value_.__r.__words[2] = v92->__r_.__value_.__r.__words[2];
              *(_OWORD *)&__p[0].__r_.__value_.__l.__data_ = v93;
              v92->__r_.__value_.__l.__size_ = 0;
              v92->__r_.__value_.__r.__words[2] = 0;
              v92->__r_.__value_.__r.__words[0] = 0;
              MIL::ValidationResult::ValidationResult(v131, &v156, 309, __p);
              goto LABEL_109;
            }
          }
          else
          {
            std::string v52 = (unsigned __int8 *)(*(uint64_t (**)(uint64_t))(*(void *)v27 + 16))(v27);
            long long v53 = std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(a3, v52);
            if (!v53) {
              goto LABEL_92;
            }
            uint64_t Operator = MIL::IROpset::TryGetOperator(a2, v53 + 40);
            if (!Operator) {
              goto LABEL_92;
            }
          }
          if (v27 != Operator)
          {
            uint64_t v55 = (uint64_t *)MIL::IRObject::GetLocationPtr(v21);
            uint64_t v56 = (std::__shared_weak_count *)v55[1];
            uint64_t v156 = *v55;
            uint64_t v157 = v56;
            if (v56) {
              atomic_fetch_add_explicit(&v56->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            (*(void (**)(MIL::IRObject *))(*(void *)v21 + 56))(v21);
            std::operator+<char>();
            std::string::size_type v57 = std::string::append(&v154, ") referenced by this operation does not match the operator defined by expected opset ");
            long long v58 = *(_OWORD *)&v57->__r_.__value_.__l.__data_;
            v155.__r_.__value_.__r.__words[2] = v57->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v155.__r_.__value_.__l.__data_ = v58;
            v57->__r_.__value_.__l.__size_ = 0;
            v57->__r_.__value_.__r.__words[2] = 0;
            v57->__r_.__value_.__r.__words[0] = 0;
            uint64_t v59 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
            size_t v61 = v60;
            if (v60 > 0x7FFFFFFFFFFFFFF7) {
              std::string::__throw_length_error[abi:ne180100]();
            }
            char v62 = (const void *)v59;
            if (v60 >= 0x17)
            {
              uint64_t v69 = (v60 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v60 | 7) != 0x17) {
                uint64_t v69 = v60 | 7;
              }
              uint64_t v70 = v69 + 1;
              uint64_t v63 = (void **)operator new(v69 + 1);
              size_t v152 = v61;
              int64_t v153 = v70 | 0x8000000000000000;
              uint64_t v151 = v63;
            }
            else
            {
              HIBYTE(v153) = v60;
              uint64_t v63 = (void **)&v151;
              if (!v60) {
                goto LABEL_83;
              }
            }
            memmove(v63, v62, v61);
LABEL_83:
            *((unsigned char *)v63 + v61) = 0;
            if (v153 >= 0) {
              uint64_t v71 = (const std::string::value_type *)&v151;
            }
            else {
              uint64_t v71 = (const std::string::value_type *)v151;
            }
            if (v153 >= 0) {
              std::string::size_type v72 = HIBYTE(v153);
            }
            else {
              std::string::size_type v72 = v152;
            }
            std::string v73 = std::string::append(&v155, v71, v72);
            long long v74 = *(_OWORD *)&v73->__r_.__value_.__l.__data_;
            v158.__r_.__value_.__r.__words[2] = v73->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v158.__r_.__value_.__l.__data_ = v74;
            v73->__r_.__value_.__l.__size_ = 0;
            v73->__r_.__value_.__r.__words[2] = 0;
            v73->__r_.__value_.__r.__words[0] = 0;
            std::string::size_type v75 = std::string::append(&v158, ". Is it an operator of the same name described by a different opset?");
            long long v76 = *(_OWORD *)&v75->__r_.__value_.__l.__data_;
            __p[0].__r_.__value_.__r.__words[2] = v75->__r_.__value_.__r.__words[2];
            *(_OWORD *)&__p[0].__r_.__value_.__l.__data_ = v76;
            v75->__r_.__value_.__l.__size_ = 0;
            v75->__r_.__value_.__r.__words[2] = 0;
            v75->__r_.__value_.__r.__words[0] = 0;
            MIL::ValidationResult::ValidationResult(v131, &v156, 309, __p);
LABEL_109:
            if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__p[0].__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v158.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v158.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v153) < 0) {
              operator delete(v151);
            }
            if (SHIBYTE(v155.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v155.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v154.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v154.__r_.__value_.__l.__data_);
            }
            std::string::size_type v51 = v157;
            if (!v157) {
              goto LABEL_121;
            }
LABEL_120:
            std::__shared_weak_count::__release_shared[abi:ne180100](v51);
LABEL_121:
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__dst.__r_.__value_.__l.__data_);
            }
            goto LABEL_123;
          }
          if (!(*(uint64_t (**)(uint64_t))(*(void *)v27 + 72))(v27))
          {
LABEL_160:
            (*(void (**)(std::string *__return_ptr, uint64_t, MIL::IRObject *))(*(void *)v27 + 96))(__p, v27, v21);
            if ((*(uint64_t (**)(std::string *))(__p[0].__r_.__value_.__r.__words[0] + 16))(__p))
            {
              MIL::ValidationResult::~ValidationResult((MIL::ValidationResult *)__p);
              uint64_t v108 = (void **)(*(uint64_t (**)(MIL::IRObject *))(*(void *)v21 + 208))(v21);
              uint64_t v109 = (void *)**v108;
              unint64_t v110 = (void *)(*v108)[1];
              while (v109 != v110)
              {
                if (((*(uint64_t (**)(std::string *))(__p[0].__r_.__value_.__r.__words[0] + 16))(__p) & 1) == 0) {
                  goto LABEL_167;
                }
                MIL::ValidationResult::~ValidationResult((MIL::ValidationResult *)__p);
                v109 += 2;
              }
              MIL::ValidationResult::ValidationResult((MIL::ValidationResult *)v131);
            }
            else
            {
LABEL_167:
              MIL::MILResult::MILResult(v131, (uint64_t)__p);
              v131[0].__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_26C25DB50;
              int v132 = v150;
              MIL::ValidationResult::~ValidationResult((MIL::ValidationResult *)__p);
            }
            goto LABEL_121;
          }
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
          {
            std::string::size_type v94 = __dst.__r_.__value_.__l.__size_;
            if (__dst.__r_.__value_.__l.__size_ == 5)
            {
              BOOL v95 = *(_DWORD *)__dst.__r_.__value_.__l.__data_ == 829648745
                 && *(unsigned char *)(__dst.__r_.__value_.__r.__words[0] + 4) == 53;
              if (v95) {
                goto LABEL_160;
              }
              if (*(_DWORD *)__dst.__r_.__value_.__l.__data_ == 829648745
                && *(unsigned char *)(__dst.__r_.__value_.__r.__words[0] + 4) == 54)
              {
                goto LABEL_160;
              }
              std::string::size_type v94 = __dst.__r_.__value_.__l.__size_;
            }
            if (v94 != 11) {
              goto LABEL_152;
            }
            int v68 = (std::string *)__dst.__r_.__value_.__r.__words[0];
          }
          else
          {
            if (HIBYTE(__dst.__r_.__value_.__r.__words[2]) == 5)
            {
              if (LODWORD(__dst.__r_.__value_.__l.__data_) == 829648745 && __dst.__r_.__value_.__s.__data_[4] == 53) {
                goto LABEL_160;
              }
              if (LODWORD(__dst.__r_.__value_.__l.__data_) == 829648745 && __dst.__r_.__value_.__s.__data_[4] == 54) {
                goto LABEL_160;
              }
              goto LABEL_152;
            }
            if (HIBYTE(__dst.__r_.__value_.__r.__words[2]) != 11)
            {
LABEL_152:
              uint64_t v102 = (void *)(*(uint64_t (**)(MIL::IRObject *))(*(void *)v21 + 160))(v21);
              char v104 = (unsigned __int8 *)(v102 + 1);
              unint64_t v103 = (unsigned __int8 *)*v102;
              if ((void *)*v102 != v102 + 1)
              {
                while (1)
                {
                  uint64_t v105 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v27 + 64))(v27);
                  if (!std::__hash_table<std::__hash_value_type<std::string,MIL::IRValueType const*>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,MIL::IRValueType const*>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,MIL::IRValueType const*>>>::find<std::string>(v105, v103 + 32))break; {
                  unint64_t v106 = (unsigned __int8 *)*((void *)v103 + 1);
                  }
                  if (v106)
                  {
                    do
                    {
                      uint64_t v107 = v106;
                      unint64_t v106 = *(unsigned __int8 **)v106;
                    }
                    while (v106);
                  }
                  else
                  {
                    do
                    {
                      uint64_t v107 = (unsigned __int8 *)*((void *)v103 + 2);
                      BOOL v95 = *(void *)v107 == (void)v103;
                      unint64_t v103 = v107;
                    }
                    while (!v95);
                  }
                  unint64_t v103 = v107;
                  if (v107 == v104) {
                    goto LABEL_160;
                  }
                }
                uint64_t v111 = (std::string::size_type *)MIL::IRObject::GetLocationPtr(v21);
                std::string::size_type v112 = v111[1];
                v155.__r_.__value_.__r.__words[0] = *v111;
                v155.__r_.__value_.__l.__size_ = v112;
                if (v112) {
                  atomic_fetch_add_explicit((atomic_ullong *volatile)(v112 + 8), 1uLL, memory_order_relaxed);
                }
                std::operator+<char>();
                long long v113 = std::string::append(&v158, "'.");
                long long v114 = *(_OWORD *)&v113->__r_.__value_.__l.__data_;
                __p[0].__r_.__value_.__r.__words[2] = v113->__r_.__value_.__r.__words[2];
                *(_OWORD *)&__p[0].__r_.__value_.__l.__data_ = v114;
                v113->__r_.__value_.__l.__size_ = 0;
                v113->__r_.__value_.__r.__words[2] = 0;
                v113->__r_.__value_.__r.__words[0] = 0;
                MIL::ValidationResult::ValidationResult(v131, &v155, 315, __p);
LABEL_57:
                if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(__p[0].__r_.__value_.__l.__data_);
                }
                if (SHIBYTE(v158.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v158.__r_.__value_.__l.__data_);
                }
                std::string::size_type v51 = (std::__shared_weak_count *)v155.__r_.__value_.__l.__size_;
                if (!v155.__r_.__value_.__l.__size_) {
                  goto LABEL_121;
                }
                goto LABEL_120;
              }
              goto LABEL_160;
            }
            int v68 = &__dst;
          }
          std::string::size_type v97 = v68->__r_.__value_.__r.__words[0];
          uint64_t v98 = *(std::string::size_type *)((char *)v68->__r_.__value_.__r.__words + 3);
          if (v97 == 0x72745F3631736F69 && v98 == 0x6E696172745F3631) {
            goto LABEL_160;
          }
          goto LABEL_152;
        }
      }
      memmove(p_dst, v30, v31);
      goto LABEL_52;
    }
    if (*(char *)(v17 + 23) < 0)
    {
      if (!*(void *)(v17 + 8))
      {
LABEL_186:
        unint64_t v122 = (uint64_t *)MIL::IRObject::GetLocationPtr(a4);
        uint64_t v123 = (std::__shared_weak_count *)v122[1];
        uint64_t v139 = *v122;
        uint64_t v140 = v123;
        if (v123) {
          atomic_fetch_add_explicit(&v123->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        std::string::basic_string[abi:ne180100]<0>(v137, "Block output names must be non-empty.");
        MIL::ValidationResult::ValidationResult(a5, &v139, 101, v137);
        if (v138 < 0) {
          operator delete(v137[0]);
        }
        uint64_t v117 = v140;
        if (!v140) {
          return;
        }
LABEL_199:
        std::__shared_weak_count::__release_shared[abi:ne180100](v117);
        return;
      }
    }
    else if (!*(unsigned char *)(v17 + 23))
    {
      goto LABEL_186;
    }
    if (!(*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)v8 + 24))(v8, v17, 1)) {
      break;
    }
    v17 += 24;
  }
  long long v124 = (uint64_t *)MIL::IRObject::GetLocationPtr(a4);
  uint64_t v125 = (std::__shared_weak_count *)v124[1];
  uint64_t v135 = *v124;
  uint64_t v136 = v125;
  if (v125) {
    atomic_fetch_add_explicit(&v125->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  std::operator+<char>();
  uint64_t v126 = std::string::append(__p, "' used as block output.");
  long long v127 = *(_OWORD *)&v126->__r_.__value_.__l.__data_;
  std::string::size_type v134 = v126->__r_.__value_.__r.__words[2];
  *(_OWORD *)uint64_t v133 = v127;
  v126->__r_.__value_.__l.__size_ = 0;
  v126->__r_.__value_.__r.__words[2] = 0;
  v126->__r_.__value_.__r.__words[0] = 0;
  MIL::ValidationResult::ValidationResult(a5, &v135, 104, v133);
  if (SHIBYTE(v134) < 0) {
    operator delete(v133[0]);
  }
  if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p[0].__r_.__value_.__l.__data_);
  }
  uint64_t v117 = v136;
  if (v136) {
    goto LABEL_199;
  }
}

void sub_20F4B0C20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,uint64_t a42,void *a43,uint64_t a44,int a45,__int16 a46,char a47,char a48,uint64_t a49,uint64_t a50,void *__p,uint64_t a52,int a53,__int16 a54,char a55,char a56)
{
  if (a56 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v56 - 137) < 0) {
    operator delete(*(void **)(v56 - 160));
  }
  long long v58 = *(std::__shared_weak_count **)(v56 - 200);
  if (v58) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v58);
  }
  if (*(char *)(v56 - 105) < 0) {
    operator delete(*(void **)(v56 - 128));
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::ValidationError::ValidationError(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4)
{
  long long v8 = *a2;
  *(void *)a2 = 0;
  *((void *)a2 + 1) = 0;
  *(_OWORD *)std::string __p = *(_OWORD *)a3;
  uint64_t v7 = *(void *)(a3 + 16);
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)a3 = 0;
  MIL::ValidationResult::ValidationResult(v9, &v8, a4, __p);
  MIL::ValidationError::ValidationError(a1, (uint64_t)v9);
  MIL::ValidationResult::~ValidationResult((MIL::ValidationResult *)v9);
  if (SHIBYTE(v7) < 0) {
    operator delete(__p[0]);
  }
  if (*((void *)&v8 + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v8 + 1));
  }
  return a1;
}

{
  void *__p[2];
  uint64_t v7;
  long long v8;
  unsigned char v9[56];

  long long v8 = *a2;
  *(void *)a2 = 0;
  *((void *)a2 + 1) = 0;
  *(_OWORD *)std::string __p = *(_OWORD *)a3;
  uint64_t v7 = *(void *)(a3 + 16);
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)a3 = 0;
  MIL::ValidationResult::ValidationResult(v9, &v8, a4, __p);
  MIL::ValidationError::ValidationError(a1, (uint64_t)v9);
  MIL::ValidationResult::~ValidationResult((MIL::ValidationResult *)v9);
  if (SHIBYTE(v7) < 0) {
    operator delete(__p[0]);
  }
  if (*((void *)&v8 + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v8 + 1));
  }
  return a1;
}

void sub_20F4B0FA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, char a19)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a17) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a17);
  }
  _Unwind_Resume(a1);
}

uint64_t MIL::ValidationError::ValidationError(uint64_t a1, uint64_t a2)
{
  MIL::MILResult::GetMessageWithLocation((const std::string::value_type **)a2, &__p);
  MIL::MILErrorWithResult::MILErrorWithResult((std::runtime_error *)a1, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  *(void *)a1 = &unk_26C25DAE8;
  *(void *)(a1 + 16) = &unk_26C25A170;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  long long v4 = *(_OWORD *)(a2 + 24);
  *(void *)(a1 + 56) = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 40) = v4;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(a1 + 16) = &unk_26C25DB50;
  *(_DWORD *)(a1 + 64) = *(_DWORD *)(a2 + 48);
  return a1;
}

void sub_20F4B10B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_20F4B1168(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, char a19)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a17) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a17);
  }
  _Unwind_Resume(a1);
}

uint64_t MIL::ValidationError::GetReason(MIL::ValidationError *this)
{
  return MIL::ValidationResult::GetReason((MIL::ValidationError *)((char *)this + 16));
}

uint64_t MIL::ValidationError::GetResult(MIL::ValidationError *this)
{
  return (uint64_t)this + 16;
}

uint64_t MIL::ValidationError::GetValidationResult(MIL::ValidationError *this)
{
  return (uint64_t)this + 16;
}

void MIL::ValidationResult::~ValidationResult(void **this)
{
  MIL::MILResult::~MILResult(this);

  JUMPOUT(0x21056C700);
}

MIL::MILResult *MIL::ValidationResult::ValidationResult(MIL::ValidationResult *this)
{
  uint64_t result = MIL::MILResult::MILResult(this);
  *(void *)uint64_t result = &unk_26C25DB50;
  *((_DWORD *)result + 12) = 2;
  return result;
}

{
  MIL::MILResult *result;

  uint64_t result = MIL::MILResult::MILResult(this);
  *(void *)uint64_t result = &unk_26C25DB50;
  *((_DWORD *)result + 12) = 2;
  return result;
}

uint64_t MIL::ValidationResult::ValidationResult(uint64_t a1, long long *a2, int a3, uint64_t a4)
{
  long long v9 = *a2;
  *(void *)a2 = 0;
  *((void *)a2 + 1) = 0;
  *(_OWORD *)std::string __p = *(_OWORD *)a4;
  uint64_t v8 = *(void *)(a4 + 16);
  *(void *)(a4 + 8) = 0;
  *(void *)(a4 + 16) = 0;
  *(void *)a4 = 0;
  MIL::MILResult::MILResult(a1, (uint64_t)&v9, (__n128 *)__p);
  if (SHIBYTE(v8) < 0) {
    operator delete(__p[0]);
  }
  if (*((void *)&v9 + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v9 + 1));
  }
  *(void *)a1 = &unk_26C25DB50;
  *(_DWORD *)(a1 + 48) = a3;
  return a1;
}

void sub_20F4B1378(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a17) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::ValidationResult::GetReason(MIL::ValidationResult *this)
{
  return *((unsigned int *)this + 12);
}

BOOL MIL::ValidationResult::IsGood(MIL::ValidationResult *this)
{
  return *((_DWORD *)this + 12) == 2;
}

BOOL MIL::MathOps::LogicalNotOp(MIL::MathOps *this)
{
  return this == 0;
}

BOOL MIL::MathOps::LogicalAndOp(MIL::MathOps *this, int a2)
{
  return this == 1 && a2 == 1;
}

BOOL MIL::MathOps::LogicalOrOp(MIL::MathOps *this, int a2)
{
  return this == 1 || a2 == 1;
}

BOOL MIL::MathOps::LogicalXorOp(MIL::MathOps *this, int a2)
{
  return (this != 1 || a2 != 1) && (a2 | this) != 0;
}

void *MIL::ValueInferenceUtils::GetCastedTensor<float>@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  double v4 = MIL::ValueInference::Tensor<float>::Tensor((uint64_t)a2);
  uint64_t v5 = (*(uint64_t (**)(double))(*(void *)*a1 + 32))(v4);
  switch((*(unsigned int (**)(uint64_t))(*(void *)v5 + 88))(v5))
  {
    case 2u:
      uint64_t v6 = (std::__shared_weak_count *)a1[1];
      uint64_t v68 = *a1;
      uint64_t v69 = v6;
      if (v6) {
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<BOOL>::FromIRTensorValue(&v68, (uint64_t)v59);
      if (v69) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v69);
      }
      MIL::ValueInference::Tensor<BOOL>::Cast<float>(v59, (uint64_t)&v76);
      uint64_t v7 = (void *)a2[1];
      if (v7)
      {
        a2[2] = v7;
        operator delete(v7);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v8 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v8)
      {
        a2[5] = v8;
        operator delete(v8);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v9 = v79;
      uint64_t v10 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v9;
      a2[7] = v10;
      MIL::ValueInference::Tensor<float>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<BOOL>::~Tensor(v59);
      break;
    case 4u:
      uint64_t v42 = (std::__shared_weak_count *)a1[1];
      uint64_t v72 = *a1;
      std::string v73 = v42;
      if (v42) {
        atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<MIL::Fp16>::FromIRTensorValue(&v72, (uint64_t)v59);
      if (v73) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v73);
      }
      MIL::ValueInference::Tensor<MIL::Fp16>::Cast<float>(v59, (uint64_t)&v76);
      uint64_t v43 = (void *)a2[1];
      if (v43)
      {
        a2[2] = v43;
        operator delete(v43);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v44 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v44)
      {
        a2[5] = v44;
        operator delete(v44);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v45 = v79;
      uint64_t v46 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v45;
      a2[7] = v46;
      MIL::ValueInference::Tensor<float>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<MIL::Fp16>::~Tensor(v59);
      break;
    case 5u:
      uint64_t v27 = (std::__shared_weak_count *)a1[1];
      uint64_t v81 = *a1;
      unint64_t v82 = v27;
      if (v27) {
        atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<float>::FromIRTensorValue(&v81, (uint64_t)v59);
      if (v82) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v82);
      }
      MIL::ValueInference::Tensor<float>::Cast<float>(v59, (uint64_t)&v76);
      uint64_t v28 = (void *)a2[1];
      if (v28)
      {
        a2[2] = v28;
        operator delete(v28);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      unint64_t v29 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v29)
      {
        a2[5] = v29;
        operator delete(v29);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v30 = v79;
      uint64_t v31 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v30;
      a2[7] = v31;
      MIL::ValueInference::Tensor<float>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<float>::~Tensor(v59);
      break;
    case 7u:
      uint64_t v37 = (std::__shared_weak_count *)a1[1];
      uint64_t v74 = *a1;
      std::string::size_type v75 = v37;
      if (v37) {
        atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<MIL::Bf16>::FromIRTensorValue(&v74, (uint64_t)v59);
      if (v75) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v75);
      }
      MIL::ValueInference::Tensor<MIL::Bf16>::Cast<float>(v59, (uint64_t)&v76);
      std::string::size_type v38 = (void *)a2[1];
      if (v38)
      {
        a2[2] = v38;
        operator delete(v38);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v39 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v39)
      {
        a2[5] = v39;
        operator delete(v39);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v40 = v79;
      uint64_t v41 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v40;
      a2[7] = v41;
      MIL::ValueInference::Tensor<float>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<MIL::Bf16>::~Tensor(v59);
      break;
    case 9u:
      uint64_t v17 = (std::__shared_weak_count *)a1[1];
      uint64_t v66 = *a1;
      std::string::size_type v67 = v17;
      if (v17) {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<signed char>::FromIRTensorValue(&v66, (uint64_t)v59);
      if (v67) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v67);
      }
      MIL::ValueInference::Tensor<signed char>::Cast<float>(v59, (uint64_t)&v76);
      uint64_t v18 = (void *)a2[1];
      if (v18)
      {
        a2[2] = v18;
        operator delete(v18);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v19 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v19)
      {
        a2[5] = v19;
        operator delete(v19);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v20 = v79;
      uint64_t v21 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v20;
      a2[7] = v21;
      MIL::ValueInference::Tensor<float>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<signed char>::~Tensor(v59);
      break;
    case 0xAu:
      uint64_t v22 = (std::__shared_weak_count *)a1[1];
      uint64_t v60 = *a1;
      size_t v61 = v22;
      if (v22) {
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<short>::FromIRTensorValue(&v60, (uint64_t)v59);
      if (v61) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v61);
      }
      MIL::ValueInference::Tensor<short>::Cast<float>(v59, (uint64_t)&v76);
      uint64_t v23 = (void *)a2[1];
      if (v23)
      {
        a2[2] = v23;
        operator delete(v23);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v24 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v24)
      {
        a2[5] = v24;
        operator delete(v24);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v25 = v79;
      uint64_t v26 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v25;
      a2[7] = v26;
      MIL::ValueInference::Tensor<float>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<short>::~Tensor(v59);
      break;
    case 0xBu:
      uint64_t v47 = (std::__shared_weak_count *)a1[1];
      uint64_t v70 = *a1;
      uint64_t v71 = v47;
      if (v47) {
        atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<int>::FromIRTensorValue(&v70, (uint64_t)v59);
      if (v71) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v71);
      }
      MIL::ValueInference::Tensor<int>::Cast<float>(v59, (uint64_t)&v76);
      std::string::size_type v48 = (void *)a2[1];
      if (v48)
      {
        a2[2] = v48;
        operator delete(v48);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v49 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v49)
      {
        a2[5] = v49;
        operator delete(v49);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v50 = v79;
      uint64_t v51 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v50;
      a2[7] = v51;
      MIL::ValueInference::Tensor<float>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<int>::~Tensor(v59);
      break;
    case 0xEu:
      uint64_t v32 = (std::__shared_weak_count *)a1[1];
      uint64_t v64 = *a1;
      std::string v65 = v32;
      if (v32) {
        atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<unsigned char>::FromIRTensorValue(&v64, (uint64_t)v59);
      if (v65) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v65);
      }
      MIL::ValueInference::Tensor<unsigned char>::Cast<float>(v59, (uint64_t)&v76);
      uint64_t v33 = (void *)a2[1];
      if (v33)
      {
        a2[2] = v33;
        operator delete(v33);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      std::string::size_type v34 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v34)
      {
        a2[5] = v34;
        operator delete(v34);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v35 = v79;
      uint64_t v36 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v35;
      a2[7] = v36;
      MIL::ValueInference::Tensor<float>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<unsigned char>::~Tensor(v59);
      break;
    case 0xFu:
      BOOL v12 = (std::__shared_weak_count *)a1[1];
      uint64_t v62 = *a1;
      uint64_t v63 = v12;
      if (v12) {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<unsigned short>::FromIRTensorValue(&v62, (uint64_t)v59);
      if (v63) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v63);
      }
      MIL::ValueInference::Tensor<unsigned short>::Cast<float>(v59, (uint64_t)&v76);
      long long v13 = (void *)a2[1];
      if (v13)
      {
        a2[2] = v13;
        operator delete(v13);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v14 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v14)
      {
        a2[5] = v14;
        operator delete(v14);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v15 = v79;
      uint64_t v16 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v15;
      a2[7] = v16;
      MIL::ValueInference::Tensor<float>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<unsigned short>::~Tensor(v59);
      break;
    default:
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v59);
      std::string v52 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v59, (uint64_t)"Unsupported Datatype ", 21);
      uint64_t v53 = (*(uint64_t (**)(void))(*(void *)*a1 + 32))();
      int v54 = (*(uint64_t (**)(uint64_t))(*(void *)v53 + 88))(v53);
      MIL::IRDataTypeToString(v54, &v76);
      if ((v76.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v55 = &v76;
      }
      else {
        uint64_t v55 = (std::string *)v76.__r_.__value_.__r.__words[0];
      }
      if ((v76.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(v76.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = v76.__r_.__value_.__l.__size_;
      }
      std::string::size_type v57 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v52, (uint64_t)v55, size);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v57, (uint64_t)".", 1);
      if (SHIBYTE(v76.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v76.__r_.__value_.__l.__data_);
      }
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::stringbuf::str();
      std::logic_error::logic_error(exception, &v76);
      exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
      __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  return result;
}

void sub_20F4B1CFC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (*(char *)(v5 - 105) < 0)
  {
    operator delete(*(void **)(v5 - 128));
    if ((v4 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)va);
      MIL::ValueInference::Tensor<float>::~Tensor(v2);
      _Unwind_Resume(a1);
    }
  }
  else if (!v4)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v3);
  goto LABEL_6;
}

void *MIL::ValueInferenceUtils::GetCastedTensor<MIL::Fp16>@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  double v4 = MIL::ValueInference::Tensor<MIL::Fp16>::Tensor((uint64_t)a2);
  uint64_t v5 = (*(uint64_t (**)(double))(*(void *)*a1 + 32))(v4);
  switch((*(unsigned int (**)(uint64_t))(*(void *)v5 + 88))(v5))
  {
    case 2u:
      uint64_t v6 = (std::__shared_weak_count *)a1[1];
      uint64_t v68 = *a1;
      uint64_t v69 = v6;
      if (v6) {
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<BOOL>::FromIRTensorValue(&v68, (uint64_t)v59);
      if (v69) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v69);
      }
      MIL::ValueInference::Tensor<BOOL>::Cast<MIL::Fp16>(v59, (uint64_t)&v76);
      uint64_t v7 = (void *)a2[1];
      if (v7)
      {
        a2[2] = v7;
        operator delete(v7);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v8 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v8)
      {
        a2[5] = v8;
        operator delete(v8);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v9 = v79;
      uint64_t v10 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v9;
      a2[7] = v10;
      MIL::ValueInference::Tensor<MIL::Fp16>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<BOOL>::~Tensor(v59);
      break;
    case 4u:
      uint64_t v42 = (std::__shared_weak_count *)a1[1];
      uint64_t v72 = *a1;
      std::string v73 = v42;
      if (v42) {
        atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<MIL::Fp16>::FromIRTensorValue(&v72, (uint64_t)v59);
      if (v73) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v73);
      }
      MIL::ValueInference::Tensor<MIL::Fp16>::Cast<MIL::Fp16>(v59, (uint64_t)&v76);
      uint64_t v43 = (void *)a2[1];
      if (v43)
      {
        a2[2] = v43;
        operator delete(v43);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v44 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v44)
      {
        a2[5] = v44;
        operator delete(v44);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v45 = v79;
      uint64_t v46 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v45;
      a2[7] = v46;
      MIL::ValueInference::Tensor<MIL::Fp16>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<MIL::Fp16>::~Tensor(v59);
      break;
    case 5u:
      uint64_t v27 = (std::__shared_weak_count *)a1[1];
      uint64_t v81 = *a1;
      unint64_t v82 = v27;
      if (v27) {
        atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<float>::FromIRTensorValue(&v81, (uint64_t)v59);
      if (v82) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v82);
      }
      MIL::ValueInference::Tensor<float>::Cast<MIL::Fp16>(v59, (uint64_t)&v76);
      uint64_t v28 = (void *)a2[1];
      if (v28)
      {
        a2[2] = v28;
        operator delete(v28);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      unint64_t v29 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v29)
      {
        a2[5] = v29;
        operator delete(v29);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v30 = v79;
      uint64_t v31 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v30;
      a2[7] = v31;
      MIL::ValueInference::Tensor<MIL::Fp16>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<float>::~Tensor(v59);
      break;
    case 7u:
      uint64_t v37 = (std::__shared_weak_count *)a1[1];
      uint64_t v74 = *a1;
      std::string::size_type v75 = v37;
      if (v37) {
        atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<MIL::Bf16>::FromIRTensorValue(&v74, (uint64_t)v59);
      if (v75) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v75);
      }
      MIL::ValueInference::Tensor<MIL::Bf16>::Cast<MIL::Fp16>(v59, (uint64_t)&v76);
      std::string::size_type v38 = (void *)a2[1];
      if (v38)
      {
        a2[2] = v38;
        operator delete(v38);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v39 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v39)
      {
        a2[5] = v39;
        operator delete(v39);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v40 = v79;
      uint64_t v41 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v40;
      a2[7] = v41;
      MIL::ValueInference::Tensor<MIL::Fp16>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<MIL::Bf16>::~Tensor(v59);
      break;
    case 9u:
      uint64_t v17 = (std::__shared_weak_count *)a1[1];
      uint64_t v66 = *a1;
      std::string::size_type v67 = v17;
      if (v17) {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<signed char>::FromIRTensorValue(&v66, (uint64_t)v59);
      if (v67) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v67);
      }
      MIL::ValueInference::Tensor<signed char>::Cast<MIL::Fp16>(v59, (uint64_t)&v76);
      uint64_t v18 = (void *)a2[1];
      if (v18)
      {
        a2[2] = v18;
        operator delete(v18);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v19 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v19)
      {
        a2[5] = v19;
        operator delete(v19);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v20 = v79;
      uint64_t v21 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v20;
      a2[7] = v21;
      MIL::ValueInference::Tensor<MIL::Fp16>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<signed char>::~Tensor(v59);
      break;
    case 0xAu:
      uint64_t v22 = (std::__shared_weak_count *)a1[1];
      uint64_t v60 = *a1;
      size_t v61 = v22;
      if (v22) {
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<short>::FromIRTensorValue(&v60, (uint64_t)v59);
      if (v61) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v61);
      }
      MIL::ValueInference::Tensor<short>::Cast<MIL::Fp16>(v59, (uint64_t)&v76);
      uint64_t v23 = (void *)a2[1];
      if (v23)
      {
        a2[2] = v23;
        operator delete(v23);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v24 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v24)
      {
        a2[5] = v24;
        operator delete(v24);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v25 = v79;
      uint64_t v26 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v25;
      a2[7] = v26;
      MIL::ValueInference::Tensor<MIL::Fp16>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<short>::~Tensor(v59);
      break;
    case 0xBu:
      uint64_t v47 = (std::__shared_weak_count *)a1[1];
      uint64_t v70 = *a1;
      uint64_t v71 = v47;
      if (v47) {
        atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<int>::FromIRTensorValue(&v70, (uint64_t)v59);
      if (v71) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v71);
      }
      MIL::ValueInference::Tensor<int>::Cast<MIL::Fp16>(v59, (uint64_t)&v76);
      std::string::size_type v48 = (void *)a2[1];
      if (v48)
      {
        a2[2] = v48;
        operator delete(v48);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v49 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v49)
      {
        a2[5] = v49;
        operator delete(v49);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v50 = v79;
      uint64_t v51 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v50;
      a2[7] = v51;
      MIL::ValueInference::Tensor<MIL::Fp16>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<int>::~Tensor(v59);
      break;
    case 0xEu:
      uint64_t v32 = (std::__shared_weak_count *)a1[1];
      uint64_t v64 = *a1;
      std::string v65 = v32;
      if (v32) {
        atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<unsigned char>::FromIRTensorValue(&v64, (uint64_t)v59);
      if (v65) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v65);
      }
      MIL::ValueInference::Tensor<unsigned char>::Cast<MIL::Fp16>(v59, (uint64_t)&v76);
      uint64_t v33 = (void *)a2[1];
      if (v33)
      {
        a2[2] = v33;
        operator delete(v33);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      std::string::size_type v34 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v34)
      {
        a2[5] = v34;
        operator delete(v34);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v35 = v79;
      uint64_t v36 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v35;
      a2[7] = v36;
      MIL::ValueInference::Tensor<MIL::Fp16>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<unsigned char>::~Tensor(v59);
      break;
    case 0xFu:
      BOOL v12 = (std::__shared_weak_count *)a1[1];
      uint64_t v62 = *a1;
      uint64_t v63 = v12;
      if (v12) {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<unsigned short>::FromIRTensorValue(&v62, (uint64_t)v59);
      if (v63) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v63);
      }
      MIL::ValueInference::Tensor<unsigned short>::Cast<MIL::Fp16>(v59, (uint64_t)&v76);
      long long v13 = (void *)a2[1];
      if (v13)
      {
        a2[2] = v13;
        operator delete(v13);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v14 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v14)
      {
        a2[5] = v14;
        operator delete(v14);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v15 = v79;
      uint64_t v16 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v15;
      a2[7] = v16;
      MIL::ValueInference::Tensor<MIL::Fp16>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<unsigned short>::~Tensor(v59);
      break;
    default:
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v59);
      std::string v52 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v59, (uint64_t)"Unsupported Datatype ", 21);
      uint64_t v53 = (*(uint64_t (**)(void))(*(void *)*a1 + 32))();
      int v54 = (*(uint64_t (**)(uint64_t))(*(void *)v53 + 88))(v53);
      MIL::IRDataTypeToString(v54, &v76);
      if ((v76.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v55 = &v76;
      }
      else {
        uint64_t v55 = (std::string *)v76.__r_.__value_.__r.__words[0];
      }
      if ((v76.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(v76.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = v76.__r_.__value_.__l.__size_;
      }
      std::string::size_type v57 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v52, (uint64_t)v55, size);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v57, (uint64_t)".", 1);
      if (SHIBYTE(v76.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v76.__r_.__value_.__l.__data_);
      }
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::stringbuf::str();
      std::logic_error::logic_error(exception, &v76);
      exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
      __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  return result;
}

void sub_20F4B27D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (*(char *)(v5 - 105) < 0)
  {
    operator delete(*(void **)(v5 - 128));
    if ((v4 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)va);
      MIL::ValueInference::Tensor<MIL::Fp16>::~Tensor(v2);
      _Unwind_Resume(a1);
    }
  }
  else if (!v4)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v3);
  goto LABEL_6;
}

void *MIL::ValueInferenceUtils::GetCastedTensor<MIL::Bf16>@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  double v4 = MIL::ValueInference::Tensor<MIL::Bf16>::Tensor((uint64_t)a2);
  uint64_t v5 = (*(uint64_t (**)(double))(*(void *)*a1 + 32))(v4);
  switch((*(unsigned int (**)(uint64_t))(*(void *)v5 + 88))(v5))
  {
    case 2u:
      uint64_t v6 = (std::__shared_weak_count *)a1[1];
      uint64_t v68 = *a1;
      uint64_t v69 = v6;
      if (v6) {
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<BOOL>::FromIRTensorValue(&v68, (uint64_t)v59);
      if (v69) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v69);
      }
      MIL::ValueInference::Tensor<BOOL>::Cast<MIL::Bf16>(v59, (uint64_t)&v76);
      uint64_t v7 = (void *)a2[1];
      if (v7)
      {
        a2[2] = v7;
        operator delete(v7);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v8 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v8)
      {
        a2[5] = v8;
        operator delete(v8);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v9 = v79;
      uint64_t v10 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v9;
      a2[7] = v10;
      MIL::ValueInference::Tensor<MIL::Bf16>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<BOOL>::~Tensor(v59);
      break;
    case 4u:
      uint64_t v42 = (std::__shared_weak_count *)a1[1];
      uint64_t v72 = *a1;
      std::string v73 = v42;
      if (v42) {
        atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<MIL::Fp16>::FromIRTensorValue(&v72, (uint64_t)v59);
      if (v73) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v73);
      }
      MIL::ValueInference::Tensor<MIL::Fp16>::Cast<MIL::Bf16>(v59, (uint64_t)&v76);
      uint64_t v43 = (void *)a2[1];
      if (v43)
      {
        a2[2] = v43;
        operator delete(v43);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v44 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v44)
      {
        a2[5] = v44;
        operator delete(v44);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v45 = v79;
      uint64_t v46 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v45;
      a2[7] = v46;
      MIL::ValueInference::Tensor<MIL::Bf16>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<MIL::Fp16>::~Tensor(v59);
      break;
    case 5u:
      uint64_t v27 = (std::__shared_weak_count *)a1[1];
      uint64_t v81 = *a1;
      unint64_t v82 = v27;
      if (v27) {
        atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<float>::FromIRTensorValue(&v81, (uint64_t)v59);
      if (v82) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v82);
      }
      MIL::ValueInference::Tensor<float>::Cast<MIL::Bf16>(v59, (uint64_t)&v76);
      uint64_t v28 = (void *)a2[1];
      if (v28)
      {
        a2[2] = v28;
        operator delete(v28);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      unint64_t v29 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v29)
      {
        a2[5] = v29;
        operator delete(v29);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v30 = v79;
      uint64_t v31 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v30;
      a2[7] = v31;
      MIL::ValueInference::Tensor<MIL::Bf16>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<float>::~Tensor(v59);
      break;
    case 7u:
      uint64_t v37 = (std::__shared_weak_count *)a1[1];
      uint64_t v74 = *a1;
      std::string::size_type v75 = v37;
      if (v37) {
        atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<MIL::Bf16>::FromIRTensorValue(&v74, (uint64_t)v59);
      if (v75) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v75);
      }
      MIL::ValueInference::Tensor<MIL::Bf16>::Cast<MIL::Bf16>(v59, (uint64_t)&v76);
      std::string::size_type v38 = (void *)a2[1];
      if (v38)
      {
        a2[2] = v38;
        operator delete(v38);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v39 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v39)
      {
        a2[5] = v39;
        operator delete(v39);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v40 = v79;
      uint64_t v41 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v40;
      a2[7] = v41;
      MIL::ValueInference::Tensor<MIL::Bf16>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<MIL::Bf16>::~Tensor(v59);
      break;
    case 9u:
      uint64_t v17 = (std::__shared_weak_count *)a1[1];
      uint64_t v66 = *a1;
      std::string::size_type v67 = v17;
      if (v17) {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<signed char>::FromIRTensorValue(&v66, (uint64_t)v59);
      if (v67) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v67);
      }
      MIL::ValueInference::Tensor<signed char>::Cast<MIL::Bf16>(v59, (uint64_t)&v76);
      uint64_t v18 = (void *)a2[1];
      if (v18)
      {
        a2[2] = v18;
        operator delete(v18);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v19 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v19)
      {
        a2[5] = v19;
        operator delete(v19);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v20 = v79;
      uint64_t v21 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v20;
      a2[7] = v21;
      MIL::ValueInference::Tensor<MIL::Bf16>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<signed char>::~Tensor(v59);
      break;
    case 0xAu:
      uint64_t v22 = (std::__shared_weak_count *)a1[1];
      uint64_t v60 = *a1;
      size_t v61 = v22;
      if (v22) {
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<short>::FromIRTensorValue(&v60, (uint64_t)v59);
      if (v61) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v61);
      }
      MIL::ValueInference::Tensor<short>::Cast<MIL::Bf16>(v59, (uint64_t)&v76);
      uint64_t v23 = (void *)a2[1];
      if (v23)
      {
        a2[2] = v23;
        operator delete(v23);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v24 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v24)
      {
        a2[5] = v24;
        operator delete(v24);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v25 = v79;
      uint64_t v26 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v25;
      a2[7] = v26;
      MIL::ValueInference::Tensor<MIL::Bf16>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<short>::~Tensor(v59);
      break;
    case 0xBu:
      uint64_t v47 = (std::__shared_weak_count *)a1[1];
      uint64_t v70 = *a1;
      uint64_t v71 = v47;
      if (v47) {
        atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<int>::FromIRTensorValue(&v70, (uint64_t)v59);
      if (v71) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v71);
      }
      MIL::ValueInference::Tensor<int>::Cast<MIL::Bf16>(v59, (uint64_t)&v76);
      std::string::size_type v48 = (void *)a2[1];
      if (v48)
      {
        a2[2] = v48;
        operator delete(v48);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v49 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v49)
      {
        a2[5] = v49;
        operator delete(v49);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v50 = v79;
      uint64_t v51 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v50;
      a2[7] = v51;
      MIL::ValueInference::Tensor<MIL::Bf16>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<int>::~Tensor(v59);
      break;
    case 0xEu:
      uint64_t v32 = (std::__shared_weak_count *)a1[1];
      uint64_t v64 = *a1;
      std::string v65 = v32;
      if (v32) {
        atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<unsigned char>::FromIRTensorValue(&v64, (uint64_t)v59);
      if (v65) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v65);
      }
      MIL::ValueInference::Tensor<unsigned char>::Cast<MIL::Bf16>(v59, (uint64_t)&v76);
      uint64_t v33 = (void *)a2[1];
      if (v33)
      {
        a2[2] = v33;
        operator delete(v33);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      std::string::size_type v34 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v34)
      {
        a2[5] = v34;
        operator delete(v34);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v35 = v79;
      uint64_t v36 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v35;
      a2[7] = v36;
      MIL::ValueInference::Tensor<MIL::Bf16>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<unsigned char>::~Tensor(v59);
      break;
    case 0xFu:
      BOOL v12 = (std::__shared_weak_count *)a1[1];
      uint64_t v62 = *a1;
      uint64_t v63 = v12;
      if (v12) {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<unsigned short>::FromIRTensorValue(&v62, (uint64_t)v59);
      if (v63) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v63);
      }
      MIL::ValueInference::Tensor<unsigned short>::Cast<MIL::Bf16>(v59, (uint64_t)&v76);
      long long v13 = (void *)a2[1];
      if (v13)
      {
        a2[2] = v13;
        operator delete(v13);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v14 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v14)
      {
        a2[5] = v14;
        operator delete(v14);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v15 = v79;
      uint64_t v16 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v15;
      a2[7] = v16;
      MIL::ValueInference::Tensor<MIL::Bf16>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<unsigned short>::~Tensor(v59);
      break;
    default:
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v59);
      std::string v52 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v59, (uint64_t)"Unsupported Datatype ", 21);
      uint64_t v53 = (*(uint64_t (**)(void))(*(void *)*a1 + 32))();
      int v54 = (*(uint64_t (**)(uint64_t))(*(void *)v53 + 88))(v53);
      MIL::IRDataTypeToString(v54, &v76);
      if ((v76.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v55 = &v76;
      }
      else {
        uint64_t v55 = (std::string *)v76.__r_.__value_.__r.__words[0];
      }
      if ((v76.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(v76.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = v76.__r_.__value_.__l.__size_;
      }
      std::string::size_type v57 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v52, (uint64_t)v55, size);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v57, (uint64_t)".", 1);
      if (SHIBYTE(v76.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v76.__r_.__value_.__l.__data_);
      }
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::stringbuf::str();
      std::logic_error::logic_error(exception, &v76);
      exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
      __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  return result;
}

void sub_20F4B3290(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (*(char *)(v5 - 105) < 0)
  {
    operator delete(*(void **)(v5 - 128));
    if ((v4 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)va);
      MIL::ValueInference::Tensor<MIL::Bf16>::~Tensor(v2);
      _Unwind_Resume(a1);
    }
  }
  else if (!v4)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v3);
  goto LABEL_6;
}

void *MIL::ValueInferenceUtils::GetCastedTensor<int>@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  double v4 = MIL::ValueInference::Tensor<int>::Tensor((uint64_t)a2);
  uint64_t v5 = (*(uint64_t (**)(double))(*(void *)*a1 + 32))(v4);
  switch((*(unsigned int (**)(uint64_t))(*(void *)v5 + 88))(v5))
  {
    case 2u:
      uint64_t v6 = (std::__shared_weak_count *)a1[1];
      uint64_t v68 = *a1;
      uint64_t v69 = v6;
      if (v6) {
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<BOOL>::FromIRTensorValue(&v68, (uint64_t)v59);
      if (v69) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v69);
      }
      MIL::ValueInference::Tensor<BOOL>::Cast<int>(v59, (uint64_t)&v76);
      uint64_t v7 = (void *)a2[1];
      if (v7)
      {
        a2[2] = v7;
        operator delete(v7);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v8 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v8)
      {
        a2[5] = v8;
        operator delete(v8);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v9 = v79;
      uint64_t v10 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v9;
      a2[7] = v10;
      MIL::ValueInference::Tensor<int>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<BOOL>::~Tensor(v59);
      break;
    case 4u:
      uint64_t v42 = (std::__shared_weak_count *)a1[1];
      uint64_t v72 = *a1;
      std::string v73 = v42;
      if (v42) {
        atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<MIL::Fp16>::FromIRTensorValue(&v72, (uint64_t)v59);
      if (v73) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v73);
      }
      MIL::ValueInference::Tensor<MIL::Fp16>::Cast<int>(v59, (uint64_t)&v76);
      uint64_t v43 = (void *)a2[1];
      if (v43)
      {
        a2[2] = v43;
        operator delete(v43);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v44 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v44)
      {
        a2[5] = v44;
        operator delete(v44);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v45 = v79;
      uint64_t v46 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v45;
      a2[7] = v46;
      MIL::ValueInference::Tensor<int>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<MIL::Fp16>::~Tensor(v59);
      break;
    case 5u:
      uint64_t v27 = (std::__shared_weak_count *)a1[1];
      uint64_t v81 = *a1;
      unint64_t v82 = v27;
      if (v27) {
        atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<float>::FromIRTensorValue(&v81, (uint64_t)v59);
      if (v82) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v82);
      }
      MIL::ValueInference::Tensor<float>::Cast<int>(v59, (uint64_t)&v76);
      uint64_t v28 = (void *)a2[1];
      if (v28)
      {
        a2[2] = v28;
        operator delete(v28);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      unint64_t v29 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v29)
      {
        a2[5] = v29;
        operator delete(v29);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v30 = v79;
      uint64_t v31 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v30;
      a2[7] = v31;
      MIL::ValueInference::Tensor<int>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<float>::~Tensor(v59);
      break;
    case 7u:
      uint64_t v37 = (std::__shared_weak_count *)a1[1];
      uint64_t v74 = *a1;
      std::string::size_type v75 = v37;
      if (v37) {
        atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<MIL::Bf16>::FromIRTensorValue(&v74, (uint64_t)v59);
      if (v75) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v75);
      }
      MIL::ValueInference::Tensor<MIL::Bf16>::Cast<int>(v59, (uint64_t)&v76);
      std::string::size_type v38 = (void *)a2[1];
      if (v38)
      {
        a2[2] = v38;
        operator delete(v38);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v39 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v39)
      {
        a2[5] = v39;
        operator delete(v39);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v40 = v79;
      uint64_t v41 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v40;
      a2[7] = v41;
      MIL::ValueInference::Tensor<int>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<MIL::Bf16>::~Tensor(v59);
      break;
    case 9u:
      uint64_t v17 = (std::__shared_weak_count *)a1[1];
      uint64_t v66 = *a1;
      std::string::size_type v67 = v17;
      if (v17) {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<signed char>::FromIRTensorValue(&v66, (uint64_t)v59);
      if (v67) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v67);
      }
      MIL::ValueInference::Tensor<signed char>::Cast<int>(v59, (uint64_t)&v76);
      uint64_t v18 = (void *)a2[1];
      if (v18)
      {
        a2[2] = v18;
        operator delete(v18);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v19 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v19)
      {
        a2[5] = v19;
        operator delete(v19);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v20 = v79;
      uint64_t v21 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v20;
      a2[7] = v21;
      MIL::ValueInference::Tensor<int>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<signed char>::~Tensor(v59);
      break;
    case 0xAu:
      uint64_t v22 = (std::__shared_weak_count *)a1[1];
      uint64_t v60 = *a1;
      size_t v61 = v22;
      if (v22) {
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<short>::FromIRTensorValue(&v60, (uint64_t)v59);
      if (v61) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v61);
      }
      MIL::ValueInference::Tensor<short>::Cast<int>(v59, (uint64_t)&v76);
      uint64_t v23 = (void *)a2[1];
      if (v23)
      {
        a2[2] = v23;
        operator delete(v23);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v24 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v24)
      {
        a2[5] = v24;
        operator delete(v24);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v25 = v79;
      uint64_t v26 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v25;
      a2[7] = v26;
      MIL::ValueInference::Tensor<int>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<short>::~Tensor(v59);
      break;
    case 0xBu:
      uint64_t v47 = (std::__shared_weak_count *)a1[1];
      uint64_t v70 = *a1;
      uint64_t v71 = v47;
      if (v47) {
        atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<int>::FromIRTensorValue(&v70, (uint64_t)v59);
      if (v71) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v71);
      }
      MIL::ValueInference::Tensor<int>::Cast<int>(v59, (uint64_t)&v76);
      std::string::size_type v48 = (void *)a2[1];
      if (v48)
      {
        a2[2] = v48;
        operator delete(v48);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v49 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v49)
      {
        a2[5] = v49;
        operator delete(v49);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v50 = v79;
      uint64_t v51 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v50;
      a2[7] = v51;
      MIL::ValueInference::Tensor<int>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<int>::~Tensor(v59);
      break;
    case 0xEu:
      uint64_t v32 = (std::__shared_weak_count *)a1[1];
      uint64_t v64 = *a1;
      std::string v65 = v32;
      if (v32) {
        atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<unsigned char>::FromIRTensorValue(&v64, (uint64_t)v59);
      if (v65) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v65);
      }
      MIL::ValueInference::Tensor<unsigned char>::Cast<int>(v59, (uint64_t)&v76);
      uint64_t v33 = (void *)a2[1];
      if (v33)
      {
        a2[2] = v33;
        operator delete(v33);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      std::string::size_type v34 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v34)
      {
        a2[5] = v34;
        operator delete(v34);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v35 = v79;
      uint64_t v36 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v35;
      a2[7] = v36;
      MIL::ValueInference::Tensor<int>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<unsigned char>::~Tensor(v59);
      break;
    case 0xFu:
      BOOL v12 = (std::__shared_weak_count *)a1[1];
      uint64_t v62 = *a1;
      uint64_t v63 = v12;
      if (v12) {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<unsigned short>::FromIRTensorValue(&v62, (uint64_t)v59);
      if (v63) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v63);
      }
      MIL::ValueInference::Tensor<unsigned short>::Cast<int>(v59, (uint64_t)&v76);
      long long v13 = (void *)a2[1];
      if (v13)
      {
        a2[2] = v13;
        operator delete(v13);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v14 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v14)
      {
        a2[5] = v14;
        operator delete(v14);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v15 = v79;
      uint64_t v16 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v15;
      a2[7] = v16;
      MIL::ValueInference::Tensor<int>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<unsigned short>::~Tensor(v59);
      break;
    default:
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v59);
      std::string v52 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v59, (uint64_t)"Unsupported Datatype ", 21);
      uint64_t v53 = (*(uint64_t (**)(void))(*(void *)*a1 + 32))();
      int v54 = (*(uint64_t (**)(uint64_t))(*(void *)v53 + 88))(v53);
      MIL::IRDataTypeToString(v54, &v76);
      if ((v76.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v55 = &v76;
      }
      else {
        uint64_t v55 = (std::string *)v76.__r_.__value_.__r.__words[0];
      }
      if ((v76.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(v76.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = v76.__r_.__value_.__l.__size_;
      }
      std::string::size_type v57 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v52, (uint64_t)v55, size);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v57, (uint64_t)".", 1);
      if (SHIBYTE(v76.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v76.__r_.__value_.__l.__data_);
      }
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::stringbuf::str();
      std::logic_error::logic_error(exception, &v76);
      exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
      __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  return result;
}

void sub_20F4B3D50(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (*(char *)(v5 - 105) < 0)
  {
    operator delete(*(void **)(v5 - 128));
    if ((v4 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)va);
      MIL::ValueInference::Tensor<int>::~Tensor(v2);
      _Unwind_Resume(a1);
    }
  }
  else if (!v4)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v3);
  goto LABEL_6;
}

void *MIL::ValueInferenceUtils::GetCastedTensor<BOOL>@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  double v4 = MIL::ValueInference::Tensor<BOOL>::Tensor((uint64_t)a2);
  uint64_t v5 = (*(uint64_t (**)(double))(*(void *)*a1 + 32))(v4);
  switch((*(unsigned int (**)(uint64_t))(*(void *)v5 + 88))(v5))
  {
    case 2u:
      uint64_t v6 = (std::__shared_weak_count *)a1[1];
      uint64_t v68 = *a1;
      uint64_t v69 = v6;
      if (v6) {
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<BOOL>::FromIRTensorValue(&v68, (uint64_t)v59);
      if (v69) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v69);
      }
      MIL::ValueInference::Tensor<BOOL>::Cast<BOOL>(v59, (uint64_t)&v76);
      uint64_t v7 = (void *)a2[1];
      if (v7)
      {
        a2[2] = v7;
        operator delete(v7);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v8 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v8)
      {
        a2[5] = v8;
        operator delete(v8);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v9 = v79;
      uint64_t v10 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v9;
      a2[7] = v10;
      MIL::ValueInference::Tensor<BOOL>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<BOOL>::~Tensor(v59);
      break;
    case 4u:
      uint64_t v42 = (std::__shared_weak_count *)a1[1];
      uint64_t v72 = *a1;
      std::string v73 = v42;
      if (v42) {
        atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<MIL::Fp16>::FromIRTensorValue(&v72, (uint64_t)v59);
      if (v73) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v73);
      }
      MIL::ValueInference::Tensor<MIL::Fp16>::Cast<BOOL>(v59, (uint64_t)&v76);
      uint64_t v43 = (void *)a2[1];
      if (v43)
      {
        a2[2] = v43;
        operator delete(v43);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v44 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v44)
      {
        a2[5] = v44;
        operator delete(v44);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v45 = v79;
      uint64_t v46 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v45;
      a2[7] = v46;
      MIL::ValueInference::Tensor<BOOL>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<MIL::Fp16>::~Tensor(v59);
      break;
    case 5u:
      uint64_t v27 = (std::__shared_weak_count *)a1[1];
      uint64_t v81 = *a1;
      unint64_t v82 = v27;
      if (v27) {
        atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<float>::FromIRTensorValue(&v81, (uint64_t)v59);
      if (v82) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v82);
      }
      MIL::ValueInference::Tensor<float>::Cast<BOOL>(v59, (uint64_t)&v76);
      uint64_t v28 = (void *)a2[1];
      if (v28)
      {
        a2[2] = v28;
        operator delete(v28);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      unint64_t v29 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v29)
      {
        a2[5] = v29;
        operator delete(v29);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v30 = v79;
      uint64_t v31 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v30;
      a2[7] = v31;
      MIL::ValueInference::Tensor<BOOL>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<float>::~Tensor(v59);
      break;
    case 7u:
      uint64_t v37 = (std::__shared_weak_count *)a1[1];
      uint64_t v74 = *a1;
      std::string::size_type v75 = v37;
      if (v37) {
        atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<MIL::Bf16>::FromIRTensorValue(&v74, (uint64_t)v59);
      if (v75) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v75);
      }
      MIL::ValueInference::Tensor<MIL::Bf16>::Cast<BOOL>(v59, (uint64_t)&v76);
      std::string::size_type v38 = (void *)a2[1];
      if (v38)
      {
        a2[2] = v38;
        operator delete(v38);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v39 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v39)
      {
        a2[5] = v39;
        operator delete(v39);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v40 = v79;
      uint64_t v41 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v40;
      a2[7] = v41;
      MIL::ValueInference::Tensor<BOOL>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<MIL::Bf16>::~Tensor(v59);
      break;
    case 9u:
      uint64_t v17 = (std::__shared_weak_count *)a1[1];
      uint64_t v66 = *a1;
      std::string::size_type v67 = v17;
      if (v17) {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<signed char>::FromIRTensorValue(&v66, (uint64_t)v59);
      if (v67) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v67);
      }
      MIL::ValueInference::Tensor<signed char>::Cast<BOOL>(v59, (uint64_t)&v76);
      uint64_t v18 = (void *)a2[1];
      if (v18)
      {
        a2[2] = v18;
        operator delete(v18);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v19 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v19)
      {
        a2[5] = v19;
        operator delete(v19);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v20 = v79;
      uint64_t v21 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v20;
      a2[7] = v21;
      MIL::ValueInference::Tensor<BOOL>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<signed char>::~Tensor(v59);
      break;
    case 0xAu:
      uint64_t v22 = (std::__shared_weak_count *)a1[1];
      uint64_t v60 = *a1;
      size_t v61 = v22;
      if (v22) {
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<short>::FromIRTensorValue(&v60, (uint64_t)v59);
      if (v61) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v61);
      }
      MIL::ValueInference::Tensor<short>::Cast<BOOL>(v59, (uint64_t)&v76);
      uint64_t v23 = (void *)a2[1];
      if (v23)
      {
        a2[2] = v23;
        operator delete(v23);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v24 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v24)
      {
        a2[5] = v24;
        operator delete(v24);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v25 = v79;
      uint64_t v26 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v25;
      a2[7] = v26;
      MIL::ValueInference::Tensor<BOOL>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<short>::~Tensor(v59);
      break;
    case 0xBu:
      uint64_t v47 = (std::__shared_weak_count *)a1[1];
      uint64_t v70 = *a1;
      uint64_t v71 = v47;
      if (v47) {
        atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<int>::FromIRTensorValue(&v70, (uint64_t)v59);
      if (v71) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v71);
      }
      MIL::ValueInference::Tensor<int>::Cast<BOOL>(v59, (uint64_t)&v76);
      std::string::size_type v48 = (void *)a2[1];
      if (v48)
      {
        a2[2] = v48;
        operator delete(v48);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v49 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v49)
      {
        a2[5] = v49;
        operator delete(v49);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v50 = v79;
      uint64_t v51 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v50;
      a2[7] = v51;
      MIL::ValueInference::Tensor<BOOL>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<int>::~Tensor(v59);
      break;
    case 0xEu:
      uint64_t v32 = (std::__shared_weak_count *)a1[1];
      uint64_t v64 = *a1;
      std::string v65 = v32;
      if (v32) {
        atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<unsigned char>::FromIRTensorValue(&v64, (uint64_t)v59);
      if (v65) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v65);
      }
      MIL::ValueInference::Tensor<unsigned char>::Cast<BOOL>(v59, (uint64_t)&v76);
      uint64_t v33 = (void *)a2[1];
      if (v33)
      {
        a2[2] = v33;
        operator delete(v33);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      std::string::size_type v34 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v34)
      {
        a2[5] = v34;
        operator delete(v34);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v35 = v79;
      uint64_t v36 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v35;
      a2[7] = v36;
      MIL::ValueInference::Tensor<BOOL>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<unsigned char>::~Tensor(v59);
      break;
    case 0xFu:
      BOOL v12 = (std::__shared_weak_count *)a1[1];
      uint64_t v62 = *a1;
      uint64_t v63 = v12;
      if (v12) {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<unsigned short>::FromIRTensorValue(&v62, (uint64_t)v59);
      if (v63) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v63);
      }
      MIL::ValueInference::Tensor<unsigned short>::Cast<BOOL>(v59, (uint64_t)&v76);
      long long v13 = (void *)a2[1];
      if (v13)
      {
        a2[2] = v13;
        operator delete(v13);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v14 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v14)
      {
        a2[5] = v14;
        operator delete(v14);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v15 = v79;
      uint64_t v16 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v15;
      a2[7] = v16;
      MIL::ValueInference::Tensor<BOOL>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<unsigned short>::~Tensor(v59);
      break;
    default:
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v59);
      std::string v52 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v59, (uint64_t)"Unsupported Datatype ", 21);
      uint64_t v53 = (*(uint64_t (**)(void))(*(void *)*a1 + 32))();
      int v54 = (*(uint64_t (**)(uint64_t))(*(void *)v53 + 88))(v53);
      MIL::IRDataTypeToString(v54, &v76);
      if ((v76.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v55 = &v76;
      }
      else {
        uint64_t v55 = (std::string *)v76.__r_.__value_.__r.__words[0];
      }
      if ((v76.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(v76.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = v76.__r_.__value_.__l.__size_;
      }
      std::string::size_type v57 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v52, (uint64_t)v55, size);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v57, (uint64_t)".", 1);
      if (SHIBYTE(v76.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v76.__r_.__value_.__l.__data_);
      }
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::stringbuf::str();
      std::logic_error::logic_error(exception, &v76);
      exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
      __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  return result;
}

void sub_20F4B4810(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (*(char *)(v5 - 105) < 0)
  {
    operator delete(*(void **)(v5 - 128));
    if ((v4 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)va);
      MIL::ValueInference::Tensor<BOOL>::~Tensor(v2);
      _Unwind_Resume(a1);
    }
  }
  else if (!v4)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v3);
  goto LABEL_6;
}

void *MIL::ValueInferenceUtils::GetCastedTensor<signed char>@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  double v4 = MIL::ValueInference::Tensor<signed char>::Tensor((uint64_t)a2);
  uint64_t v5 = (*(uint64_t (**)(double))(*(void *)*a1 + 32))(v4);
  switch((*(unsigned int (**)(uint64_t))(*(void *)v5 + 88))(v5))
  {
    case 2u:
      uint64_t v6 = (std::__shared_weak_count *)a1[1];
      uint64_t v68 = *a1;
      uint64_t v69 = v6;
      if (v6) {
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<BOOL>::FromIRTensorValue(&v68, (uint64_t)v59);
      if (v69) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v69);
      }
      MIL::ValueInference::Tensor<BOOL>::Cast<signed char>(v59, (uint64_t)&v76);
      uint64_t v7 = (void *)a2[1];
      if (v7)
      {
        a2[2] = v7;
        operator delete(v7);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v8 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v8)
      {
        a2[5] = v8;
        operator delete(v8);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v9 = v79;
      uint64_t v10 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v9;
      a2[7] = v10;
      MIL::ValueInference::Tensor<signed char>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<BOOL>::~Tensor(v59);
      break;
    case 4u:
      uint64_t v42 = (std::__shared_weak_count *)a1[1];
      uint64_t v72 = *a1;
      std::string v73 = v42;
      if (v42) {
        atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<MIL::Fp16>::FromIRTensorValue(&v72, (uint64_t)v59);
      if (v73) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v73);
      }
      MIL::ValueInference::Tensor<MIL::Fp16>::Cast<signed char>(v59, (uint64_t)&v76);
      uint64_t v43 = (void *)a2[1];
      if (v43)
      {
        a2[2] = v43;
        operator delete(v43);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v44 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v44)
      {
        a2[5] = v44;
        operator delete(v44);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v45 = v79;
      uint64_t v46 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v45;
      a2[7] = v46;
      MIL::ValueInference::Tensor<signed char>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<MIL::Fp16>::~Tensor(v59);
      break;
    case 5u:
      uint64_t v27 = (std::__shared_weak_count *)a1[1];
      uint64_t v81 = *a1;
      unint64_t v82 = v27;
      if (v27) {
        atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<float>::FromIRTensorValue(&v81, (uint64_t)v59);
      if (v82) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v82);
      }
      MIL::ValueInference::Tensor<float>::Cast<signed char>(v59, (uint64_t)&v76);
      uint64_t v28 = (void *)a2[1];
      if (v28)
      {
        a2[2] = v28;
        operator delete(v28);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      unint64_t v29 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v29)
      {
        a2[5] = v29;
        operator delete(v29);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v30 = v79;
      uint64_t v31 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v30;
      a2[7] = v31;
      MIL::ValueInference::Tensor<signed char>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<float>::~Tensor(v59);
      break;
    case 7u:
      uint64_t v37 = (std::__shared_weak_count *)a1[1];
      uint64_t v74 = *a1;
      std::string::size_type v75 = v37;
      if (v37) {
        atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<MIL::Bf16>::FromIRTensorValue(&v74, (uint64_t)v59);
      if (v75) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v75);
      }
      MIL::ValueInference::Tensor<MIL::Bf16>::Cast<signed char>(v59, (uint64_t)&v76);
      std::string::size_type v38 = (void *)a2[1];
      if (v38)
      {
        a2[2] = v38;
        operator delete(v38);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v39 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v39)
      {
        a2[5] = v39;
        operator delete(v39);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v40 = v79;
      uint64_t v41 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v40;
      a2[7] = v41;
      MIL::ValueInference::Tensor<signed char>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<MIL::Bf16>::~Tensor(v59);
      break;
    case 9u:
      uint64_t v17 = (std::__shared_weak_count *)a1[1];
      uint64_t v66 = *a1;
      std::string::size_type v67 = v17;
      if (v17) {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<signed char>::FromIRTensorValue(&v66, (uint64_t)v59);
      if (v67) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v67);
      }
      MIL::ValueInference::Tensor<signed char>::Cast<signed char>(v59, (uint64_t)&v76);
      uint64_t v18 = (void *)a2[1];
      if (v18)
      {
        a2[2] = v18;
        operator delete(v18);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v19 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v19)
      {
        a2[5] = v19;
        operator delete(v19);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v20 = v79;
      uint64_t v21 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v20;
      a2[7] = v21;
      MIL::ValueInference::Tensor<signed char>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<signed char>::~Tensor(v59);
      break;
    case 0xAu:
      uint64_t v22 = (std::__shared_weak_count *)a1[1];
      uint64_t v60 = *a1;
      size_t v61 = v22;
      if (v22) {
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<short>::FromIRTensorValue(&v60, (uint64_t)v59);
      if (v61) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v61);
      }
      MIL::ValueInference::Tensor<short>::Cast<signed char>(v59, (uint64_t)&v76);
      uint64_t v23 = (void *)a2[1];
      if (v23)
      {
        a2[2] = v23;
        operator delete(v23);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v24 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v24)
      {
        a2[5] = v24;
        operator delete(v24);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v25 = v79;
      uint64_t v26 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v25;
      a2[7] = v26;
      MIL::ValueInference::Tensor<signed char>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<short>::~Tensor(v59);
      break;
    case 0xBu:
      uint64_t v47 = (std::__shared_weak_count *)a1[1];
      uint64_t v70 = *a1;
      uint64_t v71 = v47;
      if (v47) {
        atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<int>::FromIRTensorValue(&v70, (uint64_t)v59);
      if (v71) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v71);
      }
      MIL::ValueInference::Tensor<int>::Cast<signed char>(v59, (uint64_t)&v76);
      std::string::size_type v48 = (void *)a2[1];
      if (v48)
      {
        a2[2] = v48;
        operator delete(v48);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v49 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v49)
      {
        a2[5] = v49;
        operator delete(v49);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v50 = v79;
      uint64_t v51 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v50;
      a2[7] = v51;
      MIL::ValueInference::Tensor<signed char>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<int>::~Tensor(v59);
      break;
    case 0xEu:
      uint64_t v32 = (std::__shared_weak_count *)a1[1];
      uint64_t v64 = *a1;
      std::string v65 = v32;
      if (v32) {
        atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<unsigned char>::FromIRTensorValue(&v64, (uint64_t)v59);
      if (v65) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v65);
      }
      MIL::ValueInference::Tensor<unsigned char>::Cast<signed char>(v59, (uint64_t)&v76);
      uint64_t v33 = (void *)a2[1];
      if (v33)
      {
        a2[2] = v33;
        operator delete(v33);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      std::string::size_type v34 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v34)
      {
        a2[5] = v34;
        operator delete(v34);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v35 = v79;
      uint64_t v36 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v35;
      a2[7] = v36;
      MIL::ValueInference::Tensor<signed char>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<unsigned char>::~Tensor(v59);
      break;
    case 0xFu:
      BOOL v12 = (std::__shared_weak_count *)a1[1];
      uint64_t v62 = *a1;
      uint64_t v63 = v12;
      if (v12) {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<unsigned short>::FromIRTensorValue(&v62, (uint64_t)v59);
      if (v63) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v63);
      }
      MIL::ValueInference::Tensor<unsigned short>::Cast<signed char>(v59, (uint64_t)&v76);
      long long v13 = (void *)a2[1];
      if (v13)
      {
        a2[2] = v13;
        operator delete(v13);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v14 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v14)
      {
        a2[5] = v14;
        operator delete(v14);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v15 = v79;
      uint64_t v16 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v15;
      a2[7] = v16;
      MIL::ValueInference::Tensor<signed char>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<unsigned short>::~Tensor(v59);
      break;
    default:
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v59);
      std::string v52 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v59, (uint64_t)"Unsupported Datatype ", 21);
      uint64_t v53 = (*(uint64_t (**)(void))(*(void *)*a1 + 32))();
      int v54 = (*(uint64_t (**)(uint64_t))(*(void *)v53 + 88))(v53);
      MIL::IRDataTypeToString(v54, &v76);
      if ((v76.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v55 = &v76;
      }
      else {
        uint64_t v55 = (std::string *)v76.__r_.__value_.__r.__words[0];
      }
      if ((v76.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(v76.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = v76.__r_.__value_.__l.__size_;
      }
      std::string::size_type v57 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v52, (uint64_t)v55, size);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v57, (uint64_t)".", 1);
      if (SHIBYTE(v76.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v76.__r_.__value_.__l.__data_);
      }
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::stringbuf::str();
      std::logic_error::logic_error(exception, &v76);
      exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
      __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  return result;
}

void sub_20F4B52D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (*(char *)(v5 - 105) < 0)
  {
    operator delete(*(void **)(v5 - 128));
    if ((v4 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)va);
      MIL::ValueInference::Tensor<signed char>::~Tensor(v2);
      _Unwind_Resume(a1);
    }
  }
  else if (!v4)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v3);
  goto LABEL_6;
}

void *MIL::ValueInferenceUtils::GetCastedTensor<unsigned char>@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  double v4 = MIL::ValueInference::Tensor<unsigned char>::Tensor((uint64_t)a2);
  uint64_t v5 = (*(uint64_t (**)(double))(*(void *)*a1 + 32))(v4);
  switch((*(unsigned int (**)(uint64_t))(*(void *)v5 + 88))(v5))
  {
    case 2u:
      uint64_t v6 = (std::__shared_weak_count *)a1[1];
      uint64_t v68 = *a1;
      uint64_t v69 = v6;
      if (v6) {
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<BOOL>::FromIRTensorValue(&v68, (uint64_t)v59);
      if (v69) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v69);
      }
      MIL::ValueInference::Tensor<BOOL>::Cast<unsigned char>(v59, (uint64_t)&v76);
      uint64_t v7 = (void *)a2[1];
      if (v7)
      {
        a2[2] = v7;
        operator delete(v7);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v8 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v8)
      {
        a2[5] = v8;
        operator delete(v8);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v9 = v79;
      uint64_t v10 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v9;
      a2[7] = v10;
      MIL::ValueInference::Tensor<unsigned char>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<BOOL>::~Tensor(v59);
      break;
    case 4u:
      uint64_t v42 = (std::__shared_weak_count *)a1[1];
      uint64_t v72 = *a1;
      std::string v73 = v42;
      if (v42) {
        atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<MIL::Fp16>::FromIRTensorValue(&v72, (uint64_t)v59);
      if (v73) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v73);
      }
      MIL::ValueInference::Tensor<MIL::Fp16>::Cast<unsigned char>(v59, (uint64_t)&v76);
      uint64_t v43 = (void *)a2[1];
      if (v43)
      {
        a2[2] = v43;
        operator delete(v43);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v44 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v44)
      {
        a2[5] = v44;
        operator delete(v44);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v45 = v79;
      uint64_t v46 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v45;
      a2[7] = v46;
      MIL::ValueInference::Tensor<unsigned char>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<MIL::Fp16>::~Tensor(v59);
      break;
    case 5u:
      uint64_t v27 = (std::__shared_weak_count *)a1[1];
      uint64_t v81 = *a1;
      unint64_t v82 = v27;
      if (v27) {
        atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<float>::FromIRTensorValue(&v81, (uint64_t)v59);
      if (v82) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v82);
      }
      MIL::ValueInference::Tensor<float>::Cast<unsigned char>(v59, (uint64_t)&v76);
      uint64_t v28 = (void *)a2[1];
      if (v28)
      {
        a2[2] = v28;
        operator delete(v28);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      unint64_t v29 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v29)
      {
        a2[5] = v29;
        operator delete(v29);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v30 = v79;
      uint64_t v31 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v30;
      a2[7] = v31;
      MIL::ValueInference::Tensor<unsigned char>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<float>::~Tensor(v59);
      break;
    case 7u:
      uint64_t v37 = (std::__shared_weak_count *)a1[1];
      uint64_t v74 = *a1;
      std::string::size_type v75 = v37;
      if (v37) {
        atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<MIL::Bf16>::FromIRTensorValue(&v74, (uint64_t)v59);
      if (v75) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v75);
      }
      MIL::ValueInference::Tensor<MIL::Bf16>::Cast<unsigned char>(v59, (uint64_t)&v76);
      std::string::size_type v38 = (void *)a2[1];
      if (v38)
      {
        a2[2] = v38;
        operator delete(v38);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v39 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v39)
      {
        a2[5] = v39;
        operator delete(v39);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v40 = v79;
      uint64_t v41 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v40;
      a2[7] = v41;
      MIL::ValueInference::Tensor<unsigned char>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<MIL::Bf16>::~Tensor(v59);
      break;
    case 9u:
      uint64_t v17 = (std::__shared_weak_count *)a1[1];
      uint64_t v66 = *a1;
      std::string::size_type v67 = v17;
      if (v17) {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<signed char>::FromIRTensorValue(&v66, (uint64_t)v59);
      if (v67) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v67);
      }
      MIL::ValueInference::Tensor<signed char>::Cast<unsigned char>(v59, (uint64_t)&v76);
      uint64_t v18 = (void *)a2[1];
      if (v18)
      {
        a2[2] = v18;
        operator delete(v18);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v19 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v19)
      {
        a2[5] = v19;
        operator delete(v19);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v20 = v79;
      uint64_t v21 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v20;
      a2[7] = v21;
      MIL::ValueInference::Tensor<unsigned char>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<signed char>::~Tensor(v59);
      break;
    case 0xAu:
      uint64_t v22 = (std::__shared_weak_count *)a1[1];
      uint64_t v60 = *a1;
      size_t v61 = v22;
      if (v22) {
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<short>::FromIRTensorValue(&v60, (uint64_t)v59);
      if (v61) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v61);
      }
      MIL::ValueInference::Tensor<short>::Cast<unsigned char>(v59, (uint64_t)&v76);
      uint64_t v23 = (void *)a2[1];
      if (v23)
      {
        a2[2] = v23;
        operator delete(v23);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v24 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v24)
      {
        a2[5] = v24;
        operator delete(v24);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v25 = v79;
      uint64_t v26 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v25;
      a2[7] = v26;
      MIL::ValueInference::Tensor<unsigned char>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<short>::~Tensor(v59);
      break;
    case 0xBu:
      uint64_t v47 = (std::__shared_weak_count *)a1[1];
      uint64_t v70 = *a1;
      uint64_t v71 = v47;
      if (v47) {
        atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<int>::FromIRTensorValue(&v70, (uint64_t)v59);
      if (v71) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v71);
      }
      MIL::ValueInference::Tensor<int>::Cast<unsigned char>(v59, (uint64_t)&v76);
      std::string::size_type v48 = (void *)a2[1];
      if (v48)
      {
        a2[2] = v48;
        operator delete(v48);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v49 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v49)
      {
        a2[5] = v49;
        operator delete(v49);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v50 = v79;
      uint64_t v51 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v50;
      a2[7] = v51;
      MIL::ValueInference::Tensor<unsigned char>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<int>::~Tensor(v59);
      break;
    case 0xEu:
      uint64_t v32 = (std::__shared_weak_count *)a1[1];
      uint64_t v64 = *a1;
      std::string v65 = v32;
      if (v32) {
        atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<unsigned char>::FromIRTensorValue(&v64, (uint64_t)v59);
      if (v65) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v65);
      }
      MIL::ValueInference::Tensor<unsigned char>::Cast<unsigned char>(v59, (uint64_t)&v76);
      uint64_t v33 = (void *)a2[1];
      if (v33)
      {
        a2[2] = v33;
        operator delete(v33);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      std::string::size_type v34 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v34)
      {
        a2[5] = v34;
        operator delete(v34);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v35 = v79;
      uint64_t v36 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v35;
      a2[7] = v36;
      MIL::ValueInference::Tensor<unsigned char>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<unsigned char>::~Tensor(v59);
      break;
    case 0xFu:
      BOOL v12 = (std::__shared_weak_count *)a1[1];
      uint64_t v62 = *a1;
      uint64_t v63 = v12;
      if (v12) {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<unsigned short>::FromIRTensorValue(&v62, (uint64_t)v59);
      if (v63) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v63);
      }
      MIL::ValueInference::Tensor<unsigned short>::Cast<unsigned char>(v59, (uint64_t)&v76);
      long long v13 = (void *)a2[1];
      if (v13)
      {
        a2[2] = v13;
        operator delete(v13);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v14 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v14)
      {
        a2[5] = v14;
        operator delete(v14);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v15 = v79;
      uint64_t v16 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v15;
      a2[7] = v16;
      MIL::ValueInference::Tensor<unsigned char>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<unsigned short>::~Tensor(v59);
      break;
    default:
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v59);
      std::string v52 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v59, (uint64_t)"Unsupported Datatype ", 21);
      uint64_t v53 = (*(uint64_t (**)(void))(*(void *)*a1 + 32))();
      int v54 = (*(uint64_t (**)(uint64_t))(*(void *)v53 + 88))(v53);
      MIL::IRDataTypeToString(v54, &v76);
      if ((v76.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v55 = &v76;
      }
      else {
        uint64_t v55 = (std::string *)v76.__r_.__value_.__r.__words[0];
      }
      if ((v76.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(v76.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = v76.__r_.__value_.__l.__size_;
      }
      std::string::size_type v57 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v52, (uint64_t)v55, size);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v57, (uint64_t)".", 1);
      if (SHIBYTE(v76.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v76.__r_.__value_.__l.__data_);
      }
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::stringbuf::str();
      std::logic_error::logic_error(exception, &v76);
      exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
      __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  return result;
}

void sub_20F4B5D90(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (*(char *)(v5 - 105) < 0)
  {
    operator delete(*(void **)(v5 - 128));
    if ((v4 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)va);
      MIL::ValueInference::Tensor<unsigned char>::~Tensor(v2);
      _Unwind_Resume(a1);
    }
  }
  else if (!v4)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v3);
  goto LABEL_6;
}

void *MIL::ValueInferenceUtils::GetCastedTensor<unsigned short>@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  double v4 = MIL::ValueInference::Tensor<unsigned short>::Tensor((uint64_t)a2);
  uint64_t v5 = (*(uint64_t (**)(double))(*(void *)*a1 + 32))(v4);
  switch((*(unsigned int (**)(uint64_t))(*(void *)v5 + 88))(v5))
  {
    case 2u:
      uint64_t v6 = (std::__shared_weak_count *)a1[1];
      uint64_t v68 = *a1;
      uint64_t v69 = v6;
      if (v6) {
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<BOOL>::FromIRTensorValue(&v68, (uint64_t)v59);
      if (v69) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v69);
      }
      MIL::ValueInference::Tensor<BOOL>::Cast<unsigned short>(v59, (uint64_t)&v76);
      uint64_t v7 = (void *)a2[1];
      if (v7)
      {
        a2[2] = v7;
        operator delete(v7);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v8 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v8)
      {
        a2[5] = v8;
        operator delete(v8);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v9 = v79;
      uint64_t v10 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v9;
      a2[7] = v10;
      MIL::ValueInference::Tensor<unsigned short>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<BOOL>::~Tensor(v59);
      break;
    case 4u:
      uint64_t v42 = (std::__shared_weak_count *)a1[1];
      uint64_t v72 = *a1;
      std::string v73 = v42;
      if (v42) {
        atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<MIL::Fp16>::FromIRTensorValue(&v72, (uint64_t)v59);
      if (v73) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v73);
      }
      MIL::ValueInference::Tensor<MIL::Fp16>::Cast<unsigned short>(v59, (uint64_t)&v76);
      uint64_t v43 = (void *)a2[1];
      if (v43)
      {
        a2[2] = v43;
        operator delete(v43);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v44 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v44)
      {
        a2[5] = v44;
        operator delete(v44);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v45 = v79;
      uint64_t v46 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v45;
      a2[7] = v46;
      MIL::ValueInference::Tensor<unsigned short>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<MIL::Fp16>::~Tensor(v59);
      break;
    case 5u:
      uint64_t v27 = (std::__shared_weak_count *)a1[1];
      uint64_t v81 = *a1;
      unint64_t v82 = v27;
      if (v27) {
        atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<float>::FromIRTensorValue(&v81, (uint64_t)v59);
      if (v82) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v82);
      }
      MIL::ValueInference::Tensor<float>::Cast<unsigned short>(v59, (uint64_t)&v76);
      uint64_t v28 = (void *)a2[1];
      if (v28)
      {
        a2[2] = v28;
        operator delete(v28);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      unint64_t v29 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v29)
      {
        a2[5] = v29;
        operator delete(v29);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v30 = v79;
      uint64_t v31 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v30;
      a2[7] = v31;
      MIL::ValueInference::Tensor<unsigned short>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<float>::~Tensor(v59);
      break;
    case 7u:
      uint64_t v37 = (std::__shared_weak_count *)a1[1];
      uint64_t v74 = *a1;
      std::string::size_type v75 = v37;
      if (v37) {
        atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<MIL::Bf16>::FromIRTensorValue(&v74, (uint64_t)v59);
      if (v75) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v75);
      }
      MIL::ValueInference::Tensor<MIL::Bf16>::Cast<unsigned short>(v59, (uint64_t)&v76);
      std::string::size_type v38 = (void *)a2[1];
      if (v38)
      {
        a2[2] = v38;
        operator delete(v38);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v39 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v39)
      {
        a2[5] = v39;
        operator delete(v39);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v40 = v79;
      uint64_t v41 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v40;
      a2[7] = v41;
      MIL::ValueInference::Tensor<unsigned short>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<MIL::Bf16>::~Tensor(v59);
      break;
    case 9u:
      uint64_t v17 = (std::__shared_weak_count *)a1[1];
      uint64_t v66 = *a1;
      std::string::size_type v67 = v17;
      if (v17) {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<signed char>::FromIRTensorValue(&v66, (uint64_t)v59);
      if (v67) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v67);
      }
      MIL::ValueInference::Tensor<signed char>::Cast<unsigned short>(v59, (uint64_t)&v76);
      uint64_t v18 = (void *)a2[1];
      if (v18)
      {
        a2[2] = v18;
        operator delete(v18);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v19 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v19)
      {
        a2[5] = v19;
        operator delete(v19);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v20 = v79;
      uint64_t v21 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v20;
      a2[7] = v21;
      MIL::ValueInference::Tensor<unsigned short>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<signed char>::~Tensor(v59);
      break;
    case 0xAu:
      uint64_t v22 = (std::__shared_weak_count *)a1[1];
      uint64_t v60 = *a1;
      size_t v61 = v22;
      if (v22) {
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<short>::FromIRTensorValue(&v60, (uint64_t)v59);
      if (v61) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v61);
      }
      MIL::ValueInference::Tensor<short>::Cast<unsigned short>(v59, (uint64_t)&v76);
      uint64_t v23 = (void *)a2[1];
      if (v23)
      {
        a2[2] = v23;
        operator delete(v23);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v24 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v24)
      {
        a2[5] = v24;
        operator delete(v24);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v25 = v79;
      uint64_t v26 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v25;
      a2[7] = v26;
      MIL::ValueInference::Tensor<unsigned short>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<short>::~Tensor(v59);
      break;
    case 0xBu:
      uint64_t v47 = (std::__shared_weak_count *)a1[1];
      uint64_t v70 = *a1;
      uint64_t v71 = v47;
      if (v47) {
        atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<int>::FromIRTensorValue(&v70, (uint64_t)v59);
      if (v71) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v71);
      }
      MIL::ValueInference::Tensor<int>::Cast<unsigned short>(v59, (uint64_t)&v76);
      std::string::size_type v48 = (void *)a2[1];
      if (v48)
      {
        a2[2] = v48;
        operator delete(v48);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v49 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v49)
      {
        a2[5] = v49;
        operator delete(v49);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v50 = v79;
      uint64_t v51 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v50;
      a2[7] = v51;
      MIL::ValueInference::Tensor<unsigned short>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<int>::~Tensor(v59);
      break;
    case 0xEu:
      uint64_t v32 = (std::__shared_weak_count *)a1[1];
      uint64_t v64 = *a1;
      std::string v65 = v32;
      if (v32) {
        atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<unsigned char>::FromIRTensorValue(&v64, (uint64_t)v59);
      if (v65) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v65);
      }
      MIL::ValueInference::Tensor<unsigned char>::Cast<unsigned short>(v59, (uint64_t)&v76);
      uint64_t v33 = (void *)a2[1];
      if (v33)
      {
        a2[2] = v33;
        operator delete(v33);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      std::string::size_type v34 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v34)
      {
        a2[5] = v34;
        operator delete(v34);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v35 = v79;
      uint64_t v36 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v35;
      a2[7] = v36;
      MIL::ValueInference::Tensor<unsigned short>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<unsigned char>::~Tensor(v59);
      break;
    case 0xFu:
      BOOL v12 = (std::__shared_weak_count *)a1[1];
      uint64_t v62 = *a1;
      uint64_t v63 = v12;
      if (v12) {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<unsigned short>::FromIRTensorValue(&v62, (uint64_t)v59);
      if (v63) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v63);
      }
      MIL::ValueInference::Tensor<unsigned short>::Cast<unsigned short>(v59, (uint64_t)&v76);
      long long v13 = (void *)a2[1];
      if (v13)
      {
        a2[2] = v13;
        operator delete(v13);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v14 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v14)
      {
        a2[5] = v14;
        operator delete(v14);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v15 = v79;
      uint64_t v16 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v15;
      a2[7] = v16;
      MIL::ValueInference::Tensor<unsigned short>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<unsigned short>::~Tensor(v59);
      break;
    default:
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v59);
      std::string v52 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v59, (uint64_t)"Unsupported Datatype ", 21);
      uint64_t v53 = (*(uint64_t (**)(void))(*(void *)*a1 + 32))();
      int v54 = (*(uint64_t (**)(uint64_t))(*(void *)v53 + 88))(v53);
      MIL::IRDataTypeToString(v54, &v76);
      if ((v76.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v55 = &v76;
      }
      else {
        uint64_t v55 = (std::string *)v76.__r_.__value_.__r.__words[0];
      }
      if ((v76.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(v76.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = v76.__r_.__value_.__l.__size_;
      }
      std::string::size_type v57 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v52, (uint64_t)v55, size);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v57, (uint64_t)".", 1);
      if (SHIBYTE(v76.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v76.__r_.__value_.__l.__data_);
      }
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::stringbuf::str();
      std::logic_error::logic_error(exception, &v76);
      exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
      __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  return result;
}

void sub_20F4B6850(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (*(char *)(v5 - 105) < 0)
  {
    operator delete(*(void **)(v5 - 128));
    if ((v4 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)va);
      MIL::ValueInference::Tensor<unsigned short>::~Tensor(v2);
      _Unwind_Resume(a1);
    }
  }
  else if (!v4)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v3);
  goto LABEL_6;
}

void *MIL::ValueInferenceUtils::GetCastedTensor<short>@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  double v4 = MIL::ValueInference::Tensor<short>::Tensor((uint64_t)a2);
  uint64_t v5 = (*(uint64_t (**)(double))(*(void *)*a1 + 32))(v4);
  switch((*(unsigned int (**)(uint64_t))(*(void *)v5 + 88))(v5))
  {
    case 2u:
      uint64_t v6 = (std::__shared_weak_count *)a1[1];
      uint64_t v68 = *a1;
      uint64_t v69 = v6;
      if (v6) {
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<BOOL>::FromIRTensorValue(&v68, (uint64_t)v59);
      if (v69) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v69);
      }
      MIL::ValueInference::Tensor<BOOL>::Cast<short>(v59, (uint64_t)&v76);
      uint64_t v7 = (void *)a2[1];
      if (v7)
      {
        a2[2] = v7;
        operator delete(v7);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v8 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v8)
      {
        a2[5] = v8;
        operator delete(v8);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v9 = v79;
      uint64_t v10 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v9;
      a2[7] = v10;
      MIL::ValueInference::Tensor<short>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<BOOL>::~Tensor(v59);
      break;
    case 4u:
      uint64_t v42 = (std::__shared_weak_count *)a1[1];
      uint64_t v72 = *a1;
      std::string v73 = v42;
      if (v42) {
        atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<MIL::Fp16>::FromIRTensorValue(&v72, (uint64_t)v59);
      if (v73) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v73);
      }
      MIL::ValueInference::Tensor<MIL::Fp16>::Cast<short>(v59, (uint64_t)&v76);
      uint64_t v43 = (void *)a2[1];
      if (v43)
      {
        a2[2] = v43;
        operator delete(v43);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v44 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v44)
      {
        a2[5] = v44;
        operator delete(v44);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v45 = v79;
      uint64_t v46 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v45;
      a2[7] = v46;
      MIL::ValueInference::Tensor<short>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<MIL::Fp16>::~Tensor(v59);
      break;
    case 5u:
      uint64_t v27 = (std::__shared_weak_count *)a1[1];
      uint64_t v81 = *a1;
      unint64_t v82 = v27;
      if (v27) {
        atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<float>::FromIRTensorValue(&v81, (uint64_t)v59);
      if (v82) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v82);
      }
      MIL::ValueInference::Tensor<float>::Cast<short>(v59, (uint64_t)&v76);
      uint64_t v28 = (void *)a2[1];
      if (v28)
      {
        a2[2] = v28;
        operator delete(v28);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      unint64_t v29 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v29)
      {
        a2[5] = v29;
        operator delete(v29);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v30 = v79;
      uint64_t v31 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v30;
      a2[7] = v31;
      MIL::ValueInference::Tensor<short>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<float>::~Tensor(v59);
      break;
    case 7u:
      uint64_t v37 = (std::__shared_weak_count *)a1[1];
      uint64_t v74 = *a1;
      std::string::size_type v75 = v37;
      if (v37) {
        atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<MIL::Bf16>::FromIRTensorValue(&v74, (uint64_t)v59);
      if (v75) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v75);
      }
      MIL::ValueInference::Tensor<MIL::Bf16>::Cast<short>(v59, (uint64_t)&v76);
      std::string::size_type v38 = (void *)a2[1];
      if (v38)
      {
        a2[2] = v38;
        operator delete(v38);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v39 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v39)
      {
        a2[5] = v39;
        operator delete(v39);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v40 = v79;
      uint64_t v41 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v40;
      a2[7] = v41;
      MIL::ValueInference::Tensor<short>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<MIL::Bf16>::~Tensor(v59);
      break;
    case 9u:
      uint64_t v17 = (std::__shared_weak_count *)a1[1];
      uint64_t v66 = *a1;
      std::string::size_type v67 = v17;
      if (v17) {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<signed char>::FromIRTensorValue(&v66, (uint64_t)v59);
      if (v67) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v67);
      }
      MIL::ValueInference::Tensor<signed char>::Cast<short>(v59, (uint64_t)&v76);
      uint64_t v18 = (void *)a2[1];
      if (v18)
      {
        a2[2] = v18;
        operator delete(v18);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v19 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v19)
      {
        a2[5] = v19;
        operator delete(v19);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v20 = v79;
      uint64_t v21 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v20;
      a2[7] = v21;
      MIL::ValueInference::Tensor<short>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<signed char>::~Tensor(v59);
      break;
    case 0xAu:
      uint64_t v22 = (std::__shared_weak_count *)a1[1];
      uint64_t v60 = *a1;
      size_t v61 = v22;
      if (v22) {
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<short>::FromIRTensorValue(&v60, (uint64_t)v59);
      if (v61) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v61);
      }
      MIL::ValueInference::Tensor<short>::Cast<short>(v59, (uint64_t)&v76);
      uint64_t v23 = (void *)a2[1];
      if (v23)
      {
        a2[2] = v23;
        operator delete(v23);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v24 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v24)
      {
        a2[5] = v24;
        operator delete(v24);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v25 = v79;
      uint64_t v26 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v25;
      a2[7] = v26;
      MIL::ValueInference::Tensor<short>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<short>::~Tensor(v59);
      break;
    case 0xBu:
      uint64_t v47 = (std::__shared_weak_count *)a1[1];
      uint64_t v70 = *a1;
      uint64_t v71 = v47;
      if (v47) {
        atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<int>::FromIRTensorValue(&v70, (uint64_t)v59);
      if (v71) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v71);
      }
      MIL::ValueInference::Tensor<int>::Cast<short>(v59, (uint64_t)&v76);
      std::string::size_type v48 = (void *)a2[1];
      if (v48)
      {
        a2[2] = v48;
        operator delete(v48);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v49 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v49)
      {
        a2[5] = v49;
        operator delete(v49);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v50 = v79;
      uint64_t v51 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v50;
      a2[7] = v51;
      MIL::ValueInference::Tensor<short>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<int>::~Tensor(v59);
      break;
    case 0xEu:
      uint64_t v32 = (std::__shared_weak_count *)a1[1];
      uint64_t v64 = *a1;
      std::string v65 = v32;
      if (v32) {
        atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<unsigned char>::FromIRTensorValue(&v64, (uint64_t)v59);
      if (v65) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v65);
      }
      MIL::ValueInference::Tensor<unsigned char>::Cast<short>(v59, (uint64_t)&v76);
      uint64_t v33 = (void *)a2[1];
      if (v33)
      {
        a2[2] = v33;
        operator delete(v33);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      std::string::size_type v34 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v34)
      {
        a2[5] = v34;
        operator delete(v34);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v35 = v79;
      uint64_t v36 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v35;
      a2[7] = v36;
      MIL::ValueInference::Tensor<short>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<unsigned char>::~Tensor(v59);
      break;
    case 0xFu:
      BOOL v12 = (std::__shared_weak_count *)a1[1];
      uint64_t v62 = *a1;
      uint64_t v63 = v12;
      if (v12) {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      MIL::ValueInference::Tensor<unsigned short>::FromIRTensorValue(&v62, (uint64_t)v59);
      if (v63) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v63);
      }
      MIL::ValueInference::Tensor<unsigned short>::Cast<short>(v59, (uint64_t)&v76);
      long long v13 = (void *)a2[1];
      if (v13)
      {
        a2[2] = v13;
        operator delete(v13);
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
      }
      uint64_t v14 = (void *)a2[4];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)&v76.__r_.__value_.__r.__words[1];
      a2[3] = v77;
      uint64_t v77 = 0;
      *(_OWORD *)&v76.__r_.__value_.__r.__words[1] = 0uLL;
      if (v14)
      {
        a2[5] = v14;
        operator delete(v14);
        a2[4] = 0;
        a2[5] = 0;
        a2[6] = 0;
      }
      *((_OWORD *)a2 + 2) = v78;
      uint64_t v15 = v79;
      uint64_t v16 = v80;
      uint64_t v79 = 0;
      long long v78 = 0uLL;
      a2[6] = v15;
      a2[7] = v16;
      MIL::ValueInference::Tensor<short>::~Tensor(&v76);
      uint64_t result = MIL::ValueInference::Tensor<unsigned short>::~Tensor(v59);
      break;
    default:
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v59);
      std::string v52 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v59, (uint64_t)"Unsupported Datatype ", 21);
      uint64_t v53 = (*(uint64_t (**)(void))(*(void *)*a1 + 32))();
      int v54 = (*(uint64_t (**)(uint64_t))(*(void *)v53 + 88))(v53);
      MIL::IRDataTypeToString(v54, &v76);
      if ((v76.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v55 = &v76;
      }
      else {
        uint64_t v55 = (std::string *)v76.__r_.__value_.__r.__words[0];
      }
      if ((v76.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(v76.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = v76.__r_.__value_.__l.__size_;
      }
      std::string::size_type v57 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v52, (uint64_t)v55, size);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v57, (uint64_t)".", 1);
      if (SHIBYTE(v76.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v76.__r_.__value_.__l.__data_);
      }
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::stringbuf::str();
      std::logic_error::logic_error(exception, &v76);
      exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
      __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  return result;
}

void sub_20F4B7310(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (*(char *)(v5 - 105) < 0)
  {
    operator delete(*(void **)(v5 - 128));
    if ((v4 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)va);
      MIL::ValueInference::Tensor<short>::~Tensor(v2);
      _Unwind_Resume(a1);
    }
  }
  else if (!v4)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v3);
  goto LABEL_6;
}

void *MIL::ValueInference::Tensor<MIL::Bf16>::~Tensor(void *a1)
{
  *a1 = &unk_26C25DB98;
  uint64_t v2 = (void *)a1[4];
  if (v2)
  {
    a1[5] = v2;
    operator delete(v2);
  }
  unint64_t v3 = (void *)a1[1];
  if (v3)
  {
    a1[2] = v3;
    operator delete(v3);
  }
  return a1;
}

void MIL::ValueInference::Tensor<MIL::Bf16>::~Tensor(void *a1)
{
  MIL::ValueInference::Tensor<MIL::Bf16>::~Tensor(a1);

  JUMPOUT(0x21056C700);
}

void *MIL::ValueInference::Tensor<int>::~Tensor(void *a1)
{
  *a1 = &unk_26C25DBC8;
  uint64_t v2 = (void *)a1[4];
  if (v2)
  {
    a1[5] = v2;
    operator delete(v2);
  }
  unint64_t v3 = (void *)a1[1];
  if (v3)
  {
    a1[2] = v3;
    operator delete(v3);
  }
  return a1;
}

void MIL::ValueInference::Tensor<int>::~Tensor(void *a1)
{
  MIL::ValueInference::Tensor<int>::~Tensor(a1);

  JUMPOUT(0x21056C700);
}

void *MIL::ValueInference::Tensor<BOOL>::~Tensor(void *a1)
{
  *a1 = &unk_26C25DBF8;
  uint64_t v2 = (void *)a1[4];
  if (v2)
  {
    a1[5] = v2;
    operator delete(v2);
  }
  unint64_t v3 = (void *)a1[1];
  if (v3)
  {
    a1[2] = v3;
    operator delete(v3);
  }
  return a1;
}

void MIL::ValueInference::Tensor<BOOL>::~Tensor(void *a1)
{
  MIL::ValueInference::Tensor<BOOL>::~Tensor(a1);

  JUMPOUT(0x21056C700);
}

void *MIL::ValueInference::Tensor<unsigned short>::~Tensor(void *a1)
{
  *a1 = &unk_26C25DC28;
  uint64_t v2 = (void *)a1[4];
  if (v2)
  {
    a1[5] = v2;
    operator delete(v2);
  }
  unint64_t v3 = (void *)a1[1];
  if (v3)
  {
    a1[2] = v3;
    operator delete(v3);
  }
  return a1;
}

void MIL::ValueInference::Tensor<unsigned short>::~Tensor(void *a1)
{
  MIL::ValueInference::Tensor<unsigned short>::~Tensor(a1);

  JUMPOUT(0x21056C700);
}

void *MIL::ValueInference::Tensor<short>::~Tensor(void *a1)
{
  *a1 = &unk_26C25DC58;
  uint64_t v2 = (void *)a1[4];
  if (v2)
  {
    a1[5] = v2;
    operator delete(v2);
  }
  unint64_t v3 = (void *)a1[1];
  if (v3)
  {
    a1[2] = v3;
    operator delete(v3);
  }
  return a1;
}

void MIL::ValueInference::Tensor<short>::~Tensor(void *a1)
{
  MIL::ValueInference::Tensor<short>::~Tensor(a1);

  JUMPOUT(0x21056C700);
}

void MIL::ValueInference::Tensor<float>::Cast<float>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (const void *)a1[4];
  uint64_t v7 = a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<float>::__init_with_size[abi:ne180100]<std::__wrap_iter<float const*>,std::__wrap_iter<float const*>>(&__p, v6, v7, (v7 - (uint64_t)v6) >> 2);
  MIL::ValueInference::Tensor<float>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B7870(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<float>::Cast<int>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (float *)a1[4];
  uint64_t v7 = (float *)a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<float const*>,std::__wrap_iter<float const*>>((char *)&__p, v6, v7, v7 - v6);
  MIL::ValueInference::Tensor<int>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B793C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<float>::Cast<short>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (float *)a1[4];
  uint64_t v7 = (float *)a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<short>::__init_with_size[abi:ne180100]<std::__wrap_iter<float const*>,std::__wrap_iter<float const*>>((char *)&__p, v6, v7, v7 - v6);
  MIL::ValueInference::Tensor<short>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B7A08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<float>::Cast<unsigned short>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (float *)a1[4];
  uint64_t v7 = (float *)a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<unsigned short>::__init_with_size[abi:ne180100]<std::__wrap_iter<float const*>,std::__wrap_iter<float const*>>((char *)&__p, v6, v7, v7 - v6);
  MIL::ValueInference::Tensor<unsigned short>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B7AD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<float>::Cast<signed char>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (float *)a1[4];
  uint64_t v7 = (float *)a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<signed char>::__init_with_size[abi:ne180100]<std::__wrap_iter<float const*>,std::__wrap_iter<float const*>>((char *)&__p, v6, v7, v7 - v6);
  MIL::ValueInference::Tensor<signed char>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B7BA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<float>::Cast<unsigned char>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (float *)a1[4];
  uint64_t v7 = (float *)a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<std::__wrap_iter<float const*>,std::__wrap_iter<float const*>>((char *)&__p, v6, v7, v7 - v6);
  MIL::ValueInference::Tensor<unsigned char>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B7C6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<int>::Cast<int>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (const void *)a1[4];
  uint64_t v7 = a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, v6, v7, (v7 - (uint64_t)v6) >> 2);
  MIL::ValueInference::Tensor<int>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B7D38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<int>::Cast<float>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (int *)a1[4];
  uint64_t v7 = (int *)a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<float>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>((char *)&__p, v6, v7, v7 - v6);
  MIL::ValueInference::Tensor<float>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B7E00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<int>::Cast<short>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (int *)a1[4];
  uint64_t v7 = (int *)a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<short>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>((char *)&__p, v6, v7, v7 - v6);
  MIL::ValueInference::Tensor<short>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B7EC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<int>::Cast<unsigned short>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (int *)a1[4];
  uint64_t v7 = (int *)a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<unsigned short>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>((char *)&__p, v6, v7, v7 - v6);
  MIL::ValueInference::Tensor<unsigned short>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B7F90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<int>::Cast<signed char>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (int *)a1[4];
  uint64_t v7 = (int *)a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<signed char>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>((char *)&__p, v6, v7, v7 - v6);
  MIL::ValueInference::Tensor<signed char>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B8058(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<int>::Cast<unsigned char>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (int *)a1[4];
  uint64_t v7 = (int *)a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>((char *)&__p, v6, v7, v7 - v6);
  MIL::ValueInference::Tensor<unsigned char>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B8120(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<BOOL>::Cast<BOOL>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (const void *)a1[4];
  uint64_t v7 = a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned char const*>,std::__wrap_iter<unsigned char const*>>(&__p, v6, v7, v7 - (void)v6);
  MIL::ValueInference::Tensor<BOOL>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B81E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<BOOL>::Cast<float>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (unsigned __int8 *)a1[4];
  uint64_t v7 = (unsigned __int8 *)a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<float>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned char const*>,std::__wrap_iter<unsigned char const*>>((char *)&__p, v6, v7, v7 - v6);
  MIL::ValueInference::Tensor<float>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B82AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<BOOL>::Cast<int>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (unsigned __int8 *)a1[4];
  uint64_t v7 = (unsigned __int8 *)a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned char const*>,std::__wrap_iter<unsigned char const*>>((char *)&__p, v6, v7, v7 - v6);
  MIL::ValueInference::Tensor<int>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B8370(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<BOOL>::Cast<short>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (unsigned __int8 *)a1[4];
  uint64_t v7 = (unsigned __int8 *)a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<short>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned char const*>,std::__wrap_iter<unsigned char const*>>((char *)&__p, v6, v7, v7 - v6);
  MIL::ValueInference::Tensor<short>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B8434(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<BOOL>::Cast<unsigned short>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (unsigned __int8 *)a1[4];
  uint64_t v7 = (unsigned __int8 *)a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<unsigned short>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned char const*>,std::__wrap_iter<unsigned char const*>>((char *)&__p, v6, v7, v7 - v6);
  MIL::ValueInference::Tensor<unsigned short>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B84F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<BOOL>::Cast<signed char>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (char *)a1[4];
  uint64_t v7 = (char *)a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<signed char>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned char const*>,std::__wrap_iter<unsigned char const*>>((char *)&__p, v6, v7, v7 - v6);
  MIL::ValueInference::Tensor<signed char>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B85BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<BOOL>::Cast<unsigned char>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (const void *)a1[4];
  uint64_t v7 = a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned char const*>,std::__wrap_iter<unsigned char const*>>(&__p, v6, v7, v7 - (void)v6);
  MIL::ValueInference::Tensor<unsigned char>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B8680(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<short>::Cast<short>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (const void *)a1[4];
  uint64_t v7 = a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<short>::__init_with_size[abi:ne180100]<std::__wrap_iter<short const*>,std::__wrap_iter<short const*>>(&__p, v6, v7, (v7 - (uint64_t)v6) >> 1);
  MIL::ValueInference::Tensor<short>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B8748(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<short>::Cast<signed char>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (char *)a1[4];
  uint64_t v7 = (char *)a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<signed char>::__init_with_size[abi:ne180100]<std::__wrap_iter<short const*>,std::__wrap_iter<short const*>>((char *)&__p, v6, v7, (v7 - v6) >> 1);
  MIL::ValueInference::Tensor<signed char>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B8810(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<short>::Cast<float>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (__int16 *)a1[4];
  uint64_t v7 = (__int16 *)a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<float>::__init_with_size[abi:ne180100]<std::__wrap_iter<short const*>,std::__wrap_iter<short const*>>((char *)&__p, v6, v7, v7 - v6);
  MIL::ValueInference::Tensor<float>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B88D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<short>::Cast<int>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (__int16 *)a1[4];
  uint64_t v7 = (__int16 *)a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<short const*>,std::__wrap_iter<short const*>>((char *)&__p, v6, v7, v7 - v6);
  MIL::ValueInference::Tensor<int>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B89A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<short>::Cast<unsigned short>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (__int16 *)a1[4];
  uint64_t v7 = (__int16 *)a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<unsigned short>::__init_with_size[abi:ne180100]<std::__wrap_iter<short const*>,std::__wrap_iter<short const*>>((char *)&__p, v6, v7, v7 - v6);
  MIL::ValueInference::Tensor<unsigned short>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B8A68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<short>::Cast<unsigned char>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (char *)a1[4];
  uint64_t v7 = (char *)a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<std::__wrap_iter<short const*>,std::__wrap_iter<short const*>>((char *)&__p, v6, v7, (v7 - v6) >> 1);
  MIL::ValueInference::Tensor<unsigned char>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B8B30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<unsigned short>::Cast<unsigned short>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (const void *)a1[4];
  uint64_t v7 = a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<unsigned short>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>(&__p, v6, v7, (v7 - (uint64_t)v6) >> 1);
  MIL::ValueInference::Tensor<unsigned short>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B8BF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<unsigned short>::Cast<signed char>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (char *)a1[4];
  uint64_t v7 = (char *)a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<signed char>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)&__p, v6, v7, (v7 - v6) >> 1);
  MIL::ValueInference::Tensor<signed char>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B8CC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<unsigned short>::Cast<float>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (unsigned __int16 *)a1[4];
  uint64_t v7 = (unsigned __int16 *)a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<float>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)&__p, v6, v7, v7 - v6);
  MIL::ValueInference::Tensor<float>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B8D88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<unsigned short>::Cast<int>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (unsigned __int16 *)a1[4];
  uint64_t v7 = (unsigned __int16 *)a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)&__p, v6, v7, v7 - v6);
  MIL::ValueInference::Tensor<int>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B8E50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<unsigned short>::Cast<short>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (__int16 *)a1[4];
  uint64_t v7 = (__int16 *)a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<short>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)&__p, v6, v7, v7 - v6);
  MIL::ValueInference::Tensor<short>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B8F18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<unsigned short>::Cast<unsigned char>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (char *)a1[4];
  uint64_t v7 = (char *)a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)&__p, v6, v7, (v7 - v6) >> 1);
  MIL::ValueInference::Tensor<unsigned char>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B8FE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<signed char>::Cast<signed char>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (const void *)a1[4];
  uint64_t v7 = a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<signed char>::__init_with_size[abi:ne180100]<std::__wrap_iter<signed char const*>,std::__wrap_iter<signed char const*>>(&__p, v6, v7, v7 - (void)v6);
  MIL::ValueInference::Tensor<signed char>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B90A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<signed char>::Cast<float>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (char *)a1[4];
  uint64_t v7 = (char *)a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<float>::__init_with_size[abi:ne180100]<std::__wrap_iter<signed char const*>,std::__wrap_iter<signed char const*>>((char *)&__p, v6, v7, v7 - v6);
  MIL::ValueInference::Tensor<float>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B9168(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<signed char>::Cast<int>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (char *)a1[4];
  uint64_t v7 = (char *)a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<signed char const*>,std::__wrap_iter<signed char const*>>((char *)&__p, v6, v7, v7 - v6);
  MIL::ValueInference::Tensor<int>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B922C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<signed char>::Cast<short>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (char *)a1[4];
  uint64_t v7 = (char *)a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<short>::__init_with_size[abi:ne180100]<std::__wrap_iter<signed char const*>,std::__wrap_iter<signed char const*>>((char *)&__p, v6, v7, v7 - v6);
  MIL::ValueInference::Tensor<short>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B92F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<signed char>::Cast<unsigned short>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (char *)a1[4];
  uint64_t v7 = (char *)a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<unsigned short>::__init_with_size[abi:ne180100]<std::__wrap_iter<signed char const*>,std::__wrap_iter<signed char const*>>((char *)&__p, v6, v7, v7 - v6);
  MIL::ValueInference::Tensor<unsigned short>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B93B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<signed char>::Cast<unsigned char>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (char *)a1[4];
  uint64_t v7 = (char *)a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<std::__wrap_iter<signed char const*>,std::__wrap_iter<signed char const*>>((char *)&__p, v6, v7, v7 - v6);
  MIL::ValueInference::Tensor<unsigned char>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B9478(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<unsigned char>::Cast<unsigned char>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (const void *)a1[4];
  uint64_t v7 = a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned char const*>,std::__wrap_iter<unsigned char const*>>(&__p, v6, v7, v7 - (void)v6);
  MIL::ValueInference::Tensor<unsigned char>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B953C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<unsigned char>::Cast<float>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (unsigned __int8 *)a1[4];
  uint64_t v7 = (unsigned __int8 *)a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<float>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned char const*>,std::__wrap_iter<unsigned char const*>>((char *)&__p, v6, v7, v7 - v6);
  MIL::ValueInference::Tensor<float>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B9600(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<unsigned char>::Cast<int>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (unsigned __int8 *)a1[4];
  uint64_t v7 = (unsigned __int8 *)a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned char const*>,std::__wrap_iter<unsigned char const*>>((char *)&__p, v6, v7, v7 - v6);
  MIL::ValueInference::Tensor<int>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B96C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<unsigned char>::Cast<short>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (unsigned __int8 *)a1[4];
  uint64_t v7 = (unsigned __int8 *)a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<short>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned char const*>,std::__wrap_iter<unsigned char const*>>((char *)&__p, v6, v7, v7 - v6);
  MIL::ValueInference::Tensor<short>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B9788(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<unsigned char>::Cast<unsigned short>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (unsigned __int8 *)a1[4];
  uint64_t v7 = (unsigned __int8 *)a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<unsigned short>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned char const*>,std::__wrap_iter<unsigned char const*>>((char *)&__p, v6, v7, v7 - v6);
  MIL::ValueInference::Tensor<unsigned short>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B984C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<unsigned char>::Cast<signed char>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (char *)a1[4];
  uint64_t v7 = (char *)a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<signed char>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned char const*>,std::__wrap_iter<unsigned char const*>>((char *)&__p, v6, v7, v7 - v6);
  MIL::ValueInference::Tensor<signed char>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4B9910(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<MIL::Bf16>::Cast<float>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v23 = 0;
  __n128 v22 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v22, v4, v5, (v5 - (uint64_t)v4) >> 3);
  __n128 __p = 0uLL;
  unint64_t v21 = 0;
  std::vector<float>::reserve((void **)&__p, (uint64_t)(a1[5] - a1[4]) >> 1);
  uint64_t v6 = a1[4];
  if (a1[5] != v6)
  {
    unint64_t v7 = 0;
    do
    {
      float Float = MIL::Bf16::GetFloat((MIL::Bf16 *)(v6 + 2 * v7));
      float v9 = Float;
      unint64_t v10 = __p.n128_u64[1];
      if (__p.n128_u64[1] >= v21)
      {
        BOOL v12 = (void *)__p.n128_u64[0];
        uint64_t v13 = (uint64_t)(__p.n128_u64[1] - __p.n128_u64[0]) >> 2;
        unint64_t v14 = v13 + 1;
        if ((unint64_t)(v13 + 1) >> 62) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v15 = v21 - __p.n128_u64[0];
        if ((uint64_t)(v21 - __p.n128_u64[0]) >> 1 > v14) {
          unint64_t v14 = v15 >> 1;
        }
        if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v16 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v16 = v14;
        }
        if (v16)
        {
          uint64_t v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v21, v16);
          unint64_t v10 = __p.n128_u64[1];
          BOOL v12 = (void *)__p.n128_u64[0];
        }
        else
        {
          uint64_t v17 = 0;
        }
        uint64_t v18 = (float *)&v17[4 * v13];
        float *v18 = v9;
        unint64_t v11 = (unint64_t)(v18 + 1);
        while ((void *)v10 != v12)
        {
          int v19 = *(_DWORD *)(v10 - 4);
          v10 -= 4;
          *((_DWORD *)v18-- - 1) = v19;
        }
        __p.n128_u64[0] = (unint64_t)v18;
        __p.n128_u64[1] = v11;
        unint64_t v21 = (unint64_t)&v17[4 * v16];
        if (v12) {
          operator delete(v12);
        }
      }
      else
      {
        *(float *)__p.n128_u64[1] = Float;
        unint64_t v11 = v10 + 4;
      }
      __p.n128_u64[1] = v11;
      ++v7;
      uint64_t v6 = a1[4];
    }
    while (v7 < (a1[5] - v6) >> 1);
  }
  MIL::ValueInference::Tensor<float>::Tensor(a2, &v22, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v22.n128_u64[0])
  {
    v22.n128_u64[1] = v22.n128_u64[0];
    operator delete((void *)v22.n128_u64[0]);
  }
}

void sub_20F4B9AE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<MIL::Bf16>::Cast<int>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v21 = 0;
  __n128 v20 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v20, v4, v5, (v5 - (uint64_t)v4) >> 3);
  memset(&__p, 0, sizeof(__p));
  std::vector<int>::reserve(&__p, (uint64_t)(a1[5] - a1[4]) >> 1);
  uint64_t v6 = a1[4];
  if (a1[5] != v6)
  {
    unint64_t v7 = 0;
    do
    {
      unsigned int Float = (int)MIL::Bf16::GetFloat((MIL::Bf16 *)(v6 + 2 * v7));
      std::vector<unsigned int>::pointer end = __p.__end_;
      if (__p.__end_ >= __p.__end_cap_.__value_)
      {
        std::vector<unsigned int>::pointer begin = __p.__begin_;
        int64_t v12 = __p.__end_ - __p.__begin_;
        unint64_t v13 = v12 + 1;
        if ((unint64_t)(v12 + 1) >> 62) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        int64_t v14 = (char *)__p.__end_cap_.__value_ - (char *)__p.__begin_;
        if (((char *)__p.__end_cap_.__value_ - (char *)__p.__begin_) >> 1 > v13) {
          unint64_t v13 = v14 >> 1;
        }
        if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v15 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v15 = v13;
        }
        if (v15)
        {
          unint64_t v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&__p.__end_cap_, v15);
          std::vector<unsigned int>::pointer begin = __p.__begin_;
          std::vector<unsigned int>::pointer end = __p.__end_;
        }
        else
        {
          unint64_t v16 = 0;
        }
        uint64_t v17 = (unsigned int *)&v16[4 * v12];
        unsigned int *v17 = Float;
        unint64_t v10 = v17 + 1;
        while (end != begin)
        {
          unsigned int v18 = *--end;
          *--uint64_t v17 = v18;
        }
        __p.__begin_ = v17;
        __p.__end_ = v10;
        __p.__end_cap_.__value_ = (unsigned int *)&v16[4 * v15];
        if (begin) {
          operator delete(begin);
        }
      }
      else
      {
        *__p.__end_ = Float;
        unint64_t v10 = end + 1;
      }
      __p.__end_ = v10;
      ++v7;
      uint64_t v6 = a1[4];
    }
    while (v7 < (a1[5] - v6) >> 1);
  }
  MIL::ValueInference::Tensor<int>::Tensor(a2, &v20, (__n128 *)&__p);
  if (__p.__begin_)
  {
    __p.__end_ = __p.__begin_;
    operator delete(__p.__begin_);
  }
  if (v20.n128_u64[0])
  {
    v20.n128_u64[1] = v20.n128_u64[0];
    operator delete((void *)v20.n128_u64[0]);
  }
}

void sub_20F4B9CA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<MIL::Bf16>::Cast<short>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v22 = 0;
  __n128 v21 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v21, v4, v5, (v5 - (uint64_t)v4) >> 3);
  __n128 __p = 0uLL;
  unint64_t v20 = 0;
  std::vector<MIL::Fp16>::reserve((void **)&__p, (uint64_t)(a1[5] - a1[4]) >> 1);
  uint64_t v6 = a1[4];
  if (a1[5] != v6)
  {
    unint64_t v7 = 0;
    do
    {
      int Float = (int)MIL::Bf16::GetFloat((MIL::Bf16 *)(v6 + 2 * v7));
      unint64_t v9 = __p.n128_u64[1];
      if (__p.n128_u64[1] >= v20)
      {
        unint64_t v11 = (void *)__p.n128_u64[0];
        int64_t v12 = __p.n128_u64[1] - __p.n128_u64[0];
        if ((uint64_t)(__p.n128_u64[1] - __p.n128_u64[0]) <= -3) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v13 = v12 >> 1;
        if (v20 - __p.n128_u64[0] <= (v12 >> 1) + 1) {
          uint64_t v14 = v13 + 1;
        }
        else {
          uint64_t v14 = v20 - __p.n128_u64[0];
        }
        if (v20 - __p.n128_u64[0] >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v15 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v15 = v14;
        }
        if (v15)
        {
          unint64_t v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MIL::Fp16>>((uint64_t)&v20, v15);
          unint64_t v9 = __p.n128_u64[1];
          unint64_t v11 = (void *)__p.n128_u64[0];
        }
        else
        {
          unint64_t v16 = 0;
        }
        uint64_t v17 = &v16[2 * v13];
        *(_WORD *)uint64_t v17 = Float;
        unint64_t v10 = (unint64_t)(v17 + 2);
        while ((void *)v9 != v11)
        {
          __int16 v18 = *(_WORD *)(v9 - 2);
          v9 -= 2;
          *((_WORD *)v17 - 1) = v18;
          v17 -= 2;
        }
        __p.n128_u64[0] = (unint64_t)v17;
        __p.n128_u64[1] = v10;
        unint64_t v20 = (unint64_t)&v16[2 * v15];
        if (v11) {
          operator delete(v11);
        }
      }
      else
      {
        *(_WORD *)__p.n128_u64[1] = Float;
        unint64_t v10 = v9 + 2;
      }
      __p.n128_u64[1] = v10;
      ++v7;
      uint64_t v6 = a1[4];
    }
    while (v7 < (a1[5] - v6) >> 1);
  }
  MIL::ValueInference::Tensor<short>::Tensor(a2, &v21, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v21.n128_u64[0])
  {
    v21.n128_u64[1] = v21.n128_u64[0];
    operator delete((void *)v21.n128_u64[0]);
  }
}

void sub_20F4B9E6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<MIL::Bf16>::Cast<unsigned short>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v22 = 0;
  __n128 v21 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v21, v4, v5, (v5 - (uint64_t)v4) >> 3);
  __n128 __p = 0uLL;
  unint64_t v20 = 0;
  std::vector<MIL::Fp16>::reserve((void **)&__p, (uint64_t)(a1[5] - a1[4]) >> 1);
  uint64_t v6 = a1[4];
  if (a1[5] != v6)
  {
    unint64_t v7 = 0;
    do
    {
      int Float = (int)MIL::Bf16::GetFloat((MIL::Bf16 *)(v6 + 2 * v7));
      unint64_t v9 = __p.n128_u64[1];
      if (__p.n128_u64[1] >= v20)
      {
        unint64_t v11 = (void *)__p.n128_u64[0];
        int64_t v12 = __p.n128_u64[1] - __p.n128_u64[0];
        if ((uint64_t)(__p.n128_u64[1] - __p.n128_u64[0]) <= -3) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v13 = v12 >> 1;
        if (v20 - __p.n128_u64[0] <= (v12 >> 1) + 1) {
          uint64_t v14 = v13 + 1;
        }
        else {
          uint64_t v14 = v20 - __p.n128_u64[0];
        }
        if (v20 - __p.n128_u64[0] >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v15 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v15 = v14;
        }
        if (v15)
        {
          unint64_t v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MIL::Fp16>>((uint64_t)&v20, v15);
          unint64_t v9 = __p.n128_u64[1];
          unint64_t v11 = (void *)__p.n128_u64[0];
        }
        else
        {
          unint64_t v16 = 0;
        }
        uint64_t v17 = &v16[2 * v13];
        *(_WORD *)uint64_t v17 = Float;
        unint64_t v10 = (unint64_t)(v17 + 2);
        while ((void *)v9 != v11)
        {
          __int16 v18 = *(_WORD *)(v9 - 2);
          v9 -= 2;
          *((_WORD *)v17 - 1) = v18;
          v17 -= 2;
        }
        __p.n128_u64[0] = (unint64_t)v17;
        __p.n128_u64[1] = v10;
        unint64_t v20 = (unint64_t)&v16[2 * v15];
        if (v11) {
          operator delete(v11);
        }
      }
      else
      {
        *(_WORD *)__p.n128_u64[1] = Float;
        unint64_t v10 = v9 + 2;
      }
      __p.n128_u64[1] = v10;
      ++v7;
      uint64_t v6 = a1[4];
    }
    while (v7 < (a1[5] - v6) >> 1);
  }
  MIL::ValueInference::Tensor<unsigned short>::Tensor(a2, &v21, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v21.n128_u64[0])
  {
    v21.n128_u64[1] = v21.n128_u64[0];
    operator delete((void *)v21.n128_u64[0]);
  }
}

void sub_20F4BA030(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<MIL::Bf16>::Cast<signed char>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v24 = 0;
  __n128 v23 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v23, v4, v5, (v5 - (uint64_t)v4) >> 3);
  __n128 __p = 0uLL;
  unint64_t v22 = 0;
  std::vector<unsigned char>::reserve(__p.n128_u64, (uint64_t)(a1[5] - a1[4]) >> 1);
  uint64_t v6 = a1[4];
  if (a1[5] != v6)
  {
    unint64_t v7 = 0;
    do
    {
      int Float = (int)MIL::Bf16::GetFloat((MIL::Bf16 *)(v6 + 2 * v7));
      unint64_t v9 = (char *)__p.n128_u64[1];
      if (__p.n128_u64[1] >= v22)
      {
        unint64_t v11 = __p.n128_u64[0];
        unint64_t v12 = __p.n128_u64[1] - __p.n128_u64[0];
        int64_t v13 = __p.n128_u64[1] - __p.n128_u64[0] + 1;
        if (v13 < 0) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v14 = v22 - __p.n128_u64[0];
        if (2 * (v22 - __p.n128_u64[0]) > v13) {
          int64_t v13 = 2 * v14;
        }
        if (v14 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v15 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v15 = v13;
        }
        if (v15) {
          unint64_t v16 = (unint64_t)operator new(v15);
        }
        else {
          unint64_t v16 = 0;
        }
        unint64_t v17 = v16 + v12;
        __int16 v18 = (unsigned char *)(v16 + v12);
        unsigned char *v18 = Float;
        unint64_t v10 = (unint64_t)(v18 + 1);
        if (v9 != (char *)v11)
        {
          int v19 = &v9[~v11];
          do
          {
            char v20 = *--v9;
            (v19--)[v16] = v20;
          }
          while (v9 != (char *)v11);
          unint64_t v9 = (char *)__p.n128_u64[0];
          unint64_t v17 = v16;
        }
        __p.n128_u64[0] = v17;
        __p.n128_u64[1] = v10;
        unint64_t v22 = v16 + v15;
        if (v9) {
          operator delete(v9);
        }
      }
      else
      {
        *(unsigned char *)__p.n128_u64[1] = Float;
        unint64_t v10 = (unint64_t)(v9 + 1);
      }
      __p.n128_u64[1] = v10;
      ++v7;
      uint64_t v6 = a1[4];
    }
    while (v7 < (a1[5] - v6) >> 1);
  }
  MIL::ValueInference::Tensor<signed char>::Tensor(a2, &v23, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v23.n128_u64[0])
  {
    v23.n128_u64[1] = v23.n128_u64[0];
    operator delete((void *)v23.n128_u64[0]);
  }
}

void sub_20F4BA204(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<MIL::Bf16>::Cast<unsigned char>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v24 = 0;
  __n128 v23 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v23, v4, v5, (v5 - (uint64_t)v4) >> 3);
  __n128 __p = 0uLL;
  unint64_t v22 = 0;
  std::vector<unsigned char>::reserve(__p.n128_u64, (uint64_t)(a1[5] - a1[4]) >> 1);
  uint64_t v6 = a1[4];
  if (a1[5] != v6)
  {
    unint64_t v7 = 0;
    do
    {
      int Float = (int)MIL::Bf16::GetFloat((MIL::Bf16 *)(v6 + 2 * v7));
      unint64_t v9 = (char *)__p.n128_u64[1];
      if (__p.n128_u64[1] >= v22)
      {
        unint64_t v11 = __p.n128_u64[0];
        unint64_t v12 = __p.n128_u64[1] - __p.n128_u64[0];
        int64_t v13 = __p.n128_u64[1] - __p.n128_u64[0] + 1;
        if (v13 < 0) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v14 = v22 - __p.n128_u64[0];
        if (2 * (v22 - __p.n128_u64[0]) > v13) {
          int64_t v13 = 2 * v14;
        }
        if (v14 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v15 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v15 = v13;
        }
        if (v15) {
          unint64_t v16 = (unint64_t)operator new(v15);
        }
        else {
          unint64_t v16 = 0;
        }
        unint64_t v17 = v16 + v12;
        __int16 v18 = (unsigned char *)(v16 + v12);
        unsigned char *v18 = Float;
        unint64_t v10 = (unint64_t)(v18 + 1);
        if (v9 != (char *)v11)
        {
          int v19 = &v9[~v11];
          do
          {
            char v20 = *--v9;
            (v19--)[v16] = v20;
          }
          while (v9 != (char *)v11);
          unint64_t v9 = (char *)__p.n128_u64[0];
          unint64_t v17 = v16;
        }
        __p.n128_u64[0] = v17;
        __p.n128_u64[1] = v10;
        unint64_t v22 = v16 + v15;
        if (v9) {
          operator delete(v9);
        }
      }
      else
      {
        *(unsigned char *)__p.n128_u64[1] = Float;
        unint64_t v10 = (unint64_t)(v9 + 1);
      }
      __p.n128_u64[1] = v10;
      ++v7;
      uint64_t v6 = a1[4];
    }
    while (v7 < (a1[5] - v6) >> 1);
  }
  MIL::ValueInference::Tensor<unsigned char>::Tensor(a2, &v23, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v23.n128_u64[0])
  {
    v23.n128_u64[1] = v23.n128_u64[0];
    operator delete((void *)v23.n128_u64[0]);
  }
}

void sub_20F4BA3D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<MIL::Fp16>::Cast<float>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v23 = 0;
  __n128 v22 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v22, v4, v5, (v5 - (uint64_t)v4) >> 3);
  __n128 __p = 0uLL;
  unint64_t v21 = 0;
  std::vector<float>::reserve((void **)&__p, (uint64_t)(a1[5] - a1[4]) >> 1);
  uint64_t v6 = a1[4];
  if (a1[5] != v6)
  {
    unint64_t v7 = 0;
    do
    {
      float Float = MIL::Fp16::GetFloat((MIL::Fp16 *)(v6 + 2 * v7));
      float v9 = Float;
      unint64_t v10 = __p.n128_u64[1];
      if (__p.n128_u64[1] >= v21)
      {
        unint64_t v12 = (void *)__p.n128_u64[0];
        uint64_t v13 = (uint64_t)(__p.n128_u64[1] - __p.n128_u64[0]) >> 2;
        unint64_t v14 = v13 + 1;
        if ((unint64_t)(v13 + 1) >> 62) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v15 = v21 - __p.n128_u64[0];
        if ((uint64_t)(v21 - __p.n128_u64[0]) >> 1 > v14) {
          unint64_t v14 = v15 >> 1;
        }
        if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v16 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v16 = v14;
        }
        if (v16)
        {
          unint64_t v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v21, v16);
          unint64_t v10 = __p.n128_u64[1];
          unint64_t v12 = (void *)__p.n128_u64[0];
        }
        else
        {
          unint64_t v17 = 0;
        }
        __int16 v18 = (float *)&v17[4 * v13];
        float *v18 = v9;
        unint64_t v11 = (unint64_t)(v18 + 1);
        while ((void *)v10 != v12)
        {
          int v19 = *(_DWORD *)(v10 - 4);
          v10 -= 4;
          *((_DWORD *)v18-- - 1) = v19;
        }
        __p.n128_u64[0] = (unint64_t)v18;
        __p.n128_u64[1] = v11;
        unint64_t v21 = (unint64_t)&v17[4 * v16];
        if (v12) {
          operator delete(v12);
        }
      }
      else
      {
        *(float *)__p.n128_u64[1] = Float;
        unint64_t v11 = v10 + 4;
      }
      __p.n128_u64[1] = v11;
      ++v7;
      uint64_t v6 = a1[4];
    }
    while (v7 < (a1[5] - v6) >> 1);
  }
  MIL::ValueInference::Tensor<float>::Tensor(a2, &v22, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v22.n128_u64[0])
  {
    v22.n128_u64[1] = v22.n128_u64[0];
    operator delete((void *)v22.n128_u64[0]);
  }
}

void sub_20F4BA5A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<MIL::Fp16>::Cast<int>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v21 = 0;
  __n128 v20 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v20, v4, v5, (v5 - (uint64_t)v4) >> 3);
  memset(&__p, 0, sizeof(__p));
  std::vector<int>::reserve(&__p, (uint64_t)(a1[5] - a1[4]) >> 1);
  uint64_t v6 = a1[4];
  if (a1[5] != v6)
  {
    unint64_t v7 = 0;
    do
    {
      unsigned int Float = (int)MIL::Fp16::GetFloat((MIL::Fp16 *)(v6 + 2 * v7));
      std::vector<unsigned int>::pointer end = __p.__end_;
      if (__p.__end_ >= __p.__end_cap_.__value_)
      {
        std::vector<unsigned int>::pointer begin = __p.__begin_;
        int64_t v12 = __p.__end_ - __p.__begin_;
        unint64_t v13 = v12 + 1;
        if ((unint64_t)(v12 + 1) >> 62) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        int64_t v14 = (char *)__p.__end_cap_.__value_ - (char *)__p.__begin_;
        if (((char *)__p.__end_cap_.__value_ - (char *)__p.__begin_) >> 1 > v13) {
          unint64_t v13 = v14 >> 1;
        }
        if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v15 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v15 = v13;
        }
        if (v15)
        {
          unint64_t v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&__p.__end_cap_, v15);
          std::vector<unsigned int>::pointer begin = __p.__begin_;
          std::vector<unsigned int>::pointer end = __p.__end_;
        }
        else
        {
          unint64_t v16 = 0;
        }
        unint64_t v17 = (unsigned int *)&v16[4 * v12];
        unsigned int *v17 = Float;
        unint64_t v10 = v17 + 1;
        while (end != begin)
        {
          unsigned int v18 = *--end;
          *--unint64_t v17 = v18;
        }
        __p.__begin_ = v17;
        __p.__end_ = v10;
        __p.__end_cap_.__value_ = (unsigned int *)&v16[4 * v15];
        if (begin) {
          operator delete(begin);
        }
      }
      else
      {
        *__p.__end_ = Float;
        unint64_t v10 = end + 1;
      }
      __p.__end_ = v10;
      ++v7;
      uint64_t v6 = a1[4];
    }
    while (v7 < (a1[5] - v6) >> 1);
  }
  MIL::ValueInference::Tensor<int>::Tensor(a2, &v20, (__n128 *)&__p);
  if (__p.__begin_)
  {
    __p.__end_ = __p.__begin_;
    operator delete(__p.__begin_);
  }
  if (v20.n128_u64[0])
  {
    v20.n128_u64[1] = v20.n128_u64[0];
    operator delete((void *)v20.n128_u64[0]);
  }
}

void sub_20F4BA770(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<MIL::Fp16>::Cast<unsigned short>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v22 = 0;
  __n128 v21 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v21, v4, v5, (v5 - (uint64_t)v4) >> 3);
  __n128 __p = 0uLL;
  unint64_t v20 = 0;
  std::vector<MIL::Fp16>::reserve((void **)&__p, (uint64_t)(a1[5] - a1[4]) >> 1);
  uint64_t v6 = a1[4];
  if (a1[5] != v6)
  {
    unint64_t v7 = 0;
    do
    {
      int Float = (int)MIL::Fp16::GetFloat((MIL::Fp16 *)(v6 + 2 * v7));
      unint64_t v9 = __p.n128_u64[1];
      if (__p.n128_u64[1] >= v20)
      {
        unint64_t v11 = (void *)__p.n128_u64[0];
        int64_t v12 = __p.n128_u64[1] - __p.n128_u64[0];
        if ((uint64_t)(__p.n128_u64[1] - __p.n128_u64[0]) <= -3) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v13 = v12 >> 1;
        if (v20 - __p.n128_u64[0] <= (v12 >> 1) + 1) {
          uint64_t v14 = v13 + 1;
        }
        else {
          uint64_t v14 = v20 - __p.n128_u64[0];
        }
        if (v20 - __p.n128_u64[0] >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v15 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v15 = v14;
        }
        if (v15)
        {
          unint64_t v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MIL::Fp16>>((uint64_t)&v20, v15);
          unint64_t v9 = __p.n128_u64[1];
          unint64_t v11 = (void *)__p.n128_u64[0];
        }
        else
        {
          unint64_t v16 = 0;
        }
        unint64_t v17 = &v16[2 * v13];
        *(_WORD *)unint64_t v17 = Float;
        unint64_t v10 = (unint64_t)(v17 + 2);
        while ((void *)v9 != v11)
        {
          __int16 v18 = *(_WORD *)(v9 - 2);
          v9 -= 2;
          *((_WORD *)v17 - 1) = v18;
          v17 -= 2;
        }
        __p.n128_u64[0] = (unint64_t)v17;
        __p.n128_u64[1] = v10;
        unint64_t v20 = (unint64_t)&v16[2 * v15];
        if (v11) {
          operator delete(v11);
        }
      }
      else
      {
        *(_WORD *)__p.n128_u64[1] = Float;
        unint64_t v10 = v9 + 2;
      }
      __p.n128_u64[1] = v10;
      ++v7;
      uint64_t v6 = a1[4];
    }
    while (v7 < (a1[5] - v6) >> 1);
  }
  MIL::ValueInference::Tensor<unsigned short>::Tensor(a2, &v21, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v21.n128_u64[0])
  {
    v21.n128_u64[1] = v21.n128_u64[0];
    operator delete((void *)v21.n128_u64[0]);
  }
}

void sub_20F4BA934(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<MIL::Fp16>::Cast<short>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v22 = 0;
  __n128 v21 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v21, v4, v5, (v5 - (uint64_t)v4) >> 3);
  __n128 __p = 0uLL;
  unint64_t v20 = 0;
  std::vector<MIL::Fp16>::reserve((void **)&__p, (uint64_t)(a1[5] - a1[4]) >> 1);
  uint64_t v6 = a1[4];
  if (a1[5] != v6)
  {
    unint64_t v7 = 0;
    do
    {
      int Float = (int)MIL::Fp16::GetFloat((MIL::Fp16 *)(v6 + 2 * v7));
      unint64_t v9 = __p.n128_u64[1];
      if (__p.n128_u64[1] >= v20)
      {
        unint64_t v11 = (void *)__p.n128_u64[0];
        int64_t v12 = __p.n128_u64[1] - __p.n128_u64[0];
        if ((uint64_t)(__p.n128_u64[1] - __p.n128_u64[0]) <= -3) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v13 = v12 >> 1;
        if (v20 - __p.n128_u64[0] <= (v12 >> 1) + 1) {
          uint64_t v14 = v13 + 1;
        }
        else {
          uint64_t v14 = v20 - __p.n128_u64[0];
        }
        if (v20 - __p.n128_u64[0] >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v15 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v15 = v14;
        }
        if (v15)
        {
          unint64_t v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MIL::Fp16>>((uint64_t)&v20, v15);
          unint64_t v9 = __p.n128_u64[1];
          unint64_t v11 = (void *)__p.n128_u64[0];
        }
        else
        {
          unint64_t v16 = 0;
        }
        unint64_t v17 = &v16[2 * v13];
        *(_WORD *)unint64_t v17 = Float;
        unint64_t v10 = (unint64_t)(v17 + 2);
        while ((void *)v9 != v11)
        {
          __int16 v18 = *(_WORD *)(v9 - 2);
          v9 -= 2;
          *((_WORD *)v17 - 1) = v18;
          v17 -= 2;
        }
        __p.n128_u64[0] = (unint64_t)v17;
        __p.n128_u64[1] = v10;
        unint64_t v20 = (unint64_t)&v16[2 * v15];
        if (v11) {
          operator delete(v11);
        }
      }
      else
      {
        *(_WORD *)__p.n128_u64[1] = Float;
        unint64_t v10 = v9 + 2;
      }
      __p.n128_u64[1] = v10;
      ++v7;
      uint64_t v6 = a1[4];
    }
    while (v7 < (a1[5] - v6) >> 1);
  }
  MIL::ValueInference::Tensor<short>::Tensor(a2, &v21, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v21.n128_u64[0])
  {
    v21.n128_u64[1] = v21.n128_u64[0];
    operator delete((void *)v21.n128_u64[0]);
  }
}

void sub_20F4BAAF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<MIL::Fp16>::Cast<unsigned char>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v24 = 0;
  __n128 v23 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v23, v4, v5, (v5 - (uint64_t)v4) >> 3);
  __n128 __p = 0uLL;
  unint64_t v22 = 0;
  std::vector<unsigned char>::reserve(__p.n128_u64, (uint64_t)(a1[5] - a1[4]) >> 1);
  uint64_t v6 = a1[4];
  if (a1[5] != v6)
  {
    unint64_t v7 = 0;
    do
    {
      int Float = (int)MIL::Fp16::GetFloat((MIL::Fp16 *)(v6 + 2 * v7));
      unint64_t v9 = (char *)__p.n128_u64[1];
      if (__p.n128_u64[1] >= v22)
      {
        unint64_t v11 = __p.n128_u64[0];
        unint64_t v12 = __p.n128_u64[1] - __p.n128_u64[0];
        int64_t v13 = __p.n128_u64[1] - __p.n128_u64[0] + 1;
        if (v13 < 0) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v14 = v22 - __p.n128_u64[0];
        if (2 * (v22 - __p.n128_u64[0]) > v13) {
          int64_t v13 = 2 * v14;
        }
        if (v14 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v15 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v15 = v13;
        }
        if (v15) {
          unint64_t v16 = (unint64_t)operator new(v15);
        }
        else {
          unint64_t v16 = 0;
        }
        unint64_t v17 = v16 + v12;
        __int16 v18 = (unsigned char *)(v16 + v12);
        unsigned char *v18 = Float;
        unint64_t v10 = (unint64_t)(v18 + 1);
        if (v9 != (char *)v11)
        {
          int v19 = &v9[~v11];
          do
          {
            char v20 = *--v9;
            (v19--)[v16] = v20;
          }
          while (v9 != (char *)v11);
          unint64_t v9 = (char *)__p.n128_u64[0];
          unint64_t v17 = v16;
        }
        __p.n128_u64[0] = v17;
        __p.n128_u64[1] = v10;
        unint64_t v22 = v16 + v15;
        if (v9) {
          operator delete(v9);
        }
      }
      else
      {
        *(unsigned char *)__p.n128_u64[1] = Float;
        unint64_t v10 = (unint64_t)(v9 + 1);
      }
      __p.n128_u64[1] = v10;
      ++v7;
      uint64_t v6 = a1[4];
    }
    while (v7 < (a1[5] - v6) >> 1);
  }
  MIL::ValueInference::Tensor<unsigned char>::Tensor(a2, &v23, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v23.n128_u64[0])
  {
    v23.n128_u64[1] = v23.n128_u64[0];
    operator delete((void *)v23.n128_u64[0]);
  }
}

void sub_20F4BACCC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<MIL::Fp16>::Cast<signed char>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v24 = 0;
  __n128 v23 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v23, v4, v5, (v5 - (uint64_t)v4) >> 3);
  __n128 __p = 0uLL;
  unint64_t v22 = 0;
  std::vector<unsigned char>::reserve(__p.n128_u64, (uint64_t)(a1[5] - a1[4]) >> 1);
  uint64_t v6 = a1[4];
  if (a1[5] != v6)
  {
    unint64_t v7 = 0;
    do
    {
      int Float = (int)MIL::Fp16::GetFloat((MIL::Fp16 *)(v6 + 2 * v7));
      unint64_t v9 = (char *)__p.n128_u64[1];
      if (__p.n128_u64[1] >= v22)
      {
        unint64_t v11 = __p.n128_u64[0];
        unint64_t v12 = __p.n128_u64[1] - __p.n128_u64[0];
        int64_t v13 = __p.n128_u64[1] - __p.n128_u64[0] + 1;
        if (v13 < 0) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v14 = v22 - __p.n128_u64[0];
        if (2 * (v22 - __p.n128_u64[0]) > v13) {
          int64_t v13 = 2 * v14;
        }
        if (v14 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v15 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v15 = v13;
        }
        if (v15) {
          unint64_t v16 = (unint64_t)operator new(v15);
        }
        else {
          unint64_t v16 = 0;
        }
        unint64_t v17 = v16 + v12;
        __int16 v18 = (unsigned char *)(v16 + v12);
        unsigned char *v18 = Float;
        unint64_t v10 = (unint64_t)(v18 + 1);
        if (v9 != (char *)v11)
        {
          int v19 = &v9[~v11];
          do
          {
            char v20 = *--v9;
            (v19--)[v16] = v20;
          }
          while (v9 != (char *)v11);
          unint64_t v9 = (char *)__p.n128_u64[0];
          unint64_t v17 = v16;
        }
        __p.n128_u64[0] = v17;
        __p.n128_u64[1] = v10;
        unint64_t v22 = v16 + v15;
        if (v9) {
          operator delete(v9);
        }
      }
      else
      {
        *(unsigned char *)__p.n128_u64[1] = Float;
        unint64_t v10 = (unint64_t)(v9 + 1);
      }
      __p.n128_u64[1] = v10;
      ++v7;
      uint64_t v6 = a1[4];
    }
    while (v7 < (a1[5] - v6) >> 1);
  }
  MIL::ValueInference::Tensor<signed char>::Tensor(a2, &v23, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v23.n128_u64[0])
  {
    v23.n128_u64[1] = v23.n128_u64[0];
    operator delete((void *)v23.n128_u64[0]);
  }
}

void sub_20F4BAEA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<float>::FromIRTensorValue(void *a1@<X0>, uint64_t a2@<X8>)
{
  MIL::IRTensorValue::TryGetDataView<float>(&v12, *a1);
  if (!(_BYTE)v12)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Failed to get data view.");
    unint64_t v7 = (struct type_info *)MEMORY[0x263F8C1F0];
    uint64_t v8 = (void (*)(void *))MEMORY[0x263F8C070];
    goto LABEL_10;
  }
  int v4 = (MIL *)(*(uint64_t (**)(void))(*(void *)*a1 + 32))();
  if ((*(unsigned int (**)(MIL *))(*(void *)v4 + 88))(v4) == 3)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100]((std::logic_error *)exception, "It is not supported to convert a tensor of string dtype.");
    unint64_t v7 = (struct type_info *)off_26412C1F0;
    uint64_t v8 = (void (*)(void *))MEMORY[0x263F8C080];
LABEL_10:
    __cxa_throw(exception, v7, v8);
  }
  MIL::GetTensorShapeWithDimensionsAllKnown(v4, v5, (uint64_t)&v11);
  uint64_t v10 = 0;
  __n128 __p = 0uLL;
  std::vector<float>::__init_with_size[abi:ne180100]<float const*,float const*>(&__p, v13, (uint64_t)v13 + 4 * v14, v14);
  MIL::ValueInference::Tensor<float>::Tensor(a2, &v11, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v11.n128_u64[0])
  {
    v11.n128_u64[1] = v11.n128_u64[0];
    operator delete((void *)v11.n128_u64[0]);
  }
}

void sub_20F4BB028(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  __cxa_free_exception(v14);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<float>::ToIRTensorValue(uint64_t a1, MIL::IRConstantDimension *a2)
{
  memset(__p, 0, sizeof(__p));
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(__p, *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3);
  MIL::IRTensorValueType::Make(a2, 5, (MIL::MILContext ***)__p);
}

void sub_20F4BB130(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::ValueInference::Tensor<float>::Tensor(uint64_t a1, __n128 *a2, __n128 *a3)
{
  *(_OWORD *)(a1 + 8) = 0u;
  uint64_t v5 = a1 + 8;
  *(void *)a1 = &unk_26C259DB8;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  uint64_t v6 = (uint64_t *)a2->n128_u64[0];
  unint64_t v7 = (uint64_t *)a2->n128_u64[1];
  if ((uint64_t *)a2->n128_u64[0] == v7)
  {
    unint64_t v10 = a3->n128_u64[0];
    unint64_t v11 = a3->n128_u64[1];
    uint64_t v8 = a3->n128_u64[0] != v11;
  }
  else
  {
    uint64_t v8 = 1;
    do
    {
      uint64_t v9 = *v6++;
      v8 *= v9;
    }
    while (v6 != v7);
    unint64_t v10 = a3->n128_u64[0];
    unint64_t v11 = a3->n128_u64[1];
  }
  if (v8 != (uint64_t)(v11 - v10) >> 2)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "data size and shape dismatch.");
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  std::vector<float>::__move_assign(v5, a2);
  std::vector<float>::__move_assign(a1 + 32, a3);
  *(void *)(a1 + 56) = v8;
  return a1;
}

void sub_20F4BB268(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10)
{
  int64_t v13 = *v11;
  if (*v11)
  {
    *(void *)(v10 + 40) = v13;
    operator delete(v13);
  }
  unint64_t v14 = *a10;
  if (*a10)
  {
    *(void *)(v10 + 16) = v14;
    operator delete(v14);
  }
  _Unwind_Resume(exception_object);
}

double MIL::ValueInference::Tensor<float>::Tensor(uint64_t a1)
{
  *(void *)a1 = &unk_26C259DB8;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  return result;
}

uint64_t MIL::ValueInference::Tensor<float>::GetDataView(uint64_t a1)
{
  if (*(void *)(a1 + 40) == *(void *)(a1 + 32)) {
    return 0;
  }
  else {
    return *(void *)(a1 + 32);
  }
}

uint64_t MIL::ValueInference::Tensor<float>::GetNumElements(uint64_t a1)
{
  return *(void *)(a1 + 56);
}

unint64_t MIL::ValueInference::Tensor<float>::operator[](uint64_t a1, uint64_t *a2)
{
}

unint64_t anonymous namespace'::FlattenIndices(void *a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v2 = a2[1];
  unint64_t v4 = (v2 - *a2) >> 3;
  if (v4 != (uint64_t)(a1[1] - *a1) >> 3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "indices must have the same length as the shape.");
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  if (v2 == v3) {
    return 0;
  }
  uint64_t v5 = 0;
  unint64_t v6 = 0;
  if (v4 <= 1) {
    unint64_t v4 = 1;
  }
  do
  {
    unint64_t v7 = *(void *)(v3 + 8 * v5);
    unint64_t v8 = *(void *)(*a1 + 8 * v5);
    if (v7 >= v8)
    {
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v14);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)"index ", 6);
      uint64_t v10 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)" cannnot be out of the range of dimension ", 42);
      std::ostream::operator<<();
      unint64_t v11 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::stringbuf::str();
      std::logic_error::logic_error(v11, &v13);
      v11->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C390] + 16);
      __cxa_throw(v11, (struct type_info *)off_26412C1E0, MEMORY[0x263F8C068]);
    }
    unint64_t v6 = v7 + v8 * v6;
    ++v5;
  }
  while (v4 != v5);
  return v6;
}

void sub_20F4BB4A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  __cxa_free_exception(v17);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<float>::ForEach(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v14[4] = *MEMORY[0x263EF8340];
  unint64_t v6 = (uint64_t)(*(void *)(a1 + 40) - *(void *)(a1 + 32)) >> 2;
  __p.n128_u32[0] = 0;
  std::vector<float>::vector(&v13, v6, &__p);
  __n128 __p = 0uLL;
  uint64_t v12 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3);
  unint64_t v8 = *(float **)(a1 + 32);
  unint64_t v7 = *(float **)(a1 + 40);
  uint64_t v9 = (_DWORD *)v13.n128_u64[0];
  std::__function::__value_func<float ()(float)>::__value_func[abi:ne180100]((uint64_t)v14, a2);
  while (v8 != v7)
  {
    std::function<float ()(float)>::operator()((uint64_t)v14, *v8);
    *v9++ = v10;
    ++v8;
  }
  std::__function::__value_func<float ()(float)>::~__value_func[abi:ne180100](v14);
  MIL::ValueInference::Tensor<float>::Tensor(a3, &__p, &v13);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v13.n128_u64[0])
  {
    v13.n128_u64[1] = v13.n128_u64[0];
    operator delete((void *)v13.n128_u64[0]);
  }
}

void sub_20F4BB610(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, char a16)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

float MIL::ValueInference::Tensor<float>::GetScalarData(void *a1)
{
  if (a1[1] != a1[2] || (uint64_t v1 = a1[4], a1[5] - v1 != 4))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Tensor is not a scalar.");
    __cxa_throw(exception, MEMORY[0x263F8C1E0], MEMORY[0x263F8C048]);
  }
  return *(float *)v1;
}

void sub_20F4BB6D0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<float>::Reshape(void *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v6 = (uint64_t *)*a2;
  uint64_t v7 = a2[1];
  uint64_t v8 = 1;
  if (v6 != (uint64_t *)v7)
  {
    uint64_t v9 = v6;
    do
    {
      uint64_t v10 = *v9++;
      v8 *= v10;
    }
    while (v9 != (uint64_t *)v7);
  }
  if (a1[7] != v8)
  {
    __n128 v13 = a2;
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v22);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"Tensor is not able to be reshaped since the number of elements in the newShape [ ", 81);
    uint64_t v14 = *v13;
    uint64_t v15 = v13[1];
    if (*v13 != v15)
    {
      do
      {
        unint64_t v16 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)" ", 1);
        v14 += 8;
      }
      while (v14 != v15);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"] is not the same as the number of elements in the tensor shape [ ", 66);
    uint64_t v17 = a1[1];
    for (uint64_t i = a1[2]; v17 != i; v17 += 8)
    {
      int v19 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)" ", 1);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"].", 2);
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str();
    std::logic_error::logic_error(exception, &__p);
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  __n128 v22 = 0uLL;
  uint64_t v23 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v22, v6, v7, (v7 - (uint64_t)v6) >> 3);
  unint64_t v11 = (const void *)a1[4];
  uint64_t v12 = a1[5];
  memset(&__p, 0, sizeof(__p));
  std::vector<float>::__init_with_size[abi:ne180100]<std::__wrap_iter<float const*>,std::__wrap_iter<float const*>>(&__p, v11, v12, (v12 - (uint64_t)v11) >> 2);
  MIL::ValueInference::Tensor<float>::Tensor(a3, &v22, (__n128 *)&__p);
  if (__p.__r_.__value_.__r.__words[0])
  {
    __p.__r_.__value_.__l.__size_ = __p.__r_.__value_.__r.__words[0];
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v22.n128_u64[0])
  {
    v22.n128_u64[1] = v22.n128_u64[0];
    operator delete((void *)v22.n128_u64[0]);
  }
}

void sub_20F4BB8E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((v17 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v17)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v16);
  goto LABEL_6;
}

void MIL::ValueInference::Tensor<float>::NonZero(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v3 = *(void *)(a1 + 56);
  if (v3)
  {
    unint64_t v5 = 0;
    unint64_t v6 = (uint64_t **)(a1 + 8);
    do
    {
      if (*(float *)(*(void *)(a1 + 32) + 4 * v5) != 0.0)
      {
        std::vector<std::vector<unsigned long long>>::push_back[abi:ne180100](a2, (uint64_t)__p);
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
        unint64_t v3 = *(void *)(a1 + 56);
      }
      ++v5;
    }
    while (v5 < v3);
  }
}

void sub_20F4BB9FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
  {
    a11 = (uint64_t)__p;
    operator delete(__p);
  }
  std::vector<std::vector<unsigned long long>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::vector<unsigned long long>>::push_back[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  uint64_t v7 = *(void **)(result - 8);
  if ((unint64_t)v7 >= v6)
  {
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v7 - *a1) >> 3);
    unint64_t v10 = v9 + 1;
    if (v9 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 3);
    if (2 * v11 > v10) {
      unint64_t v10 = 2 * v11;
    }
    if (v11 >= 0x555555555555555) {
      unint64_t v12 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v12 = v10;
    }
    v16[4] = result;
    __n128 v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(result, v12);
    uint64_t v14 = &v13[24 * v9];
    v16[0] = v13;
    v16[1] = v14;
    void v16[3] = &v13[24 * v15];
    *((void *)v14 + 1) = 0;
    *((void *)v14 + 2) = 0;
    *(void *)uint64_t v14 = 0;
    *(_OWORD *)uint64_t v14 = *(_OWORD *)a2;
    *((void *)v14 + 2) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    _OWORD v16[2] = v14 + 24;
    std::vector<std::vector<unsigned long long>>::__swap_out_circular_buffer(a1, v16);
    uint64_t v8 = (void *)a1[1];
    uint64_t result = std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)v16);
  }
  else
  {
    *uint64_t v7 = 0;
    v7[1] = 0;
    void v7[2] = 0;
    *(_OWORD *)uint64_t v7 = *(_OWORD *)a2;
    void v7[2] = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    uint64_t v8 = v7 + 3;
    a1[1] = (uint64_t)(v7 + 3);
  }
  a1[1] = (uint64_t)v8;
  return result;
}

void sub_20F4BBB58(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void *anonymous namespace'::UnflattenIndex@<X0>(uint64_t **a1@<X0>, unint64_t a2@<X1>, void *a3@<X8>)
{
  unint64_t v3 = a2;
  unint64_t v5 = a1[1];
  unint64_t v6 = 1;
  if (*a1 != v5)
  {
    uint64_t v7 = *a1;
    do
    {
      uint64_t v8 = *v7++;
      v6 *= v8;
    }
    while (v7 != v5);
  }
  if (v6 <= a2)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "flattened index must be smaller than the number of elements.");
    __cxa_throw(exception, (struct type_info *)off_26412C1E0, MEMORY[0x263F8C068]);
  }
  uint64_t result = std::vector<unsigned long long>::vector(a3, v5 - *a1);
  uint64_t v10 = result[1] - *result;
  if (v10)
  {
    uint64_t v11 = v10 >> 3;
    if ((unint64_t)(v10 >> 3) <= 1) {
      uint64_t v12 = 1;
    }
    else {
      uint64_t v12 = v10 >> 3;
    }
    uint64_t v13 = 8 * v11 - 8;
    uint64_t v14 = (unint64_t *)(*result + v13);
    uint64_t v15 = (unint64_t *)((char *)*a1 + v13);
    do
    {
      *v14-- = v3 % *v15;
      unint64_t v16 = *v15--;
      v3 /= v16;
      --v12;
    }
    while (v12);
  }
  return result;
}

void sub_20F4BBC50(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<float>::SubTensor(void *a1@<X0>, uint64_t **a2@<X1>, void *a3@<X8>)
{
  unint64_t v5 = ((char *)a2[1] - (char *)*a2) >> 4;
  unint64_t v6 = a1 + 1;
  if (v5 != (uint64_t)(a1[2] - a1[1]) >> 3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "Indices does not match the rank of the tensor.");
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  std::string __p = 0;
  uint64_t v46 = 0;
  uint64_t v47 = 0;
  std::vector<unsigned long long>::reserve(&__p, v5);
  uint64_t v8 = a1[1];
  if (a1[2] != v8)
  {
    unint64_t v9 = 0;
    while (1)
    {
      unint64_t v11 = (*a2)[2 * v9];
      unint64_t v10 = (*a2)[2 * v9 + 1];
      unint64_t v12 = v10 - v11;
      if (v10 < v11) {
        break;
      }
      if (v10 > *(void *)(v8 + 8 * v9))
      {
        uint64_t v33 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(v33, "Indices end is out of the bound for the tensor dimension.");
        std::string::size_type v34 = (void (*)(void *))MEMORY[0x263F8C068];
        uint64_t v35 = (struct type_info *)off_26412C1E0;
        uint64_t v36 = MEMORY[0x263F8C390] + 16;
LABEL_45:
        v33->__vftable = (std::logic_error_vtbl *)v36;
        __cxa_throw(v33, v35, v34);
      }
      uint64_t v13 = v46;
      if (v46 >= v47)
      {
        uint64_t v15 = (char *)__p;
        uint64_t v16 = (v46 - (unsigned char *)__p) >> 3;
        unint64_t v17 = v16 + 1;
        if ((unint64_t)(v16 + 1) >> 61) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v18 = v47 - (unsigned char *)__p;
        if ((v47 - (unsigned char *)__p) >> 2 > v17) {
          unint64_t v17 = v18 >> 2;
        }
        if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v19 = v17;
        }
        if (v19)
        {
          char v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v47, v19);
          uint64_t v15 = (char *)__p;
          uint64_t v13 = v46;
        }
        else
        {
          char v20 = 0;
        }
        __n128 v21 = &v20[8 * v16];
        *(void *)__n128 v21 = v12;
        uint64_t v14 = (uint64_t)(v21 + 8);
        while (v13 != v15)
        {
          uint64_t v22 = *((void *)v13 - 1);
          v13 -= 8;
          *((void *)v21 - 1) = v22;
          v21 -= 8;
        }
        std::string __p = v21;
        uint64_t v46 = (char *)v14;
        uint64_t v47 = &v20[8 * v19];
        if (v15) {
          operator delete(v15);
        }
      }
      else
      {
        *(void *)uint64_t v46 = v12;
        uint64_t v14 = (uint64_t)(v13 + 8);
      }
      uint64_t v46 = (char *)v14;
      ++v9;
      uint64_t v8 = a1[1];
      if (v9 >= (a1[2] - v8) >> 3) {
        goto LABEL_25;
      }
    }
    uint64_t v33 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v33, "Indices end must not be smaller than the indices begin.");
    std::string::size_type v34 = (void (*)(void *))MEMORY[0x263F8C080];
    uint64_t v35 = (struct type_info *)off_26412C1F0;
    uint64_t v36 = MEMORY[0x263F8C3A0] + 16;
    goto LABEL_45;
  }
  uint64_t v14 = (uint64_t)v46;
LABEL_25:
  __n128 v43 = 0uLL;
  uint64_t v44 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v43, __p, v14, (v14 - (uint64_t)__p) >> 3);
  MIL::ValueInference::Tensor<float>::Zeros(&v43, (uint64_t)a3);
  if (v43.n128_u64[0])
  {
    v43.n128_u64[1] = v43.n128_u64[0];
    operator delete((void *)v43.n128_u64[0]);
  }
  uint64_t v23 = a3[5] - a3[4];
  if (v23)
  {
    unint64_t v24 = 0;
    unint64_t v25 = v23 >> 2;
    if (v25 <= 1) {
      uint64_t v26 = 1;
    }
    else {
      uint64_t v26 = v25;
    }
    do
    {
      std::string::size_type v38 = 0;
      uint64_t v39 = 0;
      uint64_t v40 = 0;
      std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v38, v41, (uint64_t)v42, (v42 - (unsigned char *)v41) >> 3);
      uint64_t v27 = a1[2] - a1[1];
      if (v27)
      {
        unint64_t v28 = v27 >> 3;
        unint64_t v29 = *a2;
        uint64_t v30 = v38;
        if (v28 <= 1) {
          unint64_t v28 = 1;
        }
        do
        {
          uint64_t v31 = *v29;
          v29 += 2;
          *v30++ += v31;
          --v28;
        }
        while (v28);
      }
      if (v38)
      {
        uint64_t v39 = v38;
        operator delete(v38);
      }
      if (v41)
      {
        uint64_t v42 = v41;
        operator delete(v41);
      }
      ++v24;
    }
    while (v24 != v26);
  }
  if (__p)
  {
    uint64_t v46 = (char *)__p;
    operator delete(__p);
  }
}

void sub_20F4BBFF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19)
{
  __cxa_free_exception(v19);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<float>::Zeros(__n128 *a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t v4 = (uint64_t *)a1->n128_u64[0];
  unint64_t v5 = 1;
  while (v4 != (uint64_t *)a1->n128_u64[1])
  {
    uint64_t v6 = *v4++;
    v5 *= v6;
  }
  std::vector<float>::vector(&__p, v5);
  MIL::ValueInference::Tensor<float>::Tensor(a2, a1, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
}

void sub_20F4BC104(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<float>::Concat(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *a1;
  uint64_t v7 = 0;
  uint64_t v8 = a1[1] - *a1;
  if (v8)
  {
    unint64_t v9 = v8 >> 6;
    if (v9 <= 1) {
      unint64_t v9 = 1;
    }
    unint64_t v10 = (uint64_t *)(v6 + 8);
    do
    {
      uint64_t v11 = *v10;
      v10 += 8;
      v7 += *(void *)(v11 + 8 * a2);
      --v9;
    }
    while (v9);
  }
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  unint64_t v29 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v29, *(const void **)(v6 + 8), *(void *)(v6 + 16), (uint64_t)(*(void *)(v6 + 16) - *(void *)(v6 + 8)) >> 3);
  unint64_t v12 = v29;
  *((void *)v29 + a2) = v7;
  uint64_t v28 = 0;
  __n128 __p = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, v12, (uint64_t)v30, (v30 - (unsigned char *)v12) >> 3);
  MIL::ValueInference::Tensor<float>::Zeros(&__p, a3);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  uint64_t v13 = *a1;
  uint64_t v14 = a1[1];
  if (v14 != *a1)
  {
    unint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(void *)(v13 + (v15 << 6) + 40) - *(void *)(v13 + (v15 << 6) + 32);
      if (v17)
      {
        unint64_t v18 = 0;
        if ((unint64_t)(v17 >> 2) <= 1) {
          uint64_t v19 = 1;
        }
        else {
          uint64_t v19 = v17 >> 2;
        }
        do
        {
          uint64_t v22 = 0;
          uint64_t v23 = 0;
          uint64_t v24 = 0;
          std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v22, v25, (uint64_t)v26, (v26 - (unsigned char *)v25) >> 3);
          *((void *)v22 + a2) += v16;
          unint64_t v20 = *a1 + (v15 << 6);
          int v21 = *(_DWORD *)(*(void *)(v20 + 32)
          *(_DWORD *)(*(void *)(a3 + 32)
          if (v22)
          {
            uint64_t v23 = v22;
            operator delete(v22);
          }
          if (v25)
          {
            uint64_t v26 = v25;
            operator delete(v25);
          }
          ++v18;
        }
        while (v19 != v18);
        uint64_t v13 = *a1;
        uint64_t v14 = a1[1];
      }
      v16 += *(void *)(*(void *)(v13 + (v15++ << 6) + 8) + 8 * a2);
    }
    while (v15 < (v14 - v13) >> 6);
  }
  if (v29)
  {
    uint64_t v30 = v29;
    operator delete(v29);
  }
}

void sub_20F4BC314(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  if (a18) {
    operator delete(a18);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<float>::BlockwiseMerge(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *(uint64_t **)a2;
  uint64_t v7 = *(void *)(a2 + 8) - *(void *)a2;
  if (v7)
  {
    unint64_t v8 = v7 >> 3;
    if (v8 <= 1) {
      unint64_t v8 = 1;
    }
    uint64_t v9 = 1;
    do
    {
      uint64_t v10 = *v6++;
      v9 *= v10;
      --v8;
    }
    while (v8);
  }
  else
  {
    uint64_t v9 = 1;
  }
  uint64_t v11 = *a1;
  if (v9 != (a1[1] - *a1) >> 6)
  {
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v49);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v49, (uint64_t)"The number of tensors (", 23);
    uint64_t v37 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v37, (uint64_t)") is not the same as the number of blocks (", 43);
    std::string::size_type v38 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v38, (uint64_t)").", 2);
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str();
    std::runtime_error::runtime_error(exception, &v48);
    __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
  }
  uint64_t v50 = 0;
  uint64_t v51 = 0;
  uint64_t v49 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v49, *(const void **)(v11 + 8), *(void *)(v11 + 16), (uint64_t)(*(void *)(v11 + 16) - *(void *)(v11 + 8)) >> 3);
  memset(&v48, 0, sizeof(v48));
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v48, v49, (uint64_t)v50, (v50 - (unsigned char *)v49) >> 3);
  unint64_t v12 = *(uint64_t **)a2;
  uint64_t v13 = (const void *)v48.__r_.__value_.__r.__words[0];
  uint64_t v14 = *(void *)(a2 + 8) - *(void *)a2;
  if (v14)
  {
    unint64_t v15 = v14 >> 3;
    if (v15 <= 1) {
      unint64_t v15 = 1;
    }
    uint64_t v16 = (void *)v48.__r_.__value_.__r.__words[0];
    do
    {
      uint64_t v17 = *v12++;
      *v16++ *= v17;
      --v15;
    }
    while (v15);
  }
  __n128 __p = 0uLL;
  uint64_t v47 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, v13, v48.__r_.__value_.__l.__size_, (uint64_t)(v48.__r_.__value_.__l.__size_ - (void)v13) >> 3);
  MIL::ValueInference::Tensor<float>::Zeros(&__p, a3);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v9)
  {
    for (unint64_t i = 0; i != v9; ++i)
    {
      unint64_t v19 = *a1 + (i << 6);
      unint64_t v20 = *(const void **)(v19 + 8);
      size_t v21 = *(void *)(v19 + 16) - (void)v20;
      if (v21 != v50 - (unsigned char *)v49 || memcmp(v20, v49, v21))
      {
        uint64_t v36 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v36, "All tensors must have the same shape so they can be merged.");
        __cxa_throw(v36, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
      }
      uint64_t v22 = *(void *)(*a1 + (i << 6) + 40) - *(void *)(*a1 + (i << 6) + 32);
      if (v22)
      {
        unint64_t v23 = 0;
        unint64_t v24 = v22 >> 2;
        if (v24 <= 1) {
          uint64_t v25 = 1;
        }
        else {
          uint64_t v25 = v24;
        }
        do
        {
          uint64_t v40 = 0;
          uint64_t v41 = 0;
          uint64_t v42 = 0;
          std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v40, v43, (uint64_t)v44, (v44 - (unsigned char *)v43) >> 3);
          uint64_t v26 = *(void *)(a2 + 8) - *(void *)a2;
          if (v26)
          {
            unint64_t v27 = v26 >> 3;
            uint64_t v28 = (uint64_t *)v49;
            unint64_t v29 = (uint64_t *)v45[0];
            uint64_t v30 = v40;
            if (v27 <= 1) {
              unint64_t v27 = 1;
            }
            do
            {
              uint64_t v32 = *v28++;
              uint64_t v31 = v32;
              uint64_t v33 = *v29++;
              *v30++ += v33 * v31;
              --v27;
            }
            while (v27);
          }
          unint64_t v34 = *a1 + (i << 6);
          int v35 = *(_DWORD *)(*(void *)(v34 + 32)
          *(_DWORD *)(*(void *)(a3 + 32)
          if (v40)
          {
            uint64_t v41 = v40;
            operator delete(v40);
          }
          if (v43)
          {
            uint64_t v44 = v43;
            operator delete(v43);
          }
          ++v23;
        }
        while (v23 != v25);
      }
      if (v45[0])
      {
        v45[1] = v45[0];
        operator delete(v45[0]);
      }
    }
  }
  if (v48.__r_.__value_.__r.__words[0])
  {
    v48.__r_.__value_.__l.__size_ = v48.__r_.__value_.__r.__words[0];
    operator delete(v48.__r_.__value_.__l.__data_);
  }
  if (v49)
  {
    uint64_t v50 = v49;
    operator delete(v49);
  }
}

void sub_20F4BC724(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28)
{
  if (a26 < 0)
  {
    operator delete(__p);
    if ((v29 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a27);
      _Unwind_Resume(a1);
    }
  }
  else if (!v29)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v28);
  goto LABEL_6;
}

uint64_t MIL::ValueInference::Tensor<float>::Reduce@<X0>(void *a1@<X0>, unint64_t **a2@<X1>, int a3@<W2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v106 = a1[1];
  uint64_t v107 = a1 + 1;
  uint64_t v105 = a1[2];
  unint64_t v7 = (v105 - v106) >> 3;
  std::unordered_set<unsigned long long>::unordered_set<std::__wrap_iter<unsigned long long const*>>((uint64_t)v124, *a2, a2[1]);
  for (unint64_t i = v125; i; unint64_t i = (void *)*i)
  {
    if (i[2] >= v7)
    {
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&__p);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&__p, (uint64_t)"axis(", 5);
      std::string::size_type v94 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v94, (uint64_t)") must be smaller than the number of input dimensions(", 54);
      BOOL v95 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v95, (uint64_t)").", 2);
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::stringbuf::str();
      std::logic_error::logic_error(exception, &v120);
      exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
      __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
    }
  }
  __n128 __p = 0;
  unint64_t v122 = 0;
  v123[0] = 0;
  memset(&v120, 0, sizeof(v120));
  uint64_t v117 = 0;
  uint64_t v118 = 0;
  unint64_t v119 = 0;
  if (v105 == v106)
  {
    uint64_t v55 = 0;
    int v54 = 0;
  }
  else
  {
    uint64_t v9 = 0;
    if (v7 <= 1) {
      uint64_t v10 = 1;
    }
    else {
      uint64_t v10 = (v105 - v106) >> 3;
    }
    do
    {
      v114[0] = v9;
      if (std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(v124, (unint64_t *)v114))
      {
        if (a3)
        {
          uint64_t v11 = v122;
          if ((unint64_t)v122 >= v123[0])
          {
            uint64_t v22 = (char *)__p;
            uint64_t v23 = (v122 - (unsigned char *)__p) >> 3;
            unint64_t v24 = v23 + 1;
            if ((unint64_t)(v23 + 1) >> 61) {
              std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v25 = v123[0] - (void)__p;
            if ((uint64_t)(v123[0] - (void)__p) >> 2 > v24) {
              unint64_t v24 = v25 >> 2;
            }
            if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v26 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v26 = v24;
            }
            if (v26)
            {
              unint64_t v27 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)v123, v26);
              uint64_t v22 = (char *)__p;
              uint64_t v11 = v122;
            }
            else
            {
              unint64_t v27 = 0;
            }
            uint64_t v41 = &v27[8 * v23];
            *(void *)uint64_t v41 = 1;
            unint64_t v12 = v41 + 8;
            while (v11 != v22)
            {
              uint64_t v42 = *((void *)v11 - 1);
              v11 -= 8;
              *((void *)v41 - 1) = v42;
              v41 -= 8;
            }
            __n128 __p = v41;
            unint64_t v122 = v12;
            v123[0] = &v27[8 * v26];
            if (v22) {
              operator delete(v22);
            }
          }
          else
          {
            *(void *)unint64_t v122 = 1;
            unint64_t v12 = v11 + 8;
          }
          unint64_t v122 = v12;
        }
        uint64_t v43 = *v107;
        uint64_t v44 = v118;
        if (v118 >= v119)
        {
          uint64_t v46 = (char *)v117;
          uint64_t v47 = (v118 - (unsigned char *)v117) >> 3;
          unint64_t v48 = v47 + 1;
          if ((unint64_t)(v47 + 1) >> 61) {
LABEL_154:
          }
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          uint64_t v49 = v119 - (unsigned char *)v117;
          if ((v119 - (unsigned char *)v117) >> 2 > v48) {
            unint64_t v48 = v49 >> 2;
          }
          if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v50 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v50 = v48;
          }
          if (v50)
          {
            uint64_t v51 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v119, v50);
            uint64_t v46 = (char *)v117;
            uint64_t v44 = v118;
          }
          else
          {
            uint64_t v51 = 0;
          }
          std::string v52 = &v51[8 * v47];
          *(void *)std::string v52 = *(void *)(v43 + 8 * (void)v9);
          uint64_t v45 = v52 + 8;
          while (v44 != v46)
          {
            uint64_t v53 = *((void *)v44 - 1);
            v44 -= 8;
            *((void *)v52 - 1) = v53;
            v52 -= 8;
          }
          uint64_t v117 = v52;
          uint64_t v118 = v45;
          unint64_t v119 = &v51[8 * v50];
          if (v46) {
            operator delete(v46);
          }
        }
        else
        {
          *(void *)uint64_t v118 = *(void *)(v43 + 8 * (void)v9);
          uint64_t v45 = v44 + 8;
        }
        uint64_t v118 = v45;
      }
      else
      {
        uint64_t v13 = *v107;
        uint64_t v14 = v122;
        if ((unint64_t)v122 >= v123[0])
        {
          uint64_t v16 = (char *)__p;
          uint64_t v17 = (v122 - (unsigned char *)__p) >> 3;
          unint64_t v18 = v17 + 1;
          if ((unint64_t)(v17 + 1) >> 61) {
            goto LABEL_154;
          }
          uint64_t v19 = v123[0] - (void)__p;
          if ((uint64_t)(v123[0] - (void)__p) >> 2 > v18) {
            unint64_t v18 = v19 >> 2;
          }
          if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v20 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v20 = v18;
          }
          if (v20)
          {
            size_t v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)v123, v20);
            uint64_t v16 = (char *)__p;
            uint64_t v14 = v122;
          }
          else
          {
            size_t v21 = 0;
          }
          uint64_t v28 = &v21[8 * v17];
          *(void *)uint64_t v28 = *(void *)(v13 + 8 * (void)v9);
          unint64_t v15 = v28 + 8;
          while (v14 != v16)
          {
            uint64_t v29 = *((void *)v14 - 1);
            v14 -= 8;
            *((void *)v28 - 1) = v29;
            v28 -= 8;
          }
          __n128 __p = v28;
          unint64_t v122 = v15;
          v123[0] = &v21[8 * v20];
          if (v16) {
            operator delete(v16);
          }
        }
        else
        {
          *(void *)unint64_t v122 = *(void *)(v13 + 8 * (void)v9);
          unint64_t v15 = v14 + 8;
        }
        unint64_t v122 = v15;
        uint64_t v30 = *v107;
        std::string::size_type size = v120.__r_.__value_.__l.__size_;
        if (v120.__r_.__value_.__l.__size_ >= v120.__r_.__value_.__r.__words[2])
        {
          uint64_t v33 = (void *)v120.__r_.__value_.__r.__words[0];
          uint64_t v34 = (uint64_t)(v120.__r_.__value_.__l.__size_ - v120.__r_.__value_.__r.__words[0]) >> 3;
          unint64_t v35 = v34 + 1;
          if ((unint64_t)(v34 + 1) >> 61) {
            goto LABEL_154;
          }
          int64_t v36 = v120.__r_.__value_.__r.__words[2] - v120.__r_.__value_.__r.__words[0];
          if ((uint64_t)(v120.__r_.__value_.__r.__words[2] - v120.__r_.__value_.__r.__words[0]) >> 2 > v35) {
            unint64_t v35 = v36 >> 2;
          }
          if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v37 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v37 = v35;
          }
          if (v37)
          {
            std::string::size_type v38 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v120.__r_.__value_.__r.__words[2], v37);
            std::string::size_type size = v120.__r_.__value_.__l.__size_;
            uint64_t v33 = (void *)v120.__r_.__value_.__r.__words[0];
          }
          else
          {
            std::string::size_type v38 = 0;
          }
          uint64_t v39 = &v38[8 * v34];
          *(void *)uint64_t v39 = *(void *)(v30 + 8 * (void)v9);
          std::string::size_type v32 = (std::string::size_type)(v39 + 8);
          while ((void *)size != v33)
          {
            uint64_t v40 = *(void *)(size - 8);
            size -= 8;
            *((void *)v39 - 1) = v40;
            v39 -= 8;
          }
          v120.__r_.__value_.__r.__words[0] = (std::string::size_type)v39;
          v120.__r_.__value_.__l.__size_ = v32;
          v120.__r_.__value_.__r.__words[2] = (std::string::size_type)&v38[8 * v37];
          if (v33) {
            operator delete(v33);
          }
        }
        else
        {
          *(void *)v120.__r_.__value_.__l.__size_ = *(void *)(v30 + 8 * (void)v9);
          std::string::size_type v32 = size + 8;
        }
        v120.__r_.__value_.__l.__size_ = v32;
      }
      uint64_t v9 = (char *)v9 + 1;
    }
    while (v9 != (void *)v10);
    int v54 = __p;
    uint64_t v55 = (uint64_t)v122;
  }
  __n128 v115 = 0uLL;
  uint64_t v116 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v115, v54, v55, (v55 - (uint64_t)v54) >> 3);
  MIL::ValueInference::Tensor<float>::Zeros(&v115, a5);
  if (v115.n128_u64[0])
  {
    v115.n128_u64[1] = v115.n128_u64[0];
    operator delete((void *)v115.n128_u64[0]);
  }
  uint64_t v56 = *(void *)(a5 + 40) - *(void *)(a5 + 32);
  if (v56)
  {
    unint64_t v57 = 0;
    unint64_t v58 = v56 >> 2;
    unint64_t v98 = v56 >> 2;
    unint64_t v99 = (uint64_t)(a1[5] - a1[4]) >> 2;
    unint64_t v59 = v99 / (v56 >> 2);
    uint64_t v60 = (uint64_t **)(a5 + 8);
    if (v7 <= 1) {
      uint64_t v61 = 1;
    }
    else {
      uint64_t v61 = (v105 - v106) >> 3;
    }
    if (v58 <= 1) {
      uint64_t v62 = 1;
    }
    else {
      uint64_t v62 = v58;
    }
    uint64_t v97 = v62;
    if (v59 <= 1) {
      unint64_t v59 = 1;
    }
    unint64_t v103 = v59;
    do
    {
      unint64_t v101 = v57;
      LODWORD(v5) &= 0xFFFFFF00;
      if (v98 <= v99)
      {
        unint64_t v63 = 0;
        char v64 = 1;
        do
        {
          uint64_t v109 = 0;
          unint64_t v110 = 0;
          uint64_t v111 = 0;
          if (v105 != v106)
          {
            unint64_t v65 = 0;
            uint64_t v66 = 0;
            uint64_t v67 = 0;
            do
            {
              unint64_t v108 = v65;
              uint64_t v68 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(v124, &v108);
              uint64_t v69 = v110;
              if (v68)
              {
                uint64_t v70 = v112;
                if (v110 >= v111)
                {
                  uint64_t v74 = (char *)v109;
                  uint64_t v75 = (v110 - (unsigned char *)v109) >> 3;
                  unint64_t v76 = v75 + 1;
                  if ((unint64_t)(v75 + 1) >> 61) {
                    goto LABEL_152;
                  }
                  uint64_t v77 = v111 - (unsigned char *)v109;
                  if ((v111 - (unsigned char *)v109) >> 2 > v76) {
                    unint64_t v76 = v77 >> 2;
                  }
                  if ((unint64_t)v77 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v78 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v78 = v76;
                  }
                  if (v78)
                  {
                    uint64_t v79 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v111, v78);
                    uint64_t v74 = (char *)v109;
                    uint64_t v69 = v110;
                  }
                  else
                  {
                    uint64_t v79 = 0;
                  }
                  uint64_t v86 = &v79[8 * v75];
                  *(void *)uint64_t v86 = v70[v66];
                  uint64_t v71 = v86 + 8;
                  while (v69 != v74)
                  {
                    uint64_t v87 = *((void *)v69 - 1);
                    v69 -= 8;
                    *((void *)v86 - 1) = v87;
                    v86 -= 8;
                  }
                  uint64_t v109 = v86;
                  unint64_t v110 = v71;
                  uint64_t v111 = &v79[8 * v78];
                  if (v74) {
                    operator delete(v74);
                  }
                }
                else
                {
                  *(void *)unint64_t v110 = *((void *)v112 + v66);
                  uint64_t v71 = v69 + 8;
                }
                unint64_t v110 = v71;
                ++v66;
              }
              else
              {
                uint64_t v72 = v114[0];
                if (v110 >= v111)
                {
                  uint64_t v80 = (char *)v109;
                  uint64_t v81 = (v110 - (unsigned char *)v109) >> 3;
                  unint64_t v82 = v81 + 1;
                  if ((unint64_t)(v81 + 1) >> 61) {
LABEL_152:
                  }
                    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
                  uint64_t v83 = v111 - (unsigned char *)v109;
                  if ((v111 - (unsigned char *)v109) >> 2 > v82) {
                    unint64_t v82 = v83 >> 2;
                  }
                  if ((unint64_t)v83 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v84 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v84 = v82;
                  }
                  if (v84)
                  {
                    int v85 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v111, v84);
                    uint64_t v80 = (char *)v109;
                    uint64_t v69 = v110;
                  }
                  else
                  {
                    int v85 = 0;
                  }
                  int v88 = &v85[8 * v81];
                  *(void *)int v88 = v72[v67];
                  std::string v73 = v88 + 8;
                  while (v69 != v80)
                  {
                    uint64_t v89 = *((void *)v69 - 1);
                    v69 -= 8;
                    *((void *)v88 - 1) = v89;
                    v88 -= 8;
                  }
                  uint64_t v109 = v88;
                  unint64_t v110 = v73;
                  uint64_t v111 = &v85[8 * v84];
                  if (v80) {
                    operator delete(v80);
                  }
                }
                else
                {
                  *(void *)unint64_t v110 = *((void *)v114[0] + v67);
                  std::string v73 = v69 + 8;
                }
                unint64_t v110 = v73;
                ++v67;
              }
              ++v65;
            }
            while (v65 != v61);
          }
          uint64_t v91 = a1[4];
          if (v64)
          {
            float v5 = *(float *)(v91 + 4 * v90);
          }
          else
          {
            std::function<float ()(float,float)>::operator()(a4, v5, *(float *)(v91 + 4 * v90));
            float v5 = v92;
          }
          uint64_t v60 = (uint64_t **)(a5 + 8);
          if (v109)
          {
            unint64_t v110 = (char *)v109;
            operator delete(v109);
          }
          if (v112)
          {
            long long v113 = v112;
            operator delete(v112);
          }
          char v64 = 0;
          ++v63;
        }
        while (v63 != v103);
      }
      if (v112)
      {
        long long v113 = v112;
        operator delete(v112);
      }
      if (v114[0])
      {
        v114[1] = v114[0];
        operator delete(v114[0]);
      }
      unint64_t v57 = v101 + 1;
    }
    while (v101 + 1 != v97);
  }
  if (v117)
  {
    uint64_t v118 = (char *)v117;
    operator delete(v117);
  }
  if (v120.__r_.__value_.__r.__words[0])
  {
    v120.__r_.__value_.__l.__size_ = v120.__r_.__value_.__r.__words[0];
    operator delete(v120.__r_.__value_.__l.__data_);
  }
  if (__p)
  {
    unint64_t v122 = (char *)__p;
    operator delete(__p);
  }
  return std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table((uint64_t)v124);
}

void sub_20F4BD064(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,uint64_t a36,void *__p,uint64_t a38,int a39,__int16 a40,char a41,char a42,void *a43,uint64_t a44)
{
  if (a42 < 0)
  {
    operator delete(__p);
    if ((v45 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a43);
      std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table(v46 - 144);
      _Unwind_Resume(a1);
    }
  }
  else if (!v45)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v44);
  goto LABEL_6;
}

uint64_t std::function<float ()(float,float)>::operator()(uint64_t a1, float a2, float a3)
{
  float v6 = a2;
  float v5 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, float *, float *))(*(void *)v3 + 48))(v3, &v6, &v5);
}

void MIL::ValueInference::Tensor<float>::Zeros(MIL *a1@<X0>, const MIL::IRTensorValueType *a2@<X1>, uint64_t a3@<X8>)
{
  MIL::GetTensorShapeWithDimensionsAllKnown(a1, a2, (uint64_t)v6);
  *(_OWORD *)__n128 __p = *(_OWORD *)v6;
  uint64_t v5 = v7;
  v6[1] = 0;
  uint64_t v7 = 0;
  v6[0] = 0;
  MIL::ValueInference::Tensor<float>::Zeros((__n128 *)__p, a3);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v6[0])
  {
    v6[1] = v6[0];
    operator delete(v6[0]);
  }
}

void sub_20F4BD254(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  if (__p) {
    operator delete(__p);
  }
  if (a13) {
    operator delete(a13);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<double>::FromIRTensorValue(void *a1@<X0>, uint64_t a2@<X8>)
{
  MIL::IRTensorValue::TryGetDataView<double>(&v12, *a1);
  if (!(_BYTE)v12)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Failed to get data view.");
    uint64_t v7 = (struct type_info *)MEMORY[0x263F8C1F0];
    unint64_t v8 = (void (*)(void *))MEMORY[0x263F8C070];
    goto LABEL_10;
  }
  unint64_t v4 = (MIL *)(*(uint64_t (**)(void))(*(void *)*a1 + 32))();
  if ((*(unsigned int (**)(MIL *))(*(void *)v4 + 88))(v4) == 3)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100]((std::logic_error *)exception, "It is not supported to convert a tensor of string dtype.");
    uint64_t v7 = (struct type_info *)off_26412C1F0;
    unint64_t v8 = (void (*)(void *))MEMORY[0x263F8C080];
LABEL_10:
    __cxa_throw(exception, v7, v8);
  }
  MIL::GetTensorShapeWithDimensionsAllKnown(v4, v5, (uint64_t)&v11);
  uint64_t v10 = 0;
  __n128 __p = 0uLL;
  std::vector<double>::__init_with_size[abi:ne180100]<double const*,double const*>(&__p, v13, (uint64_t)v13 + 8 * v14, v14);
  MIL::ValueInference::Tensor<double>::Tensor(a2, &v11, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v11.n128_u64[0])
  {
    v11.n128_u64[1] = v11.n128_u64[0];
    operator delete((void *)v11.n128_u64[0]);
  }
}

void sub_20F4BD3D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  __cxa_free_exception(v14);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<double>::ToIRTensorValue(uint64_t a1, MIL::IRConstantDimension *a2)
{
  memset(__p, 0, sizeof(__p));
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(__p, *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3);
  MIL::IRTensorValueType::Make(a2, 6, (MIL::MILContext ***)__p);
}

void sub_20F4BD4E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::ValueInference::Tensor<double>::Tensor(uint64_t a1, __n128 *a2, __n128 *a3)
{
  *(_OWORD *)(a1 + 8) = 0u;
  uint64_t v5 = a1 + 8;
  *(void *)a1 = &unk_26C25DC88;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  float v6 = (uint64_t *)a2->n128_u64[0];
  uint64_t v7 = (uint64_t *)a2->n128_u64[1];
  if ((uint64_t *)a2->n128_u64[0] == v7)
  {
    unint64_t v10 = a3->n128_u64[0];
    unint64_t v11 = a3->n128_u64[1];
    uint64_t v8 = a3->n128_u64[0] != v11;
  }
  else
  {
    uint64_t v8 = 1;
    do
    {
      uint64_t v9 = *v6++;
      v8 *= v9;
    }
    while (v6 != v7);
    unint64_t v10 = a3->n128_u64[0];
    unint64_t v11 = a3->n128_u64[1];
  }
  if (v8 != (uint64_t)(v11 - v10) >> 3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "data size and shape dismatch.");
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  std::vector<float>::__move_assign(v5, a2);
  std::vector<float>::__move_assign(a1 + 32, a3);
  *(void *)(a1 + 56) = v8;
  return a1;
}

void sub_20F4BD618(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10)
{
  uint64_t v13 = *v11;
  if (*v11)
  {
    *(void *)(v10 + 40) = v13;
    operator delete(v13);
  }
  unint64_t v14 = *a10;
  if (*a10)
  {
    *(void *)(v10 + 16) = v14;
    operator delete(v14);
  }
  _Unwind_Resume(exception_object);
}

double MIL::ValueInference::Tensor<double>::Tensor(uint64_t a1)
{
  *(void *)a1 = &unk_26C25DC88;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  return result;
}

uint64_t MIL::ValueInference::Tensor<double>::GetDataView(uint64_t a1)
{
  if (*(void *)(a1 + 40) == *(void *)(a1 + 32)) {
    return 0;
  }
  else {
    return *(void *)(a1 + 32);
  }
}

unint64_t MIL::ValueInference::Tensor<double>::operator[](uint64_t a1, uint64_t *a2)
{
}

void MIL::ValueInference::Tensor<double>::ForEach(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v14[4] = *MEMORY[0x263EF8340];
  unint64_t v6 = (uint64_t)(*(void *)(a1 + 40) - *(void *)(a1 + 32)) >> 3;
  __p.n128_u64[0] = 0;
  std::vector<double>::vector(&v13, v6, &__p);
  __n128 __p = 0uLL;
  uint64_t v12 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3);
  uint64_t v8 = *(double **)(a1 + 32);
  uint64_t v7 = *(double **)(a1 + 40);
  uint64_t v9 = (void *)v13.n128_u64[0];
  std::__function::__value_func<double ()(double)>::__value_func[abi:ne180100]((uint64_t)v14, a2);
  while (v8 != v7)
  {
    std::function<double ()(double)>::operator()((uint64_t)v14, *v8);
    *v9++ = v10;
    ++v8;
  }
  std::__function::__value_func<double ()(double)>::~__value_func[abi:ne180100](v14);
  MIL::ValueInference::Tensor<double>::Tensor(a3, &__p, &v13);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v13.n128_u64[0])
  {
    v13.n128_u64[1] = v13.n128_u64[0];
    operator delete((void *)v13.n128_u64[0]);
  }
}

void sub_20F4BD7DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, char a16)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double MIL::ValueInference::Tensor<double>::GetScalarData(void *a1)
{
  if (a1[1] != a1[2] || (uint64_t v1 = a1[4], a1[5] - v1 != 8))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Tensor is not a scalar.");
    __cxa_throw(exception, MEMORY[0x263F8C1E0], MEMORY[0x263F8C048]);
  }
  return *(double *)v1;
}

void sub_20F4BD89C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<double>::Reshape(void *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v6 = (uint64_t *)*a2;
  uint64_t v7 = a2[1];
  uint64_t v8 = 1;
  if (v6 != (uint64_t *)v7)
  {
    uint64_t v9 = v6;
    do
    {
      uint64_t v10 = *v9++;
      v8 *= v10;
    }
    while (v9 != (uint64_t *)v7);
  }
  if (a1[7] != v8)
  {
    __n128 v13 = a2;
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v22);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"Tensor is not able to be reshaped since the number of elements in the newShape [ ", 81);
    uint64_t v14 = *v13;
    uint64_t v15 = v13[1];
    if (*v13 != v15)
    {
      do
      {
        uint64_t v16 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)" ", 1);
        v14 += 8;
      }
      while (v14 != v15);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"] is not the same as the number of elements in the tensor shape [ ", 66);
    uint64_t v17 = a1[1];
    for (uint64_t i = a1[2]; v17 != i; v17 += 8)
    {
      uint64_t v19 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)" ", 1);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"].", 2);
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str();
    std::logic_error::logic_error(exception, &__p);
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  __n128 v22 = 0uLL;
  uint64_t v23 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v22, v6, v7, (v7 - (uint64_t)v6) >> 3);
  unint64_t v11 = (const void *)a1[4];
  uint64_t v12 = a1[5];
  memset(&__p, 0, sizeof(__p));
  std::vector<double>::__init_with_size[abi:ne180100]<std::__wrap_iter<double const*>,std::__wrap_iter<double const*>>(&__p, v11, v12, (v12 - (uint64_t)v11) >> 3);
  MIL::ValueInference::Tensor<double>::Tensor(a3, &v22, (__n128 *)&__p);
  if (__p.__r_.__value_.__r.__words[0])
  {
    __p.__r_.__value_.__l.__size_ = __p.__r_.__value_.__r.__words[0];
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v22.n128_u64[0])
  {
    v22.n128_u64[1] = v22.n128_u64[0];
    operator delete((void *)v22.n128_u64[0]);
  }
}

void sub_20F4BDAB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((v17 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v17)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v16);
  goto LABEL_6;
}

void MIL::ValueInference::Tensor<double>::NonZero(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v3 = *(void *)(a1 + 56);
  if (v3)
  {
    unint64_t v5 = 0;
    unint64_t v6 = (uint64_t **)(a1 + 8);
    do
    {
      if (*(double *)(*(void *)(a1 + 32) + 8 * v5) != 0.0)
      {
        std::vector<std::vector<unsigned long long>>::push_back[abi:ne180100](a2, (uint64_t)__p);
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
        unint64_t v3 = *(void *)(a1 + 56);
      }
      ++v5;
    }
    while (v5 < v3);
  }
}

void sub_20F4BDBC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
  {
    a11 = (uint64_t)__p;
    operator delete(__p);
  }
  std::vector<std::vector<unsigned long long>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<double>::SubTensor(void *a1@<X0>, uint64_t **a2@<X1>, void *a3@<X8>)
{
  unint64_t v5 = ((char *)a2[1] - (char *)*a2) >> 4;
  unint64_t v6 = a1 + 1;
  if (v5 != (uint64_t)(a1[2] - a1[1]) >> 3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "Indices does not match the rank of the tensor.");
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  std::string __p = 0;
  uint64_t v46 = 0;
  uint64_t v47 = 0;
  std::vector<unsigned long long>::reserve(&__p, v5);
  uint64_t v8 = a1[1];
  if (a1[2] != v8)
  {
    unint64_t v9 = 0;
    while (1)
    {
      unint64_t v11 = (*a2)[2 * v9];
      unint64_t v10 = (*a2)[2 * v9 + 1];
      unint64_t v12 = v10 - v11;
      if (v10 < v11) {
        break;
      }
      if (v10 > *(void *)(v8 + 8 * v9))
      {
        uint64_t v33 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(v33, "Indices end is out of the bound for the tensor dimension.");
        uint64_t v34 = (void (*)(void *))MEMORY[0x263F8C068];
        unint64_t v35 = (struct type_info *)off_26412C1E0;
        uint64_t v36 = MEMORY[0x263F8C390] + 16;
LABEL_45:
        v33->__vftable = (std::logic_error_vtbl *)v36;
        __cxa_throw(v33, v35, v34);
      }
      __n128 v13 = v46;
      if (v46 >= v47)
      {
        uint64_t v15 = (char *)__p;
        uint64_t v16 = (v46 - (unsigned char *)__p) >> 3;
        unint64_t v17 = v16 + 1;
        if ((unint64_t)(v16 + 1) >> 61) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v18 = v47 - (unsigned char *)__p;
        if ((v47 - (unsigned char *)__p) >> 2 > v17) {
          unint64_t v17 = v18 >> 2;
        }
        if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v19 = v17;
        }
        if (v19)
        {
          unint64_t v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v47, v19);
          uint64_t v15 = (char *)__p;
          __n128 v13 = v46;
        }
        else
        {
          unint64_t v20 = 0;
        }
        size_t v21 = &v20[8 * v16];
        *(void *)size_t v21 = v12;
        uint64_t v14 = (uint64_t)(v21 + 8);
        while (v13 != v15)
        {
          uint64_t v22 = *((void *)v13 - 1);
          v13 -= 8;
          *((void *)v21 - 1) = v22;
          v21 -= 8;
        }
        std::string __p = v21;
        uint64_t v46 = (char *)v14;
        uint64_t v47 = &v20[8 * v19];
        if (v15) {
          operator delete(v15);
        }
      }
      else
      {
        *(void *)uint64_t v46 = v12;
        uint64_t v14 = (uint64_t)(v13 + 8);
      }
      uint64_t v46 = (char *)v14;
      ++v9;
      uint64_t v8 = a1[1];
      if (v9 >= (a1[2] - v8) >> 3) {
        goto LABEL_25;
      }
    }
    uint64_t v33 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v33, "Indices end must not be smaller than the indices begin.");
    uint64_t v34 = (void (*)(void *))MEMORY[0x263F8C080];
    unint64_t v35 = (struct type_info *)off_26412C1F0;
    uint64_t v36 = MEMORY[0x263F8C3A0] + 16;
    goto LABEL_45;
  }
  uint64_t v14 = (uint64_t)v46;
LABEL_25:
  __n128 v43 = 0uLL;
  uint64_t v44 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v43, __p, v14, (v14 - (uint64_t)__p) >> 3);
  MIL::ValueInference::Tensor<double>::Zeros(&v43, (uint64_t)a3);
  if (v43.n128_u64[0])
  {
    v43.n128_u64[1] = v43.n128_u64[0];
    operator delete((void *)v43.n128_u64[0]);
  }
  uint64_t v23 = a3[5] - a3[4];
  if (v23)
  {
    unint64_t v24 = 0;
    unint64_t v25 = v23 >> 3;
    if (v25 <= 1) {
      uint64_t v26 = 1;
    }
    else {
      uint64_t v26 = v25;
    }
    do
    {
      std::string::size_type v38 = 0;
      uint64_t v39 = 0;
      uint64_t v40 = 0;
      std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v38, v41, (uint64_t)v42, (v42 - (unsigned char *)v41) >> 3);
      uint64_t v27 = a1[2] - a1[1];
      if (v27)
      {
        unint64_t v28 = v27 >> 3;
        uint64_t v29 = *a2;
        uint64_t v30 = v38;
        if (v28 <= 1) {
          unint64_t v28 = 1;
        }
        do
        {
          uint64_t v31 = *v29;
          v29 += 2;
          *v30++ += v31;
          --v28;
        }
        while (v28);
      }
      if (v38)
      {
        uint64_t v39 = v38;
        operator delete(v38);
      }
      if (v41)
      {
        uint64_t v42 = v41;
        operator delete(v41);
      }
      ++v24;
    }
    while (v24 != v26);
  }
  if (__p)
  {
    uint64_t v46 = (char *)__p;
    operator delete(__p);
  }
}

void sub_20F4BDF84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19)
{
  __cxa_free_exception(v19);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<double>::Zeros(__n128 *a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t v4 = (uint64_t *)a1->n128_u64[0];
  unint64_t v5 = 1;
  while (v4 != (uint64_t *)a1->n128_u64[1])
  {
    uint64_t v6 = *v4++;
    v5 *= v6;
  }
  std::vector<double>::vector(&__p, v5);
  MIL::ValueInference::Tensor<double>::Tensor(a2, a1, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
}

void sub_20F4BE098(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<double>::Concat(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *a1;
  uint64_t v7 = 0;
  uint64_t v8 = a1[1] - *a1;
  if (v8)
  {
    unint64_t v9 = v8 >> 6;
    if (v9 <= 1) {
      unint64_t v9 = 1;
    }
    unint64_t v10 = (uint64_t *)(v6 + 8);
    do
    {
      uint64_t v11 = *v10;
      v10 += 8;
      v7 += *(void *)(v11 + 8 * a2);
      --v9;
    }
    while (v9);
  }
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  uint64_t v29 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v29, *(const void **)(v6 + 8), *(void *)(v6 + 16), (uint64_t)(*(void *)(v6 + 16) - *(void *)(v6 + 8)) >> 3);
  unint64_t v12 = v29;
  *((void *)v29 + a2) = v7;
  uint64_t v28 = 0;
  __n128 __p = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, v12, (uint64_t)v30, (v30 - (unsigned char *)v12) >> 3);
  MIL::ValueInference::Tensor<double>::Zeros(&__p, a3);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  uint64_t v13 = *a1;
  uint64_t v14 = a1[1];
  if (v14 != *a1)
  {
    unint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(void *)(v13 + (v15 << 6) + 40) - *(void *)(v13 + (v15 << 6) + 32);
      if (v17)
      {
        unint64_t v18 = 0;
        if ((unint64_t)(v17 >> 3) <= 1) {
          uint64_t v19 = 1;
        }
        else {
          uint64_t v19 = v17 >> 3;
        }
        do
        {
          uint64_t v22 = 0;
          uint64_t v23 = 0;
          uint64_t v24 = 0;
          std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v22, v25, (uint64_t)v26, (v26 - (unsigned char *)v25) >> 3);
          *((void *)v22 + a2) += v16;
          unint64_t v20 = *a1 + (v15 << 6);
          uint64_t v21 = *(void *)(*(void *)(v20 + 32)
          *(void *)(*(void *)(a3 + 32)
          if (v22)
          {
            uint64_t v23 = v22;
            operator delete(v22);
          }
          if (v25)
          {
            uint64_t v26 = v25;
            operator delete(v25);
          }
          ++v18;
        }
        while (v19 != v18);
        uint64_t v13 = *a1;
        uint64_t v14 = a1[1];
      }
      v16 += *(void *)(*(void *)(v13 + (v15++ << 6) + 8) + 8 * a2);
    }
    while (v15 < (v14 - v13) >> 6);
  }
  if (v29)
  {
    uint64_t v30 = v29;
    operator delete(v29);
  }
}

void sub_20F4BE2AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  if (a18) {
    operator delete(a18);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<double>::BlockwiseMerge(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *(uint64_t **)a2;
  uint64_t v7 = *(void *)(a2 + 8) - *(void *)a2;
  if (v7)
  {
    unint64_t v8 = v7 >> 3;
    if (v8 <= 1) {
      unint64_t v8 = 1;
    }
    uint64_t v9 = 1;
    do
    {
      uint64_t v10 = *v6++;
      v9 *= v10;
      --v8;
    }
    while (v8);
  }
  else
  {
    uint64_t v9 = 1;
  }
  uint64_t v11 = *a1;
  if (v9 != (a1[1] - *a1) >> 6)
  {
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v49);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v49, (uint64_t)"The number of tensors (", 23);
    unint64_t v37 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v37, (uint64_t)") is not the same as the number of blocks (", 43);
    std::string::size_type v38 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v38, (uint64_t)").", 2);
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str();
    std::runtime_error::runtime_error(exception, &v48);
    __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
  }
  unint64_t v50 = 0;
  uint64_t v51 = 0;
  uint64_t v49 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v49, *(const void **)(v11 + 8), *(void *)(v11 + 16), (uint64_t)(*(void *)(v11 + 16) - *(void *)(v11 + 8)) >> 3);
  memset(&v48, 0, sizeof(v48));
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v48, v49, (uint64_t)v50, (v50 - (unsigned char *)v49) >> 3);
  unint64_t v12 = *(uint64_t **)a2;
  uint64_t v13 = (const void *)v48.__r_.__value_.__r.__words[0];
  uint64_t v14 = *(void *)(a2 + 8) - *(void *)a2;
  if (v14)
  {
    unint64_t v15 = v14 >> 3;
    if (v15 <= 1) {
      unint64_t v15 = 1;
    }
    uint64_t v16 = (void *)v48.__r_.__value_.__r.__words[0];
    do
    {
      uint64_t v17 = *v12++;
      *v16++ *= v17;
      --v15;
    }
    while (v15);
  }
  __n128 __p = 0uLL;
  uint64_t v47 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, v13, v48.__r_.__value_.__l.__size_, (uint64_t)(v48.__r_.__value_.__l.__size_ - (void)v13) >> 3);
  MIL::ValueInference::Tensor<double>::Zeros(&__p, a3);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v9)
  {
    for (unint64_t i = 0; i != v9; ++i)
    {
      unint64_t v19 = *a1 + (i << 6);
      unint64_t v20 = *(const void **)(v19 + 8);
      size_t v21 = *(void *)(v19 + 16) - (void)v20;
      if (v21 != v50 - (unsigned char *)v49 || memcmp(v20, v49, v21))
      {
        uint64_t v36 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v36, "All tensors must have the same shape so they can be merged.");
        __cxa_throw(v36, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
      }
      uint64_t v22 = *(void *)(*a1 + (i << 6) + 40) - *(void *)(*a1 + (i << 6) + 32);
      if (v22)
      {
        unint64_t v23 = 0;
        unint64_t v24 = v22 >> 3;
        if (v24 <= 1) {
          uint64_t v25 = 1;
        }
        else {
          uint64_t v25 = v24;
        }
        do
        {
          uint64_t v40 = 0;
          uint64_t v41 = 0;
          uint64_t v42 = 0;
          std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v40, v43, (uint64_t)v44, (v44 - (unsigned char *)v43) >> 3);
          uint64_t v26 = *(void *)(a2 + 8) - *(void *)a2;
          if (v26)
          {
            unint64_t v27 = v26 >> 3;
            uint64_t v28 = (uint64_t *)v49;
            uint64_t v29 = (uint64_t *)v45[0];
            uint64_t v30 = v40;
            if (v27 <= 1) {
              unint64_t v27 = 1;
            }
            do
            {
              uint64_t v32 = *v28++;
              uint64_t v31 = v32;
              uint64_t v33 = *v29++;
              *v30++ += v33 * v31;
              --v27;
            }
            while (v27);
          }
          unint64_t v34 = *a1 + (i << 6);
          uint64_t v35 = *(void *)(*(void *)(v34 + 32)
          *(void *)(*(void *)(a3 + 32)
          if (v40)
          {
            uint64_t v41 = v40;
            operator delete(v40);
          }
          if (v43)
          {
            uint64_t v44 = v43;
            operator delete(v43);
          }
          ++v23;
        }
        while (v23 != v25);
      }
      if (v45[0])
      {
        v45[1] = v45[0];
        operator delete(v45[0]);
      }
    }
  }
  if (v48.__r_.__value_.__r.__words[0])
  {
    v48.__r_.__value_.__l.__size_ = v48.__r_.__value_.__r.__words[0];
    operator delete(v48.__r_.__value_.__l.__data_);
  }
  if (v49)
  {
    unint64_t v50 = v49;
    operator delete(v49);
  }
}

void sub_20F4BE6BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28)
{
  if (a26 < 0)
  {
    operator delete(__p);
    if ((v29 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a27);
      _Unwind_Resume(a1);
    }
  }
  else if (!v29)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v28);
  goto LABEL_6;
}

uint64_t MIL::ValueInference::Tensor<double>::Reduce@<X0>(void *a1@<X0>, unint64_t **a2@<X1>, int a3@<W2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v106 = a1[1];
  uint64_t v107 = a1 + 1;
  uint64_t v105 = a1[2];
  unint64_t v7 = (v105 - v106) >> 3;
  std::unordered_set<unsigned long long>::unordered_set<std::__wrap_iter<unsigned long long const*>>((uint64_t)v124, *a2, a2[1]);
  for (unint64_t i = v125; i; unint64_t i = (void *)*i)
  {
    if (i[2] >= v7)
    {
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&__p);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&__p, (uint64_t)"axis(", 5);
      std::string::size_type v94 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v94, (uint64_t)") must be smaller than the number of input dimensions(", 54);
      BOOL v95 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v95, (uint64_t)").", 2);
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::stringbuf::str();
      std::logic_error::logic_error(exception, &v120);
      exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
      __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
    }
  }
  __n128 __p = 0;
  unint64_t v122 = 0;
  v123[0] = 0;
  memset(&v120, 0, sizeof(v120));
  uint64_t v117 = 0;
  uint64_t v118 = 0;
  unint64_t v119 = 0;
  if (v105 == v106)
  {
    uint64_t v55 = 0;
    int v54 = 0;
  }
  else
  {
    uint64_t v9 = 0;
    if (v7 <= 1) {
      uint64_t v10 = 1;
    }
    else {
      uint64_t v10 = (v105 - v106) >> 3;
    }
    do
    {
      v114[0] = v9;
      if (std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(v124, (unint64_t *)v114))
      {
        if (a3)
        {
          uint64_t v11 = v122;
          if ((unint64_t)v122 >= v123[0])
          {
            uint64_t v22 = (char *)__p;
            uint64_t v23 = (v122 - (unsigned char *)__p) >> 3;
            unint64_t v24 = v23 + 1;
            if ((unint64_t)(v23 + 1) >> 61) {
              std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v25 = v123[0] - (void)__p;
            if ((uint64_t)(v123[0] - (void)__p) >> 2 > v24) {
              unint64_t v24 = v25 >> 2;
            }
            if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v26 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v26 = v24;
            }
            if (v26)
            {
              unint64_t v27 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)v123, v26);
              uint64_t v22 = (char *)__p;
              uint64_t v11 = v122;
            }
            else
            {
              unint64_t v27 = 0;
            }
            uint64_t v41 = &v27[8 * v23];
            *(void *)uint64_t v41 = 1;
            unint64_t v12 = v41 + 8;
            while (v11 != v22)
            {
              uint64_t v42 = *((void *)v11 - 1);
              v11 -= 8;
              *((void *)v41 - 1) = v42;
              v41 -= 8;
            }
            __n128 __p = v41;
            unint64_t v122 = v12;
            v123[0] = &v27[8 * v26];
            if (v22) {
              operator delete(v22);
            }
          }
          else
          {
            *(void *)unint64_t v122 = 1;
            unint64_t v12 = v11 + 8;
          }
          unint64_t v122 = v12;
        }
        uint64_t v43 = *v107;
        uint64_t v44 = v118;
        if (v118 >= v119)
        {
          uint64_t v46 = (char *)v117;
          uint64_t v47 = (v118 - (unsigned char *)v117) >> 3;
          unint64_t v48 = v47 + 1;
          if ((unint64_t)(v47 + 1) >> 61) {
LABEL_154:
          }
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          uint64_t v49 = v119 - (unsigned char *)v117;
          if ((v119 - (unsigned char *)v117) >> 2 > v48) {
            unint64_t v48 = v49 >> 2;
          }
          if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v50 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v50 = v48;
          }
          if (v50)
          {
            uint64_t v51 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v119, v50);
            uint64_t v46 = (char *)v117;
            uint64_t v44 = v118;
          }
          else
          {
            uint64_t v51 = 0;
          }
          std::string v52 = &v51[8 * v47];
          *(void *)std::string v52 = *(void *)(v43 + 8 * (void)v9);
          int v45 = v52 + 8;
          while (v44 != v46)
          {
            uint64_t v53 = *((void *)v44 - 1);
            v44 -= 8;
            *((void *)v52 - 1) = v53;
            v52 -= 8;
          }
          uint64_t v117 = v52;
          uint64_t v118 = v45;
          unint64_t v119 = &v51[8 * v50];
          if (v46) {
            operator delete(v46);
          }
        }
        else
        {
          *(void *)uint64_t v118 = *(void *)(v43 + 8 * (void)v9);
          int v45 = v44 + 8;
        }
        uint64_t v118 = v45;
      }
      else
      {
        uint64_t v13 = *v107;
        uint64_t v14 = v122;
        if ((unint64_t)v122 >= v123[0])
        {
          uint64_t v16 = (char *)__p;
          uint64_t v17 = (v122 - (unsigned char *)__p) >> 3;
          unint64_t v18 = v17 + 1;
          if ((unint64_t)(v17 + 1) >> 61) {
            goto LABEL_154;
          }
          uint64_t v19 = v123[0] - (void)__p;
          if ((uint64_t)(v123[0] - (void)__p) >> 2 > v18) {
            unint64_t v18 = v19 >> 2;
          }
          if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v20 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v20 = v18;
          }
          if (v20)
          {
            size_t v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)v123, v20);
            uint64_t v16 = (char *)__p;
            uint64_t v14 = v122;
          }
          else
          {
            size_t v21 = 0;
          }
          uint64_t v28 = &v21[8 * v17];
          *(void *)uint64_t v28 = *(void *)(v13 + 8 * (void)v9);
          unint64_t v15 = v28 + 8;
          while (v14 != v16)
          {
            uint64_t v29 = *((void *)v14 - 1);
            v14 -= 8;
            *((void *)v28 - 1) = v29;
            v28 -= 8;
          }
          __n128 __p = v28;
          unint64_t v122 = v15;
          v123[0] = &v21[8 * v20];
          if (v16) {
            operator delete(v16);
          }
        }
        else
        {
          *(void *)unint64_t v122 = *(void *)(v13 + 8 * (void)v9);
          unint64_t v15 = v14 + 8;
        }
        unint64_t v122 = v15;
        uint64_t v30 = *v107;
        std::string::size_type size = v120.__r_.__value_.__l.__size_;
        if (v120.__r_.__value_.__l.__size_ >= v120.__r_.__value_.__r.__words[2])
        {
          uint64_t v33 = (void *)v120.__r_.__value_.__r.__words[0];
          uint64_t v34 = (uint64_t)(v120.__r_.__value_.__l.__size_ - v120.__r_.__value_.__r.__words[0]) >> 3;
          unint64_t v35 = v34 + 1;
          if ((unint64_t)(v34 + 1) >> 61) {
            goto LABEL_154;
          }
          int64_t v36 = v120.__r_.__value_.__r.__words[2] - v120.__r_.__value_.__r.__words[0];
          if ((uint64_t)(v120.__r_.__value_.__r.__words[2] - v120.__r_.__value_.__r.__words[0]) >> 2 > v35) {
            unint64_t v35 = v36 >> 2;
          }
          if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v37 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v37 = v35;
          }
          if (v37)
          {
            std::string::size_type v38 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v120.__r_.__value_.__r.__words[2], v37);
            std::string::size_type size = v120.__r_.__value_.__l.__size_;
            uint64_t v33 = (void *)v120.__r_.__value_.__r.__words[0];
          }
          else
          {
            std::string::size_type v38 = 0;
          }
          uint64_t v39 = &v38[8 * v34];
          *(void *)uint64_t v39 = *(void *)(v30 + 8 * (void)v9);
          std::string::size_type v32 = (std::string::size_type)(v39 + 8);
          while ((void *)size != v33)
          {
            uint64_t v40 = *(void *)(size - 8);
            size -= 8;
            *((void *)v39 - 1) = v40;
            v39 -= 8;
          }
          v120.__r_.__value_.__r.__words[0] = (std::string::size_type)v39;
          v120.__r_.__value_.__l.__size_ = v32;
          v120.__r_.__value_.__r.__words[2] = (std::string::size_type)&v38[8 * v37];
          if (v33) {
            operator delete(v33);
          }
        }
        else
        {
          *(void *)v120.__r_.__value_.__l.__size_ = *(void *)(v30 + 8 * (void)v9);
          std::string::size_type v32 = size + 8;
        }
        v120.__r_.__value_.__l.__size_ = v32;
      }
      uint64_t v9 = (char *)v9 + 1;
    }
    while (v9 != (void *)v10);
    int v54 = __p;
    uint64_t v55 = (uint64_t)v122;
  }
  __n128 v115 = 0uLL;
  uint64_t v116 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v115, v54, v55, (v55 - (uint64_t)v54) >> 3);
  MIL::ValueInference::Tensor<double>::Zeros(&v115, a5);
  if (v115.n128_u64[0])
  {
    v115.n128_u64[1] = v115.n128_u64[0];
    operator delete((void *)v115.n128_u64[0]);
  }
  uint64_t v56 = *(void *)(a5 + 40) - *(void *)(a5 + 32);
  if (v56)
  {
    unint64_t v57 = 0;
    unint64_t v58 = v56 >> 3;
    unint64_t v98 = v56 >> 3;
    unint64_t v99 = (uint64_t)(a1[5] - a1[4]) >> 3;
    unint64_t v59 = v99 / (v56 >> 3);
    uint64_t v60 = (uint64_t **)(a5 + 8);
    if (v7 <= 1) {
      uint64_t v61 = 1;
    }
    else {
      uint64_t v61 = (v105 - v106) >> 3;
    }
    if (v58 <= 1) {
      uint64_t v62 = 1;
    }
    else {
      uint64_t v62 = v58;
    }
    uint64_t v97 = v62;
    if (v59 <= 1) {
      unint64_t v59 = 1;
    }
    unint64_t v103 = v59;
    do
    {
      unint64_t v101 = v57;
      *(void *)&v5 &= 0xFFFFFFFFFFFFFF00;
      if (v98 <= v99)
      {
        unint64_t v63 = 0;
        char v64 = 1;
        do
        {
          uint64_t v109 = 0;
          unint64_t v110 = 0;
          uint64_t v111 = 0;
          if (v105 != v106)
          {
            unint64_t v65 = 0;
            uint64_t v66 = 0;
            uint64_t v67 = 0;
            do
            {
              unint64_t v108 = v65;
              uint64_t v68 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(v124, &v108);
              uint64_t v69 = v110;
              if (v68)
              {
                uint64_t v70 = v112;
                if (v110 >= v111)
                {
                  uint64_t v74 = (char *)v109;
                  uint64_t v75 = (v110 - (unsigned char *)v109) >> 3;
                  unint64_t v76 = v75 + 1;
                  if ((unint64_t)(v75 + 1) >> 61) {
                    goto LABEL_152;
                  }
                  uint64_t v77 = v111 - (unsigned char *)v109;
                  if ((v111 - (unsigned char *)v109) >> 2 > v76) {
                    unint64_t v76 = v77 >> 2;
                  }
                  if ((unint64_t)v77 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v78 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v78 = v76;
                  }
                  if (v78)
                  {
                    uint64_t v79 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v111, v78);
                    uint64_t v74 = (char *)v109;
                    uint64_t v69 = v110;
                  }
                  else
                  {
                    uint64_t v79 = 0;
                  }
                  uint64_t v86 = &v79[8 * v75];
                  *(void *)uint64_t v86 = v70[v66];
                  uint64_t v71 = v86 + 8;
                  while (v69 != v74)
                  {
                    uint64_t v87 = *((void *)v69 - 1);
                    v69 -= 8;
                    *((void *)v86 - 1) = v87;
                    v86 -= 8;
                  }
                  uint64_t v109 = v86;
                  unint64_t v110 = v71;
                  uint64_t v111 = &v79[8 * v78];
                  if (v74) {
                    operator delete(v74);
                  }
                }
                else
                {
                  *(void *)unint64_t v110 = *((void *)v112 + v66);
                  uint64_t v71 = v69 + 8;
                }
                unint64_t v110 = v71;
                ++v66;
              }
              else
              {
                uint64_t v72 = v114[0];
                if (v110 >= v111)
                {
                  uint64_t v80 = (char *)v109;
                  uint64_t v81 = (v110 - (unsigned char *)v109) >> 3;
                  unint64_t v82 = v81 + 1;
                  if ((unint64_t)(v81 + 1) >> 61) {
LABEL_152:
                  }
                    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
                  uint64_t v83 = v111 - (unsigned char *)v109;
                  if ((v111 - (unsigned char *)v109) >> 2 > v82) {
                    unint64_t v82 = v83 >> 2;
                  }
                  if ((unint64_t)v83 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v84 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v84 = v82;
                  }
                  if (v84)
                  {
                    int v85 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v111, v84);
                    uint64_t v80 = (char *)v109;
                    uint64_t v69 = v110;
                  }
                  else
                  {
                    int v85 = 0;
                  }
                  int v88 = &v85[8 * v81];
                  *(void *)int v88 = v72[v67];
                  std::string v73 = v88 + 8;
                  while (v69 != v80)
                  {
                    uint64_t v89 = *((void *)v69 - 1);
                    v69 -= 8;
                    *((void *)v88 - 1) = v89;
                    v88 -= 8;
                  }
                  uint64_t v109 = v88;
                  unint64_t v110 = v73;
                  uint64_t v111 = &v85[8 * v84];
                  if (v80) {
                    operator delete(v80);
                  }
                }
                else
                {
                  *(void *)unint64_t v110 = *((void *)v114[0] + v67);
                  std::string v73 = v69 + 8;
                }
                unint64_t v110 = v73;
                ++v67;
              }
              ++v65;
            }
            while (v65 != v61);
          }
          uint64_t v91 = a1[4];
          if (v64)
          {
            double v5 = *(double *)(v91 + 8 * v90);
          }
          else
          {
            std::function<double ()(double,double)>::operator()(a4, v5, *(double *)(v91 + 8 * v90));
            double v5 = v92;
          }
          uint64_t v60 = (uint64_t **)(a5 + 8);
          if (v109)
          {
            unint64_t v110 = (char *)v109;
            operator delete(v109);
          }
          if (v112)
          {
            long long v113 = v112;
            operator delete(v112);
          }
          char v64 = 0;
          ++v63;
        }
        while (v63 != v103);
      }
      if (v112)
      {
        long long v113 = v112;
        operator delete(v112);
      }
      if (v114[0])
      {
        v114[1] = v114[0];
        operator delete(v114[0]);
      }
      unint64_t v57 = v101 + 1;
    }
    while (v101 + 1 != v97);
  }
  if (v117)
  {
    uint64_t v118 = (char *)v117;
    operator delete(v117);
  }
  if (v120.__r_.__value_.__r.__words[0])
  {
    v120.__r_.__value_.__l.__size_ = v120.__r_.__value_.__r.__words[0];
    operator delete(v120.__r_.__value_.__l.__data_);
  }
  if (__p)
  {
    unint64_t v122 = (char *)__p;
    operator delete(__p);
  }
  return std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table((uint64_t)v124);
}

void sub_20F4BEFFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,uint64_t a36,void *__p,uint64_t a38,int a39,__int16 a40,char a41,char a42,void *a43,uint64_t a44)
{
  if (a42 < 0)
  {
    operator delete(__p);
    if ((v45 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a43);
      std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table(v46 - 144);
      _Unwind_Resume(a1);
    }
  }
  else if (!v45)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v44);
  goto LABEL_6;
}

uint64_t std::function<double ()(double,double)>::operator()(uint64_t a1, double a2, double a3)
{
  double v5 = a3;
  double v6 = a2;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, double *, double *))(*(void *)v3 + 48))(v3, &v6, &v5);
}

void MIL::ValueInference::Tensor<double>::Zeros(MIL *a1@<X0>, const MIL::IRTensorValueType *a2@<X1>, uint64_t a3@<X8>)
{
  MIL::GetTensorShapeWithDimensionsAllKnown(a1, a2, (uint64_t)v6);
  *(_OWORD *)__n128 __p = *(_OWORD *)v6;
  uint64_t v5 = v7;
  v6[1] = 0;
  uint64_t v7 = 0;
  v6[0] = 0;
  MIL::ValueInference::Tensor<double>::Zeros((__n128 *)__p, a3);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v6[0])
  {
    v6[1] = v6[0];
    operator delete(v6[0]);
  }
}

void sub_20F4BF1E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  if (__p) {
    operator delete(__p);
  }
  if (a13) {
    operator delete(a13);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<unsigned char>::FromIRTensorValue(void *a1@<X0>, uint64_t a2@<X8>)
{
  MIL::IRTensorValue::TryGetDataView<unsigned char>(&v12, *a1);
  if (!(_BYTE)v12)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Failed to get data view.");
    uint64_t v7 = (struct type_info *)MEMORY[0x263F8C1F0];
    unint64_t v8 = (void (*)(void *))MEMORY[0x263F8C070];
    goto LABEL_10;
  }
  unint64_t v4 = (MIL *)(*(uint64_t (**)(void))(*(void *)*a1 + 32))();
  if ((*(unsigned int (**)(MIL *))(*(void *)v4 + 88))(v4) == 3)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100]((std::logic_error *)exception, "It is not supported to convert a tensor of string dtype.");
    uint64_t v7 = (struct type_info *)off_26412C1F0;
    unint64_t v8 = (void (*)(void *))MEMORY[0x263F8C080];
LABEL_10:
    __cxa_throw(exception, v7, v8);
  }
  MIL::GetTensorShapeWithDimensionsAllKnown(v4, v5, (uint64_t)&v11);
  uint64_t v10 = 0;
  __n128 __p = 0uLL;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(&__p, v13, (uint64_t)v13 + v14, v14);
  MIL::ValueInference::Tensor<unsigned char>::Tensor(a2, &v11, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v11.n128_u64[0])
  {
    v11.n128_u64[1] = v11.n128_u64[0];
    operator delete((void *)v11.n128_u64[0]);
  }
}

void sub_20F4BF368(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  __cxa_free_exception(v14);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<unsigned char>::ToIRTensorValue(uint64_t a1, MIL::IRConstantDimension *a2)
{
  memset(__p, 0, sizeof(__p));
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(__p, *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3);
  MIL::IRTensorValueType::Make(a2, 14, (MIL::MILContext ***)__p);
}

void sub_20F4BF46C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::ValueInference::Tensor<unsigned char>::Tensor(uint64_t a1, __n128 *a2, __n128 *a3)
{
  *(_OWORD *)(a1 + 8) = 0u;
  uint64_t v5 = a1 + 8;
  *(void *)a1 = &unk_26C259E78;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  double v6 = (uint64_t *)a2->n128_u64[0];
  uint64_t v7 = (uint64_t *)a2->n128_u64[1];
  if ((uint64_t *)a2->n128_u64[0] == v7)
  {
    unint64_t v10 = a3->n128_u64[0];
    unint64_t v11 = a3->n128_u64[1];
    uint64_t v8 = a3->n128_u64[0] != v11;
  }
  else
  {
    uint64_t v8 = 1;
    do
    {
      uint64_t v9 = *v6++;
      v8 *= v9;
    }
    while (v6 != v7);
    unint64_t v10 = a3->n128_u64[0];
    unint64_t v11 = a3->n128_u64[1];
  }
  if (v8 != v11 - v10)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "data size and shape dismatch.");
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  std::vector<float>::__move_assign(v5, a2);
  std::vector<float>::__move_assign(a1 + 32, a3);
  *(void *)(a1 + 56) = v8;
  return a1;
}

void sub_20F4BF5A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10)
{
  uint64_t v13 = *v11;
  if (*v11)
  {
    *(void *)(v10 + 40) = v13;
    operator delete(v13);
  }
  size_t v14 = *a10;
  if (*a10)
  {
    *(void *)(v10 + 16) = v14;
    operator delete(v14);
  }
  _Unwind_Resume(exception_object);
}

double MIL::ValueInference::Tensor<unsigned char>::Tensor(uint64_t a1)
{
  *(void *)a1 = &unk_26C259E78;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  return result;
}

uint64_t MIL::ValueInference::Tensor<unsigned char>::GetDataView(uint64_t a1)
{
  if (*(void *)(a1 + 40) == *(void *)(a1 + 32)) {
    return 0;
  }
  else {
    return *(void *)(a1 + 32);
  }
}

unint64_t MIL::ValueInference::Tensor<unsigned char>::operator[](uint64_t a1, uint64_t *a2)
{
}

void MIL::ValueInference::Tensor<unsigned char>::ForEach(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v13[4] = *MEMORY[0x263EF8340];
  size_t v6 = *(void *)(a1 + 40) - *(void *)(a1 + 32);
  __p.n128_u8[0] = 0;
  std::vector<unsigned char>::vector(&v12, v6, &__p);
  __n128 __p = 0uLL;
  uint64_t v11 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3);
  uint64_t v8 = *(char **)(a1 + 32);
  uint64_t v7 = *(char **)(a1 + 40);
  uint64_t v9 = (unsigned char *)v12.n128_u64[0];
  std::__function::__value_func<unsigned char ()(unsigned char)>::__value_func[abi:ne180100]((uint64_t)v13, a2);
  while (v8 != v7)
    *v9++ = std::function<unsigned char ()(unsigned char)>::operator()((uint64_t)v13, *v8++);
  std::__function::__value_func<unsigned char ()(unsigned char)>::~__value_func[abi:ne180100](v13);
  MIL::ValueInference::Tensor<unsigned char>::Tensor(a3, &__p, &v12);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v12.n128_u64[0])
  {
    v12.n128_u64[1] = v12.n128_u64[0];
    operator delete((void *)v12.n128_u64[0]);
  }
}

void sub_20F4BF760(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, char a16)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::ValueInference::Tensor<unsigned char>::GetScalarData(void *a1)
{
  if (a1[1] != a1[2] || (uint64_t v1 = (unsigned __int8 *)a1[4], a1[5] - (void)v1 != 1))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Tensor is not a scalar.");
    __cxa_throw(exception, MEMORY[0x263F8C1E0], MEMORY[0x263F8C048]);
  }
  return *v1;
}

void sub_20F4BF820(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<unsigned char>::Reshape(void *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  size_t v6 = (uint64_t *)*a2;
  uint64_t v7 = a2[1];
  uint64_t v8 = 1;
  if (v6 != (uint64_t *)v7)
  {
    uint64_t v9 = v6;
    do
    {
      uint64_t v10 = *v9++;
      v8 *= v10;
    }
    while (v9 != (uint64_t *)v7);
  }
  if (a1[7] != v8)
  {
    uint64_t v13 = a2;
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v22);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"Tensor is not able to be reshaped since the number of elements in the newShape [ ", 81);
    uint64_t v14 = *v13;
    uint64_t v15 = v13[1];
    if (*v13 != v15)
    {
      do
      {
        uint64_t v16 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)" ", 1);
        v14 += 8;
      }
      while (v14 != v15);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"] is not the same as the number of elements in the tensor shape [ ", 66);
    uint64_t v17 = a1[1];
    for (uint64_t i = a1[2]; v17 != i; v17 += 8)
    {
      uint64_t v19 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)" ", 1);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"].", 2);
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str();
    std::logic_error::logic_error(exception, &__p);
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  __n128 v22 = 0uLL;
  uint64_t v23 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v22, v6, v7, (v7 - (uint64_t)v6) >> 3);
  uint64_t v11 = (const void *)a1[4];
  uint64_t v12 = a1[5];
  memset(&__p, 0, sizeof(__p));
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned char const*>,std::__wrap_iter<unsigned char const*>>(&__p, v11, v12, v12 - (void)v11);
  MIL::ValueInference::Tensor<unsigned char>::Tensor(a3, &v22, (__n128 *)&__p);
  if (__p.__r_.__value_.__r.__words[0])
  {
    __p.__r_.__value_.__l.__size_ = __p.__r_.__value_.__r.__words[0];
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v22.n128_u64[0])
  {
    v22.n128_u64[1] = v22.n128_u64[0];
    operator delete((void *)v22.n128_u64[0]);
  }
}

void sub_20F4BFA30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((v17 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v17)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v16);
  goto LABEL_6;
}

void MIL::ValueInference::Tensor<unsigned char>::NonZero(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v3 = *(void *)(a1 + 56);
  if (v3)
  {
    unint64_t v5 = 0;
    size_t v6 = (uint64_t **)(a1 + 8);
    do
    {
      if (*(unsigned char *)(*(void *)(a1 + 32) + v5))
      {
        std::vector<std::vector<unsigned long long>>::push_back[abi:ne180100](a2, (uint64_t)__p);
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
        unint64_t v3 = *(void *)(a1 + 56);
      }
      ++v5;
    }
    while (v5 < v3);
  }
}

void sub_20F4BFB44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
}

void MIL::ValueInference::Tensor<unsigned char>::SubTensor(void *a1@<X0>, uint64_t **a2@<X1>, void *a3@<X8>)
{
  unint64_t v5 = ((char *)a2[1] - (char *)*a2) >> 4;
  size_t v6 = a1 + 1;
  if (v5 != (uint64_t)(a1[2] - a1[1]) >> 3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "Indices does not match the rank of the tensor.");
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  std::string __p = 0;
  int v45 = 0;
  uint64_t v46 = 0;
  std::vector<unsigned long long>::reserve(&__p, v5);
  uint64_t v8 = a1[1];
  if (a1[2] != v8)
  {
    unint64_t v9 = 0;
    while (1)
    {
      unint64_t v11 = (*a2)[2 * v9];
      unint64_t v10 = (*a2)[2 * v9 + 1];
      unint64_t v12 = v10 - v11;
      if (v10 < v11) {
        break;
      }
      if (v10 > *(void *)(v8 + 8 * v9))
      {
        std::string::size_type v32 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(v32, "Indices end is out of the bound for the tensor dimension.");
        uint64_t v33 = (void (*)(void *))MEMORY[0x263F8C068];
        uint64_t v34 = (struct type_info *)off_26412C1E0;
        uint64_t v35 = MEMORY[0x263F8C390] + 16;
LABEL_45:
        v32->__vftable = (std::logic_error_vtbl *)v35;
        __cxa_throw(v32, v34, v33);
      }
      uint64_t v13 = v45;
      if (v45 >= v46)
      {
        uint64_t v15 = (char *)__p;
        uint64_t v16 = (v45 - (unsigned char *)__p) >> 3;
        unint64_t v17 = v16 + 1;
        if ((unint64_t)(v16 + 1) >> 61) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v18 = v46 - (unsigned char *)__p;
        if ((v46 - (unsigned char *)__p) >> 2 > v17) {
          unint64_t v17 = v18 >> 2;
        }
        if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v19 = v17;
        }
        if (v19)
        {
          unint64_t v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v46, v19);
          uint64_t v15 = (char *)__p;
          uint64_t v13 = v45;
        }
        else
        {
          unint64_t v20 = 0;
        }
        size_t v21 = &v20[8 * v16];
        *(void *)size_t v21 = v12;
        uint64_t v14 = (uint64_t)(v21 + 8);
        while (v13 != v15)
        {
          uint64_t v22 = *((void *)v13 - 1);
          v13 -= 8;
          *((void *)v21 - 1) = v22;
          v21 -= 8;
        }
        std::string __p = v21;
        int v45 = (char *)v14;
        uint64_t v46 = &v20[8 * v19];
        if (v15) {
          operator delete(v15);
        }
      }
      else
      {
        *(void *)int v45 = v12;
        uint64_t v14 = (uint64_t)(v13 + 8);
      }
      int v45 = (char *)v14;
      ++v9;
      uint64_t v8 = a1[1];
      if (v9 >= (a1[2] - v8) >> 3) {
        goto LABEL_25;
      }
    }
    std::string::size_type v32 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v32, "Indices end must not be smaller than the indices begin.");
    uint64_t v33 = (void (*)(void *))MEMORY[0x263F8C080];
    uint64_t v34 = (struct type_info *)off_26412C1F0;
    uint64_t v35 = MEMORY[0x263F8C3A0] + 16;
    goto LABEL_45;
  }
  uint64_t v14 = (uint64_t)v45;
LABEL_25:
  __n128 v42 = 0uLL;
  uint64_t v43 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v42, __p, v14, (v14 - (uint64_t)__p) >> 3);
  MIL::ValueInference::Tensor<unsigned char>::Zeros(&v42, (uint64_t)a3);
  if (v42.n128_u64[0])
  {
    v42.n128_u64[1] = v42.n128_u64[0];
    operator delete((void *)v42.n128_u64[0]);
  }
  unint64_t v23 = a3[5] - a3[4];
  if (v23)
  {
    unint64_t v24 = 0;
    if (v23 <= 1) {
      uint64_t v25 = 1;
    }
    else {
      uint64_t v25 = a3[5] - a3[4];
    }
    do
    {
      unint64_t v37 = 0;
      std::string::size_type v38 = 0;
      uint64_t v39 = 0;
      std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v37, v40, (uint64_t)v41, (v41 - (unsigned char *)v40) >> 3);
      uint64_t v26 = a1[2] - a1[1];
      if (v26)
      {
        unint64_t v27 = v26 >> 3;
        uint64_t v28 = *a2;
        uint64_t v29 = v37;
        if (v27 <= 1) {
          unint64_t v27 = 1;
        }
        do
        {
          uint64_t v30 = *v28;
          v28 += 2;
          *v29++ += v30;
          --v27;
        }
        while (v27);
      }
      if (v37)
      {
        std::string::size_type v38 = v37;
        operator delete(v37);
      }
      if (v40)
      {
        uint64_t v41 = v40;
        operator delete(v40);
      }
      ++v24;
    }
    while (v24 != v25);
  }
  if (__p)
  {
    int v45 = (char *)__p;
    operator delete(__p);
  }
}

void sub_20F4BFEF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19)
{
  __cxa_free_exception(v19);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<unsigned char>::Zeros(__n128 *a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t v4 = (uint64_t *)a1->n128_u64[0];
  size_t v5 = 1;
  while (v4 != (uint64_t *)a1->n128_u64[1])
  {
    uint64_t v6 = *v4++;
    v5 *= v6;
  }
  std::vector<unsigned char>::vector(&__p, v5);
  MIL::ValueInference::Tensor<unsigned char>::Tensor(a2, a1, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
}

void sub_20F4C0008(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<unsigned char>::Concat(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *a1;
  uint64_t v7 = 0;
  uint64_t v8 = a1[1] - *a1;
  if (v8)
  {
    unint64_t v9 = v8 >> 6;
    if (v9 <= 1) {
      unint64_t v9 = 1;
    }
    unint64_t v10 = (uint64_t *)(v6 + 8);
    do
    {
      uint64_t v11 = *v10;
      v10 += 8;
      v7 += *(void *)(v11 + 8 * a2);
      --v9;
    }
    while (v9);
  }
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  uint64_t v28 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v28, *(const void **)(v6 + 8), *(void *)(v6 + 16), (uint64_t)(*(void *)(v6 + 16) - *(void *)(v6 + 8)) >> 3);
  unint64_t v12 = v28;
  *((void *)v28 + a2) = v7;
  uint64_t v27 = 0;
  __n128 __p = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, v12, (uint64_t)v29, (v29 - (unsigned char *)v12) >> 3);
  MIL::ValueInference::Tensor<unsigned char>::Zeros(&__p, a3);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  uint64_t v13 = *a1;
  uint64_t v14 = a1[1];
  if (v14 != *a1)
  {
    unint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      unint64_t v17 = *(void *)(v13 + (v15 << 6) + 40) - *(void *)(v13 + (v15 << 6) + 32);
      if (v17)
      {
        unint64_t v18 = 0;
        if (v17 <= 1) {
          uint64_t v19 = 1;
        }
        else {
          uint64_t v19 = *(void *)(v13 + (v15 << 6) + 40) - *(void *)(v13 + (v15 << 6) + 32);
        }
        do
        {
          size_t v21 = 0;
          uint64_t v22 = 0;
          uint64_t v23 = 0;
          std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v21, v24, (uint64_t)v25, (v25 - (unsigned char *)v24) >> 3);
          *((void *)v21 + a2) += v16;
          unint64_t v20 = *a1 + (v15 << 6);
          LOBYTE(v20) = *(unsigned char *)(*(void *)(v20 + 32)
          if (v21)
          {
            uint64_t v22 = v21;
            operator delete(v21);
          }
          if (v24)
          {
            uint64_t v25 = v24;
            operator delete(v24);
          }
          ++v18;
        }
        while (v19 != v18);
        uint64_t v13 = *a1;
        uint64_t v14 = a1[1];
      }
      v16 += *(void *)(*(void *)(v13 + (v15++ << 6) + 8) + 8 * a2);
    }
    while (v15 < (v14 - v13) >> 6);
  }
  if (v28)
  {
    uint64_t v29 = v28;
    operator delete(v28);
  }
}

void sub_20F4C020C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  if (a18) {
    operator delete(a18);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<unsigned char>::BlockwiseMerge(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *(uint64_t **)a2;
  uint64_t v7 = *(void *)(a2 + 8) - *(void *)a2;
  if (v7)
  {
    unint64_t v8 = v7 >> 3;
    if (v8 <= 1) {
      unint64_t v8 = 1;
    }
    uint64_t v9 = 1;
    do
    {
      uint64_t v10 = *v6++;
      v9 *= v10;
      --v8;
    }
    while (v8);
  }
  else
  {
    uint64_t v9 = 1;
  }
  uint64_t v11 = *a1;
  if (v9 != (a1[1] - *a1) >> 6)
  {
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v47);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v47, (uint64_t)"The number of tensors (", 23);
    uint64_t v35 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v35, (uint64_t)") is not the same as the number of blocks (", 43);
    int64_t v36 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v36, (uint64_t)").", 2);
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str();
    std::runtime_error::runtime_error(exception, &v46);
    __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
  }
  unint64_t v48 = 0;
  uint64_t v49 = 0;
  uint64_t v47 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v47, *(const void **)(v11 + 8), *(void *)(v11 + 16), (uint64_t)(*(void *)(v11 + 16) - *(void *)(v11 + 8)) >> 3);
  memset(&v46, 0, sizeof(v46));
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v46, v47, (uint64_t)v48, (v48 - (unsigned char *)v47) >> 3);
  unint64_t v12 = *(uint64_t **)a2;
  uint64_t v13 = (const void *)v46.__r_.__value_.__r.__words[0];
  uint64_t v14 = *(void *)(a2 + 8) - *(void *)a2;
  if (v14)
  {
    unint64_t v15 = v14 >> 3;
    if (v15 <= 1) {
      unint64_t v15 = 1;
    }
    uint64_t v16 = (void *)v46.__r_.__value_.__r.__words[0];
    do
    {
      uint64_t v17 = *v12++;
      *v16++ *= v17;
      --v15;
    }
    while (v15);
  }
  __n128 __p = 0uLL;
  uint64_t v45 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, v13, v46.__r_.__value_.__l.__size_, (uint64_t)(v46.__r_.__value_.__l.__size_ - (void)v13) >> 3);
  MIL::ValueInference::Tensor<unsigned char>::Zeros(&__p, a3);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v9)
  {
    for (unint64_t i = 0; i != v9; ++i)
    {
      unint64_t v19 = *a1 + (i << 6);
      unint64_t v20 = *(const void **)(v19 + 8);
      size_t v21 = *(void *)(v19 + 16) - (void)v20;
      if (v21 != v48 - (unsigned char *)v47 || memcmp(v20, v47, v21))
      {
        uint64_t v34 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v34, "All tensors must have the same shape so they can be merged.");
        __cxa_throw(v34, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
      }
      unint64_t v22 = *(void *)(*a1 + (i << 6) + 40) - *(void *)(*a1 + (i << 6) + 32);
      if (v22)
      {
        unint64_t v23 = 0;
        if (v22 <= 1) {
          uint64_t v24 = 1;
        }
        else {
          uint64_t v24 = *(void *)(*a1 + (i << 6) + 40) - *(void *)(*a1 + (i << 6) + 32);
        }
        do
        {
          std::string::size_type v38 = 0;
          uint64_t v39 = 0;
          uint64_t v40 = 0;
          std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v38, v41, (uint64_t)v42, (v42 - (unsigned char *)v41) >> 3);
          uint64_t v25 = *(void *)(a2 + 8) - *(void *)a2;
          if (v25)
          {
            unint64_t v26 = v25 >> 3;
            uint64_t v27 = (uint64_t *)v47;
            uint64_t v28 = (uint64_t *)v43[0];
            uint64_t v29 = v38;
            if (v26 <= 1) {
              unint64_t v26 = 1;
            }
            do
            {
              uint64_t v31 = *v27++;
              uint64_t v30 = v31;
              uint64_t v32 = *v28++;
              *v29++ += v32 * v30;
              --v26;
            }
            while (v26);
          }
          unint64_t v33 = *a1 + (i << 6);
          LOBYTE(v33) = *(unsigned char *)(*(void *)(v33 + 32)
          if (v38)
          {
            uint64_t v39 = v38;
            operator delete(v38);
          }
          if (v41)
          {
            __n128 v42 = v41;
            operator delete(v41);
          }
          ++v23;
        }
        while (v23 != v24);
      }
      if (v43[0])
      {
        v43[1] = v43[0];
        operator delete(v43[0]);
      }
    }
  }
  if (v46.__r_.__value_.__r.__words[0])
  {
    v46.__r_.__value_.__l.__size_ = v46.__r_.__value_.__r.__words[0];
    operator delete(v46.__r_.__value_.__l.__data_);
  }
  if (v47)
  {
    unint64_t v48 = v47;
    operator delete(v47);
  }
}

void sub_20F4C0610(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28)
{
  if (a26 < 0)
  {
    operator delete(__p);
    if ((v29 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a27);
      _Unwind_Resume(a1);
    }
  }
  else if (!v29)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v28);
  goto LABEL_6;
}

uint64_t MIL::ValueInference::Tensor<unsigned char>::Reduce@<X0>(void *a1@<X0>, unint64_t **a2@<X1>, int a3@<W2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v101 = a1[1];
  uint64_t v102 = a1 + 1;
  uint64_t v100 = a1[2];
  unint64_t v6 = (v100 - v101) >> 3;
  std::unordered_set<unsigned long long>::unordered_set<std::__wrap_iter<unsigned long long const*>>((uint64_t)v120, *a2, a2[1]);
  for (unint64_t i = v121; i; unint64_t i = (void *)*i)
  {
    if (i[2] >= v6)
    {
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&__p);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&__p, (uint64_t)"axis(", 5);
      uint64_t v89 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v89, (uint64_t)") must be smaller than the number of input dimensions(", 54);
      unint64_t v90 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v90, (uint64_t)").", 2);
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::stringbuf::str();
      std::logic_error::logic_error(exception, &v116);
      exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
      __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
    }
  }
  __n128 __p = 0;
  uint64_t v118 = 0;
  v119[0] = 0;
  memset(&v116, 0, sizeof(v116));
  long long v113 = 0;
  long long v114 = 0;
  __n128 v115 = 0;
  if (v100 == v101)
  {
    uint64_t v54 = 0;
    uint64_t v53 = 0;
  }
  else
  {
    unint64_t v8 = 0;
    if (v6 <= 1) {
      uint64_t v9 = 1;
    }
    else {
      uint64_t v9 = (v100 - v101) >> 3;
    }
    do
    {
      v110[0] = v8;
      if (std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(v120, (unint64_t *)v110))
      {
        if (a3)
        {
          uint64_t v10 = v118;
          if ((unint64_t)v118 >= v119[0])
          {
            size_t v21 = (char *)__p;
            uint64_t v22 = (v118 - (unsigned char *)__p) >> 3;
            unint64_t v23 = v22 + 1;
            if ((unint64_t)(v22 + 1) >> 61) {
              std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v24 = v119[0] - (void)__p;
            if ((uint64_t)(v119[0] - (void)__p) >> 2 > v23) {
              unint64_t v23 = v24 >> 2;
            }
            if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v25 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v25 = v23;
            }
            if (v25)
            {
              unint64_t v26 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)v119, v25);
              size_t v21 = (char *)__p;
              uint64_t v10 = v118;
            }
            else
            {
              unint64_t v26 = 0;
            }
            uint64_t v40 = &v26[8 * v22];
            *(void *)uint64_t v40 = 1;
            uint64_t v11 = v40 + 8;
            while (v10 != v21)
            {
              uint64_t v41 = *((void *)v10 - 1);
              v10 -= 8;
              *((void *)v40 - 1) = v41;
              v40 -= 8;
            }
            __n128 __p = v40;
            uint64_t v118 = v11;
            v119[0] = &v26[8 * v25];
            if (v21) {
              operator delete(v21);
            }
          }
          else
          {
            *(void *)uint64_t v118 = 1;
            uint64_t v11 = v10 + 8;
          }
          uint64_t v118 = v11;
        }
        uint64_t v42 = *v102;
        uint64_t v43 = v114;
        if (v114 >= v115)
        {
          uint64_t v45 = (char *)v113;
          uint64_t v46 = (v114 - (unsigned char *)v113) >> 3;
          unint64_t v47 = v46 + 1;
          if ((unint64_t)(v46 + 1) >> 61) {
LABEL_154:
          }
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          uint64_t v48 = v115 - (unsigned char *)v113;
          if ((v115 - (unsigned char *)v113) >> 2 > v47) {
            unint64_t v47 = v48 >> 2;
          }
          if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v49 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v49 = v47;
          }
          if (v49)
          {
            unint64_t v50 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v115, v49);
            uint64_t v45 = (char *)v113;
            uint64_t v43 = v114;
          }
          else
          {
            unint64_t v50 = 0;
          }
          uint64_t v51 = &v50[8 * v46];
          *(void *)uint64_t v51 = *(void *)(v42 + 8 * (void)v8);
          uint64_t v44 = v51 + 8;
          while (v43 != v45)
          {
            uint64_t v52 = *((void *)v43 - 1);
            v43 -= 8;
            *((void *)v51 - 1) = v52;
            v51 -= 8;
          }
          long long v113 = v51;
          long long v114 = v44;
          __n128 v115 = &v50[8 * v49];
          if (v45) {
            operator delete(v45);
          }
        }
        else
        {
          *(void *)long long v114 = *(void *)(v42 + 8 * (void)v8);
          uint64_t v44 = v43 + 8;
        }
        long long v114 = v44;
      }
      else
      {
        uint64_t v12 = *v102;
        uint64_t v13 = v118;
        if ((unint64_t)v118 >= v119[0])
        {
          unint64_t v15 = (char *)__p;
          uint64_t v16 = (v118 - (unsigned char *)__p) >> 3;
          unint64_t v17 = v16 + 1;
          if ((unint64_t)(v16 + 1) >> 61) {
            goto LABEL_154;
          }
          uint64_t v18 = v119[0] - (void)__p;
          if ((uint64_t)(v119[0] - (void)__p) >> 2 > v17) {
            unint64_t v17 = v18 >> 2;
          }
          if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v19 = v17;
          }
          if (v19)
          {
            unint64_t v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)v119, v19);
            unint64_t v15 = (char *)__p;
            uint64_t v13 = v118;
          }
          else
          {
            unint64_t v20 = 0;
          }
          uint64_t v27 = &v20[8 * v16];
          *(void *)uint64_t v27 = *(void *)(v12 + 8 * (void)v8);
          uint64_t v14 = v27 + 8;
          while (v13 != v15)
          {
            uint64_t v28 = *((void *)v13 - 1);
            v13 -= 8;
            *((void *)v27 - 1) = v28;
            v27 -= 8;
          }
          __n128 __p = v27;
          uint64_t v118 = v14;
          v119[0] = &v20[8 * v19];
          if (v15) {
            operator delete(v15);
          }
        }
        else
        {
          *(void *)uint64_t v118 = *(void *)(v12 + 8 * (void)v8);
          uint64_t v14 = v13 + 8;
        }
        uint64_t v118 = v14;
        uint64_t v29 = *v102;
        std::string::size_type size = v116.__r_.__value_.__l.__size_;
        if (v116.__r_.__value_.__l.__size_ >= v116.__r_.__value_.__r.__words[2])
        {
          uint64_t v32 = (void *)v116.__r_.__value_.__r.__words[0];
          uint64_t v33 = (uint64_t)(v116.__r_.__value_.__l.__size_ - v116.__r_.__value_.__r.__words[0]) >> 3;
          unint64_t v34 = v33 + 1;
          if ((unint64_t)(v33 + 1) >> 61) {
            goto LABEL_154;
          }
          int64_t v35 = v116.__r_.__value_.__r.__words[2] - v116.__r_.__value_.__r.__words[0];
          if ((uint64_t)(v116.__r_.__value_.__r.__words[2] - v116.__r_.__value_.__r.__words[0]) >> 2 > v34) {
            unint64_t v34 = v35 >> 2;
          }
          if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v36 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v36 = v34;
          }
          if (v36)
          {
            unint64_t v37 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v116.__r_.__value_.__r.__words[2], v36);
            std::string::size_type size = v116.__r_.__value_.__l.__size_;
            uint64_t v32 = (void *)v116.__r_.__value_.__r.__words[0];
          }
          else
          {
            unint64_t v37 = 0;
          }
          std::string::size_type v38 = &v37[8 * v33];
          *(void *)std::string::size_type v38 = *(void *)(v29 + 8 * (void)v8);
          std::string::size_type v31 = (std::string::size_type)(v38 + 8);
          while ((void *)size != v32)
          {
            uint64_t v39 = *(void *)(size - 8);
            size -= 8;
            *((void *)v38 - 1) = v39;
            v38 -= 8;
          }
          v116.__r_.__value_.__r.__words[0] = (std::string::size_type)v38;
          v116.__r_.__value_.__l.__size_ = v31;
          v116.__r_.__value_.__r.__words[2] = (std::string::size_type)&v37[8 * v36];
          if (v32) {
            operator delete(v32);
          }
        }
        else
        {
          *(void *)v116.__r_.__value_.__l.__size_ = *(void *)(v29 + 8 * (void)v8);
          std::string::size_type v31 = size + 8;
        }
        v116.__r_.__value_.__l.__size_ = v31;
      }
      unint64_t v8 = (char *)v8 + 1;
    }
    while (v8 != (void *)v9);
    uint64_t v53 = __p;
    uint64_t v54 = (uint64_t)v118;
  }
  __n128 v111 = 0uLL;
  uint64_t v112 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v111, v53, v54, (v54 - (uint64_t)v53) >> 3);
  MIL::ValueInference::Tensor<unsigned char>::Zeros(&v111, a5);
  if (v111.n128_u64[0])
  {
    v111.n128_u64[1] = v111.n128_u64[0];
    operator delete((void *)v111.n128_u64[0]);
  }
  unint64_t v94 = *(void *)(a5 + 40) - *(void *)(a5 + 32);
  if (v94)
  {
    unint64_t v55 = 0;
    unint64_t v93 = a1[5] - a1[4];
    unint64_t v56 = v93 / v94;
    unint64_t v57 = (uint64_t **)(a5 + 8);
    if (v6 <= 1) {
      uint64_t v58 = 1;
    }
    else {
      uint64_t v58 = (v100 - v101) >> 3;
    }
    if (v94 <= 1) {
      uint64_t v59 = 1;
    }
    else {
      uint64_t v59 = *(void *)(a5 + 40) - *(void *)(a5 + 32);
    }
    uint64_t v92 = v59;
    if (v56 <= 1) {
      unint64_t v56 = 1;
    }
    unint64_t v98 = v56;
    do
    {
      unint64_t v96 = v55;
      if (v94 <= v93)
      {
        unint64_t v61 = 0;
        char v60 = 0;
        char v62 = 1;
        do
        {
          char v103 = v60;
          uint64_t v105 = 0;
          uint64_t v106 = 0;
          uint64_t v107 = 0;
          if (v100 != v101)
          {
            unint64_t v63 = 0;
            uint64_t v64 = 0;
            uint64_t v65 = 0;
            do
            {
              unint64_t v104 = v63;
              uint64_t v66 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(v120, &v104);
              uint64_t v67 = v106;
              if (v66)
              {
                uint64_t v68 = v108;
                if (v106 >= v107)
                {
                  uint64_t v72 = (char *)v105;
                  uint64_t v73 = (v106 - (unsigned char *)v105) >> 3;
                  unint64_t v74 = v73 + 1;
                  if ((unint64_t)(v73 + 1) >> 61) {
                    goto LABEL_152;
                  }
                  uint64_t v75 = v107 - (unsigned char *)v105;
                  if ((v107 - (unsigned char *)v105) >> 2 > v74) {
                    unint64_t v74 = v75 >> 2;
                  }
                  if ((unint64_t)v75 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v76 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v76 = v74;
                  }
                  if (v76)
                  {
                    uint64_t v77 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v107, v76);
                    uint64_t v72 = (char *)v105;
                    uint64_t v67 = v106;
                  }
                  else
                  {
                    uint64_t v77 = 0;
                  }
                  unint64_t v84 = &v77[8 * v73];
                  *(void *)unint64_t v84 = v68[v64];
                  uint64_t v69 = v84 + 8;
                  while (v67 != v72)
                  {
                    uint64_t v85 = *((void *)v67 - 1);
                    v67 -= 8;
                    *((void *)v84 - 1) = v85;
                    v84 -= 8;
                  }
                  uint64_t v105 = v84;
                  uint64_t v106 = v69;
                  uint64_t v107 = &v77[8 * v76];
                  if (v72) {
                    operator delete(v72);
                  }
                }
                else
                {
                  *(void *)uint64_t v106 = *((void *)v108 + v64);
                  uint64_t v69 = v67 + 8;
                }
                uint64_t v106 = v69;
                ++v64;
              }
              else
              {
                uint64_t v70 = v110[0];
                if (v106 >= v107)
                {
                  unint64_t v78 = (char *)v105;
                  uint64_t v79 = (v106 - (unsigned char *)v105) >> 3;
                  unint64_t v80 = v79 + 1;
                  if ((unint64_t)(v79 + 1) >> 61) {
LABEL_152:
                  }
                    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
                  uint64_t v81 = v107 - (unsigned char *)v105;
                  if ((v107 - (unsigned char *)v105) >> 2 > v80) {
                    unint64_t v80 = v81 >> 2;
                  }
                  if ((unint64_t)v81 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v82 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v82 = v80;
                  }
                  if (v82)
                  {
                    uint64_t v83 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v107, v82);
                    unint64_t v78 = (char *)v105;
                    uint64_t v67 = v106;
                  }
                  else
                  {
                    uint64_t v83 = 0;
                  }
                  uint64_t v86 = &v83[8 * v79];
                  *(void *)uint64_t v86 = v70[v65];
                  uint64_t v71 = v86 + 8;
                  while (v67 != v78)
                  {
                    uint64_t v87 = *((void *)v67 - 1);
                    v67 -= 8;
                    *((void *)v86 - 1) = v87;
                    v86 -= 8;
                  }
                  uint64_t v105 = v86;
                  uint64_t v106 = v71;
                  uint64_t v107 = &v83[8 * v82];
                  if (v78) {
                    operator delete(v78);
                  }
                }
                else
                {
                  *(void *)uint64_t v106 = *((void *)v110[0] + v65);
                  uint64_t v71 = v67 + 8;
                }
                uint64_t v106 = v71;
                ++v65;
              }
              ++v63;
            }
            while (v63 != v58);
          }
          if ((v62 & 1) == 0) {
            char v60 = std::function<unsigned char ()(unsigned char,unsigned char)>::operator()(a4, v103, v60);
          }
          unint64_t v57 = (uint64_t **)(a5 + 8);
          if (v105)
          {
            uint64_t v106 = (char *)v105;
            operator delete(v105);
          }
          if (v108)
          {
            uint64_t v109 = v108;
            operator delete(v108);
          }
          char v62 = 0;
          ++v61;
        }
        while (v61 != v98);
      }
      else
      {
        char v60 = 0;
      }
      if (v108)
      {
        uint64_t v109 = v108;
        operator delete(v108);
      }
      if (v110[0])
      {
        v110[1] = v110[0];
        operator delete(v110[0]);
      }
      unint64_t v55 = v96 + 1;
    }
    while (v96 + 1 != v92);
  }
  if (v113)
  {
    long long v114 = (char *)v113;
    operator delete(v113);
  }
  if (v116.__r_.__value_.__r.__words[0])
  {
    v116.__r_.__value_.__l.__size_ = v116.__r_.__value_.__r.__words[0];
    operator delete(v116.__r_.__value_.__l.__data_);
  }
  if (__p)
  {
    uint64_t v118 = (char *)__p;
    operator delete(__p);
  }
  return std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table((uint64_t)v120);
}

void sub_20F4C0F4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37,uint64_t a38,void *__p,uint64_t a40,int a41,__int16 a42,char a43,char a44,void *a45,uint64_t a46)
{
  if (a44 < 0)
  {
    operator delete(__p);
    if ((v47 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a45);
      std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table(v48 - 128);
      _Unwind_Resume(a1);
    }
  }
  else if (!v47)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v46);
  goto LABEL_6;
}

uint64_t std::function<unsigned char ()(unsigned char,unsigned char)>::operator()(uint64_t a1, char a2, char a3)
{
  char v6 = a2;
  char v5 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, char *, char *))(*(void *)v3 + 48))(v3, &v6, &v5);
}

void MIL::ValueInference::Tensor<unsigned char>::Zeros(MIL *a1@<X0>, const MIL::IRTensorValueType *a2@<X1>, uint64_t a3@<X8>)
{
  MIL::GetTensorShapeWithDimensionsAllKnown(a1, a2, (uint64_t)v6);
  *(_OWORD *)__n128 __p = *(_OWORD *)v6;
  uint64_t v5 = v7;
  v6[1] = 0;
  uint64_t v7 = 0;
  v6[0] = 0;
  MIL::ValueInference::Tensor<unsigned char>::Zeros((__n128 *)__p, a3);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v6[0])
  {
    v6[1] = v6[0];
    operator delete(v6[0]);
  }
}

void sub_20F4C113C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  if (__p) {
    operator delete(__p);
  }
  if (a13) {
    operator delete(a13);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<unsigned short>::FromIRTensorValue(void *a1@<X0>, uint64_t a2@<X8>)
{
  MIL::IRTensorValue::TryGetDataView<unsigned short>(&v12, *a1);
  if (!(_BYTE)v12)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Failed to get data view.");
    uint64_t v7 = (struct type_info *)MEMORY[0x263F8C1F0];
    unint64_t v8 = (void (*)(void *))MEMORY[0x263F8C070];
    goto LABEL_10;
  }
  unint64_t v4 = (MIL *)(*(uint64_t (**)(void))(*(void *)*a1 + 32))();
  if ((*(unsigned int (**)(MIL *))(*(void *)v4 + 88))(v4) == 3)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100]((std::logic_error *)exception, "It is not supported to convert a tensor of string dtype.");
    uint64_t v7 = (struct type_info *)off_26412C1F0;
    unint64_t v8 = (void (*)(void *))MEMORY[0x263F8C080];
LABEL_10:
    __cxa_throw(exception, v7, v8);
  }
  MIL::GetTensorShapeWithDimensionsAllKnown(v4, v5, (uint64_t)&v11);
  uint64_t v10 = 0;
  __n128 __p = 0uLL;
  std::vector<unsigned short>::__init_with_size[abi:ne180100]<unsigned short const*,unsigned short const*>(&__p, v13, (uint64_t)v13 + 2 * v14, v14);
  MIL::ValueInference::Tensor<unsigned short>::Tensor(a2, &v11, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v11.n128_u64[0])
  {
    v11.n128_u64[1] = v11.n128_u64[0];
    operator delete((void *)v11.n128_u64[0]);
  }
}

void sub_20F4C12BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  __cxa_free_exception(v14);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<unsigned short>::ToIRTensorValue(uint64_t a1, MIL::IRConstantDimension *a2)
{
  memset(__p, 0, sizeof(__p));
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(__p, *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3);
  MIL::IRTensorValueType::Make(a2, 15, (MIL::MILContext ***)__p);
}

void sub_20F4C13C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::ValueInference::Tensor<unsigned short>::Tensor(uint64_t a1, __n128 *a2, __n128 *a3)
{
  *(_OWORD *)(a1 + 8) = 0u;
  uint64_t v5 = a1 + 8;
  *(void *)a1 = &unk_26C25DC28;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  char v6 = (uint64_t *)a2->n128_u64[0];
  uint64_t v7 = (uint64_t *)a2->n128_u64[1];
  if ((uint64_t *)a2->n128_u64[0] == v7)
  {
    unint64_t v10 = a3->n128_u64[0];
    unint64_t v11 = a3->n128_u64[1];
    uint64_t v8 = a3->n128_u64[0] != v11;
  }
  else
  {
    uint64_t v8 = 1;
    do
    {
      uint64_t v9 = *v6++;
      v8 *= v9;
    }
    while (v6 != v7);
    unint64_t v10 = a3->n128_u64[0];
    unint64_t v11 = a3->n128_u64[1];
  }
  if (v8 != (uint64_t)(v11 - v10) >> 1)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "data size and shape dismatch.");
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  std::vector<float>::__move_assign(v5, a2);
  std::vector<float>::__move_assign(a1 + 32, a3);
  *(void *)(a1 + 56) = v8;
  return a1;
}

void sub_20F4C14FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10)
{
  uint64_t v13 = *v11;
  if (*v11)
  {
    *(void *)(v10 + 40) = v13;
    operator delete(v13);
  }
  uint64_t v14 = *a10;
  if (*a10)
  {
    *(void *)(v10 + 16) = v14;
    operator delete(v14);
  }
  _Unwind_Resume(exception_object);
}

double MIL::ValueInference::Tensor<unsigned short>::Tensor(uint64_t a1)
{
  *(void *)a1 = &unk_26C25DC28;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  return result;
}

uint64_t MIL::ValueInference::Tensor<unsigned short>::GetDataView(uint64_t a1)
{
  if (*(void *)(a1 + 40) == *(void *)(a1 + 32)) {
    return 0;
  }
  else {
    return *(void *)(a1 + 32);
  }
}

unint64_t MIL::ValueInference::Tensor<unsigned short>::operator[](uint64_t a1, uint64_t *a2)
{
}

void MIL::ValueInference::Tensor<unsigned short>::ForEach(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v13[4] = *MEMORY[0x263EF8340];
  uint64_t v6 = (uint64_t)(*(void *)(a1 + 40) - *(void *)(a1 + 32)) >> 1;
  __p.n128_u16[0] = 0;
  std::vector<unsigned short>::vector(&v12, v6, &__p);
  __n128 __p = 0uLL;
  uint64_t v11 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3);
  uint64_t v8 = *(__int16 **)(a1 + 32);
  uint64_t v7 = *(__int16 **)(a1 + 40);
  uint64_t v9 = (_WORD *)v12.n128_u64[0];
  std::__function::__value_func<unsigned short ()(unsigned short)>::__value_func[abi:ne180100]((uint64_t)v13, a2);
  while (v8 != v7)
    *v9++ = std::function<unsigned short ()(unsigned short)>::operator()((uint64_t)v13, *v8++);
  std::__function::__value_func<unsigned short ()(unsigned short)>::~__value_func[abi:ne180100](v13);
  MIL::ValueInference::Tensor<unsigned short>::Tensor(a3, &__p, &v12);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v12.n128_u64[0])
  {
    v12.n128_u64[1] = v12.n128_u64[0];
    operator delete((void *)v12.n128_u64[0]);
  }
}

void sub_20F4C16C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, char a16)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::ValueInference::Tensor<unsigned short>::GetScalarData(void *a1)
{
  if (a1[1] != a1[2] || (uint64_t v1 = (unsigned __int16 *)a1[4], a1[5] - (void)v1 != 2))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Tensor is not a scalar.");
    __cxa_throw(exception, MEMORY[0x263F8C1E0], MEMORY[0x263F8C048]);
  }
  return *v1;
}

void sub_20F4C1780(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<unsigned short>::Reshape(void *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = (uint64_t *)*a2;
  uint64_t v7 = a2[1];
  uint64_t v8 = 1;
  if (v6 != (uint64_t *)v7)
  {
    uint64_t v9 = v6;
    do
    {
      uint64_t v10 = *v9++;
      v8 *= v10;
    }
    while (v9 != (uint64_t *)v7);
  }
  if (a1[7] != v8)
  {
    uint64_t v13 = a2;
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v22);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"Tensor is not able to be reshaped since the number of elements in the newShape [ ", 81);
    uint64_t v14 = *v13;
    uint64_t v15 = v13[1];
    if (*v13 != v15)
    {
      do
      {
        uint64_t v16 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)" ", 1);
        v14 += 8;
      }
      while (v14 != v15);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"] is not the same as the number of elements in the tensor shape [ ", 66);
    uint64_t v17 = a1[1];
    for (uint64_t i = a1[2]; v17 != i; v17 += 8)
    {
      unint64_t v19 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)" ", 1);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"].", 2);
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str();
    std::logic_error::logic_error(exception, &__p);
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  __n128 v22 = 0uLL;
  uint64_t v23 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v22, v6, v7, (v7 - (uint64_t)v6) >> 3);
  uint64_t v11 = (const void *)a1[4];
  uint64_t v12 = a1[5];
  memset(&__p, 0, sizeof(__p));
  std::vector<unsigned short>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>(&__p, v11, v12, (v12 - (uint64_t)v11) >> 1);
  MIL::ValueInference::Tensor<unsigned short>::Tensor(a3, &v22, (__n128 *)&__p);
  if (__p.__r_.__value_.__r.__words[0])
  {
    __p.__r_.__value_.__l.__size_ = __p.__r_.__value_.__r.__words[0];
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v22.n128_u64[0])
  {
    v22.n128_u64[1] = v22.n128_u64[0];
    operator delete((void *)v22.n128_u64[0]);
  }
}

void sub_20F4C1994(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((v17 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v17)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v16);
  goto LABEL_6;
}

void MIL::ValueInference::Tensor<unsigned short>::NonZero(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v3 = *(void *)(a1 + 56);
  if (v3)
  {
    unint64_t v5 = 0;
    uint64_t v6 = (uint64_t **)(a1 + 8);
    do
    {
      if (*(_WORD *)(*(void *)(a1 + 32) + 2 * v5))
      {
        std::vector<std::vector<unsigned long long>>::push_back[abi:ne180100](a2, (uint64_t)__p);
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
        unint64_t v3 = *(void *)(a1 + 56);
      }
      ++v5;
    }
    while (v5 < v3);
  }
}

void sub_20F4C1AA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
}

void MIL::ValueInference::Tensor<unsigned short>::SubTensor(void *a1@<X0>, uint64_t **a2@<X1>, void *a3@<X8>)
{
  unint64_t v5 = ((char *)a2[1] - (char *)*a2) >> 4;
  uint64_t v6 = a1 + 1;
  if (v5 != (uint64_t)(a1[2] - a1[1]) >> 3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "Indices does not match the rank of the tensor.");
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  std::string __p = 0;
  uint64_t v46 = 0;
  int v47 = 0;
  std::vector<unsigned long long>::reserve(&__p, v5);
  uint64_t v8 = a1[1];
  if (a1[2] != v8)
  {
    unint64_t v9 = 0;
    while (1)
    {
      unint64_t v11 = (*a2)[2 * v9];
      unint64_t v10 = (*a2)[2 * v9 + 1];
      unint64_t v12 = v10 - v11;
      if (v10 < v11) {
        break;
      }
      if (v10 > *(void *)(v8 + 8 * v9))
      {
        uint64_t v33 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(v33, "Indices end is out of the bound for the tensor dimension.");
        unint64_t v34 = (void (*)(void *))MEMORY[0x263F8C068];
        int64_t v35 = (struct type_info *)off_26412C1E0;
        uint64_t v36 = MEMORY[0x263F8C390] + 16;
LABEL_45:
        v33->__vftable = (std::logic_error_vtbl *)v36;
        __cxa_throw(v33, v35, v34);
      }
      uint64_t v13 = v46;
      if (v46 >= v47)
      {
        uint64_t v15 = (char *)__p;
        uint64_t v16 = (v46 - (unsigned char *)__p) >> 3;
        unint64_t v17 = v16 + 1;
        if ((unint64_t)(v16 + 1) >> 61) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v18 = v47 - (unsigned char *)__p;
        if ((v47 - (unsigned char *)__p) >> 2 > v17) {
          unint64_t v17 = v18 >> 2;
        }
        if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v19 = v17;
        }
        if (v19)
        {
          unint64_t v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v47, v19);
          uint64_t v15 = (char *)__p;
          uint64_t v13 = v46;
        }
        else
        {
          unint64_t v20 = 0;
        }
        size_t v21 = &v20[8 * v16];
        *(void *)size_t v21 = v12;
        uint64_t v14 = (uint64_t)(v21 + 8);
        while (v13 != v15)
        {
          uint64_t v22 = *((void *)v13 - 1);
          v13 -= 8;
          *((void *)v21 - 1) = v22;
          v21 -= 8;
        }
        std::string __p = v21;
        uint64_t v46 = (char *)v14;
        int v47 = &v20[8 * v19];
        if (v15) {
          operator delete(v15);
        }
      }
      else
      {
        *(void *)uint64_t v46 = v12;
        uint64_t v14 = (uint64_t)(v13 + 8);
      }
      uint64_t v46 = (char *)v14;
      ++v9;
      uint64_t v8 = a1[1];
      if (v9 >= (a1[2] - v8) >> 3) {
        goto LABEL_25;
      }
    }
    uint64_t v33 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v33, "Indices end must not be smaller than the indices begin.");
    unint64_t v34 = (void (*)(void *))MEMORY[0x263F8C080];
    int64_t v35 = (struct type_info *)off_26412C1F0;
    uint64_t v36 = MEMORY[0x263F8C3A0] + 16;
    goto LABEL_45;
  }
  uint64_t v14 = (uint64_t)v46;
LABEL_25:
  __n128 v43 = 0uLL;
  uint64_t v44 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v43, __p, v14, (v14 - (uint64_t)__p) >> 3);
  MIL::ValueInference::Tensor<unsigned short>::Zeros(&v43, (uint64_t)a3);
  if (v43.n128_u64[0])
  {
    v43.n128_u64[1] = v43.n128_u64[0];
    operator delete((void *)v43.n128_u64[0]);
  }
  uint64_t v23 = a3[5] - a3[4];
  if (v23)
  {
    unint64_t v24 = 0;
    unint64_t v25 = v23 >> 1;
    if (v25 <= 1) {
      uint64_t v26 = 1;
    }
    else {
      uint64_t v26 = v25;
    }
    do
    {
      std::string::size_type v38 = 0;
      uint64_t v39 = 0;
      uint64_t v40 = 0;
      std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v38, v41, (uint64_t)v42, (v42 - (unsigned char *)v41) >> 3);
      uint64_t v27 = a1[2] - a1[1];
      if (v27)
      {
        unint64_t v28 = v27 >> 3;
        uint64_t v29 = *a2;
        uint64_t v30 = v38;
        if (v28 <= 1) {
          unint64_t v28 = 1;
        }
        do
        {
          uint64_t v31 = *v29;
          v29 += 2;
          *v30++ += v31;
          --v28;
        }
        while (v28);
      }
      if (v38)
      {
        uint64_t v39 = v38;
        operator delete(v38);
      }
      if (v41)
      {
        uint64_t v42 = v41;
        operator delete(v41);
      }
      ++v24;
    }
    while (v24 != v26);
  }
  if (__p)
  {
    uint64_t v46 = (char *)__p;
    operator delete(__p);
  }
}

void sub_20F4C1E5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19)
{
  __cxa_free_exception(v19);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<unsigned short>::Zeros(__n128 *a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t v4 = (uint64_t *)a1->n128_u64[0];
  uint64_t v5 = 1;
  while (v4 != (uint64_t *)a1->n128_u64[1])
  {
    uint64_t v6 = *v4++;
    v5 *= v6;
  }
  std::vector<unsigned short>::vector(&__p, v5);
  MIL::ValueInference::Tensor<unsigned short>::Tensor(a2, a1, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
}

void sub_20F4C1F70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<unsigned short>::Concat(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *a1;
  uint64_t v7 = 0;
  uint64_t v8 = a1[1] - *a1;
  if (v8)
  {
    unint64_t v9 = v8 >> 6;
    if (v9 <= 1) {
      unint64_t v9 = 1;
    }
    unint64_t v10 = (uint64_t *)(v6 + 8);
    do
    {
      uint64_t v11 = *v10;
      v10 += 8;
      v7 += *(void *)(v11 + 8 * a2);
      --v9;
    }
    while (v9);
  }
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  unint64_t v28 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v28, *(const void **)(v6 + 8), *(void *)(v6 + 16), (uint64_t)(*(void *)(v6 + 16) - *(void *)(v6 + 8)) >> 3);
  unint64_t v12 = v28;
  *((void *)v28 + a2) = v7;
  uint64_t v27 = 0;
  __n128 __p = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, v12, (uint64_t)v29, (v29 - (unsigned char *)v12) >> 3);
  MIL::ValueInference::Tensor<unsigned short>::Zeros(&__p, a3);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  uint64_t v13 = *a1;
  uint64_t v14 = a1[1];
  if (v14 != *a1)
  {
    unint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(void *)(v13 + (v15 << 6) + 40) - *(void *)(v13 + (v15 << 6) + 32);
      if (v17)
      {
        unint64_t v18 = 0;
        if ((unint64_t)(v17 >> 1) <= 1) {
          uint64_t v19 = 1;
        }
        else {
          uint64_t v19 = v17 >> 1;
        }
        do
        {
          size_t v21 = 0;
          uint64_t v22 = 0;
          uint64_t v23 = 0;
          std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v21, v24, (uint64_t)v25, (v25 - (unsigned char *)v24) >> 3);
          *((void *)v21 + a2) += v16;
          unint64_t v20 = *a1 + (v15 << 6);
          LOWORD(v20) = *(_WORD *)(*(void *)(v20 + 32)
          *(_WORD *)(*(void *)(a3 + 32)
          if (v21)
          {
            uint64_t v22 = v21;
            operator delete(v21);
          }
          if (v24)
          {
            unint64_t v25 = v24;
            operator delete(v24);
          }
          ++v18;
        }
        while (v19 != v18);
        uint64_t v13 = *a1;
        uint64_t v14 = a1[1];
      }
      v16 += *(void *)(*(void *)(v13 + (v15++ << 6) + 8) + 8 * a2);
    }
    while (v15 < (v14 - v13) >> 6);
  }
  if (v28)
  {
    uint64_t v29 = v28;
    operator delete(v28);
  }
}

void sub_20F4C2178(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  if (a18) {
    operator delete(a18);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<unsigned short>::BlockwiseMerge(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *(uint64_t **)a2;
  uint64_t v7 = *(void *)(a2 + 8) - *(void *)a2;
  if (v7)
  {
    unint64_t v8 = v7 >> 3;
    if (v8 <= 1) {
      unint64_t v8 = 1;
    }
    uint64_t v9 = 1;
    do
    {
      uint64_t v10 = *v6++;
      v9 *= v10;
      --v8;
    }
    while (v8);
  }
  else
  {
    uint64_t v9 = 1;
  }
  uint64_t v11 = *a1;
  if (v9 != (a1[1] - *a1) >> 6)
  {
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v48);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v48, (uint64_t)"The number of tensors (", 23);
    uint64_t v36 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v36, (uint64_t)") is not the same as the number of blocks (", 43);
    unint64_t v37 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v37, (uint64_t)").", 2);
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str();
    std::runtime_error::runtime_error(exception, &v47);
    __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
  }
  unint64_t v49 = 0;
  uint64_t v50 = 0;
  uint64_t v48 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v48, *(const void **)(v11 + 8), *(void *)(v11 + 16), (uint64_t)(*(void *)(v11 + 16) - *(void *)(v11 + 8)) >> 3);
  memset(&v47, 0, sizeof(v47));
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v47, v48, (uint64_t)v49, (v49 - (unsigned char *)v48) >> 3);
  unint64_t v12 = *(uint64_t **)a2;
  uint64_t v13 = (const void *)v47.__r_.__value_.__r.__words[0];
  uint64_t v14 = *(void *)(a2 + 8) - *(void *)a2;
  if (v14)
  {
    unint64_t v15 = v14 >> 3;
    if (v15 <= 1) {
      unint64_t v15 = 1;
    }
    uint64_t v16 = (void *)v47.__r_.__value_.__r.__words[0];
    do
    {
      uint64_t v17 = *v12++;
      *v16++ *= v17;
      --v15;
    }
    while (v15);
  }
  __n128 __p = 0uLL;
  uint64_t v46 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, v13, v47.__r_.__value_.__l.__size_, (uint64_t)(v47.__r_.__value_.__l.__size_ - (void)v13) >> 3);
  MIL::ValueInference::Tensor<unsigned short>::Zeros(&__p, a3);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v9)
  {
    for (unint64_t i = 0; i != v9; ++i)
    {
      unint64_t v19 = *a1 + (i << 6);
      unint64_t v20 = *(const void **)(v19 + 8);
      size_t v21 = *(void *)(v19 + 16) - (void)v20;
      if (v21 != v49 - (unsigned char *)v48 || memcmp(v20, v48, v21))
      {
        int64_t v35 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v35, "All tensors must have the same shape so they can be merged.");
        __cxa_throw(v35, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
      }
      uint64_t v22 = *(void *)(*a1 + (i << 6) + 40) - *(void *)(*a1 + (i << 6) + 32);
      if (v22)
      {
        unint64_t v23 = 0;
        unint64_t v24 = v22 >> 1;
        if (v24 <= 1) {
          uint64_t v25 = 1;
        }
        else {
          uint64_t v25 = v24;
        }
        do
        {
          uint64_t v39 = 0;
          uint64_t v40 = 0;
          uint64_t v41 = 0;
          std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v39, v42, (uint64_t)v43, (v43 - (unsigned char *)v42) >> 3);
          uint64_t v26 = *(void *)(a2 + 8) - *(void *)a2;
          if (v26)
          {
            unint64_t v27 = v26 >> 3;
            unint64_t v28 = (uint64_t *)v48;
            uint64_t v29 = (uint64_t *)v44[0];
            uint64_t v30 = v39;
            if (v27 <= 1) {
              unint64_t v27 = 1;
            }
            do
            {
              uint64_t v32 = *v28++;
              uint64_t v31 = v32;
              uint64_t v33 = *v29++;
              *v30++ += v33 * v31;
              --v27;
            }
            while (v27);
          }
          unint64_t v34 = *a1 + (i << 6);
          LOWORD(v34) = *(_WORD *)(*(void *)(v34 + 32)
          *(_WORD *)(*(void *)(a3 + 32)
          if (v39)
          {
            uint64_t v40 = v39;
            operator delete(v39);
          }
          if (v42)
          {
            __n128 v43 = v42;
            operator delete(v42);
          }
          ++v23;
        }
        while (v23 != v25);
      }
      if (v44[0])
      {
        v44[1] = v44[0];
        operator delete(v44[0]);
      }
    }
  }
  if (v47.__r_.__value_.__r.__words[0])
  {
    v47.__r_.__value_.__l.__size_ = v47.__r_.__value_.__r.__words[0];
    operator delete(v47.__r_.__value_.__l.__data_);
  }
  if (v48)
  {
    unint64_t v49 = v48;
    operator delete(v48);
  }
}

void sub_20F4C2580(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28)
{
  if (a26 < 0)
  {
    operator delete(__p);
    if ((v29 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a27);
      _Unwind_Resume(a1);
    }
  }
  else if (!v29)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v28);
  goto LABEL_6;
}

uint64_t MIL::ValueInference::Tensor<unsigned short>::Reduce@<X0>(void *a1@<X0>, unint64_t **a2@<X1>, int a3@<W2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v103 = a1[1];
  unint64_t v104 = a1 + 1;
  uint64_t v102 = a1[2];
  unint64_t v7 = (v102 - v103) >> 3;
  std::unordered_set<unsigned long long>::unordered_set<std::__wrap_iter<unsigned long long const*>>((uint64_t)v122, *a2, a2[1]);
  for (unint64_t i = v123; i; unint64_t i = (void *)*i)
  {
    if (i[2] >= v7)
    {
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&__p);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&__p, (uint64_t)"axis(", 5);
      uint64_t v91 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v91, (uint64_t)") must be smaller than the number of input dimensions(", 54);
      uint64_t v92 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v92, (uint64_t)").", 2);
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::stringbuf::str();
      std::logic_error::logic_error(exception, &v118);
      exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
      __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
    }
  }
  __n128 __p = 0;
  std::string v120 = 0;
  v121[0] = 0;
  memset(&v118, 0, sizeof(v118));
  __n128 v115 = 0;
  std::string v116 = 0;
  uint64_t v117 = 0;
  if (v102 == v103)
  {
    uint64_t v55 = 0;
    uint64_t v54 = 0;
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t v5 = &v117;
    if (v7 <= 1) {
      uint64_t v10 = 1;
    }
    else {
      uint64_t v10 = (v102 - v103) >> 3;
    }
    do
    {
      v112[0] = v9;
      if (std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(v122, (unint64_t *)v112))
      {
        if (a3)
        {
          uint64_t v11 = v120;
          if ((unint64_t)v120 >= v121[0])
          {
            uint64_t v22 = (char *)__p;
            uint64_t v23 = (v120 - (unsigned char *)__p) >> 3;
            unint64_t v24 = v23 + 1;
            if ((unint64_t)(v23 + 1) >> 61) {
              std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v25 = v121[0] - (void)__p;
            if ((uint64_t)(v121[0] - (void)__p) >> 2 > v24) {
              unint64_t v24 = v25 >> 2;
            }
            if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v26 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v26 = v24;
            }
            if (v26)
            {
              unint64_t v27 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)v121, v26);
              uint64_t v22 = (char *)__p;
              uint64_t v11 = v120;
            }
            else
            {
              unint64_t v27 = 0;
            }
            uint64_t v41 = &v27[8 * v23];
            *(void *)uint64_t v41 = 1;
            unint64_t v12 = v41 + 8;
            while (v11 != v22)
            {
              uint64_t v42 = *((void *)v11 - 1);
              v11 -= 8;
              *((void *)v41 - 1) = v42;
              v41 -= 8;
            }
            __n128 __p = v41;
            std::string v120 = v12;
            v121[0] = &v27[8 * v26];
            if (v22) {
              operator delete(v22);
            }
          }
          else
          {
            *(void *)std::string v120 = 1;
            unint64_t v12 = v11 + 8;
          }
          std::string v120 = v12;
        }
        uint64_t v43 = *v104;
        uint64_t v44 = v116;
        if (v116 >= v117)
        {
          uint64_t v46 = (char *)v115;
          uint64_t v47 = (v116 - (unsigned char *)v115) >> 3;
          unint64_t v48 = v47 + 1;
          if ((unint64_t)(v47 + 1) >> 61) {
LABEL_153:
          }
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          uint64_t v49 = v117 - (unsigned char *)v115;
          if ((v117 - (unsigned char *)v115) >> 2 > v48) {
            unint64_t v48 = v49 >> 2;
          }
          if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v50 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v50 = v48;
          }
          if (v50)
          {
            uint64_t v51 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v117, v50);
            uint64_t v46 = (char *)v115;
            uint64_t v44 = v116;
          }
          else
          {
            uint64_t v51 = 0;
          }
          uint64_t v52 = &v51[8 * v47];
          *(void *)uint64_t v52 = *(void *)(v43 + 8 * (void)v9);
          uint64_t v45 = v52 + 8;
          while (v44 != v46)
          {
            uint64_t v53 = *((void *)v44 - 1);
            v44 -= 8;
            *((void *)v52 - 1) = v53;
            v52 -= 8;
          }
          __n128 v115 = v52;
          std::string v116 = v45;
          uint64_t v117 = &v51[8 * v50];
          if (v46) {
            operator delete(v46);
          }
        }
        else
        {
          *(void *)std::string v116 = *(void *)(v43 + 8 * (void)v9);
          uint64_t v45 = v44 + 8;
        }
        std::string v116 = v45;
      }
      else
      {
        uint64_t v13 = *v104;
        uint64_t v14 = v120;
        if ((unint64_t)v120 >= v121[0])
        {
          uint64_t v16 = (char *)__p;
          uint64_t v17 = (v120 - (unsigned char *)__p) >> 3;
          unint64_t v18 = v17 + 1;
          if ((unint64_t)(v17 + 1) >> 61) {
            goto LABEL_153;
          }
          uint64_t v19 = v121[0] - (void)__p;
          if ((uint64_t)(v121[0] - (void)__p) >> 2 > v18) {
            unint64_t v18 = v19 >> 2;
          }
          if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v20 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v20 = v18;
          }
          if (v20)
          {
            size_t v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)v121, v20);
            uint64_t v16 = (char *)__p;
            uint64_t v14 = v120;
          }
          else
          {
            size_t v21 = 0;
          }
          unint64_t v28 = &v21[8 * v17];
          *(void *)unint64_t v28 = *(void *)(v13 + 8 * (void)v9);
          unint64_t v15 = v28 + 8;
          while (v14 != v16)
          {
            uint64_t v29 = *((void *)v14 - 1);
            v14 -= 8;
            *((void *)v28 - 1) = v29;
            v28 -= 8;
          }
          __n128 __p = v28;
          std::string v120 = v15;
          v121[0] = &v21[8 * v20];
          if (v16) {
            operator delete(v16);
          }
        }
        else
        {
          *(void *)std::string v120 = *(void *)(v13 + 8 * (void)v9);
          unint64_t v15 = v14 + 8;
        }
        std::string v120 = v15;
        uint64_t v30 = *v104;
        std::string::size_type size = v118.__r_.__value_.__l.__size_;
        if (v118.__r_.__value_.__l.__size_ >= v118.__r_.__value_.__r.__words[2])
        {
          uint64_t v33 = (void *)v118.__r_.__value_.__r.__words[0];
          uint64_t v34 = (uint64_t)(v118.__r_.__value_.__l.__size_ - v118.__r_.__value_.__r.__words[0]) >> 3;
          unint64_t v35 = v34 + 1;
          if ((unint64_t)(v34 + 1) >> 61) {
            goto LABEL_153;
          }
          int64_t v36 = v118.__r_.__value_.__r.__words[2] - v118.__r_.__value_.__r.__words[0];
          if ((uint64_t)(v118.__r_.__value_.__r.__words[2] - v118.__r_.__value_.__r.__words[0]) >> 2 > v35) {
            unint64_t v35 = v36 >> 2;
          }
          if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v37 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v37 = v35;
          }
          if (v37)
          {
            std::string::size_type v38 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v118.__r_.__value_.__r.__words[2], v37);
            std::string::size_type size = v118.__r_.__value_.__l.__size_;
            uint64_t v33 = (void *)v118.__r_.__value_.__r.__words[0];
          }
          else
          {
            std::string::size_type v38 = 0;
          }
          uint64_t v39 = &v38[8 * v34];
          *(void *)uint64_t v39 = *(void *)(v30 + 8 * (void)v9);
          std::string::size_type v32 = (std::string::size_type)(v39 + 8);
          while ((void *)size != v33)
          {
            uint64_t v40 = *(void *)(size - 8);
            size -= 8;
            *((void *)v39 - 1) = v40;
            v39 -= 8;
          }
          v118.__r_.__value_.__r.__words[0] = (std::string::size_type)v39;
          v118.__r_.__value_.__l.__size_ = v32;
          v118.__r_.__value_.__r.__words[2] = (std::string::size_type)&v38[8 * v37];
          if (v33) {
            operator delete(v33);
          }
        }
        else
        {
          *(void *)v118.__r_.__value_.__l.__size_ = *(void *)(v30 + 8 * (void)v9);
          std::string::size_type v32 = size + 8;
        }
        v118.__r_.__value_.__l.__size_ = v32;
      }
      uint64_t v9 = (char *)v9 + 1;
    }
    while (v9 != (void *)v10);
    uint64_t v54 = __p;
    uint64_t v55 = (uint64_t)v120;
  }
  __n128 v113 = 0uLL;
  uint64_t v114 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v113, v54, v55, (v55 - (uint64_t)v54) >> 3);
  MIL::ValueInference::Tensor<unsigned short>::Zeros(&v113, a5);
  if (v113.n128_u64[0])
  {
    v113.n128_u64[1] = v113.n128_u64[0];
    operator delete((void *)v113.n128_u64[0]);
  }
  uint64_t v56 = *(void *)(a5 + 40) - *(void *)(a5 + 32);
  if (v56)
  {
    unint64_t v57 = 0;
    unint64_t v58 = v56 >> 1;
    unint64_t v95 = v56 >> 1;
    unint64_t v96 = (uint64_t)(a1[5] - a1[4]) >> 1;
    unint64_t v59 = v96 / (v56 >> 1);
    char v60 = (uint64_t **)(a5 + 8);
    if (v7 <= 1) {
      uint64_t v61 = 1;
    }
    else {
      uint64_t v61 = (v102 - v103) >> 3;
    }
    if (v58 <= 1) {
      uint64_t v62 = 1;
    }
    else {
      uint64_t v62 = v58;
    }
    uint64_t v94 = v62;
    if (v59 <= 1) {
      unint64_t v59 = 1;
    }
    unint64_t v100 = v59;
    do
    {
      unint64_t v98 = v57;
      LOWORD(v5) = (unsigned __int16)v5 & 0xFF00;
      if (v95 <= v96)
      {
        unint64_t v63 = 0;
        char v64 = 1;
        do
        {
          __int16 v105 = (__int16)v5;
          uint64_t v107 = 0;
          unint64_t v108 = 0;
          uint64_t v109 = 0;
          if (v102 != v103)
          {
            unint64_t v65 = 0;
            uint64_t v66 = 0;
            uint64_t v67 = 0;
            do
            {
              unint64_t v106 = v65;
              uint64_t v68 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(v122, &v106);
              uint64_t v69 = v108;
              if (v68)
              {
                uint64_t v70 = v110;
                if (v108 >= v109)
                {
                  unint64_t v74 = (char *)v107;
                  uint64_t v75 = (v108 - (unsigned char *)v107) >> 3;
                  unint64_t v76 = v75 + 1;
                  if ((unint64_t)(v75 + 1) >> 61) {
                    goto LABEL_151;
                  }
                  uint64_t v77 = v109 - (unsigned char *)v107;
                  if ((v109 - (unsigned char *)v107) >> 2 > v76) {
                    unint64_t v76 = v77 >> 2;
                  }
                  if ((unint64_t)v77 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v78 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v78 = v76;
                  }
                  if (v78)
                  {
                    uint64_t v79 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v109, v78);
                    unint64_t v74 = (char *)v107;
                    uint64_t v69 = v108;
                  }
                  else
                  {
                    uint64_t v79 = 0;
                  }
                  uint64_t v86 = &v79[8 * v75];
                  *(void *)uint64_t v86 = v70[v66];
                  uint64_t v71 = v86 + 8;
                  while (v69 != v74)
                  {
                    uint64_t v87 = *((void *)v69 - 1);
                    v69 -= 8;
                    *((void *)v86 - 1) = v87;
                    v86 -= 8;
                  }
                  uint64_t v107 = v86;
                  unint64_t v108 = v71;
                  uint64_t v109 = &v79[8 * v78];
                  if (v74) {
                    operator delete(v74);
                  }
                }
                else
                {
                  *(void *)unint64_t v108 = *((void *)v110 + v66);
                  uint64_t v71 = v69 + 8;
                }
                unint64_t v108 = v71;
                ++v66;
              }
              else
              {
                uint64_t v72 = v112[0];
                if (v108 >= v109)
                {
                  unint64_t v80 = (char *)v107;
                  uint64_t v81 = (v108 - (unsigned char *)v107) >> 3;
                  unint64_t v82 = v81 + 1;
                  if ((unint64_t)(v81 + 1) >> 61) {
LABEL_151:
                  }
                    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
                  uint64_t v83 = v109 - (unsigned char *)v107;
                  if ((v109 - (unsigned char *)v107) >> 2 > v82) {
                    unint64_t v82 = v83 >> 2;
                  }
                  if ((unint64_t)v83 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v84 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v84 = v82;
                  }
                  if (v84)
                  {
                    uint64_t v85 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v109, v84);
                    unint64_t v80 = (char *)v107;
                    uint64_t v69 = v108;
                  }
                  else
                  {
                    uint64_t v85 = 0;
                  }
                  int v88 = &v85[8 * v81];
                  *(void *)int v88 = v72[v67];
                  uint64_t v73 = v88 + 8;
                  while (v69 != v80)
                  {
                    uint64_t v89 = *((void *)v69 - 1);
                    v69 -= 8;
                    *((void *)v88 - 1) = v89;
                    v88 -= 8;
                  }
                  uint64_t v107 = v88;
                  unint64_t v108 = v73;
                  uint64_t v109 = &v85[8 * v84];
                  if (v80) {
                    operator delete(v80);
                  }
                }
                else
                {
                  *(void *)unint64_t v108 = *((void *)v112[0] + v67);
                  uint64_t v73 = v69 + 8;
                }
                unint64_t v108 = v73;
                ++v67;
              }
              ++v65;
            }
            while (v65 != v61);
          }
          if ((v64 & 1) == 0) {
            LOWORD(v5) = std::function<unsigned short ()(unsigned short,unsigned short)>::operator()(a4, v105, (__int16)v5);
          }
          char v60 = (uint64_t **)(a5 + 8);
          if (v107)
          {
            unint64_t v108 = (char *)v107;
            operator delete(v107);
          }
          if (v110)
          {
            __n128 v111 = v110;
            operator delete(v110);
          }
          char v64 = 0;
          ++v63;
        }
        while (v63 != v100);
      }
      if (v110)
      {
        __n128 v111 = v110;
        operator delete(v110);
      }
      if (v112[0])
      {
        v112[1] = v112[0];
        operator delete(v112[0]);
      }
      unint64_t v57 = v98 + 1;
    }
    while (v98 + 1 != v94);
  }
  if (v115)
  {
    std::string v116 = (char *)v115;
    operator delete(v115);
  }
  if (v118.__r_.__value_.__r.__words[0])
  {
    v118.__r_.__value_.__l.__size_ = v118.__r_.__value_.__r.__words[0];
    operator delete(v118.__r_.__value_.__l.__data_);
  }
  if (__p)
  {
    std::string v120 = (char *)__p;
    operator delete(__p);
  }
  return std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table((uint64_t)v122);
}

void sub_20F4C2EB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37,uint64_t a38,void *__p,uint64_t a40,int a41,__int16 a42,char a43,char a44,void *a45,uint64_t a46)
{
  if (a44 < 0)
  {
    operator delete(__p);
    if ((v47 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a45);
      std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table(v48 - 128);
      _Unwind_Resume(a1);
    }
  }
  else if (!v47)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v46);
  goto LABEL_6;
}

uint64_t std::function<unsigned short ()(unsigned short,unsigned short)>::operator()(uint64_t a1, __int16 a2, __int16 a3)
{
  __int16 v6 = a2;
  __int16 v5 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, __int16 *, __int16 *))(*(void *)v3 + 48))(v3, &v6, &v5);
}

void MIL::ValueInference::Tensor<unsigned short>::Zeros(MIL *a1@<X0>, const MIL::IRTensorValueType *a2@<X1>, uint64_t a3@<X8>)
{
  MIL::GetTensorShapeWithDimensionsAllKnown(a1, a2, (uint64_t)v6);
  *(_OWORD *)__n128 __p = *(_OWORD *)v6;
  uint64_t v5 = v7;
  v6[1] = 0;
  uint64_t v7 = 0;
  v6[0] = 0;
  MIL::ValueInference::Tensor<unsigned short>::Zeros((__n128 *)__p, a3);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v6[0])
  {
    v6[1] = v6[0];
    operator delete(v6[0]);
  }
}

void sub_20F4C30A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  if (__p) {
    operator delete(__p);
  }
  if (a13) {
    operator delete(a13);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<unsigned int>::FromIRTensorValue(void *a1@<X0>, uint64_t a2@<X8>)
{
  MIL::IRTensorValue::TryGetDataView<unsigned int>(&v12, *a1);
  if (!(_BYTE)v12)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Failed to get data view.");
    uint64_t v7 = (struct type_info *)MEMORY[0x263F8C1F0];
    unint64_t v8 = (void (*)(void *))MEMORY[0x263F8C070];
    goto LABEL_10;
  }
  unint64_t v4 = (MIL *)(*(uint64_t (**)(void))(*(void *)*a1 + 32))();
  if ((*(unsigned int (**)(MIL *))(*(void *)v4 + 88))(v4) == 3)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100]((std::logic_error *)exception, "It is not supported to convert a tensor of string dtype.");
    uint64_t v7 = (struct type_info *)off_26412C1F0;
    unint64_t v8 = (void (*)(void *))MEMORY[0x263F8C080];
LABEL_10:
    __cxa_throw(exception, v7, v8);
  }
  MIL::GetTensorShapeWithDimensionsAllKnown(v4, v5, (uint64_t)&v11);
  uint64_t v10 = 0;
  __n128 __p = 0uLL;
  std::vector<unsigned int>::__init_with_size[abi:ne180100]<unsigned int const*,unsigned int const*>(&__p, v13, (uint64_t)v13 + 4 * v14, v14);
  MIL::ValueInference::Tensor<unsigned int>::Tensor(a2, &v11, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v11.n128_u64[0])
  {
    v11.n128_u64[1] = v11.n128_u64[0];
    operator delete((void *)v11.n128_u64[0]);
  }
}

void sub_20F4C3224(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  __cxa_free_exception(v14);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<unsigned int>::ToIRTensorValue(uint64_t a1, MIL::IRConstantDimension *a2)
{
  memset(__p, 0, sizeof(__p));
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(__p, *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3);
  MIL::IRTensorValueType::Make(a2, 16, (MIL::MILContext ***)__p);
}

void sub_20F4C3330(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::ValueInference::Tensor<unsigned int>::Tensor(uint64_t a1, __n128 *a2, __n128 *a3)
{
  *(_OWORD *)(a1 + 8) = 0u;
  uint64_t v5 = a1 + 8;
  *(void *)a1 = &unk_26C25DCA8;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  __int16 v6 = (uint64_t *)a2->n128_u64[0];
  uint64_t v7 = (uint64_t *)a2->n128_u64[1];
  if ((uint64_t *)a2->n128_u64[0] == v7)
  {
    unint64_t v10 = a3->n128_u64[0];
    unint64_t v11 = a3->n128_u64[1];
    uint64_t v8 = a3->n128_u64[0] != v11;
  }
  else
  {
    uint64_t v8 = 1;
    do
    {
      uint64_t v9 = *v6++;
      v8 *= v9;
    }
    while (v6 != v7);
    unint64_t v10 = a3->n128_u64[0];
    unint64_t v11 = a3->n128_u64[1];
  }
  if (v8 != (uint64_t)(v11 - v10) >> 2)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "data size and shape dismatch.");
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  std::vector<float>::__move_assign(v5, a2);
  std::vector<float>::__move_assign(a1 + 32, a3);
  *(void *)(a1 + 56) = v8;
  return a1;
}

void sub_20F4C3468(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10)
{
  uint64_t v13 = *v11;
  if (*v11)
  {
    *(void *)(v10 + 40) = v13;
    operator delete(v13);
  }
  unint64_t v14 = *a10;
  if (*a10)
  {
    *(void *)(v10 + 16) = v14;
    operator delete(v14);
  }
  _Unwind_Resume(exception_object);
}

double MIL::ValueInference::Tensor<unsigned int>::Tensor(uint64_t a1)
{
  *(void *)a1 = &unk_26C25DCA8;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  return result;
}

void MIL::ValueInference::Tensor<unsigned int>::ForEach(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v13[4] = *MEMORY[0x263EF8340];
  std::vector<unsigned int>::size_type v6 = (uint64_t)(*(void *)(a1 + 40) - *(void *)(a1 + 32)) >> 2;
  __x.n128_u32[0] = 0;
  std::vector<unsigned int>::vector(&v12, v6, (const std::vector<unsigned int>::value_type *)&__x);
  __n128 __x = 0uLL;
  uint64_t v11 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__x, *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3);
  uint64_t v8 = *(int **)(a1 + 32);
  uint64_t v7 = *(int **)(a1 + 40);
  std::vector<unsigned int>::pointer begin = v12.__begin_;
  std::__function::__value_func<unsigned int ()>::__value_func[abi:ne180100]((uint64_t)v13, a2);
  while (v8 != v7)
    *begin++ = std::function<unsigned int ()>::operator()((uint64_t)v13, *v8++);
  std::__function::__value_func<unsigned int ()>::~__value_func[abi:ne180100](v13);
  MIL::ValueInference::Tensor<unsigned int>::Tensor(a3, &__x, (__n128 *)&v12);
  if (__x.n128_u64[0])
  {
    __x.n128_u64[1] = __x.n128_u64[0];
    operator delete((void *)__x.n128_u64[0]);
  }
  if (v12.__begin_)
  {
    v12.__end_ = v12.__begin_;
    operator delete(v12.__begin_);
  }
}

void sub_20F4C35E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, char a16)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::ValueInference::Tensor<unsigned int>::GetScalarData(void *a1)
{
  if (a1[1] != a1[2] || (uint64_t v1 = (unsigned int *)a1[4], a1[5] - (void)v1 != 4))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Tensor is not a scalar.");
    __cxa_throw(exception, MEMORY[0x263F8C1E0], MEMORY[0x263F8C048]);
  }
  return *v1;
}

void sub_20F4C36A8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<unsigned int>::Reshape(void *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  std::vector<unsigned int>::size_type v6 = (uint64_t *)*a2;
  uint64_t v7 = a2[1];
  uint64_t v8 = 1;
  if (v6 != (uint64_t *)v7)
  {
    uint64_t v9 = v6;
    do
    {
      uint64_t v10 = *v9++;
      v8 *= v10;
    }
    while (v9 != (uint64_t *)v7);
  }
  if (a1[7] != v8)
  {
    uint64_t v13 = a2;
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v22);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"Tensor is not able to be reshaped since the number of elements in the newShape [ ", 81);
    uint64_t v14 = *v13;
    uint64_t v15 = v13[1];
    if (*v13 != v15)
    {
      do
      {
        uint64_t v16 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)" ", 1);
        v14 += 8;
      }
      while (v14 != v15);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"] is not the same as the number of elements in the tensor shape [ ", 66);
    uint64_t v17 = a1[1];
    for (uint64_t i = a1[2]; v17 != i; v17 += 8)
    {
      uint64_t v19 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)" ", 1);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"].", 2);
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str();
    std::logic_error::logic_error(exception, &__p);
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  __n128 v22 = 0uLL;
  uint64_t v23 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v22, v6, v7, (v7 - (uint64_t)v6) >> 3);
  uint64_t v11 = (const void *)a1[4];
  uint64_t v12 = a1[5];
  memset(&__p, 0, sizeof(__p));
  std::vector<unsigned int>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned int const*>,std::__wrap_iter<unsigned int const*>>(&__p, v11, v12, (v12 - (uint64_t)v11) >> 2);
  MIL::ValueInference::Tensor<unsigned int>::Tensor(a3, &v22, (__n128 *)&__p);
  if (__p.__r_.__value_.__r.__words[0])
  {
    __p.__r_.__value_.__l.__size_ = __p.__r_.__value_.__r.__words[0];
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v22.n128_u64[0])
  {
    v22.n128_u64[1] = v22.n128_u64[0];
    operator delete((void *)v22.n128_u64[0]);
  }
}

void sub_20F4C38BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((v17 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v17)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v16);
  goto LABEL_6;
}

void MIL::ValueInference::Tensor<unsigned int>::NonZero(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v3 = *(void *)(a1 + 56);
  if (v3)
  {
    unint64_t v5 = 0;
    std::vector<unsigned int>::size_type v6 = (uint64_t **)(a1 + 8);
    do
    {
      if (*(_DWORD *)(*(void *)(a1 + 32) + 4 * v5))
      {
        std::vector<std::vector<unsigned long long>>::push_back[abi:ne180100](a2, (uint64_t)__p);
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
        unint64_t v3 = *(void *)(a1 + 56);
      }
      ++v5;
    }
    while (v5 < v3);
  }
}

void sub_20F4C39D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
}

void MIL::ValueInference::Tensor<unsigned int>::SubTensor(void *a1@<X0>, uint64_t **a2@<X1>, void *a3@<X8>)
{
  unint64_t v5 = ((char *)a2[1] - (char *)*a2) >> 4;
  std::vector<unsigned int>::size_type v6 = a1 + 1;
  if (v5 != (uint64_t)(a1[2] - a1[1]) >> 3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "Indices does not match the rank of the tensor.");
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  std::string __p = 0;
  uint64_t v46 = 0;
  int v47 = 0;
  std::vector<unsigned long long>::reserve(&__p, v5);
  uint64_t v8 = a1[1];
  if (a1[2] != v8)
  {
    unint64_t v9 = 0;
    while (1)
    {
      unint64_t v11 = (*a2)[2 * v9];
      unint64_t v10 = (*a2)[2 * v9 + 1];
      unint64_t v12 = v10 - v11;
      if (v10 < v11) {
        break;
      }
      if (v10 > *(void *)(v8 + 8 * v9))
      {
        uint64_t v33 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(v33, "Indices end is out of the bound for the tensor dimension.");
        uint64_t v34 = (void (*)(void *))MEMORY[0x263F8C068];
        unint64_t v35 = (struct type_info *)off_26412C1E0;
        uint64_t v36 = MEMORY[0x263F8C390] + 16;
LABEL_45:
        v33->__vftable = (std::logic_error_vtbl *)v36;
        __cxa_throw(v33, v35, v34);
      }
      uint64_t v13 = v46;
      if (v46 >= v47)
      {
        uint64_t v15 = (char *)__p;
        uint64_t v16 = (v46 - (unsigned char *)__p) >> 3;
        unint64_t v17 = v16 + 1;
        if ((unint64_t)(v16 + 1) >> 61) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v18 = v47 - (unsigned char *)__p;
        if ((v47 - (unsigned char *)__p) >> 2 > v17) {
          unint64_t v17 = v18 >> 2;
        }
        if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v19 = v17;
        }
        if (v19)
        {
          unint64_t v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v47, v19);
          uint64_t v15 = (char *)__p;
          uint64_t v13 = v46;
        }
        else
        {
          unint64_t v20 = 0;
        }
        size_t v21 = &v20[8 * v16];
        *(void *)size_t v21 = v12;
        uint64_t v14 = (uint64_t)(v21 + 8);
        while (v13 != v15)
        {
          uint64_t v22 = *((void *)v13 - 1);
          v13 -= 8;
          *((void *)v21 - 1) = v22;
          v21 -= 8;
        }
        std::string __p = v21;
        uint64_t v46 = (char *)v14;
        int v47 = &v20[8 * v19];
        if (v15) {
          operator delete(v15);
        }
      }
      else
      {
        *(void *)uint64_t v46 = v12;
        uint64_t v14 = (uint64_t)(v13 + 8);
      }
      uint64_t v46 = (char *)v14;
      ++v9;
      uint64_t v8 = a1[1];
      if (v9 >= (a1[2] - v8) >> 3) {
        goto LABEL_25;
      }
    }
    uint64_t v33 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v33, "Indices end must not be smaller than the indices begin.");
    uint64_t v34 = (void (*)(void *))MEMORY[0x263F8C080];
    unint64_t v35 = (struct type_info *)off_26412C1F0;
    uint64_t v36 = MEMORY[0x263F8C3A0] + 16;
    goto LABEL_45;
  }
  uint64_t v14 = (uint64_t)v46;
LABEL_25:
  __n128 v43 = 0uLL;
  uint64_t v44 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v43, __p, v14, (v14 - (uint64_t)__p) >> 3);
  MIL::ValueInference::Tensor<unsigned int>::Zeros(&v43, (uint64_t)a3);
  if (v43.n128_u64[0])
  {
    v43.n128_u64[1] = v43.n128_u64[0];
    operator delete((void *)v43.n128_u64[0]);
  }
  uint64_t v23 = a3[5] - a3[4];
  if (v23)
  {
    unint64_t v24 = 0;
    unint64_t v25 = v23 >> 2;
    if (v25 <= 1) {
      uint64_t v26 = 1;
    }
    else {
      uint64_t v26 = v25;
    }
    do
    {
      std::string::size_type v38 = 0;
      uint64_t v39 = 0;
      uint64_t v40 = 0;
      std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v38, v41, (uint64_t)v42, (v42 - (unsigned char *)v41) >> 3);
      uint64_t v27 = a1[2] - a1[1];
      if (v27)
      {
        unint64_t v28 = v27 >> 3;
        uint64_t v29 = *a2;
        uint64_t v30 = v38;
        if (v28 <= 1) {
          unint64_t v28 = 1;
        }
        do
        {
          uint64_t v31 = *v29;
          v29 += 2;
          *v30++ += v31;
          --v28;
        }
        while (v28);
      }
      if (v38)
      {
        uint64_t v39 = v38;
        operator delete(v38);
      }
      if (v41)
      {
        uint64_t v42 = v41;
        operator delete(v41);
      }
      ++v24;
    }
    while (v24 != v26);
  }
  if (__p)
  {
    uint64_t v46 = (char *)__p;
    operator delete(__p);
  }
}

void sub_20F4C3D84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19)
{
  __cxa_free_exception(v19);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<unsigned int>::Zeros(__n128 *a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t v4 = (uint64_t *)a1->n128_u64[0];
  std::vector<unsigned int>::size_type v5 = 1;
  while (v4 != (uint64_t *)a1->n128_u64[1])
  {
    uint64_t v6 = *v4++;
    v5 *= v6;
  }
  std::vector<unsigned int>::vector(&v7, v5);
  MIL::ValueInference::Tensor<unsigned int>::Tensor(a2, a1, (__n128 *)&v7);
  if (v7.__begin_)
  {
    v7.__end_ = v7.__begin_;
    operator delete(v7.__begin_);
  }
}

void sub_20F4C3E98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<unsigned int>::Concat(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *a1;
  uint64_t v7 = 0;
  uint64_t v8 = a1[1] - *a1;
  if (v8)
  {
    unint64_t v9 = v8 >> 6;
    if (v9 <= 1) {
      unint64_t v9 = 1;
    }
    unint64_t v10 = (uint64_t *)(v6 + 8);
    do
    {
      uint64_t v11 = *v10;
      v10 += 8;
      v7 += *(void *)(v11 + 8 * a2);
      --v9;
    }
    while (v9);
  }
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  unint64_t v28 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v28, *(const void **)(v6 + 8), *(void *)(v6 + 16), (uint64_t)(*(void *)(v6 + 16) - *(void *)(v6 + 8)) >> 3);
  unint64_t v12 = v28;
  *((void *)v28 + a2) = v7;
  uint64_t v27 = 0;
  __n128 __p = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, v12, (uint64_t)v29, (v29 - (unsigned char *)v12) >> 3);
  MIL::ValueInference::Tensor<unsigned int>::Zeros(&__p, a3);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  uint64_t v13 = *a1;
  uint64_t v14 = a1[1];
  if (v14 != *a1)
  {
    unint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(void *)(v13 + (v15 << 6) + 40) - *(void *)(v13 + (v15 << 6) + 32);
      if (v17)
      {
        unint64_t v18 = 0;
        if ((unint64_t)(v17 >> 2) <= 1) {
          uint64_t v19 = 1;
        }
        else {
          uint64_t v19 = v17 >> 2;
        }
        do
        {
          size_t v21 = 0;
          uint64_t v22 = 0;
          uint64_t v23 = 0;
          std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v21, v24, (uint64_t)v25, (v25 - (unsigned char *)v24) >> 3);
          *((void *)v21 + a2) += v16;
          unint64_t v20 = *a1 + (v15 << 6);
          LODWORD(v20) = *(_DWORD *)(*(void *)(v20 + 32)
          *(_DWORD *)(*(void *)(a3 + 32)
          if (v21)
          {
            uint64_t v22 = v21;
            operator delete(v21);
          }
          if (v24)
          {
            unint64_t v25 = v24;
            operator delete(v24);
          }
          ++v18;
        }
        while (v19 != v18);
        uint64_t v13 = *a1;
        uint64_t v14 = a1[1];
      }
      v16 += *(void *)(*(void *)(v13 + (v15++ << 6) + 8) + 8 * a2);
    }
    while (v15 < (v14 - v13) >> 6);
  }
  if (v28)
  {
    uint64_t v29 = v28;
    operator delete(v28);
  }
}

void sub_20F4C40A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  if (a18) {
    operator delete(a18);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<unsigned int>::BlockwiseMerge(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *(uint64_t **)a2;
  uint64_t v7 = *(void *)(a2 + 8) - *(void *)a2;
  if (v7)
  {
    unint64_t v8 = v7 >> 3;
    if (v8 <= 1) {
      unint64_t v8 = 1;
    }
    uint64_t v9 = 1;
    do
    {
      uint64_t v10 = *v6++;
      v9 *= v10;
      --v8;
    }
    while (v8);
  }
  else
  {
    uint64_t v9 = 1;
  }
  uint64_t v11 = *a1;
  if (v9 != (a1[1] - *a1) >> 6)
  {
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v48);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v48, (uint64_t)"The number of tensors (", 23);
    uint64_t v36 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v36, (uint64_t)") is not the same as the number of blocks (", 43);
    unint64_t v37 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v37, (uint64_t)").", 2);
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str();
    std::runtime_error::runtime_error(exception, &v47);
    __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
  }
  uint64_t v49 = 0;
  uint64_t v50 = 0;
  uint64_t v48 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v48, *(const void **)(v11 + 8), *(void *)(v11 + 16), (uint64_t)(*(void *)(v11 + 16) - *(void *)(v11 + 8)) >> 3);
  memset(&v47, 0, sizeof(v47));
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v47, v48, (uint64_t)v49, (v49 - (unsigned char *)v48) >> 3);
  unint64_t v12 = *(uint64_t **)a2;
  uint64_t v13 = (const void *)v47.__r_.__value_.__r.__words[0];
  uint64_t v14 = *(void *)(a2 + 8) - *(void *)a2;
  if (v14)
  {
    unint64_t v15 = v14 >> 3;
    if (v15 <= 1) {
      unint64_t v15 = 1;
    }
    uint64_t v16 = (void *)v47.__r_.__value_.__r.__words[0];
    do
    {
      uint64_t v17 = *v12++;
      *v16++ *= v17;
      --v15;
    }
    while (v15);
  }
  __n128 __p = 0uLL;
  uint64_t v46 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, v13, v47.__r_.__value_.__l.__size_, (uint64_t)(v47.__r_.__value_.__l.__size_ - (void)v13) >> 3);
  MIL::ValueInference::Tensor<unsigned int>::Zeros(&__p, a3);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v9)
  {
    for (unint64_t i = 0; i != v9; ++i)
    {
      unint64_t v19 = *a1 + (i << 6);
      unint64_t v20 = *(const void **)(v19 + 8);
      size_t v21 = *(void *)(v19 + 16) - (void)v20;
      if (v21 != v49 - (unsigned char *)v48 || memcmp(v20, v48, v21))
      {
        unint64_t v35 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v35, "All tensors must have the same shape so they can be merged.");
        __cxa_throw(v35, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
      }
      uint64_t v22 = *(void *)(*a1 + (i << 6) + 40) - *(void *)(*a1 + (i << 6) + 32);
      if (v22)
      {
        unint64_t v23 = 0;
        unint64_t v24 = v22 >> 2;
        if (v24 <= 1) {
          uint64_t v25 = 1;
        }
        else {
          uint64_t v25 = v24;
        }
        do
        {
          uint64_t v39 = 0;
          uint64_t v40 = 0;
          uint64_t v41 = 0;
          std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v39, v42, (uint64_t)v43, (v43 - (unsigned char *)v42) >> 3);
          uint64_t v26 = *(void *)(a2 + 8) - *(void *)a2;
          if (v26)
          {
            unint64_t v27 = v26 >> 3;
            unint64_t v28 = (uint64_t *)v48;
            uint64_t v29 = (uint64_t *)v44[0];
            uint64_t v30 = v39;
            if (v27 <= 1) {
              unint64_t v27 = 1;
            }
            do
            {
              uint64_t v32 = *v28++;
              uint64_t v31 = v32;
              uint64_t v33 = *v29++;
              *v30++ += v33 * v31;
              --v27;
            }
            while (v27);
          }
          unint64_t v34 = *a1 + (i << 6);
          LODWORD(v34) = *(_DWORD *)(*(void *)(v34 + 32)
          *(_DWORD *)(*(void *)(a3 + 32)
          if (v39)
          {
            uint64_t v40 = v39;
            operator delete(v39);
          }
          if (v42)
          {
            __n128 v43 = v42;
            operator delete(v42);
          }
          ++v23;
        }
        while (v23 != v25);
      }
      if (v44[0])
      {
        v44[1] = v44[0];
        operator delete(v44[0]);
      }
    }
  }
  if (v47.__r_.__value_.__r.__words[0])
  {
    v47.__r_.__value_.__l.__size_ = v47.__r_.__value_.__r.__words[0];
    operator delete(v47.__r_.__value_.__l.__data_);
  }
  if (v48)
  {
    uint64_t v49 = v48;
    operator delete(v48);
  }
}

void sub_20F4C44AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28)
{
  if (a26 < 0)
  {
    operator delete(__p);
    if ((v29 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a27);
      _Unwind_Resume(a1);
    }
  }
  else if (!v29)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v28);
  goto LABEL_6;
}

uint64_t MIL::ValueInference::Tensor<unsigned int>::Reduce@<X0>(void *a1@<X0>, unint64_t **a2@<X1>, int a3@<W2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v103 = a1[1];
  unint64_t v104 = a1 + 1;
  uint64_t v102 = a1[2];
  unint64_t v7 = (v102 - v103) >> 3;
  std::unordered_set<unsigned long long>::unordered_set<std::__wrap_iter<unsigned long long const*>>((uint64_t)v122, *a2, a2[1]);
  for (unint64_t i = v123; i; unint64_t i = (void *)*i)
  {
    if (i[2] >= v7)
    {
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&__p);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&__p, (uint64_t)"axis(", 5);
      uint64_t v91 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v91, (uint64_t)") must be smaller than the number of input dimensions(", 54);
      uint64_t v92 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v92, (uint64_t)").", 2);
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::stringbuf::str();
      std::logic_error::logic_error(exception, &v118);
      exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
      __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
    }
  }
  __n128 __p = 0;
  std::string v120 = 0;
  v121[0] = 0;
  memset(&v118, 0, sizeof(v118));
  __n128 v115 = 0;
  std::string v116 = 0;
  uint64_t v117 = 0;
  if (v102 == v103)
  {
    uint64_t v55 = 0;
    uint64_t v54 = 0;
  }
  else
  {
    uint64_t v9 = 0;
    std::vector<unsigned int>::size_type v5 = &v117;
    if (v7 <= 1) {
      uint64_t v10 = 1;
    }
    else {
      uint64_t v10 = (v102 - v103) >> 3;
    }
    do
    {
      v112[0] = v9;
      if (std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(v122, (unint64_t *)v112))
      {
        if (a3)
        {
          uint64_t v11 = v120;
          if ((unint64_t)v120 >= v121[0])
          {
            uint64_t v22 = (char *)__p;
            uint64_t v23 = (v120 - (unsigned char *)__p) >> 3;
            unint64_t v24 = v23 + 1;
            if ((unint64_t)(v23 + 1) >> 61) {
              std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v25 = v121[0] - (void)__p;
            if ((uint64_t)(v121[0] - (void)__p) >> 2 > v24) {
              unint64_t v24 = v25 >> 2;
            }
            if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v26 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v26 = v24;
            }
            if (v26)
            {
              unint64_t v27 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)v121, v26);
              uint64_t v22 = (char *)__p;
              uint64_t v11 = v120;
            }
            else
            {
              unint64_t v27 = 0;
            }
            uint64_t v41 = &v27[8 * v23];
            *(void *)uint64_t v41 = 1;
            unint64_t v12 = v41 + 8;
            while (v11 != v22)
            {
              uint64_t v42 = *((void *)v11 - 1);
              v11 -= 8;
              *((void *)v41 - 1) = v42;
              v41 -= 8;
            }
            __n128 __p = v41;
            std::string v120 = v12;
            v121[0] = &v27[8 * v26];
            if (v22) {
              operator delete(v22);
            }
          }
          else
          {
            *(void *)std::string v120 = 1;
            unint64_t v12 = v11 + 8;
          }
          std::string v120 = v12;
        }
        uint64_t v43 = *v104;
        uint64_t v44 = v116;
        if (v116 >= v117)
        {
          uint64_t v46 = (char *)v115;
          uint64_t v47 = (v116 - (unsigned char *)v115) >> 3;
          unint64_t v48 = v47 + 1;
          if ((unint64_t)(v47 + 1) >> 61) {
LABEL_153:
          }
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          uint64_t v49 = v117 - (unsigned char *)v115;
          if ((v117 - (unsigned char *)v115) >> 2 > v48) {
            unint64_t v48 = v49 >> 2;
          }
          if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v50 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v50 = v48;
          }
          if (v50)
          {
            uint64_t v51 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v117, v50);
            uint64_t v46 = (char *)v115;
            uint64_t v44 = v116;
          }
          else
          {
            uint64_t v51 = 0;
          }
          uint64_t v52 = &v51[8 * v47];
          *(void *)uint64_t v52 = *(void *)(v43 + 8 * (void)v9);
          uint64_t v45 = v52 + 8;
          while (v44 != v46)
          {
            uint64_t v53 = *((void *)v44 - 1);
            v44 -= 8;
            *((void *)v52 - 1) = v53;
            v52 -= 8;
          }
          __n128 v115 = v52;
          std::string v116 = v45;
          uint64_t v117 = &v51[8 * v50];
          if (v46) {
            operator delete(v46);
          }
        }
        else
        {
          *(void *)std::string v116 = *(void *)(v43 + 8 * (void)v9);
          uint64_t v45 = v44 + 8;
        }
        std::string v116 = v45;
      }
      else
      {
        uint64_t v13 = *v104;
        uint64_t v14 = v120;
        if ((unint64_t)v120 >= v121[0])
        {
          uint64_t v16 = (char *)__p;
          uint64_t v17 = (v120 - (unsigned char *)__p) >> 3;
          unint64_t v18 = v17 + 1;
          if ((unint64_t)(v17 + 1) >> 61) {
            goto LABEL_153;
          }
          uint64_t v19 = v121[0] - (void)__p;
          if ((uint64_t)(v121[0] - (void)__p) >> 2 > v18) {
            unint64_t v18 = v19 >> 2;
          }
          if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v20 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v20 = v18;
          }
          if (v20)
          {
            size_t v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)v121, v20);
            uint64_t v16 = (char *)__p;
            uint64_t v14 = v120;
          }
          else
          {
            size_t v21 = 0;
          }
          unint64_t v28 = &v21[8 * v17];
          *(void *)unint64_t v28 = *(void *)(v13 + 8 * (void)v9);
          unint64_t v15 = v28 + 8;
          while (v14 != v16)
          {
            uint64_t v29 = *((void *)v14 - 1);
            v14 -= 8;
            *((void *)v28 - 1) = v29;
            v28 -= 8;
          }
          __n128 __p = v28;
          std::string v120 = v15;
          v121[0] = &v21[8 * v20];
          if (v16) {
            operator delete(v16);
          }
        }
        else
        {
          *(void *)std::string v120 = *(void *)(v13 + 8 * (void)v9);
          unint64_t v15 = v14 + 8;
        }
        std::string v120 = v15;
        uint64_t v30 = *v104;
        std::string::size_type size = v118.__r_.__value_.__l.__size_;
        if (v118.__r_.__value_.__l.__size_ >= v118.__r_.__value_.__r.__words[2])
        {
          uint64_t v33 = (void *)v118.__r_.__value_.__r.__words[0];
          uint64_t v34 = (uint64_t)(v118.__r_.__value_.__l.__size_ - v118.__r_.__value_.__r.__words[0]) >> 3;
          unint64_t v35 = v34 + 1;
          if ((unint64_t)(v34 + 1) >> 61) {
            goto LABEL_153;
          }
          int64_t v36 = v118.__r_.__value_.__r.__words[2] - v118.__r_.__value_.__r.__words[0];
          if ((uint64_t)(v118.__r_.__value_.__r.__words[2] - v118.__r_.__value_.__r.__words[0]) >> 2 > v35) {
            unint64_t v35 = v36 >> 2;
          }
          if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v37 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v37 = v35;
          }
          if (v37)
          {
            std::string::size_type v38 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v118.__r_.__value_.__r.__words[2], v37);
            std::string::size_type size = v118.__r_.__value_.__l.__size_;
            uint64_t v33 = (void *)v118.__r_.__value_.__r.__words[0];
          }
          else
          {
            std::string::size_type v38 = 0;
          }
          uint64_t v39 = &v38[8 * v34];
          *(void *)uint64_t v39 = *(void *)(v30 + 8 * (void)v9);
          std::string::size_type v32 = (std::string::size_type)(v39 + 8);
          while ((void *)size != v33)
          {
            uint64_t v40 = *(void *)(size - 8);
            size -= 8;
            *((void *)v39 - 1) = v40;
            v39 -= 8;
          }
          v118.__r_.__value_.__r.__words[0] = (std::string::size_type)v39;
          v118.__r_.__value_.__l.__size_ = v32;
          v118.__r_.__value_.__r.__words[2] = (std::string::size_type)&v38[8 * v37];
          if (v33) {
            operator delete(v33);
          }
        }
        else
        {
          *(void *)v118.__r_.__value_.__l.__size_ = *(void *)(v30 + 8 * (void)v9);
          std::string::size_type v32 = size + 8;
        }
        v118.__r_.__value_.__l.__size_ = v32;
      }
      uint64_t v9 = (char *)v9 + 1;
    }
    while (v9 != (void *)v10);
    uint64_t v54 = __p;
    uint64_t v55 = (uint64_t)v120;
  }
  __n128 v113 = 0uLL;
  uint64_t v114 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v113, v54, v55, (v55 - (uint64_t)v54) >> 3);
  MIL::ValueInference::Tensor<unsigned int>::Zeros(&v113, a5);
  if (v113.n128_u64[0])
  {
    v113.n128_u64[1] = v113.n128_u64[0];
    operator delete((void *)v113.n128_u64[0]);
  }
  uint64_t v56 = *(void *)(a5 + 40) - *(void *)(a5 + 32);
  if (v56)
  {
    unint64_t v57 = 0;
    unint64_t v58 = v56 >> 2;
    unint64_t v95 = v56 >> 2;
    unint64_t v96 = (uint64_t)(a1[5] - a1[4]) >> 2;
    unint64_t v59 = v96 / (v56 >> 2);
    char v60 = (uint64_t **)(a5 + 8);
    if (v7 <= 1) {
      uint64_t v61 = 1;
    }
    else {
      uint64_t v61 = (v102 - v103) >> 3;
    }
    if (v58 <= 1) {
      uint64_t v62 = 1;
    }
    else {
      uint64_t v62 = v58;
    }
    uint64_t v94 = v62;
    if (v59 <= 1) {
      unint64_t v59 = 1;
    }
    unint64_t v100 = v59;
    do
    {
      unint64_t v98 = v57;
      LODWORD(v5) = v5 & 0xFFFFFF00;
      if (v95 <= v96)
      {
        unint64_t v63 = 0;
        char v64 = 1;
        do
        {
          int v105 = (int)v5;
          uint64_t v107 = 0;
          unint64_t v108 = 0;
          uint64_t v109 = 0;
          if (v102 != v103)
          {
            unint64_t v65 = 0;
            uint64_t v66 = 0;
            uint64_t v67 = 0;
            do
            {
              unint64_t v106 = v65;
              uint64_t v68 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(v122, &v106);
              uint64_t v69 = v108;
              if (v68)
              {
                uint64_t v70 = v110;
                if (v108 >= v109)
                {
                  unint64_t v74 = (char *)v107;
                  uint64_t v75 = (v108 - (unsigned char *)v107) >> 3;
                  unint64_t v76 = v75 + 1;
                  if ((unint64_t)(v75 + 1) >> 61) {
                    goto LABEL_151;
                  }
                  uint64_t v77 = v109 - (unsigned char *)v107;
                  if ((v109 - (unsigned char *)v107) >> 2 > v76) {
                    unint64_t v76 = v77 >> 2;
                  }
                  if ((unint64_t)v77 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v78 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v78 = v76;
                  }
                  if (v78)
                  {
                    uint64_t v79 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v109, v78);
                    unint64_t v74 = (char *)v107;
                    uint64_t v69 = v108;
                  }
                  else
                  {
                    uint64_t v79 = 0;
                  }
                  uint64_t v86 = &v79[8 * v75];
                  *(void *)uint64_t v86 = v70[v66];
                  uint64_t v71 = v86 + 8;
                  while (v69 != v74)
                  {
                    uint64_t v87 = *((void *)v69 - 1);
                    v69 -= 8;
                    *((void *)v86 - 1) = v87;
                    v86 -= 8;
                  }
                  uint64_t v107 = v86;
                  unint64_t v108 = v71;
                  uint64_t v109 = &v79[8 * v78];
                  if (v74) {
                    operator delete(v74);
                  }
                }
                else
                {
                  *(void *)unint64_t v108 = *((void *)v110 + v66);
                  uint64_t v71 = v69 + 8;
                }
                unint64_t v108 = v71;
                ++v66;
              }
              else
              {
                uint64_t v72 = v112[0];
                if (v108 >= v109)
                {
                  unint64_t v80 = (char *)v107;
                  uint64_t v81 = (v108 - (unsigned char *)v107) >> 3;
                  unint64_t v82 = v81 + 1;
                  if ((unint64_t)(v81 + 1) >> 61) {
LABEL_151:
                  }
                    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
                  uint64_t v83 = v109 - (unsigned char *)v107;
                  if ((v109 - (unsigned char *)v107) >> 2 > v82) {
                    unint64_t v82 = v83 >> 2;
                  }
                  if ((unint64_t)v83 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v84 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v84 = v82;
                  }
                  if (v84)
                  {
                    uint64_t v85 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v109, v84);
                    unint64_t v80 = (char *)v107;
                    uint64_t v69 = v108;
                  }
                  else
                  {
                    uint64_t v85 = 0;
                  }
                  int v88 = &v85[8 * v81];
                  *(void *)int v88 = v72[v67];
                  uint64_t v73 = v88 + 8;
                  while (v69 != v80)
                  {
                    uint64_t v89 = *((void *)v69 - 1);
                    v69 -= 8;
                    *((void *)v88 - 1) = v89;
                    v88 -= 8;
                  }
                  uint64_t v107 = v88;
                  unint64_t v108 = v73;
                  uint64_t v109 = &v85[8 * v84];
                  if (v80) {
                    operator delete(v80);
                  }
                }
                else
                {
                  *(void *)unint64_t v108 = *((void *)v112[0] + v67);
                  uint64_t v73 = v69 + 8;
                }
                unint64_t v108 = v73;
                ++v67;
              }
              ++v65;
            }
            while (v65 != v61);
          }
          if ((v64 & 1) == 0) {
            LODWORD(v5) = std::function<unsigned int ()(unsigned int,unsigned int)>::operator()(a4, v105, (int)v5);
          }
          char v60 = (uint64_t **)(a5 + 8);
          if (v107)
          {
            unint64_t v108 = (char *)v107;
            operator delete(v107);
          }
          if (v110)
          {
            __n128 v111 = v110;
            operator delete(v110);
          }
          char v64 = 0;
          ++v63;
        }
        while (v63 != v100);
      }
      if (v110)
      {
        __n128 v111 = v110;
        operator delete(v110);
      }
      if (v112[0])
      {
        v112[1] = v112[0];
        operator delete(v112[0]);
      }
      unint64_t v57 = v98 + 1;
    }
    while (v98 + 1 != v94);
  }
  if (v115)
  {
    std::string v116 = (char *)v115;
    operator delete(v115);
  }
  if (v118.__r_.__value_.__r.__words[0])
  {
    v118.__r_.__value_.__l.__size_ = v118.__r_.__value_.__r.__words[0];
    operator delete(v118.__r_.__value_.__l.__data_);
  }
  if (__p)
  {
    std::string v120 = (char *)__p;
    operator delete(__p);
  }
  return std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table((uint64_t)v122);
}

void sub_20F4C4DDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37,uint64_t a38,void *__p,uint64_t a40,int a41,__int16 a42,char a43,char a44,void *a45,uint64_t a46)
{
  if (a44 < 0)
  {
    operator delete(__p);
    if ((v47 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a45);
      std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table(v48 - 128);
      _Unwind_Resume(a1);
    }
  }
  else if (!v47)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v46);
  goto LABEL_6;
}

uint64_t std::function<unsigned int ()(unsigned int,unsigned int)>::operator()(uint64_t a1, int a2, int a3)
{
  int v6 = a2;
  int v5 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, int *, int *))(*(void *)v3 + 48))(v3, &v6, &v5);
}

void MIL::ValueInference::Tensor<unsigned int>::Zeros(MIL *a1@<X0>, const MIL::IRTensorValueType *a2@<X1>, uint64_t a3@<X8>)
{
  MIL::GetTensorShapeWithDimensionsAllKnown(a1, a2, (uint64_t)v6);
  *(_OWORD *)__n128 __p = *(_OWORD *)v6;
  uint64_t v5 = v7;
  v6[1] = 0;
  uint64_t v7 = 0;
  v6[0] = 0;
  MIL::ValueInference::Tensor<unsigned int>::Zeros((__n128 *)__p, a3);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v6[0])
  {
    v6[1] = v6[0];
    operator delete(v6[0]);
  }
}

void sub_20F4C4FCC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  if (__p) {
    operator delete(__p);
  }
  if (a13) {
    operator delete(a13);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<unsigned long long>::FromIRTensorValue(void *a1@<X0>, uint64_t a2@<X8>)
{
  MIL::IRTensorValue::TryGetDataView<unsigned long long>(&v12, *a1);
  if (!(_BYTE)v12)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Failed to get data view.");
    uint64_t v7 = (struct type_info *)MEMORY[0x263F8C1F0];
    unint64_t v8 = (void (*)(void *))MEMORY[0x263F8C070];
    goto LABEL_10;
  }
  unint64_t v4 = (MIL *)(*(uint64_t (**)(void))(*(void *)*a1 + 32))();
  if ((*(unsigned int (**)(MIL *))(*(void *)v4 + 88))(v4) == 3)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100]((std::logic_error *)exception, "It is not supported to convert a tensor of string dtype.");
    uint64_t v7 = (struct type_info *)off_26412C1F0;
    unint64_t v8 = (void (*)(void *))MEMORY[0x263F8C080];
LABEL_10:
    __cxa_throw(exception, v7, v8);
  }
  MIL::GetTensorShapeWithDimensionsAllKnown(v4, v5, (uint64_t)&v11);
  uint64_t v10 = 0;
  __n128 __p = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long const*,unsigned long long const*>(&__p, v13, (uint64_t)v13 + 8 * v14, v14);
  MIL::ValueInference::Tensor<unsigned long long>::Tensor(a2, &v11, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v11.n128_u64[0])
  {
    v11.n128_u64[1] = v11.n128_u64[0];
    operator delete((void *)v11.n128_u64[0]);
  }
}

void sub_20F4C514C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  __cxa_free_exception(v14);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<unsigned long long>::ToIRTensorValue(uint64_t a1, MIL::IRConstantDimension *a2)
{
  memset(__p, 0, sizeof(__p));
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(__p, *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3);
  MIL::IRTensorValueType::Make(a2, 17, (MIL::MILContext ***)__p);
}

void sub_20F4C5258(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::ValueInference::Tensor<unsigned long long>::Tensor(uint64_t a1, __n128 *a2, __n128 *a3)
{
  *(_OWORD *)(a1 + 8) = 0u;
  uint64_t v5 = a1 + 8;
  *(void *)a1 = &unk_26C25DCC8;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  int v6 = (uint64_t *)a2->n128_u64[0];
  uint64_t v7 = (uint64_t *)a2->n128_u64[1];
  if ((uint64_t *)a2->n128_u64[0] == v7)
  {
    unint64_t v10 = a3->n128_u64[0];
    unint64_t v11 = a3->n128_u64[1];
    uint64_t v8 = a3->n128_u64[0] != v11;
  }
  else
  {
    uint64_t v8 = 1;
    do
    {
      uint64_t v9 = *v6++;
      v8 *= v9;
    }
    while (v6 != v7);
    unint64_t v10 = a3->n128_u64[0];
    unint64_t v11 = a3->n128_u64[1];
  }
  if (v8 != (uint64_t)(v11 - v10) >> 3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "data size and shape dismatch.");
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  std::vector<float>::__move_assign(v5, a2);
  std::vector<float>::__move_assign(a1 + 32, a3);
  *(void *)(a1 + 56) = v8;
  return a1;
}

void sub_20F4C5390(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10)
{
  uint64_t v13 = *v11;
  if (*v11)
  {
    *(void *)(v10 + 40) = v13;
    operator delete(v13);
  }
  unint64_t v14 = *a10;
  if (*a10)
  {
    *(void *)(v10 + 16) = v14;
    operator delete(v14);
  }
  _Unwind_Resume(exception_object);
}

double MIL::ValueInference::Tensor<unsigned long long>::Tensor(uint64_t a1)
{
  *(void *)a1 = &unk_26C25DCC8;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  return result;
}

void MIL::ValueInference::Tensor<unsigned long long>::ForEach(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v13[4] = *MEMORY[0x263EF8340];
  unint64_t v6 = (uint64_t)(*(void *)(a1 + 40) - *(void *)(a1 + 32)) >> 3;
  __p.n128_u64[0] = 0;
  std::vector<unsigned long long>::vector(&v12, v6, &__p);
  __n128 __p = 0uLL;
  uint64_t v11 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3);
  uint64_t v8 = *(uint64_t **)(a1 + 32);
  uint64_t v7 = *(uint64_t **)(a1 + 40);
  uint64_t v9 = (uint64_t *)v12.n128_u64[0];
  std::__function::__value_func<unsigned long long ()(unsigned long long)>::__value_func[abi:ne180100]((uint64_t)v13, a2);
  while (v8 != v7)
    *v9++ = std::function<unsigned long long ()(unsigned long long)>::operator()((uint64_t)v13, *v8++);
  std::__function::__value_func<unsigned long long ()(unsigned long long)>::~__value_func[abi:ne180100](v13);
  MIL::ValueInference::Tensor<unsigned long long>::Tensor(a3, &__p, &v12);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v12.n128_u64[0])
  {
    v12.n128_u64[1] = v12.n128_u64[0];
    operator delete((void *)v12.n128_u64[0]);
  }
}

void sub_20F4C5510(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, char a16)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::ValueInference::Tensor<unsigned long long>::GetScalarData(void *a1)
{
  if (a1[1] != a1[2] || (uint64_t v1 = a1[4], a1[5] - v1 != 8))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Tensor is not a scalar.");
    __cxa_throw(exception, MEMORY[0x263F8C1E0], MEMORY[0x263F8C048]);
  }
  return *(void *)v1;
}

void sub_20F4C55D0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<unsigned long long>::Reshape(void *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v6 = (uint64_t *)*a2;
  uint64_t v7 = a2[1];
  uint64_t v8 = 1;
  if (v6 != (uint64_t *)v7)
  {
    uint64_t v9 = v6;
    do
    {
      uint64_t v10 = *v9++;
      v8 *= v10;
    }
    while (v9 != (uint64_t *)v7);
  }
  if (a1[7] != v8)
  {
    uint64_t v13 = a2;
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v22);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"Tensor is not able to be reshaped since the number of elements in the newShape [ ", 81);
    uint64_t v14 = *v13;
    uint64_t v15 = v13[1];
    if (*v13 != v15)
    {
      do
      {
        uint64_t v16 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)" ", 1);
        v14 += 8;
      }
      while (v14 != v15);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"] is not the same as the number of elements in the tensor shape [ ", 66);
    uint64_t v17 = a1[1];
    for (uint64_t i = a1[2]; v17 != i; v17 += 8)
    {
      uint64_t v19 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)" ", 1);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"].", 2);
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str();
    std::logic_error::logic_error(exception, &__p);
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  __n128 v22 = 0uLL;
  uint64_t v23 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v22, v6, v7, (v7 - (uint64_t)v6) >> 3);
  uint64_t v11 = (const void *)a1[4];
  uint64_t v12 = a1[5];
  memset(&__p, 0, sizeof(__p));
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&__p, v11, v12, (v12 - (uint64_t)v11) >> 3);
  MIL::ValueInference::Tensor<unsigned long long>::Tensor(a3, &v22, (__n128 *)&__p);
  if (__p.__r_.__value_.__r.__words[0])
  {
    __p.__r_.__value_.__l.__size_ = __p.__r_.__value_.__r.__words[0];
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v22.n128_u64[0])
  {
    v22.n128_u64[1] = v22.n128_u64[0];
    operator delete((void *)v22.n128_u64[0]);
  }
}

void sub_20F4C57E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((v17 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v17)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v16);
  goto LABEL_6;
}

void MIL::ValueInference::Tensor<unsigned long long>::NonZero(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v3 = *(void *)(a1 + 56);
  if (v3)
  {
    unint64_t v5 = 0;
    unint64_t v6 = (uint64_t **)(a1 + 8);
    do
    {
      if (*(void *)(*(void *)(a1 + 32) + 8 * v5))
      {
        std::vector<std::vector<unsigned long long>>::push_back[abi:ne180100](a2, (uint64_t)__p);
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
        unint64_t v3 = *(void *)(a1 + 56);
      }
      ++v5;
    }
    while (v5 < v3);
  }
}

void sub_20F4C58F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
}

void MIL::ValueInference::Tensor<unsigned long long>::SubTensor(void *a1@<X0>, uint64_t **a2@<X1>, void *a3@<X8>)
{
  unint64_t v5 = ((char *)a2[1] - (char *)*a2) >> 4;
  unint64_t v6 = a1 + 1;
  if (v5 != (uint64_t)(a1[2] - a1[1]) >> 3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "Indices does not match the rank of the tensor.");
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  std::string __p = 0;
  uint64_t v46 = 0;
  int v47 = 0;
  std::vector<unsigned long long>::reserve(&__p, v5);
  uint64_t v8 = a1[1];
  if (a1[2] != v8)
  {
    unint64_t v9 = 0;
    while (1)
    {
      unint64_t v11 = (*a2)[2 * v9];
      unint64_t v10 = (*a2)[2 * v9 + 1];
      unint64_t v12 = v10 - v11;
      if (v10 < v11) {
        break;
      }
      if (v10 > *(void *)(v8 + 8 * v9))
      {
        uint64_t v33 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(v33, "Indices end is out of the bound for the tensor dimension.");
        uint64_t v34 = (void (*)(void *))MEMORY[0x263F8C068];
        unint64_t v35 = (struct type_info *)off_26412C1E0;
        uint64_t v36 = MEMORY[0x263F8C390] + 16;
LABEL_45:
        v33->__vftable = (std::logic_error_vtbl *)v36;
        __cxa_throw(v33, v35, v34);
      }
      uint64_t v13 = v46;
      if (v46 >= v47)
      {
        uint64_t v15 = (char *)__p;
        uint64_t v16 = (v46 - (unsigned char *)__p) >> 3;
        unint64_t v17 = v16 + 1;
        if ((unint64_t)(v16 + 1) >> 61) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v18 = v47 - (unsigned char *)__p;
        if ((v47 - (unsigned char *)__p) >> 2 > v17) {
          unint64_t v17 = v18 >> 2;
        }
        if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v19 = v17;
        }
        if (v19)
        {
          unint64_t v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v47, v19);
          uint64_t v15 = (char *)__p;
          uint64_t v13 = v46;
        }
        else
        {
          unint64_t v20 = 0;
        }
        size_t v21 = &v20[8 * v16];
        *(void *)size_t v21 = v12;
        uint64_t v14 = (uint64_t)(v21 + 8);
        while (v13 != v15)
        {
          uint64_t v22 = *((void *)v13 - 1);
          v13 -= 8;
          *((void *)v21 - 1) = v22;
          v21 -= 8;
        }
        std::string __p = v21;
        uint64_t v46 = (char *)v14;
        int v47 = &v20[8 * v19];
        if (v15) {
          operator delete(v15);
        }
      }
      else
      {
        *(void *)uint64_t v46 = v12;
        uint64_t v14 = (uint64_t)(v13 + 8);
      }
      uint64_t v46 = (char *)v14;
      ++v9;
      uint64_t v8 = a1[1];
      if (v9 >= (a1[2] - v8) >> 3) {
        goto LABEL_25;
      }
    }
    uint64_t v33 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v33, "Indices end must not be smaller than the indices begin.");
    uint64_t v34 = (void (*)(void *))MEMORY[0x263F8C080];
    unint64_t v35 = (struct type_info *)off_26412C1F0;
    uint64_t v36 = MEMORY[0x263F8C3A0] + 16;
    goto LABEL_45;
  }
  uint64_t v14 = (uint64_t)v46;
LABEL_25:
  __n128 v43 = 0uLL;
  uint64_t v44 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v43, __p, v14, (v14 - (uint64_t)__p) >> 3);
  MIL::ValueInference::Tensor<unsigned long long>::Zeros(&v43, (uint64_t)a3);
  if (v43.n128_u64[0])
  {
    v43.n128_u64[1] = v43.n128_u64[0];
    operator delete((void *)v43.n128_u64[0]);
  }
  uint64_t v23 = a3[5] - a3[4];
  if (v23)
  {
    unint64_t v24 = 0;
    unint64_t v25 = v23 >> 3;
    if (v25 <= 1) {
      uint64_t v26 = 1;
    }
    else {
      uint64_t v26 = v25;
    }
    do
    {
      std::string::size_type v38 = 0;
      uint64_t v39 = 0;
      uint64_t v40 = 0;
      std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v38, v41, (uint64_t)v42, (v42 - (unsigned char *)v41) >> 3);
      uint64_t v27 = a1[2] - a1[1];
      if (v27)
      {
        unint64_t v28 = v27 >> 3;
        uint64_t v29 = *a2;
        uint64_t v30 = v38;
        if (v28 <= 1) {
          unint64_t v28 = 1;
        }
        do
        {
          uint64_t v31 = *v29;
          v29 += 2;
          *v30++ += v31;
          --v28;
        }
        while (v28);
      }
      if (v38)
      {
        uint64_t v39 = v38;
        operator delete(v38);
      }
      if (v41)
      {
        uint64_t v42 = v41;
        operator delete(v41);
      }
      ++v24;
    }
    while (v24 != v26);
  }
  if (__p)
  {
    uint64_t v46 = (char *)__p;
    operator delete(__p);
  }
}

void sub_20F4C5CAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19)
{
  __cxa_free_exception(v19);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<unsigned long long>::Zeros(__n128 *a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t v4 = (uint64_t *)a1->n128_u64[0];
  unint64_t v5 = 1;
  while (v4 != (uint64_t *)a1->n128_u64[1])
  {
    uint64_t v6 = *v4++;
    v5 *= v6;
  }
  std::vector<unsigned long long>::vector(&__p, v5);
  MIL::ValueInference::Tensor<unsigned long long>::Tensor(a2, a1, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
}

void sub_20F4C5DC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<unsigned long long>::Concat(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *a1;
  uint64_t v7 = 0;
  uint64_t v8 = a1[1] - *a1;
  if (v8)
  {
    unint64_t v9 = v8 >> 6;
    if (v9 <= 1) {
      unint64_t v9 = 1;
    }
    unint64_t v10 = (uint64_t *)(v6 + 8);
    do
    {
      uint64_t v11 = *v10;
      v10 += 8;
      v7 += *(void *)(v11 + 8 * a2);
      --v9;
    }
    while (v9);
  }
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  uint64_t v29 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v29, *(const void **)(v6 + 8), *(void *)(v6 + 16), (uint64_t)(*(void *)(v6 + 16) - *(void *)(v6 + 8)) >> 3);
  unint64_t v12 = v29;
  *((void *)v29 + a2) = v7;
  uint64_t v28 = 0;
  __n128 __p = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, v12, (uint64_t)v30, (v30 - (unsigned char *)v12) >> 3);
  MIL::ValueInference::Tensor<unsigned long long>::Zeros(&__p, a3);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  uint64_t v13 = *a1;
  uint64_t v14 = a1[1];
  if (v14 != *a1)
  {
    unint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(void *)(v13 + (v15 << 6) + 40) - *(void *)(v13 + (v15 << 6) + 32);
      if (v17)
      {
        unint64_t v18 = 0;
        if ((unint64_t)(v17 >> 3) <= 1) {
          uint64_t v19 = 1;
        }
        else {
          uint64_t v19 = v17 >> 3;
        }
        do
        {
          uint64_t v22 = 0;
          uint64_t v23 = 0;
          uint64_t v24 = 0;
          std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v22, v25, (uint64_t)v26, (v26 - (unsigned char *)v25) >> 3);
          *((void *)v22 + a2) += v16;
          unint64_t v20 = *a1 + (v15 << 6);
          uint64_t v21 = *(void *)(*(void *)(v20 + 32)
          *(void *)(*(void *)(a3 + 32)
          if (v22)
          {
            uint64_t v23 = v22;
            operator delete(v22);
          }
          if (v25)
          {
            uint64_t v26 = v25;
            operator delete(v25);
          }
          ++v18;
        }
        while (v19 != v18);
        uint64_t v13 = *a1;
        uint64_t v14 = a1[1];
      }
      v16 += *(void *)(*(void *)(v13 + (v15++ << 6) + 8) + 8 * a2);
    }
    while (v15 < (v14 - v13) >> 6);
  }
  if (v29)
  {
    uint64_t v30 = v29;
    operator delete(v29);
  }
}

void sub_20F4C5FCC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  if (a18) {
    operator delete(a18);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<unsigned long long>::BlockwiseMerge(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *(uint64_t **)a2;
  uint64_t v7 = *(void *)(a2 + 8) - *(void *)a2;
  if (v7)
  {
    unint64_t v8 = v7 >> 3;
    if (v8 <= 1) {
      unint64_t v8 = 1;
    }
    uint64_t v9 = 1;
    do
    {
      uint64_t v10 = *v6++;
      v9 *= v10;
      --v8;
    }
    while (v8);
  }
  else
  {
    uint64_t v9 = 1;
  }
  uint64_t v11 = *a1;
  if (v9 != (a1[1] - *a1) >> 6)
  {
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v49);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v49, (uint64_t)"The number of tensors (", 23);
    unint64_t v37 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v37, (uint64_t)") is not the same as the number of blocks (", 43);
    std::string::size_type v38 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v38, (uint64_t)").", 2);
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str();
    std::runtime_error::runtime_error(exception, &v48);
    __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
  }
  unint64_t v50 = 0;
  uint64_t v51 = 0;
  uint64_t v49 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v49, *(const void **)(v11 + 8), *(void *)(v11 + 16), (uint64_t)(*(void *)(v11 + 16) - *(void *)(v11 + 8)) >> 3);
  memset(&v48, 0, sizeof(v48));
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v48, v49, (uint64_t)v50, (v50 - (unsigned char *)v49) >> 3);
  unint64_t v12 = *(uint64_t **)a2;
  uint64_t v13 = (const void *)v48.__r_.__value_.__r.__words[0];
  uint64_t v14 = *(void *)(a2 + 8) - *(void *)a2;
  if (v14)
  {
    unint64_t v15 = v14 >> 3;
    if (v15 <= 1) {
      unint64_t v15 = 1;
    }
    uint64_t v16 = (void *)v48.__r_.__value_.__r.__words[0];
    do
    {
      uint64_t v17 = *v12++;
      *v16++ *= v17;
      --v15;
    }
    while (v15);
  }
  __n128 __p = 0uLL;
  uint64_t v47 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, v13, v48.__r_.__value_.__l.__size_, (uint64_t)(v48.__r_.__value_.__l.__size_ - (void)v13) >> 3);
  MIL::ValueInference::Tensor<unsigned long long>::Zeros(&__p, a3);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v9)
  {
    for (unint64_t i = 0; i != v9; ++i)
    {
      unint64_t v19 = *a1 + (i << 6);
      unint64_t v20 = *(const void **)(v19 + 8);
      size_t v21 = *(void *)(v19 + 16) - (void)v20;
      if (v21 != v50 - (unsigned char *)v49 || memcmp(v20, v49, v21))
      {
        uint64_t v36 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v36, "All tensors must have the same shape so they can be merged.");
        __cxa_throw(v36, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
      }
      uint64_t v22 = *(void *)(*a1 + (i << 6) + 40) - *(void *)(*a1 + (i << 6) + 32);
      if (v22)
      {
        unint64_t v23 = 0;
        unint64_t v24 = v22 >> 3;
        if (v24 <= 1) {
          uint64_t v25 = 1;
        }
        else {
          uint64_t v25 = v24;
        }
        do
        {
          uint64_t v40 = 0;
          uint64_t v41 = 0;
          uint64_t v42 = 0;
          std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v40, v43, (uint64_t)v44, (v44 - (unsigned char *)v43) >> 3);
          uint64_t v26 = *(void *)(a2 + 8) - *(void *)a2;
          if (v26)
          {
            unint64_t v27 = v26 >> 3;
            uint64_t v28 = (uint64_t *)v49;
            uint64_t v29 = (uint64_t *)v45[0];
            uint64_t v30 = v40;
            if (v27 <= 1) {
              unint64_t v27 = 1;
            }
            do
            {
              uint64_t v32 = *v28++;
              uint64_t v31 = v32;
              uint64_t v33 = *v29++;
              *v30++ += v33 * v31;
              --v27;
            }
            while (v27);
          }
          unint64_t v34 = *a1 + (i << 6);
          uint64_t v35 = *(void *)(*(void *)(v34 + 32)
          *(void *)(*(void *)(a3 + 32)
          if (v40)
          {
            uint64_t v41 = v40;
            operator delete(v40);
          }
          if (v43)
          {
            uint64_t v44 = v43;
            operator delete(v43);
          }
          ++v23;
        }
        while (v23 != v25);
      }
      if (v45[0])
      {
        v45[1] = v45[0];
        operator delete(v45[0]);
      }
    }
  }
  if (v48.__r_.__value_.__r.__words[0])
  {
    v48.__r_.__value_.__l.__size_ = v48.__r_.__value_.__r.__words[0];
    operator delete(v48.__r_.__value_.__l.__data_);
  }
  if (v49)
  {
    unint64_t v50 = v49;
    operator delete(v49);
  }
}

void sub_20F4C63D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28)
{
  if (a26 < 0)
  {
    operator delete(__p);
    if ((v29 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a27);
      _Unwind_Resume(a1);
    }
  }
  else if (!v29)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v28);
  goto LABEL_6;
}

uint64_t MIL::ValueInference::Tensor<unsigned long long>::Reduce@<X0>(void *a1@<X0>, unint64_t **a2@<X1>, int a3@<W2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v103 = a1[1];
  unint64_t v104 = a1 + 1;
  uint64_t v102 = a1[2];
  unint64_t v7 = (v102 - v103) >> 3;
  std::unordered_set<unsigned long long>::unordered_set<std::__wrap_iter<unsigned long long const*>>((uint64_t)v122, *a2, a2[1]);
  for (unint64_t i = v123; i; unint64_t i = (void *)*i)
  {
    if (i[2] >= v7)
    {
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&__p);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&__p, (uint64_t)"axis(", 5);
      uint64_t v91 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v91, (uint64_t)") must be smaller than the number of input dimensions(", 54);
      uint64_t v92 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v92, (uint64_t)").", 2);
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::stringbuf::str();
      std::logic_error::logic_error(exception, &v118);
      exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
      __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
    }
  }
  __n128 __p = 0;
  std::string v120 = 0;
  v121[0] = 0;
  memset(&v118, 0, sizeof(v118));
  __n128 v115 = 0;
  std::string v116 = 0;
  uint64_t v117 = 0;
  if (v102 == v103)
  {
    uint64_t v55 = 0;
    uint64_t v54 = 0;
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t v5 = (uint64_t)&v117;
    if (v7 <= 1) {
      uint64_t v10 = 1;
    }
    else {
      uint64_t v10 = (v102 - v103) >> 3;
    }
    do
    {
      v112[0] = v9;
      if (std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(v122, (unint64_t *)v112))
      {
        if (a3)
        {
          uint64_t v11 = v120;
          if ((unint64_t)v120 >= v121[0])
          {
            uint64_t v22 = (char *)__p;
            uint64_t v23 = (v120 - (unsigned char *)__p) >> 3;
            unint64_t v24 = v23 + 1;
            if ((unint64_t)(v23 + 1) >> 61) {
              std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v25 = v121[0] - (void)__p;
            if ((uint64_t)(v121[0] - (void)__p) >> 2 > v24) {
              unint64_t v24 = v25 >> 2;
            }
            if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v26 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v26 = v24;
            }
            if (v26)
            {
              unint64_t v27 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)v121, v26);
              uint64_t v22 = (char *)__p;
              uint64_t v11 = v120;
            }
            else
            {
              unint64_t v27 = 0;
            }
            uint64_t v41 = &v27[8 * v23];
            *(void *)uint64_t v41 = 1;
            unint64_t v12 = v41 + 8;
            while (v11 != v22)
            {
              uint64_t v42 = *((void *)v11 - 1);
              v11 -= 8;
              *((void *)v41 - 1) = v42;
              v41 -= 8;
            }
            __n128 __p = v41;
            std::string v120 = v12;
            v121[0] = &v27[8 * v26];
            if (v22) {
              operator delete(v22);
            }
          }
          else
          {
            *(void *)std::string v120 = 1;
            unint64_t v12 = v11 + 8;
          }
          std::string v120 = v12;
        }
        uint64_t v43 = *v104;
        uint64_t v44 = v116;
        if (v116 >= v117)
        {
          uint64_t v46 = (char *)v115;
          uint64_t v47 = (v116 - (unsigned char *)v115) >> 3;
          unint64_t v48 = v47 + 1;
          if ((unint64_t)(v47 + 1) >> 61) {
LABEL_153:
          }
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          uint64_t v49 = v117 - (unsigned char *)v115;
          if ((v117 - (unsigned char *)v115) >> 2 > v48) {
            unint64_t v48 = v49 >> 2;
          }
          if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v50 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v50 = v48;
          }
          if (v50)
          {
            uint64_t v51 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v117, v50);
            uint64_t v46 = (char *)v115;
            uint64_t v44 = v116;
          }
          else
          {
            uint64_t v51 = 0;
          }
          uint64_t v52 = &v51[8 * v47];
          *(void *)uint64_t v52 = *(void *)(v43 + 8 * (void)v9);
          uint64_t v45 = v52 + 8;
          while (v44 != v46)
          {
            uint64_t v53 = *((void *)v44 - 1);
            v44 -= 8;
            *((void *)v52 - 1) = v53;
            v52 -= 8;
          }
          __n128 v115 = v52;
          std::string v116 = v45;
          uint64_t v117 = &v51[8 * v50];
          if (v46) {
            operator delete(v46);
          }
        }
        else
        {
          *(void *)std::string v116 = *(void *)(v43 + 8 * (void)v9);
          uint64_t v45 = v44 + 8;
        }
        std::string v116 = v45;
      }
      else
      {
        uint64_t v13 = *v104;
        uint64_t v14 = v120;
        if ((unint64_t)v120 >= v121[0])
        {
          uint64_t v16 = (char *)__p;
          uint64_t v17 = (v120 - (unsigned char *)__p) >> 3;
          unint64_t v18 = v17 + 1;
          if ((unint64_t)(v17 + 1) >> 61) {
            goto LABEL_153;
          }
          uint64_t v19 = v121[0] - (void)__p;
          if ((uint64_t)(v121[0] - (void)__p) >> 2 > v18) {
            unint64_t v18 = v19 >> 2;
          }
          if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v20 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v20 = v18;
          }
          if (v20)
          {
            size_t v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)v121, v20);
            uint64_t v16 = (char *)__p;
            uint64_t v14 = v120;
          }
          else
          {
            size_t v21 = 0;
          }
          uint64_t v28 = &v21[8 * v17];
          *(void *)uint64_t v28 = *(void *)(v13 + 8 * (void)v9);
          unint64_t v15 = v28 + 8;
          while (v14 != v16)
          {
            uint64_t v29 = *((void *)v14 - 1);
            v14 -= 8;
            *((void *)v28 - 1) = v29;
            v28 -= 8;
          }
          __n128 __p = v28;
          std::string v120 = v15;
          v121[0] = &v21[8 * v20];
          if (v16) {
            operator delete(v16);
          }
        }
        else
        {
          *(void *)std::string v120 = *(void *)(v13 + 8 * (void)v9);
          unint64_t v15 = v14 + 8;
        }
        std::string v120 = v15;
        uint64_t v30 = *v104;
        std::string::size_type size = v118.__r_.__value_.__l.__size_;
        if (v118.__r_.__value_.__l.__size_ >= v118.__r_.__value_.__r.__words[2])
        {
          uint64_t v33 = (void *)v118.__r_.__value_.__r.__words[0];
          uint64_t v34 = (uint64_t)(v118.__r_.__value_.__l.__size_ - v118.__r_.__value_.__r.__words[0]) >> 3;
          unint64_t v35 = v34 + 1;
          if ((unint64_t)(v34 + 1) >> 61) {
            goto LABEL_153;
          }
          int64_t v36 = v118.__r_.__value_.__r.__words[2] - v118.__r_.__value_.__r.__words[0];
          if ((uint64_t)(v118.__r_.__value_.__r.__words[2] - v118.__r_.__value_.__r.__words[0]) >> 2 > v35) {
            unint64_t v35 = v36 >> 2;
          }
          if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v37 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v37 = v35;
          }
          if (v37)
          {
            std::string::size_type v38 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v118.__r_.__value_.__r.__words[2], v37);
            std::string::size_type size = v118.__r_.__value_.__l.__size_;
            uint64_t v33 = (void *)v118.__r_.__value_.__r.__words[0];
          }
          else
          {
            std::string::size_type v38 = 0;
          }
          uint64_t v39 = &v38[8 * v34];
          *(void *)uint64_t v39 = *(void *)(v30 + 8 * (void)v9);
          std::string::size_type v32 = (std::string::size_type)(v39 + 8);
          while ((void *)size != v33)
          {
            uint64_t v40 = *(void *)(size - 8);
            size -= 8;
            *((void *)v39 - 1) = v40;
            v39 -= 8;
          }
          v118.__r_.__value_.__r.__words[0] = (std::string::size_type)v39;
          v118.__r_.__value_.__l.__size_ = v32;
          v118.__r_.__value_.__r.__words[2] = (std::string::size_type)&v38[8 * v37];
          if (v33) {
            operator delete(v33);
          }
        }
        else
        {
          *(void *)v118.__r_.__value_.__l.__size_ = *(void *)(v30 + 8 * (void)v9);
          std::string::size_type v32 = size + 8;
        }
        v118.__r_.__value_.__l.__size_ = v32;
      }
      uint64_t v9 = (char *)v9 + 1;
    }
    while (v9 != (void *)v10);
    uint64_t v54 = __p;
    uint64_t v55 = (uint64_t)v120;
  }
  __n128 v113 = 0uLL;
  uint64_t v114 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v113, v54, v55, (v55 - (uint64_t)v54) >> 3);
  MIL::ValueInference::Tensor<unsigned long long>::Zeros(&v113, a5);
  if (v113.n128_u64[0])
  {
    v113.n128_u64[1] = v113.n128_u64[0];
    operator delete((void *)v113.n128_u64[0]);
  }
  uint64_t v56 = *(void *)(a5 + 40) - *(void *)(a5 + 32);
  if (v56)
  {
    unint64_t v57 = 0;
    unint64_t v58 = v56 >> 3;
    unint64_t v95 = v56 >> 3;
    unint64_t v96 = (uint64_t)(a1[5] - a1[4]) >> 3;
    unint64_t v59 = v96 / (v56 >> 3);
    char v60 = (uint64_t **)(a5 + 8);
    if (v7 <= 1) {
      uint64_t v61 = 1;
    }
    else {
      uint64_t v61 = (v102 - v103) >> 3;
    }
    if (v58 <= 1) {
      uint64_t v62 = 1;
    }
    else {
      uint64_t v62 = v58;
    }
    uint64_t v94 = v62;
    if (v59 <= 1) {
      unint64_t v59 = 1;
    }
    unint64_t v100 = v59;
    do
    {
      unint64_t v98 = v57;
      v5 &= 0xFFFFFFFFFFFFFF00;
      if (v95 <= v96)
      {
        unint64_t v63 = 0;
        char v64 = 1;
        do
        {
          uint64_t v105 = v5;
          uint64_t v107 = 0;
          unint64_t v108 = 0;
          uint64_t v109 = 0;
          if (v102 != v103)
          {
            unint64_t v65 = 0;
            uint64_t v66 = 0;
            uint64_t v67 = 0;
            do
            {
              unint64_t v106 = v65;
              uint64_t v68 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(v122, &v106);
              uint64_t v69 = v108;
              if (v68)
              {
                uint64_t v70 = v110;
                if (v108 >= v109)
                {
                  unint64_t v74 = (char *)v107;
                  uint64_t v75 = (v108 - (unsigned char *)v107) >> 3;
                  unint64_t v76 = v75 + 1;
                  if ((unint64_t)(v75 + 1) >> 61) {
                    goto LABEL_151;
                  }
                  uint64_t v77 = v109 - (unsigned char *)v107;
                  if ((v109 - (unsigned char *)v107) >> 2 > v76) {
                    unint64_t v76 = v77 >> 2;
                  }
                  if ((unint64_t)v77 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v78 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v78 = v76;
                  }
                  if (v78)
                  {
                    uint64_t v79 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v109, v78);
                    unint64_t v74 = (char *)v107;
                    uint64_t v69 = v108;
                  }
                  else
                  {
                    uint64_t v79 = 0;
                  }
                  uint64_t v86 = &v79[8 * v75];
                  *(void *)uint64_t v86 = v70[v66];
                  uint64_t v71 = v86 + 8;
                  while (v69 != v74)
                  {
                    uint64_t v87 = *((void *)v69 - 1);
                    v69 -= 8;
                    *((void *)v86 - 1) = v87;
                    v86 -= 8;
                  }
                  uint64_t v107 = v86;
                  unint64_t v108 = v71;
                  uint64_t v109 = &v79[8 * v78];
                  if (v74) {
                    operator delete(v74);
                  }
                }
                else
                {
                  *(void *)unint64_t v108 = *((void *)v110 + v66);
                  uint64_t v71 = v69 + 8;
                }
                unint64_t v108 = v71;
                ++v66;
              }
              else
              {
                uint64_t v72 = v112[0];
                if (v108 >= v109)
                {
                  unint64_t v80 = (char *)v107;
                  uint64_t v81 = (v108 - (unsigned char *)v107) >> 3;
                  unint64_t v82 = v81 + 1;
                  if ((unint64_t)(v81 + 1) >> 61) {
LABEL_151:
                  }
                    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
                  uint64_t v83 = v109 - (unsigned char *)v107;
                  if ((v109 - (unsigned char *)v107) >> 2 > v82) {
                    unint64_t v82 = v83 >> 2;
                  }
                  if ((unint64_t)v83 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v84 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v84 = v82;
                  }
                  if (v84)
                  {
                    uint64_t v85 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v109, v84);
                    unint64_t v80 = (char *)v107;
                    uint64_t v69 = v108;
                  }
                  else
                  {
                    uint64_t v85 = 0;
                  }
                  int v88 = &v85[8 * v81];
                  *(void *)int v88 = v72[v67];
                  uint64_t v73 = v88 + 8;
                  while (v69 != v80)
                  {
                    uint64_t v89 = *((void *)v69 - 1);
                    v69 -= 8;
                    *((void *)v88 - 1) = v89;
                    v88 -= 8;
                  }
                  uint64_t v107 = v88;
                  unint64_t v108 = v73;
                  uint64_t v109 = &v85[8 * v84];
                  if (v80) {
                    operator delete(v80);
                  }
                }
                else
                {
                  *(void *)unint64_t v108 = *((void *)v112[0] + v67);
                  uint64_t v73 = v69 + 8;
                }
                unint64_t v108 = v73;
                ++v67;
              }
              ++v65;
            }
            while (v65 != v61);
          }
          if ((v64 & 1) == 0) {
            uint64_t v5 = std::function<unsigned long long ()(unsigned long long,unsigned long long)>::operator()(a4, v105, v5);
          }
          char v60 = (uint64_t **)(a5 + 8);
          if (v107)
          {
            unint64_t v108 = (char *)v107;
            operator delete(v107);
          }
          if (v110)
          {
            __n128 v111 = v110;
            operator delete(v110);
          }
          char v64 = 0;
          ++v63;
        }
        while (v63 != v100);
      }
      if (v110)
      {
        __n128 v111 = v110;
        operator delete(v110);
      }
      if (v112[0])
      {
        v112[1] = v112[0];
        operator delete(v112[0]);
      }
      unint64_t v57 = v98 + 1;
    }
    while (v98 + 1 != v94);
  }
  if (v115)
  {
    std::string v116 = (char *)v115;
    operator delete(v115);
  }
  if (v118.__r_.__value_.__r.__words[0])
  {
    v118.__r_.__value_.__l.__size_ = v118.__r_.__value_.__r.__words[0];
    operator delete(v118.__r_.__value_.__l.__data_);
  }
  if (__p)
  {
    std::string v120 = (char *)__p;
    operator delete(__p);
  }
  return std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table((uint64_t)v122);
}

void sub_20F4C6D04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37,uint64_t a38,void *__p,uint64_t a40,int a41,__int16 a42,char a43,char a44,void *a45,uint64_t a46)
{
  if (a44 < 0)
  {
    operator delete(__p);
    if ((v47 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a45);
      std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table(v48 - 128);
      _Unwind_Resume(a1);
    }
  }
  else if (!v47)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v46);
  goto LABEL_6;
}

uint64_t std::function<unsigned long long ()(unsigned long long,unsigned long long)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a3;
  uint64_t v6 = a2;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)v3 + 48))(v3, &v6, &v5);
}

void MIL::ValueInference::Tensor<unsigned long long>::Zeros(MIL *a1@<X0>, const MIL::IRTensorValueType *a2@<X1>, uint64_t a3@<X8>)
{
  MIL::GetTensorShapeWithDimensionsAllKnown(a1, a2, (uint64_t)v6);
  *(_OWORD *)__n128 __p = *(_OWORD *)v6;
  uint64_t v5 = v7;
  v6[1] = 0;
  uint64_t v7 = 0;
  v6[0] = 0;
  MIL::ValueInference::Tensor<unsigned long long>::Zeros((__n128 *)__p, a3);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v6[0])
  {
    v6[1] = v6[0];
    operator delete(v6[0]);
  }
}

void sub_20F4C6EF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  if (__p) {
    operator delete(__p);
  }
  if (a13) {
    operator delete(a13);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<signed char>::FromIRTensorValue(void *a1@<X0>, uint64_t a2@<X8>)
{
  MIL::IRTensorValue::TryGetDataView<signed char>(&v12, *a1);
  if (!(_BYTE)v12)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Failed to get data view.");
    uint64_t v7 = (struct type_info *)MEMORY[0x263F8C1F0];
    unint64_t v8 = (void (*)(void *))MEMORY[0x263F8C070];
    goto LABEL_10;
  }
  unint64_t v4 = (MIL *)(*(uint64_t (**)(void))(*(void *)*a1 + 32))();
  if ((*(unsigned int (**)(MIL *))(*(void *)v4 + 88))(v4) == 3)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100]((std::logic_error *)exception, "It is not supported to convert a tensor of string dtype.");
    uint64_t v7 = (struct type_info *)off_26412C1F0;
    unint64_t v8 = (void (*)(void *))MEMORY[0x263F8C080];
LABEL_10:
    __cxa_throw(exception, v7, v8);
  }
  MIL::GetTensorShapeWithDimensionsAllKnown(v4, v5, (uint64_t)&v11);
  uint64_t v10 = 0;
  __n128 __p = 0uLL;
  std::vector<signed char>::__init_with_size[abi:ne180100]<signed char const*,signed char const*>(&__p, v13, (uint64_t)v13 + v14, v14);
  MIL::ValueInference::Tensor<signed char>::Tensor(a2, &v11, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v11.n128_u64[0])
  {
    v11.n128_u64[1] = v11.n128_u64[0];
    operator delete((void *)v11.n128_u64[0]);
  }
}

void sub_20F4C7070(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  __cxa_free_exception(v14);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<signed char>::ToIRTensorValue(uint64_t a1, MIL::IRConstantDimension *a2)
{
  memset(__p, 0, sizeof(__p));
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(__p, *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3);
  MIL::IRTensorValueType::Make(a2, 9, (MIL::MILContext ***)__p);
}

void sub_20F4C7174(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::ValueInference::Tensor<signed char>::Tensor(uint64_t a1, __n128 *a2, __n128 *a3)
{
  *(_OWORD *)(a1 + 8) = 0u;
  uint64_t v5 = a1 + 8;
  *(void *)a1 = &unk_26C259EA8;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  uint64_t v6 = (uint64_t *)a2->n128_u64[0];
  uint64_t v7 = (uint64_t *)a2->n128_u64[1];
  if ((uint64_t *)a2->n128_u64[0] == v7)
  {
    unint64_t v10 = a3->n128_u64[0];
    unint64_t v11 = a3->n128_u64[1];
    uint64_t v8 = a3->n128_u64[0] != v11;
  }
  else
  {
    uint64_t v8 = 1;
    do
    {
      uint64_t v9 = *v6++;
      v8 *= v9;
    }
    while (v6 != v7);
    unint64_t v10 = a3->n128_u64[0];
    unint64_t v11 = a3->n128_u64[1];
  }
  if (v8 != v11 - v10)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "data size and shape dismatch.");
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  std::vector<float>::__move_assign(v5, a2);
  std::vector<float>::__move_assign(a1 + 32, a3);
  *(void *)(a1 + 56) = v8;
  return a1;
}

void sub_20F4C72AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10)
{
  uint64_t v13 = *v11;
  if (*v11)
  {
    *(void *)(v10 + 40) = v13;
    operator delete(v13);
  }
  size_t v14 = *a10;
  if (*a10)
  {
    *(void *)(v10 + 16) = v14;
    operator delete(v14);
  }
  _Unwind_Resume(exception_object);
}

double MIL::ValueInference::Tensor<signed char>::Tensor(uint64_t a1)
{
  *(void *)a1 = &unk_26C259EA8;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  return result;
}

void MIL::ValueInference::Tensor<signed char>::ForEach(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v13[4] = *MEMORY[0x263EF8340];
  size_t v6 = *(void *)(a1 + 40) - *(void *)(a1 + 32);
  __p.n128_u8[0] = 0;
  std::vector<signed char>::vector(&v12, v6, &__p);
  __n128 __p = 0uLL;
  uint64_t v11 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3);
  uint64_t v8 = *(char **)(a1 + 32);
  uint64_t v7 = *(char **)(a1 + 40);
  uint64_t v9 = (unsigned char *)v12.n128_u64[0];
  std::__function::__value_func<signed char ()(signed char)>::__value_func[abi:ne180100]((uint64_t)v13, a2);
  while (v8 != v7)
    *v9++ = std::function<signed char ()(signed char)>::operator()((uint64_t)v13, *v8++);
  std::__function::__value_func<signed char ()(signed char)>::~__value_func[abi:ne180100](v13);
  MIL::ValueInference::Tensor<signed char>::Tensor(a3, &__p, &v12);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v12.n128_u64[0])
  {
    v12.n128_u64[1] = v12.n128_u64[0];
    operator delete((void *)v12.n128_u64[0]);
  }
}

void sub_20F4C7428(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, char a16)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::ValueInference::Tensor<signed char>::GetScalarData(void *a1)
{
  if (a1[1] != a1[2] || (uint64_t v1 = (char *)a1[4], a1[5] - (void)v1 != 1))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Tensor is not a scalar.");
    __cxa_throw(exception, MEMORY[0x263F8C1E0], MEMORY[0x263F8C048]);
  }
  return *v1;
}

void sub_20F4C74E8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<signed char>::Reshape(void *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  size_t v6 = (uint64_t *)*a2;
  uint64_t v7 = a2[1];
  uint64_t v8 = 1;
  if (v6 != (uint64_t *)v7)
  {
    uint64_t v9 = v6;
    do
    {
      uint64_t v10 = *v9++;
      v8 *= v10;
    }
    while (v9 != (uint64_t *)v7);
  }
  if (a1[7] != v8)
  {
    uint64_t v13 = a2;
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v22);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"Tensor is not able to be reshaped since the number of elements in the newShape [ ", 81);
    uint64_t v14 = *v13;
    uint64_t v15 = v13[1];
    if (*v13 != v15)
    {
      do
      {
        uint64_t v16 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)" ", 1);
        v14 += 8;
      }
      while (v14 != v15);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"] is not the same as the number of elements in the tensor shape [ ", 66);
    uint64_t v17 = a1[1];
    for (uint64_t i = a1[2]; v17 != i; v17 += 8)
    {
      uint64_t v19 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)" ", 1);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"].", 2);
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str();
    std::logic_error::logic_error(exception, &__p);
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  __n128 v22 = 0uLL;
  uint64_t v23 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v22, v6, v7, (v7 - (uint64_t)v6) >> 3);
  uint64_t v11 = (const void *)a1[4];
  uint64_t v12 = a1[5];
  memset(&__p, 0, sizeof(__p));
  std::vector<signed char>::__init_with_size[abi:ne180100]<std::__wrap_iter<signed char const*>,std::__wrap_iter<signed char const*>>(&__p, v11, v12, v12 - (void)v11);
  MIL::ValueInference::Tensor<signed char>::Tensor(a3, &v22, (__n128 *)&__p);
  if (__p.__r_.__value_.__r.__words[0])
  {
    __p.__r_.__value_.__l.__size_ = __p.__r_.__value_.__r.__words[0];
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v22.n128_u64[0])
  {
    v22.n128_u64[1] = v22.n128_u64[0];
    operator delete((void *)v22.n128_u64[0]);
  }
}

void sub_20F4C76F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((v17 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v17)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v16);
  goto LABEL_6;
}

void MIL::ValueInference::Tensor<signed char>::NonZero(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v3 = *(void *)(a1 + 56);
  if (v3)
  {
    unint64_t v5 = 0;
    size_t v6 = (uint64_t **)(a1 + 8);
    do
    {
      if (*(unsigned char *)(*(void *)(a1 + 32) + v5))
      {
        std::vector<std::vector<unsigned long long>>::push_back[abi:ne180100](a2, (uint64_t)__p);
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
        unint64_t v3 = *(void *)(a1 + 56);
      }
      ++v5;
    }
    while (v5 < v3);
  }
}

void sub_20F4C780C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
}

void MIL::ValueInference::Tensor<signed char>::SubTensor(void *a1@<X0>, uint64_t **a2@<X1>, void *a3@<X8>)
{
  unint64_t v5 = ((char *)a2[1] - (char *)*a2) >> 4;
  size_t v6 = a1 + 1;
  if (v5 != (uint64_t)(a1[2] - a1[1]) >> 3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "Indices does not match the rank of the tensor.");
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  std::string __p = 0;
  uint64_t v45 = 0;
  uint64_t v46 = 0;
  std::vector<unsigned long long>::reserve(&__p, v5);
  uint64_t v8 = a1[1];
  if (a1[2] != v8)
  {
    unint64_t v9 = 0;
    while (1)
    {
      unint64_t v11 = (*a2)[2 * v9];
      unint64_t v10 = (*a2)[2 * v9 + 1];
      unint64_t v12 = v10 - v11;
      if (v10 < v11) {
        break;
      }
      if (v10 > *(void *)(v8 + 8 * v9))
      {
        std::string::size_type v32 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(v32, "Indices end is out of the bound for the tensor dimension.");
        uint64_t v33 = (void (*)(void *))MEMORY[0x263F8C068];
        uint64_t v34 = (struct type_info *)off_26412C1E0;
        uint64_t v35 = MEMORY[0x263F8C390] + 16;
LABEL_45:
        v32->__vftable = (std::logic_error_vtbl *)v35;
        __cxa_throw(v32, v34, v33);
      }
      uint64_t v13 = v45;
      if (v45 >= v46)
      {
        uint64_t v15 = (char *)__p;
        uint64_t v16 = (v45 - (unsigned char *)__p) >> 3;
        unint64_t v17 = v16 + 1;
        if ((unint64_t)(v16 + 1) >> 61) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v18 = v46 - (unsigned char *)__p;
        if ((v46 - (unsigned char *)__p) >> 2 > v17) {
          unint64_t v17 = v18 >> 2;
        }
        if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v19 = v17;
        }
        if (v19)
        {
          unint64_t v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v46, v19);
          uint64_t v15 = (char *)__p;
          uint64_t v13 = v45;
        }
        else
        {
          unint64_t v20 = 0;
        }
        size_t v21 = &v20[8 * v16];
        *(void *)size_t v21 = v12;
        uint64_t v14 = (uint64_t)(v21 + 8);
        while (v13 != v15)
        {
          uint64_t v22 = *((void *)v13 - 1);
          v13 -= 8;
          *((void *)v21 - 1) = v22;
          v21 -= 8;
        }
        std::string __p = v21;
        uint64_t v45 = (char *)v14;
        uint64_t v46 = &v20[8 * v19];
        if (v15) {
          operator delete(v15);
        }
      }
      else
      {
        *(void *)uint64_t v45 = v12;
        uint64_t v14 = (uint64_t)(v13 + 8);
      }
      uint64_t v45 = (char *)v14;
      ++v9;
      uint64_t v8 = a1[1];
      if (v9 >= (a1[2] - v8) >> 3) {
        goto LABEL_25;
      }
    }
    std::string::size_type v32 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v32, "Indices end must not be smaller than the indices begin.");
    uint64_t v33 = (void (*)(void *))MEMORY[0x263F8C080];
    uint64_t v34 = (struct type_info *)off_26412C1F0;
    uint64_t v35 = MEMORY[0x263F8C3A0] + 16;
    goto LABEL_45;
  }
  uint64_t v14 = (uint64_t)v45;
LABEL_25:
  __n128 v42 = 0uLL;
  uint64_t v43 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v42, __p, v14, (v14 - (uint64_t)__p) >> 3);
  MIL::ValueInference::Tensor<signed char>::Zeros(&v42, (uint64_t)a3);
  if (v42.n128_u64[0])
  {
    v42.n128_u64[1] = v42.n128_u64[0];
    operator delete((void *)v42.n128_u64[0]);
  }
  unint64_t v23 = a3[5] - a3[4];
  if (v23)
  {
    unint64_t v24 = 0;
    if (v23 <= 1) {
      uint64_t v25 = 1;
    }
    else {
      uint64_t v25 = a3[5] - a3[4];
    }
    do
    {
      unint64_t v37 = 0;
      std::string::size_type v38 = 0;
      uint64_t v39 = 0;
      std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v37, v40, (uint64_t)v41, (v41 - (unsigned char *)v40) >> 3);
      uint64_t v26 = a1[2] - a1[1];
      if (v26)
      {
        unint64_t v27 = v26 >> 3;
        uint64_t v28 = *a2;
        uint64_t v29 = v37;
        if (v27 <= 1) {
          unint64_t v27 = 1;
        }
        do
        {
          uint64_t v30 = *v28;
          v28 += 2;
          *v29++ += v30;
          --v27;
        }
        while (v27);
      }
      if (v37)
      {
        std::string::size_type v38 = v37;
        operator delete(v37);
      }
      if (v40)
      {
        uint64_t v41 = v40;
        operator delete(v40);
      }
      ++v24;
    }
    while (v24 != v25);
  }
  if (__p)
  {
    uint64_t v45 = (char *)__p;
    operator delete(__p);
  }
}

void sub_20F4C7BBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19)
{
  __cxa_free_exception(v19);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<signed char>::Zeros(__n128 *a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t v4 = (uint64_t *)a1->n128_u64[0];
  size_t v5 = 1;
  while (v4 != (uint64_t *)a1->n128_u64[1])
  {
    uint64_t v6 = *v4++;
    v5 *= v6;
  }
  std::vector<signed char>::vector(&__p, v5);
  MIL::ValueInference::Tensor<signed char>::Tensor(a2, a1, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
}

void sub_20F4C7CD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<signed char>::Concat(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *a1;
  uint64_t v7 = 0;
  uint64_t v8 = a1[1] - *a1;
  if (v8)
  {
    unint64_t v9 = v8 >> 6;
    if (v9 <= 1) {
      unint64_t v9 = 1;
    }
    unint64_t v10 = (uint64_t *)(v6 + 8);
    do
    {
      uint64_t v11 = *v10;
      v10 += 8;
      v7 += *(void *)(v11 + 8 * a2);
      --v9;
    }
    while (v9);
  }
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  uint64_t v28 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v28, *(const void **)(v6 + 8), *(void *)(v6 + 16), (uint64_t)(*(void *)(v6 + 16) - *(void *)(v6 + 8)) >> 3);
  unint64_t v12 = v28;
  *((void *)v28 + a2) = v7;
  uint64_t v27 = 0;
  __n128 __p = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, v12, (uint64_t)v29, (v29 - (unsigned char *)v12) >> 3);
  MIL::ValueInference::Tensor<signed char>::Zeros(&__p, a3);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  uint64_t v13 = *a1;
  uint64_t v14 = a1[1];
  if (v14 != *a1)
  {
    unint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      unint64_t v17 = *(void *)(v13 + (v15 << 6) + 40) - *(void *)(v13 + (v15 << 6) + 32);
      if (v17)
      {
        unint64_t v18 = 0;
        if (v17 <= 1) {
          uint64_t v19 = 1;
        }
        else {
          uint64_t v19 = *(void *)(v13 + (v15 << 6) + 40) - *(void *)(v13 + (v15 << 6) + 32);
        }
        do
        {
          size_t v21 = 0;
          uint64_t v22 = 0;
          uint64_t v23 = 0;
          std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v21, v24, (uint64_t)v25, (v25 - (unsigned char *)v24) >> 3);
          *((void *)v21 + a2) += v16;
          unint64_t v20 = *a1 + (v15 << 6);
          LOBYTE(v20) = *(unsigned char *)(*(void *)(v20 + 32)
          if (v21)
          {
            uint64_t v22 = v21;
            operator delete(v21);
          }
          if (v24)
          {
            uint64_t v25 = v24;
            operator delete(v24);
          }
          ++v18;
        }
        while (v19 != v18);
        uint64_t v13 = *a1;
        uint64_t v14 = a1[1];
      }
      v16 += *(void *)(*(void *)(v13 + (v15++ << 6) + 8) + 8 * a2);
    }
    while (v15 < (v14 - v13) >> 6);
  }
  if (v28)
  {
    uint64_t v29 = v28;
    operator delete(v28);
  }
}

void sub_20F4C7ED4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  if (a18) {
    operator delete(a18);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<signed char>::BlockwiseMerge(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *(uint64_t **)a2;
  uint64_t v7 = *(void *)(a2 + 8) - *(void *)a2;
  if (v7)
  {
    unint64_t v8 = v7 >> 3;
    if (v8 <= 1) {
      unint64_t v8 = 1;
    }
    uint64_t v9 = 1;
    do
    {
      uint64_t v10 = *v6++;
      v9 *= v10;
      --v8;
    }
    while (v8);
  }
  else
  {
    uint64_t v9 = 1;
  }
  uint64_t v11 = *a1;
  if (v9 != (a1[1] - *a1) >> 6)
  {
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v47);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v47, (uint64_t)"The number of tensors (", 23);
    uint64_t v35 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v35, (uint64_t)") is not the same as the number of blocks (", 43);
    int64_t v36 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v36, (uint64_t)").", 2);
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str();
    std::runtime_error::runtime_error(exception, &v46);
    __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
  }
  uint64_t v48 = 0;
  uint64_t v49 = 0;
  int v47 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v47, *(const void **)(v11 + 8), *(void *)(v11 + 16), (uint64_t)(*(void *)(v11 + 16) - *(void *)(v11 + 8)) >> 3);
  memset(&v46, 0, sizeof(v46));
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v46, v47, (uint64_t)v48, (v48 - (unsigned char *)v47) >> 3);
  unint64_t v12 = *(uint64_t **)a2;
  uint64_t v13 = (const void *)v46.__r_.__value_.__r.__words[0];
  uint64_t v14 = *(void *)(a2 + 8) - *(void *)a2;
  if (v14)
  {
    unint64_t v15 = v14 >> 3;
    if (v15 <= 1) {
      unint64_t v15 = 1;
    }
    uint64_t v16 = (void *)v46.__r_.__value_.__r.__words[0];
    do
    {
      uint64_t v17 = *v12++;
      *v16++ *= v17;
      --v15;
    }
    while (v15);
  }
  __n128 __p = 0uLL;
  uint64_t v45 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, v13, v46.__r_.__value_.__l.__size_, (uint64_t)(v46.__r_.__value_.__l.__size_ - (void)v13) >> 3);
  MIL::ValueInference::Tensor<signed char>::Zeros(&__p, a3);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v9)
  {
    for (unint64_t i = 0; i != v9; ++i)
    {
      unint64_t v19 = *a1 + (i << 6);
      unint64_t v20 = *(const void **)(v19 + 8);
      size_t v21 = *(void *)(v19 + 16) - (void)v20;
      if (v21 != v48 - (unsigned char *)v47 || memcmp(v20, v47, v21))
      {
        uint64_t v34 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v34, "All tensors must have the same shape so they can be merged.");
        __cxa_throw(v34, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
      }
      unint64_t v22 = *(void *)(*a1 + (i << 6) + 40) - *(void *)(*a1 + (i << 6) + 32);
      if (v22)
      {
        unint64_t v23 = 0;
        if (v22 <= 1) {
          uint64_t v24 = 1;
        }
        else {
          uint64_t v24 = *(void *)(*a1 + (i << 6) + 40) - *(void *)(*a1 + (i << 6) + 32);
        }
        do
        {
          std::string::size_type v38 = 0;
          uint64_t v39 = 0;
          uint64_t v40 = 0;
          std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v38, v41, (uint64_t)v42, (v42 - (unsigned char *)v41) >> 3);
          uint64_t v25 = *(void *)(a2 + 8) - *(void *)a2;
          if (v25)
          {
            unint64_t v26 = v25 >> 3;
            uint64_t v27 = (uint64_t *)v47;
            uint64_t v28 = (uint64_t *)v43[0];
            uint64_t v29 = v38;
            if (v26 <= 1) {
              unint64_t v26 = 1;
            }
            do
            {
              uint64_t v31 = *v27++;
              uint64_t v30 = v31;
              uint64_t v32 = *v28++;
              *v29++ += v32 * v30;
              --v26;
            }
            while (v26);
          }
          unint64_t v33 = *a1 + (i << 6);
          LOBYTE(v33) = *(unsigned char *)(*(void *)(v33 + 32)
          if (v38)
          {
            uint64_t v39 = v38;
            operator delete(v38);
          }
          if (v41)
          {
            __n128 v42 = v41;
            operator delete(v41);
          }
          ++v23;
        }
        while (v23 != v24);
      }
      if (v43[0])
      {
        v43[1] = v43[0];
        operator delete(v43[0]);
      }
    }
  }
  if (v46.__r_.__value_.__r.__words[0])
  {
    v46.__r_.__value_.__l.__size_ = v46.__r_.__value_.__r.__words[0];
    operator delete(v46.__r_.__value_.__l.__data_);
  }
  if (v47)
  {
    uint64_t v48 = v47;
    operator delete(v47);
  }
}

void sub_20F4C82D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28)
{
  if (a26 < 0)
  {
    operator delete(__p);
    if ((v29 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a27);
      _Unwind_Resume(a1);
    }
  }
  else if (!v29)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v28);
  goto LABEL_6;
}

uint64_t MIL::ValueInference::Tensor<signed char>::Reduce@<X0>(void *a1@<X0>, unint64_t **a2@<X1>, int a3@<W2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v102 = a1[1];
  uint64_t v103 = a1 + 1;
  uint64_t v101 = a1[2];
  unint64_t v6 = (v101 - v102) >> 3;
  std::unordered_set<unsigned long long>::unordered_set<std::__wrap_iter<unsigned long long const*>>((uint64_t)v121, *a2, a2[1]);
  for (unint64_t i = v122; i; unint64_t i = (void *)*i)
  {
    if (i[2] >= v6)
    {
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&__p);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&__p, (uint64_t)"axis(", 5);
      uint64_t v89 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v89, (uint64_t)") must be smaller than the number of input dimensions(", 54);
      unint64_t v90 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v90, (uint64_t)").", 2);
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::stringbuf::str();
      std::logic_error::logic_error(exception, &v117);
      exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
      __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
    }
  }
  __n128 __p = 0;
  unint64_t v119 = 0;
  v120[0] = 0;
  memset(&v117, 0, sizeof(v117));
  uint64_t v114 = 0;
  __n128 v115 = 0;
  std::string v116 = 0;
  if (v101 == v102)
  {
    uint64_t v54 = 0;
    uint64_t v53 = 0;
  }
  else
  {
    unint64_t v8 = 0;
    if (v6 <= 1) {
      uint64_t v9 = 1;
    }
    else {
      uint64_t v9 = (v101 - v102) >> 3;
    }
    do
    {
      v111[0] = v8;
      if (std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(v121, (unint64_t *)v111))
      {
        if (a3)
        {
          uint64_t v10 = v119;
          if ((unint64_t)v119 >= v120[0])
          {
            size_t v21 = (char *)__p;
            uint64_t v22 = (v119 - (unsigned char *)__p) >> 3;
            unint64_t v23 = v22 + 1;
            if ((unint64_t)(v22 + 1) >> 61) {
              std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v24 = v120[0] - (void)__p;
            if ((uint64_t)(v120[0] - (void)__p) >> 2 > v23) {
              unint64_t v23 = v24 >> 2;
            }
            if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v25 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v25 = v23;
            }
            if (v25)
            {
              unint64_t v26 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)v120, v25);
              size_t v21 = (char *)__p;
              uint64_t v10 = v119;
            }
            else
            {
              unint64_t v26 = 0;
            }
            uint64_t v40 = &v26[8 * v22];
            *(void *)uint64_t v40 = 1;
            uint64_t v11 = v40 + 8;
            while (v10 != v21)
            {
              uint64_t v41 = *((void *)v10 - 1);
              v10 -= 8;
              *((void *)v40 - 1) = v41;
              v40 -= 8;
            }
            __n128 __p = v40;
            unint64_t v119 = v11;
            v120[0] = &v26[8 * v25];
            if (v21) {
              operator delete(v21);
            }
          }
          else
          {
            *(void *)unint64_t v119 = 1;
            uint64_t v11 = v10 + 8;
          }
          unint64_t v119 = v11;
        }
        uint64_t v42 = *v103;
        uint64_t v43 = v115;
        if (v115 >= v116)
        {
          uint64_t v45 = (char *)v114;
          uint64_t v46 = (v115 - (unsigned char *)v114) >> 3;
          unint64_t v47 = v46 + 1;
          if ((unint64_t)(v46 + 1) >> 61) {
LABEL_154:
          }
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          uint64_t v48 = v116 - (unsigned char *)v114;
          if ((v116 - (unsigned char *)v114) >> 2 > v47) {
            unint64_t v47 = v48 >> 2;
          }
          if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v49 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v49 = v47;
          }
          if (v49)
          {
            unint64_t v50 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v116, v49);
            uint64_t v45 = (char *)v114;
            uint64_t v43 = v115;
          }
          else
          {
            unint64_t v50 = 0;
          }
          uint64_t v51 = &v50[8 * v46];
          *(void *)uint64_t v51 = *(void *)(v42 + 8 * (void)v8);
          uint64_t v44 = v51 + 8;
          while (v43 != v45)
          {
            uint64_t v52 = *((void *)v43 - 1);
            v43 -= 8;
            *((void *)v51 - 1) = v52;
            v51 -= 8;
          }
          uint64_t v114 = v51;
          __n128 v115 = v44;
          std::string v116 = &v50[8 * v49];
          if (v45) {
            operator delete(v45);
          }
        }
        else
        {
          *(void *)__n128 v115 = *(void *)(v42 + 8 * (void)v8);
          uint64_t v44 = v43 + 8;
        }
        __n128 v115 = v44;
      }
      else
      {
        uint64_t v12 = *v103;
        uint64_t v13 = v119;
        if ((unint64_t)v119 >= v120[0])
        {
          unint64_t v15 = (char *)__p;
          uint64_t v16 = (v119 - (unsigned char *)__p) >> 3;
          unint64_t v17 = v16 + 1;
          if ((unint64_t)(v16 + 1) >> 61) {
            goto LABEL_154;
          }
          uint64_t v18 = v120[0] - (void)__p;
          if ((uint64_t)(v120[0] - (void)__p) >> 2 > v17) {
            unint64_t v17 = v18 >> 2;
          }
          if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v19 = v17;
          }
          if (v19)
          {
            unint64_t v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)v120, v19);
            unint64_t v15 = (char *)__p;
            uint64_t v13 = v119;
          }
          else
          {
            unint64_t v20 = 0;
          }
          uint64_t v27 = &v20[8 * v16];
          *(void *)uint64_t v27 = *(void *)(v12 + 8 * (void)v8);
          uint64_t v14 = v27 + 8;
          while (v13 != v15)
          {
            uint64_t v28 = *((void *)v13 - 1);
            v13 -= 8;
            *((void *)v27 - 1) = v28;
            v27 -= 8;
          }
          __n128 __p = v27;
          unint64_t v119 = v14;
          v120[0] = &v20[8 * v19];
          if (v15) {
            operator delete(v15);
          }
        }
        else
        {
          *(void *)unint64_t v119 = *(void *)(v12 + 8 * (void)v8);
          uint64_t v14 = v13 + 8;
        }
        unint64_t v119 = v14;
        uint64_t v29 = *v103;
        std::string::size_type size = v117.__r_.__value_.__l.__size_;
        if (v117.__r_.__value_.__l.__size_ >= v117.__r_.__value_.__r.__words[2])
        {
          uint64_t v32 = (void *)v117.__r_.__value_.__r.__words[0];
          uint64_t v33 = (uint64_t)(v117.__r_.__value_.__l.__size_ - v117.__r_.__value_.__r.__words[0]) >> 3;
          unint64_t v34 = v33 + 1;
          if ((unint64_t)(v33 + 1) >> 61) {
            goto LABEL_154;
          }
          int64_t v35 = v117.__r_.__value_.__r.__words[2] - v117.__r_.__value_.__r.__words[0];
          if ((uint64_t)(v117.__r_.__value_.__r.__words[2] - v117.__r_.__value_.__r.__words[0]) >> 2 > v34) {
            unint64_t v34 = v35 >> 2;
          }
          if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v36 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v36 = v34;
          }
          if (v36)
          {
            unint64_t v37 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v117.__r_.__value_.__r.__words[2], v36);
            std::string::size_type size = v117.__r_.__value_.__l.__size_;
            uint64_t v32 = (void *)v117.__r_.__value_.__r.__words[0];
          }
          else
          {
            unint64_t v37 = 0;
          }
          std::string::size_type v38 = &v37[8 * v33];
          *(void *)std::string::size_type v38 = *(void *)(v29 + 8 * (void)v8);
          std::string::size_type v31 = (std::string::size_type)(v38 + 8);
          while ((void *)size != v32)
          {
            uint64_t v39 = *(void *)(size - 8);
            size -= 8;
            *((void *)v38 - 1) = v39;
            v38 -= 8;
          }
          v117.__r_.__value_.__r.__words[0] = (std::string::size_type)v38;
          v117.__r_.__value_.__l.__size_ = v31;
          v117.__r_.__value_.__r.__words[2] = (std::string::size_type)&v37[8 * v36];
          if (v32) {
            operator delete(v32);
          }
        }
        else
        {
          *(void *)v117.__r_.__value_.__l.__size_ = *(void *)(v29 + 8 * (void)v8);
          std::string::size_type v31 = size + 8;
        }
        v117.__r_.__value_.__l.__size_ = v31;
      }
      unint64_t v8 = (char *)v8 + 1;
    }
    while (v8 != (void *)v9);
    uint64_t v53 = __p;
    uint64_t v54 = (uint64_t)v119;
  }
  __n128 v112 = 0uLL;
  uint64_t v113 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v112, v53, v54, (v54 - (uint64_t)v53) >> 3);
  MIL::ValueInference::Tensor<signed char>::Zeros(&v112, a5);
  if (v112.n128_u64[0])
  {
    v112.n128_u64[1] = v112.n128_u64[0];
    operator delete((void *)v112.n128_u64[0]);
  }
  unint64_t v95 = *(void *)(a5 + 40) - *(void *)(a5 + 32);
  if (v95)
  {
    unint64_t v55 = 0;
    unint64_t v94 = a1[5] - a1[4];
    unint64_t v56 = v94 / v95;
    if (v6 <= 1) {
      uint64_t v57 = 1;
    }
    else {
      uint64_t v57 = (v101 - v102) >> 3;
    }
    if (v95 <= 1) {
      uint64_t v58 = 1;
    }
    else {
      uint64_t v58 = *(void *)(a5 + 40) - *(void *)(a5 + 32);
    }
    uint64_t v92 = v58;
    unint64_t v93 = (uint64_t **)(a5 + 8);
    if (v56 <= 1) {
      unint64_t v56 = 1;
    }
    unint64_t v99 = v56;
    do
    {
      unint64_t v97 = v55;
      if (v95 <= v94)
      {
        unint64_t v60 = 0;
        char v61 = 0;
        char v62 = 1;
        do
        {
          char v104 = v61;
          unint64_t v106 = 0;
          uint64_t v107 = 0;
          unint64_t v108 = 0;
          if (v101 != v102)
          {
            unint64_t v63 = 0;
            uint64_t v64 = 0;
            uint64_t v65 = 0;
            do
            {
              unint64_t v105 = v63;
              uint64_t v66 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(v121, &v105);
              uint64_t v67 = v107;
              if (v66)
              {
                uint64_t v68 = v109;
                if (v107 >= v108)
                {
                  uint64_t v72 = (char *)v106;
                  uint64_t v73 = (v107 - (unsigned char *)v106) >> 3;
                  unint64_t v74 = v73 + 1;
                  if ((unint64_t)(v73 + 1) >> 61) {
                    goto LABEL_152;
                  }
                  uint64_t v75 = v108 - (unsigned char *)v106;
                  if ((v108 - (unsigned char *)v106) >> 2 > v74) {
                    unint64_t v74 = v75 >> 2;
                  }
                  if ((unint64_t)v75 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v76 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v76 = v74;
                  }
                  if (v76)
                  {
                    uint64_t v77 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v108, v76);
                    uint64_t v72 = (char *)v106;
                    uint64_t v67 = v107;
                  }
                  else
                  {
                    uint64_t v77 = 0;
                  }
                  unint64_t v84 = &v77[8 * v73];
                  *(void *)unint64_t v84 = v68[v64];
                  uint64_t v69 = v84 + 8;
                  while (v67 != v72)
                  {
                    uint64_t v85 = *((void *)v67 - 1);
                    v67 -= 8;
                    *((void *)v84 - 1) = v85;
                    v84 -= 8;
                  }
                  unint64_t v106 = v84;
                  uint64_t v107 = v69;
                  unint64_t v108 = &v77[8 * v76];
                  if (v72) {
                    operator delete(v72);
                  }
                }
                else
                {
                  *(void *)uint64_t v107 = *((void *)v109 + v64);
                  uint64_t v69 = v67 + 8;
                }
                uint64_t v107 = v69;
                ++v64;
              }
              else
              {
                uint64_t v70 = v111[0];
                if (v107 >= v108)
                {
                  unint64_t v78 = (char *)v106;
                  uint64_t v79 = (v107 - (unsigned char *)v106) >> 3;
                  unint64_t v80 = v79 + 1;
                  if ((unint64_t)(v79 + 1) >> 61) {
LABEL_152:
                  }
                    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
                  uint64_t v81 = v108 - (unsigned char *)v106;
                  if ((v108 - (unsigned char *)v106) >> 2 > v80) {
                    unint64_t v80 = v81 >> 2;
                  }
                  if ((unint64_t)v81 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v82 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v82 = v80;
                  }
                  if (v82)
                  {
                    uint64_t v83 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v108, v82);
                    unint64_t v78 = (char *)v106;
                    uint64_t v67 = v107;
                  }
                  else
                  {
                    uint64_t v83 = 0;
                  }
                  uint64_t v86 = &v83[8 * v79];
                  *(void *)uint64_t v86 = v70[v65];
                  uint64_t v71 = v86 + 8;
                  while (v67 != v78)
                  {
                    uint64_t v87 = *((void *)v67 - 1);
                    v67 -= 8;
                    *((void *)v86 - 1) = v87;
                    v86 -= 8;
                  }
                  unint64_t v106 = v86;
                  uint64_t v107 = v71;
                  unint64_t v108 = &v83[8 * v82];
                  if (v78) {
                    operator delete(v78);
                  }
                }
                else
                {
                  *(void *)uint64_t v107 = *((void *)v111[0] + v65);
                  uint64_t v71 = v67 + 8;
                }
                uint64_t v107 = v71;
                ++v65;
              }
              ++v63;
            }
            while (v63 != v57);
          }
          if ((v62 & 1) == 0) {
            char v59 = std::function<signed char ()(signed char,signed char)>::operator()(a4, v104, v59);
          }
          if (v106)
          {
            uint64_t v107 = (char *)v106;
            operator delete(v106);
          }
          if (v109)
          {
            unint64_t v110 = v109;
            operator delete(v109);
          }
          char v62 = 0;
          ++v60;
          char v61 = v59;
        }
        while (v60 != v99);
      }
      else
      {
        char v59 = 0;
      }
      if (v109)
      {
        unint64_t v110 = v109;
        operator delete(v109);
      }
      if (v111[0])
      {
        v111[1] = v111[0];
        operator delete(v111[0]);
      }
      unint64_t v55 = v97 + 1;
    }
    while (v97 + 1 != v92);
  }
  if (v114)
  {
    __n128 v115 = (char *)v114;
    operator delete(v114);
  }
  if (v117.__r_.__value_.__r.__words[0])
  {
    v117.__r_.__value_.__l.__size_ = v117.__r_.__value_.__r.__words[0];
    operator delete(v117.__r_.__value_.__l.__data_);
  }
  if (__p)
  {
    unint64_t v119 = (char *)__p;
    operator delete(__p);
  }
  return std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table((uint64_t)v121);
}

void sub_20F4C8C1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37,uint64_t a38,void *__p,uint64_t a40,int a41,__int16 a42,char a43,char a44,void *a45,uint64_t a46)
{
  if (a44 < 0)
  {
    operator delete(__p);
    if ((v47 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a45);
      std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table(v48 - 128);
      _Unwind_Resume(a1);
    }
  }
  else if (!v47)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v46);
  goto LABEL_6;
}

uint64_t std::function<signed char ()(signed char,signed char)>::operator()(uint64_t a1, char a2, char a3)
{
  char v6 = a2;
  char v5 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, char *, char *))(*(void *)v3 + 48))(v3, &v6, &v5);
}

void MIL::ValueInference::Tensor<signed char>::Zeros(MIL *a1@<X0>, const MIL::IRTensorValueType *a2@<X1>, uint64_t a3@<X8>)
{
  MIL::GetTensorShapeWithDimensionsAllKnown(a1, a2, (uint64_t)v6);
  *(_OWORD *)__n128 __p = *(_OWORD *)v6;
  uint64_t v5 = v7;
  v6[1] = 0;
  uint64_t v7 = 0;
  v6[0] = 0;
  MIL::ValueInference::Tensor<signed char>::Zeros((__n128 *)__p, a3);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v6[0])
  {
    v6[1] = v6[0];
    operator delete(v6[0]);
  }
}

void sub_20F4C8E0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  if (__p) {
    operator delete(__p);
  }
  if (a13) {
    operator delete(a13);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<short>::FromIRTensorValue(void *a1@<X0>, uint64_t a2@<X8>)
{
  MIL::IRTensorValue::TryGetDataView<short>(&v12, *a1);
  if (!(_BYTE)v12)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Failed to get data view.");
    uint64_t v7 = (struct type_info *)MEMORY[0x263F8C1F0];
    unint64_t v8 = (void (*)(void *))MEMORY[0x263F8C070];
    goto LABEL_10;
  }
  unint64_t v4 = (MIL *)(*(uint64_t (**)(void))(*(void *)*a1 + 32))();
  if ((*(unsigned int (**)(MIL *))(*(void *)v4 + 88))(v4) == 3)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100]((std::logic_error *)exception, "It is not supported to convert a tensor of string dtype.");
    uint64_t v7 = (struct type_info *)off_26412C1F0;
    unint64_t v8 = (void (*)(void *))MEMORY[0x263F8C080];
LABEL_10:
    __cxa_throw(exception, v7, v8);
  }
  MIL::GetTensorShapeWithDimensionsAllKnown(v4, v5, (uint64_t)&v11);
  uint64_t v10 = 0;
  __n128 __p = 0uLL;
  std::vector<short>::__init_with_size[abi:ne180100]<short const*,short const*>(&__p, v13, (uint64_t)v13 + 2 * v14, v14);
  MIL::ValueInference::Tensor<short>::Tensor(a2, &v11, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v11.n128_u64[0])
  {
    v11.n128_u64[1] = v11.n128_u64[0];
    operator delete((void *)v11.n128_u64[0]);
  }
}

void sub_20F4C8F8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  __cxa_free_exception(v14);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<short>::ToIRTensorValue(uint64_t a1, MIL::IRConstantDimension *a2)
{
  memset(__p, 0, sizeof(__p));
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(__p, *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3);
  MIL::IRTensorValueType::Make(a2, 10, (MIL::MILContext ***)__p);
}

void sub_20F4C9094(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::ValueInference::Tensor<short>::Tensor(uint64_t a1, __n128 *a2, __n128 *a3)
{
  *(_OWORD *)(a1 + 8) = 0u;
  uint64_t v5 = a1 + 8;
  *(void *)a1 = &unk_26C25DC58;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  char v6 = (uint64_t *)a2->n128_u64[0];
  uint64_t v7 = (uint64_t *)a2->n128_u64[1];
  if ((uint64_t *)a2->n128_u64[0] == v7)
  {
    unint64_t v10 = a3->n128_u64[0];
    unint64_t v11 = a3->n128_u64[1];
    uint64_t v8 = a3->n128_u64[0] != v11;
  }
  else
  {
    uint64_t v8 = 1;
    do
    {
      uint64_t v9 = *v6++;
      v8 *= v9;
    }
    while (v6 != v7);
    unint64_t v10 = a3->n128_u64[0];
    unint64_t v11 = a3->n128_u64[1];
  }
  if (v8 != (uint64_t)(v11 - v10) >> 1)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "data size and shape dismatch.");
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  std::vector<float>::__move_assign(v5, a2);
  std::vector<float>::__move_assign(a1 + 32, a3);
  *(void *)(a1 + 56) = v8;
  return a1;
}

void sub_20F4C91CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10)
{
  uint64_t v13 = *v11;
  if (*v11)
  {
    *(void *)(v10 + 40) = v13;
    operator delete(v13);
  }
  uint64_t v14 = *a10;
  if (*a10)
  {
    *(void *)(v10 + 16) = v14;
    operator delete(v14);
  }
  _Unwind_Resume(exception_object);
}

double MIL::ValueInference::Tensor<short>::Tensor(uint64_t a1)
{
  *(void *)a1 = &unk_26C25DC58;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  return result;
}

void MIL::ValueInference::Tensor<short>::ForEach(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v13[4] = *MEMORY[0x263EF8340];
  uint64_t v6 = (uint64_t)(*(void *)(a1 + 40) - *(void *)(a1 + 32)) >> 1;
  __p.n128_u16[0] = 0;
  std::vector<short>::vector(&v12, v6, &__p);
  __n128 __p = 0uLL;
  uint64_t v11 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3);
  uint64_t v8 = *(__int16 **)(a1 + 32);
  uint64_t v7 = *(__int16 **)(a1 + 40);
  uint64_t v9 = (_WORD *)v12.n128_u64[0];
  std::__function::__value_func<short ()(short)>::__value_func[abi:ne180100]((uint64_t)v13, a2);
  while (v8 != v7)
    *v9++ = std::function<short ()(short)>::operator()((uint64_t)v13, *v8++);
  std::__function::__value_func<short ()(short)>::~__value_func[abi:ne180100](v13);
  MIL::ValueInference::Tensor<short>::Tensor(a3, &__p, &v12);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v12.n128_u64[0])
  {
    v12.n128_u64[1] = v12.n128_u64[0];
    operator delete((void *)v12.n128_u64[0]);
  }
}

void sub_20F4C934C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, char a16)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::ValueInference::Tensor<short>::GetScalarData(void *a1)
{
  if (a1[1] != a1[2] || (uint64_t v1 = (__int16 *)a1[4], a1[5] - (void)v1 != 2))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Tensor is not a scalar.");
    __cxa_throw(exception, MEMORY[0x263F8C1E0], MEMORY[0x263F8C048]);
  }
  return *v1;
}

void sub_20F4C940C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<short>::Reshape(void *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = (uint64_t *)*a2;
  uint64_t v7 = a2[1];
  uint64_t v8 = 1;
  if (v6 != (uint64_t *)v7)
  {
    uint64_t v9 = v6;
    do
    {
      uint64_t v10 = *v9++;
      v8 *= v10;
    }
    while (v9 != (uint64_t *)v7);
  }
  if (a1[7] != v8)
  {
    uint64_t v13 = a2;
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v22);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"Tensor is not able to be reshaped since the number of elements in the newShape [ ", 81);
    uint64_t v14 = *v13;
    uint64_t v15 = v13[1];
    if (*v13 != v15)
    {
      do
      {
        uint64_t v16 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)" ", 1);
        v14 += 8;
      }
      while (v14 != v15);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"] is not the same as the number of elements in the tensor shape [ ", 66);
    uint64_t v17 = a1[1];
    for (uint64_t i = a1[2]; v17 != i; v17 += 8)
    {
      unint64_t v19 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)" ", 1);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"].", 2);
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str();
    std::logic_error::logic_error(exception, &__p);
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  __n128 v22 = 0uLL;
  uint64_t v23 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v22, v6, v7, (v7 - (uint64_t)v6) >> 3);
  uint64_t v11 = (const void *)a1[4];
  uint64_t v12 = a1[5];
  memset(&__p, 0, sizeof(__p));
  std::vector<short>::__init_with_size[abi:ne180100]<std::__wrap_iter<short const*>,std::__wrap_iter<short const*>>(&__p, v11, v12, (v12 - (uint64_t)v11) >> 1);
  MIL::ValueInference::Tensor<short>::Tensor(a3, &v22, (__n128 *)&__p);
  if (__p.__r_.__value_.__r.__words[0])
  {
    __p.__r_.__value_.__l.__size_ = __p.__r_.__value_.__r.__words[0];
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v22.n128_u64[0])
  {
    v22.n128_u64[1] = v22.n128_u64[0];
    operator delete((void *)v22.n128_u64[0]);
  }
}

void sub_20F4C9620(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((v17 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v17)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v16);
  goto LABEL_6;
}

void MIL::ValueInference::Tensor<short>::NonZero(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v3 = *(void *)(a1 + 56);
  if (v3)
  {
    unint64_t v5 = 0;
    uint64_t v6 = (uint64_t **)(a1 + 8);
    do
    {
      if (*(_WORD *)(*(void *)(a1 + 32) + 2 * v5))
      {
        std::vector<std::vector<unsigned long long>>::push_back[abi:ne180100](a2, (uint64_t)__p);
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
        unint64_t v3 = *(void *)(a1 + 56);
      }
      ++v5;
    }
    while (v5 < v3);
  }
}

void sub_20F4C9734(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
}

void MIL::ValueInference::Tensor<short>::SubTensor(void *a1@<X0>, uint64_t **a2@<X1>, void *a3@<X8>)
{
  unint64_t v5 = ((char *)a2[1] - (char *)*a2) >> 4;
  uint64_t v6 = a1 + 1;
  if (v5 != (uint64_t)(a1[2] - a1[1]) >> 3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "Indices does not match the rank of the tensor.");
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  std::string __p = 0;
  uint64_t v46 = 0;
  int v47 = 0;
  std::vector<unsigned long long>::reserve(&__p, v5);
  uint64_t v8 = a1[1];
  if (a1[2] != v8)
  {
    unint64_t v9 = 0;
    while (1)
    {
      unint64_t v11 = (*a2)[2 * v9];
      unint64_t v10 = (*a2)[2 * v9 + 1];
      unint64_t v12 = v10 - v11;
      if (v10 < v11) {
        break;
      }
      if (v10 > *(void *)(v8 + 8 * v9))
      {
        uint64_t v33 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(v33, "Indices end is out of the bound for the tensor dimension.");
        unint64_t v34 = (void (*)(void *))MEMORY[0x263F8C068];
        int64_t v35 = (struct type_info *)off_26412C1E0;
        uint64_t v36 = MEMORY[0x263F8C390] + 16;
LABEL_45:
        v33->__vftable = (std::logic_error_vtbl *)v36;
        __cxa_throw(v33, v35, v34);
      }
      uint64_t v13 = v46;
      if (v46 >= v47)
      {
        uint64_t v15 = (char *)__p;
        uint64_t v16 = (v46 - (unsigned char *)__p) >> 3;
        unint64_t v17 = v16 + 1;
        if ((unint64_t)(v16 + 1) >> 61) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v18 = v47 - (unsigned char *)__p;
        if ((v47 - (unsigned char *)__p) >> 2 > v17) {
          unint64_t v17 = v18 >> 2;
        }
        if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v19 = v17;
        }
        if (v19)
        {
          unint64_t v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v47, v19);
          uint64_t v15 = (char *)__p;
          uint64_t v13 = v46;
        }
        else
        {
          unint64_t v20 = 0;
        }
        size_t v21 = &v20[8 * v16];
        *(void *)size_t v21 = v12;
        uint64_t v14 = (uint64_t)(v21 + 8);
        while (v13 != v15)
        {
          uint64_t v22 = *((void *)v13 - 1);
          v13 -= 8;
          *((void *)v21 - 1) = v22;
          v21 -= 8;
        }
        std::string __p = v21;
        uint64_t v46 = (char *)v14;
        int v47 = &v20[8 * v19];
        if (v15) {
          operator delete(v15);
        }
      }
      else
      {
        *(void *)uint64_t v46 = v12;
        uint64_t v14 = (uint64_t)(v13 + 8);
      }
      uint64_t v46 = (char *)v14;
      ++v9;
      uint64_t v8 = a1[1];
      if (v9 >= (a1[2] - v8) >> 3) {
        goto LABEL_25;
      }
    }
    uint64_t v33 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v33, "Indices end must not be smaller than the indices begin.");
    unint64_t v34 = (void (*)(void *))MEMORY[0x263F8C080];
    int64_t v35 = (struct type_info *)off_26412C1F0;
    uint64_t v36 = MEMORY[0x263F8C3A0] + 16;
    goto LABEL_45;
  }
  uint64_t v14 = (uint64_t)v46;
LABEL_25:
  __n128 v43 = 0uLL;
  uint64_t v44 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v43, __p, v14, (v14 - (uint64_t)__p) >> 3);
  MIL::ValueInference::Tensor<short>::Zeros(&v43, (uint64_t)a3);
  if (v43.n128_u64[0])
  {
    v43.n128_u64[1] = v43.n128_u64[0];
    operator delete((void *)v43.n128_u64[0]);
  }
  uint64_t v23 = a3[5] - a3[4];
  if (v23)
  {
    unint64_t v24 = 0;
    unint64_t v25 = v23 >> 1;
    if (v25 <= 1) {
      uint64_t v26 = 1;
    }
    else {
      uint64_t v26 = v25;
    }
    do
    {
      std::string::size_type v38 = 0;
      uint64_t v39 = 0;
      uint64_t v40 = 0;
      std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v38, v41, (uint64_t)v42, (v42 - (unsigned char *)v41) >> 3);
      uint64_t v27 = a1[2] - a1[1];
      if (v27)
      {
        unint64_t v28 = v27 >> 3;
        uint64_t v29 = *a2;
        uint64_t v30 = v38;
        if (v28 <= 1) {
          unint64_t v28 = 1;
        }
        do
        {
          uint64_t v31 = *v29;
          v29 += 2;
          *v30++ += v31;
          --v28;
        }
        while (v28);
      }
      if (v38)
      {
        uint64_t v39 = v38;
        operator delete(v38);
      }
      if (v41)
      {
        uint64_t v42 = v41;
        operator delete(v41);
      }
      ++v24;
    }
    while (v24 != v26);
  }
  if (__p)
  {
    uint64_t v46 = (char *)__p;
    operator delete(__p);
  }
}

void sub_20F4C9AE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19)
{
  __cxa_free_exception(v19);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<short>::Zeros(__n128 *a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t v4 = (uint64_t *)a1->n128_u64[0];
  uint64_t v5 = 1;
  while (v4 != (uint64_t *)a1->n128_u64[1])
  {
    uint64_t v6 = *v4++;
    v5 *= v6;
  }
  std::vector<short>::vector(&__p, v5);
  MIL::ValueInference::Tensor<short>::Tensor(a2, a1, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
}

void sub_20F4C9BFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<short>::Concat(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *a1;
  uint64_t v7 = 0;
  uint64_t v8 = a1[1] - *a1;
  if (v8)
  {
    unint64_t v9 = v8 >> 6;
    if (v9 <= 1) {
      unint64_t v9 = 1;
    }
    unint64_t v10 = (uint64_t *)(v6 + 8);
    do
    {
      uint64_t v11 = *v10;
      v10 += 8;
      v7 += *(void *)(v11 + 8 * a2);
      --v9;
    }
    while (v9);
  }
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  unint64_t v28 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v28, *(const void **)(v6 + 8), *(void *)(v6 + 16), (uint64_t)(*(void *)(v6 + 16) - *(void *)(v6 + 8)) >> 3);
  unint64_t v12 = v28;
  *((void *)v28 + a2) = v7;
  uint64_t v27 = 0;
  __n128 __p = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, v12, (uint64_t)v29, (v29 - (unsigned char *)v12) >> 3);
  MIL::ValueInference::Tensor<short>::Zeros(&__p, a3);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  uint64_t v13 = *a1;
  uint64_t v14 = a1[1];
  if (v14 != *a1)
  {
    unint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(void *)(v13 + (v15 << 6) + 40) - *(void *)(v13 + (v15 << 6) + 32);
      if (v17)
      {
        unint64_t v18 = 0;
        if ((unint64_t)(v17 >> 1) <= 1) {
          uint64_t v19 = 1;
        }
        else {
          uint64_t v19 = v17 >> 1;
        }
        do
        {
          size_t v21 = 0;
          uint64_t v22 = 0;
          uint64_t v23 = 0;
          std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v21, v24, (uint64_t)v25, (v25 - (unsigned char *)v24) >> 3);
          *((void *)v21 + a2) += v16;
          unint64_t v20 = *a1 + (v15 << 6);
          LOWORD(v20) = *(_WORD *)(*(void *)(v20 + 32)
          *(_WORD *)(*(void *)(a3 + 32)
          if (v21)
          {
            uint64_t v22 = v21;
            operator delete(v21);
          }
          if (v24)
          {
            unint64_t v25 = v24;
            operator delete(v24);
          }
          ++v18;
        }
        while (v19 != v18);
        uint64_t v13 = *a1;
        uint64_t v14 = a1[1];
      }
      v16 += *(void *)(*(void *)(v13 + (v15++ << 6) + 8) + 8 * a2);
    }
    while (v15 < (v14 - v13) >> 6);
  }
  if (v28)
  {
    uint64_t v29 = v28;
    operator delete(v28);
  }
}

void sub_20F4C9E04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  if (a18) {
    operator delete(a18);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<short>::BlockwiseMerge(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *(uint64_t **)a2;
  uint64_t v7 = *(void *)(a2 + 8) - *(void *)a2;
  if (v7)
  {
    unint64_t v8 = v7 >> 3;
    if (v8 <= 1) {
      unint64_t v8 = 1;
    }
    uint64_t v9 = 1;
    do
    {
      uint64_t v10 = *v6++;
      v9 *= v10;
      --v8;
    }
    while (v8);
  }
  else
  {
    uint64_t v9 = 1;
  }
  uint64_t v11 = *a1;
  if (v9 != (a1[1] - *a1) >> 6)
  {
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v48);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v48, (uint64_t)"The number of tensors (", 23);
    uint64_t v36 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v36, (uint64_t)") is not the same as the number of blocks (", 43);
    unint64_t v37 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v37, (uint64_t)").", 2);
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str();
    std::runtime_error::runtime_error(exception, &v47);
    __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
  }
  unint64_t v49 = 0;
  uint64_t v50 = 0;
  uint64_t v48 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v48, *(const void **)(v11 + 8), *(void *)(v11 + 16), (uint64_t)(*(void *)(v11 + 16) - *(void *)(v11 + 8)) >> 3);
  memset(&v47, 0, sizeof(v47));
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v47, v48, (uint64_t)v49, (v49 - (unsigned char *)v48) >> 3);
  unint64_t v12 = *(uint64_t **)a2;
  uint64_t v13 = (const void *)v47.__r_.__value_.__r.__words[0];
  uint64_t v14 = *(void *)(a2 + 8) - *(void *)a2;
  if (v14)
  {
    unint64_t v15 = v14 >> 3;
    if (v15 <= 1) {
      unint64_t v15 = 1;
    }
    uint64_t v16 = (void *)v47.__r_.__value_.__r.__words[0];
    do
    {
      uint64_t v17 = *v12++;
      *v16++ *= v17;
      --v15;
    }
    while (v15);
  }
  __n128 __p = 0uLL;
  uint64_t v46 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, v13, v47.__r_.__value_.__l.__size_, (uint64_t)(v47.__r_.__value_.__l.__size_ - (void)v13) >> 3);
  MIL::ValueInference::Tensor<short>::Zeros(&__p, a3);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v9)
  {
    for (unint64_t i = 0; i != v9; ++i)
    {
      unint64_t v19 = *a1 + (i << 6);
      unint64_t v20 = *(const void **)(v19 + 8);
      size_t v21 = *(void *)(v19 + 16) - (void)v20;
      if (v21 != v49 - (unsigned char *)v48 || memcmp(v20, v48, v21))
      {
        int64_t v35 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v35, "All tensors must have the same shape so they can be merged.");
        __cxa_throw(v35, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
      }
      uint64_t v22 = *(void *)(*a1 + (i << 6) + 40) - *(void *)(*a1 + (i << 6) + 32);
      if (v22)
      {
        unint64_t v23 = 0;
        unint64_t v24 = v22 >> 1;
        if (v24 <= 1) {
          uint64_t v25 = 1;
        }
        else {
          uint64_t v25 = v24;
        }
        do
        {
          uint64_t v39 = 0;
          uint64_t v40 = 0;
          uint64_t v41 = 0;
          std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v39, v42, (uint64_t)v43, (v43 - (unsigned char *)v42) >> 3);
          uint64_t v26 = *(void *)(a2 + 8) - *(void *)a2;
          if (v26)
          {
            unint64_t v27 = v26 >> 3;
            unint64_t v28 = (uint64_t *)v48;
            uint64_t v29 = (uint64_t *)v44[0];
            uint64_t v30 = v39;
            if (v27 <= 1) {
              unint64_t v27 = 1;
            }
            do
            {
              uint64_t v32 = *v28++;
              uint64_t v31 = v32;
              uint64_t v33 = *v29++;
              *v30++ += v33 * v31;
              --v27;
            }
            while (v27);
          }
          unint64_t v34 = *a1 + (i << 6);
          LOWORD(v34) = *(_WORD *)(*(void *)(v34 + 32)
          *(_WORD *)(*(void *)(a3 + 32)
          if (v39)
          {
            uint64_t v40 = v39;
            operator delete(v39);
          }
          if (v42)
          {
            __n128 v43 = v42;
            operator delete(v42);
          }
          ++v23;
        }
        while (v23 != v25);
      }
      if (v44[0])
      {
        v44[1] = v44[0];
        operator delete(v44[0]);
      }
    }
  }
  if (v47.__r_.__value_.__r.__words[0])
  {
    v47.__r_.__value_.__l.__size_ = v47.__r_.__value_.__r.__words[0];
    operator delete(v47.__r_.__value_.__l.__data_);
  }
  if (v48)
  {
    unint64_t v49 = v48;
    operator delete(v48);
  }
}

void sub_20F4CA20C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28)
{
  if (a26 < 0)
  {
    operator delete(__p);
    if ((v29 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a27);
      _Unwind_Resume(a1);
    }
  }
  else if (!v29)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v28);
  goto LABEL_6;
}

uint64_t MIL::ValueInference::Tensor<short>::Reduce@<X0>(void *a1@<X0>, unint64_t **a2@<X1>, int a3@<W2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v103 = a1[1];
  char v104 = a1 + 1;
  uint64_t v102 = a1[2];
  unint64_t v7 = (v102 - v103) >> 3;
  std::unordered_set<unsigned long long>::unordered_set<std::__wrap_iter<unsigned long long const*>>((uint64_t)v122, *a2, a2[1]);
  for (unint64_t i = v123; i; unint64_t i = (void *)*i)
  {
    if (i[2] >= v7)
    {
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&__p);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&__p, (uint64_t)"axis(", 5);
      uint64_t v91 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v91, (uint64_t)") must be smaller than the number of input dimensions(", 54);
      uint64_t v92 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v92, (uint64_t)").", 2);
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::stringbuf::str();
      std::logic_error::logic_error(exception, &v118);
      exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
      __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
    }
  }
  __n128 __p = 0;
  std::string v120 = 0;
  v121[0] = 0;
  memset(&v118, 0, sizeof(v118));
  __n128 v115 = 0;
  std::string v116 = 0;
  std::string v117 = 0;
  if (v102 == v103)
  {
    uint64_t v54 = 0;
    uint64_t v53 = 0;
  }
  else
  {
    uint64_t v5 = 0;
    if (v7 <= 1) {
      uint64_t v9 = 1;
    }
    else {
      uint64_t v9 = (v102 - v103) >> 3;
    }
    do
    {
      v112[0] = v5;
      if (std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(v122, (unint64_t *)v112))
      {
        if (a3)
        {
          uint64_t v10 = v120;
          if ((unint64_t)v120 >= v121[0])
          {
            size_t v21 = (char *)__p;
            uint64_t v22 = (v120 - (unsigned char *)__p) >> 3;
            unint64_t v23 = v22 + 1;
            if ((unint64_t)(v22 + 1) >> 61) {
              std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v24 = v121[0] - (void)__p;
            if ((uint64_t)(v121[0] - (void)__p) >> 2 > v23) {
              unint64_t v23 = v24 >> 2;
            }
            if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v25 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v25 = v23;
            }
            if (v25)
            {
              uint64_t v26 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)v121, v25);
              size_t v21 = (char *)__p;
              uint64_t v10 = v120;
            }
            else
            {
              uint64_t v26 = 0;
            }
            uint64_t v40 = &v26[8 * v22];
            *(void *)uint64_t v40 = 1;
            uint64_t v11 = v40 + 8;
            while (v10 != v21)
            {
              uint64_t v41 = *((void *)v10 - 1);
              v10 -= 8;
              *((void *)v40 - 1) = v41;
              v40 -= 8;
            }
            __n128 __p = v40;
            std::string v120 = v11;
            v121[0] = &v26[8 * v25];
            if (v21) {
              operator delete(v21);
            }
          }
          else
          {
            *(void *)std::string v120 = 1;
            uint64_t v11 = v10 + 8;
          }
          std::string v120 = v11;
        }
        uint64_t v42 = *v104;
        __n128 v43 = v116;
        if (v116 >= v117)
        {
          uint64_t v45 = (char *)v115;
          uint64_t v46 = (v116 - (unsigned char *)v115) >> 3;
          unint64_t v47 = v46 + 1;
          if ((unint64_t)(v46 + 1) >> 61) {
LABEL_154:
          }
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          uint64_t v48 = v117 - (unsigned char *)v115;
          if ((v117 - (unsigned char *)v115) >> 2 > v47) {
            unint64_t v47 = v48 >> 2;
          }
          if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v49 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v49 = v47;
          }
          if (v49)
          {
            uint64_t v50 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v117, v49);
            uint64_t v45 = (char *)v115;
            __n128 v43 = v116;
          }
          else
          {
            uint64_t v50 = 0;
          }
          uint64_t v51 = &v50[8 * v46];
          *(void *)uint64_t v51 = *(void *)(v42 + 8 * (void)v5);
          uint64_t v44 = v51 + 8;
          while (v43 != v45)
          {
            uint64_t v52 = *((void *)v43 - 1);
            v43 -= 8;
            *((void *)v51 - 1) = v52;
            v51 -= 8;
          }
          __n128 v115 = v51;
          std::string v116 = v44;
          std::string v117 = &v50[8 * v49];
          if (v45) {
            operator delete(v45);
          }
        }
        else
        {
          *(void *)std::string v116 = *(void *)(v42 + 8 * (void)v5);
          uint64_t v44 = v43 + 8;
        }
        std::string v116 = v44;
      }
      else
      {
        uint64_t v12 = *v104;
        uint64_t v13 = v120;
        if ((unint64_t)v120 >= v121[0])
        {
          unint64_t v15 = (char *)__p;
          uint64_t v16 = (v120 - (unsigned char *)__p) >> 3;
          unint64_t v17 = v16 + 1;
          if ((unint64_t)(v16 + 1) >> 61) {
            goto LABEL_154;
          }
          uint64_t v18 = v121[0] - (void)__p;
          if ((uint64_t)(v121[0] - (void)__p) >> 2 > v17) {
            unint64_t v17 = v18 >> 2;
          }
          if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v19 = v17;
          }
          if (v19)
          {
            unint64_t v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)v121, v19);
            unint64_t v15 = (char *)__p;
            uint64_t v13 = v120;
          }
          else
          {
            unint64_t v20 = 0;
          }
          unint64_t v27 = &v20[8 * v16];
          *(void *)unint64_t v27 = *(void *)(v12 + 8 * (void)v5);
          uint64_t v14 = v27 + 8;
          while (v13 != v15)
          {
            uint64_t v28 = *((void *)v13 - 1);
            v13 -= 8;
            *((void *)v27 - 1) = v28;
            v27 -= 8;
          }
          __n128 __p = v27;
          std::string v120 = v14;
          v121[0] = &v20[8 * v19];
          if (v15) {
            operator delete(v15);
          }
        }
        else
        {
          *(void *)std::string v120 = *(void *)(v12 + 8 * (void)v5);
          uint64_t v14 = v13 + 8;
        }
        std::string v120 = v14;
        uint64_t v29 = *v104;
        std::string::size_type size = v118.__r_.__value_.__l.__size_;
        if (v118.__r_.__value_.__l.__size_ >= v118.__r_.__value_.__r.__words[2])
        {
          uint64_t v32 = (void *)v118.__r_.__value_.__r.__words[0];
          uint64_t v33 = (uint64_t)(v118.__r_.__value_.__l.__size_ - v118.__r_.__value_.__r.__words[0]) >> 3;
          unint64_t v34 = v33 + 1;
          if ((unint64_t)(v33 + 1) >> 61) {
            goto LABEL_154;
          }
          int64_t v35 = v118.__r_.__value_.__r.__words[2] - v118.__r_.__value_.__r.__words[0];
          if ((uint64_t)(v118.__r_.__value_.__r.__words[2] - v118.__r_.__value_.__r.__words[0]) >> 2 > v34) {
            unint64_t v34 = v35 >> 2;
          }
          if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v36 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v36 = v34;
          }
          if (v36)
          {
            unint64_t v37 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v118.__r_.__value_.__r.__words[2], v36);
            std::string::size_type size = v118.__r_.__value_.__l.__size_;
            uint64_t v32 = (void *)v118.__r_.__value_.__r.__words[0];
          }
          else
          {
            unint64_t v37 = 0;
          }
          std::string::size_type v38 = &v37[8 * v33];
          *(void *)std::string::size_type v38 = *(void *)(v29 + 8 * (void)v5);
          std::string::size_type v31 = (std::string::size_type)(v38 + 8);
          while ((void *)size != v32)
          {
            uint64_t v39 = *(void *)(size - 8);
            size -= 8;
            *((void *)v38 - 1) = v39;
            v38 -= 8;
          }
          v118.__r_.__value_.__r.__words[0] = (std::string::size_type)v38;
          v118.__r_.__value_.__l.__size_ = v31;
          v118.__r_.__value_.__r.__words[2] = (std::string::size_type)&v37[8 * v36];
          if (v32) {
            operator delete(v32);
          }
        }
        else
        {
          *(void *)v118.__r_.__value_.__l.__size_ = *(void *)(v29 + 8 * (void)v5);
          std::string::size_type v31 = size + 8;
        }
        v118.__r_.__value_.__l.__size_ = v31;
      }
      uint64_t v5 = (char *)v5 + 1;
    }
    while (v5 != (void *)v9);
    uint64_t v53 = __p;
    uint64_t v54 = (uint64_t)v120;
  }
  __n128 v113 = 0uLL;
  uint64_t v114 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v113, v53, v54, (v54 - (uint64_t)v53) >> 3);
  MIL::ValueInference::Tensor<short>::Zeros(&v113, a5);
  if (v113.n128_u64[0])
  {
    v113.n128_u64[1] = v113.n128_u64[0];
    operator delete((void *)v113.n128_u64[0]);
  }
  uint64_t v55 = *(void *)(a5 + 40) - *(void *)(a5 + 32);
  if (v55)
  {
    unint64_t v56 = 0;
    unint64_t v57 = v55 >> 1;
    unint64_t v95 = v55 >> 1;
    unint64_t v96 = (uint64_t)(a1[5] - a1[4]) >> 1;
    unint64_t v58 = v96 / (v55 >> 1);
    char v59 = (uint64_t **)(a5 + 8);
    if (v7 <= 1) {
      uint64_t v60 = 1;
    }
    else {
      uint64_t v60 = (v102 - v103) >> 3;
    }
    if (v57 <= 1) {
      uint64_t v61 = 1;
    }
    else {
      uint64_t v61 = v57;
    }
    uint64_t v94 = v61;
    if (v58 <= 1) {
      unint64_t v58 = 1;
    }
    unint64_t v100 = v58;
    do
    {
      unint64_t v98 = v56;
      __int16 v62 = (unsigned __int16)v5 & 0xFF00;
      if (v95 <= v96)
      {
        unint64_t v63 = 0;
        char v64 = 1;
        do
        {
          __int16 v105 = v62;
          uint64_t v107 = 0;
          unint64_t v108 = 0;
          uint64_t v109 = 0;
          if (v102 != v103)
          {
            unint64_t v65 = 0;
            uint64_t v66 = 0;
            uint64_t v67 = 0;
            do
            {
              unint64_t v106 = v65;
              uint64_t v68 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(v122, &v106);
              uint64_t v69 = v108;
              if (v68)
              {
                uint64_t v70 = v110;
                if (v108 >= v109)
                {
                  unint64_t v74 = (char *)v107;
                  uint64_t v75 = (v108 - (unsigned char *)v107) >> 3;
                  unint64_t v76 = v75 + 1;
                  if ((unint64_t)(v75 + 1) >> 61) {
                    goto LABEL_152;
                  }
                  uint64_t v77 = v109 - (unsigned char *)v107;
                  if ((v109 - (unsigned char *)v107) >> 2 > v76) {
                    unint64_t v76 = v77 >> 2;
                  }
                  if ((unint64_t)v77 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v78 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v78 = v76;
                  }
                  if (v78)
                  {
                    uint64_t v79 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v109, v78);
                    unint64_t v74 = (char *)v107;
                    uint64_t v69 = v108;
                  }
                  else
                  {
                    uint64_t v79 = 0;
                  }
                  uint64_t v86 = &v79[8 * v75];
                  *(void *)uint64_t v86 = v70[v66];
                  uint64_t v71 = v86 + 8;
                  while (v69 != v74)
                  {
                    uint64_t v87 = *((void *)v69 - 1);
                    v69 -= 8;
                    *((void *)v86 - 1) = v87;
                    v86 -= 8;
                  }
                  uint64_t v107 = v86;
                  unint64_t v108 = v71;
                  uint64_t v109 = &v79[8 * v78];
                  if (v74) {
                    operator delete(v74);
                  }
                }
                else
                {
                  *(void *)unint64_t v108 = *((void *)v110 + v66);
                  uint64_t v71 = v69 + 8;
                }
                unint64_t v108 = v71;
                ++v66;
              }
              else
              {
                uint64_t v72 = v112[0];
                if (v108 >= v109)
                {
                  unint64_t v80 = (char *)v107;
                  uint64_t v81 = (v108 - (unsigned char *)v107) >> 3;
                  unint64_t v82 = v81 + 1;
                  if ((unint64_t)(v81 + 1) >> 61) {
LABEL_152:
                  }
                    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
                  uint64_t v83 = v109 - (unsigned char *)v107;
                  if ((v109 - (unsigned char *)v107) >> 2 > v82) {
                    unint64_t v82 = v83 >> 2;
                  }
                  if ((unint64_t)v83 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v84 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v84 = v82;
                  }
                  if (v84)
                  {
                    uint64_t v85 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v109, v84);
                    unint64_t v80 = (char *)v107;
                    uint64_t v69 = v108;
                  }
                  else
                  {
                    uint64_t v85 = 0;
                  }
                  int v88 = &v85[8 * v81];
                  *(void *)int v88 = v72[v67];
                  uint64_t v73 = v88 + 8;
                  while (v69 != v80)
                  {
                    uint64_t v89 = *((void *)v69 - 1);
                    v69 -= 8;
                    *((void *)v88 - 1) = v89;
                    v88 -= 8;
                  }
                  uint64_t v107 = v88;
                  unint64_t v108 = v73;
                  uint64_t v109 = &v85[8 * v84];
                  if (v80) {
                    operator delete(v80);
                  }
                }
                else
                {
                  *(void *)unint64_t v108 = *((void *)v112[0] + v67);
                  uint64_t v73 = v69 + 8;
                }
                unint64_t v108 = v73;
                ++v67;
              }
              ++v65;
            }
            while (v65 != v60);
          }
          char v59 = (uint64_t **)(a5 + 8);
          if ((v64 & 1) == 0) {
            LOWORD(v5) = std::function<short ()(short,short)>::operator()(a4, v105, (__int16)v5);
          }
          if (v107)
          {
            unint64_t v108 = (char *)v107;
            operator delete(v107);
          }
          if (v110)
          {
            __n128 v111 = v110;
            operator delete(v110);
          }
          char v64 = 0;
          ++v63;
          __int16 v62 = (__int16)v5;
        }
        while (v63 != v100);
      }
      else
      {
        LOWORD(v5) = (unsigned __int16)v5 & 0xFF00;
      }
      if (v110)
      {
        __n128 v111 = v110;
        operator delete(v110);
      }
      if (v112[0])
      {
        v112[1] = v112[0];
        operator delete(v112[0]);
      }
      unint64_t v56 = v98 + 1;
    }
    while (v98 + 1 != v94);
  }
  if (v115)
  {
    std::string v116 = (char *)v115;
    operator delete(v115);
  }
  if (v118.__r_.__value_.__r.__words[0])
  {
    v118.__r_.__value_.__l.__size_ = v118.__r_.__value_.__r.__words[0];
    operator delete(v118.__r_.__value_.__l.__data_);
  }
  if (__p)
  {
    std::string v120 = (char *)__p;
    operator delete(__p);
  }
  return std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table((uint64_t)v122);
}

void sub_20F4CAB48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37,uint64_t a38,void *__p,uint64_t a40,int a41,__int16 a42,char a43,char a44,void *a45,uint64_t a46)
{
  if (a44 < 0)
  {
    operator delete(__p);
    if ((v47 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a45);
      std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table(v48 - 128);
      _Unwind_Resume(a1);
    }
  }
  else if (!v47)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v46);
  goto LABEL_6;
}

uint64_t std::function<short ()(short,short)>::operator()(uint64_t a1, __int16 a2, __int16 a3)
{
  __int16 v6 = a2;
  __int16 v5 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, __int16 *, __int16 *))(*(void *)v3 + 48))(v3, &v6, &v5);
}

void MIL::ValueInference::Tensor<short>::Zeros(MIL *a1@<X0>, const MIL::IRTensorValueType *a2@<X1>, uint64_t a3@<X8>)
{
  MIL::GetTensorShapeWithDimensionsAllKnown(a1, a2, (uint64_t)v6);
  *(_OWORD *)__n128 __p = *(_OWORD *)v6;
  uint64_t v5 = v7;
  v6[1] = 0;
  uint64_t v7 = 0;
  v6[0] = 0;
  MIL::ValueInference::Tensor<short>::Zeros((__n128 *)__p, a3);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v6[0])
  {
    v6[1] = v6[0];
    operator delete(v6[0]);
  }
}

void sub_20F4CAD38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  if (__p) {
    operator delete(__p);
  }
  if (a13) {
    operator delete(a13);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<int>::FromIRTensorValue(void *a1@<X0>, uint64_t a2@<X8>)
{
  MIL::IRTensorValue::TryGetDataView<int>(&v12, *a1);
  if (!(_BYTE)v12)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Failed to get data view.");
    uint64_t v7 = (struct type_info *)MEMORY[0x263F8C1F0];
    unint64_t v8 = (void (*)(void *))MEMORY[0x263F8C070];
    goto LABEL_10;
  }
  unint64_t v4 = (MIL *)(*(uint64_t (**)(void))(*(void *)*a1 + 32))();
  if ((*(unsigned int (**)(MIL *))(*(void *)v4 + 88))(v4) == 3)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100]((std::logic_error *)exception, "It is not supported to convert a tensor of string dtype.");
    uint64_t v7 = (struct type_info *)off_26412C1F0;
    unint64_t v8 = (void (*)(void *))MEMORY[0x263F8C080];
LABEL_10:
    __cxa_throw(exception, v7, v8);
  }
  MIL::GetTensorShapeWithDimensionsAllKnown(v4, v5, (uint64_t)&v11);
  uint64_t v10 = 0;
  __n128 __p = 0uLL;
  std::vector<int>::__init_with_size[abi:ne180100]<int const*,int const*>(&__p, v13, (uint64_t)v13 + 4 * v14, v14);
  MIL::ValueInference::Tensor<int>::Tensor(a2, &v11, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v11.n128_u64[0])
  {
    v11.n128_u64[1] = v11.n128_u64[0];
    operator delete((void *)v11.n128_u64[0]);
  }
}

void sub_20F4CAEB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  __cxa_free_exception(v14);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<int>::ToIRTensorValue(uint64_t a1, MIL::IRConstantDimension *a2)
{
  memset(__p, 0, sizeof(__p));
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(__p, *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3);
  MIL::IRTensorValueType::Make(a2, 11, (MIL::MILContext ***)__p);
}

void sub_20F4CAFC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::ValueInference::Tensor<int>::Tensor(uint64_t a1, __n128 *a2, __n128 *a3)
{
  *(_OWORD *)(a1 + 8) = 0u;
  uint64_t v5 = a1 + 8;
  *(void *)a1 = &unk_26C25DBC8;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  __int16 v6 = (uint64_t *)a2->n128_u64[0];
  uint64_t v7 = (uint64_t *)a2->n128_u64[1];
  if ((uint64_t *)a2->n128_u64[0] == v7)
  {
    unint64_t v10 = a3->n128_u64[0];
    unint64_t v11 = a3->n128_u64[1];
    uint64_t v8 = a3->n128_u64[0] != v11;
  }
  else
  {
    uint64_t v8 = 1;
    do
    {
      uint64_t v9 = *v6++;
      v8 *= v9;
    }
    while (v6 != v7);
    unint64_t v10 = a3->n128_u64[0];
    unint64_t v11 = a3->n128_u64[1];
  }
  if (v8 != (uint64_t)(v11 - v10) >> 2)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "data size and shape dismatch.");
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  std::vector<float>::__move_assign(v5, a2);
  std::vector<float>::__move_assign(a1 + 32, a3);
  *(void *)(a1 + 56) = v8;
  return a1;
}

void sub_20F4CB0F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10)
{
  uint64_t v13 = *v11;
  if (*v11)
  {
    *(void *)(v10 + 40) = v13;
    operator delete(v13);
  }
  unint64_t v14 = *a10;
  if (*a10)
  {
    *(void *)(v10 + 16) = v14;
    operator delete(v14);
  }
  _Unwind_Resume(exception_object);
}

double MIL::ValueInference::Tensor<int>::Tensor(uint64_t a1)
{
  *(void *)a1 = &unk_26C25DBC8;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  return result;
}

void MIL::ValueInference::Tensor<int>::ForEach(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v13[4] = *MEMORY[0x263EF8340];
  std::vector<int>::size_type v6 = (uint64_t)(*(void *)(a1 + 40) - *(void *)(a1 + 32)) >> 2;
  __x.n128_u32[0] = 0;
  std::vector<int>::vector(&v12, v6, (const std::vector<int>::value_type *)&__x);
  __n128 __x = 0uLL;
  uint64_t v11 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__x, *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3);
  uint64_t v8 = *(int **)(a1 + 32);
  uint64_t v7 = *(int **)(a1 + 40);
  std::vector<int>::pointer begin = v12.__begin_;
  std::__function::__value_func<int ()(int)>::__value_func[abi:ne180100]((uint64_t)v13, a2);
  while (v8 != v7)
    *begin++ = std::function<int ()(int)>::operator()((uint64_t)v13, *v8++);
  std::__function::__value_func<int ()(int)>::~__value_func[abi:ne180100](v13);
  MIL::ValueInference::Tensor<int>::Tensor(a3, &__x, (__n128 *)&v12);
  if (__x.n128_u64[0])
  {
    __x.n128_u64[1] = __x.n128_u64[0];
    operator delete((void *)__x.n128_u64[0]);
  }
  if (v12.__begin_)
  {
    v12.__end_ = v12.__begin_;
    operator delete(v12.__begin_);
  }
}

void sub_20F4CB278(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, char a16)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::ValueInference::Tensor<int>::GetScalarData(void *a1)
{
  if (a1[1] != a1[2] || (uint64_t v1 = (unsigned int *)a1[4], a1[5] - (void)v1 != 4))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Tensor is not a scalar.");
    __cxa_throw(exception, MEMORY[0x263F8C1E0], MEMORY[0x263F8C048]);
  }
  return *v1;
}

void sub_20F4CB338(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<int>::Reshape(void *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  std::vector<int>::size_type v6 = (uint64_t *)*a2;
  uint64_t v7 = a2[1];
  uint64_t v8 = 1;
  if (v6 != (uint64_t *)v7)
  {
    uint64_t v9 = v6;
    do
    {
      uint64_t v10 = *v9++;
      v8 *= v10;
    }
    while (v9 != (uint64_t *)v7);
  }
  if (a1[7] != v8)
  {
    uint64_t v13 = a2;
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v22);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"Tensor is not able to be reshaped since the number of elements in the newShape [ ", 81);
    uint64_t v14 = *v13;
    uint64_t v15 = v13[1];
    if (*v13 != v15)
    {
      do
      {
        uint64_t v16 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)" ", 1);
        v14 += 8;
      }
      while (v14 != v15);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"] is not the same as the number of elements in the tensor shape [ ", 66);
    uint64_t v17 = a1[1];
    for (uint64_t i = a1[2]; v17 != i; v17 += 8)
    {
      unint64_t v19 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)" ", 1);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"].", 2);
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str();
    std::logic_error::logic_error(exception, &__p);
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  __n128 v22 = 0uLL;
  uint64_t v23 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v22, v6, v7, (v7 - (uint64_t)v6) >> 3);
  uint64_t v11 = (const void *)a1[4];
  uint64_t v12 = a1[5];
  memset(&__p, 0, sizeof(__p));
  std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(&__p, v11, v12, (v12 - (uint64_t)v11) >> 2);
  MIL::ValueInference::Tensor<int>::Tensor(a3, &v22, (__n128 *)&__p);
  if (__p.__r_.__value_.__r.__words[0])
  {
    __p.__r_.__value_.__l.__size_ = __p.__r_.__value_.__r.__words[0];
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v22.n128_u64[0])
  {
    v22.n128_u64[1] = v22.n128_u64[0];
    operator delete((void *)v22.n128_u64[0]);
  }
}

void sub_20F4CB54C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((v17 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v17)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v16);
  goto LABEL_6;
}

void MIL::ValueInference::Tensor<int>::NonZero(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v3 = *(void *)(a1 + 56);
  if (v3)
  {
    unint64_t v5 = 0;
    std::vector<int>::size_type v6 = (uint64_t **)(a1 + 8);
    do
    {
      if (*(_DWORD *)(*(void *)(a1 + 32) + 4 * v5))
      {
        std::vector<std::vector<unsigned long long>>::push_back[abi:ne180100](a2, (uint64_t)__p);
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
        unint64_t v3 = *(void *)(a1 + 56);
      }
      ++v5;
    }
    while (v5 < v3);
  }
}

void sub_20F4CB660(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
}

void MIL::ValueInference::Tensor<int>::SubTensor(void *a1@<X0>, uint64_t **a2@<X1>, void *a3@<X8>)
{
  unint64_t v5 = ((char *)a2[1] - (char *)*a2) >> 4;
  std::vector<int>::size_type v6 = a1 + 1;
  if (v5 != (uint64_t)(a1[2] - a1[1]) >> 3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "Indices does not match the rank of the tensor.");
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  std::string __p = 0;
  uint64_t v46 = 0;
  int v47 = 0;
  std::vector<unsigned long long>::reserve(&__p, v5);
  uint64_t v8 = a1[1];
  if (a1[2] != v8)
  {
    unint64_t v9 = 0;
    while (1)
    {
      unint64_t v11 = (*a2)[2 * v9];
      unint64_t v10 = (*a2)[2 * v9 + 1];
      unint64_t v12 = v10 - v11;
      if (v10 < v11) {
        break;
      }
      if (v10 > *(void *)(v8 + 8 * v9))
      {
        uint64_t v33 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(v33, "Indices end is out of the bound for the tensor dimension.");
        unint64_t v34 = (void (*)(void *))MEMORY[0x263F8C068];
        int64_t v35 = (struct type_info *)off_26412C1E0;
        uint64_t v36 = MEMORY[0x263F8C390] + 16;
LABEL_45:
        v33->__vftable = (std::logic_error_vtbl *)v36;
        __cxa_throw(v33, v35, v34);
      }
      uint64_t v13 = v46;
      if (v46 >= v47)
      {
        uint64_t v15 = (char *)__p;
        uint64_t v16 = (v46 - (unsigned char *)__p) >> 3;
        unint64_t v17 = v16 + 1;
        if ((unint64_t)(v16 + 1) >> 61) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v18 = v47 - (unsigned char *)__p;
        if ((v47 - (unsigned char *)__p) >> 2 > v17) {
          unint64_t v17 = v18 >> 2;
        }
        if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v19 = v17;
        }
        if (v19)
        {
          unint64_t v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v47, v19);
          uint64_t v15 = (char *)__p;
          uint64_t v13 = v46;
        }
        else
        {
          unint64_t v20 = 0;
        }
        size_t v21 = &v20[8 * v16];
        *(void *)size_t v21 = v12;
        uint64_t v14 = (uint64_t)(v21 + 8);
        while (v13 != v15)
        {
          uint64_t v22 = *((void *)v13 - 1);
          v13 -= 8;
          *((void *)v21 - 1) = v22;
          v21 -= 8;
        }
        std::string __p = v21;
        uint64_t v46 = (char *)v14;
        int v47 = &v20[8 * v19];
        if (v15) {
          operator delete(v15);
        }
      }
      else
      {
        *(void *)uint64_t v46 = v12;
        uint64_t v14 = (uint64_t)(v13 + 8);
      }
      uint64_t v46 = (char *)v14;
      ++v9;
      uint64_t v8 = a1[1];
      if (v9 >= (a1[2] - v8) >> 3) {
        goto LABEL_25;
      }
    }
    uint64_t v33 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v33, "Indices end must not be smaller than the indices begin.");
    unint64_t v34 = (void (*)(void *))MEMORY[0x263F8C080];
    int64_t v35 = (struct type_info *)off_26412C1F0;
    uint64_t v36 = MEMORY[0x263F8C3A0] + 16;
    goto LABEL_45;
  }
  uint64_t v14 = (uint64_t)v46;
LABEL_25:
  __n128 v43 = 0uLL;
  uint64_t v44 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v43, __p, v14, (v14 - (uint64_t)__p) >> 3);
  MIL::ValueInference::Tensor<int>::Zeros(&v43, (uint64_t)a3);
  if (v43.n128_u64[0])
  {
    v43.n128_u64[1] = v43.n128_u64[0];
    operator delete((void *)v43.n128_u64[0]);
  }
  uint64_t v23 = a3[5] - a3[4];
  if (v23)
  {
    unint64_t v24 = 0;
    unint64_t v25 = v23 >> 2;
    if (v25 <= 1) {
      uint64_t v26 = 1;
    }
    else {
      uint64_t v26 = v25;
    }
    do
    {
      std::string::size_type v38 = 0;
      uint64_t v39 = 0;
      uint64_t v40 = 0;
      std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v38, v41, (uint64_t)v42, (v42 - (unsigned char *)v41) >> 3);
      uint64_t v27 = a1[2] - a1[1];
      if (v27)
      {
        unint64_t v28 = v27 >> 3;
        uint64_t v29 = *a2;
        uint64_t v30 = v38;
        if (v28 <= 1) {
          unint64_t v28 = 1;
        }
        do
        {
          uint64_t v31 = *v29;
          v29 += 2;
          *v30++ += v31;
          --v28;
        }
        while (v28);
      }
      if (v38)
      {
        uint64_t v39 = v38;
        operator delete(v38);
      }
      if (v41)
      {
        uint64_t v42 = v41;
        operator delete(v41);
      }
      ++v24;
    }
    while (v24 != v26);
  }
  if (__p)
  {
    uint64_t v46 = (char *)__p;
    operator delete(__p);
  }
}

void sub_20F4CBA14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19)
{
  __cxa_free_exception(v19);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<int>::Zeros(__n128 *a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t v4 = (uint64_t *)a1->n128_u64[0];
  std::vector<int>::size_type v5 = 1;
  while (v4 != (uint64_t *)a1->n128_u64[1])
  {
    uint64_t v6 = *v4++;
    v5 *= v6;
  }
  std::vector<int>::vector(&v7, v5);
  MIL::ValueInference::Tensor<int>::Tensor(a2, a1, (__n128 *)&v7);
  if (v7.__begin_)
  {
    v7.__end_ = v7.__begin_;
    operator delete(v7.__begin_);
  }
}

void sub_20F4CBB28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<int>::Concat(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *a1;
  uint64_t v7 = 0;
  uint64_t v8 = a1[1] - *a1;
  if (v8)
  {
    unint64_t v9 = v8 >> 6;
    if (v9 <= 1) {
      unint64_t v9 = 1;
    }
    unint64_t v10 = (uint64_t *)(v6 + 8);
    do
    {
      uint64_t v11 = *v10;
      v10 += 8;
      v7 += *(void *)(v11 + 8 * a2);
      --v9;
    }
    while (v9);
  }
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  unint64_t v28 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v28, *(const void **)(v6 + 8), *(void *)(v6 + 16), (uint64_t)(*(void *)(v6 + 16) - *(void *)(v6 + 8)) >> 3);
  unint64_t v12 = v28;
  *((void *)v28 + a2) = v7;
  uint64_t v27 = 0;
  __n128 __p = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, v12, (uint64_t)v29, (v29 - (unsigned char *)v12) >> 3);
  MIL::ValueInference::Tensor<int>::Zeros(&__p, a3);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  uint64_t v13 = *a1;
  uint64_t v14 = a1[1];
  if (v14 != *a1)
  {
    unint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(void *)(v13 + (v15 << 6) + 40) - *(void *)(v13 + (v15 << 6) + 32);
      if (v17)
      {
        unint64_t v18 = 0;
        if ((unint64_t)(v17 >> 2) <= 1) {
          uint64_t v19 = 1;
        }
        else {
          uint64_t v19 = v17 >> 2;
        }
        do
        {
          size_t v21 = 0;
          uint64_t v22 = 0;
          uint64_t v23 = 0;
          std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v21, v24, (uint64_t)v25, (v25 - (unsigned char *)v24) >> 3);
          *((void *)v21 + a2) += v16;
          unint64_t v20 = *a1 + (v15 << 6);
          LODWORD(v20) = *(_DWORD *)(*(void *)(v20 + 32)
          *(_DWORD *)(*(void *)(a3 + 32)
          if (v21)
          {
            uint64_t v22 = v21;
            operator delete(v21);
          }
          if (v24)
          {
            unint64_t v25 = v24;
            operator delete(v24);
          }
          ++v18;
        }
        while (v19 != v18);
        uint64_t v13 = *a1;
        uint64_t v14 = a1[1];
      }
      v16 += *(void *)(*(void *)(v13 + (v15++ << 6) + 8) + 8 * a2);
    }
    while (v15 < (v14 - v13) >> 6);
  }
  if (v28)
  {
    uint64_t v29 = v28;
    operator delete(v28);
  }
}

void sub_20F4CBD30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  if (a18) {
    operator delete(a18);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<int>::BlockwiseMerge(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *(uint64_t **)a2;
  uint64_t v7 = *(void *)(a2 + 8) - *(void *)a2;
  if (v7)
  {
    unint64_t v8 = v7 >> 3;
    if (v8 <= 1) {
      unint64_t v8 = 1;
    }
    uint64_t v9 = 1;
    do
    {
      uint64_t v10 = *v6++;
      v9 *= v10;
      --v8;
    }
    while (v8);
  }
  else
  {
    uint64_t v9 = 1;
  }
  uint64_t v11 = *a1;
  if (v9 != (a1[1] - *a1) >> 6)
  {
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v48);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v48, (uint64_t)"The number of tensors (", 23);
    uint64_t v36 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v36, (uint64_t)") is not the same as the number of blocks (", 43);
    unint64_t v37 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v37, (uint64_t)").", 2);
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str();
    std::runtime_error::runtime_error(exception, &v47);
    __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
  }
  unint64_t v49 = 0;
  uint64_t v50 = 0;
  uint64_t v48 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v48, *(const void **)(v11 + 8), *(void *)(v11 + 16), (uint64_t)(*(void *)(v11 + 16) - *(void *)(v11 + 8)) >> 3);
  memset(&v47, 0, sizeof(v47));
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v47, v48, (uint64_t)v49, (v49 - (unsigned char *)v48) >> 3);
  unint64_t v12 = *(uint64_t **)a2;
  uint64_t v13 = (const void *)v47.__r_.__value_.__r.__words[0];
  uint64_t v14 = *(void *)(a2 + 8) - *(void *)a2;
  if (v14)
  {
    unint64_t v15 = v14 >> 3;
    if (v15 <= 1) {
      unint64_t v15 = 1;
    }
    uint64_t v16 = (void *)v47.__r_.__value_.__r.__words[0];
    do
    {
      uint64_t v17 = *v12++;
      *v16++ *= v17;
      --v15;
    }
    while (v15);
  }
  __n128 __p = 0uLL;
  uint64_t v46 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, v13, v47.__r_.__value_.__l.__size_, (uint64_t)(v47.__r_.__value_.__l.__size_ - (void)v13) >> 3);
  MIL::ValueInference::Tensor<int>::Zeros(&__p, a3);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v9)
  {
    for (unint64_t i = 0; i != v9; ++i)
    {
      unint64_t v19 = *a1 + (i << 6);
      unint64_t v20 = *(const void **)(v19 + 8);
      size_t v21 = *(void *)(v19 + 16) - (void)v20;
      if (v21 != v49 - (unsigned char *)v48 || memcmp(v20, v48, v21))
      {
        int64_t v35 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v35, "All tensors must have the same shape so they can be merged.");
        __cxa_throw(v35, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
      }
      uint64_t v22 = *(void *)(*a1 + (i << 6) + 40) - *(void *)(*a1 + (i << 6) + 32);
      if (v22)
      {
        unint64_t v23 = 0;
        unint64_t v24 = v22 >> 2;
        if (v24 <= 1) {
          uint64_t v25 = 1;
        }
        else {
          uint64_t v25 = v24;
        }
        do
        {
          uint64_t v39 = 0;
          uint64_t v40 = 0;
          uint64_t v41 = 0;
          std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v39, v42, (uint64_t)v43, (v43 - (unsigned char *)v42) >> 3);
          uint64_t v26 = *(void *)(a2 + 8) - *(void *)a2;
          if (v26)
          {
            unint64_t v27 = v26 >> 3;
            unint64_t v28 = (uint64_t *)v48;
            uint64_t v29 = (uint64_t *)v44[0];
            uint64_t v30 = v39;
            if (v27 <= 1) {
              unint64_t v27 = 1;
            }
            do
            {
              uint64_t v32 = *v28++;
              uint64_t v31 = v32;
              uint64_t v33 = *v29++;
              *v30++ += v33 * v31;
              --v27;
            }
            while (v27);
          }
          unint64_t v34 = *a1 + (i << 6);
          LODWORD(v34) = *(_DWORD *)(*(void *)(v34 + 32)
          *(_DWORD *)(*(void *)(a3 + 32)
          if (v39)
          {
            uint64_t v40 = v39;
            operator delete(v39);
          }
          if (v42)
          {
            __n128 v43 = v42;
            operator delete(v42);
          }
          ++v23;
        }
        while (v23 != v25);
      }
      if (v44[0])
      {
        v44[1] = v44[0];
        operator delete(v44[0]);
      }
    }
  }
  if (v47.__r_.__value_.__r.__words[0])
  {
    v47.__r_.__value_.__l.__size_ = v47.__r_.__value_.__r.__words[0];
    operator delete(v47.__r_.__value_.__l.__data_);
  }
  if (v48)
  {
    unint64_t v49 = v48;
    operator delete(v48);
  }
}

void sub_20F4CC138(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28)
{
  if (a26 < 0)
  {
    operator delete(__p);
    if ((v29 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a27);
      _Unwind_Resume(a1);
    }
  }
  else if (!v29)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v28);
  goto LABEL_6;
}

uint64_t MIL::ValueInference::Tensor<int>::Reduce@<X0>(void *a1@<X0>, unint64_t **a2@<X1>, int a3@<W2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v103 = a1[1];
  char v104 = a1 + 1;
  uint64_t v102 = a1[2];
  unint64_t v7 = (v102 - v103) >> 3;
  std::unordered_set<unsigned long long>::unordered_set<std::__wrap_iter<unsigned long long const*>>((uint64_t)v122, *a2, a2[1]);
  for (unint64_t i = v123; i; unint64_t i = (void *)*i)
  {
    if (i[2] >= v7)
    {
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&__p);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&__p, (uint64_t)"axis(", 5);
      uint64_t v91 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v91, (uint64_t)") must be smaller than the number of input dimensions(", 54);
      uint64_t v92 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v92, (uint64_t)").", 2);
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::stringbuf::str();
      std::logic_error::logic_error(exception, &v118);
      exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
      __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
    }
  }
  __n128 __p = 0;
  std::string v120 = 0;
  v121[0] = 0;
  memset(&v118, 0, sizeof(v118));
  __n128 v115 = 0;
  std::string v116 = 0;
  std::string v117 = 0;
  if (v102 == v103)
  {
    uint64_t v55 = 0;
    uint64_t v54 = 0;
  }
  else
  {
    uint64_t v9 = 0;
    std::vector<int>::size_type v5 = &v117;
    if (v7 <= 1) {
      uint64_t v10 = 1;
    }
    else {
      uint64_t v10 = (v102 - v103) >> 3;
    }
    do
    {
      v112[0] = v9;
      if (std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(v122, (unint64_t *)v112))
      {
        if (a3)
        {
          uint64_t v11 = v120;
          if ((unint64_t)v120 >= v121[0])
          {
            uint64_t v22 = (char *)__p;
            uint64_t v23 = (v120 - (unsigned char *)__p) >> 3;
            unint64_t v24 = v23 + 1;
            if ((unint64_t)(v23 + 1) >> 61) {
              std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v25 = v121[0] - (void)__p;
            if ((uint64_t)(v121[0] - (void)__p) >> 2 > v24) {
              unint64_t v24 = v25 >> 2;
            }
            if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v26 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v26 = v24;
            }
            if (v26)
            {
              unint64_t v27 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)v121, v26);
              uint64_t v22 = (char *)__p;
              uint64_t v11 = v120;
            }
            else
            {
              unint64_t v27 = 0;
            }
            uint64_t v41 = &v27[8 * v23];
            *(void *)uint64_t v41 = 1;
            unint64_t v12 = v41 + 8;
            while (v11 != v22)
            {
              uint64_t v42 = *((void *)v11 - 1);
              v11 -= 8;
              *((void *)v41 - 1) = v42;
              v41 -= 8;
            }
            __n128 __p = v41;
            std::string v120 = v12;
            v121[0] = &v27[8 * v26];
            if (v22) {
              operator delete(v22);
            }
          }
          else
          {
            *(void *)std::string v120 = 1;
            unint64_t v12 = v11 + 8;
          }
          std::string v120 = v12;
        }
        uint64_t v43 = *v104;
        uint64_t v44 = v116;
        if (v116 >= v117)
        {
          uint64_t v46 = (char *)v115;
          uint64_t v47 = (v116 - (unsigned char *)v115) >> 3;
          unint64_t v48 = v47 + 1;
          if ((unint64_t)(v47 + 1) >> 61) {
LABEL_153:
          }
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          uint64_t v49 = v117 - (unsigned char *)v115;
          if ((v117 - (unsigned char *)v115) >> 2 > v48) {
            unint64_t v48 = v49 >> 2;
          }
          if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v50 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v50 = v48;
          }
          if (v50)
          {
            uint64_t v51 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v117, v50);
            uint64_t v46 = (char *)v115;
            uint64_t v44 = v116;
          }
          else
          {
            uint64_t v51 = 0;
          }
          uint64_t v52 = &v51[8 * v47];
          *(void *)uint64_t v52 = *(void *)(v43 + 8 * (void)v9);
          uint64_t v45 = v52 + 8;
          while (v44 != v46)
          {
            uint64_t v53 = *((void *)v44 - 1);
            v44 -= 8;
            *((void *)v52 - 1) = v53;
            v52 -= 8;
          }
          __n128 v115 = v52;
          std::string v116 = v45;
          std::string v117 = &v51[8 * v50];
          if (v46) {
            operator delete(v46);
          }
        }
        else
        {
          *(void *)std::string v116 = *(void *)(v43 + 8 * (void)v9);
          uint64_t v45 = v44 + 8;
        }
        std::string v116 = v45;
      }
      else
      {
        uint64_t v13 = *v104;
        uint64_t v14 = v120;
        if ((unint64_t)v120 >= v121[0])
        {
          uint64_t v16 = (char *)__p;
          uint64_t v17 = (v120 - (unsigned char *)__p) >> 3;
          unint64_t v18 = v17 + 1;
          if ((unint64_t)(v17 + 1) >> 61) {
            goto LABEL_153;
          }
          uint64_t v19 = v121[0] - (void)__p;
          if ((uint64_t)(v121[0] - (void)__p) >> 2 > v18) {
            unint64_t v18 = v19 >> 2;
          }
          if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v20 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v20 = v18;
          }
          if (v20)
          {
            size_t v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)v121, v20);
            uint64_t v16 = (char *)__p;
            uint64_t v14 = v120;
          }
          else
          {
            size_t v21 = 0;
          }
          unint64_t v28 = &v21[8 * v17];
          *(void *)unint64_t v28 = *(void *)(v13 + 8 * (void)v9);
          unint64_t v15 = v28 + 8;
          while (v14 != v16)
          {
            uint64_t v29 = *((void *)v14 - 1);
            v14 -= 8;
            *((void *)v28 - 1) = v29;
            v28 -= 8;
          }
          __n128 __p = v28;
          std::string v120 = v15;
          v121[0] = &v21[8 * v20];
          if (v16) {
            operator delete(v16);
          }
        }
        else
        {
          *(void *)std::string v120 = *(void *)(v13 + 8 * (void)v9);
          unint64_t v15 = v14 + 8;
        }
        std::string v120 = v15;
        uint64_t v30 = *v104;
        std::string::size_type size = v118.__r_.__value_.__l.__size_;
        if (v118.__r_.__value_.__l.__size_ >= v118.__r_.__value_.__r.__words[2])
        {
          uint64_t v33 = (void *)v118.__r_.__value_.__r.__words[0];
          uint64_t v34 = (uint64_t)(v118.__r_.__value_.__l.__size_ - v118.__r_.__value_.__r.__words[0]) >> 3;
          unint64_t v35 = v34 + 1;
          if ((unint64_t)(v34 + 1) >> 61) {
            goto LABEL_153;
          }
          int64_t v36 = v118.__r_.__value_.__r.__words[2] - v118.__r_.__value_.__r.__words[0];
          if ((uint64_t)(v118.__r_.__value_.__r.__words[2] - v118.__r_.__value_.__r.__words[0]) >> 2 > v35) {
            unint64_t v35 = v36 >> 2;
          }
          if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v37 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v37 = v35;
          }
          if (v37)
          {
            std::string::size_type v38 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v118.__r_.__value_.__r.__words[2], v37);
            std::string::size_type size = v118.__r_.__value_.__l.__size_;
            uint64_t v33 = (void *)v118.__r_.__value_.__r.__words[0];
          }
          else
          {
            std::string::size_type v38 = 0;
          }
          uint64_t v39 = &v38[8 * v34];
          *(void *)uint64_t v39 = *(void *)(v30 + 8 * (void)v9);
          std::string::size_type v32 = (std::string::size_type)(v39 + 8);
          while ((void *)size != v33)
          {
            uint64_t v40 = *(void *)(size - 8);
            size -= 8;
            *((void *)v39 - 1) = v40;
            v39 -= 8;
          }
          v118.__r_.__value_.__r.__words[0] = (std::string::size_type)v39;
          v118.__r_.__value_.__l.__size_ = v32;
          v118.__r_.__value_.__r.__words[2] = (std::string::size_type)&v38[8 * v37];
          if (v33) {
            operator delete(v33);
          }
        }
        else
        {
          *(void *)v118.__r_.__value_.__l.__size_ = *(void *)(v30 + 8 * (void)v9);
          std::string::size_type v32 = size + 8;
        }
        v118.__r_.__value_.__l.__size_ = v32;
      }
      uint64_t v9 = (char *)v9 + 1;
    }
    while (v9 != (void *)v10);
    uint64_t v54 = __p;
    uint64_t v55 = (uint64_t)v120;
  }
  __n128 v113 = 0uLL;
  uint64_t v114 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v113, v54, v55, (v55 - (uint64_t)v54) >> 3);
  MIL::ValueInference::Tensor<int>::Zeros(&v113, a5);
  if (v113.n128_u64[0])
  {
    v113.n128_u64[1] = v113.n128_u64[0];
    operator delete((void *)v113.n128_u64[0]);
  }
  uint64_t v56 = *(void *)(a5 + 40) - *(void *)(a5 + 32);
  if (v56)
  {
    unint64_t v57 = 0;
    unint64_t v58 = v56 >> 2;
    unint64_t v95 = v56 >> 2;
    unint64_t v96 = (uint64_t)(a1[5] - a1[4]) >> 2;
    unint64_t v59 = v96 / (v56 >> 2);
    uint64_t v60 = (uint64_t **)(a5 + 8);
    if (v7 <= 1) {
      uint64_t v61 = 1;
    }
    else {
      uint64_t v61 = (v102 - v103) >> 3;
    }
    if (v58 <= 1) {
      uint64_t v62 = 1;
    }
    else {
      uint64_t v62 = v58;
    }
    uint64_t v94 = v62;
    if (v59 <= 1) {
      unint64_t v59 = 1;
    }
    unint64_t v100 = v59;
    do
    {
      unint64_t v98 = v57;
      LODWORD(v5) = v5 & 0xFFFFFF00;
      if (v95 <= v96)
      {
        unint64_t v63 = 0;
        char v64 = 1;
        do
        {
          int v105 = (int)v5;
          uint64_t v107 = 0;
          unint64_t v108 = 0;
          uint64_t v109 = 0;
          if (v102 != v103)
          {
            unint64_t v65 = 0;
            uint64_t v66 = 0;
            uint64_t v67 = 0;
            do
            {
              unint64_t v106 = v65;
              uint64_t v68 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(v122, &v106);
              uint64_t v69 = v108;
              if (v68)
              {
                uint64_t v70 = v110;
                if (v108 >= v109)
                {
                  unint64_t v74 = (char *)v107;
                  uint64_t v75 = (v108 - (unsigned char *)v107) >> 3;
                  unint64_t v76 = v75 + 1;
                  if ((unint64_t)(v75 + 1) >> 61) {
                    goto LABEL_151;
                  }
                  uint64_t v77 = v109 - (unsigned char *)v107;
                  if ((v109 - (unsigned char *)v107) >> 2 > v76) {
                    unint64_t v76 = v77 >> 2;
                  }
                  if ((unint64_t)v77 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v78 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v78 = v76;
                  }
                  if (v78)
                  {
                    uint64_t v79 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v109, v78);
                    unint64_t v74 = (char *)v107;
                    uint64_t v69 = v108;
                  }
                  else
                  {
                    uint64_t v79 = 0;
                  }
                  uint64_t v86 = &v79[8 * v75];
                  *(void *)uint64_t v86 = v70[v66];
                  uint64_t v71 = v86 + 8;
                  while (v69 != v74)
                  {
                    uint64_t v87 = *((void *)v69 - 1);
                    v69 -= 8;
                    *((void *)v86 - 1) = v87;
                    v86 -= 8;
                  }
                  uint64_t v107 = v86;
                  unint64_t v108 = v71;
                  uint64_t v109 = &v79[8 * v78];
                  if (v74) {
                    operator delete(v74);
                  }
                }
                else
                {
                  *(void *)unint64_t v108 = *((void *)v110 + v66);
                  uint64_t v71 = v69 + 8;
                }
                unint64_t v108 = v71;
                ++v66;
              }
              else
              {
                uint64_t v72 = v112[0];
                if (v108 >= v109)
                {
                  unint64_t v80 = (char *)v107;
                  uint64_t v81 = (v108 - (unsigned char *)v107) >> 3;
                  unint64_t v82 = v81 + 1;
                  if ((unint64_t)(v81 + 1) >> 61) {
LABEL_151:
                  }
                    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
                  uint64_t v83 = v109 - (unsigned char *)v107;
                  if ((v109 - (unsigned char *)v107) >> 2 > v82) {
                    unint64_t v82 = v83 >> 2;
                  }
                  if ((unint64_t)v83 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v84 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v84 = v82;
                  }
                  if (v84)
                  {
                    uint64_t v85 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v109, v84);
                    unint64_t v80 = (char *)v107;
                    uint64_t v69 = v108;
                  }
                  else
                  {
                    uint64_t v85 = 0;
                  }
                  int v88 = &v85[8 * v81];
                  *(void *)int v88 = v72[v67];
                  uint64_t v73 = v88 + 8;
                  while (v69 != v80)
                  {
                    uint64_t v89 = *((void *)v69 - 1);
                    v69 -= 8;
                    *((void *)v88 - 1) = v89;
                    v88 -= 8;
                  }
                  uint64_t v107 = v88;
                  unint64_t v108 = v73;
                  uint64_t v109 = &v85[8 * v84];
                  if (v80) {
                    operator delete(v80);
                  }
                }
                else
                {
                  *(void *)unint64_t v108 = *((void *)v112[0] + v67);
                  uint64_t v73 = v69 + 8;
                }
                unint64_t v108 = v73;
                ++v67;
              }
              ++v65;
            }
            while (v65 != v61);
          }
          if ((v64 & 1) == 0) {
            LODWORD(v5) = std::function<int ()(int,int)>::operator()(a4, v105, (int)v5);
          }
          uint64_t v60 = (uint64_t **)(a5 + 8);
          if (v107)
          {
            unint64_t v108 = (char *)v107;
            operator delete(v107);
          }
          if (v110)
          {
            __n128 v111 = v110;
            operator delete(v110);
          }
          char v64 = 0;
          ++v63;
        }
        while (v63 != v100);
      }
      if (v110)
      {
        __n128 v111 = v110;
        operator delete(v110);
      }
      if (v112[0])
      {
        v112[1] = v112[0];
        operator delete(v112[0]);
      }
      unint64_t v57 = v98 + 1;
    }
    while (v98 + 1 != v94);
  }
  if (v115)
  {
    std::string v116 = (char *)v115;
    operator delete(v115);
  }
  if (v118.__r_.__value_.__r.__words[0])
  {
    v118.__r_.__value_.__l.__size_ = v118.__r_.__value_.__r.__words[0];
    operator delete(v118.__r_.__value_.__l.__data_);
  }
  if (__p)
  {
    std::string v120 = (char *)__p;
    operator delete(__p);
  }
  return std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table((uint64_t)v122);
}

void sub_20F4CCA68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37,uint64_t a38,void *__p,uint64_t a40,int a41,__int16 a42,char a43,char a44,void *a45,uint64_t a46)
{
  if (a44 < 0)
  {
    operator delete(__p);
    if ((v47 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a45);
      std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table(v48 - 128);
      _Unwind_Resume(a1);
    }
  }
  else if (!v47)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v46);
  goto LABEL_6;
}

uint64_t std::function<int ()(int,int)>::operator()(uint64_t a1, int a2, int a3)
{
  int v6 = a2;
  int v5 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, int *, int *))(*(void *)v3 + 48))(v3, &v6, &v5);
}

void MIL::ValueInference::Tensor<int>::Zeros(MIL *a1@<X0>, const MIL::IRTensorValueType *a2@<X1>, uint64_t a3@<X8>)
{
  MIL::GetTensorShapeWithDimensionsAllKnown(a1, a2, (uint64_t)v6);
  *(_OWORD *)__n128 __p = *(_OWORD *)v6;
  uint64_t v5 = v7;
  v6[1] = 0;
  uint64_t v7 = 0;
  v6[0] = 0;
  MIL::ValueInference::Tensor<int>::Zeros((__n128 *)__p, a3);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v6[0])
  {
    v6[1] = v6[0];
    operator delete(v6[0]);
  }
}

void sub_20F4CCC58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  if (__p) {
    operator delete(__p);
  }
  if (a13) {
    operator delete(a13);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<long long>::FromIRTensorValue(void *a1@<X0>, uint64_t a2@<X8>)
{
  MIL::IRTensorValue::TryGetDataView<long long>(&v12, *a1);
  if (!(_BYTE)v12)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Failed to get data view.");
    uint64_t v7 = (struct type_info *)MEMORY[0x263F8C1F0];
    unint64_t v8 = (void (*)(void *))MEMORY[0x263F8C070];
    goto LABEL_10;
  }
  unint64_t v4 = (MIL *)(*(uint64_t (**)(void))(*(void *)*a1 + 32))();
  if ((*(unsigned int (**)(MIL *))(*(void *)v4 + 88))(v4) == 3)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100]((std::logic_error *)exception, "It is not supported to convert a tensor of string dtype.");
    uint64_t v7 = (struct type_info *)off_26412C1F0;
    unint64_t v8 = (void (*)(void *))MEMORY[0x263F8C080];
LABEL_10:
    __cxa_throw(exception, v7, v8);
  }
  MIL::GetTensorShapeWithDimensionsAllKnown(v4, v5, (uint64_t)&v11);
  uint64_t v10 = 0;
  __n128 __p = 0uLL;
  std::vector<long long>::__init_with_size[abi:ne180100]<long long const*,long long const*>(&__p, v13, (uint64_t)v13 + 8 * v14, v14);
  MIL::ValueInference::Tensor<long long>::Tensor(a2, &v11, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v11.n128_u64[0])
  {
    v11.n128_u64[1] = v11.n128_u64[0];
    operator delete((void *)v11.n128_u64[0]);
  }
}

void sub_20F4CCDD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  __cxa_free_exception(v14);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<long long>::ToIRTensorValue(uint64_t a1, MIL::IRConstantDimension *a2)
{
  memset(__p, 0, sizeof(__p));
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(__p, *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3);
  MIL::IRTensorValueType::Make(a2, 12, (MIL::MILContext ***)__p);
}

void sub_20F4CCEE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::ValueInference::Tensor<long long>::Tensor(uint64_t a1, __n128 *a2, __n128 *a3)
{
  *(_OWORD *)(a1 + 8) = 0u;
  uint64_t v5 = a1 + 8;
  *(void *)a1 = &unk_26C25DCE8;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  int v6 = (uint64_t *)a2->n128_u64[0];
  uint64_t v7 = (uint64_t *)a2->n128_u64[1];
  if ((uint64_t *)a2->n128_u64[0] == v7)
  {
    unint64_t v10 = a3->n128_u64[0];
    unint64_t v11 = a3->n128_u64[1];
    uint64_t v8 = a3->n128_u64[0] != v11;
  }
  else
  {
    uint64_t v8 = 1;
    do
    {
      uint64_t v9 = *v6++;
      v8 *= v9;
    }
    while (v6 != v7);
    unint64_t v10 = a3->n128_u64[0];
    unint64_t v11 = a3->n128_u64[1];
  }
  if (v8 != (uint64_t)(v11 - v10) >> 3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "data size and shape dismatch.");
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  std::vector<float>::__move_assign(v5, a2);
  std::vector<float>::__move_assign(a1 + 32, a3);
  *(void *)(a1 + 56) = v8;
  return a1;
}

void sub_20F4CD01C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10)
{
  uint64_t v13 = *v11;
  if (*v11)
  {
    *(void *)(v10 + 40) = v13;
    operator delete(v13);
  }
  unint64_t v14 = *a10;
  if (*a10)
  {
    *(void *)(v10 + 16) = v14;
    operator delete(v14);
  }
  _Unwind_Resume(exception_object);
}

double MIL::ValueInference::Tensor<long long>::Tensor(uint64_t a1)
{
  *(void *)a1 = &unk_26C25DCE8;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  return result;
}

void MIL::ValueInference::Tensor<long long>::ForEach(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v13[4] = *MEMORY[0x263EF8340];
  unint64_t v6 = (uint64_t)(*(void *)(a1 + 40) - *(void *)(a1 + 32)) >> 3;
  __p.n128_u64[0] = 0;
  std::vector<long long>::vector(&v12, v6, &__p);
  __n128 __p = 0uLL;
  uint64_t v11 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3);
  uint64_t v8 = *(uint64_t **)(a1 + 32);
  uint64_t v7 = *(uint64_t **)(a1 + 40);
  uint64_t v9 = (uint64_t *)v12.n128_u64[0];
  std::__function::__value_func<long long ()(long long)>::__value_func[abi:ne180100]((uint64_t)v13, a2);
  while (v8 != v7)
    *v9++ = std::function<long long ()(long long)>::operator()((uint64_t)v13, *v8++);
  std::__function::__value_func<long long ()(long long)>::~__value_func[abi:ne180100](v13);
  MIL::ValueInference::Tensor<long long>::Tensor(a3, &__p, &v12);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v12.n128_u64[0])
  {
    v12.n128_u64[1] = v12.n128_u64[0];
    operator delete((void *)v12.n128_u64[0]);
  }
}

void sub_20F4CD19C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, char a16)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::ValueInference::Tensor<long long>::GetScalarData(void *a1)
{
  if (a1[1] != a1[2] || (uint64_t v1 = a1[4], a1[5] - v1 != 8))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Tensor is not a scalar.");
    __cxa_throw(exception, MEMORY[0x263F8C1E0], MEMORY[0x263F8C048]);
  }
  return *(void *)v1;
}

void sub_20F4CD25C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<long long>::Reshape(void *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v6 = (uint64_t *)*a2;
  uint64_t v7 = a2[1];
  uint64_t v8 = 1;
  if (v6 != (uint64_t *)v7)
  {
    uint64_t v9 = v6;
    do
    {
      uint64_t v10 = *v9++;
      v8 *= v10;
    }
    while (v9 != (uint64_t *)v7);
  }
  if (a1[7] != v8)
  {
    uint64_t v13 = a2;
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v22);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"Tensor is not able to be reshaped since the number of elements in the newShape [ ", 81);
    uint64_t v14 = *v13;
    uint64_t v15 = v13[1];
    if (*v13 != v15)
    {
      do
      {
        uint64_t v16 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)" ", 1);
        v14 += 8;
      }
      while (v14 != v15);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"] is not the same as the number of elements in the tensor shape [ ", 66);
    uint64_t v17 = a1[1];
    for (uint64_t i = a1[2]; v17 != i; v17 += 8)
    {
      uint64_t v19 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)" ", 1);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"].", 2);
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str();
    std::logic_error::logic_error(exception, &__p);
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  __n128 v22 = 0uLL;
  uint64_t v23 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v22, v6, v7, (v7 - (uint64_t)v6) >> 3);
  uint64_t v11 = (const void *)a1[4];
  uint64_t v12 = a1[5];
  memset(&__p, 0, sizeof(__p));
  std::vector<long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<long long const*>,std::__wrap_iter<long long const*>>(&__p, v11, v12, (v12 - (uint64_t)v11) >> 3);
  MIL::ValueInference::Tensor<long long>::Tensor(a3, &v22, (__n128 *)&__p);
  if (__p.__r_.__value_.__r.__words[0])
  {
    __p.__r_.__value_.__l.__size_ = __p.__r_.__value_.__r.__words[0];
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v22.n128_u64[0])
  {
    v22.n128_u64[1] = v22.n128_u64[0];
    operator delete((void *)v22.n128_u64[0]);
  }
}

void sub_20F4CD470(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((v17 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v17)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v16);
  goto LABEL_6;
}

void MIL::ValueInference::Tensor<long long>::NonZero(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v3 = *(void *)(a1 + 56);
  if (v3)
  {
    unint64_t v5 = 0;
    unint64_t v6 = (uint64_t **)(a1 + 8);
    do
    {
      if (*(void *)(*(void *)(a1 + 32) + 8 * v5))
      {
        std::vector<std::vector<unsigned long long>>::push_back[abi:ne180100](a2, (uint64_t)__p);
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
        unint64_t v3 = *(void *)(a1 + 56);
      }
      ++v5;
    }
    while (v5 < v3);
  }
}

void sub_20F4CD584(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
}

void MIL::ValueInference::Tensor<long long>::SubTensor(void *a1@<X0>, uint64_t **a2@<X1>, void *a3@<X8>)
{
  unint64_t v5 = ((char *)a2[1] - (char *)*a2) >> 4;
  unint64_t v6 = a1 + 1;
  if (v5 != (uint64_t)(a1[2] - a1[1]) >> 3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "Indices does not match the rank of the tensor.");
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  std::string __p = 0;
  uint64_t v46 = 0;
  int v47 = 0;
  std::vector<unsigned long long>::reserve(&__p, v5);
  uint64_t v8 = a1[1];
  if (a1[2] != v8)
  {
    unint64_t v9 = 0;
    while (1)
    {
      unint64_t v11 = (*a2)[2 * v9];
      unint64_t v10 = (*a2)[2 * v9 + 1];
      unint64_t v12 = v10 - v11;
      if (v10 < v11) {
        break;
      }
      if (v10 > *(void *)(v8 + 8 * v9))
      {
        uint64_t v33 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(v33, "Indices end is out of the bound for the tensor dimension.");
        uint64_t v34 = (void (*)(void *))MEMORY[0x263F8C068];
        unint64_t v35 = (struct type_info *)off_26412C1E0;
        uint64_t v36 = MEMORY[0x263F8C390] + 16;
LABEL_45:
        v33->__vftable = (std::logic_error_vtbl *)v36;
        __cxa_throw(v33, v35, v34);
      }
      uint64_t v13 = v46;
      if (v46 >= v47)
      {
        uint64_t v15 = (char *)__p;
        uint64_t v16 = (v46 - (unsigned char *)__p) >> 3;
        unint64_t v17 = v16 + 1;
        if ((unint64_t)(v16 + 1) >> 61) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v18 = v47 - (unsigned char *)__p;
        if ((v47 - (unsigned char *)__p) >> 2 > v17) {
          unint64_t v17 = v18 >> 2;
        }
        if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v19 = v17;
        }
        if (v19)
        {
          unint64_t v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v47, v19);
          uint64_t v15 = (char *)__p;
          uint64_t v13 = v46;
        }
        else
        {
          unint64_t v20 = 0;
        }
        size_t v21 = &v20[8 * v16];
        *(void *)size_t v21 = v12;
        uint64_t v14 = (uint64_t)(v21 + 8);
        while (v13 != v15)
        {
          uint64_t v22 = *((void *)v13 - 1);
          v13 -= 8;
          *((void *)v21 - 1) = v22;
          v21 -= 8;
        }
        std::string __p = v21;
        uint64_t v46 = (char *)v14;
        int v47 = &v20[8 * v19];
        if (v15) {
          operator delete(v15);
        }
      }
      else
      {
        *(void *)uint64_t v46 = v12;
        uint64_t v14 = (uint64_t)(v13 + 8);
      }
      uint64_t v46 = (char *)v14;
      ++v9;
      uint64_t v8 = a1[1];
      if (v9 >= (a1[2] - v8) >> 3) {
        goto LABEL_25;
      }
    }
    uint64_t v33 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v33, "Indices end must not be smaller than the indices begin.");
    uint64_t v34 = (void (*)(void *))MEMORY[0x263F8C080];
    unint64_t v35 = (struct type_info *)off_26412C1F0;
    uint64_t v36 = MEMORY[0x263F8C3A0] + 16;
    goto LABEL_45;
  }
  uint64_t v14 = (uint64_t)v46;
LABEL_25:
  __n128 v43 = 0uLL;
  uint64_t v44 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v43, __p, v14, (v14 - (uint64_t)__p) >> 3);
  MIL::ValueInference::Tensor<long long>::Zeros(&v43, (uint64_t)a3);
  if (v43.n128_u64[0])
  {
    v43.n128_u64[1] = v43.n128_u64[0];
    operator delete((void *)v43.n128_u64[0]);
  }
  uint64_t v23 = a3[5] - a3[4];
  if (v23)
  {
    unint64_t v24 = 0;
    unint64_t v25 = v23 >> 3;
    if (v25 <= 1) {
      uint64_t v26 = 1;
    }
    else {
      uint64_t v26 = v25;
    }
    do
    {
      std::string::size_type v38 = 0;
      uint64_t v39 = 0;
      uint64_t v40 = 0;
      std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v38, v41, (uint64_t)v42, (v42 - (unsigned char *)v41) >> 3);
      uint64_t v27 = a1[2] - a1[1];
      if (v27)
      {
        unint64_t v28 = v27 >> 3;
        uint64_t v29 = *a2;
        uint64_t v30 = v38;
        if (v28 <= 1) {
          unint64_t v28 = 1;
        }
        do
        {
          uint64_t v31 = *v29;
          v29 += 2;
          *v30++ += v31;
          --v28;
        }
        while (v28);
      }
      if (v38)
      {
        uint64_t v39 = v38;
        operator delete(v38);
      }
      if (v41)
      {
        uint64_t v42 = v41;
        operator delete(v41);
      }
      ++v24;
    }
    while (v24 != v26);
  }
  if (__p)
  {
    uint64_t v46 = (char *)__p;
    operator delete(__p);
  }
}

void sub_20F4CD938(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19)
{
  __cxa_free_exception(v19);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<long long>::Zeros(__n128 *a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t v4 = (uint64_t *)a1->n128_u64[0];
  unint64_t v5 = 1;
  while (v4 != (uint64_t *)a1->n128_u64[1])
  {
    uint64_t v6 = *v4++;
    v5 *= v6;
  }
  std::vector<long long>::vector(&__p, v5);
  MIL::ValueInference::Tensor<long long>::Tensor(a2, a1, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
}

void sub_20F4CDA4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<long long>::Concat(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *a1;
  uint64_t v7 = 0;
  uint64_t v8 = a1[1] - *a1;
  if (v8)
  {
    unint64_t v9 = v8 >> 6;
    if (v9 <= 1) {
      unint64_t v9 = 1;
    }
    unint64_t v10 = (uint64_t *)(v6 + 8);
    do
    {
      uint64_t v11 = *v10;
      v10 += 8;
      v7 += *(void *)(v11 + 8 * a2);
      --v9;
    }
    while (v9);
  }
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  uint64_t v29 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v29, *(const void **)(v6 + 8), *(void *)(v6 + 16), (uint64_t)(*(void *)(v6 + 16) - *(void *)(v6 + 8)) >> 3);
  unint64_t v12 = v29;
  *((void *)v29 + a2) = v7;
  uint64_t v28 = 0;
  __n128 __p = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, v12, (uint64_t)v30, (v30 - (unsigned char *)v12) >> 3);
  MIL::ValueInference::Tensor<long long>::Zeros(&__p, a3);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  uint64_t v13 = *a1;
  uint64_t v14 = a1[1];
  if (v14 != *a1)
  {
    unint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(void *)(v13 + (v15 << 6) + 40) - *(void *)(v13 + (v15 << 6) + 32);
      if (v17)
      {
        unint64_t v18 = 0;
        if ((unint64_t)(v17 >> 3) <= 1) {
          uint64_t v19 = 1;
        }
        else {
          uint64_t v19 = v17 >> 3;
        }
        do
        {
          uint64_t v22 = 0;
          uint64_t v23 = 0;
          uint64_t v24 = 0;
          std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v22, v25, (uint64_t)v26, (v26 - (unsigned char *)v25) >> 3);
          *((void *)v22 + a2) += v16;
          unint64_t v20 = *a1 + (v15 << 6);
          uint64_t v21 = *(void *)(*(void *)(v20 + 32)
          *(void *)(*(void *)(a3 + 32)
          if (v22)
          {
            uint64_t v23 = v22;
            operator delete(v22);
          }
          if (v25)
          {
            uint64_t v26 = v25;
            operator delete(v25);
          }
          ++v18;
        }
        while (v19 != v18);
        uint64_t v13 = *a1;
        uint64_t v14 = a1[1];
      }
      v16 += *(void *)(*(void *)(v13 + (v15++ << 6) + 8) + 8 * a2);
    }
    while (v15 < (v14 - v13) >> 6);
  }
  if (v29)
  {
    uint64_t v30 = v29;
    operator delete(v29);
  }
}

void sub_20F4CDC58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  if (a18) {
    operator delete(a18);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<long long>::BlockwiseMerge(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *(uint64_t **)a2;
  uint64_t v7 = *(void *)(a2 + 8) - *(void *)a2;
  if (v7)
  {
    unint64_t v8 = v7 >> 3;
    if (v8 <= 1) {
      unint64_t v8 = 1;
    }
    uint64_t v9 = 1;
    do
    {
      uint64_t v10 = *v6++;
      v9 *= v10;
      --v8;
    }
    while (v8);
  }
  else
  {
    uint64_t v9 = 1;
  }
  uint64_t v11 = *a1;
  if (v9 != (a1[1] - *a1) >> 6)
  {
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v49);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v49, (uint64_t)"The number of tensors (", 23);
    unint64_t v37 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v37, (uint64_t)") is not the same as the number of blocks (", 43);
    std::string::size_type v38 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v38, (uint64_t)").", 2);
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str();
    std::runtime_error::runtime_error(exception, &v48);
    __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
  }
  unint64_t v50 = 0;
  uint64_t v51 = 0;
  uint64_t v49 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v49, *(const void **)(v11 + 8), *(void *)(v11 + 16), (uint64_t)(*(void *)(v11 + 16) - *(void *)(v11 + 8)) >> 3);
  memset(&v48, 0, sizeof(v48));
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v48, v49, (uint64_t)v50, (v50 - (unsigned char *)v49) >> 3);
  unint64_t v12 = *(uint64_t **)a2;
  uint64_t v13 = (const void *)v48.__r_.__value_.__r.__words[0];
  uint64_t v14 = *(void *)(a2 + 8) - *(void *)a2;
  if (v14)
  {
    unint64_t v15 = v14 >> 3;
    if (v15 <= 1) {
      unint64_t v15 = 1;
    }
    uint64_t v16 = (void *)v48.__r_.__value_.__r.__words[0];
    do
    {
      uint64_t v17 = *v12++;
      *v16++ *= v17;
      --v15;
    }
    while (v15);
  }
  __n128 __p = 0uLL;
  uint64_t v47 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, v13, v48.__r_.__value_.__l.__size_, (uint64_t)(v48.__r_.__value_.__l.__size_ - (void)v13) >> 3);
  MIL::ValueInference::Tensor<long long>::Zeros(&__p, a3);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v9)
  {
    for (unint64_t i = 0; i != v9; ++i)
    {
      unint64_t v19 = *a1 + (i << 6);
      unint64_t v20 = *(const void **)(v19 + 8);
      size_t v21 = *(void *)(v19 + 16) - (void)v20;
      if (v21 != v50 - (unsigned char *)v49 || memcmp(v20, v49, v21))
      {
        uint64_t v36 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v36, "All tensors must have the same shape so they can be merged.");
        __cxa_throw(v36, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
      }
      uint64_t v22 = *(void *)(*a1 + (i << 6) + 40) - *(void *)(*a1 + (i << 6) + 32);
      if (v22)
      {
        unint64_t v23 = 0;
        unint64_t v24 = v22 >> 3;
        if (v24 <= 1) {
          uint64_t v25 = 1;
        }
        else {
          uint64_t v25 = v24;
        }
        do
        {
          uint64_t v40 = 0;
          uint64_t v41 = 0;
          uint64_t v42 = 0;
          std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v40, v43, (uint64_t)v44, (v44 - (unsigned char *)v43) >> 3);
          uint64_t v26 = *(void *)(a2 + 8) - *(void *)a2;
          if (v26)
          {
            unint64_t v27 = v26 >> 3;
            uint64_t v28 = (uint64_t *)v49;
            uint64_t v29 = (uint64_t *)v45[0];
            uint64_t v30 = v40;
            if (v27 <= 1) {
              unint64_t v27 = 1;
            }
            do
            {
              uint64_t v32 = *v28++;
              uint64_t v31 = v32;
              uint64_t v33 = *v29++;
              *v30++ += v33 * v31;
              --v27;
            }
            while (v27);
          }
          unint64_t v34 = *a1 + (i << 6);
          uint64_t v35 = *(void *)(*(void *)(v34 + 32)
          *(void *)(*(void *)(a3 + 32)
          if (v40)
          {
            uint64_t v41 = v40;
            operator delete(v40);
          }
          if (v43)
          {
            uint64_t v44 = v43;
            operator delete(v43);
          }
          ++v23;
        }
        while (v23 != v25);
      }
      if (v45[0])
      {
        v45[1] = v45[0];
        operator delete(v45[0]);
      }
    }
  }
  if (v48.__r_.__value_.__r.__words[0])
  {
    v48.__r_.__value_.__l.__size_ = v48.__r_.__value_.__r.__words[0];
    operator delete(v48.__r_.__value_.__l.__data_);
  }
  if (v49)
  {
    unint64_t v50 = v49;
    operator delete(v49);
  }
}

void sub_20F4CE060(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28)
{
  if (a26 < 0)
  {
    operator delete(__p);
    if ((v29 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a27);
      _Unwind_Resume(a1);
    }
  }
  else if (!v29)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v28);
  goto LABEL_6;
}

uint64_t MIL::ValueInference::Tensor<long long>::Reduce@<X0>(void *a1@<X0>, unint64_t **a2@<X1>, int a3@<W2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v103 = a1[1];
  char v104 = a1 + 1;
  uint64_t v102 = a1[2];
  unint64_t v7 = (v102 - v103) >> 3;
  std::unordered_set<unsigned long long>::unordered_set<std::__wrap_iter<unsigned long long const*>>((uint64_t)v122, *a2, a2[1]);
  for (unint64_t i = v123; i; unint64_t i = (void *)*i)
  {
    if (i[2] >= v7)
    {
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&__p);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&__p, (uint64_t)"axis(", 5);
      uint64_t v91 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v91, (uint64_t)") must be smaller than the number of input dimensions(", 54);
      uint64_t v92 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v92, (uint64_t)").", 2);
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::stringbuf::str();
      std::logic_error::logic_error(exception, &v118);
      exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
      __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
    }
  }
  __n128 __p = 0;
  std::string v120 = 0;
  v121[0] = 0;
  memset(&v118, 0, sizeof(v118));
  __n128 v115 = 0;
  std::string v116 = 0;
  std::string v117 = 0;
  if (v102 == v103)
  {
    uint64_t v55 = 0;
    uint64_t v54 = 0;
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t v5 = (uint64_t)&v117;
    if (v7 <= 1) {
      uint64_t v10 = 1;
    }
    else {
      uint64_t v10 = (v102 - v103) >> 3;
    }
    do
    {
      v112[0] = v9;
      if (std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(v122, (unint64_t *)v112))
      {
        if (a3)
        {
          uint64_t v11 = v120;
          if ((unint64_t)v120 >= v121[0])
          {
            uint64_t v22 = (char *)__p;
            uint64_t v23 = (v120 - (unsigned char *)__p) >> 3;
            unint64_t v24 = v23 + 1;
            if ((unint64_t)(v23 + 1) >> 61) {
              std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v25 = v121[0] - (void)__p;
            if ((uint64_t)(v121[0] - (void)__p) >> 2 > v24) {
              unint64_t v24 = v25 >> 2;
            }
            if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v26 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v26 = v24;
            }
            if (v26)
            {
              unint64_t v27 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)v121, v26);
              uint64_t v22 = (char *)__p;
              uint64_t v11 = v120;
            }
            else
            {
              unint64_t v27 = 0;
            }
            uint64_t v41 = &v27[8 * v23];
            *(void *)uint64_t v41 = 1;
            unint64_t v12 = v41 + 8;
            while (v11 != v22)
            {
              uint64_t v42 = *((void *)v11 - 1);
              v11 -= 8;
              *((void *)v41 - 1) = v42;
              v41 -= 8;
            }
            __n128 __p = v41;
            std::string v120 = v12;
            v121[0] = &v27[8 * v26];
            if (v22) {
              operator delete(v22);
            }
          }
          else
          {
            *(void *)std::string v120 = 1;
            unint64_t v12 = v11 + 8;
          }
          std::string v120 = v12;
        }
        uint64_t v43 = *v104;
        uint64_t v44 = v116;
        if (v116 >= v117)
        {
          uint64_t v46 = (char *)v115;
          uint64_t v47 = (v116 - (unsigned char *)v115) >> 3;
          unint64_t v48 = v47 + 1;
          if ((unint64_t)(v47 + 1) >> 61) {
LABEL_153:
          }
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          uint64_t v49 = v117 - (unsigned char *)v115;
          if ((v117 - (unsigned char *)v115) >> 2 > v48) {
            unint64_t v48 = v49 >> 2;
          }
          if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v50 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v50 = v48;
          }
          if (v50)
          {
            uint64_t v51 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v117, v50);
            uint64_t v46 = (char *)v115;
            uint64_t v44 = v116;
          }
          else
          {
            uint64_t v51 = 0;
          }
          uint64_t v52 = &v51[8 * v47];
          *(void *)uint64_t v52 = *(void *)(v43 + 8 * (void)v9);
          uint64_t v45 = v52 + 8;
          while (v44 != v46)
          {
            uint64_t v53 = *((void *)v44 - 1);
            v44 -= 8;
            *((void *)v52 - 1) = v53;
            v52 -= 8;
          }
          __n128 v115 = v52;
          std::string v116 = v45;
          std::string v117 = &v51[8 * v50];
          if (v46) {
            operator delete(v46);
          }
        }
        else
        {
          *(void *)std::string v116 = *(void *)(v43 + 8 * (void)v9);
          uint64_t v45 = v44 + 8;
        }
        std::string v116 = v45;
      }
      else
      {
        uint64_t v13 = *v104;
        uint64_t v14 = v120;
        if ((unint64_t)v120 >= v121[0])
        {
          uint64_t v16 = (char *)__p;
          uint64_t v17 = (v120 - (unsigned char *)__p) >> 3;
          unint64_t v18 = v17 + 1;
          if ((unint64_t)(v17 + 1) >> 61) {
            goto LABEL_153;
          }
          uint64_t v19 = v121[0] - (void)__p;
          if ((uint64_t)(v121[0] - (void)__p) >> 2 > v18) {
            unint64_t v18 = v19 >> 2;
          }
          if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v20 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v20 = v18;
          }
          if (v20)
          {
            size_t v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)v121, v20);
            uint64_t v16 = (char *)__p;
            uint64_t v14 = v120;
          }
          else
          {
            size_t v21 = 0;
          }
          uint64_t v28 = &v21[8 * v17];
          *(void *)uint64_t v28 = *(void *)(v13 + 8 * (void)v9);
          unint64_t v15 = v28 + 8;
          while (v14 != v16)
          {
            uint64_t v29 = *((void *)v14 - 1);
            v14 -= 8;
            *((void *)v28 - 1) = v29;
            v28 -= 8;
          }
          __n128 __p = v28;
          std::string v120 = v15;
          v121[0] = &v21[8 * v20];
          if (v16) {
            operator delete(v16);
          }
        }
        else
        {
          *(void *)std::string v120 = *(void *)(v13 + 8 * (void)v9);
          unint64_t v15 = v14 + 8;
        }
        std::string v120 = v15;
        uint64_t v30 = *v104;
        std::string::size_type size = v118.__r_.__value_.__l.__size_;
        if (v118.__r_.__value_.__l.__size_ >= v118.__r_.__value_.__r.__words[2])
        {
          uint64_t v33 = (void *)v118.__r_.__value_.__r.__words[0];
          uint64_t v34 = (uint64_t)(v118.__r_.__value_.__l.__size_ - v118.__r_.__value_.__r.__words[0]) >> 3;
          unint64_t v35 = v34 + 1;
          if ((unint64_t)(v34 + 1) >> 61) {
            goto LABEL_153;
          }
          int64_t v36 = v118.__r_.__value_.__r.__words[2] - v118.__r_.__value_.__r.__words[0];
          if ((uint64_t)(v118.__r_.__value_.__r.__words[2] - v118.__r_.__value_.__r.__words[0]) >> 2 > v35) {
            unint64_t v35 = v36 >> 2;
          }
          if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v37 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v37 = v35;
          }
          if (v37)
          {
            std::string::size_type v38 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v118.__r_.__value_.__r.__words[2], v37);
            std::string::size_type size = v118.__r_.__value_.__l.__size_;
            uint64_t v33 = (void *)v118.__r_.__value_.__r.__words[0];
          }
          else
          {
            std::string::size_type v38 = 0;
          }
          uint64_t v39 = &v38[8 * v34];
          *(void *)uint64_t v39 = *(void *)(v30 + 8 * (void)v9);
          std::string::size_type v32 = (std::string::size_type)(v39 + 8);
          while ((void *)size != v33)
          {
            uint64_t v40 = *(void *)(size - 8);
            size -= 8;
            *((void *)v39 - 1) = v40;
            v39 -= 8;
          }
          v118.__r_.__value_.__r.__words[0] = (std::string::size_type)v39;
          v118.__r_.__value_.__l.__size_ = v32;
          v118.__r_.__value_.__r.__words[2] = (std::string::size_type)&v38[8 * v37];
          if (v33) {
            operator delete(v33);
          }
        }
        else
        {
          *(void *)v118.__r_.__value_.__l.__size_ = *(void *)(v30 + 8 * (void)v9);
          std::string::size_type v32 = size + 8;
        }
        v118.__r_.__value_.__l.__size_ = v32;
      }
      uint64_t v9 = (char *)v9 + 1;
    }
    while (v9 != (void *)v10);
    uint64_t v54 = __p;
    uint64_t v55 = (uint64_t)v120;
  }
  __n128 v113 = 0uLL;
  uint64_t v114 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v113, v54, v55, (v55 - (uint64_t)v54) >> 3);
  MIL::ValueInference::Tensor<long long>::Zeros(&v113, a5);
  if (v113.n128_u64[0])
  {
    v113.n128_u64[1] = v113.n128_u64[0];
    operator delete((void *)v113.n128_u64[0]);
  }
  uint64_t v56 = *(void *)(a5 + 40) - *(void *)(a5 + 32);
  if (v56)
  {
    unint64_t v57 = 0;
    unint64_t v58 = v56 >> 3;
    unint64_t v95 = v56 >> 3;
    unint64_t v96 = (uint64_t)(a1[5] - a1[4]) >> 3;
    unint64_t v59 = v96 / (v56 >> 3);
    uint64_t v60 = (uint64_t **)(a5 + 8);
    if (v7 <= 1) {
      uint64_t v61 = 1;
    }
    else {
      uint64_t v61 = (v102 - v103) >> 3;
    }
    if (v58 <= 1) {
      uint64_t v62 = 1;
    }
    else {
      uint64_t v62 = v58;
    }
    uint64_t v94 = v62;
    if (v59 <= 1) {
      unint64_t v59 = 1;
    }
    unint64_t v100 = v59;
    do
    {
      unint64_t v98 = v57;
      v5 &= 0xFFFFFFFFFFFFFF00;
      if (v95 <= v96)
      {
        unint64_t v63 = 0;
        char v64 = 1;
        do
        {
          uint64_t v105 = v5;
          uint64_t v107 = 0;
          unint64_t v108 = 0;
          uint64_t v109 = 0;
          if (v102 != v103)
          {
            unint64_t v65 = 0;
            uint64_t v66 = 0;
            uint64_t v67 = 0;
            do
            {
              unint64_t v106 = v65;
              uint64_t v68 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(v122, &v106);
              uint64_t v69 = v108;
              if (v68)
              {
                uint64_t v70 = v110;
                if (v108 >= v109)
                {
                  unint64_t v74 = (char *)v107;
                  uint64_t v75 = (v108 - (unsigned char *)v107) >> 3;
                  unint64_t v76 = v75 + 1;
                  if ((unint64_t)(v75 + 1) >> 61) {
                    goto LABEL_151;
                  }
                  uint64_t v77 = v109 - (unsigned char *)v107;
                  if ((v109 - (unsigned char *)v107) >> 2 > v76) {
                    unint64_t v76 = v77 >> 2;
                  }
                  if ((unint64_t)v77 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v78 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v78 = v76;
                  }
                  if (v78)
                  {
                    uint64_t v79 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v109, v78);
                    unint64_t v74 = (char *)v107;
                    uint64_t v69 = v108;
                  }
                  else
                  {
                    uint64_t v79 = 0;
                  }
                  uint64_t v86 = &v79[8 * v75];
                  *(void *)uint64_t v86 = v70[v66];
                  uint64_t v71 = v86 + 8;
                  while (v69 != v74)
                  {
                    uint64_t v87 = *((void *)v69 - 1);
                    v69 -= 8;
                    *((void *)v86 - 1) = v87;
                    v86 -= 8;
                  }
                  uint64_t v107 = v86;
                  unint64_t v108 = v71;
                  uint64_t v109 = &v79[8 * v78];
                  if (v74) {
                    operator delete(v74);
                  }
                }
                else
                {
                  *(void *)unint64_t v108 = *((void *)v110 + v66);
                  uint64_t v71 = v69 + 8;
                }
                unint64_t v108 = v71;
                ++v66;
              }
              else
              {
                uint64_t v72 = v112[0];
                if (v108 >= v109)
                {
                  unint64_t v80 = (char *)v107;
                  uint64_t v81 = (v108 - (unsigned char *)v107) >> 3;
                  unint64_t v82 = v81 + 1;
                  if ((unint64_t)(v81 + 1) >> 61) {
LABEL_151:
                  }
                    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
                  uint64_t v83 = v109 - (unsigned char *)v107;
                  if ((v109 - (unsigned char *)v107) >> 2 > v82) {
                    unint64_t v82 = v83 >> 2;
                  }
                  if ((unint64_t)v83 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v84 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v84 = v82;
                  }
                  if (v84)
                  {
                    uint64_t v85 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v109, v84);
                    unint64_t v80 = (char *)v107;
                    uint64_t v69 = v108;
                  }
                  else
                  {
                    uint64_t v85 = 0;
                  }
                  int v88 = &v85[8 * v81];
                  *(void *)int v88 = v72[v67];
                  uint64_t v73 = v88 + 8;
                  while (v69 != v80)
                  {
                    uint64_t v89 = *((void *)v69 - 1);
                    v69 -= 8;
                    *((void *)v88 - 1) = v89;
                    v88 -= 8;
                  }
                  uint64_t v107 = v88;
                  unint64_t v108 = v73;
                  uint64_t v109 = &v85[8 * v84];
                  if (v80) {
                    operator delete(v80);
                  }
                }
                else
                {
                  *(void *)unint64_t v108 = *((void *)v112[0] + v67);
                  uint64_t v73 = v69 + 8;
                }
                unint64_t v108 = v73;
                ++v67;
              }
              ++v65;
            }
            while (v65 != v61);
          }
          if ((v64 & 1) == 0) {
            uint64_t v5 = std::function<long long ()(long long,long long)>::operator()(a4, v105, v5);
          }
          uint64_t v60 = (uint64_t **)(a5 + 8);
          if (v107)
          {
            unint64_t v108 = (char *)v107;
            operator delete(v107);
          }
          if (v110)
          {
            __n128 v111 = v110;
            operator delete(v110);
          }
          char v64 = 0;
          ++v63;
        }
        while (v63 != v100);
      }
      if (v110)
      {
        __n128 v111 = v110;
        operator delete(v110);
      }
      if (v112[0])
      {
        v112[1] = v112[0];
        operator delete(v112[0]);
      }
      unint64_t v57 = v98 + 1;
    }
    while (v98 + 1 != v94);
  }
  if (v115)
  {
    std::string v116 = (char *)v115;
    operator delete(v115);
  }
  if (v118.__r_.__value_.__r.__words[0])
  {
    v118.__r_.__value_.__l.__size_ = v118.__r_.__value_.__r.__words[0];
    operator delete(v118.__r_.__value_.__l.__data_);
  }
  if (__p)
  {
    std::string v120 = (char *)__p;
    operator delete(__p);
  }
  return std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table((uint64_t)v122);
}

void sub_20F4CE990(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37,uint64_t a38,void *__p,uint64_t a40,int a41,__int16 a42,char a43,char a44,void *a45,uint64_t a46)
{
  if (a44 < 0)
  {
    operator delete(__p);
    if ((v47 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a45);
      std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table(v48 - 128);
      _Unwind_Resume(a1);
    }
  }
  else if (!v47)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v46);
  goto LABEL_6;
}

uint64_t std::function<long long ()(long long,long long)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a3;
  uint64_t v6 = a2;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)v3 + 48))(v3, &v6, &v5);
}

void MIL::ValueInference::Tensor<long long>::Zeros(MIL *a1@<X0>, const MIL::IRTensorValueType *a2@<X1>, uint64_t a3@<X8>)
{
  MIL::GetTensorShapeWithDimensionsAllKnown(a1, a2, (uint64_t)v6);
  *(_OWORD *)__n128 __p = *(_OWORD *)v6;
  uint64_t v5 = v7;
  v6[1] = 0;
  uint64_t v7 = 0;
  v6[0] = 0;
  MIL::ValueInference::Tensor<long long>::Zeros((__n128 *)__p, a3);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v6[0])
  {
    v6[1] = v6[0];
    operator delete(v6[0]);
  }
}

void sub_20F4CEB7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  if (__p) {
    operator delete(__p);
  }
  if (a13) {
    operator delete(a13);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<BOOL>::FromIRTensorValue(void *a1@<X0>, uint64_t a2@<X8>)
{
  MIL::IRTensorValue::TryGetDataView<BOOL>(&v12, *a1);
  if (!(_BYTE)v12)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Failed to get data view.");
    uint64_t v7 = (struct type_info *)MEMORY[0x263F8C1F0];
    unint64_t v8 = (void (*)(void *))MEMORY[0x263F8C070];
    goto LABEL_10;
  }
  unint64_t v4 = (MIL *)(*(uint64_t (**)(void))(*(void *)*a1 + 32))();
  if ((*(unsigned int (**)(MIL *))(*(void *)v4 + 88))(v4) == 3)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100]((std::logic_error *)exception, "It is not supported to convert a tensor of string dtype.");
    uint64_t v7 = (struct type_info *)off_26412C1F0;
    unint64_t v8 = (void (*)(void *))MEMORY[0x263F8C080];
LABEL_10:
    __cxa_throw(exception, v7, v8);
  }
  MIL::GetTensorShapeWithDimensionsAllKnown(v4, v5, (uint64_t)&v11);
  uint64_t v10 = 0;
  __n128 __p = 0uLL;
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<BOOL const*,BOOL const*>((char *)&__p, v13, &v13[v14], v14);
  MIL::ValueInference::Tensor<BOOL>::Tensor(a2, &v11, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v11.n128_u64[0])
  {
    v11.n128_u64[1] = v11.n128_u64[0];
    operator delete((void *)v11.n128_u64[0]);
  }
}

void sub_20F4CECFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  __cxa_free_exception(v14);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<BOOL>::ToIRTensorValue(uint64_t a1, MIL::IRConstantDimension *a2)
{
  memset(__p, 0, sizeof(__p));
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(__p, *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3);
  MIL::IRTensorValueType::Make(a2, 2, (MIL::MILContext ***)__p);
}

void sub_20F4CEE00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::ValueInference::Tensor<BOOL>::Tensor(uint64_t a1, __n128 *a2, __n128 *a3)
{
  *(_OWORD *)(a1 + 8) = 0u;
  uint64_t v5 = a1 + 8;
  *(void *)a1 = &unk_26C25DBF8;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  uint64_t v6 = (uint64_t *)a2->n128_u64[0];
  uint64_t v7 = (uint64_t *)a2->n128_u64[1];
  if ((uint64_t *)a2->n128_u64[0] == v7)
  {
    unint64_t v10 = a3->n128_u64[0];
    unint64_t v11 = a3->n128_u64[1];
    uint64_t v8 = a3->n128_u64[0] != v11;
  }
  else
  {
    uint64_t v8 = 1;
    do
    {
      uint64_t v9 = *v6++;
      v8 *= v9;
    }
    while (v6 != v7);
    unint64_t v10 = a3->n128_u64[0];
    unint64_t v11 = a3->n128_u64[1];
  }
  if (v8 != v11 - v10)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "data size and shape dismatch.");
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  std::vector<float>::__move_assign(v5, a2);
  std::vector<float>::__move_assign(a1 + 32, a3);
  *(void *)(a1 + 56) = v8;
  return a1;
}

void sub_20F4CEF38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10)
{
  uint64_t v13 = *v11;
  if (*v11)
  {
    *(void *)(v10 + 40) = v13;
    operator delete(v13);
  }
  size_t v14 = *a10;
  if (*a10)
  {
    *(void *)(v10 + 16) = v14;
    operator delete(v14);
  }
  _Unwind_Resume(exception_object);
}

double MIL::ValueInference::Tensor<BOOL>::Tensor(uint64_t a1)
{
  *(void *)a1 = &unk_26C25DBF8;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  return result;
}

void MIL::ValueInference::Tensor<BOOL>::ForEach(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v13[4] = *MEMORY[0x263EF8340];
  size_t v6 = *(void *)(a1 + 40) - *(void *)(a1 + 32);
  __p.n128_u8[0] = 0;
  std::vector<unsigned char>::vector(&v12, v6, &__p);
  __n128 __p = 0uLL;
  uint64_t v11 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3);
  uint64_t v8 = *(char **)(a1 + 32);
  uint64_t v7 = *(char **)(a1 + 40);
  uint64_t v9 = (unsigned char *)v12.n128_u64[0];
  std::__function::__value_func<unsigned char ()(unsigned char)>::__value_func[abi:ne180100]((uint64_t)v13, a2);
  while (v8 != v7)
    *v9++ = std::function<unsigned char ()(unsigned char)>::operator()((uint64_t)v13, *v8++);
  std::__function::__value_func<unsigned char ()(unsigned char)>::~__value_func[abi:ne180100](v13);
  MIL::ValueInference::Tensor<BOOL>::Tensor(a3, &__p, &v12);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v12.n128_u64[0])
  {
    v12.n128_u64[1] = v12.n128_u64[0];
    operator delete((void *)v12.n128_u64[0]);
  }
}

void sub_20F4CF0B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, char a16)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::ValueInference::Tensor<BOOL>::GetScalarData(void *a1)
{
  if (a1[1] != a1[2] || (uint64_t v1 = (unsigned __int8 *)a1[4], a1[5] - (void)v1 != 1))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Tensor is not a scalar.");
    __cxa_throw(exception, MEMORY[0x263F8C1E0], MEMORY[0x263F8C048]);
  }
  return *v1;
}

void sub_20F4CF174(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<BOOL>::Reshape(void *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  size_t v6 = (uint64_t *)*a2;
  uint64_t v7 = a2[1];
  uint64_t v8 = 1;
  if (v6 != (uint64_t *)v7)
  {
    uint64_t v9 = v6;
    do
    {
      uint64_t v10 = *v9++;
      v8 *= v10;
    }
    while (v9 != (uint64_t *)v7);
  }
  if (a1[7] != v8)
  {
    uint64_t v13 = a2;
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v22);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"Tensor is not able to be reshaped since the number of elements in the newShape [ ", 81);
    uint64_t v14 = *v13;
    uint64_t v15 = v13[1];
    if (*v13 != v15)
    {
      do
      {
        uint64_t v16 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)" ", 1);
        v14 += 8;
      }
      while (v14 != v15);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"] is not the same as the number of elements in the tensor shape [ ", 66);
    uint64_t v17 = a1[1];
    for (uint64_t i = a1[2]; v17 != i; v17 += 8)
    {
      uint64_t v19 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)" ", 1);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"].", 2);
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str();
    std::logic_error::logic_error(exception, &__p);
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  __n128 v22 = 0uLL;
  uint64_t v23 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v22, v6, v7, (v7 - (uint64_t)v6) >> 3);
  uint64_t v11 = (const void *)a1[4];
  uint64_t v12 = a1[5];
  memset(&__p, 0, sizeof(__p));
  std::vector<unsigned char>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned char const*>,std::__wrap_iter<unsigned char const*>>(&__p, v11, v12, v12 - (void)v11);
  MIL::ValueInference::Tensor<BOOL>::Tensor(a3, &v22, (__n128 *)&__p);
  if (__p.__r_.__value_.__r.__words[0])
  {
    __p.__r_.__value_.__l.__size_ = __p.__r_.__value_.__r.__words[0];
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v22.n128_u64[0])
  {
    v22.n128_u64[1] = v22.n128_u64[0];
    operator delete((void *)v22.n128_u64[0]);
  }
}

void sub_20F4CF384(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((v17 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v17)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v16);
  goto LABEL_6;
}

void MIL::ValueInference::Tensor<BOOL>::NonZero(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v3 = *(void *)(a1 + 56);
  if (v3)
  {
    unint64_t v5 = 0;
    size_t v6 = (uint64_t **)(a1 + 8);
    do
    {
      if (*(unsigned char *)(*(void *)(a1 + 32) + v5))
      {
        std::vector<std::vector<unsigned long long>>::push_back[abi:ne180100](a2, (uint64_t)__p);
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
        unint64_t v3 = *(void *)(a1 + 56);
      }
      ++v5;
    }
    while (v5 < v3);
  }
}

void sub_20F4CF498(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
}

void MIL::ValueInference::Tensor<BOOL>::SubTensor(void *a1@<X0>, uint64_t **a2@<X1>, void *a3@<X8>)
{
  unint64_t v5 = ((char *)a2[1] - (char *)*a2) >> 4;
  size_t v6 = a1 + 1;
  if (v5 != (uint64_t)(a1[2] - a1[1]) >> 3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "Indices does not match the rank of the tensor.");
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  std::string __p = 0;
  uint64_t v45 = 0;
  uint64_t v46 = 0;
  std::vector<unsigned long long>::reserve(&__p, v5);
  uint64_t v8 = a1[1];
  if (a1[2] != v8)
  {
    unint64_t v9 = 0;
    while (1)
    {
      unint64_t v11 = (*a2)[2 * v9];
      unint64_t v10 = (*a2)[2 * v9 + 1];
      unint64_t v12 = v10 - v11;
      if (v10 < v11) {
        break;
      }
      if (v10 > *(void *)(v8 + 8 * v9))
      {
        std::string::size_type v32 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(v32, "Indices end is out of the bound for the tensor dimension.");
        uint64_t v33 = (void (*)(void *))MEMORY[0x263F8C068];
        uint64_t v34 = (struct type_info *)off_26412C1E0;
        uint64_t v35 = MEMORY[0x263F8C390] + 16;
LABEL_45:
        v32->__vftable = (std::logic_error_vtbl *)v35;
        __cxa_throw(v32, v34, v33);
      }
      uint64_t v13 = v45;
      if (v45 >= v46)
      {
        uint64_t v15 = (char *)__p;
        uint64_t v16 = (v45 - (unsigned char *)__p) >> 3;
        unint64_t v17 = v16 + 1;
        if ((unint64_t)(v16 + 1) >> 61) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v18 = v46 - (unsigned char *)__p;
        if ((v46 - (unsigned char *)__p) >> 2 > v17) {
          unint64_t v17 = v18 >> 2;
        }
        if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v19 = v17;
        }
        if (v19)
        {
          unint64_t v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v46, v19);
          uint64_t v15 = (char *)__p;
          uint64_t v13 = v45;
        }
        else
        {
          unint64_t v20 = 0;
        }
        size_t v21 = &v20[8 * v16];
        *(void *)size_t v21 = v12;
        uint64_t v14 = (uint64_t)(v21 + 8);
        while (v13 != v15)
        {
          uint64_t v22 = *((void *)v13 - 1);
          v13 -= 8;
          *((void *)v21 - 1) = v22;
          v21 -= 8;
        }
        std::string __p = v21;
        uint64_t v45 = (char *)v14;
        uint64_t v46 = &v20[8 * v19];
        if (v15) {
          operator delete(v15);
        }
      }
      else
      {
        *(void *)uint64_t v45 = v12;
        uint64_t v14 = (uint64_t)(v13 + 8);
      }
      uint64_t v45 = (char *)v14;
      ++v9;
      uint64_t v8 = a1[1];
      if (v9 >= (a1[2] - v8) >> 3) {
        goto LABEL_25;
      }
    }
    std::string::size_type v32 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v32, "Indices end must not be smaller than the indices begin.");
    uint64_t v33 = (void (*)(void *))MEMORY[0x263F8C080];
    uint64_t v34 = (struct type_info *)off_26412C1F0;
    uint64_t v35 = MEMORY[0x263F8C3A0] + 16;
    goto LABEL_45;
  }
  uint64_t v14 = (uint64_t)v45;
LABEL_25:
  __n128 v42 = 0uLL;
  uint64_t v43 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v42, __p, v14, (v14 - (uint64_t)__p) >> 3);
  MIL::ValueInference::Tensor<BOOL>::Zeros(&v42, (uint64_t)a3);
  if (v42.n128_u64[0])
  {
    v42.n128_u64[1] = v42.n128_u64[0];
    operator delete((void *)v42.n128_u64[0]);
  }
  unint64_t v23 = a3[5] - a3[4];
  if (v23)
  {
    unint64_t v24 = 0;
    if (v23 <= 1) {
      uint64_t v25 = 1;
    }
    else {
      uint64_t v25 = a3[5] - a3[4];
    }
    do
    {
      unint64_t v37 = 0;
      std::string::size_type v38 = 0;
      uint64_t v39 = 0;
      std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v37, v40, (uint64_t)v41, (v41 - (unsigned char *)v40) >> 3);
      uint64_t v26 = a1[2] - a1[1];
      if (v26)
      {
        unint64_t v27 = v26 >> 3;
        uint64_t v28 = *a2;
        uint64_t v29 = v37;
        if (v27 <= 1) {
          unint64_t v27 = 1;
        }
        do
        {
          uint64_t v30 = *v28;
          v28 += 2;
          *v29++ += v30;
          --v27;
        }
        while (v27);
      }
      if (v37)
      {
        std::string::size_type v38 = v37;
        operator delete(v37);
      }
      if (v40)
      {
        uint64_t v41 = v40;
        operator delete(v40);
      }
      ++v24;
    }
    while (v24 != v25);
  }
  if (__p)
  {
    uint64_t v45 = (char *)__p;
    operator delete(__p);
  }
}

void sub_20F4CF848(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19)
{
  __cxa_free_exception(v19);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<BOOL>::Zeros(__n128 *a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t v4 = (uint64_t *)a1->n128_u64[0];
  size_t v5 = 1;
  while (v4 != (uint64_t *)a1->n128_u64[1])
  {
    uint64_t v6 = *v4++;
    v5 *= v6;
  }
  std::vector<unsigned char>::vector(&__p, v5);
  MIL::ValueInference::Tensor<BOOL>::Tensor(a2, a1, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
}

void sub_20F4CF95C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<BOOL>::Concat(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *a1;
  uint64_t v7 = 0;
  uint64_t v8 = a1[1] - *a1;
  if (v8)
  {
    unint64_t v9 = v8 >> 6;
    if (v9 <= 1) {
      unint64_t v9 = 1;
    }
    unint64_t v10 = (uint64_t *)(v6 + 8);
    do
    {
      uint64_t v11 = *v10;
      v10 += 8;
      v7 += *(void *)(v11 + 8 * a2);
      --v9;
    }
    while (v9);
  }
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  uint64_t v28 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v28, *(const void **)(v6 + 8), *(void *)(v6 + 16), (uint64_t)(*(void *)(v6 + 16) - *(void *)(v6 + 8)) >> 3);
  unint64_t v12 = v28;
  *((void *)v28 + a2) = v7;
  uint64_t v27 = 0;
  __n128 __p = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, v12, (uint64_t)v29, (v29 - (unsigned char *)v12) >> 3);
  MIL::ValueInference::Tensor<BOOL>::Zeros(&__p, a3);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  uint64_t v13 = *a1;
  uint64_t v14 = a1[1];
  if (v14 != *a1)
  {
    unint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      unint64_t v17 = *(void *)(v13 + (v15 << 6) + 40) - *(void *)(v13 + (v15 << 6) + 32);
      if (v17)
      {
        unint64_t v18 = 0;
        if (v17 <= 1) {
          uint64_t v19 = 1;
        }
        else {
          uint64_t v19 = *(void *)(v13 + (v15 << 6) + 40) - *(void *)(v13 + (v15 << 6) + 32);
        }
        do
        {
          size_t v21 = 0;
          uint64_t v22 = 0;
          uint64_t v23 = 0;
          std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v21, v24, (uint64_t)v25, (v25 - (unsigned char *)v24) >> 3);
          *((void *)v21 + a2) += v16;
          unint64_t v20 = *a1 + (v15 << 6);
          LOBYTE(v20) = *(unsigned char *)(*(void *)(v20 + 32)
          if (v21)
          {
            uint64_t v22 = v21;
            operator delete(v21);
          }
          if (v24)
          {
            uint64_t v25 = v24;
            operator delete(v24);
          }
          ++v18;
        }
        while (v19 != v18);
        uint64_t v13 = *a1;
        uint64_t v14 = a1[1];
      }
      v16 += *(void *)(*(void *)(v13 + (v15++ << 6) + 8) + 8 * a2);
    }
    while (v15 < (v14 - v13) >> 6);
  }
  if (v28)
  {
    uint64_t v29 = v28;
    operator delete(v28);
  }
}

void sub_20F4CFB60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  if (a18) {
    operator delete(a18);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<BOOL>::BlockwiseMerge(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *(uint64_t **)a2;
  uint64_t v7 = *(void *)(a2 + 8) - *(void *)a2;
  if (v7)
  {
    unint64_t v8 = v7 >> 3;
    if (v8 <= 1) {
      unint64_t v8 = 1;
    }
    uint64_t v9 = 1;
    do
    {
      uint64_t v10 = *v6++;
      v9 *= v10;
      --v8;
    }
    while (v8);
  }
  else
  {
    uint64_t v9 = 1;
  }
  uint64_t v11 = *a1;
  if (v9 != (a1[1] - *a1) >> 6)
  {
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v47);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v47, (uint64_t)"The number of tensors (", 23);
    uint64_t v35 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v35, (uint64_t)") is not the same as the number of blocks (", 43);
    int64_t v36 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v36, (uint64_t)").", 2);
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str();
    std::runtime_error::runtime_error(exception, &v46);
    __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
  }
  uint64_t v48 = 0;
  uint64_t v49 = 0;
  int v47 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v47, *(const void **)(v11 + 8), *(void *)(v11 + 16), (uint64_t)(*(void *)(v11 + 16) - *(void *)(v11 + 8)) >> 3);
  memset(&v46, 0, sizeof(v46));
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v46, v47, (uint64_t)v48, (v48 - (unsigned char *)v47) >> 3);
  unint64_t v12 = *(uint64_t **)a2;
  uint64_t v13 = (const void *)v46.__r_.__value_.__r.__words[0];
  uint64_t v14 = *(void *)(a2 + 8) - *(void *)a2;
  if (v14)
  {
    unint64_t v15 = v14 >> 3;
    if (v15 <= 1) {
      unint64_t v15 = 1;
    }
    uint64_t v16 = (void *)v46.__r_.__value_.__r.__words[0];
    do
    {
      uint64_t v17 = *v12++;
      *v16++ *= v17;
      --v15;
    }
    while (v15);
  }
  __n128 __p = 0uLL;
  uint64_t v45 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, v13, v46.__r_.__value_.__l.__size_, (uint64_t)(v46.__r_.__value_.__l.__size_ - (void)v13) >> 3);
  MIL::ValueInference::Tensor<BOOL>::Zeros(&__p, a3);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v9)
  {
    for (unint64_t i = 0; i != v9; ++i)
    {
      unint64_t v19 = *a1 + (i << 6);
      unint64_t v20 = *(const void **)(v19 + 8);
      size_t v21 = *(void *)(v19 + 16) - (void)v20;
      if (v21 != v48 - (unsigned char *)v47 || memcmp(v20, v47, v21))
      {
        uint64_t v34 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v34, "All tensors must have the same shape so they can be merged.");
        __cxa_throw(v34, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
      }
      unint64_t v22 = *(void *)(*a1 + (i << 6) + 40) - *(void *)(*a1 + (i << 6) + 32);
      if (v22)
      {
        unint64_t v23 = 0;
        if (v22 <= 1) {
          uint64_t v24 = 1;
        }
        else {
          uint64_t v24 = *(void *)(*a1 + (i << 6) + 40) - *(void *)(*a1 + (i << 6) + 32);
        }
        do
        {
          std::string::size_type v38 = 0;
          uint64_t v39 = 0;
          uint64_t v40 = 0;
          std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v38, v41, (uint64_t)v42, (v42 - (unsigned char *)v41) >> 3);
          uint64_t v25 = *(void *)(a2 + 8) - *(void *)a2;
          if (v25)
          {
            unint64_t v26 = v25 >> 3;
            uint64_t v27 = (uint64_t *)v47;
            uint64_t v28 = (uint64_t *)v43[0];
            uint64_t v29 = v38;
            if (v26 <= 1) {
              unint64_t v26 = 1;
            }
            do
            {
              uint64_t v31 = *v27++;
              uint64_t v30 = v31;
              uint64_t v32 = *v28++;
              *v29++ += v32 * v30;
              --v26;
            }
            while (v26);
          }
          unint64_t v33 = *a1 + (i << 6);
          LOBYTE(v33) = *(unsigned char *)(*(void *)(v33 + 32)
          if (v38)
          {
            uint64_t v39 = v38;
            operator delete(v38);
          }
          if (v41)
          {
            __n128 v42 = v41;
            operator delete(v41);
          }
          ++v23;
        }
        while (v23 != v24);
      }
      if (v43[0])
      {
        v43[1] = v43[0];
        operator delete(v43[0]);
      }
    }
  }
  if (v46.__r_.__value_.__r.__words[0])
  {
    v46.__r_.__value_.__l.__size_ = v46.__r_.__value_.__r.__words[0];
    operator delete(v46.__r_.__value_.__l.__data_);
  }
  if (v47)
  {
    uint64_t v48 = v47;
    operator delete(v47);
  }
}

void sub_20F4CFF64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28)
{
  if (a26 < 0)
  {
    operator delete(__p);
    if ((v29 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a27);
      _Unwind_Resume(a1);
    }
  }
  else if (!v29)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v28);
  goto LABEL_6;
}

uint64_t MIL::ValueInference::Tensor<BOOL>::Reduce@<X0>(void *a1@<X0>, unint64_t **a2@<X1>, int a3@<W2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v104 = a1[1];
  uint64_t v105 = a1 + 1;
  uint64_t v103 = a1[2];
  unint64_t v6 = (v103 - v104) >> 3;
  std::unordered_set<unsigned long long>::unordered_set<std::__wrap_iter<unsigned long long const*>>((uint64_t)v124, *a2, a2[1]);
  for (unint64_t i = v125; i; unint64_t i = (void *)*i)
  {
    if (i[2] >= v6)
    {
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&__p);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&__p, (uint64_t)"axis(", 5);
      uint64_t v92 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v92, (uint64_t)") must be smaller than the number of input dimensions(", 54);
      unint64_t v93 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v93, (uint64_t)").", 2);
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::stringbuf::str();
      std::logic_error::logic_error(exception, &v120);
      exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
      __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
    }
  }
  __n128 __p = 0;
  unint64_t v122 = 0;
  v123[0] = 0;
  memset(&v120, 0, sizeof(v120));
  std::string v117 = 0;
  std::string v118 = 0;
  unint64_t v119 = 0;
  if (v103 == v104)
  {
    uint64_t v54 = 0;
    uint64_t v53 = 0;
  }
  else
  {
    unint64_t v8 = 0;
    if (v6 <= 1) {
      uint64_t v9 = 1;
    }
    else {
      uint64_t v9 = (v103 - v104) >> 3;
    }
    do
    {
      v114[0] = v8;
      if (std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(v124, (unint64_t *)v114))
      {
        if (a3)
        {
          uint64_t v10 = v122;
          if ((unint64_t)v122 >= v123[0])
          {
            size_t v21 = (char *)__p;
            uint64_t v22 = (v122 - (unsigned char *)__p) >> 3;
            unint64_t v23 = v22 + 1;
            if ((unint64_t)(v22 + 1) >> 61) {
              std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v24 = v123[0] - (void)__p;
            if ((uint64_t)(v123[0] - (void)__p) >> 2 > v23) {
              unint64_t v23 = v24 >> 2;
            }
            if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v25 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v25 = v23;
            }
            if (v25)
            {
              unint64_t v26 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)v123, v25);
              size_t v21 = (char *)__p;
              uint64_t v10 = v122;
            }
            else
            {
              unint64_t v26 = 0;
            }
            uint64_t v40 = &v26[8 * v22];
            *(void *)uint64_t v40 = 1;
            uint64_t v11 = v40 + 8;
            while (v10 != v21)
            {
              uint64_t v41 = *((void *)v10 - 1);
              v10 -= 8;
              *((void *)v40 - 1) = v41;
              v40 -= 8;
            }
            __n128 __p = v40;
            unint64_t v122 = v11;
            v123[0] = &v26[8 * v25];
            if (v21) {
              operator delete(v21);
            }
          }
          else
          {
            *(void *)unint64_t v122 = 1;
            uint64_t v11 = v10 + 8;
          }
          unint64_t v122 = v11;
        }
        uint64_t v42 = *v105;
        uint64_t v43 = v118;
        if (v118 >= v119)
        {
          uint64_t v45 = (char *)v117;
          uint64_t v46 = (v118 - (unsigned char *)v117) >> 3;
          unint64_t v47 = v46 + 1;
          if ((unint64_t)(v46 + 1) >> 61) {
LABEL_155:
          }
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          uint64_t v48 = v119 - (unsigned char *)v117;
          if ((v119 - (unsigned char *)v117) >> 2 > v47) {
            unint64_t v47 = v48 >> 2;
          }
          if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v49 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v49 = v47;
          }
          if (v49)
          {
            unint64_t v50 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v119, v49);
            uint64_t v45 = (char *)v117;
            uint64_t v43 = v118;
          }
          else
          {
            unint64_t v50 = 0;
          }
          uint64_t v51 = &v50[8 * v46];
          *(void *)uint64_t v51 = *(void *)(v42 + 8 * (void)v8);
          uint64_t v44 = v51 + 8;
          while (v43 != v45)
          {
            uint64_t v52 = *((void *)v43 - 1);
            v43 -= 8;
            *((void *)v51 - 1) = v52;
            v51 -= 8;
          }
          std::string v117 = v51;
          std::string v118 = v44;
          unint64_t v119 = &v50[8 * v49];
          if (v45) {
            operator delete(v45);
          }
        }
        else
        {
          *(void *)std::string v118 = *(void *)(v42 + 8 * (void)v8);
          uint64_t v44 = v43 + 8;
        }
        std::string v118 = v44;
      }
      else
      {
        uint64_t v12 = *v105;
        uint64_t v13 = v122;
        if ((unint64_t)v122 >= v123[0])
        {
          unint64_t v15 = (char *)__p;
          uint64_t v16 = (v122 - (unsigned char *)__p) >> 3;
          unint64_t v17 = v16 + 1;
          if ((unint64_t)(v16 + 1) >> 61) {
            goto LABEL_155;
          }
          uint64_t v18 = v123[0] - (void)__p;
          if ((uint64_t)(v123[0] - (void)__p) >> 2 > v17) {
            unint64_t v17 = v18 >> 2;
          }
          if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v19 = v17;
          }
          if (v19)
          {
            unint64_t v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)v123, v19);
            unint64_t v15 = (char *)__p;
            uint64_t v13 = v122;
          }
          else
          {
            unint64_t v20 = 0;
          }
          uint64_t v27 = &v20[8 * v16];
          *(void *)uint64_t v27 = *(void *)(v12 + 8 * (void)v8);
          uint64_t v14 = v27 + 8;
          while (v13 != v15)
          {
            uint64_t v28 = *((void *)v13 - 1);
            v13 -= 8;
            *((void *)v27 - 1) = v28;
            v27 -= 8;
          }
          __n128 __p = v27;
          unint64_t v122 = v14;
          v123[0] = &v20[8 * v19];
          if (v15) {
            operator delete(v15);
          }
        }
        else
        {
          *(void *)unint64_t v122 = *(void *)(v12 + 8 * (void)v8);
          uint64_t v14 = v13 + 8;
        }
        unint64_t v122 = v14;
        uint64_t v29 = *v105;
        std::string::size_type size = v120.__r_.__value_.__l.__size_;
        if (v120.__r_.__value_.__l.__size_ >= v120.__r_.__value_.__r.__words[2])
        {
          uint64_t v32 = (void *)v120.__r_.__value_.__r.__words[0];
          uint64_t v33 = (uint64_t)(v120.__r_.__value_.__l.__size_ - v120.__r_.__value_.__r.__words[0]) >> 3;
          unint64_t v34 = v33 + 1;
          if ((unint64_t)(v33 + 1) >> 61) {
            goto LABEL_155;
          }
          int64_t v35 = v120.__r_.__value_.__r.__words[2] - v120.__r_.__value_.__r.__words[0];
          if ((uint64_t)(v120.__r_.__value_.__r.__words[2] - v120.__r_.__value_.__r.__words[0]) >> 2 > v34) {
            unint64_t v34 = v35 >> 2;
          }
          if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v36 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v36 = v34;
          }
          if (v36)
          {
            unint64_t v37 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v120.__r_.__value_.__r.__words[2], v36);
            std::string::size_type size = v120.__r_.__value_.__l.__size_;
            uint64_t v32 = (void *)v120.__r_.__value_.__r.__words[0];
          }
          else
          {
            unint64_t v37 = 0;
          }
          std::string::size_type v38 = &v37[8 * v33];
          *(void *)std::string::size_type v38 = *(void *)(v29 + 8 * (void)v8);
          std::string::size_type v31 = (std::string::size_type)(v38 + 8);
          while ((void *)size != v32)
          {
            uint64_t v39 = *(void *)(size - 8);
            size -= 8;
            *((void *)v38 - 1) = v39;
            v38 -= 8;
          }
          v120.__r_.__value_.__r.__words[0] = (std::string::size_type)v38;
          v120.__r_.__value_.__l.__size_ = v31;
          v120.__r_.__value_.__r.__words[2] = (std::string::size_type)&v37[8 * v36];
          if (v32) {
            operator delete(v32);
          }
        }
        else
        {
          *(void *)v120.__r_.__value_.__l.__size_ = *(void *)(v29 + 8 * (void)v8);
          std::string::size_type v31 = size + 8;
        }
        v120.__r_.__value_.__l.__size_ = v31;
      }
      unint64_t v8 = (char *)v8 + 1;
    }
    while (v8 != (void *)v9);
    uint64_t v53 = __p;
    uint64_t v54 = (uint64_t)v122;
  }
  __n128 v115 = 0uLL;
  uint64_t v116 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v115, v53, v54, (v54 - (uint64_t)v53) >> 3);
  MIL::ValueInference::Tensor<BOOL>::Zeros(&v115, a5);
  if (v115.n128_u64[0])
  {
    v115.n128_u64[1] = v115.n128_u64[0];
    operator delete((void *)v115.n128_u64[0]);
  }
  unint64_t v97 = *(void *)(a5 + 40) - *(void *)(a5 + 32);
  if (v97)
  {
    unint64_t v55 = 0;
    unint64_t v96 = a1[5] - a1[4];
    unint64_t v56 = v96 / v97;
    unint64_t v57 = (uint64_t **)(a5 + 8);
    if (v6 <= 1) {
      uint64_t v58 = 1;
    }
    else {
      uint64_t v58 = (v103 - v104) >> 3;
    }
    if (v97 <= 1) {
      uint64_t v59 = 1;
    }
    else {
      uint64_t v59 = *(void *)(a5 + 40) - *(void *)(a5 + 32);
    }
    uint64_t v95 = v59;
    if (v56 <= 1) {
      unint64_t v56 = 1;
    }
    unint64_t v101 = v56;
    do
    {
      unint64_t v99 = v55;
      if (v97 <= v96)
      {
        unint64_t v61 = 0;
        int v106 = 0;
        BOOL v60 = 0;
        do
        {
          char v107 = v60;
          uint64_t v109 = 0;
          unint64_t v110 = 0;
          __n128 v111 = 0;
          if (v103 != v104)
          {
            unint64_t v62 = 0;
            uint64_t v63 = 0;
            uint64_t v64 = 0;
            do
            {
              unint64_t v108 = v62;
              unint64_t v65 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(v124, &v108);
              uint64_t v66 = v110;
              if (v65)
              {
                uint64_t v67 = v112;
                if (v110 >= v111)
                {
                  uint64_t v71 = (char *)v109;
                  uint64_t v72 = (v110 - (unsigned char *)v109) >> 3;
                  unint64_t v73 = v72 + 1;
                  if ((unint64_t)(v72 + 1) >> 61) {
                    goto LABEL_153;
                  }
                  uint64_t v74 = v111 - (unsigned char *)v109;
                  if ((v111 - (unsigned char *)v109) >> 2 > v73) {
                    unint64_t v73 = v74 >> 2;
                  }
                  if ((unint64_t)v74 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v75 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v75 = v73;
                  }
                  if (v75)
                  {
                    unint64_t v76 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v111, v75);
                    uint64_t v71 = (char *)v109;
                    uint64_t v66 = v110;
                  }
                  else
                  {
                    unint64_t v76 = 0;
                  }
                  uint64_t v83 = &v76[8 * v72];
                  *(void *)uint64_t v83 = v67[v63];
                  uint64_t v68 = v83 + 8;
                  while (v66 != v71)
                  {
                    uint64_t v84 = *((void *)v66 - 1);
                    v66 -= 8;
                    *((void *)v83 - 1) = v84;
                    v83 -= 8;
                  }
                  uint64_t v109 = v83;
                  unint64_t v110 = v68;
                  __n128 v111 = &v76[8 * v75];
                  if (v71) {
                    operator delete(v71);
                  }
                }
                else
                {
                  *(void *)unint64_t v110 = *((void *)v112 + v63);
                  uint64_t v68 = v66 + 8;
                }
                unint64_t v110 = v68;
                ++v63;
              }
              else
              {
                uint64_t v69 = v114[0];
                if (v110 >= v111)
                {
                  uint64_t v77 = (char *)v109;
                  uint64_t v78 = (v110 - (unsigned char *)v109) >> 3;
                  unint64_t v79 = v78 + 1;
                  if ((unint64_t)(v78 + 1) >> 61) {
LABEL_153:
                  }
                    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
                  uint64_t v80 = v111 - (unsigned char *)v109;
                  if ((v111 - (unsigned char *)v109) >> 2 > v79) {
                    unint64_t v79 = v80 >> 2;
                  }
                  if ((unint64_t)v80 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v81 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v81 = v79;
                  }
                  if (v81)
                  {
                    unint64_t v82 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v111, v81);
                    uint64_t v77 = (char *)v109;
                    uint64_t v66 = v110;
                  }
                  else
                  {
                    unint64_t v82 = 0;
                  }
                  uint64_t v85 = &v82[8 * v78];
                  *(void *)uint64_t v85 = v69[v64];
                  uint64_t v70 = v85 + 8;
                  while (v66 != v77)
                  {
                    uint64_t v86 = *((void *)v66 - 1);
                    v66 -= 8;
                    *((void *)v85 - 1) = v86;
                    v85 -= 8;
                  }
                  uint64_t v109 = v85;
                  unint64_t v110 = v70;
                  __n128 v111 = &v82[8 * v81];
                  if (v77) {
                    operator delete(v77);
                  }
                }
                else
                {
                  *(void *)unint64_t v110 = *((void *)v114[0] + v64);
                  uint64_t v70 = v66 + 8;
                }
                unint64_t v110 = v70;
                ++v64;
              }
              ++v62;
            }
            while (v62 != v58);
          }
          uint64_t v88 = a1[4];
          int v89 = *(unsigned __int8 *)(v88 + v87);
          BOOL v90 = *(unsigned char *)(v88 + v87) != 0;
          if (v106)
          {
            BOOL v60 = std::function<unsigned char ()(unsigned char,unsigned char)>::operator()(a4, v107, v89 != 0) != 0;
          }
          else
          {
            int v106 = 1;
            BOOL v60 = v90;
          }
          unint64_t v57 = (uint64_t **)(a5 + 8);
          if (v109)
          {
            unint64_t v110 = (char *)v109;
            operator delete(v109);
          }
          if (v112)
          {
            __n128 v113 = v112;
            operator delete(v112);
          }
          ++v61;
        }
        while (v61 != v101);
      }
      else
      {
        BOOL v60 = 0;
      }
      if (v112)
      {
        __n128 v113 = v112;
        operator delete(v112);
      }
      if (v114[0])
      {
        v114[1] = v114[0];
        operator delete(v114[0]);
      }
      unint64_t v55 = v99 + 1;
    }
    while (v99 + 1 != v95);
  }
  if (v117)
  {
    std::string v118 = (char *)v117;
    operator delete(v117);
  }
  if (v120.__r_.__value_.__r.__words[0])
  {
    v120.__r_.__value_.__l.__size_ = v120.__r_.__value_.__r.__words[0];
    operator delete(v120.__r_.__value_.__l.__data_);
  }
  if (__p)
  {
    unint64_t v122 = (char *)__p;
    operator delete(__p);
  }
  return std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table((uint64_t)v124);
}

void sub_20F4D08BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37,uint64_t a38,void *__p,uint64_t a40,int a41,__int16 a42,char a43,char a44,void *a45,uint64_t a46)
{
  if (a44 < 0)
  {
    operator delete(__p);
    if ((v47 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a45);
      std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table(v48 - 128);
      _Unwind_Resume(a1);
    }
  }
  else if (!v47)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v46);
  goto LABEL_6;
}

void MIL::ValueInference::Tensor<BOOL>::Zeros(MIL *a1@<X0>, const MIL::IRTensorValueType *a2@<X1>, uint64_t a3@<X8>)
{
  MIL::GetTensorShapeWithDimensionsAllKnown(a1, a2, (uint64_t)v6);
  *(_OWORD *)__n128 __p = *(_OWORD *)v6;
  uint64_t v5 = v7;
  v6[1] = 0;
  uint64_t v7 = 0;
  v6[0] = 0;
  MIL::ValueInference::Tensor<BOOL>::Zeros((__n128 *)__p, a3);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v6[0])
  {
    v6[1] = v6[0];
    operator delete(v6[0]);
  }
}

void sub_20F4D0A50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  if (__p) {
    operator delete(__p);
  }
  if (a13) {
    operator delete(a13);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<MIL::Bf16>::FromIRTensorValue(void *a1@<X0>, uint64_t a2@<X8>)
{
  MIL::IRTensorValue::TryGetDataView<MIL::Bf16>(&v12, *a1);
  if (!(_BYTE)v12)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Failed to get data view.");
    uint64_t v7 = (struct type_info *)MEMORY[0x263F8C1F0];
    unint64_t v8 = (void (*)(void *))MEMORY[0x263F8C070];
    goto LABEL_10;
  }
  unint64_t v4 = (MIL *)(*(uint64_t (**)(void))(*(void *)*a1 + 32))();
  if ((*(unsigned int (**)(MIL *))(*(void *)v4 + 88))(v4) == 3)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100]((std::logic_error *)exception, "It is not supported to convert a tensor of string dtype.");
    uint64_t v7 = (struct type_info *)off_26412C1F0;
    unint64_t v8 = (void (*)(void *))MEMORY[0x263F8C080];
LABEL_10:
    __cxa_throw(exception, v7, v8);
  }
  MIL::GetTensorShapeWithDimensionsAllKnown(v4, v5, (uint64_t)&v11);
  uint64_t v10 = 0;
  __n128 __p = 0uLL;
  std::vector<MIL::Bf16>::__init_with_size[abi:ne180100]<MIL::Bf16 const*,MIL::Bf16 const*>(&__p, v13, (uint64_t)v13 + 2 * v14, v14);
  MIL::ValueInference::Tensor<MIL::Bf16>::Tensor(a2, &v11, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v11.n128_u64[0])
  {
    v11.n128_u64[1] = v11.n128_u64[0];
    operator delete((void *)v11.n128_u64[0]);
  }
}

void sub_20F4D0BD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  __cxa_free_exception(v14);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<MIL::Bf16>::ToIRTensorValue(uint64_t a1, MIL::IRConstantDimension *a2)
{
  memset(__p, 0, sizeof(__p));
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(__p, *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3);
  MIL::IRTensorValueType::Make(a2, 7, (MIL::MILContext ***)__p);
}

void sub_20F4D0CDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::ValueInference::Tensor<MIL::Bf16>::Tensor(uint64_t a1, __n128 *a2, __n128 *a3)
{
  *(_OWORD *)(a1 + 8) = 0u;
  uint64_t v5 = a1 + 8;
  *(void *)a1 = &unk_26C25DB98;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  unint64_t v6 = (uint64_t *)a2->n128_u64[0];
  uint64_t v7 = (uint64_t *)a2->n128_u64[1];
  if ((uint64_t *)a2->n128_u64[0] == v7)
  {
    unint64_t v10 = a3->n128_u64[0];
    unint64_t v11 = a3->n128_u64[1];
    uint64_t v8 = a3->n128_u64[0] != v11;
  }
  else
  {
    uint64_t v8 = 1;
    do
    {
      uint64_t v9 = *v6++;
      v8 *= v9;
    }
    while (v6 != v7);
    unint64_t v10 = a3->n128_u64[0];
    unint64_t v11 = a3->n128_u64[1];
  }
  if (v8 != (uint64_t)(v11 - v10) >> 1)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "data size and shape dismatch.");
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  std::vector<float>::__move_assign(v5, a2);
  std::vector<float>::__move_assign(a1 + 32, a3);
  *(void *)(a1 + 56) = v8;
  return a1;
}

void sub_20F4D0E14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10)
{
  uint64_t v13 = *v11;
  if (*v11)
  {
    *(void *)(v10 + 40) = v13;
    operator delete(v13);
  }
  uint64_t v14 = *a10;
  if (*a10)
  {
    *(void *)(v10 + 16) = v14;
    operator delete(v14);
  }
  _Unwind_Resume(exception_object);
}

double MIL::ValueInference::Tensor<MIL::Bf16>::Tensor(uint64_t a1)
{
  *(void *)a1 = &unk_26C25DB98;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  return result;
}

uint64_t MIL::ValueInference::Tensor<MIL::Bf16>::GetScalarData(void *a1)
{
  if (a1[1] != a1[2] || (uint64_t v1 = (unsigned __int16 *)a1[4], a1[5] - (void)v1 != 2))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Tensor is not a scalar.");
    __cxa_throw(exception, MEMORY[0x263F8C1E0], MEMORY[0x263F8C048]);
  }
  return *v1;
}

void sub_20F4D0EF8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<MIL::Bf16>::Reshape(void *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v6 = (uint64_t *)*a2;
  uint64_t v7 = a2[1];
  uint64_t v8 = 1;
  if (v6 != (uint64_t *)v7)
  {
    uint64_t v9 = v6;
    do
    {
      uint64_t v10 = *v9++;
      v8 *= v10;
    }
    while (v9 != (uint64_t *)v7);
  }
  if (a1[7] != v8)
  {
    uint64_t v13 = a2;
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v22);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"Tensor is not able to be reshaped since the number of elements in the newShape [ ", 81);
    uint64_t v14 = *v13;
    uint64_t v15 = v13[1];
    if (*v13 != v15)
    {
      do
      {
        uint64_t v16 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)" ", 1);
        v14 += 8;
      }
      while (v14 != v15);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"] is not the same as the number of elements in the tensor shape [ ", 66);
    uint64_t v17 = a1[1];
    for (uint64_t i = a1[2]; v17 != i; v17 += 8)
    {
      unint64_t v19 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)" ", 1);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"].", 2);
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str();
    std::logic_error::logic_error(exception, &__p);
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  __n128 v22 = 0uLL;
  uint64_t v23 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v22, v6, v7, (v7 - (uint64_t)v6) >> 3);
  unint64_t v11 = (const void *)a1[4];
  uint64_t v12 = a1[5];
  memset(&__p, 0, sizeof(__p));
  std::vector<MIL::Bf16>::__init_with_size[abi:ne180100]<std::__wrap_iter<MIL::Bf16 const*>,std::__wrap_iter<MIL::Bf16 const*>>(&__p, v11, v12, (v12 - (uint64_t)v11) >> 1);
  MIL::ValueInference::Tensor<MIL::Bf16>::Tensor(a3, &v22, (__n128 *)&__p);
  if (__p.__r_.__value_.__r.__words[0])
  {
    __p.__r_.__value_.__l.__size_ = __p.__r_.__value_.__r.__words[0];
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v22.n128_u64[0])
  {
    v22.n128_u64[1] = v22.n128_u64[0];
    operator delete((void *)v22.n128_u64[0]);
  }
}

void sub_20F4D110C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((v17 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v17)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v16);
  goto LABEL_6;
}

void MIL::ValueInference::Tensor<MIL::Bf16>::NonZero(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  if (*(void *)(a1 + 56))
  {
    unint64_t v4 = 0;
    uint64_t v5 = (uint64_t **)(a1 + 8);
    do
    {
      __int16 v7 = *(_WORD *)(*(void *)(a1 + 32) + 2 * v4);
      if (MIL::Bf16::GetFloat((MIL::Bf16 *)&v7) != 0.0)
      {
        std::vector<std::vector<unsigned long long>>::push_back[abi:ne180100](a2, (uint64_t)__p);
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
      }
      ++v4;
    }
    while (v4 < *(void *)(a1 + 56));
  }
}

void sub_20F4D1230(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
  {
    a10 = (uint64_t)__p;
    operator delete(__p);
  }
  std::vector<std::vector<unsigned long long>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<MIL::Bf16>::SubTensor(void *a1@<X0>, uint64_t **a2@<X1>, void *a3@<X8>)
{
  unint64_t v5 = ((char *)a2[1] - (char *)*a2) >> 4;
  unint64_t v6 = a1 + 1;
  if (v5 != (uint64_t)(a1[2] - a1[1]) >> 3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "Indices does not match the rank of the tensor.");
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  std::string __p = 0;
  int v47 = 0;
  uint64_t v48 = 0;
  std::vector<unsigned long long>::reserve(&__p, v5);
  uint64_t v8 = a1[1];
  if (a1[2] != v8)
  {
    unint64_t v9 = 0;
    while (1)
    {
      unint64_t v11 = (*a2)[2 * v9];
      unint64_t v10 = (*a2)[2 * v9 + 1];
      unint64_t v12 = v10 - v11;
      if (v10 < v11) {
        break;
      }
      if (v10 > *(void *)(v8 + 8 * v9))
      {
        unint64_t v34 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(v34, "Indices end is out of the bound for the tensor dimension.");
        int64_t v35 = (void (*)(void *))MEMORY[0x263F8C068];
        unint64_t v36 = (struct type_info *)off_26412C1E0;
        uint64_t v37 = MEMORY[0x263F8C390] + 16;
LABEL_45:
        v34->__vftable = (std::logic_error_vtbl *)v37;
        __cxa_throw(v34, v36, v35);
      }
      uint64_t v13 = v47;
      if (v47 >= v48)
      {
        uint64_t v15 = (char *)__p;
        uint64_t v16 = (v47 - (unsigned char *)__p) >> 3;
        unint64_t v17 = v16 + 1;
        if ((unint64_t)(v16 + 1) >> 61) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v18 = v48 - (unsigned char *)__p;
        if ((v48 - (unsigned char *)__p) >> 2 > v17) {
          unint64_t v17 = v18 >> 2;
        }
        if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v19 = v17;
        }
        if (v19)
        {
          unint64_t v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v48, v19);
          uint64_t v15 = (char *)__p;
          uint64_t v13 = v47;
        }
        else
        {
          unint64_t v20 = 0;
        }
        size_t v21 = &v20[8 * v16];
        *(void *)size_t v21 = v12;
        uint64_t v14 = (uint64_t)(v21 + 8);
        while (v13 != v15)
        {
          uint64_t v22 = *((void *)v13 - 1);
          v13 -= 8;
          *((void *)v21 - 1) = v22;
          v21 -= 8;
        }
        std::string __p = v21;
        int v47 = (char *)v14;
        uint64_t v48 = &v20[8 * v19];
        if (v15) {
          operator delete(v15);
        }
      }
      else
      {
        *(void *)int v47 = v12;
        uint64_t v14 = (uint64_t)(v13 + 8);
      }
      int v47 = (char *)v14;
      ++v9;
      uint64_t v8 = a1[1];
      if (v9 >= (a1[2] - v8) >> 3) {
        goto LABEL_25;
      }
    }
    unint64_t v34 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v34, "Indices end must not be smaller than the indices begin.");
    int64_t v35 = (void (*)(void *))MEMORY[0x263F8C080];
    unint64_t v36 = (struct type_info *)off_26412C1F0;
    uint64_t v37 = MEMORY[0x263F8C3A0] + 16;
    goto LABEL_45;
  }
  uint64_t v14 = (uint64_t)v47;
LABEL_25:
  __n128 v44 = 0uLL;
  uint64_t v45 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v44, __p, v14, (v14 - (uint64_t)__p) >> 3);
  MIL::ValueInference::Tensor<MIL::Bf16>::Zeros(&v44, (uint64_t)a3);
  if (v44.n128_u64[0])
  {
    v44.n128_u64[1] = v44.n128_u64[0];
    operator delete((void *)v44.n128_u64[0]);
  }
  uint64_t v23 = a3[5] - a3[4];
  if (v23)
  {
    unint64_t v24 = 0;
    unint64_t v25 = v23 >> 1;
    if (v25 <= 1) {
      uint64_t v26 = 1;
    }
    else {
      uint64_t v26 = v25;
    }
    do
    {
      uint64_t v39 = 0;
      uint64_t v40 = 0;
      uint64_t v41 = 0;
      std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v39, v42, (uint64_t)v43, (v43 - (unsigned char *)v42) >> 3);
      uint64_t v27 = a1[2] - a1[1];
      if (v27)
      {
        unint64_t v28 = v27 >> 3;
        uint64_t v29 = *a2;
        uint64_t v30 = v39;
        if (v28 <= 1) {
          unint64_t v28 = 1;
        }
        do
        {
          uint64_t v31 = *v29;
          v29 += 2;
          *v30++ += v31;
          --v28;
        }
        while (v28);
      }
      uint64_t v33 = a1[4];
      if (v39)
      {
        uint64_t v40 = v39;
        operator delete(v39);
      }
      if (v42)
      {
        uint64_t v43 = v42;
        operator delete(v42);
      }
      ++v24;
    }
    while (v24 != v26);
  }
  if (__p)
  {
    int v47 = (char *)__p;
    operator delete(__p);
  }
}

void sub_20F4D15EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19)
{
  __cxa_free_exception(v19);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<MIL::Bf16>::Zeros(__n128 *a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t v4 = (uint64_t *)a1->n128_u64[0];
  uint64_t v5 = 1;
  while (v4 != (uint64_t *)a1->n128_u64[1])
  {
    uint64_t v6 = *v4++;
    v5 *= v6;
  }
  std::vector<MIL::Bf16>::vector(&__p, v5);
  MIL::ValueInference::Tensor<MIL::Bf16>::Tensor(a2, a1, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
}

void sub_20F4D1700(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<MIL::Bf16>::Concat(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *a1;
  uint64_t v7 = 0;
  uint64_t v8 = a1[1] - *a1;
  if (v8)
  {
    unint64_t v9 = v8 >> 6;
    if (v9 <= 1) {
      unint64_t v9 = 1;
    }
    unint64_t v10 = (uint64_t *)(v6 + 8);
    do
    {
      uint64_t v11 = *v10;
      v10 += 8;
      v7 += *(void *)(v11 + 8 * a2);
      --v9;
    }
    while (v9);
  }
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  uint64_t v30 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v30, *(const void **)(v6 + 8), *(void *)(v6 + 16), (uint64_t)(*(void *)(v6 + 16) - *(void *)(v6 + 8)) >> 3);
  unint64_t v12 = v30;
  *((void *)v30 + a2) = v7;
  uint64_t v29 = 0;
  __n128 __p = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, v12, (uint64_t)v31, (v31 - (unsigned char *)v12) >> 3);
  MIL::ValueInference::Tensor<MIL::Bf16>::Zeros(&__p, a3);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  uint64_t v13 = *a1;
  uint64_t v14 = a1[1];
  if (v14 != *a1)
  {
    unint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(void *)(v13 + (v15 << 6) + 40) - *(void *)(v13 + (v15 << 6) + 32);
      if (v17)
      {
        unint64_t v18 = 0;
        if ((unint64_t)(v17 >> 1) <= 1) {
          uint64_t v19 = 1;
        }
        else {
          uint64_t v19 = v17 >> 1;
        }
        do
        {
          uint64_t v23 = 0;
          unint64_t v24 = 0;
          uint64_t v25 = 0;
          std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v23, v26, (uint64_t)v27, (v27 - (unsigned char *)v26) >> 3);
          *((void *)v23 + a2) += v16;
          unint64_t v20 = *a1 + (v15 << 6);
          uint64_t v22 = *(void *)(v20 + 32);
          *(_WORD *)(*(void *)(a3 + 32)
          if (v23)
          {
            unint64_t v24 = v23;
            operator delete(v23);
          }
          if (v26)
          {
            uint64_t v27 = v26;
            operator delete(v26);
          }
          ++v18;
        }
        while (v19 != v18);
        uint64_t v13 = *a1;
        uint64_t v14 = a1[1];
      }
      v16 += *(void *)(*(void *)(v13 + (v15++ << 6) + 8) + 8 * a2);
    }
    while (v15 < (v14 - v13) >> 6);
  }
  if (v30)
  {
    uint64_t v31 = v30;
    operator delete(v30);
  }
}

void sub_20F4D190C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  if (a18) {
    operator delete(a18);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<MIL::Bf16>::BlockwiseMerge(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *(uint64_t **)a2;
  uint64_t v7 = *(void *)(a2 + 8) - *(void *)a2;
  if (v7)
  {
    unint64_t v8 = v7 >> 3;
    if (v8 <= 1) {
      unint64_t v8 = 1;
    }
    uint64_t v9 = 1;
    do
    {
      uint64_t v10 = *v6++;
      v9 *= v10;
      --v8;
    }
    while (v8);
  }
  else
  {
    uint64_t v9 = 1;
  }
  uint64_t v11 = *a1;
  if (v9 != (a1[1] - *a1) >> 6)
  {
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v50);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v50, (uint64_t)"The number of tensors (", 23);
    std::string::size_type v38 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v38, (uint64_t)") is not the same as the number of blocks (", 43);
    uint64_t v39 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v39, (uint64_t)").", 2);
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str();
    std::runtime_error::runtime_error(exception, &v49);
    __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
  }
  uint64_t v51 = 0;
  uint64_t v52 = 0;
  unint64_t v50 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v50, *(const void **)(v11 + 8), *(void *)(v11 + 16), (uint64_t)(*(void *)(v11 + 16) - *(void *)(v11 + 8)) >> 3);
  memset(&v49, 0, sizeof(v49));
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v49, v50, (uint64_t)v51, (v51 - (unsigned char *)v50) >> 3);
  unint64_t v12 = *(uint64_t **)a2;
  uint64_t v13 = (const void *)v49.__r_.__value_.__r.__words[0];
  uint64_t v14 = *(void *)(a2 + 8) - *(void *)a2;
  if (v14)
  {
    unint64_t v15 = v14 >> 3;
    if (v15 <= 1) {
      unint64_t v15 = 1;
    }
    uint64_t v16 = (void *)v49.__r_.__value_.__r.__words[0];
    do
    {
      uint64_t v17 = *v12++;
      *v16++ *= v17;
      --v15;
    }
    while (v15);
  }
  __n128 __p = 0uLL;
  uint64_t v48 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, v13, v49.__r_.__value_.__l.__size_, (uint64_t)(v49.__r_.__value_.__l.__size_ - (void)v13) >> 3);
  MIL::ValueInference::Tensor<MIL::Bf16>::Zeros(&__p, a3);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v9)
  {
    for (unint64_t i = 0; i != v9; ++i)
    {
      unint64_t v19 = *a1 + (i << 6);
      unint64_t v20 = *(const void **)(v19 + 8);
      size_t v21 = *(void *)(v19 + 16) - (void)v20;
      if (v21 != v51 - (unsigned char *)v50 || memcmp(v20, v50, v21))
      {
        uint64_t v37 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v37, "All tensors must have the same shape so they can be merged.");
        __cxa_throw(v37, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
      }
      uint64_t v22 = *(void *)(*a1 + (i << 6) + 40) - *(void *)(*a1 + (i << 6) + 32);
      if (v22)
      {
        unint64_t v23 = 0;
        unint64_t v24 = v22 >> 1;
        if (v24 <= 1) {
          uint64_t v25 = 1;
        }
        else {
          uint64_t v25 = v24;
        }
        do
        {
          uint64_t v41 = 0;
          uint64_t v42 = 0;
          uint64_t v43 = 0;
          std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v41, v44, (uint64_t)v45, (v45 - (unsigned char *)v44) >> 3);
          uint64_t v26 = *(void *)(a2 + 8) - *(void *)a2;
          if (v26)
          {
            unint64_t v27 = v26 >> 3;
            unint64_t v28 = (uint64_t *)v50;
            uint64_t v29 = (uint64_t *)v46[0];
            uint64_t v30 = v41;
            if (v27 <= 1) {
              unint64_t v27 = 1;
            }
            do
            {
              uint64_t v32 = *v28++;
              uint64_t v31 = v32;
              uint64_t v33 = *v29++;
              *v30++ += v33 * v31;
              --v27;
            }
            while (v27);
          }
          unint64_t v34 = *a1 + (i << 6);
          uint64_t v36 = *(void *)(v34 + 32);
          *(_WORD *)(*(void *)(a3 + 32)
          if (v41)
          {
            uint64_t v42 = v41;
            operator delete(v41);
          }
          if (v44)
          {
            uint64_t v45 = v44;
            operator delete(v44);
          }
          ++v23;
        }
        while (v23 != v25);
      }
      if (v46[0])
      {
        v46[1] = v46[0];
        operator delete(v46[0]);
      }
    }
  }
  if (v49.__r_.__value_.__r.__words[0])
  {
    v49.__r_.__value_.__l.__size_ = v49.__r_.__value_.__r.__words[0];
    operator delete(v49.__r_.__value_.__l.__data_);
  }
  if (v50)
  {
    uint64_t v51 = v50;
    operator delete(v50);
  }
}

void sub_20F4D1D18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29)
{
  if (a27 < 0)
  {
    operator delete(__p);
    if ((v30 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a28);
      _Unwind_Resume(a1);
    }
  }
  else if (!v30)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v29);
  goto LABEL_6;
}

uint64_t MIL::ValueInference::Tensor<MIL::Bf16>::Reduce@<X0>(void *a1@<X0>, unint64_t **a2@<X1>, int a3@<W2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v103 = a1[1];
  uint64_t v104 = a1 + 1;
  uint64_t v102 = a1[2];
  unint64_t v7 = (v102 - v103) >> 3;
  std::unordered_set<unsigned long long>::unordered_set<std::__wrap_iter<unsigned long long const*>>((uint64_t)v123, *a2, a2[1]);
  for (unint64_t i = v124; i; unint64_t i = (void *)*i)
  {
    if (i[2] >= v7)
    {
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&__p);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&__p, (uint64_t)"axis(", 5);
      uint64_t v91 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v91, (uint64_t)") must be smaller than the number of input dimensions(", 54);
      uint64_t v92 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v92, (uint64_t)").", 2);
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::stringbuf::str();
      std::logic_error::logic_error(exception, &v119);
      exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
      __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
    }
  }
  __n128 __p = 0;
  long long v121 = 0;
  v122[0] = 0;
  memset(&v119, 0, sizeof(v119));
  uint64_t v116 = 0;
  std::string v117 = 0;
  std::string v118 = 0;
  if (v102 == v103)
  {
    uint64_t v55 = 0;
    uint64_t v54 = 0;
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t v5 = v122;
    if (v7 <= 1) {
      uint64_t v10 = 1;
    }
    else {
      uint64_t v10 = (v102 - v103) >> 3;
    }
    do
    {
      v113[0] = v9;
      if (std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(v123, (unint64_t *)v113))
      {
        if (a3)
        {
          uint64_t v11 = v121;
          if ((unint64_t)v121 >= v122[0])
          {
            uint64_t v22 = (char *)__p;
            uint64_t v23 = (v121 - (unsigned char *)__p) >> 3;
            unint64_t v24 = v23 + 1;
            if ((unint64_t)(v23 + 1) >> 61) {
              std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v25 = v122[0] - (void)__p;
            if ((uint64_t)(v122[0] - (void)__p) >> 2 > v24) {
              unint64_t v24 = v25 >> 2;
            }
            if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v26 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v26 = v24;
            }
            if (v26)
            {
              unint64_t v27 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)v122, v26);
              uint64_t v22 = (char *)__p;
              uint64_t v11 = v121;
            }
            else
            {
              unint64_t v27 = 0;
            }
            uint64_t v41 = &v27[8 * v23];
            *(void *)uint64_t v41 = 1;
            unint64_t v12 = v41 + 8;
            while (v11 != v22)
            {
              uint64_t v42 = *((void *)v11 - 1);
              v11 -= 8;
              *((void *)v41 - 1) = v42;
              v41 -= 8;
            }
            __n128 __p = v41;
            long long v121 = v12;
            v122[0] = &v27[8 * v26];
            if (v22) {
              operator delete(v22);
            }
          }
          else
          {
            *(void *)long long v121 = 1;
            unint64_t v12 = v11 + 8;
          }
          long long v121 = v12;
        }
        uint64_t v43 = *v104;
        __n128 v44 = v117;
        if (v117 >= v118)
        {
          uint64_t v46 = (char *)v116;
          uint64_t v47 = (v117 - (unsigned char *)v116) >> 3;
          unint64_t v48 = v47 + 1;
          if ((unint64_t)(v47 + 1) >> 61) {
LABEL_154:
          }
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          uint64_t v49 = v118 - (unsigned char *)v116;
          if ((v118 - (unsigned char *)v116) >> 2 > v48) {
            unint64_t v48 = v49 >> 2;
          }
          if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v50 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v50 = v48;
          }
          if (v50)
          {
            uint64_t v51 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v118, v50);
            uint64_t v46 = (char *)v116;
            __n128 v44 = v117;
          }
          else
          {
            uint64_t v51 = 0;
          }
          uint64_t v52 = &v51[8 * v47];
          *(void *)uint64_t v52 = *(void *)(v43 + 8 * (void)v9);
          uint64_t v45 = v52 + 8;
          while (v44 != v46)
          {
            uint64_t v53 = *((void *)v44 - 1);
            v44 -= 8;
            *((void *)v52 - 1) = v53;
            v52 -= 8;
          }
          uint64_t v116 = v52;
          std::string v117 = v45;
          std::string v118 = &v51[8 * v50];
          if (v46) {
            operator delete(v46);
          }
        }
        else
        {
          *(void *)std::string v117 = *(void *)(v43 + 8 * (void)v9);
          uint64_t v45 = v44 + 8;
        }
        std::string v117 = v45;
      }
      else
      {
        uint64_t v13 = *v104;
        uint64_t v14 = v121;
        if ((unint64_t)v121 >= v122[0])
        {
          uint64_t v16 = (char *)__p;
          uint64_t v17 = (v121 - (unsigned char *)__p) >> 3;
          unint64_t v18 = v17 + 1;
          if ((unint64_t)(v17 + 1) >> 61) {
            goto LABEL_154;
          }
          uint64_t v19 = v122[0] - (void)__p;
          if ((uint64_t)(v122[0] - (void)__p) >> 2 > v18) {
            unint64_t v18 = v19 >> 2;
          }
          if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v20 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v20 = v18;
          }
          if (v20)
          {
            size_t v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)v122, v20);
            uint64_t v16 = (char *)__p;
            uint64_t v14 = v121;
          }
          else
          {
            size_t v21 = 0;
          }
          unint64_t v28 = &v21[8 * v17];
          *(void *)unint64_t v28 = *(void *)(v13 + 8 * (void)v9);
          unint64_t v15 = v28 + 8;
          while (v14 != v16)
          {
            uint64_t v29 = *((void *)v14 - 1);
            v14 -= 8;
            *((void *)v28 - 1) = v29;
            v28 -= 8;
          }
          __n128 __p = v28;
          long long v121 = v15;
          v122[0] = &v21[8 * v20];
          if (v16) {
            operator delete(v16);
          }
        }
        else
        {
          *(void *)long long v121 = *(void *)(v13 + 8 * (void)v9);
          unint64_t v15 = v14 + 8;
        }
        long long v121 = v15;
        uint64_t v30 = *v104;
        std::string::size_type size = v119.__r_.__value_.__l.__size_;
        if (v119.__r_.__value_.__l.__size_ >= v119.__r_.__value_.__r.__words[2])
        {
          uint64_t v33 = (void *)v119.__r_.__value_.__r.__words[0];
          uint64_t v34 = (uint64_t)(v119.__r_.__value_.__l.__size_ - v119.__r_.__value_.__r.__words[0]) >> 3;
          unint64_t v35 = v34 + 1;
          if ((unint64_t)(v34 + 1) >> 61) {
            goto LABEL_154;
          }
          int64_t v36 = v119.__r_.__value_.__r.__words[2] - v119.__r_.__value_.__r.__words[0];
          if ((uint64_t)(v119.__r_.__value_.__r.__words[2] - v119.__r_.__value_.__r.__words[0]) >> 2 > v35) {
            unint64_t v35 = v36 >> 2;
          }
          if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v37 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v37 = v35;
          }
          if (v37)
          {
            std::string::size_type v38 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v119.__r_.__value_.__r.__words[2], v37);
            std::string::size_type size = v119.__r_.__value_.__l.__size_;
            uint64_t v33 = (void *)v119.__r_.__value_.__r.__words[0];
          }
          else
          {
            std::string::size_type v38 = 0;
          }
          uint64_t v39 = &v38[8 * v34];
          *(void *)uint64_t v39 = *(void *)(v30 + 8 * (void)v9);
          std::string::size_type v32 = (std::string::size_type)(v39 + 8);
          while ((void *)size != v33)
          {
            uint64_t v40 = *(void *)(size - 8);
            size -= 8;
            *((void *)v39 - 1) = v40;
            v39 -= 8;
          }
          v119.__r_.__value_.__r.__words[0] = (std::string::size_type)v39;
          v119.__r_.__value_.__l.__size_ = v32;
          v119.__r_.__value_.__r.__words[2] = (std::string::size_type)&v38[8 * v37];
          if (v33) {
            operator delete(v33);
          }
        }
        else
        {
          *(void *)v119.__r_.__value_.__l.__size_ = *(void *)(v30 + 8 * (void)v9);
          std::string::size_type v32 = size + 8;
        }
        v119.__r_.__value_.__l.__size_ = v32;
      }
      uint64_t v9 = (char *)v9 + 1;
    }
    while (v9 != (void *)v10);
    uint64_t v54 = __p;
    uint64_t v55 = (uint64_t)v121;
  }
  __n128 v114 = 0uLL;
  uint64_t v115 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v114, v54, v55, (v55 - (uint64_t)v54) >> 3);
  MIL::ValueInference::Tensor<MIL::Bf16>::Zeros(&v114, a5);
  if (v114.n128_u64[0])
  {
    v114.n128_u64[1] = v114.n128_u64[0];
    operator delete((void *)v114.n128_u64[0]);
  }
  uint64_t v56 = *(void *)(a5 + 40) - *(void *)(a5 + 32);
  if (v56)
  {
    unint64_t v57 = 0;
    unint64_t v58 = v56 >> 1;
    unint64_t v95 = v56 >> 1;
    unint64_t v96 = (uint64_t)(a1[5] - a1[4]) >> 1;
    unint64_t v59 = v96 / (v56 >> 1);
    BOOL v60 = (uint64_t **)(a5 + 8);
    if (v7 <= 1) {
      uint64_t v61 = 1;
    }
    else {
      uint64_t v61 = (v102 - v103) >> 3;
    }
    if (v58 <= 1) {
      uint64_t v62 = 1;
    }
    else {
      uint64_t v62 = v58;
    }
    uint64_t v94 = v62;
    if (v59 <= 1) {
      unint64_t v59 = 1;
    }
    unint64_t v100 = v59;
    do
    {
      unint64_t v98 = v57;
      LOWORD(v5) = (unsigned __int16)v5 & 0xFF00;
      if (v95 <= v96)
      {
        unint64_t v63 = 0;
        int v105 = 0;
        do
        {
          __int16 v106 = (__int16)v5;
          unint64_t v108 = 0;
          uint64_t v109 = 0;
          unint64_t v110 = 0;
          if (v102 != v103)
          {
            unint64_t v64 = 0;
            uint64_t v65 = 0;
            uint64_t v66 = 0;
            do
            {
              unint64_t v107 = v64;
              uint64_t v67 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(v123, &v107);
              uint64_t v68 = v109;
              if (v67)
              {
                uint64_t v69 = v111;
                if (v109 >= v110)
                {
                  unint64_t v73 = (char *)v108;
                  uint64_t v74 = (v109 - (unsigned char *)v108) >> 3;
                  unint64_t v75 = v74 + 1;
                  if ((unint64_t)(v74 + 1) >> 61) {
                    goto LABEL_152;
                  }
                  uint64_t v76 = v110 - (unsigned char *)v108;
                  if ((v110 - (unsigned char *)v108) >> 2 > v75) {
                    unint64_t v75 = v76 >> 2;
                  }
                  if ((unint64_t)v76 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v77 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v77 = v75;
                  }
                  if (v77)
                  {
                    uint64_t v78 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v110, v77);
                    unint64_t v73 = (char *)v108;
                    uint64_t v68 = v109;
                  }
                  else
                  {
                    uint64_t v78 = 0;
                  }
                  uint64_t v85 = &v78[8 * v74];
                  *(void *)uint64_t v85 = v69[v65];
                  uint64_t v70 = v85 + 8;
                  while (v68 != v73)
                  {
                    uint64_t v86 = *((void *)v68 - 1);
                    v68 -= 8;
                    *((void *)v85 - 1) = v86;
                    v85 -= 8;
                  }
                  unint64_t v108 = v85;
                  uint64_t v109 = v70;
                  unint64_t v110 = &v78[8 * v77];
                  if (v73) {
                    operator delete(v73);
                  }
                }
                else
                {
                  *(void *)uint64_t v109 = *((void *)v111 + v65);
                  uint64_t v70 = v68 + 8;
                }
                uint64_t v109 = v70;
                ++v65;
              }
              else
              {
                uint64_t v71 = v113[0];
                if (v109 >= v110)
                {
                  unint64_t v79 = (char *)v108;
                  uint64_t v80 = (v109 - (unsigned char *)v108) >> 3;
                  unint64_t v81 = v80 + 1;
                  if ((unint64_t)(v80 + 1) >> 61) {
LABEL_152:
                  }
                    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
                  uint64_t v82 = v110 - (unsigned char *)v108;
                  if ((v110 - (unsigned char *)v108) >> 2 > v81) {
                    unint64_t v81 = v82 >> 2;
                  }
                  if ((unint64_t)v82 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v83 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v83 = v81;
                  }
                  if (v83)
                  {
                    uint64_t v84 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v110, v83);
                    unint64_t v79 = (char *)v108;
                    uint64_t v68 = v109;
                  }
                  else
                  {
                    uint64_t v84 = 0;
                  }
                  unint64_t v87 = &v84[8 * v80];
                  *(void *)unint64_t v87 = v71[v66];
                  uint64_t v72 = v87 + 8;
                  while (v68 != v79)
                  {
                    uint64_t v88 = *((void *)v68 - 1);
                    v68 -= 8;
                    *((void *)v87 - 1) = v88;
                    v87 -= 8;
                  }
                  unint64_t v108 = v87;
                  uint64_t v109 = v72;
                  unint64_t v110 = &v84[8 * v83];
                  if (v79) {
                    operator delete(v79);
                  }
                }
                else
                {
                  *(void *)uint64_t v109 = *((void *)v113[0] + v66);
                  uint64_t v72 = v68 + 8;
                }
                uint64_t v109 = v72;
                ++v66;
              }
              ++v64;
            }
            while (v64 != v61);
          }
          if (v105)
          {
            LOWORD(v5) = std::function<MIL::Bf16 ()(MIL::Bf16,MIL::Bf16)>::operator()(a4, v106, v89);
          }
          else
          {
            int v105 = 1;
            LOWORD(v5) = v89;
          }
          BOOL v60 = (uint64_t **)(a5 + 8);
          if (v108)
          {
            uint64_t v109 = (char *)v108;
            operator delete(v108);
          }
          if (v111)
          {
            __n128 v112 = v111;
            operator delete(v111);
          }
          ++v63;
        }
        while (v63 != v100);
      }
      if (v111)
      {
        __n128 v112 = v111;
        operator delete(v111);
      }
      if (v113[0])
      {
        v113[1] = v113[0];
        operator delete(v113[0]);
      }
      unint64_t v57 = v98 + 1;
    }
    while (v98 + 1 != v94);
  }
  if (v116)
  {
    std::string v117 = (char *)v116;
    operator delete(v116);
  }
  if (v119.__r_.__value_.__r.__words[0])
  {
    v119.__r_.__value_.__l.__size_ = v119.__r_.__value_.__r.__words[0];
    operator delete(v119.__r_.__value_.__l.__data_);
  }
  if (__p)
  {
    long long v121 = (char *)__p;
    operator delete(__p);
  }
  return std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table((uint64_t)v123);
}

void sub_20F4D2654(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37,uint64_t a38,void *__p,uint64_t a40,int a41,__int16 a42,char a43,char a44,void *a45,uint64_t a46)
{
  if (a44 < 0)
  {
    operator delete(__p);
    if ((v47 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a45);
      std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table(v48 - 128);
      _Unwind_Resume(a1);
    }
  }
  else if (!v47)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v46);
  goto LABEL_6;
}

uint64_t std::function<MIL::Bf16 ()(MIL::Bf16,MIL::Bf16)>::operator()(uint64_t a1, __int16 a2, __int16 a3)
{
  __int16 v6 = a2;
  __int16 v5 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, __int16 *, __int16 *))(*(void *)v3 + 48))(v3, &v6, &v5);
}

void MIL::ValueInference::Tensor<MIL::Bf16>::Zeros(MIL *a1@<X0>, const MIL::IRTensorValueType *a2@<X1>, uint64_t a3@<X8>)
{
  MIL::GetTensorShapeWithDimensionsAllKnown(a1, a2, (uint64_t)v6);
  *(_OWORD *)__n128 __p = *(_OWORD *)v6;
  uint64_t v5 = v7;
  v6[1] = 0;
  uint64_t v7 = 0;
  v6[0] = 0;
  MIL::ValueInference::Tensor<MIL::Bf16>::Zeros((__n128 *)__p, a3);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v6[0])
  {
    v6[1] = v6[0];
    operator delete(v6[0]);
  }
}

void sub_20F4D2844(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  if (__p) {
    operator delete(__p);
  }
  if (a13) {
    operator delete(a13);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<MIL::Fp16>::FromIRTensorValue(void *a1@<X0>, uint64_t a2@<X8>)
{
  MIL::IRTensorValue::TryGetDataView<MIL::Fp16>(&v12, *a1);
  if (!(_BYTE)v12)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Failed to get data view.");
    uint64_t v7 = (struct type_info *)MEMORY[0x263F8C1F0];
    unint64_t v8 = (void (*)(void *))MEMORY[0x263F8C070];
    goto LABEL_10;
  }
  unint64_t v4 = (MIL *)(*(uint64_t (**)(void))(*(void *)*a1 + 32))();
  if ((*(unsigned int (**)(MIL *))(*(void *)v4 + 88))(v4) == 3)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100]((std::logic_error *)exception, "It is not supported to convert a tensor of string dtype.");
    uint64_t v7 = (struct type_info *)off_26412C1F0;
    unint64_t v8 = (void (*)(void *))MEMORY[0x263F8C080];
LABEL_10:
    __cxa_throw(exception, v7, v8);
  }
  MIL::GetTensorShapeWithDimensionsAllKnown(v4, v5, (uint64_t)&v11);
  uint64_t v10 = 0;
  __n128 __p = 0uLL;
  std::vector<MIL::Fp16>::__init_with_size[abi:ne180100]<MIL::Fp16 const*,MIL::Fp16 const*>(&__p, v13, (uint64_t)v13 + 2 * v14, v14);
  MIL::ValueInference::Tensor<MIL::Fp16>::Tensor(a2, &v11, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v11.n128_u64[0])
  {
    v11.n128_u64[1] = v11.n128_u64[0];
    operator delete((void *)v11.n128_u64[0]);
  }
}

void sub_20F4D29C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  __cxa_free_exception(v14);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<MIL::Fp16>::ToIRTensorValue(uint64_t a1, MIL::IRConstantDimension *a2)
{
  memset(__p, 0, sizeof(__p));
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(__p, *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3);
  MIL::IRTensorValueType::Make(a2, 4, (MIL::MILContext ***)__p);
}

void sub_20F4D2AD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MIL::ValueInference::Tensor<MIL::Fp16>::Tensor(uint64_t a1, __n128 *a2, __n128 *a3)
{
  *(_OWORD *)(a1 + 8) = 0u;
  uint64_t v5 = a1 + 8;
  *(void *)a1 = &unk_26C259D88;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  __int16 v6 = (uint64_t *)a2->n128_u64[0];
  uint64_t v7 = (uint64_t *)a2->n128_u64[1];
  if ((uint64_t *)a2->n128_u64[0] == v7)
  {
    unint64_t v10 = a3->n128_u64[0];
    unint64_t v11 = a3->n128_u64[1];
    uint64_t v8 = a3->n128_u64[0] != v11;
  }
  else
  {
    uint64_t v8 = 1;
    do
    {
      uint64_t v9 = *v6++;
      v8 *= v9;
    }
    while (v6 != v7);
    unint64_t v10 = a3->n128_u64[0];
    unint64_t v11 = a3->n128_u64[1];
  }
  if (v8 != (uint64_t)(v11 - v10) >> 1)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "data size and shape dismatch.");
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  std::vector<float>::__move_assign(v5, a2);
  std::vector<float>::__move_assign(a1 + 32, a3);
  *(void *)(a1 + 56) = v8;
  return a1;
}

void sub_20F4D2C08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10)
{
  uint64_t v13 = *v11;
  if (*v11)
  {
    *(void *)(v10 + 40) = v13;
    operator delete(v13);
  }
  uint64_t v14 = *a10;
  if (*a10)
  {
    *(void *)(v10 + 16) = v14;
    operator delete(v14);
  }
  _Unwind_Resume(exception_object);
}

double MIL::ValueInference::Tensor<MIL::Fp16>::Tensor(uint64_t a1)
{
  *(void *)a1 = &unk_26C259D88;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  return result;
}

uint64_t MIL::ValueInference::Tensor<MIL::Fp16>::GetScalarData(void *a1)
{
  if (a1[1] != a1[2] || (uint64_t v1 = (unsigned __int16 *)a1[4], a1[5] - (void)v1 != 2))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Tensor is not a scalar.");
    __cxa_throw(exception, MEMORY[0x263F8C1E0], MEMORY[0x263F8C048]);
  }
  return *v1;
}

void sub_20F4D2CEC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<MIL::Fp16>::Reshape(void *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  __int16 v6 = (uint64_t *)*a2;
  uint64_t v7 = a2[1];
  uint64_t v8 = 1;
  if (v6 != (uint64_t *)v7)
  {
    uint64_t v9 = v6;
    do
    {
      uint64_t v10 = *v9++;
      v8 *= v10;
    }
    while (v9 != (uint64_t *)v7);
  }
  if (a1[7] != v8)
  {
    uint64_t v13 = a2;
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v22);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"Tensor is not able to be reshaped since the number of elements in the newShape [ ", 81);
    uint64_t v14 = *v13;
    uint64_t v15 = v13[1];
    if (*v13 != v15)
    {
      do
      {
        uint64_t v16 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)" ", 1);
        v14 += 8;
      }
      while (v14 != v15);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"] is not the same as the number of elements in the tensor shape [ ", 66);
    uint64_t v17 = a1[1];
    for (uint64_t i = a1[2]; v17 != i; v17 += 8)
    {
      uint64_t v19 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)" ", 1);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)"].", 2);
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str();
    std::logic_error::logic_error(exception, &__p);
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  __n128 v22 = 0uLL;
  uint64_t v23 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v22, v6, v7, (v7 - (uint64_t)v6) >> 3);
  unint64_t v11 = (const void *)a1[4];
  uint64_t v12 = a1[5];
  memset(&__p, 0, sizeof(__p));
  std::vector<MIL::Fp16>::__init_with_size[abi:ne180100]<std::__wrap_iter<MIL::Fp16 const*>,std::__wrap_iter<MIL::Fp16 const*>>(&__p, v11, v12, (v12 - (uint64_t)v11) >> 1);
  MIL::ValueInference::Tensor<MIL::Fp16>::Tensor(a3, &v22, (__n128 *)&__p);
  if (__p.__r_.__value_.__r.__words[0])
  {
    __p.__r_.__value_.__l.__size_ = __p.__r_.__value_.__r.__words[0];
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v22.n128_u64[0])
  {
    v22.n128_u64[1] = v22.n128_u64[0];
    operator delete((void *)v22.n128_u64[0]);
  }
}

void sub_20F4D2F00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((v17 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v17)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v16);
  goto LABEL_6;
}

void MIL::ValueInference::Tensor<MIL::Fp16>::NonZero(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  if (*(void *)(a1 + 56))
  {
    unint64_t v4 = 0;
    uint64_t v5 = (uint64_t **)(a1 + 8);
    do
    {
      __int16 v7 = *(_WORD *)(*(void *)(a1 + 32) + 2 * v4);
      if (MIL::Fp16::GetFloat((MIL::Fp16 *)&v7) != 0.0)
      {
        std::vector<std::vector<unsigned long long>>::push_back[abi:ne180100](a2, (uint64_t)__p);
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
      }
      ++v4;
    }
    while (v4 < *(void *)(a1 + 56));
  }
}

void sub_20F4D3024(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
  {
    a10 = (uint64_t)__p;
    operator delete(__p);
  }
  std::vector<std::vector<unsigned long long>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<MIL::Fp16>::SubTensor(void *a1@<X0>, uint64_t **a2@<X1>, void *a3@<X8>)
{
  unint64_t v5 = ((char *)a2[1] - (char *)*a2) >> 4;
  __int16 v6 = a1 + 1;
  if (v5 != (uint64_t)(a1[2] - a1[1]) >> 3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "Indices does not match the rank of the tensor.");
    __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
  }
  std::string __p = 0;
  int v47 = 0;
  uint64_t v48 = 0;
  std::vector<unsigned long long>::reserve(&__p, v5);
  uint64_t v8 = a1[1];
  if (a1[2] != v8)
  {
    unint64_t v9 = 0;
    while (1)
    {
      unint64_t v11 = (*a2)[2 * v9];
      unint64_t v10 = (*a2)[2 * v9 + 1];
      unint64_t v12 = v10 - v11;
      if (v10 < v11) {
        break;
      }
      if (v10 > *(void *)(v8 + 8 * v9))
      {
        uint64_t v34 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(v34, "Indices end is out of the bound for the tensor dimension.");
        unint64_t v35 = (void (*)(void *))MEMORY[0x263F8C068];
        int64_t v36 = (struct type_info *)off_26412C1E0;
        uint64_t v37 = MEMORY[0x263F8C390] + 16;
LABEL_45:
        v34->__vftable = (std::logic_error_vtbl *)v37;
        __cxa_throw(v34, v36, v35);
      }
      uint64_t v13 = v47;
      if (v47 >= v48)
      {
        uint64_t v15 = (char *)__p;
        uint64_t v16 = (v47 - (unsigned char *)__p) >> 3;
        unint64_t v17 = v16 + 1;
        if ((unint64_t)(v16 + 1) >> 61) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v18 = v48 - (unsigned char *)__p;
        if ((v48 - (unsigned char *)__p) >> 2 > v17) {
          unint64_t v17 = v18 >> 2;
        }
        if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v19 = v17;
        }
        if (v19)
        {
          unint64_t v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v48, v19);
          uint64_t v15 = (char *)__p;
          uint64_t v13 = v47;
        }
        else
        {
          unint64_t v20 = 0;
        }
        size_t v21 = &v20[8 * v16];
        *(void *)size_t v21 = v12;
        uint64_t v14 = (uint64_t)(v21 + 8);
        while (v13 != v15)
        {
          uint64_t v22 = *((void *)v13 - 1);
          v13 -= 8;
          *((void *)v21 - 1) = v22;
          v21 -= 8;
        }
        std::string __p = v21;
        int v47 = (char *)v14;
        uint64_t v48 = &v20[8 * v19];
        if (v15) {
          operator delete(v15);
        }
      }
      else
      {
        *(void *)int v47 = v12;
        uint64_t v14 = (uint64_t)(v13 + 8);
      }
      int v47 = (char *)v14;
      ++v9;
      uint64_t v8 = a1[1];
      if (v9 >= (a1[2] - v8) >> 3) {
        goto LABEL_25;
      }
    }
    uint64_t v34 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v34, "Indices end must not be smaller than the indices begin.");
    unint64_t v35 = (void (*)(void *))MEMORY[0x263F8C080];
    int64_t v36 = (struct type_info *)off_26412C1F0;
    uint64_t v37 = MEMORY[0x263F8C3A0] + 16;
    goto LABEL_45;
  }
  uint64_t v14 = (uint64_t)v47;
LABEL_25:
  __n128 v44 = 0uLL;
  uint64_t v45 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v44, __p, v14, (v14 - (uint64_t)__p) >> 3);
  MIL::ValueInference::Tensor<MIL::Fp16>::Zeros(&v44, (uint64_t)a3);
  if (v44.n128_u64[0])
  {
    v44.n128_u64[1] = v44.n128_u64[0];
    operator delete((void *)v44.n128_u64[0]);
  }
  uint64_t v23 = a3[5] - a3[4];
  if (v23)
  {
    unint64_t v24 = 0;
    unint64_t v25 = v23 >> 1;
    if (v25 <= 1) {
      uint64_t v26 = 1;
    }
    else {
      uint64_t v26 = v25;
    }
    do
    {
      uint64_t v39 = 0;
      uint64_t v40 = 0;
      uint64_t v41 = 0;
      std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v39, v42, (uint64_t)v43, (v43 - (unsigned char *)v42) >> 3);
      uint64_t v27 = a1[2] - a1[1];
      if (v27)
      {
        unint64_t v28 = v27 >> 3;
        uint64_t v29 = *a2;
        uint64_t v30 = v39;
        if (v28 <= 1) {
          unint64_t v28 = 1;
        }
        do
        {
          uint64_t v31 = *v29;
          v29 += 2;
          *v30++ += v31;
          --v28;
        }
        while (v28);
      }
      uint64_t v33 = a1[4];
      if (v39)
      {
        uint64_t v40 = v39;
        operator delete(v39);
      }
      if (v42)
      {
        uint64_t v43 = v42;
        operator delete(v42);
      }
      ++v24;
    }
    while (v24 != v26);
  }
  if (__p)
  {
    int v47 = (char *)__p;
    operator delete(__p);
  }
}

void sub_20F4D33E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19)
{
  __cxa_free_exception(v19);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::Tensor<MIL::Fp16>::Zeros(__n128 *a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t v4 = (uint64_t *)a1->n128_u64[0];
  uint64_t v5 = 1;
  while (v4 != (uint64_t *)a1->n128_u64[1])
  {
    uint64_t v6 = *v4++;
    v5 *= v6;
  }
  std::vector<MIL::Fp16>::vector(&__p, v5);
  MIL::ValueInference::Tensor<MIL::Fp16>::Tensor(a2, a1, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
}

void sub_20F4D34F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<MIL::Fp16>::Concat(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *a1;
  uint64_t v7 = 0;
  uint64_t v8 = a1[1] - *a1;
  if (v8)
  {
    unint64_t v9 = v8 >> 6;
    if (v9 <= 1) {
      unint64_t v9 = 1;
    }
    unint64_t v10 = (uint64_t *)(v6 + 8);
    do
    {
      uint64_t v11 = *v10;
      v10 += 8;
      v7 += *(void *)(v11 + 8 * a2);
      --v9;
    }
    while (v9);
  }
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  uint64_t v30 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v30, *(const void **)(v6 + 8), *(void *)(v6 + 16), (uint64_t)(*(void *)(v6 + 16) - *(void *)(v6 + 8)) >> 3);
  unint64_t v12 = v30;
  *((void *)v30 + a2) = v7;
  uint64_t v29 = 0;
  __n128 __p = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, v12, (uint64_t)v31, (v31 - (unsigned char *)v12) >> 3);
  MIL::ValueInference::Tensor<MIL::Fp16>::Zeros(&__p, a3);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  uint64_t v13 = *a1;
  uint64_t v14 = a1[1];
  if (v14 != *a1)
  {
    unint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      uint64_t v17 = *(void *)(v13 + (v15 << 6) + 40) - *(void *)(v13 + (v15 << 6) + 32);
      if (v17)
      {
        unint64_t v18 = 0;
        if ((unint64_t)(v17 >> 1) <= 1) {
          uint64_t v19 = 1;
        }
        else {
          uint64_t v19 = v17 >> 1;
        }
        do
        {
          uint64_t v23 = 0;
          unint64_t v24 = 0;
          uint64_t v25 = 0;
          std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v23, v26, (uint64_t)v27, (v27 - (unsigned char *)v26) >> 3);
          *((void *)v23 + a2) += v16;
          unint64_t v20 = *a1 + (v15 << 6);
          uint64_t v22 = *(void *)(v20 + 32);
          *(_WORD *)(*(void *)(a3 + 32)
          if (v23)
          {
            unint64_t v24 = v23;
            operator delete(v23);
          }
          if (v26)
          {
            uint64_t v27 = v26;
            operator delete(v26);
          }
          ++v18;
        }
        while (v19 != v18);
        uint64_t v13 = *a1;
        uint64_t v14 = a1[1];
      }
      v16 += *(void *)(*(void *)(v13 + (v15++ << 6) + 8) + 8 * a2);
    }
    while (v15 < (v14 - v13) >> 6);
  }
  if (v30)
  {
    uint64_t v31 = v30;
    operator delete(v30);
  }
}

void sub_20F4D3700(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  if (a18) {
    operator delete(a18);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<MIL::Fp16>::BlockwiseMerge(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *(uint64_t **)a2;
  uint64_t v7 = *(void *)(a2 + 8) - *(void *)a2;
  if (v7)
  {
    unint64_t v8 = v7 >> 3;
    if (v8 <= 1) {
      unint64_t v8 = 1;
    }
    uint64_t v9 = 1;
    do
    {
      uint64_t v10 = *v6++;
      v9 *= v10;
      --v8;
    }
    while (v8);
  }
  else
  {
    uint64_t v9 = 1;
  }
  uint64_t v11 = *a1;
  if (v9 != (a1[1] - *a1) >> 6)
  {
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v50);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v50, (uint64_t)"The number of tensors (", 23);
    std::string::size_type v38 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v38, (uint64_t)") is not the same as the number of blocks (", 43);
    uint64_t v39 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v39, (uint64_t)").", 2);
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str();
    std::runtime_error::runtime_error(exception, &v49);
    __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
  }
  uint64_t v51 = 0;
  uint64_t v52 = 0;
  unint64_t v50 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v50, *(const void **)(v11 + 8), *(void *)(v11 + 16), (uint64_t)(*(void *)(v11 + 16) - *(void *)(v11 + 8)) >> 3);
  memset(&v49, 0, sizeof(v49));
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v49, v50, (uint64_t)v51, (v51 - (unsigned char *)v50) >> 3);
  unint64_t v12 = *(uint64_t **)a2;
  uint64_t v13 = (const void *)v49.__r_.__value_.__r.__words[0];
  uint64_t v14 = *(void *)(a2 + 8) - *(void *)a2;
  if (v14)
  {
    unint64_t v15 = v14 >> 3;
    if (v15 <= 1) {
      unint64_t v15 = 1;
    }
    uint64_t v16 = (void *)v49.__r_.__value_.__r.__words[0];
    do
    {
      uint64_t v17 = *v12++;
      *v16++ *= v17;
      --v15;
    }
    while (v15);
  }
  __n128 __p = 0uLL;
  uint64_t v48 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, v13, v49.__r_.__value_.__l.__size_, (uint64_t)(v49.__r_.__value_.__l.__size_ - (void)v13) >> 3);
  MIL::ValueInference::Tensor<MIL::Fp16>::Zeros(&__p, a3);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v9)
  {
    for (unint64_t i = 0; i != v9; ++i)
    {
      unint64_t v19 = *a1 + (i << 6);
      unint64_t v20 = *(const void **)(v19 + 8);
      size_t v21 = *(void *)(v19 + 16) - (void)v20;
      if (v21 != v51 - (unsigned char *)v50 || memcmp(v20, v50, v21))
      {
        uint64_t v37 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v37, "All tensors must have the same shape so they can be merged.");
        __cxa_throw(v37, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
      }
      uint64_t v22 = *(void *)(*a1 + (i << 6) + 40) - *(void *)(*a1 + (i << 6) + 32);
      if (v22)
      {
        unint64_t v23 = 0;
        unint64_t v24 = v22 >> 1;
        if (v24 <= 1) {
          uint64_t v25 = 1;
        }
        else {
          uint64_t v25 = v24;
        }
        do
        {
          uint64_t v41 = 0;
          uint64_t v42 = 0;
          uint64_t v43 = 0;
          std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v41, v44, (uint64_t)v45, (v45 - (unsigned char *)v44) >> 3);
          uint64_t v26 = *(void *)(a2 + 8) - *(void *)a2;
          if (v26)
          {
            unint64_t v27 = v26 >> 3;
            unint64_t v28 = (uint64_t *)v50;
            uint64_t v29 = (uint64_t *)v46[0];
            uint64_t v30 = v41;
            if (v27 <= 1) {
              unint64_t v27 = 1;
            }
            do
            {
              uint64_t v32 = *v28++;
              uint64_t v31 = v32;
              uint64_t v33 = *v29++;
              *v30++ += v33 * v31;
              --v27;
            }
            while (v27);
          }
          unint64_t v34 = *a1 + (i << 6);
          uint64_t v36 = *(void *)(v34 + 32);
          *(_WORD *)(*(void *)(a3 + 32)
          if (v41)
          {
            uint64_t v42 = v41;
            operator delete(v41);
          }
          if (v44)
          {
            uint64_t v45 = v44;
            operator delete(v44);
          }
          ++v23;
        }
        while (v23 != v25);
      }
      if (v46[0])
      {
        v46[1] = v46[0];
        operator delete(v46[0]);
      }
    }
  }
  if (v49.__r_.__value_.__r.__words[0])
  {
    v49.__r_.__value_.__l.__size_ = v49.__r_.__value_.__r.__words[0];
    operator delete(v49.__r_.__value_.__l.__data_);
  }
  if (v50)
  {
    uint64_t v51 = v50;
    operator delete(v50);
  }
}

void sub_20F4D3B0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29)
{
  if (a27 < 0)
  {
    operator delete(__p);
    if ((v30 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a28);
      _Unwind_Resume(a1);
    }
  }
  else if (!v30)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v29);
  goto LABEL_6;
}

uint64_t MIL::ValueInference::Tensor<MIL::Fp16>::Reduce@<X0>(void *a1@<X0>, unint64_t **a2@<X1>, int a3@<W2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v103 = a1[1];
  uint64_t v104 = a1 + 1;
  uint64_t v102 = a1[2];
  unint64_t v7 = (v102 - v103) >> 3;
  std::unordered_set<unsigned long long>::unordered_set<std::__wrap_iter<unsigned long long const*>>((uint64_t)v123, *a2, a2[1]);
  for (unint64_t i = v124; i; unint64_t i = (void *)*i)
  {
    if (i[2] >= v7)
    {
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&__p);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&__p, (uint64_t)"axis(", 5);
      uint64_t v91 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v91, (uint64_t)") must be smaller than the number of input dimensions(", 54);
      uint64_t v92 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v92, (uint64_t)").", 2);
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::stringbuf::str();
      std::logic_error::logic_error(exception, &v119);
      exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
      __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
    }
  }
  __n128 __p = 0;
  long long v121 = 0;
  v122[0] = 0;
  memset(&v119, 0, sizeof(v119));
  uint64_t v116 = 0;
  std::string v117 = 0;
  std::string v118 = 0;
  if (v102 == v103)
  {
    uint64_t v55 = 0;
    uint64_t v54 = 0;
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t v5 = v122;
    if (v7 <= 1) {
      uint64_t v10 = 1;
    }
    else {
      uint64_t v10 = (v102 - v103) >> 3;
    }
    do
    {
      v113[0] = v9;
      if (std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(v123, (unint64_t *)v113))
      {
        if (a3)
        {
          uint64_t v11 = v121;
          if ((unint64_t)v121 >= v122[0])
          {
            uint64_t v22 = (char *)__p;
            uint64_t v23 = (v121 - (unsigned char *)__p) >> 3;
            unint64_t v24 = v23 + 1;
            if ((unint64_t)(v23 + 1) >> 61) {
              std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v25 = v122[0] - (void)__p;
            if ((uint64_t)(v122[0] - (void)__p) >> 2 > v24) {
              unint64_t v24 = v25 >> 2;
            }
            if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v26 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v26 = v24;
            }
            if (v26)
            {
              unint64_t v27 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)v122, v26);
              uint64_t v22 = (char *)__p;
              uint64_t v11 = v121;
            }
            else
            {
              unint64_t v27 = 0;
            }
            uint64_t v41 = &v27[8 * v23];
            *(void *)uint64_t v41 = 1;
            unint64_t v12 = v41 + 8;
            while (v11 != v22)
            {
              uint64_t v42 = *((void *)v11 - 1);
              v11 -= 8;
              *((void *)v41 - 1) = v42;
              v41 -= 8;
            }
            __n128 __p = v41;
            long long v121 = v12;
            v122[0] = &v27[8 * v26];
            if (v22) {
              operator delete(v22);
            }
          }
          else
          {
            *(void *)long long v121 = 1;
            unint64_t v12 = v11 + 8;
          }
          long long v121 = v12;
        }
        uint64_t v43 = *v104;
        __n128 v44 = v117;
        if (v117 >= v118)
        {
          uint64_t v46 = (char *)v116;
          uint64_t v47 = (v117 - (unsigned char *)v116) >> 3;
          unint64_t v48 = v47 + 1;
          if ((unint64_t)(v47 + 1) >> 61) {
LABEL_154:
          }
            std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
          uint64_t v49 = v118 - (unsigned char *)v116;
          if ((v118 - (unsigned char *)v116) >> 2 > v48) {
            unint64_t v48 = v49 >> 2;
          }
          if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v50 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v50 = v48;
          }
          if (v50)
          {
            uint64_t v51 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v118, v50);
            uint64_t v46 = (char *)v116;
            __n128 v44 = v117;
          }
          else
          {
            uint64_t v51 = 0;
          }
          uint64_t v52 = &v51[8 * v47];
          *(void *)uint64_t v52 = *(void *)(v43 + 8 * (void)v9);
          uint64_t v45 = v52 + 8;
          while (v44 != v46)
          {
            uint64_t v53 = *((void *)v44 - 1);
            v44 -= 8;
            *((void *)v52 - 1) = v53;
            v52 -= 8;
          }
          uint64_t v116 = v52;
          std::string v117 = v45;
          std::string v118 = &v51[8 * v50];
          if (v46) {
            operator delete(v46);
          }
        }
        else
        {
          *(void *)std::string v117 = *(void *)(v43 + 8 * (void)v9);
          uint64_t v45 = v44 + 8;
        }
        std::string v117 = v45;
      }
      else
      {
        uint64_t v13 = *v104;
        uint64_t v14 = v121;
        if ((unint64_t)v121 >= v122[0])
        {
          uint64_t v16 = (char *)__p;
          uint64_t v17 = (v121 - (unsigned char *)__p) >> 3;
          unint64_t v18 = v17 + 1;
          if ((unint64_t)(v17 + 1) >> 61) {
            goto LABEL_154;
          }
          uint64_t v19 = v122[0] - (void)__p;
          if ((uint64_t)(v122[0] - (void)__p) >> 2 > v18) {
            unint64_t v18 = v19 >> 2;
          }
          if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v20 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v20 = v18;
          }
          if (v20)
          {
            size_t v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)v122, v20);
            uint64_t v16 = (char *)__p;
            uint64_t v14 = v121;
          }
          else
          {
            size_t v21 = 0;
          }
          unint64_t v28 = &v21[8 * v17];
          *(void *)unint64_t v28 = *(void *)(v13 + 8 * (void)v9);
          unint64_t v15 = v28 + 8;
          while (v14 != v16)
          {
            uint64_t v29 = *((void *)v14 - 1);
            v14 -= 8;
            *((void *)v28 - 1) = v29;
            v28 -= 8;
          }
          __n128 __p = v28;
          long long v121 = v15;
          v122[0] = &v21[8 * v20];
          if (v16) {
            operator delete(v16);
          }
        }
        else
        {
          *(void *)long long v121 = *(void *)(v13 + 8 * (void)v9);
          unint64_t v15 = v14 + 8;
        }
        long long v121 = v15;
        uint64_t v30 = *v104;
        std::string::size_type size = v119.__r_.__value_.__l.__size_;
        if (v119.__r_.__value_.__l.__size_ >= v119.__r_.__value_.__r.__words[2])
        {
          uint64_t v33 = (void *)v119.__r_.__value_.__r.__words[0];
          uint64_t v34 = (uint64_t)(v119.__r_.__value_.__l.__size_ - v119.__r_.__value_.__r.__words[0]) >> 3;
          unint64_t v35 = v34 + 1;
          if ((unint64_t)(v34 + 1) >> 61) {
            goto LABEL_154;
          }
          int64_t v36 = v119.__r_.__value_.__r.__words[2] - v119.__r_.__value_.__r.__words[0];
          if ((uint64_t)(v119.__r_.__value_.__r.__words[2] - v119.__r_.__value_.__r.__words[0]) >> 2 > v35) {
            unint64_t v35 = v36 >> 2;
          }
          if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v37 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v37 = v35;
          }
          if (v37)
          {
            std::string::size_type v38 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v119.__r_.__value_.__r.__words[2], v37);
            std::string::size_type size = v119.__r_.__value_.__l.__size_;
            uint64_t v33 = (void *)v119.__r_.__value_.__r.__words[0];
          }
          else
          {
            std::string::size_type v38 = 0;
          }
          uint64_t v39 = &v38[8 * v34];
          *(void *)uint64_t v39 = *(void *)(v30 + 8 * (void)v9);
          std::string::size_type v32 = (std::string::size_type)(v39 + 8);
          while ((void *)size != v33)
          {
            uint64_t v40 = *(void *)(size - 8);
            size -= 8;
            *((void *)v39 - 1) = v40;
            v39 -= 8;
          }
          v119.__r_.__value_.__r.__words[0] = (std::string::size_type)v39;
          v119.__r_.__value_.__l.__size_ = v32;
          v119.__r_.__value_.__r.__words[2] = (std::string::size_type)&v38[8 * v37];
          if (v33) {
            operator delete(v33);
          }
        }
        else
        {
          *(void *)v119.__r_.__value_.__l.__size_ = *(void *)(v30 + 8 * (void)v9);
          std::string::size_type v32 = size + 8;
        }
        v119.__r_.__value_.__l.__size_ = v32;
      }
      uint64_t v9 = (char *)v9 + 1;
    }
    while (v9 != (void *)v10);
    uint64_t v54 = __p;
    uint64_t v55 = (uint64_t)v121;
  }
  __n128 v114 = 0uLL;
  uint64_t v115 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v114, v54, v55, (v55 - (uint64_t)v54) >> 3);
  MIL::ValueInference::Tensor<MIL::Fp16>::Zeros(&v114, a5);
  if (v114.n128_u64[0])
  {
    v114.n128_u64[1] = v114.n128_u64[0];
    operator delete((void *)v114.n128_u64[0]);
  }
  uint64_t v56 = *(void *)(a5 + 40) - *(void *)(a5 + 32);
  if (v56)
  {
    unint64_t v57 = 0;
    unint64_t v58 = v56 >> 1;
    unint64_t v95 = v56 >> 1;
    unint64_t v96 = (uint64_t)(a1[5] - a1[4]) >> 1;
    unint64_t v59 = v96 / (v56 >> 1);
    BOOL v60 = (uint64_t **)(a5 + 8);
    if (v7 <= 1) {
      uint64_t v61 = 1;
    }
    else {
      uint64_t v61 = (v102 - v103) >> 3;
    }
    if (v58 <= 1) {
      uint64_t v62 = 1;
    }
    else {
      uint64_t v62 = v58;
    }
    uint64_t v94 = v62;
    if (v59 <= 1) {
      unint64_t v59 = 1;
    }
    unint64_t v100 = v59;
    do
    {
      unint64_t v98 = v57;
      LOWORD(v5) = (unsigned __int16)v5 & 0xFF00;
      if (v95 <= v96)
      {
        unint64_t v63 = 0;
        int v105 = 0;
        do
        {
          __int16 v106 = (__int16)v5;
          unint64_t v108 = 0;
          uint64_t v109 = 0;
          unint64_t v110 = 0;
          if (v102 != v103)
          {
            unint64_t v64 = 0;
            uint64_t v65 = 0;
            uint64_t v66 = 0;
            do
            {
              unint64_t v107 = v64;
              uint64_t v67 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(v123, &v107);
              uint64_t v68 = v109;
              if (v67)
              {
                uint64_t v69 = v111;
                if (v109 >= v110)
                {
                  unint64_t v73 = (char *)v108;
                  uint64_t v74 = (v109 - (unsigned char *)v108) >> 3;
                  unint64_t v75 = v74 + 1;
                  if ((unint64_t)(v74 + 1) >> 61) {
                    goto LABEL_152;
                  }
                  uint64_t v76 = v110 - (unsigned char *)v108;
                  if ((v110 - (unsigned char *)v108) >> 2 > v75) {
                    unint64_t v75 = v76 >> 2;
                  }
                  if ((unint64_t)v76 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v77 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v77 = v75;
                  }
                  if (v77)
                  {
                    uint64_t v78 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v110, v77);
                    unint64_t v73 = (char *)v108;
                    uint64_t v68 = v109;
                  }
                  else
                  {
                    uint64_t v78 = 0;
                  }
                  uint64_t v85 = &v78[8 * v74];
                  *(void *)uint64_t v85 = v69[v65];
                  uint64_t v70 = v85 + 8;
                  while (v68 != v73)
                  {
                    uint64_t v86 = *((void *)v68 - 1);
                    v68 -= 8;
                    *((void *)v85 - 1) = v86;
                    v85 -= 8;
                  }
                  unint64_t v108 = v85;
                  uint64_t v109 = v70;
                  unint64_t v110 = &v78[8 * v77];
                  if (v73) {
                    operator delete(v73);
                  }
                }
                else
                {
                  *(void *)uint64_t v109 = *((void *)v111 + v65);
                  uint64_t v70 = v68 + 8;
                }
                uint64_t v109 = v70;
                ++v65;
              }
              else
              {
                uint64_t v71 = v113[0];
                if (v109 >= v110)
                {
                  unint64_t v79 = (char *)v108;
                  uint64_t v80 = (v109 - (unsigned char *)v108) >> 3;
                  unint64_t v81 = v80 + 1;
                  if ((unint64_t)(v80 + 1) >> 61) {
LABEL_152:
                  }
                    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
                  uint64_t v82 = v110 - (unsigned char *)v108;
                  if ((v110 - (unsigned char *)v108) >> 2 > v81) {
                    unint64_t v81 = v82 >> 2;
                  }
                  if ((unint64_t)v82 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v83 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v83 = v81;
                  }
                  if (v83)
                  {
                    uint64_t v84 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v110, v83);
                    unint64_t v79 = (char *)v108;
                    uint64_t v68 = v109;
                  }
                  else
                  {
                    uint64_t v84 = 0;
                  }
                  unint64_t v87 = &v84[8 * v80];
                  *(void *)unint64_t v87 = v71[v66];
                  uint64_t v72 = v87 + 8;
                  while (v68 != v79)
                  {
                    uint64_t v88 = *((void *)v68 - 1);
                    v68 -= 8;
                    *((void *)v87 - 1) = v88;
                    v87 -= 8;
                  }
                  unint64_t v108 = v87;
                  uint64_t v109 = v72;
                  unint64_t v110 = &v84[8 * v83];
                  if (v79) {
                    operator delete(v79);
                  }
                }
                else
                {
                  *(void *)uint64_t v109 = *((void *)v113[0] + v66);
                  uint64_t v72 = v68 + 8;
                }
                uint64_t v109 = v72;
                ++v66;
              }
              ++v64;
            }
            while (v64 != v61);
          }
          if (v105)
          {
            LOWORD(v5) = std::function<MIL::Fp16 ()(MIL::Fp16,MIL::Fp16)>::operator()(a4, v106, v89);
          }
          else
          {
            int v105 = 1;
            LOWORD(v5) = v89;
          }
          BOOL v60 = (uint64_t **)(a5 + 8);
          if (v108)
          {
            uint64_t v109 = (char *)v108;
            operator delete(v108);
          }
          if (v111)
          {
            __n128 v112 = v111;
            operator delete(v111);
          }
          ++v63;
        }
        while (v63 != v100);
      }
      if (v111)
      {
        __n128 v112 = v111;
        operator delete(v111);
      }
      if (v113[0])
      {
        v113[1] = v113[0];
        operator delete(v113[0]);
      }
      unint64_t v57 = v98 + 1;
    }
    while (v98 + 1 != v94);
  }
  if (v116)
  {
    std::string v117 = (char *)v116;
    operator delete(v116);
  }
  if (v119.__r_.__value_.__r.__words[0])
  {
    v119.__r_.__value_.__l.__size_ = v119.__r_.__value_.__r.__words[0];
    operator delete(v119.__r_.__value_.__l.__data_);
  }
  if (__p)
  {
    long long v121 = (char *)__p;
    operator delete(__p);
  }
  return std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table((uint64_t)v123);
}

void sub_20F4D4448(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37,uint64_t a38,void *__p,uint64_t a40,int a41,__int16 a42,char a43,char a44,void *a45,uint64_t a46)
{
  if (a44 < 0)
  {
    operator delete(__p);
    if ((v47 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a45);
      std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table(v48 - 128);
      _Unwind_Resume(a1);
    }
  }
  else if (!v47)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v46);
  goto LABEL_6;
}

uint64_t std::function<MIL::Fp16 ()(MIL::Fp16,MIL::Fp16)>::operator()(uint64_t a1, __int16 a2, __int16 a3)
{
  __int16 v6 = a2;
  __int16 v5 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, __int16 *, __int16 *))(*(void *)v3 + 48))(v3, &v6, &v5);
}

void MIL::ValueInference::Tensor<MIL::Fp16>::Zeros(MIL *a1@<X0>, const MIL::IRTensorValueType *a2@<X1>, uint64_t a3@<X8>)
{
  MIL::GetTensorShapeWithDimensionsAllKnown(a1, a2, (uint64_t)v6);
  *(_OWORD *)__n128 __p = *(_OWORD *)v6;
  uint64_t v5 = v7;
  v6[1] = 0;
  uint64_t v7 = 0;
  v6[0] = 0;
  MIL::ValueInference::Tensor<MIL::Fp16>::Zeros((__n128 *)__p, a3);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v6[0])
  {
    v6[1] = v6[0];
    operator delete(v6[0]);
  }
}

void sub_20F4D4638(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  if (__p) {
    operator delete(__p);
  }
  if (a13) {
    operator delete(a13);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::BinaryOp<float,float>(void *a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, void *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v9 = (void *)*a4;
  uint64_t v10 = a4[1];
  uint64_t v11 = v10 - *a4;
  if (v10 == *a4)
  {
    Scalaruint64_t Data = MIL::ValueInference::Tensor<float>::GetScalarData(a1);
    float v23 = MIL::ValueInference::Tensor<float>::GetScalarData(a2);
    std::function<float ()(float,float)>::operator()(a3, ScalarData, v23);
    int v25 = v24;
    __n128 v40 = 0uLL;
    uint64_t v41 = 0;
    unint64_t v26 = operator new(4uLL);
    v38.n128_u64[0] = (unint64_t)v26;
    _DWORD *v26 = v25;
    v38.n128_u64[1] = (unint64_t)(v26 + 1);
    uint64_t v39 = v26 + 1;
    MIL::ValueInference::Tensor<float>::Tensor(a5, &v40, &v38);
  }
  else
  {
    __n128 __p = 0uLL;
    uint64_t v37 = 0;
    std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, v9, v10, v11 >> 3);
    MIL::ValueInference::Tensor<float>::Zeros(&__p, a5);
    if (__p.n128_u64[0])
    {
      __p.n128_u64[1] = __p.n128_u64[0];
      operator delete((void *)__p.n128_u64[0]);
    }
    unint64_t v13 = (uint64_t)(a1[2] - a1[1]) >> 3;
    v38.n128_u64[0] = 0;
    std::vector<unsigned long long>::vector(&v40, v13, &v38);
    unint64_t v14 = (uint64_t)(a2[2] - a2[1]) >> 3;
    v34[0] = 0;
    std::vector<unsigned long long>::vector(&v38, v14, v34);
    unint64_t v15 = (uint64_t)(a4[1] - *a4) >> 3;
    __s2 = 0;
    std::vector<unsigned long long>::vector(v34, v15, &__s2);
    unint64_t v16 = (uint64_t)(a4[1] - *a4) >> 3;
    *(void *)&long long v30 = 0;
    std::vector<unsigned long long>::vector(&__s2, v16, &v30);
    uint64_t v17 = __s2;
    *(void *)__s2 = *(void *)*a4;
    while (1)
    {
      unint64_t v18 = v34[0];
      if ((char *)v34[1] - (char *)v34[0] == v33 - v17 && !memcmp(v34[0], v17, (char *)v34[1] - (char *)v34[0])) {
        break;
      }
      if (a1[1] == a1[2]) {
        float v19 = MIL::ValueInference::Tensor<float>::GetScalarData(a1);
      }
      else {
      if (a2[1] == a2[2]) {
        float v20 = MIL::ValueInference::Tensor<float>::GetScalarData(a2);
      }
      else {
      std::function<float ()(float,float)>::operator()(a3, v19, v20);
      }
      unint64_t v28 = 0;
      uint64_t v29 = 0;
      unint64_t v27 = 0;
      std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v27, v34[0], (uint64_t)v34[1], ((char *)v34[1] - (char *)v34[0]) >> 3);
      if (v34[0])
      {
        v34[1] = v34[0];
        operator delete(v34[0]);
      }
      *(_OWORD *)uint64_t v34 = v30;
      uint64_t v35 = v31;
      if (v27)
      {
        unint64_t v28 = v27;
        operator delete(v27);
      }
      uint64_t v17 = __s2;
    }
    if (v17)
    {
      uint64_t v33 = v17;
      operator delete(v17);
      unint64_t v18 = v34[0];
    }
    if (v18)
    {
      v34[1] = v18;
      operator delete(v18);
    }
  }
  if (v38.n128_u64[0])
  {
    v38.n128_u64[1] = v38.n128_u64[0];
    operator delete((void *)v38.n128_u64[0]);
  }
  if (v40.n128_u64[0])
  {
    v40.n128_u64[1] = v40.n128_u64[0];
    operator delete((void *)v40.n128_u64[0]);
  }
}

void sub_20F4D4960(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27)
{
  if (__p) {
    operator delete(__p);
  }
  uint64_t v29 = *(void **)(v27 - 128);
  if (v29)
  {
    *(void *)(v27 - 120) = v29;
    operator delete(v29);
  }
  _Unwind_Resume(exception_object);
}

uint64_t anonymous namespace'::GetInputIndexFromOutputIndex(uint64_t result, void *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = *a3;
  uint64_t v5 = a3[1];
  if (*a3 != v5)
  {
    unint64_t v6 = (v5 - v4) >> 3;
    if (v6 > (uint64_t)(a2[1] - *a2) >> 3)
    {
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::out_of_range::out_of_range[abi:ne180100](exception, "inShape has more elements than outShape.");
    }
    else
    {
      uint64_t v7 = a4[1];
      if (v6 == (v7 - *a4) >> 3)
      {
        unint64_t v8 = (unint64_t *)(v7 - 8);
        uint64_t v9 = (unint64_t *)(*(void *)(result + 8) - 8);
        do
        {
          unint64_t v11 = *(void *)(v5 - 8);
          v5 -= 8;
          unint64_t v10 = v11;
          unint64_t v12 = *v9--;
          *v8-- = v12 % v10;
        }
        while (v5 != v4);
        return result;
      }
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::out_of_range::out_of_range[abi:ne180100](exception, "Size of inIndex is not equal to size of inShape.");
    }
    __cxa_throw(exception, (struct type_info *)off_26412C1E0, MEMORY[0x263F8C068]);
  }
  return result;
}

void sub_20F4D4B08(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

__n128 anonymous namespace'::FetchNextIndex@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3 = 0;
  uint64_t v4 = *(unint64_t **)a2;
  uint64_t v5 = *(void *)(a2 + 8) - *(void *)a2;
  unint64_t v6 = *(unint64_t **)a1;
  unint64_t v7 = (v5 & 0xFFFFFFFFFFFFFFF8) - 8;
  unint64_t v8 = *(void *)a2 + v7;
  uint64_t v9 = (unint64_t *)(*(void *)a1 + v7);
  uint64_t v10 = -(v5 >> 3);
  uint64_t v11 = 1 - (v5 >> 3);
  for (unint64_t i = v9; ; --i)
  {
    if (v11 == v3)
    {
      unint64_t v13 = *v6;
      if (*v6 < *v4) {
        break;
      }
    }
    unint64_t v13 = v9[v3];
    if (v13 < *(void *)(v8 + 8 * v3) - 1) {
      goto LABEL_8;
    }
    v9[v3--] = 0;
    if (v10 == v3)
    {
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::invalid_argument::invalid_argument[abi:ne180100](exception, "The next index cannot be found.");
      __cxa_throw(exception, (struct type_info *)off_26412C1F0, MEMORY[0x263F8C080]);
    }
  }
  unint64_t i = v6;
LABEL_8:
  unint64_t *i = v13 + 1;
  *(void *)a3 = v6;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a3 + 8) = result;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  return result;
}

void sub_20F4D4C04(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void MIL::ValueInference::BinaryOp<MIL::Fp16,MIL::Fp16>(void *a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, void *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v9 = (void *)*a4;
  uint64_t v10 = a4[1];
  uint64_t v11 = v10 - *a4;
  if (v10 == *a4)
  {
    Scalaruint64_t Data = MIL::ValueInference::Tensor<MIL::Fp16>::GetScalarData(a1);
    __int16 v23 = MIL::ValueInference::Tensor<MIL::Fp16>::GetScalarData(a2);
    __int16 v24 = std::function<MIL::Fp16 ()(MIL::Fp16,MIL::Fp16)>::operator()(a3, ScalarData, v23);
    __n128 v39 = 0uLL;
    uint64_t v40 = 0;
    int v25 = operator new(2uLL);
    v37.n128_u64[0] = (unint64_t)v25;
    _WORD *v25 = v24;
    v37.n128_u64[1] = (unint64_t)(v25 + 1);
    __n128 v38 = v25 + 1;
    MIL::ValueInference::Tensor<MIL::Fp16>::Tensor(a5, &v39, &v37);
  }
  else
  {
    __n128 __p = 0uLL;
    uint64_t v36 = 0;
    std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, v9, v10, v11 >> 3);
    MIL::ValueInference::Tensor<MIL::Fp16>::Zeros(&__p, a5);
    if (__p.n128_u64[0])
    {
      __p.n128_u64[1] = __p.n128_u64[0];
      operator delete((void *)__p.n128_u64[0]);
    }
    unint64_t v13 = (uint64_t)(a1[2] - a1[1]) >> 3;
    v37.n128_u64[0] = 0;
    std::vector<unsigned long long>::vector(&v39, v13, &v37);
    unint64_t v14 = (uint64_t)(a2[2] - a2[1]) >> 3;
    v33[0] = 0;
    std::vector<unsigned long long>::vector(&v37, v14, v33);
    unint64_t v15 = (uint64_t)(a4[1] - *a4) >> 3;
    __s2 = 0;
    std::vector<unsigned long long>::vector(v33, v15, &__s2);
    unint64_t v16 = (uint64_t)(a4[1] - *a4) >> 3;
    *(void *)&long long v29 = 0;
    std::vector<unsigned long long>::vector(&__s2, v16, &v29);
    uint64_t v17 = __s2;
    *(void *)__s2 = *(void *)*a4;
    while (1)
    {
      unint64_t v18 = v33[0];
      if ((char *)v33[1] - (char *)v33[0] == v32 - v17 && !memcmp(v33[0], v17, (char *)v33[1] - (char *)v33[0])) {
        break;
      }
      if (a1[1] == a1[2]) {
        __int16 v19 = MIL::ValueInference::Tensor<MIL::Fp16>::GetScalarData(a1);
      }
      else {
      if (a2[1] == a2[2]) {
        __int16 v20 = MIL::ValueInference::Tensor<MIL::Fp16>::GetScalarData(a2);
      }
      else {
      __int16 v21 = std::function<MIL::Fp16 ()(MIL::Fp16,MIL::Fp16)>::operator()(a3, v19, v20);
      }
      uint64_t v27 = 0;
      uint64_t v28 = 0;
      unint64_t v26 = 0;
      std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v26, v33[0], (uint64_t)v33[1], ((char *)v33[1] - (char *)v33[0]) >> 3);
      if (v33[0])
      {
        v33[1] = v33[0];
        operator delete(v33[0]);
      }
      *(_OWORD *)uint64_t v33 = v29;
      uint64_t v34 = v30;
      if (v26)
      {
        uint64_t v27 = v26;
        operator delete(v26);
      }
      uint64_t v17 = __s2;
    }
    if (v17)
    {
      std::string::size_type v32 = v17;
      operator delete(v17);
      unint64_t v18 = v33[0];
    }
    if (v18)
    {
      v33[1] = v18;
      operator delete(v18);
    }
  }
  if (v37.n128_u64[0])
  {
    v37.n128_u64[1] = v37.n128_u64[0];
    operator delete((void *)v37.n128_u64[0]);
  }
  if (v39.n128_u64[0])
  {
    v39.n128_u64[1] = v39.n128_u64[0];
    operator delete((void *)v39.n128_u64[0]);
  }
}

void sub_20F4D4F0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27)
{
  if (__p) {
    operator delete(__p);
  }
  long long v29 = *(void **)(v27 - 112);
  if (v29)
  {
    *(void *)(v27 - 104) = v29;
    operator delete(v29);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::BinaryOp<MIL::Bf16,MIL::Bf16>(void *a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, void *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v9 = (void *)*a4;
  uint64_t v10 = a4[1];
  uint64_t v11 = v10 - *a4;
  if (v10 == *a4)
  {
    Scalaruint64_t Data = MIL::ValueInference::Tensor<MIL::Bf16>::GetScalarData(a1);
    __int16 v23 = MIL::ValueInference::Tensor<MIL::Bf16>::GetScalarData(a2);
    __int16 v24 = std::function<MIL::Bf16 ()(MIL::Bf16,MIL::Bf16)>::operator()(a3, ScalarData, v23);
    __n128 v39 = 0uLL;
    uint64_t v40 = 0;
    int v25 = operator new(2uLL);
    v37.n128_u64[0] = (unint64_t)v25;
    _WORD *v25 = v24;
    v37.n128_u64[1] = (unint64_t)(v25 + 1);
    __n128 v38 = v25 + 1;
    MIL::ValueInference::Tensor<MIL::Bf16>::Tensor(a5, &v39, &v37);
  }
  else
  {
    __n128 __p = 0uLL;
    uint64_t v36 = 0;
    std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, v9, v10, v11 >> 3);
    MIL::ValueInference::Tensor<MIL::Bf16>::Zeros(&__p, a5);
    if (__p.n128_u64[0])
    {
      __p.n128_u64[1] = __p.n128_u64[0];
      operator delete((void *)__p.n128_u64[0]);
    }
    unint64_t v13 = (uint64_t)(a1[2] - a1[1]) >> 3;
    v37.n128_u64[0] = 0;
    std::vector<unsigned long long>::vector(&v39, v13, &v37);
    unint64_t v14 = (uint64_t)(a2[2] - a2[1]) >> 3;
    v33[0] = 0;
    std::vector<unsigned long long>::vector(&v37, v14, v33);
    unint64_t v15 = (uint64_t)(a4[1] - *a4) >> 3;
    __s2 = 0;
    std::vector<unsigned long long>::vector(v33, v15, &__s2);
    unint64_t v16 = (uint64_t)(a4[1] - *a4) >> 3;
    *(void *)&long long v29 = 0;
    std::vector<unsigned long long>::vector(&__s2, v16, &v29);
    uint64_t v17 = __s2;
    *(void *)__s2 = *(void *)*a4;
    while (1)
    {
      unint64_t v18 = v33[0];
      if ((char *)v33[1] - (char *)v33[0] == v32 - v17 && !memcmp(v33[0], v17, (char *)v33[1] - (char *)v33[0])) {
        break;
      }
      if (a1[1] == a1[2]) {
        __int16 v19 = MIL::ValueInference::Tensor<MIL::Bf16>::GetScalarData(a1);
      }
      else {
      if (a2[1] == a2[2]) {
        __int16 v20 = MIL::ValueInference::Tensor<MIL::Bf16>::GetScalarData(a2);
      }
      else {
      __int16 v21 = std::function<MIL::Bf16 ()(MIL::Bf16,MIL::Bf16)>::operator()(a3, v19, v20);
      }
      uint64_t v27 = 0;
      uint64_t v28 = 0;
      unint64_t v26 = 0;
      std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v26, v33[0], (uint64_t)v33[1], ((char *)v33[1] - (char *)v33[0]) >> 3);
      if (v33[0])
      {
        v33[1] = v33[0];
        operator delete(v33[0]);
      }
      *(_OWORD *)uint64_t v33 = v29;
      uint64_t v34 = v30;
      if (v26)
      {
        uint64_t v27 = v26;
        operator delete(v26);
      }
      uint64_t v17 = __s2;
    }
    if (v17)
    {
      std::string::size_type v32 = v17;
      operator delete(v17);
      unint64_t v18 = v33[0];
    }
    if (v18)
    {
      v33[1] = v18;
      operator delete(v18);
    }
  }
  if (v37.n128_u64[0])
  {
    v37.n128_u64[1] = v37.n128_u64[0];
    operator delete((void *)v37.n128_u64[0]);
  }
  if (v39.n128_u64[0])
  {
    v39.n128_u64[1] = v39.n128_u64[0];
    operator delete((void *)v39.n128_u64[0]);
  }
}

void sub_20F4D52E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27)
{
  if (__p) {
    operator delete(__p);
  }
  long long v29 = *(void **)(v27 - 112);
  if (v29)
  {
    *(void *)(v27 - 104) = v29;
    operator delete(v29);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::BinaryOp<int,int>(void *a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, void *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v9 = (void *)*a4;
  uint64_t v10 = a4[1];
  uint64_t v11 = v10 - *a4;
  if (v10 == *a4)
  {
    Scalaruint64_t Data = MIL::ValueInference::Tensor<int>::GetScalarData(a1);
    int v23 = MIL::ValueInference::Tensor<int>::GetScalarData(a2);
    int v24 = std::function<int ()(int,int)>::operator()(a3, ScalarData, v23);
    __n128 v39 = 0uLL;
    uint64_t v40 = 0;
    int v25 = operator new(4uLL);
    v37.n128_u64[0] = (unint64_t)v25;
    _DWORD *v25 = v24;
    v37.n128_u64[1] = (unint64_t)(v25 + 1);
    __n128 v38 = v25 + 1;
    MIL::ValueInference::Tensor<int>::Tensor(a5, &v39, &v37);
  }
  else
  {
    __n128 __p = 0uLL;
    uint64_t v36 = 0;
    std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, v9, v10, v11 >> 3);
    MIL::ValueInference::Tensor<int>::Zeros(&__p, a5);
    if (__p.n128_u64[0])
    {
      __p.n128_u64[1] = __p.n128_u64[0];
      operator delete((void *)__p.n128_u64[0]);
    }
    unint64_t v13 = (uint64_t)(a1[2] - a1[1]) >> 3;
    v37.n128_u64[0] = 0;
    std::vector<unsigned long long>::vector(&v39, v13, &v37);
    unint64_t v14 = (uint64_t)(a2[2] - a2[1]) >> 3;
    v33[0] = 0;
    std::vector<unsigned long long>::vector(&v37, v14, v33);
    unint64_t v15 = (uint64_t)(a4[1] - *a4) >> 3;
    __s2 = 0;
    std::vector<unsigned long long>::vector(v33, v15, &__s2);
    unint64_t v16 = (uint64_t)(a4[1] - *a4) >> 3;
    *(void *)&long long v29 = 0;
    std::vector<unsigned long long>::vector(&__s2, v16, &v29);
    uint64_t v17 = __s2;
    *(void *)__s2 = *(void *)*a4;
    while (1)
    {
      unint64_t v18 = v33[0];
      if ((char *)v33[1] - (char *)v33[0] == v32 - v17 && !memcmp(v33[0], v17, (char *)v33[1] - (char *)v33[0])) {
        break;
      }
      if (a1[1] == a1[2]) {
        int v19 = MIL::ValueInference::Tensor<int>::GetScalarData(a1);
      }
      else {
      if (a2[1] == a2[2]) {
        int v20 = MIL::ValueInference::Tensor<int>::GetScalarData(a2);
      }
      else {
      int v21 = std::function<int ()(int,int)>::operator()(a3, v19, v20);
      }
      uint64_t v27 = 0;
      uint64_t v28 = 0;
      unint64_t v26 = 0;
      std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v26, v33[0], (uint64_t)v33[1], ((char *)v33[1] - (char *)v33[0]) >> 3);
      if (v33[0])
      {
        v33[1] = v33[0];
        operator delete(v33[0]);
      }
      *(_OWORD *)uint64_t v33 = v29;
      uint64_t v34 = v30;
      if (v26)
      {
        uint64_t v27 = v26;
        operator delete(v26);
      }
      uint64_t v17 = __s2;
    }
    if (v17)
    {
      std::string::size_type v32 = v17;
      operator delete(v17);
      unint64_t v18 = v33[0];
    }
    if (v18)
    {
      v33[1] = v18;
      operator delete(v18);
    }
  }
  if (v37.n128_u64[0])
  {
    v37.n128_u64[1] = v37.n128_u64[0];
    operator delete((void *)v37.n128_u64[0]);
  }
  if (v39.n128_u64[0])
  {
    v39.n128_u64[1] = v39.n128_u64[0];
    operator delete((void *)v39.n128_u64[0]);
  }
}

void sub_20F4D56B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27)
{
  if (__p) {
    operator delete(__p);
  }
  long long v29 = *(void **)(v27 - 112);
  if (v29)
  {
    *(void *)(v27 - 104) = v29;
    operator delete(v29);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::BinaryOp<BOOL,BOOL>(void *a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, void *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v9 = (void *)*a4;
  uint64_t v10 = a4[1];
  uint64_t v11 = v10 - *a4;
  if (v10 == *a4)
  {
    Scalaruint64_t Data = MIL::ValueInference::Tensor<BOOL>::GetScalarData(a1);
    char v23 = MIL::ValueInference::Tensor<BOOL>::GetScalarData(a2);
    char v24 = std::function<unsigned char ()(unsigned char,unsigned char)>::operator()(a3, ScalarData, v23);
    __n128 v39 = 0uLL;
    uint64_t v40 = 0;
    int v25 = operator new(1uLL);
    v37.n128_u64[0] = (unint64_t)v25;
    unsigned char *v25 = v24;
    v37.n128_u64[1] = (unint64_t)(v25 + 1);
    __n128 v38 = v25 + 1;
    MIL::ValueInference::Tensor<BOOL>::Tensor(a5, &v39, &v37);
  }
  else
  {
    __n128 __p = 0uLL;
    uint64_t v36 = 0;
    std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, v9, v10, v11 >> 3);
    MIL::ValueInference::Tensor<BOOL>::Zeros(&__p, a5);
    if (__p.n128_u64[0])
    {
      __p.n128_u64[1] = __p.n128_u64[0];
      operator delete((void *)__p.n128_u64[0]);
    }
    unint64_t v13 = (uint64_t)(a1[2] - a1[1]) >> 3;
    v37.n128_u64[0] = 0;
    std::vector<unsigned long long>::vector(&v39, v13, &v37);
    unint64_t v14 = (uint64_t)(a2[2] - a2[1]) >> 3;
    v33[0] = 0;
    std::vector<unsigned long long>::vector(&v37, v14, v33);
    unint64_t v15 = (uint64_t)(a4[1] - *a4) >> 3;
    __s2 = 0;
    std::vector<unsigned long long>::vector(v33, v15, &__s2);
    unint64_t v16 = (uint64_t)(a4[1] - *a4) >> 3;
    *(void *)&long long v29 = 0;
    std::vector<unsigned long long>::vector(&__s2, v16, &v29);
    uint64_t v17 = __s2;
    *(void *)__s2 = *(void *)*a4;
    while (1)
    {
      unint64_t v18 = v33[0];
      if ((char *)v33[1] - (char *)v33[0] == v32 - v17 && !memcmp(v33[0], v17, (char *)v33[1] - (char *)v33[0])) {
        break;
      }
      if (a1[1] == a1[2]) {
        char v19 = MIL::ValueInference::Tensor<BOOL>::GetScalarData(a1);
      }
      else {
      if (a2[1] == a2[2]) {
        char v20 = MIL::ValueInference::Tensor<BOOL>::GetScalarData(a2);
      }
      else {
      char v21 = std::function<unsigned char ()(unsigned char,unsigned char)>::operator()(a3, v19, v20);
      }
      uint64_t v27 = 0;
      uint64_t v28 = 0;
      unint64_t v26 = 0;
      std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v26, v33[0], (uint64_t)v33[1], ((char *)v33[1] - (char *)v33[0]) >> 3);
      if (v33[0])
      {
        v33[1] = v33[0];
        operator delete(v33[0]);
      }
      *(_OWORD *)uint64_t v33 = v29;
      uint64_t v34 = v30;
      if (v26)
      {
        uint64_t v27 = v26;
        operator delete(v26);
      }
      uint64_t v17 = __s2;
    }
    if (v17)
    {
      std::string::size_type v32 = v17;
      operator delete(v17);
      unint64_t v18 = v33[0];
    }
    if (v18)
    {
      v33[1] = v18;
      operator delete(v18);
    }
  }
  if (v37.n128_u64[0])
  {
    v37.n128_u64[1] = v37.n128_u64[0];
    operator delete((void *)v37.n128_u64[0]);
  }
  if (v39.n128_u64[0])
  {
    v39.n128_u64[1] = v39.n128_u64[0];
    operator delete((void *)v39.n128_u64[0]);
  }
}

void sub_20F4D5A84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27)
{
  if (__p) {
    operator delete(__p);
  }
  long long v29 = *(void **)(v27 - 112);
  if (v29)
  {
    *(void *)(v27 - 104) = v29;
    operator delete(v29);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::BinaryOp<float,BOOL>(void *a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, void *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v9 = (void *)*a4;
  uint64_t v10 = a4[1];
  uint64_t v11 = v10 - *a4;
  if (v10 == *a4)
  {
    Scalaruint64_t Data = MIL::ValueInference::Tensor<float>::GetScalarData(a1);
    float v23 = MIL::ValueInference::Tensor<float>::GetScalarData(a2);
    char v24 = std::function<unsigned char ()(float,float)>::operator()(a3, ScalarData, v23);
    __n128 v39 = 0uLL;
    uint64_t v40 = 0;
    int v25 = operator new(1uLL);
    v37.n128_u64[0] = (unint64_t)v25;
    unsigned char *v25 = v24;
    v37.n128_u64[1] = (unint64_t)(v25 + 1);
    __n128 v38 = v25 + 1;
    MIL::ValueInference::Tensor<BOOL>::Tensor(a5, &v39, &v37);
  }
  else
  {
    __n128 __p = 0uLL;
    uint64_t v36 = 0;
    std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, v9, v10, v11 >> 3);
    MIL::ValueInference::Tensor<BOOL>::Zeros(&__p, a5);
    if (__p.n128_u64[0])
    {
      __p.n128_u64[1] = __p.n128_u64[0];
      operator delete((void *)__p.n128_u64[0]);
    }
    unint64_t v13 = (uint64_t)(a1[2] - a1[1]) >> 3;
    v37.n128_u64[0] = 0;
    std::vector<unsigned long long>::vector(&v39, v13, &v37);
    unint64_t v14 = (uint64_t)(a2[2] - a2[1]) >> 3;
    v33[0] = 0;
    std::vector<unsigned long long>::vector(&v37, v14, v33);
    unint64_t v15 = (uint64_t)(a4[1] - *a4) >> 3;
    __s2 = 0;
    std::vector<unsigned long long>::vector(v33, v15, &__s2);
    unint64_t v16 = (uint64_t)(a4[1] - *a4) >> 3;
    *(void *)&long long v29 = 0;
    std::vector<unsigned long long>::vector(&__s2, v16, &v29);
    uint64_t v17 = __s2;
    *(void *)__s2 = *(void *)*a4;
    while (1)
    {
      unint64_t v18 = v33[0];
      if ((char *)v33[1] - (char *)v33[0] == v32 - v17 && !memcmp(v33[0], v17, (char *)v33[1] - (char *)v33[0])) {
        break;
      }
      if (a1[1] == a1[2]) {
        float v19 = MIL::ValueInference::Tensor<float>::GetScalarData(a1);
      }
      else {
      if (a2[1] == a2[2]) {
        float v20 = MIL::ValueInference::Tensor<float>::GetScalarData(a2);
      }
      else {
      char v21 = std::function<unsigned char ()(float,float)>::operator()(a3, v19, v20);
      }
      uint64_t v27 = 0;
      uint64_t v28 = 0;
      unint64_t v26 = 0;
      std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v26, v33[0], (uint64_t)v33[1], ((char *)v33[1] - (char *)v33[0]) >> 3);
      if (v33[0])
      {
        v33[1] = v33[0];
        operator delete(v33[0]);
      }
      *(_OWORD *)uint64_t v33 = v29;
      uint64_t v34 = v30;
      if (v26)
      {
        uint64_t v27 = v26;
        operator delete(v26);
      }
      uint64_t v17 = __s2;
    }
    if (v17)
    {
      std::string::size_type v32 = v17;
      operator delete(v17);
      unint64_t v18 = v33[0];
    }
    if (v18)
    {
      v33[1] = v18;
      operator delete(v18);
    }
  }
  if (v37.n128_u64[0])
  {
    v37.n128_u64[1] = v37.n128_u64[0];
    operator delete((void *)v37.n128_u64[0]);
  }
  if (v39.n128_u64[0])
  {
    v39.n128_u64[1] = v39.n128_u64[0];
    operator delete((void *)v39.n128_u64[0]);
  }
}

void sub_20F4D5E5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27)
{
  if (__p) {
    operator delete(__p);
  }
  long long v29 = *(void **)(v27 - 128);
  if (v29)
  {
    *(void *)(v27 - 120) = v29;
    operator delete(v29);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::function<unsigned char ()(float,float)>::operator()(uint64_t a1, float a2, float a3)
{
  float v6 = a2;
  float v5 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, float *, float *))(*(void *)v3 + 48))(v3, &v6, &v5);
}

void MIL::ValueInference::BinaryOp<int,BOOL>(void *a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, void *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v9 = (void *)*a4;
  uint64_t v10 = a4[1];
  uint64_t v11 = v10 - *a4;
  if (v10 == *a4)
  {
    Scalaruint64_t Data = MIL::ValueInference::Tensor<int>::GetScalarData(a1);
    int v23 = MIL::ValueInference::Tensor<int>::GetScalarData(a2);
    char v24 = std::function<unsigned char ()(int,int)>::operator()(a3, ScalarData, v23);
    __n128 v39 = 0uLL;
    uint64_t v40 = 0;
    int v25 = operator new(1uLL);
    v37.n128_u64[0] = (unint64_t)v25;
    unsigned char *v25 = v24;
    v37.n128_u64[1] = (unint64_t)(v25 + 1);
    __n128 v38 = v25 + 1;
    MIL::ValueInference::Tensor<BOOL>::Tensor(a5, &v39, &v37);
  }
  else
  {
    __n128 __p = 0uLL;
    uint64_t v36 = 0;
    std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, v9, v10, v11 >> 3);
    MIL::ValueInference::Tensor<BOOL>::Zeros(&__p, a5);
    if (__p.n128_u64[0])
    {
      __p.n128_u64[1] = __p.n128_u64[0];
      operator delete((void *)__p.n128_u64[0]);
    }
    unint64_t v13 = (uint64_t)(a1[2] - a1[1]) >> 3;
    v37.n128_u64[0] = 0;
    std::vector<unsigned long long>::vector(&v39, v13, &v37);
    unint64_t v14 = (uint64_t)(a2[2] - a2[1]) >> 3;
    v33[0] = 0;
    std::vector<unsigned long long>::vector(&v37, v14, v33);
    unint64_t v15 = (uint64_t)(a4[1] - *a4) >> 3;
    __s2 = 0;
    std::vector<unsigned long long>::vector(v33, v15, &__s2);
    unint64_t v16 = (uint64_t)(a4[1] - *a4) >> 3;
    *(void *)&long long v29 = 0;
    std::vector<unsigned long long>::vector(&__s2, v16, &v29);
    uint64_t v17 = __s2;
    *(void *)__s2 = *(void *)*a4;
    while (1)
    {
      unint64_t v18 = v33[0];
      if ((char *)v33[1] - (char *)v33[0] == v32 - v17 && !memcmp(v33[0], v17, (char *)v33[1] - (char *)v33[0])) {
        break;
      }
      if (a1[1] == a1[2]) {
        int v19 = MIL::ValueInference::Tensor<int>::GetScalarData(a1);
      }
      else {
      if (a2[1] == a2[2]) {
        int v20 = MIL::ValueInference::Tensor<int>::GetScalarData(a2);
      }
      else {
      char v21 = std::function<unsigned char ()(int,int)>::operator()(a3, v19, v20);
      }
      uint64_t v27 = 0;
      uint64_t v28 = 0;
      unint64_t v26 = 0;
      std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v26, v33[0], (uint64_t)v33[1], ((char *)v33[1] - (char *)v33[0]) >> 3);
      if (v33[0])
      {
        v33[1] = v33[0];
        operator delete(v33[0]);
      }
      *(_OWORD *)uint64_t v33 = v29;
      uint64_t v34 = v30;
      if (v26)
      {
        uint64_t v27 = v26;
        operator delete(v26);
      }
      uint64_t v17 = __s2;
    }
    if (v17)
    {
      std::string::size_type v32 = v17;
      operator delete(v17);
      unint64_t v18 = v33[0];
    }
    if (v18)
    {
      v33[1] = v18;
      operator delete(v18);
    }
  }
  if (v37.n128_u64[0])
  {
    v37.n128_u64[1] = v37.n128_u64[0];
    operator delete((void *)v37.n128_u64[0]);
  }
  if (v39.n128_u64[0])
  {
    v39.n128_u64[1] = v39.n128_u64[0];
    operator delete((void *)v39.n128_u64[0]);
  }
}

void sub_20F4D6288(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27)
{
  if (__p) {
    operator delete(__p);
  }
  long long v29 = *(void **)(v27 - 112);
  if (v29)
  {
    *(void *)(v27 - 104) = v29;
    operator delete(v29);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::function<unsigned char ()(int,int)>::operator()(uint64_t a1, int a2, int a3)
{
  int v6 = a2;
  int v5 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, int *, int *))(*(void *)v3 + 48))(v3, &v6, &v5);
}

void MIL::ValueInference::BinaryOp<MIL::Fp16,BOOL>(void *a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, void *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v9 = (void *)*a4;
  uint64_t v10 = a4[1];
  uint64_t v11 = v10 - *a4;
  if (v10 == *a4)
  {
    Scalaruint64_t Data = MIL::ValueInference::Tensor<MIL::Fp16>::GetScalarData(a1);
    __int16 v23 = MIL::ValueInference::Tensor<MIL::Fp16>::GetScalarData(a2);
    char v24 = std::function<unsigned char ()(MIL::Fp16,MIL::Fp16)>::operator()(a3, ScalarData, v23);
    __n128 v39 = 0uLL;
    uint64_t v40 = 0;
    int v25 = operator new(1uLL);
    v37.n128_u64[0] = (unint64_t)v25;
    unsigned char *v25 = v24;
    v37.n128_u64[1] = (unint64_t)(v25 + 1);
    __n128 v38 = v25 + 1;
    MIL::ValueInference::Tensor<BOOL>::Tensor(a5, &v39, &v37);
  }
  else
  {
    __n128 __p = 0uLL;
    uint64_t v36 = 0;
    std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, v9, v10, v11 >> 3);
    MIL::ValueInference::Tensor<BOOL>::Zeros(&__p, a5);
    if (__p.n128_u64[0])
    {
      __p.n128_u64[1] = __p.n128_u64[0];
      operator delete((void *)__p.n128_u64[0]);
    }
    unint64_t v13 = (uint64_t)(a1[2] - a1[1]) >> 3;
    v37.n128_u64[0] = 0;
    std::vector<unsigned long long>::vector(&v39, v13, &v37);
    unint64_t v14 = (uint64_t)(a2[2] - a2[1]) >> 3;
    v33[0] = 0;
    std::vector<unsigned long long>::vector(&v37, v14, v33);
    unint64_t v15 = (uint64_t)(a4[1] - *a4) >> 3;
    __s2 = 0;
    std::vector<unsigned long long>::vector(v33, v15, &__s2);
    unint64_t v16 = (uint64_t)(a4[1] - *a4) >> 3;
    *(void *)&long long v29 = 0;
    std::vector<unsigned long long>::vector(&__s2, v16, &v29);
    uint64_t v17 = __s2;
    *(void *)__s2 = *(void *)*a4;
    while (1)
    {
      unint64_t v18 = v33[0];
      if ((char *)v33[1] - (char *)v33[0] == v32 - v17 && !memcmp(v33[0], v17, (char *)v33[1] - (char *)v33[0])) {
        break;
      }
      if (a1[1] == a1[2]) {
        __int16 v19 = MIL::ValueInference::Tensor<MIL::Fp16>::GetScalarData(a1);
      }
      else {
      if (a2[1] == a2[2]) {
        __int16 v20 = MIL::ValueInference::Tensor<MIL::Fp16>::GetScalarData(a2);
      }
      else {
      char v21 = std::function<unsigned char ()(MIL::Fp16,MIL::Fp16)>::operator()(a3, v19, v20);
      }
      uint64_t v27 = 0;
      uint64_t v28 = 0;
      unint64_t v26 = 0;
      std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v26, v33[0], (uint64_t)v33[1], ((char *)v33[1] - (char *)v33[0]) >> 3);
      if (v33[0])
      {
        v33[1] = v33[0];
        operator delete(v33[0]);
      }
      *(_OWORD *)uint64_t v33 = v29;
      uint64_t v34 = v30;
      if (v26)
      {
        uint64_t v27 = v26;
        operator delete(v26);
      }
      uint64_t v17 = __s2;
    }
    if (v17)
    {
      std::string::size_type v32 = v17;
      operator delete(v17);
      unint64_t v18 = v33[0];
    }
    if (v18)
    {
      v33[1] = v18;
      operator delete(v18);
    }
  }
  if (v37.n128_u64[0])
  {
    v37.n128_u64[1] = v37.n128_u64[0];
    operator delete((void *)v37.n128_u64[0]);
  }
  if (v39.n128_u64[0])
  {
    v39.n128_u64[1] = v39.n128_u64[0];
    operator delete((void *)v39.n128_u64[0]);
  }
}

void sub_20F4D66B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27)
{
  if (__p) {
    operator delete(__p);
  }
  long long v29 = *(void **)(v27 - 112);
  if (v29)
  {
    *(void *)(v27 - 104) = v29;
    operator delete(v29);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::function<unsigned char ()(MIL::Fp16,MIL::Fp16)>::operator()(uint64_t a1, __int16 a2, __int16 a3)
{
  __int16 v6 = a2;
  __int16 v5 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, __int16 *, __int16 *))(*(void *)v3 + 48))(v3, &v6, &v5);
}

void MIL::ValueInference::BinaryOp<MIL::Bf16,BOOL>(void *a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, void *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v9 = (void *)*a4;
  uint64_t v10 = a4[1];
  uint64_t v11 = v10 - *a4;
  if (v10 == *a4)
  {
    Scalaruint64_t Data = MIL::ValueInference::Tensor<MIL::Bf16>::GetScalarData(a1);
    __int16 v23 = MIL::ValueInference::Tensor<MIL::Bf16>::GetScalarData(a2);
    char v24 = std::function<unsigned char ()(MIL::Bf16,MIL::Bf16)>::operator()(a3, ScalarData, v23);
    __n128 v39 = 0uLL;
    uint64_t v40 = 0;
    int v25 = operator new(1uLL);
    v37.n128_u64[0] = (unint64_t)v25;
    unsigned char *v25 = v24;
    v37.n128_u64[1] = (unint64_t)(v25 + 1);
    __n128 v38 = v25 + 1;
    MIL::ValueInference::Tensor<BOOL>::Tensor(a5, &v39, &v37);
  }
  else
  {
    __n128 __p = 0uLL;
    uint64_t v36 = 0;
    std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&__p, v9, v10, v11 >> 3);
    MIL::ValueInference::Tensor<BOOL>::Zeros(&__p, a5);
    if (__p.n128_u64[0])
    {
      __p.n128_u64[1] = __p.n128_u64[0];
      operator delete((void *)__p.n128_u64[0]);
    }
    unint64_t v13 = (uint64_t)(a1[2] - a1[1]) >> 3;
    v37.n128_u64[0] = 0;
    std::vector<unsigned long long>::vector(&v39, v13, &v37);
    unint64_t v14 = (uint64_t)(a2[2] - a2[1]) >> 3;
    v33[0] = 0;
    std::vector<unsigned long long>::vector(&v37, v14, v33);
    unint64_t v15 = (uint64_t)(a4[1] - *a4) >> 3;
    __s2 = 0;
    std::vector<unsigned long long>::vector(v33, v15, &__s2);
    unint64_t v16 = (uint64_t)(a4[1] - *a4) >> 3;
    *(void *)&long long v29 = 0;
    std::vector<unsigned long long>::vector(&__s2, v16, &v29);
    uint64_t v17 = __s2;
    *(void *)__s2 = *(void *)*a4;
    while (1)
    {
      unint64_t v18 = v33[0];
      if ((char *)v33[1] - (char *)v33[0] == v32 - v17 && !memcmp(v33[0], v17, (char *)v33[1] - (char *)v33[0])) {
        break;
      }
      if (a1[1] == a1[2]) {
        __int16 v19 = MIL::ValueInference::Tensor<MIL::Bf16>::GetScalarData(a1);
      }
      else {
      if (a2[1] == a2[2]) {
        __int16 v20 = MIL::ValueInference::Tensor<MIL::Bf16>::GetScalarData(a2);
      }
      else {
      char v21 = std::function<unsigned char ()(MIL::Bf16,MIL::Bf16)>::operator()(a3, v19, v20);
      }
      uint64_t v27 = 0;
      uint64_t v28 = 0;
      unint64_t v26 = 0;
      std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v26, v33[0], (uint64_t)v33[1], ((char *)v33[1] - (char *)v33[0]) >> 3);
      if (v33[0])
      {
        v33[1] = v33[0];
        operator delete(v33[0]);
      }
      *(_OWORD *)uint64_t v33 = v29;
      uint64_t v34 = v30;
      if (v26)
      {
        uint64_t v27 = v26;
        operator delete(v26);
      }
      uint64_t v17 = __s2;
    }
    if (v17)
    {
      std::string::size_type v32 = v17;
      operator delete(v17);
      unint64_t v18 = v33[0];
    }
    if (v18)
    {
      v33[1] = v18;
      operator delete(v18);
    }
  }
  if (v37.n128_u64[0])
  {
    v37.n128_u64[1] = v37.n128_u64[0];
    operator delete((void *)v37.n128_u64[0]);
  }
  if (v39.n128_u64[0])
  {
    v39.n128_u64[1] = v39.n128_u64[0];
    operator delete((void *)v39.n128_u64[0]);
  }
}

void sub_20F4D6AE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27)
{
  if (__p) {
    operator delete(__p);
  }
  long long v29 = *(void **)(v27 - 112);
  if (v29)
  {
    *(void *)(v27 - 104) = v29;
    operator delete(v29);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::function<unsigned char ()(MIL::Bf16,MIL::Bf16)>::operator()(uint64_t a1, __int16 a2, __int16 a3)
{
  __int16 v6 = a2;
  __int16 v5 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, __int16 *, __int16 *))(*(void *)v3 + 48))(v3, &v6, &v5);
}

void MIL::ValueInference::Tensor<MIL::Bf16>::ForEach(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v25[4] = *MEMORY[0x263EF8340];
  __n128 __p = 0uLL;
  unint64_t v24 = 0;
  std::vector<MIL::Fp16>::reserve((void **)&__p, (uint64_t)(*(void *)(a1 + 40) - *(void *)(a1 + 32)) >> 1);
  if (*(void *)(a1 + 40) != *(void *)(a1 + 32))
  {
    unint64_t v7 = 0;
    do
    {
      __int16 v6 = (MIL::Bf16 *)MIL::Bf16::FromFloat(v6, 0.0);
      __int16 v8 = (__int16)v6;
      unint64_t v9 = __p.n128_u64[1];
      if (__p.n128_u64[1] >= v24)
      {
        __int16 v6 = (MIL::Bf16 *)__p.n128_u64[0];
        int64_t v11 = __p.n128_u64[1] - __p.n128_u64[0];
        if ((uint64_t)(__p.n128_u64[1] - __p.n128_u64[0]) <= -3) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v12 = v11 >> 1;
        if (v24 - __p.n128_u64[0] <= (v11 >> 1) + 1) {
          uint64_t v13 = v12 + 1;
        }
        else {
          uint64_t v13 = v24 - __p.n128_u64[0];
        }
        if (v24 - __p.n128_u64[0] >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v14 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v14 = v13;
        }
        if (v14)
        {
          unint64_t v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MIL::Fp16>>((uint64_t)&v24, v14);
          unint64_t v9 = __p.n128_u64[1];
          __int16 v6 = (MIL::Bf16 *)__p.n128_u64[0];
        }
        else
        {
          unint64_t v15 = 0;
        }
        unint64_t v16 = &v15[2 * v12];
        *(_WORD *)unint64_t v16 = v8;
        unint64_t v10 = (unint64_t)(v16 + 2);
        while ((MIL::Bf16 *)v9 != v6)
        {
          __int16 v17 = *(_WORD *)(v9 - 2);
          v9 -= 2;
          *((_WORD *)v16 - 1) = v17;
          v16 -= 2;
        }
        __p.n128_u64[0] = (unint64_t)v16;
        __p.n128_u64[1] = v10;
        unint64_t v24 = (unint64_t)&v15[2 * v14];
        if (v6) {
          operator delete(v6);
        }
      }
      else
      {
        *(_WORD *)__p.n128_u64[1] = (_WORD)v6;
        unint64_t v10 = v9 + 2;
      }
      __p.n128_u64[1] = v10;
      ++v7;
    }
    while (v7 < (uint64_t)(*(void *)(a1 + 40) - *(void *)(a1 + 32)) >> 1);
  }
  __n128 v21 = 0uLL;
  uint64_t v22 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v21, *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3);
  __int16 v19 = *(__int16 **)(a1 + 32);
  unint64_t v18 = *(__int16 **)(a1 + 40);
  __int16 v20 = (_WORD *)__p.n128_u64[0];
  std::__function::__value_func<MIL::Bf16 ()(MIL::Bf16)>::__value_func[abi:ne180100]((uint64_t)v25, a2);
  while (v19 != v18)
    *v20++ = std::function<MIL::Bf16 ()(MIL::Bf16)>::operator()((uint64_t)v25, *v19++);
  std::__function::__value_func<MIL::Bf16 ()(MIL::Bf16)>::~__value_func[abi:ne180100](v25);
  MIL::ValueInference::Tensor<MIL::Bf16>::Tensor(a3, &v21, &__p);
  if (v21.n128_u64[0])
  {
    v21.n128_u64[1] = v21.n128_u64[0];
    operator delete((void *)v21.n128_u64[0]);
  }
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
}

void sub_20F4D6E1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, char a16)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<MIL::Fp16>::ForEach(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v25[4] = *MEMORY[0x263EF8340];
  __n128 __p = 0uLL;
  unint64_t v24 = 0;
  std::vector<MIL::Fp16>::reserve((void **)&__p, (uint64_t)(*(void *)(a1 + 40) - *(void *)(a1 + 32)) >> 1);
  if (*(void *)(a1 + 40) != *(void *)(a1 + 32))
  {
    unint64_t v7 = 0;
    do
    {
      __int16 v6 = (MIL::Fp16 *)MIL::Fp16::FromFloat(v6, 0.0);
      __int16 v8 = (__int16)v6;
      unint64_t v9 = __p.n128_u64[1];
      if (__p.n128_u64[1] >= v24)
      {
        __int16 v6 = (MIL::Fp16 *)__p.n128_u64[0];
        int64_t v11 = __p.n128_u64[1] - __p.n128_u64[0];
        if ((uint64_t)(__p.n128_u64[1] - __p.n128_u64[0]) <= -3) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v12 = v11 >> 1;
        if (v24 - __p.n128_u64[0] <= (v11 >> 1) + 1) {
          uint64_t v13 = v12 + 1;
        }
        else {
          uint64_t v13 = v24 - __p.n128_u64[0];
        }
        if (v24 - __p.n128_u64[0] >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v14 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v14 = v13;
        }
        if (v14)
        {
          unint64_t v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MIL::Fp16>>((uint64_t)&v24, v14);
          unint64_t v9 = __p.n128_u64[1];
          __int16 v6 = (MIL::Fp16 *)__p.n128_u64[0];
        }
        else
        {
          unint64_t v15 = 0;
        }
        unint64_t v16 = &v15[2 * v12];
        *(_WORD *)unint64_t v16 = v8;
        unint64_t v10 = (unint64_t)(v16 + 2);
        while ((MIL::Fp16 *)v9 != v6)
        {
          __int16 v17 = *(_WORD *)(v9 - 2);
          v9 -= 2;
          *((_WORD *)v16 - 1) = v17;
          v16 -= 2;
        }
        __p.n128_u64[0] = (unint64_t)v16;
        __p.n128_u64[1] = v10;
        unint64_t v24 = (unint64_t)&v15[2 * v14];
        if (v6) {
          operator delete(v6);
        }
      }
      else
      {
        *(_WORD *)__p.n128_u64[1] = (_WORD)v6;
        unint64_t v10 = v9 + 2;
      }
      __p.n128_u64[1] = v10;
      ++v7;
    }
    while (v7 < (uint64_t)(*(void *)(a1 + 40) - *(void *)(a1 + 32)) >> 1);
  }
  __n128 v21 = 0uLL;
  uint64_t v22 = 0;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v21, *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3);
  __int16 v19 = *(__int16 **)(a1 + 32);
  unint64_t v18 = *(__int16 **)(a1 + 40);
  __int16 v20 = (_WORD *)__p.n128_u64[0];
  std::__function::__value_func<MIL::Fp16 ()(MIL::Fp16)>::__value_func[abi:ne180100]((uint64_t)v25, a2);
  while (v19 != v18)
    *v20++ = std::function<MIL::Fp16 ()(MIL::Fp16)>::operator()((uint64_t)v25, *v19++);
  std::__function::__value_func<MIL::Fp16 ()(MIL::Fp16)>::~__value_func[abi:ne180100](v25);
  MIL::ValueInference::Tensor<MIL::Fp16>::Tensor(a3, &v21, &__p);
  if (v21.n128_u64[0])
  {
    v21.n128_u64[1] = v21.n128_u64[0];
    operator delete((void *)v21.n128_u64[0]);
  }
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
}

void sub_20F4D7070(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, char a16)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<MIL::Bf16>::Cast<BOOL>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v24 = 0;
  __n128 v23 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v23, v4, v5, (v5 - (uint64_t)v4) >> 3);
  __n128 __p = 0uLL;
  unint64_t v22 = 0;
  std::vector<unsigned char>::reserve(__p.n128_u64, (uint64_t)(a1[5] - a1[4]) >> 1);
  uint64_t v6 = a1[4];
  if (a1[5] != v6)
  {
    unint64_t v7 = 0;
    do
    {
      BOOL v8 = MIL::Bf16::GetFloat((MIL::Bf16 *)(v6 + 2 * v7)) != 0.0;
      unint64_t v9 = (char *)__p.n128_u64[1];
      if (__p.n128_u64[1] >= v22)
      {
        unint64_t v11 = __p.n128_u64[0];
        unint64_t v12 = __p.n128_u64[1] - __p.n128_u64[0];
        int64_t v13 = __p.n128_u64[1] - __p.n128_u64[0] + 1;
        if (v13 < 0) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v14 = v22 - __p.n128_u64[0];
        if (2 * (v22 - __p.n128_u64[0]) > v13) {
          int64_t v13 = 2 * v14;
        }
        if (v14 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v15 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v15 = v13;
        }
        if (v15) {
          unint64_t v16 = (unint64_t)operator new(v15);
        }
        else {
          unint64_t v16 = 0;
        }
        unint64_t v17 = v16 + v12;
        unint64_t v18 = (BOOL *)(v16 + v12);
        BOOL *v18 = v8;
        unint64_t v10 = (unint64_t)(v18 + 1);
        if (v9 != (char *)v11)
        {
          __int16 v19 = &v9[~v11];
          do
          {
            char v20 = *--v9;
            (v19--)[v16] = v20;
          }
          while (v9 != (char *)v11);
          unint64_t v9 = (char *)__p.n128_u64[0];
          unint64_t v17 = v16;
        }
        __p.n128_u64[0] = v17;
        __p.n128_u64[1] = v10;
        unint64_t v22 = v16 + v15;
        if (v9) {
          operator delete(v9);
        }
      }
      else
      {
        *(unsigned char *)__p.n128_u64[1] = v8;
        unint64_t v10 = (unint64_t)(v9 + 1);
      }
      __p.n128_u64[1] = v10;
      ++v7;
      uint64_t v6 = a1[4];
    }
    while (v7 < (a1[5] - v6) >> 1);
  }
  MIL::ValueInference::Tensor<BOOL>::Tensor(a2, &v23, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v23.n128_u64[0])
  {
    v23.n128_u64[1] = v23.n128_u64[0];
    operator delete((void *)v23.n128_u64[0]);
  }
}

void sub_20F4D7264(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<MIL::Bf16>::Cast<MIL::Bf16>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (const void *)a1[4];
  uint64_t v7 = a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<MIL::Bf16>::__init_with_size[abi:ne180100]<std::__wrap_iter<MIL::Bf16 const*>,std::__wrap_iter<MIL::Bf16 const*>>(&__p, v6, v7, (v7 - (uint64_t)v6) >> 1);
  MIL::ValueInference::Tensor<MIL::Bf16>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4D732C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<MIL::Fp16>::Cast<MIL::Bf16>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v25 = 0;
  __n128 v24 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v24, v4, v5, (v5 - (uint64_t)v4) >> 3);
  __n128 __p = 0uLL;
  unint64_t v23 = 0;
  std::vector<MIL::Fp16>::reserve((void **)&__p, (uint64_t)(a1[5] - a1[4]) >> 1);
  uint64_t v6 = a1[4];
  if (a1[5] != v6)
  {
    unint64_t v7 = 0;
    do
    {
      float Float = MIL::Fp16::GetFloat((MIL::Fp16 *)(v6 + 2 * v7));
      __int16 v10 = MIL::Bf16::FromFloat(v9, Float);
      __int16 v11 = v10;
      unint64_t v12 = __p.n128_u64[1];
      if (__p.n128_u64[1] >= v23)
      {
        unint64_t v14 = (void *)__p.n128_u64[0];
        int64_t v15 = __p.n128_u64[1] - __p.n128_u64[0];
        if ((uint64_t)(__p.n128_u64[1] - __p.n128_u64[0]) <= -3) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v16 = v15 >> 1;
        if (v23 - __p.n128_u64[0] <= (v15 >> 1) + 1) {
          uint64_t v17 = v16 + 1;
        }
        else {
          uint64_t v17 = v23 - __p.n128_u64[0];
        }
        if (v23 - __p.n128_u64[0] >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v18 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v18 = v17;
        }
        if (v18)
        {
          __int16 v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MIL::Fp16>>((uint64_t)&v23, v18);
          unint64_t v12 = __p.n128_u64[1];
          unint64_t v14 = (void *)__p.n128_u64[0];
        }
        else
        {
          __int16 v19 = 0;
        }
        char v20 = &v19[2 * v16];
        *(_WORD *)char v20 = v11;
        unint64_t v13 = (unint64_t)(v20 + 2);
        while ((void *)v12 != v14)
        {
          __int16 v21 = *(_WORD *)(v12 - 2);
          v12 -= 2;
          *((_WORD *)v20 - 1) = v21;
          v20 -= 2;
        }
        __p.n128_u64[0] = (unint64_t)v20;
        __p.n128_u64[1] = v13;
        unint64_t v23 = (unint64_t)&v19[2 * v18];
        if (v14) {
          operator delete(v14);
        }
      }
      else
      {
        *(_WORD *)__p.n128_u64[1] = v10;
        unint64_t v13 = v12 + 2;
      }
      __p.n128_u64[1] = v13;
      ++v7;
      uint64_t v6 = a1[4];
    }
    while (v7 < (a1[5] - v6) >> 1);
  }
  MIL::ValueInference::Tensor<MIL::Bf16>::Tensor(a2, &v24, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v24.n128_u64[0])
  {
    v24.n128_u64[1] = v24.n128_u64[0];
    operator delete((void *)v24.n128_u64[0]);
  }
}

void sub_20F4D74F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<float>::Cast<MIL::Bf16>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v22 = 0;
  __n128 v21 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v21, v4, v5, (v5 - (uint64_t)v4) >> 3);
  __n128 __p = 0uLL;
  unint64_t v20 = 0;
  std::vector<MIL::Fp16>::reserve((void **)&__p, (uint64_t)(a1[5] - a1[4]) >> 2);
  uint64_t v7 = a1[4];
  if (a1[5] != v7)
  {
    unint64_t v8 = 0;
    do
    {
      uint64_t v6 = (MIL::Bf16 *)MIL::Bf16::FromFloat(v6, *(float *)(v7 + 4 * v8));
      __int16 v9 = (__int16)v6;
      unint64_t v10 = __p.n128_u64[1];
      if (__p.n128_u64[1] >= v20)
      {
        uint64_t v6 = (MIL::Bf16 *)__p.n128_u64[0];
        int64_t v12 = __p.n128_u64[1] - __p.n128_u64[0];
        if ((uint64_t)(__p.n128_u64[1] - __p.n128_u64[0]) <= -3) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v13 = v12 >> 1;
        if (v20 - __p.n128_u64[0] <= (v12 >> 1) + 1) {
          uint64_t v14 = v13 + 1;
        }
        else {
          uint64_t v14 = v20 - __p.n128_u64[0];
        }
        if (v20 - __p.n128_u64[0] >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v15 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v15 = v14;
        }
        if (v15)
        {
          uint64_t v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MIL::Fp16>>((uint64_t)&v20, v15);
          unint64_t v10 = __p.n128_u64[1];
          uint64_t v6 = (MIL::Bf16 *)__p.n128_u64[0];
        }
        else
        {
          uint64_t v16 = 0;
        }
        uint64_t v17 = &v16[2 * v13];
        *(_WORD *)uint64_t v17 = v9;
        unint64_t v11 = (unint64_t)(v17 + 2);
        while ((MIL::Bf16 *)v10 != v6)
        {
          __int16 v18 = *(_WORD *)(v10 - 2);
          v10 -= 2;
          *((_WORD *)v17 - 1) = v18;
          v17 -= 2;
        }
        __p.n128_u64[0] = (unint64_t)v17;
        __p.n128_u64[1] = v11;
        unint64_t v20 = (unint64_t)&v16[2 * v15];
        if (v6) {
          operator delete(v6);
        }
      }
      else
      {
        *(_WORD *)__p.n128_u64[1] = (_WORD)v6;
        unint64_t v11 = v10 + 2;
      }
      __p.n128_u64[1] = v11;
      ++v8;
      uint64_t v7 = a1[4];
    }
    while (v8 < (a1[5] - v7) >> 2);
  }
  MIL::ValueInference::Tensor<MIL::Bf16>::Tensor(a2, &v21, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v21.n128_u64[0])
  {
    v21.n128_u64[1] = v21.n128_u64[0];
    operator delete((void *)v21.n128_u64[0]);
  }
}

void sub_20F4D76B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<int>::Cast<MIL::Bf16>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v22 = 0;
  __n128 v21 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v21, v4, v5, (v5 - (uint64_t)v4) >> 3);
  __n128 __p = 0uLL;
  unint64_t v20 = 0;
  std::vector<MIL::Fp16>::reserve((void **)&__p, (uint64_t)(a1[5] - a1[4]) >> 2);
  uint64_t v7 = a1[4];
  if (a1[5] != v7)
  {
    unint64_t v8 = 0;
    do
    {
      uint64_t v6 = (MIL::Bf16 *)MIL::Bf16::FromFloat(v6, (float)*(int *)(v7 + 4 * v8));
      __int16 v9 = (__int16)v6;
      unint64_t v10 = __p.n128_u64[1];
      if (__p.n128_u64[1] >= v20)
      {
        uint64_t v6 = (MIL::Bf16 *)__p.n128_u64[0];
        int64_t v12 = __p.n128_u64[1] - __p.n128_u64[0];
        if ((uint64_t)(__p.n128_u64[1] - __p.n128_u64[0]) <= -3) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v13 = v12 >> 1;
        if (v20 - __p.n128_u64[0] <= (v12 >> 1) + 1) {
          uint64_t v14 = v13 + 1;
        }
        else {
          uint64_t v14 = v20 - __p.n128_u64[0];
        }
        if (v20 - __p.n128_u64[0] >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v15 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v15 = v14;
        }
        if (v15)
        {
          uint64_t v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MIL::Fp16>>((uint64_t)&v20, v15);
          unint64_t v10 = __p.n128_u64[1];
          uint64_t v6 = (MIL::Bf16 *)__p.n128_u64[0];
        }
        else
        {
          uint64_t v16 = 0;
        }
        uint64_t v17 = &v16[2 * v13];
        *(_WORD *)uint64_t v17 = v9;
        unint64_t v11 = (unint64_t)(v17 + 2);
        while ((MIL::Bf16 *)v10 != v6)
        {
          __int16 v18 = *(_WORD *)(v10 - 2);
          v10 -= 2;
          *((_WORD *)v17 - 1) = v18;
          v17 -= 2;
        }
        __p.n128_u64[0] = (unint64_t)v17;
        __p.n128_u64[1] = v11;
        unint64_t v20 = (unint64_t)&v16[2 * v15];
        if (v6) {
          operator delete(v6);
        }
      }
      else
      {
        *(_WORD *)__p.n128_u64[1] = (_WORD)v6;
        unint64_t v11 = v10 + 2;
      }
      __p.n128_u64[1] = v11;
      ++v8;
      uint64_t v7 = a1[4];
    }
    while (v8 < (a1[5] - v7) >> 2);
  }
  MIL::ValueInference::Tensor<MIL::Bf16>::Tensor(a2, &v21, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v21.n128_u64[0])
  {
    v21.n128_u64[1] = v21.n128_u64[0];
    operator delete((void *)v21.n128_u64[0]);
  }
}

void sub_20F4D7880(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<short>::Cast<MIL::Bf16>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v22 = 0;
  __n128 v21 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v21, v4, v5, (v5 - (uint64_t)v4) >> 3);
  __n128 __p = 0uLL;
  unint64_t v20 = 0;
  std::vector<MIL::Fp16>::reserve((void **)&__p, (uint64_t)(a1[5] - a1[4]) >> 1);
  uint64_t v7 = a1[4];
  if (a1[5] != v7)
  {
    unint64_t v8 = 0;
    do
    {
      uint64_t v6 = (MIL::Bf16 *)MIL::Bf16::FromFloat(v6, (float)*(__int16 *)(v7 + 2 * v8));
      __int16 v9 = (__int16)v6;
      unint64_t v10 = __p.n128_u64[1];
      if (__p.n128_u64[1] >= v20)
      {
        uint64_t v6 = (MIL::Bf16 *)__p.n128_u64[0];
        int64_t v12 = __p.n128_u64[1] - __p.n128_u64[0];
        if ((uint64_t)(__p.n128_u64[1] - __p.n128_u64[0]) <= -3) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v13 = v12 >> 1;
        if (v20 - __p.n128_u64[0] <= (v12 >> 1) + 1) {
          uint64_t v14 = v13 + 1;
        }
        else {
          uint64_t v14 = v20 - __p.n128_u64[0];
        }
        if (v20 - __p.n128_u64[0] >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v15 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v15 = v14;
        }
        if (v15)
        {
          uint64_t v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MIL::Fp16>>((uint64_t)&v20, v15);
          unint64_t v10 = __p.n128_u64[1];
          uint64_t v6 = (MIL::Bf16 *)__p.n128_u64[0];
        }
        else
        {
          uint64_t v16 = 0;
        }
        uint64_t v17 = &v16[2 * v13];
        *(_WORD *)uint64_t v17 = v9;
        unint64_t v11 = (unint64_t)(v17 + 2);
        while ((MIL::Bf16 *)v10 != v6)
        {
          __int16 v18 = *(_WORD *)(v10 - 2);
          v10 -= 2;
          *((_WORD *)v17 - 1) = v18;
          v17 -= 2;
        }
        __p.n128_u64[0] = (unint64_t)v17;
        __p.n128_u64[1] = v11;
        unint64_t v20 = (unint64_t)&v16[2 * v15];
        if (v6) {
          operator delete(v6);
        }
      }
      else
      {
        *(_WORD *)__p.n128_u64[1] = (_WORD)v6;
        unint64_t v11 = v10 + 2;
      }
      __p.n128_u64[1] = v11;
      ++v8;
      uint64_t v7 = a1[4];
    }
    while (v8 < (a1[5] - v7) >> 1);
  }
  MIL::ValueInference::Tensor<MIL::Bf16>::Tensor(a2, &v21, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v21.n128_u64[0])
  {
    v21.n128_u64[1] = v21.n128_u64[0];
    operator delete((void *)v21.n128_u64[0]);
  }
}

void sub_20F4D7A48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<unsigned short>::Cast<MIL::Bf16>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v23 = 0;
  __n128 v22 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v22, v4, v5, (v5 - (uint64_t)v4) >> 3);
  __n128 __p = 0uLL;
  unint64_t v21 = 0;
  std::vector<MIL::Fp16>::reserve((void **)&__p, (uint64_t)(a1[5] - a1[4]) >> 1);
  uint64_t v8 = a1[4];
  if (a1[5] != v8)
  {
    unint64_t v9 = 0;
    do
    {
      LOWORD(v7) = *(_WORD *)(v8 + 2 * v9);
      uint64_t v6 = (MIL::Bf16 *)MIL::Bf16::FromFloat(v6, (float)v7);
      __int16 v10 = (__int16)v6;
      unint64_t v11 = __p.n128_u64[1];
      if (__p.n128_u64[1] >= v21)
      {
        uint64_t v6 = (MIL::Bf16 *)__p.n128_u64[0];
        int64_t v13 = __p.n128_u64[1] - __p.n128_u64[0];
        if ((uint64_t)(__p.n128_u64[1] - __p.n128_u64[0]) <= -3) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v14 = v13 >> 1;
        if (v21 - __p.n128_u64[0] <= (v13 >> 1) + 1) {
          uint64_t v15 = v14 + 1;
        }
        else {
          uint64_t v15 = v21 - __p.n128_u64[0];
        }
        if (v21 - __p.n128_u64[0] >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v16 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v16 = v15;
        }
        if (v16)
        {
          uint64_t v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MIL::Fp16>>((uint64_t)&v21, v16);
          unint64_t v11 = __p.n128_u64[1];
          uint64_t v6 = (MIL::Bf16 *)__p.n128_u64[0];
        }
        else
        {
          uint64_t v17 = 0;
        }
        __int16 v18 = &v17[2 * v14];
        *(_WORD *)__int16 v18 = v10;
        unint64_t v12 = (unint64_t)(v18 + 2);
        while ((MIL::Bf16 *)v11 != v6)
        {
          __int16 v19 = *(_WORD *)(v11 - 2);
          v11 -= 2;
          *((_WORD *)v18 - 1) = v19;
          v18 -= 2;
        }
        __p.n128_u64[0] = (unint64_t)v18;
        __p.n128_u64[1] = v12;
        unint64_t v21 = (unint64_t)&v17[2 * v16];
        if (v6) {
          operator delete(v6);
        }
      }
      else
      {
        *(_WORD *)__p.n128_u64[1] = (_WORD)v6;
        unint64_t v12 = v11 + 2;
      }
      __p.n128_u64[1] = v12;
      ++v9;
      uint64_t v8 = a1[4];
    }
    while (v9 < (a1[5] - v8) >> 1);
  }
  MIL::ValueInference::Tensor<MIL::Bf16>::Tensor(a2, &v22, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v22.n128_u64[0])
  {
    v22.n128_u64[1] = v22.n128_u64[0];
    operator delete((void *)v22.n128_u64[0]);
  }
}

void sub_20F4D7C10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<signed char>::Cast<MIL::Bf16>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v22 = 0;
  __n128 v21 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v21, v4, v5, (v5 - (uint64_t)v4) >> 3);
  __n128 __p = 0uLL;
  unint64_t v20 = 0;
  std::vector<MIL::Fp16>::reserve((void **)&__p, a1[5] - a1[4]);
  uint64_t v7 = a1[4];
  if (a1[5] != v7)
  {
    unint64_t v8 = 0;
    do
    {
      uint64_t v6 = (MIL::Bf16 *)MIL::Bf16::FromFloat(v6, (float)*(char *)(v7 + v8));
      __int16 v9 = (__int16)v6;
      unint64_t v10 = __p.n128_u64[1];
      if (__p.n128_u64[1] >= v20)
      {
        uint64_t v6 = (MIL::Bf16 *)__p.n128_u64[0];
        int64_t v12 = __p.n128_u64[1] - __p.n128_u64[0];
        if ((uint64_t)(__p.n128_u64[1] - __p.n128_u64[0]) <= -3) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v13 = v12 >> 1;
        if (v20 - __p.n128_u64[0] <= (v12 >> 1) + 1) {
          uint64_t v14 = v13 + 1;
        }
        else {
          uint64_t v14 = v20 - __p.n128_u64[0];
        }
        if (v20 - __p.n128_u64[0] >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v15 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v15 = v14;
        }
        if (v15)
        {
          uint64_t v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MIL::Fp16>>((uint64_t)&v20, v15);
          unint64_t v10 = __p.n128_u64[1];
          uint64_t v6 = (MIL::Bf16 *)__p.n128_u64[0];
        }
        else
        {
          uint64_t v16 = 0;
        }
        uint64_t v17 = &v16[2 * v13];
        *(_WORD *)uint64_t v17 = v9;
        unint64_t v11 = (unint64_t)(v17 + 2);
        while ((MIL::Bf16 *)v10 != v6)
        {
          __int16 v18 = *(_WORD *)(v10 - 2);
          v10 -= 2;
          *((_WORD *)v17 - 1) = v18;
          v17 -= 2;
        }
        __p.n128_u64[0] = (unint64_t)v17;
        __p.n128_u64[1] = v11;
        unint64_t v20 = (unint64_t)&v16[2 * v15];
        if (v6) {
          operator delete(v6);
        }
      }
      else
      {
        *(_WORD *)__p.n128_u64[1] = (_WORD)v6;
        unint64_t v11 = v10 + 2;
      }
      __p.n128_u64[1] = v11;
      ++v8;
      uint64_t v7 = a1[4];
    }
    while (v8 < a1[5] - v7);
  }
  MIL::ValueInference::Tensor<MIL::Bf16>::Tensor(a2, &v21, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v21.n128_u64[0])
  {
    v21.n128_u64[1] = v21.n128_u64[0];
    operator delete((void *)v21.n128_u64[0]);
  }
}

void sub_20F4D7DD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<unsigned char>::Cast<MIL::Bf16>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v23 = 0;
  __n128 v22 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v22, v4, v5, (v5 - (uint64_t)v4) >> 3);
  __n128 __p = 0uLL;
  unint64_t v21 = 0;
  std::vector<MIL::Fp16>::reserve((void **)&__p, a1[5] - a1[4]);
  uint64_t v8 = a1[4];
  if (a1[5] != v8)
  {
    unint64_t v9 = 0;
    do
    {
      LOBYTE(v7) = *(unsigned char *)(v8 + v9);
      uint64_t v6 = (MIL::Bf16 *)MIL::Bf16::FromFloat(v6, (float)v7);
      __int16 v10 = (__int16)v6;
      unint64_t v11 = __p.n128_u64[1];
      if (__p.n128_u64[1] >= v21)
      {
        uint64_t v6 = (MIL::Bf16 *)__p.n128_u64[0];
        int64_t v13 = __p.n128_u64[1] - __p.n128_u64[0];
        if ((uint64_t)(__p.n128_u64[1] - __p.n128_u64[0]) <= -3) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v14 = v13 >> 1;
        if (v21 - __p.n128_u64[0] <= (v13 >> 1) + 1) {
          uint64_t v15 = v14 + 1;
        }
        else {
          uint64_t v15 = v21 - __p.n128_u64[0];
        }
        if (v21 - __p.n128_u64[0] >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v16 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v16 = v15;
        }
        if (v16)
        {
          uint64_t v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MIL::Fp16>>((uint64_t)&v21, v16);
          unint64_t v11 = __p.n128_u64[1];
          uint64_t v6 = (MIL::Bf16 *)__p.n128_u64[0];
        }
        else
        {
          uint64_t v17 = 0;
        }
        __int16 v18 = &v17[2 * v14];
        *(_WORD *)__int16 v18 = v10;
        unint64_t v12 = (unint64_t)(v18 + 2);
        while ((MIL::Bf16 *)v11 != v6)
        {
          __int16 v19 = *(_WORD *)(v11 - 2);
          v11 -= 2;
          *((_WORD *)v18 - 1) = v19;
          v18 -= 2;
        }
        __p.n128_u64[0] = (unint64_t)v18;
        __p.n128_u64[1] = v12;
        unint64_t v21 = (unint64_t)&v17[2 * v16];
        if (v6) {
          operator delete(v6);
        }
      }
      else
      {
        *(_WORD *)__p.n128_u64[1] = (_WORD)v6;
        unint64_t v12 = v11 + 2;
      }
      __p.n128_u64[1] = v12;
      ++v9;
      uint64_t v8 = a1[4];
    }
    while (v9 < a1[5] - v8);
  }
  MIL::ValueInference::Tensor<MIL::Bf16>::Tensor(a2, &v22, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v22.n128_u64[0])
  {
    v22.n128_u64[1] = v22.n128_u64[0];
    operator delete((void *)v22.n128_u64[0]);
  }
}

void sub_20F4D7F98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<BOOL>::Cast<MIL::Bf16>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v23 = 0;
  __n128 v22 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v22, v4, v5, (v5 - (uint64_t)v4) >> 3);
  __n128 __p = 0uLL;
  unint64_t v21 = 0;
  std::vector<MIL::Fp16>::reserve((void **)&__p, a1[5] - a1[4]);
  uint64_t v8 = a1[4];
  if (a1[5] != v8)
  {
    unint64_t v9 = 0;
    do
    {
      LOBYTE(v7) = *(unsigned char *)(v8 + v9);
      uint64_t v6 = (MIL::Bf16 *)MIL::Bf16::FromFloat(v6, (float)v7);
      __int16 v10 = (__int16)v6;
      unint64_t v11 = __p.n128_u64[1];
      if (__p.n128_u64[1] >= v21)
      {
        uint64_t v6 = (MIL::Bf16 *)__p.n128_u64[0];
        int64_t v13 = __p.n128_u64[1] - __p.n128_u64[0];
        if ((uint64_t)(__p.n128_u64[1] - __p.n128_u64[0]) <= -3) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v14 = v13 >> 1;
        if (v21 - __p.n128_u64[0] <= (v13 >> 1) + 1) {
          uint64_t v15 = v14 + 1;
        }
        else {
          uint64_t v15 = v21 - __p.n128_u64[0];
        }
        if (v21 - __p.n128_u64[0] >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v16 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v16 = v15;
        }
        if (v16)
        {
          uint64_t v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MIL::Fp16>>((uint64_t)&v21, v16);
          unint64_t v11 = __p.n128_u64[1];
          uint64_t v6 = (MIL::Bf16 *)__p.n128_u64[0];
        }
        else
        {
          uint64_t v17 = 0;
        }
        __int16 v18 = &v17[2 * v14];
        *(_WORD *)__int16 v18 = v10;
        unint64_t v12 = (unint64_t)(v18 + 2);
        while ((MIL::Bf16 *)v11 != v6)
        {
          __int16 v19 = *(_WORD *)(v11 - 2);
          v11 -= 2;
          *((_WORD *)v18 - 1) = v19;
          v18 -= 2;
        }
        __p.n128_u64[0] = (unint64_t)v18;
        __p.n128_u64[1] = v12;
        unint64_t v21 = (unint64_t)&v17[2 * v16];
        if (v6) {
          operator delete(v6);
        }
      }
      else
      {
        *(_WORD *)__p.n128_u64[1] = (_WORD)v6;
        unint64_t v12 = v11 + 2;
      }
      __p.n128_u64[1] = v12;
      ++v9;
      uint64_t v8 = a1[4];
    }
    while (v9 < a1[5] - v8);
  }
  MIL::ValueInference::Tensor<MIL::Bf16>::Tensor(a2, &v22, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v22.n128_u64[0])
  {
    v22.n128_u64[1] = v22.n128_u64[0];
    operator delete((void *)v22.n128_u64[0]);
  }
}

void sub_20F4D815C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<MIL::Fp16>::Cast<BOOL>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v24 = 0;
  __n128 v23 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v23, v4, v5, (v5 - (uint64_t)v4) >> 3);
  __n128 __p = 0uLL;
  unint64_t v22 = 0;
  std::vector<unsigned char>::reserve(__p.n128_u64, (uint64_t)(a1[5] - a1[4]) >> 1);
  uint64_t v6 = a1[4];
  if (a1[5] != v6)
  {
    unint64_t v7 = 0;
    do
    {
      BOOL v8 = MIL::Fp16::GetFloat((MIL::Fp16 *)(v6 + 2 * v7)) != 0.0;
      unint64_t v9 = (char *)__p.n128_u64[1];
      if (__p.n128_u64[1] >= v22)
      {
        unint64_t v11 = __p.n128_u64[0];
        unint64_t v12 = __p.n128_u64[1] - __p.n128_u64[0];
        int64_t v13 = __p.n128_u64[1] - __p.n128_u64[0] + 1;
        if (v13 < 0) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v14 = v22 - __p.n128_u64[0];
        if (2 * (v22 - __p.n128_u64[0]) > v13) {
          int64_t v13 = 2 * v14;
        }
        if (v14 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v15 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v15 = v13;
        }
        if (v15) {
          unint64_t v16 = (unint64_t)operator new(v15);
        }
        else {
          unint64_t v16 = 0;
        }
        unint64_t v17 = v16 + v12;
        __int16 v18 = (BOOL *)(v16 + v12);
        BOOL *v18 = v8;
        unint64_t v10 = (unint64_t)(v18 + 1);
        if (v9 != (char *)v11)
        {
          __int16 v19 = &v9[~v11];
          do
          {
            char v20 = *--v9;
            (v19--)[v16] = v20;
          }
          while (v9 != (char *)v11);
          unint64_t v9 = (char *)__p.n128_u64[0];
          unint64_t v17 = v16;
        }
        __p.n128_u64[0] = v17;
        __p.n128_u64[1] = v10;
        unint64_t v22 = v16 + v15;
        if (v9) {
          operator delete(v9);
        }
      }
      else
      {
        *(unsigned char *)__p.n128_u64[1] = v8;
        unint64_t v10 = (unint64_t)(v9 + 1);
      }
      __p.n128_u64[1] = v10;
      ++v7;
      uint64_t v6 = a1[4];
    }
    while (v7 < (a1[5] - v6) >> 1);
  }
  MIL::ValueInference::Tensor<BOOL>::Tensor(a2, &v23, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v23.n128_u64[0])
  {
    v23.n128_u64[1] = v23.n128_u64[0];
    operator delete((void *)v23.n128_u64[0]);
  }
}

void sub_20F4D8334(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<MIL::Bf16>::Cast<MIL::Fp16>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v25 = 0;
  __n128 v24 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v24, v4, v5, (v5 - (uint64_t)v4) >> 3);
  __n128 __p = 0uLL;
  unint64_t v23 = 0;
  std::vector<MIL::Fp16>::reserve((void **)&__p, (uint64_t)(a1[5] - a1[4]) >> 1);
  uint64_t v6 = a1[4];
  if (a1[5] != v6)
  {
    unint64_t v7 = 0;
    do
    {
      float Float = MIL::Bf16::GetFloat((MIL::Bf16 *)(v6 + 2 * v7));
      __int16 v10 = MIL::Fp16::FromFloat(v9, Float);
      __int16 v11 = v10;
      unint64_t v12 = __p.n128_u64[1];
      if (__p.n128_u64[1] >= v23)
      {
        unint64_t v14 = (void *)__p.n128_u64[0];
        int64_t v15 = __p.n128_u64[1] - __p.n128_u64[0];
        if ((uint64_t)(__p.n128_u64[1] - __p.n128_u64[0]) <= -3) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v16 = v15 >> 1;
        if (v23 - __p.n128_u64[0] <= (v15 >> 1) + 1) {
          uint64_t v17 = v16 + 1;
        }
        else {
          uint64_t v17 = v23 - __p.n128_u64[0];
        }
        if (v23 - __p.n128_u64[0] >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v18 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v18 = v17;
        }
        if (v18)
        {
          __int16 v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MIL::Fp16>>((uint64_t)&v23, v18);
          unint64_t v12 = __p.n128_u64[1];
          unint64_t v14 = (void *)__p.n128_u64[0];
        }
        else
        {
          __int16 v19 = 0;
        }
        char v20 = &v19[2 * v16];
        *(_WORD *)char v20 = v11;
        unint64_t v13 = (unint64_t)(v20 + 2);
        while ((void *)v12 != v14)
        {
          __int16 v21 = *(_WORD *)(v12 - 2);
          v12 -= 2;
          *((_WORD *)v20 - 1) = v21;
          v20 -= 2;
        }
        __p.n128_u64[0] = (unint64_t)v20;
        __p.n128_u64[1] = v13;
        unint64_t v23 = (unint64_t)&v19[2 * v18];
        if (v14) {
          operator delete(v14);
        }
      }
      else
      {
        *(_WORD *)__p.n128_u64[1] = v10;
        unint64_t v13 = v12 + 2;
      }
      __p.n128_u64[1] = v13;
      ++v7;
      uint64_t v6 = a1[4];
    }
    while (v7 < (a1[5] - v6) >> 1);
  }
  MIL::ValueInference::Tensor<MIL::Fp16>::Tensor(a2, &v24, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v24.n128_u64[0])
  {
    v24.n128_u64[1] = v24.n128_u64[0];
    operator delete((void *)v24.n128_u64[0]);
  }
}

void sub_20F4D84FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<MIL::Fp16>::Cast<MIL::Fp16>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v11 = 0;
  __n128 v10 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v10, v4, v5, (v5 - (uint64_t)v4) >> 3);
  uint64_t v6 = (const void *)a1[4];
  uint64_t v7 = a1[5];
  uint64_t v9 = 0;
  __n128 __p = 0uLL;
  std::vector<MIL::Fp16>::__init_with_size[abi:ne180100]<std::__wrap_iter<MIL::Fp16 const*>,std::__wrap_iter<MIL::Fp16 const*>>(&__p, v6, v7, (v7 - (uint64_t)v6) >> 1);
  MIL::ValueInference::Tensor<MIL::Fp16>::Tensor(a2, &v10, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v10.n128_u64[0])
  {
    v10.n128_u64[1] = v10.n128_u64[0];
    operator delete((void *)v10.n128_u64[0]);
  }
}

void sub_20F4D85C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<float>::Cast<MIL::Fp16>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v22 = 0;
  __n128 v21 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v21, v4, v5, (v5 - (uint64_t)v4) >> 3);
  __n128 __p = 0uLL;
  unint64_t v20 = 0;
  std::vector<MIL::Fp16>::reserve((void **)&__p, (uint64_t)(a1[5] - a1[4]) >> 2);
  uint64_t v7 = a1[4];
  if (a1[5] != v7)
  {
    unint64_t v8 = 0;
    do
    {
      uint64_t v6 = (MIL::Fp16 *)MIL::Fp16::FromFloat(v6, *(float *)(v7 + 4 * v8));
      __int16 v9 = (__int16)v6;
      unint64_t v10 = __p.n128_u64[1];
      if (__p.n128_u64[1] >= v20)
      {
        uint64_t v6 = (MIL::Fp16 *)__p.n128_u64[0];
        int64_t v12 = __p.n128_u64[1] - __p.n128_u64[0];
        if ((uint64_t)(__p.n128_u64[1] - __p.n128_u64[0]) <= -3) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v13 = v12 >> 1;
        if (v20 - __p.n128_u64[0] <= (v12 >> 1) + 1) {
          uint64_t v14 = v13 + 1;
        }
        else {
          uint64_t v14 = v20 - __p.n128_u64[0];
        }
        if (v20 - __p.n128_u64[0] >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v15 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v15 = v14;
        }
        if (v15)
        {
          uint64_t v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MIL::Fp16>>((uint64_t)&v20, v15);
          unint64_t v10 = __p.n128_u64[1];
          uint64_t v6 = (MIL::Fp16 *)__p.n128_u64[0];
        }
        else
        {
          uint64_t v16 = 0;
        }
        uint64_t v17 = &v16[2 * v13];
        *(_WORD *)uint64_t v17 = v9;
        unint64_t v11 = (unint64_t)(v17 + 2);
        while ((MIL::Fp16 *)v10 != v6)
        {
          __int16 v18 = *(_WORD *)(v10 - 2);
          v10 -= 2;
          *((_WORD *)v17 - 1) = v18;
          v17 -= 2;
        }
        __p.n128_u64[0] = (unint64_t)v17;
        __p.n128_u64[1] = v11;
        unint64_t v20 = (unint64_t)&v16[2 * v15];
        if (v6) {
          operator delete(v6);
        }
      }
      else
      {
        *(_WORD *)__p.n128_u64[1] = (_WORD)v6;
        unint64_t v11 = v10 + 2;
      }
      __p.n128_u64[1] = v11;
      ++v8;
      uint64_t v7 = a1[4];
    }
    while (v8 < (a1[5] - v7) >> 2);
  }
  MIL::ValueInference::Tensor<MIL::Fp16>::Tensor(a2, &v21, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v21.n128_u64[0])
  {
    v21.n128_u64[1] = v21.n128_u64[0];
    operator delete((void *)v21.n128_u64[0]);
  }
}

void sub_20F4D8788(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<int>::Cast<MIL::Fp16>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v22 = 0;
  __n128 v21 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v21, v4, v5, (v5 - (uint64_t)v4) >> 3);
  __n128 __p = 0uLL;
  unint64_t v20 = 0;
  std::vector<MIL::Fp16>::reserve((void **)&__p, (uint64_t)(a1[5] - a1[4]) >> 2);
  uint64_t v7 = a1[4];
  if (a1[5] != v7)
  {
    unint64_t v8 = 0;
    do
    {
      uint64_t v6 = (MIL::Fp16 *)MIL::Fp16::FromFloat(v6, (float)*(int *)(v7 + 4 * v8));
      __int16 v9 = (__int16)v6;
      unint64_t v10 = __p.n128_u64[1];
      if (__p.n128_u64[1] >= v20)
      {
        uint64_t v6 = (MIL::Fp16 *)__p.n128_u64[0];
        int64_t v12 = __p.n128_u64[1] - __p.n128_u64[0];
        if ((uint64_t)(__p.n128_u64[1] - __p.n128_u64[0]) <= -3) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v13 = v12 >> 1;
        if (v20 - __p.n128_u64[0] <= (v12 >> 1) + 1) {
          uint64_t v14 = v13 + 1;
        }
        else {
          uint64_t v14 = v20 - __p.n128_u64[0];
        }
        if (v20 - __p.n128_u64[0] >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v15 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v15 = v14;
        }
        if (v15)
        {
          uint64_t v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MIL::Fp16>>((uint64_t)&v20, v15);
          unint64_t v10 = __p.n128_u64[1];
          uint64_t v6 = (MIL::Fp16 *)__p.n128_u64[0];
        }
        else
        {
          uint64_t v16 = 0;
        }
        uint64_t v17 = &v16[2 * v13];
        *(_WORD *)uint64_t v17 = v9;
        unint64_t v11 = (unint64_t)(v17 + 2);
        while ((MIL::Fp16 *)v10 != v6)
        {
          __int16 v18 = *(_WORD *)(v10 - 2);
          v10 -= 2;
          *((_WORD *)v17 - 1) = v18;
          v17 -= 2;
        }
        __p.n128_u64[0] = (unint64_t)v17;
        __p.n128_u64[1] = v11;
        unint64_t v20 = (unint64_t)&v16[2 * v15];
        if (v6) {
          operator delete(v6);
        }
      }
      else
      {
        *(_WORD *)__p.n128_u64[1] = (_WORD)v6;
        unint64_t v11 = v10 + 2;
      }
      __p.n128_u64[1] = v11;
      ++v8;
      uint64_t v7 = a1[4];
    }
    while (v8 < (a1[5] - v7) >> 2);
  }
  MIL::ValueInference::Tensor<MIL::Fp16>::Tensor(a2, &v21, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v21.n128_u64[0])
  {
    v21.n128_u64[1] = v21.n128_u64[0];
    operator delete((void *)v21.n128_u64[0]);
  }
}

void sub_20F4D8950(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<short>::Cast<MIL::Fp16>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v22 = 0;
  __n128 v21 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v21, v4, v5, (v5 - (uint64_t)v4) >> 3);
  __n128 __p = 0uLL;
  unint64_t v20 = 0;
  std::vector<MIL::Fp16>::reserve((void **)&__p, (uint64_t)(a1[5] - a1[4]) >> 1);
  uint64_t v7 = a1[4];
  if (a1[5] != v7)
  {
    unint64_t v8 = 0;
    do
    {
      uint64_t v6 = (MIL::Fp16 *)MIL::Fp16::FromFloat(v6, (float)*(__int16 *)(v7 + 2 * v8));
      __int16 v9 = (__int16)v6;
      unint64_t v10 = __p.n128_u64[1];
      if (__p.n128_u64[1] >= v20)
      {
        uint64_t v6 = (MIL::Fp16 *)__p.n128_u64[0];
        int64_t v12 = __p.n128_u64[1] - __p.n128_u64[0];
        if ((uint64_t)(__p.n128_u64[1] - __p.n128_u64[0]) <= -3) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v13 = v12 >> 1;
        if (v20 - __p.n128_u64[0] <= (v12 >> 1) + 1) {
          uint64_t v14 = v13 + 1;
        }
        else {
          uint64_t v14 = v20 - __p.n128_u64[0];
        }
        if (v20 - __p.n128_u64[0] >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v15 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v15 = v14;
        }
        if (v15)
        {
          uint64_t v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MIL::Fp16>>((uint64_t)&v20, v15);
          unint64_t v10 = __p.n128_u64[1];
          uint64_t v6 = (MIL::Fp16 *)__p.n128_u64[0];
        }
        else
        {
          uint64_t v16 = 0;
        }
        uint64_t v17 = &v16[2 * v13];
        *(_WORD *)uint64_t v17 = v9;
        unint64_t v11 = (unint64_t)(v17 + 2);
        while ((MIL::Fp16 *)v10 != v6)
        {
          __int16 v18 = *(_WORD *)(v10 - 2);
          v10 -= 2;
          *((_WORD *)v17 - 1) = v18;
          v17 -= 2;
        }
        __p.n128_u64[0] = (unint64_t)v17;
        __p.n128_u64[1] = v11;
        unint64_t v20 = (unint64_t)&v16[2 * v15];
        if (v6) {
          operator delete(v6);
        }
      }
      else
      {
        *(_WORD *)__p.n128_u64[1] = (_WORD)v6;
        unint64_t v11 = v10 + 2;
      }
      __p.n128_u64[1] = v11;
      ++v8;
      uint64_t v7 = a1[4];
    }
    while (v8 < (a1[5] - v7) >> 1);
  }
  MIL::ValueInference::Tensor<MIL::Fp16>::Tensor(a2, &v21, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v21.n128_u64[0])
  {
    v21.n128_u64[1] = v21.n128_u64[0];
    operator delete((void *)v21.n128_u64[0]);
  }
}

void sub_20F4D8B18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<unsigned short>::Cast<MIL::Fp16>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v23 = 0;
  __n128 v22 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v22, v4, v5, (v5 - (uint64_t)v4) >> 3);
  __n128 __p = 0uLL;
  unint64_t v21 = 0;
  std::vector<MIL::Fp16>::reserve((void **)&__p, (uint64_t)(a1[5] - a1[4]) >> 1);
  uint64_t v8 = a1[4];
  if (a1[5] != v8)
  {
    unint64_t v9 = 0;
    do
    {
      LOWORD(v7) = *(_WORD *)(v8 + 2 * v9);
      uint64_t v6 = (MIL::Fp16 *)MIL::Fp16::FromFloat(v6, (float)v7);
      __int16 v10 = (__int16)v6;
      unint64_t v11 = __p.n128_u64[1];
      if (__p.n128_u64[1] >= v21)
      {
        uint64_t v6 = (MIL::Fp16 *)__p.n128_u64[0];
        int64_t v13 = __p.n128_u64[1] - __p.n128_u64[0];
        if ((uint64_t)(__p.n128_u64[1] - __p.n128_u64[0]) <= -3) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v14 = v13 >> 1;
        if (v21 - __p.n128_u64[0] <= (v13 >> 1) + 1) {
          uint64_t v15 = v14 + 1;
        }
        else {
          uint64_t v15 = v21 - __p.n128_u64[0];
        }
        if (v21 - __p.n128_u64[0] >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v16 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v16 = v15;
        }
        if (v16)
        {
          uint64_t v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MIL::Fp16>>((uint64_t)&v21, v16);
          unint64_t v11 = __p.n128_u64[1];
          uint64_t v6 = (MIL::Fp16 *)__p.n128_u64[0];
        }
        else
        {
          uint64_t v17 = 0;
        }
        __int16 v18 = &v17[2 * v14];
        *(_WORD *)__int16 v18 = v10;
        unint64_t v12 = (unint64_t)(v18 + 2);
        while ((MIL::Fp16 *)v11 != v6)
        {
          __int16 v19 = *(_WORD *)(v11 - 2);
          v11 -= 2;
          *((_WORD *)v18 - 1) = v19;
          v18 -= 2;
        }
        __p.n128_u64[0] = (unint64_t)v18;
        __p.n128_u64[1] = v12;
        unint64_t v21 = (unint64_t)&v17[2 * v16];
        if (v6) {
          operator delete(v6);
        }
      }
      else
      {
        *(_WORD *)__p.n128_u64[1] = (_WORD)v6;
        unint64_t v12 = v11 + 2;
      }
      __p.n128_u64[1] = v12;
      ++v9;
      uint64_t v8 = a1[4];
    }
    while (v9 < (a1[5] - v8) >> 1);
  }
  MIL::ValueInference::Tensor<MIL::Fp16>::Tensor(a2, &v22, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v22.n128_u64[0])
  {
    v22.n128_u64[1] = v22.n128_u64[0];
    operator delete((void *)v22.n128_u64[0]);
  }
}

void sub_20F4D8CE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<unsigned char>::Cast<MIL::Fp16>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v23 = 0;
  __n128 v22 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v22, v4, v5, (v5 - (uint64_t)v4) >> 3);
  __n128 __p = 0uLL;
  unint64_t v21 = 0;
  std::vector<MIL::Fp16>::reserve((void **)&__p, a1[5] - a1[4]);
  uint64_t v8 = a1[4];
  if (a1[5] != v8)
  {
    unint64_t v9 = 0;
    do
    {
      LOBYTE(v7) = *(unsigned char *)(v8 + v9);
      uint64_t v6 = (MIL::Fp16 *)MIL::Fp16::FromFloat(v6, (float)v7);
      __int16 v10 = (__int16)v6;
      unint64_t v11 = __p.n128_u64[1];
      if (__p.n128_u64[1] >= v21)
      {
        uint64_t v6 = (MIL::Fp16 *)__p.n128_u64[0];
        int64_t v13 = __p.n128_u64[1] - __p.n128_u64[0];
        if ((uint64_t)(__p.n128_u64[1] - __p.n128_u64[0]) <= -3) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v14 = v13 >> 1;
        if (v21 - __p.n128_u64[0] <= (v13 >> 1) + 1) {
          uint64_t v15 = v14 + 1;
        }
        else {
          uint64_t v15 = v21 - __p.n128_u64[0];
        }
        if (v21 - __p.n128_u64[0] >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v16 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v16 = v15;
        }
        if (v16)
        {
          uint64_t v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MIL::Fp16>>((uint64_t)&v21, v16);
          unint64_t v11 = __p.n128_u64[1];
          uint64_t v6 = (MIL::Fp16 *)__p.n128_u64[0];
        }
        else
        {
          uint64_t v17 = 0;
        }
        __int16 v18 = &v17[2 * v14];
        *(_WORD *)__int16 v18 = v10;
        unint64_t v12 = (unint64_t)(v18 + 2);
        while ((MIL::Fp16 *)v11 != v6)
        {
          __int16 v19 = *(_WORD *)(v11 - 2);
          v11 -= 2;
          *((_WORD *)v18 - 1) = v19;
          v18 -= 2;
        }
        __p.n128_u64[0] = (unint64_t)v18;
        __p.n128_u64[1] = v12;
        unint64_t v21 = (unint64_t)&v17[2 * v16];
        if (v6) {
          operator delete(v6);
        }
      }
      else
      {
        *(_WORD *)__p.n128_u64[1] = (_WORD)v6;
        unint64_t v12 = v11 + 2;
      }
      __p.n128_u64[1] = v12;
      ++v9;
      uint64_t v8 = a1[4];
    }
    while (v9 < a1[5] - v8);
  }
  MIL::ValueInference::Tensor<MIL::Fp16>::Tensor(a2, &v22, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v22.n128_u64[0])
  {
    v22.n128_u64[1] = v22.n128_u64[0];
    operator delete((void *)v22.n128_u64[0]);
  }
}

void sub_20F4D8EA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<signed char>::Cast<MIL::Fp16>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v22 = 0;
  __n128 v21 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v21, v4, v5, (v5 - (uint64_t)v4) >> 3);
  __n128 __p = 0uLL;
  unint64_t v20 = 0;
  std::vector<MIL::Fp16>::reserve((void **)&__p, a1[5] - a1[4]);
  uint64_t v7 = a1[4];
  if (a1[5] != v7)
  {
    unint64_t v8 = 0;
    do
    {
      uint64_t v6 = (MIL::Fp16 *)MIL::Fp16::FromFloat(v6, (float)*(char *)(v7 + v8));
      __int16 v9 = (__int16)v6;
      unint64_t v10 = __p.n128_u64[1];
      if (__p.n128_u64[1] >= v20)
      {
        uint64_t v6 = (MIL::Fp16 *)__p.n128_u64[0];
        int64_t v12 = __p.n128_u64[1] - __p.n128_u64[0];
        if ((uint64_t)(__p.n128_u64[1] - __p.n128_u64[0]) <= -3) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v13 = v12 >> 1;
        if (v20 - __p.n128_u64[0] <= (v12 >> 1) + 1) {
          uint64_t v14 = v13 + 1;
        }
        else {
          uint64_t v14 = v20 - __p.n128_u64[0];
        }
        if (v20 - __p.n128_u64[0] >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v15 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v15 = v14;
        }
        if (v15)
        {
          uint64_t v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MIL::Fp16>>((uint64_t)&v20, v15);
          unint64_t v10 = __p.n128_u64[1];
          uint64_t v6 = (MIL::Fp16 *)__p.n128_u64[0];
        }
        else
        {
          uint64_t v16 = 0;
        }
        uint64_t v17 = &v16[2 * v13];
        *(_WORD *)uint64_t v17 = v9;
        unint64_t v11 = (unint64_t)(v17 + 2);
        while ((MIL::Fp16 *)v10 != v6)
        {
          __int16 v18 = *(_WORD *)(v10 - 2);
          v10 -= 2;
          *((_WORD *)v17 - 1) = v18;
          v17 -= 2;
        }
        __p.n128_u64[0] = (unint64_t)v17;
        __p.n128_u64[1] = v11;
        unint64_t v20 = (unint64_t)&v16[2 * v15];
        if (v6) {
          operator delete(v6);
        }
      }
      else
      {
        *(_WORD *)__p.n128_u64[1] = (_WORD)v6;
        unint64_t v11 = v10 + 2;
      }
      __p.n128_u64[1] = v11;
      ++v8;
      uint64_t v7 = a1[4];
    }
    while (v8 < a1[5] - v7);
  }
  MIL::ValueInference::Tensor<MIL::Fp16>::Tensor(a2, &v21, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v21.n128_u64[0])
  {
    v21.n128_u64[1] = v21.n128_u64[0];
    operator delete((void *)v21.n128_u64[0]);
  }
}

void sub_20F4D9068(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<BOOL>::Cast<MIL::Fp16>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v23 = 0;
  __n128 v22 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v22, v4, v5, (v5 - (uint64_t)v4) >> 3);
  __n128 __p = 0uLL;
  unint64_t v21 = 0;
  std::vector<MIL::Fp16>::reserve((void **)&__p, a1[5] - a1[4]);
  uint64_t v8 = a1[4];
  if (a1[5] != v8)
  {
    unint64_t v9 = 0;
    do
    {
      LOBYTE(v7) = *(unsigned char *)(v8 + v9);
      uint64_t v6 = (MIL::Fp16 *)MIL::Fp16::FromFloat(v6, (float)v7);
      __int16 v10 = (__int16)v6;
      unint64_t v11 = __p.n128_u64[1];
      if (__p.n128_u64[1] >= v21)
      {
        uint64_t v6 = (MIL::Fp16 *)__p.n128_u64[0];
        int64_t v13 = __p.n128_u64[1] - __p.n128_u64[0];
        if ((uint64_t)(__p.n128_u64[1] - __p.n128_u64[0]) <= -3) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v14 = v13 >> 1;
        if (v21 - __p.n128_u64[0] <= (v13 >> 1) + 1) {
          uint64_t v15 = v14 + 1;
        }
        else {
          uint64_t v15 = v21 - __p.n128_u64[0];
        }
        if (v21 - __p.n128_u64[0] >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v16 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v16 = v15;
        }
        if (v16)
        {
          uint64_t v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MIL::Fp16>>((uint64_t)&v21, v16);
          unint64_t v11 = __p.n128_u64[1];
          uint64_t v6 = (MIL::Fp16 *)__p.n128_u64[0];
        }
        else
        {
          uint64_t v17 = 0;
        }
        __int16 v18 = &v17[2 * v14];
        *(_WORD *)__int16 v18 = v10;
        unint64_t v12 = (unint64_t)(v18 + 2);
        while ((MIL::Fp16 *)v11 != v6)
        {
          __int16 v19 = *(_WORD *)(v11 - 2);
          v11 -= 2;
          *((_WORD *)v18 - 1) = v19;
          v18 -= 2;
        }
        __p.n128_u64[0] = (unint64_t)v18;
        __p.n128_u64[1] = v12;
        unint64_t v21 = (unint64_t)&v17[2 * v16];
        if (v6) {
          operator delete(v6);
        }
      }
      else
      {
        *(_WORD *)__p.n128_u64[1] = (_WORD)v6;
        unint64_t v12 = v11 + 2;
      }
      __p.n128_u64[1] = v12;
      ++v9;
      uint64_t v8 = a1[4];
    }
    while (v9 < a1[5] - v8);
  }
  MIL::ValueInference::Tensor<MIL::Fp16>::Tensor(a2, &v22, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v22.n128_u64[0])
  {
    v22.n128_u64[1] = v22.n128_u64[0];
    operator delete((void *)v22.n128_u64[0]);
  }
}

void sub_20F4D922C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<float>::Cast<BOOL>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v24 = 0;
  __n128 v23 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v23, v4, v5, (v5 - (uint64_t)v4) >> 3);
  __n128 __p = 0uLL;
  __n128 v22 = 0;
  std::vector<unsigned char>::reserve(__p.n128_u64, (uint64_t)(a1[5] - a1[4]) >> 2);
  uint64_t v6 = a1[4];
  if (a1[5] != v6)
  {
    unint64_t v7 = 0;
    uint64_t v8 = (char *)__p.n128_u64[1];
    do
    {
      BOOL v9 = *(float *)(v6 + 4 * v7) != 0.0;
      if (v8 >= v22)
      {
        unint64_t v11 = __p.n128_u64[0];
        unint64_t v12 = &v8[-__p.n128_u64[0]];
        int64_t v13 = (int64_t)&v8[-__p.n128_u64[0] + 1];
        if (v13 < 0) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v14 = (unint64_t)&v22[-__p.n128_u64[0]];
        if (2 * (uint64_t)&v22[-__p.n128_u64[0]] > (unint64_t)v13) {
          int64_t v13 = 2 * v14;
        }
        if (v14 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v15 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v15 = v13;
        }
        if (v15) {
          unint64_t v16 = (unint64_t)operator new(v15);
        }
        else {
          unint64_t v16 = 0;
        }
        unint64_t v17 = (unint64_t)&v12[v16];
        __int16 v18 = (BOOL *)&v12[v16];
        BOOL *v18 = v9;
        unint64_t v10 = (unint64_t)(v18 + 1);
        if (v8 != (char *)v11)
        {
          __int16 v19 = &v8[~v11];
          do
          {
            char v20 = *--v8;
            (v19--)[v16] = v20;
          }
          while (v8 != (char *)v11);
          uint64_t v8 = (char *)__p.n128_u64[0];
          unint64_t v17 = v16;
        }
        __p.n128_u64[0] = v17;
        __p.n128_u64[1] = v10;
        __n128 v22 = (char *)(v16 + v15);
        if (v8) {
          operator delete(v8);
        }
      }
      else
      {
        *uint64_t v8 = v9;
        unint64_t v10 = (unint64_t)(v8 + 1);
      }
      __p.n128_u64[1] = v10;
      ++v7;
      uint64_t v6 = a1[4];
      uint64_t v8 = (char *)v10;
    }
    while (v7 < (a1[5] - v6) >> 2);
  }
  MIL::ValueInference::Tensor<BOOL>::Tensor(a2, &v23, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v23.n128_u64[0])
  {
    v23.n128_u64[1] = v23.n128_u64[0];
    operator delete((void *)v23.n128_u64[0]);
  }
}

void sub_20F4D9408(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<int>::Cast<BOOL>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v24 = 0;
  __n128 v23 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v23, v4, v5, (v5 - (uint64_t)v4) >> 3);
  __n128 __p = 0uLL;
  __n128 v22 = 0;
  std::vector<unsigned char>::reserve(__p.n128_u64, (uint64_t)(a1[5] - a1[4]) >> 2);
  uint64_t v6 = a1[4];
  if (a1[5] != v6)
  {
    unint64_t v7 = 0;
    uint64_t v8 = (char *)__p.n128_u64[1];
    do
    {
      BOOL v9 = *(_DWORD *)(v6 + 4 * v7) != 0;
      if (v8 >= v22)
      {
        unint64_t v11 = __p.n128_u64[0];
        unint64_t v12 = &v8[-__p.n128_u64[0]];
        int64_t v13 = (int64_t)&v8[-__p.n128_u64[0] + 1];
        if (v13 < 0) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v14 = (unint64_t)&v22[-__p.n128_u64[0]];
        if (2 * (uint64_t)&v22[-__p.n128_u64[0]] > (unint64_t)v13) {
          int64_t v13 = 2 * v14;
        }
        if (v14 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v15 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v15 = v13;
        }
        if (v15) {
          unint64_t v16 = (unint64_t)operator new(v15);
        }
        else {
          unint64_t v16 = 0;
        }
        unint64_t v17 = (unint64_t)&v12[v16];
        __int16 v18 = (BOOL *)&v12[v16];
        BOOL *v18 = v9;
        unint64_t v10 = (unint64_t)(v18 + 1);
        if (v8 != (char *)v11)
        {
          __int16 v19 = &v8[~v11];
          do
          {
            char v20 = *--v8;
            (v19--)[v16] = v20;
          }
          while (v8 != (char *)v11);
          uint64_t v8 = (char *)__p.n128_u64[0];
          unint64_t v17 = v16;
        }
        __p.n128_u64[0] = v17;
        __p.n128_u64[1] = v10;
        __n128 v22 = (char *)(v16 + v15);
        if (v8) {
          operator delete(v8);
        }
      }
      else
      {
        *uint64_t v8 = v9;
        unint64_t v10 = (unint64_t)(v8 + 1);
      }
      __p.n128_u64[1] = v10;
      ++v7;
      uint64_t v6 = a1[4];
      uint64_t v8 = (char *)v10;
    }
    while (v7 < (a1[5] - v6) >> 2);
  }
  MIL::ValueInference::Tensor<BOOL>::Tensor(a2, &v23, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v23.n128_u64[0])
  {
    v23.n128_u64[1] = v23.n128_u64[0];
    operator delete((void *)v23.n128_u64[0]);
  }
}

void sub_20F4D95E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<short>::Cast<BOOL>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v24 = 0;
  __n128 v23 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v23, v4, v5, (v5 - (uint64_t)v4) >> 3);
  __n128 __p = 0uLL;
  __n128 v22 = 0;
  std::vector<unsigned char>::reserve(__p.n128_u64, (uint64_t)(a1[5] - a1[4]) >> 1);
  uint64_t v6 = a1[4];
  if (a1[5] != v6)
  {
    unint64_t v7 = 0;
    uint64_t v8 = (char *)__p.n128_u64[1];
    do
    {
      BOOL v9 = *(unsigned __int16 *)(v6 + 2 * v7) != 0;
      if (v8 >= v22)
      {
        unint64_t v11 = __p.n128_u64[0];
        unint64_t v12 = &v8[-__p.n128_u64[0]];
        int64_t v13 = (int64_t)&v8[-__p.n128_u64[0] + 1];
        if (v13 < 0) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v14 = (unint64_t)&v22[-__p.n128_u64[0]];
        if (2 * (uint64_t)&v22[-__p.n128_u64[0]] > (unint64_t)v13) {
          int64_t v13 = 2 * v14;
        }
        if (v14 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v15 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v15 = v13;
        }
        if (v15) {
          unint64_t v16 = (unint64_t)operator new(v15);
        }
        else {
          unint64_t v16 = 0;
        }
        unint64_t v17 = (unint64_t)&v12[v16];
        __int16 v18 = (BOOL *)&v12[v16];
        BOOL *v18 = v9;
        unint64_t v10 = (unint64_t)(v18 + 1);
        if (v8 != (char *)v11)
        {
          __int16 v19 = &v8[~v11];
          do
          {
            char v20 = *--v8;
            (v19--)[v16] = v20;
          }
          while (v8 != (char *)v11);
          uint64_t v8 = (char *)__p.n128_u64[0];
          unint64_t v17 = v16;
        }
        __p.n128_u64[0] = v17;
        __p.n128_u64[1] = v10;
        __n128 v22 = (char *)(v16 + v15);
        if (v8) {
          operator delete(v8);
        }
      }
      else
      {
        *uint64_t v8 = v9;
        unint64_t v10 = (unint64_t)(v8 + 1);
      }
      __p.n128_u64[1] = v10;
      ++v7;
      uint64_t v6 = a1[4];
      uint64_t v8 = (char *)v10;
    }
    while (v7 < (a1[5] - v6) >> 1);
  }
  MIL::ValueInference::Tensor<BOOL>::Tensor(a2, &v23, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v23.n128_u64[0])
  {
    v23.n128_u64[1] = v23.n128_u64[0];
    operator delete((void *)v23.n128_u64[0]);
  }
}

void sub_20F4D97C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<unsigned short>::Cast<BOOL>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v24 = 0;
  __n128 v23 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v23, v4, v5, (v5 - (uint64_t)v4) >> 3);
  __n128 __p = 0uLL;
  __n128 v22 = 0;
  std::vector<unsigned char>::reserve(__p.n128_u64, (uint64_t)(a1[5] - a1[4]) >> 1);
  uint64_t v6 = a1[4];
  if (a1[5] != v6)
  {
    unint64_t v7 = 0;
    uint64_t v8 = (char *)__p.n128_u64[1];
    do
    {
      BOOL v9 = *(unsigned __int16 *)(v6 + 2 * v7) != 0;
      if (v8 >= v22)
      {
        unint64_t v11 = __p.n128_u64[0];
        unint64_t v12 = &v8[-__p.n128_u64[0]];
        int64_t v13 = (int64_t)&v8[-__p.n128_u64[0] + 1];
        if (v13 < 0) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v14 = (unint64_t)&v22[-__p.n128_u64[0]];
        if (2 * (uint64_t)&v22[-__p.n128_u64[0]] > (unint64_t)v13) {
          int64_t v13 = 2 * v14;
        }
        if (v14 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v15 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v15 = v13;
        }
        if (v15) {
          unint64_t v16 = (unint64_t)operator new(v15);
        }
        else {
          unint64_t v16 = 0;
        }
        unint64_t v17 = (unint64_t)&v12[v16];
        __int16 v18 = (BOOL *)&v12[v16];
        BOOL *v18 = v9;
        unint64_t v10 = (unint64_t)(v18 + 1);
        if (v8 != (char *)v11)
        {
          __int16 v19 = &v8[~v11];
          do
          {
            char v20 = *--v8;
            (v19--)[v16] = v20;
          }
          while (v8 != (char *)v11);
          uint64_t v8 = (char *)__p.n128_u64[0];
          unint64_t v17 = v16;
        }
        __p.n128_u64[0] = v17;
        __p.n128_u64[1] = v10;
        __n128 v22 = (char *)(v16 + v15);
        if (v8) {
          operator delete(v8);
        }
      }
      else
      {
        *uint64_t v8 = v9;
        unint64_t v10 = (unint64_t)(v8 + 1);
      }
      __p.n128_u64[1] = v10;
      ++v7;
      uint64_t v6 = a1[4];
      uint64_t v8 = (char *)v10;
    }
    while (v7 < (a1[5] - v6) >> 1);
  }
  MIL::ValueInference::Tensor<BOOL>::Tensor(a2, &v23, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v23.n128_u64[0])
  {
    v23.n128_u64[1] = v23.n128_u64[0];
    operator delete((void *)v23.n128_u64[0]);
  }
}

void sub_20F4D999C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<signed char>::Cast<BOOL>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v24 = 0;
  __n128 v23 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v23, v4, v5, (v5 - (uint64_t)v4) >> 3);
  __n128 __p = 0uLL;
  __n128 v22 = 0;
  std::vector<unsigned char>::reserve(__p.n128_u64, a1[5] - a1[4]);
  uint64_t v6 = a1[4];
  if (a1[5] != v6)
  {
    unint64_t v7 = 0;
    uint64_t v8 = (char *)__p.n128_u64[1];
    do
    {
      BOOL v9 = *(unsigned char *)(v6 + v7) != 0;
      if (v8 >= v22)
      {
        unint64_t v11 = __p.n128_u64[0];
        unint64_t v12 = &v8[-__p.n128_u64[0]];
        int64_t v13 = (int64_t)&v8[-__p.n128_u64[0] + 1];
        if (v13 < 0) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v14 = (unint64_t)&v22[-__p.n128_u64[0]];
        if (2 * (uint64_t)&v22[-__p.n128_u64[0]] > (unint64_t)v13) {
          int64_t v13 = 2 * v14;
        }
        if (v14 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v15 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v15 = v13;
        }
        if (v15) {
          unint64_t v16 = (unint64_t)operator new(v15);
        }
        else {
          unint64_t v16 = 0;
        }
        unint64_t v17 = (unint64_t)&v12[v16];
        __int16 v18 = (BOOL *)&v12[v16];
        BOOL *v18 = v9;
        unint64_t v10 = (unint64_t)(v18 + 1);
        if (v8 != (char *)v11)
        {
          __int16 v19 = &v8[~v11];
          do
          {
            char v20 = *--v8;
            (v19--)[v16] = v20;
          }
          while (v8 != (char *)v11);
          uint64_t v8 = (char *)__p.n128_u64[0];
          unint64_t v17 = v16;
        }
        __p.n128_u64[0] = v17;
        __p.n128_u64[1] = v10;
        __n128 v22 = (char *)(v16 + v15);
        if (v8) {
          operator delete(v8);
        }
      }
      else
      {
        *uint64_t v8 = v9;
        unint64_t v10 = (unint64_t)(v8 + 1);
      }
      __p.n128_u64[1] = v10;
      ++v7;
      uint64_t v6 = a1[4];
      uint64_t v8 = (char *)v10;
    }
    while (v7 < a1[5] - v6);
  }
  MIL::ValueInference::Tensor<BOOL>::Tensor(a2, &v23, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v23.n128_u64[0])
  {
    v23.n128_u64[1] = v23.n128_u64[0];
    operator delete((void *)v23.n128_u64[0]);
  }
}

void sub_20F4D9B74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<unsigned char>::Cast<BOOL>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = (const void *)a1[1];
  uint64_t v5 = a1[2];
  uint64_t v24 = 0;
  __n128 v23 = 0uLL;
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(&v23, v4, v5, (v5 - (uint64_t)v4) >> 3);
  __n128 __p = 0uLL;
  __n128 v22 = 0;
  std::vector<unsigned char>::reserve(__p.n128_u64, a1[5] - a1[4]);
  uint64_t v6 = a1[4];
  if (a1[5] != v6)
  {
    unint64_t v7 = 0;
    uint64_t v8 = (char *)__p.n128_u64[1];
    do
    {
      BOOL v9 = *(unsigned char *)(v6 + v7) != 0;
      if (v8 >= v22)
      {
        unint64_t v11 = __p.n128_u64[0];
        unint64_t v12 = &v8[-__p.n128_u64[0]];
        int64_t v13 = (int64_t)&v8[-__p.n128_u64[0] + 1];
        if (v13 < 0) {
          std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v14 = (unint64_t)&v22[-__p.n128_u64[0]];
        if (2 * (uint64_t)&v22[-__p.n128_u64[0]] > (unint64_t)v13) {
          int64_t v13 = 2 * v14;
        }
        if (v14 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v15 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v15 = v13;
        }
        if (v15) {
          unint64_t v16 = (unint64_t)operator new(v15);
        }
        else {
          unint64_t v16 = 0;
        }
        unint64_t v17 = (unint64_t)&v12[v16];
        __int16 v18 = (BOOL *)&v12[v16];
        BOOL *v18 = v9;
        unint64_t v10 = (unint64_t)(v18 + 1);
        if (v8 != (char *)v11)
        {
          __int16 v19 = &v8[~v11];
          do
          {
            char v20 = *--v8;
            (v19--)[v16] = v20;
          }
          while (v8 != (char *)v11);
          uint64_t v8 = (char *)__p.n128_u64[0];
          unint64_t v17 = v16;
        }
        __p.n128_u64[0] = v17;
        __p.n128_u64[1] = v10;
        __n128 v22 = (char *)(v16 + v15);
        if (v8) {
          operator delete(v8);
        }
      }
      else
      {
        *uint64_t v8 = v9;
        unint64_t v10 = (unint64_t)(v8 + 1);
      }
      __p.n128_u64[1] = v10;
      ++v7;
      uint64_t v6 = a1[4];
      uint64_t v8 = (char *)v10;
    }
    while (v7 < a1[5] - v6);
  }
  MIL::ValueInference::Tensor<BOOL>::Tensor(a2, &v23, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v23.n128_u64[0])
  {
    v23.n128_u64[1] = v23.n128_u64[0];
    operator delete((void *)v23.n128_u64[0]);
  }
}

void sub_20F4D9D4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void MIL::ValueInference::Tensor<double>::~Tensor(void *a1)
{
  MIL::ValueInference::Tensor<double>::~Tensor(a1);

  JUMPOUT(0x21056C700);
}

void MIL::ValueInference::Tensor<unsigned int>::~Tensor(void *a1)
{
  MIL::ValueInference::Tensor<unsigned int>::~Tensor(a1);

  JUMPOUT(0x21056C700);
}

void MIL::ValueInference::Tensor<unsigned long long>::~Tensor(void *a1)
{
  MIL::ValueInference::Tensor<unsigned long long>::~Tensor(a1);

  JUMPOUT(0x21056C700);
}

void MIL::ValueInference::Tensor<long long>::~Tensor(void *a1)
{
  MIL::ValueInference::Tensor<long long>::~Tensor(a1);

  JUMPOUT(0x21056C700);
}

void *MIL::ValueInference::Tensor<double>::~Tensor(void *a1)
{
  *a1 = &unk_26C25DC88;
  uint64_t v2 = (void *)a1[4];
  if (v2)
  {
    a1[5] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[1];
  if (v3)
  {
    a1[2] = v3;
    operator delete(v3);
  }
  return a1;
}

void *MIL::ValueInference::Tensor<unsigned int>::~Tensor(void *a1)
{
  *a1 = &unk_26C25DCA8;
  uint64_t v2 = (void *)a1[4];
  if (v2)
  {
    a1[5] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[1];
  if (v3)
  {
    a1[2] = v3;
    operator delete(v3);
  }
  return a1;
}

void *MIL::ValueInference::Tensor<unsigned long long>::~Tensor(void *a1)
{
  *a1 = &unk_26C25DCC8;
  uint64_t v2 = (void *)a1[4];
  if (v2)
  {
    a1[5] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[1];
  if (v3)
  {
    a1[2] = v3;
    operator delete(v3);
  }
  return a1;
}

void *MIL::ValueInference::Tensor<long long>::~Tensor(void *a1)
{
  *a1 = &unk_26C25DCE8;
  uint64_t v2 = (void *)a1[4];
  if (v2)
  {
    a1[5] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[1];
  if (v3)
  {
    a1[2] = v3;
    operator delete(v3);
  }
  return a1;
}

uint64_t std::function<MIL::Bf16 ()(MIL::Bf16)>::operator()(uint64_t a1, __int16 a2)
{
  __int16 v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, __int16 *))(*(void *)v2 + 48))(v2, &v4);
}

uint64_t std::__function::__value_func<MIL::Bf16 ()(MIL::Bf16)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *std::__function::__value_func<MIL::Bf16 ()(MIL::Bf16)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::function<MIL::Fp16 ()(MIL::Fp16)>::operator()(uint64_t a1, __int16 a2)
{
  __int16 v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, __int16 *))(*(void *)v2 + 48))(v2, &v4);
}

uint64_t std::__function::__value_func<MIL::Fp16 ()(MIL::Fp16)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *std::__function::__value_func<MIL::Fp16 ()(MIL::Fp16)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::vector<unsigned long long>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<unsigned long long>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      __n128 result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_20F4DA320(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<float const*>,std::__wrap_iter<float const*>>(char *result, float *a2, float *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<float>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = (_DWORD *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      float v8 = *a2++;
      *v7++ = (int)v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_20F4DA398(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<short>::__init_with_size[abi:ne180100]<std::__wrap_iter<float const*>,std::__wrap_iter<float const*>>(char *result, float *a2, float *a3, uint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<MIL::Fp16>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = (_WORD *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      float v8 = *a2++;
      *v7++ = (int)v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_20F4DA410(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<unsigned short>::__init_with_size[abi:ne180100]<std::__wrap_iter<float const*>,std::__wrap_iter<float const*>>(char *result, float *a2, float *a3, uint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<MIL::Fp16>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = (_WORD *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      float v8 = *a2++;
      *v7++ = (int)v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_20F4DA488(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<float>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      __n128 result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_20F4DA504(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<float>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(char *result, int *a2, int *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<float>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = (float *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      int v8 = *a2++;
      *v7++ = (float)v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_20F4DA57C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<short>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(char *result, int *a2, int *a3, uint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<MIL::Fp16>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = (_WORD *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      int v8 = *a2++;
      *v7++ = v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_20F4DA5F0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<unsigned short>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(char *result, int *a2, int *a3, uint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<MIL::Fp16>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = (_WORD *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      int v8 = *a2++;
      *v7++ = v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_20F4DA664(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<signed char>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(char *result, int *a2, int *a3, size_t __sz)
{
  if (__sz)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<unsigned char>::__vallocate[abi:ne180100](result, __sz);
    uint64_t v7 = (unsigned char *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      int v8 = *a2++;
      *v7++ = v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_20F4DA6D8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<unsigned char>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(char *result, int *a2, int *a3, size_t __sz)
{
  if (__sz)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<unsigned char>::__vallocate[abi:ne180100](result, __sz);
    uint64_t v7 = (unsigned char *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      int v8 = *a2++;
      *v7++ = v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_20F4DA74C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<unsigned char>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned char const*>,std::__wrap_iter<unsigned char const*>>(void *result, const void *a2, uint64_t a3, size_t __sz)
{
  if (__sz)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<unsigned char>::__vallocate[abi:ne180100](result, __sz);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      __n128 result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_20F4DA7C8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<float>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned char const*>,std::__wrap_iter<unsigned char const*>>(char *result, unsigned __int8 *a2, unsigned __int8 *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<float>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = (float *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      unsigned int v8 = *a2++;
      *v7++ = (float)v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_20F4DA840(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned char const*>,std::__wrap_iter<unsigned char const*>>(char *result, unsigned __int8 *a2, unsigned __int8 *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<float>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = (_DWORD *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      int v8 = *a2++;
      *v7++ = v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_20F4DA8B4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<short>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned char const*>,std::__wrap_iter<unsigned char const*>>(char *result, unsigned __int8 *a2, unsigned __int8 *a3, uint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<MIL::Fp16>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = (_WORD *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      __int16 v8 = *a2++;
      *v7++ = v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_20F4DA928(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<unsigned short>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned char const*>,std::__wrap_iter<unsigned char const*>>(char *result, unsigned __int8 *a2, unsigned __int8 *a3, uint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<MIL::Fp16>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = (_WORD *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      __int16 v8 = *a2++;
      *v7++ = v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_20F4DA99C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<signed char>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned char const*>,std::__wrap_iter<unsigned char const*>>(char *result, char *a2, char *a3, size_t __sz)
{
  if (__sz)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<unsigned char>::__vallocate[abi:ne180100](result, __sz);
    uint64_t v7 = (unsigned char *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      char v8 = *a2++;
      *v7++ = v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_20F4DAA10(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<short>::__init_with_size[abi:ne180100]<std::__wrap_iter<short const*>,std::__wrap_iter<short const*>>(void *result, const void *a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<MIL::Fp16>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      __n128 result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_20F4DAA8C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<signed char>::__init_with_size[abi:ne180100]<std::__wrap_iter<short const*>,std::__wrap_iter<short const*>>(char *result, char *a2, char *a3, size_t __sz)
{
  if (__sz)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<unsigned char>::__vallocate[abi:ne180100](result, __sz);
    uint64_t v7 = (unsigned char *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      char v8 = *a2;
      a2 += 2;
      *v7++ = v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_20F4DAB00(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<float>::__init_with_size[abi:ne180100]<std::__wrap_iter<short const*>,std::__wrap_iter<short const*>>(char *result, __int16 *a2, __int16 *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<float>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = (float *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      int v8 = *a2++;
      *v7++ = (float)v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_20F4DAB78(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<short const*>,std::__wrap_iter<short const*>>(char *result, __int16 *a2, __int16 *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<float>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = (_DWORD *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      int v8 = *a2++;
      *v7++ = v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_20F4DABEC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<unsigned short>::__init_with_size[abi:ne180100]<std::__wrap_iter<short const*>,std::__wrap_iter<short const*>>(char *result, __int16 *a2, __int16 *a3, uint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<MIL::Fp16>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = (_WORD *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      __int16 v8 = *a2++;
      *v7++ = v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_20F4DAC60(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<unsigned char>::__init_with_size[abi:ne180100]<std::__wrap_iter<short const*>,std::__wrap_iter<short const*>>(char *result, char *a2, char *a3, size_t __sz)
{
  if (__sz)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<unsigned char>::__vallocate[abi:ne180100](result, __sz);
    uint64_t v7 = (unsigned char *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      char v8 = *a2;
      a2 += 2;
      *v7++ = v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_20F4DACD4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<unsigned short>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>(void *result, const void *a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<MIL::Fp16>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      __n128 result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_20F4DAD50(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<signed char>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>(char *result, char *a2, char *a3, size_t __sz)
{
  if (__sz)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<unsigned char>::__vallocate[abi:ne180100](result, __sz);
    uint64_t v7 = (unsigned char *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      char v8 = *a2;
      a2 += 2;
      *v7++ = v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_20F4DADC4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<float>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>(char *result, unsigned __int16 *a2, unsigned __int16 *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<float>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = (float *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      unsigned int v8 = *a2++;
      *v7++ = (float)v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_20F4DAE3C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>(char *result, unsigned __int16 *a2, unsigned __int16 *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<float>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = (_DWORD *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      int v8 = *a2++;
      *v7++ = v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_20F4DAEB0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<short>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>(char *result, __int16 *a2, __int16 *a3, uint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<MIL::Fp16>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = (_WORD *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      __int16 v8 = *a2++;
      *v7++ = v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_20F4DAF24(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<unsigned char>::__init_with_size[abi:ne180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>(char *result, char *a2, char *a3, size_t __sz)
{
  if (__sz)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<unsigned char>::__vallocate[abi:ne180100](result, __sz);
    uint64_t v7 = (unsigned char *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      char v8 = *a2;
      a2 += 2;
      *v7++ = v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_20F4DAF98(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<signed char>::__init_with_size[abi:ne180100]<std::__wrap_iter<signed char const*>,std::__wrap_iter<signed char const*>>(void *result, const void *a2, uint64_t a3, size_t __sz)
{
  if (__sz)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<unsigned char>::__vallocate[abi:ne180100](result, __sz);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      __n128 result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_20F4DB014(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<float>::__init_with_size[abi:ne180100]<std::__wrap_iter<signed char const*>,std::__wrap_iter<signed char const*>>(char *result, char *a2, char *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<float>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = (float *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      int v8 = *a2++;
      *v7++ = (float)v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_20F4DB08C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<int>::__init_with_size[abi:ne180100]<std::__wrap_iter<signed char const*>,std::__wrap_iter<signed char const*>>(char *result, char *a2, char *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<float>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = (_DWORD *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      int v8 = *a2++;
      *v7++ = v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_20F4DB100(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<short>::__init_with_size[abi:ne180100]<std::__wrap_iter<signed char const*>,std::__wrap_iter<signed char const*>>(char *result, char *a2, char *a3, uint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<MIL::Fp16>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = (_WORD *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      __int16 v8 = *a2++;
      *v7++ = v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_20F4DB174(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<unsigned short>::__init_with_size[abi:ne180100]<std::__wrap_iter<signed char const*>,std::__wrap_iter<signed char const*>>(char *result, char *a2, char *a3, uint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<MIL::Fp16>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = (_WORD *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      __int16 v8 = *a2++;
      *v7++ = v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_20F4DB1E8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<unsigned char>::__init_with_size[abi:ne180100]<std::__wrap_iter<signed char const*>,std::__wrap_iter<signed char const*>>(char *result, char *a2, char *a3, size_t __sz)
{
  if (__sz)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<unsigned char>::__vallocate[abi:ne180100](result, __sz);
    uint64_t v7 = (unsigned char *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      char v8 = *a2++;
      *v7++ = v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_20F4DB25C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<MIL::Bf16>::__init_with_size[abi:ne180100]<std::__wrap_iter<MIL::Bf16 const*>,std::__wrap_iter<MIL::Bf16 const*>>(void *result, const void *a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<MIL::Fp16>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      __n128 result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_20F4DB2D8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<MIL::Fp16>::__init_with_size[abi:ne180100]<std::__wrap_iter<MIL::Fp16 const*>,std::__wrap_iter<MIL::Fp16 const*>>(void *result, const void *a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<MIL::Fp16>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      __n128 result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_20F4DB354(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::allocate_shared[abi:ne180100]<MIL::IRTypedTensorValue<float>,std::allocator<MIL::IRTypedTensorValue<float>>,MIL::IRTensorValueType const*&,std::vector<float>,void>()
{
  v0 = operator new(0x30uLL);
  std::__shared_ptr_emplace<MIL::IRTypedTensorValue<float>>::__shared_ptr_emplace[abi:ne180100]<MIL::IRTensorValueType const*&,std::vector<float>,std::allocator<MIL::IRTypedTensorValue<float>>,0>(v0);
}

void sub_20F4DB3C0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<MIL::IRTypedTensorValue<float>>::__shared_ptr_emplace[abi:ne180100]<MIL::IRTensorValueType const*&,std::vector<float>,std::allocator<MIL::IRTypedTensorValue<float>>,0>(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_26C25DD48;
  MIL::IRTypedTensorValue<float>::IRTypedTensorValue();
}

void sub_20F4DB420(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<MIL::IRTypedTensorValue<float>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C25DD48;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<MIL::IRTypedTensorValue<float>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C25DD48;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21056C700);
}

uint64_t std::__shared_ptr_emplace<MIL::IRTypedTensorValue<float>>::__on_zero_shared(uint64_t a1)
{
  return MIL::IRTypedTensorValue<float>::~IRTypedTensorValue(a1 + 24);
}

uint64_t std::function<float ()(float)>::operator()(uint64_t a1, float a2)
{
  float v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, float *))(*(void *)v2 + 48))(v2, &v4);
}

uint64_t std::__function::__value_func<float ()(float)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t std::vector<std::vector<unsigned long long>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<unsigned long long>>,std::reverse_iterator<std::vector<unsigned long long>*>,std::reverse_iterator<std::vector<unsigned long long>*>,std::reverse_iterator<std::vector<unsigned long long>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<unsigned long long>>,std::reverse_iterator<std::vector<unsigned long long>*>,std::reverse_iterator<std::vector<unsigned long long>*>,std::reverse_iterator<std::vector<unsigned long long>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v14 = a6;
  *((void *)&v14 + 1) = a7;
  long long v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    uint64_t v9 = a6;
  }
  else
  {
    do
    {
      *(void *)(v7 - 24) = 0;
      *(void *)(v7 - 16) = 0;
      *(void *)(v7 - 8) = 0;
      long long v8 = *(_OWORD *)(a3 - 3);
      a3 -= 3;
      *(_OWORD *)(v7 - 24) = v8;
      *(void *)(v7 - 8) = a3[2];
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      uint64_t v7 = *((void *)&v14 + 1) - 24;
      *((void *)&v14 + 1) -= 24;
    }
    while (a3 != a5);
    uint64_t v9 = v14;
  }
  char v12 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<unsigned long long>>,std::reverse_iterator<std::vector<unsigned long long>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<unsigned long long>>,std::reverse_iterator<std::vector<unsigned long long>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::reverse_iterator<std::vector<float>*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

uint64_t std::unordered_set<unsigned long long>::unordered_set<std::__wrap_iter<unsigned long long const*>>(uint64_t a1, unint64_t *a2, unint64_t *a3)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (a2 != a3)
  {
    uint64_t v5 = a2;
    do
    {
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>(a1, v5, v5);
      ++v5;
    }
    while (v5 != a3);
  }
  return a1;
}

void sub_20F4DB75C(_Unwind_Exception *a1)
{
  std::__hash_table<MIL::IRValueType const*,std::hash<MIL::IRValueType const*>,std::equal_to<MIL::IRValueType const*>,std::allocator<MIL::IRValueType const*>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>(uint64_t a1, unint64_t *a2, void *a3)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = *a2;
      if (v6 >= v7) {
        unint64_t v3 = v6 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      for (unint64_t i = *v9; i; unint64_t i = (void *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == v6)
        {
          if (i[2] == v6) {
            return i;
          }
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }
  unint64_t i = operator new(0x18uLL);
  void *i = 0;
  i[1] = v6;
  i[2] = *a3;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<MIL::IRValue const>>>>::__rehash<true>(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v6 >= v7) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v18 = *(void *)a1;
  __int16 v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    void *i = *v19;
LABEL_38:
    void *v19 = i;
    goto LABEL_39;
  }
  void *i = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*i)
  {
    unint64_t v20 = *(void *)(*i + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }
    else
    {
      v20 &= v7 - 1;
    }
    __int16 v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_20F4DB978(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(void *a1, unint64_t *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = *a2;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = *a2;
    if (v3 >= *(void *)&v2) {
      unint64_t v5 = v3 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v5 = (*(void *)&v2 - 1) & v3;
  }
  unint64_t v6 = *(void **)(*a1 + 8 * v5);
  if (!v6) {
    return 0;
  }
  uint64_t result = (void *)*v6;
  if (*v6)
  {
    do
    {
      unint64_t v8 = result[1];
      if (v3 == v8)
      {
        if (result[2] == v3) {
          return result;
        }
      }
      else
      {
        if (v4.u32[0] > 1uLL)
        {
          if (v8 >= *(void *)&v2) {
            v8 %= *(void *)&v2;
          }
        }
        else
        {
          v8 &= *(void *)&v2 - 1;
        }
        if (v8 != v5) {
          return 0;
        }
      }
      uint64_t result = (void *)*result;
    }
    while (result);
  }
  return result;
}

void *std::vector<double>::__init_with_size[abi:ne180100]<double *,double *>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = result;
    uint64_t result = std::vector<unsigned long long>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_20F4DBAA0(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::allocate_shared[abi:ne180100]<MIL::IRTypedTensorValue<double>,std::allocator<MIL::IRTypedTensorValue<double>>,MIL::IRTensorValueType const*&,std::vector<double>,void>()
{
  v0 = operator new(0x30uLL);
  std::__shared_ptr_emplace<MIL::IRTypedTensorValue<double>>::__shared_ptr_emplace[abi:ne180100]<MIL::IRTensorValueType const*&,std::vector<double>,std::allocator<MIL::IRTypedTensorValue<double>>,0>(v0);
}

void sub_20F4DBB0C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<MIL::IRTypedTensorValue<double>>::__shared_ptr_emplace[abi:ne180100]<MIL::IRTensorValueType const*&,std::vector<double>,std::allocator<MIL::IRTypedTensorValue<double>>,0>(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_26C25DD98;
  MIL::IRTypedTensorValue<double>::IRTypedTensorValue();
}

void sub_20F4DBB6C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<MIL::IRTypedTensorValue<double>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C25DD98;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<MIL::IRTypedTensorValue<double>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C25DD98;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21056C700);
}

uint64_t std::__shared_ptr_emplace<MIL::IRTypedTensorValue<double>>::__on_zero_shared(uint64_t a1)
{
  return MIL::IRTypedTensorValue<double>::~IRTypedTensorValue(a1 + 24);
}

void *std::vector<double>::vector(void *a1, unint64_t a2, void *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<unsigned long long>::__vallocate[abi:ne180100](a1, a2);
    unint64_t v6 = (void *)a1[1];
    uint64_t v7 = &v6[a2];
    uint64_t v8 = 8 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 8;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_20F4DBC68(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::function<double ()(double)>::operator()(uint64_t a1, double a2)
{
  double v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, double *))(*(void *)v2 + 48))(v2, &v4);
}

uint64_t std::__function::__value_func<double ()(double)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *std::__function::__value_func<double ()(double)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::vector<double>::__init_with_size[abi:ne180100]<std::__wrap_iter<double const*>,std::__wrap_iter<double const*>>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = result;
    uint64_t result = std::vector<unsigned long long>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_20F4DBE54(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::allocate_shared[abi:ne180100]<MIL::IRTypedTensorValue<unsigned char>,std::allocator<MIL::IRTypedTensorValue<unsigned char>>,MIL::IRTensorValueType const*&,std::vector<unsigned char>,void>()
{
  v0 = operator new(0x30uLL);
  std::__shared_ptr_emplace<MIL::IRTypedTensorValue<unsigned char>>::__shared_ptr_emplace[abi:ne180100]<MIL::IRTensorValueType const*&,std::vector<unsigned char>,std::allocator<MIL::IRTypedTensorValue<unsigned char>>,0>(v0);
}

void sub_20F4DBEC0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<MIL::IRTypedTensorValue<unsigned char>>::__shared_ptr_emplace[abi:ne180100]<MIL::IRTensorValueType const*&,std::vector<unsigned char>,std::allocator<MIL::IRTypedTensorValue<unsigned char>>,0>(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_26C25DDE8;
  MIL::IRTypedTensorValue<unsigned char>::IRTypedTensorValue();
}

void sub_20F4DBF20(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<MIL::IRTypedTensorValue<unsigned char>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C25DDE8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<MIL::IRTypedTensorValue<unsigned char>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C25DDE8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21056C700);
}

uint64_t std::__shared_ptr_emplace<MIL::IRTypedTensorValue<unsigned char>>::__on_zero_shared(uint64_t a1)
{
  return MIL::IRTypedTensorValue<unsigned char>::~IRTypedTensorValue(a1 + 24);
}

uint64_t std::function<unsigned char ()(unsigned char)>::operator()(uint64_t a1, char a2)
{
  char v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, char *))(*(void *)v2 + 48))(v2, &v4);
}

uint64_t std::__function::__value_func<unsigned char ()(unsigned char)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *std::__function::__value_func<unsigned char ()(unsigned char)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::vector<unsigned short>::__init_with_size[abi:ne180100]<unsigned short const*,unsigned short const*>(void *result, const void *a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = result;
    uint64_t result = std::vector<MIL::Fp16>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_20F4DC184(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<unsigned short>::__init_with_size[abi:ne180100]<unsigned short *,unsigned short *>(void *result, const void *a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = result;
    uint64_t result = std::vector<MIL::Fp16>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_20F4DC200(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::allocate_shared[abi:ne180100]<MIL::IRTypedTensorValue<unsigned short>,std::allocator<MIL::IRTypedTensorValue<unsigned short>>,MIL::IRTensorValueType const*&,std::vector<unsigned short>,void>()
{
  v0 = operator new(0x30uLL);
  std::__shared_ptr_emplace<MIL::IRTypedTensorValue<unsigned short>>::__shared_ptr_emplace[abi:ne180100]<MIL::IRTensorValueType const*&,std::vector<unsigned short>,std::allocator<MIL::IRTypedTensorValue<unsigned short>>,0>(v0);
}

void sub_20F4DC26C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<MIL::IRTypedTensorValue<unsigned short>>::__shared_ptr_emplace[abi:ne180100]<MIL::IRTensorValueType const*&,std::vector<unsigned short>,std::allocator<MIL::IRTypedTensorValue<unsigned short>>,0>(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_26C25DE38;
  MIL::IRTypedTensorValue<unsigned short>::IRTypedTensorValue();
}

void sub_20F4DC2CC(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<MIL::IRTypedTensorValue<unsigned short>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C25DE38;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<MIL::IRTypedTensorValue<unsigned short>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C25DE38;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21056C700);
}

uint64_t std::__shared_ptr_emplace<MIL::IRTypedTensorValue<unsigned short>>::__on_zero_shared(uint64_t a1)
{
  return MIL::IRTypedTensorValue<unsigned short>::~IRTypedTensorValue(a1 + 24);
}

void *std::vector<unsigned short>::vector(void *a1, uint64_t a2, _WORD *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<MIL::Fp16>::__vallocate[abi:ne180100](a1, a2);
    unint64_t v6 = (_WORD *)a1[1];
    uint64_t v7 = &v6[a2];
    uint64_t v8 = 2 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 2;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_20F4DC3C8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::function<unsigned short ()(unsigned short)>::operator()(uint64_t a1, __int16 a2)
{
  __int16 v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, __int16 *))(*(void *)v2 + 48))(v2, &v4);
}

uint64_t std::__function::__value_func<unsigned short ()(unsigned short)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *std::__function::__value_func<unsigned short ()(unsigned short)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::vector<unsigned short>::vector(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<MIL::Fp16>::__vallocate[abi:ne180100](a1, a2);
    __int16 v4 = (char *)a1[1];
    bzero(v4, 2 * a2);
    a1[1] = &v4[2 * a2];
  }
  return a1;
}

void sub_20F4DC5B0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<unsigned int>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = result;
    uint64_t result = std::vector<float>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_20F4DC62C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::allocate_shared[abi:ne180100]<MIL::IRTypedTensorValue<unsigned int>,std::allocator<MIL::IRTypedTensorValue<unsigned int>>,MIL::IRTensorValueType const*&,std::vector<unsigned int>,void>()
{
  v0 = operator new(0x30uLL);
  std::__shared_ptr_emplace<MIL::IRTypedTensorValue<unsigned int>>::__shared_ptr_emplace[abi:ne180100]<MIL::IRTensorValueType const*&,std::vector<unsigned int>,std::allocator<MIL::IRTypedTensorValue<unsigned int>>,0>(v0);
}

void sub_20F4DC698(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<MIL::IRTypedTensorValue<unsigned int>>::__shared_ptr_emplace[abi:ne180100]<MIL::IRTensorValueType const*&,std::vector<unsigned int>,std::allocator<MIL::IRTypedTensorValue<unsigned int>>,0>(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_26C25DE88;
  MIL::IRTypedTensorValue<unsigned int>::IRTypedTensorValue();
}

void sub_20F4DC6F8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<MIL::IRTypedTensorValue<unsigned int>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C25DE88;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<MIL::IRTypedTensorValue<unsigned int>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C25DE88;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21056C700);
}

uint64_t std::__shared_ptr_emplace<MIL::IRTypedTensorValue<unsigned int>>::__on_zero_shared(uint64_t a1)
{
  return MIL::IRTypedTensorValue<unsigned int>::~IRTypedTensorValue(a1 + 24);
}

std::vector<unsigned int> *__cdecl std::vector<unsigned int>::vector(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __n, const std::vector<unsigned int>::value_type *__x)
{
  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  if (__n)
  {
    std::vector<float>::__vallocate[abi:ne180100](this, __n);
    std::vector<unsigned int>::pointer end = this->__end_;
    uint64_t v7 = &end[__n];
    std::vector<unsigned int>::size_type v8 = 4 * __n;
    do
    {
      *end++ = *__x;
      v8 -= 4;
    }
    while (v8);
    this->__end_ = v7;
  }
  return this;
}

void sub_20F4DC7F4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}