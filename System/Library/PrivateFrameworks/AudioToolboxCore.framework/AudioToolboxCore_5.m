void caulk::inplace_function_detail::vtable<int,void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,unsigned int>::vtable<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_5>(caulk::inplace_function_detail::wrapper<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_5>)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

__n128 caulk::inplace_function_detail::vtable<int,void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,unsigned int>::vtable<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_5>(caulk::inplace_function_detail::wrapper<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_5>)::{lambda(void *,void *)#2}::__invoke(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  return result;
}

void *caulk::inplace_function_detail::vtable<int,void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,unsigned int>::vtable<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_5>(caulk::inplace_function_detail::wrapper<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_5>)::{lambda(void *,void *)#1}::__invoke(void *result, void *a2)
{
  uint64_t v2 = a2[1];
  *__n128 result = *a2;
  result[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t caulk::inplace_function_detail::vtable<int,void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,unsigned int>::vtable<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_5>(caulk::inplace_function_detail::wrapper<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_5>)::{lambda(void *,void *&&,AudioUnitPluginDispatch const&,unsigned int &&,void *&&,void *&&,void *&&)#1}::__invoke(int **a1, uint64_t *a2, uint64_t a3, int *a4, int *a5, int *a6, int *a7)
{
  v20[6] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *a2;
  int v8 = *a4;
  int v9 = *a5;
  int v10 = *a6;
  int v18 = *a7;
  uint64_t v17 = *(void *)(a3 + 192);
  unsigned int v11 = v8 >> 4;
  if (v11 > 0xF) {
    goto LABEL_9;
  }
  if (((1 << v11) & 0x4F00) == 0)
  {
    if (((1 << v11) & 0x3000) != 0)
    {
      uint64_t v12 = 2;
      goto LABEL_10;
    }
    if (v11 == 15 && v8 > 0xF0u)
    {
      uint64_t v12 = qword_1901DC728[(v8 + 15)];
      goto LABEL_10;
    }
LABEL_9:
    uint64_t v12 = 0;
    goto LABEL_10;
  }
  uint64_t v12 = 3;
LABEL_10:
  v16[0] = v8;
  v16[1] = v9;
  v16[2] = v10;
  unsigned int v15 = 0;
  v13 = *a1;
  v19 = caulk::inplace_function<void ()(MIDI::EventList const*),48ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_5::operator() const(void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,unsigned int)::{lambda(MIDI::EventList const*)#1}>;
  v20[0] = v7;
  v20[1] = &v17;
  v20[2] = &v18;
  v20[3] = &v15;
  MIDI::LegacyMIDIConverter<MIDI::MIDI_1_to_2_Translator>::convertLegacyDataToEventList(v13, (uint64_t)v16, v12, 0, (uint64_t *)&v19);
  ((void (*)(void *))v19[3])(v20);
  return v15;
}

void sub_190158B98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

__n128 caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_5::operator() const(void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,unsigned int)::{lambda(MIDI::EventList const*)#1}>(caulk::inplace_function_detail::wrapper<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_5::operator() const(void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,unsigned int)::{lambda(MIDI::EventList const*)#1}>)::{lambda(void *,void *)#2}::__invoke(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

__n128 caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_5::operator() const(void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,unsigned int)::{lambda(MIDI::EventList const*)#1}>(caulk::inplace_function_detail::wrapper<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_5::operator() const(void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,unsigned int)::{lambda(MIDI::EventList const*)#1}>)::{lambda(void *,void *)#1}::__invoke(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

uint64_t caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_5::operator() const(void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,unsigned int)::{lambda(MIDI::EventList const*)#1}>(caulk::inplace_function_detail::wrapper<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_5::operator() const(void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,unsigned int)::{lambda(MIDI::EventList const*)#1}>)::{lambda(void *,MIDI::EventList const*&&)#1}::__invoke(uint64_t a1, void *a2)
{
  uint64_t result = (**(uint64_t (***)(void, void, void))(a1 + 8))(*(void *)a1, **(unsigned int **)(a1 + 16), *a2);
  **(_DWORD **)(a1 + 24) = result;
  return result;
}

void caulk::inplace_function_detail::vtable<int,void *,AudioUnitPluginDispatch const&,unsigned char const*,unsigned int>::vtable<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_4>(caulk::inplace_function_detail::wrapper<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_4>)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

__n128 caulk::inplace_function_detail::vtable<int,void *,AudioUnitPluginDispatch const&,unsigned char const*,unsigned int>::vtable<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_4>(caulk::inplace_function_detail::wrapper<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_4>)::{lambda(void *,void *)#2}::__invoke(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  return result;
}

void *caulk::inplace_function_detail::vtable<int,void *,AudioUnitPluginDispatch const&,unsigned char const*,unsigned int>::vtable<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_4>(caulk::inplace_function_detail::wrapper<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_4>)::{lambda(void *,void *)#1}::__invoke(void *result, void *a2)
{
  uint64_t v2 = a2[1];
  *__n128 result = *a2;
  result[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t caulk::inplace_function_detail::vtable<int,void *,AudioUnitPluginDispatch const&,unsigned char const*,unsigned int>::vtable<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_4>(caulk::inplace_function_detail::wrapper<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_4>)::{lambda(void *,void *&&,AudioUnitPluginDispatch const&,unsigned char const*&&,unsigned int &&)#1}::__invoke(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t *a4, unsigned int *a5)
{
  v12[6] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *a2;
  uint64_t v6 = *a4;
  uint64_t v7 = *a5;
  unsigned int v10 = 0;
  uint64_t v9 = *(void *)(a3 + 192);
  unsigned int v11 = caulk::inplace_function<void ()(MIDI::EventList const*),48ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_4::operator() const(void *,AudioUnitPluginDispatch const&,unsigned char const*,unsigned int)::{lambda(MIDI::EventList const*)#1}>;
  v12[0] = v5;
  v12[1] = &v9;
  v12[2] = &v10;
  MIDI::LegacyMIDIConverter<MIDI::IdentityTranslator>::convertLegacyDataToEventList(v6, v7, 0, (uint64_t *)&v11);
  ((void (*)(void *))v11[3])(v12);
  return v10;
}

void sub_190158D10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

__n128 caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_4::operator() const(void *,AudioUnitPluginDispatch const&,unsigned char const*,unsigned int)::{lambda(MIDI::EventList const*)#1}>(caulk::inplace_function_detail::wrapper<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_4::operator() const(void *,AudioUnitPluginDispatch const&,unsigned char const*,unsigned int)::{lambda(MIDI::EventList const*)#1}>)::{lambda(void *,void *)#2}::__invoke(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  a1[1].n128_u64[0] = a2[1].n128_u64[0];
  *a1 = result;
  return result;
}

__n128 caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_4::operator() const(void *,AudioUnitPluginDispatch const&,unsigned char const*,unsigned int)::{lambda(MIDI::EventList const*)#1}>(caulk::inplace_function_detail::wrapper<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_4::operator() const(void *,AudioUnitPluginDispatch const&,unsigned char const*,unsigned int)::{lambda(MIDI::EventList const*)#1}>)::{lambda(void *,void *)#1}::__invoke(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  a1[1].n128_u64[0] = a2[1].n128_u64[0];
  *a1 = result;
  return result;
}

uint64_t caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_4::operator() const(void *,AudioUnitPluginDispatch const&,unsigned char const*,unsigned int)::{lambda(MIDI::EventList const*)#1}>(caulk::inplace_function_detail::wrapper<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_4::operator() const(void *,AudioUnitPluginDispatch const&,unsigned char const*,unsigned int)::{lambda(MIDI::EventList const*)#1}>)::{lambda(void *,MIDI::EventList const*&&)#1}::__invoke(uint64_t a1, void *a2)
{
  uint64_t result = (**(uint64_t (***)(void, void, void))(a1 + 8))(*(void *)a1, 0, *a2);
  **(_DWORD **)(a1 + 16) = result;
  return result;
}

void caulk::inplace_function_detail::vtable<int,void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,unsigned int>::vtable<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_3>(caulk::inplace_function_detail::wrapper<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_3>)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

__n128 caulk::inplace_function_detail::vtable<int,void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,unsigned int>::vtable<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_3>(caulk::inplace_function_detail::wrapper<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_3>)::{lambda(void *,void *)#2}::__invoke(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  return result;
}

void *caulk::inplace_function_detail::vtable<int,void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,unsigned int>::vtable<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_3>(caulk::inplace_function_detail::wrapper<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_3>)::{lambda(void *,void *)#1}::__invoke(void *result, void *a2)
{
  uint64_t v2 = a2[1];
  *__n128 result = *a2;
  result[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t caulk::inplace_function_detail::vtable<int,void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,unsigned int>::vtable<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_3>(caulk::inplace_function_detail::wrapper<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_3>)::{lambda(void *,void *&&,AudioUnitPluginDispatch const&,unsigned int &&,void *&&,void *&&,void *&&)#1}::__invoke(uint64_t a1, uint64_t *a2, uint64_t a3, _DWORD *a4, _DWORD *a5, int *a6, int *a7)
{
  v17[6] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *a2;
  char v8 = *a4;
  char v9 = *a5;
  int v10 = *a6;
  int v15 = *a7;
  uint64_t v14 = *(void *)(a3 + 192);
  v13[0] = v8;
  v13[1] = v9;
  v13[2] = v10;
  unsigned int v12 = 0;
  v16 = caulk::inplace_function<void ()(MIDI::EventList const*),48ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_3::operator() const(void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,unsigned int)::{lambda(MIDI::EventList const*)#1}>;
  v17[0] = v7;
  v17[1] = &v14;
  v17[2] = &v15;
  v17[3] = &v12;
  MIDI::LegacyMIDIConverter<MIDI::IdentityTranslator>::convertLegacyDataToEventList((uint64_t)v13, 3, 0, (uint64_t *)&v16);
  ((void (*)(void *))v16[3])(v17);
  return v12;
}

void sub_190158EBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

__n128 caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_3::operator() const(void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,unsigned int)::{lambda(MIDI::EventList const*)#1}>(caulk::inplace_function_detail::wrapper<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_3::operator() const(void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,unsigned int)::{lambda(MIDI::EventList const*)#1}>)::{lambda(void *,void *)#2}::__invoke(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

__n128 caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_3::operator() const(void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,unsigned int)::{lambda(MIDI::EventList const*)#1}>(caulk::inplace_function_detail::wrapper<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_3::operator() const(void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,unsigned int)::{lambda(MIDI::EventList const*)#1}>)::{lambda(void *,void *)#1}::__invoke(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

uint64_t caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_3::operator() const(void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,unsigned int)::{lambda(MIDI::EventList const*)#1}>(caulk::inplace_function_detail::wrapper<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_3::operator() const(void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,unsigned int)::{lambda(MIDI::EventList const*)#1}>)::{lambda(void *,MIDI::EventList const*&&)#1}::__invoke(uint64_t a1, void *a2)
{
  uint64_t result = (**(uint64_t (***)(void, void, void))(a1 + 8))(*(void *)a1, **(unsigned int **)(a1 + 16), *a2);
  **(_DWORD **)(a1 + 24) = result;
  return result;
}

uint64_t caulk::inplace_function_detail::vtable<int,void *,AudioUnitPluginDispatch const&,unsigned char const*,unsigned int>::vtable<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_2>(caulk::inplace_function_detail::wrapper<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_2>)::{lambda(void *,void *&&,AudioUnitPluginDispatch const&,unsigned char const*&&,unsigned int &&)#1}::__invoke(uint64_t a1, void *a2, uint64_t a3, void *a4, unsigned int *a5)
{
  return (*(uint64_t (**)(void, void, void))(a3 + 168))(*a2, *a4, *a5);
}

void caulk::inplace_function_detail::vtable<int,void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,unsigned int>::vtable(void)::{lambda(void *,void *&&,AudioUnitPluginDispatch const&,unsigned int &&,void *&&,void *&&,void *&&)#1}::__invoke()
{
  exception = __cxa_allocate_exception(8uLL);
}

uint64_t caulk::inplace_function_detail::vtable<int,void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,unsigned int>::vtable<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_1>(caulk::inplace_function_detail::wrapper<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_1>)::{lambda(void *,void *&&,AudioUnitPluginDispatch const&,unsigned int &&,void *&&,void *&&,void *&&)#1}::__invoke(uint64_t a1, void *a2, uint64_t a3, unsigned int *a4, unsigned int *a5, unsigned int *a6, unsigned int *a7)
{
  return (*(uint64_t (**)(void, void, void, void, void))(a3 + 160))(*a2, *a4, *a5, *a6, *a7);
}

void caulk::inplace_function_detail::vtable<int,void *,AudioUnitPluginDispatch const&,unsigned char const*,unsigned int>::vtable(void)::{lambda(void *,void *&&,AudioUnitPluginDispatch const&,unsigned char const*&&,unsigned int &&)#1}::__invoke()
{
  exception = __cxa_allocate_exception(8uLL);
}

uint64_t caulk::inplace_function_detail::vtable<int,void *,AudioUnitPluginDispatch const&,unsigned char const*,unsigned int>::vtable<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_0>(caulk::inplace_function_detail::wrapper<APMIDIRouter::init(MIDIProtocolID,AudioUnitPluginDispatch const*)::$_0>)::{lambda(void *,void *&&,AudioUnitPluginDispatch const&,unsigned char const*&&,unsigned int &&)#1}::__invoke(uint64_t a1, void *a2, uint64_t a3, void *a4, unsigned int *a5)
{
  uint64_t v5 = *(uint64_t (**)(void, void, void))(a3 + 168);
  if (v5) {
    return v5(*a2, *a4, *a5);
  }
  else {
    return 4294967292;
  }
}

__n128 caulk::inplace_function_detail::vtable<void,MIDI::LegacyPacketList const*>::vtable<APMIDIRouter::handleMIDIEventList(void *,AudioUnitPluginDispatch const&,unsigned int,MIDIEventList const*)::$_1>(caulk::inplace_function_detail::wrapper<APMIDIRouter::handleMIDIEventList(void *,AudioUnitPluginDispatch const&,unsigned int,MIDIEventList const*)::$_1>)::{lambda(void *,void *)#2}::__invoke(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 caulk::inplace_function_detail::vtable<void,MIDI::LegacyPacketList const*>::vtable<APMIDIRouter::handleMIDIEventList(void *,AudioUnitPluginDispatch const&,unsigned int,MIDIEventList const*)::$_1>(caulk::inplace_function_detail::wrapper<APMIDIRouter::handleMIDIEventList(void *,AudioUnitPluginDispatch const&,unsigned int,MIDIEventList const*)::$_1>)::{lambda(void *,void *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

uint64_t caulk::inplace_function_detail::vtable<void,MIDI::LegacyPacketList const*>::vtable<APMIDIRouter::handleMIDIEventList(void *,AudioUnitPluginDispatch const&,unsigned int,MIDIEventList const*)::$_1>(caulk::inplace_function_detail::wrapper<APMIDIRouter::handleMIDIEventList(void *,AudioUnitPluginDispatch const&,unsigned int,MIDIEventList const*)::$_1>)::{lambda(void *,MIDI::LegacyPacketList const*&&)#1}::__invoke(uint64_t result, unsigned int **a2)
{
  uint64_t v2 = *a2;
  if (**a2)
  {
    long long v3 = (void *)result;
    unsigned int v4 = 0;
    unint64_t v5 = (unint64_t)(v2 + 1);
    do
    {
      uint64_t v6 = *(unsigned __int16 *)(v5 + 8);
      if (*(unsigned __int8 *)(v5 + 10) == 240
        && *(unsigned __int8 *)(v6 + v5 + 9) == 247
        && (uint64_t v7 = *(uint64_t (**)(void))(v3[1] + 168)) != 0)
      {
        __n128 result = v7(*v3);
        *(_DWORD *)v3[4] = result;
      }
      else
      {
        v11[0] = v5 + 10;
        v11[1] = v6;
        v11[2] = *(void *)v5;
        v11[3] = 0;
        while (1)
        {
          v9[1] = 0;
          uint64_t v10 = 0;
          v9[0] = 0;
          int v8 = MIDI::LegacyPacketList::PacketReader::read(v11, &v10, v9);
          __n128 result = *(unsigned int *)v3[4];
          if (!v8 || result) {
            break;
          }
          *(_DWORD *)v3[4] = (*(uint64_t (**)(void, void, void, void, void))v3[2])(*v3, BYTE2(v9[0]), BYTE1(v9[0]), LOBYTE(v9[0]), (*(_DWORD *)v3[3] + v10));
        }
      }
      if (result) {
        break;
      }
      unint64_t v5 = (v5 + *(unsigned __int16 *)(v5 + 8) + 13) & 0xFFFFFFFFFFFFFFFCLL;
      ++v4;
    }
    while (v4 < *v2);
  }
  return result;
}

uint64_t ___ZN12APMIDIRouter17handleSetPropertyEPvRK23AudioUnitPluginDispatchjjjPKvj_block_invoke(uint64_t a1, uint64_t a2, char a3, _DWORD *a4)
{
  v16[102] = *MEMORY[0x1E4F143B8];
  char v8 = a3;
  uint64_t v5 = *(void *)(a1 + 32);
  unsigned int v7 = 0;
  uint64_t v9 = a2;
  uint64_t v10 = _ZN5caulk16inplace_functionIFvPKN4MIDI16LegacyPacketListEELm48ELm8ENS_23inplace_function_detail6vtableEE16k_wrapper_vtableIZZN12APMIDIRouter17handleSetPropertyEPvRK23AudioUnitPluginDispatchjjjPKvjEUb_E4__13EE;
  *(void *)&long long v11 = &v9;
  *((void *)&v11 + 1) = &v7;
  *(void *)&long long v12 = v5;
  *((void *)&v12 + 1) = &v8;
  v13 = _ZN5caulk16inplace_functionIFvPKN4MIDI16LegacyPacketListEELm48ELm8ENS_23inplace_function_detail6vtableEE16k_wrapper_vtableIZZN12APMIDIRouter17handleSetPropertyEPvRK23AudioUnitPluginDispatchjjjPKvjEUb_E4__13EE;
  v14[0] = v11;
  v14[1] = v12;
  MIDI::MIDIPacketList_Deliverer::MIDIPacketList_Deliverer(v15, (uint64_t *)&v13);
  ((void (*)(_OWORD *))v13[3])(v14);
  MIDI::MIDIPacketList_Deliverer::operator()((uint64_t)v15, a4);
  v15[0] = &unk_1EDF95120;
  (*(void (**)(void *))(v15[1] + 24))(v16);
  ((void (*)(long long *))v10[3])(&v11);
  return v7;
}

void sub_1901592E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

uint64_t ___ZN12APMIDIRouter17handleSetPropertyEPvRK23AudioUnitPluginDispatchjjjPKvj_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  unsigned int v4 = a4;
  uint64_t v139 = *(void *)(a1 + 32);
  MIDIProtocolID v5 = *(_DWORD *)(v139 + 16);
  int v6 = *a4;
  if (*a4 != v5)
  {
    v136 = *(int **)(a1 + 40);
    if (v5 != kMIDIProtocol_2_0 || v6 != 1)
    {
      BOOL v11 = v5 == kMIDIProtocol_1_0 && v6 == 2;
      if (v11 && a4[1])
      {
        uint64_t v7 = 0;
        int v12 = 0;
        uint64_t v13 = (uint64_t)(a4 + 2);
        v125 = v136 + 521;
        while (1)
        {
          uint64_t v14 = *(unsigned int *)(v13 + 8);
          v142 = (_DWORD *)(v13 + 12);
          uint64_t v143 = v14;
          uint64_t v132 = v13;
          uint64_t v144 = *(void *)v13;
          uint64_t v145 = 0;
          int v15 = MIDIEventListInit(&evtlist, kMIDIProtocol_1_0);
          time[0] = 0;
          *(void *)words = 0;
          uint64_t v147 = 0;
          while (MIDI::EventList::PacketReader::read((uint64_t *)&v142, time, words))
          {
            unint64_t v16 = (unint64_t)words[0] >> 28;
            if (((1 << v16) & 0xA02F) != 0)
            {
              int v15 = MIDIEventListAdd(&evtlist, 0x114uLL, v15, time[0], MIDI::UniversalPacket::word_sizes[v16], words);
              if (!v15)
              {
                if (!v7) {
                  uint64_t v7 = (*(uint64_t (**)(void))(*(void *)(v139 + 48) + 16))();
                }
                memset(&evtlist, 0, sizeof(evtlist));
                uint64_t v17 = MIDIEventListInit(&evtlist, kMIDIProtocol_1_0);
                MIDITimeStamp v18 = time[0];
                ByteCount v19 = MIDI::UniversalPacket::word_sizes[(unint64_t)words[0] >> 28];
                v20 = words;
                goto LABEL_26;
              }
            }
            else if (v16 == 4)
            {
              UInt32 v22 = HIBYTE(words[0]) & 0xF | 0x20;
              UInt32 v23 = words[1];
              switch(BYTE2(words[0]) >> 4)
              {
                case 2:
                case 3:
                  v26 = &v125[12 * (HIBYTE(words[0]) & 0xF)];
                  unint64_t v27 = ((unint64_t)words[0] >> 16) & 0xF;
                  v28 = (unsigned __int8 *)v26 + 3 * v27;
                  UInt32 v29 = (words[0] >> 8) & 0x7F;
                  int v134 = words[0] & 0x7F;
                  if ((words[0] & 0x100000) != 0) {
                    int v30 = 2;
                  }
                  else {
                    int v30 = 1;
                  }
                  if (v30 == *v28 && v29 == v28[1])
                  {
                    int v31 = v27 | 0xB0;
                    if (v134 == *((unsigned __int8 *)v26 + 3 * v27 + 2))
                    {
                      int v137 = (v31 << 16) | (v22 << 24);
                      MIDITimeStamp v32 = time[0];
                      goto LABEL_62;
                    }
                  }
                  else
                  {
                    int v31 = v27 | 0xB0;
                  }
                  char v126 = v30;
                  v127 = (char *)v26 + 3 * v27;
                  v129 = &v125[12 * (HIBYTE(words[0]) & 0xF)];
                  int v130 = v12;
                  if ((words[0] & 0x100000) != 0) {
                    int v33 = 25344;
                  }
                  else {
                    int v33 = 25856;
                  }
                  char v128 = BYTE1(words[0]) & 0x7F;
                  int v137 = (v22 << 24) | (v31 << 16);
                  *(_OWORD *)v149 = v33 | v29 | v137;
                  v34 = MIDIEventListAdd(&evtlist, 0x114uLL, v15, time[0], 1uLL, v149);
                  if (v34)
                  {
                    v35 = v34;
                    MIDITimeStamp v32 = time[0];
                  }
                  else
                  {
                    if (!v7) {
                      uint64_t v7 = (*(uint64_t (**)(void))(*(void *)(v139 + 48) + 16))();
                    }
                    memset(&evtlist, 0, sizeof(evtlist));
                    v39 = MIDIEventListInit(&evtlist, kMIDIProtocol_1_0);
                    MIDITimeStamp v32 = time[0];
                    v35 = MIDIEventListAdd(&evtlist, 0x114uLL, v39, time[0], MIDI::UniversalPacket::word_sizes[(unint64_t)v149[0] >> 28], v149);
                  }
                  *(_OWORD *)v149 = v137 | (v33 - 256) | v134;
                  v40 = MIDIEventListAdd(&evtlist, 0x114uLL, v35, v32, 1uLL, v149);
                  if (!v40)
                  {
                    if (!v7) {
                      uint64_t v7 = (*(uint64_t (**)(void))(*(void *)(v139 + 48) + 16))();
                    }
                    memset(&evtlist, 0, sizeof(evtlist));
                    v41 = MIDIEventListInit(&evtlist, kMIDIProtocol_1_0);
                    v40 = MIDIEventListAdd(&evtlist, 0x114uLL, v41, v32, MIDI::UniversalPacket::word_sizes[(unint64_t)v149[0] >> 28], v149);
                  }
                  int v15 = v40;
                  int v12 = v130;
                  unsigned char *v127 = v126;
                  uint64_t v42 = (uint64_t)v129 + 3 * v27;
                  *(unsigned char *)(v42 + 1) = v128;
                  *(unsigned char *)(v42 + 2) = v134;
LABEL_62:
                  *(_OWORD *)v149 = v137 | (v23 >> 25) | 0x600;
                  v43 = MIDIEventListAdd(&evtlist, 0x114uLL, v15, v32, 1uLL, v149);
                  if (!v43)
                  {
                    if (!v7) {
                      uint64_t v7 = (*(uint64_t (**)(void))(*(void *)(v139 + 48) + 16))();
                    }
                    memset(&evtlist, 0, sizeof(evtlist));
                    v44 = MIDIEventListInit(&evtlist, kMIDIProtocol_1_0);
                    v43 = MIDIEventListAdd(&evtlist, 0x114uLL, v44, time[0], MIDI::UniversalPacket::word_sizes[(unint64_t)v149[0] >> 28], v149);
                  }
                  int v15 = v43;
                  unsigned int v4 = a4;
                  int v45 = (v23 >> 18) & 0x7F;
                  if (v45)
                  {
                    *(_OWORD *)v149 = v45 | v137 | 0x2600u;
                    MIDITimeStamp v46 = time[0];
                    v47 = MIDIEventListAdd(&evtlist, 0x114uLL, v43, time[0], 1uLL, v149);
                    if (!v47)
                    {
                      if (!v7) {
                        uint64_t v7 = (*(uint64_t (**)(void))(*(void *)(v139 + 48) + 16))();
                      }
                      memset(&evtlist, 0, sizeof(evtlist));
                      v48 = MIDIEventListInit(&evtlist, kMIDIProtocol_1_0);
                      v47 = MIDIEventListAdd(&evtlist, 0x114uLL, v48, v46, MIDI::UniversalPacket::word_sizes[(unint64_t)v149[0] >> 28], v149);
                    }
                    goto LABEL_83;
                  }
                  continue;
                case 8:
                case 9:
                case 10:
                case 11:
                  UInt32 v24 = BYTE2(words[0]) >> 4 == 9;
                  if (words[1] >> 25) {
                    UInt32 v24 = words[1] >> 25;
                  }
                  v149[3] = 0;
                  *(void *)&v149[1] = 0;
                  UInt32 v25 = words[0] & 0x7F00 | (BYTE2(words[0]) << 16) | (v22 << 24) | v24;
                  goto LABEL_33;
                case 12:
                  UInt32 v36 = v22 << 24;
                  if (words[0])
                  {
                    UInt32 v138 = v22 << 24;
                    int v131 = v12;
                    int v37 = BYTE2(words[0]) << 16;
                    unint64_t v49 = (v37 - 0x100000) | (v22 << 24);
                    *(_OWORD *)v149 = (v37 - 0x100000) & 0xFFFFFF80 | (v22 << 24) | (words[1] >> 8) & 0x7F;
                    v50 = v15;
                    ByteCount v51 = MIDI::UniversalPacket::word_sizes[v49 >> 28];
                    v52 = MIDIEventListAdd(&evtlist, 0x114uLL, v50, time[0], v51, v149);
                    if (v52)
                    {
                      v53 = v52;
                      MIDITimeStamp v38 = time[0];
                    }
                    else
                    {
                      if (!v7) {
                        uint64_t v7 = (*(uint64_t (**)(void))(*(void *)(v139 + 48) + 16))();
                      }
                      memset(&evtlist, 0, sizeof(evtlist));
                      v54 = MIDIEventListInit(&evtlist, kMIDIProtocol_1_0);
                      MIDITimeStamp v38 = time[0];
                      v53 = MIDIEventListAdd(&evtlist, 0x114uLL, v54, time[0], MIDI::UniversalPacket::word_sizes[(unint64_t)v149[0] >> 28], v149);
                    }
                    *(_OWORD *)v149 = v49 | v23 & 0x7F | 0x2000;
                    v55 = MIDIEventListAdd(&evtlist, 0x114uLL, v53, v38, v51, v149);
                    if (v55)
                    {
                      int v15 = v55;
                      int v12 = v131;
                    }
                    else
                    {
                      int v12 = v131;
                      if (!v7) {
                        uint64_t v7 = (*(uint64_t (**)(void))(*(void *)(v139 + 48) + 16))();
                      }
                      memset(&evtlist, 0, sizeof(evtlist));
                      v56 = MIDIEventListInit(&evtlist, kMIDIProtocol_1_0);
                      int v15 = MIDIEventListAdd(&evtlist, 0x114uLL, v56, v38, MIDI::UniversalPacket::word_sizes[(unint64_t)v149[0] >> 28], v149);
                    }
                    UInt32 v36 = v138;
                  }
                  else
                  {
                    int v37 = BYTE2(words[0]) << 16;
                    MIDITimeStamp v38 = time[0];
                  }
                  *(_OWORD *)v149 = v37 | v36 | HIWORD(v23) & 0x7F00;
                  v47 = MIDIEventListAdd(&evtlist, 0x114uLL, v15, v38, 1uLL, v149);
                  if (v47)
                  {
LABEL_83:
                    int v15 = v47;
                    unsigned int v4 = a4;
                    continue;
                  }
                  unsigned int v4 = a4;
                  if (!v7) {
LABEL_35:
                  }
                    uint64_t v7 = (*(uint64_t (**)(void))(*(void *)(v139 + 48) + 16))();
LABEL_36:
                  memset(&evtlist, 0, sizeof(evtlist));
                  uint64_t v17 = MIDIEventListInit(&evtlist, kMIDIProtocol_1_0);
                  MIDITimeStamp v18 = time[0];
                  ByteCount v19 = MIDI::UniversalPacket::word_sizes[(unint64_t)v149[0] >> 28];
                  v20 = v149;
                  break;
                case 13:
                  v149[3] = 0;
                  *(void *)&v149[1] = 0;
                  UInt32 v25 = (BYTE2(words[0]) << 16) | (v22 << 24) | (words[1] >> 25 << 8);
                  goto LABEL_33;
                case 14:
                  v149[3] = 0;
                  *(void *)&v149[1] = 0;
                  UInt32 v25 = (words[1] >> 10) & 0x7F00 | (words[1] >> 25) | (BYTE2(words[0]) << 16) | (v22 << 24);
LABEL_33:
                  v149[0] = v25;
                  v21 = MIDIEventListAdd(&evtlist, 0x114uLL, v15, time[0], 1uLL, v149);
                  if (v21) {
                    goto LABEL_27;
                  }
                  if (!v7) {
                    goto LABEL_35;
                  }
                  goto LABEL_36;
                default:
                  continue;
              }
LABEL_26:
              v21 = MIDIEventListAdd(&evtlist, 0x114uLL, v17, v18, v19, v20);
LABEL_27:
              int v15 = v21;
            }
          }
          if (evtlist.numPackets) {
            BOOL v57 = v7 == 0;
          }
          else {
            BOOL v57 = 0;
          }
          if (v57) {
            uint64_t v7 = (*(uint64_t (**)(void))(*(void *)(v139 + 48) + 16))();
          }
          uint64_t v13 = v132 + 4 * *(unsigned int *)(v132 + 8) + 12;
          if (++v12 >= v4[1]) {
            return v7;
          }
        }
      }
      return 0;
    }
    if (!a4[1]) {
      return 0;
    }
    uint64_t v7 = 0;
    int v64 = 0;
    v65 = a4 + 2;
    v133 = v136 + 4;
LABEL_111:
    uint64_t v66 = v65[2];
    v142 = v65 + 3;
    uint64_t v143 = v66;
    uint64_t v144 = *(void *)v65;
    uint64_t v145 = 0;
    v67 = MIDIEventListInit(&evtlist, kMIDIProtocol_2_0);
    time[1] = 0;
    MIDITimeStamp v141 = 0;
    time[0] = 0;
    while (1)
    {
      while (1)
      {
LABEL_112:
        if (!MIDI::EventList::PacketReader::read((uint64_t *)&v142, &v141, time))
        {
          if (evtlist.numPackets) {
            BOOL v124 = v7 == 0;
          }
          else {
            BOOL v124 = 0;
          }
          if (v124) {
            uint64_t v7 = (*(uint64_t (**)(void))(*(void *)(v139 + 48) + 16))();
          }
          v65 += v65[2] + 3;
          if (++v64 >= v4[1]) {
            return v7;
          }
          goto LABEL_111;
        }
        unint64_t v68 = LODWORD(time[0]);
        if (LODWORD(time[0]) >> 28 == 2) {
          break;
        }
        v67 = MIDIEventListAdd(&evtlist, 0x114uLL, v67, v141, MIDI::UniversalPacket::word_sizes[(unint64_t)LODWORD(time[0]) >> 28], (const UInt32 *)time);
        if (!v67)
        {
          if (!v7) {
            uint64_t v7 = (*(uint64_t (**)(void))(*(void *)(v139 + 48) + 16))();
          }
          memset(&evtlist, 0, sizeof(evtlist));
          v69 = MIDIEventListInit(&evtlist, kMIDIProtocol_2_0);
          MIDITimeStamp v70 = v141;
          ByteCount v71 = MIDI::UniversalPacket::word_sizes[(unint64_t)LODWORD(time[0]) >> 28];
          v72 = (const UInt32 *)time;
          goto LABEL_219;
        }
      }
      *(void *)words = 0;
      uint64_t v147 = 0;
      int v73 = BYTE2(time[0]);
      int v74 = *((unsigned __int8 *)v136 + 32);
      int v75 = *v136;
      int v76 = BYTE2(time[0]) >> 4;
      if (!*((unsigned char *)v136 + 32))
      {
        if ((v75 & 0xFF0000) != 0)
        {
          if (((v75 ^ LODWORD(time[0])) & 0xF0000) != 0)
          {
            int v74 = 1;
            *((unsigned char *)v136 + 32) = 1;
            goto LABEL_119;
          }
          if (v76 != 11)
          {
            int v74 = (v75 & 0xDF00) != 0 || v76 != 12;
            goto LABEL_119;
          }
          switch(BYTE1(v75))
          {
            case 'b':
              int v109 = time[0] & 0xFF00;
              int v110 = 25344;
              goto LABEL_224;
            case 'c':
              int v109 = time[0] & 0xFF00;
              int v110 = 25088;
              goto LABEL_224;
            case 'd':
              int v109 = time[0] & 0xFF00;
              int v110 = 25856;
              goto LABEL_224;
            case 'e':
              int v109 = time[0] & 0xFF00;
              int v110 = 25600;
LABEL_224:
              if (v109 != v110 && (time[0] & 0xF0DF00) != 0xB00600) {
                break;
              }
              goto LABEL_228;
            default:
              if (BYTE1(v75) == 32)
              {
                if ((time[0] & 0xFF00) != 0) {
                  break;
                }
LABEL_228:
                int v74 = 0;
                _OWORD *v133 = *(_OWORD *)time;
                goto LABEL_119;
              }
              if (!BYTE1(v75) && (time[0] & 0xFF00) == 0x2000) {
                goto LABEL_228;
              }
              break;
          }
        }
        else
        {
          int v74 = 1;
          if ((time[0] & 0xF00000) != 0xB00000 || v76 != 11) {
            goto LABEL_119;
          }
          if (BYTE1(time[0]) - 98 < 4 || BYTE1(time[0]) == 32 || !BYTE1(time[0]))
          {
            int v74 = 0;
            *(_OWORD *)v136 = *(_OWORD *)time;
            int v75 = *v136;
            goto LABEL_119;
          }
        }
        int v74 = 1;
      }
LABEL_119:
      uint64_t v77 = BYTE3(v68) & 0xF;
      unsigned int v78 = BYTE3(v68) & 0xF | 0x40;
      if (BYTE2(v75) && v74)
      {
        *((unsigned char *)v136 + 32) = 1;
        *(void *)&v149[2] = 0;
        v149[0] = v75 & 0xFF00 | (BYTE2(v75) << 16) & 0x80FFFFFF | ((BYTE3(v68) & 0xF | 0x40) << 24);
        unsigned int v79 = v75;
        UInt32 v80 = v75 << 25;
        if (v79 >= 0x41)
        {
          unsigned int v81 = (v79 & 0x3F) << 19;
          if (v81)
          {
            do
            {
              v80 |= v81;
              BOOL v82 = v81 > 0x3F;
              v81 >>= 6;
            }
            while (v82);
          }
        }
        v149[1] = v80;
        v83 = MIDIEventListAdd(&evtlist, 0x114uLL, v67, v141, 2uLL, v149);
        if (!v83)
        {
          if (!v7) {
            uint64_t v7 = (*(uint64_t (**)(void))(*(void *)(v139 + 48) + 16))();
          }
          memset(&evtlist, 0, sizeof(evtlist));
          v84 = MIDIEventListInit(&evtlist, kMIDIProtocol_2_0);
          v83 = MIDIEventListAdd(&evtlist, 0x114uLL, v84, v141, MIDI::UniversalPacket::word_sizes[(unint64_t)v149[0] >> 28], v149);
        }
        v67 = v83;
        int v76 = BYTE2(v68) >> 4;
        int *v136 = 0;
        *(void *)&v149[2] = 0;
        int v85 = v136[4];
        if (BYTE2(v85))
        {
          LOWORD(v149[0]) = v85 & 0xFF00;
          BYTE2(v149[0]) = BYTE2(v85);
          HIBYTE(v149[0]) = BYTE3(v68) & 0xF | 0x40;
          unsigned int v86 = v85;
          UInt32 v87 = v85 << 25;
          if (v86 >= 0x41)
          {
            unsigned int v88 = (v86 & 0x3F) << 19;
            if (v88)
            {
              do
              {
                v87 |= v88;
                BOOL v82 = v88 > 0x3F;
                v88 >>= 6;
              }
              while (v82);
            }
          }
          v149[1] = v87;
          MIDITimeStamp v89 = v141;
          v90 = MIDIEventListAdd(&evtlist, 0x114uLL, v83, v141, 2uLL, v149);
          if (!v90)
          {
            if (!v7) {
              uint64_t v7 = (*(uint64_t (**)(void))(*(void *)(v139 + 48) + 16))();
            }
            memset(&evtlist, 0, sizeof(evtlist));
            v91 = MIDIEventListInit(&evtlist, kMIDIProtocol_2_0);
            v90 = MIDIEventListAdd(&evtlist, 0x114uLL, v91, v89, MIDI::UniversalPacket::word_sizes[(unint64_t)v149[0] >> 28], v149);
          }
          v67 = v90;
          *(_DWORD *)v133 = 0;
          unsigned int v4 = a4;
          int v73 = BYTE2(v68);
          int v76 = BYTE2(v68) >> 4;
        }
        else
        {
          int v73 = BYTE2(v68);
        }
        *(void *)((char *)&v136[32 * v77 + 8 + 2 * ((v68 >> 16) & 0xF)] + 1) = 0;
      }
      unsigned int v92 = (v68 >> 8) & 0x7F;
      unsigned int v93 = v68 & 0x7F;
      switch(v76)
      {
        case 8:
          goto LABEL_145;
        case 9:
          if ((v68 & 0x7F) == 0)
          {
            v73 -= 16;
            unsigned int v93 = 64;
          }
LABEL_145:
          UInt32 v94 = (v78 << 24) | (v73 << 16) | (v92 << 8);
          words[0] = v94;
          unsigned int v95 = v93 << 9;
          if (v93 >= 0x41)
          {
            unsigned int v96 = 8 * (v93 & 0x3F);
            if (v96)
            {
              do
              {
                v95 |= v96;
                BOOL v82 = v96 > 0x3F;
                v96 >>= 6;
              }
              while (v82);
            }
          }
          UInt32 v97 = v95 << 16;
          goto LABEL_214;
        case 10:
          UInt32 v94 = (v73 << 16) | (v78 << 24) | (v92 << 8);
          words[0] = v94;
          UInt32 v97 = v68 << 25;
          if (v93 >= 0x41)
          {
            unsigned int v98 = (v68 & 0x3F) << 19;
            if (v98)
            {
              do
              {
                v97 |= v98;
                BOOL v82 = v98 > 0x3F;
                v98 >>= 6;
              }
              while (v82);
            }
          }
          goto LABEL_214;
        case 11:
          int v99 = v73;
          uint64_t v100 = (uint64_t)&v136[32 * v77 + 8] + 1;
          uint64_t v101 = (v68 >> 16) & 0xF;
          if (((v68 >> 8) & 0x7F) > 0x25)
          {
            switch(v92)
            {
              case 'b':
                uint64_t v111 = v100 + 8 * v101;
                *(unsigned char *)(v111 + 1) = 2;
                goto LABEL_207;
              case 'c':
                uint64_t v121 = v100 + 8 * v101;
                *(unsigned char *)(v121 + 1) = 2;
                goto LABEL_209;
              case 'd':
                uint64_t v111 = v100 + 8 * v101;
                *(unsigned char *)(v111 + 1) = 1;
LABEL_207:
                *(unsigned char *)(v111 + 5) = v93;
                break;
              case 'e':
                uint64_t v121 = v100 + 8 * v101;
                *(unsigned char *)(v121 + 1) = 1;
LABEL_209:
                *(unsigned char *)(v121 + 4) = v93;
                break;
              default:
                if (v92 != 38) {
                  goto LABEL_211;
                }
                char v113 = v68 & 0x7F;
                int v114 = v68 & 0x7F;
                goto LABEL_196;
            }
            goto LABEL_210;
          }
          if (!v92)
          {
            *(unsigned char *)(v100 + 8 * v101 + 2) = v93;
            goto LABEL_192;
          }
          if (v92 != 6)
          {
            if (v92 != 32) {
              goto LABEL_211;
            }
            *(unsigned char *)(v100 + 8 * v101 + 3) = v93;
LABEL_192:
            *(unsigned char *)(v100 + 8 * v101) = 1;
LABEL_210:
            if (!*((unsigned char *)v136 + 32)) {
              goto LABEL_112;
            }
            goto LABEL_211;
          }
          char v113 = 0;
          int v114 = 0;
          *(unsigned char *)(v100 + 8 * v101 + 6) = v93;
LABEL_196:
          uint64_t v115 = v100 + 8 * v101;
          *(unsigned char *)(v115 + 7) = v113;
          if (!*((unsigned char *)v136 + 32) && *(unsigned char *)(v115 + 1))
          {
            if (*(unsigned char *)(v115 + 1) == 1) {
              int v116 = 32;
            }
            else {
              int v116 = 48;
            }
            v117 = (unsigned __int8 *)(v100 + 8 * v101);
            UInt32 v94 = (v78 << 24) | ((v116 | v101) << 16) | (v117[4] << 8) | v117[5];
            words[0] = v94;
            unsigned int v118 = v114 | (v117[6] << 7);
            UInt32 v119 = v118 << 18;
            if (v118 > 0x2000)
            {
              for (unsigned int i = 32 * (v118 & 0x1FFF); i; i >>= 13)
                v119 |= i;
            }
            words[1] = v119;
            *(_OWORD *)v136 = 0u;
            *((_OWORD *)v136 + 1) = 0u;
            goto LABEL_215;
          }
LABEL_211:
          UInt32 v94 = (v99 << 16) | (v78 << 24) | (v92 << 8);
          words[0] = v94;
          UInt32 v97 = v68 << 25;
          if (v93 >= 0x41)
          {
            unsigned int v122 = (v68 & 0x3F) << 19;
            if (v122)
            {
              do
              {
                v97 |= v122;
                BOOL v82 = v122 > 0x3F;
                v122 >>= 6;
              }
              while (v82);
            }
          }
LABEL_214:
          words[1] = v97;
LABEL_215:
          v123 = MIDIEventListAdd(&evtlist, 0x114uLL, v67, v141, MIDI::UniversalPacket::word_sizes[(unint64_t)v94 >> 28], words);
          if (v123) {
            goto LABEL_220;
          }
          if (!v7) {
            uint64_t v7 = (*(uint64_t (**)(void))(*(void *)(v139 + 48) + 16))();
          }
          memset(&evtlist, 0, sizeof(evtlist));
          v69 = MIDIEventListInit(&evtlist, kMIDIProtocol_2_0);
          MIDITimeStamp v70 = v141;
          ByteCount v71 = MIDI::UniversalPacket::word_sizes[(unint64_t)words[0] >> 28];
          v72 = words;
          break;
        case 12:
          v102 = &v136[32 * v77 + 2 * (WORD1(v68) & 0xF)];
          int v103 = v73;
          unsigned __int8 v104 = *((unsigned char *)v136 + 32) ^ 1;
          if (!*((unsigned char *)v102 + 33)) {
            unsigned __int8 v104 = 0;
          }
          UInt32 v94 = (v103 << 16) | (v78 << 24) | v104;
          words[0] = v94;
          HIBYTE(words[1]) = BYTE1(v68) & 0x7F;
          BYTE1(words[1]) = *((unsigned char *)v102 + 35);
          LOBYTE(words[1]) = *((unsigned char *)v102 + 36);
          *(void *)((char *)v102 + 33) = 0;
          *(_OWORD *)v136 = 0u;
          *((_OWORD *)v136 + 1) = 0u;
          goto LABEL_215;
        case 13:
          UInt32 v94 = (v73 << 16) | (v78 << 24);
          words[0] = v94;
          unsigned int v105 = v68 >> 8 << 25;
          if (v92 >= 0x41)
          {
            unsigned int v106 = ((v68 >> 8) & 0x3F) << 19;
            if (v106)
            {
              do
              {
                v105 |= v106;
                BOOL v82 = v106 > 0x3F;
                v106 >>= 6;
              }
              while (v82);
            }
          }
          words[1] = v105;
          goto LABEL_215;
        case 14:
          UInt32 v94 = (v73 << 16) | (v78 << 24);
          words[0] = v94;
          unsigned int v107 = v92 | (v93 << 7);
          UInt32 v97 = v107 << 18;
          if (v107 > 0x2000)
          {
            for (unsigned int j = 32 * (v107 & 0x1FFF); j; j >>= 13)
              v97 |= j;
          }
          goto LABEL_214;
        default:
          UInt32 v94 = words[0];
          goto LABEL_215;
      }
LABEL_219:
      v123 = MIDIEventListAdd(&evtlist, 0x114uLL, v69, v70, v71, v72);
LABEL_220:
      v67 = v123;
    }
  }
  uint64_t v7 = a4[1];
  if (!v7) {
    return v7;
  }
  if (v7 != 1 || a4[4] > 0x40u)
  {
    uint64_t v7 = 0;
    unsigned int v58 = 0;
    v59 = a4 + 2;
    do
    {
      uint64_t v60 = v59[2];
      v142 = v59 + 3;
      uint64_t v143 = v60;
      uint64_t v144 = *(void *)v59;
      uint64_t v145 = 0;
      v61 = MIDIEventListInit(&evtlist, v5);
      *(void *)words = 0;
      *(_OWORD *)v149 = 0uLL;
      while (MIDI::EventList::PacketReader::read((uint64_t *)&v142, words, v149))
      {
        v61 = MIDIEventListAdd(&evtlist, 0x114uLL, v61, *(MIDITimeStamp *)words, MIDI::UniversalPacket::word_sizes[(unint64_t)v149[0] >> 28], v149);
        if (!v61)
        {
          if (!v7) {
            uint64_t v7 = (*(uint64_t (**)(void))(*(void *)(v139 + 48) + 16))();
          }
          memset(&evtlist, 0, sizeof(evtlist));
          v62 = MIDIEventListInit(&evtlist, v5);
          v61 = MIDIEventListAdd(&evtlist, 0x114uLL, v62, *(MIDITimeStamp *)words, MIDI::UniversalPacket::word_sizes[(unint64_t)v149[0] >> 28], v149);
        }
      }
      if (evtlist.numPackets) {
        BOOL v63 = v7 == 0;
      }
      else {
        BOOL v63 = 0;
      }
      if (v63) {
        uint64_t v7 = (*(uint64_t (**)(void))(*(void *)(v139 + 48) + 16))();
      }
      v59 += v59[2] + 3;
      ++v58;
    }
    while (v58 < a4[1]);
    return v7;
  }
  char v8 = *(uint64_t (**)(void))(*(void *)(v139 + 48) + 16);
  return v8();
}

uint64_t APMIDIRouter::handleSetProperty(void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,void const*,unsigned int)::$_2::__invoke(uint64_t a1, uint64_t a2, int a3, unsigned int *a4)
{
  v16[6] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  int v13 = a3;
  uint64_t v12 = a1;
  unsigned int v11 = 0;
  if (!*a4) {
    return 0;
  }
  unsigned int v5 = 0;
  unint64_t v6 = (unint64_t)(a4 + 1);
  do
  {
    uint64_t v7 = *(int **)(v12 + 88);
    uint64_t v8 = *(unsigned __int16 *)(v6 + 8);
    uint64_t v9 = *(void *)v6;
    int v15 = caulk::inplace_function<void ()(MIDI::EventList const*),48ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<APMIDIRouter::handleSetProperty(void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,void const*,unsigned int)::$_2::operator() const(void *,AudioTimeStamp const*,unsigned int,MIDIPacketList const*)::{lambda(MIDIPacket const*)#1}::operator() const(MIDIPacket const*)::{lambda(MIDI::EventList const*)#1}>;
    v16[0] = &v11;
    v16[1] = &v12;
    v16[2] = &v14;
    unsigned char v16[3] = &v13;
    MIDI::LegacyMIDIConverter<MIDI::MIDI_1_to_2_Translator>::convertLegacyDataToEventList(v7, v6 + 10, v8, v9, (uint64_t *)&v15);
    ((void (*)(void *))v15[3])(v16);
    unint64_t v6 = (v6 + *(unsigned __int16 *)(v6 + 8) + 13) & 0xFFFFFFFFFFFFFFFCLL;
    ++v5;
  }
  while (v5 < *a4);
  return v11;
}

void sub_19015A980(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

__n128 caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<APMIDIRouter::handleSetProperty(void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,void const*,unsigned int)::$_2::operator() const(void *,AudioTimeStamp const*,unsigned int,MIDIPacketList const*)::{lambda(MIDIPacket const*)#1}::operator() const(MIDIPacket const*)::{lambda(MIDI::EventList const*)#1}>(caulk::inplace_function_detail::wrapper<APMIDIRouter::handleSetProperty(void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,void const*,unsigned int)::$_2::operator() const(void *,AudioTimeStamp const*,unsigned int,MIDIPacketList const*)::{lambda(MIDIPacket const*)#1}::operator() const(MIDIPacket const*)::{lambda(MIDI::EventList const*)#1}>)::{lambda(void *,void *)#2}::__invoke(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

__n128 caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<APMIDIRouter::handleSetProperty(void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,void const*,unsigned int)::$_2::operator() const(void *,AudioTimeStamp const*,unsigned int,MIDIPacketList const*)::{lambda(MIDIPacket const*)#1}::operator() const(MIDIPacket const*)::{lambda(MIDI::EventList const*)#1}>(caulk::inplace_function_detail::wrapper<APMIDIRouter::handleSetProperty(void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,void const*,unsigned int)::$_2::operator() const(void *,AudioTimeStamp const*,unsigned int,MIDIPacketList const*)::{lambda(MIDIPacket const*)#1}::operator() const(MIDIPacket const*)::{lambda(MIDI::EventList const*)#1}>)::{lambda(void *,void *)#1}::__invoke(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

uint64_t caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<APMIDIRouter::handleSetProperty(void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,void const*,unsigned int)::$_2::operator() const(void *,AudioTimeStamp const*,unsigned int,MIDIPacketList const*)::{lambda(MIDIPacket const*)#1}::operator() const(MIDIPacket const*)::{lambda(MIDI::EventList const*)#1}>(caulk::inplace_function_detail::wrapper<APMIDIRouter::handleSetProperty(void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,void const*,unsigned int)::$_2::operator() const(void *,AudioTimeStamp const*,unsigned int,MIDIPacketList const*)::{lambda(MIDIPacket const*)#1}::operator() const(MIDIPacket const*)::{lambda(MIDI::EventList const*)#1}>)::{lambda(void *,MIDI::EventList const*&&)#1}::__invoke(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(**(void **)(a1 + 8) + 48) + 16))();
  **(_DWORD **)a1 = result;
  return result;
}

uint64_t APMIDIRouter::handleSetProperty(void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,void const*,unsigned int)::$_1::__invoke(uint64_t a1, uint64_t a2, int a3, unsigned int *a4)
{
  v15[6] = *MEMORY[0x1E4F143B8];
  uint64_t v13 = a2;
  int v12 = a3;
  uint64_t v11 = a1;
  unsigned int v10 = 0;
  if (!*a4) {
    return 0;
  }
  unsigned int v5 = 0;
  unint64_t v6 = (unint64_t)(a4 + 1);
  do
  {
    uint64_t v7 = *(unsigned __int16 *)(v6 + 8);
    uint64_t v8 = *(void *)v6;
    uint64_t v14 = caulk::inplace_function<void ()(MIDI::EventList const*),48ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<APMIDIRouter::handleSetProperty(void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,void const*,unsigned int)::$_1::operator() const(void *,AudioTimeStamp const*,unsigned int,MIDIPacketList const*)::{lambda(MIDIPacket const*)#1}::operator() const(MIDIPacket const*)::{lambda(MIDI::EventList const*)#1}>;
    v15[0] = &v10;
    v15[1] = &v11;
    void v15[2] = &v13;
    v15[3] = &v12;
    MIDI::LegacyMIDIConverter<MIDI::IdentityTranslator>::convertLegacyDataToEventList(v6 + 10, v7, v8, (uint64_t *)&v14);
    ((void (*)(void *))v14[3])(v15);
    unint64_t v6 = (v6 + *(unsigned __int16 *)(v6 + 8) + 13) & 0xFFFFFFFFFFFFFFFCLL;
    ++v5;
  }
  while (v5 < *a4);
  return v10;
}

void sub_19015AB38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

__n128 caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<APMIDIRouter::handleSetProperty(void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,void const*,unsigned int)::$_1::operator() const(void *,AudioTimeStamp const*,unsigned int,MIDIPacketList const*)::{lambda(MIDIPacket const*)#1}::operator() const(MIDIPacket const*)::{lambda(MIDI::EventList const*)#1}>(caulk::inplace_function_detail::wrapper<APMIDIRouter::handleSetProperty(void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,void const*,unsigned int)::$_1::operator() const(void *,AudioTimeStamp const*,unsigned int,MIDIPacketList const*)::{lambda(MIDIPacket const*)#1}::operator() const(MIDIPacket const*)::{lambda(MIDI::EventList const*)#1}>)::{lambda(void *,void *)#2}::__invoke(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

__n128 caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<APMIDIRouter::handleSetProperty(void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,void const*,unsigned int)::$_1::operator() const(void *,AudioTimeStamp const*,unsigned int,MIDIPacketList const*)::{lambda(MIDIPacket const*)#1}::operator() const(MIDIPacket const*)::{lambda(MIDI::EventList const*)#1}>(caulk::inplace_function_detail::wrapper<APMIDIRouter::handleSetProperty(void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,void const*,unsigned int)::$_1::operator() const(void *,AudioTimeStamp const*,unsigned int,MIDIPacketList const*)::{lambda(MIDIPacket const*)#1}::operator() const(MIDIPacket const*)::{lambda(MIDI::EventList const*)#1}>)::{lambda(void *,void *)#1}::__invoke(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

uint64_t caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<APMIDIRouter::handleSetProperty(void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,void const*,unsigned int)::$_1::operator() const(void *,AudioTimeStamp const*,unsigned int,MIDIPacketList const*)::{lambda(MIDIPacket const*)#1}::operator() const(MIDIPacket const*)::{lambda(MIDI::EventList const*)#1}>(caulk::inplace_function_detail::wrapper<APMIDIRouter::handleSetProperty(void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,void const*,unsigned int)::$_1::operator() const(void *,AudioTimeStamp const*,unsigned int,MIDIPacketList const*)::{lambda(MIDIPacket const*)#1}::operator() const(MIDIPacket const*)::{lambda(MIDI::EventList const*)#1}>)::{lambda(void *,MIDI::EventList const*&&)#1}::__invoke(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(**(void **)(a1 + 8) + 48) + 16))();
  **(_DWORD **)a1 = result;
  return result;
}

uint64_t APMIDIRouter::handleSetProperty(void *,AudioUnitPluginDispatch const&,unsigned int,unsigned int,unsigned int,void const*,unsigned int)::$_0::__invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))(*(void *)(a1 + 40));
}

__n128 _ZZN5caulk23inplace_function_detail6vtableIvJPKN4MIDI16LegacyPacketListEEEC1IZZN12APMIDIRouter17handleSetPropertyEPvRK23AudioUnitPluginDispatchjjjPKvjEUb_E4__13EENS0_7wrapperIT_EEENUlS9_S9_E0_8__invokeES9_S9_(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

__n128 _ZZN5caulk23inplace_function_detail6vtableIvJPKN4MIDI16LegacyPacketListEEEC1IZZN12APMIDIRouter17handleSetPropertyEPvRK23AudioUnitPluginDispatchjjjPKvjEUb_E4__13EENS0_7wrapperIT_EEENUlS9_S9_E_8__invokeES9_S9_(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

uint64_t _ZZN5caulk23inplace_function_detail6vtableIvJPKN4MIDI16LegacyPacketListEEEC1IZZN12APMIDIRouter17handleSetPropertyEPvRK23AudioUnitPluginDispatchjjjPKvjEUb_E4__13EENS0_7wrapperIT_EEENUlS9_OS5_E_8__invokeES9_SJ_(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  long long v3 = *(_DWORD **)(result + 8);
  uint64_t v4 = **(void **)result;
  int v11 = 1;
  uint64_t v5 = *(void *)(result + 16);
  double v7 = (double)v4;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  if (!*v3)
  {
    uint64_t v6 = result;
    __n128 result = (*(uint64_t (**)(void, double *, void, uint64_t))(v5 + 32))(*(void *)(v5 + 40), &v7, **(unsigned __int8 **)(result + 24), v2);
    **(_DWORD **)(v6 + 8) = result;
  }
  return result;
}

uint64_t APAC::MetadataBitStreamParser::parse(unint64_t a1, unint64_t a2, unsigned int a3, uint64_t a4)
{
  v65[0] = a2;
  v65[1] = a2;
  unint64_t v6 = a2 + a3;
  v65[2] = v6;
  if ((a2 & 3) != 0)
  {
    int v7 = 0;
    uint64_t v8 = ((a2 ^ 3) & 3) + 1;
    unint64_t v9 = a2 + 1;
    int v10 = 8 * ((a2 ^ 3) & 3) + 8;
    int v11 = (unsigned __int8 *)a2;
    do
    {
      if ((unint64_t)v11 >= v6) {
        int v12 = 255;
      }
      else {
        int v12 = *v11;
      }
      int v7 = v12 | (v7 << 8);
      ++v11;
    }
    while ((v9++ & 3) != 0);
    uint64_t v14 = (unsigned int *)(a2 + v8);
    int v67 = 8 * ((a2 ^ 3) & 3) + 8;
    v65[0] = a2 + v8;
    unsigned int v15 = v7 << ((8 * ((a2 ^ 3) & 3)) ^ 0x18);
  }
  else
  {
    unsigned int v15 = 0;
    int v10 = 0;
    uint64_t v14 = (unsigned int *)a2;
  }
  if (v10 + 8 * ((int)v6 - (int)v14) <= 15)
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = "Cannot read metadata.header.syncWords";
    __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
  }
  unsigned int v16 = HIWORD(v15);
  int v17 = v10 - 16;
  if (v10 - 16 < 0)
  {
    if ((unint64_t)v14 >= a2
      && ((v6 - v14) & ~((uint64_t)(v6 - (void)v14) >> 63) & 0xFFFFFFFC) != 0)
    {
      unsigned int v15 = bswap32(*v14);
    }
    else
    {
      uint64_t v19 = 0;
      do
      {
        v20 = (unsigned __int8 *)v14 + v19;
        int v21 = 255;
        if ((unint64_t)v14 + v19 < v6 && (unint64_t)v20 >= a2) {
          int v21 = *v20;
        }
        unsigned int v15 = v21 | (v15 << 8);
        ++v19;
      }
      while (v19 != 4);
    }
    unsigned int v22 = v15 << (16 - v10);
    int v23 = v10 + 16;
    v65[0] = ++v14;
    v16 |= v15 >> v23;
    if (v23) {
      unsigned int v18 = v22;
    }
    else {
      unsigned int v18 = 0;
    }
    if (v23) {
      int v17 = v23;
    }
    else {
      int v17 = 0;
    }
  }
  else
  {
    unsigned int v18 = v15 << 16;
  }
  unsigned int v66 = v18;
  *(_WORD *)a4 = v16;
  if ((_WORD)v16 != 0xFFFF)
  {
    v59 = __cxa_allocate_exception(8uLL);
    uint64_t v60 = "metadata.header.syncWords not recognized";
    goto LABEL_110;
  }
  if (v17 + 8 * ((int)v6 - (int)v14) <= 15)
  {
    v61 = __cxa_allocate_exception(8uLL);
    void *v61 = "Cannot read metadata.header.chunkSize";
    __cxa_throw(v61, MEMORY[0x1E4FBA308], 0);
  }
  unsigned int v24 = HIWORD(v18);
  int v25 = v17 - 16;
  int v67 = v17 - 16;
  if (v17 - 16 < 0)
  {
    if ((unint64_t)v14 >= a2
      && ((v6 - v14) & ~((uint64_t)(v6 - (void)v14) >> 63) & 0xFFFFFFFC) != 0)
    {
      unsigned int v18 = bswap32(*v14);
    }
    else
    {
      uint64_t v27 = 0;
      do
      {
        v28 = (unsigned __int8 *)v14 + v27;
        unsigned int v29 = v18 << 8;
        unsigned int v66 = v29;
        int v30 = 255;
        if ((unint64_t)v14 + v27 < v6 && (unint64_t)v28 >= a2) {
          int v30 = *v28;
        }
        unsigned int v18 = v30 | v29;
        unsigned int v66 = v18;
        ++v27;
      }
      while (v27 != 4);
    }
    unsigned int v31 = v18 << (16 - v17);
    int v32 = v17 + 16;
    v65[0] = ++v14;
    v24 |= v18 >> v32;
    if (v32) {
      unsigned int v26 = v31;
    }
    else {
      unsigned int v26 = 0;
    }
    if (v32) {
      int v25 = v32;
    }
    else {
      int v25 = 0;
    }
  }
  else
  {
    unsigned int v26 = v18 << 16;
  }
  unsigned int v66 = v26;
  *(_WORD *)(a4 + 2) = v24;
  if ((unsigned __int16)v24 + 4 > a3)
  {
    v59 = __cxa_allocate_exception(8uLL);
    uint64_t v60 = "The metadata chunk size exceeds capacity. Early exit.";
    goto LABEL_110;
  }
  if (v25 + 8 * ((int)v6 - (int)v14) <= 7)
  {
    v62 = __cxa_allocate_exception(8uLL);
    void *v62 = "Cannot read metadata.header.version.major";
    __cxa_throw(v62, MEMORY[0x1E4FBA308], 0);
  }
  unsigned int v33 = HIBYTE(v26);
  int v34 = v25 - 8;
  int v67 = v25 - 8;
  if (v25 - 8 < 0)
  {
    if ((unint64_t)v14 >= a2
      && ((v6 - v14) & ~((uint64_t)(v6 - (void)v14) >> 63) & 0xFFFFFFFC) != 0)
    {
      unsigned int v26 = bswap32(*v14);
    }
    else
    {
      uint64_t v36 = 0;
      do
      {
        int v37 = (unsigned __int8 *)v14 + v36;
        unsigned int v38 = v26 << 8;
        unsigned int v66 = v38;
        int v39 = 255;
        if ((unint64_t)v14 + v36 < v6 && (unint64_t)v37 >= a2) {
          int v39 = *v37;
        }
        unsigned int v26 = v39 | v38;
        unsigned int v66 = v26;
        ++v36;
      }
      while (v36 != 4);
    }
    unsigned int v40 = v26 << (8 - v25);
    int v41 = v25 + 24;
    v65[0] = ++v14;
    v33 |= v26 >> v41;
    if (v41) {
      unsigned int v35 = v40;
    }
    else {
      unsigned int v35 = 0;
    }
    if (v41) {
      int v34 = v41;
    }
    else {
      int v34 = 0;
    }
  }
  else
  {
    unsigned int v35 = v26 << 8;
  }
  unsigned int v66 = v35;
  *(unsigned char *)(a4 + 4) = v33;
  if (v34 + 8 * ((int)v6 - (int)v14) <= 7)
  {
    BOOL v63 = __cxa_allocate_exception(8uLL);
    *BOOL v63 = "Cannot read metadata.header.version.minor";
    __cxa_throw(v63, MEMORY[0x1E4FBA308], 0);
  }
  unsigned int v42 = HIBYTE(v35);
  int v43 = v34 - 8;
  int v67 = v34 - 8;
  if (v34 - 8 < 0)
  {
    if ((unint64_t)v14 >= a2
      && ((v6 - v14) & ~((uint64_t)(v6 - (void)v14) >> 63) & 0xFFFFFFFC) != 0)
    {
      unsigned int v35 = bswap32(*v14);
    }
    else
    {
      uint64_t v45 = 0;
      do
      {
        MIDITimeStamp v46 = (unsigned __int8 *)v14 + v45;
        unsigned int v47 = v35 << 8;
        unsigned int v66 = v47;
        int v48 = 255;
        if ((unint64_t)v14 + v45 < v6 && (unint64_t)v46 >= a2) {
          int v48 = *v46;
        }
        unsigned int v35 = v48 | v47;
        unsigned int v66 = v35;
        ++v45;
      }
      while (v45 != 4);
    }
    unsigned int v49 = v35 << (8 - v34);
    int v50 = v34 + 24;
    v65[0] = ++v14;
    v42 |= v35 >> v50;
    if (v50) {
      unsigned int v44 = v49;
    }
    else {
      unsigned int v44 = 0;
    }
    if (v50) {
      int v43 = v50;
    }
    else {
      int v43 = 0;
    }
  }
  else
  {
    unsigned int v44 = v35 << 8;
  }
  unsigned int v66 = v44;
  *(unsigned char *)(a4 + 5) = v42;
  if (v43 + 8 * ((int)v6 - (int)v14) <= 0)
  {
    int v64 = __cxa_allocate_exception(8uLL);
    *int v64 = "Cannot read metadata.header.informationFrame";
    __cxa_throw(v64, MEMORY[0x1E4FBA308], 0);
  }
  unsigned int v51 = v44 >> 31;
  int v67 = v43 - 1;
  if (v43 - 1 < 0)
  {
    if ((unint64_t)v14 >= a2
      && ((v6 - v14) & ~((uint64_t)(v6 - (void)v14) >> 63) & 0xFFFFFFFC) != 0)
    {
      unsigned int v44 = bswap32(*v14);
    }
    else
    {
      uint64_t v53 = 0;
      do
      {
        v54 = (unsigned __int8 *)v14 + v53;
        unsigned int v55 = v44 << 8;
        unsigned int v66 = v55;
        int v56 = 255;
        if ((unint64_t)v14 + v53 < v6 && (unint64_t)v54 >= a2) {
          int v56 = *v54;
        }
        unsigned int v44 = v56 | v55;
        unsigned int v66 = v44;
        ++v53;
      }
      while (v53 != 4);
    }
    int v52 = v44 << (1 - v43);
    int v67 = v43 + 31;
    v65[0] = v14 + 1;
    v51 |= v44 >> (v43 + 31);
    if (v43 == -31) {
      int v52 = 0;
    }
  }
  else
  {
    int v52 = 2 * v44;
  }
  unsigned int v66 = v52;
  *(unsigned char *)(a4 + 6) = v51 != 0;
  if (v33 != 1)
  {
    v59 = __cxa_allocate_exception(8uLL);
    uint64_t v60 = "Metadata version mismatch";
    goto LABEL_110;
  }
  if (v42 == 3)
  {
    APAC::MetadataBitStreamParser::parseMetadataFrame(a1, a4 + 1451080, v51 != 0, (uint64_t)v65);
    return 0;
  }
  if (v42 != 2)
  {
    v59 = __cxa_allocate_exception(8uLL);
    uint64_t v60 = "Metadata version not supported";
LABEL_110:
    void *v59 = v60;
    __cxa_throw(v59, MEMORY[0x1E4FBA308], 0);
  }
  if (v51) {
    APAC::MetadataBitStreamParser::parseStaticMetadata(a1, (BOOL *)(a4 + 8), (uint64_t)v65);
  }
  APAC::MetadataBitStreamParser::parseDynamicMetadata(a1, (BOOL *)(a4 + 174192), (uint64_t)v65);
  return 0;
}

void sub_19015B284(void *a1, int a2)
{
  if (a2 == 2)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    JUMPOUT(0x19015B144);
  }
  __clang_call_terminate(a1);
}

void APAC::MetadataBitStreamParser::parseStaticMetadata(uint64_t a1, BOOL *a2, uint64_t a3)
{
  uint64_t v4 = a2 + 424;
  uint64_t v5 = a2 + 428;
  unint64_t v6 = a2 + 27864;
  uint64_t v7 = (uint64_t)(a2 + 173156);
  APAC::MetadataBitStreamParser::parseReferenceScreen(a1, a2, a3);
  APAC::MetadataBitStreamParser::parseCodeBookData(v8, v4, a3);
  APAC::MetadataBitStreamParser::parseGroupStaticData(v9, v5, a3);
  APAC::MetadataBitStreamParser::parseSceneComponenentStaticData(v10, v6, a3);
  APAC::MetadataBitStreamParser::parseExtendedData(v11, v7, a3);
}

void APAC::MetadataBitStreamParser::parseDynamicMetadata(uint64_t a1, BOOL *a2, uint64_t a3)
{
  uint64_t v5 = a2 + 32516;
  uint64_t v6 = (uint64_t)(a2 + 1271024);
  APAC::MetadataBitStreamParser::parseGroupDynamicData(a1, a2, a3);
  APAC::MetadataBitStreamParser::parseSceneComponenentDynamicData(a1, v5, a3);
  APAC::MetadataBitStreamParser::parseExtendedData(v7, v6, a3);
}

void APAC::MetadataBitStreamParser::parseMetadataFrame(unint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  unint64_t v4 = *(void *)(a4 + 16);
  uint64_t v5 = *(unsigned int **)a4;
  uint64_t v6 = v4 - *(void *)a4;
  int v7 = *(_DWORD *)(a4 + 28);
  if (v7 + 8 * (int)v6 <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    unsigned int v51 = "Cannot read mdFrame.mRendererMetadataPresent";
    goto LABEL_64;
  }
  unsigned int v11 = *(_DWORD *)(a4 + 24);
  unsigned int v12 = v11 >> 31;
  int v13 = v7 - 1;
  *(_DWORD *)(a4 + 28) = v7 - 1;
  if (v7 - 1 < 0)
  {
    unint64_t v15 = *(void *)(a4 + 8);
    if ((v6 & ~(v6 >> 63) & 0xFFFFFFFC) == 0 || v15 > (unint64_t)v5)
    {
      uint64_t v17 = 0;
      do
      {
        unsigned int v18 = (unsigned __int8 *)v5 + v17;
        unsigned int v19 = v11 << 8;
        *(_DWORD *)(a4 + 24) = v19;
        int v20 = 255;
        if ((unint64_t)v5 + v17 < v4 && (unint64_t)v18 >= v15) {
          int v20 = *v18;
        }
        unsigned int v11 = v20 | v19;
        *(_DWORD *)(a4 + 24) = v11;
        ++v17;
      }
      while (v17 != 4);
    }
    else
    {
      unsigned int v11 = bswap32(*v5);
    }
    unsigned int v21 = v11 << (1 - v7);
    int v22 = v7 + 31;
    *(_DWORD *)(a4 + 28) = v22;
    *(void *)a4 = ++v5;
    v12 |= v11 >> v22;
    if (v22) {
      unsigned int v14 = v21;
    }
    else {
      unsigned int v14 = 0;
    }
    if (v22) {
      int v13 = v22;
    }
    else {
      int v13 = 0;
    }
  }
  else
  {
    unsigned int v14 = 2 * v11;
  }
  *(_DWORD *)(a4 + 24) = v14;
  *(unsigned char *)(a2 + 1) = v12 != 0;
  if (v12)
  {
    if (a3)
    {
      if (v13 + 8 * ((int)v4 - (int)v5) <= 0)
      {
        exception = __cxa_allocate_exception(8uLL);
        unsigned int v51 = "Cannot read glbCfg.mHasData";
        goto LABEL_64;
      }
      int v23 = (BOOL *)(a2 + 16);
      unsigned int v24 = v14 >> 31;
      int v25 = v13 - 1;
      *(_DWORD *)(a4 + 28) = v13 - 1;
      if (v13 - 1 < 0)
      {
        unint64_t v27 = *(void *)(a4 + 8);
        if (((v4 - v5) & ~((uint64_t)(v4 - (void)v5) >> 63) & 0xFFFFFFFC) != 0
          && v27 <= (unint64_t)v5)
        {
          unsigned int v14 = bswap32(*v5);
        }
        else
        {
          uint64_t v28 = 0;
          do
          {
            unsigned int v29 = (unsigned __int8 *)v5 + v28;
            unsigned int v30 = v14 << 8;
            *(_DWORD *)(a4 + 24) = v30;
            int v31 = 255;
            if ((unint64_t)v5 + v28 < v4 && (unint64_t)v29 >= v27) {
              int v31 = *v29;
            }
            unsigned int v14 = v31 | v30;
            *(_DWORD *)(a4 + 24) = v14;
            ++v28;
          }
          while (v28 != 4);
        }
        int v33 = v13 + 31;
        BOOL v32 = v13 == -31;
        *(_DWORD *)(a4 + 28) = v13 + 31;
        *(void *)a4 = ++v5;
        v24 |= v14 >> (v13 + 31);
        if (v13 == -31) {
          int v26 = 0;
        }
        else {
          int v26 = v14 << (1 - v13);
        }
        if (v32) {
          int v25 = 0;
        }
        else {
          int v25 = v33;
        }
      }
      else
      {
        int v26 = 2 * v14;
      }
      *(_DWORD *)(a4 + 24) = v26;
      *int v23 = v24 != 0;
      if (v24)
      {
        APAC::MetadataBitStreamParser::parseGlobalConfig(a1, (uint64_t)v23, 0, a4);
        unint64_t v4 = *(void *)(a4 + 16);
        uint64_t v5 = *(unsigned int **)a4;
        int v25 = *(_DWORD *)(a4 + 28);
      }
      if (v25 + 8 * ((int)v4 - (int)v5) <= 10)
      {
        exception = __cxa_allocate_exception(8uLL);
        unsigned int v51 = "Cannot read mdFrame.mRendererMetadata.mGroupCount";
        goto LABEL_64;
      }
      unsigned int v34 = *(_DWORD *)(a4 + 24);
      unsigned int v35 = v34 >> 21;
      *(_DWORD *)(a4 + 28) = v25 - 11;
      if (v25 - 11 < 0)
      {
        unint64_t v37 = *(void *)(a4 + 8);
        if (((v4 - v5) & ~((uint64_t)(v4 - (void)v5) >> 63) & 0xFFFFFFFC) != 0
          && v37 <= (unint64_t)v5)
        {
          unsigned int v34 = bswap32(*v5);
        }
        else
        {
          uint64_t v38 = 0;
          do
          {
            int v39 = (unsigned __int8 *)v5 + v38;
            unsigned int v40 = v34 << 8;
            *(_DWORD *)(a4 + 24) = v40;
            int v41 = 255;
            if ((unint64_t)v5 + v38 < v4 && (unint64_t)v39 >= v37) {
              int v41 = *v39;
            }
            unsigned int v34 = v41 | v40;
            *(_DWORD *)(a4 + 24) = v34;
            ++v38;
          }
          while (v38 != 4);
        }
        unsigned int v42 = v34 << (11 - v25);
        int v43 = v25 + 21;
        *(_DWORD *)(a4 + 28) = v43;
        *(void *)a4 = v5 + 1;
        v35 |= v34 >> v43;
        if (v43) {
          unsigned int v36 = v42;
        }
        else {
          unsigned int v36 = 0;
        }
      }
      else
      {
        unsigned int v36 = v34 << 11;
      }
      *(_DWORD *)(a4 + 24) = v36;
      *(_WORD *)(a2 + 8) = v35;
      unint64_t v44 = (unsigned __int16)v35;
      std::vector<APAC::Metadata::GroupConfig>::resize(a2 + 4784, v44);
      if (v44)
      {
        uint64_t v46 = 0;
        unint64_t v47 = 0;
        uint64_t v48 = 48 * v44;
        while (1)
        {
          uint64_t v49 = *(void *)(a2 + 4784);
          if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(a2 + 4792) - v49) >> 4) <= v47) {
            break;
          }
          APAC::MetadataBitStreamParser::parseGroupConfig(v45, v49 + v46, 0, a4);
          ++v47;
          v46 += 48;
          if (v48 == v46) {
            goto LABEL_60;
          }
        }
        exception = __cxa_allocate_exception(8uLL);
        unsigned int v51 = "metadata.mMetadataFrame.mRendererMetadata.mGroupConfig does not have enough elements";
LABEL_64:
        void *exception = v51;
        __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
      }
    }
LABEL_60:
    APAC::MetadataBitStreamParser::parseRendererMetadata(a1, a2 + 8, a4);
  }
}

void APAC::MetadataBitStreamParser::parseGlobalConfig(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  unsigned int v8 = *(_DWORD *)(a4 + 24);
  int v7 = *(_DWORD *)(a4 + 28);
  unsigned int v9 = v8 >> 21;
  *(_DWORD *)(a4 + 28) = v7 - 11;
  if (v7 - 11 < 0)
  {
    unint64_t v12 = *(void *)(a4 + 8);
    unint64_t v11 = *(void *)(a4 + 16);
    int v13 = *(unsigned int **)a4;
    if (((v11 - *(_DWORD *)a4) & ~((uint64_t)(v11 - *(void *)a4) >> 63) & 0xFFFFFFFC) == 0
      || v12 > (unint64_t)v13)
    {
      uint64_t v15 = 0;
      do
      {
        unsigned int v16 = (unsigned __int8 *)v13 + v15;
        unsigned int v17 = v8 << 8;
        *(_DWORD *)(a4 + 24) = v17;
        int v18 = 255;
        if ((unint64_t)v13 + v15 < v11 && (unint64_t)v16 >= v12) {
          int v18 = *v16;
        }
        unsigned int v8 = v18 | v17;
        *(_DWORD *)(a4 + 24) = v8;
        ++v15;
      }
      while (v15 != 4);
    }
    else
    {
      unsigned int v8 = bswap32(*v13);
    }
    unsigned int v19 = v8 << (11 - v7);
    int v20 = v7 + 21;
    *(_DWORD *)(a4 + 28) = v20;
    *(void *)a4 = v13 + 1;
    v9 |= v8 >> v20;
    if (v20) {
      unsigned int v10 = v19;
    }
    else {
      unsigned int v10 = 0;
    }
  }
  else
  {
    unsigned int v10 = v8 << 11;
  }
  *(_DWORD *)(a4 + 24) = v10;
  *(_WORD *)(a2 + 2) = v9;
  if (v9)
  {
    uint64_t v21 = 0;
    v193 = (unsigned char *)(a2 + 4496);
    v200 = (unsigned __int8 *)(a2 + 4736);
    uint64_t v199 = a2 + 4716;
    uint64_t v198 = a2 + 4668;
    uint64_t v197 = a2 + 4648;
    uint64_t v196 = a2 + 4504;
    uint64_t v195 = a2 + 4480;
    v194 = (unsigned char *)(a2 + 4156);
    uint64_t v22 = v9;
    while (1)
    {
      unsigned int v24 = *(_DWORD *)(a4 + 24);
      int v23 = *(_DWORD *)(a4 + 28);
      unsigned int v25 = v24 >> 21;
      int v26 = v23 - 11;
      *(_DWORD *)(a4 + 28) = v23 - 11;
      if (v23 - 11 < 0)
      {
        unint64_t v29 = *(void *)(a4 + 8);
        unint64_t v28 = *(void *)(a4 + 16);
        unsigned int v30 = *(unsigned int **)a4;
        if (((v28 - *(_DWORD *)a4) & ~((uint64_t)(v28 - *(void *)a4) >> 63) & 0xFFFFFFFC) == 0
          || v29 > (unint64_t)v30)
        {
          uint64_t v32 = 0;
          do
          {
            int v33 = (unsigned __int8 *)v30 + v32;
            unsigned int v34 = v24 << 8;
            *(_DWORD *)(a4 + 24) = v34;
            int v35 = 255;
            if ((unint64_t)v30 + v32 < v28 && (unint64_t)v33 >= v29) {
              int v35 = *v33;
            }
            unsigned int v24 = v35 | v34;
            *(_DWORD *)(a4 + 24) = v24;
            ++v32;
          }
          while (v32 != 4);
        }
        else
        {
          unsigned int v24 = bswap32(*v30);
        }
        int v37 = v23 + 21;
        BOOL v36 = v23 == -21;
        *(_DWORD *)(a4 + 28) = v23 + 21;
        *(void *)a4 = v30 + 1;
        v25 |= v24 >> (v23 + 21);
        if (v23 == -21) {
          unsigned int v27 = 0;
        }
        else {
          unsigned int v27 = v24 << (11 - v23);
        }
        if (v36) {
          int v26 = 0;
        }
        else {
          int v26 = v37;
        }
      }
      else
      {
        unsigned int v27 = v24 << 11;
      }
      *(_DWORD *)(a4 + 24) = v27;
      *(_WORD *)(a2 + 4 + 2 * v21) = v25;
      switch(v25)
      {
        case 0u:
          unint64_t v38 = *(void *)(a4 + 16);
          int v39 = *(unsigned int **)a4;
          uint64_t v40 = v38 - *(void *)a4;
          if (v26 + 8 * (int)v40 <= 0)
          {
            exception = __cxa_allocate_exception(8uLL);
            v192 = "Cannot read glbCfg.mApplyPostProcReverb";
            goto LABEL_271;
          }
          unsigned int v41 = v27 >> 31;
          *(_DWORD *)(a4 + 28) = v26 - 1;
          if (v26 - 1 < 0)
          {
            uint64_t v91 = v40 & ~(v40 >> 63) & 0xFFFFFFFC;
            unint64_t v92 = *(void *)(a4 + 8);
            if (v91) {
              BOOL v93 = v92 > (unint64_t)v39;
            }
            else {
              BOOL v93 = 1;
            }
            if (v93)
            {
              uint64_t v94 = 0;
              do
              {
                unsigned int v95 = (unsigned __int8 *)v39 + v94;
                unsigned int v96 = v27 << 8;
                *(_DWORD *)(a4 + 24) = v96;
                int v97 = 255;
                if ((unint64_t)v39 + v94 < v38 && (unint64_t)v95 >= v92) {
                  int v97 = *v95;
                }
                unsigned int v27 = v97 | v96;
                *(_DWORD *)(a4 + 24) = v27;
                ++v94;
              }
              while (v94 != 4);
            }
            else
            {
              unsigned int v27 = bswap32(*v39);
            }
            int v151 = v27 << (1 - v26);
            int v152 = v26 + 31;
            *(_DWORD *)(a4 + 28) = v152;
            *(void *)a4 = v39 + 1;
            v41 |= v27 >> v152;
            if (v152) {
              int v42 = v151;
            }
            else {
              int v42 = 0;
            }
          }
          else
          {
            int v42 = 2 * v27;
          }
          *(_DWORD *)(a4 + 24) = v42;
          *(unsigned char *)(a2 + 4100) = v41 != 0;
          goto LABEL_261;
        case 1u:
          unint64_t v43 = *(void *)(a4 + 16);
          unint64_t v44 = *(unsigned int **)a4;
          uint64_t v45 = v43 - *(void *)a4;
          if (v26 + 8 * (int)v45 <= 0)
          {
            exception = __cxa_allocate_exception(8uLL);
            v192 = "Cannot read glbCfg.mIs6DoF";
            goto LABEL_271;
          }
          unsigned int v46 = v27 >> 31;
          *(_DWORD *)(a4 + 28) = v26 - 1;
          if (v26 - 1 < 0)
          {
            uint64_t v98 = v45 & ~(v45 >> 63) & 0xFFFFFFFC;
            unint64_t v99 = *(void *)(a4 + 8);
            if (v98) {
              BOOL v100 = v99 > (unint64_t)v44;
            }
            else {
              BOOL v100 = 1;
            }
            if (v100)
            {
              uint64_t v101 = 0;
              do
              {
                v102 = (unsigned __int8 *)v44 + v101;
                unsigned int v103 = v27 << 8;
                *(_DWORD *)(a4 + 24) = v103;
                int v104 = 255;
                if ((unint64_t)v44 + v101 < v43 && (unint64_t)v102 >= v99) {
                  int v104 = *v102;
                }
                unsigned int v27 = v104 | v103;
                *(_DWORD *)(a4 + 24) = v27;
                ++v101;
              }
              while (v101 != 4);
            }
            else
            {
              unsigned int v27 = bswap32(*v44);
            }
            int v153 = v27 << (1 - v26);
            int v154 = v26 + 31;
            *(_DWORD *)(a4 + 28) = v154;
            *(void *)a4 = v44 + 1;
            v46 |= v27 >> v154;
            if (v154) {
              int v47 = v153;
            }
            else {
              int v47 = 0;
            }
          }
          else
          {
            int v47 = 2 * v27;
          }
          *(_DWORD *)(a4 + 24) = v47;
          *(unsigned char *)(a2 + 4101) = v46 != 0;
          goto LABEL_261;
        case 2u:
          unint64_t v48 = *(void *)(a4 + 16);
          uint64_t v49 = *(unsigned int **)a4;
          uint64_t v50 = v48 - *(void *)a4;
          if (v26 + 8 * (int)v50 <= 0)
          {
            exception = __cxa_allocate_exception(8uLL);
            v192 = "Cannot read glbCfg.mHasSceneRadiationPattern";
            goto LABEL_271;
          }
          unsigned int v51 = v27 >> 31;
          *(_DWORD *)(a4 + 28) = v26 - 1;
          if (v26 - 1 < 0)
          {
            uint64_t v105 = v50 & ~(v50 >> 63) & 0xFFFFFFFC;
            unint64_t v106 = *(void *)(a4 + 8);
            if (v105) {
              BOOL v107 = v106 > (unint64_t)v49;
            }
            else {
              BOOL v107 = 1;
            }
            if (v107)
            {
              uint64_t v108 = 0;
              do
              {
                int v109 = (unsigned __int8 *)v49 + v108;
                unsigned int v110 = v27 << 8;
                *(_DWORD *)(a4 + 24) = v110;
                int v111 = 255;
                if ((unint64_t)v49 + v108 < v48 && (unint64_t)v109 >= v106) {
                  int v111 = *v109;
                }
                unsigned int v27 = v111 | v110;
                *(_DWORD *)(a4 + 24) = v27;
                ++v108;
              }
              while (v108 != 4);
            }
            else
            {
              unsigned int v27 = bswap32(*v49);
            }
            int v155 = v27 << (1 - v26);
            int v156 = v26 + 31;
            *(_DWORD *)(a4 + 28) = v156;
            *(void *)a4 = v49 + 1;
            v51 |= v27 >> v156;
            if (v156) {
              int v52 = v155;
            }
            else {
              int v52 = 0;
            }
          }
          else
          {
            int v52 = 2 * v27;
          }
          *(_DWORD *)(a4 + 24) = v52;
          *(unsigned char *)(a2 + 4102) = v51 != 0;
          goto LABEL_261;
        case 3u:
          unint64_t v53 = *(void *)(a4 + 16);
          v54 = *(unsigned int **)a4;
          uint64_t v55 = v53 - *(void *)a4;
          if (v26 + 8 * (int)v55 <= 4)
          {
            exception = __cxa_allocate_exception(8uLL);
            v192 = "Cannot read glbCfg.mTargetPlaybackSystemIndex";
            goto LABEL_271;
          }
          unsigned int v56 = v27 >> 27;
          *(_DWORD *)(a4 + 28) = v26 - 5;
          if (v26 - 5 < 0)
          {
            uint64_t v112 = v55 & ~(v55 >> 63) & 0xFFFFFFFC;
            unint64_t v113 = *(void *)(a4 + 8);
            if (v112) {
              BOOL v114 = v113 > (unint64_t)v54;
            }
            else {
              BOOL v114 = 1;
            }
            if (v114)
            {
              uint64_t v115 = 0;
              do
              {
                int v116 = (unsigned __int8 *)v54 + v115;
                unsigned int v117 = v27 << 8;
                *(_DWORD *)(a4 + 24) = v117;
                int v118 = 255;
                if ((unint64_t)v54 + v115 < v53 && (unint64_t)v116 >= v113) {
                  int v118 = *v116;
                }
                unsigned int v27 = v118 | v117;
                *(_DWORD *)(a4 + 24) = v27;
                ++v115;
              }
              while (v115 != 4);
            }
            else
            {
              unsigned int v27 = bswap32(*v54);
            }
            int v157 = v27 << (5 - v26);
            int v158 = v26 + 27;
            *(_DWORD *)(a4 + 28) = v158;
            *(void *)a4 = v54 + 1;
            v56 |= v27 >> v158;
            if (v158) {
              int v57 = v157;
            }
            else {
              int v57 = 0;
            }
          }
          else
          {
            int v57 = 32 * v27;
          }
          *(_DWORD *)(a4 + 24) = v57;
          *(unsigned char *)(a2 + 4103) = v56;
          goto LABEL_261;
        case 4u:
          APAC::MetadataBitStreamParser::parseAuthoringInformation(a1, (unsigned char *)(a2 + 4106), a4);
          goto LABEL_261;
        case 5u:
          APAC::MetadataBitStreamParser::parseReferenceScreen(a1, a2 + 4116, a4);
          goto LABEL_261;
        case 6u:
          a1 = APAC::MetadataBitStreamParser::parseDBMD(a1, v194, a4);
          goto LABEL_261;
        case 7u:
          APAC::MetadataBitStreamParser::parseBinauralization(a1, v195, a4);
          goto LABEL_261;
        case 8u:
          unint64_t v58 = *(void *)(a4 + 16);
          v59 = *(unsigned int **)a4;
          uint64_t v60 = v58 - *(void *)a4;
          if (v26 + 8 * (int)v60 <= 1)
          {
            exception = __cxa_allocate_exception(8uLL);
            v192 = "Cannot read glbCfg.mHCFilter.mDataLocationIndex";
            goto LABEL_271;
          }
          unsigned int v61 = v27 >> 30;
          int v62 = v26 - 2;
          *(_DWORD *)(a4 + 28) = v26 - 2;
          if (v26 - 2 < 0)
          {
            unint64_t v119 = *(void *)(a4 + 8);
            if ((v60 & ~(v60 >> 63) & 0xFFFFFFFC) == 0 || v119 > (unint64_t)v59)
            {
              uint64_t v121 = 0;
              do
              {
                unsigned int v122 = (unsigned __int8 *)v59 + v121;
                unsigned int v123 = v27 << 8;
                *(_DWORD *)(a4 + 24) = v123;
                int v124 = 255;
                if ((unint64_t)v59 + v121 < v58 && (unint64_t)v122 >= v119) {
                  int v124 = *v122;
                }
                unsigned int v27 = v124 | v123;
                *(_DWORD *)(a4 + 24) = v27;
                ++v121;
              }
              while (v121 != 4);
            }
            else
            {
              unsigned int v27 = bswap32(*v59);
            }
            unsigned int v159 = v27 << (2 - v26);
            int v160 = v26 + 30;
            *(_DWORD *)(a4 + 28) = v160;
            *(void *)a4 = ++v59;
            v61 |= v27 >> v160;
            if (v160) {
              unsigned int v63 = v159;
            }
            else {
              unsigned int v63 = 0;
            }
            if (v160) {
              int v62 = v160;
            }
            else {
              int v62 = 0;
            }
          }
          else
          {
            unsigned int v63 = 4 * v27;
          }
          *(_DWORD *)(a4 + 24) = v63;
          unsigned char *v193 = v61;
          if (v62 + 8 * ((int)v58 - (int)v59) <= 8)
          {
            exception = __cxa_allocate_exception(8uLL);
            v192 = "Cannot read glbCfg.mHCFilter.mCustomData_TableID";
            goto LABEL_271;
          }
          unsigned int v161 = v63 >> 23;
          int v162 = v62 - 9;
          *(_DWORD *)(a4 + 28) = v62 - 9;
          if (v62 - 9 < 0)
          {
            unint64_t v164 = *(void *)(a4 + 8);
            if (((v58 - v59) & ~((uint64_t)(v58 - (void)v59) >> 63) & 0xFFFFFFFC) != 0
              && v164 <= (unint64_t)v59)
            {
              unsigned int v63 = bswap32(*v59);
            }
            else
            {
              uint64_t v167 = 0;
              do
              {
                v168 = (unsigned __int8 *)v59 + v167;
                unsigned int v169 = v63 << 8;
                *(_DWORD *)(a4 + 24) = v169;
                int v170 = 255;
                if ((unint64_t)v59 + v167 < v58 && (unint64_t)v168 >= v164) {
                  int v170 = *v168;
                }
                unsigned int v63 = v170 | v169;
                *(_DWORD *)(a4 + 24) = v63;
                ++v167;
              }
              while (v167 != 4);
            }
            int v172 = v62 + 23;
            BOOL v171 = v62 == -23;
            *(_DWORD *)(a4 + 28) = v62 + 23;
            *(void *)a4 = ++v59;
            v161 |= v63 >> (v62 + 23);
            if (v62 == -23) {
              unsigned int v163 = 0;
            }
            else {
              unsigned int v163 = v63 << (9 - v62);
            }
            if (v171) {
              int v162 = 0;
            }
            else {
              int v162 = v172;
            }
          }
          else
          {
            unsigned int v163 = v63 << 9;
          }
          *(_DWORD *)(a4 + 24) = v163;
          *(_WORD *)(a2 + 4498) = v161;
          if (v162 + 8 * ((int)v58 - (int)v59) <= 8)
          {
            exception = __cxa_allocate_exception(8uLL);
            v192 = "Cannot read glbCfg.mHCFilter.mCustomData_EntryID";
LABEL_271:
            void *exception = v192;
            __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
          }
          unsigned int v173 = v163 >> 23;
          *(_DWORD *)(a4 + 28) = v162 - 9;
          if (v162 - 9 < 0)
          {
            unint64_t v175 = *(void *)(a4 + 8);
            if (((v58 - v59) & ~((uint64_t)(v58 - (void)v59) >> 63) & 0xFFFFFFFC) != 0
              && v175 <= (unint64_t)v59)
            {
              unsigned int v163 = bswap32(*v59);
            }
            else
            {
              uint64_t v176 = 0;
              do
              {
                v177 = (unsigned __int8 *)v59 + v176;
                unsigned int v178 = v163 << 8;
                *(_DWORD *)(a4 + 24) = v178;
                int v179 = 255;
                if ((unint64_t)v59 + v176 < v58 && (unint64_t)v177 >= v175) {
                  int v179 = *v177;
                }
                unsigned int v163 = v179 | v178;
                *(_DWORD *)(a4 + 24) = v163;
                ++v176;
              }
              while (v176 != 4);
            }
            unsigned int v180 = v163 << (9 - v162);
            int v181 = v162 + 23;
            *(_DWORD *)(a4 + 28) = v181;
            *(void *)a4 = v59 + 1;
            v173 |= v163 >> v181;
            if (v181) {
              unsigned int v174 = v180;
            }
            else {
              unsigned int v174 = 0;
            }
          }
          else
          {
            unsigned int v174 = v163 << 9;
          }
          *(_DWORD *)(a4 + 24) = v174;
          *(_WORD *)(a2 + 4500) = v173;
LABEL_261:
          if (++v21 == v22) {
            return;
          }
          break;
        case 9u:
          APAC::MetadataBitStreamParser::parseSPAD(a1, v196, a3, a4);
          goto LABEL_261;
        case 0xAu:
          APAC::MetadataBitStreamParser::parseDistanceAttenuation(a1, v197, a4);
          goto LABEL_261;
        case 0xBu:
          a1 = APAC::MetadataBitStreamParser::parsePosition(a1, v198, a4);
          goto LABEL_261;
        case 0xCu:
          APAC::MetadataBitStreamParser::parseGenericRenderingConfig(a1, v199, a4);
          goto LABEL_261;
        case 0xDu:
          unint64_t v64 = *(void *)(a4 + 16);
          v65 = *(unsigned int **)a4;
          uint64_t v66 = v64 - *(void *)a4;
          if (v26 + 8 * (int)v66 <= 5)
          {
            exception = __cxa_allocate_exception(8uLL);
            v192 = "Cannot read glbCfg.mContentKind";
            goto LABEL_271;
          }
          unsigned int v67 = v27 >> 26;
          *(_DWORD *)(a4 + 28) = v26 - 6;
          if (v26 - 6 < 0)
          {
            uint64_t v125 = v66 & ~(v66 >> 63) & 0xFFFFFFFC;
            unint64_t v126 = *(void *)(a4 + 8);
            if (v125) {
              BOOL v127 = v126 > (unint64_t)v65;
            }
            else {
              BOOL v127 = 1;
            }
            if (v127)
            {
              uint64_t v128 = 0;
              do
              {
                v129 = (unsigned __int8 *)v65 + v128;
                unsigned int v130 = v27 << 8;
                *(_DWORD *)(a4 + 24) = v130;
                int v131 = 255;
                if ((unint64_t)v65 + v128 < v64 && (unint64_t)v129 >= v126) {
                  int v131 = *v129;
                }
                unsigned int v27 = v131 | v130;
                *(_DWORD *)(a4 + 24) = v27;
                ++v128;
              }
              while (v128 != 4);
            }
            else
            {
              unsigned int v27 = bswap32(*v65);
            }
            unsigned int v165 = v27 << (6 - v26);
            int v166 = v26 + 26;
            *(_DWORD *)(a4 + 28) = v166;
            *(void *)a4 = v65 + 1;
            v67 |= v27 >> v166;
            if (v166) {
              unsigned int v68 = v165;
            }
            else {
              unsigned int v68 = 0;
            }
          }
          else
          {
            unsigned int v68 = v27 << 6;
          }
          *(_DWORD *)(a4 + 24) = v68;
          *(unsigned char *)(a2 + 4104) = v67;
          goto LABEL_261;
        case 0xEu:
          unsigned int v69 = v27 >> 28;
          int v70 = v26 - 4;
          *(_DWORD *)(a4 + 28) = v26 - 4;
          if (v26 - 4 < 0)
          {
            unint64_t v76 = *(void *)(a4 + 8);
            unint64_t v75 = *(void *)(a4 + 16);
            uint64_t v77 = *(unsigned int **)a4;
            if (((v75 - *(_DWORD *)a4) & ~((uint64_t)(v75 - *(void *)a4) >> 63) & 0xFFFFFFFC) == 0
              || v76 > (unint64_t)v77)
            {
              uint64_t v79 = 0;
              do
              {
                UInt32 v80 = (unsigned __int8 *)v77 + v79;
                unsigned int v81 = v27 << 8;
                *(_DWORD *)(a4 + 24) = v81;
                int v82 = 255;
                if ((unint64_t)v77 + v79 < v75 && (unint64_t)v80 >= v76) {
                  int v82 = *v80;
                }
                unsigned int v27 = v82 | v81;
                *(_DWORD *)(a4 + 24) = v27;
                ++v79;
              }
              while (v79 != 4);
            }
            else
            {
              unsigned int v27 = bswap32(*v77);
            }
            unsigned int v132 = v27 << (4 - v26);
            int v133 = v26 + 28;
            *(_DWORD *)(a4 + 28) = v133;
            *(void *)a4 = v77 + 1;
            v69 |= v27 >> v133;
            if (v133) {
              unsigned int v71 = v132;
            }
            else {
              unsigned int v71 = 0;
            }
            if (v133) {
              int v70 = v133;
            }
            else {
              int v70 = 0;
            }
          }
          else
          {
            unsigned int v71 = 16 * v27;
          }
          *(_DWORD *)(a4 + 24) = v71;
          int v134 = 8 * v69;
          if (8 * v69 - 25 >= 0xFFFFFFE0)
          {
            int v136 = v134 + 8;
            unsigned int v135 = v71 >> (24 - v134);
            int v137 = v70 - v136;
            *(_DWORD *)(a4 + 28) = v70 - v136;
            if (v70 - v136 < 0)
            {
              unint64_t v146 = *(void *)(a4 + 8);
              unint64_t v145 = *(void *)(a4 + 16);
              uint64_t v147 = *(unsigned int **)a4;
              if (((v145 - *(_DWORD *)a4) & ~((uint64_t)(v145 - *(void *)a4) >> 63) & 0xFFFFFFFC) != 0
                && v146 <= (unint64_t)v147)
              {
                unsigned int v71 = bswap32(*v147);
              }
              else
              {
                uint64_t v182 = 0;
                do
                {
                  v183 = (unsigned __int8 *)v147 + v182;
                  unsigned int v184 = v71 << 8;
                  *(_DWORD *)(a4 + 24) = v184;
                  int v185 = 255;
                  if ((unint64_t)v147 + v182 < v145 && (unint64_t)v183 >= v146) {
                    int v185 = *v183;
                  }
                  unsigned int v71 = v185 | v184;
                  *(_DWORD *)(a4 + 24) = v71;
                  ++v182;
                }
                while (v182 != 4);
              }
              *(_DWORD *)(a4 + 28) = v137 + 32;
              *(void *)a4 = v147 + 1;
              v135 |= v71 >> v137;
              if (v137 == -32) {
                unsigned int v138 = 0;
              }
              else {
                unsigned int v138 = v71 << -(char)v137;
              }
            }
            else
            {
              unsigned int v138 = v71 << v136;
            }
            *(_DWORD *)(a4 + 24) = v138;
          }
          else
          {
            LOBYTE(v135) = 0;
          }
          *(unsigned char *)(a2 + 4105) = v135;
          goto LABEL_261;
        case 0xFu:
          APAC::MetadataBitStreamParser::parseChannelBedHeadphoneMetadata(a1, v200, a4);
          goto LABEL_261;
        default:
          unsigned int v72 = v27 >> 28;
          int v73 = v26 - 4;
          *(_DWORD *)(a4 + 28) = v26 - 4;
          if (v26 - 4 < 0)
          {
            unint64_t v84 = *(void *)(a4 + 8);
            unint64_t v83 = *(void *)(a4 + 16);
            int v85 = *(unsigned int **)a4;
            if (((v83 - *(_DWORD *)a4) & ~((uint64_t)(v83 - *(void *)a4) >> 63) & 0xFFFFFFFC) == 0
              || v84 > (unint64_t)v85)
            {
              uint64_t v87 = 0;
              do
              {
                unsigned int v88 = (unsigned __int8 *)v85 + v87;
                unsigned int v89 = v27 << 8;
                *(_DWORD *)(a4 + 24) = v89;
                int v90 = 255;
                if ((unint64_t)v85 + v87 < v83 && (unint64_t)v88 >= v84) {
                  int v90 = *v88;
                }
                unsigned int v27 = v90 | v89;
                *(_DWORD *)(a4 + 24) = v27;
                ++v87;
              }
              while (v87 != 4);
            }
            else
            {
              unsigned int v27 = bswap32(*v85);
            }
            int v140 = v26 + 28;
            BOOL v139 = v26 == -28;
            *(_DWORD *)(a4 + 28) = v26 + 28;
            *(void *)a4 = v85 + 1;
            v72 |= v27 >> (v26 + 28);
            if (v26 == -28) {
              int v74 = 0;
            }
            else {
              int v74 = v27 << (4 - v26);
            }
            if (v139) {
              int v73 = 0;
            }
            else {
              int v73 = v140;
            }
          }
          else
          {
            int v74 = 16 * v27;
          }
          *(_DWORD *)(a4 + 24) = v74;
          int v141 = 8 * v72 + 8;
          unsigned int v142 = v141 - v73;
          if (v141 > v73)
          {
            *(void *)(a4 + 24) = 0;
            int v74 = 0;
            int v73 = 0;
            if (v142 >= 0x20)
            {
              *(void *)a4 += (v142 >> 3) & 0x1FFFFFFC;
              int v141 = v142 & 0x1F;
            }
            else
            {
              int v141 = v142;
            }
          }
          if ((v141 - 33) >= 0xFFFFFFE0)
          {
            int v143 = v73 - v141;
            *(_DWORD *)(a4 + 28) = v73 - v141;
            if (v73 - v141 < 0)
            {
              unint64_t v149 = *(void *)(a4 + 8);
              unint64_t v148 = *(void *)(a4 + 16);
              v150 = *(unsigned int **)a4;
              if (((v148 - *(_DWORD *)a4) & ~((uint64_t)(v148 - *(void *)a4) >> 63) & 0xFFFFFFFC) != 0
                && v149 <= (unint64_t)v150)
              {
                int v74 = bswap32(*v150);
              }
              else
              {
                uint64_t v186 = 0;
                do
                {
                  v187 = (unsigned __int8 *)v150 + v186;
                  int v188 = v74 << 8;
                  *(_DWORD *)(a4 + 24) = v188;
                  int v189 = 255;
                  if ((unint64_t)v150 + v186 < v148 && (unint64_t)v187 >= v149) {
                    int v189 = *v187;
                  }
                  int v74 = v189 | v188;
                  *(_DWORD *)(a4 + 24) = v74;
                  ++v186;
                }
                while (v186 != 4);
              }
              int v144 = v74 << -(char)v143;
              int v190 = v143 + 32;
              *(_DWORD *)(a4 + 28) = v190;
              *(void *)a4 = v150 + 1;
              if (!v190) {
                int v144 = 0;
              }
            }
            else
            {
              int v144 = v74 << v141;
            }
            *(_DWORD *)(a4 + 24) = v144;
          }
          goto LABEL_261;
      }
    }
  }
}

void std::vector<APAC::Metadata::GroupConfig>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = *(char **)a1;
  long long v3 = *(char **)(a1 + 8);
  unint64_t v5 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v3[-*(void *)a1] >> 4);
  unint64_t v6 = a2 - v5;
  if (a2 > v5)
  {
    uint64_t v7 = *(void *)(a1 + 16);
    if (0xAAAAAAAAAAAAAAABLL * ((v7 - (uint64_t)v3) >> 4) >= v6)
    {
      bzero(*(void **)(a1 + 8), 48 * ((48 * v6 - 48) / 0x30) + 48);
      *(void *)(a1 + 8) = &v3[48 * ((48 * v6 - 48) / 0x30) + 48];
      return;
    }
    if (a2 > 0x555555555555555) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - (uint64_t)v4) >> 4);
    uint64_t v9 = 2 * v8;
    if (2 * v8 <= a2) {
      uint64_t v9 = a2;
    }
    if (v8 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v10 = 0x555555555555555;
    }
    else {
      unint64_t v10 = v9;
    }
    if (v10 > 0x555555555555555) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    uint64_t v11 = 3 * v10;
    unint64_t v12 = (char *)operator new(48 * v10);
    int v13 = &v12[48 * v5];
    unsigned int v14 = &v12[16 * v11];
    size_t v15 = 48 * ((48 * v6 - 48) / 0x30) + 48;
    bzero(v13, v15);
    unsigned int v16 = &v13[v15];
    if (v3 == v4)
    {
      *(void *)a1 = v13;
      *(void *)(a1 + 8) = v16;
      *(void *)(a1 + 16) = v14;
      if (!v3) {
        return;
      }
    }
    else
    {
      uint64_t v17 = 0;
      do
      {
        int v18 = &v13[v17];
        unsigned int v19 = &v3[v17];
        long long v20 = *(_OWORD *)&v3[v17 - 48];
        *((void *)v18 - 4) = *(void *)&v3[v17 - 32];
        *((_OWORD *)v18 - 3) = v20;
        *((void *)v18 - 1) = 0;
        *(_OWORD *)(v18 - 24) = *(_OWORD *)&v3[v17 - 24];
        *((void *)v18 - 1) = *(void *)&v3[v17 - 8];
        *((void *)v19 - 3) = 0;
        *((void *)v19 - 2) = 0;
        *((void *)v19 - 1) = 0;
        v17 -= 48;
      }
      while (&v3[v17] != v4);
      uint64_t v21 = &v13[v17];
      uint64_t v22 = *(char **)a1;
      long long v3 = *(char **)(a1 + 8);
      *(void *)a1 = v21;
      *(void *)(a1 + 8) = v16;
      *(void *)(a1 + 16) = v14;
      if (v3 != v22)
      {
        do
        {
          int v23 = (void *)*((void *)v3 - 3);
          if (v23)
          {
            *((void *)v3 - 2) = v23;
            operator delete(v23);
          }
          v3 -= 48;
        }
        while (v3 != v22);
        long long v3 = v22;
      }
      if (!v3) {
        return;
      }
    }
    operator delete(v3);
    return;
  }
  if (a2 < v5)
  {
    unsigned int v24 = &v4[48 * a2];
    while (v3 != v24)
    {
      unsigned int v25 = (void *)*((void *)v3 - 3);
      if (v25)
      {
        *((void *)v3 - 2) = v25;
        operator delete(v25);
      }
      v3 -= 48;
    }
    *(void *)(a1 + 8) = v24;
  }
}

void APAC::MetadataBitStreamParser::parseGroupConfig(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  unsigned int v7 = *(_DWORD *)(a4 + 24);
  int v6 = *(_DWORD *)(a4 + 28);
  unsigned int v8 = v7 >> 21;
  int v9 = v6 - 11;
  *(_DWORD *)(a4 + 28) = v6 - 11;
  if (v6 - 11 < 0)
  {
    unint64_t v13 = *(void *)(a4 + 8);
    unint64_t v11 = *(void *)(a4 + 16);
    unsigned int v14 = *(unsigned int **)a4;
    if (((v11 - *(_DWORD *)a4) & ~((uint64_t)(v11 - *(void *)a4) >> 63) & 0xFFFFFFFC) == 0
      || v13 > (unint64_t)v14)
    {
      uint64_t v16 = 0;
      do
      {
        uint64_t v17 = (unsigned __int8 *)v14 + v16;
        unsigned int v18 = v7 << 8;
        *(_DWORD *)(a4 + 24) = v18;
        int v19 = 255;
        if ((unint64_t)v14 + v16 < v11 && (unint64_t)v17 >= v13) {
          int v19 = *v17;
        }
        unsigned int v7 = v19 | v18;
        *(_DWORD *)(a4 + 24) = v7;
        ++v16;
      }
      while (v16 != 4);
    }
    else
    {
      unsigned int v7 = bswap32(*v14);
    }
    unint64_t v12 = v14 + 1;
    *(void *)a4 = v14 + 1;
    int v9 = v6 + 21;
    *(_DWORD *)(a4 + 28) = v6 + 21;
    v8 |= v7 >> (v6 + 21);
    if (v6 == -21)
    {
      unsigned int v10 = 0;
      *(_DWORD *)(a4 + 24) = 0;
    }
    else
    {
      unsigned int v10 = v7 << (11 - v6);
      *(_DWORD *)(a4 + 24) = v10;
    }
  }
  else
  {
    unsigned int v10 = v7 << 11;
    *(_DWORD *)(a4 + 24) = v10;
    unint64_t v11 = *(void *)(a4 + 16);
    unint64_t v12 = *(unsigned int **)a4;
  }
  *(_WORD *)a2 = v8;
  if (v9 + 8 * ((int)v11 - (int)v12) <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v154 = "Cannot read gpCfg.mIsGlobal";
    goto LABEL_246;
  }
  unsigned int v20 = v10 >> 31;
  int v21 = v9 - 1;
  *(_DWORD *)(a4 + 28) = v9 - 1;
  if (v9 - 1 < 0)
  {
    unint64_t v23 = *(void *)(a4 + 8);
    if (((v11 - v12) & ~((uint64_t)(v11 - (void)v12) >> 63) & 0xFFFFFFFC) == 0
      || v23 > (unint64_t)v12)
    {
      uint64_t v25 = 0;
      do
      {
        int v26 = (unsigned __int8 *)v12 + v25;
        unsigned int v27 = v10 << 8;
        *(_DWORD *)(a4 + 24) = v27;
        int v28 = 255;
        if ((unint64_t)v12 + v25 < v11 && (unint64_t)v26 >= v23) {
          int v28 = *v26;
        }
        unsigned int v10 = v28 | v27;
        *(_DWORD *)(a4 + 24) = v10;
        ++v25;
      }
      while (v25 != 4);
    }
    else
    {
      unsigned int v10 = bswap32(*v12);
    }
    int v30 = v9 + 31;
    BOOL v29 = v9 == -31;
    *(_DWORD *)(a4 + 28) = v9 + 31;
    *(void *)a4 = ++v12;
    v20 |= v10 >> (v9 + 31);
    if (v9 == -31) {
      unsigned int v22 = 0;
    }
    else {
      unsigned int v22 = v10 << (1 - v9);
    }
    if (v29) {
      int v21 = 0;
    }
    else {
      int v21 = v30;
    }
  }
  else
  {
    unsigned int v22 = 2 * v10;
  }
  *(_DWORD *)(a4 + 24) = v22;
  *(unsigned char *)(a2 + 2) = v20 != 0;
  if (!v20)
  {
    if (v21 + 8 * ((int)v11 - (int)v12) <= 0)
    {
      exception = __cxa_allocate_exception(8uLL);
      int v154 = "Cannot read gpCfg.mIsPerASC";
      goto LABEL_246;
    }
    unsigned int v31 = v22 >> 31;
    int v32 = v21 - 1;
    *(_DWORD *)(a4 + 28) = v21 - 1;
    if (v21 - 1 < 0)
    {
      unint64_t v34 = *(void *)(a4 + 8);
      if (((v11 - v12) & ~((uint64_t)(v11 - (void)v12) >> 63) & 0xFFFFFFFC) != 0
        && v34 <= (unint64_t)v12)
      {
        unsigned int v22 = bswap32(*v12);
      }
      else
      {
        uint64_t v35 = 0;
        do
        {
          BOOL v36 = (unsigned __int8 *)v12 + v35;
          unsigned int v37 = v22 << 8;
          *(_DWORD *)(a4 + 24) = v37;
          int v38 = 255;
          if ((unint64_t)v12 + v35 < v11 && (unint64_t)v36 >= v34) {
            int v38 = *v36;
          }
          unsigned int v22 = v38 | v37;
          *(_DWORD *)(a4 + 24) = v22;
          ++v35;
        }
        while (v35 != 4);
      }
      unsigned int v39 = v22 << (1 - v21);
      int v40 = v21 + 31;
      *(void *)a4 = ++v12;
      v31 |= v22 >> v40;
      if (v40) {
        unsigned int v33 = v39;
      }
      else {
        unsigned int v33 = 0;
      }
      if (v40) {
        int v32 = v40;
      }
      else {
        int v32 = 0;
      }
    }
    else
    {
      unsigned int v33 = 2 * v22;
    }
    *(unsigned char *)(a2 + 3) = v31 != 0;
    LODWORD(v41) = v33 >> 21;
    int v42 = v32 - 11;
    *(_DWORD *)(a4 + 24) = v33;
    *(_DWORD *)(a4 + 28) = v32 - 11;
    if (v31)
    {
      if (v42 < 0)
      {
        unint64_t v45 = *(void *)(a4 + 8);
        if (((v11 - v12) & ~((uint64_t)(v11 - (void)v12) >> 63) & 0xFFFFFFFC) != 0
          && v45 <= (unint64_t)v12)
        {
          unsigned int v33 = bswap32(*v12);
        }
        else
        {
          uint64_t v47 = 0;
          do
          {
            unint64_t v48 = (unsigned __int8 *)v12 + v47;
            unsigned int v49 = v33 << 8;
            *(_DWORD *)(a4 + 24) = v49;
            int v50 = 255;
            if ((unint64_t)v12 + v47 < v11 && (unint64_t)v48 >= v45) {
              int v50 = *v48;
            }
            unsigned int v33 = v50 | v49;
            *(_DWORD *)(a4 + 24) = v33;
            ++v47;
          }
          while (v47 != 4);
        }
        unsigned int v51 = v33 << (11 - v32);
        int v52 = v32 + 21;
        *(_DWORD *)(a4 + 28) = v52;
        *(void *)a4 = ++v12;
        LODWORD(v41) = (v33 >> v52) | v41;
        if (v52) {
          unsigned int v43 = v51;
        }
        else {
          unsigned int v43 = 0;
        }
        if (v52) {
          int v42 = v52;
        }
        else {
          int v42 = 0;
        }
      }
      else
      {
        unsigned int v43 = v33 << 11;
      }
      *(_DWORD *)(a4 + 24) = v43;
      *(_WORD *)(a2 + 4) = v41;
      if (v42 + 8 * ((int)v11 - (int)v12) <= 2)
      {
        exception = __cxa_allocate_exception(8uLL);
        int v154 = "Cannot read gpCfg.mASCType";
      }
      else
      {
        unsigned int v53 = v43 >> 29;
        int v54 = v42 - 3;
        *(_DWORD *)(a4 + 28) = v42 - 3;
        if (v42 - 3 < 0)
        {
          unint64_t v56 = *(void *)(a4 + 8);
          if (((v11 - v12) & ~((uint64_t)(v11 - (void)v12) >> 63) & 0xFFFFFFFC) != 0
            && v56 <= (unint64_t)v12)
          {
            unsigned int v43 = bswap32(*v12);
          }
          else
          {
            uint64_t v57 = 0;
            do
            {
              unint64_t v58 = (unsigned __int8 *)v12 + v57;
              unsigned int v59 = v43 << 8;
              *(_DWORD *)(a4 + 24) = v59;
              int v60 = 255;
              if ((unint64_t)v12 + v57 < v11 && (unint64_t)v58 >= v56) {
                int v60 = *v58;
              }
              unsigned int v43 = v60 | v59;
              *(_DWORD *)(a4 + 24) = v43;
              ++v57;
            }
            while (v57 != 4);
          }
          int v62 = v42 + 29;
          BOOL v61 = v42 == -29;
          *(_DWORD *)(a4 + 28) = v42 + 29;
          *(void *)a4 = ++v12;
          v53 |= v43 >> (v42 + 29);
          if (v42 == -29) {
            unsigned int v55 = 0;
          }
          else {
            unsigned int v55 = v43 << (3 - v42);
          }
          if (v61) {
            int v54 = 0;
          }
          else {
            int v54 = v62;
          }
        }
        else
        {
          unsigned int v55 = 8 * v43;
        }
        *(_DWORD *)(a4 + 24) = v55;
        *(unsigned char *)(a2 + 6) = v53;
        if (v53 == 2)
        {
          unsigned int v65 = v55 >> 21;
          *(_DWORD *)(a4 + 28) = v54 - 11;
          if (v54 - 11 < 0)
          {
            unint64_t v103 = *(void *)(a4 + 8);
            if (((v11 - v12) & ~((uint64_t)(v11 - (void)v12) >> 63) & 0xFFFFFFFC) != 0
              && v103 <= (unint64_t)v12)
            {
              unsigned int v55 = bswap32(*v12);
            }
            else
            {
              uint64_t v115 = 0;
              do
              {
                int v116 = (unsigned __int8 *)v12 + v115;
                unsigned int v117 = v55 << 8;
                *(_DWORD *)(a4 + 24) = v117;
                int v118 = 255;
                if ((unint64_t)v12 + v115 < v11 && (unint64_t)v116 >= v103) {
                  int v118 = *v116;
                }
                unsigned int v55 = v118 | v117;
                *(_DWORD *)(a4 + 24) = v55;
                ++v115;
              }
              while (v115 != 4);
            }
            unsigned int v66 = v55 << (11 - v54);
            int v119 = v54 + 21;
            *(_DWORD *)(a4 + 28) = v119;
            *(void *)a4 = v12 + 1;
            v65 |= v55 >> v119;
            if (!v119) {
              unsigned int v66 = 0;
            }
          }
          else
          {
            unsigned int v66 = v55 << 11;
          }
          *(_DWORD *)(a4 + 24) = v66;
          *(_WORD *)(a2 + 14) = v65;
          return;
        }
        if (v53 != 1)
        {
          if (!(_BYTE)v53)
          {
            unsigned int v63 = v55 >> 21;
            *(_DWORD *)(a4 + 28) = v54 - 11;
            if (v54 - 11 < 0)
            {
              unint64_t v102 = *(void *)(a4 + 8);
              if (((v11 - v12) & ~((uint64_t)(v11 - (void)v12) >> 63) & 0xFFFFFFFC) != 0
                && v102 <= (unint64_t)v12)
              {
                unsigned int v55 = bswap32(*v12);
              }
              else
              {
                uint64_t v110 = 0;
                do
                {
                  int v111 = (unsigned __int8 *)v12 + v110;
                  unsigned int v112 = v55 << 8;
                  *(_DWORD *)(a4 + 24) = v112;
                  int v113 = 255;
                  if ((unint64_t)v12 + v110 < v11 && (unint64_t)v111 >= v102) {
                    int v113 = *v111;
                  }
                  unsigned int v55 = v113 | v112;
                  *(_DWORD *)(a4 + 24) = v55;
                  ++v110;
                }
                while (v110 != 4);
              }
              unsigned int v64 = v55 << (11 - v54);
              int v114 = v54 + 21;
              *(_DWORD *)(a4 + 28) = v114;
              *(void *)a4 = v12 + 1;
              v63 |= v55 >> v114;
              if (!v114) {
                unsigned int v64 = 0;
              }
            }
            else
            {
              unsigned int v64 = v55 << 11;
            }
            *(_DWORD *)(a4 + 24) = v64;
            *(_WORD *)(a2 + 16) = v63;
          }
          return;
        }
        unsigned int v67 = v55 >> 21;
        int v68 = v54 - 11;
        *(_DWORD *)(a4 + 28) = v54 - 11;
        if (v54 - 11 < 0)
        {
          unint64_t v104 = *(void *)(a4 + 8);
          if (((v11 - v12) & ~((uint64_t)(v11 - (void)v12) >> 63) & 0xFFFFFFFC) != 0
            && v104 <= (unint64_t)v12)
          {
            unsigned int v55 = bswap32(*v12);
          }
          else
          {
            uint64_t v120 = 0;
            do
            {
              uint64_t v121 = (unsigned __int8 *)v12 + v120;
              unsigned int v122 = v55 << 8;
              *(_DWORD *)(a4 + 24) = v122;
              int v123 = 255;
              if ((unint64_t)v12 + v120 < v11 && (unint64_t)v121 >= v104) {
                int v123 = *v121;
              }
              unsigned int v55 = v123 | v122;
              *(_DWORD *)(a4 + 24) = v55;
              ++v120;
            }
            while (v120 != 4);
          }
          unsigned int v124 = v55 << (11 - v54);
          int v125 = v54 + 21;
          *(_DWORD *)(a4 + 28) = v125;
          *(void *)a4 = ++v12;
          v67 |= v55 >> v125;
          if (v125) {
            unsigned int v69 = v124;
          }
          else {
            unsigned int v69 = 0;
          }
          if (v125) {
            int v68 = v125;
          }
          else {
            int v68 = 0;
          }
        }
        else
        {
          unsigned int v69 = v55 << 11;
        }
        *(_DWORD *)(a4 + 24) = v69;
        *(_WORD *)(a2 + 8) = v67;
        if (v68 + 8 * ((int)v11 - (int)v12) > 0)
        {
          unsigned int v126 = v69 >> 31;
          int v127 = v68 - 1;
          *(_DWORD *)(a4 + 28) = v68 - 1;
          if (v68 - 1 < 0)
          {
            unint64_t v129 = *(void *)(a4 + 8);
            if (((v11 - v12) & ~((uint64_t)(v11 - (void)v12) >> 63) & 0xFFFFFFFC) != 0
              && v129 <= (unint64_t)v12)
            {
              unsigned int v69 = bswap32(*v12);
            }
            else
            {
              uint64_t v130 = 0;
              do
              {
                int v131 = (unsigned __int8 *)v12 + v130;
                unsigned int v132 = v69 << 8;
                *(_DWORD *)(a4 + 24) = v132;
                int v133 = 255;
                if ((unint64_t)v12 + v130 < v11 && (unint64_t)v131 >= v129) {
                  int v133 = *v131;
                }
                unsigned int v69 = v133 | v132;
                *(_DWORD *)(a4 + 24) = v69;
                ++v130;
              }
              while (v130 != 4);
            }
            unsigned int v128 = v69 << (1 - v68);
            int v134 = v68 + 31;
            *(_DWORD *)(a4 + 28) = v134;
            *(void *)a4 = ++v12;
            v126 |= v69 >> v134;
            if (v134)
            {
              int v127 = v134;
            }
            else
            {
              unsigned int v128 = 0;
              int v127 = 0;
            }
          }
          else
          {
            unsigned int v128 = 2 * v69;
          }
          *(_DWORD *)(a4 + 24) = v128;
          *(unsigned char *)(a2 + 10) = v126 != 0;
          if (v126)
          {
            unsigned int v135 = v128 >> 21;
            *(_DWORD *)(a4 + 28) = v127 - 11;
            if (v127 - 11 < 0)
            {
              AT::TBitstreamReader<unsigned int>::FillCacheFrom(a4, v12);
              *(void *)a4 += 4;
              unsigned int v137 = *(_DWORD *)(a4 + 24);
              int v138 = *(_DWORD *)(a4 + 28);
              v135 |= v137 >> v138;
              *(_DWORD *)(a4 + 28) = v138 + 32;
              if (v138 == -32) {
                unsigned int v136 = 0;
              }
              else {
                unsigned int v136 = v137 << -(char)v138;
              }
            }
            else
            {
              unsigned int v136 = v128 << 11;
            }
            *(_DWORD *)(a4 + 24) = v136;
            *(_WORD *)(a2 + 12) = v135;
          }
          return;
        }
        exception = __cxa_allocate_exception(8uLL);
        int v154 = "Cannot read gpCfg.mIsObjectInBed";
      }
LABEL_246:
      void *exception = v154;
      __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
    }
    if (v42 < 0)
    {
      unint64_t v46 = *(void *)(a4 + 8);
      if (((v11 - v12) & ~((uint64_t)(v11 - (void)v12) >> 63) & 0xFFFFFFFC) != 0
        && v46 <= (unint64_t)v12)
      {
        unsigned int v33 = bswap32(*v12);
      }
      else
      {
        uint64_t v70 = 0;
        do
        {
          unsigned int v71 = (unsigned __int8 *)v12 + v70;
          unsigned int v72 = v33 << 8;
          *(_DWORD *)(a4 + 24) = v72;
          int v73 = 255;
          if ((unint64_t)v12 + v70 < v11 && (unint64_t)v71 >= v46) {
            int v73 = *v71;
          }
          unsigned int v33 = v73 | v72;
          *(_DWORD *)(a4 + 24) = v33;
          ++v70;
        }
        while (v70 != 4);
      }
      unsigned int v74 = v33 << (11 - v32);
      int v75 = v32 + 21;
      *(_DWORD *)(a4 + 28) = v75;
      *(void *)a4 = ++v12;
      LODWORD(v41) = (v33 >> v75) | v41;
      if (v75) {
        unsigned int v44 = v74;
      }
      else {
        unsigned int v44 = 0;
      }
      if (v75) {
        int v42 = v75;
      }
      else {
        int v42 = 0;
      }
    }
    else
    {
      unsigned int v44 = v33 << 11;
    }
    *(_DWORD *)(a4 + 24) = v44;
    *(_WORD *)(a2 + 18) = v41;
    if (v42 + 8 * ((int)v11 - (int)v12) <= 0)
    {
      exception = __cxa_allocate_exception(8uLL);
      int v154 = "Cannot read gpCfg.mHasConjunctMembers";
      goto LABEL_246;
    }
    unsigned int v76 = v44 >> 31;
    int v77 = v42 - 1;
    *(_DWORD *)(a4 + 28) = v42 - 1;
    if (v42 - 1 < 0)
    {
      unint64_t v79 = *(void *)(a4 + 8);
      if (((v11 - v12) & ~((uint64_t)(v11 - (void)v12) >> 63) & 0xFFFFFFFC) != 0
        && v79 <= (unint64_t)v12)
      {
        unsigned int v44 = bswap32(*v12);
      }
      else
      {
        uint64_t v80 = 0;
        do
        {
          unsigned int v81 = (unsigned __int8 *)v12 + v80;
          unsigned int v82 = v44 << 8;
          *(_DWORD *)(a4 + 24) = v82;
          int v83 = 255;
          if ((unint64_t)v12 + v80 < v11 && (unint64_t)v81 >= v79) {
            int v83 = *v81;
          }
          unsigned int v44 = v83 | v82;
          *(_DWORD *)(a4 + 24) = v44;
          ++v80;
        }
        while (v80 != 4);
      }
      int v85 = v42 + 31;
      BOOL v84 = v42 == -31;
      *(_DWORD *)(a4 + 28) = v42 + 31;
      *(void *)a4 = ++v12;
      v76 |= v44 >> (v42 + 31);
      if (v42 == -31) {
        unsigned int v78 = 0;
      }
      else {
        unsigned int v78 = v44 << (1 - v42);
      }
      if (v84) {
        int v77 = 0;
      }
      else {
        int v77 = v85;
      }
    }
    else
    {
      unsigned int v78 = 2 * v44;
    }
    *(_DWORD *)(a4 + 24) = v78;
    *(unsigned char *)(a2 + 20) = v76 != 0;
    if (v76)
    {
      unsigned int v86 = v78 >> 21;
      *(_DWORD *)(a4 + 28) = v77 - 11;
      if (v77 - 11 < 0)
      {
        unint64_t v101 = *(void *)(a4 + 8);
        if (((v11 - v12) & ~((uint64_t)(v11 - (void)v12) >> 63) & 0xFFFFFFFC) != 0
          && v101 <= (unint64_t)v12)
        {
          unsigned int v78 = bswap32(*v12);
        }
        else
        {
          uint64_t v105 = 0;
          do
          {
            unint64_t v106 = (unsigned __int8 *)v12 + v105;
            unsigned int v107 = v78 << 8;
            *(_DWORD *)(a4 + 24) = v107;
            int v108 = 255;
            if ((unint64_t)v12 + v105 < v11 && (unint64_t)v106 >= v101) {
              int v108 = *v106;
            }
            unsigned int v78 = v108 | v107;
            *(_DWORD *)(a4 + 24) = v78;
            ++v105;
          }
          while (v105 != 4);
        }
        unsigned int v87 = v78 << (11 - v77);
        *(_DWORD *)(a4 + 28) = v77 + 21;
        *(void *)a4 = v12 + 1;
        v86 |= v78 >> (v77 + 21);
        if (v77 == -21) {
          unsigned int v87 = 0;
        }
      }
      else
      {
        unsigned int v87 = v78 << 11;
      }
      *(_DWORD *)(a4 + 24) = v87;
      *(_WORD *)(a2 + 22) = v86;
      return;
    }
    uint64_t v88 = (unsigned __int16)v41;
    if (a3)
    {
      unsigned int v89 = *(char **)(a2 + 24);
      int v90 = *(unsigned char **)(a2 + 32);
      unint64_t v91 = (v90 - v89) >> 1;
      if ((unsigned __int16)v41 <= v91)
      {
        if ((unsigned __int16)v41 >= v91) {
          goto LABEL_218;
        }
        int v109 = &v89[2 * (unsigned __int16)v41];
      }
      else
      {
        unint64_t v92 = (unsigned __int16)v41 - v91;
        uint64_t v93 = *(void *)(a2 + 40);
        if (v92 > (v93 - (uint64_t)v90) >> 1)
        {
          unint64_t v94 = v93 - (void)v89;
          if (v94 <= (unsigned __int16)v41) {
            unint64_t v41 = (unsigned __int16)v41;
          }
          else {
            unint64_t v41 = v94;
          }
          if (v94 >= 0x7FFFFFFFFFFFFFFELL) {
            uint64_t v95 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v95 = v41;
          }
          if (v95 < 0) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          unsigned int v96 = (char *)operator new(2 * v95);
          int v97 = &v96[2 * v91];
          uint64_t v98 = &v96[2 * v95];
          bzero(v97, 2 * v92);
          unint64_t v99 = &v97[2 * v92];
          while (v90 != v89)
          {
            __int16 v100 = *((_WORD *)v90 - 1);
            v90 -= 2;
            *((_WORD *)v97 - 1) = v100;
            v97 -= 2;
          }
          *(void *)(a2 + 24) = v97;
          *(void *)(a2 + 32) = v99;
          *(void *)(a2 + 40) = v98;
          if (v89) {
            operator delete(v89);
          }
          goto LABEL_218;
        }
        bzero(*(void **)(a2 + 32), 2 * v92);
        int v109 = &v90[2 * v92];
      }
      *(void *)(a2 + 32) = v109;
    }
LABEL_218:
    if (v88)
    {
      uint64_t v139 = 0;
      unsigned int v141 = *(_DWORD *)(a4 + 24);
      int v140 = *(_DWORD *)(a4 + 28);
      unint64_t v143 = *(void *)(a4 + 8);
      unint64_t v142 = *(void *)(a4 + 16);
      int v144 = *(unsigned int **)a4;
      uint64_t v145 = *(void *)(a2 + 24);
      do
      {
        unsigned int v146 = v141 >> 21;
        *(_DWORD *)(a4 + 28) = v140 - 11;
        if (v140 - 11 < 0)
        {
          if (((v142 - v144) & ~((uint64_t)(v142 - (void)v144) >> 63) & 0xFFFFFFFC) == 0
            || v143 > (unint64_t)v144)
          {
            uint64_t v148 = 0;
            do
            {
              unint64_t v149 = (unsigned __int8 *)v144 + v148;
              unsigned int v150 = v141 << 8;
              *(_DWORD *)(a4 + 24) = v150;
              int v151 = 255;
              if ((unint64_t)v144 + v148 < v142 && (unint64_t)v149 >= v143) {
                int v151 = *v149;
              }
              unsigned int v141 = v151 | v150;
              *(_DWORD *)(a4 + 24) = v141;
              ++v148;
            }
            while (v148 != 4);
          }
          else
          {
            unsigned int v141 = bswap32(*v144);
          }
          unsigned int v152 = v141 << (11 - v140);
          v140 += 21;
          *(_DWORD *)(a4 + 28) = v140;
          *(void *)a4 = ++v144;
          v146 |= v141 >> v140;
          if (v140) {
            unsigned int v141 = v152;
          }
          else {
            unsigned int v141 = 0;
          }
          if (!v140) {
            int v140 = 0;
          }
        }
        else
        {
          v141 <<= 11;
          v140 -= 11;
        }
        *(_DWORD *)(a4 + 24) = v141;
        *(_WORD *)(v145 + 2 * v139++) = v146;
      }
      while (v139 != v88);
    }
  }
}

void APAC::MetadataBitStreamParser::parseRendererMetadata(unint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 16);
  unint64_t v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 10)
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = "Cannot read rMd.mGroupCount";
    __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
  }
  unsigned int v10 = *(_DWORD *)(a3 + 24);
  unsigned int v11 = v10 >> 21;
  *(_DWORD *)(a3 + 28) = v6 - 11;
  if (v6 - 11 < 0)
  {
    uint64_t v13 = v5 & ~(v5 >> 63) & 0xFFFFFFFC;
    unint64_t v14 = *(void *)(a3 + 8);
    if (v13) {
      BOOL v15 = v14 > (unint64_t)v4;
    }
    else {
      BOOL v15 = 1;
    }
    if (v15)
    {
      uint64_t v16 = 0;
      do
      {
        uint64_t v17 = (unsigned __int8 *)v4 + v16;
        unsigned int v18 = v10 << 8;
        *(_DWORD *)(a3 + 24) = v18;
        int v19 = 255;
        if ((unint64_t)v4 + v16 < v3 && (unint64_t)v17 >= v14) {
          int v19 = *v17;
        }
        unsigned int v10 = v19 | v18;
        *(_DWORD *)(a3 + 24) = v10;
        ++v16;
      }
      while (v16 != 4);
    }
    else
    {
      unsigned int v10 = bswap32(*v4);
    }
    unsigned int v20 = v10 << (11 - v6);
    int v21 = v6 + 21;
    *(_DWORD *)(a3 + 28) = v21;
    *(void *)a3 = v4 + 1;
    v11 |= v10 >> v21;
    if (v21) {
      unsigned int v12 = v20;
    }
    else {
      unsigned int v12 = 0;
    }
  }
  else
  {
    unsigned int v12 = v10 << 11;
  }
  *(_DWORD *)(a3 + 24) = v12;
  *(_WORD *)a2 = v11;
  unint64_t v22 = (unsigned __int16)v11;
  uint64_t v23 = *(void *)(a2 + 4808);
  uint64_t v24 = *(void *)(a2 + 4800);
  unint64_t v25 = 0xB81DC085AE2E9061 * ((v23 - v24) >> 3);
  unint64_t v26 = v22 - v25;
  if (v22 <= v25)
  {
    if (v22 < v25)
    {
      uint64_t v73 = v24 + 40200 * v22;
      while (v23 != v73)
      {
        v23 -= 40200;
        std::__destroy_at[abi:ne180100]<APAC::Metadata::GroupData,0>(v23);
      }
      *(void *)(a2 + 4808) = v73;
    }
  }
  else
  {
    uint64_t v27 = *(void *)(a2 + 4816);
    if (0xB81DC085AE2E9061 * ((v27 - v23) >> 3) < v26)
    {
      unint64_t v28 = 0xB81DC085AE2E9061 * ((v27 - v24) >> 3);
      uint64_t v29 = 2 * v28;
      if (2 * v28 <= v22) {
        uint64_t v29 = v22;
      }
      if (v28 >= 0xD0ABFDC22706) {
        unint64_t v30 = 0x1A157FB844E0CLL;
      }
      else {
        unint64_t v30 = v29;
      }
      if (v30 > 0x1A157FB844E0CLL) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      unsigned int v31 = (char *)operator new(40200 * v30);
      int v32 = &v31[40200 * v25];
      unsigned int v81 = &v31[40200 * v22];
      int v82 = v22;
      uint64_t v33 = 40200 * v22 - 40200 * v25;
      uint64_t v34 = (uint64_t)(v32 + 8);
      do
      {
        bzero((void *)(v34 - 8), 0x9D08uLL);
        std::array<APAC::Metadata::GroupData::BlockData,32ul>::array(v34);
        v34 += 40200;
        v33 -= 40200;
      }
      while (v33);
      uint64_t v35 = &v31[40200 * v30];
      BOOL v36 = *(char **)(a2 + 4808);
      int v83 = *(char **)(a2 + 4800);
      if (v36 == v83)
      {
        *(void *)(a2 + 4800) = v32;
        *(void *)(a2 + 4808) = v81;
        *(void *)(a2 + 4816) = v35;
        if (!v36) {
          goto LABEL_46;
        }
      }
      else
      {
        unint64_t v79 = v35;
        unint64_t v80 = a1;
        do
        {
          uint64_t v37 = 0;
          int v38 = v36 - 38944;
          v36 -= 40200;
          int v39 = *(_DWORD *)v36;
          int v40 = v32 - 38944;
          v32 -= 40200;
          v32[4] = v36[4];
          *(_DWORD *)int v32 = v39;
          uint64_t v41 = 32;
          do
          {
            int v42 = &v40[v37];
            unsigned int v43 = &v38[v37];
            int v44 = *(_DWORD *)&v38[v37 - 1248];
            uint64_t v45 = (uint64_t)&v40[v37 - 1248];
            *(_WORD *)(v45 + 4) = *(_WORD *)&v38[v37 - 1244];
            *(_DWORD *)uint64_t v45 = v44;
            memcpy(&v40[v37 - 1240], &v38[v37 - 1240], 0x314uLL);
            uint64_t v46 = (uint64_t)&v40[v37 - 448];
            uint64_t v47 = *(void *)&v38[v37 - 448];
            *(_DWORD *)(v46 + 8) = *(_DWORD *)&v38[v37 - 440];
            *(void *)uint64_t v46 = v47;
            uint64_t v48 = *(void *)&v38[v37 - 432];
            unsigned int v49 = &v40[v37 - 424];
            uint64_t v50 = (uint64_t)&v38[v37 - 424];
            *((void *)v49 + 1) = 0;
            *((void *)v49 + 2) = 0;
            *((void *)v42 - 54) = v48;
            *(void *)unsigned int v49 = 0;
            *(_OWORD *)unsigned int v49 = *(_OWORD *)v50;
            *((void *)v42 - 51) = *(void *)&v38[v37 - 408];
            *((void *)v43 - 52) = 0;
            *(void *)uint64_t v50 = 0;
            *(void *)(v50 + 16) = 0;
            unsigned int v51 = &v40[v37 - 400];
            uint64_t v52 = (uint64_t)&v38[v37 - 400];
            *((void *)v51 + 2) = 0;
            *(void *)unsigned int v51 = 0;
            *((void *)v42 - 49) = 0;
            *(_OWORD *)unsigned int v51 = *(_OWORD *)v52;
            *((void *)v42 - 48) = *(void *)&v38[v37 - 384];
            *((void *)v43 - 49) = 0;
            *(void *)uint64_t v52 = 0;
            unsigned int v53 = &v40[v37 - 376];
            uint64_t v54 = (uint64_t)&v38[v37 - 376];
            *(void *)(v52 + 16) = 0;
            *((void *)v53 + 2) = 0;
            *(void *)unsigned int v53 = 0;
            *((void *)v42 - 46) = 0;
            *(_OWORD *)unsigned int v53 = *(_OWORD *)v54;
            *((void *)v42 - 45) = *(void *)&v38[v37 - 360];
            *((void *)v43 - 46) = 0;
            *(void *)uint64_t v54 = 0;
            *(void *)(v54 + 16) = 0;
            unsigned int v55 = &v40[v37 - 352];
            uint64_t v56 = (uint64_t)&v38[v37 - 352];
            *((void *)v55 + 2) = 0;
            *(void *)unsigned int v55 = 0;
            *((void *)v42 - 43) = 0;
            *(_OWORD *)unsigned int v55 = *(_OWORD *)v56;
            *((void *)v42 - 42) = *(void *)&v38[v37 - 336];
            *((void *)v43 - 43) = 0;
            *(void *)uint64_t v56 = 0;
            *(void *)(v56 + 16) = 0;
            uint64_t v57 = &v40[v37 - 328];
            uint64_t v58 = (uint64_t)&v38[v37 - 328];
            *((void *)v57 + 2) = 0;
            *(void *)uint64_t v57 = 0;
            *((void *)v42 - 40) = 0;
            *(_OWORD *)uint64_t v57 = *(_OWORD *)v58;
            *((void *)v42 - 39) = *(void *)&v38[v37 - 312];
            *((void *)v43 - 40) = 0;
            *(void *)uint64_t v58 = 0;
            unsigned int v59 = &v40[v37 - 304];
            uint64_t v60 = (uint64_t)&v38[v37 - 304];
            *(void *)(v58 + 16) = 0;
            *((void *)v59 + 2) = 0;
            *(void *)unsigned int v59 = 0;
            *((void *)v42 - 37) = 0;
            *(_OWORD *)unsigned int v59 = *(_OWORD *)v60;
            *((void *)v42 - 36) = *(void *)&v38[v37 - 288];
            *((void *)v43 - 37) = 0;
            *(void *)uint64_t v60 = 0;
            *(void *)(v60 + 16) = 0;
            *((void *)v42 - 35) = *(void *)&v38[v37 - 280];
            LOWORD(v58) = *(_WORD *)&v38[v37 - 272];
            BOOL v61 = &v40[v37 - 264];
            *((void *)v42 - 32) = 0;
            *((void *)v42 - 31) = 0;
            *(void *)BOOL v61 = 0;
            *(_OWORD *)BOOL v61 = *(_OWORD *)&v38[v37 - 264];
            uint64_t v62 = *(void *)&v38[v37 - 248];
            *((_WORD *)v42 - 136) = v58;
            *((void *)v42 - 31) = v62;
            *((void *)v43 - 33) = 0;
            *((void *)v43 - 32) = 0;
            *((void *)v43 - 31) = 0;
            *((void *)v42 - 29) = 0;
            *((void *)v42 - 28) = 0;
            *((void *)v42 - 30) = 0;
            *((_OWORD *)v42 - 15) = *(_OWORD *)&v38[v37 - 240];
            *((void *)v42 - 28) = *(void *)&v38[v37 - 224];
            *((void *)v43 - 30) = 0;
            *((void *)v43 - 29) = 0;
            long long v63 = *(_OWORD *)&v38[v37 - 168];
            long long v64 = *(_OWORD *)&v38[v37 - 120];
            long long v65 = *(_OWORD *)&v38[v37 - 136];
            long long v66 = *(_OWORD *)&v38[v37 - 152];
            *((void *)v43 - 28) = 0;
            *(_OWORD *)(v42 - 152) = v66;
            *(_OWORD *)(v42 - 136) = v65;
            *(_OWORD *)(v42 - 120) = v64;
            *(_OWORD *)(v42 - 168) = v63;
            long long v67 = *(_OWORD *)&v38[v37 - 59];
            long long v68 = *(_OWORD *)&v38[v37 - 72];
            long long v69 = *(_OWORD *)&v38[v37 - 88];
            *(_OWORD *)(v42 - 104) = *(_OWORD *)&v38[v37 - 104];
            *(_OWORD *)(v42 - 88) = v69;
            *(_OWORD *)(v42 - 72) = v68;
            *(_OWORD *)(v42 - 59) = v67;
            long long v70 = *(_OWORD *)&v38[v37 - 184];
            long long v71 = *(_OWORD *)&v38[v37 - 200];
            *(_OWORD *)(v42 - 216) = *(_OWORD *)&v38[v37 - 216];
            *(_OWORD *)(v42 - 200) = v71;
            *(_OWORD *)(v42 - 184) = v70;
            LODWORD(v59) = *(_DWORD *)&v38[v37 - 32];
            *((void *)v42 - 5) = *(void *)&v38[v37 - 40];
            *((void *)v42 - 2) = 0;
            *((void *)v42 - 1) = 0;
            *((void *)v42 - 3) = 0;
            *((_DWORD *)v42 - 8) = v59;
            *(_OWORD *)(v42 - 24) = *(_OWORD *)&v38[v37 - 24];
            *((void *)v42 - 1) = *(void *)&v38[v37 - 8];
            *((void *)v43 - 3) = 0;
            *((void *)v43 - 2) = 0;
            *((void *)v43 - 1) = 0;
            *(void *)int v42 = *(void *)&v38[v37];
            v37 += 1256;
            --v41;
          }
          while (v41);
        }
        while (v36 != v83);
        unsigned int v72 = *(char **)(a2 + 4800);
        BOOL v36 = *(char **)(a2 + 4808);
        *(void *)(a2 + 4800) = v32;
        LODWORD(v22) = v82;
        *(void *)(a2 + 4808) = v81;
        *(void *)(a2 + 4816) = v79;
        if (v36 == v72)
        {
          a1 = v80;
          if (!v36) {
            goto LABEL_46;
          }
        }
        else
        {
          a1 = v80;
          do
          {
            v36 -= 40200;
            std::__destroy_at[abi:ne180100]<APAC::Metadata::GroupData,0>((uint64_t)v36);
          }
          while (v36 != v72);
          BOOL v36 = v72;
          if (!v72) {
            goto LABEL_46;
          }
        }
      }
      operator delete(v36);
      goto LABEL_46;
    }
    unint64_t v74 = v23 + 40200 * v26;
    uint64_t v75 = 40200 * v22 - 8 * ((v23 - v24) >> 3);
    uint64_t v76 = v23 + 8;
    do
    {
      bzero((void *)(v76 - 8), 0x9D08uLL);
      std::array<APAC::Metadata::GroupData::BlockData,32ul>::array(v76);
      v76 += 40200;
      v75 -= 40200;
    }
    while (v75);
    *(void *)(a2 + 4808) = v74;
  }
LABEL_46:
  if (v22)
  {
    uint64_t v77 = 0;
    do
    {
      APAC::MetadataBitStreamParser::parseGroupData(a1, *(void *)(a2 + 4800) + v77, a3);
      v77 += 40200;
    }
    while (40200 * v22 != v77);
  }
}

void APAC::MetadataBitStreamParser::parseGroupData(unint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 16);
  unint64_t v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    unsigned int v43 = "Cannot read gpData.mHasData";
    goto LABEL_59;
  }
  unsigned int v9 = *(_DWORD *)(a3 + 24);
  unsigned int v10 = v9 >> 31;
  int v11 = v6 - 1;
  *(_DWORD *)(a3 + 28) = v6 - 1;
  if (v6 - 1 < 0)
  {
    unint64_t v13 = *(void *)(a3 + 8);
    if ((v5 & ~(v5 >> 63) & 0xFFFFFFFC) == 0 || v13 > (unint64_t)v4)
    {
      uint64_t v15 = 0;
      do
      {
        uint64_t v16 = (unsigned __int8 *)v4 + v15;
        unsigned int v17 = v9 << 8;
        *(_DWORD *)(a3 + 24) = v17;
        int v18 = 255;
        if ((unint64_t)v4 + v15 < v3 && (unint64_t)v16 >= v13) {
          int v18 = *v16;
        }
        unsigned int v9 = v18 | v17;
        *(_DWORD *)(a3 + 24) = v9;
        ++v15;
      }
      while (v15 != 4);
    }
    else
    {
      unsigned int v9 = bswap32(*v4);
    }
    unsigned int v19 = v9 << (1 - v6);
    int v20 = v6 + 31;
    *(_DWORD *)(a3 + 28) = v20;
    *(void *)a3 = ++v4;
    v10 |= v9 >> v20;
    if (v20) {
      unsigned int v12 = v19;
    }
    else {
      unsigned int v12 = 0;
    }
    if (v20) {
      int v11 = v20;
    }
    else {
      int v11 = 0;
    }
  }
  else
  {
    unsigned int v12 = 2 * v9;
  }
  *(_DWORD *)(a3 + 24) = v12;
  *(unsigned char *)a2 = v10 != 0;
  if (v10)
  {
    if (v11 + 8 * ((int)v3 - (int)v4) <= 10)
    {
      exception = __cxa_allocate_exception(8uLL);
      unsigned int v43 = "Cannot read gpData.mGroupID";
    }
    else
    {
      unsigned int v21 = v12 >> 21;
      int v22 = v11 - 11;
      *(_DWORD *)(a3 + 28) = v11 - 11;
      if (v11 - 11 < 0)
      {
        unint64_t v24 = *(void *)(a3 + 8);
        if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
          && v24 <= (unint64_t)v4)
        {
          unsigned int v12 = bswap32(*v4);
        }
        else
        {
          uint64_t v25 = 0;
          do
          {
            unint64_t v26 = (unsigned __int8 *)v4 + v25;
            unsigned int v27 = v12 << 8;
            *(_DWORD *)(a3 + 24) = v27;
            int v28 = 255;
            if ((unint64_t)v4 + v25 < v3 && (unint64_t)v26 >= v24) {
              int v28 = *v26;
            }
            unsigned int v12 = v28 | v27;
            *(_DWORD *)(a3 + 24) = v12;
            ++v25;
          }
          while (v25 != 4);
        }
        unsigned int v29 = v12 << (11 - v11);
        int v30 = v11 + 21;
        *(_DWORD *)(a3 + 28) = v30;
        *(void *)a3 = ++v4;
        v21 |= v12 >> v30;
        if (v30) {
          unsigned int v23 = v29;
        }
        else {
          unsigned int v23 = 0;
        }
        if (v30) {
          int v22 = v30;
        }
        else {
          int v22 = 0;
        }
      }
      else
      {
        unsigned int v23 = v12 << 11;
      }
      *(_DWORD *)(a3 + 24) = v23;
      *(_WORD *)(a2 + 2) = v21;
      if (v22 + 8 * ((int)v3 - (int)v4) > 5)
      {
        unsigned int v31 = v23 >> 26;
        *(_DWORD *)(a3 + 28) = v22 - 6;
        if (v22 - 6 < 0)
        {
          unint64_t v33 = *(void *)(a3 + 8);
          if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
            && v33 <= (unint64_t)v4)
          {
            unsigned int v23 = bswap32(*v4);
          }
          else
          {
            uint64_t v34 = 0;
            do
            {
              uint64_t v35 = (unsigned __int8 *)v4 + v34;
              unsigned int v36 = v23 << 8;
              *(_DWORD *)(a3 + 24) = v36;
              int v37 = 255;
              if ((unint64_t)v4 + v34 < v3 && (unint64_t)v35 >= v33) {
                int v37 = *v35;
              }
              unsigned int v23 = v37 | v36;
              *(_DWORD *)(a3 + 24) = v23;
              ++v34;
            }
            while (v34 != 4);
          }
          unsigned int v38 = v23 << (6 - v22);
          int v39 = v22 + 26;
          *(_DWORD *)(a3 + 28) = v39;
          *(void *)a3 = v4 + 1;
          v31 |= v23 >> v39;
          if (v39) {
            unsigned int v32 = v38;
          }
          else {
            unsigned int v32 = 0;
          }
        }
        else
        {
          unsigned int v32 = v23 << 6;
        }
        *(_DWORD *)(a3 + 24) = v32;
        *(unsigned char *)(a2 + 4) = v31;
        uint64_t v40 = v31;
        if ((_BYTE)v31)
        {
          uint64_t v41 = a2 + 8;
          do
          {
            APAC::MetadataBitStreamParser::parseBlockData(a1, v41, a3);
            v41 += 1256;
            --v40;
          }
          while (v40);
        }
        return;
      }
      exception = __cxa_allocate_exception(8uLL);
      unsigned int v43 = "Cannot read gpData.mNumBlocks";
    }
LABEL_59:
    void *exception = v43;
    __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
  }
}

void APAC::MetadataBitStreamParser::parseBlockData(unint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 16);
  unint64_t v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 9)
  {
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v40 = "Cannot read blkMd.mRtime";
    goto LABEL_59;
  }
  unsigned int v7 = *(_DWORD *)(a3 + 24);
  unsigned int v8 = v7 >> 22;
  int v9 = v6 - 10;
  *(_DWORD *)(a3 + 28) = v6 - 10;
  if (v6 - 10 < 0)
  {
    unint64_t v11 = *(void *)(a3 + 8);
    if ((v5 & ~(v5 >> 63) & 0xFFFFFFFC) == 0 || v11 > (unint64_t)v4)
    {
      uint64_t v13 = 0;
      do
      {
        unint64_t v14 = (unsigned __int8 *)v4 + v13;
        unsigned int v15 = v7 << 8;
        *(_DWORD *)(a3 + 24) = v15;
        int v16 = 255;
        if ((unint64_t)v4 + v13 < v3 && (unint64_t)v14 >= v11) {
          int v16 = *v14;
        }
        unsigned int v7 = v16 | v15;
        *(_DWORD *)(a3 + 24) = v7;
        ++v13;
      }
      while (v13 != 4);
    }
    else
    {
      unsigned int v7 = bswap32(*v4);
    }
    unsigned int v17 = v7 << (10 - v6);
    int v18 = v6 + 22;
    *(_DWORD *)(a3 + 28) = v18;
    *(void *)a3 = ++v4;
    v8 |= v7 >> v18;
    if (v18) {
      unsigned int v10 = v17;
    }
    else {
      unsigned int v10 = 0;
    }
    if (v18) {
      int v9 = v18;
    }
    else {
      int v9 = 0;
    }
  }
  else
  {
    unsigned int v10 = v7 << 10;
  }
  *(_DWORD *)(a3 + 24) = v10;
  *(_WORD *)a2 = v8;
  if (v9 + 8 * ((int)v3 - (int)v4) <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v40 = "Cannot read blkMd.mHasInterpolationLength";
    goto LABEL_59;
  }
  unsigned int v19 = v10 >> 31;
  int v20 = v9 - 1;
  *(_DWORD *)(a3 + 28) = v9 - 1;
  if (v9 - 1 < 0)
  {
    unint64_t v22 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v22 <= (unint64_t)v4)
    {
      unsigned int v10 = bswap32(*v4);
    }
    else
    {
      uint64_t v23 = 0;
      do
      {
        unint64_t v24 = (unsigned __int8 *)v4 + v23;
        unsigned int v25 = v10 << 8;
        *(_DWORD *)(a3 + 24) = v25;
        int v26 = 255;
        if ((unint64_t)v4 + v23 < v3 && (unint64_t)v24 >= v22) {
          int v26 = *v24;
        }
        unsigned int v10 = v26 | v25;
        *(_DWORD *)(a3 + 24) = v10;
        ++v23;
      }
      while (v23 != 4);
    }
    int v28 = v9 + 31;
    BOOL v27 = v9 == -31;
    *(_DWORD *)(a3 + 28) = v9 + 31;
    *(void *)a3 = ++v4;
    v19 |= v10 >> (v9 + 31);
    if (v9 == -31) {
      unsigned int v21 = 0;
    }
    else {
      unsigned int v21 = v10 << (1 - v9);
    }
    if (v27) {
      int v20 = 0;
    }
    else {
      int v20 = v28;
    }
  }
  else
  {
    unsigned int v21 = 2 * v10;
  }
  *(_DWORD *)(a3 + 24) = v21;
  *(unsigned char *)(a2 + 2) = v19 != 0;
  if (v19)
  {
    if (v20 + 8 * ((int)v3 - (int)v4) > 10)
    {
      unsigned int v29 = v21 >> 21;
      *(_DWORD *)(a3 + 28) = v20 - 11;
      if (v20 - 11 < 0)
      {
        unint64_t v31 = *(void *)(a3 + 8);
        if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
          && v31 <= (unint64_t)v4)
        {
          unsigned int v21 = bswap32(*v4);
        }
        else
        {
          uint64_t v32 = 0;
          do
          {
            unint64_t v33 = (unsigned __int8 *)v4 + v32;
            unsigned int v34 = v21 << 8;
            *(_DWORD *)(a3 + 24) = v34;
            int v35 = 255;
            if ((unint64_t)v4 + v32 < v3 && (unint64_t)v33 >= v31) {
              int v35 = *v33;
            }
            unsigned int v21 = v35 | v34;
            *(_DWORD *)(a3 + 24) = v21;
            ++v32;
          }
          while (v32 != 4);
        }
        unsigned int v36 = v21 << (11 - v20);
        int v37 = v20 + 21;
        *(_DWORD *)(a3 + 28) = v37;
        *(void *)a3 = v4 + 1;
        v29 |= v21 >> v37;
        if (v37) {
          unsigned int v30 = v36;
        }
        else {
          unsigned int v30 = 0;
        }
      }
      else
      {
        unsigned int v30 = v21 << 11;
      }
      *(_DWORD *)(a3 + 24) = v30;
      *(_WORD *)(a2 + 4) = v29;
      goto LABEL_53;
    }
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v40 = "Cannot read blkMd.mInterpolationLength";
LABEL_59:
    void *exception = v40;
    __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
  }
LABEL_53:
  uint64_t v38 = a2 + 8;
  APAC::MetadataBitStreamParser::parseRendererData(a1, v38, 0, a3);
}

void APAC::MetadataBitStreamParser::parseRendererData(unint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  unsigned int v8 = *(_DWORD *)(a4 + 24);
  int v7 = *(_DWORD *)(a4 + 28);
  unsigned int v9 = v8 >> 21;
  *(_DWORD *)(a4 + 28) = v7 - 11;
  if (v7 - 11 < 0)
  {
    unint64_t v12 = *(void *)(a4 + 8);
    unint64_t v11 = *(void *)(a4 + 16);
    uint64_t v13 = *(unsigned int **)a4;
    if (((v11 - *(_DWORD *)a4) & ~((uint64_t)(v11 - *(void *)a4) >> 63) & 0xFFFFFFFC) == 0
      || v12 > (unint64_t)v13)
    {
      uint64_t v15 = 0;
      do
      {
        int v16 = (unsigned __int8 *)v13 + v15;
        unsigned int v17 = v8 << 8;
        *(_DWORD *)(a4 + 24) = v17;
        int v18 = 255;
        if ((unint64_t)v13 + v15 < v11 && (unint64_t)v16 >= v12) {
          int v18 = *v16;
        }
        unsigned int v8 = v18 | v17;
        *(_DWORD *)(a4 + 24) = v8;
        ++v15;
      }
      while (v15 != 4);
    }
    else
    {
      unsigned int v8 = bswap32(*v13);
    }
    unsigned int v19 = v8 << (11 - v7);
    int v20 = v7 + 21;
    *(_DWORD *)(a4 + 28) = v20;
    *(void *)a4 = v13 + 1;
    v9 |= v8 >> v20;
    if (v20) {
      unsigned int v10 = v19;
    }
    else {
      unsigned int v10 = 0;
    }
  }
  else
  {
    unsigned int v10 = v8 << 11;
  }
  *(_DWORD *)(a4 + 24) = v10;
  *(_WORD *)(a2 + 2) = v9;
  if (v9)
  {
    uint64_t v21 = 0;
    uint64_t v268 = a2 + 1200;
    uint64_t v269 = a2 + 1244;
    uint64_t v266 = a2 + 1096;
    uint64_t v267 = a2 + 1148;
    uint64_t v264 = a2 + 780;
    uint64_t v265 = a2 + 792;
    uint64_t v262 = a2 + 1044;
    uint64_t v263 = a2 + 568;
    uint64_t v260 = a2 + 148;
    v261 = (BOOL *)(a2 + 172);
    uint64_t v22 = v9;
    do
    {
      unsigned int v24 = *(_DWORD *)(a4 + 24);
      int v23 = *(_DWORD *)(a4 + 28);
      unsigned int v25 = v24 >> 21;
      int v26 = v23 - 11;
      *(_DWORD *)(a4 + 28) = v23 - 11;
      if (v23 - 11 < 0)
      {
        unint64_t v29 = *(void *)(a4 + 8);
        unint64_t v28 = *(void *)(a4 + 16);
        unsigned int v30 = *(unsigned int **)a4;
        if (((v28 - *(_DWORD *)a4) & ~((uint64_t)(v28 - *(void *)a4) >> 63) & 0xFFFFFFFC) == 0
          || v29 > (unint64_t)v30)
        {
          uint64_t v32 = 0;
          do
          {
            unint64_t v33 = (unsigned __int8 *)v30 + v32;
            unsigned int v34 = v24 << 8;
            *(_DWORD *)(a4 + 24) = v34;
            int v35 = 255;
            if ((unint64_t)v30 + v32 < v28 && (unint64_t)v33 >= v29) {
              int v35 = *v33;
            }
            unsigned int v24 = v35 | v34;
            *(_DWORD *)(a4 + 24) = v24;
            ++v32;
          }
          while (v32 != 4);
        }
        else
        {
          unsigned int v24 = bswap32(*v30);
        }
        int v37 = v23 + 21;
        BOOL v36 = v23 == -21;
        *(_DWORD *)(a4 + 28) = v23 + 21;
        *(void *)a4 = v30 + 1;
        v25 |= v24 >> (v23 + 21);
        if (v23 == -21) {
          unsigned int v27 = 0;
        }
        else {
          unsigned int v27 = v24 << (11 - v23);
        }
        if (v36) {
          int v26 = 0;
        }
        else {
          int v26 = v37;
        }
      }
      else
      {
        unsigned int v27 = v24 << 11;
      }
      *(_DWORD *)(a4 + 24) = v27;
      *(_WORD *)(a2 + 4 + 2 * v21) = v25;
      switch(v25)
      {
        case 0u:
          uint64_t v38 = a2 + 68;
          goto LABEL_118;
        case 1u:
          APAC::MetadataBitStreamParser::parseObjectSpread(a1, a2 + 116, a4);
          break;
        case 2u:
          unint64_t v39 = *(void *)(a4 + 16);
          uint64_t v40 = *(unsigned int **)a4;
          uint64_t v41 = v39 - *(void *)a4;
          if (v26 + 8 * (int)v41 <= 31)
          {
            exception = __cxa_allocate_exception(8uLL);
            v259 = "Cannot read rData.mGain";
            goto LABEL_385;
          }
          *(_DWORD *)(a4 + 28) = v26 - 32;
          if (v26 - 32 < 0)
          {
            uint64_t v42 = v41 & ~(v41 >> 63) & 0xFFFFFFFC;
            unint64_t v43 = *(void *)(a4 + 8);
            if (v42) {
              BOOL v44 = v43 > (unint64_t)v40;
            }
            else {
              BOOL v44 = 1;
            }
            if (v44)
            {
              uint64_t v45 = 0;
              unsigned int v193 = v27;
              do
              {
                uint64_t v46 = (unsigned __int8 *)v40 + v45;
                unsigned int v47 = v193 << 8;
                *(_DWORD *)(a4 + 24) = v47;
                int v48 = 255;
                if ((unint64_t)v40 + v45 < v39 && (unint64_t)v46 >= v43) {
                  int v48 = *v46;
                }
                unsigned int v193 = v48 | v47;
                *(_DWORD *)(a4 + 24) = v193;
                ++v45;
              }
              while (v45 != 4);
            }
            else
            {
              unsigned int v193 = bswap32(*v40);
            }
            *(void *)a4 = v40 + 1;
            v27 |= v193 >> v26;
            unsigned int v194 = v193 << -(char)v26;
            if (!v26) {
              unsigned int v194 = 0;
            }
            *(_DWORD *)(a4 + 24) = v194;
            *(_DWORD *)(a4 + 28) = v26;
          }
          *(_DWORD *)(a2 + 132) = v27;
          break;
        case 3u:
          unint64_t v49 = *(void *)(a4 + 16);
          uint64_t v50 = *(unsigned int **)a4;
          uint64_t v51 = v49 - *(void *)a4;
          if (v26 + 8 * (int)v51 <= 31)
          {
            exception = __cxa_allocate_exception(8uLL);
            v259 = "Cannot read rData.mObjectDiffuse";
            goto LABEL_385;
          }
          *(_DWORD *)(a4 + 28) = v26 - 32;
          if (v26 - 32 < 0)
          {
            uint64_t v52 = v51 & ~(v51 >> 63) & 0xFFFFFFFC;
            unint64_t v53 = *(void *)(a4 + 8);
            if (v52) {
              BOOL v54 = v53 > (unint64_t)v50;
            }
            else {
              BOOL v54 = 1;
            }
            if (v54)
            {
              uint64_t v55 = 0;
              unsigned int v195 = v27;
              do
              {
                uint64_t v56 = (unsigned __int8 *)v50 + v55;
                unsigned int v57 = v195 << 8;
                *(_DWORD *)(a4 + 24) = v57;
                int v58 = 255;
                if ((unint64_t)v50 + v55 < v49 && (unint64_t)v56 >= v53) {
                  int v58 = *v56;
                }
                unsigned int v195 = v58 | v57;
                *(_DWORD *)(a4 + 24) = v195;
                ++v55;
              }
              while (v55 != 4);
            }
            else
            {
              unsigned int v195 = bswap32(*v50);
            }
            *(void *)a4 = v50 + 1;
            v27 |= v195 >> v26;
            unsigned int v196 = v195 << -(char)v26;
            if (!v26) {
              unsigned int v196 = 0;
            }
            *(_DWORD *)(a4 + 24) = v196;
            *(_DWORD *)(a4 + 28) = v26;
          }
          *(_DWORD *)(a2 + 136) = v27;
          break;
        case 4u:
          APAC::MetadataBitStreamParser::parseObjectChannelLock(a1, a2 + 140, a4);
          break;
        case 5u:
          APAC::MetadataBitStreamParser::parseObjectDivergence(a1, v260, a4);
          break;
        case 6u:
          unint64_t v59 = *(void *)(a4 + 16);
          uint64_t v60 = *(unsigned int **)a4;
          uint64_t v61 = v59 - *(void *)a4;
          if (v26 + 8 * (int)v61 <= 0)
          {
            exception = __cxa_allocate_exception(8uLL);
            v259 = "Cannot read rData.mIsScreenSizeAdaptationEnabled";
            goto LABEL_385;
          }
          unsigned int v62 = v27 >> 31;
          *(_DWORD *)(a4 + 28) = v26 - 1;
          if (v26 - 1 < 0)
          {
            uint64_t v137 = v61 & ~(v61 >> 63) & 0xFFFFFFFC;
            unint64_t v138 = *(void *)(a4 + 8);
            if (v137) {
              BOOL v139 = v138 > (unint64_t)v60;
            }
            else {
              BOOL v139 = 1;
            }
            if (v139)
            {
              uint64_t v140 = 0;
              do
              {
                unsigned int v141 = (unsigned __int8 *)v60 + v140;
                unsigned int v142 = v27 << 8;
                *(_DWORD *)(a4 + 24) = v142;
                int v143 = 255;
                if ((unint64_t)v60 + v140 < v59 && (unint64_t)v141 >= v138) {
                  int v143 = *v141;
                }
                unsigned int v27 = v143 | v142;
                *(_DWORD *)(a4 + 24) = v27;
                ++v140;
              }
              while (v140 != 4);
            }
            else
            {
              unsigned int v27 = bswap32(*v60);
            }
            int v203 = v27 << (1 - v26);
            int v204 = v26 + 31;
            *(_DWORD *)(a4 + 28) = v204;
            *(void *)a4 = v60 + 1;
            v62 |= v27 >> v204;
            if (v204) {
              int v63 = v203;
            }
            else {
              int v63 = 0;
            }
          }
          else
          {
            int v63 = 2 * v27;
          }
          *(_DWORD *)(a4 + 24) = v63;
          *(unsigned char *)(a2 + 168) = v62 != 0;
          break;
        case 7u:
          APAC::MetadataBitStreamParser::parseZoneExclusion(a1, v261, a4);
          break;
        case 8u:
          unint64_t v64 = *(void *)(a4 + 16);
          long long v65 = *(unsigned int **)a4;
          uint64_t v66 = v64 - *(void *)a4;
          if (v26 + 8 * (int)v66 <= 2)
          {
            exception = __cxa_allocate_exception(8uLL);
            v259 = "Cannot read rData.mBinauralizationPreset";
            goto LABEL_385;
          }
          unsigned int v67 = v27 >> 29;
          *(_DWORD *)(a4 + 28) = v26 - 3;
          if (v26 - 3 < 0)
          {
            uint64_t v144 = v66 & ~(v66 >> 63) & 0xFFFFFFFC;
            unint64_t v145 = *(void *)(a4 + 8);
            if (v144) {
              BOOL v146 = v145 > (unint64_t)v65;
            }
            else {
              BOOL v146 = 1;
            }
            if (v146)
            {
              uint64_t v147 = 0;
              do
              {
                uint64_t v148 = (unsigned __int8 *)v65 + v147;
                unsigned int v149 = v27 << 8;
                *(_DWORD *)(a4 + 24) = v149;
                int v150 = 255;
                if ((unint64_t)v65 + v147 < v64 && (unint64_t)v148 >= v145) {
                  int v150 = *v148;
                }
                unsigned int v27 = v150 | v149;
                *(_DWORD *)(a4 + 24) = v27;
                ++v147;
              }
              while (v147 != 4);
            }
            else
            {
              unsigned int v27 = bswap32(*v65);
            }
            int v205 = v27 << (3 - v26);
            int v206 = v26 + 29;
            *(_DWORD *)(a4 + 28) = v206;
            *(void *)a4 = v65 + 1;
            v67 |= v27 >> v206;
            if (v206) {
              int v68 = v205;
            }
            else {
              int v68 = 0;
            }
          }
          else
          {
            int v68 = 8 * v27;
          }
          *(_DWORD *)(a4 + 24) = v68;
          *(unsigned char *)(a2 + 1037) = v67;
          break;
        case 9u:
          APAC::MetadataBitStreamParser::parseSceneReverb(a1, v263, a4);
          break;
        case 0xAu:
          APAC::MetadataBitStreamParser::parsePostProcReverb(a1, v264, a4);
          break;
        case 0xBu:
          APAC::MetadataBitStreamParser::parseRadiationPattern(a1, v265, a3, a4);
          break;
        case 0xCu:
          unint64_t v69 = *(void *)(a4 + 16);
          long long v70 = *(unsigned int **)a4;
          uint64_t v71 = v69 - *(void *)a4;
          if (v26 + 8 * (int)v71 <= 0)
          {
            exception = __cxa_allocate_exception(8uLL);
            v259 = "Cannot read rData.mHPVirtualize.mBypass";
            goto LABEL_385;
          }
          unsigned int v72 = v27 >> 31;
          int v73 = v26 - 1;
          *(_DWORD *)(a4 + 28) = v26 - 1;
          if (v26 - 1 < 0)
          {
            unint64_t v151 = *(void *)(a4 + 8);
            if ((v71 & ~(v71 >> 63) & 0xFFFFFFFC) == 0 || v151 > (unint64_t)v70)
            {
              uint64_t v153 = 0;
              do
              {
                int v154 = (unsigned __int8 *)v70 + v153;
                unsigned int v155 = v27 << 8;
                *(_DWORD *)(a4 + 24) = v155;
                int v156 = 255;
                if ((unint64_t)v70 + v153 < v69 && (unint64_t)v154 >= v151) {
                  int v156 = *v154;
                }
                unsigned int v27 = v156 | v155;
                *(_DWORD *)(a4 + 24) = v27;
                ++v153;
              }
              while (v153 != 4);
            }
            else
            {
              unsigned int v27 = bswap32(*v70);
            }
            int v208 = v26 + 31;
            BOOL v207 = v26 == -31;
            *(_DWORD *)(a4 + 28) = v26 + 31;
            *(void *)a4 = ++v70;
            v72 |= v27 >> (v26 + 31);
            if (v26 == -31) {
              unsigned int v74 = 0;
            }
            else {
              unsigned int v74 = v27 << (1 - v26);
            }
            if (v207) {
              int v73 = 0;
            }
            else {
              int v73 = v208;
            }
          }
          else
          {
            unsigned int v74 = 2 * v27;
          }
          *(_DWORD *)(a4 + 24) = v74;
          *(unsigned char *)(a2 + 1024) = v72 != 0;
          if (v73 + 8 * ((int)v69 - (int)v70) <= 0)
          {
            exception = __cxa_allocate_exception(8uLL);
            v259 = "Cannot read rData.mHPVirtualize.mHasDRR";
            goto LABEL_385;
          }
          unsigned int v209 = v74 >> 31;
          int v210 = v73 - 1;
          *(_DWORD *)(a4 + 28) = v73 - 1;
          if (v73 - 1 < 0)
          {
            unint64_t v212 = *(void *)(a4 + 8);
            if (((v69 - v70) & ~((uint64_t)(v69 - (void)v70) >> 63) & 0xFFFFFFFC) != 0
              && v212 <= (unint64_t)v70)
            {
              unsigned int v74 = bswap32(*v70);
            }
            else
            {
              uint64_t v225 = 0;
              do
              {
                v226 = (unsigned __int8 *)v70 + v225;
                unsigned int v227 = v74 << 8;
                *(_DWORD *)(a4 + 24) = v227;
                int v228 = 255;
                if ((unint64_t)v70 + v225 < v69 && (unint64_t)v226 >= v212) {
                  int v228 = *v226;
                }
                unsigned int v74 = v228 | v227;
                *(_DWORD *)(a4 + 24) = v74;
                ++v225;
              }
              while (v225 != 4);
            }
            int v229 = v74 << (1 - v73);
            int v230 = v73 + 31;
            *(_DWORD *)(a4 + 28) = v230;
            *(void *)a4 = ++v70;
            v209 |= v74 >> v230;
            if (v230) {
              int v211 = v229;
            }
            else {
              int v211 = 0;
            }
            if (v230) {
              int v210 = v230;
            }
            else {
              int v210 = 0;
            }
          }
          else
          {
            int v211 = 2 * v74;
          }
          *(_DWORD *)(a4 + 24) = v211;
          *(unsigned char *)(a2 + 1025) = v209 != 0;
          if (!v209) {
            break;
          }
          if (v210 + 8 * ((int)v69 - (int)v70) <= 31)
          {
            exception = __cxa_allocate_exception(8uLL);
            v259 = "Cannot read rData.mHPVirtualize.mDRR";
LABEL_385:
            void *exception = v259;
            __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
          }
          *(_DWORD *)(a4 + 28) = v210 - 32;
          if (v210 - 32 < 0)
          {
            unint64_t v231 = *(void *)(a4 + 8);
            if (((v69 - v70) & ~((uint64_t)(v69 - (void)v70) >> 63) & 0xFFFFFFFC) != 0
              && v231 <= (unint64_t)v70)
            {
              unsigned int v232 = bswap32(*v70);
            }
            else
            {
              uint64_t v248 = 0;
              unsigned int v232 = v211;
              do
              {
                v249 = (unsigned __int8 *)v70 + v248;
                unsigned int v250 = v232 << 8;
                *(_DWORD *)(a4 + 24) = v250;
                int v251 = 255;
                if ((unint64_t)v70 + v248 < v69 && (unint64_t)v249 >= v231) {
                  int v251 = *v249;
                }
                unsigned int v232 = v251 | v250;
                *(_DWORD *)(a4 + 24) = v232;
                ++v248;
              }
              while (v248 != 4);
            }
            *(void *)a4 = v70 + 1;
            v211 |= v232 >> v210;
            unsigned int v252 = v232 << -(char)v210;
            if (!v210) {
              unsigned int v252 = 0;
            }
            *(_DWORD *)(a4 + 24) = v252;
            *(_DWORD *)(a4 + 28) = v210;
          }
          *(_DWORD *)(a2 + 1028) = v211;
          break;
        case 0xDu:
          unint64_t v75 = *(void *)(a4 + 16);
          uint64_t v76 = *(unsigned int **)a4;
          uint64_t v77 = v75 - *(void *)a4;
          if (v26 + 8 * (int)v77 <= 0)
          {
            exception = __cxa_allocate_exception(8uLL);
            v259 = "Cannot read rData.mHeadLock.mHeadLocked";
            goto LABEL_385;
          }
          unsigned int v78 = v27 >> 31;
          int v79 = v26 - 1;
          *(_DWORD *)(a4 + 28) = v26 - 1;
          if (v26 - 1 < 0)
          {
            unint64_t v157 = *(void *)(a4 + 8);
            if ((v77 & ~(v77 >> 63) & 0xFFFFFFFC) == 0 || v157 > (unint64_t)v76)
            {
              uint64_t v159 = 0;
              do
              {
                int v160 = (unsigned __int8 *)v76 + v159;
                unsigned int v161 = v27 << 8;
                *(_DWORD *)(a4 + 24) = v161;
                int v162 = 255;
                if ((unint64_t)v76 + v159 < v75 && (unint64_t)v160 >= v157) {
                  int v162 = *v160;
                }
                unsigned int v27 = v162 | v161;
                *(_DWORD *)(a4 + 24) = v27;
                ++v159;
              }
              while (v159 != 4);
            }
            else
            {
              unsigned int v27 = bswap32(*v76);
            }
            unsigned int v213 = v27 << (1 - v26);
            int v214 = v26 + 31;
            *(_DWORD *)(a4 + 28) = v214;
            *(void *)a4 = ++v76;
            v78 |= v27 >> v214;
            if (v214) {
              unsigned int v80 = v213;
            }
            else {
              unsigned int v80 = 0;
            }
            if (v214) {
              int v79 = v214;
            }
            else {
              int v79 = 0;
            }
          }
          else
          {
            unsigned int v80 = 2 * v27;
          }
          *(_DWORD *)(a4 + 24) = v80;
          *(unsigned char *)(a2 + 1032) = v78 != 0;
          if (v79 + 8 * ((int)v75 - (int)v76) <= 0)
          {
            exception = __cxa_allocate_exception(8uLL);
            v259 = "Cannot read rData.mHeadLock.mIsExternalized";
            goto LABEL_385;
          }
          unsigned int v215 = v80 >> 31;
          int v216 = v79 - 1;
          *(_DWORD *)(a4 + 28) = v79 - 1;
          if (v79 - 1 < 0)
          {
            unint64_t v218 = *(void *)(a4 + 8);
            if (((v75 - v76) & ~((uint64_t)(v75 - (void)v76) >> 63) & 0xFFFFFFFC) != 0
              && v218 <= (unint64_t)v76)
            {
              unsigned int v80 = bswap32(*v76);
            }
            else
            {
              uint64_t v233 = 0;
              do
              {
                v234 = (unsigned __int8 *)v76 + v233;
                unsigned int v235 = v80 << 8;
                *(_DWORD *)(a4 + 24) = v235;
                int v236 = 255;
                if ((unint64_t)v76 + v233 < v75 && (unint64_t)v234 >= v218) {
                  int v236 = *v234;
                }
                unsigned int v80 = v236 | v235;
                *(_DWORD *)(a4 + 24) = v80;
                ++v233;
              }
              while (v233 != 4);
            }
            int v238 = v79 + 31;
            BOOL v237 = v79 == -31;
            *(_DWORD *)(a4 + 28) = v79 + 31;
            *(void *)a4 = ++v76;
            v215 |= v80 >> (v79 + 31);
            if (v79 == -31) {
              unsigned int v217 = 0;
            }
            else {
              unsigned int v217 = v80 << (1 - v79);
            }
            if (v237) {
              int v216 = 0;
            }
            else {
              int v216 = v238;
            }
          }
          else
          {
            unsigned int v217 = 2 * v80;
          }
          *(_DWORD *)(a4 + 24) = v217;
          *(unsigned char *)(a2 + 1033) = v215 != 0;
          if (v216 + 8 * ((int)v75 - (int)v76) <= 2)
          {
            exception = __cxa_allocate_exception(8uLL);
            v259 = "Cannot read rData.mHeadLock.mReference";
            goto LABEL_385;
          }
          unsigned int v239 = v217 >> 29;
          *(_DWORD *)(a4 + 28) = v216 - 3;
          if (v216 - 3 < 0)
          {
            unint64_t v241 = *(void *)(a4 + 8);
            if (((v75 - v76) & ~((uint64_t)(v75 - (void)v76) >> 63) & 0xFFFFFFFC) != 0
              && v241 <= (unint64_t)v76)
            {
              unsigned int v217 = bswap32(*v76);
            }
            else
            {
              uint64_t v242 = 0;
              do
              {
                v243 = (unsigned __int8 *)v76 + v242;
                unsigned int v244 = v217 << 8;
                *(_DWORD *)(a4 + 24) = v244;
                int v245 = 255;
                if ((unint64_t)v76 + v242 < v75 && (unint64_t)v243 >= v241) {
                  int v245 = *v243;
                }
                unsigned int v217 = v245 | v244;
                *(_DWORD *)(a4 + 24) = v217;
                ++v242;
              }
              while (v242 != 4);
            }
            int v246 = v217 << (3 - v216);
            int v247 = v216 + 29;
            *(_DWORD *)(a4 + 28) = v247;
            *(void *)a4 = v76 + 1;
            v239 |= v217 >> v247;
            if (v247) {
              int v240 = v246;
            }
            else {
              int v240 = 0;
            }
          }
          else
          {
            int v240 = 8 * v217;
          }
          *(_DWORD *)(a4 + 24) = v240;
          *(unsigned char *)(a2 + 1034) = v239;
          break;
        case 0xEu:
          unint64_t v81 = *(void *)(a4 + 16);
          int v82 = *(unsigned int **)a4;
          uint64_t v83 = v81 - *(void *)a4;
          if (v26 + 8 * (int)v83 <= 0)
          {
            exception = __cxa_allocate_exception(8uLL);
            v259 = "Cannot read rData.mParallax";
            goto LABEL_385;
          }
          unsigned int v84 = v27 >> 31;
          *(_DWORD *)(a4 + 28) = v26 - 1;
          if (v26 - 1 < 0)
          {
            uint64_t v163 = v83 & ~(v83 >> 63) & 0xFFFFFFFC;
            unint64_t v164 = *(void *)(a4 + 8);
            if (v163) {
              BOOL v165 = v164 > (unint64_t)v82;
            }
            else {
              BOOL v165 = 1;
            }
            if (v165)
            {
              uint64_t v166 = 0;
              do
              {
                uint64_t v167 = (unsigned __int8 *)v82 + v166;
                unsigned int v168 = v27 << 8;
                *(_DWORD *)(a4 + 24) = v168;
                int v169 = 255;
                if ((unint64_t)v82 + v166 < v81 && (unint64_t)v167 >= v164) {
                  int v169 = *v167;
                }
                unsigned int v27 = v169 | v168;
                *(_DWORD *)(a4 + 24) = v27;
                ++v166;
              }
              while (v166 != 4);
            }
            else
            {
              unsigned int v27 = bswap32(*v82);
            }
            int v219 = v27 << (1 - v26);
            int v220 = v26 + 31;
            *(_DWORD *)(a4 + 28) = v220;
            *(void *)a4 = v82 + 1;
            v84 |= v27 >> v220;
            if (v220) {
              int v85 = v219;
            }
            else {
              int v85 = 0;
            }
          }
          else
          {
            int v85 = 2 * v27;
          }
          *(_DWORD *)(a4 + 24) = v85;
          *(unsigned char *)(a2 + 1035) = v84 != 0;
          break;
        case 0xFu:
          unint64_t v86 = *(void *)(a4 + 16);
          unsigned int v87 = *(unsigned int **)a4;
          uint64_t v88 = v86 - *(void *)a4;
          if (v26 + 8 * (int)v88 <= 2)
          {
            exception = __cxa_allocate_exception(8uLL);
            v259 = "Cannot read rData.mPreferredDoF.mDoFIndex";
            goto LABEL_385;
          }
          unsigned int v89 = v27 >> 29;
          *(_DWORD *)(a4 + 28) = v26 - 3;
          if (v26 - 3 < 0)
          {
            uint64_t v170 = v88 & ~(v88 >> 63) & 0xFFFFFFFC;
            unint64_t v171 = *(void *)(a4 + 8);
            if (v170) {
              BOOL v172 = v171 > (unint64_t)v87;
            }
            else {
              BOOL v172 = 1;
            }
            if (v172)
            {
              uint64_t v173 = 0;
              do
              {
                unsigned int v174 = (unsigned __int8 *)v87 + v173;
                unsigned int v175 = v27 << 8;
                *(_DWORD *)(a4 + 24) = v175;
                int v176 = 255;
                if ((unint64_t)v87 + v173 < v86 && (unint64_t)v174 >= v171) {
                  int v176 = *v174;
                }
                unsigned int v27 = v176 | v175;
                *(_DWORD *)(a4 + 24) = v27;
                ++v173;
              }
              while (v173 != 4);
            }
            else
            {
              unsigned int v27 = bswap32(*v87);
            }
            int v221 = v27 << (3 - v26);
            int v222 = v26 + 29;
            *(_DWORD *)(a4 + 28) = v222;
            *(void *)a4 = v87 + 1;
            v89 |= v27 >> v222;
            if (v222) {
              int v90 = v221;
            }
            else {
              int v90 = 0;
            }
          }
          else
          {
            int v90 = 8 * v27;
          }
          *(_DWORD *)(a4 + 24) = v90;
          *(unsigned char *)(a2 + 1036) = v89;
          break;
        case 0x10u:
          unint64_t v91 = *(void *)(a4 + 16);
          unint64_t v92 = *(unsigned int **)a4;
          uint64_t v93 = v91 - *(void *)a4;
          if (v26 + 8 * (int)v93 <= 31)
          {
            exception = __cxa_allocate_exception(8uLL);
            v259 = "Cannot read rData.mFieldOfView.mAzimuth";
            goto LABEL_385;
          }
          *(_DWORD *)(a4 + 28) = v26 - 32;
          if (v26 - 32 < 0)
          {
            uint64_t v94 = v93 & ~(v93 >> 63) & 0xFFFFFFFC;
            unint64_t v95 = *(void *)(a4 + 8);
            if (v94) {
              BOOL v96 = v95 > (unint64_t)v92;
            }
            else {
              BOOL v96 = 1;
            }
            if (v96)
            {
              uint64_t v97 = 0;
              unsigned int v197 = v27;
              do
              {
                uint64_t v98 = (unsigned __int8 *)v92 + v97;
                unsigned int v99 = v197 << 8;
                *(_DWORD *)(a4 + 24) = v99;
                int v100 = 255;
                if ((unint64_t)v92 + v97 < v91 && (unint64_t)v98 >= v95) {
                  int v100 = *v98;
                }
                unsigned int v197 = v100 | v99;
                *(_DWORD *)(a4 + 24) = v197;
                ++v97;
              }
              while (v97 != 4);
            }
            else
            {
              unsigned int v197 = bswap32(*v92);
            }
            *(void *)a4 = v92 + 1;
            v27 |= v197 >> v26;
            unsigned int v198 = v197 << -(char)v26;
            if (!v26) {
              unsigned int v198 = 0;
            }
            *(_DWORD *)(a4 + 24) = v198;
            *(_DWORD *)(a4 + 28) = v26;
          }
          *(_DWORD *)(a2 + 1040) = v27;
          break;
        case 0x11u:
          APAC::MetadataBitStreamParser::parseMaskingZone(a1, v262, a4);
          break;
        case 0x12u:
          uint64_t v38 = v266;
          goto LABEL_118;
        case 0x13u:
          unint64_t v101 = *(void *)(a4 + 16);
          unint64_t v102 = *(unsigned int **)a4;
          uint64_t v103 = v101 - *(void *)a4;
          if (v26 + 8 * (int)v103 <= 31)
          {
            exception = __cxa_allocate_exception(8uLL);
            v259 = "Cannot read rData.mHOA_Radius";
            goto LABEL_385;
          }
          *(_DWORD *)(a4 + 28) = v26 - 32;
          if (v26 - 32 < 0)
          {
            uint64_t v104 = v103 & ~(v103 >> 63) & 0xFFFFFFFC;
            unint64_t v105 = *(void *)(a4 + 8);
            if (v104) {
              BOOL v106 = v105 > (unint64_t)v102;
            }
            else {
              BOOL v106 = 1;
            }
            if (v106)
            {
              uint64_t v107 = 0;
              unsigned int v199 = v27;
              do
              {
                int v108 = (unsigned __int8 *)v102 + v107;
                unsigned int v109 = v199 << 8;
                *(_DWORD *)(a4 + 24) = v109;
                int v110 = 255;
                if ((unint64_t)v102 + v107 < v101 && (unint64_t)v108 >= v105) {
                  int v110 = *v108;
                }
                unsigned int v199 = v110 | v109;
                *(_DWORD *)(a4 + 24) = v199;
                ++v107;
              }
              while (v107 != 4);
            }
            else
            {
              unsigned int v199 = bswap32(*v102);
            }
            *(void *)a4 = v102 + 1;
            v27 |= v199 >> v26;
            unsigned int v200 = v199 << -(char)v26;
            if (!v26) {
              unsigned int v200 = 0;
            }
            *(_DWORD *)(a4 + 24) = v200;
            *(_DWORD *)(a4 + 28) = v26;
          }
          *(_DWORD *)(a2 + 1144) = v27;
          break;
        case 0x14u:
          uint64_t v38 = v267;
LABEL_118:
          a1 = APAC::MetadataBitStreamParser::parsePosition(a1, v38, a4);
          break;
        case 0x15u:
          unint64_t v111 = *(void *)(a4 + 16);
          unsigned int v112 = *(unsigned int **)a4;
          uint64_t v113 = v111 - *(void *)a4;
          if (v26 + 8 * (int)v113 <= 0)
          {
            exception = __cxa_allocate_exception(8uLL);
            v259 = "Cannot read rData.mHOA_InteriorOrExterior";
            goto LABEL_385;
          }
          unsigned int v114 = v27 >> 31;
          *(_DWORD *)(a4 + 28) = v26 - 1;
          if (v26 - 1 < 0)
          {
            uint64_t v177 = v113 & ~(v113 >> 63) & 0xFFFFFFFC;
            unint64_t v178 = *(void *)(a4 + 8);
            if (v177) {
              BOOL v179 = v178 > (unint64_t)v112;
            }
            else {
              BOOL v179 = 1;
            }
            if (v179)
            {
              uint64_t v180 = 0;
              do
              {
                int v181 = (unsigned __int8 *)v112 + v180;
                unsigned int v182 = v27 << 8;
                *(_DWORD *)(a4 + 24) = v182;
                int v183 = 255;
                if ((unint64_t)v112 + v180 < v111 && (unint64_t)v181 >= v178) {
                  int v183 = *v181;
                }
                unsigned int v27 = v183 | v182;
                *(_DWORD *)(a4 + 24) = v27;
                ++v180;
              }
              while (v180 != 4);
            }
            else
            {
              unsigned int v27 = bswap32(*v112);
            }
            int v223 = v27 << (1 - v26);
            int v224 = v26 + 31;
            *(_DWORD *)(a4 + 28) = v224;
            *(void *)a4 = v112 + 1;
            v114 |= v27 >> v224;
            if (v224) {
              int v115 = v223;
            }
            else {
              int v115 = 0;
            }
          }
          else
          {
            int v115 = 2 * v27;
          }
          *(_DWORD *)(a4 + 24) = v115;
          *(unsigned char *)(a2 + 1196) = v114 != 0;
          break;
        case 0x16u:
          APAC::MetadataBitStreamParser::parseHOARenderingMatrix(a1, v268, a3, a4);
          break;
        case 0x17u:
          unint64_t v116 = *(void *)(a4 + 16);
          unsigned int v117 = *(unsigned int **)a4;
          uint64_t v118 = v116 - *(void *)a4;
          if (v26 + 8 * (int)v118 <= 31)
          {
            exception = __cxa_allocate_exception(8uLL);
            v259 = "Cannot read rData.mNFCRefDist";
            goto LABEL_385;
          }
          *(_DWORD *)(a4 + 28) = v26 - 32;
          if (v26 - 32 < 0)
          {
            uint64_t v119 = v118 & ~(v118 >> 63) & 0xFFFFFFFC;
            unint64_t v120 = *(void *)(a4 + 8);
            if (v119) {
              BOOL v121 = v120 > (unint64_t)v117;
            }
            else {
              BOOL v121 = 1;
            }
            if (v121)
            {
              uint64_t v122 = 0;
              unsigned int v201 = v27;
              do
              {
                int v123 = (unsigned __int8 *)v117 + v122;
                unsigned int v124 = v201 << 8;
                *(_DWORD *)(a4 + 24) = v124;
                int v125 = 255;
                if ((unint64_t)v117 + v122 < v116 && (unint64_t)v123 >= v120) {
                  int v125 = *v123;
                }
                unsigned int v201 = v125 | v124;
                *(_DWORD *)(a4 + 24) = v201;
                ++v122;
              }
              while (v122 != 4);
            }
            else
            {
              unsigned int v201 = bswap32(*v117);
            }
            *(void *)a4 = v117 + 1;
            v27 |= v201 >> v26;
            unsigned int v202 = v201 << -(char)v26;
            if (!v26) {
              unsigned int v202 = 0;
            }
            *(_DWORD *)(a4 + 24) = v202;
            *(_DWORD *)(a4 + 28) = v26;
          }
          *(_DWORD *)(a2 + 1240) = v27;
          break;
        case 0x18u:
          APAC::MetadataBitStreamParser::parsePropagationDelay(a1, v269, a4);
          break;
        default:
          unsigned int v126 = v27 >> 15;
          int v127 = v26 - 17;
          *(_DWORD *)(a4 + 28) = v26 - 17;
          if (v26 - 17 < 0)
          {
            unint64_t v130 = *(void *)(a4 + 8);
            unint64_t v129 = *(void *)(a4 + 16);
            int v131 = *(unsigned int **)a4;
            if (((v129 - *(_DWORD *)a4) & ~((uint64_t)(v129 - *(void *)a4) >> 63) & 0xFFFFFFFC) == 0
              || v130 > (unint64_t)v131)
            {
              uint64_t v133 = 0;
              do
              {
                int v134 = (unsigned __int8 *)v131 + v133;
                unsigned int v135 = v27 << 8;
                *(_DWORD *)(a4 + 24) = v135;
                int v136 = 255;
                if ((unint64_t)v131 + v133 < v129 && (unint64_t)v134 >= v130) {
                  int v136 = *v134;
                }
                unsigned int v27 = v136 | v135;
                *(_DWORD *)(a4 + 24) = v27;
                ++v133;
              }
              while (v133 != 4);
            }
            else
            {
              unsigned int v27 = bswap32(*v131);
            }
            int v185 = v26 + 15;
            BOOL v184 = v26 == -15;
            *(_DWORD *)(a4 + 28) = v26 + 15;
            *(void *)a4 = v131 + 1;
            v126 |= v27 >> (v26 + 15);
            if (v26 == -15) {
              int v128 = 0;
            }
            else {
              int v128 = v27 << (17 - v26);
            }
            if (v184) {
              int v127 = 0;
            }
            else {
              int v127 = v185;
            }
          }
          else
          {
            int v128 = v27 << 17;
          }
          *(_DWORD *)(a4 + 24) = v128;
          int v186 = 8 * v126 + 8;
          unsigned int v187 = v186 - v127;
          if (v186 > v127)
          {
            *(void *)(a4 + 24) = 0;
            int v128 = 0;
            int v127 = 0;
            if (v187 >= 0x20)
            {
              *(void *)a4 += (v187 >> 3) & 0x1FFFFFFC;
              int v186 = v187 & 0x1F;
            }
            else
            {
              int v186 = v187;
            }
          }
          if ((v186 - 33) >= 0xFFFFFFE0)
          {
            int v188 = v127 - v186;
            *(_DWORD *)(a4 + 28) = v127 - v186;
            if (v127 - v186 < 0)
            {
              unint64_t v191 = *(void *)(a4 + 8);
              unint64_t v190 = *(void *)(a4 + 16);
              v192 = *(unsigned int **)a4;
              if (((v190 - *(_DWORD *)a4) & ~((uint64_t)(v190 - *(void *)a4) >> 63) & 0xFFFFFFFC) != 0
                && v191 <= (unint64_t)v192)
              {
                int v128 = bswap32(*v192);
              }
              else
              {
                uint64_t v253 = 0;
                do
                {
                  v254 = (unsigned __int8 *)v192 + v253;
                  int v255 = v128 << 8;
                  *(_DWORD *)(a4 + 24) = v255;
                  int v256 = 255;
                  if ((unint64_t)v192 + v253 < v190 && (unint64_t)v254 >= v191) {
                    int v256 = *v254;
                  }
                  int v128 = v256 | v255;
                  *(_DWORD *)(a4 + 24) = v128;
                  ++v253;
                }
                while (v253 != 4);
              }
              int v189 = v128 << -(char)v188;
              int v257 = v188 + 32;
              *(_DWORD *)(a4 + 28) = v257;
              *(void *)a4 = v192 + 1;
              if (!v257) {
                int v189 = 0;
              }
            }
            else
            {
              int v189 = v128 << v186;
            }
            *(_DWORD *)(a4 + 24) = v189;
          }
          break;
      }
      ++v21;
    }
    while (v21 != v22);
  }
}

unint64_t APAC::MetadataBitStreamParser::parsePosition(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 16);
  unint64_t v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v76 = "Cannot read pos.mPositionPresent";
    goto LABEL_98;
  }
  unsigned int v9 = *(_DWORD *)(a3 + 24);
  unsigned int v10 = v9 >> 31;
  *(_DWORD *)(a3 + 28) = v6 - 1;
  if (v6 - 1 < 0)
  {
    uint64_t v12 = v5 & ~(v5 >> 63) & 0xFFFFFFFC;
    unint64_t v13 = *(void *)(a3 + 8);
    if (v12) {
      BOOL v14 = v13 > (unint64_t)v4;
    }
    else {
      BOOL v14 = 1;
    }
    if (v14)
    {
      uint64_t v15 = 0;
      do
      {
        int v16 = (unsigned __int8 *)v4 + v15;
        unsigned int v17 = v9 << 8;
        *(_DWORD *)(a3 + 24) = v17;
        int v18 = 255;
        if ((unint64_t)v4 + v15 < v3 && (unint64_t)v16 >= v13) {
          int v18 = *v16;
        }
        unsigned int v9 = v18 | v17;
        *(_DWORD *)(a3 + 24) = v9;
        ++v15;
      }
      while (v15 != 4);
    }
    else
    {
      unsigned int v9 = bswap32(*v4);
    }
    int v19 = v9 << (1 - v6);
    int v20 = v6 + 31;
    *(_DWORD *)(a3 + 28) = v20;
    *(void *)a3 = v4 + 1;
    v10 |= v9 >> v20;
    if (v20) {
      int v11 = v19;
    }
    else {
      int v11 = 0;
    }
  }
  else
  {
    int v11 = 2 * v9;
  }
  *(_DWORD *)(a3 + 24) = v11;
  *(unsigned char *)a2 = v10 != 0;
  if (v10)
  {
    BOOL Bit = AT::TBitstreamReader<unsigned int>::GetBit(a3);
    *(unsigned char *)(a2 + 1) = Bit;
    unint64_t v22 = *(void *)(a3 + 16);
    if (Bit)
    {
      uint64_t v23 = 0;
      unsigned int v25 = *(_DWORD *)(a3 + 24);
      int v24 = *(_DWORD *)(a3 + 28);
      int v26 = *(unsigned int **)a3;
      unint64_t v27 = *(void *)(a3 + 8);
      while (v24 + 8 * ((int)v22 - (int)v26) > 31)
      {
        *(_DWORD *)(a3 + 28) = v24 - 32;
        if (v24 - 32 < 0)
        {
          if (((v22 - v26) & ~((uint64_t)(v22 - (void)v26) >> 63) & 0xFFFFFFFC) != 0
            && v27 <= (unint64_t)v26)
          {
            unsigned int v29 = bswap32(*v26);
          }
          else
          {
            uint64_t v30 = 0;
            unsigned int v29 = v25;
            do
            {
              unint64_t v31 = (unsigned __int8 *)v26 + v30;
              unsigned int v32 = v29 << 8;
              *(_DWORD *)(a3 + 24) = v32;
              int v33 = 255;
              if ((unint64_t)v26 + v30 < v22 && (unint64_t)v31 >= v27) {
                int v33 = *v31;
              }
              unsigned int v29 = v33 | v32;
              *(_DWORD *)(a3 + 24) = v29;
              ++v30;
            }
            while (v30 != 4);
          }
          *(void *)a3 = ++v26;
          int v28 = (v29 >> v24) | v25;
          unsigned int v25 = v29 << -(char)v24;
          if (!v24) {
            unsigned int v25 = 0;
          }
          *(_DWORD *)(a3 + 24) = v25;
          *(_DWORD *)(a3 + 28) = v24;
        }
        else
        {
          v24 -= 32;
          int v28 = v25;
        }
        *(_DWORD *)(a2 + 20 + 4 * v23++) = v28;
        if (v23 == 3) {
          goto LABEL_78;
        }
      }
      exception = __cxa_allocate_exception(8uLL);
      uint64_t v76 = "Cannot read pos.mCoordinate[n]";
LABEL_98:
      void *exception = v76;
      __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
    }
    unsigned int v34 = *(unsigned int **)a3;
    uint64_t v35 = v22 - *(void *)a3;
    int v36 = *(_DWORD *)(a3 + 28);
    if (v36 + 8 * (int)v35 <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      uint64_t v76 = "Cannot read pos.mAzimuth";
      goto LABEL_98;
    }
    unsigned int v37 = *(_DWORD *)(a3 + 24);
    *(_DWORD *)(a3 + 28) = v36 - 32;
    if (v36 - 32 < 0)
    {
      int v40 = v35 & ~(v35 >> 63);
      unint64_t v41 = *(void *)(a3 + 8);
      if ((v40 & 0xFFFFFFFC) != 0 && v41 <= (unint64_t)v34)
      {
        unsigned int v42 = bswap32(*v34);
      }
      else
      {
        uint64_t v43 = 0;
        unsigned int v42 = v37;
        do
        {
          BOOL v44 = (unsigned __int8 *)v34 + v43;
          unsigned int v45 = v42 << 8;
          *(_DWORD *)(a3 + 24) = v45;
          int v46 = 255;
          if ((unint64_t)v34 + v43 < v22 && (unint64_t)v44 >= v41) {
            int v46 = *v44;
          }
          unsigned int v42 = v46 | v45;
          *(_DWORD *)(a3 + 24) = v42;
          ++v43;
        }
        while (v43 != 4);
      }
      *(void *)a3 = ++v34;
      int v39 = (v42 >> v36) | v37;
      unsigned int v37 = v42 << -(char)v36;
      if (!v36) {
        unsigned int v37 = 0;
      }
      *(_DWORD *)(a3 + 24) = v37;
      *(_DWORD *)(a3 + 28) = v36;
      uint64_t v35 = v22 - (void)v34;
      int v38 = 8 * (v22 - v34);
    }
    else
    {
      int v38 = 8 * v35;
      v36 -= 32;
      int v39 = v37;
    }
    *(_DWORD *)(a2 + 4) = v39;
    if (v38 + v36 <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      uint64_t v76 = "Cannot read pos.mElevation";
      goto LABEL_98;
    }
    *(_DWORD *)(a3 + 28) = v36 - 32;
    if (v36 - 32 < 0)
    {
      int v48 = v35 & ~(v35 >> 63);
      unint64_t v49 = *(void *)(a3 + 8);
      if ((v48 & 0xFFFFFFFC) != 0 && v49 <= (unint64_t)v34)
      {
        unsigned int v50 = bswap32(*v34);
      }
      else
      {
        uint64_t v51 = 0;
        unsigned int v50 = v37;
        do
        {
          uint64_t v52 = (unsigned __int8 *)v34 + v51;
          unsigned int v53 = v50 << 8;
          *(_DWORD *)(a3 + 24) = v53;
          int v54 = 255;
          if ((unint64_t)v34 + v51 < v22 && (unint64_t)v52 >= v49) {
            int v54 = *v52;
          }
          unsigned int v50 = v54 | v53;
          *(_DWORD *)(a3 + 24) = v50;
          ++v51;
        }
        while (v51 != 4);
      }
      *(void *)a3 = ++v34;
      int v47 = (v50 >> v36) | v37;
      unsigned int v37 = v50 << -(char)v36;
      if (!v36) {
        unsigned int v37 = 0;
      }
      *(_DWORD *)(a3 + 24) = v37;
      *(_DWORD *)(a3 + 28) = v36;
      uint64_t v35 = v22 - (void)v34;
      int v38 = 8 * (v22 - v34);
    }
    else
    {
      v36 -= 32;
      int v47 = v37;
    }
    *(_DWORD *)(a2 + 8) = v47;
    if (v38 + v36 <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      uint64_t v76 = "Cannot read pos.mRadius";
      goto LABEL_98;
    }
    *(_DWORD *)(a3 + 28) = v36 - 32;
    if (v36 - 32 < 0)
    {
      int v55 = v35 & ~(v35 >> 63);
      unint64_t v56 = *(void *)(a3 + 8);
      if ((v55 & 0xFFFFFFFC) != 0 && v56 <= (unint64_t)v34)
      {
        unsigned int v57 = bswap32(*v34);
      }
      else
      {
        uint64_t v58 = 0;
        unsigned int v57 = v37;
        do
        {
          unint64_t v59 = (unsigned __int8 *)v34 + v58;
          unsigned int v60 = v57 << 8;
          *(_DWORD *)(a3 + 24) = v60;
          int v61 = 255;
          if ((unint64_t)v34 + v58 < v22 && (unint64_t)v59 >= v56) {
            int v61 = *v59;
          }
          unsigned int v57 = v61 | v60;
          *(_DWORD *)(a3 + 24) = v57;
          ++v58;
        }
        while (v58 != 4);
      }
      *(void *)a3 = v34 + 1;
      v37 |= v57 >> v36;
      unsigned int v62 = v57 << -(char)v36;
      if (!v36) {
        unsigned int v62 = 0;
      }
      *(_DWORD *)(a3 + 24) = v62;
      *(_DWORD *)(a3 + 28) = v36;
    }
    *(_DWORD *)(a2 + 12) = v37;
  }
LABEL_78:
  unint64_t result = AT::TBitstreamReader<unsigned int>::GetBit(a3);
  *(unsigned char *)(a2 + 16) = result;
  if (result)
  {
    uint64_t v64 = 0;
    unint64_t v66 = *(void *)(a3 + 8);
    unint64_t v65 = *(void *)(a3 + 16);
    unsigned int v68 = *(_DWORD *)(a3 + 24);
    int v67 = *(_DWORD *)(a3 + 28);
    unint64_t v69 = *(unsigned int **)a3;
    while (v67 + 8 * ((int)v65 - (int)v69) > 31)
    {
      *(_DWORD *)(a3 + 28) = v67 - 32;
      if (v67 - 32 < 0)
      {
        if (((v65 - v69) & ~((uint64_t)(v65 - (void)v69) >> 63) & 0xFFFFFFFC) != 0
          && v66 <= (unint64_t)v69)
        {
          unsigned int v71 = bswap32(*v69);
        }
        else
        {
          uint64_t v72 = 0;
          unsigned int v71 = v68;
          do
          {
            unint64_t result = (unint64_t)v69 + v72;
            unsigned int v73 = v71 << 8;
            *(_DWORD *)(a3 + 24) = v73;
            int v74 = 255;
            if ((unint64_t)v69 + v72 < v65 && result >= v66) {
              int v74 = *(unsigned __int8 *)result;
            }
            unsigned int v71 = v74 | v73;
            *(_DWORD *)(a3 + 24) = v71;
            ++v72;
          }
          while (v72 != 4);
        }
        *(void *)a3 = ++v69;
        int v70 = (v71 >> v67) | v68;
        unsigned int v68 = v71 << -(char)v67;
        if (!v67) {
          unsigned int v68 = 0;
        }
        *(_DWORD *)(a3 + 24) = v68;
        *(_DWORD *)(a3 + 28) = v67;
      }
      else
      {
        v67 -= 32;
        int v70 = v68;
      }
      *(_DWORD *)(a2 + 32 + 4 * v64++) = v70;
      if (v64 == 4) {
        return result;
      }
    }
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v76 = "Cannot read pos.mQuaternion[n]";
    goto LABEL_98;
  }
  return result;
}

void APAC::MetadataBitStreamParser::parseObjectSpread(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 16);
  unint64_t v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    unsigned int v53 = "Cannot read spread.mIsCartesian";
    goto LABEL_86;
  }
  unsigned int v7 = *(_DWORD *)(a3 + 24);
  unsigned int v8 = v7 >> 31;
  int v9 = v6 - 1;
  *(_DWORD *)(a3 + 28) = v6 - 1;
  if (v6 - 1 < 0)
  {
    unint64_t v11 = *(void *)(a3 + 8);
    if ((v5 & ~(v5 >> 63) & 0xFFFFFFFC) == 0 || v11 > (unint64_t)v4)
    {
      uint64_t v13 = 0;
      do
      {
        BOOL v14 = (unsigned __int8 *)v4 + v13;
        unsigned int v15 = v7 << 8;
        *(_DWORD *)(a3 + 24) = v15;
        int v16 = 255;
        if ((unint64_t)v4 + v13 < v3 && (unint64_t)v14 >= v11) {
          int v16 = *v14;
        }
        unsigned int v7 = v16 | v15;
        *(_DWORD *)(a3 + 24) = v7;
        ++v13;
      }
      while (v13 != 4);
    }
    else
    {
      unsigned int v7 = bswap32(*v4);
    }
    int v18 = v6 + 31;
    BOOL v17 = v6 == -31;
    *(_DWORD *)(a3 + 28) = v6 + 31;
    *(void *)a3 = ++v4;
    v8 |= v7 >> (v6 + 31);
    if (v6 == -31) {
      unsigned int v10 = 0;
    }
    else {
      unsigned int v10 = v7 << (1 - v6);
    }
    if (v17) {
      int v9 = 0;
    }
    else {
      int v9 = v18;
    }
  }
  else
  {
    unsigned int v10 = 2 * v7;
  }
  *(_DWORD *)(a3 + 24) = v10;
  *(unsigned char *)a2 = v8 != 0;
  uint64_t v19 = v3 - (void)v4;
  if (v9 + 8 * ((int)v3 - (int)v4) <= 31)
  {
    exception = __cxa_allocate_exception(8uLL);
    unsigned int v53 = "Cannot read spread.mWidth";
    goto LABEL_86;
  }
  *(_DWORD *)(a3 + 28) = v9 - 32;
  if (v9 - 32 < 0)
  {
    unint64_t v22 = *(void *)(a3 + 8);
    if ((v19 & ~(v19 >> 63) & 0xFFFFFFFC) != 0 && v22 <= (unint64_t)v4)
    {
      unsigned int v23 = bswap32(*v4);
    }
    else
    {
      uint64_t v24 = 0;
      unsigned int v23 = v10;
      do
      {
        unsigned int v25 = (unsigned __int8 *)v4 + v24;
        unsigned int v26 = v23 << 8;
        *(_DWORD *)(a3 + 24) = v26;
        int v27 = 255;
        if ((unint64_t)v4 + v24 < v3 && (unint64_t)v25 >= v22) {
          int v27 = *v25;
        }
        unsigned int v23 = v27 | v26;
        *(_DWORD *)(a3 + 24) = v23;
        ++v24;
      }
      while (v24 != 4);
    }
    *(void *)a3 = ++v4;
    int v21 = (v23 >> v9) | v10;
    unsigned int v10 = v23 << -(char)v9;
    if (!v9) {
      unsigned int v10 = 0;
    }
    *(_DWORD *)(a3 + 24) = v10;
    *(_DWORD *)(a3 + 28) = v9;
    uint64_t v19 = v3 - (void)v4;
    int v20 = 8 * (v3 - v4);
  }
  else
  {
    int v20 = 8 * v19;
    v9 -= 32;
    int v21 = v10;
  }
  *(_DWORD *)(a2 + 4) = v21;
  if (v20 + v9 <= 31)
  {
    exception = __cxa_allocate_exception(8uLL);
    unsigned int v53 = "Cannot read spread.mHeight";
    goto LABEL_86;
  }
  *(_DWORD *)(a3 + 28) = v9 - 32;
  if (v9 - 32 < 0)
  {
    unint64_t v29 = *(void *)(a3 + 8);
    if ((v19 & ~(v19 >> 63) & 0xFFFFFFFC) != 0 && v29 <= (unint64_t)v4)
    {
      unsigned int v30 = bswap32(*v4);
    }
    else
    {
      uint64_t v31 = 0;
      unsigned int v30 = v10;
      do
      {
        unsigned int v32 = (unsigned __int8 *)v4 + v31;
        unsigned int v33 = v30 << 8;
        *(_DWORD *)(a3 + 24) = v33;
        int v34 = 255;
        if ((unint64_t)v4 + v31 < v3 && (unint64_t)v32 >= v29) {
          int v34 = *v32;
        }
        unsigned int v30 = v34 | v33;
        *(_DWORD *)(a3 + 24) = v30;
        ++v31;
      }
      while (v31 != 4);
    }
    *(void *)a3 = ++v4;
    int v28 = (v30 >> v9) | v10;
    unsigned int v10 = v30 << -(char)v9;
    if (!v9) {
      unsigned int v10 = 0;
    }
    *(_DWORD *)(a3 + 24) = v10;
    *(_DWORD *)(a3 + 28) = v9;
    uint64_t v19 = v3 - (void)v4;
    int v20 = 8 * (v3 - v4);
  }
  else
  {
    v9 -= 32;
    int v28 = v10;
  }
  *(_DWORD *)(a2 + 8) = v28;
  if ((v20 + v9 < 0) ^ __OFADD__(v20, v9) | (v20 + v9 == 0))
  {
    exception = __cxa_allocate_exception(8uLL);
    unsigned int v53 = "Cannot read spread.mHasDepth";
    goto LABEL_86;
  }
  unsigned int v35 = v10 >> 31;
  int v36 = v9 - 1;
  *(_DWORD *)(a3 + 28) = v9 - 1;
  if (v9 - 1 < 0)
  {
    unint64_t v38 = *(void *)(a3 + 8);
    if ((v19 & ~(v19 >> 63) & 0xFFFFFFFC) != 0 && v38 <= (unint64_t)v4)
    {
      unsigned int v10 = bswap32(*v4);
    }
    else
    {
      uint64_t v39 = 0;
      do
      {
        int v40 = (unsigned __int8 *)v4 + v39;
        unsigned int v41 = v10 << 8;
        *(_DWORD *)(a3 + 24) = v41;
        int v42 = 255;
        if ((unint64_t)v4 + v39 < v3 && (unint64_t)v40 >= v38) {
          int v42 = *v40;
        }
        unsigned int v10 = v42 | v41;
        *(_DWORD *)(a3 + 24) = v10;
        ++v39;
      }
      while (v39 != 4);
    }
    int v44 = v9 + 31;
    BOOL v43 = v9 == -31;
    *(_DWORD *)(a3 + 28) = v9 + 31;
    *(void *)a3 = ++v4;
    v35 |= v10 >> (v9 + 31);
    if (v9 == -31) {
      int v37 = 0;
    }
    else {
      int v37 = v10 << (1 - v9);
    }
    if (v43) {
      int v36 = 0;
    }
    else {
      int v36 = v44;
    }
  }
  else
  {
    int v37 = 2 * v10;
  }
  *(_DWORD *)(a3 + 24) = v37;
  *(unsigned char *)(a2 + 1) = v35 != 0;
  if (v35)
  {
    if (v36 + 8 * ((int)v3 - (int)v4) > 31)
    {
      *(_DWORD *)(a3 + 28) = v36 - 32;
      if (v36 - 32 < 0)
      {
        unint64_t v45 = *(void *)(a3 + 8);
        if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
          && v45 <= (unint64_t)v4)
        {
          unsigned int v46 = bswap32(*v4);
        }
        else
        {
          uint64_t v47 = 0;
          unsigned int v46 = v37;
          do
          {
            int v48 = (unsigned __int8 *)v4 + v47;
            unsigned int v49 = v46 << 8;
            *(_DWORD *)(a3 + 24) = v49;
            int v50 = 255;
            if ((unint64_t)v4 + v47 < v3 && (unint64_t)v48 >= v45) {
              int v50 = *v48;
            }
            unsigned int v46 = v50 | v49;
            *(_DWORD *)(a3 + 24) = v46;
            ++v47;
          }
          while (v47 != 4);
        }
        *(void *)a3 = v4 + 1;
        v37 |= v46 >> v36;
        unsigned int v51 = v46 << -(char)v36;
        if (!v36) {
          unsigned int v51 = 0;
        }
        *(_DWORD *)(a3 + 24) = v51;
        *(_DWORD *)(a3 + 28) = v36;
      }
      *(_DWORD *)(a2 + 12) = v37;
      return;
    }
    exception = __cxa_allocate_exception(8uLL);
    unsigned int v53 = "Cannot read spread.mDepth";
LABEL_86:
    void *exception = v53;
    __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
  }
}

void APAC::MetadataBitStreamParser::parseObjectChannelLock(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 16);
  unint64_t v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v27 = "Cannot read chLock.mHasMaxDistance";
    goto LABEL_38;
  }
  unsigned int v7 = *(_DWORD *)(a3 + 24);
  unsigned int v8 = v7 >> 31;
  int v9 = v6 - 1;
  *(_DWORD *)(a3 + 28) = v6 - 1;
  if (v6 - 1 < 0)
  {
    unint64_t v11 = *(void *)(a3 + 8);
    if ((v5 & ~(v5 >> 63) & 0xFFFFFFFC) == 0 || v11 > (unint64_t)v4)
    {
      uint64_t v13 = 0;
      do
      {
        BOOL v14 = (unsigned __int8 *)v4 + v13;
        unsigned int v15 = v7 << 8;
        *(_DWORD *)(a3 + 24) = v15;
        int v16 = 255;
        if ((unint64_t)v4 + v13 < v3 && (unint64_t)v14 >= v11) {
          int v16 = *v14;
        }
        unsigned int v7 = v16 | v15;
        *(_DWORD *)(a3 + 24) = v7;
        ++v13;
      }
      while (v13 != 4);
    }
    else
    {
      unsigned int v7 = bswap32(*v4);
    }
    int v18 = v6 + 31;
    BOOL v17 = v6 == -31;
    *(_DWORD *)(a3 + 28) = v6 + 31;
    *(void *)a3 = ++v4;
    v8 |= v7 >> (v6 + 31);
    if (v6 == -31) {
      int v10 = 0;
    }
    else {
      int v10 = v7 << (1 - v6);
    }
    if (v17) {
      int v9 = 0;
    }
    else {
      int v9 = v18;
    }
  }
  else
  {
    int v10 = 2 * v7;
  }
  *(_DWORD *)(a3 + 24) = v10;
  *(unsigned char *)(a2 + 1) = v8 != 0;
  if (v8)
  {
    if (v9 + 8 * ((int)v3 - (int)v4) > 31)
    {
      *(_DWORD *)(a3 + 28) = v9 - 32;
      if (v9 - 32 < 0)
      {
        unint64_t v19 = *(void *)(a3 + 8);
        if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
          && v19 <= (unint64_t)v4)
        {
          unsigned int v20 = bswap32(*v4);
        }
        else
        {
          uint64_t v21 = 0;
          unsigned int v20 = v10;
          do
          {
            unint64_t v22 = (unsigned __int8 *)v4 + v21;
            unsigned int v23 = v20 << 8;
            *(_DWORD *)(a3 + 24) = v23;
            int v24 = 255;
            if ((unint64_t)v4 + v21 < v3 && (unint64_t)v22 >= v19) {
              int v24 = *v22;
            }
            unsigned int v20 = v24 | v23;
            *(_DWORD *)(a3 + 24) = v20;
            ++v21;
          }
          while (v21 != 4);
        }
        *(void *)a3 = v4 + 1;
        v10 |= v20 >> v9;
        unsigned int v25 = v20 << -(char)v9;
        if (!v9) {
          unsigned int v25 = 0;
        }
        *(_DWORD *)(a3 + 24) = v25;
        *(_DWORD *)(a3 + 28) = v9;
      }
      *(_DWORD *)(a2 + 4) = v10;
      return;
    }
    exception = __cxa_allocate_exception(8uLL);
    int v27 = "Cannot read chLock.mMaxDistance";
LABEL_38:
    void *exception = v27;
    __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
  }
}

void APAC::MetadataBitStreamParser::parseObjectDivergence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 16);
  unint64_t v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 31)
  {
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v47 = "Cannot read objDiv.mDivergence";
    goto LABEL_69;
  }
  unsigned int v7 = *(_DWORD *)(a3 + 24);
  *(_DWORD *)(a3 + 28) = v6 - 32;
  if (v6 - 32 < 0)
  {
    unint64_t v10 = *(void *)(a3 + 8);
    if ((v5 & ~(v5 >> 63) & 0xFFFFFFFC) == 0 || v10 > (unint64_t)v4)
    {
      uint64_t v12 = 0;
      unsigned int v16 = v7;
      do
      {
        uint64_t v13 = (unsigned __int8 *)v4 + v12;
        unsigned int v14 = v16 << 8;
        *(_DWORD *)(a3 + 24) = v14;
        int v15 = 255;
        if ((unint64_t)v4 + v12 < v3 && (unint64_t)v13 >= v10) {
          int v15 = *v13;
        }
        unsigned int v16 = v15 | v14;
        *(_DWORD *)(a3 + 24) = v16;
        ++v12;
      }
      while (v12 != 4);
    }
    else
    {
      unsigned int v16 = bswap32(*v4);
    }
    *(void *)a3 = ++v4;
    int v9 = (v16 >> v6) | v7;
    unsigned int v7 = v16 << -(char)v6;
    if (!v6) {
      unsigned int v7 = 0;
    }
    *(_DWORD *)(a3 + 24) = v7;
    *(_DWORD *)(a3 + 28) = v6;
    uint64_t v5 = v3 - (void)v4;
    int v8 = 8 * (v3 - v4);
  }
  else
  {
    int v8 = 8 * v5;
    v6 -= 32;
    int v9 = v7;
  }
  *(_DWORD *)a2 = v9;
  if ((v8 + v6 < 0) ^ __OFADD__(v8, v6) | (v8 + v6 == 0))
  {
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v47 = "Cannot read objDiv.mIsCartesian";
    goto LABEL_69;
  }
  unsigned int v17 = v7 >> 31;
  int v18 = v6 - 1;
  *(_DWORD *)(a3 + 28) = v6 - 1;
  if (v6 - 1 < 0)
  {
    unint64_t v20 = *(void *)(a3 + 8);
    if ((v5 & ~(v5 >> 63) & 0xFFFFFFFC) == 0 || v20 > (unint64_t)v4)
    {
      uint64_t v22 = 0;
      do
      {
        unsigned int v23 = (unsigned __int8 *)v4 + v22;
        unsigned int v24 = v7 << 8;
        *(_DWORD *)(a3 + 24) = v24;
        int v25 = 255;
        if ((unint64_t)v4 + v22 < v3 && (unint64_t)v23 >= v20) {
          int v25 = *v23;
        }
        unsigned int v7 = v25 | v24;
        *(_DWORD *)(a3 + 24) = v7;
        ++v22;
      }
      while (v22 != 4);
    }
    else
    {
      unsigned int v7 = bswap32(*v4);
    }
    int v27 = v6 + 31;
    BOOL v26 = v6 == -31;
    *(_DWORD *)(a3 + 28) = v6 + 31;
    *(void *)a3 = ++v4;
    v17 |= v7 >> (v6 + 31);
    if (v6 == -31) {
      int v19 = 0;
    }
    else {
      int v19 = v7 << (1 - v6);
    }
    if (v26) {
      int v18 = 0;
    }
    else {
      int v18 = v27;
    }
  }
  else
  {
    int v19 = 2 * v7;
  }
  *(_DWORD *)(a3 + 24) = v19;
  *(unsigned char *)(a2 + 4) = v17 != 0;
  uint64_t v28 = v3 - (void)v4;
  int v29 = v18 + 8 * (v3 - v4);
  if (v17)
  {
    if (v29 > 31)
    {
      *(_DWORD *)(a3 + 28) = v18 - 32;
      if (v18 - 32 < 0)
      {
        int v30 = v28 & ~(v28 >> 63);
        unint64_t v31 = *(void *)(a3 + 8);
        if ((v30 & 0xFFFFFFFC) != 0 && v31 <= (unint64_t)v4)
        {
          unsigned int v32 = bswap32(*v4);
        }
        else
        {
          uint64_t v36 = 0;
          unsigned int v32 = v19;
          do
          {
            int v37 = (unsigned __int8 *)v4 + v36;
            unsigned int v38 = v32 << 8;
            *(_DWORD *)(a3 + 24) = v38;
            int v39 = 255;
            if ((unint64_t)v4 + v36 < v3 && (unint64_t)v37 >= v31) {
              int v39 = *v37;
            }
            unsigned int v32 = v39 | v38;
            *(_DWORD *)(a3 + 24) = v32;
            ++v36;
          }
          while (v36 != 4);
        }
        *(void *)a3 = v4 + 1;
        v19 |= v32 >> v18;
        unsigned int v40 = v32 << -(char)v18;
        if (!v18) {
          unsigned int v40 = 0;
        }
        *(_DWORD *)(a3 + 24) = v40;
        *(_DWORD *)(a3 + 28) = v18;
      }
      *(_DWORD *)(a2 + 12) = v19;
      return;
    }
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v47 = "Cannot read objDiv.mPositionRange";
LABEL_69:
    void *exception = v47;
    __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
  }
  if (v29 <= 31)
  {
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v47 = "Cannot read objDiv.mAzimuthRange";
    goto LABEL_69;
  }
  *(_DWORD *)(a3 + 28) = v18 - 32;
  if (v18 - 32 < 0)
  {
    int v33 = v28 & ~(v28 >> 63);
    unint64_t v34 = *(void *)(a3 + 8);
    if ((v33 & 0xFFFFFFFC) != 0 && v34 <= (unint64_t)v4)
    {
      unsigned int v35 = bswap32(*v4);
    }
    else
    {
      uint64_t v41 = 0;
      unsigned int v35 = v19;
      do
      {
        int v42 = (unsigned __int8 *)v4 + v41;
        unsigned int v43 = v35 << 8;
        *(_DWORD *)(a3 + 24) = v43;
        int v44 = 255;
        if ((unint64_t)v4 + v41 < v3 && (unint64_t)v42 >= v34) {
          int v44 = *v42;
        }
        unsigned int v35 = v44 | v43;
        *(_DWORD *)(a3 + 24) = v35;
        ++v41;
      }
      while (v41 != 4);
    }
    *(void *)a3 = v4 + 1;
    v19 |= v35 >> v18;
    unsigned int v45 = v35 << -(char)v18;
    if (!v18) {
      unsigned int v45 = 0;
    }
    *(_DWORD *)(a3 + 24) = v45;
    *(_DWORD *)(a3 + 28) = v18;
  }
  *(_DWORD *)(a2 + 16) = v19;
}

void APAC::MetadataBitStreamParser::parseZoneExclusion(uint64_t a1, BOOL *a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 16);
  unint64_t v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    unsigned int v200 = "Cannot read zoneExclusion.mIsZoneDefined";
    goto LABEL_258;
  }
  unsigned int v7 = *(_DWORD *)(a3 + 24);
  unsigned int v8 = v7 >> 31;
  int v9 = v6 - 1;
  *(_DWORD *)(a3 + 28) = v6 - 1;
  if (v6 - 1 < 0)
  {
    unint64_t v11 = *(void *)(a3 + 8);
    if ((v5 & ~(v5 >> 63) & 0xFFFFFFFC) == 0 || v11 > (unint64_t)v4)
    {
      uint64_t v13 = 0;
      do
      {
        unsigned int v14 = (unsigned __int8 *)v4 + v13;
        unsigned int v15 = v7 << 8;
        *(_DWORD *)(a3 + 24) = v15;
        int v16 = 255;
        if ((unint64_t)v4 + v13 < v3 && (unint64_t)v14 >= v11) {
          int v16 = *v14;
        }
        unsigned int v7 = v16 | v15;
        *(_DWORD *)(a3 + 24) = v7;
        ++v13;
      }
      while (v13 != 4);
    }
    else
    {
      unsigned int v7 = bswap32(*v4);
    }
    unsigned int v17 = v7 << (1 - v6);
    int v18 = v6 + 31;
    *(_DWORD *)(a3 + 28) = v18;
    *(void *)a3 = ++v4;
    v8 |= v7 >> v18;
    if (v18) {
      unsigned int v10 = v17;
    }
    else {
      unsigned int v10 = 0;
    }
    if (v18) {
      int v9 = v18;
    }
    else {
      int v9 = 0;
    }
  }
  else
  {
    unsigned int v10 = 2 * v7;
  }
  *(_DWORD *)(a3 + 24) = v10;
  *a2 = v8 != 0;
  if (!v8) {
    return;
  }
  if (v9 + 8 * ((int)v3 - (int)v4) <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    unsigned int v200 = "Cannot read zoneExclusion.mKeepPreviousZone";
    goto LABEL_258;
  }
  unsigned int v19 = v10 >> 31;
  int v20 = v9 - 1;
  *(_DWORD *)(a3 + 28) = v9 - 1;
  if (v9 - 1 < 0)
  {
    unint64_t v22 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v22 <= (unint64_t)v4)
    {
      unsigned int v10 = bswap32(*v4);
    }
    else
    {
      uint64_t v23 = 0;
      do
      {
        unsigned int v24 = (unsigned __int8 *)v4 + v23;
        unsigned int v25 = v10 << 8;
        *(_DWORD *)(a3 + 24) = v25;
        int v26 = 255;
        if ((unint64_t)v4 + v23 < v3 && (unint64_t)v24 >= v22) {
          int v26 = *v24;
        }
        unsigned int v10 = v26 | v25;
        *(_DWORD *)(a3 + 24) = v10;
        ++v23;
      }
      while (v23 != 4);
    }
    unsigned int v27 = v10 << (1 - v9);
    int v28 = v9 + 31;
    *(_DWORD *)(a3 + 28) = v28;
    *(void *)a3 = ++v4;
    v19 |= v10 >> v28;
    if (v28) {
      unsigned int v21 = v27;
    }
    else {
      unsigned int v21 = 0;
    }
    if (v28) {
      int v20 = v28;
    }
    else {
      int v20 = 0;
    }
  }
  else
  {
    unsigned int v21 = 2 * v10;
  }
  *(_DWORD *)(a3 + 24) = v21;
  a2[1] = v19 != 0;
  if (v19) {
    return;
  }
  if (v20 + 8 * ((int)v3 - (int)v4) <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    unsigned int v200 = "Cannot read zoneExclusion.mIsCartesian";
    goto LABEL_258;
  }
  unsigned int v29 = v21 >> 31;
  int v30 = v20 - 1;
  *(_DWORD *)(a3 + 28) = v20 - 1;
  if (v20 - 1 < 0)
  {
    unint64_t v32 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v32 <= (unint64_t)v4)
    {
      unsigned int v21 = bswap32(*v4);
    }
    else
    {
      uint64_t v33 = 0;
      do
      {
        unint64_t v34 = (unsigned __int8 *)v4 + v33;
        unsigned int v35 = v21 << 8;
        *(_DWORD *)(a3 + 24) = v35;
        int v36 = 255;
        if ((unint64_t)v4 + v33 < v3 && (unint64_t)v34 >= v32) {
          int v36 = *v34;
        }
        unsigned int v21 = v36 | v35;
        *(_DWORD *)(a3 + 24) = v21;
        ++v33;
      }
      while (v33 != 4);
    }
    unsigned int v37 = v21 << (1 - v20);
    int v38 = v20 + 31;
    *(_DWORD *)(a3 + 28) = v38;
    *(void *)a3 = ++v4;
    v29 |= v21 >> v38;
    if (v38) {
      unsigned int v31 = v37;
    }
    else {
      unsigned int v31 = 0;
    }
    if (v38) {
      int v30 = v38;
    }
    else {
      int v30 = 0;
    }
  }
  else
  {
    unsigned int v31 = 2 * v21;
  }
  *(_DWORD *)(a3 + 24) = v31;
  a2[2] = v29 != 0;
  if (v30 + 8 * ((int)v3 - (int)v4) <= 3)
  {
    exception = __cxa_allocate_exception(8uLL);
    unsigned int v200 = "Cannot read zoneExclusion.mNumZones";
LABEL_258:
    void *exception = v200;
    __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
  }
  unsigned int v39 = v31 >> 28;
  *(_DWORD *)(a3 + 28) = v30 - 4;
  if (v30 - 4 < 0)
  {
    unint64_t v41 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v41 <= (unint64_t)v4)
    {
      unsigned int v31 = bswap32(*v4);
    }
    else
    {
      uint64_t v42 = 0;
      do
      {
        unsigned int v43 = (unsigned __int8 *)v4 + v42;
        unsigned int v44 = v31 << 8;
        *(_DWORD *)(a3 + 24) = v44;
        int v45 = 255;
        if ((unint64_t)v4 + v42 < v3 && (unint64_t)v43 >= v41) {
          int v45 = *v43;
        }
        unsigned int v31 = v45 | v44;
        *(_DWORD *)(a3 + 24) = v31;
        ++v42;
      }
      while (v42 != 4);
    }
    int v46 = v31 << (4 - v30);
    int v47 = v30 + 28;
    *(_DWORD *)(a3 + 28) = v47;
    *(void *)a3 = v4 + 1;
    v39 |= v31 >> v47;
    if (v47) {
      int v40 = v46;
    }
    else {
      int v40 = 0;
    }
  }
  else
  {
    int v40 = 16 * v31;
  }
  *(_DWORD *)(a3 + 24) = v40;
  a2[3] = v39;
  if ((_BYTE)v39)
  {
    for (uint64_t i = 0; i != v39; ++i)
    {
      unint64_t v49 = *(void *)(a3 + 16);
      int v50 = *(unsigned int **)a3;
      uint64_t v51 = v49 - *(void *)a3;
      int v52 = *(_DWORD *)(a3 + 28);
      if (v52 + 8 * (int)v51 <= 0)
      {
        exception = __cxa_allocate_exception(8uLL);
        unsigned int v200 = "Cannot read zoneExclusion.mUsePreDefinedZone[n]";
        goto LABEL_258;
      }
      unsigned int v53 = *(_DWORD *)(a3 + 24);
      unsigned int v54 = v53 >> 31;
      int v55 = v52 - 1;
      *(_DWORD *)(a3 + 28) = v52 - 1;
      if (v52 - 1 < 0)
      {
        unint64_t v57 = *(void *)(a3 + 8);
        if ((v51 & ~(v51 >> 63) & 0xFFFFFFFC) == 0 || v57 > (unint64_t)v50)
        {
          uint64_t v59 = 0;
          do
          {
            unsigned int v60 = (unsigned __int8 *)v50 + v59;
            unsigned int v61 = v53 << 8;
            *(_DWORD *)(a3 + 24) = v61;
            int v62 = 255;
            if ((unint64_t)v50 + v59 < v49 && (unint64_t)v60 >= v57) {
              int v62 = *v60;
            }
            unsigned int v53 = v62 | v61;
            *(_DWORD *)(a3 + 24) = v53;
            ++v59;
          }
          while (v59 != 4);
        }
        else
        {
          unsigned int v53 = bswap32(*v50);
        }
        int v64 = v52 + 31;
        BOOL v63 = v52 == -31;
        *(_DWORD *)(a3 + 28) = v52 + 31;
        *(void *)a3 = ++v50;
        v54 |= v53 >> (v52 + 31);
        if (v52 == -31) {
          unsigned int v56 = 0;
        }
        else {
          unsigned int v56 = v53 << (1 - v52);
        }
        if (v63) {
          int v55 = 0;
        }
        else {
          int v55 = v64;
        }
      }
      else
      {
        unsigned int v56 = 2 * v53;
      }
      *(_DWORD *)(a3 + 24) = v56;
      a2[i + 4] = v54 != 0;
      uint64_t v65 = v49 - (void)v50;
      int v66 = v55 + 8 * (v49 - v50);
      if (v54)
      {
        if (v66 <= 3)
        {
          exception = __cxa_allocate_exception(8uLL);
          unsigned int v200 = "Cannot read zoneExclusion.mZoneIndex[n]";
          goto LABEL_258;
        }
        unsigned int v67 = v56 >> 28;
        *(_DWORD *)(a3 + 28) = v55 - 4;
        if (v55 - 4 < 0)
        {
          int v71 = v65 & ~(v65 >> 63);
          unint64_t v72 = *(void *)(a3 + 8);
          if ((v71 & 0xFFFFFFFC) != 0 && v72 <= (unint64_t)v50)
          {
            unsigned int v56 = bswap32(*v50);
          }
          else
          {
            uint64_t v75 = 0;
            do
            {
              uint64_t v76 = (unsigned __int8 *)v50 + v75;
              unsigned int v77 = v56 << 8;
              *(_DWORD *)(a3 + 24) = v77;
              int v78 = 255;
              if ((unint64_t)v50 + v75 < v49 && (unint64_t)v76 >= v72) {
                int v78 = *v76;
              }
              unsigned int v56 = v78 | v77;
              *(_DWORD *)(a3 + 24) = v56;
              ++v75;
            }
            while (v75 != 4);
          }
          int v79 = v56 << (4 - v55);
          int v80 = v55 + 28;
          *(_DWORD *)(a3 + 28) = v80;
          *(void *)a3 = v50 + 1;
          v67 |= v56 >> v80;
          if (v80) {
            int v68 = v79;
          }
          else {
            int v68 = 0;
          }
        }
        else
        {
          int v68 = 16 * v56;
        }
        *(_DWORD *)(a3 + 24) = v68;
        a2[i + 19] = v67;
      }
      else if (v29)
      {
        if (v66 <= 31)
        {
          exception = __cxa_allocate_exception(8uLL);
          unsigned int v200 = "Cannot read zoneExclusion.mZone[n].co_tu.cartesian.mMinX";
          goto LABEL_258;
        }
        *(_DWORD *)(a3 + 28) = v55 - 32;
        if (v55 - 32 < 0)
        {
          unint64_t v69 = *(void *)(a3 + 8);
          if ((v65 & ~(v65 >> 63) & 0xFFFFFFFC) != 0 && v69 <= (unint64_t)v50)
          {
            unsigned int v70 = bswap32(*v50);
          }
          else
          {
            uint64_t v81 = 0;
            unsigned int v70 = v56;
            do
            {
              int v82 = (unsigned __int8 *)v50 + v81;
              unsigned int v83 = v70 << 8;
              *(_DWORD *)(a3 + 24) = v83;
              int v84 = 255;
              if ((unint64_t)v50 + v81 < v49 && (unint64_t)v82 >= v69) {
                int v84 = *v82;
              }
              unsigned int v70 = v84 | v83;
              *(_DWORD *)(a3 + 24) = v70;
              ++v81;
            }
            while (v81 != 4);
          }
          *(void *)a3 = v50 + 1;
          v56 |= v70 >> v55;
          unsigned int v85 = v70 << -(char)v55;
          if (!v55) {
            unsigned int v85 = 0;
          }
          *(_DWORD *)(a3 + 24) = v85;
          *(_DWORD *)(a3 + 28) = v55;
        }
        unint64_t v86 = &a2[24 * i];
        *((_DWORD *)v86 + 9) = v56;
        unsigned int v87 = v86 + 36;
        unint64_t v88 = *(void *)(a3 + 16);
        unsigned int v89 = *(unsigned int **)a3;
        uint64_t v90 = v88 - *(void *)a3;
        int v91 = *(_DWORD *)(a3 + 28);
        if (v91 + 8 * (int)v90 <= 31)
        {
          exception = __cxa_allocate_exception(8uLL);
          unsigned int v200 = "Cannot read zoneExclusion.mZone[n].co_tu.cartesian.mMaxX";
          goto LABEL_258;
        }
        unsigned int v92 = *(_DWORD *)(a3 + 24);
        *(_DWORD *)(a3 + 28) = v91 - 32;
        if (v91 - 32 < 0)
        {
          int v93 = v90 & ~(v90 >> 63);
          unint64_t v94 = *(void *)(a3 + 8);
          if ((v93 & 0xFFFFFFFC) != 0 && v94 <= (unint64_t)v89)
          {
            unsigned int v95 = bswap32(*v89);
          }
          else
          {
            uint64_t v96 = 0;
            unsigned int v95 = v92;
            do
            {
              uint64_t v97 = (unsigned __int8 *)v89 + v96;
              unsigned int v98 = v95 << 8;
              *(_DWORD *)(a3 + 24) = v98;
              int v99 = 255;
              if ((unint64_t)v89 + v96 < v88 && (unint64_t)v97 >= v94) {
                int v99 = *v97;
              }
              unsigned int v95 = v99 | v98;
              *(_DWORD *)(a3 + 24) = v95;
              ++v96;
            }
            while (v96 != 4);
          }
          *(void *)a3 = v89 + 1;
          v92 |= v95 >> v91;
          unsigned int v100 = v95 << -(char)v91;
          if (!v91) {
            unsigned int v100 = 0;
          }
          *(_DWORD *)(a3 + 24) = v100;
          *(_DWORD *)(a3 + 28) = v91;
        }
        v87[1] = v92;
        unint64_t v101 = *(void *)(a3 + 16);
        unint64_t v102 = *(unsigned int **)a3;
        uint64_t v103 = v101 - *(void *)a3;
        int v104 = *(_DWORD *)(a3 + 28);
        if (v104 + 8 * (int)v103 <= 31)
        {
          exception = __cxa_allocate_exception(8uLL);
          unsigned int v200 = "Cannot read zoneExclusion.mZone[n].co_tu.cartesian.mMinY";
          goto LABEL_258;
        }
        unsigned int v105 = *(_DWORD *)(a3 + 24);
        *(_DWORD *)(a3 + 28) = v104 - 32;
        if (v104 - 32 < 0)
        {
          int v106 = v103 & ~(v103 >> 63);
          unint64_t v107 = *(void *)(a3 + 8);
          if ((v106 & 0xFFFFFFFC) != 0 && v107 <= (unint64_t)v102)
          {
            unsigned int v108 = bswap32(*v102);
          }
          else
          {
            uint64_t v109 = 0;
            unsigned int v108 = v105;
            do
            {
              int v110 = (unsigned __int8 *)v102 + v109;
              unsigned int v111 = v108 << 8;
              *(_DWORD *)(a3 + 24) = v111;
              int v112 = 255;
              if ((unint64_t)v102 + v109 < v101 && (unint64_t)v110 >= v107) {
                int v112 = *v110;
              }
              unsigned int v108 = v112 | v111;
              *(_DWORD *)(a3 + 24) = v108;
              ++v109;
            }
            while (v109 != 4);
          }
          *(void *)a3 = v102 + 1;
          v105 |= v108 >> v104;
          unsigned int v113 = v108 << -(char)v104;
          if (!v104) {
            unsigned int v113 = 0;
          }
          *(_DWORD *)(a3 + 24) = v113;
          *(_DWORD *)(a3 + 28) = v104;
        }
        v87[2] = v105;
        unint64_t v114 = *(void *)(a3 + 16);
        int v115 = *(unsigned int **)a3;
        uint64_t v116 = v114 - *(void *)a3;
        int v117 = *(_DWORD *)(a3 + 28);
        if (v117 + 8 * (int)v116 <= 31)
        {
          exception = __cxa_allocate_exception(8uLL);
          unsigned int v200 = "Cannot read zoneExclusion.mZone[n].co_tu.cartesian.mMaxY";
          goto LABEL_258;
        }
        unsigned int v118 = *(_DWORD *)(a3 + 24);
        *(_DWORD *)(a3 + 28) = v117 - 32;
        if (v117 - 32 < 0)
        {
          int v119 = v116 & ~(v116 >> 63);
          unint64_t v120 = *(void *)(a3 + 8);
          if ((v119 & 0xFFFFFFFC) != 0 && v120 <= (unint64_t)v115)
          {
            unsigned int v121 = bswap32(*v115);
          }
          else
          {
            uint64_t v122 = 0;
            unsigned int v121 = v118;
            do
            {
              int v123 = (unsigned __int8 *)v115 + v122;
              unsigned int v124 = v121 << 8;
              *(_DWORD *)(a3 + 24) = v124;
              int v125 = 255;
              if ((unint64_t)v115 + v122 < v114 && (unint64_t)v123 >= v120) {
                int v125 = *v123;
              }
              unsigned int v121 = v125 | v124;
              *(_DWORD *)(a3 + 24) = v121;
              ++v122;
            }
            while (v122 != 4);
          }
          *(void *)a3 = v115 + 1;
          v118 |= v121 >> v117;
          unsigned int v126 = v121 << -(char)v117;
          if (!v117) {
            unsigned int v126 = 0;
          }
          *(_DWORD *)(a3 + 24) = v126;
          *(_DWORD *)(a3 + 28) = v117;
        }
        v87[3] = v118;
        unint64_t v127 = *(void *)(a3 + 16);
        int v128 = *(unsigned int **)a3;
        uint64_t v129 = v127 - *(void *)a3;
        int v130 = *(_DWORD *)(a3 + 28);
        if (v130 + 8 * (int)v129 <= 31)
        {
          exception = __cxa_allocate_exception(8uLL);
          unsigned int v200 = "Cannot read zoneExclusion.mZone[n].co_tu.cartesian.mMinZ";
          goto LABEL_258;
        }
        unsigned int v131 = *(_DWORD *)(a3 + 24);
        *(_DWORD *)(a3 + 28) = v130 - 32;
        if (v130 - 32 < 0)
        {
          int v132 = v129 & ~(v129 >> 63);
          unint64_t v133 = *(void *)(a3 + 8);
          if ((v132 & 0xFFFFFFFC) != 0 && v133 <= (unint64_t)v128)
          {
            unsigned int v134 = bswap32(*v128);
          }
          else
          {
            uint64_t v135 = 0;
            unsigned int v134 = v131;
            do
            {
              int v136 = (unsigned __int8 *)v128 + v135;
              unsigned int v137 = v134 << 8;
              *(_DWORD *)(a3 + 24) = v137;
              int v138 = 255;
              if ((unint64_t)v128 + v135 < v127 && (unint64_t)v136 >= v133) {
                int v138 = *v136;
              }
              unsigned int v134 = v138 | v137;
              *(_DWORD *)(a3 + 24) = v134;
              ++v135;
            }
            while (v135 != 4);
          }
          *(void *)a3 = v128 + 1;
          v131 |= v134 >> v130;
          unsigned int v139 = v134 << -(char)v130;
          if (!v130) {
            unsigned int v139 = 0;
          }
          *(_DWORD *)(a3 + 24) = v139;
          *(_DWORD *)(a3 + 28) = v130;
        }
        v87[4] = v131;
        unint64_t v140 = *(void *)(a3 + 16);
        unsigned int v141 = *(unsigned int **)a3;
        uint64_t v142 = v140 - *(void *)a3;
        int v143 = *(_DWORD *)(a3 + 28);
        if (v143 + 8 * (int)v142 <= 31)
        {
          exception = __cxa_allocate_exception(8uLL);
          unsigned int v200 = "Cannot read zoneExclusion.mZone[n].co_tu.cartesian.mMaxZ";
          goto LABEL_258;
        }
        unsigned int v144 = *(_DWORD *)(a3 + 24);
        *(_DWORD *)(a3 + 28) = v143 - 32;
        if (v143 - 32 < 0)
        {
          int v145 = v142 & ~(v142 >> 63);
          unint64_t v146 = *(void *)(a3 + 8);
          if ((v145 & 0xFFFFFFFC) != 0 && v146 <= (unint64_t)v141)
          {
            unsigned int v147 = bswap32(*v141);
          }
          else
          {
            uint64_t v148 = 0;
            unsigned int v147 = v144;
            do
            {
              unsigned int v149 = (unsigned __int8 *)v141 + v148;
              unsigned int v150 = v147 << 8;
              *(_DWORD *)(a3 + 24) = v150;
              int v151 = 255;
              if ((unint64_t)v141 + v148 < v140 && (unint64_t)v149 >= v146) {
                int v151 = *v149;
              }
              unsigned int v147 = v151 | v150;
              *(_DWORD *)(a3 + 24) = v147;
              ++v148;
            }
            while (v148 != 4);
          }
          *(void *)a3 = v141 + 1;
          v144 |= v147 >> v143;
          unsigned int v152 = v147 << -(char)v143;
          if (!v143) {
            unsigned int v152 = 0;
          }
          *(_DWORD *)(a3 + 24) = v152;
          *(_DWORD *)(a3 + 28) = v143;
        }
        v87[5] = v144;
      }
      else
      {
        if (v66 <= 31)
        {
          exception = __cxa_allocate_exception(8uLL);
          unsigned int v200 = "Cannot read zoneExclusion.mZone[n].co_tu.spherical.mMinAzimuth";
          goto LABEL_258;
        }
        *(_DWORD *)(a3 + 28) = v55 - 32;
        if (v55 - 32 < 0)
        {
          unint64_t v73 = *(void *)(a3 + 8);
          if ((v65 & ~(v65 >> 63) & 0xFFFFFFFC) != 0 && v73 <= (unint64_t)v50)
          {
            unsigned int v74 = bswap32(*v50);
          }
          else
          {
            uint64_t v153 = 0;
            unsigned int v74 = v56;
            do
            {
              int v154 = (unsigned __int8 *)v50 + v153;
              unsigned int v155 = v74 << 8;
              *(_DWORD *)(a3 + 24) = v155;
              int v156 = 255;
              if ((unint64_t)v50 + v153 < v49 && (unint64_t)v154 >= v73) {
                int v156 = *v154;
              }
              unsigned int v74 = v156 | v155;
              *(_DWORD *)(a3 + 24) = v74;
              ++v153;
            }
            while (v153 != 4);
          }
          *(void *)a3 = v50 + 1;
          v56 |= v74 >> v55;
          unsigned int v157 = v74 << -(char)v55;
          if (!v55) {
            unsigned int v157 = 0;
          }
          *(_DWORD *)(a3 + 24) = v157;
          *(_DWORD *)(a3 + 28) = v55;
        }
        int v158 = &a2[24 * i];
        *((_DWORD *)v158 + 9) = v56;
        uint64_t v159 = v158 + 36;
        unint64_t v160 = *(void *)(a3 + 16);
        unsigned int v161 = *(unsigned int **)a3;
        uint64_t v162 = v160 - *(void *)a3;
        int v163 = *(_DWORD *)(a3 + 28);
        if (v163 + 8 * (int)v162 <= 31)
        {
          exception = __cxa_allocate_exception(8uLL);
          unsigned int v200 = "Cannot read zoneExclusion.mZone[n].co_tu.spherical.mMaxAzimuth";
          goto LABEL_258;
        }
        unsigned int v164 = *(_DWORD *)(a3 + 24);
        *(_DWORD *)(a3 + 28) = v163 - 32;
        if (v163 - 32 < 0)
        {
          int v165 = v162 & ~(v162 >> 63);
          unint64_t v166 = *(void *)(a3 + 8);
          if ((v165 & 0xFFFFFFFC) != 0 && v166 <= (unint64_t)v161)
          {
            unsigned int v167 = bswap32(*v161);
          }
          else
          {
            uint64_t v168 = 0;
            unsigned int v167 = v164;
            do
            {
              int v169 = (unsigned __int8 *)v161 + v168;
              unsigned int v170 = v167 << 8;
              *(_DWORD *)(a3 + 24) = v170;
              int v171 = 255;
              if ((unint64_t)v161 + v168 < v160 && (unint64_t)v169 >= v166) {
                int v171 = *v169;
              }
              unsigned int v167 = v171 | v170;
              *(_DWORD *)(a3 + 24) = v167;
              ++v168;
            }
            while (v168 != 4);
          }
          *(void *)a3 = v161 + 1;
          v164 |= v167 >> v163;
          unsigned int v172 = v167 << -(char)v163;
          if (!v163) {
            unsigned int v172 = 0;
          }
          *(_DWORD *)(a3 + 24) = v172;
          *(_DWORD *)(a3 + 28) = v163;
        }
        v159[1] = v164;
        unint64_t v173 = *(void *)(a3 + 16);
        unsigned int v174 = *(unsigned int **)a3;
        uint64_t v175 = v173 - *(void *)a3;
        int v176 = *(_DWORD *)(a3 + 28);
        if (v176 + 8 * (int)v175 <= 31)
        {
          exception = __cxa_allocate_exception(8uLL);
          unsigned int v200 = "Cannot read zoneExclusion.mZone[n].co_tu.spherical.mMinElevation";
          goto LABEL_258;
        }
        unsigned int v177 = *(_DWORD *)(a3 + 24);
        *(_DWORD *)(a3 + 28) = v176 - 32;
        if (v176 - 32 < 0)
        {
          int v178 = v175 & ~(v175 >> 63);
          unint64_t v179 = *(void *)(a3 + 8);
          if ((v178 & 0xFFFFFFFC) != 0 && v179 <= (unint64_t)v174)
          {
            unsigned int v180 = bswap32(*v174);
          }
          else
          {
            uint64_t v181 = 0;
            unsigned int v180 = v177;
            do
            {
              unsigned int v182 = (unsigned __int8 *)v174 + v181;
              unsigned int v183 = v180 << 8;
              *(_DWORD *)(a3 + 24) = v183;
              int v184 = 255;
              if ((unint64_t)v174 + v181 < v173 && (unint64_t)v182 >= v179) {
                int v184 = *v182;
              }
              unsigned int v180 = v184 | v183;
              *(_DWORD *)(a3 + 24) = v180;
              ++v181;
            }
            while (v181 != 4);
          }
          *(void *)a3 = v174 + 1;
          v177 |= v180 >> v176;
          unsigned int v185 = v180 << -(char)v176;
          if (!v176) {
            unsigned int v185 = 0;
          }
          *(_DWORD *)(a3 + 24) = v185;
          *(_DWORD *)(a3 + 28) = v176;
        }
        v159[2] = v177;
        unint64_t v186 = *(void *)(a3 + 16);
        unsigned int v187 = *(unsigned int **)a3;
        uint64_t v188 = v186 - *(void *)a3;
        int v189 = *(_DWORD *)(a3 + 28);
        if (v189 + 8 * (int)v188 <= 31)
        {
          exception = __cxa_allocate_exception(8uLL);
          unsigned int v200 = "Cannot read zoneExclusion.mZone[n].co_tu.spherical.mMaxElevation";
          goto LABEL_258;
        }
        unsigned int v190 = *(_DWORD *)(a3 + 24);
        *(_DWORD *)(a3 + 28) = v189 - 32;
        if (v189 - 32 < 0)
        {
          int v191 = v188 & ~(v188 >> 63);
          unint64_t v192 = *(void *)(a3 + 8);
          if ((v191 & 0xFFFFFFFC) != 0 && v192 <= (unint64_t)v187)
          {
            unsigned int v193 = bswap32(*v187);
          }
          else
          {
            uint64_t v194 = 0;
            unsigned int v193 = v190;
            do
            {
              unsigned int v195 = (unsigned __int8 *)v187 + v194;
              unsigned int v196 = v193 << 8;
              *(_DWORD *)(a3 + 24) = v196;
              int v197 = 255;
              if ((unint64_t)v187 + v194 < v186 && (unint64_t)v195 >= v192) {
                int v197 = *v195;
              }
              unsigned int v193 = v197 | v196;
              *(_DWORD *)(a3 + 24) = v193;
              ++v194;
            }
            while (v194 != 4);
          }
          *(void *)a3 = v187 + 1;
          v190 |= v193 >> v189;
          unsigned int v198 = v193 << -(char)v189;
          if (!v189) {
            unsigned int v198 = 0;
          }
          *(_DWORD *)(a3 + 24) = v198;
          *(_DWORD *)(a3 + 28) = v189;
        }
        v159[3] = v190;
      }
    }
  }
}

void APAC::MetadataBitStreamParser::parseMaskingZone(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 16);
  unint64_t v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v151 = "Cannot read maskingZone.mIsZoneDefined";
    goto LABEL_257;
  }
  unsigned int v7 = *(_DWORD *)(a3 + 24);
  unsigned int v8 = v7 >> 31;
  int v9 = v6 - 1;
  *(_DWORD *)(a3 + 28) = v6 - 1;
  if (v6 - 1 < 0)
  {
    unint64_t v11 = *(void *)(a3 + 8);
    if ((v5 & ~(v5 >> 63) & 0xFFFFFFFC) == 0 || v11 > (unint64_t)v4)
    {
      uint64_t v13 = 0;
      do
      {
        unsigned int v14 = (unsigned __int8 *)v4 + v13;
        unsigned int v15 = v7 << 8;
        *(_DWORD *)(a3 + 24) = v15;
        int v16 = 255;
        if ((unint64_t)v4 + v13 < v3 && (unint64_t)v14 >= v11) {
          int v16 = *v14;
        }
        unsigned int v7 = v16 | v15;
        *(_DWORD *)(a3 + 24) = v7;
        ++v13;
      }
      while (v13 != 4);
    }
    else
    {
      unsigned int v7 = bswap32(*v4);
    }
    unsigned int v17 = v7 << (1 - v6);
    int v18 = v6 + 31;
    *(_DWORD *)(a3 + 28) = v18;
    *(void *)a3 = ++v4;
    v8 |= v7 >> v18;
    if (v18) {
      unsigned int v10 = v17;
    }
    else {
      unsigned int v10 = 0;
    }
    if (v18) {
      int v9 = v18;
    }
    else {
      int v9 = 0;
    }
  }
  else
  {
    unsigned int v10 = 2 * v7;
  }
  *(_DWORD *)(a3 + 24) = v10;
  *(unsigned char *)a2 = v8 != 0;
  if (v8)
  {
    if (v9 + 8 * ((int)v3 - (int)v4) <= 0)
    {
      exception = __cxa_allocate_exception(8uLL);
      int v151 = "Cannot read maskingZone.mUsePreDefinedZone";
      goto LABEL_257;
    }
    unsigned int v19 = v10 >> 31;
    int v20 = v9 - 1;
    *(_DWORD *)(a3 + 28) = v9 - 1;
    if (v9 - 1 < 0)
    {
      unint64_t v22 = *(void *)(a3 + 8);
      if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
        && v22 <= (unint64_t)v4)
      {
        unsigned int v10 = bswap32(*v4);
      }
      else
      {
        uint64_t v23 = 0;
        do
        {
          unsigned int v24 = (unsigned __int8 *)v4 + v23;
          unsigned int v25 = v10 << 8;
          *(_DWORD *)(a3 + 24) = v25;
          int v26 = 255;
          if ((unint64_t)v4 + v23 < v3 && (unint64_t)v24 >= v22) {
            int v26 = *v24;
          }
          unsigned int v10 = v26 | v25;
          *(_DWORD *)(a3 + 24) = v10;
          ++v23;
        }
        while (v23 != 4);
      }
      int v28 = v9 + 31;
      BOOL v27 = v9 == -31;
      *(_DWORD *)(a3 + 28) = v9 + 31;
      *(void *)a3 = ++v4;
      v19 |= v10 >> (v9 + 31);
      if (v9 == -31) {
        unsigned int v21 = 0;
      }
      else {
        unsigned int v21 = v10 << (1 - v9);
      }
      if (v27) {
        int v20 = 0;
      }
      else {
        int v20 = v28;
      }
    }
    else
    {
      unsigned int v21 = 2 * v10;
    }
    *(_DWORD *)(a3 + 24) = v21;
    *(unsigned char *)(a2 + 1) = v19 != 0;
    uint64_t v29 = v3 - (void)v4;
    int v30 = v20 + 8 * (v3 - v4);
    if (v19)
    {
      if (v30 > 3)
      {
        unsigned int v31 = v21 >> 28;
        *(_DWORD *)(a3 + 28) = v20 - 4;
        if (v20 - 4 < 0)
        {
          int v36 = v29 & ~(v29 >> 63);
          unint64_t v37 = *(void *)(a3 + 8);
          if ((v36 & 0xFFFFFFFC) != 0 && v37 <= (unint64_t)v4)
          {
            unsigned int v21 = bswap32(*v4);
          }
          else
          {
            uint64_t v39 = 0;
            do
            {
              int v40 = (unsigned __int8 *)v4 + v39;
              unsigned int v41 = v21 << 8;
              *(_DWORD *)(a3 + 24) = v41;
              int v42 = 255;
              if ((unint64_t)v4 + v39 < v3 && (unint64_t)v40 >= v37) {
                int v42 = *v40;
              }
              unsigned int v21 = v42 | v41;
              *(_DWORD *)(a3 + 24) = v21;
              ++v39;
            }
            while (v39 != 4);
          }
          int v43 = v21 << (4 - v20);
          int v44 = v20 + 28;
          *(_DWORD *)(a3 + 28) = v44;
          *(void *)a3 = v4 + 1;
          v31 |= v21 >> v44;
          if (v44) {
            int v32 = v43;
          }
          else {
            int v32 = 0;
          }
        }
        else
        {
          int v32 = 16 * v21;
        }
        *(_DWORD *)(a3 + 24) = v32;
        *(unsigned char *)(a2 + 3) = v31;
        return;
      }
      exception = __cxa_allocate_exception(8uLL);
      int v151 = "Cannot read maskingZone.mZoneIndex";
LABEL_257:
      void *exception = v151;
      __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
    }
    if (v30 <= 0)
    {
      exception = __cxa_allocate_exception(8uLL);
      int v151 = "Cannot read maskingZone.mIsCartesian";
      goto LABEL_257;
    }
    unsigned int v33 = v21 >> 31;
    int v34 = v20 - 1;
    *(_DWORD *)(a3 + 28) = v20 - 1;
    if (v20 - 1 < 0)
    {
      unint64_t v38 = *(void *)(a3 + 8);
      if ((v29 & ~(v29 >> 63) & 0xFFFFFFFC) != 0 && v38 <= (unint64_t)v4)
      {
        unsigned int v21 = bswap32(*v4);
      }
      else
      {
        uint64_t v45 = 0;
        do
        {
          int v46 = (unsigned __int8 *)v4 + v45;
          unsigned int v47 = v21 << 8;
          *(_DWORD *)(a3 + 24) = v47;
          int v48 = 255;
          if ((unint64_t)v4 + v45 < v3 && (unint64_t)v46 >= v38) {
            int v48 = *v46;
          }
          unsigned int v21 = v48 | v47;
          *(_DWORD *)(a3 + 24) = v21;
          ++v45;
        }
        while (v45 != 4);
      }
      int v50 = v20 + 31;
      BOOL v49 = v20 == -31;
      *(_DWORD *)(a3 + 28) = v20 + 31;
      *(void *)a3 = ++v4;
      v33 |= v21 >> (v20 + 31);
      if (v20 == -31) {
        int v35 = 0;
      }
      else {
        int v35 = v21 << (1 - v20);
      }
      if (v49) {
        int v34 = 0;
      }
      else {
        int v34 = v50;
      }
    }
    else
    {
      int v35 = 2 * v21;
    }
    *(_DWORD *)(a3 + 24) = v35;
    *(unsigned char *)(a2 + 2) = v33 != 0;
    uint64_t v51 = v3 - (void)v4;
    int v52 = 8 * (v3 - v4);
    int v53 = v34 + v52;
    if (v33)
    {
      if (v53 <= 31)
      {
        exception = __cxa_allocate_exception(8uLL);
        int v151 = "Cannot read maskingZone.mZone.mMinX";
        goto LABEL_257;
      }
      *(_DWORD *)(a3 + 28) = v34 - 32;
      if (v34 - 32 < 0)
      {
        int v56 = v51 & ~(v51 >> 63);
        unint64_t v57 = *(void *)(a3 + 8);
        if ((v56 & 0xFFFFFFFC) != 0 && v57 <= (unint64_t)v4)
        {
          unsigned int v58 = bswap32(*v4);
        }
        else
        {
          uint64_t v62 = 0;
          unsigned int v58 = v35;
          do
          {
            BOOL v63 = (unsigned __int8 *)v4 + v62;
            unsigned int v64 = v58 << 8;
            *(_DWORD *)(a3 + 24) = v64;
            int v65 = 255;
            if ((unint64_t)v4 + v62 < v3 && (unint64_t)v63 >= v57) {
              int v65 = *v63;
            }
            unsigned int v58 = v65 | v64;
            *(_DWORD *)(a3 + 24) = v58;
            ++v62;
          }
          while (v62 != 4);
        }
        *(void *)a3 = ++v4;
        int v54 = (v58 >> v34) | v35;
        int v35 = v58 << -(char)v34;
        if (!v34) {
          int v35 = 0;
        }
        *(_DWORD *)(a3 + 24) = v35;
        *(_DWORD *)(a3 + 28) = v34;
        uint64_t v51 = v3 - (void)v4;
        int v52 = 8 * (v3 - v4);
      }
      else
      {
        v34 -= 32;
        int v54 = v35;
      }
      *(_DWORD *)(a2 + 4) = v54;
      if (v52 + v34 <= 31)
      {
        exception = __cxa_allocate_exception(8uLL);
        int v151 = "Cannot read maskingZone.mZone.mMaxX";
        goto LABEL_257;
      }
      *(_DWORD *)(a3 + 28) = v34 - 32;
      if (v34 - 32 < 0)
      {
        int v67 = v51 & ~(v51 >> 63);
        unint64_t v68 = *(void *)(a3 + 8);
        if ((v67 & 0xFFFFFFFC) != 0 && v68 <= (unint64_t)v4)
        {
          unsigned int v69 = bswap32(*v4);
        }
        else
        {
          uint64_t v70 = 0;
          unsigned int v69 = v35;
          do
          {
            int v71 = (unsigned __int8 *)v4 + v70;
            unsigned int v72 = v69 << 8;
            *(_DWORD *)(a3 + 24) = v72;
            int v73 = 255;
            if ((unint64_t)v4 + v70 < v3 && (unint64_t)v71 >= v68) {
              int v73 = *v71;
            }
            unsigned int v69 = v73 | v72;
            *(_DWORD *)(a3 + 24) = v69;
            ++v70;
          }
          while (v70 != 4);
        }
        *(void *)a3 = ++v4;
        int v66 = (v69 >> v34) | v35;
        int v35 = v69 << -(char)v34;
        if (!v34) {
          int v35 = 0;
        }
        *(_DWORD *)(a3 + 24) = v35;
        *(_DWORD *)(a3 + 28) = v34;
        uint64_t v51 = v3 - (void)v4;
        int v52 = 8 * (v3 - v4);
      }
      else
      {
        v34 -= 32;
        int v66 = v35;
      }
      *(_DWORD *)(a2 + 8) = v66;
      if (v52 + v34 <= 31)
      {
        exception = __cxa_allocate_exception(8uLL);
        int v151 = "Cannot read maskingZone.mZone.mMinY";
        goto LABEL_257;
      }
      *(_DWORD *)(a3 + 28) = v34 - 32;
      if (v34 - 32 < 0)
      {
        int v75 = v51 & ~(v51 >> 63);
        unint64_t v76 = *(void *)(a3 + 8);
        if ((v75 & 0xFFFFFFFC) != 0 && v76 <= (unint64_t)v4)
        {
          unsigned int v77 = bswap32(*v4);
        }
        else
        {
          uint64_t v78 = 0;
          unsigned int v77 = v35;
          do
          {
            int v79 = (unsigned __int8 *)v4 + v78;
            unsigned int v80 = v77 << 8;
            *(_DWORD *)(a3 + 24) = v80;
            int v81 = 255;
            if ((unint64_t)v4 + v78 < v3 && (unint64_t)v79 >= v76) {
              int v81 = *v79;
            }
            unsigned int v77 = v81 | v80;
            *(_DWORD *)(a3 + 24) = v77;
            ++v78;
          }
          while (v78 != 4);
        }
        *(void *)a3 = ++v4;
        int v74 = (v77 >> v34) | v35;
        int v35 = v77 << -(char)v34;
        if (!v34) {
          int v35 = 0;
        }
        *(_DWORD *)(a3 + 24) = v35;
        *(_DWORD *)(a3 + 28) = v34;
        uint64_t v51 = v3 - (void)v4;
        int v52 = 8 * (v3 - v4);
      }
      else
      {
        v34 -= 32;
        int v74 = v35;
      }
      *(_DWORD *)(a2 + 12) = v74;
      if (v52 + v34 <= 31)
      {
        exception = __cxa_allocate_exception(8uLL);
        int v151 = "Cannot read maskingZone.mZone.mMaxY";
        goto LABEL_257;
      }
      *(_DWORD *)(a3 + 28) = v34 - 32;
      if (v34 - 32 < 0)
      {
        int v83 = v51 & ~(v51 >> 63);
        unint64_t v84 = *(void *)(a3 + 8);
        if ((v83 & 0xFFFFFFFC) != 0 && v84 <= (unint64_t)v4)
        {
          unsigned int v85 = bswap32(*v4);
        }
        else
        {
          uint64_t v86 = 0;
          unsigned int v85 = v35;
          do
          {
            unsigned int v87 = (unsigned __int8 *)v4 + v86;
            unsigned int v88 = v85 << 8;
            *(_DWORD *)(a3 + 24) = v88;
            int v89 = 255;
            if ((unint64_t)v4 + v86 < v3 && (unint64_t)v87 >= v84) {
              int v89 = *v87;
            }
            unsigned int v85 = v89 | v88;
            *(_DWORD *)(a3 + 24) = v85;
            ++v86;
          }
          while (v86 != 4);
        }
        *(void *)a3 = ++v4;
        int v82 = (v85 >> v34) | v35;
        int v35 = v85 << -(char)v34;
        if (!v34) {
          int v35 = 0;
        }
        *(_DWORD *)(a3 + 24) = v35;
        *(_DWORD *)(a3 + 28) = v34;
        uint64_t v51 = v3 - (void)v4;
        int v52 = 8 * (v3 - v4);
      }
      else
      {
        v34 -= 32;
        int v82 = v35;
      }
      *(_DWORD *)(a2 + 16) = v82;
      if (v52 + v34 <= 31)
      {
        exception = __cxa_allocate_exception(8uLL);
        int v151 = "Cannot read maskingZone.mZone.mMinZ";
        goto LABEL_257;
      }
      *(_DWORD *)(a3 + 28) = v34 - 32;
      if (v34 - 32 < 0)
      {
        int v91 = v51 & ~(v51 >> 63);
        unint64_t v92 = *(void *)(a3 + 8);
        if ((v91 & 0xFFFFFFFC) != 0 && v92 <= (unint64_t)v4)
        {
          unsigned int v93 = bswap32(*v4);
        }
        else
        {
          uint64_t v94 = 0;
          unsigned int v93 = v35;
          do
          {
            unsigned int v95 = (unsigned __int8 *)v4 + v94;
            unsigned int v96 = v93 << 8;
            *(_DWORD *)(a3 + 24) = v96;
            int v97 = 255;
            if ((unint64_t)v4 + v94 < v3 && (unint64_t)v95 >= v92) {
              int v97 = *v95;
            }
            unsigned int v93 = v97 | v96;
            *(_DWORD *)(a3 + 24) = v93;
            ++v94;
          }
          while (v94 != 4);
        }
        *(void *)a3 = ++v4;
        int v90 = (v93 >> v34) | v35;
        int v35 = v93 << -(char)v34;
        if (!v34) {
          int v35 = 0;
        }
        *(_DWORD *)(a3 + 24) = v35;
        *(_DWORD *)(a3 + 28) = v34;
        uint64_t v51 = v3 - (void)v4;
        int v52 = 8 * (v3 - v4);
      }
      else
      {
        v34 -= 32;
        int v90 = v35;
      }
      *(_DWORD *)(a2 + 20) = v90;
      if (v52 + v34 <= 31)
      {
        exception = __cxa_allocate_exception(8uLL);
        int v151 = "Cannot read maskingZone.mZone.mMaxZ";
        goto LABEL_257;
      }
      *(_DWORD *)(a3 + 28) = v34 - 32;
      if (v34 - 32 < 0)
      {
        int v98 = v51 & ~(v51 >> 63);
        unint64_t v99 = *(void *)(a3 + 8);
        if ((v98 & 0xFFFFFFFC) != 0 && v99 <= (unint64_t)v4)
        {
          unsigned int v100 = bswap32(*v4);
        }
        else
        {
          uint64_t v101 = 0;
          unsigned int v100 = v35;
          do
          {
            unint64_t v102 = (unsigned __int8 *)v4 + v101;
            unsigned int v103 = v100 << 8;
            *(_DWORD *)(a3 + 24) = v103;
            int v104 = 255;
            if ((unint64_t)v4 + v101 < v3 && (unint64_t)v102 >= v99) {
              int v104 = *v102;
            }
            unsigned int v100 = v104 | v103;
            *(_DWORD *)(a3 + 24) = v100;
            ++v101;
          }
          while (v101 != 4);
        }
        *(void *)a3 = v4 + 1;
        v35 |= v100 >> v34;
        unsigned int v105 = v100 << -(char)v34;
        if (!v34) {
          unsigned int v105 = 0;
        }
        *(_DWORD *)(a3 + 24) = v105;
        *(_DWORD *)(a3 + 28) = v34;
      }
      *(_DWORD *)(a2 + 24) = v35;
    }
    else
    {
      if (v53 <= 31)
      {
        exception = __cxa_allocate_exception(8uLL);
        int v151 = "Cannot read maskingZone.mZone.mMinAzimuth";
        goto LABEL_257;
      }
      *(_DWORD *)(a3 + 28) = v34 - 32;
      if (v34 - 32 < 0)
      {
        int v59 = v51 & ~(v51 >> 63);
        unint64_t v60 = *(void *)(a3 + 8);
        if ((v59 & 0xFFFFFFFC) != 0 && v60 <= (unint64_t)v4)
        {
          unsigned int v61 = bswap32(*v4);
        }
        else
        {
          uint64_t v106 = 0;
          unsigned int v61 = v35;
          do
          {
            unint64_t v107 = (unsigned __int8 *)v4 + v106;
            unsigned int v108 = v61 << 8;
            *(_DWORD *)(a3 + 24) = v108;
            int v109 = 255;
            if ((unint64_t)v4 + v106 < v3 && (unint64_t)v107 >= v60) {
              int v109 = *v107;
            }
            unsigned int v61 = v109 | v108;
            *(_DWORD *)(a3 + 24) = v61;
            ++v106;
          }
          while (v106 != 4);
        }
        *(void *)a3 = ++v4;
        int v55 = (v61 >> v34) | v35;
        int v35 = v61 << -(char)v34;
        if (!v34) {
          int v35 = 0;
        }
        *(_DWORD *)(a3 + 24) = v35;
        *(_DWORD *)(a3 + 28) = v34;
        uint64_t v51 = v3 - (void)v4;
        int v52 = 8 * (v3 - v4);
      }
      else
      {
        v34 -= 32;
        int v55 = v35;
      }
      *(_DWORD *)(a2 + 28) = v55;
      if (v52 + v34 <= 31)
      {
        exception = __cxa_allocate_exception(8uLL);
        int v151 = "Cannot read maskingZone.mZone.mMaxAzimuth";
        goto LABEL_257;
      }
      *(_DWORD *)(a3 + 28) = v34 - 32;
      if (v34 - 32 < 0)
      {
        int v111 = v51 & ~(v51 >> 63);
        unint64_t v112 = *(void *)(a3 + 8);
        if ((v111 & 0xFFFFFFFC) != 0 && v112 <= (unint64_t)v4)
        {
          unsigned int v113 = bswap32(*v4);
        }
        else
        {
          uint64_t v114 = 0;
          unsigned int v113 = v35;
          do
          {
            int v115 = (unsigned __int8 *)v4 + v114;
            unsigned int v116 = v113 << 8;
            *(_DWORD *)(a3 + 24) = v116;
            int v117 = 255;
            if ((unint64_t)v4 + v114 < v3 && (unint64_t)v115 >= v112) {
              int v117 = *v115;
            }
            unsigned int v113 = v117 | v116;
            *(_DWORD *)(a3 + 24) = v113;
            ++v114;
          }
          while (v114 != 4);
        }
        *(void *)a3 = ++v4;
        int v110 = (v113 >> v34) | v35;
        int v35 = v113 << -(char)v34;
        if (!v34) {
          int v35 = 0;
        }
        *(_DWORD *)(a3 + 24) = v35;
        *(_DWORD *)(a3 + 28) = v34;
        uint64_t v51 = v3 - (void)v4;
        int v52 = 8 * (v3 - v4);
      }
      else
      {
        v34 -= 32;
        int v110 = v35;
      }
      *(_DWORD *)(a2 + 32) = v110;
      if (v52 + v34 <= 31)
      {
        exception = __cxa_allocate_exception(8uLL);
        int v151 = "Cannot read maskingZone.mZone.mMinElevation";
        goto LABEL_257;
      }
      *(_DWORD *)(a3 + 28) = v34 - 32;
      if (v34 - 32 < 0)
      {
        int v119 = v51 & ~(v51 >> 63);
        unint64_t v120 = *(void *)(a3 + 8);
        if ((v119 & 0xFFFFFFFC) != 0 && v120 <= (unint64_t)v4)
        {
          unsigned int v121 = bswap32(*v4);
        }
        else
        {
          uint64_t v122 = 0;
          unsigned int v121 = v35;
          do
          {
            int v123 = (unsigned __int8 *)v4 + v122;
            unsigned int v124 = v121 << 8;
            *(_DWORD *)(a3 + 24) = v124;
            int v125 = 255;
            if ((unint64_t)v4 + v122 < v3 && (unint64_t)v123 >= v120) {
              int v125 = *v123;
            }
            unsigned int v121 = v125 | v124;
            *(_DWORD *)(a3 + 24) = v121;
            ++v122;
          }
          while (v122 != 4);
        }
        *(void *)a3 = ++v4;
        int v118 = (v121 >> v34) | v35;
        int v35 = v121 << -(char)v34;
        if (!v34) {
          int v35 = 0;
        }
        *(_DWORD *)(a3 + 24) = v35;
        *(_DWORD *)(a3 + 28) = v34;
        uint64_t v51 = v3 - (void)v4;
        int v52 = 8 * (v3 - v4);
      }
      else
      {
        v34 -= 32;
        int v118 = v35;
      }
      *(_DWORD *)(a2 + 36) = v118;
      if (v52 + v34 <= 31)
      {
        exception = __cxa_allocate_exception(8uLL);
        int v151 = "Cannot read maskingZone.mZone.mMaxElevation";
        goto LABEL_257;
      }
      *(_DWORD *)(a3 + 28) = v34 - 32;
      if (v34 - 32 < 0)
      {
        int v127 = v51 & ~(v51 >> 63);
        unint64_t v128 = *(void *)(a3 + 8);
        if ((v127 & 0xFFFFFFFC) != 0 && v128 <= (unint64_t)v4)
        {
          unsigned int v129 = bswap32(*v4);
        }
        else
        {
          uint64_t v130 = 0;
          unsigned int v129 = v35;
          do
          {
            unsigned int v131 = (unsigned __int8 *)v4 + v130;
            unsigned int v132 = v129 << 8;
            *(_DWORD *)(a3 + 24) = v132;
            int v133 = 255;
            if ((unint64_t)v4 + v130 < v3 && (unint64_t)v131 >= v128) {
              int v133 = *v131;
            }
            unsigned int v129 = v133 | v132;
            *(_DWORD *)(a3 + 24) = v129;
            ++v130;
          }
          while (v130 != 4);
        }
        *(void *)a3 = ++v4;
        int v126 = (v129 >> v34) | v35;
        int v35 = v129 << -(char)v34;
        if (!v34) {
          int v35 = 0;
        }
        *(_DWORD *)(a3 + 24) = v35;
        *(_DWORD *)(a3 + 28) = v34;
        uint64_t v51 = v3 - (void)v4;
        int v52 = 8 * (v3 - v4);
      }
      else
      {
        v34 -= 32;
        int v126 = v35;
      }
      *(_DWORD *)(a2 + 40) = v126;
      if (v52 + v34 <= 31)
      {
        exception = __cxa_allocate_exception(8uLL);
        int v151 = "Cannot read maskingZone.mZone.mMinDistance";
        goto LABEL_257;
      }
      *(_DWORD *)(a3 + 28) = v34 - 32;
      if (v34 - 32 < 0)
      {
        int v135 = v51 & ~(v51 >> 63);
        unint64_t v136 = *(void *)(a3 + 8);
        if ((v135 & 0xFFFFFFFC) != 0 && v136 <= (unint64_t)v4)
        {
          unsigned int v137 = bswap32(*v4);
        }
        else
        {
          uint64_t v138 = 0;
          unsigned int v137 = v35;
          do
          {
            unsigned int v139 = (unsigned __int8 *)v4 + v138;
            unsigned int v140 = v137 << 8;
            *(_DWORD *)(a3 + 24) = v140;
            int v141 = 255;
            if ((unint64_t)v4 + v138 < v3 && (unint64_t)v139 >= v136) {
              int v141 = *v139;
            }
            unsigned int v137 = v141 | v140;
            *(_DWORD *)(a3 + 24) = v137;
            ++v138;
          }
          while (v138 != 4);
        }
        *(void *)a3 = ++v4;
        int v134 = (v137 >> v34) | v35;
        int v35 = v137 << -(char)v34;
        if (!v34) {
          int v35 = 0;
        }
        *(_DWORD *)(a3 + 24) = v35;
        *(_DWORD *)(a3 + 28) = v34;
        uint64_t v51 = v3 - (void)v4;
        int v52 = 8 * (v3 - v4);
      }
      else
      {
        v34 -= 32;
        int v134 = v35;
      }
      *(_DWORD *)(a2 + 44) = v134;
      if (v52 + v34 <= 31)
      {
        exception = __cxa_allocate_exception(8uLL);
        int v151 = "Cannot read maskingZone.mZone.mMaxDistance";
        goto LABEL_257;
      }
      *(_DWORD *)(a3 + 28) = v34 - 32;
      if (v34 - 32 < 0)
      {
        int v142 = v51 & ~(v51 >> 63);
        unint64_t v143 = *(void *)(a3 + 8);
        if ((v142 & 0xFFFFFFFC) != 0 && v143 <= (unint64_t)v4)
        {
          unsigned int v144 = bswap32(*v4);
        }
        else
        {
          uint64_t v145 = 0;
          unsigned int v144 = v35;
          do
          {
            unint64_t v146 = (unsigned __int8 *)v4 + v145;
            unsigned int v147 = v144 << 8;
            *(_DWORD *)(a3 + 24) = v147;
            int v148 = 255;
            if ((unint64_t)v4 + v145 < v3 && (unint64_t)v146 >= v143) {
              int v148 = *v146;
            }
            unsigned int v144 = v148 | v147;
            *(_DWORD *)(a3 + 24) = v144;
            ++v145;
          }
          while (v145 != 4);
        }
        *(void *)a3 = v4 + 1;
        v35 |= v144 >> v34;
        unsigned int v149 = v144 << -(char)v34;
        if (!v34) {
          unsigned int v149 = 0;
        }
        *(_DWORD *)(a3 + 24) = v149;
        *(_DWORD *)(a3 + 28) = v34;
      }
      *(_DWORD *)(a2 + 48) = v35;
    }
  }
}

void APAC::MetadataBitStreamParser::parseSceneReverb(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 16);
  unint64_t v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 2)
  {
    exception = __cxa_allocate_exception(8uLL);
    unint64_t v99 = "Cannot read reverb.mReverbProcIndex";
    goto LABEL_165;
  }
  unsigned int v7 = *(_DWORD *)(a3 + 24);
  unsigned int v8 = v7 >> 29;
  int v9 = v6 - 3;
  *(_DWORD *)(a3 + 28) = v6 - 3;
  if (v6 - 3 < 0)
  {
    unint64_t v11 = *(void *)(a3 + 8);
    if ((v5 & ~(v5 >> 63) & 0xFFFFFFFC) == 0 || v11 > (unint64_t)v4)
    {
      uint64_t v13 = 0;
      do
      {
        unsigned int v14 = (unsigned __int8 *)v4 + v13;
        unsigned int v15 = v7 << 8;
        *(_DWORD *)(a3 + 24) = v15;
        int v16 = 255;
        if ((unint64_t)v4 + v13 < v3 && (unint64_t)v14 >= v11) {
          int v16 = *v14;
        }
        unsigned int v7 = v16 | v15;
        *(_DWORD *)(a3 + 24) = v7;
        ++v13;
      }
      while (v13 != 4);
    }
    else
    {
      unsigned int v7 = bswap32(*v4);
    }
    int v18 = v6 + 29;
    BOOL v17 = v6 == -29;
    *(_DWORD *)(a3 + 28) = v6 + 29;
    *(void *)a3 = ++v4;
    v8 |= v7 >> (v6 + 29);
    if (v6 == -29) {
      unsigned int v10 = 0;
    }
    else {
      unsigned int v10 = v7 << (3 - v6);
    }
    if (v17) {
      int v9 = 0;
    }
    else {
      int v9 = v18;
    }
  }
  else
  {
    unsigned int v10 = 8 * v7;
  }
  *(_DWORD *)(a3 + 24) = v10;
  *(unsigned char *)a2 = v8;
  if (v8 != 3)
  {
    if (v8 != 2)
    {
      if (v8 != 1) {
        return;
      }
      if (v9 + 8 * ((int)v3 - (int)v4) > 9)
      {
        unsigned int v19 = v10 >> 22;
        *(_DWORD *)(a3 + 28) = v9 - 10;
        if (v9 - 10 < 0)
        {
          unint64_t v28 = *(void *)(a3 + 8);
          if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
            && v28 <= (unint64_t)v4)
          {
            unsigned int v10 = bswap32(*v4);
          }
          else
          {
            uint64_t v40 = 0;
            do
            {
              unsigned int v41 = (unsigned __int8 *)v4 + v40;
              unsigned int v42 = v10 << 8;
              *(_DWORD *)(a3 + 24) = v42;
              int v43 = 255;
              if ((unint64_t)v4 + v40 < v3 && (unint64_t)v41 >= v28) {
                int v43 = *v41;
              }
              unsigned int v10 = v43 | v42;
              *(_DWORD *)(a3 + 24) = v10;
              ++v40;
            }
            while (v40 != 4);
          }
          unsigned int v44 = v10 << (10 - v9);
          int v45 = v9 + 22;
          *(_DWORD *)(a3 + 28) = v45;
          *(void *)a3 = v4 + 1;
          v19 |= v10 >> v45;
          if (v45) {
            unsigned int v20 = v44;
          }
          else {
            unsigned int v20 = 0;
          }
        }
        else
        {
          unsigned int v20 = v10 << 10;
        }
        *(_DWORD *)(a3 + 24) = v20;
        *(_WORD *)(a2 + 2) = v19;
LABEL_156:
        uint64_t v97 = a2 + 144;
        APAC::MetadataBitStreamParser::parseParametricReverb(a1, v97, a3);
        return;
      }
      exception = __cxa_allocate_exception(8uLL);
      unint64_t v99 = "Cannot read reverb.mAUSMReverbPreset";
      goto LABEL_165;
    }
    if (v9 + 8 * ((int)v3 - (int)v4) > 1)
    {
      unsigned int v21 = v10 >> 30;
      int v22 = v9 - 2;
      *(_DWORD *)(a3 + 28) = v9 - 2;
      if (v9 - 2 < 0)
      {
        unint64_t v27 = *(void *)(a3 + 8);
        if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
          && v27 <= (unint64_t)v4)
        {
          unsigned int v10 = bswap32(*v4);
        }
        else
        {
          uint64_t v30 = 0;
          do
          {
            unsigned int v31 = (unsigned __int8 *)v4 + v30;
            unsigned int v32 = v10 << 8;
            *(_DWORD *)(a3 + 24) = v32;
            int v33 = 255;
            if ((unint64_t)v4 + v30 < v3 && (unint64_t)v31 >= v27) {
              int v33 = *v31;
            }
            unsigned int v10 = v33 | v32;
            *(_DWORD *)(a3 + 24) = v10;
            ++v30;
          }
          while (v30 != 4);
        }
        unsigned int v34 = v10 << (2 - v9);
        int v35 = v9 + 30;
        *(_DWORD *)(a3 + 28) = v35;
        *(void *)a3 = ++v4;
        v21 |= v10 >> v35;
        if (v35) {
          unsigned int v23 = v34;
        }
        else {
          unsigned int v23 = 0;
        }
        if (v35) {
          int v22 = v35;
        }
        else {
          int v22 = 0;
        }
      }
      else
      {
        unsigned int v23 = 4 * v10;
      }
      *(_DWORD *)(a3 + 24) = v23;
      *(unsigned char *)(a2 + 4) = v21;
      if (v22 + 8 * ((int)v3 - (int)v4) > 8)
      {
        unsigned int v36 = v23 >> 23;
        int v37 = v22 - 9;
        *(_DWORD *)(a3 + 28) = v22 - 9;
        if (v22 - 9 < 0)
        {
          unint64_t v39 = *(void *)(a3 + 8);
          if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
            && v39 <= (unint64_t)v4)
          {
            unsigned int v23 = bswap32(*v4);
          }
          else
          {
            uint64_t v56 = 0;
            do
            {
              unint64_t v57 = (unsigned __int8 *)v4 + v56;
              unsigned int v58 = v23 << 8;
              *(_DWORD *)(a3 + 24) = v58;
              int v59 = 255;
              if ((unint64_t)v4 + v56 < v3 && (unint64_t)v57 >= v39) {
                int v59 = *v57;
              }
              unsigned int v23 = v59 | v58;
              *(_DWORD *)(a3 + 24) = v23;
              ++v56;
            }
            while (v56 != 4);
          }
          unsigned int v60 = v23 << (9 - v22);
          int v61 = v22 + 23;
          *(_DWORD *)(a3 + 28) = v61;
          *(void *)a3 = ++v4;
          v36 |= v23 >> v61;
          if (v61) {
            unsigned int v38 = v60;
          }
          else {
            unsigned int v38 = 0;
          }
          if (v61) {
            int v37 = v61;
          }
          else {
            int v37 = 0;
          }
        }
        else
        {
          unsigned int v38 = v23 << 9;
        }
        *(_DWORD *)(a3 + 24) = v38;
        *(_WORD *)(a2 + 6) = v36;
        if (v37 + 8 * ((int)v3 - (int)v4) > 8)
        {
          unsigned int v62 = v38 >> 23;
          int v63 = v37 - 9;
          *(_DWORD *)(a3 + 28) = v37 - 9;
          if (v37 - 9 < 0)
          {
            unint64_t v65 = *(void *)(a3 + 8);
            if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
              && v65 <= (unint64_t)v4)
            {
              unsigned int v38 = bswap32(*v4);
            }
            else
            {
              uint64_t v75 = 0;
              do
              {
                unint64_t v76 = (unsigned __int8 *)v4 + v75;
                unsigned int v77 = v38 << 8;
                *(_DWORD *)(a3 + 24) = v77;
                int v78 = 255;
                if ((unint64_t)v4 + v75 < v3 && (unint64_t)v76 >= v65) {
                  int v78 = *v76;
                }
                unsigned int v38 = v78 | v77;
                *(_DWORD *)(a3 + 24) = v38;
                ++v75;
              }
              while (v75 != 4);
            }
            unsigned int v79 = v38 << (9 - v37);
            int v80 = v37 + 23;
            *(_DWORD *)(a3 + 28) = v80;
            *(void *)a3 = ++v4;
            v62 |= v38 >> v80;
            if (v80) {
              unsigned int v64 = v79;
            }
            else {
              unsigned int v64 = 0;
            }
            if (v80) {
              int v63 = v80;
            }
            else {
              int v63 = 0;
            }
          }
          else
          {
            unsigned int v64 = v38 << 9;
          }
          *(_DWORD *)(a3 + 24) = v64;
          *(_WORD *)(a2 + 8) = v62;
          if (v63 + 8 * ((int)v3 - (int)v4) > 9)
          {
            unsigned int v81 = v64 >> 22;
            *(_DWORD *)(a3 + 28) = v63 - 10;
            if (v63 - 10 < 0)
            {
              unint64_t v83 = *(void *)(a3 + 8);
              if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
                && v83 <= (unint64_t)v4)
              {
                unsigned int v64 = bswap32(*v4);
              }
              else
              {
                uint64_t v91 = 0;
                do
                {
                  unint64_t v92 = (unsigned __int8 *)v4 + v91;
                  unsigned int v93 = v64 << 8;
                  *(_DWORD *)(a3 + 24) = v93;
                  int v94 = 255;
                  if ((unint64_t)v4 + v91 < v3 && (unint64_t)v92 >= v83) {
                    int v94 = *v92;
                  }
                  unsigned int v64 = v94 | v93;
                  *(_DWORD *)(a3 + 24) = v64;
                  ++v91;
                }
                while (v91 != 4);
              }
              unsigned int v95 = v64 << (10 - v63);
              int v96 = v63 + 22;
              *(_DWORD *)(a3 + 28) = v96;
              *(void *)a3 = v4 + 1;
              v81 |= v64 >> v96;
              if (v96) {
                unsigned int v82 = v95;
              }
              else {
                unsigned int v82 = 0;
              }
            }
            else
            {
              unsigned int v82 = v64 << 10;
            }
            *(_DWORD *)(a3 + 24) = v82;
            *(_WORD *)(a2 + 10) = v81;
            goto LABEL_156;
          }
          exception = __cxa_allocate_exception(8uLL);
          unint64_t v99 = "Cannot read reverb.mFallbackCustomeIR.mAUSMReverbPreset";
LABEL_165:
          void *exception = v99;
          __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
        }
LABEL_162:
        exception = __cxa_allocate_exception(8uLL);
        unint64_t v99 = "Cannot read reverb.mCustomData_EntryID";
        goto LABEL_165;
      }
LABEL_161:
      exception = __cxa_allocate_exception(8uLL);
      unint64_t v99 = "Cannot read reverb.mCustomData_TableID";
      goto LABEL_165;
    }
LABEL_160:
    exception = __cxa_allocate_exception(8uLL);
    unint64_t v99 = "Cannot read reverb.mDataLocationIndex";
    goto LABEL_165;
  }
  if (v9 + 8 * ((int)v3 - (int)v4) <= 1) {
    goto LABEL_160;
  }
  unsigned int v24 = v10 >> 30;
  int v25 = v9 - 2;
  *(_DWORD *)(a3 + 28) = v9 - 2;
  if (v9 - 2 < 0)
  {
    unint64_t v29 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v29 <= (unint64_t)v4)
    {
      unsigned int v10 = bswap32(*v4);
    }
    else
    {
      uint64_t v46 = 0;
      do
      {
        unsigned int v47 = (unsigned __int8 *)v4 + v46;
        unsigned int v48 = v10 << 8;
        *(_DWORD *)(a3 + 24) = v48;
        int v49 = 255;
        if ((unint64_t)v4 + v46 < v3 && (unint64_t)v47 >= v29) {
          int v49 = *v47;
        }
        unsigned int v10 = v49 | v48;
        *(_DWORD *)(a3 + 24) = v10;
        ++v46;
      }
      while (v46 != 4);
    }
    unsigned int v50 = v10 << (2 - v9);
    int v51 = v9 + 30;
    *(_DWORD *)(a3 + 28) = v51;
    *(void *)a3 = ++v4;
    v24 |= v10 >> v51;
    if (v51) {
      unsigned int v26 = v50;
    }
    else {
      unsigned int v26 = 0;
    }
    if (v51) {
      int v25 = v51;
    }
    else {
      int v25 = 0;
    }
  }
  else
  {
    unsigned int v26 = 4 * v10;
  }
  *(_DWORD *)(a3 + 24) = v26;
  *(unsigned char *)(a2 + 4) = v24;
  if (v25 + 8 * ((int)v3 - (int)v4) <= 8) {
    goto LABEL_161;
  }
  unsigned int v52 = v26 >> 23;
  int v53 = v25 - 9;
  *(_DWORD *)(a3 + 28) = v25 - 9;
  if (v25 - 9 < 0)
  {
    unint64_t v55 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v55 <= (unint64_t)v4)
    {
      unsigned int v26 = bswap32(*v4);
    }
    else
    {
      uint64_t v66 = 0;
      do
      {
        int v67 = (unsigned __int8 *)v4 + v66;
        unsigned int v68 = v26 << 8;
        *(_DWORD *)(a3 + 24) = v68;
        int v69 = 255;
        if ((unint64_t)v4 + v66 < v3 && (unint64_t)v67 >= v55) {
          int v69 = *v67;
        }
        unsigned int v26 = v69 | v68;
        *(_DWORD *)(a3 + 24) = v26;
        ++v66;
      }
      while (v66 != 4);
    }
    int v71 = v25 + 23;
    BOOL v70 = v25 == -23;
    *(_DWORD *)(a3 + 28) = v25 + 23;
    *(void *)a3 = ++v4;
    v52 |= v26 >> (v25 + 23);
    if (v25 == -23) {
      unsigned int v54 = 0;
    }
    else {
      unsigned int v54 = v26 << (9 - v25);
    }
    if (v70) {
      int v53 = 0;
    }
    else {
      int v53 = v71;
    }
  }
  else
  {
    unsigned int v54 = v26 << 9;
  }
  *(_DWORD *)(a3 + 24) = v54;
  *(_WORD *)(a2 + 6) = v52;
  if (v53 + 8 * ((int)v3 - (int)v4) <= 8) {
    goto LABEL_162;
  }
  unsigned int v72 = v54 >> 23;
  *(_DWORD *)(a3 + 28) = v53 - 9;
  if (v53 - 9 < 0)
  {
    unint64_t v74 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v74 <= (unint64_t)v4)
    {
      unsigned int v54 = bswap32(*v4);
    }
    else
    {
      uint64_t v84 = 0;
      do
      {
        unsigned int v85 = (unsigned __int8 *)v4 + v84;
        unsigned int v86 = v54 << 8;
        *(_DWORD *)(a3 + 24) = v86;
        int v87 = 255;
        if ((unint64_t)v4 + v84 < v3 && (unint64_t)v85 >= v74) {
          int v87 = *v85;
        }
        unsigned int v54 = v87 | v86;
        *(_DWORD *)(a3 + 24) = v54;
        ++v84;
      }
      while (v84 != 4);
    }
    unsigned int v88 = v54 << (9 - v53);
    int v89 = v53 + 23;
    *(_DWORD *)(a3 + 28) = v89;
    *(void *)a3 = v4 + 1;
    v72 |= v54 >> v89;
    if (v89) {
      unsigned int v73 = v88;
    }
    else {
      unsigned int v73 = 0;
    }
  }
  else
  {
    unsigned int v73 = v54 << 9;
  }
  *(_DWORD *)(a3 + 24) = v73;
  *(_WORD *)(a2 + 8) = v72;
  uint64_t v90 = a2 + 12;
  APAC::MetadataBitStreamParser::parseFallbackRoomGeometry(a1, v90, a3);
}

{
  unint64_t v3;
  unsigned int *v4;
  uint64_t v5;
  int v6;
  unsigned int v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  unint64_t v11;
  uint64_t v13;
  unsigned __int8 *v14;
  unsigned int v15;
  int v16;
  BOOL v17;
  int v18;
  unsigned int v19;
  int v20;
  unsigned int v21;
  unsigned int v22;
  int v23;
  unsigned int v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unsigned __int8 *v28;
  unsigned int v29;
  int v30;
  unsigned int v31;
  int v32;
  unsigned int v33;
  unsigned int v34;
  unint64_t v35;
  uint64_t v36;
  unsigned __int8 *v37;
  unsigned int v38;
  int v39;
  unsigned int v40;
  int v41;
  unsigned int v42;
  int v43;
  unsigned int v44;
  unint64_t v45;
  uint64_t v46;
  unsigned __int8 *v47;
  unsigned int v48;
  int v49;
  unsigned int v50;
  BOOL v51;
  int v52;
  unsigned int v53;
  uint64_t v54;
  unsigned __int8 *v55;
  unsigned int v56;
  int v57;
  BOOL v58;
  int v59;
  unint64_t v60;
  uint64_t v61;
  unsigned __int8 *v62;
  unsigned int v63;
  int v64;
  int v65;
  void *exception;
  const char *v67;

  unint64_t v3 = *(void *)(a3 + 16);
  unint64_t v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 2)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v67 = "Cannot read sR.reverbProcIndex";
    goto LABEL_107;
  }
  unsigned int v7 = *(_DWORD *)(a3 + 24);
  unsigned int v8 = v7 >> 29;
  int v9 = v6 - 3;
  *(_DWORD *)(a3 + 28) = v6 - 3;
  if (v6 - 3 < 0)
  {
    unint64_t v11 = *(void *)(a3 + 8);
    if ((v5 & ~(v5 >> 63) & 0xFFFFFFFC) == 0 || v11 > (unint64_t)v4)
    {
      uint64_t v13 = 0;
      do
      {
        unsigned int v14 = (unsigned __int8 *)v4 + v13;
        unsigned int v15 = v7 << 8;
        *(_DWORD *)(a3 + 24) = v15;
        int v16 = 255;
        if ((unint64_t)v4 + v13 < v3 && (unint64_t)v14 >= v11) {
          int v16 = *v14;
        }
        unsigned int v7 = v16 | v15;
        *(_DWORD *)(a3 + 24) = v7;
        ++v13;
      }
      while (v13 != 4);
    }
    else
    {
      unsigned int v7 = bswap32(*v4);
    }
    int v18 = v6 + 29;
    BOOL v17 = v6 == -29;
    *(_DWORD *)(a3 + 28) = v6 + 29;
    *(void *)a3 = ++v4;
    v8 |= v7 >> (v6 + 29);
    if (v6 == -29) {
      unsigned int v10 = 0;
    }
    else {
      unsigned int v10 = v7 << (3 - v6);
    }
    if (v17) {
      int v9 = 0;
    }
    else {
      int v9 = v18;
    }
  }
  else
  {
    unsigned int v10 = 8 * v7;
  }
  *(_DWORD *)(a3 + 24) = v10;
  *(unsigned char *)a2 = v8;
  if (v8 == 2)
  {
    if (v9 + 8 * ((int)v3 - (int)v4) <= 3)
    {
      exception = __cxa_allocate_exception(8uLL);
      int v67 = "Cannot read sR.codeBookID";
    }
    else
    {
      int v22 = v10 >> 28;
      unsigned int v23 = v9 - 4;
      *(_DWORD *)(a3 + 28) = v9 - 4;
      if (v9 - 4 < 0)
      {
        unsigned int v26 = *(void *)(a3 + 8);
        if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
          && v26 <= (unint64_t)v4)
        {
          unsigned int v10 = bswap32(*v4);
        }
        else
        {
          unsigned int v36 = 0;
          do
          {
            int v37 = (unsigned __int8 *)v4 + v36;
            unsigned int v38 = v10 << 8;
            *(_DWORD *)(a3 + 24) = v38;
            unint64_t v39 = 255;
            if ((unint64_t)v4 + v36 < v3 && (unint64_t)v37 >= v26) {
              unint64_t v39 = *v37;
            }
            unsigned int v10 = v39 | v38;
            *(_DWORD *)(a3 + 24) = v10;
            ++v36;
          }
          while (v36 != 4);
        }
        uint64_t v40 = v10 << (4 - v9);
        unsigned int v41 = v9 + 28;
        *(_DWORD *)(a3 + 28) = v41;
        *(void *)a3 = ++v4;
        v22 |= v10 >> v41;
        if (v41) {
          unsigned int v24 = v40;
        }
        else {
          unsigned int v24 = 0;
        }
        if (v41) {
          unsigned int v23 = v41;
        }
        else {
          unsigned int v23 = 0;
        }
      }
      else
      {
        unsigned int v24 = 16 * v10;
      }
      *(_DWORD *)(a3 + 24) = v24;
      *(unsigned char *)(a2 + 5) = v22;
      if (v23 + 8 * ((int)v3 - (int)v4) > 9)
      {
        unsigned int v42 = v24 >> 22;
        int v43 = v23 - 10;
        *(_DWORD *)(a3 + 28) = v23 - 10;
        if (v23 - 10 < 0)
        {
          int v45 = *(void *)(a3 + 8);
          if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
            && v45 <= (unint64_t)v4)
          {
            unsigned int v24 = bswap32(*v4);
          }
          else
          {
            unsigned int v54 = 0;
            do
            {
              unint64_t v55 = (unsigned __int8 *)v4 + v54;
              uint64_t v56 = v24 << 8;
              *(_DWORD *)(a3 + 24) = v56;
              unint64_t v57 = 255;
              if ((unint64_t)v4 + v54 < v3 && (unint64_t)v55 >= v45) {
                unint64_t v57 = *v55;
              }
              unsigned int v24 = v57 | v56;
              *(_DWORD *)(a3 + 24) = v24;
              ++v54;
            }
            while (v54 != 4);
          }
          int v59 = v23 + 22;
          unsigned int v58 = v23 == -22;
          *(_DWORD *)(a3 + 28) = v23 + 22;
          *(void *)a3 = ++v4;
          v42 |= v24 >> (v23 + 22);
          if (v23 == -22) {
            unsigned int v44 = 0;
          }
          else {
            unsigned int v44 = v24 << (10 - v23);
          }
          if (v58) {
            int v43 = 0;
          }
          else {
            int v43 = v59;
          }
        }
        else
        {
          unsigned int v44 = v24 << 10;
        }
        *(_DWORD *)(a3 + 24) = v44;
        *(_WORD *)(a2 + 6) = v42;
        if (v43 + 8 * ((int)v3 - (int)v4) > 6)
        {
          int v33 = v44 >> 25;
          *(_DWORD *)(a3 + 28) = v43 - 7;
          if (v43 - 7 >= 0)
          {
            unsigned int v34 = v44 << 7;
            goto LABEL_100;
          }
          unsigned int v60 = *(void *)(a3 + 8);
          if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
            && v60 <= (unint64_t)v4)
          {
            unsigned int v44 = bswap32(*v4);
          }
          else
          {
            int v61 = 0;
            do
            {
              unsigned int v62 = (unsigned __int8 *)v4 + v61;
              int v63 = v44 << 8;
              *(_DWORD *)(a3 + 24) = v63;
              unsigned int v64 = 255;
              if ((unint64_t)v4 + v61 < v3 && (unint64_t)v62 >= v60) {
                unsigned int v64 = *v62;
              }
              unsigned int v44 = v64 | v63;
              *(_DWORD *)(a3 + 24) = v44;
              ++v61;
            }
            while (v61 != 4);
          }
          unsigned int v50 = v44 << (7 - v43);
          unint64_t v65 = v43 + 25;
          int v51 = v65 == 0;
          *(_DWORD *)(a3 + 28) = v65;
          *(void *)a3 = v4 + 1;
          int v53 = v44 >> v65;
LABEL_97:
          LOBYTE(v33) = v53 | v33;
          if (v51) {
            unsigned int v34 = 0;
          }
          else {
            unsigned int v34 = v50;
          }
          goto LABEL_100;
        }
        goto LABEL_103;
      }
      exception = __cxa_allocate_exception(8uLL);
      int v67 = "Cannot read sR.IRFilterID";
    }
LABEL_107:
    void *exception = v67;
    __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
  }
  if (v8 != 1) {
    return;
  }
  if (v9 + 8 * ((int)v3 - (int)v4) <= 9)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v67 = "Cannot read sR.reverbProcPreset";
    goto LABEL_107;
  }
  unsigned int v19 = v10 >> 22;
  unsigned int v20 = v9 - 10;
  *(_DWORD *)(a3 + 28) = v9 - 10;
  if (v9 - 10 < 0)
  {
    int v25 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v25 <= (unint64_t)v4)
    {
      unsigned int v10 = bswap32(*v4);
    }
    else
    {
      unint64_t v27 = 0;
      do
      {
        unint64_t v28 = (unsigned __int8 *)v4 + v27;
        unint64_t v29 = v10 << 8;
        *(_DWORD *)(a3 + 24) = v29;
        uint64_t v30 = 255;
        if ((unint64_t)v4 + v27 < v3 && (unint64_t)v28 >= v25) {
          uint64_t v30 = *v28;
        }
        unsigned int v10 = v30 | v29;
        *(_DWORD *)(a3 + 24) = v10;
        ++v27;
      }
      while (v27 != 4);
    }
    unsigned int v31 = v10 << (10 - v9);
    unsigned int v32 = v9 + 22;
    *(_DWORD *)(a3 + 28) = v32;
    *(void *)a3 = ++v4;
    v19 |= v10 >> v32;
    if (v32) {
      unsigned int v21 = v31;
    }
    else {
      unsigned int v21 = 0;
    }
    if (v32) {
      unsigned int v20 = v32;
    }
    else {
      unsigned int v20 = 0;
    }
  }
  else
  {
    unsigned int v21 = v10 << 10;
  }
  *(_DWORD *)(a3 + 24) = v21;
  *(_WORD *)(a2 + 2) = v19;
  if (v20 + 8 * ((int)v3 - (int)v4) <= 6)
  {
LABEL_103:
    exception = __cxa_allocate_exception(8uLL);
    int v67 = "Cannot read sR.mixLevel";
    goto LABEL_107;
  }
  int v33 = v21 >> 25;
  *(_DWORD *)(a3 + 28) = v20 - 7;
  if (v20 - 7 < 0)
  {
    int v35 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v35 <= (unint64_t)v4)
    {
      unsigned int v21 = bswap32(*v4);
    }
    else
    {
      uint64_t v46 = 0;
      do
      {
        unsigned int v47 = (unsigned __int8 *)v4 + v46;
        unsigned int v48 = v21 << 8;
        *(_DWORD *)(a3 + 24) = v48;
        int v49 = 255;
        if ((unint64_t)v4 + v46 < v3 && (unint64_t)v47 >= v35) {
          int v49 = *v47;
        }
        unsigned int v21 = v49 | v48;
        *(_DWORD *)(a3 + 24) = v21;
        ++v46;
      }
      while (v46 != 4);
    }
    unsigned int v50 = v21 << (7 - v20);
    unsigned int v52 = v20 + 25;
    int v51 = v52 == 0;
    *(_DWORD *)(a3 + 28) = v52;
    *(void *)a3 = v4 + 1;
    int v53 = v21 >> v52;
    goto LABEL_97;
  }
  unsigned int v34 = v21 << 7;
LABEL_100:
  *(_DWORD *)(a3 + 24) = v34;
  *(unsigned char *)(a2 + 4) = v33;
}

void APAC::MetadataBitStreamParser::parsePostProcReverb(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 16);
  unint64_t v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 2)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v37 = "Cannot read ppReverb.mReverbProcIndex";
    goto LABEL_57;
  }
  unsigned int v7 = *(_DWORD *)(a3 + 24);
  unsigned int v8 = v7 >> 29;
  int v9 = v6 - 3;
  *(_DWORD *)(a3 + 28) = v6 - 3;
  if (v6 - 3 < 0)
  {
    unint64_t v11 = *(void *)(a3 + 8);
    if ((v5 & ~(v5 >> 63) & 0xFFFFFFFC) == 0 || v11 > (unint64_t)v4)
    {
      uint64_t v13 = 0;
      do
      {
        unsigned int v14 = (unsigned __int8 *)v4 + v13;
        unsigned int v15 = v7 << 8;
        *(_DWORD *)(a3 + 24) = v15;
        int v16 = 255;
        if ((unint64_t)v4 + v13 < v3 && (unint64_t)v14 >= v11) {
          int v16 = *v14;
        }
        unsigned int v7 = v16 | v15;
        *(_DWORD *)(a3 + 24) = v7;
        ++v13;
      }
      while (v13 != 4);
    }
    else
    {
      unsigned int v7 = bswap32(*v4);
    }
    unsigned int v17 = v7 << (3 - v6);
    int v18 = v6 + 29;
    *(_DWORD *)(a3 + 28) = v18;
    *(void *)a3 = ++v4;
    v8 |= v7 >> v18;
    if (v18) {
      unsigned int v10 = v17;
    }
    else {
      unsigned int v10 = 0;
    }
    if (v18) {
      int v9 = v18;
    }
    else {
      int v9 = 0;
    }
  }
  else
  {
    unsigned int v10 = 8 * v7;
  }
  *(_DWORD *)(a3 + 24) = v10;
  *(unsigned char *)a2 = v8;
  if (v8 == 1)
  {
    if (v9 + 8 * ((int)v3 - (int)v4) <= 0)
    {
      exception = __cxa_allocate_exception(8uLL);
      int v37 = "Cannot read ppReverb.mEarlyReflectionTimeProvided";
      goto LABEL_57;
    }
    unsigned int v19 = v10 >> 31;
    int v20 = v9 - 1;
    *(_DWORD *)(a3 + 28) = v9 - 1;
    if (v9 - 1 < 0)
    {
      unint64_t v22 = *(void *)(a3 + 8);
      if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
        && v22 <= (unint64_t)v4)
      {
        unsigned int v10 = bswap32(*v4);
      }
      else
      {
        uint64_t v23 = 0;
        do
        {
          unsigned int v24 = (unsigned __int8 *)v4 + v23;
          unsigned int v25 = v10 << 8;
          *(_DWORD *)(a3 + 24) = v25;
          int v26 = 255;
          if ((unint64_t)v4 + v23 < v3 && (unint64_t)v24 >= v22) {
            int v26 = *v24;
          }
          unsigned int v10 = v26 | v25;
          *(_DWORD *)(a3 + 24) = v10;
          ++v23;
        }
        while (v23 != 4);
      }
      int v28 = v9 + 31;
      BOOL v27 = v9 == -31;
      *(_DWORD *)(a3 + 28) = v9 + 31;
      *(void *)a3 = ++v4;
      v19 |= v10 >> (v9 + 31);
      if (v9 == -31) {
        int v21 = 0;
      }
      else {
        int v21 = v10 << (1 - v9);
      }
      if (v27) {
        int v20 = 0;
      }
      else {
        int v20 = v28;
      }
    }
    else
    {
      int v21 = 2 * v10;
    }
    *(_DWORD *)(a3 + 24) = v21;
    *(unsigned char *)(a2 + 1) = v19 != 0;
    if (v19)
    {
      if (v20 + 8 * ((int)v3 - (int)v4) > 31)
      {
        *(_DWORD *)(a3 + 28) = v20 - 32;
        if (v20 - 32 < 0)
        {
          unint64_t v29 = *(void *)(a3 + 8);
          if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
            && v29 <= (unint64_t)v4)
          {
            unsigned int v30 = bswap32(*v4);
          }
          else
          {
            uint64_t v31 = 0;
            unsigned int v30 = v21;
            do
            {
              unsigned int v32 = (unsigned __int8 *)v4 + v31;
              unsigned int v33 = v30 << 8;
              *(_DWORD *)(a3 + 24) = v33;
              int v34 = 255;
              if ((unint64_t)v4 + v31 < v3 && (unint64_t)v32 >= v29) {
                int v34 = *v32;
              }
              unsigned int v30 = v34 | v33;
              *(_DWORD *)(a3 + 24) = v30;
              ++v31;
            }
            while (v31 != 4);
          }
          *(void *)a3 = v4 + 1;
          v21 |= v30 >> v20;
          unsigned int v35 = v30 << -(char)v20;
          if (!v20) {
            unsigned int v35 = 0;
          }
          *(_DWORD *)(a3 + 24) = v35;
          *(_DWORD *)(a3 + 28) = v20;
        }
        *(_DWORD *)(a2 + 4) = v21;
        return;
      }
      exception = __cxa_allocate_exception(8uLL);
      int v37 = "Cannot read ppReverb.mEarlyReflectionTime";
LABEL_57:
      void *exception = v37;
      __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
    }
  }
}

void APAC::MetadataBitStreamParser::parseRadiationPattern(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  unint64_t v4 = *(void *)(a4 + 16);
  uint64_t v5 = *(unsigned int **)a4;
  uint64_t v6 = v4 - *(void *)a4;
  int v7 = *(_DWORD *)(a4 + 28);
  if (v7 + 8 * (int)v6 <= 2)
  {
    exception = __cxa_allocate_exception(8uLL);
    unint64_t v65 = "Cannot read radPattern.mAuSMProcIndex";
    goto LABEL_103;
  }
  unsigned int v8 = *(_DWORD *)(a4 + 24);
  unsigned int v9 = v8 >> 29;
  int v10 = v7 - 3;
  *(_DWORD *)(a4 + 28) = v7 - 3;
  if (v7 - 3 < 0)
  {
    unint64_t v12 = *(void *)(a4 + 8);
    if ((v6 & ~(v6 >> 63) & 0xFFFFFFFC) == 0 || v12 > (unint64_t)v5)
    {
      uint64_t v14 = 0;
      do
      {
        unsigned int v15 = (unsigned __int8 *)v5 + v14;
        unsigned int v16 = v8 << 8;
        *(_DWORD *)(a4 + 24) = v16;
        int v17 = 255;
        if ((unint64_t)v5 + v14 < v4 && (unint64_t)v15 >= v12) {
          int v17 = *v15;
        }
        unsigned int v8 = v17 | v16;
        *(_DWORD *)(a4 + 24) = v8;
        ++v14;
      }
      while (v14 != 4);
    }
    else
    {
      unsigned int v8 = bswap32(*v5);
    }
    int v19 = v7 + 29;
    BOOL v18 = v7 == -29;
    *(_DWORD *)(a4 + 28) = v7 + 29;
    *(void *)a4 = ++v5;
    v9 |= v8 >> (v7 + 29);
    if (v7 == -29) {
      unsigned int v11 = 0;
    }
    else {
      unsigned int v11 = v8 << (3 - v7);
    }
    if (v18) {
      int v10 = 0;
    }
    else {
      int v10 = v19;
    }
  }
  else
  {
    unsigned int v11 = 8 * v8;
  }
  *(_DWORD *)(a4 + 24) = v11;
  *(unsigned char *)a2 = v9;
  switch((char)v9)
  {
    case 1:
      if (v10 + 8 * ((int)v4 - (int)v5) > 9)
      {
        unsigned int v20 = v11 >> 22;
        *(_DWORD *)(a4 + 28) = v10 - 10;
        if (v10 - 10 < 0)
        {
          unint64_t v27 = *(void *)(a4 + 8);
          if (((v4 - v5) & ~((uint64_t)(v4 - (void)v5) >> 63) & 0xFFFFFFFC) != 0
            && v27 <= (unint64_t)v5)
          {
            unsigned int v11 = bswap32(*v5);
          }
          else
          {
            uint64_t v29 = 0;
            do
            {
              unsigned int v30 = (unsigned __int8 *)v5 + v29;
              unsigned int v31 = v11 << 8;
              *(_DWORD *)(a4 + 24) = v31;
              int v32 = 255;
              if ((unint64_t)v5 + v29 < v4 && (unint64_t)v30 >= v27) {
                int v32 = *v30;
              }
              unsigned int v11 = v32 | v31;
              *(_DWORD *)(a4 + 24) = v11;
              ++v29;
            }
            while (v29 != 4);
          }
          unsigned int v33 = v11 << (10 - v10);
          int v34 = v10 + 22;
          *(_DWORD *)(a4 + 28) = v34;
          *(void *)a4 = v5 + 1;
          v20 |= v11 >> v34;
          if (v34) {
            unsigned int v21 = v33;
          }
          else {
            unsigned int v21 = 0;
          }
        }
        else
        {
          unsigned int v21 = v11 << 10;
        }
        *(_DWORD *)(a4 + 24) = v21;
        *(_WORD *)(a2 + 2) = v20;
        return;
      }
      exception = __cxa_allocate_exception(8uLL);
      unint64_t v65 = "Cannot read radPattern.mSourceType";
      goto LABEL_103;
    case 2:
      if (v10 + 8 * ((int)v4 - (int)v5) <= 1)
      {
        exception = __cxa_allocate_exception(8uLL);
        unint64_t v65 = "Cannot read radPattern.mDataLocationIndex";
        goto LABEL_103;
      }
      unsigned int v22 = v11 >> 30;
      int v23 = v10 - 2;
      *(_DWORD *)(a4 + 28) = v10 - 2;
      if (v10 - 2 < 0)
      {
        unint64_t v28 = *(void *)(a4 + 8);
        if (((v4 - v5) & ~((uint64_t)(v4 - (void)v5) >> 63) & 0xFFFFFFFC) != 0
          && v28 <= (unint64_t)v5)
        {
          unsigned int v11 = bswap32(*v5);
        }
        else
        {
          uint64_t v35 = 0;
          do
          {
            unsigned int v36 = (unsigned __int8 *)v5 + v35;
            unsigned int v37 = v11 << 8;
            *(_DWORD *)(a4 + 24) = v37;
            int v38 = 255;
            if ((unint64_t)v5 + v35 < v4 && (unint64_t)v36 >= v28) {
              int v38 = *v36;
            }
            unsigned int v11 = v38 | v37;
            *(_DWORD *)(a4 + 24) = v11;
            ++v35;
          }
          while (v35 != 4);
        }
        *(void *)a4 = ++v5;
        int v23 = v10 + 30;
        v22 |= v11 >> (v10 + 30);
        if (v10 == -30)
        {
          unsigned int v39 = 0;
          unsigned int v24 = 0;
          *(unsigned char *)(a2 + 4) = v22;
          *(void *)(a4 + 24) = 0xFFFFFFF700000000;
          goto LABEL_59;
        }
        unsigned int v24 = v11 << (2 - v10);
      }
      else
      {
        unsigned int v24 = 4 * v11;
      }
      *(unsigned char *)(a2 + 4) = v22;
      unsigned int v39 = v24 >> 23;
      int v40 = v23 - 9;
      *(_DWORD *)(a4 + 24) = v24;
      *(_DWORD *)(a4 + 28) = v23 - 9;
      if (v23 - 9 >= 0)
      {
        unsigned int v41 = v24 << 9;
        goto LABEL_69;
      }
      unint64_t v28 = *(void *)(a4 + 8);
LABEL_59:
      if (((v4 - v5) & ~((uint64_t)(v4 - (void)v5) >> 63) & 0xFFFFFFFC) != 0
        && v28 <= (unint64_t)v5)
      {
        unsigned int v24 = bswap32(*v5);
      }
      else
      {
        uint64_t v42 = 0;
        do
        {
          int v43 = (unsigned __int8 *)v5 + v42;
          unsigned int v44 = v24 << 8;
          *(_DWORD *)(a4 + 24) = v44;
          int v45 = 255;
          if ((unint64_t)v5 + v42 < v4 && (unint64_t)v43 >= v28) {
            int v45 = *v43;
          }
          unsigned int v24 = v45 | v44;
          *(_DWORD *)(a4 + 24) = v24;
          ++v42;
        }
        while (v42 != 4);
      }
      *(void *)a4 = ++v5;
      int v40 = v23 + 23;
      v39 |= v24 >> (v23 + 23);
      if (v23 == -23)
      {
        unsigned int v46 = 0;
        unsigned int v41 = 0;
        *(_WORD *)(a2 + 6) = v39;
        *(void *)(a4 + 24) = 0xFFFFFFF700000000;
        goto LABEL_73;
      }
      unsigned int v41 = v24 << (9 - v23);
LABEL_69:
      *(_WORD *)(a2 + 6) = v39;
      unsigned int v46 = v41 >> 23;
      int v47 = v40 - 9;
      *(_DWORD *)(a4 + 24) = v41;
      *(_DWORD *)(a4 + 28) = v40 - 9;
      if (v40 - 9 >= 0)
      {
        unsigned int v48 = v41 << 9;
        goto LABEL_87;
      }
      unint64_t v28 = *(void *)(a4 + 8);
LABEL_73:
      if (((v4 - v5) & ~((uint64_t)(v4 - (void)v5) >> 63) & 0xFFFFFFFC) != 0
        && v28 <= (unint64_t)v5)
      {
        unsigned int v41 = bswap32(*v5);
      }
      else
      {
        uint64_t v49 = 0;
        do
        {
          unsigned int v50 = (unsigned __int8 *)v5 + v49;
          unsigned int v51 = v41 << 8;
          *(_DWORD *)(a4 + 24) = v51;
          int v52 = 255;
          if ((unint64_t)v5 + v49 < v4 && (unint64_t)v50 >= v28) {
            int v52 = *v50;
          }
          unsigned int v41 = v52 | v51;
          *(_DWORD *)(a4 + 24) = v41;
          ++v49;
        }
        while (v49 != 4);
      }
      unsigned int v53 = v41 << (9 - v40);
      int v54 = v40 + 23;
      *(_DWORD *)(a4 + 28) = v54;
      *(void *)a4 = ++v5;
      v46 |= v41 >> v54;
      if (v54) {
        unsigned int v48 = v53;
      }
      else {
        unsigned int v48 = 0;
      }
      if (v54) {
        int v47 = v54;
      }
      else {
        int v47 = 0;
      }
LABEL_87:
      *(_DWORD *)(a4 + 24) = v48;
      *(_WORD *)(a2 + 8) = v46;
      if (v47 + 8 * ((int)v4 - (int)v5) <= 9)
      {
        exception = __cxa_allocate_exception(8uLL);
        unint64_t v65 = "Cannot read radPattern.mFallbackCustomIR.mSourceType";
LABEL_103:
        void *exception = v65;
        __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
      }
      unsigned int v55 = v48 >> 22;
      *(_DWORD *)(a4 + 28) = v47 - 10;
      if (v47 - 10 < 0)
      {
        unint64_t v57 = *(void *)(a4 + 8);
        if (((v4 - v5) & ~((uint64_t)(v4 - (void)v5) >> 63) & 0xFFFFFFFC) != 0
          && v57 <= (unint64_t)v5)
        {
          unsigned int v48 = bswap32(*v5);
        }
        else
        {
          uint64_t v58 = 0;
          do
          {
            int v59 = (unsigned __int8 *)v5 + v58;
            unsigned int v60 = v48 << 8;
            *(_DWORD *)(a4 + 24) = v60;
            int v61 = 255;
            if ((unint64_t)v5 + v58 < v4 && (unint64_t)v59 >= v57) {
              int v61 = *v59;
            }
            unsigned int v48 = v61 | v60;
            *(_DWORD *)(a4 + 24) = v48;
            ++v58;
          }
          while (v58 != 4);
        }
        unsigned int v62 = v48 << (10 - v47);
        int v63 = v47 + 22;
        *(_DWORD *)(a4 + 28) = v63;
        *(void *)a4 = v5 + 1;
        v55 |= v48 >> v63;
        if (v63) {
          unsigned int v56 = v62;
        }
        else {
          unsigned int v56 = 0;
        }
      }
      else
      {
        unsigned int v56 = v48 << 10;
      }
      *(_DWORD *)(a4 + 24) = v56;
      *(_WORD *)(a2 + 10) = v55;
      return;
    case 3:
      uint64_t v25 = a2 + 16;
      APAC::MetadataBitStreamParser::parseParametricRadiationPattern(a1, v25, a3, a4);
      return;
    case 4:
      uint64_t v26 = a2 + 176;
      APAC::MetadataBitStreamParser::parseHOADirectivityModel(a1, v26, a3, a4);
      return;
    default:
      return;
  }
}

void APAC::MetadataBitStreamParser::parseHOARenderingMatrix(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  unint64_t v4 = *(void *)(a4 + 16);
  uint64_t v5 = *(unsigned int **)a4;
  uint64_t v6 = v4 - *(void *)a4;
  int v7 = *(_DWORD *)(a4 + 28);
  if (v7 + 8 * (int)v6 <= 1)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v67 = "Cannot read matrix.mDataLocationIndex";
    goto LABEL_105;
  }
  unsigned int v10 = *(_DWORD *)(a4 + 24);
  unsigned int v11 = v10 >> 30;
  int v12 = v7 - 2;
  *(_DWORD *)(a4 + 28) = v7 - 2;
  if (v7 - 2 < 0)
  {
    unint64_t v14 = *(void *)(a4 + 8);
    if ((v6 & ~(v6 >> 63) & 0xFFFFFFFC) == 0 || v14 > (unint64_t)v5)
    {
      uint64_t v16 = 0;
      do
      {
        int v17 = (unsigned __int8 *)v5 + v16;
        unsigned int v18 = v10 << 8;
        *(_DWORD *)(a4 + 24) = v18;
        int v19 = 255;
        if ((unint64_t)v5 + v16 < v4 && (unint64_t)v17 >= v14) {
          int v19 = *v17;
        }
        unsigned int v10 = v19 | v18;
        *(_DWORD *)(a4 + 24) = v10;
        ++v16;
      }
      while (v16 != 4);
    }
    else
    {
      unsigned int v10 = bswap32(*v5);
    }
    unsigned int v20 = v10 << (2 - v7);
    int v21 = v7 + 30;
    *(_DWORD *)(a4 + 28) = v21;
    *(void *)a4 = ++v5;
    v11 |= v10 >> v21;
    if (v21) {
      unsigned int v13 = v20;
    }
    else {
      unsigned int v13 = 0;
    }
    if (v21) {
      int v12 = v21;
    }
    else {
      int v12 = 0;
    }
  }
  else
  {
    unsigned int v13 = 4 * v10;
  }
  *(_DWORD *)(a4 + 24) = v13;
  *(unsigned char *)a2 = v11;
  if (v11 == 2)
  {
LABEL_23:
    unsigned int v22 = v13 >> 23;
    int v23 = v12 - 9;
    *(_DWORD *)(a4 + 28) = v12 - 9;
    if (v12 - 9 < 0)
    {
      unint64_t v28 = *(void *)(a4 + 8);
      if (((v4 - v5) & ~((uint64_t)(v4 - (void)v5) >> 63) & 0xFFFFFFFC) != 0
        && v28 <= (unint64_t)v5)
      {
        unsigned int v13 = bswap32(*v5);
      }
      else
      {
        uint64_t v29 = 0;
        do
        {
          unsigned int v30 = (unsigned __int8 *)v5 + v29;
          unsigned int v31 = v13 << 8;
          *(_DWORD *)(a4 + 24) = v31;
          int v32 = 255;
          if ((unint64_t)v5 + v29 < v4 && (unint64_t)v30 >= v28) {
            int v32 = *v30;
          }
          unsigned int v13 = v32 | v31;
          *(_DWORD *)(a4 + 24) = v13;
          ++v29;
        }
        while (v29 != 4);
      }
      *(void *)a4 = ++v5;
      int v23 = v12 + 23;
      v22 |= v13 >> (v12 + 23);
      if (v12 == -23)
      {
        unsigned int v33 = 0;
        unsigned int v24 = 0;
        *(_WORD *)(a2 + 2) = v22;
        *(void *)(a4 + 24) = 0xFFFFFFF700000000;
        goto LABEL_45;
      }
      unsigned int v24 = v13 << (9 - v12);
    }
    else
    {
      unsigned int v24 = v13 << 9;
    }
    *(_WORD *)(a2 + 2) = v22;
    unsigned int v33 = v24 >> 23;
    *(_DWORD *)(a4 + 24) = v24;
    *(_DWORD *)(a4 + 28) = v23 - 9;
    if (v23 - 9 >= 0)
    {
      unsigned int v34 = v24 << 9;
LABEL_56:
      *(_DWORD *)(a4 + 24) = v34;
      *(_WORD *)(a2 + 4) = v33;
      return;
    }
    unint64_t v28 = *(void *)(a4 + 8);
LABEL_45:
    if (((v4 - v5) & ~((uint64_t)(v4 - (void)v5) >> 63) & 0xFFFFFFFC) != 0
      && v28 <= (unint64_t)v5)
    {
      unsigned int v24 = bswap32(*v5);
    }
    else
    {
      uint64_t v36 = 0;
      do
      {
        unsigned int v37 = (unsigned __int8 *)v5 + v36;
        unsigned int v38 = v24 << 8;
        *(_DWORD *)(a4 + 24) = v38;
        int v39 = 255;
        if ((unint64_t)v5 + v36 < v4 && (unint64_t)v37 >= v28) {
          int v39 = *v37;
        }
        unsigned int v24 = v39 | v38;
        *(_DWORD *)(a4 + 24) = v24;
        ++v36;
      }
      while (v36 != 4);
    }
    *(_DWORD *)(a4 + 28) = v23 + 23;
    *(void *)a4 = v5 + 1;
    v33 |= v24 >> (v23 + 23);
    if (v23 == -23) {
      unsigned int v34 = 0;
    }
    else {
      unsigned int v34 = v24 << (9 - v23);
    }
    goto LABEL_56;
  }
  if (v11 == 1)
  {
    if (v12 + 8 * ((int)v4 - (int)v5) <= 3)
    {
      exception = __cxa_allocate_exception(8uLL);
      int v67 = "Cannot read matrix.mHOAOrder";
    }
    else
    {
      unsigned int v25 = v13 >> 28;
      int v26 = v12 - 4;
      *(_DWORD *)(a4 + 28) = v12 - 4;
      if (v12 - 4 < 0)
      {
        unint64_t v35 = *(void *)(a4 + 8);
        if (((v4 - v5) & ~((uint64_t)(v4 - (void)v5) >> 63) & 0xFFFFFFFC) != 0
          && v35 <= (unint64_t)v5)
        {
          unsigned int v13 = bswap32(*v5);
        }
        else
        {
          uint64_t v40 = 0;
          do
          {
            unsigned int v41 = (unsigned __int8 *)v5 + v40;
            unsigned int v42 = v13 << 8;
            *(_DWORD *)(a4 + 24) = v42;
            int v43 = 255;
            if ((unint64_t)v5 + v40 < v4 && (unint64_t)v41 >= v35) {
              int v43 = *v41;
            }
            unsigned int v13 = v43 | v42;
            *(_DWORD *)(a4 + 24) = v13;
            ++v40;
          }
          while (v40 != 4);
        }
        int v45 = v12 + 28;
        BOOL v44 = v12 == -28;
        *(_DWORD *)(a4 + 28) = v12 + 28;
        *(void *)a4 = ++v5;
        v25 |= v13 >> (v12 + 28);
        if (v12 == -28) {
          int v27 = 0;
        }
        else {
          int v27 = v13 << (4 - v12);
        }
        if (v44) {
          int v26 = 0;
        }
        else {
          int v26 = v45;
        }
      }
      else
      {
        int v27 = 16 * v13;
      }
      *(_DWORD *)(a4 + 24) = v27;
      *(unsigned char *)(a2 + 6) = v25;
      if (v26 + 8 * ((int)v4 - (int)v5) <= 31)
      {
        exception = __cxa_allocate_exception(8uLL);
        int v67 = "Cannot read matrix.mChannelLayoutTag";
      }
      else
      {
        *(_DWORD *)(a4 + 28) = v26 - 32;
        if (v26 - 32 < 0)
        {
          unint64_t v47 = *(void *)(a4 + 8);
          if (((v4 - v5) & ~((uint64_t)(v4 - (void)v5) >> 63) & 0xFFFFFFFC) != 0
            && v47 <= (unint64_t)v5)
          {
            unsigned int v48 = bswap32(*v5);
          }
          else
          {
            uint64_t v49 = 0;
            unsigned int v48 = v27;
            do
            {
              unsigned int v50 = (unsigned __int8 *)v5 + v49;
              unsigned int v51 = v48 << 8;
              *(_DWORD *)(a4 + 24) = v51;
              int v52 = 255;
              if ((unint64_t)v5 + v49 < v4 && (unint64_t)v50 >= v47) {
                int v52 = *v50;
              }
              unsigned int v48 = v52 | v51;
              *(_DWORD *)(a4 + 24) = v48;
              ++v49;
            }
            while (v49 != 4);
          }
          *(void *)a4 = ++v5;
          int v46 = (v48 >> v26) | v27;
          int v27 = v48 << -(char)v26;
          if (!v26) {
            int v27 = 0;
          }
          *(_DWORD *)(a4 + 24) = v27;
          *(_DWORD *)(a4 + 28) = v26;
        }
        else
        {
          v26 -= 32;
          int v46 = v27;
        }
        *(_DWORD *)(a2 + 8) = v46;
        uint64_t v53 = (v25 + 1) * (v25 + 1);
        uint64_t v54 = (unsigned __int16)v46;
        if (a3)
        {
          std::vector<float>::resize((char **)(a2 + 16), (unsigned __int16)v46 * v53);
          int v27 = *(_DWORD *)(a4 + 24);
          int v26 = *(_DWORD *)(a4 + 28);
          uint64_t v5 = *(unsigned int **)a4;
        }
        uint64_t v55 = 0;
        unint64_t v56 = *(void *)(a4 + 16);
        while (!v54)
        {
LABEL_102:
          if (++v55 == v53) {
            return;
          }
        }
        uint64_t v57 = 0;
        unint64_t v58 = *(void *)(a4 + 8);
        uint64_t v59 = *(void *)(a2 + 16);
        while (v26 + 8 * ((int)v56 - (int)v5) > 31)
        {
          *(_DWORD *)(a4 + 28) = v26 - 32;
          if (v26 - 32 < 0)
          {
            if (((v56 - v5) & ~((uint64_t)(v56 - (void)v5) >> 63) & 0xFFFFFFFC) != 0
              && v58 <= (unint64_t)v5)
            {
              unsigned int v61 = bswap32(*v5);
            }
            else
            {
              uint64_t v62 = 0;
              unsigned int v61 = v27;
              do
              {
                int v63 = (unsigned __int8 *)v5 + v62;
                unsigned int v64 = v61 << 8;
                *(_DWORD *)(a4 + 24) = v64;
                int v65 = 255;
                if ((unint64_t)v5 + v62 < v56 && (unint64_t)v63 >= v58) {
                  int v65 = *v63;
                }
                unsigned int v61 = v65 | v64;
                *(_DWORD *)(a4 + 24) = v61;
                ++v62;
              }
              while (v62 != 4);
            }
            *(void *)a4 = ++v5;
            int v60 = (v61 >> v26) | v27;
            int v27 = v61 << -(char)v26;
            if (!v26) {
              int v27 = 0;
            }
            *(_DWORD *)(a4 + 24) = v27;
            *(_DWORD *)(a4 + 28) = v26;
          }
          else
          {
            v26 -= 32;
            int v60 = v27;
          }
          *(_DWORD *)(v59 + 4 * (v57 + v55 * v54)) = v60;
          if (++v57 == v54) {
            goto LABEL_102;
          }
        }
        exception = __cxa_allocate_exception(8uLL);
        int v67 = "Cannot read matrix.mCoeff[idx]";
      }
    }
LABEL_105:
    void *exception = v67;
    __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
  }
  if (!(_BYTE)v11) {
    goto LABEL_23;
  }
}

void APAC::MetadataBitStreamParser::parsePropagationDelay(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 16);
  unint64_t v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 1)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v39 = "Cannot read propDelay.mProcessingIndex";
    goto LABEL_58;
  }
  unsigned int v7 = *(_DWORD *)(a3 + 24);
  unsigned int v8 = v7 >> 30;
  int v9 = v6 - 2;
  *(_DWORD *)(a3 + 28) = v6 - 2;
  if (v6 - 2 < 0)
  {
    unint64_t v11 = *(void *)(a3 + 8);
    if ((v5 & ~(v5 >> 63) & 0xFFFFFFFC) == 0 || v11 > (unint64_t)v4)
    {
      uint64_t v13 = 0;
      do
      {
        unint64_t v14 = (unsigned __int8 *)v4 + v13;
        unsigned int v15 = v7 << 8;
        *(_DWORD *)(a3 + 24) = v15;
        int v16 = 255;
        if ((unint64_t)v4 + v13 < v3 && (unint64_t)v14 >= v11) {
          int v16 = *v14;
        }
        unsigned int v7 = v16 | v15;
        *(_DWORD *)(a3 + 24) = v7;
        ++v13;
      }
      while (v13 != 4);
    }
    else
    {
      unsigned int v7 = bswap32(*v4);
    }
    unsigned int v17 = v7 << (2 - v6);
    int v18 = v6 + 30;
    *(_DWORD *)(a3 + 28) = v18;
    *(void *)a3 = ++v4;
    v8 |= v7 >> v18;
    if (v18) {
      unsigned int v10 = v17;
    }
    else {
      unsigned int v10 = 0;
    }
    if (v18) {
      int v9 = v18;
    }
    else {
      int v9 = 0;
    }
  }
  else
  {
    unsigned int v10 = 4 * v7;
  }
  *(_DWORD *)(a3 + 24) = v10;
  *(unsigned char *)a2 = v8;
  if ((_BYTE)v8)
  {
    if (v9 + 8 * ((int)v3 - (int)v4) <= 0)
    {
      exception = __cxa_allocate_exception(8uLL);
      int v39 = "Cannot read propDelay.mSpeedOfSoundProvided";
      goto LABEL_58;
    }
    unsigned int v19 = v10 >> 31;
    int v20 = v9 - 1;
    *(_DWORD *)(a3 + 28) = v9 - 1;
    if (v9 - 1 < 0)
    {
      unint64_t v22 = *(void *)(a3 + 8);
      if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
        && v22 <= (unint64_t)v4)
      {
        unsigned int v10 = bswap32(*v4);
      }
      else
      {
        uint64_t v23 = 0;
        do
        {
          unsigned int v24 = (unsigned __int8 *)v4 + v23;
          unsigned int v25 = v10 << 8;
          *(_DWORD *)(a3 + 24) = v25;
          int v26 = 255;
          if ((unint64_t)v4 + v23 < v3 && (unint64_t)v24 >= v22) {
            int v26 = *v24;
          }
          unsigned int v10 = v26 | v25;
          *(_DWORD *)(a3 + 24) = v10;
          ++v23;
        }
        while (v23 != 4);
      }
      unsigned int v27 = v10 << (1 - v9);
      int v28 = v9 + 31;
      *(_DWORD *)(a3 + 28) = v28;
      *(void *)a3 = ++v4;
      v19 |= v10 >> v28;
      if (v28) {
        unsigned int v21 = v27;
      }
      else {
        unsigned int v21 = 0;
      }
      if (v28) {
        int v20 = v28;
      }
      else {
        int v20 = 0;
      }
    }
    else
    {
      unsigned int v21 = 2 * v10;
    }
    *(_DWORD *)(a3 + 24) = v21;
    *(unsigned char *)(a2 + 1) = v19 != 0;
    if (v19)
    {
      if (v20 + 8 * ((int)v3 - (int)v4) > 15)
      {
        unsigned int v29 = HIWORD(v21);
        *(_DWORD *)(a3 + 28) = v20 - 16;
        if (v20 - 16 < 0)
        {
          unint64_t v31 = *(void *)(a3 + 8);
          if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
            && v31 <= (unint64_t)v4)
          {
            unsigned int v21 = bswap32(*v4);
          }
          else
          {
            uint64_t v32 = 0;
            do
            {
              unsigned int v33 = (unsigned __int8 *)v4 + v32;
              unsigned int v34 = v21 << 8;
              *(_DWORD *)(a3 + 24) = v34;
              int v35 = 255;
              if ((unint64_t)v4 + v32 < v3 && (unint64_t)v33 >= v31) {
                int v35 = *v33;
              }
              unsigned int v21 = v35 | v34;
              *(_DWORD *)(a3 + 24) = v21;
              ++v32;
            }
            while (v32 != 4);
          }
          unsigned int v36 = v21 << (16 - v20);
          int v37 = v20 + 16;
          *(_DWORD *)(a3 + 28) = v37;
          *(void *)a3 = v4 + 1;
          v29 |= v21 >> v37;
          if (v37) {
            unsigned int v30 = v36;
          }
          else {
            unsigned int v30 = 0;
          }
        }
        else
        {
          unsigned int v30 = v21 << 16;
        }
        *(_DWORD *)(a3 + 24) = v30;
        *(_WORD *)(a2 + 2) = v29;
        return;
      }
      exception = __cxa_allocate_exception(8uLL);
      int v39 = "Cannot read propDelay.mSpeedOfSound";
LABEL_58:
      void *exception = v39;
      __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
    }
  }
}

void APAC::MetadataBitStreamParser::parseParametricRadiationPattern(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  unint64_t v4 = *(void *)(a4 + 16);
  uint64_t v5 = *(unsigned int **)a4;
  uint64_t v6 = v4 - *(void *)a4;
  int v7 = *(_DWORD *)(a4 + 28);
  if (v7 + 8 * (int)v6 <= 4)
  {
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v145 = "Cannot read parametric.mDirectivityModel";
    goto LABEL_232;
  }
  unsigned int v10 = *(_DWORD *)(a4 + 24);
  unsigned int v11 = v10 >> 27;
  int v12 = v7 - 5;
  *(_DWORD *)(a4 + 28) = v7 - 5;
  if (v7 - 5 < 0)
  {
    unint64_t v14 = *(void *)(a4 + 8);
    if ((v6 & ~(v6 >> 63) & 0xFFFFFFFC) == 0 || v14 > (unint64_t)v5)
    {
      uint64_t v16 = 0;
      do
      {
        unsigned int v17 = (unsigned __int8 *)v5 + v16;
        unsigned int v18 = v10 << 8;
        *(_DWORD *)(a4 + 24) = v18;
        int v19 = 255;
        if ((unint64_t)v5 + v16 < v4 && (unint64_t)v17 >= v14) {
          int v19 = *v17;
        }
        unsigned int v10 = v19 | v18;
        *(_DWORD *)(a4 + 24) = v10;
        ++v16;
      }
      while (v16 != 4);
    }
    else
    {
      unsigned int v10 = bswap32(*v5);
    }
    int v21 = v7 + 27;
    BOOL v20 = v7 == -27;
    *(_DWORD *)(a4 + 28) = v7 + 27;
    *(void *)a4 = ++v5;
    v11 |= v10 >> (v7 + 27);
    if (v7 == -27) {
      unsigned int v13 = 0;
    }
    else {
      unsigned int v13 = v10 << (5 - v7);
    }
    if (v20) {
      int v12 = 0;
    }
    else {
      int v12 = v21;
    }
  }
  else
  {
    unsigned int v13 = 32 * v10;
  }
  *(_DWORD *)(a4 + 24) = v13;
  *(unsigned char *)a2 = v11;
  switch((char)v11)
  {
    case 0:
      return;
    case 1:
      unsigned int v22 = v13 >> 14;
      *(_DWORD *)(a4 + 28) = v12 - 18;
      if (v12 - 18 < 0)
      {
        unint64_t v33 = *(void *)(a4 + 8);
        if (((v4 - v5) & ~((uint64_t)(v4 - (void)v5) >> 63) & 0xFFFFFFFC) != 0
          && v33 <= (unint64_t)v5)
        {
          unsigned int v13 = bswap32(*v5);
        }
        else
        {
          uint64_t v81 = 0;
          do
          {
            unsigned int v82 = (unsigned __int8 *)v5 + v81;
            unsigned int v83 = v13 << 8;
            *(_DWORD *)(a4 + 24) = v83;
            int v84 = 255;
            if ((unint64_t)v5 + v81 < v4 && (unint64_t)v82 >= v33) {
              int v84 = *v82;
            }
            unsigned int v13 = v84 | v83;
            *(_DWORD *)(a4 + 24) = v13;
            ++v81;
          }
          while (v81 != 4);
        }
        unsigned int v85 = v13 << (18 - v12);
        int v86 = v12 + 14;
        *(_DWORD *)(a4 + 28) = v86;
        *(void *)a4 = v5 + 1;
        v22 |= v13 >> v86;
        if (v86) {
          unsigned int v23 = v85;
        }
        else {
          unsigned int v23 = 0;
        }
      }
      else
      {
        unsigned int v23 = v13 << 18;
      }
      *(_DWORD *)(a4 + 24) = v23;
      unint64_t v87 = v22 + 1;
      *(_DWORD *)(a2 + 4) = v87;
      if (a3)
      {
        std::vector<unsigned int>::resize((std::vector<int> *)(a2 + 8), v22 + 1);
        std::vector<float>::resize((char **)(a2 + 32), v87);
        std::vector<float>::resize((char **)(a2 + 56), v87);
      }
      if (!v87) {
        return;
      }
      uint64_t v88 = 0;
      unsigned int v90 = *(_DWORD *)(a4 + 24);
      int v89 = *(_DWORD *)(a4 + 28);
      unint64_t v92 = *(void *)(a4 + 8);
      unint64_t v91 = *(void *)(a4 + 16);
      unsigned int v93 = *(unsigned int **)a4;
      uint64_t v94 = *(void *)(a2 + 8);
      uint64_t v95 = *(void *)(a2 + 32);
      uint64_t v96 = *(void *)(a2 + 56);
      while (1)
      {
        if (v89 + 8 * ((int)v91 - (int)v93) <= 17) {
          goto LABEL_225;
        }
        unsigned int v97 = v90 >> 14;
        *(_DWORD *)(a4 + 28) = v89 - 18;
        if (v89 - 18 < 0)
        {
          if (((v91 - v93) & ~((uint64_t)(v91 - (void)v93) >> 63) & 0xFFFFFFFC) != 0
            && v92 <= (unint64_t)v93)
          {
            unsigned int v90 = bswap32(*v93);
          }
          else
          {
            uint64_t v98 = 0;
            do
            {
              unint64_t v99 = (unsigned __int8 *)v93 + v98;
              unsigned int v100 = v90 << 8;
              *(_DWORD *)(a4 + 24) = v100;
              int v101 = 255;
              if ((unint64_t)v93 + v98 < v91 && (unint64_t)v99 >= v92) {
                int v101 = *v99;
              }
              unsigned int v90 = v101 | v100;
              *(_DWORD *)(a4 + 24) = v90;
              ++v98;
            }
            while (v98 != 4);
          }
          unsigned int v102 = v90 << (18 - v89);
          v89 += 14;
          *(_DWORD *)(a4 + 28) = v89;
          *(void *)a4 = ++v93;
          v97 |= v90 >> v89;
          if (v89) {
            unsigned int v90 = v102;
          }
          else {
            unsigned int v90 = 0;
          }
          if (!v89) {
            int v89 = 0;
          }
        }
        else
        {
          v90 <<= 18;
          v89 -= 18;
        }
        *(_DWORD *)(a4 + 24) = v90;
        *(_DWORD *)(v94 + 4 * v88) = v97 + 1;
        uint64_t v103 = v91 - (void)v93;
        if (v89 + 8 * ((int)v91 - (int)v93) <= 31)
        {
          exception = __cxa_allocate_exception(8uLL);
          uint64_t v145 = "Cannot read parametric.mPattern[sb]";
          goto LABEL_232;
        }
        *(_DWORD *)(a4 + 28) = v89 - 32;
        if (v89 - 32 < 0)
        {
          if ((v103 & ~(v103 >> 63) & 0xFFFFFFFC) != 0 && v92 <= (unint64_t)v93)
          {
            unsigned int v106 = bswap32(*v93);
          }
          else
          {
            uint64_t v107 = 0;
            unsigned int v106 = v90;
            do
            {
              unsigned int v108 = (unsigned __int8 *)v93 + v107;
              unsigned int v109 = v106 << 8;
              *(_DWORD *)(a4 + 24) = v109;
              int v110 = 255;
              if ((unint64_t)v93 + v107 < v91 && (unint64_t)v108 >= v92) {
                int v110 = *v108;
              }
              unsigned int v106 = v110 | v109;
              *(_DWORD *)(a4 + 24) = v106;
              ++v107;
            }
            while (v107 != 4);
          }
          *(void *)a4 = ++v93;
          int v105 = (v106 >> v89) | v90;
          unsigned int v90 = v106 << -(char)v89;
          if (!v89) {
            unsigned int v90 = 0;
          }
          *(_DWORD *)(a4 + 24) = v90;
          *(_DWORD *)(a4 + 28) = v89;
          uint64_t v103 = v91 - (void)v93;
          int v104 = 8 * (v91 - v93);
        }
        else
        {
          int v104 = 8 * v103;
          v89 -= 32;
          int v105 = v90;
        }
        *(_DWORD *)(v95 + 4 * v88) = v105;
        if (v104 + v89 <= 31) {
          break;
        }
        *(_DWORD *)(a4 + 28) = v89 - 32;
        if (v89 - 32 < 0)
        {
          if ((v103 & ~(v103 >> 63) & 0xFFFFFFFC) != 0 && v92 <= (unint64_t)v93)
          {
            unsigned int v112 = bswap32(*v93);
          }
          else
          {
            uint64_t v113 = 0;
            unsigned int v112 = v90;
            do
            {
              uint64_t v114 = (unsigned __int8 *)v93 + v113;
              unsigned int v115 = v112 << 8;
              *(_DWORD *)(a4 + 24) = v115;
              int v116 = 255;
              if ((unint64_t)v93 + v113 < v91 && (unint64_t)v114 >= v92) {
                int v116 = *v114;
              }
              unsigned int v112 = v116 | v115;
              *(_DWORD *)(a4 + 24) = v112;
              ++v113;
            }
            while (v113 != 4);
          }
          *(void *)a4 = ++v93;
          int v111 = (v112 >> v89) | v90;
          unsigned int v90 = v112 << -(char)v89;
          if (!v89) {
            unsigned int v90 = 0;
          }
          *(_DWORD *)(a4 + 24) = v90;
          *(_DWORD *)(a4 + 28) = v89;
        }
        else
        {
          v89 -= 32;
          int v111 = v90;
        }
        *(_DWORD *)(v96 + 4 * v88++) = v111;
        if (v88 == v87) {
          return;
        }
      }
      exception = __cxa_allocate_exception(8uLL);
      uint64_t v145 = "Cannot read parametric.mSharpness[sb]";
      goto LABEL_232;
    case 2:
      unsigned int v24 = v13 >> 14;
      *(_DWORD *)(a4 + 28) = v12 - 18;
      if (v12 - 18 < 0)
      {
        unint64_t v32 = *(void *)(a4 + 8);
        if (((v4 - v5) & ~((uint64_t)(v4 - (void)v5) >> 63) & 0xFFFFFFFC) != 0
          && v32 <= (unint64_t)v5)
        {
          unsigned int v13 = bswap32(*v5);
        }
        else
        {
          uint64_t v38 = 0;
          do
          {
            int v39 = (unsigned __int8 *)v5 + v38;
            unsigned int v40 = v13 << 8;
            *(_DWORD *)(a4 + 24) = v40;
            int v41 = 255;
            if ((unint64_t)v5 + v38 < v4 && (unint64_t)v39 >= v32) {
              int v41 = *v39;
            }
            unsigned int v13 = v41 | v40;
            *(_DWORD *)(a4 + 24) = v13;
            ++v38;
          }
          while (v38 != 4);
        }
        unsigned int v42 = v13 << (18 - v12);
        int v43 = v12 + 14;
        *(_DWORD *)(a4 + 28) = v43;
        *(void *)a4 = v5 + 1;
        v24 |= v13 >> v43;
        if (v43) {
          unsigned int v25 = v42;
        }
        else {
          unsigned int v25 = 0;
        }
      }
      else
      {
        unsigned int v25 = v13 << 18;
      }
      *(_DWORD *)(a4 + 24) = v25;
      unint64_t v44 = v24 + 1;
      *(_DWORD *)(a2 + 4) = v44;
      if (a3)
      {
        std::vector<unsigned int>::resize((std::vector<int> *)(a2 + 8), v24 + 1);
        std::vector<float>::resize((char **)(a2 + 80), v44);
        std::vector<float>::resize((char **)(a2 + 104), v44);
        std::vector<float>::resize((char **)(a2 + 128), v44);
      }
      if (!v44) {
        return;
      }
      uint64_t v45 = 0;
      unsigned int v46 = *(_DWORD *)(a4 + 24);
      int v47 = *(_DWORD *)(a4 + 28);
      unint64_t v49 = *(void *)(a4 + 8);
      unint64_t v48 = *(void *)(a4 + 16);
      unsigned int v50 = *(unsigned int **)a4;
      uint64_t v51 = *(void *)(a2 + 8);
      uint64_t v52 = *(void *)(a2 + 80);
      uint64_t v53 = *(void *)(a2 + 104);
      uint64_t v54 = *(void *)(a2 + 128);
      do
      {
        if (v47 + 8 * ((int)v48 - (int)v50) <= 17)
        {
LABEL_225:
          exception = __cxa_allocate_exception(8uLL);
          uint64_t v145 = "Cannot read parametric.mFrequencyForTheSubband[sb]";
          goto LABEL_232;
        }
        unsigned int v55 = v46 >> 14;
        *(_DWORD *)(a4 + 28) = v47 - 18;
        if (v47 - 18 < 0)
        {
          if (((v48 - v50) & ~((uint64_t)(v48 - (void)v50) >> 63) & 0xFFFFFFFC) != 0
            && v49 <= (unint64_t)v50)
          {
            unsigned int v46 = bswap32(*v50);
          }
          else
          {
            uint64_t v56 = 0;
            do
            {
              uint64_t v57 = (unsigned __int8 *)v50 + v56;
              unsigned int v58 = v46 << 8;
              *(_DWORD *)(a4 + 24) = v58;
              int v59 = 255;
              if ((unint64_t)v50 + v56 < v48 && (unint64_t)v57 >= v49) {
                int v59 = *v57;
              }
              unsigned int v46 = v59 | v58;
              *(_DWORD *)(a4 + 24) = v46;
              ++v56;
            }
            while (v56 != 4);
          }
          unsigned int v60 = v46 << (18 - v47);
          v47 += 14;
          *(_DWORD *)(a4 + 28) = v47;
          *(void *)a4 = ++v50;
          v55 |= v46 >> v47;
          if (v47) {
            unsigned int v46 = v60;
          }
          else {
            unsigned int v46 = 0;
          }
          if (!v47) {
            int v47 = 0;
          }
        }
        else
        {
          v46 <<= 18;
          v47 -= 18;
        }
        *(_DWORD *)(a4 + 24) = v46;
        *(_DWORD *)(v51 + 4 * v45) = v55 + 1;
        uint64_t v61 = v48 - (void)v50;
        if (v47 + 8 * ((int)v48 - (int)v50) <= 31)
        {
          exception = __cxa_allocate_exception(8uLL);
          uint64_t v145 = "Cannot read parametric.mInnerAngle[sb]";
          goto LABEL_232;
        }
        *(_DWORD *)(a4 + 28) = v47 - 32;
        if (v47 - 32 < 0)
        {
          if ((v61 & ~(v61 >> 63) & 0xFFFFFFFC) != 0 && v49 <= (unint64_t)v50)
          {
            unsigned int v64 = bswap32(*v50);
          }
          else
          {
            uint64_t v65 = 0;
            unsigned int v64 = v46;
            do
            {
              uint64_t v66 = (unsigned __int8 *)v50 + v65;
              unsigned int v67 = v64 << 8;
              *(_DWORD *)(a4 + 24) = v67;
              int v68 = 255;
              if ((unint64_t)v50 + v65 < v48 && (unint64_t)v66 >= v49) {
                int v68 = *v66;
              }
              unsigned int v64 = v68 | v67;
              *(_DWORD *)(a4 + 24) = v64;
              ++v65;
            }
            while (v65 != 4);
          }
          *(void *)a4 = ++v50;
          int v63 = (v64 >> v47) | v46;
          unsigned int v46 = v64 << -(char)v47;
          if (!v47) {
            unsigned int v46 = 0;
          }
          *(_DWORD *)(a4 + 24) = v46;
          *(_DWORD *)(a4 + 28) = v47;
          uint64_t v61 = v48 - (void)v50;
          int v62 = 8 * (v48 - v50);
        }
        else
        {
          int v62 = 8 * v61;
          v47 -= 32;
          int v63 = v46;
        }
        *(_DWORD *)(v52 + 4 * v45) = v63;
        if (v62 + v47 <= 31)
        {
          exception = __cxa_allocate_exception(8uLL);
          uint64_t v145 = "Cannot read parametric.mOuterAngle[sb]";
          goto LABEL_232;
        }
        *(_DWORD *)(a4 + 28) = v47 - 32;
        if (v47 - 32 < 0)
        {
          if ((v61 & ~(v61 >> 63) & 0xFFFFFFFC) != 0 && v49 <= (unint64_t)v50)
          {
            unsigned int v70 = bswap32(*v50);
          }
          else
          {
            uint64_t v71 = 0;
            unsigned int v70 = v46;
            do
            {
              unsigned int v72 = (unsigned __int8 *)v50 + v71;
              unsigned int v73 = v70 << 8;
              *(_DWORD *)(a4 + 24) = v73;
              int v74 = 255;
              if ((unint64_t)v50 + v71 < v48 && (unint64_t)v72 >= v49) {
                int v74 = *v72;
              }
              unsigned int v70 = v74 | v73;
              *(_DWORD *)(a4 + 24) = v70;
              ++v71;
            }
            while (v71 != 4);
          }
          *(void *)a4 = ++v50;
          int v69 = (v70 >> v47) | v46;
          unsigned int v46 = v70 << -(char)v47;
          if (!v47) {
            unsigned int v46 = 0;
          }
          *(_DWORD *)(a4 + 24) = v46;
          *(_DWORD *)(a4 + 28) = v47;
          uint64_t v61 = v48 - (void)v50;
          int v62 = 8 * (v48 - v50);
        }
        else
        {
          v47 -= 32;
          int v69 = v46;
        }
        *(_DWORD *)(v53 + 4 * v45) = v69;
        if (v62 + v47 <= 31)
        {
          exception = __cxa_allocate_exception(8uLL);
          uint64_t v145 = "Cannot read parametric.mOuterGain[sb]";
          goto LABEL_232;
        }
        *(_DWORD *)(a4 + 28) = v47 - 32;
        if (v47 - 32 < 0)
        {
          if ((v61 & ~(v61 >> 63) & 0xFFFFFFFC) != 0 && v49 <= (unint64_t)v50)
          {
            unsigned int v76 = bswap32(*v50);
          }
          else
          {
            uint64_t v77 = 0;
            unsigned int v76 = v46;
            do
            {
              int v78 = (unsigned __int8 *)v50 + v77;
              unsigned int v79 = v76 << 8;
              *(_DWORD *)(a4 + 24) = v79;
              int v80 = 255;
              if ((unint64_t)v50 + v77 < v48 && (unint64_t)v78 >= v49) {
                int v80 = *v78;
              }
              unsigned int v76 = v80 | v79;
              *(_DWORD *)(a4 + 24) = v76;
              ++v77;
            }
            while (v77 != 4);
          }
          *(void *)a4 = ++v50;
          int v75 = (v76 >> v47) | v46;
          unsigned int v46 = v76 << -(char)v47;
          if (!v47) {
            unsigned int v46 = 0;
          }
          *(_DWORD *)(a4 + 24) = v46;
          *(_DWORD *)(a4 + 28) = v47;
        }
        else
        {
          v47 -= 32;
          int v75 = v46;
        }
        *(_DWORD *)(v54 + 4 * v45++) = v75;
      }
      while (v45 != v44);
      return;
    case 3:
      uint64_t v26 = v4 - (void)v5;
      if (v12 + 8 * ((int)v4 - (int)v5) <= 31)
      {
        exception = __cxa_allocate_exception(8uLL);
        uint64_t v145 = "Cannot read parametric.mSphereRadius";
        goto LABEL_232;
      }
      *(_DWORD *)(a4 + 28) = v12 - 32;
      if (v12 - 32 < 0)
      {
        int v35 = v26 & ~(v26 >> 63);
        unint64_t v36 = *(void *)(a4 + 8);
        if ((v35 & 0xFFFFFFFC) != 0 && v36 <= (unint64_t)v5)
        {
          unsigned int v37 = bswap32(*v5);
        }
        else
        {
          uint64_t v128 = 0;
          unsigned int v37 = v13;
          do
          {
            unsigned int v129 = (unsigned __int8 *)v5 + v128;
            unsigned int v130 = v37 << 8;
            *(_DWORD *)(a4 + 24) = v130;
            int v131 = 255;
            if ((unint64_t)v5 + v128 < v4 && (unint64_t)v129 >= v36) {
              int v131 = *v129;
            }
            unsigned int v37 = v131 | v130;
            *(_DWORD *)(a4 + 24) = v37;
            ++v128;
          }
          while (v128 != 4);
        }
        *(void *)a4 = ++v5;
        int v28 = (v37 >> v12) | v13;
        unsigned int v13 = v37 << -(char)v12;
        if (!v12) {
          unsigned int v13 = 0;
        }
        *(_DWORD *)(a4 + 24) = v13;
        *(_DWORD *)(a4 + 28) = v12;
        uint64_t v26 = v4 - (void)v5;
        int v27 = 8 * (v4 - v5);
      }
      else
      {
        int v27 = 8 * v26;
        v12 -= 32;
        int v28 = v13;
      }
      *(_DWORD *)(a2 + 152) = v28;
      if (v27 + v12 <= 31)
      {
        exception = __cxa_allocate_exception(8uLL);
        uint64_t v145 = "Cannot read parametric.mCapOpeningAngle";
LABEL_232:
        void *exception = v145;
        __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
      }
      *(_DWORD *)(a4 + 28) = v12 - 32;
      if (v12 - 32 < 0)
      {
        int v132 = v26 & ~(v26 >> 63);
        unint64_t v133 = *(void *)(a4 + 8);
        if ((v132 & 0xFFFFFFFC) != 0 && v133 <= (unint64_t)v5)
        {
          unsigned int v134 = bswap32(*v5);
        }
        else
        {
          uint64_t v135 = 0;
          unsigned int v134 = v13;
          do
          {
            unint64_t v136 = (unsigned __int8 *)v5 + v135;
            unsigned int v137 = v134 << 8;
            *(_DWORD *)(a4 + 24) = v137;
            int v138 = 255;
            if ((unint64_t)v5 + v135 < v4 && (unint64_t)v136 >= v133) {
              int v138 = *v136;
            }
            unsigned int v134 = v138 | v137;
            *(_DWORD *)(a4 + 24) = v134;
            ++v135;
          }
          while (v135 != 4);
        }
        *(void *)a4 = v5 + 1;
        v13 |= v134 >> v12;
        unsigned int v139 = v134 << -(char)v12;
        if (!v12) {
          unsigned int v139 = 0;
        }
        *(_DWORD *)(a4 + 24) = v139;
        *(_DWORD *)(a4 + 28) = v12;
      }
      *(_DWORD *)(a2 + 156) = v13;
      return;
    default:
      unsigned int v29 = v13 >> 15;
      int v30 = v12 - 17;
      *(_DWORD *)(a4 + 28) = v12 - 17;
      if (v12 - 17 < 0)
      {
        unint64_t v34 = *(void *)(a4 + 8);
        if (((v4 - v5) & ~((uint64_t)(v4 - (void)v5) >> 63) & 0xFFFFFFFC) != 0
          && v34 <= (unint64_t)v5)
        {
          unsigned int v13 = bswap32(*v5);
        }
        else
        {
          uint64_t v117 = 0;
          do
          {
            int v118 = (unsigned __int8 *)v5 + v117;
            unsigned int v119 = v13 << 8;
            *(_DWORD *)(a4 + 24) = v119;
            int v120 = 255;
            if ((unint64_t)v5 + v117 < v4 && (unint64_t)v118 >= v34) {
              int v120 = *v118;
            }
            unsigned int v13 = v120 | v119;
            *(_DWORD *)(a4 + 24) = v13;
            ++v117;
          }
          while (v117 != 4);
        }
        int v122 = v12 + 15;
        BOOL v121 = v12 == -15;
        *(_DWORD *)(a4 + 28) = v12 + 15;
        *(void *)a4 = ++v5;
        v29 |= v13 >> (v12 + 15);
        if (v12 == -15) {
          int v31 = 0;
        }
        else {
          int v31 = v13 << (17 - v12);
        }
        if (v121) {
          int v30 = 0;
        }
        else {
          int v30 = v122;
        }
      }
      else
      {
        int v31 = v13 << 17;
      }
      *(_DWORD *)(a4 + 24) = v31;
      int v123 = 8 * v29 + 8;
      unsigned int v124 = v123 - v30;
      if (v123 > v30)
      {
        *(void *)(a4 + 24) = 0;
        int v31 = 0;
        int v30 = 0;
        if (v124 >= 0x20)
        {
          uint64_t v5 = (unsigned int *)((char *)v5 + ((v124 >> 3) & 0x1FFFFFFC));
          *(void *)a4 = v5;
          int v123 = v124 & 0x1F;
        }
        else
        {
          int v123 = v124;
        }
      }
      if ((v123 - 33) >= 0xFFFFFFE0)
      {
        int v125 = v30 - v123;
        *(_DWORD *)(a4 + 28) = v30 - v123;
        if (v30 - v123 < 0)
        {
          unint64_t v127 = *(void *)(a4 + 8);
          if (((v4 - v5) & ~((uint64_t)(v4 - (void)v5) >> 63) & 0xFFFFFFFC) != 0
            && v127 <= (unint64_t)v5)
          {
            int v31 = bswap32(*v5);
          }
          else
          {
            uint64_t v140 = 0;
            do
            {
              int v141 = (unsigned __int8 *)v5 + v140;
              int v142 = v31 << 8;
              *(_DWORD *)(a4 + 24) = v142;
              int v143 = 255;
              if ((unint64_t)v5 + v140 < v4 && (unint64_t)v141 >= v127) {
                int v143 = *v141;
              }
              int v31 = v143 | v142;
              *(_DWORD *)(a4 + 24) = v31;
              ++v140;
            }
            while (v140 != 4);
          }
          *(_DWORD *)(a4 + 28) = v125 + 32;
          *(void *)a4 = v5 + 1;
          if (v125 == -32) {
            int v126 = 0;
          }
          else {
            int v126 = v31 << -(char)v125;
          }
        }
        else
        {
          int v126 = v31 << v123;
        }
        *(_DWORD *)(a4 + 24) = v126;
      }
      return;
  }
}

void APAC::MetadataBitStreamParser::parseHOADirectivityModel(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  unsigned int v7 = *(_DWORD *)(a4 + 24);
  int v6 = *(_DWORD *)(a4 + 28);
  unsigned int v8 = v7 >> 22;
  int v9 = v6 - 10;
  *(_DWORD *)(a4 + 28) = v6 - 10;
  if (v6 - 10 < 0)
  {
    unint64_t v12 = *(void *)(a4 + 8);
    unint64_t v11 = *(void *)(a4 + 16);
    unsigned int v13 = *(unsigned int **)a4;
    if (((v11 - *(_DWORD *)a4) & ~((uint64_t)(v11 - *(void *)a4) >> 63) & 0xFFFFFFFC) == 0
      || v12 > (unint64_t)v13)
    {
      uint64_t v15 = 0;
      do
      {
        uint64_t v16 = (unsigned __int8 *)v13 + v15;
        unsigned int v17 = v7 << 8;
        *(_DWORD *)(a4 + 24) = v17;
        int v18 = 255;
        if ((unint64_t)v13 + v15 < v11 && (unint64_t)v16 >= v12) {
          int v18 = *v16;
        }
        unsigned int v7 = v18 | v17;
        *(_DWORD *)(a4 + 24) = v7;
        ++v15;
      }
      while (v15 != 4);
    }
    else
    {
      unsigned int v7 = bswap32(*v13);
    }
    unsigned int v19 = v7 << (10 - v6);
    int v20 = v6 + 22;
    *(_DWORD *)(a4 + 28) = v20;
    *(void *)a4 = v13 + 1;
    v8 |= v7 >> v20;
    if (v20) {
      unsigned int v10 = v19;
    }
    else {
      unsigned int v10 = 0;
    }
    if (v20) {
      int v9 = v20;
    }
    else {
      int v9 = 0;
    }
  }
  else
  {
    unsigned int v10 = v7 << 10;
  }
  *(_DWORD *)(a4 + 24) = v10;
  BOOL v21 = __CFADD__(v8, 1);
  uint64_t v22 = v8 + 1;
  *(_WORD *)a2 = v22;
  if (v21)
  {
    if ((a3 & 1) == 0) {
      goto LABEL_45;
    }
    unint64_t v23 = 0;
    goto LABEL_44;
  }
  uint64_t v24 = 0;
  unint64_t v26 = *(void *)(a4 + 8);
  unint64_t v25 = *(void *)(a4 + 16);
  int v27 = *(unsigned int **)a4;
  int v28 = *(unsigned __int16 **)(a2 + 8);
  do
  {
    unsigned int v29 = v10 >> 19;
    *(_DWORD *)(a4 + 28) = v9 - 13;
    if (v9 - 13 < 0)
    {
      if (((v25 - v27) & ~((uint64_t)(v25 - (void)v27) >> 63) & 0xFFFFFFFC) == 0
        || v26 > (unint64_t)v27)
      {
        uint64_t v31 = 0;
        do
        {
          unint64_t v32 = (unsigned __int8 *)v27 + v31;
          unsigned int v33 = v10 << 8;
          *(_DWORD *)(a4 + 24) = v33;
          int v34 = 255;
          if ((unint64_t)v27 + v31 < v25 && (unint64_t)v32 >= v26) {
            int v34 = *v32;
          }
          unsigned int v10 = v34 | v33;
          *(_DWORD *)(a4 + 24) = v10;
          ++v31;
        }
        while (v31 != 4);
      }
      else
      {
        unsigned int v10 = bswap32(*v27);
      }
      unsigned int v35 = v10 << (13 - v9);
      v9 += 19;
      *(_DWORD *)(a4 + 28) = v9;
      *(void *)a4 = ++v27;
      v29 |= v10 >> v9;
      if (v9) {
        unsigned int v10 = v35;
      }
      else {
        unsigned int v10 = 0;
      }
      if (!v9) {
        int v9 = 0;
      }
    }
    else
    {
      v10 <<= 13;
      v9 -= 13;
    }
    *(_DWORD *)(a4 + 24) = v10;
    v28[v24++] = v29 + 1;
  }
  while (v24 != v22);
  if (a3)
  {
    LODWORD(v23) = 0;
    do
    {
      int v36 = *v28++;
      unint64_t v23 = (v23 + v36);
      --v22;
    }
    while (v22);
LABEL_44:
    std::vector<float>::resize((char **)(a2 + 32), v23);
  }
LABEL_45:
  uint64_t v37 = *(void *)(a2 + 32);
  uint64_t v38 = *(void *)(a2 + 40);
  uint64_t v39 = v38 - v37;
  if (v38 != v37)
  {
    uint64_t v40 = 0;
    unsigned int v41 = 0;
    unint64_t v42 = v39 >> 2;
    unsigned int v44 = *(_DWORD *)(a4 + 24);
    int v43 = *(_DWORD *)(a4 + 28);
    unint64_t v46 = *(void *)(a4 + 8);
    unint64_t v45 = *(void *)(a4 + 16);
    int v47 = *(unsigned int **)a4;
    do
    {
      if (v43 + 8 * ((int)v45 - (int)v47) <= 31)
      {
        exception = __cxa_allocate_exception(8uLL);
        void *exception = "Cannot read hoaModel.mCoeffs[n]";
        __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
      }
      *(_DWORD *)(a4 + 28) = v43 - 32;
      if (v43 - 32 < 0)
      {
        if (((v45 - v47) & ~((uint64_t)(v45 - (void)v47) >> 63) & 0xFFFFFFFC) != 0
          && v46 <= (unint64_t)v47)
        {
          unsigned int v49 = bswap32(*v47);
        }
        else
        {
          uint64_t v50 = 0;
          unsigned int v49 = v44;
          do
          {
            uint64_t v51 = (unsigned __int8 *)v47 + v50;
            unsigned int v52 = v49 << 8;
            *(_DWORD *)(a4 + 24) = v52;
            int v53 = 255;
            if ((unint64_t)v47 + v50 < v45 && (unint64_t)v51 >= v46) {
              int v53 = *v51;
            }
            unsigned int v49 = v53 | v52;
            *(_DWORD *)(a4 + 24) = v49;
            ++v50;
          }
          while (v50 != 4);
        }
        *(void *)a4 = ++v47;
        int v48 = (v49 >> v43) | v44;
        unsigned int v44 = v49 << -(char)v43;
        if (!v43) {
          unsigned int v44 = 0;
        }
        *(_DWORD *)(a4 + 24) = v44;
        *(_DWORD *)(a4 + 28) = v43;
      }
      else
      {
        v43 -= 32;
        int v48 = v44;
      }
      *(_DWORD *)(v37 + 4 * v40) = v48;
      uint64_t v40 = ++v41;
    }
    while (v42 > v41);
  }
}

void APAC::MetadataBitStreamParser::parseParametricReverb(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 16);
  unint64_t v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v156 = "Cannot read reverbParams.mPreDelay.mHasData";
    goto LABEL_301;
  }
  unsigned int v7 = *(_DWORD *)(a3 + 24);
  unsigned int v8 = v7 >> 31;
  int v9 = v6 - 1;
  *(_DWORD *)(a3 + 28) = v6 - 1;
  if (v6 - 1 < 0)
  {
    unint64_t v11 = *(void *)(a3 + 8);
    if ((v5 & ~(v5 >> 63) & 0xFFFFFFFC) == 0 || v11 > (unint64_t)v4)
    {
      uint64_t v13 = 0;
      do
      {
        unint64_t v14 = (unsigned __int8 *)v4 + v13;
        unsigned int v15 = v7 << 8;
        *(_DWORD *)(a3 + 24) = v15;
        int v16 = 255;
        if ((unint64_t)v4 + v13 < v3 && (unint64_t)v14 >= v11) {
          int v16 = *v14;
        }
        unsigned int v7 = v16 | v15;
        *(_DWORD *)(a3 + 24) = v7;
        ++v13;
      }
      while (v13 != 4);
    }
    else
    {
      unsigned int v7 = bswap32(*v4);
    }
    int v18 = v6 + 31;
    BOOL v17 = v6 == -31;
    *(_DWORD *)(a3 + 28) = v6 + 31;
    *(void *)a3 = ++v4;
    v8 |= v7 >> (v6 + 31);
    if (v6 == -31) {
      unsigned int v10 = 0;
    }
    else {
      unsigned int v10 = v7 << (1 - v6);
    }
    if (v17) {
      int v9 = 0;
    }
    else {
      int v9 = v18;
    }
  }
  else
  {
    unsigned int v10 = 2 * v7;
  }
  *(_DWORD *)(a3 + 24) = v10;
  *(unsigned char *)(a2 + 4) = v8 != 0;
  if (v8)
  {
    if (v9 + 8 * ((int)v3 - (int)v4) <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      int v156 = "Cannot read reverbParams.mPreDelay.mValue";
      goto LABEL_301;
    }
    *(_DWORD *)(a3 + 28) = v9 - 32;
    if (v9 - 32 < 0)
    {
      unint64_t v20 = *(void *)(a3 + 8);
      if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
        && v20 <= (unint64_t)v4)
      {
        unsigned int v21 = bswap32(*v4);
      }
      else
      {
        uint64_t v22 = 0;
        unsigned int v21 = v10;
        do
        {
          unint64_t v23 = (unsigned __int8 *)v4 + v22;
          unsigned int v24 = v21 << 8;
          *(_DWORD *)(a3 + 24) = v24;
          int v25 = 255;
          if ((unint64_t)v4 + v22 < v3 && (unint64_t)v23 >= v20) {
            int v25 = *v23;
          }
          unsigned int v21 = v25 | v24;
          *(_DWORD *)(a3 + 24) = v21;
          ++v22;
        }
        while (v22 != 4);
      }
      *(void *)a3 = ++v4;
      int v19 = (v21 >> v9) | v10;
      unsigned int v10 = v21 << -(char)v9;
      if (!v9) {
        unsigned int v10 = 0;
      }
      *(_DWORD *)(a3 + 24) = v10;
      *(_DWORD *)(a3 + 28) = v9;
    }
    else
    {
      v9 -= 32;
      int v19 = v10;
    }
    *(_DWORD *)a2 = v19;
  }
  if (v9 + 8 * ((int)v3 - (int)v4) <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v156 = "Cannot read reverbParams.mRT60.mHasData";
    goto LABEL_301;
  }
  unsigned int v26 = v10 >> 31;
  int v27 = v9 - 1;
  *(_DWORD *)(a3 + 28) = v9 - 1;
  if (v9 - 1 < 0)
  {
    unint64_t v29 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v29 <= (unint64_t)v4)
    {
      unsigned int v10 = bswap32(*v4);
    }
    else
    {
      uint64_t v30 = 0;
      do
      {
        uint64_t v31 = (unsigned __int8 *)v4 + v30;
        unsigned int v32 = v10 << 8;
        *(_DWORD *)(a3 + 24) = v32;
        int v33 = 255;
        if ((unint64_t)v4 + v30 < v3 && (unint64_t)v31 >= v29) {
          int v33 = *v31;
        }
        unsigned int v10 = v33 | v32;
        *(_DWORD *)(a3 + 24) = v10;
        ++v30;
      }
      while (v30 != 4);
    }
    unsigned int v34 = v10 << (1 - v9);
    int v35 = v9 + 31;
    *(_DWORD *)(a3 + 28) = v35;
    *(void *)a3 = ++v4;
    v26 |= v10 >> v35;
    if (v35) {
      unsigned int v28 = v34;
    }
    else {
      unsigned int v28 = 0;
    }
    if (v35) {
      int v27 = v35;
    }
    else {
      int v27 = 0;
    }
  }
  else
  {
    unsigned int v28 = 2 * v10;
  }
  *(_DWORD *)(a3 + 24) = v28;
  *(unsigned char *)(a2 + 12) = v26 != 0;
  if (v26)
  {
    if (v27 + 8 * ((int)v3 - (int)v4) <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      int v156 = "Cannot read reverbParams.mRT60.mValue";
      goto LABEL_301;
    }
    *(_DWORD *)(a3 + 28) = v27 - 32;
    if (v27 - 32 < 0)
    {
      unint64_t v37 = *(void *)(a3 + 8);
      if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
        && v37 <= (unint64_t)v4)
      {
        unsigned int v38 = bswap32(*v4);
      }
      else
      {
        uint64_t v39 = 0;
        unsigned int v38 = v28;
        do
        {
          uint64_t v40 = (unsigned __int8 *)v4 + v39;
          unsigned int v41 = v38 << 8;
          *(_DWORD *)(a3 + 24) = v41;
          int v42 = 255;
          if ((unint64_t)v4 + v39 < v3 && (unint64_t)v40 >= v37) {
            int v42 = *v40;
          }
          unsigned int v38 = v42 | v41;
          *(_DWORD *)(a3 + 24) = v38;
          ++v39;
        }
        while (v39 != 4);
      }
      *(void *)a3 = ++v4;
      int v36 = (v38 >> v27) | v28;
      unsigned int v28 = v38 << -(char)v27;
      if (!v27) {
        unsigned int v28 = 0;
      }
      *(_DWORD *)(a3 + 24) = v28;
      *(_DWORD *)(a3 + 28) = v27;
    }
    else
    {
      v27 -= 32;
      int v36 = v28;
    }
    *(_DWORD *)(a2 + 8) = v36;
  }
  if (v27 + 8 * ((int)v3 - (int)v4) <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v156 = "Cannot read reverbParams.mWetDryMix.mHasData";
    goto LABEL_301;
  }
  unsigned int v43 = v28 >> 31;
  int v44 = v27 - 1;
  *(_DWORD *)(a3 + 28) = v27 - 1;
  if (v27 - 1 < 0)
  {
    unint64_t v46 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v46 <= (unint64_t)v4)
    {
      unsigned int v28 = bswap32(*v4);
    }
    else
    {
      uint64_t v47 = 0;
      do
      {
        int v48 = (unsigned __int8 *)v4 + v47;
        unsigned int v49 = v28 << 8;
        *(_DWORD *)(a3 + 24) = v49;
        int v50 = 255;
        if ((unint64_t)v4 + v47 < v3 && (unint64_t)v48 >= v46) {
          int v50 = *v48;
        }
        unsigned int v28 = v50 | v49;
        *(_DWORD *)(a3 + 24) = v28;
        ++v47;
      }
      while (v47 != 4);
    }
    unsigned int v51 = v28 << (1 - v27);
    int v52 = v27 + 31;
    *(_DWORD *)(a3 + 28) = v52;
    *(void *)a3 = ++v4;
    v43 |= v28 >> v52;
    if (v52) {
      unsigned int v45 = v51;
    }
    else {
      unsigned int v45 = 0;
    }
    if (v52) {
      int v44 = v52;
    }
    else {
      int v44 = 0;
    }
  }
  else
  {
    unsigned int v45 = 2 * v28;
  }
  *(_DWORD *)(a3 + 24) = v45;
  *(unsigned char *)(a2 + 20) = v43 != 0;
  if (v43)
  {
    if (v44 + 8 * ((int)v3 - (int)v4) <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      int v156 = "Cannot read reverbParams.mWetDryMix.mValue";
      goto LABEL_301;
    }
    *(_DWORD *)(a3 + 28) = v44 - 32;
    if (v44 - 32 < 0)
    {
      unint64_t v54 = *(void *)(a3 + 8);
      if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
        && v54 <= (unint64_t)v4)
      {
        unsigned int v55 = bswap32(*v4);
      }
      else
      {
        uint64_t v56 = 0;
        unsigned int v55 = v45;
        do
        {
          uint64_t v57 = (unsigned __int8 *)v4 + v56;
          unsigned int v58 = v55 << 8;
          *(_DWORD *)(a3 + 24) = v58;
          int v59 = 255;
          if ((unint64_t)v4 + v56 < v3 && (unint64_t)v57 >= v54) {
            int v59 = *v57;
          }
          unsigned int v55 = v59 | v58;
          *(_DWORD *)(a3 + 24) = v55;
          ++v56;
        }
        while (v56 != 4);
      }
      *(void *)a3 = ++v4;
      int v53 = (v55 >> v44) | v45;
      unsigned int v45 = v55 << -(char)v44;
      if (!v44) {
        unsigned int v45 = 0;
      }
      *(_DWORD *)(a3 + 24) = v45;
      *(_DWORD *)(a3 + 28) = v44;
    }
    else
    {
      v44 -= 32;
      int v53 = v45;
    }
    *(_DWORD *)(a2 + 16) = v53;
  }
  if (v44 + 8 * ((int)v3 - (int)v4) <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v156 = "Cannot read reverbParams.mReverbWidth.mHasData";
    goto LABEL_301;
  }
  unsigned int v60 = v45 >> 31;
  int v61 = v44 - 1;
  *(_DWORD *)(a3 + 28) = v44 - 1;
  if (v44 - 1 < 0)
  {
    unint64_t v63 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v63 <= (unint64_t)v4)
    {
      unsigned int v45 = bswap32(*v4);
    }
    else
    {
      uint64_t v64 = 0;
      do
      {
        uint64_t v65 = (unsigned __int8 *)v4 + v64;
        unsigned int v66 = v45 << 8;
        *(_DWORD *)(a3 + 24) = v66;
        int v67 = 255;
        if ((unint64_t)v4 + v64 < v3 && (unint64_t)v65 >= v63) {
          int v67 = *v65;
        }
        unsigned int v45 = v67 | v66;
        *(_DWORD *)(a3 + 24) = v45;
        ++v64;
      }
      while (v64 != 4);
    }
    unsigned int v68 = v45 << (1 - v44);
    int v69 = v44 + 31;
    *(_DWORD *)(a3 + 28) = v69;
    *(void *)a3 = ++v4;
    v60 |= v45 >> v69;
    if (v69) {
      unsigned int v62 = v68;
    }
    else {
      unsigned int v62 = 0;
    }
    if (v69) {
      int v61 = v69;
    }
    else {
      int v61 = 0;
    }
  }
  else
  {
    unsigned int v62 = 2 * v45;
  }
  *(_DWORD *)(a3 + 24) = v62;
  *(unsigned char *)(a2 + 28) = v60 != 0;
  if (v60)
  {
    if (v61 + 8 * ((int)v3 - (int)v4) <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      int v156 = "Cannot read reverbParams.mReverbWidth.mValue";
      goto LABEL_301;
    }
    *(_DWORD *)(a3 + 28) = v61 - 32;
    if (v61 - 32 < 0)
    {
      unint64_t v71 = *(void *)(a3 + 8);
      if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
        && v71 <= (unint64_t)v4)
      {
        unsigned int v72 = bswap32(*v4);
      }
      else
      {
        uint64_t v73 = 0;
        unsigned int v72 = v62;
        do
        {
          int v74 = (unsigned __int8 *)v4 + v73;
          unsigned int v75 = v72 << 8;
          *(_DWORD *)(a3 + 24) = v75;
          int v76 = 255;
          if ((unint64_t)v4 + v73 < v3 && (unint64_t)v74 >= v71) {
            int v76 = *v74;
          }
          unsigned int v72 = v76 | v75;
          *(_DWORD *)(a3 + 24) = v72;
          ++v73;
        }
        while (v73 != 4);
      }
      *(void *)a3 = ++v4;
      int v70 = (v72 >> v61) | v62;
      unsigned int v62 = v72 << -(char)v61;
      if (!v61) {
        unsigned int v62 = 0;
      }
      *(_DWORD *)(a3 + 24) = v62;
      *(_DWORD *)(a3 + 28) = v61;
    }
    else
    {
      v61 -= 32;
      int v70 = v62;
    }
    *(_DWORD *)(a2 + 24) = v70;
  }
  if (v61 + 8 * ((int)v3 - (int)v4) <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v156 = "Cannot read reverbParams.mHFDampingCutoffFreq.mHasData";
    goto LABEL_301;
  }
  unsigned int v77 = v62 >> 31;
  int v78 = v61 - 1;
  *(_DWORD *)(a3 + 28) = v61 - 1;
  if (v61 - 1 < 0)
  {
    unint64_t v80 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v80 <= (unint64_t)v4)
    {
      unsigned int v62 = bswap32(*v4);
    }
    else
    {
      uint64_t v81 = 0;
      do
      {
        unsigned int v82 = (unsigned __int8 *)v4 + v81;
        unsigned int v83 = v62 << 8;
        *(_DWORD *)(a3 + 24) = v83;
        int v84 = 255;
        if ((unint64_t)v4 + v81 < v3 && (unint64_t)v82 >= v80) {
          int v84 = *v82;
        }
        unsigned int v62 = v84 | v83;
        *(_DWORD *)(a3 + 24) = v62;
        ++v81;
      }
      while (v81 != 4);
    }
    int v86 = v61 + 31;
    BOOL v85 = v61 == -31;
    *(_DWORD *)(a3 + 28) = v61 + 31;
    *(void *)a3 = ++v4;
    v77 |= v62 >> (v61 + 31);
    if (v61 == -31) {
      unsigned int v79 = 0;
    }
    else {
      unsigned int v79 = v62 << (1 - v61);
    }
    if (v85) {
      int v78 = 0;
    }
    else {
      int v78 = v86;
    }
  }
  else
  {
    unsigned int v79 = 2 * v62;
  }
  *(_DWORD *)(a3 + 24) = v79;
  *(unsigned char *)(a2 + 36) = v77 != 0;
  if (v77)
  {
    if (v78 + 8 * ((int)v3 - (int)v4) <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      int v156 = "Cannot read reverbParams.mHFDampingCutoffFreq.mValue";
      goto LABEL_301;
    }
    *(_DWORD *)(a3 + 28) = v78 - 32;
    if (v78 - 32 < 0)
    {
      unint64_t v88 = *(void *)(a3 + 8);
      if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
        && v88 <= (unint64_t)v4)
      {
        unsigned int v89 = bswap32(*v4);
      }
      else
      {
        uint64_t v90 = 0;
        unsigned int v89 = v79;
        do
        {
          unint64_t v91 = (unsigned __int8 *)v4 + v90;
          unsigned int v92 = v89 << 8;
          *(_DWORD *)(a3 + 24) = v92;
          int v93 = 255;
          if ((unint64_t)v4 + v90 < v3 && (unint64_t)v91 >= v88) {
            int v93 = *v91;
          }
          unsigned int v89 = v93 | v92;
          *(_DWORD *)(a3 + 24) = v89;
          ++v90;
        }
        while (v90 != 4);
      }
      *(void *)a3 = ++v4;
      int v87 = (v89 >> v78) | v79;
      unsigned int v79 = v89 << -(char)v78;
      if (!v78) {
        unsigned int v79 = 0;
      }
      *(_DWORD *)(a3 + 24) = v79;
      *(_DWORD *)(a3 + 28) = v78;
    }
    else
    {
      v78 -= 32;
      int v87 = v79;
    }
    *(_DWORD *)(a2 + 32) = v87;
  }
  if (v78 + 8 * ((int)v3 - (int)v4) <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v156 = "Cannot read reverbParams.mEarlyReflectionOnly";
    goto LABEL_301;
  }
  unsigned int v94 = v79 >> 31;
  int v95 = v78 - 1;
  *(_DWORD *)(a3 + 28) = v78 - 1;
  if (v78 - 1 < 0)
  {
    unint64_t v97 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v97 <= (unint64_t)v4)
    {
      unsigned int v79 = bswap32(*v4);
    }
    else
    {
      uint64_t v98 = 0;
      do
      {
        unint64_t v99 = (unsigned __int8 *)v4 + v98;
        unsigned int v100 = v79 << 8;
        *(_DWORD *)(a3 + 24) = v100;
        int v101 = 255;
        if ((unint64_t)v4 + v98 < v3 && (unint64_t)v99 >= v97) {
          int v101 = *v99;
        }
        unsigned int v79 = v101 | v100;
        *(_DWORD *)(a3 + 24) = v79;
        ++v98;
      }
      while (v98 != 4);
    }
    unsigned int v102 = v79 << (1 - v78);
    int v103 = v78 + 31;
    *(_DWORD *)(a3 + 28) = v103;
    *(void *)a3 = ++v4;
    v94 |= v79 >> v103;
    if (v103) {
      unsigned int v96 = v102;
    }
    else {
      unsigned int v96 = 0;
    }
    if (v103) {
      int v95 = v103;
    }
    else {
      int v95 = 0;
    }
  }
  else
  {
    unsigned int v96 = 2 * v79;
  }
  *(_DWORD *)(a3 + 24) = v96;
  *(unsigned char *)(a2 + 40) = v94 != 0;
  if (v95 + 8 * ((int)v3 - (int)v4) <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v156 = "Cannot read reverbParams.mEarlyReflectionLevel.mHasData";
    goto LABEL_301;
  }
  unsigned int v104 = v96 >> 31;
  int v105 = v95 - 1;
  *(_DWORD *)(a3 + 28) = v95 - 1;
  if (v95 - 1 < 0)
  {
    unint64_t v107 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v107 <= (unint64_t)v4)
    {
      unsigned int v96 = bswap32(*v4);
    }
    else
    {
      uint64_t v108 = 0;
      do
      {
        unsigned int v109 = (unsigned __int8 *)v4 + v108;
        unsigned int v110 = v96 << 8;
        *(_DWORD *)(a3 + 24) = v110;
        int v111 = 255;
        if ((unint64_t)v4 + v108 < v3 && (unint64_t)v109 >= v107) {
          int v111 = *v109;
        }
        unsigned int v96 = v111 | v110;
        *(_DWORD *)(a3 + 24) = v96;
        ++v108;
      }
      while (v108 != 4);
    }
    int v113 = v95 + 31;
    BOOL v112 = v95 == -31;
    *(_DWORD *)(a3 + 28) = v95 + 31;
    *(void *)a3 = ++v4;
    v104 |= v96 >> (v95 + 31);
    if (v95 == -31) {
      unsigned int v106 = 0;
    }
    else {
      unsigned int v106 = v96 << (1 - v95);
    }
    if (v112) {
      int v105 = 0;
    }
    else {
      int v105 = v113;
    }
  }
  else
  {
    unsigned int v106 = 2 * v96;
  }
  *(_DWORD *)(a3 + 24) = v106;
  *(unsigned char *)(a2 + 48) = v104 != 0;
  if (v104)
  {
    if (v105 + 8 * ((int)v3 - (int)v4) <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      int v156 = "Cannot read reverbParams.mEarlyReflectionLevel.mValue";
      goto LABEL_301;
    }
    *(_DWORD *)(a3 + 28) = v105 - 32;
    if (v105 - 32 < 0)
    {
      unint64_t v115 = *(void *)(a3 + 8);
      if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
        && v115 <= (unint64_t)v4)
      {
        unsigned int v116 = bswap32(*v4);
      }
      else
      {
        uint64_t v117 = 0;
        unsigned int v116 = v106;
        do
        {
          int v118 = (unsigned __int8 *)v4 + v117;
          unsigned int v119 = v116 << 8;
          *(_DWORD *)(a3 + 24) = v119;
          int v120 = 255;
          if ((unint64_t)v4 + v117 < v3 && (unint64_t)v118 >= v115) {
            int v120 = *v118;
          }
          unsigned int v116 = v120 | v119;
          *(_DWORD *)(a3 + 24) = v116;
          ++v117;
        }
        while (v117 != 4);
      }
      *(void *)a3 = ++v4;
      int v114 = (v116 >> v105) | v106;
      unsigned int v106 = v116 << -(char)v105;
      if (!v105) {
        unsigned int v106 = 0;
      }
      *(_DWORD *)(a3 + 24) = v106;
      *(_DWORD *)(a3 + 28) = v105;
    }
    else
    {
      v105 -= 32;
      int v114 = v106;
    }
    *(_DWORD *)(a2 + 44) = v114;
  }
  if (v105 + 8 * ((int)v3 - (int)v4) <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v156 = "Cannot read reverbParams.mEarlyReflectionTime.mHasData";
    goto LABEL_301;
  }
  unsigned int v121 = v106 >> 31;
  int v122 = v105 - 1;
  *(_DWORD *)(a3 + 28) = v105 - 1;
  if (v105 - 1 < 0)
  {
    unint64_t v124 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v124 <= (unint64_t)v4)
    {
      unsigned int v106 = bswap32(*v4);
    }
    else
    {
      uint64_t v125 = 0;
      do
      {
        int v126 = (unsigned __int8 *)v4 + v125;
        unsigned int v127 = v106 << 8;
        *(_DWORD *)(a3 + 24) = v127;
        int v128 = 255;
        if ((unint64_t)v4 + v125 < v3 && (unint64_t)v126 >= v124) {
          int v128 = *v126;
        }
        unsigned int v106 = v128 | v127;
        *(_DWORD *)(a3 + 24) = v106;
        ++v125;
      }
      while (v125 != 4);
    }
    int v130 = v105 + 31;
    BOOL v129 = v105 == -31;
    *(_DWORD *)(a3 + 28) = v105 + 31;
    *(void *)a3 = ++v4;
    v121 |= v106 >> (v105 + 31);
    if (v105 == -31) {
      unsigned int v123 = 0;
    }
    else {
      unsigned int v123 = v106 << (1 - v105);
    }
    if (v129) {
      int v122 = 0;
    }
    else {
      int v122 = v130;
    }
  }
  else
  {
    unsigned int v123 = 2 * v106;
  }
  *(_DWORD *)(a3 + 24) = v123;
  *(unsigned char *)(a2 + 56) = v121 != 0;
  if (v121)
  {
    if (v122 + 8 * ((int)v3 - (int)v4) <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      int v156 = "Cannot read reverbParams.mEarlyReflectionTime.mValue";
      goto LABEL_301;
    }
    *(_DWORD *)(a3 + 28) = v122 - 32;
    if (v122 - 32 < 0)
    {
      unint64_t v132 = *(void *)(a3 + 8);
      if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
        && v132 <= (unint64_t)v4)
      {
        unsigned int v133 = bswap32(*v4);
      }
      else
      {
        uint64_t v134 = 0;
        unsigned int v133 = v123;
        do
        {
          uint64_t v135 = (unsigned __int8 *)v4 + v134;
          unsigned int v136 = v133 << 8;
          *(_DWORD *)(a3 + 24) = v136;
          int v137 = 255;
          if ((unint64_t)v4 + v134 < v3 && (unint64_t)v135 >= v132) {
            int v137 = *v135;
          }
          unsigned int v133 = v137 | v136;
          *(_DWORD *)(a3 + 24) = v133;
          ++v134;
        }
        while (v134 != 4);
      }
      *(void *)a3 = ++v4;
      int v131 = (v133 >> v122) | v123;
      unsigned int v123 = v133 << -(char)v122;
      if (!v122) {
        unsigned int v123 = 0;
      }
      *(_DWORD *)(a3 + 24) = v123;
      *(_DWORD *)(a3 + 28) = v122;
    }
    else
    {
      v122 -= 32;
      int v131 = v123;
    }
    *(_DWORD *)(a2 + 52) = v131;
  }
  if (v122 + 8 * ((int)v3 - (int)v4) <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v156 = "Cannot read reverbParams.mLateReverbLevel.mHasData";
    goto LABEL_301;
  }
  unsigned int v138 = v123 >> 31;
  int v139 = v122 - 1;
  *(_DWORD *)(a3 + 28) = v122 - 1;
  if (v122 - 1 < 0)
  {
    unint64_t v141 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v141 <= (unint64_t)v4)
    {
      unsigned int v123 = bswap32(*v4);
    }
    else
    {
      uint64_t v142 = 0;
      do
      {
        int v143 = (unsigned __int8 *)v4 + v142;
        unsigned int v144 = v123 << 8;
        *(_DWORD *)(a3 + 24) = v144;
        int v145 = 255;
        if ((unint64_t)v4 + v142 < v3 && (unint64_t)v143 >= v141) {
          int v145 = *v143;
        }
        unsigned int v123 = v145 | v144;
        *(_DWORD *)(a3 + 24) = v123;
        ++v142;
      }
      while (v142 != 4);
    }
    int v146 = v123 << (1 - v122);
    int v147 = v122 + 31;
    *(_DWORD *)(a3 + 28) = v147;
    *(void *)a3 = ++v4;
    v138 |= v123 >> v147;
    if (v147) {
      int v140 = v146;
    }
    else {
      int v140 = 0;
    }
    if (v147) {
      int v139 = v147;
    }
    else {
      int v139 = 0;
    }
  }
  else
  {
    int v140 = 2 * v123;
  }
  *(_DWORD *)(a3 + 24) = v140;
  *(unsigned char *)(a2 + 64) = v138 != 0;
  if (v138)
  {
    if (v139 + 8 * ((int)v3 - (int)v4) > 31)
    {
      *(_DWORD *)(a3 + 28) = v139 - 32;
      if (v139 - 32 < 0)
      {
        unint64_t v148 = *(void *)(a3 + 8);
        if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
          && v148 <= (unint64_t)v4)
        {
          unsigned int v149 = bswap32(*v4);
        }
        else
        {
          uint64_t v150 = 0;
          unsigned int v149 = v140;
          do
          {
            int v151 = (unsigned __int8 *)v4 + v150;
            unsigned int v152 = v149 << 8;
            *(_DWORD *)(a3 + 24) = v152;
            int v153 = 255;
            if ((unint64_t)v4 + v150 < v3 && (unint64_t)v151 >= v148) {
              int v153 = *v151;
            }
            unsigned int v149 = v153 | v152;
            *(_DWORD *)(a3 + 24) = v149;
            ++v150;
          }
          while (v150 != 4);
        }
        *(void *)a3 = v4 + 1;
        v140 |= v149 >> v139;
        unsigned int v154 = v149 << -(char)v139;
        if (!v139) {
          unsigned int v154 = 0;
        }
        *(_DWORD *)(a3 + 24) = v154;
        *(_DWORD *)(a3 + 28) = v139;
      }
      *(_DWORD *)(a2 + 60) = v140;
      return;
    }
    exception = __cxa_allocate_exception(8uLL);
    int v156 = "Cannot read reverbParams.mLateReverbLevel.mValue";
LABEL_301:
    void *exception = v156;
    __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
  }
}

{
  unint64_t v3;
  unsigned int *v4;
  uint64_t v5;
  int v6;
  unsigned int v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  unint64_t v11;
  uint64_t v13;
  unsigned __int8 *v14;
  unsigned int v15;
  int v16;
  BOOL v17;
  int v18;
  int v19;
  unint64_t v20;
  unsigned int v21;
  uint64_t v22;
  unsigned __int8 *v23;
  unsigned int v24;
  int v25;
  unsigned int v26;
  int v27;
  unsigned int v28;
  unint64_t v29;
  uint64_t v30;
  unsigned __int8 *v31;
  unsigned int v32;
  int v33;
  unsigned int v34;
  int v35;
  int v36;
  unint64_t v37;
  unsigned int v38;
  uint64_t v39;
  unsigned __int8 *v40;
  unsigned int v41;
  int v42;
  unsigned int v43;
  int v44;
  unsigned int v45;
  unint64_t v46;
  uint64_t v47;
  unsigned __int8 *v48;
  unsigned int v49;
  int v50;
  unsigned int v51;
  int v52;
  int v53;
  unint64_t v54;
  unsigned int v55;
  uint64_t v56;
  unsigned __int8 *v57;
  unsigned int v58;
  int v59;
  unsigned int v60;
  int v61;
  unsigned int v62;
  unint64_t v63;
  uint64_t v64;
  unsigned __int8 *v65;
  unsigned int v66;
  int v67;
  unsigned int v68;
  int v69;
  int v70;
  unint64_t v71;
  unsigned int v72;
  uint64_t v73;
  unsigned __int8 *v74;
  unsigned int v75;
  int v76;
  unsigned int v77;
  int v78;
  unsigned int v79;
  unint64_t v80;
  uint64_t v81;
  unsigned __int8 *v82;
  unsigned int v83;
  int v84;
  unsigned int v85;
  int v86;
  int v87;
  unint64_t v88;
  unsigned int v89;
  uint64_t v90;
  unsigned __int8 *v91;
  unsigned int v92;
  int v93;
  unsigned int v94;
  int v95;
  unsigned int v96;
  unint64_t v97;
  uint64_t v98;
  unsigned __int8 *v99;
  unsigned int v100;
  int v101;
  unsigned int v102;
  int v103;
  int v104;
  unint64_t v105;
  unsigned int v106;
  uint64_t v107;
  unsigned __int8 *v108;
  unsigned int v109;
  int v110;
  unsigned int v111;
  int v112;
  unsigned int v113;
  unint64_t v114;
  uint64_t v115;
  unsigned __int8 *v116;
  unsigned int v117;
  int v118;
  BOOL v119;
  int v120;
  unsigned int v121;
  unint64_t v122;
  uint64_t v123;
  unsigned __int8 *v124;
  unsigned int v125;
  int v126;
  unsigned int v127;
  unsigned int v128;
  int v129;
  int v130;
  unint64_t v131;
  uint64_t v132;
  unsigned __int8 *v133;
  unsigned int v134;
  int v135;
  BOOL v136;
  int v137;
  unint64_t v138;
  unsigned int v139;
  uint64_t v140;
  unsigned __int8 *v141;
  unsigned int v142;
  int v143;
  unsigned int v144;
  void *exception;
  const char *v146;

  unint64_t v3 = *(void *)(a3 + 16);
  unint64_t v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v146 = "Cannot read pR.hasPreDelay";
    goto LABEL_285;
  }
  unsigned int v7 = *(_DWORD *)(a3 + 24);
  unsigned int v8 = v7 >> 31;
  int v9 = v6 - 1;
  *(_DWORD *)(a3 + 28) = v6 - 1;
  if (v6 - 1 < 0)
  {
    unint64_t v11 = *(void *)(a3 + 8);
    if ((v5 & ~(v5 >> 63) & 0xFFFFFFFC) == 0 || v11 > (unint64_t)v4)
    {
      uint64_t v13 = 0;
      do
      {
        unint64_t v14 = (unsigned __int8 *)v4 + v13;
        unsigned int v15 = v7 << 8;
        *(_DWORD *)(a3 + 24) = v15;
        int v16 = 255;
        if ((unint64_t)v4 + v13 < v3 && (unint64_t)v14 >= v11) {
          int v16 = *v14;
        }
        unsigned int v7 = v16 | v15;
        *(_DWORD *)(a3 + 24) = v7;
        ++v13;
      }
      while (v13 != 4);
    }
    else
    {
      unsigned int v7 = bswap32(*v4);
    }
    int v18 = v6 + 31;
    BOOL v17 = v6 == -31;
    *(_DWORD *)(a3 + 28) = v6 + 31;
    *(void *)a3 = ++v4;
    v8 |= v7 >> (v6 + 31);
    if (v6 == -31) {
      unsigned int v10 = 0;
    }
    else {
      unsigned int v10 = v7 << (1 - v6);
    }
    if (v17) {
      int v9 = 0;
    }
    else {
      int v9 = v18;
    }
  }
  else
  {
    unsigned int v10 = 2 * v7;
  }
  *(_DWORD *)(a3 + 24) = v10;
  *(unsigned char *)a2 = v8 != 0;
  if (v8)
  {
    if (v9 + 8 * ((int)v3 - (int)v4) <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      int v146 = "Cannot read pR.preDelayMSec";
      goto LABEL_285;
    }
    *(_DWORD *)(a3 + 28) = v9 - 32;
    if (v9 - 32 < 0)
    {
      unint64_t v20 = *(void *)(a3 + 8);
      if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
        && v20 <= (unint64_t)v4)
      {
        unsigned int v21 = bswap32(*v4);
      }
      else
      {
        uint64_t v22 = 0;
        unsigned int v21 = v10;
        do
        {
          unint64_t v23 = (unsigned __int8 *)v4 + v22;
          unsigned int v24 = v21 << 8;
          *(_DWORD *)(a3 + 24) = v24;
          int v25 = 255;
          if ((unint64_t)v4 + v22 < v3 && (unint64_t)v23 >= v20) {
            int v25 = *v23;
          }
          unsigned int v21 = v25 | v24;
          *(_DWORD *)(a3 + 24) = v21;
          ++v22;
        }
        while (v22 != 4);
      }
      *(void *)a3 = ++v4;
      int v19 = (v21 >> v9) | v10;
      unsigned int v10 = v21 << -(char)v9;
      if (!v9) {
        unsigned int v10 = 0;
      }
      *(_DWORD *)(a3 + 24) = v10;
      *(_DWORD *)(a3 + 28) = v9;
    }
    else
    {
      v9 -= 32;
      int v19 = v10;
    }
    *(_DWORD *)(a2 + 8) = v19;
  }
  if (v9 + 8 * ((int)v3 - (int)v4) <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v146 = "Cannot read pR.hasEarlyReflectionLevel";
    goto LABEL_285;
  }
  unsigned int v26 = v10 >> 31;
  int v27 = v9 - 1;
  *(_DWORD *)(a3 + 28) = v9 - 1;
  if (v9 - 1 < 0)
  {
    unint64_t v29 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v29 <= (unint64_t)v4)
    {
      unsigned int v10 = bswap32(*v4);
    }
    else
    {
      uint64_t v30 = 0;
      do
      {
        uint64_t v31 = (unsigned __int8 *)v4 + v30;
        unsigned int v32 = v10 << 8;
        *(_DWORD *)(a3 + 24) = v32;
        int v33 = 255;
        if ((unint64_t)v4 + v30 < v3 && (unint64_t)v31 >= v29) {
          int v33 = *v31;
        }
        unsigned int v10 = v33 | v32;
        *(_DWORD *)(a3 + 24) = v10;
        ++v30;
      }
      while (v30 != 4);
    }
    unsigned int v34 = v10 << (1 - v9);
    int v35 = v9 + 31;
    *(_DWORD *)(a3 + 28) = v35;
    *(void *)a3 = ++v4;
    v26 |= v10 >> v35;
    if (v35) {
      unsigned int v28 = v34;
    }
    else {
      unsigned int v28 = 0;
    }
    if (v35) {
      int v27 = v35;
    }
    else {
      int v27 = 0;
    }
  }
  else
  {
    unsigned int v28 = 2 * v10;
  }
  *(_DWORD *)(a3 + 24) = v28;
  *(unsigned char *)(a2 + 1) = v26 != 0;
  if (v26)
  {
    if (v27 + 8 * ((int)v3 - (int)v4) <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      int v146 = "Cannot read pR.earlyReflectionLevel";
      goto LABEL_285;
    }
    *(_DWORD *)(a3 + 28) = v27 - 32;
    if (v27 - 32 < 0)
    {
      unint64_t v37 = *(void *)(a3 + 8);
      if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
        && v37 <= (unint64_t)v4)
      {
        unsigned int v38 = bswap32(*v4);
      }
      else
      {
        uint64_t v39 = 0;
        unsigned int v38 = v28;
        do
        {
          uint64_t v40 = (unsigned __int8 *)v4 + v39;
          unsigned int v41 = v38 << 8;
          *(_DWORD *)(a3 + 24) = v41;
          int v42 = 255;
          if ((unint64_t)v4 + v39 < v3 && (unint64_t)v40 >= v37) {
            int v42 = *v40;
          }
          unsigned int v38 = v42 | v41;
          *(_DWORD *)(a3 + 24) = v38;
          ++v39;
        }
        while (v39 != 4);
      }
      *(void *)a3 = ++v4;
      int v36 = (v38 >> v27) | v28;
      unsigned int v28 = v38 << -(char)v27;
      if (!v27) {
        unsigned int v28 = 0;
      }
      *(_DWORD *)(a3 + 24) = v28;
      *(_DWORD *)(a3 + 28) = v27;
    }
    else
    {
      v27 -= 32;
      int v36 = v28;
    }
    *(_DWORD *)(a2 + 12) = v36;
  }
  if (v27 + 8 * ((int)v3 - (int)v4) <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v146 = "Cannot read pR.hasRT60";
    goto LABEL_285;
  }
  unsigned int v43 = v28 >> 31;
  int v44 = v27 - 1;
  *(_DWORD *)(a3 + 28) = v27 - 1;
  if (v27 - 1 < 0)
  {
    unint64_t v46 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v46 <= (unint64_t)v4)
    {
      unsigned int v28 = bswap32(*v4);
    }
    else
    {
      uint64_t v47 = 0;
      do
      {
        int v48 = (unsigned __int8 *)v4 + v47;
        unsigned int v49 = v28 << 8;
        *(_DWORD *)(a3 + 24) = v49;
        int v50 = 255;
        if ((unint64_t)v4 + v47 < v3 && (unint64_t)v48 >= v46) {
          int v50 = *v48;
        }
        unsigned int v28 = v50 | v49;
        *(_DWORD *)(a3 + 24) = v28;
        ++v47;
      }
      while (v47 != 4);
    }
    unsigned int v51 = v28 << (1 - v27);
    int v52 = v27 + 31;
    *(_DWORD *)(a3 + 28) = v52;
    *(void *)a3 = ++v4;
    v43 |= v28 >> v52;
    if (v52) {
      unsigned int v45 = v51;
    }
    else {
      unsigned int v45 = 0;
    }
    if (v52) {
      int v44 = v52;
    }
    else {
      int v44 = 0;
    }
  }
  else
  {
    unsigned int v45 = 2 * v28;
  }
  *(_DWORD *)(a3 + 24) = v45;
  *(unsigned char *)(a2 + 2) = v43 != 0;
  if (v43)
  {
    if (v44 + 8 * ((int)v3 - (int)v4) <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      int v146 = "Cannot read pR.RT60Msec";
      goto LABEL_285;
    }
    *(_DWORD *)(a3 + 28) = v44 - 32;
    if (v44 - 32 < 0)
    {
      unint64_t v54 = *(void *)(a3 + 8);
      if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
        && v54 <= (unint64_t)v4)
      {
        unsigned int v55 = bswap32(*v4);
      }
      else
      {
        uint64_t v56 = 0;
        unsigned int v55 = v45;
        do
        {
          uint64_t v57 = (unsigned __int8 *)v4 + v56;
          unsigned int v58 = v55 << 8;
          *(_DWORD *)(a3 + 24) = v58;
          int v59 = 255;
          if ((unint64_t)v4 + v56 < v3 && (unint64_t)v57 >= v54) {
            int v59 = *v57;
          }
          unsigned int v55 = v59 | v58;
          *(_DWORD *)(a3 + 24) = v55;
          ++v56;
        }
        while (v56 != 4);
      }
      *(void *)a3 = ++v4;
      int v53 = (v55 >> v44) | v45;
      unsigned int v45 = v55 << -(char)v44;
      if (!v44) {
        unsigned int v45 = 0;
      }
      *(_DWORD *)(a3 + 24) = v45;
      *(_DWORD *)(a3 + 28) = v44;
    }
    else
    {
      v44 -= 32;
      int v53 = v45;
    }
    *(_DWORD *)(a2 + 16) = v53;
  }
  if (v44 + 8 * ((int)v3 - (int)v4) <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v146 = "Cannot read pR.hasWetDryMix";
    goto LABEL_285;
  }
  unsigned int v60 = v45 >> 31;
  int v61 = v44 - 1;
  *(_DWORD *)(a3 + 28) = v44 - 1;
  if (v44 - 1 < 0)
  {
    unint64_t v63 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v63 <= (unint64_t)v4)
    {
      unsigned int v45 = bswap32(*v4);
    }
    else
    {
      uint64_t v64 = 0;
      do
      {
        uint64_t v65 = (unsigned __int8 *)v4 + v64;
        unsigned int v66 = v45 << 8;
        *(_DWORD *)(a3 + 24) = v66;
        int v67 = 255;
        if ((unint64_t)v4 + v64 < v3 && (unint64_t)v65 >= v63) {
          int v67 = *v65;
        }
        unsigned int v45 = v67 | v66;
        *(_DWORD *)(a3 + 24) = v45;
        ++v64;
      }
      while (v64 != 4);
    }
    unsigned int v68 = v45 << (1 - v44);
    int v69 = v44 + 31;
    *(_DWORD *)(a3 + 28) = v69;
    *(void *)a3 = ++v4;
    v60 |= v45 >> v69;
    if (v69) {
      unsigned int v62 = v68;
    }
    else {
      unsigned int v62 = 0;
    }
    if (v69) {
      int v61 = v69;
    }
    else {
      int v61 = 0;
    }
  }
  else
  {
    unsigned int v62 = 2 * v45;
  }
  *(_DWORD *)(a3 + 24) = v62;
  *(unsigned char *)(a2 + 3) = v60 != 0;
  if (v60)
  {
    if (v61 + 8 * ((int)v3 - (int)v4) <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      int v146 = "Cannot read pR.wetDryMix";
      goto LABEL_285;
    }
    *(_DWORD *)(a3 + 28) = v61 - 32;
    if (v61 - 32 < 0)
    {
      unint64_t v71 = *(void *)(a3 + 8);
      if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
        && v71 <= (unint64_t)v4)
      {
        unsigned int v72 = bswap32(*v4);
      }
      else
      {
        uint64_t v73 = 0;
        unsigned int v72 = v62;
        do
        {
          int v74 = (unsigned __int8 *)v4 + v73;
          unsigned int v75 = v72 << 8;
          *(_DWORD *)(a3 + 24) = v75;
          int v76 = 255;
          if ((unint64_t)v4 + v73 < v3 && (unint64_t)v74 >= v71) {
            int v76 = *v74;
          }
          unsigned int v72 = v76 | v75;
          *(_DWORD *)(a3 + 24) = v72;
          ++v73;
        }
        while (v73 != 4);
      }
      *(void *)a3 = ++v4;
      int v70 = (v72 >> v61) | v62;
      unsigned int v62 = v72 << -(char)v61;
      if (!v61) {
        unsigned int v62 = 0;
      }
      *(_DWORD *)(a3 + 24) = v62;
      *(_DWORD *)(a3 + 28) = v61;
    }
    else
    {
      v61 -= 32;
      int v70 = v62;
    }
    *(_DWORD *)(a2 + 20) = v70;
  }
  if (v61 + 8 * ((int)v3 - (int)v4) <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v146 = "Cannot read pR.hasReverbWidth";
    goto LABEL_285;
  }
  unsigned int v77 = v62 >> 31;
  int v78 = v61 - 1;
  *(_DWORD *)(a3 + 28) = v61 - 1;
  if (v61 - 1 < 0)
  {
    unint64_t v80 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v80 <= (unint64_t)v4)
    {
      unsigned int v62 = bswap32(*v4);
    }
    else
    {
      uint64_t v81 = 0;
      do
      {
        unsigned int v82 = (unsigned __int8 *)v4 + v81;
        unsigned int v83 = v62 << 8;
        *(_DWORD *)(a3 + 24) = v83;
        int v84 = 255;
        if ((unint64_t)v4 + v81 < v3 && (unint64_t)v82 >= v80) {
          int v84 = *v82;
        }
        unsigned int v62 = v84 | v83;
        *(_DWORD *)(a3 + 24) = v62;
        ++v81;
      }
      while (v81 != 4);
    }
    BOOL v85 = v62 << (1 - v61);
    int v86 = v61 + 31;
    *(_DWORD *)(a3 + 28) = v86;
    *(void *)a3 = ++v4;
    v77 |= v62 >> v86;
    if (v86) {
      unsigned int v79 = v85;
    }
    else {
      unsigned int v79 = 0;
    }
    if (v86) {
      int v78 = v86;
    }
    else {
      int v78 = 0;
    }
  }
  else
  {
    unsigned int v79 = 2 * v62;
  }
  *(_DWORD *)(a3 + 24) = v79;
  *(unsigned char *)(a2 + 4) = v77 != 0;
  if (v77)
  {
    if (v78 + 8 * ((int)v3 - (int)v4) <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      int v146 = "Cannot read pR.reverbWidth";
      goto LABEL_285;
    }
    *(_DWORD *)(a3 + 28) = v78 - 32;
    if (v78 - 32 < 0)
    {
      unint64_t v88 = *(void *)(a3 + 8);
      if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
        && v88 <= (unint64_t)v4)
      {
        unsigned int v89 = bswap32(*v4);
      }
      else
      {
        uint64_t v90 = 0;
        unsigned int v89 = v79;
        do
        {
          unint64_t v91 = (unsigned __int8 *)v4 + v90;
          unsigned int v92 = v89 << 8;
          *(_DWORD *)(a3 + 24) = v92;
          int v93 = 255;
          if ((unint64_t)v4 + v90 < v3 && (unint64_t)v91 >= v88) {
            int v93 = *v91;
          }
          unsigned int v89 = v93 | v92;
          *(_DWORD *)(a3 + 24) = v89;
          ++v90;
        }
        while (v90 != 4);
      }
      *(void *)a3 = ++v4;
      int v87 = (v89 >> v78) | v79;
      unsigned int v79 = v89 << -(char)v78;
      if (!v78) {
        unsigned int v79 = 0;
      }
      *(_DWORD *)(a3 + 24) = v79;
      *(_DWORD *)(a3 + 28) = v78;
    }
    else
    {
      v78 -= 32;
      int v87 = v79;
    }
    *(_DWORD *)(a2 + 24) = v87;
  }
  if (v78 + 8 * ((int)v3 - (int)v4) <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v146 = "Cannot read pR.hasHighFrequencyDamping";
    goto LABEL_285;
  }
  unsigned int v94 = v79 >> 31;
  int v95 = v78 - 1;
  *(_DWORD *)(a3 + 28) = v78 - 1;
  if (v78 - 1 < 0)
  {
    unint64_t v97 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v97 <= (unint64_t)v4)
    {
      unsigned int v79 = bswap32(*v4);
    }
    else
    {
      uint64_t v98 = 0;
      do
      {
        unint64_t v99 = (unsigned __int8 *)v4 + v98;
        unsigned int v100 = v79 << 8;
        *(_DWORD *)(a3 + 24) = v100;
        int v101 = 255;
        if ((unint64_t)v4 + v98 < v3 && (unint64_t)v99 >= v97) {
          int v101 = *v99;
        }
        unsigned int v79 = v101 | v100;
        *(_DWORD *)(a3 + 24) = v79;
        ++v98;
      }
      while (v98 != 4);
    }
    unsigned int v102 = v79 << (1 - v78);
    int v103 = v78 + 31;
    *(_DWORD *)(a3 + 28) = v103;
    *(void *)a3 = ++v4;
    v94 |= v79 >> v103;
    if (v103) {
      unsigned int v96 = v102;
    }
    else {
      unsigned int v96 = 0;
    }
    if (v103) {
      int v95 = v103;
    }
    else {
      int v95 = 0;
    }
  }
  else
  {
    unsigned int v96 = 2 * v79;
  }
  *(_DWORD *)(a3 + 24) = v96;
  *(unsigned char *)(a2 + 5) = v94 != 0;
  if (v94)
  {
    if (v95 + 8 * ((int)v3 - (int)v4) <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      int v146 = "Cannot read pR.highFrequencyDamping";
      goto LABEL_285;
    }
    *(_DWORD *)(a3 + 28) = v95 - 32;
    if (v95 - 32 < 0)
    {
      int v105 = *(void *)(a3 + 8);
      if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
        && v105 <= (unint64_t)v4)
      {
        unsigned int v106 = bswap32(*v4);
      }
      else
      {
        unint64_t v107 = 0;
        unsigned int v106 = v96;
        do
        {
          uint64_t v108 = (unsigned __int8 *)v4 + v107;
          unsigned int v109 = v106 << 8;
          *(_DWORD *)(a3 + 24) = v109;
          unsigned int v110 = 255;
          if ((unint64_t)v4 + v107 < v3 && (unint64_t)v108 >= v105) {
            unsigned int v110 = *v108;
          }
          unsigned int v106 = v110 | v109;
          *(_DWORD *)(a3 + 24) = v106;
          ++v107;
        }
        while (v107 != 4);
      }
      *(void *)a3 = ++v4;
      unsigned int v104 = (v106 >> v95) | v96;
      unsigned int v96 = v106 << -(char)v95;
      if (!v95) {
        unsigned int v96 = 0;
      }
      *(_DWORD *)(a3 + 24) = v96;
      *(_DWORD *)(a3 + 28) = v95;
    }
    else
    {
      v95 -= 32;
      unsigned int v104 = v96;
    }
    *(_DWORD *)(a2 + 28) = v104;
  }
  if (v95 + 8 * ((int)v3 - (int)v4) <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v146 = "Cannot read pR.hasEarlyReflectionOnly";
    goto LABEL_285;
  }
  int v111 = v96 >> 31;
  BOOL v112 = v95 - 1;
  *(_DWORD *)(a3 + 28) = v95 - 1;
  if (v95 - 1 < 0)
  {
    int v114 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v114 <= (unint64_t)v4)
    {
      unsigned int v96 = bswap32(*v4);
    }
    else
    {
      unint64_t v115 = 0;
      do
      {
        unsigned int v116 = (unsigned __int8 *)v4 + v115;
        uint64_t v117 = v96 << 8;
        *(_DWORD *)(a3 + 24) = v117;
        int v118 = 255;
        if ((unint64_t)v4 + v115 < v3 && (unint64_t)v116 >= v114) {
          int v118 = *v116;
        }
        unsigned int v96 = v118 | v117;
        *(_DWORD *)(a3 + 24) = v96;
        ++v115;
      }
      while (v115 != 4);
    }
    int v120 = v95 + 31;
    unsigned int v119 = v95 == -31;
    *(_DWORD *)(a3 + 28) = v95 + 31;
    *(void *)a3 = ++v4;
    v111 |= v96 >> (v95 + 31);
    if (v95 == -31) {
      int v113 = 0;
    }
    else {
      int v113 = v96 << (1 - v95);
    }
    if (v119) {
      BOOL v112 = 0;
    }
    else {
      BOOL v112 = v120;
    }
  }
  else
  {
    int v113 = 2 * v96;
  }
  *(_DWORD *)(a3 + 24) = v113;
  *(unsigned char *)(a2 + 6) = v111 != 0;
  if (v111)
  {
    if (v112 + 8 * ((int)v3 - (int)v4) <= 0)
    {
      exception = __cxa_allocate_exception(8uLL);
      int v146 = "Cannot read pR.earlyReflectionOnly";
      goto LABEL_285;
    }
    unsigned int v121 = v113 >> 31;
    *(_DWORD *)(a3 + 28) = v112 - 1;
    if (v112 - 1 < 0)
    {
      int v122 = *(void *)(a3 + 8);
      if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
        && v122 <= (unint64_t)v4)
      {
        int v113 = bswap32(*v4);
      }
      else
      {
        unsigned int v123 = 0;
        do
        {
          unint64_t v124 = (unsigned __int8 *)v4 + v123;
          uint64_t v125 = v113 << 8;
          *(_DWORD *)(a3 + 24) = v125;
          int v126 = 255;
          if ((unint64_t)v4 + v123 < v3 && (unint64_t)v124 >= v122) {
            int v126 = *v124;
          }
          int v113 = v126 | v125;
          *(_DWORD *)(a3 + 24) = v113;
          ++v123;
        }
        while (v123 != 4);
      }
      unsigned int v127 = v113 << (1 - v112);
      v112 += 31;
      *(_DWORD *)(a3 + 28) = v112;
      *(void *)a3 = ++v4;
      v121 |= v113 >> v112;
      if (v112) {
        int v113 = v127;
      }
      else {
        int v113 = 0;
      }
      if (!v112) {
        BOOL v112 = 0;
      }
    }
    else
    {
      v113 *= 2;
      --v112;
    }
    *(_DWORD *)(a3 + 24) = v113;
    *(unsigned char *)(a2 + 32) = v121 != 0;
  }
  if (v112 + 8 * ((int)v3 - (int)v4) <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v146 = "Cannot read pR.hasEarlyReflectionTime";
    goto LABEL_285;
  }
  int v128 = v113 >> 31;
  BOOL v129 = v112 - 1;
  *(_DWORD *)(a3 + 28) = v112 - 1;
  if (v112 - 1 < 0)
  {
    int v131 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v131 <= (unint64_t)v4)
    {
      int v113 = bswap32(*v4);
    }
    else
    {
      unint64_t v132 = 0;
      do
      {
        unsigned int v133 = (unsigned __int8 *)v4 + v132;
        uint64_t v134 = v113 << 8;
        *(_DWORD *)(a3 + 24) = v134;
        uint64_t v135 = 255;
        if ((unint64_t)v4 + v132 < v3 && (unint64_t)v133 >= v131) {
          uint64_t v135 = *v133;
        }
        int v113 = v135 | v134;
        *(_DWORD *)(a3 + 24) = v113;
        ++v132;
      }
      while (v132 != 4);
    }
    int v137 = v112 + 31;
    unsigned int v136 = v112 == -31;
    *(_DWORD *)(a3 + 28) = v112 + 31;
    *(void *)a3 = ++v4;
    v128 |= v113 >> (v112 + 31);
    if (v112 == -31) {
      int v130 = 0;
    }
    else {
      int v130 = v113 << (1 - v112);
    }
    if (v136) {
      BOOL v129 = 0;
    }
    else {
      BOOL v129 = v137;
    }
  }
  else
  {
    int v130 = 2 * v113;
  }
  *(_DWORD *)(a3 + 24) = v130;
  *(unsigned char *)(a2 + 7) = v128 != 0;
  if (v128)
  {
    if (v129 + 8 * ((int)v3 - (int)v4) > 31)
    {
      *(_DWORD *)(a3 + 28) = v129 - 32;
      if (v129 - 32 < 0)
      {
        unsigned int v138 = *(void *)(a3 + 8);
        if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
          && v138 <= (unint64_t)v4)
        {
          int v139 = bswap32(*v4);
        }
        else
        {
          int v140 = 0;
          int v139 = v130;
          do
          {
            unint64_t v141 = (unsigned __int8 *)v4 + v140;
            uint64_t v142 = v139 << 8;
            *(_DWORD *)(a3 + 24) = v142;
            int v143 = 255;
            if ((unint64_t)v4 + v140 < v3 && (unint64_t)v141 >= v138) {
              int v143 = *v141;
            }
            int v139 = v143 | v142;
            *(_DWORD *)(a3 + 24) = v139;
            ++v140;
          }
          while (v140 != 4);
        }
        *(void *)a3 = v4 + 1;
        v130 |= v139 >> v129;
        unsigned int v144 = v139 << -(char)v129;
        if (!v129) {
          unsigned int v144 = 0;
        }
        *(_DWORD *)(a3 + 24) = v144;
        *(_DWORD *)(a3 + 28) = v129;
      }
      *(_DWORD *)(a2 + 36) = v130;
      return;
    }
    exception = __cxa_allocate_exception(8uLL);
    int v146 = "Cannot read pR.earlyReflectionTimeMsec";
LABEL_285:
    void *exception = v146;
    __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
  }
}

uint64_t APAC::MetadataBitStreamParser::parseFallbackRoomGeometry(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = 0;
  unint64_t v5 = *(void *)(a3 + 8);
  unint64_t v4 = *(void *)(a3 + 16);
  int v6 = *(unsigned int **)a3;
  unsigned int v7 = *(_DWORD *)(a3 + 24);
  int v8 = *(_DWORD *)(a3 + 28);
  do
  {
    uint64_t v9 = v4 - (void)v6;
    if (v8 + 8 * ((int)v4 - (int)v6) <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      int v44 = "Cannot read fallbackRoomGeometry.mOctaveBandRt60[n]";
      goto LABEL_76;
    }
    *(_DWORD *)(a3 + 28) = v8 - 32;
    if (v8 - 32 < 0)
    {
      if ((v9 & ~(v9 >> 63) & 0xFFFFFFFC) != 0 && v5 <= (unint64_t)v6)
      {
        unsigned int v12 = bswap32(*v6);
      }
      else
      {
        uint64_t v13 = 0;
        unsigned int v12 = v7;
        do
        {
          unint64_t v14 = (unsigned __int8 *)v6 + v13;
          unsigned int v15 = v12 << 8;
          *(_DWORD *)(a3 + 24) = v15;
          int v16 = 255;
          if ((unint64_t)v6 + v13 < v4 && (unint64_t)v14 >= v5) {
            int v16 = *v14;
          }
          unsigned int v12 = v16 | v15;
          *(_DWORD *)(a3 + 24) = v12;
          ++v13;
        }
        while (v13 != 4);
      }
      *(void *)a3 = ++v6;
      int v11 = (v12 >> v8) | v7;
      unsigned int v7 = v12 << -(char)v8;
      if (!v8) {
        unsigned int v7 = 0;
      }
      *(_DWORD *)(a3 + 24) = v7;
      *(_DWORD *)(a3 + 28) = v8;
      uint64_t v9 = v4 - (void)v6;
      int v10 = 8 * (v4 - v6);
    }
    else
    {
      int v10 = 8 * v9;
      v8 -= 32;
      int v11 = v7;
    }
    *(_DWORD *)(a2 + 4 + 4 * v3) = v11;
    if (v10 + v8 <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      int v44 = "Cannot read fallbackRoomGeometry.mOctaveBandEarlyRoomEnergy[n]";
      goto LABEL_76;
    }
    *(_DWORD *)(a3 + 28) = v8 - 32;
    if (v8 - 32 < 0)
    {
      if ((v9 & ~(v9 >> 63) & 0xFFFFFFFC) != 0 && v5 <= (unint64_t)v6)
      {
        unsigned int v18 = bswap32(*v6);
      }
      else
      {
        uint64_t v19 = 0;
        unsigned int v18 = v7;
        do
        {
          unint64_t v20 = (unsigned __int8 *)v6 + v19;
          unsigned int v21 = v18 << 8;
          *(_DWORD *)(a3 + 24) = v21;
          int v22 = 255;
          if ((unint64_t)v6 + v19 < v4 && (unint64_t)v20 >= v5) {
            int v22 = *v20;
          }
          unsigned int v18 = v22 | v21;
          *(_DWORD *)(a3 + 24) = v18;
          ++v19;
        }
        while (v19 != 4);
      }
      *(void *)a3 = ++v6;
      int v17 = (v18 >> v8) | v7;
      unsigned int v7 = v18 << -(char)v8;
      if (!v8) {
        unsigned int v7 = 0;
      }
      *(_DWORD *)(a3 + 24) = v7;
      *(_DWORD *)(a3 + 28) = v8;
      uint64_t v9 = v4 - (void)v6;
      int v10 = 8 * (v4 - v6);
    }
    else
    {
      v8 -= 32;
      int v17 = v7;
    }
    *(_DWORD *)(a2 + 44 + 4 * v3) = v17;
    if (v10 + v8 <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      int v44 = "Cannot read fallbackRoomGeometry.mOctaveBandLateRoomEnergy[n]";
      goto LABEL_76;
    }
    uint64_t result = (v8 - 32);
    *(_DWORD *)(a3 + 28) = result;
    if (v8 - 32 < 0)
    {
      if ((v9 & ~(v9 >> 63) & 0xFFFFFFFC) != 0 && v5 <= (unint64_t)v6)
      {
        uint64_t result = bswap32(*v6);
      }
      else
      {
        uint64_t v25 = 0;
        LODWORD(result) = v7;
        do
        {
          unsigned int v26 = (unsigned __int8 *)v6 + v25;
          unsigned int v27 = result << 8;
          *(_DWORD *)(a3 + 24) = v27;
          int v28 = 255;
          if ((unint64_t)v6 + v25 < v4 && (unint64_t)v26 >= v5) {
            int v28 = *v26;
          }
          uint64_t result = v28 | v27;
          *(_DWORD *)(a3 + 24) = result;
          ++v25;
        }
        while (v25 != 4);
      }
      *(void *)a3 = ++v6;
      unsigned int v24 = (result >> v8) | v7;
      unsigned int v7 = result << -(char)v8;
      if (!v8) {
        unsigned int v7 = 0;
      }
      *(_DWORD *)(a3 + 24) = v7;
      *(_DWORD *)(a3 + 28) = v8;
    }
    else
    {
      v8 -= 32;
      unsigned int v24 = v7;
    }
    *(_DWORD *)(a2 + 84 + 4 * v3++) = v24;
  }
  while (v3 != 10);
  uint64_t v29 = v4 - (void)v6;
  if (v8 + 8 * ((int)v4 - (int)v6) < 32)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v44 = "Cannot read fallbackRoomGeometry.mRoomVolume";
    goto LABEL_76;
  }
  *(_DWORD *)(a3 + 28) = v8 - 32;
  if (v8 - 32 < 0)
  {
    if ((v29 & ~(v29 >> 63) & 0xFFFFFFFC) != 0 && v5 <= (unint64_t)v6)
    {
      unsigned int v32 = bswap32(*v6);
    }
    else
    {
      uint64_t v33 = 0;
      unsigned int v32 = v7;
      do
      {
        unsigned int v34 = (unsigned __int8 *)v6 + v33;
        unsigned int v35 = v32 << 8;
        *(_DWORD *)(a3 + 24) = v35;
        int v36 = 255;
        if ((unint64_t)v6 + v33 < v4 && (unint64_t)v34 >= v5) {
          int v36 = *v34;
        }
        unsigned int v32 = v36 | v35;
        *(_DWORD *)(a3 + 24) = v32;
        ++v33;
      }
      while (v33 != 4);
    }
    *(void *)a3 = ++v6;
    int v31 = (v32 >> v8) | v7;
    unsigned int v7 = v32 << -(char)v8;
    if (!v8) {
      unsigned int v7 = 0;
    }
    *(_DWORD *)(a3 + 24) = v7;
    *(_DWORD *)(a3 + 28) = v8;
    uint64_t v29 = v4 - (void)v6;
    int v30 = 8 * (v4 - v6);
  }
  else
  {
    int v30 = 8 * v29;
    v8 -= 32;
    int v31 = v7;
  }
  *(_DWORD *)(a2 + 124) = v31;
  if (v30 + v8 <= 31)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v44 = "Cannot read fallbackRoomGeometry.mRoomSurface";
LABEL_76:
    void *exception = v44;
    __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
  }
  *(_DWORD *)(a3 + 28) = v8 - 32;
  if (v8 - 32 < 0)
  {
    if ((v29 & ~(v29 >> 63) & 0xFFFFFFFC) != 0 && v5 <= (unint64_t)v6)
    {
      unsigned int v37 = bswap32(*v6);
    }
    else
    {
      uint64_t v38 = 0;
      unsigned int v37 = v7;
      do
      {
        uint64_t v39 = (unsigned __int8 *)v6 + v38;
        unsigned int v40 = v37 << 8;
        *(_DWORD *)(a3 + 24) = v40;
        int v41 = 255;
        if ((unint64_t)v6 + v38 < v4 && (unint64_t)v39 >= v5) {
          int v41 = *v39;
        }
        unsigned int v37 = v41 | v40;
        *(_DWORD *)(a3 + 24) = v37;
        ++v38;
      }
      while (v38 != 4);
    }
    *(void *)a3 = v6 + 1;
    v7 |= v37 >> v8;
    unsigned int v42 = v37 << -(char)v8;
    if (!v8) {
      unsigned int v42 = 0;
    }
    *(_DWORD *)(a3 + 24) = v42;
    *(_DWORD *)(a3 + 28) = v8;
  }
  *(_DWORD *)(a2 + 128) = v7;
  return result;
}

void std::__destroy_at[abi:ne180100]<APAC::Metadata::GroupData,0>(uint64_t a1)
{
  v1 = (APAC::Metadata::RendererData::RadiationPattern *)(a1 + 39744);
  uint64_t v2 = -40192;
  do
  {
    uint64_t v3 = (void *)*((void *)v1 + 53);
    if (v3)
    {
      *((void *)v1 + 54) = v3;
      operator delete(v3);
    }
    APAC::Metadata::RendererData::RadiationPattern::~RadiationPattern(v1);
    v1 = (APAC::Metadata::RendererData::RadiationPattern *)((char *)v1 - 1256);
    v2 += 1256;
  }
  while (v2);
}

uint64_t std::array<APAC::Metadata::GroupData::BlockData,32ul>::array(uint64_t result)
{
  uint64_t v1 = 0;
  uint64_t v2 = 32;
  do
  {
    uint64_t v3 = result + v1;
    *(_WORD *)uint64_t v3 = 0;
    *(unsigned char *)(v3 + 2) = 0;
    *(_WORD *)(v3 + 4) = 0;
    *(unsigned char *)(v3 + 8) = 0;
    *(void *)(v3 + 80) = 0;
    *(void *)(v3 + 85) = 0;
    *(_WORD *)(v3 + 124) = 0;
    *(_DWORD *)(v3 + 180) = 0;
    *(unsigned char *)(v3 + 576) = 0;
    *(_WORD *)(v3 + 578) = 0;
    *(unsigned char *)(v3 + 580) = 0;
    unint64_t v4 = (_DWORD *)(result + v1 + 582);
    *(_DWORD *)(v3 + 728) = 0;
    *(unsigned char *)(v3 + 732) = 0;
    *(_DWORD *)(v3 + 736) = 0;
    *(unsigned char *)(v3 + 740) = 0;
    *(_DWORD *)(v3 + 744) = 0;
    *(unsigned char *)(v3 + 748) = 0;
    *(_DWORD *)(v3 + 752) = 0;
    *(unsigned char *)(v3 + 756) = 0;
    *(unsigned char *)(v3 + 760) = 0;
    *(_DWORD *)(v3 + 764) = 0;
    *(unsigned char *)(v3 + 768) = 0;
    *(_DWORD *)(v3 + 772) = 0;
    *(unsigned char *)(v3 + 776) = 0;
    *(_DWORD *)(v3 + 780) = 0;
    *(unsigned char *)(v3 + 784) = 0;
    *(_DWORD *)((char *)v4 + 3) = 0;
    *unint64_t v4 = 0;
    *(void *)(v3 + 712) = 0;
    *(void *)(result + v1 + 717) = 0;
    *(_WORD *)(v3 + 788) = 0;
    *(_DWORD *)(v3 + 792) = 0;
    *(unsigned char *)(v3 + 800) = 0;
    *(_WORD *)(v3 + 802) = 0;
    *(unsigned char *)(v3 + 804) = 0;
    *(_DWORD *)(result + v1 + 806) = 0;
    *(_WORD *)(v3 + 810) = 0;
    *(unsigned char *)(v3 + 816) = 0;
    unint64_t v5 = (_OWORD *)(result + v1 + 820);
    int v6 = (_OWORD *)(result + v1 + 984);
    *unint64_t v5 = 0uLL;
    v5[1] = 0uLL;
    v5[2] = 0uLL;
    v5[3] = 0uLL;
    v5[4] = 0uLL;
    v5[5] = 0uLL;
    v5[6] = 0uLL;
    v5[7] = 0uLL;
    v5[8] = 0uLL;
    *(_OWORD *)((char *)v5 + 142) = 0uLL;
    *(_DWORD *)(v3 + 1048) = 0;
    *(_WORD *)(v3 + 1052) = 0;
    *(_DWORD *)(v3 + 74) = 0;
    *(_OWORD *)(v3 + 58) = 0uLL;
    *(_OWORD *)(v3 + 42) = 0uLL;
    *(_OWORD *)(v3 + 26) = 0uLL;
    *(_OWORD *)(v3 + 10) = 0uLL;
    *(void *)(v3 + 128) = 0;
    *(void *)(v3 + 136) = 0;
    *(void *)(v3 + 142) = 0;
    *(unsigned char *)(v3 + 160) = 0;
    *(void *)(v3 + 152) = 0;
    *(void *)(v3 + 169) = 0;
    *(void *)(v3 + 164) = 0;
    *(_WORD *)(v3 + 1032) = 0;
    v6[1] = 0uLL;
    v6[2] = 0uLL;
    *int v6 = 0uLL;
    *(_WORD *)(v3 + 1044) = 0;
    *(void *)(result + v1 + 1036) = 0;
    *(unsigned char *)(v3 + 1054) = 1;
    uint64_t v7 = result + v1 + 1055;
    int v8 = (void *)(result + v1 + 1108);
    *(void *)((char *)v8 + 5) = 0;
    *int v8 = 0;
    *(_DWORD *)(v3 + 1152) = 0;
    *(_WORD *)(v3 + 1156) = 0;
    *(void *)(result + v1 + 1165) = 0;
    *(void *)(v3 + 1160) = 0;
    *(unsigned char *)(v3 + 1204) = 0;
    *(unsigned char *)(v3 + 1208) = 0;
    *(_DWORD *)(result + v1 + 1210) = 0;
    *(unsigned char *)(v3 + 1214) = 0;
    *(_DWORD *)(v3 + 1216) = 0;
    uint64_t v9 = (_OWORD *)(result + v1 + 1224);
    *(_DWORD *)(v7 + 47) = 0;
    *(_OWORD *)(v7 + 16) = 0uLL;
    *(_OWORD *)(v7 + 32) = 0uLL;
    *(_OWORD *)uint64_t v7 = 0uLL;
    v1 += 1256;
    *uint64_t v9 = 0uLL;
    v9[1] = 0uLL;
    --v2;
  }
  while (v2);
  return result;
}

void APAC::MetadataBitStreamParser::parseAuthoringInformation(uint64_t a1, unsigned char *a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 16);
  unint64_t v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 2)
  {
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v90 = "Cannot read authorInfo.mAuthoringToolNameIndex";
    goto LABEL_145;
  }
  unsigned int v7 = *(_DWORD *)(a3 + 24);
  unsigned int v8 = v7 >> 29;
  int v9 = v6 - 3;
  *(_DWORD *)(a3 + 28) = v6 - 3;
  if (v6 - 3 < 0)
  {
    int v11 = *(unsigned int **)(a3 + 8);
    if ((v5 & ~(v5 >> 63) & 0xFFFFFFFC) != 0)
    {
      BOOL v12 = v11 >= v4;
      BOOL v13 = v11 == v4;
    }
    else
    {
      BOOL v12 = 1;
      BOOL v13 = 0;
    }
    if (!v13 && v12)
    {
      uint64_t v14 = 0;
      do
      {
        unsigned int v15 = (unsigned __int8 *)v4 + v14;
        unsigned int v16 = v7 << 8;
        *(_DWORD *)(a3 + 24) = v16;
        int v17 = 255;
        if ((unint64_t)v4 + v14 < v3 && v15 >= (unsigned __int8 *)v11) {
          int v17 = *v15;
        }
        unsigned int v7 = v17 | v16;
        *(_DWORD *)(a3 + 24) = v7;
        ++v14;
      }
      while (v14 != 4);
    }
    else
    {
      unsigned int v7 = bswap32(*v4);
    }
    unsigned int v18 = v7 << (3 - v6);
    int v19 = v6 + 29;
    *(_DWORD *)(a3 + 28) = v19;
    *(void *)a3 = ++v4;
    v8 |= v7 >> v19;
    if (v19) {
      unsigned int v10 = v18;
    }
    else {
      unsigned int v10 = 0;
    }
    if (v19) {
      int v9 = v19;
    }
    else {
      int v9 = 0;
    }
  }
  else
  {
    unsigned int v10 = 8 * v7;
  }
  *(_DWORD *)(a3 + 24) = v10;
  *a2 = v8;
  if (v9 + 8 * ((int)v3 - (int)v4) <= 7)
  {
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v90 = "Cannot read authorInfo.mAuthoringToolVersion.mMajor";
    goto LABEL_145;
  }
  unsigned int v20 = HIBYTE(v10);
  int v21 = v9 - 8;
  *(_DWORD *)(a3 + 28) = v9 - 8;
  if (v9 - 8 < 0)
  {
    unint64_t v23 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v23 <= (unint64_t)v4)
    {
      unsigned int v10 = bswap32(*v4);
    }
    else
    {
      uint64_t v24 = 0;
      do
      {
        uint64_t v25 = (unsigned __int8 *)v4 + v24;
        unsigned int v26 = v10 << 8;
        *(_DWORD *)(a3 + 24) = v26;
        int v27 = 255;
        if ((unint64_t)v4 + v24 < v3 && (unint64_t)v25 >= v23) {
          int v27 = *v25;
        }
        unsigned int v10 = v27 | v26;
        *(_DWORD *)(a3 + 24) = v10;
        ++v24;
      }
      while (v24 != 4);
    }
    unsigned int v28 = v10 << (8 - v9);
    int v29 = v9 + 24;
    *(_DWORD *)(a3 + 28) = v29;
    *(void *)a3 = ++v4;
    v20 |= v10 >> v29;
    if (v29) {
      unsigned int v22 = v28;
    }
    else {
      unsigned int v22 = 0;
    }
    if (v29) {
      int v21 = v29;
    }
    else {
      int v21 = 0;
    }
  }
  else
  {
    unsigned int v22 = v10 << 8;
  }
  *(_DWORD *)(a3 + 24) = v22;
  a2[1] = v20;
  if (v21 + 8 * ((int)v3 - (int)v4) <= 7)
  {
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v90 = "Cannot read authorInfo.mAuthoringToolVersion.mMinor";
    goto LABEL_145;
  }
  unsigned int v30 = HIBYTE(v22);
  int v31 = v21 - 8;
  *(_DWORD *)(a3 + 28) = v21 - 8;
  if (v21 - 8 < 0)
  {
    unint64_t v33 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v33 <= (unint64_t)v4)
    {
      unsigned int v22 = bswap32(*v4);
    }
    else
    {
      uint64_t v34 = 0;
      do
      {
        unsigned int v35 = (unsigned __int8 *)v4 + v34;
        unsigned int v36 = v22 << 8;
        *(_DWORD *)(a3 + 24) = v36;
        int v37 = 255;
        if ((unint64_t)v4 + v34 < v3 && (unint64_t)v35 >= v33) {
          int v37 = *v35;
        }
        unsigned int v22 = v37 | v36;
        *(_DWORD *)(a3 + 24) = v22;
        ++v34;
      }
      while (v34 != 4);
    }
    unsigned int v38 = v22 << (8 - v21);
    int v39 = v21 + 24;
    *(_DWORD *)(a3 + 28) = v39;
    *(void *)a3 = ++v4;
    v30 |= v22 >> v39;
    if (v39) {
      unsigned int v32 = v38;
    }
    else {
      unsigned int v32 = 0;
    }
    if (v39) {
      int v31 = v39;
    }
    else {
      int v31 = 0;
    }
  }
  else
  {
    unsigned int v32 = v22 << 8;
  }
  *(_DWORD *)(a3 + 24) = v32;
  a2[2] = v30;
  if (v31 + 8 * ((int)v3 - (int)v4) <= 7)
  {
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v90 = "Cannot read authorInfo.mAuthoringToolVersion.mPatch";
    goto LABEL_145;
  }
  unsigned int v40 = HIBYTE(v32);
  int v41 = v31 - 8;
  *(_DWORD *)(a3 + 28) = v31 - 8;
  if (v31 - 8 < 0)
  {
    unint64_t v43 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v43 <= (unint64_t)v4)
    {
      unsigned int v32 = bswap32(*v4);
    }
    else
    {
      uint64_t v44 = 0;
      do
      {
        unsigned int v45 = (unsigned __int8 *)v4 + v44;
        unsigned int v46 = v32 << 8;
        *(_DWORD *)(a3 + 24) = v46;
        int v47 = 255;
        if ((unint64_t)v4 + v44 < v3 && (unint64_t)v45 >= v43) {
          int v47 = *v45;
        }
        unsigned int v32 = v47 | v46;
        *(_DWORD *)(a3 + 24) = v32;
        ++v44;
      }
      while (v44 != 4);
    }
    unsigned int v48 = v32 << (8 - v31);
    int v49 = v31 + 24;
    *(_DWORD *)(a3 + 28) = v49;
    *(void *)a3 = ++v4;
    v40 |= v32 >> v49;
    if (v49) {
      unsigned int v42 = v48;
    }
    else {
      unsigned int v42 = 0;
    }
    if (v49) {
      int v41 = v49;
    }
    else {
      int v41 = 0;
    }
  }
  else
  {
    unsigned int v42 = v32 << 8;
  }
  *(_DWORD *)(a3 + 24) = v42;
  a2[3] = v40;
  if (v41 + 8 * ((int)v3 - (int)v4) <= 2)
  {
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v90 = "Cannot read authorInfo.mRendererNameIndex";
    goto LABEL_145;
  }
  unsigned int v50 = v42 >> 29;
  int v51 = v41 - 3;
  *(_DWORD *)(a3 + 28) = v41 - 3;
  if (v41 - 3 < 0)
  {
    unint64_t v53 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v53 <= (unint64_t)v4)
    {
      unsigned int v42 = bswap32(*v4);
    }
    else
    {
      uint64_t v54 = 0;
      do
      {
        unsigned int v55 = (unsigned __int8 *)v4 + v54;
        unsigned int v56 = v42 << 8;
        *(_DWORD *)(a3 + 24) = v56;
        int v57 = 255;
        if ((unint64_t)v4 + v54 < v3 && (unint64_t)v55 >= v53) {
          int v57 = *v55;
        }
        unsigned int v42 = v57 | v56;
        *(_DWORD *)(a3 + 24) = v42;
        ++v54;
      }
      while (v54 != 4);
    }
    unsigned int v58 = v42 << (3 - v41);
    int v59 = v41 + 29;
    *(_DWORD *)(a3 + 28) = v59;
    *(void *)a3 = ++v4;
    v50 |= v42 >> v59;
    if (v59) {
      unsigned int v52 = v58;
    }
    else {
      unsigned int v52 = 0;
    }
    if (v59) {
      int v51 = v59;
    }
    else {
      int v51 = 0;
    }
  }
  else
  {
    unsigned int v52 = 8 * v42;
  }
  *(_DWORD *)(a3 + 24) = v52;
  a2[4] = v50;
  if (v51 + 8 * ((int)v3 - (int)v4) <= 7)
  {
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v90 = "Cannot read authorInfo.mRendererVersion.mMajor";
    goto LABEL_145;
  }
  unsigned int v60 = HIBYTE(v52);
  int v61 = v51 - 8;
  *(_DWORD *)(a3 + 28) = v51 - 8;
  if (v51 - 8 < 0)
  {
    unint64_t v63 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v63 <= (unint64_t)v4)
    {
      unsigned int v52 = bswap32(*v4);
    }
    else
    {
      uint64_t v64 = 0;
      do
      {
        uint64_t v65 = (unsigned __int8 *)v4 + v64;
        unsigned int v66 = v52 << 8;
        *(_DWORD *)(a3 + 24) = v66;
        int v67 = 255;
        if ((unint64_t)v4 + v64 < v3 && (unint64_t)v65 >= v63) {
          int v67 = *v65;
        }
        unsigned int v52 = v67 | v66;
        *(_DWORD *)(a3 + 24) = v52;
        ++v64;
      }
      while (v64 != 4);
    }
    unsigned int v68 = v52 << (8 - v51);
    int v69 = v51 + 24;
    *(_DWORD *)(a3 + 28) = v69;
    *(void *)a3 = ++v4;
    v60 |= v52 >> v69;
    if (v69) {
      unsigned int v62 = v68;
    }
    else {
      unsigned int v62 = 0;
    }
    if (v69) {
      int v61 = v69;
    }
    else {
      int v61 = 0;
    }
  }
  else
  {
    unsigned int v62 = v52 << 8;
  }
  *(_DWORD *)(a3 + 24) = v62;
  a2[5] = v60;
  if (v61 + 8 * ((int)v3 - (int)v4) <= 7)
  {
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v90 = "Cannot read authorInfo.mRendererVersion.mMinor";
    goto LABEL_145;
  }
  unsigned int v70 = HIBYTE(v62);
  int v71 = v61 - 8;
  *(_DWORD *)(a3 + 28) = v61 - 8;
  if (v61 - 8 < 0)
  {
    unint64_t v73 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v73 <= (unint64_t)v4)
    {
      unsigned int v62 = bswap32(*v4);
    }
    else
    {
      uint64_t v74 = 0;
      do
      {
        unsigned int v75 = (unsigned __int8 *)v4 + v74;
        unsigned int v76 = v62 << 8;
        *(_DWORD *)(a3 + 24) = v76;
        int v77 = 255;
        if ((unint64_t)v4 + v74 < v3 && (unint64_t)v75 >= v73) {
          int v77 = *v75;
        }
        unsigned int v62 = v77 | v76;
        *(_DWORD *)(a3 + 24) = v62;
        ++v74;
      }
      while (v74 != 4);
    }
    unsigned int v78 = v62 << (8 - v61);
    int v79 = v61 + 24;
    *(_DWORD *)(a3 + 28) = v79;
    *(void *)a3 = ++v4;
    v70 |= v62 >> v79;
    if (v79) {
      unsigned int v72 = v78;
    }
    else {
      unsigned int v72 = 0;
    }
    if (v79) {
      int v71 = v79;
    }
    else {
      int v71 = 0;
    }
  }
  else
  {
    unsigned int v72 = v62 << 8;
  }
  *(_DWORD *)(a3 + 24) = v72;
  a2[6] = v70;
  if (v71 + 8 * ((int)v3 - (int)v4) <= 7)
  {
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v90 = "Cannot read authorInfo.mRendererVersion.mPatch";
LABEL_145:
    void *exception = v90;
    __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
  }
  unsigned int v80 = HIBYTE(v72);
  *(_DWORD *)(a3 + 28) = v71 - 8;
  if (v71 - 8 < 0)
  {
    unint64_t v82 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v82 <= (unint64_t)v4)
    {
      unsigned int v72 = bswap32(*v4);
    }
    else
    {
      uint64_t v83 = 0;
      do
      {
        int v84 = (unsigned __int8 *)v4 + v83;
        unsigned int v85 = v72 << 8;
        *(_DWORD *)(a3 + 24) = v85;
        int v86 = 255;
        if ((unint64_t)v4 + v83 < v3 && (unint64_t)v84 >= v82) {
          int v86 = *v84;
        }
        unsigned int v72 = v86 | v85;
        *(_DWORD *)(a3 + 24) = v72;
        ++v83;
      }
      while (v83 != 4);
    }
    unsigned int v87 = v72 << (8 - v71);
    int v88 = v71 + 24;
    *(_DWORD *)(a3 + 28) = v88;
    *(void *)a3 = v4 + 1;
    v80 |= v72 >> v88;
    if (v88) {
      unsigned int v81 = v87;
    }
    else {
      unsigned int v81 = 0;
    }
  }
  else
  {
    unsigned int v81 = v72 << 8;
  }
  *(_DWORD *)(a3 + 24) = v81;
  a2[7] = v80;
}

void APAC::MetadataBitStreamParser::parseReferenceScreen(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 16);
  unint64_t v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 31)
  {
    exception = __cxa_allocate_exception(8uLL);
    unsigned int v96 = "Cannot read refScreen.mAspectRatio";
    goto LABEL_159;
  }
  unsigned int v7 = *(_DWORD *)(a3 + 24);
  *(_DWORD *)(a3 + 28) = v6 - 32;
  if (v6 - 32 < 0)
  {
    unint64_t v10 = *(void *)(a3 + 8);
    if ((v5 & ~(v5 >> 63) & 0xFFFFFFFC) == 0 || v10 > (unint64_t)v4)
    {
      uint64_t v12 = 0;
      unsigned int v16 = v7;
      do
      {
        BOOL v13 = (unsigned __int8 *)v4 + v12;
        unsigned int v14 = v16 << 8;
        *(_DWORD *)(a3 + 24) = v14;
        int v15 = 255;
        if ((unint64_t)v4 + v12 < v3 && (unint64_t)v13 >= v10) {
          int v15 = *v13;
        }
        unsigned int v16 = v15 | v14;
        *(_DWORD *)(a3 + 24) = v16;
        ++v12;
      }
      while (v12 != 4);
    }
    else
    {
      unsigned int v16 = bswap32(*v4);
    }
    *(void *)a3 = ++v4;
    int v9 = (v16 >> v6) | v7;
    unsigned int v7 = v16 << -(char)v6;
    if (!v6) {
      unsigned int v7 = 0;
    }
    *(_DWORD *)(a3 + 24) = v7;
    *(_DWORD *)(a3 + 28) = v6;
    uint64_t v5 = v3 - (void)v4;
    int v8 = 8 * (v3 - v4);
  }
  else
  {
    int v8 = 8 * v5;
    v6 -= 32;
    int v9 = v7;
  }
  *(_DWORD *)a2 = v9;
  if ((v8 + v6 < 0) ^ __OFADD__(v8, v6) | (v8 + v6 == 0))
  {
    exception = __cxa_allocate_exception(8uLL);
    unsigned int v96 = "Cannot read refScreen.mIsCartesian";
    goto LABEL_159;
  }
  unsigned int v17 = v7 >> 31;
  int v18 = v6 - 1;
  *(_DWORD *)(a3 + 28) = v6 - 1;
  if (v6 - 1 < 0)
  {
    unint64_t v20 = *(void *)(a3 + 8);
    if ((v5 & ~(v5 >> 63) & 0xFFFFFFFC) == 0 || v20 > (unint64_t)v4)
    {
      uint64_t v22 = 0;
      do
      {
        unint64_t v23 = (unsigned __int8 *)v4 + v22;
        unsigned int v24 = v7 << 8;
        *(_DWORD *)(a3 + 24) = v24;
        int v25 = 255;
        if ((unint64_t)v4 + v22 < v3 && (unint64_t)v23 >= v20) {
          int v25 = *v23;
        }
        unsigned int v7 = v25 | v24;
        *(_DWORD *)(a3 + 24) = v7;
        ++v22;
      }
      while (v22 != 4);
    }
    else
    {
      unsigned int v7 = bswap32(*v4);
    }
    int v27 = v6 + 31;
    BOOL v26 = v6 == -31;
    *(_DWORD *)(a3 + 28) = v6 + 31;
    *(void *)a3 = ++v4;
    v17 |= v7 >> (v6 + 31);
    if (v6 == -31) {
      int v19 = 0;
    }
    else {
      int v19 = v7 << (1 - v6);
    }
    if (v26) {
      int v18 = 0;
    }
    else {
      int v18 = v27;
    }
  }
  else
  {
    int v19 = 2 * v7;
  }
  *(_DWORD *)(a3 + 24) = v19;
  *(unsigned char *)(a2 + 4) = v17 != 0;
  uint64_t v28 = v3 - (void)v4;
  int v29 = 8 * (v3 - v4);
  int v30 = v18 + v29;
  if (v17)
  {
    if (v30 <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      unsigned int v96 = "Cannot read refScreen.mScreenCentrePosition.mX";
    }
    else
    {
      *(_DWORD *)(a3 + 28) = v18 - 32;
      if (v18 - 32 < 0)
      {
        int v33 = v28 & ~(v28 >> 63);
        unint64_t v34 = *(void *)(a3 + 8);
        if ((v33 & 0xFFFFFFFC) != 0 && v34 <= (unint64_t)v4)
        {
          unsigned int v35 = bswap32(*v4);
        }
        else
        {
          uint64_t v39 = 0;
          unsigned int v35 = v19;
          do
          {
            unsigned int v40 = (unsigned __int8 *)v4 + v39;
            unsigned int v41 = v35 << 8;
            *(_DWORD *)(a3 + 24) = v41;
            int v42 = 255;
            if ((unint64_t)v4 + v39 < v3 && (unint64_t)v40 >= v34) {
              int v42 = *v40;
            }
            unsigned int v35 = v42 | v41;
            *(_DWORD *)(a3 + 24) = v35;
            ++v39;
          }
          while (v39 != 4);
        }
        *(void *)a3 = ++v4;
        int v31 = (v35 >> v18) | v19;
        int v19 = v35 << -(char)v18;
        if (!v18) {
          int v19 = 0;
        }
        *(_DWORD *)(a3 + 24) = v19;
        *(_DWORD *)(a3 + 28) = v18;
        uint64_t v28 = v3 - (void)v4;
        int v29 = 8 * (v3 - v4);
      }
      else
      {
        v18 -= 32;
        int v31 = v19;
      }
      *(_DWORD *)(a2 + 8) = v31;
      if (v29 + v18 <= 31)
      {
        exception = __cxa_allocate_exception(8uLL);
        unsigned int v96 = "Cannot read refScreen.mScreenCentrePosition.mY";
      }
      else
      {
        *(_DWORD *)(a3 + 28) = v18 - 32;
        if (v18 - 32 < 0)
        {
          int v44 = v28 & ~(v28 >> 63);
          unint64_t v45 = *(void *)(a3 + 8);
          if ((v44 & 0xFFFFFFFC) != 0 && v45 <= (unint64_t)v4)
          {
            unsigned int v46 = bswap32(*v4);
          }
          else
          {
            uint64_t v47 = 0;
            unsigned int v46 = v19;
            do
            {
              unsigned int v48 = (unsigned __int8 *)v4 + v47;
              unsigned int v49 = v46 << 8;
              *(_DWORD *)(a3 + 24) = v49;
              int v50 = 255;
              if ((unint64_t)v4 + v47 < v3 && (unint64_t)v48 >= v45) {
                int v50 = *v48;
              }
              unsigned int v46 = v50 | v49;
              *(_DWORD *)(a3 + 24) = v46;
              ++v47;
            }
            while (v47 != 4);
          }
          *(void *)a3 = ++v4;
          int v43 = (v46 >> v18) | v19;
          int v19 = v46 << -(char)v18;
          if (!v18) {
            int v19 = 0;
          }
          *(_DWORD *)(a3 + 24) = v19;
          *(_DWORD *)(a3 + 28) = v18;
          uint64_t v28 = v3 - (void)v4;
          int v29 = 8 * (v3 - v4);
        }
        else
        {
          v18 -= 32;
          int v43 = v19;
        }
        *(_DWORD *)(a2 + 12) = v43;
        if (v29 + v18 <= 31)
        {
          exception = __cxa_allocate_exception(8uLL);
          unsigned int v96 = "Cannot read refScreen.mScreenCentrePosition.mZ";
        }
        else
        {
          *(_DWORD *)(a3 + 28) = v18 - 32;
          if (v18 - 32 < 0)
          {
            int v52 = v28 & ~(v28 >> 63);
            unint64_t v53 = *(void *)(a3 + 8);
            if ((v52 & 0xFFFFFFFC) != 0 && v53 <= (unint64_t)v4)
            {
              unsigned int v54 = bswap32(*v4);
            }
            else
            {
              uint64_t v55 = 0;
              unsigned int v54 = v19;
              do
              {
                unsigned int v56 = (unsigned __int8 *)v4 + v55;
                unsigned int v57 = v54 << 8;
                *(_DWORD *)(a3 + 24) = v57;
                int v58 = 255;
                if ((unint64_t)v4 + v55 < v3 && (unint64_t)v56 >= v53) {
                  int v58 = *v56;
                }
                unsigned int v54 = v58 | v57;
                *(_DWORD *)(a3 + 24) = v54;
                ++v55;
              }
              while (v55 != 4);
            }
            *(void *)a3 = ++v4;
            int v51 = (v54 >> v18) | v19;
            int v19 = v54 << -(char)v18;
            if (!v18) {
              int v19 = 0;
            }
            *(_DWORD *)(a3 + 24) = v19;
            *(_DWORD *)(a3 + 28) = v18;
            uint64_t v28 = v3 - (void)v4;
            int v29 = 8 * (v3 - v4);
          }
          else
          {
            v18 -= 32;
            int v51 = v19;
          }
          *(_DWORD *)(a2 + 16) = v51;
          if (v29 + v18 > 31)
          {
            *(_DWORD *)(a3 + 28) = v18 - 32;
            if (v18 - 32 < 0)
            {
              int v59 = v28 & ~(v28 >> 63);
              unint64_t v60 = *(void *)(a3 + 8);
              if ((v59 & 0xFFFFFFFC) != 0 && v60 <= (unint64_t)v4)
              {
                unsigned int v61 = bswap32(*v4);
              }
              else
              {
                uint64_t v62 = 0;
                unsigned int v61 = v19;
                do
                {
                  unint64_t v63 = (unsigned __int8 *)v4 + v62;
                  unsigned int v64 = v61 << 8;
                  *(_DWORD *)(a3 + 24) = v64;
                  int v65 = 255;
                  if ((unint64_t)v4 + v62 < v3 && (unint64_t)v63 >= v60) {
                    int v65 = *v63;
                  }
                  unsigned int v61 = v65 | v64;
                  *(_DWORD *)(a3 + 24) = v61;
                  ++v62;
                }
                while (v62 != 4);
              }
              *(void *)a3 = v4 + 1;
              v19 |= v61 >> v18;
              unsigned int v66 = v61 << -(char)v18;
              if (!v18) {
                unsigned int v66 = 0;
              }
              *(_DWORD *)(a3 + 24) = v66;
              *(_DWORD *)(a3 + 28) = v18;
            }
            *(_DWORD *)(a2 + 32) = v19;
            return;
          }
          exception = __cxa_allocate_exception(8uLL);
          unsigned int v96 = "Cannot read refScreen.mScreenWidth.mX";
        }
      }
    }
LABEL_159:
    void *exception = v96;
    __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
  }
  if (v30 <= 31)
  {
    exception = __cxa_allocate_exception(8uLL);
    unsigned int v96 = "Cannot read refScreen.mScreenCentrePosition.mAzimuth";
    goto LABEL_159;
  }
  *(_DWORD *)(a3 + 28) = v18 - 32;
  if (v18 - 32 < 0)
  {
    int v36 = v28 & ~(v28 >> 63);
    unint64_t v37 = *(void *)(a3 + 8);
    if ((v36 & 0xFFFFFFFC) != 0 && v37 <= (unint64_t)v4)
    {
      unsigned int v38 = bswap32(*v4);
    }
    else
    {
      uint64_t v67 = 0;
      unsigned int v38 = v19;
      do
      {
        unsigned int v68 = (unsigned __int8 *)v4 + v67;
        unsigned int v69 = v38 << 8;
        *(_DWORD *)(a3 + 24) = v69;
        int v70 = 255;
        if ((unint64_t)v4 + v67 < v3 && (unint64_t)v68 >= v37) {
          int v70 = *v68;
        }
        unsigned int v38 = v70 | v69;
        *(_DWORD *)(a3 + 24) = v38;
        ++v67;
      }
      while (v67 != 4);
    }
    *(void *)a3 = ++v4;
    int v32 = (v38 >> v18) | v19;
    int v19 = v38 << -(char)v18;
    if (!v18) {
      int v19 = 0;
    }
    *(_DWORD *)(a3 + 24) = v19;
    *(_DWORD *)(a3 + 28) = v18;
    uint64_t v28 = v3 - (void)v4;
    int v29 = 8 * (v3 - v4);
  }
  else
  {
    v18 -= 32;
    int v32 = v19;
  }
  *(_DWORD *)(a2 + 20) = v32;
  if (v29 + v18 <= 31)
  {
    exception = __cxa_allocate_exception(8uLL);
    unsigned int v96 = "Cannot read refScreen.mScreenCentrePosition.mElevation";
    goto LABEL_159;
  }
  *(_DWORD *)(a3 + 28) = v18 - 32;
  if (v18 - 32 < 0)
  {
    int v72 = v28 & ~(v28 >> 63);
    unint64_t v73 = *(void *)(a3 + 8);
    if ((v72 & 0xFFFFFFFC) != 0 && v73 <= (unint64_t)v4)
    {
      unsigned int v74 = bswap32(*v4);
    }
    else
    {
      uint64_t v75 = 0;
      unsigned int v74 = v19;
      do
      {
        unsigned int v76 = (unsigned __int8 *)v4 + v75;
        unsigned int v77 = v74 << 8;
        *(_DWORD *)(a3 + 24) = v77;
        int v78 = 255;
        if ((unint64_t)v4 + v75 < v3 && (unint64_t)v76 >= v73) {
          int v78 = *v76;
        }
        unsigned int v74 = v78 | v77;
        *(_DWORD *)(a3 + 24) = v74;
        ++v75;
      }
      while (v75 != 4);
    }
    *(void *)a3 = ++v4;
    int v71 = (v74 >> v18) | v19;
    int v19 = v74 << -(char)v18;
    if (!v18) {
      int v19 = 0;
    }
    *(_DWORD *)(a3 + 24) = v19;
    *(_DWORD *)(a3 + 28) = v18;
    uint64_t v28 = v3 - (void)v4;
    int v29 = 8 * (v3 - v4);
  }
  else
  {
    v18 -= 32;
    int v71 = v19;
  }
  *(_DWORD *)(a2 + 24) = v71;
  if (v29 + v18 <= 31)
  {
    exception = __cxa_allocate_exception(8uLL);
    unsigned int v96 = "Cannot read refScreen.mScreenCentrePosition.mRadius";
    goto LABEL_159;
  }
  *(_DWORD *)(a3 + 28) = v18 - 32;
  if (v18 - 32 < 0)
  {
    int v80 = v28 & ~(v28 >> 63);
    unint64_t v81 = *(void *)(a3 + 8);
    if ((v80 & 0xFFFFFFFC) != 0 && v81 <= (unint64_t)v4)
    {
      unsigned int v82 = bswap32(*v4);
    }
    else
    {
      uint64_t v83 = 0;
      unsigned int v82 = v19;
      do
      {
        int v84 = (unsigned __int8 *)v4 + v83;
        unsigned int v85 = v82 << 8;
        *(_DWORD *)(a3 + 24) = v85;
        int v86 = 255;
        if ((unint64_t)v4 + v83 < v3 && (unint64_t)v84 >= v81) {
          int v86 = *v84;
        }
        unsigned int v82 = v86 | v85;
        *(_DWORD *)(a3 + 24) = v82;
        ++v83;
      }
      while (v83 != 4);
    }
    *(void *)a3 = ++v4;
    int v79 = (v82 >> v18) | v19;
    int v19 = v82 << -(char)v18;
    if (!v18) {
      int v19 = 0;
    }
    *(_DWORD *)(a3 + 24) = v19;
    *(_DWORD *)(a3 + 28) = v18;
    uint64_t v28 = v3 - (void)v4;
    int v29 = 8 * (v3 - v4);
  }
  else
  {
    v18 -= 32;
    int v79 = v19;
  }
  *(_DWORD *)(a2 + 28) = v79;
  if (v29 + v18 <= 31)
  {
    exception = __cxa_allocate_exception(8uLL);
    unsigned int v96 = "Cannot read refScreen.mScreenWidth.mAzimuth";
    goto LABEL_159;
  }
  *(_DWORD *)(a3 + 28) = v18 - 32;
  if (v18 - 32 < 0)
  {
    int v87 = v28 & ~(v28 >> 63);
    unint64_t v88 = *(void *)(a3 + 8);
    if ((v87 & 0xFFFFFFFC) != 0 && v88 <= (unint64_t)v4)
    {
      unsigned int v89 = bswap32(*v4);
    }
    else
    {
      uint64_t v90 = 0;
      unsigned int v89 = v19;
      do
      {
        unint64_t v91 = (unsigned __int8 *)v4 + v90;
        unsigned int v92 = v89 << 8;
        *(_DWORD *)(a3 + 24) = v92;
        int v93 = 255;
        if ((unint64_t)v4 + v90 < v3 && (unint64_t)v91 >= v88) {
          int v93 = *v91;
        }
        unsigned int v89 = v93 | v92;
        *(_DWORD *)(a3 + 24) = v89;
        ++v90;
      }
      while (v90 != 4);
    }
    *(void *)a3 = v4 + 1;
    v19 |= v89 >> v18;
    unsigned int v94 = v89 << -(char)v18;
    if (!v18) {
      unsigned int v94 = 0;
    }
    *(_DWORD *)(a3 + 24) = v94;
    *(_DWORD *)(a3 + 28) = v18;
  }
  *(_DWORD *)(a2 + 36) = v19;
}

BOOL APAC::MetadataBitStreamParser::parseDBMD(uint64_t a1, unsigned char *a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 16);
  unint64_t v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 1)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v93 = "Cannot read dbmd.mSurroundDownmix";
    goto LABEL_167;
  }
  unsigned int v8 = *(_DWORD *)(a3 + 24);
  unsigned int v9 = v8 >> 30;
  int v10 = v6 - 2;
  *(_DWORD *)(a3 + 28) = v6 - 2;
  if (v6 - 2 < 0)
  {
    unint64_t v12 = *(void *)(a3 + 8);
    if ((v5 & ~(v5 >> 63) & 0xFFFFFFFC) == 0 || v12 > (unint64_t)v4)
    {
      uint64_t v14 = 0;
      do
      {
        int v15 = (unsigned __int8 *)v4 + v14;
        unsigned int v16 = v8 << 8;
        *(_DWORD *)(a3 + 24) = v16;
        int v17 = 255;
        if ((unint64_t)v4 + v14 < v3 && (unint64_t)v15 >= v12) {
          int v17 = *v15;
        }
        unsigned int v8 = v17 | v16;
        *(_DWORD *)(a3 + 24) = v8;
        ++v14;
      }
      while (v14 != 4);
    }
    else
    {
      unsigned int v8 = bswap32(*v4);
    }
    unsigned int v18 = v8 << (2 - v6);
    int v19 = v6 + 30;
    *(_DWORD *)(a3 + 28) = v19;
    *(void *)a3 = ++v4;
    v9 |= v8 >> v19;
    if (v19) {
      unsigned int v11 = v18;
    }
    else {
      unsigned int v11 = 0;
    }
    if (v19) {
      int v10 = v19;
    }
    else {
      int v10 = 0;
    }
  }
  else
  {
    unsigned int v11 = 4 * v8;
  }
  *(_DWORD *)(a3 + 24) = v11;
  *a2 = v9;
  if (v10 + 8 * ((int)v3 - (int)v4) <= 1)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v93 = "Cannot read dbmd.mSurroundToStereoDownmix";
    goto LABEL_167;
  }
  unsigned int v20 = v11 >> 30;
  int v21 = v10 - 2;
  *(_DWORD *)(a3 + 28) = v10 - 2;
  if (v10 - 2 < 0)
  {
    unint64_t v23 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v23 <= (unint64_t)v4)
    {
      unsigned int v11 = bswap32(*v4);
    }
    else
    {
      uint64_t v24 = 0;
      do
      {
        int v25 = (unsigned __int8 *)v4 + v24;
        unsigned int v26 = v11 << 8;
        *(_DWORD *)(a3 + 24) = v26;
        int v27 = 255;
        if ((unint64_t)v4 + v24 < v3 && (unint64_t)v25 >= v23) {
          int v27 = *v25;
        }
        unsigned int v11 = v27 | v26;
        *(_DWORD *)(a3 + 24) = v11;
        ++v24;
      }
      while (v24 != 4);
    }
    unsigned int v28 = v11 << (2 - v10);
    int v29 = v10 + 30;
    *(_DWORD *)(a3 + 28) = v29;
    *(void *)a3 = ++v4;
    v20 |= v11 >> v29;
    if (v29) {
      unsigned int v22 = v28;
    }
    else {
      unsigned int v22 = 0;
    }
    if (v29) {
      int v21 = v29;
    }
    else {
      int v21 = 0;
    }
  }
  else
  {
    unsigned int v22 = 4 * v11;
  }
  *(_DWORD *)(a3 + 24) = v22;
  a2[1] = v20;
  if (v21 + 8 * ((int)v3 - (int)v4) <= 2)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v93 = "Cannot read dbmd.mPositionAdjustment";
    goto LABEL_167;
  }
  unsigned int v30 = v22 >> 29;
  int v31 = v21 - 3;
  *(_DWORD *)(a3 + 28) = v21 - 3;
  if (v21 - 3 < 0)
  {
    unint64_t v33 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v33 <= (unint64_t)v4)
    {
      unsigned int v22 = bswap32(*v4);
    }
    else
    {
      uint64_t v34 = 0;
      do
      {
        unsigned int v35 = (unsigned __int8 *)v4 + v34;
        unsigned int v36 = v22 << 8;
        *(_DWORD *)(a3 + 24) = v36;
        int v37 = 255;
        if ((unint64_t)v4 + v34 < v3 && (unint64_t)v35 >= v33) {
          int v37 = *v35;
        }
        unsigned int v22 = v37 | v36;
        *(_DWORD *)(a3 + 24) = v22;
        ++v34;
      }
      while (v34 != 4);
    }
    unsigned int v38 = v22 << (3 - v21);
    int v39 = v21 + 29;
    *(_DWORD *)(a3 + 28) = v39;
    *(void *)a3 = ++v4;
    v30 |= v22 >> v39;
    if (v39) {
      unsigned int v32 = v38;
    }
    else {
      unsigned int v32 = 0;
    }
    if (v39) {
      int v31 = v39;
    }
    else {
      int v31 = 0;
    }
  }
  else
  {
    unsigned int v32 = 8 * v22;
  }
  uint64_t v40 = 0;
  *(_DWORD *)(a3 + 24) = v32;
  a2[2] = v30;
  unint64_t v41 = *(void *)(a3 + 8);
  int v42 = a2 + 12;
  do
  {
    if (v31 + 8 * ((int)v3 - (int)v4) <= 0)
    {
      exception = __cxa_allocate_exception(8uLL);
      int v93 = "Cannot read dbmd.mIsAutoTrim[cfg]";
      goto LABEL_167;
    }
    unsigned int v43 = v32 >> 31;
    *(_DWORD *)(a3 + 28) = v31 - 1;
    if (v31 - 1 < 0)
    {
      if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
        && v41 <= (unint64_t)v4)
      {
        unsigned int v32 = bswap32(*v4);
      }
      else
      {
        uint64_t v44 = 0;
        do
        {
          unint64_t v45 = (unsigned __int8 *)v4 + v44;
          unsigned int v46 = v32 << 8;
          *(_DWORD *)(a3 + 24) = v46;
          int v47 = 255;
          if ((unint64_t)v4 + v44 < v3 && (unint64_t)v45 >= v41) {
            int v47 = *v45;
          }
          unsigned int v32 = v47 | v46;
          *(_DWORD *)(a3 + 24) = v32;
          ++v44;
        }
        while (v44 != 4);
      }
      unsigned int v48 = v32 << (1 - v31);
      v31 += 31;
      *(_DWORD *)(a3 + 28) = v31;
      *(void *)a3 = ++v4;
      v43 |= v32 >> v31;
      if (v31) {
        unsigned int v32 = v48;
      }
      else {
        unsigned int v32 = 0;
      }
      if (!v31) {
        int v31 = 0;
      }
    }
    else
    {
      v32 *= 2;
      --v31;
    }
    *(_DWORD *)(a3 + 24) = v32;
    a2[v40 + 3] = v43 != 0;
    if (!v43)
    {
      uint64_t v49 = v3 - (void)v4;
      if (v31 + 8 * ((int)v3 - (int)v4) <= 31)
      {
        exception = __cxa_allocate_exception(8uLL);
        int v93 = "Cannot read dbmd.mMixingGains[cfg].mFrontGain";
        goto LABEL_167;
      }
      *(_DWORD *)(a3 + 28) = v31 - 32;
      if (v31 - 32 < 0)
      {
        if ((v49 & ~(v49 >> 63) & 0xFFFFFFFC) != 0 && v41 <= (unint64_t)v4)
        {
          unsigned int v52 = bswap32(*v4);
        }
        else
        {
          uint64_t v53 = 0;
          unsigned int v52 = v32;
          do
          {
            unsigned int v54 = (unsigned __int8 *)v4 + v53;
            unsigned int v55 = v52 << 8;
            *(_DWORD *)(a3 + 24) = v55;
            int v56 = 255;
            if ((unint64_t)v4 + v53 < v3 && (unint64_t)v54 >= v41) {
              int v56 = *v54;
            }
            unsigned int v52 = v56 | v55;
            *(_DWORD *)(a3 + 24) = v52;
            ++v53;
          }
          while (v53 != 4);
        }
        *(void *)a3 = ++v4;
        int v51 = (v52 >> v31) | v32;
        unsigned int v32 = v52 << -(char)v31;
        if (!v31) {
          unsigned int v32 = 0;
        }
        *(_DWORD *)(a3 + 24) = v32;
        *(_DWORD *)(a3 + 28) = v31;
        uint64_t v49 = v3 - (void)v4;
        int v50 = 8 * (v3 - v4);
      }
      else
      {
        int v50 = 8 * v49;
        v31 -= 32;
        int v51 = v32;
      }
      *(_DWORD *)&v42[20 * v40] = v51;
      if (v50 + v31 <= 31)
      {
        exception = __cxa_allocate_exception(8uLL);
        int v93 = "Cannot read dbmd.mMixingGains[cfg].mBackGain";
        goto LABEL_167;
      }
      *(_DWORD *)(a3 + 28) = v31 - 32;
      if (v31 - 32 < 0)
      {
        if ((v49 & ~(v49 >> 63) & 0xFFFFFFFC) != 0 && v41 <= (unint64_t)v4)
        {
          unsigned int v58 = bswap32(*v4);
        }
        else
        {
          uint64_t v59 = 0;
          unsigned int v58 = v32;
          do
          {
            unint64_t v60 = (unsigned __int8 *)v4 + v59;
            unsigned int v61 = v58 << 8;
            *(_DWORD *)(a3 + 24) = v61;
            int v62 = 255;
            if ((unint64_t)v4 + v59 < v3 && (unint64_t)v60 >= v41) {
              int v62 = *v60;
            }
            unsigned int v58 = v62 | v61;
            *(_DWORD *)(a3 + 24) = v58;
            ++v59;
          }
          while (v59 != 4);
        }
        *(void *)a3 = ++v4;
        int v57 = (v58 >> v31) | v32;
        unsigned int v32 = v58 << -(char)v31;
        if (!v31) {
          unsigned int v32 = 0;
        }
        *(_DWORD *)(a3 + 24) = v32;
        *(_DWORD *)(a3 + 28) = v31;
        uint64_t v49 = v3 - (void)v4;
        int v50 = 8 * (v3 - v4);
      }
      else
      {
        v31 -= 32;
        int v57 = v32;
      }
      *(_DWORD *)&v42[20 * v40 + 4] = v57;
      if (v50 + v31 <= 31)
      {
        exception = __cxa_allocate_exception(8uLL);
        int v93 = "Cannot read dbmd.mMixingGains[cfg].mTopGain";
        goto LABEL_167;
      }
      *(_DWORD *)(a3 + 28) = v31 - 32;
      if (v31 - 32 < 0)
      {
        if ((v49 & ~(v49 >> 63) & 0xFFFFFFFC) != 0 && v41 <= (unint64_t)v4)
        {
          unsigned int v64 = bswap32(*v4);
        }
        else
        {
          uint64_t v65 = 0;
          unsigned int v64 = v32;
          do
          {
            unsigned int v66 = (unsigned __int8 *)v4 + v65;
            unsigned int v67 = v64 << 8;
            *(_DWORD *)(a3 + 24) = v67;
            int v68 = 255;
            if ((unint64_t)v4 + v65 < v3 && (unint64_t)v66 >= v41) {
              int v68 = *v66;
            }
            unsigned int v64 = v68 | v67;
            *(_DWORD *)(a3 + 24) = v64;
            ++v65;
          }
          while (v65 != 4);
        }
        *(void *)a3 = ++v4;
        int v63 = (v64 >> v31) | v32;
        unsigned int v32 = v64 << -(char)v31;
        if (!v31) {
          unsigned int v32 = 0;
        }
        *(_DWORD *)(a3 + 24) = v32;
        *(_DWORD *)(a3 + 28) = v31;
        uint64_t v49 = v3 - (void)v4;
        int v50 = 8 * (v3 - v4);
      }
      else
      {
        v31 -= 32;
        int v63 = v32;
      }
      *(_DWORD *)&v42[20 * v40 + 8] = v63;
      if (v50 + v31 <= 31)
      {
        exception = __cxa_allocate_exception(8uLL);
        int v93 = "Cannot read dbmd.mMixingGains[cfg].mEarLevelBalance";
        goto LABEL_167;
      }
      *(_DWORD *)(a3 + 28) = v31 - 32;
      if (v31 - 32 < 0)
      {
        if ((v49 & ~(v49 >> 63) & 0xFFFFFFFC) != 0 && v41 <= (unint64_t)v4)
        {
          unsigned int v70 = bswap32(*v4);
        }
        else
        {
          uint64_t v71 = 0;
          unsigned int v70 = v32;
          do
          {
            int v72 = (unsigned __int8 *)v4 + v71;
            unsigned int v73 = v70 << 8;
            *(_DWORD *)(a3 + 24) = v73;
            int v74 = 255;
            if ((unint64_t)v4 + v71 < v3 && (unint64_t)v72 >= v41) {
              int v74 = *v72;
            }
            unsigned int v70 = v74 | v73;
            *(_DWORD *)(a3 + 24) = v70;
            ++v71;
          }
          while (v71 != 4);
        }
        *(void *)a3 = ++v4;
        int v69 = (v70 >> v31) | v32;
        unsigned int v32 = v70 << -(char)v31;
        if (!v31) {
          unsigned int v32 = 0;
        }
        *(_DWORD *)(a3 + 24) = v32;
        *(_DWORD *)(a3 + 28) = v31;
        uint64_t v49 = v3 - (void)v4;
        int v50 = 8 * (v3 - v4);
      }
      else
      {
        v31 -= 32;
        int v69 = v32;
      }
      *(_DWORD *)&v42[20 * v40 + 12] = v69;
      if (v50 + v31 <= 31)
      {
        exception = __cxa_allocate_exception(8uLL);
        int v93 = "Cannot read dbmd.mMixingGains[cfg].mHeightBalance";
        goto LABEL_167;
      }
      *(_DWORD *)(a3 + 28) = v31 - 32;
      if (v31 - 32 < 0)
      {
        if ((v49 & ~(v49 >> 63) & 0xFFFFFFFC) != 0 && v41 <= (unint64_t)v4)
        {
          unsigned int v76 = bswap32(*v4);
        }
        else
        {
          uint64_t v77 = 0;
          unsigned int v76 = v32;
          do
          {
            int v78 = (unsigned __int8 *)v4 + v77;
            unsigned int v79 = v76 << 8;
            *(_DWORD *)(a3 + 24) = v79;
            int v80 = 255;
            if ((unint64_t)v4 + v77 < v3 && (unint64_t)v78 >= v41) {
              int v80 = *v78;
            }
            unsigned int v76 = v80 | v79;
            *(_DWORD *)(a3 + 24) = v76;
            ++v77;
          }
          while (v77 != 4);
        }
        *(void *)a3 = ++v4;
        int v75 = (v76 >> v31) | v32;
        unsigned int v32 = v76 << -(char)v31;
        if (!v31) {
          unsigned int v32 = 0;
        }
        *(_DWORD *)(a3 + 24) = v32;
        *(_DWORD *)(a3 + 28) = v31;
      }
      else
      {
        v31 -= 32;
        int v75 = v32;
      }
      *(_DWORD *)&v42[20 * v40 + 16] = v75;
    }
    ++v40;
  }
  while (v40 != 9);
  if (v31 + 8 * ((int)v3 - (int)v4) < 7)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v93 = "Cannot read dbmd.mNumChannels";
LABEL_167:
    void *exception = v93;
    __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
  }
  unsigned int v81 = v32 >> 25;
  *(_DWORD *)(a3 + 28) = v31 - 7;
  if (v31 - 7 < 0)
  {
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v41 <= (unint64_t)v4)
    {
      unsigned int v32 = bswap32(*v4);
    }
    else
    {
      uint64_t v83 = 0;
      do
      {
        int v84 = (unsigned __int8 *)v4 + v83;
        unsigned int v85 = v32 << 8;
        *(_DWORD *)(a3 + 24) = v85;
        int v86 = 255;
        if ((unint64_t)v4 + v83 < v3 && (unint64_t)v84 >= v41) {
          int v86 = *v84;
        }
        unsigned int v32 = v86 | v85;
        *(_DWORD *)(a3 + 24) = v32;
        ++v83;
      }
      while (v83 != 4);
    }
    unsigned int v87 = v32 << (7 - v31);
    int v88 = v31 + 25;
    *(_DWORD *)(a3 + 28) = v88;
    *(void *)a3 = v4 + 1;
    v81 |= v32 >> v88;
    if (v88) {
      unsigned int v82 = v87;
    }
    else {
      unsigned int v82 = 0;
    }
  }
  else
  {
    unsigned int v82 = v32 << 7;
  }
  *(_DWORD *)(a3 + 24) = v82;
  a2[192] = v81 + 1;
  unsigned int v89 = a2 + 193;
  uint64_t v90 = v81 + 1;
  do
  {
    BOOL result = AT::TBitstreamReader<unsigned int>::GetBit(a3);
    *v89++ = result;
    --v90;
  }
  while (v90);
  return result;
}

void APAC::MetadataBitStreamParser::parseBinauralization(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 16);
  unint64_t v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    unsigned int v79 = "Cannot read binaural.mIsDirectBinauralization";
    goto LABEL_137;
  }
  unsigned int v7 = *(_DWORD *)(a3 + 24);
  unsigned int v8 = v7 >> 31;
  int v9 = v6 - 1;
  *(_DWORD *)(a3 + 28) = v6 - 1;
  if (v6 - 1 < 0)
  {
    unint64_t v11 = *(void *)(a3 + 8);
    if ((v5 & ~(v5 >> 63) & 0xFFFFFFFC) == 0 || v11 > (unint64_t)v4)
    {
      uint64_t v13 = 0;
      do
      {
        uint64_t v14 = (unsigned __int8 *)v4 + v13;
        unsigned int v15 = v7 << 8;
        *(_DWORD *)(a3 + 24) = v15;
        int v16 = 255;
        if ((unint64_t)v4 + v13 < v3 && (unint64_t)v14 >= v11) {
          int v16 = *v14;
        }
        unsigned int v7 = v16 | v15;
        *(_DWORD *)(a3 + 24) = v7;
        ++v13;
      }
      while (v13 != 4);
    }
    else
    {
      unsigned int v7 = bswap32(*v4);
    }
    int v18 = v6 + 31;
    BOOL v17 = v6 == -31;
    *(_DWORD *)(a3 + 28) = v6 + 31;
    *(void *)a3 = ++v4;
    v8 |= v7 >> (v6 + 31);
    if (v6 == -31) {
      unsigned int v10 = 0;
    }
    else {
      unsigned int v10 = v7 << (1 - v6);
    }
    if (v17) {
      int v9 = 0;
    }
    else {
      int v9 = v18;
    }
  }
  else
  {
    unsigned int v10 = 2 * v7;
  }
  *(_DWORD *)(a3 + 24) = v10;
  *(unsigned char *)a2 = v8 != 0;
  if (v8)
  {
    if (v9 + 8 * ((int)v3 - (int)v4) <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      unsigned int v79 = "Cannot read binaural.mChannelLayoutTag";
      goto LABEL_137;
    }
    *(_DWORD *)(a3 + 28) = v9 - 32;
    if (v9 - 32 < 0)
    {
      unint64_t v20 = *(void *)(a3 + 8);
      if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
        && v20 <= (unint64_t)v4)
      {
        unsigned int v21 = bswap32(*v4);
      }
      else
      {
        uint64_t v22 = 0;
        unsigned int v21 = v10;
        do
        {
          unint64_t v23 = (unsigned __int8 *)v4 + v22;
          unsigned int v24 = v21 << 8;
          *(_DWORD *)(a3 + 24) = v24;
          int v25 = 255;
          if ((unint64_t)v4 + v22 < v3 && (unint64_t)v23 >= v20) {
            int v25 = *v23;
          }
          unsigned int v21 = v25 | v24;
          *(_DWORD *)(a3 + 24) = v21;
          ++v22;
        }
        while (v22 != 4);
      }
      *(void *)a3 = ++v4;
      int v19 = (v21 >> v9) | v10;
      unsigned int v10 = v21 << -(char)v9;
      if (!v9) {
        unsigned int v10 = 0;
      }
      *(_DWORD *)(a3 + 24) = v10;
      *(_DWORD *)(a3 + 28) = v9;
    }
    else
    {
      v9 -= 32;
      int v19 = v10;
    }
    *(_DWORD *)(a2 + 4) = v19;
  }
  if (v9 + 8 * ((int)v3 - (int)v4) <= 2)
  {
    exception = __cxa_allocate_exception(8uLL);
    unsigned int v79 = "Cannot read binaural.mHRTFType";
    goto LABEL_137;
  }
  unsigned int v26 = v10 >> 29;
  int v27 = v9 - 3;
  *(_DWORD *)(a3 + 28) = v9 - 3;
  if (v9 - 3 < 0)
  {
    unint64_t v29 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v29 <= (unint64_t)v4)
    {
      unsigned int v10 = bswap32(*v4);
    }
    else
    {
      uint64_t v30 = 0;
      do
      {
        int v31 = (unsigned __int8 *)v4 + v30;
        unsigned int v32 = v10 << 8;
        *(_DWORD *)(a3 + 24) = v32;
        int v33 = 255;
        if ((unint64_t)v4 + v30 < v3 && (unint64_t)v31 >= v29) {
          int v33 = *v31;
        }
        unsigned int v10 = v33 | v32;
        *(_DWORD *)(a3 + 24) = v10;
        ++v30;
      }
      while (v30 != 4);
    }
    unsigned int v34 = v10 << (3 - v9);
    int v35 = v9 + 29;
    *(_DWORD *)(a3 + 28) = v35;
    *(void *)a3 = ++v4;
    v26 |= v10 >> v35;
    if (v35) {
      unsigned int v28 = v34;
    }
    else {
      unsigned int v28 = 0;
    }
    if (v35) {
      int v27 = v35;
    }
    else {
      int v27 = 0;
    }
  }
  else
  {
    unsigned int v28 = 8 * v10;
  }
  *(_DWORD *)(a3 + 24) = v28;
  *(unsigned char *)(a2 + 8) = v26;
  if (v26 != 2)
  {
    if (v26 != 1) {
      return;
    }
    if (v27 + 8 * ((int)v3 - (int)v4) > 7)
    {
      unsigned int v36 = HIBYTE(v28);
      *(_DWORD *)(a3 + 28) = v27 - 8;
      if (v27 - 8 < 0)
      {
        unint64_t v41 = *(void *)(a3 + 8);
        if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
          && v41 <= (unint64_t)v4)
        {
          unsigned int v28 = bswap32(*v4);
        }
        else
        {
          uint64_t v43 = 0;
          do
          {
            uint64_t v44 = (unsigned __int8 *)v4 + v43;
            unsigned int v45 = v28 << 8;
            *(_DWORD *)(a3 + 24) = v45;
            int v46 = 255;
            if ((unint64_t)v4 + v43 < v3 && (unint64_t)v44 >= v41) {
              int v46 = *v44;
            }
            unsigned int v28 = v46 | v45;
            *(_DWORD *)(a3 + 24) = v28;
            ++v43;
          }
          while (v43 != 4);
        }
        unsigned int v47 = v28 << (8 - v27);
        int v48 = v27 + 24;
        *(_DWORD *)(a3 + 28) = v48;
        *(void *)a3 = v4 + 1;
        v36 |= v28 >> v48;
        if (v48) {
          unsigned int v37 = v47;
        }
        else {
          unsigned int v37 = 0;
        }
      }
      else
      {
        unsigned int v37 = v28 << 8;
      }
      *(_DWORD *)(a3 + 24) = v37;
      *(unsigned char *)(a2 + 9) = v36;
      return;
    }
    exception = __cxa_allocate_exception(8uLL);
    unsigned int v79 = "Cannot read binaural.mPredefinedIR_ID";
LABEL_137:
    void *exception = v79;
    __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
  }
  if (v27 + 8 * ((int)v3 - (int)v4) <= 1)
  {
    exception = __cxa_allocate_exception(8uLL);
    unsigned int v79 = "Cannot read binaural.mDataLocationIndex";
    goto LABEL_137;
  }
  unsigned int v38 = v28 >> 30;
  int v39 = v27 - 2;
  *(_DWORD *)(a3 + 28) = v27 - 2;
  if (v27 - 2 < 0)
  {
    unint64_t v42 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v42 <= (unint64_t)v4)
    {
      unsigned int v28 = bswap32(*v4);
    }
    else
    {
      uint64_t v49 = 0;
      do
      {
        int v50 = (unsigned __int8 *)v4 + v49;
        unsigned int v51 = v28 << 8;
        *(_DWORD *)(a3 + 24) = v51;
        int v52 = 255;
        if ((unint64_t)v4 + v49 < v3 && (unint64_t)v50 >= v42) {
          int v52 = *v50;
        }
        unsigned int v28 = v52 | v51;
        *(_DWORD *)(a3 + 24) = v28;
        ++v49;
      }
      while (v49 != 4);
    }
    *(void *)a3 = ++v4;
    int v39 = v27 + 30;
    v38 |= v28 >> (v27 + 30);
    if (v27 == -30)
    {
      unsigned int v53 = 0;
      unsigned int v40 = 0;
      *(unsigned char *)(a2 + 14) = v38;
      *(void *)(a3 + 24) = 0xFFFFFFF700000000;
      goto LABEL_87;
    }
    unsigned int v40 = v28 << (2 - v27);
  }
  else
  {
    unsigned int v40 = 4 * v28;
  }
  *(unsigned char *)(a2 + 14) = v38;
  unsigned int v53 = v40 >> 23;
  int v54 = v39 - 9;
  *(_DWORD *)(a3 + 24) = v40;
  *(_DWORD *)(a3 + 28) = v39 - 9;
  if (v39 - 9 >= 0)
  {
    unsigned int v55 = v40 << 9;
    goto LABEL_97;
  }
  unint64_t v42 = *(void *)(a3 + 8);
LABEL_87:
  if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
    && v42 <= (unint64_t)v4)
  {
    unsigned int v40 = bswap32(*v4);
  }
  else
  {
    uint64_t v56 = 0;
    do
    {
      int v57 = (unsigned __int8 *)v4 + v56;
      unsigned int v58 = v40 << 8;
      *(_DWORD *)(a3 + 24) = v58;
      int v59 = 255;
      if ((unint64_t)v4 + v56 < v3 && (unint64_t)v57 >= v42) {
        int v59 = *v57;
      }
      unsigned int v40 = v59 | v58;
      *(_DWORD *)(a3 + 24) = v40;
      ++v56;
    }
    while (v56 != 4);
  }
  *(void *)a3 = ++v4;
  int v54 = v39 + 23;
  v53 |= v40 >> (v39 + 23);
  if (v39 == -23)
  {
    unsigned int v60 = 0;
    unsigned int v55 = 0;
    *(_WORD *)(a2 + 10) = v53;
    *(void *)(a3 + 24) = 0xFFFFFFF700000000;
    goto LABEL_101;
  }
  unsigned int v55 = v40 << (9 - v39);
LABEL_97:
  *(_WORD *)(a2 + 10) = v53;
  unsigned int v60 = v55 >> 23;
  int v61 = v54 - 9;
  *(_DWORD *)(a3 + 24) = v55;
  *(_DWORD *)(a3 + 28) = v54 - 9;
  if (v54 - 9 >= 0)
  {
    unsigned int v62 = v55 << 9;
    goto LABEL_115;
  }
  unint64_t v42 = *(void *)(a3 + 8);
LABEL_101:
  if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
    && v42 <= (unint64_t)v4)
  {
    unsigned int v55 = bswap32(*v4);
  }
  else
  {
    uint64_t v63 = 0;
    do
    {
      unsigned int v64 = (unsigned __int8 *)v4 + v63;
      unsigned int v65 = v55 << 8;
      *(_DWORD *)(a3 + 24) = v65;
      int v66 = 255;
      if ((unint64_t)v4 + v63 < v3 && (unint64_t)v64 >= v42) {
        int v66 = *v64;
      }
      unsigned int v55 = v66 | v65;
      *(_DWORD *)(a3 + 24) = v55;
      ++v63;
    }
    while (v63 != 4);
  }
  unsigned int v67 = v55 << (9 - v54);
  int v68 = v54 + 23;
  *(_DWORD *)(a3 + 28) = v68;
  *(void *)a3 = ++v4;
  v60 |= v55 >> v68;
  if (v68) {
    unsigned int v62 = v67;
  }
  else {
    unsigned int v62 = 0;
  }
  if (v68) {
    int v61 = v68;
  }
  else {
    int v61 = 0;
  }
LABEL_115:
  *(_DWORD *)(a3 + 24) = v62;
  *(_WORD *)(a2 + 12) = v60;
  if (v61 + 8 * ((int)v3 - (int)v4) <= 2)
  {
    exception = __cxa_allocate_exception(8uLL);
    unsigned int v79 = "Cannot read binaural.mFallbackCustomHRTF.mHRTFType";
    goto LABEL_137;
  }
  unsigned int v69 = v62 >> 29;
  *(_DWORD *)(a3 + 28) = v61 - 3;
  if (v61 - 3 < 0)
  {
    unint64_t v71 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v71 <= (unint64_t)v4)
    {
      unsigned int v62 = bswap32(*v4);
    }
    else
    {
      uint64_t v72 = 0;
      do
      {
        unsigned int v73 = (unsigned __int8 *)v4 + v72;
        unsigned int v74 = v62 << 8;
        *(_DWORD *)(a3 + 24) = v74;
        int v75 = 255;
        if ((unint64_t)v4 + v72 < v3 && (unint64_t)v73 >= v71) {
          int v75 = *v73;
        }
        unsigned int v62 = v75 | v74;
        *(_DWORD *)(a3 + 24) = v62;
        ++v72;
      }
      while (v72 != 4);
    }
    int v76 = v62 << (3 - v61);
    int v77 = v61 + 29;
    *(_DWORD *)(a3 + 28) = v77;
    *(void *)a3 = v4 + 1;
    v69 |= v62 >> v77;
    if (v77) {
      int v70 = v76;
    }
    else {
      int v70 = 0;
    }
  }
  else
  {
    int v70 = 8 * v62;
  }
  *(_DWORD *)(a3 + 24) = v70;
  *(unsigned char *)(a2 + 15) = v69;
}

{
  unint64_t v3;
  unsigned int *v4;
  uint64_t v5;
  int v6;
  unsigned int v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  unint64_t v11;
  uint64_t v13;
  unsigned __int8 *v14;
  unsigned int v15;
  int v16;
  BOOL v17;
  int v18;
  int v19;
  unint64_t v20;
  unsigned int v21;
  uint64_t v22;
  unsigned __int8 *v23;
  unsigned int v24;
  int v25;
  unsigned int v26;
  int v27;
  unsigned int v28;
  unint64_t v29;
  uint64_t v30;
  unsigned __int8 *v31;
  unsigned int v32;
  int v33;
  unsigned int v34;
  int v35;
  unsigned int v36;
  int v37;
  unint64_t v38;
  uint64_t v39;
  unsigned __int8 *v40;
  unsigned int v41;
  int v42;
  int v43;
  int v44;
  void *exception;
  const char *v46;

  unint64_t v3 = *(void *)(a3 + 16);
  unint64_t v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v46 = "Cannot read binaural.isDirectBinauralization";
    goto LABEL_74;
  }
  unsigned int v7 = *(_DWORD *)(a3 + 24);
  unsigned int v8 = v7 >> 31;
  int v9 = v6 - 1;
  *(_DWORD *)(a3 + 28) = v6 - 1;
  if (v6 - 1 < 0)
  {
    unint64_t v11 = *(void *)(a3 + 8);
    if ((v5 & ~(v5 >> 63) & 0xFFFFFFFC) == 0 || v11 > (unint64_t)v4)
    {
      uint64_t v13 = 0;
      do
      {
        uint64_t v14 = (unsigned __int8 *)v4 + v13;
        unsigned int v15 = v7 << 8;
        *(_DWORD *)(a3 + 24) = v15;
        int v16 = 255;
        if ((unint64_t)v4 + v13 < v3 && (unint64_t)v14 >= v11) {
          int v16 = *v14;
        }
        unsigned int v7 = v16 | v15;
        *(_DWORD *)(a3 + 24) = v7;
        ++v13;
      }
      while (v13 != 4);
    }
    else
    {
      unsigned int v7 = bswap32(*v4);
    }
    int v18 = v6 + 31;
    BOOL v17 = v6 == -31;
    *(_DWORD *)(a3 + 28) = v6 + 31;
    *(void *)a3 = ++v4;
    v8 |= v7 >> (v6 + 31);
    if (v6 == -31) {
      unsigned int v10 = 0;
    }
    else {
      unsigned int v10 = v7 << (1 - v6);
    }
    if (v17) {
      int v9 = 0;
    }
    else {
      int v9 = v18;
    }
  }
  else
  {
    unsigned int v10 = 2 * v7;
  }
  *(_DWORD *)(a3 + 24) = v10;
  *(unsigned char *)a2 = v8 != 0;
  if (!v8)
  {
    if (v9 + 8 * ((int)v3 - (int)v4) <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      int v46 = "Cannot read binaural.channelLayoutTag";
      goto LABEL_74;
    }
    *(_DWORD *)(a3 + 28) = v9 - 32;
    if (v9 - 32 < 0)
    {
      unint64_t v20 = *(void *)(a3 + 8);
      if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
        && v20 <= (unint64_t)v4)
      {
        unsigned int v21 = bswap32(*v4);
      }
      else
      {
        uint64_t v22 = 0;
        unsigned int v21 = v10;
        do
        {
          unint64_t v23 = (unsigned __int8 *)v4 + v22;
          unsigned int v24 = v21 << 8;
          *(_DWORD *)(a3 + 24) = v24;
          int v25 = 255;
          if ((unint64_t)v4 + v22 < v3 && (unint64_t)v23 >= v20) {
            int v25 = *v23;
          }
          unsigned int v21 = v25 | v24;
          *(_DWORD *)(a3 + 24) = v21;
          ++v22;
        }
        while (v22 != 4);
      }
      *(void *)a3 = ++v4;
      int v19 = (v21 >> v9) | v10;
      unsigned int v10 = v21 << -(char)v9;
      if (!v9) {
        unsigned int v10 = 0;
      }
      *(_DWORD *)(a3 + 24) = v10;
      *(_DWORD *)(a3 + 28) = v9;
    }
    else
    {
      v9 -= 32;
      int v19 = v10;
    }
    *(_DWORD *)(a2 + 4) = v19;
  }
  if (v9 + 8 * ((int)v3 - (int)v4) <= 2)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v46 = "Cannot read binaural.HRTFType";
    goto LABEL_74;
  }
  unsigned int v26 = v10 >> 29;
  int v27 = v9 - 3;
  *(_DWORD *)(a3 + 28) = v9 - 3;
  if (v9 - 3 < 0)
  {
    unint64_t v29 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v29 <= (unint64_t)v4)
    {
      unsigned int v10 = bswap32(*v4);
    }
    else
    {
      uint64_t v30 = 0;
      do
      {
        int v31 = (unsigned __int8 *)v4 + v30;
        unsigned int v32 = v10 << 8;
        *(_DWORD *)(a3 + 24) = v32;
        int v33 = 255;
        if ((unint64_t)v4 + v30 < v3 && (unint64_t)v31 >= v29) {
          int v33 = *v31;
        }
        unsigned int v10 = v33 | v32;
        *(_DWORD *)(a3 + 24) = v10;
        ++v30;
      }
      while (v30 != 4);
    }
    unsigned int v34 = v10 << (3 - v9);
    int v35 = v9 + 29;
    *(_DWORD *)(a3 + 28) = v35;
    *(void *)a3 = ++v4;
    v26 |= v10 >> v35;
    if (v35) {
      unsigned int v28 = v34;
    }
    else {
      unsigned int v28 = 0;
    }
    if (v35) {
      int v27 = v35;
    }
    else {
      int v27 = 0;
    }
  }
  else
  {
    unsigned int v28 = 8 * v10;
  }
  *(_DWORD *)(a3 + 24) = v28;
  *(unsigned char *)(a2 + 8) = v26;
  if (v26 == 1)
  {
    if (v27 + 8 * ((int)v3 - (int)v4) > 3)
    {
      unsigned int v36 = v28 >> 28;
      *(_DWORD *)(a3 + 28) = v27 - 4;
      if (v27 - 4 < 0)
      {
        unsigned int v38 = *(void *)(a3 + 8);
        if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
          && v38 <= (unint64_t)v4)
        {
          unsigned int v28 = bswap32(*v4);
        }
        else
        {
          int v39 = 0;
          do
          {
            unsigned int v40 = (unsigned __int8 *)v4 + v39;
            unint64_t v41 = v28 << 8;
            *(_DWORD *)(a3 + 24) = v41;
            unint64_t v42 = 255;
            if ((unint64_t)v4 + v39 < v3 && (unint64_t)v40 >= v38) {
              unint64_t v42 = *v40;
            }
            unsigned int v28 = v42 | v41;
            *(_DWORD *)(a3 + 24) = v28;
            ++v39;
          }
          while (v39 != 4);
        }
        uint64_t v43 = v28 << (4 - v27);
        uint64_t v44 = v27 + 28;
        *(_DWORD *)(a3 + 28) = v44;
        *(void *)a3 = v4 + 1;
        v36 |= v28 >> v44;
        if (v44) {
          unsigned int v37 = v43;
        }
        else {
          unsigned int v37 = 0;
        }
      }
      else
      {
        unsigned int v37 = 16 * v28;
      }
      *(_DWORD *)(a3 + 24) = v37;
      *(unsigned char *)(a2 + 9) = v36;
      return;
    }
    exception = __cxa_allocate_exception(8uLL);
    int v46 = "Cannot read binaural.codeBookID";
LABEL_74:
    void *exception = v46;
    __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
  }
}

void APAC::MetadataBitStreamParser::parseSPAD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  unint64_t v4 = *(void *)(a4 + 16);
  uint64_t v5 = *(unsigned int **)a4;
  uint64_t v6 = v4 - *(void *)a4;
  int v7 = *(_DWORD *)(a4 + 28);
  if (v7 + 8 * (int)v6 <= 1)
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = "Cannot read spad.mDataLocationIndex";
    __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
  }
  unsigned int v8 = *(_DWORD *)(a4 + 24);
  unsigned int v9 = v8 >> 30;
  int v10 = v7 - 2;
  *(_DWORD *)(a4 + 28) = v7 - 2;
  if (v7 - 2 < 0)
  {
    uint64_t v12 = v6 & ~(v6 >> 63) & 0xFFFFFFFC;
    unint64_t v13 = *(void *)(a4 + 8);
    if (v12) {
      BOOL v14 = v13 > (unint64_t)v5;
    }
    else {
      BOOL v14 = 1;
    }
    if (v14)
    {
      uint64_t v15 = 0;
      do
      {
        int v16 = (unsigned __int8 *)v5 + v15;
        unsigned int v17 = v8 << 8;
        *(_DWORD *)(a4 + 24) = v17;
        int v18 = 255;
        if ((unint64_t)v5 + v15 < v4 && (unint64_t)v16 >= v13) {
          int v18 = *v16;
        }
        unsigned int v8 = v18 | v17;
        *(_DWORD *)(a4 + 24) = v8;
        ++v15;
      }
      while (v15 != 4);
    }
    else
    {
      unsigned int v8 = bswap32(*v5);
    }
    *(void *)a4 = ++v5;
    int v10 = v7 + 30;
    v9 |= v8 >> (v7 + 30);
    if (v7 == -30)
    {
      unsigned int v19 = 0;
      unsigned int v11 = 0;
      *(unsigned char *)a2 = v9;
      *(void *)(a4 + 24) = 0xFFFFFFF700000000;
      goto LABEL_20;
    }
    unsigned int v11 = v8 << (2 - v7);
  }
  else
  {
    unsigned int v11 = 4 * v8;
  }
  *(unsigned char *)a2 = v9;
  unsigned int v19 = v11 >> 23;
  int v20 = v10 - 9;
  *(_DWORD *)(a4 + 24) = v11;
  *(_DWORD *)(a4 + 28) = v10 - 9;
  if (v10 - 9 >= 0)
  {
    unsigned int v21 = v11 << 9;
    goto LABEL_30;
  }
  unint64_t v13 = *(void *)(a4 + 8);
LABEL_20:
  if (((v4 - v5) & ~((uint64_t)(v4 - (void)v5) >> 63) & 0xFFFFFFFC) != 0
    && v13 <= (unint64_t)v5)
  {
    unsigned int v11 = bswap32(*v5);
  }
  else
  {
    uint64_t v22 = 0;
    do
    {
      unint64_t v23 = (unsigned __int8 *)v5 + v22;
      unsigned int v24 = v11 << 8;
      *(_DWORD *)(a4 + 24) = v24;
      int v25 = 255;
      if ((unint64_t)v5 + v22 < v4 && (unint64_t)v23 >= v13) {
        int v25 = *v23;
      }
      unsigned int v11 = v25 | v24;
      *(_DWORD *)(a4 + 24) = v11;
      ++v22;
    }
    while (v22 != 4);
  }
  *(void *)a4 = ++v5;
  int v20 = v10 + 23;
  v19 |= v11 >> (v10 + 23);
  if (v10 == -23)
  {
    unsigned int v26 = 0;
    unsigned int v21 = 0;
    *(_WORD *)(a2 + 2) = v19;
    *(void *)(a4 + 24) = 0xFFFFFFF700000000;
    goto LABEL_34;
  }
  unsigned int v21 = v11 << (9 - v10);
LABEL_30:
  *(_WORD *)(a2 + 2) = v19;
  unsigned int v26 = v21 >> 23;
  *(_DWORD *)(a4 + 24) = v21;
  *(_DWORD *)(a4 + 28) = v20 - 9;
  if (v20 - 9 >= 0)
  {
    unsigned int v27 = v21 << 9;
    goto LABEL_45;
  }
  unint64_t v13 = *(void *)(a4 + 8);
LABEL_34:
  if (((v4 - v5) & ~((uint64_t)(v4 - (void)v5) >> 63) & 0xFFFFFFFC) != 0
    && v13 <= (unint64_t)v5)
  {
    unsigned int v21 = bswap32(*v5);
  }
  else
  {
    uint64_t v28 = 0;
    do
    {
      unint64_t v29 = (unsigned __int8 *)v5 + v28;
      unsigned int v30 = v21 << 8;
      *(_DWORD *)(a4 + 24) = v30;
      int v31 = 255;
      if ((unint64_t)v5 + v28 < v4 && (unint64_t)v29 >= v13) {
        int v31 = *v29;
      }
      unsigned int v21 = v31 | v30;
      *(_DWORD *)(a4 + 24) = v21;
      ++v28;
    }
    while (v28 != 4);
  }
  *(_DWORD *)(a4 + 28) = v20 + 23;
  *(void *)a4 = v5 + 1;
  v26 |= v21 >> (v20 + 23);
  if (v20 == -23) {
    unsigned int v27 = 0;
  }
  else {
    unsigned int v27 = v21 << (9 - v20);
  }
LABEL_45:
  *(_DWORD *)(a4 + 24) = v27;
  *(_WORD *)(a2 + 4) = v26;
  uint64_t v32 = a2 + 8;
  APAC::MetadataBitStreamParser::parseFallbackSPAD(a1, v32, a3, a4);
}

void APAC::MetadataBitStreamParser::parseDistanceAttenuation(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 16);
  unint64_t v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 2)
  {
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v56 = "Cannot read distAttnParams.mAttnLawIndex";
    goto LABEL_82;
  }
  unsigned int v7 = *(_DWORD *)(a3 + 24);
  unsigned int v8 = v7 >> 29;
  int v9 = v6 - 3;
  *(_DWORD *)(a3 + 28) = v6 - 3;
  if (v6 - 3 < 0)
  {
    unint64_t v11 = *(void *)(a3 + 8);
    if ((v5 & ~(v5 >> 63) & 0xFFFFFFFC) == 0 || v11 > (unint64_t)v4)
    {
      uint64_t v13 = 0;
      do
      {
        BOOL v14 = (unsigned __int8 *)v4 + v13;
        unsigned int v15 = v7 << 8;
        *(_DWORD *)(a3 + 24) = v15;
        int v16 = 255;
        if ((unint64_t)v4 + v13 < v3 && (unint64_t)v14 >= v11) {
          int v16 = *v14;
        }
        unsigned int v7 = v16 | v15;
        *(_DWORD *)(a3 + 24) = v7;
        ++v13;
      }
      while (v13 != 4);
    }
    else
    {
      unsigned int v7 = bswap32(*v4);
    }
    int v18 = v6 + 29;
    BOOL v17 = v6 == -29;
    *(_DWORD *)(a3 + 28) = v6 + 29;
    *(void *)a3 = ++v4;
    v8 |= v7 >> (v6 + 29);
    if (v6 == -29) {
      unsigned int v10 = 0;
    }
    else {
      unsigned int v10 = v7 << (3 - v6);
    }
    if (v17) {
      int v9 = 0;
    }
    else {
      int v9 = v18;
    }
  }
  else
  {
    unsigned int v10 = 8 * v7;
  }
  *(_DWORD *)(a3 + 24) = v10;
  *(unsigned char *)a2 = v8;
  uint64_t v19 = v3 - (void)v4;
  if (v9 + 8 * ((int)v3 - (int)v4) <= 31)
  {
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v56 = "Cannot read distAttnParams.mDistNorm";
    goto LABEL_82;
  }
  *(_DWORD *)(a3 + 28) = v9 - 32;
  if (v9 - 32 < 0)
  {
    int v22 = v19 & ~(v19 >> 63);
    unint64_t v23 = *(void *)(a3 + 8);
    if ((v22 & 0xFFFFFFFC) != 0 && v23 <= (unint64_t)v4)
    {
      unsigned int v24 = bswap32(*v4);
    }
    else
    {
      uint64_t v25 = 0;
      unsigned int v24 = v10;
      do
      {
        unsigned int v26 = (unsigned __int8 *)v4 + v25;
        unsigned int v27 = v24 << 8;
        *(_DWORD *)(a3 + 24) = v27;
        int v28 = 255;
        if ((unint64_t)v4 + v25 < v3 && (unint64_t)v26 >= v23) {
          int v28 = *v26;
        }
        unsigned int v24 = v28 | v27;
        *(_DWORD *)(a3 + 24) = v24;
        ++v25;
      }
      while (v25 != 4);
    }
    *(void *)a3 = ++v4;
    int v21 = (v24 >> v9) | v10;
    unsigned int v10 = v24 << -(char)v9;
    if (!v9) {
      unsigned int v10 = 0;
    }
    *(_DWORD *)(a3 + 24) = v10;
    *(_DWORD *)(a3 + 28) = v9;
    uint64_t v19 = v3 - (void)v4;
    int v20 = 8 * (v3 - v4);
  }
  else
  {
    int v20 = 8 * v19;
    v9 -= 32;
    int v21 = v10;
  }
  *(_DWORD *)(a2 + 4) = v21;
  if (v20 + v9 <= 31)
  {
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v56 = "Cannot read distAttnParams.mRefDistance";
    goto LABEL_82;
  }
  *(_DWORD *)(a3 + 28) = v9 - 32;
  if (v9 - 32 < 0)
  {
    int v30 = v19 & ~(v19 >> 63);
    unint64_t v31 = *(void *)(a3 + 8);
    if ((v30 & 0xFFFFFFFC) != 0 && v31 <= (unint64_t)v4)
    {
      unsigned int v32 = bswap32(*v4);
    }
    else
    {
      uint64_t v33 = 0;
      unsigned int v32 = v10;
      do
      {
        unsigned int v34 = (unsigned __int8 *)v4 + v33;
        unsigned int v35 = v32 << 8;
        *(_DWORD *)(a3 + 24) = v35;
        int v36 = 255;
        if ((unint64_t)v4 + v33 < v3 && (unint64_t)v34 >= v31) {
          int v36 = *v34;
        }
        unsigned int v32 = v36 | v35;
        *(_DWORD *)(a3 + 24) = v32;
        ++v33;
      }
      while (v33 != 4);
    }
    *(void *)a3 = ++v4;
    int v29 = (v32 >> v9) | v10;
    unsigned int v10 = v32 << -(char)v9;
    if (!v9) {
      unsigned int v10 = 0;
    }
    *(_DWORD *)(a3 + 24) = v10;
    *(_DWORD *)(a3 + 28) = v9;
    uint64_t v19 = v3 - (void)v4;
    int v20 = 8 * (v3 - v4);
  }
  else
  {
    v9 -= 32;
    int v29 = v10;
  }
  *(_DWORD *)(a2 + 8) = v29;
  if (v20 + v9 <= 31)
  {
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v56 = "Cannot read distAttnParams.mMaxDistance";
    goto LABEL_82;
  }
  *(_DWORD *)(a3 + 28) = v9 - 32;
  if (v9 - 32 < 0)
  {
    int v38 = v19 & ~(v19 >> 63);
    unint64_t v39 = *(void *)(a3 + 8);
    if ((v38 & 0xFFFFFFFC) != 0 && v39 <= (unint64_t)v4)
    {
      unsigned int v40 = bswap32(*v4);
    }
    else
    {
      uint64_t v41 = 0;
      unsigned int v40 = v10;
      do
      {
        unint64_t v42 = (unsigned __int8 *)v4 + v41;
        unsigned int v43 = v40 << 8;
        *(_DWORD *)(a3 + 24) = v43;
        int v44 = 255;
        if ((unint64_t)v4 + v41 < v3 && (unint64_t)v42 >= v39) {
          int v44 = *v42;
        }
        unsigned int v40 = v44 | v43;
        *(_DWORD *)(a3 + 24) = v40;
        ++v41;
      }
      while (v41 != 4);
    }
    *(void *)a3 = ++v4;
    int v37 = (v40 >> v9) | v10;
    unsigned int v10 = v40 << -(char)v9;
    if (!v9) {
      unsigned int v10 = 0;
    }
    *(_DWORD *)(a3 + 24) = v10;
    *(_DWORD *)(a3 + 28) = v9;
    uint64_t v19 = v3 - (void)v4;
    int v20 = 8 * (v3 - v4);
  }
  else
  {
    v9 -= 32;
    int v37 = v10;
  }
  *(_DWORD *)(a2 + 12) = v37;
  if ((v20 + v9 < 0) ^ __OFADD__(v20, v9) | (v20 + v9 == 0))
  {
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v56 = "Cannot read distAttnParams.mAttnNormIndex";
LABEL_82:
    void *exception = v56;
    __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
  }
  unsigned int v45 = v10 >> 31;
  *(_DWORD *)(a3 + 28) = v9 - 1;
  if (v9 - 1 < 0)
  {
    int v47 = v19 & ~(v19 >> 63);
    unint64_t v48 = *(void *)(a3 + 8);
    if ((v47 & 0xFFFFFFFC) != 0 && v48 <= (unint64_t)v4)
    {
      unsigned int v10 = bswap32(*v4);
    }
    else
    {
      uint64_t v49 = 0;
      do
      {
        int v50 = (unsigned __int8 *)v4 + v49;
        unsigned int v51 = v10 << 8;
        *(_DWORD *)(a3 + 24) = v51;
        int v52 = 255;
        if ((unint64_t)v4 + v49 < v3 && (unint64_t)v50 >= v48) {
          int v52 = *v50;
        }
        unsigned int v10 = v52 | v51;
        *(_DWORD *)(a3 + 24) = v10;
        ++v49;
      }
      while (v49 != 4);
    }
    int v53 = v10 << (1 - v9);
    int v54 = v9 + 31;
    *(_DWORD *)(a3 + 28) = v54;
    *(void *)a3 = v4 + 1;
    v45 |= v10 >> v54;
    if (v54) {
      int v46 = v53;
    }
    else {
      int v46 = 0;
    }
  }
  else
  {
    int v46 = 2 * v10;
  }
  *(_DWORD *)(a3 + 24) = v46;
  *(unsigned char *)(a2 + 16) = v45 != 0;
}

void APAC::MetadataBitStreamParser::parseGenericRenderingConfig(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 16);
  unint64_t v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    unsigned int v74 = "Cannot read cfg.mHasPreset";
    goto LABEL_118;
  }
  unsigned int v7 = *(_DWORD *)(a3 + 24);
  unsigned int v8 = v7 >> 31;
  int v9 = v6 - 1;
  *(_DWORD *)(a3 + 28) = v6 - 1;
  if (v6 - 1 < 0)
  {
    unint64_t v11 = *(void *)(a3 + 8);
    if ((v5 & ~(v5 >> 63) & 0xFFFFFFFC) == 0 || v11 > (unint64_t)v4)
    {
      uint64_t v13 = 0;
      do
      {
        BOOL v14 = (unsigned __int8 *)v4 + v13;
        unsigned int v15 = v7 << 8;
        *(_DWORD *)(a3 + 24) = v15;
        int v16 = 255;
        if ((unint64_t)v4 + v13 < v3 && (unint64_t)v14 >= v11) {
          int v16 = *v14;
        }
        unsigned int v7 = v16 | v15;
        *(_DWORD *)(a3 + 24) = v7;
        ++v13;
      }
      while (v13 != 4);
    }
    else
    {
      unsigned int v7 = bswap32(*v4);
    }
    int v18 = v6 + 31;
    BOOL v17 = v6 == -31;
    *(_DWORD *)(a3 + 28) = v6 + 31;
    *(void *)a3 = ++v4;
    v8 |= v7 >> (v6 + 31);
    if (v6 == -31) {
      unsigned int v10 = 0;
    }
    else {
      unsigned int v10 = v7 << (1 - v6);
    }
    if (v17) {
      int v9 = 0;
    }
    else {
      int v9 = v18;
    }
  }
  else
  {
    unsigned int v10 = 2 * v7;
  }
  *(_DWORD *)(a3 + 24) = v10;
  *(unsigned char *)a2 = v8 != 0;
  uint64_t v19 = v3 - (void)v4;
  int v20 = v9 + 8 * (v3 - v4);
  if (v8)
  {
    if (v20 > 10)
    {
      unsigned int v21 = v10 >> 21;
      *(_DWORD *)(a3 + 28) = v9 - 11;
      if (v9 - 11 < 0)
      {
        unint64_t v26 = *(void *)(a3 + 8);
        if ((v19 & ~(v19 >> 63) & 0xFFFFFFFC) != 0 && v26 <= (unint64_t)v4)
        {
          unsigned int v10 = bswap32(*v4);
        }
        else
        {
          uint64_t v28 = 0;
          do
          {
            int v29 = (unsigned __int8 *)v4 + v28;
            unsigned int v30 = v10 << 8;
            *(_DWORD *)(a3 + 24) = v30;
            int v31 = 255;
            if ((unint64_t)v4 + v28 < v3 && (unint64_t)v29 >= v26) {
              int v31 = *v29;
            }
            unsigned int v10 = v31 | v30;
            *(_DWORD *)(a3 + 24) = v10;
            ++v28;
          }
          while (v28 != 4);
        }
        unsigned int v32 = v10 << (11 - v9);
        int v33 = v9 + 21;
        *(_DWORD *)(a3 + 28) = v33;
        *(void *)a3 = v4 + 1;
        v21 |= v10 >> v33;
        if (v33) {
          unsigned int v22 = v32;
        }
        else {
          unsigned int v22 = 0;
        }
      }
      else
      {
        unsigned int v22 = v10 << 11;
      }
      *(_DWORD *)(a3 + 24) = v22;
      *(_WORD *)(a2 + 2) = v21;
      return;
    }
    exception = __cxa_allocate_exception(8uLL);
    unsigned int v74 = "Cannot read cfg.mPresetIndex";
LABEL_118:
    void *exception = v74;
    __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
  }
  if (v20 <= 1)
  {
    exception = __cxa_allocate_exception(8uLL);
    unsigned int v74 = "Cannot read cfg.mDataLocationIndex";
    goto LABEL_118;
  }
  unsigned int v23 = v10 >> 30;
  int v24 = v9 - 2;
  *(_DWORD *)(a3 + 28) = v9 - 2;
  if (v9 - 2 < 0)
  {
    unint64_t v27 = *(void *)(a3 + 8);
    if ((v19 & ~(v19 >> 63) & 0xFFFFFFFC) != 0 && v27 <= (unint64_t)v4)
    {
      unsigned int v10 = bswap32(*v4);
    }
    else
    {
      uint64_t v34 = 0;
      do
      {
        unsigned int v35 = (unsigned __int8 *)v4 + v34;
        unsigned int v36 = v10 << 8;
        *(_DWORD *)(a3 + 24) = v36;
        int v37 = 255;
        if ((unint64_t)v4 + v34 < v3 && (unint64_t)v35 >= v27) {
          int v37 = *v35;
        }
        unsigned int v10 = v37 | v36;
        *(_DWORD *)(a3 + 24) = v10;
        ++v34;
      }
      while (v34 != 4);
    }
    *(void *)a3 = ++v4;
    int v24 = v9 + 30;
    v23 |= v10 >> (v9 + 30);
    if (v9 == -30)
    {
      unsigned int v38 = 0;
      unsigned int v25 = 0;
      *(unsigned char *)(a2 + 4) = v23;
      *(void *)(a3 + 24) = 0xFFFFFFF700000000;
      goto LABEL_53;
    }
    unsigned int v25 = v10 << (2 - v9);
  }
  else
  {
    unsigned int v25 = 4 * v10;
  }
  *(unsigned char *)(a2 + 4) = v23;
  unsigned int v38 = v25 >> 23;
  int v39 = v24 - 9;
  *(_DWORD *)(a3 + 24) = v25;
  *(_DWORD *)(a3 + 28) = v24 - 9;
  if (v24 - 9 >= 0)
  {
    unsigned int v40 = v25 << 9;
    goto LABEL_63;
  }
  unint64_t v27 = *(void *)(a3 + 8);
LABEL_53:
  if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
    && v27 <= (unint64_t)v4)
  {
    unsigned int v25 = bswap32(*v4);
  }
  else
  {
    uint64_t v41 = 0;
    do
    {
      unint64_t v42 = (unsigned __int8 *)v4 + v41;
      unsigned int v43 = v25 << 8;
      *(_DWORD *)(a3 + 24) = v43;
      int v44 = 255;
      if ((unint64_t)v4 + v41 < v3 && (unint64_t)v42 >= v27) {
        int v44 = *v42;
      }
      unsigned int v25 = v44 | v43;
      *(_DWORD *)(a3 + 24) = v25;
      ++v41;
    }
    while (v41 != 4);
  }
  *(void *)a3 = ++v4;
  int v39 = v24 + 23;
  v38 |= v25 >> (v24 + 23);
  if (v24 == -23)
  {
    unsigned int v45 = 0;
    unsigned int v40 = 0;
    *(_WORD *)(a2 + 6) = v38;
    *(void *)(a3 + 24) = 0xFFFFFFF700000000;
    goto LABEL_67;
  }
  unsigned int v40 = v25 << (9 - v24);
LABEL_63:
  *(_WORD *)(a2 + 6) = v38;
  unsigned int v45 = v40 >> 23;
  int v46 = v39 - 9;
  *(_DWORD *)(a3 + 24) = v40;
  *(_DWORD *)(a3 + 28) = v39 - 9;
  if (v39 - 9 >= 0)
  {
    unsigned int v47 = v40 << 9;
    goto LABEL_81;
  }
  unint64_t v27 = *(void *)(a3 + 8);
LABEL_67:
  if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
    && v27 <= (unint64_t)v4)
  {
    unsigned int v40 = bswap32(*v4);
  }
  else
  {
    uint64_t v48 = 0;
    do
    {
      uint64_t v49 = (unsigned __int8 *)v4 + v48;
      unsigned int v50 = v40 << 8;
      *(_DWORD *)(a3 + 24) = v50;
      int v51 = 255;
      if ((unint64_t)v4 + v48 < v3 && (unint64_t)v49 >= v27) {
        int v51 = *v49;
      }
      unsigned int v40 = v51 | v50;
      *(_DWORD *)(a3 + 24) = v40;
      ++v48;
    }
    while (v48 != 4);
  }
  unsigned int v52 = v40 << (9 - v39);
  int v53 = v39 + 23;
  *(_DWORD *)(a3 + 28) = v53;
  *(void *)a3 = ++v4;
  v45 |= v40 >> v53;
  if (v53) {
    unsigned int v47 = v52;
  }
  else {
    unsigned int v47 = 0;
  }
  if (v53) {
    int v46 = v53;
  }
  else {
    int v46 = 0;
  }
LABEL_81:
  *(_DWORD *)(a3 + 24) = v47;
  *(_WORD *)(a2 + 8) = v45;
  if (v46 + 8 * ((int)v3 - (int)v4) <= 10)
  {
    exception = __cxa_allocate_exception(8uLL);
    unsigned int v74 = "Cannot read cfg.mFallbackIndex";
    goto LABEL_118;
  }
  unsigned int v54 = v47 >> 21;
  int v55 = v46 - 11;
  *(_DWORD *)(a3 + 28) = v46 - 11;
  if (v46 - 11 < 0)
  {
    unint64_t v57 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v57 <= (unint64_t)v4)
    {
      unsigned int v47 = bswap32(*v4);
    }
    else
    {
      uint64_t v58 = 0;
      do
      {
        int v59 = (unsigned __int8 *)v4 + v58;
        unsigned int v60 = v47 << 8;
        *(_DWORD *)(a3 + 24) = v60;
        int v61 = 255;
        if ((unint64_t)v4 + v58 < v3 && (unint64_t)v59 >= v57) {
          int v61 = *v59;
        }
        unsigned int v47 = v61 | v60;
        *(_DWORD *)(a3 + 24) = v47;
        ++v58;
      }
      while (v58 != 4);
    }
    int v63 = v46 + 21;
    BOOL v62 = v46 == -21;
    *(_DWORD *)(a3 + 28) = v46 + 21;
    *(void *)a3 = ++v4;
    v54 |= v47 >> (v46 + 21);
    if (v46 == -21) {
      unsigned int v56 = 0;
    }
    else {
      unsigned int v56 = v47 << (11 - v46);
    }
    if (v62) {
      int v55 = 0;
    }
    else {
      int v55 = v63;
    }
  }
  else
  {
    unsigned int v56 = v47 << 11;
  }
  *(_DWORD *)(a3 + 24) = v56;
  *(_WORD *)(a2 + 10) = v54;
  if (v55 + 8 * ((int)v3 - (int)v4) <= 16)
  {
    exception = __cxa_allocate_exception(8uLL);
    unsigned int v74 = "Cannot read cfg.mDataByteSize";
    goto LABEL_118;
  }
  unsigned int v64 = v56 >> 15;
  *(_DWORD *)(a3 + 28) = v55 - 17;
  if (v55 - 17 < 0)
  {
    unint64_t v66 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v66 <= (unint64_t)v4)
    {
      unsigned int v56 = bswap32(*v4);
    }
    else
    {
      uint64_t v67 = 0;
      do
      {
        int v68 = (unsigned __int8 *)v4 + v67;
        unsigned int v69 = v56 << 8;
        *(_DWORD *)(a3 + 24) = v69;
        int v70 = 255;
        if ((unint64_t)v4 + v67 < v3 && (unint64_t)v68 >= v66) {
          int v70 = *v68;
        }
        unsigned int v56 = v70 | v69;
        *(_DWORD *)(a3 + 24) = v56;
        ++v67;
      }
      while (v67 != 4);
    }
    unsigned int v71 = v56 << (17 - v55);
    int v72 = v55 + 15;
    *(_DWORD *)(a3 + 28) = v72;
    *(void *)a3 = v4 + 1;
    v64 |= v56 >> v72;
    if (v72) {
      unsigned int v65 = v71;
    }
    else {
      unsigned int v65 = 0;
    }
  }
  else
  {
    unsigned int v65 = v56 << 17;
  }
  *(_DWORD *)(a3 + 24) = v65;
  *(_DWORD *)(a2 + 12) = v64;
}

void APAC::MetadataBitStreamParser::parseChannelBedHeadphoneMetadata(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  unsigned int v6 = *(_DWORD *)(a3 + 24);
  int v5 = *(_DWORD *)(a3 + 28);
  unsigned int v7 = v6 >> 28;
  int v8 = v5 - 4;
  *(_DWORD *)(a3 + 28) = v5 - 4;
  if (v5 - 4 < 0)
  {
    unint64_t v11 = *(void *)(a3 + 8);
    unint64_t v10 = *(void *)(a3 + 16);
    uint64_t v12 = *(unsigned int **)a3;
    if (((v10 - *(_DWORD *)a3) & ~((uint64_t)(v10 - *(void *)a3) >> 63) & 0xFFFFFFFC) == 0
      || v11 > (unint64_t)v12)
    {
      uint64_t v14 = 0;
      do
      {
        unsigned int v15 = (unsigned __int8 *)v12 + v14;
        unsigned int v16 = v6 << 8;
        *(_DWORD *)(a3 + 24) = v16;
        int v17 = 255;
        if ((unint64_t)v12 + v14 < v10 && (unint64_t)v15 >= v11) {
          int v17 = *v15;
        }
        unsigned int v6 = v17 | v16;
        *(_DWORD *)(a3 + 24) = v6;
        ++v14;
      }
      while (v14 != 4);
    }
    else
    {
      unsigned int v6 = bswap32(*v12);
    }
    int v18 = v12 + 1;
    *(void *)a3 = v12 + 1;
    int v8 = v5 + 28;
    v7 |= v6 >> (v5 + 28);
    if (v5 == -28)
    {
      unsigned int v20 = 0;
      unsigned int v9 = 0;
      unsigned __int8 v19 = v7 + 1;
      *a2 = v19;
      *(void *)(a3 + 24) = 0xFFFFFFF800000000;
      goto LABEL_19;
    }
    unsigned int v9 = v6 << (4 - v5);
  }
  else
  {
    unsigned int v9 = 16 * v6;
  }
  unsigned __int8 v19 = v7 + 1;
  *a2 = v19;
  unsigned int v20 = HIBYTE(v9);
  int v21 = v8 - 8;
  *(_DWORD *)(a3 + 24) = v9;
  *(_DWORD *)(a3 + 28) = v8 - 8;
  if (v8 - 8 >= 0)
  {
    unsigned int v22 = v9 << 8;
    goto LABEL_35;
  }
  unint64_t v11 = *(void *)(a3 + 8);
  unint64_t v10 = *(void *)(a3 + 16);
  int v18 = *(unsigned int **)a3;
LABEL_19:
  if (((v10 - v18) & ~((uint64_t)(v10 - (void)v18) >> 63) & 0xFFFFFFFC) == 0
    || v11 > (unint64_t)v18)
  {
    uint64_t v24 = 0;
    do
    {
      unsigned int v25 = (unsigned __int8 *)v18 + v24;
      unsigned int v26 = v9 << 8;
      *(_DWORD *)(a3 + 24) = v26;
      int v27 = 255;
      if ((unint64_t)v18 + v24 < v10 && (unint64_t)v25 >= v11) {
        int v27 = *v25;
      }
      unsigned int v9 = v27 | v26;
      *(_DWORD *)(a3 + 24) = v9;
      ++v24;
    }
    while (v24 != 4);
  }
  else
  {
    unsigned int v9 = bswap32(*v18);
  }
  unsigned int v28 = v9 << (8 - v8);
  int v29 = v8 + 24;
  *(_DWORD *)(a3 + 28) = v29;
  *(void *)a3 = v18 + 1;
  v20 |= v9 >> v29;
  if (v29) {
    unsigned int v22 = v28;
  }
  else {
    unsigned int v22 = 0;
  }
  if (v29) {
    int v21 = v29;
  }
  else {
    int v21 = 0;
  }
LABEL_35:
  *(_DWORD *)(a3 + 24) = v22;
  a2[1] = v20 + 1;
  if (((v20 + 1) & 0x100) != 0)
  {
    int v30 = -8;
  }
  else
  {
    unsigned int v31 = 0;
    do
    {
      unsigned int v33 = *(_DWORD *)(a3 + 24);
      int v32 = *(_DWORD *)(a3 + 28);
      unsigned int v34 = v33 >> 29;
      *(_DWORD *)(a3 + 28) = v32 - 3;
      if (v32 - 3 < 0)
      {
        unint64_t v37 = *(void *)(a3 + 8);
        unint64_t v36 = *(void *)(a3 + 16);
        unsigned int v38 = *(unsigned int **)a3;
        if (((v36 - *(_DWORD *)a3) & ~((uint64_t)(v36 - *(void *)a3) >> 63) & 0xFFFFFFFC) == 0
          || v37 > (unint64_t)v38)
        {
          uint64_t v40 = 0;
          do
          {
            uint64_t v41 = (unsigned __int8 *)v38 + v40;
            unsigned int v42 = v33 << 8;
            *(_DWORD *)(a3 + 24) = v42;
            int v43 = 255;
            if ((unint64_t)v38 + v40 < v36 && (unint64_t)v41 >= v37) {
              int v43 = *v41;
            }
            unsigned int v33 = v43 | v42;
            *(_DWORD *)(a3 + 24) = v33;
            ++v40;
          }
          while (v40 != 4);
        }
        else
        {
          unsigned int v33 = bswap32(*v38);
        }
        int v44 = v33 << (3 - v32);
        int v45 = v32 + 29;
        *(_DWORD *)(a3 + 28) = v45;
        *(void *)a3 = v38 + 1;
        v34 |= v33 >> v45;
        if (v45) {
          int v35 = v44;
        }
        else {
          int v35 = 0;
        }
      }
      else
      {
        int v35 = 8 * v33;
      }
      *(_DWORD *)(a3 + 24) = v35;
      unsigned int v47 = (unsigned char *)*((void *)a2 + 2);
      unint64_t v46 = *((void *)a2 + 3);
      if ((unint64_t)v47 >= v46)
      {
        unint64_t v49 = *((void *)a2 + 1);
        unsigned int v50 = &v47[-v49];
        uint64_t v51 = (uint64_t)&v47[-v49 + 1];
        if (v51 < 0) {
          std::vector<float>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v52 = v46 - v49;
        if (2 * v52 > v51) {
          uint64_t v51 = 2 * v52;
        }
        if (v52 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v53 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v53 = v51;
        }
        if (v53) {
          unsigned int v54 = (char *)operator new(v53);
        }
        else {
          unsigned int v54 = 0;
        }
        int v55 = &v50[(void)v54];
        unsigned int v56 = &v50[(void)v54];
        unsigned char *v56 = v34;
        uint64_t v48 = v56 + 1;
        if (v47 != (unsigned char *)v49)
        {
          unint64_t v57 = &v47[~v49];
          do
          {
            char v58 = *--v47;
            (v57--)[(void)v54] = v58;
          }
          while (v47 != (unsigned char *)v49);
          int v55 = v54;
        }
        *((void *)a2 + 1) = v55;
        *((void *)a2 + 2) = v48;
        *((void *)a2 + 3) = &v54[v53];
        if (v49) {
          operator delete((void *)v49);
        }
      }
      else
      {
        unsigned char *v47 = v34;
        uint64_t v48 = v47 + 1;
      }
      *((void *)a2 + 2) = v48;
      ++v31;
      unsigned int v59 = a2[1];
    }
    while (v31 < v59);
    unsigned __int8 v19 = *a2;
    int v21 = *(_DWORD *)(a3 + 28);
    int v30 = -3 * v59 - 8;
  }
  int v60 = v30 + 8 * v19;
  unsigned int v61 = v60 - v21;
  if (v60 > v21)
  {
    *(void *)(a3 + 24) = 0;
    int v21 = 0;
    if (v61 >= 0x20)
    {
      *(void *)a3 += (v61 >> 3) & 0x1FFFFFFC;
      int v60 = v61 & 0x1F;
    }
    else
    {
      int v60 = v61;
    }
  }
  if ((v60 - 33) >= 0xFFFFFFE0)
  {
    int v62 = *(_DWORD *)(a3 + 24);
    int v63 = v21 - v60;
    *(_DWORD *)(a3 + 28) = v63;
    if (v63 < 0)
    {
      unint64_t v66 = *(void *)(a3 + 8);
      unint64_t v65 = *(void *)(a3 + 16);
      uint64_t v67 = *(unsigned int **)a3;
      if (((v65 - *(_DWORD *)a3) & ~((uint64_t)(v65 - *(void *)a3) >> 63) & 0xFFFFFFFC) != 0
        && v66 <= (unint64_t)v67)
      {
        int v62 = bswap32(*v67);
      }
      else
      {
        uint64_t v68 = 0;
        do
        {
          unsigned int v69 = (unsigned __int8 *)v67 + v68;
          int v70 = v62 << 8;
          *(_DWORD *)(a3 + 24) = v70;
          int v71 = 255;
          if ((unint64_t)v67 + v68 < v65 && (unint64_t)v69 >= v66) {
            int v71 = *v69;
          }
          int v62 = v71 | v70;
          *(_DWORD *)(a3 + 24) = v62;
          ++v68;
        }
        while (v68 != 4);
      }
      int v72 = v62 << -(char)v63;
      int v73 = v63 + 32;
      *(_DWORD *)(a3 + 28) = v73;
      *(void *)a3 = v67 + 1;
      if (v73) {
        int v64 = v72;
      }
      else {
        int v64 = 0;
      }
    }
    else
    {
      int v64 = v62 << v60;
    }
    *(_DWORD *)(a3 + 24) = v64;
  }
}

void APAC::MetadataBitStreamParser::parseFallbackSPAD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v6 = 0;
  unint64_t v8 = *(void *)(a4 + 8);
  unint64_t v7 = *(void *)(a4 + 16);
  unsigned int v9 = *(unsigned int **)a4;
  uint64_t v10 = a2 + 2;
  unsigned int v12 = *(_DWORD *)(a4 + 24);
  int v11 = *(_DWORD *)(a4 + 28);
  do
  {
    if (v11 + 8 * ((int)v7 - (int)v9) <= 7)
    {
      exception = __cxa_allocate_exception(8uLL);
      int v105 = "Cannot read fallback.mDeviceID[n]";
      goto LABEL_172;
    }
    unsigned int v13 = HIBYTE(v12);
    *(_DWORD *)(a4 + 28) = v11 - 8;
    if (v11 - 8 < 0)
    {
      if (((v7 - v9) & ~((uint64_t)(v7 - (void)v9) >> 63) & 0xFFFFFFFC) != 0
        && v8 <= (unint64_t)v9)
      {
        unsigned int v12 = bswap32(*v9);
      }
      else
      {
        uint64_t v14 = 0;
        do
        {
          unsigned int v15 = (unsigned __int8 *)v9 + v14;
          unsigned int v16 = v12 << 8;
          *(_DWORD *)(a4 + 24) = v16;
          int v17 = 255;
          if ((unint64_t)v9 + v14 < v7 && (unint64_t)v15 >= v8) {
            int v17 = *v15;
          }
          unsigned int v12 = v17 | v16;
          *(_DWORD *)(a4 + 24) = v12;
          ++v14;
        }
        while (v14 != 4);
      }
      unsigned int v18 = v12 << (8 - v11);
      v11 += 24;
      *(_DWORD *)(a4 + 28) = v11;
      *(void *)a4 = ++v9;
      v13 |= v12 >> v11;
      if (v11) {
        unsigned int v12 = v18;
      }
      else {
        unsigned int v12 = 0;
      }
      if (!v11) {
        int v11 = 0;
      }
    }
    else
    {
      v12 <<= 8;
      v11 -= 8;
    }
    *(_DWORD *)(a4 + 24) = v12;
    *(unsigned char *)(v10 + v6) = v13;
    if (!(_BYTE)v13) {
      break;
    }
    ++v6;
  }
  while (v6 != 8);
  if (v11 + 8 * ((int)v7 - (int)v9) <= 3)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v105 = "Cannot read fallback.mOrientation";
    goto LABEL_172;
  }
  unsigned int v19 = v12 >> 28;
  int v20 = v11 - 4;
  *(_DWORD *)(a4 + 28) = v11 - 4;
  if (v11 - 4 < 0)
  {
    if (((v7 - v9) & ~((uint64_t)(v7 - (void)v9) >> 63) & 0xFFFFFFFC) != 0
      && v8 <= (unint64_t)v9)
    {
      unsigned int v12 = bswap32(*v9);
    }
    else
    {
      uint64_t v22 = 0;
      do
      {
        unsigned int v23 = (unsigned __int8 *)v9 + v22;
        unsigned int v24 = v12 << 8;
        *(_DWORD *)(a4 + 24) = v24;
        int v25 = 255;
        if ((unint64_t)v9 + v22 < v7 && (unint64_t)v23 >= v8) {
          int v25 = *v23;
        }
        unsigned int v12 = v25 | v24;
        *(_DWORD *)(a4 + 24) = v12;
        ++v22;
      }
      while (v22 != 4);
    }
    unsigned int v26 = v12 << (4 - v11);
    int v27 = v11 + 28;
    *(_DWORD *)(a4 + 28) = v27;
    *(void *)a4 = ++v9;
    v19 |= v12 >> v27;
    if (v27) {
      unsigned int v21 = v26;
    }
    else {
      unsigned int v21 = 0;
    }
    if (v27) {
      int v20 = v27;
    }
    else {
      int v20 = 0;
    }
  }
  else
  {
    unsigned int v21 = 16 * v12;
  }
  *(_DWORD *)(a4 + 24) = v21;
  *(unsigned char *)a2 = v19;
  if (v20 + 8 * ((int)v7 - (int)v9) <= 7)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v105 = "Cannot read fallback.mNumMicrophones";
    goto LABEL_172;
  }
  unsigned int v28 = HIBYTE(v21);
  *(_DWORD *)(a4 + 28) = v20 - 8;
  if (v20 - 8 < 0)
  {
    if (((v7 - v9) & ~((uint64_t)(v7 - (void)v9) >> 63) & 0xFFFFFFFC) != 0
      && v8 <= (unint64_t)v9)
    {
      unsigned int v21 = bswap32(*v9);
    }
    else
    {
      uint64_t v30 = 0;
      do
      {
        unsigned int v31 = (unsigned __int8 *)v9 + v30;
        unsigned int v32 = v21 << 8;
        *(_DWORD *)(a4 + 24) = v32;
        int v33 = 255;
        if ((unint64_t)v9 + v30 < v7 && (unint64_t)v31 >= v8) {
          int v33 = *v31;
        }
        unsigned int v21 = v33 | v32;
        *(_DWORD *)(a4 + 24) = v21;
        ++v30;
      }
      while (v30 != 4);
    }
    *(_DWORD *)(a4 + 28) = v20 + 24;
    *(void *)a4 = v9 + 1;
    v28 |= v21 >> (v20 + 24);
    if (v20 == -24) {
      unsigned int v29 = 0;
    }
    else {
      unsigned int v29 = v21 << (8 - v20);
    }
  }
  else
  {
    unsigned int v29 = v21 << 8;
  }
  *(_DWORD *)(a4 + 24) = v29;
  *(unsigned char *)(a2 + 1) = v28;
  unint64_t v34 = v28;
  if (a3)
  {
    unint64_t v35 = *(void *)(a2 + 16);
    unint64_t v36 = *(char **)(a2 + 24);
    if (v28 <= (unint64_t)&v36[-v35])
    {
      if (v28 < (unint64_t)&v36[-v35]) {
        *(void *)(a2 + 24) = v35 + v28;
      }
    }
    else
    {
      uint64_t v37 = *(void *)(a2 + 32);
      if (v37 - (uint64_t)v36 >= v28 - (unint64_t)&v36[-v35])
      {
        bzero(*(void **)(a2 + 24), v28 - (void)&v36[-v35]);
        *(void *)(a2 + 24) = v34 + v35;
      }
      else
      {
        unint64_t v38 = v37 - v35;
        uint64_t v39 = 2 * v38;
        if (2 * v38 <= v28) {
          uint64_t v39 = v28;
        }
        if (v38 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v40 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v40 = v39;
        }
        uint64_t v41 = (char *)operator new(v40);
        unsigned int v42 = &v41[v40];
        int v43 = &v41[v34];
        bzero(&v36[(void)v41 - v35], v34 - (void)&v36[-v35]);
        if (v36 == (char *)v35)
        {
          uint64_t v41 = &v36[(void)v41 - v35];
        }
        else
        {
          int v44 = &v36[~v35];
          do
          {
            char v45 = *--v36;
            (v44--)[(void)v41] = v45;
          }
          while (v36 != (char *)v35);
        }
        *(void *)(a2 + 16) = v41;
        *(void *)(a2 + 24) = v43;
        *(void *)(a2 + 32) = v42;
        if (v35) {
          operator delete((void *)v35);
        }
      }
    }
    std::vector<float>::resize((char **)(a2 + 40), v34);
    std::vector<float>::resize((char **)(a2 + 64), v34);
    std::vector<float>::resize((char **)(a2 + 88), v34);
    unint64_t v46 = *(void *)(a2 + 112);
    unsigned int v47 = *(char **)(a2 + 120);
    if (v34 <= (unint64_t)&v47[-v46])
    {
      if (v34 < (unint64_t)&v47[-v46]) {
        *(void *)(a2 + 120) = v46 + v34;
      }
    }
    else
    {
      uint64_t v48 = *(void *)(a2 + 128);
      if (v48 - (uint64_t)v47 >= v34 - (unint64_t)&v47[-v46])
      {
        bzero(*(void **)(a2 + 120), v34 - (void)&v47[-v46]);
        *(void *)(a2 + 120) = v34 + v46;
      }
      else
      {
        unint64_t v49 = v48 - v46;
        uint64_t v50 = 2 * v49;
        if (2 * v49 <= v34) {
          uint64_t v50 = v34;
        }
        if (v49 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v51 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v51 = v50;
        }
        unint64_t v52 = (char *)operator new(v51);
        size_t v53 = &v52[v51];
        unsigned int v54 = &v52[v34];
        bzero(&v47[(void)v52 - v46], v34 - (void)&v47[-v46]);
        if (v47 == (char *)v46)
        {
          unint64_t v52 = &v47[(void)v52 - v46];
        }
        else
        {
          int v55 = &v47[~v46];
          do
          {
            char v56 = *--v47;
            (v55--)[(void)v52] = v56;
          }
          while (v47 != (char *)v46);
        }
        *(void *)(a2 + 112) = v52;
        *(void *)(a2 + 120) = v54;
        *(void *)(a2 + 128) = v53;
        if (v46) {
          operator delete((void *)v46);
        }
      }
    }
  }
  if (v34)
  {
    uint64_t v57 = 0;
    unsigned int v58 = *(_DWORD *)(a4 + 24);
    int v59 = *(_DWORD *)(a4 + 28);
    unint64_t v61 = *(void *)(a4 + 8);
    unint64_t v60 = *(void *)(a4 + 16);
    int v62 = *(unsigned int **)a4;
    uint64_t v63 = *(void *)(a2 + 16);
    uint64_t v64 = *(void *)(a2 + 40);
    uint64_t v65 = *(void *)(a2 + 64);
    uint64_t v66 = *(void *)(a2 + 88);
    uint64_t v67 = *(void *)(a2 + 112);
    while (1)
    {
      if (v59 + 8 * ((int)v60 - (int)v62) <= 3)
      {
        exception = __cxa_allocate_exception(8uLL);
        int v105 = "Cannot read fallback.mMicType[n]";
        goto LABEL_172;
      }
      unsigned int v68 = v58 >> 28;
      int v69 = v59 - 4;
      *(_DWORD *)(a4 + 28) = v59 - 4;
      if (v59 - 4 < 0)
      {
        if (((v60 - v62) & ~((uint64_t)(v60 - (void)v62) >> 63) & 0xFFFFFFFC) != 0
          && v61 <= (unint64_t)v62)
        {
          unsigned int v58 = bswap32(*v62);
        }
        else
        {
          uint64_t v71 = 0;
          do
          {
            int v72 = (unsigned __int8 *)v62 + v71;
            unsigned int v73 = v58 << 8;
            *(_DWORD *)(a4 + 24) = v73;
            int v74 = 255;
            if ((unint64_t)v62 + v71 < v60 && (unint64_t)v72 >= v61) {
              int v74 = *v72;
            }
            unsigned int v58 = v74 | v73;
            *(_DWORD *)(a4 + 24) = v58;
            ++v71;
          }
          while (v71 != 4);
        }
        unsigned int v75 = v58 << (4 - v59);
        int v76 = v59 + 28;
        *(_DWORD *)(a4 + 28) = v76;
        *(void *)a4 = ++v62;
        v68 |= v58 >> v76;
        if (v76) {
          unsigned int v70 = v75;
        }
        else {
          unsigned int v70 = 0;
        }
        if (v76) {
          int v69 = v76;
        }
        else {
          int v69 = 0;
        }
      }
      else
      {
        unsigned int v70 = 16 * v58;
      }
      *(_DWORD *)(a4 + 24) = v70;
      *(unsigned char *)(v63 + v57) = v68;
      uint64_t v77 = v60 - (void)v62;
      if (v69 + 8 * ((int)v60 - (int)v62) <= 31)
      {
        exception = __cxa_allocate_exception(8uLL);
        int v105 = "Cannot read fallback.mMicPosAzimuth[n]";
        goto LABEL_172;
      }
      *(_DWORD *)(a4 + 28) = v69 - 32;
      if (v69 - 32 < 0)
      {
        if ((v77 & ~(v77 >> 63) & 0xFFFFFFFC) != 0 && v61 <= (unint64_t)v62)
        {
          unsigned int v80 = bswap32(*v62);
        }
        else
        {
          uint64_t v81 = 0;
          unsigned int v80 = v70;
          do
          {
            unsigned int v82 = (unsigned __int8 *)v62 + v81;
            unsigned int v83 = v80 << 8;
            *(_DWORD *)(a4 + 24) = v83;
            int v84 = 255;
            if ((unint64_t)v62 + v81 < v60 && (unint64_t)v82 >= v61) {
              int v84 = *v82;
            }
            unsigned int v80 = v84 | v83;
            *(_DWORD *)(a4 + 24) = v80;
            ++v81;
          }
          while (v81 != 4);
        }
        *(void *)a4 = ++v62;
        int v79 = (v80 >> v69) | v70;
        unsigned int v70 = v80 << -(char)v69;
        if (!v69) {
          unsigned int v70 = 0;
        }
        *(_DWORD *)(a4 + 24) = v70;
        *(_DWORD *)(a4 + 28) = v69;
        uint64_t v77 = v60 - (void)v62;
        int v78 = 8 * (v60 - v62);
      }
      else
      {
        int v78 = 8 * v77;
        v69 -= 32;
        int v79 = v70;
      }
      *(_DWORD *)(v64 + 4 * v57) = v79;
      if (v78 + v69 <= 31)
      {
        exception = __cxa_allocate_exception(8uLL);
        int v105 = "Cannot read fallback.mMicPosElevation[n]";
        goto LABEL_172;
      }
      *(_DWORD *)(a4 + 28) = v69 - 32;
      if (v69 - 32 < 0)
      {
        if ((v77 & ~(v77 >> 63) & 0xFFFFFFFC) != 0 && v61 <= (unint64_t)v62)
        {
          unsigned int v86 = bswap32(*v62);
        }
        else
        {
          uint64_t v87 = 0;
          unsigned int v86 = v70;
          do
          {
            int v88 = (unsigned __int8 *)v62 + v87;
            unsigned int v89 = v86 << 8;
            *(_DWORD *)(a4 + 24) = v89;
            int v90 = 255;
            if ((unint64_t)v62 + v87 < v60 && (unint64_t)v88 >= v61) {
              int v90 = *v88;
            }
            unsigned int v86 = v90 | v89;
            *(_DWORD *)(a4 + 24) = v86;
            ++v87;
          }
          while (v87 != 4);
        }
        *(void *)a4 = ++v62;
        int v85 = (v86 >> v69) | v70;
        unsigned int v70 = v86 << -(char)v69;
        if (!v69) {
          unsigned int v70 = 0;
        }
        *(_DWORD *)(a4 + 24) = v70;
        *(_DWORD *)(a4 + 28) = v69;
        uint64_t v77 = v60 - (void)v62;
        int v78 = 8 * (v60 - v62);
      }
      else
      {
        v69 -= 32;
        int v85 = v70;
      }
      *(_DWORD *)(v65 + 4 * v57) = v85;
      if (v78 + v69 <= 31)
      {
        exception = __cxa_allocate_exception(8uLL);
        int v105 = "Cannot read fallback.mMicPosRadius[n]";
        goto LABEL_172;
      }
      *(_DWORD *)(a4 + 28) = v69 - 32;
      if (v69 - 32 < 0)
      {
        if ((v77 & ~(v77 >> 63) & 0xFFFFFFFC) != 0 && v61 <= (unint64_t)v62)
        {
          unsigned int v92 = bswap32(*v62);
        }
        else
        {
          uint64_t v93 = 0;
          unsigned int v92 = v70;
          do
          {
            unsigned int v94 = (unsigned __int8 *)v62 + v93;
            unsigned int v95 = v92 << 8;
            *(_DWORD *)(a4 + 24) = v95;
            int v96 = 255;
            if ((unint64_t)v62 + v93 < v60 && (unint64_t)v94 >= v61) {
              int v96 = *v94;
            }
            unsigned int v92 = v96 | v95;
            *(_DWORD *)(a4 + 24) = v92;
            ++v93;
          }
          while (v93 != 4);
        }
        *(void *)a4 = ++v62;
        int v91 = (v92 >> v69) | v70;
        unsigned int v70 = v92 << -(char)v69;
        if (!v69) {
          unsigned int v70 = 0;
        }
        *(_DWORD *)(a4 + 24) = v70;
        *(_DWORD *)(a4 + 28) = v69;
        uint64_t v77 = v60 - (void)v62;
        int v78 = 8 * (v60 - v62);
      }
      else
      {
        v69 -= 32;
        int v91 = v70;
      }
      *(_DWORD *)(v66 + 4 * v57) = v91;
      if (v78 + v69 <= 2) {
        break;
      }
      unsigned int v97 = v70 >> 29;
      int v59 = v69 - 3;
      *(_DWORD *)(a4 + 28) = v69 - 3;
      if (v69 - 3 < 0)
      {
        if ((v77 & ~(v77 >> 63) & 0xFFFFFFFC) != 0 && v61 <= (unint64_t)v62)
        {
          unsigned int v70 = bswap32(*v62);
        }
        else
        {
          uint64_t v98 = 0;
          do
          {
            unint64_t v99 = (unsigned __int8 *)v62 + v98;
            unsigned int v100 = v70 << 8;
            *(_DWORD *)(a4 + 24) = v100;
            int v101 = 255;
            if ((unint64_t)v62 + v98 < v60 && (unint64_t)v99 >= v61) {
              int v101 = *v99;
            }
            unsigned int v70 = v101 | v100;
            *(_DWORD *)(a4 + 24) = v70;
            ++v98;
          }
          while (v98 != 4);
        }
        unsigned int v102 = v70 << (3 - v69);
        int v103 = v69 + 29;
        *(_DWORD *)(a4 + 28) = v103;
        *(void *)a4 = ++v62;
        v97 |= v70 >> v103;
        if (v103) {
          unsigned int v58 = v102;
        }
        else {
          unsigned int v58 = 0;
        }
        if (v103) {
          int v59 = v103;
        }
        else {
          int v59 = 0;
        }
      }
      else
      {
        unsigned int v58 = 8 * v70;
      }
      *(_DWORD *)(a4 + 24) = v58;
      *(unsigned char *)(v67 + v57++) = v97;
      if (v57 == v34) {
        return;
      }
    }
    exception = __cxa_allocate_exception(8uLL);
    int v105 = "Cannot read fallback.mMicDirection[n]";
LABEL_172:
    void *exception = v105;
    __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
  }
}

void APAC::MetadataBitStreamParser::parseGroupDynamicData(uint64_t a1, BOOL *a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 16);
  unint64_t v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v33 = "Cannot read grpDD.hasData";
    goto LABEL_41;
  }
  unsigned int v9 = *(_DWORD *)(a3 + 24);
  unsigned int v10 = v9 >> 31;
  int v11 = v6 - 1;
  *(_DWORD *)(a3 + 28) = v6 - 1;
  if (v6 - 1 < 0)
  {
    unint64_t v13 = *(void *)(a3 + 8);
    if ((v5 & ~(v5 >> 63) & 0xFFFFFFFC) == 0 || v13 > (unint64_t)v4)
    {
      uint64_t v15 = 0;
      do
      {
        unsigned int v16 = (unsigned __int8 *)v4 + v15;
        unsigned int v17 = v9 << 8;
        *(_DWORD *)(a3 + 24) = v17;
        int v18 = 255;
        if ((unint64_t)v4 + v15 < v3 && (unint64_t)v16 >= v13) {
          int v18 = *v16;
        }
        unsigned int v9 = v18 | v17;
        *(_DWORD *)(a3 + 24) = v9;
        ++v15;
      }
      while (v15 != 4);
    }
    else
    {
      unsigned int v9 = bswap32(*v4);
    }
    int v20 = v6 + 31;
    BOOL v19 = v6 == -31;
    *(_DWORD *)(a3 + 28) = v6 + 31;
    *(void *)a3 = ++v4;
    v10 |= v9 >> (v6 + 31);
    if (v6 == -31) {
      unsigned int v12 = 0;
    }
    else {
      unsigned int v12 = v9 << (1 - v6);
    }
    if (v19) {
      int v11 = 0;
    }
    else {
      int v11 = v20;
    }
  }
  else
  {
    unsigned int v12 = 2 * v9;
  }
  *(_DWORD *)(a3 + 24) = v12;
  *a2 = v10 != 0;
  if (v10)
  {
    if (v11 + 8 * ((int)v3 - (int)v4) > 6)
    {
      unsigned int v21 = v12 >> 25;
      *(_DWORD *)(a3 + 28) = v11 - 7;
      if (v11 - 7 < 0)
      {
        unint64_t v23 = *(void *)(a3 + 8);
        if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
          && v23 <= (unint64_t)v4)
        {
          unsigned int v12 = bswap32(*v4);
        }
        else
        {
          uint64_t v24 = 0;
          do
          {
            int v25 = (unsigned __int8 *)v4 + v24;
            unsigned int v26 = v12 << 8;
            *(_DWORD *)(a3 + 24) = v26;
            int v27 = 255;
            if ((unint64_t)v4 + v24 < v3 && (unint64_t)v25 >= v23) {
              int v27 = *v25;
            }
            unsigned int v12 = v27 | v26;
            *(_DWORD *)(a3 + 24) = v12;
            ++v24;
          }
          while (v24 != 4);
        }
        unsigned int v28 = v12 << (7 - v11);
        int v29 = v11 + 25;
        *(_DWORD *)(a3 + 28) = v29;
        *(void *)a3 = v4 + 1;
        v21 |= v12 >> v29;
        if (v29) {
          unsigned int v22 = v28;
        }
        else {
          unsigned int v22 = 0;
        }
      }
      else
      {
        unsigned int v22 = v12 << 7;
      }
      *(_DWORD *)(a3 + 24) = v22;
      a2[1] = v21;
      if ((_BYTE)v21)
      {
        unint64_t v30 = 0;
        unsigned int v31 = a2 + 4;
        do
        {
          APAC::MetadataBitStreamParser::parseDynamicGroup(a1, v31, a3);
          ++v30;
          v31 += 256;
        }
        while (v30 < a2[1]);
      }
      return;
    }
    exception = __cxa_allocate_exception(8uLL);
    int v33 = "Cannot read grpDD.groupCount";
LABEL_41:
    void *exception = v33;
    __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
  }
}

void APAC::MetadataBitStreamParser::parseSceneComponenentDynamicData(uint64_t a1, unsigned char *a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 16);
  unint64_t v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 6)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v43 = "Cannot read scDD.ASCCount";
LABEL_45:
    void *exception = v43;
    __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
  }
  unsigned int v9 = *(_DWORD *)(a3 + 24);
  unsigned int v10 = v9 >> 25;
  *(_DWORD *)(a3 + 28) = v6 - 7;
  if (v6 - 7 < 0)
  {
    uint64_t v12 = v5 & ~(v5 >> 63) & 0xFFFFFFFC;
    unint64_t v13 = *(void *)(a3 + 8);
    if (v12) {
      BOOL v14 = v13 > (unint64_t)v4;
    }
    else {
      BOOL v14 = 1;
    }
    if (v14)
    {
      uint64_t v15 = 0;
      do
      {
        unsigned int v16 = (unsigned __int8 *)v4 + v15;
        unsigned int v17 = v9 << 8;
        *(_DWORD *)(a3 + 24) = v17;
        int v18 = 255;
        if ((unint64_t)v4 + v15 < v3 && (unint64_t)v16 >= v13) {
          int v18 = *v16;
        }
        unsigned int v9 = v18 | v17;
        *(_DWORD *)(a3 + 24) = v9;
        ++v15;
      }
      while (v15 != 4);
    }
    else
    {
      unsigned int v9 = bswap32(*v4);
    }
    unsigned int v19 = v9 << (7 - v6);
    int v20 = v6 + 25;
    *(_DWORD *)(a3 + 28) = v20;
    *(void *)a3 = v4 + 1;
    v10 |= v9 >> v20;
    if (v20) {
      unsigned int v11 = v19;
    }
    else {
      unsigned int v11 = 0;
    }
  }
  else
  {
    unsigned int v11 = v9 << 7;
  }
  *(_DWORD *)(a3 + 24) = v11;
  *a2 = v10;
  if ((_BYTE)v10)
  {
    uint64_t v21 = 0;
    while (1)
    {
      unint64_t v22 = *(void *)(a3 + 16);
      unint64_t v23 = *(unsigned int **)a3;
      uint64_t v24 = v22 - *(void *)a3;
      int v25 = *(_DWORD *)(a3 + 28);
      if (v25 + 8 * (int)v24 <= 1)
      {
        exception = __cxa_allocate_exception(8uLL);
        int v43 = "Cannot read scDD.ASCData[n].ASCType";
        goto LABEL_45;
      }
      unsigned int v26 = *(_DWORD *)(a3 + 24);
      unsigned int v27 = v26 >> 30;
      *(_DWORD *)(a3 + 28) = v25 - 2;
      if (v25 - 2 < 0)
      {
        uint64_t v29 = v24 & ~(v24 >> 63) & 0xFFFFFFFC;
        unint64_t v30 = *(void *)(a3 + 8);
        if (!v29 || v30 > (unint64_t)v23)
        {
          uint64_t v32 = 0;
          do
          {
            int v33 = (unsigned __int8 *)v23 + v32;
            unsigned int v34 = v26 << 8;
            *(_DWORD *)(a3 + 24) = v34;
            int v35 = 255;
            if ((unint64_t)v23 + v32 < v22 && (unint64_t)v33 >= v30) {
              int v35 = *v33;
            }
            unsigned int v26 = v35 | v34;
            *(_DWORD *)(a3 + 24) = v26;
            ++v32;
          }
          while (v32 != 4);
        }
        else
        {
          unsigned int v26 = bswap32(*v23);
        }
        unsigned int v36 = v26 << (2 - v25);
        int v37 = v25 + 30;
        *(_DWORD *)(a3 + 28) = v37;
        *(void *)a3 = v23 + 1;
        v27 |= v26 >> v37;
        int v28 = v37 ? v36 : 0;
      }
      else
      {
        int v28 = 4 * v26;
      }
      *(_DWORD *)(a3 + 24) = v28;
      a2[9752 * v21 + 4] = v27;
      if (v27 == 2) {
        break;
      }
      if (v27 == 1)
      {
        APAC::MetadataBitStreamParser::parseObjectMetadata(a1, (uint64_t)&a2[9752 * v21 + 72], a3);
        goto LABEL_42;
      }
      if (!(_BYTE)v27)
      {
        uint64_t v38 = (uint64_t)&a2[9752 * v21 + 8];
LABEL_40:
        APAC::MetadataBitStreamParser::parseCommonDynamicMetadata(a1, v38, a3);
      }
LABEL_42:
      uint64_t v39 = &a2[9752 * v21];
      APAC::MetadataBitStreamParser::parseProprietaryDynamicData(a1, (uint64_t)(v39 + 7576), a3);
      APAC::MetadataBitStreamParser::parseExtendedData(v40, (uint64_t)(v39 + 7700), a3);
      APAC::MetadataBitStreamParser::parseExtendedData(v41, (uint64_t)(v39 + 8728), a3);
      if (++v21 >= (unint64_t)*a2) {
        return;
      }
    }
    uint64_t v38 = (uint64_t)&a2[9752 * v21 + 40];
    goto LABEL_40;
  }
}

void APAC::MetadataBitStreamParser::parseExtendedData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 16);
  unint64_t v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v40 = "Cannot read extData.hasData";
    goto LABEL_58;
  }
  unsigned int v7 = *(_DWORD *)(a3 + 24);
  unsigned int v8 = v7 >> 31;
  int v9 = v6 - 1;
  *(_DWORD *)(a3 + 28) = v6 - 1;
  if (v6 - 1 < 0)
  {
    unint64_t v11 = *(void *)(a3 + 8);
    if ((v5 & ~(v5 >> 63) & 0xFFFFFFFC) == 0 || v11 > (unint64_t)v4)
    {
      uint64_t v13 = 0;
      do
      {
        BOOL v14 = (unsigned __int8 *)v4 + v13;
        unsigned int v15 = v7 << 8;
        *(_DWORD *)(a3 + 24) = v15;
        int v16 = 255;
        if ((unint64_t)v4 + v13 < v3 && (unint64_t)v14 >= v11) {
          int v16 = *v14;
        }
        unsigned int v7 = v16 | v15;
        *(_DWORD *)(a3 + 24) = v7;
        ++v13;
      }
      while (v13 != 4);
    }
    else
    {
      unsigned int v7 = bswap32(*v4);
    }
    unsigned int v17 = v7 << (1 - v6);
    int v18 = v6 + 31;
    *(_DWORD *)(a3 + 28) = v18;
    *(void *)a3 = ++v4;
    v8 |= v7 >> v18;
    if (v18) {
      unsigned int v10 = v17;
    }
    else {
      unsigned int v10 = 0;
    }
    if (v18) {
      int v9 = v18;
    }
    else {
      int v9 = 0;
    }
  }
  else
  {
    unsigned int v10 = 2 * v7;
  }
  *(_DWORD *)(a3 + 24) = v10;
  *(unsigned char *)a2 = v8 != 0;
  if (v8)
  {
    if (v9 + 8 * ((int)v3 - (int)v4) <= 9)
    {
      exception = __cxa_allocate_exception(8uLL);
      uint64_t v40 = "Cannot read extData.chunkSize";
    }
    else
    {
      unsigned int v19 = v10 >> 22;
      int v20 = v9 - 10;
      *(_DWORD *)(a3 + 28) = v9 - 10;
      if (v9 - 10 < 0)
      {
        unint64_t v22 = *(void *)(a3 + 8);
        if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
          && v22 <= (unint64_t)v4)
        {
          unsigned int v10 = bswap32(*v4);
        }
        else
        {
          uint64_t v23 = 0;
          do
          {
            uint64_t v24 = (unsigned __int8 *)v4 + v23;
            unsigned int v25 = v10 << 8;
            *(_DWORD *)(a3 + 24) = v25;
            int v26 = 255;
            if ((unint64_t)v4 + v23 < v3 && (unint64_t)v24 >= v22) {
              int v26 = *v24;
            }
            unsigned int v10 = v26 | v25;
            *(_DWORD *)(a3 + 24) = v10;
            ++v23;
          }
          while (v23 != 4);
        }
        unsigned int v27 = v10 << (10 - v9);
        int v28 = v9 + 22;
        *(_DWORD *)(a3 + 28) = v28;
        *(void *)a3 = ++v4;
        v19 |= v10 >> v28;
        if (v28) {
          unsigned int v21 = v27;
        }
        else {
          unsigned int v21 = 0;
        }
        if (v28) {
          int v20 = v28;
        }
        else {
          int v20 = 0;
        }
      }
      else
      {
        unsigned int v21 = v10 << 10;
      }
      uint64_t v29 = 0;
      *(_DWORD *)(a3 + 24) = v21;
      *(_WORD *)(a2 + 2) = v19;
      int v30 = (unsigned __int16)v19;
      unint64_t v31 = *(void *)(a3 + 8);
      uint64_t v32 = (v30 + 1);
      while (v20 + 8 * ((int)v3 - (int)v4) > 7)
      {
        unsigned int v33 = HIBYTE(v21);
        *(_DWORD *)(a3 + 28) = v20 - 8;
        if (v20 - 8 < 0)
        {
          if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
            && v31 <= (unint64_t)v4)
          {
            unsigned int v21 = bswap32(*v4);
          }
          else
          {
            uint64_t v34 = 0;
            do
            {
              int v35 = (unsigned __int8 *)v4 + v34;
              unsigned int v36 = v21 << 8;
              *(_DWORD *)(a3 + 24) = v36;
              int v37 = 255;
              if ((unint64_t)v4 + v34 < v3 && (unint64_t)v35 >= v31) {
                int v37 = *v35;
              }
              unsigned int v21 = v37 | v36;
              *(_DWORD *)(a3 + 24) = v21;
              ++v34;
            }
            while (v34 != 4);
          }
          unsigned int v38 = v21 << (8 - v20);
          v20 += 24;
          *(_DWORD *)(a3 + 28) = v20;
          *(void *)a3 = ++v4;
          v33 |= v21 >> v20;
          if (v20) {
            unsigned int v21 = v38;
          }
          else {
            unsigned int v21 = 0;
          }
          if (!v20) {
            int v20 = 0;
          }
        }
        else
        {
          v21 <<= 8;
          v20 -= 8;
        }
        *(_DWORD *)(a3 + 24) = v21;
        *(unsigned char *)(a2 + v29++ + 4) = v33;
        if (v29 == v32) {
          return;
        }
      }
      exception = __cxa_allocate_exception(8uLL);
      uint64_t v40 = "Cannot read extData.dataChunk[n]";
    }
LABEL_58:
    void *exception = v40;
    __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
  }
}

void APAC::MetadataBitStreamParser::parseCommonDynamicMetadata(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 16);
  unint64_t v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v98 = "Cannot read cmmMd.hasADMMetadata";
    goto LABEL_180;
  }
  unsigned int v7 = *(_DWORD *)(a3 + 24);
  unsigned int v8 = v7 >> 31;
  int v9 = v6 - 1;
  *(_DWORD *)(a3 + 28) = v6 - 1;
  if (v6 - 1 < 0)
  {
    unint64_t v11 = *(void *)(a3 + 8);
    if ((v5 & ~(v5 >> 63) & 0xFFFFFFFC) == 0 || v11 > (unint64_t)v4)
    {
      uint64_t v13 = 0;
      do
      {
        BOOL v14 = (unsigned __int8 *)v4 + v13;
        unsigned int v15 = v7 << 8;
        *(_DWORD *)(a3 + 24) = v15;
        int v16 = 255;
        if ((unint64_t)v4 + v13 < v3 && (unint64_t)v14 >= v11) {
          int v16 = *v14;
        }
        unsigned int v7 = v16 | v15;
        *(_DWORD *)(a3 + 24) = v7;
        ++v13;
      }
      while (v13 != 4);
    }
    else
    {
      unsigned int v7 = bswap32(*v4);
    }
    int v18 = v6 + 31;
    BOOL v17 = v6 == -31;
    *(_DWORD *)(a3 + 28) = v6 + 31;
    *(void *)a3 = ++v4;
    v8 |= v7 >> (v6 + 31);
    if (v6 == -31) {
      unsigned int v10 = 0;
    }
    else {
      unsigned int v10 = v7 << (1 - v6);
    }
    if (v17) {
      int v9 = 0;
    }
    else {
      int v9 = v18;
    }
  }
  else
  {
    unsigned int v10 = 2 * v7;
  }
  *(_DWORD *)(a3 + 24) = v10;
  *(unsigned char *)a2 = v8 != 0;
  if (v8)
  {
    if (v9 + 8 * ((int)v3 - (int)v4) <= 0)
    {
      exception = __cxa_allocate_exception(8uLL);
      uint64_t v98 = "Cannot read cmmMd.absoluteDistance.hasData";
      goto LABEL_180;
    }
    unsigned int v19 = v10 >> 31;
    int v20 = v9 - 1;
    *(_DWORD *)(a3 + 28) = v9 - 1;
    if (v9 - 1 < 0)
    {
      unint64_t v22 = *(void *)(a3 + 8);
      if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
        && v22 <= (unint64_t)v4)
      {
        unsigned int v10 = bswap32(*v4);
      }
      else
      {
        uint64_t v23 = 0;
        do
        {
          uint64_t v24 = (unsigned __int8 *)v4 + v23;
          unsigned int v25 = v10 << 8;
          *(_DWORD *)(a3 + 24) = v25;
          int v26 = 255;
          if ((unint64_t)v4 + v23 < v3 && (unint64_t)v24 >= v22) {
            int v26 = *v24;
          }
          unsigned int v10 = v26 | v25;
          *(_DWORD *)(a3 + 24) = v10;
          ++v23;
        }
        while (v23 != 4);
      }
      unsigned int v27 = v10 << (1 - v9);
      int v28 = v9 + 31;
      *(_DWORD *)(a3 + 28) = v28;
      *(void *)a3 = ++v4;
      v19 |= v10 >> v28;
      if (v28) {
        unsigned int v21 = v27;
      }
      else {
        unsigned int v21 = 0;
      }
      if (v28) {
        int v20 = v28;
      }
      else {
        int v20 = 0;
      }
    }
    else
    {
      unsigned int v21 = 2 * v10;
    }
    *(_DWORD *)(a3 + 24) = v21;
    *(unsigned char *)(a2 + 4) = v19 != 0;
    if (v19)
    {
      if (v20 + 8 * ((int)v3 - (int)v4) <= 31)
      {
        exception = __cxa_allocate_exception(8uLL);
        uint64_t v98 = "Cannot read cmmMd.absoluteDistance.distance";
        goto LABEL_180;
      }
      *(_DWORD *)(a3 + 28) = v20 - 32;
      if (v20 - 32 < 0)
      {
        unint64_t v30 = *(void *)(a3 + 8);
        if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
          && v30 <= (unint64_t)v4)
        {
          unsigned int v31 = bswap32(*v4);
        }
        else
        {
          uint64_t v32 = 0;
          unsigned int v31 = v21;
          do
          {
            unsigned int v33 = (unsigned __int8 *)v4 + v32;
            unsigned int v34 = v31 << 8;
            *(_DWORD *)(a3 + 24) = v34;
            int v35 = 255;
            if ((unint64_t)v4 + v32 < v3 && (unint64_t)v33 >= v30) {
              int v35 = *v33;
            }
            unsigned int v31 = v35 | v34;
            *(_DWORD *)(a3 + 24) = v31;
            ++v32;
          }
          while (v32 != 4);
        }
        *(void *)a3 = ++v4;
        int v29 = (v31 >> v20) | v21;
        unsigned int v21 = v31 << -(char)v20;
        if (!v20) {
          unsigned int v21 = 0;
        }
        *(_DWORD *)(a3 + 24) = v21;
        *(_DWORD *)(a3 + 28) = v20;
      }
      else
      {
        v20 -= 32;
        int v29 = v21;
      }
      *(_DWORD *)(a2 + 8) = v29;
    }
    if (v20 + 8 * ((int)v3 - (int)v4) <= 0)
    {
      exception = __cxa_allocate_exception(8uLL);
      uint64_t v98 = "Cannot read cmmMd.gain.hasData";
      goto LABEL_180;
    }
    unsigned int v36 = v21 >> 31;
    int v37 = v20 - 1;
    *(_DWORD *)(a3 + 28) = v20 - 1;
    if (v20 - 1 < 0)
    {
      unint64_t v39 = *(void *)(a3 + 8);
      if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
        && v39 <= (unint64_t)v4)
      {
        unsigned int v21 = bswap32(*v4);
      }
      else
      {
        uint64_t v40 = 0;
        do
        {
          uint64_t v41 = (unsigned __int8 *)v4 + v40;
          unsigned int v42 = v21 << 8;
          *(_DWORD *)(a3 + 24) = v42;
          int v43 = 255;
          if ((unint64_t)v4 + v40 < v3 && (unint64_t)v41 >= v39) {
            int v43 = *v41;
          }
          unsigned int v21 = v43 | v42;
          *(_DWORD *)(a3 + 24) = v21;
          ++v40;
        }
        while (v40 != 4);
      }
      int v45 = v20 + 31;
      BOOL v44 = v20 == -31;
      *(_DWORD *)(a3 + 28) = v20 + 31;
      *(void *)a3 = ++v4;
      v36 |= v21 >> (v20 + 31);
      if (v20 == -31) {
        unsigned int v38 = 0;
      }
      else {
        unsigned int v38 = v21 << (1 - v20);
      }
      if (v44) {
        int v37 = 0;
      }
      else {
        int v37 = v45;
      }
    }
    else
    {
      unsigned int v38 = 2 * v21;
    }
    *(_DWORD *)(a3 + 24) = v38;
    *(unsigned char *)(a2 + 12) = v36 != 0;
    if (v36)
    {
      if (v37 + 8 * ((int)v3 - (int)v4) <= 0)
      {
        exception = __cxa_allocate_exception(8uLL);
        uint64_t v98 = "Cannot read cmmMd.gain.isDB";
        goto LABEL_180;
      }
      unsigned int v46 = v38 >> 31;
      *(_DWORD *)(a3 + 28) = v37 - 1;
      if (v37 - 1 < 0)
      {
        unint64_t v47 = *(void *)(a3 + 8);
        if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
          && v47 <= (unint64_t)v4)
        {
          unsigned int v38 = bswap32(*v4);
        }
        else
        {
          uint64_t v48 = 0;
          do
          {
            unint64_t v49 = (unsigned __int8 *)v4 + v48;
            unsigned int v50 = v38 << 8;
            *(_DWORD *)(a3 + 24) = v50;
            int v51 = 255;
            if ((unint64_t)v4 + v48 < v3 && (unint64_t)v49 >= v47) {
              int v51 = *v49;
            }
            unsigned int v38 = v51 | v50;
            *(_DWORD *)(a3 + 24) = v38;
            ++v48;
          }
          while (v48 != 4);
        }
        unsigned int v52 = v38 << (1 - v37);
        v37 += 31;
        *(_DWORD *)(a3 + 28) = v37;
        *(void *)a3 = ++v4;
        v46 |= v38 >> v37;
        if (v37) {
          unsigned int v38 = v52;
        }
        else {
          unsigned int v38 = 0;
        }
        if (!v37) {
          int v37 = 0;
        }
      }
      else
      {
        v38 *= 2;
        --v37;
      }
      *(_DWORD *)(a3 + 24) = v38;
      *(unsigned char *)(a2 + 13) = v46 != 0;
      if (v37 + 8 * ((int)v3 - (int)v4) <= 31)
      {
        exception = __cxa_allocate_exception(8uLL);
        uint64_t v98 = "Cannot read cmmMd.gain.gain";
        goto LABEL_180;
      }
      *(_DWORD *)(a3 + 28) = v37 - 32;
      if (v37 - 32 < 0)
      {
        unint64_t v54 = *(void *)(a3 + 8);
        if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
          && v54 <= (unint64_t)v4)
        {
          unsigned int v55 = bswap32(*v4);
        }
        else
        {
          uint64_t v56 = 0;
          unsigned int v55 = v38;
          do
          {
            uint64_t v57 = (unsigned __int8 *)v4 + v56;
            unsigned int v58 = v55 << 8;
            *(_DWORD *)(a3 + 24) = v58;
            int v59 = 255;
            if ((unint64_t)v4 + v56 < v3 && (unint64_t)v57 >= v54) {
              int v59 = *v57;
            }
            unsigned int v55 = v59 | v58;
            *(_DWORD *)(a3 + 24) = v55;
            ++v56;
          }
          while (v56 != 4);
        }
        *(void *)a3 = ++v4;
        int v53 = (v55 >> v37) | v38;
        unsigned int v38 = v55 << -(char)v37;
        if (!v37) {
          unsigned int v38 = 0;
        }
        *(_DWORD *)(a3 + 24) = v38;
        *(_DWORD *)(a3 + 28) = v37;
      }
      else
      {
        v37 -= 32;
        int v53 = v38;
      }
      *(_DWORD *)(a2 + 16) = v53;
    }
    if (v37 + 8 * ((int)v3 - (int)v4) <= 0)
    {
      exception = __cxa_allocate_exception(8uLL);
      uint64_t v98 = "Cannot read cmmMd.headLocked";
      goto LABEL_180;
    }
    unsigned int v60 = v38 >> 31;
    int v61 = v37 - 1;
    *(_DWORD *)(a3 + 28) = v37 - 1;
    if (v37 - 1 < 0)
    {
      unint64_t v63 = *(void *)(a3 + 8);
      if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
        && v63 <= (unint64_t)v4)
      {
        unsigned int v38 = bswap32(*v4);
      }
      else
      {
        uint64_t v64 = 0;
        do
        {
          uint64_t v65 = (unsigned __int8 *)v4 + v64;
          unsigned int v66 = v38 << 8;
          *(_DWORD *)(a3 + 24) = v66;
          int v67 = 255;
          if ((unint64_t)v4 + v64 < v3 && (unint64_t)v65 >= v63) {
            int v67 = *v65;
          }
          unsigned int v38 = v67 | v66;
          *(_DWORD *)(a3 + 24) = v38;
          ++v64;
        }
        while (v64 != 4);
      }
      unsigned int v68 = v38 << (1 - v37);
      int v69 = v37 + 31;
      *(_DWORD *)(a3 + 28) = v69;
      *(void *)a3 = ++v4;
      v60 |= v38 >> v69;
      if (v69) {
        unsigned int v62 = v68;
      }
      else {
        unsigned int v62 = 0;
      }
      if (v69) {
        int v61 = v69;
      }
      else {
        int v61 = 0;
      }
    }
    else
    {
      unsigned int v62 = 2 * v38;
    }
    *(_DWORD *)(a3 + 24) = v62;
    *(unsigned char *)(a2 + 22) = v60 != 0;
    if (v61 + 8 * ((int)v3 - (int)v4) <= 0)
    {
      exception = __cxa_allocate_exception(8uLL);
      uint64_t v98 = "Cannot read cmmMd.headphoneVirtualize.hasData";
      goto LABEL_180;
    }
    unsigned int v70 = v62 >> 31;
    int v71 = v61 - 1;
    *(_DWORD *)(a3 + 28) = v61 - 1;
    if (v61 - 1 < 0)
    {
      unint64_t v73 = *(void *)(a3 + 8);
      if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
        && v73 <= (unint64_t)v4)
      {
        unsigned int v62 = bswap32(*v4);
      }
      else
      {
        uint64_t v74 = 0;
        do
        {
          unsigned int v75 = (unsigned __int8 *)v4 + v74;
          unsigned int v76 = v62 << 8;
          *(_DWORD *)(a3 + 24) = v76;
          int v77 = 255;
          if ((unint64_t)v4 + v74 < v3 && (unint64_t)v75 >= v73) {
            int v77 = *v75;
          }
          unsigned int v62 = v77 | v76;
          *(_DWORD *)(a3 + 24) = v62;
          ++v74;
        }
        while (v74 != 4);
      }
      unsigned int v78 = v62 << (1 - v61);
      int v79 = v61 + 31;
      *(_DWORD *)(a3 + 28) = v79;
      *(void *)a3 = ++v4;
      v70 |= v62 >> v79;
      if (v79) {
        unsigned int v72 = v78;
      }
      else {
        unsigned int v72 = 0;
      }
      if (v79) {
        int v71 = v79;
      }
      else {
        int v71 = 0;
      }
    }
    else
    {
      unsigned int v72 = 2 * v62;
    }
    *(_DWORD *)(a3 + 24) = v72;
    *(unsigned char *)(a2 + 24) = v70 != 0;
    if (v70)
    {
      if (v71 + 8 * ((int)v3 - (int)v4) <= 0)
      {
        exception = __cxa_allocate_exception(8uLL);
        uint64_t v98 = "Cannot read cmmMd.headphoneVirtualize.bypass";
      }
      else
      {
        unsigned int v80 = v72 >> 31;
        int v81 = v71 - 1;
        *(_DWORD *)(a3 + 28) = v71 - 1;
        if (v71 - 1 < 0)
        {
          unint64_t v83 = *(void *)(a3 + 8);
          if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
            && v83 <= (unint64_t)v4)
          {
            unsigned int v72 = bswap32(*v4);
          }
          else
          {
            uint64_t v84 = 0;
            do
            {
              int v85 = (unsigned __int8 *)v4 + v84;
              unsigned int v86 = v72 << 8;
              *(_DWORD *)(a3 + 24) = v86;
              int v87 = 255;
              if ((unint64_t)v4 + v84 < v3 && (unint64_t)v85 >= v83) {
                int v87 = *v85;
              }
              unsigned int v72 = v87 | v86;
              *(_DWORD *)(a3 + 24) = v72;
              ++v84;
            }
            while (v84 != 4);
          }
          int v89 = v71 + 31;
          BOOL v88 = v71 == -31;
          *(_DWORD *)(a3 + 28) = v71 + 31;
          *(void *)a3 = ++v4;
          v80 |= v72 >> (v71 + 31);
          if (v71 == -31) {
            int v82 = 0;
          }
          else {
            int v82 = v72 << (1 - v71);
          }
          if (v88) {
            int v81 = 0;
          }
          else {
            int v81 = v89;
          }
        }
        else
        {
          int v82 = 2 * v72;
        }
        *(_DWORD *)(a3 + 24) = v82;
        *(unsigned char *)(a2 + 25) = v80 != 0;
        if (v81 + 8 * ((int)v3 - (int)v4) > 31)
        {
          *(_DWORD *)(a3 + 28) = v81 - 32;
          if (v81 - 32 < 0)
          {
            unint64_t v90 = *(void *)(a3 + 8);
            if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
              && v90 <= (unint64_t)v4)
            {
              unsigned int v91 = bswap32(*v4);
            }
            else
            {
              uint64_t v92 = 0;
              unsigned int v91 = v82;
              do
              {
                uint64_t v93 = (unsigned __int8 *)v4 + v92;
                unsigned int v94 = v91 << 8;
                *(_DWORD *)(a3 + 24) = v94;
                int v95 = 255;
                if ((unint64_t)v4 + v92 < v3 && (unint64_t)v93 >= v90) {
                  int v95 = *v93;
                }
                unsigned int v91 = v95 | v94;
                *(_DWORD *)(a3 + 24) = v91;
                ++v92;
              }
              while (v92 != 4);
            }
            *(void *)a3 = v4 + 1;
            v82 |= v91 >> v81;
            unsigned int v96 = v91 << -(char)v81;
            if (!v81) {
              unsigned int v96 = 0;
            }
            *(_DWORD *)(a3 + 24) = v96;
            *(_DWORD *)(a3 + 28) = v81;
          }
          *(_DWORD *)(a2 + 28) = v82;
          return;
        }
        exception = __cxa_allocate_exception(8uLL);
        uint64_t v98 = "Cannot read cmmMd.headphoneVirtualize.DRR";
      }
LABEL_180:
      void *exception = v98;
      __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
    }
  }
}

void APAC::MetadataBitStreamParser::parseObjectMetadata(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 16);
  unint64_t v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 6)
  {
    exception = __cxa_allocate_exception(8uLL);
    unsigned int v60 = "Cannot read objMd.objectID";
    goto LABEL_78;
  }
  unsigned int v9 = *(_DWORD *)(a3 + 24);
  unsigned int v10 = v9 >> 25;
  int v11 = v6 - 7;
  *(_DWORD *)(a3 + 28) = v6 - 7;
  if (v6 - 7 < 0)
  {
    unint64_t v13 = *(void *)(a3 + 8);
    if ((v5 & ~(v5 >> 63) & 0xFFFFFFFC) == 0 || v13 > (unint64_t)v4)
    {
      uint64_t v15 = 0;
      do
      {
        int v16 = (unsigned __int8 *)v4 + v15;
        unsigned int v17 = v9 << 8;
        *(_DWORD *)(a3 + 24) = v17;
        int v18 = 255;
        if ((unint64_t)v4 + v15 < v3 && (unint64_t)v16 >= v13) {
          int v18 = *v16;
        }
        unsigned int v9 = v18 | v17;
        *(_DWORD *)(a3 + 24) = v9;
        ++v15;
      }
      while (v15 != 4);
    }
    else
    {
      unsigned int v9 = bswap32(*v4);
    }
    int v20 = v6 + 25;
    BOOL v19 = v6 == -25;
    *(_DWORD *)(a3 + 28) = v6 + 25;
    *(void *)a3 = ++v4;
    v10 |= v9 >> (v6 + 25);
    if (v6 == -25) {
      unsigned int v12 = 0;
    }
    else {
      unsigned int v12 = v9 << (7 - v6);
    }
    if (v19) {
      int v11 = 0;
    }
    else {
      int v11 = v20;
    }
  }
  else
  {
    unsigned int v12 = v9 << 7;
  }
  *(_DWORD *)(a3 + 24) = v12;
  *(unsigned char *)a2 = v10;
  if (v11 + 8 * ((int)v3 - (int)v4) <= 3)
  {
    exception = __cxa_allocate_exception(8uLL);
    unsigned int v60 = "Cannot read objMd.numBlocks";
LABEL_78:
    void *exception = v60;
    __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
  }
  unsigned int v21 = v12 >> 28;
  *(_DWORD *)(a3 + 28) = v11 - 4;
  if (v11 - 4 < 0)
  {
    unint64_t v23 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v23 <= (unint64_t)v4)
    {
      unsigned int v12 = bswap32(*v4);
    }
    else
    {
      uint64_t v24 = 0;
      do
      {
        unsigned int v25 = (unsigned __int8 *)v4 + v24;
        unsigned int v26 = v12 << 8;
        *(_DWORD *)(a3 + 24) = v26;
        int v27 = 255;
        if ((unint64_t)v4 + v24 < v3 && (unint64_t)v25 >= v23) {
          int v27 = *v25;
        }
        unsigned int v12 = v27 | v26;
        *(_DWORD *)(a3 + 24) = v12;
        ++v24;
      }
      while (v24 != 4);
    }
    int v28 = v12 << (4 - v11);
    int v29 = v11 + 28;
    *(_DWORD *)(a3 + 28) = v29;
    *(void *)a3 = v4 + 1;
    v21 |= v12 >> v29;
    if (v29) {
      int v22 = v28;
    }
    else {
      int v22 = 0;
    }
  }
  else
  {
    int v22 = 16 * v12;
  }
  *(_DWORD *)(a3 + 24) = v22;
  *(unsigned char *)(a2 + 1) = v21;
  LODWORD(v30) = v21;
  if ((_BYTE)v21)
  {
    for (unint64_t i = 0; i < v30; ++i)
    {
      unint64_t v32 = *(void *)(a3 + 16);
      unsigned int v33 = *(unsigned int **)a3;
      uint64_t v34 = v32 - *(void *)a3;
      int v35 = *(_DWORD *)(a3 + 28);
      if (v35 + 8 * (int)v34 <= 0)
      {
        exception = __cxa_allocate_exception(8uLL);
        unsigned int v60 = "Cannot read objMd.blockData[n].isNewBlk";
        goto LABEL_78;
      }
      unsigned int v36 = *(_DWORD *)(a3 + 24);
      unsigned int v37 = v36 >> 31;
      int v38 = v35 - 1;
      *(_DWORD *)(a3 + 28) = v35 - 1;
      if (v35 - 1 < 0)
      {
        unint64_t v40 = *(void *)(a3 + 8);
        if ((v34 & ~(v34 >> 63) & 0xFFFFFFFC) == 0 || v40 > (unint64_t)v33)
        {
          uint64_t v42 = 0;
          do
          {
            int v43 = (unsigned __int8 *)v33 + v42;
            unsigned int v44 = v36 << 8;
            *(_DWORD *)(a3 + 24) = v44;
            int v45 = 255;
            if ((unint64_t)v33 + v42 < v32 && (unint64_t)v43 >= v40) {
              int v45 = *v43;
            }
            unsigned int v36 = v45 | v44;
            *(_DWORD *)(a3 + 24) = v36;
            ++v42;
          }
          while (v42 != 4);
        }
        else
        {
          unsigned int v36 = bswap32(*v33);
        }
        int v47 = v35 + 31;
        BOOL v46 = v35 == -31;
        *(_DWORD *)(a3 + 28) = v35 + 31;
        *(void *)a3 = ++v33;
        v37 |= v36 >> (v35 + 31);
        if (v35 == -31) {
          unsigned int v39 = 0;
        }
        else {
          unsigned int v39 = v36 << (1 - v35);
        }
        if (v46) {
          int v38 = 0;
        }
        else {
          int v38 = v47;
        }
      }
      else
      {
        unsigned int v39 = 2 * v36;
      }
      *(_DWORD *)(a3 + 24) = v39;
      uint64_t v48 = a2 + 500 * i;
      *(unsigned char *)(v48 + 4) = v37 != 0;
      uint64_t v49 = v48 + 4;
      if (i)
      {
        if (i >= (v30 - 1))
        {
          *(_WORD *)(a2 + 500 * i + 6) = 0;
        }
        else
        {
          if (v38 + 8 * ((int)v32 - (int)v33) <= 9)
          {
            exception = __cxa_allocate_exception(8uLL);
            unsigned int v60 = "Cannot read objMd.blockData[n].rtime";
            goto LABEL_78;
          }
          unsigned int v50 = v39 >> 22;
          *(_DWORD *)(a3 + 28) = v38 - 10;
          if (v38 - 10 < 0)
          {
            unint64_t v52 = *(void *)(a3 + 8);
            if (((v32 - v33) & ~((uint64_t)(v32 - (void)v33) >> 63) & 0xFFFFFFFC) != 0
              && v52 <= (unint64_t)v33)
            {
              unsigned int v39 = bswap32(*v33);
            }
            else
            {
              uint64_t v53 = 0;
              do
              {
                unint64_t v54 = (unsigned __int8 *)v33 + v53;
                unsigned int v55 = v39 << 8;
                *(_DWORD *)(a3 + 24) = v55;
                int v56 = 255;
                if ((unint64_t)v33 + v53 < v32 && (unint64_t)v54 >= v52) {
                  int v56 = *v54;
                }
                unsigned int v39 = v56 | v55;
                *(_DWORD *)(a3 + 24) = v39;
                ++v53;
              }
              while (v53 != 4);
            }
            unsigned int v57 = v39 << (10 - v38);
            int v58 = v38 + 22;
            *(_DWORD *)(a3 + 28) = v58;
            *(void *)a3 = v33 + 1;
            v50 |= v39 >> v58;
            if (v58) {
              unsigned int v51 = v57;
            }
            else {
              unsigned int v51 = 0;
            }
          }
          else
          {
            unsigned int v51 = v39 << 10;
          }
          *(_DWORD *)(a3 + 24) = v51;
          *(_WORD *)(a2 + 500 * i + 6) = v50;
        }
      }
      else
      {
        *(_WORD *)(a2 + 6) = 0;
      }
      APAC::MetadataBitStreamParser::parseBlockData(a1, v49, 513, a3);
      unint64_t v30 = *(unsigned __int8 *)(a2 + 1);
    }
  }
}

void APAC::MetadataBitStreamParser::parseProprietaryDynamicData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 16);
  unint64_t v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v93 = "Cannot read pDD.hasData";
    goto LABEL_135;
  }
  unsigned int v9 = *(_DWORD *)(a3 + 24);
  unsigned int v10 = v9 >> 31;
  int v11 = v6 - 1;
  *(_DWORD *)(a3 + 28) = v6 - 1;
  if (v6 - 1 < 0)
  {
    unint64_t v13 = *(void *)(a3 + 8);
    if ((v5 & ~(v5 >> 63) & 0xFFFFFFFC) == 0 || v13 > (unint64_t)v4)
    {
      uint64_t v15 = 0;
      do
      {
        int v16 = (unsigned __int8 *)v4 + v15;
        unsigned int v17 = v9 << 8;
        *(_DWORD *)(a3 + 24) = v17;
        int v18 = 255;
        if ((unint64_t)v4 + v15 < v3 && (unint64_t)v16 >= v13) {
          int v18 = *v16;
        }
        unsigned int v9 = v18 | v17;
        *(_DWORD *)(a3 + 24) = v9;
        ++v15;
      }
      while (v15 != 4);
    }
    else
    {
      unsigned int v9 = bswap32(*v4);
    }
    int v20 = v6 + 31;
    BOOL v19 = v6 == -31;
    *(_DWORD *)(a3 + 28) = v6 + 31;
    *(void *)a3 = ++v4;
    v10 |= v9 >> (v6 + 31);
    if (v6 == -31) {
      unsigned int v12 = 0;
    }
    else {
      unsigned int v12 = v9 << (1 - v6);
    }
    if (v19) {
      int v11 = 0;
    }
    else {
      int v11 = v20;
    }
  }
  else
  {
    unsigned int v12 = 2 * v9;
  }
  *(_DWORD *)(a3 + 24) = v12;
  *(unsigned char *)a2 = v10 != 0;
  if (!v10) {
    return;
  }
  if (v11 + 8 * ((int)v3 - (int)v4) <= 4)
  {
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v93 = "Cannot read pDD.numParameters";
LABEL_135:
    void *exception = v93;
    __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
  }
  unsigned int v21 = v12 >> 27;
  *(_DWORD *)(a3 + 28) = v11 - 5;
  if (v11 - 5 < 0)
  {
    unint64_t v23 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v23 <= (unint64_t)v4)
    {
      unsigned int v12 = bswap32(*v4);
    }
    else
    {
      uint64_t v24 = 0;
      do
      {
        unsigned int v25 = (unsigned __int8 *)v4 + v24;
        unsigned int v26 = v12 << 8;
        *(_DWORD *)(a3 + 24) = v26;
        int v27 = 255;
        if ((unint64_t)v4 + v24 < v3 && (unint64_t)v25 >= v23) {
          int v27 = *v25;
        }
        unsigned int v12 = v27 | v26;
        *(_DWORD *)(a3 + 24) = v12;
        ++v24;
      }
      while (v24 != 4);
    }
    int v28 = v12 << (5 - v11);
    int v29 = v11 + 27;
    *(_DWORD *)(a3 + 28) = v29;
    *(void *)a3 = v4 + 1;
    v21 |= v12 >> v29;
    if (v29) {
      int v22 = v28;
    }
    else {
      int v22 = 0;
    }
  }
  else
  {
    int v22 = 32 * v12;
  }
  *(_DWORD *)(a3 + 24) = v22;
  *(unsigned char *)(a2 + 1) = v21;
  if ((_BYTE)v21)
  {
    uint64_t v30 = 0;
    while (1)
    {
      unint64_t v31 = *(void *)(a3 + 16);
      unint64_t v32 = *(unsigned int **)a3;
      uint64_t v33 = v31 - *(void *)a3;
      int v34 = *(_DWORD *)(a3 + 28);
      if (v34 + 8 * (int)v33 <= 4)
      {
        exception = __cxa_allocate_exception(8uLL);
        uint64_t v93 = "Cannot read pDD.paramIndexList[n]";
        goto LABEL_135;
      }
      unsigned int v35 = *(_DWORD *)(a3 + 24);
      unsigned int v36 = v35 >> 27;
      int v37 = v34 - 5;
      *(_DWORD *)(a3 + 28) = v34 - 5;
      if (v34 - 5 < 0)
      {
        unint64_t v39 = *(void *)(a3 + 8);
        if ((v33 & ~(v33 >> 63) & 0xFFFFFFFC) == 0 || v39 > (unint64_t)v32)
        {
          uint64_t v41 = 0;
          do
          {
            uint64_t v42 = (unsigned __int8 *)v32 + v41;
            unsigned int v43 = v35 << 8;
            *(_DWORD *)(a3 + 24) = v43;
            int v44 = 255;
            if ((unint64_t)v32 + v41 < v31 && (unint64_t)v42 >= v39) {
              int v44 = *v42;
            }
            unsigned int v35 = v44 | v43;
            *(_DWORD *)(a3 + 24) = v35;
            ++v41;
          }
          while (v41 != 4);
        }
        else
        {
          unsigned int v35 = bswap32(*v32);
        }
        int v46 = v34 + 27;
        BOOL v45 = v34 == -27;
        *(_DWORD *)(a3 + 28) = v34 + 27;
        *(void *)a3 = ++v32;
        v36 |= v35 >> (v34 + 27);
        if (v34 == -27) {
          unsigned int v38 = 0;
        }
        else {
          unsigned int v38 = v35 << (5 - v34);
        }
        if (v45) {
          int v37 = 0;
        }
        else {
          int v37 = v46;
        }
      }
      else
      {
        unsigned int v38 = 32 * v35;
      }
      *(_DWORD *)(a3 + 24) = v38;
      *(unsigned char *)(a2 + v30 + 90) = v36;
      switch((char)v36)
      {
        case 0:
          uint64_t v47 = v31 - (void)v32;
          if (v37 + 8 * ((int)v31 - (int)v32) <= 31)
          {
            exception = __cxa_allocate_exception(8uLL);
            uint64_t v93 = "Cannot read pDD.lookDirection.azimuth";
            goto LABEL_135;
          }
          *(_DWORD *)(a3 + 28) = v37 - 32;
          if (v37 - 32 < 0)
          {
            int v56 = v47 & ~(v47 >> 63);
            unint64_t v57 = *(void *)(a3 + 8);
            if ((v56 & 0xFFFFFFFC) != 0 && v57 <= (unint64_t)v32)
            {
              unsigned int v58 = bswap32(*v32);
            }
            else
            {
              uint64_t v62 = 0;
              unsigned int v58 = v38;
              do
              {
                unint64_t v63 = (unsigned __int8 *)v32 + v62;
                unsigned int v64 = v58 << 8;
                *(_DWORD *)(a3 + 24) = v64;
                int v65 = 255;
                if ((unint64_t)v32 + v62 < v31 && (unint64_t)v63 >= v57) {
                  int v65 = *v63;
                }
                unsigned int v58 = v65 | v64;
                *(_DWORD *)(a3 + 24) = v58;
                ++v62;
              }
              while (v62 != 4);
            }
            *(void *)a3 = ++v32;
            int v49 = (v58 >> v37) | v38;
            unsigned int v38 = v58 << -(char)v37;
            if (!v37) {
              unsigned int v38 = 0;
            }
            *(_DWORD *)(a3 + 24) = v38;
            *(_DWORD *)(a3 + 28) = v37;
            uint64_t v47 = v31 - (void)v32;
            int v48 = 8 * (v31 - v32);
          }
          else
          {
            int v48 = 8 * v47;
            v37 -= 32;
            int v49 = v38;
          }
          *(_DWORD *)(a2 + 4) = v49;
          if (v48 + v37 <= 31)
          {
            exception = __cxa_allocate_exception(8uLL);
            uint64_t v93 = "Cannot read pDD.lookDirection.elevation";
            goto LABEL_135;
          }
          *(_DWORD *)(a3 + 28) = v37 - 32;
          if (v37 - 32 < 0)
          {
            int v66 = v47 & ~(v47 >> 63);
            unint64_t v67 = *(void *)(a3 + 8);
            if ((v66 & 0xFFFFFFFC) != 0 && v67 <= (unint64_t)v32)
            {
              unsigned int v68 = bswap32(*v32);
            }
            else
            {
              uint64_t v87 = 0;
              unsigned int v68 = v38;
              do
              {
                BOOL v88 = (unsigned __int8 *)v32 + v87;
                unsigned int v89 = v68 << 8;
                *(_DWORD *)(a3 + 24) = v89;
                int v90 = 255;
                if ((unint64_t)v32 + v87 < v31 && (unint64_t)v88 >= v67) {
                  int v90 = *v88;
                }
                unsigned int v68 = v90 | v89;
                *(_DWORD *)(a3 + 24) = v68;
                ++v87;
              }
              while (v87 != 4);
            }
            *(void *)a3 = v32 + 1;
            v38 |= v68 >> v37;
            unsigned int v91 = v68 << -(char)v37;
            if (!v37) {
              unsigned int v91 = 0;
            }
            *(_DWORD *)(a3 + 24) = v91;
            *(_DWORD *)(a3 + 28) = v37;
          }
          *(_DWORD *)(a2 + 8) = v38;
LABEL_132:
          if (++v30 >= (unint64_t)*(unsigned __int8 *)(a2 + 1)) {
            return;
          }
          break;
        case 1:
          APAC::MetadataBitStreamParser::parseAudioSceneMaskingZone(a1, a2 + 12, a3);
          goto LABEL_132;
        case 2:
          if (v37 + 8 * ((int)v31 - (int)v32) <= 2)
          {
            exception = __cxa_allocate_exception(8uLL);
            uint64_t v93 = "Cannot read pDD.preferredDoF";
            goto LABEL_135;
          }
          unsigned int v50 = v38 >> 29;
          *(_DWORD *)(a3 + 28) = v37 - 3;
          if (v37 - 3 < 0)
          {
            unint64_t v59 = *(void *)(a3 + 8);
            if (((v31 - v32) & ~((uint64_t)(v31 - (void)v32) >> 63) & 0xFFFFFFFC) != 0
              && v59 <= (unint64_t)v32)
            {
              unsigned int v38 = bswap32(*v32);
            }
            else
            {
              uint64_t v69 = 0;
              do
              {
                unsigned int v70 = (unsigned __int8 *)v32 + v69;
                unsigned int v71 = v38 << 8;
                *(_DWORD *)(a3 + 24) = v71;
                int v72 = 255;
                if ((unint64_t)v32 + v69 < v31 && (unint64_t)v70 >= v59) {
                  int v72 = *v70;
                }
                unsigned int v38 = v72 | v71;
                *(_DWORD *)(a3 + 24) = v38;
                ++v69;
              }
              while (v69 != 4);
            }
            int v73 = v38 << (3 - v37);
            int v74 = v37 + 29;
            *(_DWORD *)(a3 + 28) = v74;
            *(void *)a3 = v32 + 1;
            v50 |= v38 >> v74;
            if (v74) {
              int v51 = v73;
            }
            else {
              int v51 = 0;
            }
          }
          else
          {
            int v51 = 8 * v38;
          }
          *(_DWORD *)(a3 + 24) = v51;
          *(unsigned char *)(a2 + 44) = v50;
          goto LABEL_132;
        case 3:
          APAC::MetadataBitStreamParser::parseParametricReverb(a1, a2 + 48, a3);
          goto LABEL_132;
        case 4:
          if (v37 + 8 * ((int)v31 - (int)v32) <= 0)
          {
            exception = __cxa_allocate_exception(8uLL);
            uint64_t v93 = "Cannot read pDD.headLocked";
            goto LABEL_135;
          }
          unsigned int v52 = v38 >> 31;
          *(_DWORD *)(a3 + 28) = v37 - 1;
          if (v37 - 1 < 0)
          {
            unint64_t v60 = *(void *)(a3 + 8);
            if (((v31 - v32) & ~((uint64_t)(v31 - (void)v32) >> 63) & 0xFFFFFFFC) != 0
              && v60 <= (unint64_t)v32)
            {
              unsigned int v38 = bswap32(*v32);
            }
            else
            {
              uint64_t v75 = 0;
              do
              {
                unsigned int v76 = (unsigned __int8 *)v32 + v75;
                unsigned int v77 = v38 << 8;
                *(_DWORD *)(a3 + 24) = v77;
                int v78 = 255;
                if ((unint64_t)v32 + v75 < v31 && (unint64_t)v76 >= v60) {
                  int v78 = *v76;
                }
                unsigned int v38 = v78 | v77;
                *(_DWORD *)(a3 + 24) = v38;
                ++v75;
              }
              while (v75 != 4);
            }
            int v79 = v38 << (1 - v37);
            int v80 = v37 + 31;
            *(_DWORD *)(a3 + 28) = v80;
            *(void *)a3 = v32 + 1;
            v52 |= v38 >> v80;
            if (v80) {
              int v53 = v79;
            }
            else {
              int v53 = 0;
            }
          }
          else
          {
            int v53 = 2 * v38;
          }
          *(_DWORD *)(a3 + 24) = v53;
          *(unsigned char *)(a2 + 88) = v52 != 0;
          goto LABEL_132;
        case 5:
          if (v37 + 8 * ((int)v31 - (int)v32) <= 0)
          {
            exception = __cxa_allocate_exception(8uLL);
            uint64_t v93 = "Cannot read pDD.parallax";
            goto LABEL_135;
          }
          unsigned int v54 = v38 >> 31;
          *(_DWORD *)(a3 + 28) = v37 - 1;
          if (v37 - 1 < 0)
          {
            unint64_t v61 = *(void *)(a3 + 8);
            if (((v31 - v32) & ~((uint64_t)(v31 - (void)v32) >> 63) & 0xFFFFFFFC) != 0
              && v61 <= (unint64_t)v32)
            {
              unsigned int v38 = bswap32(*v32);
            }
            else
            {
              uint64_t v81 = 0;
              do
              {
                int v82 = (unsigned __int8 *)v32 + v81;
                unsigned int v83 = v38 << 8;
                *(_DWORD *)(a3 + 24) = v83;
                int v84 = 255;
                if ((unint64_t)v32 + v81 < v31 && (unint64_t)v82 >= v61) {
                  int v84 = *v82;
                }
                unsigned int v38 = v84 | v83;
                *(_DWORD *)(a3 + 24) = v38;
                ++v81;
              }
              while (v81 != 4);
            }
            int v85 = v38 << (1 - v37);
            int v86 = v37 + 31;
            *(_DWORD *)(a3 + 28) = v86;
            *(void *)a3 = v32 + 1;
            v54 |= v38 >> v86;
            if (v86) {
              int v55 = v85;
            }
            else {
              int v55 = 0;
            }
          }
          else
          {
            int v55 = 2 * v38;
          }
          *(_DWORD *)(a3 + 24) = v55;
          *(unsigned char *)(a2 + 89) = v54 != 0;
          goto LABEL_132;
        default:
          goto LABEL_132;
      }
    }
  }
}

void APAC::MetadataBitStreamParser::parseAudioSceneMaskingZone(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v4 = *(void *)(a3 + 16);
  uint64_t v5 = *(unsigned int **)a3;
  uint64_t v6 = v4 - *(void *)a3;
  int v7 = *(_DWORD *)(a3 + 28);
  if (v7 + 8 * (int)v6 <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    unint64_t v179 = "Cannot read mZ.isZoneDefined";
    goto LABEL_217;
  }
  unsigned int v9 = *(_DWORD *)(a3 + 24);
  unsigned int v10 = v9 >> 31;
  int v11 = v7 - 1;
  *(_DWORD *)(a3 + 28) = v7 - 1;
  if (v7 - 1 < 0)
  {
    unint64_t v13 = *(void *)(a3 + 8);
    if ((v6 & ~(v6 >> 63) & 0xFFFFFFFC) == 0 || v13 > (unint64_t)v5)
    {
      uint64_t v15 = 0;
      do
      {
        int v16 = (unsigned __int8 *)v5 + v15;
        unsigned int v17 = v9 << 8;
        *(_DWORD *)(a3 + 24) = v17;
        int v18 = 255;
        if ((unint64_t)v5 + v15 < v4 && (unint64_t)v16 >= v13) {
          int v18 = *v16;
        }
        unsigned int v9 = v18 | v17;
        *(_DWORD *)(a3 + 24) = v9;
        ++v15;
      }
      while (v15 != 4);
    }
    else
    {
      unsigned int v9 = bswap32(*v5);
    }
    unsigned int v19 = v9 << (1 - v7);
    int v20 = v7 + 31;
    *(_DWORD *)(a3 + 28) = v20;
    *(void *)a3 = ++v5;
    v10 |= v9 >> v20;
    if (v20) {
      unsigned int v12 = v19;
    }
    else {
      unsigned int v12 = 0;
    }
    if (v20) {
      int v11 = v20;
    }
    else {
      int v11 = 0;
    }
  }
  else
  {
    unsigned int v12 = 2 * v9;
  }
  *(_DWORD *)(a3 + 24) = v12;
  *(unsigned char *)a2 = v10 != 0;
  if (v10)
  {
    if (v11 + 8 * ((int)v4 - (int)v5) <= 0)
    {
      exception = __cxa_allocate_exception(8uLL);
      unint64_t v179 = "Cannot read mZ.keepPreviousZone";
      goto LABEL_217;
    }
    unsigned int v21 = v12 >> 31;
    int v22 = v11 - 1;
    *(_DWORD *)(a3 + 28) = v11 - 1;
    if (v11 - 1 < 0)
    {
      unint64_t v24 = *(void *)(a3 + 8);
      if (((v4 - v5) & ~((uint64_t)(v4 - (void)v5) >> 63) & 0xFFFFFFFC) != 0
        && v24 <= (unint64_t)v5)
      {
        unsigned int v12 = bswap32(*v5);
      }
      else
      {
        uint64_t v25 = 0;
        do
        {
          unsigned int v26 = (unsigned __int8 *)v5 + v25;
          unsigned int v27 = v12 << 8;
          *(_DWORD *)(a3 + 24) = v27;
          int v28 = 255;
          if ((unint64_t)v5 + v25 < v4 && (unint64_t)v26 >= v24) {
            int v28 = *v26;
          }
          unsigned int v12 = v28 | v27;
          *(_DWORD *)(a3 + 24) = v12;
          ++v25;
        }
        while (v25 != 4);
      }
      unsigned int v29 = v12 << (1 - v11);
      int v30 = v11 + 31;
      *(_DWORD *)(a3 + 28) = v30;
      *(void *)a3 = ++v5;
      v21 |= v12 >> v30;
      unsigned int v23 = v30 ? v29 : 0;
      int v22 = v30 ? v30 : 0;
    }
    else
    {
      unsigned int v23 = 2 * v12;
    }
    *(_DWORD *)(a3 + 24) = v23;
    *(unsigned char *)(a2 + 1) = v21 != 0;
    if (!v21)
    {
      if (v22 + 8 * ((int)v4 - (int)v5) <= 0)
      {
        exception = __cxa_allocate_exception(8uLL);
        unint64_t v179 = "Cannot read mZ.usePreDefinedZone";
        goto LABEL_217;
      }
      unsigned int v31 = v23 >> 31;
      int v32 = v22 - 1;
      *(_DWORD *)(a3 + 28) = v22 - 1;
      if (v22 - 1 < 0)
      {
        unint64_t v34 = *(void *)(a3 + 8);
        if (((v4 - v5) & ~((uint64_t)(v4 - (void)v5) >> 63) & 0xFFFFFFFC) != 0
          && v34 <= (unint64_t)v5)
        {
          unsigned int v23 = bswap32(*v5);
        }
        else
        {
          uint64_t v35 = 0;
          do
          {
            unsigned int v36 = (unsigned __int8 *)v5 + v35;
            unsigned int v37 = v23 << 8;
            *(_DWORD *)(a3 + 24) = v37;
            int v38 = 255;
            if ((unint64_t)v5 + v35 < v4 && (unint64_t)v36 >= v34) {
              int v38 = *v36;
            }
            unsigned int v23 = v38 | v37;
            *(_DWORD *)(a3 + 24) = v23;
            ++v35;
          }
          while (v35 != 4);
        }
        int v40 = v22 + 31;
        BOOL v39 = v22 == -31;
        *(_DWORD *)(a3 + 28) = v22 + 31;
        *(void *)a3 = ++v5;
        v31 |= v23 >> (v22 + 31);
        if (v22 == -31) {
          unsigned int v33 = 0;
        }
        else {
          unsigned int v33 = v23 << (1 - v22);
        }
        if (v39) {
          int v32 = 0;
        }
        else {
          int v32 = v40;
        }
      }
      else
      {
        unsigned int v33 = 2 * v23;
      }
      *(_DWORD *)(a3 + 24) = v33;
      *(unsigned char *)(a2 + 2) = v31 != 0;
      uint64_t v41 = v4 - (void)v5;
      int v42 = v32 + 8 * (v4 - v5);
      if (v31)
      {
        if (v42 > 3)
        {
          unsigned int v43 = v33 >> 28;
          *(_DWORD *)(a3 + 28) = v32 - 4;
          if (v32 - 4 < 0)
          {
            unint64_t v48 = *(void *)(a3 + 8);
            if ((v41 & ~(v41 >> 63) & 0xFFFFFFFC) != 0 && v48 <= (unint64_t)v5)
            {
              unsigned int v33 = bswap32(*v5);
            }
            else
            {
              uint64_t v50 = 0;
              do
              {
                int v51 = (unsigned __int8 *)v5 + v50;
                unsigned int v52 = v33 << 8;
                *(_DWORD *)(a3 + 24) = v52;
                int v53 = 255;
                if ((unint64_t)v5 + v50 < v4 && (unint64_t)v51 >= v48) {
                  int v53 = *v51;
                }
                unsigned int v33 = v53 | v52;
                *(_DWORD *)(a3 + 24) = v33;
                ++v50;
              }
              while (v50 != 4);
            }
            int v44 = v33 << (4 - v32);
            int v54 = v32 + 28;
            *(_DWORD *)(a3 + 28) = v54;
            *(void *)a3 = v5 + 1;
            v43 |= v33 >> v54;
            if (!v54) {
              int v44 = 0;
            }
          }
          else
          {
            int v44 = 16 * v33;
          }
          *(_DWORD *)(a3 + 24) = v44;
          *(unsigned char *)(a2 + 4) = v43;
          return;
        }
        exception = __cxa_allocate_exception(8uLL);
        unint64_t v179 = "Cannot read mZ.zoneIndex";
LABEL_217:
        void *exception = v179;
        __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
      }
      if (v42 <= 0)
      {
        exception = __cxa_allocate_exception(8uLL);
        unint64_t v179 = "Cannot read mZ.cartesian";
        goto LABEL_217;
      }
      unsigned int v45 = v33 >> 31;
      int v46 = v32 - 1;
      *(_DWORD *)(a3 + 28) = v32 - 1;
      if (v32 - 1 < 0)
      {
        unint64_t v49 = *(void *)(a3 + 8);
        if ((v41 & ~(v41 >> 63) & 0xFFFFFFFC) != 0 && v49 <= (unint64_t)v5)
        {
          unsigned int v33 = bswap32(*v5);
        }
        else
        {
          uint64_t v55 = 0;
          do
          {
            int v56 = (unsigned __int8 *)v5 + v55;
            unsigned int v57 = v33 << 8;
            *(_DWORD *)(a3 + 24) = v57;
            int v58 = 255;
            if ((unint64_t)v5 + v55 < v4 && (unint64_t)v56 >= v49) {
              int v58 = *v56;
            }
            unsigned int v33 = v58 | v57;
            *(_DWORD *)(a3 + 24) = v33;
            ++v55;
          }
          while (v55 != 4);
        }
        int v59 = v33 << (1 - v32);
        int v60 = v32 + 31;
        *(_DWORD *)(a3 + 28) = v60;
        *(void *)a3 = ++v5;
        v45 |= v33 >> v60;
        if (v60) {
          int v47 = v59;
        }
        else {
          int v47 = 0;
        }
        if (v60) {
          int v46 = v60;
        }
        else {
          int v46 = 0;
        }
      }
      else
      {
        int v47 = 2 * v33;
      }
      *(_DWORD *)(a3 + 24) = v47;
      *(unsigned char *)(a2 + 3) = v45 != 0;
      int v61 = v46 + 8 * (v4 - v5);
      if (v45)
      {
        if (v61 <= 31)
        {
          exception = __cxa_allocate_exception(8uLL);
          unint64_t v179 = "Cannot read mZ.co_tu.cartesian.minX";
          goto LABEL_217;
        }
        *(_DWORD *)(a3 + 28) = v46 - 32;
        if (v46 - 32 < 0)
        {
          unint64_t v62 = *(void *)(a3 + 8);
          if (((v4 - v5) & ~((uint64_t)(v4 - (void)v5) >> 63) & 0xFFFFFFFC) != 0
            && v62 <= (unint64_t)v5)
          {
            unsigned int v63 = bswap32(*v5);
          }
          else
          {
            uint64_t v108 = 0;
            unsigned int v63 = v47;
            do
            {
              unsigned int v109 = (unsigned __int8 *)v5 + v108;
              unsigned int v110 = v63 << 8;
              *(_DWORD *)(a3 + 24) = v110;
              int v111 = 255;
              if ((unint64_t)v5 + v108 < v4 && (unint64_t)v109 >= v62) {
                int v111 = *v109;
              }
              unsigned int v63 = v111 | v110;
              *(_DWORD *)(a3 + 24) = v63;
              ++v108;
            }
            while (v108 != 4);
          }
          *(void *)a3 = v5 + 1;
          v47 |= v63 >> v46;
          unsigned int v112 = v63 << -(char)v46;
          if (!v46) {
            unsigned int v112 = 0;
          }
          *(_DWORD *)(a3 + 24) = v112;
          *(_DWORD *)(a3 + 28) = v46;
        }
        *(_DWORD *)(a2 + 8) = v47;
        unint64_t v113 = *(void *)(a3 + 16);
        int v114 = *(unsigned int **)a3;
        uint64_t v115 = v113 - *(void *)a3;
        int v116 = *(_DWORD *)(a3 + 28);
        if (v116 + 8 * (int)v115 <= 31)
        {
          exception = __cxa_allocate_exception(8uLL);
          unint64_t v179 = "Cannot read mZ.co_tu.cartesian.maxX";
          goto LABEL_217;
        }
        unsigned int v117 = *(_DWORD *)(a3 + 24);
        *(_DWORD *)(a3 + 28) = v116 - 32;
        if (v116 - 32 < 0)
        {
          int v118 = v115 & ~(v115 >> 63);
          unint64_t v119 = *(void *)(a3 + 8);
          if ((v118 & 0xFFFFFFFC) != 0 && v119 <= (unint64_t)v114)
          {
            unsigned int v120 = bswap32(*v114);
          }
          else
          {
            uint64_t v121 = 0;
            unsigned int v120 = v117;
            do
            {
              int v122 = (unsigned __int8 *)v114 + v121;
              unsigned int v123 = v120 << 8;
              *(_DWORD *)(a3 + 24) = v123;
              int v124 = 255;
              if ((unint64_t)v114 + v121 < v113 && (unint64_t)v122 >= v119) {
                int v124 = *v122;
              }
              unsigned int v120 = v124 | v123;
              *(_DWORD *)(a3 + 24) = v120;
              ++v121;
            }
            while (v121 != 4);
          }
          *(void *)a3 = v114 + 1;
          v117 |= v120 >> v116;
          unsigned int v125 = v120 << -(char)v116;
          if (!v116) {
            unsigned int v125 = 0;
          }
          *(_DWORD *)(a3 + 24) = v125;
          *(_DWORD *)(a3 + 28) = v116;
        }
        *(_DWORD *)(a2 + 12) = v117;
        unint64_t v126 = *(void *)(a3 + 16);
        unsigned int v127 = *(unsigned int **)a3;
        uint64_t v128 = v126 - *(void *)a3;
        int v129 = *(_DWORD *)(a3 + 28);
        if (v129 + 8 * (int)v128 <= 31)
        {
          exception = __cxa_allocate_exception(8uLL);
          unint64_t v179 = "Cannot read mZ.co_tu.cartesian.minY";
          goto LABEL_217;
        }
        unsigned int v130 = *(_DWORD *)(a3 + 24);
        *(_DWORD *)(a3 + 28) = v129 - 32;
        if (v129 - 32 < 0)
        {
          int v131 = v128 & ~(v128 >> 63);
          unint64_t v132 = *(void *)(a3 + 8);
          if ((v131 & 0xFFFFFFFC) != 0 && v132 <= (unint64_t)v127)
          {
            unsigned int v133 = bswap32(*v127);
          }
          else
          {
            uint64_t v134 = 0;
            unsigned int v133 = v130;
            do
            {
              uint64_t v135 = (unsigned __int8 *)v127 + v134;
              unsigned int v136 = v133 << 8;
              *(_DWORD *)(a3 + 24) = v136;
              int v137 = 255;
              if ((unint64_t)v127 + v134 < v126 && (unint64_t)v135 >= v132) {
                int v137 = *v135;
              }
              unsigned int v133 = v137 | v136;
              *(_DWORD *)(a3 + 24) = v133;
              ++v134;
            }
            while (v134 != 4);
          }
          *(void *)a3 = v127 + 1;
          v130 |= v133 >> v129;
          unsigned int v138 = v133 << -(char)v129;
          if (!v129) {
            unsigned int v138 = 0;
          }
          *(_DWORD *)(a3 + 24) = v138;
          *(_DWORD *)(a3 + 28) = v129;
        }
        *(_DWORD *)(a2 + 16) = v130;
        unint64_t v139 = *(void *)(a3 + 16);
        int v140 = *(unsigned int **)a3;
        uint64_t v141 = v139 - *(void *)a3;
        int v142 = *(_DWORD *)(a3 + 28);
        if (v142 + 8 * (int)v141 <= 31)
        {
          exception = __cxa_allocate_exception(8uLL);
          unint64_t v179 = "Cannot read mZ.co_tu.cartesian.maxY";
          goto LABEL_217;
        }
        unsigned int v143 = *(_DWORD *)(a3 + 24);
        *(_DWORD *)(a3 + 28) = v142 - 32;
        if (v142 - 32 < 0)
        {
          int v144 = v141 & ~(v141 >> 63);
          unint64_t v145 = *(void *)(a3 + 8);
          if ((v144 & 0xFFFFFFFC) != 0 && v145 <= (unint64_t)v140)
          {
            unsigned int v146 = bswap32(*v140);
          }
          else
          {
            uint64_t v147 = 0;
            unsigned int v146 = v143;
            do
            {
              unint64_t v148 = (unsigned __int8 *)v140 + v147;
              unsigned int v149 = v146 << 8;
              *(_DWORD *)(a3 + 24) = v149;
              int v150 = 255;
              if ((unint64_t)v140 + v147 < v139 && (unint64_t)v148 >= v145) {
                int v150 = *v148;
              }
              unsigned int v146 = v150 | v149;
              *(_DWORD *)(a3 + 24) = v146;
              ++v147;
            }
            while (v147 != 4);
          }
          *(void *)a3 = v140 + 1;
          v143 |= v146 >> v142;
          unsigned int v151 = v146 << -(char)v142;
          if (!v142) {
            unsigned int v151 = 0;
          }
          *(_DWORD *)(a3 + 24) = v151;
          *(_DWORD *)(a3 + 28) = v142;
        }
        *(_DWORD *)(a2 + 20) = v143;
        unint64_t v152 = *(void *)(a3 + 16);
        int v153 = *(unsigned int **)a3;
        uint64_t v154 = v152 - *(void *)a3;
        int v155 = *(_DWORD *)(a3 + 28);
        if (v155 + 8 * (int)v154 <= 31)
        {
          exception = __cxa_allocate_exception(8uLL);
          unint64_t v179 = "Cannot read mZ.co_tu.cartesian.minZ";
          goto LABEL_217;
        }
        unsigned int v156 = *(_DWORD *)(a3 + 24);
        *(_DWORD *)(a3 + 28) = v155 - 32;
        if (v155 - 32 < 0)
        {
          int v157 = v154 & ~(v154 >> 63);
          unint64_t v158 = *(void *)(a3 + 8);
          if ((v157 & 0xFFFFFFFC) != 0 && v158 <= (unint64_t)v153)
          {
            unsigned int v159 = bswap32(*v153);
          }
          else
          {
            uint64_t v160 = 0;
            unsigned int v159 = v156;
            do
            {
              unsigned int v161 = (unsigned __int8 *)v153 + v160;
              unsigned int v162 = v159 << 8;
              *(_DWORD *)(a3 + 24) = v162;
              int v163 = 255;
              if ((unint64_t)v153 + v160 < v152 && (unint64_t)v161 >= v158) {
                int v163 = *v161;
              }
              unsigned int v159 = v163 | v162;
              *(_DWORD *)(a3 + 24) = v159;
              ++v160;
            }
            while (v160 != 4);
          }
          *(void *)a3 = v153 + 1;
          v156 |= v159 >> v155;
          unsigned int v164 = v159 << -(char)v155;
          if (!v155) {
            unsigned int v164 = 0;
          }
          *(_DWORD *)(a3 + 24) = v164;
          *(_DWORD *)(a3 + 28) = v155;
        }
        *(_DWORD *)(a2 + 24) = v156;
        unint64_t v165 = *(void *)(a3 + 16);
        unint64_t v166 = *(unsigned int **)a3;
        uint64_t v167 = v165 - *(void *)a3;
        int v168 = *(_DWORD *)(a3 + 28);
        if (v168 + 8 * (int)v167 <= 31)
        {
          exception = __cxa_allocate_exception(8uLL);
          unint64_t v179 = "Cannot read mZ.co_tu.cartesian.maxZ";
          goto LABEL_217;
        }
        unsigned int v169 = *(_DWORD *)(a3 + 24);
        *(_DWORD *)(a3 + 28) = v168 - 32;
        if (v168 - 32 < 0)
        {
          int v170 = v167 & ~(v167 >> 63);
          unint64_t v171 = *(void *)(a3 + 8);
          if ((v170 & 0xFFFFFFFC) != 0 && v171 <= (unint64_t)v166)
          {
            unsigned int v172 = bswap32(*v166);
          }
          else
          {
            uint64_t v173 = 0;
            unsigned int v172 = v169;
            do
            {
              unsigned int v174 = (unsigned __int8 *)v166 + v173;
              unsigned int v175 = v172 << 8;
              *(_DWORD *)(a3 + 24) = v175;
              int v176 = 255;
              if ((unint64_t)v166 + v173 < v165 && (unint64_t)v174 >= v171) {
                int v176 = *v174;
              }
              unsigned int v172 = v176 | v175;
              *(_DWORD *)(a3 + 24) = v172;
              ++v173;
            }
            while (v173 != 4);
          }
          *(void *)a3 = v166 + 1;
          v169 |= v172 >> v168;
          unsigned int v177 = v172 << -(char)v168;
          if (!v168) {
            unsigned int v177 = 0;
          }
          *(_DWORD *)(a3 + 24) = v177;
          *(_DWORD *)(a3 + 28) = v168;
        }
        *(_DWORD *)(a2 + 28) = v169;
      }
      else
      {
        if (v61 <= 31)
        {
          exception = __cxa_allocate_exception(8uLL);
          unint64_t v179 = "Cannot read mZ.co_tu.spherical.minAzimuth";
          goto LABEL_217;
        }
        *(_DWORD *)(a3 + 28) = v46 - 32;
        if (v46 - 32 < 0)
        {
          AT::TBitstreamReader<unsigned int>::FillCacheFrom(a3, v5);
          unsigned int v65 = *(_DWORD *)(a3 + 24);
          int v64 = *(_DWORD *)(a3 + 28);
          int v66 = v64 + 32;
          BOOL v39 = v64 == -32;
          *(void *)a3 += 4;
          v47 |= v65 >> v64;
          int v67 = v65 << -(char)v64;
          if (v39) {
            int v67 = 0;
          }
          *(_DWORD *)(a3 + 24) = v67;
          *(_DWORD *)(a3 + 28) = v66;
        }
        *(_DWORD *)(a2 + 8) = v47;
        unsigned int v68 = *(unsigned int **)a3;
        int v69 = *(_DWORD *)(a3 + 28);
        if ((int)(v69 + 8 * (*(_DWORD *)(a3 + 16) - *(void *)a3)) <= 31)
        {
          exception = __cxa_allocate_exception(8uLL);
          unint64_t v179 = "Cannot read mZ.co_tu.spherical.maxAzimuth";
          goto LABEL_217;
        }
        int v70 = *(_DWORD *)(a3 + 24);
        int v71 = v69 - 32;
        *(_DWORD *)(a3 + 28) = v71;
        if (v71 < 0)
        {
          AT::TBitstreamReader<unsigned int>::FillCacheFrom(a3, v68);
          unsigned int v73 = *(_DWORD *)(a3 + 24);
          int v72 = *(_DWORD *)(a3 + 28);
          int v74 = v72 + 32;
          BOOL v39 = v72 == -32;
          *(void *)a3 += 4;
          v70 |= v73 >> v72;
          int v75 = v73 << -(char)v72;
          if (v39) {
            int v75 = 0;
          }
          *(_DWORD *)(a3 + 24) = v75;
          *(_DWORD *)(a3 + 28) = v74;
        }
        *(_DWORD *)(a2 + 12) = v70;
        unsigned int v76 = *(unsigned int **)a3;
        int v77 = *(_DWORD *)(a3 + 28);
        if ((int)(v77 + 8 * (*(_DWORD *)(a3 + 16) - *(void *)a3)) <= 31)
        {
          exception = __cxa_allocate_exception(8uLL);
          unint64_t v179 = "Cannot read mZ.co_tu.spherical.minElevation";
          goto LABEL_217;
        }
        int v78 = *(_DWORD *)(a3 + 24);
        int v79 = v77 - 32;
        *(_DWORD *)(a3 + 28) = v79;
        if (v79 < 0)
        {
          AT::TBitstreamReader<unsigned int>::FillCacheFrom(a3, v76);
          unsigned int v81 = *(_DWORD *)(a3 + 24);
          int v80 = *(_DWORD *)(a3 + 28);
          int v82 = v80 + 32;
          BOOL v39 = v80 == -32;
          *(void *)a3 += 4;
          v78 |= v81 >> v80;
          int v83 = v81 << -(char)v80;
          if (v39) {
            int v83 = 0;
          }
          *(_DWORD *)(a3 + 24) = v83;
          *(_DWORD *)(a3 + 28) = v82;
        }
        *(_DWORD *)(a2 + 16) = v78;
        int v84 = *(unsigned int **)a3;
        int v85 = *(_DWORD *)(a3 + 28);
        if ((int)(v85 + 8 * (*(_DWORD *)(a3 + 16) - *(void *)a3)) <= 31)
        {
          exception = __cxa_allocate_exception(8uLL);
          unint64_t v179 = "Cannot read mZ.co_tu.spherical.maxElevation";
          goto LABEL_217;
        }
        int v86 = *(_DWORD *)(a3 + 24);
        int v87 = v85 - 32;
        *(_DWORD *)(a3 + 28) = v87;
        if (v87 < 0)
        {
          AT::TBitstreamReader<unsigned int>::FillCacheFrom(a3, v84);
          unsigned int v89 = *(_DWORD *)(a3 + 24);
          int v88 = *(_DWORD *)(a3 + 28);
          int v90 = v88 + 32;
          BOOL v39 = v88 == -32;
          *(void *)a3 += 4;
          v86 |= v89 >> v88;
          int v91 = v89 << -(char)v88;
          if (v39) {
            int v91 = 0;
          }
          *(_DWORD *)(a3 + 24) = v91;
          *(_DWORD *)(a3 + 28) = v90;
        }
        *(_DWORD *)(a2 + 20) = v86;
        uint64_t v92 = *(unsigned int **)a3;
        int v93 = *(_DWORD *)(a3 + 28);
        if ((int)(v93 + 8 * (*(_DWORD *)(a3 + 16) - *(void *)a3)) <= 31)
        {
          exception = __cxa_allocate_exception(8uLL);
          unint64_t v179 = "Cannot read mZ.co_tu.spherical.minDistance";
          goto LABEL_217;
        }
        int v94 = *(_DWORD *)(a3 + 24);
        int v95 = v93 - 32;
        *(_DWORD *)(a3 + 28) = v95;
        if (v95 < 0)
        {
          AT::TBitstreamReader<unsigned int>::FillCacheFrom(a3, v92);
          unsigned int v97 = *(_DWORD *)(a3 + 24);
          int v96 = *(_DWORD *)(a3 + 28);
          int v98 = v96 + 32;
          BOOL v39 = v96 == -32;
          *(void *)a3 += 4;
          v94 |= v97 >> v96;
          int v99 = v97 << -(char)v96;
          if (v39) {
            int v99 = 0;
          }
          *(_DWORD *)(a3 + 24) = v99;
          *(_DWORD *)(a3 + 28) = v98;
        }
        *(_DWORD *)(a2 + 24) = v94;
        unsigned int v100 = *(unsigned int **)a3;
        int v101 = *(_DWORD *)(a3 + 28);
        if ((int)(v101 + 8 * (*(_DWORD *)(a3 + 16) - *(void *)a3)) <= 31)
        {
          exception = __cxa_allocate_exception(8uLL);
          unint64_t v179 = "Cannot read mZ.co_tu.spherical.maxDistance";
          goto LABEL_217;
        }
        int v102 = *(_DWORD *)(a3 + 24);
        int v103 = v101 - 32;
        *(_DWORD *)(a3 + 28) = v103;
        if (v103 < 0)
        {
          AT::TBitstreamReader<unsigned int>::FillCacheFrom(a3, v100);
          unsigned int v105 = *(_DWORD *)(a3 + 24);
          int v104 = *(_DWORD *)(a3 + 28);
          int v106 = v104 + 32;
          BOOL v39 = v104 == -32;
          *(void *)a3 += 4;
          v102 |= v105 >> v104;
          int v107 = v105 << -(char)v104;
          if (v39) {
            int v107 = 0;
          }
          *(_DWORD *)(a3 + 24) = v107;
          *(_DWORD *)(a3 + 28) = v106;
        }
        *(_DWORD *)(a2 + 28) = v102;
      }
    }
  }
}

void APAC::MetadataBitStreamParser::parseBlockData(uint64_t a1, uint64_t a2, __int16 a3, uint64_t a4)
{
  if (!*(unsigned char *)a2) {
    return;
  }
  unint64_t v5 = *(void *)(a4 + 16);
  uint64_t v6 = *(unsigned int **)a4;
  uint64_t v7 = v5 - *(void *)a4;
  int v8 = *(_DWORD *)(a4 + 28);
  if (v8 + 8 * (int)v7 <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    v627 = "Cannot read blkData.cartesian";
    goto LABEL_935;
  }
  int v11 = (_DWORD *)(a4 + 24);
  unsigned int v10 = *(_DWORD *)(a4 + 24);
  unsigned int v12 = v10 >> 31;
  int v13 = v8 - 1;
  *(_DWORD *)(a4 + 28) = v8 - 1;
  if (v8 - 1 < 0)
  {
    unint64_t v15 = *(void *)(a4 + 8);
    if ((v7 & ~(v7 >> 63) & 0xFFFFFFFC) == 0 || v15 > (unint64_t)v6)
    {
      uint64_t v17 = 0;
      do
      {
        int v18 = (unsigned __int8 *)v6 + v17;
        unsigned int v19 = v10 << 8;
        *int v11 = v19;
        int v20 = 255;
        if ((unint64_t)v6 + v17 < v5 && (unint64_t)v18 >= v15) {
          int v20 = *v18;
        }
        unsigned int v10 = v20 | v19;
        *int v11 = v10;
        ++v17;
      }
      while (v17 != 4);
    }
    else
    {
      unsigned int v10 = bswap32(*v6);
    }
    int v22 = v8 + 31;
    BOOL v21 = v8 == -31;
    *(_DWORD *)(a4 + 28) = v8 + 31;
    *(void *)a4 = ++v6;
    v12 |= v10 >> (v8 + 31);
    if (v8 == -31) {
      int v14 = 0;
    }
    else {
      int v14 = v10 << (1 - v8);
    }
    if (v21) {
      int v13 = 0;
    }
    else {
      int v13 = v22;
    }
  }
  else
  {
    int v14 = 2 * v10;
  }
  *int v11 = v14;
  *(unsigned char *)(a2 + 4) = v12 != 0;
  uint64_t v23 = v5 - (void)v6;
  int v24 = v13 + 8 * (v5 - v6);
  if (v12)
  {
    if (v24 <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      v627 = "Cannot read blkData.position.co_ut.cartesian.X";
      goto LABEL_935;
    }
    *(_DWORD *)(a4 + 28) = v13 - 32;
    if (v13 - 32 < 0)
    {
      unint64_t v25 = *(void *)(a4 + 8);
      if ((v23 & ~(v23 >> 63) & 0xFFFFFFFC) != 0 && v25 <= (unint64_t)v6)
      {
        unsigned int v26 = bswap32(*v6);
      }
      else
      {
        uint64_t v29 = 0;
        unsigned int v26 = v14;
        do
        {
          int v30 = (unsigned __int8 *)v6 + v29;
          unsigned int v31 = v26 << 8;
          *int v11 = v31;
          int v32 = 255;
          if ((unint64_t)v6 + v29 < v5 && (unint64_t)v30 >= v25) {
            int v32 = *v30;
          }
          unsigned int v26 = v32 | v31;
          *int v11 = v26;
          ++v29;
        }
        while (v29 != 4);
      }
      *(void *)a4 = v6 + 1;
      v14 |= v26 >> v13;
      unsigned int v33 = v26 << -(char)v13;
      if (!v13) {
        unsigned int v33 = 0;
      }
      *(_DWORD *)(a4 + 24) = v33;
      *(_DWORD *)(a4 + 28) = v13;
    }
    *(_DWORD *)(a2 + 8) = v14;
    unint64_t v34 = *(void *)(a4 + 16);
    uint64_t v35 = *(unsigned int **)a4;
    uint64_t v36 = v34 - *(void *)a4;
    int v37 = *(_DWORD *)(a4 + 28);
    if (v37 + 8 * (int)v36 <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      v627 = "Cannot read blkData.position.co_ut.cartesian.Y";
      goto LABEL_935;
    }
    unsigned int v38 = *(_DWORD *)(a4 + 24);
    *(_DWORD *)(a4 + 28) = v37 - 32;
    if (v37 - 32 < 0)
    {
      int v39 = v36 & ~(v36 >> 63);
      unint64_t v40 = *(void *)(a4 + 8);
      if ((v39 & 0xFFFFFFFC) != 0 && v40 <= (unint64_t)v35)
      {
        unsigned int v41 = bswap32(*v35);
      }
      else
      {
        uint64_t v42 = 0;
        unsigned int v41 = v38;
        do
        {
          unsigned int v43 = (unsigned __int8 *)v35 + v42;
          unsigned int v44 = v41 << 8;
          *int v11 = v44;
          int v45 = 255;
          if ((unint64_t)v35 + v42 < v34 && (unint64_t)v43 >= v40) {
            int v45 = *v43;
          }
          unsigned int v41 = v45 | v44;
          *int v11 = v41;
          ++v42;
        }
        while (v42 != 4);
      }
      *(void *)a4 = v35 + 1;
      v38 |= v41 >> v37;
      unsigned int v46 = v41 << -(char)v37;
      if (!v37) {
        unsigned int v46 = 0;
      }
      *(_DWORD *)(a4 + 24) = v46;
      *(_DWORD *)(a4 + 28) = v37;
    }
    *(_DWORD *)(a2 + 12) = v38;
    unint64_t v47 = *(void *)(a4 + 16);
    unint64_t v48 = *(unsigned int **)a4;
    uint64_t v49 = v47 - *(void *)a4;
    int v50 = *(_DWORD *)(a4 + 28);
    if (v50 + 8 * (int)v49 <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      v627 = "Cannot read blkData.position.co_ut.cartesian.Z";
      goto LABEL_935;
    }
    unsigned int v51 = *(_DWORD *)(a4 + 24);
    *(_DWORD *)(a4 + 28) = v50 - 32;
    if (v50 - 32 < 0)
    {
      unint64_t v52 = *(void *)(a4 + 8);
      if ((v49 & ~(v49 >> 63) & 0xFFFFFFFC) == 0 || v52 > (unint64_t)v48)
      {
        uint64_t v53 = 0;
        unsigned int v54 = v51;
        do
        {
          uint64_t v55 = (unsigned __int8 *)v48 + v53;
          unsigned int v56 = v54 << 8;
          *int v11 = v56;
          int v57 = 255;
          if ((unint64_t)v48 + v53 < v47 && (unint64_t)v55 >= v52) {
            int v57 = *v55;
          }
          unsigned int v54 = v57 | v56;
          *int v11 = v54;
          ++v53;
        }
        while (v53 != 4);
        goto LABEL_94;
      }
LABEL_88:
      unsigned int v54 = bswap32(*v48);
LABEL_94:
      *(_DWORD *)(a4 + 28) = v50;
      *(void *)a4 = v48 + 1;
      v51 |= v54 >> v50;
      if (v50) {
        unsigned int v83 = v54 << -(char)v50;
      }
      else {
        unsigned int v83 = 0;
      }
      *int v11 = v83;
    }
  }
  else
  {
    if (v24 <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      v627 = "Cannot read blkData.position.co_ut.spherical.azimuth";
      goto LABEL_935;
    }
    *(_DWORD *)(a4 + 28) = v13 - 32;
    if (v13 - 32 < 0)
    {
      unint64_t v27 = *(void *)(a4 + 8);
      if ((v23 & ~(v23 >> 63) & 0xFFFFFFFC) != 0 && v27 <= (unint64_t)v6)
      {
        unsigned int v28 = bswap32(*v6);
      }
      else
      {
        uint64_t v58 = 0;
        unsigned int v28 = v14;
        do
        {
          int v59 = (unsigned __int8 *)v6 + v58;
          unsigned int v60 = v28 << 8;
          *int v11 = v60;
          int v61 = 255;
          if ((unint64_t)v6 + v58 < v5 && (unint64_t)v59 >= v27) {
            int v61 = *v59;
          }
          unsigned int v28 = v61 | v60;
          *int v11 = v28;
          ++v58;
        }
        while (v58 != 4);
      }
      *(void *)a4 = v6 + 1;
      v14 |= v28 >> v13;
      unsigned int v62 = v28 << -(char)v13;
      if (!v13) {
        unsigned int v62 = 0;
      }
      *(_DWORD *)(a4 + 24) = v62;
      *(_DWORD *)(a4 + 28) = v13;
    }
    *(_DWORD *)(a2 + 8) = v14;
    unint64_t v63 = *(void *)(a4 + 16);
    int v64 = *(unsigned int **)a4;
    uint64_t v65 = v63 - *(void *)a4;
    int v66 = *(_DWORD *)(a4 + 28);
    if (v66 + 8 * (int)v65 <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      v627 = "Cannot read blkData.position.co_ut.spherical.elevation";
      goto LABEL_935;
    }
    unsigned int v67 = *(_DWORD *)(a4 + 24);
    *(_DWORD *)(a4 + 28) = v66 - 32;
    if (v66 - 32 < 0)
    {
      int v68 = v65 & ~(v65 >> 63);
      unint64_t v69 = *(void *)(a4 + 8);
      if ((v68 & 0xFFFFFFFC) != 0 && v69 <= (unint64_t)v64)
      {
        unsigned int v70 = bswap32(*v64);
      }
      else
      {
        uint64_t v71 = 0;
        unsigned int v70 = v67;
        do
        {
          int v72 = (unsigned __int8 *)v64 + v71;
          unsigned int v73 = v70 << 8;
          *int v11 = v73;
          int v74 = 255;
          if ((unint64_t)v64 + v71 < v63 && (unint64_t)v72 >= v69) {
            int v74 = *v72;
          }
          unsigned int v70 = v74 | v73;
          *int v11 = v70;
          ++v71;
        }
        while (v71 != 4);
      }
      *(void *)a4 = v64 + 1;
      v67 |= v70 >> v66;
      unsigned int v75 = v70 << -(char)v66;
      if (!v66) {
        unsigned int v75 = 0;
      }
      *(_DWORD *)(a4 + 24) = v75;
      *(_DWORD *)(a4 + 28) = v66;
    }
    *(_DWORD *)(a2 + 12) = v67;
    unint64_t v76 = *(void *)(a4 + 16);
    unint64_t v48 = *(unsigned int **)a4;
    uint64_t v77 = v76 - *(void *)a4;
    int v50 = *(_DWORD *)(a4 + 28);
    if (v50 + 8 * (int)v77 <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      v627 = "Cannot read blkData.position.co_ut.spherical.distance";
      goto LABEL_935;
    }
    unsigned int v51 = *(_DWORD *)(a4 + 24);
    *(_DWORD *)(a4 + 28) = v50 - 32;
    if (v50 - 32 < 0)
    {
      unint64_t v78 = *(void *)(a4 + 8);
      if ((v77 & ~(v77 >> 63) & 0xFFFFFFFC) == 0 || v78 > (unint64_t)v48)
      {
        uint64_t v79 = 0;
        unsigned int v54 = v51;
        do
        {
          int v80 = (unsigned __int8 *)v48 + v79;
          unsigned int v81 = v54 << 8;
          *int v11 = v81;
          int v82 = 255;
          if ((unint64_t)v48 + v79 < v76 && (unint64_t)v80 >= v78) {
            int v82 = *v80;
          }
          unsigned int v54 = v82 | v81;
          *int v11 = v54;
          ++v79;
        }
        while (v79 != 4);
        goto LABEL_94;
      }
      goto LABEL_88;
    }
  }
  *(_DWORD *)(a2 + 16) = v51;
  unint64_t v84 = *(void *)(a4 + 16);
  int v85 = *(unsigned int **)a4;
  uint64_t v86 = v84 - *(void *)a4;
  int v87 = *(_DWORD *)(a4 + 28);
  if (v87 + 8 * (int)v86 <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    v627 = "Cannot read blkData.hasADMMetadata";
    goto LABEL_935;
  }
  unsigned int v88 = *(_DWORD *)(a4 + 24);
  unsigned int v89 = v88 >> 31;
  int v90 = v87 - 1;
  *(_DWORD *)(a4 + 28) = v87 - 1;
  if (v87 - 1 < 0)
  {
    unint64_t v92 = *(void *)(a4 + 8);
    if ((v86 & ~(v86 >> 63) & 0xFFFFFFFC) != 0 && v92 <= (unint64_t)v85)
    {
      unsigned int v88 = bswap32(*v85);
    }
    else
    {
      uint64_t v93 = 0;
      do
      {
        int v94 = (unsigned __int8 *)v85 + v93;
        unsigned int v95 = v88 << 8;
        *int v11 = v95;
        int v96 = 255;
        if ((unint64_t)v85 + v93 < v84 && (unint64_t)v94 >= v92) {
          int v96 = *v94;
        }
        unsigned int v88 = v96 | v95;
        *int v11 = v88;
        ++v93;
      }
      while (v93 != 4);
    }
    int v98 = v87 + 31;
    BOOL v97 = v87 == -31;
    *(_DWORD *)(a4 + 28) = v87 + 31;
    *(void *)a4 = ++v85;
    v89 |= v88 >> (v87 + 31);
    if (v87 == -31) {
      unsigned int v91 = 0;
    }
    else {
      unsigned int v91 = v88 << (1 - v87);
    }
    if (v97) {
      int v90 = 0;
    }
    else {
      int v90 = v98;
    }
  }
  else
  {
    unsigned int v91 = 2 * v88;
  }
  *int v11 = v91;
  *(unsigned char *)(a2 + 20) = v89 != 0;
  if (!v89) {
    return;
  }
  if (v90 + 8 * ((int)v84 - (int)v85) <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    v627 = "Cannot read blkData.absoluteDistance.hasData";
    goto LABEL_935;
  }
  unsigned int v99 = v91 >> 31;
  int v100 = v90 - 1;
  *(_DWORD *)(a4 + 28) = v90 - 1;
  if (v90 - 1 < 0)
  {
    unint64_t v102 = *(void *)(a4 + 8);
    if (((v84 - v85) & ~((uint64_t)(v84 - (void)v85) >> 63) & 0xFFFFFFFC) != 0
      && v102 <= (unint64_t)v85)
    {
      unsigned int v91 = bswap32(*v85);
    }
    else
    {
      uint64_t v103 = 0;
      do
      {
        int v104 = (unsigned __int8 *)v85 + v103;
        unsigned int v105 = v91 << 8;
        *int v11 = v105;
        int v106 = 255;
        if ((unint64_t)v85 + v103 < v84 && (unint64_t)v104 >= v102) {
          int v106 = *v104;
        }
        unsigned int v91 = v106 | v105;
        *int v11 = v91;
        ++v103;
      }
      while (v103 != 4);
    }
    unsigned int v107 = v91 << (1 - v90);
    int v108 = v90 + 31;
    *(_DWORD *)(a4 + 28) = v108;
    *(void *)a4 = ++v85;
    v99 |= v91 >> v108;
    if (v108) {
      unsigned int v101 = v107;
    }
    else {
      unsigned int v101 = 0;
    }
    if (v108) {
      int v100 = v108;
    }
    else {
      int v100 = 0;
    }
  }
  else
  {
    unsigned int v101 = 2 * v91;
  }
  *int v11 = v101;
  *(unsigned char *)(a2 + 24) = v99 != 0;
  if (v99)
  {
    if (v100 + 8 * ((int)v84 - (int)v85) <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      v627 = "Cannot read blkData.absoluteDistance.distance";
      goto LABEL_935;
    }
    *(_DWORD *)(a4 + 28) = v100 - 32;
    if (v100 - 32 < 0)
    {
      unint64_t v110 = *(void *)(a4 + 8);
      if (((v84 - v85) & ~((uint64_t)(v84 - (void)v85) >> 63) & 0xFFFFFFFC) != 0
        && v110 <= (unint64_t)v85)
      {
        unsigned int v111 = bswap32(*v85);
      }
      else
      {
        uint64_t v112 = 0;
        unsigned int v111 = v101;
        do
        {
          unint64_t v113 = (unsigned __int8 *)v85 + v112;
          unsigned int v114 = v111 << 8;
          *int v11 = v114;
          int v115 = 255;
          if ((unint64_t)v85 + v112 < v84 && (unint64_t)v113 >= v110) {
            int v115 = *v113;
          }
          unsigned int v111 = v115 | v114;
          *int v11 = v111;
          ++v112;
        }
        while (v112 != 4);
      }
      *(void *)a4 = ++v85;
      int v109 = (v111 >> v100) | v101;
      unsigned int v101 = v111 << -(char)v100;
      if (!v100) {
        unsigned int v101 = 0;
      }
      *(_DWORD *)(a4 + 24) = v101;
      *(_DWORD *)(a4 + 28) = v100;
    }
    else
    {
      v100 -= 32;
      int v109 = v101;
    }
    *(_DWORD *)(a2 + 28) = v109;
  }
  if (v100 + 8 * ((int)v84 - (int)v85) <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    v627 = "Cannot read blkData.spread.hasData";
    goto LABEL_935;
  }
  unsigned int v116 = v101 >> 31;
  int v117 = v100 - 1;
  *(_DWORD *)(a4 + 28) = v100 - 1;
  if (v100 - 1 < 0)
  {
    unint64_t v119 = *(void *)(a4 + 8);
    if (((v84 - v85) & ~((uint64_t)(v84 - (void)v85) >> 63) & 0xFFFFFFFC) != 0
      && v119 <= (unint64_t)v85)
    {
      unsigned int v101 = bswap32(*v85);
    }
    else
    {
      uint64_t v120 = 0;
      do
      {
        uint64_t v121 = (unsigned __int8 *)v85 + v120;
        unsigned int v122 = v101 << 8;
        *int v11 = v122;
        int v123 = 255;
        if ((unint64_t)v85 + v120 < v84 && (unint64_t)v121 >= v119) {
          int v123 = *v121;
        }
        unsigned int v101 = v123 | v122;
        *int v11 = v101;
        ++v120;
      }
      while (v120 != 4);
    }
    int v125 = v100 + 31;
    BOOL v124 = v100 == -31;
    *(_DWORD *)(a4 + 28) = v100 + 31;
    *(void *)a4 = ++v85;
    v116 |= v101 >> (v100 + 31);
    if (v100 == -31) {
      unsigned int v118 = 0;
    }
    else {
      unsigned int v118 = v101 << (1 - v100);
    }
    if (v124) {
      int v117 = 0;
    }
    else {
      int v117 = v125;
    }
  }
  else
  {
    unsigned int v118 = 2 * v101;
  }
  *int v11 = v118;
  *(unsigned char *)(a2 + 32) = v116 != 0;
  if (v116)
  {
    uint64_t v126 = v84 - (void)v85;
    if (v117 + 8 * ((int)v84 - (int)v85) <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      v627 = "Cannot read blkData.spread.width";
      goto LABEL_935;
    }
    *(_DWORD *)(a4 + 28) = v117 - 32;
    if (v117 - 32 < 0)
    {
      int v129 = v126 & ~(v126 >> 63);
      unint64_t v130 = *(void *)(a4 + 8);
      if ((v129 & 0xFFFFFFFC) != 0 && v130 <= (unint64_t)v85)
      {
        unsigned int v131 = bswap32(*v85);
      }
      else
      {
        uint64_t v132 = 0;
        unsigned int v131 = v118;
        do
        {
          unsigned int v133 = (unsigned __int8 *)v85 + v132;
          unsigned int v134 = v131 << 8;
          *int v11 = v134;
          int v135 = 255;
          if ((unint64_t)v85 + v132 < v84 && (unint64_t)v133 >= v130) {
            int v135 = *v133;
          }
          unsigned int v131 = v135 | v134;
          *int v11 = v131;
          ++v132;
        }
        while (v132 != 4);
      }
      *(void *)a4 = ++v85;
      int v128 = (v131 >> v117) | v118;
      unsigned int v118 = v131 << -(char)v117;
      if (!v117) {
        unsigned int v118 = 0;
      }
      *(_DWORD *)(a4 + 24) = v118;
      *(_DWORD *)(a4 + 28) = v117;
      uint64_t v126 = v84 - (void)v85;
      int v127 = 8 * (v84 - v85);
    }
    else
    {
      int v127 = 8 * v126;
      v117 -= 32;
      int v128 = v118;
    }
    *(_DWORD *)(a2 + 36) = v128;
    if (v127 + v117 <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      v627 = "Cannot read blkData.spread.height";
      goto LABEL_935;
    }
    *(_DWORD *)(a4 + 28) = v117 - 32;
    if (v117 - 32 < 0)
    {
      int v137 = v126 & ~(v126 >> 63);
      unint64_t v138 = *(void *)(a4 + 8);
      if ((v137 & 0xFFFFFFFC) != 0 && v138 <= (unint64_t)v85)
      {
        unsigned int v139 = bswap32(*v85);
      }
      else
      {
        uint64_t v140 = 0;
        unsigned int v139 = v118;
        do
        {
          uint64_t v141 = (unsigned __int8 *)v85 + v140;
          unsigned int v142 = v139 << 8;
          *int v11 = v142;
          int v143 = 255;
          if ((unint64_t)v85 + v140 < v84 && (unint64_t)v141 >= v138) {
            int v143 = *v141;
          }
          unsigned int v139 = v143 | v142;
          *int v11 = v139;
          ++v140;
        }
        while (v140 != 4);
      }
      *(void *)a4 = ++v85;
      int v136 = (v139 >> v117) | v118;
      unsigned int v118 = v139 << -(char)v117;
      if (!v117) {
        unsigned int v118 = 0;
      }
      *(_DWORD *)(a4 + 24) = v118;
      *(_DWORD *)(a4 + 28) = v117;
      uint64_t v126 = v84 - (void)v85;
      int v127 = 8 * (v84 - v85);
    }
    else
    {
      v117 -= 32;
      int v136 = v118;
    }
    *(_DWORD *)(a2 + 40) = v136;
    if (v127 + v117 <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      v627 = "Cannot read blkData.spread.depth";
      goto LABEL_935;
    }
    *(_DWORD *)(a4 + 28) = v117 - 32;
    if (v117 - 32 < 0)
    {
      int v145 = v126 & ~(v126 >> 63);
      unint64_t v146 = *(void *)(a4 + 8);
      if ((v145 & 0xFFFFFFFC) != 0 && v146 <= (unint64_t)v85)
      {
        unsigned int v147 = bswap32(*v85);
      }
      else
      {
        uint64_t v148 = 0;
        unsigned int v147 = v118;
        do
        {
          unsigned int v149 = (unsigned __int8 *)v85 + v148;
          unsigned int v150 = v147 << 8;
          *int v11 = v150;
          int v151 = 255;
          if ((unint64_t)v85 + v148 < v84 && (unint64_t)v149 >= v146) {
            int v151 = *v149;
          }
          unsigned int v147 = v151 | v150;
          *int v11 = v147;
          ++v148;
        }
        while (v148 != 4);
      }
      *(void *)a4 = ++v85;
      int v144 = (v147 >> v117) | v118;
      unsigned int v118 = v147 << -(char)v117;
      if (!v117) {
        unsigned int v118 = 0;
      }
      *(_DWORD *)(a4 + 24) = v118;
      *(_DWORD *)(a4 + 28) = v117;
    }
    else
    {
      v117 -= 32;
      int v144 = v118;
    }
    *(_DWORD *)(a2 + 44) = v144;
  }
  if (v117 + 8 * ((int)v84 - (int)v85) <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    v627 = "Cannot read blkData.gain.hasData";
    goto LABEL_935;
  }
  unsigned int v152 = v118 >> 31;
  int v153 = v117 - 1;
  *(_DWORD *)(a4 + 28) = v117 - 1;
  if (v117 - 1 < 0)
  {
    unint64_t v155 = *(void *)(a4 + 8);
    if (((v84 - v85) & ~((uint64_t)(v84 - (void)v85) >> 63) & 0xFFFFFFFC) != 0
      && v155 <= (unint64_t)v85)
    {
      unsigned int v118 = bswap32(*v85);
    }
    else
    {
      uint64_t v156 = 0;
      do
      {
        int v157 = (unsigned __int8 *)v85 + v156;
        unsigned int v158 = v118 << 8;
        *int v11 = v158;
        int v159 = 255;
        if ((unint64_t)v85 + v156 < v84 && (unint64_t)v157 >= v155) {
          int v159 = *v157;
        }
        unsigned int v118 = v159 | v158;
        *int v11 = v118;
        ++v156;
      }
      while (v156 != 4);
    }
    int v161 = v117 + 31;
    BOOL v160 = v117 == -31;
    *(_DWORD *)(a4 + 28) = v117 + 31;
    *(void *)a4 = ++v85;
    v152 |= v118 >> (v117 + 31);
    if (v117 == -31) {
      unsigned int v154 = 0;
    }
    else {
      unsigned int v154 = v118 << (1 - v117);
    }
    if (v160) {
      int v153 = 0;
    }
    else {
      int v153 = v161;
    }
  }
  else
  {
    unsigned int v154 = 2 * v118;
  }
  *int v11 = v154;
  *(unsigned char *)(a2 + 48) = v152 != 0;
  if (v152)
  {
    if (v153 + 8 * ((int)v84 - (int)v85) <= 0)
    {
      exception = __cxa_allocate_exception(8uLL);
      v627 = "Cannot read blkData.gain.isDB";
      goto LABEL_935;
    }
    unsigned int v162 = v154 >> 31;
    *(_DWORD *)(a4 + 28) = v153 - 1;
    if (v153 - 1 < 0)
    {
      unint64_t v163 = *(void *)(a4 + 8);
      if (((v84 - v85) & ~((uint64_t)(v84 - (void)v85) >> 63) & 0xFFFFFFFC) != 0
        && v163 <= (unint64_t)v85)
      {
        unsigned int v154 = bswap32(*v85);
      }
      else
      {
        uint64_t v164 = 0;
        do
        {
          unint64_t v165 = (unsigned __int8 *)v85 + v164;
          unsigned int v166 = v154 << 8;
          *int v11 = v166;
          int v167 = 255;
          if ((unint64_t)v85 + v164 < v84 && (unint64_t)v165 >= v163) {
            int v167 = *v165;
          }
          unsigned int v154 = v167 | v166;
          *int v11 = v154;
          ++v164;
        }
        while (v164 != 4);
      }
      unsigned int v168 = v154 << (1 - v153);
      v153 += 31;
      *(_DWORD *)(a4 + 28) = v153;
      *(void *)a4 = ++v85;
      v162 |= v154 >> v153;
      if (v153) {
        unsigned int v154 = v168;
      }
      else {
        unsigned int v154 = 0;
      }
      if (!v153) {
        int v153 = 0;
      }
    }
    else
    {
      v154 *= 2;
      --v153;
    }
    *int v11 = v154;
    *(unsigned char *)(a2 + 49) = v162 != 0;
    if (v153 + 8 * ((int)v84 - (int)v85) <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      v627 = "Cannot read blkData.gain.gain";
      goto LABEL_935;
    }
    *(_DWORD *)(a4 + 28) = v153 - 32;
    if (v153 - 32 < 0)
    {
      unint64_t v170 = *(void *)(a4 + 8);
      if (((v84 - v85) & ~((uint64_t)(v84 - (void)v85) >> 63) & 0xFFFFFFFC) != 0
        && v170 <= (unint64_t)v85)
      {
        unsigned int v171 = bswap32(*v85);
      }
      else
      {
        uint64_t v172 = 0;
        unsigned int v171 = v154;
        do
        {
          uint64_t v173 = (unsigned __int8 *)v85 + v172;
          unsigned int v174 = v171 << 8;
          *int v11 = v174;
          int v175 = 255;
          if ((unint64_t)v85 + v172 < v84 && (unint64_t)v173 >= v170) {
            int v175 = *v173;
          }
          unsigned int v171 = v175 | v174;
          *int v11 = v171;
          ++v172;
        }
        while (v172 != 4);
      }
      *(void *)a4 = ++v85;
      int v169 = (v171 >> v153) | v154;
      unsigned int v154 = v171 << -(char)v153;
      if (!v153) {
        unsigned int v154 = 0;
      }
      *(_DWORD *)(a4 + 24) = v154;
      *(_DWORD *)(a4 + 28) = v153;
    }
    else
    {
      v153 -= 32;
      int v169 = v154;
    }
    *(_DWORD *)(a2 + 52) = v169;
  }
  if (v153 + 8 * ((int)v84 - (int)v85) <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    v627 = "Cannot read blkData.diffuse.hasData";
    goto LABEL_935;
  }
  unsigned int v176 = v154 >> 31;
  int v177 = v153 - 1;
  *(_DWORD *)(a4 + 28) = v153 - 1;
  if (v153 - 1 < 0)
  {
    unint64_t v179 = *(void *)(a4 + 8);
    if (((v84 - v85) & ~((uint64_t)(v84 - (void)v85) >> 63) & 0xFFFFFFFC) != 0
      && v179 <= (unint64_t)v85)
    {
      unsigned int v154 = bswap32(*v85);
    }
    else
    {
      uint64_t v180 = 0;
      do
      {
        uint64_t v181 = (unsigned __int8 *)v85 + v180;
        unsigned int v182 = v154 << 8;
        *int v11 = v182;
        int v183 = 255;
        if ((unint64_t)v85 + v180 < v84 && (unint64_t)v181 >= v179) {
          int v183 = *v181;
        }
        unsigned int v154 = v183 | v182;
        *int v11 = v154;
        ++v180;
      }
      while (v180 != 4);
    }
    unsigned int v184 = v154 << (1 - v153);
    int v185 = v153 + 31;
    *(_DWORD *)(a4 + 28) = v185;
    *(void *)a4 = ++v85;
    v176 |= v154 >> v185;
    if (v185) {
      unsigned int v178 = v184;
    }
    else {
      unsigned int v178 = 0;
    }
    if (v185) {
      int v177 = v185;
    }
    else {
      int v177 = 0;
    }
  }
  else
  {
    unsigned int v178 = 2 * v154;
  }
  *int v11 = v178;
  *(unsigned char *)(a2 + 56) = v176 != 0;
  if (v176)
  {
    if (v177 + 8 * ((int)v84 - (int)v85) <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      v627 = "Cannot read blkData.diffuse.diffuse";
      goto LABEL_935;
    }
    *(_DWORD *)(a4 + 28) = v177 - 32;
    if (v177 - 32 < 0)
    {
      unint64_t v187 = *(void *)(a4 + 8);
      if (((v84 - v85) & ~((uint64_t)(v84 - (void)v85) >> 63) & 0xFFFFFFFC) != 0
        && v187 <= (unint64_t)v85)
      {
        unsigned int v188 = bswap32(*v85);
      }
      else
      {
        uint64_t v189 = 0;
        unsigned int v188 = v178;
        do
        {
          unsigned int v190 = (unsigned __int8 *)v85 + v189;
          unsigned int v191 = v188 << 8;
          *int v11 = v191;
          int v192 = 255;
          if ((unint64_t)v85 + v189 < v84 && (unint64_t)v190 >= v187) {
            int v192 = *v190;
          }
          unsigned int v188 = v192 | v191;
          *int v11 = v188;
          ++v189;
        }
        while (v189 != 4);
      }
      *(void *)a4 = ++v85;
      int v186 = (v188 >> v177) | v178;
      unsigned int v178 = v188 << -(char)v177;
      if (!v177) {
        unsigned int v178 = 0;
      }
      *(_DWORD *)(a4 + 24) = v178;
      *(_DWORD *)(a4 + 28) = v177;
    }
    else
    {
      v177 -= 32;
      int v186 = v178;
    }
    *(_DWORD *)(a2 + 60) = v186;
  }
  if (v177 + 8 * ((int)v84 - (int)v85) <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    v627 = "Cannot read blkData.channelLock.channelLock";
    goto LABEL_935;
  }
  unsigned int v193 = v178 >> 31;
  int v194 = v177 - 1;
  *(_DWORD *)(a4 + 28) = v177 - 1;
  if (v177 - 1 < 0)
  {
    unint64_t v196 = *(void *)(a4 + 8);
    if (((v84 - v85) & ~((uint64_t)(v84 - (void)v85) >> 63) & 0xFFFFFFFC) != 0
      && v196 <= (unint64_t)v85)
    {
      unsigned int v178 = bswap32(*v85);
    }
    else
    {
      uint64_t v197 = 0;
      do
      {
        unsigned int v198 = (unsigned __int8 *)v85 + v197;
        unsigned int v199 = v178 << 8;
        *int v11 = v199;
        int v200 = 255;
        if ((unint64_t)v85 + v197 < v84 && (unint64_t)v198 >= v196) {
          int v200 = *v198;
        }
        unsigned int v178 = v200 | v199;
        *int v11 = v178;
        ++v197;
      }
      while (v197 != 4);
    }
    unsigned int v201 = v178 << (1 - v177);
    int v202 = v177 + 31;
    *(_DWORD *)(a4 + 28) = v202;
    *(void *)a4 = ++v85;
    v193 |= v178 >> v202;
    if (v202) {
      unsigned int v195 = v201;
    }
    else {
      unsigned int v195 = 0;
    }
    if (v202) {
      int v194 = v202;
    }
    else {
      int v194 = 0;
    }
  }
  else
  {
    unsigned int v195 = 2 * v178;
  }
  *int v11 = v195;
  *(unsigned char *)(a2 + 64) = v193 != 0;
  if (v193)
  {
    if (v194 + 8 * ((int)v84 - (int)v85) <= 0)
    {
      exception = __cxa_allocate_exception(8uLL);
      v627 = "Cannot read blkData.channelLock.hasMaxDistance";
      goto LABEL_935;
    }
    unsigned int v203 = v195 >> 31;
    *(_DWORD *)(a4 + 28) = v194 - 1;
    if (v194 - 1 < 0)
    {
      unint64_t v204 = *(void *)(a4 + 8);
      if (((v84 - v85) & ~((uint64_t)(v84 - (void)v85) >> 63) & 0xFFFFFFFC) != 0
        && v204 <= (unint64_t)v85)
      {
        unsigned int v195 = bswap32(*v85);
      }
      else
      {
        uint64_t v205 = 0;
        do
        {
          int v206 = (unsigned __int8 *)v85 + v205;
          unsigned int v207 = v195 << 8;
          *int v11 = v207;
          int v208 = 255;
          if ((unint64_t)v85 + v205 < v84 && (unint64_t)v206 >= v204) {
            int v208 = *v206;
          }
          unsigned int v195 = v208 | v207;
          *int v11 = v195;
          ++v205;
        }
        while (v205 != 4);
      }
      unsigned int v209 = v195 << (1 - v194);
      v194 += 31;
      *(_DWORD *)(a4 + 28) = v194;
      *(void *)a4 = ++v85;
      v203 |= v195 >> v194;
      if (v194) {
        unsigned int v195 = v209;
      }
      else {
        unsigned int v195 = 0;
      }
      if (!v194) {
        int v194 = 0;
      }
    }
    else
    {
      v195 *= 2;
      --v194;
    }
    *int v11 = v195;
    *(unsigned char *)(a2 + 65) = v203 != 0;
    if (v203)
    {
      if (v194 + 8 * ((int)v84 - (int)v85) <= 31)
      {
        exception = __cxa_allocate_exception(8uLL);
        v627 = "Cannot read blkData.channelLock.maxDistance";
        goto LABEL_935;
      }
      *(_DWORD *)(a4 + 28) = v194 - 32;
      if (v194 - 32 < 0)
      {
        unint64_t v211 = *(void *)(a4 + 8);
        if (((v84 - v85) & ~((uint64_t)(v84 - (void)v85) >> 63) & 0xFFFFFFFC) != 0
          && v211 <= (unint64_t)v85)
        {
          unsigned int v212 = bswap32(*v85);
        }
        else
        {
          uint64_t v213 = 0;
          unsigned int v212 = v195;
          do
          {
            int v214 = (unsigned __int8 *)v85 + v213;
            unsigned int v215 = v212 << 8;
            *int v11 = v215;
            int v216 = 255;
            if ((unint64_t)v85 + v213 < v84 && (unint64_t)v214 >= v211) {
              int v216 = *v214;
            }
            unsigned int v212 = v216 | v215;
            *int v11 = v212;
            ++v213;
          }
          while (v213 != 4);
        }
        *(void *)a4 = ++v85;
        int v210 = (v212 >> v194) | v195;
        unsigned int v195 = v212 << -(char)v194;
        if (!v194) {
          unsigned int v195 = 0;
        }
        *(_DWORD *)(a4 + 24) = v195;
        *(_DWORD *)(a4 + 28) = v194;
      }
      else
      {
        v194 -= 32;
        int v210 = v195;
      }
      *(_DWORD *)(a2 + 68) = v210;
    }
  }
  if (v194 + 8 * ((int)v84 - (int)v85) <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    v627 = "Cannot read blkData.objectDivergence.hasData";
    goto LABEL_935;
  }
  unsigned int v217 = v195 >> 31;
  int v218 = v194 - 1;
  *(_DWORD *)(a4 + 28) = v194 - 1;
  if (v194 - 1 < 0)
  {
    unint64_t v220 = *(void *)(a4 + 8);
    if (((v84 - v85) & ~((uint64_t)(v84 - (void)v85) >> 63) & 0xFFFFFFFC) != 0
      && v220 <= (unint64_t)v85)
    {
      unsigned int v195 = bswap32(*v85);
    }
    else
    {
      uint64_t v221 = 0;
      do
      {
        int v222 = (unsigned __int8 *)v85 + v221;
        unsigned int v223 = v195 << 8;
        *int v11 = v223;
        int v224 = 255;
        if ((unint64_t)v85 + v221 < v84 && (unint64_t)v222 >= v220) {
          int v224 = *v222;
        }
        unsigned int v195 = v224 | v223;
        *int v11 = v195;
        ++v221;
      }
      while (v221 != 4);
    }
    int v226 = v194 + 31;
    BOOL v225 = v194 == -31;
    *(_DWORD *)(a4 + 28) = v194 + 31;
    *(void *)a4 = ++v85;
    v217 |= v195 >> (v194 + 31);
    if (v194 == -31) {
      unsigned int v219 = 0;
    }
    else {
      unsigned int v219 = v195 << (1 - v194);
    }
    if (v225) {
      int v218 = 0;
    }
    else {
      int v218 = v226;
    }
  }
  else
  {
    unsigned int v219 = 2 * v195;
  }
  *int v11 = v219;
  *(unsigned char *)(a2 + 72) = v217 != 0;
  if (v217)
  {
    uint64_t v227 = v84 - (void)v85;
    if (v218 + 8 * ((int)v84 - (int)v85) <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      v627 = "Cannot read blkData.objectDivergence.objectDivergence";
      goto LABEL_935;
    }
    *(_DWORD *)(a4 + 28) = v218 - 32;
    if (v218 - 32 < 0)
    {
      int v230 = v227 & ~(v227 >> 63);
      unint64_t v231 = *(void *)(a4 + 8);
      if ((v230 & 0xFFFFFFFC) != 0 && v231 <= (unint64_t)v85)
      {
        unsigned int v232 = bswap32(*v85);
      }
      else
      {
        uint64_t v233 = 0;
        unsigned int v232 = v219;
        do
        {
          v234 = (unsigned __int8 *)v85 + v233;
          unsigned int v235 = v232 << 8;
          *int v11 = v235;
          int v236 = 255;
          if ((unint64_t)v85 + v233 < v84 && (unint64_t)v234 >= v231) {
            int v236 = *v234;
          }
          unsigned int v232 = v236 | v235;
          *int v11 = v232;
          ++v233;
        }
        while (v233 != 4);
      }
      *(void *)a4 = ++v85;
      int v229 = (v232 >> v218) | v219;
      unsigned int v219 = v232 << -(char)v218;
      if (!v218) {
        unsigned int v219 = 0;
      }
      *(_DWORD *)(a4 + 24) = v219;
      *(_DWORD *)(a4 + 28) = v218;
      uint64_t v227 = v84 - (void)v85;
      int v228 = 8 * (v84 - v85);
    }
    else
    {
      int v228 = 8 * v227;
      v218 -= 32;
      int v229 = v219;
    }
    *(_DWORD *)(a2 + 76) = v229;
    if (v228 + v218 <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      v627 = "Cannot read blkData.objectDivergence.positionOrAzimuthRange";
      goto LABEL_935;
    }
    *(_DWORD *)(a4 + 28) = v218 - 32;
    if (v218 - 32 < 0)
    {
      int v238 = v227 & ~(v227 >> 63);
      unint64_t v239 = *(void *)(a4 + 8);
      if ((v238 & 0xFFFFFFFC) != 0 && v239 <= (unint64_t)v85)
      {
        unsigned int v240 = bswap32(*v85);
      }
      else
      {
        uint64_t v241 = 0;
        unsigned int v240 = v219;
        do
        {
          uint64_t v242 = (unsigned __int8 *)v85 + v241;
          unsigned int v243 = v240 << 8;
          *int v11 = v243;
          int v244 = 255;
          if ((unint64_t)v85 + v241 < v84 && (unint64_t)v242 >= v239) {
            int v244 = *v242;
          }
          unsigned int v240 = v244 | v243;
          *int v11 = v240;
          ++v241;
        }
        while (v241 != 4);
      }
      *(void *)a4 = ++v85;
      int v237 = (v240 >> v218) | v219;
      unsigned int v219 = v240 << -(char)v218;
      if (!v218) {
        unsigned int v219 = 0;
      }
      *(_DWORD *)(a4 + 24) = v219;
      *(_DWORD *)(a4 + 28) = v218;
    }
    else
    {
      v218 -= 32;
      int v237 = v219;
    }
    *(_DWORD *)(a2 + 88) = v237;
  }
  if (v218 + 8 * ((int)v84 - (int)v85) <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    v627 = "Cannot read blkData.screenRef";
    goto LABEL_935;
  }
  unsigned int v245 = v219 >> 31;
  int v246 = v218 - 1;
  *(_DWORD *)(a4 + 28) = v218 - 1;
  if (v218 - 1 < 0)
  {
    unint64_t v249 = *(void *)(a4 + 8);
    unint64_t v248 = *(void *)(a4 + 16);
    if (((v248 - v85) & ~((uint64_t)(v248 - (void)v85) >> 63) & 0xFFFFFFFC) != 0
      && v249 <= (unint64_t)v85)
    {
      unsigned int v219 = bswap32(*v85);
    }
    else
    {
      uint64_t v250 = 0;
      do
      {
        int v251 = (unsigned __int8 *)v85 + v250;
        unsigned int v252 = v219 << 8;
        *int v11 = v252;
        int v253 = 255;
        if ((unint64_t)v85 + v250 < v248 && (unint64_t)v251 >= v249) {
          int v253 = *v251;
        }
        unsigned int v219 = v253 | v252;
        *int v11 = v219;
        ++v250;
      }
      while (v250 != 4);
    }
    unsigned int v254 = v219 << (1 - v218);
    int v255 = v218 + 31;
    *(_DWORD *)(a4 + 28) = v255;
    *(void *)a4 = ++v85;
    v245 |= v219 >> v255;
    if (v255) {
      unsigned int v247 = v254;
    }
    else {
      unsigned int v247 = 0;
    }
    if (v255) {
      int v246 = v255;
    }
    else {
      int v246 = 0;
    }
  }
  else
  {
    unsigned int v247 = 2 * v219;
  }
  *int v11 = v247;
  *(unsigned char *)(a2 + 92) = v245 != 0;
  BOOL v256 = a3 == 1 && HIBYTE(a3) == 1;
  int v257 = v256;
  if (v256)
  {
    if (v246 + 8 * ((int)v84 - (int)v85) <= 0)
    {
      exception = __cxa_allocate_exception(8uLL);
      v627 = "Cannot read blkData.importance.hasData";
      goto LABEL_935;
    }
    unsigned int v258 = v247 >> 31;
    *(_DWORD *)(a4 + 28) = v246 - 1;
    if (v246 - 1 < 0)
    {
      unint64_t v259 = *(void *)(a4 + 8);
      if (((v84 - v85) & ~((uint64_t)(v84 - (void)v85) >> 63) & 0xFFFFFFFC) != 0
        && v259 <= (unint64_t)v85)
      {
        unsigned int v247 = bswap32(*v85);
      }
      else
      {
        uint64_t v260 = 0;
        do
        {
          v261 = (unsigned __int8 *)v85 + v260;
          unsigned int v262 = v247 << 8;
          *int v11 = v262;
          int v263 = 255;
          if ((unint64_t)v85 + v260 < v84 && (unint64_t)v261 >= v259) {
            int v263 = *v261;
          }
          unsigned int v247 = v263 | v262;
          *int v11 = v247;
          ++v260;
        }
        while (v260 != 4);
      }
      unsigned int v264 = v247 << (1 - v246);
      v246 += 31;
      *(_DWORD *)(a4 + 28) = v246;
      *(void *)a4 = ++v85;
      v258 |= v247 >> v246;
      if (v246) {
        unsigned int v247 = v264;
      }
      else {
        unsigned int v247 = 0;
      }
      if (!v246) {
        int v246 = 0;
      }
    }
    else
    {
      v247 *= 2;
      --v246;
    }
    *int v11 = v247;
    *(unsigned char *)(a2 + 93) = v258 != 0;
    if (v258)
    {
      if (v246 + 8 * ((int)v84 - (int)v85) <= 3)
      {
        exception = __cxa_allocate_exception(8uLL);
        v627 = "Cannot read blkData.importance.importance";
        goto LABEL_935;
      }
      unsigned int v265 = v247 >> 28;
      *(_DWORD *)(a4 + 28) = v246 - 4;
      if (v246 - 4 < 0)
      {
        unint64_t v266 = *(void *)(a4 + 8);
        if (((v84 - v85) & ~((uint64_t)(v84 - (void)v85) >> 63) & 0xFFFFFFFC) != 0
          && v266 <= (unint64_t)v85)
        {
          unsigned int v247 = bswap32(*v85);
        }
        else
        {
          uint64_t v267 = 0;
          do
          {
            uint64_t v268 = (unsigned __int8 *)v85 + v267;
            unsigned int v269 = v247 << 8;
            *int v11 = v269;
            int v270 = 255;
            if ((unint64_t)v85 + v267 < v84 && (unint64_t)v268 >= v266) {
              int v270 = *v268;
            }
            unsigned int v247 = v270 | v269;
            *int v11 = v247;
            ++v267;
          }
          while (v267 != 4);
        }
        unsigned int v271 = v247 << (4 - v246);
        v246 += 28;
        *(_DWORD *)(a4 + 28) = v246;
        *(void *)a4 = ++v85;
        v265 |= v247 >> v246;
        if (v246) {
          unsigned int v247 = v271;
        }
        else {
          unsigned int v247 = 0;
        }
        if (!v246) {
          int v246 = 0;
        }
      }
      else
      {
        v247 *= 16;
        v246 -= 4;
      }
      *int v11 = v247;
      *(unsigned char *)(a2 + 94) = v265;
    }
  }
  if (v246 + 8 * ((int)v84 - (int)v85) <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    v627 = "Cannot read blkData.headLocked";
    goto LABEL_935;
  }
  unsigned int v272 = v247 >> 31;
  int v273 = v246 - 1;
  *(_DWORD *)(a4 + 28) = v246 - 1;
  if (v246 - 1 < 0)
  {
    unint64_t v276 = *(void *)(a4 + 8);
    unint64_t v275 = *(void *)(a4 + 16);
    if (((v275 - v85) & ~((uint64_t)(v275 - (void)v85) >> 63) & 0xFFFFFFFC) != 0
      && v276 <= (unint64_t)v85)
    {
      unsigned int v247 = bswap32(*v85);
      *int v11 = v247;
    }
    else
    {
      uint64_t v277 = 0;
      do
      {
        v278 = (unsigned __int8 *)v85 + v277;
        unsigned int v279 = v247 << 8;
        *int v11 = v279;
        int v280 = 255;
        if ((unint64_t)v85 + v277 < v275 && (unint64_t)v278 >= v276) {
          int v280 = *v278;
        }
        unsigned int v247 = v280 | v279;
        *int v11 = v247;
        ++v277;
      }
      while (v277 != 4);
    }
    *(void *)a4 = ++v85;
    int v273 = v246 + 31;
    *(_DWORD *)(a4 + 28) = v246 + 31;
    v272 |= v247 >> (v246 + 31);
    if (v246 == -31)
    {
      unsigned int v274 = 0;
      *int v11 = 0;
    }
    else
    {
      unsigned int v274 = v247 << (1 - v246);
      *int v11 = v274;
    }
  }
  else
  {
    unsigned int v274 = 2 * v247;
    *(_DWORD *)(a4 + 24) = v274;
    unint64_t v275 = *(void *)(a4 + 16);
  }
  *(unsigned char *)(a2 + 95) = v272 != 0;
  if (v273 + 8 * ((int)v275 - (int)v85) <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    v627 = "Cannot read blkData.headphoneVirtualize.hasData";
    goto LABEL_935;
  }
  unsigned int v281 = v274 >> 31;
  int v282 = v273 - 1;
  *(_DWORD *)(a4 + 28) = v273 - 1;
  if (v273 - 1 < 0)
  {
    unint64_t v284 = *(void *)(a4 + 8);
    if (((v275 - v85) & ~((uint64_t)(v275 - (void)v85) >> 63) & 0xFFFFFFFC) != 0
      && v284 <= (unint64_t)v85)
    {
      unsigned int v274 = bswap32(*v85);
    }
    else
    {
      uint64_t v285 = 0;
      do
      {
        v286 = (unsigned __int8 *)v85 + v285;
        unsigned int v287 = v274 << 8;
        *int v11 = v287;
        int v288 = 255;
        if ((unint64_t)v85 + v285 < v275 && (unint64_t)v286 >= v284) {
          int v288 = *v286;
        }
        unsigned int v274 = v288 | v287;
        *int v11 = v274;
        ++v285;
      }
      while (v285 != 4);
    }
    unsigned int v289 = v274 << (1 - v273);
    int v290 = v273 + 31;
    *(_DWORD *)(a4 + 28) = v290;
    *(void *)a4 = ++v85;
    v281 |= v274 >> v290;
    if (v290) {
      unsigned int v283 = v289;
    }
    else {
      unsigned int v283 = 0;
    }
    if (v290) {
      int v282 = v290;
    }
    else {
      int v282 = 0;
    }
  }
  else
  {
    unsigned int v283 = 2 * v274;
  }
  *int v11 = v283;
  *(unsigned char *)(a2 + 96) = v281 != 0;
  if (v281)
  {
    if (v282 + 8 * ((int)v275 - (int)v85) <= 0)
    {
      exception = __cxa_allocate_exception(8uLL);
      v627 = "Cannot read blkData.headphoneVirtualize.bypass";
      goto LABEL_935;
    }
    unsigned int v291 = v283 >> 31;
    *(_DWORD *)(a4 + 28) = v282 - 1;
    if (v282 - 1 < 0)
    {
      unint64_t v292 = *(void *)(a4 + 8);
      if (((v275 - v85) & ~((uint64_t)(v275 - (void)v85) >> 63) & 0xFFFFFFFC) != 0
        && v292 <= (unint64_t)v85)
      {
        unsigned int v283 = bswap32(*v85);
      }
      else
      {
        uint64_t v293 = 0;
        do
        {
          v294 = (unsigned __int8 *)v85 + v293;
          unsigned int v295 = v283 << 8;
          *int v11 = v295;
          int v296 = 255;
          if ((unint64_t)v85 + v293 < v275 && (unint64_t)v294 >= v292) {
            int v296 = *v294;
          }
          unsigned int v283 = v296 | v295;
          *int v11 = v283;
          ++v293;
        }
        while (v293 != 4);
      }
      unsigned int v297 = v283 << (1 - v282);
      v282 += 31;
      *(_DWORD *)(a4 + 28) = v282;
      *(void *)a4 = ++v85;
      v291 |= v283 >> v282;
      if (v282) {
        unsigned int v283 = v297;
      }
      else {
        unsigned int v283 = 0;
      }
      if (!v282) {
        int v282 = 0;
      }
    }
    else
    {
      v283 *= 2;
      --v282;
    }
    *int v11 = v283;
    *(unsigned char *)(a2 + 97) = v291 != 0;
    if (v282 + 8 * ((int)v275 - (int)v85) <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      v627 = "Cannot read blkData.headphoneVirtualize.DRR";
      goto LABEL_935;
    }
    *(_DWORD *)(a4 + 28) = v282 - 32;
    if (v282 - 32 < 0)
    {
      unint64_t v299 = *(void *)(a4 + 8);
      if (((v275 - v85) & ~((uint64_t)(v275 - (void)v85) >> 63) & 0xFFFFFFFC) != 0
        && v299 <= (unint64_t)v85)
      {
        unsigned int v300 = bswap32(*v85);
      }
      else
      {
        uint64_t v301 = 0;
        unsigned int v300 = v283;
        do
        {
          v302 = (unsigned __int8 *)v85 + v301;
          unsigned int v303 = v300 << 8;
          *int v11 = v303;
          int v304 = 255;
          if ((unint64_t)v85 + v301 < v275 && (unint64_t)v302 >= v299) {
            int v304 = *v302;
          }
          unsigned int v300 = v304 | v303;
          *int v11 = v300;
          ++v301;
        }
        while (v301 != 4);
      }
      *(void *)a4 = ++v85;
      int v298 = (v300 >> v282) | v283;
      unsigned int v283 = v300 << -(char)v282;
      if (!v282) {
        unsigned int v283 = 0;
      }
      *(_DWORD *)(a4 + 24) = v283;
      *(_DWORD *)(a4 + 28) = v282;
    }
    else
    {
      v282 -= 32;
      int v298 = v283;
    }
    *(_DWORD *)(a2 + 100) = v298;
  }
  if (v257)
  {
    if (v282 + 8 * ((int)v275 - (int)v85) > 3)
    {
      unsigned int v305 = v283 >> 28;
      *(_DWORD *)(a4 + 28) = v282 - 4;
      if (v282 - 4 < 0)
      {
        unint64_t v310 = *(void *)(a4 + 8);
        if (((v275 - v85) & ~((uint64_t)(v275 - (void)v85) >> 63) & 0xFFFFFFFC) != 0
          && v310 <= (unint64_t)v85)
        {
          unsigned int v283 = bswap32(*v85);
        }
        else
        {
          uint64_t v312 = 0;
          do
          {
            v313 = (unsigned __int8 *)v85 + v312;
            unsigned int v314 = v283 << 8;
            *int v11 = v314;
            int v315 = 255;
            if ((unint64_t)v85 + v312 < v275 && (unint64_t)v313 >= v310) {
              int v315 = *v313;
            }
            unsigned int v283 = v315 | v314;
            *int v11 = v283;
            ++v312;
          }
          while (v312 != 4);
        }
        int v306 = v283 << (4 - v282);
        *(_DWORD *)(a4 + 28) = v282 + 28;
        *(void *)a4 = v85 + 1;
        v305 |= v283 >> (v282 + 28);
        if (v282 == -28) {
          int v306 = 0;
        }
      }
      else
      {
        int v306 = 16 * v283;
      }
      *int v11 = v306;
      *(unsigned char *)(a2 + 106) = v305;
      uint64_t v316 = v305;
      if ((_BYTE)v305)
      {
        uint64_t v317 = 0;
        int v318 = *(unsigned __int8 *)(a2 + 4);
        while (1)
        {
          unint64_t v319 = *(void *)(a4 + 16);
          v320 = *(unsigned int **)a4;
          uint64_t v321 = v319 - *(void *)a4;
          int v322 = *(_DWORD *)(a4 + 28);
          int v323 = v322 + 8 * v321;
          if (v318)
          {
            if (v323 <= 31) {
              goto LABEL_888;
            }
            unsigned int v324 = *(_DWORD *)(a4 + 24);
            *(_DWORD *)(a4 + 28) = v322 - 32;
            if (v322 - 32 < 0)
            {
              uint64_t v325 = v321 & ~(v321 >> 63) & 0xFFFFFFFC;
              unint64_t v326 = *(void *)(a4 + 8);
              if (v325) {
                BOOL v327 = v326 > (unint64_t)v320;
              }
              else {
                BOOL v327 = 1;
              }
              if (v327)
              {
                uint64_t v328 = 0;
                unsigned int v340 = v324;
                do
                {
                  v329 = (unsigned __int8 *)v320 + v328;
                  unsigned int v330 = v340 << 8;
                  *int v11 = v330;
                  int v331 = 255;
                  if ((unint64_t)v320 + v328 < v319 && (unint64_t)v329 >= v326) {
                    int v331 = *v329;
                  }
                  unsigned int v340 = v331 | v330;
                  *int v11 = v340;
                  ++v328;
                }
                while (v328 != 4);
              }
              else
              {
                unsigned int v340 = bswap32(*v320);
              }
              *(void *)a4 = v320 + 1;
              v324 |= v340 >> v322;
              unsigned int v341 = v340 << -(char)v322;
              if (!v322) {
                unsigned int v341 = 0;
              }
              *(_DWORD *)(a4 + 24) = v341;
              *(_DWORD *)(a4 + 28) = v322;
            }
            uint64_t v342 = a2 + 24 * v317;
            *(_DWORD *)(v342 + 140) = v324;
            v343 = (_DWORD *)(v342 + 140);
            unint64_t v344 = *(void *)(a4 + 16);
            v345 = *(unsigned int **)a4;
            uint64_t v346 = v344 - *(void *)a4;
            int v347 = *(_DWORD *)(a4 + 28);
            if (v347 + 8 * (int)v346 <= 31) {
              goto LABEL_889;
            }
            unsigned int v348 = *(_DWORD *)(a4 + 24);
            *(_DWORD *)(a4 + 28) = v347 - 32;
            if (v347 - 32 < 0)
            {
              uint64_t v349 = v346 & ~(v346 >> 63) & 0xFFFFFFFC;
              unint64_t v350 = *(void *)(a4 + 8);
              if (v349) {
                BOOL v351 = v350 > (unint64_t)v345;
              }
              else {
                BOOL v351 = 1;
              }
              if (v351)
              {
                uint64_t v352 = 0;
                unsigned int v356 = v348;
                do
                {
                  v353 = (unsigned __int8 *)v345 + v352;
                  unsigned int v354 = v356 << 8;
                  *int v11 = v354;
                  int v355 = 255;
                  if ((unint64_t)v345 + v352 < v344 && (unint64_t)v353 >= v350) {
                    int v355 = *v353;
                  }
                  unsigned int v356 = v355 | v354;
                  *int v11 = v356;
                  ++v352;
                }
                while (v352 != 4);
              }
              else
              {
                unsigned int v356 = bswap32(*v345);
              }
              *(void *)a4 = v345 + 1;
              v348 |= v356 >> v347;
              unsigned int v357 = v356 << -(char)v347;
              if (!v347) {
                unsigned int v357 = 0;
              }
              *(_DWORD *)(a4 + 24) = v357;
              *(_DWORD *)(a4 + 28) = v347;
            }
            v343[1] = v348;
            unint64_t v358 = *(void *)(a4 + 16);
            v359 = *(unsigned int **)a4;
            uint64_t v360 = v358 - *(void *)a4;
            int v361 = *(_DWORD *)(a4 + 28);
            if (v361 + 8 * (int)v360 <= 31) {
              goto LABEL_890;
            }
            unsigned int v362 = *(_DWORD *)(a4 + 24);
            *(_DWORD *)(a4 + 28) = v361 - 32;
            if (v361 - 32 < 0)
            {
              int v363 = v360 & ~(v360 >> 63);
              unint64_t v364 = *(void *)(a4 + 8);
              if ((v363 & 0xFFFFFFFC) != 0 && v364 <= (unint64_t)v359)
              {
                unsigned int v365 = bswap32(*v359);
              }
              else
              {
                uint64_t v366 = 0;
                unsigned int v365 = v362;
                do
                {
                  v367 = (unsigned __int8 *)v359 + v366;
                  unsigned int v368 = v365 << 8;
                  *int v11 = v368;
                  int v369 = 255;
                  if ((unint64_t)v359 + v366 < v358 && (unint64_t)v367 >= v364) {
                    int v369 = *v367;
                  }
                  unsigned int v365 = v369 | v368;
                  *int v11 = v365;
                  ++v366;
                }
                while (v366 != 4);
              }
              *(void *)a4 = v359 + 1;
              v362 |= v365 >> v361;
              unsigned int v370 = v365 << -(char)v361;
              if (!v361) {
                unsigned int v370 = 0;
              }
              *(_DWORD *)(a4 + 24) = v370;
              *(_DWORD *)(a4 + 28) = v361;
            }
            v343[2] = v362;
            unint64_t v371 = *(void *)(a4 + 16);
            v372 = *(unsigned int **)a4;
            uint64_t v373 = v371 - *(void *)a4;
            int v374 = *(_DWORD *)(a4 + 28);
            if (v374 + 8 * (int)v373 <= 31) {
              goto LABEL_891;
            }
            unsigned int v375 = *(_DWORD *)(a4 + 24);
            *(_DWORD *)(a4 + 28) = v374 - 32;
            if (v374 - 32 < 0)
            {
              int v376 = v373 & ~(v373 >> 63);
              unint64_t v377 = *(void *)(a4 + 8);
              if ((v376 & 0xFFFFFFFC) != 0 && v377 <= (unint64_t)v372)
              {
                unsigned int v378 = bswap32(*v372);
              }
              else
              {
                uint64_t v379 = 0;
                unsigned int v378 = v375;
                do
                {
                  v380 = (unsigned __int8 *)v372 + v379;
                  unsigned int v381 = v378 << 8;
                  *int v11 = v381;
                  int v382 = 255;
                  if ((unint64_t)v372 + v379 < v371 && (unint64_t)v380 >= v377) {
                    int v382 = *v380;
                  }
                  unsigned int v378 = v382 | v381;
                  *int v11 = v378;
                  ++v379;
                }
                while (v379 != 4);
              }
              *(void *)a4 = v372 + 1;
              v375 |= v378 >> v374;
              unsigned int v383 = v378 << -(char)v374;
              if (!v374) {
                unsigned int v383 = 0;
              }
              *(_DWORD *)(a4 + 24) = v383;
              *(_DWORD *)(a4 + 28) = v374;
            }
            v343[3] = v375;
            unint64_t v384 = *(void *)(a4 + 16);
            v385 = *(unsigned int **)a4;
            uint64_t v386 = v384 - *(void *)a4;
            int v387 = *(_DWORD *)(a4 + 28);
            if (v387 + 8 * (int)v386 <= 31) {
              goto LABEL_892;
            }
            unsigned int v388 = *(_DWORD *)(a4 + 24);
            *(_DWORD *)(a4 + 28) = v387 - 32;
            if (v387 - 32 < 0)
            {
              int v389 = v386 & ~(v386 >> 63);
              unint64_t v390 = *(void *)(a4 + 8);
              if ((v389 & 0xFFFFFFFC) != 0 && v390 <= (unint64_t)v385)
              {
                unsigned int v391 = bswap32(*v385);
              }
              else
              {
                uint64_t v392 = 0;
                unsigned int v391 = v388;
                do
                {
                  v393 = (unsigned __int8 *)v385 + v392;
                  unsigned int v394 = v391 << 8;
                  *int v11 = v394;
                  int v395 = 255;
                  if ((unint64_t)v385 + v392 < v384 && (unint64_t)v393 >= v390) {
                    int v395 = *v393;
                  }
                  unsigned int v391 = v395 | v394;
                  *int v11 = v391;
                  ++v392;
                }
                while (v392 != 4);
              }
              *(void *)a4 = v385 + 1;
              v388 |= v391 >> v387;
              unsigned int v396 = v391 << -(char)v387;
              if (!v387) {
                unsigned int v396 = 0;
              }
              *(_DWORD *)(a4 + 24) = v396;
              *(_DWORD *)(a4 + 28) = v387;
            }
            v343[4] = v388;
            unint64_t v397 = *(void *)(a4 + 16);
            v398 = *(unsigned int **)a4;
            uint64_t v399 = v397 - *(void *)a4;
            int v400 = *(_DWORD *)(a4 + 28);
            if (v400 + 8 * (int)v399 <= 31) {
              goto LABEL_893;
            }
            unsigned int v401 = *(_DWORD *)(a4 + 24);
            *(_DWORD *)(a4 + 28) = v400 - 32;
            if (v400 - 32 < 0)
            {
              int v402 = v399 & ~(v399 >> 63);
              unint64_t v403 = *(void *)(a4 + 8);
              if ((v402 & 0xFFFFFFFC) != 0 && v403 <= (unint64_t)v398)
              {
                unsigned int v404 = bswap32(*v398);
              }
              else
              {
                uint64_t v405 = 0;
                unsigned int v404 = v401;
                do
                {
                  v406 = (unsigned __int8 *)v398 + v405;
                  unsigned int v407 = v404 << 8;
                  *int v11 = v407;
                  int v408 = 255;
                  if ((unint64_t)v398 + v405 < v397 && (unint64_t)v406 >= v403) {
                    int v408 = *v406;
                  }
                  unsigned int v404 = v408 | v407;
                  *int v11 = v404;
                  ++v405;
                }
                while (v405 != 4);
              }
              *(void *)a4 = v398 + 1;
              v401 |= v404 >> v400;
              unsigned int v409 = v404 << -(char)v400;
              if (!v400) {
                unsigned int v409 = 0;
              }
              *(_DWORD *)(a4 + 24) = v409;
              *(_DWORD *)(a4 + 28) = v400;
            }
            v343[5] = v401;
          }
          else
          {
            if (v323 <= 31) {
              goto LABEL_894;
            }
            unsigned int v332 = *(_DWORD *)(a4 + 24);
            *(_DWORD *)(a4 + 28) = v322 - 32;
            if (v322 - 32 < 0)
            {
              uint64_t v333 = v321 & ~(v321 >> 63) & 0xFFFFFFFC;
              unint64_t v334 = *(void *)(a4 + 8);
              if (v333) {
                BOOL v335 = v334 > (unint64_t)v320;
              }
              else {
                BOOL v335 = 1;
              }
              if (v335)
              {
                uint64_t v336 = 0;
                unsigned int v410 = v332;
                do
                {
                  v337 = (unsigned __int8 *)v320 + v336;
                  unsigned int v338 = v410 << 8;
                  *int v11 = v338;
                  int v339 = 255;
                  if ((unint64_t)v320 + v336 < v319 && (unint64_t)v337 >= v334) {
                    int v339 = *v337;
                  }
                  unsigned int v410 = v339 | v338;
                  *int v11 = v410;
                  ++v336;
                }
                while (v336 != 4);
              }
              else
              {
                unsigned int v410 = bswap32(*v320);
              }
              *(void *)a4 = v320 + 1;
              v332 |= v410 >> v322;
              unsigned int v411 = v410 << -(char)v322;
              if (!v322) {
                unsigned int v411 = 0;
              }
              *(_DWORD *)(a4 + 24) = v411;
              *(_DWORD *)(a4 + 28) = v322;
            }
            uint64_t v412 = a2 + 24 * v317;
            *(_DWORD *)(v412 + 140) = v332;
            v413 = (_DWORD *)(v412 + 140);
            unint64_t v414 = *(void *)(a4 + 16);
            v415 = *(unsigned int **)a4;
            uint64_t v416 = v414 - *(void *)a4;
            int v417 = *(_DWORD *)(a4 + 28);
            if (v417 + 8 * (int)v416 <= 31) {
              goto LABEL_895;
            }
            unsigned int v418 = *(_DWORD *)(a4 + 24);
            *(_DWORD *)(a4 + 28) = v417 - 32;
            if (v417 - 32 < 0)
            {
              uint64_t v419 = v416 & ~(v416 >> 63) & 0xFFFFFFFC;
              unint64_t v420 = *(void *)(a4 + 8);
              if (v419) {
                BOOL v421 = v420 > (unint64_t)v415;
              }
              else {
                BOOL v421 = 1;
              }
              if (v421)
              {
                uint64_t v422 = 0;
                unsigned int v426 = v418;
                do
                {
                  v423 = (unsigned __int8 *)v415 + v422;
                  unsigned int v424 = v426 << 8;
                  *int v11 = v424;
                  int v425 = 255;
                  if ((unint64_t)v415 + v422 < v414 && (unint64_t)v423 >= v420) {
                    int v425 = *v423;
                  }
                  unsigned int v426 = v425 | v424;
                  *int v11 = v426;
                  ++v422;
                }
                while (v422 != 4);
              }
              else
              {
                unsigned int v426 = bswap32(*v415);
              }
              *(void *)a4 = v415 + 1;
              v418 |= v426 >> v417;
              unsigned int v427 = v426 << -(char)v417;
              if (!v417) {
                unsigned int v427 = 0;
              }
              *(_DWORD *)(a4 + 24) = v427;
              *(_DWORD *)(a4 + 28) = v417;
            }
            v413[1] = v418;
            unint64_t v428 = *(void *)(a4 + 16);
            v429 = *(unsigned int **)a4;
            uint64_t v430 = v428 - *(void *)a4;
            int v431 = *(_DWORD *)(a4 + 28);
            if (v431 + 8 * (int)v430 <= 31) {
              goto LABEL_896;
            }
            unsigned int v432 = *(_DWORD *)(a4 + 24);
            *(_DWORD *)(a4 + 28) = v431 - 32;
            if (v431 - 32 < 0)
            {
              int v433 = v430 & ~(v430 >> 63);
              unint64_t v434 = *(void *)(a4 + 8);
              if ((v433 & 0xFFFFFFFC) != 0 && v434 <= (unint64_t)v429)
              {
                unsigned int v435 = bswap32(*v429);
              }
              else
              {
                uint64_t v436 = 0;
                unsigned int v435 = v432;
                do
                {
                  v437 = (unsigned __int8 *)v429 + v436;
                  unsigned int v438 = v435 << 8;
                  *int v11 = v438;
                  int v439 = 255;
                  if ((unint64_t)v429 + v436 < v428 && (unint64_t)v437 >= v434) {
                    int v439 = *v437;
                  }
                  unsigned int v435 = v439 | v438;
                  *int v11 = v435;
                  ++v436;
                }
                while (v436 != 4);
              }
              *(void *)a4 = v429 + 1;
              v432 |= v435 >> v431;
              unsigned int v440 = v435 << -(char)v431;
              if (!v431) {
                unsigned int v440 = 0;
              }
              *(_DWORD *)(a4 + 24) = v440;
              *(_DWORD *)(a4 + 28) = v431;
            }
            v413[2] = v432;
            unint64_t v441 = *(void *)(a4 + 16);
            v442 = *(unsigned int **)a4;
            uint64_t v443 = v441 - *(void *)a4;
            int v444 = *(_DWORD *)(a4 + 28);
            if (v444 + 8 * (int)v443 <= 31) {
              goto LABEL_897;
            }
            unsigned int v445 = *(_DWORD *)(a4 + 24);
            *(_DWORD *)(a4 + 28) = v444 - 32;
            if (v444 - 32 < 0)
            {
              int v446 = v443 & ~(v443 >> 63);
              unint64_t v447 = *(void *)(a4 + 8);
              if ((v446 & 0xFFFFFFFC) != 0 && v447 <= (unint64_t)v442)
              {
                unsigned int v448 = bswap32(*v442);
              }
              else
              {
                uint64_t v449 = 0;
                unsigned int v448 = v445;
                do
                {
                  v450 = (unsigned __int8 *)v442 + v449;
                  unsigned int v451 = v448 << 8;
                  *int v11 = v451;
                  int v452 = 255;
                  if ((unint64_t)v442 + v449 < v441 && (unint64_t)v450 >= v447) {
                    int v452 = *v450;
                  }
                  unsigned int v448 = v452 | v451;
                  *int v11 = v448;
                  ++v449;
                }
                while (v449 != 4);
              }
              *(void *)a4 = v442 + 1;
              v445 |= v448 >> v444;
              unsigned int v453 = v448 << -(char)v444;
              if (!v444) {
                unsigned int v453 = 0;
              }
              *(_DWORD *)(a4 + 24) = v453;
              *(_DWORD *)(a4 + 28) = v444;
            }
            v413[3] = v445;
          }
          if (++v317 == v316) {
            return;
          }
        }
      }
      return;
    }
    goto LABEL_929;
  }
  if (a3 != 1 || HIBYTE(a3) != 2) {
    return;
  }
  if (v282 + 8 * ((int)v275 - (int)v85) <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    v627 = "Cannot read blkData.zoneExclusion.isZoneDefined";
    goto LABEL_935;
  }
  unsigned int v307 = v283 >> 31;
  int v308 = v282 - 1;
  *(_DWORD *)(a4 + 28) = v282 - 1;
  if (v282 - 1 < 0)
  {
    unint64_t v311 = *(void *)(a4 + 8);
    if (((v275 - v85) & ~((uint64_t)(v275 - (void)v85) >> 63) & 0xFFFFFFFC) != 0
      && v311 <= (unint64_t)v85)
    {
      unsigned int v283 = bswap32(*v85);
    }
    else
    {
      uint64_t v454 = 0;
      do
      {
        v455 = (unsigned __int8 *)v85 + v454;
        unsigned int v456 = v283 << 8;
        *int v11 = v456;
        int v457 = 255;
        if ((unint64_t)v85 + v454 < v275 && (unint64_t)v455 >= v311) {
          int v457 = *v455;
        }
        unsigned int v283 = v457 | v456;
        *int v11 = v283;
        ++v454;
      }
      while (v454 != 4);
    }
    unsigned int v458 = v283 << (1 - v282);
    int v459 = v282 + 31;
    *(_DWORD *)(a4 + 28) = v459;
    *(void *)a4 = ++v85;
    v307 |= v283 >> v459;
    if (v459) {
      unsigned int v309 = v458;
    }
    else {
      unsigned int v309 = 0;
    }
    if (v459) {
      int v308 = v459;
    }
    else {
      int v308 = 0;
    }
  }
  else
  {
    unsigned int v309 = 2 * v283;
  }
  *int v11 = v309;
  *(unsigned char *)(a2 + 104) = v307 != 0;
  if (!v307) {
    return;
  }
  if (v308 + 8 * ((int)v275 - (int)v85) <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    v627 = "Cannot read blkData.zoneExclusion.keepPreviousZone";
LABEL_935:
    void *exception = v627;
    __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
  }
  unsigned int v460 = v309 >> 31;
  int v461 = v308 - 1;
  *(_DWORD *)(a4 + 28) = v308 - 1;
  if (v308 - 1 < 0)
  {
    unint64_t v463 = *(void *)(a4 + 8);
    if (((v275 - v85) & ~((uint64_t)(v275 - (void)v85) >> 63) & 0xFFFFFFFC) != 0
      && v463 <= (unint64_t)v85)
    {
      unsigned int v309 = bswap32(*v85);
    }
    else
    {
      uint64_t v464 = 0;
      do
      {
        v465 = (unsigned __int8 *)v85 + v464;
        unsigned int v466 = v309 << 8;
        *int v11 = v466;
        int v467 = 255;
        if ((unint64_t)v85 + v464 < v275 && (unint64_t)v465 >= v463) {
          int v467 = *v465;
        }
        unsigned int v309 = v467 | v466;
        *int v11 = v309;
        ++v464;
      }
      while (v464 != 4);
    }
    int v469 = v308 + 31;
    BOOL v468 = v308 == -31;
    *(_DWORD *)(a4 + 28) = v308 + 31;
    *(void *)a4 = ++v85;
    v460 |= v309 >> (v308 + 31);
    if (v308 == -31) {
      unsigned int v462 = 0;
    }
    else {
      unsigned int v462 = v309 << (1 - v308);
    }
    if (v468) {
      int v461 = 0;
    }
    else {
      int v461 = v469;
    }
  }
  else
  {
    unsigned int v462 = 2 * v309;
  }
  *int v11 = v462;
  *(unsigned char *)(a2 + 105) = v460 != 0;
  if (v460) {
    return;
  }
  if (v461 + 8 * ((int)v275 - (int)v85) <= 3)
  {
LABEL_929:
    exception = __cxa_allocate_exception(8uLL);
    v627 = "Cannot read blkData.zoneExclusion.numZones";
    goto LABEL_935;
  }
  unsigned int v470 = v462 >> 28;
  *(_DWORD *)(a4 + 28) = v461 - 4;
  if (v461 - 4 < 0)
  {
    AT::TBitstreamReader<unsigned int>::FillCacheFrom(a4, v85);
    *(void *)a4 += 4;
    unsigned int v472 = *(_DWORD *)(a4 + 24);
    int v473 = *(_DWORD *)(a4 + 28);
    v470 |= v472 >> v473;
    *(_DWORD *)(a4 + 28) = v473 + 32;
    if (v473 == -32) {
      int v471 = 0;
    }
    else {
      int v471 = v472 << -(char)v473;
    }
  }
  else
  {
    int v471 = 16 * v462;
  }
  *int v11 = v471;
  *(unsigned char *)(a2 + 106) = v470;
  if ((_BYTE)v470)
  {
    uint64_t v474 = 0;
    int v475 = *(unsigned __int8 *)(a2 + 4);
    do
    {
      unint64_t v476 = *(void *)(a4 + 16);
      v477 = *(unsigned int **)a4;
      uint64_t v478 = v476 - *(void *)a4;
      int v479 = *(_DWORD *)(a4 + 28);
      if (v479 + 8 * (int)v478 <= 0)
      {
        exception = __cxa_allocate_exception(8uLL);
        v627 = "Cannot read blkData.zoneExclusion.usePreDefinedZone[w]";
        goto LABEL_935;
      }
      unsigned int v480 = *(_DWORD *)(a4 + 24);
      unsigned int v481 = v480 >> 31;
      int v482 = v479 - 1;
      *(_DWORD *)(a4 + 28) = v479 - 1;
      if (v479 - 1 < 0)
      {
        unint64_t v484 = *(void *)(a4 + 8);
        if ((v478 & ~(v478 >> 63) & 0xFFFFFFFC) == 0 || v484 > (unint64_t)v477)
        {
          uint64_t v486 = 0;
          do
          {
            v487 = (unsigned __int8 *)v477 + v486;
            unsigned int v488 = v480 << 8;
            *int v11 = v488;
            int v489 = 255;
            if ((unint64_t)v477 + v486 < v476 && (unint64_t)v487 >= v484) {
              int v489 = *v487;
            }
            unsigned int v480 = v489 | v488;
            *int v11 = v480;
            ++v486;
          }
          while (v486 != 4);
        }
        else
        {
          unsigned int v480 = bswap32(*v477);
        }
        int v491 = v479 + 31;
        BOOL v490 = v479 == -31;
        *(_DWORD *)(a4 + 28) = v479 + 31;
        *(void *)a4 = ++v477;
        v481 |= v480 >> (v479 + 31);
        if (v479 == -31) {
          unsigned int v483 = 0;
        }
        else {
          unsigned int v483 = v480 << (1 - v479);
        }
        if (v490) {
          int v482 = 0;
        }
        else {
          int v482 = v491;
        }
      }
      else
      {
        unsigned int v483 = 2 * v480;
      }
      *int v11 = v483;
      *(unsigned char *)(a2 + v474 + 107) = v481 != 0;
      uint64_t v492 = v476 - (void)v477;
      int v493 = v482 + 8 * (v476 - v477);
      if (v481)
      {
        if (v493 <= 3)
        {
          exception = __cxa_allocate_exception(8uLL);
          v627 = "Cannot read blkData.zoneExclusion.zoneIndex[w]";
          goto LABEL_935;
        }
        unsigned int v494 = v483 >> 28;
        *(_DWORD *)(a4 + 28) = v482 - 4;
        if (v482 - 4 < 0)
        {
          int v498 = v492 & ~(v492 >> 63);
          unint64_t v499 = *(void *)(a4 + 8);
          if ((v498 & 0xFFFFFFFC) != 0 && v499 <= (unint64_t)v477)
          {
            unsigned int v483 = bswap32(*v477);
          }
          else
          {
            uint64_t v502 = 0;
            do
            {
              v503 = (unsigned __int8 *)v477 + v502;
              unsigned int v504 = v483 << 8;
              *int v11 = v504;
              int v505 = 255;
              if ((unint64_t)v477 + v502 < v476 && (unint64_t)v503 >= v499) {
                int v505 = *v503;
              }
              unsigned int v483 = v505 | v504;
              *int v11 = v483;
              ++v502;
            }
            while (v502 != 4);
          }
          int v506 = v483 << (4 - v482);
          int v507 = v482 + 28;
          *(_DWORD *)(a4 + 28) = v507;
          *(void *)a4 = v477 + 1;
          v494 |= v483 >> v507;
          if (v507) {
            int v495 = v506;
          }
          else {
            int v495 = 0;
          }
        }
        else
        {
          int v495 = 16 * v483;
        }
        *int v11 = v495;
        *(unsigned char *)(a2 + v474 + 122) = v494;
      }
      else if (v475)
      {
        if (v493 <= 31)
        {
LABEL_888:
          exception = __cxa_allocate_exception(8uLL);
          v627 = "Cannot read blkData.zoneExclusion.zone[w].co_tu.cartesian.minX";
          goto LABEL_935;
        }
        *(_DWORD *)(a4 + 28) = v482 - 32;
        if (v482 - 32 < 0)
        {
          unint64_t v496 = *(void *)(a4 + 8);
          if ((v492 & ~(v492 >> 63) & 0xFFFFFFFC) != 0 && v496 <= (unint64_t)v477)
          {
            unsigned int v497 = bswap32(*v477);
          }
          else
          {
            uint64_t v508 = 0;
            unsigned int v497 = v483;
            do
            {
              v509 = (unsigned __int8 *)v477 + v508;
              unsigned int v510 = v497 << 8;
              *int v11 = v510;
              int v511 = 255;
              if ((unint64_t)v477 + v508 < v476 && (unint64_t)v509 >= v496) {
                int v511 = *v509;
              }
              unsigned int v497 = v511 | v510;
              *int v11 = v497;
              ++v508;
            }
            while (v508 != 4);
          }
          *(void *)a4 = v477 + 1;
          v483 |= v497 >> v482;
          unsigned int v512 = v497 << -(char)v482;
          if (!v482) {
            unsigned int v512 = 0;
          }
          *(_DWORD *)(a4 + 24) = v512;
          *(_DWORD *)(a4 + 28) = v482;
        }
        uint64_t v513 = a2 + 24 * v474;
        *(_DWORD *)(v513 + 140) = v483;
        v514 = (_DWORD *)(v513 + 140);
        unint64_t v515 = *(void *)(a4 + 16);
        v516 = *(unsigned int **)a4;
        uint64_t v517 = v515 - *(void *)a4;
        int v518 = *(_DWORD *)(a4 + 28);
        if (v518 + 8 * (int)v517 <= 31)
        {
LABEL_889:
          exception = __cxa_allocate_exception(8uLL);
          v627 = "Cannot read blkData.zoneExclusion.zone[w].co_tu.cartesian.maxX";
          goto LABEL_935;
        }
        unsigned int v519 = *(_DWORD *)(a4 + 24);
        *(_DWORD *)(a4 + 28) = v518 - 32;
        if (v518 - 32 < 0)
        {
          int v520 = v517 & ~(v517 >> 63);
          unint64_t v521 = *(void *)(a4 + 8);
          if ((v520 & 0xFFFFFFFC) != 0 && v521 <= (unint64_t)v516)
          {
            unsigned int v522 = bswap32(*v516);
          }
          else
          {
            uint64_t v523 = 0;
            unsigned int v522 = v519;
            do
            {
              v524 = (unsigned __int8 *)v516 + v523;
              unsigned int v525 = v522 << 8;
              *int v11 = v525;
              int v526 = 255;
              if ((unint64_t)v516 + v523 < v515 && (unint64_t)v524 >= v521) {
                int v526 = *v524;
              }
              unsigned int v522 = v526 | v525;
              *int v11 = v522;
              ++v523;
            }
            while (v523 != 4);
          }
          *(void *)a4 = v516 + 1;
          v519 |= v522 >> v518;
          unsigned int v527 = v522 << -(char)v518;
          if (!v518) {
            unsigned int v527 = 0;
          }
          *(_DWORD *)(a4 + 24) = v527;
          *(_DWORD *)(a4 + 28) = v518;
        }
        v514[1] = v519;
        unint64_t v528 = *(void *)(a4 + 16);
        v529 = *(unsigned int **)a4;
        uint64_t v530 = v528 - *(void *)a4;
        int v531 = *(_DWORD *)(a4 + 28);
        if (v531 + 8 * (int)v530 <= 31)
        {
LABEL_890:
          exception = __cxa_allocate_exception(8uLL);
          v627 = "Cannot read blkData.zoneExclusion.zone[w].co_tu.cartesian.minY";
          goto LABEL_935;
        }
        unsigned int v532 = *(_DWORD *)(a4 + 24);
        *(_DWORD *)(a4 + 28) = v531 - 32;
        if (v531 - 32 < 0)
        {
          int v533 = v530 & ~(v530 >> 63);
          unint64_t v534 = *(void *)(a4 + 8);
          if ((v533 & 0xFFFFFFFC) != 0 && v534 <= (unint64_t)v529)
          {
            unsigned int v535 = bswap32(*v529);
          }
          else
          {
            uint64_t v536 = 0;
            unsigned int v535 = v532;
            do
            {
              v537 = (unsigned __int8 *)v529 + v536;
              unsigned int v538 = v535 << 8;
              *int v11 = v538;
              int v539 = 255;
              if ((unint64_t)v529 + v536 < v528 && (unint64_t)v537 >= v534) {
                int v539 = *v537;
              }
              unsigned int v535 = v539 | v538;
              *int v11 = v535;
              ++v536;
            }
            while (v536 != 4);
          }
          *(void *)a4 = v529 + 1;
          v532 |= v535 >> v531;
          unsigned int v540 = v535 << -(char)v531;
          if (!v531) {
            unsigned int v540 = 0;
          }
          *(_DWORD *)(a4 + 24) = v540;
          *(_DWORD *)(a4 + 28) = v531;
        }
        v514[2] = v532;
        unint64_t v541 = *(void *)(a4 + 16);
        v542 = *(unsigned int **)a4;
        uint64_t v543 = v541 - *(void *)a4;
        int v544 = *(_DWORD *)(a4 + 28);
        if (v544 + 8 * (int)v543 <= 31)
        {
LABEL_891:
          exception = __cxa_allocate_exception(8uLL);
          v627 = "Cannot read blkData.zoneExclusion.zone[w].co_tu.cartesian.maxY";
          goto LABEL_935;
        }
        unsigned int v545 = *(_DWORD *)(a4 + 24);
        *(_DWORD *)(a4 + 28) = v544 - 32;
        if (v544 - 32 < 0)
        {
          int v546 = v543 & ~(v543 >> 63);
          unint64_t v547 = *(void *)(a4 + 8);
          if ((v546 & 0xFFFFFFFC) != 0 && v547 <= (unint64_t)v542)
          {
            unsigned int v548 = bswap32(*v542);
          }
          else
          {
            uint64_t v549 = 0;
            unsigned int v548 = v545;
            do
            {
              v550 = (unsigned __int8 *)v542 + v549;
              unsigned int v551 = v548 << 8;
              *int v11 = v551;
              int v552 = 255;
              if ((unint64_t)v542 + v549 < v541 && (unint64_t)v550 >= v547) {
                int v552 = *v550;
              }
              unsigned int v548 = v552 | v551;
              *int v11 = v548;
              ++v549;
            }
            while (v549 != 4);
          }
          *(void *)a4 = v542 + 1;
          v545 |= v548 >> v544;
          unsigned int v553 = v548 << -(char)v544;
          if (!v544) {
            unsigned int v553 = 0;
          }
          *(_DWORD *)(a4 + 24) = v553;
          *(_DWORD *)(a4 + 28) = v544;
        }
        v514[3] = v545;
        unint64_t v554 = *(void *)(a4 + 16);
        v555 = *(unsigned int **)a4;
        uint64_t v556 = v554 - *(void *)a4;
        int v557 = *(_DWORD *)(a4 + 28);
        if (v557 + 8 * (int)v556 <= 31)
        {
LABEL_892:
          exception = __cxa_allocate_exception(8uLL);
          v627 = "Cannot read blkData.zoneExclusion.zone[w].co_tu.cartesian.minZ";
          goto LABEL_935;
        }
        unsigned int v558 = *(_DWORD *)(a4 + 24);
        *(_DWORD *)(a4 + 28) = v557 - 32;
        if (v557 - 32 < 0)
        {
          int v559 = v556 & ~(v556 >> 63);
          unint64_t v560 = *(void *)(a4 + 8);
          if ((v559 & 0xFFFFFFFC) != 0 && v560 <= (unint64_t)v555)
          {
            unsigned int v561 = bswap32(*v555);
          }
          else
          {
            uint64_t v562 = 0;
            unsigned int v561 = v558;
            do
            {
              v563 = (unsigned __int8 *)v555 + v562;
              unsigned int v564 = v561 << 8;
              *int v11 = v564;
              int v565 = 255;
              if ((unint64_t)v555 + v562 < v554 && (unint64_t)v563 >= v560) {
                int v565 = *v563;
              }
              unsigned int v561 = v565 | v564;
              *int v11 = v561;
              ++v562;
            }
            while (v562 != 4);
          }
          *(void *)a4 = v555 + 1;
          v558 |= v561 >> v557;
          unsigned int v566 = v561 << -(char)v557;
          if (!v557) {
            unsigned int v566 = 0;
          }
          *(_DWORD *)(a4 + 24) = v566;
          *(_DWORD *)(a4 + 28) = v557;
        }
        v514[4] = v558;
        unint64_t v567 = *(void *)(a4 + 16);
        v568 = *(unsigned int **)a4;
        uint64_t v569 = v567 - *(void *)a4;
        int v570 = *(_DWORD *)(a4 + 28);
        if (v570 + 8 * (int)v569 <= 31)
        {
LABEL_893:
          exception = __cxa_allocate_exception(8uLL);
          v627 = "Cannot read blkData.zoneExclusion.zone[w].co_tu.cartesian.maxZ";
          goto LABEL_935;
        }
        unsigned int v571 = *(_DWORD *)(a4 + 24);
        *(_DWORD *)(a4 + 28) = v570 - 32;
        if (v570 - 32 < 0)
        {
          int v572 = v569 & ~(v569 >> 63);
          unint64_t v573 = *(void *)(a4 + 8);
          if ((v572 & 0xFFFFFFFC) != 0 && v573 <= (unint64_t)v568)
          {
            unsigned int v574 = bswap32(*v568);
          }
          else
          {
            uint64_t v575 = 0;
            unsigned int v574 = v571;
            do
            {
              v576 = (unsigned __int8 *)v568 + v575;
              unsigned int v577 = v574 << 8;
              *int v11 = v577;
              int v578 = 255;
              if ((unint64_t)v568 + v575 < v567 && (unint64_t)v576 >= v573) {
                int v578 = *v576;
              }
              unsigned int v574 = v578 | v577;
              *int v11 = v574;
              ++v575;
            }
            while (v575 != 4);
          }
          *(void *)a4 = v568 + 1;
          v571 |= v574 >> v570;
          unsigned int v579 = v574 << -(char)v570;
          if (!v570) {
            unsigned int v579 = 0;
          }
          *(_DWORD *)(a4 + 24) = v579;
          *(_DWORD *)(a4 + 28) = v570;
        }
        v514[5] = v571;
      }
      else
      {
        if (v493 <= 31)
        {
LABEL_894:
          exception = __cxa_allocate_exception(8uLL);
          v627 = "Cannot read blkData.zoneExclusion.zone[w].co_tu.spherical.minAzimuth";
          goto LABEL_935;
        }
        *(_DWORD *)(a4 + 28) = v482 - 32;
        if (v482 - 32 < 0)
        {
          unint64_t v500 = *(void *)(a4 + 8);
          if ((v492 & ~(v492 >> 63) & 0xFFFFFFFC) != 0 && v500 <= (unint64_t)v477)
          {
            unsigned int v501 = bswap32(*v477);
          }
          else
          {
            uint64_t v580 = 0;
            unsigned int v501 = v483;
            do
            {
              v581 = (unsigned __int8 *)v477 + v580;
              unsigned int v582 = v501 << 8;
              *int v11 = v582;
              int v583 = 255;
              if ((unint64_t)v477 + v580 < v476 && (unint64_t)v581 >= v500) {
                int v583 = *v581;
              }
              unsigned int v501 = v583 | v582;
              *int v11 = v501;
              ++v580;
            }
            while (v580 != 4);
          }
          *(void *)a4 = v477 + 1;
          v483 |= v501 >> v482;
          unsigned int v584 = v501 << -(char)v482;
          if (!v482) {
            unsigned int v584 = 0;
          }
          *(_DWORD *)(a4 + 24) = v584;
          *(_DWORD *)(a4 + 28) = v482;
        }
        uint64_t v585 = a2 + 24 * v474;
        *(_DWORD *)(v585 + 140) = v483;
        v586 = (_DWORD *)(v585 + 140);
        unint64_t v587 = *(void *)(a4 + 16);
        v588 = *(unsigned int **)a4;
        uint64_t v589 = v587 - *(void *)a4;
        int v590 = *(_DWORD *)(a4 + 28);
        if (v590 + 8 * (int)v589 <= 31)
        {
LABEL_895:
          exception = __cxa_allocate_exception(8uLL);
          v627 = "Cannot read blkData.zoneExclusion.zone[w].co_tu.spherical.maxAzimuth";
          goto LABEL_935;
        }
        unsigned int v591 = *(_DWORD *)(a4 + 24);
        *(_DWORD *)(a4 + 28) = v590 - 32;
        if (v590 - 32 < 0)
        {
          int v592 = v589 & ~(v589 >> 63);
          unint64_t v593 = *(void *)(a4 + 8);
          if ((v592 & 0xFFFFFFFC) != 0 && v593 <= (unint64_t)v588)
          {
            unsigned int v594 = bswap32(*v588);
          }
          else
          {
            uint64_t v595 = 0;
            unsigned int v594 = v591;
            do
            {
              v596 = (unsigned __int8 *)v588 + v595;
              unsigned int v597 = v594 << 8;
              *int v11 = v597;
              int v598 = 255;
              if ((unint64_t)v588 + v595 < v587 && (unint64_t)v596 >= v593) {
                int v598 = *v596;
              }
              unsigned int v594 = v598 | v597;
              *int v11 = v594;
              ++v595;
            }
            while (v595 != 4);
          }
          *(void *)a4 = v588 + 1;
          v591 |= v594 >> v590;
          unsigned int v599 = v594 << -(char)v590;
          if (!v590) {
            unsigned int v599 = 0;
          }
          *(_DWORD *)(a4 + 24) = v599;
          *(_DWORD *)(a4 + 28) = v590;
        }
        v586[1] = v591;
        unint64_t v600 = *(void *)(a4 + 16);
        v601 = *(unsigned int **)a4;
        uint64_t v602 = v600 - *(void *)a4;
        int v603 = *(_DWORD *)(a4 + 28);
        if (v603 + 8 * (int)v602 <= 31)
        {
LABEL_896:
          exception = __cxa_allocate_exception(8uLL);
          v627 = "Cannot read blkData.zoneExclusion.zone[w].co_tu.spherical.minElevation";
          goto LABEL_935;
        }
        unsigned int v604 = *(_DWORD *)(a4 + 24);
        *(_DWORD *)(a4 + 28) = v603 - 32;
        if (v603 - 32 < 0)
        {
          int v605 = v602 & ~(v602 >> 63);
          unint64_t v606 = *(void *)(a4 + 8);
          if ((v605 & 0xFFFFFFFC) != 0 && v606 <= (unint64_t)v601)
          {
            unsigned int v607 = bswap32(*v601);
          }
          else
          {
            uint64_t v608 = 0;
            unsigned int v607 = v604;
            do
            {
              v609 = (unsigned __int8 *)v601 + v608;
              unsigned int v610 = v607 << 8;
              *int v11 = v610;
              int v611 = 255;
              if ((unint64_t)v601 + v608 < v600 && (unint64_t)v609 >= v606) {
                int v611 = *v609;
              }
              unsigned int v607 = v611 | v610;
              *int v11 = v607;
              ++v608;
            }
            while (v608 != 4);
          }
          *(void *)a4 = v601 + 1;
          v604 |= v607 >> v603;
          unsigned int v612 = v607 << -(char)v603;
          if (!v603) {
            unsigned int v612 = 0;
          }
          *(_DWORD *)(a4 + 24) = v612;
          *(_DWORD *)(a4 + 28) = v603;
        }
        v586[2] = v604;
        unint64_t v613 = *(void *)(a4 + 16);
        v614 = *(unsigned int **)a4;
        uint64_t v615 = v613 - *(void *)a4;
        int v616 = *(_DWORD *)(a4 + 28);
        if (v616 + 8 * (int)v615 <= 31)
        {
LABEL_897:
          exception = __cxa_allocate_exception(8uLL);
          v627 = "Cannot read blkData.zoneExclusion.zone[w].co_tu.spherical.maxElevation";
          goto LABEL_935;
        }
        unsigned int v617 = *(_DWORD *)(a4 + 24);
        *(_DWORD *)(a4 + 28) = v616 - 32;
        if (v616 - 32 < 0)
        {
          int v618 = v615 & ~(v615 >> 63);
          unint64_t v619 = *(void *)(a4 + 8);
          if ((v618 & 0xFFFFFFFC) != 0 && v619 <= (unint64_t)v614)
          {
            unsigned int v620 = bswap32(*v614);
          }
          else
          {
            uint64_t v621 = 0;
            unsigned int v620 = v617;
            do
            {
              v622 = (unsigned __int8 *)v614 + v621;
              unsigned int v623 = v620 << 8;
              *int v11 = v623;
              int v624 = 255;
              if ((unint64_t)v614 + v621 < v613 && (unint64_t)v622 >= v619) {
                int v624 = *v622;
              }
              unsigned int v620 = v624 | v623;
              *int v11 = v620;
              ++v621;
            }
            while (v621 != 4);
          }
          *(void *)a4 = v614 + 1;
          v617 |= v620 >> v616;
          unsigned int v625 = v620 << -(char)v616;
          if (!v616) {
            unsigned int v625 = 0;
          }
          *(_DWORD *)(a4 + 24) = v625;
          *(_DWORD *)(a4 + 28) = v616;
        }
        v586[3] = v617;
      }
      ++v474;
    }
    while (v474 != v470);
  }
}

void APAC::MetadataBitStreamParser::parseDynamicGroup(uint64_t a1, unsigned char *a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 16);
  unint64_t v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 6)
  {
    exception = __cxa_allocate_exception(8uLL);
    unsigned int v67 = "Cannot read dG.groupID";
    goto LABEL_115;
  }
  unsigned int v7 = *(_DWORD *)(a3 + 24);
  unsigned int v8 = v7 >> 25;
  int v9 = v6 - 7;
  *(_DWORD *)(a3 + 28) = v6 - 7;
  if (v6 - 7 < 0)
  {
    unint64_t v11 = *(void *)(a3 + 8);
    if ((v5 & ~(v5 >> 63) & 0xFFFFFFFC) == 0 || v11 > (unint64_t)v4)
    {
      uint64_t v13 = 0;
      do
      {
        int v14 = (unsigned __int8 *)v4 + v13;
        unsigned int v15 = v7 << 8;
        *(_DWORD *)(a3 + 24) = v15;
        int v16 = 255;
        if ((unint64_t)v4 + v13 < v3 && (unint64_t)v14 >= v11) {
          int v16 = *v14;
        }
        unsigned int v7 = v16 | v15;
        *(_DWORD *)(a3 + 24) = v7;
        ++v13;
      }
      while (v13 != 4);
    }
    else
    {
      unsigned int v7 = bswap32(*v4);
    }
    unsigned int v17 = v7 << (7 - v6);
    int v18 = v6 + 25;
    *(_DWORD *)(a3 + 28) = v18;
    *(void *)a3 = ++v4;
    v8 |= v7 >> v18;
    if (v18) {
      unsigned int v10 = v17;
    }
    else {
      unsigned int v10 = 0;
    }
    if (v18) {
      int v9 = v18;
    }
    else {
      int v9 = 0;
    }
  }
  else
  {
    unsigned int v10 = v7 << 7;
  }
  *(_DWORD *)(a3 + 24) = v10;
  *a2 = v8;
  if (v9 + 8 * ((int)v3 - (int)v4) <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    unsigned int v67 = "Cannot read dG.isGlobal";
    goto LABEL_115;
  }
  unsigned int v19 = v10 >> 31;
  int v20 = v9 - 1;
  *(_DWORD *)(a3 + 28) = v9 - 1;
  if (v9 - 1 < 0)
  {
    unint64_t v22 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v22 <= (unint64_t)v4)
    {
      unsigned int v10 = bswap32(*v4);
    }
    else
    {
      uint64_t v23 = 0;
      do
      {
        int v24 = (unsigned __int8 *)v4 + v23;
        unsigned int v25 = v10 << 8;
        *(_DWORD *)(a3 + 24) = v25;
        int v26 = 255;
        if ((unint64_t)v4 + v23 < v3 && (unint64_t)v24 >= v22) {
          int v26 = *v24;
        }
        unsigned int v10 = v26 | v25;
        *(_DWORD *)(a3 + 24) = v10;
        ++v23;
      }
      while (v23 != 4);
    }
    unsigned int v27 = v10 << (1 - v9);
    int v28 = v9 + 31;
    *(_DWORD *)(a3 + 28) = v28;
    *(void *)a3 = ++v4;
    v19 |= v10 >> v28;
    if (v28) {
      unsigned int v21 = v27;
    }
    else {
      unsigned int v21 = 0;
    }
    if (v28) {
      int v20 = v28;
    }
    else {
      int v20 = 0;
    }
  }
  else
  {
    unsigned int v21 = 2 * v10;
  }
  *(_DWORD *)(a3 + 24) = v21;
  a2[1] = v19 != 0;
  if (!v19)
  {
    if (v20 + 8 * ((int)v3 - (int)v4) <= 6)
    {
      exception = __cxa_allocate_exception(8uLL);
      unsigned int v67 = "Cannot read dG.memberCount";
    }
    else
    {
      unsigned int v29 = v21 >> 25;
      int v30 = v20 - 7;
      *(_DWORD *)(a3 + 28) = v20 - 7;
      if (v20 - 7 < 0)
      {
        unint64_t v32 = *(void *)(a3 + 8);
        if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
          && v32 <= (unint64_t)v4)
        {
          unsigned int v21 = bswap32(*v4);
        }
        else
        {
          uint64_t v33 = 0;
          do
          {
            unint64_t v34 = (unsigned __int8 *)v4 + v33;
            unsigned int v35 = v21 << 8;
            *(_DWORD *)(a3 + 24) = v35;
            int v36 = 255;
            if ((unint64_t)v4 + v33 < v3 && (unint64_t)v34 >= v32) {
              int v36 = *v34;
            }
            unsigned int v21 = v36 | v35;
            *(_DWORD *)(a3 + 24) = v21;
            ++v33;
          }
          while (v33 != 4);
        }
        unsigned int v37 = v21 << (7 - v20);
        int v38 = v20 + 25;
        *(_DWORD *)(a3 + 28) = v38;
        *(void *)a3 = ++v4;
        v29 |= v21 >> v38;
        if (v38) {
          unsigned int v31 = v37;
        }
        else {
          unsigned int v31 = 0;
        }
        if (v38) {
          int v30 = v38;
        }
        else {
          int v30 = 0;
        }
      }
      else
      {
        unsigned int v31 = v21 << 7;
      }
      *(_DWORD *)(a3 + 24) = v31;
      a2[2] = v29;
      if (v30 + 8 * ((int)v3 - (int)v4) <= 0)
      {
        exception = __cxa_allocate_exception(8uLL);
        unsigned int v67 = "Cannot read dG.hasConjunctMembers";
      }
      else
      {
        unsigned int v39 = v31 >> 31;
        int v40 = v30 - 1;
        *(_DWORD *)(a3 + 28) = v30 - 1;
        if (v30 - 1 < 0)
        {
          unint64_t v42 = *(void *)(a3 + 8);
          if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
            && v42 <= (unint64_t)v4)
          {
            unsigned int v31 = bswap32(*v4);
          }
          else
          {
            uint64_t v43 = 0;
            do
            {
              unsigned int v44 = (unsigned __int8 *)v4 + v43;
              unsigned int v45 = v31 << 8;
              *(_DWORD *)(a3 + 24) = v45;
              int v46 = 255;
              if ((unint64_t)v4 + v43 < v3 && (unint64_t)v44 >= v42) {
                int v46 = *v44;
              }
              unsigned int v31 = v46 | v45;
              *(_DWORD *)(a3 + 24) = v31;
              ++v43;
            }
            while (v43 != 4);
          }
          int v48 = v30 + 31;
          BOOL v47 = v30 == -31;
          *(_DWORD *)(a3 + 28) = v30 + 31;
          *(void *)a3 = ++v4;
          v39 |= v31 >> (v30 + 31);
          if (v30 == -31) {
            unsigned int v41 = 0;
          }
          else {
            unsigned int v41 = v31 << (1 - v30);
          }
          if (v47) {
            int v40 = 0;
          }
          else {
            int v40 = v48;
          }
        }
        else
        {
          unsigned int v41 = 2 * v31;
        }
        *(_DWORD *)(a3 + 24) = v41;
        a2[3] = v39 != 0;
        if (v39)
        {
          if (v40 + 8 * ((int)v3 - (int)v4) > 6)
          {
            unsigned int v49 = v41 >> 25;
            *(_DWORD *)(a3 + 28) = v40 - 7;
            if (v40 - 7 < 0)
            {
              unint64_t v59 = *(void *)(a3 + 8);
              if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
                && v59 <= (unint64_t)v4)
              {
                unsigned int v41 = bswap32(*v4);
              }
              else
              {
                uint64_t v60 = 0;
                do
                {
                  int v61 = (unsigned __int8 *)v4 + v60;
                  unsigned int v62 = v41 << 8;
                  *(_DWORD *)(a3 + 24) = v62;
                  int v63 = 255;
                  if ((unint64_t)v4 + v60 < v3 && (unint64_t)v61 >= v59) {
                    int v63 = *v61;
                  }
                  unsigned int v41 = v63 | v62;
                  *(_DWORD *)(a3 + 24) = v41;
                  ++v60;
                }
                while (v60 != 4);
              }
              unsigned int v64 = v41 << (7 - v40);
              int v65 = v40 + 25;
              *(_DWORD *)(a3 + 28) = v65;
              *(void *)a3 = v4 + 1;
              v49 |= v41 >> v65;
              if (v65) {
                unsigned int v50 = v64;
              }
              else {
                unsigned int v50 = 0;
              }
            }
            else
            {
              unsigned int v50 = v41 << 7;
            }
            *(_DWORD *)(a3 + 24) = v50;
            a2[4] = v49;
            return;
          }
          exception = __cxa_allocate_exception(8uLL);
          unsigned int v67 = "Cannot read dG.startASCID";
        }
        else
        {
          if (!(_BYTE)v29) {
            return;
          }
          uint64_t v51 = 0;
          unint64_t v52 = *(void *)(a3 + 8);
          while (v40 + 8 * ((int)v3 - (int)v4) > 6)
          {
            unsigned int v53 = v41 >> 25;
            *(_DWORD *)(a3 + 28) = v40 - 7;
            if (v40 - 7 < 0)
            {
              if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
                && v52 <= (unint64_t)v4)
              {
                unsigned int v41 = bswap32(*v4);
              }
              else
              {
                uint64_t v54 = 0;
                do
                {
                  uint64_t v55 = (unsigned __int8 *)v4 + v54;
                  unsigned int v56 = v41 << 8;
                  *(_DWORD *)(a3 + 24) = v56;
                  int v57 = 255;
                  if ((unint64_t)v4 + v54 < v3 && (unint64_t)v55 >= v52) {
                    int v57 = *v55;
                  }
                  unsigned int v41 = v57 | v56;
                  *(_DWORD *)(a3 + 24) = v41;
                  ++v54;
                }
                while (v54 != 4);
              }
              unsigned int v58 = v41 << (7 - v40);
              v40 += 25;
              *(_DWORD *)(a3 + 28) = v40;
              *(void *)a3 = ++v4;
              v53 |= v41 >> v40;
              if (v40) {
                unsigned int v41 = v58;
              }
              else {
                unsigned int v41 = 0;
              }
              if (!v40) {
                int v40 = 0;
              }
            }
            else
            {
              v41 <<= 7;
              v40 -= 7;
            }
            *(_DWORD *)(a3 + 24) = v41;
            a2[v51++ + 5] = v53;
            if (v51 == v29) {
              return;
            }
          }
          exception = __cxa_allocate_exception(8uLL);
          unsigned int v67 = "Cannot read dG.ASCIDList[n]";
        }
      }
    }
LABEL_115:
    void *exception = v67;
    __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
  }
}

void APAC::MetadataBitStreamParser::parseReferenceScreen(uint64_t a1, BOOL *a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 16);
  unint64_t v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v33 = "Cannot read refScreen.hasData";
    goto LABEL_41;
  }
  unsigned int v9 = *(_DWORD *)(a3 + 24);
  unsigned int v10 = v9 >> 31;
  int v11 = v6 - 1;
  *(_DWORD *)(a3 + 28) = v6 - 1;
  if (v6 - 1 < 0)
  {
    unint64_t v13 = *(void *)(a3 + 8);
    if ((v5 & ~(v5 >> 63) & 0xFFFFFFFC) == 0 || v13 > (unint64_t)v4)
    {
      uint64_t v15 = 0;
      do
      {
        int v16 = (unsigned __int8 *)v4 + v15;
        unsigned int v17 = v9 << 8;
        *(_DWORD *)(a3 + 24) = v17;
        int v18 = 255;
        if ((unint64_t)v4 + v15 < v3 && (unint64_t)v16 >= v13) {
          int v18 = *v16;
        }
        unsigned int v9 = v18 | v17;
        *(_DWORD *)(a3 + 24) = v9;
        ++v15;
      }
      while (v15 != 4);
    }
    else
    {
      unsigned int v9 = bswap32(*v4);
    }
    int v20 = v6 + 31;
    BOOL v19 = v6 == -31;
    *(_DWORD *)(a3 + 28) = v6 + 31;
    *(void *)a3 = ++v4;
    v10 |= v9 >> (v6 + 31);
    if (v6 == -31) {
      unsigned int v12 = 0;
    }
    else {
      unsigned int v12 = v9 << (1 - v6);
    }
    if (v19) {
      int v11 = 0;
    }
    else {
      int v11 = v20;
    }
  }
  else
  {
    unsigned int v12 = 2 * v9;
  }
  *(_DWORD *)(a3 + 24) = v12;
  *a2 = v10 != 0;
  if (v10)
  {
    if (v11 + 8 * ((int)v3 - (int)v4) > 3)
    {
      unsigned int v21 = v12 >> 28;
      *(_DWORD *)(a3 + 28) = v11 - 4;
      if (v11 - 4 < 0)
      {
        unint64_t v23 = *(void *)(a3 + 8);
        if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
          && v23 <= (unint64_t)v4)
        {
          unsigned int v12 = bswap32(*v4);
        }
        else
        {
          uint64_t v24 = 0;
          do
          {
            unsigned int v25 = (unsigned __int8 *)v4 + v24;
            unsigned int v26 = v12 << 8;
            *(_DWORD *)(a3 + 24) = v26;
            int v27 = 255;
            if ((unint64_t)v4 + v24 < v3 && (unint64_t)v25 >= v23) {
              int v27 = *v25;
            }
            unsigned int v12 = v27 | v26;
            *(_DWORD *)(a3 + 24) = v12;
            ++v24;
          }
          while (v24 != 4);
        }
        int v28 = v12 << (4 - v11);
        int v29 = v11 + 28;
        *(_DWORD *)(a3 + 28) = v29;
        *(void *)a3 = v4 + 1;
        v21 |= v12 >> v29;
        if (v29) {
          int v22 = v28;
        }
        else {
          int v22 = 0;
        }
      }
      else
      {
        int v22 = 16 * v12;
      }
      *(_DWORD *)(a3 + 24) = v22;
      a2[1] = v21;
      if ((_BYTE)v21)
      {
        unint64_t v30 = 0;
        uint64_t v31 = (uint64_t)(a2 + 4);
        do
        {
          APAC::MetadataBitStreamParser::parseScreenData(a1, v31, a3);
          ++v30;
          v31 += 28;
        }
        while (v30 < a2[1]);
      }
      return;
    }
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v33 = "Cannot read refScreen.APCount";
LABEL_41:
    void *exception = v33;
    __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
  }
}

void APAC::MetadataBitStreamParser::parseCodeBookData(uint64_t a1, BOOL *a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 16);
  unint64_t v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = "Cannot read cbD.hasData";
    __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
  }
  unsigned int v7 = *(_DWORD *)(a3 + 24);
  unsigned int v8 = v7 >> 31;
  *(_DWORD *)(a3 + 28) = v6 - 1;
  if (v6 - 1 < 0)
  {
    uint64_t v10 = v5 & ~(v5 >> 63) & 0xFFFFFFFC;
    unint64_t v11 = *(void *)(a3 + 8);
    if (v10) {
      BOOL v12 = v11 > (unint64_t)v4;
    }
    else {
      BOOL v12 = 1;
    }
    if (v12)
    {
      uint64_t v13 = 0;
      do
      {
        int v14 = (unsigned __int8 *)v4 + v13;
        unsigned int v15 = v7 << 8;
        *(_DWORD *)(a3 + 24) = v15;
        int v16 = 255;
        if ((unint64_t)v4 + v13 < v3 && (unint64_t)v14 >= v11) {
          int v16 = *v14;
        }
        unsigned int v7 = v16 | v15;
        *(_DWORD *)(a3 + 24) = v7;
        ++v13;
      }
      while (v13 != 4);
    }
    else
    {
      unsigned int v7 = bswap32(*v4);
    }
    int v17 = v7 << (1 - v6);
    int v18 = v6 + 31;
    *(_DWORD *)(a3 + 28) = v18;
    *(void *)a3 = v4 + 1;
    v8 |= v7 >> v18;
    if (v18) {
      int v9 = v17;
    }
    else {
      int v9 = 0;
    }
  }
  else
  {
    int v9 = 2 * v7;
  }
  *(_DWORD *)(a3 + 24) = v9;
  *a2 = v8 != 0;
}

void APAC::MetadataBitStreamParser::parseGroupStaticData(uint64_t a1, BOOL *a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 16);
  unint64_t v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v33 = "Cannot read grpSD.hasData";
    goto LABEL_41;
  }
  unsigned int v9 = *(_DWORD *)(a3 + 24);
  unsigned int v10 = v9 >> 31;
  int v11 = v6 - 1;
  *(_DWORD *)(a3 + 28) = v6 - 1;
  if (v6 - 1 < 0)
  {
    unint64_t v13 = *(void *)(a3 + 8);
    if ((v5 & ~(v5 >> 63) & 0xFFFFFFFC) == 0 || v13 > (unint64_t)v4)
    {
      uint64_t v15 = 0;
      do
      {
        int v16 = (unsigned __int8 *)v4 + v15;
        unsigned int v17 = v9 << 8;
        *(_DWORD *)(a3 + 24) = v17;
        int v18 = 255;
        if ((unint64_t)v4 + v15 < v3 && (unint64_t)v16 >= v13) {
          int v18 = *v16;
        }
        unsigned int v9 = v18 | v17;
        *(_DWORD *)(a3 + 24) = v9;
        ++v15;
      }
      while (v15 != 4);
    }
    else
    {
      unsigned int v9 = bswap32(*v4);
    }
    int v20 = v6 + 31;
    BOOL v19 = v6 == -31;
    *(_DWORD *)(a3 + 28) = v6 + 31;
    *(void *)a3 = ++v4;
    v10 |= v9 >> (v6 + 31);
    if (v6 == -31) {
      unsigned int v12 = 0;
    }
    else {
      unsigned int v12 = v9 << (1 - v6);
    }
    if (v19) {
      int v11 = 0;
    }
    else {
      int v11 = v20;
    }
  }
  else
  {
    unsigned int v12 = 2 * v9;
  }
  *(_DWORD *)(a3 + 24) = v12;
  *a2 = v10 != 0;
  if (v10)
  {
    if (v11 + 8 * ((int)v3 - (int)v4) > 6)
    {
      unsigned int v21 = v12 >> 25;
      *(_DWORD *)(a3 + 28) = v11 - 7;
      if (v11 - 7 < 0)
      {
        unint64_t v23 = *(void *)(a3 + 8);
        if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
          && v23 <= (unint64_t)v4)
        {
          unsigned int v12 = bswap32(*v4);
        }
        else
        {
          uint64_t v24 = 0;
          do
          {
            unsigned int v25 = (unsigned __int8 *)v4 + v24;
            unsigned int v26 = v12 << 8;
            *(_DWORD *)(a3 + 24) = v26;
            int v27 = 255;
            if ((unint64_t)v4 + v24 < v3 && (unint64_t)v25 >= v23) {
              int v27 = *v25;
            }
            unsigned int v12 = v27 | v26;
            *(_DWORD *)(a3 + 24) = v12;
            ++v24;
          }
          while (v24 != 4);
        }
        unsigned int v28 = v12 << (7 - v11);
        int v29 = v11 + 25;
        *(_DWORD *)(a3 + 28) = v29;
        *(void *)a3 = v4 + 1;
        v21 |= v12 >> v29;
        if (v29) {
          unsigned int v22 = v28;
        }
        else {
          unsigned int v22 = 0;
        }
      }
      else
      {
        unsigned int v22 = v12 << 7;
      }
      *(_DWORD *)(a3 + 24) = v22;
      a2[1] = v21;
      if ((_BYTE)v21)
      {
        unint64_t v30 = 0;
        uint64_t v31 = a2 + 4;
        do
        {
          APAC::MetadataBitStreamParser::parseStaticGroup(a1, v31, a3);
          ++v30;
          v31 += 216;
        }
        while (v30 < a2[1]);
      }
      return;
    }
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v33 = "Cannot read grpSD.groupCount";
LABEL_41:
    void *exception = v33;
    __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
  }
}

void APAC::MetadataBitStreamParser::parseSceneComponenentStaticData(uint64_t a1, unsigned char *a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 16);
  unint64_t v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 6)
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = "Cannot read scSD.ASCCount";
    __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
  }
  unsigned int v9 = *(_DWORD *)(a3 + 24);
  unsigned int v10 = v9 >> 25;
  *(_DWORD *)(a3 + 28) = v6 - 7;
  if (v6 - 7 < 0)
  {
    uint64_t v12 = v5 & ~(v5 >> 63) & 0xFFFFFFFC;
    unint64_t v13 = *(void *)(a3 + 8);
    if (v12) {
      BOOL v14 = v13 > (unint64_t)v4;
    }
    else {
      BOOL v14 = 1;
    }
    if (v14)
    {
      uint64_t v15 = 0;
      do
      {
        int v16 = (unsigned __int8 *)v4 + v15;
        unsigned int v17 = v9 << 8;
        *(_DWORD *)(a3 + 24) = v17;
        int v18 = 255;
        if ((unint64_t)v4 + v15 < v3 && (unint64_t)v16 >= v13) {
          int v18 = *v16;
        }
        unsigned int v9 = v18 | v17;
        *(_DWORD *)(a3 + 24) = v9;
        ++v15;
      }
      while (v15 != 4);
    }
    else
    {
      unsigned int v9 = bswap32(*v4);
    }
    unsigned int v19 = v9 << (7 - v6);
    int v20 = v6 + 25;
    *(_DWORD *)(a3 + 28) = v20;
    *(void *)a3 = v4 + 1;
    v10 |= v9 >> v20;
    if (v20) {
      unsigned int v11 = v19;
    }
    else {
      unsigned int v11 = 0;
    }
  }
  else
  {
    unsigned int v11 = v9 << 7;
  }
  *(_DWORD *)(a3 + 24) = v11;
  *a2 = v10;
  if ((_BYTE)v10)
  {
    unint64_t v21 = 0;
    uint64_t v22 = (uint64_t)(a2 + 4);
    do
    {
      APAC::MetadataBitStreamParser::parseASCStaticData(a1, v22, a3);
      ++v21;
      v22 += 1144;
    }
    while (v21 < *a2);
  }
}

void APAC::MetadataBitStreamParser::parseASCStaticData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 16);
  unint64_t v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 6)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v129 = "Cannot read sD.sceneComponentID";
    goto LABEL_215;
  }
  unsigned int v9 = *(_DWORD *)(a3 + 24);
  unsigned int v10 = v9 >> 25;
  int v11 = v6 - 7;
  *(_DWORD *)(a3 + 28) = v6 - 7;
  if (v6 - 7 < 0)
  {
    unint64_t v13 = *(void *)(a3 + 8);
    if ((v5 & ~(v5 >> 63) & 0xFFFFFFFC) == 0 || v13 > (unint64_t)v4)
    {
      uint64_t v15 = 0;
      do
      {
        int v16 = (unsigned __int8 *)v4 + v15;
        unsigned int v17 = v9 << 8;
        *(_DWORD *)(a3 + 24) = v17;
        int v18 = 255;
        if ((unint64_t)v4 + v15 < v3 && (unint64_t)v16 >= v13) {
          int v18 = *v16;
        }
        unsigned int v9 = v18 | v17;
        *(_DWORD *)(a3 + 24) = v9;
        ++v15;
      }
      while (v15 != 4);
    }
    else
    {
      unsigned int v9 = bswap32(*v4);
    }
    unsigned int v19 = v9 << (7 - v6);
    int v20 = v6 + 25;
    *(_DWORD *)(a3 + 28) = v20;
    *(void *)a3 = ++v4;
    v10 |= v9 >> v20;
    if (v20) {
      unsigned int v12 = v19;
    }
    else {
      unsigned int v12 = 0;
    }
    if (v20) {
      int v11 = v20;
    }
    else {
      int v11 = 0;
    }
  }
  else
  {
    unsigned int v12 = v9 << 7;
  }
  *(_DWORD *)(a3 + 24) = v12;
  *(unsigned char *)a2 = v10;
  if (v11 + 8 * ((int)v3 - (int)v4) <= 1)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v129 = "Cannot read sD.sceneComponentType";
    goto LABEL_215;
  }
  unsigned int v21 = v12 >> 30;
  int v22 = v11 - 2;
  *(_DWORD *)(a3 + 28) = v11 - 2;
  if (v11 - 2 < 0)
  {
    unint64_t v24 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v24 <= (unint64_t)v4)
    {
      unsigned int v12 = bswap32(*v4);
    }
    else
    {
      uint64_t v25 = 0;
      do
      {
        unsigned int v26 = (unsigned __int8 *)v4 + v25;
        unsigned int v27 = v12 << 8;
        *(_DWORD *)(a3 + 24) = v27;
        int v28 = 255;
        if ((unint64_t)v4 + v25 < v3 && (unint64_t)v26 >= v24) {
          int v28 = *v26;
        }
        unsigned int v12 = v28 | v27;
        *(_DWORD *)(a3 + 24) = v12;
        ++v25;
      }
      while (v25 != 4);
    }
    unsigned int v29 = v12 << (2 - v11);
    int v30 = v11 + 30;
    *(_DWORD *)(a3 + 28) = v30;
    *(void *)a3 = ++v4;
    v21 |= v12 >> v30;
    if (v30) {
      unsigned int v23 = v29;
    }
    else {
      unsigned int v23 = 0;
    }
    if (v30) {
      int v22 = v30;
    }
    else {
      int v22 = 0;
    }
  }
  else
  {
    unsigned int v23 = 4 * v12;
  }
  *(_DWORD *)(a3 + 24) = v23;
  *(unsigned char *)(a2 + 1) = v21;
  if (v22 + 8 * ((int)v3 - (int)v4) <= 6)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v129 = "Cannot read sD.startChannelIndex";
    goto LABEL_215;
  }
  unsigned int v31 = v23 >> 25;
  int v32 = v22 - 7;
  *(_DWORD *)(a3 + 28) = v22 - 7;
  if (v22 - 7 < 0)
  {
    unint64_t v34 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v34 <= (unint64_t)v4)
    {
      unsigned int v23 = bswap32(*v4);
    }
    else
    {
      uint64_t v35 = 0;
      do
      {
        int v36 = (unsigned __int8 *)v4 + v35;
        unsigned int v37 = v23 << 8;
        *(_DWORD *)(a3 + 24) = v37;
        int v38 = 255;
        if ((unint64_t)v4 + v35 < v3 && (unint64_t)v36 >= v34) {
          int v38 = *v36;
        }
        unsigned int v23 = v38 | v37;
        *(_DWORD *)(a3 + 24) = v23;
        ++v35;
      }
      while (v35 != 4);
    }
    unsigned int v39 = v23 << (7 - v22);
    int v40 = v22 + 25;
    *(_DWORD *)(a3 + 28) = v40;
    *(void *)a3 = ++v4;
    v31 |= v23 >> v40;
    if (v40) {
      unsigned int v33 = v39;
    }
    else {
      unsigned int v33 = 0;
    }
    if (v40) {
      int v32 = v40;
    }
    else {
      int v32 = 0;
    }
  }
  else
  {
    unsigned int v33 = v23 << 7;
  }
  *(_DWORD *)(a3 + 24) = v33;
  *(unsigned char *)(a2 + 2) = v31;
  if (v32 + 8 * ((int)v3 - (int)v4) <= 2)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v129 = "Cannot read sD.rendererSubType";
    goto LABEL_215;
  }
  unsigned int v41 = v33 >> 29;
  int v42 = v32 - 3;
  *(_DWORD *)(a3 + 28) = v32 - 3;
  if (v32 - 3 < 0)
  {
    unint64_t v44 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v44 <= (unint64_t)v4)
    {
      unsigned int v33 = bswap32(*v4);
    }
    else
    {
      uint64_t v45 = 0;
      do
      {
        int v46 = (unsigned __int8 *)v4 + v45;
        unsigned int v47 = v33 << 8;
        *(_DWORD *)(a3 + 24) = v47;
        int v48 = 255;
        if ((unint64_t)v4 + v45 < v3 && (unint64_t)v46 >= v44) {
          int v48 = *v46;
        }
        unsigned int v33 = v48 | v47;
        *(_DWORD *)(a3 + 24) = v33;
        ++v45;
      }
      while (v45 != 4);
    }
    unsigned int v49 = v33 << (3 - v32);
    int v50 = v32 + 29;
    *(_DWORD *)(a3 + 28) = v50;
    *(void *)a3 = ++v4;
    v41 |= v33 >> v50;
    if (v50) {
      unsigned int v43 = v49;
    }
    else {
      unsigned int v43 = 0;
    }
    if (v50) {
      int v42 = v50;
    }
    else {
      int v42 = 0;
    }
  }
  else
  {
    unsigned int v43 = 8 * v33;
  }
  *(_DWORD *)(a3 + 24) = v43;
  *(unsigned char *)(a2 + 3) = v41;
  if (v42 + 8 * ((int)v3 - (int)v4) <= 7)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v129 = "Cannot read sD.rendererVersion";
    goto LABEL_215;
  }
  unsigned int v51 = HIBYTE(v43);
  int v52 = v42 - 8;
  *(_DWORD *)(a3 + 28) = v42 - 8;
  if (v42 - 8 < 0)
  {
    unint64_t v54 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v54 <= (unint64_t)v4)
    {
      unsigned int v43 = bswap32(*v4);
    }
    else
    {
      uint64_t v55 = 0;
      do
      {
        unsigned int v56 = (unsigned __int8 *)v4 + v55;
        unsigned int v57 = v43 << 8;
        *(_DWORD *)(a3 + 24) = v57;
        int v58 = 255;
        if ((unint64_t)v4 + v55 < v3 && (unint64_t)v56 >= v54) {
          int v58 = *v56;
        }
        unsigned int v43 = v58 | v57;
        *(_DWORD *)(a3 + 24) = v43;
        ++v55;
      }
      while (v55 != 4);
    }
    int v60 = v42 + 24;
    BOOL v59 = v42 == -24;
    *(_DWORD *)(a3 + 28) = v42 + 24;
    *(void *)a3 = ++v4;
    v51 |= v43 >> (v42 + 24);
    if (v42 == -24) {
      unsigned int v53 = 0;
    }
    else {
      unsigned int v53 = v43 << (8 - v42);
    }
    if (v59) {
      int v52 = 0;
    }
    else {
      int v52 = v60;
    }
  }
  else
  {
    unsigned int v53 = v43 << 8;
  }
  *(_DWORD *)(a3 + 24) = v53;
  *(unsigned char *)(a2 + 4) = v51;
  uint64_t v61 = v3 - (void)v4;
  if (v52 + 8 * ((int)v3 - (int)v4) <= 31)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v129 = "Cannot read sD.channelLayoutTag";
    goto LABEL_215;
  }
  *(_DWORD *)(a3 + 28) = v52 - 32;
  if (v52 - 32 < 0)
  {
    unint64_t v64 = *(void *)(a3 + 8);
    if ((v61 & ~(v61 >> 63) & 0xFFFFFFFC) != 0 && v64 <= (unint64_t)v4)
    {
      unsigned int v65 = bswap32(*v4);
    }
    else
    {
      uint64_t v66 = 0;
      unsigned int v65 = v53;
      do
      {
        unsigned int v67 = (unsigned __int8 *)v4 + v66;
        unsigned int v68 = v65 << 8;
        *(_DWORD *)(a3 + 24) = v68;
        int v69 = 255;
        if ((unint64_t)v4 + v66 < v3 && (unint64_t)v67 >= v64) {
          int v69 = *v67;
        }
        unsigned int v65 = v69 | v68;
        *(_DWORD *)(a3 + 24) = v65;
        ++v66;
      }
      while (v66 != 4);
    }
    *(void *)a3 = ++v4;
    int v63 = (v65 >> v52) | v53;
    unsigned int v53 = v65 << -(char)v52;
    if (!v52) {
      unsigned int v53 = 0;
    }
    *(_DWORD *)(a3 + 24) = v53;
    *(_DWORD *)(a3 + 28) = v52;
    uint64_t v61 = v3 - (void)v4;
    int v62 = 8 * (v3 - v4);
  }
  else
  {
    int v62 = 8 * v61;
    v52 -= 32;
    int v63 = v53;
  }
  *(_DWORD *)(a2 + 8) = v63;
  if (v62 + v52 <= 2)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v129 = "Cannot read sD.HOAOrder";
    goto LABEL_215;
  }
  unsigned int v70 = v53 >> 29;
  int v71 = v52 - 3;
  *(_DWORD *)(a3 + 28) = v52 - 3;
  if (v52 - 3 < 0)
  {
    unint64_t v73 = *(void *)(a3 + 8);
    if ((v61 & ~(v61 >> 63) & 0xFFFFFFFC) != 0 && v73 <= (unint64_t)v4)
    {
      unsigned int v53 = bswap32(*v4);
    }
    else
    {
      uint64_t v74 = 0;
      do
      {
        unsigned int v75 = (unsigned __int8 *)v4 + v74;
        unsigned int v76 = v53 << 8;
        *(_DWORD *)(a3 + 24) = v76;
        int v77 = 255;
        if ((unint64_t)v4 + v74 < v3 && (unint64_t)v75 >= v73) {
          int v77 = *v75;
        }
        unsigned int v53 = v77 | v76;
        *(_DWORD *)(a3 + 24) = v53;
        ++v74;
      }
      while (v74 != 4);
    }
    unsigned int v78 = v53 << (3 - v52);
    int v79 = v52 + 29;
    *(_DWORD *)(a3 + 28) = v79;
    *(void *)a3 = ++v4;
    v70 |= v53 >> v79;
    if (v79) {
      unsigned int v72 = v78;
    }
    else {
      unsigned int v72 = 0;
    }
    if (v79) {
      int v71 = v79;
    }
    else {
      int v71 = 0;
    }
  }
  else
  {
    unsigned int v72 = 8 * v53;
  }
  *(_DWORD *)(a3 + 24) = v72;
  *(unsigned char *)(a2 + 12) = v70;
  if (v71 + 8 * ((int)v3 - (int)v4) <= 1)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v129 = "Cannot read sD.HOAOrdering";
    goto LABEL_215;
  }
  unsigned int v80 = v72 >> 30;
  int v81 = v71 - 2;
  *(_DWORD *)(a3 + 28) = v71 - 2;
  if (v71 - 2 < 0)
  {
    unint64_t v83 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v83 <= (unint64_t)v4)
    {
      unsigned int v72 = bswap32(*v4);
    }
    else
    {
      uint64_t v84 = 0;
      do
      {
        int v85 = (unsigned __int8 *)v4 + v84;
        unsigned int v86 = v72 << 8;
        *(_DWORD *)(a3 + 24) = v86;
        int v87 = 255;
        if ((unint64_t)v4 + v84 < v3 && (unint64_t)v85 >= v83) {
          int v87 = *v85;
        }
        unsigned int v72 = v87 | v86;
        *(_DWORD *)(a3 + 24) = v72;
        ++v84;
      }
      while (v84 != 4);
    }
    unsigned int v88 = v72 << (2 - v71);
    int v89 = v71 + 30;
    *(_DWORD *)(a3 + 28) = v89;
    *(void *)a3 = ++v4;
    v80 |= v72 >> v89;
    if (v89) {
      unsigned int v82 = v88;
    }
    else {
      unsigned int v82 = 0;
    }
    if (v89) {
      int v81 = v89;
    }
    else {
      int v81 = 0;
    }
  }
  else
  {
    unsigned int v82 = 4 * v72;
  }
  *(_DWORD *)(a3 + 24) = v82;
  *(unsigned char *)(a2 + 13) = v80;
  if (v81 + 8 * ((int)v3 - (int)v4) <= 1)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v129 = "Cannot read sD.HOANormalization";
    goto LABEL_215;
  }
  unsigned int v90 = v82 >> 30;
  int v91 = v81 - 2;
  *(_DWORD *)(a3 + 28) = v81 - 2;
  if (v81 - 2 < 0)
  {
    unint64_t v93 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v93 <= (unint64_t)v4)
    {
      unsigned int v82 = bswap32(*v4);
    }
    else
    {
      uint64_t v94 = 0;
      do
      {
        unsigned int v95 = (unsigned __int8 *)v4 + v94;
        unsigned int v96 = v82 << 8;
        *(_DWORD *)(a3 + 24) = v96;
        int v97 = 255;
        if ((unint64_t)v4 + v94 < v3 && (unint64_t)v95 >= v93) {
          int v97 = *v95;
        }
        unsigned int v82 = v97 | v96;
        *(_DWORD *)(a3 + 24) = v82;
        ++v94;
      }
      while (v94 != 4);
    }
    unsigned int v98 = v82 << (2 - v81);
    int v99 = v81 + 30;
    *(_DWORD *)(a3 + 28) = v99;
    *(void *)a3 = ++v4;
    v90 |= v82 >> v99;
    if (v99) {
      unsigned int v92 = v98;
    }
    else {
      unsigned int v92 = 0;
    }
    if (v99) {
      int v91 = v99;
    }
    else {
      int v91 = 0;
    }
  }
  else
  {
    unsigned int v92 = 4 * v82;
  }
  *(_DWORD *)(a3 + 24) = v92;
  *(unsigned char *)(a2 + 14) = v90;
  if (v91 + 8 * ((int)v3 - (int)v4) <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v129 = "Cannot read sD.NFCRefDist.hasData";
    goto LABEL_215;
  }
  unsigned int v100 = v92 >> 31;
  int v101 = v91 - 1;
  *(_DWORD *)(a3 + 28) = v91 - 1;
  if (v91 - 1 < 0)
  {
    unint64_t v103 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v103 <= (unint64_t)v4)
    {
      unsigned int v92 = bswap32(*v4);
    }
    else
    {
      uint64_t v104 = 0;
      do
      {
        unsigned int v105 = (unsigned __int8 *)v4 + v104;
        unsigned int v106 = v92 << 8;
        *(_DWORD *)(a3 + 24) = v106;
        int v107 = 255;
        if ((unint64_t)v4 + v104 < v3 && (unint64_t)v105 >= v103) {
          int v107 = *v105;
        }
        unsigned int v92 = v107 | v106;
        *(_DWORD *)(a3 + 24) = v92;
        ++v104;
      }
      while (v104 != 4);
    }
    int v109 = v91 + 31;
    BOOL v108 = v91 == -31;
    *(_DWORD *)(a3 + 28) = v91 + 31;
    *(void *)a3 = ++v4;
    v100 |= v92 >> (v91 + 31);
    if (v91 == -31) {
      unsigned int v102 = 0;
    }
    else {
      unsigned int v102 = v92 << (1 - v91);
    }
    if (v108) {
      int v101 = 0;
    }
    else {
      int v101 = v109;
    }
  }
  else
  {
    unsigned int v102 = 2 * v92;
  }
  *(_DWORD *)(a3 + 24) = v102;
  *(unsigned char *)(a2 + 16) = v100 != 0;
  if (v100)
  {
    if (v101 + 8 * ((int)v3 - (int)v4) <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      int v129 = "Cannot read sD.NFCRefDist.nfcRefDist";
LABEL_215:
      void *exception = v129;
      __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
    }
    *(_DWORD *)(a3 + 28) = v101 - 32;
    if (v101 - 32 < 0)
    {
      unint64_t v111 = *(void *)(a3 + 8);
      if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
        && v111 <= (unint64_t)v4)
      {
        unsigned int v112 = bswap32(*v4);
      }
      else
      {
        uint64_t v113 = 0;
        unsigned int v112 = v102;
        do
        {
          unsigned int v114 = (unsigned __int8 *)v4 + v113;
          unsigned int v115 = v112 << 8;
          *(_DWORD *)(a3 + 24) = v115;
          int v116 = 255;
          if ((unint64_t)v4 + v113 < v3 && (unint64_t)v114 >= v111) {
            int v116 = *v114;
          }
          unsigned int v112 = v116 | v115;
          *(_DWORD *)(a3 + 24) = v112;
          ++v113;
        }
        while (v113 != 4);
      }
      *(void *)a3 = ++v4;
      int v110 = (v112 >> v101) | v102;
      unsigned int v102 = v112 << -(char)v101;
      if (!v101) {
        unsigned int v102 = 0;
      }
      *(_DWORD *)(a3 + 24) = v102;
      *(_DWORD *)(a3 + 28) = v101;
    }
    else
    {
      v101 -= 32;
      int v110 = v102;
    }
    *(_DWORD *)(a2 + 20) = v110;
  }
  if (v101 + 8 * ((int)v3 - (int)v4) <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v129 = "Cannot read sD.screenRef";
    goto LABEL_215;
  }
  unsigned int v117 = v102 >> 31;
  *(_DWORD *)(a3 + 28) = v101 - 1;
  if (v101 - 1 < 0)
  {
    unint64_t v119 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v119 <= (unint64_t)v4)
    {
      unsigned int v102 = bswap32(*v4);
    }
    else
    {
      uint64_t v120 = 0;
      do
      {
        uint64_t v121 = (unsigned __int8 *)v4 + v120;
        unsigned int v122 = v102 << 8;
        *(_DWORD *)(a3 + 24) = v122;
        int v123 = 255;
        if ((unint64_t)v4 + v120 < v3 && (unint64_t)v121 >= v119) {
          int v123 = *v121;
        }
        unsigned int v102 = v123 | v122;
        *(_DWORD *)(a3 + 24) = v102;
        ++v120;
      }
      while (v120 != 4);
    }
    int v124 = v102 << (1 - v101);
    int v125 = v101 + 31;
    *(_DWORD *)(a3 + 28) = v125;
    *(void *)a3 = v4 + 1;
    v117 |= v102 >> v125;
    if (v125) {
      int v118 = v124;
    }
    else {
      int v118 = 0;
    }
  }
  else
  {
    int v118 = 2 * v102;
  }
  *(_DWORD *)(a3 + 24) = v118;
  *(unsigned char *)(a2 + 24) = v117 != 0;
  APAC::MetadataBitStreamParser::parseProprietaryStaticData(a1, a2 + 28, a3);
  APAC::MetadataBitStreamParser::parseDolbyStaticData(v126, (BOOL *)(a2 + 112), a3);
  APAC::MetadataBitStreamParser::parseExtendedData(v127, a2 + 114, a3);
}

void APAC::MetadataBitStreamParser::parseProprietaryStaticData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 16);
  unint64_t v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    unint64_t v119 = "Cannot read pSD.hasData";
    goto LABEL_180;
  }
  unsigned int v9 = *(_DWORD *)(a3 + 24);
  unsigned int v10 = v9 >> 31;
  int v11 = v6 - 1;
  *(_DWORD *)(a3 + 28) = v6 - 1;
  if (v6 - 1 < 0)
  {
    unint64_t v13 = *(void *)(a3 + 8);
    if ((v5 & ~(v5 >> 63) & 0xFFFFFFFC) == 0 || v13 > (unint64_t)v4)
    {
      uint64_t v15 = 0;
      do
      {
        int v16 = (unsigned __int8 *)v4 + v15;
        unsigned int v17 = v9 << 8;
        *(_DWORD *)(a3 + 24) = v17;
        int v18 = 255;
        if ((unint64_t)v4 + v15 < v3 && (unint64_t)v16 >= v13) {
          int v18 = *v16;
        }
        unsigned int v9 = v18 | v17;
        *(_DWORD *)(a3 + 24) = v9;
        ++v15;
      }
      while (v15 != 4);
    }
    else
    {
      unsigned int v9 = bswap32(*v4);
    }
    int v20 = v6 + 31;
    BOOL v19 = v6 == -31;
    *(_DWORD *)(a3 + 28) = v6 + 31;
    *(void *)a3 = ++v4;
    v10 |= v9 >> (v6 + 31);
    if (v6 == -31) {
      unsigned int v12 = 0;
    }
    else {
      unsigned int v12 = v9 << (1 - v6);
    }
    if (v19) {
      int v11 = 0;
    }
    else {
      int v11 = v20;
    }
  }
  else
  {
    unsigned int v12 = 2 * v9;
  }
  *(_DWORD *)(a3 + 24) = v12;
  *(unsigned char *)a2 = v10 != 0;
  if (!v10) {
    return;
  }
  if (v11 + 8 * ((int)v3 - (int)v4) <= 4)
  {
    exception = __cxa_allocate_exception(8uLL);
    unint64_t v119 = "Cannot read pSD.numParameters";
LABEL_180:
    void *exception = v119;
    __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
  }
  unsigned int v21 = v12 >> 27;
  *(_DWORD *)(a3 + 28) = v11 - 5;
  if (v11 - 5 < 0)
  {
    unint64_t v23 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v23 <= (unint64_t)v4)
    {
      unsigned int v12 = bswap32(*v4);
    }
    else
    {
      uint64_t v24 = 0;
      do
      {
        uint64_t v25 = (unsigned __int8 *)v4 + v24;
        unsigned int v26 = v12 << 8;
        *(_DWORD *)(a3 + 24) = v26;
        int v27 = 255;
        if ((unint64_t)v4 + v24 < v3 && (unint64_t)v25 >= v23) {
          int v27 = *v25;
        }
        unsigned int v12 = v27 | v26;
        *(_DWORD *)(a3 + 24) = v12;
        ++v24;
      }
      while (v24 != 4);
    }
    int v28 = v12 << (5 - v11);
    int v29 = v11 + 27;
    *(_DWORD *)(a3 + 28) = v29;
    *(void *)a3 = v4 + 1;
    v21 |= v12 >> v29;
    if (v29) {
      int v22 = v28;
    }
    else {
      int v22 = 0;
    }
  }
  else
  {
    int v22 = 32 * v12;
  }
  *(_DWORD *)(a3 + 24) = v22;
  *(unsigned char *)(a2 + 1) = v21;
  if ((_BYTE)v21)
  {
    uint64_t v30 = 0;
    while (1)
    {
      unint64_t v31 = *(void *)(a3 + 16);
      int v32 = *(unsigned int **)a3;
      uint64_t v33 = v31 - *(void *)a3;
      int v34 = *(_DWORD *)(a3 + 28);
      if (v34 + 8 * (int)v33 <= 4)
      {
        exception = __cxa_allocate_exception(8uLL);
        unint64_t v119 = "Cannot read pSD.paramIndexList[n]";
        goto LABEL_180;
      }
      unsigned int v35 = *(_DWORD *)(a3 + 24);
      unsigned int v36 = v35 >> 27;
      int v37 = v34 - 5;
      *(_DWORD *)(a3 + 28) = v34 - 5;
      if (v34 - 5 < 0)
      {
        unint64_t v39 = *(void *)(a3 + 8);
        if ((v33 & ~(v33 >> 63) & 0xFFFFFFFC) == 0 || v39 > (unint64_t)v32)
        {
          uint64_t v41 = 0;
          do
          {
            int v42 = (unsigned __int8 *)v32 + v41;
            unsigned int v43 = v35 << 8;
            *(_DWORD *)(a3 + 24) = v43;
            int v44 = 255;
            if ((unint64_t)v32 + v41 < v31 && (unint64_t)v42 >= v39) {
              int v44 = *v42;
            }
            unsigned int v35 = v44 | v43;
            *(_DWORD *)(a3 + 24) = v35;
            ++v41;
          }
          while (v41 != 4);
        }
        else
        {
          unsigned int v35 = bswap32(*v32);
        }
        int v46 = v34 + 27;
        BOOL v45 = v34 == -27;
        *(_DWORD *)(a3 + 28) = v34 + 27;
        *(void *)a3 = ++v32;
        v36 |= v35 >> (v34 + 27);
        if (v34 == -27) {
          unsigned int v38 = 0;
        }
        else {
          unsigned int v38 = v35 << (5 - v34);
        }
        if (v45) {
          int v37 = 0;
        }
        else {
          int v37 = v46;
        }
      }
      else
      {
        unsigned int v38 = 32 * v35;
      }
      *(_DWORD *)(a3 + 24) = v38;
      *(unsigned char *)(a2 + v30 + 52) = v36;
      switch((char)v36)
      {
        case 0:
          if (v37 + 8 * ((int)v31 - (int)v32) <= 0)
          {
            exception = __cxa_allocate_exception(8uLL);
            unint64_t v119 = "Cannot read pSD.isComplexSH";
            goto LABEL_180;
          }
          unsigned int v47 = v38 >> 31;
          *(_DWORD *)(a3 + 28) = v37 - 1;
          if (v37 - 1 < 0)
          {
            unint64_t v60 = *(void *)(a3 + 8);
            if (((v31 - v32) & ~((uint64_t)(v31 - (void)v32) >> 63) & 0xFFFFFFFC) != 0
              && v60 <= (unint64_t)v32)
            {
              unsigned int v38 = bswap32(*v32);
            }
            else
            {
              uint64_t v68 = 0;
              do
              {
                int v69 = (unsigned __int8 *)v32 + v68;
                unsigned int v70 = v38 << 8;
                *(_DWORD *)(a3 + 24) = v70;
                int v71 = 255;
                if ((unint64_t)v32 + v68 < v31 && (unint64_t)v69 >= v60) {
                  int v71 = *v69;
                }
                unsigned int v38 = v71 | v70;
                *(_DWORD *)(a3 + 24) = v38;
                ++v68;
              }
              while (v68 != 4);
            }
            int v72 = v38 << (1 - v37);
            int v73 = v37 + 31;
            *(_DWORD *)(a3 + 28) = v73;
            *(void *)a3 = v32 + 1;
            v47 |= v38 >> v73;
            if (v73) {
              int v48 = v72;
            }
            else {
              int v48 = 0;
            }
          }
          else
          {
            int v48 = 2 * v38;
          }
          *(_DWORD *)(a3 + 24) = v48;
          *(unsigned char *)(a2 + 2) = v47 != 0;
          goto LABEL_177;
        case 1:
          if (v37 + 8 * ((int)v31 - (int)v32) <= 0)
          {
            exception = __cxa_allocate_exception(8uLL);
            unint64_t v119 = "Cannot read pSD.isCSPhase";
            goto LABEL_180;
          }
          unsigned int v49 = v38 >> 31;
          *(_DWORD *)(a3 + 28) = v37 - 1;
          if (v37 - 1 < 0)
          {
            unint64_t v61 = *(void *)(a3 + 8);
            if (((v31 - v32) & ~((uint64_t)(v31 - (void)v32) >> 63) & 0xFFFFFFFC) != 0
              && v61 <= (unint64_t)v32)
            {
              unsigned int v38 = bswap32(*v32);
            }
            else
            {
              uint64_t v74 = 0;
              do
              {
                unsigned int v75 = (unsigned __int8 *)v32 + v74;
                unsigned int v76 = v38 << 8;
                *(_DWORD *)(a3 + 24) = v76;
                int v77 = 255;
                if ((unint64_t)v32 + v74 < v31 && (unint64_t)v75 >= v61) {
                  int v77 = *v75;
                }
                unsigned int v38 = v77 | v76;
                *(_DWORD *)(a3 + 24) = v38;
                ++v74;
              }
              while (v74 != 4);
            }
            int v78 = v38 << (1 - v37);
            int v79 = v37 + 31;
            *(_DWORD *)(a3 + 28) = v79;
            *(void *)a3 = v32 + 1;
            v49 |= v38 >> v79;
            if (v79) {
              int v50 = v78;
            }
            else {
              int v50 = 0;
            }
          }
          else
          {
            int v50 = 2 * v38;
          }
          *(_DWORD *)(a3 + 24) = v50;
          *(unsigned char *)(a2 + 3) = v49 != 0;
          goto LABEL_177;
        case 2:
          if (v37 + 8 * ((int)v31 - (int)v32) <= 1)
          {
            exception = __cxa_allocate_exception(8uLL);
            unint64_t v119 = "Cannot read pSD.productionCoordinate";
            goto LABEL_180;
          }
          unsigned int v51 = v38 >> 30;
          *(_DWORD *)(a3 + 28) = v37 - 2;
          if (v37 - 2 < 0)
          {
            unint64_t v62 = *(void *)(a3 + 8);
            if (((v31 - v32) & ~((uint64_t)(v31 - (void)v32) >> 63) & 0xFFFFFFFC) != 0
              && v62 <= (unint64_t)v32)
            {
              unsigned int v38 = bswap32(*v32);
            }
            else
            {
              uint64_t v80 = 0;
              do
              {
                int v81 = (unsigned __int8 *)v32 + v80;
                unsigned int v82 = v38 << 8;
                *(_DWORD *)(a3 + 24) = v82;
                int v83 = 255;
                if ((unint64_t)v32 + v80 < v31 && (unint64_t)v81 >= v62) {
                  int v83 = *v81;
                }
                unsigned int v38 = v83 | v82;
                *(_DWORD *)(a3 + 24) = v38;
                ++v80;
              }
              while (v80 != 4);
            }
            int v84 = v38 << (2 - v37);
            int v85 = v37 + 30;
            *(_DWORD *)(a3 + 28) = v85;
            *(void *)a3 = v32 + 1;
            v51 |= v38 >> v85;
            if (v85) {
              int v52 = v84;
            }
            else {
              int v52 = 0;
            }
          }
          else
          {
            int v52 = 4 * v38;
          }
          *(_DWORD *)(a3 + 24) = v52;
          *(unsigned char *)(a2 + 4) = v51;
          goto LABEL_177;
        case 3:
          APAC::MetadataBitStreamParser::parseSceneReverb(a1, a2 + 6, a3);
          goto LABEL_177;
        case 4:
          if (v37 + 8 * ((int)v31 - (int)v32) <= 1)
          {
            exception = __cxa_allocate_exception(8uLL);
            unint64_t v119 = "Cannot read pSD.postProcReverbIndex";
            goto LABEL_180;
          }
          unsigned int v53 = v38 >> 30;
          *(_DWORD *)(a3 + 28) = v37 - 2;
          if (v37 - 2 < 0)
          {
            unint64_t v63 = *(void *)(a3 + 8);
            if (((v31 - v32) & ~((uint64_t)(v31 - (void)v32) >> 63) & 0xFFFFFFFC) != 0
              && v63 <= (unint64_t)v32)
            {
              unsigned int v38 = bswap32(*v32);
            }
            else
            {
              uint64_t v86 = 0;
              do
              {
                int v87 = (unsigned __int8 *)v32 + v86;
                unsigned int v88 = v38 << 8;
                *(_DWORD *)(a3 + 24) = v88;
                int v89 = 255;
                if ((unint64_t)v32 + v86 < v31 && (unint64_t)v87 >= v63) {
                  int v89 = *v87;
                }
                unsigned int v38 = v89 | v88;
                *(_DWORD *)(a3 + 24) = v38;
                ++v86;
              }
              while (v86 != 4);
            }
            int v90 = v38 << (2 - v37);
            int v91 = v37 + 30;
            *(_DWORD *)(a3 + 28) = v91;
            *(void *)a3 = v32 + 1;
            v53 |= v38 >> v91;
            if (v91) {
              int v54 = v90;
            }
            else {
              int v54 = 0;
            }
          }
          else
          {
            int v54 = 4 * v38;
          }
          *(_DWORD *)(a3 + 24) = v54;
          *(unsigned char *)(a2 + 14) = v53;
          goto LABEL_177;
        case 5:
          APAC::MetadataBitStreamParser::parseRadiationPattern(a1, a2 + 16, a3);
          goto LABEL_177;
        case 6:
          APAC::MetadataBitStreamParser::parseBinauralization(a1, a2 + 24, a3);
          goto LABEL_177;
        case 7:
          if (v37 + 8 * ((int)v31 - (int)v32) <= 3)
          {
            exception = __cxa_allocate_exception(8uLL);
            unint64_t v119 = "Cannot read pSD.HCFilterCodeBookID";
            goto LABEL_180;
          }
          unsigned int v55 = v38 >> 28;
          *(_DWORD *)(a3 + 28) = v37 - 4;
          if (v37 - 4 < 0)
          {
            unint64_t v64 = *(void *)(a3 + 8);
            if (((v31 - v32) & ~((uint64_t)(v31 - (void)v32) >> 63) & 0xFFFFFFFC) != 0
              && v64 <= (unint64_t)v32)
            {
              unsigned int v38 = bswap32(*v32);
            }
            else
            {
              uint64_t v92 = 0;
              do
              {
                unint64_t v93 = (unsigned __int8 *)v32 + v92;
                unsigned int v94 = v38 << 8;
                *(_DWORD *)(a3 + 24) = v94;
                int v95 = 255;
                if ((unint64_t)v32 + v92 < v31 && (unint64_t)v93 >= v64) {
                  int v95 = *v93;
                }
                unsigned int v38 = v95 | v94;
                *(_DWORD *)(a3 + 24) = v38;
                ++v92;
              }
              while (v92 != 4);
            }
            int v96 = v38 << (4 - v37);
            int v97 = v37 + 28;
            *(_DWORD *)(a3 + 28) = v97;
            *(void *)a3 = v32 + 1;
            v55 |= v38 >> v97;
            if (v97) {
              int v56 = v96;
            }
            else {
              int v56 = 0;
            }
          }
          else
          {
            int v56 = 16 * v38;
          }
          *(_DWORD *)(a3 + 24) = v56;
          *(unsigned char *)(a2 + 36) = v55;
          goto LABEL_177;
        case 8:
          uint64_t v57 = v31 - (void)v32;
          if (v37 + 8 * ((int)v31 - (int)v32) <= 31)
          {
            exception = __cxa_allocate_exception(8uLL);
            unint64_t v119 = "Cannot read pSD.hoaRotation.pitch";
            goto LABEL_180;
          }
          *(_DWORD *)(a3 + 28) = v37 - 32;
          if (v37 - 32 < 0)
          {
            int v65 = v57 & ~(v57 >> 63);
            unint64_t v66 = *(void *)(a3 + 8);
            if ((v65 & 0xFFFFFFFC) != 0 && v66 <= (unint64_t)v32)
            {
              unsigned int v67 = bswap32(*v32);
            }
            else
            {
              uint64_t v98 = 0;
              unsigned int v67 = v38;
              do
              {
                int v99 = (unsigned __int8 *)v32 + v98;
                unsigned int v100 = v67 << 8;
                *(_DWORD *)(a3 + 24) = v100;
                int v101 = 255;
                if ((unint64_t)v32 + v98 < v31 && (unint64_t)v99 >= v66) {
                  int v101 = *v99;
                }
                unsigned int v67 = v101 | v100;
                *(_DWORD *)(a3 + 24) = v67;
                ++v98;
              }
              while (v98 != 4);
            }
            *(void *)a3 = ++v32;
            int v59 = (v67 >> v37) | v38;
            unsigned int v38 = v67 << -(char)v37;
            if (!v37) {
              unsigned int v38 = 0;
            }
            *(_DWORD *)(a3 + 24) = v38;
            *(_DWORD *)(a3 + 28) = v37;
            uint64_t v57 = v31 - (void)v32;
            int v58 = 8 * (v31 - v32);
          }
          else
          {
            int v58 = 8 * v57;
            v37 -= 32;
            int v59 = v38;
          }
          *(_DWORD *)(a2 + 40) = v59;
          if (v58 + v37 <= 31)
          {
            exception = __cxa_allocate_exception(8uLL);
            unint64_t v119 = "Cannot read pSD.hoaRotation.yaw";
            goto LABEL_180;
          }
          *(_DWORD *)(a3 + 28) = v37 - 32;
          if (v37 - 32 < 0)
          {
            int v103 = v57 & ~(v57 >> 63);
            unint64_t v104 = *(void *)(a3 + 8);
            if ((v103 & 0xFFFFFFFC) != 0 && v104 <= (unint64_t)v32)
            {
              unsigned int v105 = bswap32(*v32);
            }
            else
            {
              uint64_t v106 = 0;
              unsigned int v105 = v38;
              do
              {
                int v107 = (unsigned __int8 *)v32 + v106;
                unsigned int v108 = v105 << 8;
                *(_DWORD *)(a3 + 24) = v108;
                int v109 = 255;
                if ((unint64_t)v32 + v106 < v31 && (unint64_t)v107 >= v104) {
                  int v109 = *v107;
                }
                unsigned int v105 = v109 | v108;
                *(_DWORD *)(a3 + 24) = v105;
                ++v106;
              }
              while (v106 != 4);
            }
            *(void *)a3 = ++v32;
            int v102 = (v105 >> v37) | v38;
            unsigned int v38 = v105 << -(char)v37;
            if (!v37) {
              unsigned int v38 = 0;
            }
            *(_DWORD *)(a3 + 24) = v38;
            *(_DWORD *)(a3 + 28) = v37;
            uint64_t v57 = v31 - (void)v32;
            int v58 = 8 * (v31 - v32);
          }
          else
          {
            v37 -= 32;
            int v102 = v38;
          }
          *(_DWORD *)(a2 + 44) = v102;
          if (v58 + v37 <= 31)
          {
            exception = __cxa_allocate_exception(8uLL);
            unint64_t v119 = "Cannot read pSD.hoaRotation.roll";
            goto LABEL_180;
          }
          *(_DWORD *)(a3 + 28) = v37 - 32;
          if (v37 - 32 < 0)
          {
            int v110 = v57 & ~(v57 >> 63);
            unint64_t v111 = *(void *)(a3 + 8);
            if ((v110 & 0xFFFFFFFC) != 0 && v111 <= (unint64_t)v32)
            {
              unsigned int v112 = bswap32(*v32);
            }
            else
            {
              uint64_t v113 = 0;
              unsigned int v112 = v38;
              do
              {
                unsigned int v114 = (unsigned __int8 *)v32 + v113;
                unsigned int v115 = v112 << 8;
                *(_DWORD *)(a3 + 24) = v115;
                int v116 = 255;
                if ((unint64_t)v32 + v113 < v31 && (unint64_t)v114 >= v111) {
                  int v116 = *v114;
                }
                unsigned int v112 = v116 | v115;
                *(_DWORD *)(a3 + 24) = v112;
                ++v113;
              }
              while (v113 != 4);
            }
            *(void *)a3 = v32 + 1;
            v38 |= v112 >> v37;
            unsigned int v117 = v112 << -(char)v37;
            if (!v37) {
              unsigned int v117 = 0;
            }
            *(_DWORD *)(a3 + 24) = v117;
            *(_DWORD *)(a3 + 28) = v37;
          }
          *(_DWORD *)(a2 + 48) = v38;
LABEL_177:
          if (++v30 >= (unint64_t)*(unsigned __int8 *)(a2 + 1)) {
            return;
          }
          break;
        default:
          goto LABEL_177;
      }
    }
  }
}

void APAC::MetadataBitStreamParser::parseDolbyStaticData(uint64_t a1, BOOL *a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 16);
  unint64_t v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v29 = "Cannot read pDolby.hasData";
    goto LABEL_39;
  }
  unsigned int v7 = *(_DWORD *)(a3 + 24);
  unsigned int v8 = v7 >> 31;
  int v9 = v6 - 1;
  *(_DWORD *)(a3 + 28) = v6 - 1;
  if (v6 - 1 < 0)
  {
    unint64_t v11 = *(void *)(a3 + 8);
    if ((v5 & ~(v5 >> 63) & 0xFFFFFFFC) == 0 || v11 > (unint64_t)v4)
    {
      uint64_t v13 = 0;
      do
      {
        BOOL v14 = (unsigned __int8 *)v4 + v13;
        unsigned int v15 = v7 << 8;
        *(_DWORD *)(a3 + 24) = v15;
        int v16 = 255;
        if ((unint64_t)v4 + v13 < v3 && (unint64_t)v14 >= v11) {
          int v16 = *v14;
        }
        unsigned int v7 = v16 | v15;
        *(_DWORD *)(a3 + 24) = v7;
        ++v13;
      }
      while (v13 != 4);
    }
    else
    {
      unsigned int v7 = bswap32(*v4);
    }
    int v18 = v6 + 31;
    BOOL v17 = v6 == -31;
    *(_DWORD *)(a3 + 28) = v6 + 31;
    *(void *)a3 = ++v4;
    v8 |= v7 >> (v6 + 31);
    if (v6 == -31) {
      unsigned int v10 = 0;
    }
    else {
      unsigned int v10 = v7 << (1 - v6);
    }
    if (v17) {
      int v9 = 0;
    }
    else {
      int v9 = v18;
    }
  }
  else
  {
    unsigned int v10 = 2 * v7;
  }
  *(_DWORD *)(a3 + 24) = v10;
  *a2 = v8 != 0;
  if (v8)
  {
    if (v9 + 8 * ((int)v3 - (int)v4) > 1)
    {
      unsigned int v19 = v10 >> 30;
      *(_DWORD *)(a3 + 28) = v9 - 2;
      if (v9 - 2 < 0)
      {
        unint64_t v21 = *(void *)(a3 + 8);
        if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
          && v21 <= (unint64_t)v4)
        {
          unsigned int v10 = bswap32(*v4);
        }
        else
        {
          uint64_t v22 = 0;
          do
          {
            unint64_t v23 = (unsigned __int8 *)v4 + v22;
            unsigned int v24 = v10 << 8;
            *(_DWORD *)(a3 + 24) = v24;
            int v25 = 255;
            if ((unint64_t)v4 + v22 < v3 && (unint64_t)v23 >= v21) {
              int v25 = *v23;
            }
            unsigned int v10 = v25 | v24;
            *(_DWORD *)(a3 + 24) = v10;
            ++v22;
          }
          while (v22 != 4);
        }
        int v26 = v10 << (2 - v9);
        int v27 = v9 + 30;
        *(_DWORD *)(a3 + 28) = v27;
        *(void *)a3 = v4 + 1;
        v19 |= v10 >> v27;
        if (v27) {
          int v20 = v26;
        }
        else {
          int v20 = 0;
        }
      }
      else
      {
        int v20 = 4 * v10;
      }
      *(_DWORD *)(a3 + 24) = v20;
      a2[1] = v19;
      return;
    }
    exception = __cxa_allocate_exception(8uLL);
    int v29 = "Cannot read pDolby.headphoneRenderingData";
LABEL_39:
    void *exception = v29;
    __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
  }
}

void APAC::MetadataBitStreamParser::parseRadiationPattern(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 16);
  unint64_t v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    unint64_t v39 = "Cannot read rP.isPHASE";
    goto LABEL_58;
  }
  unsigned int v7 = *(_DWORD *)(a3 + 24);
  unsigned int v8 = v7 >> 31;
  int v9 = v6 - 1;
  *(_DWORD *)(a3 + 28) = v6 - 1;
  if (v6 - 1 < 0)
  {
    unint64_t v11 = *(void *)(a3 + 8);
    if ((v5 & ~(v5 >> 63) & 0xFFFFFFFC) == 0 || v11 > (unint64_t)v4)
    {
      uint64_t v13 = 0;
      do
      {
        BOOL v14 = (unsigned __int8 *)v4 + v13;
        unsigned int v15 = v7 << 8;
        *(_DWORD *)(a3 + 24) = v15;
        int v16 = 255;
        if ((unint64_t)v4 + v13 < v3 && (unint64_t)v14 >= v11) {
          int v16 = *v14;
        }
        unsigned int v7 = v16 | v15;
        *(_DWORD *)(a3 + 24) = v7;
        ++v13;
      }
      while (v13 != 4);
    }
    else
    {
      unsigned int v7 = bswap32(*v4);
    }
    unsigned int v17 = v7 << (1 - v6);
    int v18 = v6 + 31;
    *(_DWORD *)(a3 + 28) = v18;
    *(void *)a3 = ++v4;
    v8 |= v7 >> v18;
    if (v18) {
      unsigned int v10 = v17;
    }
    else {
      unsigned int v10 = 0;
    }
    if (v18) {
      int v9 = v18;
    }
    else {
      int v9 = 0;
    }
  }
  else
  {
    unsigned int v10 = 2 * v7;
  }
  *(_DWORD *)(a3 + 24) = v10;
  *(unsigned char *)a2 = v8 != 0;
  if (!v8)
  {
    if (v9 + 8 * ((int)v3 - (int)v4) <= 2)
    {
      exception = __cxa_allocate_exception(8uLL);
      unint64_t v39 = "Cannot read rP.AuSMProcIndex";
      goto LABEL_58;
    }
    unsigned int v19 = v10 >> 29;
    int v20 = v9 - 3;
    *(_DWORD *)(a3 + 28) = v9 - 3;
    if (v9 - 3 < 0)
    {
      unint64_t v22 = *(void *)(a3 + 8);
      if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
        && v22 <= (unint64_t)v4)
      {
        unsigned int v10 = bswap32(*v4);
      }
      else
      {
        uint64_t v23 = 0;
        do
        {
          unsigned int v24 = (unsigned __int8 *)v4 + v23;
          unsigned int v25 = v10 << 8;
          *(_DWORD *)(a3 + 24) = v25;
          int v26 = 255;
          if ((unint64_t)v4 + v23 < v3 && (unint64_t)v24 >= v22) {
            int v26 = *v24;
          }
          unsigned int v10 = v26 | v25;
          *(_DWORD *)(a3 + 24) = v10;
          ++v23;
        }
        while (v23 != 4);
      }
      unsigned int v27 = v10 << (3 - v9);
      int v28 = v9 + 29;
      *(_DWORD *)(a3 + 28) = v28;
      *(void *)a3 = ++v4;
      v19 |= v10 >> v28;
      if (v28) {
        unsigned int v21 = v27;
      }
      else {
        unsigned int v21 = 0;
      }
      if (v28) {
        int v20 = v28;
      }
      else {
        int v20 = 0;
      }
    }
    else
    {
      unsigned int v21 = 8 * v10;
    }
    *(_DWORD *)(a3 + 24) = v21;
    *(unsigned char *)(a2 + 1) = v19;
    if (v19 == 1)
    {
      if (v20 + 8 * ((int)v3 - (int)v4) > 9)
      {
        unsigned int v29 = v21 >> 22;
        *(_DWORD *)(a3 + 28) = v20 - 10;
        if (v20 - 10 < 0)
        {
          unint64_t v31 = *(void *)(a3 + 8);
          if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
            && v31 <= (unint64_t)v4)
          {
            unsigned int v21 = bswap32(*v4);
          }
          else
          {
            uint64_t v32 = 0;
            do
            {
              uint64_t v33 = (unsigned __int8 *)v4 + v32;
              unsigned int v34 = v21 << 8;
              *(_DWORD *)(a3 + 24) = v34;
              int v35 = 255;
              if ((unint64_t)v4 + v32 < v3 && (unint64_t)v33 >= v31) {
                int v35 = *v33;
              }
              unsigned int v21 = v35 | v34;
              *(_DWORD *)(a3 + 24) = v21;
              ++v32;
            }
            while (v32 != 4);
          }
          unsigned int v36 = v21 << (10 - v20);
          int v37 = v20 + 22;
          *(_DWORD *)(a3 + 28) = v37;
          *(void *)a3 = v4 + 1;
          v29 |= v21 >> v37;
          if (v37) {
            unsigned int v30 = v36;
          }
          else {
            unsigned int v30 = 0;
          }
        }
        else
        {
          unsigned int v30 = v21 << 10;
        }
        *(_DWORD *)(a3 + 24) = v30;
        *(_WORD *)(a2 + 2) = v29;
        return;
      }
      exception = __cxa_allocate_exception(8uLL);
      unint64_t v39 = "Cannot read rP.sourceType";
LABEL_58:
      void *exception = v39;
      __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
    }
  }
}

void APAC::MetadataBitStreamParser::parseStaticGroup(uint64_t a1, unsigned char *a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 16);
  unint64_t v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 6)
  {
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v68 = "Cannot read sG.groupID";
    goto LABEL_117;
  }
  unsigned int v7 = *(_DWORD *)(a3 + 24);
  unsigned int v8 = v7 >> 25;
  int v9 = v6 - 7;
  *(_DWORD *)(a3 + 28) = v6 - 7;
  if (v6 - 7 < 0)
  {
    unint64_t v11 = *(void *)(a3 + 8);
    if ((v5 & ~(v5 >> 63) & 0xFFFFFFFC) == 0 || v11 > (unint64_t)v4)
    {
      uint64_t v13 = 0;
      do
      {
        BOOL v14 = (unsigned __int8 *)v4 + v13;
        unsigned int v15 = v7 << 8;
        *(_DWORD *)(a3 + 24) = v15;
        int v16 = 255;
        if ((unint64_t)v4 + v13 < v3 && (unint64_t)v14 >= v11) {
          int v16 = *v14;
        }
        unsigned int v7 = v16 | v15;
        *(_DWORD *)(a3 + 24) = v7;
        ++v13;
      }
      while (v13 != 4);
    }
    else
    {
      unsigned int v7 = bswap32(*v4);
    }
    unsigned int v17 = v7 << (7 - v6);
    int v18 = v6 + 25;
    *(_DWORD *)(a3 + 28) = v18;
    *(void *)a3 = ++v4;
    v8 |= v7 >> v18;
    if (v18) {
      unsigned int v10 = v17;
    }
    else {
      unsigned int v10 = 0;
    }
    if (v18) {
      int v9 = v18;
    }
    else {
      int v9 = 0;
    }
  }
  else
  {
    unsigned int v10 = v7 << 7;
  }
  *(_DWORD *)(a3 + 24) = v10;
  *a2 = v8;
  if (v9 + 8 * ((int)v3 - (int)v4) <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    uint64_t v68 = "Cannot read sG.isGlobal";
    goto LABEL_117;
  }
  unsigned int v19 = v10 >> 31;
  int v20 = v9 - 1;
  *(_DWORD *)(a3 + 28) = v9 - 1;
  if (v9 - 1 < 0)
  {
    unint64_t v22 = *(void *)(a3 + 8);
    if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
      && v22 <= (unint64_t)v4)
    {
      unsigned int v10 = bswap32(*v4);
    }
    else
    {
      uint64_t v23 = 0;
      do
      {
        unsigned int v24 = (unsigned __int8 *)v4 + v23;
        unsigned int v25 = v10 << 8;
        *(_DWORD *)(a3 + 24) = v25;
        int v26 = 255;
        if ((unint64_t)v4 + v23 < v3 && (unint64_t)v24 >= v22) {
          int v26 = *v24;
        }
        unsigned int v10 = v26 | v25;
        *(_DWORD *)(a3 + 24) = v10;
        ++v23;
      }
      while (v23 != 4);
    }
    unsigned int v27 = v10 << (1 - v9);
    int v28 = v9 + 31;
    *(_DWORD *)(a3 + 28) = v28;
    *(void *)a3 = ++v4;
    v19 |= v10 >> v28;
    if (v28) {
      unsigned int v21 = v27;
    }
    else {
      unsigned int v21 = 0;
    }
    if (v28) {
      int v20 = v28;
    }
    else {
      int v20 = 0;
    }
  }
  else
  {
    unsigned int v21 = 2 * v10;
  }
  *(_DWORD *)(a3 + 24) = v21;
  a2[1] = v19 != 0;
  if (!v19)
  {
    if (v20 + 8 * ((int)v3 - (int)v4) <= 6)
    {
      exception = __cxa_allocate_exception(8uLL);
      uint64_t v68 = "Cannot read sG.memberCount";
    }
    else
    {
      unsigned int v29 = v21 >> 25;
      int v30 = v20 - 7;
      *(_DWORD *)(a3 + 28) = v20 - 7;
      if (v20 - 7 < 0)
      {
        unint64_t v32 = *(void *)(a3 + 8);
        if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
          && v32 <= (unint64_t)v4)
        {
          unsigned int v21 = bswap32(*v4);
        }
        else
        {
          uint64_t v33 = 0;
          do
          {
            unsigned int v34 = (unsigned __int8 *)v4 + v33;
            unsigned int v35 = v21 << 8;
            *(_DWORD *)(a3 + 24) = v35;
            int v36 = 255;
            if ((unint64_t)v4 + v33 < v3 && (unint64_t)v34 >= v32) {
              int v36 = *v34;
            }
            unsigned int v21 = v36 | v35;
            *(_DWORD *)(a3 + 24) = v21;
            ++v33;
          }
          while (v33 != 4);
        }
        unsigned int v37 = v21 << (7 - v20);
        int v38 = v20 + 25;
        *(_DWORD *)(a3 + 28) = v38;
        *(void *)a3 = ++v4;
        v29 |= v21 >> v38;
        if (v38) {
          unsigned int v31 = v37;
        }
        else {
          unsigned int v31 = 0;
        }
        if (v38) {
          int v30 = v38;
        }
        else {
          int v30 = 0;
        }
      }
      else
      {
        unsigned int v31 = v21 << 7;
      }
      *(_DWORD *)(a3 + 24) = v31;
      a2[2] = v29;
      if (v30 + 8 * ((int)v3 - (int)v4) <= 0)
      {
        exception = __cxa_allocate_exception(8uLL);
        uint64_t v68 = "Cannot read sG.hasConjunctMembers";
      }
      else
      {
        unsigned int v39 = v31 >> 31;
        int v40 = v30 - 1;
        *(_DWORD *)(a3 + 28) = v30 - 1;
        if (v30 - 1 < 0)
        {
          unint64_t v42 = *(void *)(a3 + 8);
          if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
            && v42 <= (unint64_t)v4)
          {
            unsigned int v31 = bswap32(*v4);
          }
          else
          {
            uint64_t v43 = 0;
            do
            {
              int v44 = (unsigned __int8 *)v4 + v43;
              unsigned int v45 = v31 << 8;
              *(_DWORD *)(a3 + 24) = v45;
              int v46 = 255;
              if ((unint64_t)v4 + v43 < v3 && (unint64_t)v44 >= v42) {
                int v46 = *v44;
              }
              unsigned int v31 = v46 | v45;
              *(_DWORD *)(a3 + 24) = v31;
              ++v43;
            }
            while (v43 != 4);
          }
          int v48 = v30 + 31;
          BOOL v47 = v30 == -31;
          *(_DWORD *)(a3 + 28) = v30 + 31;
          *(void *)a3 = ++v4;
          v39 |= v31 >> (v30 + 31);
          if (v30 == -31) {
            unsigned int v41 = 0;
          }
          else {
            unsigned int v41 = v31 << (1 - v30);
          }
          if (v47) {
            int v40 = 0;
          }
          else {
            int v40 = v48;
          }
        }
        else
        {
          unsigned int v41 = 2 * v31;
        }
        *(_DWORD *)(a3 + 24) = v41;
        a2[3] = v39 != 0;
        if (v39)
        {
          if (v40 + 8 * ((int)v3 - (int)v4) > 6)
          {
            unsigned int v49 = v41 >> 25;
            *(_DWORD *)(a3 + 28) = v40 - 7;
            if (v40 - 7 < 0)
            {
              unint64_t v59 = *(void *)(a3 + 8);
              if (((v3 - v4) & ~((uint64_t)(v3 - (void)v4) >> 63) & 0xFFFFFFFC) != 0
                && v59 <= (unint64_t)v4)
              {
                unsigned int v41 = bswap32(*v4);
              }
              else
              {
                uint64_t v60 = 0;
                do
                {
                  unint64_t v61 = (unsigned __int8 *)v4 + v60;
                  unsigned int v62 = v41 << 8;
                  *(_DWORD *)(a3 + 24) = v62;
                  int v63 = 255;
                  if ((unint64_t)v4 + v60 < v3 && (unint64_t)v61 >= v59) {
                    int v63 = *v61;
                  }
                  unsigned int v41 = v63 | v62;
                  *(_DWORD *)(a3 + 24) = v41;
                  ++v60;
                }
                while (v60 != 4);
              }
              unsigned int v64 = v41 << (7 - v40);
              int v65 = v40 + 25;
              *(_DWORD *)(a3 + 28) = v65;
              *(void *)a3 = v4 + 1;
              v49 |= v41 >> v65;
              if (v65) {
                unsigned int v50 = v64;
              }
              else {
                unsigned int v50 = 0;
              }
            }
            else
            {
              unsigned int v50 = v41 << 7;
            }
            *(_DWORD *)(a3 + 24) = v50;
            a2[4] = v49;
            goto LABEL_108;
          }
          exception = __cxa_allocate_exception(8uLL);
          uint64_t v68 = "Cannot read sG.startASCID";
        }
        else
        {
          if (!(_BYTE)v29) {
            goto LABEL_108;
          }
          uint64_t v51 = 0;
          unint64_t v52 = *(void *)(a3 + 8);
          while (1)
          {
            uint64_t v53 = v3 - (void)v4;
            if (v40 + 8 * ((int)v3 - (int)v4) <= 6) {
              break;
            }
            unsigned int v54 = v41 >> 25;
            a1 = (v40 - 7);
            *(_DWORD *)(a3 + 28) = a1;
            if (v40 - 7 < 0)
            {
              a1 = v53 >> 63;
              if ((v53 & ~(v53 >> 63) & 0xFFFFFFFC) != 0 && v52 <= (unint64_t)v4)
              {
                unsigned int v41 = bswap32(*v4);
              }
              else
              {
                uint64_t v55 = 0;
                do
                {
                  int v56 = (unsigned __int8 *)v4 + v55;
                  unsigned int v57 = v41 << 8;
                  *(_DWORD *)(a3 + 24) = v57;
                  a1 = 255;
                  if ((unint64_t)v4 + v55 < v3 && (unint64_t)v56 >= v52) {
                    a1 = *v56;
                  }
                  unsigned int v41 = a1 | v57;
                  *(_DWORD *)(a3 + 24) = v41;
                  ++v55;
                }
                while (v55 != 4);
              }
              unsigned int v58 = v41 << (7 - v40);
              v40 += 25;
              *(_DWORD *)(a3 + 28) = v40;
              *(void *)a3 = ++v4;
              v54 |= v41 >> v40;
              if (v40) {
                unsigned int v41 = v58;
              }
              else {
                unsigned int v41 = 0;
              }
              if (!v40) {
                int v40 = 0;
              }
            }
            else
            {
              v41 <<= 7;
              v40 -= 7;
            }
            *(_DWORD *)(a3 + 24) = v41;
            a2[v51++ + 5] = v54;
            if (v51 == v29) {
              goto LABEL_108;
            }
          }
          exception = __cxa_allocate_exception(8uLL);
          uint64_t v68 = "Cannot read sG.ASCIDList[m]";
        }
      }
    }
LABEL_117:
    void *exception = v68;
    __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
  }
LABEL_108:
  uint64_t v66 = (uint64_t)(a2 + 132);
  APAC::MetadataBitStreamParser::parseProprietaryStaticData(a1, v66, a3);
}

void APAC::MetadataBitStreamParser::parseScreenData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 16);
  unint64_t v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v135 = "Cannot read sD.hasData";
    goto LABEL_171;
  }
  unsigned int v7 = *(_DWORD *)(a3 + 24);
  unsigned int v8 = v7 >> 31;
  int v9 = v6 - 1;
  *(_DWORD *)(a3 + 28) = v6 - 1;
  if (v6 - 1 < 0)
  {
    unint64_t v11 = *(void *)(a3 + 8);
    if ((v5 & ~(v5 >> 63) & 0xFFFFFFFC) == 0 || v11 > (unint64_t)v4)
    {
      uint64_t v13 = 0;
      do
      {
        BOOL v14 = (unsigned __int8 *)v4 + v13;
        unsigned int v15 = v7 << 8;
        *(_DWORD *)(a3 + 24) = v15;
        int v16 = 255;
        if ((unint64_t)v4 + v13 < v3 && (unint64_t)v14 >= v11) {
          int v16 = *v14;
        }
        unsigned int v7 = v16 | v15;
        *(_DWORD *)(a3 + 24) = v7;
        ++v13;
      }
      while (v13 != 4);
    }
    else
    {
      unsigned int v7 = bswap32(*v4);
    }
    int v18 = v6 + 31;
    BOOL v17 = v6 == -31;
    *(_DWORD *)(a3 + 28) = v6 + 31;
    *(void *)a3 = ++v4;
    v8 |= v7 >> (v6 + 31);
    if (v6 == -31) {
      unsigned int v10 = 0;
    }
    else {
      unsigned int v10 = v7 << (1 - v6);
    }
    if (v17) {
      int v9 = 0;
    }
    else {
      int v9 = v18;
    }
  }
  else
  {
    unsigned int v10 = 2 * v7;
  }
  *(_DWORD *)(a3 + 24) = v10;
  *(unsigned char *)a2 = v8 != 0;
  if (v8)
  {
    uint64_t v19 = v3 - (void)v4;
    if (v9 + 8 * ((int)v3 - (int)v4) <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      int v135 = "Cannot read sD.aspectRatio";
      goto LABEL_171;
    }
    *(_DWORD *)(a3 + 28) = v9 - 32;
    if (v9 - 32 < 0)
    {
      unint64_t v22 = *(void *)(a3 + 8);
      if ((v19 & ~(v19 >> 63) & 0xFFFFFFFC) != 0 && v22 <= (unint64_t)v4)
      {
        unsigned int v23 = bswap32(*v4);
      }
      else
      {
        uint64_t v24 = 0;
        unsigned int v23 = v10;
        do
        {
          unsigned int v25 = (unsigned __int8 *)v4 + v24;
          unsigned int v26 = v23 << 8;
          *(_DWORD *)(a3 + 24) = v26;
          int v27 = 255;
          if ((unint64_t)v4 + v24 < v3 && (unint64_t)v25 >= v22) {
            int v27 = *v25;
          }
          unsigned int v23 = v27 | v26;
          *(_DWORD *)(a3 + 24) = v23;
          ++v24;
        }
        while (v24 != 4);
      }
      *(void *)a3 = ++v4;
      int v21 = (v23 >> v9) | v10;
      unsigned int v10 = v23 << -(char)v9;
      if (!v9) {
        unsigned int v10 = 0;
      }
      *(_DWORD *)(a3 + 24) = v10;
      *(_DWORD *)(a3 + 28) = v9;
      uint64_t v19 = v3 - (void)v4;
      int v20 = 8 * (v3 - v4);
    }
    else
    {
      int v20 = 8 * v19;
      v9 -= 32;
      int v21 = v10;
    }
    *(_DWORD *)(a2 + 4) = v21;
    if ((v20 + v9 < 0) ^ __OFADD__(v20, v9) | (v20 + v9 == 0))
    {
      exception = __cxa_allocate_exception(8uLL);
      int v135 = "Cannot read sD.cartesian";
      goto LABEL_171;
    }
    unsigned int v28 = v10 >> 31;
    int v29 = v9 - 1;
    *(_DWORD *)(a3 + 28) = v9 - 1;
    if (v9 - 1 < 0)
    {
      unint64_t v31 = *(void *)(a3 + 8);
      if ((v19 & ~(v19 >> 63) & 0xFFFFFFFC) != 0 && v31 <= (unint64_t)v4)
      {
        unsigned int v10 = bswap32(*v4);
      }
      else
      {
        uint64_t v32 = 0;
        do
        {
          uint64_t v33 = (unsigned __int8 *)v4 + v32;
          unsigned int v34 = v10 << 8;
          *(_DWORD *)(a3 + 24) = v34;
          int v35 = 255;
          if ((unint64_t)v4 + v32 < v3 && (unint64_t)v33 >= v31) {
            int v35 = *v33;
          }
          unsigned int v10 = v35 | v34;
          *(_DWORD *)(a3 + 24) = v10;
          ++v32;
        }
        while (v32 != 4);
      }
      int v37 = v9 + 31;
      BOOL v36 = v9 == -31;
      *(_DWORD *)(a3 + 28) = v9 + 31;
      *(void *)a3 = ++v4;
      v28 |= v10 >> (v9 + 31);
      if (v9 == -31) {
        int v30 = 0;
      }
      else {
        int v30 = v10 << (1 - v9);
      }
      if (v36) {
        int v29 = 0;
      }
      else {
        int v29 = v37;
      }
    }
    else
    {
      int v30 = 2 * v10;
    }
    *(_DWORD *)(a3 + 24) = v30;
    *(unsigned char *)(a2 + 1) = v28 != 0;
    uint64_t v38 = v3 - (void)v4;
    int v39 = v29 + 8 * (v3 - v4);
    if (v28)
    {
      if (v39 <= 31)
      {
        exception = __cxa_allocate_exception(8uLL);
        int v135 = "Cannot read sD.screenCentrePosition.co_ut.cartesian.X";
      }
      else
      {
        *(_DWORD *)(a3 + 28) = v29 - 32;
        if (v29 - 32 < 0)
        {
          int v40 = v38 & ~(v38 >> 63);
          unint64_t v41 = *(void *)(a3 + 8);
          if ((v40 & 0xFFFFFFFC) != 0 && v41 <= (unint64_t)v4)
          {
            unsigned int v42 = bswap32(*v4);
          }
          else
          {
            uint64_t v46 = 0;
            unsigned int v42 = v30;
            do
            {
              BOOL v47 = (unsigned __int8 *)v4 + v46;
              unsigned int v48 = v42 << 8;
              *(_DWORD *)(a3 + 24) = v48;
              int v49 = 255;
              if ((unint64_t)v4 + v46 < v3 && (unint64_t)v47 >= v41) {
                int v49 = *v47;
              }
              unsigned int v42 = v49 | v48;
              *(_DWORD *)(a3 + 24) = v42;
              ++v46;
            }
            while (v46 != 4);
          }
          *(void *)a3 = v4 + 1;
          v30 |= v42 >> v29;
          unsigned int v50 = v42 << -(char)v29;
          if (!v29) {
            unsigned int v50 = 0;
          }
          *(_DWORD *)(a3 + 24) = v50;
          *(_DWORD *)(a3 + 28) = v29;
        }
        *(_DWORD *)(a2 + 8) = v30;
        unint64_t v51 = *(void *)(a3 + 16);
        unint64_t v52 = *(unsigned int **)a3;
        uint64_t v53 = v51 - *(void *)a3;
        int v54 = *(_DWORD *)(a3 + 28);
        if (v54 + 8 * (int)v53 <= 31)
        {
          exception = __cxa_allocate_exception(8uLL);
          int v135 = "Cannot read sD.screenCentrePosition.co_ut.cartesian.Y";
        }
        else
        {
          unsigned int v55 = *(_DWORD *)(a3 + 24);
          *(_DWORD *)(a3 + 28) = v54 - 32;
          if (v54 - 32 < 0)
          {
            int v56 = v53 & ~(v53 >> 63);
            unint64_t v57 = *(void *)(a3 + 8);
            if ((v56 & 0xFFFFFFFC) != 0 && v57 <= (unint64_t)v52)
            {
              unsigned int v58 = bswap32(*v52);
            }
            else
            {
              uint64_t v59 = 0;
              unsigned int v58 = v55;
              do
              {
                uint64_t v60 = (unsigned __int8 *)v52 + v59;
                unsigned int v61 = v58 << 8;
                *(_DWORD *)(a3 + 24) = v61;
                int v62 = 255;
                if ((unint64_t)v52 + v59 < v51 && (unint64_t)v60 >= v57) {
                  int v62 = *v60;
                }
                unsigned int v58 = v62 | v61;
                *(_DWORD *)(a3 + 24) = v58;
                ++v59;
              }
              while (v59 != 4);
            }
            *(void *)a3 = v52 + 1;
            v55 |= v58 >> v54;
            unsigned int v63 = v58 << -(char)v54;
            if (!v54) {
              unsigned int v63 = 0;
            }
            *(_DWORD *)(a3 + 24) = v63;
            *(_DWORD *)(a3 + 28) = v54;
          }
          *(_DWORD *)(a2 + 12) = v55;
          unint64_t v64 = *(void *)(a3 + 16);
          int v65 = *(unsigned int **)a3;
          uint64_t v66 = v64 - *(void *)a3;
          int v67 = *(_DWORD *)(a3 + 28);
          if (v67 + 8 * (int)v66 <= 31)
          {
            exception = __cxa_allocate_exception(8uLL);
            int v135 = "Cannot read sD.screenCentrePosition.co_ut.cartesian.Z";
          }
          else
          {
            unsigned int v68 = *(_DWORD *)(a3 + 24);
            *(_DWORD *)(a3 + 28) = v67 - 32;
            if (v67 - 32 < 0)
            {
              int v69 = v66 & ~(v66 >> 63);
              unint64_t v70 = *(void *)(a3 + 8);
              if ((v69 & 0xFFFFFFFC) != 0 && v70 <= (unint64_t)v65)
              {
                unsigned int v71 = bswap32(*v65);
              }
              else
              {
                uint64_t v72 = 0;
                unsigned int v71 = v68;
                do
                {
                  int v73 = (unsigned __int8 *)v65 + v72;
                  unsigned int v74 = v71 << 8;
                  *(_DWORD *)(a3 + 24) = v74;
                  int v75 = 255;
                  if ((unint64_t)v65 + v72 < v64 && (unint64_t)v73 >= v70) {
                    int v75 = *v73;
                  }
                  unsigned int v71 = v75 | v74;
                  *(_DWORD *)(a3 + 24) = v71;
                  ++v72;
                }
                while (v72 != 4);
              }
              *(void *)a3 = v65 + 1;
              v68 |= v71 >> v67;
              unsigned int v76 = v71 << -(char)v67;
              if (!v67) {
                unsigned int v76 = 0;
              }
              *(_DWORD *)(a3 + 24) = v76;
              *(_DWORD *)(a3 + 28) = v67;
            }
            *(_DWORD *)(a2 + 16) = v68;
            unint64_t v77 = *(void *)(a3 + 16);
            int v78 = *(unsigned int **)a3;
            uint64_t v79 = v77 - *(void *)a3;
            int v80 = *(_DWORD *)(a3 + 28);
            if (v80 + 8 * (int)v79 > 31)
            {
              unsigned int v81 = *(_DWORD *)(a3 + 24);
              *(_DWORD *)(a3 + 28) = v80 - 32;
              if (v80 - 32 < 0)
              {
                int v82 = v79 & ~(v79 >> 63);
                unint64_t v83 = *(void *)(a3 + 8);
                if ((v82 & 0xFFFFFFFC) != 0 && v83 <= (unint64_t)v78)
                {
                  unsigned int v84 = bswap32(*v78);
                }
                else
                {
                  uint64_t v85 = 0;
                  unsigned int v84 = v81;
                  do
                  {
                    uint64_t v86 = (unsigned __int8 *)v78 + v85;
                    unsigned int v87 = v84 << 8;
                    *(_DWORD *)(a3 + 24) = v87;
                    int v88 = 255;
                    if ((unint64_t)v78 + v85 < v77 && (unint64_t)v86 >= v83) {
                      int v88 = *v86;
                    }
                    unsigned int v84 = v88 | v87;
                    *(_DWORD *)(a3 + 24) = v84;
                    ++v85;
                  }
                  while (v85 != 4);
                }
                *(void *)a3 = v78 + 1;
                v81 |= v84 >> v80;
                unsigned int v89 = v84 << -(char)v80;
                if (!v80) {
                  unsigned int v89 = 0;
                }
                *(_DWORD *)(a3 + 24) = v89;
                *(_DWORD *)(a3 + 28) = v80;
              }
              *(_DWORD *)(a2 + 20) = v81;
              return;
            }
            exception = __cxa_allocate_exception(8uLL);
            int v135 = "Cannot read sD.screenWidth.X";
          }
        }
      }
LABEL_171:
      void *exception = v135;
      __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
    }
    if (v39 <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      int v135 = "Cannot read sD.screenCentrePosition.co_ut.spherical.azimuth";
      goto LABEL_171;
    }
    *(_DWORD *)(a3 + 28) = v29 - 32;
    if (v29 - 32 < 0)
    {
      int v43 = v38 & ~(v38 >> 63);
      unint64_t v44 = *(void *)(a3 + 8);
      if ((v43 & 0xFFFFFFFC) != 0 && v44 <= (unint64_t)v4)
      {
        unsigned int v45 = bswap32(*v4);
      }
      else
      {
        uint64_t v90 = 0;
        unsigned int v45 = v30;
        do
        {
          int v91 = (unsigned __int8 *)v4 + v90;
          unsigned int v92 = v45 << 8;
          *(_DWORD *)(a3 + 24) = v92;
          int v93 = 255;
          if ((unint64_t)v4 + v90 < v3 && (unint64_t)v91 >= v44) {
            int v93 = *v91;
          }
          unsigned int v45 = v93 | v92;
          *(_DWORD *)(a3 + 24) = v45;
          ++v90;
        }
        while (v90 != 4);
      }
      *(void *)a3 = v4 + 1;
      v30 |= v45 >> v29;
      unsigned int v94 = v45 << -(char)v29;
      if (!v29) {
        unsigned int v94 = 0;
      }
      *(_DWORD *)(a3 + 24) = v94;
      *(_DWORD *)(a3 + 28) = v29;
    }
    *(_DWORD *)(a2 + 8) = v30;
    unint64_t v95 = *(void *)(a3 + 16);
    int v96 = *(unsigned int **)a3;
    uint64_t v97 = v95 - *(void *)a3;
    int v98 = *(_DWORD *)(a3 + 28);
    if (v98 + 8 * (int)v97 <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      int v135 = "Cannot read sD.screenCentrePosition.co_ut.spherical.elevation";
      goto LABEL_171;
    }
    unsigned int v99 = *(_DWORD *)(a3 + 24);
    *(_DWORD *)(a3 + 28) = v98 - 32;
    if (v98 - 32 < 0)
    {
      int v100 = v97 & ~(v97 >> 63);
      unint64_t v101 = *(void *)(a3 + 8);
      if ((v100 & 0xFFFFFFFC) != 0 && v101 <= (unint64_t)v96)
      {
        unsigned int v102 = bswap32(*v96);
      }
      else
      {
        uint64_t v103 = 0;
        unsigned int v102 = v99;
        do
        {
          unint64_t v104 = (unsigned __int8 *)v96 + v103;
          unsigned int v105 = v102 << 8;
          *(_DWORD *)(a3 + 24) = v105;
          int v106 = 255;
          if ((unint64_t)v96 + v103 < v95 && (unint64_t)v104 >= v101) {
            int v106 = *v104;
          }
          unsigned int v102 = v106 | v105;
          *(_DWORD *)(a3 + 24) = v102;
          ++v103;
        }
        while (v103 != 4);
      }
      *(void *)a3 = v96 + 1;
      v99 |= v102 >> v98;
      unsigned int v107 = v102 << -(char)v98;
      if (!v98) {
        unsigned int v107 = 0;
      }
      *(_DWORD *)(a3 + 24) = v107;
      *(_DWORD *)(a3 + 28) = v98;
    }
    *(_DWORD *)(a2 + 12) = v99;
    unint64_t v108 = *(void *)(a3 + 16);
    int v109 = *(unsigned int **)a3;
    uint64_t v110 = v108 - *(void *)a3;
    int v111 = *(_DWORD *)(a3 + 28);
    if (v111 + 8 * (int)v110 <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      int v135 = "Cannot read sD.screenCentrePosition.co_ut.spherical.distance";
      goto LABEL_171;
    }
    unsigned int v112 = *(_DWORD *)(a3 + 24);
    *(_DWORD *)(a3 + 28) = v111 - 32;
    if (v111 - 32 < 0)
    {
      int v113 = v110 & ~(v110 >> 63);
      unint64_t v114 = *(void *)(a3 + 8);
      if ((v113 & 0xFFFFFFFC) != 0 && v114 <= (unint64_t)v109)
      {
        unsigned int v115 = bswap32(*v109);
      }
      else
      {
        uint64_t v116 = 0;
        unsigned int v115 = v112;
        do
        {
          unsigned int v117 = (unsigned __int8 *)v109 + v116;
          unsigned int v118 = v115 << 8;
          *(_DWORD *)(a3 + 24) = v118;
          int v119 = 255;
          if ((unint64_t)v109 + v116 < v108 && (unint64_t)v117 >= v114) {
            int v119 = *v117;
          }
          unsigned int v115 = v119 | v118;
          *(_DWORD *)(a3 + 24) = v115;
          ++v116;
        }
        while (v116 != 4);
      }
      *(void *)a3 = v109 + 1;
      v112 |= v115 >> v111;
      unsigned int v120 = v115 << -(char)v111;
      if (!v111) {
        unsigned int v120 = 0;
      }
      *(_DWORD *)(a3 + 24) = v120;
      *(_DWORD *)(a3 + 28) = v111;
    }
    *(_DWORD *)(a2 + 16) = v112;
    unint64_t v121 = *(void *)(a3 + 16);
    unsigned int v122 = *(unsigned int **)a3;
    uint64_t v123 = v121 - *(void *)a3;
    int v124 = *(_DWORD *)(a3 + 28);
    if (v124 + 8 * (int)v123 <= 31)
    {
      exception = __cxa_allocate_exception(8uLL);
      int v135 = "Cannot read sD.screenWidth.azimuth";
      goto LABEL_171;
    }
    unsigned int v125 = *(_DWORD *)(a3 + 24);
    *(_DWORD *)(a3 + 28) = v124 - 32;
    if (v124 - 32 < 0)
    {
      int v126 = v123 & ~(v123 >> 63);
      unint64_t v127 = *(void *)(a3 + 8);
      if ((v126 & 0xFFFFFFFC) != 0 && v127 <= (unint64_t)v122)
      {
        unsigned int v128 = bswap32(*v122);
      }
      else
      {
        uint64_t v129 = 0;
        unsigned int v128 = v125;
        do
        {
          unint64_t v130 = (unsigned __int8 *)v122 + v129;
          unsigned int v131 = v128 << 8;
          *(_DWORD *)(a3 + 24) = v131;
          int v132 = 255;
          if ((unint64_t)v122 + v129 < v121 && (unint64_t)v130 >= v127) {
            int v132 = *v130;
          }
          unsigned int v128 = v132 | v131;
          *(_DWORD *)(a3 + 24) = v128;
          ++v129;
        }
        while (v129 != 4);
      }
      *(void *)a3 = v122 + 1;
      v125 |= v128 >> v124;
      unsigned int v133 = v128 << -(char)v124;
      if (!v124) {
        unsigned int v133 = 0;
      }
      *(_DWORD *)(a3 + 24) = v133;
      *(_DWORD *)(a3 + 28) = v124;
    }
    *(_DWORD *)(a2 + 24) = v125;
  }
}

void APAC::MetadataBitStreamParser::parseConfig(uint64_t a1, unsigned __int8 *a2, int a3, uint64_t a4)
{
  v9[0] = a2;
  v9[1] = a2;
  void v9[2] = &a2[a3];
  uint64_t v10 = 0;
  if ((a2 & 3) != 0)
  {
    int v4 = 0;
    uint64_t v5 = a2 + 1;
    int v6 = a2;
    do
    {
      if (v6 >= &a2[a3]) {
        int v7 = 255;
      }
      else {
        int v7 = *v6;
      }
      int v4 = v7 | (v4 << 8);
      ++v6;
    }
    while ((v5++ & 3) != 0);
    v9[0] = &a2[((a2 ^ 3) & 3) + 1];
    LODWORD(v10) = v4 << ((8 * ((a2 ^ 3) & 3)) ^ 0x18);
    HIDWORD(v10) = 8 * ((a2 ^ 3) & 3) + 8;
  }
  APAC::MetadataBitStreamParser::parseMetadataConfig(a1, a4, (uint64_t)v9);
}

void APAC::MetadataBitStreamParser::parseMetadataConfig(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 16);
  int v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = "Cannot read mdCfg.mRendererMetadataConfigPresent";
    __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
  }
  unsigned int v7 = *(_DWORD *)(a3 + 24);
  unsigned int v8 = v7 >> 31;
  *(_DWORD *)(a3 + 28) = v6 - 1;
  if (v6 - 1 < 0)
  {
    uint64_t v10 = v5 & ~(v5 >> 63) & 0xFFFFFFFC;
    unint64_t v11 = *(void *)(a3 + 8);
    if (v10) {
      BOOL v12 = v11 > (unint64_t)v4;
    }
    else {
      BOOL v12 = 1;
    }
    if (v12)
    {
      uint64_t v13 = 0;
      do
      {
        BOOL v14 = (unsigned __int8 *)v4 + v13;
        unsigned int v15 = v7 << 8;
        *(_DWORD *)(a3 + 24) = v15;
        int v16 = 255;
        if ((unint64_t)v4 + v13 < v3 && (unint64_t)v14 >= v11) {
          int v16 = *v14;
        }
        unsigned int v7 = v16 | v15;
        *(_DWORD *)(a3 + 24) = v7;
        ++v13;
      }
      while (v13 != 4);
    }
    else
    {
      unsigned int v7 = bswap32(*v4);
    }
    int v17 = v7 << (1 - v6);
    int v18 = v6 + 31;
    *(_DWORD *)(a3 + 28) = v18;
    *(void *)a3 = v4 + 1;
    v8 |= v7 >> v18;
    if (v18) {
      int v9 = v17;
    }
    else {
      int v9 = 0;
    }
  }
  else
  {
    int v9 = 2 * v7;
  }
  *(_DWORD *)(a3 + 24) = v9;
  *(unsigned char *)(a2 + 1) = v8 != 0;
  if (v8)
  {
    uint64_t v19 = a2 + 8;
    APAC::MetadataBitStreamParser::parseRendererMetadataConfig(a1, v19, a3);
  }
}

void APAC::MetadataBitStreamParser::parseRendererMetadataConfig(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 16);
  int v4 = *(unsigned int **)a3;
  uint64_t v5 = v3 - *(void *)a3;
  int v6 = *(_DWORD *)(a3 + 28);
  if (v6 + 8 * (int)v5 <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    int v100 = "Cannot read rMdCfg.mGlobalConfig.mHasData";
    goto LABEL_85;
  }
  unsigned int v9 = *(_DWORD *)(a3 + 24);
  unsigned int v10 = v9 >> 31;
  int v11 = v6 - 1;
  *(_DWORD *)(a3 + 28) = v6 - 1;
  if (v6 - 1 < 0)
  {
    unint64_t v13 = *(void *)(a3 + 8);
    if ((v5 & ~(v5 >> 63) & 0xFFFFFFFC) == 0 || v13 > (unint64_t)v4)
    {
      uint64_t v15 = 0;
      do
      {
        int v16 = (unsigned __int8 *)v4 + v15;
        unsigned int v17 = v9 << 8;
        *(_DWORD *)(a3 + 24) = v17;
        int v18 = 255;
        if ((unint64_t)v4 + v15 < v3 && (unint64_t)v16 >= v13) {
          int v18 = *v16;
        }
        unsigned int v9 = v18 | v17;
        *(_DWORD *)(a3 + 24) = v9;
        ++v15;
      }
      while (v15 != 4);
    }
    else
    {
      unsigned int v9 = bswap32(*v4);
    }
    unsigned int v19 = v9 << (1 - v6);
    int v20 = v6 + 31;
    *(_DWORD *)(a3 + 28) = v20;
    *(void *)a3 = v4 + 1;
    v10 |= v9 >> v20;
    if (v20) {
      unsigned int v12 = v19;
    }
    else {
      unsigned int v12 = 0;
    }
    if (v20) {
      int v11 = v20;
    }
    else {
      int v11 = 0;
    }
  }
  else
  {
    unsigned int v12 = 2 * v9;
  }
  *(_DWORD *)(a3 + 24) = v12;
  *(unsigned char *)(a2 + 8) = v10 != 0;
  uint64_t v21 = a2 + 8;
  if (v10)
  {
    APAC::MetadataBitStreamParser::parseGlobalConfig(a1, v21, 1, a3);
    unsigned int v12 = *(_DWORD *)(a3 + 24);
    int v11 = *(_DWORD *)(a3 + 28);
  }
  unsigned int v22 = v12 >> 21;
  *(_DWORD *)(a3 + 28) = v11 - 11;
  if (v11 - 11 < 0)
  {
    unint64_t v25 = *(void *)(a3 + 8);
    unint64_t v24 = *(void *)(a3 + 16);
    unsigned int v26 = *(unsigned int **)a3;
    if (((v24 - *(_DWORD *)a3) & ~((uint64_t)(v24 - *(void *)a3) >> 63) & 0xFFFFFFFC) != 0
      && v25 <= (unint64_t)v26)
    {
      unsigned int v12 = bswap32(*v26);
    }
    else
    {
      uint64_t v27 = 0;
      do
      {
        unsigned int v28 = (unsigned __int8 *)v26 + v27;
        unsigned int v29 = v12 << 8;
        *(_DWORD *)(a3 + 24) = v29;
        int v30 = 255;
        if ((unint64_t)v26 + v27 < v24 && (unint64_t)v28 >= v25) {
          int v30 = *v28;
        }
        unsigned int v12 = v30 | v29;
        *(_DWORD *)(a3 + 24) = v12;
        ++v27;
      }
      while (v27 != 4);
    }
    unsigned int v31 = v12 << (11 - v11);
    int v32 = v11 + 21;
    *(_DWORD *)(a3 + 28) = v32;
    *(void *)a3 = v26 + 1;
    v22 |= v12 >> v32;
    if (v32) {
      unsigned int v23 = v31;
    }
    else {
      unsigned int v23 = 0;
    }
  }
  else
  {
    unsigned int v23 = v12 << 11;
  }
  *(_DWORD *)(a3 + 24) = v23;
  *(_WORD *)a2 = v22;
  unint64_t v33 = (unsigned __int16)v22;
  std::vector<APAC::Metadata::GroupConfig>::resize(a2 + 4776, v33);
  uint64_t v35 = *(void *)(a2 + 4808);
  uint64_t v36 = *(void *)(a2 + 4800);
  unint64_t v37 = 0x6F96F96F96F96F97 * ((v35 - v36) >> 5);
  unint64_t v38 = v33 - v37;
  if (v33 <= v37)
  {
    if (v33 >= v37) {
      goto LABEL_62;
    }
    uint64_t v79 = v36 + 1248 * v33;
    while (v35 != v79)
    {
      v35 -= 1248;
      std::__destroy_at[abi:ne180100]<APAC::Metadata::RendererData,0>((void *)v35);
    }
    goto LABEL_59;
  }
  uint64_t v39 = *(void *)(a2 + 4816);
  if (0x6F96F96F96F96F97 * ((v39 - v35) >> 5) >= v38)
  {
    uint64_t v79 = v35 + 1248 * v38;
    do
    {
      bzero((void *)v35, 0x4C0uLL);
      *(unsigned char *)(v35 + 1046) = 1;
      uint64_t v80 = v35 + 1100;
      *(void *)(v35 + 1100) = 0;
      *(void *)(v35 + 1105) = 0;
      *(void *)(v35 + 1152) = 0;
      *(void *)(v35 + 1157) = 0;
      *(_OWORD *)(v35 + 1047) = 0u;
      *(_OWORD *)(v35 + 1063) = 0u;
      *(_OWORD *)(v35 + 1079) = 0u;
      *(_OWORD *)(v35 + 1216) = 0u;
      *(_OWORD *)(v35 + 1232) = 0u;
      v35 += 1248;
      *(_DWORD *)(v80 - 6) = 0;
    }
    while (v35 != v79);
LABEL_59:
    *(void *)(a2 + 4808) = v79;
    goto LABEL_62;
  }
  unint64_t v40 = 0x6F96F96F96F96F97 * ((v39 - v36) >> 5);
  uint64_t v41 = 2 * v40;
  if (2 * v40 <= v33) {
    uint64_t v41 = v33;
  }
  if (v40 >= 0x1A41A41A41A41ALL) {
    unint64_t v42 = 0x34834834834834;
  }
  else {
    unint64_t v42 = v41;
  }
  if (v42 > 0x34834834834834) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  int v43 = (char *)operator new(1248 * v42);
  unint64_t v44 = &v43[1248 * v37];
  unsigned int v45 = &v43[1248 * v33];
  uint64_t v46 = v44;
  do
  {
    bzero(v46, 0x4C0uLL);
    v46[1046] = 1;
    BOOL v47 = v46 + 1100;
    *(void *)(v46 + 1100) = 0;
    *(void *)(v46 + 1105) = 0;
    *((void *)v46 + 144) = 0;
    *(void *)(v46 + 1157) = 0;
    *(_OWORD *)(v46 + 1047) = 0u;
    *(_OWORD *)(v46 + 1063) = 0u;
    *(_OWORD *)(v46 + 1079) = 0u;
    *((_OWORD *)v46 + 76) = 0u;
    *((_OWORD *)v46 + 77) = 0u;
    v46 += 1248;
    *(_DWORD *)(v47 - 6) = 0;
  }
  while (v46 != v45);
  unsigned int v48 = &v43[1248 * v42];
  int v49 = *(void **)(a2 + 4808);
  unsigned int v50 = *(void **)(a2 + 4800);
  if (v49 == v50)
  {
    *(void *)(a2 + 4800) = v44;
    *(void *)(a2 + 4808) = v45;
    *(void *)(a2 + 4816) = v48;
    if (!v49) {
      goto LABEL_62;
    }
    goto LABEL_61;
  }
  unint64_t v101 = v48;
  unsigned int v102 = v44;
  uint64_t v51 = 0;
  do
  {
    unint64_t v52 = &v102[v51 * 8];
    uint64_t v53 = &v49[v51];
    unsigned int v34 = memcpy(&v102[v51 * 8 - 1248], &v49[v51 - 156], 0x314uLL);
    uint64_t v54 = (uint64_t)&v102[v51 * 8 - 456];
    uint64_t v55 = v49[v51 - 57];
    *(_DWORD *)(v54 + 8) = v49[v51 - 56];
    *(void *)uint64_t v54 = v55;
    uint64_t v56 = v49[v51 - 55];
    unint64_t v57 = &v102[v51 * 8 - 432];
    uint64_t v58 = (uint64_t)&v49[v51 - 54];
    *((void *)v57 + 1) = 0;
    *((void *)v57 + 2) = 0;
    *((void *)v52 - 55) = v56;
    *(void *)unint64_t v57 = 0;
    *(_OWORD *)unint64_t v57 = *(_OWORD *)v58;
    *((void *)v52 - 52) = v49[v51 - 52];
    *(v53 - 53) = 0;
    *(void *)uint64_t v58 = 0;
    uint64_t v59 = &v102[v51 * 8 - 408];
    uint64_t v60 = (uint64_t)&v49[v51 - 51];
    *(void *)(v58 + 16) = 0;
    *((void *)v59 + 2) = 0;
    *(void *)uint64_t v59 = 0;
    *((void *)v52 - 50) = 0;
    *(_OWORD *)uint64_t v59 = *(_OWORD *)v60;
    *((void *)v52 - 49) = v49[v51 - 49];
    *(v53 - 50) = 0;
    *(void *)uint64_t v60 = 0;
    *(void *)(v60 + 16) = 0;
    unsigned int v61 = &v102[v51 * 8 - 384];
    uint64_t v62 = (uint64_t)&v49[v51 - 48];
    *((void *)v61 + 2) = 0;
    *(void *)unsigned int v61 = 0;
    *((void *)v52 - 47) = 0;
    *(_OWORD *)unsigned int v61 = *(_OWORD *)v62;
    *((void *)v52 - 46) = v49[v51 - 46];
    *(v53 - 47) = 0;
    *(void *)uint64_t v62 = 0;
    *(void *)(v62 + 16) = 0;
    unsigned int v63 = &v102[v51 * 8 - 360];
    uint64_t v64 = (uint64_t)&v49[v51 - 45];
    *((void *)v63 + 2) = 0;
    *(void *)unsigned int v63 = 0;
    *((void *)v52 - 44) = 0;
    *(_OWORD *)unsigned int v63 = *(_OWORD *)v64;
    *((void *)v52 - 43) = v49[v51 - 43];
    *(v53 - 44) = 0;
    *(void *)uint64_t v64 = 0;
    int v65 = &v102[v51 * 8 - 336];
    uint64_t v66 = (uint64_t)&v49[v51 - 42];
    *(void *)(v64 + 16) = 0;
    *((void *)v65 + 2) = 0;
    *(void *)int v65 = 0;
    *((void *)v52 - 41) = 0;
    *(_OWORD *)int v65 = *(_OWORD *)v66;
    *((void *)v52 - 40) = v49[v51 - 40];
    *(v53 - 41) = 0;
    *(void *)uint64_t v66 = 0;
    *(void *)(v66 + 16) = 0;
    int v67 = &v102[v51 * 8 - 312];
    uint64_t v68 = (uint64_t)&v49[v51 - 39];
    *((void *)v67 + 2) = 0;
    *(void *)int v67 = 0;
    *((void *)v52 - 38) = 0;
    *(_OWORD *)int v67 = *(_OWORD *)v68;
    *((void *)v52 - 37) = v49[v51 - 37];
    *(v53 - 38) = 0;
    *(void *)uint64_t v68 = 0;
    *(void *)(v68 + 16) = 0;
    *((void *)v52 - 36) = v49[v51 - 36];
    LOWORD(v67) = v49[v51 - 35];
    int v69 = &v102[v51 * 8 - 272];
    *((void *)v52 - 32) = 0;
    *(void *)int v69 = 0;
    *((void *)v69 + 1) = 0;
    *((_WORD *)v52 - 140) = (_WORD)v67;
    *(_OWORD *)int v69 = *(_OWORD *)&v49[v51 - 34];
    *((void *)v52 - 32) = v49[v51 - 32];
    *(v53 - 33) = 0;
    *(v53 - 34) = 0;
    *(v53 - 32) = 0;
    *((void *)v52 - 30) = 0;
    *((void *)v52 - 29) = 0;
    *((void *)v52 - 31) = 0;
    *(_OWORD *)(v52 - 248) = *(_OWORD *)&v49[v51 - 31];
    *((void *)v52 - 29) = v49[v51 - 29];
    *(v53 - 31) = 0;
    *(v53 - 30) = 0;
    *(v53 - 29) = 0;
    long long v70 = *(_OWORD *)&v49[v51 - 16];
    long long v71 = *(_OWORD *)&v49[v51 - 22];
    long long v72 = *(_OWORD *)&v49[v51 - 20];
    *((_OWORD *)v52 - 9) = *(_OWORD *)&v49[v51 - 18];
    *((_OWORD *)v52 - 8) = v70;
    *((_OWORD *)v52 - 11) = v71;
    *((_OWORD *)v52 - 10) = v72;
    long long v73 = *(_OWORD *)((char *)&v49[v51 - 8] - 3);
    long long v75 = *(_OWORD *)&v49[v51 - 12];
    long long v74 = *(_OWORD *)&v49[v51 - 10];
    *((_OWORD *)v52 - 7) = *(_OWORD *)&v49[v51 - 14];
    *((_OWORD *)v52 - 6) = v75;
    *((_OWORD *)v52 - 5) = v74;
    *(_OWORD *)(v52 - 67) = v73;
    long long v77 = *(_OWORD *)&v49[v51 - 26];
    long long v76 = *(_OWORD *)&v49[v51 - 24];
    *((_OWORD *)v52 - 14) = *(_OWORD *)&v49[v51 - 28];
    *((_OWORD *)v52 - 13) = v77;
    *((_OWORD *)v52 - 12) = v76;
    LODWORD(v67) = v49[v51 - 5];
    *((void *)v52 - 6) = v49[v51 - 6];
    *((void *)v52 - 3) = 0;
    *((void *)v52 - 2) = 0;
    *((void *)v52 - 4) = 0;
    *((_DWORD *)v52 - 10) = v67;
    *((_OWORD *)v52 - 2) = *(_OWORD *)&v49[v51 - 4];
    *((void *)v52 - 2) = v49[v51 - 2];
    *(v53 - 4) = 0;
    *(v53 - 3) = 0;
    *(v53 - 2) = 0;
    *((void *)v52 - 1) = v49[v51 - 1];
    v51 -= 156;
  }
  while (&v49[v51] != v50);
  int v78 = *(void **)(a2 + 4800);
  int v49 = *(void **)(a2 + 4808);
  *(void *)(a2 + 4800) = &v102[v51 * 8];
  *(void *)(a2 + 4808) = v45;
  *(void *)(a2 + 4816) = v101;
  if (v49 != v78)
  {
    do
    {
      v49 -= 156;
      std::__destroy_at[abi:ne180100]<APAC::Metadata::RendererData,0>(v49);
    }
    while (v49 != v78);
    int v49 = v78;
  }
  if (v49) {
LABEL_61:
  }
    operator delete(v49);
LABEL_62:
  if (v33)
  {
    uint64_t v81 = 0;
    while (1)
    {
      APAC::MetadataBitStreamParser::parseGroupConfig((uint64_t)v34, *(void *)(a2 + 4776) + 48 * v81, 1, a3);
      unint64_t v82 = *(void *)(a3 + 16);
      unint64_t v83 = *(unsigned int **)a3;
      uint64_t v84 = v82 - *(void *)a3;
      int v85 = *(_DWORD *)(a3 + 28);
      if (v85 + 8 * (int)v84 <= 0) {
        break;
      }
      unsigned int v86 = *(_DWORD *)(a3 + 24);
      unsigned int v87 = v86 >> 31;
      *(_DWORD *)(a3 + 28) = v85 - 1;
      if (v85 - 1 < 0)
      {
        uint64_t v89 = v84 & ~(v84 >> 63) & 0xFFFFFFFC;
        unint64_t v90 = *(void *)(a3 + 8);
        if (v89) {
          BOOL v91 = v90 > (unint64_t)v83;
        }
        else {
          BOOL v91 = 1;
        }
        if (v91)
        {
          uint64_t v92 = 0;
          do
          {
            int v93 = (unsigned __int8 *)v83 + v92;
            unsigned int v94 = v86 << 8;
            *(_DWORD *)(a3 + 24) = v94;
            int v95 = 255;
            if ((unint64_t)v83 + v92 < v82 && (unint64_t)v93 >= v90) {
              int v95 = *v93;
            }
            unsigned int v86 = v95 | v94;
            *(_DWORD *)(a3 + 24) = v86;
            ++v92;
          }
          while (v92 != 4);
        }
        else
        {
          unsigned int v86 = bswap32(*v83);
        }
        int v96 = v86 << (1 - v85);
        int v97 = v85 + 31;
        *(_DWORD *)(a3 + 28) = v97;
        *(void *)a3 = v83 + 1;
        v87 |= v86 >> v97;
        if (v97) {
          int v88 = v96;
        }
        else {
          int v88 = 0;
        }
      }
      else
      {
        int v88 = 2 * v86;
      }
      *(_DWORD *)(a3 + 24) = v88;
      int v98 = (BOOL *)(*(void *)(a2 + 4800) + 1248 * v81);
      *int v98 = v87 != 0;
      if (v87) {
        APAC::MetadataBitStreamParser::parseRendererData((unint64_t)v34, (uint64_t)v98, 1, a3);
      }
      if (++v81 == v33) {
        return;
      }
    }
    exception = __cxa_allocate_exception(8uLL);
    int v100 = "Cannot read rMdCfg.mRendererData[gp].mHasData";
LABEL_85:
    void *exception = v100;
    __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
  }
}

uint64_t TBitstreamWriter<unsigned short>::Flush(uint64_t result)
{
  uint64_t v1 = result;
  int v2 = *(_DWORD *)(result + 28);
  if ((v2 & 7) != 0)
  {
    BOOL result = AT::TBitstreamWriter<unsigned short>::PutBits(result, 0, *(_DWORD *)(result + 28) & 7);
    int v2 = *(_DWORD *)(v1 + 28);
  }
  if (v2 == 16)
  {
    uint64_t v3 = *(void *)(v1 + 8);
  }
  else
  {
    uint64_t v3 = *(void *)(v1 + 8);
    int v4 = 8 - v2;
    do
    {
      *(unsigned char *)uint64_t v3 = *(unsigned __int16 *)(v1 + 24) >> v4;
      uint64_t v3 = *(void *)(v1 + 8) + 1;
      *(void *)(v1 + 8) = v3;
      v4 -= 8;
    }
    while (v4 != -8);
  }
  *(_DWORD *)(v1 + 28) = 16;
  *(_DWORD *)(v1 + 32) = v3 & 1;
  return result;
}

id APComponent_NSExtension::getExtension(APComponent_NSExtension *this)
{
  int v2 = (void *)*((void *)this + 21);
  if (!v2)
  {
    uint64_t v3 = [MEMORY[0x1E4F28C70] extensionWithIdentifier:*((void *)this + 20) error:0];
    int v4 = (void *)*((void *)this + 21);
    *((void *)this + 21) = v3;

    int v2 = (void *)*((void *)this + 21);
  }
  return v2;
}

void APComponent_NSExtension::~APComponent_NSExtension(APComponent_NSExtension *this)
{
  APComponent_NSExtension::~APComponent_NSExtension(this);
  JUMPOUT(0x192FC8940);
}

{
  std::__shared_weak_count *v2;
  const void *v3;
  std::__shared_weak_count *v4;
  uint64_t vars8;

  *(void *)this = &unk_1EDF93900;
  int v2 = (std::__shared_weak_count *)*((void *)this + 26);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  uint64_t v3 = (const void *)*((void *)this + 24);
  if (v3) {
    CFRelease(v3);
  }
  int v4 = (std::__shared_weak_count *)*((void *)this + 23);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }

  APComponent::~APComponent((APComponent *)this);
}

void create_shared_APComponent_Remote<RemoteV2Instance>()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

void sub_1901740B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void *create_shared_APComponent_Remote<RemoteV2Instance>(AudioComponentDescription const&,AUComponentFlags,applesauce::CF::StringRef const&,unsigned int,std::function<NSXPCConnection * ()(NSUUID *)>,applesauce::CF::ArrayRef const&,applesauce::CF::StringRef)::{lambda(AudioComponentDescription const*)#1}::~ArrayRef(void *a1)
{
  int v2 = (const void *)a1[5];
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)a1[4];
  if (v3) {
    CFRelease(v3);
  }
  return std::__function::__value_func<NSXPCConnection * ()(NSUUID *)>::~__value_func[abi:ne180100](a1);
}

uint64_t std::__shared_ptr_pointer<APComponent_RemoteV2 *,std::shared_ptr<APComponent_RemoteV2>::__shared_ptr_default_delete<APComponent_RemoteV2,APComponent_RemoteV2>,std::allocator<APComponent_RemoteV2>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

void std::__shared_ptr_pointer<APComponent_RemoteV2 *,std::shared_ptr<APComponent_RemoteV2>::__shared_ptr_default_delete<APComponent_RemoteV2,APComponent_RemoteV2>,std::allocator<APComponent_RemoteV2>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x192FC8940);
}

void APComponent_RemoteV2::~APComponent_RemoteV2(APComponent *this)
{
  *(void *)this = &unk_1EDF92DC8;
  int v2 = (const void *)*((void *)this + 20);
  if (v2) {
    CFRelease(v2);
  }
  APComponent::~APComponent(this);
  JUMPOUT(0x192FC8940);
}

{
  const void *v2;
  uint64_t vars8;

  *(void *)this = &unk_1EDF92DC8;
  int v2 = (const void *)*((void *)this + 20);
  if (v2) {
    CFRelease(v2);
  }
  APComponent::~APComponent(this);
}

void std::__function::__func<std::shared_ptr<APComponent> create_shared_APComponent_Remote<RemoteV2Instance>(AudioComponentDescription const&,AUComponentFlags,applesauce::CF::StringRef const&,unsigned int,std::function<NSXPCConnection * ()(NSUUID *)>,applesauce::CF::ArrayRef const&,applesauce::CF::StringRef)::{lambda(AudioComponentDescription const*)#1},std::allocator<std::shared_ptr<APComponent> create_shared_APComponent_Remote<RemoteV2Instance>(AudioComponentDescription const&,AUComponentFlags,applesauce::CF::StringRef const&,unsigned int,std::function<NSXPCConnection * ()(NSUUID *)>,applesauce::CF::ArrayRef const&,applesauce::CF::StringRef)::{lambda(AudioComponentDescription const*)#1}>,AudioComponentPlugInInterface * ()(AudioComponentDescription const*)>::operator()(uint64_t a1)
{
  uint64_t v1 = *MEMORY[0x1E4F143B8];
  [objc_alloc(MEMORY[0x1E4F29128]) initWithUUIDString:*(void *)(a1 + 48)];
  operator new();
}

void sub_190174480(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va2, a4);
  va_start(va1, a4);
  va_start(va, a4);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v14 = va_arg(va2, void);
  uint64_t v16 = va_arg(va2, void);
  uint64_t v17 = va_arg(va2, void);
  uint64_t v18 = va_arg(va2, void);
  std::__function::__value_func<NSXPCConnection * ()(NSUUID *)>::~__value_func[abi:ne180100]((uint64_t *)va2);
  AUv3InstanceBase::~AUv3InstanceBase(v4);

  std::__function::__value_func<NSXPCConnection * ()(NSUUID *)>::~__value_func[abi:ne180100]((uint64_t *)va1);
  std::__function::__value_func<NSXPCConnection * ()(NSUUID *)>::~__value_func[abi:ne180100]((uint64_t *)va);
  MEMORY[0x192FC8940](v4, 0x10A1C4002A128E6);

  _Unwind_Resume(a1);
}

uint64_t RemoteV2Instance::isRemoteV2(RemoteV2Instance *this)
{
  return 1;
}

void AUv3InstanceXPC::OpenAsync(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v6 = a4;
  unsigned int v7 = dispatch_get_global_queue(0, 0);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZN15AUv3InstanceXPC9OpenAsyncEP28OpaqueAudioComponentInstancejU13block_pointerFvS1_iE_block_invoke;
  block[3] = &unk_1E56888E0;
  uint64_t v11 = a1;
  uint64_t v12 = a2;
  id v10 = v6;
  id v8 = v6;
  dispatch_async(v7, block);
}

uint64_t ___ZN15AUv3InstanceXPC9OpenAsyncEP28OpaqueAudioComponentInstancejU13block_pointerFvS1_iE_block_invoke(uint64_t a1)
{
  (*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 32))(*(void *)(a1 + 40), *(void *)(a1 + 48));
  int v2 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
  return v2();
}

uint64_t AUv3InstanceXPC::Open(AUv3InstanceXPC *this, OpaqueAudioComponentInstance *a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (AUHostingServiceClient *)*((void *)this + 50);
  if (v3 && (AudioComponentDescription v20 = *(AudioComponentDescription *)((char *)this + 48), AUHostingServiceClient::loadRemotely(v3, &v20)))
  {
    id v5 = *(id *)(*((void *)this + 50) + 72);
    id v6 = [AUAudioUnit_RemoteV2 alloc];
    unsigned int v7 = (AUHostingServiceClient *)*((void *)this + 50);
    *((void *)this + 50) = 0;
    unsigned int v19 = v7;
    long long v17 = *((_OWORD *)this + 3);
    int v18 = *((_DWORD *)this + 16);
    id v16 = 0;
    id v8 = [(AUAudioUnit_RemoteV2 *)v6 initWithXPCService:&v19 componentDescription:&v17 instance:a2 instanceUUID:v5 error:&v16];
    id v9 = v16;
    id v10 = v19;
    unsigned int v19 = 0;
    if (v10)
    {
      AUHostingServiceClient::~AUHostingServiceClient(v10);
      MEMORY[0x192FC8940]();
    }
    if (v8) {
      BOOL v11 = v9 == 0;
    }
    else {
      BOOL v11 = 0;
    }
    if (v11)
    {
      AUv3InstanceBase::DoOpen(this, a2, v8);
      uint64_t v12 = 0;
    }
    else
    {
      if (!gAudioComponentLogCategory) {
        operator new();
      }
      uint64_t v13 = *(id *)gAudioComponentLogCategory;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315650;
        unsigned int v22 = "AUNSExtension.mm";
        __int16 v23 = 1024;
        int v24 = 490;
        __int16 v25 = 2112;
        id v26 = v9;
        _os_log_impl(&dword_18FEC0000, v13, OS_LOG_TYPE_ERROR, "%25s:%-5d Failed to open AudioUnit remotely: %@", buf, 0x1Cu);
      }
      (*(void (**)(AUv3InstanceXPC *))(*(void *)this + 8))(this);
      if (v9) {
        uint64_t v12 = [v9 code];
      }
      else {
        uint64_t v12 = 4294956421;
      }
    }
  }
  else
  {
    (*(void (**)(AUv3InstanceXPC *, OpaqueAudioComponentInstance *))(*(void *)this + 8))(this, a2);
    return 4294956421;
  }
  return v12;
}

void sub_19017494C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void RemoteV2Instance::~RemoteV2Instance(AUHostingServiceClient **this)
{
  *this = (AUHostingServiceClient *)&unk_1EDF8FCE8;
  std::unique_ptr<AUHostingServiceClient>::reset[abi:ne180100](this + 50, 0);
  AUv3InstanceBase::~AUv3InstanceBase((id *)this);
  JUMPOUT(0x192FC8940);
}

{
  uint64_t vars8;

  *this = (AUHostingServiceClient *)&unk_1EDF8FCE8;
  std::unique_ptr<AUHostingServiceClient>::reset[abi:ne180100](this + 50, 0);
  AUv3InstanceBase::~AUv3InstanceBase((id *)this);
}

void AUv3InstanceBase::~AUv3InstanceBase(id *this)
{
  *this = &unk_1EDF91570;
  int v2 = this + 25;
  if (*((unsigned char *)this + 280))
  {
    id WeakRetained = objc_loadWeakRetained(this + 25);
    [WeakRetained removeObserver:this[34] forKeyPath:@"parameterTree" context:0];
  }
  id v4 = this[34];
  this[34] = 0;

  objc_destroyWeak(this + 41);
  std::__tree<std::__value_type<unsigned int,AUParameterGroup * {__strong}>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,AUParameterGroup * {__strong}>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,AUParameterGroup * {__strong}>>>::destroy(this[38]);

  id v6 = this + 31;
  std::vector<AUv3InstanceBase::ScopeElementIDObj>::__destroy_vector::operator()[abi:ne180100](&v6);
  id v6 = this + 28;
  std::vector<AUv3InstanceBase::ScopeElementIDObj>::__destroy_vector::operator()[abi:ne180100](&v6);
  objc_destroyWeak(v2);

  AUv3RenderAdapter::~AUv3RenderAdapter((AUv3RenderAdapter *)(this + 17));
  id v5 = this[16];
  this[16] = 0;
  if (v5) {
    (*(void (**)(id))(*(void *)v5 + 8))(v5);
  }
  id v6 = this + 13;
  std::vector<std::shared_ptr<AudioMetadataTimeline::Node<AudioMetadataStreamFormat,AudioMetadataTimeline::Node<AudioMetadataTrackFormat,AudioMetadataTimeline::Node<AudioMetadataTrackUID,AudioMetadataTimeline::Node<AudioMetadataObject,AudioMetadataTimeline::Node<AudioMetadataContent,AudioMetadataTimeline::Node<AudioMetadataProgramme,AudioMetadataTimeline::Node<AudioMetadataFormatExtended,decltype(nullptr)>>>>>>>>>::__destroy_vector::operator()[abi:ne180100](&v6);
}

void AUv3InstanceXPC::~AUv3InstanceXPC(AUHostingServiceClient **this)
{
  *this = (AUHostingServiceClient *)&unk_1EDF8FCE8;
  std::unique_ptr<AUHostingServiceClient>::reset[abi:ne180100](this + 50, 0);
  AUv3InstanceBase::~AUv3InstanceBase((id *)this);
  JUMPOUT(0x192FC8940);
}

{
  uint64_t vars8;

  *this = (AUHostingServiceClient *)&unk_1EDF8FCE8;
  std::unique_ptr<AUHostingServiceClient>::reset[abi:ne180100](this + 50, 0);
  AUv3InstanceBase::~AUv3InstanceBase((id *)this);
}

void std::__function::__func<std::shared_ptr<APComponent> create_shared_APComponent_Remote<RemoteV2Instance>(AudioComponentDescription const&,AUComponentFlags,applesauce::CF::StringRef const&,unsigned int,std::function<NSXPCConnection * ()(NSUUID *)>,applesauce::CF::ArrayRef const&,applesauce::CF::StringRef)::{lambda(AudioComponentDescription const*)#1},std::allocator<std::shared_ptr<APComponent> create_shared_APComponent_Remote<RemoteV2Instance>(AudioComponentDescription const&,AUComponentFlags,applesauce::CF::StringRef const&,unsigned int,std::function<NSXPCConnection * ()(NSUUID *)>,applesauce::CF::ArrayRef const&,applesauce::CF::StringRef)::{lambda(AudioComponentDescription const*)#1}>,AudioComponentPlugInInterface * ()(AudioComponentDescription const*)>::destroy_deallocate(void *a1)
{
  std::__function::__alloc_func<std::shared_ptr<APComponent> create_shared_APComponent_Remote<RemoteV2Instance>(AudioComponentDescription const&,AUComponentFlags,applesauce::CF::StringRef const&,unsigned int,std::function<NSXPCConnection * ()(NSUUID *)>,applesauce::CF::ArrayRef const&,applesauce::CF::StringRef)::{lambda(AudioComponentDescription const*)#1},std::allocator<std::shared_ptr<APComponent> create_shared_APComponent_Remote<RemoteV2Instance>(AudioComponentDescription const&,AUComponentFlags,applesauce::CF::StringRef const&,unsigned int,std::function<NSXPCConnection * ()(NSUUID *)>,applesauce::CF::ArrayRef const&,applesauce::CF::StringRef)::{lambda(AudioComponentDescription const*)#1}>,AudioComponentPlugInInterface * ()(AudioComponentDescription const*)>::destroy[abi:ne180100](a1 + 1);
  operator delete(a1);
}

void *std::__function::__alloc_func<std::shared_ptr<APComponent> create_shared_APComponent_Remote<RemoteV2Instance>(AudioComponentDescription const&,AUComponentFlags,applesauce::CF::StringRef const&,unsigned int,std::function<NSXPCConnection * ()(NSUUID *)>,applesauce::CF::ArrayRef const&,applesauce::CF::StringRef)::{lambda(AudioComponentDescription const*)#1},std::allocator<std::shared_ptr<APComponent> create_shared_APComponent_Remote<RemoteV2Instance>(AudioComponentDescription const&,AUComponentFlags,applesauce::CF::StringRef const&,unsigned int,std::function<NSXPCConnection * ()(NSUUID *)>,applesauce::CF::ArrayRef const&,applesauce::CF::StringRef)::{lambda(AudioComponentDescription const*)#1}>,AudioComponentPlugInInterface * ()(AudioComponentDescription const*)>::destroy[abi:ne180100](void *a1)
{
  int v2 = (const void *)a1[5];
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)a1[4];
  if (v3) {
    CFRelease(v3);
  }
  return std::__function::__value_func<NSXPCConnection * ()(NSUUID *)>::~__value_func[abi:ne180100](a1);
}

void *std::__function::__func<std::shared_ptr<APComponent> create_shared_APComponent_Remote<RemoteV2Instance>(AudioComponentDescription const&,AUComponentFlags,applesauce::CF::StringRef const&,unsigned int,std::function<NSXPCConnection * ()(NSUUID *)>,applesauce::CF::ArrayRef const&,applesauce::CF::StringRef)::{lambda(AudioComponentDescription const*)#1},std::allocator<std::shared_ptr<APComponent> create_shared_APComponent_Remote<RemoteV2Instance>(AudioComponentDescription const&,AUComponentFlags,applesauce::CF::StringRef const&,unsigned int,std::function<NSXPCConnection * ()(NSUUID *)>,applesauce::CF::ArrayRef const&,applesauce::CF::StringRef)::{lambda(AudioComponentDescription const*)#1}>,AudioComponentPlugInInterface * ()(AudioComponentDescription const*)>::destroy(uint64_t a1)
{
  return std::__function::__alloc_func<std::shared_ptr<APComponent> create_shared_APComponent_Remote<RemoteV2Instance>(AudioComponentDescription const&,AUComponentFlags,applesauce::CF::StringRef const&,unsigned int,std::function<NSXPCConnection * ()(NSUUID *)>,applesauce::CF::ArrayRef const&,applesauce::CF::StringRef)::{lambda(AudioComponentDescription const*)#1},std::allocator<std::shared_ptr<APComponent> create_shared_APComponent_Remote<RemoteV2Instance>(AudioComponentDescription const&,AUComponentFlags,applesauce::CF::StringRef const&,unsigned int,std::function<NSXPCConnection * ()(NSUUID *)>,applesauce::CF::ArrayRef const&,applesauce::CF::StringRef)::{lambda(AudioComponentDescription const*)#1}>,AudioComponentPlugInInterface * ()(AudioComponentDescription const*)>::destroy[abi:ne180100]((void *)(a1 + 8));
}

uint64_t std::__function::__func<std::shared_ptr<APComponent> create_shared_APComponent_Remote<RemoteV2Instance>(AudioComponentDescription const&,AUComponentFlags,applesauce::CF::StringRef const&,unsigned int,std::function<NSXPCConnection * ()(NSUUID *)>,applesauce::CF::ArrayRef const&,applesauce::CF::StringRef)::{lambda(AudioComponentDescription const*)#1},std::allocator<std::shared_ptr<APComponent> create_shared_APComponent_Remote<RemoteV2Instance>(AudioComponentDescription const&,AUComponentFlags,applesauce::CF::StringRef const&,unsigned int,std::function<NSXPCConnection * ()(NSUUID *)>,applesauce::CF::ArrayRef const&,applesauce::CF::StringRef)::{lambda(AudioComponentDescription const*)#1}>,AudioComponentPlugInInterface * ()(AudioComponentDescription const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EDF9E5A8;
  return std::__compressed_pair_elem<std::shared_ptr<APComponent> create_shared_APComponent_Remote<RemoteV2Instance>(AudioComponentDescription const&,AUComponentFlags,applesauce::CF::StringRef const&,unsigned int,std::function<NSXPCConnection * ()(NSUUID *)>,applesauce::CF::ArrayRef const&,applesauce::CF::StringRef)::{lambda(AudioComponentDescription const*)#1},0,false>::__compressed_pair_elem[abi:ne180100]<std::shared_ptr<APComponent> create_shared_APComponent_Remote<RemoteV2Instance>(AudioComponentDescription const&,AUComponentFlags,applesauce::CF::StringRef const&,unsigned int,std::function<NSXPCConnection * ()(NSUUID *)>,applesauce::CF::ArrayRef const&,applesauce::CF::StringRef)::{lambda(AudioComponentDescription const*)#1} const&,0ul>((uint64_t)(a2 + 1), a1 + 8);
}

uint64_t std::__compressed_pair_elem<std::shared_ptr<APComponent> create_shared_APComponent_Remote<RemoteV2Instance>(AudioComponentDescription const&,AUComponentFlags,applesauce::CF::StringRef const&,unsigned int,std::function<NSXPCConnection * ()(NSUUID *)>,applesauce::CF::ArrayRef const&,applesauce::CF::StringRef)::{lambda(AudioComponentDescription const*)#1},0,false>::__compressed_pair_elem[abi:ne180100]<std::shared_ptr<APComponent> create_shared_APComponent_Remote<RemoteV2Instance>(AudioComponentDescription const&,AUComponentFlags,applesauce::CF::StringRef const&,unsigned int,std::function<NSXPCConnection * ()(NSUUID *)>,applesauce::CF::ArrayRef const&,applesauce::CF::StringRef)::{lambda(AudioComponentDescription const*)#1} const&,0ul>(uint64_t a1, uint64_t a2)
{
  std::__function::__value_func<NSXPCConnection * ()(NSUUID *)>::__value_func[abi:ne180100](a1, a2);
  uint64_t v4 = *(void *)(a2 + 32);
  if (v4) {
    CFRetain(*(CFTypeRef *)(a2 + 32));
  }
  *(void *)(a1 + 32) = v4;
  id v5 = *(const void **)(a2 + 40);
  if (v5) {
    CFRetain(v5);
  }
  *(void *)(a1 + 40) = v5;
  return a1;
}

void *std::__function::__func<std::shared_ptr<APComponent> create_shared_APComponent_Remote<RemoteV2Instance>(AudioComponentDescription const&,AUComponentFlags,applesauce::CF::StringRef const&,unsigned int,std::function<NSXPCConnection * ()(NSUUID *)>,applesauce::CF::ArrayRef const&,applesauce::CF::StringRef)::{lambda(AudioComponentDescription const*)#1},std::allocator<std::shared_ptr<APComponent> create_shared_APComponent_Remote<RemoteV2Instance>(AudioComponentDescription const&,AUComponentFlags,applesauce::CF::StringRef const&,unsigned int,std::function<NSXPCConnection * ()(NSUUID *)>,applesauce::CF::ArrayRef const&,applesauce::CF::StringRef)::{lambda(AudioComponentDescription const*)#1}>,AudioComponentPlugInInterface * ()(AudioComponentDescription const*)>::__clone(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  int v2 = operator new(0x38uLL);
  *int v2 = &unk_1EDF9E5A8;
  std::__compressed_pair_elem<std::shared_ptr<APComponent> create_shared_APComponent_Remote<RemoteV2Instance>(AudioComponentDescription const&,AUComponentFlags,applesauce::CF::StringRef const&,unsigned int,std::function<NSXPCConnection * ()(NSUUID *)>,applesauce::CF::ArrayRef const&,applesauce::CF::StringRef)::{lambda(AudioComponentDescription const*)#1},0,false>::__compressed_pair_elem[abi:ne180100]<std::shared_ptr<APComponent> create_shared_APComponent_Remote<RemoteV2Instance>(AudioComponentDescription const&,AUComponentFlags,applesauce::CF::StringRef const&,unsigned int,std::function<NSXPCConnection * ()(NSUUID *)>,applesauce::CF::ArrayRef const&,applesauce::CF::StringRef)::{lambda(AudioComponentDescription const*)#1} const&,0ul>((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_190174DE4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<std::shared_ptr<APComponent> create_shared_APComponent_Remote<RemoteV2Instance>(AudioComponentDescription const&,AUComponentFlags,applesauce::CF::StringRef const&,unsigned int,std::function<NSXPCConnection * ()(NSUUID *)>,applesauce::CF::ArrayRef const&,applesauce::CF::StringRef)::{lambda(AudioComponentDescription const*)#1},std::allocator<std::shared_ptr<APComponent> create_shared_APComponent_Remote<RemoteV2Instance>(AudioComponentDescription const&,AUComponentFlags,applesauce::CF::StringRef const&,unsigned int,std::function<NSXPCConnection * ()(NSUUID *)>,applesauce::CF::ArrayRef const&,applesauce::CF::StringRef)::{lambda(AudioComponentDescription const*)#1}>,AudioComponentPlugInInterface * ()(AudioComponentDescription const*)>::~__func(void *a1)
{
  *a1 = &unk_1EDF9E5A8;
  int v2 = (const void *)a1[6];
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)a1[5];
  if (v3) {
    CFRelease(v3);
  }
  std::__function::__value_func<NSXPCConnection * ()(NSUUID *)>::~__value_func[abi:ne180100](a1 + 1);
  JUMPOUT(0x192FC8940);
}

void *std::__function::__func<std::shared_ptr<APComponent> create_shared_APComponent_Remote<RemoteV2Instance>(AudioComponentDescription const&,AUComponentFlags,applesauce::CF::StringRef const&,unsigned int,std::function<NSXPCConnection * ()(NSUUID *)>,applesauce::CF::ArrayRef const&,applesauce::CF::StringRef)::{lambda(AudioComponentDescription const*)#1},std::allocator<std::shared_ptr<APComponent> create_shared_APComponent_Remote<RemoteV2Instance>(AudioComponentDescription const&,AUComponentFlags,applesauce::CF::StringRef const&,unsigned int,std::function<NSXPCConnection * ()(NSUUID *)>,applesauce::CF::ArrayRef const&,applesauce::CF::StringRef)::{lambda(AudioComponentDescription const*)#1}>,AudioComponentPlugInInterface * ()(AudioComponentDescription const*)>::~__func(void *a1)
{
  *a1 = &unk_1EDF9E5A8;
  int v2 = (const void *)a1[6];
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)a1[5];
  if (v3) {
    CFRelease(v3);
  }
  std::__function::__value_func<NSXPCConnection * ()(NSUUID *)>::~__value_func[abi:ne180100](a1 + 1);
  return a1;
}

void AUAudioUnitSubclassInstance::OpenAsync(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  unsigned int v7 = a4;
  uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 32))(a1, a2);
  v7[2](v7, a2, v6);
}

void sub_190174F74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t AUAudioUnitSubclassInstance::Open(Class *this, OpaqueAudioComponentInstance *a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v4 = objc_alloc(this[50]);
  long long v12 = *((_OWORD *)this + 3);
  int v13 = *((_DWORD *)this + 16);
  id v11 = 0;
  id v5 = (AUAudioUnit *)[v4 initWithComponentDescription:&v12 error:&v11];
  id v6 = v11;
  if (v5)
  {
    AUv3InstanceBase::DoOpen((AUv3InstanceBase *)this, a2, v5);
    uint64_t v7 = 0;
  }
  else
  {
    if (!gAudioComponentLogCategory) {
      operator new();
    }
    id v8 = *(id *)gAudioComponentLogCategory;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      uint64_t v15 = "AUNSExtension.mm";
      __int16 v16 = 1024;
      int v17 = 354;
      __int16 v18 = 2112;
      id v19 = v6;
      _os_log_impl(&dword_18FEC0000, v8, OS_LOG_TYPE_ERROR, "%25s:%-5d Failed to open AudioUnit extension: %@", buf, 0x1Cu);
    }
    (*((void (**)(Class *))*this + 1))(this);
    if ([v6 code]) {
      uint64_t v7 = [v6 code];
    }
    else {
      uint64_t v7 = 0xFFFFFFFFLL;
    }
  }

  return v7;
}

void sub_190175154(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void AUAudioUnitSubclassInstance::~AUAudioUnitSubclassInstance(id *this)
{
  AUv3InstanceBase::~AUv3InstanceBase(this);
  JUMPOUT(0x192FC8940);
}

uint64_t initInterAppAudioLogging()
{
  if (initInterAppAudioLogging::once != -1) {
    dispatch_once(&initInterAppAudioLogging::once, &__block_literal_global_13085);
  }
  return kInterAppAudioScope;
}

void __initInterAppAudioLogging_block_invoke()
{
}

uint64_t std::__function::__func<APComponent_NSExtension::APComponent_NSExtension(AudioComponentRegistrationInfo const&,NSString *,NSExtension *)::$_0,std::allocator<APComponent_NSExtension::APComponent_NSExtension(AudioComponentRegistrationInfo const&,NSString *,NSExtension *)::$_0>,AudioComponentPlugInInterface * ()(AudioComponentDescription const*)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 8);
  id v2 = (id)(*(uint64_t (**)(void *))(*v1 + 32))(v1);
  if (v1[21]) {
    operator new();
  }
  return 0;
}

void sub_190175364(_Unwind_Exception *a1)
{
  MEMORY[0x192FC8940](v1, 0x10A1C406BDEE126);
  _Unwind_Resume(a1);
}

void AUNSExtensionInstance::OpenAsync(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v7 = a4;
  uint64_t v8 = *(void *)(a1 + 400);
  long long v14 = *(_OWORD *)(a1 + 48);
  int v15 = *(_DWORD *)(a1 + 64);
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 3221225472;
  v10[2] = ___ZN21AUNSExtensionInstance9OpenAsyncEP28OpaqueAudioComponentInstancejU13block_pointerFvS1_iE_block_invoke;
  v10[3] = &unk_1E56888B8;
  id v11 = v7;
  uint64_t v12 = a1;
  uint64_t v13 = a2;
  id v9 = v7;
  +[AUAudioUnit_XH instantiateWithExtension:v8 componentDescription:&v14 instance:a2 options:a3 completionHandler:v10];
}

void sub_190175468(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void ___ZN21AUNSExtensionInstance9OpenAsyncEP28OpaqueAudioComponentInstancejU13block_pointerFvS1_iE_block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    if (!gAudioComponentLogCategory) {
      operator new();
    }
    id v7 = *(id *)gAudioComponentLogCategory;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      int v9 = 136315650;
      id v10 = "AUNSExtension.mm";
      __int16 v11 = 1024;
      int v12 = 104;
      __int16 v13 = 2112;
      id v14 = v6;
      _os_log_impl(&dword_18FEC0000, v7, OS_LOG_TYPE_ERROR, "%25s:%-5d Failed to open AudioUnit extension: %@", (uint8_t *)&v9, 0x1Cu);
    }
    (*(void (**)(void, void, uint64_t))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), 0, [v6 code]);
  }
  else
  {
    AUv3InstanceBase::DoOpen(*(AUv3InstanceBase **)(a1 + 40), *(OpaqueAudioComponentInstance **)(a1 + 48), v5);
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
}

void sub_19017560C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t AUNSExtensionInstance::Open(AUNSExtensionInstance *this, OpaqueAudioComponentInstance *a2)
{
  if (this) {
    (*(void (**)(AUNSExtensionInstance *, OpaqueAudioComponentInstance *))(*(void *)this + 8))(this, a2);
  }
  return 4294967292;
}

void AUNSExtensionInstance::~AUNSExtensionInstance(id *this)
{
  AUv3InstanceBase::~AUv3InstanceBase(this);
  JUMPOUT(0x192FC8940);
}

{
  uint64_t vars8;

  AUv3InstanceBase::~AUv3InstanceBase(this);
}

void *std::__function::__func<APComponent_NSExtension::APComponent_NSExtension(AudioComponentRegistrationInfo const&,NSString *,NSExtension *)::$_0,std::allocator<APComponent_NSExtension::APComponent_NSExtension(AudioComponentRegistrationInfo const&,NSString *,NSExtension *)::$_0>,AudioComponentPlugInInterface * ()(AudioComponentDescription const*)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EDFA09F0;
  result[1] = v3;
  return result;
}

void std::__function::__func<APComponent_NSExtension::APComponent_NSExtension(AudioComponentRegistrationInfo const&,NSString *,NSExtension *)::$_0,std::allocator<APComponent_NSExtension::APComponent_NSExtension(AudioComponentRegistrationInfo const&,NSString *,NSExtension *)::$_0>,AudioComponentPlugInInterface * ()(AudioComponentDescription const*)>::~__func()
{
}

OSStatus AudioUnitExtensionSetComponentList(CFStringRef extensionIdentifier, CFArrayRef audioComponentInfo)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (getenv("DYLD_FRAMEWORK_PATH"))
  {
LABEL_2:
    GlobalComponentPluginMgr((uint64_t *)v16);
    OSStatus v4 = AudioComponentMgr_NSExtension::setExtensionComponentList(*(AudioComponentMgr_NSExtension **)&v16[8], &extensionIdentifier->isa, (NSArray *)audioComponentInfo);
    if (*(void *)v16) {
      std::recursive_mutex::unlock(*(std::recursive_mutex **)v16);
    }
    return v4;
  }
  MainBundle = CFBundleGetMainBundle();
  if (MainBundle && (CFStringRef Identifier = CFBundleGetIdentifier(MainBundle)) != 0)
  {
    CFStringRef v7 = Identifier;
    if (CFStringHasPrefix(extensionIdentifier, Identifier)) {
      goto LABEL_2;
    }
    if (!gAudioComponentLogCategory) {
      operator new();
    }
    OSStatus v4 = 1885696621;
    id v14 = *(id *)gAudioComponentLogCategory;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int16 v16 = 136315906;
      *(void *)&v16[4] = "AUNSExtension.mm";
      *(_WORD *)&v16[12] = 1024;
      *(_DWORD *)&v16[14] = 397;
      __int16 v17 = 2112;
      CFStringRef v18 = extensionIdentifier;
      __int16 v19 = 2112;
      CFStringRef v20 = v7;
      id v10 = "%25s:%-5d AudioUnitExtensionSetComponentList: failing because the extension identifier \"%@\" is not prefixe"
            "d by the main bundle ID \"%@\".";
      __int16 v11 = v14;
      uint32_t v12 = 38;
      goto LABEL_14;
    }
  }
  else
  {
    if (!gAudioComponentLogCategory) {
      operator new();
    }
    OSStatus v4 = 1651401791;
    uint64_t v8 = *(id *)gAudioComponentLogCategory;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int16 v16 = 136315394;
      *(void *)&v16[4] = "AUNSExtension.mm";
      *(_WORD *)&v16[12] = 1024;
      *(_DWORD *)&v16[14] = 392;
      id v10 = "%25s:%-5d AudioUnitExtensionSetComponentList: failing because there is no main bundle or it has no identifier.";
      __int16 v11 = v8;
      uint32_t v12 = 18;
LABEL_14:
      _os_log_impl(&dword_18FEC0000, v11, OS_LOG_TYPE_ERROR, v10, v16, v12);
    }
  }
  return v4;
}

void sub_1901759AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, std::recursive_mutex *a9)
{
  if (a9) {
    std::recursive_mutex::unlock(a9);
  }
  _Unwind_Resume(exception_object);
}

CFArrayRef AudioUnitExtensionCopyComponentList(CFStringRef extensionIdentifier)
{
  GlobalComponentPluginMgr((uint64_t *)v5);
  id v2 = AudioComponentMgr_NSExtension::getExtensionComponentList((AudioComponentMgr_NSExtension *)v5[1], &extensionIdentifier->isa);
  if (v5[0]) {
    std::recursive_mutex::unlock(v5[0]);
  }
  if (v2) {
    id v3 = v2;
  }

  return (CFArrayRef)v2;
}

void sub_190175A2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, std::recursive_mutex *a9)
{
  if (a9) {
    std::recursive_mutex::unlock(a9);
  }
  _Unwind_Resume(exception_object);
}

void create_shared_APComponent_RemoteV2()
{
}

void sub_190175AC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
}

void create_shared_APComponent_RemoteV2WithExistingConnection(uint64_t a1, uint64_t a2, void **a3, const void **a4)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFRetain(&stru_1EDFA53D0);
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&cf, &stru_1EDFA53D0);
  applesauce::xpc::object::object(&v9, *a3);
  uint32_t v12 = 0;
  v11[0] = &unk_1EDF9E6C8;
  v11[1] = v9;
  xpc_object_t v6 = xpc_null_create();
  CFStringRef v7 = v9;
  int v9 = v6;

  uint32_t v12 = v11;
  uint64_t v8 = *a4;
  if (v8) {
    CFRetain(v8);
  }
  create_shared_APComponent_Remote<RemoteV2Instance>();
}

void sub_190175C24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, int a17, __int16 a18, char a19, char a20)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

id std::__function::__func<create_shared_APComponent_RemoteV2WithExistingConnection(AudioComponentDescription const&,applesauce::xpc::endpoint,applesauce::CF::StringRef)::$_0,std::allocator<create_shared_APComponent_RemoteV2WithExistingConnection(AudioComponentDescription const&,applesauce::xpc::endpoint,applesauce::CF::StringRef)::$_0>,NSXPCConnection * ()(NSUUID *)>::operator()(uint64_t a1)
{
  id v2 = objc_opt_new();
  id v3 = *(id *)(a1 + 8);
  [v2 _setEndpoint:v3];

  OSStatus v4 = (void *)[(id)objc_opt_new() initWithListenerEndpoint:v2];
  return v4;
}

void sub_190175D10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::__function::__func<create_shared_APComponent_RemoteV2WithExistingConnection(AudioComponentDescription const&,applesauce::xpc::endpoint,applesauce::CF::StringRef)::$_0,std::allocator<create_shared_APComponent_RemoteV2WithExistingConnection(AudioComponentDescription const&,applesauce::xpc::endpoint,applesauce::CF::StringRef)::$_0>,NSXPCConnection * ()(NSUUID *)>::destroy_deallocate(id *a1)
{
  id v2 = a1[1];
  a1[1] = 0;

  operator delete(a1);
}

void std::__function::__func<create_shared_APComponent_RemoteV2WithExistingConnection(AudioComponentDescription const&,applesauce::xpc::endpoint,applesauce::CF::StringRef)::$_0,std::allocator<create_shared_APComponent_RemoteV2WithExistingConnection(AudioComponentDescription const&,applesauce::xpc::endpoint,applesauce::CF::StringRef)::$_0>,NSXPCConnection * ()(NSUUID *)>::destroy(uint64_t a1)
{
  id v2 = *(void **)(a1 + 8);
  *(void *)(a1 + 8) = 0;

  id v3 = *(void **)(a1 + 8);
}

void **std::__function::__func<create_shared_APComponent_RemoteV2WithExistingConnection(AudioComponentDescription const&,applesauce::xpc::endpoint,applesauce::CF::StringRef)::$_0,std::allocator<create_shared_APComponent_RemoteV2WithExistingConnection(AudioComponentDescription const&,applesauce::xpc::endpoint,applesauce::CF::StringRef)::$_0>,NSXPCConnection * ()(NSUUID *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EDF9E6C8;
  return applesauce::xpc::object::object((void **)(a2 + 8), *(void **)(a1 + 8));
}

void **std::__function::__func<create_shared_APComponent_RemoteV2WithExistingConnection(AudioComponentDescription const&,applesauce::xpc::endpoint,applesauce::CF::StringRef)::$_0,std::allocator<create_shared_APComponent_RemoteV2WithExistingConnection(AudioComponentDescription const&,applesauce::xpc::endpoint,applesauce::CF::StringRef)::$_0>,NSXPCConnection * ()(NSUUID *)>::__clone(uint64_t a1)
{
  id v2 = (void **)operator new(0x10uLL);
  *id v2 = &unk_1EDF9E6C8;
  applesauce::xpc::object::object(v2 + 1, *(void **)(a1 + 8));
  return v2;
}

void std::__function::__func<create_shared_APComponent_RemoteV2WithExistingConnection(AudioComponentDescription const&,applesauce::xpc::endpoint,applesauce::CF::StringRef)::$_0,std::allocator<create_shared_APComponent_RemoteV2WithExistingConnection(AudioComponentDescription const&,applesauce::xpc::endpoint,applesauce::CF::StringRef)::$_0>,NSXPCConnection * ()(NSUUID *)>::~__func(uint64_t a1)
{
  id v2 = *(void **)(a1 + 8);
  *(void *)a1 = &unk_1EDF9E6C8;
  *(void *)(a1 + 8) = 0;

  JUMPOUT(0x192FC8940);
}

uint64_t std::__function::__func<create_shared_APComponent_RemoteV2WithExistingConnection(AudioComponentDescription const&,applesauce::xpc::endpoint,applesauce::CF::StringRef)::$_0,std::allocator<create_shared_APComponent_RemoteV2WithExistingConnection(AudioComponentDescription const&,applesauce::xpc::endpoint,applesauce::CF::StringRef)::$_0>,NSXPCConnection * ()(NSUUID *)>::~__func(uint64_t a1)
{
  id v2 = *(void **)(a1 + 8);
  *(void *)a1 = &unk_1EDF9E6C8;
  *(void *)(a1 + 8) = 0;

  return a1;
}

uint64_t *AUMetadata_log_category(void)
{
  {
    qword_1E9276798 = 0;
    AUMetadata_log_category(void)::gLog = (uint64_t)os_log_create("com.apple.coreaudio", "AudioMetadata");
  }
  return &AUMetadata_log_category(void)::gLog;
}

void AudioMetadataFrame::AudioMetadataFrame(AudioMetadataFrame *this)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  uint64_t v1 = (void *)MEMORY[0x1E4FB7E88];
  if (!*MEMORY[0x1E4FB7E88])
  {
    MEMORY[0x192FC7EE0]();
    if (!*v1) {
      __break(1u);
    }
  }
}

void sub_190175FB8(_Unwind_Exception *exception_object)
{
  id v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    std::allocator_traits<caulk::rt_allocator<char>>::deallocate[abi:ne180100](v3);
  }
  _Unwind_Resume(exception_object);
}

caulk::rt_safe_memory_resource *std::allocator_traits<caulk::rt_allocator<char>>::deallocate[abi:ne180100](void *a1)
{
  uint64_t result = (caulk::rt_safe_memory_resource *)*MEMORY[0x1E4FB7E88];
  if (*MEMORY[0x1E4FB7E88]) {
    return (caulk::rt_safe_memory_resource *)caulk::rt_safe_memory_resource::rt_deallocate(result, a1);
  }
  __break(1u);
  return result;
}

void *AudioMetadataFrame::AudioMetadataFrame(void *result)
{
  *uint64_t result = 0;
  result[1] = 0;
  result[2] = 0;
  return result;
}

{
  *uint64_t result = 0;
  result[1] = 0;
  result[2] = 0;
  return result;
}

void AudioMetadataFrame::~AudioMetadataFrame(AudioMetadataFrame *this)
{
  id v2 = *(void **)this;
  if (v2)
  {
    *((void *)this + 1) = v2;
    std::allocator_traits<caulk::rt_allocator<char>>::deallocate[abi:ne180100](v2);
  }
}

{
  void *v2;

  id v2 = *(void **)this;
  if (v2)
  {
    *((void *)this + 1) = v2;
    std::allocator_traits<caulk::rt_allocator<char>>::deallocate[abi:ne180100](v2);
  }
}

uint64_t *AudioMetadataFrame::begin_new(uint64_t *result, unsigned int *__src)
{
  id v3 = result;
  OSStatus v4 = __src + 11;
  for (unsigned int i = __src[10]; i; --i)
    OSStatus v4 = (unsigned int *)((char *)v4 + v4[2]);
  unint64_t v6 = (char *)v4 - (char *)__src;
  unint64_t v7 = result[2];
  uint64_t v8 = (char *)*result;
  if (v7 - *result < (char *)v4 - (char *)__src)
  {
    if (v8)
    {
      result[1] = (uint64_t)v8;
      std::allocator_traits<caulk::rt_allocator<char>>::deallocate[abi:ne180100](v8);
      unint64_t v7 = 0;
      *id v3 = 0;
      v3[1] = 0;
      v3[2] = 0;
    }
    if ((v6 & 0x8000000000000000) != 0) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v9 = 2 * v7;
    if (2 * v7 <= v6) {
      uint64_t v9 = (char *)v4 - (char *)__src;
    }
    if (v7 >= 0x3FFFFFFFFFFFFFFFLL) {
      uint64_t v10 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v10 = v9;
    }
    uint64_t result = (uint64_t *)std::vector<char,caulk::rt_allocator<char>>::__vallocate[abi:ne180100](v3, v10);
    uint64_t v8 = (char *)v3[1];
    goto LABEL_19;
  }
  __int16 v11 = (unsigned char *)result[1];
  size_t v12 = v11 - v8;
  if (v11 - v8 >= v6)
  {
LABEL_19:
    if (v4 != __src) {
      uint64_t result = (uint64_t *)memmove(v8, __src, (char *)v4 - (char *)__src);
    }
    id v14 = &v8[v6];
    goto LABEL_22;
  }
  uint64_t v13 = (unsigned int *)((char *)__src + v12);
  if (v11 != v8)
  {
    uint64_t result = (uint64_t *)memmove((void *)*result, __src, v12);
    uint64_t v8 = (char *)v3[1];
  }
  if (v4 != v13) {
    uint64_t result = (uint64_t *)memmove(v8, v13, (char *)v4 - (char *)v13);
  }
  id v14 = &v8[(char *)v4 - (char *)v13];
LABEL_22:
  v3[1] = (uint64_t)v14;
  return result;
}

uint64_t std::vector<char,caulk::rt_allocator<char>>::__vallocate[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  if (a2 < 0) {
LABEL_5:
  }
    std::vector<float>::__throw_length_error[abi:ne180100]();
  if (!*MEMORY[0x1E4FB7E88])
  {
    __break(1u);
    goto LABEL_5;
  }
  uint64_t result = caulk::rt_safe_memory_resource::rt_allocate((caulk::rt_safe_memory_resource *)*MEMORY[0x1E4FB7E88]);
  *a1 = result;
  a1[1] = result;
  a1[2] = result + a2;
  return result;
}

uint64_t AudioMetadataFrame::append(uint64_t result, char *__src)
{
  if (*((_DWORD *)__src + 2) == 40)
  {
    id v2 = (uint64_t *)result;
    AudioMetadataFrame::append(AudioMetadataEvent const&)::gInvalidEventCount = 0;
    uint64_t result = (uint64_t)std::vector<char,caulk::rt_allocator<char>>::__insert_with_size[abi:ne180100]<char const*,char const*>(result, *(char **)(result + 8), __src, __src + 40, 40);
    uint64_t v3 = *v2;
    if (!*v2 || (unint64_t)(v2[1] - v3) <= 0x2B) {
      std::terminate();
    }
    OSStatus v4 = (int *)(v3 + 40);
  }
  else
  {
    if (AudioMetadataFrame::append(AudioMetadataEvent const&)::gInvalidEventCount > 0x1F3) {
      return result;
    }
    uint64_t v5 = _os_log_pack_size();
    uint64_t result = caulk::deferred_logger::create_message((caulk::deferred_logger *)gCADefaultDeferredLog, v5 + 88, 16);
    if (result)
    {
      unint64_t v6 = (caulk::concurrent::message *)result;
      *(_WORD *)_os_log_pack_fill() = 0;
      uint64_t result = caulk::concurrent::messenger::enqueue(*(caulk::concurrent::messenger **)(gCADefaultDeferredLog + 16), v6);
    }
    OSStatus v4 = &AudioMetadataFrame::append(AudioMetadataEvent const&)::gInvalidEventCount;
  }
  ++*v4;
  return result;
}

char *std::vector<char,caulk::rt_allocator<char>>::__insert_with_size[abi:ne180100]<char const*,char const*>(uint64_t a1, char *__dst, char *__src, char *a4, uint64_t a5)
{
  uint64_t v5 = __dst;
  if (a5 < 1) {
    return v5;
  }
  uint64_t v6 = a5;
  unint64_t v7 = __src;
  unint64_t v10 = *(void *)(a1 + 8);
  uint64_t v9 = *(void *)(a1 + 16);
  if ((uint64_t)(v9 - v10) < a5)
  {
    __int16 v11 = *(char **)a1;
    uint64_t v12 = v10 - *(void *)a1 + a5;
    if (v12 >= 0)
    {
      unint64_t v13 = v9 - (void)v11;
      if (2 * v13 > v12) {
        uint64_t v12 = 2 * v13;
      }
      if (v13 >= 0x3FFFFFFFFFFFFFFFLL) {
        uint64_t v14 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v14 = v12;
      }
      if (!v14)
      {
        uint64_t v15 = 0;
LABEL_26:
        __int16 v25 = (unsigned char *)(v15 + v5 - v11);
        id v26 = &v25[v6];
        uint64_t v27 = v25;
        do
        {
          char v28 = *v7++;
          *v27++ = v28;
          --v6;
        }
        while (v6);
        unsigned int v29 = *(char **)a1;
        int v30 = v25;
        if (*(char **)a1 != v5)
        {
          unsigned int v31 = v5;
          int v30 = v25;
          do
          {
            char v32 = *--v31;
            *--int v30 = v32;
          }
          while (v31 != v29);
        }
        uint64_t v33 = v15 + v14;
        unsigned int v34 = *(unsigned char **)(a1 + 8);
        uint64_t v35 = v34 - v5;
        if (v34 != v5) {
          memmove(v26, v5, v34 - v5);
        }
        uint64_t v36 = *(char **)a1;
        *(void *)a1 = v30;
        *(void *)(a1 + 8) = &v26[v35];
        *(void *)(a1 + 16) = v33;
        if (v36) {
          std::allocator_traits<caulk::rt_allocator<char>>::deallocate[abi:ne180100](v36);
        }
        return v25;
      }
      if (*MEMORY[0x1E4FB7E88])
      {
        uint64_t v15 = caulk::rt_safe_memory_resource::rt_allocate((caulk::rt_safe_memory_resource *)*MEMORY[0x1E4FB7E88]);
        goto LABEL_26;
      }
      __break(1u);
    }
    std::vector<float>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v16 = v10 - (void)__dst;
  if ((uint64_t)(v10 - (void)__dst) >= a5)
  {
    __int16 v17 = &__src[a5];
    __int16 v19 = *(unsigned char **)(a1 + 8);
LABEL_18:
    CFStringRef v20 = &v5[v6];
    uint64_t v21 = &v19[-v6];
    unsigned int v22 = v19;
    if ((unint64_t)&v19[-v6] < v10)
    {
      uint64_t v23 = v6 + v10 - (void)v19;
      unsigned int v22 = v19;
      do
      {
        char v24 = *v21++;
        *v22++ = v24;
        --v23;
      }
      while (v23);
    }
    *(void *)(a1 + 8) = v22;
    if (v19 != v20) {
      memmove(&v5[v6], v5, v19 - v20);
    }
    if (v17 != v7) {
      memmove(v5, v7, v17 - v7);
    }
    return v5;
  }
  __int16 v17 = &__src[v16];
  int64_t v18 = a4 - &__src[v16];
  if (a4 != &__src[v16]) {
    memmove(*(void **)(a1 + 8), &__src[v16], a4 - &__src[v16]);
  }
  __int16 v19 = (unsigned char *)(v10 + v18);
  *(void *)(a1 + 8) = v10 + v18;
  if (v16 >= 1) {
    goto LABEL_18;
  }
  return v5;
}

unint64_t *AudioMetadataFrame::insert(unint64_t *a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  if (a3) {
    uint64_t v6 = (char *)AudioMetadataFrame::eventToImplIter(a1, a3);
  }
  else {
    uint64_t v6 = (char *)a1[1];
  }
  std::vector<char,caulk::rt_allocator<char>>::__insert_with_size[abi:ne180100]<char const*,char const*>((uint64_t)a1, v6, (char *)a4, (char *)(a4 + *(unsigned int *)(a4 + 8)), *(unsigned int *)(a4 + 8));
  unint64_t v7 = *a1;
  if (!*a1 || a1[1] - v7 <= 0x2B) {
    std::terminate();
  }
  ++*(_DWORD *)(v7 + 40);
  return a1;
}

unint64_t AudioMetadataFrame::eventToImplIter(unint64_t *a1, unint64_t a2)
{
  if (*a1 >= a2 || a2 - *a1 > a1[1] - *a1) {
    std::terminate();
  }
  return a2;
}

uint64_t AudioMetadataFrame::erase(unint64_t *a1, uint64_t a2, unint64_t a3)
{
  unint64_t v3 = *a1;
  if (!*a1 || a1[1] - v3 <= 0x2B || !a3 || !*(_DWORD *)(v3 + 40)) {
    std::terminate();
  }
  unint64_t v7 = (char *)AudioMetadataFrame::eventToImplIter(a1, a3);
  uint64_t v8 = *(unsigned int *)(a3 + 8);
  if (v8)
  {
    uint64_t v9 = v7;
    unint64_t v10 = &v7[v8];
    __int16 v11 = (unsigned char *)a1[1];
    uint64_t v12 = v11 - v10;
    if (v11 != v10) {
      memmove(v7, v10, v11 - v10);
    }
    a1[1] = (unint64_t)&v9[v12];
  }
  --*(_DWORD *)(v3 + 40);
  return a2;
}

BOOL AudioMetadataFrame::overlapsTimeRange(double **this, double a2, double a3)
{
  unint64_t v3 = *this;
  if (!*this || (unint64_t)((char *)this[1] - (char *)v3) <= 0x2B) {
    std::terminate();
  }
  double v4 = *v3;
  double v5 = v3[1];
  BOOL v6 = *v3 < a3;
  return v4 + v5 > a2 && v6;
}

CA::MetadataFrameQueue *CA::MetadataFrameQueue::MetadataFrameQueue(CA::MetadataFrameQueue *this)
{
  *(void *)this = this;
  *((void *)this + 1) = this;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  id v2 = (void *)MEMORY[0x1E4FB7E88];
  if (*MEMORY[0x1E4FB7E88]) {
    return this;
  }
  uint64_t result = (CA::MetadataFrameQueue *)MEMORY[0x192FC7EE0]();
  if (*v2) {
    return this;
  }
  __break(1u);
  return result;
}

void sub_190176714(_Unwind_Exception *a1)
{
  unint64_t v3 = (caulk::rt_safe_memory_resource *)v1[3];
  if (v3)
  {
    v1[4] = v3;
    std::allocator_traits<caulk::rt_allocator<AudioMetadataEvent const*>>::deallocate[abi:ne180100](v3, (uint64_t)(v1[5] - (void)v3) >> 3);
  }
  std::__list_imp<AudioMetadataFrame,caulk::rt_allocator<AudioMetadataFrame>>::clear(v1);
  _Unwind_Resume(a1);
}

void *std::__list_imp<AudioMetadataFrame,caulk::rt_allocator<AudioMetadataFrame>>::clear(void *result)
{
  if (result[2])
  {
    uint64_t v1 = result;
    uint64_t result = (void *)result[1];
    uint64_t v2 = *v1;
    uint64_t v3 = *result;
    *(void *)(v3 + 8) = *(void *)(*v1 + 8);
    **(void **)(v2 + 8) = v3;
    v1[2] = 0;
    while (result != v1)
    {
      double v4 = (void *)result[1];
      std::__list_imp<AudioMetadataFrame,caulk::rt_allocator<AudioMetadataFrame>>::__delete_node[abi:ne180100]<>(result);
      uint64_t result = v4;
    }
  }
  return result;
}

caulk::rt_safe_memory_resource *std::__list_imp<AudioMetadataFrame,caulk::rt_allocator<AudioMetadataFrame>>::__delete_node[abi:ne180100]<>(void *a1)
{
  uint64_t v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    std::allocator_traits<caulk::rt_allocator<char>>::deallocate[abi:ne180100](v2);
  }
  return std::allocator_traits<caulk::rt_allocator<std::__list_node<AudioMetadataFrame,void *>>>::deallocate[abi:ne180100](a1);
}

caulk::rt_safe_memory_resource *std::allocator_traits<caulk::rt_allocator<std::__list_node<AudioMetadataFrame,void *>>>::deallocate[abi:ne180100](void *a1)
{
  uint64_t result = (caulk::rt_safe_memory_resource *)*MEMORY[0x1E4FB7E88];
  if (*MEMORY[0x1E4FB7E88]) {
    return (caulk::rt_safe_memory_resource *)caulk::rt_safe_memory_resource::rt_deallocate(result, a1);
  }
  __break(1u);
  return result;
}

caulk::rt_safe_memory_resource *std::allocator_traits<caulk::rt_allocator<AudioMetadataEvent const*>>::deallocate[abi:ne180100](caulk::rt_safe_memory_resource *result, unint64_t a2)
{
  if (!(a2 >> 61))
  {
    uint64_t v2 = result;
    uint64_t result = (caulk::rt_safe_memory_resource *)*MEMORY[0x1E4FB7E88];
    if (*MEMORY[0x1E4FB7E88]) {
      return (caulk::rt_safe_memory_resource *)caulk::rt_safe_memory_resource::rt_deallocate(result, v2);
    }
  }
  __break(1u);
  return result;
}

caulk::rt_safe_memory_resource *CA::MetadataFrameQueue::appendFrame(CA::MetadataFrameQueue *this, double **a2)
{
  if (*((void *)this + 2))
  {
    double v4 = *(double **)(*(void *)this + 16);
    if (!v4
      || *(void *)(*(void *)this + 24) - (void)v4 <= 0x2BuLL
      || (double v5 = *a2) == 0
      || (unint64_t)((char *)a2[1] - (char *)v5) <= 0x2B
      || *v5 < *v4 + v4[1])
    {
      std::terminate();
    }
  }
  uint64_t result = (caulk::rt_safe_memory_resource *)*MEMORY[0x1E4FB7E88];
  if (*MEMORY[0x1E4FB7E88])
  {
    unint64_t v7 = (void *)caulk::rt_safe_memory_resource::rt_allocate(result);
    *unint64_t v7 = 0;
    v7[1] = 0;
    uint64_t v9 = *a2;
    uint64_t v8 = a2[1];
    v7[2] = 0;
    uint64_t result = (caulk::rt_safe_memory_resource *)(v7 + 2);
    v7[3] = 0;
    v7[4] = 0;
    size_t v10 = (char *)v8 - (char *)v9;
    if (v8 != v9)
    {
      std::vector<char,caulk::rt_allocator<char>>::__vallocate[abi:ne180100]((uint64_t *)result, (char *)v8 - (char *)v9);
      __int16 v11 = (char *)v7[3];
      uint64_t result = (caulk::rt_safe_memory_resource *)memmove(v11, v9, v10);
      v7[3] = &v11[v10];
    }
    v7[1] = this;
    uint64_t v12 = *(void *)this;
    *unint64_t v7 = *(void *)this;
    *(void *)(v12 + 8) = v7;
    *(void *)this = v7;
    ++*((void *)this + 2);
  }
  else
  {
    __break(1u);
  }
  return result;
}

void sub_190176994(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::__exception_guard_exceptions<std::vector<char,caulk::rt_allocator<char>>::__destroy_vector>::~__exception_guard_exceptions[abi:ne180100](&a9);
  std::allocator_traits<caulk::rt_allocator<std::__list_node<AudioMetadataFrame,void *>>>::deallocate[abi:ne180100](v9);
  _Unwind_Resume(a1);
}

void ***std::__exception_guard_exceptions<std::vector<char,caulk::rt_allocator<char>>::__destroy_vector>::~__exception_guard_exceptions[abi:ne180100](void ***a1)
{
  if (!*((unsigned char *)a1 + 8))
  {
    uint64_t v2 = *a1;
    uint64_t v3 = **a1;
    if (v3)
    {
      v2[1] = v3;
      std::allocator_traits<caulk::rt_allocator<char>>::deallocate[abi:ne180100](v3);
    }
  }
  return a1;
}

uint64_t *CA::MetadataFrameQueue::eraseBefore(CA::MetadataFrameQueue *this, double a2)
{
  uint64_t result = (uint64_t *)*((void *)this + 1);
  double v4 = (double *)result[2];
  if (!v4 || (unint64_t)(result[3] - (void)v4) < 0x2C) {
LABEL_6:
  }
    std::terminate();
  while (*v4 + v4[1] <= a2)
  {
    uint64_t v6 = *result;
    unint64_t v7 = (uint64_t *)result[1];
    *(void *)(v6 + 8) = v7;
    *(void *)result[1] = v6;
    --*((void *)this + 2);
    std::__list_imp<AudioMetadataFrame,caulk::rt_allocator<AudioMetadataFrame>>::__delete_node[abi:ne180100]<>(result);
    double v4 = (double *)v7[2];
    if (v4)
    {
      uint64_t result = v7;
      if ((unint64_t)(v7[3] - (void)v4) >= 0x2C) {
        continue;
      }
    }
    goto LABEL_6;
  }
  return result;
}

uint64_t CA::MetadataFrameQueue::extract(CA::MetadataFrameQueue *this, double a2, double a3, AudioMetadataFrame *a4)
{
  *((void *)this + 4) = *((void *)this + 3);
  uint64_t v8 = *((void *)this + 1);
  if ((CA::MetadataFrameQueue *)v8 == this) {
    goto LABEL_52;
  }
  unsigned int v9 = 0;
  double v10 = a2 + a3;
  do
  {
    if (!AudioMetadataFrame::overlapsTimeRange((double **)(v8 + 16), a2, a2 + a3))
    {
      unsigned int v34 = *(double **)(v8 + 16);
      if (v34 && *(void *)(v8 + 24) - (void)v34 > 0x2BuLL)
      {
        if (*v34 < a2) {
          goto LABEL_46;
        }
        break;
      }
      goto LABEL_57;
    }
    __int16 v11 = (void *)*((void *)this + 4);
    uint64_t v12 = (char *)v11 - *((void *)this + 3);
    uint64_t v14 = *(void *)(v8 + 16);
    uint64_t v13 = *(void *)(v8 + 24);
    BOOL v15 = (unint64_t)(v13 - v14) < 0x2C || v14 == 0;
    uint64_t v16 = (char *)v11 - *((void *)this + 3);
    if (v15) {
      goto LABEL_40;
    }
    uint64_t v17 = v14 + 44;
    do
    {
      double v18 = *(double *)(v17 + 12);
      if (v18 >= a2 && v18 < v10)
      {
        unint64_t v20 = *((void *)this + 5);
        if ((unint64_t)v11 < v20)
        {
          *v11++ = v17;
LABEL_33:
          *((void *)this + 4) = v11;
          uint64_t v13 = *(void *)(v8 + 24);
          goto LABEL_34;
        }
        uint64_t v21 = *((void *)this + 3);
        uint64_t v22 = ((uint64_t)v11 - v21) >> 3;
        if ((unint64_t)(v22 + 1) >> 61) {
          std::vector<float>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v23 = v20 - v21;
        uint64_t v24 = v23 >> 2;
        if (v23 >> 2 <= (unint64_t)(v22 + 1)) {
          uint64_t v24 = v22 + 1;
        }
        if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v25 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v25 = v24;
        }
        if (!v25)
        {
          uint64_t v26 = 0;
LABEL_27:
          uint64_t v27 = (void *)(v26 + 8 * v22);
          *uint64_t v27 = v17;
          __int16 v11 = v27 + 1;
          uint64_t v29 = *((void *)this + 3);
          unint64_t v28 = *((void *)this + 4);
          if (v28 == v29)
          {
            *(void *)&long long v31 = vdupq_n_s64(v28).u64[0];
          }
          else
          {
            do
            {
              uint64_t v30 = *(void *)(v28 - 8);
              v28 -= 8;
              *--uint64_t v27 = v30;
            }
            while (v28 != v29);
            long long v31 = *(_OWORD *)((char *)this + 24);
          }
          *((void *)this + 3) = v27;
          *((void *)this + 4) = v11;
          uint64_t v32 = *((void *)this + 5);
          *((void *)this + 5) = v26 + 8 * v25;
          if ((void)v31) {
            std::allocator_traits<caulk::rt_allocator<AudioMetadataEvent const*>>::deallocate[abi:ne180100]((caulk::rt_safe_memory_resource *)v31, (v32 - (uint64_t)v31) >> 3);
          }
          goto LABEL_33;
        }
        if (!(v25 >> 61) && *MEMORY[0x1E4FB7E88])
        {
          uint64_t v26 = caulk::rt_safe_memory_resource::rt_allocate((caulk::rt_safe_memory_resource *)*MEMORY[0x1E4FB7E88]);
          goto LABEL_27;
        }
        __break(1u);
LABEL_57:
        std::terminate();
      }
LABEL_34:
      BOOL v33 = v17 + (unint64_t)*(unsigned int *)(v17 + 8) >= v13 - 1 || v17 == 0;
      v17 += *(unsigned int *)(v17 + 8);
    }
    while (!v33);
    uint64_t v16 = (char *)v11 - *((void *)this + 3);
LABEL_40:
    if (v16 > v12) {
      ++v9;
    }
LABEL_46:
    uint64_t v8 = *(void *)(v8 + 8);
  }
  while ((CA::MetadataFrameQueue *)v8 != this);
  if (v9 >= 2)
  {
    unint64_t v35 = *((void *)this + 3);
    uint64_t v36 = (uint64_t *)*((void *)this + 4);
    unint64_t v37 = 126 - 2 * __clz((uint64_t)((uint64_t)v36 - v35) >> 3);
    if (v36 == (uint64_t *)v35) {
      uint64_t v38 = 0;
    }
    else {
      uint64_t v38 = v37;
    }
    std::__introsort<std::_ClassicAlgPolicy,CA::MetadataFrameQueue::extract(double,double,AudioMetadataFrame &)::$_0 &,AudioMetadataEvent const**,false>(v35, v36, v38, 1);
  }
LABEL_52:
  *(double *)int v43 = a2;
  *(double *)&v43[1] = a3;
  v43[2] = 0;
  __int16 v44 = 3;
  long long v45 = xmmword_1901C6570;
  uint64_t result = (uint64_t)AudioMetadataFrame::begin_new((uint64_t *)a4, (unsigned int *)v43);
  uint64_t v41 = (char **)*((void *)this + 3);
  unint64_t v40 = (char **)*((void *)this + 4);
  while (v41 != v40)
  {
    unint64_t v42 = *v41++;
    uint64_t result = AudioMetadataFrame::append((uint64_t)a4, v42);
  }
  return result;
}

unint64_t std::__introsort<std::_ClassicAlgPolicy,CA::MetadataFrameQueue::extract(double,double,AudioMetadataFrame &)::$_0 &,AudioMetadataEvent const**,false>(unint64_t result, uint64_t *a2, uint64_t a3, char a4)
{
  unsigned int v9 = (uint64_t *)result;
LABEL_2:
  double v10 = a2 - 1;
  k = v9;
  while (1)
  {
    unsigned int v9 = k;
    uint64_t v12 = (char *)a2 - (char *)k;
    unint64_t v13 = a2 - k;
    if (v5 || !v4)
    {
      switch(v13)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          uint64_t v47 = *v10;
          uint64_t v48 = *k;
          unsigned int v49 = *(_DWORD *)(*v10 + 4);
          unsigned int v50 = *(_DWORD *)(*k + 4);
          if (v49 == v50)
          {
            if (*(double *)(v47 + 12) >= *(double *)(v48 + 12)) {
              return result;
            }
          }
          else if (v49 >= v50)
          {
            return result;
          }
          uint64_t *k = v47;
          *double v10 = v48;
          return result;
        case 3uLL:
          return (unint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CA::MetadataFrameQueue::extract(double,double,AudioMetadataFrame &)::$_0 &,AudioMetadataEvent const**>(k, k + 1, a2 - 1);
        case 4uLL:
          return (unint64_t)std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,CA::MetadataFrameQueue::extract(double,double,AudioMetadataFrame &)::$_0 &,AudioMetadataEvent const**>(k, k + 1, k + 2, a2 - 1);
        case 5uLL:
          uint64_t v51 = k + 1;
          unint64_t v52 = k + 2;
          uint64_t v53 = k + 3;
          uint64_t result = (unint64_t)std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,CA::MetadataFrameQueue::extract(double,double,AudioMetadataFrame &)::$_0 &,AudioMetadataEvent const**>(k, k + 1, k + 2, k + 3);
          uint64_t v54 = *v10;
          uint64_t v55 = k[3];
          unsigned int v56 = *(_DWORD *)(*v10 + 4);
          unsigned int v57 = *(_DWORD *)(v55 + 4);
          if (v56 == v57)
          {
            if (*(double *)(v54 + 12) >= *(double *)(v55 + 12)) {
              return result;
            }
          }
          else if (v56 >= v57)
          {
            return result;
          }
          uint64_t *v53 = v54;
          *double v10 = v55;
          uint64_t v110 = *v53;
          uint64_t v111 = *v52;
          unsigned int v112 = *(_DWORD *)(*v53 + 4);
          unsigned int v113 = *(_DWORD *)(*v52 + 4);
          if (v112 == v113)
          {
            if (*(double *)(v110 + 12) >= *(double *)(v111 + 12)) {
              return result;
            }
          }
          else if (v112 >= v113)
          {
            return result;
          }
          uint64_t *v52 = v110;
          uint64_t *v53 = v111;
          uint64_t v122 = *v51;
          unsigned int v123 = *(_DWORD *)(*v51 + 4);
          if (v112 == v123)
          {
            if (*(double *)(v110 + 12) >= *(double *)(v122 + 12)) {
              return result;
            }
          }
          else if (v112 >= v123)
          {
            return result;
          }
          k[1] = v110;
          k[2] = v122;
          uint64_t v124 = *k;
          unsigned int v125 = *(_DWORD *)(*k + 4);
          if (v112 == v125)
          {
            if (*(double *)(v110 + 12) >= *(double *)(v124 + 12)) {
              return result;
            }
          }
          else if (v112 >= v125)
          {
            return result;
          }
          uint64_t *k = v110;
          k[1] = v124;
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v12 <= 191) {
      break;
    }
    if (!a3)
    {
      if (k == a2) {
        return result;
      }
      int64_t v72 = (v13 - 2) >> 1;
      int64_t v73 = v72;
      while (1)
      {
        int64_t v74 = v73;
        if (v72 < v73) {
          goto LABEL_161;
        }
        uint64_t v75 = (2 * v73) | 1;
        long long v76 = &k[v75];
        if (2 * v74 + 2 < (uint64_t)v13)
        {
          uint64_t v77 = v76[1];
          uint64_t result = *(unsigned int *)(*v76 + 4);
          unsigned int v78 = *(_DWORD *)(v77 + 4);
          if (result != v78)
          {
            if (result >= v78) {
              goto LABEL_143;
            }
LABEL_142:
            ++v76;
            uint64_t v75 = 2 * v74 + 2;
            goto LABEL_143;
          }
          if (*(double *)(*v76 + 12) < *(double *)(v77 + 12)) {
            goto LABEL_142;
          }
        }
LABEL_143:
        uint64_t v79 = *v76;
        uint64_t v80 = k[v74];
        unsigned int v81 = *(_DWORD *)(*v76 + 4);
        unsigned int v82 = *(_DWORD *)(v80 + 4);
        if (v81 == v82)
        {
          if (*(double *)(v79 + 12) >= *(double *)(v80 + 12)) {
            goto LABEL_147;
          }
        }
        else if (v81 >= v82)
        {
LABEL_147:
          k[v74] = v79;
          if (v72 < v75)
          {
LABEL_148:
            unint64_t v83 = v76;
LABEL_160:
            uint64_t *v83 = v80;
            goto LABEL_161;
          }
          while (2)
          {
            uint64_t v84 = 2 * v75;
            uint64_t v75 = (2 * v75) | 1;
            unint64_t v83 = &k[v75];
            uint64_t v85 = v84 + 2;
            if (v85 < (uint64_t)v13)
            {
              uint64_t v86 = v83[1];
              unsigned int v87 = *(_DWORD *)(*v83 + 4);
              unsigned int v88 = *(_DWORD *)(v86 + 4);
              if (v87 == v88)
              {
                if (*(double *)(*v83 + 12) >= *(double *)(v86 + 12)) {
                  goto LABEL_155;
                }
              }
              else if (v87 >= v88)
              {
                goto LABEL_155;
              }
              ++v83;
              uint64_t v75 = v85;
            }
LABEL_155:
            uint64_t v89 = *v83;
            uint64_t result = *(unsigned int *)(*v83 + 4);
            if (result == v82)
            {
              if (*(double *)(v89 + 12) < *(double *)(v80 + 12)) {
                goto LABEL_148;
              }
            }
            else if (result < v82)
            {
              goto LABEL_148;
            }
            *long long v76 = v89;
            long long v76 = v83;
            if (v72 < v75) {
              goto LABEL_160;
            }
            continue;
          }
        }
LABEL_161:
        int64_t v73 = v74 - 1;
        if (!v74)
        {
          uint64_t v90 = (unint64_t)v12 >> 3;
          while (1)
          {
            uint64_t v91 = 0;
            uint64_t v92 = *k;
            int v93 = k;
            do
            {
              unsigned int v94 = v93;
              v93 += v91 + 1;
              uint64_t v95 = 2 * v91;
              uint64_t v91 = (2 * v91) | 1;
              uint64_t v96 = v95 + 2;
              if (v96 >= v90) {
                goto LABEL_170;
              }
              uint64_t v97 = v93[1];
              uint64_t result = *(unsigned int *)(*v93 + 4);
              unsigned int v98 = *(_DWORD *)(v97 + 4);
              if (result != v98)
              {
                if (result >= v98) {
                  goto LABEL_170;
                }
LABEL_169:
                ++v93;
                uint64_t v91 = v96;
                goto LABEL_170;
              }
              if (*(double *)(*v93 + 12) < *(double *)(v97 + 12)) {
                goto LABEL_169;
              }
LABEL_170:
              *unsigned int v94 = *v93;
            }
            while (v91 <= (uint64_t)((unint64_t)(v90 - 2) >> 1));
            if (v93 == --a2) {
              goto LABEL_184;
            }
            *int v93 = *a2;
            *a2 = v92;
            uint64_t v99 = (char *)v93 - (char *)k + 8;
            if (v99 < 9) {
              goto LABEL_185;
            }
            unint64_t v100 = ((unint64_t)v99 >> 3) - 2;
            unint64_t v101 = v100 >> 1;
            unsigned int v102 = &k[v100 >> 1];
            uint64_t v103 = *v102;
            uint64_t v92 = *v93;
            unsigned int v104 = *(_DWORD *)(*v102 + 4);
            unsigned int v105 = *(_DWORD *)(*v93 + 4);
            if (v104 != v105)
            {
              if (v104 >= v105) {
                goto LABEL_185;
              }
LABEL_177:
              *int v93 = v103;
              if (v100 >= 2)
              {
                do
                {
                  unint64_t v106 = v101 - 1;
                  unint64_t v101 = (v101 - 1) >> 1;
                  int v93 = &k[v101];
                  uint64_t v107 = *v93;
                  unsigned int v108 = *(_DWORD *)(*v93 + 4);
                  if (v108 == v105)
                  {
                    if (*(double *)(v107 + 12) >= *(double *)(v92 + 12)) {
                      goto LABEL_178;
                    }
                  }
                  else if (v108 >= v105)
                  {
                    goto LABEL_178;
                  }
                  uint64_t *v102 = v107;
                  unsigned int v102 = &k[v101];
                }
                while (v106 > 1);
              }
              else
              {
LABEL_178:
                int v93 = v102;
              }
LABEL_184:
              *int v93 = v92;
              goto LABEL_185;
            }
            if (*(double *)(v103 + 12) < *(double *)(v92 + 12)) {
              goto LABEL_177;
            }
LABEL_185:
            if (v90-- <= 2) {
              return result;
            }
          }
        }
      }
    }
    unint64_t v14 = v13 >> 1;
    BOOL v15 = &k[v13 >> 1];
    if ((unint64_t)v12 >= 0x401)
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CA::MetadataFrameQueue::extract(double,double,AudioMetadataFrame &)::$_0 &,AudioMetadataEvent const**>(v9, &v9[v13 >> 1], a2 - 1);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CA::MetadataFrameQueue::extract(double,double,AudioMetadataFrame &)::$_0 &,AudioMetadataEvent const**>(v9 + 1, v15 - 1, a2 - 2);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CA::MetadataFrameQueue::extract(double,double,AudioMetadataFrame &)::$_0 &,AudioMetadataEvent const**>(v9 + 2, &v9[v14 + 1], a2 - 3);
      uint64_t result = (unint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CA::MetadataFrameQueue::extract(double,double,AudioMetadataFrame &)::$_0 &,AudioMetadataEvent const**>(v15 - 1, v15, &v9[v14 + 1]);
      uint64_t v16 = *v9;
      *unsigned int v9 = *v15;
      *BOOL v15 = v16;
    }
    else
    {
      uint64_t result = (unint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CA::MetadataFrameQueue::extract(double,double,AudioMetadataFrame &)::$_0 &,AudioMetadataEvent const**>(&v9[v13 >> 1], v9, a2 - 1);
    }
    --a3;
    uint64_t v17 = *v9;
    if (a4)
    {
      unsigned int v18 = *(_DWORD *)(v17 + 4);
LABEL_24:
      for (unsigned int i = v9 + 1; ; ++i)
      {
        uint64_t v25 = *i;
        unsigned int v26 = *(_DWORD *)(*i + 4);
        if (v26 != v18) {
          break;
        }
        if (*(double *)(v25 + 12) >= *(double *)(v17 + 12)) {
          goto LABEL_30;
        }
LABEL_29:
        ;
      }
      if (v26 < v18) {
        goto LABEL_29;
      }
LABEL_30:
      uint64_t v27 = i - 1;
      unsigned int j = a2 - 1;
      if (i - 1 != v9)
      {
        while (1)
        {
          unsigned int v29 = *(_DWORD *)(*j + 4);
          if (v29 == v18)
          {
            if (*(double *)(*j + 12) < *(double *)(v17 + 12)) {
              goto LABEL_45;
            }
          }
          else if (v29 < v18)
          {
            goto LABEL_45;
          }
          --j;
        }
      }
      unsigned int j = a2;
      if (i < a2)
      {
        for (unsigned int j = a2 - 1; ; --j)
        {
          unsigned int v30 = *(_DWORD *)(*j + 4);
          if (v30 == v18)
          {
            if (i >= j || *(double *)(*j + 12) < *(double *)(v17 + 12)) {
              break;
            }
          }
          else if (i >= j || v30 < v18)
          {
            break;
          }
        }
      }
LABEL_45:
      if (i >= j) {
        goto LABEL_59;
      }
      uint64_t v31 = *j;
      unint64_t v32 = (unint64_t)i;
      BOOL v33 = j;
      while (2)
      {
        *(void *)unint64_t v32 = v31;
        v32 += 8;
        *BOOL v33 = v25;
        while (2)
        {
          uint64_t v25 = *(void *)v32;
          unsigned int v34 = *(_DWORD *)(*(void *)v32 + 4);
          if (v34 == v18)
          {
            if (*(double *)(v25 + 12) >= *(double *)(v17 + 12)) {
              break;
            }
            goto LABEL_52;
          }
          if (v34 < v18)
          {
LABEL_52:
            v32 += 8;
            continue;
          }
          break;
        }
        uint64_t v27 = (uint64_t *)(v32 - 8);
        do
        {
          while (1)
          {
            uint64_t v35 = *--v33;
            uint64_t v31 = v35;
            unsigned int v36 = *(_DWORD *)(v35 + 4);
            if (v36 != v18) {
              break;
            }
            if (*(double *)(v31 + 12) < *(double *)(v17 + 12)) {
              goto LABEL_58;
            }
          }
        }
        while (v36 >= v18);
LABEL_58:
        if (v32 < (unint64_t)v33) {
          continue;
        }
        break;
      }
LABEL_59:
      if (v27 != v9) {
        *unsigned int v9 = *v27;
      }
      *uint64_t v27 = v17;
      if (i < j)
      {
LABEL_64:
        uint64_t result = std::__introsort<std::_ClassicAlgPolicy,CA::MetadataFrameQueue::extract(double,double,AudioMetadataFrame &)::$_0 &,AudioMetadataEvent const**,false>(v9, v27, a3, a4 & 1);
        a4 = 0;
        k = v27 + 1;
      }
      else
      {
        BOOL v37 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,CA::MetadataFrameQueue::extract(double,double,AudioMetadataFrame &)::$_0 &,AudioMetadataEvent const**>(v9, v27);
        k = v27 + 1;
        uint64_t result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,CA::MetadataFrameQueue::extract(double,double,AudioMetadataFrame &)::$_0 &,AudioMetadataEvent const**>(v27 + 1, a2);
        if (result)
        {
          a2 = v27;
          if (v37) {
            return result;
          }
          goto LABEL_2;
        }
        if (!v37) {
          goto LABEL_64;
        }
      }
    }
    else
    {
      uint64_t v19 = *(v9 - 1);
      unsigned int v20 = *(_DWORD *)(v19 + 4);
      unsigned int v18 = *(_DWORD *)(v17 + 4);
      if (v20 == v18)
      {
        unsigned int v18 = *(_DWORD *)(v19 + 4);
        if (*(double *)(v19 + 12) < *(double *)(v17 + 12)) {
          goto LABEL_24;
        }
      }
      else if (v20 < v18)
      {
        goto LABEL_24;
      }
      uint64_t v21 = *v10;
      unsigned int v22 = *(_DWORD *)(*v10 + 4);
      if (v18 == v22)
      {
        if (*(double *)(v17 + 12) < *(double *)(v21 + 12)) {
          goto LABEL_66;
        }
      }
      else if (v18 < v22)
      {
LABEL_66:
        for (k = v9 + 1; ; ++k)
        {
          unsigned int v38 = *(_DWORD *)(*k + 4);
          if (v18 == v38)
          {
            if (*(double *)(v17 + 12) < *(double *)(*k + 12)) {
              goto LABEL_72;
            }
          }
          else if (v18 < v38)
          {
            goto LABEL_72;
          }
        }
      }
      for (k = v9 + 1; k < a2; ++k)
      {
        unsigned int v23 = *(_DWORD *)(*k + 4);
        if (v18 == v23)
        {
          if (*(double *)(v17 + 12) < *(double *)(*k + 12)) {
            break;
          }
        }
        else if (v18 < v23)
        {
          break;
        }
      }
LABEL_72:
      m = a2;
      if (k < a2)
      {
        for (m = a2 - 1; ; --m)
        {
          if (v18 == v22)
          {
            if (*(double *)(v17 + 12) >= *(double *)(v21 + 12)) {
              break;
            }
          }
          else if (v18 >= v22)
          {
            break;
          }
          uint64_t v40 = *(m - 1);
          uint64_t v21 = v40;
          unsigned int v22 = *(_DWORD *)(v40 + 4);
        }
      }
      if (k >= m) {
        goto LABEL_91;
      }
      uint64_t v41 = *k;
      uint64_t v42 = *m;
      do
      {
        *k++ = v42;
        uint64_t *m = v41;
        while (1)
        {
          uint64_t v41 = *k;
          unsigned int v43 = *(_DWORD *)(*k + 4);
          if (v18 == v43) {
            break;
          }
          if (v18 < v43) {
            goto LABEL_88;
          }
LABEL_86:
          ++k;
        }
        if (*(double *)(v17 + 12) >= *(double *)(v41 + 12)) {
          goto LABEL_86;
        }
        do
        {
LABEL_88:
          while (1)
          {
            uint64_t v44 = *--m;
            uint64_t v42 = v44;
            unsigned int v45 = *(_DWORD *)(v44 + 4);
            if (v18 == v45) {
              break;
            }
            if (v18 >= v45) {
              goto LABEL_90;
            }
          }
        }
        while (*(double *)(v17 + 12) < *(double *)(v42 + 12));
LABEL_90:
        ;
      }
      while (k < m);
LABEL_91:
      uint64_t v46 = k - 1;
      BOOL v4 = k - 1 >= v9;
      BOOL v5 = k - 1 == v9;
      if (k - 1 != v9) {
        *unsigned int v9 = *v46;
      }
      a4 = 0;
      *uint64_t v46 = v17;
    }
  }
  uint64_t v58 = k + 1;
  BOOL v60 = k == a2 || v58 == a2;
  if ((a4 & 1) == 0)
  {
    if (v60) {
      return result;
    }
    while (1)
    {
      unint64_t v114 = v9;
      unsigned int v9 = v58;
      uint64_t v116 = *v114;
      uint64_t v115 = v114[1];
      unsigned int v117 = *(_DWORD *)(v115 + 4);
      unsigned int v118 = *(_DWORD *)(*v114 + 4);
      if (v117 == v118)
      {
        if (*(double *)(v115 + 12) < *(double *)(v116 + 12)) {
          goto LABEL_199;
        }
      }
      else if (v117 < v118)
      {
        do
        {
LABEL_199:
          while (1)
          {
            int v119 = v114;
            uint64_t v120 = *--v114;
            v114[2] = v116;
            uint64_t v116 = v120;
            unsigned int v121 = *(_DWORD *)(v120 + 4);
            if (v117 != v121) {
              break;
            }
            if (*(double *)(v115 + 12) >= *(double *)(v116 + 12)) {
              goto LABEL_203;
            }
          }
        }
        while (v117 < v121);
LABEL_203:
        *int v119 = v115;
      }
      uint64_t v58 = v9 + 1;
      if (v9 + 1 == a2) {
        return result;
      }
    }
  }
  if (v60) {
    return result;
  }
  uint64_t v61 = 0;
  uint64_t v62 = k;
  while (2)
  {
    unsigned int v63 = v62;
    uint64_t v62 = v58;
    uint64_t v65 = *v63;
    uint64_t v64 = v63[1];
    unsigned int v66 = *(_DWORD *)(v64 + 4);
    unsigned int v67 = *(_DWORD *)(*v63 + 4);
    if (v66 == v67)
    {
      if (*(double *)(v64 + 12) >= *(double *)(v65 + 12)) {
        goto LABEL_132;
      }
    }
    else if (v66 >= v67)
    {
      goto LABEL_132;
    }
    v63[1] = v65;
    uint64_t v68 = k;
    if (v63 == k) {
      goto LABEL_131;
    }
    uint64_t v69 = v61;
    while (2)
    {
      uint64_t v70 = *(uint64_t *)((char *)k + v69 - 8);
      unsigned int v71 = *(_DWORD *)(v70 + 4);
      if (v66 == v71)
      {
        if (*(double *)(v64 + 12) >= *(double *)(v70 + 12))
        {
          uint64_t v68 = v63;
          goto LABEL_131;
        }
LABEL_128:
        --v63;
        *(uint64_t *)((char *)k + v69) = v70;
        v69 -= 8;
        if (!v69)
        {
          uint64_t v68 = k;
          goto LABEL_131;
        }
        continue;
      }
      break;
    }
    if (v66 < v71) {
      goto LABEL_128;
    }
    uint64_t v68 = (uint64_t *)((char *)k + v69);
LABEL_131:
    *uint64_t v68 = v64;
LABEL_132:
    uint64_t v58 = v62 + 1;
    v61 += 8;
    if (v62 + 1 != a2) {
      continue;
    }
    return result;
  }
}

uint64_t *std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CA::MetadataFrameQueue::extract(double,double,AudioMetadataFrame &)::$_0 &,AudioMetadataEvent const**>(uint64_t *result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *result;
  unsigned int v5 = *(_DWORD *)(*a2 + 4);
  unsigned int v6 = *(_DWORD *)(*result + 4);
  if (v5 != v6)
  {
    if (v5 >= v6) {
      goto LABEL_3;
    }
LABEL_7:
    uint64_t v9 = *a3;
    unsigned int v10 = *(_DWORD *)(*a3 + 4);
    if (v10 == v5)
    {
      if (*(double *)(v9 + 12) >= *(double *)(v3 + 12))
      {
LABEL_9:
        *uint64_t result = v3;
        *a2 = v4;
        uint64_t v11 = *a3;
        unsigned int v12 = *(_DWORD *)(*a3 + 4);
        if (v12 == v6)
        {
          if (*(double *)(v11 + 12) >= *(double *)(v4 + 12)) {
            return result;
          }
        }
        else if (v12 >= v6)
        {
          return result;
        }
        *a2 = v11;
LABEL_20:
        *a3 = v4;
        return result;
      }
    }
    else if (v10 >= v5)
    {
      goto LABEL_9;
    }
    *uint64_t result = v9;
    goto LABEL_20;
  }
  if (*(double *)(v3 + 12) < *(double *)(v4 + 12)) {
    goto LABEL_7;
  }
LABEL_3:
  uint64_t v7 = *a3;
  unsigned int v8 = *(_DWORD *)(*a3 + 4);
  if (v8 == v5)
  {
    if (*(double *)(v7 + 12) >= *(double *)(v3 + 12)) {
      return result;
    }
  }
  else if (v8 >= v5)
  {
    return result;
  }
  *a2 = v7;
  *a3 = v3;
  uint64_t v13 = *a2;
  uint64_t v14 = *result;
  unsigned int v15 = *(_DWORD *)(*a2 + 4);
  unsigned int v16 = *(_DWORD *)(*result + 4);
  if (v15 == v16)
  {
    if (*(double *)(v13 + 12) < *(double *)(v14 + 12)) {
      goto LABEL_22;
    }
  }
  else if (v15 < v16)
  {
LABEL_22:
    *uint64_t result = v13;
    *a2 = v14;
  }
  return result;
}

uint64_t *std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,CA::MetadataFrameQueue::extract(double,double,AudioMetadataFrame &)::$_0 &,AudioMetadataEvent const**>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CA::MetadataFrameQueue::extract(double,double,AudioMetadataFrame &)::$_0 &,AudioMetadataEvent const**>(a1, a2, a3);
  uint64_t v9 = *a4;
  uint64_t v10 = *a3;
  unsigned int v11 = *(_DWORD *)(*a4 + 4);
  unsigned int v12 = *(_DWORD *)(*a3 + 4);
  if (v11 == v12)
  {
    if (*(double *)(v9 + 12) >= *(double *)(v10 + 12)) {
      return result;
    }
  }
  else if (v11 >= v12)
  {
    return result;
  }
  *a3 = v9;
  *a4 = v10;
  uint64_t v13 = *a3;
  uint64_t v14 = *a2;
  unsigned int v15 = *(_DWORD *)(*a3 + 4);
  unsigned int v16 = *(_DWORD *)(*a2 + 4);
  if (v15 == v16)
  {
    if (*(double *)(v13 + 12) >= *(double *)(v14 + 12)) {
      return result;
    }
  }
  else if (v15 >= v16)
  {
    return result;
  }
  *a2 = v13;
  *a3 = v14;
  uint64_t v17 = *a2;
  uint64_t v18 = *a1;
  unsigned int v19 = *(_DWORD *)(*a2 + 4);
  unsigned int v20 = *(_DWORD *)(*a1 + 4);
  if (v19 != v20)
  {
    if (v19 >= v20) {
      return result;
    }
    goto LABEL_13;
  }
  if (*(double *)(v17 + 12) < *(double *)(v18 + 12))
  {
LABEL_13:
    *a1 = v17;
    *a2 = v18;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,CA::MetadataFrameQueue::extract(double,double,AudioMetadataFrame &)::$_0 &,AudioMetadataEvent const**>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v6 = *(a2 - 1);
      uint64_t v7 = *a1;
      unsigned int v8 = *(_DWORD *)(v6 + 4);
      unsigned int v9 = *(_DWORD *)(*a1 + 4);
      if (v8 == v9)
      {
        if (*(double *)(v6 + 12) >= *(double *)(v7 + 12)) {
          return result;
        }
      }
      else if (v8 >= v9)
      {
        return result;
      }
      *a1 = v6;
      *(a2 - 1) = v7;
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CA::MetadataFrameQueue::extract(double,double,AudioMetadataFrame &)::$_0 &,AudioMetadataEvent const**>(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,CA::MetadataFrameQueue::extract(double,double,AudioMetadataFrame &)::$_0 &,AudioMetadataEvent const**>(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      uint64_t v10 = a1 + 1;
      unsigned int v11 = a1 + 2;
      unsigned int v12 = a1 + 3;
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,CA::MetadataFrameQueue::extract(double,double,AudioMetadataFrame &)::$_0 &,AudioMetadataEvent const**>(a1, a1 + 1, a1 + 2, a1 + 3);
      uint64_t v13 = *(a2 - 1);
      uint64_t v14 = a1[3];
      unsigned int v15 = *(_DWORD *)(v13 + 4);
      unsigned int v16 = *(_DWORD *)(v14 + 4);
      if (v15 == v16)
      {
        if (*(double *)(v13 + 12) >= *(double *)(v14 + 12)) {
          return 1;
        }
      }
      else if (v15 >= v16)
      {
        return 1;
      }
      *unsigned int v12 = v13;
      *(a2 - 1) = v14;
      uint64_t v29 = *v12;
      uint64_t v30 = *v11;
      unsigned int v31 = *(_DWORD *)(*v12 + 4);
      unsigned int v32 = *(_DWORD *)(*v11 + 4);
      if (v31 == v32)
      {
        if (*(double *)(v29 + 12) >= *(double *)(v30 + 12)) {
          return 1;
        }
      }
      else if (v31 >= v32)
      {
        return 1;
      }
      *unsigned int v11 = v29;
      *unsigned int v12 = v30;
      uint64_t v33 = *v10;
      unsigned int v34 = *(_DWORD *)(*v10 + 4);
      if (v31 == v34)
      {
        if (*(double *)(v29 + 12) >= *(double *)(v33 + 12)) {
          return 1;
        }
      }
      else if (v31 >= v34)
      {
        return 1;
      }
      a1[1] = v29;
      a1[2] = v33;
      uint64_t v35 = *a1;
      unsigned int v36 = *(_DWORD *)(*a1 + 4);
      if (v31 == v36)
      {
        if (*(double *)(v29 + 12) >= *(double *)(v35 + 12)) {
          return 1;
        }
      }
      else if (v31 >= v36)
      {
        return 1;
      }
      *a1 = v29;
      a1[1] = v35;
      return 1;
    default:
      uint64_t v17 = a1 + 2;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CA::MetadataFrameQueue::extract(double,double,AudioMetadataFrame &)::$_0 &,AudioMetadataEvent const**>(a1, a1 + 1, a1 + 2);
      uint64_t v18 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      uint64_t v19 = 0;
      int v20 = 0;
      break;
  }
  do
  {
    uint64_t v21 = *v18;
    uint64_t v22 = *v17;
    unsigned int v23 = *(_DWORD *)(*v18 + 4);
    unsigned int v24 = *(_DWORD *)(*v17 + 4);
    if (v23 == v24)
    {
      if (*(double *)(v21 + 12) >= *(double *)(v22 + 12)) {
        goto LABEL_25;
      }
    }
    else if (v23 >= v24)
    {
      goto LABEL_25;
    }
    *uint64_t v18 = v22;
    uint64_t v25 = a1;
    if (v17 == a1) {
      goto LABEL_24;
    }
    uint64_t v26 = v19;
    while (1)
    {
      uint64_t v27 = *(uint64_t *)((char *)a1 + v26 + 8);
      unsigned int v28 = *(_DWORD *)(v27 + 4);
      if (v23 == v28)
      {
        if (*(double *)(v21 + 12) >= *(double *)(v27 + 12))
        {
          uint64_t v25 = (uint64_t *)((char *)a1 + v26 + 16);
          goto LABEL_24;
        }
        goto LABEL_21;
      }
      if (v23 >= v28) {
        break;
      }
LABEL_21:
      --v17;
      *(uint64_t *)((char *)a1 + v26 + 16) = v27;
      v26 -= 8;
      if (v26 == -16)
      {
        uint64_t v25 = a1;
        goto LABEL_24;
      }
    }
    uint64_t v25 = v17;
LABEL_24:
    *uint64_t v25 = v21;
    if (++v20 == 8) {
      return v18 + 1 == a2;
    }
LABEL_25:
    uint64_t v17 = v18;
    v19 += 8;
    ++v18;
  }
  while (v18 != a2);
  return 1;
}

uint64_t (*AUInstanceBase::LookupMethod(AUInstanceBase *this))(char *a1, int (*a2)(void *, unsigned int *, const AudioTimeStamp *, unsigned int, unsigned int, AudioBufferList *), void *a3)
{
  uint64_t v1 = AUIB_Initialize;
  switch((int)this)
  {
    case 1:
      return (uint64_t (*)(char *, int (*)(void *, unsigned int *, const AudioTimeStamp *, unsigned int, unsigned int, AudioBufferList *), void *))v1;
    case 2:
      return (uint64_t (*)(char *, int (*)(void *, unsigned int *, const AudioTimeStamp *, unsigned int, unsigned int, AudioBufferList *), void *))AUIB_Uninitialize;
    case 3:
      return (uint64_t (*)(char *, int (*)(void *, unsigned int *, const AudioTimeStamp *, unsigned int, unsigned int, AudioBufferList *), void *))AUIB_GetPropertyInfo;
    case 4:
      return (uint64_t (*)(char *, int (*)(void *, unsigned int *, const AudioTimeStamp *, unsigned int, unsigned int, AudioBufferList *), void *))AUIB_GetProperty;
    case 5:
      return (uint64_t (*)(char *, int (*)(void *, unsigned int *, const AudioTimeStamp *, unsigned int, unsigned int, AudioBufferList *), void *))AUIB_SetProperty;
    case 6:
      return (uint64_t (*)(char *, int (*)(void *, unsigned int *, const AudioTimeStamp *, unsigned int, unsigned int, AudioBufferList *), void *))AUIB_GetParameter;
    case 7:
      return (uint64_t (*)(char *, int (*)(void *, unsigned int *, const AudioTimeStamp *, unsigned int, unsigned int, AudioBufferList *), void *))AUIB_SetParameter;
    case 8:
    case 12:
    case 13:
    case 19:
      return 0;
    case 9:
      return (uint64_t (*)(char *, int (*)(void *, unsigned int *, const AudioTimeStamp *, unsigned int, unsigned int, AudioBufferList *), void *))AUIB_Reset;
    case 10:
      return (uint64_t (*)(char *, int (*)(void *, unsigned int *, const AudioTimeStamp *, unsigned int, unsigned int, AudioBufferList *), void *))AUIB_AddPropertyListener;
    case 11:
      return (uint64_t (*)(char *, int (*)(void *, unsigned int *, const AudioTimeStamp *, unsigned int, unsigned int, AudioBufferList *), void *))AUIB_RemovePropertyListener;
    case 14:
      return (uint64_t (*)(char *, int (*)(void *, unsigned int *, const AudioTimeStamp *, unsigned int, unsigned int, AudioBufferList *), void *))AUIB_Render;
    case 15:
      return AUIB_AddRenderNotify;
    case 16:
      return AUIB_RemoveRenderNotify;
    case 17:
      return (uint64_t (*)(char *, int (*)(void *, unsigned int *, const AudioTimeStamp *, unsigned int, unsigned int, AudioBufferList *), void *))AUIB_ScheduleParameters;
    case 18:
      return (uint64_t (*)(char *, int (*)(void *, unsigned int *, const AudioTimeStamp *, unsigned int, unsigned int, AudioBufferList *), void *))AUIB_RemovePropertyListenerWithUserData;
    case 20:
      return (uint64_t (*)(char *, int (*)(void *, unsigned int *, const AudioTimeStamp *, unsigned int, unsigned int, AudioBufferList *), void *))AUIB_Process;
    case 21:
      return (uint64_t (*)(char *, int (*)(void *, unsigned int *, const AudioTimeStamp *, unsigned int, unsigned int, AudioBufferList *), void *))AUIB_ProcessMultiple;
    default:
      if (this != 0x7FFF) {
        return 0;
      }
      return (uint64_t (*)(char *, int (*)(void *, unsigned int *, const AudioTimeStamp *, unsigned int, unsigned int, AudioBufferList *), void *))AUIB_OpenAsync;
  }
}

uint64_t AUIB_Initialize(char *a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (a1) {
    uint64_t v1 = a1 - 8;
  }
  else {
    uint64_t v1 = 0;
  }
  uint64_t v2 = *(NSObject **)gAUInstanceLog();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    int v4 = 136315650;
    unsigned int v5 = "AUInstanceBase.cpp";
    __int16 v6 = 1024;
    int v7 = 92;
    __int16 v8 = 2048;
    unsigned int v9 = v1;
    _os_log_impl(&dword_18FEC0000, v2, OS_LOG_TYPE_DEBUG, "%25s:%-5d %p Initialize", (uint8_t *)&v4, 0x1Cu);
  }
  return (*(uint64_t (**)(char *))(*(void *)v1 + 56))(v1);
}

uint64_t gAUInstanceLog(void)
{
  if (atomic_load_explicit((atomic_ullong *volatile)gAUInstanceLog(void)::onceflag, memory_order_acquire) != -1)
  {
    uint64_t v3 = &v1;
    uint64_t v2 = &v3;
    std::__call_once(gAUInstanceLog(void)::onceflag, &v2, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<gAUInstanceLog(void)::$_0 &&>>);
  }
  return gAUInstanceLog(void)::global;
}

void std::__call_once_proxy[abi:ne180100]<std::tuple<gAUInstanceLog(void)::$_0 &&>>()
{
}

uint64_t AUIB_Uninitialize(char *a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (a1) {
    char v1 = a1 - 8;
  }
  else {
    char v1 = 0;
  }
  uint64_t v2 = *(NSObject **)gAUInstanceLog();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    int v4 = 136315650;
    unsigned int v5 = "AUInstanceBase.cpp";
    __int16 v6 = 1024;
    int v7 = 99;
    __int16 v8 = 2048;
    unsigned int v9 = v1;
    _os_log_impl(&dword_18FEC0000, v2, OS_LOG_TYPE_DEBUG, "%25s:%-5d %p Uninitialize", (uint8_t *)&v4, 0x1Cu);
  }
  (*(void (**)(char *))(*(void *)v1 + 64))(v1);
  return 0;
}

uint64_t AUIB_Reset(char *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (a1) {
    unsigned int v5 = a1 - 8;
  }
  else {
    unsigned int v5 = 0;
  }
  __int16 v6 = *(NSObject **)gAUInstanceLog();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    int v8 = 136315650;
    unsigned int v9 = "AUInstanceBase.cpp";
    __int16 v10 = 1024;
    int v11 = 107;
    __int16 v12 = 2048;
    uint64_t v13 = v5;
    _os_log_impl(&dword_18FEC0000, v6, OS_LOG_TYPE_DEBUG, "%25s:%-5d %p Reset", (uint8_t *)&v8, 0x1Cu);
  }
  return (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)v5 + 72))(v5, a2, a3);
}

uint64_t AUIB_GetPropertyInfo(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int *a5, unsigned __int8 *a6)
{
  unsigned int v11 = 0;
  unsigned __int8 v10 = 0;
  if (a1) {
    int v8 = a1 - 8;
  }
  else {
    int v8 = 0;
  }
  uint64_t result = (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t, unsigned int *, unsigned __int8 *))(*(void *)v8 + 80))(v8, a2, a3, a4, &v11, &v10);
  if (a5) {
    *a5 = v11;
  }
  if (a6) {
    *a6 = v10;
  }
  return result;
}

uint64_t AUIB_GetProperty(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, unsigned int *a6)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (!a6)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      uint64_t v14 = "AUInstanceBase.cpp";
      __int16 v15 = 1024;
      int v16 = 130;
      __int16 v17 = 2080;
      uint64_t v18 = "AudioUnitGetProperty: null size pointer";
      unsigned __int8 v10 = MEMORY[0x1E4F14500];
LABEL_18:
      _os_log_impl(&dword_18FEC0000, v10, OS_LOG_TYPE_ERROR, "%25s:%-5d  ca_debug_string: %s", buf, 0x1Cu);
    }
    return 4294967246;
  }
  if (a5)
  {
    if (*a6)
    {
      if (a1) {
        int v7 = a1 - 8;
      }
      else {
        int v7 = 0;
      }
      int v8 = *(uint64_t (**)(void))(*(void *)v7 + 88);
      return v8();
    }
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      uint64_t v14 = "AUInstanceBase.cpp";
      __int16 v15 = 1024;
      int v16 = 137;
      __int16 v17 = 2080;
      uint64_t v18 = "AudioUnitGetProperty: zero size on entry";
      unsigned __int8 v10 = MEMORY[0x1E4F14500];
      goto LABEL_18;
    }
    return 4294967246;
  }
  *(_DWORD *)buf = 0;
  char v12 = 0;
  if (a1) {
    unsigned int v11 = a1 - 8;
  }
  else {
    unsigned int v11 = 0;
  }
  uint64_t result = (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t, uint8_t *, char *))(*(void *)v11 + 80))(v11, a2, a3, a4, buf, &v12);
  *a6 = *(_DWORD *)buf;
  return result;
}

uint64_t AUIB_SetProperty(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, const void *a5)
{
  if (a1) {
    unsigned int v5 = a1 - 8;
  }
  else {
    unsigned int v5 = 0;
  }
  return (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t, const void *))(*(void *)v5 + 96))(v5, a2, a3, a4, a5);
}

uint64_t AUIB_AddPropertyListener(char *a1, unsigned int a2, void (*a3)(void *, OpaqueAudioComponentInstance *, unsigned int, unsigned int, unsigned int), void *a4)
{
  if (!a3) {
    return 4294967246;
  }
  if (a1) {
    int v4 = a1 - 8;
  }
  else {
    int v4 = 0;
  }
  return (*(uint64_t (**)(void))(*(void *)v4 + 104))();
}

uint64_t AUIB_RemovePropertyListener(char *a1, unsigned int a2, void (*a3)(void *, OpaqueAudioComponentInstance *, unsigned int, unsigned int, unsigned int))
{
  if (!a3) {
    return 4294967246;
  }
  if (a1) {
    uint64_t v3 = a1 - 8;
  }
  else {
    uint64_t v3 = 0;
  }
  return (*(uint64_t (**)(void))(*(void *)v3 + 112))();
}

uint64_t AUIB_RemovePropertyListenerWithUserData(char *a1, unsigned int a2, void (*a3)(void *, OpaqueAudioComponentInstance *, unsigned int, unsigned int, unsigned int), void *a4)
{
  if (!a3) {
    return 4294967246;
  }
  if (a1) {
    int v4 = a1 - 8;
  }
  else {
    int v4 = 0;
  }
  return (*(uint64_t (**)(void))(*(void *)v4 + 112))();
}

uint64_t AUIB_AddRenderNotify(char *a1, int (*a2)(void *, unsigned int *, const AudioTimeStamp *, unsigned int, unsigned int, AudioBufferList *), void *a3)
{
  if (!a2) {
    return 4294967246;
  }
  if (a1) {
    uint64_t v3 = a1 - 8;
  }
  else {
    uint64_t v3 = 0;
  }
  return (*(uint64_t (**)(void))(*(void *)v3 + 120))();
}

uint64_t AUIB_RemoveRenderNotify(char *a1, int (*a2)(void *, unsigned int *, const AudioTimeStamp *, unsigned int, unsigned int, AudioBufferList *), void *a3)
{
  if (!a2) {
    return 4294967246;
  }
  if (a1) {
    uint64_t v3 = a1 - 8;
  }
  else {
    uint64_t v3 = 0;
  }
  return (*(uint64_t (**)(void))(*(void *)v3 + 128))();
}

uint64_t AUIB_GetParameter(char *a1, unsigned int a2, unsigned int a3, unsigned int a4, float *a5)
{
  if (!a5) {
    return 4294967246;
  }
  if (a1) {
    unsigned int v5 = a1 - 8;
  }
  else {
    unsigned int v5 = 0;
  }
  return (*(uint64_t (**)(void))(*(void *)v5 + 136))();
}

uint64_t AUIB_SetParameter(char *a1, __n128 a2)
{
  if (a1) {
    uint64_t v2 = a1 - 8;
  }
  else {
    uint64_t v2 = 0;
  }
  return (*(uint64_t (**)(__n128))(*(void *)v2 + 144))(a2);
}

uint64_t AUIB_Render(char *a1, unsigned int *a2, const AudioTimeStamp *a3, unsigned int a4, unsigned int a5, AudioBufferList *a6)
{
  uint64_t v6 = 4294967246;
  if (a3 && a6)
  {
    if (!a2) {
      a2 = (unsigned int *)&v9;
    }
    int v9 = 0;
    if (a1) {
      int v7 = a1 - 8;
    }
    else {
      int v7 = 0;
    }
    return (*(uint64_t (**)(char *, unsigned int *))(*(void *)v7 + 152))(v7, a2);
  }
  return v6;
}

uint64_t AUIB_Process(char *a1, unsigned int *a2, const AudioTimeStamp *a3, unsigned int a4, AudioBufferList *a5)
{
  int v9 = a5;
  uint64_t v5 = 4294967246;
  if (a3 && a5)
  {
    if (!a2) {
      a2 = (unsigned int *)&v8;
    }
    int v8 = 0;
    if (a1) {
      uint64_t v6 = a1 - 8;
    }
    else {
      uint64_t v6 = 0;
    }
    return (*(uint64_t (**)(char *, unsigned int *))(*(void *)v6 + 160))(v6, a2);
  }
  return v5;
}

uint64_t AUIB_ProcessMultiple(char *a1, unsigned int *a2, const AudioTimeStamp *a3, unsigned int a4, unsigned int a5, const AudioBufferList **a6, unsigned int a7, AudioBufferList **a8)
{
  uint64_t result = 4294967246;
  if (a3 && a6 && a8)
  {
    if (!a2) {
      a2 = (unsigned int *)&v11;
    }
    int v11 = 0;
    if (a1) {
      unsigned __int8 v10 = a1 - 8;
    }
    else {
      unsigned __int8 v10 = 0;
    }
    return (*(uint64_t (**)(char *, unsigned int *))(*(void *)v10 + 160))(v10, a2);
  }
  return result;
}

uint64_t AUIB_ScheduleParameters(char *a1, const AudioUnitParameterEvent *a2, int a3)
{
  if (!a3) {
    return 0;
  }
  if (!a2) {
    return 4294967246;
  }
  if (a1) {
    uint64_t v3 = a1 - 8;
  }
  else {
    uint64_t v3 = 0;
  }
  return (*(uint64_t (**)(void))(*(void *)v3 + 168))();
}

uint64_t AUIB_OpenAsync(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a1) {
    uint64_t v7 = a1 - 8;
  }
  else {
    uint64_t v7 = 0;
  }
  int v8 = *(NSObject **)gAUInstanceLog();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    int v10 = 136315650;
    int v11 = "AUInstanceBase.cpp";
    __int16 v12 = 1024;
    int v13 = 69;
    __int16 v14 = 2048;
    uint64_t v15 = v7;
    _os_log_impl(&dword_18FEC0000, v8, OS_LOG_TYPE_DEBUG, "%25s:%-5d %p OpenAsync", (uint8_t *)&v10, 0x1Cu);
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v7 + 40))(v7, a2, a3, a4);
}

uint64_t (*AUInstanceBase::LookupMethod_Music(AUInstanceBase *this))(char *a1, const unsigned __int8 *a2)
{
  char v1 = AUIB_MIDIEvent;
  switch(this)
  {
    case 0x101:
      return (uint64_t (*)(char *, const unsigned __int8 *))v1;
    case 0x107:
      return (uint64_t (*)(char *, const unsigned __int8 *))AUIB_MIDIEventList;
    case 0x102:
      return AUIB_SysEx;
  }
  return (uint64_t (*)(char *, const unsigned __int8 *))AUInstanceBase::LookupMethod(this);
}

uint64_t AUIB_MIDIEvent(char *a1)
{
  if (a1) {
    char v1 = a1 - 8;
  }
  else {
    char v1 = 0;
  }
  return (*(uint64_t (**)(void))(*(void *)v1 + 192))();
}

uint64_t AUIB_SysEx(char *a1, const unsigned __int8 *a2)
{
  if (a1) {
    uint64_t v2 = a1 - 8;
  }
  else {
    uint64_t v2 = 0;
  }
  return (*(uint64_t (**)(char *, const unsigned __int8 *))(*(void *)v2 + 200))(v2, a2);
}

uint64_t AUIB_MIDIEventList(char *a1, uint64_t a2, const MIDIEventList *a3)
{
  if (a1) {
    uint64_t v3 = a1 - 8;
  }
  else {
    uint64_t v3 = 0;
  }
  return (*(uint64_t (**)(char *, uint64_t, const MIDIEventList *))(*(void *)v3 + 208))(v3, a2, a3);
}

uint64_t (*AUInstanceBase::LookupMethod_Output(AUInstanceBase *this))(char *a1)
{
  char v1 = AUIB_Start;
  if (this == 513) {
    return v1;
  }
  if (this == 514) {
    return AUIB_Stop;
  }
  return (uint64_t (*)(char *))AUInstanceBase::LookupMethod(this);
}

uint64_t AUIB_Start(char *a1)
{
  if (a1) {
    char v1 = a1 - 8;
  }
  else {
    char v1 = 0;
  }
  return (*(uint64_t (**)(void))(*(void *)v1 + 176))();
}

uint64_t AUIB_Stop(char *a1)
{
  if (a1) {
    char v1 = a1 - 8;
  }
  else {
    char v1 = 0;
  }
  return (*(uint64_t (**)(void))(*(void *)v1 + 184))();
}

uint64_t AUIB_Close(char *a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (a1) {
    char v1 = a1 - 8;
  }
  else {
    char v1 = 0;
  }
  uint64_t v2 = *(NSObject **)gAUInstanceLog();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    int v5 = 136315650;
    uint64_t v6 = "AUInstanceBase.cpp";
    __int16 v7 = 1024;
    int v8 = 83;
    __int16 v9 = 2048;
    int v10 = v1;
    _os_log_impl(&dword_18FEC0000, v2, OS_LOG_TYPE_DEBUG, "%25s:%-5d %p Close", (uint8_t *)&v5, 0x1Cu);
  }
  uint64_t v3 = (*(uint64_t (**)(char *))(*(void *)v1 + 48))(v1);
  (*(void (**)(char *))(*(void *)v1 + 8))(v1);
  return v3;
}

uint64_t AUIB_Open(char *a1, OpaqueAudioComponentInstance *a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (a1) {
    uint64_t v3 = a1 - 8;
  }
  else {
    uint64_t v3 = 0;
  }
  int v4 = *(NSObject **)gAUInstanceLog();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    int v6 = 136315650;
    __int16 v7 = "AUInstanceBase.cpp";
    __int16 v8 = 1024;
    int v9 = 76;
    __int16 v10 = 2048;
    uint64_t v11 = v3;
    _os_log_impl(&dword_18FEC0000, v4, OS_LOG_TYPE_DEBUG, "%25s:%-5d %p Open", (uint8_t *)&v6, 0x1Cu);
  }
  return (*(uint64_t (**)(char *, OpaqueAudioComponentInstance *))(*(void *)v3 + 32))(v3, a2);
}

uint64_t std::__optional_destruct_base<CA::AudioBuffers,false>::~__optional_destruct_base[abi:ne180100](uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8)) {
    ExtendedAudioBufferList_Destroy(*(std::pmr **)a1);
  }
  return a1;
}

OpaqueExtAudioFile *AudioConverterCapturer::setDecompressionCookie(AudioConverterCapturer *this, const void *inPropertyData, UInt32 a3)
{
  if (*((_DWORD *)this + 8) == 1819304813) {
    std::terminate();
  }
  if (*((void *)this + 13))
  {
    uint64_t v3 = (OpaqueAudioFileID *)*((void *)this + 13);
    return (OpaqueExtAudioFile *)AudioFileSetProperty(v3, 0x6D676963u, a3, inPropertyData);
  }
  else
  {
    uint64_t result = (OpaqueExtAudioFile *)*((void *)this + 14);
    if (result)
    {
      return (OpaqueExtAudioFile *)ExtAudioFileSetProperty(result, 0x6D676963u, a3, inPropertyData);
    }
  }
  return result;
}

OpaqueExtAudioFile *AudioConverterCapturer::write(AudioConverterCapturer *this, const AudioBufferList *ioData, const AudioStreamPacketDescription *inPacketDescriptions, UInt32 a4)
{
  uint64_t result = (OpaqueExtAudioFile *)*((void *)this + 14);
  if (result)
  {
    if (*((_DWORD *)this + 8) != 1819304813) {
      goto LABEL_28;
    }
    UInt32 mDataByteSize = ioData->mBuffers[0].mDataByteSize;
    UInt32 v8 = *((_DWORD *)this + 12);
    if (v8 > mDataByteSize) {
      return result;
    }
    uint64_t v9 = mDataByteSize / v8;
    if (*((unsigned char *)this + 129))
    {
      unsigned int v10 = *((_DWORD *)this + 22) * v9;
      if (v10 > *((_DWORD *)this + 33))
      {
        if (*((unsigned char *)this + 144))
        {
          ExtendedAudioBufferList_Destroy(*((std::pmr **)this + 17));
          *((unsigned char *)this + 144) = 0;
        }
        CA::AudioBuffers::AudioBuffers((AudioConverterCapturer *)((char *)this + 136), (const AudioStreamBasicDescription *)((char *)this + 64), v10);
        *((unsigned char *)this + 144) = 1;
        *((_DWORD *)this + 33) = v9;
      }
      uint64_t v11 = CA::AudioBuffers::Prepare(*((CA::AudioBuffers **)this + 17), *((_DWORD *)this + 23), v10);
      uint64_t v12 = *((void *)this + 19);
      *(void *)ioPropertyDataSize = ioData;
      UInt32 mNumberBuffers = ioData->mNumberBuffers;
      char v29 = 0;
      unsigned int v24 = v11;
      unsigned int v25 = *v11;
      char v26 = 0;
      (*(void (**)(uint64_t, uint64_t, UInt32 *, unsigned int **))(*(void *)v12 + 160))(v12, v9, ioPropertyDataSize, &v24);
      if (!*((unsigned char *)this + 128))
      {
LABEL_22:
        uint64_t result = (OpaqueExtAudioFile *)*((void *)this + 14);
        UInt32 v22 = v9;
        unsigned int v23 = (const AudioBufferList *)v11;
LABEL_24:
        uint64_t result = (OpaqueExtAudioFile *)ExtAudioFileWrite(result, v22, v23);
        goto LABEL_25;
      }
      if (*((void *)this + 15))
      {
LABEL_13:
        uint64_t result = (OpaqueExtAudioFile *)*((void *)this + 14);
        UInt32 v15 = v9;
        uint64_t v16 = (const AudioBufferList *)v11;
LABEL_21:
        uint64_t result = (OpaqueExtAudioFile *)ExtAudioFileWriteAsync(result, v15, v16);
LABEL_25:
        uint64_t v20 = *((void *)this + 15) + v9;
        goto LABEL_26;
      }
      ioPropertyDataSize[0] = 4;
      LODWORD(v24) = 0;
      if (!ExtAudioFileGetProperty(*((ExtAudioFileRef *)this + 14), 0x696F6273u, ioPropertyDataSize, &v24))
      {
        unsigned int v13 = v11[3];
        BOOL v14 = v13 >= v24;
        *((unsigned char *)this + 128) = v13 < v24;
        if (!v14) {
          goto LABEL_13;
        }
        goto LABEL_22;
      }
LABEL_28:
      std::terminate();
    }
    if (*((unsigned char *)this + 128))
    {
      if (*((void *)this + 15)) {
        goto LABEL_20;
      }
      ioPropertyDataSize[0] = 4;
      LODWORD(v24) = 0;
      if (ExtAudioFileGetProperty(result, 0x696F6273u, ioPropertyDataSize, &v24)) {
        goto LABEL_28;
      }
      UInt32 v21 = ioData->mBuffers[0].mDataByteSize;
      uint64_t result = (OpaqueExtAudioFile *)*((void *)this + 14);
      BOOL v14 = v21 >= v24;
      *((unsigned char *)this + 128) = v21 < v24;
      if (!v14)
      {
LABEL_20:
        UInt32 v15 = v9;
        uint64_t v16 = ioData;
        goto LABEL_21;
      }
    }
    UInt32 v22 = v9;
    unsigned int v23 = ioData;
    goto LABEL_24;
  }
  mData = ioData->mBuffers[0].mData;
  UInt32 v19 = ioData->mBuffers[0].mDataByteSize;
  ioPropertyDataSize[0] = a4;
  uint64_t result = (OpaqueExtAudioFile *)AudioFileWritePackets(*((AudioFileID *)this + 13), 0, v19, inPacketDescriptions, *((void *)this + 15), ioPropertyDataSize, mData);
  if (result) {
    return result;
  }
  uint64_t v20 = *((void *)this + 15) + ioPropertyDataSize[0];
LABEL_26:
  *((void *)this + 15) = v20;
  return result;
}

uint64_t acv2::CBRConverter::GetPropertyInfo(acv2::CBRConverter *this, int a2, unsigned int *a3, unsigned __int8 *a4)
{
  uint64_t result = 1886547824;
  if (a2 <= 1836016242)
  {
    if (a2 != 1667850867 && a2 != 1668244083)
    {
      int v6 = 1835623027;
      goto LABEL_11;
    }
  }
  else if (a2 > 2020175986)
  {
    if (a2 != 2020569203)
    {
      unsigned __int16 v5 = 28787;
      goto LABEL_10;
    }
  }
  else if (a2 != 1836016243)
  {
    unsigned __int16 v5 = 25203;
LABEL_10:
    int v6 = v5 | 0x78690000;
LABEL_11:
    if (a2 != v6) {
      return result;
    }
  }
  if (a3) {
    *a3 = 4;
  }
  uint64_t result = 0;
  if (a4) {
    *a4 = 0;
  }
  return result;
}

void sub_190179440(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1901797C0(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_pointer<APComponent_FromBundle_Base *,std::shared_ptr<APComponent_FromBundle_Base>::__shared_ptr_default_delete<APComponent_FromBundle_Base,APComponent_FromBundle_Base>,std::allocator<APComponent_FromBundle_Base>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

void std::__shared_ptr_pointer<APComponent_FromBundle_Base *,std::shared_ptr<APComponent_FromBundle_Base>::__shared_ptr_default_delete<APComponent_FromBundle_Base,APComponent_FromBundle_Base>,std::allocator<APComponent_FromBundle_Base>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x192FC8940);
}

void sub_1901799FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_190179B08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_190179CF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double modDate(NSString *a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = [MEMORY[0x1E4F28CB8] defaultManager];
  uint64_t v3 = [v2 attributesOfItemAtPath:v1 error:0];

  double v4 = 0.0;
  if (v3)
  {
    unsigned __int16 v5 = [v3 objectForKeyedSubscript:*MEMORY[0x1E4F28310]];
    int v6 = v5;
    if (v5)
    {
      [v5 timeIntervalSinceReferenceDate];
      double v4 = v7;
    }
  }

  return v4;
}

void sub_190179DD4(_Unwind_Exception *a1)
{
  double v4 = v3;

  _Unwind_Resume(a1);
}

void sub_19017A0A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_19017A208(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t eventStreamCallback(const __FSEventStream *a1, void *a2, unint64_t a3, void *a4, const unsigned int *a5, const unint64_t *a6)
{
  return [a2 eventStreamCallback:a4 flags:a5];
}

void sub_19017A508(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_19017AC58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void ****a19, uint64_t a20,uint64_t a21,uint64_t a22,void ***a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void **a45)
{
  a19 = &a23;
  std::vector<std::shared_ptr<CA::ADMPackFormat>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a19);
  a23 = &a45;
  std::vector<std::shared_ptr<CA::ADMPackFormat>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a23);
  a45 = (void **)&a35;
  std::vector<std::shared_ptr<CA::ADMPackFormat>>::__destroy_vector::operator()[abi:ne180100](&a45);
  a45 = (void **)&a39;
  std::vector<std::shared_ptr<CA::ADMPackFormat>>::__destroy_vector::operator()[abi:ne180100](&a45);

  _Unwind_Resume(a1);
}

void sub_19017AE44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_19017AF80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_19017B034(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_19017B0A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)_ACPluginDBDirectory;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_19017B150(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *std::__function::__value_func<void ()(AudioComponentVector &,AudioComponentVector &)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_19017B468(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_19017B8B0(_Unwind_Exception *a1)
{
  STACK[0x270] = v1;
  std::vector<std::shared_ptr<CA::ADMPackFormat>>::__destroy_vector::operator()[abi:ne180100]((void ***)&STACK[0x270]);
  _Unwind_Resume(a1);
}

void sub_19017B9B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_19017BAA4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_19017BB00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void anonymous namespace'::addNewTypes(__int32 **a1, const void *a2, uint64_t a3, __int32 **a4)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  std::vector<unsigned int>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>(a1, a2, a3, (a3 - (uint64_t)a2) >> 2);
  int v6 = *a4;
  double v7 = a4[1];
  if (*a4 != v7)
  {
    UInt32 v8 = *a1;
    uint64_t v9 = a1[1];
    do
    {
      __int32 v10 = *v6;
      uint64_t v11 = wmemchr(v8, *v6, v9 - v8);
      if (v11) {
        uint64_t v12 = v11;
      }
      else {
        uint64_t v12 = v9;
      }
      uint64_t v9 = a1[1];
      if (v12 == v9)
      {
        unint64_t v13 = (unint64_t)a1[2];
        if ((unint64_t)v12 >= v13)
        {
          BOOL v14 = *a1;
          uint64_t v15 = v9 - *a1;
          unint64_t v16 = v15 + 1;
          if ((unint64_t)(v15 + 1) >> 62) {
            std::vector<float>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v17 = v13 - (void)v14;
          if (v17 >> 1 > v16) {
            unint64_t v16 = v17 >> 1;
          }
          if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v18 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v18 = v16;
          }
          if (v18) {
            unint64_t v18 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v18);
          }
          else {
            uint64_t v19 = 0;
          }
          UInt32 v8 = (__int32 *)(v18 + 4 * v15);
          *UInt32 v8 = v10;
          uint64_t v9 = v8 + 1;
          while (v12 != v14)
          {
            __int32 v20 = *--v12;
            *--UInt32 v8 = v20;
          }
          *a1 = v8;
          a1[1] = v9;
          a1[2] = (__int32 *)(v18 + 4 * v19);
          if (v14) {
            operator delete(v14);
          }
        }
        else
        {
          *uint64_t v12 = v10;
          uint64_t v9 = v12 + 1;
        }
        a1[1] = v9;
      }
      ++v6;
    }
    while (v6 != v7);
  }
}

void sub_19017BC54(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    *(void *)(v1 + 8) = v2;
    operator delete(v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::optional<std::vector<unsigned int>>::operator=[abi:ne180100]<std::vector<unsigned int>,void>(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 24))
  {
    double v4 = *(void **)a1;
    if (*(void *)a1)
    {
      *(void *)(a1 + 8) = v4;
      operator delete(v4);
      *(void *)a1 = 0;
      *(void *)(a1 + 8) = 0;
      *(void *)(a1 + 16) = 0;
    }
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(void *)(a1 + 16) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(void *)(a1 + 16) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    *(unsigned char *)(a1 + 24) = 1;
  }
  return a1;
}

void AudioFileAllowListFilter::AudioFileAllowListFilter(__CFDictionary const*)::$_3::__invoke(__CFString *a1, uint64_t a2)
{
  uint64_t v3 = v4;
  std::vector<unsigned int>::__insert_with_size[abi:ne180100]<std::__wrap_iter<unsigned int const*>,std::__wrap_iter<unsigned int const*>>(a2, *(char **)(a2 + 8), v4, v5, (v5 - v4) >> 2);
  if (v3)
  {
    operator delete(v3);
  }
}

void sub_19017BD80(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

double anonymous namespace'::GetTypesForStringInput(_anonymous_namespace_ *this, AudioFilePropertyID inPropertyID, const __CFString *a3)
{
  CFStringRef inSpecifier = a3;
  UInt32 outDataSize = 0;
  if (AudioFileGetGlobalInfoSize(inPropertyID, 8u, &inSpecifier, &outDataSize))
  {
    *(void *)this = 0;
    *((void *)this + 1) = 0;
    *((void *)this + 2) = 0;
  }
  else
  {
    std::vector<unsigned int>::vector(&outPropertyData, (unint64_t)outDataSize >> 2);
    if (AudioFileGetGlobalInfo(inPropertyID, 8u, &inSpecifier, &outDataSize, outPropertyData.__begin_))
    {
      *(void *)this = 0;
      *((void *)this + 1) = 0;
      *((void *)this + 2) = 0;
      if (outPropertyData.__begin_)
      {
        outPropertyData.__end_ = outPropertyData.__begin_;
        operator delete(outPropertyData.__begin_);
      }
    }
    else
    {
      double result = *(double *)&outPropertyData.__begin_;
      *(std::vector<unsigned int> *)this = outPropertyData;
    }
  }
  return result;
}

void sub_19017BE48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<unsigned int>::__insert_with_size[abi:ne180100]<std::__wrap_iter<unsigned int const*>,std::__wrap_iter<unsigned int const*>>(uint64_t a1, char *__dst, char *__src, char *a4, uint64_t a5)
{
  if (a5 < 1) {
    return;
  }
  int v6 = __src;
  unint64_t v10 = *(void *)(a1 + 8);
  uint64_t v9 = *(void *)(a1 + 16);
  if (a5 > (uint64_t)(v9 - v10) >> 2)
  {
    uint64_t v11 = *(char **)a1;
    unint64_t v12 = a5 + ((uint64_t)(v10 - *(void *)a1) >> 2);
    if (v12 >> 62) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v13 = (__dst - v11) >> 2;
    uint64_t v14 = v9 - (void)v11;
    if (v14 >> 1 > v12) {
      unint64_t v12 = v14 >> 1;
    }
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v15 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v15 = v12;
    }
    if (v15) {
      unint64_t v15 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v15);
    }
    else {
      uint64_t v16 = 0;
    }
    char v26 = (_DWORD *)(v15 + 4 * v13);
    uint64_t v27 = (char *)&v26[a5];
    uint64_t v28 = 4 * a5;
    char v29 = v26;
    do
    {
      int v30 = *(_DWORD *)v6;
      v6 += 4;
      *v29++ = v30;
      v28 -= 4;
    }
    while (v28);
    unsigned int v31 = *(char **)a1;
    if (*(char **)a1 != __dst)
    {
      unsigned int v32 = __dst;
      do
      {
        int v33 = *((_DWORD *)v32 - 1);
        v32 -= 4;
        *--char v26 = v33;
      }
      while (v32 != v31);
    }
    unint64_t v34 = v15 + 4 * v16;
    uint64_t v35 = *(unsigned char **)(a1 + 8);
    uint64_t v36 = v35 - __dst;
    if (v35 != __dst) {
      memmove(v27, __dst, v35 - __dst);
    }
    BOOL v37 = *(char **)a1;
    *(void *)a1 = v26;
    *(void *)(a1 + 8) = &v27[v36];
    *(void *)(a1 + 16) = v34;
    if (v37)
    {
      operator delete(v37);
    }
    return;
  }
  uint64_t v17 = v10 - (void)__dst;
  uint64_t v18 = (uint64_t)(v10 - (void)__dst) >> 2;
  if (v18 >= a5)
  {
    uint64_t v19 = &__src[4 * a5];
    UInt32 v21 = *(char **)(a1 + 8);
LABEL_17:
    UInt32 v22 = &__dst[4 * a5];
    unsigned int v23 = &v21[-4 * a5];
    unsigned int v24 = v21;
    if ((unint64_t)v23 < v10)
    {
      unsigned int v24 = v21;
      do
      {
        int v25 = *(_DWORD *)v23;
        v23 += 4;
        *(_DWORD *)unsigned int v24 = v25;
        v24 += 4;
      }
      while ((unint64_t)v23 < v10);
    }
    *(void *)(a1 + 8) = v24;
    if (v21 != v22) {
      memmove(&v21[-4 * ((v21 - v22) >> 2)], __dst, v21 - v22);
    }
    if (v19 != v6)
    {
      memmove(__dst, v6, v19 - v6);
    }
    return;
  }
  uint64_t v19 = &__src[4 * v18];
  int64_t v20 = a4 - v19;
  if (a4 != v19) {
    memmove(*(void **)(a1 + 8), &__src[4 * v18], a4 - v19);
  }
  UInt32 v21 = (char *)(v10 + v20);
  *(void *)(a1 + 8) = v10 + v20;
  if (v17 >= 1) {
    goto LABEL_17;
  }
}

void AudioFileAllowListFilter::AudioFileAllowListFilter(__CFDictionary const*)::$_2::__invoke(__CFString *a1, uint64_t a2)
{
  uint64_t v3 = v4;
  std::vector<unsigned int>::__insert_with_size[abi:ne180100]<std::__wrap_iter<unsigned int const*>,std::__wrap_iter<unsigned int const*>>(a2, *(char **)(a2 + 8), v4, v5, (v5 - v4) >> 2);
  if (v3)
  {
    operator delete(v3);
  }
}

void sub_19017C0F4(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

void AudioFileAllowListFilter::AudioFileAllowListFilter(__CFDictionary const*)::$_1::__invoke(__CFString *a1, uint64_t a2)
{
  uint64_t v3 = v4;
  std::vector<unsigned int>::__insert_with_size[abi:ne180100]<std::__wrap_iter<unsigned int const*>,std::__wrap_iter<unsigned int const*>>(a2, *(char **)(a2 + 8), v4, v5, (v5 - v4) >> 2);
  if (v3)
  {
    operator delete(v3);
  }
}

void sub_19017C18C(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

void AudioFileAllowListFilter::AudioFileAllowListFilter(__CFDictionary const*)::$_0::__invoke(CFNumberRef number, uint64_t a2)
{
  uint64_t v3 = v4;
  std::vector<unsigned int>::__insert_with_size[abi:ne180100]<std::__wrap_iter<unsigned int const*>,std::__wrap_iter<unsigned int const*>>(a2, *(char **)(a2 + 8), v4, v5, (v5 - v4) >> 2);
  if (v3)
  {
    operator delete(v3);
  }
}

void sub_19017C21C(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::GetTypesForHFSCode(_anonymous_namespace_ *this, CFNumberRef number)
{
  int valuePtr = 0;
  if (!CFNumberGetValue(number, kCFNumberSInt32Type, &valuePtr))
  {
    uint64_t v3 = 0;
    long long v4 = 0uLL;
LABEL_5:
    *(_OWORD *)this = v4;
    *((void *)this + 2) = v3;
    return;
  }
  UInt32 outDataSize = 0;
  if (AudioFileGetGlobalInfoSize(0x74686673u, 4u, &valuePtr, &outDataSize))
  {
    *(void *)this = 0;
    *((void *)this + 1) = 0;
    *((void *)this + 2) = 0;
    return;
  }
  unint64_t v5 = (unint64_t)outDataSize >> 2;
  if (outDataSize > 3)
  {
    UInt32 v8 = std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((unint64_t)outDataSize >> 2);
    *(void *)&long long v7 = v8;
    uint64_t v10 = 4 * v5;
    uint64_t v11 = v8;
    uint64_t v6 = (uint64_t)&v8[v5];
    do
    {
      *v11++ = 0;
      v10 -= 4;
    }
    while (v10);
    uint64_t v3 = (char *)&v8[v9];
  }
  else
  {
    uint64_t v3 = 0;
    uint64_t v6 = 4 * v5;
    *(void *)&long long v7 = 0;
  }
  *((void *)&v7 + 1) = v6;
  long long v14 = v7;
  unint64_t v12 = (void *)v7;
  OSStatus GlobalInfo = AudioFileGetGlobalInfo(0x74686673u, 4u, &valuePtr, &outDataSize, (void *)v7);
  long long v4 = v14;
  if (!GlobalInfo) {
    goto LABEL_5;
  }
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  if (v12) {
    operator delete(v12);
  }
}

void sub_19017C350(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9)
{
}

void AudioFileAllowListFilter::AudioFileAllowListFilter(AudioFileAllowListFilter *this, CFDictionaryRef theDict)
{
  long long v4 = (char *)this + 40;
  *((unsigned char *)this + 64) = 0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *(_OWORD *)((char *)this + 25) = 0u;
  Value = CFDictionaryGetValue(theDict, @"kAudioFileAllowList_HFSCodeKey");
  uint64_t v6 = Value;
  if (Value)
  {
    CFTypeID v7 = CFGetTypeID(Value);
    if (v7 == CFArrayGetTypeID())
    {
      CFArrayRef v8 = (const __CFArray *)CFRetain(v6);
      *((void *)this + 3) = v8;
      context = 0;
      uint64_t v28 = 0;
      uint64_t v29 = 0;
      v30.length = CFArrayGetCount(v8);
      v30.location = 0;
      CFArrayApplyFunction(v8, v30, (CFArrayApplierFunction)AudioFileAllowListFilter::AudioFileAllowListFilter(__CFDictionary const*)::$_0::__invoke, &context);
      if (*((unsigned char *)this + 64))
      {
        if (v4 != (char *)&context) {
          std::vector<int>::__assign_with_size[abi:ne180100]<int *,int *>(v4, context, (uint64_t)v28, ((char *)v28 - context) >> 2);
        }
      }
      else
      {
        *(void *)long long v4 = 0;
        *((void *)v4 + 1) = 0;
        *((void *)v4 + 2) = 0;
        std::vector<unsigned int>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>(v4, context, (uint64_t)v28, ((char *)v28 - context) >> 2);
        *((unsigned char *)this + 64) = 1;
      }
      if (context)
      {
        uint64_t v28 = (__int32 *)context;
        operator delete(context);
      }
    }
  }
  uint64_t v9 = CFDictionaryGetValue(theDict, @"kAudioFileAllowList_UTIKey");
  uint64_t v10 = v9;
  if (v9)
  {
    CFTypeID v11 = CFGetTypeID(v9);
    if (v11 == CFArrayGetTypeID())
    {
      CFArrayRef v12 = (const __CFArray *)CFRetain(v10);
      *(void *)this = v12;
      context = 0;
      uint64_t v28 = 0;
      uint64_t v29 = 0;
      v31.length = CFArrayGetCount(v12);
      v31.location = 0;
      CFArrayApplyFunction(v12, v31, (CFArrayApplierFunction)AudioFileAllowListFilter::AudioFileAllowListFilter(__CFDictionary const*)::$_1::__invoke, &context);
      if (*((unsigned char *)this + 64))
      {
      }
      else
      {
        __p = 0;
        uint64_t v25 = 0;
        uint64_t v26 = 0;
        std::vector<unsigned int>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>(&__p, context, (uint64_t)v28, ((char *)v28 - context) >> 2);
      }
      std::optional<std::vector<unsigned int>>::operator=[abi:ne180100]<std::vector<unsigned int>,void>((uint64_t)v4, (uint64_t)&__p);
      if (__p) {
        operator delete(__p);
      }
      if (context)
      {
        uint64_t v28 = (__int32 *)context;
        operator delete(context);
      }
    }
  }
  uint64_t v13 = CFDictionaryGetValue(theDict, @"kAudioFileAllowList_ExtensionKey");
  long long v14 = v13;
  if (v13)
  {
    CFTypeID v15 = CFGetTypeID(v13);
    if (v15 == CFArrayGetTypeID())
    {
      CFArrayRef v16 = (const __CFArray *)CFRetain(v14);
      *((void *)this + 2) = v16;
      context = 0;
      uint64_t v28 = 0;
      uint64_t v29 = 0;
      v32.length = CFArrayGetCount(v16);
      v32.location = 0;
      CFArrayApplyFunction(v16, v32, (CFArrayApplierFunction)AudioFileAllowListFilter::AudioFileAllowListFilter(__CFDictionary const*)::$_2::__invoke, &context);
      if (*((unsigned char *)this + 64))
      {
      }
      else
      {
        __p = 0;
        uint64_t v25 = 0;
        uint64_t v26 = 0;
        std::vector<unsigned int>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>(&__p, context, (uint64_t)v28, ((char *)v28 - context) >> 2);
      }
      std::optional<std::vector<unsigned int>>::operator=[abi:ne180100]<std::vector<unsigned int>,void>((uint64_t)v4, (uint64_t)&__p);
      if (__p) {
        operator delete(__p);
      }
      if (context)
      {
        uint64_t v28 = (__int32 *)context;
        operator delete(context);
      }
    }
  }
  uint64_t v17 = CFDictionaryGetValue(theDict, @"kAudioFileAllowList_MIMETypeKey");
  uint64_t v18 = v17;
  if (v17)
  {
    CFTypeID v19 = CFGetTypeID(v17);
    if (v19 == CFArrayGetTypeID())
    {
      CFArrayRef v20 = (const __CFArray *)CFRetain(v18);
      *((void *)this + 1) = v20;
      context = 0;
      uint64_t v28 = 0;
      uint64_t v29 = 0;
      v33.length = CFArrayGetCount(v20);
      v33.location = 0;
      CFArrayApplyFunction(v20, v33, (CFArrayApplierFunction)AudioFileAllowListFilter::AudioFileAllowListFilter(__CFDictionary const*)::$_3::__invoke, &context);
      if (*((unsigned char *)this + 64))
      {
      }
      else
      {
        __p = 0;
        uint64_t v25 = 0;
        uint64_t v26 = 0;
        std::vector<unsigned int>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>(&__p, context, (uint64_t)v28, ((char *)v28 - context) >> 2);
      }
      std::optional<std::vector<unsigned int>>::operator=[abi:ne180100]<std::vector<unsigned int>,void>((uint64_t)v4, (uint64_t)&__p);
      if (__p) {
        operator delete(__p);
      }
      if (context)
      {
        uint64_t v28 = (__int32 *)context;
        operator delete(context);
      }
    }
  }
  UInt32 v21 = CFDictionaryGetValue(theDict, @"kAudioFileAllowList_DataFormatKey");
  UInt32 v22 = v21;
  if (v21)
  {
    CFTypeID v23 = CFGetTypeID(v21);
    if (v23 == CFArrayGetTypeID()) {
      *((void *)this + 4) = CFRetain(v22);
    }
  }
}

void sub_19017C748(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (*(unsigned char *)(v13 + 64))
  {
    CFArrayRef v16 = *v14;
    if (*v14)
    {
      *(void *)(v13 + 48) = v16;
      operator delete(v16);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t AudioFileAllowListFilter::operator=(uint64_t a1, uint64_t a2)
{
  CFTypeRef v4 = *(CFTypeRef *)(a2 + 8);
  if (v4) {
    CFTypeRef v4 = CFRetain(v4);
  }
  *(void *)(a1 + 8) = v4;
  CFTypeRef v5 = *(CFTypeRef *)(a2 + 16);
  if (v5) {
    CFTypeRef v5 = CFRetain(v5);
  }
  *(void *)(a1 + 16) = v5;
  CFTypeRef v6 = *(CFTypeRef *)a2;
  if (*(void *)a2) {
    CFTypeRef v6 = CFRetain(v6);
  }
  *(void *)a1 = v6;
  CFTypeRef v7 = *(CFTypeRef *)(a2 + 24);
  if (v7) {
    CFTypeRef v7 = CFRetain(v7);
  }
  *(void *)(a1 + 24) = v7;
  CFTypeRef v8 = *(CFTypeRef *)(a2 + 32);
  if (v8) {
    CFTypeRef v8 = CFRetain(v8);
  }
  *(void *)(a1 + 32) = v8;
  uint64_t v9 = (char *)(a1 + 40);
  if (*(unsigned __int8 *)(a1 + 64) == *(unsigned __int8 *)(a2 + 64))
  {
    if (a1 != a2 && *(unsigned char *)(a1 + 64)) {
      std::vector<int>::__assign_with_size[abi:ne180100]<int *,int *>(v9, *(char **)(a2 + 40), *(void *)(a2 + 48), (uint64_t)(*(void *)(a2 + 48) - *(void *)(a2 + 40)) >> 2);
    }
  }
  else if (*(unsigned char *)(a1 + 64))
  {
    uint64_t v10 = *(void **)v9;
    if (v10)
    {
      *(void *)(a1 + 48) = v10;
      operator delete(v10);
    }
    *(unsigned char *)(a1 + 64) = 0;
  }
  else
  {
    *(void *)uint64_t v9 = 0;
    *(void *)(a1 + 48) = 0;
    *(void *)(a1 + 56) = 0;
    std::vector<unsigned int>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>(v9, *(const void **)(a2 + 40), *(void *)(a2 + 48), (uint64_t)(*(void *)(a2 + 48) - *(void *)(a2 + 40)) >> 2);
    *(unsigned char *)(a1 + 64) = 1;
  }
  return a1;
}

void AudioFileAllowListFilter::~AudioFileAllowListFilter(AudioFileAllowListFilter *this)
{
  uint64_t v2 = (const void *)*((void *)this + 1);
  if (v2)
  {
    CFRelease(v2);
    *((void *)this + 1) = 0;
  }
  uint64_t v3 = (const void *)*((void *)this + 2);
  if (v3)
  {
    CFRelease(v3);
    *((void *)this + 2) = 0;
  }
  if (*(void *)this)
  {
    CFRelease(*(CFTypeRef *)this);
    *(void *)this = 0;
  }
  CFTypeRef v4 = (const void *)*((void *)this + 3);
  if (v4)
  {
    CFRelease(v4);
    *((void *)this + 3) = 0;
  }
  CFTypeRef v5 = (const void *)*((void *)this + 4);
  if (v5)
  {
    CFRelease(v5);
    *((void *)this + 4) = 0;
  }
  if (*((unsigned char *)this + 64))
  {
    CFTypeRef v6 = (void *)*((void *)this + 5);
    if (v6)
    {
      *((void *)this + 6) = v6;
      operator delete(v6);
    }
  }
}

void AudioFileAllowListFilter::GetAllowedTypes(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(unsigned char *)(a2 + 64) && *(void *)(a2 + 40) == *(void *)(a2 + 48)) {
    goto LABEL_25;
  }
  int v6 = *(_DWORD *)a3;
  if (*(int *)a3 > 1718446444)
  {
    if (v6 == 1718446445)
    {
      CFArrayRef v7 = *(const __CFArray **)(a2 + 8);
      if (!v7) {
        goto LABEL_28;
      }
    }
    else
    {
      if (v6 != 1718973545) {
        goto LABEL_25;
      }
      CFArrayRef v7 = *(const __CFArray **)a2;
      if (!*(void *)a2)
      {
LABEL_23:
        if (*(unsigned char *)(a2 + 64)) {
          goto LABEL_29;
        }
        goto LABEL_33;
      }
    }
  }
  else if (v6 == 1717926004)
  {
    CFArrayRef v7 = *(const __CFArray **)(a2 + 16);
    if (!v7) {
      goto LABEL_26;
    }
  }
  else
  {
    if (v6 != 1718118003) {
      goto LABEL_25;
    }
    CFArrayRef v7 = *(const __CFArray **)(a2 + 24);
    if (!v7)
    {
LABEL_19:
      if (*(unsigned char *)(a2 + 64)) {
        goto LABEL_29;
      }
      goto LABEL_33;
    }
  }
  v12.length = CFArrayGetCount(v7);
  v12.location = 0;
  if (!CFArrayContainsValue(v7, v12, *(const void **)(a3 + 8))) {
    goto LABEL_25;
  }
  int v8 = *(_DWORD *)a3;
  if (*(int *)a3 <= 1718446444)
  {
    if (v8 != 1717926004)
    {
      if (v8 == 1718118003) {
        goto LABEL_19;
      }
LABEL_25:
      *(void *)a1 = 0;
      *(void *)(a1 + 8) = 0;
      *(void *)(a1 + 16) = 0;
      return;
    }
LABEL_26:
    if (*(unsigned char *)(a2 + 64)) {
      goto LABEL_29;
    }
    goto LABEL_33;
  }
  if (v8 != 1718446445)
  {
    if (v8 != 1718973545) {
      goto LABEL_25;
    }
    goto LABEL_23;
  }
LABEL_28:
  if (*(unsigned char *)(a2 + 64))
  {
LABEL_29:
    uint64_t v9 = __p;
    goto LABEL_30;
  }
LABEL_33:
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  uint64_t v9 = __p;
  std::vector<unsigned int>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>((void *)a1, __p, v11, (v11 - (uint64_t)__p) >> 2);
LABEL_30:
  if (v9) {
    operator delete(v9);
  }
}

void sub_19017CBD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::intersectionOfAllowedTypes(__int32 **a1, __int32 *a2, __int32 *a3, __int32 **a4)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2 != a3)
  {
    int v6 = a2;
    int v8 = 0;
    unint64_t v9 = 0;
    uint64_t v10 = 0;
    do
    {
      __int32 v11 = *v6;
      CFRange v12 = a4[1];
      uint64_t v13 = wmemchr(*a4, *v6, v12 - *a4);
      if (v13) {
        long long v14 = v13;
      }
      else {
        long long v14 = v12;
      }
      if (v14 != a4[1])
      {
        if ((unint64_t)v10 >= v9)
        {
          uint64_t v16 = v10 - v8;
          unint64_t v17 = v16 + 1;
          if ((unint64_t)(v16 + 1) >> 62) {
            std::vector<float>::__throw_length_error[abi:ne180100]();
          }
          if ((uint64_t)(v9 - (void)v8) >> 1 > v17) {
            unint64_t v17 = (uint64_t)(v9 - (void)v8) >> 1;
          }
          if (v9 - (unint64_t)v8 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v18 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v18 = v17;
          }
          if (v18) {
            unint64_t v18 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v18);
          }
          else {
            uint64_t v19 = 0;
          }
          CFArrayRef v20 = (__int32 *)(v18 + 4 * v16);
          __int32 *v20 = v11;
          CFTypeID v15 = v20 + 1;
          while (v10 != v8)
          {
            __int32 v21 = *--v10;
            *--CFArrayRef v20 = v21;
          }
          unint64_t v9 = v18 + 4 * v19;
          *a1 = v20;
          a1[1] = v15;
          a1[2] = (__int32 *)v9;
          if (v8) {
            operator delete(v8);
          }
          int v8 = v20;
        }
        else
        {
          *uint64_t v10 = v11;
          CFTypeID v15 = v10 + 1;
        }
        a1[1] = v15;
        uint64_t v10 = v15;
      }
      ++v6;
    }
    while (v6 != a3);
  }
}

void sub_19017CD3C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

BOOL AudioFileAllowListFilter::IsDataFormatAllowed(AudioFileAllowListFilter *this, int a2)
{
  int valuePtr = a2;
  CFNumberRef v3 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &valuePtr);
  CFArrayRef v4 = (const __CFArray *)*((void *)this + 4);
  if (v4)
  {
    v8.length = CFArrayGetCount(v4);
    v8.location = 0;
    BOOL v5 = CFArrayContainsValue(v4, v8, v3) != 0;
  }
  else
  {
    BOOL v5 = 1;
  }
  CFRelease(v3);
  return v5;
}

uint64_t CAFAudioStream::GetFormatList(CAFAudioStream *this, unsigned int *a2, AudioFormatListItem *a3)
{
  return 4294967292;
}

uint64_t CAFAudioStream::GetFormatListInfo(CAFAudioStream *this, unsigned int *a2, unsigned int *a3)
{
  return 4294967292;
}

uint64_t CAFAudioStream::HandleDiscontinuity(CAFAudioStream *this)
{
  return 0;
}

uint64_t CAFAudioStream::ParseHeader(uint64_t a1, uint64_t a2)
{
  CFNumberRef v3 = (int8x16_t *)(a1 + 348);
  int v4 = *(_DWORD *)(a1 + 236);
  if (v4 > 301)
  {
    if (v4 > 349)
    {
      switch(v4)
      {
        case 350:
          int v44 = *(_DWORD *)(a1 + 256);
          unsigned int v45 = *(unsigned __int8 **)(a1 + 264);
LABEL_172:
          LODWORD(__dst) = v44;
          StreamBuffer::Copy((void *)(*(void *)(a1 + 8) + 72), (unsigned int *)&__dst, v45);
          int v130 = (int)__dst;
          int v131 = *(_DWORD *)(a1 + 256);
          *(void *)(a1 + 264) += __dst;
          int v132 = v131 - v130;
          *(_DWORD *)(a1 + 256) = v132;
          if (!v132)
          {
            unsigned int v133 = *(const UInt8 **)(a1 + 432);
            CFIndex v134 = *(unsigned int *)(a1 + 440);
            __dst = 0;
            char v156 = 1;
            __dst = CFDataCreate(0, v133, v134);
            CFDictionaryRef v135 = (const __CFDictionary *)CFPropertyListCreateWithData((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFDataRef)__dst, 0, 0, 0);
            if (v135)
            {
              CFDictionaryRef theDict = v135;
              char v154 = 1;
              CFTypeID v136 = CFGetTypeID(v135);
              if (v136 == CFDictionaryGetTypeID()) {
                operator new();
              }
              uint64_t v13 = 1667787583;
              CACFObject<void const*>::~CACFObject((uint64_t)&theDict);
            }
            else
            {
              uint64_t v13 = 1667787583;
            }
            CACFData::~CACFData((CACFData *)&__dst);
            return v13;
          }
          uint64_t v13 = 0;
          int v48 = 350;
LABEL_209:
          *(_DWORD *)(a1 + 236) = v48;
          return v13;
        case 373:
          __int32 v46 = *(_DWORD *)(a1 + 256);
          uint64_t v47 = *(unsigned __int8 **)(a1 + 264);
          goto LABEL_167;
        case 383:
          __int32 v11 = *(_DWORD *)(a1 + 256);
          CFRange v12 = *(unsigned __int8 **)(a1 + 264);
LABEL_93:
          LODWORD(__dst) = v11;
          StreamBuffer::Copy((void *)(*(void *)(a1 + 8) + 72), (unsigned int *)&__dst, v12);
          int v78 = (int)__dst;
          int v79 = *(_DWORD *)(a1 + 256);
          *(void *)(a1 + 264) += __dst;
          int v80 = v79 - v78;
          *(_DWORD *)(a1 + 256) = v80;
          if (!v80) {
            operator new();
          }
          uint64_t v13 = 0;
          int v48 = 383;
          goto LABEL_209;
      }
    }
    else
    {
      switch(v4)
      {
        case 302:
          int v21 = *(_DWORD *)(a1 + 256);
          UInt32 v22 = *(unsigned __int8 **)(a1 + 264);
          goto LABEL_30;
        case 319:
          __int32 v38 = *(_DWORD *)(a1 + 256);
          uint64_t v39 = *(unsigned __int8 **)(a1 + 264);
          goto LABEL_143;
        case 330:
          __int32 v7 = *(_DWORD *)(a1 + 256);
          CFRange v8 = *(unsigned __int8 **)(a1 + 264);
          goto LABEL_60;
      }
    }
    goto LABEL_57;
  }
  if (v4 > 244)
  {
    switch(v4)
    {
      case 245:
        int v40 = *(_DWORD *)(a1 + 256);
        uint64_t v41 = *(unsigned __int8 **)(a1 + 264);
        goto LABEL_70;
      case 261:
        int v42 = *(_DWORD *)(a1 + 256);
        unsigned int v43 = *(unsigned __int8 **)(a1 + 264);
        goto LABEL_148;
      case 279:
        LODWORD(v9) = *(_DWORD *)(a1 + 256);
        uint64_t v10 = *(unsigned __int8 **)(a1 + 264);
        goto LABEL_101;
    }
    goto LABEL_57;
  }
  if (v4 == -1) {
    return 0;
  }
  if (v4)
  {
    if (v4 == 229)
    {
      int v5 = *(_DWORD *)(a1 + 256);
      int v6 = *(unsigned __int8 **)(a1 + 264);
      goto LABEL_25;
    }
LABEL_57:
    uint64_t v13 = 0;
LABEL_208:
    int v48 = -1;
    goto LABEL_209;
  }
  uint64_t v14 = *(void *)(a1 + 8);
  LODWORD(v159) = 1;
  if (!*(unsigned char *)(v14 + 104))
  {
    *(unsigned char *)(v14 + 104) = 1;
    CFTypeID v15 = *(void (**)(void, void, uint64_t, long long *))(v14 + 24);
    if (v15) {
      v15(*(void *)(v14 + 40), *(unsigned int *)(v14 + 8), 1717988724, &v159);
    }
  }
  int v5 = 8;
  *(_DWORD *)(a1 + 256) = 8;
  int v6 = (unsigned __int8 *)(a1 + 336);
  *(void *)(a1 + 264) = a1 + 336;
LABEL_25:
  LODWORD(v159) = v5;
  StreamBuffer::Copy((void *)(*(void *)(a1 + 8) + 72), (unsigned int *)&v159, v6);
  int v16 = v159;
  int v17 = *(_DWORD *)(a1 + 256);
  *(void *)(a1 + 264) += v159;
  int v18 = v17 - v16;
  *(_DWORD *)(a1 + 256) = v18;
  if (v18)
  {
    uint64_t v13 = 0;
    int v48 = 229;
    goto LABEL_209;
  }
  unsigned int v19 = *(_DWORD *)(a1 + 336);
  *(_DWORD *)(a1 + 336) = bswap32(v19);
  unsigned int v20 = *(unsigned __int16 *)(a1 + 340);
  *(_WORD *)(a1 + 340) = __rev16(v20);
  *(_WORD *)(a1 + 342) = bswap32(*(unsigned __int16 *)(a1 + 342)) >> 16;
  if (v19 != 1717985635 || v20 != 256)
  {
LABEL_207:
    uint64_t v13 = 1685348671;
    *(unsigned char *)(a1 + 177) = 1;
    goto LABEL_208;
  }
  *(void *)(a1 + 296) += 8;
  while (1)
  {
    int v40 = 12;
    *(_DWORD *)(a1 + 256) = 12;
    uint64_t v41 = (unsigned __int8 *)(a1 + 344);
    *(void *)(a1 + 264) = a1 + 344;
LABEL_70:
    LODWORD(__dst) = v40;
    StreamBuffer::Copy((void *)(*(void *)(a1 + 8) + 72), (unsigned int *)&__dst, v41);
    int v63 = (int)__dst;
    int v64 = *(_DWORD *)(a1 + 256);
    *(void *)(a1 + 264) += __dst;
    int v65 = v64 - v63;
    *(_DWORD *)(a1 + 256) = v65;
    if (v65)
    {
      uint64_t v13 = 0;
      int v48 = 245;
      goto LABEL_209;
    }
    int v66 = bswap32(*(_DWORD *)(a1 + 344));
    *(_DWORD *)(a1 + 344) = v66;
    size_t v9 = bswap64(v3->i64[0]);
    v3->i64[0] = v9;
    if ((uint64_t)v9 <= 0) {
      goto LABEL_207;
    }
    uint64_t v67 = *(void *)(a1 + 296);
    *(void *)(a1 + 296) = v67 + 12;
    if (v66 <= 1802857320) {
      break;
    }
    if (v66 > 1819243875)
    {
      if (v66 == 1819243876)
      {
        if (!HIDWORD(v9))
        {
          *(_DWORD *)(a1 + 440) = v9;
          CADeprecated::CAAutoFree<unsigned char>::allocBytes((void **)(a1 + 432), v9, 0);
          int v44 = *(_DWORD *)(a1 + 440);
          *(_DWORD *)(a1 + 256) = v44;
          unsigned int v45 = *(unsigned __int8 **)(a1 + 432);
          *(void *)(a1 + 264) = v45;
          goto LABEL_172;
        }
        goto LABEL_194;
      }
      if (v66 == 1885432692)
      {
        if (HIDWORD(v9)) {
          goto LABEL_194;
        }
        if (*(_DWORD *)(a1 + 284) < v9)
        {
          *(_DWORD *)(a1 + 284) = v9;
          CADeprecated::CAAutoFree<unsigned char>::allocBytes((void **)(a1 + 288), v9, 0);
          LODWORD(v9) = v3->i32[0];
        }
        *(_DWORD *)(a1 + 256) = v9;
        uint64_t v10 = *(unsigned __int8 **)(a1 + 288);
        *(void *)(a1 + 264) = v10;
LABEL_101:
        LODWORD(__dst) = v9;
        StreamBuffer::Copy((void *)(*(void *)(a1 + 8) + 72), (unsigned int *)&__dst, v10);
        int v81 = (int)__dst;
        int v82 = *(_DWORD *)(a1 + 256);
        *(void *)(a1 + 264) += __dst;
        int v83 = v82 - v81;
        *(_DWORD *)(a1 + 256) = v83;
        if (v83)
        {
          uint64_t v13 = 0;
          int v48 = 279;
          goto LABEL_209;
        }
        uint64_t v13 = 1667787583;
        if (v3->i64[0] < 0x18) {
          goto LABEL_208;
        }
        size_t v84 = v3->i64[0];
        uint64_t v85 = *(const void **)(a1 + 288);
        uint64_t v152 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 88))(a1);
        uint64_t v86 = *(CompressedPacketTable **)(a1 + 152);
        if (v86)
        {
          CompressedPacketTable::~CompressedPacketTable(v86);
          MEMORY[0x192FC8940]();
        }
        *(void *)(a1 + 152) = 0;
        AudioFileStreamObject::GetPacketTable((AudioFileStreamObject *)a1);
        int v87 = *(_DWORD *)(a1 + 44);
        __dst = 0;
        CADeprecated::CAAutoFree<unsigned char>::allocBytes(&__dst, v84, 0);
        unsigned int v88 = (int8x8_t *)__dst;
        memcpy(__dst, v85, v84);
        uint64_t v89 = v88 + 3;
        uint64_t v90 = (char *)v88 + v84;
        unsigned int v91 = *(_DWORD *)(a1 + 112);
        int8x16_t v92 = vrev64q_s8(*(int8x16_t *)v88->i8);
        *(int8x16_t *)v88->i8 = v92;
        int8x8_t v93 = vrev32_s8(v88[2]);
        v88[2] = v93;
        *(void *)(a1 + 160) = v92.i64[1];
        *(int8x8_t *)(a1 + 168) = v93;
        if (*(_DWORD *)(a1 + 40) && *(_DWORD *)(a1 + 44))
        {
LABEL_107:
          uint64_t v13 = 0;
          *(_DWORD *)(a1 + 112) = v91;
          if (!v88) {
            goto LABEL_199;
          }
        }
        else if (v92.i64[0] <= (uint64_t)(v84 - 24))
        {
          (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 80))(a1, v92.i64[0]);
          if (v89 < (int8x8_t *)v90)
          {
            uint64_t v94 = 0;
            uint64_t v150 = 0;
            do
            {
              if (v94 >= *(void *)v88) {
                break;
              }
              uint64_t v149 = v94;
              uint64_t v95 = 0;
              unsigned int v96 = 0;
              do
              {
                if (&v89->i8[v95] >= v90)
                {
LABEL_178:
                  exception = __cxa_allocate_exception(4uLL);
                  _DWORD *exception = 1667787583;
                  __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
                }
                if (v95 == 5)
                {
LABEL_179:
                  unint64_t v138 = __cxa_allocate_exception(4uLL);
                  *unint64_t v138 = 1885563711;
                  __cxa_throw(v138, MEMORY[0x1E4FBA3A8], 0);
                }
                char v97 = v89->i8[v95];
                unsigned int v98 = v97 & 0x7F | (v96 << 7);
                ++v95;
                unsigned int v96 = v98;
              }
              while (v97 < 0);
              if (v98 > v91) {
                unsigned int v91 = v98;
              }
              if (v87)
              {
                LODWORD(v99) = 0;
                uint64_t v89 = (int8x8_t *)((char *)v89 + v95);
              }
              else
              {
                uint64_t v106 = 0;
                LODWORD(v99) = 0;
                uint64_t v107 = (char *)v89 + v95;
                do
                {
                  if (&v107[v106] >= v90) {
                    goto LABEL_178;
                  }
                  if (v106 == 5) {
                    goto LABEL_179;
                  }
                  char v108 = v107[v106];
                  LODWORD(v99) = v108 & 0x7F | (v99 << 7);
                  ++v106;
                }
                while (v108 < 0);
                uint64_t v89 = (int8x8_t *)((char *)v89 + v95 + v106);
              }
              PacketTable = (uint64_t *)AudioFileStreamObject::GetPacketTable((AudioFileStreamObject *)a1);
              unint64_t v101 = (char **)PacketTable;
              unint64_t v102 = __PAIR64__(v98, v99);
              unsigned int v103 = *(_DWORD *)(a1 + 44);
              *(void *)&long long v159 = v150;
              if (v103) {
                uint64_t v99 = v103;
              }
              else {
                uint64_t v99 = v99;
              }
              *((void *)&v159 + 1) = v102;
              uint64_t v104 = PacketTable[3];
              if (v104)
              {
                uint64_t v148 = PacketTable;
                CompressedPacketTable::operator[]((uint64_t)v157, PacketTable, v104 - 1);
                unint64_t v101 = (char **)v148;
                uint64_t v104 = v158;
              }
              uint64_t v160 = v104 + v99;
              CompressedPacketTable::push_back(v101, &v159);
              if (v98 > *(_DWORD *)(a1 + 112)) {
                *(_DWORD *)(a1 + 112) = v98;
              }
              v150 += v98;
              if (v150 >= v152 && v152 >= 1) {
                break;
              }
              uint64_t v94 = v149 + 1;
            }
            while (v89 < (int8x8_t *)v90);
          }
          goto LABEL_107;
        }
        free(v88);
LABEL_199:
        if (v13) {
          goto LABEL_208;
        }
        uint64_t v143 = *(void *)(a1 + 8);
        LODWORD(__dst) = 1;
        if (!*(unsigned char *)(v143 + 106))
        {
          *(unsigned char *)(v143 + 106) = 1;
          int v144 = *(void (**)(void, void, uint64_t, void **))(v143 + 24);
          if (v144)
          {
            v144(*(void *)(v143 + 40), *(unsigned int *)(v143 + 8), 1886283375, &__dst);
            uint64_t v143 = *(void *)(a1 + 8);
          }
        }
        LODWORD(__dst) = 1;
        int v145 = *(void (**)(void, void, uint64_t, void **))(v143 + 24);
        if (v145) {
          v145(*(void *)(v143 + 40), *(unsigned int *)(v143 + 8), 1886616165, &__dst);
        }
      }
    }
    else if (v66 == 1802857321)
    {
      if (HIDWORD(v9)) {
        goto LABEL_194;
      }
      CADeprecated::CAAutoFree<unsigned char>::allocBytes((void **)(a1 + 120), v9, 0);
      __int32 v46 = v3->i32[0];
      *(_DWORD *)(a1 + 256) = v3->i32[0];
      uint64_t v47 = *(unsigned __int8 **)(a1 + 120);
      *(void *)(a1 + 264) = v47;
LABEL_167:
      LODWORD(__dst) = v46;
      StreamBuffer::Copy((void *)(*(void *)(a1 + 8) + 72), (unsigned int *)&__dst, v47);
      int v126 = (int)__dst;
      int v127 = *(_DWORD *)(a1 + 256);
      *(void *)(a1 + 264) += __dst;
      int v128 = v127 - v126;
      *(_DWORD *)(a1 + 256) = v128;
      if (v128)
      {
        uint64_t v13 = 0;
        int v48 = 373;
        goto LABEL_209;
      }
      *(_DWORD *)(a1 + 128) = v3->i64[0];
      uint64_t v129 = *(void *)(a1 + 8);
      LODWORD(__dst) = 1;
      *(unsigned char *)(v129 + 108) = 1;
      uint64_t v59 = *(void (**)(uint64_t, uint64_t, uint64_t, void **))(v129 + 24);
      if (v59)
      {
        uint64_t v60 = *(void *)(v129 + 40);
        uint64_t v61 = *(unsigned int *)(v129 + 8);
        uint64_t v62 = 1835493731;
        goto LABEL_176;
      }
    }
    else if (v66 == 1818522467)
    {
      if (HIDWORD(v9)) {
        goto LABEL_194;
      }
      uint64_t v68 = *(void **)(a1 + 408);
      if (v68)
      {
        free(v68);
        *(void *)(a1 + 408) = 0;
      }
      uint64_t v69 = (unsigned __int8 *)malloc_type_malloc(v9, 0x7C51E058uLL);
      if (!v69)
      {
        uint64_t v141 = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
        unsigned int v142 = std::bad_alloc::bad_alloc(v141);
      }
      CFRange v8 = v69;
      *(void *)(a1 + 408) = v69;
      __int32 v7 = v3->i32[0];
      *(_DWORD *)(a1 + 256) = v3->i32[0];
      *(void *)(a1 + 264) = v69;
LABEL_60:
      LODWORD(__dst) = v7;
      StreamBuffer::Copy((void *)(*(void *)(a1 + 8) + 72), (unsigned int *)&__dst, v8);
      int v49 = (int)__dst;
      int v50 = *(_DWORD *)(a1 + 256);
      *(void *)(a1 + 264) += __dst;
      int v51 = v50 - v49;
      *(_DWORD *)(a1 + 256) = v51;
      if (v51)
      {
        uint64_t v13 = 0;
        int v48 = 330;
        goto LABEL_209;
      }
      unint64_t v52 = v3->u32[0] / 0x24uLL;
      *(_DWORD *)(a1 + 400) = v52;
      std::vector<AudioFormatListItem>::resize((char **)(a1 + 64), v52);
      if (*(_DWORD *)(a1 + 400))
      {
        uint64_t v53 = 0;
        uint64_t v54 = 0;
        unint64_t v55 = 0;
        do
        {
          uint64_t v56 = *(void *)(a1 + 408) + v54;
          *(void *)uint64_t v56 = bswap64(*(void *)v56);
          *(int8x16_t *)(v56 + 8) = vrev32q_s8(*(int8x16_t *)(v56 + 8));
          *(int8x8_t *)(v56 + 24) = vrev32_s8(*(int8x8_t *)(v56 + 24));
          *(_DWORD *)(v56 + 32) = bswap32(*(_DWORD *)(v56 + 32));
          CAFtoAF_FormatListItem(v56, (AudioFormatListItem *)(*(void *)(a1 + 64) + v53));
          ++v55;
          v54 += 36;
          v53 += 48;
        }
        while (v55 < *(unsigned int *)(a1 + 400));
      }
      unsigned int v57 = *(void **)(a1 + 408);
      if (v57)
      {
        free(v57);
        *(void *)(a1 + 408) = 0;
      }
      uint64_t v58 = *(void *)(a1 + 8);
      LODWORD(__dst) = 0;
      *(unsigned char *)(v58 + 108) = 1;
      uint64_t v59 = *(void (**)(uint64_t, uint64_t, uint64_t, void **))(v58 + 24);
      if (v59)
      {
        uint64_t v60 = *(void *)(v58 + 40);
        uint64_t v61 = *(unsigned int *)(v58 + 8);
        uint64_t v62 = 1718383476;
LABEL_176:
        v59(v60, v61, v62, &__dst);
      }
    }
LABEL_205:
    uint64_t v146 = *(void *)(a1 + 296) + v3->i64[0];
    *(void *)(a1 + 296) = v146;
    *(void *)(*(void *)(a1 + 8) + 96) = v146;
  }
  if (v66 > 1684370274)
  {
    if (v66 == 1684370275)
    {
      int v42 = 32;
      *(_DWORD *)(a1 + 256) = 32;
      unsigned int v43 = (unsigned __int8 *)(a1 + 356);
      *(void *)(a1 + 264) = a1 + 356;
LABEL_148:
      LODWORD(__dst) = v42;
      StreamBuffer::Copy((void *)(*(void *)(a1 + 8) + 72), (unsigned int *)&__dst, v43);
      int v114 = (int)__dst;
      int v115 = *(_DWORD *)(a1 + 256);
      *(void *)(a1 + 264) += __dst;
      int v116 = v115 - v114;
      *(_DWORD *)(a1 + 256) = v116;
      if (v116)
      {
        uint64_t v13 = 0;
        int v48 = 261;
        goto LABEL_209;
      }
      unint64_t v117 = bswap64(v3->u64[1]);
      v3->i64[1] = v117;
      int8x16_t v118 = vrev32q_s8(v3[1]);
      v3[1] = v118;
      int8x8_t v119 = vrev32_s8(*(int8x8_t *)v3[2].i8);
      *(int8x8_t *)v3[2].i8 = v119;
      *(_OWORD *)(a1 + 32) = 0u;
      *(_OWORD *)(a1 + 48) = 0u;
      *(void *)(a1 + 24) = v117;
      *(_DWORD *)(a1 + 32) = v118.i32[0];
      int v120 = v118.i32[1];
      *(void *)(a1 + 40) = vextq_s8(v118, v118, 8uLL).u64[0];
      *(int8x8_t *)(a1 + 52) = v119;
      if (v118.i32[3] == 1) {
        *(_DWORD *)(a1 + 48) = v118.i32[2];
      }
      if (v118.i32[0] == 1819304813)
      {
        if (v118.i8[4]) {
          int v121 = 1;
        }
        else {
          int v121 = 4;
        }
        int v122 = (v121 | v118.i8[4] & 2) ^ 2;
        if ((v119.i8[4] & 7) == 0 && ((unsigned __int32)v119.i32[1] >> 3) * v119.i32[0] == v118.i32[2]) {
          int v120 = v122 | 8;
        }
        else {
          int v120 = v122 | 0x10;
        }
      }
      *(_DWORD *)(a1 + 36) = v120;
      if (v118.i32[2])
      {
        *(_DWORD *)(a1 + 112) = v118.i32[2];
        uint64_t v124 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 88))(a1);
        (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 80))(a1, v124 / *(unsigned int *)(a1 + 40));
      }
      uint64_t v125 = *(void *)(a1 + 8);
      LODWORD(__dst) = 1;
      if (!*(unsigned char *)(v125 + 105))
      {
        *(unsigned char *)(v125 + 105) = 1;
        uint64_t v59 = *(void (**)(uint64_t, uint64_t, uint64_t, void **))(v125 + 24);
        if (v59)
        {
          uint64_t v60 = *(void *)(v125 + 40);
          uint64_t v61 = *(unsigned int *)(v125 + 8);
          uint64_t v62 = 1684434292;
          goto LABEL_176;
        }
      }
    }
    else if (v66 == 1768842863)
    {
      uint64_t v70 = *(void *)(*(void *)(a1 + 8) + 48);
      uint64_t v71 = *(void *)(*(void *)(a1 + 8) + 56);
      uint64_t v72 = v71 - v70;
      if (v71 != v70)
      {
        unint64_t v73 = 0;
        unint64_t v74 = v72 >> 2;
        unsigned int v75 = 1;
        do
        {
          int v76 = *(_DWORD *)(v70 + 4 * v73);
          unint64_t v73 = v75++;
        }
        while (v76 != 1935832164 && v74 > v73);
        if (v76 == 1935832164)
        {
          if ((uint64_t)v9 < 0x100000000)
          {
            CADeprecated::CAAutoFree<unsigned char>::allocBytes((void **)(a1 + 416), v9, 0);
            __int32 v11 = v3->i32[0];
            *(_DWORD *)(a1 + 256) = v3->i32[0];
            CFRange v12 = *(unsigned __int8 **)(a1 + 416);
            *(void *)(a1 + 264) = v12;
            goto LABEL_93;
          }
LABEL_194:
          uint64_t v13 = 2003334207;
          goto LABEL_208;
        }
      }
    }
    goto LABEL_205;
  }
  if (v66 == 1667785070)
  {
    if (HIDWORD(v9)) {
      goto LABEL_194;
    }
    CADeprecated::CAAutoFree<unsigned char>::allocBytes((void **)(a1 + 136), v9, 0);
    __int32 v38 = v3->i32[0];
    *(_DWORD *)(a1 + 256) = v3->i32[0];
    uint64_t v39 = *(unsigned __int8 **)(a1 + 136);
    *(void *)(a1 + 264) = v39;
LABEL_143:
    LODWORD(__dst) = v38;
    StreamBuffer::Copy((void *)(*(void *)(a1 + 8) + 72), (unsigned int *)&__dst, v39);
    int v109 = (int)__dst;
    int v110 = *(_DWORD *)(a1 + 256);
    *(void *)(a1 + 264) += __dst;
    int v111 = v110 - v109;
    *(_DWORD *)(a1 + 256) = v111;
    if (v111)
    {
      uint64_t v13 = 0;
      int v48 = 319;
      goto LABEL_209;
    }
    unint64_t v112 = v3->i64[0];
    *(_DWORD *)(a1 + 144) = v3->i64[0];
    AudioChannelLayout_BtoN(*(AudioChannelLayout **)(a1 + 136), v112);
    uint64_t v113 = *(void *)(a1 + 8);
    LODWORD(__dst) = 1;
    if (!*(unsigned char *)(v113 + 109))
    {
      *(unsigned char *)(v113 + 109) = 1;
      uint64_t v59 = *(void (**)(uint64_t, uint64_t, uint64_t, void **))(v113 + 24);
      if (v59)
      {
        uint64_t v60 = *(void *)(v113 + 40);
        uint64_t v61 = *(unsigned int *)(v113 + 8);
        uint64_t v62 = 1668112752;
        goto LABEL_176;
      }
    }
    goto LABEL_205;
  }
  if (v66 != 1684108385) {
    goto LABEL_205;
  }
  *(void *)(a1 + 104) = v67 + 16;
  if (v9 < 5)
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 96))(a1, -1);
  }
  else
  {
    (*(void (**)(uint64_t, size_t))(*(void *)a1 + 96))(a1, v9 - 4);
    uint64_t v139 = *(void *)(a1 + 8);
    LODWORD(__dst) = 1;
    uint64_t v140 = *(void (**)(void, void, uint64_t, void **))(v139 + 24);
    if (v140) {
      v140(*(void *)(v139 + 40), *(unsigned int *)(v139 + 8), 1650683508, &__dst);
    }
  }
  int v21 = 4;
  *(_DWORD *)(a1 + 256) = 4;
  UInt32 v22 = (unsigned __int8 *)(a1 + 332);
  *(void *)(a1 + 264) = a1 + 332;
LABEL_30:
  LODWORD(__dst) = v21;
  StreamBuffer::Copy((void *)(*(void *)(a1 + 8) + 72), (unsigned int *)&__dst, v22);
  int v23 = (int)__dst;
  int v24 = *(_DWORD *)(a1 + 256);
  *(void *)(a1 + 264) += __dst;
  int v25 = v24 - v23;
  *(_DWORD *)(a1 + 256) = v25;
  if (v25)
  {
    uint64_t v13 = 0;
    int v48 = 302;
    goto LABEL_209;
  }
  *(_DWORD *)(a1 + 332) = bswap32(*(_DWORD *)(a1 + 332));
  uint64_t v26 = *(void *)(a1 + 8);
  LODWORD(__dst) = 1;
  uint64_t v27 = *(void (**)(void, void, uint64_t, void **))(v26 + 24);
  if (v27)
  {
    v27(*(void *)(v26 + 40), *(unsigned int *)(v26 + 8), 1685022310, &__dst);
    uint64_t v26 = *(void *)(a1 + 8);
  }
  uint64_t v28 = a2;
  if (*(_DWORD *)(a1 + 40) || *(unsigned char *)(v26 + 106))
  {
    LODWORD(__dst) = 1;
    if (!*(_DWORD *)(v26 + 112))
    {
      *(_DWORD *)(v26 + 112) = 1;
      uint64_t v29 = *(void (**)(void, void, uint64_t, void **))(v26 + 24);
      if (v29)
      {
        v29(*(void *)(v26 + 40), *(unsigned int *)(v26 + 8), 1919247481, &__dst);
        uint64_t v28 = a2;
        uint64_t v26 = *(void *)(a1 + 8);
      }
    }
    uint64_t v30 = 0;
    *(void *)uint64_t v28 = a1;
    *(void *)(v28 + 8) = AudioFileStreamObject::GeneratePackets;
    *(void *)(v28 + 16) = 0;
    uint64_t v31 = *(void *)(v26 + 88);
    uint64_t v32 = *(void *)(v26 + 96);
    uint64_t v33 = v31 + *(unsigned int *)(v26 + 80);
    BOOL v34 = v32 < v31 || v33 <= v32;
    int v35 = v34;
    int v36 = v33 - v32;
    if (!v34 && v36) {
      uint64_t v30 = *(void *)(v26 + 72) + (v32 - v31);
    }
    uint64_t v13 = 0;
    *(void *)(v28 + 32) = v30;
    if (v35) {
      int v37 = 0;
    }
    else {
      int v37 = v36;
    }
    *(_DWORD *)(v28 + 24) = v37;
  }
  else
  {
    *(_DWORD *)(a1 + 236) = -1;
    return 1869640813;
  }
  return v13;
}

void sub_19017DF58(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  if (a17) {
    free(a17);
  }
  JUMPOUT(0x19017DE64);
}

CACFDictionary *CADeprecated::CAAutoDelete<CACFDictionary>::set(CACFDictionary **a1, CACFDictionary *a2)
{
  double result = *a1;
  if (result != a2)
  {
    if (result)
    {
      CACFDictionary::~CACFDictionary(result);
      double result = (CACFDictionary *)MEMORY[0x192FC8940]();
    }
    *a1 = a2;
  }
  return result;
}

uint64_t CAFAudioStream::GetProperty(CAFAudioStream *this, int a2, unsigned int *a3, void *__dst)
{
  switch(a2)
  {
    case 1768842863:
      if (*a3 != 8) {
        return 561211770;
      }
      __int32 v7 = (CFTypeRef *)*((void *)this + 53);
      if (!v7) {
        return 1836020325;
      }
      goto LABEL_10;
    case 1819243876:
      if (*a3 != 8) {
        return 561211770;
      }
      __int32 v7 = (CFTypeRef *)*((void *)this + 56);
      if (!v7) {
        return 1836020325;
      }
LABEL_10:
      if (*v7)
      {
        CFRetain(*v7);
        CFTypeRef v8 = *v7;
      }
      else
      {
        CFTypeRef v8 = 0;
      }
      uint64_t result = 0;
      void *__dst = v8;
      return result;
    case 1935893603:
      if (*a3 == 8)
      {
        if (*((void *)this + 56))
        {
          CFTypeRef cf = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          __int16 v11 = 257;
          AudioFileGetSoundCheckDictionaryFromLoudnessInfo(*((const CACFDictionary **)this + 56), (CACFDictionary *)&cf);
          if (cf)
          {
            CFRetain(cf);
            CFTypeRef v6 = cf;
          }
          else
          {
            CFTypeRef v6 = 0;
          }
          void *__dst = v6;
          CACFDictionary::~CACFDictionary((CACFDictionary *)&cf);
          return 0;
        }
        return 1836020325;
      }
      return 561211770;
  }
  return AudioFileStreamObject::GetProperty(this, a2, a3, __dst);
}

void sub_19017E114(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t CAFAudioStream::GetPropertyInfo(CAFAudioStream *this, int a2, unsigned int *a3, unsigned __int8 *a4)
{
  if (a2 != 1768842863 && a2 != 1819243876 && a2 != 1935893603) {
    return AudioFileStreamObject::GetPropertyInfo(this, a2, a3, a4);
  }
  if (a3) {
    *a3 = 8;
  }
  if (a4) {
    *a4 = 0;
  }
  return 0;
}

void CAFAudioStream::~CAFAudioStream(CACFDictionary **this)
{
  CAFAudioStream::~CAFAudioStream(this);
  JUMPOUT(0x192FC8940);
}

{
  CACFDictionary *v2;
  CACFDictionary *v3;
  CACFDictionary *v4;
  CACFDictionary *v5;
  uint64_t vars8;

  *this = (CACFDictionary *)&unk_1EDF8F2B8;
  CADeprecated::CAAutoDelete<CACFDictionary>::set(this + 56, 0);
  uint64_t v2 = this[54];
  if (v2)
  {
    free(v2);
    this[54] = 0;
  }
  CADeprecated::CAAutoDelete<CACFDictionary>::set(this + 53, 0);
  CFNumberRef v3 = this[52];
  if (v3)
  {
    free(v3);
    this[52] = 0;
  }
  int v4 = this[51];
  if (v4)
  {
    free(v4);
    this[51] = 0;
  }
  int v5 = this[49];
  if (v5)
  {
    free(v5);
    this[49] = 0;
  }
  AudioFileStreamObject::~AudioFileStreamObject((AudioFileStreamObject *)this);
}

uint64_t GetAllFormatIDs(UInt32 *outPropertyDataSize, void *outPropertyData)
{
  if (outPropertyData) {
    return AudioFormatGetProperty(0x61636966u, 0, 0, outPropertyDataSize, outPropertyData);
  }
  else {
    return AudioFormatGetPropertyInfo(0x61636966u, 0, 0, outPropertyDataSize);
  }
}

void AppendCommentStringToDictionary(CACFDictionary *a1, CFStringRef theString)
{
  if (CFStringGetLength(theString))
  {
    if (CACFDictionary::HasKey(a1, @"comments"))
    {
      CFStringRef theStringa = 0;
      CACFDictionary::GetString(a1, @"comments", &theStringa);
      if (theStringa)
      {
        CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        MutableCFStringRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, theStringa);
        if (MutableCopy)
        {
          CFTypeRef v6 = MutableCopy;
          CFStringAppend(MutableCopy, @"\n\n");
          CFStringAppend(v6, theString);
          CFStringRef Copy = CFStringCreateCopy(v4, v6);
          if (Copy)
          {
            CFStringRef v8 = Copy;
            if (CFStringGetLength(Copy)) {
              CACFDictionary::AddString(a1, @"comments", v8);
            }
            CFRelease(v8);
          }
          CFRelease(v6);
        }
      }
    }
    else
    {
      CACFDictionary::AddString(a1, @"comments", theString);
    }
  }
}

uint64_t FillOutAudioDescription(AudioStreamBasicDescription *a1, UInt32 a2, void *a3, int a4)
{
  a1->mFormatFlags = 0;
  signed int mFormatID = a1->mFormatID;
  if (mFormatID > 1768775987)
  {
    if (mFormatID <= 1918990111)
    {
      if (mFormatID <= 1768829745)
      {
        if (mFormatID == 1768775988)
        {
          uint64_t result = 0;
          a1->AudioFormatFlags mBitsPerChannel = 0;
          *(void *)&a1->mFramesPerPacket = 64;
          a1->mBytesPerPacket = 34 * a1->mChannelsPerFrame;
          return result;
        }
        if (mFormatID == 1768829492)
        {
          uint64_t result = 0;
          UInt32 v7 = 3 * a1->mChannelsPerFrame;
          a1->mFramesPerPacket = 1;
          a1->mBytesPerFrame = v7;
          a1->mBytesPerPacket = v7;
          UInt32 v8 = 24;
LABEL_34:
          a1->AudioFormatFlags mBitsPerChannel = v8;
          return result;
        }
        goto LABEL_40;
      }
      if (mFormatID != 1768829746)
      {
        if (mFormatID == 1819304813) {
          goto LABEL_21;
        }
LABEL_40:
        Float64 outPropertyData = a1->mSampleRate;
        UInt32 mChannelsPerFrame = a1->mChannelsPerFrame;
        signed int v23 = mFormatID;
        AudioFormatFlags v24 = 0;
        *(_DWORD *)int v25 = a1->mBytesPerPacket;
        *(void *)&v25[4] = 0;
        uint64_t v27 = 0;
        UInt32 ioPropertyDataSize = 40;
        uint64_t result = AudioFormatGetProperty(0x666D7469u, a2, a3, &ioPropertyDataSize, &outPropertyData);
        uint64_t v18 = 0;
        UInt32 v19 = 0;
        UInt32 v20 = 0;
        if (!result)
        {
          a1->mFormatFlags = v24;
          uint64_t v18 = *(void *)v25;
          UInt32 v19 = *(_DWORD *)&v25[8];
          UInt32 v20 = v27;
          a1->mReserved = HIDWORD(v27);
        }
        *(void *)&a1->mBytesPerPacket = v18;
        a1->mBytesPerFrame = v19;
        a1->AudioFormatFlags mBitsPerChannel = v20;
        return result;
      }
LABEL_26:
      uint64_t result = 0;
      UInt32 v14 = 4 * a1->mChannelsPerFrame;
      a1->mFramesPerPacket = 1;
      a1->mBytesPerFrame = v14;
      a1->mBytesPerPacket = v14;
      UInt32 v8 = 32;
      goto LABEL_34;
    }
    if (mFormatID <= 1953984370)
    {
      if (mFormatID == 1918990112)
      {
        uint64_t result = 0;
        UInt32 v17 = a1->mChannelsPerFrame;
        a1->mFramesPerPacket = 1;
        a1->mBytesPerFrame = v17;
        a1->mBytesPerPacket = v17;
        UInt32 v8 = 8;
        goto LABEL_34;
      }
      if (mFormatID != 1936684916) {
        goto LABEL_40;
      }
LABEL_31:
      uint64_t result = 0;
      UInt32 v16 = 2 * a1->mChannelsPerFrame;
      a1->mFramesPerPacket = 1;
      a1->mBytesPerFrame = v16;
      a1->mBytesPerPacket = v16;
      UInt32 v8 = 16;
      goto LABEL_34;
    }
    if (mFormatID == 1953984371) {
      goto LABEL_31;
    }
    int v9 = 1970037111;
    goto LABEL_29;
  }
  if (mFormatID <= 1313820228)
  {
    switch(mFormatID)
    {
      case 842231401:
        goto LABEL_26;
      case 1296122675:
        uint64_t result = 0;
        a1->AudioFormatFlags mBitsPerChannel = 0;
        UInt32 v10 = 2 * a1->mChannelsPerFrame;
        break;
      case 1296122678:
        uint64_t result = 0;
        a1->AudioFormatFlags mBitsPerChannel = 0;
        UInt32 v10 = a1->mChannelsPerFrame;
        break;
      default:
        goto LABEL_40;
    }
    a1->mBytesPerFrame = v10;
    UInt32 v15 = 6;
LABEL_37:
    a1->mBytesPerPacket = v10;
    a1->mFramesPerPacket = v15;
    return result;
  }
  if (mFormatID > 1718367025)
  {
    if (mFormatID != 1718367026)
    {
      if (mFormatID == 1718367796)
      {
        uint64_t result = 0;
        UInt32 v13 = 8 * a1->mChannelsPerFrame;
        a1->mFramesPerPacket = 1;
        a1->mBytesPerFrame = v13;
        a1->mBytesPerPacket = v13;
        UInt32 v8 = 64;
        goto LABEL_34;
      }
      goto LABEL_40;
    }
    goto LABEL_26;
  }
  if (mFormatID != 1313820229)
  {
    int v9 = 1634492791;
LABEL_29:
    if (mFormatID != v9) {
      goto LABEL_40;
    }
    uint64_t result = 0;
    a1->AudioFormatFlags mBitsPerChannel = 8;
    UInt32 v10 = a1->mChannelsPerFrame;
    a1->mBytesPerFrame = v10;
    UInt32 v15 = 1;
    goto LABEL_37;
  }
LABEL_21:
  AudioFormatFlags mBitsPerChannel = a1->mBitsPerChannel;
  UInt32 v12 = ((mBitsPerChannel + 7) >> 3) * a1->mChannelsPerFrame;
  a1->mFramesPerPacket = 1;
  a1->mBytesPerFrame = v12;
  a1->mBytesPerPacket = v12;
  if (mBitsPerChannel == 8)
  {
    uint64_t result = 0;
  }
  else if ((mBitsPerChannel & 7) != 0)
  {
    uint64_t result = 0;
    AudioFormatFlags mBitsPerChannel = 20;
  }
  else
  {
    uint64_t result = 0;
    if (a4) {
      AudioFormatFlags mBitsPerChannel = 9;
    }
    else {
      AudioFormatFlags mBitsPerChannel = 12;
    }
  }
  a1->mFormatFlags = mBitsPerChannel;
  return result;
}

uint64_t SyncSampleTable::IndexOfEntryWithClosestSampleNumberLessThanOrEqualTo(SyncSampleTable *this, SyncSampleTable *a2, uint64_t a3)
{
  uint64_t v3 = a2 - this;
  if (a2 == this) {
    return -1;
  }
  uint64_t v4 = 0;
  if ((v3 & 0x8000000000000000) == 0)
  {
    uint64_t v5 = 0;
    uint64_t v6 = v3 >> 3;
    uint64_t v7 = v6;
    do
    {
      uint64_t v8 = (v7 + v5) >> 1;
      if (v8 >= v6) {
        break;
      }
      if (*((void *)this + v8) > a3)
      {
        uint64_t v7 = v8 - 1;
      }
      else
      {
        uint64_t v5 = v8 + 1;
        uint64_t v4 = v8;
      }
    }
    while (v7 >= v5);
  }
  if (*((void *)this + v4) > a3) {
    return -1;
  }
  return v4;
}

uint64_t SampleToRollDistanceTable::IndexOfEntryWithClosestSampleNumberLessThanOrEqualTo(SampleToRollDistanceTable *this, SampleToRollDistanceTable *a2, int64_t a3)
{
  if (this == a2) {
    return -1;
  }
  uint64_t v3 = 0;
  uint64_t v4 = this;
  do
  {
    v3 += *((void *)v4 + 1);
    uint64_t v4 = (SampleToRollDistanceTable *)((char *)v4 + 24);
  }
  while (v4 != a2);
  if (v3 < 1) {
    return -1;
  }
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  uint64_t v7 = v3;
  do
  {
    uint64_t v8 = (v7 + v6) >> 1;
    if (v8 >= v3) {
      break;
    }
    unint64_t v9 = (v7 + v6) >> 1;
    UInt32 v10 = this;
    do
    {
      unint64_t v11 = *((void *)v10 + 1);
      BOOL v12 = v9 >= v11;
      unint64_t v13 = v9 - v11;
      if (!v12)
      {
        int64_t v14 = *(void *)v10 + v9;
        goto LABEL_12;
      }
      UInt32 v10 = (SampleToRollDistanceTable *)((char *)v10 + 24);
      unint64_t v9 = v13;
    }
    while (v10 != a2);
    int64_t v14 = *((void *)a2 - 3);
LABEL_12:
    if (v14 > a3)
    {
      uint64_t v7 = v8 - 1;
    }
    else
    {
      uint64_t v6 = v8 + 1;
      uint64_t v5 = v8;
    }
  }
  while (v7 >= v6);
  unint64_t v15 = v5;
  do
  {
    unint64_t v16 = *((void *)this + 1);
    BOOL v12 = v15 >= v16;
    unint64_t v17 = v15 - v16;
    if (!v12)
    {
      int64_t v18 = *(void *)this + v15;
      goto LABEL_21;
    }
    this = (SampleToRollDistanceTable *)((char *)this + 24);
    unint64_t v15 = v17;
  }
  while (this != a2);
  int64_t v18 = *((void *)a2 - 3);
LABEL_21:
  if (v18 > a3) {
    return -1;
  }
  return v5;
}

uint64_t PacketToRollDistanceForRestrictedRandomAccess(AudioPacketRollDistanceTranslation *a1, const SampleToRollDistanceTable *a2, const SyncSampleTable *a3)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  a1->mRollDistance = 0;
  int v5 = *(unsigned __int8 *)a2;
  if (*(unsigned char *)a2)
  {
    if (!*(unsigned char *)a3)
    {
      SInt64 mPacket = a1->mPacket;
      SInt64 v7 = 0x7FFFFFFFFFFFFFFFLL;
      goto LABEL_9;
    }
LABEL_5:
    SInt64 mPacket = a1->mPacket;
    uint64_t v8 = (SyncSampleTable *)*((void *)a3 + 1);
    uint64_t v9 = SyncSampleTable::IndexOfEntryWithClosestSampleNumberLessThanOrEqualTo(v8, *((SyncSampleTable **)a3 + 2), a1->mPacket);
    if (v9 < 0)
    {
      SInt64 v7 = 0x7FFFFFFFFFFFFFFFLL;
      if (!v5) {
        goto LABEL_22;
      }
    }
    else
    {
      SInt64 v7 = mPacket - *((void *)v8 + v9);
      if (!v5) {
        goto LABEL_22;
      }
    }
LABEL_9:
    uint64_t v10 = *((void *)a2 + 4);
    uint64_t v11 = *((void *)a2 + 5);
    uint64_t v12 = v11 - v10;
    if (v11 != v10)
    {
      if (v12 < 0)
      {
        uint64_t v14 = 0;
      }
      else
      {
        uint64_t v13 = 0;
        uint64_t v14 = 0;
        int64_t v15 = 0xAAAAAAAAAAAAAAABLL * (v12 >> 3);
        int64_t v16 = v15;
        do
        {
          uint64_t v17 = (v13 + v16) >> 1;
          if (v17 >= v15) {
            break;
          }
          SInt64 v18 = *(void *)(v10 + 24 * v17) + *(__int16 *)(v10 + 24 * v17 + 16);
          if (v18 <= mPacket) {
            uint64_t v14 = (v13 + v16) >> 1;
          }
          else {
            int64_t v16 = v17 - 1;
          }
          if (v18 <= mPacket) {
            uint64_t v13 = v17 + 1;
          }
        }
        while (v16 >= v13);
      }
      UInt32 v19 = (uint64_t *)(v10 + 24 * v14);
      uint64_t v20 = *v19;
      uint64_t v21 = *((__int16 *)v19 + 8);
      if (v20 + v21 <= mPacket)
      {
        SInt64 v23 = *(void *)(v10 + 24 * v14 + 8);
        if (mPacket - v20 >= v23)
        {
          SInt64 v24 = mPacket - (v20 + v23);
          if (v24 + 1 > v21) {
            uint64_t v21 = v24 + 1;
          }
        }
        goto LABEL_23;
      }
    }
LABEL_22:
    uint64_t v21 = 0x7FFFFFFFFFFFFFFFLL;
LABEL_23:
    uint64_t result = 0;
    if (v21 < v7) {
      SInt64 v7 = v21;
    }
    if (v7 >= mPacket) {
      SInt64 v7 = mPacket;
    }
    a1->mRollDistance = v7;
    return result;
  }
  if (*(unsigned char *)a3) {
    goto LABEL_5;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    int v25 = 136315394;
    uint64_t v26 = "AudioFileCommon.cpp";
    __int16 v27 = 1024;
    int v28 = 550;
    _os_log_impl(&dword_18FEC0000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%25s:%-5d  invalid preroll table and invalid sync sample table", (uint8_t *)&v25, 0x12u);
  }
  return 4294967246;
}

uint64_t PacketToRollDistanceForRollRecovery(AudioPacketRollDistanceTranslation *a1, const SampleToRollDistanceTable *a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  a1->mRollDistance = 0;
  if (*(unsigned char *)a2)
  {
    uint64_t v2 = *((void *)a2 + 4);
    uint64_t v3 = *((void *)a2 + 5);
    uint64_t v4 = v3 - v2;
    if (v3 == v2) {
      return 0;
    }
    uint64_t v5 = 0;
    if ((v4 & 0x8000000000000000) == 0)
    {
      uint64_t v6 = 0;
      int64_t v7 = 0xAAAAAAAAAAAAAAABLL * (v4 >> 3);
      int64_t v8 = v7;
      do
      {
        uint64_t v9 = (v8 + v6) >> 1;
        if (v9 >= v7) {
          break;
        }
        SInt64 v10 = *(void *)(v2 + 24 * v9);
        if (v10 <= a1->mPacket)
        {
          if (v10 >= a1->mPacket)
          {
            uint64_t v5 = (v8 + v6) >> 1;
            break;
          }
          uint64_t v6 = v9 + 1;
          uint64_t v5 = v9;
        }
        else
        {
          int64_t v8 = v9 - 1;
        }
      }
      while (v8 >= v6);
    }
    SInt64 mPacket = a1->mPacket;
    if (a1->mPacket >= *(void *)(v2 + 24 * v5))
    {
      SInt64 v13 = -(uint64_t)*(__int16 *)(v2 + 24 * v5 + 16);
      a1->mRollDistance = v13;
    }
    else
    {
      SInt64 v13 = 0;
    }
    if (v13 <= mPacket)
    {
      return 0;
    }
    else
    {
      uint64_t v11 = 0;
      a1->mRollDistance = mPacket;
    }
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      int v15 = 136315394;
      int64_t v16 = "AudioFileCommon.cpp";
      __int16 v17 = 1024;
      int v18 = 589;
      _os_log_impl(&dword_18FEC0000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%25s:%-5d  invalid roll recovery table", (uint8_t *)&v15, 0x12u);
    }
    return 4294967246;
  }
  return v11;
}

uint64_t PacketToDependencyInfoForRestrictedRandomAccess(AudioPacketDependencyInfoTranslation *a1, const SampleToRollDistanceTable *a2, const SyncSampleTable *a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    SInt64 mPacket = a1->mPacket;
    if (a1->mPacket < 0)
    {
      uint64_t v8 = 1885563711;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        int v20 = 136315394;
        uint64_t v21 = "AudioFileCommon.cpp";
        __int16 v22 = 1024;
        int v23 = 635;
        _os_log_impl(&dword_18FEC0000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%25s:%-5d  invalid packet number", (uint8_t *)&v20, 0x12u);
      }
    }
    else
    {
      a1->mIsIndependentlyDecodable = 0;
      if (*(unsigned char *)a3
        && (uint64_t v6 = (SyncSampleTable *)*((void *)a3 + 1),
            uint64_t v7 = SyncSampleTable::IndexOfEntryWithClosestSampleNumberLessThanOrEqualTo(v6, *((SyncSampleTable **)a3 + 2), mPacket), (v7 & 0x8000000000000000) == 0)&& mPacket == *((void *)v6 + v7))
      {
        uint64_t v8 = 0;
        *(void *)&a1->mIsIndependentlyDecodable = 1;
      }
      else
      {
        if (!*(unsigned char *)a2) {
          return 0;
        }
        uint64_t v9 = (__int16 *)*((void *)a2 + 4);
        SInt64 v10 = (SampleToRollDistanceTable *)*((void *)a2 + 5);
        unint64_t v11 = SampleToRollDistanceTable::IndexOfEntryWithClosestSampleNumberLessThanOrEqualTo((SampleToRollDistanceTable *)v9, v10, mPacket);
        if ((v11 & 0x8000000000000000) != 0) {
          return 0;
        }
        while (v9 != (__int16 *)v10)
        {
          unint64_t v12 = *((void *)v9 + 1);
          BOOL v13 = v11 >= v12;
          unint64_t v14 = v11 - v12;
          if (!v13)
          {
            uint64_t v16 = *(void *)v9;
            int v15 = v9 + 8;
            uint64_t v17 = v16 + v11;
            goto LABEL_19;
          }
          v9 += 12;
          unint64_t v11 = v14;
        }
        uint64_t v17 = *((void *)v10 - 3);
        int v15 = (__int16 *)((char *)v10 - 8);
LABEL_19:
        if (mPacket == v17)
        {
          uint64_t v8 = 0;
          UInt32 v18 = *v15;
          a1->mIsIndependentlyDecodable = 1;
          a1->mNumberPrerollPackets = v18;
        }
        else
        {
          return 0;
        }
      }
    }
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      int v20 = 136315394;
      uint64_t v21 = "AudioFileCommon.cpp";
      __int16 v22 = 1024;
      int v23 = 634;
      _os_log_impl(&dword_18FEC0000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%25s:%-5d  null AudioPacketDependencyInfoTranslation", (uint8_t *)&v20, 0x12u);
    }
    return 4294967246;
  }
  return v8;
}

uint64_t ScanForIndependentPacketWithRestrictedRandomAccess(uint64_t a1, AudioIndependentPacketTranslation *a2, SampleToRollDistanceTable **a3, SyncSampleTable **a4)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    SInt64 mPacket = a2->mPacket;
    if ((a2->mPacket & 0x8000000000000000) == 0)
    {
      if (*(unsigned char *)a4) {
        uint64_t v9 = SyncSampleTable::IndexOfEntryWithClosestSampleNumberLessThanOrEqualTo(a4[1], a4[2], mPacket);
      }
      else {
        uint64_t v9 = -1;
      }
      if (*(unsigned char *)a3)
      {
        unint64_t v10 = SampleToRollDistanceTable::IndexOfEntryWithClosestSampleNumberLessThanOrEqualTo(a3[4], a3[5], mPacket);
        if (a1) {
          goto LABEL_13;
        }
      }
      else
      {
        unint64_t v10 = -1;
        if (a1)
        {
LABEL_13:
          if (v9 < 0)
          {
            __int16 v22 = (SInt64 *)a4[1];
            if (a4[2] == (SyncSampleTable *)v22) {
LABEL_32:
            }
              SInt64 v14 = -1;
            else {
              SInt64 v14 = *v22;
            }
          }
          else
          {
            unint64_t v11 = a4[1];
            while (mPacket >= *((void *)v11 + v9))
            {
              if (++v9 >= (unint64_t)((a4[2] - v11) >> 3)) {
                goto LABEL_32;
              }
            }
            if (v9 < 0) {
              SInt64 v14 = -1;
            }
            else {
              SInt64 v14 = *((void *)v11 + v9);
            }
          }
          int v23 = (SInt64 *)a3[4];
          uint64_t v16 = (SInt64 *)a3[5];
          if (v23 == v16)
          {
            if ((v10 & 0x8000000000000000) == 0)
            {
              unint64_t v24 = 0;
              goto LABEL_46;
            }
          }
          else
          {
            unint64_t v24 = 0;
            int v25 = a3[4];
            do
            {
              v24 += *((void *)v25 + 1);
              int v25 = (SampleToRollDistanceTable *)((char *)v25 + 24);
            }
            while (v25 != (SampleToRollDistanceTable *)v16);
            if ((v10 & 0x8000000000000000) != 0)
            {
              if (v24)
              {
                while (!v23[1])
                {
                  v23 += 3;
                  if (v23 == v16) {
                    goto LABEL_43;
                  }
                }
                SInt64 v26 = *v23;
                goto LABEL_66;
              }
              goto LABEL_65;
            }
            while (1)
            {
LABEL_46:
              if (v23 == v16)
              {
LABEL_51:
                SInt64 v31 = *(v16 - 3);
              }
              else
              {
                unint64_t v27 = v10;
                int v28 = a3[4];
                while (1)
                {
                  unint64_t v29 = *((void *)v28 + 1);
                  BOOL v20 = v27 >= v29;
                  unint64_t v30 = v27 - v29;
                  if (!v20) {
                    break;
                  }
                  int v28 = (SampleToRollDistanceTable *)((char *)v28 + 24);
                  unint64_t v27 = v30;
                  if (v28 == (SampleToRollDistanceTable *)v16) {
                    goto LABEL_51;
                  }
                }
                SInt64 v31 = *(void *)v28 + v27;
              }
              if (mPacket < v31) {
                break;
              }
              if (++v10 >= v24) {
                goto LABEL_65;
              }
            }
            if ((v10 & 0x8000000000000000) == 0)
            {
              while (v23 != v16)
              {
                unint64_t v32 = v23[1];
                BOOL v20 = v10 >= v32;
                unint64_t v33 = v10 - v32;
                if (!v20)
                {
                  SInt64 v26 = *v23 + v10;
                  goto LABEL_66;
                }
                v23 += 3;
                unint64_t v10 = v33;
              }
LABEL_43:
              SInt64 v26 = *(v16 - 3);
              goto LABEL_66;
            }
          }
          goto LABEL_65;
        }
      }
      if (v9 < 0 || (unint64_t v12 = a4[1], v13 = v9 - (mPacket == *((void *)v12 + v9)), v13 < 0))
      {
        SInt64 v14 = -1;
        if ((v10 & 0x8000000000000000) != 0) {
          goto LABEL_65;
        }
      }
      else
      {
        SInt64 v14 = *((void *)v12 + v13);
        if ((v10 & 0x8000000000000000) != 0) {
          goto LABEL_65;
        }
      }
      int v15 = a3[4];
      uint64_t v16 = (SInt64 *)a3[5];
      if (v15 == (SampleToRollDistanceTable *)v16)
      {
LABEL_29:
        unint64_t v34 = *(v16 - 3);
      }
      else
      {
        unint64_t v17 = v10;
        UInt32 v18 = a3[4];
        while (1)
        {
          unint64_t v19 = *((void *)v18 + 1);
          BOOL v20 = v17 >= v19;
          unint64_t v21 = v17 - v19;
          if (!v20) {
            break;
          }
          UInt32 v18 = (SampleToRollDistanceTable *)((char *)v18 + 24);
          unint64_t v17 = v21;
          if (v18 == (SampleToRollDistanceTable *)v16) {
            goto LABEL_29;
          }
        }
        unint64_t v34 = *(void *)v18 + v17;
      }
      uint64_t v35 = v10 - (mPacket == v34);
      if (v35 >= 0)
      {
        while (v15 != (SampleToRollDistanceTable *)v16)
        {
          unint64_t v36 = *((void *)v15 + 1);
          BOOL v20 = v35 >= v36;
          uint64_t v37 = v35 - v36;
          if (!v20)
          {
            SInt64 v26 = *(void *)v15 + v35;
            goto LABEL_66;
          }
          int v15 = (SampleToRollDistanceTable *)((char *)v15 + 24);
          uint64_t v35 = v37;
        }
        goto LABEL_43;
      }
LABEL_65:
      SInt64 v26 = -1;
LABEL_66:
      if (v14 == -1)
      {
        a1 = 0;
        a2->mIndependentlyDecodablePacket = v26;
      }
      else
      {
        if (v26 == -1)
        {
          a1 = 0;
        }
        else if (a1)
        {
          a1 = 0;
          if (v26 < v14) {
            SInt64 v14 = v26;
          }
        }
        else if (v14 <= v26)
        {
          SInt64 v14 = v26;
        }
        a2->mIndependentlyDecodablePacket = v14;
      }
      return a1;
    }
    a1 = 1885563711;
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      int v39 = 136315394;
      int v40 = "AudioFileCommon.cpp";
      __int16 v41 = 1024;
      int v42 = 672;
      _os_log_impl(&dword_18FEC0000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%25s:%-5d  invalid packet number", (uint8_t *)&v39, 0x12u);
    }
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      int v39 = 136315394;
      int v40 = "AudioFileCommon.cpp";
      __int16 v41 = 1024;
      int v42 = 671;
      _os_log_impl(&dword_18FEC0000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%25s:%-5d  null AudioIndependentPacketTranslation", (uint8_t *)&v39, 0x12u);
    }
    return 4294967246;
  }
  return a1;
}

uint64_t GetMetaHeader(uint64_t a1, unsigned __int8 *a2, unsigned int a3)
{
  if (a3 < 4) {
    return 0;
  }
  uint64_t v3 = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 124) = 0;
  unsigned int v4 = a2[3];
  BOOL v5 = v4 > 0xBF;
  if (v4 <= 0xBF) {
    unsigned int v6 = 36;
  }
  else {
    unsigned int v6 = 21;
  }
  if (v5) {
    LODWORD(v7) = 13;
  }
  else {
    LODWORD(v7) = 21;
  }
  int v8 = (a2[1] >> 3) & 1;
  unint64_t v9 = a2[2];
  if (v8) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = v7;
  }
  *(_DWORD *)(a1 + 144) = v7;
  if ((int)v7 + 4 <= a3)
  {
    uint64_t v11 = (v9 >> 2) & 3;
    unint64_t v12 = &a2[v7];
    int v13 = *v12;
    for (uint64_t i = 1; i != 4; ++i)
      int v13 = v12[i] | (v13 << 8);
    if (v13 != 1483304551 && v13 != 1231971951) {
      return 0;
    }
    if (v13 == 1231971951)
    {
      int v16 = 16;
      *(_DWORD *)(a1 + 8) = 16;
    }
    else
    {
      int v16 = 0;
    }
    unsigned int v17 = GetMetaHeader(XingHeader &,unsigned char *,unsigned int)::sr_table[v11];
    *(_DWORD *)a1 = v8;
    *(_DWORD *)(a1 + 4) = v17 >> (v8 == 0);
    uint64_t v18 = v7 + 8;
    if ((int)v7 + 8 > a3) {
      return 0;
    }
    unsigned __int8 v19 = a2[(v7 + 4) + 3];
    if (v19)
    {
      int v20 = v7 + 12;
      if ((int)v7 + 12 > a3) {
        return 0;
      }
      uint64_t v22 = 0;
      v16 |= 1u;
      *(_DWORD *)(a1 + 8) = v16;
      int v23 = a2[v18];
      unint64_t v24 = v12 + 9;
      do
        int v23 = v24[v22++] | (v23 << 8);
      while (v22 != 3);
      *(_DWORD *)(a1 + 12) = v23;
      if ((v19 & 2) == 0)
      {
LABEL_27:
        int v21 = v20;
        if ((v19 & 4) == 0)
        {
LABEL_41:
          *(_DWORD *)(a1 + 20) = -1;
          if ((v19 & 8) == 0)
          {
            int v31 = v21;
LABEL_47:
            *(_DWORD *)(a1 + 148) = v31 - *(_DWORD *)(a1 + 144);
            if (v31 + 36 <= a3)
            {
              uint64_t v35 = (v31 + 34);
              unsigned int v36 = *(unsigned __int16 *)&a2[v35];
              unsigned int v37 = 0;
              if (v31 != -34)
              {
                __int32 v38 = a2;
                do
                {
                  int v39 = *v38++;
                  unsigned int v37 = crc16_lookup[v39 ^ v37] ^ (v37 >> 8);
                  --v35;
                }
                while (v35);
              }
              unsigned int v40 = __rev16(v36);
              __int16 v41 = &a2[v31];
              int v42 = *v41;
              for (uint64_t j = 1; j != 4; ++j)
                int v42 = v41[j] | (v42 << 8);
              *(_DWORD *)(a1 + 124) = v42;
              if (v37 == v40 || v42 == 1279348037)
              {
                uint64_t v44 = 0;
                unsigned int v45 = v41[11];
                do
                  unsigned int v45 = v41[v44++ + 12] | (v45 << 8);
                while (v44 != 3);
                float v46 = (float)v45 * 0.00000011921;
                *(float *)(a1 + 128) = v46;
                unsigned int v47 = v41[15];
                unsigned __int16 v48 = _byteswap_ushort(*(_WORD *)(v41 + 15));
                *(unsigned char *)(a1 + 132) = v41[15] >> 2;
                int v49 = v48 & 0x1FF;
                if ((v47 & 2) != 0) {
                  int v49 = -v49;
                }
                *(_WORD *)(a1 + 134) = v49;
                unsigned int v50 = v41[17];
                int v51 = _byteswap_ushort(*(_WORD *)(v41 + 17)) & 0x1FF;
                if ((v50 & 2) != 0) {
                  int v51 = -v51;
                }
                BOOL v52 = v50 >= 4 || v47 >= 4;
                *(unsigned char *)(a1 + 136) = v41[17] >> 2;
                *(_WORD *)(a1 + 138) = v51;
                if (v52 || v46 != 0.0) {
                  v16 |= 0x40u;
                }
                v16 |= 0x20u;
                *(_DWORD *)(a1 + 8) = v16;
                unsigned int v54 = (v41[22] << 8) | (v41[21] << 16);
                unsigned __int16 v55 = _byteswap_ushort(*((_WORD *)v41 + 11));
                *(_WORD *)(a1 + 140) = v54 >> 12;
                *(_WORD *)(a1 + 142) = v55 & 0xFFF;
              }
            }
            if (v13 == 1231971951)
            {
              int v56 = *(_DWORD *)(a1 + 124);
              if (v56 == 1279348037 || !v56) {
                *(_DWORD *)(a1 + 8) = v16 & 0x7E;
              }
            }
            return 1;
          }
          int v31 = v21 + 4;
          if (v21 + 4 <= a3)
          {
            v16 |= 8u;
            *(_DWORD *)(a1 + 8) = v16;
            unint64_t v32 = &a2[v21];
            int v33 = *v32;
            for (uint64_t k = 1; k != 4; ++k)
              int v33 = v32[k] | (v33 << 8);
            *(_DWORD *)(a1 + 20) = v33;
            goto LABEL_47;
          }
          return 0;
        }
LABEL_37:
        int v28 = v21 + 100;
        if (v21 + 100 > a3) {
          return 0;
        }
        uint64_t v29 = 0;
        v16 |= 4u;
        *(_DWORD *)(a1 + 8) = v16;
        unint64_t v30 = &a2[v21];
        do
        {
          *(unsigned char *)(a1 + 24 + v29) = v30[v29];
          ++v29;
        }
        while (v29 != 100);
        int v21 = v28;
        goto LABEL_41;
      }
    }
    else
    {
      int v20 = v7 + 8;
      if ((a2[(v7 + 4) + 3] & 2) == 0) {
        goto LABEL_27;
      }
    }
    int v21 = v20 + 4;
    if (v20 + 4 > a3) {
      return 0;
    }
    v16 |= 2u;
    *(_DWORD *)(a1 + 8) = v16;
    int v25 = &a2[v20];
    int v26 = *v25;
    for (uint64_t m = 1; m != 4; ++m)
      int v26 = v25[m] | (v26 << 8);
    *(_DWORD *)(a1 + 16) = v26;
    if ((v19 & 4) == 0) {
      goto LABEL_41;
    }
    goto LABEL_37;
  }
  return v3;
}

uint64_t ParseiTunesSMPBData(char *a1, int a2, AudioFilePacketTableInfo *a3)
{
  *(void *)&v13[23] = *MEMORY[0x1E4F143B8];
  if (a2 < 35) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = 1667787583;
  *(void *)int v13 = 0;
  *(void *)&v12[9] = 0;
  *(void *)&v13[7] = 0;
  *(void *)unint64_t v12 = *(void *)a1;
  v12[8] = a1[8];
  SInt32 v11 = 0;
  sscanf(v12, "%X", &v11);
  if ((v11 & 0x80000000) == 0)
  {
    *(void *)&v12[9] = 0;
    *(void *)int v13 = 0;
    *(void *)&v13[7] = 0;
    *(void *)unint64_t v12 = *(void *)(a1 + 9);
    v12[8] = a1[17];
    SInt32 v10 = 0;
    sscanf(v12, "%X", &v10);
    if ((v10 & 0x80000000) == 0)
    {
      *(void *)&v13[7] = 0;
      *(void *)int v13 = 0;
      *(_OWORD *)unint64_t v12 = *(_OWORD *)(a1 + 18);
      v12[16] = a1[34];
      SInt64 v9 = 0;
      sscanf(v12, "%qX", &v9);
      SInt64 v6 = v9;
      if ((v9 & 0x8000000000000000) == 0)
      {
        uint64_t v3 = 0;
        SInt32 v7 = v10;
        a3->mPrimingFrames = v11;
        a3->mRemainderFrames = v7;
        a3->mNumberValidFrames = v6;
      }
    }
  }
  return v3;
}

uint64_t ParseiTunesNORMData(const char *a1, CACFDictionary *a2, CACFDictionary *a3)
{
  v13[5] = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = a1;
  unsigned int v4 = strlen(a1);
  if ((int)v4 < 45) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v5 = v4 / 0x2D;
  if (5 * (v4 / 0x2D) != v4 / 9) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v6 = 0;
  v13[0] = @"sc ave perceived power coeff";
  v13[1] = @"sc max perceived power coeff";
  v13[2] = @"sc max perceived power msec";
  unsigned char v13[3] = @"sc peak amplitude";
  v13[4] = @"sc peak amplitude msec";
  do
  {
    int v11 = 0;
    SInt32 v7 = v12;
    unsigned int v8 = v5;
    do
    {
      sscanf(v3, "%X", &v11);
      v3 += 9;
      snprintf(v7, (char *)v13 - v7, "%u%s", v11, " ");
      v7 += strlen(v7);
      --v8;
    }
    while (v8);
    CACFDictionary::AddCString(a2, (const __CFString *)v13[v6++], v12);
  }
  while (v6 != 5);
  return 0;
}

uint64_t ParseiTunesLOUDData(const char *a1, CACFDictionary *a2, CACFDictionary *a3)
{
  uint64_t v20 = 0;
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  __int16 v22 = 257;
  __int16 v19 = 0;
  if (sscanf(a1, "%X %X %X", &v19, &v20, (char *)&v20 + 4) < 3)
  {
LABEL_2:
    uint64_t v5 = 0xFFFFFFFFLL;
    goto LABEL_31;
  }
  if (v19 != -1)
  {
    float v6 = -(float)((float)(v19 & 0x7FFF) * 0.0039062);
    if (v19 >= 0) {
      float v6 = (float)(v19 & 0x7FFF) * 0.0039062;
    }
    CACFDictionary::AddFloat32((CACFDictionary *)&Mutable, @"aa itu true peak", v6);
  }
  BOOL v7 = v20 != 0;
  if (v20)
  {
    CFStringRef v8 = CopyMediaKindStringFromStoreItemKind(v20);
    CACFDictionary::AddString(a2, @"media kind", v8);
  }
  if (HIDWORD(v20))
  {
    unsigned int v9 = 0;
    SInt32 v10 = a1 + 11;
    do
    {
      int v17 = 0;
      int v18 = 0;
      if (v9 == 19 || sscanf(v10, "%X %X", &v18, &v17) < 2) {
        goto LABEL_2;
      }
      float v11 = (float)v17;
      float v12 = (float)(v11 * -0.25) + 6.0;
      float v13 = (float)(v17 - 204) + 70.0;
      if (v17 <= 0xCCu) {
        float v13 = (float)((float)(v17 - 128) * 0.5) + 32.0;
      }
      float v14 = v11 * 0.25;
      if (v17 > 0x80u) {
        float v14 = v13;
      }
      if (v18 != 6) {
        float v14 = v12;
      }
      CFStringRef v15 = @"aa ebu top of loudness range";
      switch((char)v18)
      {
        case 1:
        case 6:
          goto LABEL_23;
        case 2:
          CFStringRef v15 = @"aa ebu max momentary loudness";
          goto LABEL_23;
        case 3:
          CFStringRef v15 = @"aa ebu max short-term loudness";
          goto LABEL_23;
        case 4:
          CFStringRef v15 = @"aa itu loudness";
LABEL_23:
          CACFDictionary::AddFloat32((CACFDictionary *)&Mutable, v15, v14);
          goto LABEL_24;
        case 5:
          CACFDictionary::AddFloat32(a2, @"anchor loudness", v14);
LABEL_24:
          BOOL v7 = 1;
          break;
        default:
          break;
      }
      ++v9;
      v10 += 6;
    }
    while (v9 < HIDWORD(v20));
  }
  if (v7) {
    CACFDictionary::AddDictionary(a2, @"main loudness parameters", Mutable);
  }
  uint64_t v5 = 0;
LABEL_31:
  CACFDictionary::~CACFDictionary((CACFDictionary *)&Mutable);
  return v5;
}

void sub_19017FAA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  CACFDictionary::~CACFDictionary((CACFDictionary *)va);
  _Unwind_Resume(a1);
}

CFStringRef CopyMediaKindStringFromStoreItemKind(int a1)
{
  uint64_t v1 = kMediaKind_MusicValue;
  switch(a1)
  {
    case 1:
      return CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *v1);
    case 2:
      uint64_t v1 = kMediaKind_AudiobookValue;
      return CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *v1);
    case 3:
    case 4:
    case 5:
    case 7:
      return 0;
    case 6:
      uint64_t v1 = kMediaKind_MusicVideoValue;
      return CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *v1);
    case 8:
      uint64_t v1 = kMediaKind_PodcastValue;
      return CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *v1);
    case 9:
      uint64_t v1 = kMediaKind_MovieValue;
      return CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *v1);
    default:
      switch(a1)
      {
        case 24:
          uint64_t v1 = kMediaKind_iTunesUValue;
          return CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *v1);
        case 29:
          uint64_t v1 = kMediaKind_TVShowValue;
          return CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *v1);
        case 32:
          uint64_t v1 = kMediaKind_HomeVideoValue;
          return CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *v1);
        case 33:
          uint64_t v1 = kMediaKind_VoiceMemoValue;
          return CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *v1);
        default:
          return 0;
      }
  }
}

uint64_t GetSoundCheckValuesFromString(const __CFString *a1, unsigned int a2, unsigned int *a3)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = 2003334207;
  if (a1)
  {
    long long v27 = 0u;
    long long v28 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    long long v15 = 0u;
    long long v16 = 0u;
    *(_OWORD *)buffer = 0u;
    long long v14 = 0u;
    CFStringEncoding SystemEncoding = CFStringGetSystemEncoding();
    if (CFStringGetCString(a1, buffer, 256, SystemEncoding))
    {
      if (a2)
      {
        unint64_t v8 = 0;
        unsigned int v9 = buffer;
        do
        {
          unsigned int v12 = 0;
          sscanf(v9, "%u", &v12);
          a3[v8++] = v12;
          if (v8 < a2)
          {
            do
              int v10 = *v9++;
            while (v10 != 32);
          }
        }
        while (v8 != a2);
      }
      return 0;
    }
  }
  return v3;
}

uint64_t GetSCFields(CACFDictionary *a1, unsigned int *a2, unsigned int a3)
{
  uint64_t v6 = 2003334207;
  if (CACFDictionary::HasKey(a1, @"sc ave perceived power coeff"))
  {
    if (CACFDictionary::HasKey(a1, @"sc max perceived power coeff"))
    {
      if (CACFDictionary::HasKey(a1, @"sc max perceived power msec"))
      {
        if (CACFDictionary::HasKey(a1, @"sc peak amplitude"))
        {
          if (CACFDictionary::HasKey(a1, @"sc peak amplitude msec"))
          {
            unint64_t v8 = 0;
            if (CACFDictionary::GetString(a1, @"sc ave perceived power coeff", (const __CFString **)&v8))
            {
              uint64_t v6 = GetSoundCheckValuesFromString(v8, a3, a2);
              if (!v6)
              {
                unint64_t v8 = 0;
                if (!CACFDictionary::GetString(a1, @"sc max perceived power coeff", (const __CFString **)&v8))return 2003334207; {
                uint64_t v6 = GetSoundCheckValuesFromString(v8, a3, &a2[a3]);
                }
                if (v6) {
                  return v6;
                }
                unint64_t v8 = 0;
                if (!CACFDictionary::GetString(a1, @"sc max perceived power msec", (const __CFString **)&v8))return 2003334207; {
                uint64_t v6 = GetSoundCheckValuesFromString(v8, a3, &a2[2 * a3]);
                }
                if (v6) {
                  return v6;
                }
                unint64_t v8 = 0;
                if (!CACFDictionary::GetString(a1, @"sc peak amplitude", (const __CFString **)&v8)) {
                  return 2003334207;
                }
                uint64_t v6 = GetSoundCheckValuesFromString(v8, a3, &a2[3 * a3]);
                if (!v6)
                {
                  unint64_t v8 = 0;
                  uint64_t v6 = 2003334207;
                  if (CACFDictionary::GetString(a1, @"sc peak amplitude msec", (const __CFString **)&v8))return GetSoundCheckValuesFromString(v8, a3, &a2[4 * a3]); {
                }
                  }
              }
            }
          }
        }
      }
    }
  }
  return v6;
}

int *FillSCString(int *result, int a2, char *a3)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    uint64_t v3 = result;
    if ((5 * a2) <= 1) {
      uint64_t v4 = 1;
    }
    else {
      uint64_t v4 = (5 * a2);
    }
    uint64_t v5 = a3 + 9;
    do
    {
      *(v5 - 9) = 32;
      int v6 = *v3++;
      *((void *)v5 - 1) = 0x3030303030303030;
      snprintf(__str, 0x20uLL, "%X", v6);
      size_t v7 = strlen(__str);
      uint64_t result = (int *)memcpy(&v5[-v7], __str, v7);
      v5 += 9;
      --v4;
    }
    while (v4);
  }
  return result;
}

CFComparisonResult AddTextToReplayGainDict(CFComparisonResult theString1, const __CFString *a2, CACFDictionary *a3)
{
  if (!a2) {
    return theString1;
  }
  CFStringRef v3 = (const __CFString *)theString1;
  if (theString1 == kCFCompareEqualTo || !a3) {
    return theString1;
  }
  if (CFStringCompare((CFStringRef)theString1, @"REPLAYGAIN_TRACK_GAIN", 1uLL) == kCFCompareEqualTo)
  {
    theString1 = CACFDictionary::HasKey(a3, @"REPLAYGAIN_TRACK_GAIN");
    if (theString1) {
      return theString1;
    }
    float v11 = 0.0;
    theString1 = ConvertReplayGainStringToGain(a2, &v11);
    if (!theString1) {
      return theString1;
    }
    float v8 = v11;
    CFStringRef v9 = @"REPLAYGAIN_TRACK_GAIN";
    return CACFDictionary::AddFloat32(a3, v9, v8);
  }
  if (CFStringCompare(v3, @"REPLAYGAIN_TRACK_PEAK", 1uLL))
  {
    if (CFStringCompare(v3, @"REPLAYGAIN_ALBUM_GAIN", 1uLL))
    {
      theString1 = CFStringCompare(v3, @"REPLAYGAIN_ALBUM_PEAK", 1uLL);
      if (theString1) {
        return theString1;
      }
      theString1 = CACFDictionary::HasKey(a3, @"REPLAYGAIN_ALBUM_PEAK");
      if (theString1) {
        return theString1;
      }
      float DoubleValue = CFStringGetDoubleValue(a2);
      CFStringRef v7 = @"REPLAYGAIN_ALBUM_PEAK";
      goto LABEL_15;
    }
    theString1 = CACFDictionary::HasKey(a3, @"REPLAYGAIN_ALBUM_GAIN");
    if (theString1) {
      return theString1;
    }
    float v10 = 0.0;
    theString1 = ConvertReplayGainStringToGain(a2, &v10);
    if (!theString1) {
      return theString1;
    }
    float v8 = v10;
    CFStringRef v9 = @"REPLAYGAIN_ALBUM_GAIN";
    return CACFDictionary::AddFloat32(a3, v9, v8);
  }
  theString1 = CACFDictionary::HasKey(a3, @"REPLAYGAIN_TRACK_PEAK");
  if (theString1) {
    return theString1;
  }
  float DoubleValue = CFStringGetDoubleValue(a2);
  CFStringRef v7 = @"REPLAYGAIN_TRACK_PEAK";
LABEL_15:
  return CACFDictionary::AddFloat32(a3, v7, DoubleValue);
}

uint64_t ConvertReplayGainStringToGain(CFStringRef theString, float *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  MutableCFStringRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, theString);
  if (MutableCopy)
  {
    uint64_t v4 = (__CFString *)MutableCopy;
    CFRange v5 = CFStringFind(MutableCopy, @"dB", 1uLL);
    if (v5.location != -1)
    {
      if (v5.location + v5.length != CFStringGetLength(v4))
      {
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
        {
          int v9 = 136315394;
          float v10 = "AudioFileCommon.cpp";
          __int16 v11 = 1024;
          int v12 = 1438;
          _os_log_impl(&dword_18FEC0000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%25s:%-5d  dB isn't a suffix", (uint8_t *)&v9, 0x12u);
        }
        uint64_t v7 = 0;
        goto LABEL_12;
      }
      CFStringDelete(v4, v5);
    }
    CFStringTrimWhitespace(v4);
    float DoubleValue = CFStringGetDoubleValue(v4);
    *a2 = DoubleValue;
    uint64_t v7 = 1;
LABEL_12:
    CFRelease(v4);
    return v7;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    int v9 = 136315394;
    float v10 = "AudioFileCommon.cpp";
    __int16 v11 = 1024;
    int v12 = 1434;
    _os_log_impl(&dword_18FEC0000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%25s:%-5d  failed to copy input string", (uint8_t *)&v9, 0x12u);
  }
  return 0;
}

CFStringRef BitDepthFromCFString(const __CFString *result)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (result)
  {
    p_char buffer = &buffer;
    CFStringGetCString(result, &buffer, 256, 0x8000100u);
    uint64_t v2 = MEMORY[0x1E4F14390];
    do
    {
      while (1)
      {
        unsigned int v4 = *p_buffer++;
        unsigned int v3 = v4;
        if ((v4 & 0x80000000) != 0) {
          break;
        }
        if ((*(_DWORD *)(v2 + 4 * v3 + 60) & 0x4000) == 0) {
          goto LABEL_7;
        }
      }
    }
    while (__maskrune(v3, 0x4000uLL));
LABEL_7:
    unsigned int v5 = buffer - 70;
    BOOL v6 = v5 > 0x23;
    uint64_t v7 = (1 << v5) & 0x900000009;
    if (v6 || v7 == 0)
    {
      return 0;
    }
    else
    {
      int v9 = buffer & 0xDF;
      unsigned int v10 = 0;
      sscanf(v12, "%d", &v10);
      if (v9 == 70) {
        return (const __CFString *)-v10;
      }
      else {
        return (const __CFString *)v10;
      }
    }
  }
  return result;
}

CFStringRef CreateCFStringFromBitDepth(int a1)
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  if (a1 < 0) {
    snprintf(__str, 0x20uLL, "F%d");
  }
  else {
    snprintf(__str, 0x20uLL, "I%d");
  }
  return CFStringCreateWithCString(0, __str, 0x8000100u);
}

uint64_t GetSourceBitDepthFromASBD(const AudioStreamBasicDescription *a1, char a2)
{
  if ((int)a1 <= 1718378850)
  {
    if (a1 != 1634492771)
    {
      int v2 = 1634497332;
      goto LABEL_7;
    }
  }
  else if (a1 != 1718378851)
  {
    if (a1 == 1936487278)
    {
LABEL_8:
      if ((a2 & 0xF) == 0) {
        return 8;
      }
      goto LABEL_9;
    }
    int v2 = 1936487267;
LABEL_7:
    if (a1 != v2) {
      return 0;
    }
    goto LABEL_8;
  }
LABEL_9:
  uint64_t v3 = 16;
  switch(a2 & 0xF)
  {
    case 1:
      return v3;
    case 2:
      uint64_t v3 = 20;
      break;
    case 3:
      uint64_t v3 = 24;
      break;
    case 4:
      if (a1 == 1936487278 || a1 == 1936487267) {
        uint64_t v3 = 0;
      }
      else {
        uint64_t v3 = 32;
      }
      break;
    default:
      return 0;
  }
  return v3;
}

void AudioFileGenerateLoudnessInfo(AudioFileObject *a1, CACFDictionary *a2)
{
}

void sub_190180A44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, void *a18, uint64_t a19, void *a20)
{
  if (a16) {
    free(a16);
  }
  if (v21) {
    free(v21);
  }
  if (a18) {
    free(a18);
  }
  if (a20) {
    free(a20);
  }
  (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
  _Unwind_Resume(a1);
}

uint64_t AudioFileGetSoundCheckDictionaryFromLoudnessInfo(AudioFileObject *a1, CACFDictionary *a2)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  __int16 v7 = 257;
  uint64_t v4 = (*(uint64_t (**)(AudioFileObject *, CFMutableDictionaryRef *))(*(void *)a1 + 472))(a1, &Mutable);
  if (!v4) {
    AudioFileGetSoundCheckDictionaryFromLoudnessInfo((const CACFDictionary *)&Mutable, a2);
  }
  CACFDictionary::~CACFDictionary((CACFDictionary *)&Mutable);
  return v4;
}

void sub_190180B94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void AudioFileGetSoundCheckDictionaryFromLoudnessInfo(const CACFDictionary *a1, CACFDictionary *a2)
{
  int v12 = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  __int16 v11 = 257;
  if (CACFDictionary::GetDictionary(a1, @"sound check info", &v12))
  {
    CACFDictionary::operator=((uint64_t)&Mutable, v12);
    unsigned int v4 = CACFDictionary::Size((CACFDictionary *)&Mutable);
    uint64_t v5 = v4;
    std::vector<__CFString const*>::vector(v9, v4);
    std::vector<void const*>::vector(__p, v4);
    CACFDictionary::GetKeysAndValues((CACFDictionary *)&Mutable, (const void **)v9[0], (const void **)__p[0]);
    if (v4)
    {
      unint64_t v6 = 0;
      uint64_t v7 = 8 * v5;
      do
      {
        CACFDictionary::AddCFType(a2, (const __CFString *)v9[0][v6 / 8], *(const void **)((char *)__p[0] + v6));
        v6 += 8;
      }
      while (v7 != v6);
    }
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    if (v9[0])
    {
      v9[1] = v9[0];
      operator delete(v9[0]);
    }
  }
  CACFDictionary::~CACFDictionary((CACFDictionary *)&Mutable);
}

void sub_190180CBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, char a16)
{
  if (__p) {
    operator delete(__p);
  }
  if (a13) {
    operator delete(a13);
  }
  CACFDictionary::~CACFDictionary((CACFDictionary *)&a16);
  _Unwind_Resume(a1);
}

uint64_t CACFDictionary::operator=(uint64_t a1, const void *a2)
{
  if (!*(unsigned char *)(a1 + 8))
  {
    *(void *)a1 = a2;
    *(unsigned char *)(a1 + 9) = 0;
    return a1;
  }
  unsigned int v4 = *(const void **)a1;
  if (!*(void *)a1)
  {
    *(void *)a1 = a2;
    *(unsigned char *)(a1 + 9) = 0;
    if (!a2) {
      return a1;
    }
LABEL_8:
    CFRetain(a2);
    return a1;
  }
  CFRelease(v4);
  int v5 = *(unsigned __int8 *)(a1 + 8);
  *(void *)a1 = a2;
  *(unsigned char *)(a1 + 9) = 0;
  if (a2 && v5) {
    goto LABEL_8;
  }
  return a1;
}

void AudioFileGetLoudnessInfoFromSoundCheckDictionary(CFDictionaryRef *a1, CACFDictionary *a2)
{
  v21[7] = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  __int16 v18 = 257;
  MutableCFStringRef Copy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, *a1);
  if (!cf)
  {
    CFTypeRef cf = MutableCopy;
    HIBYTE(v18) = 1;
    if (!MutableCopy) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  CFRelease(cf);
  CFTypeRef cf = MutableCopy;
  HIBYTE(v18) = 1;
  if (MutableCopy) {
    BOOL v5 = v18 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5) {
LABEL_9:
  }
    CFRetain(MutableCopy);
LABEL_10:
  *(void *)long long v16 = 0;
  if (CACFDictionary::GetUInt32FromString((CACFDictionary *)&cf, @"aa bit depth pcm master", &v16[1]))CACFDictionary::AddUInt32(a2, @"bit depth pcm master"); {
  v21[0] = @"aa itu loudness";
  }
  v21[1] = @"aa ebu loudness range";
  v21[2] = @"aa ebu top of loudness range";
  v21[3] = @"aa itu true peak";
  v21[4] = @"aa ebu max momentary loudness";
  v21[5] = @"aa ebu max short-term loudness";
  v21[6] = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  __int16 v15 = 257;
  CFStringRef v6 = @"aa itu loudness";
  uint64_t v7 = 1;
  do
  {
    if (CACFDictionary::GetFloat32FromString((CACFDictionary *)&cf, v6, (float *)v16))
    {
      CACFDictionary::AddFloat32((CACFDictionary *)&Mutable, v6, *(float *)v16);
      if (HIBYTE(v18))
      {
        if (cf) {
          CFDictionaryRemoveValue((CFMutableDictionaryRef)cf, v6);
        }
      }
    }
    CFStringRef v6 = (const __CFString *)v21[v7++];
  }
  while (v6);
  v20[0] = @"aa headroom master";
  v20[1] = @"aa noise floor master";
  v20[2] = 0;
  int v12 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  __int16 v13 = 257;
  CFStringRef v8 = @"aa headroom master";
  uint64_t v9 = 1;
  do
  {
    if (CACFDictionary::GetFloat32FromString((CACFDictionary *)&cf, v8, (float *)v16))
    {
      CACFDictionary::AddUInt32((CACFDictionary *)&v12, v8);
      if (HIBYTE(v18))
      {
        if (cf) {
          CFDictionaryRemoveValue((CFMutableDictionaryRef)cf, v8);
        }
      }
    }
    CFStringRef v8 = (const __CFString *)v20[v9++];
  }
  while (v8);
  CFStringRef v10 = @"aa source bandwidth master";
  v19[0] = @"aa source bandwidth master";
  v19[1] = 0;
  uint64_t v11 = 1;
  do
  {
    if (CACFDictionary::GetUInt32FromString((CACFDictionary *)&cf, v10, &v16[1]))
    {
      CACFDictionary::AddUInt32((CACFDictionary *)&v12, v10);
      if (HIBYTE(v18))
      {
        if (cf) {
          CFDictionaryRemoveValue((CFMutableDictionaryRef)cf, v10);
        }
      }
    }
    CFStringRef v10 = (const __CFString *)v19[v11++];
  }
  while (v10);
  if (CACFDictionary::Size((CACFDictionary *)&cf)) {
    CACFDictionary::AddDictionary(a2, @"sound check info", (const __CFDictionary *)cf);
  }
  if (CACFDictionary::Size((CACFDictionary *)&Mutable)) {
    CACFDictionary::AddDictionary(a2, @"main loudness parameters", Mutable);
  }
  if (CACFDictionary::Size((CACFDictionary *)&v12)) {
    CACFDictionary::AddDictionary(a2, @"additional loudness parameters", v12);
  }
  CACFDictionary::~CACFDictionary((CACFDictionary *)&v12);
  CACFDictionary::~CACFDictionary((CACFDictionary *)&Mutable);
  CACFDictionary::~CACFDictionary((CACFDictionary *)&cf);
}

void sub_1901810E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  CACFDictionary::~CACFDictionary((CACFDictionary *)va);
  CACFDictionary::~CACFDictionary((CACFDictionary *)va1);
  _Unwind_Resume(a1);
}

uint64_t GetStoreItemKindFromLID(CACFDictionary *a1)
{
  CFStringRef theString1 = 0;
  if (!CACFDictionary::GetString(a1, @"media kind", &theString1)) {
    return 0;
  }
  uint64_t v1 = 1;
  if (CFStringCompare(theString1, @"Music", 1uLL))
  {
    if (CFStringCompare(theString1, @"Podcast", 1uLL))
    {
      if (CFStringCompare(theString1, @"Audiobook", 1uLL))
      {
        if (CFStringCompare(theString1, @"Movie", 1uLL))
        {
          if (CFStringCompare(theString1, @"TV Show", 1uLL))
          {
            if (CFStringCompare(theString1, @"Music Video", 1uLL))
            {
              if (CFStringCompare(theString1, @"iTunes U", 1uLL))
              {
                if (CFStringCompare(theString1, @"Home Video", 1uLL))
                {
                  if (CFStringCompare(theString1, @"Voice Memo", 1uLL)) {
                    return 0;
                  }
                  else {
                    return 33;
                  }
                }
                else
                {
                  return 32;
                }
              }
              else
              {
                return 24;
              }
            }
            else
            {
              return 6;
            }
          }
          else
          {
            return 29;
          }
        }
        else
        {
          return 9;
        }
      }
      else
      {
        return 2;
      }
    }
    else
    {
      return 8;
    }
  }
  return v1;
}

uint64_t LoudnessMethodsCountFromLID(const CACFDictionary *a1, unsigned int *a2)
{
  if (CACFDictionary::HasKey(a1, @"dialogue anchor parameters"))
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    __int16 v14 = 257;
    CACFDictionary::GetCACFDictionary(a1, @"dialogue anchor parameters", (CACFDictionary *)&Mutable);
    uint64_t HasKey = CACFDictionary::HasKey((CACFDictionary *)&Mutable, @"aa itu loudness");
    CACFDictionary::~CACFDictionary((CACFDictionary *)&Mutable);
  }
  else
  {
    uint64_t HasKey = 0;
  }
  if (CACFDictionary::HasKey(a1, @"main loudness parameters"))
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    __int16 v14 = 257;
    CACFDictionary::GetCACFDictionary(a1, @"main loudness parameters", (CACFDictionary *)&Mutable);
    int v5 = CACFDictionary::HasKey((CACFDictionary *)&Mutable, @"aa itu loudness");
    int v6 = CACFDictionary::HasKey((CACFDictionary *)&Mutable, @"aa ebu loudness range");
    int v7 = CACFDictionary::HasKey((CACFDictionary *)&Mutable, @"aa ebu top of loudness range");
    int v8 = CACFDictionary::HasKey((CACFDictionary *)&Mutable, @"aa ebu max momentary loudness");
    int v9 = CACFDictionary::HasKey((CACFDictionary *)&Mutable, @"aa ebu max short-term loudness");
    int v10 = CACFDictionary::HasKey((CACFDictionary *)&Mutable, @"aa production mixing level");
    int v11 = CACFDictionary::HasKey((CACFDictionary *)&Mutable, @"aa production room type");
    uint64_t HasKey = HasKey
           + v5
           + v6
           + v7
           + v8
           + v9
           + v10
           + v11
           + CACFDictionary::HasKey((CACFDictionary *)&Mutable, @"aa short term loudness");
    CACFDictionary::~CACFDictionary((CACFDictionary *)&Mutable);
  }
  if (CACFDictionary::HasKey(a1, @"album loudness parameters"))
  {
    *a2 = 0;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    __int16 v14 = 257;
    CACFDictionary::GetCACFDictionary(a1, @"album loudness parameters", (CACFDictionary *)&Mutable);
    if (CACFDictionary::HasKey((CACFDictionary *)&Mutable, @"aa itu loudness")) {
      ++*a2;
    }
    if (CACFDictionary::HasKey((CACFDictionary *)&Mutable, @"aa ebu loudness range")) {
      ++*a2;
    }
    if (CACFDictionary::HasKey((CACFDictionary *)&Mutable, @"aa ebu top of loudness range")) {
      ++*a2;
    }
    if (CACFDictionary::HasKey((CACFDictionary *)&Mutable, @"aa ebu max momentary loudness")) {
      ++*a2;
    }
    if (CACFDictionary::HasKey((CACFDictionary *)&Mutable, @"aa ebu max short-term loudness")) {
      ++*a2;
    }
    if (CACFDictionary::HasKey((CACFDictionary *)&Mutable, @"aa production mixing level")) {
      ++*a2;
    }
    if (CACFDictionary::HasKey((CACFDictionary *)&Mutable, @"aa production room type")) {
      ++*a2;
    }
    if (CACFDictionary::HasKey((CACFDictionary *)&Mutable, @"aa short term loudness")) {
      ++*a2;
    }
    CACFDictionary::~CACFDictionary((CACFDictionary *)&Mutable);
  }
  return HasKey;
}

void sub_1901815BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t CompressLoudnessRange(float a1)
{
  if (a1 >= 0.0)
  {
    if (a1 <= 32.0)
    {
      return (int)(float)((float)(a1 * 4.0) + 0.5);
    }
    else if (a1 <= 70.0)
    {
      return ((int)(float)((float)((float)(a1 + -32.0) * 2.0) + 0.5) ^ 0xFFFFFF80);
    }
    else if (a1 >= 121.0)
    {
      LOBYTE(v1) = -1;
    }
    else
    {
      return ((int)(float)((float)(a1 + -70.0) + 0.5) - 52);
    }
  }
  else
  {
    LOBYTE(v1) = 0;
  }
  return v1;
}

void PacketDependencyParser::PacketDependencyParser(PacketDependencyParser *this, const AudioStreamBasicDescription *a2, unsigned __int8 *a3, int a4)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  *((_DWORD *)this + 1) = 0;
  *((_DWORD *)this + 2) = 0;
  AudioFormatID mFormatID = a2->mFormatID;
  *(_DWORD *)this = mFormatID;
  if (mFormatID == 1970495843 && a3 != 0 && a4 != 0)
  {
    int v9 = a3;
    v21[2] = 0;
    uint64_t v22 = 0;
    uint64_t v23 = 0;
    v24[2] = 0;
    MP4AudioProgramConfig::Clear((MP4AudioProgramConfig *)v24);
    long long v26 = 0u;
    long long v25 = 0u;
    DecoderConfigDescr::cleanup((DecoderConfigDescr *)v21);
    bzero(v20, 0x5F0uLL);
    int v10 = &v9[a4];
    v18[0] = v9;
    v18[1] = v10;
    uint64_t v19 = 0;
    if ((v9 & 3) != 0)
    {
      int v11 = 0;
      char v12 = (_BYTE)v9 + 1;
      int v13 = -8;
      do
      {
        int v14 = v13;
        int v15 = *v9++;
        int v11 = v15 | (v11 << 8);
        v13 += 8;
        if ((v12 & 3) == 0) {
          break;
        }
        ++v12;
      }
      while (v9 < v10);
      v18[0] = v9;
      LODWORD(v19) = v11 << (24 - v13);
      HIDWORD(v19) = v14 + 16;
    }
    if (!MP4AudioESDS::Deserialize((uint64_t)v20, (uint64_t)v18, 0, 0))
    {
      if (v22 == 42 && (void)v25)
      {
        if (*(_DWORD *)(v25 + 12) >= 2u)
        {
          if (*(unsigned char *)(v25 + 74)) {
            int v16 = 3;
          }
          else {
            int v16 = 2;
          }
        }
        else
        {
          int v16 = 1;
        }
        uint64_t v17 = v25;
        *((_DWORD *)this + 1) = v16;
        if (*(unsigned char *)(v17 + 184)) {
          *((_DWORD *)this + 2) = 1;
        }
      }
      else
      {
        *((_DWORD *)this + 1) = 0;
      }
    }
    if (*((void *)&v26 + 1)) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v26 + 1));
    }
    if (*((void *)&v25 + 1)) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v25 + 1));
    }
  }
}

void sub_19018183C(_Unwind_Exception *a1)
{
  if (STACK[0x600]) {
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)STACK[0x600]);
  }
  if (STACK[0x5F0]) {
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)STACK[0x5F0]);
  }
  _Unwind_Resume(a1);
}

_DWORD *PacketDependencyParser::PacketDependencyInfo(_DWORD *result, uint64_t a2, uint64_t a3)
{
  if (*result == 1634754915)
  {
    unsigned int v8 = *(_DWORD *)(a2 + 24);
    int v7 = *(_DWORD *)(a2 + 28);
    unsigned int v9 = v8 >> 30;
    *(_DWORD *)(a2 + 28) = v7 - 2;
    if (v7 - 2 < 0)
    {
      unint64_t v12 = *(void *)(a2 + 8);
      unint64_t v11 = *(void *)(a2 + 16);
      int v13 = *(unsigned int **)a2;
      if (((v11 - *(_DWORD *)a2) & ~((uint64_t)(v11 - *(void *)a2) >> 63) & 0xFFFFFFFC) == 0
        || v12 > (unint64_t)v13)
      {
        uint64_t v15 = 0;
        do
        {
          int v16 = (unsigned __int8 *)v13 + v15;
          unsigned int v17 = v8 << 8;
          *(_DWORD *)(a2 + 24) = v17;
          int v18 = 255;
          if ((unint64_t)v13 + v15 < v11 && (unint64_t)v16 >= v12) {
            int v18 = *v16;
          }
          unsigned int v8 = v18 | v17;
          *(_DWORD *)(a2 + 24) = v8;
          ++v15;
        }
        while (v15 != 4);
      }
      else
      {
        unsigned int v8 = bswap32(*v13);
      }
      int v19 = v8 << (2 - v7);
      int v20 = v7 + 30;
      *(_DWORD *)(a2 + 28) = v20;
      *(void *)a2 = v13 + 1;
      v9 |= v8 >> v20;
      if (v20) {
        int v10 = v19;
      }
      else {
        int v10 = 0;
      }
    }
    else
    {
      int v10 = 4 * v8;
    }
    *(_DWORD *)(a2 + 24) = v10;
    if (v9 == 2)
    {
      *(void *)a3 = 0;
      return result;
    }
    if (v9 == 1)
    {
      uint64_t v21 = 0x100000000;
LABEL_31:
      *(void *)a3 = v21;
      return result;
    }
LABEL_30:
    uint64_t v21 = 1;
    goto LABEL_31;
  }
  if (*result != 1970495843) {
    goto LABEL_30;
  }
  int v5 = result[1];
  int v6 = result[2];
  *(void *)a3 = 1;
  if (*(_DWORD *)(a2 + 28) + 8 * (*(_DWORD *)(a2 + 16) - *(_DWORD *)a2))
  {
    uint64_t result = (_DWORD *)AT::TBitstreamReader<unsigned int>::GetBit(a2);
    if (result)
    {
      if (v6 != 1) {
        goto LABEL_11;
      }
      if (!(*(_DWORD *)(a2 + 28) + 8 * (*(_DWORD *)(a2 + 16) - *(_DWORD *)a2))) {
        return result;
      }
      uint64_t result = (_DWORD *)AT::TBitstreamReader<unsigned int>::GetBit(a2);
      if (!result)
      {
LABEL_11:
        *(_DWORD *)a3 = 0;
        *(_DWORD *)(a3 + 4) = (__int16)v5;
        return result;
      }
      if (*(_DWORD *)(a2 + 28) + 8 * (*(_DWORD *)(a2 + 16) - *(_DWORD *)a2))
      {
        uint64_t result = (_DWORD *)AT::TBitstreamReader<unsigned int>::GetBit(a2);
        if (!result) {
          LOWORD(v5) = 0;
        }
        goto LABEL_11;
      }
    }
  }
  return result;
}

uint64_t MP4BoxParser_MovieHeader::Init(MP4BoxParser **this)
{
  uint64_t result = MP4BoxParser_Full::Initialize((MP4BoxParser_Full *)this);
  if (!result)
  {
    if (*((_DWORD *)this + 5) != 1836476516) {
      return 4294967294;
    }
    if (*((unsigned char *)this + 56) == 1)
    {
      unsigned int v3 = (*((uint64_t (**)(MP4BoxParser **))*this + 3))(this);
      uint64_t result = MP4BoxParser::ReadDataSourceBytes(this[1], v3, 0x20uLL, &v9);
      if (result) {
        return result;
      }
      *((int8x16_t *)this + 4) = vrev64q_s8(v9);
      *((_DWORD *)this + 20) = bswap32(v10);
      unint64_t v4 = bswap64(v11);
    }
    else
    {
      unsigned int v5 = (*((uint64_t (**)(MP4BoxParser **))*this + 3))(this);
      uint64_t result = MP4BoxParser::ReadDataSourceBytes(this[1], v5, 0x10uLL, &v9);
      if (result) {
        return result;
      }
      int8x8_t v6 = vrev32_s8(*(int8x8_t *)v9.i8);
      *(void *)&long long v7 = v6.u32[0];
      *((void *)&v7 + 1) = v6.u32[1];
      *((_OWORD *)this + 4) = v7;
      unsigned int v8 = v9.u32[3];
      *((_DWORD *)this + 20) = bswap32(v9.u32[2]);
      unint64_t v4 = bswap32(v8);
    }
    this[11] = (MP4BoxParser *)v4;
  }
  return result;
}

void MP4BoxParser_MovieHeader::~MP4BoxParser_MovieHeader(MP4BoxParser_MovieHeader *this)
{
  uint64_t v2 = *((void *)this + 1);
  *(void *)this = &unk_1EDF8DA18;
  *((void *)this + 1) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  JUMPOUT(0x192FC8940);
}

{
  uint64_t v2;

  uint64_t v2 = *((void *)this + 1);
  *(void *)this = &unk_1EDF8DA18;
  *((void *)this + 1) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
}

uint64_t AudioConverterOOP::isOOP(AudioConverterOOP *this)
{
  return 1;
}

uint64_t AudioConverterOOP::convertComplexBuffer(AudioConverterOOP *this, unsigned int a2, const AudioBufferList *a3, AudioBufferList *a4)
{
  unsigned int v38 = a2;
  if (!*((unsigned char *)this + 96)) {
    std::__throw_bad_optional_access[abi:ne180100]();
  }
  v37[0] = this;
  v37[1] = &v38;
  if (*((unsigned char *)this + 12) || !*((unsigned char *)this + 13))
  {
    v30[0] = 0;
    char v36 = 0;
  }
  else
  {
    uint64_t v7 = *((unsigned int *)this + 4);
    uint64_t v8 = *((unsigned int *)this + 5);
    int v23 = 2756;
    uint64_t v24 = v7;
    uint64_t v25 = v8;
    uint64_t v26 = 0;
    uint64_t v27 = 0;
    kdebug_trace();
    v30[0] = 1;
    int v31 = 2756;
    uint64_t v32 = v7;
    uint64_t v33 = v8;
    uint64_t v34 = 0;
    uint64_t v35 = 0;
    v22[0] = 0;
    char v36 = 1;
    AT::ScopedTrace::~ScopedTrace((AT::ScopedTrace *)v22);
  }
  unsigned __int8 v9 = atomic_load((unsigned __int8 *)(*((void *)this + 10) + 232));
  if (v9)
  {
    AudioConverterClientBufferManager::AudioConverterClientBufferManager((uint64_t)v22, (long long *)(*((void *)this + 10) + 32));
    if (a3->mNumberBuffers == *((_DWORD *)v28 + 12))
    {
      v21[0] = a3;
      v21[1] = &v38;
      AudioConverterClientBufferManager::AudioConverterClientBufferManager((uint64_t)v18, (long long *)(*((void *)this + 10) + 128));
      uint64_t v10 = AudioConverterRenderClient::enterRenderLoop(*(AudioConverterRenderClient **)(*((void *)this + 10) + 8), (OpaqueAudioConverter *)*((unsigned int *)this + 2), (int (*)(OpaqueAudioConverter *, unsigned int *, AudioBufferList *, AudioStreamPacketDescription **, void *))AudioConverterOOP::convertComplexBuffer(unsigned int,AudioBufferList const*,AudioBufferList*)::$_1::__invoke, v21, a4, (AudioConverterClientBufferManager *)v22, (AudioConverterClientBufferManager *)v18, &v38, 0);
      if (*((unsigned char *)this + 28) && a4->mNumberBuffers && a4->mBuffers[0].mDataByteSize)
      {
        *((unsigned char *)this + 28) = 0;
        kdebug_trace();
      }
      if (v20) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v20);
      }
      ExtendedAudioBufferList_Destroy(v19);
    }
    else
    {
      uint64_t v11 = _os_log_pack_size();
      uint64_t message = caulk::deferred_logger::create_message((caulk::deferred_logger *)gAudioConverterDeferredLog, v11 + 88, 16);
      if (message)
      {
        int v13 = (caulk::concurrent::message *)message;
        uint64_t v14 = _os_log_pack_fill();
        UInt32 mNumberBuffers = a3->mNumberBuffers;
        int v16 = *((_DWORD *)v28 + 12);
        *(_DWORD *)uint64_t v14 = 67109376;
        *(_DWORD *)(v14 + 4) = mNumberBuffers;
        *(_WORD *)(v14 + 8) = 1024;
        *(_DWORD *)(v14 + 10) = v16;
        caulk::concurrent::messenger::enqueue(*(caulk::concurrent::messenger **)(gAudioConverterDeferredLog + 16), v13);
      }
      uint64_t v10 = 4294967246;
    }
    if (v29) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v29);
    }
    ExtendedAudioBufferList_Destroy(v28);
  }
  else
  {
    uint64_t v10 = 560164718;
  }
  if (v36) {
    AT::ScopedTrace::~ScopedTrace((AT::ScopedTrace *)v30);
  }
  applesauce::raii::v1::detail::ScopeGuard<AudioConverterOOP::convertComplexBuffer(unsigned int,AudioBufferList const*,AudioBufferList*)::$_0,applesauce::raii::v1::detail::StackExitPolicy>::~ScopeGuard((uint64_t)v37);
  return v10;
}

void sub_190181EC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);
  AudioConverterClientBufferManager::~AudioConverterClientBufferManager((AudioConverterClientBufferManager *)va);
  if (*(unsigned char *)(v16 - 96)) {
    AT::ScopedTrace::~ScopedTrace((AT::ScopedTrace *)(v16 - 136));
  }
  applesauce::raii::v1::detail::ScopeGuard<AudioConverterOOP::convertComplexBuffer(unsigned int,AudioBufferList const*,AudioBufferList*)::$_0,applesauce::raii::v1::detail::StackExitPolicy>::~ScopeGuard(v16 - 88);
  _Unwind_Resume(a1);
}

uint64_t AudioConverterClientBufferManager::AudioConverterClientBufferManager(uint64_t a1, long long *a2)
{
  long long v4 = *a2;
  long long v5 = a2[1];
  *(void *)(a1 + 32) = *((void *)a2 + 4);
  *(_OWORD *)a1 = v4;
  *(_OWORD *)(a1 + 16) = v5;
  int8x8_t v6 = (void *)(a1 + 40);
  CA::AudioBuffers::AudioBuffers(v6, v7, 1);
  uint64_t v8 = (void *)*((void *)a2 + 7);
  uint64_t v9 = *((void *)a2 + 8);
  *(void *)(a1 + 56) = v8;
  *(void *)(a1 + 64) = v9;
  if (v9)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
    uint64_t v8 = *(void **)(a1 + 56);
  }
  *(unsigned char *)(a1 + 72) = v8[1] != *v8;
  int v10 = *((_DWORD *)a2 + 20);
  *(_DWORD *)(a1 + 76) = 0;
  *(_DWORD *)(a1 + 80) = v10;
  *(void *)(a1 + 88) = 0;
  return a1;
}

uint64_t AudioConverterRenderClient::enterRenderLoop(AudioConverterRenderClient *this, OpaqueAudioConverter *a2, int (*a3)(OpaqueAudioConverter *, unsigned int *, AudioBufferList *, AudioStreamPacketDescription **, void *), void *a4, AudioBufferList *a5, AudioConverterClientBufferManager *a6, AudioConverterClientBufferManager *a7, unsigned int *a8, AudioStreamPacketDescription *a9)
{
  int v13 = this;
  uint64_t v202 = *MEMORY[0x1E4F143B8];
  uint64_t v14 = *((void *)this + 30);
  *(void *)(v14 + 24) = audioipc::current_render_context(this);
  uint64_t mDataByteSize = a5->mBuffers[0].mDataByteSize;
  int v186 = a8;
  unsigned int v16 = *a8;
  if (a5->mNumberBuffers)
  {
    uint64_t v17 = 0;
    unint64_t v18 = 0;
    do
    {
      *(AudioBuffer *)(*((void *)a7 + 5) + v17 * 16 + 56) = a5->mBuffers[v17];
      ++v18;
      ++v17;
    }
    while (v18 < a5->mNumberBuffers);
  }
  int v19 = a9;
  if (*(void *)(*((void *)a7 + 7) + 8) == **((void **)a7 + 7)) {
    int v19 = 0;
  }
  *((void *)a7 + 6) = v19;
  *((_DWORD *)a7 + 19) = v16;
  *((void *)a7 + 11) = 0;
  unsigned int v184 = *a8;
  *a8 = 0;
  unsigned int v180 = *(_DWORD *)(*((void *)v13 + 31) + 128);
  if (*((_DWORD *)v13 + 85))
  {
    if (a5->mBuffers[a5->mNumberBuffers].mNumberChannels == 1094863915)
    {
      uint64_t v20 = a5[-2].mBuffers[0].mDataByteSize;
      if (v20) {
        uint64_t v21 = (uint64_t *)((char *)&a5[-2] + v20);
      }
      else {
        uint64_t v21 = 0;
      }
    }
    else
    {
      uint64_t v21 = 0;
    }
    if (mDataByteSize > v180 && (uint64_t v23 = *((void *)v13 + 9), *(_DWORD *)(v23 + 92))) {
      unsigned __int16 v24 = *(_WORD *)(v23 + 104) + 1;
    }
    else {
      unsigned __int16 v24 = 0;
    }
    unsigned int v178 = v21;
    if (v21)
    {
      uint64_t v26 = v21;
      uint64_t v25 = *v21;
      if ((unint64_t)(v26[1] - v25) <= 0x2B) {
        uint64_t v27 = 0;
      }
      else {
        uint64_t v27 = v25;
      }
      unsigned __int16 v28 = *(_WORD *)(v27 + 40);
      if (mDataByteSize <= v180) {
        unsigned __int16 v22 = v28;
      }
      else {
        unsigned __int16 v22 = v24;
      }
    }
    else
    {
      unsigned __int16 v22 = 0;
    }
    if ((unsigned __int16)(v184 / *((_DWORD *)v13 + 86)) + 1 < v22)
    {
      uint64_t v29 = _os_log_pack_size();
      uint64_t message = caulk::deferred_logger::create_message((caulk::deferred_logger *)gAudioConverterDeferredLog, v29 + 88, 2);
      if (message)
      {
        int v31 = (caulk::concurrent::message *)message;
        uint64_t v32 = _os_log_pack_fill();
        uint64_t v33 = *((void *)v13 + 44);
        *(_DWORD *)uint64_t v32 = 134218496;
        *(void *)(v32 + 4) = v33;
        *(_WORD *)(v32 + 12) = 1024;
        *(_DWORD *)(v32 + 14) = v22;
        *(_WORD *)(v32 + 18) = 1024;
        *(_DWORD *)(v32 + 20) = v184;
        caulk::concurrent::messenger::enqueue(*(caulk::concurrent::messenger **)(gAudioConverterDeferredLog + 16), v31);
      }
    }
  }
  else
  {
    unsigned __int16 v22 = 0;
    unsigned int v178 = 0;
  }
  uint64_t v34 = (unsigned int *)((char *)a6 + 76);
  unsigned int v195 = (const void **)((char *)a6 + 48);
  unint64_t v179 = a5 - 2;
  *(void *)&double v35 = 136315650;
  uint64_t v182 = mDataByteSize;
  ioData = a5;
  unsigned int v190 = (unsigned int *)v13;
  int v185 = a7;
  unsigned __int16 v181 = v22;
  do
  {
    unsigned int v36 = v184 - *v186;
    if (v184 <= *v186) {
      break;
    }
    uint64_t v37 = *((void *)a7 + 11);
    if (v37 >= mDataByteSize) {
      break;
    }
    unsigned int v38 = mDataByteSize - v37;
    unsigned int v39 = *(_DWORD *)(*((void *)v13 + 31) + 128);
    if (v39 >= v38) {
      unsigned int v40 = v38;
    }
    else {
      unsigned int v40 = *(_DWORD *)(*((void *)v13 + 31) + 128);
    }
    unsigned int v41 = v39 / *((_DWORD *)a7 + 20);
    if (*((_DWORD *)v13 + 85))
    {
      unsigned int v42 = v41 - *((_DWORD *)v13 + 87);
      if (v42 >= v36) {
        int v43 = v184 - *v186;
      }
      else {
        int v43 = v42;
      }
    }
    else if (v41 < v36 && mDataByteSize > v180)
    {
      int v43 = v39 / *((_DWORD *)a7 + 20);
    }
    else
    {
      int v43 = v184 - *v186;
    }
    uint64_t v45 = *((void *)v13 + 30);
    uint64_t v46 = 561145203;
    if (!audioipc::ipc_node_base<(audioipc::ipcnode_options)0,audioipc::eventlink_primitive,unilaterally_billed_shared_memory>::can_send((uint64_t)v13, v35))goto LABEL_172; {
    *(_WORD *)uint64_t v45 = 25601;
    }
    *(_DWORD *)(v45 + 16) = v40;
    *(_DWORD *)(v45 + 8) = v43;
    *(_WORD *)(v45 + 20) = v181;
    if (!audioipc::ipc_node_base<(audioipc::ipcnode_options)0,audioipc::eventlink_primitive,unilaterally_billed_shared_memory>::signal_wait_with_timeout((uint64_t)v13)) {
      goto LABEL_172;
    }
    uint64_t v191 = v45;
    while (1)
    {
      int v47 = *(unsigned __int8 *)(v45 + 1);
      if (v47 != 102) {
        break;
      }
      int v48 = *(_DWORD *)(v45 + 8);
      uint64_t v49 = *((void *)v13 + 31);
      unsigned int v50 = *(_DWORD *)(v49 + 40);
      if (v50 >= *(_DWORD *)(v45 + 12)) {
        int v51 = *(_DWORD *)(v45 + 12);
      }
      else {
        int v51 = *(_DWORD *)(v49 + 40);
      }
      uint64_t v52 = *(void *)(v49 + 56);
      uint64_t v53 = *(unsigned int *)(v52 + 48);
      uint64_t v54 = 16 * v53;
      if (16 * v53)
      {
        unsigned __int16 v55 = (_DWORD *)(v52 + 60);
        int v56 = (unsigned int *)(v52 + 60);
        uint64_t v57 = 16 * v53;
        do
        {
          unsigned int *v56 = v50;
          v56 += 4;
          v57 -= 16;
        }
        while (v57);
        do
        {
          _DWORD *v55 = v51;
          v55 += 4;
          v54 -= 16;
        }
        while (v54);
      }
      if (*(_DWORD *)(*((void *)a6 + 5) + 60))
      {
LABEL_56:
        uint64_t v58 = (void *)*((void *)v13 + 32);
        uint64_t v59 = (uint8_t *)v34;
        if (v58)
        {
          *(_DWORD *)buf = *(_DWORD *)(*((void *)v13 + 9) + 104);
          uint64_t v59 = buf;
          if (*(_DWORD *)buf >= *v34) {
            uint64_t v59 = (uint8_t *)v34;
          }
        }
        unsigned int v60 = *(_DWORD *)v59;
        uint64_t v61 = *((void *)v13 + 31);
        uint64_t v62 = *(void *)(v61 + 56);
        unint64_t v63 = *(unsigned int *)(v62 + 48);
        uint64_t v64 = 16 * v63;
        if (16 * v63)
        {
          int v65 = *(_DWORD *)(v61 + 40);
          int v66 = (_DWORD *)(v62 + 60);
          do
          {
            *int v66 = v65;
            v66 += 4;
            v64 -= 16;
          }
          while (v64);
        }
        uint64_t v67 = (char *)*v195;
        if (v58) {
          BOOL v68 = v67 == 0;
        }
        else {
          BOOL v68 = 1;
        }
        char v69 = v68;
        char v192 = v69;
        if (v68)
        {
          uint64_t v70 = 0;
          unsigned int v71 = *(_DWORD *)(*((void *)a6 + 5) + 60);
          if (v71 >= *(_DWORD *)(v62 + 60)) {
            unsigned int v71 = *(_DWORD *)(v62 + 60);
          }
          unsigned int v72 = *((_DWORD *)a6 + 20);
          unsigned int __src = v71 / v72;
          size_t v73 = v71 / v72 * v72;
        }
        else
        {
          uint64_t v79 = *(void *)v67;
          uint64_t v70 = *(void *)v67 - *((void *)a6 + 11);
          unsigned int v80 = *((_DWORD *)a6 + 19);
          if (v80 >= v60) {
            uint64_t v81 = v60;
          }
          else {
            uint64_t v81 = v80;
          }
          if (v81
            && ((LODWORD(v82) = *(_DWORD *)(*((void *)a6 + 5) + 60),
                 unsigned int v83 = *(_DWORD *)(v62 + 60),
                 v82 >= v83)
              ? (int64_t v82 = v83)
              : (int64_t v82 = v82),
                int64_t v84 = *((unsigned int *)v67 + 3),
                v84 <= v82))
          {
            uint64_t v105 = 0;
            uint64_t v106 = (unsigned int *)(v67 + 28);
            while (1)
            {
              size_t v73 = v84;
              if (v81 - 1 == v105) {
                break;
              }
              uint64_t v107 = *(void *)(v106 - 3);
              unsigned int v108 = *v106;
              v106 += 4;
              int64_t v84 = v107 - v79 + v108;
              ++v105;
              if (v84 > v82)
              {
                unsigned int __src = v105;
                goto LABEL_86;
              }
            }
            unsigned int __src = v81;
          }
          else
          {
            unsigned int __src = 0;
            size_t v73 = 0;
          }
        }
LABEL_86:
        if (v63)
        {
          uint64_t v85 = 0;
          unint64_t v86 = 0;
          size_t v87 = v73 + v70;
          uint64_t v88 = *((void *)a6 + 5);
          do
          {
            uint64_t v89 = *(char **)(v62 + v85 + 64);
            uint64_t v90 = *(char **)(v88 + v85 + 64);
            if (v89 != v90)
            {
              memcpy(v89, &v90[v70], v73);
              uint64_t v88 = *((void *)a6 + 5);
              unint64_t v63 = *(unsigned int *)(v62 + 48);
              uint64_t v89 = *(char **)(v88 + v85 + 64);
            }
            *(_DWORD *)(v62 + v85 + 60) = v73;
            uint64_t v91 = v88 + v85;
            *(_DWORD *)(v91 + 60) = *(_DWORD *)(v88 + v85 + 60) - v87;
            *(void *)(v91 + 64) = &v89[v87];
            ++v86;
            v85 += 16;
          }
          while (v86 < v63);
        }
        int v13 = (AudioConverterRenderClient *)v190;
        unsigned int v92 = __src;
        if ((v192 & 1) == 0)
        {
          memcpy(v58, *v195, 16 * __src);
          if (__src)
          {
            uint64_t v93 = *((void *)a6 + 11) + v70;
            uint64_t v94 = __src;
            do
            {
              *v58 -= v93;
              v58 += 2;
              --v94;
            }
            while (v94);
          }
          *unsigned int v195 = (char *)*v195 + 16 * __src;
        }
        unsigned int v95 = *((_DWORD *)a6 + 19) - __src;
        *((_DWORD *)a6 + 19) = v95;
        *((void *)a6 + 11) += v73 + v70;
        if (v95) {
          char v96 = 1;
        }
        else {
          char v96 = v192;
        }
        if ((v96 & 1) == 0)
        {
          uint64_t v97 = *((void *)a6 + 5);
          uint64_t v98 = *(unsigned int *)(v97 + 48);
          if (v98)
          {
            uint64_t v99 = (_DWORD *)(v97 + 60);
            do
            {
              *uint64_t v99 = 0;
              v99 += 4;
              --v98;
            }
            while (v98);
          }
        }
        int v100 = 0;
        int v101 = *(_DWORD *)(v52 + 60);
        uint64_t v45 = v191;
        uint64_t v34 = (unsigned int *)((char *)a6 + 76);
        goto LABEL_114;
      }
      unint64_t v74 = (uint64_t *)*((void *)a6 + 7);
      uint64_t v75 = *v74;
      *((void *)a6 + 6) = *v74;
      if (v53)
      {
        unint64_t v76 = 0;
        uint64_t v77 = 56;
        do
        {
          *(_OWORD *)(*((void *)a6 + 5) + v77) = *(_OWORD *)(v52 + v77);
          ++v76;
          v77 += 16;
        }
        while (v76 < *(unsigned int *)(v52 + 48));
        unint64_t v74 = (uint64_t *)*((void *)a6 + 7);
        uint64_t v78 = *v74;
      }
      else
      {
        uint64_t v78 = v75;
      }
      if (v74[1] == v78) {
        uint64_t v102 = 0;
      }
      else {
        uint64_t v102 = v75;
      }
      *((void *)a6 + 6) = v102;
      *((_DWORD *)a6 + 19) = v48;
      *((void *)a6 + 11) = 0;
      int v100 = a3(a2, v34, (AudioBufferList *)(*((void *)a6 + 5) + 48), (AudioStreamPacketDescription **)v195, a4);
      if (v100)
      {
        unsigned int v92 = 0;
        int v101 = 0;
        *(_DWORD *)(*((void *)a6 + 5) + 60) = 0;
        *((void *)a6 + 6) = 0;
        *((_DWORD *)a6 + 19) = 0;
        *((void *)a6 + 11) = 0;
      }
      else
      {
        int v100 = validateInputProcData((uint64_t)a6, (unsigned int *)(*((void *)a6 + 5) + 48), *((_DWORD *)a6 + 19), *((void *)a6 + 6), *((unsigned int *)a6 + 20) | 0x100000000);
        unsigned int v103 = (AudioConverterCapturer *)*((void *)v13 + 46);
        if (v103) {
          AudioConverterCapturer::write(v103, (const AudioBufferList *)(*((void *)a6 + 5) + 48), *((const AudioStreamPacketDescription **)a6 + 6), *((_DWORD *)a6 + 19));
        }
        if (!v100) {
          goto LABEL_56;
        }
        unsigned int v92 = 0;
        int v101 = 0;
      }
LABEL_114:
      *(_DWORD *)(v45 + 4) = v100;
      uint64_t v104 = *((void *)v13 + 30);
      if (audioipc::ipc_node_base<(audioipc::ipcnode_options)0,audioipc::eventlink_primitive,unilaterally_billed_shared_memory>::can_send((uint64_t)v13, v35))
      {
        *(_WORD *)uint64_t v104 = 25602;
        *(_DWORD *)(v104 + 8) = v92;
        *(_DWORD *)(v104 + 12) = v101;
        if (audioipc::ipc_node_base<(audioipc::ipcnode_options)0,audioipc::eventlink_primitive,unilaterally_billed_shared_memory>::signal_wait_with_timeout((uint64_t)v13)) {
          continue;
        }
      }
      uint64_t v46 = 561145203;
      goto LABEL_172;
    }
    uint64_t v46 = 561145203;
    if (v47 == 100) {
      goto LABEL_172;
    }
    if (v47 != 101)
    {
      uint64_t v46 = 4294967246;
      goto LABEL_172;
    }
    unint64_t v109 = *(unsigned int *)(v45 + 8);
    uint64_t v110 = *((void *)v13 + 31);
    uint64_t v111 = *(void *)(v110 + 144);
    unint64_t v112 = (unsigned int *)(v111 + 48);
    uint64_t v113 = 16 * *(unsigned int *)(v111 + 48);
    if (v113)
    {
      int v114 = *(_DWORD *)(v45 + 16);
      int v115 = *(_DWORD *)(v110 + 128);
      int v116 = (_DWORD *)(v111 + 60);
      unint64_t v117 = (_DWORD *)(v111 + 60);
      uint64_t v118 = 16 * *(unsigned int *)(v111 + 48);
      do
      {
        _DWORD *v117 = v115;
        v117 += 4;
        v118 -= 16;
      }
      while (v118);
      do
      {
        *int v116 = v114;
        v116 += 4;
        v113 -= 16;
      }
      while (v113);
    }
    uint64_t v119 = *((void *)v185 + 7);
    int v120 = *(void **)v119;
    if (v109)
    {
      int v121 = (const void *)*((void *)v13 + 33);
      int v122 = *(void **)(v119 + 8);
      if (v121 && v122 != v120)
      {
        memmove(v120, v121, 16 * v109);
        int v120 = (void *)**((void **)v185 + 7);
      }
    }
    if (validateInputProcData((uint64_t)v185, v112, v109, (uint64_t)v120, *((unsigned int *)v185 + 20) | 0x100000000))
    {
      uint64_t v46 = 2003329396;
      AudioConverterLog();
      uint64_t v124 = AudioConverterLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)AudioConverterLog(void)::gLog, OS_LOG_TYPE_ERROR))
      {
        uint64_t v125 = *((void *)v13 + 44);
        *(_DWORD *)buf = 136315650;
        uint64_t v197 = "AudioConverterRenderClient.h";
        __int16 v198 = 1024;
        int v199 = 219;
        __int16 v200 = 2048;
        uint64_t v201 = v125;
        _os_log_impl(&dword_18FEC0000, v124, OS_LOG_TYPE_ERROR, "%25s:%-5d The converter service for %p is returning unexpected data.", buf, 0x1Cu);
      }
      goto LABEL_172;
    }
    int v126 = *((unsigned __int8 *)v185 + 72);
    if (*((unsigned char *)v185 + 72))
    {
      if (!v109) {
        goto LABEL_146;
      }
      LODWORD(v127) = *(_DWORD *)(*((void *)v185 + 5) + 60);
      unsigned int v128 = *(_DWORD *)(v111 + 60);
      if (v127 >= v128) {
        int64_t v127 = v128;
      }
      else {
        int64_t v127 = v127;
      }
      uint64_t v129 = **((void **)v185 + 7);
      if (v109 <= (*(void *)(*((void *)v185 + 7) + 8) - v129) >> 4)
      {
        uint64_t v133 = 0;
        size_t v130 = 0;
        while (1)
        {
          int64_t v134 = *(void *)v129 + *(unsigned int *)(v129 + 12);
          if (v134 > v127) {
            break;
          }
          v129 += 16;
          ++v133;
          size_t v130 = v134;
          if (v109 == v133)
          {
            size_t v130 = v134;
            goto LABEL_155;
          }
        }
        LODWORD(v109) = v133;
      }
      else
      {
        LODWORD(v109) = 0;
LABEL_146:
        size_t v130 = 0;
      }
    }
    else
    {
      unsigned int v131 = *(_DWORD *)(*((void *)v185 + 5) + 60);
      if (v131 >= *(_DWORD *)(v111 + 60)) {
        unsigned int v131 = *(_DWORD *)(v111 + 60);
      }
      unsigned int v132 = *((_DWORD *)v185 + 20);
      LODWORD(v109) = v131 / v132;
      size_t v130 = v131 / v132 * v132;
    }
LABEL_155:
    unint64_t v135 = *v112;
    if (v135)
    {
      uint64_t v136 = 0;
      unint64_t v137 = 0;
      uint64_t v138 = *((void *)v185 + 5);
      uint64_t v139 = v111 + 64;
      do
      {
        uint64_t v140 = *(char **)(v139 + v136);
        uint64_t v141 = *(char **)(v138 + v136 + 64);
        if (v140 != v141)
        {
          memcpy(v141, v140, v130);
          uint64_t v138 = *((void *)v185 + 5);
          unint64_t v135 = *v112;
          uint64_t v140 = *(char **)(v138 + v136 + 64);
        }
        uint64_t v142 = v138 + v136;
        *(_DWORD *)(v142 + 60) = *(_DWORD *)(v138 + v136 + 60) - v130;
        *(void *)(v142 + 64) = &v140[v130];
        ++v137;
        v136 += 16;
      }
      while (v137 < v135);
      int v126 = *((unsigned __int8 *)v185 + 72);
    }
    if (v126)
    {
      uint64_t v143 = (void *)*((void *)v185 + 6);
      if (v143)
      {
        memcpy(v143, **((const void ***)v185 + 7), 16 * v109);
        uint64_t v144 = *((void *)v185 + 6);
        if (v109)
        {
          uint64_t v145 = *((void *)v185 + 11);
          uint64_t v146 = (void *)*((void *)v185 + 6);
          uint64_t v147 = v109;
          do
          {
            *v146 += v145;
            v146 += 2;
            --v147;
          }
          while (v147);
        }
        *((void *)v185 + 6) = v144 + 16 * v109;
        *((_DWORD *)v185 + 19) += v109;
      }
    }
    *((void *)v185 + 11) += v130;
    *v186 += v109;
    int v13 = (AudioConverterRenderClient *)v190;
    unsigned int v148 = v190[87];
    unsigned int v149 = v190[86];
    if (v148 && v109 < v149) {
      unsigned int v150 = 0;
    }
    else {
      unsigned int v150 = (v148 + v109 - v149) % v149;
    }
    v190[87] = v150;
    uint64_t v46 = *(unsigned int *)(v45 + 4);
LABEL_172:
    a5 = ioData;
    if (*((_DWORD *)v13 + 85))
    {
      if (ioData->mBuffers[ioData->mNumberBuffers].mNumberChannels == 1094863915)
      {
        uint64_t v151 = ioData[-2].mBuffers[0].mDataByteSize;
        uint64_t v152 = (uint64_t *)((char *)v179 + v151);
        if (v151)
        {
          uint64_t v153 = *((void *)v13 + 31);
          if (*(_DWORD *)(v153 + 136))
          {
            uint64_t v154 = *(void *)(v153 + 160);
            if (v154)
            {
              uint64_t v155 = *v152;
              if ((unint64_t)(v152[1] - *v152) >= 0x2C && v155 != 0)
              {
                unsigned int v157 = *(_DWORD *)(v155 + 40);
                if (v157)
                {
                  uint64_t v158 = v155 + 44;
                  if (*(_DWORD *)(v155 + 64))
                  {
                    unsigned int v159 = 0;
                    do
                    {
                      v158 += *(unsigned int *)(v158 + 8);
                      ++v159;
                      if (*(_DWORD *)(v158 + 20)) {
                        BOOL v160 = v159 >= v157;
                      }
                      else {
                        BOOL v160 = 1;
                      }
                    }
                    while (!v160);
                  }
                  else
                  {
                    unsigned int v159 = 0;
                  }
                  int v193 = *(_DWORD *)(v154 + 40);
                  if (v193)
                  {
                    int v161 = 0;
                    unsigned int v162 = (_DWORD *)(v154 + *(unsigned int *)(v154 + 32) + 20);
                    do
                    {
                      if (v159 + v161 >= *(_DWORD *)(v155 + 40) || !*v162 || !*(_DWORD *)(v158 + 28)) {
                        break;
                      }
                      if (!(v161 | (v159 + v161))) {
                        *(void *)uint64_t v155 = *((void *)v162 - 1);
                      }
                      unint64_t v163 = *(void **)(v158 + 32);
                      unsigned int v164 = v162[2];
                      uint64_t v165 = v153;
                      uint64_t v166 = v155;
                      memcpy(v163, (const void *)(*(void *)(v153 + 152) + (*(_DWORD *)(v153 + 136) * v161)), v164);
                      memcpy((void *)v158, v162 - 5, *(v162 - 3));
                      uint64_t v155 = v166;
                      uint64_t v153 = v165;
                      *(_DWORD *)(v158 + 28) = v164;
                      *(void *)(v158 + 32) = v163;
                      LODWORD(v167) = *(_DWORD *)(v158 + 20);
                      double v35 = *(double *)(v166 + 8) + (double)v167;
                      *(double *)(v166 + 8) = v35;
                      v158 += *(unsigned int *)(v158 + 8);
                      ++v161;
                      v162 += 10;
                      a5 = ioData;
                      int v13 = (AudioConverterRenderClient *)v190;
                    }
                    while (v193 != v161);
                  }
                }
              }
            }
          }
        }
      }
    }
    a7 = v185;
    uint64_t mDataByteSize = v182;
    if (v46) {
      goto LABEL_202;
    }
    uint64_t v34 = (unsigned int *)((char *)a6 + 76);
  }
  while (*(_DWORD *)(*((void *)v13 + 30) + 8));
  uint64_t v46 = 0;
LABEL_202:
  uint64_t mNumberBuffers = a5->mNumberBuffers;
  if (mNumberBuffers)
  {
    UInt32 v169 = *((_DWORD *)a7 + 22);
    p_uint64_t mDataByteSize = &a5->mBuffers[0].mDataByteSize;
    do
    {
      *p_uint64_t mDataByteSize = v169;
      p_mDataByteSize += 4;
      --mNumberBuffers;
    }
    while (mNumberBuffers);
  }
  if (v178)
  {
    uint64_t v171 = *((void *)v13 + 31);
    if (*(_DWORD *)(v171 + 136))
    {
      if (*(void *)(v171 + 160))
      {
        uint64_t v172 = *v178;
        if ((unint64_t)(v178[1] - *v178) >= 0x2C && v172 != 0)
        {
          int v174 = *(_DWORD *)(v172 + 64);
          if (v174)
          {
            int v174 = 0;
            uint64_t v175 = v172 + 44;
            while (*(_DWORD *)(v172 + 40) != v174)
            {
              v175 += *(unsigned int *)(v175 + 8);
              ++v174;
              if (!*(_DWORD *)(v175 + 20)) {
                goto LABEL_218;
              }
            }
            int v174 = *(_DWORD *)(v172 + 40);
          }
LABEL_218:
          *(_DWORD *)(v172 + 40) = v174;
        }
      }
    }
  }
  unsigned int v176 = (AudioConverterCapturer *)*((void *)v13 + 47);
  if (v176) {
    AudioConverterCapturer::write(v176, a5, a9, *v186);
  }
  return v46;
}

void AudioConverterClientBufferManager::~AudioConverterClientBufferManager(AudioConverterClientBufferManager *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 8);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  ExtendedAudioBufferList_Destroy(*((std::pmr **)this + 5));
}

uint64_t applesauce::raii::v1::detail::ScopeGuard<AudioConverterOOP::convertComplexBuffer(unsigned int,AudioBufferList const*,AudioBufferList*)::$_0,applesauce::raii::v1::detail::StackExitPolicy>::~ScopeGuard(uint64_t result)
{
  if (!*(unsigned char *)(*(void *)result + 96)) {
    std::__throw_bad_optional_access[abi:ne180100]();
  }
  return result;
}

uint64_t AudioConverterOOP::convertComplexBuffer(unsigned int,AudioBufferList const*,AudioBufferList*)::$_1::__invoke(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, unsigned int **a5)
{
  long long v5 = *a5;
  *a2 = *a5[1];
  uint64_t v6 = *v5;
  *a3 = v6;
  if (v6)
  {
    uint64_t v7 = a3 + 4;
    uint64_t v8 = (uint64_t *)(v5 + 4);
    do
    {
      *(v7 - 1) = *(v8 - 1);
      uint64_t v9 = *v8;
      v8 += 2;
      *uint64_t v7 = v9;
      v7 += 2;
      --v6;
    }
    while (v6);
  }
  return 0;
}

uint64_t AudioConverterOOP::fillComplexBuffer(uint64_t a1, int (*a2)(OpaqueAudioConverter *, unsigned int *, AudioBufferList *, AudioStreamPacketDescription **, void *), void *a3, unsigned int *a4, AudioBufferList *a5, AudioStreamPacketDescription *a6, uint64_t a7)
{
  uint64_t v29 = a4;
  unsigned __int8 v7 = atomic_load((unsigned __int8 *)(*(void *)(a1 + 80) + 232));
  if ((v7 & 1) == 0) {
    return 560164718;
  }
  if (a7)
  {
    uint64_t v8 = 1869627199;
    uint64_t v9 = _os_log_pack_size();
    uint64_t message = caulk::deferred_logger::create_message((caulk::deferred_logger *)gAudioConverterDeferredLog, v9 + 88, 16);
    if (message)
    {
      uint64_t v11 = (caulk::concurrent::message *)message;
      *(_WORD *)_os_log_pack_fill() = 0;
      caulk::concurrent::messenger::enqueue(*(caulk::concurrent::messenger **)(gAudioConverterDeferredLog + 16), v11);
    }
  }
  else
  {
    if (!*(unsigned char *)(a1 + 96)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    uint64_t v17 = v29;
    v28[0] = a1;
    v28[1] = &v29;
    if (*(unsigned char *)(a1 + 12) || !*(unsigned char *)(a1 + 13))
    {
      v21[0] = 0;
      char v27 = 0;
    }
    else
    {
      uint64_t v18 = *(unsigned int *)(a1 + 16);
      uint64_t v19 = *(unsigned int *)(a1 + 20);
      int v31 = 2756;
      uint64_t v32 = v18;
      uint64_t v33 = v19;
      uint64_t v34 = 0;
      uint64_t v35 = 0;
      kdebug_trace();
      v21[0] = 1;
      int v22 = 2756;
      uint64_t v23 = v18;
      uint64_t v24 = v19;
      uint64_t v25 = 0;
      uint64_t v26 = 0;
      v30[0] = 0;
      char v27 = 1;
      AT::ScopedTrace::~ScopedTrace((AT::ScopedTrace *)v30);
      uint64_t v17 = v29;
    }
    uint64_t v8 = AudioConverterRenderClient::enterRenderLoop(*(AudioConverterRenderClient **)(*(void *)(a1 + 80) + 8), (OpaqueAudioConverter *)*(unsigned int *)(a1 + 8), a2, a3, a5, (AudioConverterClientBufferManager *)(*(void *)(a1 + 80) + 32), (AudioConverterClientBufferManager *)(*(void *)(a1 + 80) + 128), v17, a6);
    if (*(unsigned char *)(a1 + 28) && *v29)
    {
      *(unsigned char *)(a1 + 28) = 0;
      kdebug_trace();
    }
    if (v27) {
      AT::ScopedTrace::~ScopedTrace((AT::ScopedTrace *)v21);
    }
    applesauce::raii::v1::detail::ScopeGuard<AudioConverterOOP::fillComplexBuffer(int (*)(OpaqueAudioConverter *,unsigned int *,AudioBufferList *,AudioStreamPacketDescription **,void *),void *,unsigned int *,AudioBufferList *,AudioStreamPacketDescription *,AudioStreamPacketDependencyInfo *)::$_0,applesauce::raii::v1::detail::StackExitPolicy>::~ScopeGuard((uint64_t)v28);
  }
  return v8;
}

void sub_190182F24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  applesauce::raii::v1::detail::ScopeGuard<AudioConverterOOP::fillComplexBuffer(int (*)(OpaqueAudioConverter *,unsigned int *,AudioBufferList *,AudioStreamPacketDescription **,void *),void *,unsigned int *,AudioBufferList *,AudioStreamPacketDescription *,AudioStreamPacketDependencyInfo *)::$_0,applesauce::raii::v1::detail::StackExitPolicy>::~ScopeGuard((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t applesauce::raii::v1::detail::ScopeGuard<AudioConverterOOP::fillComplexBuffer(int (*)(OpaqueAudioConverter *,unsigned int *,AudioBufferList *,AudioStreamPacketDescription **,void *),void *,unsigned int *,AudioBufferList *,AudioStreamPacketDescription *,AudioStreamPacketDependencyInfo *)::$_0,applesauce::raii::v1::detail::StackExitPolicy>::~ScopeGuard(uint64_t result)
{
  if (!*(unsigned char *)(*(void *)result + 96)) {
    std::__throw_bad_optional_access[abi:ne180100]();
  }
  return result;
}

uint64_t AudioConverterOOP::fillBuffer(AudioConverterOOP *this, int (*a2)(OpaqueAudioConverter *, unsigned int *, void **, void *), void *a3, unsigned int *a4, void *a5)
{
  return 4294967292;
}

uint64_t AudioConverterOOP::convertBuffer(AudioConverterOOP *this, unsigned int a2, const void *a3, unsigned int *a4, void *a5)
{
  uint64_t v46 = a4;
  if (!*((unsigned char *)this + 96)) {
    std::__throw_bad_optional_access[abi:ne180100]();
  }
  v45[0] = this;
  v45[1] = &v46;
  if (*((unsigned char *)this + 12) || !*((unsigned char *)this + 13))
  {
    v38[0] = 0;
    char v44 = 0;
  }
  else
  {
    uint64_t v9 = *((unsigned int *)this + 4);
    uint64_t v10 = *((unsigned int *)this + 5);
    int v23 = 2756;
    uint64_t v24 = v9;
    uint64_t v25 = v10;
    uint64_t v26 = 0;
    uint64_t v27 = 0;
    kdebug_trace();
    v38[0] = 1;
    int v39 = 2756;
    uint64_t v40 = v9;
    uint64_t v41 = v10;
    uint64_t v42 = 0;
    uint64_t v43 = 0;
    v22[0] = 0;
    char v44 = 1;
    AT::ScopedTrace::~ScopedTrace((AT::ScopedTrace *)v22);
  }
  unsigned __int8 v11 = atomic_load((unsigned __int8 *)(*((void *)this + 10) + 232));
  if (v11)
  {
    uint64_t v13 = *((void *)this + 10);
    int v14 = *(_DWORD *)(*(void *)(v13 + 72) + 56);
    UInt32 v15 = *(_DWORD *)(*(void *)(v13 + 168) + 56);
    UInt32 v16 = *v46;
    v33.mBuffers[0].mData = a5;
    uint64_t v34 = 1;
    int v35 = v14;
    unsigned int v36 = a2;
    uint64_t v37 = a3;
    v33.mBuffers[0].mNumberChannels = v15;
    v33.mBuffers[0].uint64_t mDataByteSize = v16;
    int v31 = a2 / *(_DWORD *)(v13 + 112);
    v32[0] = &v34;
    v32[1] = &v31;
    *(void *)&v33.uint64_t mNumberBuffers = 1;
    unsigned int v30 = v16 / *(_DWORD *)(v13 + 208);
    AudioConverterClientBufferManager::AudioConverterClientBufferManager((uint64_t)v22, (long long *)(v13 + 32));
    AudioConverterClientBufferManager::AudioConverterClientBufferManager((uint64_t)v19, (long long *)(*((void *)this + 10) + 128));
    uint64_t v12 = AudioConverterRenderClient::enterRenderLoop(*(AudioConverterRenderClient **)(*((void *)this + 10) + 8), (OpaqueAudioConverter *)*((unsigned int *)this + 2), (int (*)(OpaqueAudioConverter *, unsigned int *, AudioBufferList *, AudioStreamPacketDescription **, void *))AudioConverterOOP::convertBuffer(unsigned int,void const*,unsigned int *,void *)::$_1::__invoke, v32, &v33, (AudioConverterClientBufferManager *)v22, (AudioConverterClientBufferManager *)v19, &v30, 0);
    unsigned int v17 = *(_DWORD *)(*((void *)this + 10) + 208) * v30;
    *uint64_t v46 = v17;
    if (*((unsigned char *)this + 28) && v17)
    {
      *((unsigned char *)this + 28) = 0;
      kdebug_trace();
    }
    if (v21) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v21);
    }
    ExtendedAudioBufferList_Destroy(v20);
    if (v29) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v29);
    }
    ExtendedAudioBufferList_Destroy(v28);
  }
  else
  {
    uint64_t v12 = 560164718;
  }
  if (v44) {
    AT::ScopedTrace::~ScopedTrace((AT::ScopedTrace *)v38);
  }
  applesauce::raii::v1::detail::ScopeGuard<AudioConverterOOP::convertBuffer(unsigned int,void const*,unsigned int *,void *)::$_0,applesauce::raii::v1::detail::StackExitPolicy>::~ScopeGuard((uint64_t)v45);
  return v12;
}

void sub_1901831E8(_Unwind_Exception *a1)
{
  applesauce::raii::v1::detail::ScopeGuard<AudioConverterOOP::convertBuffer(unsigned int,void const*,unsigned int *,void *)::$_0,applesauce::raii::v1::detail::StackExitPolicy>::~ScopeGuard(v1 - 88);
  _Unwind_Resume(a1);
}

uint64_t applesauce::raii::v1::detail::ScopeGuard<AudioConverterOOP::convertBuffer(unsigned int,void const*,unsigned int *,void *)::$_0,applesauce::raii::v1::detail::StackExitPolicy>::~ScopeGuard(uint64_t result)
{
  if (!*(unsigned char *)(*(void *)result + 96)) {
    std::__throw_bad_optional_access[abi:ne180100]();
  }
  return result;
}

uint64_t AudioConverterOOP::convertBuffer(unsigned int,void const*,unsigned int *,void *)::$_1::__invoke(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, unsigned int **a5)
{
  long long v5 = *a5;
  *a2 = *a5[1];
  uint64_t v6 = *v5;
  *a3 = v6;
  if (v6)
  {
    unsigned __int8 v7 = a3 + 4;
    uint64_t v8 = (uint64_t *)(v5 + 4);
    do
    {
      *(v7 - 1) = *(v8 - 1);
      uint64_t v9 = *v8;
      v8 += 2;
      *unsigned __int8 v7 = v9;
      v7 += 2;
      --v6;
    }
    while (v6);
  }
  return 0;
}

int64_t AudioConverterOOP::setProperty(AudioConverterOOP *this, unsigned int a2, const void *a3, int *a4)
{
  UInt32 v5 = a3;
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = a2;
  if (*((unsigned char *)this + 12) || !*((unsigned char *)this + 13))
  {
    v41[0] = 0;
    char v47 = 0;
    if (!a4)
    {
LABEL_14:
      uint64_t v15 = _os_log_pack_size();
      uint64_t message = caulk::deferred_logger::create_message((caulk::deferred_logger *)gAudioConverterDeferredLog, v15 + 88, 16);
      if (message)
      {
        unsigned int v17 = (caulk::concurrent::message *)message;
        uint64_t v18 = (_DWORD *)_os_log_pack_fill();
        *uint64_t v18 = 67109120;
        v18[1] = a2;
        caulk::concurrent::messenger::enqueue(*(caulk::concurrent::messenger **)(gAudioConverterDeferredLog + 16), v17);
      }
      int64_t v19 = 4294967246;
      goto LABEL_41;
    }
  }
  else
  {
    *(_DWORD *)buf_4 = 2753;
    *(void *)&buf_4[4] = a2;
    memset(&buf_4[12], 0, 24);
    kdebug_trace();
    v41[0] = 1;
    int v42 = 2753;
    uint64_t v43 = v8;
    uint64_t v44 = 0;
    uint64_t v45 = 0;
    uint64_t v46 = 0;
    LOBYTE(buf) = 0;
    char v47 = 1;
    AT::ScopedTrace::~ScopedTrace((AT::ScopedTrace *)&buf);
    if (!a4) {
      goto LABEL_14;
    }
  }
  if (a2 == 1684891491)
  {
    if (v5)
    {
      uint64_t v9 = *(AudioConverterCapturer **)(*(void *)(*((void *)this + 10) + 8) + 368);
      if (v9) {
        AudioConverterCapturer::setDecompressionCookie(v9, a4, v5);
      }
    }
    BOOL v10 = v5 == 4;
  }
  else
  {
    BOOL v10 = v5 == 4;
    if (a2 == 1919837298 && v5 == 4)
    {
      unsigned __int8 v11 = *(void **)(*((void *)this + 10) + 8);
      int v12 = *a4;
      uint64_t v13 = v11[9];
      if (*a4) {
        uint64_t v14 = 0;
      }
      else {
        uint64_t v14 = v11[42];
      }
      v48[0] = v14;
      if (v14 != *(void *)(v13 + 88))
      {
        *(void *)(v13 + 88) = v14;
        int64_t v19 = ACOOPSharedMemory::calculateAndPartitionBuffers((ACOOPSharedMemory *)(v11 + 7));
        if (v19
          || (uint64_t v21 = v11[30],
              int64_t v19 = 561145203,
              !audioipc::ipc_node_base<(audioipc::ipcnode_options)0,audioipc::eventlink_primitive,unilaterally_billed_shared_memory>::can_send((uint64_t)v11, v20))|| (*(unsigned char *)v21 = 4, !audioipc::ipc_node_base<(audioipc::ipcnode_options)0,audioipc::eventlink_primitive,unilaterally_billed_shared_memory>::signal_wait_with_timeout((uint64_t)v11))|| (int64_t v19 = *(unsigned int *)(v21 + 4), v19))
        {
          AudioConverterLog();
          uint64_t v22 = AudioConverterLog(void)::gLog;
          if (!os_log_type_enabled((os_log_t)AudioConverterLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
            goto LABEL_41;
          }
          uint64_t v23 = v11[44];
          uint64_t v24 = "deallocate";
          *(void *)buf_4 = "AudioConverterRenderClient.h";
          int buf = 136316162;
          *(_WORD *)&buf_4[8] = 1024;
          if (!v12) {
            uint64_t v24 = "allocate";
          }
          *(_DWORD *)&buf_4[10] = 77;
          *(_WORD *)&buf_4[14] = 2048;
          *(void *)&buf_4[16] = v23;
          *(_WORD *)&buf_4[24] = 2080;
          *(void *)&buf_4[26] = v24;
          *(_WORD *)&buf_4[34] = 1024;
          int v51 = v19;
          uint64_t v25 = "%25s:%-5d AudioConverter -> %p: Repartitioning the shared memory to %s metadata failed. Returning %i";
          uint64_t v26 = v22;
          uint32_t v27 = 44;
          goto LABEL_27;
        }
      }
      BOOL v10 = 1;
    }
  }
  uint64_t v28 = CheckProperty(a2, a4, a3);
  if (!v28)
  {
    if (a2 != 1970103906) {
      PropertyMarshaller::PropertyMarshaller((PropertyMarshaller *)&buf, 0);
    }
    if (!v10)
    {
      int64_t v19 = 561211770;
      goto LABEL_41;
    }
    unsigned __int8 v33 = atomic_load((unsigned __int8 *)(*((void *)this + 10) + 232));
    if ((v33 & 1) == 0)
    {
      int64_t v19 = 560164718;
      goto LABEL_41;
    }
    uint64_t v34 = (uint64_t *)*((void *)this + 10);
    uint64_t v35 = v34[3];
    if (*a4)
    {
      if (!v35) {
        operator new();
      }
      goto LABEL_52;
    }
    if (!v35)
    {
LABEL_52:
      int64_t v19 = 0;
      goto LABEL_41;
    }
    uint64_t v37 = *v34;
    MEMORY[0x192FC7DA0](v48, 74777831);
    unsigned int v38 = *(swix::connection **)(v37 + 8);
    if (!v38) {
      std::terminate();
    }
    swix::connection::send_and_await_reply((uint64_t *)&buf, v38, (const swix::encode_message *)v48);
    int64_t v19 = swix::coder<int>::decode(*(void **)&buf_4[4], ".error");
    xpc_release(*(xpc_object_t *)&buf_4[4]);
    xpc_release((xpc_object_t)v48[1]);
    if ((unint64_t)(v19 == 0) << 32 || !v19)
    {
      std::unique_ptr<AudioConverterPropertyClient>::reset[abi:ne180100]((uint64_t *)(*((void *)this + 10) + 24), 0);
      AudioConverterLog();
      uint64_t v40 = AudioConverterLog(void)::gLog;
      int64_t v19 = 0;
      if (!os_log_type_enabled((os_log_t)AudioConverterLog(void)::gLog, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_41;
      }
      int buf = 136315650;
      *(void *)buf_4 = "AudioConverterOOP.cpp";
      *(_WORD *)&buf_4[8] = 1024;
      *(_DWORD *)&buf_4[10] = 840;
      *(_WORD *)&buf_4[14] = 2048;
      *(void *)&buf_4[16] = this;
      _os_log_impl(&dword_18FEC0000, v40, OS_LOG_TYPE_DEFAULT, "%25s:%-5d AudioConverterOOP -> %p: Stopped using messenger for bundle data", (uint8_t *)&buf, 0x1Cu);
      goto LABEL_52;
    }
    AudioConverterLog();
    uint64_t v39 = AudioConverterLog(void)::gLog;
    if (!os_log_type_enabled((os_log_t)AudioConverterLog(void)::gLog, OS_LOG_TYPE_ERROR)) {
      goto LABEL_41;
    }
    int buf = 136315650;
    *(void *)buf_4 = "AudioConverterOOP.cpp";
    *(_WORD *)&buf_4[8] = 1024;
    *(_DWORD *)&buf_4[10] = 843;
    *(_WORD *)&buf_4[14] = 2048;
    *(void *)&buf_4[16] = this;
    uint64_t v25 = "%25s:%-5d AudioConverterOOP -> %p: Unable to stop using messenger for bundle data";
    uint64_t v26 = v39;
    uint32_t v27 = 28;
LABEL_27:
    _os_log_impl(&dword_18FEC0000, v26, OS_LOG_TYPE_ERROR, v25, (uint8_t *)&buf, v27);
    goto LABEL_41;
  }
  int64_t v19 = v28;
  uint64_t v29 = _os_log_pack_size();
  uint64_t v30 = caulk::deferred_logger::create_message((caulk::deferred_logger *)gAudioConverterDeferredLog, v29 + 88, 16);
  if (v30)
  {
    int v31 = (caulk::concurrent::message *)v30;
    uint64_t v32 = _os_log_pack_fill();
    *(_DWORD *)uint64_t v32 = 134218240;
    *(void *)(v32 + 4) = this;
    *(_WORD *)(v32 + 12) = 1024;
    *(_DWORD *)(v32 + 14) = a2;
    caulk::concurrent::messenger::enqueue(*(caulk::concurrent::messenger **)(gAudioConverterDeferredLog + 16), v31);
  }
LABEL_41:
  if (v47) {
    AT::ScopedTrace::~ScopedTrace((AT::ScopedTrace *)v41);
  }
  return v19;
}

void sub_190183CA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, xpc_object_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint8_t buf,xpc_object_t object,__int16 a25,__int16 a26,int a27,int a28,__int16 a29)
{
  if (a15) {
    AT::ScopedTrace::~ScopedTrace((AT::ScopedTrace *)&a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CheckProperty(int a1, void *a2, const void *a3)
{
  v12[2] = *MEMORY[0x1E4F143B8];
  if (a1 <= 1684496751)
  {
    if (a1 <= 1651401827)
    {
      if ((a1 == 1633776744 || a1 == 1633904233) && !a2[5]) {
        return 2003329396;
      }
      return 0;
    }
    if (a1 != 1651401828)
    {
      if (a1 == 1668312419 && !a2[1]) {
        return 2003329396;
      }
      return 0;
    }
LABEL_20:
    if (!*a2) {
      return 2003329396;
    }
    return 0;
  }
  if (a1 > 1832022883)
  {
    if (a1 != 1832022884)
    {
      if (a1 != 1986946671) {
        return 0;
      }
      goto LABEL_20;
    }
    uint64_t result = 2003329396;
    if (a2[1] && a2[3]) {
      return 0;
    }
  }
  else if (a1 == 1684496752)
  {
    uint64_t result = 2003329396;
    if (*a2)
    {
      uint64_t v5 = a2[1];
      if (v5)
      {
        char v6 = 0;
        uint64_t v7 = 0;
        v12[0] = *a2;
        v12[1] = v5;
        while (1)
        {
          char v8 = v6;
          uint64_t v9 = (unsigned int *)v12[v7];
          uint64_t v10 = *v9;
          if (v10) {
            break;
          }
LABEL_30:
          char v6 = 1;
          uint64_t v7 = 1;
          if (v8) {
            return 0;
          }
        }
        unsigned __int8 v11 = v9 + 4;
        while (!*((_DWORD *)v11 - 1) || *v11)
        {
          v11 += 2;
          if (!--v10) {
            goto LABEL_30;
          }
        }
      }
    }
  }
  else
  {
    if (a1 != 1685218164) {
      return 0;
    }
    uint64_t result = 2003329396;
    uint64_t v4 = *a2;
    if (*a2)
    {
      if (*(void *)(v4 + 48) && *(void *)(v4 + 64)) {
        return 0;
      }
    }
  }
  return result;
}

uint64_t std::unique_ptr<AudioConverterPropertyClient>::reset[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    audioipc::rt_sender<(audioipc::ipcnode_options)0,audioipc::eventlink_primitive,unilaterally_billed_shared_memory>::~rt_sender(result);
    JUMPOUT(0x192FC8940);
  }
  return result;
}

uint64_t audioipc::rt_sender<(audioipc::ipcnode_options)0,audioipc::eventlink_primitive,unilaterally_billed_shared_memory>::ipc_resources(audioipc::eventlink_primitive *a1, IOSurfaceRef *a2)
{
  kern_return_t v5;
  NSObject *v6;
  xpc_object_t v7;
  xpc_object_t XPCObject;
  void *v9;
  void *v10;
  void *v11;
  xpc_object_t v13;
  xpc_object_t object;
  task_id_token_t token;
  unsigned char buf[18];
  __int16 v17;
  kern_return_t v18;
  uint64_t v19;

  int64_t v19 = *MEMORY[0x1E4F143B8];
  audioipc::eventlink_primitive::ipc_resources(a1, (uint64_t)(a2 + 5));
  token = 0;
  uint64_t v4 = (ipc_space_t *)MEMORY[0x1E4F14960];
  uint64_t v5 = task_create_identity_token(*MEMORY[0x1E4F14960], &token);
  if (v5)
  {
    AudioConverterLog();
    char v6 = (id) AudioConverterLog(void)::gLog;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136315650;
      *(void *)&uint8_t buf[4] = "ACOOPSharedMemory.mm";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 93;
      unsigned int v17 = 1024;
      uint64_t v18 = v5;
      _os_log_impl(&dword_18FEC0000, v6, OS_LOG_TYPE_ERROR, "%25s:%-5d unilaterally_billed_shared_memory - error on task_create_identity_token: %u", buf, 0x18u);
    }
    uint64_t v13 = 0;
  }
  else
  {
    uint64_t v7 = xpc_dictionary_create(0, 0, 0);
    XPCObject = IOSurfaceCreateXPCObject(*a2);
    xpc_dictionary_set_value(v7, "surface", XPCObject);

    uint64_t v9 = (void *)xpc_mach_send_create();
    xpc_dictionary_set_value(v7, "token", v9);

    mach_port_deallocate(*v4, token);
    caulk::mach::details::release_os_object(0, v10);
    uint64_t v13 = v7;
    if (v7)
    {
      xpc_retain(v7);
      goto LABEL_8;
    }
  }
  uint64_t v7 = 0;
  uint64_t v13 = xpc_null_create();
LABEL_8:
  *(void *)int buf = a1;
  *(void *)&buf[8] = "sharedMemory";
  applesauce::xpc::dict::object_proxy::operator=(&object, (uint64_t)buf, &v13);
  xpc_release(object);
  object = 0;
  xpc_release(v13);
  return caulk::mach::details::release_os_object((caulk::mach::details *)v7, v11);
}

void sub_190184328(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  __clang_call_terminate(a1);
}

void audioipc::rt_sender<(audioipc::ipcnode_options)0,audioipc::eventlink_primitive,unilaterally_billed_shared_memory>::~rt_sender(uint64_t a1)
{
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)(a1 + 33));
  if ((v2 & 1) == 0)
  {
    unsigned int v3 = atomic_load(*(unsigned int **)(a1 + 8));
    if (v3 != 2)
    {
      atomic_store(1u, (unsigned __int8 *)(a1 + 33));
      atomic_store(2u, *(unsigned int **)(a1 + 8));
      audioipc::eventlink_primitive::timed_wait_signal_or_error(*(audioipc::eventlink_primitive **)(a1 + 40), 0.02);
      os_eventlink_cancel();
    }
  }
  audioipc::eventlink_primitive::~eventlink_primitive((audioipc::eventlink_primitive *)(a1 + 40));
  unilaterally_billed_shared_memory::~unilaterally_billed_shared_memory((const void **)a1);
}

uint64_t audioipc::ipc_node_base<(audioipc::ipcnode_options)0,audioipc::eventlink_primitive,unilaterally_billed_shared_memory>::ipc_node_base(uint64_t a1, uint64_t a2)
{
  unsigned int v16[2] = *MEMORY[0x1E4F143B8];
  *(void *)a1 = 0;
  size_t v3 = caulk::numeric::exceptional_add<unsigned long>(a2 + 16, 16382) & 0xFFFFFFFFFFFFC001;
  v15[0] = *MEMORY[0x1E4F2EFB8];
  uint64_t v4 = [MEMORY[0x1E4F28ED0] numberWithUnsignedLong:v3];
  v15[1] = *MEMORY[0x1E4F2F268];
  v16[0] = v4;
  v16[1] = MEMORY[0x1E4F1CC38];
  CFDictionaryRef v5 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v16 forKeys:v15 count:2];
  IOSurfaceRef v6 = IOSurfaceCreate(v5);
  uint64_t v7 = *(const void **)a1;
  *(void *)a1 = v6;
  if (v7) {
    CFRelease(v7);
  }

  if (!*(void *)a1)
  {
    AudioConverterLog();
    uint64_t v9 = (id) AudioConverterLog(void)::gLog;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      int v11 = 136315394;
      int v12 = "ACOOPSharedMemory.mm";
      __int16 v13 = 1024;
      int v14 = 23;
      _os_log_impl(&dword_18FEC0000, v9, OS_LOG_TYPE_ERROR, "%25s:%-5d unilaterally_billed_shared_memory - error on IOSurfaceCreate", (uint8_t *)&v11, 0x12u);
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "bad IOSurface");
  }
  IOSurfaceSetValue(*(IOSurfaceRef *)a1, (CFStringRef)*MEMORY[0x1E4F2F128], @"AudioConverter Shared memory");
  if (IOSurfaceGetAllocSize(*(IOSurfaceRef *)a1) < v3
    || !unilaterally_billed_shared_memory::get_raw_ptr((IOSurfaceRef *)a1, 0))
  {
    std::terminate();
  }
  *(void *)(a1 + 8) = unilaterally_billed_shared_memory::get_raw_ptr((IOSurfaceRef *)a1, 0);
  *(void *)(a1 + 16) = unilaterally_billed_shared_memory::get_raw_ptr((IOSurfaceRef *)a1, 0) + 8;
  *(void *)(a1 + 24) = unilaterally_billed_shared_memory::get_raw_ptr((IOSurfaceRef *)a1, 0x10uLL);
  *(_WORD *)(a1 + 32) = 1;
  *(void *)(a1 + 40) = os_eventlink_create();
  *(_DWORD *)(a1 + 48) = 0;
  return a1;
}

void sub_190184610(_Unwind_Exception *a1)
{
  __cxa_free_exception(v2);
  if (*v1) {
    CFRelease(*v1);
  }
  _Unwind_Resume(a1);
}

uint64_t ACOOPSharedMemory::calculateAndPartitionBuffers(ACOOPSharedMemory *this)
{
  v96[1] = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *((void *)this + 2);
  if (*(_DWORD *)(v1 + 88)) {
    return 2003329396;
  }
  unint64_t v4 = caulk::numeric::exceptional_add<unsigned long>(*((void *)this + 1) - *(void *)(v1 + 112) - 15, 15) & 0xFFFFFFFFFFFFFFF0;
  uint64_t v5 = *((void *)this + 2);
  uint64_t v6 = *(unsigned int *)(v5 + 92);
  if (!v6)
  {
    if ((*(unsigned char *)(v5 + 12) & 0x20) != 0) {
      int v12 = *(_DWORD *)(v5 + 28);
    }
    else {
      int v12 = 1;
    }
    uint64_t v13 = caulk::numeric::exceptional_add<unsigned long>((v12 * *(_DWORD *)(v5 + 96)) + 16 * *(unsigned int *)(v5 + 80), 15);
    uint64_t v14 = *((void *)this + 2);
    if ((*(unsigned char *)(v14 + 52) & 0x20) != 0) {
      int v15 = *(_DWORD *)(v14 + 68);
    }
    else {
      int v15 = 1;
    }
    if ((caulk::numeric::exceptional_add<unsigned long>((v15 * *(_DWORD *)(v14 + 100)) + 16 * *(unsigned int *)(v14 + 84), 15) & 0xFFFFFFFFFFFFFFF0)+ (v13 & 0xFFFFFFFFFFFFFFF0) > v4)return 2003329396; {
    uint64_t v16 = caulk::numeric::exceptional_add<unsigned long>((v4 >> 1) - 15, 15);
    }
    char v17 = 0;
    uint64_t v18 = 0;
    unint64_t v19 = v16 & 0xFFFFFFFFFFFFFFF0;
    v95[0] = v16 & 0xFFFFFFFFFFFFFFF0;
    v95[1] = v16 & 0xFFFFFFFFFFFFFFF0;
    v96[0] = 0x100000000;
    do
    {
      char v20 = v17;
      uint64_t v21 = *((unsigned int *)v96 + v18);
      uint64_t v22 = *((void *)this + 2);
      uint64_t v23 = v22 + 40 * v21;
      if ((*(unsigned char *)(v23 + 12) & 0x20) != 0) {
        int v24 = *(_DWORD *)(v23 + 28);
      }
      else {
        int v24 = 1;
      }
      unint64_t v25 = caulk::numeric::exceptional_add<unsigned long>((v24 * *(_DWORD *)(v22 + 4 * v21 + 96)) + 16 * *(unsigned int *)(v22 + 4 * v21 + 80), 15) & 0xFFFFFFFFFFFFFFF0;
      if (v25 > v19)
      {
        v95[v21] = v25;
        v95[1 - (int)v21] = v4 - v25;
      }
      char v17 = 1;
      uint64_t v18 = 1;
    }
    while ((v20 & 1) == 0);
    char v26 = 0;
    uint64_t v27 = 0;
    v96[0] = 0x100000000;
    uint64_t v28 = *((void *)this + 2);
    while (1)
    {
      char v29 = v26;
      uint64_t v30 = *((unsigned int *)v96 + v27);
      uint64_t v31 = v28 + 4 * v30;
      unint64_t v32 = *(unsigned int *)(v31 + 80);
      if (v32 || (uint64_t v34 = v28 + 40 * v30, (v35 = *(_DWORD *)(v34 + 16)) == 0))
      {
        unsigned int v33 = 64;
      }
      else
      {
        if ((*(unsigned char *)(v34 + 12) & 0x20) != 0) {
          int v36 = *(_DWORD *)(v34 + 28);
        }
        else {
          int v36 = 1;
        }
        unsigned int v33 = v36 * v35;
      }
      unint64_t v37 = v95[v30];
      unint64_t v38 = v37 / v33;
      unint64_t v39 = *(unsigned int *)(v31 + 96);
      if (v37 - 16 * v38 >= v39) {
        goto LABEL_40;
      }
      uint64_t v40 = v28 + 40 * v30;
      if ((*(unsigned char *)(v40 + 12) & 0x20) != 0) {
        int v41 = *(_DWORD *)(v40 + 28);
      }
      else {
        int v41 = 1;
      }
      uint64_t v42 = caulk::numeric::exceptional_add<unsigned long>((v41 * v39) + 16 * v32, 15);
      uint64_t v28 = *((void *)this + 2);
      uint64_t v43 = v28 + 4 * v30;
      unsigned int v44 = *(_DWORD *)(v43 + 96);
      unint64_t v32 = *(unsigned int *)(v43 + 80);
      if (*(_DWORD *)(v28 + 4 * (1 - v30) + 88)) {
        goto LABEL_38;
      }
      unint64_t v38 = v32;
      if (v44 <= 0x10000) {
        break;
      }
LABEL_39:
      LODWORD(v38) = (v37 - (v42 & 0xFFFFFFFFFFFFFFF0)) / (16 * v38 + v44) + 1;
LABEL_40:
      uint64_t v45 = v28 + 4 * v30;
      *(_DWORD *)(v45 + 104) = v38;
      if (v32) {
        int v46 = v38;
      }
      else {
        int v46 = 0;
      }
      *((_DWORD *)this + v30 + 54) = v46;
      unint64_t v47 = *(unsigned int *)(v45 + 104) * (unint64_t)(16 * *(_DWORD *)(v45 + 80));
      BOOL v48 = (v47 & 0xFFFFFFFF00000000) == 0;
      uint64_t v49 = v47 & 0xFFFFFFF0;
      if (v48) {
        uint64_t v50 = v49;
      }
      else {
        uint64_t v50 = 0xFFFFFFFFLL;
      }
      uint64_t v51 = caulk::numeric::exceptional_add<unsigned long>(v50, 15);
      uint64_t v28 = *((void *)this + 2);
      *(void *)(v28 + 8 * v30 + 144) = v37 - (v51 & 0xFFFFFFFFFFFFFFF0);
      char v26 = 1;
      uint64_t v27 = 1;
      if (v29) {
        goto LABEL_80;
      }
    }
    if (!v32)
    {
      uint64_t v52 = v28 + 40 * v30;
      int v53 = *(_DWORD *)(v52 + 16);
      if (v53)
      {
        if ((*(unsigned char *)(v52 + 12) & 0x20) != 0) {
          int v54 = *(_DWORD *)(v52 + 28);
        }
        else {
          int v54 = 1;
        }
        unint64_t v38 = 0;
        unsigned int v44 = v54 * v53;
      }
      else
      {
        unint64_t v38 = 0;
        unsigned int v44 = 64;
      }
      goto LABEL_39;
    }
    unsigned int v44 = 64;
LABEL_38:
    unint64_t v38 = v32;
    goto LABEL_39;
  }
  uint64_t v7 = *(unsigned int *)(v5 + 20);
  unsigned int v8 = *(_DWORD *)(v5 + 84);
  uint64_t v9 = 16 * *(unsigned int *)(v5 + 80);
  uint64_t v10 = *(unsigned int *)(v5 + 96);
  unsigned int v11 = *(_DWORD *)(v5 + 100);
  if (!*(_DWORD *)(v5 + 88) && v11 <= 0x10000)
  {
    if (!v8)
    {
      int v55 = *(_DWORD *)(v5 + 56);
      if (v55)
      {
        if ((*(unsigned char *)(v5 + 52) & 0x20) != 0) {
          int v56 = *(_DWORD *)(v5 + 68);
        }
        else {
          int v56 = 1;
        }
        unsigned int v8 = 0;
        unsigned int v11 = v56 * v55;
        goto LABEL_60;
      }
      unsigned int v8 = 0;
    }
    unsigned int v11 = 64;
  }
LABEL_60:
  uint64_t v57 = caulk::numeric::exceptional_add<unsigned long>(v6 + v10 + v9 + (16 * v8 + v11) * v7 + 40, 15);
  uint64_t v58 = *((void *)this + 2);
  int v59 = *(_DWORD *)(v58 + 92);
  unint64_t v60 = v4 - (v59 + 40) - 44;
  unint64_t v61 = v60 / (v57 & 0xFFFFFFFFFFFFFFF0);
  *(_DWORD *)(v58 + 104) = v61;
  if (v60 < (v57 & 0xFFFFFFFFFFFFFFF0)) {
    return 2003329396;
  }
  *(_DWORD *)(v58 + 108) = v7 * v61;
  unsigned int v62 = *(_DWORD *)(v58 + 96);
  if (!v59 && v62 <= 0x10000)
  {
    if (*(_DWORD *)(v58 + 80) || (int v63 = *(_DWORD *)(v58 + 16)) == 0)
    {
      unsigned int v62 = 64;
    }
    else
    {
      if ((*(unsigned char *)(v58 + 12) & 0x20) != 0) {
        int v64 = *(_DWORD *)(v58 + 28);
      }
      else {
        int v64 = 1;
      }
      unsigned int v62 = v64 * v63;
    }
  }
  uint64_t v65 = caulk::numeric::exceptional_add<unsigned long>(v62 * v61, 15);
  uint64_t v66 = *((void *)this + 2);
  *(void *)(v66 + 144) = v65 & 0xFFFFFFFFFFFFFFF0;
  unsigned int v67 = *(_DWORD *)(v66 + 100);
  if (!*(_DWORD *)(v66 + 88) && v67 <= 0x10000)
  {
    if (*(_DWORD *)(v66 + 84) || (int v68 = *(_DWORD *)(v66 + 56)) == 0)
    {
      unsigned int v67 = 64;
    }
    else
    {
      if ((*(unsigned char *)(v66 + 52) & 0x20) != 0) {
        int v69 = *(_DWORD *)(v66 + 68);
      }
      else {
        int v69 = 1;
      }
      unsigned int v67 = v69 * v68;
    }
  }
  uint64_t v70 = caulk::numeric::exceptional_add<unsigned long>(*(_DWORD *)(v66 + 108) * v67, 15);
  uint64_t v28 = *((void *)this + 2);
  *(void *)(v28 + 152) = v70 & 0xFFFFFFFFFFFFFFF0;
LABEL_80:
  uint64_t v71 = *(void *)(v28 + 112);
  unint64_t v72 = *(unsigned int *)(v28 + 108) * (unint64_t)(16 * *(_DWORD *)(v28 + 84));
  BOOL v48 = (v72 & 0xFFFFFFFF00000000) == 0;
  uint64_t v73 = v72 & 0xFFFFFFF0;
  uint64_t v74 = v48 ? v73 : 0xFFFFFFFFLL;
  uint64_t v75 = caulk::numeric::exceptional_add<unsigned long>(v74, 15);
  unint64_t v76 = *(unsigned int *)(*((void *)this + 2) + 104)
      * (unint64_t)(16 * *(_DWORD *)(*((void *)this + 2) + 80));
  BOOL v48 = (v76 & 0xFFFFFFFF00000000) == 0;
  uint64_t v77 = v76 & 0xFFFFFFF0;
  uint64_t v78 = v48 ? v77 : 0xFFFFFFFFLL;
  unint64_t v79 = (v75 & 0xFFFFFFFFFFFFFFF0)
      + v71
      + (caulk::numeric::exceptional_add<unsigned long>(v78, 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v80 = *((void *)this + 2);
  *(void *)(v80 + 120) = v79;
  unsigned int v81 = *(_DWORD *)(v80 + 92);
  if (v81)
  {
    unint64_t v82 = caulk::numeric::exceptional_add<unsigned long>(40 * (*(_DWORD *)(v80 + 104) + 1) + 44, 15) & 0xFFFFFFFFFFFFFFF0;
    uint64_t v80 = *((void *)this + 2);
    unsigned int v81 = *(_DWORD *)(v80 + 92);
  }
  else
  {
    unint64_t v82 = 0;
  }
  unint64_t v83 = v82 + v79;
  *(void *)(v80 + 128) = v83;
  unint64_t v84 = v81 * (unint64_t)(*(_DWORD *)(v80 + 104) + 1);
  uint64_t v85 = (v84 & 0xFFFFFFFF00000000) != 0 ? 0xFFFFFFFFLL : v84;
  unint64_t v86 = (caulk::numeric::exceptional_add<unsigned long>(v85, 15) & 0xFFFFFFFFFFFFFFF0) + v83;
  size_t v87 = (long long *)*((void *)this + 2);
  *((void *)v87 + 17) = v86;
  if (*((void *)v87 + 18) + *((void *)v87 + 19) + v86 > *((void *)this + 1)) {
    return 2003329396;
  }
  long long v88 = *v87;
  *(_OWORD *)((char *)this + 40) = v87[1];
  *(_OWORD *)((char *)this + 24) = v88;
  long long v89 = v87[2];
  long long v90 = v87[3];
  long long v91 = v87[4];
  *(_OWORD *)((char *)this + 104) = v87[5];
  *(_OWORD *)((char *)this + 88) = v91;
  *(_OWORD *)((char *)this + 72) = v90;
  *(_OWORD *)((char *)this + 56) = v89;
  long long v92 = v87[6];
  long long v93 = v87[7];
  long long v94 = v87[8];
  *(_OWORD *)((char *)this + 168) = v87[9];
  *(_OWORD *)((char *)this + 152) = v94;
  *(_OWORD *)((char *)this + 136) = v93;
  *(_OWORD *)((char *)this + 120) = v92;
  *((void *)this + 2) = (char *)this + 24;
  return ACOOPSharedMemory::partitionBuffers(this);
}

void sub_190184CD8(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t AudioConverterOOP::getProperty(AudioConverterOOP *this, unsigned int a2, unsigned int *a3, const void **a4)
{
  uint64_t v43 = a4;
  uint64_t v8 = a2;
  if (*((unsigned char *)this + 12) || !*((unsigned char *)this + 13))
  {
    v36[0] = 0;
    char v42 = 0;
    if (!a4) {
      goto LABEL_15;
    }
  }
  else
  {
    HIDWORD(v31) = 2754;
    xpc_object_t object = (xpc_object_t)a2;
    uint64_t v33 = 0;
    uint64_t v34 = 0;
    uint64_t v35 = 0;
    kdebug_trace();
    v36[0] = 1;
    int v37 = 2754;
    uint64_t v38 = v8;
    uint64_t v39 = 0;
    uint64_t v40 = 0;
    uint64_t v41 = 0;
    LOBYTE(v31) = 0;
    char v42 = 1;
    AT::ScopedTrace::~ScopedTrace((AT::ScopedTrace *)&v31);
    if (!a4)
    {
LABEL_15:
      uint64_t v19 = _os_log_pack_size();
      uint64_t message = caulk::deferred_logger::create_message((caulk::deferred_logger *)gAudioConverterDeferredLog, v19 + 88, 16);
      if (message)
      {
        uint64_t v21 = (caulk::concurrent::message *)message;
        uint64_t v22 = (_DWORD *)_os_log_pack_fill();
        *uint64_t v22 = 67109120;
        v22[1] = a2;
        caulk::concurrent::messenger::enqueue(*(caulk::concurrent::messenger **)(gAudioConverterDeferredLog + 16), v21);
      }
LABEL_37:
      uint64_t SpeechCodecBundleData = 4294967246;
      goto LABEL_32;
    }
  }
  if (!a3)
  {
    uint64_t v27 = _os_log_pack_size();
    uint64_t v28 = caulk::deferred_logger::create_message((caulk::deferred_logger *)gAudioConverterDeferredLog, v27 + 88, 16);
    if (v28)
    {
      char v29 = (caulk::concurrent::message *)v28;
      *(_WORD *)_os_log_pack_fill() = 0;
      caulk::concurrent::messenger::enqueue(*(caulk::concurrent::messenger **)(gAudioConverterDeferredLog + 16), v29);
    }
    goto LABEL_37;
  }
  if (a2 == 1885955104)
  {
    if (PlatformUtilities::IsInternalBuild(this))
    {
      if (*a3 >= 4)
      {
        *a3 = 4;
        uint64_t v9 = **((void **)this + 10);
        MEMORY[0x192FC7DA0](v30, 74777825);
        uint64_t v10 = *(swix::connection **)(v9 + 8);
        if (!v10) {
          std::terminate();
        }
        swix::connection::send_and_await_reply(&v31, v10, (const swix::encode_message *)v30);
        unsigned int v11 = swix::coder<int>::decode(object, ".error");
        if (v11)
        {
          uint64_t v12 = 0;
        }
        else
        {
          unsigned int v11 = swix::coder<int>::decode(object, "process");
          uint64_t v12 = 0x100000000;
        }
        xpc_release(object);
        xpc_release(v30[1]);
        uint64_t SpeechCodecBundleData = 0;
        unint64_t v25 = v12 & 0x100000000 | v11;
        if (v25 <= 0x100000000) {
          LODWORD(v25) = 0;
        }
        *(_DWORD *)uint64_t v43 = v25;
        goto LABEL_32;
      }
LABEL_31:
      uint64_t SpeechCodecBundleData = 561211770;
      goto LABEL_32;
    }
    goto LABEL_30;
  }
  uint64_t v13 = CheckProperty(a2, a4, a3);
  if (!v13)
  {
    if (a2 == 1970103906)
    {
      if (*a3 == 4)
      {
        uint64_t SpeechCodecBundleData = 0;
        *(_DWORD *)a4 = *(void *)(*((void *)this + 10) + 24) != 0;
        goto LABEL_32;
      }
      goto LABEL_31;
    }
    if (a2 == 1651401828)
    {
      uint64_t v23 = *((void *)this + 10);
      if (*(void *)(v23 + 24))
      {
        unsigned __int8 v24 = atomic_load((unsigned __int8 *)(v23 + 232));
        if ((v24 & 1) == 0)
        {
          uint64_t SpeechCodecBundleData = 560164718;
          goto LABEL_32;
        }
        if (*a3 != 336) {
          goto LABEL_31;
        }
        uint64_t SpeechCodecBundleData = AudioConverterPropertyClient::getSpeechCodecBundleData(*(void *)(*((void *)this + 10) + 24), v43);
        if (SpeechCodecBundleData != 1768846202) {
          goto LABEL_32;
        }
      }
    }
LABEL_30:
    PropertyMarshaller::PropertyMarshaller((PropertyMarshaller *)&v31, 0);
  }
  uint64_t SpeechCodecBundleData = v13;
  uint64_t v15 = _os_log_pack_size();
  uint64_t v16 = caulk::deferred_logger::create_message((caulk::deferred_logger *)gAudioConverterDeferredLog, v15 + 88, 16);
  if (v16)
  {
    char v17 = (caulk::concurrent::message *)v16;
    uint64_t v18 = _os_log_pack_fill();
    *(_DWORD *)uint64_t v18 = 134218240;
    *(void *)(v18 + 4) = this;
    *(_WORD *)(v18 + 12) = 1024;
    *(_DWORD *)(v18 + 14) = a2;
    caulk::concurrent::messenger::enqueue(*(caulk::concurrent::messenger **)(gAudioConverterDeferredLog + 16), v17);
  }
LABEL_32:
  if (v42) {
    AT::ScopedTrace::~ScopedTrace((AT::ScopedTrace *)v36);
  }
  return SpeechCodecBundleData;
}

void sub_19018549C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, xpc_object_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  if (a27) {
    AT::ScopedTrace::~ScopedTrace((AT::ScopedTrace *)&a22);
  }
  _Unwind_Resume(exception_object);
}

uint64_t AudioConverterPropertyClient::getSpeechCodecBundleData(uint64_t a1, const void **__src)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (**(_DWORD **)(a1 + 72) >= *((_DWORD *)__src + 2))
  {
    uint64_t v12 = *(void **)(a1 + 104);
    unsigned int v11 = *(void **)(a1 + 112);
    uint64_t v13 = (audioipc *)memcpy(v12, __src, 0x150uLL);
    *uint64_t v12 = v11;
    size_t v14 = *((unsigned int *)__src + 2);
    if (v14) {
      uint64_t v13 = (audioipc *)memcpy(v11, *__src, v14);
    }
    uint64_t v4 = 561145203;
    uint64_t v15 = *(void *)(a1 + 96);
    *(void *)(v15 + 8) = audioipc::current_render_context(v13);
    uint64_t v16 = *(void *)(a1 + 96);
    if (audioipc::ipc_node_base<(audioipc::ipcnode_options)0,audioipc::eventlink_primitive,unilaterally_billed_shared_memory>::can_send(a1, v17))
    {
      *(_WORD *)uint64_t v16 = 25601;
      if (audioipc::ipc_node_base<(audioipc::ipcnode_options)0,audioipc::eventlink_primitive,unilaterally_billed_shared_memory>::signal_wait_with_timeout(a1))
      {
        int v18 = *(unsigned __int8 *)(v16 + 1);
        if (v18 != 100)
        {
          if (v18 == 101)
          {
            memcpy(__src, v12, 0x150uLL);
            return *(unsigned int *)(v16 + 4);
          }
          else
          {
            return 4294967246;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v4 = 1768846202;
    int v5 = *(_DWORD *)(a1 + 128);
    BOOL v6 = __OFSUB__(v5, 1);
    int v7 = v5 - 1;
    if (v7 < 0 == v6)
    {
      *(_DWORD *)(a1 + 128) = v7;
      AudioConverterLog();
      uint64_t v8 = AudioConverterLog(void)::gLog;
      if (os_log_type_enabled((os_log_t)AudioConverterLog(void)::gLog, OS_LOG_TYPE_ERROR))
      {
        int v9 = *((_DWORD *)__src + 2);
        int v10 = **(_DWORD **)(a1 + 72);
        int v20 = 136315906;
        uint64_t v21 = "AudioConverterPropertyClient.h";
        __int16 v22 = 1024;
        int v23 = 50;
        __int16 v24 = 1024;
        int v25 = v9;
        __int16 v26 = 1024;
        int v27 = v10;
        _os_log_impl(&dword_18FEC0000, v8, OS_LOG_TYPE_ERROR, "%25s:%-5d bundle data too large to send over messenger (%d bytes > %d); falling back to XPC",
          (uint8_t *)&v20,
          0x1Eu);
      }
    }
  }
  return v4;
}

swix::data *swix::data::data(swix::data *this, xpc_object_t object)
{
  *(void *)this = object;
  if (object) {
    xpc_retain(object);
  }
  else {
    *(void *)this = xpc_null_create();
  }
  return this;
}

uint64_t AudioConverterOOP::getPropertyInfo(AudioConverterOOP *this, unsigned int a2, unsigned int *a3, BOOL *a4)
{
  uint64_t v8 = a2;
  if (*((unsigned char *)this + 12) || !*((unsigned char *)this + 13))
  {
    v16[0] = 0;
    char v22 = 0;
  }
  else
  {
    HIDWORD(v23) = 2755;
    xpc_object_t xdict = (xpc_object_t)a2;
    uint64_t v25 = 0;
    uint64_t v26 = 0;
    uint64_t v27 = 0;
    kdebug_trace();
    v16[0] = 1;
    int v17 = 2755;
    uint64_t v18 = v8;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    LOBYTE(v23) = 0;
    char v22 = 1;
    AT::ScopedTrace::~ScopedTrace((AT::ScopedTrace *)&v23);
  }
  unsigned __int8 v9 = atomic_load((unsigned __int8 *)(*((void *)this + 10) + 232));
  if (v9)
  {
    if (a2 == 1970103906)
    {
      uint64_t v10 = 0;
      *a3 = 4;
      *a4 = 1;
    }
    else if (a2 == 1885955104 && PlatformUtilities::IsInternalBuild(this))
    {
      uint64_t v10 = 0;
      *a3 = 4;
      *a4 = 0;
    }
    else
    {
      uint64_t v11 = **((void **)this + 10);
      MEMORY[0x192FC7DA0](v28, 74777834);
      xpc_dictionary_set_uint64(v29, "propertyID", v8);
      uint64_t v12 = *(swix::connection **)(v11 + 8);
      if (!v12) {
        std::terminate();
      }
      swix::connection::send_and_await_reply(&v23, v12, (const swix::encode_message *)v28);
      uint64_t v10 = swix::coder<int>::decode(xdict, ".error");
      if (v10)
      {
        BOOL v13 = 0;
        uint64_t v14 = 0;
      }
      else
      {
        uint64_t v10 = swix::coder<unsigned int>::decode(xdict, "dataSize");
        BOOL v13 = xpc_dictionary_get_BOOL(xdict, "outWritable");
        uint64_t v14 = 1;
      }
      xpc_release(xdict);
      xpc_release(v29);
      if (v14 || !v10)
      {
        if (a3) {
          *a3 = v10;
        }
        if (a4) {
          *a4 = v13;
        }
        if (v14) {
          uint64_t v10 = 0;
        }
      }
    }
  }
  else
  {
    uint64_t v10 = 560164718;
  }
  if (v22) {
    AT::ScopedTrace::~ScopedTrace((AT::ScopedTrace *)v16);
  }
  return v10;
}

void sub_190185A18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  if (a14) {
    AT::ScopedTrace::~ScopedTrace((AT::ScopedTrace *)&a9);
  }
  _Unwind_Resume(exception_object);
}

void sub_190185A34(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, xpc_object_t object)
{
}

uint64_t AudioConverterOOP::reset(AudioConverterOOP *this, double a2)
{
  uint64_t v3 = 561145203;
  uint64_t v4 = *(void *)(*((void *)this + 10) + 8);
  uint64_t v5 = *(void *)(v4 + 240);
  if (audioipc::ipc_node_base<(audioipc::ipcnode_options)0,audioipc::eventlink_primitive,unilaterally_billed_shared_memory>::can_send(v4, a2))
  {
    *(unsigned char *)uint64_t v5 = 3;
    if (audioipc::ipc_node_base<(audioipc::ipcnode_options)0,audioipc::eventlink_primitive,unilaterally_billed_shared_memory>::signal_wait_with_timeout(v4)) {
      uint64_t v3 = *(unsigned int *)(v5 + 4);
    }
    else {
      uint64_t v3 = 561145203;
    }
  }
  uint64_t v6 = *((void *)this + 10);
  *(_DWORD *)(*(void *)(v6 + 72) + 60) = 0;
  *(void *)(v6 + 80) = 0;
  *(_DWORD *)(v6 + 108) = 0;
  *(void *)(v6 + 120) = 0;
  return v3;
}

void AudioConverterOOP::~AudioConverterOOP(AudioConverterOOP *this)
{
  AudioConverterOOP::~AudioConverterOOP(this);
  JUMPOUT(0x192FC8940);
}

{
  NSObject *v2;
  unsigned __int8 v3;
  uint64_t v4;
  swix::connection *v5;
  unsigned char v6[8];
  xpc_object_t v7;
  uint8_t buf[4];
  unsigned char object[14];
  __int16 v10;
  AudioConverterOOP *v11;
  uint64_t v12;

  uint64_t v12 = *MEMORY[0x1E4F143B8];
  *(void *)this = &unk_1EDF91DD8;
  if (!*((unsigned char *)this + 12) && *((unsigned char *)this + 13))
  {
    if (*((unsigned char *)this + 72))
    {
      AT::ScopedTrace::~ScopedTrace((AudioConverterOOP *)((char *)this + 32));
      *((unsigned char *)this + 72) = 0;
    }
    *((unsigned char *)this + 32) = 1;
    *((_DWORD *)this + 9) = 2757;
    *(_OWORD *)((char *)this + 40) = 0u;
    *(_OWORD *)((char *)this + 56) = 0u;
    kdebug_trace();
    *((unsigned char *)this + 72) = 1;
  }
  AudioConverterLog();
  unsigned __int8 v2 = AudioConverterLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)AudioConverterLog(void)::gLog, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 136315650;
    *(void *)xpc_object_t object = "AudioConverterOOP.cpp";
    *(_WORD *)&object[8] = 1024;
    *(_DWORD *)&object[10] = 464;
    uint64_t v10 = 2048;
    uint64_t v11 = this;
    _os_log_impl(&dword_18FEC0000, v2, OS_LOG_TYPE_DEFAULT, "%25s:%-5d AudioConverterOOP -> %p: Disposing of service.", buf, 0x1Cu);
  }
  uint64_t v3 = atomic_load((unsigned __int8 *)(*((void *)this + 10) + 232));
  if (v3)
  {
    uint64_t v4 = **((void **)this + 10);
    MEMORY[0x192FC7DA0](v6, 74777832);
    uint64_t v5 = *(swix::connection **)(v4 + 8);
    if (!v5) {
      std::terminate();
    }
    swix::connection::send_and_await_reply((uint64_t *)buf, v5, (const swix::encode_message *)v6);
    swix::coder<int>::decode(*(void **)&object[4], ".error");
    xpc_release(*(xpc_object_t *)&object[4]);
    xpc_release(v7);
  }
  std::unique_ptr<AudioConverterOOP::Impl>::reset[abi:ne180100]((uint64_t **)this + 10);
  if (*((unsigned char *)this + 72)) {
    AT::ScopedTrace::~ScopedTrace((AudioConverterOOP *)((char *)this + 32));
  }
  AudioConverterAPI::~AudioConverterAPI(this);
}

void sub_190185D28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

uint64_t **std::unique_ptr<AudioConverterOOP::Impl>::reset[abi:ne180100](uint64_t **result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    std::unique_ptr<auoop::WorkgroupPropagator>::reset[abi:ne180100]((os_unfair_lock_s ***)v1 + 28, 0);
    unsigned __int8 v2 = (std::__shared_weak_count *)v1[24];
    if (v2) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v2);
    }
    ExtendedAudioBufferList_Destroy((std::pmr *)v1[21]);
    uint64_t v3 = (std::__shared_weak_count *)v1[12];
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    }
    ExtendedAudioBufferList_Destroy((std::pmr *)v1[9]);
    std::unique_ptr<AudioConverterPropertyClient>::reset[abi:ne180100](v1 + 3, 0);
    std::unique_ptr<AudioConverterRenderClient>::reset[abi:ne180100](v1 + 1, 0);
    uint64_t v4 = (os_unfair_lock_s **)*v1;
    uint64_t *v1 = 0;
    if (v4) {
      (*(void (**)(os_unfair_lock_s **))&(*v4)[2]._os_unfair_lock_opaque)(v4);
    }
    JUMPOUT(0x192FC8940);
  }
  return result;
}

os_unfair_lock_s **std::unique_ptr<auoop::WorkgroupPropagator>::reset[abi:ne180100](os_unfair_lock_s ***a1, os_unfair_lock_s **a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    auoop::WorkgroupPropagator::~WorkgroupPropagator(result);
    JUMPOUT(0x192FC8940);
  }
  return result;
}

uint64_t *std::unique_ptr<AudioConverterRenderClient>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  *uint64_t result = a2;
  if (v2)
  {
    std::unique_ptr<AudioConverterCapturer>::reset[abi:ne180100]((const std::__fs::filesystem::path **)(v2 + 376), 0);
    std::unique_ptr<AudioConverterCapturer>::reset[abi:ne180100]((const std::__fs::filesystem::path **)(v2 + 368), 0);
    if (*(unsigned char *)(v2 + 320))
    {
      uint64_t v3 = *(void *)(v2 + 248);
      *(void *)(v2 + 248) = 0;
      if (v3) {
        std::default_delete<AudioConverterSharedAudioBuffers>::operator()[abi:ne180100](v3);
      }
    }
    audioipc::rt_sender<(audioipc::ipcnode_options)0,audioipc::eventlink_primitive,unilaterally_billed_shared_memory>::~rt_sender(v2);
    JUMPOUT(0x192FC8940);
  }
  return result;
}

void AudioConverterOOP::AudioConverterOOP(BaseOpaqueObject *a1)
{
  BaseOpaqueObject::BaseOpaqueObject(a1);
  *(_WORD *)(v1 + 12) = 0;
  *(unsigned char *)(v1 + 28) = 0;
  *(void *)(v1 + 16) = 0;
  *(unsigned char *)(v1 + 24) = 0;
  *(void *)uint64_t v1 = &unk_1EDF91DD8;
  *(unsigned char *)(v1 + 32) = 0;
  *(unsigned char *)(v1 + 72) = 0;
  operator new();
}

void sub_19018701C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, AT::ScopedTrace *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, xpc_object_t object, uint64_t a17)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

void AudioConverterOOP::Impl::setUpClientRenderer(uint64_t a1, uint64_t a2, long long *a3, uint64_t a4, uint64_t a5)
{
  char v5 = 0;
  uint64_t v6 = 0;
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  long long v7 = *(_OWORD *)(a2 + 16);
  v19[0] = *(_OWORD *)a2;
  v19[1] = v7;
  long long v8 = a3[1];
  long long v21 = *a3;
  uint64_t v24 = a5;
  uint64_t v25 = a4;
  uint64_t v20 = *(void *)(a2 + 32);
  long long v22 = v8;
  uint64_t v23 = *((void *)a3 + 4);
  *(void *)int buf = 0x100000000;
  while (1)
  {
    char v9 = v5;
    uint64_t v10 = *(unsigned int *)&buf[4 * v6];
    uint64_t v11 = (char *)v19 + 56 * v10;
    LODWORD(outPropertyData[0]) = 0;
    ioPropertyDataSize[0] = 4;
    int v12 = *((_DWORD *)v11 + 2);
    if (v12 == 1818440480 || v12 == 1935827744)
    {
      BOOL v14 = 1;
    }
    else if (AudioFormatGetProperty(0x66766272u, 0x28u, (char *)v19 + 56 * v10, ioPropertyDataSize, outPropertyData))
    {
      BOOL v14 = *((_DWORD *)v11 + 4) == 0;
    }
    else
    {
      BOOL v14 = outPropertyData[0];
    }
    uint64_t v15 = (_DWORD *)v19 + 14 * v10;
    uint64_t v16 = (int *)&v24 + v10;
    if (!*v16) {
      uint64_t v16 = (int *)(v11 + 16);
    }
    int v17 = *v16;
    UInt32 v18 = ioPropertyDataSize[v10 - 2];
    v15[10] = v14;
    v15[11] = v18;
    v15[12] = v17;
    char v5 = 1;
    uint64_t v6 = 1;
    if (v9) {
      operator new();
    }
  }
}

void sub_19018784C(_Unwind_Exception *a1, int a2)
{
  __cxa_guard_abort(&_ZGVZ16isEnvVariableSetIXtlN9envHelper13StringLiteralILm33EEEtlA33_cLc67ELc111ELc114ELc101ELc65ELc117ELc100ELc105ELc111ELc95ELc67ELc97ELc112ELc116ELc117ELc114ELc101ELc65ELc67ELc83ELc101ELc114ELc118ELc105ELc99ELc101ELc95ELc73ELc110ELc112ELc117ELc116EEEEEbvE5input);
  std::unique_ptr<AudioConverterCapturer>::reset[abi:ne180100](v4, 0);
  std::unique_ptr<AudioConverterCapturer>::reset[abi:ne180100](v3, 0);
  if (*(unsigned char *)(v2 + 320))
  {
    uint64_t v8 = *(void *)(v2 + 248);
    *(void *)(v2 + 248) = 0;
    if (v8) {
      std::default_delete<AudioConverterSharedAudioBuffers>::operator()[abi:ne180100](v8);
    }
  }
  audioipc::rt_sender<(audioipc::ipcnode_options)0,audioipc::eventlink_primitive,unilaterally_billed_shared_memory>::~rt_sender(v2);
  MEMORY[0x192FC8940](v2, 0x10F2C40CE9AAB0ALL);
  if (a2 == 2)
  {
    char v9 = __cxa_begin_catch(a1);
    AudioConverterLog();
    uint64_t v10 = AudioConverterLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)AudioConverterLog(void)::gLog, OS_LOG_TYPE_ERROR))
    {
      uint64_t v11 = (*(uint64_t (**)(void *))(*(void *)v9 + 16))(v9);
      *(_DWORD *)(v5 - 160) = 136315650;
      uint64_t v12 = v5 - 160;
      *(void *)(v12 + 4) = "AudioConverterOOP.cpp";
      *(_WORD *)(v5 - 148) = 1024;
      *(_DWORD *)(v12 + 14) = 306;
      *(_WORD *)(v5 - 142) = 2080;
      *(void *)(v12 + 20) = v11;
      _os_log_impl(&dword_18FEC0000, v10, OS_LOG_TYPE_ERROR, "%25s:%-5d AudioConverterOOP: Error creating real time renderer: %s.", (uint8_t *)(v5 - 160), 0x1Cu);
    }
  }
  else
  {
    if (a2 != 1) {
      _Unwind_Resume(a1);
    }
    __cxa_begin_catch(a1);
    AudioConverterLog();
    BOOL v13 = AudioConverterLog(void)::gLog;
    if (os_log_type_enabled((os_log_t)AudioConverterLog(void)::gLog, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)(v5 - 160) = 136315394;
      uint64_t v14 = v5 - 160;
      *(void *)(v14 + 4) = "AudioConverterOOP.cpp";
      *(_WORD *)(v5 - 148) = 1024;
      *(_DWORD *)(v14 + 14) = 310;
      _os_log_impl(&dword_18FEC0000, v13, OS_LOG_TYPE_ERROR, "%25s:%-5d AudioConverterOOP: Error creating real time renderer.", (uint8_t *)(v5 - 160), 0x12u);
    }
  }
  __cxa_end_catch();
  JUMPOUT(0x190187718);
}

void AudioConverterClientBufferManager::AudioConverterClientBufferManager(AudioConverterClientBufferManager *this, const CA::StreamDescription *a2)
{
  long long v4 = *(_OWORD *)a2;
  long long v5 = *((_OWORD *)a2 + 1);
  *((void *)this + 4) = *((void *)a2 + 4);
  *(_OWORD *)this = v4;
  *((_OWORD *)this + 1) = v5;
  uint64_t v6 = (void *)((char *)this + 40);
  if ((*((_DWORD *)a2 + 3) & 0x20) != 0) {
    uint64_t v7 = *((unsigned int *)a2 + 7);
  }
  else {
    uint64_t v7 = 1;
  }
  CA::AudioBuffers::AudioBuffers(v6, v8, 1);
  char v9 = operator new(0x30uLL);
  v9[1] = 0;
  void v9[2] = 0;
  *char v9 = &unk_1EDFA2AF0;
  v9[4] = 0;
  v9[5] = 0;
  void v9[3] = 0;
  *((void *)this + 7) = v9 + 3;
  *((void *)this + 8) = v9;
  *((_DWORD *)this + 19) = 0;
  int v10 = *((_DWORD *)a2 + 4);
  if (!v10) {
    int v10 = *((_DWORD *)a2 + 6);
  }
  *((_DWORD *)this + 20) = v10;
  *((void *)this + 11) = 0;
}

void sub_190187B1C(_Unwind_Exception *a1)
{
  CA::AudioBuffers::~AudioBuffers(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<AudioConverterOOP::Impl::Impl(applesauce::xpc::connection,AudioStreamBasicDescription const*,AudioStreamBasicDescription const*)::{lambda(swix::ipc_endpoint const&,applesauce::xpc::object const&)#1},std::allocator<AudioConverterOOP::Impl::Impl(applesauce::xpc::connection,AudioStreamBasicDescription const*,AudioStreamBasicDescription const*)::{lambda(swix::ipc_endpoint const&,applesauce::xpc::object const&)#1}>,void ()(swix::ipc_endpoint&,applesauce::xpc::object const&)>::operator()(uint64_t a1, uint64_t a2, swix **a3)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 8);
  AudioConverterLog();
  long long v5 = AudioConverterLog(void)::gLog;
  if (os_log_type_enabled((os_log_t)AudioConverterLog(void)::gLog, OS_LOG_TYPE_ERROR))
  {
    swix::xpc_object_description((uint64_t *)__p, *a3, v6);
    if (v9 >= 0) {
      uint64_t v7 = __p;
    }
    else {
      uint64_t v7 = (void **)__p[0];
    }
    *(_DWORD *)int buf = 136315906;
    uint64_t v11 = "AudioConverterOOP.cpp";
    __int16 v12 = 1024;
    int v13 = 280;
    __int16 v14 = 2048;
    uint64_t v15 = v4;
    __int16 v16 = 2080;
    int v17 = v7;
    _os_log_impl(&dword_18FEC0000, v5, OS_LOG_TYPE_ERROR, "%25s:%-5d AudioConverterOOP -> %p: Converter connection was invalidated with error \"%s\".", buf, 0x26u);
    if (v9 < 0) {
      operator delete(__p[0]);
    }
  }
  atomic_store(0, (unsigned __int8 *)(v4 + 232));
}

uint64_t std::__function::__func<AudioConverterOOP::Impl::Impl(applesauce::xpc::connection,AudioStreamBasicDescription const*,AudioStreamBasicDescription const*)::{lambda(swix::ipc_endpoint const&,applesauce::xpc::object const&)#1},std::allocator<AudioConverterOOP::Impl::Impl(applesauce::xpc::connection,AudioStreamBasicDescription const*,AudioStreamBasicDescription const*)::{lambda(swix::ipc_endpoint const&,applesauce::xpc::object const&)#1}>,void ()(swix::ipc_endpoint&,applesauce::xpc::object const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EDFA0498;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<AudioConverterOOP::Impl::Impl(applesauce::xpc::connection,AudioStreamBasicDescription const*,AudioStreamBasicDescription const*)::{lambda(swix::ipc_endpoint const&,applesauce::xpc::object const&)#1},std::allocator<AudioConverterOOP::Impl::Impl(applesauce::xpc::connection,AudioStreamBasicDescription const*,AudioStreamBasicDescription const*)::{lambda(swix::ipc_endpoint const&,applesauce::xpc::object const&)#1}>,void ()(swix::ipc_endpoint&,applesauce::xpc::object const&)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EDFA0498;
  result[1] = v3;
  return result;
}

void std::__function::__func<AudioConverterOOP::Impl::Impl(applesauce::xpc::connection,AudioStreamBasicDescription const*,AudioStreamBasicDescription const*)::{lambda(swix::ipc_endpoint const&,applesauce::xpc::object const&)#1},std::allocator<AudioConverterOOP::Impl::Impl(applesauce::xpc::connection,AudioStreamBasicDescription const*,AudioStreamBasicDescription const*)::{lambda(swix::ipc_endpoint const&,applesauce::xpc::object const&)#1}>,void ()(swix::ipc_endpoint&,applesauce::xpc::object const&)>::~__func()
{
}

void std::__function::__func<AudioConverterOOP::Impl::Impl(applesauce::xpc::connection,AudioStreamBasicDescription const*,AudioStreamBasicDescription const*)::{lambda(applesauce::xpc::dict const&)#1},std::allocator<AudioConverterOOP::Impl::Impl(applesauce::xpc::connection,AudioStreamBasicDescription const*,AudioStreamBasicDescription const*)::{lambda(applesauce::xpc::dict const&)#1}>,void ()(applesauce::xpc::dict const&)>::operator()(uint64_t a1, xpc_object_t *a2)
{
  uint64_t v2 = **(void **)(a1 + 8);
  xpc_object_t v3 = *a2;
  if (*a2) {
    xpc_retain(*a2);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  MEMORY[0x192FC7DA0](v7, 74777833);
  xpc_dictionary_set_value(xdict, "workgroups", v3);
  uint64_t v4 = *(swix::connection **)(v2 + 8);
  if (!v4) {
    std::terminate();
  }
  swix::connection::send_and_await_reply(&v5, v4, (const swix::encode_message *)v7);
  swix::coder<int>::decode(object, ".error");
  xpc_release(object);
  xpc_release(xdict);
  xpc_release(v3);
}

void sub_190187D90(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object)
{
}

uint64_t std::__function::__func<AudioConverterOOP::Impl::Impl(applesauce::xpc::connection,AudioStreamBasicDescription const*,AudioStreamBasicDescription const*)::{lambda(applesauce::xpc::dict const&)#1},std::allocator<AudioConverterOOP::Impl::Impl(applesauce::xpc::connection,AudioStreamBasicDescription const*,AudioStreamBasicDescription const*)::{lambda(applesauce::xpc::dict const&)#1}>,void ()(applesauce::xpc::dict const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EDFA04E0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<AudioConverterOOP::Impl::Impl(applesauce::xpc::connection,AudioStreamBasicDescription const*,AudioStreamBasicDescription const*)::{lambda(applesauce::xpc::dict const&)#1},std::allocator<AudioConverterOOP::Impl::Impl(applesauce::xpc::connection,AudioStreamBasicDescription const*,AudioStreamBasicDescription const*)::{lambda(applesauce::xpc::dict const&)#1}>,void ()(applesauce::xpc::dict const&)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EDFA04E0;
  result[1] = v3;
  return result;
}

void std::__function::__func<AudioConverterOOP::Impl::Impl(applesauce::xpc::connection,AudioStreamBasicDescription const*,AudioStreamBasicDescription const*)::{lambda(applesauce::xpc::dict const&)#1},std::allocator<AudioConverterOOP::Impl::Impl(applesauce::xpc::connection,AudioStreamBasicDescription const*,AudioStreamBasicDescription const*)::{lambda(applesauce::xpc::dict const&)#1}>,void ()(applesauce::xpc::dict const&)>::~__func()
{
}

void std::__shared_ptr_emplace<std::vector<AudioStreamPacketDescription>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }
}

void std::__shared_ptr_emplace<std::vector<AudioStreamPacketDescription>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EDFA2AF0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x192FC8940);
}

void std::__shared_ptr_emplace<std::vector<AudioStreamPacketDescription>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EDFA2AF0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t newAudioConverterOOP(const AudioStreamBasicDescription *a1, const AudioStreamBasicDescription *a2, unsigned int a3, const AudioClassDescription *a4)
{
  task_info_outCnt.val[0] = 8;
  if (!task_info(*MEMORY[0x1E4F14960], 0xFu, (task_info_t)&task_info_out, task_info_outCnt.val))
  {
    audit_token_t task_info_outCnt = task_info_out;
    uint64_t v8 = SecTaskCreateWithAuditToken(0, &task_info_outCnt);
    if (!v8) {
      goto LABEL_9;
    }
    char v9 = v8;
    CFBooleanRef v10 = (const __CFBoolean *)SecTaskCopyValueForEntitlement(v8, @"com.apple.coreaudio.LoadConvertersInProcessXPC", 0);
    if (v10)
    {
      CFBooleanRef v11 = v10;
      CFTypeID v12 = CFGetTypeID(v10);
      if (v12 == CFBooleanGetTypeID())
      {
        int Value = CFBooleanGetValue(v11);
        CFRelease(v11);
        CFRelease(v9);
        if (Value) {
          newAudioConverterInProcessXPC(a1, a2, a3, a4);
        }
LABEL_9:
        operator new();
      }
      CFRelease(v11);
    }
    CFRelease(v9);
    goto LABEL_9;
  }
  _os_assert_log();
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

void sub_190188050(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(object);
  MEMORY[0x192FC8940](v10, 0x10A1C4037BC56B3);
  _Unwind_Resume(a1);
}

void newAudioConverterInProcessXPC(const AudioStreamBasicDescription *a1, const AudioStreamBasicDescription *a2, unsigned int a3, const AudioClassDescription *a4)
{
}

void sub_19018828C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, xpc_object_t a10)
{
  xpc_release(object);
  MEMORY[0x192FC8940](v10, 0x10A1C4037BC56B3);
  _Unwind_Resume(a1);
}

uint64_t AudioFormatProperty_FormatList(const AudioFormatInfo *a1, unsigned int a2, unsigned int *a3, AudioFormatListItem *a4)
{
  if (*a3 < 0x30) {
    return 561211770;
  }
  uint64_t v6 = a4;
  if (a1->mASBD.mFormatID == 1836069985)
  {
    unsigned int v17 = 0;
    int v8 = FormatFromESDS((unsigned __int8 *)a1->mMagicCookie, a1->mMagicCookieSize, &v17);
    if (v17)
    {
      int v9 = v8;
      memset(&v16, 0, 40);
      mMagicCookie = a1->mMagicCookie;
      v16.mMagicCookie = mMagicCookie;
      UInt32 mMagicCookieSize = a1->mMagicCookieSize;
      v16.UInt32 mMagicCookieSize = mMagicCookieSize;
      if (v9)
      {
        unsigned int v13 = 40;
        memset(v14, 0, sizeof(v14));
        uint64_t v15 = 0;
        uint64_t result = AudioFormatProperty_AudioFormatInfoFromESDS(mMagicCookie, mMagicCookieSize, &v13, v14);
        if (result) {
          return result;
        }
        v16.mASBD.AudioFormatID mFormatID = DWORD2(v14[0]);
      }
      else
      {
        v16.mASBD.AudioFormatID mFormatID = v17;
      }
      return AudioFormatProperty_FormatList(&v16, 0x38u, a3, v6);
    }
    else
    {
      return 560360820;
    }
  }
  else
  {
    uint64_t result = FetchFormatListFromCodecs((uint64_t (*)(void))GetFormatListFromCodec, a1, a2, a3, a4);
    if (!result)
    {
      if (v6)
      {
        if (*a3 >= 0x30)
        {
          unint64_t v12 = *a3 / 0x30uLL;
          uint64_t result = 0;
          do
          {
            if (v6->mASBD.mSampleRate == 0.0) {
              v6->mASBD.mSampleRate = a1->mASBD.mSampleRate;
            }
            if (!v6->mASBD.mChannelsPerFrame) {
              v6->mASBD.UInt32 mChannelsPerFrame = a1->mASBD.mChannelsPerFrame;
            }
            ++v6;
            --v12;
          }
          while (v12);
        }
        else
        {
          return 0;
        }
      }
      else
      {
        return 2003329396;
      }
    }
  }
  return result;
}

uint64_t GetFormatListFromCodec(AudioCodec inCodec, const AudioFormatInfo *a2, unsigned int *a3, AudioFormatListItem *a4)
{
  UInt32 outSize = 0;
  uint64_t result = 561211770;
  if (a3)
  {
    uint64_t result = AudioCodecGetPropertyInfo(inCodec, 0x6163666Cu, &outSize, 0);
    if (!result)
    {
      if (a4)
      {
        bzero(a4, *a3);
        uint64_t result = 561211770;
        if (outSize <= *a3)
        {
          mMagicCookie = a2->mMagicCookie;
          LODWORD(a4->mASBD.mSampleRate) = a2->mMagicCookieSize;
          *(void *)&a4->mASBD.AudioFormatID mFormatID = mMagicCookie;
          return AudioCodecGetProperty(inCodec, 0x6163666Cu, a3, a4);
        }
      }
      else
      {
        uint64_t result = 0;
        *a3 = outSize;
      }
    }
  }
  return result;
}

uint64_t AudioFormatProperty_FormatIsVBR(RegistryAccess *a1, unsigned int *a2)
{
  RegistryAccess::instance(a1);
  uint64_t v4 = qword_1EB3D4FB0;
  os_unfair_recursive_lock_lock_with_options();
  uint64_t v5 = (*(uint64_t (**)(uint64_t, RegistryAccess *, uint64_t, void, void))(*(void *)v4 + 16))(v4, a1, 1819304813, 0, 0);
  if (v5
    || (uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, RegistryAccess *, void, void))(*(void *)v4 + 16))(v4, 1819304813, a1, 0, 0)) != 0)
  {
    uint64_t v6 = (*(uint64_t (**)(uint64_t, unsigned int *))(*(void *)v5 + 24))(v5, a2);
  }
  else
  {
    uint64_t v6 = 1718449215;
  }
  os_unfair_recursive_lock_unlock();
  return v6;
}

void sub_190188694(_Unwind_Exception *a1)
{
}

uint64_t AudioFormatProperty_FormatIsEncrypted(uint64_t result, unsigned int *a2)
{
  unsigned int v2 = 1;
  if ((int)result > 1902211170)
  {
    if ((int)result <= 2053202274)
    {
      if ((int)result > 1902537826)
      {
        if (result == 1902537827 || result == 1902928227) {
          goto LABEL_34;
        }
        int v3 = 1903522657;
      }
      else
      {
        if (result == 1902211171 || result == 1902324531) {
          goto LABEL_34;
        }
        int v3 = 1902469939;
      }
    }
    else if ((int)result > 2053319474)
    {
      if (result == 2053319475 || result == 2053464883) {
        goto LABEL_34;
      }
      int v3 = 2053923171;
    }
    else
    {
      if ((result - 2053202739) <= 0x3D
        && ((1 << (result - 51)) & 0x2020000000000001) != 0)
      {
        goto LABEL_34;
      }
      int v3 = 2053202275;
    }
  }
  else if ((int)result <= 1885547314)
  {
    if ((int)result <= 1885430578)
    {
      if (result == 1633771875) {
        goto LABEL_34;
      }
      unsigned __int16 v4 = 24931;
    }
    else
    {
      if ((result - 1885430579) <= 0x3D
        && ((1 << (result - 51)) & 0x2020000000000001) != 0)
      {
        goto LABEL_34;
      }
      unsigned __int16 v4 = 28771;
    }
    int v3 = v4 | 0x70610000;
  }
  else if ((int)result <= 1902207330)
  {
    if (result == 1885547315 || result == 1885692723) {
      goto LABEL_34;
    }
    int v3 = 1886745441;
  }
  else
  {
    if ((result - 1902207795) <= 0x3D
      && ((1 << (result - 51)) & 0x2020000000000001) != 0)
    {
      goto LABEL_34;
    }
    int v3 = 1902207331;
  }
  if (result != v3) {
    unsigned int v2 = 0;
  }
LABEL_34:
  *a2 = v2;
  return result;
}

uint64_t GetCodecPropertyFromFormatInfo(const AudioFormatInfo *a1, unsigned int *a2, void *a3, AudioCodecPropertyID a4)
{
  AudioCodec inCodec = 0;
  uint64_t PropertyInfo = OpenCodecComponent(a1->mASBD.mFormatID, &inCodec, 0x61646563u);
  if (!PropertyInfo)
  {
    AudioCodec v11 = inCodec;
    uint64_t PropertyInfo = AudioCodecInitialize(inCodec, 0, 0, a1->mMagicCookie, a1->mMagicCookieSize);
    if (!PropertyInfo)
    {
      UInt32 outSize = 0;
      uint64_t PropertyInfo = AudioCodecGetPropertyInfo(v11, a4, &outSize, 0);
      if (!PropertyInfo)
      {
        if (a3)
        {
          if (*a2 >= outSize) {
            uint64_t PropertyInfo = AudioCodecGetProperty(v11, a4, a2, a3);
          }
          else {
            uint64_t PropertyInfo = 561211770;
          }
        }
        else
        {
          uint64_t PropertyInfo = 0;
          *a2 = outSize;
        }
      }
    }
    AudioCodecAutoDisposer::~AudioCodecAutoDisposer(&v11);
  }
  return PropertyInfo;
}

void sub_1901889A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  AudioCodecAutoDisposer::~AudioCodecAutoDisposer((OpaqueAudioComponentInstance **)va);
  _Unwind_Resume(a1);
}

uint64_t AudioFormatProperty_VorbisModeInfoFromFormatInfo(const AudioFormatInfo *a1, _DWORD *a2, uint64_t a3)
{
  if (a1->mASBD.mFormatID != 1987015266) {
    return 1718449215;
  }
  if (!a3)
  {
    uint64_t result = 0;
LABEL_9:
    *a2 = 24;
    return result;
  }
  if (*a2 < 0x18u) {
    return 561213539;
  }
  uint64_t v9 = 0;
  mMagicCookie = a1->mMagicCookie;
  long long v8 = 0uLL;
  LODWORD(v8) = a1->mMagicCookieSize;
  unsigned int v6 = 32;
  uint64_t result = GetCodecPropertyFromFormatInfo(a1, &v6, &mMagicCookie, 0x766E666Fu);
  if (!result)
  {
    *(void *)a3 = *(void *)((char *)&v8 + 4);
    *(_DWORD *)(a3 + 8) = HIDWORD(v8);
    *(void *)(a3 + 16) = v9;
    goto LABEL_9;
  }
  return result;
}

uint64_t AudioFormatProperty_CodecsParameterValueFromAudioFormat(uint64_t a1, CFStringRef *a2)
{
  uint64_t PropertyInfo = 1718449215;
  if (*(_DWORD *)(a1 + 56) == 1836069990
    && AudioFormatEncryptedFormatTranslator::DecryptFormatID(*(unsigned int *)(a1 + 8), &v15) == 1634754915)
  {
    __int16 v14 = 0;
    uint64_t PropertyInfo = OpenCodecComponent(0x61706163u, &v14, 0x61646563u);
    if (!PropertyInfo)
    {
      unsigned int v13 = v14;
      AudioCodecInitialize(v14, 0, 0, *(const void **)(a1 + 40), *(_DWORD *)(a1 + 48));
      UInt32 outSize = 0;
      uint64_t PropertyInfo = AudioCodecGetPropertyInfo(v13, 0x63706D63u, &outSize, 0);
      if (!PropertyInfo)
      {
        if (outSize <= 0x10) {
          size_t v5 = 16;
        }
        else {
          size_t v5 = outSize;
        }
        UInt32 outSize = v5;
        std::vector<unsigned char>::vector(outPropertyData, v5);
        unsigned int v6 = outPropertyData[0];
        *((void *)outPropertyData[0] + 1) = *(void *)(a1 + 40);
        *unsigned int v6 = *(_DWORD *)(a1 + 48);
        uint64_t PropertyInfo = AudioCodecGetProperty(v13, 0x63706D63u, &outSize, v6);
        if (!PropertyInfo)
        {
          CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          char v10 = 4;
          strcpy((char *)__p, "apac");
          *a2 = CFStringCreateWithFormat(v7, 0, @"%s.%02u.%02u", __p, *(unsigned int *)outPropertyData[0], *((unsigned int *)outPropertyData[0] + 1));
          if (v10 < 0) {
            operator delete(__p[0]);
          }
        }
        if (outPropertyData[0])
        {
          outPropertyData[1] = outPropertyData[0];
          operator delete(outPropertyData[0]);
        }
      }
      AudioCodecAutoDisposer::~AudioCodecAutoDisposer(&v13);
    }
  }
  return PropertyInfo;
}

void sub_190188C14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a19) {
    operator delete(a19);
  }
  AudioCodecAutoDisposer::~AudioCodecAutoDisposer((OpaqueAudioComponentInstance **)(v20 - 56));
  _Unwind_Resume(a1);
}

uint64_t AudioFormatProperty_CanDecodeAudioFormatIndicatedByCodecsParameterValue(uint64_t a1, _DWORD *a2, void *a3)
{
  uint64_t CodecPropertyFromFormatInfo = 1886547824;
  if (*(_DWORD *)(a1 + 8) == 1836069990)
  {
    CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(CFStringRef *)a1, @".");
    if (CFArrayGetCount(ArrayBySeparatingStrings) == 3)
    {
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, 0);
      if (CFEqual(ValueAtIndex, @"apac"))
      {
        CFStringRef v8 = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, 1);
        __src[0] = CFStringGetIntValue(v8);
        CFStringRef v9 = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, 2);
        __src[1] = CFStringGetIntValue(v9);
        memset(&__n_4, 0, sizeof(__n_4));
        __n_4.mASBD.AudioFormatID mFormatID = 1634754915;
        unsigned int __n = 8;
        uint64_t CodecPropertyFromFormatInfo = GetCodecPropertyFromFormatInfo(&__n_4, &__n, __src, 0x63706F6Bu);
        if (!CodecPropertyFromFormatInfo)
        {
          size_t v10 = __n;
          *a2 = __n;
          memcpy(a3, __src, v10);
        }
      }
    }
    CFRelease(ArrayBySeparatingStrings);
  }
  return CodecPropertyFromFormatInfo;
}

uint64_t AudioFormatProperty_AudioFormatFromCodecsParameterValue(uint64_t a1, void *a2)
{
  if (*(_DWORD *)(a1 + 8) != 1836069990) {
    return 1886547824;
  }
  uint64_t v3 = 1718449215;
  CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(CFStringRef *)a1, @".");
  if (CFArrayGetCount(ArrayBySeparatingStrings))
  {
    CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, 0);
    if (CFEqual(ValueAtIndex, @"apac"))
    {
      uint64_t v3 = 0;
      *a2 = 1634754915;
    }
  }
  CFRelease(ArrayBySeparatingStrings);
  return v3;
}

uint64_t TBitstreamReader<unsigned int>::FillCacheFrom(uint64_t result, unsigned int *a2)
{
  uint64_t v2 = (*(void *)(result + 8) - (void)a2) & ~((uint64_t)(*(void *)(result + 8) - (void)a2) >> 63);
  if (v2 <= 3)
  {
    int v4 = *(_DWORD *)(result + 16);
    if (v2)
    {
      uint64_t v5 = (*(_DWORD *)(result + 8) - a2) & ~((uint64_t)(*(void *)(result + 8) - (void)a2) >> 63);
      do
      {
        *(_DWORD *)(result + 16) = v4 << 8;
        unsigned __int8 v6 = *(unsigned char *)a2;
        a2 = (unsigned int *)((char *)a2 + 1);
        int v3 = v6 | (v4 << 8);
        *(_DWORD *)(result + 16) = v3;
        int v4 = v3;
        --v5;
      }
      while (v5);
    }
    else
    {
      int v3 = *(_DWORD *)(result + 16);
    }
    int v7 = v2 - 4;
    do
      int v3 = (v3 << 8) | 0xFF;
    while (!__CFADD__(v7++, 1));
  }
  else
  {
    int v3 = bswap32(*a2);
  }
  *(_DWORD *)(result + 16) = v3;
  return result;
}

uint64_t TBitstreamReader<unsigned int>::GetBit(uint64_t a1)
{
  unsigned int v2 = *(_DWORD *)(a1 + 16);
  unsigned int v3 = v2 >> 31;
  int v4 = *(_DWORD *)(a1 + 20) - 1;
  *(_DWORD *)(a1 + 20) = v4;
  if (v4 < 0)
  {
    TBitstreamReader<unsigned int>::FillCacheFrom(a1, *(unsigned int **)a1);
    *(void *)a1 += 4;
    unsigned int v6 = *(_DWORD *)(a1 + 16);
    int v7 = *(_DWORD *)(a1 + 20);
    v3 |= v6 >> v7;
    *(_DWORD *)(a1 + 20) = v7 + 32;
    if (v7 == -32) {
      int v5 = 0;
    }
    else {
      int v5 = v6 << -(char)v7;
    }
  }
  else
  {
    int v5 = 2 * v2;
  }
  *(_DWORD *)(a1 + 16) = v5;
  return v3;
}

uint64_t TBitstreamReader<unsigned int>::PutBack(uint64_t result, int a2)
{
  if (a2)
  {
    uint64_t v2 = result;
    unsigned int v3 = *(_DWORD *)(result + 20) + a2;
    uint64_t v4 = *(void *)result - ((v3 >> 3) & 0x1FFFFFFC);
    *(void *)uint64_t result = v4;
    int v5 = v3 & 0x1F;
    *(_DWORD *)(result + 20) = v5;
    if (v5)
    {
      uint64_t result = TBitstreamReader<unsigned int>::FillCacheFrom(result, (unsigned int *)(v4 - 4));
      *(_DWORD *)(v2 + 16) <<= -*(unsigned char *)(v2 + 20);
    }
    else
    {
      *(_DWORD *)(result + 16) = 0;
    }
  }
  return result;
}

uint64_t TBitstreamReader<unsigned int>::SkipBits(uint64_t result, int a2)
{
  uint64_t v2 = result;
  int v3 = *(_DWORD *)(result + 20);
  unsigned int v4 = a2 - v3;
  if (a2 > v3)
  {
    *(void *)(result + 16) = 0;
    int v3 = 0;
    if (v4 >= 0x20)
    {
      *(void *)result += (v4 >> 3) & 0x1FFFFFFC;
      a2 = v4 & 0x1F;
    }
    else
    {
      a2 = v4;
    }
  }
  if ((a2 - 33) >= 0xFFFFFFE0)
  {
    int v5 = *(_DWORD *)(result + 16);
    int v6 = v3 - a2;
    *(_DWORD *)(result + 20) = v6;
    if (v6 < 0)
    {
      uint64_t result = TBitstreamReader<unsigned int>::FillCacheFrom(result, *(unsigned int **)result);
      int v8 = *(_DWORD *)(v2 + 20);
      *(void *)v2 += 4;
      *(_DWORD *)(v2 + 20) = v8 + 32;
      if (v8 == -32) {
        int v7 = 0;
      }
      else {
        int v7 = *(_DWORD *)(v2 + 16) << -(char)v8;
      }
    }
    else
    {
      int v7 = v5 << a2;
    }
    *(_DWORD *)(v2 + 16) = v7;
  }
  return result;
}

uint64_t AudioFormatProperty_DecodeFormatIDsForCodingName(int *a1, unsigned int *a2, unsigned int *a3)
{
  if (a3 && *a2 < 4) {
    return 561211770;
  }
  uint64_t v5 = 1718449215;
  int v6 = *a1;
  if (*a1 > 1380333107)
  {
    if (v6 <= 1832149349)
    {
      if (v6 != 1380333108 && v6 != 1463899717)
      {
        uint64_t v5 = 1718449215;
        if (v6 != 1667327590) {
          return v5;
        }
        uint64_t v5 = 561213539;
        if (a1[1] != 4) {
          return v5;
        }
        goto LABEL_12;
      }
LABEL_28:
      uint64_t v5 = 561213539;
      if (a1[1] == 2)
      {
        unsigned int AudioFormatIDFromFormatTag = AudioFormat_GetAudioFormatIDFromFormatTag(*((__int16 *)a1 + 4), &v19);
        if (AudioFormatIDFromFormatTag == 1061109567)
        {
          return 1718449215;
        }
        else
        {
          if (a3) {
            *a3 = AudioFormatIDFromFormatTag;
          }
          uint64_t v5 = 0;
          *a2 = 4;
        }
      }
      return v5;
    }
    BOOL v11 = v6 == 1832149350 || v6 == 1832149606;
    int v12 = 1836069990;
    goto LABEL_32;
  }
  if (v6 <= 1095321154)
  {
    BOOL v11 = v6 == 862416946;
    int v12 = 862417008;
LABEL_32:
    BOOL v14 = v11 || v6 == v12;
    uint64_t v5 = 1718449215;
    if (!v14) {
      return v5;
    }
    goto LABEL_37;
  }
  if (v6 == 1095321155)
  {
    uint64_t v5 = 561213539;
    if (a1[1] != 4) {
      return v5;
    }
    int v17 = a1[2];
    if (v17 > 1768829491)
    {
      if (v17 <= 1918990111)
      {
        if (v17 != 1768829492 && v17 != 1768829746)
        {
          uint64_t v5 = 1718449215;
          if (v17 == 1819304813) {
            return v5;
          }
LABEL_12:
          *a2 = 4;
          if (a3)
          {
            uint64_t v5 = 0;
            unsigned int v8 = a1[2];
LABEL_64:
            *a3 = v8;
            return v5;
          }
          return 0;
        }
LABEL_62:
        *a2 = 4;
        if (a3)
        {
          uint64_t v5 = 0;
          unsigned int v8 = 1819304813;
          goto LABEL_64;
        }
        return 0;
      }
      if (v17 == 1918990112 || v17 == 1953984371) {
        goto LABEL_62;
      }
      int v18 = 1936684916;
    }
    else if (v17 > 1313820228)
    {
      if (v17 == 1313820229 || v17 == 1718367026) {
        goto LABEL_62;
      }
      int v18 = 1718367796;
    }
    else
    {
      if (v17 == 842231401 || v17 == 1179398962) {
        goto LABEL_62;
      }
      int v18 = 1179399732;
    }
    if (v17 != v18) {
      goto LABEL_12;
    }
    goto LABEL_62;
  }
  if (v6 == 1113011764) {
    goto LABEL_28;
  }
  if (v6 != 1299148630 || a1[1] != 4) {
    return v5;
  }
  char v9 = 0;
  do
  {
    char v10 = v9;
    if (v9) {
      break;
    }
    char v9 = 1;
  }
  while (a1[2] != 1634754915);
  uint64_t v5 = 1718449215;
  if (v10) {
    return v5;
  }
LABEL_37:
  uint64_t v5 = 561213539;
  if (a1[1] != 4) {
    return v5;
  }
  int v15 = a1[2];
  return AudioFormat_GetAudioFormatIDsForISOCodingName(v15, a2, a3);
}

uint64_t AudioFormat_GetAudioFormatIDsForISOCodingName(int a1, unsigned int *a2, unsigned int *a3)
{
  if (a1 == 1700998451)
  {
    if (a3)
    {
      if (*a2 < 4) {
        goto LABEL_11;
      }
      *a3 = 1700998451;
      if (*a2 < 8)
      {
LABEL_20:
        int v5 = 4;
        goto LABEL_23;
      }
      a3[1] = 1700997939;
    }
    int v5 = 8;
    goto LABEL_23;
  }
  if (a1 != 1836069985)
  {
    uint64_t v6 = 0;
    int v7 = sPairedCodingNameAndAudioFormatIDs;
    while (1)
    {
      int v8 = *v7;
      v7 += 2;
      if (v8 == a1) {
        break;
      }
      if (++v6 == 9) {
        return 1718449215;
      }
    }
    if (a3) {
      *a3 = sPairedCodingNameAndAudioFormatIDs[2 * v6 + 1];
    }
    goto LABEL_20;
  }
  if (!a3)
  {
    int v5 = 76;
    goto LABEL_23;
  }
  if (*a2 >= 4)
  {
    uint64_t v3 = 0;
    do
    {
      a3[v3] = sAudioFormatIDs_mp4a[v3];
      unsigned int v4 = v3 + 1;
      if (v3 == 18) {
        break;
      }
      ++v3;
    }
    while (*a2 >> 2 > v4);
    int v5 = 4 * v4;
    goto LABEL_23;
  }
LABEL_11:
  int v5 = 0;
LABEL_23:
  uint64_t result = 0;
  *a2 = v5;
  return result;
}

uint64_t AudioFormatProperty_EncapsulatedMagicCookieNameForCodingName(int *a1, _DWORD *a2, int *a3)
{
  uint64_t result = 1718449215;
  int v5 = *a1;
  if (*a1 <= 1667327589)
  {
    if (v5 != 862416946 && v5 != 862417008)
    {
      if (v5 != 1299148630 || a1[1] != 4) {
        return result;
      }
      char v7 = 0;
      do
      {
        char v8 = v7;
        if (v7) {
          break;
        }
        char v7 = 1;
      }
      while (a1[2] != 1634754915);
      if (v8) {
        return result;
      }
    }
LABEL_22:
    if (a3 && *a2 < 0xCu) {
      return 561211770;
    }
    uint64_t v10 = 0;
    BOOL v11 = sPairedCodingNameAndConfigNames;
    while (1)
    {
      int v12 = *v11;
      v11 += 2;
      if (v12 == a1[2]) {
        break;
      }
      if (++v10 == 11) {
        return result;
      }
    }
    if (!a3) {
      goto LABEL_32;
    }
    int v13 = sPairedCodingNameAndConfigNames[2 * v10 + 1];
    goto LABEL_31;
  }
  if (v5 > 1832149605)
  {
    if (v5 != 1832149606 && v5 != 1836069990) {
      return result;
    }
    goto LABEL_22;
  }
  if (v5 != 1667327590)
  {
    if (v5 != 1832149350) {
      return result;
    }
    goto LABEL_22;
  }
  uint64_t result = 561211770;
  if (a1[1] != 4) {
    return 561213539;
  }
  if (!a3)
  {
LABEL_32:
    uint64_t result = 0;
    *a2 = 12;
    return result;
  }
  if (*a2 >= 0xCu)
  {
    int v13 = 1802857321;
    int v5 = 1667327590;
LABEL_31:
    *a3 = v5;
    a3[1] = 4;
    a3[2] = v13;
    goto LABEL_32;
  }
  return result;
}

uint64_t AudioFormatProperty_CanonicalMagicCookieFromEncapsulatedMagicCookie(unsigned int *a1, unsigned int *a2, void *a3)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = 1718449215;
  int v7 = AudioFormatEncryptedFormatTranslator::DecryptFormatID(*a1, &v40);
  int v8 = a1[1];
  if (v8 <= 1667327589)
  {
    BOOL v9 = v8 == 862416946 || v8 == 862417008;
    if (!v9 && (v8 != 1299148630 || v7 != 1634754915)) {
      return v6;
    }
  }
  else if (v8 > 1832149605)
  {
    if (v8 != 1832149606 && v8 != 1836069990) {
      return v6;
    }
  }
  else
  {
    if (v8 == 1667327590)
    {
      uint64_t v27 = a1[4];
      if (v27 < 0xC) {
        return 561213539;
      }
      uint64_t v35 = (_DWORD *)*((void *)a1 + 1);
      if (*v35 != 1802857321) {
        return v6;
      }
      if (a3)
      {
        uint64_t v6 = 561211770;
        if (v27 - 12 > (unint64_t)*a2) {
          return v6;
        }
        memcpy(a3, v35 + 3, v27 - 12);
        LODWORD(v27) = a1[4];
      }
      uint64_t v6 = 0;
      unsigned int v28 = v27 - 12;
      goto LABEL_54;
    }
    if (v8 != 1832149350) {
      return v6;
    }
  }
  for (uint64_t i = 0; i != 4; ++i)
  {
    if (v7 == sAudioFormatsThatHaveISOBoxesAsMagicCookies[i])
    {
      if (a3)
      {
        size_t v13 = a1[4];
        if (*a2 < v13) {
          return 561211770;
        }
        memcpy(a3, *((const void **)a1 + 1), v13);
      }
      uint64_t v6 = 0;
      unsigned int v28 = a1[4];
LABEL_54:
      *a2 = v28;
      return v6;
    }
  }
  if (v7 <= 1633772401)
  {
    if (v7 != 1633772320)
    {
      unsigned __int16 v12 = 25453;
      goto LABEL_29;
    }
    goto LABEL_30;
  }
  if (v7 == 1869641075)
  {
    size_t v30 = a1[4];
    if (v30 < 0x13) {
      return v6;
    }
    uint64_t v31 = (unsigned int *)*((void *)a1 + 1);
    if (bswap32(*v31) < 0x13 || v31[1] != 1936740196) {
      return v6;
    }
    if (!a3)
    {
LABEL_62:
      uint64_t v6 = 0;
      *a2 = v30;
      return v6;
    }
    if (*a2 >= v30)
    {
      memcpy(a3, v31, v30);
      uint64_t v32 = *((void *)a1 + 1);
      unsigned int v33 = bswap32(*(unsigned __int16 *)(v32 + 10)) >> 16;
      unsigned int v34 = bswap32(*(_DWORD *)(v32 + 12));
      LODWORD(v32) = bswap32(*(unsigned __int16 *)(v32 + 16)) >> 16;
      *a3 = 0x646165487375704FLL;
      *((unsigned char *)a3 + 8) = 1;
      *((_WORD *)a3 + 5) = v33;
      *((_DWORD *)a3 + 3) = v34;
      *((_WORD *)a3 + 8) = v32;
      LODWORD(v30) = a1[4];
      goto LABEL_62;
    }
    return 561211770;
  }
  unsigned __int16 v12 = 25458;
LABEL_29:
  if (v7 == (v12 | 0x61610000))
  {
LABEL_30:
    unsigned int v14 = a1[4];
    if (v14 >= 0xD)
    {
      uint64_t v15 = *((void *)a1 + 1);
      if (*(_DWORD *)(v15 + 4) == 1935962981)
      {
        int v17 = *(unsigned __int8 *)(v15 + 8);
        AudioFormatInfo v16 = (char *)(v15 + 8);
        BOOL v18 = v17 == 3;
        if (v17 == 3) {
          int v19 = -8;
        }
        else {
          int v19 = -12;
        }
        size_t v20 = v19 + v14;
        if (v18) {
          long long v21 = v16;
        }
        else {
          long long v21 = v16 + 4;
        }
        int v43 = 0;
        uint64_t v44 = 0;
        uint64_t v45 = 0;
        v46[2] = 0;
        MP4AudioProgramConfig::Clear((MP4AudioProgramConfig *)v46);
        long long v48 = 0u;
        long long v47 = 0u;
        DecoderConfigDescr::cleanup((DecoderConfigDescr *)&v42);
        bzero(v41, 0x5F0uLL);
        v38[0] = v21;
        v38[1] = &v21[v20];
        uint64_t v39 = 0;
        if ((v21 & 3) != 0 && v20)
        {
          int v22 = 0;
          char v23 = (_BYTE)v21 + 1;
          int v24 = -8;
          uint64_t v25 = v21 + 1;
          do
          {
            HIDWORD(v39) = v24 + 16;
            v38[0] = v25;
            int v22 = *(v25 - 1) | (v22 << 8);
            LODWORD(v39) = v22;
            v24 += 8;
            if ((v23 & 3) == 0) {
              break;
            }
            ++v23;
          }
          while (v25++ < &v21[v20]);
          LODWORD(v39) = v22 << (24 - v24);
        }
        uint64_t v6 = MP4AudioESDS::Deserialize((uint64_t)v41, (uint64_t)v38, 0, 0);
        if (!v6)
        {
          if ((v43 - 105) >= 0xFFFFFFFD)
          {
            int v43 = 64;
            LODWORD(v20) = DecoderConfigDescr::MPEG4AudioSpecificPayloadSerializeByteCount((DecoderConfigDescr *)&v42)
                         + 37;
            if (a3)
            {
              if (*a2 < v20) {
                goto LABEL_70;
              }
              v36[0] = a3;
              v36[1] = a3;
              v36[2] = (char *)a3 + v20;
              v36[3] = 0x2000000000;
              int v37 = a3 & 3;
              MP4AudioESDS::Serialize((uint64_t)v41, (uint64_t)v36, 0, 0);
            }
LABEL_72:
            uint64_t v6 = 0;
            *a2 = v20;
          }
          else
          {
            if (!a3) {
              goto LABEL_72;
            }
            if (*a2 >= v20)
            {
              memcpy(a3, v21, v20);
              goto LABEL_72;
            }
LABEL_70:
            uint64_t v6 = 561211770;
          }
        }
        if (*((void *)&v48 + 1)) {
          std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v48 + 1));
        }
        if (*((void *)&v47 + 1)) {
          std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v47 + 1));
        }
      }
    }
  }
  return v6;
}

void sub_190189B20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  MP4AudioESDS::~MP4AudioESDS((MP4AudioESDS *)va);
  _Unwind_Resume(a1);
}

uint64_t AudioFormatProperty_DecodeFormatIDsForEncapsulatedMagicCookieName(int *a1, unsigned int *a2, unsigned int *a3)
{
  int v3 = *a1;
  if (*a1 > 1832149349)
  {
    if (v3 == 1832149350 || v3 == 1832149606 || v3 == 1836069990) {
      goto LABEL_22;
    }
    return 1718449215;
  }
  if (v3 == 862416946 || v3 == 862417008) {
    goto LABEL_22;
  }
  if (v3 != 1299148630 || a1[1] != 4) {
    return 1718449215;
  }
  int v5 = a1[2];
  if (v5 != 1680961633)
  {
    uint64_t v6 = 1;
    while (v6 != 10)
    {
      uint64_t v7 = v6;
      int v8 = sQTMovieDecoderConfigBoxNames_HandledTheSameAsMP4[v6++];
      if (v5 == v8)
      {
        if ((unint64_t)(v7 - 1) <= 8) {
          goto LABEL_22;
        }
        return 1718449215;
      }
    }
    return 1718449215;
  }
LABEL_22:
  if (a1[1] != 4) {
    return 561213539;
  }
  uint64_t v11 = 0;
  int v12 = 0;
  char v13 = 0;
  int v14 = a1[2];
  char v15 = 1;
  uint64_t result = 1718449215;
  while (2)
  {
    int v17 = &sPairedCodingNameAndConfigNames[2 * v11 + 1];
    while (1)
    {
      int v18 = *v17;
      v17 += 2;
      if (v18 == v14) {
        break;
      }
      if (++v11 == 11)
      {
        if ((v13 & 1) == 0) {
          return result;
        }
        return AudioFormat_GetAudioFormatIDsForISOCodingName(v12, a2, a3);
      }
    }
    if ((v15 & 1) == 0) {
      return 1718449215;
    }
    char v15 = 0;
    uint64_t result = 0;
    int v12 = sPairedCodingNameAndConfigNames[2 * v11++];
    char v13 = 1;
    if (v11 != 11) {
      continue;
    }
    break;
  }
  return AudioFormat_GetAudioFormatIDsForISOCodingName(v12, a2, a3);
}

uint64_t AudioFormatProperty_CodingNameForDecodeFormatID(int *a1, int *a2, int *a3)
{
  uint64_t v6 = 1718449215;
  int v7 = a1[2];
  if (v7 <= 1463899716)
  {
    if (v7 > 1113011763)
    {
      if (v7 != 1113011764)
      {
        if (v7 != 1299148630)
        {
          if (v7 != 1380333108) {
            return v6;
          }
          goto LABEL_35;
        }
        if (*a1 != 1634754915) {
          return v6;
        }
LABEL_18:
        if (a3 && *a2 < 0xC) {
          return 561211770;
        }
        uint64_t v11 = 0;
        uint64_t v12 = *a1;
        do
        {
          if (sAudioFormatIDs_mp4a[v11] == v12)
          {
            int v13 = 1836069985;
            goto LABEL_42;
          }
          ++v11;
        }
        while (v11 != 19);
        int v13 = 1700998451;
        if (v12 != 1700997939 && v12 != 1700998451)
        {
          if (v12 == 1819304813)
          {
            if (a1[1]) {
              int v13 = 1718641517;
            }
            else {
              int v13 = 1768973165;
            }
          }
          else
          {
            uint64_t v17 = 0;
            int v18 = &dword_1901DCA94;
            do
            {
              int v19 = *v18;
              v18 += 2;
              if (v19 == v12)
              {
                int v13 = sPairedCodingNameAndAudioFormatIDs[2 * v17];
                goto LABEL_42;
              }
              ++v17;
            }
            while (v17 != 9);
            int v20 = 1969977198;
            AudioFormatEncryptedFormatTranslator::DecryptFormatID(v12, &v20);
            if (v20 == 1667392371)
            {
LABEL_57:
              int v13 = 1701733217;
              goto LABEL_42;
            }
            if (v20 != 1885695587)
            {
              if (v20 != 1667591779) {
                return v6;
              }
              goto LABEL_57;
            }
            int v13 = 1685220723;
          }
        }
LABEL_42:
        if (a3)
        {
          *a3 = v7;
          a3[1] = 4;
          a3[2] = v13;
        }
        int v14 = 12;
        goto LABEL_47;
      }
LABEL_35:
      if (a3 && *a2 < 0xA) {
        return 561211770;
      }
      FormatTagFroAudioFormatID mFormatID = AudioFormat_GetFormatTagFromFormatID(*a1, a1[1]);
      if (a3 && FormatTagFromFormatID)
      {
        *a3 = a1[2];
        a3[1] = 2;
        *((_WORD *)a3 + 4) = FormatTagFromFormatID;
      }
      else if (!FormatTagFromFormatID)
      {
        return v6;
      }
      int v14 = 10;
      goto LABEL_47;
    }
    BOOL v8 = v7 == 862416946;
    int v9 = 862417008;
    goto LABEL_13;
  }
  if (v7 > 1832149349)
  {
    BOOL v8 = v7 == 1832149350 || v7 == 1832149606;
    int v9 = 1836069990;
LABEL_13:
    if (v8 || v7 == v9) {
      goto LABEL_18;
    }
    return v6;
  }
  if (v7 == 1463899717) {
    goto LABEL_35;
  }
  if (v7 == 1667327590)
  {
    if (a3)
    {
      if (*a2 < 0x10) {
        return 561211770;
      }
      *(void *)a3 = 0x463616666;
      a3[2] = *a1;
    }
    int v14 = 16;
LABEL_47:
    uint64_t v6 = 0;
    *a2 = v14;
  }
  return v6;
}

uint64_t AudioFormatProperty_EncapsulatedMagicCookieFromCanonicalMagicCookie(unsigned int *a1, _DWORD *a2, uint64_t a3)
{
  uint64_t v6 = 1718449215;
  int v7 = AudioFormatEncryptedFormatTranslator::DecryptFormatID(*a1, &v24);
  int v8 = a1[1];
  if (v8 <= 1667327589)
  {
    BOOL v9 = v8 == 862416946 || v8 == 862417008;
    if (!v9 && (v8 != 1299148630 || v7 != 1634754915)) {
      return v6;
    }
  }
  else if (v8 > 1832149605)
  {
    if (v8 != 1832149606 && v8 != 1836069990) {
      return v6;
    }
  }
  else
  {
    if (v8 == 1667327590)
    {
      if (a3)
      {
        unint64_t v19 = a1[4];
        if (v19 + 12 > *a2) {
          return 561211770;
        }
        *(_DWORD *)a3 = 1768650091;
        *(void *)(a3 + 4) = bswap64(v19);
        memcpy((void *)(a3 + 12), (const void *)(*((void *)a1 + 1) + 12), a1[4] - 12);
      }
      LODWORD(v12) = a1[4] + 12;
      goto LABEL_46;
    }
    if (v8 != 1832149350) {
      return v6;
    }
  }
  for (uint64_t i = 0; i != 4; ++i)
  {
    if (v7 == sAudioFormatsThatHaveISOBoxesAsMagicCookies[i])
    {
      if (a3)
      {
        size_t v18 = a1[4];
        if (*a2 < v18) {
          return 561211770;
        }
        memcpy((void *)a3, *((const void **)a1 + 1), v18);
      }
      goto LABEL_31;
    }
  }
  if (v7 == 1869641075)
  {
    size_t v12 = a1[4];
    if (v12 >= 0x13)
    {
      int v13 = (int *)*((void *)a1 + 1);
      int v14 = *v13;
      if (*v13 == 1937076303 && v13[1] == 1684104520)
      {
        if (!a3) {
          goto LABEL_46;
        }
        if (*a2 >= v12)
        {
          memcpy((void *)a3, v13, v12);
          uint64_t v15 = *((void *)a1 + 1);
          unsigned int v16 = bswap32(*(unsigned __int16 *)(v15 + 10)) >> 16;
          unsigned int v17 = bswap32(*(_DWORD *)(v15 + 12));
          LODWORD(v15) = bswap32(*(unsigned __int16 *)(v15 + 16)) >> 16;
          *(_DWORD *)a3 = bswap32(a1[4]);
          strcpy((char *)(a3 + 4), "dOps");
          *(_WORD *)(a3 + 10) = v16;
          *(_DWORD *)(a3 + 12) = v17;
          *(_WORD *)(a3 + 16) = v15;
LABEL_31:
          LODWORD(v12) = a1[4];
          goto LABEL_46;
        }
        return 561211770;
      }
      if (v12 != 28) {
        return v6;
      }
      if (!a3) {
        goto LABEL_43;
      }
      if (*a2 >= 0x13u)
      {
        unsigned int v20 = bswap32(v13[4]);
        if (v20 - 1 > 1) {
          return v6;
        }
        int v21 = v13[1];
        *(void *)a3 = 0x73704F6413000000;
        if (v14 == 50855936) {
          __int16 v22 = 30720;
        }
        else {
          __int16 v22 = 14337;
        }
        *(unsigned char *)(a3 + 8) = 0;
        *(unsigned char *)(a3 + 9) = v20;
        *(_WORD *)(a3 + 10) = v22;
        *(_DWORD *)(a3 + 12) = v21;
        *(_WORD *)(a3 + 16) = 0;
        *(unsigned char *)(a3 + 18) = 0;
LABEL_43:
        LODWORD(v12) = 19;
LABEL_46:
        uint64_t v6 = 0;
        *a2 = v12;
        return v6;
      }
      return 561211770;
    }
  }
  return v6;
}

uint64_t MP4SLSSpecificConfig::Deserialize(uint64_t a1, uint64_t a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  unsigned int v4 = *(_DWORD *)(a2 + 16);
  unsigned int v5 = v4 >> 26;
  int v6 = *(_DWORD *)(a2 + 20) - 6;
  *(_DWORD *)(a2 + 20) = v6;
  if (v6 < 0)
  {
    TBitstreamReader<unsigned int>::FillCacheFrom(a2, *(unsigned int **)a2);
    *(void *)a2 += 4;
    unsigned int v8 = *(_DWORD *)(a2 + 16);
    int v9 = *(_DWORD *)(a2 + 20);
    v5 |= v8 >> v9;
    int v6 = v9 + 32;
    *(_DWORD *)(a2 + 20) = v9 + 32;
    if (v9 == -32) {
      unsigned int v7 = 0;
    }
    else {
      unsigned int v7 = v8 << -(char)v9;
    }
  }
  else
  {
    unsigned int v7 = v4 << 6;
  }
  *(_DWORD *)(a2 + 16) = v7;
  *(unsigned char *)(a1 + 1116) = (4 * v5) & 0xF8;
  if (((4 * (_BYTE)v5) & 0x80) != 0)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      int v19 = 136315394;
      unsigned int v20 = "MP4SLSSpecificConfig.cpp";
      __int16 v21 = 1024;
      int v22 = 28;
      int v13 = MEMORY[0x1E4F14500];
      int v14 = "%25s:%-5d  MP4SLSSpecificConfig::Deserialize: invalid PCM word length";
LABEL_17:
      _os_log_impl(&dword_18FEC0000, v13, OS_LOG_TYPE_ERROR, v14, (uint8_t *)&v19, 0x12u);
    }
    return 4294967090;
  }
  unsigned int v10 = v7 >> 29;
  int v11 = v6 - 3;
  *(_DWORD *)(a2 + 20) = v11;
  if (v11 < 0)
  {
    TBitstreamReader<unsigned int>::FillCacheFrom(a2, *(unsigned int **)a2);
    *(void *)a2 += 4;
    unsigned int v15 = *(_DWORD *)(a2 + 16);
    int v16 = *(_DWORD *)(a2 + 20);
    v10 |= v15 >> v16;
    *(_DWORD *)(a2 + 20) = v16 + 32;
    if (v16 == -32) {
      int v12 = 0;
    }
    else {
      int v12 = v15 << -(char)v16;
    }
  }
  else
  {
    int v12 = 8 * v7;
  }
  *(_DWORD *)(a2 + 16) = v12;
  char v17 = *(unsigned char *)(a1 + 1116) | v10;
  *(unsigned char *)(a1 + 1116) = v17;
  if ((v17 & 7u) >= 3)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      int v19 = 136315394;
      unsigned int v20 = "MP4SLSSpecificConfig.cpp";
      __int16 v21 = 1024;
      int v22 = 32;
      int v13 = MEMORY[0x1E4F14500];
      int v14 = "%25s:%-5d  MP4SLSSpecificConfig::Deserialize: invalid frame length";
      goto LABEL_17;
    }
    return 4294967090;
  }
  if (!*(_DWORD *)(a1 + 12))
  {
    MP4AudioProgramConfig::Deserialize((unsigned int *)(a1 + 16), a2);
    if (*(_DWORD *)(a1 + 24) != *(_DWORD *)(a1 + 8))
    {
      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
        return 4294967090;
      }
      int v19 = 136315394;
      unsigned int v20 = "MP4SLSSpecificConfig.cpp";
      __int16 v21 = 1024;
      int v22 = 40;
      int v13 = MEMORY[0x1E4F14500];
      int v14 = "%25s:%-5d  MP4SLSSpecificConfig::Deserialize: the Program sampleRate is incorrect";
      goto LABEL_17;
    }
  }
  return 0;
}

void MP4SLSSpecificConfig::~MP4SLSSpecificConfig(MP4SLSSpecificConfig *this)
{
}

uint64_t MP4ALSSpecificConfig::Deserialize(_DWORD *a1, uint64_t a2)
{
  uint64_t v84 = *MEMORY[0x1E4F143B8];
  TBitstreamReader<unsigned int>::SkipBits(a2, 5);
  int v4 = *(_DWORD *)(a2 + 16);
  int v5 = *(_DWORD *)(a2 + 20) - 32;
  *(_DWORD *)(a2 + 20) = v5;
  if (v5 < 0)
  {
    TBitstreamReader<unsigned int>::FillCacheFrom(a2, *(unsigned int **)a2);
    unsigned int v8 = *(_DWORD *)(a2 + 16);
    int v7 = *(_DWORD *)(a2 + 20);
    int v5 = v7 + 32;
    BOOL v9 = v7 == -32;
    *(void *)a2 += 4;
    int v6 = (v8 >> v7) | v4;
    int v10 = v8 << -(char)v7;
    if (v9) {
      int v4 = 0;
    }
    else {
      int v4 = v10;
    }
    *(_DWORD *)(a2 + 16) = v4;
    *(_DWORD *)(a2 + 20) = v5;
  }
  else
  {
    int v6 = v4;
  }
  if (v6 != 1095521024)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136315394;
      *(void *)&uint8_t buf[4] = "MP4SLSSpecificConfig.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 127;
      unsigned int v20 = MEMORY[0x1E4F14500];
      __int16 v21 = "%25s:%-5d  MP4ALSSpecificConfig::Deserialize: invalid ALS identifier";
LABEL_67:
      _os_log_impl(&dword_18FEC0000, v20, OS_LOG_TYPE_ERROR, v21, buf, 0x12u);
    }
    return 4294967090;
  }
  int v11 = v5 - 32;
  *(_DWORD *)(a2 + 20) = v11;
  if (v11 < 0)
  {
    TBitstreamReader<unsigned int>::FillCacheFrom(a2, *(unsigned int **)a2);
    unsigned int v13 = *(_DWORD *)(a2 + 16);
    int v12 = *(_DWORD *)(a2 + 20);
    int v14 = v12 + 32;
    BOOL v9 = v12 == -32;
    *(void *)a2 += 4;
    v4 |= v13 >> v12;
    int v15 = v13 << -(char)v12;
    if (v9) {
      int v15 = 0;
    }
    *(_DWORD *)(a2 + 16) = v15;
    *(_DWORD *)(a2 + 20) = v14;
  }
  a1[2] = v4;
  TBitstreamReader<unsigned int>::SkipBits(a2, 32);
  unsigned int v16 = *(_DWORD *)(a2 + 16);
  unsigned int v17 = HIWORD(v16);
  int v18 = *(_DWORD *)(a2 + 20) - 16;
  *(_DWORD *)(a2 + 20) = v18;
  if (v18 < 0)
  {
    TBitstreamReader<unsigned int>::FillCacheFrom(a2, *(unsigned int **)a2);
    *(void *)a2 += 4;
    unsigned int v22 = *(_DWORD *)(a2 + 16);
    int v23 = *(_DWORD *)(a2 + 20);
    v17 |= v22 >> v23;
    *(_DWORD *)(a2 + 20) = v23 + 32;
    if (v23 == -32) {
      int v19 = 0;
    }
    else {
      int v19 = v22 << -(char)v23;
    }
  }
  else
  {
    int v19 = v16 << 16;
  }
  *(_DWORD *)(a2 + 16) = v19;
  a1[4] = v17 + 1;
  if (v17 + 1 >= 0xD)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136315394;
      *(void *)&uint8_t buf[4] = "MP4SLSSpecificConfig.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 134;
      unsigned int v20 = MEMORY[0x1E4F14500];
      __int16 v21 = "%25s:%-5d  MP4ALSSpecificConfig::Deserialize: invalid channel count";
      goto LABEL_67;
    }
    return 4294967090;
  }
  if (v17)
  {
    if (v17 == 1) {
      unsigned int v24 = 6619138;
    }
    else {
      unsigned int v24 = ((_WORD)v17 + 1) | 0xFFFF0000;
    }
  }
  else
  {
    unsigned int v24 = 6553601;
  }
  a1[6] = v24;
  TBitstreamReader<unsigned int>::SkipBits(a2, 3);
  unsigned int v25 = *(_DWORD *)(a2 + 16);
  unsigned int v26 = v25 >> 29;
  int v27 = *(_DWORD *)(a2 + 20) - 3;
  *(_DWORD *)(a2 + 20) = v27;
  if (v27 < 0)
  {
    TBitstreamReader<unsigned int>::FillCacheFrom(a2, *(unsigned int **)a2);
    *(void *)a2 += 4;
    unsigned int v29 = *(_DWORD *)(a2 + 16);
    int v30 = *(_DWORD *)(a2 + 20);
    v26 |= v29 >> v30;
    *(_DWORD *)(a2 + 20) = v30 + 32;
    if (v30 == -32) {
      int v28 = 0;
    }
    else {
      int v28 = v29 << -(char)v30;
    }
  }
  else
  {
    int v28 = 8 * v25;
  }
  *(_DWORD *)(a2 + 16) = v28;
  if ((v26 - 1) >= 3u)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136315394;
      *(void *)&uint8_t buf[4] = "MP4SLSSpecificConfig.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 160;
      unsigned int v20 = MEMORY[0x1E4F14500];
      __int16 v21 = "%25s:%-5d  MP4ALSSpecificConfig::Deserialize: invalid resolution";
      goto LABEL_67;
    }
    return 4294967090;
  }
  a1[5] = dword_1901DCBB8[(v26 - 1)];
  TBitstreamReader<unsigned int>::SkipBits(a2, 2);
  unsigned int v31 = *(_DWORD *)(a2 + 16);
  unsigned int v32 = HIWORD(v31);
  int v33 = *(_DWORD *)(a2 + 20) - 16;
  *(_DWORD *)(a2 + 20) = v33;
  if (v33 < 0)
  {
    TBitstreamReader<unsigned int>::FillCacheFrom(a2, *(unsigned int **)a2);
    *(void *)a2 += 4;
    unsigned int v35 = *(_DWORD *)(a2 + 16);
    int v36 = *(_DWORD *)(a2 + 20);
    v32 |= v35 >> v36;
    *(_DWORD *)(a2 + 20) = v36 + 32;
    if (v36 == -32) {
      int v34 = 0;
    }
    else {
      int v34 = v35 << -(char)v36;
    }
  }
  else
  {
    int v34 = v31 << 16;
  }
  *(_DWORD *)(a2 + 16) = v34;
  a1[3] = v32 + 1;
  TBitstreamReader<unsigned int>::SkipBits(a2, 30);
  int Bit = TBitstreamReader<unsigned int>::GetBit(a2);
  int v38 = TBitstreamReader<unsigned int>::GetBit(a2);
  TBitstreamReader<unsigned int>::SkipBits(a2, 8);
  if (!Bit) {
    return 0;
  }
  unsigned int v40 = *(_DWORD *)(a2 + 16);
  unsigned int v41 = HIWORD(v40);
  int v42 = *(_DWORD *)(a2 + 20) - 16;
  *(_DWORD *)(a2 + 20) = v42;
  if (v42 < 0)
  {
    TBitstreamReader<unsigned int>::FillCacheFrom(a2, *(unsigned int **)a2);
    *(void *)a2 += 4;
    unsigned int v45 = *(_DWORD *)(a2 + 16);
    int v46 = *(_DWORD *)(a2 + 20);
    v41 |= v45 >> v46;
    *(_DWORD *)(a2 + 20) = v46 + 32;
    if (v46 == -32) {
      int v43 = 0;
    }
    else {
      int v43 = v45 << -(char)v46;
    }
  }
  else
  {
    int v43 = v40 << 16;
  }
  *(_DWORD *)(a2 + 16) = v43;
  if ((v41 & 0xF000) != 0)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136315394;
      *(void *)&uint8_t buf[4] = "MP4SLSSpecificConfig.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 208;
      unsigned int v20 = MEMORY[0x1E4F14500];
      __int16 v21 = "%25s:%-5d  MP4ALSSpecificConfig::Deserialize: invalid channel configuration";
      goto LABEL_67;
    }
    return 4294967090;
  }
  v39.i32[0] = (unsigned __int16)v41;
  uint8x8_t v47 = (uint8x8_t)vcnt_s8(v39);
  v47.i16[0] = vaddlv_u8(v47);
  if (v47.i32[0] != a1[4])
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136315394;
      *(void *)&uint8_t buf[4] = "MP4SLSSpecificConfig.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 211;
      unsigned int v20 = MEMORY[0x1E4F14500];
      __int16 v21 = "%25s:%-5d  MP4ALSSpecificConfig::Deserialize: mismatch between channel count and channel configuration";
      goto LABEL_67;
    }
    return 4294967090;
  }
  std::vector<unsigned char>::vector(buf, v47.u32[0]);
  if (v38)
  {
    int v48 = a1[4];
    if (v48)
    {
      unsigned __int8 v49 = 0;
      int v50 = v48 - 1;
      unsigned int v51 = __clz(v48 - 1);
      unsigned int v52 = 32 - v51;
      while (1)
      {
        if (v50)
        {
          unsigned int v53 = *(_DWORD *)(a2 + 16);
          unsigned int v54 = v53 >> v51;
          int v55 = *(_DWORD *)(a2 + 20) - v52;
          *(_DWORD *)(a2 + 20) = v55;
          if (v55 < 0)
          {
            TBitstreamReader<unsigned int>::FillCacheFrom(a2, *(unsigned int **)a2);
            *(void *)a2 += 4;
            unsigned int v57 = *(_DWORD *)(a2 + 16);
            int v58 = *(_DWORD *)(a2 + 20);
            v54 |= v57 >> v58;
            *(_DWORD *)(a2 + 20) = v58 + 32;
            int v56 = v58 == -32 ? 0 : v57 << -(char)v58;
          }
          else
          {
            int v56 = v53 << v52;
          }
          *(_DWORD *)(a2 + 16) = v56;
        }
        else
        {
          LOBYTE(v54) = 0;
        }
        *(unsigned char *)(*(void *)buf + v49) = v54;
        int v59 = (CAAudioChannelLayout *)a1[4];
        if (v59 <= *(unsigned __int8 *)(*(void *)buf + v49)) {
          break;
        }
        if (v59 <= ++v49) {
          goto LABEL_78;
        }
      }
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        int v79 = 136315394;
        uint64_t v80 = "MP4SLSSpecificConfig.cpp";
        __int16 v81 = 1024;
        int v82 = 222;
        _os_log_impl(&dword_18FEC0000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%25s:%-5d  MP4ALSSpecificConfig::Deserialize: channel position out of range", (uint8_t *)&v79, 0x12u);
      }
      uint64_t v44 = 4294967090;
      goto LABEL_112;
    }
LABEL_77:
    int v59 = 0;
  }
  else
  {
    for (uint64_t i = 0; i != 96; i += 8)
    {
      if (*(unsigned __int16 *)((char *)&ALSChannelBitmapToTag + i) == (unsigned __int16)v41)
      {
        uint64_t v44 = 0;
        a1[6] = *(_DWORD *)((char *)&ALSChannelBitmapToTag + i + 4);
        goto LABEL_112;
      }
    }
    if (!a1[4]) {
      goto LABEL_77;
    }
    int v62 = 0;
    do
    {
      *(unsigned char *)(*(void *)buf + v62) = v62;
      ++v62;
      int v59 = (CAAudioChannelLayout *)a1[4];
    }
    while (v59 > v62);
  }
LABEL_78:
  int v63 = (CAAudioChannelLayout *)CAAudioChannelLayout::Create(v59);
  CAAudioChannelLayout::SetAllToUnknown(v63, (AudioChannelLayout *)a1[4]);
  uint64_t v65 = (char *)v63 + 12;
  if (v41)
  {
    unsigned int v66 = 1;
    *(_DWORD *)&v65[20 * **(unsigned char **)buf] = 1;
  }
  else
  {
    unsigned int v66 = 0;
  }
  if ((v41 & 2) != 0)
  {
    int v69 = *(unsigned __int8 *)(*(void *)buf + v66++);
    *(_DWORD *)&v65[20 * v69] = 2;
    if ((v41 & 4) == 0)
    {
LABEL_83:
      if ((v41 & 8) == 0) {
        goto LABEL_84;
      }
      goto LABEL_99;
    }
  }
  else if ((v41 & 4) == 0)
  {
    goto LABEL_83;
  }
  int v70 = *(unsigned __int8 *)(*(void *)buf + v66++);
  *(_DWORD *)&v65[20 * v70] = 33;
  if ((v41 & 8) == 0)
  {
LABEL_84:
    if ((v41 & 0x10) == 0) {
      goto LABEL_85;
    }
    goto LABEL_100;
  }
LABEL_99:
  int v71 = *(unsigned __int8 *)(*(void *)buf + v66++);
  *(_DWORD *)&v65[20 * v71] = 34;
  if ((v41 & 0x10) == 0)
  {
LABEL_85:
    if ((v41 & 0x20) == 0) {
      goto LABEL_86;
    }
    goto LABEL_101;
  }
LABEL_100:
  int v72 = *(unsigned __int8 *)(*(void *)buf + v66++);
  *(_DWORD *)&v65[20 * v72] = 5;
  if ((v41 & 0x20) == 0)
  {
LABEL_86:
    if ((v41 & 0x40) == 0) {
      goto LABEL_87;
    }
    goto LABEL_102;
  }
LABEL_101:
  int v73 = *(unsigned __int8 *)(*(void *)buf + v66++);
  *(_DWORD *)&v65[20 * v73] = 6;
  if ((v41 & 0x40) == 0)
  {
LABEL_87:
    if ((v41 & 0x80) == 0) {
      goto LABEL_88;
    }
    goto LABEL_103;
  }
LABEL_102:
  int v74 = *(unsigned __int8 *)(*(void *)buf + v66++);
  *(_DWORD *)&v65[20 * v74] = 3;
  if ((v41 & 0x80) == 0)
  {
LABEL_88:
    if ((v41 & 0x100) == 0) {
      goto LABEL_89;
    }
    goto LABEL_104;
  }
LABEL_103:
  int v75 = *(unsigned __int8 *)(*(void *)buf + v66++);
  *(_DWORD *)&v65[20 * v75] = 9;
  if ((v41 & 0x100) == 0)
  {
LABEL_89:
    if ((v41 & 0x200) == 0) {
      goto LABEL_90;
    }
    goto LABEL_105;
  }
LABEL_104:
  int v76 = *(unsigned __int8 *)(*(void *)buf + v66);
  LOBYTE(v66) = v66 + 1;
  *(_DWORD *)&v65[20 * v76] = 4;
  if ((v41 & 0x200) == 0)
  {
LABEL_90:
    if ((v41 & 0x400) == 0) {
      goto LABEL_91;
    }
LABEL_106:
    int v78 = *(unsigned __int8 *)(*(void *)buf + v66);
    LOBYTE(v66) = v66 + 1;
    *(_DWORD *)&v65[20 * v78] = 0;
    if ((v41 & 0x800) == 0) {
      goto LABEL_93;
    }
    goto LABEL_92;
  }
LABEL_105:
  int v77 = *(unsigned __int8 *)(*(void *)buf + v66);
  LOBYTE(v66) = v66 + 1;
  *(_DWORD *)&v65[20 * v77] = 0;
  if ((v41 & 0x400) != 0) {
    goto LABEL_106;
  }
LABEL_91:
  if ((v41 & 0x800) != 0) {
LABEL_92:
  }
    *(_DWORD *)&v65[20 * *(unsigned __int8 *)(*(void *)buf + v66)] = 0;
LABEL_93:
  int v67 = CAAudioChannelLayout::ToTag((AudioChannelLayout *)v63, v64);
  if (v67 == 7143429) {
    int v68 = 7733253;
  }
  else {
    int v68 = v67;
  }
  a1[6] = v68;
  MEMORY[0x192FC7C50](v63);
  uint64_t v44 = 0;
LABEL_112:
  if (*(void *)buf)
  {
    *(void *)&uint8_t buf[8] = *(void *)buf;
    operator delete(*(void **)buf);
  }
  return v44;
}

void sub_19018ADDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
}

void MP4ALSSpecificConfig::~MP4ALSSpecificConfig(MP4ALSSpecificConfig *this)
{
}

uint64_t MP4ELDSpecificConfig::Serialize(uint64_t a1, uint64_t a2)
{
  AT::TBitstreamWriter<unsigned int>::PutBits(a2, *(_DWORD *)(a1 + 16), 1u);
  AT::TBitstreamWriter<unsigned int>::PutBits(a2, *(_DWORD *)(a1 + 20) >> 1, 3u);
  AT::TBitstreamWriter<unsigned int>::PutBits(a2, *(_DWORD *)(a1 + 24), 1u);
  if (*(_DWORD *)(a1 + 24))
  {
    uint64_t v4 = 1;
    AT::TBitstreamWriter<unsigned int>::PutBits(a2, *(_DWORD *)(a1 + 28), 1u);
    AT::TBitstreamWriter<unsigned int>::PutBits(a2, *(_DWORD *)(a1 + 32), 1u);
    unsigned int v5 = *(_DWORD *)(a1 + 12);
    if (v5 >= 3)
    {
      if (v5 == 3)
      {
        uint64_t v4 = 2;
      }
      else if (v5 >= 7)
      {
        if (v5 != 7) {
          goto LABEL_15;
        }
        uint64_t v4 = 4;
      }
      else
      {
        uint64_t v4 = 3;
      }
    }
    int v6 = (unsigned __int8 *)(a1 + 48);
    do
    {
      AT::TBitstreamWriter<unsigned int>::PutBits(a2, *(v6 - 12), 1u);
      AT::TBitstreamWriter<unsigned int>::PutBits(a2, *(v6 - 11), 4u);
      AT::TBitstreamWriter<unsigned int>::PutBits(a2, *(v6 - 10), 4u);
      AT::TBitstreamWriter<unsigned int>::PutBits(a2, *(v6 - 9), 3u);
      AT::TBitstreamWriter<unsigned int>::PutBits(a2, 0, 2u);
      AT::TBitstreamWriter<unsigned int>::PutBits(a2, *(v6 - 8), 1u);
      AT::TBitstreamWriter<unsigned int>::PutBits(a2, *(v6 - 4), 1u);
      if (*(v6 - 8))
      {
        AT::TBitstreamWriter<unsigned int>::PutBits(a2, *(v6 - 7), 2u);
        AT::TBitstreamWriter<unsigned int>::PutBits(a2, *(v6 - 6), 1u);
        AT::TBitstreamWriter<unsigned int>::PutBits(a2, *(v6 - 5), 2u);
      }
      if (*(v6 - 4))
      {
        AT::TBitstreamWriter<unsigned int>::PutBits(a2, *(v6 - 3), 2u);
        AT::TBitstreamWriter<unsigned int>::PutBits(a2, *(v6 - 2), 2u);
        AT::TBitstreamWriter<unsigned int>::PutBits(a2, *(v6 - 1), 1u);
        AT::TBitstreamWriter<unsigned int>::PutBits(a2, *v6, 1u);
      }
      v6 += 13;
      --v4;
    }
    while (v4);
  }
LABEL_15:
  if (*(unsigned char *)(a1 + 103) && *(void *)(a1 + 112))
  {
    AT::TBitstreamWriter<unsigned int>::PutBits(a2, 2, 4u);
    MP4LDSpatialConfigWriter::MP4LDSpatialConfigWriter((MP4LDSpatialConfigWriter *)&v12, *(const MP4SpatialAudioSpecificConfig **)(a1 + 112));
  }
  int v8 = *(_DWORD *)(a1 + 104);
  int v7 = (int *)(a1 + 104);
  if (v8)
  {
    AT::TBitstreamWriter<unsigned int>::PutBits(a2, 3, 4u);
    if (MP4SampleRate::Index((MP4SampleRate *)*v7) == 15) {
      int v9 = 4;
    }
    else {
      int v9 = 1;
    }
    AT::TBitstreamWriter<unsigned int>::PutBits(a2, v9, 4u);
    MP4SampleRate::Serialize(v7, a2);
    unsigned int v10 = *(_DWORD *)(a2 + 28) & 7;
    if (v10) {
      AT::TBitstreamWriter<unsigned int>::PutBits(a2, 0, v10);
    }
  }
  AT::TBitstreamWriter<unsigned int>::PutBits(a2, 0, 4u);
  return 0;
}

uint64_t MP4ELDSpecificConfig::SerializeCount(MP4ELDSpecificConfig *this)
{
  if (*((_DWORD *)this + 6))
  {
    unsigned int v1 = *((_DWORD *)this + 3);
    if (v1 >= 3)
    {
      if (v1 == 3)
      {
        uint64_t v2 = 2;
      }
      else if (v1 >= 7)
      {
        if (v1 != 7)
        {
          int v3 = 7;
          goto LABEL_18;
        }
        uint64_t v2 = 4;
      }
      else
      {
        uint64_t v2 = 3;
      }
    }
    else
    {
      uint64_t v2 = 1;
    }
    uint64_t v4 = (unsigned __int8 *)this + 44;
    int v3 = 7;
    do
    {
      if (*(v4 - 4)) {
        int v5 = 21;
      }
      else {
        int v5 = 16;
      }
      int v6 = *v4;
      v4 += 13;
      if (v6) {
        v5 += 6;
      }
      v3 += v5;
      --v2;
    }
    while (v2);
  }
  else
  {
    int v3 = 5;
  }
LABEL_18:
  if (*((unsigned char *)this + 103))
  {
    int v7 = (const MP4SpatialAudioSpecificConfig *)*((void *)this + 14);
    if (v7) {
      MP4LDSpatialConfigWriter::MP4LDSpatialConfigWriter((MP4LDSpatialConfigWriter *)&v11, v7);
    }
  }
  int v8 = (MP4SampleRate *)*((unsigned int *)this + 26);
  if (v8)
  {
    if (MP4SampleRate::Index(v8) == 15) {
      int v9 = 28;
    }
    else {
      int v9 = 4;
    }
    v3 += v9 + 8;
  }
  return (v3 + 4);
}

uint64_t MP4ELDSpecificConfig::Deserialize(uint64_t a1, uint64_t a2)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  *(_DWORD *)(a1 + 16) = TBitstreamReader<unsigned int>::GetBit(a2);
  unsigned int v4 = *(_DWORD *)(a2 + 16);
  unsigned int v5 = v4 >> 29;
  int v6 = *(_DWORD *)(a2 + 20) - 3;
  *(_DWORD *)(a2 + 20) = v6;
  if (v6 < 0)
  {
    TBitstreamReader<unsigned int>::FillCacheFrom(a2, *(unsigned int **)a2);
    *(void *)a2 += 4;
    unsigned int v8 = *(_DWORD *)(a2 + 16);
    int v9 = *(_DWORD *)(a2 + 20);
    v5 |= v8 >> v9;
    *(_DWORD *)(a2 + 20) = v9 + 32;
    if (v9 == -32) {
      int v7 = 0;
    }
    else {
      int v7 = v8 << -(char)v9;
    }
  }
  else
  {
    int v7 = 8 * v4;
  }
  *(_DWORD *)(a2 + 16) = v7;
  *(_DWORD *)(a1 + 20) = 2 * v5;
  if (!(2 * v5))
  {
    int Bit = TBitstreamReader<unsigned int>::GetBit(a2);
    *(_DWORD *)(a1 + 24) = Bit;
    if (Bit)
    {
      *(_DWORD *)(a1 + 28) = TBitstreamReader<unsigned int>::GetBit(a2);
      *(_DWORD *)(a1 + 32) = TBitstreamReader<unsigned int>::GetBit(a2);
      unsigned int v14 = *(_DWORD *)(a1 + 12);
      if (v14 < 3)
      {
        uint64_t v15 = 1;
LABEL_20:
        unsigned int v17 = *(_DWORD *)(a2 + 16);
        int v16 = *(_DWORD *)(a2 + 20);
        int v18 = (char *)(a1 + 48);
        while (1)
        {
          unsigned int v19 = HIWORD(v17);
          v16 -= 16;
          *(_DWORD *)(a2 + 20) = v16;
          if (v16 < 0)
          {
            TBitstreamReader<unsigned int>::FillCacheFrom(a2, *(unsigned int **)a2);
            *(void *)a2 += 4;
            unsigned int v20 = *(_DWORD *)(a2 + 16);
            int v21 = *(_DWORD *)(a2 + 20);
            v19 |= v20 >> v21;
            int v16 = v21 + 32;
            *(_DWORD *)(a2 + 20) = v21 + 32;
            if (v21 == -32) {
              unsigned int v17 = 0;
            }
            else {
              unsigned int v17 = v20 << -(char)v21;
            }
          }
          else
          {
            v17 <<= 16;
          }
          *(_DWORD *)(a2 + 16) = v17;
          *(v18 - 12) = (v19 & 0x8000) != 0;
          *(v18 - 11) = (v19 >> 11) & 0xF;
          *(v18 - 10) = (v19 >> 7) & 0xF;
          *(v18 - 9) = (v19 >> 4) & 7;
          *(v18 - 8) = (v19 & 2) != 0;
          *(v18 - 4) = v19 & 1;
          if ((v19 >> 1))
          {
            unsigned int v23 = v17 >> 27;
            v16 -= 5;
            *(_DWORD *)(a2 + 20) = v16;
            if (v16 < 0)
            {
              TBitstreamReader<unsigned int>::FillCacheFrom(a2, *(unsigned int **)a2);
              *(void *)a2 += 4;
              unsigned int v24 = *(_DWORD *)(a2 + 16);
              int v25 = *(_DWORD *)(a2 + 20);
              v23 |= v24 >> v25;
              int v16 = v25 + 32;
              *(_DWORD *)(a2 + 20) = v25 + 32;
              if (v25 == -32) {
                unsigned int v17 = 0;
              }
              else {
                unsigned int v17 = v24 << -(char)v25;
              }
            }
            else
            {
              v17 *= 32;
            }
            *(_DWORD *)(a2 + 16) = v17;
            *(v18 - 7) = (v23 >> 3) & 3;
            *(v18 - 6) = (v23 & 4) != 0;
            *(v18 - 5) = v23 & 3;
            if (*(v18 - 4))
            {
LABEL_35:
              unsigned int v26 = v17 >> 26;
              v16 -= 6;
              *(_DWORD *)(a2 + 20) = v16;
              if (v16 < 0)
              {
                TBitstreamReader<unsigned int>::FillCacheFrom(a2, *(unsigned int **)a2);
                *(void *)a2 += 4;
                unsigned int v27 = *(_DWORD *)(a2 + 16);
                int v28 = *(_DWORD *)(a2 + 20);
                v26 |= v27 >> v28;
                int v16 = v28 + 32;
                *(_DWORD *)(a2 + 20) = v28 + 32;
                if (v28 == -32) {
                  unsigned int v17 = 0;
                }
                else {
                  unsigned int v17 = v27 << -(char)v28;
                }
              }
              else
              {
                v17 <<= 6;
              }
              *(_DWORD *)(a2 + 16) = v17;
              *(v18 - 3) = (v26 >> 4) & 3;
              *(v18 - 2) = (v26 >> 2) & 3;
              *(v18 - 1) = (v26 & 2) != 0;
              char v22 = v26 & 1;
              goto LABEL_41;
            }
          }
          else
          {
            *(_WORD *)(v18 - 7) = 258;
            *(v18 - 5) = 2;
            if (v19) {
              goto LABEL_35;
            }
          }
          *(_WORD *)(v18 - 3) = 514;
          char v22 = 1;
          *(v18 - 1) = 1;
LABEL_41:
          *int v18 = v22;
          v18 += 13;
          if (!--v15) {
            goto LABEL_42;
          }
        }
      }
      if (v14 == 3)
      {
        uint64_t v15 = 2;
        goto LABEL_20;
      }
      if (v14 < 7)
      {
        uint64_t v15 = 3;
        goto LABEL_20;
      }
      if (v14 == 7)
      {
        uint64_t v15 = 4;
        goto LABEL_20;
      }
    }
LABEL_42:
    unsigned int v29 = *(unsigned int **)a2;
    int v30 = *(_DWORD *)(a2 + 20);
    if ((int)(v30 + 8 * (*(_DWORD *)(a2 + 8) - *(void *)a2)) < 8) {
      return 0;
    }
    unsigned int v31 = (unsigned int *)(a1 + 104);
    while (1)
    {
      unsigned int v32 = *(_DWORD *)(a2 + 16);
      uint64_t v12 = v32 >> 28;
      int v33 = v30 - 4;
      *(_DWORD *)(a2 + 20) = v33;
      if (v33 < 0)
      {
        TBitstreamReader<unsigned int>::FillCacheFrom(a2, v29);
        unsigned int v29 = (unsigned int *)(*(void *)a2 + 4);
        *(void *)a2 = v29;
        unsigned int v35 = *(_DWORD *)(a2 + 16);
        int v36 = *(_DWORD *)(a2 + 20);
        uint64_t v12 = (v35 >> v36) | v12;
        int v33 = v36 + 32;
        *(_DWORD *)(a2 + 20) = v36 + 32;
        if (v36 == -32) {
          unsigned int v34 = 0;
        }
        else {
          unsigned int v34 = v35 << -(char)v36;
        }
      }
      else
      {
        unsigned int v34 = 16 * v32;
      }
      *(_DWORD *)(a2 + 16) = v34;
      if (!v12) {
        return v12;
      }
      unsigned int v37 = v34 >> 28;
      int v38 = v33 - 4;
      *(_DWORD *)(a2 + 20) = v33 - 4;
      if (v33 - 4 < 0)
      {
        TBitstreamReader<unsigned int>::FillCacheFrom(a2, v29);
        unsigned int v29 = (unsigned int *)(*(void *)a2 + 4);
        *(void *)a2 = v29;
        unsigned int v40 = *(_DWORD *)(a2 + 16);
        int v41 = *(_DWORD *)(a2 + 20);
        v37 |= v40 >> v41;
        int v38 = v41 + 32;
        *(_DWORD *)(a2 + 20) = v41 + 32;
        if (v41 == -32) {
          unsigned int v39 = 0;
        }
        else {
          unsigned int v39 = v40 << -(char)v41;
        }
      }
      else
      {
        unsigned int v39 = 16 * v34;
      }
      *(_DWORD *)(a2 + 16) = v39;
      if (v37 == 15)
      {
        unsigned int v42 = HIBYTE(v39);
        v38 -= 8;
        *(_DWORD *)(a2 + 20) = v38;
        if (v38 < 0)
        {
          TBitstreamReader<unsigned int>::FillCacheFrom(a2, v29);
          unsigned int v29 = (unsigned int *)(*(void *)a2 + 4);
          *(void *)a2 = v29;
          unsigned int v43 = *(_DWORD *)(a2 + 16);
          int v44 = *(_DWORD *)(a2 + 20);
          v42 |= v43 >> v44;
          int v38 = v44 + 32;
          *(_DWORD *)(a2 + 20) = v44 + 32;
          if (v44 == -32) {
            unsigned int v39 = 0;
          }
          else {
            unsigned int v39 = v43 << -(char)v44;
          }
        }
        else
        {
          v39 <<= 8;
        }
        *(_DWORD *)(a2 + 16) = v39;
        unsigned int v37 = v42 + 15;
      }
      if (v37 == 270)
      {
        unsigned int v45 = HIWORD(v39);
        v38 -= 16;
        *(_DWORD *)(a2 + 20) = v38;
        if (v38 < 0)
        {
          TBitstreamReader<unsigned int>::FillCacheFrom(a2, v29);
          unsigned int v29 = (unsigned int *)(*(void *)a2 + 4);
          *(void *)a2 = v29;
          unsigned int v47 = *(_DWORD *)(a2 + 16);
          int v48 = *(_DWORD *)(a2 + 20);
          v45 |= v47 >> v48;
          int v38 = v48 + 32;
          *(_DWORD *)(a2 + 20) = v48 + 32;
          if (v48 == -32) {
            unsigned int v46 = 0;
          }
          else {
            unsigned int v46 = v47 << -(char)v48;
          }
        }
        else
        {
          unsigned int v46 = v39 << 16;
        }
        *(_DWORD *)(a2 + 16) = v46;
        unsigned int v37 = v45 + 270;
      }
      if (v12 == 3) {
        break;
      }
      if (v12 == 2)
      {
        *(unsigned char *)(a1 + 101) = 1;
        *(unsigned char *)(a1 + 103) = 1;
        operator new();
      }
      if (v12 != 1)
      {
        if (8 * v37 > v38 + 8 * (*(_DWORD *)(a2 + 8) - (int)v29))
        {
          if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
            return 4294967090;
          }
          int v53 = 136315394;
          unsigned int v54 = "MP4ELDSpecificConfig.cpp";
          __int16 v55 = 1024;
          int v56 = 81;
          unsigned int v10 = MEMORY[0x1E4F14500];
          uint64_t v11 = "%25s:%-5d  MP4ELDSpecificConfig::Deserialize: invalid eldExtLen value";
          goto LABEL_9;
        }
        uint64_t v50 = a2;
        int v51 = 8 * v37;
        goto LABEL_82;
      }
      *(_WORD *)(a1 + 101) = 257;
LABEL_83:
      unsigned int v29 = *(unsigned int **)a2;
      int v30 = *(_DWORD *)(a2 + 20);
      if ((int)(v30 + 8 * (*(_DWORD *)(a2 + 8) - *(void *)a2)) <= 7) {
        return 0;
      }
    }
    MP4SampleRate::Deserialize((MP4SampleRate *)(a1 + 104), a2, 1);
    if (!*v31)
    {
      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
        return 4294967090;
      }
      int v53 = 136315394;
      unsigned int v54 = "MP4ELDSpecificConfig.cpp";
      __int16 v55 = 1024;
      int v56 = 64;
      unsigned int v10 = MEMORY[0x1E4F14500];
      uint64_t v11 = "%25s:%-5d  MP4ELDSpecificConfig::Deserialize: invalid downscaling sample rate";
      goto LABEL_9;
    }
    if (*(_DWORD *)(a1 + 24))
    {
      if (*(_DWORD *)(a1 + 28)
        || (float v49 = (float)*(unsigned int *)(a1 + 8) / (float)*v31, v49 != floorf(v49))
        || (v49 & 1) != 0)
      {
        if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
          return 4294967090;
        }
        int v53 = 136315394;
        unsigned int v54 = "MP4ELDSpecificConfig.cpp";
        __int16 v55 = 1024;
        int v56 = 73;
        unsigned int v10 = MEMORY[0x1E4F14500];
        uint64_t v11 = "%25s:%-5d  MP4ELDSpecificConfig::Deserialize: incompatible downscaling and SBR settings";
        goto LABEL_9;
      }
    }
    uint64_t v50 = a2;
    int v51 = 4;
LABEL_82:
    TBitstreamReader<unsigned int>::SkipBits(v50, v51);
    goto LABEL_83;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    int v53 = 136315394;
    unsigned int v54 = "MP4ELDSpecificConfig.cpp";
    __int16 v55 = 1024;
    int v56 = 21;
    unsigned int v10 = MEMORY[0x1E4F14500];
    uint64_t v11 = "%25s:%-5d  MP4ELDSpecificConfig::Deserialize: Error resilience not supported";
LABEL_9:
    _os_log_impl(&dword_18FEC0000, v10, OS_LOG_TYPE_ERROR, v11, (uint8_t *)&v53, 0x12u);
  }
  return 4294967090;
}

void sub_19018BA5C(_Unwind_Exception *a1)
{
  MEMORY[0x192FC8940](v1, 0x10A1C40A5657A2CLL);
  _Unwind_Resume(a1);
}

void MP4ELDSpecificConfig::~MP4ELDSpecificConfig(MP4ELDSpecificConfig *this)
{
  *(void *)this = &unk_1EDF92F20;
  uint64_t v2 = *((void *)this + 14);
  *((void *)this + 14) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  JUMPOUT(0x192FC8940);
}

{
  uint64_t v2;

  *(void *)this = &unk_1EDF92F20;
  uint64_t v2 = *((void *)this + 14);
  *((void *)this + 14) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
}

uint64_t acv2::DitherConverter::SetBitDepth(acv2::DitherConverter *this, unsigned int a2)
{
  if (a2 > 0x18) {
    return 560096368;
  }
  uint64_t result = 0;
  *((_DWORD *)this + 42) = a2;
  return result;
}

void acv2::TPDFDitherConverter::ConvertBufferList(uint64_t a1, int a2, unsigned int **a3, _DWORD **a4)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  unsigned int v4 = (int *)*a3;
  int v5 = **a3;
  if (v5 != **a4) {
    std::terminate();
  }
  int v8 = 1;
  if ((*(unsigned char *)(a1 + 28) & 0x20) == 0) {
    int v8 = *(_DWORD *)(a1 + 44);
  }
  float v9 = scalbnf(1.0, 1 - *(_DWORD *)(a1 + 168));
  if (v5)
  {
    float v10 = v9;
    unint64_t v11 = 0;
    vDSP_Length v12 = (v8 * a2);
    uint64_t v13 = a1 + 176;
    uint64_t v14 = a1 + 208;
    do
    {
      __A = *(float **)&v4[4 * v11 + 4];
      uint64_t v15 = *(float **)&(*a4)[4 * v11 + 4];
      vDSP_Length v16 = v12;
      if (v12)
      {
        int v17 = 0;
        unsigned int v18 = v16;
        do
        {
          if (v18 >= 0x200) {
            vDSP_Length v19 = 512;
          }
          else {
            vDSP_Length v19 = v18;
          }
          generateVector((float32x4_t *)&v15[v17], v19, v13, v10);
          generateVector(__B, v19, v14, v10);
          vDSP_vadd(&v15[v17], 1, __B[0].f32, 1, &v15[v17], 1, v19);
          v17 += v19;
          v18 -= v19;
        }
        while (v18);
      }
      vDSP_Length v12 = v16;
      vDSP_vadd(__A, 1, v15, 1, v15, 1, v16);
      ++v11;
      unsigned int v4 = (int *)*a3;
    }
    while (v11 < **a3);
  }
}

void acv2::DitherConverter::description(int16x8_t *this@<X0>, std::string *a2@<X8>)
{
  acv2::AudioConverterBase::description(this, &v12);
  unsigned int v4 = std::string::append(&v12, "    bitdepth: ", 0xEuLL);
  long long v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v13.__r_.__value_.__r.__UInt32 words[2] = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v13.__r_.__value_.__l.__data_ = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__UInt32 words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&__p, this[10].u32[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  int v8 = std::string::append(&v13, (const std::string::value_type *)p_p, size);
  long long v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  v14.__r_.__value_.__r.__UInt32 words[2] = v8->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v14.__r_.__value_.__l.__data_ = v9;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__UInt32 words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  float v10 = std::string::append(&v14, "\n", 1uLL);
  *a2 = *v10;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__UInt32 words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v14.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v13.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v12.__r_.__value_.__l.__data_);
  }
}

void sub_19018BE68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (*(char *)(v26 - 25) < 0) {
    operator delete(*(void **)(v26 - 48));
  }
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

__CFString *acv2::TPDFDitherConverter::ConverterName(acv2::TPDFDitherConverter *this)
{
  return @"TPDFDitherConverter";
}

void acv2::TPDFDitherConverter::~TPDFDitherConverter(acv2::TPDFDitherConverter *this)
{
  acv2::AudioConverterBase::~AudioConverterBase(this);
  JUMPOUT(0x192FC8940);
}

void acv2::NoiseShapingDitherConverter::ConvertSingleChannel(acv2::NoiseShapingDitherConverter *this, unsigned int a2, unsigned int a3, const float *a4, int a5, float *a6, int a7)
{
  int v14 = *((_DWORD *)this + 42);
  float v15 = scalbnf(0.5, v14);
  *(float *)v16.i32 = scalbnf(2.0, -v14);
  uint64_t v17 = *((void *)this + 22);
  v18.i32[0] = *(_DWORD *)(v17 + 4 * a3);
  if (a2)
  {
    int v19 = 0;
    int v20 = 0;
    uint64_t v21 = a2;
    uint64_t v22 = *((void *)this + 24) + 32 * a3;
    do
    {
      float v23 = -(float)(*(float *)v18.i32 - (float)(v15 * a4[v19]));
      float v24 = roundf(v23);
      float v25 = v24 - v23;
      int8x16_t v18 = *(int8x16_t *)v22;
      int8x16_t v26 = *(int8x16_t *)(v22 + 16);
      float32x4_t v27 = (float32x4_t)vextq_s8(*(int8x16_t *)v22, v26, 4uLL);
      float32x4_t v28 = (float32x4_t)vextq_s8(v26, v16, 4uLL);
      v28.i32[3] = 0;
      *(float32x4_t *)uint64_t v22 = vmlaq_n_f32(v27, (float32x4_t)xmmword_1901C6580, v25);
      *(float32x4_t *)(v22 + 16) = vmlaq_n_f32(v28, (float32x4_t)xmmword_1901C6590, v25);
      a6[v20] = *(float *)v16.i32 * v24;
      v20 += a7;
      v19 += a5;
      --v21;
    }
    while (v21);
    uint64_t v17 = *((void *)this + 22);
  }
  *(_DWORD *)(v17 + 4 * a3) = v18.i32[0];
}

uint64_t acv2::NoiseShapingDitherConverter::ConvertBufferList(uint64_t result, uint64_t a2, unsigned int **a3, _DWORD **a4)
{
  unsigned int v4 = *a3;
  unsigned int v5 = **a3;
  if (v5 != **a4
    || ((v6 = result, unsigned int v7 = *(_DWORD *)(result + 84), (*(unsigned char *)(result + 68) & 0x20) != 0) ? (v8 = 1) : (v8 = v7),
        v8 * v5 != v7))
  {
    std::terminate();
  }
  if (v5)
  {
    unint64_t v12 = 0;
    int v13 = 0;
    do
    {
      if (v8)
      {
        uint64_t v14 = 0;
        uint64_t v15 = *(void *)&v4[4 * v12 + 4];
        uint64_t v16 = *(void *)&(*a4)[4 * v12 + 4];
        do
        {
          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v6 + 176))(v6, a2, (v13 + v14++), v15, v8, v16, v8);
          v16 += 4;
          v15 += 4;
        }
        while (v8 != v14);
        v13 += v14;
        unsigned int v4 = *a3;
        unsigned int v5 = **a3;
      }
      ++v12;
    }
    while (v12 < v5);
  }
  return result;
}

uint64_t acv2::NoiseShapingDitherConverter::Reset(acv2::NoiseShapingDitherConverter *this)
{
  uint64_t v2 = (void *)*((void *)this + 22);
  uint64_t v3 = *((void *)this + 23) - (void)v2;
  if (v3 >= 1) {
    bzero(v2, 4 * (((unint64_t)v3 >> 2) - ((unint64_t)v3 > 3)) + 4);
  }
  unsigned int v4 = (void *)*((void *)this + 24);
  uint64_t v5 = *((void *)this + 25) - (void)v4;
  if (v5 >= 1) {
    bzero(v4, 32 * (((unint64_t)v5 >> 5) - ((unint64_t)v5 > 0x1F)) + 32);
  }
  return 0;
}

__CFString *acv2::NoiseShapingDitherConverter::ConverterName(acv2::NoiseShapingDitherConverter *this)
{
  return @"NoiseShapingDitherConverter";
}

void acv2::NoiseShapingDitherConverter::~NoiseShapingDitherConverter(acv2::NoiseShapingDitherConverter *this)
{
  acv2::NoiseShapingDitherConverter::~NoiseShapingDitherConverter(this);
  JUMPOUT(0x192FC8940);
}

{
  unsigned char *v2;
  void *v3;
  unsigned char *v4;
  unsigned char *v5;
  unsigned char *v6;
  uint64_t vars8;

  *(void *)this = &unk_1EDF96090;
  uint64_t v3 = (void *)((char *)this + 192);
  uint64_t v2 = (unsigned char *)*((void *)this + 24);
  if (v2)
  {
    unsigned int v4 = (unsigned char *)*((void *)this + 25);
    if (v4 != v2) {
      *((void *)this + 25) = &v4[(v2 - v4 + 31) & 0xFFFFFFFFFFFFFFE0];
    }
    operator delete(v2);
    *uint64_t v3 = 0;
    v3[1] = 0;
  }
  uint64_t v5 = (unsigned char *)*((void *)this + 22);
  if (v5)
  {
    uint64_t v6 = (unsigned char *)*((void *)this + 23);
    if (v6 != v5) {
      *((void *)this + 23) = &v6[(v5 - v6 + 3) & 0xFFFFFFFFFFFFFFFCLL];
    }
    operator delete(v5);
    *((void *)this + 22) = 0;
    *((void *)this + 23) = 0;
  }
  acv2::AudioConverterBase::~AudioConverterBase(this);
}

void acv2::UV22DitherConverter::ConvertBufferList(uint64_t a1, int a2, void *a3, _DWORD **a4)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(unsigned int *)*a3;
  if (v4 != **a4)
  {
    if (!os_log_type_enabled(0, OS_LOG_TYPE_ERROR)) {
      goto LABEL_23;
    }
    *(_DWORD *)int buf = 136315394;
    uint64_t v22 = "DitherConverter.cpp";
    __int16 v23 = 1024;
    int v24 = 377;
    int v20 = "%25s:%-5d ASSERTION FAILURE [(inBufferList.size() == outBufferList.size()) != 0 is false]: ";
    goto LABEL_22;
  }
  unsigned int v6 = *(_DWORD *)(a1 + 84);
  if ((*(unsigned char *)(a1 + 68) & 0x20) != 0) {
    uint64_t v7 = 1;
  }
  else {
    uint64_t v7 = v6;
  }
  if (v7 * v4 != v6)
  {
    if (!os_log_type_enabled(0, OS_LOG_TYPE_ERROR)) {
      goto LABEL_23;
    }
    *(_DWORD *)int buf = 136315394;
    uint64_t v22 = "DitherConverter.cpp";
    __int16 v23 = 1024;
    int v24 = 383;
    int v20 = "%25s:%-5d ASSERTION FAILURE [(numChannels == OutputFormat().mChannelsPerFrame) != 0 is false]: ";
LABEL_22:
    _os_log_impl(&dword_18FEC0000, 0, OS_LOG_TYPE_ERROR, v20, buf, 0x12u);
LABEL_23:
    __break(1u);
  }
  if (v4)
  {
    for (uint64_t i = 0; i != v4; ++i)
    {
      uint64_t v12 = *(void *)(*a3 + 16 * i + 16);
      uint64_t v13 = *(void *)&(*a4)[4 * i + 4];
      if (*(unsigned char *)(a1 + 28))
      {
        if (v7)
        {
          acv2::UV22DitherConverter::ConvertChannel<float,float>((_DWORD *)a1, *(float **)(*a3 + 16 * i + 16), v7, *(float **)&(*a4)[4 * i + 4], v7, a2);
          uint64_t v17 = (float *)(v12 + 4);
          int8x16_t v18 = (float *)(v13 + 4);
          uint64_t v19 = v7 - 1;
          if (v7 != 1)
          {
            do
            {
              acv2::UV22DitherConverter::ConvertChannel<float,float>((_DWORD *)a1, v17++, v7, v18++, v7, a2);
              --v19;
            }
            while (v19);
          }
        }
      }
      else if (v7)
      {
        acv2::UV22DitherConverter::ConvertChannel<int,short>((_DWORD *)a1, *(_DWORD **)(*a3 + 16 * i + 16), v7, *(_WORD **)&(*a4)[4 * i + 4], v7, a2);
        uint64_t v14 = (_DWORD *)(v12 + 4);
        uint64_t v15 = (_WORD *)(v13 + 2);
        uint64_t v16 = v7 - 1;
        if (v7 != 1)
        {
          do
          {
            acv2::UV22DitherConverter::ConvertChannel<int,short>((_DWORD *)a1, v14++, v7, v15++, v7, a2);
            --v16;
          }
          while (v16);
        }
      }
    }
  }
}

void acv2::UV22DitherConverter::ConvertChannel<float,float>(_DWORD *a1, float *a2, unsigned int a3, float *a4, unsigned int a5, int a6)
{
  float v12 = scalbnf(1.0, a1[47] - a1[44] - 7);
  if (a6)
  {
    int v13 = a1[43];
    int v14 = a1[46];
    uint64_t v15 = (int)a1[45];
    unsigned int v16 = v13 + acv2::UV22DitherConverter::m_pcDriverTable[v15];
    if (v16 <= 7) {
      unsigned int v17 = v13 + acv2::UV22DitherConverter::m_pcDriverTable[v15];
    }
    else {
      unsigned int v17 = v16 - 8;
    }
    do
    {
      *a4 = *a2
          + (float)(v12
                  * (float)((float)(char)acv2::UV22DitherConverter::m_pcDitherSequence[4096 * (unint64_t)v17
                                                                                     + v14]
                          + 0.5));
      if (v14 + 1 < 4096)
      {
        ++v14;
      }
      else
      {
        v14 -= 4095;
        if (v15 == 2047) {
          LODWORD(v15) = 0;
        }
        else {
          LODWORD(v15) = v15 + 1;
        }
        a1[45] = v15;
        unsigned int v17 = v13 + acv2::UV22DitherConverter::m_pcDriverTable[(int)v15];
        if (v17 > 7) {
          v17 -= 8;
        }
      }
      a2 += a3;
      a4 += a5;
      --a6;
    }
    while (a6);
    a1[46] = v14;
  }
}

_DWORD *acv2::UV22DitherConverter::ConvertChannel<int,short>(_DWORD *result, _DWORD *a2, unsigned int a3, _WORD *a4, unsigned int a5, int a6)
{
  if (a6)
  {
    int v6 = result[46];
    int v7 = result[47] - 8;
    int v8 = result[43];
    int v9 = result[44];
    char v10 = v7 + v9;
    int v11 = (1 << (v7 + v9 - 1)) + (1 << (v9 - 1));
    uint64_t v12 = (int)result[45];
    unsigned int v13 = v8 + acv2::UV22DitherConverter::m_pcDriverTable[v12];
    if (v13 <= 7) {
      unsigned int v14 = v8 + acv2::UV22DitherConverter::m_pcDriverTable[v12];
    }
    else {
      unsigned int v14 = v13 - 8;
    }
    uint64_t v15 = 4 * a3;
    do
    {
      int v16 = v11
          + *a2
          + ((acv2::UV22DitherConverter::m_pcDitherSequence[4096 * (unint64_t)v14 + v6] - 128) << v10);
      if (v16 < 0)
      {
        if (HIBYTE(v16) == 255)
        {
LABEL_11:
          int v17 = v16 >> 9;
          goto LABEL_12;
        }
        LOWORD(v17) = 0x8000;
      }
      else
      {
        if (!HIBYTE(v16)) {
          goto LABEL_11;
        }
        LOWORD(v17) = 0x7FFF;
      }
LABEL_12:
      *a4 = v17;
      int v18 = v6 + 1;
      result[46] = v6 + 1;
      if (v6 + 1 >= 4096)
      {
        int v18 = v6 - 4095;
        if (v12 == 2047) {
          LODWORD(v12) = 0;
        }
        else {
          LODWORD(v12) = v12 + 1;
        }
        result[45] = v12;
        result[46] = v18;
        unsigned int v14 = v8 + acv2::UV22DitherConverter::m_pcDriverTable[(int)v12];
        if (v14 > 7) {
          v14 -= 8;
        }
      }
      a2 = (_DWORD *)((char *)a2 + v15);
      a4 += a5;
      int v6 = v18;
      --a6;
    }
    while (a6);
  }
  return result;
}

uint64_t acv2::UV22DitherConverter::Reset(acv2::UV22DitherConverter *this)
{
  *((_DWORD *)this + 46) = 0;
  *((_DWORD *)this + 47) = 3;
  *((_DWORD *)this + 43) = 0;
  *((_DWORD *)this + 45) = 0;
  return 0;
}

__CFString *acv2::UV22DitherConverter::ConverterName(acv2::UV22DitherConverter *this)
{
  return @"UV22DitherConverter";
}

void acv2::UV22DitherConverter::~UV22DitherConverter(acv2::UV22DitherConverter *this)
{
  acv2::AudioConverterBase::~AudioConverterBase(this);
  JUMPOUT(0x192FC8940);
}

uint64_t _ZNSt3__18valarrayIDv8_fED1Ev(uint64_t a1)
{
  uint64_t v2 = *(unsigned char **)a1;
  if (v2)
  {
    uint64_t v3 = *(unsigned char **)(a1 + 8);
    if (v3 != v2) {
      *(void *)(a1 + 8) = &v3[(v2 - v3 + 31) & 0xFFFFFFFFFFFFFFE0];
    }
    operator delete(v2);
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
  }
  return a1;
}

uint64_t std::valarray<float>::~valarray(uint64_t a1)
{
  uint64_t v2 = *(unsigned char **)a1;
  if (v2)
  {
    uint64_t v3 = *(unsigned char **)(a1 + 8);
    if (v3 != v2) {
      *(void *)(a1 + 8) = &v3[(v2 - v3 + 3) & 0xFFFFFFFFFFFFFFFCLL];
    }
    operator delete(v2);
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
  }
  return a1;
}

uint64_t MP4BoxParser_SyncSampleTable::Init(MP4BoxParser **this)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = MP4BoxParser_Full::Initialize((MP4BoxParser_Full *)this);
  if (!v2)
  {
    if (*((_DWORD *)this + 5) != 1937011571) {
      return 4294967294;
    }
    unsigned int v3 = (*((uint64_t (**)(MP4BoxParser **))*this + 3))(this);
    unsigned int v11 = 0;
    unint64_t v4 = (unint64_t)this[3];
    if (v4 <= (*((unsigned int (**)(MP4BoxParser **))*this + 3))(this) || (unint64_t)this[3] <= 3)
    {
      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
LABEL_8:
        uint64_t v2 = 0;
        *((unsigned char *)this + 60) = 0;
        return v2;
      }
      *(_DWORD *)int buf = 136315394;
      unsigned int v13 = "MP4_BoxParser_SyncSampleTable.cpp";
      __int16 v14 = 1024;
      int v15 = 105;
      uint64_t v5 = MEMORY[0x1E4F14500];
      int v6 = "%25s:%-5d  'stss' box is too small for its entry count";
LABEL_7:
      _os_log_impl(&dword_18FEC0000, v5, OS_LOG_TYPE_ERROR, v6, buf, 0x12u);
      goto LABEL_8;
    }
    uint64_t v8 = MP4BoxParser::ReadDataSourceBytes(this[1], v3, 4uLL, &v11);
    if (!v8)
    {
      unsigned int v9 = bswap32(v11);
      *((_DWORD *)this + 16) = v9;
      this[9] = (MP4BoxParser *)4;
      unint64_t v10 = (unint64_t)this[3];
      if (v10 > (*((unsigned int (**)(MP4BoxParser **))*this + 3))(this)
        && (unint64_t)this[3] >= 4 * (unint64_t)v9 + 4)
      {
        uint64_t v2 = 0;
        *((unsigned char *)this + 60) = 1;
        return v2;
      }
      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
        goto LABEL_8;
      }
      *(_DWORD *)int buf = 136315394;
      unsigned int v13 = "MP4_BoxParser_SyncSampleTable.cpp";
      __int16 v14 = 1024;
      int v15 = 116;
      uint64_t v5 = MEMORY[0x1E4F14500];
      int v6 = "%25s:%-5d  'stss' box is too small for its entries";
      goto LABEL_7;
    }
    uint64_t v2 = v8;
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136315394;
      unsigned int v13 = "MP4_BoxParser_SyncSampleTable.cpp";
      __int16 v14 = 1024;
      int v15 = 108;
      _os_log_impl(&dword_18FEC0000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%25s:%-5d  Couldn't read sync sample box entry count", buf, 0x12u);
    }
  }
  return v2;
}

void MP4BoxParser_SyncSampleTable::~MP4BoxParser_SyncSampleTable(MP4BoxParser_SyncSampleTable *this)
{
  MP4BoxParser_SyncSampleTable::~MP4BoxParser_SyncSampleTable(this);
  JUMPOUT(0x192FC8940);
}

{
  void *v2;
  uint64_t v3;

  *(void *)this = &unk_1EDF943B0;
  uint64_t v2 = (void *)*((void *)this + 11);
  if (v2)
  {
    *((void *)this + 12) = v2;
    operator delete(v2);
  }
  unsigned int v3 = *((void *)this + 1);
  *(void *)this = &unk_1EDF8DA18;
  *((void *)this + 1) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
}

void MP4BoxParser_SyncSampleTable::MP4BoxParser_SyncSampleTable(MP4BoxParser_SyncSampleTable *this, DataSource *a2, uint64_t a3)
{
  *(void *)this = &unk_1EDF8DA18;
  (*(void (**)(DataSource *, uint64_t))(*(void *)a2 + 88))(a2, a3);
  *((unsigned char *)this + 16) = 0;
  *((_DWORD *)this + 5) = 0;
  *((void *)this + 3) = 0;
  *((unsigned char *)this + 32) = 0;
  *((_DWORD *)this + 9) = 8;
  *(void *)this = &unk_1EDF943B0;
  *((unsigned char *)this + 60) = 0;
  *((_DWORD *)this + 16) = 0;
  *((void *)this + 9) = 0;
  *((unsigned char *)this + 80) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 13) = 0;
  *((void *)this + 11) = 0;
}

uint64_t MP4BoxParser_SyncSampleTable::GetSyncSampleTable(MP4BoxParser_SyncSampleTable *this, SyncSampleTable *a2)
{
  uint64_t v2 = a2;
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = (MP4BoxParser_SyncSampleTable *)((char *)this + 80);
  char v4 = *((unsigned char *)this + 80);
  if (*((unsigned char *)this + 60))
  {
    if (*((unsigned char *)this + 80))
    {
      char v4 = 1;
    }
    else
    {
      unsigned int v6 = *((_DWORD *)this + 16);
      if (v6)
      {
        memset(v37, 0, sizeof(v37));
        if (v6 >= 0x2000) {
          int v7 = 0x2000;
        }
        else {
          int v7 = v6;
        }
        uint64_t v8 = *((void *)this + 9);
        buf[0] = 0;
        unsigned int v35 = v7;
        std::vector<unsigned char>::__append(v37, (4 * v7), buf);
        unsigned int v9 = (char *)v37[0];
        while (1)
        {
          unsigned int v10 = v6 >= v35 ? v35 : v6;
          unsigned int v11 = (*(uint64_t (**)(MP4BoxParser_SyncSampleTable *))(*(void *)this + 24))(this);
          uint64_t DataSourceBytes = MP4BoxParser::ReadDataSourceBytes(*((MP4BoxParser **)this + 1), v8 + v11, 4 * v10, v9);
          if (DataSourceBytes) {
            break;
          }
          uint64_t v13 = 0;
          if (v10 <= 1) {
            unsigned int v14 = 1;
          }
          else {
            unsigned int v14 = v10;
          }
          uint64_t v15 = 4 * v14;
          do
          {
            uint64_t v36 = bswap32(*(_DWORD *)&v9[v13]) - 1;
            SyncSampleTable::append_entry((uint64_t)v5, &v36);
            v13 += 4;
          }
          while (v15 != v13);
          v8 += 4 * v10;
          v6 -= v10;
          if (!v6)
          {
            operator delete(v9);
            uint64_t v2 = a2;
            goto LABEL_20;
          }
        }
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)int buf = 136315394;
          unsigned int v39 = "MP4_BoxParser_SyncSampleTable.cpp";
          __int16 v40 = 1024;
          int v41 = 72;
          _os_log_impl(&dword_18FEC0000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%25s:%-5d  Couldn't read sync sample entries", buf, 0x12u);
        }
        if (v9) {
          operator delete(v9);
        }
        return DataSourceBytes;
      }
LABEL_20:
      char v4 = 1;
      *(unsigned char *)uint64_t v5 = 1;
    }
  }
  *(unsigned char *)uint64_t v2 = v4;
  if (v5 != v2)
  {
    uint64_t v16 = (char *)*((void *)v2 + 1);
    int v17 = (char *)*((void *)this + 11);
    int v18 = (unsigned char *)*((void *)this + 12);
    size_t v19 = v18 - v17;
    unint64_t v20 = (v18 - v17) >> 3;
    uint64_t v21 = *((void *)v2 + 3);
    if (v20 <= (v21 - (uint64_t)v16) >> 3)
    {
      float32x4_t v27 = (char *)*((void *)v2 + 2);
      int v24 = (void **)((char *)v2 + 16);
      int8x16_t v26 = v27;
      size_t v28 = v27 - v16;
      unint64_t v29 = (v27 - v16) >> 3;
      if (v29 < v20)
      {
        int v30 = &v17[8 * v29];
        if (v26 != v16)
        {
          memmove(v16, v17, v28);
          uint64_t v16 = (char *)*v24;
        }
        size_t v19 = v18 - v30;
        if (v18 == v30) {
          goto LABEL_41;
        }
        unsigned int v31 = v16;
        unsigned int v32 = v30;
        goto LABEL_40;
      }
    }
    else
    {
      if (v16)
      {
        *((void *)v2 + 2) = v16;
        operator delete(v16);
        uint64_t v21 = 0;
        *((void *)v2 + 1) = 0;
        *((void *)v2 + 2) = 0;
        *((void *)v2 + 3) = 0;
      }
      if ((v19 & 0x8000000000000000) != 0) {
        std::vector<float>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v22 = v21 >> 2;
      if (v21 >> 2 <= v20) {
        uint64_t v22 = (v18 - v17) >> 3;
      }
      if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v23 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v23 = v22;
      }
      std::vector<double>::__vallocate[abi:ne180100]((void *)v2 + 1, v23);
      uint64_t v25 = (char *)*((void *)v2 + 2);
      int v24 = (void **)((char *)v2 + 16);
      uint64_t v16 = v25;
    }
    if (v18 == v17)
    {
LABEL_41:
      uint64_t DataSourceBytes = 0;
      *int v24 = &v16[v19];
      return DataSourceBytes;
    }
    unsigned int v31 = v16;
    unsigned int v32 = v17;
LABEL_40:
    memmove(v31, v32, v19);
    goto LABEL_41;
  }
  return 0;
}

void sub_19018CF44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_19018D684(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26)
{
  if (a26) {
    free(a26);
  }

  _Unwind_Resume(a1);
}

void ___ZN27AudioComponentRegistrarImpl16getComponentListER14ConnectionInfoP8NSStringbbU13block_pointerFvP6NSDatabS5_P7NSArrayE_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 56);
  atomic_store(1u, (unsigned __int8 *)(v1 + 2));
  AudioComponentRegistrarImpl::replyWithComponentList(v1, *(unsigned __int8 *)(a1 + 64), *(void **)(a1 + 32), *(void **)(a1 + 40), *(void **)(a1 + 48));
}

void *std::default_delete<caulk::synchronized<AUExtensionScanner,caulk::mach::unfair_lock,caulk::empty_atomic_interface<AUExtensionScanner>>>::operator()[abi:ne180100](void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = result[17];
    if (v2)
    {
      uint64_t v3 = result[18];
      char v4 = (void *)result[17];
      if (v3 != v2)
      {
        do
        {
          v3 -= 32;
          std::__destroy_at[abi:ne180100]<AUExtensionScanner::ExtensionComponents,0>(v3);
        }
        while (v3 != v2);
        char v4 = (void *)v1[17];
      }
      v1[18] = v2;
      operator delete(v4);
    }
    for (uint64_t i = 0; i != -9; i -= 3)
    {
    }
    std::__function::__value_func<void ()(AudioComponentVector const&,AudioComponentVector&)>::~__value_func[abi:ne180100](v1 + 4);
    unsigned int v6 = (std::__shared_weak_count *)v1[3];
    if (v6) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v6);
    }
    JUMPOUT(0x192FC8940);
  }
  return result;
}

void ___ZN27AudioComponentRegistrarImpl21_initialExtensionScanEU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  v43[1] = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 40);
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)(v1 + 2));
  if ((v2 & 1) == 0)
  {
    uint64_t v20 = *(void *)(a1 + 40);
    uint64_t v3 = *(void *)(v1 + 256);
    os_unfair_lock_lock((os_unfair_lock_t)v3);
    char v4 = (NSArray *)(v3 + 8);
    uint64_t v22 = *(void *)(v3 + 8);
    memset(&v26, 0, 24);
    v26.mSorted = 1;
    locuint64_t k = (os_unfair_lock_s *)v3;
    double Current = CFAbsoluteTimeGetCurrent();
    uint64_t v6 = 0;
    uint64_t v23 = *MEMORY[0x1E4F282B0];
    uint64_t v7 = v3 + 64;
    do
    {
      uint64_t v8 = [&unk_1EDFB2E30 objectAtIndexedSubscript:v6];
      uint64_t v42 = v23;
      v43[0] = v8;
      unsigned int v9 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v43 forKeys:&v42 count:1];
      *(void *)unsigned int v39 = 0;
      *(void *)&v39[8] = v39;
      *(void *)&v39[16] = 0x3032000000;
      *(void *)&v39[24] = __Block_byref_object_copy__7673;
      __int16 v40 = __Block_byref_object_dispose__7674;
      id v41 = 0;
      float32x4_t v27 = (AudioComponentVector *)MEMORY[0x1E4F143A8];
      uint64_t v28 = 3221225472;
      unint64_t v29 = ___ZN18AUExtensionScanner11initialScanEv_block_invoke;
      int v30 = &unk_1E5687D70;
      unsigned int v34 = v4;
      id v10 = v9;
      uint64_t v35 = v7;
      id v31 = v10;
      int v33 = v39;
      id v11 = v8;
      id v32 = v11;
      uint64_t v36 = v22;
      if (!Synchronously((uint64_t)&v27))
      {
        if (!gAudioComponentLogCategory) {
          operator new();
        }
        uint64_t v12 = *(id *)gAudioComponentLogCategory;
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          LODWORD(buf.__begin_) = 136315394;
          *(void **)((char *)&buf.__begin_ + 4) = "AUExtensionScanner.mm";
          WORD2(buf.__end_) = 1024;
          *(_DWORD *)((char *)&buf.__end_ + 6) = 164;
          _os_log_impl(&dword_18FEC0000, v12, OS_LOG_TYPE_ERROR, "%25s:%-5d Timeout running task synchronously", (uint8_t *)&buf, 0x12u);
        }
      }
      AUExtensionScanner::addExtensions(&buf, v4, *(void **)(*(void *)&v39[8] + 40));
      AudioComponentVector::append(&v26, (const AudioComponentVector *)buf.__begin_, (const AudioComponentVector *)buf.__end_);
      p_AudioComponentVector buf = &buf;
      std::vector<std::shared_ptr<CA::ADMPackFormat>>::__destroy_vector::operator()[abi:ne180100]((void ***)&p_buf);

      _Block_object_dispose(v39, 8);
      ++v6;
      v7 += 24;
    }
    while (v6 != 3);
    double v14 = CFAbsoluteTimeGetCurrent();
    if (!gAudioComponentLogCategory) {
      operator new();
    }
    uint64_t v15 = *(id *)gAudioComponentLogCategory;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)unsigned int v39 = 136315650;
      *(void *)&v39[4] = "AUExtensionScanner.mm";
      *(_WORD *)&v39[12] = 1024;
      *(_DWORD *)&v39[14] = 171;
      *(_WORD *)&v39[18] = 2048;
      *(double *)&v39[20] = v14 - Current;
      _os_log_impl(&dword_18FEC0000, v15, OS_LOG_TYPE_INFO, "%25s:%-5d %.6fs", v39, 0x1Cu);
    }
    if (lock) {
      os_unfair_lock_unlock(lock);
    }
    float32x4_t v27 = 0;
    uint64_t v28 = 0;
    unint64_t v29 = 0;
    LOBYTE(v30) = 1;
    uint64_t v17 = *(void *)(v20 + 40);
    if (!v17) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    (*(void (**)(uint64_t, AudioComponentVector *, AudioComponentVector **))(*(void *)v17 + 48))(v17, &v26, &v27);
    *(void *)unsigned int v39 = &v27;
    std::vector<std::shared_ptr<CA::ADMPackFormat>>::__destroy_vector::operator()[abi:ne180100]((void ***)v39);
    float32x4_t v27 = &v26;
    std::vector<std::shared_ptr<CA::ADMPackFormat>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v27);
    uint64_t v1 = v20;
  }
  int v18 = [*(id *)(v1 + 80) _queue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZN27AudioComponentRegistrarImpl21_initialExtensionScanEU13block_pointerFvvE_block_invoke_2;
  block[3] = &unk_1E5688B08;
  id v25 = *(id *)(a1 + 32);
  dispatch_sync(v18, block);
}

void sub_19018DCF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_unfair_lock_t lock, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  *(void *)(v37 - 208) = &a22;
  std::vector<std::shared_ptr<CA::ADMPackFormat>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v37 - 208));
  if (lock) {
    os_unfair_lock_unlock(lock);
  }
  _Unwind_Resume(a1);
}

uint64_t ___ZN27AudioComponentRegistrarImpl21_initialExtensionScanEU13block_pointerFvvE_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void *std::__shared_ptr_pointer<caulk::synchronized<AUExtensionScanner,caulk::mach::unfair_lock,caulk::empty_atomic_interface<AUExtensionScanner>> *>::__on_zero_shared(uint64_t a1)
{
  return std::default_delete<caulk::synchronized<AUExtensionScanner,caulk::mach::unfair_lock,caulk::empty_atomic_interface<AUExtensionScanner>>>::operator()[abi:ne180100](*(void **)(a1 + 24));
}

void std::__shared_ptr_pointer<caulk::synchronized<AUExtensionScanner,caulk::mach::unfair_lock,caulk::empty_atomic_interface<AUExtensionScanner>> *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x192FC8940);
}

void sub_19018DFB0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_19018E068(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_19018E12C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v13 = v12;

  _Unwind_Resume(a1);
}

void sub_19018E240(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v13 = v12;

  _Unwind_Resume(a1);
}

void localUIImagePNGRepresentation(UIImage *a1)
{
  uint64_t v1 = a1;
  uint64_t v8 = 0;
  unsigned int v9 = &v8;
  uint64_t v10 = 0x2020000000;
  unsigned __int8 v2 = (void (*)(UIImage *))getUIImagePNGRepresentationSymbolLoc(void)::ptr;
  id v11 = getUIImagePNGRepresentationSymbolLoc(void)::ptr;
  if (!getUIImagePNGRepresentationSymbolLoc(void)::ptr)
  {
    uint64_t v3 = UIKitLibrary();
    void v9[3] = (uint64_t)dlsym(v3, "UIImagePNGRepresentation");
    getUIImagePNGRepresentationSymbolLoc(void)::ptr = (_UNKNOWN *)v9[3];
    unsigned __int8 v2 = (void (*)(UIImage *))v9[3];
  }
  _Block_object_dispose(&v8, 8);
  if (v2)
  {
    char v4 = v2(v1);

    id v5 = v4;
  }
  else
  {
    uint64_t v6 = [MEMORY[0x1E4F28B00] currentHandler];
    uint64_t v7 = [NSString stringWithUTF8String:"NSData *localUIImagePNGRepresentation(UIImage *__strong)"];
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, @"AudioComponentRegistrar.mm", 624, @"%s", dlerror());

    __break(1u);
  }
}

void sub_19018E3E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

void *___ZL36getUIImagePNGRepresentationSymbolLocv_block_invoke(uint64_t a1)
{
  unsigned __int8 v2 = UIKitLibrary();
  uint64_t result = dlsym(v2, "UIImagePNGRepresentation");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getUIImagePNGRepresentationSymbolLoc(void)::ptr = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *UIKitLibrary(void)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v4[0] = 0;
  if (!UIKitLibraryCore(char **)::frameworkLibrary)
  {
    v4[1] = (void *)MEMORY[0x1E4F143A8];
    v4[2] = (void *)3221225472;
    v4[3] = ___ZL16UIKitLibraryCorePPc_block_invoke;
    v4[4] = &__block_descriptor_40_e5_v8__0l;
    v4[5] = v4;
    long long v5 = xmmword_1E5688BD8;
    uint64_t v6 = 0;
    UIKitLibraryCore(char **)::frameworkLibrary = _sl_dlopen();
  }
  uint64_t v0 = (void *)UIKitLibraryCore(char **)::frameworkLibrary;
  if (!UIKitLibraryCore(char **)::frameworkLibrary)
  {
    uint64_t v0 = [MEMORY[0x1E4F28B00] currentHandler];
    uint64_t v3 = [NSString stringWithUTF8String:"void *UIKitLibrary()"];
    objc_msgSend(v0, "handleFailureInFunction:file:lineNumber:description:", v3, @"AudioComponentRegistrar.mm", 620, @"%s", v4[0]);

    __break(1u);
    goto LABEL_7;
  }
  uint64_t v1 = v4[0];
  if (v4[0]) {
LABEL_7:
  }
    free(v1);
  return v0;
}

void sub_19018E5D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, _Unwind_Exception *exception_object)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL16UIKitLibraryCorePPc_block_invoke()
{
  uint64_t result = _sl_dlopen();
  UIKitLibraryCore(char **)::frameworkLibrary = result;
  return result;
}

void sub_19018E9E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

id getISImageDescriptorClass(void)
{
  uint64_t v4 = 0;
  long long v5 = &v4;
  uint64_t v6 = 0x2050000000;
  uint64_t v0 = (void *)getISImageDescriptorClass(void)::softClass;
  uint64_t v7 = getISImageDescriptorClass(void)::softClass;
  if (!getISImageDescriptorClass(void)::softClass)
  {
    v3[0] = MEMORY[0x1E4F143A8];
    v3[1] = 3221225472;
    v3[2] = ___ZL25getISImageDescriptorClassv_block_invoke;
    v3[3] = &unk_1E5688B80;
    v3[4] = &v4;
    ___ZL25getISImageDescriptorClassv_block_invoke((uint64_t)v3);
    uint64_t v0 = (void *)v5[3];
  }
  id v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_19018EB7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *___ZL40getkISImageDescriptorHomeScreenSymbolLocv_block_invoke(uint64_t a1)
{
  unsigned __int8 v2 = IconServicesLibrary();
  uint64_t result = dlsym(v2, "kISImageDescriptorHomeScreen");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkISImageDescriptorHomeScreenSymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *IconServicesLibrary(void)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v4[0] = 0;
  if (!IconServicesLibraryCore(char **)::frameworkLibrary)
  {
    v4[1] = (void *)MEMORY[0x1E4F143A8];
    v4[2] = (void *)3221225472;
    v4[3] = ___ZL23IconServicesLibraryCorePPc_block_invoke;
    v4[4] = &__block_descriptor_40_e5_v8__0l;
    v4[5] = v4;
    long long v5 = xmmword_1E5688BA0;
    uint64_t v6 = 0;
    IconServicesLibraryCore(char **)::frameworkLibrary = _sl_dlopen();
  }
  uint64_t v0 = (void *)IconServicesLibraryCore(char **)::frameworkLibrary;
  if (!IconServicesLibraryCore(char **)::frameworkLibrary)
  {
    uint64_t v0 = [MEMORY[0x1E4F28B00] currentHandler];
    uint64_t v3 = [NSString stringWithUTF8String:"void *IconServicesLibrary()"];
    objc_msgSend(v0, "handleFailureInFunction:file:lineNumber:description:", v3, @"AudioComponentRegistrar.mm", 626, @"%s", v4[0]);

    __break(1u);
    goto LABEL_7;
  }
  id v1 = v4[0];
  if (v4[0]) {
LABEL_7:
  }
    free(v1);
  return v0;
}

void sub_19018ED40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, _Unwind_Exception *exception_object)
{
  _Unwind_Resume(a1);
}

void ___ZL16getUIScreenClassv_block_invoke(uint64_t a1)
{
  UIKitLibrary();
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = objc_getClass("UIScreen");
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    getUIScreenClass(void)::softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    unsigned __int8 v2 = [MEMORY[0x1E4F28B00] currentHandler];
    uint64_t v3 = [NSString stringWithUTF8String:"Class getUIScreenClass()_block_invoke"];
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, @"AudioComponentRegistrar.mm", 622, @"Unable to find class %s", "UIScreen");

    __break(1u);
  }
}

void sub_19018EE2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id getISIconClass(void)
{
  uint64_t v4 = 0;
  long long v5 = &v4;
  uint64_t v6 = 0x2050000000;
  uint64_t v0 = (void *)getISIconClass(void)::softClass;
  uint64_t v7 = getISIconClass(void)::softClass;
  if (!getISIconClass(void)::softClass)
  {
    v3[0] = MEMORY[0x1E4F143A8];
    v3[1] = 3221225472;
    v3[2] = ___ZL14getISIconClassv_block_invoke;
    v3[3] = &unk_1E5688B80;
    v3[4] = &v4;
    ___ZL14getISIconClassv_block_invoke((uint64_t)v3);
    uint64_t v0 = (void *)v5[3];
  }
  id v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_19018EF14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id getUIImageClass(void)
{
  uint64_t v4 = 0;
  long long v5 = &v4;
  uint64_t v6 = 0x2050000000;
  uint64_t v0 = (void *)getUIImageClass(void)::softClass;
  uint64_t v7 = getUIImageClass(void)::softClass;
  if (!getUIImageClass(void)::softClass)
  {
    v3[0] = MEMORY[0x1E4F143A8];
    v3[1] = 3221225472;
    v3[2] = ___ZL15getUIImageClassv_block_invoke;
    v3[3] = &unk_1E5688B80;
    v3[4] = &v4;
    ___ZL15getUIImageClassv_block_invoke((uint64_t)v3);
    uint64_t v0 = (void *)v5[3];
  }
  id v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_19018EFF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ___ZL15getUIImageClassv_block_invoke(uint64_t a1)
{
  UIKitLibrary();
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = objc_getClass("UIImage");
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    getUIImageClass(void)::softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    unsigned __int8 v2 = [MEMORY[0x1E4F28B00] currentHandler];
    uint64_t v3 = [NSString stringWithUTF8String:"Class getUIImageClass()_block_invoke"];
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, @"AudioComponentRegistrar.mm", 621, @"Unable to find class %s", "UIImage");

    __break(1u);
  }
}

void sub_19018F0D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL14getISIconClassv_block_invoke(uint64_t a1)
{
  IconServicesLibrary();
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = objc_getClass("ISIcon");
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    getISIconClass(void)::softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    unsigned __int8 v2 = [MEMORY[0x1E4F28B00] currentHandler];
    uint64_t v3 = [NSString stringWithUTF8String:"Class getISIconClass()_block_invoke"];
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, @"AudioComponentRegistrar.mm", 627, @"Unable to find class %s", "ISIcon");

    __break(1u);
  }
}

void sub_19018F1BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL23IconServicesLibraryCorePPc_block_invoke()
{
  uint64_t result = _sl_dlopen();
  IconServicesLibraryCore(char **)::frameworkLibrary = result;
  return result;
}

void ___ZL25getISImageDescriptorClassv_block_invoke(uint64_t a1)
{
  IconServicesLibrary();
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = objc_getClass("ISImageDescriptor");
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    getISImageDescriptorClass(void)::softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    unsigned __int8 v2 = [MEMORY[0x1E4F28B00] currentHandler];
    uint64_t v3 = [NSString stringWithUTF8String:"Class getISImageDescriptorClass()_block_invoke"];
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, @"AudioComponentRegistrar.mm", 629, @"Unable to find class %s", "ISImageDescriptor");

    __break(1u);
  }
}

void sub_19018F314(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_19018F470(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_19018F5F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_19018F8A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, id a13)
{
  _Unwind_Resume(a1);
}

void sub_19018FA00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v12 = v11;
  os_unfair_lock_unlock(v12);

  _Unwind_Resume(a1);
}

void sub_19018FCC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, void **a19)
{
  float32x4_t v27 = *(std::__shared_weak_count **)(v25 - 96);
  if (v27) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v27);
  }
  if (v24) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v24);
  }

  os_unfair_lock_unlock(v22);
  a19 = (void **)&a11;
  std::vector<std::shared_ptr<CA::ADMPackFormat>>::__destroy_vector::operator()[abi:ne180100](&a19);
  a19 = (void **)&a15;
  std::vector<std::shared_ptr<CA::ADMPackFormat>>::__destroy_vector::operator()[abi:ne180100](&a19);

  _Unwind_Resume(a1);
}

void AudioComponentRegistrarImpl::addRemoveComponents(AudioComponentRegistrarImpl *this, const AudioComponentVector *a2, AudioComponentVector *a3)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  if (a2->__begin_ != a2->__end_ || a3->__begin_ != a3->__end_)
  {
    uint64_t v4 = (uint64_t *)((char *)this + 136);
    AudioComponentVector::subtract(&buf, (AudioComponentVector *)((char *)this + 136), a3);
    std::vector<std::shared_ptr<APComponent>>::__vdeallocate(v4);
    *(_OWORD *)uint64_t v4 = *(_OWORD *)&buf.__begin_;
    *((void *)this + 19) = buf.__end_cap_.__value_;
    memset(&buf, 0, 24);
    *((unsigned char *)this + 160) = buf.mSorted;
    p_AudioComponentVector buf = &buf;
    std::vector<std::shared_ptr<CA::ADMPackFormat>>::__destroy_vector::operator()[abi:ne180100]((void ***)&p_buf);
    AudioComponentVector::append((AudioComponentVector *)v4, (const AudioComponentVector *)a2->__begin_, (const AudioComponentVector *)a2->__end_);
    AudioComponentVector::sort((AudioComponentVector *)v4);
    if (*((unsigned char *)this + 1))
    {
      long long v5 = (void *)*((void *)this + 30);
      *((void *)this + 30) = 0;

      uint64_t v6 = (void *)*((void *)this + 25);
      *((void *)this + 25) = 0;

      if (!gAudioComponentLogCategory) {
        operator new();
      }
      uint64_t v7 = *(id *)gAudioComponentLogCategory;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v9 = (unint64_t)((char *)a2->__end_ - (char *)a2->__begin_) >> 4;
        unint64_t v10 = (unint64_t)((char *)a3->__end_ - (char *)a3->__begin_) >> 4;
        uint64_t v11 = *((void *)this + 16);
        LODWORD(buf.__begin_) = 136316162;
        *(void **)((char *)&buf.__begin_ + 4) = "AudioComponentRegistrar.mm";
        WORD2(buf.__end_) = 1024;
        *(_DWORD *)((char *)&buf.__end_ + 6) = 161;
        WORD1(buf.__end_cap_.__value_) = 1024;
        HIDWORD(buf.__end_cap_.__value_) = v9;
        *(_WORD *)&buf.mSorted = 1024;
        *(_DWORD *)(&buf.mSorted + 2) = v10;
        *((_WORD *)&buf.mSorted + 3) = 2112;
        uint64_t v44 = v11;
        _os_log_impl(&dword_18FEC0000, v7, OS_LOG_TYPE_DEFAULT, "%25s:%-5d %d added, %d removed, conns %@", (uint8_t *)&buf, 0x28u);
      }
      begin = (char *)a2->__begin_;
      end = (char *)a2->__end_;
      if (a2->__begin_ != end)
      {
        do
        {
          if (!gAudioComponentLogCategory) {
            operator new();
          }
          log = *(id *)gAudioComponentLogCategory;
          if (os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT))
          {
            CAFormatter::CAFormatter((CAFormatter *)&p_buf, (const AudioComponentDescription *)(*(void *)begin + 36));
            LODWORD(buf.__begin_) = 136315650;
            *(void **)((char *)&buf.__begin_ + 4) = "AudioComponentRegistrar.mm";
            WORD2(buf.__end_) = 1024;
            *(_DWORD *)((char *)&buf.__end_ + 6) = 163;
            WORD1(buf.__end_cap_.__value_) = 2080;
            *(void **)((char *)&buf.__end_cap_.__value_ + 4) = p_buf;
            _os_log_impl(&dword_18FEC0000, log, OS_LOG_TYPE_DEFAULT, "%25s:%-5d added %s", (uint8_t *)&buf, 0x1Cu);
            if (p_buf) {
              free(p_buf);
            }
          }

          begin += 16;
        }
        while (begin != end);
      }
      uint64_t v15 = (char *)a3->__begin_;
      uint64_t v16 = (char *)a3->__end_;
      if (a3->__begin_ != v16)
      {
        do
        {
          if (!gAudioComponentLogCategory) {
            operator new();
          }
          loga = *(id *)gAudioComponentLogCategory;
          if (os_log_type_enabled(loga, OS_LOG_TYPE_DEFAULT))
          {
            CAFormatter::CAFormatter((CAFormatter *)&p_buf, (const AudioComponentDescription *)(*(void *)v15 + 36));
            LODWORD(buf.__begin_) = 136315650;
            *(void **)((char *)&buf.__begin_ + 4) = "AudioComponentRegistrar.mm";
            WORD2(buf.__end_) = 1024;
            *(_DWORD *)((char *)&buf.__end_ + 6) = 166;
            WORD1(buf.__end_cap_.__value_) = 2080;
            *(void **)((char *)&buf.__end_cap_.__value_ + 4) = p_buf;
            _os_log_impl(&dword_18FEC0000, loga, OS_LOG_TYPE_DEFAULT, "%25s:%-5d removed %s", (uint8_t *)&buf, 0x1Cu);
            if (p_buf) {
              free(p_buf);
            }
          }

          v15 += 16;
        }
        while (v15 != v16);
      }
      uint64_t v18 = *((void *)this + 31);
      if (v18) {
        os_log_t logb = (os_log_t)*(id *)(*(void *)v18 + 96);
      }
      else {
        os_log_t logb = 0;
      }
      buf.__begin_ = (char *)this + 208;
      LOBYTE(buf.__end_) = 0;
      p_AudioComponentVector buf = (char *)this + 168;
      char v41 = 0;
      long long v36 = 0u;
      long long v37 = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      obuint64_t j = *((id *)this + 16);
      uint64_t v19 = [obj countByEnumeratingWithState:&v36 objects:v42 count:16];
      if (v19)
      {
        uint64_t v20 = *(void *)v37;
        do
        {
          for (uint64_t i = 0; i != v19; ++i)
          {
            if (*(void *)v37 != v20) {
              objc_enumerationMutation(obj);
            }
            uint64_t v22 = (ConnectionInfo *)*(id *)(*((void *)&v36 + 1) + 8 * i);
            uint64_t v23 = v22;
            p_mConnection = (id *)&v22[1].mConnection;
            int mExtUsePermission = v22[1].mExtUsePermission;
            if (mExtUsePermission == -1)
            {
              int mExtUsePermission = ConnectionInfo::_canUseExtensions(v22 + 1);
              v23[1].int mExtUsePermission = mExtUsePermission;
            }
            id WeakRetained = objc_loadWeakRetained(p_mConnection);
            float32x4_t v27 = [WeakRetained remoteObjectProxy];
            if (mExtUsePermission == 1) {
              p_p_AudioComponentVector buf = (AudioComponentVector *)&p_buf;
            }
            else {
              p_p_AudioComponentVector buf = &buf;
            }
            unint64_t v29 = PurgeableDataWrapper::accessor::data((PurgeableDataWrapper::accessor *)p_p_buf);
            [v27 registrationsChanged:v29 includesExtensions:mExtUsePermission == 1 fsHash:logb];
          }
          uint64_t v19 = [obj countByEnumeratingWithState:&v36 objects:v42 count:16];
        }
        while (v19);
      }

      notify_post("com.apple.coreaudio.components.changed");
      if (v41) {
        [*((id *)p_buf + 4) endContentAccess];
      }
      if (LOBYTE(buf.__end_)) {
        [*((id *)buf.__begin_ + 4) endContentAccess];
      }
    }
  }
}

void sub_19019032C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_190190458(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZN27AudioComponentRegistrarImpl33listenerShouldAcceptNewConnectionEP13NSXPCListenerP15NSXPCConnection_block_invoke(uint64_t a1)
{
  id v1 = *(void **)(*(void *)(a1 + 40) + 128);
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  objc_msgSend(v1, "removeObject:");
}

void sub_1901904C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void ___ZN27AudioComponentRegistrarImpl33listenerShouldAcceptNewConnectionEP13NSXPCListenerP15NSXPCConnection_block_invoke_2(uint64_t a1)
{
  id v1 = *(void **)(*(void *)(a1 + 40) + 128);
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  objc_msgSend(v1, "removeObject:");
}

void sub_190190534(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1901906C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)AudioComponentRegistrar;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_190190E40(_Unwind_Exception *a1, uint64_t a2, RegistrarService *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, id *a11, void *a12, uint64_t a13, uint64_t a14, std::mutex *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void **a23)
{
  std::mutex::~mutex((std::mutex *)&a23);
  unint64_t v29 = *(std::__shared_weak_count **)(v24 + 264);
  if (v29) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v29);
  }
  std::unique_ptr<AudioComponentPluginScanner>::reset[abi:ne180100](v27, 0);

  std::__function::__value_func<NSData * ()(void)>::~__value_func[abi:ne180100](a10);
  std::__function::__value_func<NSData * ()(void)>::~__value_func[abi:ne180100](a9);
  a23 = (void **)(v24 + 136);
  std::vector<std::shared_ptr<CA::ADMPackFormat>>::__destroy_vector::operator()[abi:ne180100](&a23);

  RegistrarService::~RegistrarService(a11);
  RegistrarService::~RegistrarService(v25);
  std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100](a12);
  std::__function::__value_func<void ()(AudioComponentVector const&,AudioComponentVector&)>::~__value_func[abi:ne180100]((void *)(v24 + 16));

  MEMORY[0x192FC8940](v24, 0x10A0C401440404FLL);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__value_func<NSData * ()(void)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

void *std::__function::__value_func<NSData * ()(void)>::~__value_func[abi:ne180100](void *a1)
{
  unsigned __int8 v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100](void *a1)
{
  unsigned __int8 v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

id **std::unique_ptr<AudioComponentPluginScanner>::reset[abi:ne180100](id **result, id *a2)
{
  unsigned __int8 v2 = *result;
  *uint64_t result = a2;
  if (v2)
  {

    JUMPOUT(0x192FC8940);
  }
  return result;
}

void RegistrarService::~RegistrarService(id *this)
{
}

void ___ZN27AudioComponentRegistrarImpl15_initSubsystemsEv_block_invoke(void *a1)
{
  v34[3] = *MEMORY[0x1E4F143B8];
  unsigned __int8 v2 = (unsigned __int8 *)a1[4];
  uint64_t v3 = (id *)*((void *)v2 + 31);
  int v4 = *v2;
  std::__function::__value_func<void ()(AudioComponentVector const&,AudioComponentVector&)>::__value_func[abi:ne180100]((uint64_t)v29, (uint64_t)(v2 + 16));
  id v32 = 0;
  long long v5 = v30;
  if (v30)
  {
    uint64_t v6 = (void ***)operator new(0x28uLL);
    uint64_t v7 = v6;
    *uint64_t v6 = (void **)&unk_1EDF9E3F8;
    if (v5 == v29)
    {
      v6[4] = (void **)(v6 + 1);
      (*(void (**)(void *))(v29[0] + 24))(v29);
    }
    else
    {
      v6[4] = v5;
      int v30 = 0;
    }
    id v32 = v7;
  }
  v28[0] = &unk_1EDFA0B10;
  v28[3] = v28;
  if (!gAudioComponentLogCategory) {
    operator new();
  }
  uint64_t v8 = *(id *)gAudioComponentLogCategory;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
  {
    LODWORD(buf.__begin_) = 136315394;
    *(void **)((char *)&buf.__begin_ + 4) = "AudioComponentPluginScanner.mm";
    WORD2(buf.__end_) = 1024;
    *(_DWORD *)((char *)&buf.__end_ + 6) = 716;
    _os_log_impl(&dword_18FEC0000, v8, OS_LOG_TYPE_INFO, "%25s:%-5d Scanning for bundles", (uint8_t *)&buf, 0x12u);
  }
  double Current = CFAbsoluteTimeGetCurrent();
  uint64_t v11 = *v3;
  if (!*v3)
  {
    uint64_t v12 = objc_opt_new();
    id v13 = *v3;
    *uint64_t v3 = (id)v12;

    uint64_t v11 = *v3;
  }
  uint64_t v14 = (uint64_t)v32;
  if (!v32) {
    goto LABEL_16;
  }
  if (v32 != v31)
  {
    uint64_t v14 = ((uint64_t (*)(void))(*v32)[2])();
LABEL_16:
    *(void *)&buf.mSorted = v14;
    goto LABEL_18;
  }
  *(void *)&buf.mSorted = &buf;
  (*((void (**)(void ***, AudioComponentVector *))v31[0] + 3))(v31, &buf);
LABEL_18:
  uint64_t v15 = (char *)(v11 + 4);
  if (v11 + 4 != (void *)&buf)
  {
    uint64_t v16 = *(void *)&buf.mSorted;
    uint64_t v17 = (char *)v11[7];
    if (*(AudioComponentVector **)&buf.mSorted == &buf)
    {
      if (v17 == v15)
      {
        (*((void (**)(AudioComponentVector *, void *))buf.__begin_ + 3))(&buf, v34);
        (*(void (**)(void))(**(void **)&buf.mSorted + 32))(*(void *)&buf.mSorted);
        *(void *)&buf.mSorted = 0;
        (*(void (**)(void, AudioComponentVector *))(*(void *)v11[7] + 24))(v11[7], &buf);
        (*(void (**)(void))(*(void *)v11[7] + 32))(v11[7]);
        v11[7] = 0;
        *(void *)&buf.mSorted = &buf;
        (*(void (**)(void *, void *))(v34[0] + 24))(v34, v11 + 4);
        (*(void (**)(void *))(v34[0] + 32))(v34);
      }
      else
      {
        (*((void (**)(AudioComponentVector *, void *))buf.__begin_ + 3))(&buf, v11 + 4);
        (*(void (**)(void))(**(void **)&buf.mSorted + 32))(*(void *)&buf.mSorted);
        *(void *)&buf.mSorted = v11[7];
      }
      v11[7] = v15;
    }
    else if (v17 == v15)
    {
      (*(void (**)(void *, AudioComponentVector *))(*(void *)v15 + 24))(v11 + 4, &buf);
      (*(void (**)(void))(*(void *)v11[7] + 32))(v11[7]);
      v11[7] = *(void *)&buf.mSorted;
      *(void *)&buf.mSorted = &buf;
    }
    else
    {
      *(void *)&buf.mSorted = v11[7];
      v11[7] = v16;
    }
  }
  std::__function::__value_func<void ()(AudioComponentVector &,AudioComponentVector &)>::~__value_func[abi:ne180100](&buf);
  uint64_t v18 = *v3;
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)&buf, (uint64_t)v28);
  uint64_t v19 = (char *)(v18 + 8);
  if (v18 + 8 != (void *)&buf)
  {
    uint64_t v20 = *(void *)&buf.mSorted;
    uint64_t v21 = (char *)v18[11];
    if (*(AudioComponentVector **)&buf.mSorted == &buf)
    {
      if (v21 == v19)
      {
        (*((void (**)(AudioComponentVector *, void *))buf.__begin_ + 3))(&buf, v34);
        (*(void (**)(void))(**(void **)&buf.mSorted + 32))(*(void *)&buf.mSorted);
        *(void *)&buf.mSorted = 0;
        (*(void (**)(void, AudioComponentVector *))(*(void *)v18[11] + 24))(v18[11], &buf);
        (*(void (**)(void))(*(void *)v18[11] + 32))(v18[11]);
        v18[11] = 0;
        *(void *)&buf.mSorted = &buf;
        (*(void (**)(void *, void *))(v34[0] + 24))(v34, v18 + 8);
        (*(void (**)(void *))(v34[0] + 32))(v34);
      }
      else
      {
        (*((void (**)(AudioComponentVector *, void *))buf.__begin_ + 3))(&buf, v18 + 8);
        (*(void (**)(void))(**(void **)&buf.mSorted + 32))(*(void *)&buf.mSorted);
        *(void *)&buf.mSorted = v18[11];
      }
      v18[11] = v19;
    }
    else if (v21 == v19)
    {
      (*(void (**)(void *, AudioComponentVector *))(*(void *)v19 + 24))(v18 + 8, &buf);
      (*(void (**)(void))(*(void *)v18[11] + 32))(v18[11]);
      v18[11] = *(void *)&buf.mSorted;
      *(void *)&buf.mSorted = &buf;
    }
    else
    {
      *(void *)&buf.mSorted = v18[11];
      v18[11] = v20;
    }
  }
  std::__function::__value_func<void ()(void)>::~__value_func[abi:ne180100](&buf);
  if (*v3) {
    [*v3 postInit:v4 != 0];
  }
  else {
    memset(&v27, 0, sizeof(v27));
  }
  double v22 = CFAbsoluteTimeGetCurrent();
  if (!gAudioComponentLogCategory) {
    operator new();
  }
  uint64_t v23 = *(id *)gAudioComponentLogCategory;
  if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
  {
    LODWORD(buf.__begin_) = 136315650;
    *(void **)((char *)&buf.__begin_ + 4) = "AudioComponentPluginScanner.mm";
    WORD2(buf.__end_) = 1024;
    *(_DWORD *)((char *)&buf.__end_ + 6) = 734;
    WORD1(buf.__end_cap_.__value_) = 2048;
    *(double *)((char *)&buf.__end_cap_.__value_ + 4) = v22 - Current;
    _os_log_impl(&dword_18FEC0000, v23, OS_LOG_TYPE_INFO, "%25s:%-5d Finished scanning for bundles (%.3f s)", (uint8_t *)&buf, 0x1Cu);
  }
  std::__function::__value_func<void ()(void)>::~__value_func[abi:ne180100](v28);
  std::__function::__value_func<void ()(AudioComponentVector &,AudioComponentVector &)>::~__value_func[abi:ne180100](v31);
  std::__function::__value_func<void ()(AudioComponentVector const&,AudioComponentVector&)>::~__value_func[abi:ne180100](v29);
  uint64_t v25 = (std::mutex *)a1[5];
  AudioComponentVector v26 = (AudioComponentRegistrarImpl *)a1[6];
  std::mutex::lock(v25);
  memset(&buf, 0, 24);
  buf.mSorted = 1;
  AudioComponentRegistrarImpl::addRemoveComponents(v26, &v27, &buf);
  v31[0] = (void **)&buf;
  std::vector<std::shared_ptr<CA::ADMPackFormat>>::__destroy_vector::operator()[abi:ne180100](v31);
  std::mutex::unlock(v25);
  buf.__begin_ = &v27;
  std::vector<std::shared_ptr<CA::ADMPackFormat>>::__destroy_vector::operator()[abi:ne180100]((void ***)&buf);
}

void sub_1901919A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<AudioComponentRegistrarImpl::_initSubsystems(void)::$_2,std::allocator<AudioComponentRegistrarImpl::_initSubsystems(void)::$_2>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EDFA0B10;
}

void *std::__function::__func<AudioComponentRegistrarImpl::_initSubsystems(void)::$_2,std::allocator<AudioComponentRegistrarImpl::_initSubsystems(void)::$_2>,void ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EDFA0B10;
  return result;
}

void std::__function::__func<AudioComponentRegistrarImpl::_initSubsystems(void)::$_2,std::allocator<AudioComponentRegistrarImpl::_initSubsystems(void)::$_2>,void ()(void)>::~__func()
{
}

uint64_t std::__function::__func<std::function<void ()(AudioComponentVector const&,AudioComponentVector&)>,std::allocator<std::function<void ()(AudioComponentVector const&,AudioComponentVector&)>>,void ()(AudioComponentVector&,AudioComponentVector&)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!v1) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  unsigned __int8 v2 = *(uint64_t (**)(void))(*(void *)v1 + 48);
  return v2();
}

void std::__function::__func<std::function<void ()(AudioComponentVector const&,AudioComponentVector&)>,std::allocator<std::function<void ()(AudioComponentVector const&,AudioComponentVector&)>>,void ()(AudioComponentVector&,AudioComponentVector&)>::destroy_deallocate(void *a1)
{
  std::__function::__value_func<void ()(AudioComponentVector const&,AudioComponentVector&)>::~__value_func[abi:ne180100](a1 + 1);
  operator delete(a1);
}

void *std::__function::__func<std::function<void ()(AudioComponentVector const&,AudioComponentVector&)>,std::allocator<std::function<void ()(AudioComponentVector const&,AudioComponentVector&)>>,void ()(AudioComponentVector&,AudioComponentVector&)>::destroy(uint64_t a1)
{
  return std::__function::__value_func<void ()(AudioComponentVector const&,AudioComponentVector&)>::~__value_func[abi:ne180100]((void *)(a1 + 8));
}

uint64_t std::__function::__func<std::function<void ()(AudioComponentVector const&,AudioComponentVector&)>,std::allocator<std::function<void ()(AudioComponentVector const&,AudioComponentVector&)>>,void ()(AudioComponentVector&,AudioComponentVector&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EDF9E3F8;
  return std::__function::__value_func<void ()(AudioComponentVector const&,AudioComponentVector&)>::__value_func[abi:ne180100]((uint64_t)(a2 + 1), a1 + 8);
}

void *std::__function::__func<std::function<void ()(AudioComponentVector const&,AudioComponentVector&)>,std::allocator<std::function<void ()(AudioComponentVector const&,AudioComponentVector&)>>,void ()(AudioComponentVector&,AudioComponentVector&)>::__clone(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  unsigned __int8 v2 = operator new(0x28uLL);
  *unsigned __int8 v2 = &unk_1EDF9E3F8;
  std::__function::__value_func<void ()(AudioComponentVector const&,AudioComponentVector&)>::__value_func[abi:ne180100]((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_190191BD0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<std::function<void ()(AudioComponentVector const&,AudioComponentVector&)>,std::allocator<std::function<void ()(AudioComponentVector const&,AudioComponentVector&)>>,void ()(AudioComponentVector&,AudioComponentVector&)>::~__func(void *a1)
{
  *a1 = &unk_1EDF9E3F8;
  std::__function::__value_func<void ()(AudioComponentVector const&,AudioComponentVector&)>::~__value_func[abi:ne180100](a1 + 1);
  JUMPOUT(0x192FC8940);
}

void *std::__function::__func<std::function<void ()(AudioComponentVector const&,AudioComponentVector&)>,std::allocator<std::function<void ()(AudioComponentVector const&,AudioComponentVector&)>>,void ()(AudioComponentVector&,AudioComponentVector&)>::~__func(void *a1)
{
  *a1 = &unk_1EDF9E3F8;
  std::__function::__value_func<void ()(AudioComponentVector const&,AudioComponentVector&)>::~__value_func[abi:ne180100](a1 + 1);
  return a1;
}

void std::__function::__func<AudioComponentRegistrarImpl::_initSubsystems(void)::$_0,std::allocator<AudioComponentRegistrarImpl::_initSubsystems(void)::$_0>,void ()(AudioComponentVector const&,AudioComponentVector&)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v6 = [*(id *)(v5 + 80) _queue];
  dispatch_assert_queue_not_V2(v6);

  uint64_t v7 = [*(id *)(v5 + 80) _queue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZZN27AudioComponentRegistrarImpl15_initSubsystemsEvENK3__0clERK20AudioComponentVectorRS1__block_invoke;
  block[3] = &__block_descriptor_56_e5_v8__0l;
  void block[4] = v5;
  block[5] = a2;
  block[6] = a3;
  dispatch_sync(v7, block);
}

void sub_190191D44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZZN27AudioComponentRegistrarImpl15_initSubsystemsEvENK3__0clERK20AudioComponentVectorRS1__block_invoke(uint64_t a1)
{
}

uint64_t std::__function::__func<AudioComponentRegistrarImpl::_initSubsystems(void)::$_0,std::allocator<AudioComponentRegistrarImpl::_initSubsystems(void)::$_0>,void ()(AudioComponentVector const&,AudioComponentVector&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EDFA0AC8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<AudioComponentRegistrarImpl::_initSubsystems(void)::$_0,std::allocator<AudioComponentRegistrarImpl::_initSubsystems(void)::$_0>,void ()(AudioComponentVector const&,AudioComponentVector&)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EDFA0AC8;
  result[1] = v3;
  return result;
}

void std::__function::__func<AudioComponentRegistrarImpl::_initSubsystems(void)::$_0,std::allocator<AudioComponentRegistrarImpl::_initSubsystems(void)::$_0>,void ()(AudioComponentVector const&,AudioComponentVector&)>::~__func()
{
}

uint64_t std::__function::__func<AudioComponentRegistrarImpl::AudioComponentRegistrarImpl(BOOL,AudioComponentRegistrar *)::$_2,std::allocator<AudioComponentRegistrarImpl::AudioComponentRegistrarImpl(BOOL,AudioComponentRegistrar *)::$_2>,BOOL ()(void)>::operator()()
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v0 = [MEMORY[0x1E4F22420] sharedDatabaseContext];
  id v6 = 0;
  uint64_t v1 = [v0 startAccessingWithOptions:1 error:&v6];
  id v2 = v6;
  if ((v1 & 1) == 0)
  {
    if (!gAudioComponentLogCategory) {
      operator new();
    }
    uint64_t v3 = *(id *)gAudioComponentLogCategory;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)AudioComponentVector buf = 136315394;
      uint64_t v8 = "AudioComponentRegistrar.mm";
      __int16 v9 = 1024;
      int v10 = 82;
      _os_log_impl(&dword_18FEC0000, v3, OS_LOG_TYPE_ERROR, "%25s:%-5d AudioComponentRegistrar: LS Database rebuild is in progress, can't scan for extensions now!", buf, 0x12u);
    }
  }

  return v1;
}

void sub_190191F44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::__function::__func<AudioComponentRegistrarImpl::AudioComponentRegistrarImpl(BOOL,AudioComponentRegistrar *)::$_2,std::allocator<AudioComponentRegistrarImpl::AudioComponentRegistrarImpl(BOOL,AudioComponentRegistrar *)::$_2>,BOOL ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EDFA0BE8;
}

void *std::__function::__func<AudioComponentRegistrarImpl::AudioComponentRegistrarImpl(BOOL,AudioComponentRegistrar *)::$_2,std::allocator<AudioComponentRegistrarImpl::AudioComponentRegistrarImpl(BOOL,AudioComponentRegistrar *)::$_2>,BOOL ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EDFA0BE8;
  return result;
}

void std::__function::__func<AudioComponentRegistrarImpl::AudioComponentRegistrarImpl(BOOL,AudioComponentRegistrar *)::$_2,std::allocator<AudioComponentRegistrarImpl::AudioComponentRegistrarImpl(BOOL,AudioComponentRegistrar *)::$_2>,BOOL ()(void)>::~__func()
{
}

uint64_t std::__function::__func<AudioComponentRegistrarImpl::AudioComponentRegistrarImpl(BOOL,AudioComponentRegistrar *)::$_1,std::allocator<AudioComponentRegistrarImpl::AudioComponentRegistrarImpl(BOOL,AudioComponentRegistrar *)::$_1>,NSData * ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EDFA0BA0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<AudioComponentRegistrarImpl::AudioComponentRegistrarImpl(BOOL,AudioComponentRegistrar *)::$_1,std::allocator<AudioComponentRegistrarImpl::AudioComponentRegistrarImpl(BOOL,AudioComponentRegistrar *)::$_1>,NSData * ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EDFA0BA0;
  result[1] = v3;
  return result;
}

void std::__function::__func<AudioComponentRegistrarImpl::AudioComponentRegistrarImpl(BOOL,AudioComponentRegistrar *)::$_1,std::allocator<AudioComponentRegistrarImpl::AudioComponentRegistrarImpl(BOOL,AudioComponentRegistrar *)::$_1>,NSData * ()(void)>::~__func()
{
}

id std::__function::__func<AudioComponentRegistrarImpl::AudioComponentRegistrarImpl(BOOL,AudioComponentRegistrar *)::$_0,std::allocator<AudioComponentRegistrarImpl::AudioComponentRegistrarImpl(BOOL,AudioComponentRegistrar *)::$_0>,NSData * ()(void)>::operator()(uint64_t a1)
{
  return AudioComponentVector::serialized((AudioComponentVector *)(*(void *)(a1 + 8) + 136));
}

uint64_t std::__function::__func<AudioComponentRegistrarImpl::AudioComponentRegistrarImpl(BOOL,AudioComponentRegistrar *)::$_0,std::allocator<AudioComponentRegistrarImpl::AudioComponentRegistrarImpl(BOOL,AudioComponentRegistrar *)::$_0>,NSData * ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EDFA0B58;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<AudioComponentRegistrarImpl::AudioComponentRegistrarImpl(BOOL,AudioComponentRegistrar *)::$_0,std::allocator<AudioComponentRegistrarImpl::AudioComponentRegistrarImpl(BOOL,AudioComponentRegistrar *)::$_0>,NSData * ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EDFA0B58;
  result[1] = v3;
  return result;
}

void std::__function::__func<AudioComponentRegistrarImpl::AudioComponentRegistrarImpl(BOOL,AudioComponentRegistrar *)::$_0,std::allocator<AudioComponentRegistrarImpl::AudioComponentRegistrarImpl(BOOL,AudioComponentRegistrar *)::$_0>,NSData * ()(void)>::~__func()
{
}

void sub_1901921B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

UIImage *__cdecl AudioOutputUnitGetHostIcon(AudioUnit au, float desiredPointSize)
{
  *(float *)&outData = desiredPointSize;
  UInt32 ioDataSize = 8;
  if (AudioUnitGetProperty(au, 0xBB5u, 0, 0, &outData, &ioDataSize)) {
    return 0;
  }
  else {
    return outData;
  }
}

id IPCAUIcons::GetIconFromBundle(IPCAUIcons *this, const __CFString *a2)
{
  int v9 = 0;
  id v10 = 0;
  GlobalComponentPluginMgr((uint64_t *)v8);
  uint64_t v3 = (AudioComponentMgr_RegistrarService *)v8[1];
  aBlock[0] = MEMORY[0x1E4F143A8];
  aBlock[1] = 3221225472;
  aBlock[2] = ___ZN29AudioComponentMgr_NSExtension23iconForInterAppBundleIDEPK10__CFStringR13APIconRequest_block_invoke;
  aBlock[3] = &__block_descriptor_40_e16_v16__0__NSData_8l;
  aBlock[4] = &v9;
  int v4 = _Block_copy(aBlock);
  uint64_t v5 = AudioComponentMgr_RegistrarService::syncPrefServerProxy(v3);
  [v5 getInterAppIcon:this reply:v4];

  if (v8[0]) {
    std::recursive_mutex::unlock(v8[0]);
  }
  id v6 = v10;

  return v6;
}

void sub_1901922FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::recursive_mutex *a10, uint64_t a11, uint64_t a12, void *a13)
{
  if (a10) {
    std::recursive_mutex::unlock(a10);
  }

  _Unwind_Resume(a1);
}

id copyConfigurationInfoFromCache(const __CFString *a1)
{
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x3032000000;
  int v9 = __Block_byref_object_copy__14136;
  id v10 = __Block_byref_object_dispose__14137;
  id v11 = 0;
  uint64_t v2 = syncCacheServerProxy();
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = ___Z30copyConfigurationInfoFromCachePK10__CFString_block_invoke;
  v5[3] = &unk_1E5688C18;
  v5[4] = &v6;
  [v2 copyConfigurationInfoFromCache:a1 reply:v5];

  id v3 = (id)v7[5];
  _Block_object_dispose(&v6, 8);

  return v3;
}

void sub_190192430(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id a20)
{
  _Block_object_dispose(&a15, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__14136(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__14137(uint64_t a1)
{
}

id syncCacheServerProxy(void)
{
  uint64_t v0 = cacheServerConnection();
  uint64_t v1 = [v0 synchronousRemoteObjectProxyWithErrorHandler:&__block_literal_global_14139];

  return v1;
}

void sub_1901924C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___Z30copyConfigurationInfoFromCachePK10__CFString_block_invoke(uint64_t a1, void *a2)
{
}

id cacheServerConnection(void)
{
  uint64_t v0 = (void *)gCacheServerConnection;
  if (!gCacheServerConnection)
  {
    uint64_t v1 = (void *)[objc_alloc(MEMORY[0x1E4F29268]) initWithMachServiceName:@"com.apple.audio.AudioComponentPrefs" options:4096];
    uint64_t v2 = [MEMORY[0x1E4F29280] interfaceWithProtocol:&unk_1EDFB9950];
    [v1 setRemoteObjectInterface:v2];

    [v1 setInterruptionHandler:&__block_literal_global_34];
    [v1 setInvalidationHandler:&__block_literal_global_37];
    [v1 resume];
    id v3 = (void *)gCacheServerConnection;
    gCacheServerConnection = (uint64_t)v1;

    uint64_t v0 = (void *)gCacheServerConnection;
  }
  return v0;
}

void sub_1901925AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL20syncCacheServerProxyv_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  id v2 = a2;
  if (!gAudioComponentLogCategory) {
    operator new();
  }
  id v3 = *(id *)gAudioComponentLogCategory;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    int v5 = 136315650;
    uint64_t v6 = "AudioComponentConfigurationInfoCache.mm";
    __int16 v7 = 1024;
    int v8 = 58;
    __int16 v9 = 2112;
    id v10 = v2;
    _os_log_impl(&dword_18FEC0000, v3, OS_LOG_TYPE_ERROR, "%25s:%-5d cache server proxy error: %@", (uint8_t *)&v5, 0x1Cu);
  }
}

void sub_1901926E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL21cacheServerConnectionv_block_invoke_35()
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (!gAudioComponentLogCategory) {
    operator new();
  }
  uint64_t v0 = *(id *)gAudioComponentLogCategory;
  if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR))
  {
    int v2 = 136315394;
    id v3 = "AudioComponentConfigurationInfoCache.mm";
    __int16 v4 = 1024;
    int v5 = 45;
    _os_log_impl(&dword_18FEC0000, v0, OS_LOG_TYPE_ERROR, "%25s:%-5d cache server proxy error: Connection Invalidated", (uint8_t *)&v2, 0x12u);
  }
}

void ___ZL21cacheServerConnectionv_block_invoke()
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (!gAudioComponentLogCategory) {
    operator new();
  }
  uint64_t v0 = *(id *)gAudioComponentLogCategory;
  if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR))
  {
    int v2 = 136315394;
    id v3 = "AudioComponentConfigurationInfoCache.mm";
    __int16 v4 = 1024;
    int v5 = 42;
    _os_log_impl(&dword_18FEC0000, v0, OS_LOG_TYPE_ERROR, "%25s:%-5d cache server proxy error: Connection Interrupted", (uint8_t *)&v2, 0x12u);
  }
}

void writeConfigurationInfoToCache(const __CFString *a1, const __CFDictionary *a2)
{
  syncCacheServerProxy();
  id v4 = (id)objc_claimAutoreleasedReturnValue();
  [v4 writeConfigurationInfoToCache:a1 configurationInfo:a2];
}

void sub_190192958(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t createConfgurationInfoCacheKey(const AudioComponentDescription *a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  id v4 = NSString;
  CAX4CCString::CAX4CCString((CAX4CCString *)v8, a1->componentType);
  CAX4CCString::CAX4CCString((CAX4CCString *)v7, a1->componentSubType);
  CAX4CCString::CAX4CCString((CAX4CCString *)v6, a1->componentManufacturer);
  return objc_msgSend(v4, "stringWithFormat:", @"%d-%s-%s-%s-0x%X", 7, v8, v7, v6, a2);
}

void clearConfigInfoCache(const AudioComponentDescription *a1, uint64_t a2)
{
  OSType componentType = a1->componentType;
  OSType componentSubType = a1->componentSubType;
  OSType componentManufacturer = a1->componentManufacturer;
  __int16 v7 = cacheServerConnection();
  id v10 = [v7 remoteObjectProxyWithErrorHandler:&__block_literal_global_43_14159];

  if (componentType) {
    BOOL v8 = componentSubType == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8 || componentManufacturer == 0) {
    [v10 clearConfigurationInfoCache:0];
  }
  else {
    objc_msgSend(v10, "clearConfigurationInfoCache:", createConfgurationInfoCacheKey(a1, a2));
  }
}

void sub_190192AE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void ___ZL21asyncCacheServerProxyv_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  id v2 = a2;
  if (!gAudioComponentLogCategory) {
    operator new();
  }
  id v3 = *(id *)gAudioComponentLogCategory;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    int v5 = 136315650;
    uint64_t v6 = "AudioComponentConfigurationInfoCache.mm";
    __int16 v7 = 1024;
    int v8 = 65;
    __int16 v9 = 2112;
    id v10 = v2;
    _os_log_impl(&dword_18FEC0000, v3, OS_LOG_TYPE_ERROR, "%25s:%-5d cache server proxy error: %@", (uint8_t *)&v5, 0x1Cu);
  }
}

void sub_190192C24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id getValidationResultFromCache(const AudioComponentDescription *a1, int a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  createValidationResultCacheKey(a1, a2, a3, a4, a5);
  int v5 = (__CFString *)objc_claimAutoreleasedReturnValue();
  id v6 = copyConfigurationInfoFromCache(v5);

  return v6;
}

void sub_190192C74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id createValidationResultCacheKey(const AudioComponentDescription *a1, int a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  int v5 = @"arm64";
  if (a2 == 16777223) {
    int v5 = @"x86_64";
  }
  id v6 = [NSString stringWithFormat:@"validation-%d-'%x'-'%x'-'%x'-0x%X-0x%X-%@-%d", 7, a1->componentType, a1->componentSubType, a1->componentManufacturer, a3, a4, v5, a5];
  return v6;
}

void writeValidationResultToCache(const AudioComponentDescription *a1, int a2, uint64_t a3, uint64_t a4, unsigned int a5, const __CFDictionary *a6)
{
  createValidationResultCacheKey(a1, a2, a3, a4, a5);
  __int16 v7 = (__CFString *)objc_claimAutoreleasedReturnValue();
  writeConfigurationInfoToCache(v7, a6);
}

void sub_190192D5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void *CDelaunayTriangles3D::check_avail_vertices(void *result, unint64_t a2, int a3)
{
  id v4 = result;
  int v5 = 0;
  int v6 = 0;
  int v7 = 0;
  unint64_t v8 = HIDWORD(a2);
  __int16 v9 = result;
  while (1)
  {
    __int16 v9 = (void *)v9[1];
    if (v9 == result) {
      break;
    }
    int v10 = *((_DWORD *)v9 + 4);
    if (v10 == a2 || *((_DWORD *)v9 + 5) == a2) {
      int v7 = 1;
    }
    if (v10 == HIDWORD(a2) || *((_DWORD *)v9 + 5) == HIDWORD(a2)) {
      int v5 = 1;
    }
    if (v10 == a3 || *((_DWORD *)v9 + 5) == a3) {
      int v6 = 1;
    }
    if (v7 && v5 && v6) {
      return result;
    }
  }
  if (v7)
  {
    if (v5) {
      goto LABEL_18;
    }
LABEL_21:
    uint64_t result = std::list<int>::remove(v4 + 3, v8);
    if (v6) {
      return result;
    }
    goto LABEL_22;
  }
  uint64_t result = std::list<int>::remove(result + 3, a2);
  if (!v5) {
    goto LABEL_21;
  }
LABEL_18:
  if (v6) {
    return result;
  }
LABEL_22:
  return std::list<int>::remove(v4 + 3, a3);
}

void *std::list<int>::remove(void *a1, int a2)
{
  v13[0] = v13;
  v13[1] = v13;
  uint64_t v14 = 0;
  id v2 = (void *)a1[1];
  if (v2 != a1)
  {
    uint64_t v3 = 0;
    do
    {
      id v4 = (void *)v2[1];
      if (*((_DWORD *)v2 + 4) == a2)
      {
        while (v4 != a1)
        {
          BOOL v5 = *((_DWORD *)v4 + 4) == a2;
          if (*((_DWORD *)v4 + 4) != a2) {
            goto LABEL_8;
          }
          id v4 = (void *)v4[1];
        }
        BOOL v5 = 1;
        id v4 = a1;
LABEL_8:
        if (v2 != v4)
        {
          int v6 = (void *)*v4;
          if (v13 != a1)
          {
            if (v6 == v2)
            {
              uint64_t v9 = 1;
            }
            else
            {
              uint64_t v7 = -1;
              unint64_t v8 = v2;
              do
              {
                unint64_t v8 = (void *)v8[1];
                ++v7;
              }
              while (v8 != v6);
              uint64_t v9 = v7 + 2;
            }
            a1[2] -= v9;
            v3 += v9;
            uint64_t v14 = v3;
          }
          uint64_t v10 = *v2;
          *(void *)(v10 + 8) = v6[1];
          *(void *)v6[1] = v10;
          uint64_t v11 = v13[0];
          *(void *)(v13[0] + 8) = v2;
          *id v2 = v11;
          v13[0] = v6;
          v6[1] = v13;
        }
        if (!v5) {
          id v4 = (void *)v4[1];
        }
      }
      id v2 = v4;
    }
    while (v4 != a1);
  }
  return std::__list_imp<ID3FrameInfo>::clear(v13);
}

void *CDelaunayTriangles3D::add_edge_to_buffer(CDelaunayTriangles3D *this, int32x2_t *a2)
{
  uint64_t v4 = *((void *)this + 2);
  int32x2_t v8 = vrev64_s32(*a2);
  uint64_t result = std::list<std::array<int,2ul>>::remove(this, &v8);
  if (*((void *)this + 2) == v4)
  {
    int32x2_t v6 = *a2;
    uint64_t result = operator new(0x18uLL);
    result[2] = v6;
    uint64_t v7 = *(void *)this;
    *uint64_t result = *(void *)this;
    result[1] = this;
    *(void *)(v7 + 8) = result;
    *(void *)this = result;
    *((void *)this + 2) = v4 + 1;
  }
  return result;
}

void *std::list<std::array<int,2ul>>::remove(void *a1, void *a2)
{
  v13[0] = v13;
  v13[1] = v13;
  uint64_t v14 = 0;
  id v2 = (void *)a1[1];
  if (v2 != a1)
  {
    uint64_t v3 = 0;
    do
    {
      uint64_t v4 = (void *)v2[1];
      if (v2[2] == *a2)
      {
        while (v4 != a1)
        {
          BOOL v5 = v4[2] == *a2;
          if (v4[2] != *a2) {
            goto LABEL_10;
          }
          uint64_t v4 = (void *)v4[1];
        }
        BOOL v5 = 1;
        uint64_t v4 = a1;
LABEL_10:
        if (v2 != v4)
        {
          int32x2_t v6 = (void *)*v4;
          if (v13 != a1)
          {
            if (v6 == v2)
            {
              uint64_t v9 = 1;
            }
            else
            {
              uint64_t v7 = -1;
              int32x2_t v8 = v2;
              do
              {
                int32x2_t v8 = (void *)v8[1];
                ++v7;
              }
              while (v8 != v6);
              uint64_t v9 = v7 + 2;
            }
            a1[2] -= v9;
            v3 += v9;
            uint64_t v14 = v3;
          }
          uint64_t v10 = *v2;
          *(void *)(v10 + 8) = v6[1];
          *(void *)v6[1] = v10;
          uint64_t v11 = v13[0];
          *(void *)(v13[0] + 8) = v2;
          *id v2 = v11;
          v13[0] = v6;
          v6[1] = v13;
        }
        if (!v5) {
          uint64_t v4 = (void *)v4[1];
        }
      }
      id v2 = v4;
    }
    while (v4 != a1);
  }
  return std::__list_imp<ID3FrameInfo>::clear(v13);
}

uint64_t CDelaunayTriangles3D::find_one_delaunay3(CDelaunayTriangles3D *this, const double *a2, const double *a3, const double *a4, int *a5, int a6)
{
  uint64_t v6 = *((void *)this + 5);
  if (!v6) {
    return 0xFFFFFFFFLL;
  }
  if (v6 != 1)
  {
    uint64_t v12 = (char *)this + 24;
    id v13 = (CDelaunayTriangles3D *)*((void *)this + 4);
    if (v13 != (CDelaunayTriangles3D *)((char *)this + 24))
    {
      int v14 = 0;
      uint64_t v15 = *((void *)this + 4);
      do
      {
        uint64_t result = *(unsigned int *)(v15 + 16);
        if (result != a5 && result != a6)
        {
          v17.f64[0] = a2[(int)a5];
          double v18 = a2[a6];
          double v19 = a2[(int)result];
          v20.f64[0] = a3[(int)a5];
          double v21 = a3[a6];
          double v22 = a3[(int)result];
          v23.f64[0] = a4[(int)a5];
          double v24 = a4[a6];
          double v25 = a4[(int)result];
          if (v17.f64[0] * (v21 * v25 - v24 * v22)
             - v20.f64[0] * (v18 * v25 - v24 * v19)
             + v23.f64[0] * (v18 * v22 - v21 * v19) > 0.0)
          {
            v26.f64[0] = v20.f64[0] * v20.f64[0] + v17.f64[0] * v17.f64[0] + v23.f64[0] * v23.f64[0];
            v26.f64[1] = v21 * v21 + v18 * v18 + v24 * v24;
            v17.f64[1] = a2[a6];
            v20.f64[1] = a3[a6];
            v23.f64[1] = a4[a6];
            int v27 = v14;
            uint64_t v28 = v13;
            while (1)
            {
              if (v27)
              {
                int v29 = *((_DWORD *)v28 + 4);
                if (v29 != a5 && v29 != a6)
                {
                  v31.f64[0] = v22 * v22 + v19 * v19 + v25 * v25;
                  v31.f64[1] = a3[v29] * a3[v29] + a2[v29] * a2[v29] + a4[v29] * a4[v29];
                  v32.f64[0] = a2[(int)result];
                  v32.f64[1] = a2[v29];
                  *(double *)v33.i64 = a3[(int)result];
                  *(double *)&v33.i64[1] = a3[v29];
                  *(double *)v34.i64 = a4[(int)result];
                  *(double *)&v34.i64[1] = a4[v29];
                  float64x2_t v35 = (float64x2_t)vextq_s8(v33, (int8x16_t)v20, 8uLL);
                  float64x2_t v36 = vnegq_f64(v35);
                  float64x2_t v37 = (float64x2_t)vextq_s8((int8x16_t)v20, v33, 8uLL);
                  float64x2_t v38 = vnegq_f64(v37);
                  float64x2_t v39 = (float64x2_t)vextq_s8(v34, (int8x16_t)v23, 8uLL);
                  float64x2_t v40 = (float64x2_t)vextq_s8((int8x16_t)v23, v34, 8uLL);
                  float64x2_t v41 = vmlaq_f64(vmulq_f64(v23, v38), v40, v20);
                  float64x2_t v42 = vmulq_f64(v32, vmlaq_f64(vmulq_f64(v39, v38), v40, v35));
                  float64x2_t v43 = (float64x2_t)vextq_s8((int8x16_t)v32, (int8x16_t)v17, 8uLL);
                  float64x2_t v44 = (float64x2_t)vextq_s8((int8x16_t)v17, (int8x16_t)v32, 8uLL);
                  float64x2_t v45 = vmlaq_f64(vmlaq_f64(v42, vmlaq_f64(vmulq_f64((float64x2_t)v34, v36), v39, (float64x2_t)v33), v44), vmlaq_f64(vmulq_f64(v40, vnegq_f64((float64x2_t)v33)), (float64x2_t)v34, v37), v43);
                  int64x2_t v46 = (int64x2_t)vmulq_f64(v31, vmlaq_f64(vmlaq_f64(vmulq_f64(v17, vmlaq_f64(vmulq_f64(v40, v36), v39, v37)), v41, v43), vmlaq_f64(vmulq_f64(v39, vnegq_f64(v20)), v23, v35), v44));
                  int64x2_t v47 = (int64x2_t)vmulq_f64(v26, v45);
                  if (vaddvq_f64(vsubq_f64((float64x2_t)vzip1q_s64(v47, v46), (float64x2_t)vzip2q_s64(v47, v46))) > 1.0e-13) {
                    break;
                  }
                }
              }
              uint64_t v28 = (CDelaunayTriangles3D *)*((void *)v28 + 1);
              --v27;
              if (v28 == (CDelaunayTriangles3D *)v12) {
                return result;
              }
            }
          }
        }
        uint64_t v15 = *(void *)(v15 + 8);
        ++v14;
      }
      while ((char *)v15 != v12);
    }
    return 0xFFFFFFFFLL;
  }
  unsigned int v7 = *(_DWORD *)(*((void *)this + 4) + 16);
  if (v7 == a5 || v7 == a6) {
    return 0xFFFFFFFFLL;
  }
  double v9 = a2[a6];
  double v10 = a2[v7];
  if (a2[(int)a5] * (a3[a6] * a4[v7] - a4[a6] * a3[v7])
     - a3[(int)a5] * (v9 * a4[v7] - a4[a6] * v10)
     + a4[(int)a5] * (v9 * a3[v7] - a3[a6] * v10) <= 0.0)
    return 0xFFFFFFFFLL;
  else {
    return v7;
  }
}

uint64_t CDelaunayTriangles3D::find_subtriangle_containment(unint64_t this, double a2, double a3, double a4)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if ((this & 0x8000000000000000) != 0) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v4 = this;
  if (a3 <= -0.00000011920929) {
    int v5 = 4 * (a2 > -0.00000011920929);
  }
  else {
    int v5 = (4 * (a2 > -0.00000011920929)) | 2;
  }
  uint64_t v6 = v5 | (a4 > -0.00000011920929);
  if (this)
  {
    uint64_t v6 = (v6 << (2 * this));
    double v7 = fabs(a4);
    double v8 = fabs(a3);
    double v9 = fabs(a2);
    double v10 = MEMORY[0x1E4F14500];
    do
    {
      uint64_t v11 = v4;
      double v12 = v9 - v8 - v7;
      double v13 = v8 + v8;
      double v14 = v7 + v7;
      double v15 = v9 + v9;
      if (v8 + v8 >= v12) {
        double v16 = v9 - v8 - v7;
      }
      else {
        double v16 = v8 + v8;
      }
      if (v14 < v16) {
        double v16 = v7 + v7;
      }
      if (v13 >= v15) {
        double v17 = v9 + v9;
      }
      else {
        double v17 = v8 + v8;
      }
      if (v7 - v8 - v9 < v17) {
        double v17 = v7 - v8 - v9;
      }
      *(double *)float64x2_t v23 = v16;
      *(double *)&v23[1] = v17;
      if (v8 - v9 - v7 >= v15) {
        double v18 = v9 + v9;
      }
      else {
        double v18 = v8 - v9 - v7;
      }
      if (v14 < v18) {
        double v18 = v7 + v7;
      }
      if (v9 - v8 + v7 >= v8 + v7 - v9) {
        double v19 = v8 + v7 - v9;
      }
      else {
        double v19 = v9 - v8 + v7;
      }
      if (v9 + v8 - v7 < v19) {
        double v19 = v9 + v8 - v7;
      }
      *(double *)&v23[2] = v18;
      *(double *)&v23[3] = v19;
      float64x2_t v20 = (double *)v23;
      for (uint64_t i = 1; i != 4; ++i)
      {
        if (v16 < *(double *)&v23[i])
        {
          double v16 = *(double *)&v23[i];
          float64x2_t v20 = (double *)&v23[i];
        }
      }
      --v4;
      if (*v20 <= -0.00000011920929)
      {
LABEL_33:
        if (*v20 <= -0.0000011920929)
        {
LABEL_36:
          if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)AudioComponentVector buf = 136315906;
            double v25 = "DelaunayTriangles3D.cpp";
            __int16 v26 = 1024;
            int v27 = 476;
            __int16 v28 = 2080;
            int v29 = "find_subtriangle_containment";
            __int16 v30 = 1024;
            int v31 = 476;
            _os_log_impl(&dword_18FEC0000, v10, OS_LOG_TYPE_ERROR, "%25s:%-5d CADSPUtility:%s:%d: subtriangle still not found in computing rank with relaxed test!", buf, 0x22u);
          }
          double v12 = v9;
          double v13 = v8;
          double v14 = v7;
        }
        else
        {
          switch(((char *)v20 - (char *)v23) >> 3)
          {
            case 0:
              break;
            case 1:
              goto LABEL_35;
            case 2:
              goto LABEL_39;
            case 3:
              goto LABEL_40;
            default:
              goto LABEL_36;
          }
        }
      }
      else
      {
        switch(((char *)v20 - (char *)v23) >> 3)
        {
          case 0:
            break;
          case 1:
LABEL_35:
            uint64_t v6 = ((1 << (2 * v4)) + v6);
            double v12 = v9 + v9;
            double v14 = v7 - v8 - v9;
            break;
          case 2:
LABEL_39:
            uint64_t v6 = ((2 << (2 * v4)) + v6);
            double v12 = v9 + v9;
            double v13 = v8 - v9 - v7;
            break;
          case 3:
LABEL_40:
            uint64_t v6 = ((3 << (2 * v4)) + v6);
            double v12 = v8 + v7 - v9;
            double v13 = v9 - v8 + v7;
            double v14 = v9 + v8 - v7;
            break;
          default:
            goto LABEL_33;
        }
      }
      double v7 = v14;
      double v8 = v13;
      double v9 = v12;
    }
    while (v11 > 1);
  }
  return v6;
}

BOOL CDelaunayTriangles3D::check_coplanar(float64_t *this, const double *a2, const double *a3, const double *a4, double a5, float64x2_t a6, double a7, double a8, float64x2_t a9, double a10, float64x2_t a11)
{
  if (a4 >= 4)
  {
    uint64_t v12 = 0;
    while (2)
    {
      uint64_t v13 = 0;
      do
      {
        if (v13 != v12)
        {
          uint64_t v14 = 0;
          while (1)
          {
            if (v12 != v14 && v13 != v14)
            {
              v15.f64[0] = this[v12];
              v15.f64[1] = a2[v12];
              a6.f64[0] = a3[v12];
              v16.f64[0] = this[v13];
              v16.f64[1] = a2[v13];
              a9.f64[0] = a3[v13];
              v17.f64[0] = this[v14];
              v17.f64[1] = a2[v14];
              a11.f64[0] = a3[v14];
              float64x2_t v18 = vsubq_f64(v17, v15);
              float64x2_t v19 = vsubq_f64(a11, a6);
              float64x2_t v20 = vsubq_f64(v16, v15);
              float64x2_t v21 = vsubq_f64(a9, a6);
              float64x2_t v22 = vmlaq_laneq_f64(vmulq_laneq_f64(vnegq_f64(v19), v20, 1), v21, v18, 1);
              v21.f64[1] = v20.f64[0];
              v19.f64[1] = v18.f64[0];
              a11 = vmlaq_f64(vmulq_f64(v21, vnegq_f64(v18)), v20, v19);
              v23.f64[0] = v22.f64[0];
              v23.f64[1] = a11.f64[0];
              a9 = (float64x2_t)vdupq_laneq_s64((int64x2_t)a11, 1);
              if (vabsq_f64(a9).f64[0] + vaddvq_f64(vabsq_f64(v23)) > 0.05) {
                break;
              }
            }
            if (a4 == ++v14) {
              goto LABEL_11;
            }
          }
          uint64_t v24 = 0;
          BOOL v11 = 0;
          *(void *)&v23.f64[1] = vextq_s8((int8x16_t)v23, (int8x16_t)v23, 8uLL).u64[0];
          float64x2_t v25 = (float64x2_t)vextq_s8((int8x16_t)a11, (int8x16_t)a11, 8uLL);
          a11.f64[1] = v25.f64[0];
          float64x2_t v26 = vmulq_f64(a11, a11);
          float v27 = sqrt(v26.f64[1] + vmulq_f64(v22, v22).f64[0] + v26.f64[0]);
          double v28 = v27;
          do
          {
            if (v14 != v24 && v12 != v24 && v13 != v24)
            {
              v29.f64[0] = this[v24];
              v29.f64[1] = a2[v24];
              v25.f64[0] = a3[v24];
              float64x2_t v25 = vmulq_f64(a9, vsubq_f64(v25, a6));
              if (fabs((v25.f64[0] + vaddvq_f64(vmulq_f64(v23, vsubq_f64(v29, v15)))) / v28) > 0.01) {
                break;
              }
            }
            BOOL v11 = ++v24 >= (unint64_t)a4;
          }
          while (a4 != v24);
          return v11;
        }
LABEL_11:
        ++v13;
      }
      while (v13 != a4);
      ++v12;
      BOOL v11 = 1;
      if (v12 != a4) {
        continue;
      }
      break;
    }
  }
  else
  {
    return 1;
  }
  return v11;
}

uint64_t std::list<int>::__sort<std::__less<void,void>>(uint64_t result, uint64_t a2, unint64_t a3)
{
  if (a3 >= 2)
  {
    if (a3 == 2)
    {
      unint64_t v4 = *(uint64_t **)a2;
      if (*(_DWORD *)(*(void *)a2 + 16) < *(_DWORD *)(result + 16))
      {
        uint64_t v5 = *v4;
        *(void *)(v5 + 8) = v4[1];
        *(void *)v4[1] = v5;
        uint64_t v6 = *(void *)result;
        *(void *)(v6 + 8) = v4;
        *unint64_t v4 = v6;
        *(void *)uint64_t result = v4;
        v4[1] = result;
        return (uint64_t)v4;
      }
    }
    else
    {
      unint64_t v8 = a3 >> 1;
      unint64_t v9 = (a3 >> 1) + 1;
      uint64_t v10 = result;
      do
      {
        uint64_t v10 = *(void *)(v10 + 8);
        --v9;
      }
      while (v9 > 1);
      uint64_t v11 = std::list<int>::__sort<std::__less<void,void>>(result, v10, a3 >> 1);
      uint64_t result = std::list<int>::__sort<std::__less<void,void>>(v10, a2, a3 - v8);
      int v12 = *(_DWORD *)(v11 + 16);
      if (*(_DWORD *)(result + 16) >= v12)
      {
        uint64_t v14 = *(uint64_t **)(v11 + 8);
        uint64_t i = result;
        uint64_t result = v11;
      }
      else
      {
        for (uint64_t i = *(void *)(result + 8); i != a2; uint64_t i = *(void *)(i + 8))
        {
          if (*(_DWORD *)(i + 16) >= v12) {
            goto LABEL_14;
          }
        }
        uint64_t i = a2;
LABEL_14:
        uint64_t v15 = *(void *)i;
        uint64_t v16 = *(void *)result;
        *(void *)(v16 + 8) = *(void *)(*(void *)i + 8);
        **(void **)(v15 + 8) = v16;
        uint64_t v17 = *(void *)v11;
        uint64_t v14 = *(uint64_t **)(v11 + 8);
        *(void *)(v17 + 8) = result;
        *(void *)uint64_t result = v17;
        *(void *)uint64_t v11 = v15;
        *(void *)(v15 + 8) = v11;
      }
      if (v14 != (uint64_t *)i && i != a2)
      {
        uint64_t v18 = i;
        do
        {
          int v19 = *((_DWORD *)v14 + 4);
          if (*(_DWORD *)(i + 16) >= v19)
          {
            uint64_t v14 = (uint64_t *)v14[1];
          }
          else
          {
            for (uint64_t j = *(void *)(i + 8); j != a2; uint64_t j = *(void *)(j + 8))
            {
              if (*(_DWORD *)(j + 16) >= v19) {
                goto LABEL_25;
              }
            }
            uint64_t j = a2;
LABEL_25:
            uint64_t v21 = *(void *)j;
            uint64_t v22 = *(void *)i;
            *(void *)(v22 + 8) = *(void *)(*(void *)j + 8);
            **(void **)(v21 + 8) = v22;
            if (v18 == i) {
              uint64_t v18 = j;
            }
            uint64_t v24 = *v14;
            float64x2_t v23 = (uint64_t *)v14[1];
            *(void *)(v24 + 8) = i;
            *(void *)uint64_t i = v24;
            *uint64_t v14 = v21;
            *(void *)(v21 + 8) = v14;
            uint64_t v14 = v23;
            uint64_t i = j;
          }
        }
        while (v14 != (uint64_t *)v18 && i != a2);
      }
    }
  }
  return result;
}

OSStatus AudioUnitAddPropertyListener(AudioUnit inUnit, AudioUnitPropertyID inID, AudioUnitPropertyListenerProc inProc, void *inProcUserData)
{
  if (!inUnit) {
    return -50;
  }
  uint64_t v6 = *(void *)&inID;
  double v7 = (uint64_t (***)(void))(*(uint64_t (**)(AudioUnit))(*(void *)inUnit + 8))(inUnit);
  if (!v7) {
    return 560947818;
  }
  unint64_t v8 = v7;
  if (*(_WORD *)((**v7)(v7) + 38) != 24949) {
    return -3000;
  }
  unint64_t v9 = *(uint64_t (**)(uint64_t (**)(void), uint64_t, AudioUnitPropertyListenerProc, void *))(*(void *)((**v8)(v8) + 112) + 40);
  if (!v9) {
    return -4;
  }
  uint64_t v10 = v8[3];
  return v9(v10, v6, inProc, inProcUserData);
}

OSStatus AudioUnitRemovePropertyListenerWithUserData(AudioUnit inUnit, AudioUnitPropertyID inID, AudioUnitPropertyListenerProc inProc, void *inProcUserData)
{
  if (!inUnit) {
    return -50;
  }
  uint64_t v6 = *(void *)&inID;
  double v7 = (uint64_t (***)(void))(*(uint64_t (**)(AudioUnit))(*(void *)inUnit + 8))(inUnit);
  if (!v7) {
    return 560947818;
  }
  unint64_t v8 = v7;
  if (*(_WORD *)((**v7)(v7) + 38) != 24949) {
    return -3000;
  }
  unint64_t v9 = *(uint64_t (**)(uint64_t (**)(void), uint64_t, AudioUnitPropertyListenerProc, void *))(*(void *)((**v8)(v8) + 112) + 56);
  if (!v9) {
    return -4;
  }
  uint64_t v10 = v8[3];
  return v9(v10, v6, inProc, inProcUserData);
}

OSStatus AudioUnitAddRenderNotify(AudioUnit inUnit, AURenderCallback inProc, void *inProcUserData)
{
  if (!inUnit) {
    return -50;
  }
  uint64_t v5 = (uint64_t (***)(void))(*(uint64_t (**)(AudioUnit))(*(void *)inUnit + 8))(inUnit);
  if (!v5) {
    return 560947818;
  }
  uint64_t v6 = v5;
  if (*(_WORD *)((**v5)(v5) + 38) != 24949) {
    return -3000;
  }
  double v7 = *(uint64_t (**)(uint64_t (**)(void), AURenderCallback, void *))(*(void *)((**v6)(v6) + 112)
                                                                                           + 64);
  if (!v7) {
    return -4;
  }
  unint64_t v8 = v6[3];
  return v7(v8, inProc, inProcUserData);
}

OSStatus AudioUnitRemoveRenderNotify(AudioUnit inUnit, AURenderCallback inProc, void *inProcUserData)
{
  if (!inUnit) {
    return -50;
  }
  uint64_t v5 = (uint64_t (***)(void))(*(uint64_t (**)(AudioUnit))(*(void *)inUnit + 8))(inUnit);
  if (!v5) {
    return 560947818;
  }
  uint64_t v6 = v5;
  if (*(_WORD *)((**v5)(v5) + 38) != 24949) {
    return -3000;
  }
  double v7 = *(uint64_t (**)(uint64_t (**)(void), AURenderCallback, void *))(*(void *)((**v6)(v6) + 112)
                                                                                           + 72);
  if (!v7) {
    return -4;
  }
  unint64_t v8 = v6[3];
  return v7(v8, inProc, inProcUserData);
}

OSStatus AudioUnitScheduleParameters(AudioUnit inUnit, const AudioUnitParameterEvent *inParameterEvent, UInt32 inNumParamEvents)
{
  if (!inUnit) {
    return -50;
  }
  uint64_t v3 = *(void *)&inNumParamEvents;
  uint64_t v5 = (uint64_t (***)(void))(*(uint64_t (**)(AudioUnit))(*(void *)inUnit + 8))(inUnit);
  if (!v5) {
    return 560947818;
  }
  uint64_t v6 = v5;
  if (*(_WORD *)((**v5)(v5) + 38) != 24949) {
    return -3000;
  }
  double v7 = *(uint64_t (**)(uint64_t (**)(void), const AudioUnitParameterEvent *, uint64_t))(*(void *)((**v6)(v6) + 112) + 96);
  if (!v7) {
    return -4;
  }
  unint64_t v8 = v6[3];
  return v7(v8, inParameterEvent, v3);
}

uint64_t AudioUnitComplexRender(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (!a1) {
    return 4294967246;
  }
  uint64_t v17 = (uint64_t (***)(void))(*(uint64_t (**)(uint64_t))(*(void *)a1 + 8))(a1);
  if (!v17) {
    return 4294967292;
  }
  uint64_t v18 = v17;
  if (*(_WORD *)((**v17)(v17) + 38) != 24949) {
    return 4294964296;
  }
  int v19 = *(uint64_t (**)(uint64_t (**)(void), uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)((**v18)(v18) + 112) + 120);
  if (!v19) {
    return 4294967292;
  }
  float64x2_t v20 = v18[3];
  return v19(v20, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

OSStatus AudioOutputUnitStop(AudioUnit ci)
{
  if (!ci) {
    return -50;
  }
  uint64_t v1 = (uint64_t (***)(void))(*(uint64_t (**)(AudioUnit))(*(void *)ci + 8))(ci);
  if (!v1) {
    return 560947818;
  }
  id v2 = v1;
  if (*(_WORD *)((**v1)(v1) + 38) != 24949) {
    return -3000;
  }
  uint64_t v3 = *(uint64_t (**)(void))(*(void *)((**v2)(v2) + 112) + 152);
  if (!v3) {
    return -4;
  }
  unint64_t v4 = v2[3];
  return v3(v4);
}

OSStatus MusicDeviceMIDIEvent(MusicDeviceComponent inUnit, UInt32 inStatus, UInt32 inData1, UInt32 inData2, UInt32 inOffsetSampleFrame)
{
  if (!inUnit) {
    return -50;
  }
  uint64_t v5 = *(void *)&inOffsetSampleFrame;
  uint64_t v6 = *(void *)&inData2;
  uint64_t v7 = *(void *)&inData1;
  uint64_t v8 = *(void *)&inStatus;
  unint64_t v9 = (uint64_t (***)(void))(*(uint64_t (**)(MusicDeviceComponent))(*(void *)inUnit + 8))(inUnit);
  if (!v9) {
    return 560947818;
  }
  uint64_t v10 = v9;
  if (*(_WORD *)((**v9)(v9) + 38) != 24949) {
    return -3000;
  }
  (**v10)(v10);
  if (!v10[3]) {
    return -66740;
  }
  uint64_t v11 = *(void *)((**v10)(v10) + 112);
  if (*((unsigned char *)v10 + 88))
  {
    int v19 = v10[3];
    int v17 = v7;
    int v18 = v8;
    int v15 = v5;
    int v16 = v6;
    return ((uint64_t (*)(uint64_t (***)(void), uint64_t (***)(void), uint64_t, int *, int *, int *, int *))*v10[23])(v10 + 24, &v19, v11, &v18, &v17, &v16, &v15);
  }
  else
  {
    uint64_t v13 = *(uint64_t (**)(uint64_t (**)(void), uint64_t, uint64_t, uint64_t, uint64_t))(v11 + 160);
    if (v13)
    {
      uint64_t v14 = v10[3];
      return v13(v14, v8, v7, v6, v5);
    }
    else
    {
      return -4;
    }
  }
}

OSStatus MusicDeviceMIDIEventList(MusicDeviceComponent inUnit, UInt32 inOffsetSampleFrame, const MIDIEventList *evtList)
{
  uint64_t v142 = *MEMORY[0x1E4F143B8];
  OSStatus numPackets = -50;
  if (!inUnit || !evtList) {
    return numPackets;
  }
  uint64_t v5 = *(void *)&inOffsetSampleFrame;
  uint64_t v6 = (*(uint64_t (**)(MusicDeviceComponent))(*(void *)inUnit + 8))(inUnit);
  if (!v6) {
    return -3000;
  }
  uint64_t v7 = v6;
  if (!*(void *)(v6 + 24)) {
    return -66740;
  }
  uint64_t v8 = (**(uint64_t (***)(uint64_t))v6)(v6);
  if (!*(unsigned char *)(v7 + 88)) {
    return -4;
  }
  uint64_t v9 = *(void *)(v8 + 112);
  uint64_t v127 = *(void *)(v7 + 24);
  unsigned int v128 = v5;
  MIDIProtocolID v10 = *(_DWORD *)(v7 + 108);
  if (!v10 || (int v126 = *(uint64_t (**)(uint64_t, uint64_t, const MIDIEventList *))(v9 + 192)) == 0)
  {
    if (*(void *)(v9 + 160))
    {
      words[0] = 0;
      *(void *)uint64_t v133 = caulk::inplace_function<void ()(MIDI::LegacyPacketList const*),48ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<APMIDIRouter::handleMIDIEventList(void *,AudioUnitPluginDispatch const&,unsigned int,MIDIEventList const*)::$_1>;
      *(void *)&long long v134 = v127;
      *((void *)&v134 + 1) = v9;
      *(void *)&long long v135 = v9 + 160;
      *((void *)&v135 + 1) = &v128;
      uint64_t v136 = words;
      unint64_t v137 = caulk::inplace_function<void ()(MIDI::LegacyPacketList const*),48ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<APMIDIRouter::handleMIDIEventList(void *,AudioUnitPluginDispatch const&,unsigned int,MIDIEventList const*)::$_1>;
      long long v138 = v134;
      long long v139 = v135;
      uint64_t v140 = words;
      MIDI::MIDIPacketList_Deliverer::MIDIPacketList_Deliverer(&evtlist, (uint64_t *)&v137);
      ((void (*)(long long *))v137[3])(&v138);
      MIDI::MIDIPacketList_Deliverer::operator()((uint64_t)&evtlist, evtList);
      *(void *)&evtlist.MIDIProtocolID protocol = &unk_1EDF95120;
      (*(void (**)(UInt32 *))(evtlist.packet[0].timeStamp + 24))(&evtlist.packet[0].wordCount);
      (*(void (**)(long long *))(*(void *)v133 + 24))(&v134);
      return words[0];
    }
    return -4;
  }
  MIDIProtocolID protocol = evtList->protocol;
  if (evtList->protocol == v10)
  {
    OSStatus numPackets = evtList->numPackets;
    if (numPackets)
    {
      if (numPackets == 1 && evtList->packet[0].wordCount <= 0x40)
      {
        return v126(v127, v5, evtList);
      }
      else
      {
        OSStatus numPackets = 0;
        UInt32 v54 = 0;
        packet = evtList->packet;
        do
        {
          uint64_t wordCount = packet->wordCount;
          unint64_t v137 = (uint64_t (**)())packet->words;
          *(void *)&long long v138 = wordCount;
          *((void *)&v138 + 1) = packet->timeStamp;
          *(void *)&long long v139 = 0;
          uint64_t v57 = MIDIEventListInit(&evtlist, v10);
          *(void *)words = 0;
          *(void *)uint64_t v133 = 0;
          *(void *)&long long v134 = 0;
          while (MIDI::EventList::PacketReader::read((uint64_t *)&v137, words, v133))
          {
            uint64_t v57 = MIDIEventListAdd(&evtlist, 0x114uLL, v57, *(MIDITimeStamp *)words, MIDI::UniversalPacket::word_sizes[(unint64_t)v133[0] >> 28], v133);
            if (!v57)
            {
              OSStatus numPackets = v126(v127, v128, &evtlist);
              memset(&evtlist, 0, sizeof(evtlist));
              int v58 = MIDIEventListInit(&evtlist, v10);
              uint64_t v57 = MIDIEventListAdd(&evtlist, 0x114uLL, v58, *(MIDITimeStamp *)words, MIDI::UniversalPacket::word_sizes[(unint64_t)v133[0] >> 28], v133);
            }
          }
          if (evtlist.numPackets) {
            OSStatus numPackets = v126(v127, v128, &evtlist);
          }
          packet = (MIDIEventPacket *)((char *)packet + 4 * packet->wordCount + 12);
          ++v54;
        }
        while (v54 < evtList->numPackets);
      }
    }
    return numPackets;
  }
  unsigned int v123 = *(int **)(v7 + 112);
  if (v10 != kMIDIProtocol_2_0 || protocol != kMIDIProtocol_1_0)
  {
    BOOL v14 = v10 == kMIDIProtocol_1_0 && protocol == kMIDIProtocol_2_0;
    if (v14 && evtList->numPackets)
    {
      OSStatus numPackets = 0;
      int v15 = 0;
      int v16 = evtList->packet;
      uint64_t v113 = v123 + 521;
      while (1)
      {
        int v121 = v15;
        uint64_t v17 = v16->wordCount;
        unint64_t v137 = (uint64_t (**)())v16->words;
        *(void *)&long long v138 = v17;
        uint64_t v119 = v16;
        *((void *)&v138 + 1) = v16->timeStamp;
        *(void *)&long long v139 = 0;
        int v18 = MIDIEventListInit(&evtlist, kMIDIProtocol_1_0);
        time[0] = 0;
        *(void *)words = 0;
        uint64_t v132 = 0;
        while (MIDI::EventList::PacketReader::read((uint64_t *)&v137, time, words))
        {
          unint64_t v19 = (unint64_t)words[0] >> 28;
          if (((1 << v19) & 0xA02F) != 0)
          {
            int v18 = MIDIEventListAdd(&evtlist, 0x114uLL, v18, time[0], MIDI::UniversalPacket::word_sizes[v19], words);
            if (!v18)
            {
              OSStatus numPackets = v126(v127, v128, &evtlist);
              memset(&evtlist, 0, sizeof(evtlist));
              float64x2_t v20 = MIDIEventListInit(&evtlist, kMIDIProtocol_1_0);
              uint64_t v21 = MIDIEventListAdd(&evtlist, 0x114uLL, v20, time[0], MIDI::UniversalPacket::word_sizes[(unint64_t)words[0] >> 28], words);
LABEL_35:
              int v18 = v21;
            }
          }
          else if (v19 == 4)
          {
            UInt32 v22 = HIBYTE(words[0]) & 0xF | 0x20;
            UInt32 v23 = words[1];
            switch(BYTE2(words[0]) >> 4)
            {
              case 2:
              case 3:
                float64x2_t v25 = &v113[12 * (HIBYTE(words[0]) & 0xF)];
                unint64_t v26 = ((unint64_t)words[0] >> 16) & 0xF;
                float v27 = (unsigned __int8 *)v25 + 3 * v26;
                UInt32 v28 = (words[0] >> 8) & 0x7F;
                int v124 = words[0] & 0x7F;
                if ((words[0] & 0x100000) != 0) {
                  int v29 = 2;
                }
                else {
                  int v29 = 1;
                }
                if (v29 != *v27 || v28 != v27[1])
                {
                  int v30 = v26 | 0xB0;
LABEL_50:
                  char v114 = v29;
                  int v115 = (char *)v25 + 3 * v26;
                  unint64_t v117 = ((unint64_t)words[0] >> 16) & 0xF;
                  uint64_t v118 = &v113[12 * (HIBYTE(words[0]) & 0xF)];
                  if ((words[0] & 0x100000) != 0) {
                    int v33 = 25344;
                  }
                  else {
                    int v33 = 25856;
                  }
                  *(void *)&long long v134 = 0;
                  int v31 = (v22 << 24) | (v30 << 16);
                  char v116 = BYTE1(words[0]) & 0x7F;
                  *(void *)uint64_t v133 = v33 | v28 | v31;
                  int8x16_t v34 = MIDIEventListAdd(&evtlist, 0x114uLL, v18, time[0], 1uLL, v133);
                  if (v34)
                  {
                    MIDITimeStamp v32 = time[0];
                  }
                  else
                  {
                    OSStatus numPackets = v126(v127, v128, &evtlist);
                    memset(&evtlist, 0, sizeof(evtlist));
                    float64x2_t v38 = MIDIEventListInit(&evtlist, kMIDIProtocol_1_0);
                    MIDITimeStamp v32 = time[0];
                    int8x16_t v34 = MIDIEventListAdd(&evtlist, 0x114uLL, v38, time[0], MIDI::UniversalPacket::word_sizes[(unint64_t)v133[0] >> 28], v133);
                  }
                  *(void *)&long long v134 = 0;
                  *(void *)uint64_t v133 = v31 | (v33 - 256) | v124;
                  int v18 = MIDIEventListAdd(&evtlist, 0x114uLL, v34, v32, 1uLL, v133);
                  if (!v18)
                  {
                    OSStatus numPackets = v126(v127, v128, &evtlist);
                    memset(&evtlist, 0, sizeof(evtlist));
                    float64x2_t v39 = MIDIEventListInit(&evtlist, kMIDIProtocol_1_0);
                    int v18 = MIDIEventListAdd(&evtlist, 0x114uLL, v39, v32, MIDI::UniversalPacket::word_sizes[(unint64_t)v133[0] >> 28], v133);
                  }
                  *int v115 = v114;
                  uint64_t v40 = (uint64_t)v118 + 3 * v117;
                  *(unsigned char *)(v40 + 1) = v116;
                  *(unsigned char *)(v40 + 2) = v124;
                  goto LABEL_65;
                }
                int v30 = v26 | 0xB0;
                if (v124 != *((unsigned __int8 *)v25 + 3 * v26 + 2)) {
                  goto LABEL_50;
                }
                int v31 = (v30 << 16) | (v22 << 24);
                MIDITimeStamp v32 = time[0];
LABEL_65:
                *(void *)&long long v134 = 0;
                *(void *)uint64_t v133 = v31 | (v23 >> 25) | 0x600;
                int v18 = MIDIEventListAdd(&evtlist, 0x114uLL, v18, v32, 1uLL, v133);
                if (!v18)
                {
                  OSStatus numPackets = v126(v127, v128, &evtlist);
                  memset(&evtlist, 0, sizeof(evtlist));
                  float64x2_t v41 = MIDIEventListInit(&evtlist, kMIDIProtocol_1_0);
                  int v18 = MIDIEventListAdd(&evtlist, 0x114uLL, v41, time[0], MIDI::UniversalPacket::word_sizes[(unint64_t)v133[0] >> 28], v133);
                }
                int v42 = (v23 >> 18) & 0x7F;
                if (v42)
                {
                  *(void *)&long long v134 = 0;
                  *(void *)uint64_t v133 = v42 | v31 | 0x2600u;
                  MIDITimeStamp v43 = time[0];
                  int v18 = MIDIEventListAdd(&evtlist, 0x114uLL, v18, time[0], 1uLL, v133);
                  if (!v18)
                  {
                    OSStatus numPackets = v126(v127, v128, &evtlist);
                    memset(&evtlist, 0, sizeof(evtlist));
                    float64x2_t v44 = MIDIEventListInit(&evtlist, kMIDIProtocol_1_0);
                    uint64_t v21 = MIDIEventListAdd(&evtlist, 0x114uLL, v44, v43, MIDI::UniversalPacket::word_sizes[(unint64_t)v133[0] >> 28], v133);
                    goto LABEL_35;
                  }
                }
                break;
              case 8:
              case 9:
              case 10:
              case 11:
                UInt32 v24 = BYTE2(words[0]) >> 4 == 9;
                if (words[1] >> 25) {
                  UInt32 v24 = words[1] >> 25;
                }
                *(void *)&long long v134 = 0;
                *(void *)uint64_t v133 = words[0] & 0x7F00 | (BYTE2(words[0]) << 16) | (v22 << 24) | v24;
                int v18 = MIDIEventListAdd(&evtlist, 0x114uLL, v18, time[0], 1uLL, v133);
                if (!v18) {
                  goto LABEL_77;
                }
                continue;
              case 12:
                UInt32 v35 = v22 << 24;
                if (words[0])
                {
                  UInt32 v125 = v22 << 24;
                  *(void *)&long long v134 = 0;
                  int v36 = BYTE2(words[0]) << 16;
                  unint64_t v45 = (v36 - 0x100000) | (v22 << 24);
                  *(void *)uint64_t v133 = (v36 - 0x100000) & 0xFFFFFF80 | (v22 << 24) | (words[1] >> 8) & 0x7F;
                  ByteCount v46 = MIDI::UniversalPacket::word_sizes[v45 >> 28];
                  int64x2_t v47 = MIDIEventListAdd(&evtlist, 0x114uLL, v18, time[0], v46, v133);
                  if (v47)
                  {
                    MIDITimeStamp v48 = time[0];
                  }
                  else
                  {
                    OSStatus numPackets = v126(v127, v128, &evtlist);
                    memset(&evtlist, 0, sizeof(evtlist));
                    float v49 = MIDIEventListInit(&evtlist, kMIDIProtocol_1_0);
                    MIDITimeStamp v50 = time[0];
                    int64x2_t v47 = MIDIEventListAdd(&evtlist, 0x114uLL, v49, time[0], MIDI::UniversalPacket::word_sizes[(unint64_t)v133[0] >> 28], v133);
                    MIDITimeStamp v48 = v50;
                  }
                  *(void *)&long long v134 = 0;
                  *(void *)uint64_t v133 = v45 | v23 & 0x7F | 0x2000;
                  MIDITimeStamp v51 = v48;
                  int v18 = MIDIEventListAdd(&evtlist, 0x114uLL, v47, v48, v46, v133);
                  if (!v18)
                  {
                    OSStatus numPackets = v126(v127, v128, &evtlist);
                    memset(&evtlist, 0, sizeof(evtlist));
                    unsigned int v52 = MIDIEventListInit(&evtlist, kMIDIProtocol_1_0);
                    int v18 = MIDIEventListAdd(&evtlist, 0x114uLL, v52, v51, MIDI::UniversalPacket::word_sizes[(unint64_t)v133[0] >> 28], v133);
                  }
                  UInt32 v35 = v125;
                  MIDITimeStamp v37 = v51;
                }
                else
                {
                  int v36 = BYTE2(words[0]) << 16;
                  MIDITimeStamp v37 = time[0];
                }
                *(void *)&long long v134 = 0;
                *(void *)uint64_t v133 = v36 | v35 | HIWORD(v23) & 0x7F00;
                int v18 = MIDIEventListAdd(&evtlist, 0x114uLL, v18, v37, 1uLL, v133);
                if (!v18) {
                  goto LABEL_77;
                }
                continue;
              case 13:
                *(void *)&long long v134 = 0;
                *(void *)uint64_t v133 = (BYTE2(words[0]) << 16) | (v22 << 24) | (words[1] >> 25 << 8);
                int v18 = MIDIEventListAdd(&evtlist, 0x114uLL, v18, time[0], 1uLL, v133);
                if (!v18) {
                  goto LABEL_77;
                }
                continue;
              case 14:
                *(void *)&long long v134 = 0;
                *(void *)uint64_t v133 = (words[1] >> 10) & 0x7F00 | (words[1] >> 25) | (BYTE2(words[0]) << 16) | (v22 << 24);
                int v18 = MIDIEventListAdd(&evtlist, 0x114uLL, v18, time[0], 1uLL, v133);
                if (!v18)
                {
LABEL_77:
                  OSStatus numPackets = v126(v127, v128, &evtlist);
                  memset(&evtlist, 0, sizeof(evtlist));
                  int v53 = MIDIEventListInit(&evtlist, kMIDIProtocol_1_0);
                  uint64_t v21 = MIDIEventListAdd(&evtlist, 0x114uLL, v53, time[0], MIDI::UniversalPacket::word_sizes[(unint64_t)v133[0] >> 28], v133);
                  goto LABEL_35;
                }
                continue;
              default:
                continue;
            }
          }
        }
        if (evtlist.numPackets) {
          OSStatus numPackets = v126(v127, v128, &evtlist);
        }
        int v16 = (MIDIEventPacket *)&v119->words[v119->wordCount];
        int v15 = v121 + 1;
        if (v121 + 1 >= evtList->numPackets) {
          return numPackets;
        }
      }
    }
    return 0;
  }
  if (!evtList->numPackets) {
    return 0;
  }
  OSStatus numPackets = 0;
  UInt32 v59 = 0;
  int v122 = evtList;
  unint64_t v60 = evtList->packet;
  int v120 = v123 + 4;
  do
  {
    uint64_t v61 = v60->wordCount;
    unint64_t v137 = (uint64_t (**)())v60->words;
    *(void *)&long long v138 = v61;
    *((void *)&v138 + 1) = v60->timeStamp;
    *(void *)&long long v139 = 0;
    int v62 = MIDIEventListInit(&evtlist, kMIDIProtocol_2_0);
    time[1] = 0;
    MIDITimeStamp v130 = 0;
    time[0] = 0;
    while (MIDI::EventList::PacketReader::read((uint64_t *)&v137, &v130, time))
    {
      unint64_t v63 = LODWORD(time[0]);
      if (LODWORD(time[0]) >> 28 == 2)
      {
        *(void *)words = 0;
        uint64_t v132 = 0;
        int v66 = BYTE2(time[0]);
        int v67 = *((unsigned __int8 *)v123 + 32);
        int v68 = *v123;
        int v69 = BYTE2(time[0]) >> 4;
        if (*((unsigned char *)v123 + 32)) {
          goto LABEL_99;
        }
        if ((v68 & 0xFF0000) != 0)
        {
          if (((v68 ^ LODWORD(time[0])) & 0xF0000) != 0)
          {
            int v67 = 1;
            *((unsigned char *)v123 + 32) = 1;
            goto LABEL_99;
          }
          if (v69 != 11)
          {
            int v67 = (v68 & 0xDF00) != 0 || v69 != 12;
            goto LABEL_99;
          }
          switch(BYTE1(v68))
          {
            case 'b':
              int v98 = time[0] & 0xFF00;
              int v99 = 25344;
              goto LABEL_196;
            case 'c':
              int v98 = time[0] & 0xFF00;
              int v99 = 25088;
              goto LABEL_196;
            case 'd':
              int v98 = time[0] & 0xFF00;
              int v99 = 25856;
              goto LABEL_196;
            case 'e':
              int v98 = time[0] & 0xFF00;
              int v99 = 25600;
LABEL_196:
              if (v98 != v99 && (time[0] & 0xF0DF00) != 0xB00600) {
                break;
              }
              goto LABEL_200;
            default:
              if (BYTE1(v68) == 32)
              {
                if ((time[0] & 0xFF00) != 0) {
                  break;
                }
LABEL_200:
                int v67 = 0;
                *int v120 = *(_OWORD *)time;
                goto LABEL_99;
              }
              if (!BYTE1(v68) && (time[0] & 0xFF00) == 0x2000) {
                goto LABEL_200;
              }
              break;
          }
        }
        else
        {
          int v67 = 1;
          if ((time[0] & 0xF00000) != 0xB00000 || v69 != 11) {
            goto LABEL_99;
          }
          if (BYTE1(time[0]) - 98 < 4 || BYTE1(time[0]) == 32 || !BYTE1(time[0]))
          {
            int v67 = 0;
            *(_OWORD *)unsigned int v123 = *(_OWORD *)time;
            int v68 = *v123;
            goto LABEL_99;
          }
        }
        int v67 = 1;
LABEL_99:
        uint64_t v70 = BYTE3(v63) & 0xF;
        unsigned int v71 = BYTE3(v63) & 0xF | 0x40;
        if (BYTE2(v68) && v67)
        {
          *((unsigned char *)v123 + 32) = 1;
          *(void *)&long long v134 = 0;
          v133[0] = v68 & 0xFF00 | (BYTE2(v68) << 16) & 0x80FFFFFF | ((BYTE3(v63) & 0xF | 0x40) << 24);
          unsigned int v72 = v68;
          UInt32 v73 = v68 << 25;
          if (v72 >= 0x41)
          {
            unsigned int v74 = (v72 & 0x3F) << 19;
            if (v74)
            {
              do
              {
                v73 |= v74;
                BOOL v75 = v74 > 0x3F;
                v74 >>= 6;
              }
              while (v75);
            }
          }
          v133[1] = v73;
          int v62 = MIDIEventListAdd(&evtlist, 0x114uLL, v62, v130, 2uLL, v133);
          if (!v62)
          {
            OSStatus numPackets = v126(v127, v128, &evtlist);
            memset(&evtlist, 0, sizeof(evtlist));
            int v76 = MIDIEventListInit(&evtlist, kMIDIProtocol_2_0);
            int v62 = MIDIEventListAdd(&evtlist, 0x114uLL, v76, v130, MIDI::UniversalPacket::word_sizes[(unint64_t)v133[0] >> 28], v133);
          }
          int *v123 = 0;
          *(void *)&long long v134 = 0;
          int v77 = v123[4];
          if (BYTE2(v77))
          {
            LOWORD(v133[0]) = v77 & 0xFF00;
            BYTE2(v133[0]) = BYTE2(v77);
            HIBYTE(v133[0]) = BYTE3(v63) & 0xF | 0x40;
            unsigned int v78 = v77;
            UInt32 v79 = v77 << 25;
            if (v78 >= 0x41)
            {
              unsigned int v80 = (v78 & 0x3F) << 19;
              if (v80)
              {
                do
                {
                  v79 |= v80;
                  BOOL v75 = v80 > 0x3F;
                  v80 >>= 6;
                }
                while (v75);
              }
            }
            v133[1] = v79;
            MIDITimeStamp v81 = v130;
            int v62 = MIDIEventListAdd(&evtlist, 0x114uLL, v62, v130, 2uLL, v133);
            if (!v62)
            {
              OSStatus numPackets = v126(v127, v128, &evtlist);
              memset(&evtlist, 0, sizeof(evtlist));
              int v82 = MIDIEventListInit(&evtlist, kMIDIProtocol_2_0);
              int v62 = MIDIEventListAdd(&evtlist, 0x114uLL, v82, v81, MIDI::UniversalPacket::word_sizes[(unint64_t)v133[0] >> 28], v133);
            }
            *(_DWORD *)int v120 = 0;
          }
          int v66 = BYTE2(v63);
          int v69 = BYTE2(v63) >> 4;
          *(void *)((char *)&v123[32 * v70 + 8 + 2 * ((v63 >> 16) & 0xF)] + 1) = 0;
        }
        unsigned int v83 = (v63 >> 8) & 0x7F;
        unsigned int v84 = v63 & 0x7F;
        switch(v69)
        {
          case 8:
            goto LABEL_117;
          case 9:
            if ((v63 & 0x7F) == 0)
            {
              v66 -= 16;
              unsigned int v84 = 64;
            }
LABEL_117:
            UInt32 v85 = (v71 << 24) | (v66 << 16) | (v83 << 8);
            words[0] = v85;
            unsigned int v86 = v84 << 9;
            if (v84 >= 0x41)
            {
              unsigned int v87 = 8 * (v84 & 0x3F);
              if (v87)
              {
                do
                {
                  v86 |= v87;
                  BOOL v75 = v87 > 0x3F;
                  v87 >>= 6;
                }
                while (v75);
              }
            }
            UInt32 v88 = v86 << 16;
            goto LABEL_189;
          case 10:
            UInt32 v85 = (v66 << 16) | (v71 << 24) | (v83 << 8);
            words[0] = v85;
            UInt32 v88 = v63 << 25;
            if (v84 >= 0x41)
            {
              unsigned int v89 = (v63 & 0x3F) << 19;
              if (v89)
              {
                do
                {
                  v88 |= v89;
                  BOOL v75 = v89 > 0x3F;
                  v89 >>= 6;
                }
                while (v75);
              }
            }
            goto LABEL_189;
          case 11:
            uint64_t v90 = (uint64_t)&v123[32 * v70 + 8] + 1;
            uint64_t v91 = (v63 >> 16) & 0xF;
            if (((v63 >> 8) & 0x7F) > 0x25)
            {
              switch(v83)
              {
                case 'b':
                  uint64_t v100 = v90 + 8 * v91;
                  *(unsigned char *)(v100 + 1) = 2;
                  goto LABEL_182;
                case 'c':
                  uint64_t v110 = v90 + 8 * v91;
                  *(unsigned char *)(v110 + 1) = 2;
                  goto LABEL_184;
                case 'd':
                  uint64_t v100 = v90 + 8 * v91;
                  *(unsigned char *)(v100 + 1) = 1;
LABEL_182:
                  *(unsigned char *)(v100 + 5) = v84;
                  break;
                case 'e':
                  uint64_t v110 = v90 + 8 * v91;
                  *(unsigned char *)(v110 + 1) = 1;
LABEL_184:
                  *(unsigned char *)(v110 + 4) = v84;
                  break;
                default:
                  if (v83 != 38) {
                    goto LABEL_186;
                  }
                  char v102 = v63 & 0x7F;
                  int v103 = v63 & 0x7F;
                  goto LABEL_171;
              }
              goto LABEL_185;
            }
            if (!v83)
            {
              *(unsigned char *)(v90 + 8 * v91 + 2) = v84;
              goto LABEL_167;
            }
            if (v83 != 6)
            {
              if (v83 != 32) {
                goto LABEL_186;
              }
              *(unsigned char *)(v90 + 8 * v91 + 3) = v84;
LABEL_167:
              *(unsigned char *)(v90 + 8 * v91) = 1;
LABEL_185:
              if (!*((unsigned char *)v123 + 32)) {
                continue;
              }
              goto LABEL_186;
            }
            char v102 = 0;
            int v103 = 0;
            *(unsigned char *)(v90 + 8 * v91 + 6) = v84;
LABEL_171:
            uint64_t v104 = v90 + 8 * v91;
            *(unsigned char *)(v104 + 7) = v102;
            if (!*((unsigned char *)v123 + 32) && *(unsigned char *)(v104 + 1))
            {
              if (*(unsigned char *)(v104 + 1) == 1) {
                int v105 = 32;
              }
              else {
                int v105 = 48;
              }
              uint64_t v106 = (unsigned __int8 *)(v90 + 8 * v91);
              UInt32 v85 = (v71 << 24) | ((v105 | v91) << 16) | (v106[4] << 8) | v106[5];
              words[0] = v85;
              unsigned int v107 = v103 | (v106[6] << 7);
              UInt32 v108 = v107 << 18;
              if (v107 > 0x2000)
              {
                for (unsigned int i = 32 * (v107 & 0x1FFF); i; i >>= 13)
                  v108 |= i;
              }
              words[1] = v108;
              *(_OWORD *)unsigned int v123 = 0u;
              *((_OWORD *)v123 + 1) = 0u;
              goto LABEL_190;
            }
LABEL_186:
            UInt32 v85 = (v66 << 16) | (v71 << 24) | (v83 << 8);
            words[0] = v85;
            UInt32 v88 = v63 << 25;
            if (v84 >= 0x41)
            {
              unsigned int v111 = (v63 & 0x3F) << 19;
              if (v111)
              {
                do
                {
                  v88 |= v111;
                  BOOL v75 = v111 > 0x3F;
                  v111 >>= 6;
                }
                while (v75);
              }
            }
LABEL_189:
            words[1] = v88;
LABEL_190:
            int v62 = MIDIEventListAdd(&evtlist, 0x114uLL, v62, v130, MIDI::UniversalPacket::word_sizes[(unint64_t)v85 >> 28], words);
            if (v62) {
              continue;
            }
            OSStatus numPackets = v126(v127, v128, &evtlist);
            memset(&evtlist, 0, sizeof(evtlist));
            unint64_t v112 = MIDIEventListInit(&evtlist, kMIDIProtocol_2_0);
            uint64_t v65 = MIDIEventListAdd(&evtlist, 0x114uLL, v112, v130, MIDI::UniversalPacket::word_sizes[(unint64_t)words[0] >> 28], words);
            break;
          case 12:
            long long v92 = &v123[32 * v70 + 2 * (WORD1(v63) & 0xF)];
            unsigned __int8 v93 = *((unsigned char *)v123 + 32) ^ 1;
            if (!*((unsigned char *)v92 + 33)) {
              unsigned __int8 v93 = 0;
            }
            UInt32 v85 = (v66 << 16) | (v71 << 24) | v93;
            words[0] = v85;
            HIBYTE(words[1]) = BYTE1(v63) & 0x7F;
            BYTE1(words[1]) = *((unsigned char *)v92 + 35);
            LOBYTE(words[1]) = *((unsigned char *)v92 + 36);
            *(void *)((char *)v92 + 33) = 0;
            *(_OWORD *)unsigned int v123 = 0u;
            *((_OWORD *)v123 + 1) = 0u;
            goto LABEL_190;
          case 13:
            UInt32 v85 = (v66 << 16) | (v71 << 24);
            words[0] = v85;
            unsigned int v94 = v63 >> 8 << 25;
            if (v83 >= 0x41)
            {
              unsigned int v95 = ((v63 >> 8) & 0x3F) << 19;
              if (v95)
              {
                do
                {
                  v94 |= v95;
                  BOOL v75 = v95 > 0x3F;
                  v95 >>= 6;
                }
                while (v75);
              }
            }
            words[1] = v94;
            goto LABEL_190;
          case 14:
            UInt32 v85 = (v66 << 16) | (v71 << 24);
            words[0] = v85;
            unsigned int v96 = v83 | (v84 << 7);
            UInt32 v88 = v96 << 18;
            if (v96 > 0x2000)
            {
              for (unsigned int j = 32 * (v96 & 0x1FFF); j; j >>= 13)
                v88 |= j;
            }
            goto LABEL_189;
          default:
            UInt32 v85 = words[0];
            goto LABEL_190;
        }
LABEL_192:
        int v62 = v65;
      }
      else
      {
        int v62 = MIDIEventListAdd(&evtlist, 0x114uLL, v62, v130, MIDI::UniversalPacket::word_sizes[(unint64_t)LODWORD(time[0]) >> 28], (const UInt32 *)time);
        if (!v62)
        {
          OSStatus numPackets = v126(v127, v128, &evtlist);
          memset(&evtlist, 0, sizeof(evtlist));
          int v64 = MIDIEventListInit(&evtlist, kMIDIProtocol_2_0);
          uint64_t v65 = MIDIEventListAdd(&evtlist, 0x114uLL, v64, v130, MIDI::UniversalPacket::word_sizes[(unint64_t)LODWORD(time[0]) >> 28], (const UInt32 *)time);
          goto LABEL_192;
        }
      }
    }
    if (evtlist.numPackets) {
      OSStatus numPackets = v126(v127, v128, &evtlist);
    }
    unint64_t v60 = (MIDIEventPacket *)((char *)v60 + 4 * v60->wordCount + 12);
    ++v59;
  }
  while (v59 < v122->numPackets);
  return numPackets;
}

void sub_1901959F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

OSStatus MusicDeviceSysEx(MusicDeviceComponent inUnit, const UInt8 *inData, UInt32 inLength)
{
  if (!inUnit) {
    return -50;
  }
  uint64_t v3 = *(void *)&inLength;
  uint64_t v5 = (uint64_t (***)(void))(*(uint64_t (**)(MusicDeviceComponent))(*(void *)inUnit + 8))(inUnit);
  if (!v5) {
    return 560947818;
  }
  uint64_t v6 = v5;
  if (*(_WORD *)((**v5)(v5) + 38) != 24949) {
    return -3000;
  }
  (**v6)(v6);
  if (!v6[3]) {
    return -66740;
  }
  uint64_t v7 = *(void *)((**v6)(v6) + 112);
  if (*((unsigned char *)v6 + 88))
  {
    uint64_t v8 = v6[3];
    uint64_t v13 = inData;
    BOOL v14 = v8;
    int v12 = v3;
    return ((uint64_t (*)(uint64_t (***)(void), uint64_t (***)(void), uint64_t, const UInt8 **, int *))*v6[28])(v6 + 29, &v14, v7, &v13, &v12);
  }
  else
  {
    MIDIProtocolID v10 = *(uint64_t (**)(uint64_t (**)(void), const UInt8 *, uint64_t))(v7 + 168);
    if (v10)
    {
      uint64_t v11 = v6[3];
      return v10(v11, inData, v3);
    }
    else
    {
      return -4;
    }
  }
}

OSStatus MusicDeviceStopNote(MusicDeviceComponent inUnit, MusicDeviceGroupID inGroupID, NoteInstanceID inNoteInstanceID, UInt32 inOffsetSampleFrame)
{
  if (!inUnit) {
    return -50;
  }
  uint64_t v4 = *(void *)&inOffsetSampleFrame;
  uint64_t v5 = *(void *)&inNoteInstanceID;
  uint64_t v6 = *(void *)&inGroupID;
  uint64_t v7 = (uint64_t (***)(void))(*(uint64_t (**)(MusicDeviceComponent))(*(void *)inUnit + 8))(inUnit);
  if (!v7) {
    return 560947818;
  }
  uint64_t v8 = v7;
  if (*(_WORD *)((**v7)(v7) + 38) != 24949) {
    return -3000;
  }
  uint64_t v9 = *(uint64_t (**)(uint64_t (**)(void), uint64_t, uint64_t, uint64_t))(*(void *)((**v8)(v8) + 112)
                                                                                            + 184);
  if (!v9) {
    return -4;
  }
  MIDIProtocolID v10 = v8[3];
  return v9(v10, v6, v5, v4);
}

OSStatus AudioCodecSetProperty(AudioCodec inCodec, AudioCodecPropertyID inPropertyID, UInt32 inPropertyDataSize, const void *inPropertyData)
{
  if (!inCodec) {
    return -50;
  }
  uint64_t v5 = *(void *)&inPropertyDataSize;
  uint64_t v6 = *(void *)&inPropertyID;
  uint64_t v7 = (uint64_t (***)(void))(*(uint64_t (**)(AudioCodec))(*(void *)inCodec + 8))(inCodec);
  if (!v7) {
    return 560947818;
  }
  uint64_t v8 = v7;
  uint64_t v9 = *(uint64_t (**)(uint64_t (**)(void), uint64_t, uint64_t, const void *))(*(void *)((**v7)(v7) + 112)
                                                                                                 + 16);
  if (!v9) {
    return -4;
  }
  MIDIProtocolID v10 = v8[3];
  return v9(v10, v6, v5, inPropertyData);
}

OSStatus AudioCodecInitialize(AudioCodec inCodec, const AudioStreamBasicDescription *inInputFormat, const AudioStreamBasicDescription *inOutputFormat, const void *inMagicCookie, UInt32 inMagicCookieByteSize)
{
  if (!inCodec) {
    return -50;
  }
  uint64_t v5 = *(void *)&inMagicCookieByteSize;
  uint64_t v9 = (uint64_t (***)(void))(*(uint64_t (**)(AudioCodec))(*(void *)inCodec + 8))(inCodec);
  if (!v9) {
    return 560947818;
  }
  MIDIProtocolID v10 = v9;
  uint64_t v11 = *(uint64_t (**)(uint64_t (**)(void), const AudioStreamBasicDescription *, const AudioStreamBasicDescription *, const void *, uint64_t))(*(void *)((**v9)(v9) + 112) + 24);
  if (!v11) {
    return -4;
  }
  int v12 = v10[3];
  return v11(v12, inInputFormat, inOutputFormat, inMagicCookie, v5);
}

OSStatus AudioCodecUninitialize(AudioCodec inCodec)
{
  if (!inCodec) {
    return -50;
  }
  uint64_t v1 = (uint64_t (***)(void))(*(uint64_t (**)(AudioCodec))(*(void *)inCodec + 8))(inCodec);
  if (!v1) {
    return 560947818;
  }
  id v2 = v1;
  uint64_t v3 = *(uint64_t (**)(void))(*(void *)((**v1)(v1) + 112) + 32);
  if (!v3) {
    return -4;
  }
  uint64_t v4 = v2[3];
  return v3(v4);
}

OSStatus AudioCodecAppendInputData(AudioCodec inCodec, const void *inInputData, UInt32 *ioInputDataByteSize, UInt32 *ioNumberPackets, const AudioStreamPacketDescription *inPacketDescription)
{
  if (!inCodec) {
    return -50;
  }
  uint64_t v9 = (uint64_t (***)(void))(*(uint64_t (**)(AudioCodec))(*(void *)inCodec + 8))(inCodec);
  if (!v9) {
    return 560947818;
  }
  MIDIProtocolID v10 = v9;
  uint64_t v11 = *(uint64_t (**)(uint64_t (**)(void), const void *, UInt32 *, UInt32 *, const AudioStreamPacketDescription *))(*(void *)((**v9)(v9) + 112) + 40);
  if (!v11) {
    return -4;
  }
  int v12 = v10[3];
  return v11(v12, inInputData, ioInputDataByteSize, ioNumberPackets, inPacketDescription);
}

OSStatus AudioCodecProduceOutputPackets(AudioCodec inCodec, void *outOutputData, UInt32 *ioOutputDataByteSize, UInt32 *ioNumberPackets, AudioStreamPacketDescription *outPacketDescription, UInt32 *outStatus)
{
  if (!inCodec) {
    return -50;
  }
  uint64_t v11 = (uint64_t (***)(void))(*(uint64_t (**)(AudioCodec))(*(void *)inCodec + 8))(inCodec);
  int v12 = v11;
  if (ioOutputDataByteSize)
  {
    UInt32 v13 = *ioOutputDataByteSize;
    if (v11) {
      goto LABEL_4;
    }
LABEL_9:
    OSStatus result = 560947818;
    if (!ioOutputDataByteSize) {
      return result;
    }
    goto LABEL_12;
  }
  UInt32 v13 = 0;
  if (!v11) {
    goto LABEL_9;
  }
LABEL_4:
  BOOL v14 = *(uint64_t (**)(uint64_t (**)(void), void *, UInt32 *, UInt32 *, AudioStreamPacketDescription *, UInt32 *))(*(void *)((**v11)(v11) + 112) + 48);
  if (v14)
  {
    OSStatus result = v14(v12[3], outOutputData, ioOutputDataByteSize, ioNumberPackets, outPacketDescription, outStatus);
    if (!ioOutputDataByteSize) {
      return result;
    }
  }
  else
  {
    OSStatus result = -4;
    if (!ioOutputDataByteSize) {
      return result;
    }
  }
LABEL_12:
  if (*ioOutputDataByteSize > v13)
  {
    _os_assert_log();
    OSStatus result = _os_crash();
    __break(1u);
  }
  return result;
}

OSStatus AudioCodecAppendInputBufferList(AudioCodec inCodec, const AudioBufferList *inBufferList, UInt32 *ioNumberPackets, const AudioStreamPacketDescription *inPacketDescription, UInt32 *outBytesConsumed)
{
  if (!inCodec) {
    return -50;
  }
  uint64_t v9 = (uint64_t (***)(void))(*(uint64_t (**)(AudioCodec))(*(void *)inCodec + 8))(inCodec);
  if (!v9) {
    return 560947818;
  }
  MIDIProtocolID v10 = v9;
  uint64_t v11 = *(uint64_t (**)(uint64_t (**)(void), const AudioBufferList *, UInt32 *, const AudioStreamPacketDescription *, UInt32 *))(*(void *)((**v9)(v9) + 112) + 64);
  if (!v11) {
    return -4;
  }
  int v12 = v10[3];
  return v11(v12, inBufferList, ioNumberPackets, inPacketDescription, outBytesConsumed);
}

OSStatus AudioCodecProduceOutputBufferList(AudioCodec inCodec, AudioBufferList *ioBufferList, UInt32 *ioNumberPackets, AudioStreamPacketDescription *outPacketDescription, UInt32 *outStatus)
{
  if (!inCodec) {
    return -50;
  }
  uint64_t v9 = (uint64_t (***)(void))(*(uint64_t (**)(AudioCodec))(*(void *)inCodec + 8))(inCodec);
  MIDIProtocolID v10 = v9;
  if (ioBufferList && ioBufferList->mNumberBuffers)
  {
    UInt32 mDataByteSize = ioBufferList->mBuffers[0].mDataByteSize;
    int v12 = 1;
    if (!v9) {
      goto LABEL_5;
    }
  }
  else
  {
    int v12 = 0;
    UInt32 mDataByteSize = 0;
    if (!v9)
    {
LABEL_5:
      OSStatus result = 560947818;
      if (!v12) {
        return result;
      }
      goto LABEL_13;
    }
  }
  BOOL v14 = *(uint64_t (**)(uint64_t (**)(void), AudioBufferList *, UInt32 *, AudioStreamPacketDescription *, UInt32 *))(*(void *)((**v9)(v9) + 112) + 72);
  if (v14)
  {
    OSStatus result = v14(v10[3], ioBufferList, ioNumberPackets, outPacketDescription, outStatus);
    if (!v12) {
      return result;
    }
  }
  else
  {
    OSStatus result = -4;
    if (!v12) {
      return result;
    }
  }
LABEL_13:
  if (ioBufferList->mBuffers[0].mDataByteSize > mDataByteSize)
  {
    _os_assert_log();
    OSStatus result = _os_crash();
    __break(1u);
  }
  return result;
}

OSStatus AudioCodecReset(AudioCodec inCodec)
{
  if (!inCodec) {
    return -50;
  }
  uint64_t v1 = (uint64_t (***)(void))(*(uint64_t (**)(AudioCodec))(*(void *)inCodec + 8))(inCodec);
  if (!v1) {
    return 560947818;
  }
  id v2 = v1;
  uint64_t v3 = *(uint64_t (**)(void))(*(void *)((**v1)(v1) + 112) + 56);
  if (!v3) {
    return -4;
  }
  uint64_t v4 = v2[3];
  return v3(v4);
}

void std::__introsort<std::_ClassicAlgPolicy,AUParameterCache::AUParameterCache(OpaqueAudioComponentInstance *)::$_0 &,AUFlatParameterInfoBlob::Parameter *,false>(unint64_t a1, unint64_t a2, uint64_t a3, char a4)
{
  while (2)
  {
    MIDIProtocolID v10 = (long long *)(a2 - 52);
    unint64_t v11 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v11;
          uint64_t v12 = a2 - v11;
          unint64_t v13 = 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(a2 - v11) >> 2);
          if (v5 || !v4)
          {
            switch(v13)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                if (*(void *)(a2 - 44) < *(void *)(v11 + 8))
                {
                  int v180 = *(_DWORD *)(v11 + 48);
                  long long v162 = *(_OWORD *)(v11 + 16);
                  long long v171 = *(_OWORD *)(v11 + 32);
                  long long v153 = *(_OWORD *)v11;
                  long long v59 = *v10;
                  long long v60 = *(_OWORD *)(a2 - 36);
                  long long v61 = *(_OWORD *)(a2 - 20);
                  *(_DWORD *)(v11 + 48) = *(_DWORD *)(a2 - 4);
                  *(_OWORD *)(v11 + 16) = v60;
                  *(_OWORD *)(v11 + 32) = v61;
                  *(_OWORD *)unint64_t v11 = v59;
                  *(_DWORD *)(a2 - 4) = v180;
                  *(_OWORD *)(a2 - 36) = v162;
                  *(_OWORD *)(a2 - 20) = v171;
                  *MIDIProtocolID v10 = v153;
                }
                break;
              case 3uLL:
                std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AUParameterCache::AUParameterCache(OpaqueAudioComponentInstance *)::$_0 &,AUFlatParameterInfoBlob::Parameter *>((long long *)v11, (long long *)(v11 + 52), (long long *)(a2 - 52));
                break;
              case 4uLL:
                std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,AUParameterCache::AUParameterCache(OpaqueAudioComponentInstance *)::$_0 &,AUFlatParameterInfoBlob::Parameter *>(v11, v11 + 52, v11 + 104, (long long *)(a2 - 52));
                break;
              case 5uLL:
                int v62 = (long long *)(v11 + 52);
                unint64_t v63 = (long long *)(v11 + 104);
                int v64 = (long long *)(v11 + 156);
                std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,AUParameterCache::AUParameterCache(OpaqueAudioComponentInstance *)::$_0 &,AUFlatParameterInfoBlob::Parameter *>(v11, v11 + 52, v11 + 104, (long long *)(v11 + 156));
                if (*(void *)(a2 - 44) < *(void *)(v11 + 164))
                {
                  long long v65 = *v64;
                  long long v163 = *(_OWORD *)(v11 + 172);
                  long long v66 = *(_OWORD *)(v11 + 188);
                  int v67 = *(_DWORD *)(v11 + 204);
                  int v68 = *(_DWORD *)(a2 - 4);
                  long long v70 = *(_OWORD *)(a2 - 36);
                  long long v69 = *(_OWORD *)(a2 - 20);
                  *int v64 = *v10;
                  *(_OWORD *)(v11 + 172) = v70;
                  *(_OWORD *)(v11 + 188) = v69;
                  *(_DWORD *)(v11 + 204) = v68;
                  *(_OWORD *)(a2 - 36) = v163;
                  *(_OWORD *)(a2 - 20) = v66;
                  *(_DWORD *)(a2 - 4) = v67;
                  *MIDIProtocolID v10 = v65;
                  if (*(void *)(v11 + 164) < *(void *)(v11 + 112))
                  {
                    int v71 = *(_DWORD *)(v11 + 152);
                    long long v73 = *(_OWORD *)(v11 + 120);
                    long long v72 = *(_OWORD *)(v11 + 136);
                    long long v74 = *v63;
                    long long v75 = *(_OWORD *)(v11 + 172);
                    *unint64_t v63 = *v64;
                    *(_OWORD *)(v11 + 120) = v75;
                    *(_OWORD *)(v11 + 136) = *(_OWORD *)(v11 + 188);
                    *(_DWORD *)(v11 + 152) = *(_DWORD *)(v11 + 204);
                    *int v64 = v74;
                    *(_OWORD *)(v11 + 172) = v73;
                    *(_OWORD *)(v11 + 188) = v72;
                    *(_DWORD *)(v11 + 204) = v71;
                    if (*(void *)(v11 + 112) < *(void *)(v11 + 60))
                    {
                      int v76 = *(_DWORD *)(v11 + 100);
                      long long v78 = *(_OWORD *)(v11 + 68);
                      long long v77 = *(_OWORD *)(v11 + 84);
                      long long v79 = *v62;
                      long long v80 = *(_OWORD *)(v11 + 120);
                      long long *v62 = *v63;
                      *(_OWORD *)(v11 + 68) = v80;
                      *(_OWORD *)(v11 + 84) = *(_OWORD *)(v11 + 136);
                      *(_DWORD *)(v11 + 100) = *(_DWORD *)(v11 + 152);
                      *unint64_t v63 = v79;
                      *(_OWORD *)(v11 + 120) = v78;
                      *(_OWORD *)(v11 + 136) = v77;
                      *(_DWORD *)(v11 + 152) = v76;
                      if (*(void *)(v11 + 60) < *(void *)(v11 + 8))
                      {
                        int v181 = *(_DWORD *)(v11 + 48);
                        long long v164 = *(_OWORD *)(v11 + 16);
                        long long v172 = *(_OWORD *)(v11 + 32);
                        long long v154 = *(_OWORD *)v11;
                        long long v81 = *(_OWORD *)(v11 + 68);
                        *(_OWORD *)unint64_t v11 = *v62;
                        *(_OWORD *)(v11 + 16) = v81;
                        *(_OWORD *)(v11 + 32) = *(_OWORD *)(v11 + 84);
                        *(_DWORD *)(v11 + 48) = *(_DWORD *)(v11 + 100);
                        *(_DWORD *)(v11 + 100) = v181;
                        *(_OWORD *)(v11 + 68) = v164;
                        *(_OWORD *)(v11 + 84) = v172;
                        long long *v62 = v154;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v12 <= 1247)
          {
            int v82 = (void *)(v11 + 52);
            BOOL v84 = v11 == a2 || v82 == (void *)a2;
            if (a4)
            {
              if (!v84)
              {
                uint64_t v85 = 0;
                unsigned int v86 = (void *)v11;
                do
                {
                  unsigned int v87 = v82;
                  unint64_t v88 = *(void *)((char *)v86 + 60);
                  if (v88 < v86[1])
                  {
                    uint64_t v89 = *v87;
                    long long v155 = *(_OWORD *)((char *)v86 + 68);
                    long long v165 = *(_OWORD *)((char *)v86 + 84);
                    int v173 = *((_DWORD *)v86 + 25);
                    uint64_t v90 = v85;
                    while (1)
                    {
                      uint64_t v91 = v11 + v90;
                      long long v92 = *(_OWORD *)(v11 + v90 + 16);
                      *(_OWORD *)(v91 + 52) = *(_OWORD *)(v11 + v90);
                      *(_OWORD *)(v91 + 68) = v92;
                      *(_OWORD *)(v91 + 84) = *(_OWORD *)(v11 + v90 + 32);
                      *(_DWORD *)(v91 + 100) = *(_DWORD *)(v11 + v90 + 48);
                      if (!v90) {
                        break;
                      }
                      v90 -= 52;
                      if (v88 >= *(void *)(v91 - 44))
                      {
                        uint64_t v93 = v11 + v90 + 52;
                        goto LABEL_83;
                      }
                    }
                    uint64_t v93 = v11;
LABEL_83:
                    *(void *)uint64_t v93 = v89;
                    *(void *)(v93 + 8) = v88;
                    *(_OWORD *)(v93 + 16) = v155;
                    *(_OWORD *)(v93 + 32) = v165;
                    *(_DWORD *)(v93 + 48) = v173;
                  }
                  int v82 = (void *)((char *)v87 + 52);
                  v85 += 52;
                  unsigned int v86 = v87;
                }
                while ((void *)((char *)v87 + 52) != (void *)a2);
              }
            }
            else if (!v84)
            {
              do
              {
                uint64_t v136 = v82;
                unint64_t v137 = *(void *)(a1 + 60);
                if (v137 < *(void *)(a1 + 8))
                {
                  uint64_t v138 = *v82;
                  long long v158 = *(_OWORD *)(a1 + 68);
                  long long v168 = *(_OWORD *)(a1 + 84);
                  int v176 = *(_DWORD *)(a1 + 100);
                  long long v139 = v136;
                  do
                  {
                    long long v140 = *(_OWORD *)((char *)v139 - 36);
                    *(_OWORD *)long long v139 = *(_OWORD *)((char *)v139 - 52);
                    *((_OWORD *)v139 + 1) = v140;
                    *((_OWORD *)v139 + 2) = *(_OWORD *)((char *)v139 - 20);
                    *((_DWORD *)v139 + 12) = *((_DWORD *)v139 - 1);
                    unint64_t v141 = *(v139 - 12);
                    long long v139 = (void *)((char *)v139 - 52);
                  }
                  while (v137 < v141);
                  *long long v139 = v138;
                  v139[1] = v137;
                  *((_DWORD *)v139 + 12) = v176;
                  *((_OWORD *)v139 + 1) = v158;
                  *((_OWORD *)v139 + 2) = v168;
                }
                int v82 = (void *)((char *)v136 + 52);
                a1 = (unint64_t)v136;
              }
              while ((void *)((char *)v136 + 52) != (void *)a2);
            }
            return;
          }
          if (!a3)
          {
            if (v11 != a2)
            {
              int64_t v94 = (v13 - 2) >> 1;
              int64_t v95 = v94;
              do
              {
                int64_t v96 = v95;
                if (v94 >= v95)
                {
                  uint64_t v97 = (2 * v95) | 1;
                  unint64_t v98 = v11 + 52 * v97;
                  if (2 * v96 + 2 < (uint64_t)v13)
                  {
                    unint64_t v99 = *(void *)(v11 + 52 * v97 + 8);
                    unint64_t v100 = *(void *)(v98 + 60);
                    v98 += 52 * (v99 < v100);
                    if (v99 < v100) {
                      uint64_t v97 = 2 * v96 + 2;
                    }
                  }
                  unint64_t v101 = *(void *)(v11 + 52 * v96 + 8);
                  if (*(void *)(v98 + 8) >= v101)
                  {
                    unint64_t v102 = v11 + 52 * v96;
                    uint64_t v103 = *(void *)v102;
                    int v174 = *(_DWORD *)(v102 + 48);
                    long long v156 = *(_OWORD *)(v102 + 16);
                    long long v166 = *(_OWORD *)(v102 + 32);
                    do
                    {
                      unint64_t v104 = v102;
                      unint64_t v102 = v98;
                      long long v105 = *(_OWORD *)v98;
                      long long v106 = *(_OWORD *)(v98 + 16);
                      long long v107 = *(_OWORD *)(v98 + 32);
                      *(_DWORD *)(v104 + 48) = *(_DWORD *)(v98 + 48);
                      *(_OWORD *)(v104 + 16) = v106;
                      *(_OWORD *)(v104 + 32) = v107;
                      *(_OWORD *)unint64_t v104 = v105;
                      if (v94 < v97) {
                        break;
                      }
                      uint64_t v108 = (2 * v97) | 1;
                      unint64_t v98 = v11 + 52 * v108;
                      uint64_t v109 = 2 * v97 + 2;
                      if (v109 < (uint64_t)v13)
                      {
                        unint64_t v110 = *(void *)(v11 + 52 * v108 + 8);
                        unint64_t v111 = *(void *)(v98 + 60);
                        v98 += 52 * (v110 < v111);
                        if (v110 < v111) {
                          uint64_t v108 = v109;
                        }
                      }
                      uint64_t v97 = v108;
                    }
                    while (*(void *)(v98 + 8) >= v101);
                    *(void *)unint64_t v102 = v103;
                    *(void *)(v102 + 8) = v101;
                    *(_OWORD *)(v102 + 16) = v156;
                    *(_OWORD *)(v102 + 32) = v166;
                    *(_DWORD *)(v102 + 48) = v174;
                  }
                }
                int64_t v95 = v96 - 1;
              }
              while (v96);
              int64_t v112 = v12 / 0x34uLL;
              do
              {
                uint64_t v113 = 0;
                int v182 = *(_DWORD *)(v11 + 48);
                long long v167 = *(_OWORD *)(v11 + 16);
                long long v175 = *(_OWORD *)(v11 + 32);
                long long v157 = *(_OWORD *)v11;
                unint64_t v114 = v11;
                do
                {
                  uint64_t v115 = v113 + 1;
                  unint64_t v116 = v114 + 52 * (v113 + 1);
                  uint64_t v117 = (2 * v113) | 1;
                  uint64_t v118 = 2 * v113 + 2;
                  if (v118 < v112)
                  {
                    unint64_t v119 = *(void *)(v114 + 52 * v115 + 8);
                    unint64_t v120 = *(void *)(v116 + 60);
                    v116 += 52 * (v119 < v120);
                    if (v119 < v120) {
                      uint64_t v117 = v118;
                    }
                  }
                  long long v121 = *(_OWORD *)v116;
                  long long v122 = *(_OWORD *)(v116 + 16);
                  long long v123 = *(_OWORD *)(v116 + 32);
                  *(_DWORD *)(v114 + 48) = *(_DWORD *)(v116 + 48);
                  *(_OWORD *)(v114 + 16) = v122;
                  *(_OWORD *)(v114 + 32) = v123;
                  *(_OWORD *)unint64_t v114 = v121;
                  unint64_t v114 = v116;
                  uint64_t v113 = v117;
                }
                while (v117 <= (uint64_t)((unint64_t)(v112 - 2) >> 1));
                a2 -= 52;
                if (v116 == a2)
                {
                  *(_DWORD *)(v116 + 48) = v182;
                  *(_OWORD *)(v116 + 16) = v167;
                  *(_OWORD *)(v116 + 32) = v175;
                  *(_OWORD *)unint64_t v116 = v157;
                }
                else
                {
                  long long v124 = *(_OWORD *)a2;
                  long long v125 = *(_OWORD *)(a2 + 16);
                  long long v126 = *(_OWORD *)(a2 + 32);
                  *(_DWORD *)(v116 + 48) = *(_DWORD *)(a2 + 48);
                  *(_OWORD *)(v116 + 16) = v125;
                  *(_OWORD *)(v116 + 32) = v126;
                  *(_OWORD *)unint64_t v116 = v124;
                  *(_DWORD *)(a2 + 48) = v182;
                  *(_OWORD *)(a2 + 16) = v167;
                  *(_OWORD *)(a2 + 32) = v175;
                  *(_OWORD *)a2 = v157;
                  uint64_t v127 = v116 - v11 + 52;
                  if (v127 >= 53)
                  {
                    unint64_t v128 = (v127 / 0x34uLL - 2) >> 1;
                    unint64_t v129 = *(void *)(v116 + 8);
                    if (*(void *)(v11 + 52 * v128 + 8) < v129)
                    {
                      uint64_t v130 = *(void *)v116;
                      int v150 = *(_DWORD *)(v116 + 48);
                      long long v144 = *(_OWORD *)(v116 + 16);
                      long long v147 = *(_OWORD *)(v116 + 32);
                      do
                      {
                        unint64_t v131 = v116;
                        unint64_t v116 = v11 + 52 * v128;
                        long long v132 = *(_OWORD *)v116;
                        long long v133 = *(_OWORD *)(v116 + 16);
                        long long v134 = *(_OWORD *)(v116 + 32);
                        *(_DWORD *)(v131 + 48) = *(_DWORD *)(v116 + 48);
                        *(_OWORD *)(v131 + 16) = v133;
                        *(_OWORD *)(v131 + 32) = v134;
                        *(_OWORD *)unint64_t v131 = v132;
                        if (!v128) {
                          break;
                        }
                        unint64_t v128 = (v128 - 1) >> 1;
                      }
                      while (*(void *)(v11 + 52 * v128 + 8) < v129);
                      *(void *)unint64_t v116 = v130;
                      *(void *)(v116 + 8) = v129;
                      *(_DWORD *)(v116 + 48) = v150;
                      *(_OWORD *)(v116 + 16) = v144;
                      *(_OWORD *)(v116 + 32) = v147;
                    }
                  }
                }
              }
              while (v112-- > 2);
            }
            return;
          }
          unint64_t v14 = v13 >> 1;
          unint64_t v15 = v11 + 52 * (v13 >> 1);
          if ((unint64_t)v12 >= 0x1A01)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AUParameterCache::AUParameterCache(OpaqueAudioComponentInstance *)::$_0 &,AUFlatParameterInfoBlob::Parameter *>((long long *)a1, (long long *)(a1 + 52 * (v13 >> 1)), (long long *)(a2 - 52));
            uint64_t v16 = 52 * v14;
            uint64_t v17 = (long long *)(52 * v14 + a1 - 52);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AUParameterCache::AUParameterCache(OpaqueAudioComponentInstance *)::$_0 &,AUFlatParameterInfoBlob::Parameter *>((long long *)(a1 + 52), v17, (long long *)(a2 - 104));
            int v18 = (long long *)(a1 + 52 + v16);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AUParameterCache::AUParameterCache(OpaqueAudioComponentInstance *)::$_0 &,AUFlatParameterInfoBlob::Parameter *>((long long *)(a1 + 104), v18, (long long *)(a2 - 156));
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AUParameterCache::AUParameterCache(OpaqueAudioComponentInstance *)::$_0 &,AUFlatParameterInfoBlob::Parameter *>(v17, (long long *)v15, v18);
            int v177 = *(_DWORD *)(a1 + 48);
            long long v159 = *(_OWORD *)(a1 + 16);
            long long v169 = *(_OWORD *)(a1 + 32);
            long long v151 = *(_OWORD *)a1;
            long long v19 = *(_OWORD *)v15;
            long long v20 = *(_OWORD *)(v15 + 16);
            long long v21 = *(_OWORD *)(v15 + 32);
            *(_DWORD *)(a1 + 48) = *(_DWORD *)(v15 + 48);
            *(_OWORD *)(a1 + 16) = v20;
            *(_OWORD *)(a1 + 32) = v21;
            *(_OWORD *)a1 = v19;
            *(_DWORD *)(v15 + 48) = v177;
            *(_OWORD *)(v15 + 16) = v159;
            *(_OWORD *)(v15 + 32) = v169;
            *(_OWORD *)unint64_t v15 = v151;
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AUParameterCache::AUParameterCache(OpaqueAudioComponentInstance *)::$_0 &,AUFlatParameterInfoBlob::Parameter *>((long long *)(a1 + 52 * (v13 >> 1)), (long long *)a1, (long long *)(a2 - 52));
          }
          --a3;
          if (a4) {
            break;
          }
          unint64_t v22 = *(void *)(a1 + 8);
          if (*(void *)(a1 - 44) < v22) {
            goto LABEL_12;
          }
          uint64_t v43 = *(void *)a1;
          int v149 = *(_DWORD *)(a1 + 48);
          long long v143 = *(_OWORD *)(a1 + 16);
          long long v146 = *(_OWORD *)(a1 + 32);
          if (v22 >= *(void *)(a2 - 44))
          {
            unint64_t v46 = a1 + 52;
            do
            {
              unint64_t v11 = v46;
              if (v46 >= a2) {
                break;
              }
              unint64_t v47 = *(void *)(v46 + 8);
              v46 += 52;
            }
            while (v22 >= v47);
          }
          else
          {
            unint64_t v44 = a1;
            do
            {
              unint64_t v11 = v44 + 52;
              unint64_t v45 = *(void *)(v44 + 60);
              v44 += 52;
            }
            while (v22 >= v45);
          }
          unint64_t v48 = a2;
          if (v11 < a2)
          {
            unint64_t v49 = a2;
            do
            {
              unint64_t v48 = v49 - 52;
              unint64_t v50 = *(void *)(v49 - 44);
              v49 -= 52;
            }
            while (v22 < v50);
          }
          while (v11 < v48)
          {
            int v179 = *(_DWORD *)(v11 + 48);
            long long v161 = *(_OWORD *)(v11 + 16);
            long long v170 = *(_OWORD *)(v11 + 32);
            long long v152 = *(_OWORD *)v11;
            long long v51 = *(_OWORD *)v48;
            long long v52 = *(_OWORD *)(v48 + 16);
            long long v53 = *(_OWORD *)(v48 + 32);
            *(_DWORD *)(v11 + 48) = *(_DWORD *)(v48 + 48);
            *(_OWORD *)(v11 + 16) = v52;
            *(_OWORD *)(v11 + 32) = v53;
            *(_OWORD *)unint64_t v11 = v51;
            *(_DWORD *)(v48 + 48) = v179;
            *(_OWORD *)(v48 + 16) = v161;
            *(_OWORD *)(v48 + 32) = v170;
            *(_OWORD *)unint64_t v48 = v152;
            do
            {
              unint64_t v54 = *(void *)(v11 + 60);
              v11 += 52;
            }
            while (v22 >= v54);
            do
            {
              unint64_t v55 = *(void *)(v48 - 44);
              v48 -= 52;
            }
            while (v22 < v55);
          }
          BOOL v4 = v11 - 52 >= a1;
          BOOL v5 = v11 - 52 == a1;
          if (v11 - 52 != a1)
          {
            long long v56 = *(_OWORD *)(v11 - 52);
            long long v57 = *(_OWORD *)(v11 - 36);
            long long v58 = *(_OWORD *)(v11 - 20);
            *(_DWORD *)(a1 + 48) = *(_DWORD *)(v11 - 4);
            *(_OWORD *)(a1 + 16) = v57;
            *(_OWORD *)(a1 + 32) = v58;
            *(_OWORD *)a1 = v56;
          }
          a4 = 0;
          *(void *)(v11 - 52) = v43;
          *(void *)(v11 - 44) = v22;
          *(_DWORD *)(v11 - 4) = v149;
          *(_OWORD *)(v11 - 20) = v146;
          *(_OWORD *)(v11 - 36) = v143;
        }
        unint64_t v22 = *(void *)(a1 + 8);
LABEL_12:
        uint64_t v23 = *(void *)a1;
        int v148 = *(_DWORD *)(a1 + 48);
        long long v142 = *(_OWORD *)(a1 + 16);
        long long v145 = *(_OWORD *)(a1 + 32);
        unint64_t v24 = a1;
        do
        {
          unint64_t v25 = v24;
          v24 += 52;
        }
        while (*(void *)(v25 + 60) < v22);
        unint64_t v26 = a2;
        if (v25 == a1)
        {
          unint64_t v29 = a2;
          while (v24 < v29)
          {
            unint64_t v27 = v29 - 52;
            unint64_t v30 = *(void *)(v29 - 44);
            v29 -= 52;
            if (v30 < v22) {
              goto LABEL_22;
            }
          }
          unint64_t v27 = v29;
        }
        else
        {
          do
          {
            unint64_t v27 = v26 - 52;
            unint64_t v28 = *(void *)(v26 - 44);
            v26 -= 52;
          }
          while (v28 >= v22);
        }
LABEL_22:
        unint64_t v11 = v24;
        if (v24 < v27)
        {
          unint64_t v31 = v27;
          do
          {
            long long v32 = *(_OWORD *)v11;
            long long v160 = *(_OWORD *)(v11 + 16);
            long long v33 = *(_OWORD *)(v11 + 32);
            int v178 = *(_DWORD *)(v11 + 48);
            int v34 = *(_DWORD *)(v31 + 48);
            long long v36 = *(_OWORD *)(v31 + 16);
            long long v35 = *(_OWORD *)(v31 + 32);
            *(_OWORD *)unint64_t v11 = *(_OWORD *)v31;
            *(_OWORD *)(v11 + 16) = v36;
            *(_OWORD *)(v11 + 32) = v35;
            *(_DWORD *)(v11 + 48) = v34;
            *(_OWORD *)(v31 + 16) = v160;
            *(_OWORD *)(v31 + 32) = v33;
            *(_DWORD *)(v31 + 48) = v178;
            *(_OWORD *)unint64_t v31 = v32;
            do
            {
              unint64_t v37 = *(void *)(v11 + 60);
              v11 += 52;
            }
            while (v37 < v22);
            do
            {
              unint64_t v38 = *(void *)(v31 - 44);
              v31 -= 52;
            }
            while (v38 >= v22);
          }
          while (v11 < v31);
        }
        if (v11 - 52 != a1)
        {
          long long v39 = *(_OWORD *)(v11 - 52);
          long long v40 = *(_OWORD *)(v11 - 36);
          long long v41 = *(_OWORD *)(v11 - 20);
          *(_DWORD *)(a1 + 48) = *(_DWORD *)(v11 - 4);
          *(_OWORD *)(a1 + 16) = v40;
          *(_OWORD *)(a1 + 32) = v41;
          *(_OWORD *)a1 = v39;
        }
        *(void *)(v11 - 52) = v23;
        *(void *)(v11 - 44) = v22;
        *(_DWORD *)(v11 - 4) = v148;
        *(_OWORD *)(v11 - 20) = v145;
        *(_OWORD *)(v11 - 36) = v142;
        if (v24 >= v27) {
          break;
        }
LABEL_33:
        std::__introsort<std::_ClassicAlgPolicy,AUParameterCache::AUParameterCache(OpaqueAudioComponentInstance *)::$_0 &,AUFlatParameterInfoBlob::Parameter *,false>(a1, v11 - 52, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v42 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,AUParameterCache::AUParameterCache(OpaqueAudioComponentInstance *)::$_0 &,AUFlatParameterInfoBlob::Parameter *>(a1, v11 - 52);
      if (std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,AUParameterCache::AUParameterCache(OpaqueAudioComponentInstance *)::$_0 &,AUFlatParameterInfoBlob::Parameter *>(v11, a2))
      {
        break;
      }
      if (!v42) {
        goto LABEL_33;
      }
    }
    a2 = v11 - 52;
    if (!v42) {
      continue;
    }
    break;
  }
}

void AUFlatParameterInfoBlob::V2Builder::~V2Builder(AUFlatParameterInfoBlob::V2Builder *this)
{
  id v2 = (void *)*((void *)this + 16);
  if (v2)
  {
    *((void *)this + 17) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 13);
  if (v3)
  {
    *((void *)this + 14) = v3;
    operator delete(v3);
  }
  BOOL v4 = (void *)*((void *)this + 10);
  if (v4)
  {
    *((void *)this + 11) = v4;
    operator delete(v4);
  }
  BOOL v5 = (void *)*((void *)this + 7);
  if (v5)
  {
    *((void *)this + 8) = v5;
    operator delete(v5);
  }
}

uint64_t caulk::concurrent::lf_read_synchronized_write<std::shared_ptr<AUFlatParameterInfoBlob>>::~lf_read_synchronized_write(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8))
  {
    id v2 = *(std::__shared_weak_count **)(a1 + 24);
    if (v2) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v2);
    }
  }
  if (*(unsigned char *)(a1 + 9))
  {
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    }
  }
  return a1;
}

uint64_t std::__shared_ptr_pointer<AUFlatParameterInfoBlob  *>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    JUMPOUT(0x192FC8940);
  }
  return result;
}

void std::__shared_ptr_pointer<AUFlatParameterInfoBlob  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x192FC8940);
}

long long *std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AUParameterCache::AUParameterCache(OpaqueAudioComponentInstance *)::$_0 &,AUFlatParameterInfoBlob::Parameter *>(long long *result, long long *a2, long long *a3)
{
  unint64_t v3 = *((void *)a2 + 1);
  unint64_t v4 = *((void *)a3 + 1);
  if (v3 >= *((void *)result + 1))
  {
    if (v4 < v3)
    {
      int v12 = *((_DWORD *)a2 + 12);
      long long v14 = a2[1];
      long long v13 = a2[2];
      long long v15 = *a2;
      long long v17 = a3[1];
      long long v16 = a3[2];
      long long v18 = *a3;
      *((_DWORD *)a2 + 12) = *((_DWORD *)a3 + 12);
      a2[1] = v17;
      a2[2] = v16;
      *a2 = v18;
      *a3 = v15;
      a3[1] = v14;
      a3[2] = v13;
      *((_DWORD *)a3 + 12) = v12;
      if (*((void *)a2 + 1) < *((void *)result + 1))
      {
        int v19 = *((_DWORD *)result + 12);
        long long v21 = result[1];
        long long v20 = result[2];
        long long v22 = *result;
        long long v24 = a2[1];
        long long v23 = a2[2];
        long long v25 = *a2;
        *((_DWORD *)result + 12) = *((_DWORD *)a2 + 12);
        result[1] = v24;
        result[2] = v23;
        *uint64_t result = v25;
        *a2 = v22;
        a2[1] = v21;
        a2[2] = v20;
        *((_DWORD *)a2 + 12) = v19;
      }
    }
  }
  else
  {
    if (v4 >= v3)
    {
      int v26 = *((_DWORD *)result + 12);
      long long v28 = result[1];
      long long v27 = result[2];
      long long v29 = *result;
      long long v31 = a2[1];
      long long v30 = a2[2];
      long long v32 = *a2;
      *((_DWORD *)result + 12) = *((_DWORD *)a2 + 12);
      result[1] = v31;
      result[2] = v30;
      *uint64_t result = v32;
      *a2 = v29;
      a2[1] = v28;
      a2[2] = v27;
      *((_DWORD *)a2 + 12) = v26;
      if (*((void *)a3 + 1) >= *((void *)a2 + 1)) {
        return result;
      }
      int v5 = *((_DWORD *)a2 + 12);
      long long v7 = a2[1];
      long long v6 = a2[2];
      long long v8 = *a2;
      long long v34 = a3[1];
      long long v33 = a3[2];
      long long v35 = *a3;
      *((_DWORD *)a2 + 12) = *((_DWORD *)a3 + 12);
      a2[1] = v34;
      a2[2] = v33;
      *a2 = v35;
    }
    else
    {
      int v5 = *((_DWORD *)result + 12);
      long long v7 = result[1];
      long long v6 = result[2];
      long long v8 = *result;
      long long v10 = a3[1];
      long long v9 = a3[2];
      long long v11 = *a3;
      *((_DWORD *)result + 12) = *((_DWORD *)a3 + 12);
      result[1] = v10;
      result[2] = v9;
      *uint64_t result = v11;
    }
    *a3 = v8;
    a3[1] = v7;
    a3[2] = v6;
    *((_DWORD *)a3 + 12) = v5;
  }
  return result;
}

__n128 std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,AUParameterCache::AUParameterCache(OpaqueAudioComponentInstance *)::$_0 &,AUFlatParameterInfoBlob::Parameter *>(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4)
{
  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AUParameterCache::AUParameterCache(OpaqueAudioComponentInstance *)::$_0 &,AUFlatParameterInfoBlob::Parameter *>((long long *)a1, (long long *)a2, (long long *)a3);
  if (*((void *)a4 + 1) < *(void *)(a3 + 8))
  {
    int v9 = *(_DWORD *)(a3 + 48);
    long long v10 = *(_OWORD *)(a3 + 16);
    __n128 result = *(__n128 *)(a3 + 32);
    long long v11 = *(_OWORD *)a3;
    long long v13 = a4[1];
    long long v12 = a4[2];
    long long v14 = *a4;
    *(_DWORD *)(a3 + 48) = *((_DWORD *)a4 + 12);
    *(_OWORD *)(a3 + 16) = v13;
    *(_OWORD *)(a3 + 32) = v12;
    *(_OWORD *)a3 = v14;
    *a4 = v11;
    a4[1] = v10;
    a4[2] = (__int128)result;
    *((_DWORD *)a4 + 12) = v9;
    if (*(void *)(a3 + 8) < *(void *)(a2 + 8))
    {
      int v15 = *(_DWORD *)(a2 + 48);
      long long v16 = *(_OWORD *)(a2 + 16);
      __n128 result = *(__n128 *)(a2 + 32);
      long long v17 = *(_OWORD *)a2;
      long long v19 = *(_OWORD *)(a3 + 16);
      long long v18 = *(_OWORD *)(a3 + 32);
      long long v20 = *(_OWORD *)a3;
      *(_DWORD *)(a2 + 48) = *(_DWORD *)(a3 + 48);
      *(_OWORD *)(a2 + 16) = v19;
      *(_OWORD *)(a2 + 32) = v18;
      *(_OWORD *)a2 = v20;
      *(_OWORD *)a3 = v17;
      *(_OWORD *)(a3 + 16) = v16;
      *(__n128 *)(a3 + 32) = result;
      *(_DWORD *)(a3 + 48) = v15;
      if (*(void *)(a2 + 8) < *(void *)(a1 + 8))
      {
        int v21 = *(_DWORD *)(a1 + 48);
        long long v22 = *(_OWORD *)(a1 + 16);
        __n128 result = *(__n128 *)(a1 + 32);
        long long v23 = *(_OWORD *)a1;
        long long v25 = *(_OWORD *)(a2 + 16);
        long long v24 = *(_OWORD *)(a2 + 32);
        long long v26 = *(_OWORD *)a2;
        *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
        *(_OWORD *)(a1 + 16) = v25;
        *(_OWORD *)(a1 + 32) = v24;
        *(_OWORD *)a1 = v26;
        *(_OWORD *)a2 = v23;
        *(_OWORD *)(a2 + 16) = v22;
        *(__n128 *)(a2 + 32) = result;
        *(_DWORD *)(a2 + 48) = v21;
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,AUParameterCache::AUParameterCache(OpaqueAudioComponentInstance *)::$_0 &,AUFlatParameterInfoBlob::Parameter *>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 2;
  BOOL result = 1;
  switch(0x4EC4EC4EC4EC4EC5 * v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (*(void *)(a2 - 44) < *(void *)(a1 + 8))
      {
        int v6 = *(_DWORD *)(a1 + 48);
        long long v8 = *(_OWORD *)(a1 + 16);
        long long v7 = *(_OWORD *)(a1 + 32);
        long long v9 = *(_OWORD *)a1;
        long long v10 = *(_OWORD *)(a2 - 36);
        long long v11 = *(_OWORD *)(a2 - 20);
        long long v12 = *(_OWORD *)(a2 - 52);
        *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 - 4);
        *(_OWORD *)(a1 + 16) = v10;
        *(_OWORD *)(a1 + 32) = v11;
        *(_OWORD *)a1 = v12;
        *(_OWORD *)(a2 - 52) = v9;
        *(_OWORD *)(a2 - 36) = v8;
        *(_OWORD *)(a2 - 20) = v7;
        *(_DWORD *)(a2 - 4) = v6;
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AUParameterCache::AUParameterCache(OpaqueAudioComponentInstance *)::$_0 &,AUFlatParameterInfoBlob::Parameter *>((long long *)a1, (long long *)(a1 + 52), (long long *)(a2 - 52));
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,AUParameterCache::AUParameterCache(OpaqueAudioComponentInstance *)::$_0 &,AUFlatParameterInfoBlob::Parameter *>(a1, a1 + 52, a1 + 104, (long long *)(a2 - 52));
      return 1;
    case 5:
      long long v22 = (long long *)(a1 + 52);
      long long v23 = (long long *)(a1 + 104);
      long long v24 = (long long *)(a1 + 156);
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,AUParameterCache::AUParameterCache(OpaqueAudioComponentInstance *)::$_0 &,AUFlatParameterInfoBlob::Parameter *>(a1, a1 + 52, a1 + 104, (long long *)(a1 + 156));
      if (*(void *)(a2 - 44) >= *(void *)(a1 + 164)) {
        return 1;
      }
      int v25 = *(_DWORD *)(a1 + 204);
      long long v27 = *(_OWORD *)(a1 + 172);
      long long v26 = *(_OWORD *)(a1 + 188);
      long long v28 = *v24;
      long long v29 = *(_OWORD *)(a2 - 36);
      long long v30 = *(_OWORD *)(a2 - 20);
      long long v31 = *(_OWORD *)(a2 - 52);
      *(_DWORD *)(a1 + 204) = *(_DWORD *)(a2 - 4);
      *(_OWORD *)(a1 + 172) = v29;
      *(_OWORD *)(a1 + 188) = v30;
      *long long v24 = v31;
      *(_OWORD *)(a2 - 52) = v28;
      *(_OWORD *)(a2 - 36) = v27;
      *(_OWORD *)(a2 - 20) = v26;
      *(_DWORD *)(a2 - 4) = v25;
      if (*(void *)(a1 + 164) >= *(void *)(a1 + 112)) {
        return 1;
      }
      int v32 = *(_DWORD *)(a1 + 152);
      long long v34 = *(_OWORD *)(a1 + 120);
      long long v33 = *(_OWORD *)(a1 + 136);
      long long v35 = *v23;
      long long v36 = *(_OWORD *)(a1 + 172);
      *long long v23 = *v24;
      *(_OWORD *)(a1 + 120) = v36;
      *(_OWORD *)(a1 + 136) = *(_OWORD *)(a1 + 188);
      *(_DWORD *)(a1 + 152) = *(_DWORD *)(a1 + 204);
      *long long v24 = v35;
      *(_OWORD *)(a1 + 172) = v34;
      *(_OWORD *)(a1 + 188) = v33;
      *(_DWORD *)(a1 + 204) = v32;
      if (*(void *)(a1 + 112) >= *(void *)(a1 + 60)) {
        return 1;
      }
      int v37 = *(_DWORD *)(a1 + 100);
      long long v39 = *(_OWORD *)(a1 + 68);
      long long v38 = *(_OWORD *)(a1 + 84);
      long long v40 = *v22;
      long long v41 = *(_OWORD *)(a1 + 120);
      *long long v22 = *v23;
      *(_OWORD *)(a1 + 68) = v41;
      *(_OWORD *)(a1 + 84) = *(_OWORD *)(a1 + 136);
      *(_DWORD *)(a1 + 100) = *(_DWORD *)(a1 + 152);
      *long long v23 = v40;
      *(_OWORD *)(a1 + 120) = v39;
      *(_OWORD *)(a1 + 136) = v38;
      *(_DWORD *)(a1 + 152) = v37;
      if (*(void *)(a1 + 60) >= *(void *)(a1 + 8)) {
        return 1;
      }
      int v42 = *(_DWORD *)(a1 + 48);
      long long v44 = *(_OWORD *)(a1 + 16);
      long long v43 = *(_OWORD *)(a1 + 32);
      long long v45 = *(_OWORD *)a1;
      long long v46 = *(_OWORD *)(a1 + 68);
      *(_OWORD *)a1 = *v22;
      *(_OWORD *)(a1 + 16) = v46;
      *(_OWORD *)(a1 + 32) = *(_OWORD *)(a1 + 84);
      *(_DWORD *)(a1 + 48) = *(_DWORD *)(a1 + 100);
      *long long v22 = v45;
      *(_OWORD *)(a1 + 68) = v44;
      *(_OWORD *)(a1 + 84) = v43;
      BOOL result = 1;
      *(_DWORD *)(a1 + 100) = v42;
      return result;
    default:
      uint64_t v13 = a1 + 104;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,AUParameterCache::AUParameterCache(OpaqueAudioComponentInstance *)::$_0 &,AUFlatParameterInfoBlob::Parameter *>((long long *)a1, (long long *)(a1 + 52), (long long *)(a1 + 104));
      uint64_t v14 = a1 + 156;
      if (a1 + 156 == a2) {
        return 1;
      }
      uint64_t v15 = 0;
      int v16 = 0;
      break;
  }
  while (1)
  {
    unint64_t v17 = *(void *)(v14 + 8);
    if (v17 < *(void *)(v13 + 8))
    {
      uint64_t v18 = *(void *)v14;
      long long v47 = *(_OWORD *)(v14 + 16);
      long long v48 = *(_OWORD *)(v14 + 32);
      int v49 = *(_DWORD *)(v14 + 48);
      uint64_t v19 = v15;
      while (1)
      {
        uint64_t v20 = a1 + v19;
        *(_OWORD *)(v20 + 156) = *(_OWORD *)(a1 + v19 + 104);
        *(_OWORD *)(v20 + 172) = *(_OWORD *)(a1 + v19 + 120);
        *(_OWORD *)(v20 + 188) = *(_OWORD *)(a1 + v19 + 136);
        *(_DWORD *)(v20 + 204) = *(_DWORD *)(a1 + v19 + 152);
        if (v19 == -104) {
          break;
        }
        v19 -= 52;
        if (v17 >= *(void *)(v20 + 60))
        {
          uint64_t v21 = a1 + v19 + 156;
          goto LABEL_13;
        }
      }
      uint64_t v21 = a1;
LABEL_13:
      *(void *)uint64_t v21 = v18;
      *(void *)(v21 + 8) = v17;
      *(_OWORD *)(v21 + 16) = v47;
      *(_OWORD *)(v21 + 32) = v48;
      *(_DWORD *)(v21 + 48) = v49;
      if (++v16 == 8) {
        return v14 + 52 == a2;
      }
    }
    uint64_t v13 = v14;
    v15 += 52;
    v14 += 52;
    if (v14 == a2) {
      return 1;
    }
  }
}

uint64_t AUFlatParameterInfoBlob::V2Builder::stringOffset(AUFlatParameterInfoBlob::V2Builder *this, id *a2)
{
  if (!*a2 || (*((unsigned char *)this + 16) & 1) == 0) {
    return 0xFFFFFFFFLL;
  }
  id v5 = *a2;
  int v6 = [*((id *)this + 1) objectForKeyedSubscript:v5];
  long long v7 = v6;
  if (v6)
  {
    uint64_t v3 = [v6 intValue];
  }
  else
  {
    uint64_t v3 = (*((_DWORD *)this + 34) - *((_DWORD *)this + 32));
    long long v8 = [MEMORY[0x1E4F28ED0] numberWithInt:v3];
    [*((id *)this + 1) setObject:v8 forKeyedSubscript:v5];

    if (!*a2)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Could not construct");
    }
    applesauce::CF::convert_to<std::string,0>((uint64_t)__p, (const __CFString *)*a2);
    if (v35 >= 0) {
      long long v9 = __p;
    }
    else {
      long long v9 = (void **)__p[0];
    }
    long long v10 = (unsigned char *)*((void *)this + 17);
    size_t v11 = strlen((const char *)v9);
    int64_t v12 = v11 + 1;
    if ((uint64_t)(v11 + 1) >= 1)
    {
      uint64_t v13 = *((void *)this + 18);
      if (v13 - (uint64_t)v10 >= v12)
      {
        if (v12 <= 0)
        {
          uint64_t v21 = (uint64_t)v9 + v11 + 1;
          long long v22 = (unsigned char *)*((void *)this + 17);
          if (&v10[-v12] < v10)
          {
            int64_t v23 = -v12;
            long long v22 = (unsigned char *)*((void *)this + 17);
            do
              *v22++ = v10[v23++];
            while (v23);
          }
          *((void *)this + 17) = v22;
          if (v10 != &v10[v12]) {
            memmove(&v10[v12], v10, -v12);
          }
          if ((void **)v21 != v9) {
            memmove(v10, v9, v21 - (void)v9);
          }
        }
        else
        {
          size_t v20 = v11 + 1;
          if ((void **)((char *)v9 + v11 + 1) != v9) {
            memmove(v10, v9, v11 + 1);
          }
          *((void *)this + 17) = &v10[v20];
        }
      }
      else
      {
        uint64_t v14 = (unsigned char *)*((void *)this + 16);
        uint64_t v15 = (char *)(v10 - v14);
        uint64_t v16 = v10 - v14 + v12;
        if (v16 < 0) {
          std::vector<float>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v17 = v13 - (void)v14;
        if (2 * v17 > v16) {
          uint64_t v16 = 2 * v17;
        }
        if (v17 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v18 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v18 = v16;
        }
        size_t v33 = v18;
        if (v18) {
          uint64_t v19 = (char *)operator new(v18);
        }
        else {
          uint64_t v19 = 0;
        }
        long long v24 = &v15[(void)v19];
        memcpy(&v15[(void)v19], v9, v12);
        if (v14 == v10)
        {
          int v25 = v10;
          long long v26 = &v15[(void)v19];
        }
        else
        {
          do
          {
            v15[(void)v19 - 1] = v15[(void)(v14 - 1)];
            --v15;
          }
          while (v15);
          int v25 = (unsigned char *)*((void *)this + 17);
          long long v26 = v19;
        }
        long long v27 = &v24[v12];
        long long v28 = &v19[v33];
        uint64_t v29 = v25 - v10;
        if (v25 != v10) {
          memmove(v27, v10, v25 - v10);
        }
        long long v30 = (void *)*((void *)this + 16);
        *((void *)this + 16) = v26;
        *((void *)this + 17) = &v27[v29];
        *((void *)this + 18) = v28;
        if (v30) {
          operator delete(v30);
        }
      }
    }
    if (v35 < 0) {
      operator delete(__p[0]);
    }
  }

  return v3;
}

void sub_1901978EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  __cxa_free_exception(v16);

  _Unwind_Resume(a1);
}

void caulk::__expected_detail::destroy<AU::Property::Attributes::details::AUParameterInfoValue<1021u>::Wrapper,(void *)0>(uint64_t a1)
{
  id v2 = *(const void **)(a1 + 8);
  if (v2) {
    CFRelease(v2);
  }
  if (*(void *)a1) {
    CFRelease(*(CFTypeRef *)a1);
  }
}

void std::vector<unsigned long long>::reserve(void **a1, unint64_t a2)
{
  if (a2 > ((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3)
  {
    if (a2 >> 61) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    int64_t v3 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    uint64_t v4 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned char *>>(a2);
    id v5 = &v4[v3 & 0xFFFFFFFFFFFFFFF8];
    long long v7 = &v4[8 * v6];
    long long v8 = (char *)*a1;
    long long v9 = (char *)a1[1];
    long long v10 = v5;
    if (v9 != *a1)
    {
      long long v10 = v5;
      do
      {
        uint64_t v11 = *((void *)v9 - 1);
        v9 -= 8;
        *((void *)v10 - 1) = v11;
        v10 -= 8;
      }
      while (v9 != v8);
    }
    *a1 = v10;
    a1[1] = v5;
    a1[2] = v7;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

void AUParameterCache::create(AUParameterCache *this, OpaqueAudioComponentInstance *a2)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  operator new();
}

void sub_190198558(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,long long a27,uint64_t a28,AUParameterCache *a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,void *a48,uint64_t a49,char a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55)
{
}

void ParameterListPropertyListener(uint64_t a1, OpaqueAudioComponentInstance *a2)
{
  if (a2)
  {
    int64_t v3 = (os_unfair_lock_s *)(*(uint64_t (**)(OpaqueAudioComponentInstance *))(*(void *)a2 + 8))(a2);
    if (v3)
    {
      os_unfair_lock_lock(v3 + 14);
      AUParameterCache::create((AUParameterCache *)&v4, a2);
    }
  }
}

void sub_190198774(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

AUParameterCache *std::unique_ptr<AUParameterCache>::reset[abi:ne180100](AUParameterCache **a1)
{
  BOOL result = *a1;
  *a1 = 0;
  if (result)
  {
    AUParameterCache::~AUParameterCache(result);
    JUMPOUT(0x192FC8940);
  }
  return result;
}

void AUParameterCache::~AUParameterCache(AUParameterCache *this)
{
  caulk::concurrent::lf_read_synchronized_write<std::shared_ptr<AUFlatParameterInfoBlob>>::~lf_read_synchronized_write((uint64_t)this + 24);
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 1);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
}

AUParameterCache *std::__shared_ptr_pointer<AUParameterCache *,std::shared_ptr<AUParameterCache>::__shared_ptr_default_delete<AUParameterCache,AUParameterCache>,std::allocator<AUParameterCache>>::__on_zero_shared(uint64_t a1)
{
  BOOL result = *(AUParameterCache **)(a1 + 24);
  if (result)
  {
    AUParameterCache::~AUParameterCache(result);
    JUMPOUT(0x192FC8940);
  }
  return result;
}

void std::__shared_ptr_pointer<AUParameterCache *,std::shared_ptr<AUParameterCache>::__shared_ptr_default_delete<AUParameterCache,AUParameterCache>,std::allocator<AUParameterCache>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x192FC8940);
}

void XAUParameter::GetParamProxy(XAUParameter *this, OpaqueAudioComponentInstance **a2)
{
  int64_t v3 = *a2;
  if (!*a2
    || (id v5 = (os_unfair_lock_s *)(*(uint64_t (**)(OpaqueAudioComponentInstance *))(*(void *)v3 + 8))(*a2)) == 0)
  {
    long long v10 = 0;
    int v11 = -2147450879;
LABEL_8:
    *(_DWORD *)this = v11;
    *((unsigned char *)this + 32) = 0;
    goto LABEL_9;
  }
  uint64_t v6 = v5;
  long long v7 = v5 + 14;
  os_unfair_lock_lock(v5 + 14);
  uint64_t v9 = *(void *)&v6[16]._os_unfair_lock_opaque;
  long long v8 = *(std::__shared_weak_count **)&v6[18]._os_unfair_lock_opaque;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v9) {
    AUParameterCache::create((AUParameterCache *)&v30, v3);
  }
  os_unfair_lock_unlock(v7);
  long long v10 = v8;
  uint64_t v13 = *((unsigned int *)a2 + 2);
  uint64_t v12 = *((unsigned int *)a2 + 3);
  uint64_t v14 = v9 + 24;
  unsigned int v15 = caulk::concurrent::details::lf_read_sync_write_impl::begin_access((caulk::concurrent::details::lf_read_sync_write_impl *)(v9 + 24));
  if (!*(unsigned char *)(v14 + v15 + 8))
  {
    __break(1u);
    return;
  }
  uint64_t v16 = v9 + 16 * v15;
  uint64_t v18 = *(void *)(v16 + 40);
  unint64_t v17 = *(std::__shared_weak_count **)(v16 + 48);
  if (v17) {
    atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  caulk::concurrent::details::lf_read_sync_write_impl::end_access((caulk::concurrent::details::lf_read_sync_write_impl *)(v9 + 24));
  unint64_t v19 = *(void *)(v18 + 40);
  if (!*(void *)(v18 + 40)) {
    goto LABEL_31;
  }
  unint64_t v20 = v13 | (v12 << 61);
  uint64_t v14 = v18 + (*(uint64_t *)(v18 + 40) >> 32);
  uint64_t v21 = v14 + 52 * v19;
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = v14 + 52 * (v19 >> 1);
    unint64_t v24 = *(void *)(v23 + 8);
    uint64_t v25 = v23 + 52;
    v19 += ~(v19 >> 1);
    if (v24 < v20) {
      uint64_t v14 = v25;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v14 == v21)
  {
LABEL_31:
    uint64_t v28 = 0;
    BOOL v27 = 1;
  }
  else
  {
    uint64_t v26 = *(void *)(v14 + 8);
    BOOL v27 = v26 != v20;
    if (v26 == v20) {
      uint64_t v28 = v18;
    }
    else {
      uint64_t v28 = 0;
    }
    if (v26 == v20 && v17 != 0)
    {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      std::__shared_weak_count::__release_shared[abi:ne180100](v17);
      uint64_t v28 = v18;
LABEL_34:
      *(void *)this = v28;
      *((void *)this + 1) = v14;
      *((void *)this + 2) = v18;
      *((void *)this + 3) = v17;
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      *((unsigned char *)this + 32) = 1;
      std::__shared_weak_count::__release_shared[abi:ne180100](v17);
      goto LABEL_9;
    }
  }
  if (v17)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v17);
    if (!v27) {
      goto LABEL_34;
    }
    goto LABEL_36;
  }
  if (v27)
  {
LABEL_36:
    int v11 = -10878;
    goto LABEL_8;
  }
  *(void *)this = v28;
  *((void *)this + 1) = v14;
  *((void *)this + 2) = v18;
  *((void *)this + 3) = 0;
  *((unsigned char *)this + 32) = 1;
LABEL_9:
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
}

void sub_190198AF8(_Unwind_Exception *a1)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  os_unfair_lock_unlock(v2);
  _Unwind_Resume(a1);
}

void *DSPGraph::DenormalEliminatorBox::process(DSPGraph::DenormalEliminatorBox *this, unsigned int a2)
{
  if ((*(unsigned int (**)(DSPGraph::DenormalEliminatorBox *))(*(void *)this + 48))(this))
  {
    uint64_t v4 = *((void *)this + 8);
    if (*((void *)this + 9) == v4)
    {
      std::string::basic_string[abi:ne180100]<0>(v49, "/Library/Caches/com.apple.xbs/Sources/CoreAudioServices_AudioToolboxCore/CoreAudioUtility/Source/CADSP/DSPGraph/DSPGraph_Box.h");
      std::string::basic_string[abi:ne180100]<0>(v48, "in");
      int v42 = (void *)((char *)this + 32);
      if (*((char *)this + 55) < 0) {
        int v42 = (void *)*v42;
      }
      DSPGraph::strprintf((DSPGraph *)"Box::in inIndex out of range! box %s has %zu inputs but input %u was requested", v41, v42, (uint64_t)(*((void *)this + 9) - *((void *)this + 8)) >> 5, 0);
    }
    uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 40))(v4);
    uint64_t v6 = *((void *)this + 11);
    if (*((void *)this + 12) == v6)
    {
      std::string::basic_string[abi:ne180100]<0>(v49, "/Library/Caches/com.apple.xbs/Sources/CoreAudioServices_AudioToolboxCore/CoreAudioUtility/Source/CADSP/DSPGraph/DSPGraph_Box.h");
      std::string::basic_string[abi:ne180100]<0>(v48, "out");
      long long v46 = (void *)((char *)this + 32);
      if (*((char *)this + 55) < 0) {
        long long v46 = (void *)*v46;
      }
      DSPGraph::strprintf((DSPGraph *)"Box::out inIndex out of range! box %s has %zu outputs but input %u was requested", v45, v46, (uint64_t)(*((void *)this + 12) - *((void *)this + 11)) >> 5, 0);
    }
    long long v7 = (void *)(*(void *)(v5 + 56) + 80);
    uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 40))(v6);
    DSPGraph::SimpleABL::copy(v7, (DSPGraph::SimpleABL *)(*(void *)(v8 + 56) + 80), 1);
  }
  else
  {
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 4, 0));
    _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 4, 0), StatusReg | 0x1000000);
    uint64_t v10 = *((void *)this + 11);
    if (*((void *)this + 12) == v10)
    {
      std::string::basic_string[abi:ne180100]<0>(v49, "/Library/Caches/com.apple.xbs/Sources/CoreAudioServices_AudioToolboxCore/CoreAudioUtility/Source/CADSP/DSPGraph/DSPGraph_Box.h");
      std::string::basic_string[abi:ne180100]<0>(v48, "out");
      long long v44 = (void *)((char *)this + 32);
      if (*((char *)this + 55) < 0) {
        long long v44 = (void *)*v44;
      }
      DSPGraph::strprintf((DSPGraph *)"Box::out inIndex out of range! box %s has %zu outputs but input %u was requested", v43, v44, (uint64_t)(*((void *)this + 12) - *((void *)this + 11)) >> 5, 0);
    }
    uint64_t v11 = **(unsigned int **)(*(void *)((*(uint64_t (**)(uint64_t))(*(void *)v10 + 40))(v10) + 56) + 80);
    if (v11)
    {
      uint64_t v12 = 0;
      uint64_t v13 = 16 * v11;
      do
      {
        float __B = 0.0;
        uint64_t v14 = *((void *)this + 8);
        if (*((void *)this + 9) == v14)
        {
          std::string::basic_string[abi:ne180100]<0>(v49, "/Library/Caches/com.apple.xbs/Sources/CoreAudioServices_AudioToolboxCore/CoreAudioUtility/Source/CADSP/DSPGraph/DSPGraph_Box.h");
          std::string::basic_string[abi:ne180100]<0>(v48, "in");
          long long v34 = (void *)((char *)this + 32);
          if (*((char *)this + 55) < 0) {
            long long v34 = (void *)*v34;
          }
          DSPGraph::strprintf((DSPGraph *)"Box::in inIndex out of range! box %s has %zu inputs but input %u was requested", v33, v34, (uint64_t)(*((void *)this + 9) - *((void *)this + 8)) >> 5, 0);
        }
        uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 40))(v14);
        uint64_t v16 = *((void *)this + 11);
        if (*((void *)this + 12) == v16)
        {
          std::string::basic_string[abi:ne180100]<0>(v49, "/Library/Caches/com.apple.xbs/Sources/CoreAudioServices_AudioToolboxCore/CoreAudioUtility/Source/CADSP/DSPGraph/DSPGraph_Box.h");
          std::string::basic_string[abi:ne180100]<0>(v48, "out");
          long long v36 = (void *)((char *)this + 32);
          if (*((char *)this + 55) < 0) {
            long long v36 = (void *)*v36;
          }
          DSPGraph::strprintf((DSPGraph *)"Box::out inIndex out of range! box %s has %zu outputs but input %u was requested", v35, v36, (uint64_t)(*((void *)this + 12) - *((void *)this + 11)) >> 5, 0);
        }
        unint64_t v17 = *(const float **)(*(void *)(*(void *)(v15 + 56) + 80) + v12 + 16);
        uint64_t v18 = (*(uint64_t (**)(uint64_t))(*(void *)v16 + 40))(v16);
        vDSP_vsadd(v17, 1, &__B, *(float **)(*(void *)(*(void *)(v18 + 56) + 80) + v12 + 16), 1, a2);
        v12 += 16;
      }
      while (v13 != v12);
    }
    _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 4, 0), StatusReg);
  }
  uint64_t v19 = *((void *)this + 8);
  if (*((void *)this + 9) == v19)
  {
    std::string::basic_string[abi:ne180100]<0>(v49, "/Library/Caches/com.apple.xbs/Sources/CoreAudioServices_AudioToolboxCore/CoreAudioUtility/Source/CADSP/DSPGraph/DSPGraph_Box.h");
    std::string::basic_string[abi:ne180100]<0>(v48, "in");
    long long v38 = (void *)((char *)this + 32);
    if (*((char *)this + 55) < 0) {
      long long v38 = (void *)*v38;
    }
    DSPGraph::strprintf((DSPGraph *)"Box::in inIndex out of range! box %s has %zu inputs but input %u was requested", v37, v38, (uint64_t)(*((void *)this + 9) - *((void *)this + 8)) >> 5, 0);
  }
  uint64_t v20 = (*(uint64_t (**)(uint64_t))(*(void *)v19 + 40))(v19);
  uint64_t v21 = *((void *)this + 8);
  if (*((void *)this + 9) == v21)
  {
    std::string::basic_string[abi:ne180100]<0>(v49, "/Library/Caches/com.apple.xbs/Sources/CoreAudioServices_AudioToolboxCore/CoreAudioUtility/Source/CADSP/DSPGraph/DSPGraph_Box.h");
    std::string::basic_string[abi:ne180100]<0>(v48, "in");
    long long v40 = (void *)((char *)this + 32);
    if (*((char *)this + 55) < 0) {
      long long v40 = (void *)*v40;
    }
    DSPGraph::strprintf((DSPGraph *)"Box::in inIndex out of range! box %s has %zu inputs but input %u was requested", v39, v40, (uint64_t)(*((void *)this + 9) - *((void *)this + 8)) >> 5, 0);
  }
  int v22 = *(_DWORD *)(*(void *)(v20 + 56) + 72);
  BOOL result = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v21 + 40))(v21);
  uint64_t v25 = *((void *)this + 11);
  unint64_t v24 = (void *)*((void *)this + 12);
  if ((void *)v25 != v24)
  {
    uint64_t v26 = (_OWORD *)(result[7] + 8);
    BOOL result = (void *)v25;
    BOOL v27 = (void *)v25;
    do
    {
      uint64_t v28 = *v27;
      v27 += 4;
      uint64_t v29 = *(void *)((*(uint64_t (**)(void *))(v28 + 40))(result) + 56);
      long long v31 = v26[2];
      long long v30 = v26[3];
      long long v32 = v26[1];
      *(_OWORD *)(v29 + 8) = *v26;
      *(_OWORD *)(v29 + 24) = v32;
      *(_OWORD *)(v29 + 40) = v31;
      *(_OWORD *)(v29 + 56) = v30;
      *(_DWORD *)(v29 + 72) = v22;
      v25 += 32;
      BOOL result = v27;
    }
    while (v27 != v24);
  }
  return result;
}

void sub_19019911C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  if (*(char *)(v26 - 49) < 0) {
    operator delete(*(void **)(v26 - 72));
  }
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 4, 0), v25);
  _Unwind_Resume(exception_object);
}

double DSPGraph::DenormalEliminatorBox::desc@<D0>(uint64_t a1@<X8>)
{
  double result = 6.02437133e175;
  *(_OWORD *)a1 = xmmword_1901C6430;
  *(_DWORD *)(a1 + 16) = 0;
  return result;
}

uint64_t DSPGraph::DenormalEliminatorBox::canProcessInPlace(DSPGraph::DenormalEliminatorBox *this)
{
  return 1;
}

uint64_t DSPGraph::DenormalEliminatorBox::bypass(uint64_t this, unsigned __int8 a2)
{
  return this;
}

uint64_t DSPGraph::DenormalEliminatorBox::isBypassed(DSPGraph::DenormalEliminatorBox *this)
{
  unsigned __int8 v1 = atomic_load((unsigned __int8 *)this + 772);
  return v1 & 1;
}

uint64_t DSPGraph::DenormalEliminatorBox::canBypass(DSPGraph::DenormalEliminatorBox *this)
{
  return 1;
}

const char *DSPGraph::DenormalEliminatorBox::ClassName(DSPGraph::DenormalEliminatorBox *this)
{
  return "DenormalEliminatorBox";
}

void DSPGraph::DenormalEliminatorBox::~DenormalEliminatorBox(DSPGraph::DenormalEliminatorBox *this)
{
  DSPGraph::Box::~Box(this);
  JUMPOUT(0x192FC8940);
}

uint64_t MP4BoxParser_MovieExtends::Init(MP4BoxParser_MovieExtends *this)
{
  uint64_t result = MP4BoxParser::Initialize(this);
  if (!result)
  {
    if (*((_DWORD *)this + 5) == 1836475768)
    {
      if (*((unsigned char *)this + 56)) {
        operator new();
      }
      return 0;
    }
    else
    {
      return 4294967294;
    }
  }
  return result;
}

void MP4BoxParser_MovieExtends::~MP4BoxParser_MovieExtends(MP4BoxParser_MovieExtends *this)
{
  MP4BoxParser_MovieExtends::~MP4BoxParser_MovieExtends(this);
  JUMPOUT(0x192FC8940);
}

{
  uint64_t v2;
  uint64_t v3;

  *(void *)this = off_1EDF93EA0;
  if (*((unsigned char *)this + 56))
  {
    uint64_t v2 = *((void *)this + 8);
    if (v2)
    {
      std::__list_imp<MP4BoxInfo>::clear(*((uint64_t **)this + 8));
      MEMORY[0x192FC8940](v2, 0x1020C4062D53EE8);
    }
  }
  int64_t v3 = *((void *)this + 1);
  *(void *)this = &unk_1EDF8DA18;
  *((void *)this + 1) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
}

uint64_t MP4BoxParser_MovieExtends::GetOverallDurationIncludingFragments(MP4BoxParser_MovieExtends *this, unint64_t *a2, void *a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 0;
  }
  unint64_t v3 = a2[1];
  if ((unint64_t *)v3 == a2) {
    return 0;
  }
  while (*(_DWORD *)(v3 + 16) != 1835362404)
  {
    unint64_t v3 = *(void *)(v3 + 8);
    if ((unint64_t *)v3 == a2) {
      return 0;
    }
  }
  uint64_t v8 = (void (**)(MP4BoxParser_MovieExtendsHeader *__hidden))&unk_1EDF8DA18;
  (*(void (**)(uint64_t *__return_ptr))(*(void *)this + 88))(&v9);
  char v10 = 0;
  int v11 = 0;
  uint64_t v12 = 0;
  char v13 = 0;
  int v14 = 8;
  uint64_t v8 = off_1EDF947C8;
  uint64_t v15 = 0;
  if (MP4BoxParser_MovieExtendsHeader::Init((MP4BoxParser **)&v8))
  {
    uint64_t v5 = v9;
    uint64_t v8 = (void (**)(MP4BoxParser_MovieExtendsHeader *__hidden))&unk_1EDF8DA18;
    uint64_t v9 = 0;
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    }
    return 0;
  }
  uint64_t v7 = v9;
  *a3 = v15;
  uint64_t v8 = (void (**)(MP4BoxParser_MovieExtendsHeader *__hidden))&unk_1EDF8DA18;
  uint64_t v9 = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  return 1;
}

void sub_19019961C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8))(a10);
  }
  _Unwind_Resume(exception_object);
}

void MP4BoxParser_MovieExtends::GetTrackFragmentDefaultsMap(uint64_t a1, uint64_t a2)
{
  v59[2] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 64);
  if (!v2) {
    return;
  }
  uint64_t v4 = &v49;
  int v49 = 0;
  uint64_t v50 = 0;
  long long v48 = &v49;
  uint64_t v5 = *(void *)(v2 + 8);
  if (v5 == v2) {
    goto LABEL_24;
  }
  int v7 = 0;
  uint64_t v8 = v59;
  uint64_t v9 = &v52;
  int v10 = 1;
  do
  {
    int v11 = 0;
    int v12 = v7;
    int v7 = v10;
    while (*(_DWORD *)(v5 + 16) != 1953654136)
    {
LABEL_8:
      uint64_t v5 = *(void *)(v5 + 8);
      if (v5 == v2) {
        goto LABEL_24;
      }
    }
    if (v11 != v12)
    {
      ++v11;
      goto LABEL_8;
    }
    char v13 = v4;
    uint64_t v14 = *(void *)(a1 + 8);
    uint64_t v15 = *(void *)(v5 + 32);
    long long v51 = &unk_1EDF8DA18;
    long long v47 = v9;
    (*(void (**)(uint64_t, uint64_t))(*(void *)v14 + 88))(v14, v15);
    char v53 = 0;
    int v54 = 0;
    uint64_t v55 = 0;
    char v56 = 0;
    int v57 = 8;
    long long v51 = &unk_1EDF93F00;
    unsigned int v58 = 0;
    *uint64_t v8 = -1;
    v8[1] = -1;
    uint64_t v16 = v8;
    if (!MP4BoxParser_TrackExtends::Init((MP4BoxParser_TrackExtends *)&v51))
    {
      unsigned int v17 = v58;
      uint64_t v18 = v49;
      uint64_t v19 = v4;
      if (v49)
      {
        while (1)
        {
          while (1)
          {
            uint64_t v4 = (uint64_t **)v18;
            unsigned int v20 = *((_DWORD *)v18 + 7);
            if (v58 >= v20) {
              break;
            }
            uint64_t v18 = *v4;
            uint64_t v19 = v4;
            if (!*v4) {
              goto LABEL_18;
            }
          }
          if (v20 >= v58) {
            break;
          }
          uint64_t v18 = v4[1];
          if (!v18)
          {
            uint64_t v19 = v4 + 1;
            goto LABEL_18;
          }
        }
      }
      else
      {
LABEL_18:
        uint64_t v21 = operator new(0x30uLL);
        v21[7] = v17;
        *((_OWORD *)v21 + 2) = *v16;
        *(void *)uint64_t v21 = 0;
        *((void *)v21 + 1) = 0;
        *((void *)v21 + 2) = v4;
        *uint64_t v19 = (uint64_t *)v21;
        if (*v48)
        {
          long long v48 = (uint64_t **)*v48;
          uint64_t v21 = *v19;
        }
        std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v49, (uint64_t *)v21);
        ++v50;
      }
    }
    uint64_t v22 = v52;
    long long v51 = &unk_1EDF8DA18;
    uint64_t v52 = 0;
    if (v22) {
      (*(void (**)(uint64_t))(*(void *)v22 + 8))(v22);
    }
    uint64_t v2 = *(void *)(a1 + 64);
    int v10 = v7 + 1;
    uint64_t v5 = *(void *)(v2 + 8);
    uint64_t v4 = v13;
    uint64_t v8 = v16;
    uint64_t v9 = v47;
  }
  while (v5 != v2);
LABEL_24:
  if (&v48 != (uint64_t ***)a2 && v50)
  {
    uint64_t v23 = v48;
    if (*(void *)(a2 + 16))
    {
      unint64_t v24 = *(uint64_t **)a2;
      uint64_t v26 = (uint64_t **)(a2 + 8);
      uint64_t v25 = *(void *)(a2 + 8);
      *(void *)a2 = a2 + 8;
      *(void *)(v25 + 16) = 0;
      *(void *)(a2 + 16) = 0;
      *(void *)(a2 + 8) = 0;
      if (v24[1]) {
        uint64_t v27 = v24[1];
      }
      else {
        uint64_t v27 = (uint64_t)v24;
      }
      if (!v27)
      {
        int v37 = 0;
        goto LABEL_56;
      }
      uint64_t v28 = std::__tree<AUObserverController::AddressOriginator>::_DetachedTreeCache::__detach_next(v27);
      if (v23 == v4)
      {
        long long v30 = (void *)v27;
        uint64_t v23 = v4;
      }
      else
      {
        uint64_t v29 = v23;
        do
        {
          long long v30 = v28;
          unsigned int v31 = *((_DWORD *)v29 + 7);
          *(_DWORD *)(v27 + 28) = v31;
          *(_OWORD *)(v27 + 32) = *((_OWORD *)v29 + 2);
          long long v32 = *v26;
          size_t v33 = (uint64_t **)(a2 + 8);
          long long v34 = (uint64_t **)(a2 + 8);
          if (*v26)
          {
            do
            {
              while (1)
              {
                size_t v33 = (uint64_t **)v32;
                if (v31 >= *((_DWORD *)v32 + 7)) {
                  break;
                }
                long long v32 = (uint64_t *)*v32;
                long long v34 = v33;
                if (!*v33) {
                  goto LABEL_39;
                }
              }
              long long v32 = (uint64_t *)v32[1];
            }
            while (v32);
            long long v34 = v33 + 1;
          }
LABEL_39:
          if (v28) {
            uint64_t v28 = std::__tree<AUObserverController::AddressOriginator>::_DetachedTreeCache::__detach_next((uint64_t)v28);
          }
          else {
            uint64_t v28 = 0;
          }
          char v35 = v29[1];
          if (v35)
          {
            do
            {
              uint64_t v23 = (uint64_t **)v35;
              char v35 = (uint64_t *)*v35;
            }
            while (v35);
          }
          else
          {
            do
            {
              uint64_t v23 = (uint64_t **)v29[2];
              BOOL v36 = *v23 == (uint64_t *)v29;
              uint64_t v29 = v23;
            }
            while (!v36);
          }
          if (!v30) {
            break;
          }
          uint64_t v27 = (uint64_t)v30;
          uint64_t v29 = v23;
        }
        while (v23 != v4);
      }
      if (v28)
      {
        for (unsigned int i = (void *)v28[2]; i; unsigned int i = (void *)i[2])
          uint64_t v28 = i;
        int v37 = v28;
LABEL_56:
      }
    }
    if (v23 != v4)
    {
      long long v39 = (uint64_t **)(a2 + 8);
      do
      {
        long long v40 = (char *)operator new(0x30uLL);
        long long v41 = *(_OWORD *)((char *)v23 + 28);
        *((_DWORD *)v40 + 11) = *((_DWORD *)v23 + 11);
        *(_OWORD *)(v40 + 28) = v41;
        int v42 = *v39;
        long long v43 = (uint64_t **)(a2 + 8);
        long long v44 = (uint64_t **)(a2 + 8);
        if (*v39)
        {
          do
          {
            while (1)
            {
              long long v43 = (uint64_t **)v42;
              if (*((_DWORD *)v40 + 7) >= *((_DWORD *)v42 + 7)) {
                break;
              }
              int v42 = (uint64_t *)*v42;
              long long v44 = v43;
              if (!*v43) {
                goto LABEL_65;
              }
            }
            int v42 = (uint64_t *)v42[1];
          }
          while (v42);
          long long v44 = v43 + 1;
        }
LABEL_65:
        long long v45 = v23[1];
        if (v45)
        {
          do
          {
            long long v46 = (uint64_t **)v45;
            long long v45 = (uint64_t *)*v45;
          }
          while (v45);
        }
        else
        {
          do
          {
            long long v46 = (uint64_t **)v23[2];
            BOOL v36 = *v46 == (uint64_t *)v23;
            uint64_t v23 = v46;
          }
          while (!v36);
        }
        uint64_t v23 = v46;
      }
      while (v46 != v4);
    }
  }
}

void sub_190199AE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  if (a15) {
    (*(void (**)(uint64_t))(*(void *)a15 + 8))(a15);
  }
  _Unwind_Resume(a1);
}

CFIndex AudioComponentRegistrationInfo::parseInfoPlistArray(int a1, uint64_t a2, CFArrayRef *a3, uint64_t a4)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  if (!*a3)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(exception);
  }
  CFIndex result = CFArrayGetCount(*a3);
  if ((int)result >= 1)
  {
    unint64_t v7 = 0;
    uint64_t v8 = result;
    do
    {
      if (!*a3)
      {
        uint64_t v25 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(v25);
      }
      applesauce::CF::details::at_as<applesauce::CF::DictionaryRef>(&theDict, *a3, v7);
      if (!v47) {
        goto LABEL_21;
      }
      CFDictionaryRef v9 = theDict;
      CFTypeRef cf = 0;
      CFTypeRef v41 = 0;
      long long v38 = 0;
      CFTypeRef v39 = 0;
      unsigned int v37 = 0;
      if (!Get4CCOrNumber(theDict, @"type", &v42, (const __CFString **)&v38)
        || !Get4CCOrNumber(v9, @"subtype", &v43, (const __CFString **)&v38)
        || !Get4CCOrNumber(v9, @"manufacturer", &v44, (const __CFString **)&v38)
        || !GetString(v9, @"name", (const __CFString **)&v41, (const __CFString **)&v38)
        || !GetNumber(v9, @"version", &v37, (const __CFString **)&v38)
        || (int String = GetString(v9, @"class", (const __CFString **)&v39, (const __CFString **)&v38),
            (String | ((a1 & 4) >> 2) | GetString(v9, @"factoryFunction", (const __CFString **)&cf, (const __CFString **)&v38)) != 1))
      {
        if (!gAudioComponentLogCategory) {
          operator new();
        }
        uint64_t v14 = *(NSObject **)gAudioComponentLogCategory;
        if (os_log_type_enabled(*(os_log_t *)gAudioComponentLogCategory, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)AudioComponentVector buf = 136316162;
          *(void *)&uint8_t buf[4] = "AudioComponentRegistrationInfo.cpp";
          __int16 v49 = 1024;
          int v50 = 196;
          __int16 v51 = 2112;
          uint64_t v52 = a2;
          __int16 v53 = 2112;
          int v54 = v38;
          __int16 v55 = 2112;
          CFDictionaryRef v56 = v9;
          _os_log_impl(&dword_18FEC0000, v14, OS_LOG_TYPE_DEFAULT, "%25s:%-5d %@: trouble parsing Info.plist's AudioComponents, key %@; entry: %@",
            buf,
            0x30u);
        }
        goto LABEL_21;
      }
      GetNumber(v9, @"flags", v45, (const __CFString **)&v38);
      int Value = CFDictionaryGetValue(v9, @"sandboxSafe");
      int v12 = Value;
      if (Value)
      {
        CFTypeID v13 = CFGetTypeID(Value);
        if (v13 != CFBooleanGetTypeID())
        {
          CFTypeID v16 = CFGetTypeID(v12);
          if (v16 != CFNumberGetTypeID()) {
            goto LABEL_26;
          }
          *(_DWORD *)AudioComponentVector buf = 0;
          CFNumberGetValue((CFNumberRef)v12, kCFNumberSInt32Type, buf);
          if (!*(_DWORD *)buf) {
            goto LABEL_26;
          }
LABEL_25:
          v45[0] |= 2u;
          goto LABEL_26;
        }
        if (CFBooleanGetValue((CFBooleanRef)v12)) {
          goto LABEL_25;
        }
      }
LABEL_26:
      v45[1] = 0;
      char v35 = 0;
      BOOL v36 = 0;
      CFTypeRef v17 = cf;
      if (cf)
      {
        CFRetain(cf);
        applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)buf, v17);
        CFTypeRef v29 = *(CFTypeRef *)buf;
        BOOL v36 = *(const void **)buf;
      }
      else
      {
        CFTypeRef v29 = 0;
      }
      CFTypeRef v18 = v39;
      if (v39)
      {
        CFRetain(v39);
        applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)buf, v18);
        CFTypeRef v28 = *(CFTypeRef *)buf;
        char v35 = *(const void **)buf;
        int v19 = 20;
      }
      else
      {
        CFTypeRef v28 = 0;
        int v19 = a1;
      }
      int v30 = v19;
      if (!theDict)
      {
        uint64_t v27 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v27, "Could not construct");
      }
      unsigned int v20 = CFDictionaryGetValue(theDict, @"tags");
      uint64_t v21 = v20;
      if (!v20) {
        goto LABEL_37;
      }
      CFRetain(v20);
      CFTypeID v22 = CFGetTypeID(v21);
      if (v22 != CFArrayGetTypeID())
      {
        CFRelease(v21);
LABEL_37:
        buf[0] = 0;
        uint8_t buf[8] = 0;
        long long v34 = 0;
        std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)buf);
        uint64_t v21 = 0;
        goto LABEL_38;
      }
      *(void *)AudioComponentVector buf = v21;
      uint8_t buf[8] = 1;
      CFRetain(v21);
      long long v34 = v21;
      std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)buf);
LABEL_38:
      CFTypeRef v23 = v41;
      if (v41) {
        CFRetain(v41);
      }
      applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&v33, v23);
      AudioComponentRegistrationInfo::AudioComponentRegistrationInfo((uint64_t)buf, (uint64_t)&v42, v30, &v33, v37, &v36, &v35, &v34);
      if (v33) {
        CFRelease(v33);
      }
      uint64_t v24 = *(void *)(a4 + 24);
      if (!v24) {
        std::__throw_bad_function_call[abi:ne180100]();
      }
      (*(void (**)(uint64_t, unsigned char *))(*(void *)v24 + 48))(v24, buf);
      AudioComponentRegistrationInfo::~AudioComponentRegistrationInfo((AudioComponentRegistrationInfo *)buf);
      if (v21) {
        CFRelease(v21);
      }
      if (v28) {
        CFRelease(v28);
      }
      if (v29) {
        CFRelease(v29);
      }
LABEL_21:
      CFIndex result = std::__optional_destruct_base<applesauce::CF::DictionaryRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&theDict);
      ++v7;
    }
    while (v8 != v7);
  }
  return result;
}

void sub_19019A0C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,int a21,__int16 a22,char a23,char a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Get4CCOrNumber(const __CFDictionary *a1, const __CFString *a2, unsigned int *a3, const __CFString **a4)
{
  *a3 = 0;
  uint64_t result = (uint64_t)CFDictionaryGetValue(a1, a2);
  if (!result)
  {
LABEL_9:
    *a4 = a2;
    return result;
  }
  CFStringRef v8 = (const __CFString *)result;
  CFTypeID v9 = CFGetTypeID((CFTypeRef)result);
  if (v9 != CFStringGetTypeID())
  {
    CFTypeID v10 = CFGetTypeID(v8);
    if (v10 == CFNumberGetTypeID() && CFNumberGetValue((CFNumberRef)v8, kCFNumberSInt32Type, a3)) {
      return 1;
    }
    uint64_t result = 0;
    goto LABEL_9;
  }
  if (CFStringGetLength(v8) == 4)
  {
    CFStringGetCString(v8, buffer, 5, 0x600u);
    *a3 = bswap32(*(unsigned int *)buffer);
    return 1;
  }
  return 0;
}

uint64_t GetString(const __CFDictionary *a1, const __CFString *a2, const __CFString **a3, const __CFString **a4)
{
  *a3 = 0;
  uint64_t result = (uint64_t)CFDictionaryGetValue(a1, a2);
  if (result)
  {
    CFStringRef v8 = (const __CFString *)result;
    CFTypeID v9 = CFGetTypeID((CFTypeRef)result);
    if (v9 == CFStringGetTypeID())
    {
      *a3 = v8;
      return 1;
    }
    uint64_t result = 0;
  }
  *a4 = a2;
  return result;
}

uint64_t GetNumber(const __CFDictionary *a1, const __CFString *a2, unsigned int *a3, const __CFString **a4)
{
  *a3 = 0;
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a1, a2);
  if (Value)
  {
    CFNumberRef v8 = Value;
    CFTypeID v9 = CFGetTypeID(Value);
    if (v9 == CFNumberGetTypeID())
    {
      if (CFNumberGetValue(v8, kCFNumberSInt32Type, a3)) {
        return 1;
      }
    }
  }
  uint64_t result = 0;
  *a4 = a2;
  return result;
}

uint64_t AudioFileObject::PacketRangeUpperBound(AudioFileObject *this, uint64_t a2, unint64_t *a3, uint64_t *a4)
{
  uint64_t result = 1885563711;
  *a4 = 0;
  if ((a2 & 0x8000000000000000) == 0)
  {
    unint64_t v7 = *a3;
    if ((*a3 & 0x8000000000000000) == 0)
    {
      if ((a2 ^ 0x7FFFFFFFFFFFFFFFuLL) < v7) {
        return 4294967246;
      }
      if (*((_DWORD *)this + 10))
      {
        uint64_t v10 = (*(uint64_t (**)(AudioFileObject *))(*(void *)this + 240))(this);
        uint64_t v11 = *a3;
        if ((uint64_t)(*a3 + a2) > v10)
        {
          uint64_t v11 = (v10 - a2) & ~((v10 - a2) >> 63);
          *a3 = v11;
        }
        unint64_t v12 = *((unsigned int *)this + 10);
        if ((uint64_t)(0x7FFFFFFFFFFFFFFFLL / v12) < v11) {
          return 4294967246;
        }
        uint64_t v16 = v11 * v12;
        goto LABEL_21;
      }
      uint64_t result = (*(uint64_t (**)(AudioFileObject *, unint64_t, void, uint64_t))(*(void *)this + 688))(this, a2 + v7 + 1, 0, 1);
      if (!result || result == -39)
      {
        CFTypeID v13 = (uint64_t *)*((void *)this + 15);
        uint64_t result = 1885563711;
        if (v13)
        {
          int64_t v14 = v13[3];
          uint64_t v15 = *a3;
          if ((uint64_t)(*a3 + a2) > v14)
          {
            uint64_t v15 = (v14 - a2) & ~((v14 - a2) >> 63);
            *a3 = v15;
          }
          if (*((unsigned char *)this + 139))
          {
            if (v15 >= 1)
            {
              uint64_t v16 = 0;
              uint64_t v17 = a2;
              while (1)
              {
                CompressedPacketTable::operator[]((uint64_t)&v20, v13, v17);
                if ((v16 ^ 0x7FFFFFFFFFFFFFFFuLL) < v21) {
                  return 4294967246;
                }
                v16 += v21;
                if (++v17 >= (uint64_t)(*a3 + a2)) {
                  goto LABEL_21;
                }
              }
            }
            uint64_t v16 = 0;
          }
          else
          {
            uint64_t v16 = 0;
            if (v14 > a2 && v15 >= 1)
            {
              CompressedPacketTable::operator[]((uint64_t)&v20, v13, a2 + v15 - 1);
              uint64_t v18 = v20 + v21;
              CompressedPacketTable::operator[]((uint64_t)v19, v13, a2);
              uint64_t v16 = v18 - v19[0];
            }
          }
LABEL_21:
          uint64_t result = 0;
          *a4 = v16;
        }
      }
    }
  }
  return result;
}

uint64_t AudioFileObject::RemoveUserData(AudioFileObject *this)
{
  return 1869627199;
}

uint64_t AudioFileObject::SetUserData(AudioFileObject *this, unsigned int a2, unsigned int a3, unsigned int a4, const void *a5)
{
  return 1869627199;
}

uint64_t AudioFileObject::GetUserDataAtOffset(AudioFileObject *this, unsigned int a2, unsigned int a3, uint64_t a4, unsigned int *a5, void *a6)
{
  return 1869627199;
}

uint64_t AudioFileObject::GetUserData(AudioFileObject *this, unsigned int a2, unsigned int a3, unsigned int *a4, void *a5)
{
  return 1869627199;
}

uint64_t AudioFileObject::GetUserDataSize64(AudioFileObject *this, unsigned int a2, unsigned int a3, unint64_t *a4)
{
  return 1869627199;
}

uint64_t AudioFileObject::GetUserDataSize(AudioFileObject *this, unsigned int a2, unsigned int a3, unsigned int *a4)
{
  return 1869627199;
}

uint64_t AudioFileObject::CountUserData(AudioFileObject *this, unsigned int a2, unsigned int *a3)
{
  return 1869627199;
}

uint64_t AudioFileObject::SetInfoDictionary(AudioFileObject *this, CACFDictionary *a2)
{
  return 1886681407;
}

uint64_t AudioFileObject::GetInfoDictionary(AudioFileObject *this, CACFDictionary *a2)
{
  double v5 = 0.0;
  unint64_t v3 = (AudioFileObject *)(*(uint64_t (**)(AudioFileObject *, double *))(*(void *)this + 544))(this, &v5);
  if (v3) {
    return 1886681407;
  }
  AudioFileObject::AddDurationToInfoDictionary(v3, a2, &v5);
  return 0;
}

uint64_t AudioFileObject::AddDurationToInfoDictionary(AudioFileObject *this, CACFDictionary *a2, double *a3)
{
  Systeuint64_t m = CFLocaleGetSystem();
  if (System)
  {
    CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    unint64_t v7 = CFNumberFormatterCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], System, kCFNumberFormatterDecimalStyle);
    if (v7)
    {
      CFNumberRef v8 = v7;
      StringWithCFNumberRef Value = CFNumberFormatterCreateStringWithValue(v6, v7, kCFNumberFloat64Type, a3);
      if (StringWithValue)
      {
        CFStringRef v10 = StringWithValue;
        if (CFStringGetLength(StringWithValue)) {
          CACFDictionary::AddString(a2, @"approximate duration in seconds", v10);
        }
        CFRelease(v10);
      }
      CFRelease(v8);
    }
  }
  return 0;
}

uint64_t AudioFileObject::GetInfoDictionarySize(AudioFileObject *this, unsigned int *a2, unsigned int *a3)
{
  if (a2) {
    *a2 = 8;
  }
  if (a3) {
    *a3 = 0;
  }
  return 0;
}

uint64_t AudioFileObject::SetChannelLayout(AudioFileObject *this, unsigned int a2, const AudioChannelLayout *a3)
{
  return 1886681407;
}

uint64_t AudioFileObject::GetChannelLayout(AudioFileObject *this, unsigned int *a2, AudioChannelLayout *a3)
{
  *a2 = 0;
  return 1886681407;
}

uint64_t AudioFileObject::GetChannelLayoutSize(AudioFileObject *this, unsigned int *a2, unsigned int *a3)
{
  if (a2) {
    *a2 = 0;
  }
  if (a3) {
    *a3 = 0;
  }
  return 1886681407;
}

uint64_t AudioFileObject::SetRegionList(AudioFileObject *this, unsigned int a2, const AudioFileRegionList *a3)
{
  return 1886681407;
}

uint64_t AudioFileObject::GetRegionList(AudioFileObject *this, unsigned int *a2, AudioFileRegionList *a3)
{
  *a2 = 0;
  return 1886681407;
}

uint64_t AudioFileObject::GetRegionListSize(AudioFileObject *this, unsigned int *a2, unsigned int *a3)
{
  if (a2) {
    *a2 = 0;
  }
  if (a3) {
    *a3 = 0;
  }
  return 1886681407;
}

uint64_t AudioFileObject::SetMarkerList(AudioFileObject *this, unsigned int a2, const AudioFileMarkerList *a3)
{
  return 1886681407;
}

uint64_t AudioFileObject::GetMarkerList(AudioFileObject *this, unsigned int *a2, AudioFileMarkerList *a3)
{
  *a2 = 0;
  return 1886681407;
}

uint64_t AudioFileObject::GetMarkerListSize(AudioFileObject *this, unsigned int *a2, unsigned int *a3)
{
  if (a2) {
    *a2 = 0;
  }
  if (a3) {
    *a3 = 0;
  }
  return 1886681407;
}

uint64_t AudioFileObject::SetMagicCookieData(AudioFileObject *this, unsigned int a2, const void *a3)
{
  return 1667787583;
}

uint64_t AudioFileObject::GetMagicCookieData(AudioFileObject *this, unsigned int *a2, void *a3)
{
  *a2 = 0;
  return 1886681407;
}

uint64_t AudioFileObject::GetMagicCookieDataSize(AudioFileObject *this, unsigned int *a2, unsigned int *a3)
{
  if (a2) {
    *a2 = 0;
  }
  if (a3) {
    *a3 = 0;
  }
  return 1886681407;
}

uint64_t AudioFileObject::GetBitRate(AudioFileObject *this, unsigned int *a2)
{
  if (!a2) {
    return 2003334207;
  }
  unsigned int v4 = *((_DWORD *)this + 10);
  uint64_t v5 = *((unsigned int *)this + 11);
  double v6 = *((double *)this + 3);
  if (v4) {
    BOOL v7 = v5 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7)
  {
    double v13 = (double)v4 * 8.0 * v6 / (double)v5;
LABEL_13:
    unsigned int v11 = v13;
LABEL_14:
    uint64_t result = 0;
    *a2 = v11;
    return result;
  }
  uint64_t v8 = (*(uint64_t (**)(AudioFileObject *))(*(void *)this + 240))(this);
  uint64_t v9 = (*(uint64_t (**)(AudioFileObject *))(*(void *)this + 224))(this);
  if (v5)
  {
    uint64_t v10 = v8 * v5;
LABEL_9:
    unsigned int v11 = 0;
    if (!v10 || v6 == 0.0) {
      goto LABEL_14;
    }
    double v13 = (double)v9 * 8.0 / ((double)v10 / v6);
    goto LABEL_13;
  }
  int64_t v14 = (uint64_t *)*((void *)this + 15);
  if (!v14) {
    return 1886681407;
  }
  if (v14[3] == v8)
  {
    if (v8 < 1)
    {
      unsigned int v11 = 0;
      goto LABEL_14;
    }
    uint64_t v15 = 0;
    uint64_t v10 = 0;
    do
    {
      CompressedPacketTable::operator[]((uint64_t)v16, v14, v15);
      v10 += v17;
      ++v15;
    }
    while (v8 != v15);
    goto LABEL_9;
  }
  return 1685348671;
}

uint64_t AudioFileObject::ByteToPacket(AudioFileObject *this, AudioBytePacketTranslation *a2)
{
  uint64_t result = 1885563711;
  unint64_t mByte = a2->mByte;
  if ((a2->mByte & 0x8000000000000000) == 0)
  {
    unint64_t v6 = *((unsigned int *)this + 10);
    if (v6)
    {
      uint64_t result = 0;
      a2->SInt64 mPacket = mByte / v6;
      *(void *)&a2->mByteOffsetInPacket = (mByte % v6);
      return result;
    }
    BOOL v7 = (uint64_t *)*((void *)this + 15);
    if (v7)
    {
      v17[1] = 0;
      v17[2] = 0;
      v17[0] = mByte;
      uint64_t v8 = v7[3];
      uint64_t v20 = (uint64_t (*)(unsigned char *, uint64_t))byte_less_than;
      uint64_t v18 = v7;
      uint64_t v19 = 0;
      std::__lower_bound[abi:ne180100]<std::_ClassicAlgPolicy,CompressedPacketTable::iterator,CompressedPacketTable::iterator,AudioStreamPacketDescriptionExtended,std::__identity,BOOL (*)(AudioStreamPacketDescriptionExtended const&,AudioStreamPacketDescriptionExtended const&)>((uint64_t)&v14, (uint64_t)&v18, v8, (uint64_t)v17, &v20);
      uint64_t v9 = v7[3];
      if (v15 != v9)
      {
        SInt64 v12 = v15 - (v15 > 0);
        a2->SInt64 mPacket = v12;
        int v13 = a2->mByte;
        CompressedPacketTable::operator[]((uint64_t)v16, v14, v12);
        *(void *)&a2->mByteOffsetInPacket = (v13 - v16[0]);
        return 0;
      }
      if (v9 >= 8)
      {
        CompressedPacketTable::operator[]((uint64_t)&v18, v7, v9 - 1);
        double v10 = (double)((uint64_t)v18 + HIDWORD(v19) - *((void *)this + 9)) / (double)v9;
        double v11 = (double)a2->mByte / v10;
        a2->SInt64 mPacket = vcvtmd_s64_f64(v11);
        a2->mByteOffsetInPacket = vcvtmd_u64_f64(v10 * (v11 - (double)(uint64_t)floor(v11)));
        a2->mFlags = 1;
        return 0;
      }
      return 1836020325;
    }
  }
  return result;
}

uint64_t AudioFileObject::PacketToByte(AudioFileObject *this, AudioBytePacketTranslation *a2)
{
  uint64_t result = 1885563711;
  SInt64 mPacket = a2->mPacket;
  if ((mPacket & 0x8000000000000000) == 0)
  {
    uint64_t v6 = *((unsigned int *)this + 10);
    if (v6)
    {
      uint64_t result = 0;
      SInt64 v7 = mPacket * v6;
LABEL_4:
      a2->unint64_t mByte = v7;
      a2->mFlags = 0;
      return result;
    }
    uint64_t v8 = (uint64_t *)*((void *)this + 15);
    if (v8)
    {
      uint64_t v9 = v8[3];
      if (mPacket < v9)
      {
        CompressedPacketTable::operator[]((uint64_t)&v10, v8, (int)mPacket);
        uint64_t result = 0;
        SInt64 v7 = v10;
        goto LABEL_4;
      }
      if (v9 < 8)
      {
        return 1836020325;
      }
      else
      {
        CompressedPacketTable::operator[]((uint64_t)&v10, v8, v9 - 1);
        uint64_t result = 0;
        a2->unint64_t mByte = vcvtmd_s64_f64((double)(v10 + v11 - *((void *)this + 9)) / (double)v9 * (double)a2->mPacket);
        a2->mFlags = 1;
      }
    }
  }
  return result;
}

uint64_t AudioFileObject::PacketToDependencyInfo(AudioFileObject *this, AudioPacketDependencyInfoTranslation *a2)
{
  int v3 = *((_DWORD *)this + 8);
  UInt32 ioPropertyDataSize = 4;
  int inSpecifier = v3;
  UInt32 outPropertyData = 0;
  AudioFormatGetProperty(0x64726C6Cu, 4u, &inSpecifier, &ioPropertyDataSize, &outPropertyData);
  UInt32 mPacket = outPropertyData;
  if (a2->mPacket < outPropertyData) {
    UInt32 mPacket = a2->mPacket;
  }
  a2->mIsIndependentlyDecodable = 1;
  a2->mNumberPrerollPackets = mPacket;
  return 0;
}

uint64_t AudioFileObject::ScanForIndependentPacket(uint64_t a1, int a2, void *a3)
{
  if (a2 != 1)
  {
    uint64_t result = 0;
    uint64_t v7 = *a3 - 1;
LABEL_10:
    a3[1] = v7;
    return result;
  }
  if (*(_DWORD *)(a1 + 40))
  {
    uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 240))(a1);
    goto LABEL_7;
  }
  (*(void (**)(uint64_t, uint64_t, void, uint64_t))(*(void *)a1 + 688))(a1, *a3 + 2, 0, 1);
  uint64_t v8 = *(void *)(a1 + 120);
  if (v8)
  {
    uint64_t v5 = *(void *)(v8 + 24);
LABEL_7:
    uint64_t v7 = *a3 + 1;
    if (v7 >= v5)
    {
      uint64_t result = 0;
      uint64_t v7 = -1;
    }
    else
    {
      uint64_t result = 0;
    }
    goto LABEL_10;
  }
  return 1885563711;
}

uint64_t AudioFileObject::PacketToRollDistance(AudioFileObject *this, AudioPacketRollDistanceTranslation *a2)
{
  SInt64 mPacket = *((unsigned int *)this + 32);
  if (!mPacket)
  {
    int v4 = *((_DWORD *)this + 8);
    UInt32 ioPropertyDataSize = 4;
    int inSpecifier = v4;
    unsigned int outPropertyData = 0;
    AudioFormatGetProperty(0x64726C6Cu, 4u, &inSpecifier, &ioPropertyDataSize, &outPropertyData);
    SInt64 mPacket = outPropertyData;
  }
  if (a2->mPacket < mPacket) {
    SInt64 mPacket = a2->mPacket;
  }
  a2->mRollDistance = mPacket;
  return 0;
}

uint64_t AudioFileObject::FrameToPacket(AudioFileObject *this, uint64_t a2, uint64_t *a3, unsigned int *a4)
{
  uint64_t v6 = a2;
  uint64_t v7 = *((unsigned int *)this + 11);
  if (v7)
  {
    uint64_t v8 = 0;
    *a3 = a2 / v7;
    *a4 = a2 % v7;
  }
  else
  {
    uint64_t v8 = 1885563711;
    unsigned int v11 = (uint64_t *)*((void *)this + 15);
    if (v11)
    {
      unsigned int v12 = 0;
      while (!v12)
      {
        v22[0] = 0;
        v22[1] = 0;
        v22[2] = v6;
        v23[0] = v11;
        uint64_t v13 = v11[3];
        v23[1] = 0;
        std::__lower_bound[abi:ne180100]<std::_ClassicAlgPolicy,CompressedPacketTable::iterator,CompressedPacketTable::iterator,AudioStreamPacketDescriptionExtended,std::__identity,std::__less<void,void>>((uint64_t)&v18, (uint64_t)v23, v13, (uint64_t)v22);
        uint64_t v14 = v19;
        if (v19 != v11[3])
        {
          *a3 = v19;
          if (!v14) {
            goto LABEL_26;
          }
          uint64_t v15 = v18;
          CompressedPacketTable::operator[]((uint64_t)v20, v18, v14);
          if (v21 > v6)
          {
            CompressedPacketTable::operator[]((uint64_t)v20, v15, v14 - 1);
            LODWORD(v6) = v6 - v21;
LABEL_26:
            uint64_t v8 = 0;
            *a4 = v6;
            return v8;
          }
          if (v13 - *a3 >= 2)
          {
            LODWORD(v6) = 0;
            ++*a3;
            goto LABEL_26;
          }
        }
        CompressedPacketTable::operator[]((uint64_t)v23, v11, v13 - 1);
        if (v13 < 8)
        {
          uint64_t v17 = 8;
        }
        else
        {
          double v16 = (double)v6 / ((double)v23[2] / (double)v13);
          if (v13 + 1 > (uint64_t)v16) {
            uint64_t v17 = v13 + 1;
          }
          else {
            uint64_t v17 = (uint64_t)v16;
          }
        }
        unsigned int v12 = (*(uint64_t (**)(AudioFileObject *, uint64_t, void, uint64_t))(*(void *)this + 688))(this, v17, 0, 1);
        if (!v12 || v12 == -39)
        {
          if (v11[3] == v13) {
            unsigned int v12 = -39;
          }
          else {
            unsigned int v12 = 0;
          }
        }
      }
      if (v12 == -39) {
        return 1885563711;
      }
      else {
        return v12;
      }
    }
  }
  return v8;
}

uint64_t AudioFileObject::PacketToFrame(uint64_t **this, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = *((unsigned int *)this + 11);
  if (v5)
  {
    uint64_t result = 0;
    uint64_t v7 = v5 * a2;
LABEL_3:
    *a3 = v7;
    return result;
  }
  uint64_t result = ((uint64_t (*)(uint64_t **, uint64_t, void, uint64_t))(*this)[86])(this, a2 + 1, 0, 1);
  if (!result)
  {
    uint64_t result = 1885563711;
    uint64_t v9 = this[15];
    if (v9)
    {
      if (v9[3] <= a2)
      {
        return 4294967257;
      }
      else if ((a2 & 0x8000000000000000) == 0)
      {
        if (a2)
        {
          CompressedPacketTable::operator[]((uint64_t)v10, v9, a2 - 1);
          uint64_t v7 = v11;
        }
        else
        {
          uint64_t v7 = 0;
        }
        uint64_t result = 0;
        goto LABEL_3;
      }
    }
  }
  return result;
}

uint64_t AudioFileObject::SetFormatList(AudioFileObject *this, unsigned int a2, const AudioFormatListItem *a3)
{
  return 1869627199;
}

double AudioFileObject::GetFormatList(AudioFileObject *this, unsigned int *a2, AudioFormatListItem *a3)
{
  if (*a2 >= 0x30)
  {
    long long v6 = *(_OWORD *)((char *)this + 40);
    long long v14 = *(_OWORD *)((char *)this + 24);
    long long v15 = v6;
    uint64_t v16 = *((void *)this + 7);
    AudioChannelLayoutTag v7 = *((_DWORD *)this + 13) | 0xFFFF0000;
    size_t size = 0;
    if (!(*(unsigned int (**)(void))(*(void *)this + 400))())
    {
      unsigned int v12 = 0;
      CADeprecated::CAAutoFree<unsigned char>::allocBytes((void **)&v12, HIDWORD(size), 0);
      uint64_t v8 = v12;
      if ((*(unsigned int (**)(AudioFileObject *, char *, AudioChannelLayoutTag *))(*(void *)this + 408))(this, (char *)&size + 4, v12))
      {
        BOOL v9 = 0;
      }
      else
      {
        BOOL v9 = HIDWORD(size) >= 0xC;
      }
      if (v9)
      {
        if ((*v8 | 0x10000) != 0x10000) {
          AudioChannelLayoutTag v7 = *v8;
        }
      }
      else if (!v8)
      {
        goto LABEL_12;
      }
      free(v8);
    }
LABEL_12:
    double result = *(double *)&v14;
    long long v11 = v15;
    *(_OWORD *)&a3->mASBD.mSampleRate = v14;
    *(_OWORD *)&a3->mASBD.mBytesPerPacket = v11;
    *(void *)&a3->mASBD.AudioFormatFlags mBitsPerChannel = v16;
    a3->mChannelLayoutTag = v7;
    *a2 = 48;
  }
  return result;
}

void sub_19019B1C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9)
{
  if (a9) {
    free(a9);
  }
  _Unwind_Resume(exception_object);
}

uint64_t AudioFileObject::UpdateDataFormat(AudioFileObject *this, const AudioStreamBasicDescription *a2)
{
  return (*(uint64_t (**)(AudioFileObject *, const AudioStreamBasicDescription *))(*(void *)this + 176))(this, a2);
}

uint64_t AudioFileObject::SetProperty(AudioFileObject *this, int a2, int a3, uint64_t *a4)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = 1886681407;
  if (a2 > 1819243875)
  {
    if (a2 <= 1885564531)
    {
      if (a2 != 1819243876)
      {
        if (a2 == 1835493731)
        {
          long long v6 = *(uint64_t (**)(void))(*(void *)this + 344);
          return v6();
        }
        if (a2 == 1835756659)
        {
          long long v6 = *(uint64_t (**)(void))(*(void *)this + 368);
          return v6();
        }
        return v5;
      }
      if (a3 != 8)
      {
        uint64_t v5 = 561211770;
        if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
          return v5;
        }
        *(_DWORD *)long long v15 = 136315394;
        *(void *)&v15[4] = "AudioFileObject.cpp";
        __int16 v16 = 1024;
        int v17 = 2033;
        unsigned int v12 = MEMORY[0x1E4F14500];
        uint64_t v13 = "%25s:%-5d  inDataSize is wrong";
        goto LABEL_77;
      }
      *(void *)long long v15 = *a4;
      *(_WORD *)&v15[8] = 0;
      uint64_t v9 = (*(uint64_t (**)(AudioFileObject *, unsigned char *))(*(void *)this + 512))(this, v15);
      goto LABEL_50;
    }
    if (a2 > 1935832163)
    {
      if (a2 != 1935832164)
      {
        if (a2 == 1935893603)
        {
          if (a3 != 8)
          {
            uint64_t v5 = 561211770;
            if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
              return v5;
            }
            *(_DWORD *)long long v15 = 136315394;
            *(void *)&v15[4] = "AudioFileObject.cpp";
            __int16 v16 = 1024;
            int v17 = 2020;
            unsigned int v12 = MEMORY[0x1E4F14500];
            uint64_t v13 = "%25s:%-5d  inDataSize is wrong";
            goto LABEL_77;
          }
          *(void *)long long v15 = *a4;
          *(_WORD *)&v15[8] = 0;
          uint64_t v9 = (*(uint64_t (**)(AudioFileObject *, unsigned char *))(*(void *)this + 464))(this, v15);
          goto LABEL_50;
        }
        return v5;
      }
      if (a3 != 4)
      {
        uint64_t v5 = 561211770;
        if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
          return v5;
        }
        *(_DWORD *)long long v15 = 136315394;
        *(void *)&v15[4] = "AudioFileObject.cpp";
        __int16 v16 = 1024;
        int v17 = 2058;
        unsigned int v12 = MEMORY[0x1E4F14500];
        uint64_t v13 = "%25s:%-5d  inDataSize is wrong";
        goto LABEL_77;
      }
      AudioChannelLayoutTag v7 = *(uint64_t (**)(void))(*(void *)this + 704);
      return v7();
    }
    if (a2 != 1885564532)
    {
      if (a2 == 1919380595)
      {
        long long v6 = *(uint64_t (**)(void))(*(void *)this + 392);
        return v6();
      }
      return v5;
    }
    uint64_t v10 = *a4;
    if (v10 > (*(uint64_t (**)(AudioFileObject *))(*(void *)this + 240))(this)) {
      return 1869627199;
    }
    return AudioFileObject::UpdateNumPackets(this, v10);
  }
  else
  {
    if (a2 > 1685289588)
    {
      if (a2 <= 1768842862)
      {
        if (a2 != 1685289589)
        {
          if (a2 == 1718383476)
          {
            long long v6 = *(uint64_t (**)(void))(*(void *)this + 208);
            return v6();
          }
          return v5;
        }
        if (a3 == 4)
        {
          uint64_t v5 = 0;
          *((_DWORD *)this + 33) = *(_DWORD *)a4;
          return v5;
        }
        uint64_t v5 = 561211770;
        if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
          return v5;
        }
        *(_DWORD *)long long v15 = 136315394;
        *(void *)&v15[4] = "AudioFileObject.cpp";
        __int16 v16 = 1024;
        int v17 = 2000;
        unsigned int v12 = MEMORY[0x1E4F14500];
        uint64_t v13 = "%25s:%-5d  inDataSize is wrong";
LABEL_77:
        _os_log_impl(&dword_18FEC0000, v12, OS_LOG_TYPE_ERROR, v13, v15, 0x12u);
        return v5;
      }
      if (a2 != 1768842863)
      {
        if (a2 == 1769172837)
        {
          if (a3 != 8)
          {
            uint64_t v5 = 561211770;
            if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
              return v5;
            }
            *(_DWORD *)long long v15 = 136315394;
            *(void *)&v15[4] = "AudioFileObject.cpp";
            __int16 v16 = 1024;
            int v17 = 2046;
            unsigned int v12 = MEMORY[0x1E4F14500];
            uint64_t v13 = "%25s:%-5d  inDataSize is wrong";
            goto LABEL_77;
          }
          *(void *)long long v15 = *a4;
          *(_WORD *)&v15[8] = 0;
          uint64_t v9 = (*(uint64_t (**)(AudioFileObject *, unsigned char *))(*(void *)this + 488))(this, v15);
          goto LABEL_50;
        }
        return v5;
      }
      if (a3 != 8)
      {
        uint64_t v5 = 561211770;
        if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
          return v5;
        }
        *(_DWORD *)long long v15 = 136315394;
        *(void *)&v15[4] = "AudioFileObject.cpp";
        __int16 v16 = 1024;
        int v17 = 2007;
        unsigned int v12 = MEMORY[0x1E4F14500];
        uint64_t v13 = "%25s:%-5d  inDataSize is wrong";
        goto LABEL_77;
      }
      *(void *)long long v15 = *a4;
      *(_WORD *)&v15[8] = 0;
      uint64_t v9 = (*(uint64_t (**)(AudioFileObject *, unsigned char *))(*(void *)this + 440))(this, v15);
LABEL_50:
      uint64_t v5 = v9;
      CACFDictionary::~CACFDictionary((CACFDictionary *)v15);
      return v5;
    }
    if (a2 != 1650683508)
    {
      if (a2 == 1668112752)
      {
        long long v6 = *(uint64_t (**)(void))(*(void *)this + 416);
        return v6();
      }
      if (a2 != 1684434292) {
        return v5;
      }
      if (a3 != 40)
      {
        uint64_t v5 = 561211770;
        if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
          return v5;
        }
        *(_DWORD *)long long v15 = 136315394;
        *(void *)&v15[4] = "AudioFileObject.cpp";
        __int16 v16 = 1024;
        int v17 = 1952;
        unsigned int v12 = MEMORY[0x1E4F14500];
        uint64_t v13 = "%25s:%-5d  Incorrect data size";
        goto LABEL_77;
      }
      AudioChannelLayoutTag v7 = *(uint64_t (**)(void))(*(void *)this + 184);
      return v7();
    }
    if (a3 != 8)
    {
      uint64_t v5 = 561211770;
      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
        return v5;
      }
      *(_DWORD *)long long v15 = 136315394;
      *(void *)&v15[4] = "AudioFileObject.cpp";
      __int16 v16 = 1024;
      int v17 = 1960;
      unsigned int v12 = MEMORY[0x1E4F14500];
      uint64_t v13 = "%25s:%-5d  Incorrect data size";
      goto LABEL_77;
    }
    uint64_t v11 = *a4;
    if (v11 > (*(uint64_t (**)(AudioFileObject *))(*(void *)this + 224))(this)) {
      return 1869627199;
    }
    int v14 = *((_DWORD *)this + 33);
    *((_DWORD *)this + 33) = 0;
    uint64_t result = AudioFileObject::UpdateNumBytes(this, v11);
    *((_DWORD *)this + 33) = v14;
  }
  return result;
}

void sub_19019BBF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t AudioFileObject::UpdateNumBytes(AudioFileObject *this, uint64_t a2)
{
  if (a2 < 0) {
    return 4294967246;
  }
  if ((*(uint64_t (**)(AudioFileObject *))(*(void *)this + 224))(this) != a2)
  {
    (*(void (**)(AudioFileObject *, uint64_t))(*(void *)this + 232))(this, a2);
    uint64_t v4 = (*(uint64_t (**)(AudioFileObject *))(*(void *)this + 224))(this);
    (*(void (**)(AudioFileObject *, uint64_t))(*(void *)this + 248))(this, v4 / *((unsigned int *)this + 10));
    if ((*((unsigned char *)this + 100) & 2) != 0)
    {
      if (*((_DWORD *)this + 33))
      {
        uint64_t result = 0;
        *((unsigned char *)this + 136) = 1;
        return result;
      }
      (*(void (**)(AudioFileObject *))(*(void *)this + 216))(this);
    }
  }
  return 0;
}

uint64_t AudioFileObject::UpdateNumPackets(AudioFileObject *this, uint64_t a2)
{
  if (a2 < 0) {
    return 4294967246;
  }
  if ((*(uint64_t (**)(AudioFileObject *))(*(void *)this + 240))(this) != a2)
  {
    *((unsigned char *)this + 136) = 1;
    if (!(*(unsigned int (**)(AudioFileObject *))(*(void *)this + 216))(this)) {
      *((unsigned char *)this + 136) = 0;
    }
    (*(void (**)(AudioFileObject *, uint64_t))(*(void *)this + 248))(this, a2);
    uint64_t v4 = (*(uint64_t (**)(AudioFileObject *))(*(void *)this + 240))(this);
    (*(void (**)(AudioFileObject *, uint64_t))(*(void *)this + 232))(this, v4 * *((unsigned int *)this + 12));
    if ((*((unsigned char *)this + 100) & 2) != 0)
    {
      if (*((_DWORD *)this + 33))
      {
        uint64_t result = 0;
        *((unsigned char *)this + 136) = 1;
        return result;
      }
      (*(void (**)(AudioFileObject *))(*(void *)this + 216))(this);
    }
  }
  return 0;
}

uint64_t AudioFileObject::WritePacketsWithDependencyInfo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 136))(a1, a2, a3, a4, a6, a7, a8);
}

uint64_t AudioFileObject::WritePackets(AudioFileObject *this, uint64_t a2, uint64_t a3, const AudioStreamPacketDescription *a4, uint64_t a5, unsigned int *a6, const void *a7)
{
  unsigned int v10 = a3;
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if ((*(uint64_t (**)(AudioFileObject *, uint64_t, uint64_t, const AudioStreamPacketDescription *))(*(void *)this + 240))(this, a2, a3, a4) >= a5)
  {
    if (a6 && a7)
    {
      unsigned int v16 = *((_DWORD *)this + 10);
      unsigned int v20 = v16 * *a6;
      if (v20 > v10)
      {
        int v17 = v10 / v16;
        *a6 = v10 / v16;
        unsigned int v16 = *((_DWORD *)this + 10);
        unsigned int v20 = v16 * v17;
      }
      uint64_t v13 = (*(uint64_t (**)(AudioFileObject *, uint64_t, uint64_t, unsigned int *, const void *))(*(void *)this + 80))(this, a2, v16 * a5, &v20, a7);
      if (v13)
      {
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)AudioComponentVector buf = 136315394;
          CFTypeID v22 = "AudioFileObject.cpp";
          __int16 v23 = 1024;
          int v24 = 1190;
          int v14 = MEMORY[0x1E4F14500];
          long long v15 = "%25s:%-5d  Write Bytes Failed";
          goto LABEL_13;
        }
      }
      else
      {
        unsigned int v19 = *((_DWORD *)this + 10);
        if (v20 != v19 * *a6) {
          *a6 = v20 / v19;
        }
      }
    }
    else
    {
      uint64_t v13 = 2003334207;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)AudioComponentVector buf = 136315394;
        CFTypeID v22 = "AudioFileObject.cpp";
        __int16 v23 = 1024;
        int v24 = 1171;
        int v14 = MEMORY[0x1E4F14500];
        long long v15 = "%25s:%-5d  invalid parameter";
        goto LABEL_13;
      }
    }
  }
  else
  {
    uint64_t v13 = 1885563711;
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)AudioComponentVector buf = 136315394;
      CFTypeID v22 = "AudioFileObject.cpp";
      __int16 v23 = 1024;
      int v24 = 1170;
      int v14 = MEMORY[0x1E4F14500];
      long long v15 = "%25s:%-5d  write past end";
LABEL_13:
      _os_log_impl(&dword_18FEC0000, v14, OS_LOG_TYPE_ERROR, v15, buf, 0x12u);
    }
  }
  return v13;
}

uint64_t AudioFileObject::ReadPacketDataVBR_InTable(AudioFileObject *this, uint64_t a2, unsigned int *a3, AudioStreamPacketDescription *a4, uint64_t a5, unsigned int *a6, void *a7)
{
  AudioChannelLayoutTag v7 = (uint64_t *)*((void *)this + 15);
  if (!v7) {
    return 1685348671;
  }
  uint64_t v15 = (*(uint64_t (**)(AudioFileObject *, unsigned int *, uint64_t, unsigned int *))(*(void *)this + 120))(this, a3, a5, a6);
  if (!v15)
  {
    CompressedPacketTable::operator[]((uint64_t)v24, v7, a5);
    uint64_t v16 = v24[0];
    unsigned int v23 = *a3;
    if (a7)
    {
      uint64_t v17 = (*(uint64_t (**)(AudioFileObject *, uint64_t, void, unsigned int *, void *))(*(void *)this
                                                                                                  + 72))(this, a2, v24[0], &v23, a7);
      uint64_t v15 = v17;
      if (v17 != -39 && v17 != 0)
      {
        *a3 = 0;
        *a6 = 0;
        return v15;
      }
      *a3 = v23;
      if (!a4) {
        return v15;
      }
    }
    else
    {
      uint64_t v15 = 0;
      if (!a4) {
        return v15;
      }
    }
    if (*a6)
    {
      unint64_t v20 = 0;
      p_mVariableFramesInPacket = &a4->mVariableFramesInPacket;
      do
      {
        CompressedPacketTable::operator[]((uint64_t)v24, v7, a5 + v20);
        uint64_t v22 = v24[1];
        *((void *)p_mVariableFramesInPacket - 1) = v24[0] - v16;
        *(void *)p_mVariableFramesInPacket = v22;
        ++v20;
        p_mVariableFramesInPacket += 4;
      }
      while (v20 < *a6);
    }
  }
  return v15;
}

uint64_t AudioFileObject::HowManyPacketsCanBeReadIntoBuffer(AudioFileObject *this, unsigned int *a2, uint64_t a3, unsigned int *a4)
{
  AudioChannelLayoutTag v7 = (uint64_t *)*((void *)this + 15);
  if (v7) {
    int64_t v8 = v7[3];
  }
  else {
    int64_t v8 = 0;
  }
  if (*a4 + a3 > v8) {
    *a4 = v8 - a3;
  }
  CompressedPacketTable::operator[]((uint64_t)&v22, v7, a3);
  if (*a2 >= v23)
  {
    uint64_t v10 = v22;
    uint64_t v11 = *a4 + a3;
    CompressedPacketTable::operator[]((uint64_t)&v22, v7, v11 - 1);
    uint64_t v12 = v22 - v10 + v23;
    if (v12 <= *a2)
    {
      uint64_t result = 0;
      *a2 = v12;
    }
    else
    {
      uint64_t v13 = a3;
      uint64_t v14 = v11;
      uint64_t v15 = a3;
      do
      {
        uint64_t v16 = (v14 + v15) >> 1;
        if (v16 >= v11) {
          break;
        }
        CompressedPacketTable::operator[]((uint64_t)&v22, v7, (v14 + v15) >> 1);
        uint64_t v17 = v22 - v10 + v23;
        uint64_t v18 = *a2;
        if (v17 <= v18)
        {
          if (v17 >= v18)
          {
            uint64_t v13 = (v14 + v15) >> 1;
            break;
          }
          uint64_t v15 = v16 + 1;
          uint64_t v13 = v16;
        }
        else
        {
          uint64_t v14 = v16 - 1;
        }
      }
      while (v14 >= v15);
      uint64_t v19 = *a4;
      if (v13 - a3 >= v19) {
        uint64_t v20 = a3 + v19 - 1;
      }
      else {
        uint64_t v20 = v13;
      }
      if (v13 - a3 >= v19) {
        unsigned int v21 = *a4;
      }
      else {
        unsigned int v21 = v13 - a3 + 1;
      }
      CompressedPacketTable::operator[]((uint64_t)&v22, v7, v20);
      uint64_t result = 0;
      *a2 = v23 + v22 - v10;
      *a4 = v21;
    }
  }
  else
  {
    *a2 = 0;
    *a4 = 0;
    return 4294967246;
  }
  return result;
}

uint64_t AudioFileObject::ReadPacketDataCBR(AudioFileObject *this, uint64_t a2, unsigned int *a3, uint64_t a4, unsigned int *a5, void *a6)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (!a3 || !*a3)
  {
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      return 4294967246;
    }
    unsigned int v18 = 136315394;
    uint64_t v19 = "AudioFileObject.cpp";
    __int16 v20 = 1024;
    int v21 = 935;
    uint64_t v16 = MEMORY[0x1E4F14500];
    uint64_t v17 = "%25s:%-5d  invalid ioNumBytes parameter";
LABEL_13:
    _os_log_impl(&dword_18FEC0000, v16, OS_LOG_TYPE_ERROR, v17, (uint8_t *)&v18, 0x12u);
    return 4294967246;
  }
  if (!a6)
  {
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      return 4294967246;
    }
    unsigned int v18 = 136315394;
    uint64_t v19 = "AudioFileObject.cpp";
    __int16 v20 = 1024;
    int v21 = 936;
    uint64_t v16 = MEMORY[0x1E4F14500];
    uint64_t v17 = "%25s:%-5d  NULL buffer";
    goto LABEL_13;
  }
  unsigned int v9 = *((_DWORD *)this + 10);
  unsigned int v10 = *a3 / v9;
  unsigned int v11 = *a5;
  if (*a5 > v10)
  {
    *a5 = v10;
    unsigned int v9 = *((_DWORD *)this + 10);
    unsigned int v11 = v10;
  }
  unsigned int v18 = v9 * v11;
  uint64_t result = (*(uint64_t (**)(AudioFileObject *, uint64_t, uint64_t, unsigned int *, void *))(*(void *)this
                                                                                                  + 72))(this, a2, v9 * a4, &v18, a6);
  if (!result || result == -39)
  {
    int v13 = v18;
    unsigned int v14 = *((_DWORD *)this + 10);
    if (v18 != v14 * *a5)
    {
      int v15 = v18 / v14;
      *a5 = v18 / v14;
      int v13 = *((_DWORD *)this + 10) * v15;
    }
    *a3 = v13;
  }
  return result;
}

uint64_t AudioFileObject::ReadPacketDataVBR(AudioFileObject *this, uint64_t a2, unsigned int *a3, AudioStreamPacketDescription *a4, uint64_t a5, unsigned int *a6, void *a7)
{
  if (!a3 && a4 && !a7)
  {
    unsigned int v14 = *(uint64_t (**)(void))(*(void *)this + 88);
    return v14();
  }
  if (!a3 || !*a3) {
    return 4294967246;
  }
  uint64_t v16 = (*(uint64_t (**)(AudioFileObject *, uint64_t, void, uint64_t))(*(void *)this + 688))(this, a5 + 1, 0, 1);
  if (v16)
  {
    uint64_t v17 = v16;
    if (v16 != -39) {
      return v17;
    }
  }
  unsigned int v18 = (uint64_t *)*((void *)this + 15);
  if (!v18) {
    return 1685348671;
  }
  int64_t v19 = v18[3];
  if (v19 <= a5)
  {
    *a3 = 0;
    *a6 = 0;
    return 4294967257;
  }
  if (*a6 + a5 > v19)
  {
    uint64_t v33 = *((void *)this + 9);
    CompressedPacketTable::operator[]((uint64_t)&v38, v18, a5);
    long long v32 = v38;
    unsigned int v45 = *a3;
    uint64_t v20 = v45;
    uint64_t v44 = 0;
    (*(void (**)(void, uint64_t *))(**((void **)this + 13) + 24))(*((void *)this + 13), &v44);
    long long v34 = &v32[v33];
    if (v44 - (uint64_t)v34 < v20) {
      unsigned int v45 = v44 - v34;
    }
    uint64_t v21 = (*(uint64_t (**)(AudioFileObject *, uint64_t, char *, unsigned int *, void *))(*(void *)this + 72))(this, a2, v32, &v45, a7);
    uint64_t v17 = v21;
    if (v21 != -39 && v21)
    {
      *a3 = 0;
      *a6 = 0;
    }
    else
    {
      char v39 = 0;
      long long v38 = (char *)&unk_1EDF91E60;
      uint64_t v40 = v45;
      CFTypeRef v41 = a7;
      unsigned int v42 = v34;
      unsigned int v43 = v34;
      uint64_t v22 = (*(uint64_t (**)(AudioFileObject *, uint64_t, char **, void))(*(void *)this + 688))(this, a5 + 1 + *a6, &v38, 0);
      if (v22 && v22 != -39)
      {
        return v22;
      }
      else
      {
        LODWORD(v23) = 0;
        if (*a6)
        {
          uint64_t v24 = v18[3];
          LODWORD(v25) = 0;
          if (v24 > a5)
          {
            unint64_t v23 = 0;
            int v26 = 0;
            p_UInt32 mDataByteSize = &a4->mDataByteSize;
            while (1)
            {
              CompressedPacketTable::operator[]((uint64_t)&v35, v18, a5 + v23);
              UInt32 v28 = v37;
              uint64_t v29 = v35 - (void)v32;
              uint64_t v25 = v35 - (void)v32 + v37;
              if (v25 > v45) {
                break;
              }
              *(p_mDataByteSize - 1) = v36;
              *p_UInt32 mDataByteSize = v28;
              *(void *)(p_mDataByteSize - 3) = v29;
              ++v23;
              p_mDataByteSize += 4;
              BOOL v30 = v23 < *a6 && (uint64_t)(v23 + a5) < v24;
              int v26 = v25;
              if (!v30) {
                goto LABEL_40;
              }
            }
            LODWORD(v25) = v26;
          }
        }
        else
        {
          LODWORD(v25) = 0;
        }
LABEL_40:
        *a3 = v25;
        *a6 = v23;
      }
    }
    return v17;
  }
  unsigned int v31 = *(uint64_t (**)(AudioFileObject *, uint64_t, unsigned int *, AudioStreamPacketDescription *, uint64_t, unsigned int *, void *))(*(void *)this + 128);
  return v31(this, a2, a3, a4, a5, a6, a7);
}

uint64_t AudioFileObject::ReadPacketData(AudioFileObject *this, unsigned __int8 a2, unsigned int *a3, AudioStreamPacketDescription *a4, uint64_t a5, unsigned int *a6, void *a7)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a6 && *a6)
  {
    if (*((_DWORD *)this + 10))
    {
      AudioChannelLayoutTag v7 = *(uint64_t (**)(void))(*(void *)this + 112);
      return v7();
    }
    if (a4)
    {
      AudioChannelLayoutTag v7 = *(uint64_t (**)(void))(*(void *)this + 104);
      return v7();
    }
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      int v11 = 136315394;
      uint64_t v12 = "AudioFileObject.cpp";
      __int16 v13 = 1024;
      int v14 = 916;
      unsigned int v9 = MEMORY[0x1E4F14500];
      unsigned int v10 = "%25s:%-5d  invalid outPacketDescriptions parameter";
      goto LABEL_9;
    }
  }
  else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    int v11 = 136315394;
    uint64_t v12 = "AudioFileObject.cpp";
    __int16 v13 = 1024;
    int v14 = 911;
    unsigned int v9 = MEMORY[0x1E4F14500];
    unsigned int v10 = "%25s:%-5d  invalid ioNumPackets parameter";
LABEL_9:
    _os_log_impl(&dword_18FEC0000, v9, OS_LOG_TYPE_ERROR, v10, (uint8_t *)&v11, 0x12u);
  }
  return 4294967246;
}

uint64_t AudioFileObject::WriteBytes(AudioFileObject *this, int a2, uint64_t a3, unsigned int *a4, const void *a5)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if ((*((unsigned char *)this + 100) & 2) == 0) {
    return 1886547263;
  }
  if (!a4 || !a5)
  {
    uint64_t v5 = 2003334207;
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      return v5;
    }
    *(_DWORD *)AudioComponentVector buf = 136315394;
    uint64_t v21 = "AudioFileObject.cpp";
    __int16 v22 = 1024;
    int v23 = 817;
    uint64_t v12 = MEMORY[0x1E4F14500];
    __int16 v13 = "%25s:%-5d  invalid parameters";
    goto LABEL_10;
  }
  uint64_t v11 = (*(uint64_t (**)(AudioFileObject *, uint64_t))(*(void *)this + 624))(this, *a4 + a3);
  if (v11)
  {
    uint64_t v5 = v11;
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      return v5;
    }
    *(_DWORD *)AudioComponentVector buf = 136315394;
    uint64_t v21 = "AudioFileObject.cpp";
    __int16 v22 = 1024;
    int v23 = 823;
    uint64_t v12 = MEMORY[0x1E4F14500];
    __int16 v13 = "%25s:%-5d  invalid file position";
LABEL_10:
    _os_log_impl(&dword_18FEC0000, v12, OS_LOG_TYPE_ERROR, v13, buf, 0x12u);
    return v5;
  }
  uint64_t v15 = *a4 + a3;
  uint64_t v16 = (*(uint64_t (**)(AudioFileObject *))(*(void *)this + 224))(this);
  if (v15 > v16 && !*((_DWORD *)this + 20))
  {
    uint64_t v5 = 1869640813;
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      return v5;
    }
    *(_DWORD *)AudioComponentVector buf = 136315394;
    uint64_t v21 = "AudioFileObject.cpp";
    __int16 v22 = 1024;
    int v23 = 829;
    uint64_t v12 = MEMORY[0x1E4F14500];
    __int16 v13 = "%25s:%-5d  Can't write more data until the file is optimized";
    goto LABEL_10;
  }
  uint64_t v17 = (*(uint64_t (**)(void, void, uint64_t, void, const void *, unsigned int *))(**((void **)this + 13)
                                                                                                 + 56))(*((void *)this + 13), 32 * (a2 == 0), *((void *)this + 9) + a3, *a4, a5, a4);
  if (v17)
  {
    uint64_t v5 = v17;
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      return v5;
    }
    *(_DWORD *)AudioComponentVector buf = 136315394;
    uint64_t v21 = "AudioFileObject.cpp";
    __int16 v22 = 1024;
    int v23 = 837;
    uint64_t v12 = MEMORY[0x1E4F14500];
    __int16 v13 = "%25s:%-5d  couldn't write new data";
    goto LABEL_10;
  }
  if (v15 <= v16) {
    return 0;
  }
  uint64_t v19 = 0;
  uint64_t v18 = (*(uint64_t (**)(void, uint64_t *))(**((void **)this + 13) + 24))(*((void *)this + 13), &v19);
  if (!v18) {
    return AudioFileObject::UpdateNumBytes(this, v19 - *((void *)this + 9));
  }
  uint64_t v5 = v18;
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)AudioComponentVector buf = 136315394;
    uint64_t v21 = "AudioFileObject.cpp";
    __int16 v22 = 1024;
    int v23 = 844;
    uint64_t v12 = MEMORY[0x1E4F14500];
    __int16 v13 = "%25s:%-5d  GetSize failed";
    goto LABEL_10;
  }
  return v5;
}

uint64_t AudioFileObject::Optimize(AudioFileObject *this)
{
  *((_DWORD *)this + 20) = 1;
  return 0;
}

uint64_t AudioFileObject::Close(AudioFileObject *this)
{
  uint64_t v2 = *((void *)this + 13);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *((void *)this + 13) = 0;
  return 0;
}

uint64_t AudioFileObject::InitializeDataSource(AudioFileObject *this, const AudioStreamBasicDescription *a2)
{
  return 0;
}

uint64_t AudioFileObject::OpenFromDataSource(AudioFileObject *this)
{
  return 0;
}

uint64_t AudioFileObject::Initialize(AudioFileObject *this, CFURLRef url, const AudioStreamBasicDescription *a3)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (CFURLGetFileSystemRepresentation(url, 1u, buffer, 1024))
  {
    if ((open((const char *)buffer, 1026, 0) & 0x80000000) == 0) {
      AudioFileObject::OpenFile(this);
    }
    unsigned int v5 = *__error();
    if (v5 <= 0x1F)
    {
      if (((1 << v5) & 0x40022002) != 0) {
        return 4294967242;
      }
      if (((1 << v5) & 0x1800000) != 0) {
        return 4294967254;
      }
      if (v5 == 31) {
        return 561017960;
      }
    }
    return 2003334207;
  }
  return 4294967253;
}

uint64_t AudioFileObject::Create(AudioFileObject *this, const __CFURL *a2, const AudioStreamBasicDescription *a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  int v8 = 0;
  uint64_t v5 = AudioFileObject::CreateDataFile(this, a2, &v8);
  if (!v5)
  {
    AudioFileObject::SetURL(this, a2);
    AudioFileObject::OpenFile(this);
  }
  uint64_t v6 = v5;
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)AudioComponentVector buf = 136315394;
    unsigned int v10 = "AudioFileObject.cpp";
    __int16 v11 = 1024;
    int v12 = 53;
    _os_log_impl(&dword_18FEC0000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%25s:%-5d  CreateDataFile failed", buf, 0x12u);
  }
  return v6;
}

uint64_t AudioFileObject::CreateDataFile(AudioFileObject *this, CFURLRef url, int *a3)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (!CFURLGetFileSystemRepresentation(url, 1u, buffer, 1024)) {
    return 4294967253;
  }
  if (!stat((const char *)buffer, &v7)) {
    return 1886547263;
  }
  int v4 = open((const char *)buffer, 2562, 420);
  *a3 = v4;
  if ((v4 & 0x80000000) == 0) {
    return 0;
  }
  unsigned int v6 = *__error();
  if (v6 > 0x1F) {
    return 2003334207;
  }
  if (((1 << v6) & 0x40022002) != 0) {
    return 4294967242;
  }
  if (((1 << v6) & 0x1800000) != 0) {
    return 4294967254;
  }
  if (v6 == 31) {
    return 561017960;
  }
  else {
    return 2003334207;
  }
}

uint64_t AudioFileObject::DoCreate(AudioFileObject *this, const AudioStreamBasicDescription *a2, AudioStreamBasicDescription *a3, char a4)
{
  if (!AudioFileObject::IsDataFormatValid((AudioFileObject *)a3, a2)
    || !(*(unsigned int (**)(AudioFileObject *, AudioStreamBasicDescription *))(*(void *)this + 616))(this, a3))
  {
    return 1718449215;
  }
  *((unsigned char *)this + 100) = 3;
  *((unsigned char *)this + 138) = (a4 & 2) == 0;
  int v8 = *(uint64_t (**)(AudioFileObject *, const AudioStreamBasicDescription *, AudioStreamBasicDescription *))(*(void *)this + 16);
  return v8(this, a2, a3);
}

void AudioFileObject::DoOpenWithCallbacks(AudioFileObject *this, void *a2, int (*a3)(void *, uint64_t, unsigned int, void *, unsigned int *), unint64_t a4, uint64_t (*a5)(void *), unint64_t a6)
{
  if (a4 | a6) {
    char v6 = 3;
  }
  else {
    char v6 = 1;
  }
  *((unsigned char *)this + 100) = v6;
  operator new();
}

DataSource *AudioFileObject::SetDataSource(AudioFileObject *this, DataSource *a2)
{
  uint64_t result = (DataSource *)*((void *)this + 13);
  if (result != a2)
  {
    if (result) {
      uint64_t result = (DataSource *)(*(uint64_t (**)(DataSource *))(*(void *)result + 8))(result);
    }
    *((void *)this + 13) = a2;
  }
  return result;
}

void AudioFileObject::DoInitializeWithCallbacks(AudioFileObject *this, void *a2, int (*a3)(void *, uint64_t, unsigned int, void *, unsigned int *), int (*a4)(void *, uint64_t, unsigned int, const void *, unsigned int *), uint64_t (*a5)(void *), int (*a6)(void *, uint64_t), unsigned int a7, const AudioStreamBasicDescription *a8, unsigned int a9)
{
}

uint64_t AudioFileObject::DoInitialize(AudioFileObject *this, const __CFURL *a2, const AudioStreamBasicDescription *a3, uint64_t a4)
{
  AudioFileObject::SetURL(this, a2);
  *((unsigned char *)this + 100) = 3;
  *((unsigned char *)this + 138) = (a4 & 2) == 0;
  int v8 = *(uint64_t (**)(AudioFileObject *, const __CFURL *, const AudioStreamBasicDescription *, uint64_t))(*(void *)this + 32);
  return v8(this, a2, a3, a4);
}

uint64_t AudioFileObject::UpdateSizeIfNeeded(AudioFileObject *this)
{
  if (!*((unsigned char *)this + 136)) {
    return 0;
  }
  uint64_t result = (*(uint64_t (**)(AudioFileObject *))(*(void *)this + 216))(this);
  if (!result) {
    *((unsigned char *)this + 136) = 0;
  }
  return result;
}

uint64_t AudioFileObject::DoOptimize(AudioFileObject *this)
{
  if ((*((unsigned char *)this + 100) & 2) == 0) {
    return 1886547263;
  }
  if (*((unsigned char *)this + 136))
  {
    uint64_t result = (*(uint64_t (**)(AudioFileObject *))(*(void *)this + 216))(this);
    if (result) {
      return result;
    }
    *((unsigned char *)this + 136) = 0;
  }
  if (*((_DWORD *)this + 20)) {
    return 0;
  }
  int v3 = *(uint64_t (**)(AudioFileObject *))(*(void *)this + 64);
  return v3(this);
}

uint64_t AudioFileObject::SizeChanged(AudioFileObject *this)
{
  if ((*((unsigned char *)this + 100) & 2) == 0) {
    return 0;
  }
  if (*((_DWORD *)this + 33))
  {
    *((unsigned char *)this + 136) = 1;
    return 0;
  }
  return (*(uint64_t (**)(void))(*(void *)this + 216))();
}

uint64_t AudioFileObject::GetPacketTable(AudioFileObject *this, int a2)
{
  uint64_t result = *((void *)this + 15);
  if (a2)
  {
    if (!result) {
      operator new();
    }
  }
  return result;
}

uint64_t AudioFileObject::GetPacketTableSize(AudioFileObject *this)
{
  uint64_t v1 = *((void *)this + 15);
  if (v1) {
    return *(void *)(v1 + 24);
  }
  else {
    return 0;
  }
}

uint64_t AudioFileObject::GetPacketDescriptions(AudioFileObject *this, int a2, unsigned int *a3, AudioStreamPacketDescription *a4)
{
  if (!a4) {
    return 2003334207;
  }
  uint64_t v6 = *((void *)this + 15);
  if (v6)
  {
    int v7 = *a3;
    uint64_t v8 = *(void *)(v6 + 24);
    if (v8 < *a3 + a2)
    {
      int v7 = v8 - a2;
      *a3 = v8 - a2;
    }
    if (v7)
    {
      unint64_t v9 = 0;
      p_mVariableFramesInPacket = &a4->mVariableFramesInPacket;
      do
      {
        CompressedPacketTable::operator[]((uint64_t)v14, *((uint64_t **)this + 15), (a2 + v9));
        uint64_t v12 = v14[1];
        *((void *)p_mVariableFramesInPacket - 1) = v14[0] - *((void *)this + 9);
        *(void *)p_mVariableFramesInPacket = v12;
        p_mVariableFramesInPacket += 4;
        ++v9;
      }
      while (v9 < *a3);
    }
    return 0;
  }
  else
  {
    uint64_t result = 0;
    *a3 = 0;
  }
  return result;
}

void AudioFileObject::AppendPacket(AudioFileObject *this, const AudioStreamPacketDescription *a2)
{
  int v4 = (uint64_t *)*((void *)this + 15);
  if (!v4) {
    operator new();
  }
  unsigned int v5 = *((_DWORD *)this + 11);
  long long v10 = (__int128)*a2;
  if (v5) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = DWORD2(v10);
  }
  uint64_t v7 = v4[3];
  if (v7)
  {
    CompressedPacketTable::operator[]((uint64_t)v9, v4, v7 - 1);
    uint64_t v7 = v9[2];
  }
  uint64_t v11 = v7 + v6;
  CompressedPacketTable::push_back((char **)v4, &v10);
  UInt32 mDataByteSize = a2->mDataByteSize;
  if (mDataByteSize > *((_DWORD *)this + 28)) {
    *((_DWORD *)this + 28) = mDataByteSize;
  }
}

uint64_t AudioFileObject::MoveData(AudioFileObject *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (a2 == a3) {
    return 0;
  }
  CADeprecated::CAAutoFree<char>::CAAutoFree(&v17, 0x100000uLL);
  if (a2 >= a3)
  {
    if (a4 >= 1)
    {
      uint64_t v10 = a4;
      while (1)
      {
        int v16 = 0;
        if (v10 >= 0x100000) {
          uint64_t v11 = 0x100000;
        }
        else {
          uint64_t v11 = v10;
        }
        uint64_t v4 = (*(uint64_t (**)(void, void, uint64_t, uint64_t, void *, int *))(**((void **)this + 13) + 48))(*((void *)this + 13), 0, a4 - v10 + a2, v11, v17, &v16);
        if (v4)
        {
          if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
            goto LABEL_31;
          }
          *(_DWORD *)AudioComponentVector buf = 136315394;
          uint64_t v19 = "AudioFileObject.cpp";
          __int16 v20 = 1024;
          int v21 = 2392;
          uint64_t v13 = MEMORY[0x1E4F14500];
          int v14 = "%25s:%-5d  MoveData ReadBytes failed";
          goto LABEL_30;
        }
        uint64_t v4 = (*(uint64_t (**)(void, void, uint64_t, uint64_t, void *, int *))(**((void **)this + 13) + 56))(*((void *)this + 13), 0, a4 - v10 + a3, v11, v17, &v16);
        if (v4) {
          break;
        }
        BOOL v12 = v10 <= v11;
        v10 -= v11;
        if (v12) {
          goto LABEL_21;
        }
      }
      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
        goto LABEL_31;
      }
      *(_DWORD *)AudioComponentVector buf = 136315394;
      uint64_t v19 = "AudioFileObject.cpp";
      __int16 v20 = 1024;
      int v21 = 2395;
      uint64_t v13 = MEMORY[0x1E4F14500];
      int v14 = "%25s:%-5d  WriteBytes failed";
      goto LABEL_30;
    }
LABEL_21:
    uint64_t v4 = 0;
    goto LABEL_31;
  }
  if (a4 < 1) {
    goto LABEL_21;
  }
  while (1)
  {
    int v16 = 0;
    if (a4 >= 0x100000) {
      uint64_t v9 = 0x100000;
    }
    else {
      uint64_t v9 = a4;
    }
    a4 -= v9;
    uint64_t v4 = (*(uint64_t (**)(void, void, uint64_t, uint64_t, void *, int *))(**((void **)this + 13) + 48))(*((void *)this + 13), 0, a4 + a2, v9, v17, &v16);
    if (v4)
    {
      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
        goto LABEL_31;
      }
      *(_DWORD *)AudioComponentVector buf = 136315394;
      uint64_t v19 = "AudioFileObject.cpp";
      __int16 v20 = 1024;
      int v21 = 2378;
      uint64_t v13 = MEMORY[0x1E4F14500];
      int v14 = "%25s:%-5d  MoveData ReadBytes failed";
      goto LABEL_30;
    }
    uint64_t v4 = (*(uint64_t (**)(void, void, uint64_t, uint64_t, void *, int *))(**((void **)this + 13) + 56))(*((void *)this + 13), 0, a4 + a3, v9, v17, &v16);
    if (v4) {
      break;
    }
    if (a4 <= 0) {
      goto LABEL_21;
    }
  }
  if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
    goto LABEL_31;
  }
  *(_DWORD *)AudioComponentVector buf = 136315394;
  uint64_t v19 = "AudioFileObject.cpp";
  __int16 v20 = 1024;
  int v21 = 2381;
  uint64_t v13 = MEMORY[0x1E4F14500];
  int v14 = "%25s:%-5d  WriteBytes failed";
LABEL_30:
  _os_log_impl(&dword_18FEC0000, v13, OS_LOG_TYPE_ERROR, v14, buf, 0x12u);
LABEL_31:
  if (v17) {
    free(v17);
  }
  return v4;
}

void sub_19019E024(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10)
{
}

uint64_t PacketTableEntry(CompressedPacketTable *a1, uint64_t a2)
{
  CompressedPacketTable::operator[]((uint64_t)&v3, (uint64_t *)a1, a2);
  return v3;
}

void FindIPCAURegistrationsFromAppBundles2()
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v0 = (void *)MEMORY[0x192FC9400]();
  uint64_t v1 = (void *)[NSClassFromString(&cfstr_Lsapplicationw.isa) defaultWorkspace];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v3 = (void *)[v1 applicationsWithAudioComponents];
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  uint64_t v4 = [v3 countByEnumeratingWithState:&v13 objects:v17 count:16];
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = *(void *)v14;
    do
    {
      for (uint64_t i = 0; i != v5; ++i)
      {
        if (*(void *)v14 != v6) {
          objc_enumerationMutation(v3);
        }
        uint64_t v8 = *(void **)(*((void *)&v13 + 1) + 8 * i);
        uint64_t v9 = (const void *)[v8 audioComponents];
        if (v9) {
          CFDictionaryAddValue(Mutable, (const void *)[v8 applicationIdentifier], v9);
        }
      }
      uint64_t v5 = [v3 countByEnumeratingWithState:&v13 objects:v17 count:16];
    }
    while (v5);
  }
  if (kInterAppAudioScope)
  {
    uint64_t v10 = *(NSObject **)kInterAppAudioScope;
    if (!*(void *)kInterAppAudioScope) {
      goto LABEL_16;
    }
  }
  else
  {
    uint64_t v10 = MEMORY[0x1E4F14500];
  }
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)AudioComponentVector buf = 136315394;
    *(void *)&uint8_t buf[4] = "IPCAURegistrar.mm";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = 1266;
    _os_log_impl(&dword_18FEC0000, v10, OS_LOG_TYPE_DEBUG, "%25s:%-5d Registering AUs", buf, 0x12u);
  }
LABEL_16:
  uint64_t v11 = CADeprecated::TSingleton<IPCAURegistrar>::instance();
  BOOL v12 = *(NSObject **)(v11 + 224);
  *(void *)AudioComponentVector buf = MEMORY[0x1E4F143A8];
  *(void *)&uint8_t buf[8] = 3221225472;
  *(void *)&buf[16] = ___ZN14IPCAURegistrar25RegisterAUsFromAppBundlesEPK14__CFDictionary_block_invoke;
  uint64_t v19 = &__block_descriptor_48_e5_v8__0l;
  uint64_t v20 = v11;
  int v21 = Mutable;
  dispatch_sync(v12, buf);
  CFRelease(Mutable);
}

uint64_t __OpenAUApp_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void __SwitchToAUApp_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    NSLog(&cfstr_Openapplicatio.isa, a2);
  }
}

uint64_t MP4AudioFile::SetAlbumArtwork(MP4AudioFile *this, CFTypeRef cf)
{
  uint64_t result = 1886681407;
  if ((*((unsigned char *)this + 100) & 2) != 0)
  {
    int v4 = *((_DWORD *)this + 21);
    if (v4 == 1832149606 || v4 == 1832149350)
    {
      *((void *)this + 68) = cf;
      CFRetain(cf);
      uint64_t result = 0;
      *((unsigned char *)this + 528) = 1;
    }
  }
  return result;
}

uint64_t MP4AudioFile::GetAlbumArtwork(MP4AudioFile *this, const __CFData **a2)
{
  int v4 = (const void *)*((void *)this + 68);
  if (v4)
  {
    CFRetain(v4);
    CFDataRef v5 = (const __CFData *)*((void *)this + 68);
  }
  else
  {
    uint64_t v6 = (MP4BoxParser_iTunesMeta *)*((void *)this + 75);
    if (v6)
    {
      uint64_t v8 = 0;
      MP4BoxParser_iTunesMeta::CopyMetaItemData(v6, 1668249202, (const void **)&v8);
      CFDataRef v5 = (const __CFData *)v8;
    }
    else
    {
      CFDataRef v5 = 0;
    }
  }
  *a2 = v5;
  if (v5) {
    return 0;
  }
  else {
    return 1667787583;
  }
}

uint64_t MP4AudioFile::SetSourceBitDepth(MP4AudioFile *this, int a2)
{
  uint64_t result = 1886681407;
  if ((*((unsigned char *)this + 100) & 2) != 0)
  {
    int v4 = *((_DWORD *)this + 21);
    if ((v4 == 1832149606 || v4 == 1832149350) && *((_DWORD *)this + 8) >> 8 == 6381923)
    {
      uint64_t result = 0;
      *((_DWORD *)this + 131) = a2;
    }
  }
  return result;
}

uint64_t MP4AudioFile::GetSourceBitDepth(MP4AudioFile *this, int *a2)
{
  if ((*((unsigned char *)this + 100) & 2) != 0) {
    uint64_t v2 = (int *)((char *)this + 524);
  }
  else {
    uint64_t v2 = (int *)(*((void *)this + 30) + 424);
  }
  *a2 = *v2;
  return 0;
}

uint64_t MP4AudioFile::PacketRangeUpperBound(MP4AudioFile *this, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v8 = 1885563711;
  *a4 = 0;
  uint64_t v9 = (*(uint64_t (**)(MP4AudioFile *))(*(void *)this + 240))(this);
  if ((a2 & 0x8000000000000000) == 0)
  {
    uint64_t v10 = v9 - a2;
    if (v9 > a2)
    {
      uint64_t v11 = *a3;
      if ((*a3 & 0x8000000000000000) == 0)
      {
        if (v10 < v11)
        {
          *a3 = v10;
          LODWORD(v11) = v9 - a2;
        }
        if ((*((unsigned char *)this + 100) & 2) != 0)
        {
          unsigned int ByteCountForPackets = NUMovieBox::GetByteCountForPackets(*((void *)this + 31), v11);
        }
        else
        {
          BOOL v12 = (MP4BoxParser_Track *)*((void *)this + 30);
          if (!v12) {
            return 2003334207;
          }
          unsigned int ByteCountForPackets = MP4BoxParser_Track::GetByteCountForPackets(v12, a2, v11);
        }
        uint64_t v8 = 0;
        *a4 = ByteCountForPackets;
      }
    }
  }
  return v8;
}

BOOL MP4AudioFile::IsDataFormatSupported(MP4AudioFile *this, const AudioStreamBasicDescription *a2)
{
  BOOL result = 0;
  int v4 = *((_DWORD *)this + 21);
  if (v4 <= 1832149349)
  {
    BOOL v5 = v4 == 862416946 || v4 == 862417008;
    if (v5)
    {
      AudioFormatID mFormatID = a2->mFormatID;
      return mFormatID == 1365470320 || mFormatID == 1935764850 || mFormatID == 1935767394 || mFormatID >> 8 == 6381923;
    }
  }
  else
  {
    switch(v4)
    {
      case 1832149350:
        return IsSupportedM4AFormat(a2->mFormatID);
      case 1832149606:
        AudioFormatID v9 = a2->mFormatID;
        BOOL v5 = v9 == 1885430115;
        AudioFormatID v10 = v9 >> 8;
        return v5 || v10 == 6381923;
      case 1836069990:
        return IsSupportedMP4Format(a2->mFormatID);
    }
  }
  return result;
}

BOOL IsSupportedMP4Format(int a1)
{
  BOOL result = 1;
  if (a1 <= 1885433954)
  {
    if (a1 > 1667591279)
    {
      if (a1 <= 1752594530)
      {
        if (a1 == 1667591280 || a1 == 1700998451) {
          return result;
        }
        int v5 = 1718378851;
      }
      else if (a1 > 1836069683)
      {
        if (a1 == 1836069684) {
          return result;
        }
        int v5 = 1885430115;
      }
      else
      {
        if (a1 == 1752594531) {
          return result;
        }
        int v5 = 1819304813;
      }
      goto LABEL_43;
    }
    if (a1 <= 1365470319)
    {
      if ((a1 - 778924081) < 3) {
        return result;
      }
      goto LABEL_45;
    }
    if (a1 <= 1634492770)
    {
      if (a1 != 1365470320)
      {
        int v5 = 1633889587;
        goto LABEL_43;
      }
      return 0;
    }
    if (a1 == 1634492771) {
      return result;
    }
    int v5 = 1634497332;
LABEL_43:
    if (a1 == v5) {
      return result;
    }
    goto LABEL_45;
  }
  if (a1 <= 1902928226)
  {
    if (a1 <= 1902207794)
    {
      if (a1 == 1885433955 || a1 == 1886745441) {
        return result;
      }
      unsigned __int16 v6 = 24931;
    }
    else
    {
      if (a1 > 1902469938)
      {
        if (a1 == 1902469939) {
          return result;
        }
        int v5 = 1902537827;
        goto LABEL_43;
      }
      if (a1 == 1902207795) {
        return result;
      }
      unsigned __int16 v6 = 28771;
    }
    int v5 = v6 | 0x71610000;
    goto LABEL_43;
  }
  if (a1 > 1936487266)
  {
    if (a1 > 1953986160)
    {
      if (a1 == 1953986161) {
        return result;
      }
      int v5 = 1970495843;
    }
    else
    {
      if (a1 == 1936487267) {
        return result;
      }
      int v5 = 1936487278;
    }
    goto LABEL_43;
  }
  if (a1 <= 1935764849)
  {
    if (a1 == 1902928227) {
      return result;
    }
    int v5 = 1903522657;
    goto LABEL_43;
  }
  if (a1 == 1935764850 || a1 == 1935767394) {
    return 0;
  }
LABEL_45:
  if (a1 >> 8 != 6381923)
  {
    uint64_t v13 = v1;
    uint64_t v14 = v2;
    int v11 = a1;
    uint64_t v12 = 0x6D70346600000000;
    int v10 = 0;
    uint64_t outPropertyData = 0;
    UInt32 ioPropertyDataSize = 12;
    if (AudioFormatGetProperty(0x636E6964u, 0xCu, &v11, &ioPropertyDataSize, &outPropertyData)) {
      BOOL v7 = 1;
    }
    else {
      BOOL v7 = v10 == 0;
    }
    return !v7;
  }
  return result;
}

BOOL IsSupportedM4AFormat(int a1)
{
  BOOL result = 1;
  if (a1 <= 1700998450)
  {
    if ((a1 - 778924081) < 3 || a1 == 1633889587) {
      return result;
    }
    int v3 = 1634492771;
LABEL_13:
    if (a1 != v3) {
      return a1 >> 8 == 6381923;
    }
    return result;
  }
  if (a1 > 1885430114)
  {
    if (a1 == 1885430115 || a1 == 1885430579) {
      return result;
    }
    int v3 = 1885692723;
    goto LABEL_13;
  }
  if (a1 != 1700998451 && a1 != 1718378851)
  {
    int v3 = 1819304813;
    goto LABEL_13;
  }
  return result;
}

uint64_t MP4AudioFile::GetAseSize(MP4AudioFile *this, unsigned int *a2, unsigned int *a3)
{
  *a2 = 8;
  *a3 = 0;
  return 0;
}

uint64_t MP4AudioFile::GetLoudnessInfoSize(MP4AudioFile *this, unsigned int *a2, unsigned int *a3)
{
  *a2 = 8;
  *a3 = 1;
  return 0;
}

uint64_t MP4AudioFile::SetLoudnessInfo(MP4AudioFile *this, CACFDictionary *a2)
{
  if ((*((unsigned char *)this + 100) & 2) == 0) {
    return 1886547263;
  }
  if ((CACFDictionary::HasKey(a2, @"main loudness parameters") & 1) != 0
    || (CACFDictionary::HasKey(a2, @"dialogue anchor parameters") & 1) != 0
    || CACFDictionary::HasKey(a2, @"ISO loudness box"))
  {
    int v5 = (const void *)*((void *)this + 72);
    if (v5)
    {
      CFRelease(v5);
      *((void *)this + 72) = 0;
    }
    unsigned __int16 v6 = *(const void **)a2;
    *((void *)this + 72) = *(void *)a2;
    CFRetain(v6);
  }
  int v7 = *((_DWORD *)this + 21);
  if (v7 == 1832149606 || v7 == 1832149350)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    __int16 v10 = 257;
    CACFDictionary::GetCACFDictionary(a2, @"sound check info", (CACFDictionary *)&Mutable);
    if (Mutable) {
      (*(void (**)(MP4AudioFile *, CFMutableDictionaryRef *))(*(void *)this + 464))(this, &Mutable);
    }
    uint64_t v8 = 0;
    if (CACFDictionary::GetString(a2, @"media kind", (const __CFString **)&v8)) {
      *((unsigned char *)this + 572) = GetStoreItemKindFromLID(a2);
    }
    CACFDictionary::~CACFDictionary((CACFDictionary *)&Mutable);
  }
  if (*((void *)this + 64) || *((void *)this + 72)) {
    return 0;
  }
  uint64_t result = 0;
  *((unsigned char *)this + 572) = 0;
  return result;
}

void sub_19019EB94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  CACFDictionary::~CACFDictionary((CACFDictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t MP4AudioFile::SetAseBoxes(MP4AudioFile *this, const void **a2)
{
  if ((*((unsigned char *)this + 100) & 2) == 0) {
    return 1886547263;
  }
  int v5 = (const void *)*((void *)this + 73);
  if (v5) {
    CFRelease(v5);
  }
  unsigned __int16 v6 = *a2;
  *((void *)this + 73) = *a2;
  CFRetain(v6);
  return 0;
}

uint64_t MP4AudioFile::GetAseBoxes(MP4AudioFile *this, CACFDictionary *a2)
{
  uint64_t v2 = *(const void **)(*((void *)this + 30) + 432);
  if (!v2) {
    return 1886681407;
  }
  CACFDictionary::operator=((uint64_t)a2, v2);
  return 0;
}

uint64_t MP4AudioFile::GetLoudnessInfo(MP4AudioFile *this, CACFDictionary *a2)
{
  CFTypeRef cf = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  __int16 v13 = 257;
  CFDictionaryRef v4 = (const __CFDictionary *)*((void *)this + 72);
  if (v4)
  {
    CACFDictionary::SetCFMutableDictionaryFromCopy(a2, v4, 1);
  }
  else
  {
    uint64_t LoudnessInfo = MP4BoxParser_Track::GetLoudnessInfo(*((MP4BoxParser_Track **)this + 30), (const __CFDictionary **)&cf);
    if (LoudnessInfo) {
      goto LABEL_5;
    }
    BOOL v7 = cf != 0;
    if (cf)
    {
      CACFDictionary::SetCFMutableDictionaryFromCopy(a2, (CFDictionaryRef)cf, 1);
      CFRelease(cf);
    }
    if (!MP4AudioFile::GetSoundCheckFromMetaData(this, (CACFDictionary *)&Mutable))
    {
      CACFDictionary::AddDictionary(a2, @"sound check info", Mutable);
      BOOL v7 = 1;
    }
    uint64_t v8 = (MP4BoxParser_iTunesMeta *)*((void *)this + 75);
    if (v8
      && (int StoreKind = MP4BoxParser_iTunesMeta::GetStoreKind(v8),
          (CFStringRef v10 = CopyMediaKindStringFromStoreItemKind(StoreKind)) != 0))
    {
      CACFDictionary::AddString(a2, @"media kind", v10);
      CFRelease(v10);
    }
    else if (!v7)
    {
      uint64_t LoudnessInfo = 1886681407;
      goto LABEL_5;
    }
  }
  uint64_t LoudnessInfo = 0;
LABEL_5:
  CACFDictionary::~CACFDictionary((CACFDictionary *)&Mutable);
  return LoudnessInfo;
}

void sub_19019ED70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  CACFDictionary::~CACFDictionary((CACFDictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t MP4AudioFile::GetSoundCheckFromMetaData(MP4AudioFile *this, CACFDictionary *a2)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  uint64_t v18 = 0;
  uint64_t v4 = (*(uint64_t (**)(void, uint64_t *))(**((void **)this + 13) + 24))(*((void *)this + 13), &v18);
  if (!v4)
  {
    BoxInfo = FindBoxInfo(*((void *)this + 13), 0, v18, 1836019574, 0, *((__n128 ***)this + 28));
    if (BoxInfo)
    {
      uint64_t v6 = *((void *)this + 13);
      unint64_t v7 = BoxInfo[1].n128_u64[0];
      uint64_t v29 = (void (**)(MP4BoxParser_Movie *__hidden))&unk_1EDF8DA18;
      (*(void (**)(uint64_t *__return_ptr, uint64_t, unint64_t))(*(void *)v6 + 88))(&v30, v6, v7);
      char v31 = 0;
      int v32 = 0;
      uint64_t v33 = 0;
      char v34 = 0;
      int v35 = 8;
      uint64_t v29 = off_1EDF92718;
      char v36 = 1;
      uint64_t v37 = 0;
      uint64_t v4 = MP4BoxParser_Movie::Init((MP4BoxParser_Movie *)&v29);
      if (!v4)
      {
        char v17 = 0;
        while (1)
        {
          uint64_t v8 = (__n128 **)v37;
          if (!v37 || (uint64_t v9 = *(void *)(v37 + 8), v9 == v37))
          {
            unsigned int v10 = 0;
          }
          else
          {
            unsigned int v10 = 0;
            do
            {
              if (*(_DWORD *)(v9 + 16) == 1969517665) {
                ++v10;
              }
              uint64_t v9 = *(void *)(v9 + 8);
            }
            while (v9 != v37);
          }
          if (v4 >= v10) {
            break;
          }
          uint64_t v11 = v30;
          unsigned int v12 = ((uint64_t (*)(void))v29[3])(&v29);
          __int16 v13 = FindBoxInfo(v11, v12, v33, 1969517665, v4, v8);
          if (v13)
          {
            int v14 = *((_DWORD *)this + 13);
            uint64_t v15 = v13[1].n128_u64[0] + 8;
            uint64_t v19 = &unk_1EDF8DA18;
            (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v30 + 88))(&v20, v30, v15);
            char v21 = 0;
            int v22 = 0;
            uint64_t v23 = 0;
            char v24 = 0;
            int v25 = 8;
            uint64_t v26 = 0;
            uint64_t v27 = 0;
            uint64_t v19 = &unk_1EDF94350;
            int v28 = v14;
            if (!MP4BoxParser_iTunesNORMMeta::Init((MP4BoxParser_iTunesNORMMeta *)&v19))
            {
              MP4BoxParser_iTunesNORMMeta::FillSoundCheckDictionary((MP4BoxParser_iTunesNORMMeta *)&v19, a2);
              char v17 = 1;
            }
            MP4BoxParser_Meta::~MP4BoxParser_Meta((MP4BoxParser_Meta *)&v19);
          }
          LODWORD(v4) = v4 + 1;
        }
        if (v17) {
          uint64_t v4 = 0;
        }
        else {
          uint64_t v4 = 1886681407;
        }
      }
      MP4BoxParser_Movie::~MP4BoxParser_Movie((MP4BoxParser_Movie *)&v29);
    }
    else
    {
      return 1685348671;
    }
  }
  return v4;
}

void sub_19019F08C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  MP4BoxParser_Movie::~MP4BoxParser_Movie((MP4BoxParser_Movie *)va);
  _Unwind_Resume(a1);
}

uint64_t MP4AudioFile::SetSoundCheckDictionary(MP4AudioFile *this, CACFDictionary *a2)
{
  uint64_t result = 1886681407;
  int v4 = *((_DWORD *)this + 21);
  BOOL v5 = v4 == 1832149606 || v4 == 1832149350;
  if (v5 && (*((unsigned char *)this + 100) & 2) != 0)
  {
    unsigned int v7 = *((_DWORD *)this + 13);
    uint64_t v8 = (unsigned int *)malloc_type_malloc(20 * v7, 0x2C8E6D5CuLL);
    if (20 * v7) {
      BOOL v9 = v8 == 0;
    }
    else {
      BOOL v9 = 0;
    }
    if (v9)
    {
      exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
      __int16 v13 = std::bad_alloc::bad_alloc(exception);
    }
    unsigned int v10 = v8;
    bzero(v8, 20 * v7);
    uint64_t result = GetSCFields(a2, v10, v7);
    if (!result)
    {
      uint64_t v11 = (void *)*((void *)this + 64);
      if (v11) {
        free(v11);
      }
      uint64_t result = 0;
      *((void *)this + 64) = v10;
      *((unsigned char *)this + 528) = 1;
    }
  }
  return result;
}

uint64_t MP4AudioFile::GetSoundCheckDictionarySize(MP4AudioFile *this, unsigned int *a2, unsigned int *a3)
{
  if (a2) {
    *a2 = 8;
  }
  if (a3)
  {
    int v3 = *((_DWORD *)this + 21);
    if (v3 == 1832149606 || v3 == 1832149350) {
      int v5 = (*((unsigned __int8 *)this + 100) >> 1) & 1;
    }
    else {
      int v5 = 0;
    }
    *a3 = v5;
  }
  return 0;
}

uint64_t MP4AudioFile::SetInfoDictionary(MP4AudioFile *this, CFTypeRef *a2)
{
  if (*a2)
  {
    CFRetain(*a2);
    CFTypeRef v4 = *a2;
  }
  else
  {
    CFTypeRef v4 = 0;
  }
  *((void *)this + 67) = v4;
  *((unsigned char *)this + 528) = 1;
  return 0;
}

uint64_t MP4AudioFile::GetInfoDictionary(MP4AudioFile *this, CACFDictionary *a2)
{
  if ((*((unsigned char *)this + 100) & 2) != 0 && (CFDictionaryRef v4 = (const __CFDictionary *)*((void *)this + 67)) != 0)
  {
    CACFDictionary::SetCFMutableDictionaryFromCopy(a2, v4, 0);
  }
  else
  {
    int v5 = (MP4BoxParser_iTunesMeta *)*((void *)this + 75);
    if (v5)
    {
      MP4BoxParser_iTunesMeta::AddMetaItemDataToInfoDictionary(v5, -1451789708, a2);
      MP4BoxParser_iTunesMeta::AddMetaItemDataToInfoDictionary(*((MP4BoxParser_iTunesMeta **)this + 75), -1455336876, a2);
      MP4BoxParser_iTunesMeta::AddMetaItemDataToInfoDictionary(*((MP4BoxParser_iTunesMeta **)this + 75), -1453233054, a2);
      MP4BoxParser_iTunesMeta::AddMetaItemDataToInfoDictionary(*((MP4BoxParser_iTunesMeta **)this + 75), -1451987089, a2);
      MP4BoxParser_iTunesMeta::AddMetaItemDataToInfoDictionary(*((MP4BoxParser_iTunesMeta **)this + 75), -1452383891, a2);
      MP4BoxParser_iTunesMeta::AddMetaItemDataToInfoDictionary(*((MP4BoxParser_iTunesMeta **)this + 75), -1453039239, a2);
      MP4BoxParser_iTunesMeta::AddMetaItemDataToInfoDictionary(*((MP4BoxParser_iTunesMeta **)this + 75), -1453101708, a2);
      MP4BoxParser_iTunesMeta::AddMetaItemDataToInfoDictionary(*((MP4BoxParser_iTunesMeta **)this + 75), 1953329263, a2);
      MP4BoxParser_iTunesMeta::AddMetaItemDataToInfoDictionary(*((MP4BoxParser_iTunesMeta **)this + 75), 1668313716, a2);
      MP4BoxParser_iTunesMeta::AddMetaItemDataToInfoDictionary(*((MP4BoxParser_iTunesMeta **)this + 75), -1453230732, a2);
      MP4BoxParser_iTunesMeta::AddMetaItemDataToInfoDictionary(*((MP4BoxParser_iTunesMeta **)this + 75), 1953655662, a2);
      int v5 = (MP4BoxParser_iTunesMeta *)MP4BoxParser_iTunesMeta::AddMetaItemDataToInfoDictionary(*((MP4BoxParser_iTunesMeta **)this + 75), -1452841618, a2);
      if (v5) {
        int v5 = (MP4BoxParser_iTunesMeta *)MP4BoxParser_iTunesMeta::AddMetaItemDataToInfoDictionary(*((MP4BoxParser_iTunesMeta **)this + 75), 1735291493, a2);
      }
    }
    AudioFileObject::AddDurationToInfoDictionary(v5, a2, (double *)this + 56);
  }
  return 0;
}

uint64_t MP4AudioFile::GetInfoDictionarySize(MP4AudioFile *this, unsigned int *a2, unsigned int *a3)
{
  if (a3) {
    *a3 = 0;
  }
  if (a2) {
    *a2 = 8;
  }
  return 0;
}

uint64_t MP4AudioFile::SetChannelLayout(MP4AudioFile *this, UInt32 a2, AudioChannelLayout *inSpecifier)
{
  if ((*((unsigned char *)this + 100) & 2) == 0) {
    return 1886547263;
  }
  if (!inSpecifier) {
    return 4294967246;
  }
  if (*((_DWORD *)this + 8) != 1819304813) {
    return 1886681407;
  }
  int v7 = *((_DWORD *)this + 13);
  UInt32 ioPropertyDataSize = 4;
  int outPropertyData = 0;
  uint64_t result = AudioFormatGetProperty(0x6E63686Du, a2, inSpecifier, &ioPropertyDataSize, &outPropertyData);
  if (result) {
    return result;
  }
  if (outPropertyData != v7) {
    return 4294967246;
  }
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char *,unsigned char *>((void *)this + 19, (char *)inSpecifier, (char *)inSpecifier + a2, a2);
  UInt32 outPropertyDataSize = 0;
  if (!AudioFormatGetPropertyInfo(0x636C636Eu, *((_DWORD *)this + 40) - *((void *)this + 19), *((const void **)this + 19), &outPropertyDataSize))
  {
    std::vector<unsigned char>::resize((std::vector<char> *)((char *)this + 176), outPropertyDataSize);
    if (AudioFormatGetProperty(0x636C636Eu, *((_DWORD *)this + 40) - *((void *)this + 19), *((const void **)this + 19), &outPropertyDataSize, *((void **)this + 22)))
    {
      std::vector<char>::size_type v8 = 0;
    }
    else
    {
      std::vector<char>::size_type v8 = outPropertyDataSize;
    }
    std::vector<unsigned char>::resize((std::vector<char> *)((char *)this + 176), v8);
  }
  return 0;
}

uint64_t MP4AudioFile::GetChannelLayout(MP4AudioFile *this, unsigned int *a2, AudioChannelLayout *__dst)
{
  if (!a2) {
    return 561211770;
  }
  if ((*((unsigned char *)this + 100) & 2) != 0)
  {
    int v9 = *((_DWORD *)this + 8);
    if (v9 == 1819304813)
    {
      size_t v10 = *a2;
      uint64_t v11 = (const void *)*((void *)this + 19);
      size_t v12 = *((void *)this + 20) - (void)v11;
      uint64_t PropertyInfo = 561211770;
      if (v12 <= v10)
      {
        memcpy(__dst, v11, v12);
        uint64_t PropertyInfo = 0;
        *a2 = *((_DWORD *)this + 40) - *((_DWORD *)this + 38);
      }
    }
    else
    {
      uint64_t v13 = *((void *)this + 18);
      if (v13)
      {
        uint64_t PropertyInfo = 561211770;
        if (*a2 >= GetACLSize(*((_DWORD *)this + 8), a2, __dst))
        {
          int v14 = *((_DWORD *)this + 35);
          UInt32 outPropertyDataSize = 0;
          memset(inSpecifier, 0, sizeof(inSpecifier));
          DWORD2(inSpecifier[0]) = v9;
          uint64_t v25 = 0;
          uint64_t v26 = v13;
          int v27 = v14;
          uint64_t PropertyInfo = AudioFormatGetPropertyInfo(0x666C7374u, 0x38u, inSpecifier, &outPropertyDataSize);
          if (!PropertyInfo)
          {
            UInt32 v15 = outPropertyDataSize;
            long long v16 = malloc_type_malloc(outPropertyDataSize, 0x7C51E058uLL);
            char v17 = v16;
            if (v15 && !v16)
            {
              exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
              int v22 = std::bad_alloc::bad_alloc(exception);
            }
            uint64_t PropertyInfo = AudioFormatGetProperty(0x666C7374u, 0x38u, inSpecifier, &outPropertyDataSize, v16);
            if (!PropertyInfo)
            {
              AudioChannelLayoutTag v18 = v17[12 * (outPropertyDataSize / 0x30) - 2];
              __dst->mChannelBitmap = 0;
              __dst->mNumberChannelDescriptions = 0;
              __dst->mChannelLayoutTag = v18;
              *a2 = 32;
            }
            free(v17);
          }
        }
      }
      else
      {
        return 2003334207;
      }
    }
  }
  else
  {
    uint64_t v6 = (MP4BoxParser_Track *)*((void *)this + 30);
    uint64_t PropertyInfo = MP4BoxParser_Track::GetInfoFromTrackSubBoxes(v6);
    if (!PropertyInfo)
    {
      if (*a2 < *((_DWORD *)v6 + 93)) {
        return 561211770;
      }
      uint64_t v19 = *((void *)this + 30);
      uint64_t PropertyInfo = MP4BoxParser_Track::GetInfoFromTrackSubBoxes((MP4BoxParser_Track *)v19);
      if (!PropertyInfo)
      {
        unsigned int v20 = *(_DWORD *)(v19 + 372);
        uint64_t PropertyInfo = 561211770;
        if (*a2 >= v20)
        {
          *a2 = v20;
          memcpy(__dst, *(const void **)(v19 + 376), *(unsigned int *)(v19 + 372));
          return 0;
        }
      }
    }
  }
  return PropertyInfo;
}

uint64_t GetACLSize(int a1, unsigned int a2, void *a3)
{
  uint64_t result = 0;
  if (a1 <= 1832149348)
  {
    if (a1 == 1633889587 || a1 == 1634492771) {
      return 32;
    }
    int v5 = 1700998451;
    goto LABEL_10;
  }
  if (a1 > 1935764849)
  {
    if (a1 == 1935767394) {
      return 32;
    }
    int v5 = 1935764850;
LABEL_10:
    if (a1 != v5) {
      return result;
    }
    return 32;
  }
  if (a1 != 1832149349)
  {
    int v5 = 1836069985;
    goto LABEL_10;
  }
  return 32;
}

uint64_t MP4AudioFile::GetChannelLayoutSize(MP4AudioFile *this, unsigned int *a2, unsigned int *a3)
{
  int v5 = *((_DWORD *)this + 8);
  if (a3) {
    *a3 = (v5 == 1819304813) & (*((unsigned __int8 *)this + 100) >> 1);
  }
  if (!a2) {
    return 0;
  }
  *a2 = 0;
  if ((*((unsigned char *)this + 100) & 2) != 0)
  {
    if (v5 == 1819304813)
    {
      int ACLSize = *((_DWORD *)this + 40) - *((_DWORD *)this + 38);
    }
    else
    {
      if (!*((void *)this + 18)) {
        return 2003334207;
      }
      int ACLSize = GetACLSize(v5, a2, a3);
    }
  }
  else
  {
    uint64_t v6 = (MP4BoxParser_Track *)*((void *)this + 30);
    uint64_t result = MP4BoxParser_Track::GetInfoFromTrackSubBoxes(v6);
    if (result) {
      return result;
    }
    int ACLSize = *((_DWORD *)v6 + 93);
  }
  uint64_t result = 0;
  *a2 = ACLSize;
  return result;
}

uint64_t MP4AudioFile::SetMagicCookieData(MP4AudioFile *this, UInt32 inSpecifierSize, char *inSpecifier)
{
  if ((*((unsigned char *)this + 100) & 2) == 0) {
    return 1886547263;
  }
  uint64_t v3 = 1667787583;
  if (inSpecifierSize && inSpecifier)
  {
    double v8 = *((double *)this + 3);
    int v9 = *((_DWORD *)this + 8);
    UInt32 ioPropertyDataSize = 40;
    long long v10 = *(_OWORD *)((char *)this + 40);
    long long outPropertyData = *(_OWORD *)((char *)this + 24);
    long long v19 = v10;
    uint64_t v20 = *((void *)this + 7);
    if (!AudioFormatGetProperty(0x666D7469u, inSpecifierSize, inSpecifier, &ioPropertyDataSize, &outPropertyData))
    {
      uint64_t v3 = (*(uint64_t (**)(MP4AudioFile *, long long *))(*(void *)this + 184))(this, &outPropertyData);
      if (v3) {
        return v3;
      }
      double v11 = *(double *)&outPropertyData;
      if (v8 != *(double *)&outPropertyData)
      {
        *((_DWORD *)this + 114) = *(double *)&outPropertyData;
        uint64_t v12 = *((void *)this + 31);
        *(_DWORD *)(v12 + 28) = v11;
        if (*(_DWORD *)(v12 + 386) == 1) {
          *(_DWORD *)(**(void **)(v12 + 390) + 4) = DWORD1(v19);
        }
      }
    }
    if (v9 == 1935767394 || v9 == 1935764850)
    {
      if (inSpecifierSize != 47)
      {
LABEL_23:
        int v13 = 0;
        uint64_t v3 = 1667787583;
        goto LABEL_24;
      }
      uint64_t v3 = 0;
      *(_DWORD *)(inSpecifier + 26) = 1919770980;
    }
    else
    {
      if (v9 == 1634492771)
      {
        if (*((_DWORD *)inSpecifier + 1) == 1634562662)
        {
          if (inSpecifierSize < 0x38) {
            goto LABEL_23;
          }
        }
        else if (inSpecifierSize != 24 && inSpecifierSize != 48)
        {
          goto LABEL_23;
        }
      }
      uint64_t v3 = 0;
    }
    int v13 = 1;
LABEL_24:
    uint64_t v14 = *((void *)this + 76);
    if (v14)
    {
      MEMORY[0x192FC8940](v14, 0x1000C403E1C8BA9);
      *((void *)this + 76) = 0;
    }
    if (v13)
    {
      uint64_t v15 = *((void *)this + 18);
      if (v15)
      {
        *((void *)this + 18) = 0;
        MEMORY[0x192FC8910](v15, 0x1000C8077774924);
        *((_DWORD *)this + 35) = 0;
      }
      if (inSpecifierSize >= 0x32 && v9 == 1718378851 && *((_DWORD *)inSpecifier + 1) != 1632396900)
      {
        UInt32 outPropertyDataSize = 50;
        uint64_t PropertyInfo = AudioFormatGetPropertyInfo(0x6D636466u, inSpecifierSize, inSpecifier, &outPropertyDataSize);
        if (!PropertyInfo)
        {
          *((_DWORD *)this + 35) = outPropertyDataSize;
          operator new[]();
        }
        return PropertyInfo;
      }
      else
      {
        if (!*((void *)this + 18))
        {
          *((_DWORD *)this + 35) = inSpecifierSize;
          operator new[]();
        }
        if ((*(unsigned int (**)(MP4AudioFile *))(*(void *)this + 272))(this)) {
          operator new();
        }
        return 0;
      }
    }
  }
  return v3;
}

void sub_19019FC34(_Unwind_Exception *a1)
{
  MEMORY[0x192FC8940](v1, 0x1000C403E1C8BA9);
  _Unwind_Resume(a1);
}

uint64_t MP4AudioFile::GetMagicCookieData(const void **this, unsigned int *a2, void *__dst)
{
  uint64_t v3 = 2003334207;
  if (__dst)
  {
    if (a2)
    {
      if ((*((unsigned char *)this + 100) & 2) == 0 || this[18])
      {
        size_t v4 = *((unsigned int *)this + 35);
        uint64_t v3 = 561211770;
        if (*a2 >= v4)
        {
          memcpy(__dst, this[18], v4);
          return 0;
        }
      }
    }
    else
    {
      return 561211770;
    }
  }
  return v3;
}

uint64_t MP4AudioFile::GetMagicCookieDataSize(MP4AudioFile *this, unsigned int *a2, unsigned int *a3)
{
  if (a3) {
    *a3 = *((unsigned char *)this + 100) & 2;
  }
  if (a2) {
    *a2 = *((_DWORD *)this + 35);
  }
  return 0;
}

uint64_t MP4AudioFile::PacketToDependencyInfo(MP4AudioFile *this, AudioPacketDependencyInfoTranslation *a2)
{
  if ((*(unsigned int (**)(MP4AudioFile *))(*(void *)this + 272))(this))
  {
    if ((*((unsigned char *)this + 100) & 2) != 0)
    {
      int v5 = (MP4AudioFile *)((char *)this + 312);
    }
    else
    {
      size_t v4 = (MP4BoxParser_Track *)*((void *)this + 30);
      MP4BoxParser_Track::GetInfoFromTrackSubBoxes(v4);
      int v5 = (MP4BoxParser_Track *)((char *)v4 + 240);
      if ((*((unsigned char *)this + 100) & 2) == 0)
      {
        int v9 = (MP4BoxParser_Track *)*((void *)this + 30);
        MP4BoxParser_Track::GetInfoFromTrackSubBoxes(v9);
        uint64_t v6 = (MP4BoxParser_Track *)((char *)v9 + 296);
        goto LABEL_9;
      }
    }
    uint64_t v6 = (MP4AudioFile *)((char *)this + 368);
LABEL_9:
    return PacketToDependencyInfoForRestrictedRandomAccess(a2, v5, v6);
  }
  if ((*((unsigned char *)this + 100) & 2) != 0)
  {
    double v8 = (MP4AudioFile *)((char *)this + 256);
  }
  else
  {
    int v7 = (MP4BoxParser_Track *)*((void *)this + 30);
    MP4BoxParser_Track::GetInfoFromTrackSubBoxes(v7);
    double v8 = (MP4BoxParser_Track *)((char *)v7 + 152);
  }
  if (*(unsigned char *)v8)
  {
    a2->mIsIndependentlyDecodable = 1;
    v11.SInt64 mPacket = a2->mPacket;
    v11.mRollDistance = 0;
    PacketToRollDistanceForRollRecovery(&v11, v8);
    a2->mNumberPrerollPackets = v11.mRollDistance;
  }
  else
  {
    AudioFileObject::PacketToDependencyInfo(this, a2);
  }
  return 0;
}

uint64_t MP4AudioFile::ScanForIndependentPacket(uint64_t a1, int a2, AudioIndependentPacketTranslation *a3)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 272))(a1))
  {
    if ((*(unsigned char *)(a1 + 100) & 2) != 0)
    {
      int v7 = (SampleToRollDistanceTable **)(a1 + 312);
    }
    else
    {
      uint64_t v6 = *(MP4BoxParser_Track **)(a1 + 240);
      MP4BoxParser_Track::GetInfoFromTrackSubBoxes(v6);
      int v7 = (SampleToRollDistanceTable **)((char *)v6 + 240);
      if ((*(unsigned char *)(a1 + 100) & 2) == 0)
      {
        long long v10 = *(MP4BoxParser_Track **)(a1 + 240);
        MP4BoxParser_Track::GetInfoFromTrackSubBoxes(v10);
        double v8 = (SyncSampleTable **)((char *)v10 + 296);
        goto LABEL_10;
      }
    }
    double v8 = (SyncSampleTable **)(a1 + 368);
LABEL_10:
    return ScanForIndependentPacketWithRestrictedRandomAccess(a2 == 1, a3, v7, v8);
  }
  return AudioFileObject::ScanForIndependentPacket(a1, a2, a3);
}

uint64_t MP4AudioFile::PacketToRollDistance(MP4AudioFile *this, AudioPacketRollDistanceTranslation *a2)
{
  a2->mRollDistance = 0;
  if ((*(unsigned int (**)(MP4AudioFile *))(*(void *)this + 272))(this))
  {
    if ((*((unsigned char *)this + 100) & 2) != 0)
    {
      int v5 = (MP4AudioFile *)((char *)this + 312);
    }
    else
    {
      size_t v4 = (MP4BoxParser_Track *)*((void *)this + 30);
      MP4BoxParser_Track::GetInfoFromTrackSubBoxes(v4);
      int v5 = (MP4BoxParser_Track *)((char *)v4 + 240);
      if ((*((unsigned char *)this + 100) & 2) == 0)
      {
        int v9 = (MP4BoxParser_Track *)*((void *)this + 30);
        MP4BoxParser_Track::GetInfoFromTrackSubBoxes(v9);
        uint64_t v6 = (MP4BoxParser_Track *)((char *)v9 + 296);
        goto LABEL_9;
      }
    }
    uint64_t v6 = (MP4AudioFile *)((char *)this + 368);
LABEL_9:
    if (*(unsigned char *)v5 || *(unsigned char *)v6)
    {
      return PacketToRollDistanceForRestrictedRandomAccess(a2, v5, v6);
    }
    return 0;
  }
  if ((*((unsigned char *)this + 100) & 2) != 0)
  {
    double v8 = (MP4AudioFile *)((char *)this + 256);
  }
  else
  {
    int v7 = (MP4BoxParser_Track *)*((void *)this + 30);
    MP4BoxParser_Track::GetInfoFromTrackSubBoxes(v7);
    double v8 = (MP4BoxParser_Track *)((char *)v7 + 152);
  }
  if (!*(unsigned char *)v8)
  {
    AudioFileObject::PacketToRollDistance(this, a2);
    return 0;
  }
  return PacketToRollDistanceForRollRecovery(a2, v8);
}

uint64_t MP4AudioFile::GetNumPackets(MP4AudioFile *this)
{
  return *((void *)this + 25);
}

uint64_t MP4AudioFile::GetNumBytes(MP4AudioFile *this)
{
  return *((void *)this + 26);
}

uint64_t MP4AudioFile::UpdateSize(MP4AudioFile *this)
{
  return 0;
}

uint64_t MP4AudioFile::GetFormatList(MP4AudioFile *this, UInt32 *ioPropertyDataSize, AudioFormatListItem *outPropertyData)
{
  uint64_t v6 = *((void *)this + 18);
  if ((*((unsigned char *)this + 100) & 2) != 0 && !v6) {
    return 2003334207;
  }
  Float64 v9 = *((double *)this + 3);
  uint64_t v8 = *((void *)this + 4);
  UInt32 v10 = *((_DWORD *)this + 10);
  long long v19 = *(_OWORD *)((char *)this + 44);
  UInt32 v20 = *((_DWORD *)this + 15);
  memset(inSpecifier, 0, sizeof(inSpecifier));
  uint64_t v16 = v8;
  DWORD2(inSpecifier[0]) = v8;
  uint64_t v22 = 0;
  uint64_t v23 = v6;
  int v24 = *((_DWORD *)this + 35);
  if (AudioFormatGetProperty(0x666C7374u, 0x38u, inSpecifier, ioPropertyDataSize, outPropertyData))
  {
    outPropertyData->mASBD.mSampleRate = v9;
    *(void *)&outPropertyData->mASBD.AudioFormatID mFormatID = v16;
    outPropertyData->mASBD.mBytesPerPacket = v10;
    *(_OWORD *)&outPropertyData->mASBD.mFramesPerPacket = v19;
    outPropertyData->mASBD.mReserved = v20;
    if ((*((unsigned char *)this + 100) & 2) != 0)
    {
      int v17 = 32;
      uint64_t result = (*(uint64_t (**)(MP4AudioFile *, int *, AudioChannelLayoutTag *))(*(void *)this + 408))(this, &v17, v18);
      if (result) {
        return result;
      }
      AudioChannelLayoutTag v12 = v18[0];
    }
    else
    {
      AudioPacketRollDistanceTranslation v11 = (MP4BoxParser_Track *)*((void *)this + 30);
      if (MP4BoxParser_Track::GetInfoFromTrackSubBoxes(v11)
        || (int v13 = (AudioChannelLayoutTag *)*((void *)v11 + 47)) == 0)
      {
        AudioChannelLayoutTag v12 = -65536;
      }
      else
      {
        AudioChannelLayoutTag v12 = *v13;
      }
    }
    outPropertyData->mChannelLayoutTag = v12;
    *UInt32 ioPropertyDataSize = 48;
  }
  int v14 = DWORD2(inSpecifier[0]);
  if (DWORD2(inSpecifier[0]) == 1365470320 && outPropertyData->mASBD.mSampleRate == 0.0) {
    outPropertyData->mASBD.mSampleRate = v9;
  }
  uint64_t result = 0;
  BOOL v15 = v14 == 1935767394 || v14 == 1935764850;
  if (v15 && !v10)
  {
    uint64_t result = 0;
    if (outPropertyData->mASBD.mBytesPerPacket)
    {
      outPropertyData->mASBD.mBytesPerPacket = 0;
      outPropertyData->mASBD.mBytesPerFrame = 0;
    }
  }
  return result;
}

uint64_t MP4AudioFile::GetFormatListInfo(MP4AudioFile *this, UInt32 *outPropertyDataSize, unsigned int *a3)
{
  uint64_t v3 = *((void *)this + 18);
  if (!v3) {
    return 2003334207;
  }
  int v6 = *((_DWORD *)this + 8);
  memset(v8, 0, sizeof(v8));
  DWORD2(v8[0]) = v6;
  uint64_t v9 = 0;
  uint64_t v10 = v3;
  int v11 = *((_DWORD *)this + 35);
  if (AudioFormatGetPropertyInfo(0x666C7374u, 0x38u, v8, outPropertyDataSize))
  {
    *UInt32 outPropertyDataSize = 48;
    *a3 = 0;
  }
  return 0;
}

uint64_t MP4AudioFile::SetDataFormat(MP4AudioFile *this, AudioStreamBasicDescription *a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  AudioFormatID mFormatID = a2->mFormatID;
  BOOL v4 = mFormatID == 1700998451 || mFormatID == 1700997939;
  if (v4 && (UInt32 mFramesPerPacket = a2->mFramesPerPacket, mFramesPerPacket != 1536))
  {
    uint64_t v6 = 1718449215;
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      int v9 = 136315650;
      uint64_t v10 = "MP4AudioFile.cpp";
      __int16 v11 = 1024;
      int v12 = 1710;
      __int16 v13 = 1024;
      UInt32 v14 = mFramesPerPacket;
      _os_log_impl(&dword_18FEC0000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%25s:%-5d  disallowing request to set frames per packet to %d (ie, not 1536)", (uint8_t *)&v9, 0x18u);
    }
  }
  else
  {
    uint64_t v6 = AudioFileObject::SetDataFormat(this, a2);
    uint64_t v7 = *((void *)this + 76);
    if (v7)
    {
      MEMORY[0x192FC8940](v7, 0x1000C403E1C8BA9);
      *((void *)this + 76) = 0;
    }
  }
  return v6;
}

uint64_t MP4AudioFile::SetProperty(MP4AudioFile *this, int a2, unsigned int a3, void *a4)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (a2 > 1751216999)
  {
    if (a2 > 1920168565)
    {
      if (a2 == 1920168566)
      {
        uint64_t v7 = 1869627199;
        if ((*((unsigned char *)this + 100) & 2) == 0) {
          return v7;
        }
        uint64_t v17 = *((void *)this + 15);
        if (v17)
        {
          if (*(void *)(v17 + 24)) {
            return v7;
          }
        }
        if (a3 < 8) {
          return 561211770;
        }
        uint64_t v7 = 0;
        *((void *)this + 27) = *a4;
        return v7;
      }
      if (a2 != 1969321067) {
        goto LABEL_49;
      }
      if ((*((unsigned char *)this + 100) & 2) == 0)
      {
        if (a3 < 4) {
          return 561211770;
        }
        uint64_t v11 = 2003334207;
        unsigned int v12 = *(_DWORD *)a4;
        unsigned int v23 = 0;
        if (v12 < *((_DWORD *)this + 125))
        {
          if (v12 == *((_DWORD *)this + 126))
          {
            return 0;
          }
          else
          {
            unsigned int v22 = 0;
            uint64_t v21 = 0;
            uint64_t v7 = (*(uint64_t (**)(void, uint64_t *))(**((void **)this + 13) + 24))(*((void *)this + 13), &v21);
            if (v7) {
              return v7;
            }
            BoxInfo = FindBoxInfo(*((void *)this + 13), 0, v21, 1836019574, 0, *((__n128 ***)this + 28));
            if (!BoxInfo) {
              return 1685348671;
            }
            MP4BoxParser_Movie::MP4BoxParser_Movie((MP4BoxParser_Movie *)v24, *((DataSource **)this + 13), BoxInfo[1].n128_i64[0]);
            uint64_t v7 = MP4BoxParser_Movie::Init((MP4BoxParser_Movie *)v24);
            if (v7)
            {
              MP4BoxParser_Movie::~MP4BoxParser_Movie((MP4BoxParser_Movie *)v24);
              return v7;
            }
            AudioTrackData = MP4BoxParser_Movie::GetAudioTrackData((MP4BoxParser_Movie *)v24, v12, &v22, &v23);
            if (AudioTrackData)
            {
              if (v12)
              {
                *((void *)this + 60) = -1;
                *((void *)this + 61) = 0;
              }
              else
              {
                MP4AudioFile::FillPacketTableInfoFromiTunesUserData(this);
              }
              MP4AudioFile::UseAudioTrack(this, AudioTrackData);
            }
            uint64_t v11 = 0;
            MP4BoxParser_Movie::~MP4BoxParser_Movie((MP4BoxParser_Movie *)v24);
          }
        }
        return v11;
      }
    }
    else
    {
      if (a2 != 1751217000)
      {
        if (a2 != 1886283375) {
          goto LABEL_49;
        }
        if ((*((unsigned char *)this + 100) & 2) != 0)
        {
          if (a3 >= 0x10)
          {
            uint64_t v7 = 0;
            *((_OWORD *)this + 29) = *(_OWORD *)a4;
            *((_OWORD *)this + 30) = *(_OWORD *)a4;
            *((unsigned char *)this + 528) = 1;
            return v7;
          }
          return 561211770;
        }
        return 1886547263;
      }
      if (a3)
      {
        uint64_t v7 = 1886681407;
        int v13 = *((_DWORD *)this + 21);
        if (v13 != 1832149606 && v13 != 1832149350 || (*((unsigned char *)this + 100) & 2) == 0) {
          return v7;
        }
        UInt32 v14 = (void *)*((void *)this + 70);
        if (v14)
        {
          free(v14);
          *((void *)this + 70) = 0;
        }
        *((_DWORD *)this + 139) = a3;
        uint64_t v15 = malloc_type_calloc(1uLL, a3, 0x1AAB77FuLL);
        *((void *)this + 70) = v15;
        memcpy(v15, a4, a3);
      }
    }
    return 0;
  }
  if (a2 <= 1684434291)
  {
    if (a2 != 1633776244)
    {
      if (a2 == 1668182118)
      {
        uint64_t v7 = 1869627199;
        int v8 = *((_DWORD *)this + 21);
        if (v8 != 1832149606 && v8 != 1832149350
          || *((_DWORD *)this + 8) >> 8 != 6381923
          || (*((unsigned char *)this + 100) & 2) == 0)
        {
          return v7;
        }
        if (a3 >= 4)
        {
          uint64_t v7 = 2003334207;
          uint64_t v9 = *((void *)this + 31);
          if (*(void *)(*(void *)(v9 + 442) + 8) == **(void **)(v9 + 442)
            && !*(_DWORD *)(v9 + 434)
            && *(_DWORD *)a4 == 16)
          {
            uint64_t v7 = 0;
            *(_DWORD *)(v9 + 426) = 1937013298;
            *(unsigned char *)(v9 + 437) = 16;
            *((unsigned char *)this + 552) = 1;
          }
          return v7;
        }
        return 561211770;
      }
      goto LABEL_49;
    }
    (*(void (**)(MP4AudioFile *, void))(*(void *)this + 720))(this, *a4);
    return 0;
  }
  if (a2 == 1684434292)
  {
    unsigned int v16 = *(double *)a4;
    *((_DWORD *)this + 114) = v16;
    *(_DWORD *)(*((void *)this + 31) + 28) = v16;
    a2 = 1684434292;
    goto LABEL_49;
  }
  if (a2 == 1701012328)
  {
    uint64_t v7 = 1886681407;
    int v10 = *((_DWORD *)this + 21);
    if (v10 != 1832149606 && v10 != 1832149350 || (*((unsigned char *)this + 100) & 2) == 0) {
      return v7;
    }
    if (a3 >= 4)
    {
      uint64_t v7 = 0;
      *((_DWORD *)this + 142) = *(_DWORD *)a4;
      return v7;
    }
    return 561211770;
  }
LABEL_49:
  return AudioFileObject::SetProperty(this, a2, a3, a4);
}

void sub_1901A08E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  MP4BoxParser_Movie::~MP4BoxParser_Movie((MP4BoxParser_Movie *)va);
  _Unwind_Resume(a1);
}

void MP4AudioFile::FillPacketTableInfoFromiTunesUserData(MP4AudioFile *this)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = 0;
  if (!(*(unsigned int (**)(void, uint64_t *))(**((void **)this + 13) + 24))(*((void *)this + 13), &v13))
  {
    BoxInfo = FindBoxInfo(*((void *)this + 13), 0, v13, 1836019574, 0, *((__n128 ***)this + 28));
    if (BoxInfo)
    {
      uint64_t v3 = *((void *)this + 13);
      unint64_t v4 = BoxInfo[1].n128_u64[0];
      unsigned int v23 = (void (**)(MP4BoxParser_Movie *__hidden))&unk_1EDF8DA18;
      (*(void (**)(uint64_t *__return_ptr, uint64_t, unint64_t))(*(void *)v3 + 88))(&v24, v3, v4);
      char v25 = 0;
      int v26 = 0;
      uint64_t v27 = 0;
      char v28 = 0;
      int v29 = 8;
      unsigned int v23 = off_1EDF92718;
      char v30 = 1;
      uint64_t v31 = 0;
      if (!MP4BoxParser_Movie::Init((MP4BoxParser_Movie *)&v23))
      {
        for (unsigned int i = 0; ; ++i)
        {
          uint64_t v6 = (__n128 **)v31;
          if (!v31 || (uint64_t v7 = *(void *)(v31 + 8), v7 == v31))
          {
            unsigned int v8 = 0;
          }
          else
          {
            unsigned int v8 = 0;
            do
            {
              if (*(_DWORD *)(v7 + 16) == 1969517665) {
                ++v8;
              }
              uint64_t v7 = *(void *)(v7 + 8);
            }
            while (v7 != v31);
          }
          if (i >= v8) {
            break;
          }
          uint64_t v9 = v24;
          unsigned int v10 = ((uint64_t (*)(void))v23[3])(&v23);
          uint64_t v11 = FindBoxInfo(v9, v10, v27, 1969517665, i, v6);
          if (v11)
          {
            uint64_t v12 = v11[1].n128_u64[0] + 8;
            v14.mNumberValidFrames = (SInt64)&unk_1EDF8DA18;
            (*(void (**)(SInt32 *__return_ptr, uint64_t, uint64_t))(*(void *)v24 + 88))(&v14.mPrimingFrames, v24, v12);
            char v15 = 0;
            int v16 = 0;
            uint64_t v17 = 0;
            char v18 = 0;
            int v19 = 8;
            uint64_t v20 = 0;
            int v21 = 0;
            v14.mNumberValidFrames = (SInt64)&unk_1EDF94380;
            memset(v22, 0, sizeof(v22));
            if (!MP4BoxParser_iTunesSMPBMeta::Init(&v14) && *(uint64_t *)&v22[1] >= 1) {
              *((_OWORD *)this + 30) = *(_OWORD *)&v22[1];
            }
            MP4BoxParser_Meta::~MP4BoxParser_Meta((MP4BoxParser_Meta *)&v14);
          }
        }
      }
      MP4BoxParser_Movie::~MP4BoxParser_Movie((MP4BoxParser_Movie *)&v23);
    }
  }
}

void sub_1901A0BF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);
  MP4BoxParser_Movie::~MP4BoxParser_Movie((MP4BoxParser_Movie *)va);
  _Unwind_Resume(a1);
}

void MP4AudioFile::UseAudioTrack(MP4AudioFile *this, void *a2)
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = 0;
  (*(void (**)(void, uint64_t *))(**((void **)this + 13) + 24))(*((void *)this + 13), &v2);
  operator new();
}

void sub_1901A2028(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34)
{
  if (a2)
  {
    if (STACK[0x6B0]) {
      free((void *)STACK[0x6B0]);
    }
    __cxa_begin_catch(exception_object);
    (*(void (**)(uint64_t))(*(void *)v34 + 8))(v34);
    __cxa_end_catch();
    JUMPOUT(0x1901A1B38);
  }
  _Unwind_Resume(exception_object);
}

uint64_t FramesInALACPacket(uint64_t result, unsigned int a2, unsigned int *a3)
{
  *a3 = 0;
  if (a2 >= 7)
  {
    if ((*(unsigned char *)(result + 2) & 0x10) != 0) {
      unsigned int v3 = (*(unsigned __int8 *)(result + 6) >> 1) | (_byteswap_ulong(*(_DWORD *)(result + 2)) << 7);
    }
    else {
      unsigned int v3 = 0;
    }
    *a3 = v3;
  }
  return result;
}

uint64_t MP4AudioFile::GetProperty(MP4AudioFile *this, int a2, unsigned int *a3, __CFDate **a4)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  uint64_t DataForMeaningName = 561211770;
  if (!a3 || !a4) {
    return DataForMeaningName;
  }
  if (a2 > 1701082481)
  {
    if (a2 > 1885564531)
    {
      if (a2 <= 1886283374)
      {
        if (a2 != 1885564532)
        {
          if (a2 == 1885626740)
          {
            if (*a3 >= 8)
            {
              unsigned int v8 = (MP4AudioFile *)*((void *)this + 75);
              if (v8)
              {
                return MP4AudioFile::GetPurchaseDate(v8, a4);
              }
              return 1886681407;
            }
            return DataForMeaningName;
          }
          goto LABEL_75;
        }
        if (*a3 < 8) {
          return DataForMeaningName;
        }
        uint64_t DataForMeaningName = 0;
        char v18 = (__CFDate *)*((void *)this + 25);
LABEL_60:
        *a4 = v18;
        return DataForMeaningName;
      }
      if (a2 != 1969321067)
      {
        if (a2 == 1886283375)
        {
          if (*a3 < 0x10) {
            return DataForMeaningName;
          }
          if (*((void *)this + 58) == -1)
          {
            if (*((void *)this + 60) == -1)
            {
              if ((*((unsigned char *)this + 100) & 2) == 0)
              {
                *a3 = 0;
                return 1667787583;
              }
              *a4 = (__CFDate *)(*((void *)this + 25) * *((unsigned int *)this + 11));
              a4[1] = 0;
              goto LABEL_87;
            }
            uint64_t v17 = (char *)this + 480;
          }
          else
          {
            uint64_t v17 = (char *)this + 464;
          }
          *(_OWORD *)a4 = *(_OWORD *)v17;
LABEL_87:
          uint64_t DataForMeaningName = 0;
          *a3 = 16;
          return DataForMeaningName;
        }
LABEL_75:
        return AudioFileObject::GetProperty(this, a2, a3, (uint64_t *)a4);
      }
      if (*a3 < 4) {
        return DataForMeaningName;
      }
      uint64_t DataForMeaningName = 0;
      int v10 = *((_DWORD *)this + 126);
LABEL_83:
      *(_DWORD *)a4 = v10;
      return DataForMeaningName;
    }
    if (a2 == 1701082482)
    {
      if (*a3 >= 8)
      {
        uint64_t DataForMeaningName = 0;
        *a4 = (__CFDate *)*((void *)this + 56);
      }
      return DataForMeaningName;
    }
    if (a2 != 1751217000)
    {
      if (a2 != 1869640813) {
        goto LABEL_75;
      }
      if ((*((unsigned char *)this + 100) & 2) == 0)
      {
        int v35 = 0;
        uint64_t DataForMeaningName = (*(uint64_t (**)(void, void **))(**((void **)this + 13) + 24))(*((void *)this + 13), &v35);
        if (!DataForMeaningName)
        {
          BoxInfo = FindBoxInfo(*((void *)this + 13), 0, (uint64_t)v35, 1835295092, 0, *((__n128 ***)this + 28));
          if (BoxInfo)
          {
            char v39 = 0;
            (*(void (**)(void, void (***)(MP4BoxParser_Movie *__hidden)))(**((void **)this + 13)
                                                                                                + 24))(*((void *)this + 13), &v39);
            uint64_t DataForMeaningName = 0;
            BOOL v12 = BoxInfo->n128_u64[1] + BoxInfo[1].n128_u64[0] == (void)v39;
            *(_DWORD *)a4 = v12;
            *((_DWORD *)this + 20) = v12;
          }
          else
          {
            uint64_t DataForMeaningName = 2003334207;
            *(_DWORD *)a4 = 0;
          }
        }
        return DataForMeaningName;
      }
      uint64_t DataForMeaningName = 0;
      int v10 = *((unsigned __int8 *)this + 520);
      goto LABEL_83;
    }
    int v22 = *((_DWORD *)this + 21);
    if (v22 == 1832149606 || v22 == 1832149350)
    {
      return MP4AudioFile::GetAudioHash(this, a3, a4);
    }
    return 1869627199;
  }
  if (a2 > 1650683507)
  {
    if (a2 == 1650683508)
    {
      if (*a3 < 8) {
        return DataForMeaningName;
      }
      uint64_t DataForMeaningName = 0;
      char v18 = (__CFDate *)*((void *)this + 26);
      goto LABEL_60;
    }
    if (a2 == 1668182118)
    {
      if (*a3 < 4) {
        return DataForMeaningName;
      }
      if ((*((unsigned char *)this + 100) & 2) != 0)
      {
        if (*((unsigned char *)this + 552))
        {
          uint64_t DataForMeaningName = 0;
          int v10 = *(unsigned __int8 *)(*((void *)this + 31) + 437);
          goto LABEL_83;
        }
      }
      else
      {
        MP4BoxParser_Track::GetSampleTableSubBox((MP4BoxParser_Track *)&v39, *(void *)(*((void *)this + 30) + 64), 1937013298);
        if (v44)
        {
          MP4BoxParser_SampleSize::MP4BoxParser_SampleSize((MP4BoxParser_SampleSize *)&v35, *(DataSource **)(*((void *)this + 30) + 8), v41);
          uint64_t DataForMeaningName = MP4BoxParser_SampleSize::Init((MP4BoxParser **)&v35);
          if (!DataForMeaningName)
          {
            if (v37 == 1937011578) {
              int v23 = 32;
            }
            else {
              int v23 = v38;
            }
            *(_DWORD *)a4 = v23;
          }
          uint64_t v24 = v36;
          int v35 = &unk_1EDF8DA18;
          uint64_t v36 = 0;
          if (v24) {
            (*(void (**)(uint64_t))(*(void *)v24 + 8))(v24);
          }
          if (v43) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v43);
          }
          return DataForMeaningName;
        }
      }
      return 2003334207;
    }
    if (a2 != 1701012328) {
      goto LABEL_75;
    }
    int v13 = *((_DWORD *)this + 21);
    if (v13 == 1832149606 || v13 == 1832149350)
    {
      uint64_t v34 = 0;
      uint64_t DataForMeaningName = (*(uint64_t (**)(void, uint64_t *))(**((void **)this + 13) + 24))(*((void *)this + 13), &v34);
      if (!DataForMeaningName)
      {
        AudioFilePacketTableInfo v14 = FindBoxInfo(*((void *)this + 13), 0, v34, 1836019574, 0, *((__n128 ***)this + 28));
        if (v14)
        {
          uint64_t v15 = *((void *)this + 13);
          unint64_t v16 = v14[1].n128_u64[0];
          char v39 = (void (**)(MP4BoxParser_Movie *__hidden))&unk_1EDF8DA18;
          (*(void (**)(DataSource **__return_ptr, uint64_t, unint64_t))(*(void *)v15 + 88))(&v40, v15, v16);
          LOBYTE(v41) = 0;
          HIDWORD(v41) = 0;
          uint64_t v42 = 0;
          LOBYTE(v43) = 0;
          HIDWORD(v43) = 8;
          char v39 = off_1EDF92718;
          char v45 = 1;
          uint64_t v46 = 0;
          uint64_t DataForMeaningName = 0;
          if (!MP4BoxParser_Movie::Init((MP4BoxParser_Movie *)&v39))
          {
            for (unsigned int i = 0; ; ++i)
            {
              int v26 = (__n128 **)v46;
              if (!v46 || (uint64_t v27 = *(void *)(v46 + 8), v27 == v46))
              {
                unsigned int v28 = 0;
              }
              else
              {
                unsigned int v28 = 0;
                do
                {
                  if (*(_DWORD *)(v27 + 16) == 1969517665) {
                    ++v28;
                  }
                  uint64_t v27 = *(void *)(v27 + 8);
                }
                while (v27 != v46);
              }
              if (i >= v28) {
                break;
              }
              int v29 = v40;
              unsigned int v30 = ((uint64_t (*)(void))v39[3])(&v39);
              uint64_t v31 = FindBoxInfo((uint64_t)v29, v30, v42, 1969517665, i, v26);
              if (v31)
              {
                MP4BoxParser_iTunesMeta::MP4BoxParser_iTunesMeta((MP4BoxParser_iTunesMeta *)&v35, v40, v31[1].n128_u64[0] + 8);
                if (!MP4BoxParser_iTunesMeta::Init((MP4BoxParser_iTunesMeta *)&v35))
                {
                  unsigned int v33 = 0;
                  uint64_t DataForMeaningName = MP4BoxParser_iTunesMeta::GetDataForMeaningName((MP4BoxParser_iTunesMeta *)&v35, "iTunECCH", &v33, a3, v32);
                  *(_DWORD *)a4 = bswap32(v33);
                }
                MP4BoxParser_Meta::~MP4BoxParser_Meta((MP4BoxParser_Meta *)&v35);
              }
            }
          }
          MP4BoxParser_Movie::~MP4BoxParser_Movie((MP4BoxParser_Movie *)&v39);
        }
        else
        {
          return 0;
        }
      }
      return DataForMeaningName;
    }
    return 1869627199;
  }
  if (a2 != 1633776244)
  {
    if (a2 == 1633968493)
    {
      if (*a3 >= 8)
      {
        uint64_t v20 = (MP4BoxParser_iTunesMeta *)*((void *)this + 75);
        if (v20)
        {
          int v35 = 0;
          MP4BoxParser_iTunesMeta::CopyMetaItemData(v20, 1668172100, (const void **)&v35);
          int v21 = v35;
          *a4 = (__CFDate *)v35;
          if (v21) {
            return 0;
          }
          else {
            return 2003334207;
          }
        }
        return 1886681407;
      }
      return DataForMeaningName;
    }
    if (a2 != 1635017588) {
      goto LABEL_75;
    }
    if (*a3 < 4) {
      return DataForMeaningName;
    }
    uint64_t DataForMeaningName = 0;
    int v10 = *((_DWORD *)this + 125);
    goto LABEL_83;
  }
  if (*a3 < 8) {
    return DataForMeaningName;
  }
  int v19 = *(uint64_t (**)(void))(*(void *)this + 712);
  return v19();
}

void sub_1901A2AD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  MP4BoxParser_Movie::~MP4BoxParser_Movie((MP4BoxParser_Movie *)va);
  _Unwind_Resume(a1);
}

uint64_t MP4AudioFile::GetAudioHash(MP4AudioFile *this, unsigned int *a2, void *a3)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  uint64_t v19 = 0;
  uint64_t DataForMeaningName = (*(uint64_t (**)(void, uint64_t *))(**((void **)this + 13) + 24))(*((void *)this + 13), &v19);
  if (!DataForMeaningName)
  {
    BoxInfo = FindBoxInfo(*((void *)this + 13), 0, v19, 1836019574, 0, *((__n128 ***)this + 28));
    if (BoxInfo)
    {
      uint64_t v8 = *((void *)this + 13);
      unint64_t v9 = BoxInfo[1].n128_u64[0];
      int v21 = (void (**)(MP4BoxParser_Movie *__hidden))&unk_1EDF8DA18;
      (*(void (**)(DataSource **__return_ptr, uint64_t, unint64_t))(*(void *)v8 + 88))(&v22, v8, v9);
      char v23 = 0;
      int v24 = 0;
      uint64_t v25 = 0;
      char v26 = 0;
      int v27 = 8;
      int v21 = off_1EDF92718;
      char v28 = 1;
      uint64_t v29 = 0;
      uint64_t DataForMeaningName = 0;
      if (!MP4BoxParser_Movie::Init((MP4BoxParser_Movie *)&v21))
      {
        for (unsigned int i = 0; ; ++i)
        {
          BOOL v12 = (__n128 **)v29;
          if (!v29 || (uint64_t v13 = *(void *)(v29 + 8), v13 == v29))
          {
            unsigned int v14 = 0;
          }
          else
          {
            unsigned int v14 = 0;
            do
            {
              if (*(_DWORD *)(v13 + 16) == 1969517665) {
                ++v14;
              }
              uint64_t v13 = *(void *)(v13 + 8);
            }
            while (v13 != v29);
          }
          if (i >= v14) {
            break;
          }
          uint64_t v15 = v22;
          unsigned int v16 = ((uint64_t (*)(void))v21[3])(&v21);
          uint64_t v17 = FindBoxInfo((uint64_t)v15, v16, v25, 1969517665, i, v12);
          if (v17)
          {
            MP4BoxParser_iTunesMeta::MP4BoxParser_iTunesMeta((MP4BoxParser_iTunesMeta *)v20, v22, v17[1].n128_u64[0] + 8);
            if (!MP4BoxParser_iTunesMeta::Init((MP4BoxParser_iTunesMeta *)v20))
            {
              if (a3) {
                uint64_t DataForMeaningName = MP4BoxParser_iTunesMeta::GetDataForMeaningName((MP4BoxParser_iTunesMeta *)v20, "iTunHASH", a3, a2, v18);
              }
              else {
                *a2 = MP4BoxParser_iTunesMeta::GetDataSizeForMeaningName((MP4BoxParser_iTunesMeta *)v20, "iTunHASH");
              }
            }
            MP4BoxParser_Meta::~MP4BoxParser_Meta((MP4BoxParser_Meta *)v20);
          }
        }
      }
      MP4BoxParser_Movie::~MP4BoxParser_Movie((MP4BoxParser_Movie *)&v21);
    }
    else
    {
      return 0;
    }
  }
  return DataForMeaningName;
}

void sub_1901A2E04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  MP4BoxParser_Movie::~MP4BoxParser_Movie((MP4BoxParser_Movie *)va);
  _Unwind_Resume(a1);
}

uint64_t MP4AudioFile::GetPurchaseDate(MP4AudioFile *this, const __CFDate **a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  if (!this) {
    return 1886681407;
  }
  theString[0] = 0;
  MP4BoxParser_iTunesMeta::CopyMetaItemData(this, 1886745188, (const void **)theString);
  CFStringRef v3 = theString[0];
  if (!theString[0]) {
    return 1667787583;
  }
  CFAbsoluteTime at = 0.0;
  *(_OWORD *)theint String = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  if (!CFStringGetCString(v3, (char *)theString, 256, 0x8000100u)) {
    goto LABEL_9;
  }
  sscanf((const char *)theString, "%d-%d-%d %d:%d:%d", &v9, &v10, &v11, &v12, &v13, &v14);
  unint64_t v4 = CFCalendarCopyCurrent();
  if (v4)
  {
    int v5 = v4;
    int v6 = CFCalendarComposeAbsoluteTime(v4, &at, "yMdHms", v9, v10, v11, v12, v13, v14);
    CFRelease(v5);
    if (v6)
    {
      unint64_t v4 = CFDateCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], at);
      goto LABEL_10;
    }
LABEL_9:
    unint64_t v4 = 0;
  }
LABEL_10:
  *a2 = v4;
  CFRelease(v3);
  return 0;
}

uint64_t MP4AudioFile::GetPropertyInfo(MP4AudioFile *this, int a2, unsigned int *a3, unsigned int *a4)
{
  if (a2 > 1751216999)
  {
    if (a2 <= 1886283374)
    {
      if (a2 == 1751217000)
      {
        int v11 = *((_DWORD *)this + 21);
        if (v11 == 1832149606 || v11 == 1832149350)
        {
          if (a4) {
            *a4 = *((unsigned char *)this + 100) & 2;
          }
          if (a3) {
            return MP4AudioFile::GetAudioHash(this, a3, 0);
          }
          return 0;
        }
        return 1869627199;
      }
      int v8 = 1885626740;
      goto LABEL_22;
    }
    if (a2 == 1969321067)
    {
      if (a3) {
        *a3 = 4;
      }
      if (!a4) {
        return 0;
      }
      uint64_t v5 = 0;
      int v9 = 1;
      goto LABEL_59;
    }
    if (a2 != 1920168566)
    {
      if (a2 != 1886283375) {
        return AudioFileObject::GetPropertyInfo(this, a2, a3, a4);
      }
      if (!a3)
      {
LABEL_31:
        if (a4)
        {
          uint64_t v5 = 0;
          int v9 = (*((unsigned __int8 *)this + 100) >> 1) & 1;
          goto LABEL_59;
        }
        return 0;
      }
      unsigned int v7 = 16;
LABEL_30:
      *a3 = v7;
      goto LABEL_31;
    }
LABEL_28:
    if (!a3) {
      goto LABEL_31;
    }
    unsigned int v7 = 8;
    goto LABEL_30;
  }
  if (a2 <= 1635017587)
  {
    if (a2 != 1633776244)
    {
      int v8 = 1633968493;
LABEL_22:
      if (a2 != v8) {
        return AudioFileObject::GetPropertyInfo(this, a2, a3, a4);
      }
      if (a4) {
        *a4 = 0;
      }
      if (a3)
      {
        uint64_t v5 = 0;
        unsigned int v6 = 8;
        goto LABEL_27;
      }
      return 0;
    }
    goto LABEL_28;
  }
  if (a2 == 1635017588)
  {
    if (a3) {
      *a3 = 4;
    }
    if (a4)
    {
      uint64_t v5 = 0;
      *a4 = 0;
      return v5;
    }
    return 0;
  }
  if (a2 == 1668182118)
  {
    if (a3) {
      *a3 = 4;
    }
    if (!a4) {
      return 0;
    }
    int v10 = *((_DWORD *)this + 21);
    if ((v10 == 1832149606 || v10 == 1832149350) && *((_DWORD *)this + 8) >> 8 == 6381923) {
      int v9 = (*((unsigned __int8 *)this + 100) >> 1) & 1;
    }
    else {
      int v9 = 0;
    }
    uint64_t v5 = 0;
LABEL_59:
    *a4 = v9;
    return v5;
  }
  if (a2 != 1701012328) {
    return AudioFileObject::GetPropertyInfo(this, a2, a3, a4);
  }
  int v4 = *((_DWORD *)this + 21);
  if (v4 != 1832149606 && v4 != 1832149350) {
    return 1869627199;
  }
  if (a4) {
    *a4 = *((unsigned char *)this + 100) & 2;
  }
  if (!a3) {
    return 0;
  }
  uint64_t v5 = 0;
  unsigned int v6 = 4;
LABEL_27:
  *a3 = v6;
  return v5;
}

uint64_t MP4AudioFile::WritePacketsWithDependencyInfo(uint64_t a1, uint64_t a2, unsigned int a3, void *a4, uint64_t a5, uint64_t a6, int *a7, uint64_t a8)
{
  uint64_t v8 = 2003334207;
  if (!a7) {
    return v8;
  }
  if (!*a7) {
    return 0;
  }
  if ((*(unsigned char *)(a1 + 100) & 2) == 0) {
    return 1886547263;
  }
  uint64_t v8 = 1885563711;
  if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 240))(a1) != a6) {
    return v8;
  }
  int v16 = *(_DWORD *)(a1 + 32);
  uint64_t v17 = *(unsigned int *)(a1 + 40);
  unsigned int v83 = *(_DWORD *)(a1 + 44);
  if (!v17)
  {
    if (!a4) {
      return v8;
    }
    unint64_t v20 = *a7;
    if (!v20) {
      goto LABEL_27;
    }
    uint64_t v21 = 0;
    do
    {
      if (!HIDWORD(a4[v21 + 1])) {
        return 2003334207;
      }
      v21 += 2;
    }
    while (2 * v20 != v21);
    unint64_t v22 = 0;
    long long v23 = a4 + 2;
    uint64_t v24 = *a4;
    while (v20 - 1 != v22)
    {
      v24 += *((unsigned int *)v23 - 1);
      uint64_t v25 = *v23;
      v23 += 2;
      ++v22;
      if (v25 != v24)
      {
        if (v22 >= v20) {
          break;
        }
        unsigned int v26 = 0;
        long long v27 = (int *)a4 + 3;
        char v28 = 0;
        do
        {
          int v29 = *v27;
          v27 += 4;
          v26 += v29;
          --v20;
        }
        while (v20);
        goto LABEL_29;
      }
    }
LABEL_27:
    unsigned int v26 = LODWORD(a4[2 * (v20 - 1)]) + HIDWORD(a4[2 * (v20 - 1) + 1]) - *(_DWORD *)a4;
LABEL_28:
    char v28 = 1;
LABEL_29:
    if (v26 > a3) {
      return 561211770;
    }
    unsigned int v82 = v26;
    int v89 = 0;
    if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 240))(a1) < 1)
    {
      uint64_t v31 = 1024;
      if (v16 == 1935764850)
      {
        uint64_t v32 = v82;
      }
      else
      {
        uint64_t v32 = v82;
        if (v16 != 1935767394)
        {
          unint64_t v33 = MP4AudioFile::CalculateDataOffset((MP4AudioFile *)a1, *(double *)(a1 + 216), v85);
          uint64_t v32 = v82;
          uint64_t v31 = v33;
        }
      }
      *(void *)(a1 + 72) = v31;
    }
    else
    {
      if (*(_DWORD *)(*(void *)(a1 + 248) + 426) != 1937011578
        || (unsigned int v30 = *(_DWORD *)(*(void *)(a1 + 248) + 434)) == 0)
      {
        unsigned int v30 = *(_DWORD *)(*(void *)(a1 + 248) + 438);
        if (v30) {
          unsigned int v30 = *(_DWORD *)(**(void **)(*(void *)(a1 + 248) + 442) + 4 * (a6 - 1));
        }
      }
      uint64_t v31 = *(void *)(**(void **)(a1 + 400) + 8 * (a6 - 1)) + v30;
      uint64_t v32 = v82;
    }
    if (v28)
    {
      if (a4) {
        uint64_t v34 = *a4;
      }
      else {
        uint64_t v34 = 0;
      }
      uint64_t v8 = (*(uint64_t (**)(void, void, uint64_t, uint64_t, uint64_t, int *))(**(void **)(a1 + 104) + 56))(*(void *)(a1 + 104), 0, v31, v32, a8 + v34, &v89);
    }
    else
    {
      if (!*a7) {
        goto LABEL_96;
      }
      unsigned int v80 = v17;
      unint64_t v35 = 0;
      uint64_t v36 = (unsigned int *)a4 + 3;
      uint64_t v37 = v31;
      do
      {
        uint64_t v38 = (*(uint64_t (**)(void, void, uint64_t, void, uint64_t, int *))(**(void **)(a1 + 104) + 56))(*(void *)(a1 + 104), 0, v37, *v36, a8 + *(void *)(v36 - 3), &v89);
        unsigned int v39 = *v36;
        v36 += 4;
        v37 += v39;
        ++v35;
      }
      while (v35 < *a7);
      uint64_t v8 = v38;
      uint64_t v17 = v80;
    }
    if (v8) {
      return v8;
    }
    if (*a7)
    {
      unint64_t v40 = 0;
      uint64_t v81 = a5;
      while (1)
      {
        uint64_t v41 = *(void *)(a1 + 400);
        if (!v41) {
          operator new();
        }
        unsigned int v43 = *(uint64_t **)(v41 + 8);
        unint64_t v42 = *(void *)(v41 + 16);
        if ((unint64_t)v43 >= v42)
        {
          char v45 = *(uint64_t **)v41;
          uint64_t v46 = ((uint64_t)v43 - *(void *)v41) >> 3;
          unint64_t v47 = v46 + 1;
          if ((unint64_t)(v46 + 1) >> 61) {
            std::vector<float>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v48 = v42 - (void)v45;
          if (v48 >> 2 > v47) {
            unint64_t v47 = v48 >> 2;
          }
          BOOL v49 = (unint64_t)v48 >= 0x7FFFFFFFFFFFFFF8;
          unint64_t v50 = 0x1FFFFFFFFFFFFFFFLL;
          if (!v49) {
            unint64_t v50 = v47;
          }
          if (v50)
          {
            unint64_t v50 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned char *>>(v50);
            char v45 = *(uint64_t **)v41;
            unsigned int v43 = *(uint64_t **)(v41 + 8);
          }
          else
          {
            uint64_t v51 = 0;
          }
          uint64_t v52 = (uint64_t *)(v50 + 8 * v46);
          uint64_t *v52 = v31;
          char v44 = v52 + 1;
          while (v43 != v45)
          {
            uint64_t v53 = *--v43;
            *--uint64_t v52 = v53;
          }
          *(void *)uint64_t v41 = v52;
          *(void *)(v41 + 8) = v44;
          *(void *)(v41 + 16) = v50 + 8 * v51;
          if (v45) {
            operator delete(v45);
          }
        }
        else
        {
          uint64_t *v43 = v31;
          char v44 = v43 + 1;
        }
        *(void *)(v41 + 8) = v44;
        if (a4)
        {
          uint64_t v54 = v31;
          uint64_t v55 = v17;
          CFDictionaryRef v56 = &a4[2 * v40];
          int v58 = *((_DWORD *)v56 + 3);
          uint64_t v57 = (unsigned int *)v56 + 3;
          unsigned int v59 = v58;
          NUMovieBox::AppendPacketSize(*(void *)(a1 + 248), v58);
          unsigned int v60 = *(v57 - 1);
          if (v60) {
            uint64_t v61 = v60;
          }
          else {
            uint64_t v61 = v83;
          }
          NUMovieBox::AppendTimeToSample(*(void *)(a1 + 248), v61);
          unsigned int v62 = *v57;
          if (v62 > (*(unsigned int (**)(uint64_t))(*(void *)a1 + 632))(a1)) {
            (*(void (**)(uint64_t, void))(*(void *)a1 + 648))(a1, *v57);
          }
          uint64_t v17 = v55;
          uint64_t v31 = v54;
          a5 = v81;
          if (v81) {
            goto LABEL_91;
          }
        }
        else
        {
          NUMovieBox::AppendPacketSize(*(void *)(a1 + 248), v17);
          NUMovieBox::AppendTimeToSample(*(void *)(a1 + 248), v83);
          unsigned int v59 = v17;
          if (a5) {
            goto LABEL_91;
          }
        }
        unint64_t v63 = *(_DWORD **)(a1 + 608);
        if (v63)
        {
          int v64 = &a4[2 * v40];
          uint64_t v65 = *v64;
          uint64_t v66 = *((unsigned int *)v64 + 3);
          int v67 = (unsigned __int8 *)(a8 + *v64);
          *(void *)uint64_t v85 = v67;
          unsigned int v86 = v67;
          int v68 = &v67[v66];
          unsigned int v87 = v68;
          uint64_t v88 = 0;
          if ((v67 & 3) != 0)
          {
            int v69 = 0;
            uint64_t v70 = a8 + 1 + v65;
            int v71 = -8;
            do
            {
              int v72 = v71;
              if (v67 >= v68) {
                int v73 = 255;
              }
              else {
                int v73 = *v67;
              }
              int v69 = v73 | (v69 << 8);
              ++v67;
              int v71 = v72 + 8;
            }
            while ((v70++ & 3) != 0);
            *(void *)uint64_t v85 = v67;
            LODWORD(v88) = v69 << (16 - v72);
            HIDWORD(v88) = v72 + 16;
          }
          v84[0] = 0;
          v84[1] = 0;
          PacketDependencyParser::PacketDependencyInfo(v63, (uint64_t)v85, (uint64_t)v84);
          long long v75 = (int *)v84;
          goto LABEL_93;
        }
LABEL_91:
        if (!a5) {
          goto LABEL_94;
        }
        long long v75 = (int *)(a5 + 16 * v40);
LABEL_93:
        uint64_t v76 = MP4AudioFile::AddPacketDependencyInfo((void *)a1, v40, v75);
        if (v76) {
          return v76;
        }
LABEL_94:
        v31 += v59;
        ++v40;
        unint64_t v77 = *a7;
        if (v40 >= v77) {
          goto LABEL_97;
        }
      }
    }
LABEL_96:
    unint64_t v77 = 0;
LABEL_97:
    uint64_t v8 = 0;
    uint64_t v78 = *(void *)(a1 + 208) + v82;
    *(void *)(a1 + 200) += v77;
    *(void *)(a1 + 208) = v78;
    return v8;
  }
  int v18 = *a7;
  if (v16 != 1935767394 && v16 != 1935764850)
  {
    unsigned int v26 = v18 * v17;
    goto LABEL_28;
  }
  int v19 = v18 - (a3 % v17 != 0);
  if (v18 != 1 || v19)
  {
    unsigned int v26 = v19 * v17;
    *a7 = v19;
    goto LABEL_28;
  }
  uint64_t v8 = 0;
  *a7 = 1;
  return v8;
}

unint64_t MP4AudioFile::CalculateDataOffset(MP4AudioFile *this, double a2, BOOL *a3)
{
  unint64_t v3 = *((unsigned int *)this + 11);
  if (!v3) {
    return 4096;
  }
  double v5 = *((double *)this + 3);
  int v6 = *((_DWORD *)this + 8);
  unint64_t v7 = (unint64_t)((a2 + 1.0) * v5) / v3;
  uint64_t v8 = *((void *)this + 25);
  unsigned int v9 = 4;
  if (v8)
  {
    uint64_t v8 = *(void *)(**((void **)this + 50) + 8 * v8 - 8);
    BOOL v10 = v8 <= 0xFFFFFFFFLL;
    LOBYTE(v8) = v8 > 0xFFFFFFFFLL;
    if (v10) {
      unsigned int v9 = 4;
    }
    else {
      unsigned int v9 = 8;
    }
  }
  int v11 = *((_DWORD *)this + 10);
  *a3 = v8;
  LODWORD(v3) = (v5 / (double)v3) >> 1;
  if (v6 == 1819304813) {
    unint64_t v3 = v3;
  }
  else {
    unint64_t v3 = (v3 + 1);
  }
  int v12 = v9 * (v7 / v3);
  int MetaDataSize = MP4AudioFile::GetMetaDataSize(this, 0, 0, 0, 0, 0, 0);
  uint64_t v14 = *((void *)this + 31);
  uint64_t v15 = *(unsigned int *)(v14 + 8);
  uint64_t v16 = *(unsigned int *)(v14 + 116);
  if (v6 == 1634754915 || v6 == 1902211171 || v6 == 1885433955) {
    int v17 = 5096;
  }
  else {
    int v17 = 1000;
  }
  uint64_t v19 = (v12 + MetaDataSize + v17);
  uint64_t v20 = v7 * v9 + 4103;
  if (v11) {
    uint64_t v20 = 4103;
  }
  return (v20 + v15 + v16 + v19) & 0xFFFFFFFFFFFFF000;
}

uint64_t MP4AudioFile::AddPacketDependencyInfo(void *a1, unsigned int a2, int *a3)
{
  int v6 = (*(uint64_t (**)(void *))(*a1 + 272))(a1);
  int v7 = *a3;
  if (v6)
  {
    if (!v7)
    {
      unsigned int v8 = a3[1];
      if (v8)
      {
        if (v8 >> 15) {
          return 1684369471;
        }
        uint64_t v12 = a1[25] + a2;
        long long v13 = xmmword_1901C6520;
        WORD4(v13) = v8;
        uint64_t v11 = (uint64_t)(a1 + 39);
        goto LABEL_12;
      }
      uint64_t v12 = a1[25] + a2;
      SyncSampleTable::append_entry((uint64_t)(a1 + 46), &v12);
    }
    return 0;
  }
  uint64_t result = 1684369471;
  if (!v7)
  {
    unsigned int v10 = a3[1];
    if (!(v10 >> 15))
    {
      if (v10)
      {
        uint64_t v12 = a1[25] + a2;
        long long v13 = xmmword_1901C6520;
        WORD4(v13) = v10;
        uint64_t v11 = (uint64_t)(a1 + 32);
LABEL_12:
        SampleToRollDistanceTable::append_entry(v11, (long long *)&v12);
      }
      return 0;
    }
  }
  return result;
}

uint64_t MP4AudioFile::GetMetaDataSize(MP4AudioFile *this, unsigned int *a2, unsigned int *a3, unsigned int *a4, unsigned int *a5, unsigned int *a6, unsigned int *a7)
{
  if (*((void *)this + 60) == -1) {
    unsigned int v14 = 0;
  }
  else {
    unsigned int v14 = 188;
  }
  if (*((void *)this + 64)) {
    int v15 = 45 * *((_DWORD *)this + 13) + 72;
  }
  else {
    int v15 = 0;
  }
  unsigned int v16 = MP4AudioFile::AddITunesMetaData(this, 0, 0);
  CFDataRef v17 = (const __CFData *)*((void *)this + 68);
  if (v17
    && ((BytePtr = CFDataGetBytePtr(v17), *(_DWORD *)BytePtr == 1196314761) || *(_DWORD *)(BytePtr + 6) == 1179207242))
  {
    int Length = CFDataGetLength(*((CFDataRef *)this + 68));
    unsigned int v20 = Length + 24;
    if (!Length) {
      unsigned int v20 = 0;
    }
  }
  else
  {
    unsigned int v20 = 0;
  }
  int v21 = *((_DWORD *)this + 139);
  if (v21) {
    unsigned int v22 = v21 + 72;
  }
  else {
    unsigned int v22 = 0;
  }
  if (*((_DWORD *)this + 142)) {
    unsigned int v23 = 76;
  }
  else {
    unsigned int v23 = 0;
  }
  if (a2) {
    *a2 = v14;
  }
  if (a3) {
    *a3 = v15;
  }
  if (a4) {
    *a4 = v16;
  }
  if (a5) {
    *a5 = v20;
  }
  if (a6) {
    *a6 = v22;
  }
  if (a7) {
    *a7 = v23;
  }
  unsigned int v25 = v16 + v14 + v20 + v22 + v15 + v23;
  BOOL v24 = v25 == 0;
  unsigned int v26 = v25 + 62;
  if (v24) {
    return 0;
  }
  else {
    return v26;
  }
}

uint64_t MP4AudioFile::AddITunesMetaData(MP4AudioFile *this, unsigned __int8 *a2, unsigned int a3)
{
  unsigned int v3 = a3;
  int v10 = 0;
  if (*((unsigned char *)this + 572) && (!a2 || a3 >= 0x10))
  {
    if (a2)
    {
      a2[24] = *((unsigned char *)this + 572);
      *(_OWORD *)a2 = xmmword_1901C65A0;
      *((void *)a2 + 2) = 352321536;
      uint64_t v6 = 25;
      int v10 = 25;
      unsigned int v3 = a3 - 25;
      if (a3 == 25) {
        return 0;
      }
      int v7 = a2 + 25;
    }
    else
    {
      int v7 = 0;
      uint64_t v6 = 25;
      int v10 = 25;
    }
  }
  else
  {
    uint64_t v6 = 0;
    int v7 = a2;
  }
  CFDictionaryRef v8 = (const __CFDictionary *)*((void *)this + 67);
  if (!v8) {
    return v6;
  }
  if (!InitiiTunesMetaItemFromInfoDictionary(v7, v3, v8, -1455336876, &v10))
  {
    uint64_t v6 = (v10 + v6);
    if (a2)
    {
      v3 -= v10;
      if (!v3) {
        return 0;
      }
      v7 += v10;
    }
  }
  if (!InitiiTunesMetaItemFromInfoDictionary(v7, v3, *((const __CFDictionary **)this + 67), -1453233054, &v10))
  {
    uint64_t v6 = (v10 + v6);
    if (a2)
    {
      v3 -= v10;
      if (!v3) {
        return 0;
      }
      v7 += v10;
    }
  }
  if (!InitiiTunesMetaItemFromInfoDictionary(v7, v3, *((const __CFDictionary **)this + 67), -1453039239, &v10))
  {
    uint64_t v6 = (v10 + v6);
    if (a2)
    {
      v3 -= v10;
      if (!v3) {
        return 0;
      }
      v7 += v10;
    }
  }
  if (!InitiiTunesMetaItemFromInfoDictionary(v7, v3, *((const __CFDictionary **)this + 67), -1451789708, &v10))
  {
    uint64_t v6 = (v10 + v6);
    if (a2)
    {
      v3 -= v10;
      if (!v3) {
        return 0;
      }
      v7 += v10;
    }
  }
  if (!InitiiTunesMetaItemFromInfoDictionary(v7, v3, *((const __CFDictionary **)this + 67), -1452841618, &v10))
  {
    uint64_t v6 = (v10 + v6);
    if (a2)
    {
      v3 -= v10;
      if (!v3) {
        return 0;
      }
      v7 += v10;
    }
  }
  if (!InitiiTunesMetaItemFromInfoDictionary(v7, v3, *((const __CFDictionary **)this + 67), -1452383891, &v10))
  {
    uint64_t v6 = (v10 + v6);
    if (a2)
    {
      v3 -= v10;
      if (!v3) {
        return 0;
      }
      v7 += v10;
    }
  }
  if (!InitiiTunesMetaItemFromInfoDictionary(v7, v3, *((const __CFDictionary **)this + 67), -1452051405, &v10))
  {
    uint64_t v6 = (v10 + v6);
    if (a2)
    {
      v3 -= v10;
      if (!v3) {
        return 0;
      }
      v7 += v10;
    }
  }
  if (!InitiiTunesMetaItemFromInfoDictionary(v7, v3, *((const __CFDictionary **)this + 67), 1769173603, &v10))
  {
    uint64_t v6 = (v10 + v6);
    if (a2)
    {
      v3 -= v10;
      if (!v3) {
        return 0;
      }
      v7 += v10;
    }
  }
  if (!InitiiTunesMetaItemFromInfoDictionary(v7, v3, *((const __CFDictionary **)this + 67), -1453101708, &v10))
  {
    uint64_t v6 = (v10 + v6);
    if (a2)
    {
      v3 -= v10;
      if (!v3) {
        return 0;
      }
      v7 += v10;
    }
  }
  if (!InitiiTunesMetaItemFromInfoDictionary(v7, v3, *((const __CFDictionary **)this + 67), -1451987089, &v10))
  {
    uint64_t v6 = (v10 + v6);
    if (a2)
    {
      v3 -= v10;
      if (!v3) {
        return 0;
      }
      v7 += v10;
    }
  }
  if (!InitiiTunesMetaItemFromInfoDictionary(v7, v3, *((const __CFDictionary **)this + 67), -1453230732, &v10))
  {
    uint64_t v6 = (v10 + v6);
    if (a2)
    {
      v3 -= v10;
      if (!v3) {
        return 0;
      }
      v7 += v10;
    }
  }
  if (!InitiiTunesMetaItemFromInfoDictionary(v7, v3, *((const __CFDictionary **)this + 67), 1953329263, &v10))
  {
    uint64_t v6 = (v10 + v6);
    if (a2)
    {
      v3 -= v10;
      if (!v3) {
        return 0;
      }
      v7 += v10;
    }
  }
  if (!InitiiTunesMetaItemFromInfoDictionary(v7, v3, *((const __CFDictionary **)this + 67), 1668313716, &v10))
  {
    uint64_t v6 = (v10 + v6);
    if (a2)
    {
      v3 -= v10;
      if (v3)
      {
        v7 += v10;
        goto LABEL_22;
      }
      return 0;
    }
  }
LABEL_22:
  if (!InitiiTunesMetaItemFromInfoDictionary(v7, v3, *((const __CFDictionary **)this + 67), 1953655662, &v10))return (v10 + v6); {
  return v6;
  }
}

uint64_t MP4AudioFile::WritePackets(MP4AudioFile *this, uint64_t a2, uint64_t a3, const AudioStreamPacketDescription *a4, uint64_t a5, unsigned int *a6, const void *a7)
{
  return (*(uint64_t (**)(MP4AudioFile *, uint64_t, uint64_t, const AudioStreamPacketDescription *, void, uint64_t, unsigned int *, const void *))(*(void *)this + 144))(this, a2, a3, a4, 0, a5, a6, a7);
}

uint64_t MP4AudioFile::ReadPacketData(MP4BoxParser_Track **this, uint64_t a2, unsigned int *a3, AudioStreamPacketDescription *a4, int64_t a5, unsigned int *a6, void *a7)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  int64_t v14 = (*((uint64_t (**)(MP4BoxParser_Track **))*this + 30))(this);
  if (v14 <= a5)
  {
LABEL_21:
    *a3 = 0;
    *a6 = 0;
    return 0;
  }
  if (*a6 + a5 > v14) {
    *a6 = v14 - a5;
  }
  unsigned int v23 = 0;
  int v15 = this[30];
  if (MP4BoxParser_Track::GetInfoFromTrackSubBoxes(v15) || !*((unsigned char *)v15 + 440))
  {
    MP4BoxParser_Track::UpdateOffsetTableToIndex(this[30], *a6 + a5);
    if (!*a6) {
      goto LABEL_19;
    }
    unsigned int v16 = 0;
    unsigned int v17 = 0;
    unsigned int v18 = 0;
    do
    {
      if (MP4Parser_PacketProvider::GetPacketInfo(this[30], a5 + v16, &v23, &v22)) {
        break;
      }
      v18 += v23;
      if (v18 > *a3) {
        break;
      }
      ++v17;
      ++v16;
    }
    while (v16 < *a6);
    if (!v17) {
      goto LABEL_19;
    }
  }
  else
  {
    unsigned int v21 = *((_DWORD *)this + 10);
    if (*a3 / v21 >= *a6) {
      unsigned int v17 = *a6;
    }
    else {
      unsigned int v17 = *a3 / v21;
    }
    unsigned int v18 = v17 * v21;
    if (!v17)
    {
LABEL_19:
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)AudioComponentVector buf = 136315394;
        unsigned int v25 = "MP4AudioFile.cpp";
        __int16 v26 = 1024;
        int v27 = 2286;
        _os_log_impl(&dword_18FEC0000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%25s:%-5d  numPacketsToRead == 0", buf, 0x12u);
      }
      goto LABEL_21;
    }
  }
  *a3 = v18;
  *a6 = v17;
  uint64_t v19 = (uint64_t (*)(MP4BoxParser_Track **, uint64_t, unsigned int *, AudioStreamPacketDescription *, int64_t, unsigned int *, void *))*((void *)*this + 11);
  return v19(this, a2, a3, a4, a5, a6, a7);
}

uint64_t MP4AudioFile::ReadPackets(MP4AudioFile *this, uint64_t a2, unsigned int *a3, AudioStreamPacketDescription *a4, uint64_t a5, unsigned int *a6, char *a7)
{
  uint64_t v14 = (*(uint64_t (**)(MP4AudioFile *))(*(void *)this + 240))(this);
  if (v14 <= a5)
  {
    if (a3) {
      *a3 = 0;
    }
    uint64_t result = 0;
LABEL_22:
    *a6 = 0;
    return result;
  }
  uint64_t v15 = *a6;
  if (v15 + a5 > v14)
  {
    LODWORD(v15) = v14 - a5;
    *a6 = v14 - a5;
  }
  *(void *)unint64_t v47 = 0;
  uint64_t v45 = 0;
  if ((*((unsigned char *)this + 100) & 2) != 0)
  {
    uint64_t v31 = (void *)*((void *)this + 50);
    if (v31)
    {
      uint64_t v32 = *(void *)(*v31 + 8 * a5);
      uint64_t ByteCountForPackets = NUMovieBox::GetByteCountForPackets(*((void *)this + 31), v15);
      if ((*(unsigned int (**)(void, void, uint64_t, uint64_t, char *, unsigned int *))(**((void **)this + 13) + 48))(*((void *)this + 13), 0, v32, ByteCountForPackets, a7, v47))
      {
        return 1885563711;
      }
    }
    unint64_t v40 = a3;
    if (a4 && *a6)
    {
      unint64_t v34 = 0;
      uint64_t v35 = 0;
      uint64_t v36 = *((void *)this + 31) + 426;
      int v37 = *(_DWORD *)v36;
      p_UInt32 mDataByteSize = &a4->mDataByteSize;
      do
      {
        if (v37 != 1937011578 || (uint64_t v39 = *(unsigned int *)(v36 + 8), !v39))
        {
          if (*(_DWORD *)(v36 + 12)) {
            uint64_t v39 = *(unsigned int *)(**(void **)(v36 + 16) + 4 * (a5 + v34));
          }
          else {
            uint64_t v39 = 0;
          }
        }
        *(void *)(p_mDataByteSize - 3) = v35;
        *(p_mDataByteSize - 1) = 0;
        *p_UInt32 mDataByteSize = v39;
        v35 += v39;
        ++v34;
        p_mDataByteSize += 4;
      }
      while (v34 < *a6);
    }
  }
  else
  {
    unsigned int v16 = (MP4BoxParser_Track *)*((void *)this + 30);
    if (!MP4BoxParser_Track::GetInfoFromTrackSubBoxes(v16) && *((unsigned char *)v16 + 440)) {
      return AudioFileObject::ReadPackets(this, a2, a3, v17, a5, a6, a7);
    }
    unint64_t v40 = a3;
    MP4BoxParser_Track::UpdateOffsetTableToIndex(*((MP4BoxParser_Track **)this + 30), *a6 + a5);
    unsigned int v18 = *a6;
    if (*a6)
    {
      unsigned int v19 = 0;
      unsigned int v20 = 0;
      SInt64 v21 = 0;
      uint64_t v41 = a6;
      while (1)
      {
        unsigned int v44 = 0;
        int ContiguousPacketCountAndSize = MP4Parser_PacketProvider::GetContiguousPacketCountAndSize(*((uint64_t ***)this + 30), v20 + a5, v18 - v20, &v44, &v47[1]);
        uint64_t v23 = v44;
        if (ContiguousPacketCountAndSize || v44 == 0) {
          break;
        }
        if (MP4Parser_PacketProvider::GetPacketInfo(*((MP4Parser_PacketProvider **)this + 30), v20 + a5, &v46, (unint64_t *)&v45))return 1885563711; {
        uint64_t result = (*(uint64_t (**)(void, void, uint64_t, void, char *, unsigned int *))(**((void **)this + 13) + 48))(*((void *)this + 13), 0, v45, v47[1], a7, &v47[1]);
        }
        uint64_t v26 = v47[1];
        v19 += v47[1];
        v47[0] = v19;
        if (a4)
        {
          unsigned int v42 = v19;
          unsigned int v27 = v20;
          uint64_t v28 = v23;
          do
          {
            unsigned int v43 = 0;
            uint64_t result = MP4Parser_PacketProvider::GetPacketInfo(*((MP4Parser_PacketProvider **)this + 30), a5 + v27, &v43, (unint64_t *)&v45);
            int v29 = &a4[v27];
            v29->mStartOffset = v21;
            uint64_t v30 = v43;
            v29->mVariableFramesInPacket = 0;
            v29->UInt32 mDataByteSize = v30;
            v21 += v30;
            ++v27;
            --v28;
          }
          while (v28);
          a6 = v41;
          unsigned int v19 = v42;
        }
        a7 += v26;
        v20 += v23;
        unsigned int v18 = *a6;
        if (v20 >= *a6) {
          goto LABEL_37;
        }
      }
      uint64_t result = 1885563711;
      goto LABEL_22;
    }
  }
  uint64_t result = 0;
LABEL_37:
  if (v40)
  {
    if (!result) {
      unsigned int *v40 = v47[0];
    }
  }
  return result;
}

uint64_t MP4AudioFile::Optimize(MP4AudioFile *this)
{
  if ((*((unsigned char *)this + 100) & 2) == 0) {
    return 2003334207;
  }
  uint64_t result = 0;
  *((_DWORD *)this + 20) = 1;
  *((unsigned char *)this + 520) = 1;
  return result;
}

uint64_t MP4AudioFile::Close(MP4AudioFile *this)
{
  uint64_t v1 = this;
  uint64_t v222 = *MEMORY[0x1E4F143B8];
  if ((*((unsigned char *)this + 100) & 2) == 0)
  {
    uint64_t SampleDescription = 0;
    goto LABEL_67;
  }
  double v3 = *((double *)this + 3);
  unsigned int v4 = *((_DWORD *)this + 8);
  int v5 = *((_DWORD *)this + 11);
  int v6 = *((_DWORD *)this + 13);
  if (v4 != 1819304813 && !*((_DWORD *)this + 35)) {
    return 2003334207;
  }
  int v220 = 0;
  unsigned int v7 = *MEMORY[0x1E4F1CF68] + CFAbsoluteTimeGetCurrent();
  uint64_t v8 = *((void *)v1 + 31);
  *(_DWORD *)(v8 + 20) = v7;
  *(_DWORD *)(v8 + 24) = v7;
  *(_DWORD *)(v8 + 136) = v7;
  *(_DWORD *)(v8 + 140) = v7;
  *(_DWORD *)(v8 + 236) = v7;
  *(_DWORD *)(v8 + 240) = v7;
  uint64_t v9 = *(unsigned int *)(v8 + 386);
  if (v9)
  {
    uint64_t v10 = 0;
    uint64_t v11 = (_DWORD *)(**(void **)(v8 + 390) + 4);
    do
    {
      v10 += (*v11 * *(v11 - 1));
      v11 += 2;
      --v9;
    }
    while (v9);
  }
  else
  {
    uint64_t v10 = 0;
  }
  *(_DWORD *)(v8 + 244) = v3;
  *(_DWORD *)(v8 + 248) = v10;
  int v12 = *((_DWORD *)v1 + 21);
  BOOL v13 = v12 == 1832149350 || v12 == 1832149606;
  if (v13)
  {
    LODWORD(v14) = v10;
  }
  else
  {
    uint64_t v14 = *((void *)v1 + 58);
    if (v14 == -1) {
      LODWORD(v14) = v10;
    }
  }
  *(_DWORD *)(v8 + 28) = *((_DWORD *)v1 + 114);
  *(_DWORD *)(v8 + 32) = v14;
  *(_DWORD *)(v8 + 152) = v14;
  unsigned int v212 = v1;
  unsigned int v210 = v4;
  if (v12 != 1832149606 && v12 != 1832149350 || !*((unsigned char *)v1 + 528))
  {
    unsigned int v18 = 0;
    unsigned int v16 = 0;
    goto LABEL_46;
  }
  ioPropertyDataSize[0] = 0;
  LODWORD(outPropertyData) = 0;
  v217[0] = 0;
  v216[0] = 0;
  v215[0] = 0;
  unsigned int v219 = 0;
  unsigned int MetaDataSize = MP4AudioFile::GetMetaDataSize(v1, ioPropertyDataSize, (unsigned int *)&outPropertyData, v217, v216, v215, &v219);
  unsigned int v16 = MetaDataSize;
  if (MetaDataSize)
  {
    unsigned int v17 = (char *)malloc_type_malloc(MetaDataSize, 0x2C8E6D5CuLL);
    unsigned int v18 = v17;
    if (!v17)
    {
      exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
      int v193 = std::bad_alloc::bad_alloc(exception);
    }
    bzero(v17, v16);
    UInt32 v19 = outPropertyData + ioPropertyDataSize[0] + v217[0] + v216[0];
    *(_DWORD *)(v18 + 54) = v19 + 8;
    *(_DWORD *)(v18 + 58) = 1768715124;
    *((void *)v18 + 4) = 0x6D64697200000000;
    *((_DWORD *)v18 + 10) = 1634758764;
    *((_DWORD *)v18 + 2) = v19 + 54;
    *((_DWORD *)v18 + 3) = 1835365473;
    *(_DWORD *)unsigned int v18 = v19 + 62;
    *((_DWORD *)v18 + 1) = 1969517665;
    *(int8x16_t *)unsigned int v18 = vrev32q_s8(*(int8x16_t *)v18);
    *(void *)(v18 + 20) = 0x726C646822000000;
    *((int8x16_t *)v18 + 2) = vrev32q_s8(*((int8x16_t *)v18 + 2));
    *((_DWORD *)v18 + 12) = bswap32(*((_DWORD *)v18 + 12));
    *(int8x8_t *)(v18 + 54) = vrev32_s8(*(int8x8_t *)(v18 + 54));
    unsigned int v20 = &xmmword_1901C6000;
    SInt64 v21 = &off_1901C5000;
    if (v219)
    {
      *(_DWORD *)(v18 + 62) = 1275068416;
      *(_OWORD *)(v18 + 66) = xmmword_1901C65B0;
      *(_OWORD *)(v18 + 82) = *(_OWORD *)"com.apple.iTunes";
      *(_DWORD *)(v18 + 98) = 335544320;
      *(void *)(v18 + 102) = 1701667182;
      *(void *)(v18 + 110) = 0x484343456E755469;
      *(_DWORD *)(v18 + 118) = 335544320;
      *(void *)(v18 + 122) = 1635017060;
      v18[129] = 1;
      *(_DWORD *)(v18 + 130) = 0;
      *(_DWORD *)(v18 + 134) = bswap32(*((_DWORD *)v1 + 142));
      unsigned int v22 = 138;
    }
    else
    {
      unsigned int v22 = 62;
    }
    if (v215[0])
    {
      uint64_t v23 = &v18[v22];
      int v24 = *((_DWORD *)v1 + 139);
      *(_DWORD *)uint64_t v23 = bswap32(v24 + 72);
      *(_OWORD *)(v23 + 4) = xmmword_1901C65B0;
      *(_OWORD *)(v23 + 20) = *(_OWORD *)"com.apple.iTunes";
      *((_DWORD *)v23 + 9) = 335544320;
      *((void *)v23 + 5) = 1701667182;
      *((void *)v23 + 6) = 0x485341486E755469;
      *((_DWORD *)v23 + 14) = bswap32(v24 + 16);
      *(void *)(v23 + 60) = 1635017060;
      v23[67] = 1;
      *((_DWORD *)v23 + 17) = 0;
      uint64_t v25 = v22 + 72;
      memcpy(&v18[v25], *((const void **)v1 + 70), *((unsigned int *)v1 + 139));
      unsigned int v20 = &xmmword_1901C6000;
      unsigned int v22 = *((_DWORD *)v1 + 139) + v25;
    }
    if (v217[0])
    {
      MP4AudioFile::AddITunesMetaData(v1, (unsigned __int8 *)&v18[v22], v16 - v22);
      v22 += v217[0];
      unsigned int v20 = &xmmword_1901C6000;
    }
    if (ioPropertyDataSize[0])
    {
      uint64_t v26 = &v18[v22];
      *(_DWORD *)uint64_t v26 = -1140850688;
      *(_OWORD *)(v26 + 4) = v20[91];
      *(_OWORD *)(v26 + 20) = *(_OWORD *)"com.apple.iTunes";
      *((_DWORD *)v26 + 9) = 335544320;
      *((void *)v26 + 5) = 1701667182;
      *((void *)v26 + 6) = 0x42504D536E755469;
      *((_DWORD *)v26 + 14) = -2080374784;
      *(void *)(v26 + 60) = 1635017060;
      v26[67] = 1;
      *((_DWORD *)v26 + 17) = 0;
      unsigned int v27 = &v18[v22 + 72];
      *(void *)&long long v28 = 0x3030303030303030;
      *((void *)&v28 + 1) = 0x3030303030303030;
      *(_OWORD *)(v27 + 49) = v28;
      *(_OWORD *)(v27 + 65) = v28;
      *(_OWORD *)(v27 + 81) = v28;
      *(_OWORD *)(v27 + 97) = v28;
      *((_DWORD *)v27 + 28) = 808464432;
      *(_OWORD *)(v27 + 33) = v28;
      *(_OWORD *)(v27 + 17) = v28;
      *(_OWORD *)(v27 + 1) = v28;
      *unsigned int v27 = 32;
      v27[9] = 32;
      snprintf(__str, 0x20uLL, "%X", *((_DWORD *)v212 + 122));
      size_t v29 = strlen(__str);
      memcpy(&v27[-v29 + 18], __str, v29);
      v27[18] = 32;
      int v30 = *((_DWORD *)v212 + 123);
      *(void *)(v27 + 19) = 0x3030303030303030;
      snprintf(__str, 0x20uLL, "%X", v30);
      size_t v31 = strlen(__str);
      memcpy(&v27[-v31 + 27], __str, v31);
      qmemcpy(v27 + 27, " 0000000000000000", 17);
      snprintf(__str, 0x20uLL, "%qX", *((void *)v212 + 60));
      size_t v32 = strlen(__str);
      memcpy(&v27[-v32 + 44], __str, v32);
      uint64_t v33 = 44;
      do
      {
        v27[v33] = 32;
        v33 += 9;
      }
      while (v33 != 116);
      v22 += 188;
      SInt64 v21 = &off_1901C5000;
      unsigned int v20 = &xmmword_1901C6000;
    }
    uint64_t v1 = v212;
    if (outPropertyData)
    {
      unint64_t v34 = &v18[v22];
      *(_DWORD *)unint64_t v34 = bswap32(45 * v6 + 72);
      *(_OWORD *)(v34 + 4) = v20[91];
      *(_OWORD *)(v34 + 20) = *(_OWORD *)"com.apple.iTunes";
      *((_DWORD *)v34 + 9) = 335544320;
      *((void *)v34 + 5) = 1701667182;
      *((void *)v34 + 6) = 0x4D524F4E6E755469;
      *((_DWORD *)v34 + 14) = bswap32(45 * v6 + 16);
      *(void *)(v34 + 60) = *((void *)v21 + 465);
      v34[67] = 1;
      *((_DWORD *)v34 + 17) = 0;
      uint64_t v35 = v22 + 72;
      FillSCString(*((int **)v212 + 64), *((_DWORD *)v212 + 13), &v18[v35]);
      unsigned int v22 = v35 + 45 * v6;
    }
    if (v216[0])
    {
      CFDataRef v36 = (const __CFData *)*((void *)v212 + 68);
      if (v36)
      {
        unsigned int Length = CFDataGetLength(v36);
        unsigned int v38 = Length;
        if (Length)
        {
          unsigned int v39 = Length + 24;
          if ((unint64_t)Length + 24 <= v16 - v22)
          {
            CFDataRef v40 = (const __CFData *)*((void *)v212 + 68);
            if (v40)
            {
              BytePtr = CFDataGetBytePtr(v40);
              if (*(_DWORD *)BytePtr == 1196314761)
              {
                char v42 = 14;
LABEL_154:
                uint64_t v118 = &v18[v22];
                *(_DWORD *)uint64_t v118 = bswap32(v39);
                *((_DWORD *)v118 + 1) = 1920364387;
                *((_DWORD *)v118 + 2) = bswap32(v38 + 16);
                *((_DWORD *)v118 + 3) = 1635017060;
                *((_WORD *)v118 + 8) = 0;
                v118[18] = 0;
                v118[19] = v42;
                *((_DWORD *)v118 + 5) = 0;
                CFDataRef v119 = (const __CFData *)*((void *)v212 + 68);
                v223.length = CFDataGetLength(v119);
                v223.location = 0;
                CFDataGetBytes(v119, v223, (UInt8 *)v118 + 24);
                goto LABEL_46;
              }
              if (*(_DWORD *)(BytePtr + 6) == 1179207242)
              {
                char v42 = 13;
                goto LABEL_154;
              }
            }
          }
        }
      }
    }
  }
  else
  {
    unsigned int v18 = 0;
  }
LABEL_46:
  unsigned int v219 = 0;
  BOOL v44 = v3 > 65535.0 && v4 == 1819304813;
  uint64_t SampleDescription = (*(uint64_t (**)(void, void, void, uint64_t, unsigned int *, int *))(**((void **)v1 + 13) + 48))(*((void *)v1 + 13), 0, 0, 4, &v219, &v220);
  if (SampleDescription)
  {
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      goto LABEL_67;
    }
    *(_DWORD *)__str = 136315394;
    *(void *)&__str[4] = "MP4AudioFile.cpp";
    *(_WORD *)&__str[12] = 1024;
    *(_DWORD *)&__str[14] = 1225;
    uint64_t v45 = MEMORY[0x1E4F14500];
    unsigned int v46 = "%25s:%-5d  MP4AudioFile::Close - Couldn't read fileType size";
LABEL_66:
    _os_log_impl(&dword_18FEC0000, v45, OS_LOG_TYPE_ERROR, v46, (uint8_t *)__str, 0x12u);
    goto LABEL_67;
  }
  uint64_t v47 = *((void *)v1 + 25);
  int v48 = 8;
  unsigned int v208 = v219;
  if (v47)
  {
    if (*(uint64_t *)(**((void **)v1 + 50) + 8 * v47 - 8) <= 0xFFFFFFFFLL) {
      int v48 = 8;
    }
    else {
      int v48 = 16;
    }
  }
  unsigned int SampleDescriptionSize = MP4AudioFile::GetSampleDescriptionSize(v1, v44);
  unsigned int v50 = SampleDescriptionSize;
  uint64_t v51 = (char *)malloc_type_malloc(SampleDescriptionSize, 0x2C8E6D5CuLL);
  uint64_t v52 = v51;
  if (SampleDescriptionSize) {
    BOOL v53 = v51 == 0;
  }
  else {
    BOOL v53 = 0;
  }
  if (v53)
  {
    unsigned int v190 = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    uint64_t v191 = std::bad_alloc::bad_alloc(v190);
  }
  bzero(v51, SampleDescriptionSize);
  uint64_t SampleDescription = MP4AudioFile::GetSampleDescription(v1, v52, SampleDescriptionSize, v44);
  if (SampleDescription)
  {
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      goto LABEL_67;
    }
    *(_DWORD *)__str = 136315394;
    *(void *)&__str[4] = "MP4AudioFile.cpp";
    *(_WORD *)&__str[12] = 1024;
    *(_DWORD *)&__str[14] = 1237;
    uint64_t v45 = MEMORY[0x1E4F14500];
    unsigned int v46 = "%25s:%-5d  MP4AudioFile::Close - GetSampleDescription() failed";
    goto LABEL_66;
  }
  *(void *)unsigned int v217 = 0;
  CFDataRef outPropertyData = 0;
  int v207 = v5;
  unsigned int v203 = (void *)((char *)v1 + 576);
  if (*((void *)v1 + 72))
  {
    ioPropertyDataSize[0] = 8;
    uint64_t SampleDescription = AudioFormatGetProperty(0x6C626C64u, 8u, (char *)v1 + 576, ioPropertyDataSize, &outPropertyData);
    if (!SampleDescription && outPropertyData) {
      operator new();
    }
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__str = 136315394;
      *(void *)&__str[4] = "MP4AudioFile.cpp";
      *(_WORD *)&__str[12] = 1024;
      *(_DWORD *)&__str[14] = 1247;
      _os_log_impl(&dword_18FEC0000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%25s:%-5d  MP4AudioFile::Close - getting ludt box from loudness info dictionary failed", (uint8_t *)__str, 0x12u);
    }
    unsigned int v60 = 0;
    LODWORD(v64) = 4;
    goto LABEL_257;
  }
  unsigned int v56 = v210;
  if (v5)
  {
    unint64_t v57 = *((void *)v1 + 25);
    int v58 = (int *)*((void *)v1 + 31);
    LODWORD(v59) = v5;
  }
  else
  {
    int v58 = (int *)*((void *)v1 + 31);
    uint64_t v61 = *(unsigned int *)((char *)v58 + 386);
    if (v61)
    {
      unint64_t v62 = 0;
      unint64_t v63 = (_DWORD *)(**(void **)((char *)v58 + 390) + 4);
      do
      {
        v62 += (*v63 * *(v63 - 1));
        v63 += 2;
        --v61;
      }
      while (v61);
    }
    else
    {
      unint64_t v62 = 0;
    }
    unint64_t v57 = *((void *)v1 + 25);
    unint64_t v59 = v62 / v57;
    if (!v59) {
      goto LABEL_87;
    }
  }
  LODWORD(v59) = (v3 / (double)v59) >> 1;
LABEL_87:
  unint64_t v196 = v52;
  int v197 = v44;
  unsigned int v65 = v59 + 1;
  unsigned int v205 = v50;
  unsigned int v204 = v48;
  if (v57)
  {
    unsigned int v66 = v57 / v65;
    uint64_t v67 = *(void *)(**((void **)v1 + 50) + 8 * v57 - 8);
    BOOL v13 = v57 / v65 * v65 == v57;
    BOOL v68 = v13;
    if (v13) {
      int v69 = 12;
    }
    else {
      int v69 = 24;
    }
    if (v67 <= 0xFFFFFFFFLL) {
      int v70 = 4;
    }
    else {
      int v70 = 8;
    }
    if (v67 <= 0xFFFFFFFFLL) {
      char v71 = 2;
    }
    else {
      char v71 = 3;
    }
  }
  else
  {
    unsigned int v66 = 0 / v65;
    BOOL v68 = 0 / v65 * v65 == 0;
    if (0 / v65 * v65) {
      int v69 = 24;
    }
    else {
      int v69 = 12;
    }
    char v71 = 2;
    int v70 = 4;
  }
  int v72 = v1;
  int v73 = *v58;
  if (v68) {
    int v74 = 0;
  }
  else {
    int v74 = v70;
  }
  uint64_t v75 = *((void *)v72 + 9);
  *(void *)unsigned int v215 = 0;
  *(void *)int v216 = 0;
  int v76 = (*(uint64_t (**)(MP4AudioFile *))(*(void *)v72 + 272))(v72);
  unsigned int v78 = v16 + v205 + (v66 << v71) + v73 + v69 + v74;
  uint64_t v1 = v212;
  unsigned int v79 = v204;
  if (v76)
  {
LABEL_105:
    if (*((void *)v212 + 58) == -1)
    {
      *((void *)v212 + 58) = v10;
      *((void *)v212 + 59) = 0;
    }
    unsigned int v80 = malloc_type_calloc(1uLL, 0x24uLL, 0x10000408AA14F5FuLL);
    *(_OWORD *)unsigned int v80 = xmmword_1901C65C0;
    v80[2] = 0x100000000000000;
    *((_DWORD *)v80 + 6) = bswap32(*((_DWORD *)v212 + 116));
    *((_DWORD *)v80 + 7) = bswap32(*((_DWORD *)v212 + 118));
    *((_DWORD *)v80 + 8) = 256;
    if (!(*(unsigned int (**)(void))(*(void *)v212 + 272))())
    {
      if (AudioFormatEncryptedFormatTranslator::DecryptFormatID(v210, (int *)__str) >> 8 == 6381923) {
        v77.n128_f64[0] = CreateSampleToRollGroup(*((void *)v212 + 25), v216, v215);
      }
      uint64_t v85 = 0;
      unsigned int v93 = v78 + 36;
      goto LABEL_125;
    }
    memset(__str, 0, 24);
    std::vector<SyncSampleEntry>::__init_with_size[abi:ne180100]<SyncSampleEntry*,SyncSampleEntry*>(__str, *((const void **)v212 + 47), *((void *)v212 + 48), (uint64_t)(*((void *)v212 + 48) - *((void *)v212 + 47)) >> 3);
    uint64_t v81 = v75;
    unsigned int v82 = *(int **)__str;
    if (*((unsigned char *)v212 + 368)) {
      uint64_t v83 = ((*(void *)&__str[8] - *(void *)__str) >> 3);
    }
    else {
      uint64_t v83 = 0;
    }
    BOOL v84 = (char *)malloc_type_calloc(1uLL, 4 * v83 + 16, 0x85A86819uLL);
    uint64_t v85 = (unsigned int *)v84;
    *(_DWORD *)BOOL v84 = bswap32(4 * v83 + 16);
    unsigned int v86 = bswap32(v83);
    v77.n128_u64[0] = 1936946291;
    *(void *)(v84 + 4) = 1936946291;
    *((_DWORD *)v84 + 3) = v86;
    if (v83)
    {
      unsigned int v87 = v84 + 16;
      uint64_t v88 = v82;
      unsigned int v56 = v210;
      do
      {
        int v89 = *v88;
        v88 += 2;
        *v87++ = bswap32(v89 + 1);
        --v83;
      }
      while (v83);
    }
    else
    {
      unsigned int v56 = v210;
      if (!v82) {
        goto LABEL_123;
      }
    }
    operator delete(v82);
    unsigned int v86 = v85[3];
LABEL_123:
    uint64_t v75 = v81;
    unsigned int v93 = v78 + 4 * bswap32(v86) + 52;
    if (*((unsigned char *)v212 + 312)) {
      CreateSampleToPrerollGroup(*((char **)v212 + 25), (uint64_t)v212 + 312, v216, v215);
    }
LABEL_125:
    uint64_t v202 = v85;
    long long v92 = *(unsigned int **)v216;
    if (*(void *)v216) {
      unsigned int v94 = 2 * bswap32(*(_DWORD *)(*(void *)v216 + 20)) + 24;
    }
    else {
      unsigned int v94 = 0;
    }
    uint64_t v1 = v212;
    unsigned int v79 = v204;
    unsigned int v95 = v94 + v93;
    uint64_t v90 = *(unsigned int **)v215;
    if (*(void *)v215) {
      unsigned int v96 = 8 * bswap32(*(_DWORD *)(*(void *)v215 + 16)) + 20;
    }
    else {
      unsigned int v96 = 0;
    }
    unsigned int v78 = v95 + v96;
    goto LABEL_132;
  }
  uint64_t v90 = 0;
  int v91 = *((_DWORD *)v212 + 21);
  if (v91 == 1832149350)
  {
    long long v92 = 0;
    uint64_t v202 = 0;
    unsigned int v80 = 0;
  }
  else
  {
    long long v92 = 0;
    uint64_t v202 = 0;
    unsigned int v80 = 0;
    if (v91 != 1832149606) {
      goto LABEL_105;
    }
  }
LABEL_132:
  __int16 v200 = v90;
  uint64_t v201 = v92;
  uint64_t v97 = bswap32(v208);
  uint64_t v98 = v79;
  uint64_t v99 = v75;
  uint64_t v100 = v75 - v79;
  unsigned int v101 = v205;
  if (v100 < 1 || (uint64_t v102 = v97 + v78, v102 == v100))
  {
    int v194 = 0;
  }
  else if (v100 - v97 - 8 >= (unint64_t)v78)
  {
    int v194 = 1;
  }
  else if (*((unsigned char *)v1 + 520))
  {
    uint64_t v110 = ((v79 | 0x1007) + v102) & 0x3FFFFF000;
    if (*((void *)v1 + 25))
    {
      uint64_t v111 = 0;
      uint64_t v112 = (v110 - *((_DWORD *)v1 + 18));
      uint64_t v113 = **((void **)v1 + 50);
      unsigned int v114 = 1;
      do
      {
        *(void *)(v113 + 8 * v111) += v112;
        uint64_t v111 = v114;
      }
      while (*((void *)v1 + 25) > (unint64_t)v114++);
    }
    uint64_t SampleDescription = AudioFileObject::MoveData(v1, v99, v110, *((void *)v1 + 26));
    if (SampleDescription)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__str = 136315394;
        *(void *)&__str[4] = "MP4AudioFile.cpp";
        *(_WORD *)&__str[12] = 1024;
        *(_DWORD *)&__str[14] = 1359;
        unint64_t v116 = MEMORY[0x1E4F14500];
        uint64_t v117 = "%25s:%-5d  MP4AudioFile::Close - Couldn't move data to optimize";
        goto LABEL_254;
      }
      goto LABEL_255;
    }
    *((void *)v1 + 9) = v110;
    uint64_t v100 = v110 - v98;
    int v194 = 1;
    unsigned int v56 = v210;
  }
  else
  {
    uint64_t v199 = v79;
    MP4AudioFile::NewMP4BoxToFile(*((MP4AudioFile **)v1 + 13), v100 - v97, v97);
    int v185 = (void *)*((void *)v212 + 50);
    uint64_t v186 = *(void *)(*v185 + 8 * (*(uint64_t (**)(AudioFileObject *))(*(void *)v212 + 240))(v212) - 8);
    uint64_t v187 = *((void *)v212 + 31);
    int v188 = (*(uint64_t (**)(AudioFileObject *))(*(void *)v212 + 240))(v212);
    uint64_t v1 = v212;
    unsigned int v101 = v205;
    if (*(_DWORD *)(v187 + 426) != 1937011578 || (unsigned int v189 = *(_DWORD *)(v187 + 434)) == 0)
    {
      unsigned int v189 = *(_DWORD *)(v187 + 438);
      if (v189) {
        unsigned int v189 = *(_DWORD *)(**(void **)(v187 + 442) + 4 * (v188 - 1));
      }
    }
    int v194 = 0;
    uint64_t v97 = v186 + v189;
    uint64_t v98 = v199;
  }
  unint64_t v103 = *((void *)v1 + 25);
  int v206 = v18;
  if (!v103)
  {
    uint64_t v108 = (uint64_t)v80;
    unsigned int v109 = 0;
    goto LABEL_245;
  }
  LODWORD(v104) = v207;
  if (!v207)
  {
    uint64_t v105 = *(unsigned int *)(*((void *)v1 + 31) + 386);
    if (v105)
    {
      unint64_t v106 = 0;
      long long v107 = (_DWORD *)(**(void **)(*((void *)v1 + 31) + 390) + 4);
      do
      {
        v106 += (*v107 * *(v107 - 1));
        v107 += 2;
        --v105;
      }
      while (v105);
    }
    else
    {
      unint64_t v106 = 0;
    }
    unint64_t v104 = v106 / v103;
  }
  unsigned int v209 = v16;
  uint64_t v195 = v97;
  if (v104)
  {
    v77.n128_f64[0] = v3 / (double)v104 * 0.5;
    LODWORD(v104) = v77.n128_f64[0];
  }
  uint64_t v198 = v98;
  uint64_t v120 = 0;
  BOOL v13 = v56 == 1819304813;
  unsigned int v121 = 0;
  if (!v13) {
    LODWORD(v104) = v104 + 1;
  }
  if (v104 <= 1) {
    unsigned int v122 = 1;
  }
  else {
    unsigned int v122 = v104;
  }
  long long v123 = v212;
  do
  {
    if (v103 - v120 < v122) {
      unsigned int v122 = v103 - v120;
    }
    uint64_t v124 = *((void *)v123 + 31);
    if (!v122)
    {
      uint64_t v156 = **((void **)v123 + 50);
      uint64_t v157 = *(void *)(v156 + 8 * v120);
      goto LABEL_208;
    }
    unsigned int v211 = v121;
    int v125 = 0;
    int v126 = *(_DWORD *)(v124 + 462) + 1;
    do
    {
      uint64_t v127 = *((void *)v212 + 31);
      int v128 = *(_DWORD *)(v127 + 410);
      if (v128)
      {
        unint64_t v129 = *(int ***)(v127 + 414);
        uint64_t v130 = *v129;
        if ((*v129)[3 * (v128 - 1) + 1] == v122) {
          goto LABEL_204;
        }
        *(_DWORD *)(v127 + 398) += 12;
        *(_DWORD *)(v127 + 410) = v128 + 1;
        unint64_t v131 = v129[1];
        unint64_t v132 = (unint64_t)v129[2];
        if ((unint64_t)v131 >= v132)
        {
          unint64_t v141 = 0xAAAAAAAAAAAAAAABLL * (v131 - v130);
          if (v141 + 1 > 0x1555555555555555) {
LABEL_300:
          }
            std::vector<float>::__throw_length_error[abi:ne180100]();
          unint64_t v142 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v132 - (void)v130) >> 2);
          uint64_t v143 = 2 * v142;
          if (2 * v142 <= v141 + 1) {
            uint64_t v143 = v141 + 1;
          }
          if (v142 >= 0xAAAAAAAAAAAAAAALL) {
            unint64_t v144 = 0x1555555555555555;
          }
          else {
            unint64_t v144 = v143;
          }
          if (v144)
          {
            unint64_t v144 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<auoop::RenderPipeConfig::CompactFormat>>(v144);
            unint64_t v131 = v129[1];
          }
          else
          {
            uint64_t v145 = 0;
          }
          long long v151 = (int *)(v144 + 12 * v141);
          *long long v151 = v126;
          v151[1] = v122;
          v151[2] = 1;
          long long v152 = *v129;
          long long v153 = v151;
          if (v131 != *v129)
          {
            do
            {
              uint64_t v154 = *(void *)(v131 - 3);
              v131 -= 3;
              int v155 = v131[2];
              *(void *)(v153 - 3) = v154;
              v153 -= 3;
              v153[2] = v155;
            }
            while (v131 != v152);
            unint64_t v131 = *v129;
          }
          unint64_t v150 = v144 + 12 * v145;
          long long v133 = v151 + 3;
          const char *v129 = v153;
          goto LABEL_201;
        }
        *unint64_t v131 = v126;
        v131[1] = v122;
        long long v133 = v131 + 3;
        v131[2] = 1;
      }
      else
      {
        *(_DWORD *)(v127 + 398) += 12;
        *(_DWORD *)(v127 + 410) = 1;
        unint64_t v129 = *(int ***)(v127 + 414);
        long long v135 = v129[1];
        unint64_t v134 = (unint64_t)v129[2];
        if ((unint64_t)v135 >= v134)
        {
          unint64_t v131 = *v129;
          unint64_t v136 = 0xAAAAAAAAAAAAAAABLL * (v135 - *v129);
          unint64_t v137 = v136 + 1;
          if (v136 + 1 > 0x1555555555555555) {
            goto LABEL_300;
          }
          unint64_t v138 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v134 - (void)v131) >> 2);
          if (2 * v138 > v137) {
            unint64_t v137 = 2 * v138;
          }
          if (v138 >= 0xAAAAAAAAAAAAAAALL) {
            unint64_t v139 = 0x1555555555555555;
          }
          else {
            unint64_t v139 = v137;
          }
          if (v139)
          {
            unint64_t v139 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<auoop::RenderPipeConfig::CompactFormat>>(v139);
            unint64_t v131 = *v129;
            long long v135 = v129[1];
          }
          else
          {
            uint64_t v140 = 0;
          }
          long long v146 = (int *)(v139 + 12 * v136);
          *long long v146 = 1;
          v146[1] = v122;
          v146[2] = 1;
          long long v147 = v146;
          if (v135 != v131)
          {
            do
            {
              uint64_t v148 = *(void *)(v135 - 3);
              v135 -= 3;
              int v149 = v135[2];
              *(void *)(v147 - 3) = v148;
              v147 -= 3;
              v147[2] = v149;
            }
            while (v135 != v131);
            unint64_t v131 = *v129;
          }
          unint64_t v150 = v139 + 12 * v140;
          long long v133 = v146 + 3;
          const char *v129 = v147;
LABEL_201:
          v129[1] = v133;
          v129[2] = (int *)v150;
          if (v131) {
            operator delete(v131);
          }
          goto LABEL_203;
        }
        *long long v135 = 1;
        v135[1] = v122;
        long long v133 = v135 + 3;
        v135[2] = 1;
      }
LABEL_203:
      v129[1] = v133;
      *(_DWORD *)(v127 + 350) += 12;
      *(_DWORD *)(v127 + 290) += 12;
      *(_DWORD *)(v127 + 216) += 12;
      *(_DWORD *)(v127 + 116) += 12;
      *(_DWORD *)v127 += 12;
LABEL_204:
      ++v125;
    }
    while (v125 != v122);
    uint64_t v124 = *((void *)v212 + 31);
    unint64_t v103 = *((void *)v212 + 25);
    uint64_t v156 = **((void **)v212 + 50);
    uint64_t v157 = *(void *)(v156 + 8 * v120);
    if (v103)
    {
      unsigned int v121 = v211;
LABEL_208:
      if (*(uint64_t *)(v156 + 8 * v103 - 8) <= 0xFFFFFFFFLL) {
        int v158 = 4;
      }
      else {
        int v158 = 8;
      }
    }
    else
    {
      int v158 = 4;
      unsigned int v121 = v211;
    }
    *(_DWORD *)(v124 + 450) += v158;
    ++*(_DWORD *)(v124 + 462);
    uint64_t v159 = *(void *)(v124 + 466);
    long long v161 = *(void **)(v159 + 8);
    unint64_t v160 = *(void *)(v159 + 16);
    if ((unint64_t)v161 >= v160)
    {
      long long v163 = *(void **)v159;
      uint64_t v164 = ((uint64_t)v161 - *(void *)v159) >> 3;
      unint64_t v165 = v164 + 1;
      if ((unint64_t)(v164 + 1) >> 61) {
        std::vector<float>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v166 = v160 - (void)v163;
      if (v166 >> 2 > v165) {
        unint64_t v165 = v166 >> 2;
      }
      BOOL v167 = (unint64_t)v166 >= 0x7FFFFFFFFFFFFFF8;
      unint64_t v168 = 0x1FFFFFFFFFFFFFFFLL;
      if (!v167) {
        unint64_t v168 = v165;
      }
      if (v168)
      {
        unint64_t v168 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned char *>>(v168);
        long long v163 = *(void **)v159;
        long long v161 = *(void **)(v159 + 8);
      }
      else
      {
        uint64_t v169 = 0;
      }
      long long v170 = (void *)(v168 + 8 * v164);
      *long long v170 = v157;
      long long v162 = v170 + 1;
      while (v161 != v163)
      {
        uint64_t v171 = *--v161;
        *--long long v170 = v171;
      }
      *(void *)uint64_t v159 = v170;
      *(void *)(v159 + 8) = v162;
      *(void *)(v159 + 16) = v168 + 8 * v169;
      if (v163) {
        operator delete(v163);
      }
    }
    else
    {
      *long long v161 = v157;
      long long v162 = v161 + 1;
    }
    *(void *)(v159 + 8) = v162;
    *(_DWORD *)(v124 + 350) += v158;
    *(_DWORD *)(v124 + 290) += v158;
    *(_DWORD *)(v124 + 216) += v158;
    *(_DWORD *)(v124 + 116) += v158;
    *(_DWORD *)v124 += v158;
    long long v123 = v212;
    unint64_t v103 = *((void *)v212 + 25);
    v121 += v122;
    uint64_t v120 = v121;
  }
  while (v103 > v121);
  unsigned int v16 = v209;
  unsigned int v101 = v205;
  if (v80) {
    unsigned int v109 = v205 + v209 + **((_DWORD **)v212 + 31) + 36;
  }
  else {
    unsigned int v109 = v205 + v209 + **((_DWORD **)v212 + 31);
  }
  uint64_t v1 = v212;
  if (v202) {
    v109 += 4 * bswap32(v202[3]) + 16;
  }
  uint64_t v97 = v195;
  if (v201) {
    v109 += 2 * bswap32(v201[5]) + 24;
  }
  if (v200) {
    v109 += 8 * bswap32(v200[4]) + 20;
  }
  ioPropertyDataSize[1] = 1952539757;
  if (v103 && *(uint64_t *)(**((void **)v212 + 50) + 8 * v103 - 8) >= 0x100000000)
  {
    ioPropertyDataSize[0] = 0x1000000;
    unint64_t v214 = bswap64(*((void *)v212 + 26) + 16);
  }
  else
  {
    ioPropertyDataSize[0] = bswap32(*((_DWORD *)v212 + 52) + 8);
  }
  uint64_t v100 = *((void *)v212 + 9) - v198;
  uint64_t SampleDescription = (*(uint64_t (**)(void, void, uint64_t, void, UInt32 *, int *, __n128))(**((void **)v212 + 13) + 56))(*((void *)v212 + 13), 0, v100, v204, ioPropertyDataSize, &v220, v77);
  if (SampleDescription)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__str = 136315394;
      *(void *)&__str[4] = "MP4AudioFile.cpp";
      *(_WORD *)&__str[12] = 1024;
      *(_DWORD *)&__str[14] = 1466;
      unint64_t v116 = MEMORY[0x1E4F14500];
      uint64_t v117 = "%25s:%-5d  MP4AudioFile::Close - GetDataSource()->WriteBytes - mediaBoxHeader";
      goto LABEL_254;
    }
    goto LABEL_255;
  }
  uint64_t v108 = (uint64_t)v80;
LABEL_245:
  unsigned int v172 = v16;
  if (*v203)
  {
    CA_calloc(0);
    int v174 = v173;
    *int v173 = bswap32(0);
    v173[1] = 1635017845;
    v173[2] = bswap32(8u);
    v173[3] = 1952740716;
    CFDataGetBytePtr(outPropertyData);
  }
  else
  {
    int v174 = 0;
  }
  uint64_t v175 = v97 + v109;
  if (v97 >= v100 || v100 >= v175)
  {
    int v176 = (void *)v108;
    uint64_t SampleDescription = NUMovieBox::SerializeToDataSource(*((unsigned int **)v1 + 31), *((void *)v1 + 13), v97, v197, v196, v101, v206, v172, v108, v202, v201, v200, v174, 0, *((unsigned char *)v1 + 552));
    if (SampleDescription)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__str = 136315394;
        *(void *)&__str[4] = "MP4AudioFile.cpp";
        *(_WORD *)&__str[12] = 1024;
        *(_DWORD *)&__str[14] = 1515;
        unint64_t v116 = MEMORY[0x1E4F14500];
        uint64_t v117 = "%25s:%-5d  MP4AudioFile::Close - SerializeToDataSource() failed";
LABEL_254:
        _os_log_impl(&dword_18FEC0000, v116, OS_LOG_TYPE_ERROR, v117, (uint8_t *)__str, 0x12u);
      }
LABEL_255:
      LODWORD(v64) = 4;
    }
    else
    {
      if (v194) {
        MP4AudioFile::NewMP4BoxToFile(*((MP4AudioFile **)v1 + 13), v100 - v175, v175);
      }
      if (v196) {
        free(v196);
      }
      if (v206) {
        free(v206);
      }
      if (v176) {
        free(v176);
      }
      if (v202) {
        free(v202);
      }
      if (*(void *)v215) {
        free(*(void **)v215);
      }
      if (*(void *)v216) {
        free(*(void **)v216);
      }
      if (v174) {
        free(v174);
      }
      uint64_t v177 = *((void *)v1 + 31);
      uint64_t v178 = *(void *)(v177 + 442);
      if (v178)
      {
        int v179 = *(void **)v178;
        if (*(void *)v178)
        {
          *(void *)(v178 + 8) = v179;
          operator delete(v179);
        }
        MEMORY[0x192FC8940](v178, 0x10C402FEFCB83);
        uint64_t v177 = *((void *)v1 + 31);
      }
      uint64_t v180 = *(void *)(v177 + 466);
      if (v180)
      {
        int v181 = *(void **)v180;
        if (*(void *)v180)
        {
          *(void *)(v180 + 8) = v181;
          operator delete(v181);
        }
        MEMORY[0x192FC8940](v180, 0x10C402FEFCB83);
        uint64_t v177 = *((void *)v1 + 31);
      }
      uint64_t v182 = *(void *)(v177 + 414);
      if (v182)
      {
        int v183 = *(void **)v182;
        if (*(void *)v182)
        {
          *(void *)(v182 + 8) = v183;
          operator delete(v183);
        }
        MEMORY[0x192FC8940](v182, 0x20C40960023A9);
        uint64_t v177 = *((void *)v1 + 31);
      }
      uint64_t v64 = *(void *)(v177 + 390);
      if (v64)
      {
        unsigned int v184 = *(void **)v64;
        if (*(void *)v64)
        {
          *(void *)(v64 + 8) = v184;
          operator delete(v184);
        }
        MEMORY[0x192FC8940](v64, 0x20C40960023A9);
        LODWORD(v64) = 0;
      }
      uint64_t SampleDescription = 0;
    }
  }
  else
  {
    uint64_t SampleDescription = 0;
    LODWORD(v64) = 1;
  }
  unsigned int v60 = *(CACFData **)v217;
LABEL_257:
  *(void *)unsigned int v217 = 0;
  if (v60)
  {
    CACFData::~CACFData(v60);
    MEMORY[0x192FC8940]();
  }
  if ((v64 | 4) != 4) {
    return 2003334207;
  }
LABEL_67:
  uint64_t v54 = *((void *)v1 + 13);
  if (v54) {
    (*(void (**)(uint64_t))(*(void *)v54 + 8))(v54);
  }
  *((void *)v1 + 13) = 0;
  return SampleDescription;
}

void sub_1901A5FEC(_Unwind_Exception *a1)
{
  std::unique_ptr<CACFData>::reset[abi:ne180100]((CACFData **)(v1 - 168));
  _Unwind_Resume(a1);
}

uint64_t MP4AudioFile::GetSampleDescriptionSize(MP4AudioFile *this, int a2)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  int v3 = *((_DWORD *)this + 8);
  if (v3 <= 1718378850)
  {
    if (v3 == 1633889587) {
      goto LABEL_16;
    }
    if (v3 != 1634492771)
    {
      if (v3 != 1700998451) {
        goto LABEL_24;
      }
LABEL_16:
      UInt32 v9 = *((_DWORD *)this + 35);
      goto LABEL_17;
    }
    int v11 = *((_DWORD *)this + 35);
    if (*(_DWORD *)(*((void *)this + 18) + 4) == 1634562662)
    {
      if (v11 != 80)
      {
LABEL_28:
        int v8 = 72;
        goto LABEL_31;
      }
    }
    else if (v11 != 48)
    {
      goto LABEL_28;
    }
    int v8 = 96;
    goto LABEL_31;
  }
  if (v3 > 1935764849)
  {
    if (v3 == 1935764850 || v3 == 1935767394)
    {
      int v8 = 53;
      goto LABEL_31;
    }
    goto LABEL_24;
  }
  if (v3 == 1718378851) {
    goto LABEL_16;
  }
  if (v3 != 1819304813)
  {
LABEL_24:
    UInt32 outPropertyDataSize = 0;
    inSpecifier[0] = v3;
    inSpecifier[1] = *((_DWORD *)this + 21);
    uint64_t v31 = *((void *)this + 18);
    uint64_t v32 = 0;
    LODWORD(v32) = *((_DWORD *)this + 35);
    if (AudioFormatGetPropertyInfo(0x65636D63u, 0x18u, inSpecifier, &outPropertyDataSize))
    {
      int v8 = *((_DWORD *)this + 35) + 48;
      goto LABEL_31;
    }
    UInt32 v9 = outPropertyDataSize;
LABEL_17:
    int v8 = v9 + 36;
    goto LABEL_31;
  }
  uint64_t v5 = *((void *)this + 22);
  uint64_t v4 = *((void *)this + 23);
  BOOL v6 = *((_DWORD *)this + 13) == 2 && v4 == v5;
  int v7 = v4 - v5 + 50;
  if (v6) {
    int v7 = 66;
  }
  if (a2) {
    int v8 = v7 + 16;
  }
  else {
    int v8 = v7;
  }
LABEL_31:
  int v12 = *((_DWORD *)this + 131);
  if (v12)
  {
    if (v12 < 0) {
      int v12 = -v12;
    }
    v8 += snprintf((char *)inSpecifier, 8uLL, "%d", v12) + 13;
  }
  *((_DWORD *)this + 148) = 0;
  CFDictionaryRef v13 = (const __CFDictionary *)*((void *)this + 73);
  if (v13)
  {
    CFIndex Count = CFDictionaryGetCount(v13);
    uint64_t v15 = Count;
    unint64_t v16 = 8 * Count;
    MEMORY[0x1F4188790](Count);
    uint64_t v17 = (v16 + 15) & 0xFFFFFFFF0;
    if (v16 >= 0x200) {
      size_t v18 = 512;
    }
    else {
      size_t v18 = v16;
    }
    bzero(&v28[-v17], v18);
    MEMORY[0x1F4188790](v19);
    unsigned int v20 = &v28[-v17];
    bzero(&v28[-v17], v18);
    CFDictionaryGetKeysAndValues(*((CFDictionaryRef *)this + 73), (const void **)&v28[-v17], (const void **)&v28[-v17]);
    if (v15)
    {
      for (uint64_t i = 0; i != v15; ++i)
      {
        CFTypeID v22 = CFGetTypeID(*(CFTypeRef *)&v20[8 * i]);
        if (v22 == CFArrayGetTypeID())
        {
          uint64_t v23 = CFArrayGetCount(*(CFArrayRef *)&v20[8 * i]);
          if (v23)
          {
            for (CFIndex j = 0; j != v23; ++j)
            {
              CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(*(CFArrayRef *)&v20[8 * i], j);
              *((_DWORD *)this + 148) += CFDataGetLength(ValueAtIndex) + 8;
            }
          }
        }
        else if (v22 == CFDataGetTypeID())
        {
          *((_DWORD *)this + 148) += CFDataGetLength(*(CFDataRef *)&v20[8 * i]) + 8;
        }
      }
    }
    int v26 = *((_DWORD *)this + 148);
  }
  else
  {
    int v26 = 0;
  }
  return (v26 + v8);
}

uint64_t MP4AudioFile::GetSampleDescription(MP4AudioFile *this, char *a2, unsigned int a3, int a4)
{
  uint64_t v111 = *MEMORY[0x1E4F143B8];
  long long v7 = *(_OWORD *)((char *)this + 40);
  long long v97 = *(_OWORD *)((char *)this + 24);
  long long v98 = v7;
  uint64_t v99 = *((void *)this + 7);
  unsigned int v8 = DWORD2(v97);
  if (DWORD2(v97) == 1634492771)
  {
    if (MP4AudioFile::GetSampleDescriptionSize(this, a4) != a3) {
      return 0xFFFFFFFFLL;
    }
    unsigned int v100 = bswap32(MP4AudioFile::GetSampleDescriptionSize(this, a4));
    long long v101 = xmmword_1901C65D0;
    uint64_t v102 = 0x1000020000000000;
    uint64_t v103 = 0x44AC00000000;
    uint64_t v104 = 0x63616C6124000000;
    int v105 = 0;
    uint64_t v10 = (long long *)*((void *)this + 18);
    unsigned int v11 = *((_DWORD *)this + 35);
    if (*((_DWORD *)v10 + 1) == 1634562662)
    {
      if (v11 >= 0x30)
      {
        long long v106 = *(long long *)((char *)v10 + 24);
        uint64_t v107 = *((void *)v10 + 5);
        if (v11 == 80)
        {
          uint64_t v12 = 48;
LABEL_25:
          int v26 = (long long *)((char *)v10 + v12);
          long long v108 = *v26;
          uint64_t v109 = *((void *)v26 + 2);
          goto LABEL_26;
        }
        goto LABEL_26;
      }
    }
    else if (v11 >= 0x18)
    {
      long long v106 = *v10;
      uint64_t v107 = *((void *)v10 + 2);
      if (v11 == 48)
      {
        uint64_t v12 = 24;
        goto LABEL_25;
      }
LABEL_26:
      size_t v16 = a3;
      uint64_t v15 = &v100;
      uint64_t v14 = a2;
      goto LABEL_27;
    }
    return 2003334207;
  }
  if ((DWORD2(v97) & 0xFBFFFFFF) == 0x61632D33)
  {
    __int16 v13 = __rev16((int)*(double *)&v97);
    *(_DWORD *)a2 = bswap32(*((_DWORD *)this + 35) + 36);
    *((_DWORD *)a2 + 1) = bswap32(v8);
    *((void *)a2 + 1) = 0x100000000000000;
    *((void *)a2 + 2) = 0;
    *((void *)a2 + 3) = 268435968;
    *((_WORD *)a2 + 16) = v13;
LABEL_9:
    *((_WORD *)a2 + 17) = 0;
    uint64_t v14 = a2 + 36;
    uint64_t v15 = (unsigned int *)*((void *)this + 18);
    size_t v16 = *((unsigned int *)this + 35);
LABEL_27:
    memcpy(v14, v15, v16);
    return 0;
  }
  switch(DWORD2(v97))
  {
    case 0x73617762:
      uint64_t result = 0;
      *(void *)a2 = 0x6277617335000000;
      *((void *)a2 + 3) = 268435968;
      int v23 = 32830;
LABEL_22:
      *((_DWORD *)a2 + 8) = v23;
      *((void *)a2 + 1) = 0x100000000000000;
      *((void *)a2 + 2) = 0;
      uint64_t v24 = *((void *)this + 18);
      long long v25 = *(_OWORD *)(v24 + 22);
      a2[52] = *(unsigned char *)(v24 + 38);
      *(_OWORD *)(a2 + 36) = v25;
      return result;
    case 0x73616D72:
      uint64_t result = 0;
      *(void *)a2 = 0x726D617335000000;
      *((void *)a2 + 3) = 268435968;
      int v23 = 16415;
      goto LABEL_22;
    case 0x666C6163:
      unsigned int v18 = bswap32(*((_DWORD *)this + 35) + 36);
      unsigned int v19 = bswap32(WORD6(v98)) >> 16;
      unsigned int v20 = bswap32((unsigned __int16)v99) >> 16;
      if (*(double *)&v97 <= 65535.0)
      {
        unsigned int v22 = (int)*(double *)&v97;
      }
      else
      {
        HIDWORD(v21) = -1214044089 * *(double *)&v97;
        LODWORD(v21) = HIDWORD(v21);
        if ((v21 >> 7) >= 0x15D87) {
          unsigned int v22 = -1;
        }
        else {
          unsigned int v22 = -17536;
        }
      }
      *(_DWORD *)a2 = v18;
      *(void *)(a2 + 4) = 1130450022;
      *((_DWORD *)a2 + 3) = 0x1000000;
      *((void *)a2 + 2) = 0;
      *((_WORD *)a2 + 12) = v19;
      *((_WORD *)a2 + 13) = v20;
      *((_DWORD *)a2 + 7) = 0;
      *((_WORD *)a2 + 16) = bswap32(v22) >> 16;
      goto LABEL_9;
  }
  int v27 = *((_DWORD *)this + 148);
  UInt32 v96 = 0;
  int v28 = *((_DWORD *)this + 21);
  v93[0] = DWORD2(v97);
  v93[1] = v28;
  uint64_t v94 = *((void *)this + 18);
  uint64_t v95 = 0;
  LODWORD(v95) = *((_DWORD *)this + 35);
  uint64_t v91 = *((void *)&v97 + 1);
  int v92 = v28;
  unsigned int v90 = 0;
  uint64_t v89 = 0;
  UInt32 v88 = 12;
  BOOL v84 = this;
  int v29 = *((_DWORD *)this + 131);
  if (v29 && (CFStringRef CFStringFromBitDepth = CreateCFStringFromBitDepth(v29)) != 0)
  {
    CFStringRef v31 = CFStringFromBitDepth;
    int v32 = *((_DWORD *)v84 + 131);
    if (v32)
    {
      if (v32 < 0) {
        int v32 = -v32;
      }
      int v32 = snprintf((char *)&v100, 8uLL, "%d", v32) + 1;
    }
    CFStringRef v82 = v31;
    if (CFStringGetCString(v31, buffer, (v32 + 1), 0x8000100u) == 1)
    {
      int v33 = *((_DWORD *)v84 + 131);
      if (v33)
      {
        if (v33 < 0) {
          int v33 = -v33;
        }
        int v33 = snprintf((char *)&v100, 8uLL, "%d", v33) + 1;
      }
      unsigned int v83 = v33 + 12;
    }
    else
    {
      unsigned int v83 = 0;
    }
  }
  else
  {
    unsigned int v83 = 0;
    CFStringRef v82 = 0;
  }
  int v34 = v27 + 36;
  if (AudioFormatGetPropertyInfo(0x65636D63u, 0x18u, v93, &v96))
  {
    if (v8 == 1819304813)
    {
      uint64_t v36 = *((void *)v84 + 22);
      uint64_t v35 = *((void *)v84 + 23);
      BOOL v37 = HIDWORD(v98) == 2 && v35 == v36;
      int v38 = v35 - v36 + 14;
      if (v37) {
        int v38 = 30;
      }
      unsigned int v39 = v38 + v34;
      if (a4) {
        unsigned int v40 = v39 + 16;
      }
      else {
        unsigned int v40 = v39;
      }
    }
    else
    {
      unsigned int v40 = v27 + v83 + *((_DWORD *)v84 + 35) + 48;
    }
  }
  else
  {
    unsigned int v40 = v96 + v34;
  }
  OSStatus Property = AudioFormatGetProperty(0x636E6964u, 0xCu, &v91, &v88, &v89);
  __int16 v42 = 0;
  unsigned int v43 = 1630826605;
  if (Property || v88 != 12) {
    goto LABEL_67;
  }
  unsigned int v43 = bswap32(v90);
  if (v8 != 1819304813)
  {
    __int16 v42 = 0;
LABEL_67:
    __int16 v44 = 512;
    goto LABEL_68;
  }
  if (a4) {
    __int16 v42 = 256;
  }
  else {
    __int16 v42 = 0;
  }
  if (!WORD6(v98)) {
    goto LABEL_67;
  }
  __int16 v44 = __rev16(WORD6(v98));
LABEL_68:
  unsigned int v45 = bswap32(v40);
  unsigned int v46 = *(double *)&v97;
  do
  {
    unsigned int v47 = v46;
    v46 >>= 1;
  }
  while (HIWORD(v47));
  *(_DWORD *)a2 = v45;
  *((_DWORD *)a2 + 1) = v43;
  *((void *)a2 + 1) = 0x100000000000000;
  *((_WORD *)a2 + 8) = v42;
  *(_DWORD *)(a2 + 18) = 0;
  *((_WORD *)a2 + 11) = 0;
  *((_WORD *)a2 + 12) = v44;
  *((_WORD *)a2 + 13) = 4096;
  *((_DWORD *)a2 + 7) = 0;
  *((_WORD *)a2 + 16) = bswap32(v47) >> 16;
  int v48 = a2 + 36;
  *((_WORD *)a2 + 17) = 0;
  if (!AudioFormatGetProperty(0x65636D63u, 0x18u, v93, &v96, a2 + 36))
  {
    unsigned int v50 = &v48[v96];
    uint64_t v52 = v84;
    goto LABEL_80;
  }
  if (v8 != 1819304813)
  {
    uint64_t v52 = v84;
    *((_DWORD *)a2 + 9) = bswap32(*((_DWORD *)v84 + 35) + 12);
    *((void *)a2 + 5) = 1935962981;
    unsigned int v50 = a2 + 48;
    memcpy(v50, *((const void **)v52 + 18), *((unsigned int *)v52 + 35));
    uint64_t v55 = *((unsigned int *)v52 + 35);
    goto LABEL_79;
  }
  UInt32 v87 = 14;
  uint64_t result = AudioFormatGetProperty(0x73647063u, 0x28u, &v97, &v87, &v100);
  if (!result)
  {
    uint64_t v49 = v87;
    memcpy(v48, &v100, v87);
    unsigned int v50 = &v48[v49];
    if (a4)
    {
      unsigned int v51 = bswap32(*(double *)&v97);
      *(void *)unsigned int v50 = 0x7461727310000000;
      *((_DWORD *)v50 + 2) = 0;
      *((_DWORD *)v50 + 3) = v51;
      v50 += 16;
    }
    uint64_t v52 = v84;
    BOOL v53 = (unsigned char *)*((void *)v84 + 22);
    uint64_t v54 = (unsigned char *)*((void *)v84 + 23);
    if (v54 != v53)
    {
      memcpy(v50, v53, v54 - v53);
      uint64_t v55 = *((void *)v84 + 23) - *((void *)v84 + 22);
LABEL_79:
      v50 += v55;
      goto LABEL_80;
    }
    if (*((void *)v84 + 20) == *((void *)v84 + 19) && HIDWORD(v98) == 2)
    {
      *(_OWORD *)unsigned int v50 = sStereoISOLayout;
      v50 += 16;
    }
    else if (HIDWORD(v98) > 1)
    {
      return 2003334207;
    }
LABEL_80:
    CFDictionaryRef v56 = (const __CFDictionary *)*((void *)v52 + 73);
    if (v56)
    {
      CFIndex Count = CFDictionaryGetCount(v56);
      uint64_t v81 = (uint64_t)&v81;
      uint64_t v58 = Count;
      unint64_t v59 = v52;
      unint64_t v60 = 8 * Count;
      MEMORY[0x1F4188790](Count);
      uint64_t v61 = (v60 + 15) & 0xFFFFFFFF0;
      if (v60 >= 0x200) {
        size_t v62 = 512;
      }
      else {
        size_t v62 = v60;
      }
      bzero((char *)&v81 - v61, v62);
      MEMORY[0x1F4188790](v63);
      uint64_t v64 = (char *)&v81 - v61;
      bzero((char *)&v81 - v61, v62);
      CFDictionaryRef v65 = (const __CFDictionary *)*((void *)v59 + 73);
      uint64_t v85 = (char *)&v81 - v61;
      CFDictionaryGetKeysAndValues(v65, (const void **)((char *)&v81 - v61), (const void **)((char *)&v81 - v61));
      uint64_t v86 = v58;
      if (v58)
      {
        uint64_t v66 = 0;
        do
        {
          CFStringGetCString(*(CFStringRef *)&v85[8 * v66], (char *)&v100, 256, 0x8000100u);
          unsigned int v67 = v100;
          CFTypeID v68 = CFGetTypeID(*(CFTypeRef *)&v64[8 * v66]);
          if (v68 == CFArrayGetTypeID())
          {
            uint64_t v69 = CFArrayGetCount(*(CFArrayRef *)&v64[8 * v66]);
            if (v69)
            {
              for (CFIndex i = 0; i != v69; ++i)
              {
                CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(*(CFArrayRef *)&v64[8 * v66], i);
                unsigned int Length = CFDataGetLength(ValueAtIndex);
                *(_DWORD *)unsigned int v50 = bswap32(Length + 8);
                *((_DWORD *)v50 + 1) = v67;
                int v73 = v50 + 8;
                BytePtr = CFDataGetBytePtr(ValueAtIndex);
                memcpy(v73, BytePtr, Length);
                unsigned int v50 = &v73[Length];
              }
            }
          }
          else if (v68 == CFDataGetTypeID())
          {
            unsigned int v75 = CFDataGetLength(*(CFDataRef *)&v64[8 * v66]);
            *(_DWORD *)unsigned int v50 = bswap32(v75 + 8);
            *((_DWORD *)v50 + 1) = v67;
            int v76 = v50 + 8;
            __n128 v77 = CFDataGetBytePtr(*(CFDataRef *)&v64[8 * v66]);
            memcpy(v76, v77, v75);
            unsigned int v50 = &v76[v75];
          }
          ++v66;
        }
        while (v66 != v86);
      }
      uint64_t v52 = v84;
    }
    if (*((_DWORD *)v52 + 131) && v83)
    {
      *(_DWORD *)unsigned int v50 = bswap32(v83);
      *(void *)(v50 + 4) = 1685348979;
      unsigned int v78 = v50 + 12;
      int v79 = *((_DWORD *)v52 + 131);
      if (v79)
      {
        if (v79 < 0) {
          int v79 = -v79;
        }
        size_t v80 = (snprintf((char *)&v100, 8uLL, "%d", v79) + 1);
      }
      else
      {
        size_t v80 = 0;
      }
      memcpy(v78, buffer, v80);
    }
    if (v82) {
      CFRelease(v82);
    }
    return 0;
  }
  return result;
}

void *std::vector<SyncSampleEntry>::__init_with_size[abi:ne180100]<SyncSampleEntry*,SyncSampleEntry*>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    BOOL v6 = result;
    uint64_t result = std::vector<double>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1901A6CD8(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *CreateSampleToPrerollGroup(char *result, uint64_t a2, void *a3, void *a4)
{
  if (*(unsigned char *)a2)
  {
    unint64_t v7 = (unint64_t)result;
    unint64_t v8 = *(void *)(a2 + 16) - *(void *)(a2 + 8);
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 40) - *(void *)(a2 + 32)) >> 3);
    uint64_t v10 = (char *)malloc_type_calloc(1uLL, (v8 & 0x1FFFFFFFELL) + 24, 0x1BB7D15BuLL);
    uint64_t result = (char *)malloc_type_calloc(1uLL, 16 * (v9 & 0x7FFFFFFF) + 28, 0xBFAB9308uLL);
    *(_DWORD *)uint64_t v10 = bswap32((v8 & 0xFFFFFFFE) + 24);
    *((_DWORD *)v10 + 1) = 1685088115;
    *((_DWORD *)v10 + 2) = 1;
    *(void *)(v10 + 12) = 0x20000006C6F7270;
    *((_DWORD *)v10 + 5) = bswap32(v8 >> 1);
    if ((v8 >> 1))
    {
      unsigned int v11 = *(unsigned __int16 **)(a2 + 8);
      uint64_t v12 = v10 + 24;
      uint64_t v13 = (v8 >> 1);
      do
      {
        unsigned int v14 = *v11++;
        *v12++ = bswap32(v14) >> 16;
        --v13;
      }
      while (v13);
    }
    *(void *)(result + 4) = 1885823603;
    *((_DWORD *)result + 3) = 1819243120;
    if (v9)
    {
      uint64_t v15 = 0;
      unsigned int v16 = 0;
      unsigned int v17 = 0;
      uint64_t v18 = *(void *)(a2 + 32);
      uint64_t v19 = *(void *)(a2 + 8);
      do
      {
        uint64_t v20 = *(void *)(v18 + 24 * v15);
        if (v20 > v17) {
          *(void *)&result[8 * v16++ + 20] = bswap32(v20 - v17);
        }
        uint64_t v21 = *(void *)(v18 + 24 * v15 + 8);
        *(_DWORD *)&result[8 * v16 + 20] = bswap32(v21);
        if ((v8 >> 1))
        {
          uint64_t v22 = 0;
          while (*(unsigned __int16 *)(v19 + 2 * v22) != *(__int16 *)(v18 + 24 * v15 + 16))
          {
            if ((v8 >> 1) == ++v22) {
              goto LABEL_13;
            }
          }
          unsigned int v23 = v22 + 1;
        }
        else
        {
LABEL_13:
          unsigned int v23 = 0;
        }
        *(_DWORD *)&result[8 * v16++ + 24] = bswap32(v23);
        unsigned int v17 = v21 + v20;
        ++v15;
      }
      while (v15 != v9);
    }
    else
    {
      unsigned int v17 = 0;
      unsigned int v16 = 0;
    }
    if (v17 < v7) {
      *(void *)&result[8 * v16++ + 20] = bswap32(v7 - v17);
    }
    *((_DWORD *)result + 4) = bswap32(v16);
    *(_DWORD *)uint64_t result = bswap32(8 * v16 + 20);
    *a3 = v10;
    *a4 = result;
  }
  return result;
}

double CreateSampleToRollGroup(unsigned int a1, void *a2, void *a3)
{
  BOOL v6 = (char *)malloc_type_calloc(1uLL, 0x1AuLL, 0x10000408DD1DBA6uLL);
  unint64_t v7 = malloc_type_calloc(1uLL, 0x1CuLL, 0x100004027586B93uLL);
  *(void *)BOOL v6 = 0x647067731A000000;
  *((_DWORD *)v6 + 2) = 1;
  *(void *)(v6 + 12) = 0x20000006C6C6F72;
  *((_DWORD *)v6 + 5) = 0x1000000;
  *((_WORD *)v6 + 12) = -1;
  double result = 2.90439731e233;
  *(_OWORD *)unint64_t v7 = xmmword_1901C65E0;
  v7[4] = 0x1000000;
  v7[5] = bswap32(a1);
  v7[6] = 0x1000000;
  *a2 = v6;
  *a3 = v7;
  return result;
}

uint64_t MP4AudioFile::NewMP4BoxToFile(MP4AudioFile *this, unsigned int a2, uint64_t a3)
{
  int v5 = 0;
  v4[0] = bswap32(a2);
  v4[1] = 1701147238;
  return (*(uint64_t (**)(MP4AudioFile *, void, uint64_t, uint64_t, _DWORD *, int *))(*(void *)this + 56))(this, 0, a3, 8, v4, &v5);
}

CACFData *std::unique_ptr<CACFData>::reset[abi:ne180100](CACFData **a1)
{
  double result = *a1;
  *a1 = 0;
  if (result)
  {
    CACFData::~CACFData(result);
    JUMPOUT(0x192FC8940);
  }
  return result;
}

uint64_t MP4AudioFile::InitializeDataSource(MP4AudioFile *this, const AudioStreamBasicDescription *a2)
{
  if (!(*(unsigned int (**)(MP4AudioFile *))(*(void *)this + 616))(this)) {
    return 1685348671;
  }
  uint64_t result = MP4AudioFile::WriteFileTypeBoxToFile(this);
  if (!result)
  {
    uint64_t result = (*(uint64_t (**)(MP4AudioFile *, const AudioStreamBasicDescription *))(*(void *)this + 176))(this, a2);
    if (!result) {
      MP4AudioFile::InitNewFile(this);
    }
  }
  return result;
}

uint64_t MP4AudioFile::WriteFileTypeBoxToFile(MP4AudioFile *this)
{
  int v1 = 0;
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  int v2 = *((_DWORD *)this + 21);
  if (v2 <= 1832149349)
  {
    if (v2 == 862416946)
    {
      int v3 = 1630693171;
      int v4 = 896558899;
      int v5 = 879781683;
      int v16 = 1630693171;
      goto LABEL_13;
    }
    if (v2 != 862417008) {
      goto LABEL_15;
    }
    int v5 = 896558899;
    int v1 = 24;
    int v4 = 879781683;
    uint64_t v6 = 5;
    uint64_t v7 = 4;
    uint64_t v8 = 2;
    int v3 = 896558899;
LABEL_14:
    v15[v8] = v5;
    v15[v7] = v4;
    v15[v6] = v3;
    goto LABEL_15;
  }
  int v3 = 1836020585;
  int v4 = 842297453;
  switch(v2)
  {
    case 1836069990:
      int v1 = 24;
      uint64_t v6 = 5;
      uint64_t v7 = 4;
      uint64_t v8 = 2;
      int v5 = 842297453;
      goto LABEL_14;
    case 1832149606:
      int v5 = 541209677;
      goto LABEL_11;
    case 1832149350:
      int v5 = 541144141;
LABEL_11:
      int v16 = v5;
LABEL_13:
      int v1 = 28;
      uint64_t v6 = 6;
      uint64_t v7 = 5;
      uint64_t v8 = 4;
      goto LABEL_14;
  }
LABEL_15:
  v15[0] = v1 << 24;
  v15[1] = 1887007846;
  int v17 = 0;
  uint64_t v9 = (*(uint64_t (**)(void, void, void))(**((void **)this + 13) + 56))(*((void *)this + 13), 0, 0);
  if (v9 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)AudioComponentVector buf = 136315394;
    uint64_t v12 = "MP4AudioFile.cpp";
    __int16 v13 = 1024;
    int v14 = 3637;
    _os_log_impl(&dword_18FEC0000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%25s:%-5d  Couldn't create a new audio file object", buf, 0x12u);
  }
  return v9;
}

void MP4AudioFile::InitNewFile(MP4AudioFile *this)
{
}

uint64_t MP4AudioFile::OpenFromDataSource(MP4AudioFile *this)
{
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  if ((*((unsigned char *)this + 100) & 2) != 0) {
    return 1886547263;
  }
  uint64_t v48 = 0;
  unsigned int v47 = 0;
  int v2 = (void *)((char *)this + 104);
  (*(void (**)(void, uint64_t *))(**((void **)this + 13) + 24))(*((void *)this + 13), &v48);
  int v44 = 0;
  uint64_t v3 = (*(uint64_t (**)(void, void, void, uint64_t, char *, int *))(*(void *)*v2 + 48))(*v2, 0, 0, 8, v45, &v44);
  if (!v3)
  {
    uint64_t v3 = 1685348671;
    if (v46 == 1887007846)
    {
      if (IsValidDataForMP4FileType(*((DataSource **)this + 13), *((_DWORD *)this + 21)))
      {
        int v4 = FillMP4BoxTable(*((void *)this + 13), 0, v48, *((__n128 ***)this + 28), 0, 0);
        uint64_t v5 = v48;
        if (!v4
          || FindBoxInfo(*((void *)this + 13), 0, v48, 1718909296, 0, *((__n128 ***)this + 28))
          && FindBoxInfo(*((void *)this + 13), 0, v48, 1836019574, 0, *((__n128 ***)this + 28))
          && (uint64_t v6 = FindBoxInfo(*((void *)this + 13), 0, v48, 1835295092, 0, *((__n128 ***)this + 28))) != 0
          && (uint64_t v5 = v48, (int64_t)(v6[1].n128_u64[0] + v6->n128_u64[1]) <= v48))
        {
          BoxInfo = FindBoxInfo(*((void *)this + 13), 0, v5, 1836019574, 0, *((__n128 ***)this + 28));
          if (BoxInfo)
          {
            uint64_t v8 = *((void *)this + 13);
            unint64_t v9 = BoxInfo[1].n128_u64[0];
            unsigned int v50 = (void (**)(MP4BoxParser_Movie *__hidden))&unk_1EDF8DA18;
            (*(void (**)(uint64_t *__return_ptr, uint64_t, unint64_t))(*(void *)v8 + 88))(&v51, v8, v9);
            char v52 = 0;
            int v53 = 0;
            uint64_t v54 = 0;
            char v55 = 0;
            int v56 = 8;
            unsigned int v50 = off_1EDF92718;
            char v57 = 1;
            uint64_t v58 = 0;
            uint64_t v10 = MP4BoxParser_Movie::Init((MP4BoxParser_Movie *)&v50);
            if (!v10)
            {
              unsigned int v11 = v58;
              if (v58)
              {
                unsigned int v12 = 0;
                unsigned int v13 = 0;
LABEL_14:
                int v14 = v11[1];
                if (v14 == (__n128 *)v11) {
                  goto LABEL_20;
                }
                unsigned int v15 = 0;
                do
                {
                  if (v14[1].n128_u32[0] == 1953653099) {
                    ++v15;
                  }
                  int v14 = (__n128 *)v14->n128_u64[1];
                }
                while (v14 != (__n128 *)v11);
LABEL_21:
                if (v12 < v15)
                {
                  int v16 = v11[1];
                  if (v16 == (__n128 *)v11) {
                    goto LABEL_33;
                  }
                  int v17 = 0;
                  while (1)
                  {
                    if (v16[1].n128_u32[0] == 1953653099)
                    {
                      if (v17 == v12)
                      {
                        MP4BoxParser_Track::MP4BoxParser_Track((uint64_t)&v59, v51, v16[2].n128_i64[0], v16[2].n128_i64[1], v12);
                        if (!MP4BoxParser_Track::Init((MP4BoxParser_Track *)&v59)
                          && MP4BoxParser_Track::GetTrackType((MP4BoxParser_Track *)&v59) == 1936684398)
                        {
                          ++v13;
                        }
                        MP4BoxParser_Track::~MP4BoxParser_Track((MP4BoxParser_Track *)&v59);
                        unsigned int v11 = v58;
LABEL_33:
                        ++v12;
                        if (!v11)
                        {
LABEL_20:
                          unsigned int v15 = 0;
                          goto LABEL_21;
                        }
                        goto LABEL_14;
                      }
                      ++v17;
                    }
                    int v16 = (__n128 *)v16->n128_u64[1];
                    if (v16 == (__n128 *)v11) {
                      goto LABEL_33;
                    }
                  }
                }
                *((_DWORD *)this + 125) = v13;
                if (v13)
                {
                  if (!v11 || (uint64_t v19 = v11[1], v19 == (__n128 *)v11))
                  {
                    unsigned int v20 = 0;
                  }
                  else
                  {
                    unsigned int v20 = 0;
                    do
                    {
                      if (v19[1].n128_u32[0] == 1953653099) {
                        ++v20;
                      }
                      uint64_t v19 = (__n128 *)v19->n128_u64[1];
                    }
                    while (v19 != (__n128 *)v11);
                  }
                  *((_DWORD *)this + 124) = v20;
                  if (v20 >= v13)
                  {
                    unsigned int v43 = 0;
                    AudioTrackData = MP4BoxParser_Movie::GetAudioTrackData((MP4BoxParser_Movie *)&v50, 0, &v47, &v43);
                    *((void *)this + 29) = AudioTrackData;
                    if (AudioTrackData)
                    {
                      uint64_t v22 = v58;
                      uint64_t v23 = v51;
                      unsigned int v24 = ((uint64_t (*)(void))v50[3])(&v50);
                      long long v25 = FindBoxInfo(v23, v24, v54, 1836476516, 0, v22);
                      if (v25)
                      {
                        unint64_t v26 = v25[1].n128_u64[0];
                        unint64_t v59 = (void (**)(MP4BoxParser_Movie *__hidden))&unk_1EDF8DA18;
                        (*(void (**)(DataSource **__return_ptr, uint64_t, unint64_t))(*(void *)v51 + 88))(&v60, v51, v26);
                        char v61 = 0;
                        int v62 = 0;
                        uint64_t v63 = 0;
                        char v64 = 0;
                        int v65 = 8;
                        unint64_t v59 = (void (**)(MP4BoxParser_Movie *__hidden))&unk_1EDF93B90;
                        uint64_t v70 = 0;
                        unsigned int v67 = 0;
                        uint64_t v68 = 0;
                        int v69 = 0;
                        if (!MP4BoxParser_MovieHeader::Init((MP4BoxParser **)&v59)) {
                          *((_DWORD *)this + 114) = v69;
                        }
                        int v27 = v60;
                        unint64_t v59 = (void (**)(MP4BoxParser_Movie *__hidden))&unk_1EDF8DA18;
                        unint64_t v60 = 0;
                        if (v27) {
                          (*(void (**)(DataSource *))(*(void *)v27 + 8))(v27);
                        }
                      }
                      int v28 = v58;
                      uint64_t v29 = v51;
                      unsigned int v30 = ((uint64_t (*)(void))v50[3])(&v50);
                      CFStringRef v31 = FindBoxInfo(v29, v30, v54, 1836475768, 0, v28);
                      if (v31)
                      {
                        unint64_t v32 = v31[1].n128_u64[0];
                        unint64_t v59 = (void (**)(MP4BoxParser_Movie *__hidden))&unk_1EDF8DA18;
                        (*(void (**)(DataSource **__return_ptr, uint64_t, unint64_t))(*(void *)v51 + 88))(&v60, v51, v32);
                        char v61 = 0;
                        int v62 = 0;
                        uint64_t v63 = 0;
                        char v64 = 0;
                        int v65 = 8;
                        unint64_t v59 = off_1EDF93EA0;
                        char v66 = 1;
                        unsigned int v67 = 0;
                        if (!MP4BoxParser_MovieExtends::Init((MP4BoxParser_MovieExtends *)&v59))
                        {
                          *((unsigned char *)this + 408) = 1;
                          uint64_t v49 = 0;
                          if (MP4BoxParser_MovieExtends::GetOverallDurationIncludingFragments(v60, v67, &v49))
                          {
                            unsigned int v33 = *((_DWORD *)this + 114);
                            if (v33)
                            {
                              *((unsigned char *)this + 409) = 1;
                              *((double *)this + 52) = (double)(unint64_t)v49 / (double)v33;
                            }
                          }
                          MP4BoxParser_MovieExtends::GetTrackFragmentDefaultsMap((uint64_t)&v59, (uint64_t)this + 424);
                        }
                        MP4BoxParser_MovieExtends::~MP4BoxParser_MovieExtends((MP4BoxParser_MovieExtends *)&v59);
                      }
                      uint64_t v49 = 0;
                      if (!(*(unsigned int (**)(void, uint64_t *))(**((void **)this + 13) + 24))(*((void *)this + 13), &v49))
                      {
                        int v34 = FindBoxInfo(*((void *)this + 13), 0, v49, 1836019574, 0, *((__n128 ***)this + 28));
                        if (v34)
                        {
                          uint64_t v35 = *((void *)this + 13);
                          unint64_t v36 = v34[1].n128_u64[0];
                          unint64_t v59 = (void (**)(MP4BoxParser_Movie *__hidden))&unk_1EDF8DA18;
                          (*(void (**)(DataSource **__return_ptr, uint64_t, unint64_t))(*(void *)v35 + 88))(&v60, v35, v36);
                          char v61 = 0;
                          int v62 = 0;
                          uint64_t v63 = 0;
                          char v64 = 0;
                          int v65 = 8;
                          unint64_t v59 = off_1EDF92718;
                          char v66 = 1;
                          unsigned int v67 = 0;
                          if (!MP4BoxParser_Movie::Init((MP4BoxParser_Movie *)&v59))
                          {
                            for (unsigned int i = 0; ; ++i)
                            {
                              int v38 = (__n128 **)v67;
                              if (!v67 || (unint64_t v39 = v67[1], (unint64_t *)v39 == v67))
                              {
                                unsigned int v40 = 0;
                              }
                              else
                              {
                                unsigned int v40 = 0;
                                do
                                {
                                  if (*(_DWORD *)(v39 + 16) == 1969517665) {
                                    ++v40;
                                  }
                                  unint64_t v39 = *(void *)(v39 + 8);
                                }
                                while ((unint64_t *)v39 != v67);
                              }
                              if (i >= v40) {
                                break;
                              }
                              uint64_t v41 = v60;
                              unsigned int v42 = ((uint64_t (*)(void))v59[3])(&v59);
                              if (FindBoxInfo((uint64_t)v41, v42, v63, 1969517665, i, v38)) {
                                operator new();
                              }
                            }
                          }
                          MP4BoxParser_Movie::~MP4BoxParser_Movie((MP4BoxParser_Movie *)&v59);
                        }
                      }
                      *((void *)this + 75) = 0;
                      MP4AudioFile::FillPacketTableInfoFromiTunesUserData(this);
                      MP4AudioFile::UseAudioTrack(this, *((void **)this + 29));
                    }
                    uint64_t v10 = 1685348671;
                    goto LABEL_49;
                  }
                }
              }
              else
              {
                *((_DWORD *)this + 125) = 0;
              }
              uint64_t v10 = 1685348671;
            }
LABEL_49:
            MP4BoxParser_Movie::~MP4BoxParser_Movie((MP4BoxParser_Movie *)&v50);
            return v10;
          }
        }
      }
    }
  }
  return v3;
}

void sub_1901A7EA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  MP4BoxParser_Movie::~MP4BoxParser_Movie((MP4BoxParser_Movie *)va1);
  MP4BoxParser_Movie::~MP4BoxParser_Movie((MP4BoxParser_Movie *)va);
  _Unwind_Resume(a1);
}

uint64_t IsValidDataForMP4FileType(DataSource *a1, int a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  MP4BoxParser_FileType::MP4BoxParser_FileType((uint64_t)v22, (uint64_t)a1);
  if (MP4BoxParser_FileType::Init((MP4BoxParser_FileType *)v22)) {
    goto LABEL_2;
  }
  if (v23 == 1295270176)
  {
    char v5 = 1;
  }
  else
  {
    char v5 = v23 == 1295275552;
    if (v23 == 1903435808) {
      goto LABEL_2;
    }
  }
  char v6 = v23 == 1295270432;
  if (v24)
  {
    char v7 = 0;
    char v8 = 0;
    uint64_t v9 = v24;
    uint64_t v10 = v25;
    do
    {
      if (v25)
      {
        int v11 = *v10;
        BOOL v13 = *v10 == 862416950 || (*v10 & 0xFFFFFFFE) == 862416948;
        v8 |= v13;
        v7 |= v11 == 862401121;
        BOOL v15 = v11 == 1295270176 || v11 == 1295275552;
        v5 |= v15;
      }
      else
      {
        int v11 = 0;
      }
      v6 |= v11 == 1295270432;
      ++v10;
      --v9;
    }
    while (v9);
  }
  else
  {
    char v8 = 0;
    char v7 = 0;
  }
  if (a2 > 1832149349)
  {
    switch(a2)
    {
      case 1832149350:
        char v20 = (v23 == 1295270176) | v5;
        char v21 = (v8 | v7) ^ 1;
        break;
      case 1832149606:
        char v20 = (v23 == 1295270432) | v6;
        char v21 = (v8 | v7) ^ 1;
        break;
      case 1836069990:
        char v16 = v8 | v7 | v5 | v6;
        if (v24) {
          BOOL v17 = 1;
        }
        else {
          BOOL v17 = v23 == 1836069938;
        }
        char v18 = v17;
        if (v16) {
          char v3 = 0;
        }
        else {
          char v3 = v18;
        }
        goto LABEL_3;
      default:
LABEL_2:
        char v3 = 0;
        goto LABEL_3;
    }
    char v3 = v21 & v20;
    goto LABEL_3;
  }
  char v19 = v8 & (v7 ^ 1);
  if (a2 != 862417008) {
    char v19 = 0;
  }
  if (a2 == 862416946) {
    char v3 = v7;
  }
  else {
    char v3 = v19;
  }
LABEL_3:
  MP4BoxParser_FileType::~MP4BoxParser_FileType((MP4BoxParser_FileType *)v22);
  return v3 & 1;
}

void sub_1901A819C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  MP4BoxParser_FileType::~MP4BoxParser_FileType((MP4BoxParser_FileType *)va);
  _Unwind_Resume(a1);
}

uint64_t MP4AudioFile::Create(MP4AudioFile *this, const __CFURL *a2, const AudioStreamBasicDescription *a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (!(*(unsigned int (**)(MP4AudioFile *, const AudioStreamBasicDescription *))(*(void *)this + 616))(this, a3))return 1685348671; {
  uint64_t result = AudioFileObject::Create(this, a2, a3);
  }
  if (!result)
  {
    uint64_t result = MP4AudioFile::WriteFileTypeBoxToFile(this);
    if (!result)
    {
      int v7 = (*(uint64_t (**)(MP4AudioFile *, const AudioStreamBasicDescription *))(*(void *)this + 176))(this, a3);
      if (!v7) {
        MP4AudioFile::InitNewFile(this);
      }
      int v8 = v7;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        int v10 = 136315394;
        int v11 = "MP4AudioFile.cpp";
        __int16 v12 = 1024;
        int v13 = 1049;
        _os_log_impl(&dword_18FEC0000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%25s:%-5d  bad data format", (uint8_t *)&v10, 0x12u);
      }
      exception = __cxa_allocate_exception(4uLL);
      _DWORD *exception = v8;
      __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
    }
  }
  return result;
}

void MP4AudioFile::~MP4AudioFile(MP4AudioFile *this)
{
  MP4AudioFile::~MP4AudioFile(this);
  JUMPOUT(0x192FC8940);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  void *v8;
  const void *v9;
  const void *v10;
  void *v11;
  const void *v12;
  const void *v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  uint64_t v23;
  uint64_t vars8;

  *(void *)this = &unk_1EDF8D730;
  int v2 = *((void *)this + 30);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  char v3 = *((void *)this + 28);
  if (v3)
  {
    std::__list_imp<MP4BoxInfo>::clear(*((uint64_t **)this + 28));
    MEMORY[0x192FC8940](v3, 0x1020C4062D53EE8);
  }
  int v4 = (void *)*((void *)this + 29);
  if (v4) {
    free(v4);
  }
  char v5 = *((void *)this + 31);
  if (v5) {
    MEMORY[0x192FC8940](v5, 0x1020C40AF72B1D3);
  }
  char v6 = *((void *)this + 50);
  if (v6)
  {
    int v7 = *(void **)v6;
    if (*(void *)v6)
    {
      *(void *)(v6 + 8) = v7;
      operator delete(v7);
    }
    MEMORY[0x192FC8940](v6, 0x10C402FEFCB83);
  }
  int v8 = (void *)*((void *)this + 64);
  if (v8) {
    free(v8);
  }
  uint64_t v9 = (const void *)*((void *)this + 67);
  if (v9) {
    CFRelease(v9);
  }
  int v10 = (const void *)*((void *)this + 68);
  if (v10) {
    CFRelease(v10);
  }
  int v11 = (void *)*((void *)this + 70);
  if (v11) {
    free(v11);
  }
  __int16 v12 = (const void *)*((void *)this + 72);
  if (v12) {
    CFRelease(v12);
  }
  int v13 = (const void *)*((void *)this + 73);
  if (v13) {
    CFRelease(v13);
  }
  uint64_t v14 = *((void *)this + 75);
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
  }
  BOOL v15 = *((void *)this + 76);
  if (v15) {
    MEMORY[0x192FC8940](v15, 0x1000C403E1C8BA9);
  }
  char v16 = (void *)*((void *)this + 47);
  if (v16)
  {
    *((void *)this + 48) = v16;
    operator delete(v16);
  }
  BOOL v17 = (void *)*((void *)this + 43);
  if (v17)
  {
    *((void *)this + 44) = v17;
    operator delete(v17);
  }
  char v18 = (void *)*((void *)this + 40);
  if (v18)
  {
    *((void *)this + 41) = v18;
    operator delete(v18);
  }
  char v19 = (void *)*((void *)this + 36);
  if (v19)
  {
    *((void *)this + 37) = v19;
    operator delete(v19);
  }
  char v20 = (void *)*((void *)this + 33);
  if (v20)
  {
    *((void *)this + 34) = v20;
    operator delete(v20);
  }
  char v21 = (void *)*((void *)this + 22);
  if (v21)
  {
    *((void *)this + 23) = v21;
    operator delete(v21);
  }
  uint64_t v22 = (void *)*((void *)this + 19);
  if (v22)
  {
    *((void *)this + 20) = v22;
    operator delete(v22);
  }
  int v23 = *((void *)this + 18);
  *((void *)this + 18) = 0;
  if (v23) {
    MEMORY[0x192FC8910](v23, 0x1000C8077774924);
  }
  AudioFileObject::~AudioFileObject(this);
}

uint64_t MP4_AudioFormat::DataSourceIsThisFormat(MP4_AudioFormat *this, DataSource *a2)
{
  return IsValidDataForMP4FileType(a2, 1836069990);
}

void MP4_AudioFormat::NewStream(MP4_AudioFormat *this)
{
}

void MP4_AudioFormat::New(MP4_AudioFormat *this)
{
}

void sub_1901A8654(_Unwind_Exception *a1)
{
  MEMORY[0x192FC8940](v1, 0x10F1C4096D1D24ELL);
  _Unwind_Resume(a1);
}

void MP4AudioFile::MP4AudioFile(MP4AudioFile *this, int a2)
{
  *((_DWORD *)this + 16) = 0;
  *((void *)this + 9) = 0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *((_DWORD *)this + 20) = 1;
  *((_DWORD *)this + 21) = a2;
  *((void *)this + 11) = 0;
  *((_DWORD *)this + 24) = -1;
  *((_WORD *)this + 50) = 0;
  *((void *)this + 13) = 0;
  *((_DWORD *)this + 28) = 0;
  *((void *)this + 15) = 0;
  *((void *)this + 16) = 0x100000000;
  *((_DWORD *)this + 34) = 65792;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *((void *)this + 7) = 0;
  *(void *)this = &unk_1EDF8D730;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 188) = 0u;
  *(_OWORD *)((char *)this + 172) = 0u;
  *(_OWORD *)((char *)this + 156) = 0u;
  *(_OWORD *)((char *)this + 140) = 0u;
  *((void *)this + 27) = 0x4072C00000000000;
  *(_OWORD *)((char *)this + 392) = 0u;
  *(_OWORD *)((char *)this + 376) = 0u;
  *((_OWORD *)this + 27) = 0u;
  *((void *)this + 31) = 0;
  *(_OWORD *)((char *)this + 232) = 0u;
  *((unsigned char *)this + 256) = 0;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *((unsigned char *)this + 312) = 0;
  *((_OWORD *)this + 20) = 0u;
  *((_OWORD *)this + 21) = 0u;
  *((_OWORD *)this + 22) = 0u;
  *((unsigned char *)this + 368) = 0;
  *((_WORD *)this + 204) = 0;
  *((void *)this + 52) = 0;
  *((void *)this + 53) = (char *)this + 432;
  *((void *)this + 56) = 0;
  *((_DWORD *)this + 114) = 600;
  *((_DWORD *)this + 126) = 0;
  *((void *)this + 64) = 0;
  *((unsigned char *)this + 520) = 0;
  *((_DWORD *)this + 131) = 0;
  *((unsigned char *)this + 528) = 0;
  *((unsigned char *)this + 552) = 0;
  *(_OWORD *)((char *)this + 536) = 0u;
  *((unsigned char *)this + 572) = 0;
  *(_OWORD *)((char *)this + 556) = 0u;
  *((_DWORD *)this + 148) = 0;
  *((_OWORD *)this + 36) = 0u;
  *(_OWORD *)((char *)this + 600) = 0u;
  *((void *)this + 58) = -1;
  *((void *)this + 59) = 0;
  *((void *)this + 60) = -1;
  *((void *)this + 61) = 0;
  *((void *)this + 62) = 0;
  operator new();
}

void sub_1901A880C(_Unwind_Exception *a1)
{
  int v7 = *v4;
  if (*v4)
  {
    *((void *)v1 + 48) = v7;
    operator delete(v7);
  }
  SampleToRollDistanceTable::~SampleToRollDistanceTable(v3);
  SampleToRollDistanceTable::~SampleToRollDistanceTable(v2);
  int v8 = (void *)*((void *)v1 + 22);
  if (v8)
  {
    *((void *)v1 + 23) = v8;
    operator delete(v8);
  }
  uint64_t v9 = (void *)*((void *)v1 + 19);
  if (v9)
  {
    *((void *)v1 + 20) = v9;
    operator delete(v9);
  }
  uint64_t v10 = *((void *)v1 + 18);
  *((void *)v1 + 18) = 0;
  if (v10) {
    MEMORY[0x192FC8910](v10, 0x1000C8077774924);
  }
  AudioFileObject::~AudioFileObject(v1);
  _Unwind_Resume(a1);
}

void SampleToRollDistanceTable::~SampleToRollDistanceTable(SampleToRollDistanceTable *this)
{
  int v2 = (void *)*((void *)this + 4);
  if (v2)
  {
    *((void *)this + 5) = v2;
    operator delete(v2);
  }
  char v3 = (void *)*((void *)this + 1);
  if (v3)
  {
    *((void *)this + 2) = v3;
    operator delete(v3);
  }
}

uint64_t MP4_AudioFormat::GetHFSCodes(MP4_AudioFormat *this, unsigned int *a2, void *__dst)
{
  int __src = 1836082996;
  if (*a2 >= 4) {
    size_t v3 = 4;
  }
  else {
    size_t v3 = *a2 & 0xFFFFFFFC;
  }
  *a2 = v3;
  if (__dst) {
    memcpy(__dst, &__src, v3);
  }
  return 0;
}

uint64_t MP4_AudioFormat::GetAvailableStreamDescriptions(MP4_AudioFormat *this, int a2, unsigned int *a3, void *a4)
{
  return GetAvailableStreamDescriptionsForFileType(1836069990, a2, a3, a4);
}

uint64_t GetAvailableStreamDescriptionsForFileType(int a1, int a2, unsigned int *a3, void *__dst)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  if (a2 == 1819304813)
  {
    if (a1 == 1836069990)
    {
      memset(v34, 0, 352);
      long long v32 = 0u;
      long long v33 = 0u;
      long long __src = 0u;
      int v7 = v34;
      uint64_t v8 = -24;
      do
      {
        *((void *)v7 - 5) = 0xC6C70636DLL;
        *((_DWORD *)v7 - 4) = v8 + 40;
        *((_DWORD *)v7 - 7) = 1;
        *(void *)int v7 = 0xE6C70636DLL;
        *((_DWORD *)v7 + 6) = v8 + 40;
        *((_DWORD *)v7 + 3) = 1;
        v7 += 5;
        v8 += 8;
      }
      while (v8);
      uint64_t v9 = 0;
      int v10 = 32;
      char v11 = 1;
      do
      {
        __int16 v12 = (char *)&__src + 40 * v9;
        *((void *)v12 + 1) = 0x96C70636DLL;
        *((_DWORD *)v12 + 8) = v10;
        *((_DWORD *)v12 + 5) = 1;
        int v13 = (char *)&__src + 40 * (v9 | 1);
        *((void *)v13 + 1) = 0xB6C70636DLL;
        LOBYTE(v12) = v11;
        *((_DWORD *)v13 + 8) = v10;
        *((_DWORD *)v13 + 5) = 1;
        v10 += 32;
        uint64_t v9 = 2;
        char v11 = 0;
      }
      while ((v12 & 1) != 0);
      unsigned int v14 = 10;
    }
    else
    {
      unsigned int v14 = 0;
    }
LABEL_13:
    if (*a3 / 0x28 < v14) {
      unsigned int v14 = *a3 / 0x28;
    }
    size_t v19 = 40 * v14;
    *a3 = v19;
    if (__dst) {
      memcpy(__dst, &__src, v19);
    }
    return 0;
  }
  UInt32 outPropertyDataSize = 0;
  uint64_t PropertyInfo = AudioFormatGetPropertyInfo(0x61636966u, 0, 0, &outPropertyDataSize);
  if (PropertyInfo) {
    return PropertyInfo;
  }
  UInt32 v17 = outPropertyDataSize;
  unint64_t v18 = (unint64_t)outPropertyDataSize >> 2;
  CADeprecated::CAAutoFree<unsigned int>::CAAutoFree(&outPropertyData, v18, 1);
  uint64_t PropertyInfo = GetAllFormatIDs(&outPropertyDataSize, outPropertyData);
  if (!PropertyInfo)
  {
    if (v17 < 4)
    {
      BOOL v26 = 0;
LABEL_50:
      if (outPropertyData) {
        free(outPropertyData);
      }
      if (!v26)
      {
        *a3 = 0;
        return 1718449215;
      }
      *(void *)&long long v33 = 0;
      long long __src = 0u;
      long long v32 = 0u;
      DWORD2(__src) = a2;
      unsigned int v14 = 1;
      goto LABEL_13;
    }
    uint64_t v21 = 0;
    unsigned int v22 = a2 & 0xFFFFFF00;
    BOOL v24 = a2 == 1885430115 || v22 == 1633772288;
    BOOL v28 = v24;
    if (v18 <= 1) {
      uint64_t v25 = 1;
    }
    else {
      uint64_t v25 = v18;
    }
    BOOL v26 = 1;
    while (1)
    {
      if (*((_DWORD *)outPropertyData + v21) == a2)
      {
        if (a1 <= 1832149349)
        {
          if ((a1 == 862416946 || a1 == 862417008)
            && (a2 == 1365470320 || a2 == 1935764850 || a2 == 1935767394 || v22 == 1633772288))
          {
            goto LABEL_50;
          }
        }
        else
        {
          switch(a1)
          {
            case 1832149350:
              BOOL v27 = IsSupportedM4AFormat(a2);
LABEL_44:
              if (v27) {
                goto LABEL_50;
              }
              break;
            case 1832149606:
              if (v28) {
                goto LABEL_50;
              }
              break;
            case 1836069990:
              BOOL v27 = IsSupportedMP4Format(a2);
              goto LABEL_44;
          }
        }
      }
      BOOL v26 = ++v21 < v18;
      if (v25 == v21) {
        goto LABEL_50;
      }
    }
  }
  if (outPropertyData) {
    free(outPropertyData);
  }
  return PropertyInfo;
}

void sub_1901A8CC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11)
{
  if (a11) {
    free(a11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MP4_AudioFormat::GetAvailableFormatIDs(MP4_AudioFormat *this, unsigned int *a2, void *a3)
{
  return GetAvailableFormatIDsForFileType(1836069990, a2, a3);
}

uint64_t GetAvailableFormatIDsForFileType(int a1, unsigned int *a2, void *a3)
{
  UInt32 outPropertyDataSize = 0;
  uint64_t PropertyInfo = AudioFormatGetPropertyInfo(0x61636966u, 0, 0, &outPropertyDataSize);
  if (PropertyInfo) {
    return PropertyInfo;
  }
  UInt32 v7 = outPropertyDataSize;
  unint64_t v8 = (unint64_t)outPropertyDataSize >> 2;
  CADeprecated::CAAutoFree<unsigned int>::CAAutoFree(&__src, v8, 1);
  CADeprecated::CAAutoFree<unsigned int>::CAAutoFree(&outPropertyData, v8, 1);
  uint64_t PropertyInfo = GetAllFormatIDs(&outPropertyDataSize, outPropertyData);
  if (!PropertyInfo)
  {
    if (v7 < 4)
    {
      unsigned int v9 = 0;
LABEL_36:
      if (outPropertyData)
      {
        free(outPropertyData);
        CFDataRef outPropertyData = 0;
      }
      if (4 * v9 >= *a2) {
        size_t v18 = *a2;
      }
      else {
        size_t v18 = 4 * v9;
      }
      *a2 = v18;
      if (a3)
      {
        size_t v19 = __src;
        memcpy(a3, __src, v18);
        uint64_t PropertyInfo = 0;
        if (!v19) {
          return PropertyInfo;
        }
        goto LABEL_46;
      }
      uint64_t PropertyInfo = 0;
      goto LABEL_45;
    }
    uint64_t v10 = 0;
    unsigned int v9 = 0;
    if (v8 <= 1) {
      unsigned int v11 = 1;
    }
    else {
      unsigned int v11 = v8;
    }
    uint64_t v12 = 4 * v11;
    while (1)
    {
      if (a1 <= 1832149349)
      {
        if (a1 != 862416946 && a1 != 862417008) {
          goto LABEL_35;
        }
        int v13 = *(_DWORD *)((char *)outPropertyData + v10);
        BOOL v15 = v13 == 1365470320 || v13 == 1935764850 || v13 == 1935767394;
        unsigned int v16 = v13 & 0xFFFFFF00;
      }
      else
      {
        if (a1 == 1832149350)
        {
          int v13 = *(_DWORD *)((char *)outPropertyData + v10);
          if (!IsSupportedM4AFormat(v13)) {
            goto LABEL_35;
          }
          goto LABEL_34;
        }
        if (a1 != 1832149606)
        {
          if (a1 != 1836069990 || !IsSupportedMP4Format(*(_DWORD *)((char *)outPropertyData + v10))) {
            goto LABEL_35;
          }
          int v13 = *(_DWORD *)((char *)outPropertyData + v10);
          goto LABEL_34;
        }
        int v13 = *(_DWORD *)((char *)outPropertyData + v10);
        unsigned int v16 = v13 & 0xFFFFFF00;
        BOOL v15 = v13 == 1885430115;
      }
      if (!v15 && v16 != 1633772288) {
        goto LABEL_35;
      }
LABEL_34:
      *((_DWORD *)__src + v9++) = v13;
LABEL_35:
      v10 += 4;
      if (v12 == v10) {
        goto LABEL_36;
      }
    }
  }
  if (outPropertyData) {
    free(outPropertyData);
  }
LABEL_45:
  size_t v19 = __src;
  if (__src) {
LABEL_46:
  }
    free(v19);
  return PropertyInfo;
}

void sub_1901A8F3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *a11)
{
  if (a10) {
    free(a10);
  }
  if (a11) {
    free(a11);
  }
  _Unwind_Resume(exception_object);
}

void MP4_AudioFormat::GetFileTypeName(MP4_AudioFormat *this, const __CFString **a2)
{
  CABundleLocker::CABundleLocker((CABundleLocker *)&v5);
  size_t v3 = (__CFBundle *)sAudioToolboxBundle;
  if (sAudioToolboxBundle == -1)
  {
    pthread_once(&sOnce, InitGetAudioToolboxBundle);
    size_t v3 = (__CFBundle *)sAudioToolboxBundle;
    if (sAudioToolboxBundle) {
      goto LABEL_3;
    }
LABEL_5:
    CFStringRef v4 = (const __CFString *)CFRetain(@"MPEG-4");
    goto LABEL_6;
  }
  if (!sAudioToolboxBundle) {
    goto LABEL_5;
  }
LABEL_3:
  CFStringRef v4 = CFBundleCopyLocalizedString(v3, @"MPEG-4 Audio", @"MPEG-4 Audio", @"FileTypeNames");
LABEL_6:
  *a2 = v4;
  CABundleLocker::~CABundleLocker((CABundleLocker *)&v5);
}

void sub_1901A9008(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

const __CFArray *MP4_AudioFormat::GetMIMETypes(MP4_AudioFormat *this, const __CFArray **a2)
{
  v4[1] = *(const void **)MEMORY[0x1E4F143B8];
  v4[0] = @"audio/mp4";
  CFArrayRef result = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v4, 1, MEMORY[0x1E4F1D510]);
  *a2 = result;
  return result;
}

const __CFArray *MP4_AudioFormat::GetUTIs(MP4_AudioFormat *this, const __CFArray **a2)
{
  v4[1] = *(const void **)MEMORY[0x1E4F143B8];
  v4[0] = @"public.mpeg-4";
  CFArrayRef result = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v4, 1, MEMORY[0x1E4F1D510]);
  *a2 = result;
  return result;
}

const __CFArray *MP4_AudioFormat::GetExtensions(MP4_AudioFormat *this, const __CFArray **a2)
{
  values[2] = *(void **)MEMORY[0x1E4F143B8];
  values[0] = @"mp4";
  values[1] = @"mpg4";
  CFArrayRef result = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)values, 2, MEMORY[0x1E4F1D510]);
  *a2 = result;
  return result;
}

void MP4_AudioFormat::FileDataIsThisFormat(MP4_AudioFormat *this, unsigned int a2, const void *a3)
{
}

BOOL MP4_AudioFormat::ExtensionIsThisFormat(MP4_AudioFormat *this, CFStringRef theString1)
{
  uint64_t v3 = 1;
  if (CFStringCompare(theString1, @"mp4", 1uLL)) {
    return CFStringCompare(theString1, @"mpg4", 1uLL) == kCFCompareEqualTo;
  }
  return v3;
}

void MP4_AudioFormat::~MP4_AudioFormat(MP4_AudioFormat *this)
{
}

uint64_t MP4_M4A_AudioFormat::DataSourceIsThisFormat(MP4_M4A_AudioFormat *this, DataSource *a2)
{
  return IsValidDataForMP4FileType(a2, 1832149350);
}

void MP4_M4A_AudioFormat::NewStream(MP4_M4A_AudioFormat *this)
{
}

void MP4_M4A_AudioFormat::New(MP4_M4A_AudioFormat *this)
{
}

void sub_1901A9384(_Unwind_Exception *a1)
{
  MEMORY[0x192FC8940](v1, 0x10F1C4096D1D24ELL);
  _Unwind_Resume(a1);
}

uint64_t MP4_M4A_AudioFormat::GetHFSCodes(MP4_M4A_AudioFormat *this, unsigned int *a2, void *__dst)
{
  int __src = 1295270176;
  if (*a2 >= 4) {
    size_t v3 = 4;
  }
  else {
    size_t v3 = *a2 & 0xFFFFFFFC;
  }
  *a2 = v3;
  if (__dst) {
    memcpy(__dst, &__src, v3);
  }
  return 0;
}

uint64_t MP4_M4A_AudioFormat::GetAvailableStreamDescriptions(MP4_M4A_AudioFormat *this, int a2, unsigned int *a3, void *a4)
{
  return GetAvailableStreamDescriptionsForFileType(1832149350, a2, a3, a4);
}

uint64_t MP4_M4A_AudioFormat::GetAvailableFormatIDs(MP4_M4A_AudioFormat *this, unsigned int *a2, void *a3)
{
  return GetAvailableFormatIDsForFileType(1832149350, a2, a3);
}

void MP4_M4A_AudioFormat::GetFileTypeName(MP4_M4A_AudioFormat *this, const __CFString **a2)
{
  CABundleLocker::CABundleLocker((CABundleLocker *)&v5);
  size_t v3 = (__CFBundle *)sAudioToolboxBundle;
  if (sAudioToolboxBundle == -1)
  {
    pthread_once(&sOnce, InitGetAudioToolboxBundle);
    size_t v3 = (__CFBundle *)sAudioToolboxBundle;
    if (sAudioToolboxBundle) {
      goto LABEL_3;
    }
LABEL_5:
    CFStringRef v4 = (const __CFString *)CFRetain(@"Apple MPEG-4");
    goto LABEL_6;
  }
  if (!sAudioToolboxBundle) {
    goto LABEL_5;
  }
LABEL_3:
  CFStringRef v4 = CFBundleCopyLocalizedString(v3, @"Apple MPEG-4 Audio", @"Apple MPEG-4 Audio", @"FileTypeNames");
LABEL_6:
  *a2 = v4;
  CABundleLocker::~CABundleLocker((CABundleLocker *)&v5);
}

void sub_1901A94B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

const __CFArray *MP4_M4A_AudioFormat::GetMIMETypes(MP4_M4A_AudioFormat *this, const __CFArray **a2)
{
  values[2] = *(void **)MEMORY[0x1E4F143B8];
  values[0] = @"audio/x-m4a";
  values[1] = @"audio/x-m4r";
  CFArrayRef result = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)values, 2, MEMORY[0x1E4F1D510]);
  *a2 = result;
  return result;
}

const __CFArray *MP4_M4A_AudioFormat::GetUTIs(MP4_M4A_AudioFormat *this, const __CFArray **a2)
{
  v4[3] = *(const void **)MEMORY[0x1E4F143B8];
  v4[0] = @"public.mpeg-4-audio";
  v4[1] = @"com.apple.m4a-audio";
  _DWORD v4[2] = @"com.apple.mpeg-4-ringtone";
  CFArrayRef result = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v4, 3, MEMORY[0x1E4F1D510]);
  *a2 = result;
  return result;
}

const __CFArray *MP4_M4A_AudioFormat::GetExtensions(MP4_M4A_AudioFormat *this, const __CFArray **a2)
{
  values[2] = *(void **)MEMORY[0x1E4F143B8];
  values[0] = @"m4a";
  values[1] = @"m4r";
  CFArrayRef result = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)values, 2, MEMORY[0x1E4F1D510]);
  *a2 = result;
  return result;
}

void MP4_M4A_AudioFormat::FileDataIsThisFormat(MP4_M4A_AudioFormat *this, unsigned int a2, const void *a3)
{
}

BOOL MP4_M4A_AudioFormat::ExtensionIsThisFormat(MP4_M4A_AudioFormat *this, CFStringRef theString1)
{
  uint64_t v3 = 1;
  if (CFStringCompare(theString1, @"m4a", 1uLL)) {
    return CFStringCompare(theString1, @"m4r", 1uLL) == kCFCompareEqualTo;
  }
  return v3;
}

void MP4_M4A_AudioFormat::~MP4_M4A_AudioFormat(MP4_M4A_AudioFormat *this)
{
}

uint64_t MP4_M4B_AudioFormat::DataSourceIsThisFormat(MP4_M4B_AudioFormat *this, DataSource *a2)
{
  return IsValidDataForMP4FileType(a2, 1832149606);
}

void MP4_M4B_AudioFormat::NewStream(MP4_M4B_AudioFormat *this)
{
}

void MP4_M4B_AudioFormat::New(MP4_M4B_AudioFormat *this)
{
}

void sub_1901A984C(_Unwind_Exception *a1)
{
  MEMORY[0x192FC8940](v1, 0x10F1C4096D1D24ELL);
  _Unwind_Resume(a1);
}

uint64_t MP4_M4B_AudioFormat::GetHFSCodes(MP4_M4B_AudioFormat *this, unsigned int *a2, void *__dst)
{
  int __src = 1295270432;
  if (*a2 >= 4) {
    size_t v3 = 4;
  }
  else {
    size_t v3 = *a2 & 0xFFFFFFFC;
  }
  *a2 = v3;
  if (__dst) {
    memcpy(__dst, &__src, v3);
  }
  return 0;
}

uint64_t MP4_M4B_AudioFormat::GetAvailableStreamDescriptions(MP4_M4B_AudioFormat *this, int a2, unsigned int *a3, void *a4)
{
  return GetAvailableStreamDescriptionsForFileType(1832149606, a2, a3, a4);
}

uint64_t MP4_M4B_AudioFormat::GetAvailableFormatIDs(MP4_M4B_AudioFormat *this, unsigned int *a2, void *a3)
{
  return GetAvailableFormatIDsForFileType(1832149606, a2, a3);
}

void MP4_M4B_AudioFormat::GetFileTypeName(MP4_M4B_AudioFormat *this, const __CFString **a2)
{
  CABundleLocker::CABundleLocker((CABundleLocker *)&v5);
  size_t v3 = (__CFBundle *)sAudioToolboxBundle;
  if (sAudioToolboxBundle == -1)
  {
    pthread_once(&sOnce, InitGetAudioToolboxBundle);
    size_t v3 = (__CFBundle *)sAudioToolboxBundle;
    if (sAudioToolboxBundle) {
      goto LABEL_3;
    }
LABEL_5:
    CFStringRef v4 = (const __CFString *)CFRetain(@"Apple MPEG-4");
    goto LABEL_6;
  }
  if (!sAudioToolboxBundle) {
    goto LABEL_5;
  }
LABEL_3:
  CFStringRef v4 = CFBundleCopyLocalizedString(v3, @"Apple MPEG-4 AudioBooks", @"Apple MPEG-4 AudioBooks", @"FileTypeNames");
LABEL_6:
  *a2 = v4;
  CABundleLocker::~CABundleLocker((CABundleLocker *)&v5);
}

void sub_1901A997C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

const __CFArray *MP4_M4B_AudioFormat::GetMIMETypes(MP4_M4B_AudioFormat *this, const __CFArray **a2)
{
  v4[1] = *(const void **)MEMORY[0x1E4F143B8];
  v4[0] = @"audio/x-m4b";
  CFArrayRef result = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v4, 1, MEMORY[0x1E4F1D510]);
  *a2 = result;
  return result;
}

const __CFArray *MP4_M4B_AudioFormat::GetUTIs(MP4_M4B_AudioFormat *this, const __CFArray **a2)
{
  v4[1] = *(const void **)MEMORY[0x1E4F143B8];
  v4[0] = @"public.mpeg-4-audiobooks";
  CFArrayRef result = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v4, 1, MEMORY[0x1E4F1D510]);
  *a2 = result;
  return result;
}

const __CFArray *MP4_M4B_AudioFormat::GetExtensions(MP4_M4B_AudioFormat *this, const __CFArray **a2)
{
  v4[1] = *(const void **)MEMORY[0x1E4F143B8];
  v4[0] = @"m4b";
  CFArrayRef result = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v4, 1, MEMORY[0x1E4F1D510]);
  *a2 = result;
  return result;
}

void MP4_M4B_AudioFormat::FileDataIsThisFormat(MP4_M4B_AudioFormat *this, unsigned int a2, const void *a3)
{
}

BOOL MP4_M4B_AudioFormat::ExtensionIsThisFormat(MP4_M4B_AudioFormat *this, CFStringRef theString1)
{
  return CFStringCompare(theString1, @"m4b", 1uLL) == kCFCompareEqualTo;
}

void MP4_M4B_AudioFormat::~MP4_M4B_AudioFormat(MP4_M4B_AudioFormat *this)
{
}

uint64_t MP4_3GP_AudioFormat::DataSourceIsThisFormat(MP4_3GP_AudioFormat *this, DataSource *a2)
{
  return IsValidDataForMP4FileType(a2, 862417008);
}

void MP4_3GP_AudioFormat::NewStream(MP4_3GP_AudioFormat *this)
{
}

void MP4_3GP_AudioFormat::New(MP4_3GP_AudioFormat *this)
{
}

void sub_1901A9CC4(_Unwind_Exception *a1)
{
  MEMORY[0x192FC8940](v1, 0x10F1C4096D1D24ELL);
  _Unwind_Resume(a1);
}

uint64_t MP4_3GP_AudioFormat::GetHFSCodes(MP4_3GP_AudioFormat *this, unsigned int *a2, void *__dst)
{
  int __src = 862417008;
  if (*a2 >= 4) {
    size_t v3 = 4;
  }
  else {
    size_t v3 = *a2 & 0xFFFFFFFC;
  }
  *a2 = v3;
  if (__dst) {
    memcpy(__dst, &__src, v3);
  }
  return 0;
}

uint64_t MP4_3GP_AudioFormat::GetAvailableStreamDescriptions(MP4_3GP_AudioFormat *this, int a2, unsigned int *a3, void *a4)
{
  return GetAvailableStreamDescriptionsForFileType(862417008, a2, a3, a4);
}

uint64_t MP4_3GP_AudioFormat::GetAvailableFormatIDs(MP4_3GP_AudioFormat *this, unsigned int *a2, void *a3)
{
  return GetAvailableFormatIDsForFileType(862417008, a2, a3);
}

void MP4_3GP_AudioFormat::GetFileTypeName(MP4_3GP_AudioFormat *this, const __CFString **a2)
{
  CABundleLocker::CABundleLocker((CABundleLocker *)&v5);
  size_t v3 = (__CFBundle *)sAudioToolboxBundle;
  if (sAudioToolboxBundle == -1)
  {
    pthread_once(&sOnce, InitGetAudioToolboxBundle);
    size_t v3 = (__CFBundle *)sAudioToolboxBundle;
    if (sAudioToolboxBundle) {
      goto LABEL_3;
    }
LABEL_5:
    CFStringRef v4 = (const __CFString *)CFRetain(@"3GPP");
    goto LABEL_6;
  }
  if (!sAudioToolboxBundle) {
    goto LABEL_5;
  }
LABEL_3:
  CFStringRef v4 = CFBundleCopyLocalizedString(v3, @"3GP Audio", @"3GP Audio", @"FileTypeNames");
LABEL_6:
  *a2 = v4;
  CABundleLocker::~CABundleLocker((CABundleLocker *)&v5);
}

void sub_1901A9DF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

const __CFArray *MP4_3GP_AudioFormat::GetMIMETypes(MP4_3GP_AudioFormat *this, const __CFArray **a2)
{
  v4[1] = *(const void **)MEMORY[0x1E4F143B8];
  v4[0] = @"audio/3gpp";
  CFArrayRef result = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v4, 1, MEMORY[0x1E4F1D510]);
  *a2 = result;
  return result;
}

const __CFArray *MP4_3GP_AudioFormat::GetUTIs(MP4_3GP_AudioFormat *this, const __CFArray **a2)
{
  v4[1] = *(const void **)MEMORY[0x1E4F143B8];
  v4[0] = @"public.3gpp";
  CFArrayRef result = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v4, 1, MEMORY[0x1E4F1D510]);
  *a2 = result;
  return result;
}

const __CFArray *MP4_3GP_AudioFormat::GetExtensions(MP4_3GP_AudioFormat *this, const __CFArray **a2)
{
  values[2] = *(void **)MEMORY[0x1E4F143B8];
  values[0] = @"3gp";
  values[1] = @"3gpp";
  CFArrayRef result = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)values, 2, MEMORY[0x1E4F1D510]);
  *a2 = result;
  return result;
}

void MP4_3GP_AudioFormat::FileDataIsThisFormat(MP4_3GP_AudioFormat *this, unsigned int a2, const void *a3)
{
}

BOOL MP4_3GP_AudioFormat::ExtensionIsThisFormat(MP4_3GP_AudioFormat *this, CFStringRef theString1)
{
  uint64_t v3 = 1;
  if (CFStringCompare(theString1, @"3gp", 1uLL)) {
    return CFStringCompare(theString1, @"3gpp", 1uLL) == kCFCompareEqualTo;
  }
  return v3;
}

void MP4_3GP_AudioFormat::~MP4_3GP_AudioFormat(MP4_3GP_AudioFormat *this)
{
}

uint64_t MP4_3GP2_AudioFormat::DataSourceIsThisFormat(MP4_3GP2_AudioFormat *this, DataSource *a2)
{
  return IsValidDataForMP4FileType(a2, 862416946);
}

void MP4_3GP2_AudioFormat::NewStream(MP4_3GP2_AudioFormat *this)
{
}

void MP4_3GP2_AudioFormat::New(MP4_3GP2_AudioFormat *this)
{
}

void sub_1901AA170(_Unwind_Exception *a1)
{
  MEMORY[0x192FC8940](v1, 0x10F1C4096D1D24ELL);
  _Unwind_Resume(a1);
}

uint64_t MP4_3GP2_AudioFormat::GetHFSCodes(MP4_3GP2_AudioFormat *this, unsigned int *a2, void *__dst)
{
  int __src = 862416946;
  if (*a2 >= 4) {
    size_t v3 = 4;
  }
  else {
    size_t v3 = *a2 & 0xFFFFFFFC;
  }
  *a2 = v3;
  if (__dst) {
    memcpy(__dst, &__src, v3);
  }
  return 0;
}

uint64_t MP4_3GP2_AudioFormat::GetAvailableStreamDescriptions(MP4_3GP2_AudioFormat *this, int a2, unsigned int *a3, void *a4)
{
  return GetAvailableStreamDescriptionsForFileType(862417008, a2, a3, a4);
}

uint64_t MP4_3GP2_AudioFormat::GetAvailableFormatIDs(MP4_3GP2_AudioFormat *this, unsigned int *a2, void *a3)
{
  return GetAvailableFormatIDsForFileType(862416946, a2, a3);
}

void MP4_3GP2_AudioFormat::GetFileTypeName(MP4_3GP2_AudioFormat *this, const __CFString **a2)
{
  CABundleLocker::CABundleLocker((CABundleLocker *)&v5);
  size_t v3 = (__CFBundle *)sAudioToolboxBundle;
  if (sAudioToolboxBundle == -1)
  {
    pthread_once(&sOnce, InitGetAudioToolboxBundle);
    size_t v3 = (__CFBundle *)sAudioToolboxBundle;
    if (sAudioToolboxBundle) {
      goto LABEL_3;
    }
LABEL_5:
    CFStringRef v4 = (const __CFString *)CFRetain(@"3GPP-2");
    goto LABEL_6;
  }
  if (!sAudioToolboxBundle) {
    goto LABEL_5;
  }
LABEL_3:
  CFStringRef v4 = CFBundleCopyLocalizedString(v3, @"3GPP-2 Audio", @"3GPP-2 Audio", @"FileTypeNames");
LABEL_6:
  *a2 = v4;
  CABundleLocker::~CABundleLocker((CABundleLocker *)&v5);
}

void sub_1901AA2A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

const __CFArray *MP4_3GP2_AudioFormat::GetMIMETypes(MP4_3GP2_AudioFormat *this, const __CFArray **a2)
{
  v4[1] = *(const void **)MEMORY[0x1E4F143B8];
  v4[0] = @"audio/3gpp2";
  CFArrayRef result = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v4, 1, MEMORY[0x1E4F1D510]);
  *a2 = result;
  return result;
}

const __CFArray *MP4_3GP2_AudioFormat::GetUTIs(MP4_3GP2_AudioFormat *this, const __CFArray **a2)
{
  v4[1] = *(const void **)MEMORY[0x1E4F143B8];
  v4[0] = @"public.3gpp2";
  CFArrayRef result = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v4, 1, MEMORY[0x1E4F1D510]);
  *a2 = result;
  return result;
}

const __CFArray *MP4_3GP2_AudioFormat::GetExtensions(MP4_3GP2_AudioFormat *this, const __CFArray **a2)
{
  values[2] = *(void **)MEMORY[0x1E4F143B8];
  values[0] = @"3g2";
  values[1] = @"3gp2";
  CFArrayRef result = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)values, 2, MEMORY[0x1E4F1D510]);
  *a2 = result;
  return result;
}

void MP4_3GP2_AudioFormat::FileDataIsThisFormat(MP4_3GP2_AudioFormat *this, unsigned int a2, const void *a3)
{
}

BOOL MP4_3GP2_AudioFormat::ExtensionIsThisFormat(MP4_3GP2_AudioFormat *this, CFStringRef theString1)
{
  uint64_t v3 = 1;
  if (CFStringCompare(theString1, @"3g2", 1uLL)) {
    return CFStringCompare(theString1, @"3gp2", 1uLL) == kCFCompareEqualTo;
  }
  return v3;
}

void MP4_3GP2_AudioFormat::~MP4_3GP2_AudioFormat(MP4_3GP2_AudioFormat *this)
{
}

void *AT::RingBufferErrorCategory::message@<X0>(int a1@<W1>, void *a2@<X8>)
{
  if ((a1 + 5) > 9) {
    uint64_t v3 = "unknown";
  }
  else {
    uint64_t v3 = off_1E5688CC8[a1 + 5];
  }
  return std::string::basic_string[abi:ne180100]<0>(a2, v3);
}

const char *AT::RingBufferErrorCategory::name(AT::RingBufferErrorCategory *this)
{
  return "AT::RingBufferError";
}

void AT::RingBufferErrorCategory::~RingBufferErrorCategory(std::error_category *this)
{
  std::error_category::~error_category(this);
  JUMPOUT(0x192FC8940);
}

uint64_t *AT::RingBufferErrorCategory::instance(AT::RingBufferErrorCategory *this)
{
  {
    AT::RingBufferErrorCategory::instance(void)::global = (uint64_t)&unk_1EDF94F08;
  }
  return &AT::RingBufferErrorCategory::instance(void)::global;
}

uint64_t AT::make_error_code(AT::RingBufferErrorCategory *a1)
{
  unsigned int v1 = a1;
  AT::RingBufferErrorCategory::instance(a1);
  return v1;
}

void AT::RingBuffer::RingBuffer(AT::RingBuffer *this, const AudioStreamBasicDescription *a2, int a3)
{
  long long v3 = *(_OWORD *)&a2->mSampleRate;
  long long v4 = *(_OWORD *)&a2->mBytesPerPacket;
  *((void *)this + 4) = *(void *)&a2->mBitsPerChannel;
  *(_OWORD *)this = v3;
  *((_OWORD *)this + 1) = v4;
  *((_DWORD *)this + 10) = a3;
  operator new();
}

void sub_1901AA714(_Unwind_Exception *a1)
{
  MEMORY[0x192FC8940](v1, 0x1070C40F214F66CLL);
  _Unwind_Resume(a1);
}

AT::RingBuffer::Impl *AT::RingBuffer::Impl::Impl(AT::RingBuffer::Impl *this, const AudioStreamBasicDescription *a2, _anonymous_namespace_::EABLImpl *a3, int a4, int a5)
{
  unsigned int v5 = a3;
  long long v8 = *(_OWORD *)&a2->mSampleRate;
  long long v9 = *(_OWORD *)&a2->mBytesPerPacket;
  *((void *)this + 4) = *(void *)&a2->mBitsPerChannel;
  *(_OWORD *)this = v8;
  *((_OWORD *)this + 1) = v9;
  *((_DWORD *)this + 10) = a5;
  *((_DWORD *)this + 11) = a3;
  *((_DWORD *)this + 12) = a4;
  *((_DWORD *)this + 13) = a5 * a4;
  uint64_t v10 = (void *)((char *)this + 56);
  CA::AudioBuffers::AudioBuffers(v10, v11, 1);
  if (v5 > 1) {
    UInt32 mChannelsPerFrame = 1;
  }
  else {
    UInt32 mChannelsPerFrame = a2->mChannelsPerFrame;
  }
  int v13 = CA::AudioBuffers::Prepare(*((CA::AudioBuffers **)this + 7), mChannelsPerFrame, *((_DWORD *)this + 13));
  uint64_t v14 = 0;
  *((void *)this + 8) = v13;
  *((unsigned char *)this + 72) = 0;
  *((unsigned char *)this + 168) = 0;
  do
  {
    BOOL v15 = (char *)this + v14;
    *((void *)v15 + 22) = 0;
    *((void *)v15 + 23) = 0;
    *((_DWORD *)v15 + 48) = 0;
    v14 += 24;
  }
  while (v14 != 768);
  *((_DWORD *)this + 236) = 0;
  *((_WORD *)this + 474) = 257;
  uint64_t v16 = 176;
  do
  {
    UInt32 v17 = (char *)this + v16;
    *(void *)UInt32 v17 = 0;
    *((void *)v17 + 1) = 0;
    *((_DWORD *)v17 + 4) = 0;
    v16 += 24;
  }
  while (v17 + 24 != (char *)this + 944);
  atomic_store(0, (unsigned int *)this + 236);
  *((unsigned char *)this + 948) = 1;
  return this;
}

void sub_1901AA830(_Unwind_Exception *a1)
{
  CA::AudioBuffers::~AudioBuffers(v1);
  _Unwind_Resume(a1);
}

void AT::RingBuffer::RingBuffer(AT::RingBuffer *this, unsigned int a2, int a3, int a4)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((_DWORD *)this + 6) = a3;
  *(void *)((char *)this + 28) = 0;
  *((_DWORD *)this + 9) = 0;
  *((_DWORD *)this + 10) = a4;
  uint64_t v6 = 0;
  long long v4 = 0u;
  long long v5 = 0u;
  operator new();
}

void sub_1901AA8E4(_Unwind_Exception *a1)
{
  MEMORY[0x192FC8940](v1, 0x1070C40F214F66CLL);
  _Unwind_Resume(a1);
}

void AT::RingBuffer::~RingBuffer(AT::RingBuffer *this)
{
}

{
  std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6);
}

uint64_t *std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100](uint64_t *result)
{
  uint64_t v1 = *result;
  *CFArrayRef result = 0;
  if (v1)
  {
    if (*(unsigned char *)(v1 + 168)) {
      AT::RingBuffer::Impl::InputConverter::~InputConverter((AT::RingBuffer::Impl::InputConverter *)(v1 + 72));
    }
    ExtendedAudioBufferList_Destroy(*(std::pmr **)(v1 + 56));
    JUMPOUT(0x192FC8940);
  }
  return result;
}

void AT::RingBuffer::Impl::InputConverter::~InputConverter(AT::RingBuffer::Impl::InputConverter *this)
{
  int v2 = (OpaqueAudioConverter *)*((void *)this + 11);
  if (v2) {
    AudioConverterDispose(v2);
  }
  long long v3 = (void *)*((void *)this + 8);
  if (v3)
  {
    *((void *)this + 9) = v3;
    operator delete(v3);
  }
  long long v4 = (void *)*((void *)this + 5);
  if (v4)
  {
    *((void *)this + std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = v4;
    operator delete(v4);
  }
}

uint64_t AT::RingBuffer::SetInputFormat(AT::RingBuffer *this, const AudioStreamBasicDescription *a2)
{
  uint64_t v2 = *((void *)this + 6);
  if (a2->mSampleRate != *(double *)v2) {
    return 4294967246;
  }
  if (*(unsigned char *)(v2 + 168))
  {
    AT::RingBuffer::Impl::InputConverter::~InputConverter((AT::RingBuffer::Impl::InputConverter *)(v2 + 72));
    *(unsigned char *)(v2 + 168) = 0;
  }
  UInt32 mBytesPerFrame = a2->mBytesPerFrame;
  UInt32 mChannelsPerFrame = a2->mChannelsPerFrame;
  uint64_t v7 = *(void *)&a2->mBitsPerChannel;
  uint64_t v12 = *(void *)&a2->mBytesPerPacket;
  AudioFormatID mFormatID = a2->mFormatID;
  AudioFormatFlags mFormatFlags = a2->mFormatFlags;
  *(Float64 *)(v2 + 72) = a2->mSampleRate;
  *(_DWORD *)(v2 + 80) = mFormatID;
  *(_DWORD *)(v2 + 84) = mFormatFlags;
  *(void *)(v2 + 88) = v12;
  if ((mFormatFlags & 0x20) != 0) {
    uint64_t v10 = mChannelsPerFrame;
  }
  else {
    uint64_t v10 = 1;
  }
  *(_DWORD *)(v2 + 9std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = mBytesPerFrame;
  *(_DWORD *)(v2 + 100) = mChannelsPerFrame;
  *(void *)(v2 + 104) = v7;
  std::vector<char>::value_type __x = 0;
  std::vector<char>::vector((std::vector<char> *)(v2 + 112), (16 * v10) | 8, &__x);
  **(_DWORD **)(v2 + 112) = v10;
  if ((*(_DWORD *)(v2 + 12) & 0x20) != 0) {
    uint64_t v11 = *(unsigned int *)(v2 + 28);
  }
  else {
    uint64_t v11 = 1;
  }
  std::vector<char>::value_type __x = 0;
  std::vector<char>::vector((std::vector<char> *)(v2 + 136), (16 * v11) | 8, &__x);
  **(_DWORD **)(v2 + 13std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = v11;
  *(void *)(v2 + 160) = 0;
  uint64_t result = AudioConverterNewWithOptions((AudioStreamBasicDescription *)(v2 + 72), (AudioStreamBasicDescription *)v2, 0x10000, (void *)(v2 + 160));
  *(unsigned char *)(v2 + 168) = 1;
  return result;
}

void sub_1901AAB48(_Unwind_Exception *exception_object)
{
  long long v5 = *v3;
  if (*v3)
  {
    *(void *)(v1 + 144) = v5;
    operator delete(v5);
  }
  uint64_t v6 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 120) = v6;
    operator delete(v6);
  }
  _Unwind_Resume(exception_object);
}

uint64_t AT::RingBuffer::Fetch(AT::RingBuffer *this, AudioBufferList *a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7 = *((void *)this + 6);
  uint64_t v8 = a4 + a3;
  uint64_t result = AT::RingBuffer::Impl::CheckTimeBounds((AT::RingBuffer::Impl *)v7, a4, v8);
  if (!result)
  {
    if (a3)
    {
      uint64_t v10 = *(int *)(v7 + 40);
      int v11 = *(_DWORD *)(v7 + 48);
      uint64_t v12 = ((v10 & ((int)(a4 % v10) >> 31)) + (a4 % v10)) * v11;
      size_t v13 = ((v10 & ((int)(v8 % v10) >> 31)) + (v8 % v10)) * v11;
      if (v12 >= v13)
      {
        size_t v18 = *(unsigned int *)(v7 + 52) - v12;
        LODWORD(mNumberBuffers) = a2->mNumberBuffers;
        if (a2->mNumberBuffers)
        {
          unint64_t v19 = 0;
          uint64_t v20 = *(void *)(v7 + 64);
          uint64_t v21 = 16;
          do
          {
            memcpy(*(void **)((char *)&a2->mNumberBuffers + v21), (const void *)(*(void *)(v20 + v21) + v12), v18);
            ++v19;
            unint64_t mNumberBuffers = a2->mNumberBuffers;
            v21 += 16;
          }
          while (v19 < mNumberBuffers);
          if (mNumberBuffers)
          {
            unint64_t v22 = 0;
            uint64_t v23 = *(void *)(v7 + 64);
            uint64_t v24 = 16;
            do
            {
              memcpy((void *)(*(void *)((char *)&a2->mNumberBuffers + v24) + v18), *(const void **)(v23 + v24), v13);
              ++v22;
              unint64_t mNumberBuffers = a2->mNumberBuffers;
              v24 += 16;
            }
            while (v22 < mNumberBuffers);
          }
        }
        LODWORD(v13) = v18 + v13;
        if (!mNumberBuffers) {
          return AT::RingBuffer::Impl::CheckTimeBounds((AT::RingBuffer::Impl *)v7, a4, v8);
        }
        goto LABEL_18;
      }
      if (!a2->mNumberBuffers) {
        return AT::RingBuffer::Impl::CheckTimeBounds((AT::RingBuffer::Impl *)v7, a4, v8);
      }
      unint64_t v14 = 0;
      uint64_t v15 = *(void *)(v7 + 64);
      v13 -= v12;
      uint64_t v16 = 16;
      do
      {
        memcpy(*(void **)((char *)&a2->mNumberBuffers + v16), (const void *)(*(void *)(v15 + v16) + v12), v13);
        ++v14;
        unint64_t mNumberBuffers = a2->mNumberBuffers;
        v16 += 16;
      }
      while (v14 < mNumberBuffers);
    }
    else
    {
      LODWORD(v13) = 0;
      LODWORD(mNumberBuffers) = a2->mNumberBuffers;
    }
    if (!mNumberBuffers) {
      return AT::RingBuffer::Impl::CheckTimeBounds((AT::RingBuffer::Impl *)v7, a4, v8);
    }
LABEL_18:
    unint64_t mNumberBuffers = mNumberBuffers;
    p_UInt32 mDataByteSize = &a2->mBuffers[0].mDataByteSize;
    do
    {
      *p_UInt32 mDataByteSize = v13;
      p_mDataByteSize += 4;
      --mNumberBuffers;
    }
    while (mNumberBuffers);
    return AT::RingBuffer::Impl::CheckTimeBounds((AT::RingBuffer::Impl *)v7, a4, v8);
  }
  return result;
}

unint64_t AT::RingBuffer::Impl::CheckTimeBounds(AT::RingBuffer::Impl *this, uint64_t a2, uint64_t a3)
{
  TimeBounds = AT::RingBuffer::Impl::GetTimeBounds(&v9, (uint64_t)this);
  if (!v11)
  {
    unint64_t v6 = v9 & 0xFFFFFFFF00000000;
    uint64_t v7 = v9;
    return v6 | v7;
  }
  if (v9 <= a2)
  {
    if (v10 >= a3)
    {
      std::system_category();
      uint64_t v7 = 0;
      unint64_t v6 = 0;
      return v6 | v7;
    }
    if (v10 > a2) {
      uint64_t v7 = 1;
    }
    else {
      uint64_t v7 = 2;
    }
    goto LABEL_13;
  }
  if (v10 >= a3)
  {
    if (v9 >= a3) {
      uint64_t v7 = 4294967294;
    }
    else {
      uint64_t v7 = 0xFFFFFFFFLL;
    }
LABEL_13:
    AT::RingBufferErrorCategory::instance((AT::RingBufferErrorCategory *)TimeBounds);
    unint64_t v6 = 0;
    return v6 | v7;
  }
  AT::RingBufferErrorCategory::instance((AT::RingBufferErrorCategory *)TimeBounds);
  unint64_t v6 = 0;
  uint64_t v7 = 3;
  return v6 | v7;
}

uint64_t AT::RingBuffer::SetResetWhenEmpty(uint64_t this, char a2)
{
  *(unsigned char *)(*(void *)(this + 48) + 949) = a2;
  return this;
}

uint64_t AT::RingBuffer::TouchMemory(AT::RingBuffer *this)
{
  uint64_t v1 = *((void *)this + 6);
  uint64_t v2 = *(unsigned int **)(v1 + 64);
  uint64_t v3 = *v2;
  if (v3)
  {
    uint64_t v4 = 0;
    int v5 = 0;
    unint64_t v6 = *(unsigned int *)(v1 + 52);
    do
    {
      if (v6)
      {
        for (unint64_t i = 0; i < v6; i += 4096)
          v5 += *(unsigned __int8 *)(*(void *)&v2[4 * v4 + 4] + i);
      }
      ++v4;
    }
    while (v4 != v3);
  }
  else
  {
    int v5 = 0;
  }
  uint64_t result = (AT::RingBuffer::Impl::TouchMemory(void)::gTempValue + v5);
  AT::RingBuffer::Impl::TouchMemory(void)::gTempValue += v5;
  return result;
}

uint64_t MP4BoxParser_SampleToGroup::GetSampleToGroupTable()
{
  return 0;
}

uint64_t MP4BoxParser_SampleToGroup::Init(MP4BoxParser_SampleToGroup *this)
{
  return 4294967294;
}

void MP4BoxParser_SampleToGroup::~MP4BoxParser_SampleToGroup(MP4BoxParser_SampleToGroup *this)
{
  uint64_t v2 = *((void *)this + 1);
  *(void *)this = &unk_1EDF8DA18;
  *((void *)this + 1) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  JUMPOUT(0x192FC8940);
}

{
  uint64_t v2;

  uint64_t v2 = *((void *)this + 1);
  *(void *)this = &unk_1EDF8DA18;
  *((void *)this + 1) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
}

void MP4BoxParser_SampleToGroup::MP4BoxParser_SampleToGroup(MP4BoxParser_SampleToGroup *this, DataSource *a2, uint64_t a3)
{
  *(void *)this = &unk_1EDF8DA18;
  (*(void (**)(DataSource *, uint64_t))(*(void *)a2 + 88))(a2, a3);
  *((unsigned char *)this + 1std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  *((_DWORD *)this + 5) = 0;
  *((void *)this + 3) = 0;
  *((unsigned char *)this + 32) = 0;
  *((_DWORD *)this + 9) = 8;
  *(void *)this = &unk_1EDF94058;
  *((unsigned char *)this + 60) = 0;
  *((_DWORD *)this + 1std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  *((unsigned char *)this + 68) = 0;
  *((_DWORD *)this + 18) = 0;
  *((_WORD *)this + 38) = 0;
}

uint64_t ShortTermLinearInterpolationResampler::SetRate(uint64_t this, double a2)
{
  if (a2 >= 0.0)
  {
    BOOL v2 = a2 == 32.0;
    BOOL v3 = a2 < 32.0;
  }
  else
  {
    BOOL v2 = 0;
    BOOL v3 = 0;
  }
  if (!v3 && !v2)
  {
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = -50;
  }
  *(double *)(this + 40) = a2;
  *(void *)(this + 24) = vcvtd_n_s64_f64(a2, 0x20uLL);
  return this;
}

unint64_t ShortTermLinearInterpolationResampler::GetNumberOfSourceFrames(ShortTermLinearInterpolationResampler *this, uint64_t a2)
{
  if (a2 > 0x400000)
  {
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = -50;
  }
  if (!*(unsigned char *)this && a2) {
    return (*((void *)this + 2) + *((void *)this + 3) * (unint64_t)a2 + 0x80000000) >> 32;
  }
  return a2;
}

uint64_t ShortTermLinearInterpolationResampler::GetNumberOfOutputFrames(ShortTermLinearInterpolationResampler *this, uint64_t a2)
{
  if (a2 > 0x400000)
  {
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = -50;
  }
  if (!*(unsigned char *)this)
  {
    uint64_t v2 = *((void *)this + 3);
    uint64_t v3 = ~*((void *)this + 2) + (a2 << 32) + v2;
    if (v3 < 0) {
      return 0;
    }
    else {
      return v3 / v2;
    }
  }
  return a2;
}

FILE *CAFormatter::InitWithMemoryStream(CAFormatter *this, FILE **a2)
{
  uint64_t result = CAMemoryStream::cstr(a2);
  a2[2] = 0;
  a2[3] = 0;
  a2[1] = 0;
  *(void *)this = result;
  return result;
}

void CAFormatter::CAFormatter(CAFormatter *this, const int *a2, int a3)
{
  char v11 = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  unint64_t v6 = funopen(&v10, 0, (int (__cdecl *)(void *, const char *, int))CAMemoryStream::Write, 0, 0);
  uint64_t v10 = v6;
  int v7 = a3 - 1;
  if (a3 >= 1)
  {
    uint64_t v8 = v6;
    while (1)
    {
      fprintf(v8, "%d", *a2);
      if (!v7) {
        break;
      }
      ++a2;
      fputc(32, v8);
      --v7;
    }
  }
  uint64_t v9 = CAMemoryStream::cstr(&v10);
  char v11 = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  *(void *)this = v9;
  fclose(v10);
  free(v11);
}

void sub_1901AB254(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, FILE *a11, void *a12)
{
}

void CAFormatter::CAFormatter(CAFormatter *this, const float *a2, int a3)
{
  char v11 = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  unint64_t v6 = funopen(&v10, 0, (int (__cdecl *)(void *, const char *, int))CAMemoryStream::Write, 0, 0);
  uint64_t v10 = v6;
  int v7 = a3 - 1;
  if (a3 >= 1)
  {
    uint64_t v8 = v6;
    while (1)
    {
      fprintf(v8, "%.3f", *a2);
      if (!v7) {
        break;
      }
      ++a2;
      fputc(32, v8);
      --v7;
    }
  }
  uint64_t v9 = CAMemoryStream::cstr(&v10);
  char v11 = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  *(void *)this = v9;
  fclose(v10);
  free(v11);
}

void sub_1901AB35C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, FILE *a11, void *a12)
{
}

void CAFormatter::CAFormatter(CAFormatter *this, float *a2, int a3, int a4)
{
  unint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t v8 = funopen(&v13, 0, (int (__cdecl *)(void *, const char *, int))CAMemoryStream::Write, 0, 0);
  uint64_t v13 = v8;
  fputc(124, v8);
  if (a4 >= 1)
  {
    do
    {
      int v9 = a3;
      if (a3 >= 1)
      {
        do
        {
          float v10 = *a2++;
          fprintf(v8, " %.3f", v10);
          --v9;
        }
        while (v9);
      }
      fwrite("| ", 2uLL, 1uLL, v8);
    }
    while (a4-- > 1);
  }
  uint64_t v12 = CAMemoryStream::cstr(&v13);
  unint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  *(void *)this = v12;
  fclose(v13);
  free(v14);
}

void sub_1901AB4A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, FILE *a11, void *a12)
{
}

void CAFormatter::CAFormatter(CAFormatter *this, unsigned __int8 *a2, int a3)
{
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  unint64_t v6 = funopen(&v11, 0, (int (__cdecl *)(void *, const char *, int))CAMemoryStream::Write, 0, 0);
  char v11 = v6;
  if (a3 >= 1)
  {
    int v7 = v6;
    unsigned int v8 = a3 + 1;
    do
    {
      int v9 = *a2++;
      fprintf(v7, "%02x", v9);
      --v8;
    }
    while (v8 > 1);
  }
  float v10 = CAMemoryStream::cstr(&v11);
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  *(void *)this = v10;
  fclose(v11);
  free(v12);
}

void sub_1901AB5A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, FILE *a11, void *a12)
{
}

void CAFormatter::CAFormatter(CAFormatter *this, const CAStreamBasicDescription *a2, double a3, int16x8_t a4)
{
  CA::StreamDescription::AsString((CA::StreamDescription *)__p, a2, a3, a4);
  if (v7 >= 0) {
    int v5 = __p;
  }
  else {
    int v5 = (void **)__p[0];
  }
  CAFormatter::Init(this, (const char *)v5);
  if (v7 < 0) {
    operator delete(__p[0]);
  }
}

{
  CAFormatter::CAFormatter(this, a2, a3, a4);
}

void sub_1901AB620(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void CAFormatter::CAFormatter(CAFormatter *this, const AudioTimeStamp *a2, char a3, int a4)
{
  if (a2) {
    CAFormatter::Init(this, a2, a3, a4);
  }
  else {
    CAFormatter::Init(this, "(null)");
  }
}

void CAFormatter::Init(CAFormatter *this, const AudioTimeStamp *a2, char a3, int a4)
{
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  unsigned int v8 = funopen(&v12, 0, (int (__cdecl *)(void *, const char *, int))CAMemoryStream::Write, 0, 0);
  int v9 = v8;
  uint64_t v12 = v8;
  if ((a3 & 2) != 0)
  {
    if ((a2->mFlags & 2) != 0)
    {
      fprintf(v8, "%.6f", (double)a2->mHostTime * 0.0000000416666667);
      if ((a3 & 1) == 0) {
        goto LABEL_15;
      }
    }
    else
    {
      fwrite("invalid ht", 0xAuLL, 1uLL, v8);
      if ((a3 & 1) == 0) {
        goto LABEL_15;
      }
    }
    fwrite(", ", 2uLL, 1uLL, v9);
LABEL_10:
    if (a2->mFlags)
    {
      if (a4) {
        fprintf(v9, "0x%qx st");
      }
      else {
        fprintf(v9, "%lld st");
      }
    }
    else
    {
      fwrite("invalid st", 0xAuLL, 1uLL, v9);
    }
LABEL_15:
    char v10 = 0;
    if ((a3 & 4) == 0) {
      goto LABEL_20;
    }
    goto LABEL_16;
  }
  if (a3) {
    goto LABEL_10;
  }
  char v10 = 1;
  if ((a3 & 4) == 0) {
    goto LABEL_20;
  }
LABEL_16:
  if ((a2->mFlags & 4) != 0)
  {
    if ((v10 & 1) == 0) {
      fwrite(", ", 2uLL, 1uLL, v9);
    }
    fprintf(v9, "%.6f rs", a2->mRateScalar);
  }
LABEL_20:
  char v11 = CAMemoryStream::cstr(&v12);
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  *(void *)this = v11;
  fclose(v12);
  free(v13);
}

void sub_1901AB840(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, FILE *a11, void *a12)
{
}

void CAFormatter::CAFormatter(CAFormatter *this, const AudioComponentDescription *a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (*(void *)&a2->componentFlags) {
    snprintf(__str, 0x30uLL, "/0x%x/0x%x", a2->componentFlags, a2->componentFlagsMask);
  }
  else {
    __str[0] = 0;
  }
  Format4CC(a2->componentType, v7, 0x10uLL);
  Format4CC(a2->componentSubType, v6, 0x10uLL);
  Format4CC(a2->componentManufacturer, v5, 0x10uLL);
  snprintf(__s, 0x30uLL, "%s/%s/%s%s", v7, v6, v5, __str);
  CAFormatter::Init(this, __s);
}

char *Format4CC(unsigned int a1, char *__str, size_t __size)
{
  unsigned int v6 = bswap32(a1);
  *(_DWORD *)__str = v6;
  uint64_t v7 = MEMORY[0x1E4F14390];
  if ((v6 & 0x80) != 0)
  {
    if (!__maskrune((char)v6, 0x40000uLL)) {
      goto LABEL_17;
    }
  }
  else if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v6 + 60) & 0x40000) == 0)
  {
    goto LABEL_17;
  }
  unsigned int v8 = __str[1];
  if ((v8 & 0x80000000) != 0)
  {
    if (!__maskrune(v8, 0x40000uLL)) {
      goto LABEL_17;
    }
  }
  else if ((*(_DWORD *)(v7 + 4 * v8 + 60) & 0x40000) == 0)
  {
    goto LABEL_17;
  }
  unsigned int v9 = __str[2];
  if ((v9 & 0x80000000) != 0)
  {
    if (!__maskrune(v9, 0x40000uLL)) {
      goto LABEL_17;
    }
  }
  else if ((*(_DWORD *)(v7 + 4 * v9 + 60) & 0x40000) == 0)
  {
    goto LABEL_17;
  }
  unsigned int v10 = __str[3];
  if ((v10 & 0x80000000) != 0)
  {
    if (__maskrune(v10, 0x40000uLL)) {
      goto LABEL_15;
    }
LABEL_17:
    snprintf(__str, __size, "0x%08x", a1);
    return __str;
  }
  if ((*(_DWORD *)(v7 + 4 * v10 + 60) & 0x40000) == 0) {
    goto LABEL_17;
  }
LABEL_15:
  __str[4] = 0;
  return __str;
}

void CAFormatter::CAFormatter(CAFormatter *this, const AudioClassDescription *a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  Format4CC(a2->mType, v6, 0x10uLL);
  Format4CC(a2->mSubType, v5, 0x10uLL);
  Format4CC(a2->mManufacturer, v4, 0x10uLL);
  snprintf(__str, 0x30uLL, "%s/%s/%s", v6, v5, v4);
  CAFormatter::Init(this, __str);
}

void CAFormatter::CAFormatter(CAFormatter *this, OpaqueAudioConverter *a2)
{
}

{
  CAFormatter::InitCAShowable(this, (uint64_t)a2, "AudioConverterRef");
}

FILE *CAFormatter::InitCAShowable(CAFormatter *this, uint64_t a2, const char *__s)
{
  if (a2)
  {
    uint64_t result = CACopyObjectDescription(a2, 0);
    *(void *)this = result;
  }
  else
  {
    size_t v6 = strlen(__s) + 20;
    uint64_t v7 = (char *)malloc_type_malloc(v6, 0x409FA1A0uLL);
    *(void *)this = v7;
    return (FILE *)snprintf(v7, v6, "NULL %s", __s);
  }
  return result;
}

void CAFormatter::CAFormatter(CAFormatter *this, const AudioObjectPropertyAddress *a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  Format4CC(a2->mSelector, v6, 0x10uLL);
  Format4CC(a2->mScope, v5, 0x10uLL);
  Format4CC(a2->mElement, v4, 0x10uLL);
  snprintf(__str, 0x30uLL, "%s/%s/%s", v6, v5, v4);
  CAFormatter::Init(this, __str);
}

void CAFormatter::CAFormatter(CAFormatter *this, const AudioObjectPropertyAddress *a2, unsigned int *a3, int a4)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  unint64_t v19 = 0;
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  uint64_t v8 = funopen(&v18, 0, (int (__cdecl *)(void *, const char *, int))CAMemoryStream::Write, 0, 0);
  unsigned int v9 = v8;
  size_t v18 = v8;
  signed int mSelector = a2->mSelector;
  if ((int)a2->mSelector <= 1885762591)
  {
    if (mSelector == 1718839674)
    {
      fprintf(v8, "(UInt32)0x%x");
      goto LABEL_20;
    }
    if (mSelector == 1768845421) {
      goto LABEL_13;
    }
    if (mSelector != 1853059700) {
      goto LABEL_22;
    }
    fprintf(v8, "(Float64)%g");
    goto LABEL_20;
  }
  if (mSelector > 1936092531)
  {
    if (mSelector == 1936092532) {
      goto LABEL_14;
    }
    if (mSelector != 1987013741) {
      goto LABEL_22;
    }
    fprintf(v8, "(Float32)%g");
LABEL_20:
    uint64_t v13 = CAMemoryStream::cstr(&v18);
    unint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    *(void *)this = v13;
    goto LABEL_21;
  }
  if (mSelector != 1885762592)
  {
    if (mSelector != 1919120504)
    {
LABEL_22:
      if (a4 >= 1)
      {
        unsigned int v14 = a4 + 1;
        do
        {
          int v15 = *(unsigned __int8 *)a3;
          a3 = (unsigned int *)((char *)a3 + 1);
          fprintf(v9, "%02x", v15);
          --v14;
        }
        while (v14 > 1);
      }
      goto LABEL_20;
    }
LABEL_13:
    Format4CC(*a3, __str, 0xCuLL);
    fputs(__str, v9);
    goto LABEL_20;
  }
LABEL_14:
  int16x8_t v11 = *((int16x8_t *)a3 + 1);
  *(_OWORD *)__str = *(_OWORD *)a3;
  int16x8_t v23 = v11;
  uint64_t v24 = *((void *)a3 + 4);
  CA::StreamDescription::AsString((CA::StreamDescription *)__p, __str, *(double *)__str, v11);
  if (v17 >= 0) {
    uint64_t v12 = __p;
  }
  else {
    uint64_t v12 = (void **)__p[0];
  }
  CAFormatter::Init(this, (const char *)v12);
  if (v17 < 0) {
    operator delete(__p[0]);
  }
LABEL_21:
  fclose(v18);
  free(v19);
}

void sub_1901ABF30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, FILE *a16, void *a17)
{
}

uint64_t CAFormatter::DumpAudioBuffer(FILE *this, __sFILE *a2, const char *a3, const AudioBuffer *a4, int a5, int a6, int a7)
{
  int v10 = (int)a4;
  fprintf(this, "%s%5dbytes %dch @ %p", (const char *)a2, *((_DWORD *)a3 + 1), *(_DWORD *)a3, *((const void **)a3 + 1));
  if (a5 >= v10) {
    a5 = v10;
  }
  if (a5)
  {
    if (*((void *)a3 + 1))
    {
      fputc(58, this);
      int v13 = *(_DWORD *)a3 * a5;
      if (v13 >= 1)
      {
        unsigned int v14 = (unsigned __int8 *)*((void *)a3 + 1);
        if (a7) {
          int v15 = " %06X";
        }
        else {
          int v15 = " %8d";
        }
        if (a7) {
          uint64_t v16 = " %02X";
        }
        else {
          uint64_t v16 = " %4d";
        }
        unsigned int v17 = v13 + 1;
        int v18 = a6 + 10;
        do
        {
          switch(v18)
          {
            case 0:
            case 10:
              v14 += 4;
              goto LABEL_28;
            case 6:
              v14 += 4;
              goto LABEL_26;
            case 7:
              int v20 = (v14[2] << 16) | (v14[1] << 8);
              unsigned int v21 = *v14;
              goto LABEL_24;
            case 8:
              if (!a7) {
                goto LABEL_19;
              }
              goto LABEL_21;
            case 9:
            case 11:
              unsigned int v19 = *v14++;
              fprintf(this, v16, v19);
              break;
            case 12:
              if (a7) {
LABEL_21:
              }
                fprintf(this, " %04X");
              else {
LABEL_19:
              }
                fprintf(this, " %6d");
              v14 += 2;
              break;
            case 13:
              int v20 = (*v14 << 16) | (v14[1] << 8);
              unsigned int v21 = v14[2];
LABEL_24:
              fprintf(this, v15, v20 | v21);
              v14 += 3;
              break;
            case 14:
              v14 += 4;
LABEL_26:
              fprintf(this, " %08X");
              break;
            case 20:
              v14 += 4;
LABEL_28:
              fprintf(this, " %6.3f");
              break;
            default:
              break;
          }
          --v17;
        }
        while (v17 > 1);
      }
    }
  }
  return fputc(10, this);
}

uint64_t CAFormatter::DumpAudio(FILE *this, __sFILE *a2, const AudioBuffer *a3, int a4, int a5, const char *a6, const char *a7, const char *a8, const char *a9)
{
  int v9 = (int)a7;
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  int v15 = "AudioBufferList";
  uint64_t v16 = ", ";
  if (a6) {
    int v15 = a6;
  }
  unsigned int v17 = "";
  if (a8) {
    unsigned int v17 = a8;
  }
  else {
    uint64_t v16 = "";
  }
  uint64_t result = fprintf(this, "%s@%p (%d fr%s%s):\n", v15, a2, a3, v16, v17);
  if (LODWORD(a2->_p))
  {
    unint64_t v19 = 0;
    p_r = &a2->_r;
    do
    {
      snprintf(__str, 0x20uLL, "    [%2d] ", v19);
      uint64_t result = CAFormatter::DumpAudioBuffer(this, (__sFILE *)__str, (const char *)p_r, a3, a4, a5, v9);
      ++v19;
      p_r += 4;
    }
    while (v19 < LODWORD(a2->_p));
  }
  return result;
}

void CAFormatter::CAFormatter(CAFormatter *this, __sFILE *a2, const AudioBuffer *a3, AudioStreamBasicDescription *a4, const char *a5, const char *a6)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  int v17 = 0;
  AudioFormatString(a4, __dst, 0x50uLL, &v17);
  unsigned int v14 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  int16x8_t v11 = funopen(&v13, 0, (int (__cdecl *)(void *, const char *, int))CAMemoryStream::Write, 0, 0);
  CAFormatter::DumpAudio(v11, a2, a3, 8, v17, a5, a6, __dst, (const char *)v11);
  uint64_t v12 = CAMemoryStream::cstr(&v13);
  unsigned int v14 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  *(void *)this = v12;
  fclose(v13);
  free(v14);
}

void sub_1901AC438(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, FILE *a9, void *a10)
{
}

_DWORD *AudioFormatString(_DWORD *result, char *__dst, size_t __size, int *a4)
{
  int v4 = result[2];
  int v5 = result[3];
  unsigned int v6 = result[6];
  unsigned int v7 = result[7];
  int v8 = result[8];
  *a4 = 1;
  void *__dst = 0;
  if (v4 == 1819304813)
  {
    if (v5)
    {
      if (v8 == 32)
      {
        if ((v5 & 2) != 0)
        {
          *a4 = 10;
          uint64_t v12 = "BEF";
        }
        else
        {
          *a4 = -10;
          uint64_t v12 = "LEF";
        }
        return (_DWORD *)strlcpy(__dst, v12, __size);
      }
    }
    else
    {
      if (!v6)
      {
LABEL_6:
        *a4 = 0;
        return result;
      }
      if ((v5 & 0x20) != 0)
      {
        unsigned int v7 = 1;
      }
      else if (!v7)
      {
        goto LABEL_6;
      }
      int v13 = v6 / v7;
      *a4 = v13;
      if (v13 >= 1)
      {
        if (((result[3] >> 7) & 0x3F) != 0) {
          snprintf(__dst, __size, "%d.%d-bit");
        }
        else {
          snprintf(__dst, __size, "%d-bit");
        }
        if ((v5 & 2) != 0)
        {
          unsigned int v14 = " BEI";
        }
        else
        {
          *a4 = -*a4;
          unsigned int v14 = " LEI";
        }
        return (_DWORD *)strlcat(__dst, v14, __size);
      }
    }
  }
  return result;
}

void CAFormatter::CAFormatter(CAFormatter *this, const AudioBufferList *a2, unsigned int a3, const AudioStreamBasicDescription *a4, const char *a5, int a6)
{
  *(void *)(&__str._ub._size + 1) = *MEMORY[0x1E4F143B8];
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  int v10 = funopen(&v34, 0, (int (__cdecl *)(void *, const char *, int))CAMemoryStream::Write, 0, 0);
  int16x8_t v11 = v10;
  int v34 = v10;
  uint64_t v12 = "AudioBufferList";
  if (a5) {
    uint64_t v12 = a5;
  }
  fprintf(v10, "%s@%p:\n", v12, a2);
  if (a3)
  {
    uint64_t v13 = 0;
    unsigned int v14 = 0;
    uint64_t v28 = a3;
    BOOL v27 = a4;
    while (1)
    {
      uint64_t v15 = (AudioStreamBasicDescription *)&a4[v13];
      if ((v15->mFormatFlags & 0x20) == 0) {
        break;
      }
      uint64_t mChannelsPerFrame = a4[v13].mChannelsPerFrame;
      if (mChannelsPerFrame) {
        goto LABEL_8;
      }
LABEL_15:
      v14 += mChannelsPerFrame;
      if (++v13 == v28) {
        goto LABEL_16;
      }
    }
    uint64_t mChannelsPerFrame = 1;
LABEL_8:
    uint64_t v17 = 0;
    int v18 = &a4[v13];
    p_UInt32 mBytesPerFrame = &v18->mBytesPerFrame;
    uint64_t v30 = v13;
    p_mBytesPerPacket = &v18->mBytesPerPacket;
    uint64_t v20 = v14;
    unsigned int v29 = v14;
    unsigned int v21 = &a2->mBuffers[v14];
    do
    {
      if (v20 + v17 >= (unint64_t)a2->mNumberBuffers) {
        break;
      }
      int v33 = 0;
      AudioFormatString(v15, (char *)&__str._cookie + 2, 0x32uLL, &v33);
      UInt32 v22 = *p_mBytesPerFrame;
      if (*p_mBytesPerFrame)
      {
        int v23 = v33;
      }
      else
      {
        UInt32 v22 = *p_mBytesPerPacket;
        int v23 = 4;
      }
      uint64_t v24 = (const AudioBuffer *)(v21->mDataByteSize / v22);
      snprintf((char *)&__str, 0x32uLL, "    [%2d] %-12.12s %5dfr ", v20 + v17, (const char *)&__str._cookie + 2, v21->mDataByteSize / v22);
      CAFormatter::DumpAudioBuffer(v11, &__str, (const char *)v21, v24, 8, v23, a6);
      ++v17;
      ++v21;
    }
    while (mChannelsPerFrame != v17);
    a4 = v27;
    uint64_t v13 = v30;
    unsigned int v14 = v29;
    goto LABEL_15;
  }
LABEL_16:
  uint64_t v25 = CAMemoryStream::cstr(&v34);
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  *(void *)this = v25;
  fclose(v34);
  free(v35);
}

void sub_1901AC808(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, FILE *a20,void *a21)
{
}

void CAFormatter::CAFormatter(CAFormatter *this, const AudioBufferList *a2)
{
  int16x8_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  int v4 = funopen(&v10, 0, (int (__cdecl *)(void *, const char *, int))CAMemoryStream::Write, 0, 0);
  int v5 = v4;
  int v10 = v4;
  unsigned int v6 = "";
  if (a2->mNumberBuffers > 1) {
    unsigned int v6 = "s";
  }
  fprintf(v4, "%d buffer%s: ", a2->mNumberBuffers, v6);
  if (a2->mNumberBuffers)
  {
    unint64_t v7 = 0;
    p_mData = &a2->mBuffers[0].mData;
    do
    {
      if (v7) {
        fwrite("; ", 2uLL, 1uLL, v5);
      }
      fprintf(v5, "%p-%p (%d)", *p_mData, (char *)*p_mData + *((unsigned int *)p_mData - 1), *((_DWORD *)p_mData - 1));
      ++v7;
      p_mData += 2;
    }
    while (v7 < a2->mNumberBuffers);
  }
  int v9 = CAMemoryStream::cstr(&v10);
  int16x8_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  *(void *)this = v9;
  fclose(v10);
  free(v11);
}

void sub_1901AC974(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, FILE *a13, void *a14)
{
}

void CAFormatter::CAFormatter(CAFormatter *this, const AudioStreamPacketDescription *a2, int a3, int a4)
{
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  int v8 = funopen(&v15, 0, (int (__cdecl *)(void *, const char *, int))CAMemoryStream::Write, 0, 0);
  int v9 = v8;
  uint64_t v15 = v8;
  if (a2)
  {
    int v10 = "";
    if (a3 > 1) {
      int v10 = "s";
    }
    fprintf(v8, "%d packet desc%s:\n", a3, v10);
    if (a3 <= a4 || a4 <= 0) {
      int v12 = a3;
    }
    else {
      int v12 = a4;
    }
    if (v12 >= 1)
    {
      for (int i = 0; i != v12; ++i)
      {
        fprintf(v9, "  [%2d] byte offsets %d - %d (%d)", i, a2->mStartOffset, a2->mDataByteSize + a2->mStartOffset, a2->mDataByteSize);
        if (a2->mVariableFramesInPacket) {
          fprintf(v9, "; %d fr\n", a2->mVariableFramesInPacket);
        }
        else {
          fputc(10, v9);
        }
        ++a2;
      }
    }
  }
  else
  {
    fwrite("packet descs NULL\n", 0x12uLL, 1uLL, v8);
  }
  unsigned int v14 = CAMemoryStream::cstr(&v15);
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  *(void *)this = v14;
  fclose(v15);
  free(v16);
}

void sub_1901ACB10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, FILE *a13, void *a14)
{
}

void CAAUScopeElementFormatter::CAAUScopeElementFormatter(CAAUScopeElementFormatter *this, unsigned int a2, int a3)
{
  *(void *)this = 0;
  unsigned int v6 = (char *)malloc_type_malloc(0x40uLL, 0x409FA1A0uLL);
  *(void *)this = v6;
  if (!(a3 | a2)) {
    strcpy(v6, "Global scope");
  }
  if (a2 > 5) {
    snprintf(v6, 0x40uLL, "scope %d, element %d");
  }
  else {
    snprintf(v6, 0x40uLL, "%s scope, element %d");
  }
}

void sub_1901ACBDC(_Unwind_Exception *exception_object)
{
  if (*v1) {
    free(*v1);
  }
  _Unwind_Resume(exception_object);
}

void CAHexDumpFormatter::CAHexDumpFormatter(CAHexDumpFormatter *this, unsigned __int8 *a2, int a3)
{
  *(void *)this = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  int v5 = funopen(&v14, 0, (int (__cdecl *)(void *, const char *, int))CAMemoryStream::Write, 0, 0);
  unsigned int v14 = v5;
  if (a3 >= 1)
  {
    if (a3 >= 1024) {
      int v6 = 1024;
    }
    else {
      int v6 = a3;
    }
    do
    {
      if (v6 >= 16) {
        unint64_t v7 = 16;
      }
      else {
        unint64_t v7 = v6;
      }
      fprintf(v5, "%08lX:  ", a2);
      for (unint64_t i = 0; i != 16; ++i)
      {
        if (i >= v7) {
          fwrite("   ", 3uLL, 1uLL, v5);
        }
        else {
          fprintf(v5, "%02X ", a2[i]);
        }
      }
      for (unint64_t j = 0; j != 16; ++j)
      {
        if (j >= v7)
        {
          int v10 = 32;
        }
        else if (a2[j] - 32 >= 0x5F)
        {
          int v10 = 46;
        }
        else
        {
          int v10 = a2[j];
        }
        fputc(v10, v5);
      }
      fputc(10, v5);
      a2 += 16;
      BOOL v11 = __OFSUB__(v6, 16);
      v6 -= 16;
    }
    while (!((v6 < 0) ^ v11 | (v6 == 0)));
  }
  int v12 = CAMemoryStream::cstr(&v14);
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  *(void *)this = v12;
  fclose(v14);
  free(v15);
}

void sub_1901ACD90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, FILE *a11, void *a12)
{
  if (*a10) {
    free(*a10);
  }
  _Unwind_Resume(a1);
}

void sub_1901ACF1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1901AD014(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1901AD0FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, objc_super a10, uint64_t a11, uint64_t a12, char a13)
{
}

void sub_1901AD43C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,id location)
{
  _Block_object_dispose(&a15, 8);
  objc_destroyWeak(&location);

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__15067(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__15068(uint64_t a1)
{
}

void sub_1901AD53C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

unint64_t DSPGraph::Graph::getPropertyInfo(DSPGraph::Graph *this, unsigned int a2)
{
  uint64_t v2 = std::__hash_table<std::__hash_value_type<unsigned int,DSPGraph::AnalyzerBuilder::Info>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,DSPGraph::AnalyzerBuilder::Info>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,DSPGraph::AnalyzerBuilder::Info>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,DSPGraph::AnalyzerBuilder::Info>>>::find<unsigned int>((void *)this + 70, a2);
  if (v2)
  {
    uint64_t v3 = (unsigned int *)v2[9];
    if ((unsigned int *)v2[10] == v3)
    {
      unint64_t v5 = 0;
      uint64_t v6 = 1969451041;
    }
    else
    {
      uint64_t v4 = (*(uint64_t (**)(void, void, void, void))(**(void **)v3 + 296))(*(void *)v3, v3[2], v3[3], v3[4]);
      unint64_t v5 = v4 & 0xFFFFFFFF00000000;
      uint64_t v6 = v4;
    }
  }
  else
  {
    unint64_t v5 = 0;
    uint64_t v6 = 1852204065;
  }
  return v5 | v6;
}

uint64_t DSPGraph::Graph::print(uint64_t result, void *a2, int a3, uint64_t a4)
{
  if (a3 >= 1)
  {
    int v4 = a4;
    (*(void (**)(uint64_t, void *, uint64_t, uint64_t))(*(void *)result + 32))(result, a2, a4, 1);
    DSPGraph::printi(a2, v4 + 4, "initialized %d\n");
  }
  return result;
}

const char *DSPGraph::Graph::ClassName(DSPGraph::Graph *this)
{
  return "Graph";
}

void DSPGraph::Graph::~Graph(DSPGraph::Graph *this)
{
  DSPGraph::Graph::~Graph(this);
  JUMPOUT(0x192FC8940);
}

{
  uint64_t **i;
  void *j;
  uint64_t v4;
  void *v5;
  void *v6;
  uint64_t v7;
  uint64_t k;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void **v14;

  *(void *)this = &unk_1EDF9CAC8;
  DSPGraph::Graph::uninitialize(this);
  DSPGraph::Graph::unconfigure(this);
  for (unint64_t i = (uint64_t **)*((void *)this + 3); i; unint64_t i = (uint64_t **)*i)
    (*(void (**)(uint64_t *))(*i[2] + 568))(i[2]);
  for (unint64_t j = (void *)*((void *)this + 8); j; unint64_t j = (void *)*j)
  {
    int v4 = j[2];
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
  }
  if (*((void *)this + 9))
  {
    unint64_t v5 = (void *)*((void *)this + 8);
    if (v5)
    {
      do
      {
        uint64_t v6 = (void *)*v5;
        operator delete(v5);
        unint64_t v5 = v6;
      }
      while (v6);
    }
    *((void *)this + 8) = 0;
    unint64_t v7 = *((void *)this + 7);
    if (v7)
    {
      for (uint64_t k = 0; k != v7; ++k)
        *(void *)(*((void *)this + 6) + 8 * k) = 0;
    }
    *((void *)this + 9) = 0;
  }
  std::__hash_table<std::__hash_value_type<std::string,DSPGraph::Graph::profiler_t>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,DSPGraph::Graph::profiler_t>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,DSPGraph::Graph::profiler_t>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,DSPGraph::Graph::profiler_t>>>::~__hash_table((uint64_t)this + 1056);
  std::__function::__value_func<void ()(double)>::~__value_func[abi:ne180100]((void *)this + 128);
  std::unique_ptr<DSPGraph::Graph::profiler_t>::reset[abi:ne180100]((uint64_t *)this + 127, 0);
  unsigned int v14 = (void **)((char *)this + 992);
  std::vector<DSPGraph::Graph::GraphBridge>::__destroy_vector::operator()[abi:ne180100](&v14);
  *((void *)this + 118) = &unk_1EDF98450;
  std::__hash_table<std::__hash_value_type<unsigned int,DSPGraph::AnalyzerBuilder::Info>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,DSPGraph::AnalyzerBuilder::Info>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,DSPGraph::AnalyzerBuilder::Info>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,DSPGraph::AnalyzerBuilder::Info>>>::~__hash_table((uint64_t)this + 952);
  unsigned int v14 = (void **)((char *)this + 904);
  std::vector<std::unique_ptr<DSPGraph::Subset>>::__destroy_vector::operator()[abi:ne180100](&v14);
  std::__hash_table<std::__hash_value_type<std::string,DSPGraph::Box *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,DSPGraph::Box *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,DSPGraph::Box *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,DSPGraph::Box *>>>::~__hash_table((uint64_t)this + 784);
  std::unique_ptr<DSPGraph::RenderObserverList<DSPGraph::Graph>>::reset[abi:ne180100]((uint64_t *)this + 85, 0);
  std::__hash_table<std::__hash_value_type<std::string,DSPGraph::Box *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,DSPGraph::Box *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,DSPGraph::Box *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,DSPGraph::Box *>>>::~__hash_table((uint64_t)this + 640);
  std::__hash_table<std::__hash_value_type<std::string,DSPGraph::Box *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,DSPGraph::Box *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,DSPGraph::Box *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,DSPGraph::Box *>>>::~__hash_table((uint64_t)this + 600);
  std::__hash_table<std::__hash_value_type<unsigned int,DSPGraph::Graph::GraphProperty>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,DSPGraph::Graph::GraphProperty>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,DSPGraph::Graph::GraphProperty>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,DSPGraph::Graph::GraphProperty>>>::~__hash_table((uint64_t)this + 560);
  std::__hash_table<std::__hash_value_type<unsigned int,DSPGraph::Graph::GraphParameter>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,DSPGraph::Graph::GraphParameter>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,DSPGraph::Graph::GraphParameter>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,DSPGraph::Graph::GraphParameter>>>::~__hash_table((uint64_t)this + 520);
  int v9 = (void *)*((void *)this + 62);
  if (v9)
  {
    *((void *)this + 63) = v9;
    operator delete(v9);
  }
  int v10 = (void *)*((void *)this + 59);
  if (v10)
  {
    *((void *)this + 60) = v10;
    operator delete(v10);
  }
  if (*((char *)this + 455) < 0) {
    operator delete(*((void **)this + 54));
  }
  if (*((char *)this + 431) < 0) {
    operator delete(*((void **)this + 51));
  }
  BOOL v11 = (void *)*((void *)this + 38);
  if (v11)
  {
    *((void *)this + 39) = v11;
    operator delete(v11);
  }
  int v12 = (void *)*((void *)this + 35);
  if (v12)
  {
    *((void *)this + 3std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = v12;
    operator delete(v12);
  }
  uint64_t v13 = (void *)*((void *)this + 32);
  if (v13)
  {
    *((void *)this + 33) = v13;
    operator delete(v13);
  }
  std::__hash_table<std::unique_ptr<DSPGraph::IsoGroup>,std::hash<std::unique_ptr<DSPGraph::IsoGroup>>,std::equal_to<std::unique_ptr<DSPGraph::IsoGroup>>,std::allocator<std::unique_ptr<DSPGraph::IsoGroup>>>::~__hash_table((uint64_t)this + 216);
  unsigned int v14 = (void **)((char *)this + 192);
  std::vector<std::unique_ptr<DSPGraph::InternalBuffer>>::__destroy_vector::operator()[abi:ne180100](&v14);
  std::mutex::~mutex((std::mutex *)this + 2);
  std::__hash_table<std::unique_ptr<DSPGraph::Box>,std::hash<std::unique_ptr<DSPGraph::Box>>,std::equal_to<std::unique_ptr<DSPGraph::Box>>,std::allocator<std::unique_ptr<DSPGraph::Box>>>::~__hash_table((uint64_t)this + 8);
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,DSPGraph::Graph::profiler_t>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,DSPGraph::Graph::profiler_t>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,DSPGraph::Graph::profiler_t>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,DSPGraph::Graph::profiler_t>>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,DSPGraph::Graph::profiler_t>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  int v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

uint64_t *std::unique_ptr<DSPGraph::Graph::profiler_t>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  *uint64_t result = a2;
  if (v2)
  {
    boost::circular_buffer<double,std::allocator<double>>::destroy(v2);
    JUMPOUT(0x192FC8940);
  }
  return result;
}

void std::vector<DSPGraph::Graph::GraphBridge>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    unint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 56;
        std::__destroy_at[abi:ne180100]<DSPGraph::Graph::GraphBridge,0>(v4);
      }
      while ((void *)v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<std::unique_ptr<DSPGraph::Subset>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = *--v4;
        uint64_t v6 = v7;
        *uint64_t v4 = 0;
        if (v7) {
          std::default_delete<DSPGraph::Subset>::operator()[abi:ne180100](v6);
        }
      }
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,DSPGraph::Box *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,DSPGraph::Box *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,DSPGraph::Box *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,DSPGraph::Box *>>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void **)*v2;
      if (*((char *)v2 + 39) < 0) {
        operator delete(v2[2]);
      }
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned int,DSPGraph::Graph::GraphProperty>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,DSPGraph::Graph::GraphProperty>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,DSPGraph::Graph::GraphProperty>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,DSPGraph::Graph::GraphProperty>>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      std::__destroy_at[abi:ne180100]<std::pair<unsigned int const,DSPGraph::Graph::GraphProperty>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned int,DSPGraph::Graph::GraphParameter>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,DSPGraph::Graph::GraphParameter>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,DSPGraph::Graph::GraphParameter>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,DSPGraph::Graph::GraphParameter>>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      uint64_t v4 = (void *)v2[5];
      if (v4)
      {
        v2[6] = v4;
        operator delete(v4);
      }
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  unint64_t v5 = *(void **)a1;
  *(void *)a1 = 0;
  if (v5) {
    operator delete(v5);
  }
  return a1;
}

uint64_t std::__hash_table<std::unique_ptr<DSPGraph::IsoGroup>,std::hash<std::unique_ptr<DSPGraph::IsoGroup>>,std::equal_to<std::unique_ptr<DSPGraph::IsoGroup>>,std::allocator<std::unique_ptr<DSPGraph::IsoGroup>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::unique_ptr<DSPGraph::IsoGroup>,std::hash<std::unique_ptr<DSPGraph::IsoGroup>>,std::equal_to<std::unique_ptr<DSPGraph::IsoGroup>>,std::allocator<std::unique_ptr<DSPGraph::IsoGroup>>>::__deallocate_node(*(void **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::vector<std::unique_ptr<DSPGraph::InternalBuffer>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<std::unique_ptr<DSPGraph::InternalBuffer>>::__clear[abi:ne180100](v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

uint64_t std::__hash_table<std::unique_ptr<DSPGraph::Box>,std::hash<std::unique_ptr<DSPGraph::Box>>,std::equal_to<std::unique_ptr<DSPGraph::Box>>,std::allocator<std::unique_ptr<DSPGraph::Box>>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      uint64_t v4 = v2[2];
      v2[2] = 0;
      if (v4) {
        (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
      }
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  unint64_t v5 = *(void **)a1;
  *(void *)a1 = 0;
  if (v5) {
    operator delete(v5);
  }
  return a1;
}

void std::__destroy_at[abi:ne180100]<std::pair<unsigned int const,DSPGraph::Graph::GraphProperty>,0>(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 56);
  if (v2)
  {
    *(void *)(a1 + 64) = v2;
    operator delete(v2);
  }
  if (*(unsigned char *)(a1 + 40))
  {
    uint64_t v3 = *(void **)(a1 + 16);
    if (v3)
    {
      *(void *)(a1 + 24) = v3;
      operator delete(v3);
    }
  }
}

uint64_t caulk::concurrent::lf_read_synchronized_write<std::vector<DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver,std::allocator<DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver>>>::~lf_read_synchronized_write(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8))
  {
    uint64_t v3 = (void **)(a1 + 16);
    std::vector<DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver,std::allocator<DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver>>::__destroy_vector::operator()[abi:ne180100](&v3);
  }
  if (*(unsigned char *)(a1 + 9))
  {
    uint64_t v3 = (void **)(a1 + 40);
    std::vector<DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver,std::allocator<DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver>>::__destroy_vector::operator()[abi:ne180100](&v3);
  }
  return a1;
}

void std::vector<DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver,std::allocator<DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v6 = v4 - 48;
        std::__function::__value_func<void ()(DSPGraph::Graph *,unsigned int)>::~__value_func[abi:ne180100]((void *)v4 - 5);
        uint64_t v4 = v6;
      }
      while (v6 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::default_delete<DSPGraph::Subset>::operator()[abi:ne180100](uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  JUMPOUT(0x192FC8940);
}

void std::__destroy_at[abi:ne180100]<DSPGraph::Graph::GraphBridge,0>(uint64_t a1)
{
  uint64_t v3 = (void **)(a1 + 32);
  std::vector<DSPGraph::Graph::GraphBridge::BridgedProperty>::__destroy_vector::operator()[abi:ne180100](&v3);
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 1std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = v2;
    operator delete(v2);
  }
}

void std::vector<DSPGraph::Graph::GraphBridge::BridgedProperty>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<DSPGraph::Graph::GraphBridge::BridgedProperty>::__clear[abi:ne180100]((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<DSPGraph::Graph::GraphBridge::BridgedProperty>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 32)
  {
    uint64_t v4 = *(void **)(i - 24);
    if (v4)
    {
      *(void *)(i - 1std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = v4;
      operator delete(v4);
    }
  }
  a1[1] = v2;
}

void boost::circular_buffer<double,std::allocator<double>>::destroy(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 32);
  unint64_t v5 = *(void **)a1;
  uint64_t v6 = v3 - v2;
  unint64_t v7 = (unint64_t)(v3 - (void)v5) >> 3;
  if (v4 < v6 >> 3) {
    unint64_t v7 = 0;
  }
  *(void *)(a1 + 1std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = v2 + 8 * (v4 - v7);
  if (v5) {
    operator delete(v5);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string const,DSPGraph::Graph::profiler_t>,0>(uint64_t a1)
{
  boost::circular_buffer<double,std::allocator<double>>::destroy(a1 + 24);
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

std::random_device *std::random_device::random_device[abi:ne180100](std::random_device *a1)
{
  std::string::basic_string[abi:ne180100]<0>(&__token, "/dev/urandom");
  std::random_device::random_device(a1, &__token);
  if (SHIBYTE(__token.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__token.__r_.__value_.__l.__data_);
  }
  return a1;
}

void sub_1901AE7A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

unint64_t DSPGraph::intPtrHash(DSPGraph *this)
{
  unint64_t v1 = ((unint64_t)this + ~((void)this << 32)) ^ (((unint64_t)this + ~((void)this << 32)) >> 22);
  unint64_t v2 = 9 * ((v1 + ~(v1 << 13)) ^ ((v1 + ~(v1 << 13)) >> 8));
  unint64_t v3 = (v2 ^ (v2 >> 15)) + ~((v2 ^ (v2 >> 15)) << 27);
  return v3 ^ (v3 >> 31);
}

const char *DSPGraph::InternalBuffer::ClassName(DSPGraph::InternalBuffer *this)
{
  return "InternalBuffer";
}

void *DSPGraph::Graph::processInPlace(DSPGraph::Graph *this, uint64_t a2)
{
  if (!*((unsigned char *)this + 762))
  {
    std::string::basic_string[abi:ne180100]<0>(&v8, "/Library/Caches/com.apple.xbs/Sources/CoreAudioServices_AudioToolboxCore/CoreAudioUtility/Source/CADSP/DSPGraph/DSPGraph_Graph.cpp");
    std::string::basic_string[abi:ne180100]<0>(&v7, "processInPlace");
    std::string::basic_string[abi:ne180100]<0>(&v6, "not initialized");
    DSPGraph::ThrowException(1768843553, &v8, 556, &v7, &v6);
  }
  if (((*((void *)this + 36) - *((void *)this + 35)) & 0x7FFFFFFF8) != 8
    || ((*((void *)this + 39) - *((void *)this + 38)) & 0x7FFFFFFF8) != 8)
  {
    std::string::basic_string[abi:ne180100]<0>(&v8, "/Library/Caches/com.apple.xbs/Sources/CoreAudioServices_AudioToolboxCore/CoreAudioUtility/Source/CADSP/DSPGraph/DSPGraph_Graph.cpp");
    std::string::basic_string[abi:ne180100]<0>(&v7, "processInPlace");
    std::string::basic_string[abi:ne180100]<0>(&v6, "graph must have one input and one output to process in-place.");
    DSPGraph::ThrowException(1768975393, &v8, 560, &v7, &v6);
  }
  *(void *)(DSPGraph::Graph::in(this, 0) + 848) = a2;
  *(void *)(DSPGraph::Graph::out(this, 0) + 848) = a2;
  if (*((unsigned char *)this + 764))
  {
    for (uint64_t i = (void *)*((void *)this + 8); i; uint64_t i = (void *)*i)
      DSPGraph::SimpleABL::set(*(void *)(i[2] + 56) + 80, *(AudioBufferList **)(a2 + 72));
  }
  DSPGraph::Graph::checkCurSliceTicks((uint64_t)this, (unsigned int *)a2, (unsigned int *)a2);
  DSPGraph::Graph::processAll(this);
  return DSPGraph::Graph::propagateFlagsAndTimeStamp(this, a2);
}

void sub_1901AE9CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  _Unwind_Resume(exception_object);
}

uint64_t DSPGraph::Graph::addRenderCallback(uint64_t a1, uint64_t a2, unsigned int a3, signed int a4)
{
  uint64_t v85 = *MEMORY[0x1E4F143B8];
  long long v6 = *(os_unfair_lock_s **)(a1 + 680);
  std::__function::__value_func<void ()(DSPGraph::Graph *,unsigned int)>::__value_func[abi:ne180100]((uint64_t)v72, a2);
  unsigned int add = atomic_fetch_add(DSPGraph::RenderObserverList<DSPGraph::Graph>::add(std::function<void ()(DSPGraph::Graph*,unsigned int)>,DSPGraph::RenderCallbackType,DSPGraph::RenderCallbackOrder)::sToken, 1u);
  std::__function::__value_func<void ()(DSPGraph::Graph *,unsigned int)>::__value_func[abi:ne180100]((uint64_t)v73, (uint64_t)v72);
  unsigned int v74 = add + 1;
  std::__function::__value_func<void ()(DSPGraph::Graph *,unsigned int)>::__value_func[abi:ne180100]((uint64_t)v75, (uint64_t)v73);
  unint64_t v76 = __PAIR64__(a4, a3);
  std::__function::__value_func<void ()(DSPGraph::Graph *,unsigned int)>::~__value_func[abi:ne180100](v73);
  if (a3) {
    long long v8 = v6 + 16;
  }
  else {
    long long v8 = v6;
  }
  v68[0] = (uint64_t)v8;
  v68[1] = 0;
  v68[2] = (uint64_t)&v8[1];
  char v69 = 1;
  os_unfair_lock_lock(v8 + 1);
  int v70 = caulk::concurrent::details::lf_read_sync_write_impl::begin_mutate((caulk::concurrent::details::lf_read_sync_write_impl *)v8);
  BOOL v71 = v70 == 0;
  int v9 = caulk::concurrent::lf_read_synchronized_write<std::vector<DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver,std::allocator<DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver>>>::mutator::copy_previous(v68);
  int v10 = v9;
  uint64_t v12 = *v9;
  BOOL v11 = (char *)v9[1];
  uint64_t v13 = (uint64_t)&v11[-*v9];
  if (v11 == (char *)*v9)
  {
    uint64_t v15 = v9[1];
  }
  else
  {
    unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * (v13 >> 4);
    uint64_t v15 = *v9;
    do
    {
      unint64_t v16 = v14 >> 1;
      unint64_t v17 = v15 + 48 * (v14 >> 1);
      int v18 = *(_DWORD *)(v17 + 44);
      uint64_t v19 = v17 + 48;
      v14 += ~(v14 >> 1);
      if (v18 > a4) {
        unint64_t v14 = v16;
      }
      else {
        uint64_t v15 = v19;
      }
    }
    while (v14);
  }
  uint64_t v20 = (v15 - v12) / 48;
  unsigned int v21 = (char *)(v12 + 48 * v20);
  unint64_t v22 = v9[2];
  if ((unint64_t)v11 >= v22)
  {
    unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * (v13 >> 4) + 1;
    if (v27 > 0x555555555555555) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v28 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v22 - v12) >> 4);
    if (2 * v28 > v27) {
      unint64_t v27 = 2 * v28;
    }
    if (v28 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v29 = 0x555555555555555;
    }
    else {
      unint64_t v29 = v27;
    }
    size_t v80 = v10 + 2;
    if (v29) {
      unint64_t v29 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<AudioFormatListItem>>(v29);
    }
    else {
      uint64_t v30 = 0;
    }
    uint64_t v31 = v29 + 48 * v20;
    unint64_t v77 = v29;
    *(void *)&long long v78 = v31;
    *((void *)&v78 + 1) = v31;
    unint64_t v79 = v29 + 48 * v30;
    uint64_t v67 = (v15 - v12) / 48;
    if (v20 == v30)
    {
      if (v15 - v12 < 1)
      {
        if (v15 == v12) {
          unint64_t v41 = 1;
        }
        else {
          unint64_t v41 = 2 * v20;
        }
        BOOL v84 = v10 + 2;
        unsigned int v42 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<AudioFormatListItem>>(v41);
        unsigned int v43 = v42;
        int v44 = &v42[48 * (v41 >> 2)];
        int v46 = &v42[48 * v45];
        if (*((void *)&v78 + 1) == (void)v78)
        {
          int64x2_t v52 = vdupq_n_s64(v78);
          unsigned int v47 = &v42[48 * (v41 >> 2)];
        }
        else
        {
          unsigned int v47 = &v44[*((void *)&v78 + 1) - v78];
          uint64_t v48 = (uint64_t)&v42[48 * (v41 >> 2) + 8];
          uint64_t v49 = v78 + 8;
          do
          {
            *(_DWORD *)(v48 - 8) = *(_DWORD *)(v49 - 8);
            uint64_t v50 = std::__function::__value_func<void ()(DSPGraph::Graph *,unsigned int)>::__value_func[abi:ne180100](v48, v49);
            *(void *)(v50 + 32) = *(void *)(v49 + 32);
            uint64_t v51 = v50 + 40;
            uint64_t v48 = v50 + 48;
            v49 += 48;
          }
          while ((char *)v51 != v47);
          int64x2_t v52 = (int64x2_t)v78;
        }
        unint64_t v53 = v77;
        uint64_t v54 = (unint64_t *)v79;
        unint64_t v77 = (unint64_t)v43;
        *(void *)&long long v78 = v44;
        int64x2_t v82 = v52;
        *((void *)&v78 + 1) = v47;
        unint64_t v79 = (unint64_t)v46;
        unint64_t v81 = v53;
        unsigned int v83 = v54;
        std::__split_buffer<DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver,std::allocator<DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver> &>::~__split_buffer((uint64_t)&v81);
        uint64_t v31 = *((void *)&v78 + 1);
      }
      else
      {
        uint64_t v32 = v20 + 2;
        if (v20 >= -1) {
          uint64_t v32 = v20 + 1;
        }
        uint64_t v33 = -3 * (v32 >> 1);
        uint64_t v31 = std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver *,DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver *,DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver *>(v29 + 48 * v20, v31, v31 - 48 * (v32 >> 1));
        *(void *)&long long v78 = v78 + 16 * v33;
        *((void *)&v78 + 1) = v31;
      }
    }
    *(_DWORD *)uint64_t v31 = v74;
    std::__function::__value_func<void ()(DSPGraph::Graph *,unsigned int)>::__value_func[abi:ne180100](v31 + 8, (uint64_t)v75);
    *(void *)(v31 + 40) = v76;
    uint64_t v55 = v78;
    uint64_t v56 = *((void *)&v78 + 1) + 48;
    *((void *)&v78 + 1) += 48;
    char v57 = (char *)*v10;
    if ((char *)*v10 != v21)
    {
      uint64_t v58 = 0;
      do
      {
        *(_DWORD *)(v55 + v58 - 48) = *(_DWORD *)&v21[v58 - 48];
        std::__function::__value_func<void ()(DSPGraph::Graph *,unsigned int)>::__value_func[abi:ne180100](v55 + v58 - 40, (uint64_t)&v21[v58 - 40]);
        *(void *)(v55 + v58 - 8) = *(void *)&v21[v58 - 8];
        v58 -= 48;
      }
      while (&v21[v58] != v57);
      v55 += v58;
      uint64_t v56 = *((void *)&v78 + 1);
    }
    *(void *)&long long v78 = v55;
    unint64_t v59 = (char *)v10[1];
    if (v59 != v21)
    {
      uint64_t v60 = v12 + 48 * v67 + 8;
      do
      {
        *(_DWORD *)uint64_t v56 = *(_DWORD *)(v60 - 8);
        std::__function::__value_func<void ()(DSPGraph::Graph *,unsigned int)>::__value_func[abi:ne180100](v56 + 8, v60);
        *(void *)(v56 + 40) = *(void *)(v60 + 32);
        v56 += 48;
        uint64_t v61 = v60 + 40;
        v60 += 48;
      }
      while ((char *)v61 != v59);
      uint64_t v55 = v78;
      unsigned int v21 = (char *)v10[1];
    }
    unint64_t v62 = *v10;
    *int v10 = v55;
    unint64_t v77 = v62;
    *(void *)&long long v78 = v62;
    v10[1] = v56;
    *((void *)&v78 + 1) = v21;
    unint64_t v63 = v10[2];
    v10[2] = v79;
    unint64_t v79 = v63;
    std::__split_buffer<DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver,std::allocator<DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver> &>::~__split_buffer((uint64_t)&v77);
  }
  else if (v21 == v11)
  {
    *(_DWORD *)BOOL v11 = v74;
    std::__function::__value_func<void ()(DSPGraph::Graph *,unsigned int)>::__value_func[abi:ne180100](v12 + 48 * v20 + 8, (uint64_t)v75);
    *(void *)(v12 + 48 * v20 + 40) = v76;
    v10[1] = (uint64_t)(v11 + 48);
  }
  else
  {
    uint64_t v66 = (v15 - v12) / 48;
    int v23 = v11 - 48;
    if ((unint64_t)v11 < 0x30)
    {
      uint64_t v26 = v9[1];
    }
    else
    {
      uint64_t v24 = 48 * v20 + 16 * ((v11 - (v21 + 48)) >> 4) + v12 + 8;
      uint64_t v25 = v11 - 48;
      uint64_t v26 = v9[1];
      do
      {
        *(_DWORD *)uint64_t v26 = *(_DWORD *)(v24 - 8);
        std::__function::__value_func<void ()(DSPGraph::Graph *,unsigned int)>::__value_func[abi:ne180100](v26 + 8, v24);
        *(void *)(v26 + 40) = *((void *)v25 + 5);
        v25 += 48;
        v26 += 48;
        v24 += 48;
      }
      while (v25 < v11);
    }
    v10[1] = v26;
    if (v11 != v21 + 48)
    {
      uint64_t v34 = 0;
      do
      {
        *(_DWORD *)&v11[v34 - 48] = *(_DWORD *)&v23[v34 - 48];
        std::__function::__value_func<void ()(DSPGraph::Graph *,unsigned int)>::operator=[abi:ne180100](&v11[v34 - 40], (uint64_t)&v23[v34 - 40]);
        *(void *)&v11[v34 - 8] = *(void *)(v12 + 16 * ((v11 - (v21 + 48)) >> 4) + 48 * v66 + v34 - 8);
        v34 -= 48;
      }
      while (-16 * ((v11 - (v21 + 48)) >> 4) != v34);
    }
    BOOL v36 = v21 <= (char *)&v74 && v10[1] > (unint64_t)&v74;
    *(_DWORD *)unsigned int v21 = v74;
    uint64_t v37 = std::__function::__value_func<void ()(DSPGraph::Graph *,unsigned int)>::__value_func[abi:ne180100]((uint64_t)&v81, (uint64_t)&v75[3 * v36]);
    int v38 = (unint64_t *)(v12 + 48 * v66 + 8);
    if (v38 != &v81)
    {
      unint64_t v39 = v83;
      unsigned int v40 = *(unint64_t **)(v12 + 48 * v66 + 32);
      if (v83 == &v81)
      {
        if (v40 == v38)
        {
          (*(void (**)(uint64_t, unint64_t *))(v81 + 24))(v37, &v77);
          (*(void (**)(unint64_t *))(*v83 + 32))(v83);
          unsigned int v83 = 0;
          (*(void (**)(void, unint64_t *))(**(void **)(v12 + 48 * v66 + 32) + 24))(*(void *)(v12 + 48 * v66 + 32), &v81);
          (*(void (**)(void))(**(void **)(v12 + 48 * v66 + 32) + 32))(*(void *)(v12 + 48 * v66 + 32));
          *(void *)(v12 + 48 * v66 + 32) = 0;
          unsigned int v83 = &v81;
          (*(void (**)(unint64_t *, unint64_t *))(v77 + 24))(&v77, v38);
          (*(void (**)(unint64_t *))(v77 + 32))(&v77);
        }
        else
        {
          (*(void (**)(uint64_t, unint64_t *))(v81 + 24))(v37, v38);
          (*(void (**)(unint64_t *))(*v83 + 32))(v83);
          unsigned int v83 = *(unint64_t **)(v12 + 48 * v66 + 32);
        }
        *(void *)(v12 + 48 * v66 + 32) = v12 + 48 * v66 + 8;
      }
      else if (v40 == v38)
      {
        (*(void (**)(unint64_t *, unint64_t *))(*v38 + 24))(v38, &v81);
        (*(void (**)(void))(**(void **)(v12 + 48 * v66 + 32) + 32))(*(void *)(v12 + 48 * v66 + 32));
        *(void *)(v12 + 48 * v66 + 32) = v83;
        unsigned int v83 = &v81;
      }
      else
      {
        unsigned int v83 = *(unint64_t **)(v12 + 48 * v66 + 32);
        *(void *)(v12 + 48 * v66 + 32) = v39;
      }
    }
    std::__function::__value_func<void ()(DSPGraph::Graph *,unsigned int)>::~__value_func[abi:ne180100](&v81);
    *(void *)(v12 + 48 * v66 + 40) = v76;
  }
  caulk::concurrent::lf_read_synchronized_write<std::vector<DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver,std::allocator<DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver>>>::mutator::~mutator((uint64_t)v68);
  uint64_t v64 = v74;
  std::__function::__value_func<void ()(DSPGraph::Graph *,unsigned int)>::~__value_func[abi:ne180100](v75);
  std::__function::__value_func<void ()(DSPGraph::Graph *,unsigned int)>::~__value_func[abi:ne180100](v72);
  return v64;
}

void sub_1901AF1E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

uint64_t std::__function::__value_func<void ()(DSPGraph::Graph *,unsigned int)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

{
  void *v3;
  uint64_t v4;

  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

uint64_t *caulk::concurrent::lf_read_synchronized_write<std::vector<DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver,std::allocator<DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver>>>::mutator::copy_previous(uint64_t *result)
{
  uint64_t v1 = *result;
  uint64_t v2 = *((unsigned int *)result + 8);
  if (*(unsigned char *)(*result + v2 + 8))
  {
    uint64_t v3 = result;
    uint64_t v4 = v1 + 24 * v2;
    long long v14 = 0uLL;
    uint64_t v15 = 0;
    uint64_t v5 = *(void *)(v4 + 16);
    uint64_t v6 = *(void *)(v4 + 24);
    unint64_t v16 = (void **)&v14;
    char v17 = 0;
    if (v6 != v5)
    {
      unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * ((v6 - v5) >> 4);
      if (v7 >= 0x555555555555556) {
        std::vector<float>::__throw_length_error[abi:ne180100]();
      }
      long long v8 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<AudioFormatListItem>>(v7);
      uint64_t v9 = 0;
      *(void *)&long long v14 = v8;
      *((void *)&v14 + 1) = v8;
      uint64_t v15 = &v8[48 * v10];
      do
      {
        uint64_t v11 = v5 + v9;
        *(_DWORD *)&v8[v9] = *(_DWORD *)(v5 + v9);
        std::__function::__value_func<void ()(DSPGraph::Graph *,unsigned int)>::__value_func[abi:ne180100]((uint64_t)&v8[v9 + 8], v5 + v9 + 8);
        *(void *)&v8[v9 + 40] = *(void *)(v5 + v9 + 40);
        v9 += 48;
      }
      while (v11 + 48 != v6);
      *((void *)&v14 + 1) = &v8[v9];
      uint64_t v1 = *v3;
    }
    uint64_t v12 = *((unsigned int *)v3 + 9);
    uint64_t v13 = (void *)(v1 + 24 * v12 + 16);
    if (*(unsigned char *)(v1 + 8 + v12))
    {
      unint64_t v16 = (void **)(v1 + 24 * v12 + 16);
      std::vector<DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver,std::allocator<DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver>>::__destroy_vector::operator()[abi:ne180100](&v16);
    }
    else
    {
      *(unsigned char *)(v1 + 8 + v12) = 1;
    }
    void *v13 = 0;
    v13[1] = 0;
    void v13[2] = 0;
    *(_OWORD *)uint64_t v13 = v14;
    void v13[2] = v15;
    long long v14 = 0uLL;
    uint64_t v15 = 0;
    v3[1] = (uint64_t)v13;
    unint64_t v16 = (void **)&v14;
    std::vector<DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver,std::allocator<DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver>>::__destroy_vector::operator()[abi:ne180100](&v16);
    return v13;
  }
  else
  {
    __break(1u);
  }
  return result;
}

void sub_1901AF45C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::vector<DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver,std::allocator<DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  __clang_call_terminate(a1);
}

uint64_t caulk::concurrent::lf_read_synchronized_write<std::vector<DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver,std::allocator<DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver>>>::mutator::~mutator(uint64_t a1)
{
  uint64_t v2 = *(caulk::concurrent::details::lf_read_sync_write_impl **)a1;
  if (v2 && *(void *)(a1 + 8))
  {
    caulk::concurrent::details::lf_read_sync_write_impl::end_mutate(v2);
    uint64_t v3 = *(caulk::concurrent::details::lf_read_sync_write_impl **)a1;
    uint64_t v4 = *(unsigned int *)(a1 + 32);
    *(unsigned char *)(*(void *)a1 + v4 + 8) = 0;
    uint64_t v6 = (void **)((char *)v3 + 24 * v4 + 16);
    std::vector<DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver,std::allocator<DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver>>::__destroy_vector::operator()[abi:ne180100](&v6);
  }
  if (*(unsigned char *)(a1 + 24)) {
    os_unfair_lock_unlock(*(os_unfair_lock_t *)(a1 + 16));
  }
  return a1;
}

uint64_t std::__split_buffer<DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver,std::allocator<DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 1std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = i - 48;
    std::__function::__value_func<void ()(DSPGraph::Graph *,unsigned int)>::~__value_func[abi:ne180100]((void *)(i - 40));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver *,DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver *,DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1 + 8;
    do
    {
      uint64_t v6 = v5 - 8;
      *(_DWORD *)a3 = *(_DWORD *)(v5 - 8);
      std::__function::__value_func<void ()(DSPGraph::Graph *,unsigned int)>::operator=[abi:ne180100]((void *)(a3 + 8), v5);
      *(void *)(a3 + 40) = *(void *)(v5 + 32);
      a3 += 48;
      v5 += 48;
    }
    while (v6 + 48 != a2);
  }
  return a3;
}

void *std::__function::__value_func<void ()(DSPGraph::Graph *,unsigned int)>::operator=[abi:ne180100](void *a1, uint64_t a2)
{
  uint64_t v4 = (void *)a1[3];
  a1[3] = 0;
  if (v4 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v4)
  {
    (*(void (**)(void *))(*v4 + 40))(v4);
  }
  uint64_t v5 = *(void *)(a2 + 24);
  if (v5)
  {
    if (v5 == a2)
    {
      a1[3] = a1;
      (*(void (**)(void, void *))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      a1[3] = v5;
      *(void *)(a2 + 24) = 0;
    }
  }
  else
  {
    a1[3] = 0;
  }
  return a1;
}

uint64_t DSPGraph::Graph::removeRenderCallback(DSPGraph::Graph *this, int a2)
{
  uint64_t v3 = 0;
  v28[5] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *((void *)this + 85) + 64;
  v24[0] = *((void *)this + 85);
  v24[1] = v4;
  do
  {
    uint64_t v5 = (os_unfair_lock_s *)v24[v3];
    v20[0] = (uint64_t)v5;
    v20[1] = 0;
    v20[2] = (uint64_t)&v5[1];
    char v21 = 1;
    os_unfair_lock_lock(v5 + 1);
    int v22 = caulk::concurrent::details::lf_read_sync_write_impl::begin_mutate((caulk::concurrent::details::lf_read_sync_write_impl *)v5);
    BOOL v23 = v22 == 0;
    uint64_t v6 = caulk::concurrent::lf_read_synchronized_write<std::vector<DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver,std::allocator<DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver>>>::mutator::copy_previous(v20);
    uint64_t v8 = *v6;
    uint64_t v7 = v6[1];
    while (1)
    {
      if (v8 == v7)
      {
        uint64_t v10 = v7;
        goto LABEL_7;
      }
      int v27 = *(_DWORD *)v8;
      std::__function::__value_func<void ()(DSPGraph::Graph *,unsigned int)>::__value_func[abi:ne180100]((uint64_t)v28, v8 + 8);
      void v28[4] = *(void *)(v8 + 40);
      int v9 = v27;
      std::__function::__value_func<void ()(DSPGraph::Graph *,unsigned int)>::~__value_func[abi:ne180100](v28);
      if (v9 == a2) {
        break;
      }
      v8 += 48;
    }
    uint64_t v10 = v7;
    if (v8 != v7)
    {
      uint64_t v16 = v8 + 48;
      uint64_t v10 = v8;
      while (v16 != v7)
      {
        int v25 = *(_DWORD *)v16;
        std::__function::__value_func<void ()(DSPGraph::Graph *,unsigned int)>::__value_func[abi:ne180100]((uint64_t)v26, v16 + 8);
        v26[4] = *(void *)(v16 + 40);
        int v17 = v25;
        std::__function::__value_func<void ()(DSPGraph::Graph *,unsigned int)>::~__value_func[abi:ne180100](v26);
        if (v17 != a2)
        {
          *(_DWORD *)uint64_t v10 = *(_DWORD *)v16;
          std::__function::__value_func<void ()(DSPGraph::Graph *,unsigned int)>::operator=[abi:ne180100]((void *)(v10 + 8), v16 + 8);
          *(void *)(v10 + 40) = *(void *)(v16 + 40);
          v10 += 48;
        }
        v16 += 48;
      }
    }
LABEL_7:
    uint64_t v11 = v6[1];
    if (v10 != v11)
    {
      uint64_t v12 = std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver *,DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver *,DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver *>(v11, v6[1], v10);
      uint64_t v13 = v6[1];
      if (v13 != v12)
      {
        do
        {
          uint64_t v14 = v13 - 48;
          std::__function::__value_func<void ()(DSPGraph::Graph *,unsigned int)>::~__value_func[abi:ne180100]((void *)(v13 - 40));
          uint64_t v13 = v14;
        }
        while (v14 != v12);
      }
      v6[1] = v12;
    }
    uint64_t result = caulk::concurrent::lf_read_synchronized_write<std::vector<DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver,std::allocator<DSPGraph::RenderObserverList<DSPGraph::Graph>::RenderObserver>>>::mutator::~mutator((uint64_t)v20);
    ++v3;
  }
  while (v3 != 2);
  do
    unsigned __int8 v18 = atomic_load((unsigned __int8 *)this + 464);
  while ((v18 & 1) != 0);
  return result;
}

void sub_1901AF940(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::unique_ptr<DSPGraph::IsoGroup>,void *>>>::operator()[abi:ne180100](char a1, void *__p)
{
  if (a1)
  {
    uint64_t v3 = __p[2];
    __p[2] = 0;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

const char *DSPGraph::IsoGroup::ClassName(DSPGraph::IsoGroup *this)
{
  return "IsoGroup";
}

void *std::__function::__value_func<void ()(double)>::swap[abi:ne180100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x1E4F143B8];
  if (a2 != result)
  {
    uint64_t v3 = result;
    uint64_t v4 = (void *)result[3];
    uint64_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_1901AFCDC(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  __clang_call_terminate(a1);
}

uint64_t std::pair<std::string const,DSPGraph::Graph::profiler_t>::~pair(uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

double **std::__function::__func<DSPGraph::Graph::initializeProfilers(void)::$_1,std::allocator<DSPGraph::Graph::initializeProfilers(void)::$_1>,void ()(double)>::operator()(uint64_t a1, double *a2)
{
  return boost::circular_buffer<double,std::allocator<double>>::push_back_impl<double const&>(*(double ***)(a1 + 8), *a2);
}

double **boost::circular_buffer<double,std::allocator<double>>::push_back_impl<double const&>(double **result, double a2)
{
  uint64_t v2 = *result;
  uint64_t v3 = result[1];
  uint64_t v4 = result[4];
  if (v4 == (double *)(v3 - *result))
  {
    if (v3 != v2)
    {
      uint64_t v5 = result[3];
      *uint64_t v5 = a2;
      uint64_t v6 = v5 + 1;
      if (v6 != v3) {
        uint64_t v2 = v6;
      }
      result[2] = v2;
      result[3] = v2;
    }
  }
  else
  {
    uint64_t v7 = result[3];
    *uint64_t v7 = a2;
    uint64_t v8 = v7 + 1;
    if (v8 != v3) {
      uint64_t v2 = v8;
    }
    result[3] = v2;
    result[4] = (double *)((char *)v4 + 1);
  }
  return result;
}

uint64_t std::__function::__func<DSPGraph::Graph::initializeProfilers(void)::$_1,std::allocator<DSPGraph::Graph::initializeProfilers(void)::$_1>,void ()(double)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EDFA1EC0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<DSPGraph::Graph::initializeProfilers(void)::$_1,std::allocator<DSPGraph::Graph::initializeProfilers(void)::$_1>,void ()(double)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EDFA1EC0;
  result[1] = v3;
  return result;
}

void std::__function::__func<DSPGraph::Graph::initializeProfilers(void)::$_1,std::allocator<DSPGraph::Graph::initializeProfilers(void)::$_1>,void ()(double)>::~__func()
{
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,DSPGraph::Graph::profiler_t>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,DSPGraph::Graph::profiler_t>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,DSPGraph::Graph::profiler_t>,0>((uint64_t)v1 + 16);
    }
    operator delete(v1);
  }
}

double **std::__function::__func<DSPGraph::Graph::initializeProfilers(void)::$_0,std::allocator<DSPGraph::Graph::initializeProfilers(void)::$_0>,void ()(double)>::operator()(uint64_t a1, double *a2)
{
  return boost::circular_buffer<double,std::allocator<double>>::push_back_impl<double const&>(*(double ***)(*(void *)(a1 + 8) + 1016), *a2);
}

uint64_t std::__function::__func<DSPGraph::Graph::initializeProfilers(void)::$_0,std::allocator<DSPGraph::Graph::initializeProfilers(void)::$_0>,void ()(double)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EDFA1E78;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<DSPGraph::Graph::initializeProfilers(void)::$_0,std::allocator<DSPGraph::Graph::initializeProfilers(void)::$_0>,void ()(double)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EDFA1E78;
  result[1] = v3;
  return result;
}

void std::__function::__func<DSPGraph::Graph::initializeProfilers(void)::$_0,std::allocator<DSPGraph::Graph::initializeProfilers(void)::$_0>,void ()(double)>::~__func()
{
}

void std::__function::__func<DSPGraph::Graph::initializeWithFlags(unsigned int)::$_0,std::allocator<DSPGraph::Graph::initializeWithFlags(unsigned int)::$_0>,void ()(DSPGraph::Box *,unsigned int)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a2;
  uint64_t v3 = *(void *)(*a2 + 88);
  uint64_t v4 = *(void *)(*a2 + 96) - v3;
  if ((v4 & 0x1FFFFFFFE0) != 0)
  {
    unint64_t v6 = 0;
    unint64_t v7 = v4 >> 5;
    do
    {
      if (v7 <= v6)
      {
        std::string::basic_string[abi:ne180100]<0>(buf, "/Library/Caches/com.apple.xbs/Sources/CoreAudioServices_AudioToolboxCore/CoreAudioUtility/Source/CADSP/DSPGraph/DSPGraph_Box.h");
        std::string::basic_string[abi:ne180100]<0>(__C, "out");
        int v25 = (void *)(v2 + 32);
        if (*(char *)(v2 + 55) < 0) {
          int v25 = (void *)*v25;
        }
        DSPGraph::strprintf((DSPGraph *)"Box::out inIndex out of range! box %s has %zu outputs but input %u was requested", v24, v25, (uint64_t)(*(void *)(v2 + 96) - *(void *)(v2 + 88)) >> 5, v6);
      }
      uint64_t v8 = (*(uint64_t (**)(unint64_t))(*(void *)(v3 + 32 * v6) + 40))(v3 + 32 * v6);
      uint64_t v9 = *(void *)(v2 + 88);
      if (v6 >= (*(void *)(v2 + 96) - v9) >> 5)
      {
        std::string::basic_string[abi:ne180100]<0>(buf, "/Library/Caches/com.apple.xbs/Sources/CoreAudioServices_AudioToolboxCore/CoreAudioUtility/Source/CADSP/DSPGraph/DSPGraph_Box.h");
        std::string::basic_string[abi:ne180100]<0>(__C, "out");
        int v27 = (void *)(v2 + 32);
        if (*(char *)(v2 + 55) < 0) {
          int v27 = (void *)*v27;
        }
        DSPGraph::strprintf((DSPGraph *)"Box::out inIndex out of range! box %s has %zu outputs but input %u was requested", v26, v27, (uint64_t)(*(void *)(v2 + 96) - *(void *)(v2 + 88)) >> 5, v6);
      }
      unsigned int v10 = *(_DWORD *)(*(void *)(v8 + 56) + 100);
      unsigned int v11 = v10
          / *(_DWORD *)(*(void *)((*(uint64_t (**)(unint64_t))(*(void *)(v9 + 32 * v6) + 40))(v9 + 32 * v6)
                                  + 120)
                      + 16);
      if ((*(unsigned char *)(a1 + 8) & 0x20) != 0) {
        vDSP_Length v12 = 1;
      }
      else {
        vDSP_Length v12 = v11;
      }
      uint64_t v13 = *(void *)(v2 + 88);
      if (v6 >= (*(void *)(v2 + 96) - v13) >> 5)
      {
        std::string::basic_string[abi:ne180100]<0>(buf, "/Library/Caches/com.apple.xbs/Sources/CoreAudioServices_AudioToolboxCore/CoreAudioUtility/Source/CADSP/DSPGraph/DSPGraph_Box.h");
        std::string::basic_string[abi:ne180100]<0>(__C, "out");
        BOOL v23 = (void *)(v2 + 32);
        if (*(char *)(v2 + 55) < 0) {
          BOOL v23 = (void *)*v23;
        }
        DSPGraph::strprintf((DSPGraph *)"Box::out inIndex out of range! box %s has %zu outputs but input %u was requested", v22, v23, (uint64_t)(*(void *)(v2 + 96) - *(void *)(v2 + 88)) >> 5, v6);
      }
      uint64_t v14 = *(_DWORD **)(*(void *)((*(uint64_t (**)(unint64_t))(*(void *)(v13 + 32 * v6) + 40))(v13 + 32 * v6)
                                   + 56)
                       + 80);
      if (*v14)
      {
        unint64_t v15 = 0;
        uint64_t v16 = 4;
        do
        {
          LODWORD(__C[0]) = 0;
          vDSP_sve(*(const float **)&v14[v16], 1, (float *)__C, v12);
          if ((__C[0] & 0x7FFFFFFF) >= 0x7F800000)
          {
            if (DSPGraph::getLog(void)::onceToken != -1) {
              goto LABEL_23;
            }
            while (1)
            {
              int v17 = DSPGraph::getLog(void)::gLog;
              if (os_log_type_enabled((os_log_t)DSPGraph::getLog(void)::gLog, OS_LOG_TYPE_FAULT))
              {
                unsigned __int8 v18 = (void *)(v2 + 32);
                if (*(char *)(v2 + 55) < 0) {
                  unsigned __int8 v18 = (void *)*v18;
                }
                uint64_t v19 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 16))(v2);
                *(_DWORD *)AudioComponentVector buf = 136315906;
                uint64_t v30 = v18;
                __int16 v31 = 2080;
                uint64_t v32 = v19;
                __int16 v33 = 1024;
                int v34 = v6;
                __int16 v35 = 1024;
                int v36 = v15;
                _os_log_fault_impl(&dword_18FEC0000, v17, OS_LOG_TYPE_FAULT, "DSPGraph assertion failure: Box: %s (%s), non finite detected at output port: %u, buffer: %u", buf, 0x22u);
              }
              uint64_t v20 = (const char *)(v2 + 32);
              if (*(char *)(v2 + 55) < 0) {
                uint64_t v20 = *(const char **)v20;
              }
              char v21 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)v2 + 16))(v2);
              snprintf((char *)buf, 0x400uLL, "DSPGraph assertion failure: Box: %s (%s), non finite detected at output port: %u, buffer: %u", v20, v21, v6, v15);
              __break(1u);
LABEL_23:
              dispatch_once(&DSPGraph::getLog(void)::onceToken, &__block_literal_global_15177);
            }
          }
          ++v15;
          v16 += 4;
        }
        while (v15 < *v14);
      }
      ++v6;
      uint64_t v3 = *(void *)(v2 + 88);
      unint64_t v7 = (*(void *)(v2 + 96) - v3) >> 5;
    }
    while (v6 < v7);
  }
}

void sub_1901B0340(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a24 < 0) {
    operator delete(a19);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__func<DSPGraph::Graph::initializeWithFlags(unsigned int)::$_0,std::allocator<DSPGraph::Graph::initializeWithFlags(unsigned int)::$_0>,void ()(DSPGraph::Box *,unsigned int)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EDFA1F08;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(result + 8);
  return result;
}

_DWORD *std::__function::__func<DSPGraph::Graph::initializeWithFlags(unsigned int)::$_0,std::allocator<DSPGraph::Graph::initializeWithFlags(unsigned int)::$_0>,void ()(DSPGraph::Box *,unsigned int)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  *(void *)uint64_t result = &unk_1EDFA1F08;
  result[2] = *(_DWORD *)(a1 + 8);
  return result;
}

void std::__function::__func<DSPGraph::Graph::initializeWithFlags(unsigned int)::$_0,std::allocator<DSPGraph::Graph::initializeWithFlags(unsigned int)::$_0>,void ()(DSPGraph::Box *,unsigned int)>::~__func()
{
}

os_log_t ___ZN8DSPGraph6getLogEv_block_invoke_15193()
{
  os_log_t result = os_log_create("com.apple.coreaudio", "DSPGraph");
  DSPGraph::getLog(void)::gLog = (uint64_t)result;
  return result;
}

void DSPGraph::Graph::removeWire(int8x8_t *this, unint64_t a2)
{
  int8x8_t v3 = this[7];
  if (!*(void *)&v3) {
    goto LABEL_18;
  }
  unint64_t v4 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  unint64_t v5 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v4 >> 47) ^ v4);
  unint64_t v6 = 0x9DDFEA08EB382D69 * (v5 ^ (v5 >> 47));
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v3);
  v7.i16[0] = vaddlv_u8(v7);
  if (v7.u32[0] > 1uLL)
  {
    unint64_t v8 = 0x9DDFEA08EB382D69 * (v5 ^ (v5 >> 47));
    if (v6 >= *(void *)&v3) {
      unint64_t v8 = v6 % *(void *)&v3;
    }
  }
  else
  {
    unint64_t v8 = v6 & (*(void *)&v3 - 1);
  }
  int8x8_t v9 = this[6];
  unsigned int v10 = *(void ***)(*(void *)&v9 + 8 * v8);
  if (!v10 || (unsigned int v11 = (int8x8_t *)*v10) == 0)
  {
LABEL_18:
    if (!a2) {
      return;
    }
    goto LABEL_19;
  }
  uint64_t v12 = *(void *)&v3 - 1;
  while (1)
  {
    unint64_t v13 = (unint64_t)v11[1];
    if (v13 == v6) {
      break;
    }
    if (v7.u32[0] > 1uLL)
    {
      if (v13 >= *(void *)&v3) {
        v13 %= *(void *)&v3;
      }
    }
    else
    {
      v13 &= v12;
    }
    if (v13 != v8) {
      goto LABEL_18;
    }
LABEL_17:
    unsigned int v11 = (int8x8_t *)*v11;
    if (!v11) {
      goto LABEL_18;
    }
  }
  if (*(void *)&v11[2] != a2) {
    goto LABEL_17;
  }
  if (v7.u32[0] > 1uLL)
  {
    if (v6 >= *(void *)&v3) {
      v6 %= *(void *)&v3;
    }
  }
  else
  {
    v6 &= v12;
  }
  unint64_t v15 = *(int8x8_t **)(*(void *)&v9 + 8 * v6);
  do
  {
    uint64_t v16 = v15;
    unint64_t v15 = (int8x8_t *)*v15;
  }
  while (v15 != v11);
  if (v16 == &this[8]) {
    goto LABEL_39;
  }
  unint64_t v17 = (unint64_t)v16[1];
  if (v7.u32[0] > 1uLL)
  {
    if (v17 >= *(void *)&v3) {
      v17 %= *(void *)&v3;
    }
  }
  else
  {
    v17 &= v12;
  }
  if (v17 != v6)
  {
LABEL_39:
    if (!*(void *)v11) {
      goto LABEL_40;
    }
    unint64_t v18 = *(void *)(*(void *)v11 + 8);
    if (v7.u32[0] > 1uLL)
    {
      if (v18 >= *(void *)&v3) {
        v18 %= *(void *)&v3;
      }
    }
    else
    {
      v18 &= v12;
    }
    if (v18 != v6) {
LABEL_40:
    }
      *(void *)(*(void *)&v9 + 8 * vstd::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  }
  int8x8_t v19 = *v11;
  if (*v11)
  {
    unint64_t v20 = *(void *)(*(void *)&v19 + 8);
    if (v7.u32[0] > 1uLL)
    {
      if (v20 >= *(void *)&v3) {
        v20 %= *(void *)&v3;
      }
    }
    else
    {
      v20 &= v12;
    }
    if (v20 != v6)
    {
      *(void *)(*(void *)&this[6] + 8 * v20) = v16;
      int8x8_t v19 = *v11;
    }
  }
  *uint64_t v16 = v19;
  *unsigned int v11 = 0;
  --*(void *)&this[9];
  operator delete(v11);
  if (a2)
  {
LABEL_19:
    uint64_t v14 = *(void (**)(unint64_t))(*(void *)a2 + 8);
    v14(a2);
  }
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::unique_ptr<DSPGraph::Box>,void *>>>::operator()[abi:ne180100](char a1, void *__p)
{
  if (a1)
  {
    uint64_t v3 = __p[2];
    __p[2] = 0;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
  }
  operator delete(__p);
}

BOOL DSPGraph::Graph::has(DSPGraph::Graph *this, DSPGraph::Box *a2)
{
  uint64_t v2 = (DSPGraph::Box **)((char *)this + 24);
  do
    uint64_t v2 = (DSPGraph::Box **)*v2;
  while (v2 && v2[2] != a2);
  return v2 != 0;
}

unsigned __int8 **DSPGraph::Graph::addSubset(uint64_t a1, unsigned __int8 *a2)
{
  os_log_t result = DSPGraph::Graph::getSubset(a1, a2);
  if (!result) {
    operator new();
  }
  return result;
}

void sub_1901B08E4(_Unwind_Exception *a1)
{
  MEMORY[0x192FC8940](v1, 0x10B2C40A8EE1826);
  _Unwind_Resume(a1);
}

unsigned __int8 **DSPGraph::Graph::getSubset(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = *(unsigned __int8 ****)(a1 + 904);
  uint64_t v3 = *(unsigned __int8 ****)(a1 + 912);
  if (v2 == v3)
  {
LABEL_20:
    if (v2 != v3) {
      return *v2;
    }
  }
  else
  {
    uint64_t v5 = a2[23];
    uint8x8_t v7 = *(const void **)a2;
    size_t v6 = *((void *)a2 + 1);
    if ((v5 & 0x80u) == 0) {
      unint64_t v8 = (unsigned __int8 *)a2[23];
    }
    else {
      unint64_t v8 = (unsigned __int8 *)*((void *)a2 + 1);
    }
    do
    {
      int8x8_t v9 = (unsigned __int8 *)*((unsigned __int8 *)*v2 + 23);
      int v10 = (char)v9;
      if ((char)v9 < 0) {
        int8x8_t v9 = (*v2)[1];
      }
      if (v8 == v9)
      {
        if (v10 >= 0) {
          unsigned int v11 = (unsigned __int8 *)*v2;
        }
        else {
          unsigned int v11 = **v2;
        }
        if ((v5 & 0x80) != 0)
        {
          if (!memcmp(v7, v11, v6)) {
            goto LABEL_20;
          }
        }
        else
        {
          if (!v5) {
            goto LABEL_20;
          }
          uint64_t v12 = a2;
          uint64_t v13 = v5;
          while (*v12 == *v11)
          {
            ++v12;
            ++v11;
            if (!--v13) {
              goto LABEL_20;
            }
          }
        }
      }
      ++v2;
    }
    while (v2 != v3);
  }
  return 0;
}

unsigned __int8 *DSPGraph::Graph::box(uint64_t a1, unsigned __int8 *a2)
{
  os_log_t result = std::__hash_table<std::__hash_value_type<std::string,DSPGraph::Box *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,DSPGraph::Box *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,DSPGraph::Box *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,DSPGraph::Box *>>>::find<std::string>((void *)(a1 + 784), a2);
  if (result) {
    return (unsigned __int8 *)*((void *)result + 5);
  }
  return result;
}

uint64_t DSPGraph::Graph::box(int8x8_t *this, unint64_t a2)
{
  int8x8_t v2 = this[104];
  if (v2)
  {
    uint8x8_t v3 = (uint8x8_t)vcnt_s8(v2);
    v3.i16[0] = vaddlv_u8(v3);
    if (v3.u32[0] > 1uLL)
    {
      unint64_t v4 = a2;
      if (*(void *)&v2 <= a2) {
        unint64_t v4 = a2 % *(void *)&v2;
      }
    }
    else
    {
      unint64_t v4 = (*(void *)&v2 - 1) & a2;
    }
    uint64_t v5 = *(void **)(*(void *)&this[103] + 8 * v4);
    if (v5)
    {
      for (uint64_t i = (void *)*v5; i; uint64_t i = (void *)*i)
      {
        unint64_t v7 = i[1];
        if (v7 == a2)
        {
          if (i[2] == a2) {
            return i[3];
          }
        }
        else
        {
          if (v3.u32[0] > 1uLL)
          {
            if (v7 >= *(void *)&v2) {
              v7 %= *(void *)&v2;
            }
          }
          else
          {
            v7 &= *(void *)&v2 - 1;
          }
          if (v7 != v4) {
            return 0;
          }
        }
      }
    }
  }
  return 0;
}

uint64_t DSPGraph::Graph::analyzer(std::mutex *this, unint64_t a2)
{
  unint64_t v4 = this + 2;
  std::mutex::lock(this + 2);
  uint64_t v5 = std::__hash_table<std::__hash_value_type<unsigned long long,DSPGraph::Analyzer *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,DSPGraph::Analyzer *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,DSPGraph::Analyzer *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,DSPGraph::Analyzer *>>>::find<unsigned long long>(&this[13].__m_.__opaque[24], a2);
  if (v5) {
    uint64_t v6 = v5[3];
  }
  else {
    uint64_t v6 = 0;
  }
  std::mutex::unlock(v4);
  return v6;
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,DSPGraph::Analyzer *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,DSPGraph::Analyzer *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,DSPGraph::Analyzer *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,DSPGraph::Analyzer *>>>::find<unsigned long long>(void *a1, unint64_t a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8(v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a2;
    if (*(void *)&v2 <= a2) {
      unint64_t v4 = a2 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v4 = (*(void *)&v2 - 1) & a2;
  }
  uint64_t v5 = *(void **)(*a1 + 8 * v4);
  if (!v5) {
    return 0;
  }
  os_log_t result = (void *)*v5;
  if (*v5)
  {
    do
    {
      unint64_t v7 = result[1];
      if (v7 == a2)
      {
        if (result[2] == a2) {
          return result;
        }
      }
      else
      {
        if (v3.u32[0] > 1uLL)
        {
          if (v7 >= *(void *)&v2) {
            v7 %= *(void *)&v2;
          }
        }
        else
        {
          v7 &= *(void *)&v2 - 1;
        }
        if (v7 != v4) {
          return 0;
        }
      }
      os_log_t result = (void *)*result;
    }
    while (result);
  }
  return result;
}

void DSPGraph::Graph::addAnalyzer(std::mutex *this, unint64_t a2)
{
  uint64_t v5 = this + 2;
  std::mutex::lock(this + 2);
  unint64_t v6 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  unint64_t v7 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v6 >> 47) ^ v6);
  unint64_t v8 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
  unint64_t v9 = *(void *)&this[1].__m_.__opaque[24];
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v2 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
      if (v8 >= v9) {
        unint64_t v2 = v8 % v9;
      }
    }
    else
    {
      unint64_t v2 = v8 & (v9 - 1);
    }
    unsigned int v11 = *(void **)(*(void *)&this[1].__m_.__opaque[16] + 8 * v2);
    if (v11)
    {
      for (uint64_t i = (void *)*v11; i; uint64_t i = (void *)*i)
      {
        unint64_t v13 = i[1];
        if (v13 == v8)
        {
          if (i[2] == a2) {
            goto LABEL_74;
          }
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9) {
              v13 %= v9;
            }
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v2) {
            break;
          }
        }
      }
    }
  }
  uint64_t v14 = operator new(0x18uLL);
  *uint64_t v14 = 0;
  v14[1] = v8;
  _OWORD v14[2] = a2;
  float v15 = (float)(unint64_t)(*(void *)&this[1].__m_.__opaque[40] + 1);
  float v16 = *(float *)&this[1].__m_.__opaque[48];
  if (!v9 || (float)(v16 * (float)v9) < v15)
  {
    BOOL v17 = 1;
    if (v9 >= 3) {
      BOOL v17 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v9);
    unint64_t v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19) {
      int8x8_t prime = (int8x8_t)v19;
    }
    else {
      int8x8_t prime = (int8x8_t)v18;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v9 = *(void *)&this[1].__m_.__opaque[24];
    }
    if (*(void *)&prime > v9) {
      goto LABEL_30;
    }
    if (*(void *)&prime < v9)
    {
      unint64_t v27 = vcvtps_u32_f32((float)*(unint64_t *)&this[1].__m_.__opaque[40] / *(float *)&this[1].__m_.__opaque[48]);
      if (v9 < 3 || (uint8x8_t v28 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v28.i16[0] = vaddlv_u8(v28), v28.u32[0] > 1uLL))
      {
        unint64_t v27 = std::__next_prime(v27);
      }
      else
      {
        uint64_t v29 = 1 << -(char)__clz(v27 - 1);
        if (v27 >= 2) {
          unint64_t v27 = v29;
        }
      }
      if (*(void *)&prime <= v27) {
        int8x8_t prime = (int8x8_t)v27;
      }
      if (*(void *)&prime >= v9)
      {
        unint64_t v9 = *(void *)&this[1].__m_.__opaque[24];
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          char v21 = operator new(8 * *(void *)&prime);
          int v22 = *(void **)&this[1].__m_.__opaque[16];
          *(void *)&this[1].__m_.__opaque[16] = v21;
          if (v22) {
            operator delete(v22);
          }
          uint64_t v23 = 0;
          *(int8x8_t *)&this[1].__m_.__opaque[24] = prime;
          do
            *(void *)(*(void *)&this[1].__m_.__opaque[16] + 8 * v23++) = 0;
          while (*(void *)&prime != v23);
          uint64_t v24 = *(void **)&this[1].__m_.__opaque[32];
          if (v24)
          {
            unint64_t v25 = v24[1];
            uint8x8_t v26 = (uint8x8_t)vcnt_s8(prime);
            v26.i16[0] = vaddlv_u8(v26);
            if (v26.u32[0] > 1uLL)
            {
              if (v25 >= *(void *)&prime) {
                v25 %= *(void *)&prime;
              }
            }
            else
            {
              v25 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)&this[1].__m_.__opaque[16] + 8 * v25) = (char *)this + 104;
            uint64_t v30 = (void *)*v24;
            if (*v24)
            {
              do
              {
                unint64_t v31 = v30[1];
                if (v26.u32[0] > 1uLL)
                {
                  if (v31 >= *(void *)&prime) {
                    v31 %= *(void *)&prime;
                  }
                }
                else
                {
                  v31 &= *(void *)&prime - 1;
                }
                if (v31 != v25)
                {
                  uint64_t v32 = *(void *)&this[1].__m_.__opaque[16];
                  if (!*(void *)(v32 + 8 * v31))
                  {
                    *(void *)(v32 + 8 * v31) = v24;
                    goto LABEL_55;
                  }
                  *uint64_t v24 = *v30;
                  *uint64_t v30 = **(void **)(*(void *)&this[1].__m_.__opaque[16] + 8 * v31);
                  **(void **)(*(void *)&this[1].__m_.__opaque[16] + 8 * v31) = v30;
                  uint64_t v30 = v24;
                }
                unint64_t v31 = v25;
LABEL_55:
                uint64_t v24 = v30;
                uint64_t v30 = (void *)*v30;
                unint64_t v25 = v31;
              }
              while (v30);
            }
          }
          unint64_t v9 = (unint64_t)prime;
          goto LABEL_59;
        }
        uint64_t v64 = *(void **)&this[1].__m_.__opaque[16];
        *(void *)&this[1].__m_.__opaque[16] = 0;
        if (v64) {
          operator delete(v64);
        }
        unint64_t v9 = 0;
        *(void *)&this[1].__m_.__opaque[24] = 0;
      }
    }
LABEL_59:
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v2 = v8 % v9;
      }
      else {
        unint64_t v2 = v8;
      }
    }
    else
    {
      unint64_t v2 = (v9 - 1) & v8;
    }
  }
  uint64_t v33 = *(void *)&this[1].__m_.__opaque[16];
  int v34 = *(void **)(v33 + 8 * v2);
  if (v34)
  {
    *uint64_t v14 = *v34;
LABEL_72:
    void *v34 = v14;
    goto LABEL_73;
  }
  *uint64_t v14 = *(void *)&this[1].__m_.__opaque[32];
  *(void *)&this[1].__m_.__opaque[32] = v14;
  *(void *)(v33 + 8 * v2) = (char *)this + 104;
  if (*v14)
  {
    unint64_t v35 = *(void *)(*v14 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v35 >= v9) {
        v35 %= v9;
      }
    }
    else
    {
      v35 &= v9 - 1;
    }
    int v34 = (void *)(*(void *)&this[1].__m_.__opaque[16] + 8 * v35);
    goto LABEL_72;
  }
LABEL_73:
  ++*(void *)&this[1].__m_.__opaque[40];
LABEL_74:
  unint64_t v36 = *(void *)(a2 + 88);
  unint64_t v37 = *(void *)&this[13].__m_.__opaque[32];
  if (v37)
  {
    uint8x8_t v38 = (uint8x8_t)vcnt_s8((int8x8_t)v37);
    v38.i16[0] = vaddlv_u8(v38);
    if (v38.u32[0] > 1uLL)
    {
      unint64_t v9 = *(void *)(a2 + 88);
      if (v36 >= v37) {
        unint64_t v9 = v36 % v37;
      }
    }
    else
    {
      unint64_t v9 = (v37 - 1) & v36;
    }
    unint64_t v39 = *(void **)(*(void *)&this[13].__m_.__opaque[24] + 8 * v9);
    if (v39)
    {
      for (unint64_t j = (void *)*v39; j; unint64_t j = (void *)*j)
      {
        unint64_t v41 = j[1];
        if (v41 == v36)
        {
          if (j[2] == v36) {
            goto LABEL_147;
          }
        }
        else
        {
          if (v38.u32[0] > 1uLL)
          {
            if (v41 >= v37) {
              v41 %= v37;
            }
          }
          else
          {
            v41 &= v37 - 1;
          }
          if (v41 != v9) {
            break;
          }
        }
      }
    }
  }
  unsigned int v42 = operator new(0x20uLL);
  *unsigned int v42 = 0;
  v42[1] = v36;
  v42[2] = v36;
  v42[3] = a2;
  float v43 = (float)(unint64_t)(*(void *)&this[13].__m_.__opaque[48] + 1);
  float v44 = *(float *)&this[14].__m_.__sig;
  if (!v37 || (float)(v44 * (float)v37) < v43)
  {
    BOOL v45 = 1;
    if (v37 >= 3) {
      BOOL v45 = (v37 & (v37 - 1)) != 0;
    }
    unint64_t v46 = v45 | (2 * v37);
    unint64_t v47 = vcvtps_u32_f32(v43 / v44);
    if (v46 <= v47) {
      int8x8_t v48 = (int8x8_t)v47;
    }
    else {
      int8x8_t v48 = (int8x8_t)v46;
    }
    if (*(void *)&v48 == 1)
    {
      int8x8_t v48 = (int8x8_t)2;
    }
    else if ((*(void *)&v48 & (*(void *)&v48 - 1)) != 0)
    {
      int8x8_t v48 = (int8x8_t)std::__next_prime(*(void *)&v48);
      unint64_t v37 = *(void *)&this[13].__m_.__opaque[32];
    }
    if (*(void *)&v48 > v37) {
      goto LABEL_103;
    }
    if (*(void *)&v48 < v37)
    {
      unint64_t v55 = vcvtps_u32_f32((float)*(unint64_t *)&this[13].__m_.__opaque[48] / *(float *)&this[14].__m_.__sig);
      if (v37 < 3 || (uint8x8_t v56 = (uint8x8_t)vcnt_s8((int8x8_t)v37), v56.i16[0] = vaddlv_u8(v56), v56.u32[0] > 1uLL))
      {
        unint64_t v55 = std::__next_prime(v55);
      }
      else
      {
        uint64_t v57 = 1 << -(char)__clz(v55 - 1);
        if (v55 >= 2) {
          unint64_t v55 = v57;
        }
      }
      if (*(void *)&v48 <= v55) {
        int8x8_t v48 = (int8x8_t)v55;
      }
      if (*(void *)&v48 >= v37)
      {
        unint64_t v37 = *(void *)&this[13].__m_.__opaque[32];
      }
      else
      {
        if (v48)
        {
LABEL_103:
          if (*(void *)&v48 >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v49 = operator new(8 * *(void *)&v48);
          uint64_t v50 = *(void **)&this[13].__m_.__opaque[24];
          *(void *)&this[13].__m_.__opaque[24] = v49;
          if (v50) {
            operator delete(v50);
          }
          uint64_t v51 = 0;
          *(int8x8_t *)&this[13].__m_.__opaque[32] = v48;
          do
            *(void *)(*(void *)&this[13].__m_.__opaque[24] + 8 * v51++) = 0;
          while (*(void *)&v48 != v51);
          int64x2_t v52 = *(void **)&this[13].__m_.__opaque[40];
          if (v52)
          {
            unint64_t v53 = v52[1];
            uint8x8_t v54 = (uint8x8_t)vcnt_s8(v48);
            v54.i16[0] = vaddlv_u8(v54);
            if (v54.u32[0] > 1uLL)
            {
              if (v53 >= *(void *)&v48) {
                v53 %= *(void *)&v48;
              }
            }
            else
            {
              v53 &= *(void *)&v48 - 1;
            }
            *(void *)(*(void *)&this[13].__m_.__opaque[24] + 8 * v53) = (char *)this + 880;
            uint64_t v58 = (void *)*v52;
            if (*v52)
            {
              do
              {
                unint64_t v59 = v58[1];
                if (v54.u32[0] > 1uLL)
                {
                  if (v59 >= *(void *)&v48) {
                    v59 %= *(void *)&v48;
                  }
                }
                else
                {
                  v59 &= *(void *)&v48 - 1;
                }
                if (v59 != v53)
                {
                  uint64_t v60 = *(void *)&this[13].__m_.__opaque[24];
                  if (!*(void *)(v60 + 8 * v59))
                  {
                    *(void *)(v60 + 8 * v59) = v52;
                    goto LABEL_128;
                  }
                  void *v52 = *v58;
                  *uint64_t v58 = **(void **)(*(void *)&this[13].__m_.__opaque[24] + 8 * v59);
                  **(void **)(*(void *)&this[13].__m_.__opaque[24] + 8 * v59) = v58;
                  uint64_t v58 = v52;
                }
                unint64_t v59 = v53;
LABEL_128:
                int64x2_t v52 = v58;
                uint64_t v58 = (void *)*v58;
                unint64_t v53 = v59;
              }
              while (v58);
            }
          }
          unint64_t v37 = (unint64_t)v48;
          goto LABEL_132;
        }
        int v65 = *(void **)&this[13].__m_.__opaque[24];
        *(void *)&this[13].__m_.__opaque[24] = 0;
        if (v65) {
          operator delete(v65);
        }
        unint64_t v37 = 0;
        *(void *)&this[13].__m_.__opaque[32] = 0;
      }
    }
LABEL_132:
    if ((v37 & (v37 - 1)) != 0)
    {
      if (v36 >= v37) {
        unint64_t v9 = v36 % v37;
      }
      else {
        unint64_t v9 = v36;
      }
    }
    else
    {
      unint64_t v9 = (v37 - 1) & v36;
    }
  }
  uint64_t v61 = *(void *)&this[13].__m_.__opaque[24];
  unint64_t v62 = *(void **)(v61 + 8 * v9);
  if (v62)
  {
    *unsigned int v42 = *v62;
LABEL_145:
    void *v62 = v42;
    goto LABEL_146;
  }
  *unsigned int v42 = *(void *)&this[13].__m_.__opaque[40];
  *(void *)&this[13].__m_.__opaque[40] = v42;
  *(void *)(v61 + 8 * v9) = (char *)this + 880;
  if (*v42)
  {
    unint64_t v63 = *(void *)(*v42 + 8);
    if ((v37 & (v37 - 1)) != 0)
    {
      if (v63 >= v37) {
        v63 %= v37;
      }
    }
    else
    {
      v63 &= v37 - 1;
    }
    unint64_t v62 = (void *)(*(void *)&this[13].__m_.__opaque[24] + 8 * v63);
    goto LABEL_145;
  }
LABEL_146:
  ++*(void *)&this[13].__m_.__opaque[48];
LABEL_147:
  std::mutex::unlock(v5);
}

void sub_1901B13B8(_Unwind_Exception *a1)
{
  operator delete(v2);
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void DSPGraph::Graph::removeAnalyzer(std::mutex *this, DSPGraph::Analyzer *a2)
{
  unint64_t v4 = this + 2;
  std::mutex::lock(this + 2);
  uint64_t v5 = &this[1].__m_.__opaque[32];
  while (1)
  {
    uint64_t v5 = *(char **)v5;
    if (!v5) {
      break;
    }
    if (*(void *)(*((void *)v5 + 2) + 88) == *((void *)a2 + 11))
    {
      int8x8_t v6 = *(int8x8_t *)&this[1].__m_.__opaque[24];
      unint64_t v7 = *((void *)v5 + 1);
      uint8x8_t v8 = (uint8x8_t)vcnt_s8(v6);
      v8.i16[0] = vaddlv_u8(v8);
      if (v8.u32[0] > 1uLL)
      {
        if (v7 >= *(void *)&v6) {
          v7 %= *(void *)&v6;
        }
      }
      else
      {
        v7 &= *(void *)&v6 - 1;
      }
      uint64_t v9 = *(void *)&this[1].__m_.__opaque[16];
      uint8x8_t v10 = *(char **)(v9 + 8 * v7);
      do
      {
        unsigned int v11 = v10;
        uint8x8_t v10 = *(char **)v10;
      }
      while (v10 != v5);
      if (v11 == &this[1].__m_.__opaque[32]) {
        goto LABEL_21;
      }
      unint64_t v12 = *((void *)v11 + 1);
      if (v8.u32[0] > 1uLL)
      {
        if (v12 >= *(void *)&v6) {
          v12 %= *(void *)&v6;
        }
      }
      else
      {
        v12 &= *(void *)&v6 - 1;
      }
      if (v12 != v7)
      {
LABEL_21:
        if (!*(void *)v5) {
          goto LABEL_22;
        }
        unint64_t v13 = *(void *)(*(void *)v5 + 8);
        if (v8.u32[0] > 1uLL)
        {
          if (v13 >= *(void *)&v6) {
            v13 %= *(void *)&v6;
          }
        }
        else
        {
          v13 &= *(void *)&v6 - 1;
        }
        if (v13 != v7) {
LABEL_22:
        }
          *(void *)(v9 + 8 * v7) = 0;
      }
      uint64_t v14 = *(char **)v5;
      if (*(void *)v5)
      {
        unint64_t v15 = *((void *)v14 + 1);
        if (v8.u32[0] > 1uLL)
        {
          if (v15 >= *(void *)&v6) {
            v15 %= *(void *)&v6;
          }
        }
        else
        {
          v15 &= *(void *)&v6 - 1;
        }
        if (v15 != v7)
        {
          *(void *)(*(void *)&this[1].__m_.__opaque[16] + 8 * v15) = v11;
          uint64_t v14 = *(char **)v5;
        }
      }
      *(void *)unsigned int v11 = v14;
      *(void *)uint64_t v5 = 0;
      --*(void *)&this[1].__m_.__opaque[40];
      operator delete(v5);
      break;
    }
  }
  float v16 = &this[13].__m_.__opaque[24];
  BOOL v17 = (char *)std::__hash_table<std::__hash_value_type<unsigned long long,DSPGraph::Analyzer *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,DSPGraph::Analyzer *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,DSPGraph::Analyzer *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,DSPGraph::Analyzer *>>>::find<unsigned long long>(&this[13].__m_.__opaque[24], *((void *)a2 + 11));
  if (v17)
  {
    int8x8_t v18 = *(int8x8_t *)&this[13].__m_.__opaque[32];
    unint64_t v19 = *((void *)v17 + 1);
    uint8x8_t v20 = (uint8x8_t)vcnt_s8(v18);
    v20.i16[0] = vaddlv_u8(v20);
    if (v20.u32[0] > 1uLL)
    {
      if (v19 >= *(void *)&v18) {
        v19 %= *(void *)&v18;
      }
    }
    else
    {
      v19 &= *(void *)&v18 - 1;
    }
    char v21 = *(char **)(*(void *)v16 + 8 * v19);
    do
    {
      int v22 = v21;
      char v21 = *(char **)v21;
    }
    while (v21 != v17);
    if (v22 == &this[13].__m_.__opaque[40]) {
      goto LABEL_49;
    }
    unint64_t v23 = *((void *)v22 + 1);
    if (v20.u32[0] > 1uLL)
    {
      if (v23 >= *(void *)&v18) {
        v23 %= *(void *)&v18;
      }
    }
    else
    {
      v23 &= *(void *)&v18 - 1;
    }
    if (v23 != v19)
    {
LABEL_49:
      if (!*(void *)v17) {
        goto LABEL_50;
      }
      unint64_t v24 = *(void *)(*(void *)v17 + 8);
      if (v20.u32[0] > 1uLL)
      {
        if (v24 >= *(void *)&v18) {
          v24 %= *(void *)&v18;
        }
      }
      else
      {
        v24 &= *(void *)&v18 - 1;
      }
      if (v24 != v19) {
LABEL_50:
      }
        *(void *)(*(void *)v16 + 8 * v19) = 0;
    }
    uint64_t v25 = *(void *)v17;
    if (*(void *)v17)
    {
      unint64_t v26 = *(void *)(v25 + 8);
      if (v20.u32[0] > 1uLL)
      {
        if (v26 >= *(void *)&v18) {
          v26 %= *(void *)&v18;
        }
      }
      else
      {
        v26 &= *(void *)&v18 - 1;
      }
      if (v26 != v19)
      {
        *(void *)(*(void *)v16 + 8 * v2std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = v22;
        uint64_t v25 = *(void *)v17;
      }
    }
    *(void *)int v22 = v25;
    *(void *)BOOL v17 = 0;
    --*(void *)&this[13].__m_.__opaque[48];
    operator delete(v17);
  }
  std::mutex::unlock(v4);
}

float *DSPGraph::Graph::connect(int8x8_t *a1, unsigned __int8 *a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5, DSPGraph *a6)
{
  if (a4)
  {
    unint64_t v12 = 0;
  }
  else
  {
    unint64_t v13 = std::__hash_table<std::__hash_value_type<std::string,DSPGraph::Box *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,DSPGraph::Box *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,DSPGraph::Box *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,DSPGraph::Box *>>>::find<std::string>(&a1[80], a2);
    if (v13) {
      unint64_t v12 = (float **)(v13 + 40);
    }
    else {
      unint64_t v12 = 0;
    }
  }
  uint64_t v14 = std::__hash_table<std::__hash_value_type<std::string,DSPGraph::Box *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,DSPGraph::Box *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,DSPGraph::Box *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,DSPGraph::Box *>>>::find<std::string>(&a1[98], a2);
  if (v14) {
    unint64_t v15 = (const AudioStreamBasicDescription *)*((void *)v14 + 5);
  }
  else {
    unint64_t v15 = 0;
  }
  if (!((unint64_t)v15 | (unint64_t)v12))
  {
    std::string::basic_string[abi:ne180100]<0>(&v35, "/Library/Caches/com.apple.xbs/Sources/CoreAudioServices_AudioToolboxCore/CoreAudioUtility/Source/CADSP/DSPGraph/DSPGraph_Graph.cpp");
    std::string::basic_string[abi:ne180100]<0>(&v34, "connect");
    std::operator+<char>();
    std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(&v31, &v30, "\" index ");
    std::to_string(&v29, a4);
    if ((v29.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      char v21 = &v29;
    }
    else {
      char v21 = (std::string *)v29.__r_.__value_.__r.__words[0];
    }
    if ((v29.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v29.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v29.__r_.__value_.__l.__size_;
    }
    unint64_t v23 = std::string::append(&v31, (const std::string::value_type *)v21, size);
    long long v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
    v32.__r_.__value_.__r.__UInt32 words[2] = v23->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v32.__r_.__value_.__l.__data_ = v24;
    v23->__r_.__value_.__l.__size_ = 0;
    v23->__r_.__value_.__r.__UInt32 words[2] = 0;
    v23->__r_.__value_.__r.__words[0] = 0;
    std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(&v33, &v32, " not found");
    DSPGraph::ThrowException(1852204065, &v35, 1120, &v34, (long long *)&v33);
  }
  if (a5)
  {
    float v16 = 0;
  }
  else
  {
    BOOL v17 = std::__hash_table<std::__hash_value_type<std::string,DSPGraph::Box *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,DSPGraph::Box *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,DSPGraph::Box *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,DSPGraph::Box *>>>::find<std::string>(&a1[80], a3);
    if (v17) {
      float v16 = (uint64_t *)(v17 + 40);
    }
    else {
      float v16 = 0;
    }
  }
  int8x8_t v18 = std::__hash_table<std::__hash_value_type<std::string,DSPGraph::Box *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,DSPGraph::Box *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,DSPGraph::Box *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,DSPGraph::Box *>>>::find<std::string>(&a1[98], a3);
  if (v18) {
    uint64_t v19 = *((void *)v18 + 5);
  }
  else {
    uint64_t v19 = 0;
  }
  if (!(v19 | (unint64_t)v16))
  {
    std::string::basic_string[abi:ne180100]<0>(&v35, "/Library/Caches/com.apple.xbs/Sources/CoreAudioServices_AudioToolboxCore/CoreAudioUtility/Source/CADSP/DSPGraph/DSPGraph_Graph.cpp");
    std::string::basic_string[abi:ne180100]<0>(&v34, "connect");
    std::operator+<char>();
    std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(&v31, &v30, "\" index ");
    std::to_string(&v29, a5);
    if ((v29.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v25 = &v29;
    }
    else {
      uint64_t v25 = (std::string *)v29.__r_.__value_.__r.__words[0];
    }
    if ((v29.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v26 = HIBYTE(v29.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v26 = v29.__r_.__value_.__l.__size_;
    }
    unint64_t v27 = std::string::append(&v31, (const std::string::value_type *)v25, v26);
    long long v28 = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
    v32.__r_.__value_.__r.__UInt32 words[2] = v27->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v32.__r_.__value_.__l.__data_ = v28;
    v27->__r_.__value_.__l.__size_ = 0;
    v27->__r_.__value_.__r.__UInt32 words[2] = 0;
    v27->__r_.__value_.__r.__words[0] = 0;
    std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(&v33, &v32, " not found");
    DSPGraph::ThrowException(1852204065, &v35, 1126, &v34, (long long *)&v33);
  }
  return DSPGraph::Graph::connect(a1, v15, v19, a4, a5, a6, v12, v16);
}

void sub_1901B1958(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45)
{
  if (a39 < 0) {
    operator delete(__p);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a45 < 0) {
    operator delete(a40);
  }
  if (*(char *)(v45 - 81) < 0) {
    operator delete(*(void **)(v45 - 104));
  }
  _Unwind_Resume(exception_object);
}

float *DSPGraph::Graph::connect(int8x8_t *a1, const AudioStreamBasicDescription *a2, uint64_t a3, uint64_t a4, uint64_t a5, DSPGraph *this, float **a7, uint64_t *a8)
{
  if (*((_DWORD *)this + 2) == 1718773105 && *((_DWORD *)this + 8) != 64)
  {
    std::string::basic_string[abi:ne180100]<0>(&v20, "/Library/Caches/com.apple.xbs/Sources/CoreAudioServices_AudioToolboxCore/CoreAudioUtility/Source/CADSP/DSPGraph/DSPGraph_Graph.cpp");
    std::string::basic_string[abi:ne180100]<0>(&v19, "connect");
    std::string::basic_string[abi:ne180100]<0>(&v18, "frequency domain format should be 64 bits.");
    DSPGraph::ThrowException(1718449215, &v20, 1141, &v19, &v18);
  }
  if (*(double *)this != floor(*(double *)this))
  {
    std::string::basic_string[abi:ne180100]<0>(&v20, "/Library/Caches/com.apple.xbs/Sources/CoreAudioServices_AudioToolboxCore/CoreAudioUtility/Source/CADSP/DSPGraph/DSPGraph_Graph.cpp");
    std::string::basic_string[abi:ne180100]<0>(&v19, "connect");
    std::string::basic_string[abi:ne180100]<0>(&v18, "only integer sample rates are supported.");
    DSPGraph::ThrowException(1718449215, &v20, 1145, &v19, &v18);
  }
  if (!DSPGraph::MinimalSafetyCheck(this, a2))
  {
    std::string::basic_string[abi:ne180100]<0>(&v20, "/Library/Caches/com.apple.xbs/Sources/CoreAudioServices_AudioToolboxCore/CoreAudioUtility/Source/CADSP/DSPGraph/DSPGraph_Graph.cpp");
    std::string::basic_string[abi:ne180100]<0>(&v19, "connect");
    std::string::basic_string[abi:ne180100]<0>(&v18, "format failed sanity check.");
    DSPGraph::ThrowException(1718449215, &v20, 1148, &v19, &v18);
  }
  float v16 = DSPGraph::Graph::connect(a1, (uint64_t)a2, a3, a4, a5, a7, a8);
  DSPGraph::Wire::setLocalFormat((uint64_t)v16, (const AudioStreamBasicDescription *)this, *((unsigned int *)this + 10));
  return v16;
}

void sub_1901B1BDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  _Unwind_Resume(exception_object);
}

unsigned __int8 *DSPGraph::Graph::getJack(uint64_t a1, unsigned __int8 *a2)
{
  unint64_t v2 = std::__hash_table<std::__hash_value_type<std::string,DSPGraph::Box *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,DSPGraph::Box *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,DSPGraph::Box *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,DSPGraph::Box *>>>::find<std::string>((void *)(a1 + 640), a2);
  if (v2) {
    return v2 + 40;
  }
  else {
    return 0;
  }
}

uint64_t DSPGraph::Graph::connectProperties(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  if (*(unsigned char *)(a1 + 761))
  {
    std::string::basic_string[abi:ne180100]<0>(&v23, "/Library/Caches/com.apple.xbs/Sources/CoreAudioServices_AudioToolboxCore/CoreAudioUtility/Source/CADSP/DSPGraph/DSPGraph_Graph.cpp");
    std::string::basic_string[abi:ne180100]<0>(&v28, "connectProperties");
    std::string::basic_string[abi:ne180100]<0>(&v27, "graph is configured");
    DSPGraph::ThrowException(1667655457, &v23, 1299, &v28, &v27);
  }
  long long v23 = *(_OWORD *)a2;
  *(_DWORD *)long long v24 = *(_DWORD *)(a2 + 16);
  *(_OWORD *)&v24[8] = *(_OWORD *)a3;
  *(_DWORD *)&v24[24] = *(_DWORD *)(a3 + 16);
  uint64_t v9 = *(char **)(a1 + 504);
  unint64_t v8 = *(void *)(a1 + 512);
  if ((unint64_t)v9 >= v8)
  {
    unsigned int v11 = *(char **)(a1 + 496);
    unint64_t v12 = 0x6DB6DB6DB6DB6DB7 * ((v9 - v11) >> 3) + 1;
    if (v12 > 0x492492492492492) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v13 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v8 - (void)v11) >> 3);
    if (2 * v13 > v12) {
      unint64_t v12 = 2 * v13;
    }
    if (v13 >= 0x249249249249249) {
      unint64_t v14 = 0x492492492492492;
    }
    else {
      unint64_t v14 = v12;
    }
    if (v14)
    {
      if (v14 > 0x492492492492492) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      unint64_t v15 = (char *)operator new(56 * v14);
    }
    else
    {
      unint64_t v15 = 0;
    }
    float v16 = &v15[8 * ((v9 - v11) >> 3)];
    long long v17 = *(_OWORD *)v24;
    *(_OWORD *)float v16 = v23;
    *((_OWORD *)v16 + 1) = v17;
    *((_OWORD *)v16 + 2) = *(_OWORD *)&v24[16];
    v16[48] = a4;
    uint8x8_t v10 = v16 + 56;
    if (v9 != v11)
    {
      do
      {
        long long v18 = *(_OWORD *)(v9 - 56);
        long long v19 = *(_OWORD *)(v9 - 40);
        long long v20 = *(_OWORD *)(v9 - 24);
        *(v16 - 8) = *(v9 - 8);
        *(_OWORD *)(v16 - 24) = v20;
        *(_OWORD *)(v16 - 40) = v19;
        *(_OWORD *)(v16 - 5std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = v18;
        v16 -= 56;
        v9 -= 56;
      }
      while (v9 != v11);
      uint64_t v9 = *(char **)(a1 + 496);
    }
    *(void *)(a1 + 49std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = v16;
    *(void *)(a1 + 504) = v10;
    *(void *)(a1 + 512) = &v15[56 * v14];
    if (v9) {
      operator delete(v9);
    }
  }
  else
  {
    *(_OWORD *)uint64_t v9 = v23;
    *((_OWORD *)v9 + 1) = *(_OWORD *)v24;
    *((_OWORD *)v9 + 2) = *(_OWORD *)&v24[16];
    v9[48] = a4;
    uint8x8_t v10 = v9 + 56;
  }
  *(void *)(a1 + 504) = v10;
  long long v23 = *(_OWORD *)a2;
  *(_DWORD *)long long v24 = *(_DWORD *)(a2 + 16);
  char v21 = *(int64x2_t **)a3;
  *(void *)&v24[8] = *(void *)(a3 + 8);
  *(_DWORD *)&v24[16] = *(_DWORD *)(a3 + 16);
  v24[20] = a4;
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  *(void *)&v24[24] = 0;
  return DSPGraph::Box::addPropertyTap(v21, (const DSPGraph::PropertyTap *)&v23);
}

void sub_1901B1EA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  if (a31 < 0) {
    operator delete(a26);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(exception_object);
}

void DSPGraph::Graph::detach(DSPGraph::Graph *this, DSPGraph::Box *a2)
{
  unint64_t v4 = (char *)this + 24;
  uint64_t v5 = (DSPGraph::Box **)((char *)this + 24);
  do
  {
    uint64_t v5 = (DSPGraph::Box **)*v5;
    if (!v5)
    {
      std::string::basic_string[abi:ne180100]<0>(&v47, "/Library/Caches/com.apple.xbs/Sources/CoreAudioServices_AudioToolboxCore/CoreAudioUtility/Source/CADSP/DSPGraph/DSPGraph_Graph.cpp");
      std::string::basic_string[abi:ne180100]<0>(&v46, "detach");
      std::string::basic_string[abi:ne180100]<0>(&v45, "box not in graph");
      DSPGraph::ThrowException(1852204065, &v47, 1310, &v46, &v45);
    }
  }
  while (v5[2] != a2);
  if (*((unsigned char *)this + 761))
  {
    std::string::basic_string[abi:ne180100]<0>(&v47, "/Library/Caches/com.apple.xbs/Sources/CoreAudioServices_AudioToolboxCore/CoreAudioUtility/Source/CADSP/DSPGraph/DSPGraph_Graph.cpp");
    std::string::basic_string[abi:ne180100]<0>(&v46, "detach");
    std::string::basic_string[abi:ne180100]<0>(&v45, "graph is configured");
    DSPGraph::ThrowException(1667655457, &v47, 1314, &v46, &v45);
  }
  for (uint64_t i = (void *)*((void *)this + 29); i; uint64_t i = (void *)*i)
    *(void *)(i[2] + 232) = *(void *)(i[2] + 224);
  *((void *)this + 33) = *((void *)this + 32);
  unint64_t v7 = (DSPGraph::InputPort *)*((void *)a2 + 8);
  unint64_t v8 = (DSPGraph::InputPort *)*((void *)a2 + 9);
  while (v7 != v8)
  {
    DSPGraph::InputPort::detach(v7);
    unint64_t v7 = (DSPGraph::InputPort *)((char *)v7 + 32);
  }
  uint64_t v9 = (void *)*((void *)a2 + 11);
  uint8x8_t v10 = (void *)*((void *)a2 + 12);
  if (v9 == v10)
  {
    uint64_t v14 = *((void *)a2 + 11);
  }
  else
  {
    do
    {
      for (unint64_t j = *(void **)((*(uint64_t (**)(void *))(*v9 + 40))(v9) + 32); j; unint64_t j = (void *)*j)
        *(void *)(j[2] + 1std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
      unint64_t v12 = *(int8x8_t **)(v9[1] + 8);
      unint64_t v13 = (*(uint64_t (**)(void *))(*v9 + 40))(v9);
      DSPGraph::Graph::removeWire(v12, v13);
      v9 += 4;
    }
    while (v9 != v10);
    uint64_t v9 = (void *)*((void *)a2 + 11);
    uint64_t v14 = *((void *)a2 + 12);
  }
  *((void *)a2 + 1) = 0;
  if (((v14 - (void)v9) & 0x1FFFFFFFE0) == 0) {
    std::__hash_table<RegistrarClientProcess *,std::hash<RegistrarClientProcess *>,std::equal_to<RegistrarClientProcess *>,std::allocator<RegistrarClientProcess *>>::__erase_unique<RegistrarClientProcess *>((uint64_t *)this + 41, (unint64_t)a2);
  }
  unint64_t v15 = (*(uint64_t (**)(DSPGraph::Box *))(*(void *)a2 + 248))(a2);
  if (v15)
  {
    int8x8_t v16 = *(int8x8_t *)((char *)this + 376);
    if (v16)
    {
      unint64_t v17 = v15;
      unint64_t v18 = 0x9DDFEA08EB382D69 * (((8 * v15) + 8) ^ HIDWORD(v15));
      unint64_t v19 = 0x9DDFEA08EB382D69 * (HIDWORD(v15) ^ (v18 >> 47) ^ v18);
      unint64_t v20 = 0x9DDFEA08EB382D69 * (v19 ^ (v19 >> 47));
      uint8x8_t v21 = (uint8x8_t)vcnt_s8(v16);
      v21.i16[0] = vaddlv_u8(v21);
      if (v21.u32[0] > 1uLL)
      {
        unint64_t v22 = v20;
        if (v20 >= *(void *)&v16) {
          unint64_t v22 = v20 % *(void *)&v16;
        }
      }
      else
      {
        unint64_t v22 = v20 & (*(void *)&v16 - 1);
      }
      uint64_t v23 = *((void *)this + 46);
      long long v24 = *(void ***)(v23 + 8 * v22);
      if (v24)
      {
        uint64_t v25 = *v24;
        if (*v24)
        {
          uint64_t v26 = *(void *)&v16 - 1;
          do
          {
            unint64_t v27 = v25[1];
            if (v27 == v20)
            {
              if (v25[2] == v17)
              {
                if (v21.u32[0] > 1uLL)
                {
                  if (v20 >= *(void *)&v16) {
                    v20 %= *(void *)&v16;
                  }
                }
                else
                {
                  v20 &= v26;
                }
                long long v28 = *(void **)(v23 + 8 * v20);
                do
                {
                  std::string v29 = v28;
                  long long v28 = (void *)*v28;
                }
                while (v28 != v25);
                if (v29 == (void *)((char *)this + 384)) {
                  goto LABEL_54;
                }
                unint64_t v30 = v29[1];
                if (v21.u32[0] > 1uLL)
                {
                  if (v30 >= *(void *)&v16) {
                    v30 %= *(void *)&v16;
                  }
                }
                else
                {
                  v30 &= v26;
                }
                if (v30 != v20)
                {
LABEL_54:
                  if (!*v25) {
                    goto LABEL_55;
                  }
                  unint64_t v31 = *(void *)(*v25 + 8);
                  if (v21.u32[0] > 1uLL)
                  {
                    if (v31 >= *(void *)&v16) {
                      v31 %= *(void *)&v16;
                    }
                  }
                  else
                  {
                    v31 &= v26;
                  }
                  if (v31 != v20) {
LABEL_55:
                  }
                    *(void *)(v23 + 8 * v20) = 0;
                }
                uint64_t v32 = *v25;
                if (*v25)
                {
                  unint64_t v33 = *(void *)(v32 + 8);
                  if (v21.u32[0] > 1uLL)
                  {
                    if (v33 >= *(void *)&v16) {
                      v33 %= *(void *)&v16;
                    }
                  }
                  else
                  {
                    v33 &= v26;
                  }
                  if (v33 != v20)
                  {
                    *(void *)(*((void *)this + 46) + 8 * v33) = v29;
                    uint64_t v32 = *v25;
                  }
                }
                *std::string v29 = v32;
                *uint64_t v25 = 0;
                --*((void *)this + 49);
                operator delete(v25);
                break;
              }
            }
            else
            {
              if (v21.u32[0] > 1uLL)
              {
                if (v27 >= *(void *)&v16) {
                  v27 %= *(void *)&v16;
                }
              }
              else
              {
                v27 &= v26;
              }
              if (v27 != v22) {
                break;
              }
            }
            uint64_t v25 = (void *)*v25;
          }
          while (v25);
        }
      }
    }
  }
  long long v34 = (char *)*((void *)this + 3);
  if (v34)
  {
    while (*((DSPGraph::Box **)v34 + 2) != a2)
    {
      long long v34 = *(char **)v34;
      if (!v34) {
        return;
      }
    }
    int8x8_t v35 = *(int8x8_t *)((char *)this + 16);
    unint64_t v36 = *((void *)v34 + 1);
    uint8x8_t v37 = (uint8x8_t)vcnt_s8(v35);
    v37.i16[0] = vaddlv_u8(v37);
    if (v37.u32[0] > 1uLL)
    {
      if (v36 >= *(void *)&v35) {
        v36 %= *(void *)&v35;
      }
    }
    else
    {
      v36 &= *(void *)&v35 - 1;
    }
    uint64_t v38 = *((void *)this + 1);
    unint64_t v39 = *(char **)(v38 + 8 * v36);
    do
    {
      unsigned int v40 = v39;
      unint64_t v39 = *(char **)v39;
    }
    while (v39 != v34);
    if (v40 == v4) {
      goto LABEL_85;
    }
    unint64_t v41 = *((void *)v40 + 1);
    if (v37.u32[0] > 1uLL)
    {
      if (v41 >= *(void *)&v35) {
        v41 %= *(void *)&v35;
      }
    }
    else
    {
      v41 &= *(void *)&v35 - 1;
    }
    if (v41 != v36)
    {
LABEL_85:
      if (!*(void *)v34) {
        goto LABEL_86;
      }
      unint64_t v42 = *(void *)(*(void *)v34 + 8);
      if (v37.u32[0] > 1uLL)
      {
        if (v42 >= *(void *)&v35) {
          v42 %= *(void *)&v35;
        }
      }
      else
      {
        v42 &= *(void *)&v35 - 1;
      }
      if (v42 != v36) {
LABEL_86:
      }
        *(void *)(v38 + 8 * v3std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
    }
    float v43 = *(char **)v34;
    if (*(void *)v34)
    {
      unint64_t v44 = *((void *)v43 + 1);
      if (v37.u32[0] > 1uLL)
      {
        if (v44 >= *(void *)&v35) {
          v44 %= *(void *)&v35;
        }
      }
      else
      {
        v44 &= *(void *)&v35 - 1;
      }
      if (v44 != v36)
      {
        *(void *)(*((void *)this + 1) + 8 * v44) = v40;
        float v43 = *(char **)v34;
      }
    }
    *(void *)unsigned int v40 = v43;
    *(void *)long long v34 = 0;
    --*((void *)this + 4);
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::unique_ptr<DSPGraph::Box>,void *>>>::operator()[abi:ne180100](1, v34);
  }
}

void sub_1901B2458(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  _Unwind_Resume(exception_object);
}

void DSPGraph::Graph::addOrderingConstraint(DSPGraph::Graph *this, DSPGraph::Box *a2, DSPGraph::Box *a3)
{
  if (*((unsigned char *)this + 761))
  {
    std::string::basic_string[abi:ne180100]<0>(&v5, "/Library/Caches/com.apple.xbs/Sources/CoreAudioServices_AudioToolboxCore/CoreAudioUtility/Source/CADSP/DSPGraph/DSPGraph_Graph.cpp");
    std::string::basic_string[abi:ne180100]<0>(&v4, "addOrderingConstraint");
    std::string::basic_string[abi:ne180100]<0>(&v3, "graph is configured");
    DSPGraph::ThrowException(1667655457, &v5, 1372, &v4, &v3);
  }
  std::__hash_table<DSPGraph::Box *,std::hash<DSPGraph::Box *>,std::equal_to<DSPGraph::Box *>,std::allocator<DSPGraph::Box *>>::__emplace_unique_key_args<DSPGraph::Box *,DSPGraph::Box * const&>((uint64_t)a2 + 112, (unint64_t)a3, (uint64_t)a3);
}

void sub_1901B2544(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (*(char *)(v21 - 17) < 0) {
    operator delete(*(void **)(v21 - 40));
  }
  _Unwind_Resume(exception_object);
}

uint64_t DSPGraph::Graph::writeDotAttributes(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result != a2)
  {
    uint64_t v5 = result;
    do
    {
      int8x8_t v6 = *(uint64_t **)(*(void *)v5 + 224);
      unint64_t v7 = *(uint64_t **)(*(void *)v5 + 232);
      while (v6 != v7)
      {
        uint64_t v8 = *v6++;
        os_log_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v8 + 496))(v8, a3);
      }
      v5 += 8;
    }
    while (v5 != a2);
  }
  return result;
}

void DSPGraph::Graph::decompile(DSPGraph::Graph *this)
{
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v2);
  DSPGraph::Graph::decompile((uint64_t)this, (const char *)&v2);
}

void sub_1901B276C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void DSPGraph::Graph::decompile(uint64_t a1, const char *a2)
{
  if (*(unsigned char *)(a1 + 761)) {
    DSPGraph::strprintf((DSPGraph *)"; DSP graph definition\n", a2);
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "/Library/Caches/com.apple.xbs/Sources/CoreAudioServices_AudioToolboxCore/CoreAudioUtility/Source/CADSP/DSPGraph/DSPGraph_Graph.cpp");
  std::string::basic_string[abi:ne180100]<0>(v3, "decompile");
  std::string::basic_string[abi:ne180100]<0>(&v2, "configure the graph before decompiling.");
  DSPGraph::ThrowException(1667655457, (long long *)__p, 1421, (long long *)v3, &v2);
}

void sub_1901B3198(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  if (a31 < 0) {
    operator delete(a26);
  }
  _Unwind_Resume(exception_object);
}

void DSPGraph::Graph::decompile(DSPGraph::Graph *this, const char *a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = MEMORY[0x1E4FBA468] + 64;
  uint64_t v9 = MEMORY[0x1E4FBA468] + 64;
  uint64_t v4 = *(void *)(MEMORY[0x1E4FBA400] + 16);
  uint64_t v7 = *(void *)(MEMORY[0x1E4FBA400] + 8);
  *(void *)&v8[*(void *)(v7 - 24) - 8] = v4;
  uint64_t v5 = (std::ios_base *)&v8[*(void *)(v7 - 24) - 8];
  std::ios_base::init(v5, v8);
  uint64_t v6 = MEMORY[0x1E4FBA468] + 24;
  v5[1].__vftable = 0;
  v5[1].__fmtflags_ = -1;
  uint64_t v7 = v6;
  uint64_t v9 = v3;
  MEMORY[0x192FC84D0](v8);
  std::ofstream::open();
  DSPGraph::Graph::decompile((uint64_t)this, (const char *)&v7);
}

void sub_1901B3520(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,char a30)
{
  if (a2)
  {
    unint64_t v31 = __cxa_begin_catch(exception_object);
    if (a2 == 2)
    {
      uint64_t v32 = v31;
      __error();
      std::string::basic_string[abi:ne180100]<0>(&a24, "/Library/Caches/com.apple.xbs/Sources/CoreAudioServices_AudioToolboxCore/CoreAudioUtility/Source/CADSP/DSPGraph/DSPGraph_Graph.cpp");
      std::string::basic_string[abi:ne180100]<0>(&a18, "decompile");
      (*(void (**)(void *))(*(void *)v32 + 16))(v32);
      DSPGraph::strprintf((DSPGraph *)"couldn't open file '%s': %s\n", v33);
    }
    __error();
    std::string::basic_string[abi:ne180100]<0>(&a24, "/Library/Caches/com.apple.xbs/Sources/CoreAudioServices_AudioToolboxCore/CoreAudioUtility/Source/CADSP/DSPGraph/DSPGraph_Graph.cpp");
    std::string::basic_string[abi:ne180100]<0>(&a18, "decompile");
    DSPGraph::strprintf((DSPGraph *)"couldn't open file '%s'\n", v34);
  }
  _Unwind_Resume(exception_object);
}

void *std::ofstream::~ofstream(void *a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA400];
  uint64_t v3 = *MEMORY[0x1E4FBA400];
  *a1 = *MEMORY[0x1E4FBA400];
  *(void *)((char *)a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  MEMORY[0x192FC84E0](a1 + 1);
  std::ostream::~ostream();
  MEMORY[0x192FC8840](a1 + 52);
  return a1;
}

uint64_t DSPGraph::Graph::writeDotFile(DSPGraph::Graph *this, const char *a2, const char *a3)
{
  v16[19] = *MEMORY[0x1E4F143B8];
  if (!*((unsigned char *)this + 761))
  {
    std::string::basic_string[abi:ne180100]<0>(v15, "/Library/Caches/com.apple.xbs/Sources/CoreAudioServices_AudioToolboxCore/CoreAudioUtility/Source/CADSP/DSPGraph/DSPGraph_Graph.cpp");
    std::string::basic_string[abi:ne180100]<0>(&v14, "writeDotFile");
    std::string::basic_string[abi:ne180100]<0>(&__p, "configure the graph before writing a dot file.");
    DSPGraph::ThrowException(1667655457, (long long *)v15, 1546, &v14, &__p);
  }
  uint64_t v5 = MEMORY[0x1E4FBA468] + 64;
  v16[0] = MEMORY[0x1E4FBA468] + 64;
  uint64_t v6 = MEMORY[0x1E4FBA400];
  uint64_t v7 = *(void **)(MEMORY[0x1E4FBA400] + 16);
  v15[0] = *(void **)(MEMORY[0x1E4FBA400] + 8);
  *(void **)((char *)v15 + *((void *)v15[0] - 3)) = v7;
  uint64_t v8 = (std::ios_base *)((char *)v15 + *((void *)v15[0] - 3));
  std::ios_base::init(v8, &v15[1]);
  uint64_t v9 = (void *)(MEMORY[0x1E4FBA468] + 24);
  v8[1].__vftable = 0;
  v8[1].__fmtflags_ = -1;
  v15[0] = v9;
  v16[0] = v5;
  MEMORY[0x192FC84D0](&v15[1]);
  std::ofstream::open();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)"digraph ", 8);
  size_t v10 = strlen(a2);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)a2, v10);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)" {\n", 3);
  DSPGraph::Graph::writeDotAttributes(*((void *)this + 32), *((void *)this + 33), (uint64_t)v15);
  for (uint64_t i = (uint64_t **)*((void *)this + 3); i; uint64_t i = (uint64_t **)*i)
    (*(void (**)(uint64_t *, void **))(*i[2] + 504))(i[2], v15);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)"}\n", 2);
  if (!std::filebuf::close()) {
    std::ios_base::clear((std::ios_base *)((char *)v15 + *((void *)v15[0] - 3)), *(_DWORD *)((char *)&v15[4] + *((void *)v15[0] - 3)) | 4);
  }
  v15[0] = *(void **)v6;
  *(void **)((char *)v15 + *((void *)v15[0] - 3)) = *(void **)(v6 + 24);
  MEMORY[0x192FC84E0](&v15[1]);
  std::ostream::~ostream();
  return MEMORY[0x192FC8840](v16);
}

void sub_1901B3C94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  __cxa_end_catch();
  std::ofstream::~ofstream(&a30);
  _Unwind_Resume(a1);
}

uint64_t DSPGraph::Graph::writeDotFile@<X0>(DSPGraph::Graph *this@<X0>, const char *a2@<X1>, void *a3@<X8>)
{
  if (!*((unsigned char *)this + 761))
  {
    std::string::basic_string[abi:ne180100]<0>(v9, "/Library/Caches/com.apple.xbs/Sources/CoreAudioServices_AudioToolboxCore/CoreAudioUtility/Source/CADSP/DSPGraph/DSPGraph_Graph.cpp");
    std::string::basic_string[abi:ne180100]<0>(&v14, "writeDotFile");
    std::string::basic_string[abi:ne180100]<0>(&v13, "configure the graph before writing a dot file.");
    DSPGraph::ThrowException(1667655457, v9, 1565, &v14, &v13);
  }
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v9);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)"digraph ", 8);
  size_t v6 = strlen(a2);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)a2, v6);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)" {\n", 3);
  DSPGraph::Graph::writeDotAttributes(*((void *)this + 32), *((void *)this + 33), (uint64_t)v9);
  for (uint64_t i = (uint64_t **)*((void *)this + 3); i; uint64_t i = (uint64_t **)*i)
    (*(void (**)(uint64_t *, long long *))(*i[2] + 504))(i[2], v9);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)"}\n", 2);
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>(a3, (uint64_t)v9 + 8);
  *(void *)&v9[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v9 + *(void *)(*(void *)&v9[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  *((void *)&v9[0] + 1) = MEMORY[0x1E4FBA470] + 16;
  if (v11 < 0) {
    operator delete(__p);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x192FC8840](&v12);
}

void sub_1901B3FB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (*(char *)(v15 - 57) < 0) {
    operator delete(*(void **)(v15 - 80));
  }
  if (*(char *)(v15 - 33) < 0) {
    operator delete(*(void **)(v15 - 56));
  }
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t DSPGraph::Graph::setAUStrip()
{
  return 0;
}

uint64_t DSPGraph::Graph::makeAUStrip()
{
  return 0;
}

{
  return 0;
}

void applesauce::CF::details::find_at_key_or_optional<applesauce::CF::ArrayRef,__CFString const* const&>(unsigned char *a1, CFDictionaryRef theDict, const void *a3)
{
  uint64_t v4 = applesauce::CF::details::at_key<__CFString const* const&>(theDict, a3);
  if (!v4) {
    goto LABEL_5;
  }
  uint64_t v5 = v4;
  CFRetain(v4);
  CFTypeID v6 = CFGetTypeID(v5);
  if (v6 != CFArrayGetTypeID())
  {
    CFRelease(v5);
LABEL_5:
    char v7 = 0;
    *a1 = 0;
    goto LABEL_6;
  }
  *(void *)a1 = v5;
  char v7 = 1;
LABEL_6:
  a1[8] = v7;
}

unint64_t applesauce::CF::at_or<unsigned int,__CFString const* const&>(const __CFDictionary *a1, const void *a2, unsigned int *a3)
{
  CFNumberRef v4 = (const __CFNumber *)applesauce::CF::details::at_key<__CFString const* const&>(a1, a2);
  if (!v4) {
    return *a3;
  }
  unint64_t result = (unint64_t)applesauce::CF::convert_as<unsigned int,0>(v4);
  if (HIDWORD(result)) {
    return result;
  }
  else {
    return *a3;
  }
}

void DSPGraph::Graph::makeAUStrip(uint64_t a1@<X0>, unsigned __int8 *a2@<X1>, CFDictionaryRef *a3@<X8>)
{
  Subset = DSPGraph::Graph::getSubset(a1, a2);
  if (Subset)
  {
    uint64_t v5 = Subset;
    uint64_t v21 = 0;
    unint64_t v22 = 0;
    unint64_t v23 = 0;
    std::vector<void const*>::reserve(&v21, (unint64_t)Subset[6]);
    CFTypeID v6 = v5[5];
    if (v6)
    {
      char v7 = v22;
      unint64_t v8 = v23;
      uint64_t v9 = (char *)v21;
      do
      {
        uint64_t v10 = *((void *)v6 + 2);
        if ((unint64_t)v7 >= v8)
        {
          uint64_t v11 = (v7 - v9) >> 3;
          unint64_t v12 = v11 + 1;
          if ((unint64_t)(v11 + 1) >> 61) {
            std::vector<float>::__throw_length_error[abi:ne180100]();
          }
          if ((uint64_t)(v8 - (void)v9) >> 2 > v12) {
            unint64_t v12 = (uint64_t)(v8 - (void)v9) >> 2;
          }
          if (v8 - (unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v13 = v12;
          }
          if (v13) {
            unint64_t v13 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned char *>>(v13);
          }
          else {
            uint64_t v14 = 0;
          }
          uint64_t v15 = (char *)(v13 + 8 * v11);
          *(void *)uint64_t v15 = v10;
          int8x8_t v16 = v15 + 8;
          if (v7 != v9)
          {
            do
            {
              uint64_t v17 = *((void *)v7 - 1);
              v7 -= 8;
              *((void *)v15 - 1) = v17;
              v15 -= 8;
            }
            while (v7 != v9);
            char v7 = v9;
          }
          uint64_t v9 = v15;
          unint64_t v8 = v13 + 8 * v14;
          if (v7) {
            operator delete(v7);
          }
          char v7 = v16;
        }
        else
        {
          *(void *)char v7 = v10;
          v7 += 8;
        }
        CFTypeID v6 = *(unsigned __int8 **)v6;
      }
      while (v6);
      unint64_t v22 = v7;
      unint64_t v23 = v8;
      uint64_t v21 = v9;
    }
    else
    {
      uint64_t v9 = (char *)v21;
      char v7 = v22;
    }
    unint64_t v18 = 126 - 2 * __clz((v7 - v9) >> 3);
    if (v7 == v9) {
      uint64_t v19 = 0;
    }
    else {
      uint64_t v19 = v18;
    }
    std::__introsort<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box *> DSPGraph::GetBoxesSortedByName<DSPGraph::Box *>(std::unordered_set<DSPGraph::Box *> const&)::{lambda(DSPGraph::Box *,DSPGraph::Box *)#1} &,DSPGraph::Box **,false>((uint64_t)v9, (uint64_t *)v7, v19, 1);
    memset(__p, 0, sizeof(__p));
    std::vector<DSPGraph::Box *>::__init_with_size[abi:ne180100]<DSPGraph::Box **,DSPGraph::Box **>(__p, v9, (uint64_t)v7, (v7 - v9) >> 3);
    DSPGraph::stripDictFromBoxes(a3, (uint64_t)__p);
    if (__p[0]) {
      operator delete(__p[0]);
    }
    if (v21) {
      operator delete(v21);
    }
  }
  else
  {
    *a3 = 0;
  }
}

void *std::vector<DSPGraph::Box *>::__init_with_size[abi:ne180100]<DSPGraph::Box **,DSPGraph::Box **>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    CFNumberRef v4 = result;
    if (a4 >> 61) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    unint64_t result = std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned char *>>(a4);
    char v7 = result;
    *CFNumberRef v4 = result;
    v4[1] = result;
    _DWORD v4[2] = &result[v8];
    size_t v9 = a3 - (void)a2;
    if (v9) {
      unint64_t result = memmove(result, a2, v9);
    }
    v4[1] = (char *)v7 + v9;
  }
  return result;
}

void sub_1901B4360(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void DSPGraph::stripDictFromBoxes(CFDictionaryRef *a1, uint64_t a2)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  CFMutableArrayRef theArray = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  CFNumberRef v4 = *(void **)a2;
  uint64_t v3 = *(void **)(a2 + 8);
  if (*(void **)a2 != v3)
  {
    uint64_t v5 = @"subtype";
    do
    {
      if ((*(uint64_t (**)(void))(*(void *)*v4 + 328))(*v4))
      {
        CFRetain(@"type");
        applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&v32, @"type");
        (*(void (**)(void ***__return_ptr))(*(void *)*v4 + 208))(&p_p);
        applesauce::CF::TypeRefPair::TypeRefPair<applesauce::CF::StringRef,unsigned int>(&__p, v32, (int *)&p_p);
        CFRetain(v5);
        applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&v31, v5);
        (*(void (**)(void **__return_ptr))(*(void *)*v4 + 208))(value);
        applesauce::CF::TypeRefPair::TypeRefPair<applesauce::CF::StringRef,unsigned int>(v37, v31, (int *)value + 1);
        CFRetain(@"manufacturer");
        applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&cf, @"manufacturer");
        (*(void (**)(CFTypeRef *__return_ptr))(*(void *)*v4 + 208))(&v27);
        applesauce::CF::TypeRefPair::TypeRefPair<applesauce::CF::StringRef,unsigned int>(v38, cf, v28);
        CFTypeID v6 = v5;
        v33[0] = &__p;
        v33[1] = (CFTypeRef)3;
        CFDictionaryRef CFDictionaryRef = applesauce::CF::details::make_CFDictionaryRef((uint64_t)v33);
        uint64_t v8 = 0;
        v33[2] = CFDictionaryRef;
        do
        {
          size_t v9 = (const void *)v38[v8 + 1];
          if (v9) {
            CFRelease(v9);
          }
          uint64_t v10 = (const void *)v38[v8];
          if (v10) {
            CFRelease(v10);
          }
          v8 -= 2;
        }
        while (v8 != -6);
        if (cf) {
          CFRelease(cf);
        }
        if (v31) {
          CFRelease(v31);
        }
        if (v32) {
          CFRelease(v32);
        }
        CFRetain(@"aupreset");
        applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&v27, @"aupreset");
        (*(void (**)(CFTypeRef *__return_ptr))(*(void *)*v4 + 360))(v33);
        uint64_t v11 = (void *)v27;
        if (v27) {
          CFRetain(v27);
        }
        long long __p = v11;
        CFTypeRef v12 = v33[0];
        if (v33[0]) {
          CFRetain(v33[0]);
        }
        uint64_t v36 = (uint64_t)v12;
        CFRetain(@"displayname");
        applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&v32, @"displayname");
        unint64_t v13 = (void *)(*v4 + 32);
        if (*(char *)(*v4 + 55) < 0) {
          unint64_t v13 = (void *)*v13;
        }
        CFTypeRef v31 = v13;
        applesauce::CF::TypeRefPair::TypeRefPair<applesauce::CF::StringRef,char const*>(v37, v32, (char **)&v31);
        CFRetain(@"bypass");
        applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&cf, @"bypass");
        int v26 = (*(uint64_t (**)(void))(*(void *)*v4 + 48))();
        applesauce::CF::TypeRefPair::TypeRefPair<applesauce::CF::StringRef,unsigned int>(v38, cf, &v26);
        CFRetain(@"unit");
        applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&v25, @"unit");
        CFTypeRef v14 = v25;
        if (v25) {
          CFRetain(v25);
        }
        CFTypeRef v39 = v14;
        if (CFDictionaryRef) {
          CFRetain(CFDictionaryRef);
        }
        CFDictionaryRef v40 = CFDictionaryRef;
        p_p = &__p;
        uint64_t v42 = 4;
        uint64_t v15 = 0;
        value[0] = applesauce::CF::details::make_CFDictionaryRef((uint64_t)&p_p);
        do
        {
          int8x8_t v16 = *(CFDictionaryRef *)((char *)&v40 + v15);
          if (v16) {
            CFRelease(v16);
          }
          uint64_t v17 = *(CFTypeRef *)((char *)&v39 + v15);
          if (v17) {
            CFRelease(v17);
          }
          v15 -= 16;
        }
        while (v15 != -64);
        if (v25) {
          CFRelease(v25);
        }
        uint64_t v5 = v6;
        if (cf) {
          CFRelease(cf);
        }
        if (v32) {
          CFRelease(v32);
        }
        if (v33[0]) {
          CFRelease(v33[0]);
        }
        if (v27) {
          CFRelease(v27);
        }
        CFArrayAppendValue(theArray, value[0]);
        if (value[0]) {
          CFRelease(value[0]);
        }
        if (CFDictionaryRef) {
          CFRelease(CFDictionaryRef);
        }
      }
      ++v4;
    }
    while (v4 != v3);
  }
  CFRetain(@"effects");
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&v27, @"effects");
  CFMutableArrayRef v18 = theArray;
  if (theArray) {
    CFRetain(theArray);
  }
  applesauce::CF::ArrayRef::ArrayRef((applesauce::CF::ArrayRef *)v33, v18);
  uint64_t v19 = (void **)v27;
  if (v27) {
    CFRetain(v27);
  }
  p_p = v19;
  CFTypeRef v20 = v33[0];
  if (v33[0]) {
    CFRetain(v33[0]);
  }
  uint64_t v42 = (uint64_t)v20;
  long long __p = &p_p;
  uint64_t v36 = 1;
  CFDictionaryRef v21 = applesauce::CF::details::make_CFDictionaryRef((uint64_t)&__p);
  value[0] = v21;
  if (v42) {
    CFRelease((CFTypeRef)v42);
  }
  if (p_p) {
    CFRelease(p_p);
  }
  if (v33[0]) {
    CFRelease(v33[0]);
  }
  if (v27) {
    CFRelease(v27);
  }
  CFRetain(v21);
  p_p = (void **)v21;
  std::vector<void const*>::vector(&__p, 1uLL);
  *(void *)long long __p = p_p;
  CFArrayRef CFArray = applesauce::CF::details::make_CFArrayRef<void const*>((const void **)__p, v36);
  if (__p)
  {
    uint64_t v36 = (uint64_t)__p;
    operator delete(__p);
  }
  CFTypeRef v27 = CFArray;
  if (p_p) {
    CFRelease(p_p);
  }
  CFRetain(@"strips");
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)v33, @"strips");
  unint64_t v23 = (void **)v33[0];
  if (v33[0]) {
    CFRetain(v33[0]);
  }
  p_p = v23;
  if (CFArray) {
    CFRetain(CFArray);
  }
  uint64_t v42 = (uint64_t)CFArray;
  long long __p = &p_p;
  uint64_t v36 = 1;
  *a1 = applesauce::CF::details::make_CFDictionaryRef((uint64_t)&__p);
  if (v42) {
    CFRelease((CFTypeRef)v42);
  }
  if (p_p) {
    CFRelease(p_p);
  }
  if (v33[0]) {
    CFRelease(v33[0]);
  }
  if (CFArray) {
    CFRelease(CFArray);
  }
  CFRelease(v21);
  if (v18) {
    CFRelease(v18);
  }
}

void sub_1901B4AC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, char a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,char a27,int a28,__int16 a29,char a30,char a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,void *__p,uint64_t a40)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1901B4CCC()
{
}

void sub_1901B4CE4()
{
}

void sub_1901B4D20()
{
}

void sub_1901B4D40(void *a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x1901B4D54);
  }
  __clang_call_terminate(a1);
}

void *applesauce::CF::TypeRefPair::TypeRefPair<applesauce::CF::StringRef,unsigned int>(void *a1, CFTypeRef cf, int *a3)
{
  if (cf) {
    CFRetain(cf);
  }
  *a1 = cf;
  int valuePtr = *a3;
  CFNumberRef v6 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  a1[1] = v6;
  if (!v6)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  return a1;
}

void sub_1901B4E0C(_Unwind_Exception *a1)
{
  uint64_t v3 = *(const void **)(v1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

const void **applesauce::CF::ObjectRef<__CFArray *>::~ObjectRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box *> DSPGraph::GetBoxesSortedByName<DSPGraph::Box *>(std::unordered_set<DSPGraph::Box *> const&)::{lambda(DSPGraph::Box *,DSPGraph::Box *)#1} &,DSPGraph::Box **,false>(uint64_t result, uint64_t *a2, uint64_t a3, char a4)
{
  uint64_t v8 = (uint64_t *)result;
  while (2)
  {
    uint64_t v145 = a2 - 1;
    long long v146 = a2;
    unint64_t v142 = a2 - 3;
    uint64_t v143 = a2 - 2;
    size_t v9 = v8;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v10 = v9;
          uint64_t v11 = (char *)a2 - (char *)v9;
          uint64_t v12 = a2 - v9;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0:
              case 1:
                return result;
              case 2:
                uint64_t v69 = *v145;
                uint64_t v70 = *v10;
                BOOL v71 = (const char *)(*v145 + 32);
                if (*(char *)(*v145 + 55) < 0) {
                  BOOL v71 = *(const char **)v71;
                }
                int v72 = (const char *)(v70 + 32);
                if (*(char *)(v70 + 55) < 0) {
                  int v72 = *(const char **)v72;
                }
                unint64_t result = strcmp(v71, v72);
                if ((result & 0x80000000) != 0)
                {
                  *uint64_t v10 = v69;
                  *uint64_t v145 = v70;
                }
                break;
              case 3:
                unint64_t result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box *> DSPGraph::GetBoxesSortedByName<DSPGraph::Box *>(std::unordered_set<DSPGraph::Box *> const&)::{lambda(DSPGraph::Box *,DSPGraph::Box *)#1} &,DSPGraph::Box **>(v10, v10 + 1, v145);
                break;
              case 4:
                unint64_t result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box *> DSPGraph::GetBoxesSortedByName<DSPGraph::Box *>(std::unordered_set<DSPGraph::Box *> const&)::{lambda(DSPGraph::Box *,DSPGraph::Box *)#1} &,DSPGraph::Box **>(v10, v10 + 1, v10 + 2, v145);
                break;
              case 5:
                unint64_t result = std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box *> DSPGraph::GetBoxesSortedByName<DSPGraph::Box *>(std::unordered_set<DSPGraph::Box *> const&)::{lambda(DSPGraph::Box *,DSPGraph::Box *)#1} &,DSPGraph::Box **>(v10, v10 + 1, v10 + 2, v10 + 3, v145);
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v11 <= 191)
          {
            int v73 = v10 + 1;
            BOOL v75 = v10 == a2 || v73 == a2;
            if (a4)
            {
              if (!v75)
              {
                uint64_t v76 = 0;
                unint64_t v77 = v10;
                do
                {
                  long long v78 = v73;
                  uint64_t v79 = v77[1];
                  size_t v80 = (const char **)(v79 + 32);
                  unint64_t v81 = (const char *)(v79 + 32);
                  if (*(char *)(v79 + 55) < 0) {
                    unint64_t v81 = *v80;
                  }
                  uint64_t v82 = *v77;
                  unsigned int v83 = (const char *)(*v77 + 32);
                  if (*(char *)(*v77 + 55) < 0) {
                    unsigned int v83 = *(const char **)v83;
                  }
                  unint64_t result = strcmp(v81, v83);
                  if ((result & 0x80000000) != 0)
                  {
                    uint64_t v84 = v76;
                    while (1)
                    {
                      *(uint64_t *)((char *)v10 + v84 + 8) = v82;
                      if (!v84) {
                        break;
                      }
                      uint64_t v85 = (const char *)(v79 + 32);
                      if (*(char *)(v79 + 55) < 0) {
                        uint64_t v85 = *v80;
                      }
                      uint64_t v82 = *(uint64_t *)((char *)v10 + v84 - 8);
                      uint64_t v86 = (const char *)(v82 + 32);
                      if (*(char *)(v82 + 55) < 0) {
                        uint64_t v86 = *(const char **)v86;
                      }
                      unint64_t result = strcmp(v85, v86);
                      v84 -= 8;
                      if ((result & 0x80000000) == 0)
                      {
                        UInt32 v87 = (uint64_t *)((char *)v10 + v84 + 8);
                        goto LABEL_142;
                      }
                    }
                    UInt32 v87 = v10;
LABEL_142:
                    *UInt32 v87 = v79;
                    a2 = v146;
                  }
                  int v73 = v78 + 1;
                  v76 += 8;
                  unint64_t v77 = v78;
                }
                while (v78 + 1 != a2);
              }
            }
            else if (!v75)
            {
              do
              {
                long long v133 = v73;
                uint64_t v134 = v10[1];
                long long v135 = (const char **)(v134 + 32);
                unint64_t v136 = (const char *)(v134 + 32);
                if (*(char *)(v134 + 55) < 0) {
                  unint64_t v136 = *v135;
                }
                uint64_t v137 = *v10;
                unint64_t v138 = (const char *)(*v10 + 32);
                if (*(char *)(*v10 + 55) < 0) {
                  unint64_t v138 = *(const char **)v138;
                }
                unint64_t result = strcmp(v136, v138);
                if ((result & 0x80000000) != 0)
                {
                  unint64_t v139 = v133;
                  do
                  {
                    *unint64_t v139 = v137;
                    uint64_t v140 = (const char *)(v134 + 32);
                    if (*(char *)(v134 + 55) < 0) {
                      uint64_t v140 = *v135;
                    }
                    uint64_t v137 = *(v139 - 2);
                    unint64_t v141 = (const char *)(v137 + 32);
                    if (*(char *)(v137 + 55) < 0) {
                      unint64_t v141 = *(const char **)v141;
                    }
                    unint64_t result = strcmp(v140, v141);
                    --v139;
                  }
                  while ((result & 0x80000000) != 0);
                  *unint64_t v139 = v134;
                }
                int v73 = v133 + 1;
                uint64_t v10 = v133;
              }
              while (v133 + 1 != v146);
            }
            return result;
          }
          int v149 = v10;
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v88 = (unint64_t)(v12 - 2) >> 1;
              int64_t v148 = v88;
              do
              {
                int64_t v89 = v88;
                if (v148 >= v88)
                {
                  uint64_t v90 = (2 * v88) | 1;
                  uint64_t v91 = &v149[v90];
                  if (2 * v88 + 2 < v12)
                  {
                    int v92 = (const char *)(*v91 + 32);
                    if (*(char *)(*v91 + 55) < 0) {
                      int v92 = *(const char **)v92;
                    }
                    uint64_t v93 = v91[1];
                    ++v91;
                    uint64_t v94 = (const char *)(v93 + 32);
                    if (*(char *)(v93 + 55) < 0) {
                      uint64_t v94 = *(const char **)v94;
                    }
                    if (strcmp(v92, v94) < 0) {
                      uint64_t v90 = 2 * v89 + 2;
                    }
                    else {
                      uint64_t v91 = &v149[v90];
                    }
                  }
                  uint64_t v95 = &v149[v89];
                  uint64_t v96 = *v91;
                  uint64_t v97 = *v95;
                  long long v98 = (const char *)(*v91 + 32);
                  if (*(char *)(*v91 + 55) < 0) {
                    long long v98 = *(const char **)v98;
                  }
                  uint64_t v99 = (const char **)(v97 + 32);
                  unsigned int v100 = (const char *)(v97 + 32);
                  if (*(char *)(v97 + 55) < 0) {
                    unsigned int v100 = *v99;
                  }
                  unint64_t result = strcmp(v98, v100);
                  if ((result & 0x80000000) == 0)
                  {
                    do
                    {
                      long long v101 = v91;
                      *uint64_t v95 = v96;
                      if (v148 < v90) {
                        break;
                      }
                      uint64_t v102 = (2 * v90) | 1;
                      uint64_t v91 = &v149[v102];
                      uint64_t v90 = 2 * v90 + 2;
                      if (v90 < v12)
                      {
                        uint64_t v103 = (const char *)(*v91 + 32);
                        if (*(char *)(*v91 + 55) < 0) {
                          uint64_t v103 = *(const char **)v103;
                        }
                        uint64_t v104 = v91[1];
                        ++v91;
                        int v105 = (const char *)(v104 + 32);
                        if (*(char *)(v104 + 55) < 0) {
                          int v105 = *(const char **)v105;
                        }
                        if (strcmp(v103, v105) >= 0)
                        {
                          uint64_t v91 = &v149[v102];
                          uint64_t v90 = v102;
                        }
                      }
                      else
                      {
                        uint64_t v90 = v102;
                      }
                      uint64_t v96 = *v91;
                      long long v106 = (const char *)(*v91 + 32);
                      if (*(char *)(*v91 + 55) < 0) {
                        long long v106 = *(const char **)v106;
                      }
                      uint64_t v107 = (const char *)(v97 + 32);
                      if (*(char *)(v97 + 55) < 0) {
                        uint64_t v107 = *v99;
                      }
                      unint64_t result = strcmp(v106, v107);
                      uint64_t v95 = v101;
                    }
                    while ((result & 0x80000000) == 0);
                    *long long v101 = v97;
                  }
                }
                int64_t v88 = v89 - 1;
              }
              while (v89);
              uint64_t v108 = (unint64_t)v11 >> 3;
              uint64_t v109 = v146;
              uint64_t v110 = v149;
              do
              {
                uint64_t v111 = 0;
                uint64_t v112 = *v110;
                uint64_t v113 = v108 - 2;
                if (v108 < 2) {
                  uint64_t v113 = v108 - 1;
                }
                uint64_t v114 = v113 >> 1;
                do
                {
                  uint64_t v115 = (uint64_t)&v110[v111 + 1];
                  uint64_t v116 = (2 * v111) | 1;
                  uint64_t v117 = 2 * v111 + 2;
                  if (v117 < v108)
                  {
                    uint64_t v118 = (const char *)(*(void *)v115 + 32);
                    if (*(char *)(*(void *)v115 + 55) < 0) {
                      uint64_t v118 = *(const char **)v118;
                    }
                    uint64_t v119 = v110[v111 + 2];
                    uint64_t v120 = (const char *)(v119 + 32);
                    if (*(char *)(v119 + 55) < 0) {
                      uint64_t v120 = *(const char **)v120;
                    }
                    unint64_t result = strcmp(v118, v120);
                    if ((int)result < 0)
                    {
                      v115 += 8;
                      uint64_t v116 = v117;
                    }
                  }
                  *uint64_t v110 = *(void *)v115;
                  uint64_t v110 = (uint64_t *)v115;
                  uint64_t v111 = v116;
                }
                while (v116 <= v114);
                if ((uint64_t *)v115 == --v109)
                {
                  *(void *)uint64_t v115 = v112;
                }
                else
                {
                  *(void *)uint64_t v115 = *v109;
                  *uint64_t v109 = v112;
                  uint64_t v121 = v115 - (void)v149 + 8;
                  if (v121 >= 9)
                  {
                    unint64_t v122 = (unint64_t)((v121 >> 3) - 2) >> 1;
                    long long v123 = &v149[v122];
                    uint64_t v124 = *v123;
                    int v125 = (const char *)(*v123 + 32);
                    if (*(char *)(*v123 + 55) < 0) {
                      int v125 = *(const char **)v125;
                    }
                    uint64_t v126 = *(void *)v115;
                    uint64_t v127 = (const char **)(*(void *)v115 + 32);
                    int v128 = (const char *)v127;
                    if (*(char *)(*(void *)v115 + 55) < 0) {
                      int v128 = *v127;
                    }
                    unint64_t result = strcmp(v125, v128);
                    if ((result & 0x80000000) != 0)
                    {
                      do
                      {
                        unint64_t v129 = v123;
                        *(void *)uint64_t v115 = v124;
                        if (!v122) {
                          break;
                        }
                        unint64_t v122 = (v122 - 1) >> 1;
                        long long v123 = &v149[v122];
                        uint64_t v124 = *v123;
                        uint64_t v130 = (const char *)(*v123 + 32);
                        if (*(char *)(*v123 + 55) < 0) {
                          uint64_t v130 = *(const char **)v130;
                        }
                        unint64_t v131 = (const char *)v127;
                        if (*(char *)(v126 + 55) < 0) {
                          unint64_t v131 = *v127;
                        }
                        unint64_t result = strcmp(v130, v131);
                        uint64_t v115 = (uint64_t)v129;
                      }
                      while ((result & 0x80000000) != 0);
                      uint64_t *v129 = v126;
                    }
                  }
                }
                BOOL v132 = v108-- <= 2;
                uint64_t v110 = v149;
              }
              while (!v132);
            }
            return result;
          }
          unint64_t v13 = (unint64_t)v12 >> 1;
          CFTypeRef v14 = &v10[(unint64_t)v12 >> 1];
          if ((unint64_t)v11 < 0x401)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box *> DSPGraph::GetBoxesSortedByName<DSPGraph::Box *>(std::unordered_set<DSPGraph::Box *> const&)::{lambda(DSPGraph::Box *,DSPGraph::Box *)#1} &,DSPGraph::Box **>(v14, v10, v145);
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box *> DSPGraph::GetBoxesSortedByName<DSPGraph::Box *>(std::unordered_set<DSPGraph::Box *> const&)::{lambda(DSPGraph::Box *,DSPGraph::Box *)#1} &,DSPGraph::Box **>(v10, v14, v145);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box *> DSPGraph::GetBoxesSortedByName<DSPGraph::Box *>(std::unordered_set<DSPGraph::Box *> const&)::{lambda(DSPGraph::Box *,DSPGraph::Box *)#1} &,DSPGraph::Box **>(v10 + 1, v14 - 1, v143);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box *> DSPGraph::GetBoxesSortedByName<DSPGraph::Box *>(std::unordered_set<DSPGraph::Box *> const&)::{lambda(DSPGraph::Box *,DSPGraph::Box *)#1} &,DSPGraph::Box **>(v10 + 2, &v10[v13 + 1], v142);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box *> DSPGraph::GetBoxesSortedByName<DSPGraph::Box *>(std::unordered_set<DSPGraph::Box *> const&)::{lambda(DSPGraph::Box *,DSPGraph::Box *)#1} &,DSPGraph::Box **>(v14 - 1, v14, &v10[v13 + 1]);
            uint64_t v15 = *v10;
            *uint64_t v10 = *v14;
            *CFTypeRef v14 = v15;
          }
          --a3;
          uint64_t v16 = *v10;
          uint64_t v147 = a3;
          if (a4)
          {
            LOBYTE(v17) = *(unsigned char *)(v16 + 55);
            break;
          }
          uint64_t v18 = *(v10 - 1);
          uint64_t v19 = (const char *)(v18 + 32);
          if (*(char *)(v18 + 55) < 0) {
            uint64_t v19 = *(const char **)v19;
          }
          CFTypeRef v20 = (const char **)(v16 + 32);
          int v17 = *(char *)(v16 + 55);
          CFDictionaryRef v21 = (const char *)(v16 + 32);
          if (v17 < 0) {
            CFDictionaryRef v21 = *v20;
          }
          if (strcmp(v19, v21) < 0) {
            break;
          }
          long long v47 = (const char *)(v16 + 32);
          if (v17 < 0) {
            long long v47 = *v20;
          }
          int8x8_t v48 = (const char *)(*v145 + 32);
          if (*(char *)(*v145 + 55) < 0) {
            int8x8_t v48 = *(const char **)v48;
          }
          unint64_t result = strcmp(v47, v48);
          if ((result & 0x80000000) != 0)
          {
            size_t v9 = v10;
            do
            {
              uint64_t v49 = (const char *)(v16 + 32);
              if (v17 < 0) {
                uint64_t v49 = *v20;
              }
              uint64_t v50 = v9[1];
              ++v9;
              uint64_t v51 = (const char *)(v50 + 32);
              if (*(char *)(v50 + 55) < 0) {
                uint64_t v51 = *(const char **)v51;
              }
              unint64_t result = strcmp(v49, v51);
            }
            while ((result & 0x80000000) == 0);
          }
          else
          {
            int64x2_t v52 = v10 + 1;
            do
            {
              size_t v9 = v52;
              if (v52 >= a2) {
                break;
              }
              unint64_t v53 = (const char *)(v16 + 32);
              if (v17 < 0) {
                unint64_t v53 = *v20;
              }
              uint8x8_t v54 = (const char *)(*v52 + 32);
              if (*(char *)(*v52 + 55) < 0) {
                uint8x8_t v54 = *(const char **)v54;
              }
              unint64_t result = strcmp(v53, v54);
              int64x2_t v52 = v9 + 1;
            }
            while ((result & 0x80000000) == 0);
          }
          unint64_t v55 = a2;
          if (v9 < a2)
          {
            unint64_t v55 = a2;
            do
            {
              uint8x8_t v56 = (const char *)(v16 + 32);
              if (v17 < 0) {
                uint8x8_t v56 = *v20;
              }
              uint64_t v57 = *--v55;
              uint64_t v58 = (const char *)(v57 + 32);
              if (*(char *)(v57 + 55) < 0) {
                uint64_t v58 = *(const char **)v58;
              }
              unint64_t result = strcmp(v56, v58);
            }
            while ((result & 0x80000000) != 0);
          }
          if (v9 < v55)
          {
            uint64_t v59 = *v9;
            uint64_t v60 = *v55;
            do
            {
              *size_t v9 = v60;
              uint64_t *v55 = v59;
              int v61 = *(char *)(v16 + 55);
              do
              {
                uint64_t v62 = v9[1];
                ++v9;
                uint64_t v59 = v62;
                unint64_t v63 = (const char *)(v16 + 32);
                if (v61 < 0) {
                  unint64_t v63 = *v20;
                }
                uint64_t v64 = (const char *)(v59 + 32);
                if (*(char *)(v59 + 55) < 0) {
                  uint64_t v64 = *(const char **)v64;
                }
              }
              while ((strcmp(v63, v64) & 0x80000000) == 0);
              do
              {
                uint64_t v65 = *--v55;
                uint64_t v60 = v65;
                uint64_t v66 = (const char *)(v16 + 32);
                if (v61 < 0) {
                  uint64_t v66 = *v20;
                }
                uint64_t v67 = (const char *)(v60 + 32);
                if (*(char *)(v60 + 55) < 0) {
                  uint64_t v67 = *(const char **)v67;
                }
                unint64_t result = strcmp(v66, v67);
              }
              while ((result & 0x80000000) != 0);
            }
            while (v9 < v55);
          }
          uint64_t v68 = v9 - 1;
          BOOL v4 = v9 - 1 >= v10;
          BOOL v5 = v9 - 1 == v10;
          if (v9 - 1 != v10) {
            *uint64_t v10 = *v68;
          }
          a4 = 0;
          *uint64_t v68 = v16;
        }
        unint64_t v22 = (const char **)(v16 + 32);
        unint64_t v23 = v10;
        do
        {
          uint64_t v25 = v23[1];
          ++v23;
          uint64_t v24 = v25;
          int v26 = (const char *)(v25 + 32);
          if (*(char *)(v25 + 55) < 0) {
            int v26 = *(const char **)v26;
          }
          CFTypeRef v27 = (const char *)(v16 + 32);
          if ((v17 & 0x80) != 0) {
            CFTypeRef v27 = *v22;
          }
        }
        while (strcmp(v26, v27) < 0);
        long long v28 = v23 - 1;
        std::string v29 = a2;
        if (v23 - 1 == v10)
        {
          std::string v29 = a2;
          do
          {
            if (v23 >= v29) {
              break;
            }
            uint64_t v33 = *--v29;
            long long v34 = (const char *)(v33 + 32);
            if (*(char *)(v33 + 55) < 0) {
              long long v34 = *(const char **)v34;
            }
            int8x8_t v35 = (const char *)(v16 + 32);
            if ((v17 & 0x80) != 0) {
              int8x8_t v35 = *v22;
            }
          }
          while ((strcmp(v34, v35) & 0x80000000) == 0);
        }
        else
        {
          do
          {
            uint64_t v30 = *--v29;
            CFTypeRef v31 = (const char *)(v30 + 32);
            if (*(char *)(v30 + 55) < 0) {
              CFTypeRef v31 = *(const char **)v31;
            }
            CFTypeRef v32 = (const char *)(v16 + 32);
            if ((v17 & 0x80) != 0) {
              CFTypeRef v32 = *v22;
            }
          }
          while ((strcmp(v31, v32) & 0x80000000) == 0);
        }
        if (v23 < v29)
        {
          uint64_t v36 = *v29;
          uint8x8_t v37 = v23;
          uint64_t v38 = v29;
          do
          {
            *uint8x8_t v37 = v36;
            *uint64_t v38 = v24;
            int v39 = *(char *)(v16 + 55);
            do
            {
              uint64_t v40 = v37[1];
              ++v37;
              uint64_t v24 = v40;
              unint64_t v41 = (const char *)(v40 + 32);
              if (*(char *)(v40 + 55) < 0) {
                unint64_t v41 = *(const char **)v41;
              }
              uint64_t v42 = (const char *)(v16 + 32);
              if (v39 < 0) {
                uint64_t v42 = *v22;
              }
            }
            while (strcmp(v41, v42) < 0);
            long long v28 = v37 - 1;
            do
            {
              uint64_t v43 = *--v38;
              uint64_t v36 = v43;
              unint64_t v44 = (const char *)(v43 + 32);
              if (*(char *)(v43 + 55) < 0) {
                unint64_t v44 = *(const char **)v44;
              }
              long long v45 = (const char *)(v16 + 32);
              if (v39 < 0) {
                long long v45 = *v22;
              }
            }
            while ((strcmp(v44, v45) & 0x80000000) == 0);
          }
          while (v37 < v38);
        }
        uint64_t v8 = v149;
        if (v28 != v149) {
          *int v149 = *v28;
        }
        uint64_t *v28 = v16;
        a2 = v146;
        a3 = v147;
        if (v23 >= v29) {
          break;
        }
LABEL_57:
        unint64_t result = std::__introsort<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box *> DSPGraph::GetBoxesSortedByName<DSPGraph::Box *>(std::unordered_set<DSPGraph::Box *> const&)::{lambda(DSPGraph::Box *,DSPGraph::Box *)#1} &,DSPGraph::Box **,false>(v149, v28, v147, a4 & 1);
        a4 = 0;
        size_t v9 = v28 + 1;
      }
      BOOL v46 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box *> DSPGraph::GetBoxesSortedByName<DSPGraph::Box *>(std::unordered_set<DSPGraph::Box *> const&)::{lambda(DSPGraph::Box *,DSPGraph::Box *)#1} &,DSPGraph::Box **>(v149, v28);
      size_t v9 = v28 + 1;
      unint64_t result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box *> DSPGraph::GetBoxesSortedByName<DSPGraph::Box *>(std::unordered_set<DSPGraph::Box *> const&)::{lambda(DSPGraph::Box *,DSPGraph::Box *)#1} &,DSPGraph::Box **>(v28 + 1, v146);
      if (result) {
        break;
      }
      if (!v46) {
        goto LABEL_57;
      }
    }
    a2 = v28;
    if (!v46) {
      continue;
    }
    return result;
  }
}

uint64_t std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box *> DSPGraph::GetBoxesSortedByName<DSPGraph::Box *>(std::unordered_set<DSPGraph::Box *> const&)::{lambda(DSPGraph::Box *,DSPGraph::Box *)#1} &,DSPGraph::Box **>(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6 = *a2;
  uint64_t v7 = *a1;
  uint64_t v8 = (const char *)(*a2 + 32);
  int v9 = *(char *)(*a2 + 55);
  uint64_t v10 = v8;
  if (v9 < 0) {
    uint64_t v10 = *(const char **)v8;
  }
  uint64_t v11 = (const char *)(v7 + 32);
  uint64_t v12 = (const char *)(v7 + 32);
  if (*(char *)(v7 + 55) < 0) {
    uint64_t v12 = *(const char **)v11;
  }
  int v13 = strcmp(v10, v12);
  uint64_t v14 = *a3;
  uint64_t v15 = (const char *)(*a3 + 32);
  int v16 = *(char *)(*a3 + 55);
  if ((v13 & 0x80000000) == 0)
  {
    if (v16 < 0)
    {
      uint64_t v15 = *(const char **)v15;
      if ((v9 & 0x80000000) == 0) {
        goto LABEL_12;
      }
    }
    else if ((v9 & 0x80000000) == 0)
    {
      goto LABEL_12;
    }
    uint64_t v8 = *(const char **)v8;
LABEL_12:
    uint64_t result = strcmp(v15, v8);
    if ((result & 0x80000000) != 0)
    {
      *a2 = v14;
      *a3 = v6;
      uint64_t v18 = *a2;
      uint64_t v19 = *a1;
      CFTypeRef v20 = (const char *)(*a2 + 32);
      if (*(char *)(*a2 + 55) < 0) {
        CFTypeRef v20 = *(const char **)v20;
      }
      CFDictionaryRef v21 = (const char *)(v19 + 32);
      if (*(char *)(v19 + 55) < 0) {
        CFDictionaryRef v21 = *(const char **)v21;
      }
      uint64_t result = strcmp(v20, v21);
      if ((result & 0x80000000) != 0)
      {
        *a1 = v18;
        *a2 = v19;
      }
    }
    return result;
  }
  if (v16 < 0)
  {
    uint64_t v15 = *(const char **)v15;
    if ((v9 & 0x80000000) == 0) {
      goto LABEL_8;
    }
LABEL_28:
    uint64_t v8 = *(const char **)v8;
    goto LABEL_8;
  }
  if (v9 < 0) {
    goto LABEL_28;
  }
LABEL_8:
  uint64_t result = strcmp(v15, v8);
  if ((result & 0x80000000) != 0)
  {
    *a1 = v14;
LABEL_25:
    *a3 = v7;
    return result;
  }
  *a1 = v6;
  *a2 = v7;
  uint64_t v22 = *a3;
  unint64_t v23 = (const char *)(*a3 + 32);
  if (*(char *)(*a3 + 55) < 0) {
    unint64_t v23 = *(const char **)v23;
  }
  if (*(char *)(v7 + 55) < 0) {
    uint64_t v11 = *(const char **)v11;
  }
  uint64_t result = strcmp(v23, v11);
  if ((result & 0x80000000) != 0)
  {
    *a2 = v22;
    goto LABEL_25;
  }
  return result;
}

uint64_t std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box *> DSPGraph::GetBoxesSortedByName<DSPGraph::Box *>(std::unordered_set<DSPGraph::Box *> const&)::{lambda(DSPGraph::Box *,DSPGraph::Box *)#1} &,DSPGraph::Box **>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box *> DSPGraph::GetBoxesSortedByName<DSPGraph::Box *>(std::unordered_set<DSPGraph::Box *> const&)::{lambda(DSPGraph::Box *,DSPGraph::Box *)#1} &,DSPGraph::Box **>(a1, a2, a3);
  uint64_t v8 = *a4;
  uint64_t v9 = *a3;
  uint64_t v10 = (const char *)(*a4 + 32);
  if (*(char *)(*a4 + 55) < 0) {
    uint64_t v10 = *(const char **)v10;
  }
  uint64_t v11 = (const char *)(v9 + 32);
  if (*(char *)(v9 + 55) < 0) {
    uint64_t v11 = *(const char **)v11;
  }
  uint64_t result = strcmp(v10, v11);
  if ((result & 0x80000000) != 0)
  {
    *a3 = v8;
    *a4 = v9;
    uint64_t v13 = *a3;
    uint64_t v14 = *a2;
    uint64_t v15 = (const char *)(*a3 + 32);
    if (*(char *)(*a3 + 55) < 0) {
      uint64_t v15 = *(const char **)v15;
    }
    int v16 = (const char *)(v14 + 32);
    if (*(char *)(v14 + 55) < 0) {
      int v16 = *(const char **)v16;
    }
    uint64_t result = strcmp(v15, v16);
    if ((result & 0x80000000) != 0)
    {
      *a2 = v13;
      *a3 = v14;
      uint64_t v17 = *a2;
      uint64_t v18 = *a1;
      uint64_t v19 = (const char *)(*a2 + 32);
      if (*(char *)(*a2 + 55) < 0) {
        uint64_t v19 = *(const char **)v19;
      }
      CFTypeRef v20 = (const char *)(v18 + 32);
      if (*(char *)(v18 + 55) < 0) {
        CFTypeRef v20 = *(const char **)v20;
      }
      uint64_t result = strcmp(v19, v20);
      if ((result & 0x80000000) != 0)
      {
        *a1 = v17;
        *a2 = v18;
      }
    }
  }
  return result;
}

uint64_t std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box *> DSPGraph::GetBoxesSortedByName<DSPGraph::Box *>(std::unordered_set<DSPGraph::Box *> const&)::{lambda(DSPGraph::Box *,DSPGraph::Box *)#1} &,DSPGraph::Box **>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box *> DSPGraph::GetBoxesSortedByName<DSPGraph::Box *>(std::unordered_set<DSPGraph::Box *> const&)::{lambda(DSPGraph::Box *,DSPGraph::Box *)#1} &,DSPGraph::Box **>(a1, a2, a3, a4);
  uint64_t v10 = *a5;
  uint64_t v11 = *a4;
  uint64_t v12 = (const char *)(*a5 + 32);
  if (*(char *)(*a5 + 55) < 0) {
    uint64_t v12 = *(const char **)v12;
  }
  uint64_t v13 = (const char *)(v11 + 32);
  if (*(char *)(v11 + 55) < 0) {
    uint64_t v13 = *(const char **)v13;
  }
  uint64_t result = strcmp(v12, v13);
  if ((result & 0x80000000) != 0)
  {
    *a4 = v10;
    *a5 = v11;
    uint64_t v15 = *a4;
    uint64_t v16 = *a3;
    uint64_t v17 = (const char *)(*a4 + 32);
    if (*(char *)(*a4 + 55) < 0) {
      uint64_t v17 = *(const char **)v17;
    }
    uint64_t v18 = (const char *)(v16 + 32);
    if (*(char *)(v16 + 55) < 0) {
      uint64_t v18 = *(const char **)v18;
    }
    uint64_t result = strcmp(v17, v18);
    if ((result & 0x80000000) != 0)
    {
      *a3 = v15;
      *a4 = v16;
      uint64_t v19 = *a3;
      uint64_t v20 = *a2;
      CFDictionaryRef v21 = (const char *)(*a3 + 32);
      if (*(char *)(*a3 + 55) < 0) {
        CFDictionaryRef v21 = *(const char **)v21;
      }
      uint64_t v22 = (const char *)(v20 + 32);
      if (*(char *)(v20 + 55) < 0) {
        uint64_t v22 = *(const char **)v22;
      }
      uint64_t result = strcmp(v21, v22);
      if ((result & 0x80000000) != 0)
      {
        *a2 = v19;
        *a3 = v20;
        uint64_t v23 = *a2;
        uint64_t v24 = *a1;
        uint64_t v25 = (const char *)(*a2 + 32);
        if (*(char *)(*a2 + 55) < 0) {
          uint64_t v25 = *(const char **)v25;
        }
        int v26 = (const char *)(v24 + 32);
        if (*(char *)(v24 + 55) < 0) {
          int v26 = *(const char **)v26;
        }
        uint64_t result = strcmp(v25, v26);
        if ((result & 0x80000000) != 0)
        {
          *a1 = v23;
          *a2 = v24;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box *> DSPGraph::GetBoxesSortedByName<DSPGraph::Box *>(std::unordered_set<DSPGraph::Box *> const&)::{lambda(DSPGraph::Box *,DSPGraph::Box *)#1} &,DSPGraph::Box **>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v6 = *(a2 - 1);
      uint64_t v7 = *a1;
      uint64_t v8 = (const char *)(v6 + 32);
      if (*(char *)(v6 + 55) < 0) {
        uint64_t v8 = *(const char **)v8;
      }
      uint64_t v9 = (const char *)(v7 + 32);
      if (*(char *)(v7 + 55) < 0) {
        uint64_t v9 = *(const char **)v9;
      }
      if (strcmp(v8, v9) < 0)
      {
        *a1 = v6;
        *(a2 - 1) = v7;
      }
      return 1;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box *> DSPGraph::GetBoxesSortedByName<DSPGraph::Box *>(std::unordered_set<DSPGraph::Box *> const&)::{lambda(DSPGraph::Box *,DSPGraph::Box *)#1} &,DSPGraph::Box **>(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box *> DSPGraph::GetBoxesSortedByName<DSPGraph::Box *>(std::unordered_set<DSPGraph::Box *> const&)::{lambda(DSPGraph::Box *,DSPGraph::Box *)#1} &,DSPGraph::Box **>(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box *> DSPGraph::GetBoxesSortedByName<DSPGraph::Box *>(std::unordered_set<DSPGraph::Box *> const&)::{lambda(DSPGraph::Box *,DSPGraph::Box *)#1} &,DSPGraph::Box **>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      uint64_t v10 = a1 + 2;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box *> DSPGraph::GetBoxesSortedByName<DSPGraph::Box *>(std::unordered_set<DSPGraph::Box *> const&)::{lambda(DSPGraph::Box *,DSPGraph::Box *)#1} &,DSPGraph::Box **>(a1, a1 + 1, a1 + 2);
      uint64_t v11 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v12 = 0;
      uint64_t v13 = 24;
      break;
  }
  while (1)
  {
    uint64_t v14 = *v11;
    uint64_t v15 = (const char **)(*v11 + 32);
    uint64_t v16 = (const char *)v15;
    if (*(char *)(*v11 + 55) < 0) {
      uint64_t v16 = *v15;
    }
    uint64_t v17 = *v10;
    uint64_t v18 = (const char *)(v17 + 32);
    if (*(char *)(v17 + 55) < 0) {
      uint64_t v18 = *(const char **)v18;
    }
    if (strcmp(v16, v18) < 0)
    {
      uint64_t v19 = v13;
      while (1)
      {
        *(uint64_t *)((char *)a1 + v19) = v17;
        uint64_t v20 = v19 - 8;
        if (v19 == 8) {
          break;
        }
        CFDictionaryRef v21 = (const char *)v15;
        if (*(char *)(v14 + 55) < 0) {
          CFDictionaryRef v21 = *v15;
        }
        uint64_t v17 = *(uint64_t *)((char *)a1 + v19 - 16);
        uint64_t v22 = (const char *)(v17 + 32);
        if (*(char *)(v17 + 55) < 0) {
          uint64_t v22 = *(const char **)v22;
        }
        int v23 = strcmp(v21, v22);
        uint64_t v19 = v20;
        if ((v23 & 0x80000000) == 0)
        {
          uint64_t v24 = (uint64_t *)((char *)a1 + v20);
          goto LABEL_24;
        }
      }
      uint64_t v24 = a1;
LABEL_24:
      *uint64_t v24 = v14;
      if (++v12 == 8) {
        return v11 + 1 == a2;
      }
    }
    uint64_t v10 = v11;
    v13 += 8;
    if (++v11 == a2) {
      return 1;
    }
  }
}

void DSPGraph::Graph::makeAUStrip(DSPGraph::Graph *this@<X0>, CFDictionaryRef *a2@<X8>)
{
  uint64_t v20 = 0;
  CFDictionaryRef v21 = 0;
  unint64_t v22 = 0;
  std::vector<void const*>::reserve(&v20, *((void *)this + 4));
  uint64_t v4 = (void *)*((void *)this + 3);
  if (v4)
  {
    BOOL v5 = v21;
    unint64_t v6 = v22;
    uint64_t v7 = (char *)v20;
    do
    {
      uint64_t v8 = v4[2];
      if ((unint64_t)v5 >= v6)
      {
        uint64_t v9 = (v5 - v7) >> 3;
        unint64_t v10 = v9 + 1;
        if ((unint64_t)(v9 + 1) >> 61) {
          std::vector<float>::__throw_length_error[abi:ne180100]();
        }
        if ((uint64_t)(v6 - (void)v7) >> 2 > v10) {
          unint64_t v10 = (uint64_t)(v6 - (void)v7) >> 2;
        }
        if (v6 - (unint64_t)v7 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v11 = v10;
        }
        if (v11) {
          unint64_t v11 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned char *>>(v11);
        }
        else {
          uint64_t v12 = 0;
        }
        uint64_t v13 = (char *)(v11 + 8 * v9);
        *(void *)uint64_t v13 = v8;
        uint64_t v14 = v13 + 8;
        if (v5 != v7)
        {
          do
          {
            uint64_t v15 = *((void *)v5 - 1);
            v5 -= 8;
            *((void *)v13 - 1) = v15;
            v13 -= 8;
          }
          while (v5 != v7);
          BOOL v5 = v7;
        }
        uint64_t v7 = v13;
        unint64_t v6 = v11 + 8 * v12;
        if (v5) {
          operator delete(v5);
        }
        BOOL v5 = v14;
      }
      else
      {
        *(void *)BOOL v5 = v8;
        v5 += 8;
      }
      uint64_t v4 = (void *)*v4;
    }
    while (v4);
    CFDictionaryRef v21 = v5;
    unint64_t v22 = v6;
    uint64_t v20 = v7;
  }
  else
  {
    uint64_t v7 = (char *)v20;
    BOOL v5 = v21;
  }
  unint64_t v16 = 126 - 2 * __clz((v5 - v7) >> 3);
  if (v5 == v7) {
    uint64_t v17 = 0;
  }
  else {
    uint64_t v17 = v16;
  }
  std::__introsort<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box*> DSPGraph::GetBoxesSortedByName<std::unique_ptr<DSPGraph::Box>>(std::unordered_set<std::unique_ptr<DSPGraph::Box>> const&)::{lambda(DSPGraph::Box*,DSPGraph::Box*)#1} &,DSPGraph::Box**,false>((uint64_t)v7, (uint64_t *)v5, v17, 1);
  memset(__p, 0, sizeof(__p));
  std::vector<DSPGraph::Box *>::__init_with_size[abi:ne180100]<DSPGraph::Box **,DSPGraph::Box **>(__p, v7, (uint64_t)v5, (v5 - v7) >> 3);
  DSPGraph::stripDictFromBoxes(a2, (uint64_t)__p);
  if (__p[0]) {
    operator delete(__p[0]);
  }
  uint64_t v18 = v20;
  if (v20)
  {
    operator delete(v18);
  }
}

void sub_1901B5F98(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26)
{
  if (v28) {
    operator delete(v28);
  }
  if (v29) {
    operator delete(v29);
  }
  __cxa_begin_catch(a1);
  void *v26 = 0;
  __cxa_end_catch();
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box*> DSPGraph::GetBoxesSortedByName<std::unique_ptr<DSPGraph::Box>>(std::unordered_set<std::unique_ptr<DSPGraph::Box>> const&)::{lambda(DSPGraph::Box*,DSPGraph::Box*)#1} &,DSPGraph::Box**,false>(uint64_t result, uint64_t *a2, uint64_t a3, char a4)
{
  uint64_t v8 = (uint64_t *)result;
  while (2)
  {
    uint64_t v145 = a2 - 1;
    long long v146 = a2;
    unint64_t v142 = a2 - 3;
    uint64_t v143 = a2 - 2;
    uint64_t v9 = v8;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          unint64_t v10 = v9;
          uint64_t v11 = (char *)a2 - (char *)v9;
          uint64_t v12 = a2 - v9;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0:
              case 1:
                return result;
              case 2:
                uint64_t v69 = *v145;
                uint64_t v70 = *v10;
                BOOL v71 = (const char *)(*v145 + 32);
                if (*(char *)(*v145 + 55) < 0) {
                  BOOL v71 = *(const char **)v71;
                }
                int v72 = (const char *)(v70 + 32);
                if (*(char *)(v70 + 55) < 0) {
                  int v72 = *(const char **)v72;
                }
                BOOL result = strcmp(v71, v72);
                if ((result & 0x80000000) != 0)
                {
                  *unint64_t v10 = v69;
                  *uint64_t v145 = v70;
                }
                break;
              case 3:
                BOOL result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box *> DSPGraph::GetBoxesSortedByName<DSPGraph::Box *>(std::unordered_set<DSPGraph::Box *> const&)::{lambda(DSPGraph::Box *,DSPGraph::Box *)#1} &,DSPGraph::Box **>(v10, v10 + 1, v145);
                break;
              case 4:
                BOOL result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box *> DSPGraph::GetBoxesSortedByName<DSPGraph::Box *>(std::unordered_set<DSPGraph::Box *> const&)::{lambda(DSPGraph::Box *,DSPGraph::Box *)#1} &,DSPGraph::Box **>(v10, v10 + 1, v10 + 2, v145);
                break;
              case 5:
                BOOL result = std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box *> DSPGraph::GetBoxesSortedByName<DSPGraph::Box *>(std::unordered_set<DSPGraph::Box *> const&)::{lambda(DSPGraph::Box *,DSPGraph::Box *)#1} &,DSPGraph::Box **>(v10, v10 + 1, v10 + 2, v10 + 3, v145);
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v11 <= 191)
          {
            int v73 = v10 + 1;
            BOOL v75 = v10 == a2 || v73 == a2;
            if (a4)
            {
              if (!v75)
              {
                uint64_t v76 = 0;
                unint64_t v77 = v10;
                do
                {
                  long long v78 = v73;
                  uint64_t v79 = v77[1];
                  size_t v80 = (const char **)(v79 + 32);
                  unint64_t v81 = (const char *)(v79 + 32);
                  if (*(char *)(v79 + 55) < 0) {
                    unint64_t v81 = *v80;
                  }
                  uint64_t v82 = *v77;
                  unsigned int v83 = (const char *)(*v77 + 32);
                  if (*(char *)(*v77 + 55) < 0) {
                    unsigned int v83 = *(const char **)v83;
                  }
                  BOOL result = strcmp(v81, v83);
                  if ((result & 0x80000000) != 0)
                  {
                    uint64_t v84 = v76;
                    while (1)
                    {
                      *(uint64_t *)((char *)v10 + v84 + 8) = v82;
                      if (!v84) {
                        break;
                      }
                      uint64_t v85 = (const char *)(v79 + 32);
                      if (*(char *)(v79 + 55) < 0) {
                        uint64_t v85 = *v80;
                      }
                      uint64_t v82 = *(uint64_t *)((char *)v10 + v84 - 8);
                      uint64_t v86 = (const char *)(v82 + 32);
                      if (*(char *)(v82 + 55) < 0) {
                        uint64_t v86 = *(const char **)v86;
                      }
                      BOOL result = strcmp(v85, v86);
                      v84 -= 8;
                      if ((result & 0x80000000) == 0)
                      {
                        UInt32 v87 = (uint64_t *)((char *)v10 + v84 + 8);
                        goto LABEL_142;
                      }
                    }
                    UInt32 v87 = v10;
LABEL_142:
                    *UInt32 v87 = v79;
                    a2 = v146;
                  }
                  int v73 = v78 + 1;
                  v76 += 8;
                  unint64_t v77 = v78;
                }
                while (v78 + 1 != a2);
              }
            }
            else if (!v75)
            {
              do
              {
                long long v133 = v73;
                uint64_t v134 = v10[1];
                long long v135 = (const char **)(v134 + 32);
                unint64_t v136 = (const char *)(v134 + 32);
                if (*(char *)(v134 + 55) < 0) {
                  unint64_t v136 = *v135;
                }
                uint64_t v137 = *v10;
                unint64_t v138 = (const char *)(*v10 + 32);
                if (*(char *)(*v10 + 55) < 0) {
                  unint64_t v138 = *(const char **)v138;
                }
                BOOL result = strcmp(v136, v138);
                if ((result & 0x80000000) != 0)
                {
                  unint64_t v139 = v133;
                  do
                  {
                    *unint64_t v139 = v137;
                    uint64_t v140 = (const char *)(v134 + 32);
                    if (*(char *)(v134 + 55) < 0) {
                      uint64_t v140 = *v135;
                    }
                    uint64_t v137 = *(v139 - 2);
                    unint64_t v141 = (const char *)(v137 + 32);
                    if (*(char *)(v137 + 55) < 0) {
                      unint64_t v141 = *(const char **)v141;
                    }
                    BOOL result = strcmp(v140, v141);
                    --v139;
                  }
                  while ((result & 0x80000000) != 0);
                  *unint64_t v139 = v134;
                }
                int v73 = v133 + 1;
                unint64_t v10 = v133;
              }
              while (v133 + 1 != v146);
            }
            return result;
          }
          int v149 = v10;
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v88 = (unint64_t)(v12 - 2) >> 1;
              int64_t v148 = v88;
              do
              {
                int64_t v89 = v88;
                if (v148 >= v88)
                {
                  uint64_t v90 = (2 * v88) | 1;
                  uint64_t v91 = &v149[v90];
                  if (2 * v88 + 2 < v12)
                  {
                    int v92 = (const char *)(*v91 + 32);
                    if (*(char *)(*v91 + 55) < 0) {
                      int v92 = *(const char **)v92;
                    }
                    uint64_t v93 = v91[1];
                    ++v91;
                    uint64_t v94 = (const char *)(v93 + 32);
                    if (*(char *)(v93 + 55) < 0) {
                      uint64_t v94 = *(const char **)v94;
                    }
                    if (strcmp(v92, v94) < 0) {
                      uint64_t v90 = 2 * v89 + 2;
                    }
                    else {
                      uint64_t v91 = &v149[v90];
                    }
                  }
                  uint64_t v95 = &v149[v89];
                  uint64_t v96 = *v91;
                  uint64_t v97 = *v95;
                  long long v98 = (const char *)(*v91 + 32);
                  if (*(char *)(*v91 + 55) < 0) {
                    long long v98 = *(const char **)v98;
                  }
                  uint64_t v99 = (const char **)(v97 + 32);
                  unsigned int v100 = (const char *)(v97 + 32);
                  if (*(char *)(v97 + 55) < 0) {
                    unsigned int v100 = *v99;
                  }
                  BOOL result = strcmp(v98, v100);
                  if ((result & 0x80000000) == 0)
                  {
                    do
                    {
                      long long v101 = v91;
                      *uint64_t v95 = v96;
                      if (v148 < v90) {
                        break;
                      }
                      uint64_t v102 = (2 * v90) | 1;
                      uint64_t v91 = &v149[v102];
                      uint64_t v90 = 2 * v90 + 2;
                      if (v90 < v12)
                      {
                        uint64_t v103 = (const char *)(*v91 + 32);
                        if (*(char *)(*v91 + 55) < 0) {
                          uint64_t v103 = *(const char **)v103;
                        }
                        uint64_t v104 = v91[1];
                        ++v91;
                        int v105 = (const char *)(v104 + 32);
                        if (*(char *)(v104 + 55) < 0) {
                          int v105 = *(const char **)v105;
                        }
                        if (strcmp(v103, v105) >= 0)
                        {
                          uint64_t v91 = &v149[v102];
                          uint64_t v90 = v102;
                        }
                      }
                      else
                      {
                        uint64_t v90 = v102;
                      }
                      uint64_t v96 = *v91;
                      long long v106 = (const char *)(*v91 + 32);
                      if (*(char *)(*v91 + 55) < 0) {
                        long long v106 = *(const char **)v106;
                      }
                      uint64_t v107 = (const char *)(v97 + 32);
                      if (*(char *)(v97 + 55) < 0) {
                        uint64_t v107 = *v99;
                      }
                      BOOL result = strcmp(v106, v107);
                      uint64_t v95 = v101;
                    }
                    while ((result & 0x80000000) == 0);
                    *long long v101 = v97;
                  }
                }
                int64_t v88 = v89 - 1;
              }
              while (v89);
              uint64_t v108 = (unint64_t)v11 >> 3;
              uint64_t v109 = v146;
              uint64_t v110 = v149;
              do
              {
                uint64_t v111 = 0;
                uint64_t v112 = *v110;
                uint64_t v113 = v108 - 2;
                if (v108 < 2) {
                  uint64_t v113 = v108 - 1;
                }
                uint64_t v114 = v113 >> 1;
                do
                {
                  uint64_t v115 = (uint64_t)&v110[v111 + 1];
                  uint64_t v116 = (2 * v111) | 1;
                  uint64_t v117 = 2 * v111 + 2;
                  if (v117 < v108)
                  {
                    uint64_t v118 = (const char *)(*(void *)v115 + 32);
                    if (*(char *)(*(void *)v115 + 55) < 0) {
                      uint64_t v118 = *(const char **)v118;
                    }
                    uint64_t v119 = v110[v111 + 2];
                    uint64_t v120 = (const char *)(v119 + 32);
                    if (*(char *)(v119 + 55) < 0) {
                      uint64_t v120 = *(const char **)v120;
                    }
                    BOOL result = strcmp(v118, v120);
                    if ((int)result < 0)
                    {
                      v115 += 8;
                      uint64_t v116 = v117;
                    }
                  }
                  *uint64_t v110 = *(void *)v115;
                  uint64_t v110 = (uint64_t *)v115;
                  uint64_t v111 = v116;
                }
                while (v116 <= v114);
                if ((uint64_t *)v115 == --v109)
                {
                  *(void *)uint64_t v115 = v112;
                }
                else
                {
                  *(void *)uint64_t v115 = *v109;
                  *uint64_t v109 = v112;
                  uint64_t v121 = v115 - (void)v149 + 8;
                  if (v121 >= 9)
                  {
                    unint64_t v122 = (unint64_t)((v121 >> 3) - 2) >> 1;
                    long long v123 = &v149[v122];
                    uint64_t v124 = *v123;
                    int v125 = (const char *)(*v123 + 32);
                    if (*(char *)(*v123 + 55) < 0) {
                      int v125 = *(const char **)v125;
                    }
                    uint64_t v126 = *(void *)v115;
                    uint64_t v127 = (const char **)(*(void *)v115 + 32);
                    int v128 = (const char *)v127;
                    if (*(char *)(*(void *)v115 + 55) < 0) {
                      int v128 = *v127;
                    }
                    BOOL result = strcmp(v125, v128);
                    if ((result & 0x80000000) != 0)
                    {
                      do
                      {
                        unint64_t v129 = v123;
                        *(void *)uint64_t v115 = v124;
                        if (!v122) {
                          break;
                        }
                        unint64_t v122 = (v122 - 1) >> 1;
                        long long v123 = &v149[v122];
                        uint64_t v124 = *v123;
                        uint64_t v130 = (const char *)(*v123 + 32);
                        if (*(char *)(*v123 + 55) < 0) {
                          uint64_t v130 = *(const char **)v130;
                        }
                        unint64_t v131 = (const char *)v127;
                        if (*(char *)(v126 + 55) < 0) {
                          unint64_t v131 = *v127;
                        }
                        BOOL result = strcmp(v130, v131);
                        uint64_t v115 = (uint64_t)v129;
                      }
                      while ((result & 0x80000000) != 0);
                      uint64_t *v129 = v126;
                    }
                  }
                }
                BOOL v132 = v108-- <= 2;
                uint64_t v110 = v149;
              }
              while (!v132);
            }
            return result;
          }
          unint64_t v13 = (unint64_t)v12 >> 1;
          uint64_t v14 = &v10[(unint64_t)v12 >> 1];
          if ((unint64_t)v11 < 0x401)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box *> DSPGraph::GetBoxesSortedByName<DSPGraph::Box *>(std::unordered_set<DSPGraph::Box *> const&)::{lambda(DSPGraph::Box *,DSPGraph::Box *)#1} &,DSPGraph::Box **>(v14, v10, v145);
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box *> DSPGraph::GetBoxesSortedByName<DSPGraph::Box *>(std::unordered_set<DSPGraph::Box *> const&)::{lambda(DSPGraph::Box *,DSPGraph::Box *)#1} &,DSPGraph::Box **>(v10, v14, v145);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box *> DSPGraph::GetBoxesSortedByName<DSPGraph::Box *>(std::unordered_set<DSPGraph::Box *> const&)::{lambda(DSPGraph::Box *,DSPGraph::Box *)#1} &,DSPGraph::Box **>(v10 + 1, v14 - 1, v143);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box *> DSPGraph::GetBoxesSortedByName<DSPGraph::Box *>(std::unordered_set<DSPGraph::Box *> const&)::{lambda(DSPGraph::Box *,DSPGraph::Box *)#1} &,DSPGraph::Box **>(v10 + 2, &v10[v13 + 1], v142);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box *> DSPGraph::GetBoxesSortedByName<DSPGraph::Box *>(std::unordered_set<DSPGraph::Box *> const&)::{lambda(DSPGraph::Box *,DSPGraph::Box *)#1} &,DSPGraph::Box **>(v14 - 1, v14, &v10[v13 + 1]);
            uint64_t v15 = *v10;
            *unint64_t v10 = *v14;
            *uint64_t v14 = v15;
          }
          --a3;
          uint64_t v16 = *v10;
          uint64_t v147 = a3;
          if (a4)
          {
            LOBYTE(v17) = *(unsigned char *)(v16 + 55);
            break;
          }
          uint64_t v18 = *(v10 - 1);
          uint64_t v19 = (const char *)(v18 + 32);
          if (*(char *)(v18 + 55) < 0) {
            uint64_t v19 = *(const char **)v19;
          }
          uint64_t v20 = (const char **)(v16 + 32);
          int v17 = *(char *)(v16 + 55);
          CFDictionaryRef v21 = (const char *)(v16 + 32);
          if (v17 < 0) {
            CFDictionaryRef v21 = *v20;
          }
          if (strcmp(v19, v21) < 0) {
            break;
          }
          long long v47 = (const char *)(v16 + 32);
          if (v17 < 0) {
            long long v47 = *v20;
          }
          int8x8_t v48 = (const char *)(*v145 + 32);
          if (*(char *)(*v145 + 55) < 0) {
            int8x8_t v48 = *(const char **)v48;
          }
          BOOL result = strcmp(v47, v48);
          if ((result & 0x80000000) != 0)
          {
            uint64_t v9 = v10;
            do
            {
              uint64_t v49 = (const char *)(v16 + 32);
              if (v17 < 0) {
                uint64_t v49 = *v20;
              }
              uint64_t v50 = v9[1];
              ++v9;
              uint64_t v51 = (const char *)(v50 + 32);
              if (*(char *)(v50 + 55) < 0) {
                uint64_t v51 = *(const char **)v51;
              }
              BOOL result = strcmp(v49, v51);
            }
            while ((result & 0x80000000) == 0);
          }
          else
          {
            int64x2_t v52 = v10 + 1;
            do
            {
              uint64_t v9 = v52;
              if (v52 >= a2) {
                break;
              }
              unint64_t v53 = (const char *)(v16 + 32);
              if (v17 < 0) {
                unint64_t v53 = *v20;
              }
              uint8x8_t v54 = (const char *)(*v52 + 32);
              if (*(char *)(*v52 + 55) < 0) {
                uint8x8_t v54 = *(const char **)v54;
              }
              BOOL result = strcmp(v53, v54);
              int64x2_t v52 = v9 + 1;
            }
            while ((result & 0x80000000) == 0);
          }
          unint64_t v55 = a2;
          if (v9 < a2)
          {
            unint64_t v55 = a2;
            do
            {
              uint8x8_t v56 = (const char *)(v16 + 32);
              if (v17 < 0) {
                uint8x8_t v56 = *v20;
              }
              uint64_t v57 = *--v55;
              uint64_t v58 = (const char *)(v57 + 32);
              if (*(char *)(v57 + 55) < 0) {
                uint64_t v58 = *(const char **)v58;
              }
              BOOL result = strcmp(v56, v58);
            }
            while ((result & 0x80000000) != 0);
          }
          if (v9 < v55)
          {
            uint64_t v59 = *v9;
            uint64_t v60 = *v55;
            do
            {
              *uint64_t v9 = v60;
              uint64_t *v55 = v59;
              int v61 = *(char *)(v16 + 55);
              do
              {
                uint64_t v62 = v9[1];
                ++v9;
                uint64_t v59 = v62;
                unint64_t v63 = (const char *)(v16 + 32);
                if (v61 < 0) {
                  unint64_t v63 = *v20;
                }
                uint64_t v64 = (const char *)(v59 + 32);
                if (*(char *)(v59 + 55) < 0) {
                  uint64_t v64 = *(const char **)v64;
                }
              }
              while ((strcmp(v63, v64) & 0x80000000) == 0);
              do
              {
                uint64_t v65 = *--v55;
                uint64_t v60 = v65;
                uint64_t v66 = (const char *)(v16 + 32);
                if (v61 < 0) {
                  uint64_t v66 = *v20;
                }
                uint64_t v67 = (const char *)(v60 + 32);
                if (*(char *)(v60 + 55) < 0) {
                  uint64_t v67 = *(const char **)v67;
                }
                BOOL result = strcmp(v66, v67);
              }
              while ((result & 0x80000000) != 0);
            }
            while (v9 < v55);
          }
          uint64_t v68 = v9 - 1;
          BOOL v4 = v9 - 1 >= v10;
          BOOL v5 = v9 - 1 == v10;
          if (v9 - 1 != v10) {
            *unint64_t v10 = *v68;
          }
          a4 = 0;
          *uint64_t v68 = v16;
        }
        unint64_t v22 = (const char **)(v16 + 32);
        int v23 = v10;
        do
        {
          uint64_t v25 = v23[1];
          ++v23;
          uint64_t v24 = v25;
          int v26 = (const char *)(v25 + 32);
          if (*(char *)(v25 + 55) < 0) {
            int v26 = *(const char **)v26;
          }
          CFTypeRef v27 = (const char *)(v16 + 32);
          if ((v17 & 0x80) != 0) {
            CFTypeRef v27 = *v22;
          }
        }
        while (strcmp(v26, v27) < 0);
        long long v28 = v23 - 1;
        std::string v29 = a2;
        if (v23 - 1 == v10)
        {
          std::string v29 = a2;
          do
          {
            if (v23 >= v29) {
              break;
            }
            uint64_t v33 = *--v29;
            long long v34 = (const char *)(v33 + 32);
            if (*(char *)(v33 + 55) < 0) {
              long long v34 = *(const char **)v34;
            }
            int8x8_t v35 = (const char *)(v16 + 32);
            if ((v17 & 0x80) != 0) {
              int8x8_t v35 = *v22;
            }
          }
          while ((strcmp(v34, v35) & 0x80000000) == 0);
        }
        else
        {
          do
          {
            uint64_t v30 = *--v29;
            CFTypeRef v31 = (const char *)(v30 + 32);
            if (*(char *)(v30 + 55) < 0) {
              CFTypeRef v31 = *(const char **)v31;
            }
            CFTypeRef v32 = (const char *)(v16 + 32);
            if ((v17 & 0x80) != 0) {
              CFTypeRef v32 = *v22;
            }
          }
          while ((strcmp(v31, v32) & 0x80000000) == 0);
        }
        if (v23 < v29)
        {
          uint64_t v36 = *v29;
          uint8x8_t v37 = v23;
          uint64_t v38 = v29;
          do
          {
            *uint8x8_t v37 = v36;
            *uint64_t v38 = v24;
            int v39 = *(char *)(v16 + 55);
            do
            {
              uint64_t v40 = v37[1];
              ++v37;
              uint64_t v24 = v40;
              unint64_t v41 = (const char *)(v40 + 32);
              if (*(char *)(v40 + 55) < 0) {
                unint64_t v41 = *(const char **)v41;
              }
              uint64_t v42 = (const char *)(v16 + 32);
              if (v39 < 0) {
                uint64_t v42 = *v22;
              }
            }
            while (strcmp(v41, v42) < 0);
            long long v28 = v37 - 1;
            do
            {
              uint64_t v43 = *--v38;
              uint64_t v36 = v43;
              unint64_t v44 = (const char *)(v43 + 32);
              if (*(char *)(v43 + 55) < 0) {
                unint64_t v44 = *(const char **)v44;
              }
              long long v45 = (const char *)(v16 + 32);
              if (v39 < 0) {
                long long v45 = *v22;
              }
            }
            while ((strcmp(v44, v45) & 0x80000000) == 0);
          }
          while (v37 < v38);
        }
        uint64_t v8 = v149;
        if (v28 != v149) {
          *int v149 = *v28;
        }
        uint64_t *v28 = v16;
        a2 = v146;
        a3 = v147;
        if (v23 >= v29) {
          break;
        }
LABEL_57:
        BOOL result = std::__introsort<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box*> DSPGraph::GetBoxesSortedByName<std::unique_ptr<DSPGraph::Box>>(std::unordered_set<std::unique_ptr<DSPGraph::Box>> const&)::{lambda(DSPGraph::Box*,DSPGraph::Box*)#1} &,DSPGraph::Box**,false>(v149, v28, v147, a4 & 1);
        a4 = 0;
        uint64_t v9 = v28 + 1;
      }
      BOOL v46 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box*> DSPGraph::GetBoxesSortedByName<std::unique_ptr<DSPGraph::Box>>(std::unordered_set<std::unique_ptr<DSPGraph::Box>> const&)::{lambda(DSPGraph::Box*,DSPGraph::Box*)#1} &,DSPGraph::Box**>(v149, v28);
      uint64_t v9 = v28 + 1;
      BOOL result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box*> DSPGraph::GetBoxesSortedByName<std::unique_ptr<DSPGraph::Box>>(std::unordered_set<std::unique_ptr<DSPGraph::Box>> const&)::{lambda(DSPGraph::Box*,DSPGraph::Box*)#1} &,DSPGraph::Box**>(v28 + 1, v146);
      if (result) {
        break;
      }
      if (!v46) {
        goto LABEL_57;
      }
    }
    a2 = v28;
    if (!v46) {
      continue;
    }
    return result;
  }
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box*> DSPGraph::GetBoxesSortedByName<std::unique_ptr<DSPGraph::Box>>(std::unordered_set<std::unique_ptr<DSPGraph::Box>> const&)::{lambda(DSPGraph::Box*,DSPGraph::Box*)#1} &,DSPGraph::Box**>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v6 = *(a2 - 1);
      uint64_t v7 = *a1;
      uint64_t v8 = (const char *)(v6 + 32);
      if (*(char *)(v6 + 55) < 0) {
        uint64_t v8 = *(const char **)v8;
      }
      uint64_t v9 = (const char *)(v7 + 32);
      if (*(char *)(v7 + 55) < 0) {
        uint64_t v9 = *(const char **)v9;
      }
      if (strcmp(v8, v9) < 0)
      {
        *a1 = v6;
        *(a2 - 1) = v7;
      }
      return 1;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box *> DSPGraph::GetBoxesSortedByName<DSPGraph::Box *>(std::unordered_set<DSPGraph::Box *> const&)::{lambda(DSPGraph::Box *,DSPGraph::Box *)#1} &,DSPGraph::Box **>(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box *> DSPGraph::GetBoxesSortedByName<DSPGraph::Box *>(std::unordered_set<DSPGraph::Box *> const&)::{lambda(DSPGraph::Box *,DSPGraph::Box *)#1} &,DSPGraph::Box **>(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box *> DSPGraph::GetBoxesSortedByName<DSPGraph::Box *>(std::unordered_set<DSPGraph::Box *> const&)::{lambda(DSPGraph::Box *,DSPGraph::Box *)#1} &,DSPGraph::Box **>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      unint64_t v10 = a1 + 2;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<DSPGraph::Box *> DSPGraph::GetBoxesSortedByName<DSPGraph::Box *>(std::unordered_set<DSPGraph::Box *> const&)::{lambda(DSPGraph::Box *,DSPGraph::Box *)#1} &,DSPGraph::Box **>(a1, a1 + 1, a1 + 2);
      uint64_t v11 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v12 = 0;
      uint64_t v13 = 24;
      break;
  }
  while (1)
  {
    uint64_t v14 = *v11;
    uint64_t v15 = (const char **)(*v11 + 32);
    uint64_t v16 = (const char *)v15;
    if (*(char *)(*v11 + 55) < 0) {
      uint64_t v16 = *v15;
    }
    uint64_t v17 = *v10;
    uint64_t v18 = (const char *)(v17 + 32);
    if (*(char *)(v17 + 55) < 0) {
      uint64_t v18 = *(const char **)v18;
    }
    if (strcmp(v16, v18) < 0)
    {
      uint64_t v19 = v13;
      while (1)
      {
        *(uint64_t *)((char *)a1 + v19) = v17;
        uint64_t v20 = v19 - 8;
        if (v19 == 8) {
          break;
        }
        CFDictionaryRef v21 = (const char *)v15;
        if (*(char *)(v14 + 55) < 0) {
          CFDictionaryRef v21 = *v15;
        }
        uint64_t v17 = *(uint64_t *)((char *)a1 + v19 - 16);
        unint64_t v22 = (const char *)(v17 + 32);
        if (*(char *)(v17 + 55) < 0) {
          unint64_t v22 = *(const char **)v22;
        }
        int v23 = strcmp(v21, v22);
        uint64_t v19 = v20;
        if ((v23 & 0x80000000) == 0)
        {
          uint64_t v24 = (uint64_t *)((char *)a1 + v20);
          goto LABEL_24;
        }
      }
      uint64_t v24 = a1;
LABEL_24:
      *uint64_t v24 = v14;
      if (++v12 == 8) {
        return v11 + 1 == a2;
      }
    }
    unint64_t v10 = v11;
    v13 += 8;
    if (++v11 == a2) {
      return 1;
    }
  }
}

void DSPGraph::Graph::setPropertyStrip(DSPGraph::Graph *this, const __CFDictionary *a2)
{
}

void *applesauce::CF::StringRef::operator->(void *result)
{
  if (!*result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(exception);
  }
  return result;
}

void sub_1901B6C4C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

double applesauce::CF::StringRef_proxy::convert_or(std::string *a1, const __CFString *a2, uint64_t a3)
{
  if (*(char *)(a3 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
  }
  else {
    std::string __p = *(std::string *)a3;
  }
  if (a2 && (CFTypeID TypeID = CFStringGetTypeID(), TypeID == CFGetTypeID(a2)))
  {
    applesauce::CF::details::CFString_get_value<false>((uint64_t)a1, a2);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      uint64_t v7 = (void *)__p.__r_.__value_.__r.__words[0];
      operator delete(v7);
    }
  }
  else
  {
    double result = *(double *)&__p.__r_.__value_.__l.__data_;
    *a1 = __p;
  }
  return result;
}

const void **applesauce::CF::ObjectRef<void const*>::~ObjectRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

const void **applesauce::CF::ObjectRef<__CFReadStream *>::~ObjectRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

const __CFNumber *applesauce::CF::convert_as<unsigned long long,0>(const __CFNumber *result)
{
  if (result)
  {
    CFNumberRef v1 = result;
    CFTypeID TypeID = CFNumberGetTypeID();
    if (TypeID == CFGetTypeID(v1))
    {
      switch(CFNumberGetType(v1))
      {
        case kCFNumberSInt8Type:
          LOBYTE(valuePtr) = 0;
          int Value = CFNumberGetValue(v1, kCFNumberSInt8Type, &valuePtr);
          goto LABEL_16;
        case kCFNumberSInt16Type:
          LOWORD(valuePtr) = 0;
          int v7 = CFNumberGetValue(v1, kCFNumberSInt16Type, &valuePtr);
          goto LABEL_24;
        case kCFNumberSInt32Type:
          LODWORD(valuePtr) = 0;
          int v8 = CFNumberGetValue(v1, kCFNumberSInt32Type, &valuePtr);
          goto LABEL_26;
        case kCFNumberSInt64Type:
          double valuePtr = 0.0;
          int v9 = CFNumberGetValue(v1, kCFNumberSInt64Type, &valuePtr);
          goto LABEL_37;
        case kCFNumberFloat32Type:
          LODWORD(valuePtr) = 0;
          int v10 = CFNumberGetValue(v1, kCFNumberFloat32Type, &valuePtr);
          goto LABEL_33;
        case kCFNumberFloat64Type:
          double valuePtr = 0.0;
          int v11 = CFNumberGetValue(v1, kCFNumberFloat64Type, &valuePtr);
          goto LABEL_39;
        case kCFNumberCharType:
          LOBYTE(valuePtr) = 0;
          int Value = CFNumberGetValue(v1, kCFNumberCharType, &valuePtr);
LABEL_16:
          if (Value) {
            char v12 = LOBYTE(valuePtr);
          }
          else {
            char v12 = 0;
          }
          if (Value != 0 && SLOBYTE(valuePtr) < 0) {
            unint64_t v5 = -256;
          }
          else {
            unint64_t v5 = 0;
          }
          LOBYTE(vstd::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = v12;
          return (const __CFNumber *)(v6 | v5);
        case kCFNumberShortType:
          LOWORD(valuePtr) = 0;
          int v7 = CFNumberGetValue(v1, kCFNumberShortType, &valuePtr);
LABEL_24:
          BOOL v13 = v7 == 0;
          unsigned __int8 v14 = LOBYTE(valuePtr);
          uint64_t v15 = SLOWORD(valuePtr);
          goto LABEL_27;
        case kCFNumberIntType:
          LODWORD(valuePtr) = 0;
          int v8 = CFNumberGetValue(v1, kCFNumberIntType, &valuePtr);
LABEL_26:
          BOOL v13 = v8 == 0;
          unsigned __int8 v14 = LOBYTE(valuePtr);
          uint64_t v15 = SLODWORD(valuePtr);
LABEL_27:
          unint64_t v16 = v15 & 0xFFFFFFFFFFFFFF00 | v14;
          if (v13) {
            unint64_t v6 = 0;
          }
          else {
            unint64_t v6 = v16;
          }
          goto LABEL_43;
        case kCFNumberLongType:
          double valuePtr = 0.0;
          int v9 = CFNumberGetValue(v1, kCFNumberLongType, &valuePtr);
          goto LABEL_37;
        case kCFNumberLongLongType:
          double valuePtr = 0.0;
          int v9 = CFNumberGetValue(v1, kCFNumberLongLongType, &valuePtr);
          goto LABEL_37;
        case kCFNumberFloatType:
          LODWORD(valuePtr) = 0;
          int v10 = CFNumberGetValue(v1, kCFNumberFloatType, &valuePtr);
LABEL_33:
          BOOL v17 = v10 == 0;
          unint64_t v6 = (unint64_t)*(float *)&valuePtr;
          goto LABEL_40;
        case kCFNumberDoubleType:
          double valuePtr = 0.0;
          int v11 = CFNumberGetValue(v1, kCFNumberDoubleType, &valuePtr);
          goto LABEL_39;
        case kCFNumberCFIndexType:
          double valuePtr = 0.0;
          int v9 = CFNumberGetValue(v1, kCFNumberCFIndexType, &valuePtr);
          goto LABEL_37;
        case kCFNumberNSIntegerType:
          double valuePtr = 0.0;
          int v9 = CFNumberGetValue(v1, kCFNumberNSIntegerType, &valuePtr);
LABEL_37:
          BOOL v17 = v9 == 0;
          unint64_t v6 = *(void *)&valuePtr;
          goto LABEL_40;
        case kCFNumberCGFloatType:
          double valuePtr = 0.0;
          int v11 = CFNumberGetValue(v1, kCFNumberCGFloatType, &valuePtr);
LABEL_39:
          BOOL v17 = v11 == 0;
          unint64_t v6 = (unint64_t)valuePtr;
LABEL_40:
          if (v17) {
            unint64_t v6 = 0;
          }
LABEL_43:
          unint64_t v5 = v6 & 0xFFFFFFFFFFFFFF00;
          break;
        default:
          unint64_t v5 = 0;
          LOBYTE(vstd::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
          break;
      }
      return (const __CFNumber *)(v6 | v5);
    }
    else
    {
      CFTypeID v4 = CFBooleanGetTypeID();
      if (v4 == CFGetTypeID(v1)) {
        return (const __CFNumber *)CFBooleanGetValue(v1);
      }
      else {
        return 0;
      }
    }
  }
  return result;
}

void DSPGraph::Graph::GraphProperty::~GraphProperty(DSPGraph::Graph::GraphProperty *this)
{
  uint64_t v2 = (void *)*((void *)this + 6);
  if (v2)
  {
    *((void *)this + 7) = v2;
    operator delete(v2);
  }
  if (*((unsigned char *)this + 32))
  {
    uint64_t v3 = (void *)*((void *)this + 1);
    if (v3)
    {
      *((void *)this + 2) = v3;
      operator delete(v3);
    }
  }
}

double DSPGraph::Graph::getLatencyInSeconds(DSPGraph::Graph *this, unsigned int a2)
{
  if (a2 >= (unint64_t)((uint64_t)(*((void *)this + 39) - *((void *)this + 38)) >> 3))
  {
    std::string::basic_string[abi:ne180100]<0>(&v7, "/Library/Caches/com.apple.xbs/Sources/CoreAudioServices_AudioToolboxCore/CoreAudioUtility/Source/CADSP/DSPGraph/DSPGraph_Graph.cpp");
    std::string::basic_string[abi:ne180100]<0>(&v6, "getLatencyInSeconds");
    std::string::basic_string[abi:ne180100]<0>(&v5, "latency queried on non-existent output");
    DSPGraph::ThrowException(1701602593, &v7, 2299, &v6, &v5);
  }
  uint64_t v2 = (DSPGraph::Box *)DSPGraph::Graph::out(this, a2);
  uint64_t v3 = (*(uint64_t (**)(DSPGraph::Box *))(*(void *)v2 + 72))(v2);
  return (double)(DSPGraph::Box::upstreamLatencyInTicks(v2) + v3)
       / (double)*(unint64_t *)(*((void *)v2 + 1) + 696);
}

void sub_1901B71D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (*(char *)(v21 - 17) < 0) {
    operator delete(*(void **)(v21 - 40));
  }
  _Unwind_Resume(exception_object);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,DSPGraph::Graph::GraphParameter>,void *>>>::operator()[abi:ne180100](char a1, void *__p)
{
  if (a1)
  {
    uint64_t v3 = (void *)__p[5];
    if (v3)
    {
      __p[6] = v3;
      operator delete(v3);
    }
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

char *DSPGraph::Graph::getOrderingConstraints@<X0>(char *this@<X0>, void **a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2)
  {
    CFTypeID v4 = 0;
    this = 0;
    do
    {
      long long v5 = *(void **)(v2[2] + 128);
      if (v5)
      {
        long long v6 = this;
        do
        {
          uint64_t v7 = v5[2];
          uint64_t v8 = v2[2];
          unint64_t v9 = (unint64_t)a2[2];
          if ((unint64_t)v6 >= v9)
          {
            int v10 = (char *)*a2;
            uint64_t v11 = (v6 - (unsigned char *)*a2) >> 4;
            unint64_t v12 = v11 + 1;
            if ((unint64_t)(v11 + 1) >> 60) {
              std::vector<float>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v13 = v9 - (void)v10;
            if (v13 >> 3 > v12) {
              unint64_t v12 = v13 >> 3;
            }
            if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v14 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v14 = v12;
            }
            if (v14)
            {
              if (v14 >> 60) {
                std::__throw_bad_array_new_length[abi:ne180100]();
              }
              uint64_t v15 = (char *)operator new(16 * v14);
            }
            else
            {
              uint64_t v15 = 0;
            }
            unint64_t v16 = &v15[16 * v11];
            *(void *)unint64_t v16 = v7;
            *((void *)v16 + 1) = v8;
            BOOL v17 = v16;
            if (v4 != v10)
            {
              do
              {
                *((_OWORD *)v17 - 1) = *((_OWORD *)v4 - 1);
                v17 -= 16;
                v4 -= 16;
              }
              while (v4 != v10);
              CFTypeID v4 = (char *)*a2;
            }
            uint64_t v18 = &v15[16 * v14];
            long long v6 = v16 + 16;
            *a2 = v17;
            a2[1] = v16 + 16;
            a2[2] = v18;
            if (v4) {
              operator delete(v4);
            }
          }
          else
          {
            *(void *)long long v6 = v7;
            *((void *)v6 + 1) = v8;
            v6 += 16;
          }
          a2[1] = v6;
          long long v5 = (void *)*v5;
          this = v6;
          CFTypeID v4 = v6;
        }
        while (v5);
      }
      else
      {
        long long v6 = v4;
      }
      uint64_t v2 = (void *)*v2;
      CFTypeID v4 = v6;
    }
    while (v2);
  }
  return this;
}

void sub_1901B73E4(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    *(void *)(v1 + 8) = v2;
    operator delete(v2);
  }
  _Unwind_Resume(exception_object);
}

double DSPGraph::Graph::profiler_t::results(DSPGraph::Graph::profiler_t *this)
{
  double v1 = 0.0;
  if (!*((void *)this + 4)) {
    return 0.0;
  }
  uint64_t v2 = (double *)*((void *)this + 2);
  if (!v2) {
    return NAN;
  }
  unint64_t v3 = 0;
  double v4 = 0.0;
  do
  {
    unint64_t v5 = v3 + 1;
    double v4 = *v2 + v4;
    if (v3 + 1 >= 2) {
      double v1 = v1 * (double)v3 / (double)v5 + (*v2 - v4 / (double)v5) * (*v2 - v4 / (double)v5) / (double)v3;
    }
    if (++v2 == *((double **)this + 1)) {
      uint64_t v2 = *(double **)this;
    }
    if (v2 == *((double **)this + 3)) {
      uint64_t v2 = 0;
    }
    ++v3;
  }
  while (v2);
  return v4 / (double)v5;
}

void DSPGraph::Graph::bridge(int64x2_t *this, int64x2_t *a2, DSPGraph::Graph *a3)
{
  if (this[47].i8[9] || a2[47].i8[9])
  {
    std::string::basic_string[abi:ne180100]<0>(&v61, "/Library/Caches/com.apple.xbs/Sources/CoreAudioServices_AudioToolboxCore/CoreAudioUtility/Source/CADSP/DSPGraph/DSPGraph_Graph.cpp");
    std::string::basic_string[abi:ne180100]<0>(&v57, "bridge");
    std::string::basic_string[abi:ne180100]<0>(&v65, "graph is configured");
    DSPGraph::ThrowException(1667655457, (long long *)&v61, 2499, (long long *)&v57, &v65);
  }
  long long v63 = 0u;
  long long v64 = 0u;
  *(_OWORD *)std::string __p = 0u;
  long long v60 = 0u;
  long long v59 = 0u;
  *(_OWORD *)uint64_t v58 = 0u;
  int v61 = a2;
  uint64_t v57 = this;
  for (uint64_t i = this[33].i64[1]; i; uint64_t i = *(void *)i)
  {
    long long v6 = (_DWORD *)(i + 24);
    unsigned int v7 = *(_DWORD *)(i + 24);
    if (std::__hash_table<std::__hash_value_type<unsigned int,DSPGraph::AnalyzerBuilder::Info>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,DSPGraph::AnalyzerBuilder::Info>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,DSPGraph::AnalyzerBuilder::Info>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,DSPGraph::AnalyzerBuilder::Info>>>::find<unsigned int>(&a2[32].i64[1], v7))
    {
      uint64_t v8 = std::__hash_table<std::__hash_value_type<unsigned int,DSPGraph::Graph::GraphParameter>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,DSPGraph::Graph::GraphParameter>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,DSPGraph::Graph::GraphParameter>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,DSPGraph::Graph::GraphParameter>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(&a2[32].i64[1], v7, (_DWORD *)(i + 24));
      unint64_t v9 = v8;
      if (!*(unsigned char *)(i + 32) || v8[32])
      {
        if (!*(unsigned char *)(i + 32) && v8[32])
        {
          unint64_t v12 = (char *)v58[1];
          if (v58[1] >= (void *)v59)
          {
            uint64_t v20 = (char *)v58[0];
            int64_t v21 = ((char *)v58[1] - (char *)v58[0]) >> 2;
            unint64_t v22 = v21 + 1;
            if ((unint64_t)(v21 + 1) >> 62) {
LABEL_82:
            }
              std::vector<float>::__throw_length_error[abi:ne180100]();
            uint64_t v23 = v59 - (unint64_t)v58[0];
            if ((uint64_t)(v59 - (unint64_t)v58[0]) >> 1 > v22) {
              unint64_t v22 = v23 >> 1;
            }
            if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v24 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v24 = v22;
            }
            if (v24)
            {
              unint64_t v24 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v24);
              uint64_t v20 = (char *)v58[0];
              unint64_t v12 = (char *)v58[1];
            }
            else
            {
              uint64_t v25 = 0;
            }
            long long v28 = (_DWORD *)(v24 + 4 * v21);
            _DWORD *v28 = *v6;
            uint64_t v13 = v28 + 1;
            while (v12 != v20)
            {
              int v29 = *((_DWORD *)v12 - 1);
              v12 -= 4;
              *--long long v28 = v29;
            }
            v58[0] = v28;
            *(void *)&long long v59 = v24 + 4 * v25;
            if (v20) {
              operator delete(v20);
            }
          }
          else
          {
            *(_DWORD *)v58[1] = *v6;
            uint64_t v13 = v12 + 4;
          }
          v58[1] = v13;
        }
      }
      else
      {
        int v10 = (char *)__p[1];
        if (__p[1] >= (void *)v63)
        {
          unint64_t v14 = (char *)__p[0];
          int64_t v15 = ((char *)__p[1] - (char *)__p[0]) >> 2;
          unint64_t v16 = v15 + 1;
          if ((unint64_t)(v15 + 1) >> 62) {
            goto LABEL_82;
          }
          uint64_t v17 = v63 - (unint64_t)__p[0];
          if ((uint64_t)(v63 - (unint64_t)__p[0]) >> 1 > v16) {
            unint64_t v16 = v17 >> 1;
          }
          if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v18 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v18 = v16;
          }
          if (v18)
          {
            unint64_t v18 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v18);
            unint64_t v14 = (char *)__p[0];
            int v10 = (char *)__p[1];
          }
          else
          {
            uint64_t v19 = 0;
          }
          int v26 = (_DWORD *)(v18 + 4 * v15);
          _DWORD *v26 = *((_DWORD *)v9 + 6);
          uint64_t v11 = v26 + 1;
          while (v10 != v14)
          {
            int v27 = *((_DWORD *)v10 - 1);
            v10 -= 4;
            *--int v26 = v27;
          }
          __p[0] = v26;
          *(void *)&long long v63 = v18 + 4 * v19;
          if (v14) {
            operator delete(v14);
          }
        }
        else
        {
          *(_DWORD *)__p[1] = *((_DWORD *)v8 + 6);
          uint64_t v11 = v10 + 4;
        }
        __p[1] = v11;
      }
    }
  }
  for (uint64_t j = this[36].i64[0]; j; uint64_t j = *(void *)j)
  {
    unsigned int v31 = *(_DWORD *)(j + 24);
    if (std::__hash_table<std::__hash_value_type<unsigned int,DSPGraph::AnalyzerBuilder::Info>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,DSPGraph::AnalyzerBuilder::Info>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,DSPGraph::AnalyzerBuilder::Info>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,DSPGraph::AnalyzerBuilder::Info>>>::find<unsigned int>((int64x2_t *)a2[35].i64, v31))
    {
      CFTypeRef v32 = std::__hash_table<std::__hash_value_type<unsigned int,DSPGraph::Graph::GraphProperty>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,DSPGraph::Graph::GraphProperty>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,DSPGraph::Graph::GraphProperty>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,DSPGraph::Graph::GraphProperty>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)a2[35].i64, v31, (_DWORD *)(j + 24));
      if (!*(unsigned char *)(j + 64) || *((unsigned char *)v32 + 64))
      {
        if (!*(unsigned char *)(j + 64) && *((unsigned char *)v32 + 64))
        {
          int v36 = *(_DWORD *)(j + 24);
          uint8x8_t v37 = (void *)v60;
          if ((unint64_t)v60 >= *((void *)&v60 + 1))
          {
            uint64_t v46 = (uint64_t)(v60 - *((void *)&v59 + 1)) >> 5;
            unint64_t v47 = v46 + 1;
            if ((unint64_t)(v46 + 1) >> 59) {
              std::vector<float>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v48 = *((void *)&v60 + 1) - *((void *)&v59 + 1);
            if ((uint64_t)(*((void *)&v60 + 1) - *((void *)&v59 + 1)) >> 4 > v47) {
              unint64_t v47 = v48 >> 4;
            }
            if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFE0) {
              unint64_t v49 = 0x7FFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v49 = v47;
            }
            uint64_t v68 = (char *)&v60 + 8;
            uint64_t v50 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<KVOAggregator::Record>>(v49);
            uint64_t v51 = &v50[32 * v46];
            *(void *)&long long v65 = v50;
            *((void *)&v65 + 1) = v51;
            uint64_t v67 = &v50[32 * v52];
            *(_DWORD *)uint64_t v51 = v36;
            *((void *)v51 + 2) = 0;
            *((void *)v51 + 3) = 0;
            *((void *)v51 + 1) = 0;
            uint64_t v66 = v51 + 32;
            std::vector<DSPGraph::Graph::GraphBridge::BridgedProperty>::__swap_out_circular_buffer((uint64_t *)&v59 + 1, &v65);
            uint64_t v38 = (void *)v60;
            std::__split_buffer<DSPGraph::Graph::GraphBridge::BridgedProperty>::~__split_buffer((uint64_t)&v65);
          }
          else
          {
            *(_DWORD *)long long v60 = v36;
            uint64_t v38 = v37 + 4;
            void v37[2] = 0;
            void v37[3] = 0;
            v37[1] = 0;
          }
          *(void *)&long long v60 = v38;
        }
      }
      else
      {
        int v33 = *((_DWORD *)v32 + 6);
        long long v34 = (void *)v64;
        if ((unint64_t)v64 >= *((void *)&v64 + 1))
        {
          uint64_t v39 = (uint64_t)(v64 - *((void *)&v63 + 1)) >> 5;
          unint64_t v40 = v39 + 1;
          if ((unint64_t)(v39 + 1) >> 59) {
            std::vector<float>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v41 = *((void *)&v64 + 1) - *((void *)&v63 + 1);
          if ((uint64_t)(*((void *)&v64 + 1) - *((void *)&v63 + 1)) >> 4 > v40) {
            unint64_t v40 = v41 >> 4;
          }
          if ((unint64_t)v41 >= 0x7FFFFFFFFFFFFFE0) {
            unint64_t v42 = 0x7FFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v42 = v40;
          }
          uint64_t v68 = (char *)&v64 + 8;
          uint64_t v43 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<KVOAggregator::Record>>(v42);
          unint64_t v44 = &v43[32 * v39];
          *(void *)&long long v65 = v43;
          *((void *)&v65 + 1) = v44;
          uint64_t v67 = &v43[32 * v45];
          *(_DWORD *)unint64_t v44 = v33;
          *((void *)v44 + 2) = 0;
          *((void *)v44 + 3) = 0;
          *((void *)v44 + 1) = 0;
          uint64_t v66 = v44 + 32;
          std::vector<DSPGraph::Graph::GraphBridge::BridgedProperty>::__swap_out_circular_buffer((uint64_t *)&v63 + 1, &v65);
          int8x8_t v35 = (void *)v64;
          std::__split_buffer<DSPGraph::Graph::GraphBridge::BridgedProperty>::~__split_buffer((uint64_t)&v65);
        }
        else
        {
          *(_DWORD *)long long v64 = v33;
          int8x8_t v35 = v34 + 4;
          v34[2] = 0;
          v34[3] = 0;
          v34[1] = 0;
        }
        *(void *)&long long v64 = v35;
      }
    }
  }
  unint64_t v53 = this[62].u64[1];
  if (v53 >= this[63].i64[0])
  {
    uint64_t v54 = std::vector<DSPGraph::Graph::GraphBridge>::__push_back_slow_path<DSPGraph::Graph::GraphBridge const&>(this + 62, (uint64_t)&v61);
  }
  else
  {
    std::construct_at[abi:ne180100]<DSPGraph::Graph::GraphBridge,DSPGraph::Graph::GraphBridge const&,DSPGraph::Graph::GraphBridge*>((void *)this[62].i64[1], (uint64_t)&v61);
    uint64_t v54 = v53 + 56;
    this[62].i64[1] = v53 + 56;
  }
  this[62].i64[1] = v54;
  unint64_t v55 = a2[62].u64[1];
  if (v55 >= a2[63].i64[0])
  {
    uint64_t v56 = std::vector<DSPGraph::Graph::GraphBridge>::__push_back_slow_path<DSPGraph::Graph::GraphBridge const&>(a2 + 62, (uint64_t)&v57);
  }
  else
  {
    std::construct_at[abi:ne180100]<DSPGraph::Graph::GraphBridge,DSPGraph::Graph::GraphBridge const&,DSPGraph::Graph::GraphBridge*>((void *)a2[62].i64[1], (uint64_t)&v57);
    uint64_t v56 = v55 + 56;
    a2[62].i64[1] = v55 + 56;
  }
  a2[62].i64[1] = v56;
  *(void *)&long long v65 = (char *)&v59 + 8;
  std::vector<DSPGraph::Graph::GraphBridge::BridgedProperty>::__destroy_vector::operator()[abi:ne180100]((void ***)&v65);
  if (v58[0])
  {
    v58[1] = v58[0];
    operator delete(v58[0]);
  }
  uint64_t v57 = (int64x2_t *)((char *)&v63 + 8);
  std::vector<DSPGraph::Graph::GraphBridge::BridgedProperty>::__destroy_vector::operator()[abi:ne180100]((void ***)&v57);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void sub_1901B79A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  *(void *)(v36 + 1000) = v37;
  DSPGraph::Graph::GraphBridge::~GraphBridge((DSPGraph::Graph::GraphBridge *)&a11);
  DSPGraph::Graph::GraphBridge::~GraphBridge((DSPGraph::Graph::GraphBridge *)&a21);
  _Unwind_Resume(a1);
}

void *std::construct_at[abi:ne180100]<DSPGraph::Graph::GraphBridge,DSPGraph::Graph::GraphBridge const&,DSPGraph::Graph::GraphBridge*>(void *a1, uint64_t a2)
{
  *a1 = *(void *)a2;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  std::vector<unsigned int>::__init_with_size[abi:ne180100]<unsigned int *,unsigned int *>(a1 + 1, *(const void **)(a2 + 8), *(void *)(a2 + 16), (uint64_t)(*(void *)(a2 + 16) - *(void *)(a2 + 8)) >> 2);
  a1[4] = 0;
  a1[5] = 0;
  a1[6] = 0;
  uint64_t v4 = *(void *)(a2 + 32);
  uint64_t v5 = *(void *)(a2 + 40);
  uint64_t v6 = v5 - v4;
  if (v5 != v4)
  {
    if (v6 < 0) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    unsigned int v7 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<KVOAggregator::Record>>(v6 >> 5);
    a1[6] = &v7[32 * v8];
    a1[4] = v7;
    a1[5] = v7;
    uint64_t v13 = v7;
    unint64_t v14 = v7;
    v11[0] = a1 + 6;
    v11[1] = &v13;
    v11[2] = &v14;
    unint64_t v9 = v7;
    char v12 = 0;
    do
    {
      *(_DWORD *)unint64_t v9 = *(_DWORD *)v4;
      *((void *)v9 + 2) = 0;
      *((void *)v9 + 3) = 0;
      *((void *)v9 + 1) = 0;
      std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>((void *)v9 + 1, *(const void **)(v4 + 8), *(void *)(v4 + 16), *(void *)(v4 + 16) - *(void *)(v4 + 8));
      unint64_t v9 = v14 + 32;
      v14 += 32;
      v4 += 32;
    }
    while (v4 != v5);
    char v12 = 1;
    std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<DSPGraph::Graph::GraphBridge::BridgedProperty>,DSPGraph::Graph::GraphBridge::BridgedProperty*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
    a1[5] = v9;
  }
  return a1;
}

void sub_1901B7B58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<DSPGraph::Graph::GraphBridge::BridgedProperty>::__destroy_vector::operator()[abi:ne180100](&a9);
  char v12 = *v10;
  if (*v10)
  {
    *(void *)(v9 + 1std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = v12;
    operator delete(v12);
  }
  _Unwind_Resume(a1);
}

uint64_t std::vector<DSPGraph::Graph::GraphBridge>::__push_back_slow_path<DSPGraph::Graph::GraphBridge const&>(int64x2_t *a1, uint64_t a2)
{
  uint64_t v2 = 0x6DB6DB6DB6DB6DB7 * ((a1->i64[1] - a1->i64[0]) >> 3);
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) > 0x492492492492492) {
    std::vector<float>::__throw_length_error[abi:ne180100]();
  }
  if (0xDB6DB6DB6DB6DB6ELL * ((a1[1].i64[0] - a1->i64[0]) >> 3) > v3) {
    unint64_t v3 = 0xDB6DB6DB6DB6DB6ELL * ((a1[1].i64[0] - a1->i64[0]) >> 3);
  }
  if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((a1[1].i64[0] - a1->i64[0]) >> 3)) >= 0x249249249249249) {
    unint64_t v6 = 0x492492492492492;
  }
  else {
    unint64_t v6 = v3;
  }
  uint64_t v19 = a1 + 1;
  if (v6)
  {
    if (v6 > 0x492492492492492) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    unsigned int v7 = (char *)operator new(56 * v6);
  }
  else
  {
    unsigned int v7 = 0;
  }
  unint64_t v16 = v7;
  v17.i64[0] = (uint64_t)&v7[56 * v2];
  unint64_t v18 = &v7[56 * v6];
  std::construct_at[abi:ne180100]<DSPGraph::Graph::GraphBridge,DSPGraph::Graph::GraphBridge const&,DSPGraph::Graph::GraphBridge*>(v17.i64[0], a2);
  uint64_t v8 = (void *)v17.i64[0];
  uint64_t v9 = v17.i64[0] + 56;
  v17.i64[1] = v17.i64[0] + 56;
  uint64_t v11 = a1->i64[0];
  unint64_t v10 = a1->u64[1];
  if (v10 == a1->i64[0])
  {
    int64x2_t v13 = vdupq_n_s64(v10);
  }
  else
  {
    do
    {
      uint64_t v12 = *(void *)(v10 - 56);
      v10 -= 56;
      *(v8 - 7) = v12;
      v8 -= 7;
      _OWORD v8[2] = 0;
      v8[3] = 0;
      v8[1] = 0;
      *(_OWORD *)(v8 + 1) = *(_OWORD *)(v10 + 8);
      v8[3] = *(void *)(v10 + 24);
      *(void *)(v10 + 8) = 0;
      *(void *)(v10 + 1std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
      *(void *)(v10 + 24) = 0;
      v8[4] = 0;
      v8[5] = 0;
      v8[6] = 0;
      *((_OWORD *)v8 + 2) = *(_OWORD *)(v10 + 32);
      v8[6] = *(void *)(v10 + 48);
      *(void *)(v10 + 32) = 0;
      *(void *)(v10 + 40) = 0;
      *(void *)(v10 + 48) = 0;
    }
    while (v10 != v11);
    int64x2_t v13 = *a1;
    uint64_t v9 = v17.i64[1];
  }
  a1->i64[0] = (uint64_t)v8;
  a1->i64[1] = v9;
  int64x2_t v17 = v13;
  unint64_t v14 = (char *)a1[1].i64[0];
  a1[1].i64[0] = (uint64_t)v18;
  unint64_t v18 = v14;
  unint64_t v16 = (char *)v13.i64[0];
  std::__split_buffer<DSPGraph::Graph::GraphBridge>::~__split_buffer((uint64_t)&v16);
  return v9;
}

void sub_1901B7D24(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<DSPGraph::Graph::GraphBridge>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *std::vector<DSPGraph::Graph::GraphBridge::BridgedProperty>::__swap_out_circular_buffer(uint64_t *result, void *a2)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  uint64_t v4 = a2[1];
  if (v2 != *result)
  {
    uint64_t v5 = 0;
    do
    {
      uint64_t v6 = v4 + v5;
      uint64_t v7 = v2 + v5;
      *(_DWORD *)(v6 - 32) = *(_DWORD *)(v2 + v5 - 32);
      *(void *)(v6 - 1std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
      *(void *)(v6 - 8) = 0;
      *(void *)(v6 - 24) = 0;
      *(_OWORD *)(v6 - 24) = *(_OWORD *)(v2 + v5 - 24);
      *(void *)(v6 - 8) = *(void *)(v2 + v5 - 8);
      *(void *)(v7 - 24) = 0;
      *(void *)(v7 - 1std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
      *(void *)(v7 - 8) = 0;
      v5 -= 32;
    }
    while (v2 + v5 != v3);
    v4 += v5;
  }
  a2[1] = v4;
  uint64_t v8 = *result;
  *double result = v4;
  a2[1] = v8;
  uint64_t v9 = result[1];
  result[1] = a2[2];
  a2[2] = v9;
  uint64_t v10 = result[2];
  result[2] = a2[3];
  a2[3] = v10;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<DSPGraph::Graph::GraphBridge::BridgedProperty>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != v3)
  {
    *(void *)(a1 + 1std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = v2 - 32;
    uint64_t v4 = *(void **)(v2 - 24);
    if (v4)
    {
      *(void *)(v2 - 1std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = v4;
      operator delete(v4);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 32;
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void DSPGraph::Graph::GraphBridge::~GraphBridge(DSPGraph::Graph::GraphBridge *this)
{
  uint64_t v3 = (void **)((char *)this + 32);
  std::vector<DSPGraph::Graph::GraphBridge::BridgedProperty>::__destroy_vector::operator()[abi:ne180100](&v3);
  uint64_t v2 = (void *)*((void *)this + 1);
  if (v2)
  {
    *((void *)this + 2) = v2;
    operator delete(v2);
  }
}

uint64_t std::__split_buffer<DSPGraph::Graph::GraphBridge>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 1std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = i - 56;
    std::__destroy_at[abi:ne180100]<DSPGraph::Graph::GraphBridge,0>(i - 56);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<DSPGraph::Graph::GraphBridge::BridgedProperty>,DSPGraph::Graph::GraphBridge::BridgedProperty*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24))
  {
    uint64_t v3 = **(void **)(a1 + 16);
    uint64_t v4 = **(void **)(a1 + 8);
    while (v3 != v4)
    {
      uint64_t v5 = *(void **)(v3 - 24);
      if (v5)
      {
        *(void *)(v3 - 1std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = v5;
        operator delete(v5);
      }
      v3 -= 32;
    }
  }
  return a1;
}

void DSPGraph::Graph::unbridge(DSPGraph::Graph *this, DSPGraph::Graph *a2, DSPGraph::Graph *a3)
{
  uint64_t v5 = (void *)((char *)this + 992);
  uint64_t v6 = *((void *)this + 125);
  for (uint64_t i = (void *)*((void *)this + 124); ; i += 7)
  {
    if (i == (void *)v6)
    {
      uint64_t i = (void *)*((void *)this + 125);
      goto LABEL_14;
    }
    if ((DSPGraph::Graph *)*i == a2) {
      break;
    }
  }
  if (i != (void *)v6)
  {
    uint64_t v8 = i + 7;
    if (i + 7 != (void *)v6)
    {
      do
      {
        if ((DSPGraph::Graph *)*v8 != a2)
        {
          *uint64_t i = *v8;
          uint64_t v9 = (void *)i[1];
          if (v9)
          {
            i[2] = v9;
            operator delete(v9);
            i[1] = 0;
            i[2] = 0;
            i[3] = 0;
          }
          *(_OWORD *)(i + 1) = *(_OWORD *)(v8 + 1);
          i[3] = v8[3];
          v8[1] = 0;
          _OWORD v8[2] = 0;
          v8[3] = 0;
          std::vector<DSPGraph::Graph::GraphBridge::BridgedProperty>::__vdeallocate(i + 4);
          *((_OWORD *)i + 2) = *((_OWORD *)v8 + 2);
          i[6] = v8[6];
          v8[4] = 0;
          v8[5] = 0;
          v8[6] = 0;
          i += 7;
        }
        v8 += 7;
      }
      while (v8 != (void *)v6);
      uint64_t v6 = *((void *)this + 125);
    }
  }
LABEL_14:
  std::vector<DSPGraph::Graph::GraphBridge>::erase(v5, i, v6);
  uint64_t v10 = *((void *)a2 + 125);
  for (uint64_t j = (void *)*((void *)a2 + 124); ; j += 7)
  {
    if (j == (void *)v10)
    {
      uint64_t j = (void *)*((void *)a2 + 125);
      goto LABEL_27;
    }
    if ((DSPGraph::Graph *)*j == this) {
      break;
    }
  }
  if (j != (void *)v10)
  {
    uint64_t v12 = j + 7;
    if (j + 7 != (void *)v10)
    {
      do
      {
        if ((DSPGraph::Graph *)*v12 != this)
        {
          *uint64_t j = *v12;
          int64x2_t v13 = (void *)j[1];
          if (v13)
          {
            j[2] = v13;
            operator delete(v13);
            j[1] = 0;
            j[2] = 0;
            j[3] = 0;
          }
          *(_OWORD *)(j + 1) = *(_OWORD *)(v12 + 1);
          j[3] = v12[3];
          v12[1] = 0;
          v12[2] = 0;
          void v12[3] = 0;
          std::vector<DSPGraph::Graph::GraphBridge::BridgedProperty>::__vdeallocate(j + 4);
          *((_OWORD *)j + 2) = *((_OWORD *)v12 + 2);
          j[6] = v12[6];
          v12[4] = 0;
          v12[5] = 0;
          v12[6] = 0;
          j += 7;
        }
        v12 += 7;
      }
      while (v12 != (void *)v10);
      uint64_t v10 = *((void *)a2 + 125);
    }
  }
LABEL_27:
  std::vector<DSPGraph::Graph::GraphBridge>::erase((void *)a2 + 124, j, v10);
}

void std::vector<DSPGraph::Graph::GraphBridge::BridgedProperty>::__vdeallocate(uint64_t *a1)
{
  if (*a1)
  {
    std::vector<DSPGraph::Graph::GraphBridge::BridgedProperty>::__clear[abi:ne180100](a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void std::vector<DSPGraph::Graph::GraphBridge>::erase(void *a1, void *a2, uint64_t a3)
{
  if (a2 != (void *)a3)
  {
    uint64_t v3 = a3;
    uint64_t v4 = a2;
    uint64_t v6 = (void *)a1[1];
    if ((void *)a3 != v6)
    {
      uint64_t v7 = 8 * ((a3 - (uint64_t)a2) >> 3);
      uint64_t v8 = *a1 + 8 * (((uint64_t)a2 - *a1) >> 3) + 24;
      do
      {
        uint64_t v9 = (void *)v8;
        uint64_t v10 = v8 + v7;
        *(void *)(v8 - 24) = *(void *)(v8 + v7 - 24);
        uint64_t v12 = (void *)(v8 - 16);
        uint64_t v11 = *(void **)(v8 - 16);
        if (v11)
        {
          *(void *)(v8 - 8) = v11;
          operator delete(v11);
          *uint64_t v12 = 0;
          *(v9 - 1) = 0;
          *uint64_t v9 = 0;
        }
        int64x2_t v13 = (void *)(v10 - 16);
        *((_OWORD *)v9 - 1) = *(_OWORD *)(v10 - 16);
        *uint64_t v9 = *(void *)v10;
        void *v13 = 0;
        v13[1] = 0;
        *(void *)uint64_t v10 = 0;
        std::vector<DSPGraph::Graph::GraphBridge::BridgedProperty>::__vdeallocate(v9 + 1);
        *(_OWORD *)(v9 + 1) = *(_OWORD *)(v10 + 8);
        void v9[3] = *(void *)(v10 + 24);
        *(void *)(v10 + 8) = 0;
        *(void *)(v10 + 1std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
        *(void *)(v10 + 24) = 0;
        uint64_t v8 = (uint64_t)(v9 + 7);
      }
      while (&v9[(unint64_t)v7 / 8 + 4] != v6);
      uint64_t v4 = v9 + 4;
      uint64_t v3 = a1[1];
    }
    while ((void *)v3 != v4)
    {
      v3 -= 56;
      std::__destroy_at[abi:ne180100]<DSPGraph::Graph::GraphBridge,0>(v3);
    }
    a1[1] = v4;
  }
}

void DSPGraph::Graph::GetProfilingInfo(DSPGraph::Graph *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v6 = (DSPGraph::Graph::profiler_t *)*((void *)this + 127);
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 1std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *(_DWORD *)(a2 + 32) = 1065353216;
  if (!v6) {
    return;
  }
  double v7 = DSPGraph::Graph::profiler_t::results(v6);
  uint64_t v9 = v8;
  std::string::basic_string[abi:ne180100]<0>(__p, "@TOP");
  unint64_t v10 = std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)__p);
  unint64_t v11 = v10;
  unint64_t v12 = *(void *)(a2 + 8);
  if (v12)
  {
    uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    unint64_t v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v2 = v10;
      if (v10 >= v12) {
        unint64_t v2 = v10 % v12;
      }
    }
    else
    {
      unint64_t v2 = (v12 - 1) & v10;
    }
    int64_t v15 = *(void ***)(*(void *)a2 + 8 * v2);
    if (v15)
    {
      for (uint64_t i = *v15; i; uint64_t i = *(void **)i)
      {
        unint64_t v17 = *((void *)i + 1);
        if (v17 == v11)
        {
          if (std::equal_to<std::string>::operator()[abi:ne180100]((unsigned __int8 *)i + 16, (unsigned __int8 *)__p)) {
            goto LABEL_41;
          }
        }
        else
        {
          if (v14 > 1)
          {
            if (v17 >= v12) {
              v17 %= v12;
            }
          }
          else
          {
            v17 &= v12 - 1;
          }
          if (v17 != v2) {
            break;
          }
        }
      }
    }
  }
  uint64_t i = operator new(0x38uLL);
  *(void *)uint64_t i = 0;
  *((void *)i + 1) = v11;
  *((_OWORD *)i + 1) = *(_OWORD *)__p;
  uint64_t v18 = v53;
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v53 = 0;
  *((void *)i + 5) = 0;
  *((void *)i + std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  *((void *)i + 4) = v18;
  float v19 = (float)(unint64_t)(*(void *)(a2 + 24) + 1);
  float v20 = *(float *)(a2 + 32);
  if (!v12 || (float)(v20 * (float)v12) < v19)
  {
    BOOL v21 = 1;
    if (v12 >= 3) {
      BOOL v21 = (v12 & (v12 - 1)) != 0;
    }
    unint64_t v22 = v21 | (2 * v12);
    unint64_t v23 = vcvtps_u32_f32(v19 / v20);
    if (v22 <= v23) {
      size_t v24 = v23;
    }
    else {
      size_t v24 = v22;
    }
    std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<CA::ADMPackFormat>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<CA::ADMPackFormat>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<CA::ADMPackFormat>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<CA::ADMPackFormat>>>>::__rehash<true>(a2, v24);
    unint64_t v12 = *(void *)(a2 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12) {
        unint64_t v2 = v11 % v12;
      }
      else {
        unint64_t v2 = v11;
      }
    }
    else
    {
      unint64_t v2 = (v12 - 1) & v11;
    }
  }
  uint64_t v25 = *(void *)a2;
  int v26 = *(void **)(*(void *)a2 + 8 * v2);
  if (v26)
  {
    *(void *)uint64_t i = *v26;
LABEL_39:
    void *v26 = i;
    goto LABEL_40;
  }
  *(void *)uint64_t i = *(void *)(a2 + 16);
  *(void *)(a2 + 1std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = i;
  *(void *)(v25 + 8 * v2) = a2 + 16;
  if (*(void *)i)
  {
    unint64_t v27 = *(void *)(*(void *)i + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v27 >= v12) {
        v27 %= v12;
      }
    }
    else
    {
      v27 &= v12 - 1;
    }
    int v26 = (void *)(*(void *)a2 + 8 * v27);
    goto LABEL_39;
  }
LABEL_40:
  ++*(void *)(a2 + 24);
LABEL_41:
  *((double *)i + 5) = v7;
  *((void *)i + std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = v9;
  if (SHIBYTE(v53) < 0) {
    operator delete(__p[0]);
  }
  long long v28 = (unsigned __int8 *)*((void *)this + 134);
  if (v28)
  {
    int v29 = (void *)(a2 + 16);
    do
    {
      double v30 = DSPGraph::Graph::profiler_t::results((DSPGraph::Graph::profiler_t *)(v28 + 40));
      uint64_t v32 = v31;
      unint64_t v33 = std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)(v28 + 16));
      unint64_t v34 = v33;
      unint64_t v35 = *(void *)(a2 + 8);
      if (v35)
      {
        uint8x8_t v36 = (uint8x8_t)vcnt_s8((int8x8_t)v35);
        v36.i16[0] = vaddlv_u8(v36);
        unint64_t v37 = v36.u32[0];
        if (v36.u32[0] > 1uLL)
        {
          unint64_t v3 = v33;
          if (v33 >= v35) {
            unint64_t v3 = v33 % v35;
          }
        }
        else
        {
          unint64_t v3 = (v35 - 1) & v33;
        }
        uint64_t v38 = *(void ***)(*(void *)a2 + 8 * v3);
        if (v38)
        {
          uint64_t v39 = (char *)*v38;
          if (*v38)
          {
            do
            {
              unint64_t v40 = *((void *)v39 + 1);
              if (v40 == v34)
              {
                if (std::equal_to<std::string>::operator()[abi:ne180100]((unsigned __int8 *)v39 + 16, v28 + 16)) {
                  goto LABEL_86;
                }
              }
              else
              {
                if (v37 > 1)
                {
                  if (v40 >= v35) {
                    v40 %= v35;
                  }
                }
                else
                {
                  v40 &= v35 - 1;
                }
                if (v40 != v3) {
                  break;
                }
              }
              uint64_t v39 = *(char **)v39;
            }
            while (v39);
          }
        }
      }
      uint64_t v39 = (char *)operator new(0x38uLL);
      *(void *)uint64_t v39 = 0;
      *((void *)v39 + 1) = v34;
      uint64_t v41 = (std::string *)(v39 + 16);
      if ((char)v28[39] < 0)
      {
        std::string::__init_copy_ctor_external(v41, *((const std::string::value_type **)v28 + 2), *((void *)v28 + 3));
      }
      else
      {
        long long v42 = *((_OWORD *)v28 + 1);
        *((void *)v39 + 4) = *((void *)v28 + 4);
        *(_OWORD *)&v41->__r_.__value_.__l.__data_ = v42;
      }
      *((void *)v39 + 5) = 0;
      *((void *)v39 + std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
      float v43 = (float)(unint64_t)(*(void *)(a2 + 24) + 1);
      float v44 = *(float *)(a2 + 32);
      if (!v35 || (float)(v44 * (float)v35) < v43)
      {
        BOOL v45 = (v35 & (v35 - 1)) != 0;
        if (v35 < 3) {
          BOOL v45 = 1;
        }
        unint64_t v46 = v45 | (2 * v35);
        unint64_t v47 = vcvtps_u32_f32(v43 / v44);
        if (v46 <= v47) {
          size_t v48 = v47;
        }
        else {
          size_t v48 = v46;
        }
        std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<CA::ADMPackFormat>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<CA::ADMPackFormat>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<CA::ADMPackFormat>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<CA::ADMPackFormat>>>>::__rehash<true>(a2, v48);
        unint64_t v35 = *(void *)(a2 + 8);
        if ((v35 & (v35 - 1)) != 0)
        {
          if (v34 >= v35) {
            unint64_t v3 = v34 % v35;
          }
          else {
            unint64_t v3 = v34;
          }
        }
        else
        {
          unint64_t v3 = (v35 - 1) & v34;
        }
      }
      uint64_t v49 = *(void *)a2;
      uint64_t v50 = *(void **)(*(void *)a2 + 8 * v3);
      if (v50)
      {
        *(void *)uint64_t v39 = *v50;
      }
      else
      {
        *(void *)uint64_t v39 = *v29;
        *int v29 = v39;
        *(void *)(v49 + 8 * v3) = v29;
        if (!*(void *)v39) {
          goto LABEL_85;
        }
        unint64_t v51 = *(void *)(*(void *)v39 + 8);
        if ((v35 & (v35 - 1)) != 0)
        {
          if (v51 >= v35) {
            v51 %= v35;
          }
        }
        else
        {
          v51 &= v35 - 1;
        }
        uint64_t v50 = (void *)(*(void *)a2 + 8 * v51);
      }
      void *v50 = v39;
LABEL_85:
      ++*(void *)(a2 + 24);
LABEL_86:
      *((double *)v39 + 5) = v30;
      *((void *)v39 + std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = v32;
      long long v28 = *(unsigned __int8 **)v28;
    }
    while (v28);
  }
}

void sub_1901B8724(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:ne180100](1, v16);
  if (a15 < 0) {
    operator delete(__p);
  }
  std::__hash_table<std::__hash_value_type<std::string,DSPGraph::Box *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,DSPGraph::Box *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,DSPGraph::Box *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,DSPGraph::Box *>>>::~__hash_table(v15);
  _Unwind_Resume(a1);
}

uint64_t DSPGraph::Graph::setSRCAlgorithm(uint64_t this, int a2)
{
  *(_DWORD *)(this + 928) = a2;
  unint64_t v2 = *(uint64_t ***)(this + 384);
  if (v2)
  {
    uint64_t v3 = this;
    do
    {
      this = (*(uint64_t (**)(uint64_t *))(*v2[2] + 256))(v2[2]);
      if (this) {
        *(_DWORD *)(this + 89std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(v3 + 928);
      }
      unint64_t v2 = (uint64_t **)*v2;
    }
    while (v2);
  }
  return this;
}

uint64_t DSPGraph::Graph::setSRCQuality(uint64_t this, int a2)
{
  *(_DWORD *)(this + 932) = a2;
  unint64_t v2 = *(uint64_t ***)(this + 384);
  if (v2)
  {
    uint64_t v3 = this;
    do
    {
      this = (*(uint64_t (**)(uint64_t *))(*v2[2] + 256))(v2[2]);
      if (this) {
        *(_DWORD *)(this + 900) = *(_DWORD *)(v3 + 932);
      }
      unint64_t v2 = (uint64_t **)*v2;
    }
    while (v2);
  }
  return this;
}

uint64_t DSPGraph::Graph::setSRCMinimumPhase(uint64_t this, char a2)
{
  *(unsigned char *)(this + 93std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = a2;
  unint64_t v2 = *(uint64_t ***)(this + 384);
  if (v2)
  {
    uint64_t v3 = this;
    do
    {
      this = (*(uint64_t (**)(uint64_t *))(*v2[2] + 256))(v2[2]);
      if (this) {
        *(unsigned char *)(this + 904) = *(unsigned char *)(v3 + 936);
      }
      unint64_t v2 = (uint64_t **)*v2;
    }
    while (v2);
  }
  return this;
}

char *DSPGraph::Graph::addJack(uint64_t a1, long long *a2)
{
  uint64_t v3 = (uint64_t *)(a1 + 640);
  uint64_t v5 = a2;
  *((void *)std::__hash_table<std::__hash_value_type<std::string,DSPGraph::Jack>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,DSPGraph::Jack>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,DSPGraph::Jack>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,DSPGraph::Jack>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t *)(a1 + 640), (unsigned __int8 *)a2, &v5)+ 5) = 0;
  uint64_t v5 = a2;
  return std::__hash_table<std::__hash_value_type<std::string,DSPGraph::Jack>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,DSPGraph::Jack>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,DSPGraph::Jack>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,DSPGraph::Jack>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v3, (unsigned __int8 *)a2, &v5)+ 40;
}

char *std::__hash_table<std::__hash_value_type<std::string,DSPGraph::Jack>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,DSPGraph::Jack>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,DSPGraph::Jack>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,DSPGraph::Jack>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t *a1, unsigned __int8 *a2, long long **a3)
{
  unint64_t v7 = std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)a2);
  unint64_t v8 = v7;
  unint64_t v9 = a1[1];
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    unint64_t v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v3 = v7;
      if (v7 >= v9) {
        unint64_t v3 = v7 % v9;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v7;
    }
    unint64_t v12 = *(void ***)(*a1 + 8 * v3);
    if (v12)
    {
      uint8x8_t v13 = (char *)*v12;
      if (*v12)
      {
        do
        {
          unint64_t v14 = *((void *)v13 + 1);
          if (v14 == v8)
          {
            if (std::equal_to<std::string>::operator()[abi:ne180100]((unsigned __int8 *)v13 + 16, a2)) {
              return v13;
            }
          }
          else
          {
            if (v11 > 1)
            {
              if (v14 >= v9) {
                v14 %= v9;
              }
            }
            else
            {
              v14 &= v9 - 1;
            }
            if (v14 != v3) {
              break;
            }
          }
          uint8x8_t v13 = *(char **)v13;
        }
        while (v13);
      }
    }
  }
  uint8x8_t v13 = (char *)operator new(0x30uLL);
  *(void *)uint8x8_t v13 = 0;
  *((void *)v13 + 1) = v8;
  uint64_t v15 = (std::string *)(v13 + 16);
  unint64_t v16 = *a3;
  if (*((char *)*a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v15, *(const std::string::value_type **)v16, *((void *)v16 + 1));
  }
  else
  {
    long long v17 = *v16;
    *((void *)v13 + 4) = *((void *)v16 + 2);
    *(_OWORD *)&v15->__r_.__value_.__l.__data_ = v17;
  }
  uint64_t v18 = a1 + 2;
  *((void *)v13 + 5) = 0;
  float v19 = (float)(unint64_t)(a1[3] + 1);
  float v20 = *((float *)a1 + 8);
  if (!v9 || (float)(v20 * (float)v9) < v19)
  {
    BOOL v21 = 1;
    if (v9 >= 3) {
      BOOL v21 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v22 = v21 | (2 * v9);
    unint64_t v23 = vcvtps_u32_f32(v19 / v20);
    if (v22 <= v23) {
      int8x8_t prime = (int8x8_t)v23;
    }
    else {
      int8x8_t prime = (int8x8_t)v22;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }
    unint64_t v9 = a1[1];
    if (*(void *)&prime > v9) {
      goto LABEL_33;
    }
    if (*(void *)&prime < v9)
    {
      unint64_t v31 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v9 < 3 || (uint8x8_t v32 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v32.i16[0] = vaddlv_u8(v32), v32.u32[0] > 1uLL))
      {
        unint64_t v31 = std::__next_prime(v31);
      }
      else
      {
        uint64_t v33 = 1 << -(char)__clz(v31 - 1);
        if (v31 >= 2) {
          unint64_t v31 = v33;
        }
      }
      if (*(void *)&prime <= v31) {
        int8x8_t prime = (int8x8_t)v31;
      }
      if (*(void *)&prime >= v9)
      {
        unint64_t v9 = a1[1];
      }
      else
      {
        if (prime)
        {
LABEL_33:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v25 = operator new(8 * *(void *)&prime);
          int v26 = (void *)*a1;
          *a1 = (uint64_t)v25;
          if (v26) {
            operator delete(v26);
          }
          uint64_t v27 = 0;
          a1[1] = (uint64_t)prime;
          do
            *(void *)(*a1 + 8 * v27++) = 0;
          while (*(void *)&prime != v27);
          long long v28 = (void *)*v18;
          if (*v18)
          {
            unint64_t v29 = v28[1];
            uint8x8_t v30 = (uint8x8_t)vcnt_s8(prime);
            v30.i16[0] = vaddlv_u8(v30);
            if (v30.u32[0] > 1uLL)
            {
              if (v29 >= *(void *)&prime) {
                v29 %= *(void *)&prime;
              }
            }
            else
            {
              v29 &= *(void *)&prime - 1;
            }
            *(void *)(*a1 + 8 * v29) = v18;
            unint64_t v34 = (void *)*v28;
            if (*v28)
            {
              do
              {
                unint64_t v35 = v34[1];
                if (v30.u32[0] > 1uLL)
                {
                  if (v35 >= *(void *)&prime) {
                    v35 %= *(void *)&prime;
                  }
                }
                else
                {
                  v35 &= *(void *)&prime - 1;
                }
                if (v35 != v29)
                {
                  if (!*(void *)(*a1 + 8 * v35))
                  {
                    *(void *)(*a1 + 8 * v35) = v28;
                    goto LABEL_58;
                  }
                  void *v28 = *v34;
                  void *v34 = **(void **)(*a1 + 8 * v35);
                  **(void **)(*a1 + 8 * v35) = v34;
                  unint64_t v34 = v28;
                }
                unint64_t v35 = v29;
LABEL_58:
                long long v28 = v34;
                unint64_t v34 = (void *)*v34;
                unint64_t v29 = v35;
              }
              while (v34);
            }
          }
          unint64_t v9 = (unint64_t)prime;
          goto LABEL_62;
        }
        unint64_t v40 = (void *)*a1;
        *a1 = 0;
        if (v40) {
          operator delete(v40);
        }
        unint64_t v9 = 0;
        a1[1] = 0;
      }
    }
LABEL_62:
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
      else {
        unint64_t v3 = v8;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v8;
    }
  }
  uint64_t v36 = *a1;
  unint64_t v37 = *(void **)(*a1 + 8 * v3);
  if (v37)
  {
    *(void *)uint8x8_t v13 = *v37;
LABEL_75:
    *unint64_t v37 = v13;
    goto LABEL_76;
  }
  *(void *)uint8x8_t v13 = *v18;
  *uint64_t v18 = v13;
  *(void *)(v36 + 8 * v3) = v18;
  if (*(void *)v13)
  {
    unint64_t v38 = *(void *)(*(void *)v13 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v38 >= v9) {
        v38 %= v9;
      }
    }
    else
    {
      v38 &= v9 - 1;
    }
    unint64_t v37 = (void *)(*a1 + 8 * v38);
    goto LABEL_75;
  }
LABEL_76:
  ++a1[3];
  return v13;
}

void sub_1901B8D48(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:ne180100](0, v1);
  _Unwind_Resume(a1);
}

void sub_1901B9134(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);

  caulk::xpc::sync_message<objc_object  {objcproto33CarbonComponentScannerXPCProtocol}* {__strong},NSData * {__strong},NSData *>::~sync_message((uint64_t)va);
  _Unwind_Resume(a1);
}

void *std::__function::__value_func<void ()(NSError *,std::tuple<NSData * {__strong},NSData * {__strong}> &&)>::~__value_func[abi:ne180100](void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t caulk::xpc::sync_message<objc_object  {objcproto33CarbonComponentScannerXPCProtocol}* {__strong},NSData * {__strong},NSData *>::~sync_message(uint64_t a1)
{
  std::__function::__value_func<void ()(NSError *,std::tuple<NSData * {__strong},NSData * {__strong}> &&)>::~__value_func[abi:ne180100]((void *)(a1 + 8));
  return a1;
}

uint64_t std::__function::__value_func<void ()(NSError *,std::tuple<NSData * {__strong},NSData * {__strong}> &&)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void ___ZN5caulk3xpc7messageIU8__strongPU44objcproto33CarbonComponentScannerXPCProtocol11objc_objectJU8__strongP6NSDataS7_EE5replyEv_block_invoke(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  std::function<void ()(NSError *,std::tuple<NSData * {__strong},NSData * {__strong}> &&)>::operator()(a1 + 32, a2, (uint64_t)&v7);
}

void sub_1901B93BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  _Unwind_Resume(a1);
}

void *__destroy_helper_block_ea8_32c71_ZTSNSt3__18functionIFvP7NSErrorONS_5tupleIJU8__strongP6NSDataS6_EEEEEE(uint64_t a1)
{
  return std::__function::__value_func<void ()(NSError *,std::tuple<NSData * {__strong},NSData * {__strong}> &&)>::~__value_func[abi:ne180100]((void *)(a1 + 32));
}

uint64_t __copy_helper_block_ea8_32c71_ZTSNSt3__18functionIFvP7NSErrorONS_5tupleIJU8__strongP6NSDataS6_EEEEEE(uint64_t a1, uint64_t a2)
{
  return std::__function::__value_func<void ()(NSError *,std::tuple<NSData * {__strong},NSData * {__strong}> &&)>::__value_func[abi:ne180100](a1 + 32, a2 + 32);
}

void std::function<void ()(NSError *,std::tuple<NSData * {__strong},NSData * {__strong}> &&)>::operator()(uint64_t a1, void *a2, uint64_t a3)
{
  id v6 = a2;
  uint64_t v5 = *(void *)(a1 + 24);
  if (!v5) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  (*(void (**)(uint64_t, id *, uint64_t))(*(void *)v5 + 48))(v5, &v6, a3);
}

void sub_1901B9464(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void ___ZN5caulk3xpc7messageIU8__strongPU44objcproto33CarbonComponentScannerXPCProtocol11objc_objectJU8__strongP6NSDataS7_EE10sync_proxyEv_block_invoke(uint64_t a1, void *a2)
{
  id v2 = 0;
  id v3 = 0;
  std::function<void ()(NSError *,std::tuple<NSData * {__strong},NSData * {__strong}> &&)>::operator()(a1 + 32, a2, (uint64_t)&v2);
}

void sub_1901B94BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  _Unwind_Resume(a1);
}

void std::__function::__func<caulk::xpc::sync_message<objc_object  {objcproto33CarbonComponentScannerXPCProtocol}* {__strong},NSData * {__strong},NSData *>::sync_message(NSXPCConnection *)::{lambda(NSError *,std::tuple<NSData *,NSData *> &&)#1},std::allocator<std::tuple<NSData *,NSData *> &>,void ()(NSError,std::tuple<NSData *,NSData *>)>::operator()(uint64_t a1, id *a2, id *a3)
{
  id v5 = *a2;
  uint64_t v6 = *(void *)(a1 + 8);
  id v7 = *(void **)(v6 + 40);
  *(void *)(v6 + 40) = v5;
  id v8 = v5;

  objc_storeStrong((id *)(v6 + 48), *a3);
  objc_storeStrong((id *)(v6 + 56), a3[1]);
}

uint64_t std::__function::__func<caulk::xpc::sync_message<objc_object  {objcproto33CarbonComponentScannerXPCProtocol}* {__strong},NSData * {__strong},NSData *>::sync_message(NSXPCConnection *)::{lambda(NSError *,std::tuple<NSData *,NSData *> &&)#1},std::allocator<std::tuple<NSData *,NSData *> &>,void ()(NSError,std::tuple<NSData *,NSData *>)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EDFA14A0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<caulk::xpc::sync_message<objc_object  {objcproto33CarbonComponentScannerXPCProtocol}* {__strong},NSData * {__strong},NSData *>::sync_message(NSXPCConnection *)::{lambda(NSError *,std::tuple<NSData *,NSData *> &&)#1},std::allocator<std::tuple<NSData *,NSData *> &>,void ()(NSError,std::tuple<NSData *,NSData *>)>::__clone(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = &unk_1EDFA14A0;
  result[1] = v3;
  return result;
}

void std::__function::__func<caulk::xpc::sync_message<objc_object  {objcproto33CarbonComponentScannerXPCProtocol}* {__strong},NSData * {__strong},NSData *>::sync_message(NSXPCConnection *)::{lambda(NSError *,std::tuple<NSData *,NSData *> &&)#1},std::allocator<std::tuple<NSData *,NSData *> &>,void ()(NSError,std::tuple<NSData *,NSData *>)>::~__func()
{
}

void sub_1901B9934(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  caulk::xpc::sync_message<objc_object  {objcproto33CarbonComponentScannerXPCProtocol}* {__strong},NSData * {__strong}>::~sync_message((uint64_t)va);
  _Unwind_Resume(a1);
}

void *std::__function::__value_func<void ()(NSError *,std::tuple<NSData * {__strong}> &&)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t caulk::xpc::sync_message<objc_object  {objcproto33CarbonComponentScannerXPCProtocol}* {__strong},NSData * {__strong}>::~sync_message(uint64_t a1)
{
  std::__function::__value_func<void ()(NSError *,std::tuple<NSData * {__strong}> &&)>::~__value_func[abi:ne180100]((void *)(a1 + 8));
  return a1;
}

uint64_t std::__function::__value_func<void ()(NSError *,std::tuple<NSData * {__strong}> &&)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void ___ZN5caulk3xpc7messageIU8__strongPU44objcproto33CarbonComponentScannerXPCProtocol11objc_objectJU8__strongP6NSDataEE5replyEv_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  std::function<void ()(NSError *,std::tuple<NSData * {__strong}> &&)>::operator()(a1 + 32, a2, (uint64_t)&v5);
}

void sub_1901B9BA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void *__destroy_helper_block_ea8_32c68_ZTSNSt3__18functionIFvP7NSErrorONS_5tupleIJU8__strongP6NSDataEEEEEE(uint64_t a1)
{
  return std::__function::__value_func<void ()(NSError *,std::tuple<NSData * {__strong}> &&)>::~__value_func[abi:ne180100]((void *)(a1 + 32));
}

uint64_t __copy_helper_block_ea8_32c68_ZTSNSt3__18functionIFvP7NSErrorONS_5tupleIJU8__strongP6NSDataEEEEEE(uint64_t a1, uint64_t a2)
{
  return std::__function::__value_func<void ()(NSError *,std::tuple<NSData * {__strong}> &&)>::__value_func[abi:ne180100](a1 + 32, a2 + 32);
}

void std::function<void ()(NSError *,std::tuple<NSData * {__strong}> &&)>::operator()(uint64_t a1, void *a2, uint64_t a3)
{
  id v6 = a2;
  uint64_t v5 = *(void *)(a1 + 24);
  if (!v5) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  (*(void (**)(uint64_t, id *, uint64_t))(*(void *)v5 + 48))(v5, &v6, a3);
}

void sub_1901B9C40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void ___ZN5caulk3xpc7messageIU8__strongPU44objcproto33CarbonComponentScannerXPCProtocol11objc_objectJU8__strongP6NSDataEE10sync_proxyEv_block_invoke(uint64_t a1, void *a2)
{
  id v2 = 0;
  std::function<void ()(NSError *,std::tuple<NSData * {__strong}> &&)>::operator()(a1 + 32, a2, (uint64_t)&v2);
}

void sub_1901B9C90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void std::__function::__func<caulk::xpc::sync_message<objc_object  {objcproto33CarbonComponentScannerXPCProtocol}* {__strong},NSData * {__strong}>::sync_message(NSXPCConnection *)::{lambda(NSError *,std::tuple<NSData *> &&)#1},std::allocator<std::tuple<NSData *> &>,void ()(NSError,std::tuple<NSData *>)>::operator()(uint64_t a1, id *a2, id *a3)
{
  id v5 = *a2;
  uint64_t v6 = *(void *)(a1 + 8);
  id v7 = *(void **)(v6 + 40);
  *(void *)(v6 + 40) = v5;
  id v8 = v5;

  objc_storeStrong((id *)(v6 + 48), *a3);
}

uint64_t std::__function::__func<caulk::xpc::sync_message<objc_object  {objcproto33CarbonComponentScannerXPCProtocol}* {__strong},NSData * {__strong}>::sync_message(NSXPCConnection *)::{lambda(NSError *,std::tuple<NSData *> &&)#1},std::allocator<std::tuple<NSData *> &>,void ()(NSError,std::tuple<NSData *>)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EDFA1458;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<caulk::xpc::sync_message<objc_object  {objcproto33CarbonComponentScannerXPCProtocol}* {__strong},NSData * {__strong}>::sync_message(NSXPCConnection *)::{lambda(NSError *,std::tuple<NSData *> &&)#1},std::allocator<std::tuple<NSData *> &>,void ()(NSError,std::tuple<NSData *>)>::__clone(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = &unk_1EDFA1458;
  result[1] = v3;
  return result;
}

void std::__function::__func<caulk::xpc::sync_message<objc_object  {objcproto33CarbonComponentScannerXPCProtocol}* {__strong},NSData * {__strong}>::sync_message(NSXPCConnection *)::{lambda(NSError *,std::tuple<NSData *> &&)#1},std::allocator<std::tuple<NSData *> &>,void ()(NSError,std::tuple<NSData *>)>::~__func()
{
}

void sub_1901BA070(_Unwind_Exception *a1)
{
  objc_destroyWeak(v2);
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v3 - 56));
  _Unwind_Resume(a1);
}

void sub_1901BA100(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1901BA168(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t IPCAUCallbackSender_LaunchRequestComplete(mach_port_t a1, int a2, int a3)
{
  uint64_t v6 = *MEMORY[0x1E4F14068];
  int v7 = a2;
  int v8 = a3;
  *(void *)&msg.msgh_bits = 19;
  msg.msgh_voucher_port = 0;
  msg.msgh_id = 90103;
  msg.msgh_remote_port = a1;
  msg.msgh_local_port = 0;
  if (MEMORY[0x1E4F14B18]) {
    voucher_mach_msg_set(&msg);
  }
  uint64_t v3 = mach_msg(&msg, 17, 0x28u, 0, 0, gMediaServerTimeout, 0);
  if (v3 == 268435460)
  {
    if ((msg.msgh_bits & 0x1F00) == 0x1100) {
      mach_port_deallocate(*MEMORY[0x1E4F14960], msg.msgh_local_port);
    }
    mach_msg_destroy(&msg);
  }
  return v3;
}

_DWORD *_XLaunchRequestComplete(_DWORD *result, uint64_t a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if ((*result & 0x80000000) != 0 || result[1] != 40)
  {
    int v3 = -304;
    goto LABEL_7;
  }
  if (result[10] || result[11] <= 0x1Fu)
  {
    int v3 = -309;
LABEL_7:
    *(_DWORD *)(a2 + 32) = v3;
    *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
    return result;
  }
  int v5 = result[8];
  int v4 = result[9];
  uint64_t v6 = CADeprecated::TSingleton<IPCAUClient>::instance();
  if (kInterAppAudioScope)
  {
    int v7 = *(NSObject **)kInterAppAudioScope;
    if (!*(void *)kInterAppAudioScope) {
      goto LABEL_14;
    }
  }
  else
  {
    int v7 = MEMORY[0x1E4F14500];
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)AudioComponentVector buf = 136315906;
    unint64_t v16 = "IPCAUClient.h";
    __int16 v17 = 1024;
    int v18 = 369;
    __int16 v19 = 1024;
    int v20 = v5;
    __int16 v21 = 1024;
    BOOL v22 = v4 != 0;
    _os_log_impl(&dword_18FEC0000, v7, OS_LOG_TYPE_DEBUG, "%25s:%-5d token %d, success %d", buf, 0x1Eu);
  }
LABEL_14:
  unint64_t v9 = (CADeprecated::CAGuard *)(v6 + 88);
  uint64_t v8 = *(void *)(v6 + 88);
  uint64_t v13 = v6 + 88;
  char v14 = (*(uint64_t (**)(uint64_t))(v8 + 16))(v6 + 88);
  int v10 = *(_DWORD *)(v6 + 224);
  if (v10 == v5)
  {
    if (v4) {
      int v11 = 2;
    }
    else {
      int v11 = 1;
    }
    *(_DWORD *)(v6 + 228) = v11;
    goto LABEL_25;
  }
  if (!kInterAppAudioScope)
  {
    unint64_t v12 = MEMORY[0x1E4F14500];
LABEL_23:
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)AudioComponentVector buf = 136315650;
      unint64_t v16 = "IPCAUClient.h";
      __int16 v17 = 1024;
      int v18 = 375;
      __int16 v19 = 1024;
      int v20 = v10;
      _os_log_impl(&dword_18FEC0000, v12, OS_LOG_TYPE_DEBUG, "%25s:%-5d doesn't match wait token %d", buf, 0x18u);
    }
    goto LABEL_25;
  }
  unint64_t v12 = *(NSObject **)kInterAppAudioScope;
  if (*(void *)kInterAppAudioScope) {
    goto LABEL_23;
  }
LABEL_25:
  CADeprecated::CAGuard::Locker::~Locker((CADeprecated::CAGuard::Locker *)&v13);
  double result = (_DWORD *)CADeprecated::CAGuard::Notify(v9);
  *(_DWORD *)(a2 + 32) = 0;
  return result;
}

void _XRemoteControlEvent(_DWORD *a1, uint64_t a2)
{
  if ((*a1 & 0x80000000) != 0 || a1[1] != 40)
  {
    int v3 = -304;
    goto LABEL_7;
  }
  if (a1[10] || a1[11] <= 0x1Fu)
  {
    int v3 = -309;
LABEL_7:
    *(_DWORD *)(a2 + 32) = v3;
    *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
    return;
  }
  uint64_t v4 = a1[9];
  uint64_t v7 = CADeprecated::TSingleton<IPCAUClient>::instance();
  char v8 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 16))(v7);
  uint64_t v5 = BaseOpaqueObject::ResolveOpaqueRef();
  if (v5)
  {
    uint64_t v6 = *(void *)(v5 + 520);
    if (v6) {
      (*(void (**)(uint64_t, uint64_t))(v6 + 16))(v6, v4);
    }
  }
  CADeprecated::CAMutex::Locker::~Locker((CADeprecated::CAMutex::Locker *)&v7);
  *(_DWORD *)(a2 + 32) = 0;
}

void sub_1901BA5D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void _XPropertiesChanged(_DWORD *a1, uint64_t a2)
{
  mach_msg_return_t v14;
  int v15;
  unsigned int v16;
  char *v17;
  char *v18;
  uint64_t *v19;
  int v20;
  NSObject *v21;
  const void *v22;
  uint64_t v23;
  char v24;
  uint64_t v25;
  unsigned int v26;
  int v27;
  uint64_t v28;
  char v29;
  int v30;
  void v31[2];
  char v32;
  uint64_t *v33;
  int *v34;
  const void **v35;
  int *v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  int v40;
  _DWORD msg[9];
  long long v42;
  _OWORD __n[17];
  uint64_t v44;

  float v44 = *MEMORY[0x1E4F143B8];
  if ((*a1 & 0x80000000) != 0 || a1[1] != 36)
  {
    int v3 = -304;
    goto LABEL_7;
  }
  if (a1[9] || a1[10] <= 0x1Fu)
  {
    int v3 = -309;
LABEL_7:
    *(_DWORD *)(a2 + 32) = v3;
    *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
    return;
  }
  uint64_t v23 = CADeprecated::TSingleton<IPCAUClient>::instance();
  size_t v24 = (*(uint64_t (**)(uint64_t))(*(void *)v23 + 16))(v23);
  uint64_t v4 = BaseOpaqueObject::ResolveOpaqueRef();
  uint64_t v5 = v4;
  if (v4)
  {
    uint8x8_t v32 = 1;
    v31[0] = &unk_1EDF93860;
    v31[1] = 256;
    uint64_t v33 = &v37;
    unint64_t v34 = &v38;
    unint64_t v35 = (const void **)&v39;
    uint64_t v36 = &v40;
    unint64_t v38 = 0;
    uint64_t v39 = 0;
    unint64_t v40 = 0;
    uint8x8_t v30 = 0;
    IPCAUClient::RemoteAUServer::TransientWaker::TransientWaker(&v28, *(void *)(v4 + 16), &v30);
    if (v30)
    {
LABEL_10:
      IPCAUClient::RemoteAUServer::TransientWaker::~TransientWaker((IPCAUClient::RemoteAUServer::TransientWaker *)&v28);
      MIGVariableLengthRefs::~MIGVariableLengthRefs((MIGVariableLengthRefs *)v31);
      goto LABEL_11;
    }
    int v6 = *(_DWORD *)(*(void *)(v5 + 16) + 48);
    if (v29) {
      mach_msg_timeout_t v7 = 0x7FFFFFFF;
    }
    else {
      mach_msg_timeout_t v7 = 10000;
    }
    int v8 = *(_DWORD *)(v5 + 80);
    unint64_t v9 = v33;
    int v10 = v34;
    unint64_t v12 = v35;
    int v11 = v36;
    memset(__n, 0, sizeof(__n));
    long long v42 = 0u;
    memset(&msg[1], 0, 32);
    *(void *)&msg[6] = *MEMORY[0x1E4F14068];
    msg[8] = v8;
    mach_port_name_t reply_port = mig_get_reply_port();
    msg[3] = reply_port;
    msg[0] = 5395;
    msg[2] = v6;
    *(void *)&msg[4] = 0x1606200000000;
    if (MEMORY[0x1E4F14B18])
    {
      voucher_mach_msg_set((mach_msg_header_t *)msg);
      mach_port_name_t reply_port = msg[3];
    }
    char v14 = mach_msg((mach_msg_header_t *)msg, 275, 0x24u, 0x144u, reply_port, v7, 0);
    uint64_t v15 = v14;
    if ((v14 - 268435458) <= 0xE && ((1 << (v14 - 2)) & 0x4003) != 0)
    {
      mig_put_reply_port(msg[3]);
    }
    else
    {
      if (!v14)
      {
        if (msg[5] == 71)
        {
          uint64_t v15 = -308;
        }
        else if (msg[5] == 90310)
        {
          if ((msg[0] & 0x80000000) != 0)
          {
            uint64_t v15 = -300;
            if (msg[6] == 1
              && msg[1] >= 0x3Cu
              && msg[1] <= 0x13Cu
              && !msg[2]
              && BYTE3(v42) == 1
              && LODWORD(__n[0]) <= 0x100
              && (msg[1] - 60) >= LODWORD(__n[0]))
            {
              unint64_t v16 = (LODWORD(__n[0]) + 3) & 0xFFFFFFFC;
              if (msg[1] == v16 + 60)
              {
                __int16 v17 = (char *)msg + v16;
                if (DWORD1(v42) == *((_DWORD *)v17 + 14))
                {
                  int v18 = v17 - 256;
                  __int16 v19 = v9;
                  int v20 = __n[0];
                  memcpy(v19, (char *)__n + 4, LODWORD(__n[0]));
                  uint64_t v15 = 0;
                  *int v10 = v20;
                  *unint64_t v12 = *(const void **)&msg[7];
                  *int v11 = *((_DWORD *)v18 + 78);
                  goto LABEL_53;
                }
              }
            }
          }
          else if (msg[1] == 36)
          {
            uint64_t v15 = -300;
            if (msg[8])
            {
              if (msg[2]) {
                uint64_t v15 = -300;
              }
              else {
                uint64_t v15 = msg[8];
              }
            }
          }
          else
          {
            uint64_t v15 = -300;
          }
        }
        else
        {
          uint64_t v15 = -301;
        }
        mach_msg_destroy((mach_msg_header_t *)msg);
LABEL_48:
        if (v15 == 268435459 || v15 == -308)
        {
          if (kInterAppAudioScope)
          {
            __int16 v21 = *(NSObject **)kInterAppAudioScope;
            if (!*(void *)kInterAppAudioScope) {
              goto LABEL_10;
            }
          }
          else
          {
            __int16 v21 = MEMORY[0x1E4F14500];
          }
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
          {
            msg[0] = 136315906;
            *(void *)&msg[1] = "IPCAUClient.cpp";
            LOWORD(msg[3]) = 1024;
            *(_DWORD *)((char *)&msg[3] + 2) = 433;
            HIWORD(msg[4]) = 1024;
            msg[5] = v15;
            LOWORD(msg[6]) = 1024;
            *(_DWORD *)((char *)&msg[6] + 2) = -66749;
            _os_log_impl(&dword_18FEC0000, v21, OS_LOG_TYPE_DEFAULT, "%25s:%-5d converting result %d -> %d", (uint8_t *)msg, 0x1Eu);
          }
          goto LABEL_10;
        }
LABEL_53:
        if (!v15)
        {
          if (*v35) {
            BOOL v22 = *v35;
          }
          else {
            BOOL v22 = v33;
          }
          CADeserializer::CADeserializer((CADeserializer *)msg, v22);
          uint64_t v27 = 0;
          CADeserializer::Read((CADeserializer *)msg, &v27);
          for (; v27; --v27)
          {
            int v26 = 0;
            uint64_t v25 = 0;
            CADeserializer::Read((CADeserializer *)msg, &v26);
            CADeserializer::Read((CADeserializer *)msg, (char *)&v25 + 4);
            CADeserializer::Read((CADeserializer *)msg, &v25);
            RemoteAUPropertyListeners::Notify(*(RemoteAUPropertyListeners **)(v5 + 104), *(OpaqueAudioComponentInstance **)(v5 + 112), *(void *)(v5 + 72), v26, HIDWORD(v25), v25);
          }
          MEMORY[0x192FC7A90](msg);
        }
        goto LABEL_10;
      }
      mig_dealloc_reply_port(msg[3]);
    }
    if (v15 == 268435460)
    {
      if ((msg[0] & 0x1F00) == 0x1100) {
        mach_port_deallocate(*MEMORY[0x1E4F14960], msg[3]);
      }
      mach_msg_destroy((mach_msg_header_t *)msg);
      uint64_t v15 = 268435460;
      goto LABEL_53;
    }
    goto LABEL_48;
  }
LABEL_11:
  CADeprecated::CAMutex::Locker::~Locker((CADeprecated::CAMutex::Locker *)&v23);
  *(_DWORD *)(a2 + 32) = 0;
}

void sub_1901BAB84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59)
{
}

void _XAUListChanged(_DWORD *a1, uint64_t a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if ((*a1 & 0x80000000) != 0 || a1[1] != 24)
  {
    int v3 = -304;
    goto LABEL_7;
  }
  if (a1[6] || a1[7] <= 0x1Fu)
  {
    int v3 = -309;
LABEL_7:
    *(_DWORD *)(a2 + 32) = v3;
    *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
    return;
  }
  if (!kInterAppAudioScope)
  {
    uint64_t v4 = MEMORY[0x1E4F14500];
LABEL_12:
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      int v6 = 136315394;
      mach_msg_timeout_t v7 = "IPCAUClient.cpp";
      __int16 v8 = 1024;
      int v9 = 1284;
      _os_log_impl(&dword_18FEC0000, v4, OS_LOG_TYPE_DEBUG, "%25s:%-5d IPCAUCallbackReceiver_AUListChanged", (uint8_t *)&v6, 0x12u);
    }
    goto LABEL_14;
  }
  uint64_t v4 = *(NSObject **)kInterAppAudioScope;
  if (*(void *)kInterAppAudioScope) {
    goto LABEL_12;
  }
LABEL_14:
  uint64_t v5 = (IPCAUClient *)CADeprecated::TSingleton<IPCAUClient>::instance();
  IPCAUClient::RefreshRemoteAUList(v5);
  *(_DWORD *)(a2 + 32) = 0;
}

uint64_t (*IPCAudioUnitCallbacks_server_routine(uint64_t a1))()
{
  int v1 = *(_DWORD *)(a1 + 20);
  if ((v1 - 90104) >= 0xFFFFFFFC) {
    return IPCAUCallbackReceiver_IPCAudioUnitCallbacks_subsystem[5 * (v1 - 90100) + 5];
  }
  else {
    return 0;
  }
}

uint64_t IPCAudioUnitCallbacks_server(_DWORD *a1, uint64_t a2)
{
  int v2 = a1[2];
  *(_DWORD *)a2 = *a1 & 0x1F;
  *(_DWORD *)(a2 + 4) = 36;
  int v3 = a1[5] + 100;
  *(_DWORD *)(a2 + 8) = v2;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 1std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  *(_DWORD *)(a2 + 20) = v3;
  int v4 = a1[5];
  if ((v4 - 90104) >= 0xFFFFFFFC
    && (uint64_t v5 = (void (*)(void))IPCAUCallbackReceiver_IPCAudioUnitCallbacks_subsystem[5 * (v4 - 90100) + 5]) != 0)
  {
    v5();
    return 1;
  }
  else
  {
    uint64_t result = 0;
    *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
    *(_DWORD *)(a2 + 32) = -303;
  }
  return result;
}

uint64_t IPCAUClient_Uninitialize(int a1, mach_msg_timeout_t a2, int a3)
{
  *(_OWORD *)&msg[20] = 0u;
  uint64_t v11 = 0;
  *(_OWORD *)&msg[4] = 0u;
  *(void *)&msg[24] = *MEMORY[0x1E4F14068];
  *(_DWORD *)&msg[32] = a3;
  mach_port_name_t reply_port = mig_get_reply_port();
  *(_DWORD *)&msg[8] = a1;
  *(_DWORD *)&msg[12] = reply_port;
  *(_DWORD *)mach_msg_header_t msg = 5395;
  *(void *)&msg[16] = 0x1605B00000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set((mach_msg_header_t *)msg);
    mach_port_name_t reply_port = *(_DWORD *)&msg[12];
  }
  uint64_t v6 = mach_msg((mach_msg_header_t *)msg, 275, 0x24u, 0x2Cu, reply_port, a2, 0);
  uint64_t v7 = v6;
  if ((v6 - 268435458) <= 0xE && ((1 << (v6 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(*(mach_port_t *)&msg[12]);
  }
  else
  {
    if (!v6)
    {
      if (*(_DWORD *)&msg[20] == 71)
      {
        uint64_t v8 = 4294966988;
      }
      else if (*(_DWORD *)&msg[20] == 90303)
      {
        uint64_t v8 = 4294966996;
        if ((*(_DWORD *)msg & 0x80000000) == 0 && *(_DWORD *)&msg[4] == 36 && !*(_DWORD *)&msg[8])
        {
          uint64_t v8 = *(unsigned int *)&msg[32];
          if (!*(_DWORD *)&msg[32]) {
            return 0;
          }
        }
      }
      else
      {
        uint64_t v8 = 4294966995;
      }
LABEL_20:
      mach_msg_destroy((mach_msg_header_t *)msg);
      return v8;
    }
    mig_dealloc_reply_port(*(mach_port_t *)&msg[12]);
  }
  uint64_t v8 = 268435460;
  if (v7 == 268435460)
  {
    if ((*(_WORD *)msg & 0x1F00) == 0x1100) {
      mach_port_deallocate(*MEMORY[0x1E4F14960], *(mach_port_name_t *)&msg[12]);
    }
    goto LABEL_20;
  }
  return v7;
}

uint64_t IPCAUClient_ConnectInput(mach_port_t a1, mach_msg_timeout_t a2, unsigned int a3, char a4, long long *a5)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  long long v7 = a5[1];
  long long v20 = *a5;
  uint64_t v14 = *MEMORY[0x1E4F14068];
  unsigned int v15 = a3;
  int v16 = 0;
  char v17 = a4;
  __int16 v18 = 0;
  char v19 = 0;
  long long v21 = v7;
  uint64_t v22 = *((void *)a5 + 4);
  mach_port_t reply_port = mig_get_reply_port();
  *(void *)&v13.msgh_bits = 5395;
  v13.msgh_remote_port = a1;
  v13.msgh_local_port = reply_port;
  *(void *)&v13.msgh_voucher_port = 0x1606500000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set(&v13);
    mach_port_t reply_port = v13.msgh_local_port;
  }
  uint64_t v9 = mach_msg(&v13, 275, 0x54u, 0x2Cu, reply_port, a2, 0);
  uint64_t v10 = v9;
  if ((v9 - 268435458) <= 0xE && ((1 << (v9 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(v13.msgh_local_port);
  }
  else
  {
    if (!v9)
    {
      if (v13.msgh_id == 71)
      {
        uint64_t v11 = 4294966988;
      }
      else if (v13.msgh_id == 90313)
      {
        uint64_t v11 = 4294966996;
        if ((v13.msgh_bits & 0x80000000) == 0 && *(void *)&v13.msgh_size == 36)
        {
          uint64_t v11 = v15;
          if (!v15) {
            return 0;
          }
        }
      }
      else
      {
        uint64_t v11 = 4294966995;
      }
LABEL_19:
      mach_msg_destroy(&v13);
      return v11;
    }
    mig_dealloc_reply_port(v13.msgh_local_port);
  }
  uint64_t v11 = 268435460;
  if (v10 == 268435460)
  {
    if ((v13.msgh_bits & 0x1F00) == 0x1100) {
      mach_port_deallocate(*MEMORY[0x1E4F14960], v13.msgh_local_port);
    }
    goto LABEL_19;
  }
  return v10;
}

uint64_t IPCAURegClient_SetProcessWakeState(int a1, int a2, int a3, _DWORD *a4)
{
  memset(&rcv_name[16], 0, 28);
  *(_OWORD *)rcv_name = 0u;
  *(void *)&rcv_name[20] = *MEMORY[0x1E4F14068];
  *(_DWORD *)&rcv_name[28] = a2;
  *(_DWORD *)&rcv_name[32] = a3;
  mach_port_name_t reply_port = mig_get_reply_port();
  *(_DWORD *)&rcv_name[4] = a1;
  *(_DWORD *)&rcv_name[8] = reply_port;
  int v12 = 5395;
  *(void *)&rcv_name[12] = 0x15F9B00000000;
  if (MEMORY[0x1E4F14B18])
  {
    voucher_mach_msg_set((mach_msg_header_t *)&v12);
    mach_port_name_t reply_port = *(_DWORD *)&rcv_name[8];
  }
  uint64_t v7 = mach_msg((mach_msg_header_t *)&v12, 275, 0x28u, 0x30u, reply_port, gMediaServerTimeout, 0);
  uint64_t v8 = v7;
  if ((v7 - 268435458) <= 0xE && ((1 << (v7 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(*(mach_port_t *)&rcv_name[8]);
    goto LABEL_21;
  }
  if (!v7)
  {
    if (*(_DWORD *)&rcv_name[16] == 71)
    {
      uint64_t v8 = 4294966988;
    }
    else if (*(_DWORD *)&rcv_name[16] == 90111)
    {
      if ((v12 & 0x80000000) == 0)
      {
        if (*(_DWORD *)rcv_name == 40)
        {
          if (!*(_DWORD *)&rcv_name[4])
          {
            uint64_t v8 = *(unsigned int *)&rcv_name[28];
            if (!*(_DWORD *)&rcv_name[28])
            {
              *a4 = *(_DWORD *)&rcv_name[32];
              return v8;
            }
            goto LABEL_29;
          }
        }
        else if (*(_DWORD *)rcv_name == 36)
        {
          if (*(_DWORD *)&rcv_name[4]) {
            BOOL v10 = 1;
          }
          else {
            BOOL v10 = *(_DWORD *)&rcv_name[28] == 0;
          }
          if (v10) {
            uint64_t v8 = 4294966996;
          }
          else {
            uint64_t v8 = *(unsigned int *)&rcv_name[28];
          }
          goto LABEL_29;
        }
      }
      uint64_t v8 = 4294966996;
    }
    else
    {
      uint64_t v8 = 4294966995;
    }
LABEL_29:
    mach_msg_destroy((mach_msg_header_t *)&v12);
    return v8;
  }
  mig_dealloc_reply_port(*(mach_port_t *)&rcv_name[8]);
LABEL_21:
  if (v8 == 268435460)
  {
    if ((v12 & 0x1F00) == 0x1100) {
      mach_port_deallocate(*MEMORY[0x1E4F14960], *(mach_port_name_t *)&rcv_name[8]);
    }
    mach_msg_destroy((mach_msg_header_t *)&v12);
    return 268435460;
  }
  return v8;
}

uint64_t _XGetSessionInfo(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) != 0 || *(_DWORD *)(result + 4) != 24)
  {
    int v4 = -304;
    goto LABEL_7;
  }
  int v3 = *(_DWORD *)(result + 24);
  result += 24;
  if (!v3 && *(_DWORD *)(result + 4) > 0x1Fu)
  {
    *(_DWORD *)(a2 + 3std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = 16777473;
    long long v5 = *(_OWORD *)(result + 36);
    *(_OWORD *)v49.val = *(_OWORD *)(result + 20);
    *(_OWORD *)&v49.val[4] = v5;
    pid_t pidp = 0;
    uint64_t result = ClientHasInterAppAudioEntitlement(&v49, &pidp);
    if ((result & 1) == 0)
    {
      int v41 = -66748;
LABEL_81:
      *(_DWORD *)(a2 + 32) = v41;
      goto LABEL_8;
    }
    CASerializer::CASerializer(&v56, 0);
    uint64_t v6 = CADeprecated::TSingleton<IPCAURegistrar>::instance();
    uint64_t v7 = (void *)v6;
    uint64_t v9 = *(void *)(v6 + 296);
    uint64_t v8 = *(void *)(v6 + 304);
    if (v9 != v8)
    {
      BOOL v10 = 0;
      uint64_t v11 = 0;
      pid_t v12 = pidp;
      unint64_t v45 = 0;
      uint64_t v47 = *(void *)(v6 + 304);
      size_t v48 = (void *)v6;
      pid_t v46 = pidp;
      do
      {
        if (*(_DWORD *)(v9 + 20) == v12)
        {
          __int32 v13 = *(_DWORD *)(v9 + 16);
          size_t v14 = v11 - v10;
          unsigned int v15 = wmemchr(v10, v13, v14);
          if (v15) {
            int v16 = v15;
          }
          else {
            int v16 = v11;
          }
          if (v16 == v11)
          {
            if ((unint64_t)v11 >= v45)
            {
              unint64_t v17 = v14 + 1;
              if ((v14 + 1) >> 62) {
                std::vector<float>::__throw_length_error[abi:ne180100]();
              }
              if ((uint64_t)(v45 - (void)v10) >> 1 > v17) {
                unint64_t v17 = (uint64_t)(v45 - (void)v10) >> 1;
              }
              if (v45 - (unint64_t)v10 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v18 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v18 = v17;
              }
              if (v18) {
                unint64_t v18 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v18);
              }
              else {
                uint64_t v19 = 0;
              }
              long long v20 = (__int32 *)(v18 + 4 * v14);
              __int32 *v20 = v13;
              long long v21 = v20 + 1;
              while (v11 != v10)
              {
                __int32 v22 = *--v11;
                *--long long v20 = v22;
              }
              unint64_t v45 = v18 + 4 * v19;
              if (v10) {
                operator delete(v10);
              }
              BOOL v10 = v20;
              uint64_t v11 = v21;
            }
            else
            {
              *v11++ = v13;
            }
            for (uint64_t i = (int8x16_t **)v7[29]; i != (int8x16_t **)v7[30]; ++i)
            {
              size_t v24 = *i;
              if ((*i)->i32[3] == v13)
              {
                float v44 = v11;
                LOBYTE(v50) = 1;
                HIDWORD(v50) = v13;
                uint64_t v51 = 0;
                int8x16_t v52 = vextq_s8(v24[1], v24[1], 8uLL);
                CFUUIDRef v25 = CFUUIDCreateFromUUIDBytes(0, *(CFUUIDBytes *)v9);
                if (v25)
                {
                  CFStringRef v26 = CFUUIDCreateString(0, v25);
                  CFStringRef v27 = v26;
                  if (v26)
                  {
                    CFStringRef v28 = CFStringCreateWithFormat(0, 0, @"com-apple-audiounit:%@/%c", v26, 72);
                    if (v28)
                    {
                      CFURLRef v29 = CFURLCreateWithString(0, v28, 0);
                      CFRelease(v28);
                    }
                    else
                    {
                      CFURLRef v29 = 0;
                    }
                    CFRelease(v27);
                  }
                  else
                  {
                    CFURLRef v29 = 0;
                  }
                  CFRelease(v25);
                }
                else
                {
                  CFURLRef v29 = 0;
                }
                CFTypeRef cf = v29;
                v58[0] = v50;
                CASerializer::Write(&v56, v58);
                CASerializer::Write(&v56, (char *)&v50 + 4);
                operator<<();
                operator<<();
                operator<<();
                CFRelease(cf);
                uint64_t v30 = v7[37];
                uint64_t v31 = v7[38];
                while (v30 != v31)
                {
                  if (*(_DWORD *)(v30 + 16) == v13)
                  {
                    uint8x8_t v32 = (int8x16_t **)v48[29];
                    uint64_t v33 = (int8x16_t **)v48[30];
                    if (v32 != v33)
                    {
                      int v34 = *(_DWORD *)(v30 + 20);
                      while (1)
                      {
                        unint64_t v35 = *v32;
                        if ((*v32)->i32[3] == v34) {
                          break;
                        }
                        if (++v32 == v33) {
                          goto LABEL_69;
                        }
                      }
                      LOBYTE(v50) = 0;
                      HIDWORD(v50) = v34;
                      uint64_t v51 = 0;
                      int8x16_t v52 = vextq_s8(v35[1], v35[1], 8uLL);
                      CFUUIDRef v36 = CFUUIDCreateFromUUIDBytes(0, *(CFUUIDBytes *)v30);
                      if (v36)
                      {
                        CFStringRef v37 = CFUUIDCreateString(0, v36);
                        CFStringRef v38 = v37;
                        if (v37)
                        {
                          CFStringRef v39 = CFStringCreateWithFormat(0, 0, @"com-apple-audiounit:%@/%c", v37, 78);
                          if (v39)
                          {
                            CFURLRef v40 = CFURLCreateWithString(0, v39, 0);
                            CFRelease(v39);
                          }
                          else
                          {
                            CFURLRef v40 = 0;
                          }
                          CFRelease(v38);
                        }
                        else
                        {
                          CFURLRef v40 = 0;
                        }
                        CFRelease(v36);
                      }
                      else
                      {
                        CFURLRef v40 = 0;
                      }
                      CFTypeRef cf = v40;
                      v58[0] = v50;
                      CASerializer::Write(&v56, v58);
                      CASerializer::Write(&v56, (char *)&v50 + 4);
                      operator<<();
                      operator<<();
                      operator<<();
                      CFRelease(cf);
                    }
                  }
LABEL_69:
                  v30 += 24;
                }
                uint64_t v8 = v47;
                uint64_t v7 = v48;
                pid_t v12 = v46;
                uint64_t v11 = v44;
                goto LABEL_19;
              }
            }
          }
          uint64_t v8 = v47;
          pid_t v12 = v46;
        }
LABEL_19:
        v9 += 24;
      }
      while (v9 != v8);
      if (v10) {
        operator delete(v10);
      }
    }
    uint64_t v50 = &unk_1EDF93470;
    uint64_t v51 = 0;
    v52.i8[0] = *(void *)(a2 + 28) != 0;
    v52.i64[1] = 0;
    CFTypeRef cf = 0;
    uint64_t v54 = a2 + 28;
    uint64_t v55 = a2 + 52;
    *(void *)(a2 + 28) = 0;
    *(_DWORD *)(a2 + 52) = 0;
    if (v56.var0)
    {
      BytePtr = CFDataGetBytePtr(v56.var0);
      if (v56.var0)
      {
        vm_size_t Length = CFDataGetLength(v56.var0);
LABEL_79:
        int v41 = MIGVariableLengthRefs::Write((MIGVariableLengthRefs *)&v50, BytePtr, Length);
        if (!v41)
        {
          v52.i8[0] = 0;
          MIGVariableLengthRefs::~MIGVariableLengthRefs((MIGVariableLengthRefs *)&v50);
          uint64_t result = MEMORY[0x192FC7960](&v56);
          *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 52);
          *(void *)(a2 + 44) = *MEMORY[0x1E4F14068];
          *(_DWORD *)a2 |= 0x80000000;
          *(_DWORD *)(a2 + 4) = 56;
          *(_DWORD *)(a2 + 24) = 1;
          return result;
        }
        MIGVariableLengthRefs::~MIGVariableLengthRefs((MIGVariableLengthRefs *)&v50);
        uint64_t result = MEMORY[0x192FC7960](&v56);
        goto LABEL_81;
      }
    }
    else
    {
      BytePtr = 0;
    }
    vm_size_t Length = 0;
    goto LABEL_79;
  }
  int v4 = -309;
LABEL_7:
  *(_DWORD *)(a2 + 32) = v4;
LABEL_8:
  *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
  return result;
}

void sub_1901BB888(_Unwind_Exception *a1)
{
  MEMORY[0x192FC7960](v1 - 104);
  _Unwind_Resume(a1);
}

void _XURLOpen(uint64_t a1, uint64_t a2)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  int v3 = -304;
  if ((*(_DWORD *)a1 & 0x80000000) == 0)
  {
    uint64_t v4 = *(unsigned int *)(a1 + 4);
    if (v4 >= 0x24 && v4 <= 0x124)
    {
      CFIndex v5 = *(unsigned int *)(a1 + 32);
      if (v5 <= 0x100 && (int)v4 - 36 >= v5)
      {
        if (v4 != ((v5 + 3) & 0xFFFFFFFC) + 36)
        {
          int v3 = -304;
          goto LABEL_11;
        }
        uint64_t v6 = (_DWORD *)(((v4 + 3) & 0x1FFFFFFFCLL) + a1);
        if (*v6 || v6[1] < 0x20u)
        {
          int v3 = -309;
          goto LABEL_11;
        }
        CFURLRef v8 = CFURLCreateWithBytes(0, (const UInt8 *)(a1 + 36), v5, 0x8000100u, 0);
        uint64_t v9 = (void *)CADeprecated::TSingleton<IPCAURegistrar>::instance();
        CFStringRef v10 = CFURLCopyScheme(v8);
        if (v10)
        {
          CFStringRef v11 = v10;
          if (CFEqual(@"com-apple-audiounit", v10))
          {
            CFStringRef v12 = CFURLCopyResourceSpecifier(v8);
            if (v12)
            {
              CFStringRef v13 = v12;
              CFIndex Length = CFStringGetLength(v12);
              CFIndex v15 = Length - 2;
              if (Length > 2)
              {
                v48.location = Length - 2;
                v48.length = 2;
                CFStringGetCharacters(v13, v48, &buffer);
                if (buffer == 47)
                {
                  int v16 = v37;
                  if (v37 == 78 || v37 == 72)
                  {
                    v49.location = 0;
                    v49.length = v15;
                    CFStringRef v17 = CFStringCreateWithSubstring(0, v13, v49);
                    CFUUIDRef v18 = CFUUIDCreateFromString(0, v17);
                    if (v18)
                    {
                      CFUUIDRef v19 = v18;
                      if (kInterAppAudioScope)
                      {
                        long long v20 = *(NSObject **)kInterAppAudioScope;
                        if (!*(void *)kInterAppAudioScope)
                        {
LABEL_38:
                          CFUUIDBytes v22 = CFUUIDGetUUIDBytes(v19);
                          for (uint64_t i = v9[37]; i != v9[38]; i += 24)
                          {
                            if (*(void *)&v22.byte0 == *(void *)i && *(void *)&v22.byte8 == *(void *)(i + 8))
                            {
                              if (v16 == 72) {
                                uint64_t v26 = 16;
                              }
                              else {
                                uint64_t v26 = 20;
                              }
                              uint64_t v27 = v9[29];
                              uint64_t v28 = v9[30];
                              if (v27 != v28)
                              {
                                int v29 = *(_DWORD *)(i + v26);
                                while (*(_DWORD *)(*(void *)v27 + 12) != v29)
                                {
                                  v27 += 8;
                                  if (v27 == v28) {
                                    goto LABEL_55;
                                  }
                                }
                                uint64_t v31 = *(void *)(*(void *)v27 + 16);
                                uint8x8_t v32 = (void *)MEMORY[0x192FC9400]();
                                id v33 = objc_alloc_init(NSClassFromString(&cfstr_Bkssystemservi.isa));
                                if ((int)[v33 pidForApplication:v31] >= 1) {
                                  objc_msgSend(v33, "openApplication:options:clientPort:withResult:", v31, 0, objc_msgSend(v33, "createClientPort"), &__block_literal_global_14710);
                                }

                                goto LABEL_67;
                              }
LABEL_55:
                              if (kInterAppAudioScope)
                              {
                                uint64_t v30 = *(NSObject **)kInterAppAudioScope;
                                if (!*(void *)kInterAppAudioScope)
                                {
LABEL_67:
                                  CFRelease(v19);
                                  goto LABEL_68;
                                }
                              }
                              else
                              {
                                uint64_t v30 = MEMORY[0x1E4F14500];
                              }
                              if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
                              {
                                int v34 = *(_DWORD *)(i + 16);
                                int v35 = *(_DWORD *)(i + 20);
                                *(_DWORD *)AudioComponentVector buf = 136316162;
                                CFStringRef v39 = "IPCAURegistrar.mm";
                                __int16 v40 = 1024;
                                int v41 = 1074;
                                __int16 v42 = 2112;
                                CFURLRef v43 = v8;
                                __int16 v44 = 1024;
                                *(_DWORD *)unint64_t v45 = v34;
                                *(_WORD *)&char v45[4] = 1024;
                                *(_DWORD *)&v45[6] = v35;
                                _os_log_impl(&dword_18FEC0000, v30, OS_LOG_TYPE_ERROR, "%25s:%-5d Inter-app URL '%@' appears valid for processes %d - %d, but process not found", buf, 0x28u);
                              }
                              goto LABEL_67;
                            }
                          }
                          CFRelease(v19);
                          if (kInterAppAudioScope)
                          {
                            CFUUIDRef v25 = *(NSObject **)kInterAppAudioScope;
                            if (!*(void *)kInterAppAudioScope) {
                              goto LABEL_68;
                            }
                          }
                          else
                          {
                            CFUUIDRef v25 = MEMORY[0x1E4F14500];
                          }
                          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
                          {
                            *(_DWORD *)AudioComponentVector buf = 136315650;
                            CFStringRef v39 = "IPCAURegistrar.mm";
                            __int16 v40 = 1024;
                            int v41 = 1082;
                            __int16 v42 = 2112;
                            CFURLRef v43 = v8;
                            _os_log_impl(&dword_18FEC0000, v25, OS_LOG_TYPE_ERROR, "%25s:%-5d Inter-app URL '%@' does not refer to an active/valid connection", buf, 0x1Cu);
                          }
LABEL_68:
                          CFRelease(v17);
                          CFRelease(v13);
                          CFRelease(v11);
                          if (!v8) {
                            goto LABEL_34;
                          }
                          goto LABEL_33;
                        }
                      }
                      else
                      {
                        long long v20 = MEMORY[0x1E4F14500];
                      }
                      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
                      {
                        *(_DWORD *)AudioComponentVector buf = 136316162;
                        CFStringRef v39 = "IPCAURegistrar.mm";
                        __int16 v40 = 1024;
                        int v41 = 1066;
                        __int16 v42 = 2112;
                        CFURLRef v43 = v8;
                        __int16 v44 = 2112;
                        *(void *)unint64_t v45 = v19;
                        *(_WORD *)&v45[8] = 1024;
                        BOOL v46 = v16 == 72;
                        _os_log_impl(&dword_18FEC0000, v20, OS_LOG_TYPE_DEBUG, "%25s:%-5d url %@; uuid %@ host %d",
                          buf,
                          0x2Cu);
                      }
                      goto LABEL_38;
                    }
                    CFRelease(v17);
                  }
                }
              }
              CFRelease(v13);
            }
          }
          CFRelease(v11);
        }
        if (kInterAppAudioScope)
        {
          long long v21 = *(NSObject **)kInterAppAudioScope;
          if (!*(void *)kInterAppAudioScope) {
            goto LABEL_32;
          }
        }
        else
        {
          long long v21 = MEMORY[0x1E4F14500];
        }
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)AudioComponentVector buf = 136315650;
          CFStringRef v39 = "IPCAURegistrar.mm";
          __int16 v40 = 1024;
          int v41 = 1095;
          __int16 v42 = 2112;
          CFURLRef v43 = v8;
          _os_log_impl(&dword_18FEC0000, v21, OS_LOG_TYPE_ERROR, "%25s:%-5d Malformed inter-app URL: '%@'", buf, 0x1Cu);
        }
LABEL_32:
        if (!v8)
        {
LABEL_34:
          int v3 = 0;
          goto LABEL_11;
        }
LABEL_33:
        CFRelease(v8);
        goto LABEL_34;
      }
    }
  }
LABEL_11:
  uint64_t v7 = (void *)MEMORY[0x1E4F14068];
  *(_DWORD *)(a2 + 32) = v3;
  *(void *)(a2 + 24) = *v7;
}

uint64_t _XSetExtensionProcessWakeState(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if ((*(_DWORD *)a1 & 0x80000000) != 0 || *(_DWORD *)(a1 + 4) != 40)
  {
    uint64_t result = 4294966992;
  }
  else if (*(_DWORD *)(a1 + 40) || *(_DWORD *)(a1 + 44) < 0x20u)
  {
    uint64_t result = 4294966987;
  }
  else
  {
    CFIndex v5 = (RegistrarClientProcess *)*(unsigned int *)(a1 + 32);
    int v6 = *(_DWORD *)(a1 + 36);
    long long v7 = *(_OWORD *)(a1 + 76);
    long long v12 = *(_OWORD *)(a1 + 60);
    long long v13 = v7;
    pid_t pidp = 0;
    *(_OWORD *)atoken.val = v12;
    *(_OWORD *)&atoken.val[4] = v7;
    audit_token_to_au32(&atoken, 0, 0, 0, 0, 0, &pidp, 0, 0);
    CFURLRef v8 = (IPCAURegistrar *)CADeprecated::TSingleton<IPCAURegistrar>::instance();
    uint64_t result = IPCAURegistrar::SetProcessWakeState(v8, pidp, v5, v6, &v9);
  }
  uint64_t v4 = (void *)MEMORY[0x1E4F14068];
  *(_DWORD *)(a2 + 32) = result;
  *(void *)(a2 + 24) = *v4;
  return result;
}

uint64_t _XSetProcessWakeState(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) != 0 || *(_DWORD *)(result + 4) != 40)
  {
    int v3 = -304;
    goto LABEL_7;
  }
  if (*(_DWORD *)(result + 40) || *(_DWORD *)(result + 44) <= 0x1Fu)
  {
    int v3 = -309;
LABEL_7:
    *(_DWORD *)(a2 + 32) = v3;
    uint64_t v4 = *MEMORY[0x1E4F14068];
    goto LABEL_8;
  }
  CFIndex v5 = (RegistrarClientProcess *)*(unsigned int *)(result + 32);
  int v6 = *(_DWORD *)(result + 36);
  long long v7 = *(_OWORD *)(result + 76);
  *(_OWORD *)v9.val = *(_OWORD *)(result + 60);
  *(_OWORD *)&v9.val[4] = v7;
  pid_t pidp = 0;
  uint64_t result = ClientHasInterAppAudioEntitlement(&v9, &pidp);
  if ((result & 1) == 0)
  {
    int v3 = -66748;
    goto LABEL_7;
  }
  CFURLRef v8 = (IPCAURegistrar *)CADeprecated::TSingleton<IPCAURegistrar>::instance();
  uint64_t result = IPCAURegistrar::SetProcessWakeState(v8, pidp, v5, v6, (int *)(a2 + 36));
  *(_DWORD *)(a2 + 32) = result;
  uint64_t v4 = *MEMORY[0x1E4F14068];
  if (!result)
  {
    *(void *)(a2 + 24) = v4;
    *(_DWORD *)(a2 + 4) = 40;
    return result;
  }
LABEL_8:
  *(void *)(a2 + 24) = v4;
  return result;
}

uint64_t _XCloseConnection(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) != 0 || *(_DWORD *)(result + 4) != 48)
  {
    int v3 = -304;
  }
  else if (*(_DWORD *)(result + 48) || *(_DWORD *)(result + 52) < 0x20u)
  {
    int v3 = -309;
  }
  else
  {
    long long v4 = *(_OWORD *)(result + 84);
    *(_OWORD *)v10.val = *(_OWORD *)(result + 68);
    *(_OWORD *)&v10.val[4] = v4;
    long long v12 = *(_OWORD *)(result + 32);
    pid_t pidp = 0;
    uint64_t result = ClientHasInterAppAudioEntitlement(&v10, &pidp);
    if (result)
    {
      uint64_t result = CADeprecated::TSingleton<IPCAURegistrar>::instance();
      uint64_t v6 = *(void *)(result + 296);
      uint64_t v5 = *(void *)(result + 304);
      if (v6 == v5)
      {
LABEL_17:
        int v3 = -3000;
      }
      else
      {
        uint64_t v7 = result;
        while (*(_DWORD *)(v6 + 16) != pidp
             || (void)v12 != *(void *)v6
             || *((void *)&v12 + 1) != *(void *)(v6 + 8))
        {
          v6 += 24;
          if (v6 == v5) {
            goto LABEL_17;
          }
        }
        uint64_t v9 = v5 - (v6 + 24);
        if (v5 != v6 + 24) {
          uint64_t result = (uint64_t)memmove((void *)v6, (const void *)(v6 + 24), v5 - (v6 + 24));
        }
        int v3 = 0;
        *(void *)(v7 + 304) = v6 + v9;
      }
    }
    else
    {
      int v3 = -66748;
    }
  }
  *(_DWORD *)(a2 + 32) = v3;
  *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
  return result;
}

void _XGetAUServerPort(uint64_t a1, uint64_t a2)
{
  *(void *)((char *)&v49[1] + 4) = *MEMORY[0x1E4F143B8];
  if ((*(_DWORD *)a1 & 0x80000000) != 0 || *(_DWORD *)(a1 + 4) != 52)
  {
    int v3 = -304;
    goto LABEL_7;
  }
  if (*(_DWORD *)(a1 + 52) || *(_DWORD *)(a1 + 56) <= 0x1Fu)
  {
    int v3 = -309;
LABEL_7:
    *(_DWORD *)(a2 + 32) = v3;
    *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
    return;
  }
  *(void *)(a2 + 32) = 0x13000000000000;
  long long v4 = *(_OWORD *)(a1 + 88);
  *(_OWORD *)v41.val = *(_OWORD *)(a1 + 72);
  *(_OWORD *)&v41.val[4] = v4;
  AudioComponentDescription v40 = *(AudioComponentDescription *)(a1 + 32);
  pid_t pidp = 0;
  if (!ClientHasInterAppAudioEntitlement(&v41, &pidp))
  {
    int v3 = -66748;
    goto LABEL_7;
  }
  uint64_t v5 = (void *)CADeprecated::TSingleton<IPCAURegistrar>::instance();
  pid_t v6 = pidp;
  if (kInterAppAudioScope)
  {
    uint64_t v7 = *(NSObject **)kInterAppAudioScope;
    if (!*(void *)kInterAppAudioScope) {
      goto LABEL_17;
    }
  }
  else
  {
    uint64_t v7 = MEMORY[0x1E4F14500];
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    CAFormatter::CAFormatter((CAFormatter *)&v43, &v40);
    *(_DWORD *)AudioComponentVector buf = 136315650;
    unint64_t v45 = "IPCAURegistrar.mm";
    __int16 v46 = 1024;
    int v47 = 980;
    __int16 v48 = 2080;
    v49[0] = v43;
    _os_log_impl(&dword_18FEC0000, v7, OS_LOG_TYPE_DEBUG, "%25s:%-5d desc %s", buf, 0x1Cu);
    if (v43) {
      free(v43);
    }
  }
LABEL_17:
  for (uint64_t i = v5[29]; ; i += 8)
  {
    if (i == v5[30])
    {
      int v3 = -50;
      goto LABEL_7;
    }
    if (*(_DWORD *)(*(void *)i + 12) == v6) {
      break;
    }
  }
  for (uint64_t j = (uint64_t *)v5[33]; ; ++j)
  {
    if (j == (uint64_t *)v5[34])
    {
      if (kInterAppAudioScope)
      {
        long long v12 = *(NSObject **)kInterAppAudioScope;
        if (!*(void *)kInterAppAudioScope)
        {
LABEL_38:
          int v3 = -3000;
          goto LABEL_7;
        }
      }
      else
      {
        long long v12 = MEMORY[0x1E4F14500];
      }
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)AudioComponentVector buf = 136315394;
        unint64_t v45 = "IPCAURegistrar.mm";
        __int16 v46 = 1024;
        int v47 = 1010;
        _os_log_impl(&dword_18FEC0000, v12, OS_LOG_TYPE_DEBUG, "%25s:%-5d error: unknown desc", buf, 0x12u);
      }
      goto LABEL_38;
    }
    uint64_t v10 = *j;
    if (*(void *)&v40.componentType == *(void *)(*j + 24)
      && v40.componentManufacturer == (unint64_t)*(unsigned int *)(*j + 32))
    {
      break;
    }
  }
  if (!*(void *)(v10 + 64))
  {
    if (kInterAppAudioScope)
    {
      long long v21 = *(NSObject **)kInterAppAudioScope;
      if (!*(void *)kInterAppAudioScope)
      {
LABEL_54:
        int v3 = -4;
        goto LABEL_7;
      }
    }
    else
    {
      long long v21 = MEMORY[0x1E4F14500];
    }
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)AudioComponentVector buf = 136315394;
      unint64_t v45 = "IPCAURegistrar.mm";
      __int16 v46 = 1024;
      int v47 = 989;
      _os_log_impl(&dword_18FEC0000, v21, OS_LOG_TYPE_ERROR, "%25s:%-5d node app not found", buf, 0x12u);
    }
    goto LABEL_54;
  }
  CFUUIDRef v13 = CFUUIDCreate(0);
  CFUUIDBytes v15 = CFUUIDGetUUIDBytes(v13);
  uint64_t v14 = *(void *)&v15.byte8;
  uint64_t v16 = *(void *)&v15.byte0;
  int v17 = *(_DWORD *)(*(void *)(v10 + 64) + 12);
  CFUUIDRef v19 = (CFUUIDBytes *)v5[38];
  unint64_t v18 = v5[39];
  if ((unint64_t)v19 >= v18)
  {
    CFUUIDRef v39 = v13;
    CFUUIDBytes v22 = (CFUUIDBytes *)v5[37];
    unint64_t v23 = 0xAAAAAAAAAAAAAAABLL * (((char *)v19 - (char *)v22) >> 3) + 1;
    if (v23 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v24 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v18 - (void)v22) >> 3);
    if (2 * v24 > v23) {
      unint64_t v23 = 2 * v24;
    }
    if (v24 >= 0x555555555555555) {
      unint64_t v25 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v25 = v23;
    }
    if (v25)
    {
      if (v25 > 0xAAAAAAAAAAAAAAALL) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint64_t v26 = (char *)operator new(24 * v25);
      uint64_t v14 = *(void *)&v15.byte8;
      uint64_t v16 = *(void *)&v15.byte0;
    }
    else
    {
      uint64_t v26 = 0;
    }
    uint64_t v27 = &v26[8 * (((char *)v19 - (char *)v22) >> 3)];
    *(void *)uint64_t v27 = v16;
    *((void *)v27 + 1) = v14;
    uint64_t v28 = &v26[24 * v25];
    *((_DWORD *)v27 + 4) = v6;
    *((_DWORD *)v27 + 5) = v17;
    p_byte8 = v27 + 24;
    if (v19 == v22)
    {
      CFUUIDRef v13 = v39;
    }
    else
    {
      CFUUIDRef v13 = v39;
      do
      {
        long long v29 = *(_OWORD *)&v19[-2].byte8;
        *((void *)v27 - 1) = *(void *)&v19[-1].byte8;
        *(_OWORD *)(v27 - 24) = v29;
        v27 -= 24;
        CFUUIDRef v19 = (CFUUIDBytes *)((char *)v19 - 24);
      }
      while (v19 != v22);
      CFUUIDRef v19 = (CFUUIDBytes *)v5[37];
    }
    v5[37] = v27;
    v5[38] = p_byte8;
    v5[39] = v28;
    if (v19)
    {
      uint64_t v30 = v19;
      uint64_t v31 = v16;
      uint64_t v32 = v14;
      operator delete(v30);
      uint64_t v14 = v32;
      uint64_t v16 = v31;
    }
  }
  else
  {
    *CFUUIDRef v19 = v15;
    p_byte8 = (char *)&v19[1].byte8;
    *(_DWORD *)&v19[1].byte0 = v6;
    *(_DWORD *)&v19[1].byte4 = v17;
  }
  v5[38] = p_byte8;
  *(void *)(a2 + 52) = v16;
  *(void *)(a2 + 60) = v14;
  if (kInterAppAudioScope)
  {
    id v33 = *(NSObject **)kInterAppAudioScope;
    if (!*(void *)kInterAppAudioScope) {
      goto LABEL_69;
    }
  }
  else
  {
    id v33 = MEMORY[0x1E4F14500];
  }
  if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)AudioComponentVector buf = 136315650;
    unint64_t v45 = "IPCAURegistrar.mm";
    __int16 v46 = 1024;
    int v47 = 1001;
    __int16 v48 = 2112;
    v49[0] = v13;
    _os_log_impl(&dword_18FEC0000, v33, OS_LOG_TYPE_DEBUG, "%25s:%-5d conn UUID %@", buf, 0x1Cu);
  }
LABEL_69:
  CFRelease(v13);
  uint64_t v34 = *(void *)(v10 + 64);
  uint64_t v35 = *(void *)(v34 + 176);
  if (v35) {
    int v36 = *(_DWORD *)(v35 + 12);
  }
  else {
    int v36 = 0;
  }
  *(_DWORD *)(a2 + 28) = v36;
  int v37 = *(_DWORD *)(v34 + 12);
  *(_DWORD *)(a2 + 48) = v37;
  if (kInterAppAudioScope)
  {
    CFStringRef v38 = *(NSObject **)kInterAppAudioScope;
    if (!*(void *)kInterAppAudioScope) {
      goto LABEL_78;
    }
  }
  else
  {
    CFStringRef v38 = MEMORY[0x1E4F14500];
  }
  if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)AudioComponentVector buf = 136315906;
    unint64_t v45 = "IPCAURegistrar.mm";
    __int16 v46 = 1024;
    int v47 = 1006;
    __int16 v48 = 1024;
    LODWORD(v49[0]) = v36;
    WORD2(v49[0]) = 1024;
    *(_DWORD *)((char *)v49 + std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = v37;
    _os_log_impl(&dword_18FEC0000, v38, OS_LOG_TYPE_DEBUG, "%25s:%-5d returning 0x%x/%d", buf, 0x1Eu);
  }
LABEL_78:
  *(void *)(a2 + 40) = *MEMORY[0x1E4F14068];
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 68;
  *(_DWORD *)(a2 + 24) = 1;
}

void _XCheckLaunchAUServer(uint64_t a1, uint64_t a2)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  if ((*(_DWORD *)a1 & 0x80000000) != 0 || *(_DWORD *)(a1 + 4) != 56)
  {
    int v3 = -304;
    goto LABEL_7;
  }
  if (*(_DWORD *)(a1 + 56) || *(_DWORD *)(a1 + 60) <= 0x1Fu)
  {
    int v3 = -309;
LABEL_7:
    *(_DWORD *)(a2 + 32) = v3;
    uint64_t v4 = *MEMORY[0x1E4F14068];
LABEL_8:
    *(void *)(a2 + 24) = v4;
    return;
  }
  long long v5 = *(_OWORD *)(a1 + 92);
  *(_OWORD *)v31.val = *(_OWORD *)(a1 + 76);
  *(_OWORD *)&v31.val[4] = v5;
  *(_OWORD *)&v30.OSType componentType = *(_OWORD *)(a1 + 32);
  int v6 = *(_DWORD *)(a1 + 52);
  v30.componentFlagsMasuint64_t k = *(_DWORD *)(a1 + 48);
  pid_t pidp = 0;
  if (!ClientHasInterAppAudioEntitlement(&v31, &pidp))
  {
    int v3 = -66748;
    goto LABEL_7;
  }
  uint64_t v7 = (void *)CADeprecated::TSingleton<IPCAURegistrar>::instance();
  CFURLRef v8 = (PlatformUtilities *)pidp;
  if (kInterAppAudioScope)
  {
    uint64_t v9 = *(NSObject **)kInterAppAudioScope;
    if (!*(void *)kInterAppAudioScope) {
      goto LABEL_23;
    }
  }
  else
  {
    uint64_t v9 = MEMORY[0x1E4F14500];
  }
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    PlatformUtilities::processName(v8);
    int v10 = SHIBYTE(v44);
    CFStringRef v11 = (void **)__p;
    CAFormatter::CAFormatter((CAFormatter *)&v46, &v30);
    if (v10 >= 0) {
      p_p = &__p;
    }
    else {
      p_p = v11;
    }
    *(_DWORD *)AudioComponentVector buf = 136315906;
    *(void *)&uint8_t buf[4] = "IPCAURegistrar.mm";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = 904;
    *(_WORD *)&unsigned char buf[18] = 2080;
    *(void *)&buf[20] = p_p;
    *(_WORD *)&buf[28] = 2080;
    *(void *)&buf[30] = v46;
    _os_log_impl(&dword_18FEC0000, v9, OS_LOG_TYPE_DEBUG, "%25s:%-5d process '%s' requesting desc %s", buf, 0x26u);
    if (v46) {
      free(v46);
    }
    if (SHIBYTE(v44) < 0) {
      operator delete(__p);
    }
  }
LABEL_23:
  for (uint64_t i = (uint64_t *)v7[29]; ; ++i)
  {
    if (i == (uint64_t *)v7[30])
    {
      int v3 = -50;
      goto LABEL_7;
    }
    uint64_t v14 = *i;
    if (*(_DWORD *)(*i + 12) == v8) {
      break;
    }
  }
  for (uint64_t j = (uint64_t *)v7[33]; ; ++j)
  {
    if (j == (uint64_t *)v7[34])
    {
      if (kInterAppAudioScope)
      {
        unint64_t v18 = *(NSObject **)kInterAppAudioScope;
        if (!*(void *)kInterAppAudioScope)
        {
LABEL_43:
          int v3 = -3000;
          goto LABEL_7;
        }
      }
      else
      {
        unint64_t v18 = MEMORY[0x1E4F14500];
      }
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)AudioComponentVector buf = 136315394;
        *(void *)&uint8_t buf[4] = "IPCAURegistrar.mm";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 953;
        _os_log_impl(&dword_18FEC0000, v18, OS_LOG_TYPE_DEBUG, "%25s:%-5d unknown desc", buf, 0x12u);
      }
      goto LABEL_43;
    }
    uint64_t v16 = *j;
    if (*(void *)&v30.componentType == *(void *)(*j + 24)
      && v30.componentManufacturer == (unint64_t)*(unsigned int *)(*j + 32))
    {
      break;
    }
  }
  std::string __p = 0;
  CFURLRef v43 = &__p;
  uint64_t v44 = 0x2020000000;
  int v45 = 0;
  uint64_t v19 = *(void *)(v16 + 16);
  v33[0] = MEMORY[0x1E4F143A8];
  v33[1] = 3221225472;
  uint64_t v34 = ___ZN14IPCAURegistrar19CheckLaunchAUServerEiRK25AudioComponentDescriptionjRi_block_invoke;
  uint64_t v35 = &unk_1E5688638;
  uint64_t v38 = v14;
  uint64_t v39 = v16;
  int v36 = &__p;
  int v37 = v7;
  int v40 = v6;
  int v41 = (int)v8;
  long long v20 = (void *)MEMORY[0x192FC9400]();
  id v21 = objc_alloc_init(NSClassFromString(&cfstr_Bkssystemservi.isa));
  uint64_t v22 = [v21 pidForApplication:v19];
  if ((int)v22 <= 0)
  {
    uint64_t v23 = objc_msgSend(v21, "createClientPort", v22);
    if (OpenAUApp_suspendKey
      || (unint64_t v24 = dlopen("/System/Library/PrivateFrameworks/BackBoardServices.framework/BackBoardServices", 1),
          (OpenAUApp_suspendKey = *(void *)dlsym(v24, "BKSOpenApplicationOptionKeyActivateSuspended")) != 0))
    {
      unint64_t v25 = (void *)MEMORY[0x1E4F1C9E8];
      uint64_t v26 = objc_msgSend(MEMORY[0x1E4F28ED0], "numberWithBool:", 1, *(void *)&v30.componentType);
      uint64_t v27 = [v25 dictionaryWithObject:v26 forKey:OpenAUApp_suspendKey];
    }
    else
    {
      uint64_t v27 = 0;
    }
    *(void *)AudioComponentVector buf = MEMORY[0x1E4F143A8];
    *(void *)&uint8_t buf[8] = 3221225472;
    *(void *)&buf[16] = __OpenAUApp_block_invoke;
    *(void *)&unsigned char buf[24] = &unk_1E5688C60;
    *(void *)&buf[32] = v33;
    objc_msgSend(v21, "openApplication:options:clientPort:withResult:", v19, v27, v23, buf, *(void *)&v30.componentType);
  }
  else
  {
    v34((uint64_t)v33, 0, (PlatformUtilities *)v22);
  }

  uint64_t v28 = v43;
  if (*((_DWORD *)v43 + 6))
  {
    *(_DWORD *)(a2 + 3std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
    int v29 = *((_DWORD *)v28 + 6);
  }
  else
  {
    int v29 = 0;
    *(_DWORD *)(a2 + 3std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = 1;
  }
  _Block_object_dispose(&__p, 8);
  *(_DWORD *)(a2 + 32) = v29;
  uint64_t v4 = *MEMORY[0x1E4F14068];
  if (v29) {
    goto LABEL_8;
  }
  *(void *)(a2 + 24) = v4;
  *(_DWORD *)(a2 + 4) = 40;
}

void sub_1901BCB90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
}

uint64_t _XGetAUList(uint64_t result, uint64_t a2)
{
  *(void *)&v27[9] = *MEMORY[0x1E4F143B8];
  if ((*(_DWORD *)result & 0x80000000) != 0 || *(_DWORD *)(result + 4) != 24)
  {
    int v4 = -304;
    goto LABEL_7;
  }
  int v3 = *(_DWORD *)(result + 24);
  result += 24;
  if (v3 || *(_DWORD *)(result + 4) <= 0x1Fu)
  {
    int v4 = -309;
LABEL_7:
    *(_DWORD *)(a2 + 32) = v4;
LABEL_8:
    *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
    return result;
  }
  *(_DWORD *)(a2 + 3std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = 16777473;
  long long v5 = *(_OWORD *)(result + 36);
  *(_OWORD *)v20.val = *(_OWORD *)(result + 20);
  *(_OWORD *)&v20.val[4] = v5;
  pid_t pidp = 0;
  uint64_t result = ClientHasInterAppAudioEntitlement(&v20, &pidp);
  if ((result & 1) == 0)
  {
    int v9 = -66748;
LABEL_42:
    *(_DWORD *)(a2 + 32) = v9;
    goto LABEL_8;
  }
  CASerializer::CASerializer((CASerializer *)&theData, 0);
  int v6 = (void *)CADeprecated::TSingleton<IPCAURegistrar>::instance();
  uint64_t v7 = (PlatformUtilities *)pidp;
  if (kInterAppAudioScope)
  {
    CFURLRef v8 = *(NSObject **)kInterAppAudioScope;
    if (!*(void *)kInterAppAudioScope) {
      goto LABEL_21;
    }
  }
  else
  {
    CFURLRef v8 = MEMORY[0x1E4F14500];
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    PlatformUtilities::processName(v7);
    if (v24 >= 0) {
      p_p = &__p;
    }
    else {
      p_p = __p;
    }
    uint64_t v11 = (v6[34] - v6[33]) >> 3;
    *(_DWORD *)AudioComponentVector buf = 136315906;
    *(void *)&uint8_t buf[4] = "IPCAURegistrar.mm";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = 844;
    __int16 v26 = 2080;
    *(void *)uint64_t v27 = p_p;
    LOWORD(v27[2]) = 1024;
    *(_DWORD *)((char *)&v27[2] + 2) = v11;
    _os_log_impl(&dword_18FEC0000, v8, OS_LOG_TYPE_DEBUG, "%25s:%-5d process '%s' fetching %d AUs", buf, 0x22u);
    if (v24 < 0) {
      operator delete(__p);
    }
  }
LABEL_21:
  uint64_t v12 = v6[29];
  uint64_t v13 = v6[30];
  if (v12 == v13)
  {
LABEL_25:
    if (kInterAppAudioScope)
    {
      CFUUIDBytes v15 = *(NSObject **)kInterAppAudioScope;
      if (!*(void *)kInterAppAudioScope)
      {
LABEL_37:
        uint64_t result = MEMORY[0x192FC7960](&theData);
        int v9 = -50;
        goto LABEL_42;
      }
    }
    else
    {
      CFUUIDBytes v15 = MEMORY[0x1E4F14500];
    }
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)AudioComponentVector buf = 136315394;
      *(void *)&uint8_t buf[4] = "IPCAURegistrar.mm";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 852;
      _os_log_impl(&dword_18FEC0000, v15, OS_LOG_TYPE_DEBUG, "%25s:%-5d error: unknown subscriber pid", buf, 0x12u);
    }
    goto LABEL_37;
  }
  uint64_t v14 = (void *)(a2 + 28);
  while (*(_DWORD *)(*(void *)v12 + 12) != v7)
  {
    v12 += 8;
    if (v12 == v13) {
      goto LABEL_25;
    }
  }
  *(unsigned char *)(*(void *)v12 + 33) = 0;
  *(_DWORD *)AudioComponentVector buf = (v6[34] - v6[33]) >> 3;
  CASerializer::Write((CASerializer *)&theData, buf);
  for (uint64_t i = (uint64_t *)v6[33]; i != (uint64_t *)v6[34]; ++i)
  {
    uint64_t v17 = *i;
    CASerializer::Write((CASerializer *)&theData, (const void *)(*i + 8));
    operator<<();
    CASerializer::Write((CASerializer *)&theData, (const void *)(v17 + 24));
    CASerializer::Write((CASerializer *)&theData, (const void *)(v17 + 28));
    CASerializer::Write((CASerializer *)&theData, (const void *)(v17 + 32));
    CASerializer::Write((CASerializer *)&theData, (const void *)(v17 + 36));
    CASerializer::Write((CASerializer *)&theData, (const void *)(v17 + 40));
    operator<<();
    CASerializer::Write((CASerializer *)&theData, (const void *)(v17 + 56));
  }
  *(void *)AudioComponentVector buf = &unk_1EDF93470;
  *(void *)&uint8_t buf[8] = 0;
  buf[16] = *v14 != 0;
  *(_OWORD *)&v27[1] = 0uLL;
  *(void *)&v27[5] = a2 + 28;
  *(void *)&v27[7] = a2 + 52;
  *uint64_t v14 = 0;
  *(_DWORD *)(a2 + 52) = 0;
  if (theData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    if (theData)
    {
      vm_size_t Length = CFDataGetLength(theData);
      goto LABEL_40;
    }
  }
  else
  {
    BytePtr = 0;
  }
  vm_size_t Length = 0;
LABEL_40:
  int v9 = MIGVariableLengthRefs::Write((MIGVariableLengthRefs *)buf, BytePtr, Length);
  if (v9)
  {
    MIGVariableLengthRefs::~MIGVariableLengthRefs((MIGVariableLengthRefs *)buf);
    uint64_t result = MEMORY[0x192FC7960](&theData);
    goto LABEL_42;
  }
  buf[16] = 0;
  MIGVariableLengthRefs::~MIGVariableLengthRefs((MIGVariableLengthRefs *)buf);
  uint64_t result = MEMORY[0x192FC7960](&theData);
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 52);
  *(void *)(a2 + 44) = *MEMORY[0x1E4F14068];
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 56;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

void sub_1901BD010(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  MIGVariableLengthRefs::~MIGVariableLengthRefs((MIGVariableLengthRefs *)va1);
  MEMORY[0x192FC7960]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t _XSubscribeToAUList(uint64_t a1, uint64_t a2)
{
  if ((*(_DWORD *)a1 & 0x80000000) != 0 && *(_DWORD *)(a1 + 24) == 2 && *(_DWORD *)(a1 + 4) == 68)
  {
    if (*(unsigned __int16 *)(a1 + 38) << 16 == 1114112
      && *(unsigned char *)(a1 + 51) == 1
      && (unsigned int v3 = *(_DWORD *)(a1 + 52), v3 == *(_DWORD *)(a1 + 64)))
    {
      if (*(_DWORD *)(a1 + 68) || *(_DWORD *)(a1 + 72) < 0x20u)
      {
        uint64_t result = 4294966987;
      }
      else
      {
        int v5 = *(_DWORD *)(a1 + 28);
        int v6 = *(const void **)(a1 + 40);
        long long v7 = *(_OWORD *)(a1 + 104);
        *(_OWORD *)v8.val = *(_OWORD *)(a1 + 88);
        *(_OWORD *)&v8.val[4] = v7;
        uint64_t result = IPCAURegServer_SubscribeToAUList(&v8, v5, v6, v3);
      }
    }
    else
    {
      uint64_t result = 4294966996;
    }
  }
  else
  {
    uint64_t result = 4294966992;
  }
  *(_DWORD *)(a2 + 32) = result;
  *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
  return result;
}

void _XDestroySharedBuffer(uint64_t a1, uint64_t a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if ((*(_DWORD *)a1 & 0x80000000) != 0 || *(_DWORD *)(a1 + 4) != 40)
  {
    int v3 = -304;
    goto LABEL_7;
  }
  if (!*(_DWORD *)(a1 + 40) && *(_DWORD *)(a1 + 44) >= 0x20u)
  {
    long long v5 = *(_OWORD *)(a1 + 76);
    *(_OWORD *)v19.val = *(_OWORD *)(a1 + 60);
    *(_OWORD *)&v19.val[4] = v5;
    uint64_t v6 = *(void *)(a1 + 32);
    pid_t pidp = 0;
    if (!ClientHasInterAppAudioEntitlement(&v19, &pidp))
    {
      int v3 = -66748;
      goto LABEL_7;
    }
    uint64_t v7 = CADeprecated::TSingleton<IPCAURegistrar>::instance();
    audit_token_t v8 = *(uint64_t **)(v7 + 232);
    uint64_t v9 = *(uint64_t **)(v7 + 240);
    if (v8 != v9)
    {
      while (1)
      {
        uint64_t v10 = *v8;
        if (*(_DWORD *)(*v8 + 12) == pidp) {
          break;
        }
        if (++v8 == v9) {
          goto LABEL_12;
        }
      }
      uint64_t v12 = *(void ***)(v10 + 200);
      uint64_t v13 = *(void **)(v10 + 208);
      while (v12 != v13)
      {
        if (**v12 == v6)
        {
          CFUUIDBytes v15 = v12 + 1;
          if (v12 + 1 != v13)
          {
            do
            {
              uint64_t v12 = (void **)v15;
              uint64_t v16 = *(v15 - 1);
              *(v15 - 1) = *v15;
              *CFUUIDBytes v15 = 0;
              if (v16) {
                std::default_delete<RegistrarClientProcess::SharedMemoryBlock>::operator()[abi:ne180100](v16);
              }
              CFUUIDBytes v15 = v12 + 1;
            }
            while (v12 + 1 != v13);
            uint64_t v13 = *(void **)(v10 + 208);
          }
          while (v13 != v12)
          {
            uint64_t v18 = *--v13;
            uint64_t v17 = v18;
            void *v13 = 0;
            if (v18) {
              std::default_delete<RegistrarClientProcess::SharedMemoryBlock>::operator()[abi:ne180100](v17);
            }
          }
          int v3 = 0;
          *(void *)(v10 + 208) = v12;
          goto LABEL_7;
        }
        ++v12;
      }
      if (kInterAppAudioScope)
      {
        uint64_t v11 = *(NSObject **)kInterAppAudioScope;
        if (!*(void *)kInterAppAudioScope) {
          goto LABEL_39;
        }
      }
      else
      {
        uint64_t v11 = MEMORY[0x1E4F14500];
      }
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)AudioComponentVector buf = 136315394;
        uint64_t v22 = "IPCAURegistrar.mm";
        __int16 v23 = 1024;
        int v24 = 830;
        uint64_t v14 = "%25s:%-5d unknown buffer";
        goto LABEL_38;
      }
      goto LABEL_39;
    }
LABEL_12:
    if (kInterAppAudioScope)
    {
      uint64_t v11 = *(NSObject **)kInterAppAudioScope;
      if (!*(void *)kInterAppAudioScope)
      {
LABEL_39:
        int v3 = -50;
        goto LABEL_7;
      }
    }
    else
    {
      uint64_t v11 = MEMORY[0x1E4F14500];
    }
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)AudioComponentVector buf = 136315394;
      uint64_t v22 = "IPCAURegistrar.mm";
      __int16 v23 = 1024;
      int v24 = 820;
      uint64_t v14 = "%25s:%-5d unknown process";
LABEL_38:
      _os_log_impl(&dword_18FEC0000, v11, OS_LOG_TYPE_ERROR, v14, buf, 0x12u);
    }
    goto LABEL_39;
  }
  int v3 = -309;
LABEL_7:
  int v4 = (void *)MEMORY[0x1E4F14068];
  *(_DWORD *)(a2 + 32) = v3;
  *(void *)(a2 + 24) = *v4;
}

void _XCreateSharedBuffer(uint64_t a1, _DWORD *a2)
{
  if ((*(_DWORD *)a1 & 0x80000000) == 0 || *(_DWORD *)(a1 + 24) != 1 || *(_DWORD *)(a1 + 4) != 68)
  {
    int v4 = -304;
    goto LABEL_10;
  }
  if (*(unsigned char *)(a1 + 39) != 1 || *(_DWORD *)(a1 + 40) / 0x28u != *(_DWORD *)(a1 + 52))
  {
    int v4 = -300;
    goto LABEL_10;
  }
  if (*(_DWORD *)(a1 + 68) || *(_DWORD *)(a1 + 72) <= 0x1Fu)
  {
    int v4 = -309;
LABEL_10:
    a2[8] = v4;
    goto LABEL_11;
  }
  long long v5 = a2 + 7;
  *((void *)a2 + 4) = 0x13000000000000;
  uint64_t v6 = *(void *)(a1 + 28);
  unint64_t v7 = *(unsigned int *)(a1 + 40) / 0x28uLL;
  uint64_t v8 = *(unsigned int *)(a1 + 56);
  long long v9 = *(_OWORD *)(a1 + 104);
  *(_OWORD *)v11.val = *(_OWORD *)(a1 + 88);
  *(_OWORD *)&v11.val[4] = v9;
  int v10 = IPCAURegServer_CreateSharedBuffer(&v11, v6, v7, v8, *(void *)(a1 + 60), v5);
  mig_deallocate(*(void *)(a1 + 28), *(unsigned int *)(a1 + 40));
  *(void *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  if (!v10)
  {
    *a2 |= 0x80000000;
    a2[1] = 40;
    a2[6] = 1;
    return;
  }
  a2[8] = v10;
LABEL_11:
  *((void *)a2 + 3) = *MEMORY[0x1E4F14068];
}

uint64_t _XUnpublishAU(uint64_t a1, uint64_t a2)
{
  if ((*(_DWORD *)a1 & 0x80000000) != 0 || *(_DWORD *)(a1 + 4) != 52)
  {
    uint64_t result = 4294966992;
  }
  else if (*(_DWORD *)(a1 + 52) || *(_DWORD *)(a1 + 56) < 0x20u)
  {
    uint64_t result = 4294966987;
  }
  else
  {
    long long v4 = *(_OWORD *)(a1 + 88);
    *(_OWORD *)v7.val = *(_OWORD *)(a1 + 72);
    *(_OWORD *)&v7.val[4] = v4;
    AudioComponentDescription v6 = *(AudioComponentDescription *)(a1 + 32);
    pid_t pidp = 0;
    if (ClientHasInterAppAudioEntitlement(&v7, &pidp))
    {
      long long v5 = (IPCAURegistrar *)CADeprecated::TSingleton<IPCAURegistrar>::instance();
      uint64_t result = IPCAURegistrar::UnpublishAU(v5, (PlatformUtilities *)pidp, &v6);
    }
    else
    {
      uint64_t result = 4294900548;
    }
  }
  *(_DWORD *)(a2 + 32) = result;
  *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
  return result;
}

uint64_t _XPublishAU(uint64_t a1, uint64_t a2)
{
  if ((*(_DWORD *)a1 & 0x80000000) != 0 && *(_DWORD *)(a1 + 24) == 2 && *(_DWORD *)(a1 + 4) == 92)
  {
    if (*(unsigned __int16 *)(a1 + 38) << 16 == 1114112
      && *(unsigned char *)(a1 + 51) == 1
      && (unsigned int v3 = *(_DWORD *)(a1 + 52), v3 == *(_DWORD *)(a1 + 84)))
    {
      if (*(_DWORD *)(a1 + 92) || *(_DWORD *)(a1 + 96) < 0x20u)
      {
        uint64_t result = 4294966987;
      }
      else
      {
        int v5 = *(_DWORD *)(a1 + 28);
        AudioComponentDescription v6 = *(const void **)(a1 + 40);
        int v7 = *(_DWORD *)(a1 + 88);
        long long v8 = *(_OWORD *)(a1 + 128);
        *(_OWORD *)v10.val = *(_OWORD *)(a1 + 112);
        *(_OWORD *)&v10.val[4] = v8;
        AudioComponentDescription v9 = *(AudioComponentDescription *)(a1 + 64);
        uint64_t result = IPCAURegServer_PublishAU(&v10, v5, &v9, v6, v3, v7);
      }
    }
    else
    {
      uint64_t result = 4294966996;
    }
  }
  else
  {
    uint64_t result = 4294966992;
  }
  *(_DWORD *)(a2 + 32) = result;
  *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
  return result;
}

uint64_t _XRegisterExtensionProcess(uint64_t a1, uint64_t a2)
{
  if ((*(_DWORD *)a1 & 0x80000000) != 0 && *(_DWORD *)(a1 + 24) == 2 && *(_DWORD *)(a1 + 4) == 68)
  {
    if (*(unsigned __int16 *)(a1 + 38) << 16 == 1114112
      && *(unsigned char *)(a1 + 51) == 1
      && (unsigned int v3 = *(_DWORD *)(a1 + 52), v3 == *(_DWORD *)(a1 + 64)))
    {
      if (*(_DWORD *)(a1 + 68) || *(_DWORD *)(a1 + 72) < 0x20u)
      {
        uint64_t result = 4294966987;
      }
      else
      {
        int v5 = *(_DWORD *)(a1 + 28);
        AudioComponentDescription v6 = *(const void **)(a1 + 40);
        long long v7 = *(_OWORD *)(a1 + 104);
        v8[0] = *(_OWORD *)(a1 + 88);
        v8[1] = v7;
        uint64_t result = IPCAURegServer_RegisterExtensionProcess(v8, v5, v6, v3);
      }
    }
    else
    {
      uint64_t result = 4294966996;
    }
  }
  else
  {
    uint64_t result = 4294966992;
  }
  *(_DWORD *)(a2 + 32) = result;
  *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
  return result;
}

_DWORD *_XConnectToServer(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 24)
  {
    int v3 = -304;
    goto LABEL_7;
  }
  if (result[6] || result[7] <= 0x1Fu)
  {
    int v3 = -309;
LABEL_7:
    *(_DWORD *)(a2 + 32) = v3;
    *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
    return result;
  }
  uint64_t result = (_DWORD *)getpid();
  *(_DWORD *)(a2 + 32) = 0;
  *(_DWORD *)(a2 + 3std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = result;
  *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
  *(_DWORD *)(a2 + 4) = 40;
  return result;
}

uint64_t (*IPCAudioUnitRegistration_server_routine(uint64_t a1))()
{
  int v1 = *(_DWORD *)(a1 + 20);
  if ((v1 - 90015) >= 0xFFFFFFF1) {
    return IPCAURegServer_IPCAudioUnitRegistration_subsystem[5 * (v1 - 90000) + 5];
  }
  else {
    return 0;
  }
}

uint64_t IPCAudioUnitRegistration_server(_DWORD *a1, uint64_t a2)
{
  int v2 = a1[2];
  *(_DWORD *)a2 = *a1 & 0x1F;
  *(_DWORD *)(a2 + 4) = 36;
  int v3 = a1[5] + 100;
  *(_DWORD *)(a2 + 8) = v2;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 1std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  *(_DWORD *)(a2 + 20) = v3;
  int v4 = a1[5];
  if ((v4 - 90015) >= 0xFFFFFFF1
    && (int v5 = (void (*)(void))IPCAURegServer_IPCAudioUnitRegistration_subsystem[5 * (v4 - 90000) + 5]) != 0)
  {
    v5();
    return 1;
  }
  else
  {
    uint64_t result = 0;
    *(void *)(a2 + 24) = *MEMORY[0x1E4F14068];
    *(_DWORD *)(a2 + 32) = -303;
  }
  return result;
}

swix::message *AudioConverterXPC_Client::dispatch_message@<X0>(swix::message *a1@<X8>)
{
  return swix::message::message(a1);
}

__n128 swix::coder<AudioStreamBasicDescription>::decode(uint64_t a1, xpc_object_t xdict, char *key)
{
  size_t length = 0;
  data = xpc_dictionary_get_data(xdict, key, &length);
  if (length != 40 || data == 0)
  {
    *(void *)(a1 + 32) = 0;
    result.n128_u64[0] = 0;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 1std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  }
  else
  {
    __n128 result = *(__n128 *)data;
    long long v7 = data[1];
    *(_OWORD *)a1 = *data;
    *(_OWORD *)(a1 + 1std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = v7;
    *(void *)(a1 + 32) = *((void *)data + 4);
  }
  return result;
}

const void *swix::coder<std::span<AudioClassDescription const,18446744073709551615ul>>::decode(void *a1)
{
  size_t length = 0;
  __n128 result = xpc_dictionary_get_data(a1, "classDescriptions", &length);
  if (result) {
    BOOL v2 = length == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (v2) {
    return 0;
  }
  unint64_t v3 = 12 * (length / 0xC);
  if (v3 != length)
  {
    std::to_string(&v13, v3);
    int v4 = std::string::insert(&v13, 0, "invalid array size (", 0x14uLL);
    long long v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
    v14.__r_.__value_.__r.__UInt32 words[2] = v4->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v14.__r_.__value_.__l.__data_ = v5;
    v4->__r_.__value_.__l.__size_ = 0;
    v4->__r_.__value_.__r.__UInt32 words[2] = 0;
    v4->__r_.__value_.__r.__words[0] = 0;
    AudioComponentDescription v6 = std::string::append(&v14, "/", 1uLL);
    long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v15.__r_.__value_.__r.__UInt32 words[2] = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v15.__r_.__value_.__l.__data_ = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__UInt32 words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v12, length);
    if ((v12.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      long long v8 = &v12;
    }
    else {
      long long v8 = (std::string *)v12.__r_.__value_.__r.__words[0];
    }
    if ((v12.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v12.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v12.__r_.__value_.__l.__size_;
    }
    audit_token_t v10 = std::string::append(&v15, (const std::string::value_type *)v8, size);
    long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    v16.__r_.__value_.__r.__UInt32 words[2] = v10->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v16.__r_.__value_.__l.__data_ = v11;
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__UInt32 words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    swix::decode_message::throw_error(&v16);
  }
  return result;
}

void sub_1901BDA98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (*(char *)(v33 - 25) < 0) {
    operator delete(*(void **)(v33 - 48));
  }
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

xpc_object_t swix::xpcobj_coder<applesauce::xpc::object>::decode(void *a1, xpc_object_t xdict, char *key)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, key);
  *a1 = value;
  if (value) {
    return xpc_retain(value);
  }
  xpc_object_t result = xpc_null_create();
  *a1 = result;
  return result;
}

uint64_t swix::coder<unsigned int>::decode(void *a1, const char *a2)
{
  uint64_t result = xpc_dictionary_get_uint64(a1, a2);
  if (HIDWORD(result))
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = &unk_1EDF950F8;
  }
  return result;
}

void swix::xpcobj_coder<swix::data>::decode(xpc_object_t *a1, xpc_object_t xdict, char *key)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, key);
  if (value)
  {
    xpc_object_t v5 = value;
    xpc_retain(value);
    *a1 = v5;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    *a1 = v5;
    if (!v5) {
      goto LABEL_5;
    }
  }
  if (object_getClass(v5) == (Class)MEMORY[0x1E4F14580])
  {
    xpc_retain(v5);
    goto LABEL_7;
  }
LABEL_5:
  *a1 = xpc_null_create();
LABEL_7:
  xpc_release(v5);
}

void swix::encode_message::~encode_message(xpc_object_t *this)
{
  this[1] = 0;
}

void swix::decode_message::throw_error(const std::string *a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    if ((a1->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      BOOL v2 = a1;
    }
    else {
      BOOL v2 = (const std::string *)a1->__r_.__value_.__r.__words[0];
    }
    int v4 = 136315138;
    xpc_object_t v5 = v2;
    _os_log_error_impl(&dword_18FEC0000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "throwing swix::exception: %s", (uint8_t *)&v4, 0xCu);
  }
  exception = (std::runtime_error *)__cxa_allocate_exception(0x18uLL);
  swix::exception::exception(exception, a1);
}

void sub_1901BDD3C(_Unwind_Exception *exception_object)
{
}

std::runtime_error *swix::exception::exception(std::runtime_error *a1, const std::string *a2)
{
  uint64_t result = std::runtime_error::runtime_error(a1, a2);
  result->__vftable = (std::runtime_error_vtbl *)&unk_1EDF961D8;
  LODWORD(result[1].__vftable) = -307;
  return result;
}

void swix::exception::~exception(std::runtime_error *this)
{
  std::runtime_error::~runtime_error(this);
  JUMPOUT(0x192FC8940);
}

void AudioConverterXPC_Server::~AudioConverterXPC_Server(AudioConverterXPC_Server *this)
{
  swix::ipc_interface::~ipc_interface(this);
  JUMPOUT(0x192FC8940);
}

uint64_t IAAFillCodecInfoFromInternalData(uint64_t result)
{
  switch(*(void *)result)
  {
    case 0xC00CLL:
      *(void *)(result + 40) = 16;
      *(_OWORD *)(result + 8) = xmmword_1901C6690;
      long long v1 = xmmword_1901C66A0;
      goto LABEL_9;
    case 0xC00DLL:
      *(void *)(result + 40) = 16;
      *(_OWORD *)(result + 8) = xmmword_1901C6670;
      long long v1 = xmmword_1901C6680;
      goto LABEL_9;
    case 0xC00ELL:
    case 0xC00FLL:
    case 0xC011:
    case 0xC012:
      goto LABEL_5;
    case 0xC010:
      *(void *)(result + 40) = 16;
      *(_OWORD *)(result + 8) = xmmword_1901C66B0;
      long long v1 = xmmword_1901C66C0;
      goto LABEL_9;
    case 0xC013:
      *(void *)(result + 40) = 16;
      *(_OWORD *)(result + 8) = xmmword_1901C6650;
      long long v1 = xmmword_1901C6660;
LABEL_9:
      *(_OWORD *)(result + 24) = v1;
      break;
    default:
      if (*(void *)result == 1)
      {
        *(void *)(result + 8) = 0;
        *(_OWORD *)(result + 1std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = xmmword_1901C66E0;
        *(_OWORD *)(result + 32) = xmmword_1901C66D0;
      }
      else
      {
LABEL_5:
        *(void *)(result + 8) = 0;
        *(void *)&long long v2 = -1;
        *((void *)&v2 + 1) = -1;
        *(_OWORD *)(result + 1std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = v2;
        *(_OWORD *)(result + 32) = v2;
      }
      break;
  }
  return result;
}

char *IAAMalloc(size_t a1)
{
  long long v2 = (char *)malloc_type_malloc(a1, 0xE8CA8AC7uLL);
  unint64_t v3 = v2;
  if (v2 && &v2[a1 - 1] >= v2)
  {
    unint64_t v4 = (unint64_t)&v2[a1 - 2];
    if (v4 >= (unint64_t)(v2 - 1)) {
      unint64_t v4 = (unint64_t)(v2 - 1);
    }
    bzero((void *)(v4 + 1), (size_t)&v2[a1 + ~v4]);
  }
  return v3;
}

uint64_t AAReadEncodedAudio(uint64_t a1, unsigned char *a2, void *a3)
{
  unint64_t v3 = a3;
  uint64_t v98 = *MEMORY[0x1E4F143B8];
  unint64_t v6 = *a3;
  unint64_t v7 = *(void *)(a1 + 600);
  if (v7 != -1)
  {
    AASetAudioBytePos(a1, ((v7 / 0x3E8 * *(unsigned __int16 *)(a1 + 684)) >> 3) + v7 % 0x3E8 * *(unsigned __int16 *)(a1 + 684) / 0x1F40);
    *(void *)(a1 + 600) = -1;
  }
  unint64_t v8 = *(void *)(a1 + 624);
  unint64_t v9 = *(void *)(a1 + 616);
  if (v8 != v9 - 1 || *(void *)(a1 + 632) != *(void *)(*(void *)(a1 + 608) + 16 * v8 + 8))
  {
    uint64_t v10 = 0;
    if (v6) {
      BOOL v12 = v8 >= v9;
    }
    else {
      BOOL v12 = 1;
    }
    if (v12)
    {
LABEL_11:
      uint64_t result = 0;
      *(void *)(a1 + 672) += v10;
      goto LABEL_113;
    }
    std::string v13 = (char *)(a1 + 688);
    uint64_t v85 = v3;
    uint64_t v91 = (uint64_t *)(a1 + 568);
    uint64_t v92 = a1 + 688;
    while (1)
    {
      int v14 = *(unsigned __int16 *)(a1 + 544);
      switch(v14)
      {
        case 49168:
          unint64_t v15 = 1045;
          break;
        case 49165:
          unint64_t v15 = 3982;
          break;
        case 49164:
          unint64_t v15 = 2000;
          break;
        default:
          uint64_t result = 4294967285;
          goto LABEL_113;
      }
      unint64_t v16 = *(void *)(a1 + 632);
      unint64_t v17 = v16 / v15;
      uint64_t v18 = *(void *)(*(void *)(a1 + 608) + 16 * v8 + 8);
      unint64_t v19 = (v18 - 1) / v15;
      if (v16 / v15 <= v19) {
        break;
      }
      uint64_t v20 = 0;
LABEL_101:
      unint64_t v80 = v9 - 1;
      if (v16 == v18 && v8 < v80)
      {
        *(void *)(a1 + 624) = v8 + 1;
        *(void *)(a1 + 632) = 0;
        unint64_t v81 = *(uint64_t **)(a1 + 640);
        if (v81) {
          uint64_t v82 = *v81;
        }
        else {
          uint64_t v82 = -5;
        }
        OAAFileSetCurrentPos((uint64_t)v81, v82 + 8);
        unint64_t v8 = *(void *)(a1 + 624);
        unint64_t v9 = *(void *)(a1 + 616);
        unint64_t v80 = v9 - 1;
      }
      v10 += v20;
      if ((v8 != v80 || *(void *)(a1 + 632) != *(void *)(*(void *)(a1 + 608) + 16 * v80 + 8)) && v8 < v9)
      {
        a2 += v20;
        v6 -= v20;
        if (v6) {
          continue;
        }
      }
      goto LABEL_11;
    }
    uint64_t v86 = v10;
    uint64_t v20 = 0;
    unint64_t v83 = v6;
    uint64_t v84 = a2;
    id v21 = a2;
    unint64_t v22 = v15;
    unint64_t v96 = (v18 - 1) / v15;
    while (1)
    {
      if (v17 == v19)
      {
        if (*(void *)(*(void *)(a1 + 608) + 16 * *(void *)(a1 + 624) + 8) % v15) {
          unint64_t v22 = *(void *)(*(void *)(a1 + 608) + 16 * *(void *)(a1 + 624) + 8) % v15;
        }
        else {
          unint64_t v22 = v15;
        }
      }
      unint64_t v23 = v16 % v15;
      unint64_t v24 = v22 - v16 % v15 >= v6 ? v6 : v22 - v16 % v15;
      uint64_t v25 = *(void *)(a1 + 696);
      unint64_t v26 = *(void *)(a1 + 704);
      int64_t v27 = v25 - v26;
      unint64_t v28 = v25 - v26 >= v24 ? v24 : v25 - v26;
      if (v28)
      {
        if ((int)(v26 >> 3) >= 1)
        {
          uint64_t v29 = v26 & 0x7FFFFFFF8;
          v26 &= 0xFFFFFFF800000007;
          *(void *)(a1 + 704) = v26;
          uint64_t v30 = v25 - v29;
          *(void *)(a1 + 69std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = v30;
          int64_t v27 = v30 - v26;
        }
        if (v27 >= (int)v28) {
          unint64_t v28 = (int)v28;
        }
        else {
          unint64_t v28 = v27;
        }
        uint64_t v31 = v26 & 7;
        unint64_t v32 = 8 - v31;
        if (v28 >= v32) {
          unint64_t v33 = 8 - v31;
        }
        else {
          unint64_t v33 = v28;
        }
        if (v33)
        {
          uint64_t v34 = &v13[v31];
          unint64_t v35 = v33;
          int v36 = v21;
          do
          {
            char v37 = *v34++;
            *v36++ = v37;
            --v35;
          }
          while (v35);
        }
        if (v28 > v32)
        {
          unint64_t v38 = v28 - v33;
          if ((uint64_t)(v28 - v33) >= 1)
          {
            uint64_t v39 = &v21[v33];
            int v40 = v13;
            do
            {
              char v41 = *v40++;
              *v39++ = v41;
              --v38;
            }
            while (v38);
          }
        }
        *(void *)(a1 + 704) += v28;
        __int16 v42 = &v21[v28];
        v23 += v28;
        unint64_t v43 = v24 - v28;
        if (v24 == v28) {
          goto LABEL_68;
        }
      }
      else
      {
        __int16 v42 = v21;
        unint64_t v43 = v24;
        if (!v24) {
          goto LABEL_68;
        }
      }
      unint64_t v44 = v22 & 7;
      unint64_t v45 = v22 - v23;
      if (v22 - v23 <= v44) {
        break;
      }
      uint64_t v95 = v20;
      unint64_t v46 = v23 & 7;
      unint64_t v93 = v22 & 7;
      if ((v23 & 7) != 0)
      {
        int v47 = *(uint64_t **)(a1 + 640);
        unint64_t v94 = v43;
        unint64_t v48 = v22;
        if (v47) {
          uint64_t v49 = *v47;
        }
        else {
          uint64_t v49 = -5;
        }
        if (OAAFileSetCurrentPos((uint64_t)v47, v49 - v46))
        {
LABEL_112:
          uint64_t result = 4294967293;
          unint64_t v3 = v85;
          uint64_t v10 = v86;
          goto LABEL_113;
        }
        if (OAAFileRead(*(void *)(a1 + 640), (uint64_t)v97, 8, 0))
        {
          BOOL v51 = 0;
          goto LABEL_66;
        }
        IAADecrypt64Bits(v91, v97, v97);
        unint64_t v52 = 8 - v46;
        unint64_t v53 = v94;
        if (v94 < 8 - v46) {
          unint64_t v52 = v94;
        }
        unint64_t v54 = v23 & 7;
        unint64_t v55 = v52;
        CASerializer v56 = v42;
        do
        {
          *v56++ = *((unsigned char *)v97 + v54++);
          --v55;
        }
        while (v55);
        unint64_t v43 = v53 - v52;
        if (!v43 && v52 + v46 <= 7)
        {
          BOOL v51 = OAAFileSetCurrentPos(*(void *)(a1 + 640), v49 + v52) == 0;
LABEL_66:
          std::string v13 = (char *)v92;
          uint64_t v20 = v95;
          unint64_t v19 = v96;
LABEL_67:
          unint64_t v22 = v48;
          if (!v51) {
            goto LABEL_112;
          }
          goto LABEL_68;
        }
        v23 += v52;
        v42 += v52;
        unint64_t v22 = v48;
        unint64_t v45 = v48 - v23;
        std::string v13 = (char *)v92;
        unint64_t v44 = v93;
      }
      if (v43 >= v45) {
        unint64_t v57 = v45;
      }
      else {
        unint64_t v57 = v43;
      }
      unsigned int v58 = v57 & 0xFFFFFFF8;
      uint64_t v20 = v95;
      if ((v57 & 0xFFFFFFF8) != 0)
      {
        unsigned int v89 = v57 & 0xFFFFFFF8;
        unint64_t v94 = v43;
        unint64_t v90 = v22;
        if (OAAFileRead(*(void *)(a1 + 640), (uint64_t)v42, v57 & 0xFFFFFFF8, 0)) {
          goto LABEL_112;
        }
        uint64_t v87 = v57 & 0xFFFFFFF8;
        unint64_t v88 = v57;
        long long v59 = v91;
        if (v57 >= 8uLL)
        {
          unint64_t v60 = (unint64_t)v57 >> 3;
          int v61 = (unsigned int *)v42;
          do
          {
            IAADecrypt64Bits(v59, v61, v61);
            v61 += 2;
            --v60;
          }
          while (v60);
        }
        LODWORD(v57) = v88;
        v42 += v87;
        uint64_t v20 = v95;
        unint64_t v43 = v94 - v87;
        v23 += v87;
        std::string v13 = (char *)v92;
        unint64_t v44 = v93;
        unint64_t v22 = v90;
        unsigned int v58 = v89;
      }
      unint64_t v19 = v96;
      if (v58 < v57)
      {
        unint64_t v62 = v22;
        if (v22 - v23 <= v44)
        {
          int v79 = OAAFileRead(*(void *)(a1 + 640), (uint64_t)v42, v43, 0);
          unint64_t v19 = v96;
          unint64_t v22 = v62;
          if (v79) {
            goto LABEL_112;
          }
        }
        else
        {
          uint64_t v63 = v43;
          if (OAAFileRead(*(void *)(a1 + 640), (uint64_t)v97, 8, 0)) {
            goto LABEL_112;
          }
          IAADecrypt64Bits(v91, v97, v97);
          if (v63 >= 1)
          {
            long long v64 = v97;
            uint64_t v65 = v63;
            do
            {
              char v66 = *(unsigned char *)v64;
              long long v64 = (unsigned int *)((char *)v64 + 1);
              *v42++ = v66;
              --v65;
            }
            while (v65);
          }
          unint64_t v67 = 8 - v63;
          uint64_t v68 = *(void *)(a1 + 696);
          if (*(void *)(a1 + 704) - v68 + 8 < (unint64_t)(8 - v63)) {
            unint64_t v67 = *(void *)(a1 + 704) - v68 + 8;
          }
          uint64_t v69 = *(void *)(a1 + 696) & 7;
          unint64_t v70 = 8 - v69;
          if (v67 < 8 - v69) {
            unint64_t v70 = v67;
          }
          unint64_t v19 = v96;
          unint64_t v22 = v62;
          if (v70)
          {
            BOOL v71 = &v13[v69];
            unint64_t v72 = v70;
            int v73 = (char *)v97 + v63;
            do
            {
              char v74 = *v73++;
              *v71++ = v74;
              --v72;
            }
            while (v72);
          }
          unint64_t v75 = v67 - v70;
          if ((uint64_t)(v67 - v70) >= 1)
          {
            uint64_t v76 = (char *)v97 + v63 + v70;
            unint64_t v77 = v13;
            do
            {
              char v78 = *v76++;
              *v77++ = v78;
              --v75;
            }
            while (v75);
          }
          *(void *)(a1 + 696) += v67;
        }
      }
LABEL_68:
      unint64_t v16 = *(void *)(a1 + 632) + v24;
      *(void *)(a1 + 632) = v16;
      v20 += v24;
      if (v17 < v19)
      {
        v21 += v24;
        ++v17;
        unint64_t v15 = v22;
        v6 -= v24;
        if (v6) {
          continue;
        }
      }
      unint64_t v8 = *(void *)(a1 + 624);
      unint64_t v9 = *(void *)(a1 + 616);
      uint64_t v18 = *(void *)(*(void *)(a1 + 608) + 16 * v8 + 8);
      unint64_t v3 = v85;
      uint64_t v10 = v86;
      unint64_t v6 = v83;
      a2 = v84;
      goto LABEL_101;
    }
    unint64_t v48 = v22;
    int v50 = OAAFileRead(*(void *)(a1 + 640), (uint64_t)v42, v43, 0);
    unint64_t v19 = v96;
    BOOL v51 = v50 == 0;
    goto LABEL_67;
  }
  uint64_t v10 = 0;
  *(_WORD *)(a1 + 664) = 1;
  uint64_t result = 4294967272;
LABEL_113:
  *unint64_t v3 = v10;
  return result;
}

uint64_t IAAFindSection(uint64_t a1, uint64_t a2, void *a3)
{
  OAAFileSetCurrentPos(a1, 8);
  uint64_t v10 = 0;
  IAAReadULong(a1, &v10);
  uint64_t v6 = v10;
  IAAReadULong(a1, &v10);
  if (v6 < 1) {
    return 4294967272;
  }
  while (1)
  {
    uint64_t v10 = 0;
    IAAReadULong(a1, &v10);
    uint64_t v7 = v10;
    uint64_t v10 = 0;
    IAAReadULong(a1, &v10);
    uint64_t v8 = v10;
    IAAReadULong(a1, a3);
    if (v7 == a2) {
      break;
    }
    if (!--v6) {
      return 4294967272;
    }
  }
  OAAFileSetCurrentPos(a1, v8);
  return 0;
}

uint64_t IAAReadULong(uint64_t a1, void *a2)
{
  if (OAAFileRead(a1, (uint64_t)&v4, 4, 0)) {
    return 0;
  }
  *a2 = bswap32(v4);
  return 1;
}

uint64_t IAAReadUShort(uint64_t a1, _WORD *a2)
{
  uint64_t result = OAAFileRead(a1, (uint64_t)&v4, 2, 0);
  if (!result) {
    *a2 = bswap32(v4) >> 16;
  }
  return result;
}

uint64_t OAAFileRead(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t result = 4294967293;
  if (a1 && a2)
  {
    unsigned int v10 = 0;
    (*(void (**)(void, void, void, uint64_t, uint64_t, unsigned int *))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8), 0, *(void *)a1, a3, a2, &v10);
    uint64_t v8 = v10;
    *(void *)a1 += v10;
    if (a4) {
      *a4 = v8;
    }
    if (v8) {
      BOOL v9 = 1;
    }
    else {
      BOOL v9 = a3 == 0;
    }
    if (v9) {
      return 0;
    }
    else {
      return 4294967293;
    }
  }
  return result;
}

uint64_t OAAFileSetCurrentPos(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 4294967291;
  }
  unsigned int v6 = 0;
  if ((*(unsigned int (**)(void, unsigned int *))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), &v6)) {
    BOOL v4 = 0;
  }
  else {
    BOOL v4 = v6 > a2;
  }
  if (!v4) {
    return 4294967291;
  }
  uint64_t result = 0;
  *(void *)a1 = a2;
  return result;
}

uint64_t AAValidateFile(uint64_t a1)
{
  uint64_t v2 = -5;
  if (a1)
  {
    LODWORD(vstd::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
    if (!(*(unsigned int (**)(void, uint64_t *))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), &v6)) {
      uint64_t v2 = v6;
    }
  }
  uint64_t v6 = 0;
  IAAReadULong(a1, &v6);
  uint64_t v3 = v6;
  uint64_t v6 = 0;
  IAAReadULong(a1, &v6);
  if (v6 == 1469084982) {
    unsigned int v4 = 0;
  }
  else {
    unsigned int v4 = -6;
  }
  if (v2 == v3) {
    return v4;
  }
  else {
    return 4294967287;
  }
}

uint64_t AAGetMetaCodec(uint64_t a1, void *a2)
{
  int v4 = IAAFindSection(a1, 6, &v8);
  if (v4)
  {
    unsigned __int16 v5 = v4;
  }
  else
  {
    IAAReadULong(a1, &v8);
    IAAReadULong(a1, &v8);
    IAAReadULong(a1, &v8);
    IAAReadULong(a1, &v8);
    IAAReadULong(a1, &v8);
    IAAReadULong(a1, &v8);
    int v6 = OAAFileRead(a1, (uint64_t)&v9, 2, 0);
    unsigned __int16 v5 = __rev16(v9);
    if (v6) {
      unsigned __int16 v5 = 0;
    }
  }
  *a2 = v5;
  return IAAFillCodecInfoFromInternalData((uint64_t)a2);
}

unint64_t IAADecrypt64Bits(uint64_t *a1, unsigned int *a2, unsigned char *a3)
{
  unint64_t v3 = bswap32(*a2);
  unint64_t v4 = bswap32(a2[1]);
  uint64_t v5 = a1[2];
  uint64_t v6 = a1[3];
  uint64_t v7 = *a1;
  uint64_t v8 = a1[1];
  unsigned int v9 = 10;
  uint64_t v10 = 4055616968;
  do
  {
    unint64_t v11 = v4 - ((v5 + 16 * v3) ^ (v3 + v10) ^ (v6 + (v3 >> 5)));
    unint64_t v4 = v4
       - ((v5 + 16 * v3) ^ (v3 + v10) ^ (v6 + (v3 >> 5)));
    uint64_t v12 = v8 + (v4 >> 5);
    unint64_t result = v3 - ((v7 + 16 * v11) ^ (v11 + v10) ^ v12);
    unint64_t v3 = v3 - ((v7 + 16 * v11) ^ (v11 + v10) ^ v12);
    uint64_t v10 = (v10 + 1640531527);
    --v9;
  }
  while (v9 > 2);
  *a3 = BYTE3(result);
  a3[1] = BYTE2(result);
  a3[2] = BYTE1(result);
  a3[3] = result;
  a3[4] = BYTE3(v11);
  a3[5] = BYTE2(v11);
  a3[6] = BYTE1(v11);
  a3[7] = v11;
  return result;
}

uint64_t AASetAudioBytePos(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 616);
  if (!v2) {
    return 4294967276;
  }
  uint64_t v4 = *(void *)(a1 + 608);
  if (!v4) {
    return 4294967276;
  }
  uint64_t v6 = 0;
  unint64_t v7 = v2 - 1;
  unsigned int v8 = 1;
  unint64_t v9 = a2;
  while (1)
  {
    unint64_t v10 = *(void *)(v4 + 16 * v6 + 8);
    if (v7 == v6 || v9 < v10) {
      break;
    }
    uint64_t v6 = v8;
    BOOL v11 = v2 > v8++;
    v9 -= v10;
    if (!v11) {
      return 4294967275;
    }
  }
  if (v7 == v6) {
    unint64_t v13 = *(void *)(v4 + 16 * v6 + 8);
  }
  else {
    unint64_t v13 = v9;
  }
  if (v9 < v10) {
    unint64_t v13 = v9;
  }
  *(void *)(a1 + 632) = v13;
  if (*(void *)(a1 + 648))
  {
    unint64_t v14 = *(unsigned __int16 *)(a1 + 682);
    unint64_t v15 = v13 % v14;
    v13 -= v13 % v14;
    *(void *)(a1 + 632) = v13;
  }
  else
  {
    unint64_t v15 = 0;
  }
  *(void *)(a1 + 624) = v6;
  OAAFileSetCurrentPos(*(void *)(a1 + 640), v13 + *(void *)(v4 + 16 * v6));
  *(void *)(a1 + 704) = 0;
  *(void *)(a1 + 69std::unique_ptr<AT::RingBuffer::Impl>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  uint64_t result = 0;
  if (*(void *)(a1 + 600) != -1) {
    *(void *)(a1 + 600) = 1000 * (8 * (a2 - v15) % *(unsigned __int16 *)(a1 + 684)) / *(unsigned __int16 *)(a1 + 684)
  }
                          + 1000 * (8 * (a2 - v15) / *(unsigned __int16 *)(a1 + 684));
  return result;
}

void __cxx_global_array_dtor()
{
  for (uint64_t i = 0; i != -6; i -= 3)
  {
    if (SHIBYTE(_ZGRZ38__AUAudioUnit_XPC__doOpen_completion__E23crashHandlerDisableList_[i + 5]) < 0) {
      operator delete((void *)_ZGRZ38__AUAudioUnit_XPC__doOpen_completion__E23crashHandlerDisableList_[i + 3]);
    }
  }
}

uint64_t CAVectorUnit_Examine()
{
  return MEMORY[0x1F41797B8]();
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  MEMORY[0x1F40D70A8]();
  return result;
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
}

void CFArrayApplyFunction(CFArrayRef theArray, CFRange range, CFArrayApplierFunction applier, void *context)
{
}

Boolean CFArrayContainsValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x1F40D7160](theArray, range.location, range.length, value);
}

CFArrayRef CFArrayCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks)
{
  return (CFArrayRef)MEMORY[0x1F40D7170](allocator, values, numValues, callBacks);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x1F40D7190](allocator, capacity, callBacks);
}

CFMutableArrayRef CFArrayCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFArrayRef theArray)
{
  return (CFMutableArrayRef)MEMORY[0x1F40D7198](allocator, capacity, theArray);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x1F40D71B8](theArray);
}

CFIndex CFArrayGetFirstIndexOfValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x1F40D71C8](theArray, range.location, range.length, value);
}

CFTypeID CFArrayGetTypeID(void)
{
  return MEMORY[0x1F40D71D8]();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x1F40D71F0](theArray, idx);
}

void CFArrayRemoveValueAtIndex(CFMutableArrayRef theArray, CFIndex idx)
{
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x1F40D7420]();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x1F40D7430](BOOLean);
}

CFArrayRef CFBundleCopyExecutableArchitectures(CFBundleRef bundle)
{
  return (CFArrayRef)MEMORY[0x1F40D7460](bundle);
}

CFStringRef CFBundleCopyLocalizedString(CFBundleRef bundle, CFStringRef key, CFStringRef value, CFStringRef tableName)
{
  return (CFStringRef)MEMORY[0x1F40D74A8](bundle, key, value, tableName);
}

CFBundleRef CFBundleCreate(CFAllocatorRef allocator, CFURLRef bundleURL)
{
  return (CFBundleRef)MEMORY[0x1F40D7528](allocator, bundleURL);
}

CFBundleRef CFBundleGetBundleWithIdentifier(CFStringRef bundleID)
{
  return (CFBundleRef)MEMORY[0x1F40D7538](bundleID);
}

void *__cdecl CFBundleGetFunctionPointerForName(CFBundleRef bundle, CFStringRef functionName)
{
  return (void *)MEMORY[0x1F40D7558](bundle, functionName);
}

CFStringRef CFBundleGetIdentifier(CFBundleRef bundle)
{
  return (CFStringRef)MEMORY[0x1F40D7568](bundle);
}

CFBundleRef CFBundleGetMainBundle(void)
{
  return (CFBundleRef)MEMORY[0x1F40D7598]();
}

CFTypeRef CFBundleGetValueForInfoDictionaryKey(CFBundleRef bundle, CFStringRef key)
{
  return (CFTypeRef)MEMORY[0x1F40D75D0](bundle, key);
}

Boolean CFBundleLoadExecutableAndReturnError(CFBundleRef bundle, CFErrorRef *error)
{
  return MEMORY[0x1F40D75F8](bundle, error);
}

Boolean CFCalendarComposeAbsoluteTime(CFCalendarRef calendar, CFAbsoluteTime *at, const char *componentDesc, ...)
{
  return MEMORY[0x1F40D7678](calendar, at, componentDesc);
}

CFCalendarRef CFCalendarCopyCurrent(void)
{
  return (CFCalendarRef)MEMORY[0x1F40D7680]();
}

CFCharacterSetRef CFCharacterSetCreateWithCharactersInString(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFCharacterSetRef)MEMORY[0x1F40D7738](alloc, theString);
}

void CFDataAppendBytes(CFMutableDataRef theData, const UInt8 *bytes, CFIndex length)
{
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return (CFDataRef)MEMORY[0x1F40D77E8](allocator, bytes, length);
}

CFDataRef CFDataCreateCopy(CFAllocatorRef allocator, CFDataRef theData)
{
  return (CFDataRef)MEMORY[0x1F40D77F8](allocator, theData);
}

CFMutableDataRef CFDataCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  return (CFMutableDataRef)MEMORY[0x1F40D7808](allocator, capacity);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x1F40D7830](theData);
}

void CFDataGetBytes(CFDataRef theData, CFRange range, UInt8 *buffer)
{
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x1F40D7850](theData);
}

UInt8 *__cdecl CFDataGetMutableBytePtr(CFMutableDataRef theData)
{
  return (UInt8 *)MEMORY[0x1F40D7858](theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return MEMORY[0x1F40D7860]();
}

void CFDataSetLength(CFMutableDataRef theData, CFIndex length)
{
}

CFDateRef CFDateCreate(CFAllocatorRef allocator, CFAbsoluteTime at)
{
  return (CFDateRef)MEMORY[0x1F40D7898](allocator, at);
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

void CFDictionaryApplyFunction(CFDictionaryRef theDict, CFDictionaryApplierFunction applier, void *context)
{
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return MEMORY[0x1F40D7968](theDict, key);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x1F40D7978](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFDictionaryRef CFDictionaryCreateCopy(CFAllocatorRef allocator, CFDictionaryRef theDict)
{
  return (CFDictionaryRef)MEMORY[0x1F40D7990](allocator, theDict);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x1F40D7998](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  return (CFMutableDictionaryRef)MEMORY[0x1F40D79A8](allocator, capacity, theDict);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x1F40D79C0](theDict);
}

void CFDictionaryGetKeysAndValues(CFDictionaryRef theDict, const void **keys, const void **values)
{
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x1F40D7A00]();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x1F40D7A10](theDict, key);
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x1F40D7A68](cf1, cf2);
}

CFStringRef CFErrorCopyDescription(CFErrorRef err)
{
  return (CFStringRef)MEMORY[0x1F40D7A80](err);
}

CFDictionaryRef CFErrorCopyUserInfo(CFErrorRef err)
{
  return (CFDictionaryRef)MEMORY[0x1F40D7A90](err);
}

CFIndex CFErrorGetCode(CFErrorRef err)
{
  return MEMORY[0x1F40D7AA8](err);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x1F40D7B80](cf);
}

CFLocaleRef CFLocaleGetSystem(void)
{
  return (CFLocaleRef)MEMORY[0x1F40D7C38]();
}

void CFNotificationCenterAddObserver(CFNotificationCenterRef center, const void *observer, CFNotificationCallback callBack, CFStringRef name, const void *object, CFNotificationSuspensionBehavior suspensionBehavior)
{
}

CFNotificationCenterRef CFNotificationCenterGetDarwinNotifyCenter(void)
{
  return (CFNotificationCenterRef)MEMORY[0x1F40D7D08]();
}

CFNotificationCenterRef CFNotificationCenterGetLocalCenter(void)
{
  return (CFNotificationCenterRef)MEMORY[0x1F40D7D20]();
}

void CFNotificationCenterPostNotification(CFNotificationCenterRef center, CFNotificationName name, const void *object, CFDictionaryRef userInfo, Boolean deliverImmediately)
{
}

CFTypeID CFNullGetTypeID(void)
{
  return MEMORY[0x1F40D7D68]();
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x1F40D7D80](allocator, theType, valuePtr);
}

CFNumberFormatterRef CFNumberFormatterCreate(CFAllocatorRef allocator, CFLocaleRef locale, CFNumberFormatterStyle style)
{
  return (CFNumberFormatterRef)MEMORY[0x1F40D7D98](allocator, locale, style);
}

CFStringRef CFNumberFormatterCreateStringWithNumber(CFAllocatorRef allocator, CFNumberFormatterRef formatter, CFNumberRef number)
{
  return (CFStringRef)MEMORY[0x1F40D7DA8](allocator, formatter, number);
}

CFStringRef CFNumberFormatterCreateStringWithValue(CFAllocatorRef allocator, CFNumberFormatterRef formatter, CFNumberType numberType, const void *valuePtr)
{
  return (CFStringRef)MEMORY[0x1F40D7DB0](allocator, formatter, numberType, valuePtr);
}

CFNumberType CFNumberGetType(CFNumberRef number)
{
  return MEMORY[0x1F40D7E08](number);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x1F40D7E10]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x1F40D7E20](number, theType, valuePtr);
}

Boolean CFPreferencesAppSynchronize(CFStringRef applicationID)
{
  return MEMORY[0x1F40D7E90](applicationID);
}

CFPropertyListRef CFPreferencesCopyAppValue(CFStringRef key, CFStringRef applicationID)
{
  return (CFPropertyListRef)MEMORY[0x1F40D7EA0](key, applicationID);
}

CFArrayRef CFPreferencesCopyKeyList(CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return (CFArrayRef)MEMORY[0x1F40D7EB8](applicationID, userName, hostName);
}

void CFPreferencesSetAppValue(CFStringRef key, CFPropertyListRef value, CFStringRef applicationID)
{
}

Boolean CFPreferencesSynchronize(CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return MEMORY[0x1F40D7F10](applicationID, userName, hostName);
}

CFDataRef CFPropertyListCreateData(CFAllocatorRef allocator, CFPropertyListRef propertyList, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  return (CFDataRef)MEMORY[0x1F40D7F18](allocator, propertyList, format, options, error);
}

CFPropertyListRef CFPropertyListCreateFromXMLData(CFAllocatorRef allocator, CFDataRef xmlData, CFOptionFlags mutabilityOption, CFStringRef *errorString)
{
  return (CFPropertyListRef)MEMORY[0x1F40D7F40](allocator, xmlData, mutabilityOption, errorString);
}

CFPropertyListRef CFPropertyListCreateWithData(CFAllocatorRef allocator, CFDataRef data, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return (CFPropertyListRef)MEMORY[0x1F40D7F50](allocator, data, options, format, error);
}

CFPropertyListRef CFPropertyListCreateWithStream(CFAllocatorRef allocator, CFReadStreamRef stream, CFIndex streamLength, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return (CFPropertyListRef)MEMORY[0x1F40D7F58](allocator, stream, streamLength, options, format, error);
}

CFDataRef CFPropertyListCreateXMLData(CFAllocatorRef allocator, CFPropertyListRef propertyList)
{
  return (CFDataRef)MEMORY[0x1F40D7F60](allocator, propertyList);
}

void CFReadStreamClose(CFReadStreamRef stream)
{
}

CFReadStreamRef CFReadStreamCreateWithFile(CFAllocatorRef alloc, CFURLRef fileURL)
{
  return (CFReadStreamRef)MEMORY[0x1F40D7FC0](alloc, fileURL);
}

Boolean CFReadStreamOpen(CFReadStreamRef stream)
{
  return MEMORY[0x1F40D7FF8](stream);
}

void CFRelease(CFTypeRef cf)
{
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x1F40D8048](cf);
}

void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
}

CFRunLoopRef CFRunLoopGetCurrent(void)
{
  return (CFRunLoopRef)MEMORY[0x1F40D80B0]();
}

CFRunLoopRef CFRunLoopGetMain(void)
{
  return (CFRunLoopRef)MEMORY[0x1F40D80B8]();
}

void CFRunLoopPerformBlock(CFRunLoopRef rl, CFTypeRef mode, void *block)
{
}

void CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
}

CFRunLoopRunResult CFRunLoopRunInMode(CFRunLoopMode mode, CFTimeInterval seconds, Boolean returnAfterSourceHandled)
{
  return MEMORY[0x1F40D8128](mode, returnAfterSourceHandled, seconds);
}

CFRunLoopSourceRef CFRunLoopSourceCreate(CFAllocatorRef allocator, CFIndex order, CFRunLoopSourceContext *context)
{
  return (CFRunLoopSourceRef)MEMORY[0x1F40D8140](allocator, order, context);
}

void CFRunLoopSourceSignal(CFRunLoopSourceRef source)
{
}

void CFRunLoopWakeUp(CFRunLoopRef rl)
{
}

void CFSetAddValue(CFMutableSetRef theSet, const void *value)
{
}

void CFSetApplyFunction(CFSetRef theSet, CFSetApplierFunction applier, void *context)
{
}

CFMutableSetRef CFSetCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFSetCallBacks *callBacks)
{
  return (CFMutableSetRef)MEMORY[0x1F40D8210](allocator, capacity, callBacks);
}

CFIndex CFSetGetCount(CFSetRef theSet)
{
  return MEMORY[0x1F40D8220](theSet);
}

void CFStringAppend(CFMutableStringRef theString, CFStringRef appendedString)
{
}

void CFStringAppendCString(CFMutableStringRef theString, const char *cStr, CFStringEncoding encoding)
{
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1F40D8388](theString1, theString2, compareOptions);
}

CFComparisonResult CFStringCompareWithOptions(CFStringRef theString1, CFStringRef theString2, CFRange rangeToCompare, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1F40D8390](theString1, theString2, rangeToCompare.location, rangeToCompare.length, compareOptions);
}

CFArrayRef CFStringCreateArrayBySeparatingStrings(CFAllocatorRef alloc, CFStringRef theString, CFStringRef separatorString)
{
  return (CFArrayRef)MEMORY[0x1F40D83D0](alloc, theString, separatorString);
}

CFStringRef CFStringCreateCopy(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFStringRef)MEMORY[0x1F40D83F0](alloc, theString);
}

CFStringRef CFStringCreateFromExternalRepresentation(CFAllocatorRef alloc, CFDataRef data, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1F40D8400](alloc, data, *(void *)&encoding);
}

CFMutableStringRef CFStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  return (CFMutableStringRef)MEMORY[0x1F40D8408](alloc, maxLength);
}

CFMutableStringRef CFStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFStringRef theString)
{
  return (CFMutableStringRef)MEMORY[0x1F40D8410](alloc, maxLength, theString);
}

CFStringRef CFStringCreateWithBytes(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation)
{
  return (CFStringRef)MEMORY[0x1F40D8438](alloc, bytes, numBytes, *(void *)&encoding, isExternalRepresentation);
}

CFStringRef CFStringCreateWithBytesNoCopy(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation, CFAllocatorRef contentsDeallocator)
{
  return (CFStringRef)MEMORY[0x1F40D8440](alloc, bytes, numBytes, *(void *)&encoding, isExternalRepresentation, contentsDeallocator);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1F40D8448](alloc, cStr, *(void *)&encoding);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return (CFStringRef)MEMORY[0x1F40D8490](alloc, formatOptions, format);
}

CFStringRef CFStringCreateWithPascalString(CFAllocatorRef alloc, ConstStr255Param pStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1F40D84A0](alloc, pStr, *(void *)&encoding);
}

CFStringRef CFStringCreateWithSubstring(CFAllocatorRef alloc, CFStringRef str, CFRange range)
{
  return (CFStringRef)MEMORY[0x1F40D84A8](alloc, str, range.location, range.length);
}

void CFStringDelete(CFMutableStringRef theString, CFRange range)
{
}

CFRange CFStringFind(CFStringRef theString, CFStringRef stringToFind, CFStringCompareFlags compareOptions)
{
  CFIndex v3 = MEMORY[0x1F40D84C8](theString, stringToFind, compareOptions);
  result.size_t length = v4;
  result.location = v3;
  return result;
}

Boolean CFStringFindCharacterFromSet(CFStringRef theString, CFCharacterSetRef theSet, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result)
{
  return MEMORY[0x1F40D84D8](theString, theSet, rangeToSearch.location, rangeToSearch.length, searchOptions, result);
}

CFIndex CFStringGetBytes(CFStringRef theString, CFRange range, CFStringEncoding encoding, UInt8 lossByte, Boolean isExternalRepresentation, UInt8 *buffer, CFIndex maxBufLen, CFIndex *usedBufLen)
{
  return MEMORY[0x1F40D8500](theString, range.location, range.length, *(void *)&encoding, lossByte, isExternalRepresentation, buffer, maxBufLen);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x1F40D8510](theString, buffer, bufferSize, *(void *)&encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x1F40D8520](theString, *(void *)&encoding);
}

void CFStringGetCharacters(CFStringRef theString, CFRange range, UniChar *buffer)
{
}

double CFStringGetDoubleValue(CFStringRef str)
{
  MEMORY[0x1F40D8548](str);
  return result;
}

SInt32 CFStringGetIntValue(CFStringRef str)
{
  return MEMORY[0x1F40D8568](str);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x1F40D8578](theString);
}

CFIndex CFStringGetMaximumSizeForEncoding(CFIndex length, CFStringEncoding encoding)
{
  return MEMORY[0x1F40D8590](length, *(void *)&encoding);
}

Boolean CFStringGetPascalString(CFStringRef theString, StringPtr buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x1F40D85C0](theString, buffer, bufferSize, *(void *)&encoding);
}

CFStringEncoding CFStringGetSystemEncoding(void)
{
  return MEMORY[0x1F40D85E0]();
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x1F40D85F0]();
}

Boolean CFStringHasPrefix(CFStringRef theString, CFStringRef prefix)
{
  return MEMORY[0x1F40D8600](theString, prefix);
}

void CFStringInsert(CFMutableStringRef str, CFIndex idx, CFStringRef insertedStr)
{
}

void CFStringTrimWhitespace(CFMutableStringRef theString)
{
}

void CFStringUppercase(CFMutableStringRef theString, CFLocaleRef locale)
{
}

CFURLRef CFURLCopyAbsoluteURL(CFURLRef relativeURL)
{
  return (CFURLRef)MEMORY[0x1F40D8740](relativeURL);
}

CFStringRef CFURLCopyFileSystemPath(CFURLRef anURL, CFURLPathStyle pathStyle)
{
  return (CFStringRef)MEMORY[0x1F40D8758](anURL, pathStyle);
}

CFStringRef CFURLCopyPathExtension(CFURLRef url)
{
  return (CFStringRef)MEMORY[0x1F40D8798](url);
}

CFStringRef CFURLCopyResourceSpecifier(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1F40D87B8](anURL);
}

CFStringRef CFURLCopyScheme(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1F40D87C0](anURL);
}

CFURLRef CFURLCreateFromFileSystemRepresentation(CFAllocatorRef allocator, const UInt8 *buffer, CFIndex bufLen, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1F40D8848](allocator, buffer, bufLen, isDirectory);
}

CFURLRef CFURLCreateWithBytes(CFAllocatorRef allocator, const UInt8 *URLBytes, CFIndex length, CFStringEncoding encoding, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x1F40D8888](allocator, URLBytes, length, *(void *)&encoding, baseURL);
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1F40D88A0](allocator, filePath, pathStyle, isDirectory);
}

CFURLRef CFURLCreateWithFileSystemPathRelativeToBase(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x1F40D88A8](allocator, filePath, pathStyle, isDirectory, baseURL);
}

CFURLRef CFURLCreateWithString(CFAllocatorRef allocator, CFStringRef URLString, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x1F40D88C0](allocator, URLString, baseURL);
}

CFURLRef CFURLGetBaseURL(CFURLRef anURL)
{
  return (CFURLRef)MEMORY[0x1F40D88F0](anURL);
}

CFIndex CFURLGetBytes(CFURLRef url, UInt8 *buffer, CFIndex bufferLength)
{
  return MEMORY[0x1F40D8900](url, buffer, bufferLength);
}

Boolean CFURLGetFileSystemRepresentation(CFURLRef url, Boolean resolveAgainstBase, UInt8 *buffer, CFIndex maxBufLen)
{
  return MEMORY[0x1F40D8908](url, resolveAgainstBase, buffer, maxBufLen);
}

CFStringRef CFURLGetString(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1F40D8918](anURL);
}

CFTypeID CFURLGetTypeID(void)
{
  return MEMORY[0x1F40D8928]();
}

CFUUIDRef CFUUIDCreate(CFAllocatorRef alloc)
{
  return (CFUUIDRef)MEMORY[0x1F40D8988](alloc);
}

CFUUIDRef CFUUIDCreateFromString(CFAllocatorRef alloc, CFStringRef uuidStr)
{
  return (CFUUIDRef)MEMORY[0x1F40D8998](alloc, uuidStr);
}

CFUUIDRef CFUUIDCreateFromUUIDBytes(CFAllocatorRef alloc, CFUUIDBytes bytes)
{
  return (CFUUIDRef)MEMORY[0x1F40D89A0](alloc, *(void *)&bytes.byte0, *(void *)&bytes.byte8);
}

CFStringRef CFUUIDCreateString(CFAllocatorRef alloc, CFUUIDRef uuid)
{
  return (CFStringRef)MEMORY[0x1F40D89B0](alloc, uuid);
}

CFUUIDBytes CFUUIDGetUUIDBytes(CFUUIDRef uuid)
{
  uint64_t v1 = MEMORY[0x1F40D89E8](uuid);
  result.byte8 = v2;
  result.byte9 = BYTE1(v2);
  result.byte10 = BYTE2(v2);
  result.byte11 = BYTE3(v2);
  result.byte12 = BYTE4(v2);
  result.byte13 = BYTE5(v2);
  result.byte14 = BYTE6(v2);
  result.byte15 = HIBYTE(v2);
  result.byte0 = v1;
  result.byte1 = BYTE1(v1);
  result.byte2 = BYTE2(v1);
  result.byte3 = BYTE3(v1);
  result.byte4 = BYTE4(v1);
  result.byte5 = BYTE5(v1);
  result.byte6 = BYTE6(v1);
  result.byte7 = HIBYTE(v1);
  return result;
}

uint64_t CrashIfClientProvidedBogusAudioBufferList()
{
  return MEMORY[0x1F41797C0]();
}

FSEventStreamRef FSEventStreamCreate(CFAllocatorRef allocator, FSEventStreamCallback callback, FSEventStreamContext *context, CFArrayRef pathsToWatch, FSEventStreamEventId sinceWhen, CFTimeInterval latency, FSEventStreamCreateFlags flags)
{
  return (FSEventStreamRef)MEMORY[0x1F40DEDC0](allocator, callback, context, pathsToWatch, sinceWhen, *(void *)&flags, latency);
}

void FSEventStreamInvalidate(FSEventStreamRef streamRef)
{
}

void FSEventStreamSetDispatchQueue(FSEventStreamRef streamRef, dispatch_queue_t q)
{
}

Boolean FSEventStreamStart(FSEventStreamRef streamRef)
{
  return MEMORY[0x1F40DEDF8](streamRef);
}

IOSurfaceRef IOSurfaceCreate(CFDictionaryRef properties)
{
  return (IOSurfaceRef)MEMORY[0x1F40E9308](properties);
}

xpc_object_t IOSurfaceCreateXPCObject(IOSurfaceRef aSurface)
{
  return (xpc_object_t)MEMORY[0x1F40E9328](aSurface);
}

size_t IOSurfaceGetAllocSize(IOSurfaceRef buffer)
{
  return MEMORY[0x1F40E9350](buffer);
}

void *__cdecl IOSurfaceGetBaseAddress(IOSurfaceRef buffer)
{
  return (void *)MEMORY[0x1F40E9358](buffer);
}

IOSurfaceRef IOSurfaceLookupFromXPCObject(xpc_object_t xobj)
{
  return (IOSurfaceRef)MEMORY[0x1F40E9560](xobj);
}

uint64_t IOSurfaceSetOwnershipIdentity()
{
  return MEMORY[0x1F40E95D0]();
}

void IOSurfaceSetValue(IOSurfaceRef buffer, CFStringRef key, CFTypeRef value)
{
}

MIDIEventPacket *__cdecl MIDIEventListAdd(MIDIEventList *evtlist, ByteCount listSize, MIDIEventPacket *curPacket, MIDITimeStamp time, ByteCount wordCount, const UInt32 *words)
{
  return (MIDIEventPacket *)MEMORY[0x1F40DB618](evtlist, listSize, curPacket, time, wordCount, words);
}

MIDIEventPacket *__cdecl MIDIEventListInit(MIDIEventList *evtlist, MIDIProtocolID protocol)
{
  return (MIDIEventPacket *)MEMORY[0x1F40DB620](evtlist, *(void *)&protocol);
}

Class NSClassFromString(NSString *aClassName)
{
  return (Class)MEMORY[0x1F40E7010](aClassName);
}

void NSLog(NSString *format, ...)
{
}

NSArray *__cdecl NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory directory, NSSearchPathDomainMask domainMask, BOOL expandTilde)
{
  return (NSArray *)MEMORY[0x1F40E7248](directory, domainMask, expandTilde);
}

void *__cdecl OSAtomicDequeue(OSQueueHead *__list, size_t a2)
{
  return (void *)MEMORY[0x1F40C99E8](__list, a2);
}

void OSAtomicEnqueue(OSQueueHead *__list, void *__new, size_t a3)
{
}

uint64_t SBApplicationStateBeginGeneratingChangeNotifications()
{
  return MEMORY[0x1F415C008]();
}

uint64_t SBSProcessAssertionCreateForPID()
{
  return MEMORY[0x1F415C3C0]();
}

uint64_t SBSProcessAssertionSetFlags()
{
  return MEMORY[0x1F415C3D0]();
}

uint64_t SBSProcessAssertionSetInvalidationCallBack()
{
  return MEMORY[0x1F415C3D8]();
}

CFTypeRef SecTaskCopyValueForEntitlement(SecTaskRef task, CFStringRef entitlement, CFErrorRef *error)
{
  return (CFTypeRef)MEMORY[0x1F40F7138](task, entitlement, error);
}

SecTaskRef SecTaskCreateFromSelf(CFAllocatorRef allocator)
{
  return (SecTaskRef)MEMORY[0x1F40F7160](allocator);
}

SecTaskRef SecTaskCreateWithAuditToken(CFAllocatorRef allocator, audit_token_t *token)
{
  return (SecTaskRef)MEMORY[0x1F40F7168](allocator, token);
}

uint64_t WriteStackshotReportWithPID()
{
  return MEMORY[0x1F4116EC0]();
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return (void *)MEMORY[0x1F40C9A70](aBlock);
}

void _Block_object_assign(void *a1, const void *a2, const int a3)
{
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

void _Block_release(const void *aBlock)
{
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

uint64_t NextMIDIEvent(const unsigned __int8 *a1, const unsigned __int8 *a2)
{
  return MEMORY[0x1F41797D8](a1, a2);
}

uint64_t MinimalSafetyCheck(const AudioStreamBasicDescription *a1)
{
  return MEMORY[0x1F41797E8](a1);
}

uint64_t CACFPreferencesCopyAppValue(const __CFString *a1, const __CFString *a2)
{
  return MEMORY[0x1F41797F8](a1, a2);
}

uint64_t CACFPreferencesGetAppFloatValue(const __CFString *a1, const __CFString *a2, BOOL *a3)
{
  return MEMORY[0x1F4179800](a1, a2, a3);
}

uint64_t CACFPreferencesGetAppBooleanValue(const __CFString *a1, const __CFString *a2, BOOL *a3)
{
  return MEMORY[0x1F4179808](a1, a2, a3);
}

uint64_t CACFPreferencesGetAppIntegerValue(const __CFString *a1, const __CFString *a2, BOOL *a3)
{
  return MEMORY[0x1F4179810](a1, a2, a3);
}

uint64_t Read(CADeserializer *a1, AudioChannelLayout **a2, unint64_t *a3)
{
  return MEMORY[0x1F4179818](a1, a2, a3);
}

uint64_t CACFString::GetCString(CACFString *this, const __CFString *a2, char *a3, unsigned int *a4)
{
  return MEMORY[0x1F4179820](this, a2, a3, a4);
}

uint64_t CACFString::GetStringByteLength(CACFString *this, const __CFString *a2)
{
  return MEMORY[0x1F4179828](this, a2);
}

uint64_t RamstadSRC::processMono(RamstadSRC *this, const float *a2, float *a3)
{
  return MEMORY[0x1F4179868](this, a2, a3);
}

uint64_t RamstadSRC::processMulti(RamstadSRC *this, const float *const *a2, float *const *a3)
{
  return MEMORY[0x1F4179870](this, a2, a3);
}

uint64_t RamstadSRC::processStereo(RamstadSRC *this, const float *a2, const float *a3, float *a4, float *a5, int a6, int a7, int a8, int a9)
{
  return MEMORY[0x1F4179878](this, a2, a3, a4, a5);
}

uint64_t RamstadSRC::reset(RamstadSRC *this)
{
  return MEMORY[0x1F4179880](this);
}

uint64_t RamstadSRC::setRate(RamstadSRC *this, double a2)
{
  return MEMORY[0x1F4179888](this, a2);
}

void RamstadSRC::RamstadSRC(RamstadSRC *this, double a2, double a3)
{
}

void RamstadSRC::RamstadSRC(RamstadSRC *this, double a2, double a3, double a4)
{
}

void RamstadSRC::~RamstadSRC(RamstadSRC *this)
{
}

void SincKernel::SincKernel(SincKernel *this, double a2, double a3)
{
}

void SincKernel::~SincKernel(SincKernel *this)
{
}

void XPC_Object::~XPC_Object(XPC_Object *this)
{
}

uint64_t CADeprecated::XMachServer::XMachServer()
{
  return MEMORY[0x1F41798D0]();
}

uint64_t CADeprecated::CABufferList::AllocateBuffers(CADeprecated::CABufferList *this)
{
  return MEMORY[0x1F41798D8](this);
}

uint64_t CADeprecated::XBasicMIGServer::SetServerDispatchQueue()
{
  return MEMORY[0x1F41798E0]();
}

uint64_t CADeprecated::XMachReceivePort::CreateMachPort(CADeprecated::XMachReceivePort *this)
{
  return MEMORY[0x1F41798F0](this);
}

void CADeprecated::XMachReceivePort::~XMachReceivePort(CADeprecated::XMachReceivePort *this)
{
}

uint64_t CADeprecated::XRemoteMachServer::SetServerPort(CADeprecated::XRemoteMachServer *this)
{
  return MEMORY[0x1F4179910](this);
}

uint64_t CADeprecated::XRemoteMachServer::XRemoteMachServer(CADeprecated::XRemoteMachServer *this, const char *a2, const char *a3)
{
  return MEMORY[0x1F4179918](this, a2, a3);
}

void CADeprecated::XRemoteMachServer::~XRemoteMachServer(CADeprecated::XRemoteMachServer *this)
{
}

void CADeprecated::XMachPortSendRight::~XMachPortSendRight(CADeprecated::XMachPortSendRight *this)
{
}

uint64_t CADeprecated::XMachPortDeathListener::SetDeathNotificationDispatchQueue()
{
  return MEMORY[0x1F4179938]();
}

void CADeprecated::XMachPortDeathListener::~XMachPortDeathListener(CADeprecated::XMachPortDeathListener *this)
{
}

uint64_t CADeprecated::CAGuard::Notify(CADeprecated::CAGuard *this)
{
  return MEMORY[0x1F4179958](this);
}

uint64_t CADeprecated::CAGuard::CAGuard(CADeprecated::CAGuard *this, const char *a2)
{
  return MEMORY[0x1F4179968](this, a2);
}

void CADeprecated::CAGuard::~CAGuard(CADeprecated::CAGuard *this)
{
}

uint64_t CADeprecated::CAMutex::CAMutex(CADeprecated::CAMutex *this, const char *a2)
{
  return MEMORY[0x1F41799A0](this, a2);
}

void CADeprecated::CAMutex::~CAMutex(CADeprecated::CAMutex *this)
{
}

uint64_t CADeprecated::CAPThread::GetScheduledPriority(CADeprecated::CAPThread *this, _opaque_pthread_t *a2)
{
  return MEMORY[0x1F41799D0](this, a2);
}

uint64_t CASerializer::WritePlist(CASerializer *this, const void *a2)
{
  return MEMORY[0x1F4179A00](this, a2);
}

uint64_t CASerializer::Write(CASerializer *this, const void *a2)
{
  return MEMORY[0x1F4179A08](this, a2);
}

void CASerializer::CASerializer(CASerializer *this, __CFData *a2)
{
}

void CASerializer::~CASerializer(CASerializer *this)
{
}

uint64_t XOSTransactor::endTransaction(XOSTransactor *this)
{
  return MEMORY[0x1F4179A48](this);
}

uint64_t XOSTransactor::beginTransaction(XOSTransactor *this)
{
  return MEMORY[0x1F4179A50](this);
}

void CABundleLocker::CABundleLocker(CABundleLocker *this)
{
}

void CABundleLocker::~CABundleLocker(CABundleLocker *this)
{
}

uint64_t CACFDictionary::AddCString(CACFDictionary *this, const __CFString *a2, const char *a3)
{
  return MEMORY[0x1F4179A68](this, a2, a3);
}

uint64_t CACFDictionary::AddFloat32(CACFDictionary *this, const __CFString *a2, float a3)
{
  return MEMORY[0x1F4179A70](this, a2, a3);
}

uint64_t CACFDictionary::AddDictionary(CACFDictionary *this, const __CFString *a2, const __CFDictionary *a3)
{
  return MEMORY[0x1F4179A78](this, a2, a3);
}

uint64_t CACFDictionary::AddURL(CACFDictionary *this, const __CFString *a2, const __CFURL *a3)
{
  return MEMORY[0x1F4179A80](this, a2, a3);
}

uint64_t CACFDictionary::AddData(CACFDictionary *this, const __CFString *a2, const __CFData *a3)
{
  return MEMORY[0x1F4179A90](this, a2, a3);
}

uint64_t CACFDictionary::AddArray(CACFDictionary *this, const __CFString *a2, const __CFArray *a3)
{
  return MEMORY[0x1F4179A98](this, a2, a3);
}

uint64_t CACFDictionary::AddCFType(CACFDictionary *this, const __CFString *a2, const void *a3)
{
  return MEMORY[0x1F4179AA0](this, a2, a3);
}

uint64_t CACFDictionary::AddString(CACFDictionary *this, const __CFString *a2, const __CFString *a3)
{
  return MEMORY[0x1F4179AB0](this, a2, a3);
}

uint64_t CACFDictionary::AddUInt32(CACFDictionary *this, const __CFString *a2)
{
  return MEMORY[0x1F4179AB8](this, a2);
}

uint64_t CADeserializer::GetAndAdvanceReadPtr(CADeserializer *this)
{
  return MEMORY[0x1F4179AC8](this);
}

uint64_t CADeserializer::Read(CADeserializer *this, void *a2)
{
  return MEMORY[0x1F4179AD0](this, a2);
}

uint64_t CADeserializer::ReadPlist(CADeserializer *this)
{
  return MEMORY[0x1F4179AD8](this);
}

void CADeserializer::CADeserializer(CADeserializer *this, const __CFData *a2)
{
}

void CADeserializer::CADeserializer(CADeserializer *this, const void *a2)
{
}

void CADeserializer::~CADeserializer(CADeserializer *this)
{
}

uint64_t XPC_Connection::Initialize(XPC_Connection *this)
{
  return MEMORY[0x1F4179B08](this);
}

void XPC_Dictionary::~XPC_Dictionary(XPC_Dictionary *this)
{
}

uint64_t BaseOpaqueObject::ResolveOpaqueRef()
{
  return MEMORY[0x1F4179B30]();
}

uint64_t BaseOpaqueObject::destroyOpaqueRef(BaseOpaqueObject *this)
{
  return MEMORY[0x1F4179B38](this);
}

uint64_t BaseOpaqueObject::checkRTTI()
{
  return MEMORY[0x1F4179B40]();
}

void BaseOpaqueObject::BaseOpaqueObject(BaseOpaqueObject *this)
{
}

void BaseOpaqueObject::~BaseOpaqueObject(BaseOpaqueObject *this)
{
}

uint64_t MultiRadixRealFFT::Initialize(MultiRadixRealFFT *this)
{
  return MEMORY[0x1F4179B58](this);
}

uint64_t PlatformUtilities::processName(PlatformUtilities *this)
{
  return MEMORY[0x1F4179B60](this);
}

uint64_t PlatformUtilities::IsInternalBuild(PlatformUtilities *this)
{
  return MEMORY[0x1F4179B68](this);
}

uint64_t SincKernelFactory::ReleaseSincKernel(SincKernelFactory *this, SincKernel *a2)
{
  return MEMORY[0x1F4179B78](this, a2);
}

uint64_t SincKernelFactory::ReferenceSincKernel(SincKernelFactory *this, double a2, double a3)
{
  return MEMORY[0x1F4179B80](this, a2, a3);
}

uint64_t CASmartPreferences::_RegisterFirstHandler()
{
  return MEMORY[0x1F4179B88]();
}

uint64_t CASmartPreferences::instance(CASmartPreferences *this)
{
  return MEMORY[0x1F4179B90](this);
}

uint64_t PropertyMarshaller::Deserialize()
{
  return MEMORY[0x1F4179B98]();
}

uint64_t PropertyMarshaller::Serialize()
{
  return MEMORY[0x1F4179BA0]();
}

uint64_t SharableMemoryBlock::InitClient()
{
  return MEMORY[0x1F4179BB0]();
}

uint64_t SharableMemoryBlock::InitServer()
{
  return MEMORY[0x1F4179BB8]();
}

uint64_t SharableMemoryBlock::FDClientToken::Reset(SharableMemoryBlock::FDClientToken *this)
{
  return MEMORY[0x1F4179BC0](this);
}

void SharableMemoryBlock::XPCClientToken::~XPCClientToken(SharableMemoryBlock::XPCClientToken *this)
{
}

uint64_t SharableMemoryBlock::MachClientToken::Reset(SharableMemoryBlock::MachClientToken *this)
{
  return MEMORY[0x1F4179BD8](this);
}

uint64_t SharableMemoryBlock::Free(SharableMemoryBlock *this)
{
  return MEMORY[0x1F4179BE0](this);
}

uint64_t CAAudioChannelLayout::SetWithTag(CAAudioChannelLayout *this)
{
  return MEMORY[0x1F4179BE8](this);
}

uint64_t CAAudioChannelLayout::NumberChannels(CAAudioChannelLayout *this, const AudioChannelLayout *a2)
{
  return MEMORY[0x1F4179BF0](this, a2);
}

uint64_t CAAudioChannelLayout::SetAllToUnknown(CAAudioChannelLayout *this, AudioChannelLayout *a2)
{
  return MEMORY[0x1F4179BF8](this, a2);
}

uint64_t CAAudioChannelLayout::Set(CAAudioChannelLayout *this, const AudioChannelLayout *a2)
{
  return MEMORY[0x1F4179C00](this, a2);
}

uint64_t CAAudioChannelLayout::Create(CAAudioChannelLayout *this)
{
  return MEMORY[0x1F4179C08](this);
}

uint64_t CAAudioChannelLayout::Destroy(CAAudioChannelLayout *this, AudioChannelLayout *a2)
{
  return MEMORY[0x1F4179C10](this, a2);
}

void CAAudioChannelLayout::CAAudioChannelLayout(CAAudioChannelLayout *this, const AudioChannelLayout *a2)
{
}

void CAAudioChannelLayout::CAAudioChannelLayout(CAAudioChannelLayout *this)
{
}

void CAAudioChannelLayout::~CAAudioChannelLayout(CAAudioChannelLayout *this)
{
}

uint64_t CAAudioChannelLayout::operator=()
{
  return MEMORY[0x1F4179C30]();
}

{
  return MEMORY[0x1F4179C38]();
}

uint64_t CAFileSystemUtilities::GetTemporarySubDirectory()
{
  return MEMORY[0x1F4179C40]();
}

uint64_t PlatformUtilities_iOS::IsInternalBuild(PlatformUtilities_iOS *this)
{
  return MEMORY[0x1F4179C58](this);
}

uint64_t PlatformUtilities_iOS::ProductIsAppleTV(PlatformUtilities_iOS *this)
{
  return MEMORY[0x1F4179C68](this);
}

uint64_t PlatformUtilities_iOS::_eaJyFmO(PlatformUtilities_iOS *this)
{
  return MEMORY[0x1F4179CA0](this);
}

uint64_t CAStreamBasicDescription::FromText(CAStreamBasicDescription *this, const char *a2, AudioStreamBasicDescription *a3)
{
  return MEMORY[0x1F4179CA8](this, a2, a3);
}

uint64_t MIDI::LegacyPacketList::create()
{
  return MEMORY[0x1F40DB690]();
}

uint64_t MIDI::LegacyPacketListDeleter::operator()()
{
  return MEMORY[0x1F40DB698]();
}

uint64_t swix::connection::xpc_connection(swix::connection *this)
{
  return MEMORY[0x1F4179CB0](this);
}

uint64_t swix::connection::send_and_await_reply(swix::connection *this, const swix::encode_message *a2)
{
  return MEMORY[0x1F4179CB8](this, a2);
}

uint64_t swix::connection::state::cancel_connection()
{
  return MEMORY[0x1F4179CC8]();
}

void swix::connection::~connection(swix::connection *this)
{
}

{
  MEMORY[0x1F4179CD8](this);
}

uint64_t swix::ipc_interface::ipc_interface()
{
  return MEMORY[0x1F4179CE0]();
}

void swix::ipc_interface::~ipc_interface(swix::ipc_interface *this)
{
}

uint64_t swix::encode_message::encode_message()
{
  return MEMORY[0x1F4179CF0]();
}

uint64_t swix::encode_message::encode_message(swix::encode_message *this)
{
  return MEMORY[0x1F4179CF8](this);
}

uint64_t swix::xpc_object_description(swix *this, void *a2)
{
  return MEMORY[0x1F4179D00](this, a2);
}

uint64_t swix::listener::listener(swix::listener *this, const swix::connection_config *a2)
{
  return MEMORY[0x1F4179D08](this, a2);
}

uint64_t CALog::Scope::SetPriorityThresholdFromPreference(CALog::Scope *this, const __CFString *a2, const __CFString *a3)
{
  return MEMORY[0x1F4179D10](this, a2, a3);
}

uint64_t caulk::concurrent::details::lf_read_sync_write_impl::end_mutate(caulk::concurrent::details::lf_read_sync_write_impl *this)
{
  return MEMORY[0x1F41778C0](this);
}

uint64_t caulk::concurrent::details::lf_read_sync_write_impl::begin_mutate(caulk::concurrent::details::lf_read_sync_write_impl *this)
{
  return MEMORY[0x1F41778C8](this);
}

uint64_t caulk::concurrent::details::lf_read_sync_write_impl::lf_read_sync_write_impl(caulk::concurrent::details::lf_read_sync_write_impl *this)
{
  return MEMORY[0x1F41778D0](this);
}

void caulk::concurrent::message::~message(caulk::concurrent::message *this)
{
}

uint64_t caulk::concurrent::messenger::enqueue(caulk::concurrent::messenger *this, caulk::concurrent::message *a2)
{
  return MEMORY[0x1F41778F8](this, a2);
}

uint64_t caulk::concurrent::messenger::messenger()
{
  return MEMORY[0x1F4177900]();
}

void caulk::concurrent::messenger::~messenger(caulk::concurrent::messenger *this)
{
}

uint64_t caulk::deferred_logger::create_message(caulk::deferred_logger *this, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4177918](this, a2, a3);
}

uint64_t caulk::deferred_logger::create_v(caulk::deferred_logger *this, void *a2)
{
  return MEMORY[0x1F4177920](this, a2);
}

uint64_t caulk::audio_buffer_resource(caulk *this)
{
  return MEMORY[0x1F4177940](this);
}

uint64_t caulk::pooled_semaphore_mutex::_lock(caulk::pooled_semaphore_mutex *this)
{
  return MEMORY[0x1F4177948](this);
}

uint64_t caulk::pooled_semaphore_mutex::_unlock(caulk::pooled_semaphore_mutex *this)
{
  return MEMORY[0x1F4177950](this);
}

uint64_t caulk::pooled_semaphore_mutex::try_lock(caulk::pooled_semaphore_mutex *this)
{
  return MEMORY[0x1F4177958](this);
}

uint64_t caulk::pooled_semaphore_mutex::pooled_semaphore_mutex(caulk::pooled_semaphore_mutex *this)
{
  return MEMORY[0x1F4177960](this);
}

uint64_t caulk::rt_safe_memory_resource::rt_allocate(caulk::rt_safe_memory_resource *this)
{
  return MEMORY[0x1F4177968](this);
}

uint64_t caulk::rt_safe_memory_resource::rt_deallocate(caulk::rt_safe_memory_resource *this, void *a2)
{
  return MEMORY[0x1F4177970](this, a2);
}

uint64_t caulk::init_realtime_safe_resource(caulk *this)
{
  return MEMORY[0x1F4177978](this);
}

uint64_t caulk::ipc::mapped_memory::reset(caulk::ipc::mapped_memory *this)
{
  return MEMORY[0x1F4177980](this);
}

uint64_t caulk::ipc::mapped_memory::mapped_memory()
{
  return MEMORY[0x1F4177988]();
}

uint64_t caulk::ipc::mapped_memory::mapped_memory(caulk::ipc::mapped_memory *this)
{
  return MEMORY[0x1F4177990](this);
}

uint64_t caulk::xpc::reply_watchdog_factory::make_timer(caulk::xpc::reply_watchdog_factory *this)
{
  return MEMORY[0x1F4177A10](this);
}

uint64_t caulk::xpc::reply_watchdog_factory::init2()
{
  return MEMORY[0x1F4177A18]();
}

uint64_t caulk::xpc::reply_watchdog_factory::reply_watchdog_factory(caulk::xpc::reply_watchdog_factory *this)
{
  return MEMORY[0x1F4177A20](this);
}

uint64_t caulk::mach::this_thread::set_priority()
{
  return MEMORY[0x1F4177A28]();
}

uint64_t caulk::mach::os_workgroup_managed::join(caulk::mach::os_workgroup_managed *this)
{
  return MEMORY[0x1F4177A58](this);
}

uint64_t caulk::mach::os_workgroup_managed::make()
{
  return MEMORY[0x1F4177A60]();
}

uint64_t caulk::mach::os_workgroup_managed::leave(caulk::mach::os_workgroup_managed *this)
{
  return MEMORY[0x1F4177A68](this);
}

void caulk::mach::os_workgroup_managed::~os_workgroup_managed(caulk::mach::os_workgroup_managed *this)
{
}

uint64_t caulk::mach::thread::get_base_priority(caulk::mach::thread *this, _opaque_pthread_t *a2)
{
  return MEMORY[0x1F4177AB0](this, a2);
}

uint64_t caulk::mach::details::retain_os_object(caulk::mach::details *this, void *a2)
{
  return MEMORY[0x1F4177AB8](this, a2);
}

uint64_t caulk::mach::details::release_os_object(caulk::mach::details *this, void *a2)
{
  return MEMORY[0x1F4177AC0](this, a2);
}

uint64_t caulk::alloc::global_page_cache::instance(caulk::alloc::global_page_cache *this)
{
  return MEMORY[0x1F4177B00](this);
}

uint64_t caulk::alloc::details::caching_page_allocator_base::deallocate()
{
  return MEMORY[0x1F4177B10]();
}

uint64_t caulk::alloc::details::caching_page_allocator_base::allocate(caulk::alloc::details::caching_page_allocator_base *this)
{
  return MEMORY[0x1F4177B18](this);
}

uint64_t caulk::thread::attributes::apply_to_this_thread(caulk::thread::attributes *this)
{
  return MEMORY[0x1F4177B20](this);
}

uint64_t caulk::thread::join(caulk::thread *this)
{
  return MEMORY[0x1F4177B28](this);
}

uint64_t caulk::thread::start(caulk::thread *this, caulk::thread::attributes *a2, void *(*a3)(void *), void *a4)
{
  return MEMORY[0x1F4177B30](this, a2, a3, a4);
}

void caulk::thread::~thread(caulk::thread *this)
{
}

uint64_t caulk::semaphore::timed_wait(caulk::semaphore *this, double a2)
{
  return MEMORY[0x1F4177B70](this, a2);
}

uint64_t caulk::semaphore::signal(caulk::semaphore *this)
{
  return MEMORY[0x1F4177B78](this);
}

uint64_t caulk::semaphore::semaphore(caulk::semaphore *this)
{
  return MEMORY[0x1F4177B80](this);
}

void caulk::semaphore::~semaphore(caulk::semaphore *this)
{
}

uint64_t RateRamp::OffsetTimes(RateRamp *this, double a2, double a3)
{
  return MEMORY[0x1F4179D68](this, a2, a3);
}

void RateRamp::RateRamp(RateRamp *this)
{
}

uint64_t TruePeak::Reset(TruePeak *this)
{
  return MEMORY[0x1F4179DA0](this);
}

uint64_t TruePeak::Process(TruePeak *this, uint64_t a2, const float *a3)
{
  return MEMORY[0x1F4179DA8](this, a2, a3);
}

void TruePeak::TruePeak(TruePeak *this)
{
}

uint64_t CACFArray::AppendData(CACFArray *this, const __CFData *a2)
{
  return MEMORY[0x1F4179DB8](this, a2);
}

uint64_t RamstadSRC::latencySeconds(RamstadSRC *this)
{
  return MEMORY[0x1F4179DD8](this);
}

uint64_t RamstadSRC::inputSamplesForOutputSamples(RamstadSRC *this)
{
  return MEMORY[0x1F4179DE0](this);
}

uint64_t RamstadSRC::outputSamplesForInputSamples(RamstadSRC *this, uint64_t a2, int *a3)
{
  return MEMORY[0x1F4179DE8](this, a2, a3);
}

uint64_t CACFDictionary::GetFloat32(CACFDictionary *this, const __CFString *a2, float *a3)
{
  return MEMORY[0x1F4179DF8](this, a2, a3);
}

uint64_t CACFDictionary::GetCACFArray(CACFDictionary *this, const __CFString *a2, CACFArray *a3)
{
  return MEMORY[0x1F4179E00](this, a2, a3);
}

uint64_t CACFDictionary::GetDictionary(CACFDictionary *this, const __CFString *a2, const __CFDictionary **a3)
{
  return MEMORY[0x1F4179E10](this, a2, a3);
}

uint64_t CACFDictionary::GetKeysAndValues(CACFDictionary *this, const void **a2, const void **a3)
{
  return MEMORY[0x1F4179E18](this, a2, a3);
}

uint64_t CACFDictionary::GetCACFDictionary(CACFDictionary *this, const __CFString *a2, CACFDictionary *a3)
{
  return MEMORY[0x1F4179E20](this, a2, a3);
}

uint64_t CACFDictionary::GetUInt32FromString(CACFDictionary *this, const __CFString *a2, unsigned int *a3)
{
  return MEMORY[0x1F4179E28](this, a2, a3);
}

uint64_t CACFDictionary::GetFloat32FromString(CACFDictionary *this, const __CFString *a2, float *a3)
{
  return MEMORY[0x1F4179E30](this, a2, a3);
}

uint64_t CACFDictionary::Size(CACFDictionary *this)
{
  return MEMORY[0x1F4179E38](this);
}

uint64_t CACFDictionary::HasKey(CACFDictionary *this, const __CFString *a2)
{
  return MEMORY[0x1F4179E48](this, a2);
}

uint64_t CACFDictionary::GetBool(CACFDictionary *this, const __CFString *a2, BOOL *a3)
{
  return MEMORY[0x1F4179E50](this, a2, a3);
}

uint64_t CACFDictionary::GetKeys(CACFDictionary *this, const void **a2)
{
  return MEMORY[0x1F4179E58](this, a2);
}

uint64_t CACFDictionary::GetString(CACFDictionary *this, const __CFString *a2, const __CFString **a3)
{
  return MEMORY[0x1F4179E68](this, a2, a3);
}

uint64_t CACFDictionary::GetUInt32(CACFDictionary *this, const __CFString *a2, unsigned int *a3)
{
  return MEMORY[0x1F4179E70](this, a2, a3);
}

uint64_t MultiRadixRealFFT::RealOutOfPlaceForwardTransform(MultiRadixRealFFT *this, const float *a2, DSPSplitComplex *a3, float a4)
{
  return MEMORY[0x1F4179E88](this, a2, a3, a4);
}

uint64_t MultiRadixRealFFT::RealOutOfPlaceInverseTransform(MultiRadixRealFFT *this, const DSPSplitComplex *a2, float *a3)
{
  return MEMORY[0x1F4179E90](this, a2, a3);
}

uint64_t CAAudioChannelLayout::operator==()
{
  return MEMORY[0x1F4179E98]();
}

uint64_t MIDI::EventList::size(MIDI::EventList *this)
{
  return MEMORY[0x1F40DB6A0](this);
}

uint64_t caulk::concurrent::details::lf_read_sync_write_impl::end_access(caulk::concurrent::details::lf_read_sync_write_impl *this)
{
  return MEMORY[0x1F4177B90](this);
}

uint64_t caulk::concurrent::details::lf_read_sync_write_impl::begin_access(caulk::concurrent::details::lf_read_sync_write_impl *this)
{
  return MEMORY[0x1F4177B98](this);
}

uint64_t caulk::ipc::mapped_memory::create_xpc_object(caulk::ipc::mapped_memory *this)
{
  return MEMORY[0x1F4177BA0](this);
}

uint64_t caulk::mach::os_workgroup_managed::copy_mach_port(caulk::mach::os_workgroup_managed *this)
{
  return MEMORY[0x1F4177BC0](this);
}

uint64_t RateRamp::InputDuration(RateRamp *this)
{
  return MEMORY[0x1F4179EB0](this);
}

uint64_t RateRamp::RateForOutputTime(RateRamp *this, double a2)
{
  return MEMORY[0x1F4179EB8](this, a2);
}

uint64_t RateRamp::InputTimeForOutputTime(RateRamp *this, double a2)
{
  return MEMORY[0x1F4179EC0](this, a2);
}

uint64_t RateRamp::Segment(RateRamp *this, double a2, double *a3, double a4, RateRamp *a5)
{
  return MEMORY[0x1F4179EC8](this, a3, a5, a2, a4);
}

uint64_t TruePeak::GetStats()
{
  return MEMORY[0x1F4179EE0]();
}

const char *__cdecl std::runtime_error::what(const std::runtime_error *this)
{
  return (const char *)MEMORY[0x1F417E350](this);
}

std::string *__cdecl std::error_code::message(std::string *__return_ptr retstr, const std::error_code *this)
{
  return (std::string *)MEMORY[0x1F417E360](retstr, this);
}

std::__fs::filesystem::path::__string_view std::__fs::filesystem::path::__filename(const std::__fs::filesystem::path *this)
{
  uint64_t v1 = (const std::string_view::value_type *)MEMORY[0x1F417E3C0](this);
  result.__size_ = v2;
  result.__data_ = v1;
  return result;
}

std::__fs::filesystem::path::__string_view std::__fs::filesystem::path::__root_directory(const std::__fs::filesystem::path *this)
{
  uint64_t v1 = (const std::string_view::value_type *)MEMORY[0x1F417E3D8](this);
  result.__size_ = v2;
  result.__data_ = v1;
  return result;
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x1F417E408](this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return (std::locale)MEMORY[0x1F417E418](this);
}

const char *__cdecl std::exception::what(const std::exception *this)
{
  return (const char *)MEMORY[0x1F417E430](this);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x1F417E438](this, a2);
}

{
  return (std::logic_error *)MEMORY[0x1F417E448](this, a2);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const char *a2)
{
  return (std::runtime_error *)MEMORY[0x1F417E4B8](this, a2);
}

{
  return (std::runtime_error *)MEMORY[0x1F417E4D0](this, a2);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const std::string *a2)
{
  return (std::runtime_error *)MEMORY[0x1F417E4D8](this, a2);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const std::runtime_error *a2)
{
  return (std::runtime_error *)MEMORY[0x1F417E4E0](this, a2);
}

void std::runtime_error::~runtime_error(std::runtime_error *this)
{
}

{
  MEMORY[0x1F417E4F0](this);
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x1F417E530](this);
}

void std::__call_once(std::once_flag::_State_type *a1, void *a2, void (__cdecl *a3)(void *))
{
}

void std::this_thread::sleep_for (const std::chrono::nanoseconds *__ns)
{
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x1F417E588](__n);
}

void std::string::__grow_by_and_replace(std::string *this, std::string::size_type __old_cap, std::string::size_type __delta_cap, std::string::size_type __old_sz, std::string::size_type __n_copy, std::string::size_type __n_del, std::string::size_type __n_add, const std::string::value_type *__p_new_stuff)
{
}

std::string *__cdecl std::string::erase(std::string *this, std::string::size_type __pos, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x1F417E5A0](this, __pos, __n);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x1F417E5C0](this, __s, __n);
}

std::string *__cdecl std::string::insert(std::string *this, std::string::size_type __pos, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x1F417E608](this, __pos, __s, __n);
}

void std::string::resize(std::string *this, std::string::size_type __n, std::string::value_type __c)
{
}

std::string *__cdecl std::string::replace(std::string *this, std::string::size_type __pos, std::string::size_type __n1, const std::string::value_type *__s, std::string::size_type __n2)
{
  return (std::string *)MEMORY[0x1F417E628](this, __pos, __n1, __s, __n2);
}

void std::string::reserve(std::string *this, std::string::size_type __requested_capacity)
{
}

void std::string::__grow_by(std::string *this, std::string::size_type __old_cap, std::string::size_type __delta_cap, std::string::size_type __old_sz, std::string::size_type __n_copy, std::string::size_type __n_del, std::string::size_type __n_add)
{
}

void std::string::push_back(std::string *this, std::string::value_type __c)
{
}

std::string *__cdecl std::string::basic_string(std::string *this, const std::string *__str, std::string::size_type __pos, std::string::size_type __n, std::allocator<char> *__a)
{
  return (std::string *)MEMORY[0x1F417E660](this, __str, __pos, __n, __a);
}

std::string *__cdecl std::string::operator=(std::string *this, const std::string *__str)
{
  return (std::string *)MEMORY[0x1F417E670](this, __str);
}

std::system_error *__cdecl std::system_error::system_error(std::system_error *this, int __ev, const std::error_category *__ecat, const char *__what_arg)
{
  return (std::system_error *)MEMORY[0x1F417E700](this, *(void *)&__ev, __ecat, __what_arg);
}

void std::system_error::~system_error(std::system_error *this)
{
}

uint64_t std::filebuf::open()
{
  return MEMORY[0x1F417E728]();
}

uint64_t std::filebuf::close()
{
  return MEMORY[0x1F417E730]();
}

uint64_t std::filebuf::basic_filebuf()
{
  return MEMORY[0x1F417E740]();
}

uint64_t std::filebuf::~filebuf()
{
  return MEMORY[0x1F417E748]();
}

uint64_t std::istream::~istream()
{
  return MEMORY[0x1F417E7C0]();
}

uint64_t std::istream::operator>>()
{
  return MEMORY[0x1F417E7E8]();
}

uint64_t std::ostream::sentry::sentry()
{
  return MEMORY[0x1F417E848]();
}

uint64_t std::ostream::sentry::~sentry()
{
  return MEMORY[0x1F417E850]();
}

uint64_t std::ostream::~ostream()
{
  return MEMORY[0x1F417E860]();
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x1F417E868]();
}

{
  return MEMORY[0x1F417E890]();
}

{
  return MEMORY[0x1F417E898]();
}

{
  return MEMORY[0x1F417E8A0]();
}

{
  return MEMORY[0x1F417E8B0]();
}

{
  return MEMORY[0x1F417E8B8]();
}

{
  return MEMORY[0x1F417E8C0]();
}

{
  return MEMORY[0x1F417E8C8]();
}

{
  return MEMORY[0x1F417E8D0]();
}

std::random_device *__cdecl std::random_device::random_device(std::random_device *this, const std::string *__token)
{
  return (std::random_device *)MEMORY[0x1F417E908](this, __token);
}

void std::random_device::~random_device(std::random_device *this)
{
}

std::random_device::result_type std::random_device::operator()(std::random_device *this)
{
  return MEMORY[0x1F417E918](this);
}

uint64_t std::iostream::~basic_iostream()
{
  return MEMORY[0x1F417E940]();
}

uint64_t std::ofstream::open()
{
  return MEMORY[0x1F417E948]();
}

void std::error_category::~error_category(std::error_category *this)
{
}

std::__thread_struct *__cdecl std::__thread_struct::__thread_struct(std::__thread_struct *this)
{
  return (std::__thread_struct *)MEMORY[0x1F417E968](this);
}

void std::__thread_struct::~__thread_struct(std::__thread_struct *this)
{
}

uint64_t std::streambuf::basic_streambuf()
{
  return MEMORY[0x1F417E978]();
}

uint64_t std::streambuf::~streambuf()
{
  return MEMORY[0x1F417E980]();
}

void std::recursive_mutex::lock(std::recursive_mutex *this)
{
}

void std::recursive_mutex::unlock(std::recursive_mutex *this)
{
}

std::recursive_mutex *__cdecl std::recursive_mutex::recursive_mutex(std::recursive_mutex *this)
{
  return (std::recursive_mutex *)MEMORY[0x1F417E9D0](this);
}

void std::recursive_mutex::~recursive_mutex(std::recursive_mutex *this)
{
}

const std::error_category *std::system_category(void)
{
  return (const std::error_category *)MEMORY[0x1F417E9E0]();
}

void std::condition_variable::notify_one(std::condition_variable *this)
{
}

void std::condition_variable::wait(std::condition_variable *this, std::unique_lock<std::mutex> *__lk)
{
}

void std::condition_variable::~condition_variable(std::condition_variable *this)
{
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
}

std::__shared_weak_count *__cdecl std::__shared_weak_count::lock(std::__shared_weak_count *this)
{
  return (std::__shared_weak_count *)MEMORY[0x1F417EA90](this);
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
}

std::__thread_specific_ptr<std::__thread_struct> *std::__thread_local_data(void)
{
  return (std::__thread_specific_ptr<std::__thread_struct> *)MEMORY[0x1F417EAA0]();
}

void std::__throw_system_error(int __ev, const char *__what_arg)
{
}

uint64_t std::pmr::get_default_resource(std::pmr *this)
{
  return MEMORY[0x1F417EAE0](this);
}

BOOL std::__fs::filesystem::__remove(const std::__fs::filesystem::path *a1, std::error_code *__ec)
{
  return MEMORY[0x1F417EBB8](a1, __ec);
}

std::__fs::filesystem::file_status std::__fs::filesystem::__status(const std::__fs::filesystem::path *a1, std::error_code *__ec)
{
  return (std::__fs::filesystem::file_status)MEMORY[0x1F417EBC8](a1, __ec);
}

float std::stof(const std::string *__str, size_t *__idx)
{
  MEMORY[0x1F417EBD8](__str, __idx);
  return result;
}

int std::stoi(const std::string *__str, size_t *__idx, int __base)
{
  return MEMORY[0x1F417EBE0](__str, __idx, *(void *)&__base);
}

void std::mutex::lock(std::mutex *this)
{
}

void std::mutex::unlock(std::mutex *this)
{
}

void std::mutex::~mutex(std::mutex *this)
{
}

unint64_t std::stoul(const std::string *__str, size_t *__idx, int __base)
{
  return MEMORY[0x1F417EC20](__str, __idx, *(void *)&__base);
}

std::chrono::steady_clock::time_point std::chrono::steady_clock::now(void)
{
  return (std::chrono::steady_clock::time_point)MEMORY[0x1F417EC90]();
}

void std::locale::~locale(std::locale *this)
{
}

unsigned int std::thread::hardware_concurrency(void)
{
  return MEMORY[0x1F417ED08]();
}

void std::thread::~thread(std::thread *this)
{
}

void std::ios_base::__set_badbit_and_consider_rethrow(std::ios_base *this)
{
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
}

uint64_t std::ios::~ios()
{
  return MEMORY[0x1F417EE40]();
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, double __val)
{
  return (std::string *)MEMORY[0x1F417EE58](retstr, __val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, float __val)
{
  return (std::string *)MEMORY[0x1F417EE68](retstr, __val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, int __val)
{
  return (std::string *)MEMORY[0x1F417EE70](retstr, *(void *)&__val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, unsigned int __val)
{
  return (std::string *)MEMORY[0x1F417EE78](retstr, *(void *)&__val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, uint64_t __val)
{
  return (std::string *)MEMORY[0x1F417EE80](retstr, __val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, unint64_t __val)
{
  return (std::string *)MEMORY[0x1F417EE88](retstr, __val);
}

{
  return (std::string *)MEMORY[0x1F417EE98](retstr, __val);
}

uint64_t std::operator+<char>()
{
  return MEMORY[0x1F417EEA0]();
}

std::bad_alloc *__cdecl std::bad_alloc::bad_alloc(std::bad_alloc *this)
{
  return (std::bad_alloc *)MEMORY[0x1F417EEC8](this);
}

void std::exception::~exception(std::exception *this)
{
}

int std::uncaught_exceptions(void)
{
  return MEMORY[0x1F417EF20]();
}

void std::terminate(void)
{
}

void operator delete[]()
{
  while (1)
    ;
}

void operator delete(void *__p)
{
  while (1)
    ;
}

void operator delete(void *__p, std::align_val_t a2)
{
  while (1)
    ;
}

void operator delete()
{
  while (1)
    ;
}

uint64_t operator<<()
{
  return MEMORY[0x1F4179F18]();
}

{
  return MEMORY[0x1F4179F20]();
}

{
  return MEMORY[0x1F4179F28]();
}

{
  return MEMORY[0x1F4179F30]();
}

{
  return MEMORY[0x1F4179F38]();
}

void operator new[]()
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz)
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz, std::align_val_t a2)
{
  while (1)
    ;
}

void operator new()
{
  while (1)
    ;
}

uint64_t operator>>()
{
  return MEMORY[0x1F4179F48]();
}

{
  return MEMORY[0x1F4179F50]();
}

{
  return MEMORY[0x1F4179F58]();
}

{
  return MEMORY[0x1F4179F60]();
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x1F417EF30](thrown_size);
}

int __cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle)
{
  return MEMORY[0x1F40C9B60](lpfunc, obj, lpdso_handle);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x1F417EF48](a1);
}

void __cxa_end_catch(void)
{
}

void __cxa_free_exception(void *a1)
{
}

void __cxa_guard_abort(__guard *a1)
{
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x1F417EF80](a1);
}

void __cxa_guard_release(__guard *a1)
{
}

void __cxa_rethrow(void)
{
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
}

int *__error(void)
{
  return (int *)MEMORY[0x1F40C9B88]();
}

float __exp10f(float a1)
{
  MEMORY[0x1F40C9B98](a1);
  return result;
}

uint64_t __invert_d3()
{
  return MEMORY[0x1F40C9BE0]();
}

int __maskrune(__darwin_ct_rune_t a1, unint64_t a2)
{
  return MEMORY[0x1F40C9C18](*(void *)&a1, a2);
}

uint64_t __memcpy_chk()
{
  return MEMORY[0x1F40C9C28]();
}

__double2 __sincos_stret(double a1)
{
  MEMORY[0x1F40C9C80](a1);
  result.__cosval = v2;
  result.__sinval = v1;
  return result;
}

__float2 __sincosf_stret(float a1)
{
  MEMORY[0x1F40C9C88](a1);
  result.__cosval = v2;
  result.__sinval = v1;
  return result;
}

__darwin_ct_rune_t __tolower(__darwin_ct_rune_t a1)
{
  return MEMORY[0x1F40C9CF8](*(void *)&a1);
}

__darwin_ct_rune_t __toupper(__darwin_ct_rune_t a1)
{
  return MEMORY[0x1F40C9D00](*(void *)&a1);
}

uint64_t __udivti3()
{
  return MEMORY[0x1F40C9D08]();
}

uint64_t _os_assert_log()
{
  return MEMORY[0x1F40C9F90]();
}

uint64_t _os_crash()
{
  return MEMORY[0x1F40C9FA0]();
}

uint64_t _os_feature_enabled_impl()
{
  return MEMORY[0x1F40C9FB0]();
}

void _os_log_debug_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

uint64_t _os_log_pack_fill()
{
  return MEMORY[0x1F40C9FE8]();
}

uint64_t _os_log_pack_size()
{
  return MEMORY[0x1F40C9FF0]();
}

void _os_signpost_emit_with_name_impl(void *dso, os_log_t log, os_signpost_type_t type, os_signpost_id_t spid, const char *name, const char *format, uint8_t *buf, uint32_t size)
{
}

uint64_t _set_user_dir_suffix()
{
  return MEMORY[0x1F40CA130]();
}

uint64_t _sl_dlopen()
{
  return MEMORY[0x1F415B160]();
}

uint64_t abort_report_np()
{
  return MEMORY[0x1F40CA1E8]();
}

uint64_t abort_with_reason()
{
  return MEMORY[0x1F40CA1F8]();
}

int access(const char *a1, int a2)
{
  return MEMORY[0x1F40CA210](a1, *(void *)&a2);
}

void audit_token_to_au32(audit_token_t *atoken, uid_t *auidp, uid_t *euidp, gid_t *egidp, uid_t *ruidp, gid_t *rgidp, pid_t *pidp, au_asid_t *asidp, au_tid_t *tidp)
{
}

pid_t audit_token_to_pid(audit_token_t *atoken)
{
  return MEMORY[0x1F417E2E8](atoken);
}

int audit_token_to_pidversion(audit_token_t *atoken)
{
  return MEMORY[0x1F417E2F0](atoken);
}

kern_return_t bootstrap_look_up(mach_port_t bp, const name_t service_name, mach_port_t *sp)
{
  return MEMORY[0x1F40CA548](*(void *)&bp, service_name, sp);
}

void bzero(void *a1, size_t a2)
{
}

BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)
{
  return MEMORY[0x1F41814C8](cls, name, imp, types);
}

IMP class_getMethodImplementation(Class cls, SEL name)
{
  return (IMP)MEMORY[0x1F4181540](cls, name);
}

const char *__cdecl class_getName(Class cls)
{
  return (const char *)MEMORY[0x1F4181548](cls);
}

objc_property_t class_getProperty(Class cls, const char *name)
{
  return (objc_property_t)MEMORY[0x1F4181550](cls, name);
}

Class class_getSuperclass(Class cls)
{
  return (Class)MEMORY[0x1F4181558](cls);
}

IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)
{
  return (IMP)MEMORY[0x1F4181578](cls, name, imp, types);
}

clock_t clock(void)
{
  return MEMORY[0x1F40CB3B8]();
}

int clock_gettime(clockid_t __clock_id, timespec *__tp)
{
  return MEMORY[0x1F40CB3D0](*(void *)&__clock_id, __tp);
}

int close(int a1)
{
  return MEMORY[0x1F40CB3F8](*(void *)&a1);
}

size_t confstr(int a1, char *a2, size_t a3)
{
  return MEMORY[0x1F40CB438](*(void *)&a1, a2, a3);
}

float cosf(float a1)
{
  MEMORY[0x1F40CB8B0](a1);
  return result;
}

void dispatch_activate(dispatch_object_t object)
{
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_assert_queue_not_V2(dispatch_queue_t queue)
{
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
}

void dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x1F40CBA60](identifier, flags);
}

void *__cdecl dispatch_get_specific(const void *key)
{
  return (void *)MEMORY[0x1F40CBA68](key);
}

void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_group_t dispatch_group_create(void)
{
  return (dispatch_group_t)MEMORY[0x1F40CBA88]();
}

intptr_t dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)
{
  return MEMORY[0x1F40CBAC0](group, timeout);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

void dispatch_once_f(dispatch_once_t *predicate, void *context, dispatch_function_t function)
{
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency(dispatch_queue_attr_t attr, dispatch_autorelease_frequency_t frequency)
{
  return (dispatch_queue_attr_t)MEMORY[0x1F40CBBA8](attr, frequency);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return (dispatch_queue_attr_t)MEMORY[0x1F40CBBB8](attr, *(void *)&qos_class, *(void *)&relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x1F40CBBC0](label, attr);
}

dispatch_queue_t dispatch_queue_create_with_target_V2(const char *label, dispatch_queue_attr_t attr, dispatch_queue_t target)
{
  return (dispatch_queue_t)MEMORY[0x1F40CBBD0](label, attr, target);
}

void dispatch_queue_set_specific(dispatch_queue_t queue, const void *key, void *context, dispatch_function_t destructor)
{
}

void dispatch_release(dispatch_object_t object)
{
}

void dispatch_resume(dispatch_object_t object)
{
}

void dispatch_retain(dispatch_object_t object)
{
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return (dispatch_semaphore_t)MEMORY[0x1F40CBC30](value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return MEMORY[0x1F40CBC40](dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return MEMORY[0x1F40CBC50](dsema, timeout);
}

void dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t queue)
{
}

void dispatch_source_cancel(dispatch_source_t source)
{
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return (dispatch_source_t)MEMORY[0x1F40CBC98](type, handle, mask, queue);
}

void dispatch_source_set_cancel_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
{
}

intptr_t dispatch_source_testcancel(dispatch_source_t source)
{
  return MEMORY[0x1F40CBCF8](source);
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x1F40CBD30](when, delta);
}

dispatch_workloop_t dispatch_workloop_create_inactive(const char *label)
{
  return (dispatch_workloop_t)MEMORY[0x1F40CBD58](label);
}

uint64_t dispatch_workloop_set_scheduler_priority()
{
  return MEMORY[0x1F40CBD88]();
}

char *dlerror(void)
{
  return (char *)MEMORY[0x1F40CBDB0]();
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return (void *)MEMORY[0x1F40CBDB8](__path, *(void *)&__mode);
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return (void *)MEMORY[0x1F40CBDC8](__handle, __symbol);
}

uint64_t dyld_program_sdk_at_least()
{
  return MEMORY[0x1F40CBEC8]();
}

void exit(int a1)
{
}

long double exp(long double __x)
{
  MEMORY[0x1F40CBFE0](__x);
  return result;
}

long double exp2(long double __x)
{
  MEMORY[0x1F40CBFE8](__x);
  return result;
}

int fclose(FILE *a1)
{
  return MEMORY[0x1F40CC050](a1);
}

int fcntl(int a1, int a2, ...)
{
  return MEMORY[0x1F40CC058](*(void *)&a1, *(void *)&a2);
}

int fflush(FILE *a1)
{
  return MEMORY[0x1F40CC0C8](a1);
}

float fmodf(float a1, float a2)
{
  MEMORY[0x1F40CC1A8](a1, a2);
  return result;
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x1F40CC1C0](__filename, __mode);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x1F40CC1D8](a1, a2);
}

int fputc(int a1, FILE *a2)
{
  return MEMORY[0x1F40CC1E8](*(void *)&a1, a2);
}

int fputs(const char *a1, FILE *a2)
{
  return MEMORY[0x1F40CC1F0](a1, a2);
}

size_t fread(void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x1F40CC200](__ptr, __size, __nitems, __stream);
}

void free(void *a1)
{
}

long double frexp(long double __x, int *__e)
{
  MEMORY[0x1F40CC248](__e, __x);
  return result;
}

int fseek(FILE *a1, uint64_t a2, int a3)
{
  return MEMORY[0x1F40CC290](a1, a2, *(void *)&a3);
}

int fstat(int a1, stat *a2)
{
  return MEMORY[0x1F40CC2B8](*(void *)&a1, a2);
}

uint64_t ftell(FILE *a1)
{
  return MEMORY[0x1F40CC2E0](a1);
}

int ftruncate(int a1, off_t a2)
{
  return MEMORY[0x1F40CC2F0](*(void *)&a1, a2);
}

FILE *__cdecl funopen(const void *a1, int (__cdecl *a2)(void *, char *, int), int (__cdecl *a3)(void *, const char *, int), fpos_t (__cdecl *a4)(void *, fpos_t, int), int (__cdecl *a5)(void *))
{
  return (FILE *)MEMORY[0x1F40CC320](a1, a2, a3, a4, a5);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x1F40CC338](__ptr, __size, __nitems, __stream);
}

char *__cdecl getenv(const char *a1)
{
  return (char *)MEMORY[0x1F40CC3B0](a1);
}

pid_t getpid(void)
{
  return MEMORY[0x1F40CC4A0]();
}

const char *getprogname(void)
{
  return (const char *)MEMORY[0x1F40CC4C0]();
}

int gettimeofday(timeval *a1, void *a2)
{
  return MEMORY[0x1F40CC568](a1, a2);
}

uid_t getuid(void)
{
  return MEMORY[0x1F40CC570]();
}

uint64_t kdebug_trace()
{
  return MEMORY[0x1F40CC700]();
}

long double ldexp(long double __x, int __e)
{
  MEMORY[0x1F40CC800](*(void *)&__e, __x);
  return result;
}

lconv *localeconv(void)
{
  return (lconv *)MEMORY[0x1F40CC858]();
}

tm *__cdecl localtime(const time_t *a1)
{
  return (tm *)MEMORY[0x1F40CC868](a1);
}

tm *__cdecl localtime_r(const time_t *a1, tm *a2)
{
  return (tm *)MEMORY[0x1F40CC870](a1, a2);
}

long double log(long double __x)
{
  MEMORY[0x1F40CC878](__x);
  return result;
}

long double log10(long double __x)
{
  MEMORY[0x1F40CC880](__x);
  return result;
}

float log10f(float a1)
{
  MEMORY[0x1F40CC888](a1);
  return result;
}

long double log2(long double __x)
{
  MEMORY[0x1F40CC8A8](__x);
  return result;
}

off_t lseek(int a1, off_t a2, int a3)
{
  return MEMORY[0x1F40CC8F8](*(void *)&a1, a2, *(void *)&a3);
}

uint64_t mach_absolute_time(void)
{
  return MEMORY[0x1F40CC910]();
}

char *__cdecl mach_error_string(mach_error_t error_value)
{
  return (char *)MEMORY[0x1F40CC940](*(void *)&error_value);
}

mach_msg_return_t mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify)
{
  return MEMORY[0x1F40CC970](msg, *(void *)&option, *(void *)&send_size, *(void *)&rcv_size, *(void *)&rcv_name, *(void *)&timeout, *(void *)&notify);
}

void mach_msg_destroy(mach_msg_header_t *a1)
{
}

kern_return_t mach_port_deallocate(ipc_space_t task, mach_port_name_t name)
{
  return MEMORY[0x1F40CC9B8](*(void *)&task, *(void *)&name);
}

kern_return_t mach_port_get_refs(ipc_space_t task, mach_port_name_t name, mach_port_right_t right, mach_port_urefs_t *refs)
{
  return MEMORY[0x1F40CC9F0](*(void *)&task, *(void *)&name, *(void *)&right, refs);
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return MEMORY[0x1F40CCA60](info);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCB90](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCB98](size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCBA8](ptr, size, type_id);
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x1F40CCCD8](__s, *(void *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x1F40CCCE8](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1F40CCCF0](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x1F40CCD10](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x1F40CCD20](__b, *(void *)&__c, __len);
}

void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
{
}

void mig_dealloc_reply_port(mach_port_t reply_port)
{
}

void mig_deallocate(vm_address_t a1, vm_size_t a2)
{
}

mach_port_t mig_get_reply_port(void)
{
  return MEMORY[0x1F40CCD70]();
}

void mig_put_reply_port(mach_port_t reply_port)
{
}

float nextafterf(float a1, float a2)
{
  MEMORY[0x1F40CD000](a1, a2);
  return result;
}

uint32_t notify_cancel(int token)
{
  return MEMORY[0x1F40CD028](*(void *)&token);
}

uint32_t notify_get_state(int token, uint64_t *state64)
{
  return MEMORY[0x1F40CD040](*(void *)&token, state64);
}

uint32_t notify_post(const char *name)
{
  return MEMORY[0x1F40CD050](name);
}

uint32_t notify_register_check(const char *name, int *out_token)
{
  return MEMORY[0x1F40CD058](name, out_token);
}

uint32_t notify_register_dispatch(const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
{
  return MEMORY[0x1F40CD060](name, out_token, queue, handler);
}

uint32_t notify_set_state(int token, uint64_t state64)
{
  return MEMORY[0x1F40CD088](*(void *)&token, state64);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x1F4181638](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x1F4181648]();
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x1F4181660](a1);
}

{
  MEMORY[0x1F4181668](context);
}

{
  return (void *)MEMORY[0x1F4181670]();
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x1F4181678](a1);
}

id objc_begin_catch(void *exc_buf)
{
  return (id)MEMORY[0x1F4181680](exc_buf);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x1F4181688]();
}

void objc_copyWeak(id *to, id *from)
{
}

void objc_destroyWeak(id *location)
{
}

void objc_end_catch(void)
{
}

void objc_enumerationMutation(id obj)
{
}

void objc_exception_throw(id exception)
{
}

Class objc_getClass(const char *name)
{
  return (Class)MEMORY[0x1F4181728](name);
}

id objc_initWeak(id *location, id val)
{
  return (id)MEMORY[0x1F4181758](location, val);
}

id objc_loadWeak(id *location)
{
  return (id)MEMORY[0x1F4181778](location);
}

id objc_loadWeakRetained(id *location)
{
  return (id)MEMORY[0x1F4181780](location);
}

Class objc_lookUpClass(const char *name)
{
  return (Class)MEMORY[0x1F4181788](name);
}

void objc_moveWeak(id *to, id *from)
{
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x1F41817A8](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x1F41817B0]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x1F41817B8]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x1F41817C0]();
}

uint64_t objc_opt_respondsToSelector()
{
  return MEMORY[0x1F41817C8]();
}

uint64_t self
{
  return MEMORY[0x1F41817D0]();
}

void objc_release(id a1)
{
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x1F41818B0](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x1F41818B8](a1);
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x1F41818C0](a1);
}

id objc_retainAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x1F41818C8](a1);
}

id objc_retainBlock(id a1)
{
  return (id)MEMORY[0x1F41818D0](a1);
}

void objc_setProperty_nonatomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_setProperty_nonatomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_storeStrong(id *location, id obj)
{
}

id objc_storeWeak(id *location, id obj)
{
  return (id)MEMORY[0x1F4181A18](location, obj);
}

int objc_sync_enter(id obj)
{
  return MEMORY[0x1F4181A28](obj);
}

int objc_sync_exit(id obj)
{
  return MEMORY[0x1F4181A30](obj);
}

id objc_unsafeClaimAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x1F4181A40](a1);
}

Class object_getClass(id a1)
{
  return (Class)MEMORY[0x1F4181A58](a1);
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x1F40CD0E0](a1, *(void *)&a2);
}

uint64_t os_eventlink_activate()
{
  return MEMORY[0x1F40CD2D0]();
}

uint64_t os_eventlink_associate()
{
  return MEMORY[0x1F40CD2D8]();
}

uint64_t os_eventlink_cancel()
{
  return MEMORY[0x1F40CD2E0]();
}

uint64_t os_eventlink_create()
{
  return MEMORY[0x1F40CD2E8]();
}

uint64_t os_eventlink_create_with_port()
{
  return MEMORY[0x1F40CD2F0]();
}

uint64_t os_eventlink_extract_remote_port()
{
  return MEMORY[0x1F40CD2F8]();
}

uint64_t os_eventlink_signal_and_wait()
{
  return MEMORY[0x1F40CD308]();
}

uint64_t os_eventlink_signal_and_wait_until()
{
  return MEMORY[0x1F40CD310]();
}

uint64_t os_eventlink_wait()
{
  return MEMORY[0x1F40CD318]();
}

uint64_t os_eventlink_wait_until()
{
  return MEMORY[0x1F40CD320]();
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x1F40CD360](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x1F40CD3B8](oslog, type);
}

void os_release(void *object)
{
}

void *__cdecl os_retain(void *object)
{
  return (void *)MEMORY[0x1F40CD548](object);
}

BOOL os_signpost_enabled(os_log_t log)
{
  return MEMORY[0x1F40CD550](log);
}

os_signpost_id_t os_signpost_id_generate(os_log_t log)
{
  return MEMORY[0x1F40CD558](log);
}

os_signpost_id_t os_signpost_id_make_with_pointer(os_log_t log, const void *ptr)
{
  return MEMORY[0x1F40CD560](log, ptr);
}

uint64_t os_state_add_handler()
{
  return MEMORY[0x1F40CD570]();
}

uint64_t os_state_remove_handler()
{
  return MEMORY[0x1F40CD578]();
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
}

BOOL os_unfair_lock_trylock(os_unfair_lock_t lock)
{
  return MEMORY[0x1F40CD5F0](lock);
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
}

uint64_t os_unfair_recursive_lock_lock_with_options()
{
  return MEMORY[0x1F40CD610]();
}

uint64_t os_unfair_recursive_lock_unlock()
{
  return MEMORY[0x1F40CD628]();
}

uint64_t os_variant_has_internal_diagnostics()
{
  return MEMORY[0x1F40CD650]();
}

uint64_t os_workgroup_attr_set_interval_type()
{
  return MEMORY[0x1F40CD680]();
}

int os_workgroup_copy_port(os_workgroup_t wg, mach_port_t *mach_port_out)
{
  return MEMORY[0x1F40CD698](wg, mach_port_out);
}

uint64_t os_workgroup_interval_copy_current_4AudioToolbox()
{
  return MEMORY[0x1F40CD6C0]();
}

uint64_t os_workgroup_interval_create_with_workload_id()
{
  return MEMORY[0x1F40CD6D0]();
}

long double pow(long double __x, long double __y)
{
  MEMORY[0x1F40CD818](__x, __y);
  return result;
}

float powf(float a1, float a2)
{
  MEMORY[0x1F40CD828](a1, a2);
  return result;
}

ssize_t pread(int __fd, void *__buf, size_t __nbyte, off_t a4)
{
  return MEMORY[0x1F40CD830](*(void *)&__fd, __buf, __nbyte, a4);
}

uint64_t proc_disable_wakemon()
{
  return MEMORY[0x1F40CD850]();
}

int proc_pid_rusage(int pid, int flavor, rusage_info_t *buffer)
{
  return MEMORY[0x1F40CD890](*(void *)&pid, *(void *)&flavor, buffer);
}

uint64_t proc_set_wakemon_defaults()
{
  return MEMORY[0x1F40CD8E8]();
}

const char *__cdecl property_getAttributes(objc_property_t property)
{
  return (const char *)MEMORY[0x1F4181AC8](property);
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return MEMORY[0x1F40CD9B8](a1, a2, a3, a4);
}

int pthread_main_np(void)
{
  return MEMORY[0x1F40CDA68]();
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return MEMORY[0x1F40CDA88](a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return MEMORY[0x1F40CDA98](a1);
}

int pthread_once(pthread_once_t *a1, void (*a2)(void))
{
  return MEMORY[0x1F40CDAC8](a1, a2);
}

pthread_t pthread_self(void)
{
  return (pthread_t)MEMORY[0x1F40CDB30]();
}

int pthread_setspecific(pthread_key_t a1, const void *a2)
{
  return MEMORY[0x1F40CDB70](a1, a2);
}

int pthread_threadid_np(pthread_t a1, __uint64_t *a2)
{
  return MEMORY[0x1F40CDB90](a1, a2);
}

int puts(const char *a1)
{
  return MEMORY[0x1F40CDBB8](a1);
}

ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t a4)
{
  return MEMORY[0x1F40CDBC0](*(void *)&__fd, __buf, __nbyte, a4);
}

ssize_t read(int a1, void *a2, size_t a3)
{
  return MEMORY[0x1F40CDC50](*(void *)&a1, a2, a3);
}

void *__cdecl reallocf(void *__ptr, size_t __size)
{
  return (void *)MEMORY[0x1F40CDC88](__ptr, __size);
}

uint64_t sandbox_check_by_audit_token()
{
  return MEMORY[0x1F40CDDD8]();
}

float scalbnf(float a1, int a2)
{
  MEMORY[0x1F40CDEA0](*(void *)&a2, a1);
  return result;
}

int sched_yield(void)
{
  return MEMORY[0x1F40CDEC8]();
}

SEL sel_registerName(const char *str)
{
  return (SEL)MEMORY[0x1F4181B48](str);
}

float sinf(float a1)
{
  MEMORY[0x1F40CE060](a1);
  return result;
}

unsigned int sleep(unsigned int a1)
{
  return MEMORY[0x1F40CE078](*(void *)&a1);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x1F40CE080](__str, __size, __format);
}

int sscanf(const char *a1, const char *a2, ...)
{
  return MEMORY[0x1F40CE0D0](a1, a2);
}

int stat(const char *a1, stat *a2)
{
  return MEMORY[0x1F40CE110](a1, a2);
}

char *__cdecl stpcpy(char *__dst, const char *__src)
{
  return (char *)MEMORY[0x1F40CE128](__dst, __src);
}

char *__cdecl stpncpy(char *__dst, const char *__src, size_t __n)
{
  return (char *)MEMORY[0x1F40CE130](__dst, __src, __n);
}

char *__cdecl strchr(char *__s, int __c)
{
  return (char *)MEMORY[0x1F40CE150](__s, *(void *)&__c);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x1F40CE158](__s1, __s2);
}

char *__cdecl strdup(const char *__s1)
{
  return (char *)MEMORY[0x1F40CE178](__s1);
}

size_t strftime(char *a1, size_t a2, const char *a3, const tm *a4)
{
  return MEMORY[0x1F40CE198](a1, a2, a3, a4);
}

size_t strlcat(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x1F40CE1A8](__dst, __source, __size);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x1F40CE1B0](__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1F40CE1C8](__s);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x1F40CE1F0](__s1, __s2, __n);
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  return (char *)MEMORY[0x1F40CE1F8](__dst, __src, __n);
}

size_t strnlen(const char *__s1, size_t __n)
{
  return MEMORY[0x1F40CE208](__s1, __n);
}

char *__cdecl strnstr(const char *__big, const char *__little, size_t __len)
{
  return (char *)MEMORY[0x1F40CE210](__big, __little, __len);
}

double strtod(const char *a1, char **a2)
{
  MEMORY[0x1F40CE260](a1, a2);
  return result;
}

float strtof(const char *a1, char **a2)
{
  MEMORY[0x1F40CE270](a1, a2);
  return result;
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1F40CE2A0](__str, __endptr, *(void *)&__base);
}

unint64_t strtoul(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1F40CE2E0](__str, __endptr, *(void *)&__base);
}

int sysctl(int *a1, u_int a2, void *a3, size_t *a4, void *a5, size_t a6)
{
  return MEMORY[0x1F40CE3C0](a1, *(void *)&a2, a3, a4, a5, a6);
}

void syslog(int a1, const char *a2, ...)
{
}

long double tan(long double __x)
{
  MEMORY[0x1F40CE420](__x);
  return result;
}

kern_return_t task_create_identity_token(task_t task, task_id_token_t *token)
{
  return MEMORY[0x1F40CE440](*(void *)&task, token);
}

kern_return_t task_get_special_port(task_inspect_t task, int which_port, mach_port_t *special_port)
{
  return MEMORY[0x1F40CE460](*(void *)&task, *(void *)&which_port, special_port);
}

kern_return_t task_info(task_name_t target_task, task_flavor_t flavor, task_info_t task_info_out, mach_msg_type_number_t *task_info_outCnt)
{
  return MEMORY[0x1F40CE470](*(void *)&target_task, *(void *)&flavor, task_info_out, task_info_outCnt);
}

uint64_t thread_selfcounts()
{
  return MEMORY[0x1F40CE550]();
}

time_t time(time_t *a1)
{
  return MEMORY[0x1F40CE588](a1);
}

int unsetenv(const char *a1)
{
  return MEMORY[0x1F40CE5F8](a1);
}

int usleep(useconds_t a1)
{
  return MEMORY[0x1F40CE608](*(void *)&a1);
}

void vDSP_biquad(const vDSP_biquad_SetupStruct *__Setup, float *__Delay, const float *__X, vDSP_Stride __IX, float *__Y, vDSP_Stride __IY, vDSP_Length __N)
{
}

vDSP_biquad_Setup vDSP_biquad_CreateSetup(const double *__Coefficients, vDSP_Length __M)
{
  return (vDSP_biquad_Setup)MEMORY[0x1F40D1990](__Coefficients, __M);
}

void vDSP_biquad_DestroySetup(vDSP_biquad_Setup __setup)
{
}

void vDSP_ctoz(const DSPComplex *__C, vDSP_Stride __IC, const DSPSplitComplex *__Z, vDSP_Stride __IZ, vDSP_Length __N)
{
}

void vDSP_distancesq(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Length __N)
{
}

void vDSP_dotpr(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Length __N)
{
}

void vDSP_dotprD(const double *__A, vDSP_Stride __IA, const double *__B, vDSP_Stride __IB, double *__C, vDSP_Length __N)
{
}

void vDSP_maxmgv(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Length __N)
{
}

void vDSP_maxv(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Length __N)
{
}

void vDSP_meanv(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Length __N)
{
}

void vDSP_meanvD(const double *__A, vDSP_Stride __IA, double *__C, vDSP_Length __N)
{
}

void vDSP_mmul(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Stride __IC, vDSP_Length __M, vDSP_Length __N, vDSP_Length __P)
{
}

void vDSP_svdiv(const float *__A, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_sve(const float *__A, vDSP_Stride __I, float *__C, vDSP_Length __N)
{
}

void vDSP_svesq(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Length __N)
{
}

void vDSP_vabs(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vadd(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vasm(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, const float *__C, float *__D, vDSP_Stride __ID, vDSP_Length __N)
{
}

void vDSP_vclip(const float *__A, vDSP_Stride __IA, const float *__B, const float *__C, float *__D, vDSP_Stride __ID, vDSP_Length __N)
{
}

void vDSP_vclr(float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vclrD(double *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vdiv(const float *__B, vDSP_Stride __IB, const float *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vfill(const float *__A, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vmax(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vmin(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vmul(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vrampmul(const float *__I, vDSP_Stride __IS, float *__Start, const float *__Step, float *__O, vDSP_Stride __OS, vDSP_Length __N)
{
}

void vDSP_vrampmuladd(const float *__I, vDSP_Stride __IS, float *__Start, const float *__Step, float *__O, vDSP_Stride __OS, vDSP_Length __N)
{
}

void vDSP_vsadd(const float *__A, vDSP_Stride __IA, const float *__B, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vsaddD(const double *__A, vDSP_Stride __IA, const double *__B, double *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vsma(const float *__A, vDSP_Stride __IA, const float *__B, const float *__C, vDSP_Stride __IC, float *__D, vDSP_Stride __ID, vDSP_Length __N)
{
}

void vDSP_vsmsma(const float *__A, vDSP_Stride __IA, const float *__B, const float *__C, vDSP_Stride __IC, const float *__D, float *__E, vDSP_Stride __IE, vDSP_Length __N)
{
}

void vDSP_vsmul(const float *__A, vDSP_Stride __IA, const float *__B, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vsorti(const float *__C, vDSP_Length *__I, vDSP_Length *__Temporary, vDSP_Length __N, int __Order)
{
}

void vDSP_vsub(const float *__B, vDSP_Stride __IB, const float *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_zrvadd(const DSPSplitComplex *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, const DSPSplitComplex *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_zrvdiv(const DSPSplitComplex *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, const DSPSplitComplex *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_zrvmul(const DSPSplitComplex *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, const DSPSplitComplex *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_zrvsub(const DSPSplitComplex *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, const DSPSplitComplex *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_ztoc(const DSPSplitComplex *__Z, vDSP_Stride __IZ, DSPComplex *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_zvabs(const DSPSplitComplex *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_zvadd(const DSPSplitComplex *__A, vDSP_Stride __IA, const DSPSplitComplex *__B, vDSP_Stride __IB, const DSPSplitComplex *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_zvdiv(const DSPSplitComplex *__B, vDSP_Stride __IB, const DSPSplitComplex *__A, vDSP_Stride __IA, const DSPSplitComplex *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_zvmul(const DSPSplitComplex *__A, vDSP_Stride __IA, const DSPSplitComplex *__B, vDSP_Stride __IB, const DSPSplitComplex *__C, vDSP_Stride __IC, vDSP_Length __N, int __Conjugate)
{
}

void vDSP_zvneg(const DSPSplitComplex *__A, vDSP_Stride __IA, const DSPSplitComplex *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_zvsub(const DSPSplitComplex *__A, vDSP_Stride __IA, const DSPSplitComplex *__B, vDSP_Stride __IB, const DSPSplitComplex *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

kern_return_t vm_allocate(vm_map_t target_task, vm_address_t *address, vm_size_t size, int flags)
{
  return MEMORY[0x1F40CE6A8](*(void *)&target_task, address, size, *(void *)&flags);
}

kern_return_t vm_deallocate(vm_map_t target_task, vm_address_t address, vm_size_t size)
{
  return MEMORY[0x1F40CE6C0](*(void *)&target_task, address, size);
}

uint64_t voucher_adopt()
{
  return MEMORY[0x1F40CE708]();
}

uint64_t voucher_copy()
{
  return MEMORY[0x1F40CE710]();
}

BOOLean_t voucher_mach_msg_set(mach_msg_header_t *msg)
{
  return MEMORY[0x1F40CE758](msg);
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  return MEMORY[0x1F40CE790](__str, __size, __format, a4);
}

size_t wcsnlen(const __int32 *a1, size_t a2)
{
  return MEMORY[0x1F40CE830](a1, a2);
}

__int32 *__cdecl wmemchr(__int32 *__s, __int32 __c, size_t __n)
{
  return (__int32 *)MEMORY[0x1F40CE8B0](__s, *(void *)&__c, __n);
}

xmlParserCtxtPtr xmlCreatePushParserCtxt(xmlSAXHandlerPtr sax, void *user_data, const char *chunk, int size, const char *filename)
{
  return (xmlParserCtxtPtr)MEMORY[0x1F4182620](sax, user_data, chunk, *(void *)&size, filename);
}

void xmlFreeParserCtxt(xmlParserCtxtPtr ctxt)
{
}

int xmlParseChunk(xmlParserCtxtPtr ctxt, const char *chunk, int size, int terminate)
{
  return MEMORY[0x1F41827E0](ctxt, chunk, *(void *)&size, *(void *)&terminate);
}

void xpc_array_append_value(xpc_object_t xarray, xpc_object_t value)
{
}

xpc_object_t xpc_array_create(xpc_object_t *objects, size_t count)
{
  return (xpc_object_t)MEMORY[0x1F40CEA30](objects, count);
}

size_t xpc_array_get_count(xpc_object_t xarray)
{
  return MEMORY[0x1F40CEA58](xarray);
}

xpc_object_t xpc_array_get_value(xpc_object_t xarray, size_t index)
{
  return (xpc_object_t)MEMORY[0x1F40CEAA8](xarray, index);
}

void xpc_connection_activate(xpc_connection_t connection)
{
}

xpc_connection_t xpc_connection_create(const char *name, dispatch_queue_t targetq)
{
  return (xpc_connection_t)MEMORY[0x1F40CEBA8](name, targetq);
}

xpc_connection_t xpc_connection_create_from_endpoint(xpc_endpoint_t endpoint)
{
  return (xpc_connection_t)MEMORY[0x1F40CEBC0](endpoint);
}

xpc_connection_t xpc_connection_create_mach_service(const char *name, dispatch_queue_t targetq, uint64_t flags)
{
  return (xpc_connection_t)MEMORY[0x1F40CEBD0](name, targetq, flags);
}

void xpc_connection_resume(xpc_connection_t connection)
{
}

xpc_object_t xpc_connection_send_message_with_reply_sync(xpc_connection_t connection, xpc_object_t message)
{
  return (xpc_object_t)MEMORY[0x1F40CEC68](connection, message);
}

xpc_object_t xpc_data_create(const void *bytes, size_t length)
{
  return (xpc_object_t)MEMORY[0x1F40CED90](bytes, length);
}

const void *__cdecl xpc_data_get_bytes_ptr(xpc_object_t xdata)
{
  return (const void *)MEMORY[0x1F40CEDB0](xdata);
}

size_t xpc_data_get_length(xpc_object_t xdata)
{
  return MEMORY[0x1F40CEDC0](xdata);
}

uint64_t xpc_dictionary_copy_mach_send()
{
  return MEMORY[0x1F40CEE18]();
}

xpc_object_t xpc_dictionary_create(const char *const *keys, xpc_object_t *values, size_t count)
{
  return (xpc_object_t)MEMORY[0x1F40CEE20](keys, values, count);
}

int xpc_dictionary_dup_fd(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1F40CEE50](xdict, key);
}

BOOL xpc_dictionary_get_BOOL(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1F40CEE80](xdict, key);
}

const void *__cdecl xpc_dictionary_get_data(xpc_object_t xdict, const char *key, size_t *length)
{
  return (const void *)MEMORY[0x1F40CEE98](xdict, key, length);
}

int64_t xpc_dictionary_get_int64(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1F40CEEC8](xdict, key);
}

uint64_t xpc_dictionary_get_uint64(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1F40CEEF8](xdict, key);
}

xpc_object_t xpc_dictionary_get_value(xpc_object_t xdict, const char *key)
{
  return (xpc_object_t)MEMORY[0x1F40CEF10](xdict, key);
}

void xpc_dictionary_set_BOOL(xpc_object_t xdict, const char *key, BOOL value)
{
}

void xpc_dictionary_set_data(xpc_object_t xdict, const char *key, const void *bytes, size_t length)
{
}

void xpc_dictionary_set_int64(xpc_object_t xdict, const char *key, int64_t value)
{
}

void xpc_dictionary_set_uint64(xpc_object_t xdict, const char *key, uint64_t value)
{
}

void xpc_dictionary_set_value(xpc_object_t xdict, const char *key, xpc_object_t value)
{
}

xpc_endpoint_t xpc_endpoint_create(xpc_connection_t connection)
{
  return (xpc_endpoint_t)MEMORY[0x1F40CF018](connection);
}

xpc_type_t xpc_get_type(xpc_object_t object)
{
  return (xpc_type_t)MEMORY[0x1F40CF148](object);
}

int64_t xpc_int64_get_value(xpc_object_t xint)
{
  return MEMORY[0x1F40CF190](xint);
}

uint64_t xpc_mach_send_copy_right()
{
  return MEMORY[0x1F40CF1C0]();
}

uint64_t xpc_mach_send_create()
{
  return MEMORY[0x1F40CF1C8]();
}

void xpc_main(xpc_connection_handler_t handler)
{
}

xpc_object_t xpc_null_create(void)
{
  return (xpc_object_t)MEMORY[0x1F40CF208]();
}

void xpc_release(xpc_object_t object)
{
}

xpc_object_t xpc_retain(xpc_object_t object)
{
  return (xpc_object_t)MEMORY[0x1F40CF248](object);
}

xpc_object_t xpc_string_create(const char *string)
{
  return (xpc_object_t)MEMORY[0x1F40CF290](string);
}

xpc_object_t xpc_uint64_create(uint64_t value)
{
  return (xpc_object_t)MEMORY[0x1F40CF320](value);
}

uint64_t xpc_uint64_get_value(xpc_object_t xuint)
{
  return MEMORY[0x1F40CF330](xuint);
}